{"buggy_code": ["/*\n * Copyright \u00a9 2007,2008,2009,2010  Red Hat, Inc.\n * Copyright \u00a9 2010,2012,2013  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Red Hat Author(s): Behdad Esfahbod\n * Google Author(s): Behdad Esfahbod\n */\n\n#ifndef HB_OT_LAYOUT_GPOS_TABLE_HH\n#define HB_OT_LAYOUT_GPOS_TABLE_HH\n\n#include \"hb-ot-layout-gsubgpos-private.hh\"\n\n\nnamespace OT {\n\n\n/* buffer **position** var allocations */\n#define attach_lookback() var.u16[0] /* number of glyphs to go back to attach this glyph to its base */\n#define cursive_chain() var.i16[1] /* character to which this connects, may be positive or negative */\n\n\n/* Shared Tables: ValueRecord, Anchor Table, and MarkArray */\n\ntypedef USHORT Value;\n\ntypedef Value ValueRecord[VAR];\n\nstruct ValueFormat : USHORT\n{\n  enum Flags {\n    xPlacement\t= 0x0001u,\t/* Includes horizontal adjustment for placement */\n    yPlacement\t= 0x0002u,\t/* Includes vertical adjustment for placement */\n    xAdvance\t= 0x0004u,\t/* Includes horizontal adjustment for advance */\n    yAdvance\t= 0x0008u,\t/* Includes vertical adjustment for advance */\n    xPlaDevice\t= 0x0010u,\t/* Includes horizontal Device table for placement */\n    yPlaDevice\t= 0x0020u,\t/* Includes vertical Device table for placement */\n    xAdvDevice\t= 0x0040u,\t/* Includes horizontal Device table for advance */\n    yAdvDevice\t= 0x0080u,\t/* Includes vertical Device table for advance */\n    ignored\t= 0x0F00u,\t/* Was used in TrueType Open for MM fonts */\n    reserved\t= 0xF000u,\t/* For future use */\n\n    devices\t= 0x00F0u\t/* Mask for having any Device table */\n  };\n\n/* All fields are options.  Only those available advance the value pointer. */\n#if 0\n  SHORT\t\txPlacement;\t\t/* Horizontal adjustment for\n\t\t\t\t\t * placement--in design units */\n  SHORT\t\tyPlacement;\t\t/* Vertical adjustment for\n\t\t\t\t\t * placement--in design units */\n  SHORT\t\txAdvance;\t\t/* Horizontal adjustment for\n\t\t\t\t\t * advance--in design units (only used\n\t\t\t\t\t * for horizontal writing) */\n  SHORT\t\tyAdvance;\t\t/* Vertical adjustment for advance--in\n\t\t\t\t\t * design units (only used for vertical\n\t\t\t\t\t * writing) */\n  Offset\txPlaDevice;\t\t/* Offset to Device table for\n\t\t\t\t\t * horizontal placement--measured from\n\t\t\t\t\t * beginning of PosTable (may be NULL) */\n  Offset\tyPlaDevice;\t\t/* Offset to Device table for vertical\n\t\t\t\t\t * placement--measured from beginning\n\t\t\t\t\t * of PosTable (may be NULL) */\n  Offset\txAdvDevice;\t\t/* Offset to Device table for\n\t\t\t\t\t * horizontal advance--measured from\n\t\t\t\t\t * beginning of PosTable (may be NULL) */\n  Offset\tyAdvDevice;\t\t/* Offset to Device table for vertical\n\t\t\t\t\t * advance--measured from beginning of\n\t\t\t\t\t * PosTable (may be NULL) */\n#endif\n\n  inline unsigned int get_len (void) const\n  { return _hb_popcount32 ((unsigned int) *this); }\n  inline unsigned int get_size (void) const\n  { return get_len () * Value::static_size; }\n\n  void apply_value (hb_font_t            *font,\n\t\t    hb_direction_t        direction,\n\t\t    const void           *base,\n\t\t    const Value          *values,\n\t\t    hb_glyph_position_t  &glyph_pos) const\n  {\n    unsigned int x_ppem, y_ppem;\n    unsigned int format = *this;\n    hb_bool_t horizontal = HB_DIRECTION_IS_HORIZONTAL (direction);\n\n    if (!format) return;\n\n    if (format & xPlacement) glyph_pos.x_offset  += font->em_scale_x (get_short (values++));\n    if (format & yPlacement) glyph_pos.y_offset  += font->em_scale_y (get_short (values++));\n    if (format & xAdvance) {\n      if (likely (horizontal)) glyph_pos.x_advance += font->em_scale_x (get_short (values));\n      values++;\n    }\n    /* y_advance values grow downward but font-space grows upward, hence negation */\n    if (format & yAdvance) {\n      if (unlikely (!horizontal)) glyph_pos.y_advance -= font->em_scale_y (get_short (values));\n      values++;\n    }\n\n    if (!has_device ()) return;\n\n    x_ppem = font->x_ppem;\n    y_ppem = font->y_ppem;\n\n    if (!x_ppem && !y_ppem) return;\n\n    /* pixel -> fractional pixel */\n    if (format & xPlaDevice) {\n      if (x_ppem) glyph_pos.x_offset  += (base + get_device (values)).get_x_delta (font);\n      values++;\n    }\n    if (format & yPlaDevice) {\n      if (y_ppem) glyph_pos.y_offset  += (base + get_device (values)).get_y_delta (font);\n      values++;\n    }\n    if (format & xAdvDevice) {\n      if (horizontal && x_ppem) glyph_pos.x_advance += (base + get_device (values)).get_x_delta (font);\n      values++;\n    }\n    if (format & yAdvDevice) {\n      /* y_advance values grow downward but font-space grows upward, hence negation */\n      if (!horizontal && y_ppem) glyph_pos.y_advance -= (base + get_device (values)).get_y_delta (font);\n      values++;\n    }\n  }\n\n  private:\n  inline bool sanitize_value_devices (hb_sanitize_context_t *c, const void *base, const Value *values) const\n  {\n    unsigned int format = *this;\n\n    if (format & xPlacement) values++;\n    if (format & yPlacement) values++;\n    if (format & xAdvance)   values++;\n    if (format & yAdvance)   values++;\n\n    if ((format & xPlaDevice) && !get_device (values++).sanitize (c, base)) return false;\n    if ((format & yPlaDevice) && !get_device (values++).sanitize (c, base)) return false;\n    if ((format & xAdvDevice) && !get_device (values++).sanitize (c, base)) return false;\n    if ((format & yAdvDevice) && !get_device (values++).sanitize (c, base)) return false;\n\n    return true;\n  }\n\n  static inline OffsetTo<Device>& get_device (Value* value)\n  { return *CastP<OffsetTo<Device> > (value); }\n  static inline const OffsetTo<Device>& get_device (const Value* value)\n  { return *CastP<OffsetTo<Device> > (value); }\n\n  static inline const SHORT& get_short (const Value* value)\n  { return *CastP<SHORT> (value); }\n\n  public:\n\n  inline bool has_device (void) const {\n    unsigned int format = *this;\n    return (format & devices) != 0;\n  }\n\n  inline bool sanitize_value (hb_sanitize_context_t *c, const void *base, const Value *values) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_range (values, get_size ()) && (!has_device () || sanitize_value_devices (c, base, values)));\n  }\n\n  inline bool sanitize_values (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count) const\n  {\n    TRACE_SANITIZE (this);\n    unsigned int len = get_len ();\n\n    if (!c->check_array (values, get_size (), count)) return TRACE_RETURN (false);\n\n    if (!has_device ()) return TRACE_RETURN (true);\n\n    for (unsigned int i = 0; i < count; i++) {\n      if (!sanitize_value_devices (c, base, values))\n        return TRACE_RETURN (false);\n      values += len;\n    }\n\n    return TRACE_RETURN (true);\n  }\n\n  /* Just sanitize referenced Device tables.  Doesn't check the values themselves. */\n  inline bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count, unsigned int stride) const\n  {\n    TRACE_SANITIZE (this);\n\n    if (!has_device ()) return TRACE_RETURN (true);\n\n    for (unsigned int i = 0; i < count; i++) {\n      if (!sanitize_value_devices (c, base, values))\n        return TRACE_RETURN (false);\n      values += stride;\n    }\n\n    return TRACE_RETURN (true);\n  }\n};\n\n\nstruct AnchorFormat1\n{\n  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id HB_UNUSED,\n\t\t\t  hb_position_t *x, hb_position_t *y) const\n  {\n      *x = font->em_scale_x (xCoordinate);\n      *y = font->em_scale_y (yCoordinate);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  SHORT\t\txCoordinate;\t\t/* Horizontal value--in design units */\n  SHORT\t\tyCoordinate;\t\t/* Vertical value--in design units */\n  public:\n  DEFINE_SIZE_STATIC (6);\n};\n\nstruct AnchorFormat2\n{\n  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id,\n\t\t\t  hb_position_t *x, hb_position_t *y) const\n  {\n      unsigned int x_ppem = font->x_ppem;\n      unsigned int y_ppem = font->y_ppem;\n      hb_position_t cx, cy;\n      hb_bool_t ret;\n\n      ret = (x_ppem || y_ppem) &&\n             font->get_glyph_contour_point_for_origin (glyph_id, anchorPoint, HB_DIRECTION_LTR, &cx, &cy);\n      *x = ret && x_ppem ? cx : font->em_scale_x (xCoordinate);\n      *y = ret && y_ppem ? cy : font->em_scale_y (yCoordinate);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  SHORT\t\txCoordinate;\t\t/* Horizontal value--in design units */\n  SHORT\t\tyCoordinate;\t\t/* Vertical value--in design units */\n  USHORT\tanchorPoint;\t\t/* Index to glyph contour point */\n  public:\n  DEFINE_SIZE_STATIC (8);\n};\n\nstruct AnchorFormat3\n{\n  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id HB_UNUSED,\n\t\t\t  hb_position_t *x, hb_position_t *y) const\n  {\n      *x = font->em_scale_x (xCoordinate);\n      *y = font->em_scale_y (yCoordinate);\n\n      if (font->x_ppem)\n\t*x += (this+xDeviceTable).get_x_delta (font);\n      if (font->y_ppem)\n\t*y += (this+yDeviceTable).get_x_delta (font);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && xDeviceTable.sanitize (c, this) && yDeviceTable.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 3 */\n  SHORT\t\txCoordinate;\t\t/* Horizontal value--in design units */\n  SHORT\t\tyCoordinate;\t\t/* Vertical value--in design units */\n  OffsetTo<Device>\n\t\txDeviceTable;\t\t/* Offset to Device table for X\n\t\t\t\t\t * coordinate-- from beginning of\n\t\t\t\t\t * Anchor table (may be NULL) */\n  OffsetTo<Device>\n\t\tyDeviceTable;\t\t/* Offset to Device table for Y\n\t\t\t\t\t * coordinate-- from beginning of\n\t\t\t\t\t * Anchor table (may be NULL) */\n  public:\n  DEFINE_SIZE_STATIC (10);\n};\n\nstruct Anchor\n{\n  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id,\n\t\t\t  hb_position_t *x, hb_position_t *y) const\n  {\n    *x = *y = 0;\n    switch (u.format) {\n    case 1: u.format1.get_anchor (font, glyph_id, x, y); return;\n    case 2: u.format2.get_anchor (font, glyph_id, x, y); return;\n    case 3: u.format3.get_anchor (font, glyph_id, x, y); return;\n    default:\t\t\t\t\t\t return;\n    }\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!u.format.sanitize (c)) return TRACE_RETURN (false);\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.sanitize (c));\n    case 2: return TRACE_RETURN (u.format2.sanitize (c));\n    case 3: return TRACE_RETURN (u.format3.sanitize (c));\n    default:return TRACE_RETURN (true);\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  AnchorFormat1\t\tformat1;\n  AnchorFormat2\t\tformat2;\n  AnchorFormat3\t\tformat3;\n  } u;\n  public:\n  DEFINE_SIZE_UNION (2, format);\n};\n\n\nstruct AnchorMatrix\n{\n  inline const Anchor& get_anchor (unsigned int row, unsigned int col, unsigned int cols, bool *found) const {\n    *found = false;\n    if (unlikely (row >= rows || col >= cols)) return Null(Anchor);\n    *found = !matrixZ[row * cols + col].is_null ();\n    return this+matrixZ[row * cols + col];\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c, unsigned int cols) const\n  {\n    TRACE_SANITIZE (this);\n    if (!c->check_struct (this)) return TRACE_RETURN (false);\n    if (unlikely (rows > 0 && cols >= ((unsigned int) -1) / rows)) return TRACE_RETURN (false);\n    unsigned int count = rows * cols;\n    if (!c->check_array (matrixZ, matrixZ[0].static_size, count)) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < count; i++)\n      if (!matrixZ[i].sanitize (c, this)) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  USHORT\trows;\t\t\t/* Number of rows */\n  protected:\n  OffsetTo<Anchor>\n\t\tmatrixZ[VAR];\t\t/* Matrix of offsets to Anchor tables--\n\t\t\t\t\t * from beginning of AnchorMatrix table */\n  public:\n  DEFINE_SIZE_ARRAY (2, matrixZ);\n};\n\n\nstruct MarkRecord\n{\n  friend struct MarkArray;\n\n  inline bool sanitize (hb_sanitize_context_t *c, const void *base) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && markAnchor.sanitize (c, base));\n  }\n\n  protected:\n  USHORT\tklass;\t\t\t/* Class defined for this mark */\n  OffsetTo<Anchor>\n\t\tmarkAnchor;\t\t/* Offset to Anchor table--from\n\t\t\t\t\t * beginning of MarkArray table */\n  public:\n  DEFINE_SIZE_STATIC (4);\n};\n\nstruct MarkArray : ArrayOf<MarkRecord>\t/* Array of MarkRecords--in Coverage order */\n{\n  inline bool apply (hb_apply_context_t *c,\n\t\t     unsigned int mark_index, unsigned int glyph_index,\n\t\t     const AnchorMatrix &anchors, unsigned int class_count,\n\t\t     unsigned int glyph_pos) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    const MarkRecord &record = ArrayOf<MarkRecord>::operator[](mark_index);\n    unsigned int mark_class = record.klass;\n\n    const Anchor& mark_anchor = this + record.markAnchor;\n    bool found;\n    const Anchor& glyph_anchor = anchors.get_anchor (glyph_index, mark_class, class_count, &found);\n    /* If this subtable doesn't have an anchor for this base and this class,\n     * return false such that the subsequent subtables have a chance at it. */\n    if (unlikely (!found)) return TRACE_RETURN (false);\n\n    hb_position_t mark_x, mark_y, base_x, base_y;\n\n    mark_anchor.get_anchor (c->font, buffer->cur().codepoint, &mark_x, &mark_y);\n    glyph_anchor.get_anchor (c->font, buffer->info[glyph_pos].codepoint, &base_x, &base_y);\n\n    hb_glyph_position_t &o = buffer->cur_pos();\n    o.x_offset = base_x - mark_x;\n    o.y_offset = base_y - mark_y;\n    o.attach_lookback() = buffer->idx - glyph_pos;\n\n    buffer->idx++;\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (ArrayOf<MarkRecord>::sanitize (c, this));\n  }\n};\n\n\n/* Lookups */\n\nstruct SinglePosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    valueFormat.apply_value (c->font, c->direction, this,\n\t\t\t     values, buffer->cur_pos());\n\n    buffer->idx++;\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this)\n        && coverage.sanitize (c, this)\n\t&& valueFormat.sanitize_value (c, this, values));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of subtable */\n  ValueFormat\tvalueFormat;\t\t/* Defines the types of data in the\n\t\t\t\t\t * ValueRecord */\n  ValueRecord\tvalues;\t\t\t/* Defines positioning\n\t\t\t\t\t * value(s)--applied to all glyphs in\n\t\t\t\t\t * the Coverage table */\n  public:\n  DEFINE_SIZE_ARRAY (6, values);\n};\n\nstruct SinglePosFormat2\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    if (likely (index >= valueCount)) return TRACE_RETURN (false);\n\n    valueFormat.apply_value (c->font, c->direction, this,\n\t\t\t     &values[index * valueFormat.get_len ()],\n\t\t\t     buffer->cur_pos());\n\n    buffer->idx++;\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this)\n\t&& coverage.sanitize (c, this)\n\t&& valueFormat.sanitize_values (c, this, values, valueCount));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of subtable */\n  ValueFormat\tvalueFormat;\t\t/* Defines the types of data in the\n\t\t\t\t\t * ValueRecord */\n  USHORT\tvalueCount;\t\t/* Number of ValueRecords */\n  ValueRecord\tvalues;\t\t\t/* Array of ValueRecords--positioning\n\t\t\t\t\t * values applied to glyphs */\n  public:\n  DEFINE_SIZE_ARRAY (8, values);\n};\n\nstruct SinglePos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    case 2: return TRACE_RETURN (c->dispatch (u.format2));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  SinglePosFormat1\tformat1;\n  SinglePosFormat2\tformat2;\n  } u;\n};\n\n\nstruct PairValueRecord\n{\n  friend struct PairSet;\n\n  protected:\n  GlyphID\tsecondGlyph;\t\t/* GlyphID of second glyph in the\n\t\t\t\t\t * pair--first glyph is listed in the\n\t\t\t\t\t * Coverage table */\n  ValueRecord\tvalues;\t\t\t/* Positioning data for the first glyph\n\t\t\t\t\t * followed by for second glyph */\n  public:\n  DEFINE_SIZE_ARRAY (2, values);\n};\n\nstruct PairSet\n{\n  friend struct PairPosFormat1;\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c,\n\t\t\t      const ValueFormat *valueFormats) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int len1 = valueFormats[0].get_len ();\n    unsigned int len2 = valueFormats[1].get_len ();\n    unsigned int record_size = USHORT::static_size * (1 + len1 + len2);\n\n    const PairValueRecord *record = CastP<PairValueRecord> (arrayZ);\n    unsigned int count = len;\n    for (unsigned int i = 0; i < count; i++)\n    {\n      c->input->add (record->secondGlyph);\n      record = &StructAtOffset<PairValueRecord> (record, record_size);\n    }\n  }\n\n  inline bool apply (hb_apply_context_t *c,\n\t\t     const ValueFormat *valueFormats,\n\t\t     unsigned int pos) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int len1 = valueFormats[0].get_len ();\n    unsigned int len2 = valueFormats[1].get_len ();\n    unsigned int record_size = USHORT::static_size * (1 + len1 + len2);\n\n    const PairValueRecord *record_array = CastP<PairValueRecord> (arrayZ);\n    unsigned int count = len;\n\n    /* Hand-coded bsearch. */\n    if (unlikely (!count))\n      return TRACE_RETURN (false);\n    hb_codepoint_t x = buffer->info[pos].codepoint;\n    int min = 0, max = (int) count - 1;\n    while (min <= max)\n    {\n      int mid = (min + max) / 2;\n      const PairValueRecord *record = &StructAtOffset<PairValueRecord> (record_array, record_size * mid);\n      hb_codepoint_t mid_x = record->secondGlyph;\n      if (x < mid_x)\n        max = mid - 1;\n      else if (x > mid_x)\n        min = mid + 1;\n      else\n      {\n\tvalueFormats[0].apply_value (c->font, c->direction, this,\n\t\t\t\t     &record->values[0], buffer->cur_pos());\n\tvalueFormats[1].apply_value (c->font, c->direction, this,\n\t\t\t\t     &record->values[len1], buffer->pos[pos]);\n\tif (len2)\n\t  pos++;\n\tbuffer->idx = pos;\n\treturn TRACE_RETURN (true);\n      }\n    }\n\n    return TRACE_RETURN (false);\n  }\n\n  struct sanitize_closure_t {\n    const void *base;\n    const ValueFormat *valueFormats;\n    unsigned int len1; /* valueFormats[0].get_len() */\n    unsigned int stride; /* 1 + len1 + len2 */\n  };\n\n  inline bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const\n  {\n    TRACE_SANITIZE (this);\n    if (!(c->check_struct (this)\n       && c->check_array (arrayZ, USHORT::static_size * closure->stride, len))) return TRACE_RETURN (false);\n\n    unsigned int count = len;\n    const PairValueRecord *record = CastP<PairValueRecord> (arrayZ);\n    return TRACE_RETURN (closure->valueFormats[0].sanitize_values_stride_unsafe (c, closure->base, &record->values[0], count, closure->stride)\n\t\t      && closure->valueFormats[1].sanitize_values_stride_unsafe (c, closure->base, &record->values[closure->len1], count, closure->stride));\n  }\n\n  protected:\n  USHORT\tlen;\t\t\t/* Number of PairValueRecords */\n  USHORT\tarrayZ[VAR];\t\t/* Array of PairValueRecords--ordered\n\t\t\t\t\t * by GlyphID of the second glyph */\n  public:\n  DEFINE_SIZE_ARRAY (2, arrayZ);\n};\n\nstruct PairPosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n    unsigned int count = pairSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+pairSet[i]).collect_glyphs (c, &valueFormat1);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    if (!skippy_iter.next ()) return TRACE_RETURN (false);\n\n    return TRACE_RETURN ((this+pairSet[index]).apply (c, &valueFormat1, skippy_iter.idx));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n\n    unsigned int len1 = valueFormat1.get_len ();\n    unsigned int len2 = valueFormat2.get_len ();\n    PairSet::sanitize_closure_t closure = {\n      this,\n      &valueFormat1,\n      len1,\n      1 + len1 + len2\n    };\n\n    return TRACE_RETURN (c->check_struct (this) && coverage.sanitize (c, this) && pairSet.sanitize (c, this, &closure));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of subtable */\n  ValueFormat\tvalueFormat1;\t\t/* Defines the types of data in\n\t\t\t\t\t * ValueRecord1--for the first glyph\n\t\t\t\t\t * in the pair--may be zero (0) */\n  ValueFormat\tvalueFormat2;\t\t/* Defines the types of data in\n\t\t\t\t\t * ValueRecord2--for the second glyph\n\t\t\t\t\t * in the pair--may be zero (0) */\n  OffsetArrayOf<PairSet>\n\t\tpairSet;\t\t/* Array of PairSet tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (10, pairSet);\n};\n\nstruct PairPosFormat2\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    /* (this+coverage).add_coverage (c->input); // Don't need this. */\n\n    unsigned int count1 = class1Count;\n    const ClassDef &klass1 = this+classDef1;\n    for (unsigned int i = 0; i < count1; i++)\n      klass1.add_class (c->input, i);\n\n    unsigned int count2 = class2Count;\n    const ClassDef &klass2 = this+classDef2;\n    for (unsigned int i = 0; i < count2; i++)\n      klass2.add_class (c->input, i);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    if (!skippy_iter.next ()) return TRACE_RETURN (false);\n\n    unsigned int len1 = valueFormat1.get_len ();\n    unsigned int len2 = valueFormat2.get_len ();\n    unsigned int record_len = len1 + len2;\n\n    unsigned int klass1 = (this+classDef1).get_class (buffer->cur().codepoint);\n    unsigned int klass2 = (this+classDef2).get_class (buffer->info[skippy_iter.idx].codepoint);\n    if (unlikely (klass1 >= class1Count || klass2 >= class2Count)) return TRACE_RETURN (false);\n\n    const Value *v = &values[record_len * (klass1 * class2Count + klass2)];\n    valueFormat1.apply_value (c->font, c->direction, this,\n\t\t\t      v, buffer->cur_pos());\n    valueFormat2.apply_value (c->font, c->direction, this,\n\t\t\t      v + len1, buffer->pos[skippy_iter.idx]);\n\n    buffer->idx = skippy_iter.idx;\n    if (len2)\n      buffer->idx++;\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!(c->check_struct (this)\n       && coverage.sanitize (c, this)\n       && classDef1.sanitize (c, this)\n       && classDef2.sanitize (c, this))) return TRACE_RETURN (false);\n\n    unsigned int len1 = valueFormat1.get_len ();\n    unsigned int len2 = valueFormat2.get_len ();\n    unsigned int stride = len1 + len2;\n    unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();\n    unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;\n    return TRACE_RETURN (c->check_array (values, record_size, count) &&\n\t\t\t valueFormat1.sanitize_values_stride_unsafe (c, this, &values[0], count, stride) &&\n\t\t\t valueFormat2.sanitize_values_stride_unsafe (c, this, &values[len1], count, stride));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of subtable */\n  ValueFormat\tvalueFormat1;\t\t/* ValueRecord definition--for the\n\t\t\t\t\t * first glyph of the pair--may be zero\n\t\t\t\t\t * (0) */\n  ValueFormat\tvalueFormat2;\t\t/* ValueRecord definition--for the\n\t\t\t\t\t * second glyph of the pair--may be\n\t\t\t\t\t * zero (0) */\n  OffsetTo<ClassDef>\n\t\tclassDef1;\t\t/* Offset to ClassDef table--from\n\t\t\t\t\t * beginning of PairPos subtable--for\n\t\t\t\t\t * the first glyph of the pair */\n  OffsetTo<ClassDef>\n\t\tclassDef2;\t\t/* Offset to ClassDef table--from\n\t\t\t\t\t * beginning of PairPos subtable--for\n\t\t\t\t\t * the second glyph of the pair */\n  USHORT\tclass1Count;\t\t/* Number of classes in ClassDef1\n\t\t\t\t\t * table--includes Class0 */\n  USHORT\tclass2Count;\t\t/* Number of classes in ClassDef2\n\t\t\t\t\t * table--includes Class0 */\n  ValueRecord\tvalues;\t\t\t/* Matrix of value pairs:\n\t\t\t\t\t * class1-major, class2-minor,\n\t\t\t\t\t * Each entry has value1 and value2 */\n  public:\n  DEFINE_SIZE_ARRAY (16, values);\n};\n\nstruct PairPos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    case 2: return TRACE_RETURN (c->dispatch (u.format2));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  PairPosFormat1\tformat1;\n  PairPosFormat2\tformat2;\n  } u;\n};\n\n\nstruct EntryExitRecord\n{\n  friend struct CursivePosFormat1;\n\n  inline bool sanitize (hb_sanitize_context_t *c, const void *base) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (entryAnchor.sanitize (c, base) && exitAnchor.sanitize (c, base));\n  }\n\n  protected:\n  OffsetTo<Anchor>\n\t\tentryAnchor;\t\t/* Offset to EntryAnchor table--from\n\t\t\t\t\t * beginning of CursivePos\n\t\t\t\t\t * subtable--may be NULL */\n  OffsetTo<Anchor>\n\t\texitAnchor;\t\t/* Offset to ExitAnchor table--from\n\t\t\t\t\t * beginning of CursivePos\n\t\t\t\t\t * subtable--may be NULL */\n  public:\n  DEFINE_SIZE_STATIC (4);\n};\n\nstatic void\nreverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent);\n\nstruct CursivePosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n\n    /* We don't handle mark glyphs here. */\n    if (unlikely (_hb_glyph_info_is_mark (&buffer->cur()))) return TRACE_RETURN (false);\n\n    const EntryExitRecord &this_record = entryExitRecord[(this+coverage).get_coverage  (buffer->cur().codepoint)];\n    if (!this_record.exitAnchor) return TRACE_RETURN (false);\n\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    if (!skippy_iter.next ()) return TRACE_RETURN (false);\n\n    const EntryExitRecord &next_record = entryExitRecord[(this+coverage).get_coverage  (buffer->info[skippy_iter.idx].codepoint)];\n    if (!next_record.entryAnchor) return TRACE_RETURN (false);\n\n    unsigned int i = buffer->idx;\n    unsigned int j = skippy_iter.idx;\n\n    hb_position_t entry_x, entry_y, exit_x, exit_y;\n    (this+this_record.exitAnchor).get_anchor (c->font, buffer->info[i].codepoint, &exit_x, &exit_y);\n    (this+next_record.entryAnchor).get_anchor (c->font, buffer->info[j].codepoint, &entry_x, &entry_y);\n\n    hb_glyph_position_t *pos = buffer->pos;\n\n    hb_position_t d;\n    /* Main-direction adjustment */\n    switch (c->direction) {\n      case HB_DIRECTION_LTR:\n\tpos[i].x_advance  =  exit_x + pos[i].x_offset;\n\n\td = entry_x + pos[j].x_offset;\n\tpos[j].x_advance -= d;\n\tpos[j].x_offset  -= d;\n\tbreak;\n      case HB_DIRECTION_RTL:\n\td = exit_x + pos[i].x_offset;\n\tpos[i].x_advance -= d;\n\tpos[i].x_offset  -= d;\n\n\tpos[j].x_advance  =  entry_x + pos[j].x_offset;\n\tbreak;\n      case HB_DIRECTION_TTB:\n\tpos[i].y_advance  =  exit_y + pos[i].y_offset;\n\n\td = entry_y + pos[j].y_offset;\n\tpos[j].y_advance -= d;\n\tpos[j].y_offset  -= d;\n\tbreak;\n      case HB_DIRECTION_BTT:\n\td = exit_y + pos[i].y_offset;\n\tpos[i].y_advance -= d;\n\tpos[i].y_offset  -= d;\n\n\tpos[j].y_advance  =  entry_y;\n\tbreak;\n      case HB_DIRECTION_INVALID:\n      default:\n\tbreak;\n    }\n\n    /* Cross-direction adjustment */\n\n    /* We attach child to parent (think graph theory and rooted trees whereas\n     * the root stays on baseline and each node aligns itself against its\n     * parent.\n     *\n     * Optimize things for the case of RightToLeft, as that's most common in\n     * Arabinc. */\n    unsigned int child  = i;\n    unsigned int parent = j;\n    hb_position_t x_offset = entry_x - exit_x;\n    hb_position_t y_offset = entry_y - exit_y;\n    if  (!(c->lookup_props & LookupFlag::RightToLeft))\n    {\n      unsigned int k = child;\n      child = parent;\n      parent = k;\n      x_offset = -x_offset;\n      y_offset = -y_offset;\n    }\n\n    /* If child was already connected to someone else, walk through its old\n     * chain and reverse the link direction, such that the whole tree of its\n     * previous connection now attaches to new parent.  Watch out for case\n     * where new parent is on the path from old chain...\n     */\n    reverse_cursive_minor_offset (pos, child, c->direction, parent);\n\n    pos[child].cursive_chain() = parent - child;\n    if (likely (HB_DIRECTION_IS_HORIZONTAL (c->direction)))\n      pos[child].y_offset = y_offset;\n    else\n      pos[child].x_offset = x_offset;\n\n    buffer->idx = j;\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && entryExitRecord.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of subtable */\n  ArrayOf<EntryExitRecord>\n\t\tentryExitRecord;\t/* Array of EntryExit records--in\n\t\t\t\t\t * Coverage Index order */\n  public:\n  DEFINE_SIZE_ARRAY (6, entryExitRecord);\n};\n\nstruct CursivePos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  CursivePosFormat1\tformat1;\n  } u;\n};\n\n\ntypedef AnchorMatrix BaseArray;\t\t/* base-major--\n\t\t\t\t\t * in order of BaseCoverage Index--,\n\t\t\t\t\t * mark-minor--\n\t\t\t\t\t * ordered by class--zero-based. */\n\nstruct MarkBasePosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+markCoverage).add_coverage (c->input);\n    (this+baseCoverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+markCoverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int mark_index = (this+markCoverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (mark_index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    /* now we search backwards for a non-mark glyph */\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);\n    do {\n      if (!skippy_iter.prev ()) return TRACE_RETURN (false);\n      /* We only want to attach to the first of a MultipleSubst sequence.  Reject others. */\n      if (0 == _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx])) break;\n      skippy_iter.reject ();\n    } while (1);\n\n    /* Checking that matched glyph is actually a base glyph by GDEF is too strong; disabled */\n    if (!_hb_glyph_info_is_base_glyph (&buffer->info[skippy_iter.idx])) { /*return TRACE_RETURN (false);*/ }\n\n    unsigned int base_index = (this+baseCoverage).get_coverage  (buffer->info[skippy_iter.idx].codepoint);\n    if (base_index == NOT_COVERED) return TRACE_RETURN (false);\n\n    return TRACE_RETURN ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && markCoverage.sanitize (c, this) && baseCoverage.sanitize (c, this) &&\n\t\t\t markArray.sanitize (c, this) && baseArray.sanitize (c, this, (unsigned int) classCount));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tmarkCoverage;\t\t/* Offset to MarkCoverage table--from\n\t\t\t\t\t * beginning of MarkBasePos subtable */\n  OffsetTo<Coverage>\n\t\tbaseCoverage;\t\t/* Offset to BaseCoverage table--from\n\t\t\t\t\t * beginning of MarkBasePos subtable */\n  USHORT\tclassCount;\t\t/* Number of classes defined for marks */\n  OffsetTo<MarkArray>\n\t\tmarkArray;\t\t/* Offset to MarkArray table--from\n\t\t\t\t\t * beginning of MarkBasePos subtable */\n  OffsetTo<BaseArray>\n\t\tbaseArray;\t\t/* Offset to BaseArray table--from\n\t\t\t\t\t * beginning of MarkBasePos subtable */\n  public:\n  DEFINE_SIZE_STATIC (12);\n};\n\nstruct MarkBasePos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  MarkBasePosFormat1\tformat1;\n  } u;\n};\n\n\ntypedef AnchorMatrix LigatureAttach;\t/* component-major--\n\t\t\t\t\t * in order of writing direction--,\n\t\t\t\t\t * mark-minor--\n\t\t\t\t\t * ordered by class--zero-based. */\n\ntypedef OffsetListOf<LigatureAttach> LigatureArray;\n\t\t\t\t\t/* Array of LigatureAttach\n\t\t\t\t\t * tables ordered by\n\t\t\t\t\t * LigatureCoverage Index */\n\nstruct MarkLigPosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+markCoverage).add_coverage (c->input);\n    (this+ligatureCoverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+markCoverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int mark_index = (this+markCoverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (mark_index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    /* now we search backwards for a non-mark glyph */\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);\n    if (!skippy_iter.prev ()) return TRACE_RETURN (false);\n\n    /* Checking that matched glyph is actually a ligature by GDEF is too strong; disabled */\n    if (!_hb_glyph_info_is_ligature (&buffer->info[skippy_iter.idx])) { /*return TRACE_RETURN (false);*/ }\n\n    unsigned int j = skippy_iter.idx;\n    unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer->info[j].codepoint);\n    if (lig_index == NOT_COVERED) return TRACE_RETURN (false);\n\n    const LigatureArray& lig_array = this+ligatureArray;\n    const LigatureAttach& lig_attach = lig_array[lig_index];\n\n    /* Find component to attach to */\n    unsigned int comp_count = lig_attach.rows;\n    if (unlikely (!comp_count)) return TRACE_RETURN (false);\n\n    /* We must now check whether the ligature ID of the current mark glyph\n     * is identical to the ligature ID of the found ligature.  If yes, we\n     * can directly use the component index.  If not, we attach the mark\n     * glyph to the last component of the ligature. */\n    unsigned int comp_index;\n    unsigned int lig_id = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n    unsigned int mark_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n    unsigned int mark_comp = _hb_glyph_info_get_lig_comp (&buffer->cur());\n    if (lig_id && lig_id == mark_id && mark_comp > 0)\n      comp_index = MIN (comp_count, _hb_glyph_info_get_lig_comp (&buffer->cur())) - 1;\n    else\n      comp_index = comp_count - 1;\n\n    return TRACE_RETURN ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && markCoverage.sanitize (c, this) && ligatureCoverage.sanitize (c, this) &&\n\t\t\t markArray.sanitize (c, this) && ligatureArray.sanitize (c, this, (unsigned int) classCount));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tmarkCoverage;\t\t/* Offset to Mark Coverage table--from\n\t\t\t\t\t * beginning of MarkLigPos subtable */\n  OffsetTo<Coverage>\n\t\tligatureCoverage;\t/* Offset to Ligature Coverage\n\t\t\t\t\t * table--from beginning of MarkLigPos\n\t\t\t\t\t * subtable */\n  USHORT\tclassCount;\t\t/* Number of defined mark classes */\n  OffsetTo<MarkArray>\n\t\tmarkArray;\t\t/* Offset to MarkArray table--from\n\t\t\t\t\t * beginning of MarkLigPos subtable */\n  OffsetTo<LigatureArray>\n\t\tligatureArray;\t\t/* Offset to LigatureArray table--from\n\t\t\t\t\t * beginning of MarkLigPos subtable */\n  public:\n  DEFINE_SIZE_STATIC (12);\n};\n\nstruct MarkLigPos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  MarkLigPosFormat1\tformat1;\n  } u;\n};\n\n\ntypedef AnchorMatrix Mark2Array;\t/* mark2-major--\n\t\t\t\t\t * in order of Mark2Coverage Index--,\n\t\t\t\t\t * mark1-minor--\n\t\t\t\t\t * ordered by class--zero-based. */\n\nstruct MarkMarkPosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+mark1Coverage).add_coverage (c->input);\n    (this+mark2Coverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+mark1Coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int mark1_index = (this+mark1Coverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (mark1_index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    /* now we search backwards for a suitable mark glyph until a non-mark glyph */\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    skippy_iter.set_lookup_props (c->lookup_props & ~LookupFlag::IgnoreFlags);\n    if (!skippy_iter.prev ()) return TRACE_RETURN (false);\n\n    if (!_hb_glyph_info_is_mark (&buffer->info[skippy_iter.idx])) { return TRACE_RETURN (false); }\n\n    unsigned int j = skippy_iter.idx;\n\n    unsigned int id1 = _hb_glyph_info_get_lig_id (&buffer->cur());\n    unsigned int id2 = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n    unsigned int comp1 = _hb_glyph_info_get_lig_comp (&buffer->cur());\n    unsigned int comp2 = _hb_glyph_info_get_lig_comp (&buffer->info[j]);\n\n    if (likely (id1 == id2)) {\n      if (id1 == 0) /* Marks belonging to the same base. */\n\tgoto good;\n      else if (comp1 == comp2) /* Marks belonging to the same ligature component. */\n        goto good;\n    } else {\n      /* If ligature ids don't match, it may be the case that one of the marks\n       * itself is a ligature.  In which case match. */\n      if ((id1 > 0 && !comp1) || (id2 > 0 && !comp2))\n\tgoto good;\n    }\n\n    /* Didn't match. */\n    return TRACE_RETURN (false);\n\n    good:\n    unsigned int mark2_index = (this+mark2Coverage).get_coverage  (buffer->info[j].codepoint);\n    if (mark2_index == NOT_COVERED) return TRACE_RETURN (false);\n\n    return TRACE_RETURN ((this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && mark1Coverage.sanitize (c, this) &&\n\t\t\t mark2Coverage.sanitize (c, this) && mark1Array.sanitize (c, this)\n\t\t\t && mark2Array.sanitize (c, this, (unsigned int) classCount));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tmark1Coverage;\t\t/* Offset to Combining Mark1 Coverage\n\t\t\t\t\t * table--from beginning of MarkMarkPos\n\t\t\t\t\t * subtable */\n  OffsetTo<Coverage>\n\t\tmark2Coverage;\t\t/* Offset to Combining Mark2 Coverage\n\t\t\t\t\t * table--from beginning of MarkMarkPos\n\t\t\t\t\t * subtable */\n  USHORT\tclassCount;\t\t/* Number of defined mark classes */\n  OffsetTo<MarkArray>\n\t\tmark1Array;\t\t/* Offset to Mark1Array table--from\n\t\t\t\t\t * beginning of MarkMarkPos subtable */\n  OffsetTo<Mark2Array>\n\t\tmark2Array;\t\t/* Offset to Mark2Array table--from\n\t\t\t\t\t * beginning of MarkMarkPos subtable */\n  public:\n  DEFINE_SIZE_STATIC (12);\n};\n\nstruct MarkMarkPos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  MarkMarkPosFormat1\tformat1;\n  } u;\n};\n\n\nstruct ContextPos : Context {};\n\nstruct ChainContextPos : ChainContext {};\n\nstruct ExtensionPos : Extension<ExtensionPos>\n{\n  typedef struct PosLookupSubTable LookupSubTable;\n};\n\n\n\n/*\n * PosLookup\n */\n\n\nstruct PosLookupSubTable\n{\n  friend struct PosLookup;\n\n  enum Type {\n    Single\t\t= 1,\n    Pair\t\t= 2,\n    Cursive\t\t= 3,\n    MarkBase\t\t= 4,\n    MarkLig\t\t= 5,\n    MarkMark\t\t= 6,\n    Context\t\t= 7,\n    ChainContext\t= 8,\n    Extension\t\t= 9\n  };\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const\n  {\n    TRACE_DISPATCH (this, lookup_type);\n    /* The sub_format passed to may_dispatch is unnecessary but harmless. */\n    if (unlikely (!c->may_dispatch (this, &u.sub_format))) TRACE_RETURN (c->default_return_value ());\n    switch (lookup_type) {\n    case Single:\t\treturn TRACE_RETURN (u.single.dispatch (c));\n    case Pair:\t\t\treturn TRACE_RETURN (u.pair.dispatch (c));\n    case Cursive:\t\treturn TRACE_RETURN (u.cursive.dispatch (c));\n    case MarkBase:\t\treturn TRACE_RETURN (u.markBase.dispatch (c));\n    case MarkLig:\t\treturn TRACE_RETURN (u.markLig.dispatch (c));\n    case MarkMark:\t\treturn TRACE_RETURN (u.markMark.dispatch (c));\n    case Context:\t\treturn TRACE_RETURN (u.context.dispatch (c));\n    case ChainContext:\t\treturn TRACE_RETURN (u.chainContext.dispatch (c));\n    case Extension:\t\treturn TRACE_RETURN (u.extension.dispatch (c));\n    default:\t\t\treturn TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tsub_format;\n  SinglePos\t\tsingle;\n  PairPos\t\tpair;\n  CursivePos\t\tcursive;\n  MarkBasePos\t\tmarkBase;\n  MarkLigPos\t\tmarkLig;\n  MarkMarkPos\t\tmarkMark;\n  ContextPos\t\tcontext;\n  ChainContextPos\tchainContext;\n  ExtensionPos\t\textension;\n  } u;\n  public:\n  DEFINE_SIZE_UNION (2, sub_format);\n};\n\n\nstruct PosLookup : Lookup\n{\n  inline const PosLookupSubTable& get_subtable (unsigned int i) const\n  { return Lookup::get_subtable<PosLookupSubTable> (i); }\n\n  inline bool is_reverse (void) const\n  {\n    return false;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    return TRACE_RETURN (dispatch (c));\n  }\n\n  inline hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    return TRACE_RETURN (dispatch (c));\n  }\n\n  template <typename set_t>\n  inline void add_coverage (set_t *glyphs) const\n  {\n    hb_add_coverage_context_t<set_t> c (glyphs);\n    dispatch (&c);\n  }\n\n  static bool apply_recurse_func (hb_apply_context_t *c, unsigned int lookup_index);\n\n  template <typename context_t>\n  static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  { return Lookup::dispatch<PosLookupSubTable> (c); }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (unlikely (!Lookup::sanitize (c))) return TRACE_RETURN (false);\n    return TRACE_RETURN (dispatch (c));\n  }\n};\n\ntypedef OffsetListOf<PosLookup> PosLookupList;\n\n/*\n * GPOS -- The Glyph Positioning Table\n */\n\nstruct GPOS : GSUBGPOS\n{\n  static const hb_tag_t tableTag\t= HB_OT_TAG_GPOS;\n\n  inline const PosLookup& get_lookup (unsigned int i) const\n  { return CastR<PosLookup> (GSUBGPOS::get_lookup (i)); }\n\n  static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);\n  static inline void position_finish (hb_font_t *font, hb_buffer_t *buffer);\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (unlikely (!GSUBGPOS::sanitize (c))) return TRACE_RETURN (false);\n    const OffsetTo<PosLookupList> &list = CastR<OffsetTo<PosLookupList> > (lookupList);\n    return TRACE_RETURN (list.sanitize (c, this));\n  }\n  public:\n  DEFINE_SIZE_STATIC (10);\n};\n\n\nstatic void\nreverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent)\n{\n  unsigned int j = pos[i].cursive_chain();\n  if (likely (!j))\n    return;\n\n  j += i;\n\n  pos[i].cursive_chain() = 0;\n\n  /* Stop if we see new parent in the chain. */\n  if (j == new_parent)\n    return;\n\n  reverse_cursive_minor_offset (pos, j, direction, new_parent);\n\n  if (HB_DIRECTION_IS_HORIZONTAL (direction))\n    pos[j].y_offset = -pos[i].y_offset;\n  else\n    pos[j].x_offset = -pos[i].x_offset;\n\n  pos[j].cursive_chain() = i - j;\n}\nstatic void\nfix_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction)\n{\n  unsigned int j = pos[i].cursive_chain();\n  if (likely (!j))\n    return;\n\n  j += i;\n\n  pos[i].cursive_chain() = 0;\n\n  fix_cursive_minor_offset (pos, j, direction);\n\n  if (HB_DIRECTION_IS_HORIZONTAL (direction))\n    pos[i].y_offset += pos[j].y_offset;\n  else\n    pos[i].x_offset += pos[j].x_offset;\n}\n\nstatic void\nfix_mark_attachment (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction)\n{\n  if (likely (!(pos[i].attach_lookback())))\n    return;\n\n  unsigned int j = i - pos[i].attach_lookback();\n\n  pos[i].x_offset += pos[j].x_offset;\n  pos[i].y_offset += pos[j].y_offset;\n\n  if (HB_DIRECTION_IS_FORWARD (direction))\n    for (unsigned int k = j; k < i; k++) {\n      pos[i].x_offset -= pos[k].x_advance;\n      pos[i].y_offset -= pos[k].y_advance;\n    }\n  else\n    for (unsigned int k = j + 1; k < i + 1; k++) {\n      pos[i].x_offset += pos[k].x_advance;\n      pos[i].y_offset += pos[k].y_advance;\n    }\n}\n\nvoid\nGPOS::position_start (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)\n{\n  buffer->clear_positions ();\n\n  unsigned int count = buffer->len;\n  for (unsigned int i = 0; i < count; i++)\n    buffer->pos[i].attach_lookback() = buffer->pos[i].cursive_chain() = 0;\n}\n\nvoid\nGPOS::position_finish (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)\n{\n  _hb_buffer_assert_gsubgpos_vars (buffer);\n\n  unsigned int len;\n  hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &len);\n  hb_direction_t direction = buffer->props.direction;\n\n  /* Handle cursive connections */\n  for (unsigned int i = 0; i < len; i++)\n    fix_cursive_minor_offset (pos, i, direction);\n\n  /* Handle attachments */\n  for (unsigned int i = 0; i < len; i++)\n    fix_mark_attachment (pos, i, direction);\n}\n\n\n/* Out-of-class implementation for methods recursing */\n\ntemplate <typename context_t>\n/*static*/ inline typename context_t::return_t PosLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)\n{\n  const GPOS &gpos = *(hb_ot_layout_from_face (c->face)->gpos);\n  const PosLookup &l = gpos.get_lookup (lookup_index);\n  return l.dispatch (c);\n}\n\n/*static*/ inline bool PosLookup::apply_recurse_func (hb_apply_context_t *c, unsigned int lookup_index)\n{\n  const GPOS &gpos = *(hb_ot_layout_from_face (c->face)->gpos);\n  const PosLookup &l = gpos.get_lookup (lookup_index);\n  unsigned int saved_lookup_props = c->lookup_props;\n  unsigned int saved_lookup_index = c->lookup_index;\n  c->set_lookup_index (lookup_index);\n  c->set_lookup_props (l.get_props ());\n  bool ret = l.dispatch (c);\n  c->set_lookup_index (saved_lookup_index);\n  c->set_lookup_props (saved_lookup_props);\n  return ret;\n}\n\n\n#undef attach_lookback\n#undef cursive_chain\n\n\n} /* namespace OT */\n\n\n#endif /* HB_OT_LAYOUT_GPOS_TABLE_HH */\n", "/*\n * Copyright \u00a9 2007,2008,2009,2010  Red Hat, Inc.\n * Copyright \u00a9 2010,2012,2013  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Red Hat Author(s): Behdad Esfahbod\n * Google Author(s): Behdad Esfahbod\n */\n\n#ifndef HB_OT_LAYOUT_GSUB_TABLE_HH\n#define HB_OT_LAYOUT_GSUB_TABLE_HH\n\n#include \"hb-ot-layout-gsubgpos-private.hh\"\n\n\nnamespace OT {\n\n\nstruct SingleSubstFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      hb_codepoint_t glyph_id = iter.get_glyph ();\n      if (c->glyphs->has (glyph_id))\n\tc->glyphs->add ((glyph_id + deltaGlyphID) & 0xFFFFu);\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      hb_codepoint_t glyph_id = iter.get_glyph ();\n      c->input->add (glyph_id);\n      c->output->add ((glyph_id + deltaGlyphID) & 0xFFFFu);\n    }\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    return TRACE_RETURN (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_codepoint_t glyph_id = c->buffer->cur().codepoint;\n    unsigned int index = (this+coverage).get_coverage (glyph_id);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    /* According to the Adobe Annotated OpenType Suite, result is always\n     * limited to 16bit. */\n    glyph_id = (glyph_id + deltaGlyphID) & 0xFFFFu;\n    c->replace_glyph (glyph_id);\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t unsigned int num_glyphs,\n\t\t\t int delta)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return TRACE_RETURN (false);\n    deltaGlyphID.set (delta); /* TODO(serilaize) overflow? */\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && deltaGlyphID.sanitize (c));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of Substitution table */\n  SHORT\t\tdeltaGlyphID;\t\t/* Add to original GlyphID to get\n\t\t\t\t\t * substitute GlyphID */\n  public:\n  DEFINE_SIZE_STATIC (6);\n};\n\nstruct SingleSubstFormat2\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      if (c->glyphs->has (iter.get_glyph ()))\n\tc->glyphs->add (substitute[iter.get_coverage ()]);\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      c->input->add (iter.get_glyph ());\n      c->output->add (substitute[iter.get_coverage ()]);\n    }\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    return TRACE_RETURN (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_codepoint_t glyph_id = c->buffer->cur().codepoint;\n    unsigned int index = (this+coverage).get_coverage (glyph_id);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    if (unlikely (index >= substitute.len)) return TRACE_RETURN (false);\n\n    glyph_id = substitute[index];\n    c->replace_glyph (glyph_id);\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<GlyphID> &substitutes,\n\t\t\t unsigned int num_glyphs)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!substitute.serialize (c, substitutes, num_glyphs))) return TRACE_RETURN (false);\n    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && substitute.sanitize (c));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of Substitution table */\n  ArrayOf<GlyphID>\n\t\tsubstitute;\t\t/* Array of substitute\n\t\t\t\t\t * GlyphIDs--ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, substitute);\n};\n\nstruct SingleSubst\n{\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<GlyphID> &substitutes,\n\t\t\t unsigned int num_glyphs)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (u.format))) return TRACE_RETURN (false);\n    unsigned int format = 2;\n    int delta = 0;\n    if (num_glyphs) {\n      format = 1;\n      /* TODO(serialize) check for wrap-around */\n      delta = substitutes[0] - glyphs[0];\n      for (unsigned int i = 1; i < num_glyphs; i++)\n\tif (delta != substitutes[i] - glyphs[i]) {\n\t  format = 2;\n\t  break;\n\t}\n    }\n    u.format.set (format);\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.serialize (c, glyphs, num_glyphs, delta));\n    case 2: return TRACE_RETURN (u.format2.serialize (c, glyphs, substitutes, num_glyphs));\n    default:return TRACE_RETURN (false);\n    }\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    case 2: return TRACE_RETURN (c->dispatch (u.format2));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  SingleSubstFormat1\tformat1;\n  SingleSubstFormat2\tformat2;\n  } u;\n};\n\n\nstruct Sequence\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    unsigned int count = substitute.len;\n    for (unsigned int i = 0; i < count; i++)\n      c->glyphs->add (substitute[i]);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int count = substitute.len;\n    for (unsigned int i = 0; i < count; i++)\n      c->output->add (substitute[i]);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int count = substitute.len;\n\n    /* TODO:\n     * Testing shows that Uniscribe actually allows zero-len susbstitute,\n     * which essentially deletes a glyph.  We don't allow for now.  It\n     * can be confusing to the client since the cluster from the deleted\n     * glyph won't be merged with any output cluster...  Also, currently\n     * buffer->move_to() makes assumptions about this too.  Perhaps fix\n     * in the future after figuring out what to do with the clusters.\n     */\n    if (unlikely (!count)) return TRACE_RETURN (false);\n\n    /* Special-case to make it in-place and not consider this\n     * as a \"multiplied\" substitution. */\n    if (unlikely (count == 1))\n    {\n      c->replace_glyph (substitute.array[0]);\n      return TRACE_RETURN (true);\n    }\n\n    unsigned int klass = _hb_glyph_info_is_ligature (&c->buffer->cur()) ?\n\t\t\t HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH : 0;\n\n    for (unsigned int i = 0; i < count; i++) {\n      _hb_glyph_info_set_lig_props_for_component (&c->buffer->cur(), i);\n      c->output_glyph_for_component (substitute.array[i], klass);\n    }\n    c->buffer->skip_glyph ();\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t unsigned int num_glyphs)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!substitute.serialize (c, glyphs, num_glyphs))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (substitute.sanitize (c));\n  }\n\n  protected:\n  ArrayOf<GlyphID>\n\t\tsubstitute;\t\t/* String of GlyphIDs to substitute */\n  public:\n  DEFINE_SIZE_ARRAY (2, substitute);\n};\n\nstruct MultipleSubstFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      if (c->glyphs->has (iter.get_glyph ()))\n\t(this+sequence[iter.get_coverage ()]).closure (c);\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n    unsigned int count = sequence.len;\n    for (unsigned int i = 0; i < count; i++)\n\t(this+sequence[i]).collect_glyphs (c);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    return TRACE_RETURN (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    return TRACE_RETURN ((this+sequence[index]).apply (c));\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<unsigned int> &substitute_len_list,\n\t\t\t unsigned int num_glyphs,\n\t\t\t Supplier<GlyphID> &substitute_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!sequence.serialize (c, num_glyphs))) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < num_glyphs; i++)\n      if (unlikely (!sequence[i].serialize (c, this).serialize (c,\n\t\t\t\t\t\t\t\tsubstitute_glyphs_list,\n\t\t\t\t\t\t\t\tsubstitute_len_list[i]))) return TRACE_RETURN (false);\n    substitute_len_list.advance (num_glyphs);\n    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && sequence.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of Substitution table */\n  OffsetArrayOf<Sequence>\n\t\tsequence;\t\t/* Array of Sequence tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, sequence);\n};\n\nstruct MultipleSubst\n{\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<unsigned int> &substitute_len_list,\n\t\t\t unsigned int num_glyphs,\n\t\t\t Supplier<GlyphID> &substitute_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (u.format))) return TRACE_RETURN (false);\n    unsigned int format = 1;\n    u.format.set (format);\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.serialize (c, glyphs, substitute_len_list, num_glyphs, substitute_glyphs_list));\n    default:return TRACE_RETURN (false);\n    }\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  MultipleSubstFormat1\tformat1;\n  } u;\n};\n\n\ntypedef ArrayOf<GlyphID> AlternateSet;\t/* Array of alternate GlyphIDs--in\n\t\t\t\t\t * arbitrary order */\n\nstruct AlternateSubstFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      if (c->glyphs->has (iter.get_glyph ())) {\n\tconst AlternateSet &alt_set = this+alternateSet[iter.get_coverage ()];\n\tunsigned int count = alt_set.len;\n\tfor (unsigned int i = 0; i < count; i++)\n\t  c->glyphs->add (alt_set[i]);\n      }\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      c->input->add (iter.get_glyph ());\n      const AlternateSet &alt_set = this+alternateSet[iter.get_coverage ()];\n      unsigned int count = alt_set.len;\n      for (unsigned int i = 0; i < count; i++)\n\tc->output->add (alt_set[i]);\n    }\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    return TRACE_RETURN (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_codepoint_t glyph_id = c->buffer->cur().codepoint;\n\n    unsigned int index = (this+coverage).get_coverage (glyph_id);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const AlternateSet &alt_set = this+alternateSet[index];\n\n    if (unlikely (!alt_set.len)) return TRACE_RETURN (false);\n\n    hb_mask_t glyph_mask = c->buffer->cur().mask;\n    hb_mask_t lookup_mask = c->lookup_mask;\n\n    /* Note: This breaks badly if two features enabled this lookup together. */\n    unsigned int shift = _hb_ctz (lookup_mask);\n    unsigned int alt_index = ((lookup_mask & glyph_mask) >> shift);\n\n    if (unlikely (alt_index > alt_set.len || alt_index == 0)) return TRACE_RETURN (false);\n\n    glyph_id = alt_set[alt_index - 1];\n\n    c->replace_glyph (glyph_id);\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<unsigned int> &alternate_len_list,\n\t\t\t unsigned int num_glyphs,\n\t\t\t Supplier<GlyphID> &alternate_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!alternateSet.serialize (c, num_glyphs))) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < num_glyphs; i++)\n      if (unlikely (!alternateSet[i].serialize (c, this).serialize (c,\n\t\t\t\t\t\t\t\t    alternate_glyphs_list,\n\t\t\t\t\t\t\t\t    alternate_len_list[i]))) return TRACE_RETURN (false);\n    alternate_len_list.advance (num_glyphs);\n    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && alternateSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of Substitution table */\n  OffsetArrayOf<AlternateSet>\n\t\talternateSet;\t\t/* Array of AlternateSet tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, alternateSet);\n};\n\nstruct AlternateSubst\n{\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<unsigned int> &alternate_len_list,\n\t\t\t unsigned int num_glyphs,\n\t\t\t Supplier<GlyphID> &alternate_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (u.format))) return TRACE_RETURN (false);\n    unsigned int format = 1;\n    u.format.set (format);\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.serialize (c, glyphs, alternate_len_list, num_glyphs, alternate_glyphs_list));\n    default:return TRACE_RETURN (false);\n    }\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  AlternateSubstFormat1\tformat1;\n  } u;\n};\n\n\nstruct Ligature\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    unsigned int count = component.len;\n    for (unsigned int i = 1; i < count; i++)\n      if (!c->glyphs->has (component[i]))\n        return;\n    c->glyphs->add (ligGlyph);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int count = component.len;\n    for (unsigned int i = 1; i < count; i++)\n      c->input->add (component[i]);\n    c->output->add (ligGlyph);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    if (c->len != component.len)\n      return TRACE_RETURN (false);\n\n    for (unsigned int i = 1; i < c->len; i++)\n      if (likely (c->glyphs[i] != component[i]))\n\treturn TRACE_RETURN (false);\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int count = component.len;\n\n    if (unlikely (!count)) return TRACE_RETURN (false);\n\n    /* Special-case to make it in-place and not consider this\n     * as a \"ligated\" substitution. */\n    if (unlikely (count == 1))\n    {\n      c->replace_glyph (ligGlyph);\n      return TRACE_RETURN (true);\n    }\n\n    bool is_mark_ligature = false;\n    unsigned int total_component_count = 0;\n\n    unsigned int match_length = 0;\n    unsigned int match_positions[MAX_CONTEXT_LENGTH];\n\n    if (likely (!match_input (c, count,\n\t\t\t      &component[1],\n\t\t\t      match_glyph,\n\t\t\t      NULL,\n\t\t\t      &match_length,\n\t\t\t      match_positions,\n\t\t\t      &is_mark_ligature,\n\t\t\t      &total_component_count)))\n      return TRACE_RETURN (false);\n\n    ligate_input (c,\n\t\t  count,\n\t\t  match_positions,\n\t\t  match_length,\n\t\t  ligGlyph,\n\t\t  is_mark_ligature,\n\t\t  total_component_count);\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t GlyphID ligature,\n\t\t\t Supplier<GlyphID> &components, /* Starting from second */\n\t\t\t unsigned int num_components /* Including first component */)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    ligGlyph = ligature;\n    if (unlikely (!component.serialize (c, components, num_components))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  public:\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (ligGlyph.sanitize (c) && component.sanitize (c));\n  }\n\n  protected:\n  GlyphID\tligGlyph;\t\t/* GlyphID of ligature to substitute */\n  HeadlessArrayOf<GlyphID>\n\t\tcomponent;\t\t/* Array of component GlyphIDs--start\n\t\t\t\t\t * with the second  component--ordered\n\t\t\t\t\t * in writing direction */\n  public:\n  DEFINE_SIZE_ARRAY (4, component);\n};\n\nstruct LigatureSet\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    unsigned int num_ligs = ligature.len;\n    for (unsigned int i = 0; i < num_ligs; i++)\n      (this+ligature[i]).closure (c);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int num_ligs = ligature.len;\n    for (unsigned int i = 0; i < num_ligs; i++)\n      (this+ligature[i]).collect_glyphs (c);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    unsigned int num_ligs = ligature.len;\n    for (unsigned int i = 0; i < num_ligs; i++)\n    {\n      const Ligature &lig = this+ligature[i];\n      if (lig.would_apply (c))\n        return TRACE_RETURN (true);\n    }\n    return TRACE_RETURN (false);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int num_ligs = ligature.len;\n    for (unsigned int i = 0; i < num_ligs; i++)\n    {\n      const Ligature &lig = this+ligature[i];\n      if (lig.apply (c)) return TRACE_RETURN (true);\n    }\n\n    return TRACE_RETURN (false);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &ligatures,\n\t\t\t Supplier<unsigned int> &component_count_list,\n\t\t\t unsigned int num_ligatures,\n\t\t\t Supplier<GlyphID> &component_list /* Starting from second for each ligature */)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!ligature.serialize (c, num_ligatures))) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < num_ligatures; i++)\n      if (unlikely (!ligature[i].serialize (c, this).serialize (c,\n\t\t\t\t\t\t\t\tligatures[i],\n\t\t\t\t\t\t\t\tcomponent_list,\n\t\t\t\t\t\t\t\tcomponent_count_list[i]))) return TRACE_RETURN (false);\n    ligatures.advance (num_ligatures);\n    component_count_list.advance (num_ligatures);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (ligature.sanitize (c, this));\n  }\n\n  protected:\n  OffsetArrayOf<Ligature>\n\t\tligature;\t\t/* Array LigatureSet tables\n\t\t\t\t\t * ordered by preference */\n  public:\n  DEFINE_SIZE_ARRAY (2, ligature);\n};\n\nstruct LigatureSubstFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      if (c->glyphs->has (iter.get_glyph ()))\n\t(this+ligatureSet[iter.get_coverage ()]).closure (c);\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      c->input->add (iter.get_glyph ());\n      (this+ligatureSet[iter.get_coverage ()]).collect_glyphs (c);\n    }\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    unsigned int index = (this+coverage).get_coverage (c->glyphs[0]);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const LigatureSet &lig_set = this+ligatureSet[index];\n    return TRACE_RETURN (lig_set.would_apply (c));\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_codepoint_t glyph_id = c->buffer->cur().codepoint;\n\n    unsigned int index = (this+coverage).get_coverage (glyph_id);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const LigatureSet &lig_set = this+ligatureSet[index];\n    return TRACE_RETURN (lig_set.apply (c));\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &first_glyphs,\n\t\t\t Supplier<unsigned int> &ligature_per_first_glyph_count_list,\n\t\t\t unsigned int num_first_glyphs,\n\t\t\t Supplier<GlyphID> &ligatures_list,\n\t\t\t Supplier<unsigned int> &component_count_list,\n\t\t\t Supplier<GlyphID> &component_list /* Starting from second for each ligature */)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!ligatureSet.serialize (c, num_first_glyphs))) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < num_first_glyphs; i++)\n      if (unlikely (!ligatureSet[i].serialize (c, this).serialize (c,\n\t\t\t\t\t\t\t\t   ligatures_list,\n\t\t\t\t\t\t\t\t   component_count_list,\n\t\t\t\t\t\t\t\t   ligature_per_first_glyph_count_list[i],\n\t\t\t\t\t\t\t\t   component_list))) return TRACE_RETURN (false);\n    ligature_per_first_glyph_count_list.advance (num_first_glyphs);\n    if (unlikely (!coverage.serialize (c, this).serialize (c, first_glyphs, num_first_glyphs))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && ligatureSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of Substitution table */\n  OffsetArrayOf<LigatureSet>\n\t\tligatureSet;\t\t/* Array LigatureSet tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, ligatureSet);\n};\n\nstruct LigatureSubst\n{\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &first_glyphs,\n\t\t\t Supplier<unsigned int> &ligature_per_first_glyph_count_list,\n\t\t\t unsigned int num_first_glyphs,\n\t\t\t Supplier<GlyphID> &ligatures_list,\n\t\t\t Supplier<unsigned int> &component_count_list,\n\t\t\t Supplier<GlyphID> &component_list /* Starting from second for each ligature */)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (u.format))) return TRACE_RETURN (false);\n    unsigned int format = 1;\n    u.format.set (format);\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.serialize (c, first_glyphs, ligature_per_first_glyph_count_list, num_first_glyphs,\n\t\t\t\t\t\t      ligatures_list, component_count_list, component_list));\n    default:return TRACE_RETURN (false);\n    }\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  LigatureSubstFormat1\tformat1;\n  } u;\n};\n\n\nstruct ContextSubst : Context {};\n\nstruct ChainContextSubst : ChainContext {};\n\nstruct ExtensionSubst : Extension<ExtensionSubst>\n{\n  typedef struct SubstLookupSubTable LookupSubTable;\n\n  inline bool is_reverse (void) const;\n};\n\n\nstruct ReverseChainSingleSubstFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n\n    unsigned int count;\n\n    count = backtrack.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (!(this+backtrack[i]).intersects (c->glyphs))\n        return;\n\n    count = lookahead.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (!(this+lookahead[i]).intersects (c->glyphs))\n        return;\n\n    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      if (c->glyphs->has (iter.get_glyph ()))\n\tc->glyphs->add (substitute[iter.get_coverage ()]);\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n\n    unsigned int count;\n\n    (this+coverage).add_coverage (c->input);\n\n    count = backtrack.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+backtrack[i]).add_coverage (c->before);\n\n    count = lookahead.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+lookahead[i]).add_coverage (c->after);\n\n    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n    count = substitute.len;\n    for (unsigned int i = 0; i < count; i++)\n      c->output->add (substitute[i]);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    return TRACE_RETURN (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    if (unlikely (c->nesting_level_left != MAX_NESTING_LEVEL))\n      return TRACE_RETURN (false); /* No chaining to this type */\n\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n\n    if (match_backtrack (c,\n\t\t\t backtrack.len, (USHORT *) backtrack.array,\n\t\t\t match_coverage, this) &&\n        match_lookahead (c,\n\t\t\t lookahead.len, (USHORT *) lookahead.array,\n\t\t\t match_coverage, this,\n\t\t\t 1))\n    {\n      c->replace_glyph_inplace (substitute[index]);\n      /* Note: We DON'T decrease buffer->idx.  The main loop does it\n       * for us.  This is useful for preventing surprises if someone\n       * calls us through a Context lookup. */\n      return TRACE_RETURN (true);\n    }\n\n    return TRACE_RETURN (false);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!(coverage.sanitize (c, this) && backtrack.sanitize (c, this)))\n      return TRACE_RETURN (false);\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n    if (!lookahead.sanitize (c, this))\n      return TRACE_RETURN (false);\n    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n    return TRACE_RETURN (substitute.sanitize (c));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of table */\n  OffsetArrayOf<Coverage>\n\t\tbacktrack;\t\t/* Array of coverage tables\n\t\t\t\t\t * in backtracking sequence, in  glyph\n\t\t\t\t\t * sequence order */\n  OffsetArrayOf<Coverage>\n\t\tlookaheadX;\t\t/* Array of coverage tables\n\t\t\t\t\t * in lookahead sequence, in glyph\n\t\t\t\t\t * sequence order */\n  ArrayOf<GlyphID>\n\t\tsubstituteX;\t\t/* Array of substitute\n\t\t\t\t\t * GlyphIDs--ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_MIN (10);\n};\n\nstruct ReverseChainSingleSubst\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\t\t\tformat;\t\t/* Format identifier */\n  ReverseChainSingleSubstFormat1\tformat1;\n  } u;\n};\n\n\n\n/*\n * SubstLookup\n */\n\nstruct SubstLookupSubTable\n{\n  friend struct SubstLookup;\n\n  enum Type {\n    Single\t\t= 1,\n    Multiple\t\t= 2,\n    Alternate\t\t= 3,\n    Ligature\t\t= 4,\n    Context\t\t= 5,\n    ChainContext\t= 6,\n    Extension\t\t= 7,\n    ReverseChainSingle\t= 8\n  };\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const\n  {\n    TRACE_DISPATCH (this, lookup_type);\n    /* The sub_format passed to may_dispatch is unnecessary but harmless. */\n    if (unlikely (!c->may_dispatch (this, &u.sub_format))) TRACE_RETURN (c->default_return_value ());\n    switch (lookup_type) {\n    case Single:\t\treturn TRACE_RETURN (u.single.dispatch (c));\n    case Multiple:\t\treturn TRACE_RETURN (u.multiple.dispatch (c));\n    case Alternate:\t\treturn TRACE_RETURN (u.alternate.dispatch (c));\n    case Ligature:\t\treturn TRACE_RETURN (u.ligature.dispatch (c));\n    case Context:\t\treturn TRACE_RETURN (u.context.dispatch (c));\n    case ChainContext:\t\treturn TRACE_RETURN (u.chainContext.dispatch (c));\n    case Extension:\t\treturn TRACE_RETURN (u.extension.dispatch (c));\n    case ReverseChainSingle:\treturn TRACE_RETURN (u.reverseChainContextSingle.dispatch (c));\n    default:\t\t\treturn TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\t\tsub_format;\n  SingleSubst\t\t\tsingle;\n  MultipleSubst\t\t\tmultiple;\n  AlternateSubst\t\talternate;\n  LigatureSubst\t\t\tligature;\n  ContextSubst\t\t\tcontext;\n  ChainContextSubst\t\tchainContext;\n  ExtensionSubst\t\textension;\n  ReverseChainSingleSubst\treverseChainContextSingle;\n  } u;\n  public:\n  DEFINE_SIZE_UNION (2, sub_format);\n};\n\n\nstruct SubstLookup : Lookup\n{\n  inline const SubstLookupSubTable& get_subtable (unsigned int i) const\n  { return Lookup::get_subtable<SubstLookupSubTable> (i); }\n\n  inline static bool lookup_type_is_reverse (unsigned int lookup_type)\n  { return lookup_type == SubstLookupSubTable::ReverseChainSingle; }\n\n  inline bool is_reverse (void) const\n  {\n    unsigned int type = get_type ();\n    if (unlikely (type == SubstLookupSubTable::Extension))\n      return CastR<ExtensionSubst> (get_subtable(0)).is_reverse ();\n    return lookup_type_is_reverse (type);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    return TRACE_RETURN (dispatch (c));\n  }\n\n  inline hb_closure_context_t::return_t closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    c->set_recurse_func (dispatch_recurse_func<hb_closure_context_t>);\n    return TRACE_RETURN (dispatch (c));\n  }\n\n  inline hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    c->set_recurse_func (dispatch_recurse_func<hb_collect_glyphs_context_t>);\n    return TRACE_RETURN (dispatch (c));\n  }\n\n  template <typename set_t>\n  inline void add_coverage (set_t *glyphs) const\n  {\n    hb_add_coverage_context_t<set_t> c (glyphs);\n    dispatch (&c);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c,\n\t\t\t   const hb_ot_layout_lookup_accelerator_t *accel) const\n  {\n    TRACE_WOULD_APPLY (this);\n    if (unlikely (!c->len))  return TRACE_RETURN (false);\n    if (!accel->may_have (c->glyphs[0]))  return TRACE_RETURN (false);\n      return TRACE_RETURN (dispatch (c));\n  }\n\n  static bool apply_recurse_func (hb_apply_context_t *c, unsigned int lookup_index);\n\n  inline SubstLookupSubTable& serialize_subtable (hb_serialize_context_t *c,\n\t\t\t\t\t\t  unsigned int i)\n  { return get_subtables<SubstLookupSubTable> ()[i].serialize (c, this); }\n\n  inline bool serialize_single (hb_serialize_context_t *c,\n\t\t\t\tuint32_t lookup_props,\n\t\t\t        Supplier<GlyphID> &glyphs,\n\t\t\t        Supplier<GlyphID> &substitutes,\n\t\t\t        unsigned int num_glyphs)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Single, lookup_props, 1))) return TRACE_RETURN (false);\n    return TRACE_RETURN (serialize_subtable (c, 0).u.single.serialize (c, glyphs, substitutes, num_glyphs));\n  }\n\n  inline bool serialize_multiple (hb_serialize_context_t *c,\n\t\t\t\t  uint32_t lookup_props,\n\t\t\t\t  Supplier<GlyphID> &glyphs,\n\t\t\t\t  Supplier<unsigned int> &substitute_len_list,\n\t\t\t\t  unsigned int num_glyphs,\n\t\t\t\t  Supplier<GlyphID> &substitute_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Multiple, lookup_props, 1))) return TRACE_RETURN (false);\n    return TRACE_RETURN (serialize_subtable (c, 0).u.multiple.serialize (c, glyphs, substitute_len_list, num_glyphs,\n\t\t\t\t\t\t\t\t\t substitute_glyphs_list));\n  }\n\n  inline bool serialize_alternate (hb_serialize_context_t *c,\n\t\t\t\t   uint32_t lookup_props,\n\t\t\t\t   Supplier<GlyphID> &glyphs,\n\t\t\t\t   Supplier<unsigned int> &alternate_len_list,\n\t\t\t\t   unsigned int num_glyphs,\n\t\t\t\t   Supplier<GlyphID> &alternate_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Alternate, lookup_props, 1))) return TRACE_RETURN (false);\n    return TRACE_RETURN (serialize_subtable (c, 0).u.alternate.serialize (c, glyphs, alternate_len_list, num_glyphs,\n\t\t\t\t\t\t\t\t\t  alternate_glyphs_list));\n  }\n\n  inline bool serialize_ligature (hb_serialize_context_t *c,\n\t\t\t\t  uint32_t lookup_props,\n\t\t\t\t  Supplier<GlyphID> &first_glyphs,\n\t\t\t\t  Supplier<unsigned int> &ligature_per_first_glyph_count_list,\n\t\t\t\t  unsigned int num_first_glyphs,\n\t\t\t\t  Supplier<GlyphID> &ligatures_list,\n\t\t\t\t  Supplier<unsigned int> &component_count_list,\n\t\t\t\t  Supplier<GlyphID> &component_list /* Starting from second for each ligature */)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Ligature, lookup_props, 1))) return TRACE_RETURN (false);\n    return TRACE_RETURN (serialize_subtable (c, 0).u.ligature.serialize (c, first_glyphs, ligature_per_first_glyph_count_list, num_first_glyphs,\n\t\t\t\t\t\t\t\t\t ligatures_list, component_count_list, component_list));\n  }\n\n  template <typename context_t>\n  static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  { return Lookup::dispatch<SubstLookupSubTable> (c); }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (unlikely (!Lookup::sanitize (c))) return TRACE_RETURN (false);\n    if (unlikely (!dispatch (c))) return TRACE_RETURN (false);\n\n    if (unlikely (get_type () == SubstLookupSubTable::Extension))\n    {\n      /* The spec says all subtables of an Extension lookup should\n       * have the same type.  This is specially important if one has\n       * a reverse type! */\n      unsigned int type = get_subtable (0).u.extension.get_type ();\n      unsigned int count = get_subtable_count ();\n      for (unsigned int i = 1; i < count; i++)\n        if (get_subtable (i).u.extension.get_type () != type)\n\t  return TRACE_RETURN (false);\n    }\n    return TRACE_RETURN (true);\n  }\n};\n\ntypedef OffsetListOf<SubstLookup> SubstLookupList;\n\n/*\n * GSUB -- The Glyph Substitution Table\n */\n\nstruct GSUB : GSUBGPOS\n{\n  static const hb_tag_t tableTag\t= HB_OT_TAG_GSUB;\n\n  inline const SubstLookup& get_lookup (unsigned int i) const\n  { return CastR<SubstLookup> (GSUBGPOS::get_lookup (i)); }\n\n  static inline void substitute_start (hb_font_t *font, hb_buffer_t *buffer);\n  static inline void substitute_finish (hb_font_t *font, hb_buffer_t *buffer);\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (unlikely (!GSUBGPOS::sanitize (c))) return TRACE_RETURN (false);\n    const OffsetTo<SubstLookupList> &list = CastR<OffsetTo<SubstLookupList> > (lookupList);\n    return TRACE_RETURN (list.sanitize (c, this));\n  }\n  public:\n  DEFINE_SIZE_STATIC (10);\n};\n\n\nvoid\nGSUB::substitute_start (hb_font_t *font, hb_buffer_t *buffer)\n{\n  _hb_buffer_assert_gsubgpos_vars (buffer);\n\n  const GDEF &gdef = *hb_ot_layout_from_face (font->face)->gdef;\n  unsigned int count = buffer->len;\n  for (unsigned int i = 0; i < count; i++)\n  {\n    _hb_glyph_info_set_glyph_props (&buffer->info[i], gdef.get_glyph_props (buffer->info[i].codepoint));\n    _hb_glyph_info_clear_lig_props (&buffer->info[i]);\n    buffer->info[i].syllable() = 0;\n  }\n}\n\nvoid\nGSUB::substitute_finish (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer HB_UNUSED)\n{\n}\n\n\n/* Out-of-class implementation for methods recursing */\n\n/*static*/ inline bool ExtensionSubst::is_reverse (void) const\n{\n  unsigned int type = get_type ();\n  if (unlikely (type == SubstLookupSubTable::Extension))\n    return CastR<ExtensionSubst> (get_subtable<LookupSubTable>()).is_reverse ();\n  return SubstLookup::lookup_type_is_reverse (type);\n}\n\ntemplate <typename context_t>\n/*static*/ inline typename context_t::return_t SubstLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)\n{\n  const GSUB &gsub = *(hb_ot_layout_from_face (c->face)->gsub);\n  const SubstLookup &l = gsub.get_lookup (lookup_index);\n  return l.dispatch (c);\n}\n\n/*static*/ inline bool SubstLookup::apply_recurse_func (hb_apply_context_t *c, unsigned int lookup_index)\n{\n  const GSUB &gsub = *(hb_ot_layout_from_face (c->face)->gsub);\n  const SubstLookup &l = gsub.get_lookup (lookup_index);\n  unsigned int saved_lookup_props = c->lookup_props;\n  unsigned int saved_lookup_index = c->lookup_index;\n  c->set_lookup_index (lookup_index);\n  c->set_lookup_props (l.get_props ());\n  bool ret = l.dispatch (c);\n  c->set_lookup_index (saved_lookup_index);\n  c->set_lookup_props (saved_lookup_props);\n  return ret;\n}\n\n\n} /* namespace OT */\n\n\n#endif /* HB_OT_LAYOUT_GSUB_TABLE_HH */\n", "/*\n * Copyright \u00a9 2007,2008,2009,2010  Red Hat, Inc.\n * Copyright \u00a9 2010,2012  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Red Hat Author(s): Behdad Esfahbod\n * Google Author(s): Behdad Esfahbod\n */\n\n#ifndef HB_OT_LAYOUT_GSUBGPOS_PRIVATE_HH\n#define HB_OT_LAYOUT_GSUBGPOS_PRIVATE_HH\n\n#include \"hb-buffer-private.hh\"\n#include \"hb-ot-layout-gdef-table.hh\"\n#include \"hb-set-private.hh\"\n\n\nnamespace OT {\n\n\n#ifndef HB_DEBUG_CLOSURE\n#define HB_DEBUG_CLOSURE (HB_DEBUG+0)\n#endif\n\n#define TRACE_CLOSURE(this) \\\n\thb_auto_trace_t<HB_DEBUG_CLOSURE, hb_void_t> trace \\\n\t(&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n\t \"\");\n\nstruct hb_closure_context_t\n{\n  inline const char *get_name (void) { return \"CLOSURE\"; }\n  static const unsigned int max_debug_depth = HB_DEBUG_CLOSURE;\n  typedef hb_void_t return_t;\n  typedef return_t (*recurse_func_t) (hb_closure_context_t *c, unsigned int lookup_index);\n  template <typename T, typename F>\n  inline bool may_dispatch (const T *obj, const F *format) { return true; }\n  template <typename T>\n  inline return_t dispatch (const T &obj) { obj.closure (this); return HB_VOID; }\n  static return_t default_return_value (void) { return HB_VOID; }\n  bool stop_sublookup_iteration (return_t r HB_UNUSED) const { return false; }\n  return_t recurse (unsigned int lookup_index)\n  {\n    if (unlikely (nesting_level_left == 0 || !recurse_func))\n      return default_return_value ();\n\n    nesting_level_left--;\n    recurse_func (this, lookup_index);\n    nesting_level_left++;\n    return HB_VOID;\n  }\n\n  hb_face_t *face;\n  hb_set_t *glyphs;\n  recurse_func_t recurse_func;\n  unsigned int nesting_level_left;\n  unsigned int debug_depth;\n\n  hb_closure_context_t (hb_face_t *face_,\n\t\t\thb_set_t *glyphs_,\n\t\t        unsigned int nesting_level_left_ = MAX_NESTING_LEVEL) :\n\t\t\t  face (face_),\n\t\t\t  glyphs (glyphs_),\n\t\t\t  recurse_func (NULL),\n\t\t\t  nesting_level_left (nesting_level_left_),\n\t\t\t  debug_depth (0) {}\n\n  void set_recurse_func (recurse_func_t func) { recurse_func = func; }\n};\n\n\n\n#ifndef HB_DEBUG_WOULD_APPLY\n#define HB_DEBUG_WOULD_APPLY (HB_DEBUG+0)\n#endif\n\n#define TRACE_WOULD_APPLY(this) \\\n\thb_auto_trace_t<HB_DEBUG_WOULD_APPLY, bool> trace \\\n\t(&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n\t \"%d glyphs\", c->len);\n\nstruct hb_would_apply_context_t\n{\n  inline const char *get_name (void) { return \"WOULD_APPLY\"; }\n  static const unsigned int max_debug_depth = HB_DEBUG_WOULD_APPLY;\n  typedef bool return_t;\n  template <typename T, typename F>\n  inline bool may_dispatch (const T *obj, const F *format) { return true; }\n  template <typename T>\n  inline return_t dispatch (const T &obj) { return obj.would_apply (this); }\n  static return_t default_return_value (void) { return false; }\n  bool stop_sublookup_iteration (return_t r) const { return r; }\n\n  hb_face_t *face;\n  const hb_codepoint_t *glyphs;\n  unsigned int len;\n  bool zero_context;\n  unsigned int debug_depth;\n\n  hb_would_apply_context_t (hb_face_t *face_,\n\t\t\t    const hb_codepoint_t *glyphs_,\n\t\t\t    unsigned int len_,\n\t\t\t    bool zero_context_) :\n\t\t\t      face (face_),\n\t\t\t      glyphs (glyphs_),\n\t\t\t      len (len_),\n\t\t\t      zero_context (zero_context_),\n\t\t\t      debug_depth (0) {}\n};\n\n\n\n#ifndef HB_DEBUG_COLLECT_GLYPHS\n#define HB_DEBUG_COLLECT_GLYPHS (HB_DEBUG+0)\n#endif\n\n#define TRACE_COLLECT_GLYPHS(this) \\\n\thb_auto_trace_t<HB_DEBUG_COLLECT_GLYPHS, hb_void_t> trace \\\n\t(&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n\t \"\");\n\nstruct hb_collect_glyphs_context_t\n{\n  inline const char *get_name (void) { return \"COLLECT_GLYPHS\"; }\n  static const unsigned int max_debug_depth = HB_DEBUG_COLLECT_GLYPHS;\n  typedef hb_void_t return_t;\n  typedef return_t (*recurse_func_t) (hb_collect_glyphs_context_t *c, unsigned int lookup_index);\n  template <typename T, typename F>\n  inline bool may_dispatch (const T *obj, const F *format) { return true; }\n  template <typename T>\n  inline return_t dispatch (const T &obj) { obj.collect_glyphs (this); return HB_VOID; }\n  static return_t default_return_value (void) { return HB_VOID; }\n  bool stop_sublookup_iteration (return_t r HB_UNUSED) const { return false; }\n  return_t recurse (unsigned int lookup_index)\n  {\n    if (unlikely (nesting_level_left == 0 || !recurse_func))\n      return default_return_value ();\n\n    /* Note that GPOS sets recurse_func to NULL already, so it doesn't get\n     * past the previous check.  For GSUB, we only want to collect the output\n     * glyphs in the recursion.  If output is not requested, we can go home now.\n     *\n     * Note further, that the above is not exactly correct.  A recursed lookup\n     * is allowed to match input that is not matched in the context, but that's\n     * not how most fonts are built.  It's possible to relax that and recurse\n     * with all sets here if it proves to be an issue.\n     */\n\n    if (output == hb_set_get_empty ())\n      return HB_VOID;\n\n    /* Return if new lookup was recursed to before. */\n    if (recursed_lookups.has (lookup_index))\n      return HB_VOID;\n\n    hb_set_t *old_before = before;\n    hb_set_t *old_input  = input;\n    hb_set_t *old_after  = after;\n    before = input = after = hb_set_get_empty ();\n\n    nesting_level_left--;\n    recurse_func (this, lookup_index);\n    nesting_level_left++;\n\n    before = old_before;\n    input  = old_input;\n    after  = old_after;\n\n    recursed_lookups.add (lookup_index);\n\n    return HB_VOID;\n  }\n\n  hb_face_t *face;\n  hb_set_t *before;\n  hb_set_t *input;\n  hb_set_t *after;\n  hb_set_t *output;\n  recurse_func_t recurse_func;\n  hb_set_t recursed_lookups;\n  unsigned int nesting_level_left;\n  unsigned int debug_depth;\n\n  hb_collect_glyphs_context_t (hb_face_t *face_,\n\t\t\t       hb_set_t  *glyphs_before, /* OUT. May be NULL */\n\t\t\t       hb_set_t  *glyphs_input,  /* OUT. May be NULL */\n\t\t\t       hb_set_t  *glyphs_after,  /* OUT. May be NULL */\n\t\t\t       hb_set_t  *glyphs_output, /* OUT. May be NULL */\n\t\t\t       unsigned int nesting_level_left_ = MAX_NESTING_LEVEL) :\n\t\t\t      face (face_),\n\t\t\t      before (glyphs_before ? glyphs_before : hb_set_get_empty ()),\n\t\t\t      input  (glyphs_input  ? glyphs_input  : hb_set_get_empty ()),\n\t\t\t      after  (glyphs_after  ? glyphs_after  : hb_set_get_empty ()),\n\t\t\t      output (glyphs_output ? glyphs_output : hb_set_get_empty ()),\n\t\t\t      recurse_func (NULL),\n\t\t\t      recursed_lookups (),\n\t\t\t      nesting_level_left (nesting_level_left_),\n\t\t\t      debug_depth (0)\n  {\n    recursed_lookups.init ();\n  }\n  ~hb_collect_glyphs_context_t (void)\n  {\n    recursed_lookups.fini ();\n  }\n\n  void set_recurse_func (recurse_func_t func) { recurse_func = func; }\n};\n\n\n\n#ifndef HB_DEBUG_GET_COVERAGE\n#define HB_DEBUG_GET_COVERAGE (HB_DEBUG+0)\n#endif\n\ntemplate <typename set_t>\nstruct hb_add_coverage_context_t\n{\n  inline const char *get_name (void) { return \"GET_COVERAGE\"; }\n  static const unsigned int max_debug_depth = HB_DEBUG_GET_COVERAGE;\n  typedef const Coverage &return_t;\n  template <typename T, typename F>\n  inline bool may_dispatch (const T *obj, const F *format) { return true; }\n  template <typename T>\n  inline return_t dispatch (const T &obj) { return obj.get_coverage (); }\n  static return_t default_return_value (void) { return Null(Coverage); }\n  bool stop_sublookup_iteration (return_t r) const\n  {\n    r.add_coverage (set);\n    return false;\n  }\n\n  hb_add_coverage_context_t (set_t *set_) :\n\t\t\t    set (set_),\n\t\t\t    debug_depth (0) {}\n\n  set_t *set;\n  unsigned int debug_depth;\n};\n\n\n\n#ifndef HB_DEBUG_APPLY\n#define HB_DEBUG_APPLY (HB_DEBUG+0)\n#endif\n\n#define TRACE_APPLY(this) \\\n\thb_auto_trace_t<HB_DEBUG_APPLY, bool> trace \\\n\t(&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n\t \"idx %d gid %u lookup %d\", \\\n\t c->buffer->idx, c->buffer->cur().codepoint, (int) c->lookup_index);\n\nstruct hb_apply_context_t\n{\n  struct matcher_t\n  {\n    inline matcher_t (void) :\n\t     lookup_props (0),\n\t     ignore_zwnj (false),\n\t     ignore_zwj (false),\n\t     mask (-1),\n#define arg1(arg) (arg) /* Remove the macro to see why it's needed! */\n\t     syllable arg1(0),\n#undef arg1\n\t     match_func (NULL),\n\t     match_data (NULL) {};\n\n    typedef bool (*match_func_t) (hb_codepoint_t glyph_id, const USHORT &value, const void *data);\n\n    inline void set_ignore_zwnj (bool ignore_zwnj_) { ignore_zwnj = ignore_zwnj_; }\n    inline void set_ignore_zwj (bool ignore_zwj_) { ignore_zwj = ignore_zwj_; }\n    inline void set_lookup_props (unsigned int lookup_props_) { lookup_props = lookup_props_; }\n    inline void set_mask (hb_mask_t mask_) { mask = mask_; }\n    inline void set_syllable (uint8_t syllable_)  { syllable = syllable_; }\n    inline void set_match_func (match_func_t match_func_,\n\t\t\t\tconst void *match_data_)\n    { match_func = match_func_; match_data = match_data_; }\n\n    enum may_match_t {\n      MATCH_NO,\n      MATCH_YES,\n      MATCH_MAYBE\n    };\n\n    inline may_match_t may_match (const hb_glyph_info_t &info,\n\t\t\t\t  const USHORT          *glyph_data) const\n    {\n      if (!(info.mask & mask) ||\n\t  (syllable && syllable != info.syllable ()))\n\treturn MATCH_NO;\n\n      if (match_func)\n        return match_func (info.codepoint, *glyph_data, match_data) ? MATCH_YES : MATCH_NO;\n\n      return MATCH_MAYBE;\n    }\n\n    enum may_skip_t {\n      SKIP_NO,\n      SKIP_YES,\n      SKIP_MAYBE\n    };\n\n    inline may_skip_t\n    may_skip (const hb_apply_context_t *c,\n\t      const hb_glyph_info_t    &info) const\n    {\n      if (!c->check_glyph_property (&info, lookup_props))\n\treturn SKIP_YES;\n\n      if (unlikely (_hb_glyph_info_is_default_ignorable (&info) &&\n\t\t    (ignore_zwnj || !_hb_glyph_info_is_zwnj (&info)) &&\n\t\t    (ignore_zwj || !_hb_glyph_info_is_zwj (&info))))\n\treturn SKIP_MAYBE;\n\n      return SKIP_NO;\n    }\n\n    protected:\n    unsigned int lookup_props;\n    bool ignore_zwnj;\n    bool ignore_zwj;\n    hb_mask_t mask;\n    uint8_t syllable;\n    match_func_t match_func;\n    const void *match_data;\n  };\n\n  struct skipping_iterator_t\n  {\n    inline void init (hb_apply_context_t *c_, bool context_match = false)\n    {\n      c = c_;\n      match_glyph_data = NULL,\n      matcher.set_match_func (NULL, NULL);\n      matcher.set_lookup_props (c->lookup_props);\n      /* Ignore ZWNJ if we are matching GSUB context, or matching GPOS. */\n      matcher.set_ignore_zwnj (context_match || c->table_index == 1);\n      /* Ignore ZWJ if we are matching GSUB context, or matching GPOS, or if asked to. */\n      matcher.set_ignore_zwj (context_match || c->table_index == 1 || c->auto_zwj);\n      matcher.set_mask (context_match ? -1 : c->lookup_mask);\n    }\n    inline void set_lookup_props (unsigned int lookup_props)\n    {\n      matcher.set_lookup_props (lookup_props);\n    }\n    inline void set_match_func (matcher_t::match_func_t match_func,\n\t\t\t\tconst void *match_data,\n\t\t\t\tconst USHORT glyph_data[])\n    {\n      matcher.set_match_func (match_func, match_data);\n      match_glyph_data = glyph_data;\n    }\n\n    inline void reset (unsigned int start_index_,\n\t\t       unsigned int num_items_)\n    {\n      idx = start_index_;\n      num_items = num_items_;\n      end = c->buffer->len;\n      matcher.set_syllable (start_index_ == c->buffer->idx ? c->buffer->cur().syllable () : 0);\n    }\n\n    inline void reject (void) { num_items++; match_glyph_data--; }\n\n    inline bool next (void)\n    {\n      assert (num_items > 0);\n      while (idx + num_items < end)\n      {\n\tidx++;\n\tconst hb_glyph_info_t &info = c->buffer->info[idx];\n\n\tmatcher_t::may_skip_t skip = matcher.may_skip (c, info);\n\tif (unlikely (skip == matcher_t::SKIP_YES))\n\t  continue;\n\n\tmatcher_t::may_match_t match = matcher.may_match (info, match_glyph_data);\n\tif (match == matcher_t::MATCH_YES ||\n\t    (match == matcher_t::MATCH_MAYBE &&\n\t     skip == matcher_t::SKIP_NO))\n\t{\n\t  num_items--;\n\t  match_glyph_data++;\n\t  return true;\n\t}\n\n\tif (skip == matcher_t::SKIP_NO)\n\t  return false;\n      }\n      return false;\n    }\n    inline bool prev (void)\n    {\n      assert (num_items > 0);\n      while (idx >= num_items)\n      {\n\tidx--;\n\tconst hb_glyph_info_t &info = c->buffer->out_info[idx];\n\n\tmatcher_t::may_skip_t skip = matcher.may_skip (c, info);\n\tif (unlikely (skip == matcher_t::SKIP_YES))\n\t  continue;\n\n\tmatcher_t::may_match_t match = matcher.may_match (info, match_glyph_data);\n\tif (match == matcher_t::MATCH_YES ||\n\t    (match == matcher_t::MATCH_MAYBE &&\n\t     skip == matcher_t::SKIP_NO))\n\t{\n\t  num_items--;\n\t  match_glyph_data++;\n\t  return true;\n\t}\n\n\tif (skip == matcher_t::SKIP_NO)\n\t  return false;\n      }\n      return false;\n    }\n\n    unsigned int idx;\n    protected:\n    hb_apply_context_t *c;\n    matcher_t matcher;\n    const USHORT *match_glyph_data;\n\n    unsigned int num_items;\n    unsigned int end;\n  };\n\n\n  inline const char *get_name (void) { return \"APPLY\"; }\n  static const unsigned int max_debug_depth = HB_DEBUG_APPLY;\n  typedef bool return_t;\n  typedef return_t (*recurse_func_t) (hb_apply_context_t *c, unsigned int lookup_index);\n  template <typename T, typename F>\n  inline bool may_dispatch (const T *obj, const F *format) { return true; }\n  template <typename T>\n  inline return_t dispatch (const T &obj) { return obj.apply (this); }\n  static return_t default_return_value (void) { return false; }\n  bool stop_sublookup_iteration (return_t r) const { return r; }\n  return_t recurse (unsigned int lookup_index)\n  {\n    if (unlikely (nesting_level_left == 0 || !recurse_func))\n      return default_return_value ();\n\n    nesting_level_left--;\n    bool ret = recurse_func (this, lookup_index);\n    nesting_level_left++;\n    return ret;\n  }\n\n  unsigned int table_index; /* GSUB/GPOS */\n  hb_font_t *font;\n  hb_face_t *face;\n  hb_buffer_t *buffer;\n  hb_direction_t direction;\n  hb_mask_t lookup_mask;\n  bool auto_zwj;\n  recurse_func_t recurse_func;\n  unsigned int nesting_level_left;\n  unsigned int lookup_props;\n  const GDEF &gdef;\n  bool has_glyph_classes;\n  skipping_iterator_t iter_input, iter_context;\n  unsigned int lookup_index;\n  unsigned int debug_depth;\n\n\n  hb_apply_context_t (unsigned int table_index_,\n\t\t      hb_font_t *font_,\n\t\t      hb_buffer_t *buffer_) :\n\t\t\ttable_index (table_index_),\n\t\t\tfont (font_), face (font->face), buffer (buffer_),\n\t\t\tdirection (buffer_->props.direction),\n\t\t\tlookup_mask (1),\n\t\t\tauto_zwj (true),\n\t\t\trecurse_func (NULL),\n\t\t\tnesting_level_left (MAX_NESTING_LEVEL),\n\t\t\tlookup_props (0),\n\t\t\tgdef (*hb_ot_layout_from_face (face)->gdef),\n\t\t\thas_glyph_classes (gdef.has_glyph_classes ()),\n\t\t\titer_input (),\n\t\t\titer_context (),\n\t\t\tlookup_index ((unsigned int) -1),\n\t\t\tdebug_depth (0) {}\n\n  inline void set_lookup_mask (hb_mask_t mask) { lookup_mask = mask; }\n  inline void set_auto_zwj (bool auto_zwj_) { auto_zwj = auto_zwj_; }\n  inline void set_recurse_func (recurse_func_t func) { recurse_func = func; }\n  inline void set_lookup_index (unsigned int lookup_index_) { lookup_index = lookup_index_; }\n  inline void set_lookup_props (unsigned int lookup_props_)\n  {\n    lookup_props = lookup_props_;\n    iter_input.init (this, false);\n    iter_context.init (this, true);\n  }\n\n  inline bool\n  match_properties_mark (hb_codepoint_t  glyph,\n\t\t\t unsigned int    glyph_props,\n\t\t\t unsigned int    match_props) const\n  {\n    /* If using mark filtering sets, the high short of\n     * match_props has the set index.\n     */\n    if (match_props & LookupFlag::UseMarkFilteringSet)\n      return gdef.mark_set_covers (match_props >> 16, glyph);\n\n    /* The second byte of match_props has the meaning\n     * \"ignore marks of attachment type different than\n     * the attachment type specified.\"\n     */\n    if (match_props & LookupFlag::MarkAttachmentType)\n      return (match_props & LookupFlag::MarkAttachmentType) == (glyph_props & LookupFlag::MarkAttachmentType);\n\n    return true;\n  }\n\n  inline bool\n  check_glyph_property (const hb_glyph_info_t *info,\n\t\t\tunsigned int  match_props) const\n  {\n    hb_codepoint_t glyph = info->codepoint;\n    unsigned int glyph_props = _hb_glyph_info_get_glyph_props (info);\n\n    /* Not covered, if, for example, glyph class is ligature and\n     * match_props includes LookupFlags::IgnoreLigatures\n     */\n    if (glyph_props & match_props & LookupFlag::IgnoreFlags)\n      return false;\n\n    if (unlikely (glyph_props & HB_OT_LAYOUT_GLYPH_PROPS_MARK))\n      return match_properties_mark (glyph, glyph_props, match_props);\n\n    return true;\n  }\n\n  inline void _set_glyph_props (hb_codepoint_t glyph_index,\n\t\t\t  unsigned int class_guess = 0,\n\t\t\t  bool ligature = false,\n\t\t\t  bool component = false) const\n  {\n    unsigned int add_in = _hb_glyph_info_get_glyph_props (&buffer->cur()) &\n\t\t\t  HB_OT_LAYOUT_GLYPH_PROPS_PRESERVE;\n    add_in |= HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED;\n    if (ligature)\n    {\n      add_in |= HB_OT_LAYOUT_GLYPH_PROPS_LIGATED;\n      /* In the only place that the MULTIPLIED bit is used, Uniscribe\n       * seems to only care about the \"last\" transformation between\n       * Ligature and Multiple substitions.  Ie. if you ligate, expand,\n       * and ligate again, it forgives the multiplication and acts as\n       * if only ligation happened.  As such, clear MULTIPLIED bit.\n       */\n      add_in &= ~HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED;\n    }\n    if (component)\n      add_in |= HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED;\n    if (likely (has_glyph_classes))\n      _hb_glyph_info_set_glyph_props (&buffer->cur(), add_in | gdef.get_glyph_props (glyph_index));\n    else if (class_guess)\n      _hb_glyph_info_set_glyph_props (&buffer->cur(), add_in | class_guess);\n  }\n\n  inline void replace_glyph (hb_codepoint_t glyph_index) const\n  {\n    _set_glyph_props (glyph_index);\n    buffer->replace_glyph (glyph_index);\n  }\n  inline void replace_glyph_inplace (hb_codepoint_t glyph_index) const\n  {\n    _set_glyph_props (glyph_index);\n    buffer->cur().codepoint = glyph_index;\n  }\n  inline void replace_glyph_with_ligature (hb_codepoint_t glyph_index,\n\t\t\t\t\t   unsigned int class_guess) const\n  {\n    _set_glyph_props (glyph_index, class_guess, true);\n    buffer->replace_glyph (glyph_index);\n  }\n  inline void output_glyph_for_component (hb_codepoint_t glyph_index,\n\t\t\t\t\t  unsigned int class_guess) const\n  {\n    _set_glyph_props (glyph_index, class_guess, false, true);\n    buffer->output_glyph (glyph_index);\n  }\n};\n\n\n\ntypedef bool (*intersects_func_t) (hb_set_t *glyphs, const USHORT &value, const void *data);\ntypedef void (*collect_glyphs_func_t) (hb_set_t *glyphs, const USHORT &value, const void *data);\ntypedef bool (*match_func_t) (hb_codepoint_t glyph_id, const USHORT &value, const void *data);\n\nstruct ContextClosureFuncs\n{\n  intersects_func_t intersects;\n};\nstruct ContextCollectGlyphsFuncs\n{\n  collect_glyphs_func_t collect;\n};\nstruct ContextApplyFuncs\n{\n  match_func_t match;\n};\n\n\nstatic inline bool intersects_glyph (hb_set_t *glyphs, const USHORT &value, const void *data HB_UNUSED)\n{\n  return glyphs->has (value);\n}\nstatic inline bool intersects_class (hb_set_t *glyphs, const USHORT &value, const void *data)\n{\n  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);\n  return class_def.intersects_class (glyphs, value);\n}\nstatic inline bool intersects_coverage (hb_set_t *glyphs, const USHORT &value, const void *data)\n{\n  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n  return (data+coverage).intersects (glyphs);\n}\n\nstatic inline bool intersects_array (hb_closure_context_t *c,\n\t\t\t\t     unsigned int count,\n\t\t\t\t     const USHORT values[],\n\t\t\t\t     intersects_func_t intersects_func,\n\t\t\t\t     const void *intersects_data)\n{\n  for (unsigned int i = 0; i < count; i++)\n    if (likely (!intersects_func (c->glyphs, values[i], intersects_data)))\n      return false;\n  return true;\n}\n\n\nstatic inline void collect_glyph (hb_set_t *glyphs, const USHORT &value, const void *data HB_UNUSED)\n{\n  glyphs->add (value);\n}\nstatic inline void collect_class (hb_set_t *glyphs, const USHORT &value, const void *data)\n{\n  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);\n  class_def.add_class (glyphs, value);\n}\nstatic inline void collect_coverage (hb_set_t *glyphs, const USHORT &value, const void *data)\n{\n  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n  (data+coverage).add_coverage (glyphs);\n}\nstatic inline void collect_array (hb_collect_glyphs_context_t *c HB_UNUSED,\n\t\t\t\t  hb_set_t *glyphs,\n\t\t\t\t  unsigned int count,\n\t\t\t\t  const USHORT values[],\n\t\t\t\t  collect_glyphs_func_t collect_func,\n\t\t\t\t  const void *collect_data)\n{\n  for (unsigned int i = 0; i < count; i++)\n    collect_func (glyphs, values[i], collect_data);\n}\n\n\nstatic inline bool match_glyph (hb_codepoint_t glyph_id, const USHORT &value, const void *data HB_UNUSED)\n{\n  return glyph_id == value;\n}\nstatic inline bool match_class (hb_codepoint_t glyph_id, const USHORT &value, const void *data)\n{\n  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);\n  return class_def.get_class (glyph_id) == value;\n}\nstatic inline bool match_coverage (hb_codepoint_t glyph_id, const USHORT &value, const void *data)\n{\n  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n  return (data+coverage).get_coverage (glyph_id) != NOT_COVERED;\n}\n\nstatic inline bool would_match_input (hb_would_apply_context_t *c,\n\t\t\t\t      unsigned int count, /* Including the first glyph (not matched) */\n\t\t\t\t      const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t      match_func_t match_func,\n\t\t\t\t      const void *match_data)\n{\n  if (count != c->len)\n    return false;\n\n  for (unsigned int i = 1; i < count; i++)\n    if (likely (!match_func (c->glyphs[i], input[i - 1], match_data)))\n      return false;\n\n  return true;\n}\nstatic inline bool match_input (hb_apply_context_t *c,\n\t\t\t\tunsigned int count, /* Including the first glyph (not matched) */\n\t\t\t\tconst USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\tmatch_func_t match_func,\n\t\t\t\tconst void *match_data,\n\t\t\t\tunsigned int *end_offset,\n\t\t\t\tunsigned int match_positions[MAX_CONTEXT_LENGTH],\n\t\t\t\tbool *p_is_mark_ligature = NULL,\n\t\t\t\tunsigned int *p_total_component_count = NULL)\n{\n  TRACE_APPLY (NULL);\n\n  if (unlikely (count > MAX_CONTEXT_LENGTH)) return TRACE_RETURN (false);\n\n  hb_buffer_t *buffer = c->buffer;\n\n  hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n  skippy_iter.reset (buffer->idx, count - 1);\n  skippy_iter.set_match_func (match_func, match_data, input);\n\n  /*\n   * This is perhaps the trickiest part of OpenType...  Remarks:\n   *\n   * - If all components of the ligature were marks, we call this a mark ligature.\n   *\n   * - If there is no GDEF, and the ligature is NOT a mark ligature, we categorize\n   *   it as a ligature glyph.\n   *\n   * - Ligatures cannot be formed across glyphs attached to different components\n   *   of previous ligatures.  Eg. the sequence is LAM,SHADDA,LAM,FATHA,HEH, and\n   *   LAM,LAM,HEH form a ligature, leaving SHADDA,FATHA next to eachother.\n   *   However, it would be wrong to ligate that SHADDA,FATHA sequence.o\n   *   There is an exception to this: If a ligature tries ligating with marks that\n   *   belong to it itself, go ahead, assuming that the font designer knows what\n   *   they are doing (otherwise it can break Indic stuff when a matra wants to\n   *   ligate with a conjunct...)\n   */\n\n  bool is_mark_ligature = _hb_glyph_info_is_mark (&buffer->cur());\n\n  unsigned int total_component_count = 0;\n  total_component_count += _hb_glyph_info_get_lig_num_comps (&buffer->cur());\n\n  unsigned int first_lig_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n  unsigned int first_lig_comp = _hb_glyph_info_get_lig_comp (&buffer->cur());\n\n  match_positions[0] = buffer->idx;\n  for (unsigned int i = 1; i < count; i++)\n  {\n    if (!skippy_iter.next ()) return TRACE_RETURN (false);\n\n    match_positions[i] = skippy_iter.idx;\n\n    unsigned int this_lig_id = _hb_glyph_info_get_lig_id (&buffer->info[skippy_iter.idx]);\n    unsigned int this_lig_comp = _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx]);\n\n    if (first_lig_id && first_lig_comp) {\n      /* If first component was attached to a previous ligature component,\n       * all subsequent components should be attached to the same ligature\n       * component, otherwise we shouldn't ligate them. */\n      if (first_lig_id != this_lig_id || first_lig_comp != this_lig_comp)\n\treturn TRACE_RETURN (false);\n    } else {\n      /* If first component was NOT attached to a previous ligature component,\n       * all subsequent components should also NOT be attached to any ligature\n       * component, unless they are attached to the first component itself! */\n      if (this_lig_id && this_lig_comp && (this_lig_id != first_lig_id))\n\treturn TRACE_RETURN (false);\n    }\n\n    is_mark_ligature = is_mark_ligature && _hb_glyph_info_is_mark (&buffer->info[skippy_iter.idx]);\n    total_component_count += _hb_glyph_info_get_lig_num_comps (&buffer->info[skippy_iter.idx]);\n  }\n\n  *end_offset = skippy_iter.idx - buffer->idx + 1;\n\n  if (p_is_mark_ligature)\n    *p_is_mark_ligature = is_mark_ligature;\n\n  if (p_total_component_count)\n    *p_total_component_count = total_component_count;\n\n  return TRACE_RETURN (true);\n}\nstatic inline void ligate_input (hb_apply_context_t *c,\n\t\t\t\t unsigned int count, /* Including the first glyph */\n\t\t\t\t unsigned int match_positions[MAX_CONTEXT_LENGTH], /* Including the first glyph */\n\t\t\t\t unsigned int match_length,\n\t\t\t\t hb_codepoint_t lig_glyph,\n\t\t\t\t bool is_mark_ligature,\n\t\t\t\t unsigned int total_component_count)\n{\n  TRACE_APPLY (NULL);\n\n  hb_buffer_t *buffer = c->buffer;\n\n  buffer->merge_clusters (buffer->idx, buffer->idx + match_length);\n\n  /*\n   * - If it *is* a mark ligature, we don't allocate a new ligature id, and leave\n   *   the ligature to keep its old ligature id.  This will allow it to attach to\n   *   a base ligature in GPOS.  Eg. if the sequence is: LAM,LAM,SHADDA,FATHA,HEH,\n   *   and LAM,LAM,HEH for a ligature, they will leave SHADDA and FATHA wit a\n   *   ligature id and component value of 2.  Then if SHADDA,FATHA form a ligature\n   *   later, we don't want them to lose their ligature id/component, otherwise\n   *   GPOS will fail to correctly position the mark ligature on top of the\n   *   LAM,LAM,HEH ligature.  See:\n   *     https://bugzilla.gnome.org/show_bug.cgi?id=676343\n   *\n   * - If a ligature is formed of components that some of which are also ligatures\n   *   themselves, and those ligature components had marks attached to *their*\n   *   components, we have to attach the marks to the new ligature component\n   *   positions!  Now *that*'s tricky!  And these marks may be following the\n   *   last component of the whole sequence, so we should loop forward looking\n   *   for them and update them.\n   *\n   *   Eg. the sequence is LAM,LAM,SHADDA,FATHA,HEH, and the font first forms a\n   *   'calt' ligature of LAM,HEH, leaving the SHADDA and FATHA with a ligature\n   *   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature\n   *   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to\n   *   the new ligature with a component value of 2.\n   *\n   *   This in fact happened to a font...  See:\n   *   https://bugzilla.gnome.org/show_bug.cgi?id=437633\n   */\n\n  unsigned int klass = is_mark_ligature ? 0 : HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE;\n  unsigned int lig_id = is_mark_ligature ? 0 : _hb_allocate_lig_id (buffer);\n  unsigned int last_lig_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n  unsigned int last_num_components = _hb_glyph_info_get_lig_num_comps (&buffer->cur());\n  unsigned int components_so_far = last_num_components;\n\n  if (!is_mark_ligature)\n  {\n    _hb_glyph_info_set_lig_props_for_ligature (&buffer->cur(), lig_id, total_component_count);\n    if (_hb_glyph_info_get_general_category (&buffer->cur()) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)\n    {\n      _hb_glyph_info_set_general_category (&buffer->cur(), HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER);\n      _hb_glyph_info_set_modified_combining_class (&buffer->cur(), 0);\n    }\n  }\n  c->replace_glyph_with_ligature (lig_glyph, klass);\n\n  for (unsigned int i = 1; i < count; i++)\n  {\n    while (buffer->idx < match_positions[i])\n    {\n      if (!is_mark_ligature) {\n\tunsigned int new_lig_comp = components_so_far - last_num_components +\n\t\t\t\t    MIN (MAX (_hb_glyph_info_get_lig_comp (&buffer->cur()), 1u), last_num_components);\n\t_hb_glyph_info_set_lig_props_for_mark (&buffer->cur(), lig_id, new_lig_comp);\n      }\n      buffer->next_glyph ();\n    }\n\n    last_lig_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n    last_num_components = _hb_glyph_info_get_lig_num_comps (&buffer->cur());\n    components_so_far += last_num_components;\n\n    /* Skip the base glyph */\n    buffer->idx++;\n  }\n\n  if (!is_mark_ligature && last_lig_id) {\n    /* Re-adjust components for any marks following. */\n    for (unsigned int i = buffer->idx; i < buffer->len; i++) {\n      if (last_lig_id == _hb_glyph_info_get_lig_id (&buffer->info[i])) {\n\tunsigned int new_lig_comp = components_so_far - last_num_components +\n\t\t\t\t    MIN (MAX (_hb_glyph_info_get_lig_comp (&buffer->info[i]), 1u), last_num_components);\n\t_hb_glyph_info_set_lig_props_for_mark (&buffer->info[i], lig_id, new_lig_comp);\n      } else\n\tbreak;\n    }\n  }\n  TRACE_RETURN (true);\n}\n\nstatic inline bool match_backtrack (hb_apply_context_t *c,\n\t\t\t\t    unsigned int count,\n\t\t\t\t    const USHORT backtrack[],\n\t\t\t\t    match_func_t match_func,\n\t\t\t\t    const void *match_data)\n{\n  TRACE_APPLY (NULL);\n\n  hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_context;\n  skippy_iter.reset (c->buffer->backtrack_len (), count);\n  skippy_iter.set_match_func (match_func, match_data, backtrack);\n\n  for (unsigned int i = 0; i < count; i++)\n    if (!skippy_iter.prev ())\n      return TRACE_RETURN (false);\n\n  return TRACE_RETURN (true);\n}\n\nstatic inline bool match_lookahead (hb_apply_context_t *c,\n\t\t\t\t    unsigned int count,\n\t\t\t\t    const USHORT lookahead[],\n\t\t\t\t    match_func_t match_func,\n\t\t\t\t    const void *match_data,\n\t\t\t\t    unsigned int offset)\n{\n  TRACE_APPLY (NULL);\n\n  hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_context;\n  skippy_iter.reset (c->buffer->idx + offset - 1, count);\n  skippy_iter.set_match_func (match_func, match_data, lookahead);\n\n  for (unsigned int i = 0; i < count; i++)\n    if (!skippy_iter.next ())\n      return TRACE_RETURN (false);\n\n  return TRACE_RETURN (true);\n}\n\n\n\nstruct LookupRecord\n{\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this));\n  }\n\n  USHORT\tsequenceIndex;\t\t/* Index into current glyph\n\t\t\t\t\t * sequence--first glyph = 0 */\n  USHORT\tlookupListIndex;\t/* Lookup to apply to that\n\t\t\t\t\t * position--zero--based */\n  public:\n  DEFINE_SIZE_STATIC (4);\n};\n\n\ntemplate <typename context_t>\nstatic inline void recurse_lookups (context_t *c,\n\t\t\t\t    unsigned int lookupCount,\n\t\t\t\t    const LookupRecord lookupRecord[] /* Array of LookupRecords--in design order */)\n{\n  for (unsigned int i = 0; i < lookupCount; i++)\n    c->recurse (lookupRecord[i].lookupListIndex);\n}\n\nstatic inline bool apply_lookup (hb_apply_context_t *c,\n\t\t\t\t unsigned int count, /* Including the first glyph */\n\t\t\t\t unsigned int match_positions[MAX_CONTEXT_LENGTH], /* Including the first glyph */\n\t\t\t\t unsigned int lookupCount,\n\t\t\t\t const LookupRecord lookupRecord[], /* Array of LookupRecords--in design order */\n\t\t\t\t unsigned int match_length)\n{\n  TRACE_APPLY (NULL);\n\n  hb_buffer_t *buffer = c->buffer;\n  unsigned int end;\n\n  /* All positions are distance from beginning of *output* buffer.\n   * Adjust. */\n  {\n    unsigned int bl = buffer->backtrack_len ();\n    end = bl + match_length;\n\n    int delta = bl - buffer->idx;\n    /* Convert positions to new indexing. */\n    for (unsigned int j = 0; j < count; j++)\n      match_positions[j] += delta;\n  }\n\n  for (unsigned int i = 0; i < lookupCount; i++)\n  {\n    unsigned int idx = lookupRecord[i].sequenceIndex;\n    if (idx >= count)\n      continue;\n\n    buffer->move_to (match_positions[idx]);\n\n    unsigned int orig_len = buffer->backtrack_len () + buffer->lookahead_len ();\n    if (!c->recurse (lookupRecord[i].lookupListIndex))\n      continue;\n\n    unsigned int new_len = buffer->backtrack_len () + buffer->lookahead_len ();\n    int delta = new_len - orig_len;\n\n    if (!delta)\n        continue;\n\n    /* Recursed lookup changed buffer len.  Adjust. */\n\n    /* end can't go back past the current match position.\n     * Note: this is only true because we do NOT allow MultipleSubst\n     * with zero sequence len. */\n    end = MAX ((int) match_positions[idx] + 1, int (end) + delta);\n\n    unsigned int next = idx + 1; /* next now is the position after the recursed lookup. */\n\n    if (delta > 0)\n    {\n      if (unlikely (delta + count > MAX_CONTEXT_LENGTH))\n\tbreak;\n    }\n    else\n    {\n      /* NOTE: delta is negative. */\n      delta = MAX (delta, (int) next - (int) count);\n      next -= delta;\n    }\n\n    /* Shift! */\n    memmove (match_positions + next + delta, match_positions + next,\n\t     (count - next) * sizeof (match_positions[0]));\n    next += delta;\n    count += delta;\n\n    /* Fill in new entries. */\n    for (unsigned int j = idx + 1; j < next; j++)\n      match_positions[j] = match_positions[j - 1] + 1;\n\n    /* And fixup the rest. */\n    for (; next < count; next++)\n      match_positions[next] += delta;\n  }\n\n  buffer->move_to (end);\n\n  return TRACE_RETURN (true);\n}\n\n\n\n/* Contextual lookups */\n\nstruct ContextClosureLookupContext\n{\n  ContextClosureFuncs funcs;\n  const void *intersects_data;\n};\n\nstruct ContextCollectGlyphsLookupContext\n{\n  ContextCollectGlyphsFuncs funcs;\n  const void *collect_data;\n};\n\nstruct ContextApplyLookupContext\n{\n  ContextApplyFuncs funcs;\n  const void *match_data;\n};\n\nstatic inline void context_closure_lookup (hb_closure_context_t *c,\n\t\t\t\t\t   unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t   const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t   unsigned int lookupCount,\n\t\t\t\t\t   const LookupRecord lookupRecord[],\n\t\t\t\t\t   ContextClosureLookupContext &lookup_context)\n{\n  if (intersects_array (c,\n\t\t\tinputCount ? inputCount - 1 : 0, input,\n\t\t\tlookup_context.funcs.intersects, lookup_context.intersects_data))\n    recurse_lookups (c,\n\t\t     lookupCount, lookupRecord);\n}\n\nstatic inline void context_collect_glyphs_lookup (hb_collect_glyphs_context_t *c,\n\t\t\t\t\t\t  unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t\t  const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t\t  unsigned int lookupCount,\n\t\t\t\t\t\t  const LookupRecord lookupRecord[],\n\t\t\t\t\t\t  ContextCollectGlyphsLookupContext &lookup_context)\n{\n  collect_array (c, c->input,\n\t\t inputCount ? inputCount - 1 : 0, input,\n\t\t lookup_context.funcs.collect, lookup_context.collect_data);\n  recurse_lookups (c,\n\t\t   lookupCount, lookupRecord);\n}\n\nstatic inline bool context_would_apply_lookup (hb_would_apply_context_t *c,\n\t\t\t\t\t       unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t       const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t       unsigned int lookupCount HB_UNUSED,\n\t\t\t\t\t       const LookupRecord lookupRecord[] HB_UNUSED,\n\t\t\t\t\t       ContextApplyLookupContext &lookup_context)\n{\n  return would_match_input (c,\n\t\t\t    inputCount, input,\n\t\t\t    lookup_context.funcs.match, lookup_context.match_data);\n}\nstatic inline bool context_apply_lookup (hb_apply_context_t *c,\n\t\t\t\t\t unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t unsigned int lookupCount,\n\t\t\t\t\t const LookupRecord lookupRecord[],\n\t\t\t\t\t ContextApplyLookupContext &lookup_context)\n{\n  unsigned int match_length = 0;\n  unsigned int match_positions[MAX_CONTEXT_LENGTH];\n  return match_input (c,\n\t\t      inputCount, input,\n\t\t      lookup_context.funcs.match, lookup_context.match_data,\n\t\t      &match_length, match_positions)\n      && apply_lookup (c,\n\t\t       inputCount, match_positions,\n\t\t       lookupCount, lookupRecord,\n\t\t       match_length);\n}\n\nstruct Rule\n{\n  inline void closure (hb_closure_context_t *c, ContextClosureLookupContext &lookup_context) const\n  {\n    TRACE_CLOSURE (this);\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (inputZ, inputZ[0].static_size * (inputCount ? inputCount - 1 : 0));\n    context_closure_lookup (c,\n\t\t\t    inputCount, inputZ,\n\t\t\t    lookupCount, lookupRecord,\n\t\t\t    lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c, ContextCollectGlyphsLookupContext &lookup_context) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (inputZ, inputZ[0].static_size * (inputCount ? inputCount - 1 : 0));\n    context_collect_glyphs_lookup (c,\n\t\t\t\t   inputCount, inputZ,\n\t\t\t\t   lookupCount, lookupRecord,\n\t\t\t\t   lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c, ContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_WOULD_APPLY (this);\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (inputZ, inputZ[0].static_size * (inputCount ? inputCount - 1 : 0));\n    return TRACE_RETURN (context_would_apply_lookup (c, inputCount, inputZ, lookupCount, lookupRecord, lookup_context));\n  }\n\n  inline bool apply (hb_apply_context_t *c, ContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_APPLY (this);\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (inputZ, inputZ[0].static_size * (inputCount ? inputCount - 1 : 0));\n    return TRACE_RETURN (context_apply_lookup (c, inputCount, inputZ, lookupCount, lookupRecord, lookup_context));\n  }\n\n  public:\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return inputCount.sanitize (c)\n\t&& lookupCount.sanitize (c)\n\t&& c->check_range (inputZ,\n\t\t\t   inputZ[0].static_size * inputCount\n\t\t\t   + lookupRecordX[0].static_size * lookupCount);\n  }\n\n  protected:\n  USHORT\tinputCount;\t\t/* Total number of glyphs in input\n\t\t\t\t\t * glyph sequence--includes the first\n\t\t\t\t\t * glyph */\n  USHORT\tlookupCount;\t\t/* Number of LookupRecords */\n  USHORT\tinputZ[VAR];\t\t/* Array of match inputs--start with\n\t\t\t\t\t * second glyph */\n  LookupRecord\tlookupRecordX[VAR];\t/* Array of LookupRecords--in\n\t\t\t\t\t * design order */\n  public:\n  DEFINE_SIZE_ARRAY2 (4, inputZ, lookupRecordX);\n};\n\nstruct RuleSet\n{\n  inline void closure (hb_closure_context_t *c, ContextClosureLookupContext &lookup_context) const\n  {\n    TRACE_CLOSURE (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      (this+rule[i]).closure (c, lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c, ContextCollectGlyphsLookupContext &lookup_context) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      (this+rule[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c, ContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_WOULD_APPLY (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n    {\n      if ((this+rule[i]).would_apply (c, lookup_context))\n        return TRACE_RETURN (true);\n    }\n    return TRACE_RETURN (false);\n  }\n\n  inline bool apply (hb_apply_context_t *c, ContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_APPLY (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n    {\n      if ((this+rule[i]).apply (c, lookup_context))\n        return TRACE_RETURN (true);\n    }\n    return TRACE_RETURN (false);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (rule.sanitize (c, this));\n  }\n\n  protected:\n  OffsetArrayOf<Rule>\n\t\trule;\t\t\t/* Array of Rule tables\n\t\t\t\t\t * ordered by preference */\n  public:\n  DEFINE_SIZE_ARRAY (2, rule);\n};\n\n\nstruct ContextFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n\n    const Coverage &cov = (this+coverage);\n\n    struct ContextClosureLookupContext lookup_context = {\n      {intersects_glyph},\n      NULL\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (cov.intersects_coverage (c->glyphs, i)) {\n\tconst RuleSet &rule_set = this+ruleSet[i];\n\trule_set.closure (c, lookup_context);\n      }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n\n    struct ContextCollectGlyphsLookupContext lookup_context = {\n      {collect_glyph},\n      NULL\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const RuleSet &rule_set = this+ruleSet[(this+coverage).get_coverage (c->glyphs[0])];\n    struct ContextApplyLookupContext lookup_context = {\n      {match_glyph},\n      NULL\n    };\n    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED))\n      return TRACE_RETURN (false);\n\n    const RuleSet &rule_set = this+ruleSet[index];\n    struct ContextApplyLookupContext lookup_context = {\n      {match_glyph},\n      NULL\n    };\n    return TRACE_RETURN (rule_set.apply (c, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && ruleSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of table */\n  OffsetArrayOf<RuleSet>\n\t\truleSet;\t\t/* Array of RuleSet tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, ruleSet);\n};\n\n\nstruct ContextFormat2\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    if (!(this+coverage).intersects (c->glyphs))\n      return;\n\n    const ClassDef &class_def = this+classDef;\n\n    struct ContextClosureLookupContext lookup_context = {\n      {intersects_class},\n      &class_def\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (class_def.intersects_class (c->glyphs, i)) {\n\tconst RuleSet &rule_set = this+ruleSet[i];\n\trule_set.closure (c, lookup_context);\n      }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n\n    const ClassDef &class_def = this+classDef;\n    struct ContextCollectGlyphsLookupContext lookup_context = {\n      {collect_class},\n      &class_def\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const ClassDef &class_def = this+classDef;\n    unsigned int index = class_def.get_class (c->glyphs[0]);\n    const RuleSet &rule_set = this+ruleSet[index];\n    struct ContextApplyLookupContext lookup_context = {\n      {match_class},\n      &class_def\n    };\n    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const ClassDef &class_def = this+classDef;\n    index = class_def.get_class (c->buffer->cur().codepoint);\n    const RuleSet &rule_set = this+ruleSet[index];\n    struct ContextApplyLookupContext lookup_context = {\n      {match_class},\n      &class_def\n    };\n    return TRACE_RETURN (rule_set.apply (c, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && classDef.sanitize (c, this) && ruleSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of table */\n  OffsetTo<ClassDef>\n\t\tclassDef;\t\t/* Offset to glyph ClassDef table--from\n\t\t\t\t\t * beginning of table */\n  OffsetArrayOf<RuleSet>\n\t\truleSet;\t\t/* Array of RuleSet tables\n\t\t\t\t\t * ordered by class */\n  public:\n  DEFINE_SIZE_ARRAY (8, ruleSet);\n};\n\n\nstruct ContextFormat3\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    if (!(this+coverageZ[0]).intersects (c->glyphs))\n      return;\n\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverageZ, coverageZ[0].static_size * glyphCount);\n    struct ContextClosureLookupContext lookup_context = {\n      {intersects_coverage},\n      this\n    };\n    context_closure_lookup (c,\n\t\t\t    glyphCount, (const USHORT *) (coverageZ + 1),\n\t\t\t    lookupCount, lookupRecord,\n\t\t\t    lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverageZ[0]).add_coverage (c->input);\n\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverageZ, coverageZ[0].static_size * glyphCount);\n    struct ContextCollectGlyphsLookupContext lookup_context = {\n      {collect_coverage},\n      this\n    };\n\n    context_collect_glyphs_lookup (c,\n\t\t\t\t   glyphCount, (const USHORT *) (coverageZ + 1),\n\t\t\t\t   lookupCount, lookupRecord,\n\t\t\t\t   lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverageZ, coverageZ[0].static_size * glyphCount);\n    struct ContextApplyLookupContext lookup_context = {\n      {match_coverage},\n      this\n    };\n    return TRACE_RETURN (context_would_apply_lookup (c, glyphCount, (const USHORT *) (coverageZ + 1), lookupCount, lookupRecord, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverageZ[0];\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int index = (this+coverageZ[0]).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverageZ, coverageZ[0].static_size * glyphCount);\n    struct ContextApplyLookupContext lookup_context = {\n      {match_coverage},\n      this\n    };\n    return TRACE_RETURN (context_apply_lookup (c, glyphCount, (const USHORT *) (coverageZ + 1), lookupCount, lookupRecord, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!c->check_struct (this)) return TRACE_RETURN (false);\n    unsigned int count = glyphCount;\n    if (!count) return TRACE_RETURN (false); /* We want to access coverageZ[0] freely. */\n    if (!c->check_array (coverageZ, coverageZ[0].static_size, count)) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < count; i++)\n      if (!coverageZ[i].sanitize (c, this)) return TRACE_RETURN (false);\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverageZ, coverageZ[0].static_size * count);\n    return TRACE_RETURN (c->check_array (lookupRecord, lookupRecord[0].static_size, lookupCount));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 3 */\n  USHORT\tglyphCount;\t\t/* Number of glyphs in the input glyph\n\t\t\t\t\t * sequence */\n  USHORT\tlookupCount;\t\t/* Number of LookupRecords */\n  OffsetTo<Coverage>\n\t\tcoverageZ[VAR];\t\t/* Array of offsets to Coverage\n\t\t\t\t\t * table in glyph sequence order */\n  LookupRecord\tlookupRecordX[VAR];\t/* Array of LookupRecords--in\n\t\t\t\t\t * design order */\n  public:\n  DEFINE_SIZE_ARRAY2 (6, coverageZ, lookupRecordX);\n};\n\nstruct Context\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    case 2: return TRACE_RETURN (c->dispatch (u.format2));\n    case 3: return TRACE_RETURN (c->dispatch (u.format3));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  ContextFormat1\tformat1;\n  ContextFormat2\tformat2;\n  ContextFormat3\tformat3;\n  } u;\n};\n\n\n/* Chaining Contextual lookups */\n\nstruct ChainContextClosureLookupContext\n{\n  ContextClosureFuncs funcs;\n  const void *intersects_data[3];\n};\n\nstruct ChainContextCollectGlyphsLookupContext\n{\n  ContextCollectGlyphsFuncs funcs;\n  const void *collect_data[3];\n};\n\nstruct ChainContextApplyLookupContext\n{\n  ContextApplyFuncs funcs;\n  const void *match_data[3];\n};\n\nstatic inline void chain_context_closure_lookup (hb_closure_context_t *c,\n\t\t\t\t\t\t unsigned int backtrackCount,\n\t\t\t\t\t\t const USHORT backtrack[],\n\t\t\t\t\t\t unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t\t const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t\t unsigned int lookaheadCount,\n\t\t\t\t\t\t const USHORT lookahead[],\n\t\t\t\t\t\t unsigned int lookupCount,\n\t\t\t\t\t\t const LookupRecord lookupRecord[],\n\t\t\t\t\t\t ChainContextClosureLookupContext &lookup_context)\n{\n  if (intersects_array (c,\n\t\t\tbacktrackCount, backtrack,\n\t\t\tlookup_context.funcs.intersects, lookup_context.intersects_data[0])\n   && intersects_array (c,\n\t\t\tinputCount ? inputCount - 1 : 0, input,\n\t\t\tlookup_context.funcs.intersects, lookup_context.intersects_data[1])\n   && intersects_array (c,\n\t\t       lookaheadCount, lookahead,\n\t\t       lookup_context.funcs.intersects, lookup_context.intersects_data[2]))\n    recurse_lookups (c,\n\t\t     lookupCount, lookupRecord);\n}\n\nstatic inline void chain_context_collect_glyphs_lookup (hb_collect_glyphs_context_t *c,\n\t\t\t\t\t\t        unsigned int backtrackCount,\n\t\t\t\t\t\t        const USHORT backtrack[],\n\t\t\t\t\t\t        unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t\t        const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t\t        unsigned int lookaheadCount,\n\t\t\t\t\t\t        const USHORT lookahead[],\n\t\t\t\t\t\t        unsigned int lookupCount,\n\t\t\t\t\t\t        const LookupRecord lookupRecord[],\n\t\t\t\t\t\t        ChainContextCollectGlyphsLookupContext &lookup_context)\n{\n  collect_array (c, c->before,\n\t\t backtrackCount, backtrack,\n\t\t lookup_context.funcs.collect, lookup_context.collect_data[0]);\n  collect_array (c, c->input,\n\t\t inputCount ? inputCount - 1 : 0, input,\n\t\t lookup_context.funcs.collect, lookup_context.collect_data[1]);\n  collect_array (c, c->after,\n\t\t lookaheadCount, lookahead,\n\t\t lookup_context.funcs.collect, lookup_context.collect_data[2]);\n  recurse_lookups (c,\n\t\t   lookupCount, lookupRecord);\n}\n\nstatic inline bool chain_context_would_apply_lookup (hb_would_apply_context_t *c,\n\t\t\t\t\t\t     unsigned int backtrackCount,\n\t\t\t\t\t\t     const USHORT backtrack[] HB_UNUSED,\n\t\t\t\t\t\t     unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t\t     const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t\t     unsigned int lookaheadCount,\n\t\t\t\t\t\t     const USHORT lookahead[] HB_UNUSED,\n\t\t\t\t\t\t     unsigned int lookupCount HB_UNUSED,\n\t\t\t\t\t\t     const LookupRecord lookupRecord[] HB_UNUSED,\n\t\t\t\t\t\t     ChainContextApplyLookupContext &lookup_context)\n{\n  return (c->zero_context ? !backtrackCount && !lookaheadCount : true)\n      && would_match_input (c,\n\t\t\t    inputCount, input,\n\t\t\t    lookup_context.funcs.match, lookup_context.match_data[1]);\n}\n\nstatic inline bool chain_context_apply_lookup (hb_apply_context_t *c,\n\t\t\t\t\t       unsigned int backtrackCount,\n\t\t\t\t\t       const USHORT backtrack[],\n\t\t\t\t\t       unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t       const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t       unsigned int lookaheadCount,\n\t\t\t\t\t       const USHORT lookahead[],\n\t\t\t\t\t       unsigned int lookupCount,\n\t\t\t\t\t       const LookupRecord lookupRecord[],\n\t\t\t\t\t       ChainContextApplyLookupContext &lookup_context)\n{\n  unsigned int match_length = 0;\n  unsigned int match_positions[MAX_CONTEXT_LENGTH];\n  return match_input (c,\n\t\t      inputCount, input,\n\t\t      lookup_context.funcs.match, lookup_context.match_data[1],\n\t\t      &match_length, match_positions)\n      && match_backtrack (c,\n\t\t\t  backtrackCount, backtrack,\n\t\t\t  lookup_context.funcs.match, lookup_context.match_data[0])\n      && match_lookahead (c,\n\t\t\t  lookaheadCount, lookahead,\n\t\t\t  lookup_context.funcs.match, lookup_context.match_data[2],\n\t\t\t  match_length)\n      && apply_lookup (c,\n\t\t       inputCount, match_positions,\n\t\t       lookupCount, lookupRecord,\n\t\t       match_length);\n}\n\nstruct ChainRule\n{\n  inline void closure (hb_closure_context_t *c, ChainContextClosureLookupContext &lookup_context) const\n  {\n    TRACE_CLOSURE (this);\n    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);\n    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    chain_context_closure_lookup (c,\n\t\t\t\t  backtrack.len, backtrack.array,\n\t\t\t\t  input.len, input.array,\n\t\t\t\t  lookahead.len, lookahead.array,\n\t\t\t\t  lookup.len, lookup.array,\n\t\t\t\t  lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c, ChainContextCollectGlyphsLookupContext &lookup_context) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);\n    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    chain_context_collect_glyphs_lookup (c,\n\t\t\t\t\t backtrack.len, backtrack.array,\n\t\t\t\t\t input.len, input.array,\n\t\t\t\t\t lookahead.len, lookahead.array,\n\t\t\t\t\t lookup.len, lookup.array,\n\t\t\t\t\t lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_WOULD_APPLY (this);\n    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);\n    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    return TRACE_RETURN (chain_context_would_apply_lookup (c,\n\t\t\t\t\t\t\t   backtrack.len, backtrack.array,\n\t\t\t\t\t\t\t   input.len, input.array,\n\t\t\t\t\t\t\t   lookahead.len, lookahead.array, lookup.len,\n\t\t\t\t\t\t\t   lookup.array, lookup_context));\n  }\n\n  inline bool apply (hb_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_APPLY (this);\n    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);\n    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    return TRACE_RETURN (chain_context_apply_lookup (c,\n\t\t\t\t\t\t     backtrack.len, backtrack.array,\n\t\t\t\t\t\t     input.len, input.array,\n\t\t\t\t\t\t     lookahead.len, lookahead.array, lookup.len,\n\t\t\t\t\t\t     lookup.array, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!backtrack.sanitize (c)) return TRACE_RETURN (false);\n    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);\n    if (!input.sanitize (c)) return TRACE_RETURN (false);\n    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);\n    if (!lookahead.sanitize (c)) return TRACE_RETURN (false);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    return TRACE_RETURN (lookup.sanitize (c));\n  }\n\n  protected:\n  ArrayOf<USHORT>\n\t\tbacktrack;\t\t/* Array of backtracking values\n\t\t\t\t\t * (to be matched before the input\n\t\t\t\t\t * sequence) */\n  HeadlessArrayOf<USHORT>\n\t\tinputX;\t\t\t/* Array of input values (start with\n\t\t\t\t\t * second glyph) */\n  ArrayOf<USHORT>\n\t\tlookaheadX;\t\t/* Array of lookahead values's (to be\n\t\t\t\t\t * matched after the input sequence) */\n  ArrayOf<LookupRecord>\n\t\tlookupX;\t\t/* Array of LookupRecords--in\n\t\t\t\t\t * design order) */\n  public:\n  DEFINE_SIZE_MIN (8);\n};\n\nstruct ChainRuleSet\n{\n  inline void closure (hb_closure_context_t *c, ChainContextClosureLookupContext &lookup_context) const\n  {\n    TRACE_CLOSURE (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      (this+rule[i]).closure (c, lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c, ChainContextCollectGlyphsLookupContext &lookup_context) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      (this+rule[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_WOULD_APPLY (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      if ((this+rule[i]).would_apply (c, lookup_context))\n        return TRACE_RETURN (true);\n\n    return TRACE_RETURN (false);\n  }\n\n  inline bool apply (hb_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_APPLY (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      if ((this+rule[i]).apply (c, lookup_context))\n        return TRACE_RETURN (true);\n\n    return TRACE_RETURN (false);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (rule.sanitize (c, this));\n  }\n\n  protected:\n  OffsetArrayOf<ChainRule>\n\t\trule;\t\t\t/* Array of ChainRule tables\n\t\t\t\t\t * ordered by preference */\n  public:\n  DEFINE_SIZE_ARRAY (2, rule);\n};\n\nstruct ChainContextFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    const Coverage &cov = (this+coverage);\n\n    struct ChainContextClosureLookupContext lookup_context = {\n      {intersects_glyph},\n      {NULL, NULL, NULL}\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (cov.intersects_coverage (c->glyphs, i)) {\n\tconst ChainRuleSet &rule_set = this+ruleSet[i];\n\trule_set.closure (c, lookup_context);\n      }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n\n    struct ChainContextCollectGlyphsLookupContext lookup_context = {\n      {collect_glyph},\n      {NULL, NULL, NULL}\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const ChainRuleSet &rule_set = this+ruleSet[(this+coverage).get_coverage (c->glyphs[0])];\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_glyph},\n      {NULL, NULL, NULL}\n    };\n    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const ChainRuleSet &rule_set = this+ruleSet[index];\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_glyph},\n      {NULL, NULL, NULL}\n    };\n    return TRACE_RETURN (rule_set.apply (c, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && ruleSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of table */\n  OffsetArrayOf<ChainRuleSet>\n\t\truleSet;\t\t/* Array of ChainRuleSet tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, ruleSet);\n};\n\nstruct ChainContextFormat2\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    if (!(this+coverage).intersects (c->glyphs))\n      return;\n\n    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n    const ClassDef &input_class_def = this+inputClassDef;\n    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n\n    struct ChainContextClosureLookupContext lookup_context = {\n      {intersects_class},\n      {&backtrack_class_def,\n       &input_class_def,\n       &lookahead_class_def}\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (input_class_def.intersects_class (c->glyphs, i)) {\n\tconst ChainRuleSet &rule_set = this+ruleSet[i];\n\trule_set.closure (c, lookup_context);\n      }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n\n    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n    const ClassDef &input_class_def = this+inputClassDef;\n    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n\n    struct ChainContextCollectGlyphsLookupContext lookup_context = {\n      {collect_class},\n      {&backtrack_class_def,\n       &input_class_def,\n       &lookahead_class_def}\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n    const ClassDef &input_class_def = this+inputClassDef;\n    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n\n    unsigned int index = input_class_def.get_class (c->glyphs[0]);\n    const ChainRuleSet &rule_set = this+ruleSet[index];\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_class},\n      {&backtrack_class_def,\n       &input_class_def,\n       &lookahead_class_def}\n    };\n    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n    const ClassDef &input_class_def = this+inputClassDef;\n    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n\n    index = input_class_def.get_class (c->buffer->cur().codepoint);\n    const ChainRuleSet &rule_set = this+ruleSet[index];\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_class},\n      {&backtrack_class_def,\n       &input_class_def,\n       &lookahead_class_def}\n    };\n    return TRACE_RETURN (rule_set.apply (c, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && backtrackClassDef.sanitize (c, this) &&\n\t\t\t inputClassDef.sanitize (c, this) && lookaheadClassDef.sanitize (c, this) &&\n\t\t\t ruleSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of table */\n  OffsetTo<ClassDef>\n\t\tbacktrackClassDef;\t/* Offset to glyph ClassDef table\n\t\t\t\t\t * containing backtrack sequence\n\t\t\t\t\t * data--from beginning of table */\n  OffsetTo<ClassDef>\n\t\tinputClassDef;\t\t/* Offset to glyph ClassDef\n\t\t\t\t\t * table containing input sequence\n\t\t\t\t\t * data--from beginning of table */\n  OffsetTo<ClassDef>\n\t\tlookaheadClassDef;\t/* Offset to glyph ClassDef table\n\t\t\t\t\t * containing lookahead sequence\n\t\t\t\t\t * data--from beginning of table */\n  OffsetArrayOf<ChainRuleSet>\n\t\truleSet;\t\t/* Array of ChainRuleSet tables\n\t\t\t\t\t * ordered by class */\n  public:\n  DEFINE_SIZE_ARRAY (12, ruleSet);\n};\n\nstruct ChainContextFormat3\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n\n    if (!(this+input[0]).intersects (c->glyphs))\n      return;\n\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    struct ChainContextClosureLookupContext lookup_context = {\n      {intersects_coverage},\n      {this, this, this}\n    };\n    chain_context_closure_lookup (c,\n\t\t\t\t  backtrack.len, (const USHORT *) backtrack.array,\n\t\t\t\t  input.len, (const USHORT *) input.array + 1,\n\t\t\t\t  lookahead.len, (const USHORT *) lookahead.array,\n\t\t\t\t  lookup.len, lookup.array,\n\t\t\t\t  lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n\n    (this+input[0]).add_coverage (c->input);\n\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    struct ChainContextCollectGlyphsLookupContext lookup_context = {\n      {collect_coverage},\n      {this, this, this}\n    };\n    chain_context_collect_glyphs_lookup (c,\n\t\t\t\t\t backtrack.len, (const USHORT *) backtrack.array,\n\t\t\t\t\t input.len, (const USHORT *) input.array + 1,\n\t\t\t\t\t lookahead.len, (const USHORT *) lookahead.array,\n\t\t\t\t\t lookup.len, lookup.array,\n\t\t\t\t\t lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_coverage},\n      {this, this, this}\n    };\n    return TRACE_RETURN (chain_context_would_apply_lookup (c,\n\t\t\t\t\t\t\t   backtrack.len, (const USHORT *) backtrack.array,\n\t\t\t\t\t\t\t   input.len, (const USHORT *) input.array + 1,\n\t\t\t\t\t\t\t   lookahead.len, (const USHORT *) lookahead.array,\n\t\t\t\t\t\t\t   lookup.len, lookup.array, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n    return this+input[0];\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n\n    unsigned int index = (this+input[0]).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_coverage},\n      {this, this, this}\n    };\n    return TRACE_RETURN (chain_context_apply_lookup (c,\n\t\t\t\t\t\t     backtrack.len, (const USHORT *) backtrack.array,\n\t\t\t\t\t\t     input.len, (const USHORT *) input.array + 1,\n\t\t\t\t\t\t     lookahead.len, (const USHORT *) lookahead.array,\n\t\t\t\t\t\t     lookup.len, lookup.array, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!backtrack.sanitize (c, this)) return TRACE_RETURN (false);\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n    if (!input.sanitize (c, this)) return TRACE_RETURN (false);\n    if (!input.len) return TRACE_RETURN (false); /* To be consistent with Context. */\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n    if (!lookahead.sanitize (c, this)) return TRACE_RETURN (false);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    return TRACE_RETURN (lookup.sanitize (c));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 3 */\n  OffsetArrayOf<Coverage>\n\t\tbacktrack;\t\t/* Array of coverage tables\n\t\t\t\t\t * in backtracking sequence, in  glyph\n\t\t\t\t\t * sequence order */\n  OffsetArrayOf<Coverage>\n\t\tinputX\t\t;\t/* Array of coverage\n\t\t\t\t\t * tables in input sequence, in glyph\n\t\t\t\t\t * sequence order */\n  OffsetArrayOf<Coverage>\n\t\tlookaheadX;\t\t/* Array of coverage tables\n\t\t\t\t\t * in lookahead sequence, in glyph\n\t\t\t\t\t * sequence order */\n  ArrayOf<LookupRecord>\n\t\tlookupX;\t\t/* Array of LookupRecords--in\n\t\t\t\t\t * design order) */\n  public:\n  DEFINE_SIZE_MIN (10);\n};\n\nstruct ChainContext\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    case 2: return TRACE_RETURN (c->dispatch (u.format2));\n    case 3: return TRACE_RETURN (c->dispatch (u.format3));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t/* Format identifier */\n  ChainContextFormat1\tformat1;\n  ChainContextFormat2\tformat2;\n  ChainContextFormat3\tformat3;\n  } u;\n};\n\n\ntemplate <typename T>\nstruct ExtensionFormat1\n{\n  inline unsigned int get_type (void) const { return extensionLookupType; }\n\n  template <typename X>\n  inline const X& get_subtable (void) const\n  {\n    unsigned int offset = extensionOffset;\n    if (unlikely (!offset)) return Null(typename T::LookupSubTable);\n    return StructAtOffset<typename T::LookupSubTable> (this, offset);\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, format);\n    if (unlikely (!c->may_dispatch (this, this))) TRACE_RETURN (c->default_return_value ());\n    return TRACE_RETURN (get_subtable<typename T::LookupSubTable> ().dispatch (c, get_type ()));\n  }\n\n  /* This is called from may_dispatch() above with hb_sanitize_context_t. */\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && extensionOffset != 0);\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier. Set to 1. */\n  USHORT\textensionLookupType;\t/* Lookup type of subtable referenced\n\t\t\t\t\t * by ExtensionOffset (i.e. the\n\t\t\t\t\t * extension subtable). */\n  ULONG\t\textensionOffset;\t/* Offset to the extension subtable,\n\t\t\t\t\t * of lookup type subtable. */\n  public:\n  DEFINE_SIZE_STATIC (8);\n};\n\ntemplate <typename T>\nstruct Extension\n{\n  inline unsigned int get_type (void) const\n  {\n    switch (u.format) {\n    case 1: return u.format1.get_type ();\n    default:return 0;\n    }\n  }\n  template <typename X>\n  inline const X& get_subtable (void) const\n  {\n    switch (u.format) {\n    case 1: return u.format1.template get_subtable<typename T::LookupSubTable> ();\n    default:return Null(typename T::LookupSubTable);\n    }\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.dispatch (c));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  ExtensionFormat1<T>\tformat1;\n  } u;\n};\n\n\n/*\n * GSUB/GPOS Common\n */\n\nstruct GSUBGPOS\n{\n  static const hb_tag_t GSUBTag\t= HB_OT_TAG_GSUB;\n  static const hb_tag_t GPOSTag\t= HB_OT_TAG_GPOS;\n\n  inline unsigned int get_script_count (void) const\n  { return (this+scriptList).len; }\n  inline const Tag& get_script_tag (unsigned int i) const\n  { return (this+scriptList).get_tag (i); }\n  inline unsigned int get_script_tags (unsigned int start_offset,\n\t\t\t\t       unsigned int *script_count /* IN/OUT */,\n\t\t\t\t       hb_tag_t     *script_tags /* OUT */) const\n  { return (this+scriptList).get_tags (start_offset, script_count, script_tags); }\n  inline const Script& get_script (unsigned int i) const\n  { return (this+scriptList)[i]; }\n  inline bool find_script_index (hb_tag_t tag, unsigned int *index) const\n  { return (this+scriptList).find_index (tag, index); }\n\n  inline unsigned int get_feature_count (void) const\n  { return (this+featureList).len; }\n  inline hb_tag_t get_feature_tag (unsigned int i) const\n  { return i == Index::NOT_FOUND_INDEX ? HB_TAG_NONE : (this+featureList).get_tag (i); }\n  inline unsigned int get_feature_tags (unsigned int start_offset,\n\t\t\t\t\tunsigned int *feature_count /* IN/OUT */,\n\t\t\t\t\thb_tag_t     *feature_tags /* OUT */) const\n  { return (this+featureList).get_tags (start_offset, feature_count, feature_tags); }\n  inline const Feature& get_feature (unsigned int i) const\n  { return (this+featureList)[i]; }\n  inline bool find_feature_index (hb_tag_t tag, unsigned int *index) const\n  { return (this+featureList).find_index (tag, index); }\n\n  inline unsigned int get_lookup_count (void) const\n  { return (this+lookupList).len; }\n  inline const Lookup& get_lookup (unsigned int i) const\n  { return (this+lookupList)[i]; }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (version.sanitize (c) && likely (version.major == 1) &&\n\t\t\t scriptList.sanitize (c, this) &&\n\t\t\t featureList.sanitize (c, this) &&\n\t\t\t lookupList.sanitize (c, this));\n  }\n\n  protected:\n  FixedVersion\tversion;\t/* Version of the GSUB/GPOS table--initially set\n\t\t\t\t * to 0x00010000u */\n  OffsetTo<ScriptList>\n\t\tscriptList;  \t/* ScriptList table */\n  OffsetTo<FeatureList>\n\t\tfeatureList; \t/* FeatureList table */\n  OffsetTo<LookupList>\n\t\tlookupList; \t/* LookupList table */\n  public:\n  DEFINE_SIZE_STATIC (10);\n};\n\n\n} /* namespace OT */\n\n\n#endif /* HB_OT_LAYOUT_GSUBGPOS_PRIVATE_HH */\n"], "fixing_code": ["/*\n * Copyright \u00a9 2007,2008,2009,2010  Red Hat, Inc.\n * Copyright \u00a9 2010,2012,2013  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Red Hat Author(s): Behdad Esfahbod\n * Google Author(s): Behdad Esfahbod\n */\n\n#ifndef HB_OT_LAYOUT_GPOS_TABLE_HH\n#define HB_OT_LAYOUT_GPOS_TABLE_HH\n\n#include \"hb-ot-layout-gsubgpos-private.hh\"\n\n\nnamespace OT {\n\n\n/* buffer **position** var allocations */\n#define attach_lookback() var.u16[0] /* number of glyphs to go back to attach this glyph to its base */\n#define cursive_chain() var.i16[1] /* character to which this connects, may be positive or negative */\n\n\n/* Shared Tables: ValueRecord, Anchor Table, and MarkArray */\n\ntypedef USHORT Value;\n\ntypedef Value ValueRecord[VAR];\n\nstruct ValueFormat : USHORT\n{\n  enum Flags {\n    xPlacement\t= 0x0001u,\t/* Includes horizontal adjustment for placement */\n    yPlacement\t= 0x0002u,\t/* Includes vertical adjustment for placement */\n    xAdvance\t= 0x0004u,\t/* Includes horizontal adjustment for advance */\n    yAdvance\t= 0x0008u,\t/* Includes vertical adjustment for advance */\n    xPlaDevice\t= 0x0010u,\t/* Includes horizontal Device table for placement */\n    yPlaDevice\t= 0x0020u,\t/* Includes vertical Device table for placement */\n    xAdvDevice\t= 0x0040u,\t/* Includes horizontal Device table for advance */\n    yAdvDevice\t= 0x0080u,\t/* Includes vertical Device table for advance */\n    ignored\t= 0x0F00u,\t/* Was used in TrueType Open for MM fonts */\n    reserved\t= 0xF000u,\t/* For future use */\n\n    devices\t= 0x00F0u\t/* Mask for having any Device table */\n  };\n\n/* All fields are options.  Only those available advance the value pointer. */\n#if 0\n  SHORT\t\txPlacement;\t\t/* Horizontal adjustment for\n\t\t\t\t\t * placement--in design units */\n  SHORT\t\tyPlacement;\t\t/* Vertical adjustment for\n\t\t\t\t\t * placement--in design units */\n  SHORT\t\txAdvance;\t\t/* Horizontal adjustment for\n\t\t\t\t\t * advance--in design units (only used\n\t\t\t\t\t * for horizontal writing) */\n  SHORT\t\tyAdvance;\t\t/* Vertical adjustment for advance--in\n\t\t\t\t\t * design units (only used for vertical\n\t\t\t\t\t * writing) */\n  Offset\txPlaDevice;\t\t/* Offset to Device table for\n\t\t\t\t\t * horizontal placement--measured from\n\t\t\t\t\t * beginning of PosTable (may be NULL) */\n  Offset\tyPlaDevice;\t\t/* Offset to Device table for vertical\n\t\t\t\t\t * placement--measured from beginning\n\t\t\t\t\t * of PosTable (may be NULL) */\n  Offset\txAdvDevice;\t\t/* Offset to Device table for\n\t\t\t\t\t * horizontal advance--measured from\n\t\t\t\t\t * beginning of PosTable (may be NULL) */\n  Offset\tyAdvDevice;\t\t/* Offset to Device table for vertical\n\t\t\t\t\t * advance--measured from beginning of\n\t\t\t\t\t * PosTable (may be NULL) */\n#endif\n\n  inline unsigned int get_len (void) const\n  { return _hb_popcount32 ((unsigned int) *this); }\n  inline unsigned int get_size (void) const\n  { return get_len () * Value::static_size; }\n\n  void apply_value (hb_font_t            *font,\n\t\t    hb_direction_t        direction,\n\t\t    const void           *base,\n\t\t    const Value          *values,\n\t\t    hb_glyph_position_t  &glyph_pos) const\n  {\n    unsigned int x_ppem, y_ppem;\n    unsigned int format = *this;\n    hb_bool_t horizontal = HB_DIRECTION_IS_HORIZONTAL (direction);\n\n    if (!format) return;\n\n    if (format & xPlacement) glyph_pos.x_offset  += font->em_scale_x (get_short (values++));\n    if (format & yPlacement) glyph_pos.y_offset  += font->em_scale_y (get_short (values++));\n    if (format & xAdvance) {\n      if (likely (horizontal)) glyph_pos.x_advance += font->em_scale_x (get_short (values));\n      values++;\n    }\n    /* y_advance values grow downward but font-space grows upward, hence negation */\n    if (format & yAdvance) {\n      if (unlikely (!horizontal)) glyph_pos.y_advance -= font->em_scale_y (get_short (values));\n      values++;\n    }\n\n    if (!has_device ()) return;\n\n    x_ppem = font->x_ppem;\n    y_ppem = font->y_ppem;\n\n    if (!x_ppem && !y_ppem) return;\n\n    /* pixel -> fractional pixel */\n    if (format & xPlaDevice) {\n      if (x_ppem) glyph_pos.x_offset  += (base + get_device (values)).get_x_delta (font);\n      values++;\n    }\n    if (format & yPlaDevice) {\n      if (y_ppem) glyph_pos.y_offset  += (base + get_device (values)).get_y_delta (font);\n      values++;\n    }\n    if (format & xAdvDevice) {\n      if (horizontal && x_ppem) glyph_pos.x_advance += (base + get_device (values)).get_x_delta (font);\n      values++;\n    }\n    if (format & yAdvDevice) {\n      /* y_advance values grow downward but font-space grows upward, hence negation */\n      if (!horizontal && y_ppem) glyph_pos.y_advance -= (base + get_device (values)).get_y_delta (font);\n      values++;\n    }\n  }\n\n  private:\n  inline bool sanitize_value_devices (hb_sanitize_context_t *c, const void *base, const Value *values) const\n  {\n    unsigned int format = *this;\n\n    if (format & xPlacement) values++;\n    if (format & yPlacement) values++;\n    if (format & xAdvance)   values++;\n    if (format & yAdvance)   values++;\n\n    if ((format & xPlaDevice) && !get_device (values++).sanitize (c, base)) return false;\n    if ((format & yPlaDevice) && !get_device (values++).sanitize (c, base)) return false;\n    if ((format & xAdvDevice) && !get_device (values++).sanitize (c, base)) return false;\n    if ((format & yAdvDevice) && !get_device (values++).sanitize (c, base)) return false;\n\n    return true;\n  }\n\n  static inline OffsetTo<Device>& get_device (Value* value)\n  { return *CastP<OffsetTo<Device> > (value); }\n  static inline const OffsetTo<Device>& get_device (const Value* value)\n  { return *CastP<OffsetTo<Device> > (value); }\n\n  static inline const SHORT& get_short (const Value* value)\n  { return *CastP<SHORT> (value); }\n\n  public:\n\n  inline bool has_device (void) const {\n    unsigned int format = *this;\n    return (format & devices) != 0;\n  }\n\n  inline bool sanitize_value (hb_sanitize_context_t *c, const void *base, const Value *values) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_range (values, get_size ()) && (!has_device () || sanitize_value_devices (c, base, values)));\n  }\n\n  inline bool sanitize_values (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count) const\n  {\n    TRACE_SANITIZE (this);\n    unsigned int len = get_len ();\n\n    if (!c->check_array (values, get_size (), count)) return TRACE_RETURN (false);\n\n    if (!has_device ()) return TRACE_RETURN (true);\n\n    for (unsigned int i = 0; i < count; i++) {\n      if (!sanitize_value_devices (c, base, values))\n        return TRACE_RETURN (false);\n      values += len;\n    }\n\n    return TRACE_RETURN (true);\n  }\n\n  /* Just sanitize referenced Device tables.  Doesn't check the values themselves. */\n  inline bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count, unsigned int stride) const\n  {\n    TRACE_SANITIZE (this);\n\n    if (!has_device ()) return TRACE_RETURN (true);\n\n    for (unsigned int i = 0; i < count; i++) {\n      if (!sanitize_value_devices (c, base, values))\n        return TRACE_RETURN (false);\n      values += stride;\n    }\n\n    return TRACE_RETURN (true);\n  }\n};\n\n\nstruct AnchorFormat1\n{\n  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id HB_UNUSED,\n\t\t\t  hb_position_t *x, hb_position_t *y) const\n  {\n      *x = font->em_scale_x (xCoordinate);\n      *y = font->em_scale_y (yCoordinate);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  SHORT\t\txCoordinate;\t\t/* Horizontal value--in design units */\n  SHORT\t\tyCoordinate;\t\t/* Vertical value--in design units */\n  public:\n  DEFINE_SIZE_STATIC (6);\n};\n\nstruct AnchorFormat2\n{\n  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id,\n\t\t\t  hb_position_t *x, hb_position_t *y) const\n  {\n      unsigned int x_ppem = font->x_ppem;\n      unsigned int y_ppem = font->y_ppem;\n      hb_position_t cx, cy;\n      hb_bool_t ret;\n\n      ret = (x_ppem || y_ppem) &&\n             font->get_glyph_contour_point_for_origin (glyph_id, anchorPoint, HB_DIRECTION_LTR, &cx, &cy);\n      *x = ret && x_ppem ? cx : font->em_scale_x (xCoordinate);\n      *y = ret && y_ppem ? cy : font->em_scale_y (yCoordinate);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  SHORT\t\txCoordinate;\t\t/* Horizontal value--in design units */\n  SHORT\t\tyCoordinate;\t\t/* Vertical value--in design units */\n  USHORT\tanchorPoint;\t\t/* Index to glyph contour point */\n  public:\n  DEFINE_SIZE_STATIC (8);\n};\n\nstruct AnchorFormat3\n{\n  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id HB_UNUSED,\n\t\t\t  hb_position_t *x, hb_position_t *y) const\n  {\n      *x = font->em_scale_x (xCoordinate);\n      *y = font->em_scale_y (yCoordinate);\n\n      if (font->x_ppem)\n\t*x += (this+xDeviceTable).get_x_delta (font);\n      if (font->y_ppem)\n\t*y += (this+yDeviceTable).get_x_delta (font);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && xDeviceTable.sanitize (c, this) && yDeviceTable.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 3 */\n  SHORT\t\txCoordinate;\t\t/* Horizontal value--in design units */\n  SHORT\t\tyCoordinate;\t\t/* Vertical value--in design units */\n  OffsetTo<Device>\n\t\txDeviceTable;\t\t/* Offset to Device table for X\n\t\t\t\t\t * coordinate-- from beginning of\n\t\t\t\t\t * Anchor table (may be NULL) */\n  OffsetTo<Device>\n\t\tyDeviceTable;\t\t/* Offset to Device table for Y\n\t\t\t\t\t * coordinate-- from beginning of\n\t\t\t\t\t * Anchor table (may be NULL) */\n  public:\n  DEFINE_SIZE_STATIC (10);\n};\n\nstruct Anchor\n{\n  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id,\n\t\t\t  hb_position_t *x, hb_position_t *y) const\n  {\n    *x = *y = 0;\n    switch (u.format) {\n    case 1: u.format1.get_anchor (font, glyph_id, x, y); return;\n    case 2: u.format2.get_anchor (font, glyph_id, x, y); return;\n    case 3: u.format3.get_anchor (font, glyph_id, x, y); return;\n    default:\t\t\t\t\t\t return;\n    }\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!u.format.sanitize (c)) return TRACE_RETURN (false);\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.sanitize (c));\n    case 2: return TRACE_RETURN (u.format2.sanitize (c));\n    case 3: return TRACE_RETURN (u.format3.sanitize (c));\n    default:return TRACE_RETURN (true);\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  AnchorFormat1\t\tformat1;\n  AnchorFormat2\t\tformat2;\n  AnchorFormat3\t\tformat3;\n  } u;\n  public:\n  DEFINE_SIZE_UNION (2, format);\n};\n\n\nstruct AnchorMatrix\n{\n  inline const Anchor& get_anchor (unsigned int row, unsigned int col, unsigned int cols, bool *found) const {\n    *found = false;\n    if (unlikely (row >= rows || col >= cols)) return Null(Anchor);\n    *found = !matrixZ[row * cols + col].is_null ();\n    return this+matrixZ[row * cols + col];\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c, unsigned int cols) const\n  {\n    TRACE_SANITIZE (this);\n    if (!c->check_struct (this)) return TRACE_RETURN (false);\n    if (unlikely (rows > 0 && cols >= ((unsigned int) -1) / rows)) return TRACE_RETURN (false);\n    unsigned int count = rows * cols;\n    if (!c->check_array (matrixZ, matrixZ[0].static_size, count)) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < count; i++)\n      if (!matrixZ[i].sanitize (c, this)) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  USHORT\trows;\t\t\t/* Number of rows */\n  protected:\n  OffsetTo<Anchor>\n\t\tmatrixZ[VAR];\t\t/* Matrix of offsets to Anchor tables--\n\t\t\t\t\t * from beginning of AnchorMatrix table */\n  public:\n  DEFINE_SIZE_ARRAY (2, matrixZ);\n};\n\n\nstruct MarkRecord\n{\n  friend struct MarkArray;\n\n  inline bool sanitize (hb_sanitize_context_t *c, const void *base) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && markAnchor.sanitize (c, base));\n  }\n\n  protected:\n  USHORT\tklass;\t\t\t/* Class defined for this mark */\n  OffsetTo<Anchor>\n\t\tmarkAnchor;\t\t/* Offset to Anchor table--from\n\t\t\t\t\t * beginning of MarkArray table */\n  public:\n  DEFINE_SIZE_STATIC (4);\n};\n\nstruct MarkArray : ArrayOf<MarkRecord>\t/* Array of MarkRecords--in Coverage order */\n{\n  inline bool apply (hb_apply_context_t *c,\n\t\t     unsigned int mark_index, unsigned int glyph_index,\n\t\t     const AnchorMatrix &anchors, unsigned int class_count,\n\t\t     unsigned int glyph_pos) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    const MarkRecord &record = ArrayOf<MarkRecord>::operator[](mark_index);\n    unsigned int mark_class = record.klass;\n\n    const Anchor& mark_anchor = this + record.markAnchor;\n    bool found;\n    const Anchor& glyph_anchor = anchors.get_anchor (glyph_index, mark_class, class_count, &found);\n    /* If this subtable doesn't have an anchor for this base and this class,\n     * return false such that the subsequent subtables have a chance at it. */\n    if (unlikely (!found)) return TRACE_RETURN (false);\n\n    hb_position_t mark_x, mark_y, base_x, base_y;\n\n    mark_anchor.get_anchor (c->font, buffer->cur().codepoint, &mark_x, &mark_y);\n    glyph_anchor.get_anchor (c->font, buffer->info[glyph_pos].codepoint, &base_x, &base_y);\n\n    hb_glyph_position_t &o = buffer->cur_pos();\n    o.x_offset = base_x - mark_x;\n    o.y_offset = base_y - mark_y;\n    o.attach_lookback() = buffer->idx - glyph_pos;\n\n    buffer->idx++;\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (ArrayOf<MarkRecord>::sanitize (c, this));\n  }\n};\n\n\n/* Lookups */\n\nstruct SinglePosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    valueFormat.apply_value (c->font, c->direction, this,\n\t\t\t     values, buffer->cur_pos());\n\n    buffer->idx++;\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this)\n        && coverage.sanitize (c, this)\n\t&& valueFormat.sanitize_value (c, this, values));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of subtable */\n  ValueFormat\tvalueFormat;\t\t/* Defines the types of data in the\n\t\t\t\t\t * ValueRecord */\n  ValueRecord\tvalues;\t\t\t/* Defines positioning\n\t\t\t\t\t * value(s)--applied to all glyphs in\n\t\t\t\t\t * the Coverage table */\n  public:\n  DEFINE_SIZE_ARRAY (6, values);\n};\n\nstruct SinglePosFormat2\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    if (likely (index >= valueCount)) return TRACE_RETURN (false);\n\n    valueFormat.apply_value (c->font, c->direction, this,\n\t\t\t     &values[index * valueFormat.get_len ()],\n\t\t\t     buffer->cur_pos());\n\n    buffer->idx++;\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this)\n\t&& coverage.sanitize (c, this)\n\t&& valueFormat.sanitize_values (c, this, values, valueCount));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of subtable */\n  ValueFormat\tvalueFormat;\t\t/* Defines the types of data in the\n\t\t\t\t\t * ValueRecord */\n  USHORT\tvalueCount;\t\t/* Number of ValueRecords */\n  ValueRecord\tvalues;\t\t\t/* Array of ValueRecords--positioning\n\t\t\t\t\t * values applied to glyphs */\n  public:\n  DEFINE_SIZE_ARRAY (8, values);\n};\n\nstruct SinglePos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    case 2: return TRACE_RETURN (c->dispatch (u.format2));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  SinglePosFormat1\tformat1;\n  SinglePosFormat2\tformat2;\n  } u;\n};\n\n\nstruct PairValueRecord\n{\n  friend struct PairSet;\n\n  protected:\n  GlyphID\tsecondGlyph;\t\t/* GlyphID of second glyph in the\n\t\t\t\t\t * pair--first glyph is listed in the\n\t\t\t\t\t * Coverage table */\n  ValueRecord\tvalues;\t\t\t/* Positioning data for the first glyph\n\t\t\t\t\t * followed by for second glyph */\n  public:\n  DEFINE_SIZE_ARRAY (2, values);\n};\n\nstruct PairSet\n{\n  friend struct PairPosFormat1;\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c,\n\t\t\t      const ValueFormat *valueFormats) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int len1 = valueFormats[0].get_len ();\n    unsigned int len2 = valueFormats[1].get_len ();\n    unsigned int record_size = USHORT::static_size * (1 + len1 + len2);\n\n    const PairValueRecord *record = CastP<PairValueRecord> (arrayZ);\n    unsigned int count = len;\n    for (unsigned int i = 0; i < count; i++)\n    {\n      c->input->add (record->secondGlyph);\n      record = &StructAtOffset<PairValueRecord> (record, record_size);\n    }\n  }\n\n  inline bool apply (hb_apply_context_t *c,\n\t\t     const ValueFormat *valueFormats,\n\t\t     unsigned int pos) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int len1 = valueFormats[0].get_len ();\n    unsigned int len2 = valueFormats[1].get_len ();\n    unsigned int record_size = USHORT::static_size * (1 + len1 + len2);\n\n    const PairValueRecord *record_array = CastP<PairValueRecord> (arrayZ);\n    unsigned int count = len;\n\n    /* Hand-coded bsearch. */\n    if (unlikely (!count))\n      return TRACE_RETURN (false);\n    hb_codepoint_t x = buffer->info[pos].codepoint;\n    int min = 0, max = (int) count - 1;\n    while (min <= max)\n    {\n      int mid = (min + max) / 2;\n      const PairValueRecord *record = &StructAtOffset<PairValueRecord> (record_array, record_size * mid);\n      hb_codepoint_t mid_x = record->secondGlyph;\n      if (x < mid_x)\n        max = mid - 1;\n      else if (x > mid_x)\n        min = mid + 1;\n      else\n      {\n\tvalueFormats[0].apply_value (c->font, c->direction, this,\n\t\t\t\t     &record->values[0], buffer->cur_pos());\n\tvalueFormats[1].apply_value (c->font, c->direction, this,\n\t\t\t\t     &record->values[len1], buffer->pos[pos]);\n\tif (len2)\n\t  pos++;\n\tbuffer->idx = pos;\n\treturn TRACE_RETURN (true);\n      }\n    }\n\n    return TRACE_RETURN (false);\n  }\n\n  struct sanitize_closure_t {\n    const void *base;\n    const ValueFormat *valueFormats;\n    unsigned int len1; /* valueFormats[0].get_len() */\n    unsigned int stride; /* 1 + len1 + len2 */\n  };\n\n  inline bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const\n  {\n    TRACE_SANITIZE (this);\n    if (!(c->check_struct (this)\n       && c->check_array (arrayZ, USHORT::static_size * closure->stride, len))) return TRACE_RETURN (false);\n\n    unsigned int count = len;\n    const PairValueRecord *record = CastP<PairValueRecord> (arrayZ);\n    return TRACE_RETURN (closure->valueFormats[0].sanitize_values_stride_unsafe (c, closure->base, &record->values[0], count, closure->stride)\n\t\t      && closure->valueFormats[1].sanitize_values_stride_unsafe (c, closure->base, &record->values[closure->len1], count, closure->stride));\n  }\n\n  protected:\n  USHORT\tlen;\t\t\t/* Number of PairValueRecords */\n  USHORT\tarrayZ[VAR];\t\t/* Array of PairValueRecords--ordered\n\t\t\t\t\t * by GlyphID of the second glyph */\n  public:\n  DEFINE_SIZE_ARRAY (2, arrayZ);\n};\n\nstruct PairPosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n    unsigned int count = pairSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+pairSet[i]).collect_glyphs (c, &valueFormat1);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    if (!skippy_iter.next ()) return TRACE_RETURN (false);\n\n    return TRACE_RETURN ((this+pairSet[index]).apply (c, &valueFormat1, skippy_iter.idx));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n\n    unsigned int len1 = valueFormat1.get_len ();\n    unsigned int len2 = valueFormat2.get_len ();\n    PairSet::sanitize_closure_t closure = {\n      this,\n      &valueFormat1,\n      len1,\n      1 + len1 + len2\n    };\n\n    return TRACE_RETURN (c->check_struct (this) && coverage.sanitize (c, this) && pairSet.sanitize (c, this, &closure));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of subtable */\n  ValueFormat\tvalueFormat1;\t\t/* Defines the types of data in\n\t\t\t\t\t * ValueRecord1--for the first glyph\n\t\t\t\t\t * in the pair--may be zero (0) */\n  ValueFormat\tvalueFormat2;\t\t/* Defines the types of data in\n\t\t\t\t\t * ValueRecord2--for the second glyph\n\t\t\t\t\t * in the pair--may be zero (0) */\n  OffsetArrayOf<PairSet>\n\t\tpairSet;\t\t/* Array of PairSet tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (10, pairSet);\n};\n\nstruct PairPosFormat2\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    /* (this+coverage).add_coverage (c->input); // Don't need this. */\n\n    unsigned int count1 = class1Count;\n    const ClassDef &klass1 = this+classDef1;\n    for (unsigned int i = 0; i < count1; i++)\n      klass1.add_class (c->input, i);\n\n    unsigned int count2 = class2Count;\n    const ClassDef &klass2 = this+classDef2;\n    for (unsigned int i = 0; i < count2; i++)\n      klass2.add_class (c->input, i);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    if (!skippy_iter.next ()) return TRACE_RETURN (false);\n\n    unsigned int len1 = valueFormat1.get_len ();\n    unsigned int len2 = valueFormat2.get_len ();\n    unsigned int record_len = len1 + len2;\n\n    unsigned int klass1 = (this+classDef1).get_class (buffer->cur().codepoint);\n    unsigned int klass2 = (this+classDef2).get_class (buffer->info[skippy_iter.idx].codepoint);\n    if (unlikely (klass1 >= class1Count || klass2 >= class2Count)) return TRACE_RETURN (false);\n\n    const Value *v = &values[record_len * (klass1 * class2Count + klass2)];\n    valueFormat1.apply_value (c->font, c->direction, this,\n\t\t\t      v, buffer->cur_pos());\n    valueFormat2.apply_value (c->font, c->direction, this,\n\t\t\t      v + len1, buffer->pos[skippy_iter.idx]);\n\n    buffer->idx = skippy_iter.idx;\n    if (len2)\n      buffer->idx++;\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!(c->check_struct (this)\n       && coverage.sanitize (c, this)\n       && classDef1.sanitize (c, this)\n       && classDef2.sanitize (c, this))) return TRACE_RETURN (false);\n\n    unsigned int len1 = valueFormat1.get_len ();\n    unsigned int len2 = valueFormat2.get_len ();\n    unsigned int stride = len1 + len2;\n    unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();\n    unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;\n    return TRACE_RETURN (c->check_array (values, record_size, count) &&\n\t\t\t valueFormat1.sanitize_values_stride_unsafe (c, this, &values[0], count, stride) &&\n\t\t\t valueFormat2.sanitize_values_stride_unsafe (c, this, &values[len1], count, stride));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of subtable */\n  ValueFormat\tvalueFormat1;\t\t/* ValueRecord definition--for the\n\t\t\t\t\t * first glyph of the pair--may be zero\n\t\t\t\t\t * (0) */\n  ValueFormat\tvalueFormat2;\t\t/* ValueRecord definition--for the\n\t\t\t\t\t * second glyph of the pair--may be\n\t\t\t\t\t * zero (0) */\n  OffsetTo<ClassDef>\n\t\tclassDef1;\t\t/* Offset to ClassDef table--from\n\t\t\t\t\t * beginning of PairPos subtable--for\n\t\t\t\t\t * the first glyph of the pair */\n  OffsetTo<ClassDef>\n\t\tclassDef2;\t\t/* Offset to ClassDef table--from\n\t\t\t\t\t * beginning of PairPos subtable--for\n\t\t\t\t\t * the second glyph of the pair */\n  USHORT\tclass1Count;\t\t/* Number of classes in ClassDef1\n\t\t\t\t\t * table--includes Class0 */\n  USHORT\tclass2Count;\t\t/* Number of classes in ClassDef2\n\t\t\t\t\t * table--includes Class0 */\n  ValueRecord\tvalues;\t\t\t/* Matrix of value pairs:\n\t\t\t\t\t * class1-major, class2-minor,\n\t\t\t\t\t * Each entry has value1 and value2 */\n  public:\n  DEFINE_SIZE_ARRAY (16, values);\n};\n\nstruct PairPos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    case 2: return TRACE_RETURN (c->dispatch (u.format2));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  PairPosFormat1\tformat1;\n  PairPosFormat2\tformat2;\n  } u;\n};\n\n\nstruct EntryExitRecord\n{\n  friend struct CursivePosFormat1;\n\n  inline bool sanitize (hb_sanitize_context_t *c, const void *base) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (entryAnchor.sanitize (c, base) && exitAnchor.sanitize (c, base));\n  }\n\n  protected:\n  OffsetTo<Anchor>\n\t\tentryAnchor;\t\t/* Offset to EntryAnchor table--from\n\t\t\t\t\t * beginning of CursivePos\n\t\t\t\t\t * subtable--may be NULL */\n  OffsetTo<Anchor>\n\t\texitAnchor;\t\t/* Offset to ExitAnchor table--from\n\t\t\t\t\t * beginning of CursivePos\n\t\t\t\t\t * subtable--may be NULL */\n  public:\n  DEFINE_SIZE_STATIC (4);\n};\n\nstatic void\nreverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent);\n\nstruct CursivePosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n\n    /* We don't handle mark glyphs here. */\n    if (unlikely (_hb_glyph_info_is_mark (&buffer->cur()))) return TRACE_RETURN (false);\n\n    const EntryExitRecord &this_record = entryExitRecord[(this+coverage).get_coverage  (buffer->cur().codepoint)];\n    if (!this_record.exitAnchor) return TRACE_RETURN (false);\n\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    if (!skippy_iter.next ()) return TRACE_RETURN (false);\n\n    const EntryExitRecord &next_record = entryExitRecord[(this+coverage).get_coverage  (buffer->info[skippy_iter.idx].codepoint)];\n    if (!next_record.entryAnchor) return TRACE_RETURN (false);\n\n    unsigned int i = buffer->idx;\n    unsigned int j = skippy_iter.idx;\n\n    hb_position_t entry_x, entry_y, exit_x, exit_y;\n    (this+this_record.exitAnchor).get_anchor (c->font, buffer->info[i].codepoint, &exit_x, &exit_y);\n    (this+next_record.entryAnchor).get_anchor (c->font, buffer->info[j].codepoint, &entry_x, &entry_y);\n\n    hb_glyph_position_t *pos = buffer->pos;\n\n    hb_position_t d;\n    /* Main-direction adjustment */\n    switch (c->direction) {\n      case HB_DIRECTION_LTR:\n\tpos[i].x_advance  =  exit_x + pos[i].x_offset;\n\n\td = entry_x + pos[j].x_offset;\n\tpos[j].x_advance -= d;\n\tpos[j].x_offset  -= d;\n\tbreak;\n      case HB_DIRECTION_RTL:\n\td = exit_x + pos[i].x_offset;\n\tpos[i].x_advance -= d;\n\tpos[i].x_offset  -= d;\n\n\tpos[j].x_advance  =  entry_x + pos[j].x_offset;\n\tbreak;\n      case HB_DIRECTION_TTB:\n\tpos[i].y_advance  =  exit_y + pos[i].y_offset;\n\n\td = entry_y + pos[j].y_offset;\n\tpos[j].y_advance -= d;\n\tpos[j].y_offset  -= d;\n\tbreak;\n      case HB_DIRECTION_BTT:\n\td = exit_y + pos[i].y_offset;\n\tpos[i].y_advance -= d;\n\tpos[i].y_offset  -= d;\n\n\tpos[j].y_advance  =  entry_y;\n\tbreak;\n      case HB_DIRECTION_INVALID:\n      default:\n\tbreak;\n    }\n\n    /* Cross-direction adjustment */\n\n    /* We attach child to parent (think graph theory and rooted trees whereas\n     * the root stays on baseline and each node aligns itself against its\n     * parent.\n     *\n     * Optimize things for the case of RightToLeft, as that's most common in\n     * Arabinc. */\n    unsigned int child  = i;\n    unsigned int parent = j;\n    hb_position_t x_offset = entry_x - exit_x;\n    hb_position_t y_offset = entry_y - exit_y;\n    if  (!(c->lookup_props & LookupFlag::RightToLeft))\n    {\n      unsigned int k = child;\n      child = parent;\n      parent = k;\n      x_offset = -x_offset;\n      y_offset = -y_offset;\n    }\n\n    /* If child was already connected to someone else, walk through its old\n     * chain and reverse the link direction, such that the whole tree of its\n     * previous connection now attaches to new parent.  Watch out for case\n     * where new parent is on the path from old chain...\n     */\n    reverse_cursive_minor_offset (pos, child, c->direction, parent);\n\n    pos[child].cursive_chain() = parent - child;\n    if (likely (HB_DIRECTION_IS_HORIZONTAL (c->direction)))\n      pos[child].y_offset = y_offset;\n    else\n      pos[child].x_offset = x_offset;\n\n    buffer->idx = j;\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && entryExitRecord.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of subtable */\n  ArrayOf<EntryExitRecord>\n\t\tentryExitRecord;\t/* Array of EntryExit records--in\n\t\t\t\t\t * Coverage Index order */\n  public:\n  DEFINE_SIZE_ARRAY (6, entryExitRecord);\n};\n\nstruct CursivePos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  CursivePosFormat1\tformat1;\n  } u;\n};\n\n\ntypedef AnchorMatrix BaseArray;\t\t/* base-major--\n\t\t\t\t\t * in order of BaseCoverage Index--,\n\t\t\t\t\t * mark-minor--\n\t\t\t\t\t * ordered by class--zero-based. */\n\nstruct MarkBasePosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+markCoverage).add_coverage (c->input);\n    (this+baseCoverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+markCoverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int mark_index = (this+markCoverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (mark_index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    /* now we search backwards for a non-mark glyph */\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);\n    do {\n      if (!skippy_iter.prev ()) return TRACE_RETURN (false);\n      /* We only want to attach to the first of a MultipleSubst sequence.  Reject others. */\n      if (0 == _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx])) break;\n      skippy_iter.reject ();\n    } while (1);\n\n    /* Checking that matched glyph is actually a base glyph by GDEF is too strong; disabled */\n    if (!_hb_glyph_info_is_base_glyph (&buffer->info[skippy_iter.idx])) { /*return TRACE_RETURN (false);*/ }\n\n    unsigned int base_index = (this+baseCoverage).get_coverage  (buffer->info[skippy_iter.idx].codepoint);\n    if (base_index == NOT_COVERED) return TRACE_RETURN (false);\n\n    return TRACE_RETURN ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && markCoverage.sanitize (c, this) && baseCoverage.sanitize (c, this) &&\n\t\t\t markArray.sanitize (c, this) && baseArray.sanitize (c, this, (unsigned int) classCount));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tmarkCoverage;\t\t/* Offset to MarkCoverage table--from\n\t\t\t\t\t * beginning of MarkBasePos subtable */\n  OffsetTo<Coverage>\n\t\tbaseCoverage;\t\t/* Offset to BaseCoverage table--from\n\t\t\t\t\t * beginning of MarkBasePos subtable */\n  USHORT\tclassCount;\t\t/* Number of classes defined for marks */\n  OffsetTo<MarkArray>\n\t\tmarkArray;\t\t/* Offset to MarkArray table--from\n\t\t\t\t\t * beginning of MarkBasePos subtable */\n  OffsetTo<BaseArray>\n\t\tbaseArray;\t\t/* Offset to BaseArray table--from\n\t\t\t\t\t * beginning of MarkBasePos subtable */\n  public:\n  DEFINE_SIZE_STATIC (12);\n};\n\nstruct MarkBasePos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  MarkBasePosFormat1\tformat1;\n  } u;\n};\n\n\ntypedef AnchorMatrix LigatureAttach;\t/* component-major--\n\t\t\t\t\t * in order of writing direction--,\n\t\t\t\t\t * mark-minor--\n\t\t\t\t\t * ordered by class--zero-based. */\n\ntypedef OffsetListOf<LigatureAttach> LigatureArray;\n\t\t\t\t\t/* Array of LigatureAttach\n\t\t\t\t\t * tables ordered by\n\t\t\t\t\t * LigatureCoverage Index */\n\nstruct MarkLigPosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+markCoverage).add_coverage (c->input);\n    (this+ligatureCoverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+markCoverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int mark_index = (this+markCoverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (mark_index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    /* now we search backwards for a non-mark glyph */\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);\n    if (!skippy_iter.prev ()) return TRACE_RETURN (false);\n\n    /* Checking that matched glyph is actually a ligature by GDEF is too strong; disabled */\n    if (!_hb_glyph_info_is_ligature (&buffer->info[skippy_iter.idx])) { /*return TRACE_RETURN (false);*/ }\n\n    unsigned int j = skippy_iter.idx;\n    unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer->info[j].codepoint);\n    if (lig_index == NOT_COVERED) return TRACE_RETURN (false);\n\n    const LigatureArray& lig_array = this+ligatureArray;\n    const LigatureAttach& lig_attach = lig_array[lig_index];\n\n    /* Find component to attach to */\n    unsigned int comp_count = lig_attach.rows;\n    if (unlikely (!comp_count)) return TRACE_RETURN (false);\n\n    /* We must now check whether the ligature ID of the current mark glyph\n     * is identical to the ligature ID of the found ligature.  If yes, we\n     * can directly use the component index.  If not, we attach the mark\n     * glyph to the last component of the ligature. */\n    unsigned int comp_index;\n    unsigned int lig_id = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n    unsigned int mark_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n    unsigned int mark_comp = _hb_glyph_info_get_lig_comp (&buffer->cur());\n    if (lig_id && lig_id == mark_id && mark_comp > 0)\n      comp_index = MIN (comp_count, _hb_glyph_info_get_lig_comp (&buffer->cur())) - 1;\n    else\n      comp_index = comp_count - 1;\n\n    return TRACE_RETURN ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && markCoverage.sanitize (c, this) && ligatureCoverage.sanitize (c, this) &&\n\t\t\t markArray.sanitize (c, this) && ligatureArray.sanitize (c, this, (unsigned int) classCount));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tmarkCoverage;\t\t/* Offset to Mark Coverage table--from\n\t\t\t\t\t * beginning of MarkLigPos subtable */\n  OffsetTo<Coverage>\n\t\tligatureCoverage;\t/* Offset to Ligature Coverage\n\t\t\t\t\t * table--from beginning of MarkLigPos\n\t\t\t\t\t * subtable */\n  USHORT\tclassCount;\t\t/* Number of defined mark classes */\n  OffsetTo<MarkArray>\n\t\tmarkArray;\t\t/* Offset to MarkArray table--from\n\t\t\t\t\t * beginning of MarkLigPos subtable */\n  OffsetTo<LigatureArray>\n\t\tligatureArray;\t\t/* Offset to LigatureArray table--from\n\t\t\t\t\t * beginning of MarkLigPos subtable */\n  public:\n  DEFINE_SIZE_STATIC (12);\n};\n\nstruct MarkLigPos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  MarkLigPosFormat1\tformat1;\n  } u;\n};\n\n\ntypedef AnchorMatrix Mark2Array;\t/* mark2-major--\n\t\t\t\t\t * in order of Mark2Coverage Index--,\n\t\t\t\t\t * mark1-minor--\n\t\t\t\t\t * ordered by class--zero-based. */\n\nstruct MarkMarkPosFormat1\n{\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+mark1Coverage).add_coverage (c->input);\n    (this+mark2Coverage).add_coverage (c->input);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+mark1Coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_buffer_t *buffer = c->buffer;\n    unsigned int mark1_index = (this+mark1Coverage).get_coverage  (buffer->cur().codepoint);\n    if (likely (mark1_index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    /* now we search backwards for a suitable mark glyph until a non-mark glyph */\n    hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n    skippy_iter.reset (buffer->idx, 1);\n    skippy_iter.set_lookup_props (c->lookup_props & ~LookupFlag::IgnoreFlags);\n    if (!skippy_iter.prev ()) return TRACE_RETURN (false);\n\n    if (!_hb_glyph_info_is_mark (&buffer->info[skippy_iter.idx])) { return TRACE_RETURN (false); }\n\n    unsigned int j = skippy_iter.idx;\n\n    unsigned int id1 = _hb_glyph_info_get_lig_id (&buffer->cur());\n    unsigned int id2 = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n    unsigned int comp1 = _hb_glyph_info_get_lig_comp (&buffer->cur());\n    unsigned int comp2 = _hb_glyph_info_get_lig_comp (&buffer->info[j]);\n\n    if (likely (id1 == id2)) {\n      if (id1 == 0) /* Marks belonging to the same base. */\n\tgoto good;\n      else if (comp1 == comp2) /* Marks belonging to the same ligature component. */\n        goto good;\n    } else {\n      /* If ligature ids don't match, it may be the case that one of the marks\n       * itself is a ligature.  In which case match. */\n      if ((id1 > 0 && !comp1) || (id2 > 0 && !comp2))\n\tgoto good;\n    }\n\n    /* Didn't match. */\n    return TRACE_RETURN (false);\n\n    good:\n    unsigned int mark2_index = (this+mark2Coverage).get_coverage  (buffer->info[j].codepoint);\n    if (mark2_index == NOT_COVERED) return TRACE_RETURN (false);\n\n    return TRACE_RETURN ((this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && mark1Coverage.sanitize (c, this) &&\n\t\t\t mark2Coverage.sanitize (c, this) && mark1Array.sanitize (c, this)\n\t\t\t && mark2Array.sanitize (c, this, (unsigned int) classCount));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tmark1Coverage;\t\t/* Offset to Combining Mark1 Coverage\n\t\t\t\t\t * table--from beginning of MarkMarkPos\n\t\t\t\t\t * subtable */\n  OffsetTo<Coverage>\n\t\tmark2Coverage;\t\t/* Offset to Combining Mark2 Coverage\n\t\t\t\t\t * table--from beginning of MarkMarkPos\n\t\t\t\t\t * subtable */\n  USHORT\tclassCount;\t\t/* Number of defined mark classes */\n  OffsetTo<MarkArray>\n\t\tmark1Array;\t\t/* Offset to Mark1Array table--from\n\t\t\t\t\t * beginning of MarkMarkPos subtable */\n  OffsetTo<Mark2Array>\n\t\tmark2Array;\t\t/* Offset to Mark2Array table--from\n\t\t\t\t\t * beginning of MarkMarkPos subtable */\n  public:\n  DEFINE_SIZE_STATIC (12);\n};\n\nstruct MarkMarkPos\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  MarkMarkPosFormat1\tformat1;\n  } u;\n};\n\n\nstruct ContextPos : Context {};\n\nstruct ChainContextPos : ChainContext {};\n\nstruct ExtensionPos : Extension<ExtensionPos>\n{\n  typedef struct PosLookupSubTable LookupSubTable;\n};\n\n\n\n/*\n * PosLookup\n */\n\n\nstruct PosLookupSubTable\n{\n  friend struct PosLookup;\n\n  enum Type {\n    Single\t\t= 1,\n    Pair\t\t= 2,\n    Cursive\t\t= 3,\n    MarkBase\t\t= 4,\n    MarkLig\t\t= 5,\n    MarkMark\t\t= 6,\n    Context\t\t= 7,\n    ChainContext\t= 8,\n    Extension\t\t= 9\n  };\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const\n  {\n    TRACE_DISPATCH (this, lookup_type);\n    /* The sub_format passed to may_dispatch is unnecessary but harmless. */\n    if (unlikely (!c->may_dispatch (this, &u.sub_format))) return TRACE_RETURN (c->default_return_value ());\n    switch (lookup_type) {\n    case Single:\t\treturn TRACE_RETURN (u.single.dispatch (c));\n    case Pair:\t\t\treturn TRACE_RETURN (u.pair.dispatch (c));\n    case Cursive:\t\treturn TRACE_RETURN (u.cursive.dispatch (c));\n    case MarkBase:\t\treturn TRACE_RETURN (u.markBase.dispatch (c));\n    case MarkLig:\t\treturn TRACE_RETURN (u.markLig.dispatch (c));\n    case MarkMark:\t\treturn TRACE_RETURN (u.markMark.dispatch (c));\n    case Context:\t\treturn TRACE_RETURN (u.context.dispatch (c));\n    case ChainContext:\t\treturn TRACE_RETURN (u.chainContext.dispatch (c));\n    case Extension:\t\treturn TRACE_RETURN (u.extension.dispatch (c));\n    default:\t\t\treturn TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tsub_format;\n  SinglePos\t\tsingle;\n  PairPos\t\tpair;\n  CursivePos\t\tcursive;\n  MarkBasePos\t\tmarkBase;\n  MarkLigPos\t\tmarkLig;\n  MarkMarkPos\t\tmarkMark;\n  ContextPos\t\tcontext;\n  ChainContextPos\tchainContext;\n  ExtensionPos\t\textension;\n  } u;\n  public:\n  DEFINE_SIZE_UNION (2, sub_format);\n};\n\n\nstruct PosLookup : Lookup\n{\n  inline const PosLookupSubTable& get_subtable (unsigned int i) const\n  { return Lookup::get_subtable<PosLookupSubTable> (i); }\n\n  inline bool is_reverse (void) const\n  {\n    return false;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    return TRACE_RETURN (dispatch (c));\n  }\n\n  inline hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    return TRACE_RETURN (dispatch (c));\n  }\n\n  template <typename set_t>\n  inline void add_coverage (set_t *glyphs) const\n  {\n    hb_add_coverage_context_t<set_t> c (glyphs);\n    dispatch (&c);\n  }\n\n  static bool apply_recurse_func (hb_apply_context_t *c, unsigned int lookup_index);\n\n  template <typename context_t>\n  static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  { return Lookup::dispatch<PosLookupSubTable> (c); }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (unlikely (!Lookup::sanitize (c))) return TRACE_RETURN (false);\n    return TRACE_RETURN (dispatch (c));\n  }\n};\n\ntypedef OffsetListOf<PosLookup> PosLookupList;\n\n/*\n * GPOS -- The Glyph Positioning Table\n */\n\nstruct GPOS : GSUBGPOS\n{\n  static const hb_tag_t tableTag\t= HB_OT_TAG_GPOS;\n\n  inline const PosLookup& get_lookup (unsigned int i) const\n  { return CastR<PosLookup> (GSUBGPOS::get_lookup (i)); }\n\n  static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);\n  static inline void position_finish (hb_font_t *font, hb_buffer_t *buffer);\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (unlikely (!GSUBGPOS::sanitize (c))) return TRACE_RETURN (false);\n    const OffsetTo<PosLookupList> &list = CastR<OffsetTo<PosLookupList> > (lookupList);\n    return TRACE_RETURN (list.sanitize (c, this));\n  }\n  public:\n  DEFINE_SIZE_STATIC (10);\n};\n\n\nstatic void\nreverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent)\n{\n  unsigned int j = pos[i].cursive_chain();\n  if (likely (!j))\n    return;\n\n  j += i;\n\n  pos[i].cursive_chain() = 0;\n\n  /* Stop if we see new parent in the chain. */\n  if (j == new_parent)\n    return;\n\n  reverse_cursive_minor_offset (pos, j, direction, new_parent);\n\n  if (HB_DIRECTION_IS_HORIZONTAL (direction))\n    pos[j].y_offset = -pos[i].y_offset;\n  else\n    pos[j].x_offset = -pos[i].x_offset;\n\n  pos[j].cursive_chain() = i - j;\n}\nstatic void\nfix_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction)\n{\n  unsigned int j = pos[i].cursive_chain();\n  if (likely (!j))\n    return;\n\n  j += i;\n\n  pos[i].cursive_chain() = 0;\n\n  fix_cursive_minor_offset (pos, j, direction);\n\n  if (HB_DIRECTION_IS_HORIZONTAL (direction))\n    pos[i].y_offset += pos[j].y_offset;\n  else\n    pos[i].x_offset += pos[j].x_offset;\n}\n\nstatic void\nfix_mark_attachment (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction)\n{\n  if (likely (!(pos[i].attach_lookback())))\n    return;\n\n  unsigned int j = i - pos[i].attach_lookback();\n\n  pos[i].x_offset += pos[j].x_offset;\n  pos[i].y_offset += pos[j].y_offset;\n\n  if (HB_DIRECTION_IS_FORWARD (direction))\n    for (unsigned int k = j; k < i; k++) {\n      pos[i].x_offset -= pos[k].x_advance;\n      pos[i].y_offset -= pos[k].y_advance;\n    }\n  else\n    for (unsigned int k = j + 1; k < i + 1; k++) {\n      pos[i].x_offset += pos[k].x_advance;\n      pos[i].y_offset += pos[k].y_advance;\n    }\n}\n\nvoid\nGPOS::position_start (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)\n{\n  buffer->clear_positions ();\n\n  unsigned int count = buffer->len;\n  for (unsigned int i = 0; i < count; i++)\n    buffer->pos[i].attach_lookback() = buffer->pos[i].cursive_chain() = 0;\n}\n\nvoid\nGPOS::position_finish (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)\n{\n  _hb_buffer_assert_gsubgpos_vars (buffer);\n\n  unsigned int len;\n  hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &len);\n  hb_direction_t direction = buffer->props.direction;\n\n  /* Handle cursive connections */\n  for (unsigned int i = 0; i < len; i++)\n    fix_cursive_minor_offset (pos, i, direction);\n\n  /* Handle attachments */\n  for (unsigned int i = 0; i < len; i++)\n    fix_mark_attachment (pos, i, direction);\n}\n\n\n/* Out-of-class implementation for methods recursing */\n\ntemplate <typename context_t>\n/*static*/ inline typename context_t::return_t PosLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)\n{\n  const GPOS &gpos = *(hb_ot_layout_from_face (c->face)->gpos);\n  const PosLookup &l = gpos.get_lookup (lookup_index);\n  return l.dispatch (c);\n}\n\n/*static*/ inline bool PosLookup::apply_recurse_func (hb_apply_context_t *c, unsigned int lookup_index)\n{\n  const GPOS &gpos = *(hb_ot_layout_from_face (c->face)->gpos);\n  const PosLookup &l = gpos.get_lookup (lookup_index);\n  unsigned int saved_lookup_props = c->lookup_props;\n  unsigned int saved_lookup_index = c->lookup_index;\n  c->set_lookup_index (lookup_index);\n  c->set_lookup_props (l.get_props ());\n  bool ret = l.dispatch (c);\n  c->set_lookup_index (saved_lookup_index);\n  c->set_lookup_props (saved_lookup_props);\n  return ret;\n}\n\n\n#undef attach_lookback\n#undef cursive_chain\n\n\n} /* namespace OT */\n\n\n#endif /* HB_OT_LAYOUT_GPOS_TABLE_HH */\n", "/*\n * Copyright \u00a9 2007,2008,2009,2010  Red Hat, Inc.\n * Copyright \u00a9 2010,2012,2013  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Red Hat Author(s): Behdad Esfahbod\n * Google Author(s): Behdad Esfahbod\n */\n\n#ifndef HB_OT_LAYOUT_GSUB_TABLE_HH\n#define HB_OT_LAYOUT_GSUB_TABLE_HH\n\n#include \"hb-ot-layout-gsubgpos-private.hh\"\n\n\nnamespace OT {\n\n\nstruct SingleSubstFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      hb_codepoint_t glyph_id = iter.get_glyph ();\n      if (c->glyphs->has (glyph_id))\n\tc->glyphs->add ((glyph_id + deltaGlyphID) & 0xFFFFu);\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      hb_codepoint_t glyph_id = iter.get_glyph ();\n      c->input->add (glyph_id);\n      c->output->add ((glyph_id + deltaGlyphID) & 0xFFFFu);\n    }\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    return TRACE_RETURN (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_codepoint_t glyph_id = c->buffer->cur().codepoint;\n    unsigned int index = (this+coverage).get_coverage (glyph_id);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    /* According to the Adobe Annotated OpenType Suite, result is always\n     * limited to 16bit. */\n    glyph_id = (glyph_id + deltaGlyphID) & 0xFFFFu;\n    c->replace_glyph (glyph_id);\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t unsigned int num_glyphs,\n\t\t\t int delta)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return TRACE_RETURN (false);\n    deltaGlyphID.set (delta); /* TODO(serilaize) overflow? */\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && deltaGlyphID.sanitize (c));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of Substitution table */\n  SHORT\t\tdeltaGlyphID;\t\t/* Add to original GlyphID to get\n\t\t\t\t\t * substitute GlyphID */\n  public:\n  DEFINE_SIZE_STATIC (6);\n};\n\nstruct SingleSubstFormat2\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      if (c->glyphs->has (iter.get_glyph ()))\n\tc->glyphs->add (substitute[iter.get_coverage ()]);\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      c->input->add (iter.get_glyph ());\n      c->output->add (substitute[iter.get_coverage ()]);\n    }\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    return TRACE_RETURN (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_codepoint_t glyph_id = c->buffer->cur().codepoint;\n    unsigned int index = (this+coverage).get_coverage (glyph_id);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    if (unlikely (index >= substitute.len)) return TRACE_RETURN (false);\n\n    glyph_id = substitute[index];\n    c->replace_glyph (glyph_id);\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<GlyphID> &substitutes,\n\t\t\t unsigned int num_glyphs)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!substitute.serialize (c, substitutes, num_glyphs))) return TRACE_RETURN (false);\n    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && substitute.sanitize (c));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of Substitution table */\n  ArrayOf<GlyphID>\n\t\tsubstitute;\t\t/* Array of substitute\n\t\t\t\t\t * GlyphIDs--ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, substitute);\n};\n\nstruct SingleSubst\n{\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<GlyphID> &substitutes,\n\t\t\t unsigned int num_glyphs)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (u.format))) return TRACE_RETURN (false);\n    unsigned int format = 2;\n    int delta = 0;\n    if (num_glyphs) {\n      format = 1;\n      /* TODO(serialize) check for wrap-around */\n      delta = substitutes[0] - glyphs[0];\n      for (unsigned int i = 1; i < num_glyphs; i++)\n\tif (delta != substitutes[i] - glyphs[i]) {\n\t  format = 2;\n\t  break;\n\t}\n    }\n    u.format.set (format);\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.serialize (c, glyphs, num_glyphs, delta));\n    case 2: return TRACE_RETURN (u.format2.serialize (c, glyphs, substitutes, num_glyphs));\n    default:return TRACE_RETURN (false);\n    }\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    case 2: return TRACE_RETURN (c->dispatch (u.format2));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  SingleSubstFormat1\tformat1;\n  SingleSubstFormat2\tformat2;\n  } u;\n};\n\n\nstruct Sequence\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    unsigned int count = substitute.len;\n    for (unsigned int i = 0; i < count; i++)\n      c->glyphs->add (substitute[i]);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int count = substitute.len;\n    for (unsigned int i = 0; i < count; i++)\n      c->output->add (substitute[i]);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int count = substitute.len;\n\n    /* TODO:\n     * Testing shows that Uniscribe actually allows zero-len susbstitute,\n     * which essentially deletes a glyph.  We don't allow for now.  It\n     * can be confusing to the client since the cluster from the deleted\n     * glyph won't be merged with any output cluster...  Also, currently\n     * buffer->move_to() makes assumptions about this too.  Perhaps fix\n     * in the future after figuring out what to do with the clusters.\n     */\n    if (unlikely (!count)) return TRACE_RETURN (false);\n\n    /* Special-case to make it in-place and not consider this\n     * as a \"multiplied\" substitution. */\n    if (unlikely (count == 1))\n    {\n      c->replace_glyph (substitute.array[0]);\n      return TRACE_RETURN (true);\n    }\n\n    unsigned int klass = _hb_glyph_info_is_ligature (&c->buffer->cur()) ?\n\t\t\t HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH : 0;\n\n    for (unsigned int i = 0; i < count; i++) {\n      _hb_glyph_info_set_lig_props_for_component (&c->buffer->cur(), i);\n      c->output_glyph_for_component (substitute.array[i], klass);\n    }\n    c->buffer->skip_glyph ();\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t unsigned int num_glyphs)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!substitute.serialize (c, glyphs, num_glyphs))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (substitute.sanitize (c));\n  }\n\n  protected:\n  ArrayOf<GlyphID>\n\t\tsubstitute;\t\t/* String of GlyphIDs to substitute */\n  public:\n  DEFINE_SIZE_ARRAY (2, substitute);\n};\n\nstruct MultipleSubstFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      if (c->glyphs->has (iter.get_glyph ()))\n\t(this+sequence[iter.get_coverage ()]).closure (c);\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n    unsigned int count = sequence.len;\n    for (unsigned int i = 0; i < count; i++)\n\t(this+sequence[i]).collect_glyphs (c);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    return TRACE_RETURN (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    return TRACE_RETURN ((this+sequence[index]).apply (c));\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<unsigned int> &substitute_len_list,\n\t\t\t unsigned int num_glyphs,\n\t\t\t Supplier<GlyphID> &substitute_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!sequence.serialize (c, num_glyphs))) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < num_glyphs; i++)\n      if (unlikely (!sequence[i].serialize (c, this).serialize (c,\n\t\t\t\t\t\t\t\tsubstitute_glyphs_list,\n\t\t\t\t\t\t\t\tsubstitute_len_list[i]))) return TRACE_RETURN (false);\n    substitute_len_list.advance (num_glyphs);\n    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && sequence.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of Substitution table */\n  OffsetArrayOf<Sequence>\n\t\tsequence;\t\t/* Array of Sequence tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, sequence);\n};\n\nstruct MultipleSubst\n{\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<unsigned int> &substitute_len_list,\n\t\t\t unsigned int num_glyphs,\n\t\t\t Supplier<GlyphID> &substitute_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (u.format))) return TRACE_RETURN (false);\n    unsigned int format = 1;\n    u.format.set (format);\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.serialize (c, glyphs, substitute_len_list, num_glyphs, substitute_glyphs_list));\n    default:return TRACE_RETURN (false);\n    }\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  MultipleSubstFormat1\tformat1;\n  } u;\n};\n\n\ntypedef ArrayOf<GlyphID> AlternateSet;\t/* Array of alternate GlyphIDs--in\n\t\t\t\t\t * arbitrary order */\n\nstruct AlternateSubstFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      if (c->glyphs->has (iter.get_glyph ())) {\n\tconst AlternateSet &alt_set = this+alternateSet[iter.get_coverage ()];\n\tunsigned int count = alt_set.len;\n\tfor (unsigned int i = 0; i < count; i++)\n\t  c->glyphs->add (alt_set[i]);\n      }\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      c->input->add (iter.get_glyph ());\n      const AlternateSet &alt_set = this+alternateSet[iter.get_coverage ()];\n      unsigned int count = alt_set.len;\n      for (unsigned int i = 0; i < count; i++)\n\tc->output->add (alt_set[i]);\n    }\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    return TRACE_RETURN (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_codepoint_t glyph_id = c->buffer->cur().codepoint;\n\n    unsigned int index = (this+coverage).get_coverage (glyph_id);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const AlternateSet &alt_set = this+alternateSet[index];\n\n    if (unlikely (!alt_set.len)) return TRACE_RETURN (false);\n\n    hb_mask_t glyph_mask = c->buffer->cur().mask;\n    hb_mask_t lookup_mask = c->lookup_mask;\n\n    /* Note: This breaks badly if two features enabled this lookup together. */\n    unsigned int shift = _hb_ctz (lookup_mask);\n    unsigned int alt_index = ((lookup_mask & glyph_mask) >> shift);\n\n    if (unlikely (alt_index > alt_set.len || alt_index == 0)) return TRACE_RETURN (false);\n\n    glyph_id = alt_set[alt_index - 1];\n\n    c->replace_glyph (glyph_id);\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<unsigned int> &alternate_len_list,\n\t\t\t unsigned int num_glyphs,\n\t\t\t Supplier<GlyphID> &alternate_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!alternateSet.serialize (c, num_glyphs))) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < num_glyphs; i++)\n      if (unlikely (!alternateSet[i].serialize (c, this).serialize (c,\n\t\t\t\t\t\t\t\t    alternate_glyphs_list,\n\t\t\t\t\t\t\t\t    alternate_len_list[i]))) return TRACE_RETURN (false);\n    alternate_len_list.advance (num_glyphs);\n    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && alternateSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of Substitution table */\n  OffsetArrayOf<AlternateSet>\n\t\talternateSet;\t\t/* Array of AlternateSet tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, alternateSet);\n};\n\nstruct AlternateSubst\n{\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &glyphs,\n\t\t\t Supplier<unsigned int> &alternate_len_list,\n\t\t\t unsigned int num_glyphs,\n\t\t\t Supplier<GlyphID> &alternate_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (u.format))) return TRACE_RETURN (false);\n    unsigned int format = 1;\n    u.format.set (format);\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.serialize (c, glyphs, alternate_len_list, num_glyphs, alternate_glyphs_list));\n    default:return TRACE_RETURN (false);\n    }\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  AlternateSubstFormat1\tformat1;\n  } u;\n};\n\n\nstruct Ligature\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    unsigned int count = component.len;\n    for (unsigned int i = 1; i < count; i++)\n      if (!c->glyphs->has (component[i]))\n        return;\n    c->glyphs->add (ligGlyph);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int count = component.len;\n    for (unsigned int i = 1; i < count; i++)\n      c->input->add (component[i]);\n    c->output->add (ligGlyph);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    if (c->len != component.len)\n      return TRACE_RETURN (false);\n\n    for (unsigned int i = 1; i < c->len; i++)\n      if (likely (c->glyphs[i] != component[i]))\n\treturn TRACE_RETURN (false);\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int count = component.len;\n\n    if (unlikely (!count)) return TRACE_RETURN (false);\n\n    /* Special-case to make it in-place and not consider this\n     * as a \"ligated\" substitution. */\n    if (unlikely (count == 1))\n    {\n      c->replace_glyph (ligGlyph);\n      return TRACE_RETURN (true);\n    }\n\n    bool is_mark_ligature = false;\n    unsigned int total_component_count = 0;\n\n    unsigned int match_length = 0;\n    unsigned int match_positions[MAX_CONTEXT_LENGTH];\n\n    if (likely (!match_input (c, count,\n\t\t\t      &component[1],\n\t\t\t      match_glyph,\n\t\t\t      NULL,\n\t\t\t      &match_length,\n\t\t\t      match_positions,\n\t\t\t      &is_mark_ligature,\n\t\t\t      &total_component_count)))\n      return TRACE_RETURN (false);\n\n    ligate_input (c,\n\t\t  count,\n\t\t  match_positions,\n\t\t  match_length,\n\t\t  ligGlyph,\n\t\t  is_mark_ligature,\n\t\t  total_component_count);\n\n    return TRACE_RETURN (true);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t GlyphID ligature,\n\t\t\t Supplier<GlyphID> &components, /* Starting from second */\n\t\t\t unsigned int num_components /* Including first component */)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    ligGlyph = ligature;\n    if (unlikely (!component.serialize (c, components, num_components))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  public:\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (ligGlyph.sanitize (c) && component.sanitize (c));\n  }\n\n  protected:\n  GlyphID\tligGlyph;\t\t/* GlyphID of ligature to substitute */\n  HeadlessArrayOf<GlyphID>\n\t\tcomponent;\t\t/* Array of component GlyphIDs--start\n\t\t\t\t\t * with the second  component--ordered\n\t\t\t\t\t * in writing direction */\n  public:\n  DEFINE_SIZE_ARRAY (4, component);\n};\n\nstruct LigatureSet\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    unsigned int num_ligs = ligature.len;\n    for (unsigned int i = 0; i < num_ligs; i++)\n      (this+ligature[i]).closure (c);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int num_ligs = ligature.len;\n    for (unsigned int i = 0; i < num_ligs; i++)\n      (this+ligature[i]).collect_glyphs (c);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    unsigned int num_ligs = ligature.len;\n    for (unsigned int i = 0; i < num_ligs; i++)\n    {\n      const Ligature &lig = this+ligature[i];\n      if (lig.would_apply (c))\n        return TRACE_RETURN (true);\n    }\n    return TRACE_RETURN (false);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int num_ligs = ligature.len;\n    for (unsigned int i = 0; i < num_ligs; i++)\n    {\n      const Ligature &lig = this+ligature[i];\n      if (lig.apply (c)) return TRACE_RETURN (true);\n    }\n\n    return TRACE_RETURN (false);\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &ligatures,\n\t\t\t Supplier<unsigned int> &component_count_list,\n\t\t\t unsigned int num_ligatures,\n\t\t\t Supplier<GlyphID> &component_list /* Starting from second for each ligature */)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!ligature.serialize (c, num_ligatures))) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < num_ligatures; i++)\n      if (unlikely (!ligature[i].serialize (c, this).serialize (c,\n\t\t\t\t\t\t\t\tligatures[i],\n\t\t\t\t\t\t\t\tcomponent_list,\n\t\t\t\t\t\t\t\tcomponent_count_list[i]))) return TRACE_RETURN (false);\n    ligatures.advance (num_ligatures);\n    component_count_list.advance (num_ligatures);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (ligature.sanitize (c, this));\n  }\n\n  protected:\n  OffsetArrayOf<Ligature>\n\t\tligature;\t\t/* Array LigatureSet tables\n\t\t\t\t\t * ordered by preference */\n  public:\n  DEFINE_SIZE_ARRAY (2, ligature);\n};\n\nstruct LigatureSubstFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      if (c->glyphs->has (iter.get_glyph ()))\n\t(this+ligatureSet[iter.get_coverage ()]).closure (c);\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      c->input->add (iter.get_glyph ());\n      (this+ligatureSet[iter.get_coverage ()]).collect_glyphs (c);\n    }\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    unsigned int index = (this+coverage).get_coverage (c->glyphs[0]);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const LigatureSet &lig_set = this+ligatureSet[index];\n    return TRACE_RETURN (lig_set.would_apply (c));\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    hb_codepoint_t glyph_id = c->buffer->cur().codepoint;\n\n    unsigned int index = (this+coverage).get_coverage (glyph_id);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const LigatureSet &lig_set = this+ligatureSet[index];\n    return TRACE_RETURN (lig_set.apply (c));\n  }\n\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &first_glyphs,\n\t\t\t Supplier<unsigned int> &ligature_per_first_glyph_count_list,\n\t\t\t unsigned int num_first_glyphs,\n\t\t\t Supplier<GlyphID> &ligatures_list,\n\t\t\t Supplier<unsigned int> &component_count_list,\n\t\t\t Supplier<GlyphID> &component_list /* Starting from second for each ligature */)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (*this))) return TRACE_RETURN (false);\n    if (unlikely (!ligatureSet.serialize (c, num_first_glyphs))) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < num_first_glyphs; i++)\n      if (unlikely (!ligatureSet[i].serialize (c, this).serialize (c,\n\t\t\t\t\t\t\t\t   ligatures_list,\n\t\t\t\t\t\t\t\t   component_count_list,\n\t\t\t\t\t\t\t\t   ligature_per_first_glyph_count_list[i],\n\t\t\t\t\t\t\t\t   component_list))) return TRACE_RETURN (false);\n    ligature_per_first_glyph_count_list.advance (num_first_glyphs);\n    if (unlikely (!coverage.serialize (c, this).serialize (c, first_glyphs, num_first_glyphs))) return TRACE_RETURN (false);\n    return TRACE_RETURN (true);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && ligatureSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of Substitution table */\n  OffsetArrayOf<LigatureSet>\n\t\tligatureSet;\t\t/* Array LigatureSet tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, ligatureSet);\n};\n\nstruct LigatureSubst\n{\n  inline bool serialize (hb_serialize_context_t *c,\n\t\t\t Supplier<GlyphID> &first_glyphs,\n\t\t\t Supplier<unsigned int> &ligature_per_first_glyph_count_list,\n\t\t\t unsigned int num_first_glyphs,\n\t\t\t Supplier<GlyphID> &ligatures_list,\n\t\t\t Supplier<unsigned int> &component_count_list,\n\t\t\t Supplier<GlyphID> &component_list /* Starting from second for each ligature */)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!c->extend_min (u.format))) return TRACE_RETURN (false);\n    unsigned int format = 1;\n    u.format.set (format);\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.serialize (c, first_glyphs, ligature_per_first_glyph_count_list, num_first_glyphs,\n\t\t\t\t\t\t      ligatures_list, component_count_list, component_list));\n    default:return TRACE_RETURN (false);\n    }\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  LigatureSubstFormat1\tformat1;\n  } u;\n};\n\n\nstruct ContextSubst : Context {};\n\nstruct ChainContextSubst : ChainContext {};\n\nstruct ExtensionSubst : Extension<ExtensionSubst>\n{\n  typedef struct SubstLookupSubTable LookupSubTable;\n\n  inline bool is_reverse (void) const;\n};\n\n\nstruct ReverseChainSingleSubstFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n\n    unsigned int count;\n\n    count = backtrack.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (!(this+backtrack[i]).intersects (c->glyphs))\n        return;\n\n    count = lookahead.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (!(this+lookahead[i]).intersects (c->glyphs))\n        return;\n\n    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n    Coverage::Iter iter;\n    for (iter.init (this+coverage); iter.more (); iter.next ()) {\n      if (c->glyphs->has (iter.get_glyph ()))\n\tc->glyphs->add (substitute[iter.get_coverage ()]);\n    }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n\n    unsigned int count;\n\n    (this+coverage).add_coverage (c->input);\n\n    count = backtrack.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+backtrack[i]).add_coverage (c->before);\n\n    count = lookahead.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+lookahead[i]).add_coverage (c->after);\n\n    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n    count = substitute.len;\n    for (unsigned int i = 0; i < count; i++)\n      c->output->add (substitute[i]);\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n    return TRACE_RETURN (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    if (unlikely (c->nesting_level_left != MAX_NESTING_LEVEL))\n      return TRACE_RETURN (false); /* No chaining to this type */\n\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n\n    if (match_backtrack (c,\n\t\t\t backtrack.len, (USHORT *) backtrack.array,\n\t\t\t match_coverage, this) &&\n        match_lookahead (c,\n\t\t\t lookahead.len, (USHORT *) lookahead.array,\n\t\t\t match_coverage, this,\n\t\t\t 1))\n    {\n      c->replace_glyph_inplace (substitute[index]);\n      /* Note: We DON'T decrease buffer->idx.  The main loop does it\n       * for us.  This is useful for preventing surprises if someone\n       * calls us through a Context lookup. */\n      return TRACE_RETURN (true);\n    }\n\n    return TRACE_RETURN (false);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!(coverage.sanitize (c, this) && backtrack.sanitize (c, this)))\n      return TRACE_RETURN (false);\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n    if (!lookahead.sanitize (c, this))\n      return TRACE_RETURN (false);\n    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n    return TRACE_RETURN (substitute.sanitize (c));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of table */\n  OffsetArrayOf<Coverage>\n\t\tbacktrack;\t\t/* Array of coverage tables\n\t\t\t\t\t * in backtracking sequence, in  glyph\n\t\t\t\t\t * sequence order */\n  OffsetArrayOf<Coverage>\n\t\tlookaheadX;\t\t/* Array of coverage tables\n\t\t\t\t\t * in lookahead sequence, in glyph\n\t\t\t\t\t * sequence order */\n  ArrayOf<GlyphID>\n\t\tsubstituteX;\t\t/* Array of substitute\n\t\t\t\t\t * GlyphIDs--ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_MIN (10);\n};\n\nstruct ReverseChainSingleSubst\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\t\t\tformat;\t\t/* Format identifier */\n  ReverseChainSingleSubstFormat1\tformat1;\n  } u;\n};\n\n\n\n/*\n * SubstLookup\n */\n\nstruct SubstLookupSubTable\n{\n  friend struct SubstLookup;\n\n  enum Type {\n    Single\t\t= 1,\n    Multiple\t\t= 2,\n    Alternate\t\t= 3,\n    Ligature\t\t= 4,\n    Context\t\t= 5,\n    ChainContext\t= 6,\n    Extension\t\t= 7,\n    ReverseChainSingle\t= 8\n  };\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const\n  {\n    TRACE_DISPATCH (this, lookup_type);\n    /* The sub_format passed to may_dispatch is unnecessary but harmless. */\n    if (unlikely (!c->may_dispatch (this, &u.sub_format))) return TRACE_RETURN (c->default_return_value ());\n    switch (lookup_type) {\n    case Single:\t\treturn TRACE_RETURN (u.single.dispatch (c));\n    case Multiple:\t\treturn TRACE_RETURN (u.multiple.dispatch (c));\n    case Alternate:\t\treturn TRACE_RETURN (u.alternate.dispatch (c));\n    case Ligature:\t\treturn TRACE_RETURN (u.ligature.dispatch (c));\n    case Context:\t\treturn TRACE_RETURN (u.context.dispatch (c));\n    case ChainContext:\t\treturn TRACE_RETURN (u.chainContext.dispatch (c));\n    case Extension:\t\treturn TRACE_RETURN (u.extension.dispatch (c));\n    case ReverseChainSingle:\treturn TRACE_RETURN (u.reverseChainContextSingle.dispatch (c));\n    default:\t\t\treturn TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\t\tsub_format;\n  SingleSubst\t\t\tsingle;\n  MultipleSubst\t\t\tmultiple;\n  AlternateSubst\t\talternate;\n  LigatureSubst\t\t\tligature;\n  ContextSubst\t\t\tcontext;\n  ChainContextSubst\t\tchainContext;\n  ExtensionSubst\t\textension;\n  ReverseChainSingleSubst\treverseChainContextSingle;\n  } u;\n  public:\n  DEFINE_SIZE_UNION (2, sub_format);\n};\n\n\nstruct SubstLookup : Lookup\n{\n  inline const SubstLookupSubTable& get_subtable (unsigned int i) const\n  { return Lookup::get_subtable<SubstLookupSubTable> (i); }\n\n  inline static bool lookup_type_is_reverse (unsigned int lookup_type)\n  { return lookup_type == SubstLookupSubTable::ReverseChainSingle; }\n\n  inline bool is_reverse (void) const\n  {\n    unsigned int type = get_type ();\n    if (unlikely (type == SubstLookupSubTable::Extension))\n      return CastR<ExtensionSubst> (get_subtable(0)).is_reverse ();\n    return lookup_type_is_reverse (type);\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    return TRACE_RETURN (dispatch (c));\n  }\n\n  inline hb_closure_context_t::return_t closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    c->set_recurse_func (dispatch_recurse_func<hb_closure_context_t>);\n    return TRACE_RETURN (dispatch (c));\n  }\n\n  inline hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    c->set_recurse_func (dispatch_recurse_func<hb_collect_glyphs_context_t>);\n    return TRACE_RETURN (dispatch (c));\n  }\n\n  template <typename set_t>\n  inline void add_coverage (set_t *glyphs) const\n  {\n    hb_add_coverage_context_t<set_t> c (glyphs);\n    dispatch (&c);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c,\n\t\t\t   const hb_ot_layout_lookup_accelerator_t *accel) const\n  {\n    TRACE_WOULD_APPLY (this);\n    if (unlikely (!c->len))  return TRACE_RETURN (false);\n    if (!accel->may_have (c->glyphs[0]))  return TRACE_RETURN (false);\n      return TRACE_RETURN (dispatch (c));\n  }\n\n  static bool apply_recurse_func (hb_apply_context_t *c, unsigned int lookup_index);\n\n  inline SubstLookupSubTable& serialize_subtable (hb_serialize_context_t *c,\n\t\t\t\t\t\t  unsigned int i)\n  { return get_subtables<SubstLookupSubTable> ()[i].serialize (c, this); }\n\n  inline bool serialize_single (hb_serialize_context_t *c,\n\t\t\t\tuint32_t lookup_props,\n\t\t\t        Supplier<GlyphID> &glyphs,\n\t\t\t        Supplier<GlyphID> &substitutes,\n\t\t\t        unsigned int num_glyphs)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Single, lookup_props, 1))) return TRACE_RETURN (false);\n    return TRACE_RETURN (serialize_subtable (c, 0).u.single.serialize (c, glyphs, substitutes, num_glyphs));\n  }\n\n  inline bool serialize_multiple (hb_serialize_context_t *c,\n\t\t\t\t  uint32_t lookup_props,\n\t\t\t\t  Supplier<GlyphID> &glyphs,\n\t\t\t\t  Supplier<unsigned int> &substitute_len_list,\n\t\t\t\t  unsigned int num_glyphs,\n\t\t\t\t  Supplier<GlyphID> &substitute_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Multiple, lookup_props, 1))) return TRACE_RETURN (false);\n    return TRACE_RETURN (serialize_subtable (c, 0).u.multiple.serialize (c, glyphs, substitute_len_list, num_glyphs,\n\t\t\t\t\t\t\t\t\t substitute_glyphs_list));\n  }\n\n  inline bool serialize_alternate (hb_serialize_context_t *c,\n\t\t\t\t   uint32_t lookup_props,\n\t\t\t\t   Supplier<GlyphID> &glyphs,\n\t\t\t\t   Supplier<unsigned int> &alternate_len_list,\n\t\t\t\t   unsigned int num_glyphs,\n\t\t\t\t   Supplier<GlyphID> &alternate_glyphs_list)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Alternate, lookup_props, 1))) return TRACE_RETURN (false);\n    return TRACE_RETURN (serialize_subtable (c, 0).u.alternate.serialize (c, glyphs, alternate_len_list, num_glyphs,\n\t\t\t\t\t\t\t\t\t  alternate_glyphs_list));\n  }\n\n  inline bool serialize_ligature (hb_serialize_context_t *c,\n\t\t\t\t  uint32_t lookup_props,\n\t\t\t\t  Supplier<GlyphID> &first_glyphs,\n\t\t\t\t  Supplier<unsigned int> &ligature_per_first_glyph_count_list,\n\t\t\t\t  unsigned int num_first_glyphs,\n\t\t\t\t  Supplier<GlyphID> &ligatures_list,\n\t\t\t\t  Supplier<unsigned int> &component_count_list,\n\t\t\t\t  Supplier<GlyphID> &component_list /* Starting from second for each ligature */)\n  {\n    TRACE_SERIALIZE (this);\n    if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Ligature, lookup_props, 1))) return TRACE_RETURN (false);\n    return TRACE_RETURN (serialize_subtable (c, 0).u.ligature.serialize (c, first_glyphs, ligature_per_first_glyph_count_list, num_first_glyphs,\n\t\t\t\t\t\t\t\t\t ligatures_list, component_count_list, component_list));\n  }\n\n  template <typename context_t>\n  static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  { return Lookup::dispatch<SubstLookupSubTable> (c); }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (unlikely (!Lookup::sanitize (c))) return TRACE_RETURN (false);\n    if (unlikely (!dispatch (c))) return TRACE_RETURN (false);\n\n    if (unlikely (get_type () == SubstLookupSubTable::Extension))\n    {\n      /* The spec says all subtables of an Extension lookup should\n       * have the same type.  This is specially important if one has\n       * a reverse type! */\n      unsigned int type = get_subtable (0).u.extension.get_type ();\n      unsigned int count = get_subtable_count ();\n      for (unsigned int i = 1; i < count; i++)\n        if (get_subtable (i).u.extension.get_type () != type)\n\t  return TRACE_RETURN (false);\n    }\n    return TRACE_RETURN (true);\n  }\n};\n\ntypedef OffsetListOf<SubstLookup> SubstLookupList;\n\n/*\n * GSUB -- The Glyph Substitution Table\n */\n\nstruct GSUB : GSUBGPOS\n{\n  static const hb_tag_t tableTag\t= HB_OT_TAG_GSUB;\n\n  inline const SubstLookup& get_lookup (unsigned int i) const\n  { return CastR<SubstLookup> (GSUBGPOS::get_lookup (i)); }\n\n  static inline void substitute_start (hb_font_t *font, hb_buffer_t *buffer);\n  static inline void substitute_finish (hb_font_t *font, hb_buffer_t *buffer);\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (unlikely (!GSUBGPOS::sanitize (c))) return TRACE_RETURN (false);\n    const OffsetTo<SubstLookupList> &list = CastR<OffsetTo<SubstLookupList> > (lookupList);\n    return TRACE_RETURN (list.sanitize (c, this));\n  }\n  public:\n  DEFINE_SIZE_STATIC (10);\n};\n\n\nvoid\nGSUB::substitute_start (hb_font_t *font, hb_buffer_t *buffer)\n{\n  _hb_buffer_assert_gsubgpos_vars (buffer);\n\n  const GDEF &gdef = *hb_ot_layout_from_face (font->face)->gdef;\n  unsigned int count = buffer->len;\n  for (unsigned int i = 0; i < count; i++)\n  {\n    _hb_glyph_info_set_glyph_props (&buffer->info[i], gdef.get_glyph_props (buffer->info[i].codepoint));\n    _hb_glyph_info_clear_lig_props (&buffer->info[i]);\n    buffer->info[i].syllable() = 0;\n  }\n}\n\nvoid\nGSUB::substitute_finish (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer HB_UNUSED)\n{\n}\n\n\n/* Out-of-class implementation for methods recursing */\n\n/*static*/ inline bool ExtensionSubst::is_reverse (void) const\n{\n  unsigned int type = get_type ();\n  if (unlikely (type == SubstLookupSubTable::Extension))\n    return CastR<ExtensionSubst> (get_subtable<LookupSubTable>()).is_reverse ();\n  return SubstLookup::lookup_type_is_reverse (type);\n}\n\ntemplate <typename context_t>\n/*static*/ inline typename context_t::return_t SubstLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)\n{\n  const GSUB &gsub = *(hb_ot_layout_from_face (c->face)->gsub);\n  const SubstLookup &l = gsub.get_lookup (lookup_index);\n  return l.dispatch (c);\n}\n\n/*static*/ inline bool SubstLookup::apply_recurse_func (hb_apply_context_t *c, unsigned int lookup_index)\n{\n  const GSUB &gsub = *(hb_ot_layout_from_face (c->face)->gsub);\n  const SubstLookup &l = gsub.get_lookup (lookup_index);\n  unsigned int saved_lookup_props = c->lookup_props;\n  unsigned int saved_lookup_index = c->lookup_index;\n  c->set_lookup_index (lookup_index);\n  c->set_lookup_props (l.get_props ());\n  bool ret = l.dispatch (c);\n  c->set_lookup_index (saved_lookup_index);\n  c->set_lookup_props (saved_lookup_props);\n  return ret;\n}\n\n\n} /* namespace OT */\n\n\n#endif /* HB_OT_LAYOUT_GSUB_TABLE_HH */\n", "/*\n * Copyright \u00a9 2007,2008,2009,2010  Red Hat, Inc.\n * Copyright \u00a9 2010,2012  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Red Hat Author(s): Behdad Esfahbod\n * Google Author(s): Behdad Esfahbod\n */\n\n#ifndef HB_OT_LAYOUT_GSUBGPOS_PRIVATE_HH\n#define HB_OT_LAYOUT_GSUBGPOS_PRIVATE_HH\n\n#include \"hb-buffer-private.hh\"\n#include \"hb-ot-layout-gdef-table.hh\"\n#include \"hb-set-private.hh\"\n\n\nnamespace OT {\n\n\n#ifndef HB_DEBUG_CLOSURE\n#define HB_DEBUG_CLOSURE (HB_DEBUG+0)\n#endif\n\n#define TRACE_CLOSURE(this) \\\n\thb_auto_trace_t<HB_DEBUG_CLOSURE, hb_void_t> trace \\\n\t(&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n\t \"\");\n\nstruct hb_closure_context_t\n{\n  inline const char *get_name (void) { return \"CLOSURE\"; }\n  static const unsigned int max_debug_depth = HB_DEBUG_CLOSURE;\n  typedef hb_void_t return_t;\n  typedef return_t (*recurse_func_t) (hb_closure_context_t *c, unsigned int lookup_index);\n  template <typename T, typename F>\n  inline bool may_dispatch (const T *obj, const F *format) { return true; }\n  template <typename T>\n  inline return_t dispatch (const T &obj) { obj.closure (this); return HB_VOID; }\n  static return_t default_return_value (void) { return HB_VOID; }\n  bool stop_sublookup_iteration (return_t r HB_UNUSED) const { return false; }\n  return_t recurse (unsigned int lookup_index)\n  {\n    if (unlikely (nesting_level_left == 0 || !recurse_func))\n      return default_return_value ();\n\n    nesting_level_left--;\n    recurse_func (this, lookup_index);\n    nesting_level_left++;\n    return HB_VOID;\n  }\n\n  hb_face_t *face;\n  hb_set_t *glyphs;\n  recurse_func_t recurse_func;\n  unsigned int nesting_level_left;\n  unsigned int debug_depth;\n\n  hb_closure_context_t (hb_face_t *face_,\n\t\t\thb_set_t *glyphs_,\n\t\t        unsigned int nesting_level_left_ = MAX_NESTING_LEVEL) :\n\t\t\t  face (face_),\n\t\t\t  glyphs (glyphs_),\n\t\t\t  recurse_func (NULL),\n\t\t\t  nesting_level_left (nesting_level_left_),\n\t\t\t  debug_depth (0) {}\n\n  void set_recurse_func (recurse_func_t func) { recurse_func = func; }\n};\n\n\n\n#ifndef HB_DEBUG_WOULD_APPLY\n#define HB_DEBUG_WOULD_APPLY (HB_DEBUG+0)\n#endif\n\n#define TRACE_WOULD_APPLY(this) \\\n\thb_auto_trace_t<HB_DEBUG_WOULD_APPLY, bool> trace \\\n\t(&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n\t \"%d glyphs\", c->len);\n\nstruct hb_would_apply_context_t\n{\n  inline const char *get_name (void) { return \"WOULD_APPLY\"; }\n  static const unsigned int max_debug_depth = HB_DEBUG_WOULD_APPLY;\n  typedef bool return_t;\n  template <typename T, typename F>\n  inline bool may_dispatch (const T *obj, const F *format) { return true; }\n  template <typename T>\n  inline return_t dispatch (const T &obj) { return obj.would_apply (this); }\n  static return_t default_return_value (void) { return false; }\n  bool stop_sublookup_iteration (return_t r) const { return r; }\n\n  hb_face_t *face;\n  const hb_codepoint_t *glyphs;\n  unsigned int len;\n  bool zero_context;\n  unsigned int debug_depth;\n\n  hb_would_apply_context_t (hb_face_t *face_,\n\t\t\t    const hb_codepoint_t *glyphs_,\n\t\t\t    unsigned int len_,\n\t\t\t    bool zero_context_) :\n\t\t\t      face (face_),\n\t\t\t      glyphs (glyphs_),\n\t\t\t      len (len_),\n\t\t\t      zero_context (zero_context_),\n\t\t\t      debug_depth (0) {}\n};\n\n\n\n#ifndef HB_DEBUG_COLLECT_GLYPHS\n#define HB_DEBUG_COLLECT_GLYPHS (HB_DEBUG+0)\n#endif\n\n#define TRACE_COLLECT_GLYPHS(this) \\\n\thb_auto_trace_t<HB_DEBUG_COLLECT_GLYPHS, hb_void_t> trace \\\n\t(&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n\t \"\");\n\nstruct hb_collect_glyphs_context_t\n{\n  inline const char *get_name (void) { return \"COLLECT_GLYPHS\"; }\n  static const unsigned int max_debug_depth = HB_DEBUG_COLLECT_GLYPHS;\n  typedef hb_void_t return_t;\n  typedef return_t (*recurse_func_t) (hb_collect_glyphs_context_t *c, unsigned int lookup_index);\n  template <typename T, typename F>\n  inline bool may_dispatch (const T *obj, const F *format) { return true; }\n  template <typename T>\n  inline return_t dispatch (const T &obj) { obj.collect_glyphs (this); return HB_VOID; }\n  static return_t default_return_value (void) { return HB_VOID; }\n  bool stop_sublookup_iteration (return_t r HB_UNUSED) const { return false; }\n  return_t recurse (unsigned int lookup_index)\n  {\n    if (unlikely (nesting_level_left == 0 || !recurse_func))\n      return default_return_value ();\n\n    /* Note that GPOS sets recurse_func to NULL already, so it doesn't get\n     * past the previous check.  For GSUB, we only want to collect the output\n     * glyphs in the recursion.  If output is not requested, we can go home now.\n     *\n     * Note further, that the above is not exactly correct.  A recursed lookup\n     * is allowed to match input that is not matched in the context, but that's\n     * not how most fonts are built.  It's possible to relax that and recurse\n     * with all sets here if it proves to be an issue.\n     */\n\n    if (output == hb_set_get_empty ())\n      return HB_VOID;\n\n    /* Return if new lookup was recursed to before. */\n    if (recursed_lookups.has (lookup_index))\n      return HB_VOID;\n\n    hb_set_t *old_before = before;\n    hb_set_t *old_input  = input;\n    hb_set_t *old_after  = after;\n    before = input = after = hb_set_get_empty ();\n\n    nesting_level_left--;\n    recurse_func (this, lookup_index);\n    nesting_level_left++;\n\n    before = old_before;\n    input  = old_input;\n    after  = old_after;\n\n    recursed_lookups.add (lookup_index);\n\n    return HB_VOID;\n  }\n\n  hb_face_t *face;\n  hb_set_t *before;\n  hb_set_t *input;\n  hb_set_t *after;\n  hb_set_t *output;\n  recurse_func_t recurse_func;\n  hb_set_t recursed_lookups;\n  unsigned int nesting_level_left;\n  unsigned int debug_depth;\n\n  hb_collect_glyphs_context_t (hb_face_t *face_,\n\t\t\t       hb_set_t  *glyphs_before, /* OUT. May be NULL */\n\t\t\t       hb_set_t  *glyphs_input,  /* OUT. May be NULL */\n\t\t\t       hb_set_t  *glyphs_after,  /* OUT. May be NULL */\n\t\t\t       hb_set_t  *glyphs_output, /* OUT. May be NULL */\n\t\t\t       unsigned int nesting_level_left_ = MAX_NESTING_LEVEL) :\n\t\t\t      face (face_),\n\t\t\t      before (glyphs_before ? glyphs_before : hb_set_get_empty ()),\n\t\t\t      input  (glyphs_input  ? glyphs_input  : hb_set_get_empty ()),\n\t\t\t      after  (glyphs_after  ? glyphs_after  : hb_set_get_empty ()),\n\t\t\t      output (glyphs_output ? glyphs_output : hb_set_get_empty ()),\n\t\t\t      recurse_func (NULL),\n\t\t\t      recursed_lookups (),\n\t\t\t      nesting_level_left (nesting_level_left_),\n\t\t\t      debug_depth (0)\n  {\n    recursed_lookups.init ();\n  }\n  ~hb_collect_glyphs_context_t (void)\n  {\n    recursed_lookups.fini ();\n  }\n\n  void set_recurse_func (recurse_func_t func) { recurse_func = func; }\n};\n\n\n\n#ifndef HB_DEBUG_GET_COVERAGE\n#define HB_DEBUG_GET_COVERAGE (HB_DEBUG+0)\n#endif\n\ntemplate <typename set_t>\nstruct hb_add_coverage_context_t\n{\n  inline const char *get_name (void) { return \"GET_COVERAGE\"; }\n  static const unsigned int max_debug_depth = HB_DEBUG_GET_COVERAGE;\n  typedef const Coverage &return_t;\n  template <typename T, typename F>\n  inline bool may_dispatch (const T *obj, const F *format) { return true; }\n  template <typename T>\n  inline return_t dispatch (const T &obj) { return obj.get_coverage (); }\n  static return_t default_return_value (void) { return Null(Coverage); }\n  bool stop_sublookup_iteration (return_t r) const\n  {\n    r.add_coverage (set);\n    return false;\n  }\n\n  hb_add_coverage_context_t (set_t *set_) :\n\t\t\t    set (set_),\n\t\t\t    debug_depth (0) {}\n\n  set_t *set;\n  unsigned int debug_depth;\n};\n\n\n\n#ifndef HB_DEBUG_APPLY\n#define HB_DEBUG_APPLY (HB_DEBUG+0)\n#endif\n\n#define TRACE_APPLY(this) \\\n\thb_auto_trace_t<HB_DEBUG_APPLY, bool> trace \\\n\t(&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n\t \"idx %d gid %u lookup %d\", \\\n\t c->buffer->idx, c->buffer->cur().codepoint, (int) c->lookup_index);\n\nstruct hb_apply_context_t\n{\n  struct matcher_t\n  {\n    inline matcher_t (void) :\n\t     lookup_props (0),\n\t     ignore_zwnj (false),\n\t     ignore_zwj (false),\n\t     mask (-1),\n#define arg1(arg) (arg) /* Remove the macro to see why it's needed! */\n\t     syllable arg1(0),\n#undef arg1\n\t     match_func (NULL),\n\t     match_data (NULL) {};\n\n    typedef bool (*match_func_t) (hb_codepoint_t glyph_id, const USHORT &value, const void *data);\n\n    inline void set_ignore_zwnj (bool ignore_zwnj_) { ignore_zwnj = ignore_zwnj_; }\n    inline void set_ignore_zwj (bool ignore_zwj_) { ignore_zwj = ignore_zwj_; }\n    inline void set_lookup_props (unsigned int lookup_props_) { lookup_props = lookup_props_; }\n    inline void set_mask (hb_mask_t mask_) { mask = mask_; }\n    inline void set_syllable (uint8_t syllable_)  { syllable = syllable_; }\n    inline void set_match_func (match_func_t match_func_,\n\t\t\t\tconst void *match_data_)\n    { match_func = match_func_; match_data = match_data_; }\n\n    enum may_match_t {\n      MATCH_NO,\n      MATCH_YES,\n      MATCH_MAYBE\n    };\n\n    inline may_match_t may_match (const hb_glyph_info_t &info,\n\t\t\t\t  const USHORT          *glyph_data) const\n    {\n      if (!(info.mask & mask) ||\n\t  (syllable && syllable != info.syllable ()))\n\treturn MATCH_NO;\n\n      if (match_func)\n        return match_func (info.codepoint, *glyph_data, match_data) ? MATCH_YES : MATCH_NO;\n\n      return MATCH_MAYBE;\n    }\n\n    enum may_skip_t {\n      SKIP_NO,\n      SKIP_YES,\n      SKIP_MAYBE\n    };\n\n    inline may_skip_t\n    may_skip (const hb_apply_context_t *c,\n\t      const hb_glyph_info_t    &info) const\n    {\n      if (!c->check_glyph_property (&info, lookup_props))\n\treturn SKIP_YES;\n\n      if (unlikely (_hb_glyph_info_is_default_ignorable (&info) &&\n\t\t    (ignore_zwnj || !_hb_glyph_info_is_zwnj (&info)) &&\n\t\t    (ignore_zwj || !_hb_glyph_info_is_zwj (&info))))\n\treturn SKIP_MAYBE;\n\n      return SKIP_NO;\n    }\n\n    protected:\n    unsigned int lookup_props;\n    bool ignore_zwnj;\n    bool ignore_zwj;\n    hb_mask_t mask;\n    uint8_t syllable;\n    match_func_t match_func;\n    const void *match_data;\n  };\n\n  struct skipping_iterator_t\n  {\n    inline void init (hb_apply_context_t *c_, bool context_match = false)\n    {\n      c = c_;\n      match_glyph_data = NULL,\n      matcher.set_match_func (NULL, NULL);\n      matcher.set_lookup_props (c->lookup_props);\n      /* Ignore ZWNJ if we are matching GSUB context, or matching GPOS. */\n      matcher.set_ignore_zwnj (context_match || c->table_index == 1);\n      /* Ignore ZWJ if we are matching GSUB context, or matching GPOS, or if asked to. */\n      matcher.set_ignore_zwj (context_match || c->table_index == 1 || c->auto_zwj);\n      matcher.set_mask (context_match ? -1 : c->lookup_mask);\n    }\n    inline void set_lookup_props (unsigned int lookup_props)\n    {\n      matcher.set_lookup_props (lookup_props);\n    }\n    inline void set_match_func (matcher_t::match_func_t match_func,\n\t\t\t\tconst void *match_data,\n\t\t\t\tconst USHORT glyph_data[])\n    {\n      matcher.set_match_func (match_func, match_data);\n      match_glyph_data = glyph_data;\n    }\n\n    inline void reset (unsigned int start_index_,\n\t\t       unsigned int num_items_)\n    {\n      idx = start_index_;\n      num_items = num_items_;\n      end = c->buffer->len;\n      matcher.set_syllable (start_index_ == c->buffer->idx ? c->buffer->cur().syllable () : 0);\n    }\n\n    inline void reject (void) { num_items++; match_glyph_data--; }\n\n    inline bool next (void)\n    {\n      assert (num_items > 0);\n      while (idx + num_items < end)\n      {\n\tidx++;\n\tconst hb_glyph_info_t &info = c->buffer->info[idx];\n\n\tmatcher_t::may_skip_t skip = matcher.may_skip (c, info);\n\tif (unlikely (skip == matcher_t::SKIP_YES))\n\t  continue;\n\n\tmatcher_t::may_match_t match = matcher.may_match (info, match_glyph_data);\n\tif (match == matcher_t::MATCH_YES ||\n\t    (match == matcher_t::MATCH_MAYBE &&\n\t     skip == matcher_t::SKIP_NO))\n\t{\n\t  num_items--;\n\t  match_glyph_data++;\n\t  return true;\n\t}\n\n\tif (skip == matcher_t::SKIP_NO)\n\t  return false;\n      }\n      return false;\n    }\n    inline bool prev (void)\n    {\n      assert (num_items > 0);\n      while (idx >= num_items)\n      {\n\tidx--;\n\tconst hb_glyph_info_t &info = c->buffer->out_info[idx];\n\n\tmatcher_t::may_skip_t skip = matcher.may_skip (c, info);\n\tif (unlikely (skip == matcher_t::SKIP_YES))\n\t  continue;\n\n\tmatcher_t::may_match_t match = matcher.may_match (info, match_glyph_data);\n\tif (match == matcher_t::MATCH_YES ||\n\t    (match == matcher_t::MATCH_MAYBE &&\n\t     skip == matcher_t::SKIP_NO))\n\t{\n\t  num_items--;\n\t  match_glyph_data++;\n\t  return true;\n\t}\n\n\tif (skip == matcher_t::SKIP_NO)\n\t  return false;\n      }\n      return false;\n    }\n\n    unsigned int idx;\n    protected:\n    hb_apply_context_t *c;\n    matcher_t matcher;\n    const USHORT *match_glyph_data;\n\n    unsigned int num_items;\n    unsigned int end;\n  };\n\n\n  inline const char *get_name (void) { return \"APPLY\"; }\n  static const unsigned int max_debug_depth = HB_DEBUG_APPLY;\n  typedef bool return_t;\n  typedef return_t (*recurse_func_t) (hb_apply_context_t *c, unsigned int lookup_index);\n  template <typename T, typename F>\n  inline bool may_dispatch (const T *obj, const F *format) { return true; }\n  template <typename T>\n  inline return_t dispatch (const T &obj) { return obj.apply (this); }\n  static return_t default_return_value (void) { return false; }\n  bool stop_sublookup_iteration (return_t r) const { return r; }\n  return_t recurse (unsigned int lookup_index)\n  {\n    if (unlikely (nesting_level_left == 0 || !recurse_func))\n      return default_return_value ();\n\n    nesting_level_left--;\n    bool ret = recurse_func (this, lookup_index);\n    nesting_level_left++;\n    return ret;\n  }\n\n  unsigned int table_index; /* GSUB/GPOS */\n  hb_font_t *font;\n  hb_face_t *face;\n  hb_buffer_t *buffer;\n  hb_direction_t direction;\n  hb_mask_t lookup_mask;\n  bool auto_zwj;\n  recurse_func_t recurse_func;\n  unsigned int nesting_level_left;\n  unsigned int lookup_props;\n  const GDEF &gdef;\n  bool has_glyph_classes;\n  skipping_iterator_t iter_input, iter_context;\n  unsigned int lookup_index;\n  unsigned int debug_depth;\n\n\n  hb_apply_context_t (unsigned int table_index_,\n\t\t      hb_font_t *font_,\n\t\t      hb_buffer_t *buffer_) :\n\t\t\ttable_index (table_index_),\n\t\t\tfont (font_), face (font->face), buffer (buffer_),\n\t\t\tdirection (buffer_->props.direction),\n\t\t\tlookup_mask (1),\n\t\t\tauto_zwj (true),\n\t\t\trecurse_func (NULL),\n\t\t\tnesting_level_left (MAX_NESTING_LEVEL),\n\t\t\tlookup_props (0),\n\t\t\tgdef (*hb_ot_layout_from_face (face)->gdef),\n\t\t\thas_glyph_classes (gdef.has_glyph_classes ()),\n\t\t\titer_input (),\n\t\t\titer_context (),\n\t\t\tlookup_index ((unsigned int) -1),\n\t\t\tdebug_depth (0) {}\n\n  inline void set_lookup_mask (hb_mask_t mask) { lookup_mask = mask; }\n  inline void set_auto_zwj (bool auto_zwj_) { auto_zwj = auto_zwj_; }\n  inline void set_recurse_func (recurse_func_t func) { recurse_func = func; }\n  inline void set_lookup_index (unsigned int lookup_index_) { lookup_index = lookup_index_; }\n  inline void set_lookup_props (unsigned int lookup_props_)\n  {\n    lookup_props = lookup_props_;\n    iter_input.init (this, false);\n    iter_context.init (this, true);\n  }\n\n  inline bool\n  match_properties_mark (hb_codepoint_t  glyph,\n\t\t\t unsigned int    glyph_props,\n\t\t\t unsigned int    match_props) const\n  {\n    /* If using mark filtering sets, the high short of\n     * match_props has the set index.\n     */\n    if (match_props & LookupFlag::UseMarkFilteringSet)\n      return gdef.mark_set_covers (match_props >> 16, glyph);\n\n    /* The second byte of match_props has the meaning\n     * \"ignore marks of attachment type different than\n     * the attachment type specified.\"\n     */\n    if (match_props & LookupFlag::MarkAttachmentType)\n      return (match_props & LookupFlag::MarkAttachmentType) == (glyph_props & LookupFlag::MarkAttachmentType);\n\n    return true;\n  }\n\n  inline bool\n  check_glyph_property (const hb_glyph_info_t *info,\n\t\t\tunsigned int  match_props) const\n  {\n    hb_codepoint_t glyph = info->codepoint;\n    unsigned int glyph_props = _hb_glyph_info_get_glyph_props (info);\n\n    /* Not covered, if, for example, glyph class is ligature and\n     * match_props includes LookupFlags::IgnoreLigatures\n     */\n    if (glyph_props & match_props & LookupFlag::IgnoreFlags)\n      return false;\n\n    if (unlikely (glyph_props & HB_OT_LAYOUT_GLYPH_PROPS_MARK))\n      return match_properties_mark (glyph, glyph_props, match_props);\n\n    return true;\n  }\n\n  inline void _set_glyph_props (hb_codepoint_t glyph_index,\n\t\t\t  unsigned int class_guess = 0,\n\t\t\t  bool ligature = false,\n\t\t\t  bool component = false) const\n  {\n    unsigned int add_in = _hb_glyph_info_get_glyph_props (&buffer->cur()) &\n\t\t\t  HB_OT_LAYOUT_GLYPH_PROPS_PRESERVE;\n    add_in |= HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED;\n    if (ligature)\n    {\n      add_in |= HB_OT_LAYOUT_GLYPH_PROPS_LIGATED;\n      /* In the only place that the MULTIPLIED bit is used, Uniscribe\n       * seems to only care about the \"last\" transformation between\n       * Ligature and Multiple substitions.  Ie. if you ligate, expand,\n       * and ligate again, it forgives the multiplication and acts as\n       * if only ligation happened.  As such, clear MULTIPLIED bit.\n       */\n      add_in &= ~HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED;\n    }\n    if (component)\n      add_in |= HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED;\n    if (likely (has_glyph_classes))\n      _hb_glyph_info_set_glyph_props (&buffer->cur(), add_in | gdef.get_glyph_props (glyph_index));\n    else if (class_guess)\n      _hb_glyph_info_set_glyph_props (&buffer->cur(), add_in | class_guess);\n  }\n\n  inline void replace_glyph (hb_codepoint_t glyph_index) const\n  {\n    _set_glyph_props (glyph_index);\n    buffer->replace_glyph (glyph_index);\n  }\n  inline void replace_glyph_inplace (hb_codepoint_t glyph_index) const\n  {\n    _set_glyph_props (glyph_index);\n    buffer->cur().codepoint = glyph_index;\n  }\n  inline void replace_glyph_with_ligature (hb_codepoint_t glyph_index,\n\t\t\t\t\t   unsigned int class_guess) const\n  {\n    _set_glyph_props (glyph_index, class_guess, true);\n    buffer->replace_glyph (glyph_index);\n  }\n  inline void output_glyph_for_component (hb_codepoint_t glyph_index,\n\t\t\t\t\t  unsigned int class_guess) const\n  {\n    _set_glyph_props (glyph_index, class_guess, false, true);\n    buffer->output_glyph (glyph_index);\n  }\n};\n\n\n\ntypedef bool (*intersects_func_t) (hb_set_t *glyphs, const USHORT &value, const void *data);\ntypedef void (*collect_glyphs_func_t) (hb_set_t *glyphs, const USHORT &value, const void *data);\ntypedef bool (*match_func_t) (hb_codepoint_t glyph_id, const USHORT &value, const void *data);\n\nstruct ContextClosureFuncs\n{\n  intersects_func_t intersects;\n};\nstruct ContextCollectGlyphsFuncs\n{\n  collect_glyphs_func_t collect;\n};\nstruct ContextApplyFuncs\n{\n  match_func_t match;\n};\n\n\nstatic inline bool intersects_glyph (hb_set_t *glyphs, const USHORT &value, const void *data HB_UNUSED)\n{\n  return glyphs->has (value);\n}\nstatic inline bool intersects_class (hb_set_t *glyphs, const USHORT &value, const void *data)\n{\n  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);\n  return class_def.intersects_class (glyphs, value);\n}\nstatic inline bool intersects_coverage (hb_set_t *glyphs, const USHORT &value, const void *data)\n{\n  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n  return (data+coverage).intersects (glyphs);\n}\n\nstatic inline bool intersects_array (hb_closure_context_t *c,\n\t\t\t\t     unsigned int count,\n\t\t\t\t     const USHORT values[],\n\t\t\t\t     intersects_func_t intersects_func,\n\t\t\t\t     const void *intersects_data)\n{\n  for (unsigned int i = 0; i < count; i++)\n    if (likely (!intersects_func (c->glyphs, values[i], intersects_data)))\n      return false;\n  return true;\n}\n\n\nstatic inline void collect_glyph (hb_set_t *glyphs, const USHORT &value, const void *data HB_UNUSED)\n{\n  glyphs->add (value);\n}\nstatic inline void collect_class (hb_set_t *glyphs, const USHORT &value, const void *data)\n{\n  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);\n  class_def.add_class (glyphs, value);\n}\nstatic inline void collect_coverage (hb_set_t *glyphs, const USHORT &value, const void *data)\n{\n  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n  (data+coverage).add_coverage (glyphs);\n}\nstatic inline void collect_array (hb_collect_glyphs_context_t *c HB_UNUSED,\n\t\t\t\t  hb_set_t *glyphs,\n\t\t\t\t  unsigned int count,\n\t\t\t\t  const USHORT values[],\n\t\t\t\t  collect_glyphs_func_t collect_func,\n\t\t\t\t  const void *collect_data)\n{\n  for (unsigned int i = 0; i < count; i++)\n    collect_func (glyphs, values[i], collect_data);\n}\n\n\nstatic inline bool match_glyph (hb_codepoint_t glyph_id, const USHORT &value, const void *data HB_UNUSED)\n{\n  return glyph_id == value;\n}\nstatic inline bool match_class (hb_codepoint_t glyph_id, const USHORT &value, const void *data)\n{\n  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);\n  return class_def.get_class (glyph_id) == value;\n}\nstatic inline bool match_coverage (hb_codepoint_t glyph_id, const USHORT &value, const void *data)\n{\n  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n  return (data+coverage).get_coverage (glyph_id) != NOT_COVERED;\n}\n\nstatic inline bool would_match_input (hb_would_apply_context_t *c,\n\t\t\t\t      unsigned int count, /* Including the first glyph (not matched) */\n\t\t\t\t      const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t      match_func_t match_func,\n\t\t\t\t      const void *match_data)\n{\n  if (count != c->len)\n    return false;\n\n  for (unsigned int i = 1; i < count; i++)\n    if (likely (!match_func (c->glyphs[i], input[i - 1], match_data)))\n      return false;\n\n  return true;\n}\nstatic inline bool match_input (hb_apply_context_t *c,\n\t\t\t\tunsigned int count, /* Including the first glyph (not matched) */\n\t\t\t\tconst USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\tmatch_func_t match_func,\n\t\t\t\tconst void *match_data,\n\t\t\t\tunsigned int *end_offset,\n\t\t\t\tunsigned int match_positions[MAX_CONTEXT_LENGTH],\n\t\t\t\tbool *p_is_mark_ligature = NULL,\n\t\t\t\tunsigned int *p_total_component_count = NULL)\n{\n  TRACE_APPLY (NULL);\n\n  if (unlikely (count > MAX_CONTEXT_LENGTH)) return TRACE_RETURN (false);\n\n  hb_buffer_t *buffer = c->buffer;\n\n  hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n  skippy_iter.reset (buffer->idx, count - 1);\n  skippy_iter.set_match_func (match_func, match_data, input);\n\n  /*\n   * This is perhaps the trickiest part of OpenType...  Remarks:\n   *\n   * - If all components of the ligature were marks, we call this a mark ligature.\n   *\n   * - If there is no GDEF, and the ligature is NOT a mark ligature, we categorize\n   *   it as a ligature glyph.\n   *\n   * - Ligatures cannot be formed across glyphs attached to different components\n   *   of previous ligatures.  Eg. the sequence is LAM,SHADDA,LAM,FATHA,HEH, and\n   *   LAM,LAM,HEH form a ligature, leaving SHADDA,FATHA next to eachother.\n   *   However, it would be wrong to ligate that SHADDA,FATHA sequence.o\n   *   There is an exception to this: If a ligature tries ligating with marks that\n   *   belong to it itself, go ahead, assuming that the font designer knows what\n   *   they are doing (otherwise it can break Indic stuff when a matra wants to\n   *   ligate with a conjunct...)\n   */\n\n  bool is_mark_ligature = _hb_glyph_info_is_mark (&buffer->cur());\n\n  unsigned int total_component_count = 0;\n  total_component_count += _hb_glyph_info_get_lig_num_comps (&buffer->cur());\n\n  unsigned int first_lig_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n  unsigned int first_lig_comp = _hb_glyph_info_get_lig_comp (&buffer->cur());\n\n  match_positions[0] = buffer->idx;\n  for (unsigned int i = 1; i < count; i++)\n  {\n    if (!skippy_iter.next ()) return TRACE_RETURN (false);\n\n    match_positions[i] = skippy_iter.idx;\n\n    unsigned int this_lig_id = _hb_glyph_info_get_lig_id (&buffer->info[skippy_iter.idx]);\n    unsigned int this_lig_comp = _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx]);\n\n    if (first_lig_id && first_lig_comp) {\n      /* If first component was attached to a previous ligature component,\n       * all subsequent components should be attached to the same ligature\n       * component, otherwise we shouldn't ligate them. */\n      if (first_lig_id != this_lig_id || first_lig_comp != this_lig_comp)\n\treturn TRACE_RETURN (false);\n    } else {\n      /* If first component was NOT attached to a previous ligature component,\n       * all subsequent components should also NOT be attached to any ligature\n       * component, unless they are attached to the first component itself! */\n      if (this_lig_id && this_lig_comp && (this_lig_id != first_lig_id))\n\treturn TRACE_RETURN (false);\n    }\n\n    is_mark_ligature = is_mark_ligature && _hb_glyph_info_is_mark (&buffer->info[skippy_iter.idx]);\n    total_component_count += _hb_glyph_info_get_lig_num_comps (&buffer->info[skippy_iter.idx]);\n  }\n\n  *end_offset = skippy_iter.idx - buffer->idx + 1;\n\n  if (p_is_mark_ligature)\n    *p_is_mark_ligature = is_mark_ligature;\n\n  if (p_total_component_count)\n    *p_total_component_count = total_component_count;\n\n  return TRACE_RETURN (true);\n}\nstatic inline void ligate_input (hb_apply_context_t *c,\n\t\t\t\t unsigned int count, /* Including the first glyph */\n\t\t\t\t unsigned int match_positions[MAX_CONTEXT_LENGTH], /* Including the first glyph */\n\t\t\t\t unsigned int match_length,\n\t\t\t\t hb_codepoint_t lig_glyph,\n\t\t\t\t bool is_mark_ligature,\n\t\t\t\t unsigned int total_component_count)\n{\n  TRACE_APPLY (NULL);\n\n  hb_buffer_t *buffer = c->buffer;\n\n  buffer->merge_clusters (buffer->idx, buffer->idx + match_length);\n\n  /*\n   * - If it *is* a mark ligature, we don't allocate a new ligature id, and leave\n   *   the ligature to keep its old ligature id.  This will allow it to attach to\n   *   a base ligature in GPOS.  Eg. if the sequence is: LAM,LAM,SHADDA,FATHA,HEH,\n   *   and LAM,LAM,HEH for a ligature, they will leave SHADDA and FATHA wit a\n   *   ligature id and component value of 2.  Then if SHADDA,FATHA form a ligature\n   *   later, we don't want them to lose their ligature id/component, otherwise\n   *   GPOS will fail to correctly position the mark ligature on top of the\n   *   LAM,LAM,HEH ligature.  See:\n   *     https://bugzilla.gnome.org/show_bug.cgi?id=676343\n   *\n   * - If a ligature is formed of components that some of which are also ligatures\n   *   themselves, and those ligature components had marks attached to *their*\n   *   components, we have to attach the marks to the new ligature component\n   *   positions!  Now *that*'s tricky!  And these marks may be following the\n   *   last component of the whole sequence, so we should loop forward looking\n   *   for them and update them.\n   *\n   *   Eg. the sequence is LAM,LAM,SHADDA,FATHA,HEH, and the font first forms a\n   *   'calt' ligature of LAM,HEH, leaving the SHADDA and FATHA with a ligature\n   *   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature\n   *   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to\n   *   the new ligature with a component value of 2.\n   *\n   *   This in fact happened to a font...  See:\n   *   https://bugzilla.gnome.org/show_bug.cgi?id=437633\n   */\n\n  unsigned int klass = is_mark_ligature ? 0 : HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE;\n  unsigned int lig_id = is_mark_ligature ? 0 : _hb_allocate_lig_id (buffer);\n  unsigned int last_lig_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n  unsigned int last_num_components = _hb_glyph_info_get_lig_num_comps (&buffer->cur());\n  unsigned int components_so_far = last_num_components;\n\n  if (!is_mark_ligature)\n  {\n    _hb_glyph_info_set_lig_props_for_ligature (&buffer->cur(), lig_id, total_component_count);\n    if (_hb_glyph_info_get_general_category (&buffer->cur()) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)\n    {\n      _hb_glyph_info_set_general_category (&buffer->cur(), HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER);\n      _hb_glyph_info_set_modified_combining_class (&buffer->cur(), 0);\n    }\n  }\n  c->replace_glyph_with_ligature (lig_glyph, klass);\n\n  for (unsigned int i = 1; i < count; i++)\n  {\n    while (buffer->idx < match_positions[i])\n    {\n      if (!is_mark_ligature) {\n\tunsigned int new_lig_comp = components_so_far - last_num_components +\n\t\t\t\t    MIN (MAX (_hb_glyph_info_get_lig_comp (&buffer->cur()), 1u), last_num_components);\n\t_hb_glyph_info_set_lig_props_for_mark (&buffer->cur(), lig_id, new_lig_comp);\n      }\n      buffer->next_glyph ();\n    }\n\n    last_lig_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n    last_num_components = _hb_glyph_info_get_lig_num_comps (&buffer->cur());\n    components_so_far += last_num_components;\n\n    /* Skip the base glyph */\n    buffer->idx++;\n  }\n\n  if (!is_mark_ligature && last_lig_id) {\n    /* Re-adjust components for any marks following. */\n    for (unsigned int i = buffer->idx; i < buffer->len; i++) {\n      if (last_lig_id == _hb_glyph_info_get_lig_id (&buffer->info[i])) {\n\tunsigned int new_lig_comp = components_so_far - last_num_components +\n\t\t\t\t    MIN (MAX (_hb_glyph_info_get_lig_comp (&buffer->info[i]), 1u), last_num_components);\n\t_hb_glyph_info_set_lig_props_for_mark (&buffer->info[i], lig_id, new_lig_comp);\n      } else\n\tbreak;\n    }\n  }\n  TRACE_RETURN (true);\n}\n\nstatic inline bool match_backtrack (hb_apply_context_t *c,\n\t\t\t\t    unsigned int count,\n\t\t\t\t    const USHORT backtrack[],\n\t\t\t\t    match_func_t match_func,\n\t\t\t\t    const void *match_data)\n{\n  TRACE_APPLY (NULL);\n\n  hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_context;\n  skippy_iter.reset (c->buffer->backtrack_len (), count);\n  skippy_iter.set_match_func (match_func, match_data, backtrack);\n\n  for (unsigned int i = 0; i < count; i++)\n    if (!skippy_iter.prev ())\n      return TRACE_RETURN (false);\n\n  return TRACE_RETURN (true);\n}\n\nstatic inline bool match_lookahead (hb_apply_context_t *c,\n\t\t\t\t    unsigned int count,\n\t\t\t\t    const USHORT lookahead[],\n\t\t\t\t    match_func_t match_func,\n\t\t\t\t    const void *match_data,\n\t\t\t\t    unsigned int offset)\n{\n  TRACE_APPLY (NULL);\n\n  hb_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_context;\n  skippy_iter.reset (c->buffer->idx + offset - 1, count);\n  skippy_iter.set_match_func (match_func, match_data, lookahead);\n\n  for (unsigned int i = 0; i < count; i++)\n    if (!skippy_iter.next ())\n      return TRACE_RETURN (false);\n\n  return TRACE_RETURN (true);\n}\n\n\n\nstruct LookupRecord\n{\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this));\n  }\n\n  USHORT\tsequenceIndex;\t\t/* Index into current glyph\n\t\t\t\t\t * sequence--first glyph = 0 */\n  USHORT\tlookupListIndex;\t/* Lookup to apply to that\n\t\t\t\t\t * position--zero--based */\n  public:\n  DEFINE_SIZE_STATIC (4);\n};\n\n\ntemplate <typename context_t>\nstatic inline void recurse_lookups (context_t *c,\n\t\t\t\t    unsigned int lookupCount,\n\t\t\t\t    const LookupRecord lookupRecord[] /* Array of LookupRecords--in design order */)\n{\n  for (unsigned int i = 0; i < lookupCount; i++)\n    c->recurse (lookupRecord[i].lookupListIndex);\n}\n\nstatic inline bool apply_lookup (hb_apply_context_t *c,\n\t\t\t\t unsigned int count, /* Including the first glyph */\n\t\t\t\t unsigned int match_positions[MAX_CONTEXT_LENGTH], /* Including the first glyph */\n\t\t\t\t unsigned int lookupCount,\n\t\t\t\t const LookupRecord lookupRecord[], /* Array of LookupRecords--in design order */\n\t\t\t\t unsigned int match_length)\n{\n  TRACE_APPLY (NULL);\n\n  hb_buffer_t *buffer = c->buffer;\n  unsigned int end;\n\n  /* All positions are distance from beginning of *output* buffer.\n   * Adjust. */\n  {\n    unsigned int bl = buffer->backtrack_len ();\n    end = bl + match_length;\n\n    int delta = bl - buffer->idx;\n    /* Convert positions to new indexing. */\n    for (unsigned int j = 0; j < count; j++)\n      match_positions[j] += delta;\n  }\n\n  for (unsigned int i = 0; i < lookupCount; i++)\n  {\n    unsigned int idx = lookupRecord[i].sequenceIndex;\n    if (idx >= count)\n      continue;\n\n    buffer->move_to (match_positions[idx]);\n\n    unsigned int orig_len = buffer->backtrack_len () + buffer->lookahead_len ();\n    if (!c->recurse (lookupRecord[i].lookupListIndex))\n      continue;\n\n    unsigned int new_len = buffer->backtrack_len () + buffer->lookahead_len ();\n    int delta = new_len - orig_len;\n\n    if (!delta)\n        continue;\n\n    /* Recursed lookup changed buffer len.  Adjust. */\n\n    /* end can't go back past the current match position.\n     * Note: this is only true because we do NOT allow MultipleSubst\n     * with zero sequence len. */\n    end = MAX ((int) match_positions[idx] + 1, int (end) + delta);\n\n    unsigned int next = idx + 1; /* next now is the position after the recursed lookup. */\n\n    if (delta > 0)\n    {\n      if (unlikely (delta + count > MAX_CONTEXT_LENGTH))\n\tbreak;\n    }\n    else\n    {\n      /* NOTE: delta is negative. */\n      delta = MAX (delta, (int) next - (int) count);\n      next -= delta;\n    }\n\n    /* Shift! */\n    memmove (match_positions + next + delta, match_positions + next,\n\t     (count - next) * sizeof (match_positions[0]));\n    next += delta;\n    count += delta;\n\n    /* Fill in new entries. */\n    for (unsigned int j = idx + 1; j < next; j++)\n      match_positions[j] = match_positions[j - 1] + 1;\n\n    /* And fixup the rest. */\n    for (; next < count; next++)\n      match_positions[next] += delta;\n  }\n\n  buffer->move_to (end);\n\n  return TRACE_RETURN (true);\n}\n\n\n\n/* Contextual lookups */\n\nstruct ContextClosureLookupContext\n{\n  ContextClosureFuncs funcs;\n  const void *intersects_data;\n};\n\nstruct ContextCollectGlyphsLookupContext\n{\n  ContextCollectGlyphsFuncs funcs;\n  const void *collect_data;\n};\n\nstruct ContextApplyLookupContext\n{\n  ContextApplyFuncs funcs;\n  const void *match_data;\n};\n\nstatic inline void context_closure_lookup (hb_closure_context_t *c,\n\t\t\t\t\t   unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t   const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t   unsigned int lookupCount,\n\t\t\t\t\t   const LookupRecord lookupRecord[],\n\t\t\t\t\t   ContextClosureLookupContext &lookup_context)\n{\n  if (intersects_array (c,\n\t\t\tinputCount ? inputCount - 1 : 0, input,\n\t\t\tlookup_context.funcs.intersects, lookup_context.intersects_data))\n    recurse_lookups (c,\n\t\t     lookupCount, lookupRecord);\n}\n\nstatic inline void context_collect_glyphs_lookup (hb_collect_glyphs_context_t *c,\n\t\t\t\t\t\t  unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t\t  const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t\t  unsigned int lookupCount,\n\t\t\t\t\t\t  const LookupRecord lookupRecord[],\n\t\t\t\t\t\t  ContextCollectGlyphsLookupContext &lookup_context)\n{\n  collect_array (c, c->input,\n\t\t inputCount ? inputCount - 1 : 0, input,\n\t\t lookup_context.funcs.collect, lookup_context.collect_data);\n  recurse_lookups (c,\n\t\t   lookupCount, lookupRecord);\n}\n\nstatic inline bool context_would_apply_lookup (hb_would_apply_context_t *c,\n\t\t\t\t\t       unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t       const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t       unsigned int lookupCount HB_UNUSED,\n\t\t\t\t\t       const LookupRecord lookupRecord[] HB_UNUSED,\n\t\t\t\t\t       ContextApplyLookupContext &lookup_context)\n{\n  return would_match_input (c,\n\t\t\t    inputCount, input,\n\t\t\t    lookup_context.funcs.match, lookup_context.match_data);\n}\nstatic inline bool context_apply_lookup (hb_apply_context_t *c,\n\t\t\t\t\t unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t unsigned int lookupCount,\n\t\t\t\t\t const LookupRecord lookupRecord[],\n\t\t\t\t\t ContextApplyLookupContext &lookup_context)\n{\n  unsigned int match_length = 0;\n  unsigned int match_positions[MAX_CONTEXT_LENGTH];\n  return match_input (c,\n\t\t      inputCount, input,\n\t\t      lookup_context.funcs.match, lookup_context.match_data,\n\t\t      &match_length, match_positions)\n      && apply_lookup (c,\n\t\t       inputCount, match_positions,\n\t\t       lookupCount, lookupRecord,\n\t\t       match_length);\n}\n\nstruct Rule\n{\n  inline void closure (hb_closure_context_t *c, ContextClosureLookupContext &lookup_context) const\n  {\n    TRACE_CLOSURE (this);\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (inputZ, inputZ[0].static_size * (inputCount ? inputCount - 1 : 0));\n    context_closure_lookup (c,\n\t\t\t    inputCount, inputZ,\n\t\t\t    lookupCount, lookupRecord,\n\t\t\t    lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c, ContextCollectGlyphsLookupContext &lookup_context) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (inputZ, inputZ[0].static_size * (inputCount ? inputCount - 1 : 0));\n    context_collect_glyphs_lookup (c,\n\t\t\t\t   inputCount, inputZ,\n\t\t\t\t   lookupCount, lookupRecord,\n\t\t\t\t   lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c, ContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_WOULD_APPLY (this);\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (inputZ, inputZ[0].static_size * (inputCount ? inputCount - 1 : 0));\n    return TRACE_RETURN (context_would_apply_lookup (c, inputCount, inputZ, lookupCount, lookupRecord, lookup_context));\n  }\n\n  inline bool apply (hb_apply_context_t *c, ContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_APPLY (this);\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (inputZ, inputZ[0].static_size * (inputCount ? inputCount - 1 : 0));\n    return TRACE_RETURN (context_apply_lookup (c, inputCount, inputZ, lookupCount, lookupRecord, lookup_context));\n  }\n\n  public:\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return inputCount.sanitize (c)\n\t&& lookupCount.sanitize (c)\n\t&& c->check_range (inputZ,\n\t\t\t   inputZ[0].static_size * inputCount\n\t\t\t   + lookupRecordX[0].static_size * lookupCount);\n  }\n\n  protected:\n  USHORT\tinputCount;\t\t/* Total number of glyphs in input\n\t\t\t\t\t * glyph sequence--includes the first\n\t\t\t\t\t * glyph */\n  USHORT\tlookupCount;\t\t/* Number of LookupRecords */\n  USHORT\tinputZ[VAR];\t\t/* Array of match inputs--start with\n\t\t\t\t\t * second glyph */\n  LookupRecord\tlookupRecordX[VAR];\t/* Array of LookupRecords--in\n\t\t\t\t\t * design order */\n  public:\n  DEFINE_SIZE_ARRAY2 (4, inputZ, lookupRecordX);\n};\n\nstruct RuleSet\n{\n  inline void closure (hb_closure_context_t *c, ContextClosureLookupContext &lookup_context) const\n  {\n    TRACE_CLOSURE (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      (this+rule[i]).closure (c, lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c, ContextCollectGlyphsLookupContext &lookup_context) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      (this+rule[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c, ContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_WOULD_APPLY (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n    {\n      if ((this+rule[i]).would_apply (c, lookup_context))\n        return TRACE_RETURN (true);\n    }\n    return TRACE_RETURN (false);\n  }\n\n  inline bool apply (hb_apply_context_t *c, ContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_APPLY (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n    {\n      if ((this+rule[i]).apply (c, lookup_context))\n        return TRACE_RETURN (true);\n    }\n    return TRACE_RETURN (false);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (rule.sanitize (c, this));\n  }\n\n  protected:\n  OffsetArrayOf<Rule>\n\t\trule;\t\t\t/* Array of Rule tables\n\t\t\t\t\t * ordered by preference */\n  public:\n  DEFINE_SIZE_ARRAY (2, rule);\n};\n\n\nstruct ContextFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n\n    const Coverage &cov = (this+coverage);\n\n    struct ContextClosureLookupContext lookup_context = {\n      {intersects_glyph},\n      NULL\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (cov.intersects_coverage (c->glyphs, i)) {\n\tconst RuleSet &rule_set = this+ruleSet[i];\n\trule_set.closure (c, lookup_context);\n      }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n\n    struct ContextCollectGlyphsLookupContext lookup_context = {\n      {collect_glyph},\n      NULL\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const RuleSet &rule_set = this+ruleSet[(this+coverage).get_coverage (c->glyphs[0])];\n    struct ContextApplyLookupContext lookup_context = {\n      {match_glyph},\n      NULL\n    };\n    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED))\n      return TRACE_RETURN (false);\n\n    const RuleSet &rule_set = this+ruleSet[index];\n    struct ContextApplyLookupContext lookup_context = {\n      {match_glyph},\n      NULL\n    };\n    return TRACE_RETURN (rule_set.apply (c, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && ruleSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of table */\n  OffsetArrayOf<RuleSet>\n\t\truleSet;\t\t/* Array of RuleSet tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, ruleSet);\n};\n\n\nstruct ContextFormat2\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    if (!(this+coverage).intersects (c->glyphs))\n      return;\n\n    const ClassDef &class_def = this+classDef;\n\n    struct ContextClosureLookupContext lookup_context = {\n      {intersects_class},\n      &class_def\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (class_def.intersects_class (c->glyphs, i)) {\n\tconst RuleSet &rule_set = this+ruleSet[i];\n\trule_set.closure (c, lookup_context);\n      }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n\n    const ClassDef &class_def = this+classDef;\n    struct ContextCollectGlyphsLookupContext lookup_context = {\n      {collect_class},\n      &class_def\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const ClassDef &class_def = this+classDef;\n    unsigned int index = class_def.get_class (c->glyphs[0]);\n    const RuleSet &rule_set = this+ruleSet[index];\n    struct ContextApplyLookupContext lookup_context = {\n      {match_class},\n      &class_def\n    };\n    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const ClassDef &class_def = this+classDef;\n    index = class_def.get_class (c->buffer->cur().codepoint);\n    const RuleSet &rule_set = this+ruleSet[index];\n    struct ContextApplyLookupContext lookup_context = {\n      {match_class},\n      &class_def\n    };\n    return TRACE_RETURN (rule_set.apply (c, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && classDef.sanitize (c, this) && ruleSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of table */\n  OffsetTo<ClassDef>\n\t\tclassDef;\t\t/* Offset to glyph ClassDef table--from\n\t\t\t\t\t * beginning of table */\n  OffsetArrayOf<RuleSet>\n\t\truleSet;\t\t/* Array of RuleSet tables\n\t\t\t\t\t * ordered by class */\n  public:\n  DEFINE_SIZE_ARRAY (8, ruleSet);\n};\n\n\nstruct ContextFormat3\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    if (!(this+coverageZ[0]).intersects (c->glyphs))\n      return;\n\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverageZ, coverageZ[0].static_size * glyphCount);\n    struct ContextClosureLookupContext lookup_context = {\n      {intersects_coverage},\n      this\n    };\n    context_closure_lookup (c,\n\t\t\t    glyphCount, (const USHORT *) (coverageZ + 1),\n\t\t\t    lookupCount, lookupRecord,\n\t\t\t    lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverageZ[0]).add_coverage (c->input);\n\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverageZ, coverageZ[0].static_size * glyphCount);\n    struct ContextCollectGlyphsLookupContext lookup_context = {\n      {collect_coverage},\n      this\n    };\n\n    context_collect_glyphs_lookup (c,\n\t\t\t\t   glyphCount, (const USHORT *) (coverageZ + 1),\n\t\t\t\t   lookupCount, lookupRecord,\n\t\t\t\t   lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverageZ, coverageZ[0].static_size * glyphCount);\n    struct ContextApplyLookupContext lookup_context = {\n      {match_coverage},\n      this\n    };\n    return TRACE_RETURN (context_would_apply_lookup (c, glyphCount, (const USHORT *) (coverageZ + 1), lookupCount, lookupRecord, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverageZ[0];\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int index = (this+coverageZ[0]).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverageZ, coverageZ[0].static_size * glyphCount);\n    struct ContextApplyLookupContext lookup_context = {\n      {match_coverage},\n      this\n    };\n    return TRACE_RETURN (context_apply_lookup (c, glyphCount, (const USHORT *) (coverageZ + 1), lookupCount, lookupRecord, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!c->check_struct (this)) return TRACE_RETURN (false);\n    unsigned int count = glyphCount;\n    if (!count) return TRACE_RETURN (false); /* We want to access coverageZ[0] freely. */\n    if (!c->check_array (coverageZ, coverageZ[0].static_size, count)) return TRACE_RETURN (false);\n    for (unsigned int i = 0; i < count; i++)\n      if (!coverageZ[i].sanitize (c, this)) return TRACE_RETURN (false);\n    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverageZ, coverageZ[0].static_size * count);\n    return TRACE_RETURN (c->check_array (lookupRecord, lookupRecord[0].static_size, lookupCount));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 3 */\n  USHORT\tglyphCount;\t\t/* Number of glyphs in the input glyph\n\t\t\t\t\t * sequence */\n  USHORT\tlookupCount;\t\t/* Number of LookupRecords */\n  OffsetTo<Coverage>\n\t\tcoverageZ[VAR];\t\t/* Array of offsets to Coverage\n\t\t\t\t\t * table in glyph sequence order */\n  LookupRecord\tlookupRecordX[VAR];\t/* Array of LookupRecords--in\n\t\t\t\t\t * design order */\n  public:\n  DEFINE_SIZE_ARRAY2 (6, coverageZ, lookupRecordX);\n};\n\nstruct Context\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    case 2: return TRACE_RETURN (c->dispatch (u.format2));\n    case 3: return TRACE_RETURN (c->dispatch (u.format3));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  ContextFormat1\tformat1;\n  ContextFormat2\tformat2;\n  ContextFormat3\tformat3;\n  } u;\n};\n\n\n/* Chaining Contextual lookups */\n\nstruct ChainContextClosureLookupContext\n{\n  ContextClosureFuncs funcs;\n  const void *intersects_data[3];\n};\n\nstruct ChainContextCollectGlyphsLookupContext\n{\n  ContextCollectGlyphsFuncs funcs;\n  const void *collect_data[3];\n};\n\nstruct ChainContextApplyLookupContext\n{\n  ContextApplyFuncs funcs;\n  const void *match_data[3];\n};\n\nstatic inline void chain_context_closure_lookup (hb_closure_context_t *c,\n\t\t\t\t\t\t unsigned int backtrackCount,\n\t\t\t\t\t\t const USHORT backtrack[],\n\t\t\t\t\t\t unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t\t const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t\t unsigned int lookaheadCount,\n\t\t\t\t\t\t const USHORT lookahead[],\n\t\t\t\t\t\t unsigned int lookupCount,\n\t\t\t\t\t\t const LookupRecord lookupRecord[],\n\t\t\t\t\t\t ChainContextClosureLookupContext &lookup_context)\n{\n  if (intersects_array (c,\n\t\t\tbacktrackCount, backtrack,\n\t\t\tlookup_context.funcs.intersects, lookup_context.intersects_data[0])\n   && intersects_array (c,\n\t\t\tinputCount ? inputCount - 1 : 0, input,\n\t\t\tlookup_context.funcs.intersects, lookup_context.intersects_data[1])\n   && intersects_array (c,\n\t\t       lookaheadCount, lookahead,\n\t\t       lookup_context.funcs.intersects, lookup_context.intersects_data[2]))\n    recurse_lookups (c,\n\t\t     lookupCount, lookupRecord);\n}\n\nstatic inline void chain_context_collect_glyphs_lookup (hb_collect_glyphs_context_t *c,\n\t\t\t\t\t\t        unsigned int backtrackCount,\n\t\t\t\t\t\t        const USHORT backtrack[],\n\t\t\t\t\t\t        unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t\t        const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t\t        unsigned int lookaheadCount,\n\t\t\t\t\t\t        const USHORT lookahead[],\n\t\t\t\t\t\t        unsigned int lookupCount,\n\t\t\t\t\t\t        const LookupRecord lookupRecord[],\n\t\t\t\t\t\t        ChainContextCollectGlyphsLookupContext &lookup_context)\n{\n  collect_array (c, c->before,\n\t\t backtrackCount, backtrack,\n\t\t lookup_context.funcs.collect, lookup_context.collect_data[0]);\n  collect_array (c, c->input,\n\t\t inputCount ? inputCount - 1 : 0, input,\n\t\t lookup_context.funcs.collect, lookup_context.collect_data[1]);\n  collect_array (c, c->after,\n\t\t lookaheadCount, lookahead,\n\t\t lookup_context.funcs.collect, lookup_context.collect_data[2]);\n  recurse_lookups (c,\n\t\t   lookupCount, lookupRecord);\n}\n\nstatic inline bool chain_context_would_apply_lookup (hb_would_apply_context_t *c,\n\t\t\t\t\t\t     unsigned int backtrackCount,\n\t\t\t\t\t\t     const USHORT backtrack[] HB_UNUSED,\n\t\t\t\t\t\t     unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t\t     const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t\t     unsigned int lookaheadCount,\n\t\t\t\t\t\t     const USHORT lookahead[] HB_UNUSED,\n\t\t\t\t\t\t     unsigned int lookupCount HB_UNUSED,\n\t\t\t\t\t\t     const LookupRecord lookupRecord[] HB_UNUSED,\n\t\t\t\t\t\t     ChainContextApplyLookupContext &lookup_context)\n{\n  return (c->zero_context ? !backtrackCount && !lookaheadCount : true)\n      && would_match_input (c,\n\t\t\t    inputCount, input,\n\t\t\t    lookup_context.funcs.match, lookup_context.match_data[1]);\n}\n\nstatic inline bool chain_context_apply_lookup (hb_apply_context_t *c,\n\t\t\t\t\t       unsigned int backtrackCount,\n\t\t\t\t\t       const USHORT backtrack[],\n\t\t\t\t\t       unsigned int inputCount, /* Including the first glyph (not matched) */\n\t\t\t\t\t       const USHORT input[], /* Array of input values--start with second glyph */\n\t\t\t\t\t       unsigned int lookaheadCount,\n\t\t\t\t\t       const USHORT lookahead[],\n\t\t\t\t\t       unsigned int lookupCount,\n\t\t\t\t\t       const LookupRecord lookupRecord[],\n\t\t\t\t\t       ChainContextApplyLookupContext &lookup_context)\n{\n  unsigned int match_length = 0;\n  unsigned int match_positions[MAX_CONTEXT_LENGTH];\n  return match_input (c,\n\t\t      inputCount, input,\n\t\t      lookup_context.funcs.match, lookup_context.match_data[1],\n\t\t      &match_length, match_positions)\n      && match_backtrack (c,\n\t\t\t  backtrackCount, backtrack,\n\t\t\t  lookup_context.funcs.match, lookup_context.match_data[0])\n      && match_lookahead (c,\n\t\t\t  lookaheadCount, lookahead,\n\t\t\t  lookup_context.funcs.match, lookup_context.match_data[2],\n\t\t\t  match_length)\n      && apply_lookup (c,\n\t\t       inputCount, match_positions,\n\t\t       lookupCount, lookupRecord,\n\t\t       match_length);\n}\n\nstruct ChainRule\n{\n  inline void closure (hb_closure_context_t *c, ChainContextClosureLookupContext &lookup_context) const\n  {\n    TRACE_CLOSURE (this);\n    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);\n    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    chain_context_closure_lookup (c,\n\t\t\t\t  backtrack.len, backtrack.array,\n\t\t\t\t  input.len, input.array,\n\t\t\t\t  lookahead.len, lookahead.array,\n\t\t\t\t  lookup.len, lookup.array,\n\t\t\t\t  lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c, ChainContextCollectGlyphsLookupContext &lookup_context) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);\n    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    chain_context_collect_glyphs_lookup (c,\n\t\t\t\t\t backtrack.len, backtrack.array,\n\t\t\t\t\t input.len, input.array,\n\t\t\t\t\t lookahead.len, lookahead.array,\n\t\t\t\t\t lookup.len, lookup.array,\n\t\t\t\t\t lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_WOULD_APPLY (this);\n    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);\n    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    return TRACE_RETURN (chain_context_would_apply_lookup (c,\n\t\t\t\t\t\t\t   backtrack.len, backtrack.array,\n\t\t\t\t\t\t\t   input.len, input.array,\n\t\t\t\t\t\t\t   lookahead.len, lookahead.array, lookup.len,\n\t\t\t\t\t\t\t   lookup.array, lookup_context));\n  }\n\n  inline bool apply (hb_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_APPLY (this);\n    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);\n    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    return TRACE_RETURN (chain_context_apply_lookup (c,\n\t\t\t\t\t\t     backtrack.len, backtrack.array,\n\t\t\t\t\t\t     input.len, input.array,\n\t\t\t\t\t\t     lookahead.len, lookahead.array, lookup.len,\n\t\t\t\t\t\t     lookup.array, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!backtrack.sanitize (c)) return TRACE_RETURN (false);\n    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);\n    if (!input.sanitize (c)) return TRACE_RETURN (false);\n    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);\n    if (!lookahead.sanitize (c)) return TRACE_RETURN (false);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    return TRACE_RETURN (lookup.sanitize (c));\n  }\n\n  protected:\n  ArrayOf<USHORT>\n\t\tbacktrack;\t\t/* Array of backtracking values\n\t\t\t\t\t * (to be matched before the input\n\t\t\t\t\t * sequence) */\n  HeadlessArrayOf<USHORT>\n\t\tinputX;\t\t\t/* Array of input values (start with\n\t\t\t\t\t * second glyph) */\n  ArrayOf<USHORT>\n\t\tlookaheadX;\t\t/* Array of lookahead values's (to be\n\t\t\t\t\t * matched after the input sequence) */\n  ArrayOf<LookupRecord>\n\t\tlookupX;\t\t/* Array of LookupRecords--in\n\t\t\t\t\t * design order) */\n  public:\n  DEFINE_SIZE_MIN (8);\n};\n\nstruct ChainRuleSet\n{\n  inline void closure (hb_closure_context_t *c, ChainContextClosureLookupContext &lookup_context) const\n  {\n    TRACE_CLOSURE (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      (this+rule[i]).closure (c, lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c, ChainContextCollectGlyphsLookupContext &lookup_context) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      (this+rule[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_WOULD_APPLY (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      if ((this+rule[i]).would_apply (c, lookup_context))\n        return TRACE_RETURN (true);\n\n    return TRACE_RETURN (false);\n  }\n\n  inline bool apply (hb_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n  {\n    TRACE_APPLY (this);\n    unsigned int num_rules = rule.len;\n    for (unsigned int i = 0; i < num_rules; i++)\n      if ((this+rule[i]).apply (c, lookup_context))\n        return TRACE_RETURN (true);\n\n    return TRACE_RETURN (false);\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (rule.sanitize (c, this));\n  }\n\n  protected:\n  OffsetArrayOf<ChainRule>\n\t\trule;\t\t\t/* Array of ChainRule tables\n\t\t\t\t\t * ordered by preference */\n  public:\n  DEFINE_SIZE_ARRAY (2, rule);\n};\n\nstruct ChainContextFormat1\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    const Coverage &cov = (this+coverage);\n\n    struct ChainContextClosureLookupContext lookup_context = {\n      {intersects_glyph},\n      {NULL, NULL, NULL}\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (cov.intersects_coverage (c->glyphs, i)) {\n\tconst ChainRuleSet &rule_set = this+ruleSet[i];\n\trule_set.closure (c, lookup_context);\n      }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n\n    struct ChainContextCollectGlyphsLookupContext lookup_context = {\n      {collect_glyph},\n      {NULL, NULL, NULL}\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const ChainRuleSet &rule_set = this+ruleSet[(this+coverage).get_coverage (c->glyphs[0])];\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_glyph},\n      {NULL, NULL, NULL}\n    };\n    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const ChainRuleSet &rule_set = this+ruleSet[index];\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_glyph},\n      {NULL, NULL, NULL}\n    };\n    return TRACE_RETURN (rule_set.apply (c, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && ruleSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 1 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of table */\n  OffsetArrayOf<ChainRuleSet>\n\t\truleSet;\t\t/* Array of ChainRuleSet tables\n\t\t\t\t\t * ordered by Coverage Index */\n  public:\n  DEFINE_SIZE_ARRAY (6, ruleSet);\n};\n\nstruct ChainContextFormat2\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    if (!(this+coverage).intersects (c->glyphs))\n      return;\n\n    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n    const ClassDef &input_class_def = this+inputClassDef;\n    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n\n    struct ChainContextClosureLookupContext lookup_context = {\n      {intersects_class},\n      {&backtrack_class_def,\n       &input_class_def,\n       &lookahead_class_def}\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      if (input_class_def.intersects_class (c->glyphs, i)) {\n\tconst ChainRuleSet &rule_set = this+ruleSet[i];\n\trule_set.closure (c, lookup_context);\n      }\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    (this+coverage).add_coverage (c->input);\n\n    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n    const ClassDef &input_class_def = this+inputClassDef;\n    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n\n    struct ChainContextCollectGlyphsLookupContext lookup_context = {\n      {collect_class},\n      {&backtrack_class_def,\n       &input_class_def,\n       &lookahead_class_def}\n    };\n\n    unsigned int count = ruleSet.len;\n    for (unsigned int i = 0; i < count; i++)\n      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n    const ClassDef &input_class_def = this+inputClassDef;\n    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n\n    unsigned int index = input_class_def.get_class (c->glyphs[0]);\n    const ChainRuleSet &rule_set = this+ruleSet[index];\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_class},\n      {&backtrack_class_def,\n       &input_class_def,\n       &lookahead_class_def}\n    };\n    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    return this+coverage;\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n    const ClassDef &input_class_def = this+inputClassDef;\n    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n\n    index = input_class_def.get_class (c->buffer->cur().codepoint);\n    const ChainRuleSet &rule_set = this+ruleSet[index];\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_class},\n      {&backtrack_class_def,\n       &input_class_def,\n       &lookahead_class_def}\n    };\n    return TRACE_RETURN (rule_set.apply (c, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (coverage.sanitize (c, this) && backtrackClassDef.sanitize (c, this) &&\n\t\t\t inputClassDef.sanitize (c, this) && lookaheadClassDef.sanitize (c, this) &&\n\t\t\t ruleSet.sanitize (c, this));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 2 */\n  OffsetTo<Coverage>\n\t\tcoverage;\t\t/* Offset to Coverage table--from\n\t\t\t\t\t * beginning of table */\n  OffsetTo<ClassDef>\n\t\tbacktrackClassDef;\t/* Offset to glyph ClassDef table\n\t\t\t\t\t * containing backtrack sequence\n\t\t\t\t\t * data--from beginning of table */\n  OffsetTo<ClassDef>\n\t\tinputClassDef;\t\t/* Offset to glyph ClassDef\n\t\t\t\t\t * table containing input sequence\n\t\t\t\t\t * data--from beginning of table */\n  OffsetTo<ClassDef>\n\t\tlookaheadClassDef;\t/* Offset to glyph ClassDef table\n\t\t\t\t\t * containing lookahead sequence\n\t\t\t\t\t * data--from beginning of table */\n  OffsetArrayOf<ChainRuleSet>\n\t\truleSet;\t\t/* Array of ChainRuleSet tables\n\t\t\t\t\t * ordered by class */\n  public:\n  DEFINE_SIZE_ARRAY (12, ruleSet);\n};\n\nstruct ChainContextFormat3\n{\n  inline void closure (hb_closure_context_t *c) const\n  {\n    TRACE_CLOSURE (this);\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n\n    if (!(this+input[0]).intersects (c->glyphs))\n      return;\n\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    struct ChainContextClosureLookupContext lookup_context = {\n      {intersects_coverage},\n      {this, this, this}\n    };\n    chain_context_closure_lookup (c,\n\t\t\t\t  backtrack.len, (const USHORT *) backtrack.array,\n\t\t\t\t  input.len, (const USHORT *) input.array + 1,\n\t\t\t\t  lookahead.len, (const USHORT *) lookahead.array,\n\t\t\t\t  lookup.len, lookup.array,\n\t\t\t\t  lookup_context);\n  }\n\n  inline void collect_glyphs (hb_collect_glyphs_context_t *c) const\n  {\n    TRACE_COLLECT_GLYPHS (this);\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n\n    (this+input[0]).add_coverage (c->input);\n\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    struct ChainContextCollectGlyphsLookupContext lookup_context = {\n      {collect_coverage},\n      {this, this, this}\n    };\n    chain_context_collect_glyphs_lookup (c,\n\t\t\t\t\t backtrack.len, (const USHORT *) backtrack.array,\n\t\t\t\t\t input.len, (const USHORT *) input.array + 1,\n\t\t\t\t\t lookahead.len, (const USHORT *) lookahead.array,\n\t\t\t\t\t lookup.len, lookup.array,\n\t\t\t\t\t lookup_context);\n  }\n\n  inline bool would_apply (hb_would_apply_context_t *c) const\n  {\n    TRACE_WOULD_APPLY (this);\n\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_coverage},\n      {this, this, this}\n    };\n    return TRACE_RETURN (chain_context_would_apply_lookup (c,\n\t\t\t\t\t\t\t   backtrack.len, (const USHORT *) backtrack.array,\n\t\t\t\t\t\t\t   input.len, (const USHORT *) input.array + 1,\n\t\t\t\t\t\t\t   lookahead.len, (const USHORT *) lookahead.array,\n\t\t\t\t\t\t\t   lookup.len, lookup.array, lookup_context));\n  }\n\n  inline const Coverage &get_coverage (void) const\n  {\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n    return this+input[0];\n  }\n\n  inline bool apply (hb_apply_context_t *c) const\n  {\n    TRACE_APPLY (this);\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n\n    unsigned int index = (this+input[0]).get_coverage (c->buffer->cur().codepoint);\n    if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);\n\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    struct ChainContextApplyLookupContext lookup_context = {\n      {match_coverage},\n      {this, this, this}\n    };\n    return TRACE_RETURN (chain_context_apply_lookup (c,\n\t\t\t\t\t\t     backtrack.len, (const USHORT *) backtrack.array,\n\t\t\t\t\t\t     input.len, (const USHORT *) input.array + 1,\n\t\t\t\t\t\t     lookahead.len, (const USHORT *) lookahead.array,\n\t\t\t\t\t\t     lookup.len, lookup.array, lookup_context));\n  }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    if (!backtrack.sanitize (c, this)) return TRACE_RETURN (false);\n    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n    if (!input.sanitize (c, this)) return TRACE_RETURN (false);\n    if (!input.len) return TRACE_RETURN (false); /* To be consistent with Context. */\n    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n    if (!lookahead.sanitize (c, this)) return TRACE_RETURN (false);\n    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n    return TRACE_RETURN (lookup.sanitize (c));\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier--format = 3 */\n  OffsetArrayOf<Coverage>\n\t\tbacktrack;\t\t/* Array of coverage tables\n\t\t\t\t\t * in backtracking sequence, in  glyph\n\t\t\t\t\t * sequence order */\n  OffsetArrayOf<Coverage>\n\t\tinputX\t\t;\t/* Array of coverage\n\t\t\t\t\t * tables in input sequence, in glyph\n\t\t\t\t\t * sequence order */\n  OffsetArrayOf<Coverage>\n\t\tlookaheadX;\t\t/* Array of coverage tables\n\t\t\t\t\t * in lookahead sequence, in glyph\n\t\t\t\t\t * sequence order */\n  ArrayOf<LookupRecord>\n\t\tlookupX;\t\t/* Array of LookupRecords--in\n\t\t\t\t\t * design order) */\n  public:\n  DEFINE_SIZE_MIN (10);\n};\n\nstruct ChainContext\n{\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (c->dispatch (u.format1));\n    case 2: return TRACE_RETURN (c->dispatch (u.format2));\n    case 3: return TRACE_RETURN (c->dispatch (u.format3));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t/* Format identifier */\n  ChainContextFormat1\tformat1;\n  ChainContextFormat2\tformat2;\n  ChainContextFormat3\tformat3;\n  } u;\n};\n\n\ntemplate <typename T>\nstruct ExtensionFormat1\n{\n  inline unsigned int get_type (void) const { return extensionLookupType; }\n\n  template <typename X>\n  inline const X& get_subtable (void) const\n  {\n    unsigned int offset = extensionOffset;\n    if (unlikely (!offset)) return Null(typename T::LookupSubTable);\n    return StructAtOffset<typename T::LookupSubTable> (this, offset);\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, format);\n    if (unlikely (!c->may_dispatch (this, this))) return TRACE_RETURN (c->default_return_value ());\n    return TRACE_RETURN (get_subtable<typename T::LookupSubTable> ().dispatch (c, get_type ()));\n  }\n\n  /* This is called from may_dispatch() above with hb_sanitize_context_t. */\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (c->check_struct (this) && extensionOffset != 0);\n  }\n\n  protected:\n  USHORT\tformat;\t\t\t/* Format identifier. Set to 1. */\n  USHORT\textensionLookupType;\t/* Lookup type of subtable referenced\n\t\t\t\t\t * by ExtensionOffset (i.e. the\n\t\t\t\t\t * extension subtable). */\n  ULONG\t\textensionOffset;\t/* Offset to the extension subtable,\n\t\t\t\t\t * of lookup type subtable. */\n  public:\n  DEFINE_SIZE_STATIC (8);\n};\n\ntemplate <typename T>\nstruct Extension\n{\n  inline unsigned int get_type (void) const\n  {\n    switch (u.format) {\n    case 1: return u.format1.get_type ();\n    default:return 0;\n    }\n  }\n  template <typename X>\n  inline const X& get_subtable (void) const\n  {\n    switch (u.format) {\n    case 1: return u.format1.template get_subtable<typename T::LookupSubTable> ();\n    default:return Null(typename T::LookupSubTable);\n    }\n  }\n\n  template <typename context_t>\n  inline typename context_t::return_t dispatch (context_t *c) const\n  {\n    TRACE_DISPATCH (this, u.format);\n    if (unlikely (!c->may_dispatch (this, &u.format))) return TRACE_RETURN (c->default_return_value ());\n    switch (u.format) {\n    case 1: return TRACE_RETURN (u.format1.dispatch (c));\n    default:return TRACE_RETURN (c->default_return_value ());\n    }\n  }\n\n  protected:\n  union {\n  USHORT\t\tformat;\t\t/* Format identifier */\n  ExtensionFormat1<T>\tformat1;\n  } u;\n};\n\n\n/*\n * GSUB/GPOS Common\n */\n\nstruct GSUBGPOS\n{\n  static const hb_tag_t GSUBTag\t= HB_OT_TAG_GSUB;\n  static const hb_tag_t GPOSTag\t= HB_OT_TAG_GPOS;\n\n  inline unsigned int get_script_count (void) const\n  { return (this+scriptList).len; }\n  inline const Tag& get_script_tag (unsigned int i) const\n  { return (this+scriptList).get_tag (i); }\n  inline unsigned int get_script_tags (unsigned int start_offset,\n\t\t\t\t       unsigned int *script_count /* IN/OUT */,\n\t\t\t\t       hb_tag_t     *script_tags /* OUT */) const\n  { return (this+scriptList).get_tags (start_offset, script_count, script_tags); }\n  inline const Script& get_script (unsigned int i) const\n  { return (this+scriptList)[i]; }\n  inline bool find_script_index (hb_tag_t tag, unsigned int *index) const\n  { return (this+scriptList).find_index (tag, index); }\n\n  inline unsigned int get_feature_count (void) const\n  { return (this+featureList).len; }\n  inline hb_tag_t get_feature_tag (unsigned int i) const\n  { return i == Index::NOT_FOUND_INDEX ? HB_TAG_NONE : (this+featureList).get_tag (i); }\n  inline unsigned int get_feature_tags (unsigned int start_offset,\n\t\t\t\t\tunsigned int *feature_count /* IN/OUT */,\n\t\t\t\t\thb_tag_t     *feature_tags /* OUT */) const\n  { return (this+featureList).get_tags (start_offset, feature_count, feature_tags); }\n  inline const Feature& get_feature (unsigned int i) const\n  { return (this+featureList)[i]; }\n  inline bool find_feature_index (hb_tag_t tag, unsigned int *index) const\n  { return (this+featureList).find_index (tag, index); }\n\n  inline unsigned int get_lookup_count (void) const\n  { return (this+lookupList).len; }\n  inline const Lookup& get_lookup (unsigned int i) const\n  { return (this+lookupList)[i]; }\n\n  inline bool sanitize (hb_sanitize_context_t *c) const\n  {\n    TRACE_SANITIZE (this);\n    return TRACE_RETURN (version.sanitize (c) && likely (version.major == 1) &&\n\t\t\t scriptList.sanitize (c, this) &&\n\t\t\t featureList.sanitize (c, this) &&\n\t\t\t lookupList.sanitize (c, this));\n  }\n\n  protected:\n  FixedVersion\tversion;\t/* Version of the GSUB/GPOS table--initially set\n\t\t\t\t * to 0x00010000u */\n  OffsetTo<ScriptList>\n\t\tscriptList;  \t/* ScriptList table */\n  OffsetTo<FeatureList>\n\t\tfeatureList; \t/* FeatureList table */\n  OffsetTo<LookupList>\n\t\tlookupList; \t/* LookupList table */\n  public:\n  DEFINE_SIZE_STATIC (10);\n};\n\n\n} /* namespace OT */\n\n\n#endif /* HB_OT_LAYOUT_GSUBGPOS_PRIVATE_HH */\n"], "filenames": ["src/hb-ot-layout-gpos-table.hh", "src/hb-ot-layout-gsub-table.hh", "src/hb-ot-layout-gsubgpos-private.hh"], "buggy_code_start_loc": [551, 228, 1520], "buggy_code_end_loc": [1401, 1074, 2215], "fixing_code_start_loc": [551, 228, 1520], "fixing_code_end_loc": [1401, 1074, 2215], "type": "CWE-125", "message": "HarfBuzz before 1.0.4 allows remote attackers to cause a denial of service (invalid read of two bytes and application crash) because of GPOS and GSUB table mishandling, related to hb-ot-layout-gpos-table.hh, hb-ot-layout-gsub-table.hh, and hb-ot-layout-gsubgpos-private.hh.", "other": {"cve": {"id": "CVE-2015-9274", "sourceIdentifier": "cve@mitre.org", "published": "2018-11-15T06:29:00.230", "lastModified": "2018-12-18T17:21:34.120", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HarfBuzz before 1.0.4 allows remote attackers to cause a denial of service (invalid read of two bytes and application crash) because of GPOS and GSUB table mishandling, related to hb-ot-layout-gpos-table.hh, hb-ot-layout-gsub-table.hh, and hb-ot-layout-gsubgpos-private.hh."}, {"lang": "es", "value": "HarfBuzz en versiones anteriores a la 1.0.4 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (lectura inv\u00e1lida de dos bytes y cierre inesperado de la aplicaci\u00f3n) debido a la mala gesti\u00f3n de las tablas GPOS y GSUB. Esto est\u00e1 relacionado con hb-ot-layout-gpos-table.hh, hb-ot-layout-gsub-table.hh y hb-ot-layout-gsubgpos-private.hh."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:harfbuzz_project:harfbuzz:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.4", "matchCriteriaId": "99A50967-33C2-466D-8265-83349CE193CE"}]}]}], "references": [{"url": "https://github.com/harfbuzz/harfbuzz/commit/c917965b9e6fe2b21ed6c51559673288fa3af4b7", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/harfbuzz/harfbuzz/commit/c917965b9e6fe2b21ed6c51559673288fa3af4b7"}}