{"buggy_code": ["language: node_js\nnode_js:\n  - 6\n  - node\nenv:\n  - NODE_ENV=production\nsudo: false\ncache:\n  directories:\n    - node_modules\ninstall:\n  - npm --production=false install\n  - npm --production=false update\n  - npm --production=false prune\njobs:\n  include:\n    - stage: test\n      script:\n      - npm run test\n    - stage: deploy\n      node_js: 6\n      script: npm run build\n      before_deploy:\n      - VPKG=$($(npm bin)/json -f package.json version)\n      - export VERSION=${VPKG}-prerelease.$(date +%Y%m%d%H%M%S)\n      - npm --no-git-tag-version version $VERSION\n      - git config --global user.email \"$(git log --pretty=format:\"%ae\" -n1)\"\n      - git config --global user.name \"$(git log --pretty=format:\"%an\" -n1)\"\n      deploy:\n        provider: npm\n        skip_cleanup: true\n        \"on\":\n          all_branches: true\n          condition: $RELEASE_BRANCHES =~ $TRAVIS_BRANCH\n        email: $NPM_EMAIL\n        api_key: $NPM_TOKEN\n", "{\n  \"name\": \"scratch-svg-renderer\",\n  \"version\": \"0.2.0\",\n  \"description\": \"SVG renderer for Scratch\",\n  \"main\": \"./src/index.js\",\n  \"scripts\": {\n    \"build\": \"npm run clean && webpack --progress --colors --bail\",\n    \"clean\": \"rimraf ./dist\",\n    \"start\": \"webpack-dev-server\",\n    \"test\": \"npm run test:lint && npm run test:unit\",\n    \"test:lint\": \"eslint . --ext .js\",\n    \"test:unit\": \"tap ./test/*.js\",\n    \"watch\": \"webpack --progress --colors --watch\"\n  },\n  \"author\": \"Massachusetts Institute of Technology\",\n  \"license\": \"BSD-3-Clause\",\n  \"homepage\": \"https://github.com/LLK/scratch-svg-renderer#readme\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+ssh://git@github.com/LLK/scratch-svg-renderer.git\"\n  },\n  \"dependencies\": {\n    \"base64-js\": \"1.2.1\",\n    \"base64-loader\": \"1.0.0\",\n    \"minilog\": \"3.1.0\",\n    \"transformation-matrix\": \"1.15.0\",\n    \"scratch-render-fonts\": \"1.0.0-prerelease.20200507182347\"\n  },\n  \"devDependencies\": {\n    \"babel-core\": \"6.26.0\",\n    \"babel-eslint\": \"^8.1.2\",\n    \"babel-loader\": \"7.1.5\",\n    \"babel-preset-env\": \"1.6.1\",\n    \"copy-webpack-plugin\": \"^4.5.1\",\n    \"eslint\": \"^4.14.0\",\n    \"eslint-config-scratch\": \"^5.0.0\",\n    \"eslint-plugin-import\": \"^2.12.0\",\n    \"jsdom\": \"^13.0.0\",\n    \"json\": \"^9.0.6\",\n    \"lodash.defaultsdeep\": \"4.6.1\",\n    \"mkdirp\": \"^1.0.3\",\n    \"rimraf\": \"^3.0.1\",\n    \"tap\": \"^11.0.1\",\n    \"webpack\": \"^4.8.0\",\n    \"webpack-cli\": \"^3.1.0\",\n    \"webpack-dev-server\": \"^3.1.4\",\n    \"xmldom\": \"^0.1.27\"\n  }\n}\n", "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Scratch SVG rendering playground</title>\n    <style>\n        .result {\n            background-color:gray;\n        }\n        #reference {\n            display:inline-block;\n            font-size:0;\n        }\n        .column {\n            display:inline-block;\n        }\n    </style>\n</head>\n<body>\n    <p>\n        <input type=\"file\" id=\"svg-file-upload\", accept=\"image/svg+xml\">\n    </p>\n    <p>\n        <label for=\"render-scale\">Scale:</label>\n        <input type=\"range\" style=\"width:50%;\" id=\"render-scale\" value=\"1\" min=\"0.5\" max=\"3\" step=\"any\">\n        <label for=\"render-scale\" id=\"scale-display\"></label>\n    </p>\n    <p>\n        <input type=\"button\" id=\"trigger-render\" value=\"Render\">\n    </p>\n\n    <div class=\"columns\">\n        <div class=\"column\">\n            <div>Rendered Result</div>\n            <canvas id=\"render-canvas\" class=\"result\"></canvas>\n       </div>\n       <div class=\"column\">\n            <div>Reference</div>\n            <span id=\"reference\"></span>\n       </div>\n     </div>\n\n    <script src=\"scratch-svg-renderer.js\"></script>\n    <script>\n        const renderCanvas = document.getElementById(\"render-canvas\");\n        const referenceImage = document.getElementById(\"reference\");\n        const fileChooser = document.getElementById(\"svg-file-upload\");\n        const scaleSlider = document.getElementById(\"render-scale\");\n        const scaleDisplay = document.getElementById(\"scale-display\");\n        const renderButton = document.getElementById(\"trigger-render\");\n\n        const renderer = new ScratchSVGRenderer.SVGRenderer(renderCanvas);\n\n        let loadedSVGString = \"\";\n\n        if (fileChooser.value) {\n            loadSVGString();\n        }\n\n        function renderSVGString(str) {\n            renderer.fromString(str);\n            renderer._draw(parseFloat(scaleSlider.value));\n        }\n\n        function updateReferenceImage() {\n            referenceImage.innerHTML = loadedSVGString;\n            scalePercent = (parseFloat(scaleSlider.value) * 100) + \"%\"\n            referenceSVG = referenceImage.children[0];\n            referenceSVG.style.width = referenceSVG.style.height = scalePercent;\n            referenceSVG.classList.add(\"result\");\n        }\n\n        function readFileAsText(file) {\n            return new Promise((res, rej) => {\n                const reader = new FileReader();\n\n                reader.onload = function(event) {\n                    res(reader.result);\n                }\n\n                reader.onerror = console.log;\n\n                reader.readAsText(file);\n            })\n        }\n\n        function loadSVGString() {\n            readFileAsText(fileChooser.files[0]).then(str => {\n                loadedSVGString = str;\n            })\n        }\n\n        function renderLoadedString() {\n            renderSVGString(loadedSVGString);\n            updateReferenceImage();\n        }\n\n        function scaleSliderChanged() {\n            renderLoadedString();\n            scaleDisplay.innerText = scaleSlider.value;\n        }\n\n        fileChooser.addEventListener(\"change\", loadSVGString);\n\n        scaleSlider.addEventListener(\"change\", scaleSliderChanged);\n        scaleSlider.addEventListener(\"input\", scaleSliderChanged);\n\n        renderButton.addEventListener(\"click\", (event => {\n            renderLoadedString();\n        }));\n    </script>\n</body>\n</html>\n", "const inlineSvgFonts = require('./font-inliner');\nconst SvgElement = require('./svg-element');\nconst convertFonts = require('./font-converter');\nconst fixupSvgString = require('./fixup-svg-string');\nconst transformStrokeWidths = require('./transform-applier');\n\n/**\n * Main quirks-mode SVG rendering code.\n */\nclass SvgRenderer {\n    /**\n     * Create a quirks-mode SVG renderer for a particular canvas.\n     * @param {HTMLCanvasElement} [canvas] An optional canvas element to draw to. If this is not provided, the renderer\n     * will create a new canvas.\n     * @constructor\n     */\n    constructor (canvas) {\n        this._canvas = canvas || document.createElement('canvas');\n        this._context = this._canvas.getContext('2d');\n        this._measurements = {x: 0, y: 0, width: 0, height: 0};\n        this._cachedImage = null;\n        this.loaded = false;\n    }\n\n    /**\n     * @returns {!HTMLCanvasElement} this renderer's target canvas.\n     */\n    get canvas () {\n        return this._canvas;\n    }\n\n    /**\n     * Load an SVG from a string and draw it.\n     * This will be parsed and transformed, and finally drawn.\n     * When drawing is finished, the `onFinish` callback is called.\n     * @param {string} svgString String of SVG data to draw in quirks-mode.\n     * @param {number} [scale] - Optionally, also scale the image by this factor.\n     * @param {Function} [onFinish] Optional callback for when drawing finished.\n     * @deprecated Use the `loadSVG` method and public `draw` method instead.\n     */\n    fromString (svgString, scale, onFinish) {\n        this.loadSVG(svgString, false, () => {\n            this.draw(scale);\n            if (onFinish) onFinish();\n        });\n    }\n\n    /**\n     * Load an SVG from a string and measure it.\n     * @param {string} svgString String of SVG data to draw in quirks-mode.\n     * @return {object} the natural size, in Scratch units, of this SVG.\n     */\n    measure (svgString) {\n        this.loadString(svgString);\n        return this._measurements;\n    }\n\n    /**\n     * @return {Array<number>} the natural size, in Scratch units, of this SVG.\n     */\n    get size () {\n        return [this._measurements.width, this._measurements.height];\n    }\n\n    /**\n     * @return {Array<number>} the offset (upper left corner) of the SVG's view box.\n     */\n    get viewOffset () {\n        return [this._measurements.x, this._measurements.y];\n    }\n\n    /**\n     * Load an SVG string and normalize it. All the steps before drawing/measuring.\n     * @param {!string} svgString String of SVG data to draw in quirks-mode.\n     * @param {?boolean} fromVersion2 True if we should perform conversion from\n     *     version 2 to version 3 svg.\n     */\n    loadString (svgString, fromVersion2) {\n        // New svg string invalidates the cached image\n        this._cachedImage = null;\n\n        // Parse string into SVG XML.\n        const parser = new DOMParser();\n        svgString = fixupSvgString(svgString);\n        this._svgDom = parser.parseFromString(svgString, 'text/xml');\n        if (this._svgDom.childNodes.length < 1 ||\n            this._svgDom.documentElement.localName !== 'svg') {\n            throw new Error('Document does not appear to be SVG.');\n        }\n        this._svgTag = this._svgDom.documentElement;\n        if (fromVersion2) {\n            // Fix gradients. Scratch 2 exports no x2 when x2 = 0, but\n            // SVG default is that x2 is 1. This must be done before\n            // transformStrokeWidths since transformStrokeWidths affects\n            // gradients.\n            this._transformGradients();\n        }\n        transformStrokeWidths(this._svgTag, window);\n        this._transformImages(this._svgTag);\n        if (fromVersion2) {\n            // Transform all text elements.\n            this._transformText();\n            // Transform measurements.\n            this._transformMeasurements();\n            // Fix stroke roundedness.\n            this._setGradientStrokeRoundedness();\n        } else if (!this._svgTag.getAttribute('viewBox')) {\n            // Renderer expects a view box.\n            this._transformMeasurements();\n        } else if (!this._svgTag.getAttribute('width') || !this._svgTag.getAttribute('height')) {\n            this._svgTag.setAttribute('width', this._svgTag.viewBox.baseVal.width);\n            this._svgTag.setAttribute('height', this._svgTag.viewBox.baseVal.height);\n        }\n        this._measurements = {\n            width: this._svgTag.viewBox.baseVal.width,\n            height: this._svgTag.viewBox.baseVal.height,\n            x: this._svgTag.viewBox.baseVal.x,\n            y: this._svgTag.viewBox.baseVal.y\n        };\n    }\n\n    /**\n     * Load an SVG string, normalize it, and prepare it for (synchronous) rendering.\n     * @param {!string} svgString String of SVG data to draw in quirks-mode.\n     * @param {?boolean} fromVersion2 True if we should perform conversion from version 2 to version 3 svg.\n     * @param {Function} [onFinish] - An optional callback to call when the SVG is loaded and can be rendered.\n     */\n    loadSVG (svgString, fromVersion2, onFinish) {\n        this.loadString(svgString, fromVersion2);\n        this._createSVGImage(onFinish);\n    }\n\n    /**\n     * Creates an <img> element for the currently loaded SVG string, then calls the callback once it's loaded.\n     * @param {Function} [onFinish] - An optional callback to call when the <img> has loaded.\n     */\n    _createSVGImage (onFinish) {\n        if (this._cachedImage === null) this._cachedImage = new Image();\n        const img = this._cachedImage;\n\n        img.onload = () => {\n            this.loaded = true;\n            if (onFinish) onFinish();\n        };\n        const svgText = this.toString(true /* shouldInjectFonts */);\n        img.src = `data:image/svg+xml;utf8,${encodeURIComponent(svgText)}`;\n        this.loaded = false;\n    }\n\n    /**\n     * Transforms an SVG's text elements for Scratch 2.0 quirks.\n     * These quirks include:\n     * 1. `x` and `y` properties are removed/ignored.\n     * 2. Alignment is set to `text-before-edge`.\n     * 3. Line-breaks are converted to explicit <tspan> elements.\n     * 4. Any required fonts are injected.\n     */\n    _transformText () {\n        // Collect all text elements into a list.\n        const textElements = [];\n        const collectText = domElement => {\n            if (domElement.localName === 'text') {\n                textElements.push(domElement);\n            }\n            for (let i = 0; i < domElement.childNodes.length; i++) {\n                collectText(domElement.childNodes[i]);\n            }\n        };\n        collectText(this._svgTag);\n        convertFonts(this._svgTag);\n        // For each text element, apply quirks.\n        for (const textElement of textElements) {\n            // Remove x and y attributes - they are not used in Scratch.\n            textElement.removeAttribute('x');\n            textElement.removeAttribute('y');\n            // Set text-before-edge alignment:\n            // Scratch renders all text like this.\n            textElement.setAttribute('alignment-baseline', 'text-before-edge');\n            textElement.setAttribute('xml:space', 'preserve');\n            // If there's no font size provided, provide one.\n            if (!textElement.getAttribute('font-size')) {\n                textElement.setAttribute('font-size', '18');\n            }\n            let text = textElement.textContent;\n\n            // Fix line breaks in text, which are not natively supported by SVG.\n            // Only fix if text does not have child tspans.\n            // @todo this will not work for font sizes with units such as em, percent\n            // However, text made in scratch 2 should only ever export size 22 font.\n            const fontSize = parseFloat(textElement.getAttribute('font-size'));\n            const tx = 2;\n            let ty = 0;\n            let spacing = 1.2;\n            // Try to match the position and spacing of Scratch 2.0's fonts.\n            // Different fonts seem to use different line spacing.\n            // Scratch 2 always uses alignment-baseline=text-before-edge\n            // However, most SVG readers don't support this attribute\n            // or don't support it alongside use of tspan, so the translations\n            // here are to make up for that.\n            if (textElement.getAttribute('font-family') === 'Handwriting') {\n                spacing = 2;\n                ty = -11 * fontSize / 22;\n            } else if (textElement.getAttribute('font-family') === 'Scratch') {\n                spacing = 0.89;\n                ty = -3 * fontSize / 22;\n            } else if (textElement.getAttribute('font-family') === 'Curly') {\n                spacing = 1.38;\n                ty = -6 * fontSize / 22;\n            } else if (textElement.getAttribute('font-family') === 'Marker') {\n                spacing = 1.45;\n                ty = -6 * fontSize / 22;\n            } else if (textElement.getAttribute('font-family') === 'Sans Serif') {\n                spacing = 1.13;\n                ty = -3 * fontSize / 22;\n            } else if (textElement.getAttribute('font-family') === 'Serif') {\n                spacing = 1.25;\n                ty = -4 * fontSize / 22;\n            }\n\n            if (textElement.transform.baseVal.numberOfItems === 0) {\n                const transform = this._svgTag.createSVGTransform();\n                textElement.transform.baseVal.appendItem(transform);\n            }\n\n            // Right multiply matrix by a translation of (tx, ty)\n            const mtx = textElement.transform.baseVal.getItem(0).matrix;\n            mtx.e += (mtx.a * tx) + (mtx.c * ty);\n            mtx.f += (mtx.b * tx) + (mtx.d * ty);\n\n            if (text && textElement.childElementCount === 0) {\n                textElement.textContent = '';\n                const lines = text.split('\\n');\n                text = '';\n                for (const line of lines) {\n                    const tspanNode = SvgElement.create('tspan');\n                    tspanNode.setAttribute('x', '0');\n                    tspanNode.setAttribute('style', 'white-space: pre');\n                    tspanNode.setAttribute('dy', `${spacing}em`);\n                    tspanNode.textContent = line ? line : ' ';\n                    textElement.appendChild(tspanNode);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {string} [tagName] svg tag to search for (or collect all elements if not given)\n     * @return {Array} a list of elements with the given tagname in _svgTag\n     */\n    _collectElements (tagName) {\n        const elts = [];\n        const collectElements = domElement => {\n            if ((domElement.localName === tagName || typeof tagName === 'undefined') && domElement.getAttribute) {\n                elts.push(domElement);\n            }\n            for (let i = 0; i < domElement.childNodes.length; i++) {\n                collectElements(domElement.childNodes[i]);\n            }\n        };\n        collectElements(this._svgTag);\n        return elts;\n    }\n\n    /**\n     * Fix SVGs to comply with SVG spec. Scratch 2 defaults to x2 = 0 when x2 is missing, but\n     * SVG defaults to x2 = 1 when missing.\n     */\n    _transformGradients () {\n        const linearGradientElements = this._collectElements('linearGradient');\n\n        // For each gradient element, supply x2 if necessary.\n        for (const gradientElement of linearGradientElements) {\n            if (!gradientElement.getAttribute('x2')) {\n                gradientElement.setAttribute('x2', '0');\n            }\n        }\n    }\n\n    /**\n     * Fix SVGs to match appearance in Scratch 2, which used nearest neighbor scaling for bitmaps\n     * within SVGs.\n     */\n    _transformImages () {\n        const imageElements = this._collectElements('image');\n\n        // For each image element, set image rendering to pixelated\n        const pixelatedImages = 'image-rendering: optimizespeed; image-rendering: pixelated;';\n        for (const elt of imageElements) {\n            if (elt.getAttribute('style')) {\n                elt.setAttribute('style',\n                    `${pixelatedImages} ${elt.getAttribute('style')}`);\n            } else {\n                elt.setAttribute('style', pixelatedImages);\n            }\n        }\n    }\n\n    /**\n     * Find the largest stroke width in the svg. If a shape has no\n     * `stroke` property, it has a stroke-width of 0. If it has a `stroke`,\n     * it is by default a stroke-width of 1.\n     * This is used to enlarge the computed bounding box, which doesn't take\n     * stroke width into account.\n     * @param {SVGSVGElement} rootNode The root SVG node to traverse.\n     * @return {number} The largest stroke width in the SVG.\n     */\n    _findLargestStrokeWidth (rootNode) {\n        let largestStrokeWidth = 0;\n        const collectStrokeWidths = domElement => {\n            if (domElement.getAttribute) {\n                if (domElement.getAttribute('stroke')) {\n                    largestStrokeWidth = Math.max(largestStrokeWidth, 1);\n                }\n                if (domElement.getAttribute('stroke-width')) {\n                    largestStrokeWidth = Math.max(\n                        largestStrokeWidth,\n                        Number(domElement.getAttribute('stroke-width')) || 0\n                    );\n                }\n            }\n            for (let i = 0; i < domElement.childNodes.length; i++) {\n                collectStrokeWidths(domElement.childNodes[i]);\n            }\n        };\n        collectStrokeWidths(rootNode);\n        return largestStrokeWidth;\n    }\n\n    /**\n     * Find all instances of a URL-referenced `stroke` in the svg. In 2.0, all gradient strokes\n     * have a round `stroke-linejoin` and `stroke-linecap`... for some reason.\n     */\n    _setGradientStrokeRoundedness () {\n        const elements = this._collectElements();\n\n        for (const elt of elements) {\n            if (!elt.style) continue;\n            const stroke = elt.style.stroke || elt.getAttribute('stroke');\n            if (stroke && stroke.match(/^url\\(#.*\\)$/)) {\n                elt.style['stroke-linejoin'] = 'round';\n                elt.style['stroke-linecap'] = 'round';\n            }\n        }\n    }\n\n    /**\n     * Transform the measurements of the SVG.\n     * In Scratch 2.0, SVGs are drawn without respect to the width,\n     * height, and viewBox attribute on the tag. The exporter\n     * does output these properties - but they appear to be incorrect often.\n     * To address the incorrect measurements, we append the DOM to the\n     * document, and then use SVG's native `getBBox` to find the real\n     * drawn dimensions. This ensures things drawn in negative dimensions,\n     * outside the given viewBox, etc., are all eventually drawn to the canvas.\n     * I tried to do this several other ways: stripping the width/height/viewBox\n     * attributes and then drawing (Firefox won't draw anything),\n     * or inflating them and then measuring a canvas. But this seems to be\n     * a natural and performant way.\n     */\n    _transformMeasurements () {\n        // Append the SVG dom to the document.\n        // This allows us to use `getBBox` on the page,\n        // which returns the full bounding-box of all drawn SVG\n        // elements, similar to how Scratch 2.0 did measurement.\n        const svgSpot = document.createElement('span');\n        // Clone the svg tag. This tag becomes unusable/undrawable in browsers\n        // once it's appended to the page, perhaps for security reasons?\n        const tempTag = this._svgTag.cloneNode(/* deep */ true);\n        let bbox;\n        try {\n            svgSpot.appendChild(tempTag);\n            document.body.appendChild(svgSpot);\n            // Take the bounding box.\n            bbox = tempTag.getBBox();\n        } finally {\n            // Always destroy the element, even if, for example, getBBox throws.\n            document.body.removeChild(svgSpot);\n            svgSpot.removeChild(tempTag);\n        }\n\n        // Enlarge the bbox from the largest found stroke width\n        // This may have false-positives, but at least the bbox will always\n        // contain the full graphic including strokes.\n        // If the width or height is zero however, don't enlarge since\n        // they won't have a stroke width that needs to be enlarged.\n        let halfStrokeWidth;\n        if (bbox.width === 0 || bbox.height === 0) {\n            halfStrokeWidth = 0;\n        } else {\n            halfStrokeWidth = this._findLargestStrokeWidth(this._svgTag) / 2;\n        }\n        const width = bbox.width + (halfStrokeWidth * 2);\n        const height = bbox.height + (halfStrokeWidth * 2);\n        const x = bbox.x - halfStrokeWidth;\n        const y = bbox.y - halfStrokeWidth;\n\n        // Set the correct measurements on the SVG tag\n        this._svgTag.setAttribute('width', width);\n        this._svgTag.setAttribute('height', height);\n        this._svgTag.setAttribute('viewBox',\n            `${x} ${y} ${width} ${height}`);\n    }\n\n    /**\n     * Serialize the active SVG DOM to a string.\n     * @param {?boolean} shouldInjectFonts True if fonts should be included in the SVG as\n     *     base64 data.\n     * @returns {string} String representing current SVG data.\n     */\n    toString (shouldInjectFonts) {\n        const serializer = new XMLSerializer();\n        let string = serializer.serializeToString(this._svgDom);\n        if (shouldInjectFonts) {\n            string = inlineSvgFonts(string);\n        }\n        return string;\n    }\n\n    /**\n     * Synchronously draw the loaded SVG to this renderer's `canvas`.\n     * @param {number} [scale] - Optionally, also scale the image by this factor.\n     */\n    draw (scale) {\n        if (!this.loaded) throw new Error('SVG image has not finished loading');\n        this._drawFromImage(scale);\n    }\n\n    /**\n     * Asynchronously draw the (possibly non-loaded) SVG to a canvas.\n     * @param {number} [scale] - Optionally, also scale the image by this factor.\n     * @param {Function} [onFinish] - An optional callback to call when the draw operation is complete.\n     * @deprecated Use the `loadSVG` and public `draw` method instead.\n     */\n    _draw (scale, onFinish) {\n        // Convert the SVG text to an Image, and then draw it to the canvas.\n        if (this._cachedImage === null) {\n            this._createSVGImage(() => {\n                this._drawFromImage(scale);\n                onFinish();\n            });\n        } else {\n            this._drawFromImage(scale);\n            onFinish();\n        }\n    }\n\n    /**\n     * Draw to the canvas from a loaded image element.\n     * @param {number} [scale] - Optionally, also scale the image by this factor.\n     **/\n    _drawFromImage (scale) {\n        if (this._cachedImage === null) return;\n\n        const ratio = Number.isFinite(scale) ? scale : 1;\n        const bbox = this._measurements;\n        this._canvas.width = bbox.width * ratio;\n        this._canvas.height = bbox.height * ratio;\n        // Even if the canvas at the current scale has a nonzero size, the image's dimensions are floored pre-scaling.\n        // e.g. if an image has a width of 0.4 and is being rendered at 3x scale, the canvas will have a width of 1, but\n        // the image's width will be rounded down to 0 on some browsers (Firefox) prior to being drawn at that scale.\n        if (\n            this._canvas.width <= 0 ||\n            this._canvas.height <= 0 ||\n            this._cachedImage.naturalWidth <= 0 ||\n            this._cachedImage.naturalHeight <= 0\n        ) return;\n        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        this._context.scale(ratio, ratio);\n        this._context.drawImage(this._cachedImage, 0, 0);\n        // Reset the canvas transform after drawing.\n        this._context.setTransform(1, 0, 0, 1, 0, 0);\n        // Set the CSS style of the canvas to the actual measurements.\n        this._canvas.style.width = bbox.width;\n        this._canvas.style.height = bbox.height;\n    }\n}\n\nmodule.exports = SvgRenderer;\n"], "fixing_code": ["language: node_js\nnode_js:\n  - 6\n  - node\nenv:\n  global:\n    - NODE_ENV=production\n    - NPM_TAG=latest\n    - RELEASE_TIMESTAMP=\"$(date +'%Y%m%d%H%M%S')\"\nsudo: false\ncache:\n  directories:\n    - node_modules\ninstall:\n  - npm --production=false install\n  - npm --production=false update\n  - npm --production=false prune\njobs:\n  include:\n    - stage: test\n      script:\n      - npm run test\n    - stage: deploy\n      node_js: 6\n      script: npm run build\n      before_deploy:\n      - >\n        if [ -z \"$BEFORE_DEPLOY_RAN\" ]; then\n          VPKG=$($(npm bin)/json -f package.json version)\n          export RELEASE_VERSION=${VPKG}-prerelease.${RELEASE_TIMESTAMP}\n          npm --no-git-tag-version version $RELEASE_VERSION\n          if [[ \"$TRAVIS_BRANCH\" == hotfix/* ]]; then # double brackets are important for matching the wildcard\n            export NPM_TAG=hotfix\n          fi\n          git config --global user.email \"$(git log --pretty=format:\"%ae\" -n1)\"\n          git config --global user.name \"$(git log --pretty=format:\"%an\" -n1)\"\n          export BEFORE_DEPLOY_RAN=true\n        fi\n      deploy:\n      - provider: npm\n        on:\n          branch:\n          - master\n          - develop\n          - hotfix/*\n          condition: $TRAVIS_EVENT_TYPE != cron\n        skip_cleanup: true\n        email: $NPM_EMAIL\n        api_key: $NPM_TOKEN\n        tag: $NPM_TAG\n      - provider: script\n        on:\n          branch:\n          - master\n          - develop\n          - hotfix/*\n          condition: $TRAVIS_EVENT_TYPE != cron\n        skip_cleanup: true\n        script: if npm info | grep -q $RELEASE_VERSION; then git tag $RELEASE_VERSION && git push https://${GH_TOKEN}@github.com/${TRAVIS_REPO_SLUG}.git $RELEASE_VERSION; fi\n", "{\n  \"name\": \"scratch-svg-renderer\",\n  \"version\": \"0.2.0\",\n  \"description\": \"SVG renderer for Scratch\",\n  \"main\": \"./src/index.js\",\n  \"scripts\": {\n    \"build\": \"npm run clean && webpack --progress --colors --bail\",\n    \"clean\": \"rimraf ./dist\",\n    \"start\": \"webpack-dev-server\",\n    \"test\": \"npm run test:lint && npm run test:unit\",\n    \"test:lint\": \"eslint . --ext .js\",\n    \"test:unit\": \"tap ./test/*.js\",\n    \"watch\": \"webpack --progress --colors --watch\"\n  },\n  \"author\": \"Massachusetts Institute of Technology\",\n  \"license\": \"BSD-3-Clause\",\n  \"homepage\": \"https://github.com/LLK/scratch-svg-renderer#readme\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+ssh://git@github.com/LLK/scratch-svg-renderer.git\"\n  },\n  \"dependencies\": {\n    \"base64-js\": \"1.2.1\",\n    \"base64-loader\": \"1.0.0\",\n    \"dompurify\": \"2.1.1\",\n    \"minilog\": \"3.1.0\",\n    \"transformation-matrix\": \"1.15.0\",\n    \"scratch-render-fonts\": \"1.0.0-prerelease.20200507182347\"\n  },\n  \"devDependencies\": {\n    \"babel-core\": \"6.26.0\",\n    \"babel-eslint\": \"^8.1.2\",\n    \"babel-loader\": \"7.1.5\",\n    \"babel-preset-env\": \"1.6.1\",\n    \"copy-webpack-plugin\": \"^4.5.1\",\n    \"eslint\": \"^4.14.0\",\n    \"eslint-config-scratch\": \"^5.0.0\",\n    \"eslint-plugin-import\": \"^2.12.0\",\n    \"jsdom\": \"^13.0.0\",\n    \"json\": \"^9.0.6\",\n    \"lodash.defaultsdeep\": \"4.6.1\",\n    \"mkdirp\": \"^1.0.3\",\n    \"rimraf\": \"^3.0.1\",\n    \"tap\": \"^11.0.1\",\n    \"webpack\": \"^4.8.0\",\n    \"webpack-cli\": \"^3.1.0\",\n    \"webpack-dev-server\": \"^3.1.4\",\n    \"xmldom\": \"^0.1.27\"\n  }\n}\n", "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Scratch SVG rendering playground</title>\n    <style>\n        .result {\n            background-color:gray;\n        }\n        #reference {\n            display:inline-block;\n            font-size:0;\n        }\n        .column {\n            display:inline-block;\n        }\n    </style>\n</head>\n<body>\n    <p>\n        <input type=\"file\" id=\"svg-file-upload\", accept=\"image/svg+xml\">\n    </p>\n    <p>\n        <label for=\"render-scale\">Scale:</label>\n        <input type=\"range\" style=\"width:50%;\" id=\"render-scale\" value=\"1\" min=\"0.5\" max=\"3\" step=\"any\">\n        <label for=\"render-scale\" id=\"scale-display\"></label>\n    </p>\n    <p>\n        <input type=\"button\" id=\"trigger-render\" value=\"Render\">\n        <label for=\"shouldRenderReference\">\n          <input type=\"checkbox\" id=\"shouldRenderReference\" checked />\n          Render Reference?\n        </label>\n    </p>\n\n    <div class=\"columns\">\n        <div class=\"column\">\n            <div>Rendered Result</div>\n            <canvas id=\"render-canvas\" class=\"result\"></canvas>\n       </div>\n       <div class=\"column\">\n            <div>Reference</div>\n            <span id=\"reference\"></span>\n       </div>\n     </div>\n    <div class=\"columns\">\n        <div class=\"column\">\n            <div>Rendered Content</div>\n            <textarea id=\"renderedContent\" wrap=\"off\" cols=\"50\" rows=\"50\"></textarea>\n       </div>\n       <div class=\"column\">\n            <div>Reference</div>\n            <span id=\"reference\"></span>\n            <textarea id=\"referenceContent\" wrap=\"off\" cols=\"50\" rows=\"50\"></textarea>\n       </div>\n     </div>\n\n    <script src=\"scratch-svg-renderer.js\"></script>\n    <script>\n        const renderCanvas = document.getElementById(\"render-canvas\");\n        const referenceImage = document.getElementById(\"reference\");\n        const fileChooser = document.getElementById(\"svg-file-upload\");\n        const scaleSlider = document.getElementById(\"render-scale\");\n        const scaleDisplay = document.getElementById(\"scale-display\");\n        const renderButton = document.getElementById(\"trigger-render\");\n\n        const renderer = new ScratchSVGRenderer.SVGRenderer(renderCanvas);\n\n        let loadedSVGString = \"\";\n\n        if (fileChooser.value) {\n            loadSVGString();\n        }\n\n        function renderSVGString(str) {\n            renderer.fromString(str);\n            renderer._draw(parseFloat(scaleSlider.value), ()=>{});\n            renderedContent.value = renderer.toString(true);\n        }\n\n        function updateReferenceImage() {\n            referenceImage.innerHTML = loadedSVGString;\n            scalePercent = (parseFloat(scaleSlider.value) * 100) + \"%\"\n            referenceSVG = referenceImage.children[0];\n            referenceSVG.style.width = referenceSVG.style.height = scalePercent;\n            referenceSVG.classList.add(\"result\");\n        }\n\n        function readFileAsText(file) {\n            return new Promise((res, rej) => {\n                const reader = new FileReader();\n\n                reader.onload = function(event) {\n                    res(reader.result);\n                }\n\n                reader.onerror = console.log;\n\n                reader.readAsText(file);\n            })\n        }\n\n        function loadSVGString() {\n            readFileAsText(fileChooser.files[0]).then(str => {\n                loadedSVGString = str;\n            })\n        }\n\n        function renderLoadedString() {\n            renderSVGString(loadedSVGString);\n            referenceContent.value = loadedSVGString;\n            shouldRenderReference.checked && updateReferenceImage();\n        }\n\n        function scaleSliderChanged() {\n            renderLoadedString();\n            scaleDisplay.innerText = scaleSlider.value;\n        }\n\n        fileChooser.addEventListener(\"change\", loadSVGString);\n\n        scaleSlider.addEventListener(\"change\", scaleSliderChanged);\n        scaleSlider.addEventListener(\"input\", scaleSliderChanged);\n\n        renderButton.addEventListener(\"click\", (event => {\n            renderLoadedString();\n        }));\n    </script>\n</body>\n</html>\n", "const DOMPurify = require('dompurify');\nconst inlineSvgFonts = require('./font-inliner');\nconst SvgElement = require('./svg-element');\nconst convertFonts = require('./font-converter');\nconst fixupSvgString = require('./fixup-svg-string');\nconst transformStrokeWidths = require('./transform-applier');\n\n/**\n * Main quirks-mode SVG rendering code.\n */\nclass SvgRenderer {\n    /**\n     * Create a quirks-mode SVG renderer for a particular canvas.\n     * @param {HTMLCanvasElement} [canvas] An optional canvas element to draw to. If this is not provided, the renderer\n     * will create a new canvas.\n     * @constructor\n     */\n    constructor (canvas) {\n        this._canvas = canvas || document.createElement('canvas');\n        this._context = this._canvas.getContext('2d');\n        this._measurements = {x: 0, y: 0, width: 0, height: 0};\n        this._cachedImage = null;\n        this.loaded = false;\n    }\n\n    /**\n     * @returns {!HTMLCanvasElement} this renderer's target canvas.\n     */\n    get canvas () {\n        return this._canvas;\n    }\n\n    /**\n     * Load an SVG from a string and draw it.\n     * This will be parsed and transformed, and finally drawn.\n     * When drawing is finished, the `onFinish` callback is called.\n     * @param {string} svgString String of SVG data to draw in quirks-mode.\n     * @param {number} [scale] - Optionally, also scale the image by this factor.\n     * @param {Function} [onFinish] Optional callback for when drawing finished.\n     * @deprecated Use the `loadSVG` method and public `draw` method instead.\n     */\n    fromString (svgString, scale, onFinish) {\n        this.loadSVG(svgString, false, () => {\n            this.draw(scale);\n            if (onFinish) onFinish();\n        });\n    }\n\n    /**\n     * Load an SVG from a string and measure it.\n     * @param {string} svgString String of SVG data to draw in quirks-mode.\n     * @return {object} the natural size, in Scratch units, of this SVG.\n     */\n    measure (svgString) {\n        this.loadString(svgString);\n        return this._measurements;\n    }\n\n    /**\n     * @return {Array<number>} the natural size, in Scratch units, of this SVG.\n     */\n    get size () {\n        return [this._measurements.width, this._measurements.height];\n    }\n\n    /**\n     * @return {Array<number>} the offset (upper left corner) of the SVG's view box.\n     */\n    get viewOffset () {\n        return [this._measurements.x, this._measurements.y];\n    }\n\n    /**\n     * Load an SVG string and normalize it. All the steps before drawing/measuring.\n     * @param {!string} svgString String of SVG data to draw in quirks-mode.\n     * @param {?boolean} fromVersion2 True if we should perform conversion from\n     *     version 2 to version 3 svg.\n     */\n    loadString (svgString, fromVersion2) {\n        // New svg string invalidates the cached image\n        this._cachedImage = null;\n\n        // Parse string into SVG XML.\n        const parser = new DOMParser();\n        svgString = fixupSvgString(svgString);\n        this._svgDom = parser.parseFromString(svgString, 'text/xml');\n        if (this._svgDom.childNodes.length < 1 ||\n            this._svgDom.documentElement.localName !== 'svg') {\n            throw new Error('Document does not appear to be SVG.');\n        }\n        this._svgTag = this._svgDom.documentElement;\n        if (fromVersion2) {\n            // Fix gradients. Scratch 2 exports no x2 when x2 = 0, but\n            // SVG default is that x2 is 1. This must be done before\n            // transformStrokeWidths since transformStrokeWidths affects\n            // gradients.\n            this._transformGradients();\n        }\n        transformStrokeWidths(this._svgTag, window);\n        this._transformImages(this._svgTag);\n        if (fromVersion2) {\n            // Transform all text elements.\n            this._transformText();\n            // Transform measurements.\n            this._transformMeasurements();\n            // Fix stroke roundedness.\n            this._setGradientStrokeRoundedness();\n        } else if (!this._svgTag.getAttribute('viewBox')) {\n            // Renderer expects a view box.\n            this._transformMeasurements();\n        } else if (!this._svgTag.getAttribute('width') || !this._svgTag.getAttribute('height')) {\n            this._svgTag.setAttribute('width', this._svgTag.viewBox.baseVal.width);\n            this._svgTag.setAttribute('height', this._svgTag.viewBox.baseVal.height);\n        }\n        this._measurements = {\n            width: this._svgTag.viewBox.baseVal.width,\n            height: this._svgTag.viewBox.baseVal.height,\n            x: this._svgTag.viewBox.baseVal.x,\n            y: this._svgTag.viewBox.baseVal.y\n        };\n    }\n\n    /**\n     * Load an SVG string, normalize it, and prepare it for (synchronous) rendering.\n     * @param {!string} svgString String of SVG data to draw in quirks-mode.\n     * @param {?boolean} fromVersion2 True if we should perform conversion from version 2 to version 3 svg.\n     * @param {Function} [onFinish] - An optional callback to call when the SVG is loaded and can be rendered.\n     */\n    loadSVG (svgString, fromVersion2, onFinish) {\n        this.loadString(svgString, fromVersion2);\n        this._createSVGImage(onFinish);\n    }\n\n    /**\n     * Creates an <img> element for the currently loaded SVG string, then calls the callback once it's loaded.\n     * @param {Function} [onFinish] - An optional callback to call when the <img> has loaded.\n     */\n    _createSVGImage (onFinish) {\n        if (this._cachedImage === null) this._cachedImage = new Image();\n        const img = this._cachedImage;\n\n        img.onload = () => {\n            this.loaded = true;\n            if (onFinish) onFinish();\n        };\n        const svgText = this.toString(true /* shouldInjectFonts */);\n        img.src = `data:image/svg+xml;utf8,${encodeURIComponent(svgText)}`;\n        this.loaded = false;\n    }\n\n    /**\n     * Transforms an SVG's text elements for Scratch 2.0 quirks.\n     * These quirks include:\n     * 1. `x` and `y` properties are removed/ignored.\n     * 2. Alignment is set to `text-before-edge`.\n     * 3. Line-breaks are converted to explicit <tspan> elements.\n     * 4. Any required fonts are injected.\n     */\n    _transformText () {\n        // Collect all text elements into a list.\n        const textElements = [];\n        const collectText = domElement => {\n            if (domElement.localName === 'text') {\n                textElements.push(domElement);\n            }\n            for (let i = 0; i < domElement.childNodes.length; i++) {\n                collectText(domElement.childNodes[i]);\n            }\n        };\n        collectText(this._svgTag);\n        convertFonts(this._svgTag);\n        // For each text element, apply quirks.\n        for (const textElement of textElements) {\n            // Remove x and y attributes - they are not used in Scratch.\n            textElement.removeAttribute('x');\n            textElement.removeAttribute('y');\n            // Set text-before-edge alignment:\n            // Scratch renders all text like this.\n            textElement.setAttribute('alignment-baseline', 'text-before-edge');\n            textElement.setAttribute('xml:space', 'preserve');\n            // If there's no font size provided, provide one.\n            if (!textElement.getAttribute('font-size')) {\n                textElement.setAttribute('font-size', '18');\n            }\n            let text = textElement.textContent;\n\n            // Fix line breaks in text, which are not natively supported by SVG.\n            // Only fix if text does not have child tspans.\n            // @todo this will not work for font sizes with units such as em, percent\n            // However, text made in scratch 2 should only ever export size 22 font.\n            const fontSize = parseFloat(textElement.getAttribute('font-size'));\n            const tx = 2;\n            let ty = 0;\n            let spacing = 1.2;\n            // Try to match the position and spacing of Scratch 2.0's fonts.\n            // Different fonts seem to use different line spacing.\n            // Scratch 2 always uses alignment-baseline=text-before-edge\n            // However, most SVG readers don't support this attribute\n            // or don't support it alongside use of tspan, so the translations\n            // here are to make up for that.\n            if (textElement.getAttribute('font-family') === 'Handwriting') {\n                spacing = 2;\n                ty = -11 * fontSize / 22;\n            } else if (textElement.getAttribute('font-family') === 'Scratch') {\n                spacing = 0.89;\n                ty = -3 * fontSize / 22;\n            } else if (textElement.getAttribute('font-family') === 'Curly') {\n                spacing = 1.38;\n                ty = -6 * fontSize / 22;\n            } else if (textElement.getAttribute('font-family') === 'Marker') {\n                spacing = 1.45;\n                ty = -6 * fontSize / 22;\n            } else if (textElement.getAttribute('font-family') === 'Sans Serif') {\n                spacing = 1.13;\n                ty = -3 * fontSize / 22;\n            } else if (textElement.getAttribute('font-family') === 'Serif') {\n                spacing = 1.25;\n                ty = -4 * fontSize / 22;\n            }\n\n            if (textElement.transform.baseVal.numberOfItems === 0) {\n                const transform = this._svgTag.createSVGTransform();\n                textElement.transform.baseVal.appendItem(transform);\n            }\n\n            // Right multiply matrix by a translation of (tx, ty)\n            const mtx = textElement.transform.baseVal.getItem(0).matrix;\n            mtx.e += (mtx.a * tx) + (mtx.c * ty);\n            mtx.f += (mtx.b * tx) + (mtx.d * ty);\n\n            if (text && textElement.childElementCount === 0) {\n                textElement.textContent = '';\n                const lines = text.split('\\n');\n                text = '';\n                for (const line of lines) {\n                    const tspanNode = SvgElement.create('tspan');\n                    tspanNode.setAttribute('x', '0');\n                    tspanNode.setAttribute('style', 'white-space: pre');\n                    tspanNode.setAttribute('dy', `${spacing}em`);\n                    tspanNode.textContent = line ? line : ' ';\n                    textElement.appendChild(tspanNode);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {string} [tagName] svg tag to search for (or collect all elements if not given)\n     * @return {Array} a list of elements with the given tagname in _svgTag\n     */\n    _collectElements (tagName) {\n        const elts = [];\n        const collectElements = domElement => {\n            if ((domElement.localName === tagName || typeof tagName === 'undefined') && domElement.getAttribute) {\n                elts.push(domElement);\n            }\n            for (let i = 0; i < domElement.childNodes.length; i++) {\n                collectElements(domElement.childNodes[i]);\n            }\n        };\n        collectElements(this._svgTag);\n        return elts;\n    }\n\n    /**\n     * Fix SVGs to comply with SVG spec. Scratch 2 defaults to x2 = 0 when x2 is missing, but\n     * SVG defaults to x2 = 1 when missing.\n     */\n    _transformGradients () {\n        const linearGradientElements = this._collectElements('linearGradient');\n\n        // For each gradient element, supply x2 if necessary.\n        for (const gradientElement of linearGradientElements) {\n            if (!gradientElement.getAttribute('x2')) {\n                gradientElement.setAttribute('x2', '0');\n            }\n        }\n    }\n\n    /**\n     * Fix SVGs to match appearance in Scratch 2, which used nearest neighbor scaling for bitmaps\n     * within SVGs.\n     */\n    _transformImages () {\n        const imageElements = this._collectElements('image');\n\n        // For each image element, set image rendering to pixelated\n        const pixelatedImages = 'image-rendering: optimizespeed; image-rendering: pixelated;';\n        for (const elt of imageElements) {\n            if (elt.getAttribute('style')) {\n                elt.setAttribute('style',\n                    `${pixelatedImages} ${elt.getAttribute('style')}`);\n            } else {\n                elt.setAttribute('style', pixelatedImages);\n            }\n        }\n    }\n\n    /**\n     * Find the largest stroke width in the svg. If a shape has no\n     * `stroke` property, it has a stroke-width of 0. If it has a `stroke`,\n     * it is by default a stroke-width of 1.\n     * This is used to enlarge the computed bounding box, which doesn't take\n     * stroke width into account.\n     * @param {SVGSVGElement} rootNode The root SVG node to traverse.\n     * @return {number} The largest stroke width in the SVG.\n     */\n    _findLargestStrokeWidth (rootNode) {\n        let largestStrokeWidth = 0;\n        const collectStrokeWidths = domElement => {\n            if (domElement.getAttribute) {\n                if (domElement.getAttribute('stroke')) {\n                    largestStrokeWidth = Math.max(largestStrokeWidth, 1);\n                }\n                if (domElement.getAttribute('stroke-width')) {\n                    largestStrokeWidth = Math.max(\n                        largestStrokeWidth,\n                        Number(domElement.getAttribute('stroke-width')) || 0\n                    );\n                }\n            }\n            for (let i = 0; i < domElement.childNodes.length; i++) {\n                collectStrokeWidths(domElement.childNodes[i]);\n            }\n        };\n        collectStrokeWidths(rootNode);\n        return largestStrokeWidth;\n    }\n\n    /**\n     * Find all instances of a URL-referenced `stroke` in the svg. In 2.0, all gradient strokes\n     * have a round `stroke-linejoin` and `stroke-linecap`... for some reason.\n     */\n    _setGradientStrokeRoundedness () {\n        const elements = this._collectElements();\n\n        for (const elt of elements) {\n            if (!elt.style) continue;\n            const stroke = elt.style.stroke || elt.getAttribute('stroke');\n            if (stroke && stroke.match(/^url\\(#.*\\)$/)) {\n                elt.style['stroke-linejoin'] = 'round';\n                elt.style['stroke-linecap'] = 'round';\n            }\n        }\n    }\n\n    /**\n     * Transform the measurements of the SVG.\n     * In Scratch 2.0, SVGs are drawn without respect to the width,\n     * height, and viewBox attribute on the tag. The exporter\n     * does output these properties - but they appear to be incorrect often.\n     * To address the incorrect measurements, we append the DOM to the\n     * document, and then use SVG's native `getBBox` to find the real\n     * drawn dimensions. This ensures things drawn in negative dimensions,\n     * outside the given viewBox, etc., are all eventually drawn to the canvas.\n     * I tried to do this several other ways: stripping the width/height/viewBox\n     * attributes and then drawing (Firefox won't draw anything),\n     * or inflating them and then measuring a canvas. But this seems to be\n     * a natural and performant way.\n     */\n    _transformMeasurements () {\n        // Append the SVG dom to the document.\n        // This allows us to use `getBBox` on the page,\n        // which returns the full bounding-box of all drawn SVG\n        // elements, similar to how Scratch 2.0 did measurement.\n        const svgSpot = document.createElement('span');\n        // Since we're adding user-provided SVG to document.body,\n        // sanitizing is required. This should not affect bounding box calculation.\n        // outerHTML is attribute of Element (and not HTMLElement), so use it instead of\n        // calling serializer or toString()\n        // NOTE: this._svgTag remains untouched!\n        const rawValue = this._svgTag.outerHTML;\n        const sanitizedValue = DOMPurify.sanitize(rawValue, {\n            // Use SVG profile (no HTML elements)\n            USE_PROFILES: {svg: true},\n            // Remove some tags that Scratch does not use.\n            FORBID_TAGS: ['a', 'audio', 'canvas', 'video'],\n            // Allow data URI in image tags (e.g. SVGs converted from bitmap)\n            ADD_DATA_URI_TAGS: ['image']\n        });\n        let bbox;\n        try {\n            // Insert sanitized value.\n            svgSpot.innerHTML = sanitizedValue;\n            document.body.appendChild(svgSpot);\n            // Take the bounding box. We have to get elements via svgSpot\n            // because we added it via innerHTML.\n            bbox = svgSpot.children[0].getBBox();\n        } finally {\n            // Always destroy the element, even if, for example, getBBox throws.\n            document.body.removeChild(svgSpot);\n        }\n\n        // Enlarge the bbox from the largest found stroke width\n        // This may have false-positives, but at least the bbox will always\n        // contain the full graphic including strokes.\n        // If the width or height is zero however, don't enlarge since\n        // they won't have a stroke width that needs to be enlarged.\n        let halfStrokeWidth;\n        if (bbox.width === 0 || bbox.height === 0) {\n            halfStrokeWidth = 0;\n        } else {\n            halfStrokeWidth = this._findLargestStrokeWidth(this._svgTag) / 2;\n        }\n        const width = bbox.width + (halfStrokeWidth * 2);\n        const height = bbox.height + (halfStrokeWidth * 2);\n        const x = bbox.x - halfStrokeWidth;\n        const y = bbox.y - halfStrokeWidth;\n\n        // Set the correct measurements on the SVG tag\n        this._svgTag.setAttribute('width', width);\n        this._svgTag.setAttribute('height', height);\n        this._svgTag.setAttribute('viewBox',\n            `${x} ${y} ${width} ${height}`);\n    }\n\n    /**\n     * Serialize the active SVG DOM to a string.\n     * @param {?boolean} shouldInjectFonts True if fonts should be included in the SVG as\n     *     base64 data.\n     * @returns {string} String representing current SVG data.\n     */\n    toString (shouldInjectFonts) {\n        const serializer = new XMLSerializer();\n        let string = serializer.serializeToString(this._svgDom);\n        if (shouldInjectFonts) {\n            string = inlineSvgFonts(string);\n        }\n        return string;\n    }\n\n    /**\n     * Synchronously draw the loaded SVG to this renderer's `canvas`.\n     * @param {number} [scale] - Optionally, also scale the image by this factor.\n     */\n    draw (scale) {\n        if (!this.loaded) throw new Error('SVG image has not finished loading');\n        this._drawFromImage(scale);\n    }\n\n    /**\n     * Asynchronously draw the (possibly non-loaded) SVG to a canvas.\n     * @param {number} [scale] - Optionally, also scale the image by this factor.\n     * @param {Function} [onFinish] - An optional callback to call when the draw operation is complete.\n     * @deprecated Use the `loadSVG` and public `draw` method instead.\n     */\n    _draw (scale, onFinish) {\n        // Convert the SVG text to an Image, and then draw it to the canvas.\n        if (this._cachedImage === null) {\n            this._createSVGImage(() => {\n                this._drawFromImage(scale);\n                onFinish();\n            });\n        } else {\n            this._drawFromImage(scale);\n            onFinish();\n        }\n    }\n\n    /**\n     * Draw to the canvas from a loaded image element.\n     * @param {number} [scale] - Optionally, also scale the image by this factor.\n     **/\n    _drawFromImage (scale) {\n        if (this._cachedImage === null) return;\n\n        const ratio = Number.isFinite(scale) ? scale : 1;\n        const bbox = this._measurements;\n        this._canvas.width = bbox.width * ratio;\n        this._canvas.height = bbox.height * ratio;\n        // Even if the canvas at the current scale has a nonzero size, the image's dimensions are floored pre-scaling.\n        // e.g. if an image has a width of 0.4 and is being rendered at 3x scale, the canvas will have a width of 1, but\n        // the image's width will be rounded down to 0 on some browsers (Firefox) prior to being drawn at that scale.\n        if (\n            this._canvas.width <= 0 ||\n            this._canvas.height <= 0 ||\n            this._cachedImage.naturalWidth <= 0 ||\n            this._cachedImage.naturalHeight <= 0\n        ) return;\n        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        this._context.scale(ratio, ratio);\n        this._context.drawImage(this._cachedImage, 0, 0);\n        // Reset the canvas transform after drawing.\n        this._context.setTransform(1, 0, 0, 1, 0, 0);\n        // Set the CSS style of the canvas to the actual measurements.\n        this._canvas.style.width = bbox.width;\n        this._canvas.style.height = bbox.height;\n    }\n}\n\nmodule.exports = SvgRenderer;\n"], "filenames": [".travis.yml", "package.json", "src/playground/index.html", "src/svg-renderer.js"], "buggy_code_start_loc": [6, 24, 29, 0], "buggy_code_end_loc": [36, 24, 96, 379], "fixing_code_start_loc": [6, 25, 30, 1], "fixing_code_end_loc": [60, 26, 113, 391], "type": "CWE-79", "message": "This affects the package scratch-svg-renderer before 0.2.0-prerelease.20201019174008. The loadString function does not escape SVG properly, which can be used to inject arbitrary elements into the DOM via the _transformMeasurements function.", "other": {"cve": {"id": "CVE-2020-7750", "sourceIdentifier": "report@snyk.io", "published": "2020-10-21T17:15:13.343", "lastModified": "2020-12-02T20:24:12.180", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package scratch-svg-renderer before 0.2.0-prerelease.20201019174008. The loadString function does not escape SVG properly, which can be used to inject arbitrary elements into the DOM via the _transformMeasurements function."}, {"lang": "es", "value": "Esto afecta al paquete scratch-svg-renderer versiones anteriores a 0.2.0-prerelease.20201019174008.&#xa0;La funci\u00f3n loadString no escapa un SVG apropiadamente, que se puede usar para inyectar elementos arbitrarios en el DOM por medio de la funci\u00f3n _transformMeasurements"}], "metrics": {"cvssMetricV31": [{"source": "report@snyk.io", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:-:*:*:*:node.js:*:*", "matchCriteriaId": "192AC43C-F490-4856-9353-E355CDE5BD7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease1515799461:*:*:*:node.js:*:*", "matchCriteriaId": "5D0FB72A-A92D-4FD6-BC7A-5823DA4B38AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease1515800444:*:*:*:node.js:*:*", "matchCriteriaId": "E95A2901-3F62-4CF5-BD8E-E217B30431FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180117145116:*:*:*:node.js:*:*", "matchCriteriaId": "848A3555-42CC-42F2-8A5B-062221EEBB74"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180117210827:*:*:*:node.js:*:*", "matchCriteriaId": "848989DC-B98D-45A6-B07E-4B36551C3C88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180118201049:*:*:*:node.js:*:*", "matchCriteriaId": "6A0082CE-9188-44BC-B095-8C4CBF76B98D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180118201241:*:*:*:node.js:*:*", "matchCriteriaId": "9AE436DB-3864-448B-9938-9B1EF8850A4A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180118224509:*:*:*:node.js:*:*", "matchCriteriaId": "77C297C6-B978-40CC-BAC5-143FFD8D0755"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180124043252:*:*:*:node.js:*:*", "matchCriteriaId": "94DD0466-94D9-42ED-9785-CFCF0090B3E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180124054052:*:*:*:node.js:*:*", "matchCriteriaId": "3E3DD9CD-99D7-4CAB-98FA-3A357ADECAE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180210005926:*:*:*:node.js:*:*", "matchCriteriaId": "0B545B9E-FA46-4DC4-858E-31285B9CB3A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180329174139:*:*:*:node.js:*:*", "matchCriteriaId": "8DDA38C9-7456-4A0B-B6EC-504C36BCC6C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180423193917:*:*:*:node.js:*:*", "matchCriteriaId": "70278C13-07BE-4019-AD14-E6204C16E4C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180508170432:*:*:*:node.js:*:*", "matchCriteriaId": "EE8B9097-99FE-4211-BF5B-F77E2B5CADA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180510171850:*:*:*:node.js:*:*", "matchCriteriaId": "15BE17EB-1722-42AF-B9E8-BDC73D582016"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180510181711:*:*:*:node.js:*:*", "matchCriteriaId": "25233AA5-3300-49D3-AD84-49000344CCD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180511144653:*:*:*:node.js:*:*", "matchCriteriaId": "CFBAEECE-6025-4333-908B-C6A6DE82509D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180514170126:*:*:*:node.js:*:*", "matchCriteriaId": "CEBCA932-520B-4FA8-A6D7-A0D40264FFF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180521194642:*:*:*:node.js:*:*", "matchCriteriaId": "FDFE2080-4C95-48F4-8A2B-24A082620CFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180524204036:*:*:*:node.js:*:*", "matchCriteriaId": "75B63E62-33E1-489E-974F-5E8AF4654C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180524210316:*:*:*:node.js:*:*", "matchCriteriaId": "38D88F16-105C-4E7C-9F28-6D1BB6779DED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180531205843:*:*:*:node.js:*:*", "matchCriteriaId": "4AF756CD-8292-4350-9A95-AFC5166C435E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180531214630:*:*:*:node.js:*:*", "matchCriteriaId": "B424A67D-8FAE-4CB7-B477-7373D5BD2BEC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.1.0:prerelease20180605140533:*:*:*:node.js:*:*", "matchCriteriaId": "CBFD850F-9E36-4E3C-94B2-ABDE7C376F03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20180605154326:*:*:*:node.js:*:*", "matchCriteriaId": "6823F1AB-5F90-4427-9841-7DE197558238"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20180607141644:*:*:*:node.js:*:*", "matchCriteriaId": "3F455F7B-2D52-454E-B487-7890A1500292"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20180613184320:*:*:*:node.js:*:*", "matchCriteriaId": "11A71FC3-1909-4DF1-A19C-7B81F8B9C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20180618172917:*:*:*:node.js:*:*", "matchCriteriaId": "0BE8A461-6CBB-44BC-B77D-6031DA22AF52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20180711180400:*:*:*:node.js:*:*", "matchCriteriaId": "5C372C00-AAA5-49DB-9713-1831B73ECD65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20180712223402:*:*:*:node.js:*:*", "matchCriteriaId": "626A4A2D-D930-4865-84C1-5A679E7D4C0E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20180817005452:*:*:*:node.js:*:*", "matchCriteriaId": "C7401940-8651-424B-AE0E-C74E08B1171E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20180821210632:*:*:*:node.js:*:*", "matchCriteriaId": "EDBAA7BB-24DA-4910-8991-4D76B3C01735"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20180907141232:*:*:*:node.js:*:*", "matchCriteriaId": "710843B0-47BB-47D3-89F1-42036F678E37"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20180926143036:*:*:*:node.js:*:*", "matchCriteriaId": "892707F9-9957-4C11-998B-7DA4929ECE72"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20181017193458:*:*:*:node.js:*:*", "matchCriteriaId": "8B50A793-0C54-484E-960D-709A7E12EB39"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20181024192149:*:*:*:node.js:*:*", "matchCriteriaId": "4003EE4F-3B07-4B2E-B427-B3EACA852EDA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20181101210634:*:*:*:node.js:*:*", "matchCriteriaId": "DD9FB711-84CF-442E-8F81-26DCD522EEEE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20181126212715:*:*:*:node.js:*:*", "matchCriteriaId": "836A41C9-50EB-4AEF-B570-7EDFFEA2FB2F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20181212190400:*:*:*:node.js:*:*", "matchCriteriaId": "22795705-F4B8-4150-B51F-4E1AD37EECF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20181212222326:*:*:*:node.js:*:*", "matchCriteriaId": "CF2E8277-1BC4-43DB-BDC9-7E9BB4A010AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20181212230607:*:*:*:node.js:*:*", "matchCriteriaId": "6F7E6BFE-4C09-4C4E-A76B-10298E5084D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20181213165142:*:*:*:node.js:*:*", "matchCriteriaId": "65446C2E-05B0-4C8F-BC81-7F51D0FF6047"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20181213192400:*:*:*:node.js:*:*", "matchCriteriaId": "6DF3BFD1-F42A-4372-B61F-8FCF2E03CD81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20181218153528:*:*:*:node.js:*:*", "matchCriteriaId": "6DC85B93-4CED-4FA5-8543-994A1535F215"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20181220183040:*:*:*:node.js:*:*", "matchCriteriaId": "82C07B2C-F92E-4070-9F23-E7873EEE57E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190109201344:*:*:*:node.js:*:*", "matchCriteriaId": "BCE4B743-038D-4F17-A6CF-C3CD81FAA9DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190110205335:*:*:*:node.js:*:*", "matchCriteriaId": "91F3AEEF-8DFA-4CC0-A6E7-E13AB3006823"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190125192231:*:*:*:node.js:*:*", "matchCriteriaId": "D00D9FB9-14DF-4C05-86C9-7772CFD6DEDC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190304180800:*:*:*:node.js:*:*", "matchCriteriaId": "7442C836-8AF0-40CD-B1AE-7A2B86DF0828"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190329052730:*:*:*:node.js:*:*", "matchCriteriaId": "6AF077C8-F782-40A5-A62C-CDE10FD2375F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190419183947:*:*:*:node.js:*:*", "matchCriteriaId": "8CDADB43-B8E7-4344-BB6D-684C0899498D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190521170426:*:*:*:node.js:*:*", "matchCriteriaId": "18E0068F-FFBD-4F3B-AE5C-0A9DC6E3651A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190523193400:*:*:*:node.js:*:*", "matchCriteriaId": "1143D20A-3EBF-4653-9B23-75A6EB5073D2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190715144718:*:*:*:node.js:*:*", "matchCriteriaId": "AF02BAE1-D068-4C30-877A-A2C1A84E769D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190715153806:*:*:*:node.js:*:*", "matchCriteriaId": "579173E1-E5BA-4016-AADE-C2CD3AF817EB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190820171249:*:*:*:node.js:*:*", "matchCriteriaId": "A5F378D3-867D-40EF-84AE-C35DFC004DF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190822193232:*:*:*:node.js:*:*", "matchCriteriaId": "439A32E8-6274-4DA1-A41A-89EFDDADE24B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20190822202608:*:*:*:node.js:*:*", "matchCriteriaId": "ED60F8D6-8CF3-4294-8CA5-4076E2DD58C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20191031221353:*:*:*:node.js:*:*", "matchCriteriaId": "3FCFB47D-FDD8-49B2-A5F5-1A1CB331F269"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20191104164753:*:*:*:node.js:*:*", "matchCriteriaId": "F6A30033-5AD1-4099-AE22-0ECDFCECAF16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20191217211338:*:*:*:node.js:*:*", "matchCriteriaId": "47B51651-08B0-4C39-B0EB-3A66B78D4F68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20200103191258:*:*:*:node.js:*:*", "matchCriteriaId": "AFDC02E6-0121-49D1-ADF3-4921D4C17C71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20200103211543:*:*:*:node.js:*:*", "matchCriteriaId": "366A1643-1996-4382-A0E0-DF098A97EA9F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20200109070519:*:*:*:node.js:*:*", "matchCriteriaId": "0386F9BB-D321-40FB-B8D4-483445156D93"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20200205003215:*:*:*:node.js:*:*", "matchCriteriaId": "6ADAA82D-5D44-40CC-AA72-CA8ED4C8DDE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20200205003400:*:*:*:node.js:*:*", "matchCriteriaId": "ACCB7F4D-BEF3-4B37-A4EF-C5EEB110FB09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20200507183648:*:*:*:node.js:*:*", "matchCriteriaId": "C65011F7-C643-47F9-9325-8BEC32AB6026"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20200604203226:*:*:*:node.js:*:*", "matchCriteriaId": "92A9067A-7195-4B00-8723-F98DA715CAC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20200609210443:*:*:*:node.js:*:*", "matchCriteriaId": "4E9439F1-C246-410A-B836-9213C7B35812"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20200610220938:*:*:*:node.js:*:*", "matchCriteriaId": "426737F9-5AB5-493D-B78F-01D163C35496"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201008203328:*:*:*:node.js:*:*", "matchCriteriaId": "6CC1FF73-537B-40FC-A54C-C2670FA1CAFF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201009194722:*:*:*:node.js:*:*", "matchCriteriaId": "C3DF1FC7-CEDE-458D-824A-1452616F5DDB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201009195807:*:*:*:node.js:*:*", "matchCriteriaId": "68421FD0-2A29-44DF-8D4A-FB14F702C975"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201009202925:*:*:*:node.js:*:*", "matchCriteriaId": "83571CE2-6A30-4750-829D-6BC5A7E33EBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201009211507:*:*:*:node.js:*:*", "matchCriteriaId": "67DAD572-29F0-4905-9C52-35A1C9DE67E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201011114003:*:*:*:node.js:*:*", "matchCriteriaId": "E665FBFC-78B5-490E-9D07-8F89B8E9ADB8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201012151417:*:*:*:node.js:*:*", "matchCriteriaId": "7471CE1D-9B64-4C6E-A5BE-E3E19BE5D27E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201013123302:*:*:*:node.js:*:*", "matchCriteriaId": "B4F4FA13-7DB9-4B1F-91C2-8AC61A8F9D78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201013184332:*:*:*:node.js:*:*", "matchCriteriaId": "BE010383-5FD4-42D2-B8CD-DC4D2DB7CB4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201014105708:*:*:*:node.js:*:*", "matchCriteriaId": "B421BB8C-B2F8-453E-9943-2C9821769458"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201014130133:*:*:*:node.js:*:*", "matchCriteriaId": "3DB88248-1685-4D9F-971A-1436A1890AB8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201014145347:*:*:*:node.js:*:*", "matchCriteriaId": "EC6E0014-DDAE-48FD-B02B-6EF7051B4E14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201015122106:*:*:*:node.js:*:*", "matchCriteriaId": "23417905-DDDE-4610-BA2A-CC884B3A6218"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201015135047:*:*:*:node.js:*:*", "matchCriteriaId": "AEB36616-6162-4D1F-A066-EF6E54A8C5C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201015194358:*:*:*:node.js:*:*", "matchCriteriaId": "76FA6747-EF93-4B03-A9A3-344C64FD7FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:scratch-svg-renderer:0.2.0:prerelease20201016121710:*:*:*:node.js:*:*", "matchCriteriaId": "407A029F-01F3-4291-ABA1-3F737B8D7CCC"}]}]}], "references": [{"url": "https://github.com/LLK/scratch-svg-renderer/commit/9ebf57588aa596c4fa3bb64209e10ade395aee90", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-SCRATCHSVGRENDERER-1020497", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LLK/scratch-svg-renderer/commit/9ebf57588aa596c4fa3bb64209e10ade395aee90"}}