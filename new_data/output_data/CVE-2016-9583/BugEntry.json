{"buggy_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Primitive Types\n *\n * $Id$\n */\n\n#ifndef JAS_TYPES_H\n#define JAS_TYPES_H\n\n/* The configuration header file should be included first. */\n#include <jasper/jas_config.h>\n\n#if !defined(JAS_CONFIGURE)\n\n#if defined(WIN32) || defined(JAS_HAVE_WINDOWS_H)\n// THIS SHOULD NO LONGER BE NEEDED SINCE MSVC SUPPORTS LONG LONG.\n/*\n   We are dealing with Microsoft Windows and most likely Microsoft\n   Visual C (MSVC).  (Heaven help us.)  Sadly, MSVC does not correctly\n   define some of the standard types specified in ISO/IEC 9899:1999.\n   In particular, it does not define the \"long long\" and \"unsigned long\n   long\" types.  So, we work around this problem by using the \"INT64\"\n   and \"UINT64\" types that are defined in the header file \"windows.h\".\n */\n#include <windows.h>\n//#undef longlong\n//#define\tlonglong\tINT64\n//#undef ulonglong\n//#define\tulonglong\tUINT64\n#endif\n\n#endif\n\n/* Note: The immediately following header files should eventually be removed. */\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#if defined(JAS_HAVE_SYS_TYPES_H)\n#include <sys/types.h>\n#endif\n\n#define jas_uchar unsigned char\n#define jas_uint unsigned int\n#define jas_ulong unsigned long\n#define jas_longlong long long\n#define jas_ulonglong unsigned long long\n\n/* The below macro is intended to be used for type casts.  By using this\n  macro, type casts can be easily located in the source code with\n  tools like \"grep\". */\n#define\tJAS_CAST(t, e) \\\n\t((t) (e))\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Tier-2 Coding Library\n *\n * $Id$\n */\n\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_malloc.h\"\n\n#include \"jpc_cs.h\"\n#include \"jpc_t2cod.h\"\n#include \"jpc_math.h\"\n\nstatic int jpc_pi_nextlrcp(jpc_pi_t *pi);\nstatic int jpc_pi_nextrlcp(jpc_pi_t *pi);\nstatic int jpc_pi_nextrpcl(jpc_pi_t *pi);\nstatic int jpc_pi_nextpcrl(jpc_pi_t *pi);\nstatic int jpc_pi_nextcprl(jpc_pi_t *pi);\n\nint jpc_pi_next(jpc_pi_t *pi)\n{\n\tjpc_pchg_t *pchg;\n\tint ret;\n\n\tfor (;;) {\n\n\t\tpi->valid = false;\n\n\t\tif (!pi->pchg) {\n\t\t\t++pi->pchgno;\n\t\t\tpi->compno = 0;\n\t\t\tpi->rlvlno = 0;\n\t\t\tpi->prcno = 0;\n\t\t\tpi->lyrno = 0;\n\t\t\tpi->prgvolfirst = true;\n\t\t\tif (pi->pchgno < jpc_pchglist_numpchgs(pi->pchglist)) {\n\t\t\t\tpi->pchg = jpc_pchglist_get(pi->pchglist, pi->pchgno);\n\t\t\t} else if (pi->pchgno == jpc_pchglist_numpchgs(pi->pchglist)) {\n\t\t\t\tpi->pchg = &pi->defaultpchg;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tpchg = pi->pchg;\n\t\tswitch (pchg->prgord) {\n\t\tcase JPC_COD_LRCPPRG:\n\t\t\tret = jpc_pi_nextlrcp(pi);\n\t\t\tbreak;\n\t\tcase JPC_COD_RLCPPRG:\n\t\t\tret = jpc_pi_nextrlcp(pi);\n\t\t\tbreak;\n\t\tcase JPC_COD_RPCLPRG:\n\t\t\tret = jpc_pi_nextrpcl(pi);\n\t\t\tbreak;\n\t\tcase JPC_COD_PCRLPRG:\n\t\t\tret = jpc_pi_nextpcrl(pi);\n\t\t\tbreak;\n\t\tcase JPC_COD_CPRLPRG:\n\t\t\tret = jpc_pi_nextcprl(pi);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ret) {\n\t\t\tpi->valid = true;\n\t\t\t++pi->pktno;\n\t\t\treturn 0;\n\t\t}\n\t\tpi->pchg = 0;\n\t}\n}\n\nstatic int jpc_pi_nextlrcp(register jpc_pi_t *pi)\n{\n\tjpc_pchg_t *pchg;\n\tint *prclyrno;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = false;\n\t}\n\n\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs && pi->lyrno <\n\t  JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pi->maxrlvls &&\n\t\t  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno) {\n\t\t\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t\t\t  &pi->picomps[pi->compno]; pi->compno < pi->numcomps\n\t\t\t  && pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,\n\t\t\t  ++pi->picomp) {\n\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\tfor (pi->prcno = 0, prclyrno =\n\t\t\t\t  pi->pirlvl->prclyrnos; pi->prcno <\n\t\t\t\t  pi->pirlvl->numprcs; ++pi->prcno,\n\t\t\t\t  ++prclyrno) {\n\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t*prclyrno = pi->lyrno;\n\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\nskip:\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int jpc_pi_nextrlcp(register jpc_pi_t *pi)\n{\n\tjpc_pchg_t *pchg;\n\tint *prclyrno;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pi->maxrlvls &&\n\t  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno) {\n\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs && pi->lyrno <\n\t\t  JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t\t\t  &pi->picomps[pi->compno]; pi->compno < pi->numcomps &&\n\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno, ++pi->picomp) {\n\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\tfor (pi->prcno = 0, prclyrno = pi->pirlvl->prclyrnos;\n\t\t\t\t  pi->prcno < pi->pirlvl->numprcs; ++pi->prcno, ++prclyrno) {\n\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t*prclyrno = pi->lyrno;\n\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\nskip:\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int jpc_pi_nextrpcl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tint xstep;\n\tint ystep;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->xstep = 0;\n\t\tpi->ystep = 0;\n\t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t\t  ++compno, ++picomp) {\n\t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\t\txstep = picomp->hsamp * (1 << (pirlvl->prcwidthexpn +\n\t\t\t\t  picomp->numrlvls - rlvlno - 1));\n\t\t\t\tystep = picomp->vsamp * (1 << (pirlvl->prcheightexpn +\n\t\t\t\t  picomp->numrlvls - rlvlno - 1));\n\t\t\t\tpi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);\n\t\t\t\tpi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);\n\t\t\t}\n\t\t}\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pchg->rlvlnoend &&\n\t  pi->rlvlno < pi->maxrlvls; ++pi->rlvlno) {\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend; pi->y +=\n\t\t  pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend; pi->x +=\n\t\t\t  pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->compno = pchg->compnostart,\n\t\t\t\t  pi->picomp = &pi->picomps[pi->compno];\n\t\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno <\n\t\t\t\t  pi->numcomps; ++pi->compno, ++pi->picomp) {\n\t\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx)))\n\t\t\t\t\t  || !(pi->x % (1 << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy)))\n\t\t\t\t\t  || !(pi->y % (1 << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n\n\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int jpc_pi_nextpcrl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tint xstep;\n\tint ystep;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->xstep = 0;\n\t\tpi->ystep = 0;\n\t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t\t  ++compno, ++picomp) {\n\t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\t\txstep = picomp->hsamp * (1 <<\n\t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls -\n\t\t\t\t  rlvlno - 1));\n\t\t\t\tystep = picomp->vsamp * (1 <<\n\t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls -\n\t\t\t\t  rlvlno - 1));\n\t\t\t\tpi->xstep = (!pi->xstep) ? xstep :\n\t\t\t\t  JAS_MIN(pi->xstep, xstep);\n\t\t\t\tpi->ystep = (!pi->ystep) ? ystep :\n\t\t\t\t  JAS_MIN(pi->ystep, ystep);\n\t\t\t}\n\t\t}\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->y = pi->ystart; pi->y < pi->yend; pi->y += pi->ystep -\n\t  (pi->y % pi->ystep)) {\n\t\tfor (pi->x = pi->xstart; pi->x < pi->xend; pi->x += pi->xstep -\n\t\t  (pi->x % pi->xstep)) {\n\t\t\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t\t\t  &pi->picomps[pi->compno]; pi->compno < pi->numcomps\n\t\t\t  && pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,\n\t\t\t  ++pi->picomp) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls &&\n\t\t\t\t  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno,\n\t\t\t\t  ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&\n\t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int jpc_pi_nextcprl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind *\n\t\t\t\t\t\t  pi->pirlvl->numhprcs +\n\t\t\t\t\t\t  prchind;\n\t\t\t\t\t\tassert(pi->prcno <\n\t\t\t\t\t\t  pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void pirlvl_destroy(jpc_pirlvl_t *rlvl)\n{\n\tif (rlvl->prclyrnos) {\n\t\tjas_free(rlvl->prclyrnos);\n\t}\n}\n\nstatic void jpc_picomp_destroy(jpc_picomp_t *picomp)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tif (picomp->pirlvls) {\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpirlvl_destroy(pirlvl);\n\t\t}\n\t\tjas_free(picomp->pirlvls);\n\t}\n}\n\nvoid jpc_pi_destroy(jpc_pi_t *pi)\n{\n\tjpc_picomp_t *picomp;\n\tint compno;\n\tif (pi->picomps) {\n\t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t\t  ++compno, ++picomp) {\n\t\t\tjpc_picomp_destroy(picomp);\n\t\t}\n\t\tjas_free(pi->picomps);\n\t}\n\tif (pi->pchglist) {\n\t\tjpc_pchglist_destroy(pi->pchglist);\n\t}\n\tjas_free(pi);\n}\n\njpc_pi_t *jpc_pi_create0()\n{\n\tjpc_pi_t *pi;\n\tif (!(pi = jas_malloc(sizeof(jpc_pi_t)))) {\n\t\treturn 0;\n\t}\n\tpi->picomps = 0;\n\tpi->pchgno = 0;\n\tif (!(pi->pchglist = jpc_pchglist_create())) {\n\t\tjas_free(pi);\n\t\treturn 0;\n\t}\n\treturn pi;\n}\n\nint jpc_pi_addpchg(jpc_pi_t *pi, jpc_pocpchg_t *pchg)\n{\n\treturn jpc_pchglist_insert(pi->pchglist, -1, pchg);\n}\n\njpc_pchglist_t *jpc_pchglist_create()\n{\n\tjpc_pchglist_t *pchglist;\n\tif (!(pchglist = jas_malloc(sizeof(jpc_pchglist_t)))) {\n\t\treturn 0;\n\t}\n\tpchglist->numpchgs = 0;\n\tpchglist->maxpchgs = 0;\n\tpchglist->pchgs = 0;\n\treturn pchglist;\n}\n\nint jpc_pchglist_insert(jpc_pchglist_t *pchglist, int pchgno, jpc_pchg_t *pchg)\n{\n\tint i;\n\tint newmaxpchgs;\n\tjpc_pchg_t **newpchgs;\n\tif (pchgno < 0) {\n\t\tpchgno = pchglist->numpchgs;\n\t}\n\tif (pchglist->numpchgs >= pchglist->maxpchgs) {\n\t\tnewmaxpchgs = pchglist->maxpchgs + 128;\n\t\tif (!(newpchgs = jas_realloc2(pchglist->pchgs, newmaxpchgs,\n\t\t  sizeof(jpc_pchg_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tpchglist->maxpchgs = newmaxpchgs;\n\t\tpchglist->pchgs = newpchgs;\n\t}\n\tfor (i = pchglist->numpchgs; i > pchgno; --i) {\n\t\tpchglist->pchgs[i] = pchglist->pchgs[i - 1];\n\t}\n\tpchglist->pchgs[pchgno] = pchg;\n\t++pchglist->numpchgs;\n\treturn 0;\n}\n\njpc_pchg_t *jpc_pchglist_remove(jpc_pchglist_t *pchglist, int pchgno)\n{\n\tint i;\n\tjpc_pchg_t *pchg;\n\tassert(pchgno < pchglist->numpchgs);\n\tpchg = pchglist->pchgs[pchgno];\n\tfor (i = pchgno + 1; i < pchglist->numpchgs; ++i) {\n\t\tpchglist->pchgs[i - 1] = pchglist->pchgs[i];\n\t}\n\t--pchglist->numpchgs;\n\treturn pchg;\n}\n\njpc_pchg_t *jpc_pchg_copy(jpc_pchg_t *pchg)\n{\n\tjpc_pchg_t *newpchg;\n\tif (!(newpchg = jas_malloc(sizeof(jpc_pchg_t)))) {\n\t\treturn 0;\n\t}\n\t*newpchg = *pchg;\n\treturn newpchg;\n}\n\njpc_pchglist_t *jpc_pchglist_copy(jpc_pchglist_t *pchglist)\n{\n\tjpc_pchglist_t *newpchglist;\n\tjpc_pchg_t *newpchg;\n\tint pchgno;\n\tif (!(newpchglist = jpc_pchglist_create())) {\n\t\treturn 0;\n\t}\n\tfor (pchgno = 0; pchgno < pchglist->numpchgs; ++pchgno) {\n\t\tif (!(newpchg = jpc_pchg_copy(pchglist->pchgs[pchgno])) ||\n\t\t  jpc_pchglist_insert(newpchglist, -1, newpchg)) {\n\t\t\tjpc_pchglist_destroy(newpchglist);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn newpchglist;\n}\n\nvoid jpc_pchglist_destroy(jpc_pchglist_t *pchglist)\n{\n\tint pchgno;\n\tif (pchglist->pchgs) {\n\t\tfor (pchgno = 0; pchgno < pchglist->numpchgs; ++pchgno) {\n\t\t\tjpc_pchg_destroy(pchglist->pchgs[pchgno]);\n\t\t}\n\t\tjas_free(pchglist->pchgs);\n\t}\n\tjas_free(pchglist);\n}\n\nvoid jpc_pchg_destroy(jpc_pchg_t *pchg)\n{\n\tjas_free(pchg);\n}\n\njpc_pchg_t *jpc_pchglist_get(jpc_pchglist_t *pchglist, int pchgno)\n{\n\treturn pchglist->pchgs[pchgno];\n}\n\nint jpc_pchglist_numpchgs(jpc_pchglist_t *pchglist)\n{\n\treturn pchglist->numpchgs;\n}\n\nint jpc_pi_init(jpc_pi_t *pi)\n{\n\tint compno;\n\tint rlvlno;\n\tint prcno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tint *prclyrno;\n\n\tpi->prgvolfirst = 0;\n\tpi->valid = 0;\n\tpi->pktno = -1;\n\tpi->pchgno = -1;\n\tpi->pchg = 0;\n\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t  ++compno, ++picomp) {\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Tier 2 Decoder\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_fix.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_bs.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mqdec.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1cod.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nlong jpc_dec_lookahead(jas_stream_t *in);\nstatic int jpc_getcommacode(jpc_bitstream_t *in);\nstatic int jpc_getnumnewpasses(jpc_bitstream_t *in);\nstatic int jpc_dec_decodepkt(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in, int compno, int lvlno,\n  int prcno, int lyrno);\n\n/******************************************************************************\\\n* Code.\n\\******************************************************************************/\n\nstatic int jpc_getcommacode(jpc_bitstream_t *in)\n{\n\tint n;\n\tint v;\n\n\tn = 0;\n\tfor (;;) {\n\t\tif ((v = jpc_bitstream_getbit(in)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_bitstream_eof(in)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!v) {\n\t\t\tbreak;\n\t\t}\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\nstatic int jpc_getnumnewpasses(jpc_bitstream_t *in)\n{\n\tint n;\n\n\tif ((n = jpc_bitstream_getbit(in)) > 0) {\n\t\tif ((n = jpc_bitstream_getbit(in)) > 0) {\n\t\t\tif ((n = jpc_bitstream_getbits(in, 2)) == 3) {\n\t\t\t\tif ((n = jpc_bitstream_getbits(in, 5)) == 31) {\n\t\t\t\t\tif ((n = jpc_bitstream_getbits(in, 7)) >= 0) {\n\t\t\t\t\t\tn += 36 + 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (n >= 0) {\n\t\t\t\t\tn += 5 + 1;\n\t\t\t\t}\n\t\t\t} else if (n >= 0) {\n\t\t\t\tn += 2 + 1;\n\t\t\t}\n\t\t} else if (!n) {\n\t\t\tn += 2;\n\t\t}\n\t} else if (!n) {\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\nstatic int jpc_dec_decodepkt(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in, int compno, int rlvlno,\n  int prcno, int lyrno)\n{\n\tjpc_bitstream_t *inb;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_cblk_t *cblk;\n\tint n;\n\tint m;\n\tint i;\n\tjpc_tagtreenode_t *leaf;\n\tint included;\n\tint ret;\n\tint numnewpasses;\n\tjpc_dec_seg_t *seg;\n\tint len;\n\tint present;\n\tint savenumnewpasses;\n\tint mycounter;\n\tjpc_ms_t *ms;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cp_t *cp;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint usedcblkcnt;\n\tint cblkno;\n\tuint_fast32_t bodylen;\n\tbool discard;\n\tint passno;\n\tint maxpasses;\n\tint hdrlen;\n\tint hdroffstart;\n\tint hdroffend;\n\n\t/* Avoid compiler warning about possible use of uninitialized\n\t  variable. */\n\tbodylen = 0;\n\n\tdiscard = (lyrno >= dec->maxlyrs);\n\n\ttile = dec->curtile;\n\tcp = tile->cp;\n\tccp = &cp->ccps[compno];\n\n\t/*\n\t * Decode the packet header.\n\t */\n\n\t/* Decode the SOP marker segment if present. */\n\tif (cp->csty & JPC_COD_SOP) {\n\t\tif (jpc_dec_lookahead(in) == JPC_MS_SOP) {\n\t\t\tif (!(ms = jpc_getms(in, dec->cstate))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_SOP) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing SOP marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\nhdroffstart = jas_stream_getrwcount(pkthdrstream);\n\n\tif (!(inb = jpc_bitstream_sopen(pkthdrstream, \"r\"))) {\n\t\treturn -1;\n\t}\n\n\tif ((present = jpc_bitstream_getbit(inb)) < 0) {\n\t\treturn 1;\n\t}\n\tJAS_DBGLOG(10, (\"\\n\", present));\n\tJAS_DBGLOG(10, (\"present=%d \", present));\n\n\t/* Is the packet non-empty? */\n\tif (present) {\n\t\t/* The packet is non-empty. */\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tbodylen = 0;\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tusedcblkcnt = 0;\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\t++usedcblkcnt;\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->incltagtree, usedcblkcnt - 1);\n\t\t\t\t\tif ((included = jpc_tagtree_decode(prc->incltagtree, leaf, lyrno + 1, inb)) < 0) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((included = jpc_bitstream_getbit(inb)) < 0) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"\\n\"));\n\t\t\t\tJAS_DBGLOG(10, (\"included=%d \", included));\n\t\t\t\tif (!included) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\ti = 1;\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->numimsbstagtree, usedcblkcnt - 1);\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\tif ((ret = jpc_tagtree_decode(prc->numimsbstagtree, leaf, i, inb)) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ret) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numimsbs = i - 1;\n\t\t\t\t\tcblk->firstpassno = cblk->numimsbs * 3;\n\t\t\t\t}\n\t\t\t\tif ((numnewpasses = jpc_getnumnewpasses(inb)) < 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"numnewpasses=%d \", numnewpasses));\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\tsavenumnewpasses = numnewpasses;\n\t\t\t\tmycounter = 0;\n\t\t\t\tif (numnewpasses > 0) {\n\t\t\t\t\tif ((m = jpc_getcommacode(inb)) < 0) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numlenbits += m;\n\t\t\t\t\tJAS_DBGLOG(10, (\"increment=%d \", m));\n\t\t\t\t\twhile (numnewpasses > 0) {\n\t\t\t\t\t\tpassno = cblk->firstpassno + cblk->numpasses + mycounter;\n\t/* XXX - the maxpasses is not set precisely but this doesn't matter... */\n\t\t\t\t\t\tmaxpasses = JPC_SEGPASSCNT(passno, cblk->firstpassno, 10000, (ccp->cblkctx & JPC_COX_LAZY) != 0, (ccp->cblkctx & JPC_COX_TERMALL) != 0);\n\t\t\t\t\t\tif (!discard && !seg) {\n\t\t\t\t\t\t\tif (!(seg = jpc_seg_alloc())) {\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjpc_seglist_insert(&cblk->segs, cblk->segs.tail, seg);\n\t\t\t\t\t\t\tif (!cblk->curseg) {\n\t\t\t\t\t\t\t\tcblk->curseg = seg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tseg->passno = passno;\n\t\t\t\t\t\t\tseg->type = JPC_SEGTYPE(seg->passno, cblk->firstpassno, (ccp->cblkctx & JPC_COX_LAZY) != 0);\n\t\t\t\t\t\t\tseg->maxpasses = maxpasses;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn = JAS_MIN(numnewpasses, maxpasses);\n\t\t\t\t\t\tmycounter += n;\n\t\t\t\t\t\tnumnewpasses -= n;\n\t\t\t\t\t\tif ((len = jpc_bitstream_getbits(inb, cblk->numlenbits + jpc_floorlog2(n))) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJAS_DBGLOG(10, (\"len=%d \", len));\n\t\t\t\t\t\tif (!discard) {\n\t\t\t\t\t\t\tseg->lyrno = lyrno;\n\t\t\t\t\t\t\tseg->numpasses += n;\n\t\t\t\t\t\t\tseg->cnt = len;\n\t\t\t\t\t\t\tseg = seg->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbodylen += len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcblk->numpasses += savenumnewpasses;\n\t\t\t}\n\t\t}\n\n\t\tjpc_bitstream_inalign(inb, 0, 0);\n\n\t} else {\n\t\tif (jpc_bitstream_inalign(inb, 0x7f, 0)) {\n\t\t\tjas_eprintf(\"alignment failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tjpc_bitstream_close(inb);\n\n\thdroffend = jas_stream_getrwcount(pkthdrstream);\n\thdrlen = hdroffend - hdroffstart;\n\tif (jas_getdbglevel() >= 5) {\n\t\tjas_eprintf(\"hdrlen=%lu bodylen=%lu \\n\", (unsigned long) hdrlen,\n\t\t  (unsigned long) bodylen);\n\t}\n\n\tif (cp->csty & JPC_COD_EPH) {\n\t\tif (jpc_dec_lookahead(pkthdrstream) == JPC_MS_EPH) {\n\t\t\tif (!(ms = jpc_getms(pkthdrstream, dec->cstate))) {\n\t\t\t\tjas_eprintf(\"cannot get (EPH) marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_EPH) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing EPH marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\n\t/* decode the packet body. */\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjas_eprintf(\"packet body offset=%06ld\\n\", (long) jas_stream_getrwcount(in));\n\t}\n\n\tif (!discard) {\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\twhile (seg) {\n\t\t\t\t\tif (!seg->stream) {\n\t\t\t\t\t\tif (!(seg->stream = jas_stream_memopen(0, 0))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#if 0\njas_eprintf(\"lyrno=%02d, compno=%02d, lvlno=%02d, prcno=%02d, bandno=%02d, cblkno=%02d, passno=%02d numpasses=%02d cnt=%d numbps=%d, numimsbs=%d\\n\", lyrno, compno, rlvlno, prcno, band - rlvl->bands, cblk - prc->cblks, seg->passno, seg->numpasses, seg->cnt, band->numbps, cblk->numimsbs);\n#endif\n\t\t\t\t\tif (seg->cnt > 0) {\n\t\t\t\t\t\tif (jpc_getdata(in, seg->stream, seg->cnt) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tseg->cnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (seg->numpasses >= seg->maxpasses) {\n\t\t\t\t\t\tcblk->curseg = seg->next;\n\t\t\t\t\t}\n\t\t\t\t\tseg = seg->next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (jas_stream_gobble(in, bodylen) != JAS_CAST(int, bodylen)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/********************************************************************************************/\n/********************************************************************************************/\n\nint jpc_dec_decodepkts(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_pi_t *pi;\n\tint ret;\n\n\ttile = dec->curtile;\n\tpi = tile->pi;\n\tfor (;;) {\nif (!tile->pkthdrstream || jas_stream_peekc(tile->pkthdrstream) == EOF) {\n\t\tswitch (jpc_dec_lookahead(in)) {\n\t\tcase JPC_MS_EOC:\n\t\tcase JPC_MS_SOT:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase JPC_MS_SOP:\n\t\tcase JPC_MS_EPH:\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n}\n\t\tif ((ret = jpc_pi_next(pi))) {\n\t\t\treturn ret;\n\t\t}\nif (dec->maxpkts >= 0 && dec->numpkts >= dec->maxpkts) {\n\tjas_eprintf(\"warning: stopping decode prematurely as requested\\n\");\n\treturn 0;\n}\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"packet offset=%08ld prg=%d cmptno=%02d \"\n\t\t\t  \"rlvlno=%02d prcno=%03d lyrno=%02d\\n\", (long)\n\t\t\t  jas_stream_getrwcount(in), jpc_pi_prg(pi), jpc_pi_cmptno(pi),\n\t\t\t  jpc_pi_rlvlno(pi), jpc_pi_prcno(pi), jpc_pi_lyrno(pi));\n\t\t}\n\t\tif (jpc_dec_decodepkt(dec, pkthdrstream, in, jpc_pi_cmptno(pi), jpc_pi_rlvlno(pi),\n\t\t  jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) {\n\t\t\treturn -1;\n\t\t}\n++dec->numpkts;\n\t}\n\n\treturn 0;\n}\n\njpc_pi_t *jpc_dec_pi_create(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_pi_t *pi;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_dec_tcomp_t *tcomp;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tint *prclyrno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (!(pi = jpc_pi_create0())) {\n\t\treturn 0;\n\t}\n\tpi->numcomps = dec->numcomps;\n\tif (!(pi->picomps = jas_alloc2(pi->numcomps, sizeof(jpc_picomp_t)))) {\n\t\tjpc_pi_destroy(pi);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps; ++compno,\n\t  ++picomp) {\n\t\tpicomp->pirlvls = 0;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, picomp = pi->picomps;\n\t  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {\n\t\tpicomp->numrlvls = tcomp->numrlvls;\n\t\tif (!(picomp->pirlvls = jas_alloc2(picomp->numrlvls,\n\t\t  sizeof(jpc_pirlvl_t)))) {\n\t\t\tjpc_pi_destroy(pi);\n\t\t\treturn 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpirlvl->prclyrnos = 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n/* XXX sizeof(long) should be sizeof different type */\n\t\t\tpirlvl->numprcs = rlvl->numprcs;\n\t\t\tif (!(pirlvl->prclyrnos = jas_alloc2(pirlvl->numprcs,\n\t\t\t  sizeof(long)))) {\n\t\t\t\tjpc_pi_destroy(pi);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpi->maxrlvls = 0;\n\tfor (compno = 0, tcomp = tile->tcomps, picomp = pi->picomps, cmpt =\n\t  dec->cmpts; compno < pi->numcomps; ++compno, ++tcomp, ++picomp,\n\t  ++cmpt) {\n\t\tpicomp->hsamp = cmpt->hstep;\n\t\tpicomp->vsamp = cmpt->vstep;\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n\t\t\tpirlvl->prcwidthexpn = rlvl->prcwidthexpn;\n\t\t\tpirlvl->prcheightexpn = rlvl->prcheightexpn;\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t\tpirlvl->numhprcs = rlvl->numhprcs;\n\t\t}\n\t\tif (pi->maxrlvls < tcomp->numrlvls) {\n\t\t\tpi->maxrlvls = tcomp->numrlvls;\n\t\t}\n\t}\n\n\tpi->numlyrs = tile->cp->numlyrs;\n\tpi->xstart = tile->xstart;\n\tpi->ystart = tile->ystart;\n\tpi->xend = tile->xend;\n\tpi->yend = tile->yend;\n\n\tpi->picomp = 0;\n\tpi->pirlvl = 0;\n\tpi->x = 0;\n\tpi->y = 0;\n\tpi->compno = 0;\n\tpi->rlvlno = 0;\n\tpi->prcno = 0;\n\tpi->lyrno = 0;\n\tpi->xstep = 0;\n\tpi->ystep = 0;\n\n\tpi->pchgno = -1;\n\n\tpi->defaultpchg.prgord = tile->cp->prgord;\n\tpi->defaultpchg.compnostart = 0;\n\tpi->defaultpchg.compnoend = pi->numcomps;\n\tpi->defaultpchg.rlvlnostart = 0;\n\tpi->defaultpchg.rlvlnoend = pi->maxrlvls;\n\tpi->defaultpchg.lyrnoend = pi->numlyrs;\n\tpi->pchg = 0;\n\n\tpi->valid = 0;\n\n\treturn pi;\n}\n\nlong jpc_dec_lookahead(jas_stream_t *in)\n{\n\tuint_fast16_t x;\n\tif (jpc_getuint16(in, &x)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_ungetc(in, x & 0xff) == EOF ||\n\t  jas_stream_ungetc(in, x >> 8) == EOF) {\n\t\treturn -1;\n\t}\n\tif (x >= JPC_MS_INMIN && x <= JPC_MS_INMAX) {\n\t\treturn x;\n\t}\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Primitive Types\n *\n * $Id$\n */\n\n#ifndef JAS_TYPES_H\n#define JAS_TYPES_H\n\n/* The configuration header file should be included first. */\n#include <jasper/jas_config.h>\n\n#if !defined(JAS_CONFIGURE)\n\n#if defined(WIN32) || defined(JAS_HAVE_WINDOWS_H)\n// THIS SHOULD NO LONGER BE NEEDED SINCE MSVC SUPPORTS LONG LONG.\n/*\n   We are dealing with Microsoft Windows and most likely Microsoft\n   Visual C (MSVC).  (Heaven help us.)  Sadly, MSVC does not correctly\n   define some of the standard types specified in ISO/IEC 9899:1999.\n   In particular, it does not define the \"long long\" and \"unsigned long\n   long\" types.  So, we work around this problem by using the \"INT64\"\n   and \"UINT64\" types that are defined in the header file \"windows.h\".\n */\n#include <windows.h>\n//#undef longlong\n//#define\tlonglong\tINT64\n//#undef ulonglong\n//#define\tulonglong\tUINT64\n#endif\n\n#endif\n\n/* Note: The immediately following header files should eventually be removed. */\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#if defined(JAS_HAVE_SYS_TYPES_H)\n#include <sys/types.h>\n#endif\n\n#define jas_uchar unsigned char\n#define jas_uint unsigned int\n#define jas_ulong unsigned long\n#define jas_longlong long long\n#define jas_ulonglong unsigned long long\n\n/* The below macro is intended to be used for type casts.  By using this\n  macro, type casts can be easily located in the source code with\n  tools like \"grep\". */\n#define\tJAS_CAST(t, e) \\\n\t((t) (e))\n\n/* The number of bits in the integeral type uint_fast32_t. */\n/* NOTE: This could underestimate the size on some exotic architectures. */\n#define JAS_UINTFAST32_NUMBITS (8 * sizeof(uint_fast32_t))\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Tier-2 Coding Library\n *\n * $Id$\n */\n\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_malloc.h\"\n\n#include \"jpc_cs.h\"\n#include \"jpc_t2cod.h\"\n#include \"jpc_math.h\"\n\nstatic int jpc_pi_nextlrcp(jpc_pi_t *pi);\nstatic int jpc_pi_nextrlcp(jpc_pi_t *pi);\nstatic int jpc_pi_nextrpcl(jpc_pi_t *pi);\nstatic int jpc_pi_nextpcrl(jpc_pi_t *pi);\nstatic int jpc_pi_nextcprl(jpc_pi_t *pi);\n\nint jpc_pi_next(jpc_pi_t *pi)\n{\n\tjpc_pchg_t *pchg;\n\tint ret;\n\n\tfor (;;) {\n\n\t\tpi->valid = false;\n\n\t\tif (!pi->pchg) {\n\t\t\t++pi->pchgno;\n\t\t\tpi->compno = 0;\n\t\t\tpi->rlvlno = 0;\n\t\t\tpi->prcno = 0;\n\t\t\tpi->lyrno = 0;\n\t\t\tpi->prgvolfirst = true;\n\t\t\tif (pi->pchgno < jpc_pchglist_numpchgs(pi->pchglist)) {\n\t\t\t\tpi->pchg = jpc_pchglist_get(pi->pchglist, pi->pchgno);\n\t\t\t} else if (pi->pchgno == jpc_pchglist_numpchgs(pi->pchglist)) {\n\t\t\t\tpi->pchg = &pi->defaultpchg;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tpchg = pi->pchg;\n\t\tswitch (pchg->prgord) {\n\t\tcase JPC_COD_LRCPPRG:\n\t\t\tret = jpc_pi_nextlrcp(pi);\n\t\t\tbreak;\n\t\tcase JPC_COD_RLCPPRG:\n\t\t\tret = jpc_pi_nextrlcp(pi);\n\t\t\tbreak;\n\t\tcase JPC_COD_RPCLPRG:\n\t\t\tret = jpc_pi_nextrpcl(pi);\n\t\t\tbreak;\n\t\tcase JPC_COD_PCRLPRG:\n\t\t\tret = jpc_pi_nextpcrl(pi);\n\t\t\tbreak;\n\t\tcase JPC_COD_CPRLPRG:\n\t\t\tret = jpc_pi_nextcprl(pi);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ret) {\n\t\t\tpi->valid = true;\n\t\t\t++pi->pktno;\n\t\t\treturn 0;\n\t\t}\n\t\tpi->pchg = 0;\n\t}\n}\n\nstatic int jpc_pi_nextlrcp(register jpc_pi_t *pi)\n{\n\tjpc_pchg_t *pchg;\n\tint *prclyrno;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = false;\n\t}\n\n\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs && pi->lyrno <\n\t  JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pi->maxrlvls &&\n\t\t  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno) {\n\t\t\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t\t\t  &pi->picomps[pi->compno]; pi->compno < pi->numcomps\n\t\t\t  && pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,\n\t\t\t  ++pi->picomp) {\n\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\tfor (pi->prcno = 0, prclyrno =\n\t\t\t\t  pi->pirlvl->prclyrnos; pi->prcno <\n\t\t\t\t  pi->pirlvl->numprcs; ++pi->prcno,\n\t\t\t\t  ++prclyrno) {\n\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t*prclyrno = pi->lyrno;\n\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\nskip:\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int jpc_pi_nextrlcp(register jpc_pi_t *pi)\n{\n\tjpc_pchg_t *pchg;\n\tint *prclyrno;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pi->maxrlvls &&\n\t  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno) {\n\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs && pi->lyrno <\n\t\t  JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t\t\t  &pi->picomps[pi->compno]; pi->compno < pi->numcomps &&\n\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,\n\t\t\t  ++pi->picomp) {\n\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\tfor (pi->prcno = 0, prclyrno = pi->pirlvl->prclyrnos;\n\t\t\t\t  pi->prcno < pi->pirlvl->numprcs; ++pi->prcno, ++prclyrno) {\n\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t*prclyrno = pi->lyrno;\n\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\nskip:\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int jpc_pi_nextrpcl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tint xstep;\n\tint ystep;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->xstep = 0;\n\t\tpi->ystep = 0;\n\t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t\t  ++compno, ++picomp) {\n\t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\t\t// Check for the potential for overflow problems.\n\t\t\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n\t\t\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\txstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));\n\t\t\t\tystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));\n\t\t\t\tpi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);\n\t\t\t\tpi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);\n\t\t\t}\n\t\t}\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pchg->rlvlnoend &&\n\t  pi->rlvlno < pi->maxrlvls; ++pi->rlvlno) {\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend; pi->y +=\n\t\t  pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend; pi->x +=\n\t\t\t  pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->compno = pchg->compnostart,\n\t\t\t\t  pi->picomp = &pi->picomps[pi->compno];\n\t\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno <\n\t\t\t\t  pi->numcomps; ++pi->compno, ++pi->picomp) {\n\t\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\tif (((pi->x == pi->xstart &&\n\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx)))\n\t\t\t\t\t  || !(pi->x % (JAS_CAST(uint_fast32_t, 1) << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart &&\n\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy)))\n\t\t\t\t\t  || !(pi->y % (JAS_CAST(uint_fast32_t, 1) << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n\n\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int,\n\t\t\t\t\t\t  pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int jpc_pi_nextpcrl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tint xstep;\n\tint ystep;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->xstep = 0;\n\t\tpi->ystep = 0;\n\t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t\t  ++compno, ++picomp) {\n\t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\t\t// Check for the potential for overflow problems.\n\t\t\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n\t\t\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\txstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));\n\t\t\t\tystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));\n\t\t\t\tpi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);\n\t\t\t\tpi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);\n\t\t\t}\n\t\t}\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->y = pi->ystart; pi->y < pi->yend; pi->y += pi->ystep -\n\t  (pi->y % pi->ystep)) {\n\t\tfor (pi->x = pi->xstart; pi->x < pi->xend; pi->x += pi->xstep -\n\t\t  (pi->x % pi->xstep)) {\n\t\t\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t\t\t  &pi->picomps[pi->compno]; pi->compno < pi->numcomps\n\t\t\t  && pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,\n\t\t\t  ++pi->picomp) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls &&\n\t\t\t\t  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno,\n\t\t\t\t  ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart &&\n\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart &&\n\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&\n\t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend);\n\t\t\t\t\t\t  ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int jpc_pi_nextcprl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp = &pi->picomps[pi->compno];\n\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps;\n\t  ++pi->compno, ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\t// Check for the potential for overflow problems.\n\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n\t\t\treturn -1;\n\t\t}\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart &&\n\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart &&\n\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&\n\t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend);\n\t\t\t\t\t\t  ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void pirlvl_destroy(jpc_pirlvl_t *rlvl)\n{\n\tif (rlvl->prclyrnos) {\n\t\tjas_free(rlvl->prclyrnos);\n\t}\n}\n\nstatic void jpc_picomp_destroy(jpc_picomp_t *picomp)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tif (picomp->pirlvls) {\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpirlvl_destroy(pirlvl);\n\t\t}\n\t\tjas_free(picomp->pirlvls);\n\t}\n}\n\nvoid jpc_pi_destroy(jpc_pi_t *pi)\n{\n\tjpc_picomp_t *picomp;\n\tint compno;\n\tif (pi->picomps) {\n\t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t\t  ++compno, ++picomp) {\n\t\t\tjpc_picomp_destroy(picomp);\n\t\t}\n\t\tjas_free(pi->picomps);\n\t}\n\tif (pi->pchglist) {\n\t\tjpc_pchglist_destroy(pi->pchglist);\n\t}\n\tjas_free(pi);\n}\n\njpc_pi_t *jpc_pi_create0()\n{\n\tjpc_pi_t *pi;\n\tif (!(pi = jas_malloc(sizeof(jpc_pi_t)))) {\n\t\treturn 0;\n\t}\n\tpi->picomps = 0;\n\tpi->pchgno = 0;\n\tif (!(pi->pchglist = jpc_pchglist_create())) {\n\t\tjas_free(pi);\n\t\treturn 0;\n\t}\n\treturn pi;\n}\n\nint jpc_pi_addpchg(jpc_pi_t *pi, jpc_pocpchg_t *pchg)\n{\n\treturn jpc_pchglist_insert(pi->pchglist, -1, pchg);\n}\n\njpc_pchglist_t *jpc_pchglist_create()\n{\n\tjpc_pchglist_t *pchglist;\n\tif (!(pchglist = jas_malloc(sizeof(jpc_pchglist_t)))) {\n\t\treturn 0;\n\t}\n\tpchglist->numpchgs = 0;\n\tpchglist->maxpchgs = 0;\n\tpchglist->pchgs = 0;\n\treturn pchglist;\n}\n\nint jpc_pchglist_insert(jpc_pchglist_t *pchglist, int pchgno, jpc_pchg_t *pchg)\n{\n\tint i;\n\tint newmaxpchgs;\n\tjpc_pchg_t **newpchgs;\n\tif (pchgno < 0) {\n\t\tpchgno = pchglist->numpchgs;\n\t}\n\tif (pchglist->numpchgs >= pchglist->maxpchgs) {\n\t\tnewmaxpchgs = pchglist->maxpchgs + 128;\n\t\tif (!(newpchgs = jas_realloc2(pchglist->pchgs, newmaxpchgs,\n\t\t  sizeof(jpc_pchg_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tpchglist->maxpchgs = newmaxpchgs;\n\t\tpchglist->pchgs = newpchgs;\n\t}\n\tfor (i = pchglist->numpchgs; i > pchgno; --i) {\n\t\tpchglist->pchgs[i] = pchglist->pchgs[i - 1];\n\t}\n\tpchglist->pchgs[pchgno] = pchg;\n\t++pchglist->numpchgs;\n\treturn 0;\n}\n\njpc_pchg_t *jpc_pchglist_remove(jpc_pchglist_t *pchglist, int pchgno)\n{\n\tint i;\n\tjpc_pchg_t *pchg;\n\tassert(pchgno < pchglist->numpchgs);\n\tpchg = pchglist->pchgs[pchgno];\n\tfor (i = pchgno + 1; i < pchglist->numpchgs; ++i) {\n\t\tpchglist->pchgs[i - 1] = pchglist->pchgs[i];\n\t}\n\t--pchglist->numpchgs;\n\treturn pchg;\n}\n\njpc_pchg_t *jpc_pchg_copy(jpc_pchg_t *pchg)\n{\n\tjpc_pchg_t *newpchg;\n\tif (!(newpchg = jas_malloc(sizeof(jpc_pchg_t)))) {\n\t\treturn 0;\n\t}\n\t*newpchg = *pchg;\n\treturn newpchg;\n}\n\njpc_pchglist_t *jpc_pchglist_copy(jpc_pchglist_t *pchglist)\n{\n\tjpc_pchglist_t *newpchglist;\n\tjpc_pchg_t *newpchg;\n\tint pchgno;\n\tif (!(newpchglist = jpc_pchglist_create())) {\n\t\treturn 0;\n\t}\n\tfor (pchgno = 0; pchgno < pchglist->numpchgs; ++pchgno) {\n\t\tif (!(newpchg = jpc_pchg_copy(pchglist->pchgs[pchgno])) ||\n\t\t  jpc_pchglist_insert(newpchglist, -1, newpchg)) {\n\t\t\tjpc_pchglist_destroy(newpchglist);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn newpchglist;\n}\n\nvoid jpc_pchglist_destroy(jpc_pchglist_t *pchglist)\n{\n\tint pchgno;\n\tif (pchglist->pchgs) {\n\t\tfor (pchgno = 0; pchgno < pchglist->numpchgs; ++pchgno) {\n\t\t\tjpc_pchg_destroy(pchglist->pchgs[pchgno]);\n\t\t}\n\t\tjas_free(pchglist->pchgs);\n\t}\n\tjas_free(pchglist);\n}\n\nvoid jpc_pchg_destroy(jpc_pchg_t *pchg)\n{\n\tjas_free(pchg);\n}\n\njpc_pchg_t *jpc_pchglist_get(jpc_pchglist_t *pchglist, int pchgno)\n{\n\treturn pchglist->pchgs[pchgno];\n}\n\nint jpc_pchglist_numpchgs(jpc_pchglist_t *pchglist)\n{\n\treturn pchglist->numpchgs;\n}\n\nint jpc_pi_init(jpc_pi_t *pi)\n{\n\tint compno;\n\tint rlvlno;\n\tint prcno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tint *prclyrno;\n\n\tpi->prgvolfirst = 0;\n\tpi->valid = 0;\n\tpi->pktno = -1;\n\tpi->pchgno = -1;\n\tpi->pchg = 0;\n\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t  ++compno, ++picomp) {\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Tier 2 Decoder\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_fix.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_bs.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mqdec.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1cod.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nlong jpc_dec_lookahead(jas_stream_t *in);\nstatic int jpc_getcommacode(jpc_bitstream_t *in);\nstatic int jpc_getnumnewpasses(jpc_bitstream_t *in);\nstatic int jpc_dec_decodepkt(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in, int compno, int lvlno,\n  int prcno, int lyrno);\n\n/******************************************************************************\\\n* Code.\n\\******************************************************************************/\n\nstatic int jpc_getcommacode(jpc_bitstream_t *in)\n{\n\tint n;\n\tint v;\n\n\tn = 0;\n\tfor (;;) {\n\t\tif ((v = jpc_bitstream_getbit(in)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_bitstream_eof(in)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!v) {\n\t\t\tbreak;\n\t\t}\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\nstatic int jpc_getnumnewpasses(jpc_bitstream_t *in)\n{\n\tint n;\n\n\tif ((n = jpc_bitstream_getbit(in)) > 0) {\n\t\tif ((n = jpc_bitstream_getbit(in)) > 0) {\n\t\t\tif ((n = jpc_bitstream_getbits(in, 2)) == 3) {\n\t\t\t\tif ((n = jpc_bitstream_getbits(in, 5)) == 31) {\n\t\t\t\t\tif ((n = jpc_bitstream_getbits(in, 7)) >= 0) {\n\t\t\t\t\t\tn += 36 + 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (n >= 0) {\n\t\t\t\t\tn += 5 + 1;\n\t\t\t\t}\n\t\t\t} else if (n >= 0) {\n\t\t\t\tn += 2 + 1;\n\t\t\t}\n\t\t} else if (!n) {\n\t\t\tn += 2;\n\t\t}\n\t} else if (!n) {\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\nstatic int jpc_dec_decodepkt(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in, int compno, int rlvlno,\n  int prcno, int lyrno)\n{\n\tjpc_bitstream_t *inb;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_cblk_t *cblk;\n\tint n;\n\tint m;\n\tint i;\n\tjpc_tagtreenode_t *leaf;\n\tint included;\n\tint ret;\n\tint numnewpasses;\n\tjpc_dec_seg_t *seg;\n\tint len;\n\tint present;\n\tint savenumnewpasses;\n\tint mycounter;\n\tjpc_ms_t *ms;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cp_t *cp;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint usedcblkcnt;\n\tint cblkno;\n\tuint_fast32_t bodylen;\n\tbool discard;\n\tint passno;\n\tint maxpasses;\n\tint hdrlen;\n\tint hdroffstart;\n\tint hdroffend;\n\n\t/* Avoid compiler warning about possible use of uninitialized\n\t  variable. */\n\tbodylen = 0;\n\n\tdiscard = (lyrno >= dec->maxlyrs);\n\n\ttile = dec->curtile;\n\tcp = tile->cp;\n\tccp = &cp->ccps[compno];\n\n\t/*\n\t * Decode the packet header.\n\t */\n\n\t/* Decode the SOP marker segment if present. */\n\tif (cp->csty & JPC_COD_SOP) {\n\t\tif (jpc_dec_lookahead(in) == JPC_MS_SOP) {\n\t\t\tif (!(ms = jpc_getms(in, dec->cstate))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_SOP) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing SOP marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\nhdroffstart = jas_stream_getrwcount(pkthdrstream);\n\n\tif (!(inb = jpc_bitstream_sopen(pkthdrstream, \"r\"))) {\n\t\treturn -1;\n\t}\n\n\tif ((present = jpc_bitstream_getbit(inb)) < 0) {\n\t\treturn 1;\n\t}\n\tJAS_DBGLOG(10, (\"\\n\", present));\n\tJAS_DBGLOG(10, (\"present=%d \", present));\n\n\t/* Is the packet non-empty? */\n\tif (present) {\n\t\t/* The packet is non-empty. */\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tbodylen = 0;\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tusedcblkcnt = 0;\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\t++usedcblkcnt;\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->incltagtree, usedcblkcnt - 1);\n\t\t\t\t\tif ((included = jpc_tagtree_decode(prc->incltagtree, leaf, lyrno + 1, inb)) < 0) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((included = jpc_bitstream_getbit(inb)) < 0) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"\\n\"));\n\t\t\t\tJAS_DBGLOG(10, (\"included=%d \", included));\n\t\t\t\tif (!included) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\ti = 1;\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->numimsbstagtree, usedcblkcnt - 1);\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\tif ((ret = jpc_tagtree_decode(prc->numimsbstagtree, leaf, i, inb)) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ret) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numimsbs = i - 1;\n\t\t\t\t\tcblk->firstpassno = cblk->numimsbs * 3;\n\t\t\t\t}\n\t\t\t\tif ((numnewpasses = jpc_getnumnewpasses(inb)) < 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"numnewpasses=%d \", numnewpasses));\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\tsavenumnewpasses = numnewpasses;\n\t\t\t\tmycounter = 0;\n\t\t\t\tif (numnewpasses > 0) {\n\t\t\t\t\tif ((m = jpc_getcommacode(inb)) < 0) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numlenbits += m;\n\t\t\t\t\tJAS_DBGLOG(10, (\"increment=%d \", m));\n\t\t\t\t\twhile (numnewpasses > 0) {\n\t\t\t\t\t\tpassno = cblk->firstpassno + cblk->numpasses + mycounter;\n\t/* XXX - the maxpasses is not set precisely but this doesn't matter... */\n\t\t\t\t\t\tmaxpasses = JPC_SEGPASSCNT(passno, cblk->firstpassno, 10000, (ccp->cblkctx & JPC_COX_LAZY) != 0, (ccp->cblkctx & JPC_COX_TERMALL) != 0);\n\t\t\t\t\t\tif (!discard && !seg) {\n\t\t\t\t\t\t\tif (!(seg = jpc_seg_alloc())) {\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjpc_seglist_insert(&cblk->segs, cblk->segs.tail, seg);\n\t\t\t\t\t\t\tif (!cblk->curseg) {\n\t\t\t\t\t\t\t\tcblk->curseg = seg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tseg->passno = passno;\n\t\t\t\t\t\t\tseg->type = JPC_SEGTYPE(seg->passno, cblk->firstpassno, (ccp->cblkctx & JPC_COX_LAZY) != 0);\n\t\t\t\t\t\t\tseg->maxpasses = maxpasses;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn = JAS_MIN(numnewpasses, maxpasses);\n\t\t\t\t\t\tmycounter += n;\n\t\t\t\t\t\tnumnewpasses -= n;\n\t\t\t\t\t\tif ((len = jpc_bitstream_getbits(inb, cblk->numlenbits + jpc_floorlog2(n))) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJAS_DBGLOG(10, (\"len=%d \", len));\n\t\t\t\t\t\tif (!discard) {\n\t\t\t\t\t\t\tseg->lyrno = lyrno;\n\t\t\t\t\t\t\tseg->numpasses += n;\n\t\t\t\t\t\t\tseg->cnt = len;\n\t\t\t\t\t\t\tseg = seg->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbodylen += len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcblk->numpasses += savenumnewpasses;\n\t\t\t}\n\t\t}\n\n\t\tjpc_bitstream_inalign(inb, 0, 0);\n\n\t} else {\n\t\tif (jpc_bitstream_inalign(inb, 0x7f, 0)) {\n\t\t\tjas_eprintf(\"alignment failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tjpc_bitstream_close(inb);\n\n\thdroffend = jas_stream_getrwcount(pkthdrstream);\n\thdrlen = hdroffend - hdroffstart;\n\tif (jas_getdbglevel() >= 5) {\n\t\tjas_eprintf(\"hdrlen=%lu bodylen=%lu \\n\", (unsigned long) hdrlen,\n\t\t  (unsigned long) bodylen);\n\t}\n\n\tif (cp->csty & JPC_COD_EPH) {\n\t\tif (jpc_dec_lookahead(pkthdrstream) == JPC_MS_EPH) {\n\t\t\tif (!(ms = jpc_getms(pkthdrstream, dec->cstate))) {\n\t\t\t\tjas_eprintf(\"cannot get (EPH) marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_EPH) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing EPH marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\n\t/* decode the packet body. */\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjas_eprintf(\"packet body offset=%06ld\\n\", (long) jas_stream_getrwcount(in));\n\t}\n\n\tif (!discard) {\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\twhile (seg) {\n\t\t\t\t\tif (!seg->stream) {\n\t\t\t\t\t\tif (!(seg->stream = jas_stream_memopen(0, 0))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#if 0\njas_eprintf(\"lyrno=%02d, compno=%02d, lvlno=%02d, prcno=%02d, bandno=%02d, cblkno=%02d, passno=%02d numpasses=%02d cnt=%d numbps=%d, numimsbs=%d\\n\", lyrno, compno, rlvlno, prcno, band - rlvl->bands, cblk - prc->cblks, seg->passno, seg->numpasses, seg->cnt, band->numbps, cblk->numimsbs);\n#endif\n\t\t\t\t\tif (seg->cnt > 0) {\n\t\t\t\t\t\tif (jpc_getdata(in, seg->stream, seg->cnt) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tseg->cnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (seg->numpasses >= seg->maxpasses) {\n\t\t\t\t\t\tcblk->curseg = seg->next;\n\t\t\t\t\t}\n\t\t\t\t\tseg = seg->next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (jas_stream_gobble(in, bodylen) != JAS_CAST(int, bodylen)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/********************************************************************************************/\n/********************************************************************************************/\n\nint jpc_dec_decodepkts(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_pi_t *pi;\n\tint ret;\n\n\ttile = dec->curtile;\n\tpi = tile->pi;\n\tfor (;;) {\n\t\tif (!tile->pkthdrstream || jas_stream_peekc(tile->pkthdrstream) == EOF) {\n\t\t\tswitch (jpc_dec_lookahead(in)) {\n\t\t\tcase JPC_MS_EOC:\n\t\t\tcase JPC_MS_SOT:\n\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase JPC_MS_SOP:\n\t\t\tcase JPC_MS_EPH:\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((ret = jpc_pi_next(pi))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (dec->maxpkts >= 0 && dec->numpkts >= dec->maxpkts) {\n\t\t\tjas_eprintf(\"warning: stopping decode prematurely as requested\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"packet offset=%08ld prg=%d cmptno=%02d \"\n\t\t\t  \"rlvlno=%02d prcno=%03d lyrno=%02d\\n\", (long)\n\t\t\t  jas_stream_getrwcount(in), jpc_pi_prg(pi), jpc_pi_cmptno(pi),\n\t\t\t  jpc_pi_rlvlno(pi), jpc_pi_prcno(pi), jpc_pi_lyrno(pi));\n\t\t}\n\t\tif (jpc_dec_decodepkt(dec, pkthdrstream, in, jpc_pi_cmptno(pi),\n\t\t  jpc_pi_rlvlno(pi), jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) {\n\t\t\treturn -1;\n\t\t}\n\t\t++dec->numpkts;\n\t}\n\n\treturn 0;\n}\n\njpc_pi_t *jpc_dec_pi_create(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_pi_t *pi;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_dec_tcomp_t *tcomp;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tint *prclyrno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (!(pi = jpc_pi_create0())) {\n\t\treturn 0;\n\t}\n\tpi->numcomps = dec->numcomps;\n\tif (!(pi->picomps = jas_alloc2(pi->numcomps, sizeof(jpc_picomp_t)))) {\n\t\tjpc_pi_destroy(pi);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps; ++compno,\n\t  ++picomp) {\n\t\tpicomp->pirlvls = 0;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, picomp = pi->picomps;\n\t  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {\n\t\tpicomp->numrlvls = tcomp->numrlvls;\n\t\tif (!(picomp->pirlvls = jas_alloc2(picomp->numrlvls,\n\t\t  sizeof(jpc_pirlvl_t)))) {\n\t\t\tjpc_pi_destroy(pi);\n\t\t\treturn 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpirlvl->prclyrnos = 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n/* XXX sizeof(long) should be sizeof different type */\n\t\t\tpirlvl->numprcs = rlvl->numprcs;\n\t\t\tif (!(pirlvl->prclyrnos = jas_alloc2(pirlvl->numprcs,\n\t\t\t  sizeof(long)))) {\n\t\t\t\tjpc_pi_destroy(pi);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpi->maxrlvls = 0;\n\tfor (compno = 0, tcomp = tile->tcomps, picomp = pi->picomps, cmpt =\n\t  dec->cmpts; compno < pi->numcomps; ++compno, ++tcomp, ++picomp,\n\t  ++cmpt) {\n\t\tpicomp->hsamp = cmpt->hstep;\n\t\tpicomp->vsamp = cmpt->vstep;\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n\t\t\tpirlvl->prcwidthexpn = rlvl->prcwidthexpn;\n\t\t\tpirlvl->prcheightexpn = rlvl->prcheightexpn;\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t\tpirlvl->numhprcs = rlvl->numhprcs;\n\t\t}\n\t\tif (pi->maxrlvls < tcomp->numrlvls) {\n\t\t\tpi->maxrlvls = tcomp->numrlvls;\n\t\t}\n\t}\n\n\tpi->numlyrs = tile->cp->numlyrs;\n\tpi->xstart = tile->xstart;\n\tpi->ystart = tile->ystart;\n\tpi->xend = tile->xend;\n\tpi->yend = tile->yend;\n\n\tpi->picomp = 0;\n\tpi->pirlvl = 0;\n\tpi->x = 0;\n\tpi->y = 0;\n\tpi->compno = 0;\n\tpi->rlvlno = 0;\n\tpi->prcno = 0;\n\tpi->lyrno = 0;\n\tpi->xstep = 0;\n\tpi->ystep = 0;\n\n\tpi->pchgno = -1;\n\n\tpi->defaultpchg.prgord = tile->cp->prgord;\n\tpi->defaultpchg.compnostart = 0;\n\tpi->defaultpchg.compnoend = pi->numcomps;\n\tpi->defaultpchg.rlvlnostart = 0;\n\tpi->defaultpchg.rlvlnoend = pi->maxrlvls;\n\tpi->defaultpchg.lyrnoend = pi->numlyrs;\n\tpi->pchg = 0;\n\n\tpi->valid = 0;\n\n\treturn pi;\n}\n\nlong jpc_dec_lookahead(jas_stream_t *in)\n{\n\tuint_fast16_t x;\n\tif (jpc_getuint16(in, &x)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_ungetc(in, x & 0xff) == EOF ||\n\t  jas_stream_ungetc(in, x >> 8) == EOF) {\n\t\treturn -1;\n\t}\n\tif (x >= JPC_MS_INMIN && x <= JPC_MS_INMAX) {\n\t\treturn x;\n\t}\n\treturn 0;\n}\n"], "filenames": ["src/libjasper/include/jasper/jas_types.h", "src/libjasper/jpc/jpc_t2cod.c", "src/libjasper/jpc/jpc_t2dec.c"], "buggy_code_start_loc": [118, 201, 426], "buggy_code_end_loc": [118, 479, 459], "fixing_code_start_loc": [119, 201, 426], "fixing_code_end_loc": [123, 503, 459], "type": "CWE-125", "message": "An out-of-bounds heap read vulnerability was found in the jpc_pi_nextpcrl() function of jasper before 2.0.6 when processing crafted input.", "other": {"cve": {"id": "CVE-2016-9583", "sourceIdentifier": "secalert@redhat.com", "published": "2018-08-01T17:29:00.297", "lastModified": "2019-10-09T23:20:36.633", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An out-of-bounds heap read vulnerability was found in the jpc_pi_nextpcrl() function of jasper before 2.0.6 when processing crafted input."}, {"lang": "es", "value": "Se ha detectado una vulnerabilidad de lectura de memoria din\u00e1mica (heap) fuera de l\u00edmites en la funci\u00f3n jpc_pi_nextpcrl() de jasper en versiones anteriores a la 2.0.6 al procesar entradas manipuladas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "A8442C20-41F9-47FD-9A12-E724D3A31FD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.6", "matchCriteriaId": "19417BCE-999D-4421-8EE9-DC0513E88004"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:outside_in_technology:8.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "10DD6CB3-ED55-465D-AB98-13EFD013AE47"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/94925", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1208", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2016-9583", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mdadams/jasper/commit/f25486c3d4aa472fec79150f2c41ed4333395d3d", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujan2019-5072801.html", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d"}}