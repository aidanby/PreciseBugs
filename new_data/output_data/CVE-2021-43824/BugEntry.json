{"buggy_code": ["1.22.0 (pending)\n================\n\nIncompatible Behavior Changes\n-----------------------------\n*Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\n* tls: set TLS v1.2 as the default minimal version for servers. Users can still explicitly opt-in to 1.0 and 1.1 using :ref:`tls_minimum_protocol_version <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsParameters.tls_minimum_protocol_version>`.\n\nMinor Behavior Changes\n----------------------\n*Changes that may cause incompatibilities for some users, but should not for most*\n\n* dynamic_forward_proxy: if a DNS resolution fails, failing immediately with a specific resolution error, rather than finishing up all local filters and failing to select an upstream host.\n* ext_authz: added requested server name in ext_authz network filter for auth review.\n* file: changed disk based files to truncate files which are not being appended to. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.append_or_truncate`` to false.\n* grpc: flip runtime guard ``envoy.reloadable_features.enable_grpc_async_client_cache`` to be default enabled. async grpc client created through getOrCreateRawAsyncClient will be cached by default.\n* http: avoiding delay-close for HTTP/1.0 responses framed by connection: close as well as HTTP/1.1 if the request is fully read. This means for responses to such requests, the FIN will be sent immediately after the response. This behavior can be temporarily reverted by setting ``envoy.reloadable_features.skip_delay_close`` to false.  If clients are are seen to be receiving sporadic partial responses and flipping this flag fixes it, please notify the project immediately.\n* http: now the max concurrent streams of http2 connection can not only be adjusted down according to the SETTINGS frame but also can be adjusted up, of course, it can not exceed the configured upper bounds. This fix is guarded by ``envoy.reloadable_features.http2_allow_capacity_increase_by_settings``.\n* http: when writing custom filters, `injectEncodedDataToFilterChain` and `injectDecodedDataToFilterChain` now trigger sending of headers if they were not yet sent due to `StopIteration`. Previously, calling one of the inject functions in that state would trigger an assertion. See issue #19891 for more details.\n* perf: ssl contexts are now tracked without scan based garbage collection and greatly improved the performance on secret update.\n\nBug Fixes\n---------\n*Changes expected to improve the state of the world and are unlikely to have negative effects*\n\n* access_log: fix memory leak when reopening an access log fails. Access logs will now try to be reopened on each subsequent flush attempt after a failure.\n* data plane: fixing error handling where writing to a socket failed while under the stack of processing. This should genreally affect HTTP/3. This behavioral change can be reverted by setting ``envoy.reloadable_features.allow_upstream_inline_write`` to false.\n* eds: fix the eds cluster update by allowing update on the locality of the cluster endpoints. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.support_locality_update_on_eds_cluster_endpoints`` to false.\n* tcp_proxy: fix a crash that occurs when configured for :ref:`upstream tunneling <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.tunneling_config>` and the downstream connection disconnects while the the upstream connection or http/2 stream is still being established.\n* tls: fix a bug while matching a certificate SAN with an exact value in ``match_typed_subject_alt_names`` of a listener where wildcard ``*`` character is not the only character of the dns label. Example, ``baz*.example.net`` and ``*baz.example.net`` and ``b*z.example.net`` will match ``baz1.example.net`` and ``foobaz.example.net`` and ``buzz.example.net``, respectively.\n* upstream: fix stack overflow when a cluster with large number of idle connections is removed.\n* xray: fix the AWS X-Ray tracer extension to not sample the trace if ``sampled=`` keyword is not present in the header ``x-amzn-trace-id``.\n\nRemoved Config or Runtime\n-------------------------\n*Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n\n* access_log: removed ``envoy.reloadable_features.unquote_log_string_values`` and legacy code paths.\n* grpc_bridge_filter: removed ``envoy.reloadable_features.grpc_bridge_stats_disabled`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.hash_multiple_header_values`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.no_chunked_encoding_header_for_304`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.preserve_downstream_scheme`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.require_strict_1xx_and_204_response_headers`` and ``envoy.reloadable_features.send_strict_1xx_and_204_response_headers`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.strip_port_from_connect`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.use_observable_cluster_name`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http_transport_failure_reason_in_body`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.allow_response_for_timeout`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http2_consume_stream_refused_errors`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.internal_redirects_with_body`` and legacy code paths.\n* udp: removed ``envoy.reloadable_features.udp_per_event_loop_read_limit`` and legacy code paths.\n* upstream: removed ``envoy.reloadable_features.health_check.graceful_goaway_handling`` and legacy code paths.\n* xds: removed ``envoy.reloadable_features.vhds_heartbeats`` and legacy code paths.\n\n\nNew Features\n------------\n* access_log: make consistent access_log format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* admin: :http:post:`/logging` now accepts ``/logging?paths=name1:level1,name2:level2,...`` to change multiple log levels at once.\n* config: added new file based xDS configuration via :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`.\n  :ref:`watched_directory <envoy_v3_api_field_config.core.v3.PathConfigSource.watched_directory>` can\n  be used to setup an independent watch for when to reload the file path, for example when using\n  Kubernetes ConfigMaps to deliver configuration. See the linked documentation for more information.\n* cors: add dynamic support for headers ``access-control-allow-methods`` and ``access-control-allow-headers`` in cors.\n* http: added random_value_specifier in :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` to allow random value to be specified from configuration proto.\n* http: added support for :ref:`proxy_status_config <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.proxy_status_config>` for configuring `Proxy-Status <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08>`_ HTTP response header fields.\n* http: make consistent custom header format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* http3: downstream HTTP/3 support is now GA! Upstream HTTP/3 also GA for specific deployments. See :ref:`here <arch_overview_http3>` for details.\n* http3: supports upstream HTTP/3 retries. Automatically retry `0-RTT safe requests <https://www.rfc-editor.org/rfc/rfc7231#section-4.2.1>`_ if they are rejected because they are sent `too early <https://datatracker.ietf.org/doc/html/rfc8470#section-5.2>`_. And automatically retry 0-RTT safe requests if connect attempt fails later on and the cluster is configured with TCP fallback. And add retry on ``http3-post-connect-failure`` policy which allows retry of failed HTTP/3 requests with TCP fallback even after handshake if the cluster is configured with TCP fallback. This feature is guarded by ``envoy.reloadable_features.conn_pool_new_stream_with_early_data_and_http3``.\n* matching: the matching API can now express a match tree that will always match by omitting a matcher at the top level.\n* outlier_detection: :ref:`max_ejection_time_jitter<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>` configuration added to allow adding a random value to the ejection time to prevent 'thundering herd' scenarios. Defaults to 0 so as to not break or change the behavior of existing deployments.\n\nDeprecated\n----------\n\n* config: deprecated :ref:`path <envoy_v3_api_field_config.core.v3.ConfigSource.path>` in favor of\n  :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`\n* http: removing support for long-deprecated old style filter names, e.g. envoy.router, envoy.lua.\n* re2: removed undocumented histograms ``re2.program_size`` and ``re2.exceeded_warn_level``.\n", "#include \"source/extensions/filters/http/jwt_authn/matcher.h\"\n\n#include \"envoy/config/route/v3/route_components.pb.h\"\n#include \"envoy/extensions/filters/http/jwt_authn/v3/config.pb.h\"\n\n#include \"source/common/common/logger.h\"\n#include \"source/common/common/matchers.h\"\n#include \"source/common/common/regex.h\"\n#include \"source/common/router/config_impl.h\"\n\n#include \"absl/strings/match.h\"\n\nusing envoy::config::route::v3::RouteMatch;\nusing envoy::extensions::filters::http::jwt_authn::v3::RequirementRule;\nusing Envoy::Router::ConfigUtility;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\nnamespace {\n\n/**\n * Perform a match against any HTTP header or pseudo-header.\n */\nclass BaseMatcherImpl : public Matcher, public Logger::Loggable<Logger::Id::jwt> {\npublic:\n  BaseMatcherImpl(const RequirementRule& rule)\n      : case_sensitive_(PROTOBUF_GET_WRAPPED_OR_DEFAULT(rule.match(), case_sensitive, true)),\n        config_headers_(Http::HeaderUtility::buildHeaderDataVector(rule.match().headers())) {\n    for (const auto& query_parameter : rule.match().query_parameters()) {\n      config_query_parameters_.push_back(\n          std::make_unique<Router::ConfigUtility::QueryParameterMatcher>(query_parameter));\n    }\n  }\n\n  // Check match for HeaderMatcher and QueryParameterMatcher\n  bool matchRoute(const Http::RequestHeaderMap& headers) const {\n    bool matches = true;\n    // TODO(potatop): matching on RouteMatch runtime is not implemented.\n\n    matches &= Http::HeaderUtility::matchHeaders(headers, config_headers_);\n    if (!config_query_parameters_.empty()) {\n      Http::Utility::QueryParams query_parameters =\n          Http::Utility::parseQueryString(headers.getPathValue());\n      matches &= ConfigUtility::matchQueryParams(query_parameters, config_query_parameters_);\n    }\n    return matches;\n  }\n\nprotected:\n  const bool case_sensitive_;\n\nprivate:\n  std::vector<Http::HeaderUtility::HeaderDataPtr> config_headers_;\n  std::vector<Router::ConfigUtility::QueryParameterMatcherPtr> config_query_parameters_;\n};\n\n/**\n * Perform a match against any path with prefix rule.\n */\nclass PrefixMatcherImpl : public BaseMatcherImpl {\npublic:\n  PrefixMatcherImpl(const RequirementRule& rule)\n      : BaseMatcherImpl(rule), prefix_(rule.match().prefix()),\n        path_matcher_(Matchers::PathMatcher::createPrefix(prefix_, !case_sensitive_)) {}\n\n  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers) && path_matcher_->match(headers.getPathValue())) {\n      ENVOY_LOG(debug, \"Prefix requirement '{}' matched.\", prefix_);\n      return true;\n    }\n    return false;\n  }\n\nprivate:\n  // prefix string\n  const std::string prefix_;\n  const Matchers::PathMatcherConstSharedPtr path_matcher_;\n};\n\n/**\n * Perform a match against any path with a specific path rule.\n */\nclass PathMatcherImpl : public BaseMatcherImpl {\npublic:\n  PathMatcherImpl(const RequirementRule& rule)\n      : BaseMatcherImpl(rule), path_(rule.match().path()),\n        path_matcher_(Matchers::PathMatcher::createExact(path_, !case_sensitive_)) {}\n\n  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers) && path_matcher_->match(headers.getPathValue())) {\n      ENVOY_LOG(debug, \"Path requirement '{}' matched.\", path_);\n      return true;\n    }\n    return false;\n  }\n\nprivate:\n  // path string.\n  const std::string path_;\n  const Matchers::PathMatcherConstSharedPtr path_matcher_;\n};\n\n/**\n * Perform a match against any path with a regex rule.\n * TODO(mattklein123): This code needs dedup with RegexRouteEntryImpl.\n */\nclass RegexMatcherImpl : public BaseMatcherImpl {\npublic:\n  RegexMatcherImpl(const RequirementRule& rule)\n      : BaseMatcherImpl(rule), regex_str_(rule.match().safe_regex().regex()),\n        path_matcher_(Matchers::PathMatcher::createSafeRegex(rule.match().safe_regex())) {\n    ASSERT(rule.match().path_specifier_case() ==\n           envoy::config::route::v3::RouteMatch::PathSpecifierCase::kSafeRegex);\n  }\n\n  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }\n\nprivate:\n  // raw regex string, for logging.\n  const std::string regex_str_;\n  const Matchers::PathMatcherConstSharedPtr path_matcher_;\n};\n\n/**\n * Perform a match against an HTTP CONNECT request.\n */\nclass ConnectMatcherImpl : public BaseMatcherImpl {\npublic:\n  ConnectMatcherImpl(const RequirementRule& rule) : BaseMatcherImpl(rule) {}\n\n  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (Http::HeaderUtility::isConnect(headers) && BaseMatcherImpl::matchRoute(headers)) {\n      ENVOY_LOG(debug, \"CONNECT requirement matched.\");\n      return true;\n    }\n\n    return false;\n  }\n};\n} // namespace\n\nMatcherConstPtr Matcher::create(const RequirementRule& rule) {\n  switch (rule.match().path_specifier_case()) {\n  case RouteMatch::PathSpecifierCase::kPrefix:\n    return std::make_unique<PrefixMatcherImpl>(rule);\n  case RouteMatch::PathSpecifierCase::kPath:\n    return std::make_unique<PathMatcherImpl>(rule);\n  case RouteMatch::PathSpecifierCase::kSafeRegex:\n    return std::make_unique<RegexMatcherImpl>(rule);\n  case RouteMatch::PathSpecifierCase::kConnectMatcher:\n    return std::make_unique<ConnectMatcherImpl>(rule);\n  case RouteMatch::PathSpecifierCase::PATH_SPECIFIER_NOT_SET:\n    break; // Fall through to PANIC.\n  }\n  PANIC_DUE_TO_CORRUPT_ENUM;\n}\n\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"envoy/config/bootstrap/v3/bootstrap.pb.h\"\n#include \"envoy/extensions/filters/http/jwt_authn/v3/config.pb.h\"\n#include \"envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h\"\n\n#include \"source/common/router/string_accessor_impl.h\"\n#include \"source/extensions/filters/http/common/pass_through_filter.h\"\n\n#include \"test/extensions/filters/http/common/empty_http_filter_config.h\"\n#include \"test/extensions/filters/http/jwt_authn/test_common.h\"\n#include \"test/integration/http_protocol_integration.h\"\n#include \"test/test_common/registry.h\"\n\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtAuthentication;\nusing envoy::extensions::filters::http::jwt_authn::v3::PerRouteConfig;\nusing envoy::extensions::filters::network::http_connection_manager::v3::HttpFilter;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\nnamespace {\n\nconst char HeaderToFilterStateFilterName[] = \"envoy.filters.http.header_to_filter_state_for_test\";\n// This filter extracts a string header from \"header\" and\n// save it into FilterState as name \"state\" as read-only Router::StringAccessor.\nclass HeaderToFilterStateFilter : public Http::PassThroughDecoderFilter {\npublic:\n  HeaderToFilterStateFilter(const std::string& header, const std::string& state)\n      : header_(header), state_(state) {}\n\n  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers, bool) override {\n    const auto entry = headers.get(header_);\n    if (!entry.empty()) {\n      decoder_callbacks_->streamInfo().filterState()->setData(\n          state_, std::make_unique<Router::StringAccessorImpl>(entry[0]->value().getStringView()),\n          StreamInfo::FilterState::StateType::ReadOnly,\n          StreamInfo::FilterState::LifeSpan::FilterChain);\n    }\n    return Http::FilterHeadersStatus::Continue;\n  }\n\nprivate:\n  Http::LowerCaseString header_;\n  std::string state_;\n};\n\nclass HeaderToFilterStateFilterConfig : public Common::EmptyHttpFilterConfig {\npublic:\n  HeaderToFilterStateFilterConfig()\n      : Common::EmptyHttpFilterConfig(HeaderToFilterStateFilterName) {}\n\n  Http::FilterFactoryCb createFilter(const std::string&,\n                                     Server::Configuration::FactoryContext&) override {\n    return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {\n      callbacks.addStreamDecoderFilter(\n          std::make_shared<HeaderToFilterStateFilter>(\"jwt_selector\", \"jwt_selector\"));\n    };\n  }\n};\n\nstd::string getAuthFilterConfig(const std::string& config_str, bool use_local_jwks) {\n  JwtAuthentication proto_config;\n  TestUtility::loadFromYaml(config_str, proto_config);\n\n  if (use_local_jwks) {\n    auto& provider0 = (*proto_config.mutable_providers())[std::string(ProviderName)];\n    provider0.clear_remote_jwks();\n    auto local_jwks = provider0.mutable_local_jwks();\n    local_jwks->set_inline_string(PublicKey);\n  }\n\n  HttpFilter filter;\n  filter.set_name(\"envoy.filters.http.jwt_authn\");\n  filter.mutable_typed_config()->PackFrom(proto_config);\n  return MessageUtil::getJsonStringFromMessageOrDie(filter);\n}\n\nstd::string getAsyncFetchFilterConfig(const std::string& config_str, bool fast_listener) {\n  JwtAuthentication proto_config;\n  TestUtility::loadFromYaml(config_str, proto_config);\n\n  auto& provider0 = (*proto_config.mutable_providers())[std::string(ProviderName)];\n  auto* async_fetch = provider0.mutable_remote_jwks()->mutable_async_fetch();\n  async_fetch->set_fast_listener(fast_listener);\n\n  HttpFilter filter;\n  filter.set_name(\"envoy.filters.http.jwt_authn\");\n  filter.mutable_typed_config()->PackFrom(proto_config);\n  return MessageUtil::getJsonStringFromMessageOrDie(filter);\n}\n\nstd::string getFilterConfig(bool use_local_jwks) {\n  return getAuthFilterConfig(ExampleConfig, use_local_jwks);\n}\n\nclass LocalJwksIntegrationTest : public HttpProtocolIntegrationTest {\npublic:\n  LocalJwksIntegrationTest() : registration_(factory_) {}\n\n  HeaderToFilterStateFilterConfig factory_;\n  Registry::InjectFactory<Server::Configuration::NamedHttpFilterConfigFactory> registration_;\n};\n\nINSTANTIATE_TEST_SUITE_P(Protocols, LocalJwksIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\n// With local Jwks, this test verifies a request is passed with a good Jwt token.\nTEST_P(LocalJwksIntegrationTest, WithGoodToken) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  waitForNextUpstreamRequest();\n  const auto payload_entry =\n      upstream_request_->headers().get(Http::LowerCaseString(\"sec-istio-auth-userinfo\"));\n  EXPECT_FALSE(payload_entry.empty());\n  EXPECT_EQ(payload_entry[0]->value().getStringView(), ExpectedPayloadValue);\n  // Verify the token is removed.\n  EXPECT_TRUE(upstream_request_->headers().get(Http::CustomHeaders::get().Authorization).empty());\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}\n\n// With local Jwks, this test verifies a request is rejected with an expired Jwt token.\nTEST_P(LocalJwksIntegrationTest, ExpiredToken) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(ExpiredToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n  EXPECT_EQ(1, response->headers().get(Http::Headers::get().WWWAuthenticate).size());\n  EXPECT_EQ(\n      \"Bearer realm=\\\"http://host/\\\", error=\\\"invalid_token\\\"\",\n      response->headers().get(Http::Headers::get().WWWAuthenticate)[0]->value().getStringView());\n}\n\nTEST_P(LocalJwksIntegrationTest, MissingToken) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      \"Bearer realm=\\\"http://host/\\\"\",\n      response->headers().get(Http::Headers::get().WWWAuthenticate)[0]->value().getStringView());\n}\n\nTEST_P(LocalJwksIntegrationTest, ExpiredTokenHeadReply) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"HEAD\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(ExpiredToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      \"Bearer realm=\\\"http://host/\\\", error=\\\"invalid_token\\\"\",\n      response->headers().get(Http::Headers::get().WWWAuthenticate)[0]->value().getStringView());\n\n  EXPECT_NE(\"0\", response->headers().getContentLengthValue());\n  EXPECT_THAT(response->body(), ::testing::IsEmpty());\n}\n\n// This test verifies a request is passed with a path that don't match any requirements.\nTEST_P(LocalJwksIntegrationTest, NoRequiresPath) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/foo\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n  });\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}\n\n// This test verifies a CORS preflight request without JWT token is allowed.\nTEST_P(LocalJwksIntegrationTest, CorsPreflight) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"OPTIONS\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"access-control-request-method\", \"GET\"},\n      {\"origin\", \"test-origin\"},\n  });\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}\n\n// This test verifies JwtRequirement specified from filter state rules\nTEST_P(LocalJwksIntegrationTest, FilterStateRequirement) {\n  // A config with metadata rules.\n  const std::string auth_filter_conf = R\"(\n  providers:\n    example_provider:\n      issuer: https://example.com\n      audiences:\n      - example_service\n  filter_state_rules:\n    name: jwt_selector\n    requires:\n      example_provider:\n        provider_name: example_provider\n)\";\n\n  config_helper_.prependFilter(getAuthFilterConfig(auth_filter_conf, true));\n  config_helper_.prependFilter(absl::StrCat(\"name: \", HeaderToFilterStateFilterName));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  struct TestCase {\n    std::vector<std::pair<std::string, std::string>> extra_headers;\n    std::string expected_status;\n  };\n\n  const TestCase test_cases[] = {\n      // Case1: not set metadata, so Jwt is not required, expect 200\n      {\n          // Empty extra headers\n          {},\n          \"200\",\n      },\n\n      // Case2: requirement is set in the metadata, but missing token, expect 401\n      {\n          // selector header, but not token header\n          {\n              {\"jwt_selector\", \"example_provider\"},\n          },\n          \"401\",\n      },\n\n      // Case 3: requirement is set in the metadata, token is good, expect 200\n      {\n          // selector header, and token header\n          {\n              {\"jwt_selector\", \"example_provider\"},\n              {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n          },\n          \"200\",\n      },\n  };\n\n  for (const auto& test : test_cases) {\n    Http::TestRequestHeaderMapImpl headers{\n        {\":method\", \"GET\"},\n        {\":path\", \"/foo\"},\n        {\":scheme\", \"http\"},\n        {\":authority\", \"host\"},\n    };\n    for (const auto& h : test.extra_headers) {\n      headers.addCopy(h.first, h.second);\n    }\n    auto response = codec_client_->makeHeaderOnlyRequest(headers);\n\n    if (test.expected_status == \"200\") {\n      waitForNextUpstreamRequest();\n      upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n    }\n\n    ASSERT_TRUE(response->waitForEndStream());\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(test.expected_status, response->headers().getStatusValue());\n  }\n}\n\n// The test case with a fake upstream for remote Jwks server.\nclass RemoteJwksIntegrationTest : public HttpProtocolIntegrationTest {\npublic:\n  void createUpstreams() override {\n    HttpProtocolIntegrationTest::createUpstreams();\n    // for Jwks upstream.\n    addFakeUpstream(GetParam().upstream_protocol);\n  }\n\n  void initializeFilter(bool add_cluster) {\n    config_helper_.prependFilter(getFilterConfig(false));\n\n    if (add_cluster) {\n      config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n        auto* jwks_cluster = bootstrap.mutable_static_resources()->add_clusters();\n        jwks_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);\n        jwks_cluster->set_name(\"pubkey_cluster\");\n      });\n    } else {\n      config_helper_.skipPortUsageValidation();\n    }\n\n    initialize();\n  }\n\n  void initializeAsyncFetchFilter(bool fast_listener) {\n    config_helper_.prependFilter(getAsyncFetchFilterConfig(ExampleConfig, fast_listener));\n\n    config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      auto* jwks_cluster = bootstrap.mutable_static_resources()->add_clusters();\n      jwks_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);\n      jwks_cluster->set_name(\"pubkey_cluster\");\n    });\n\n    initialize();\n  }\n\n  void waitForJwksResponse(const std::string& status, const std::string& jwks_body) {\n    AssertionResult result =\n        fake_upstreams_[1]->waitForHttpConnection(*dispatcher_, fake_jwks_connection_);\n    RELEASE_ASSERT(result, result.message());\n    result = fake_jwks_connection_->waitForNewStream(*dispatcher_, jwks_request_);\n    RELEASE_ASSERT(result, result.message());\n    result = jwks_request_->waitForEndStream(*dispatcher_);\n    RELEASE_ASSERT(result, result.message());\n\n    Http::TestResponseHeaderMapImpl response_headers{{\":status\", status}};\n    jwks_request_->encodeHeaders(response_headers, false);\n    Buffer::OwnedImpl response_data1(jwks_body);\n    jwks_request_->encodeData(response_data1, true);\n  }\n\n  void cleanup() {\n    codec_client_->close();\n    if (fake_jwks_connection_ != nullptr) {\n      AssertionResult result = fake_jwks_connection_->close();\n      RELEASE_ASSERT(result, result.message());\n      result = fake_jwks_connection_->waitForDisconnect();\n      RELEASE_ASSERT(result, result.message());\n    }\n    if (fake_upstream_connection_ != nullptr) {\n      AssertionResult result = fake_upstream_connection_->close();\n      RELEASE_ASSERT(result, result.message());\n      result = fake_upstream_connection_->waitForDisconnect();\n      RELEASE_ASSERT(result, result.message());\n    }\n  }\n\n  FakeHttpConnectionPtr fake_jwks_connection_{};\n  FakeStreamPtr jwks_request_{};\n};\n\nINSTANTIATE_TEST_SUITE_P(Protocols, RemoteJwksIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\n// With remote Jwks, this test verifies a request is passed with a good Jwt token\n// and a good public key fetched from a remote server.\nTEST_P(RemoteJwksIntegrationTest, WithGoodToken) {\n  initializeFilter(/*add_cluster=*/true);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  waitForJwksResponse(\"200\", PublicKey);\n\n  waitForNextUpstreamRequest();\n\n  const auto payload_entry =\n      upstream_request_->headers().get(Http::LowerCaseString(\"sec-istio-auth-userinfo\"));\n  EXPECT_FALSE(payload_entry.empty());\n  EXPECT_EQ(payload_entry[0]->value().getStringView(), ExpectedPayloadValue);\n  // Verify the token is removed.\n  EXPECT_TRUE(upstream_request_->headers().get(Http::CustomHeaders::get().Authorization).empty());\n\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n\n  cleanup();\n}\n\n// With remote Jwks, this test verifies a request is rejected even with a good Jwt token\n// when the remote jwks server replied with 500.\nTEST_P(RemoteJwksIntegrationTest, FetchFailedJwks) {\n  initializeFilter(/*add_cluster=*/true);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  // Fails the jwks fetching.\n  waitForJwksResponse(\"500\", \"\");\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      \"Bearer realm=\\\"http://host/\\\", error=\\\"invalid_token\\\"\",\n      response->headers().get(Http::Headers::get().WWWAuthenticate)[0]->value().getStringView());\n\n  cleanup();\n}\n\nTEST_P(RemoteJwksIntegrationTest, FetchFailedMissingCluster) {\n  initializeFilter(/*add_cluster=*/false);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      \"Bearer realm=\\\"http://host/\\\", error=\\\"invalid_token\\\"\",\n      response->headers().get(Http::Headers::get().WWWAuthenticate)[0]->value().getStringView());\n  cleanup();\n}\n\nTEST_P(RemoteJwksIntegrationTest, WithGoodTokenAsyncFetch) {\n  on_server_init_function_ = [this]() { waitForJwksResponse(\"200\", PublicKey); };\n  initializeAsyncFetchFilter(false);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  waitForNextUpstreamRequest();\n\n  const auto payload_entry =\n      upstream_request_->headers().get(Http::LowerCaseString(\"sec-istio-auth-userinfo\"));\n  EXPECT_FALSE(payload_entry.empty());\n  EXPECT_EQ(payload_entry[0]->value().getStringView(), ExpectedPayloadValue);\n  // Verify the token is removed.\n  EXPECT_TRUE(upstream_request_->headers().get(Http::CustomHeaders::get().Authorization).empty());\n\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n\n  cleanup();\n}\n\nTEST_P(RemoteJwksIntegrationTest, WithGoodTokenAsyncFetchFast) {\n  on_server_init_function_ = [this]() { waitForJwksResponse(\"200\", PublicKey); };\n  initializeAsyncFetchFilter(true);\n\n  // This test is only expecting one jwks fetch, but there is a race condition in the test:\n  // In fast fetch mode, the listener is activated without waiting for jwks fetch to be\n  // completed. When the first request comes at the worker thread, jwks fetch could be at\n  // any state at the main thread. If its result is not saved into jwks thread local slot,\n  // the first request will trigger a second jwks fetch, this is not expected, test will fail.\n  // To avoid such race condition, before making the first request, wait for the first\n  // fetch stats to be updated.\n  test_server_->waitForCounterGe(\"http.config_test.jwt_authn.jwks_fetch_success\", 1);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  waitForNextUpstreamRequest();\n\n  const auto payload_entry =\n      upstream_request_->headers().get(Http::LowerCaseString(\"sec-istio-auth-userinfo\"));\n  EXPECT_FALSE(payload_entry.empty());\n  EXPECT_EQ(payload_entry[0]->value().getStringView(), ExpectedPayloadValue);\n  // Verify the token is removed.\n  EXPECT_TRUE(upstream_request_->headers().get(Http::CustomHeaders::get().Authorization).empty());\n\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n\n  cleanup();\n}\n\nTEST_P(RemoteJwksIntegrationTest, WithFailedJwksAsyncFetch) {\n  on_server_init_function_ = [this]() { waitForJwksResponse(\"500\", \"\"); };\n  initializeAsyncFetchFilter(false);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n\n  cleanup();\n}\n\nTEST_P(RemoteJwksIntegrationTest, WithFailedJwksAsyncFetchFast) {\n  on_server_init_function_ = [this]() { waitForJwksResponse(\"500\", \"\"); };\n  initializeAsyncFetchFilter(true);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n\n  cleanup();\n}\n\nclass PerRouteIntegrationTest : public HttpProtocolIntegrationTest {\npublic:\n  void setup(const std::string& filter_config, const PerRouteConfig& per_route) {\n    config_helper_.prependFilter(getAuthFilterConfig(filter_config, true));\n\n    config_helper_.addConfigModifier(\n        [per_route](\n            envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n                hcm) {\n          auto* virtual_host = hcm.mutable_route_config()->mutable_virtual_hosts(0);\n          auto& per_route_any =\n              (*virtual_host->mutable_routes(0)\n                    ->mutable_typed_per_filter_config())[\"envoy.filters.http.jwt_authn\"];\n          per_route_any.PackFrom(per_route);\n        });\n\n    initialize();\n  }\n};\n\nINSTANTIATE_TEST_SUITE_P(Protocols, PerRouteIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\n// This test verifies per-route config disabled.\nTEST_P(PerRouteIntegrationTest, PerRouteConfigDisabled) {\n  // per-route config has disabled flag.\n  PerRouteConfig per_route;\n  per_route.set_disabled(true);\n  // Use a normal filter config that requires jwt_auth.\n  setup(ExampleConfig, per_route);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // So the request without a JWT token is OK.\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n  });\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}\n\n// This test verifies per-route config with wrong requirement_name\nTEST_P(PerRouteIntegrationTest, PerRouteConfigWrongRequireName) {\n  // A config with a requirement_map\n  const std::string filter_conf = R\"(\n  providers:\n    example_provider:\n      issuer: https://example.com\n      audiences:\n      - example_service\n  requirement_map:\n    abc:\n      provider_name: \"example_provider\"\n)\";\n\n  // Per-route config has a wrong requirement_name.\n  PerRouteConfig per_route;\n  per_route.set_requirement_name(\"wrong-requirement-name\");\n  setup(filter_conf, per_route);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // So the request with a good Jwt token is rejected.\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"403\", response->headers().getStatusValue());\n}\n\n// This test verifies per-route config with correct requirement_name\nTEST_P(PerRouteIntegrationTest, PerRouteConfigOK) {\n  // A config with a requirement_map\n  const std::string filter_conf = R\"(\n  providers:\n    example_provider:\n      issuer: https://example.com\n      audiences:\n      - example_service\n  requirement_map:\n    abc:\n      provider_name: \"example_provider\"\n)\";\n\n  // Per-route config with correct requirement_name\n  PerRouteConfig per_route;\n  per_route.set_requirement_name(\"abc\");\n  setup(filter_conf, per_route);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // So the request with a JWT token is OK.\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n\n  // A request with missing token is rejected.\n  auto response1 = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n  });\n\n  ASSERT_TRUE(response1->waitForEndStream());\n  ASSERT_TRUE(response1->complete());\n  EXPECT_EQ(\"401\", response1->headers().getStatusValue());\n}\n\n} // namespace\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\n\n// RS256 private key\n//-----BEGIN PRIVATE KEY-----\n//    MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC6n3u6qsX0xY49\n//    o+TBJoF64A8s6v0UpxpYZ1UQbNDh/dmrlYpVmjDH1MIHGYiY0nWqZSLXekHyi3Az\n//    +XmV9jUAUEzFVtAJRee0ui+ENqJK9injAYOMXNCJgD6lSryHoxRkGeGV5iuRTteU\n//    IHA1XI3yo0ySksDsoVljP7jzoadXY0gknH/gEZrcd0rBAbGLa2O5CxC9qjlbjGZJ\n//    VpoRaikHAzLZCaWFIVC49SlNrLBOpRxSr/pJ8AeFnggNr8XER3ZzbPyAUa1+y31x\n//    jeVFh/5z9l1uhjeao31K7f6PfPmvZIdaWEH8s0CPJaUEay9sY+VOoPOJhDBk3hoa\n//    ypUpBv1XAgMBAAECggEAc5HaJJIm/trsqD17pyV6X6arnyxyx7xn80Eii4ZnoNv8\n//    VWbJARP4i3e1JIJqdgE3PutctUYP2u0A8h7XbcfHsMcJk9ecA3IX+HKohF71CCkD\n//    bYH9fgnoVo5lvSTYNcMHGKpyacrdRiImHKQt+M21VgJMpCRfdurAmVbX6YA9Sj6w\n//    SBFrZbWkBHiHg7w++xKr+VeTHW/8fXI5bvSPAm/XB6dDKAcSXYiJJJhIoaVR9cHn\n//    1ePRDLpEwfDpBHeepd/S3qR37mIbHmo8SVytDY2xTUaIoaRfXRWGMYSyxl0y4RsZ\n//    Vo6Tp9Tj2fyohvB/S+lE34zhxnsHToK2JZvPeoyHCQKBgQDyEcjaUZiPdx7K63CT\n//    d57QNYC6DTjtKWnfO2q/vAVyAPwS30NcVuXj3/1yc0L+eExpctn8tcLfvDi1xZPY\n//    dW2L3SZKgRJXL+JHTCEkP8To/qNLhBqitcKYwp0gtpoZbUjZdZwn18QJx7Mw/nFC\n//    lJhSYRl+FjVolY3qBaS6eD7imwKBgQDFXNmeAV5FFF0FqGRsLYl0hhXTR6Hi/hKQ\n//    OyRALBW9LUKbsazwWEFGRlqbEWd1OcOF5SSV4d3u7wLQRTDeNELXUFvivok12GR3\n//    gNl9nDJ5KKYGFmqxM0pzfbT5m3Lsrr2FTIq8gM9GBpQAOmzQIkEu62yELtt2rRf0\n//    1pTh+UbN9QKBgF88kAEUySjofLzpFElwbpML+bE5MoRcHsMs5Tq6BopryMDEBgR2\n//    S8vzfAtjPaBQQ//Yp9q8yAauTsF1Ek2/JXI5d68oSMb0l9nlIcTZMedZB3XWa4RI\n//    bl8bciZEsSv/ywGDPASQ5xfR8bX85SKEw8jlWto4cprK/CJuRfj3BgaxAoGAAmQf\n//    ltR5aejXP6xMmyrqEWlWdlrV0UQ2wVyWEdj24nXb6rr6V2caU1mi22IYmMj8X3Dp\n//    Qo+b+rsWk6Ni9i436RfmJRcd3nMitHfxKp5r1h/x8vzuifsPGdsaCDQj7k4nqafF\n//    vobo+/Y0cNREYTkpBQKBLBDNQ+DQ+3xmDV7RxskCgYBCo6u2b/DZWFLoq3VpAm8u\n//    1ZgL8qxY/bbyA02IKF84QPFczDM5wiLjDGbGnOcIYYMvTHf1LJU4FozzYkB0GicX\n//    Y0tBQIHaaLWbPk1RZdPfR9kAp16iwk8H+V4UVjLfsTP7ocEfNCzZztmds83h8mTL\n//    DSwE5aY76Cs8XLcF/GNJRQ==\n//-----END PRIVATE KEY-----\n\n// A good public key\nconst char PublicKey[] = R\"(\n{\n  \"keys\": [\n    {\n      \"kty\": \"RSA\",\n      \"alg\": \"RS256\",\n      \"use\": \"sig\",\n      \"kid\": \"62a93512c9ee4c7f8067b5a216dade2763d32a47\",\n      \"n\": \"up97uqrF9MWOPaPkwSaBeuAPLOr9FKcaWGdVEGzQ4f3Zq5WKVZowx9TCBxmImNJ1qmUi13pB8otwM_l5lfY1AFBMxVbQCUXntLovhDaiSvYp4wGDjFzQiYA-pUq8h6MUZBnhleYrkU7XlCBwNVyN8qNMkpLA7KFZYz-486GnV2NIJJx_4BGa3HdKwQGxi2tjuQsQvao5W4xmSVaaEWopBwMy2QmlhSFQuPUpTaywTqUcUq_6SfAHhZ4IDa_FxEd2c2z8gFGtfst9cY3lRYf-c_ZdboY3mqN9Su3-j3z5r2SHWlhB_LNAjyWlBGsvbGPlTqDziYQwZN4aGsqVKQb9Vw\",\n      \"e\": \"AQAB\"\n    },\n    {\n      \"kty\": \"RSA\",\n      \"alg\": \"RS256\",\n      \"use\": \"sig\",\n      \"kid\": \"b3319a147514df7ee5e4bcdee51350cc890cc89e\",\n      \"n\": \"up97uqrF9MWOPaPkwSaBeuAPLOr9FKcaWGdVEGzQ4f3Zq5WKVZowx9TCBxmImNJ1qmUi13pB8otwM_l5lfY1AFBMxVbQCUXntLovhDaiSvYp4wGDjFzQiYA-pUq8h6MUZBnhleYrkU7XlCBwNVyN8qNMkpLA7KFZYz-486GnV2NIJJx_4BGa3HdKwQGxi2tjuQsQvao5W4xmSVaaEWopBwMy2QmlhSFQuPUpTaywTqUcUq_6SfAHhZ4IDa_FxEd2c2z8gFGtfst9cY3lRYf-c_ZdboY3mqN9Su3-j3z5r2SHWlhB_LNAjyWlBGsvbGPlTqDziYQwZN4aGsqVKQb9Vw\",\n      \"e\": \"AQAB\"\n    }\n  ]\n}\n)\";\n\n// A good config.\nconst char ExampleConfig[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    audiences:\n    - example_service\n    - http://example_service1\n    - https://example_service2/\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n        timeout:\n          seconds: 5\n      cache_duration:\n        seconds: 600\n    forward_payload_header: sec-istio-auth-userinfo\nrules:\n- match:\n    path: \"/\"\n  requires:\n    provider_name: \"example_provider\"\nbypass_cors_preflight: true\n)\";\n\n// The name of provider for above config.\nconst char ProviderName[] = \"example_provider\";\n\n// Payload:\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"aud\":\"example_service\",\"exp\":2001001001}\nconst char GoodToken[] = \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2V4YW1wbGUu\"\n                         \"Y29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIsImV4cCI6MjAwMTAwMTAwMSwiY\"\n                         \"XVkIjoiZXhhbXBsZV9zZXJ2aWNlIn0.cuui_Syud76B0tqvjESE8IZbX7vzG6xA-M\"\n                         \"Daof1qEFNIoCFT_YQPkseLSUSR2Od3TJcNKk-dKjvUEL1JW3kGnyC1dBx4f3-Xxro\"\n                         \"yL23UbR2eS8TuxO9ZcNCGkjfvH5O4mDb6cVkFHRDEolGhA7XwNiuVgkGJ5Wkrvshi\"\n                         \"h6nqKXcPNaRx9lOaRWg2PkE6ySNoyju7rNfunXYtVxPuUIkl0KMq3WXWRb_cb8a_Z\"\n                         \"EprqSZUzi_ZzzYzqBNVhIJujcNWij7JRra2sXXiSAfKjtxHQoxrX8n4V1ySWJ3_1T\"\n                         \"H_cJcdfS_RKP7YgXRWC0L16PNF5K7iqRqmjKALNe83ZFnFIw\";\n\n// Payload:\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"exp\":null}\nconst char NonExpiringToken[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2V4YW1wbGUu\"\n    \"Y29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIsImlhdCI6MTUzMzE3NTk0Mn0.OSh-\"\n    \"AcY9dCUibXiIZzPlTdEsYH8xP3QkCJDesO3LVu4ndgTrxDnNuR3I4_oV4tjtirmLZD3sx\"\n    \"96wmLiIhOyqj3nipIdf_aQWcmET0XoRqGixOKse5FlHyU_VC1Jj9AlMvSz9zyCvKxMyP0\"\n    \"CeA-bhI_Qs-I9vBPK8pd-EUOespUqWMQwNdtrOdXLcvF8EA5BV5G2qRGzCU0QJaW0Dpyj\"\n    \"YF7ZCswRGorc2oMt5duXSp3-L1b9dDrnLwroxUrmQIZz9qvfwdDR-guyYSjKVQu5NJAyy\"\n    \"sd8XKNzmHqJ2fYhRjc5s7l5nIWTDyBXSdPKQ8cBnfFKoxaRhmMBjdEn9RB7r6A\";\n\n// An expired token\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"aud\":\"example_service\",\"exp\":1205005587}\nconst char ExpiredToken[] = \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2V4YW1wbGUu\"\n                            \"Y29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIsImV4cCI6MTIwNTAwNTU4NywiY\"\n                            \"XVkIjoiZXhhbXBsZV9zZXJ2aWNlIn0.izDa6aHNgbsbeRzucE0baXIP7SXOrgopYQ\"\n                            \"ALLFAsKq_N0GvOyqpAZA9nwCAhqCkeKWcL-9gbQe3XJa0KN3FPa2NbW4ChenIjmf2\"\n                            \"QYXOuOQaDu9QRTdHEY2Y4mRy6DiTZAsBHWGA71_cLX-rzTSO_8aC8eIqdHo898oJw\"\n                            \"3E8ISKdryYjayb9X3wtF6KLgNomoD9_nqtOkliuLElD8grO0qHKI1xQurGZNaoeyi\"\n                            \"V1AdwgX_5n3SmQTacVN0WcSgk6YJRZG6VE8PjxZP9bEameBmbSB0810giKRpdTU1-\"\n                            \"RJtjq6aCSTD4CYXtW38T5uko4V-S4zifK3BXeituUTebkgoA\";\n\n// An NotYetValid token\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"aud\":\"example_service\",\"nbf\":9223372036854775807}\nconst char NotYetValidToken[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\"\n    \"eyJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIsImF1\"\n    \"ZCI6ImV4YW1wbGVfc2VydmljZSIsIm5iZiI6OTIyMzM3MjAzNjg1NDc3NTgwN30K\"\n    \".izDa6aHNgbsbeRzucE0baXIP7SXOrgopYQ\"\n    \"ALLFAsKq_N0GvOyqpAZA9nwCAhqCkeKWcL-9gbQe3XJa0KN3FPa2NbW4ChenIjmf2\"\n    \"QYXOuOQaDu9QRTdHEY2Y4mRy6DiTZAsBHWGA71_cLX-rzTSO_8aC8eIqdHo898oJw\"\n    \"3E8ISKdryYjayb9X3wtF6KLgNomoD9_nqtOkliuLElD8grO0qHKI1xQurGZNaoeyi\"\n    \"V1AdwgX_5n3SmQTacVN0WcSgk6YJRZG6VE8PjxZP9bEameBmbSB0810giKRpdTU1-\"\n    \"RJtjq6aCSTD4CYXtW38T5uko4V-S4zifK3BXeituUTebkgoA\";\n\n// A token with \"aud\" as invalid_service\n// Payload:\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"aud\":\"invalid_service\",\"exp\":2001001001}\nconst char InvalidAudToken[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2V4YW1wbGUu\"\n    \"Y29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIsImV4cCI6MjAwMTAwMTAwMSwiY\"\n    \"XVkIjoiaW52YWxpZF9zZXJ2aWNlIn0.B9HuVXpRDVYIvApfNQmE_l5fEMPEiPdi-s\"\n    \"dKbTione8I_UsnYHccKZVegaF6f2uyWhAvaTPgaMosyDlJD6skadEcmZD0V4TzsYK\"\n    \"v7eP5FQga26hZ1Kra7n9hAq4oFfH0J8aZLOvDV3tAgCNRXlh9h7QiBPeDNQlwztqE\"\n    \"csyp1lHI3jdUhsn3InIn-vathdx4PWQWLVb-74vwsP-END-MGlOfu_TY5OZUeY-GB\"\n    \"E4Wr06aOSU2XQjuNr6y2WJGMYFsKKWfF01kHSuyc9hjnq5UI19WrOM8s7LFP4w2iK\"\n    \"WFIPUGmPy3aM0TiF2oFOuuMxdPR3HNdSG7EWWRwoXv7n__jA\";\n\n// A token with non exist kid\n// Payload:\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"aud\":\"example_service\",\"exp\":2001001001}\nconst char NonExistKidToken[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\"\n    \"eyJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIs\"\n    \"ImF1ZCI6ImV4YW1wbGVfc2VydmljZSIsImV4cCI6MjAwMTAwMTAwMX0.\"\n    \"n45uWZfIBZwCIPiL0K8Ca3tmm-ZlsDrC79_\"\n    \"vXCspPwk5oxdSn983tuC9GfVWKXWUMHe11DsB02b19Ow-\"\n    \"fmoEzooTFn65Ml7G34nW07amyM6lETiMhNzyiunctplOr6xKKJHmzTUhfTirvDeG-q9n24-\"\n    \"8lH7GP8GgHvDlgSM9OY7TGp81bRcnZBmxim_UzHoYO3_\"\n    \"c8OP4ZX3xG5PfihVk5G0g6wcHrO70w0_64JgkKRCrLHMJSrhIgp9NHel_\"\n    \"CNOnL0AjQKe9IGblJrMuouqYYS0zEWwmOVUWUSxQkoLpldQUVefcfjQeGjz8IlvktRa77FYe\"\n    \"xfP590ACPyXrivtsxg\";\n\n// {\"iss\":\"https://other.com\",\"sub\":\"test@other.com\",\"aud\":\"other_service\",\"exp\":2001001001}\nconst char OtherGoodToken[] =\n    \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.\"\n    \"eyJpc3MiOiJodHRwczovL290aGVyLmNvbSIsInN1YiI6InRlc3RAb3RoZXIuY29tIiwiYXVkIjoib3RoZXJfc2VydmljZS\"\n    \"IsImV4cCI6MjAwMTAwMTAwMX0.R0GR2rnRTg_gWzDvuO-BXVMmw3-vyBspV_kUQ4zvIdO-_\"\n    \"1icaWzbioPTPEyoViWuErNYxaZ5YFBoD6Zk_hIe1YWoSJr9QRwxWA4CWcasJdBXPq2mMETt8VjAiXE_\"\n    \"aIrJOLIlP786GLjVgTsnvhaDUJyU7xUdoi9HRjEBYcdjNPvxJutoby8MypAkwdGxjl4H4Z01gomgWyUDRRy47OKI_\"\n    \"buwXk5M6d-\"\n    \"drRvLcvlT5gB4adOIOlmhm8xtXgYpvqrXfmMJCHbP9no7JATFaTEAkmA3OOxDsaOju4BFgMtRZtDM8p12QQG0rFl_FE-\"\n    \"2FqYX9qA4q41HJ4vxTSxgObeLGA\";\n\n// Expected base64 payload value.\nconst char ExpectedPayloadValue[] = \"eyJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIiwic3ViIjoidGVzdEBleGFtcG\"\n                                    \"xlLmNvbSIsImV4cCI6MjAwMTAwMTAwMSwiYXVkIjoiZXhhbXBsZV9zZXJ2\"\n                                    \"aWNlIn0\";\n\nconst char ExpectedPayloadValueWithPadding[] =\n    \"eyJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIiwic3ViIjoidGVzdEBleGFtcG\"\n    \"xlLmNvbSIsImV4cCI6MjAwMTAwMTAwMSwiYXVkIjoiZXhhbXBsZV9zZXJ2\"\n    \"aWNlIn0=\";\n\n// Base64 decoded Payload JSON\nconst char ExpectedPayloadJSON[] = R\"(\n{\n  \"iss\":\"https://example.com\",\n  \"sub\":\"test@example.com\",\n  \"exp\":2001001001,\n  \"aud\":\"example_service\"\n}\n)\";\n\nconst char ExpectedHeaderJSON[] = R\"(\n{\n  \"alg\": \"RS256\",\n  \"typ\": \"JWT\"\n}\n)\";\n\nconst char ExpectedPayloadAndHeaderJSON[] = R\"(\n{\n  \"my_payload\":{\n    \"iss\":\"https://example.com\",\n    \"exp\":2001001001,\n    \"sub\":\"test@example.com\",\n    \"aud\":\"example_service\"\n  },\n  \"my_header\":{\n    \"typ\":\"JWT\",\n    \"alg\":\"RS256\"\n  }\n}\n)\";\n\n// Token copied from https://github.com/google/jwt_verify_lib/blob/master/src/verify_jwk_ec_test.cc\n// Use jwt.io to modify payload as:\n// {\n//  \"iss11\": \"628645741881-noabiu23f5a8m8ovd8ucv698lj78vv0l@developer.gserviceaccount.com\",\n//  \"sub\": \"628645741881-noabiu23f5a8m8ovd8ucv698lj78vv0l@developer.gserviceaccount.com\",\n//  \"aud\": \"example_service\"\n// }\nconst char ES256WithoutIssToken[] =\n    \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFiYyJ9.\"\n    \"eyJpc3MxMSI6IjYyODY0NTc0MTg4MS1ub2FiaXUyM2Y1YThtOG92ZDh1Y3Y2OThsajc4dnYwbEBkZXZlbG9wZXIuZ3Nlcn\"\n    \"ZpY2VhY2NvdW50LmNvbSIsInN1YiI6IjYyODY0NTc0MTg4MS1ub2FiaXUyM2Y1YThtOG92ZDh1Y3Y2OThsajc4dnYwbEBk\"\n    \"ZXZlbG9wZXIuZ3NlcnZpY2VhY2NvdW50LmNvbSIsImF1ZCI6ImV4YW1wbGVfc2VydmljZSJ9.f-_\"\n    \"NAdznQK9o93AZTqNawu1yal1igNLgYvuj0JzW9SVmJJQuBT_12wJi9XQzZLFwSFn6D3f7bPWSZQlScTFSMg\";\n\n// Public key for above ES256 tokens.\nconst char ES256PublicKey[] = R\"(\n{\n  \"keys\": [\n    {\n      \"kty\": \"EC\",\n      \"crv\": \"P-256\",\n      \"alg\": \"ES256\",\n      \"kid\": \"abc\",\n      \"x\": \"EB54wykhS7YJFD6RYJNnwbWEz3cI7CF5bCDTXlrwI5k\",\n      \"y\": \"92bCBTvMFQ8lKbS2MbgjT3YfmYo6HnPEE2tsAqWUJw8\"\n    }\n  ]\n}\n)\";\n\n// Config with requires_all requirement\nconst char RequiresAllConfig[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    audiences:\n    - example_service\n    - http://example_service1\n    - https://example_service2/\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    from_params: [\"jwt_a\"]\n    forward_payload_header: example-auth-userinfo\n  other_provider:\n    issuer: https://other.com\n    audiences:\n    - other_service\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    from_params: [\"jwt_b\"]\n    forward_payload_header: other-auth-userinfo\nrules:\n- match:\n    path: \"/requires-all\"\n  requires:\n    requires_all:\n      requirements:\n      - provider_name: \"example_provider\"\n      - provider_name: \"other_provider\"\n)\";\n// Config with requires_any requirement\nconst char RequiresAnyConfig[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    audiences:\n    - example_service\n    - http://example_service1\n    - https://example_service2/\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    from_headers:\n    - name: a\n      value_prefix: \"Bearer \"\n    - name: b\n      value_prefix: \"Bearer \"\n    forward_payload_header: example-auth-userinfo\n  other_provider:\n    issuer: https://other.com\n    audiences:\n    - other_service\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    from_headers:\n    - name: a\n      value_prefix: \"Bearer \"\n    - name: b\n      value_prefix: \"Bearer \"\n    forward_payload_header: other-auth-userinfo\nrules:\n- match:\n    path: \"/requires-any\"\n  requires:\n    requires_any:\n      requirements:\n      - provider_name: \"example_provider\"\n      - provider_name: \"other_provider\"\n)\";\n\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n"], "fixing_code": ["1.22.0 (pending)\n================\n\nIncompatible Behavior Changes\n-----------------------------\n*Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\n* tls: set TLS v1.2 as the default minimal version for servers. Users can still explicitly opt-in to 1.0 and 1.1 using :ref:`tls_minimum_protocol_version <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsParameters.tls_minimum_protocol_version>`.\n\nMinor Behavior Changes\n----------------------\n*Changes that may cause incompatibilities for some users, but should not for most*\n\n* dynamic_forward_proxy: if a DNS resolution fails, failing immediately with a specific resolution error, rather than finishing up all local filters and failing to select an upstream host.\n* ext_authz: added requested server name in ext_authz network filter for auth review.\n* file: changed disk based files to truncate files which are not being appended to. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.append_or_truncate`` to false.\n* grpc: flip runtime guard ``envoy.reloadable_features.enable_grpc_async_client_cache`` to be default enabled. async grpc client created through getOrCreateRawAsyncClient will be cached by default.\n* http: avoiding delay-close for HTTP/1.0 responses framed by connection: close as well as HTTP/1.1 if the request is fully read. This means for responses to such requests, the FIN will be sent immediately after the response. This behavior can be temporarily reverted by setting ``envoy.reloadable_features.skip_delay_close`` to false.  If clients are are seen to be receiving sporadic partial responses and flipping this flag fixes it, please notify the project immediately.\n* http: now the max concurrent streams of http2 connection can not only be adjusted down according to the SETTINGS frame but also can be adjusted up, of course, it can not exceed the configured upper bounds. This fix is guarded by ``envoy.reloadable_features.http2_allow_capacity_increase_by_settings``.\n* http: when writing custom filters, `injectEncodedDataToFilterChain` and `injectDecodedDataToFilterChain` now trigger sending of headers if they were not yet sent due to `StopIteration`. Previously, calling one of the inject functions in that state would trigger an assertion. See issue #19891 for more details.\n* perf: ssl contexts are now tracked without scan based garbage collection and greatly improved the performance on secret update.\n\nBug Fixes\n---------\n*Changes expected to improve the state of the world and are unlikely to have negative effects*\n\n* access_log: fix memory leak when reopening an access log fails. Access logs will now try to be reopened on each subsequent flush attempt after a failure.\n* data plane: fixing error handling where writing to a socket failed while under the stack of processing. This should genreally affect HTTP/3. This behavioral change can be reverted by setting ``envoy.reloadable_features.allow_upstream_inline_write`` to false.\n* eds: fix the eds cluster update by allowing update on the locality of the cluster endpoints. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.support_locality_update_on_eds_cluster_endpoints`` to false.\n* jwt_authn: fixed the crash when a CONNECT request is sent to JWT filter configured with regex match on the Host header.\n* tcp_proxy: fix a crash that occurs when configured for :ref:`upstream tunneling <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.tunneling_config>` and the downstream connection disconnects while the the upstream connection or http/2 stream is still being established.\n* tls: fix a bug while matching a certificate SAN with an exact value in ``match_typed_subject_alt_names`` of a listener where wildcard ``*`` character is not the only character of the dns label. Example, ``baz*.example.net`` and ``*baz.example.net`` and ``b*z.example.net`` will match ``baz1.example.net`` and ``foobaz.example.net`` and ``buzz.example.net``, respectively.\n* upstream: fix stack overflow when a cluster with large number of idle connections is removed.\n* xray: fix the AWS X-Ray tracer extension to not sample the trace if ``sampled=`` keyword is not present in the header ``x-amzn-trace-id``.\n\nRemoved Config or Runtime\n-------------------------\n*Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n\n* access_log: removed ``envoy.reloadable_features.unquote_log_string_values`` and legacy code paths.\n* grpc_bridge_filter: removed ``envoy.reloadable_features.grpc_bridge_stats_disabled`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.hash_multiple_header_values`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.no_chunked_encoding_header_for_304`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.preserve_downstream_scheme`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.require_strict_1xx_and_204_response_headers`` and ``envoy.reloadable_features.send_strict_1xx_and_204_response_headers`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.strip_port_from_connect`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.use_observable_cluster_name`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http_transport_failure_reason_in_body`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.allow_response_for_timeout`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http2_consume_stream_refused_errors`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.internal_redirects_with_body`` and legacy code paths.\n* udp: removed ``envoy.reloadable_features.udp_per_event_loop_read_limit`` and legacy code paths.\n* upstream: removed ``envoy.reloadable_features.health_check.graceful_goaway_handling`` and legacy code paths.\n* xds: removed ``envoy.reloadable_features.vhds_heartbeats`` and legacy code paths.\n\n\nNew Features\n------------\n* access_log: make consistent access_log format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* admin: :http:post:`/logging` now accepts ``/logging?paths=name1:level1,name2:level2,...`` to change multiple log levels at once.\n* config: added new file based xDS configuration via :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`.\n  :ref:`watched_directory <envoy_v3_api_field_config.core.v3.PathConfigSource.watched_directory>` can\n  be used to setup an independent watch for when to reload the file path, for example when using\n  Kubernetes ConfigMaps to deliver configuration. See the linked documentation for more information.\n* cors: add dynamic support for headers ``access-control-allow-methods`` and ``access-control-allow-headers`` in cors.\n* http: added random_value_specifier in :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` to allow random value to be specified from configuration proto.\n* http: added support for :ref:`proxy_status_config <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.proxy_status_config>` for configuring `Proxy-Status <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08>`_ HTTP response header fields.\n* http: make consistent custom header format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* http3: downstream HTTP/3 support is now GA! Upstream HTTP/3 also GA for specific deployments. See :ref:`here <arch_overview_http3>` for details.\n* http3: supports upstream HTTP/3 retries. Automatically retry `0-RTT safe requests <https://www.rfc-editor.org/rfc/rfc7231#section-4.2.1>`_ if they are rejected because they are sent `too early <https://datatracker.ietf.org/doc/html/rfc8470#section-5.2>`_. And automatically retry 0-RTT safe requests if connect attempt fails later on and the cluster is configured with TCP fallback. And add retry on ``http3-post-connect-failure`` policy which allows retry of failed HTTP/3 requests with TCP fallback even after handshake if the cluster is configured with TCP fallback. This feature is guarded by ``envoy.reloadable_features.conn_pool_new_stream_with_early_data_and_http3``.\n* matching: the matching API can now express a match tree that will always match by omitting a matcher at the top level.\n* outlier_detection: :ref:`max_ejection_time_jitter<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>` configuration added to allow adding a random value to the ejection time to prevent 'thundering herd' scenarios. Defaults to 0 so as to not break or change the behavior of existing deployments.\n\nDeprecated\n----------\n\n* config: deprecated :ref:`path <envoy_v3_api_field_config.core.v3.ConfigSource.path>` in favor of\n  :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`\n* http: removing support for long-deprecated old style filter names, e.g. envoy.router, envoy.lua.\n* re2: removed undocumented histograms ``re2.program_size`` and ``re2.exceeded_warn_level``.\n", "#include \"source/extensions/filters/http/jwt_authn/matcher.h\"\n\n#include \"envoy/config/route/v3/route_components.pb.h\"\n#include \"envoy/extensions/filters/http/jwt_authn/v3/config.pb.h\"\n\n#include \"source/common/common/logger.h\"\n#include \"source/common/common/matchers.h\"\n#include \"source/common/common/regex.h\"\n#include \"source/common/router/config_impl.h\"\n\n#include \"absl/strings/match.h\"\n\nusing envoy::config::route::v3::RouteMatch;\nusing envoy::extensions::filters::http::jwt_authn::v3::RequirementRule;\nusing Envoy::Router::ConfigUtility;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\nnamespace {\n\n/**\n * Perform a match against any HTTP header or pseudo-header.\n */\nclass BaseMatcherImpl : public Matcher, public Logger::Loggable<Logger::Id::jwt> {\npublic:\n  BaseMatcherImpl(const RequirementRule& rule)\n      : case_sensitive_(PROTOBUF_GET_WRAPPED_OR_DEFAULT(rule.match(), case_sensitive, true)),\n        config_headers_(Http::HeaderUtility::buildHeaderDataVector(rule.match().headers())) {\n    for (const auto& query_parameter : rule.match().query_parameters()) {\n      config_query_parameters_.push_back(\n          std::make_unique<Router::ConfigUtility::QueryParameterMatcher>(query_parameter));\n    }\n  }\n\n  // Check match for HeaderMatcher and QueryParameterMatcher\n  bool matchRoute(const Http::RequestHeaderMap& headers) const {\n    bool matches = true;\n    // TODO(potatop): matching on RouteMatch runtime is not implemented.\n\n    matches &= Http::HeaderUtility::matchHeaders(headers, config_headers_);\n    if (!config_query_parameters_.empty()) {\n      Http::Utility::QueryParams query_parameters =\n          Http::Utility::parseQueryString(headers.getPathValue());\n      matches &= ConfigUtility::matchQueryParams(query_parameters, config_query_parameters_);\n    }\n    return matches;\n  }\n\nprotected:\n  const bool case_sensitive_;\n\nprivate:\n  std::vector<Http::HeaderUtility::HeaderDataPtr> config_headers_;\n  std::vector<Router::ConfigUtility::QueryParameterMatcherPtr> config_query_parameters_;\n};\n\n/**\n * Perform a match against any path with prefix rule.\n */\nclass PrefixMatcherImpl : public BaseMatcherImpl {\npublic:\n  PrefixMatcherImpl(const RequirementRule& rule)\n      : BaseMatcherImpl(rule), prefix_(rule.match().prefix()),\n        path_matcher_(Matchers::PathMatcher::createPrefix(prefix_, !case_sensitive_)) {}\n\n  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers) && path_matcher_->match(headers.getPathValue())) {\n      ENVOY_LOG(debug, \"Prefix requirement '{}' matched.\", prefix_);\n      return true;\n    }\n    return false;\n  }\n\nprivate:\n  // prefix string\n  const std::string prefix_;\n  const Matchers::PathMatcherConstSharedPtr path_matcher_;\n};\n\n/**\n * Perform a match against any path with a specific path rule.\n */\nclass PathMatcherImpl : public BaseMatcherImpl {\npublic:\n  PathMatcherImpl(const RequirementRule& rule)\n      : BaseMatcherImpl(rule), path_(rule.match().path()),\n        path_matcher_(Matchers::PathMatcher::createExact(path_, !case_sensitive_)) {}\n\n  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers) && path_matcher_->match(headers.getPathValue())) {\n      ENVOY_LOG(debug, \"Path requirement '{}' matched.\", path_);\n      return true;\n    }\n    return false;\n  }\n\nprivate:\n  // path string.\n  const std::string path_;\n  const Matchers::PathMatcherConstSharedPtr path_matcher_;\n};\n\n/**\n * Perform a match against any path with a regex rule.\n * TODO(mattklein123): This code needs dedup with RegexRouteEntryImpl.\n */\nclass RegexMatcherImpl : public BaseMatcherImpl {\npublic:\n  RegexMatcherImpl(const RequirementRule& rule)\n      : BaseMatcherImpl(rule), regex_str_(rule.match().safe_regex().regex()),\n        path_matcher_(Matchers::PathMatcher::createSafeRegex(rule.match().safe_regex())) {\n    ASSERT(rule.match().path_specifier_case() ==\n           envoy::config::route::v3::RouteMatch::PathSpecifierCase::kSafeRegex);\n  }\n\n  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      if (headers.Path() == nullptr) {\n        return false;\n      }\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }\n\nprivate:\n  // raw regex string, for logging.\n  const std::string regex_str_;\n  const Matchers::PathMatcherConstSharedPtr path_matcher_;\n};\n\n/**\n * Perform a match against an HTTP CONNECT request.\n */\nclass ConnectMatcherImpl : public BaseMatcherImpl {\npublic:\n  ConnectMatcherImpl(const RequirementRule& rule) : BaseMatcherImpl(rule) {}\n\n  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (Http::HeaderUtility::isConnect(headers) && BaseMatcherImpl::matchRoute(headers)) {\n      ENVOY_LOG(debug, \"CONNECT requirement matched.\");\n      return true;\n    }\n\n    return false;\n  }\n};\n} // namespace\n\nMatcherConstPtr Matcher::create(const RequirementRule& rule) {\n  switch (rule.match().path_specifier_case()) {\n  case RouteMatch::PathSpecifierCase::kPrefix:\n    return std::make_unique<PrefixMatcherImpl>(rule);\n  case RouteMatch::PathSpecifierCase::kPath:\n    return std::make_unique<PathMatcherImpl>(rule);\n  case RouteMatch::PathSpecifierCase::kSafeRegex:\n    return std::make_unique<RegexMatcherImpl>(rule);\n  case RouteMatch::PathSpecifierCase::kConnectMatcher:\n    return std::make_unique<ConnectMatcherImpl>(rule);\n  case RouteMatch::PathSpecifierCase::PATH_SPECIFIER_NOT_SET:\n    break; // Fall through to PANIC.\n  }\n  PANIC_DUE_TO_CORRUPT_ENUM;\n}\n\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"envoy/config/bootstrap/v3/bootstrap.pb.h\"\n#include \"envoy/extensions/filters/http/jwt_authn/v3/config.pb.h\"\n#include \"envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h\"\n\n#include \"source/common/router/string_accessor_impl.h\"\n#include \"source/extensions/filters/http/common/pass_through_filter.h\"\n\n#include \"test/extensions/filters/http/common/empty_http_filter_config.h\"\n#include \"test/extensions/filters/http/jwt_authn/test_common.h\"\n#include \"test/integration/http_protocol_integration.h\"\n#include \"test/test_common/registry.h\"\n\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtAuthentication;\nusing envoy::extensions::filters::http::jwt_authn::v3::PerRouteConfig;\nusing envoy::extensions::filters::network::http_connection_manager::v3::HttpFilter;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\nnamespace {\n\nconst char HeaderToFilterStateFilterName[] = \"envoy.filters.http.header_to_filter_state_for_test\";\n// This filter extracts a string header from \"header\" and\n// save it into FilterState as name \"state\" as read-only Router::StringAccessor.\nclass HeaderToFilterStateFilter : public Http::PassThroughDecoderFilter {\npublic:\n  HeaderToFilterStateFilter(const std::string& header, const std::string& state)\n      : header_(header), state_(state) {}\n\n  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers, bool) override {\n    const auto entry = headers.get(header_);\n    if (!entry.empty()) {\n      decoder_callbacks_->streamInfo().filterState()->setData(\n          state_, std::make_unique<Router::StringAccessorImpl>(entry[0]->value().getStringView()),\n          StreamInfo::FilterState::StateType::ReadOnly,\n          StreamInfo::FilterState::LifeSpan::FilterChain);\n    }\n    return Http::FilterHeadersStatus::Continue;\n  }\n\nprivate:\n  Http::LowerCaseString header_;\n  std::string state_;\n};\n\nclass HeaderToFilterStateFilterConfig : public Common::EmptyHttpFilterConfig {\npublic:\n  HeaderToFilterStateFilterConfig()\n      : Common::EmptyHttpFilterConfig(HeaderToFilterStateFilterName) {}\n\n  Http::FilterFactoryCb createFilter(const std::string&,\n                                     Server::Configuration::FactoryContext&) override {\n    return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {\n      callbacks.addStreamDecoderFilter(\n          std::make_shared<HeaderToFilterStateFilter>(\"jwt_selector\", \"jwt_selector\"));\n    };\n  }\n};\n\nstd::string getAuthFilterConfig(const std::string& config_str, bool use_local_jwks) {\n  JwtAuthentication proto_config;\n  TestUtility::loadFromYaml(config_str, proto_config);\n\n  if (use_local_jwks) {\n    auto& provider0 = (*proto_config.mutable_providers())[std::string(ProviderName)];\n    provider0.clear_remote_jwks();\n    auto local_jwks = provider0.mutable_local_jwks();\n    local_jwks->set_inline_string(PublicKey);\n  }\n\n  HttpFilter filter;\n  filter.set_name(\"envoy.filters.http.jwt_authn\");\n  filter.mutable_typed_config()->PackFrom(proto_config);\n  return MessageUtil::getJsonStringFromMessageOrDie(filter);\n}\n\nstd::string getAsyncFetchFilterConfig(const std::string& config_str, bool fast_listener) {\n  JwtAuthentication proto_config;\n  TestUtility::loadFromYaml(config_str, proto_config);\n\n  auto& provider0 = (*proto_config.mutable_providers())[std::string(ProviderName)];\n  auto* async_fetch = provider0.mutable_remote_jwks()->mutable_async_fetch();\n  async_fetch->set_fast_listener(fast_listener);\n\n  HttpFilter filter;\n  filter.set_name(\"envoy.filters.http.jwt_authn\");\n  filter.mutable_typed_config()->PackFrom(proto_config);\n  return MessageUtil::getJsonStringFromMessageOrDie(filter);\n}\n\nstd::string getFilterConfig(bool use_local_jwks) {\n  return getAuthFilterConfig(ExampleConfig, use_local_jwks);\n}\n\nclass LocalJwksIntegrationTest : public HttpProtocolIntegrationTest {\npublic:\n  LocalJwksIntegrationTest() : registration_(factory_) {}\n\n  HeaderToFilterStateFilterConfig factory_;\n  Registry::InjectFactory<Server::Configuration::NamedHttpFilterConfigFactory> registration_;\n};\n\nINSTANTIATE_TEST_SUITE_P(Protocols, LocalJwksIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\n// With local Jwks, this test verifies a request is passed with a good Jwt token.\nTEST_P(LocalJwksIntegrationTest, WithGoodToken) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  waitForNextUpstreamRequest();\n  const auto payload_entry =\n      upstream_request_->headers().get(Http::LowerCaseString(\"sec-istio-auth-userinfo\"));\n  EXPECT_FALSE(payload_entry.empty());\n  EXPECT_EQ(payload_entry[0]->value().getStringView(), ExpectedPayloadValue);\n  // Verify the token is removed.\n  EXPECT_TRUE(upstream_request_->headers().get(Http::CustomHeaders::get().Authorization).empty());\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}\n\n// With local Jwks, this test verifies a request is rejected with an expired Jwt token.\nTEST_P(LocalJwksIntegrationTest, ExpiredToken) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(ExpiredToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n  EXPECT_EQ(1, response->headers().get(Http::Headers::get().WWWAuthenticate).size());\n  EXPECT_EQ(\n      \"Bearer realm=\\\"http://host/\\\", error=\\\"invalid_token\\\"\",\n      response->headers().get(Http::Headers::get().WWWAuthenticate)[0]->value().getStringView());\n}\n\nTEST_P(LocalJwksIntegrationTest, MissingToken) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      \"Bearer realm=\\\"http://host/\\\"\",\n      response->headers().get(Http::Headers::get().WWWAuthenticate)[0]->value().getStringView());\n}\n\nTEST_P(LocalJwksIntegrationTest, ExpiredTokenHeadReply) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"HEAD\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(ExpiredToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      \"Bearer realm=\\\"http://host/\\\", error=\\\"invalid_token\\\"\",\n      response->headers().get(Http::Headers::get().WWWAuthenticate)[0]->value().getStringView());\n\n  EXPECT_NE(\"0\", response->headers().getContentLengthValue());\n  EXPECT_THAT(response->body(), ::testing::IsEmpty());\n}\n\n// This test verifies a request is passed with a path that don't match any requirements.\nTEST_P(LocalJwksIntegrationTest, NoRequiresPath) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/foo\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n  });\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}\n\n// This test verifies a CORS preflight request without JWT token is allowed.\nTEST_P(LocalJwksIntegrationTest, CorsPreflight) {\n  config_helper_.prependFilter(getFilterConfig(true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"OPTIONS\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"access-control-request-method\", \"GET\"},\n      {\"origin\", \"test-origin\"},\n  });\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}\n\n// This test verifies JwtRequirement specified from filter state rules\nTEST_P(LocalJwksIntegrationTest, FilterStateRequirement) {\n  // A config with metadata rules.\n  const std::string auth_filter_conf = R\"(\n  providers:\n    example_provider:\n      issuer: https://example.com\n      audiences:\n      - example_service\n  filter_state_rules:\n    name: jwt_selector\n    requires:\n      example_provider:\n        provider_name: example_provider\n)\";\n\n  config_helper_.prependFilter(getAuthFilterConfig(auth_filter_conf, true));\n  config_helper_.prependFilter(absl::StrCat(\"name: \", HeaderToFilterStateFilterName));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  struct TestCase {\n    std::vector<std::pair<std::string, std::string>> extra_headers;\n    std::string expected_status;\n  };\n\n  const TestCase test_cases[] = {\n      // Case1: not set metadata, so Jwt is not required, expect 200\n      {\n          // Empty extra headers\n          {},\n          \"200\",\n      },\n\n      // Case2: requirement is set in the metadata, but missing token, expect 401\n      {\n          // selector header, but not token header\n          {\n              {\"jwt_selector\", \"example_provider\"},\n          },\n          \"401\",\n      },\n\n      // Case 3: requirement is set in the metadata, token is good, expect 200\n      {\n          // selector header, and token header\n          {\n              {\"jwt_selector\", \"example_provider\"},\n              {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n          },\n          \"200\",\n      },\n  };\n\n  for (const auto& test : test_cases) {\n    Http::TestRequestHeaderMapImpl headers{\n        {\":method\", \"GET\"},\n        {\":path\", \"/foo\"},\n        {\":scheme\", \"http\"},\n        {\":authority\", \"host\"},\n    };\n    for (const auto& h : test.extra_headers) {\n      headers.addCopy(h.first, h.second);\n    }\n    auto response = codec_client_->makeHeaderOnlyRequest(headers);\n\n    if (test.expected_status == \"200\") {\n      waitForNextUpstreamRequest();\n      upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n    }\n\n    ASSERT_TRUE(response->waitForEndStream());\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(test.expected_status, response->headers().getStatusValue());\n  }\n}\n\n// Verify that JWT config with RegEx matcher can handle CONNECT requests.\nTEST_P(LocalJwksIntegrationTest, ConnectRequestWithRegExMatch) {\n  config_helper_.prependFilter(getAuthFilterConfig(ExampleConfigWithRegEx, true));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder = codec_client_->startRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"CONNECT\"},\n      {\":authority\", \"host.com:80\"},\n      {\"authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n\n  if (downstreamProtocol() == Http::CodecType::HTTP1) {\n    // Because CONNECT requests for HTTP/1 do not include a path, they will fail\n    // to find a route match and return a 404.\n    ASSERT_TRUE(response->waitForEndStream());\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"404\", response->headers().getStatusValue());\n  } else {\n    ASSERT_TRUE(response->waitForReset());\n    ASSERT_TRUE(codec_client_->waitForDisconnect());\n  }\n}\n\n// The test case with a fake upstream for remote Jwks server.\nclass RemoteJwksIntegrationTest : public HttpProtocolIntegrationTest {\npublic:\n  void createUpstreams() override {\n    HttpProtocolIntegrationTest::createUpstreams();\n    // for Jwks upstream.\n    addFakeUpstream(GetParam().upstream_protocol);\n  }\n\n  void initializeFilter(bool add_cluster) {\n    config_helper_.prependFilter(getFilterConfig(false));\n\n    if (add_cluster) {\n      config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n        auto* jwks_cluster = bootstrap.mutable_static_resources()->add_clusters();\n        jwks_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);\n        jwks_cluster->set_name(\"pubkey_cluster\");\n      });\n    } else {\n      config_helper_.skipPortUsageValidation();\n    }\n\n    initialize();\n  }\n\n  void initializeAsyncFetchFilter(bool fast_listener) {\n    config_helper_.prependFilter(getAsyncFetchFilterConfig(ExampleConfig, fast_listener));\n\n    config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      auto* jwks_cluster = bootstrap.mutable_static_resources()->add_clusters();\n      jwks_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);\n      jwks_cluster->set_name(\"pubkey_cluster\");\n    });\n\n    initialize();\n  }\n\n  void waitForJwksResponse(const std::string& status, const std::string& jwks_body) {\n    AssertionResult result =\n        fake_upstreams_[1]->waitForHttpConnection(*dispatcher_, fake_jwks_connection_);\n    RELEASE_ASSERT(result, result.message());\n    result = fake_jwks_connection_->waitForNewStream(*dispatcher_, jwks_request_);\n    RELEASE_ASSERT(result, result.message());\n    result = jwks_request_->waitForEndStream(*dispatcher_);\n    RELEASE_ASSERT(result, result.message());\n\n    Http::TestResponseHeaderMapImpl response_headers{{\":status\", status}};\n    jwks_request_->encodeHeaders(response_headers, false);\n    Buffer::OwnedImpl response_data1(jwks_body);\n    jwks_request_->encodeData(response_data1, true);\n  }\n\n  void cleanup() {\n    codec_client_->close();\n    if (fake_jwks_connection_ != nullptr) {\n      AssertionResult result = fake_jwks_connection_->close();\n      RELEASE_ASSERT(result, result.message());\n      result = fake_jwks_connection_->waitForDisconnect();\n      RELEASE_ASSERT(result, result.message());\n    }\n    if (fake_upstream_connection_ != nullptr) {\n      AssertionResult result = fake_upstream_connection_->close();\n      RELEASE_ASSERT(result, result.message());\n      result = fake_upstream_connection_->waitForDisconnect();\n      RELEASE_ASSERT(result, result.message());\n    }\n  }\n\n  FakeHttpConnectionPtr fake_jwks_connection_{};\n  FakeStreamPtr jwks_request_{};\n};\n\nINSTANTIATE_TEST_SUITE_P(Protocols, RemoteJwksIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\n// With remote Jwks, this test verifies a request is passed with a good Jwt token\n// and a good public key fetched from a remote server.\nTEST_P(RemoteJwksIntegrationTest, WithGoodToken) {\n  initializeFilter(/*add_cluster=*/true);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  waitForJwksResponse(\"200\", PublicKey);\n\n  waitForNextUpstreamRequest();\n\n  const auto payload_entry =\n      upstream_request_->headers().get(Http::LowerCaseString(\"sec-istio-auth-userinfo\"));\n  EXPECT_FALSE(payload_entry.empty());\n  EXPECT_EQ(payload_entry[0]->value().getStringView(), ExpectedPayloadValue);\n  // Verify the token is removed.\n  EXPECT_TRUE(upstream_request_->headers().get(Http::CustomHeaders::get().Authorization).empty());\n\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n\n  cleanup();\n}\n\n// With remote Jwks, this test verifies a request is rejected even with a good Jwt token\n// when the remote jwks server replied with 500.\nTEST_P(RemoteJwksIntegrationTest, FetchFailedJwks) {\n  initializeFilter(/*add_cluster=*/true);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  // Fails the jwks fetching.\n  waitForJwksResponse(\"500\", \"\");\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      \"Bearer realm=\\\"http://host/\\\", error=\\\"invalid_token\\\"\",\n      response->headers().get(Http::Headers::get().WWWAuthenticate)[0]->value().getStringView());\n\n  cleanup();\n}\n\nTEST_P(RemoteJwksIntegrationTest, FetchFailedMissingCluster) {\n  initializeFilter(/*add_cluster=*/false);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      \"Bearer realm=\\\"http://host/\\\", error=\\\"invalid_token\\\"\",\n      response->headers().get(Http::Headers::get().WWWAuthenticate)[0]->value().getStringView());\n  cleanup();\n}\n\nTEST_P(RemoteJwksIntegrationTest, WithGoodTokenAsyncFetch) {\n  on_server_init_function_ = [this]() { waitForJwksResponse(\"200\", PublicKey); };\n  initializeAsyncFetchFilter(false);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  waitForNextUpstreamRequest();\n\n  const auto payload_entry =\n      upstream_request_->headers().get(Http::LowerCaseString(\"sec-istio-auth-userinfo\"));\n  EXPECT_FALSE(payload_entry.empty());\n  EXPECT_EQ(payload_entry[0]->value().getStringView(), ExpectedPayloadValue);\n  // Verify the token is removed.\n  EXPECT_TRUE(upstream_request_->headers().get(Http::CustomHeaders::get().Authorization).empty());\n\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n\n  cleanup();\n}\n\nTEST_P(RemoteJwksIntegrationTest, WithGoodTokenAsyncFetchFast) {\n  on_server_init_function_ = [this]() { waitForJwksResponse(\"200\", PublicKey); };\n  initializeAsyncFetchFilter(true);\n\n  // This test is only expecting one jwks fetch, but there is a race condition in the test:\n  // In fast fetch mode, the listener is activated without waiting for jwks fetch to be\n  // completed. When the first request comes at the worker thread, jwks fetch could be at\n  // any state at the main thread. If its result is not saved into jwks thread local slot,\n  // the first request will trigger a second jwks fetch, this is not expected, test will fail.\n  // To avoid such race condition, before making the first request, wait for the first\n  // fetch stats to be updated.\n  test_server_->waitForCounterGe(\"http.config_test.jwt_authn.jwks_fetch_success\", 1);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  waitForNextUpstreamRequest();\n\n  const auto payload_entry =\n      upstream_request_->headers().get(Http::LowerCaseString(\"sec-istio-auth-userinfo\"));\n  EXPECT_FALSE(payload_entry.empty());\n  EXPECT_EQ(payload_entry[0]->value().getStringView(), ExpectedPayloadValue);\n  // Verify the token is removed.\n  EXPECT_TRUE(upstream_request_->headers().get(Http::CustomHeaders::get().Authorization).empty());\n\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n\n  cleanup();\n}\n\nTEST_P(RemoteJwksIntegrationTest, WithFailedJwksAsyncFetch) {\n  on_server_init_function_ = [this]() { waitForJwksResponse(\"500\", \"\"); };\n  initializeAsyncFetchFilter(false);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n\n  cleanup();\n}\n\nTEST_P(RemoteJwksIntegrationTest, WithFailedJwksAsyncFetchFast) {\n  on_server_init_function_ = [this]() { waitForJwksResponse(\"500\", \"\"); };\n  initializeAsyncFetchFilter(true);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"401\", response->headers().getStatusValue());\n\n  cleanup();\n}\n\nclass PerRouteIntegrationTest : public HttpProtocolIntegrationTest {\npublic:\n  void setup(const std::string& filter_config, const PerRouteConfig& per_route) {\n    config_helper_.prependFilter(getAuthFilterConfig(filter_config, true));\n\n    config_helper_.addConfigModifier(\n        [per_route](\n            envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n                hcm) {\n          auto* virtual_host = hcm.mutable_route_config()->mutable_virtual_hosts(0);\n          auto& per_route_any =\n              (*virtual_host->mutable_routes(0)\n                    ->mutable_typed_per_filter_config())[\"envoy.filters.http.jwt_authn\"];\n          per_route_any.PackFrom(per_route);\n        });\n\n    initialize();\n  }\n};\n\nINSTANTIATE_TEST_SUITE_P(Protocols, PerRouteIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\n// This test verifies per-route config disabled.\nTEST_P(PerRouteIntegrationTest, PerRouteConfigDisabled) {\n  // per-route config has disabled flag.\n  PerRouteConfig per_route;\n  per_route.set_disabled(true);\n  // Use a normal filter config that requires jwt_auth.\n  setup(ExampleConfig, per_route);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // So the request without a JWT token is OK.\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n  });\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}\n\n// This test verifies per-route config with wrong requirement_name\nTEST_P(PerRouteIntegrationTest, PerRouteConfigWrongRequireName) {\n  // A config with a requirement_map\n  const std::string filter_conf = R\"(\n  providers:\n    example_provider:\n      issuer: https://example.com\n      audiences:\n      - example_service\n  requirement_map:\n    abc:\n      provider_name: \"example_provider\"\n)\";\n\n  // Per-route config has a wrong requirement_name.\n  PerRouteConfig per_route;\n  per_route.set_requirement_name(\"wrong-requirement-name\");\n  setup(filter_conf, per_route);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // So the request with a good Jwt token is rejected.\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"403\", response->headers().getStatusValue());\n}\n\n// This test verifies per-route config with correct requirement_name\nTEST_P(PerRouteIntegrationTest, PerRouteConfigOK) {\n  // A config with a requirement_map\n  const std::string filter_conf = R\"(\n  providers:\n    example_provider:\n      issuer: https://example.com\n      audiences:\n      - example_service\n  requirement_map:\n    abc:\n      provider_name: \"example_provider\"\n)\";\n\n  // Per-route config with correct requirement_name\n  PerRouteConfig per_route;\n  per_route.set_requirement_name(\"abc\");\n  setup(filter_conf, per_route);\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // So the request with a JWT token is OK.\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n      {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n\n  // A request with missing token is rejected.\n  auto response1 = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"},\n      {\":path\", \"/\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"host\"},\n  });\n\n  ASSERT_TRUE(response1->waitForEndStream());\n  ASSERT_TRUE(response1->complete());\n  EXPECT_EQ(\"401\", response1->headers().getStatusValue());\n}\n\n} // namespace\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\n\n// RS256 private key\n//-----BEGIN PRIVATE KEY-----\n//    MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC6n3u6qsX0xY49\n//    o+TBJoF64A8s6v0UpxpYZ1UQbNDh/dmrlYpVmjDH1MIHGYiY0nWqZSLXekHyi3Az\n//    +XmV9jUAUEzFVtAJRee0ui+ENqJK9injAYOMXNCJgD6lSryHoxRkGeGV5iuRTteU\n//    IHA1XI3yo0ySksDsoVljP7jzoadXY0gknH/gEZrcd0rBAbGLa2O5CxC9qjlbjGZJ\n//    VpoRaikHAzLZCaWFIVC49SlNrLBOpRxSr/pJ8AeFnggNr8XER3ZzbPyAUa1+y31x\n//    jeVFh/5z9l1uhjeao31K7f6PfPmvZIdaWEH8s0CPJaUEay9sY+VOoPOJhDBk3hoa\n//    ypUpBv1XAgMBAAECggEAc5HaJJIm/trsqD17pyV6X6arnyxyx7xn80Eii4ZnoNv8\n//    VWbJARP4i3e1JIJqdgE3PutctUYP2u0A8h7XbcfHsMcJk9ecA3IX+HKohF71CCkD\n//    bYH9fgnoVo5lvSTYNcMHGKpyacrdRiImHKQt+M21VgJMpCRfdurAmVbX6YA9Sj6w\n//    SBFrZbWkBHiHg7w++xKr+VeTHW/8fXI5bvSPAm/XB6dDKAcSXYiJJJhIoaVR9cHn\n//    1ePRDLpEwfDpBHeepd/S3qR37mIbHmo8SVytDY2xTUaIoaRfXRWGMYSyxl0y4RsZ\n//    Vo6Tp9Tj2fyohvB/S+lE34zhxnsHToK2JZvPeoyHCQKBgQDyEcjaUZiPdx7K63CT\n//    d57QNYC6DTjtKWnfO2q/vAVyAPwS30NcVuXj3/1yc0L+eExpctn8tcLfvDi1xZPY\n//    dW2L3SZKgRJXL+JHTCEkP8To/qNLhBqitcKYwp0gtpoZbUjZdZwn18QJx7Mw/nFC\n//    lJhSYRl+FjVolY3qBaS6eD7imwKBgQDFXNmeAV5FFF0FqGRsLYl0hhXTR6Hi/hKQ\n//    OyRALBW9LUKbsazwWEFGRlqbEWd1OcOF5SSV4d3u7wLQRTDeNELXUFvivok12GR3\n//    gNl9nDJ5KKYGFmqxM0pzfbT5m3Lsrr2FTIq8gM9GBpQAOmzQIkEu62yELtt2rRf0\n//    1pTh+UbN9QKBgF88kAEUySjofLzpFElwbpML+bE5MoRcHsMs5Tq6BopryMDEBgR2\n//    S8vzfAtjPaBQQ//Yp9q8yAauTsF1Ek2/JXI5d68oSMb0l9nlIcTZMedZB3XWa4RI\n//    bl8bciZEsSv/ywGDPASQ5xfR8bX85SKEw8jlWto4cprK/CJuRfj3BgaxAoGAAmQf\n//    ltR5aejXP6xMmyrqEWlWdlrV0UQ2wVyWEdj24nXb6rr6V2caU1mi22IYmMj8X3Dp\n//    Qo+b+rsWk6Ni9i436RfmJRcd3nMitHfxKp5r1h/x8vzuifsPGdsaCDQj7k4nqafF\n//    vobo+/Y0cNREYTkpBQKBLBDNQ+DQ+3xmDV7RxskCgYBCo6u2b/DZWFLoq3VpAm8u\n//    1ZgL8qxY/bbyA02IKF84QPFczDM5wiLjDGbGnOcIYYMvTHf1LJU4FozzYkB0GicX\n//    Y0tBQIHaaLWbPk1RZdPfR9kAp16iwk8H+V4UVjLfsTP7ocEfNCzZztmds83h8mTL\n//    DSwE5aY76Cs8XLcF/GNJRQ==\n//-----END PRIVATE KEY-----\n\n// A good public key\nconst char PublicKey[] = R\"(\n{\n  \"keys\": [\n    {\n      \"kty\": \"RSA\",\n      \"alg\": \"RS256\",\n      \"use\": \"sig\",\n      \"kid\": \"62a93512c9ee4c7f8067b5a216dade2763d32a47\",\n      \"n\": \"up97uqrF9MWOPaPkwSaBeuAPLOr9FKcaWGdVEGzQ4f3Zq5WKVZowx9TCBxmImNJ1qmUi13pB8otwM_l5lfY1AFBMxVbQCUXntLovhDaiSvYp4wGDjFzQiYA-pUq8h6MUZBnhleYrkU7XlCBwNVyN8qNMkpLA7KFZYz-486GnV2NIJJx_4BGa3HdKwQGxi2tjuQsQvao5W4xmSVaaEWopBwMy2QmlhSFQuPUpTaywTqUcUq_6SfAHhZ4IDa_FxEd2c2z8gFGtfst9cY3lRYf-c_ZdboY3mqN9Su3-j3z5r2SHWlhB_LNAjyWlBGsvbGPlTqDziYQwZN4aGsqVKQb9Vw\",\n      \"e\": \"AQAB\"\n    },\n    {\n      \"kty\": \"RSA\",\n      \"alg\": \"RS256\",\n      \"use\": \"sig\",\n      \"kid\": \"b3319a147514df7ee5e4bcdee51350cc890cc89e\",\n      \"n\": \"up97uqrF9MWOPaPkwSaBeuAPLOr9FKcaWGdVEGzQ4f3Zq5WKVZowx9TCBxmImNJ1qmUi13pB8otwM_l5lfY1AFBMxVbQCUXntLovhDaiSvYp4wGDjFzQiYA-pUq8h6MUZBnhleYrkU7XlCBwNVyN8qNMkpLA7KFZYz-486GnV2NIJJx_4BGa3HdKwQGxi2tjuQsQvao5W4xmSVaaEWopBwMy2QmlhSFQuPUpTaywTqUcUq_6SfAHhZ4IDa_FxEd2c2z8gFGtfst9cY3lRYf-c_ZdboY3mqN9Su3-j3z5r2SHWlhB_LNAjyWlBGsvbGPlTqDziYQwZN4aGsqVKQb9Vw\",\n      \"e\": \"AQAB\"\n    }\n  ]\n}\n)\";\n\n// A good config.\nconst char ExampleConfig[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    audiences:\n    - example_service\n    - http://example_service1\n    - https://example_service2/\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n        timeout:\n          seconds: 5\n      cache_duration:\n        seconds: 600\n    forward_payload_header: sec-istio-auth-userinfo\nrules:\n- match:\n    path: \"/\"\n  requires:\n    provider_name: \"example_provider\"\nbypass_cors_preflight: true\n)\";\n\nconst char ExampleConfigWithRegEx[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    audiences:\n    - example_service\n    - http://example_service1\n    - https://example_service2/\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n        timeout:\n          seconds: 5\n      cache_duration:\n        seconds: 600\n    forward_payload_header: sec-istio-auth-userinfo\nrules:\n- match:\n    safe_regex:\n      google_re2: {}\n      regex: \"/somethig/.*\"\n  requires:\n    provider_name: \"example_provider\"\n- match:\n    path: \"/\"\n  requires:\n    provider_name: \"example_provider\"\nbypass_cors_preflight: true\n)\";\n\n// The name of provider for above config.\nconst char ProviderName[] = \"example_provider\";\n\n// Payload:\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"aud\":\"example_service\",\"exp\":2001001001}\nconst char GoodToken[] = \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2V4YW1wbGUu\"\n                         \"Y29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIsImV4cCI6MjAwMTAwMTAwMSwiY\"\n                         \"XVkIjoiZXhhbXBsZV9zZXJ2aWNlIn0.cuui_Syud76B0tqvjESE8IZbX7vzG6xA-M\"\n                         \"Daof1qEFNIoCFT_YQPkseLSUSR2Od3TJcNKk-dKjvUEL1JW3kGnyC1dBx4f3-Xxro\"\n                         \"yL23UbR2eS8TuxO9ZcNCGkjfvH5O4mDb6cVkFHRDEolGhA7XwNiuVgkGJ5Wkrvshi\"\n                         \"h6nqKXcPNaRx9lOaRWg2PkE6ySNoyju7rNfunXYtVxPuUIkl0KMq3WXWRb_cb8a_Z\"\n                         \"EprqSZUzi_ZzzYzqBNVhIJujcNWij7JRra2sXXiSAfKjtxHQoxrX8n4V1ySWJ3_1T\"\n                         \"H_cJcdfS_RKP7YgXRWC0L16PNF5K7iqRqmjKALNe83ZFnFIw\";\n\n// Payload:\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"exp\":null}\nconst char NonExpiringToken[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2V4YW1wbGUu\"\n    \"Y29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIsImlhdCI6MTUzMzE3NTk0Mn0.OSh-\"\n    \"AcY9dCUibXiIZzPlTdEsYH8xP3QkCJDesO3LVu4ndgTrxDnNuR3I4_oV4tjtirmLZD3sx\"\n    \"96wmLiIhOyqj3nipIdf_aQWcmET0XoRqGixOKse5FlHyU_VC1Jj9AlMvSz9zyCvKxMyP0\"\n    \"CeA-bhI_Qs-I9vBPK8pd-EUOespUqWMQwNdtrOdXLcvF8EA5BV5G2qRGzCU0QJaW0Dpyj\"\n    \"YF7ZCswRGorc2oMt5duXSp3-L1b9dDrnLwroxUrmQIZz9qvfwdDR-guyYSjKVQu5NJAyy\"\n    \"sd8XKNzmHqJ2fYhRjc5s7l5nIWTDyBXSdPKQ8cBnfFKoxaRhmMBjdEn9RB7r6A\";\n\n// An expired token\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"aud\":\"example_service\",\"exp\":1205005587}\nconst char ExpiredToken[] = \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2V4YW1wbGUu\"\n                            \"Y29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIsImV4cCI6MTIwNTAwNTU4NywiY\"\n                            \"XVkIjoiZXhhbXBsZV9zZXJ2aWNlIn0.izDa6aHNgbsbeRzucE0baXIP7SXOrgopYQ\"\n                            \"ALLFAsKq_N0GvOyqpAZA9nwCAhqCkeKWcL-9gbQe3XJa0KN3FPa2NbW4ChenIjmf2\"\n                            \"QYXOuOQaDu9QRTdHEY2Y4mRy6DiTZAsBHWGA71_cLX-rzTSO_8aC8eIqdHo898oJw\"\n                            \"3E8ISKdryYjayb9X3wtF6KLgNomoD9_nqtOkliuLElD8grO0qHKI1xQurGZNaoeyi\"\n                            \"V1AdwgX_5n3SmQTacVN0WcSgk6YJRZG6VE8PjxZP9bEameBmbSB0810giKRpdTU1-\"\n                            \"RJtjq6aCSTD4CYXtW38T5uko4V-S4zifK3BXeituUTebkgoA\";\n\n// An NotYetValid token\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"aud\":\"example_service\",\"nbf\":9223372036854775807}\nconst char NotYetValidToken[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\"\n    \"eyJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIsImF1\"\n    \"ZCI6ImV4YW1wbGVfc2VydmljZSIsIm5iZiI6OTIyMzM3MjAzNjg1NDc3NTgwN30K\"\n    \".izDa6aHNgbsbeRzucE0baXIP7SXOrgopYQ\"\n    \"ALLFAsKq_N0GvOyqpAZA9nwCAhqCkeKWcL-9gbQe3XJa0KN3FPa2NbW4ChenIjmf2\"\n    \"QYXOuOQaDu9QRTdHEY2Y4mRy6DiTZAsBHWGA71_cLX-rzTSO_8aC8eIqdHo898oJw\"\n    \"3E8ISKdryYjayb9X3wtF6KLgNomoD9_nqtOkliuLElD8grO0qHKI1xQurGZNaoeyi\"\n    \"V1AdwgX_5n3SmQTacVN0WcSgk6YJRZG6VE8PjxZP9bEameBmbSB0810giKRpdTU1-\"\n    \"RJtjq6aCSTD4CYXtW38T5uko4V-S4zifK3BXeituUTebkgoA\";\n\n// A token with \"aud\" as invalid_service\n// Payload:\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"aud\":\"invalid_service\",\"exp\":2001001001}\nconst char InvalidAudToken[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2V4YW1wbGUu\"\n    \"Y29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIsImV4cCI6MjAwMTAwMTAwMSwiY\"\n    \"XVkIjoiaW52YWxpZF9zZXJ2aWNlIn0.B9HuVXpRDVYIvApfNQmE_l5fEMPEiPdi-s\"\n    \"dKbTione8I_UsnYHccKZVegaF6f2uyWhAvaTPgaMosyDlJD6skadEcmZD0V4TzsYK\"\n    \"v7eP5FQga26hZ1Kra7n9hAq4oFfH0J8aZLOvDV3tAgCNRXlh9h7QiBPeDNQlwztqE\"\n    \"csyp1lHI3jdUhsn3InIn-vathdx4PWQWLVb-74vwsP-END-MGlOfu_TY5OZUeY-GB\"\n    \"E4Wr06aOSU2XQjuNr6y2WJGMYFsKKWfF01kHSuyc9hjnq5UI19WrOM8s7LFP4w2iK\"\n    \"WFIPUGmPy3aM0TiF2oFOuuMxdPR3HNdSG7EWWRwoXv7n__jA\";\n\n// A token with non exist kid\n// Payload:\n// {\"iss\":\"https://example.com\",\"sub\":\"test@example.com\",\"aud\":\"example_service\",\"exp\":2001001001}\nconst char NonExistKidToken[] =\n    \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\"\n    \"eyJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIiwic3ViIjoidGVzdEBleGFtcGxlLmNvbSIs\"\n    \"ImF1ZCI6ImV4YW1wbGVfc2VydmljZSIsImV4cCI6MjAwMTAwMTAwMX0.\"\n    \"n45uWZfIBZwCIPiL0K8Ca3tmm-ZlsDrC79_\"\n    \"vXCspPwk5oxdSn983tuC9GfVWKXWUMHe11DsB02b19Ow-\"\n    \"fmoEzooTFn65Ml7G34nW07amyM6lETiMhNzyiunctplOr6xKKJHmzTUhfTirvDeG-q9n24-\"\n    \"8lH7GP8GgHvDlgSM9OY7TGp81bRcnZBmxim_UzHoYO3_\"\n    \"c8OP4ZX3xG5PfihVk5G0g6wcHrO70w0_64JgkKRCrLHMJSrhIgp9NHel_\"\n    \"CNOnL0AjQKe9IGblJrMuouqYYS0zEWwmOVUWUSxQkoLpldQUVefcfjQeGjz8IlvktRa77FYe\"\n    \"xfP590ACPyXrivtsxg\";\n\n// {\"iss\":\"https://other.com\",\"sub\":\"test@other.com\",\"aud\":\"other_service\",\"exp\":2001001001}\nconst char OtherGoodToken[] =\n    \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.\"\n    \"eyJpc3MiOiJodHRwczovL290aGVyLmNvbSIsInN1YiI6InRlc3RAb3RoZXIuY29tIiwiYXVkIjoib3RoZXJfc2VydmljZS\"\n    \"IsImV4cCI6MjAwMTAwMTAwMX0.R0GR2rnRTg_gWzDvuO-BXVMmw3-vyBspV_kUQ4zvIdO-_\"\n    \"1icaWzbioPTPEyoViWuErNYxaZ5YFBoD6Zk_hIe1YWoSJr9QRwxWA4CWcasJdBXPq2mMETt8VjAiXE_\"\n    \"aIrJOLIlP786GLjVgTsnvhaDUJyU7xUdoi9HRjEBYcdjNPvxJutoby8MypAkwdGxjl4H4Z01gomgWyUDRRy47OKI_\"\n    \"buwXk5M6d-\"\n    \"drRvLcvlT5gB4adOIOlmhm8xtXgYpvqrXfmMJCHbP9no7JATFaTEAkmA3OOxDsaOju4BFgMtRZtDM8p12QQG0rFl_FE-\"\n    \"2FqYX9qA4q41HJ4vxTSxgObeLGA\";\n\n// Expected base64 payload value.\nconst char ExpectedPayloadValue[] = \"eyJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIiwic3ViIjoidGVzdEBleGFtcG\"\n                                    \"xlLmNvbSIsImV4cCI6MjAwMTAwMTAwMSwiYXVkIjoiZXhhbXBsZV9zZXJ2\"\n                                    \"aWNlIn0\";\n\nconst char ExpectedPayloadValueWithPadding[] =\n    \"eyJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIiwic3ViIjoidGVzdEBleGFtcG\"\n    \"xlLmNvbSIsImV4cCI6MjAwMTAwMTAwMSwiYXVkIjoiZXhhbXBsZV9zZXJ2\"\n    \"aWNlIn0=\";\n\n// Base64 decoded Payload JSON\nconst char ExpectedPayloadJSON[] = R\"(\n{\n  \"iss\":\"https://example.com\",\n  \"sub\":\"test@example.com\",\n  \"exp\":2001001001,\n  \"aud\":\"example_service\"\n}\n)\";\n\nconst char ExpectedHeaderJSON[] = R\"(\n{\n  \"alg\": \"RS256\",\n  \"typ\": \"JWT\"\n}\n)\";\n\nconst char ExpectedPayloadAndHeaderJSON[] = R\"(\n{\n  \"my_payload\":{\n    \"iss\":\"https://example.com\",\n    \"exp\":2001001001,\n    \"sub\":\"test@example.com\",\n    \"aud\":\"example_service\"\n  },\n  \"my_header\":{\n    \"typ\":\"JWT\",\n    \"alg\":\"RS256\"\n  }\n}\n)\";\n\n// Token copied from https://github.com/google/jwt_verify_lib/blob/master/src/verify_jwk_ec_test.cc\n// Use jwt.io to modify payload as:\n// {\n//  \"iss11\": \"628645741881-noabiu23f5a8m8ovd8ucv698lj78vv0l@developer.gserviceaccount.com\",\n//  \"sub\": \"628645741881-noabiu23f5a8m8ovd8ucv698lj78vv0l@developer.gserviceaccount.com\",\n//  \"aud\": \"example_service\"\n// }\nconst char ES256WithoutIssToken[] =\n    \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFiYyJ9.\"\n    \"eyJpc3MxMSI6IjYyODY0NTc0MTg4MS1ub2FiaXUyM2Y1YThtOG92ZDh1Y3Y2OThsajc4dnYwbEBkZXZlbG9wZXIuZ3Nlcn\"\n    \"ZpY2VhY2NvdW50LmNvbSIsInN1YiI6IjYyODY0NTc0MTg4MS1ub2FiaXUyM2Y1YThtOG92ZDh1Y3Y2OThsajc4dnYwbEBk\"\n    \"ZXZlbG9wZXIuZ3NlcnZpY2VhY2NvdW50LmNvbSIsImF1ZCI6ImV4YW1wbGVfc2VydmljZSJ9.f-_\"\n    \"NAdznQK9o93AZTqNawu1yal1igNLgYvuj0JzW9SVmJJQuBT_12wJi9XQzZLFwSFn6D3f7bPWSZQlScTFSMg\";\n\n// Public key for above ES256 tokens.\nconst char ES256PublicKey[] = R\"(\n{\n  \"keys\": [\n    {\n      \"kty\": \"EC\",\n      \"crv\": \"P-256\",\n      \"alg\": \"ES256\",\n      \"kid\": \"abc\",\n      \"x\": \"EB54wykhS7YJFD6RYJNnwbWEz3cI7CF5bCDTXlrwI5k\",\n      \"y\": \"92bCBTvMFQ8lKbS2MbgjT3YfmYo6HnPEE2tsAqWUJw8\"\n    }\n  ]\n}\n)\";\n\n// Config with requires_all requirement\nconst char RequiresAllConfig[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    audiences:\n    - example_service\n    - http://example_service1\n    - https://example_service2/\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    from_params: [\"jwt_a\"]\n    forward_payload_header: example-auth-userinfo\n  other_provider:\n    issuer: https://other.com\n    audiences:\n    - other_service\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    from_params: [\"jwt_b\"]\n    forward_payload_header: other-auth-userinfo\nrules:\n- match:\n    path: \"/requires-all\"\n  requires:\n    requires_all:\n      requirements:\n      - provider_name: \"example_provider\"\n      - provider_name: \"other_provider\"\n)\";\n// Config with requires_any requirement\nconst char RequiresAnyConfig[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    audiences:\n    - example_service\n    - http://example_service1\n    - https://example_service2/\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    from_headers:\n    - name: a\n      value_prefix: \"Bearer \"\n    - name: b\n      value_prefix: \"Bearer \"\n    forward_payload_header: example-auth-userinfo\n  other_provider:\n    issuer: https://other.com\n    audiences:\n    - other_service\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    from_headers:\n    - name: a\n      value_prefix: \"Bearer \"\n    - name: b\n      value_prefix: \"Bearer \"\n    forward_payload_header: other-auth-userinfo\nrules:\n- match:\n    path: \"/requires-any\"\n  requires:\n    requires_any:\n      requirements:\n      - provider_name: \"example_provider\"\n      - provider_name: \"other_provider\"\n)\";\n\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n"], "filenames": ["docs/root/version_history/current.rst", "source/extensions/filters/http/jwt_authn/matcher.cc", "test/extensions/filters/http/jwt_authn/filter_integration_test.cc", "test/extensions/filters/http/jwt_authn/test_common.h"], "buggy_code_start_loc": [29, 119, 328, 87], "buggy_code_end_loc": [29, 119, 328, 87], "fixing_code_start_loc": [30, 120, 329, 88], "fixing_code_end_loc": [31, 123, 356, 119], "type": "CWE-476", "message": "Envoy is an open source edge and service proxy, designed for cloud-native applications. In affected versions a crafted request crashes Envoy when a CONNECT request is sent to JWT filter configured with regex match. This provides a denial of service attack vector. The only workaround is to not use regex in the JWT filter. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2021-43824", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-22T23:15:10.813", "lastModified": "2022-03-01T20:47:55.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Envoy is an open source edge and service proxy, designed for cloud-native applications. In affected versions a crafted request crashes Envoy when a CONNECT request is sent to JWT filter configured with regex match. This provides a denial of service attack vector. The only workaround is to not use regex in the JWT filter. Users are advised to upgrade."}, {"lang": "es", "value": "Envoy es un proxy de borde y servicio de c\u00f3digo abierto, dise\u00f1ado para aplicaciones nativas de la nube. En las versiones afectadas, una solicitud crafteada bloquea Envoy cuando se env\u00eda una solicitud CONNECT al filtro JWT configurado con coincidencia regex. Esto proporciona un vector de ataque de denegaci\u00f3n de servicio. La \u00fanica medida de mitigaci\u00f3n es no utilizar regex en el filtro JWT. Se aconseja a los usuarios que actualicen"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.18.6", "matchCriteriaId": "0EFC93D0-C206-417C-81D0-F18145E3D768"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.19.0", "versionEndExcluding": "1.19.3", "matchCriteriaId": "2812AC62-44B5-4077-862D-A221CD88981D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.20.0", "versionEndExcluding": "1.20.2", "matchCriteriaId": "F5441B2D-F807-4ED9-AFB9-ED4DE07CE5F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.21.0", "versionEndExcluding": "1.21.1", "matchCriteriaId": "83895D03-DAD1-4893-8A1C-F9143DEEC172"}]}]}], "references": [{"url": "https://github.com/envoyproxy/envoy/commit/9371333230b1a6e1be2eccf4868771e11af6253a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-vj5m-rch8-5r2p", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/envoyproxy/envoy/commit/9371333230b1a6e1be2eccf4868771e11af6253a"}}