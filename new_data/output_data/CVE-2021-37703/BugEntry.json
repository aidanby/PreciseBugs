{"buggy_code": ["# frozen_string_literal: true\n\n# This class is used to mirror unread and new status back to end users\n# in JavaScript there is a mirror class that is kept in-sync using MessageBus\n# the allows end users to always know which topics have unread posts in them\n# and which topics are new. This is used in various places in the UI, such as\n# counters, indicators, and messages at the top of topic lists, so the user\n# knows there is something worth reading at a glance.\n#\n# The TopicTrackingState.report data is preloaded in ApplicationController\n# for the current user under the topicTrackingStates key, and the existing\n# state is loaded into memory on page load. From there the MessageBus is\n# used to keep topic state up to date, as well as syncing with topics from\n# corresponding lists fetched from the server (e.g. the /new, /latest,\n# /unread topic lists).\n#\n# See discourse/app/models/topic-tracking-state.js\nclass TopicTrackingState\n\n  include ActiveModel::SerializerSupport\n\n  UNREAD_MESSAGE_TYPE = \"unread\"\n  LATEST_MESSAGE_TYPE = \"latest\"\n  MUTED_MESSAGE_TYPE = \"muted\"\n  UNMUTED_MESSAGE_TYPE = \"unmuted\"\n  NEW_TOPIC_MESSAGE_TYPE = \"new_topic\"\n  RECOVER_MESSAGE_TYPE = \"recover\"\n  DELETE_MESSAGE_TYPE = \"delete\"\n  DESTROY_MESSAGE_TYPE = \"destroy\"\n  READ_MESSAGE_TYPE = \"read\"\n  DISMISS_NEW_MESSAGE_TYPE = \"dismiss_new\"\n  MAX_TOPICS = 5000\n\n  attr_accessor :user_id,\n                :topic_id,\n                :highest_post_number,\n                :last_read_post_number,\n                :created_at,\n                :category_id,\n                :notification_level,\n                :tags\n\n  def self.publish_new(topic)\n    return unless topic.regular?\n\n    tag_ids, tags = nil\n    if SiteSetting.tagging_enabled\n      tag_ids, tags = topic.tags.pluck(:id, :name).transpose\n    end\n\n    payload = {\n      last_read_post_number: nil,\n      highest_post_number: 1,\n      created_at: topic.created_at,\n      category_id: topic.category_id,\n      archetype: topic.archetype,\n      created_in_new_period: true\n    }\n\n    if tags\n      payload[:tags] = tags\n      payload[:topic_tag_ids] = tag_ids\n    end\n\n    message = {\n      topic_id: topic.id,\n      message_type: NEW_TOPIC_MESSAGE_TYPE,\n      payload: payload\n    }\n\n    group_ids = topic.category && topic.category.secure_group_ids\n\n    MessageBus.publish(\"/new\", message.as_json, group_ids: group_ids)\n    publish_read(topic.id, 1, topic.user_id)\n  end\n\n  def self.publish_latest(topic, staff_only = false)\n    return unless topic.regular?\n\n    tag_ids, tags = nil\n    if SiteSetting.tagging_enabled\n      tag_ids, tags = topic.tags.pluck(:id, :name).transpose\n    end\n\n    message = {\n      topic_id: topic.id,\n      message_type: LATEST_MESSAGE_TYPE,\n      payload: {\n        bumped_at: topic.bumped_at,\n        category_id: topic.category_id,\n        archetype: topic.archetype\n      }\n    }\n\n    if tags\n      message[:payload][:tags] = tags\n      message[:payload][:topic_tag_ids] = tag_ids\n    end\n\n    group_ids =\n      if staff_only\n        [Group::AUTO_GROUPS[:staff]]\n      else\n        topic.category && topic.category.secure_group_ids\n      end\n    MessageBus.publish(\"/latest\", message.as_json, group_ids: group_ids)\n  end\n\n  def self.unread_channel_key(user_id)\n    \"/unread/#{user_id}\"\n  end\n\n  def self.publish_muted(topic)\n    user_ids = topic.topic_users\n      .where(notification_level: NotificationLevels.all[:muted])\n      .joins(:user)\n      .where(\"users.last_seen_at > ?\", 7.days.ago)\n      .order(\"users.last_seen_at DESC\")\n      .limit(100)\n      .pluck(:user_id)\n    return if user_ids.blank?\n    message = {\n      topic_id: topic.id,\n      message_type: MUTED_MESSAGE_TYPE,\n    }\n    MessageBus.publish(\"/latest\", message.as_json, user_ids: user_ids)\n  end\n\n  def self.publish_unmuted(topic)\n    return if !SiteSetting.mute_all_categories_by_default\n    user_ids = User.watching_topic_when_mute_categories_by_default(topic)\n      .where(\"users.last_seen_at > ?\", 7.days.ago)\n      .order(\"users.last_seen_at DESC\")\n      .limit(100)\n      .pluck(:id)\n    return if user_ids.blank?\n    message = {\n      topic_id: topic.id,\n      message_type: UNMUTED_MESSAGE_TYPE,\n    }\n    MessageBus.publish(\"/latest\", message.as_json, user_ids: user_ids)\n  end\n\n  def self.publish_unread(post)\n    return unless post.topic.regular?\n    # TODO at high scale we are going to have to defer this,\n    #   perhaps cut down to users that are around in the last 7 days as well\n\n    group_ids =\n      if post.post_type == Post.types[:whisper]\n        [Group::AUTO_GROUPS[:staff]]\n      else\n        post.topic.category && post.topic.category.secure_group_ids\n      end\n\n    tags = nil\n    tag_ids = nil\n    if include_tags_in_report?\n      tag_ids, tags = post.topic.tags.pluck(:id, :name).transpose\n    end\n\n    TopicUser\n      .tracking(post.topic_id)\n      .includes(user: :user_stat)\n      .select([:user_id, :last_read_post_number, :notification_level])\n      .each do |tu|\n\n      payload = {\n        last_read_post_number: tu.last_read_post_number,\n        highest_post_number: post.post_number,\n        updated_at: post.topic.updated_at,\n        created_at: post.created_at,\n        category_id: post.topic.category_id,\n        notification_level: tu.notification_level,\n        archetype: post.topic.archetype,\n        first_unread_at: tu.user.user_stat.first_unread_at,\n        unread_not_too_old: true\n      }\n\n      if tags\n        payload[:tags] = tags\n        payload[:topic_tag_ids] = tag_ids\n      end\n\n      message = {\n        topic_id: post.topic_id,\n        message_type: UNREAD_MESSAGE_TYPE,\n        payload: payload\n      }\n\n      MessageBus.publish(self.unread_channel_key(tu.user_id), message.as_json, group_ids: group_ids)\n    end\n\n  end\n\n  def self.publish_recover(topic)\n    group_ids = topic.category && topic.category.secure_group_ids\n\n    message = {\n      topic_id: topic.id,\n      message_type: RECOVER_MESSAGE_TYPE\n    }\n\n    MessageBus.publish(\"/recover\", message.as_json, group_ids: group_ids)\n\n  end\n\n  def self.publish_delete(topic)\n    group_ids = topic.category && topic.category.secure_group_ids\n\n    message = {\n      topic_id: topic.id,\n      message_type: DELETE_MESSAGE_TYPE\n    }\n\n    MessageBus.publish(\"/delete\", message.as_json, group_ids: group_ids)\n  end\n\n  def self.publish_destroy(topic)\n    group_ids = topic.category && topic.category.secure_group_ids\n\n    message = {\n      topic_id: topic.id,\n      message_type: DESTROY_MESSAGE_TYPE\n    }\n\n    MessageBus.publish(\"/destroy\", message.as_json, group_ids: group_ids)\n  end\n\n  def self.publish_read(topic_id, last_read_post_number, user_id, notification_level = nil)\n    highest_post_number = DB.query_single(\"SELECT highest_post_number FROM topics WHERE id = ?\", topic_id).first\n\n    message = {\n      topic_id: topic_id,\n      message_type: READ_MESSAGE_TYPE,\n      payload: {\n        last_read_post_number: last_read_post_number,\n        highest_post_number: highest_post_number,\n        notification_level: notification_level\n      }\n    }\n\n    MessageBus.publish(self.unread_channel_key(user_id), message.as_json, user_ids: [user_id])\n  end\n\n  def self.publish_dismiss_new(user_id, topic_ids: [])\n    message = {\n      message_type: DISMISS_NEW_MESSAGE_TYPE,\n      payload: {\n        topic_ids: topic_ids\n      }\n    }\n    MessageBus.publish(self.unread_channel_key(user_id), message.as_json, user_ids: [user_id])\n  end\n\n  def self.new_filter_sql\n    TopicQuery.new_filter(\n      Topic, treat_as_new_topic_clause_sql: treat_as_new_topic_clause\n    ).where_clause.ast.to_sql +\n      \" AND topics.created_at > :min_new_topic_date\" +\n      \" AND dismissed_topic_users.id IS NULL\"\n  end\n\n  def self.unread_filter_sql(staff: false)\n    TopicQuery.unread_filter(Topic, staff: staff).where_clause.ast.to_sql\n  end\n\n  def self.treat_as_new_topic_clause\n    User.where(\"GREATEST(CASE\n                  WHEN COALESCE(uo.new_topic_duration_minutes, :default_duration) = :always THEN u.created_at\n                  WHEN COALESCE(uo.new_topic_duration_minutes, :default_duration) = :last_visit THEN COALESCE(u.previous_visit_at,u.created_at)\n                  ELSE (:now::timestamp - INTERVAL '1 MINUTE' * COALESCE(uo.new_topic_duration_minutes, :default_duration))\n               END, u.created_at, :min_date)\",\n               treat_as_new_topic_params\n              ).where_clause.ast.to_sql\n  end\n\n  def self.treat_as_new_topic_params\n    {\n      now: DateTime.now,\n      last_visit: User::NewTopicDuration::LAST_VISIT,\n      always: User::NewTopicDuration::ALWAYS,\n      default_duration: SiteSetting.default_other_new_topic_duration_minutes,\n      min_date: Time.at(SiteSetting.min_new_topics_time).to_datetime\n    }\n  end\n\n  def self.include_tags_in_report?\n    SiteSetting.tagging_enabled && @include_tags_in_report\n  end\n\n  def self.include_tags_in_report=(v)\n    @include_tags_in_report = v\n  end\n\n  # Sam: this is a hairy report, in particular I need custom joins and fancy conditions\n  #  Dropping to sql_builder so I can make sense of it.\n  #\n  # Keep in mind, we need to be able to filter on a GROUP of users, and zero in on topic\n  #  all our existing scope work does not do this\n  #\n  # This code needs to be VERY efficient as it is triggered via the message bus and may steal\n  #  cycles from usual requests\n  def self.report(user, topic_id = nil)\n    tag_ids = muted_tag_ids(user)\n    sql = new_and_unread_sql(topic_id, user, tag_ids)\n    sql = tags_included_wrapped_sql(sql)\n\n    report = DB.query(\n      sql + \"\\n\\n LIMIT :max_topics\",\n      {\n        user_id: user.id,\n        topic_id: topic_id,\n        min_new_topic_date: Time.at(SiteSetting.min_new_topics_time).to_datetime,\n        max_topics: TopicTrackingState::MAX_TOPICS,\n      }\n      .merge(treat_as_new_topic_params)\n    )\n\n    report\n  end\n\n  def self.new_and_unread_sql(topic_id, user, tag_ids)\n    sql = report_raw_sql(\n      topic_id: topic_id,\n      skip_unread: true,\n      skip_order: true,\n      staff: user.staff?,\n      admin: user.admin?,\n      user: user,\n      muted_tag_ids: tag_ids\n    )\n\n    sql << \"\\nUNION ALL\\n\\n\"\n\n    sql << report_raw_sql(\n      topic_id: topic_id,\n      skip_new: true,\n      skip_order: true,\n      staff: user.staff?,\n      filter_old_unread: true,\n      admin: user.admin?,\n      user: user,\n      muted_tag_ids: tag_ids\n    )\n  end\n\n  def self.tags_included_wrapped_sql(sql)\n    if SiteSetting.tagging_enabled && TopicTrackingState.include_tags_in_report?\n      return <<~SQL\n        WITH tags_included_cte AS (\n          #{sql}\n        )\n        SELECT *, (\n          SELECT ARRAY_AGG(name) from topic_tags\n             JOIN tags on tags.id = topic_tags.tag_id\n             WHERE topic_id = tags_included_cte.topic_id\n          ) tags\n        FROM tags_included_cte\n      SQL\n    end\n\n    sql\n  end\n\n  def self.muted_tag_ids(user)\n    TagUser.lookup(user, :muted).pluck(:tag_id)\n  end\n\n  def self.report_raw_sql(\n    user:,\n    muted_tag_ids:,\n    topic_id: nil,\n    filter_old_unread: false,\n    skip_new: false,\n    skip_unread: false,\n    skip_order: false,\n    staff: false,\n    admin: false,\n    select: nil,\n    custom_state_filter: nil,\n    additional_join_sql: nil\n  )\n    unread =\n      if skip_unread\n        \"1=0\"\n      else\n        unread_filter_sql(staff: staff)\n      end\n\n    filter_old_unread_sql =\n      if filter_old_unread\n        \" topics.updated_at >= us.first_unread_at AND \"\n      else\n        \"\"\n      end\n\n    new =\n      if skip_new\n        \"1=0\"\n      else\n        new_filter_sql\n      end\n\n    select_sql = select || \"\n           DISTINCT topics.id as topic_id,\n           u.id as user_id,\n           topics.created_at,\n           topics.updated_at,\n           #{highest_post_number_column_select(staff)},\n           last_read_post_number,\n           c.id as category_id,\n           tu.notification_level,\n           us.first_unread_at,\n           GREATEST(\n              CASE\n              WHEN COALESCE(uo.new_topic_duration_minutes, :default_duration) = :always THEN u.created_at\n              WHEN COALESCE(uo.new_topic_duration_minutes, :default_duration) = :last_visit THEN COALESCE(\n                u.previous_visit_at,u.created_at\n              )\n              ELSE (:now::timestamp - INTERVAL '1 MINUTE' * COALESCE(uo.new_topic_duration_minutes, :default_duration))\n              END, u.created_at, :min_date\n           ) AS treat_as_new_topic_start_date\"\n\n    category_filter =\n      if admin\n        \"\"\n      else\n        append = \"OR u.admin\" if !admin\n        <<~SQL\n          (\n           NOT c.read_restricted #{append} OR c.id IN (\n              SELECT c2.id FROM categories c2\n              JOIN category_groups cg ON cg.category_id = c2.id\n              JOIN group_users gu ON gu.user_id = :user_id AND cg.group_id = gu.group_id\n              WHERE c2.read_restricted )\n          ) AND\n        SQL\n      end\n\n    visibility_filter =\n      if staff\n        \"\"\n      else\n        append = \"OR u.admin OR u.moderator\" if !staff\n        \"(topics.visible #{append}) AND\"\n      end\n\n    tags_filter = \"\"\n\n    if muted_tag_ids.present? && ['always', 'only_muted'].include?(SiteSetting.remove_muted_tags_from_latest)\n      existing_tags_sql = \"(select array_agg(tag_id) from topic_tags where topic_tags.topic_id = topics.id)\"\n      muted_tags_array_sql = \"ARRAY[#{muted_tag_ids.join(',')}]\"\n\n      if SiteSetting.remove_muted_tags_from_latest == 'always'\n        tags_filter = <<~SQL\n          NOT (\n            COALESCE(#{existing_tags_sql}, ARRAY[]::int[]) && #{muted_tags_array_sql}\n          ) AND\n        SQL\n      else # only muted\n        tags_filter = <<~SQL\n          NOT (\n            COALESCE(#{existing_tags_sql}, ARRAY[-999]) <@ #{muted_tags_array_sql}\n          ) AND\n        SQL\n      end\n    end\n\n    sql = +<<~SQL\n      SELECT #{select_sql}\n      FROM topics\n      JOIN users u on u.id = :user_id\n      JOIN user_stats AS us ON us.user_id = u.id\n      JOIN user_options AS uo ON uo.user_id = u.id\n      JOIN categories c ON c.id = topics.category_id\n      LEFT JOIN topic_users tu ON tu.topic_id = topics.id AND tu.user_id = u.id\n      LEFT JOIN category_users ON category_users.category_id = topics.category_id AND category_users.user_id = #{user.id}\n      LEFT JOIN dismissed_topic_users ON dismissed_topic_users.topic_id = topics.id AND dismissed_topic_users.user_id = #{user.id}\n      #{additional_join_sql}\n      WHERE u.id = :user_id AND\n            #{filter_old_unread_sql}\n            topics.archetype <> 'private_message' AND\n            #{custom_state_filter ? custom_state_filter : \"((#{unread}) OR (#{new})) AND\"}\n            #{visibility_filter}\n            #{tags_filter}\n            topics.deleted_at IS NULL AND\n            #{category_filter}\n            NOT (\n              #{(skip_new && skip_unread) ? \"\" : \"last_read_post_number IS NULL AND\"}\n              (\n                COALESCE(category_users.notification_level, #{CategoryUser.default_notification_level}) = #{CategoryUser.notification_levels[:muted]}\n                AND tu.notification_level <= #{TopicUser.notification_levels[:regular]}\n              )\n            )\n    SQL\n\n    if topic_id\n      sql << \" AND topics.id = :topic_id\"\n    end\n\n    unless skip_order\n      sql << \" ORDER BY topics.bumped_at DESC\"\n    end\n\n    sql\n  end\n\n  def self.highest_post_number_column_select(staff)\n    \"#{staff ? \"topics.highest_staff_post_number AS highest_post_number\" : \"topics.highest_post_number\"}\"\n  end\n\n  def self.publish_private_message(topic, archive_user_id: nil,\n                                          post: nil,\n                                          group_archive: false)\n\n    return unless topic.private_message?\n    channels = {}\n\n    allowed_user_ids = topic.allowed_users.pluck(:id)\n\n    if post && allowed_user_ids.include?(post.user_id)\n      channels[\"/private-messages/sent\"] = [post.user_id]\n    end\n\n    if archive_user_id\n      user_ids = [archive_user_id]\n\n      [\n        \"/private-messages/archive\",\n        \"/private-messages/inbox\",\n        \"/private-messages/sent\",\n      ].each do |channel|\n        channels[channel] = user_ids\n      end\n    end\n\n    if channels.except(\"/private-messages/sent\").blank?\n      channels[\"/private-messages/inbox\"] = allowed_user_ids\n    end\n\n    topic.allowed_groups.each do |group|\n      group_user_ids = group.users.pluck(:id)\n      next if group_user_ids.blank?\n      group_channels = []\n      channel_prefix = \"/private-messages/group/#{group.name.downcase}\"\n      group_channels << \"#{channel_prefix}/inbox\"\n      group_channels << \"#{channel_prefix}/archive\" if group_archive\n      group_channels.each { |channel| channels[channel] = group_user_ids }\n    end\n\n    message = {\n      topic_id: topic.id\n    }\n\n    channels.each do |channel, ids|\n      if ids.present?\n        MessageBus.publish(\n          channel,\n          message.as_json,\n          user_ids: ids\n        )\n      end\n    end\n  end\n\n  def self.publish_read_indicator_on_write(topic_id, last_read_post_number, user_id)\n    topic = Topic.includes(:allowed_groups).select(:highest_post_number, :archetype, :id).find_by(id: topic_id)\n\n    if topic&.private_message?\n      groups = read_allowed_groups_of(topic)\n      update_topic_list_read_indicator(topic, groups, topic.highest_post_number, user_id, true)\n    end\n  end\n\n  def self.publish_read_indicator_on_read(topic_id, last_read_post_number, user_id)\n    topic = Topic.includes(:allowed_groups).select(:highest_post_number, :archetype, :id).find_by(id: topic_id)\n\n    if topic&.private_message?\n      groups = read_allowed_groups_of(topic)\n      post = Post.find_by(topic_id: topic.id, post_number: last_read_post_number)\n      trigger_post_read_count_update(post, groups, last_read_post_number, user_id)\n      update_topic_list_read_indicator(topic, groups, last_read_post_number, user_id, false)\n    end\n  end\n\n  def self.read_allowed_groups_of(topic)\n    topic.allowed_groups\n      .joins(:group_users)\n      .where(publish_read_state: true)\n      .select('ARRAY_AGG(group_users.user_id) AS members', :name, :id)\n      .group('groups.id')\n  end\n\n  def self.update_topic_list_read_indicator(topic, groups, last_read_post_number, user_id, write_event)\n    return unless last_read_post_number == topic.highest_post_number\n    message = { topic_id: topic.id, show_indicator: write_event }.as_json\n    groups_to_update = []\n\n    groups.each do |group|\n      member = group.members.include?(user_id)\n\n      member_writing = (write_event && member)\n      non_member_reading = (!write_event && !member)\n      next if non_member_reading || member_writing\n\n      groups_to_update << group\n    end\n\n    return if groups_to_update.empty?\n    MessageBus.publish(\"/private-messages/unread-indicator/#{topic.id}\", message, user_ids: groups_to_update.flat_map(&:members))\n  end\n\n  def self.trigger_post_read_count_update(post, groups, last_read_post_number, user_id)\n    return if !post\n    return if groups.empty?\n    opts = { readers_count: post.readers_count, reader_id: user_id }\n    post.publish_change_to_clients!(:read, opts)\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'post_creator'\nrequire 'topic_subtype'\n\ndescribe PostCreator do\n\n  fab!(:user) { Fabricate(:user) }\n  let(:topic) { Fabricate(:topic, user: user) }\n\n  context \"new topic\" do\n    fab!(:category) { Fabricate(:category, user: user) }\n    let(:basic_topic_params) { { title: \"hello world topic\", raw: \"my name is fred\", archetype_id: 1 } }\n    let(:image_sizes) { { 'http://an.image.host/image.jpg' => { \"width\" => 111, \"height\" => 222 } } }\n\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n    let(:creator_with_category) { PostCreator.new(user, basic_topic_params.merge(category: category.id)) }\n    let(:creator_with_meta_data) { PostCreator.new(user, basic_topic_params.merge(meta_data: { hello: \"world\" })) }\n    let(:creator_with_image_sizes) { PostCreator.new(user, basic_topic_params.merge(image_sizes: image_sizes)) }\n    let(:creator_with_featured_link) { PostCreator.new(user, title: \"featured link topic\", archetype_id: 1, featured_link: \"http://www.discourse.org\", raw: \"http://www.discourse.org\") }\n\n    it \"can create a topic with null byte central\" do\n      post = PostCreator.create(user, title: \"hello\\u0000world this is title\", raw: \"this is my\\u0000 first topic\")\n      expect(post.raw).to eq 'this is my first topic'\n      expect(post.topic.title).to eq 'Helloworld this is title'\n    end\n\n    it \"can be created with auto tracking disabled\" do\n      p = PostCreator.create(user, basic_topic_params.merge(auto_track: false))\n      # must be 0 otherwise it will think we read the topic which is clearly untrue\n      expect(TopicUser.where(user_id: p.user_id, topic_id: p.topic_id).count).to eq(0)\n    end\n\n    it \"can be created with first post as wiki\" do\n      cat = Fabricate(:category)\n      cat.all_topics_wiki = true\n      cat.save\n      post = PostCreator.create(user, basic_topic_params.merge(category: cat.id))\n      expect(post.wiki).to eq(true)\n    end\n\n    it \"can be created with a hidden reason\" do\n      hri = Post.hidden_reasons[:flag_threshold_reached]\n      post = PostCreator.create(user, basic_topic_params.merge(hidden_reason_id: hri))\n      expect(post.hidden).to eq(true)\n      expect(post.hidden_at).to be_present\n      expect(post.hidden_reason_id).to eq(hri)\n      expect(post.topic.visible).to eq(false)\n    end\n\n    it \"ensures the user can create the topic\" do\n      Guardian.any_instance.expects(:can_create?).with(Topic, nil).returns(false)\n      expect { creator.create }.to raise_error(Discourse::InvalidAccess)\n    end\n\n    it \"can be created with custom fields\" do\n      post = PostCreator.create(user, basic_topic_params.merge(topic_opts: { custom_fields: { hello: \"world\" } }))\n      expect(post.topic.custom_fields).to eq(\"hello\" => \"world\")\n    end\n\n    context \"reply to post number\" do\n      it \"omits reply to post number if received on a new topic\" do\n        p = PostCreator.new(user, basic_topic_params.merge(reply_to_post_number: 3)).create\n        expect(p.reply_to_post_number).to be_nil\n      end\n    end\n\n    context \"invalid title\" do\n      let(:creator_invalid_title) { PostCreator.new(user, basic_topic_params.merge(title: 'a')) }\n\n      it \"has errors\" do\n        creator_invalid_title.create\n        expect(creator_invalid_title.errors).to be_present\n      end\n    end\n\n    context \"invalid raw\" do\n      let(:creator_invalid_raw) { PostCreator.new(user, basic_topic_params.merge(raw: '')) }\n\n      it \"has errors\" do\n        creator_invalid_raw.create\n        expect(creator_invalid_raw.errors).to be_present\n      end\n    end\n\n    context \"success\" do\n      before { creator }\n\n      it \"is not hidden\" do\n        p = creator.create\n        expect(p.hidden).to eq(false)\n        expect(p.hidden_at).not_to be_present\n        expect(p.hidden_reason_id).to eq(nil)\n        expect(p.topic.visible).to eq(true)\n      end\n\n      it \"doesn't return true for spam\" do\n        creator.create\n        expect(creator.spam?).to eq(false)\n      end\n\n      it \"triggers extensibility events\" do\n        events = DiscourseEvent.track_events { creator.create }\n\n        expect(events.map { |event| event[:event_name] }).to include(\n          :before_create_post,\n          :validate_post,\n          :topic_created,\n          :post_created,\n          :after_validate_topic,\n          :before_create_topic,\n          :after_trigger_post_process,\n          :markdown_context,\n          :topic_notification_level_changed,\n        )\n      end\n\n      it \"does not notify on system messages\" do\n        admin = Fabricate(:admin)\n        messages = MessageBus.track_publish do\n          p = PostCreator.create(admin, basic_topic_params.merge(post_type: Post.types[:moderator_action]))\n          PostCreator.create(admin, basic_topic_params.merge(topic_id: p.topic_id, post_type: Post.types[:moderator_action]))\n        end\n        # don't notify on system messages they introduce too much noise\n        channels = messages.map(&:channel)\n        expect(channels.find { |s| s =~ /unread/ }).to eq(nil)\n        expect(channels.find { |s| s =~ /new/ }).to eq(nil)\n      end\n\n      it 'enqueues job to generate messages' do\n        p = creator.create\n        expect(job_enqueued?(job: :post_update_topic_tracking_state, args: { post_id: p.id })).to eq(true)\n      end\n\n      it \"generates the correct messages for a secure topic\" do\n        Jobs.run_immediately!\n        UserActionManager.enable\n\n        admin = Fabricate(:admin)\n\n        cat = Fabricate(:category)\n        cat.set_permissions(admins: :full)\n        cat.save\n\n        created_post = nil\n\n        messages = MessageBus.track_publish do\n          created_post = PostCreator.new(admin, basic_topic_params.merge(category: cat.id)).create\n          _reply = PostCreator.new(admin, raw: \"this is my test reply 123 testing\", topic_id: created_post.topic_id).create\n        end\n\n        messages.filter! { |m| m.channel != \"/distributed_hash\" }\n\n        channels = messages.map { |m| m.channel }.sort\n\n        # 2 for topic, one to notify of new topic another for tracking state\n        expect(channels).to eq(\n          [\n            \"/new\",\n            \"/u/#{admin.username}\",\n            \"/u/#{admin.username}\",\n            \"/unread/#{admin.id}\",\n            \"/unread/#{admin.id}\",\n            \"/latest\",\n            \"/latest\",\n            \"/topic/#{created_post.topic_id}\",\n            \"/topic/#{created_post.topic_id}\",\n            \"/user\",\n            \"/user\",\n            \"/user\"\n          ].sort\n        )\n\n        admin_ids = [Group[:admins].id]\n        expect(messages.any? { |m| m.group_ids != admin_ids && m.user_ids != [admin.id] }).to eq(false)\n      end\n\n      it 'generates the correct messages for a normal topic' do\n        Jobs.run_immediately!\n        UserActionManager.enable\n\n        p = nil\n        messages = MessageBus.track_publish do\n          p = creator.create\n        end\n\n        latest = messages.find { |m| m.channel == \"/latest\" }\n        expect(latest).not_to eq(nil)\n\n        latest = messages.find { |m| m.channel == \"/new\" }\n        expect(latest).not_to eq(nil)\n\n        read = messages.find { |m| m.channel == \"/unread/#{p.user_id}\" }\n        expect(read).not_to eq(nil)\n\n        user_action = messages.find { |m| m.channel == \"/u/#{p.user.username}\" }\n        expect(user_action).not_to eq(nil)\n\n        draft_count = messages.find { |m| m.channel == \"/user\" }\n        expect(draft_count).not_to eq(nil)\n\n        expect(messages.filter { |m| m.channel != \"/distributed_hash\" }.length).to eq(7)\n      end\n\n      it 'extracts links from the post' do\n        create_post(raw: \"this is a link to the best site at https://google.com\")\n        creator.create\n        expect(TopicLink.count).to eq(1)\n      end\n\n      it 'queues up post processing job when saved' do\n        creator.create\n\n        post = Post.last\n        post_id = post.id\n        topic_id = post.topic_id\n\n        process_post_args = Jobs::ProcessPost.jobs.first[\"args\"].first\n        expect(process_post_args[\"post_id\"]).to eq(post_id)\n\n        feature_topic_users_args = Jobs::FeatureTopicUsers.jobs.first[\"args\"].first\n        expect(feature_topic_users_args[\"topic_id\"]).to eq(topic_id)\n\n        post_alert_args = Jobs::PostAlert.jobs.first[\"args\"].first\n        expect(post_alert_args[\"post_id\"]).to eq(post_id)\n\n        notify_mailing_list_subscribers_args =\n          Jobs::NotifyMailingListSubscribers.jobs.first[\"args\"].first\n\n        expect(notify_mailing_list_subscribers_args[\"post_id\"]).to eq(post_id)\n      end\n\n      it 'passes the invalidate_oneboxes along to the job if present' do\n        creator.opts[:invalidate_oneboxes] = true\n        creator.create\n\n        expect(job_enqueued?(job: :process_post, args: { invalidate_oneboxes: true })).to eq(true)\n      end\n\n      it 'passes the image_sizes along to the job if present' do\n        image_sizes = { 'http://an.image.host/image.jpg' => { 'width' => 17, 'height' => 31 } }\n        creator.opts[:image_sizes] = image_sizes\n        creator.create\n\n        expect(job_enqueued?(job: :process_post, args: { image_sizes: image_sizes })).to eq(true)\n      end\n\n      it 'assigns a category when supplied' do\n        expect(creator_with_category.create.topic.category).to eq(category)\n      end\n\n      it 'adds  meta data from the post' do\n        expect(creator_with_meta_data.create.topic.meta_data['hello']).to eq('world')\n      end\n\n      it 'passes the image sizes through' do\n        Post.any_instance.expects(:image_sizes=).with(image_sizes)\n        creator_with_image_sizes.create\n      end\n\n      it 'sets topic excerpt if first post, but not second post' do\n        first_post = creator.create\n        topic = first_post.topic.reload\n        expect(topic.excerpt).to be_present\n        expect {\n          PostCreator.new(first_post.user, topic_id: first_post.topic_id, raw: \"this is the second post\").create\n          topic.reload\n        }.to_not change { topic.excerpt }\n      end\n\n      it 'supports custom excerpts' do\n        raw = <<~MD\n          <div class='excerpt'>\n          I am\n\n          a custom excerpt\n          </div>\n\n          testing\n        MD\n        post = create_post(raw: raw)\n\n        expect(post.excerpt).to eq(\"I am\\na custom excerpt\")\n      end\n\n      it 'creates post stats' do\n        Draft.set(user, Draft::NEW_TOPIC, 0, \"test\")\n        Draft.set(user, Draft::NEW_TOPIC, 0, \"test1\")\n        expect(user.user_stat.draft_count).to eq(1)\n\n        begin\n          PostCreator.track_post_stats = true\n          post = creator.create\n          expect(post.post_stat.typing_duration_msecs).to eq(0)\n          expect(post.post_stat.drafts_saved).to eq(2)\n          expect(user.reload.user_stat.draft_count).to eq(0)\n        ensure\n          PostCreator.track_post_stats = false\n        end\n      end\n\n      it \"updates topic stats\" do\n        first_post = creator.create\n        topic = first_post.topic.reload\n\n        expect(topic.last_posted_at).to eq_time(first_post.created_at)\n        expect(topic.last_post_user_id).to eq(first_post.user_id)\n        expect(topic.word_count).to eq(4)\n      end\n\n      it 'creates a post with featured link' do\n        SiteSetting.topic_featured_link_enabled = true\n        SiteSetting.min_first_post_length = 100\n\n        post = creator_with_featured_link.create\n        expect(post.topic.featured_link).to eq('http://www.discourse.org')\n        expect(post.valid?).to eq(true)\n      end\n\n      it 'allows notification email to be skipped' do\n        user_2 = Fabricate(:user)\n\n        creator = PostCreator.new(user,\n          title: 'hi there welcome to my topic',\n          raw: \"this is my awesome message @#{user_2.username_lower}\",\n          archetype: Archetype.private_message,\n          target_usernames: [user_2.username],\n          post_alert_options: { skip_send_email: true }\n        )\n\n        NotificationEmailer.expects(:process_notification).never\n\n        creator.create\n      end\n\n      describe \"topic's auto close\" do\n        it \"doesn't update topic's auto close when it's not based on last post\" do\n          freeze_time\n\n          topic = Fabricate(:topic).set_or_create_timer(TopicTimer.types[:close], 12)\n          PostCreator.new(topic.user, topic_id: topic.id, raw: \"this is a second post\").create\n          topic.reload\n\n          topic_status_update = TopicTimer.last\n          expect(topic_status_update.execute_at).to eq_time(12.hours.from_now)\n          expect(topic_status_update.created_at).to eq_time(Time.zone.now)\n        end\n\n        describe \"topic's auto close based on last post\" do\n          fab!(:topic_timer) do\n            Fabricate(:topic_timer,\n              based_on_last_post: true,\n              execute_at: Time.zone.now - 12.hours,\n              created_at: Time.zone.now - 24.hours,\n              duration_minutes: 12 * 60\n            )\n          end\n\n          let(:topic) { topic_timer.topic }\n\n          fab!(:post) do\n            Fabricate(:post, topic: topic_timer.topic)\n          end\n\n          it \"updates topic's auto close date\" do\n            freeze_time\n            post\n\n            PostCreator.new(\n              topic.user,\n              topic_id: topic.id,\n              raw: \"this is a second post\"\n            ).create\n\n            topic_timer.reload\n\n            expect(topic_timer.execute_at).to eq_time(Time.zone.now + 12.hours)\n            expect(topic_timer.created_at).to eq_time(Time.zone.now)\n          end\n\n          describe \"when auto_close_topics_post_count has been reached\" do\n            before do\n              SiteSetting.auto_close_topics_post_count = 2\n            end\n\n            it \"closes the topic and deletes the topic timer\" do\n              freeze_time\n              post\n\n              PostCreator.new(\n                topic.user,\n                topic_id: topic.id,\n                raw: \"this is a second post\"\n              ).create\n\n              topic.reload\n\n              expect(topic.posts.last.raw).to eq(I18n.t(\n                'topic_statuses.autoclosed_topic_max_posts',\n                count: SiteSetting.auto_close_topics_post_count\n              ))\n\n              expect(topic.closed).to eq(true)\n              expect(topic_timer.reload.deleted_at).to eq_time(Time.zone.now)\n            end\n\n            it \"uses the system locale for the message\" do\n              post\n\n              I18n.with_locale(:fr) do\n                PostCreator.new(\n                  topic.user,\n                  topic_id: topic.id,\n                  raw: \"this is a second post\"\n                ).create\n              end\n\n              topic.reload\n\n              expect(topic.posts.last.raw).to eq(I18n.t(\n                'topic_statuses.autoclosed_topic_max_posts',\n                count: SiteSetting.auto_close_topics_post_count,\n                locale: :en\n              ))\n            end\n\n            describe \"auto_close_topics_create_linked_topic is enabled\" do\n              before do\n                SiteSetting.auto_close_topics_create_linked_topic = true\n              end\n\n              it \"enqueues a job to create a new linked topic\" do\n                freeze_time\n                post\n\n                post_2 = PostCreator.new(\n                  topic.user,\n                  topic_id: topic.id,\n                  raw: \"this is a second post\"\n                ).create\n\n                topic.reload\n\n                expect(topic.closed).to eq(true)\n                expect(topic_timer.reload.deleted_at).to eq_time(Time.zone.now)\n                expect(job_enqueued?(job: :create_linked_topic, args: { post_id: post_2.id })).to eq(true)\n              end\n            end\n          end\n        end\n      end\n\n      context \"tags\" do\n        let(:tag_names) { ['art', 'science', 'dance'] }\n        let(:creator_with_tags) { PostCreator.new(user, basic_topic_params.merge(tags: tag_names)) }\n\n        context \"tagging disabled\" do\n          before do\n            SiteSetting.tagging_enabled = false\n          end\n\n          it \"doesn't create tags\" do\n            expect { @post = creator_with_tags.create }.to change { Tag.count }.by(0)\n            expect(@post.topic&.tags&.size).to eq(nil)\n          end\n        end\n\n        context \"tagging enabled\" do\n          before do\n            SiteSetting.tagging_enabled = true\n          end\n\n          context \"can create tags\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 0\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            it \"can create all tags if none exist\" do\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(tag_names.size)\n              expect(@post.topic.tags.map(&:name).sort).to eq(tag_names.sort)\n            end\n\n            it \"creates missing tags if some exist\" do\n              _existing_tag1 = Fabricate(:tag, name: tag_names[0])\n              _existing_tag1 = Fabricate(:tag, name: tag_names[1])\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(tag_names.size - 2)\n              expect(@post.topic.tags.map(&:name).sort).to eq(tag_names.sort)\n            end\n          end\n\n          context \"cannot create tags\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 4\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            it \"only uses existing tags\" do\n              existing_tag1 = Fabricate(:tag, name: tag_names[1])\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(0)\n              expect(@post.topic.tags.map(&:name)).to eq([existing_tag1.name])\n            end\n          end\n\n          context \"automatically tags first posts\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 0\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            context \"without regular expressions\" do\n              it \"works with many tags\" do\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"HELLO\", replacement: \"greetings , hey\")\n\n                @post = creator.create\n                expect(@post.topic.tags.map(&:name)).to match_array(['greetings', 'hey'])\n              end\n\n              it \"works with overlapping words\" do\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"art\", replacement: \"about-art\")\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"artist*\", replacement: \"about-artists\")\n\n                post = PostCreator.new(user, title: \"hello world topic\", raw: \"this is topic abour artists\", archetype_id: 1).create\n                expect(post.topic.tags.map(&:name)).to match_array(['about-artists'])\n              end\n\n              it \"does not treat as regular expressions\" do\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"he(llo|y)\", replacement: \"greetings , hey\")\n\n                @post = creator_with_tags.create\n                expect(@post.topic.tags.map(&:name)).to match_array(tag_names)\n              end\n            end\n\n            context \"with regular expressions\" do\n              it \"works\" do\n                SiteSetting.watched_words_regular_expressions = true\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"he(llo|y)\", replacement: \"greetings , hey\")\n\n                @post = creator_with_tags.create\n                expect(@post.topic.tags.map(&:name)).to match_array(tag_names + ['greetings', 'hey'])\n              end\n            end\n          end\n        end\n      end\n    end\n\n    context 'when auto-close param is given' do\n      it 'ensures the user can auto-close the topic, but ignores auto-close param silently' do\n        Guardian.any_instance.stubs(:can_moderate?).returns(false)\n        expect {\n          PostCreator.new(user, basic_topic_params.merge(auto_close_time: 2)).create!\n        }.to_not change { TopicTimer.count }\n      end\n    end\n  end\n\n  context 'whisper' do\n    fab!(:topic) { Fabricate(:topic, user: user) }\n\n    it 'whispers do not mess up the public view' do\n      # turns out this can fail on leap years if we don't do this\n      freeze_time DateTime.parse('2010-01-01 12:00')\n\n      first = PostCreator.new(\n        user,\n        topic_id: topic.id,\n        raw: 'this is the first post'\n      ).create\n\n      freeze_time 1.year.from_now\n\n      user_stat = user.user_stat\n\n      whisper = PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: 1,\n        post_type: Post.types[:whisper],\n        raw: 'this is a whispered reply').create\n\n      # don't count whispers in user stats\n      expect(user_stat.reload.post_count).to eq(0)\n\n      expect(whisper).to be_present\n      expect(whisper.post_type).to eq(Post.types[:whisper])\n\n      whisper_reply = PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: whisper.post_number,\n        post_type: Post.types[:regular],\n        raw: 'replying to a whisper this time').create\n\n      expect(whisper_reply).to be_present\n      expect(whisper_reply.post_type).to eq(Post.types[:whisper])\n\n      expect(user_stat.reload.post_count).to eq(0)\n\n      user.reload\n      expect(user.last_posted_at).to eq_time(1.year.ago)\n\n      # date is not precise enough in db\n      whisper_reply.reload\n\n      first.reload\n      # does not leak into the OP\n      expect(first.reply_count).to eq(0)\n\n      topic.reload\n\n      # cause whispers should not muck up that number\n      expect(topic.highest_post_number).to eq(1)\n      expect(topic.reply_count).to eq(0)\n      expect(topic.posts_count).to eq(1)\n      expect(topic.highest_staff_post_number).to eq(3)\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.last_post_user_id).to eq(first.user_id)\n      expect(topic.word_count).to eq(5)\n\n      topic.update_columns(\n        highest_staff_post_number: 0,\n        highest_post_number: 0,\n        posts_count: 0,\n        last_posted_at: 1.year.ago\n      )\n\n      Topic.reset_highest(topic.id)\n\n      topic.reload\n      expect(topic.highest_post_number).to eq(1)\n      expect(topic.posts_count).to eq(1)\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.highest_staff_post_number).to eq(3)\n    end\n  end\n\n  context 'silent' do\n    fab!(:topic) { Fabricate(:topic, user: user) }\n\n    it 'silent do not mess up the public view' do\n      freeze_time DateTime.parse('2010-01-01 12:00')\n\n      first = PostCreator.new(\n        user,\n        topic_id: topic.id,\n        raw: 'this is the first post'\n      ).create\n\n      freeze_time 1.year.from_now\n\n      PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: 1,\n        silent: true,\n        post_type: Post.types[:regular],\n        raw: 'this is a whispered reply').create\n\n      topic.reload\n\n      # silent post should not muck up that number\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.last_post_user_id).to eq(first.user_id)\n      expect(topic.word_count).to eq(5)\n    end\n  end\n\n  context 'uniqueness' do\n\n    fab!(:topic) { Fabricate(:topic, user: user) }\n    let(:basic_topic_params) { { raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4 } }\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n\n    context \"disabled\" do\n      before do\n        SiteSetting.unique_posts_mins = 0\n        creator.create\n      end\n\n      it \"returns true for another post with the same content\" do\n        new_creator = PostCreator.new(user, basic_topic_params)\n        expect(new_creator.create).to be_present\n      end\n    end\n\n    context 'enabled' do\n      let(:new_post_creator) { PostCreator.new(user, basic_topic_params) }\n\n      before do\n        SiteSetting.unique_posts_mins = 10\n      end\n\n      it \"fails for dupe post across topic\" do\n        first = create_post(raw: \"this is a test #{SecureRandom.hex}\")\n        second = create_post(raw: \"this is a test #{SecureRandom.hex}\")\n\n        dupe = \"hello 123 test #{SecureRandom.hex}\"\n\n        response_1 = PostCreator.create(first.user, raw: dupe, topic_id: first.topic_id)\n        response_2 = PostCreator.create(first.user, raw: dupe, topic_id: second.topic_id)\n\n        expect(response_1.errors.count).to eq(0)\n        expect(response_2.errors.count).to eq(1)\n      end\n\n      it \"returns blank for another post with the same content\" do\n        creator.create\n        post = new_post_creator.create\n\n        expect(post.errors[:raw]).to include(I18n.t(:just_posted_that))\n      end\n\n      it \"returns a post for admins\" do\n        creator.create\n        user.admin = true\n        new_post_creator.create\n        expect(new_post_creator.errors).to be_blank\n      end\n\n      it \"returns a post for moderators\" do\n        creator.create\n        user.moderator = true\n        new_post_creator.create\n        expect(new_post_creator.errors).to be_blank\n      end\n    end\n\n  end\n\n  context \"host spam\" do\n\n    fab!(:topic) { Fabricate(:topic, user: user) }\n    let(:basic_topic_params) { { raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4 } }\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n\n    before do\n      Post.any_instance.expects(:has_host_spam?).returns(true)\n    end\n\n    it \"does not create the post\" do\n      GroupMessage.stubs(:create)\n      _post = creator.create\n\n      expect(creator.errors).to be_present\n      expect(creator.spam?).to eq(true)\n    end\n\n    it \"sends a message to moderators\" do\n      GroupMessage.expects(:create).with do |group_name, msg_type, params|\n        group_name == (Group[:moderators].name) && msg_type == (:spam_post_blocked) && params[:user].id == (user.id)\n      end\n      creator.create\n    end\n\n    it 'does not create a reviewable post if the review_every_post setting is enabled' do\n      SiteSetting.review_every_post = true\n      GroupMessage.stubs(:create)\n\n      expect { creator.create }.to change(ReviewablePost, :count).by(0)\n    end\n\n  end\n\n  # more integration testing ... maximise our testing\n  context 'existing topic' do\n    fab!(:topic) { Fabricate(:topic, user: user, title: 'topic title with 25 chars') }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'ensures the user can create the post' do\n      Guardian.any_instance.expects(:can_create?).with(Post, topic).returns(false)\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n\n    context 'success' do\n      it 'create correctly' do\n        post = creator.create\n        expect(Post.count).to eq(1)\n        expect(Topic.count).to eq(1)\n        expect(post.reply_to_post_number).to eq(4)\n      end\n    end\n\n    context \"when the user has bookmarks with auto_delete_preference on_owner_reply\" do\n      before do\n        Fabricate(:bookmark, topic: topic, user: user, auto_delete_preference: Bookmark.auto_delete_preferences[:on_owner_reply])\n        Fabricate(:bookmark, topic: topic, user: user, auto_delete_preference: Bookmark.auto_delete_preferences[:on_owner_reply])\n        TopicUser.create!(topic: topic, user: user, bookmarked: true)\n      end\n\n      it \"deletes the bookmarks, but not the ones without an auto_delete_preference\" do\n        Fabricate(:bookmark, topic: topic, user: user)\n        Fabricate(:bookmark, user: user)\n        creator.create\n        expect(Bookmark.where(user: user).count).to eq(2)\n        expect(TopicUser.find_by(topic: topic, user: user).bookmarked).to eq(true)\n      end\n\n      context \"when there are no bookmarks left in the topic\" do\n        it \"sets TopicUser.bookmarked to false\" do\n          creator.create\n          expect(TopicUser.find_by(topic: topic, user: user).bookmarked).to eq(false)\n        end\n      end\n    end\n\n    context \"topic stats\" do\n      before do\n        PostCreator.new(\n          Fabricate(:coding_horror),\n          raw: 'first post in topic',\n          topic_id: topic.id,\n          created_at: Time.zone.now - 24.hours\n        ).create\n      end\n\n      it \"updates topic stats\" do\n        post = creator.create\n        topic.reload\n\n        expect(topic.last_posted_at).to eq_time(post.created_at)\n        expect(topic.last_post_user_id).to eq(post.user_id)\n        expect(topic.word_count).to eq(6)\n      end\n\n      it \"updates topic stats even when topic fails validation\" do\n        topic.update_columns(title: 'below 15 chars')\n\n        post = creator.create\n        topic.reload\n\n        expect(topic.last_posted_at).to eq_time(post.created_at)\n        expect(topic.last_post_user_id).to eq(post.user_id)\n        expect(topic.word_count).to eq(6)\n      end\n    end\n\n    context 'when the topic is in slow mode' do\n      before do\n        one_day = 86400\n        topic.update!(slow_mode_seconds: one_day)\n      end\n\n      it 'fails if the user recently posted in this topic' do\n        TopicUser.create!(user: user, topic: topic, last_posted_at: 10.minutes.ago)\n\n        post = creator.create\n\n        expect(post).to be_blank\n        expect(creator.errors.count).to eq 1\n        expect(creator.errors.messages[:base][0]).to match I18n.t(:slow_mode_enabled)\n      end\n\n      it 'creates the topic if the user last post is older than the slow mode interval' do\n        TopicUser.create!(user: user, topic: topic, last_posted_at: 5.days.ago)\n\n        post = creator.create\n\n        expect(post).to be_present\n        expect(creator.errors.count).to be_zero\n      end\n\n      it 'creates the topic if the user is a staff member' do\n        admin = Fabricate(:admin)\n        post_creator = PostCreator.new(admin, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4)\n        TopicUser.create!(user: admin, topic: topic, last_posted_at: 10.minutes.ago)\n\n        post = post_creator.create\n\n        expect(post).to be_present\n        expect(post_creator.errors.count).to be_zero\n      end\n    end\n  end\n\n  context 'closed topic' do\n    fab!(:topic) { Fabricate(:topic, user: user, closed: true) }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'responds with an error message' do\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n  end\n\n  context 'missing topic' do\n    let(:topic) { Fabricate(:topic, user: user, deleted_at: 5.minutes.ago) }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'responds with an error message' do\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n  end\n\n  context \"cooking options\" do\n    let(:raw) { \"this is my awesome message body hello world\" }\n\n    it \"passes the cooking options through correctly\" do\n      creator = PostCreator.new(user,\n                                title: 'hi there welcome to my topic',\n                                raw: raw,\n                                cooking_options: { traditional_markdown_linebreaks: true })\n\n      Post.any_instance.expects(:cook).with(raw, has_key(:traditional_markdown_linebreaks)).returns(raw)\n      creator.create\n    end\n  end\n\n  # integration test ... minimise db work\n  context 'private message' do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    fab!(:unrelated_user) { Fabricate(:user) }\n    let(:post) do\n      PostCreator.create!(user,\n        title: 'hi there welcome to my topic',\n        raw: \"this is my awesome message @#{unrelated_user.username_lower}\",\n        archetype: Archetype.private_message,\n        target_usernames: [target_user1.username, target_user2.username].join(','),\n        category: 1\n      )\n    end\n\n    it 'acts correctly' do\n      freeze_time\n\n      user.update_columns(last_posted_at: 1.year.ago)\n\n      # It's not a warning\n      expect(post.topic.user_warning).to be_blank\n\n      expect(post.topic.archetype).to eq(Archetype.private_message)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n      expect(post.topic.topic_allowed_users.count).to eq(3)\n\n      # PMs can't have a category\n      expect(post.topic.category).to eq(nil)\n\n      # does not notify an unrelated user\n      expect(unrelated_user.notifications.count).to eq(0)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n\n      # PMs do not increase post count or topic count\n      expect(post.user.user_stat.post_count).to eq(0)\n      expect(post.user.user_stat.topic_count).to eq(0)\n\n      user.reload\n      expect(user.last_posted_at).to eq_time(1.year.ago)\n\n      # archive this message and ensure archive is cleared for all users on reply\n      UserArchivedMessage.create(user_id: target_user2.id, topic_id: post.topic_id)\n\n      # if an admin replies they should be added to the allowed user list\n      admin = Fabricate(:admin)\n      PostCreator.create!(admin,\n        raw: 'hi there welcome topic, I am a mod',\n        topic_id: post.topic_id\n      )\n\n      post.topic.reload\n      expect(post.topic.topic_allowed_users.where(user_id: admin.id).count).to eq(1)\n\n      expect(UserArchivedMessage.where(user_id: target_user2.id, topic_id: post.topic_id).count).to eq(0)\n\n      # if another admin replies and is already member of the group, don't add them to topic_allowed_users\n      group = Fabricate(:group)\n      post.topic.topic_allowed_groups.create!(group: group)\n      admin2 = Fabricate(:admin)\n      group.add(admin2)\n\n      PostCreator.create!(admin2, raw: 'I am also an admin, and a mod', topic_id: post.topic_id)\n\n      expect(post.topic.topic_allowed_users.where(user_id: admin2.id).count).to eq(0)\n    end\n\n    it 'does not add whisperers to allowed users of the topic' do\n      SiteSetting.enable_whispers = true\n      unrelated_user.update!(admin: true)\n\n      PostCreator.create!(\n        unrelated_user,\n        raw: \"This is a whisper that I am testing\",\n        topic_id: post.topic_id,\n        post_type: Post.types[:whisper]\n      )\n\n      expect(post.topic.topic_allowed_users.map(&:user_id)).to contain_exactly(\n        target_user1.id, target_user2.id, user.id\n      )\n    end\n\n    it 'does not increase posts count for small actions' do\n      topic = Fabricate(:private_message_topic, user: Fabricate(:user))\n\n      Fabricate(:post, topic: topic)\n\n      1.upto(3) do |i|\n        user = Fabricate(:user)\n        topic.invite(topic.user, user.username)\n        topic.reload\n        expect(topic.posts_count).to eq(1)\n        expect(topic.posts.where(post_type: Post.types[:small_action]).count).to eq(i)\n      end\n\n      Fabricate(:post, topic: topic)\n      Topic.reset_highest(topic.id)\n      expect(topic.reload.posts_count).to eq(2)\n\n      Fabricate(:post, topic: topic)\n      Topic.reset_all_highest!\n      expect(topic.reload.posts_count).to eq(3)\n    end\n  end\n\n  context \"warnings\" do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    let(:base_args) do\n      { title: 'you need a warning buddy!',\n        raw: \"you did something bad and I'm telling you about it!\",\n        is_warning: true,\n        target_usernames: target_user1.username,\n        category: 1 }\n    end\n\n    it \"works as expected\" do\n      # Invalid archetype\n      creator = PostCreator.new(user, base_args)\n      creator.create\n      expect(creator.errors).to be_present\n\n      # Too many users\n      creator = PostCreator.new(user, base_args.merge(archetype: Archetype.private_message,\n                                                      target_usernames: [target_user1.username, target_user2.username].join(',')))\n      creator.create\n      expect(creator.errors).to be_present\n\n      # Success\n      creator = PostCreator.new(user, base_args.merge(archetype: Archetype.private_message))\n      post = creator.create\n      expect(creator.errors).to be_blank\n\n      topic = post.topic\n      expect(topic).to be_present\n      expect(topic.user_warning).to be_present\n      expect(topic.subtype).to eq(TopicSubtype.moderator_warning)\n      expect(topic.user_warning.user).to eq(target_user1)\n      expect(topic.user_warning.created_by).to eq(user)\n      expect(target_user1.user_warnings.count).to eq(1)\n    end\n  end\n\n  context 'auto closing' do\n    it 'closes private messages that have more than N posts' do\n      SiteSetting.auto_close_messages_post_count = 2\n\n      admin = Fabricate(:admin)\n\n      post1 = create_post(archetype: Archetype.private_message,\n                          target_usernames: [admin.username])\n\n      expect do\n        create_post(user: post1.user, topic_id: post1.topic_id)\n      end.to change { Post.count }.by(2)\n\n      post1.topic.reload\n\n      expect(post1.topic.posts.last.raw).to eq(I18n.t(\n        'topic_statuses.autoclosed_message_max_posts',\n        count: SiteSetting.auto_close_messages_post_count\n      ))\n\n      expect(post1.topic.closed).to eq(true)\n    end\n\n    it 'closes topics that have more than N posts' do\n      SiteSetting.auto_close_topics_post_count = 2\n\n      post1 = create_post\n\n      expect do\n        create_post(user: post1.user, topic_id: post1.topic_id)\n      end.to change { Post.count }.by(2)\n\n      post1.topic.reload\n\n      expect(post1.topic.posts.last.raw).to eq(I18n.t(\n        'topic_statuses.autoclosed_topic_max_posts',\n        count: SiteSetting.auto_close_topics_post_count\n      ))\n\n      expect(post1.topic.closed).to eq(true)\n    end\n  end\n\n  context 'private message to group' do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    let(:group) do\n      g = Fabricate.build(:group, messageable_level: Group::ALIAS_LEVELS[:everyone])\n      g.add(target_user1)\n      g.add(target_user2)\n      g.save\n      g\n    end\n    fab!(:unrelated) { Fabricate(:user) }\n    let(:post) do\n      PostCreator.create!(user,\n        title: 'hi there welcome to my topic',\n        raw: \"this is my awesome message @#{unrelated.username_lower}\",\n        archetype: Archetype.private_message,\n        target_group_names: group.name\n      )\n    end\n\n    it 'can post to a group correctly' do\n      Jobs.run_immediately!\n\n      expect(post.topic.archetype).to eq(Archetype.private_message)\n      expect(post.topic.topic_allowed_users.count).to eq(1)\n      expect(post.topic.topic_allowed_groups.count).to eq(1)\n\n      # does not notify an unrelated user\n      expect(unrelated.notifications.count).to eq(0)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n\n      expect(target_user1.notifications.count).to eq(1)\n      expect(target_user2.notifications.count).to eq(1)\n    end\n  end\n\n  context 'setting created_at' do\n    it 'supports Time instances' do\n      freeze_time\n\n      post1 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        title: 'This is a very interesting test post title',\n        created_at: 1.week.ago\n      )\n      topic = post1.topic\n\n      post2 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        topic_id: topic,\n        created_at: 1.week.ago\n      )\n\n      expect(post1.created_at).to eq_time(1.week.ago)\n      expect(post2.created_at).to eq_time(1.week.ago)\n      expect(topic.created_at).to eq_time(1.week.ago)\n    end\n\n    it 'supports strings' do\n      freeze_time\n\n      time = Time.zone.parse('2019-09-02')\n\n      post1 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        title: 'This is a very interesting test post title',\n        created_at: '2019-09-02'\n      )\n      topic = post1.topic\n\n      post2 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        topic_id: topic,\n        created_at: '2019-09-02 00:00:00 UTC'\n      )\n\n      expect(post1.created_at).to eq_time(time)\n      expect(post2.created_at).to eq_time(time)\n      expect(topic.created_at).to eq_time(time)\n    end\n  end\n\n  context 'disable validations' do\n    it 'can save a post' do\n      creator = PostCreator.new(user, raw: 'q', title: 'q', skip_validations: true)\n      creator.create\n      expect(creator.errors).to be_blank\n    end\n  end\n\n  describe \"word_count\" do\n    it \"has a word count\" do\n      creator = PostCreator.new(user, title: 'some inspired poetry for a rainy day', raw: 'mary had a little lamb, little lamb, little lamb. mary had a little lamb. \u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435')\n      post = creator.create\n      expect(post.word_count).to eq(15)\n\n      post.topic.reload\n      expect(post.topic.word_count).to eq(15)\n    end\n  end\n\n  describe \"embed_url\" do\n\n    let(:embed_url) { \"http://eviltrout.com/stupid-url\" }\n\n    it \"creates the topic_embed record\" do\n      creator = PostCreator.new(user,\n                                embed_url: embed_url,\n                                title: 'Reviews of Science Ovens',\n                                raw: 'Did you know that you can use microwaves to cook your dinner? Science!')\n      creator.create\n      expect(creator.errors).to be_blank\n      expect(TopicEmbed.where(embed_url: embed_url).exists?).to eq(true)\n\n      # If we try to create another topic with the embed url, should fail\n      creator = PostCreator.new(user,\n                                embed_url: embed_url,\n                                title: 'More Reviews of Science Ovens',\n                                raw: 'As if anyone ever wanted to learn more about them!')\n      result = creator.create\n      expect(result).to be_present\n      expect(creator.errors).to be_present\n    end\n  end\n\n  describe \"read credit for creator\" do\n    it \"should give credit to creator\" do\n      post = create_post\n      expect(PostTiming.find_by(topic_id: post.topic_id,\n                                post_number: post.post_number,\n                                user_id: post.user_id).msecs).to be > 0\n\n      expect(TopicUser.find_by(topic_id: post.topic_id,\n                               user_id: post.user_id).last_read_post_number).to eq(1)\n    end\n  end\n\n  describe \"suspended users\" do\n    it \"does not allow suspended users to create topics\" do\n      user = Fabricate(:user, suspended_at: 1.month.ago, suspended_till: 1.month.from_now)\n\n      creator = PostCreator.new(user, title: \"my test title 123\", raw: \"I should not be allowed to post\")\n      creator.create\n      expect(creator.errors.count).to be > 0\n    end\n  end\n\n  it \"doesn't strip starting whitespaces\" do\n    pc = PostCreator.new(user, title: \"testing whitespace stripping\", raw: \"    <-- whitespaces -->    \")\n    post = pc.create\n    expect(post.raw).to eq(\"    <-- whitespaces -->\")\n  end\n\n  context \"events\" do\n    before do\n      @posts_created = 0\n      @topics_created = 0\n\n      @increase_posts = -> (post, opts, user) { @posts_created += 1 }\n      @increase_topics = -> (topic, opts, user) { @topics_created += 1 }\n      DiscourseEvent.on(:post_created, &@increase_posts)\n      DiscourseEvent.on(:topic_created, &@increase_topics)\n    end\n\n    after do\n      DiscourseEvent.off(:post_created, &@increase_posts)\n      DiscourseEvent.off(:topic_created, &@increase_topics)\n    end\n\n    it \"fires both event when creating a topic\" do\n      pc = PostCreator.new(user, raw: 'this is the new content for my topic', title: 'this is my new topic title')\n      _post = pc.create\n      expect(@posts_created).to eq(1)\n      expect(@topics_created).to eq(1)\n    end\n\n    it \"fires only the post event when creating a post\" do\n      pc = PostCreator.new(user, topic_id: topic.id, raw: 'this is the new content for my post')\n      _post = pc.create\n      expect(@posts_created).to eq(1)\n      expect(@topics_created).to eq(0)\n    end\n  end\n\n  context \"staged users\" do\n    fab!(:staged) { Fabricate(:staged) }\n\n    it \"automatically watches all messages it participates in\" do\n      post = PostCreator.create(staged,\n        title: \"this is the title of a topic created by a staged user\",\n        raw: \"this is the content of a topic created by a staged user ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: staged.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:watching])\n      expect(topic_user.notifications_reason_id).to eq(TopicUser.notification_reasons[:auto_watch])\n    end\n  end\n\n  context \"topic tracking\" do\n    it \"automatically watches topic based on preference\" do\n      user.user_option.notification_level_when_replying = 3\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for watching notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a watching notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to watching ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:watching])\n    end\n\n    it \"topic notification level remains tracking based on preference\" do\n      user.user_option.notification_level_when_replying = 2\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for tracking notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a tracking notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to tracking ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:tracking])\n    end\n\n    it \"topic notification level is normal based on preference\" do\n      user.user_option.notification_level_when_replying = 1\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for tracking notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a tracking notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to normal ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:regular])\n    end\n\n    it \"user preferences for notification level when replying doesn't affect PMs\" do\n      user.user_option.update!(notification_level_when_replying: 1)\n\n      admin = Fabricate(:admin)\n      pm = Fabricate(:private_message_topic, user: admin)\n\n      pm.invite(admin, user.username)\n      PostCreator.create(\n        user,\n        topic_id: pm.id,\n        raw: \"this is a test reply 123 123 ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: pm.id)\n      expect(topic_user.notification_level).to eq(3)\n    end\n\n    it 'sets the last_posted_at timestamp to track the last time the user posted' do\n      topic = Fabricate(:topic)\n\n      PostCreator.create(\n        user,\n        topic_id: topic.id,\n        raw: \"this is a test reply 123 123 ;)\"\n      )\n\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: topic.id)\n      expect(topic_user.last_posted_at).to be_present\n    end\n  end\n\n  describe '#create!' do\n    it \"should return the post if it was successfully created\" do\n      title = \"This is a valid title\"\n      raw = \"This is a really awesome post\"\n\n      post_creator = PostCreator.new(user, title: title, raw: raw)\n      post = post_creator.create\n\n      expect(post).to eq(Post.last)\n      expect(post.topic.title).to eq(title)\n      expect(post.raw).to eq(raw)\n    end\n\n    it \"should raise an error when post fails to be created\" do\n      post_creator = PostCreator.new(user, title: '', raw: '')\n      expect { post_creator.create! }.to raise_error(ActiveRecord::RecordNotSaved)\n    end\n\n    it \"does not generate an alert for empty posts\" do\n      Jobs.run_immediately!\n\n      user2 = Fabricate(:user)\n      topic = Fabricate(:private_message_topic,\n        topic_allowed_users: [\n          Fabricate.build(:topic_allowed_user, user: user),\n          Fabricate.build(:topic_allowed_user, user: user2)\n        ],\n      )\n      Fabricate(:topic_user,\n        topic: topic,\n        user: user2,\n        notification_level: TopicUser.notification_levels[:watching]\n      )\n\n      expect {\n        PostCreator.create!(user, raw: \"\", topic_id: topic.id, skip_validations: true)\n      }.to change { user2.notifications.count }.by(0)\n\n      expect {\n        PostCreator.create!(user, raw: \"hello world\", topic_id: topic.id, skip_validations: true)\n      }.to change { user2.notifications.count }.by(1)\n    end\n  end\n\n  context 'private message to a user that has disabled private messages' do\n    fab!(:another_user) { Fabricate(:user, username: 'HelloWorld') }\n\n    before do\n      another_user.user_option.update!(allow_private_messages: false)\n    end\n\n    it 'should not be valid' do\n      post_creator = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{another_user.username}\"\n      )\n\n      expect(post_creator).to_not be_valid\n\n      expect(post_creator.errors.full_messages).to include(I18n.t(\n        \"not_accepting_pms\", username: another_user.username\n      ))\n    end\n\n    it 'should not be valid if the name is downcased' do\n      post_creator = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{another_user.username.downcase}\"\n      )\n\n      expect(post_creator).to_not be_valid\n    end\n  end\n\n  context \"private message to a muted user\" do\n    fab!(:muted_me) { Fabricate(:evil_trout) }\n    fab!(:another_user) { Fabricate(:user) }\n\n    it 'should fail' do\n      updater = UserUpdater.new(muted_me, muted_me)\n      updater.update_muted_users(\"#{user.username}\")\n\n      pc = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{muted_me.username},#{another_user.username}\"\n      )\n\n      expect(pc).not_to be_valid\n\n      expect(pc.errors.full_messages).to contain_exactly(\n        I18n.t(:not_accepting_pms, username: muted_me.username)\n      )\n    end\n\n    fab!(:staff_user) { Fabricate(:admin) }\n\n    it 'succeeds if the user is staff' do\n      updater = UserUpdater.new(muted_me, muted_me)\n      updater.update_muted_users(\"#{staff_user.username}\")\n\n      pc = PostCreator.new(\n        staff_user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{muted_me.username}\"\n      )\n      expect(pc).to be_valid\n      expect(pc.errors).to be_blank\n    end\n  end\n\n  context \"private message to an ignored user\" do\n    fab!(:ignorer) { Fabricate(:evil_trout) }\n    fab!(:another_user) { Fabricate(:user) }\n\n    context \"when post author is ignored\" do\n      let!(:ignored_user) { Fabricate(:ignored_user, user: ignorer, ignored_user: user) }\n\n      it 'should fail' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is to someone who ignored me!',\n          raw: \"you will have to see this even if you ignored me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{ignorer.username},#{another_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: ignorer.username)\n                                           )\n      end\n    end\n\n    context \"when post author is admin who is ignored\" do\n      fab!(:staff_user) { Fabricate(:admin) }\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: ignorer, ignored_user: staff_user) }\n\n      it 'succeeds if the user is staff' do\n        pc = PostCreator.new(\n          staff_user,\n          title: 'this message is to someone who ignored me!',\n          raw: \"you will have to see this even if you ignored me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{ignorer.username}\"\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n  end\n\n  context \"private message to user in allow list\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n\n    context \"when post author is allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should succeed' do\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is in my allow list!',\n          raw: \"you will have to see this because I'm in your allow list!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username}\"\n        )\n\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n    context \"when personal messages are disabled\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should fail' do\n        allowed_user.user_option.update!(allow_private_messages: false)\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is in my allow list!',\n          raw: \"you will have to see this because I'm in your allow list!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: allowed_user.username)\n                                           )\n      end\n    end\n  end\n\n  context \"private message to user not in allow list\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n\n    context \"when post author is not allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: not_allowed_user, allowed_pm_user: allowed_user) }\n\n      it 'should fail' do\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{not_allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: not_allowed_user.username)\n                                           )\n      end\n\n      it 'should succeed when not enabled' do\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: false)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{not_allowed_user.username}\"\n        )\n\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n  end\n\n  context \"private message when post author is admin who is not in allow list\" do\n    fab!(:staff_user) { Fabricate(:admin) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n    fab!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: staff_user, allowed_pm_user: allowed_user) }\n\n    it 'succeeds if the user is staff' do\n      pc = PostCreator.new(\n        staff_user,\n        title: 'this message is to someone who did not allow me!',\n        raw: \"you will have to see this even if you did not allow me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{not_allowed_user.username}\"\n      )\n      expect(pc).to be_valid\n      expect(pc.errors).to be_blank\n    end\n  end\n\n  context \"private message to multiple users and one is not allowed\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n\n    context \"when post author is not allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should fail' do\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username},#{not_allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: not_allowed_user.username)\n                                           )\n      end\n    end\n  end\n\n  context \"private message recipients limit (max_allowed_message_recipients) reached\" do\n    fab!(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:evil_trout) }\n    fab!(:target_user3) { Fabricate(:walter_white) }\n\n    before do\n      SiteSetting.max_allowed_message_recipients = 2\n    end\n\n    context \"for normal user\" do\n      it 'fails when sending message to multiple recipients' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(',')\n        )\n        expect(pc).not_to be_valid\n        expect(pc.errors).to be_present\n      end\n\n      it 'succeeds when sending message to multiple recipients if skip_validations is true' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(','),\n          skip_validations: true\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n    context \"always succeeds if the user is staff\" do\n      fab!(:staff_user) { Fabricate(:admin) }\n\n      it 'when sending message to multiple recipients' do\n        pc = PostCreator.new(\n          staff_user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(',')\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n  end\n\n  context \"#create_post_notice\" do\n    fab!(:user) { Fabricate(:user) }\n    fab!(:staged) { Fabricate(:staged) }\n    fab!(:anonymous) { Fabricate(:anonymous) }\n\n    it \"generates post notices for new users\" do\n      post = PostCreator.create!(user, title: \"one of my first topics\", raw: \"one of my first posts\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:new_user])\n\n      post = PostCreator.create!(user, title: \"another one of my first topics\", raw: \"another one of my first posts\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n    end\n\n    it \"generates post notices for returning users\" do\n      SiteSetting.returning_users_days = 30\n      old_post = Fabricate(:post, user: user, created_at: 31.days.ago)\n\n      post = PostCreator.create!(user, title: \"this is a returning topic\", raw: \"this is a post\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:returning_user], \"last_posted_at\" => old_post.created_at.iso8601)\n\n      post = PostCreator.create!(user, title: \"this is another topic\", raw: \"this is my another post\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n    end\n\n    it \"does not generate for non-human, staged or anonymous users\" do\n      SiteSetting.allow_anonymous_posting = true\n\n      [anonymous, Discourse.system_user, staged].each do |user|\n        expect(user.posts.size).to eq(0)\n        post = PostCreator.create!(user, title: \"#{user.username}'s first topic\", raw: \"#{user.name}'s first post\")\n        expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n      end\n    end\n  end\n\n  context \"secure media uploads\" do\n    fab!(:image_upload) { Fabricate(:upload, secure: true) }\n    fab!(:user2) { Fabricate(:user) }\n    fab!(:public_topic) { Fabricate(:topic) }\n\n    before do\n      setup_s3\n      SiteSetting.authorized_extensions = \"png|jpg|gif|mp4\"\n      SiteSetting.secure_media = true\n      stub_upload(image_upload)\n    end\n\n    it \"links post uploads\" do\n      _public_post = PostCreator.create(\n        user,\n        topic_id: public_topic.id,\n        raw: \"A public post with an image.\\n![](#{image_upload.short_path})\"\n      )\n    end\n  end\n\n  context 'queue for review' do\n    before { SiteSetting.review_every_post = true }\n\n    it 'created a reviewable post after creating the post' do\n      title = \"This is a valid title\"\n      raw = \"This is a really awesome post\"\n\n      post_creator = PostCreator.new(user, title: title, raw: raw)\n\n      expect { post_creator.create }.to change(ReviewablePost, :count).by(1)\n    end\n\n    it 'does not create a reviewable post if the post is not valid' do\n      post_creator = PostCreator.new(user, title: '', raw: '')\n\n      expect { post_creator.create }.to change(ReviewablePost, :count).by(0)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe TopicTrackingState do\n\n  fab!(:user) do\n    Fabricate(:user)\n  end\n\n  let(:post) do\n    create_post\n  end\n\n  let(:topic) { post.topic }\n  fab!(:private_message_post) { Fabricate(:private_message_post) }\n  let(:private_message_topic) { private_message_post.topic }\n\n  describe '#publish_latest' do\n    it 'can correctly publish latest' do\n      message = MessageBus.track_publish(\"/latest\") do\n        described_class.publish_latest(topic)\n      end.first\n\n      data = message.data\n\n      expect(data[\"topic_id\"]).to eq(topic.id)\n      expect(data[\"message_type\"]).to eq(described_class::LATEST_MESSAGE_TYPE)\n      expect(data[\"payload\"][\"archetype\"]).to eq(Archetype.default)\n    end\n\n    describe 'private message' do\n      it 'should not publish any message' do\n        messages = MessageBus.track_publish do\n          described_class.publish_latest(private_message_topic)\n        end\n\n        expect(messages).to eq([])\n      end\n    end\n  end\n\n  describe '#publish_unread' do\n    it \"can correctly publish unread\" do\n      message = MessageBus.track_publish(described_class.unread_channel_key(post.user.id)) do\n        TopicTrackingState.publish_unread(post)\n      end.first\n\n      data = message.data\n\n      expect(data[\"topic_id\"]).to eq(topic.id)\n      expect(data[\"message_type\"]).to eq(described_class::UNREAD_MESSAGE_TYPE)\n      expect(data[\"payload\"][\"archetype\"]).to eq(Archetype.default)\n    end\n\n    describe 'for a private message' do\n      before do\n        TopicUser.change(\n          private_message_topic.allowed_users.first.id,\n          private_message_topic.id,\n          notification_level: TopicUser.notification_levels[:tracking]\n        )\n      end\n\n      it 'should not publish any message' do\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_unread(private_message_post)\n        end\n\n        expect(messages).to eq([])\n      end\n    end\n  end\n\n  describe '#publish_muted' do\n    let(:user) do\n      Fabricate(:user, last_seen_at: Date.today)\n    end\n    let(:post) do\n      create_post(user: user)\n    end\n\n    it 'can correctly publish muted' do\n      TopicUser.find_by(topic: topic, user: post.user).update(notification_level: 0)\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_muted(topic)\n      end\n\n      muted_message = messages.find { |message| message.data[\"message_type\"] == \"muted\" }\n\n      expect(muted_message.data[\"topic_id\"]).to eq(topic.id)\n      expect(muted_message.data[\"message_type\"]).to eq(described_class::MUTED_MESSAGE_TYPE)\n    end\n\n    it 'should not publish any message when notification level is not muted' do\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_muted(topic)\n      end\n      muted_messages = messages.select { |message| message.data[\"message_type\"] == \"muted\" }\n\n      expect(muted_messages).to eq([])\n    end\n\n    it 'should not publish any message when the user was not seen in the last 7 days' do\n      TopicUser.find_by(topic: topic, user: post.user).update(notification_level: 0)\n      post.user.update(last_seen_at: 8.days.ago)\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_muted(topic)\n      end\n      muted_messages = messages.select { |message| message.data[\"message_type\"] == \"muted\" }\n      expect(muted_messages).to eq([])\n    end\n  end\n\n  describe '#publish_unmuted' do\n    let(:user) do\n      Fabricate(:user, last_seen_at: Date.today)\n    end\n    let(:second_user) do\n      Fabricate(:user, last_seen_at: Date.today)\n    end\n    let(:third_user) do\n      Fabricate(:user, last_seen_at: Date.today)\n    end\n    let(:post) do\n      create_post(user: user)\n    end\n\n    it 'can correctly publish unmuted' do\n      Fabricate(:topic_tag, topic: topic)\n      SiteSetting.mute_all_categories_by_default = true\n      TopicUser.find_by(topic: topic, user: post.user).update(notification_level: 1)\n      CategoryUser.create!(category: topic.category, user: second_user, notification_level: 1)\n      TagUser.create!(tag: topic.tags.first, user: third_user, notification_level: 1)\n      TagUser.create!(tag: topic.tags.first, user: Fabricate(:user), notification_level: 0)\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_unmuted(topic)\n      end\n\n      unmuted_message = messages.find { |message| message.data[\"message_type\"] == \"unmuted\" }\n      expect(unmuted_message.user_ids.sort).to eq([user.id, second_user.id, third_user.id].sort)\n      expect(unmuted_message.data[\"topic_id\"]).to eq(topic.id)\n      expect(unmuted_message.data[\"message_type\"]).to eq(described_class::UNMUTED_MESSAGE_TYPE)\n    end\n\n    it 'should not publish any message when notification level is not muted' do\n      SiteSetting.mute_all_categories_by_default = true\n      TopicUser.find_by(topic: topic, user: post.user).update(notification_level: 0)\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_unmuted(topic)\n      end\n      unmuted_messages = messages.select { |message| message.data[\"message_type\"] == \"unmuted\" }\n\n      expect(unmuted_messages).to eq([])\n    end\n\n    it 'should not publish any message when the user was not seen in the last 7 days' do\n      TopicUser.find_by(topic: topic, user: post.user).update(notification_level: 1)\n      post.user.update(last_seen_at: 8.days.ago)\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_unmuted(topic)\n      end\n      unmuted_messages = messages.select { |message| message.data[\"message_type\"] == \"unmuted\" }\n      expect(unmuted_messages).to eq([])\n    end\n  end\n\n  describe '#publish_private_message' do\n    fab!(:admin) { Fabricate(:admin) }\n\n    describe 'normal topic' do\n      it 'should publish the right message' do\n        allowed_users = private_message_topic.allowed_users\n\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_private_message(private_message_topic)\n        end\n\n        expect(messages.count).to eq(1)\n\n        message = messages.first\n\n        expect(message.channel).to eq('/private-messages/inbox')\n        expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n        expect(message.user_ids).to contain_exactly(*allowed_users.map(&:id))\n      end\n    end\n\n    describe 'topic with groups' do\n      fab!(:group1) { Fabricate(:group, users: [Fabricate(:user)]) }\n      fab!(:group2) { Fabricate(:group, users: [Fabricate(:user), Fabricate(:user)]) }\n\n      before do\n        [group1, group2].each do |group|\n          private_message_topic.allowed_groups << group\n        end\n      end\n\n      it \"should publish the right message\" do\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_private_message(\n            private_message_topic\n          )\n        end\n\n        expect(messages.map(&:channel)).to contain_exactly(\n          '/private-messages/inbox',\n          \"/private-messages/group/#{group1.name}/inbox\",\n          \"/private-messages/group/#{group2.name}/inbox\"\n        )\n\n        message = messages.find do |m|\n          m.channel == '/private-messages/inbox'\n        end\n\n        expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n        expect(message.user_ids).to eq(private_message_topic.allowed_users.map(&:id))\n\n        [group1, group2].each do |group|\n          message = messages.find do |m|\n            m.channel == \"/private-messages/group/#{group.name}/inbox\"\n          end\n\n          expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n          expect(message.user_ids).to eq(group.users.map(&:id))\n        end\n      end\n\n      describe \"archiving topic\" do\n        it \"should publish the right message\" do\n          messages = MessageBus.track_publish do\n            TopicTrackingState.publish_private_message(\n              private_message_topic,\n              group_archive: true\n            )\n          end\n\n          expect(messages.map(&:channel)).to contain_exactly(\n            '/private-messages/inbox',\n            \"/private-messages/group/#{group1.name}/inbox\",\n            \"/private-messages/group/#{group1.name}/archive\",\n            \"/private-messages/group/#{group2.name}/inbox\",\n            \"/private-messages/group/#{group2.name}/archive\",\n          )\n\n          message = messages.find { |m| m.channel == '/private-messages/inbox' }\n\n          expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n          expect(message.user_ids).to eq(private_message_topic.allowed_users.map(&:id))\n\n          [group1, group2].each do |group|\n            [\n              \"/private-messages/group/#{group.name}/inbox\",\n              \"/private-messages/group/#{group.name}/archive\"\n            ].each do |channel|\n              message = messages.find { |m| m.channel == channel }\n              expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n              expect(message.user_ids).to eq(group.users.map(&:id))\n            end\n          end\n        end\n      end\n    end\n\n    describe 'topic with new post' do\n      let(:user) { private_message_topic.allowed_users.last }\n\n      let!(:post) do\n        Fabricate(:post,\n          topic: private_message_topic,\n          user: user\n        )\n      end\n\n      let!(:group) do\n        group = Fabricate(:group, users: [Fabricate(:user)])\n        private_message_topic.allowed_groups << group\n        group\n      end\n\n      it 'should publish the right message' do\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_private_message(\n            private_message_topic,\n            post: post\n          )\n        end\n\n        expected_channels = [\n          '/private-messages/inbox',\n          '/private-messages/sent',\n          \"/private-messages/group/#{group.name}/inbox\"\n        ]\n\n        expect(messages.map(&:channel)).to contain_exactly(*expected_channels)\n\n        expected_channels.zip([\n          private_message_topic.allowed_users.map(&:id),\n          [user.id],\n          [group.users.first.id]\n        ]).each do |channel, user_ids|\n          message = messages.find { |m| m.channel == channel }\n\n          expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n          expect(message.user_ids).to eq(user_ids)\n        end\n      end\n    end\n\n    describe 'archived topic' do\n      it 'should publish the right message' do\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_private_message(\n            private_message_topic,\n            archive_user_id: private_message_post.user_id,\n          )\n        end\n\n        expected_channels = [\n          \"/private-messages/archive\",\n          \"/private-messages/inbox\",\n          \"/private-messages/sent\",\n        ]\n\n        expect(messages.map(&:channel)).to eq(expected_channels)\n\n        expected_channels.each do |channel|\n          message = messages.find { |m| m.channel = channel }\n          expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n          expect(message.user_ids).to eq([private_message_post.user_id])\n        end\n      end\n    end\n\n    describe 'for a regular topic' do\n      it 'should not publish any message' do\n        topic.allowed_users << Fabricate(:user)\n\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_private_message(topic)\n        end\n\n        expect(messages).to eq([])\n      end\n    end\n  end\n\n  describe '#publish_read_private_message' do\n    fab!(:group) { Fabricate(:group) }\n    let(:read_topic_key) { \"/private-messages/unread-indicator/#{group_message.id}\" }\n    let(:read_post_key) { \"/topic/#{group_message.id}\" }\n    let(:latest_post_number) { 3 }\n    let(:group_message) { Fabricate(:private_message_topic,\n        allowed_groups: [group],\n        topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: user)],\n        highest_post_number: latest_post_number\n      )\n    }\n    let!(:post) {\n      Fabricate(:post, topic: group_message, post_number: latest_post_number)\n    }\n\n    before do\n      group.add(user)\n    end\n\n    it 'does not trigger a read count update if no allowed groups have the option enabled' do\n      messages = MessageBus.track_publish(read_post_key) do\n        TopicTrackingState.publish_read_indicator_on_read(group_message.id, latest_post_number, user.id)\n      end\n\n      expect(messages).to be_empty\n    end\n\n    context 'when the read indicator is enabled' do\n      before { group.update!(publish_read_state: true) }\n\n      it 'publishes a message to hide the unread indicator' do\n        message = MessageBus.track_publish(read_topic_key) do\n          TopicTrackingState.publish_read_indicator_on_read(group_message.id, latest_post_number, user.id)\n        end.first\n\n        expect(message.data['topic_id']).to eq group_message.id\n        expect(message.data['show_indicator']).to eq false\n      end\n\n      it 'publishes a message to show the unread indicator when a non-member creates a new post' do\n        allowed_user = Fabricate(:topic_allowed_user, topic: group_message)\n        message = MessageBus.track_publish(read_topic_key) do\n          TopicTrackingState.publish_read_indicator_on_write(group_message.id, latest_post_number, allowed_user.id)\n        end.first\n\n        expect(message.data['topic_id']).to eq group_message.id\n        expect(message.data['show_indicator']).to eq true\n      end\n\n      it 'does not publish the unread indicator if the message is not the last one' do\n        not_last_post_number = latest_post_number - 1\n        Fabricate(:post, topic: group_message, post_number: not_last_post_number)\n        messages = MessageBus.track_publish(read_topic_key) do\n          TopicTrackingState.publish_read_indicator_on_read(group_message.id, not_last_post_number, user.id)\n        end\n\n        expect(messages).to be_empty\n      end\n\n      it 'does not publish the read indicator if the user is not a group member' do\n        allowed_user = Fabricate(:topic_allowed_user, topic: group_message)\n        messages = MessageBus.track_publish(read_topic_key) do\n          TopicTrackingState.publish_read_indicator_on_read(group_message.id, latest_post_number, allowed_user.user_id)\n        end\n\n        expect(messages).to be_empty\n      end\n\n      it 'publish a read count update to every client' do\n        message = MessageBus.track_publish(read_post_key) do\n          TopicTrackingState.publish_read_indicator_on_read(group_message.id, latest_post_number, user.id)\n        end.first\n\n        expect(message.data[:type]).to eq :read\n      end\n    end\n  end\n\n  it \"correctly handles muted categories\" do\n\n    user = Fabricate(:user)\n    post\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n\n    CategoryUser.create!(user_id: user.id,\n                         notification_level: CategoryUser.notification_levels[:muted],\n                         category_id: post.topic.category_id\n                         )\n\n    create_post(topic_id: post.topic_id)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(0)\n\n    TopicUser.create!(user_id: user.id, topic_id: post.topic_id, last_read_post_number: 1, notification_level: 3)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n  end\n\n  it \"correctly handles category_users with null notification level\" do\n    user = Fabricate(:user)\n    post\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n\n    CategoryUser.create!(user_id: user.id, category_id: post.topic.category_id)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n  end\n\n  it \"works when categories are default muted\" do\n    SiteSetting.mute_all_categories_by_default = true\n\n    user = Fabricate(:user)\n    post\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(0)\n\n    CategoryUser.create!(user_id: user.id,\n                         notification_level: CategoryUser.notification_levels[:regular],\n                         category_id: post.topic.category_id\n                         )\n\n    create_post(topic_id: post.topic_id)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n  end\n\n  context 'muted tags' do\n    it \"remove_muted_tags_from_latest is set to always\" do\n      SiteSetting.remove_muted_tags_from_latest = 'always'\n      user = Fabricate(:user)\n      tag1 = Fabricate(:tag)\n      tag2 = Fabricate(:tag)\n      Fabricate(:topic_tag, tag: tag1, topic: topic)\n      Fabricate(:topic_tag, tag: tag2, topic: topic)\n      post\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n\n      TagUser.create!(user_id: user.id,\n                      notification_level: TagUser.notification_levels[:muted],\n                      tag_id: tag1.id\n                     )\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(0)\n\n      TopicTag.where(topic_id: topic.id).delete_all\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n    end\n\n    it \"remove_muted_tags_from_latest is set to only_muted\" do\n      SiteSetting.remove_muted_tags_from_latest = 'only_muted'\n      user = Fabricate(:user)\n      tag1 = Fabricate(:tag)\n      tag2 = Fabricate(:tag)\n      Fabricate(:topic_tag, tag: tag1, topic: topic)\n      Fabricate(:topic_tag, tag: tag2, topic: topic)\n      post\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n\n      TagUser.create!(user_id: user.id,\n                      notification_level: TagUser.notification_levels[:muted],\n                      tag_id: tag1.id\n                     )\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n\n      TagUser.create!(user_id: user.id,\n                      notification_level: TagUser.notification_levels[:muted],\n                      tag_id: tag2.id\n                     )\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(0)\n\n      TopicTag.where(topic_id: topic.id).delete_all\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n    end\n\n    it \"remove_muted_tags_from_latest is set to never\" do\n      SiteSetting.remove_muted_tags_from_latest = 'never'\n      user = Fabricate(:user)\n      tag1 = Fabricate(:tag)\n      Fabricate(:topic_tag, tag: tag1, topic: topic)\n      post\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n\n      TagUser.create!(user_id: user.id,\n                      notification_level: TagUser.notification_levels[:muted],\n                      tag_id: tag1.id\n                     )\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n    end\n  end\n\n  it \"correctly handles dismissed topics\" do\n    freeze_time 1.minute.ago\n    user = Fabricate(:user)\n    post\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n\n    DismissedTopicUser.create!(user_id: user.id, topic_id: post.topic_id, created_at: Time.zone.now)\n    CategoryUser.create!(user_id: user.id,\n                         notification_level: CategoryUser.notification_levels[:regular],\n                         category_id: post.topic.category_id,\n                         last_seen_at: post.topic.created_at\n                         )\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(0)\n  end\n\n  it \"correctly handles capping\" do\n    user = Fabricate(:user)\n\n    post1 = create_post\n    Fabricate(:post, topic: post1.topic)\n\n    post2 = create_post\n    Fabricate(:post, topic: post2.topic)\n\n    post3 = create_post\n    Fabricate(:post, topic: post3.topic)\n\n    tracking = {\n      notification_level: TopicUser.notification_levels[:tracking],\n      last_read_post_number: 1,\n    }\n\n    TopicUser.change(user.id, post1.topic_id, tracking)\n    TopicUser.change(user.id, post2.topic_id, tracking)\n    TopicUser.change(user.id, post3.topic_id, tracking)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(3)\n\n  end\n\n  context \"tag support\" do\n    after do\n      # this is a bit of an odd hook, but this is a global change\n      # used by plugins that leverage tagging heavily and need\n      # tag information in topic tracking state\n      TopicTrackingState.include_tags_in_report = false\n    end\n\n    it \"correctly handles tags\" do\n      SiteSetting.tagging_enabled = true\n\n      post.topic.notifier.watch_topic!(post.topic.user_id)\n\n      DiscourseTagging.tag_topic_by_names(\n        post.topic,\n        Guardian.new(Discourse.system_user),\n        ['bananas', 'apples']\n      )\n\n      TopicTrackingState.include_tags_in_report = true\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n      row = report[0]\n      expect(row.tags).to contain_exactly(\"apples\", \"bananas\")\n\n      TopicTrackingState.include_tags_in_report = false\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n      row = report[0]\n      expect(row.respond_to? :tags).to eq(false)\n    end\n  end\n\n  it \"correctly gets the tracking state\" do\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(0)\n\n    post.topic.notifier.watch_topic!(post.topic.user_id)\n\n    report = TopicTrackingState.report(user)\n\n    expect(report.length).to eq(1)\n    row = report[0]\n\n    expect(row.topic_id).to eq(post.topic_id)\n    expect(row.highest_post_number).to eq(1)\n    expect(row.last_read_post_number).to eq(nil)\n    expect(row.user_id).to eq(user.id)\n\n    # lets not leak out random users\n    expect(TopicTrackingState.report(post.user)).to be_empty\n\n    # lets not return anything if we scope on non-existing topic\n    expect(TopicTrackingState.report(user, post.topic_id + 1)).to be_empty\n\n    # when we reply the poster should have an unread row\n    create_post(user: user, topic: post.topic)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(0)\n\n    report = TopicTrackingState.report(post.user)\n    expect(report.length).to eq(1)\n\n    row = report[0]\n\n    expect(row.topic_id).to eq(post.topic_id)\n    expect(row.highest_post_number).to eq(2)\n    expect(row.last_read_post_number).to eq(1)\n    expect(row.user_id).to eq(post.user_id)\n\n    # when we have no permission to see a category, don't show its stats\n    category = Fabricate(:category, read_restricted: true)\n\n    post.topic.category_id = category.id\n    post.topic.save\n\n    expect(TopicTrackingState.report(post.user)).to be_empty\n    expect(TopicTrackingState.report(user)).to be_empty\n  end\n\n  describe \".report\" do\n    it \"correctly reports topics with staff posts\" do\n      create_post(\n        raw: \"this is a test post\",\n        topic: topic,\n        user: post.user\n      )\n\n      create_post(\n        raw: \"this is a test post\",\n        topic: topic,\n        post_type: Post.types[:whisper],\n        user: user\n      )\n\n      post.user.grant_admin!\n\n      state = TopicTrackingState.report(post.user)\n\n      expect(state.map(&:topic_id)).to contain_exactly(topic.id)\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\n# This class is used to mirror unread and new status back to end users\n# in JavaScript there is a mirror class that is kept in-sync using MessageBus\n# the allows end users to always know which topics have unread posts in them\n# and which topics are new. This is used in various places in the UI, such as\n# counters, indicators, and messages at the top of topic lists, so the user\n# knows there is something worth reading at a glance.\n#\n# The TopicTrackingState.report data is preloaded in ApplicationController\n# for the current user under the topicTrackingStates key, and the existing\n# state is loaded into memory on page load. From there the MessageBus is\n# used to keep topic state up to date, as well as syncing with topics from\n# corresponding lists fetched from the server (e.g. the /new, /latest,\n# /unread topic lists).\n#\n# See discourse/app/models/topic-tracking-state.js\nclass TopicTrackingState\n\n  include ActiveModel::SerializerSupport\n\n  UNREAD_MESSAGE_TYPE = \"unread\"\n  LATEST_MESSAGE_TYPE = \"latest\"\n  MUTED_MESSAGE_TYPE = \"muted\"\n  UNMUTED_MESSAGE_TYPE = \"unmuted\"\n  NEW_TOPIC_MESSAGE_TYPE = \"new_topic\"\n  RECOVER_MESSAGE_TYPE = \"recover\"\n  DELETE_MESSAGE_TYPE = \"delete\"\n  DESTROY_MESSAGE_TYPE = \"destroy\"\n  READ_MESSAGE_TYPE = \"read\"\n  DISMISS_NEW_MESSAGE_TYPE = \"dismiss_new\"\n  MAX_TOPICS = 5000\n\n  attr_accessor :user_id,\n                :topic_id,\n                :highest_post_number,\n                :last_read_post_number,\n                :created_at,\n                :category_id,\n                :notification_level,\n                :tags\n\n  def self.publish_new(topic)\n    return unless topic.regular?\n\n    tag_ids, tags = nil\n    if SiteSetting.tagging_enabled\n      tag_ids, tags = topic.tags.pluck(:id, :name).transpose\n    end\n\n    payload = {\n      last_read_post_number: nil,\n      highest_post_number: 1,\n      created_at: topic.created_at,\n      category_id: topic.category_id,\n      archetype: topic.archetype,\n      created_in_new_period: true\n    }\n\n    if tags\n      payload[:tags] = tags\n      payload[:topic_tag_ids] = tag_ids\n    end\n\n    message = {\n      topic_id: topic.id,\n      message_type: NEW_TOPIC_MESSAGE_TYPE,\n      payload: payload\n    }\n\n    group_ids = topic.category && topic.category.secure_group_ids\n\n    MessageBus.publish(\"/new\", message.as_json, group_ids: group_ids)\n    publish_read(topic.id, 1, topic.user_id)\n  end\n\n  def self.publish_latest(topic, staff_only = false)\n    return unless topic.regular?\n\n    tag_ids, tags = nil\n    if SiteSetting.tagging_enabled\n      tag_ids, tags = topic.tags.pluck(:id, :name).transpose\n    end\n\n    message = {\n      topic_id: topic.id,\n      message_type: LATEST_MESSAGE_TYPE,\n      payload: {\n        bumped_at: topic.bumped_at,\n        category_id: topic.category_id,\n        archetype: topic.archetype\n      }\n    }\n\n    if tags\n      message[:payload][:tags] = tags\n      message[:payload][:topic_tag_ids] = tag_ids\n    end\n\n    group_ids =\n      if staff_only\n        [Group::AUTO_GROUPS[:staff]]\n      else\n        topic.category && topic.category.secure_group_ids\n      end\n    MessageBus.publish(\"/latest\", message.as_json, group_ids: group_ids)\n  end\n\n  def self.unread_channel_key(user_id)\n    \"/unread/#{user_id}\"\n  end\n\n  def self.publish_muted(topic)\n    user_ids = topic.topic_users\n      .where(notification_level: NotificationLevels.all[:muted])\n      .joins(:user)\n      .where(\"users.last_seen_at > ?\", 7.days.ago)\n      .order(\"users.last_seen_at DESC\")\n      .limit(100)\n      .pluck(:user_id)\n    return if user_ids.blank?\n    message = {\n      topic_id: topic.id,\n      message_type: MUTED_MESSAGE_TYPE,\n    }\n    MessageBus.publish(\"/latest\", message.as_json, user_ids: user_ids)\n  end\n\n  def self.publish_unmuted(topic)\n    return if !SiteSetting.mute_all_categories_by_default\n    user_ids = User.watching_topic_when_mute_categories_by_default(topic)\n      .where(\"users.last_seen_at > ?\", 7.days.ago)\n      .order(\"users.last_seen_at DESC\")\n      .limit(100)\n      .pluck(:id)\n    return if user_ids.blank?\n    message = {\n      topic_id: topic.id,\n      message_type: UNMUTED_MESSAGE_TYPE,\n    }\n    MessageBus.publish(\"/latest\", message.as_json, user_ids: user_ids)\n  end\n\n  def self.publish_unread(post)\n    return unless post.topic.regular?\n    # TODO at high scale we are going to have to defer this,\n    #   perhaps cut down to users that are around in the last 7 days as well\n    tags = nil\n    tag_ids = nil\n    if include_tags_in_report?\n      tag_ids, tags = post.topic.tags.pluck(:id, :name).transpose\n    end\n\n    scope = TopicUser\n      .tracking(post.topic_id)\n      .includes(user: :user_stat)\n\n    group_ids =\n      if post.post_type == Post.types[:whisper]\n        [Group::AUTO_GROUPS[:staff]]\n      else\n        post.topic.category && post.topic.category.secure_group_ids\n      end\n\n    if group_ids.present?\n      scope = scope\n        .joins(\"INNER JOIN group_users gu ON gu.user_id = topic_users.user_id\")\n        .where(\"gu.group_id IN (?)\", group_ids)\n    end\n\n    scope\n      .select([:user_id, :last_read_post_number, :notification_level])\n      .each do |tu|\n\n      payload = {\n        last_read_post_number: tu.last_read_post_number,\n        highest_post_number: post.post_number,\n        updated_at: post.topic.updated_at,\n        created_at: post.created_at,\n        category_id: post.topic.category_id,\n        notification_level: tu.notification_level,\n        archetype: post.topic.archetype,\n        first_unread_at: tu.user.user_stat.first_unread_at,\n        unread_not_too_old: true\n      }\n\n      if tags\n        payload[:tags] = tags\n        payload[:topic_tag_ids] = tag_ids\n      end\n\n      message = {\n        topic_id: post.topic_id,\n        message_type: UNREAD_MESSAGE_TYPE,\n        payload: payload\n      }\n\n      MessageBus.publish(self.unread_channel_key(tu.user_id), message.as_json,\n        user_ids: [tu.user_id]\n      )\n    end\n\n  end\n\n  def self.publish_recover(topic)\n    group_ids = topic.category && topic.category.secure_group_ids\n\n    message = {\n      topic_id: topic.id,\n      message_type: RECOVER_MESSAGE_TYPE\n    }\n\n    MessageBus.publish(\"/recover\", message.as_json, group_ids: group_ids)\n\n  end\n\n  def self.publish_delete(topic)\n    group_ids = topic.category && topic.category.secure_group_ids\n\n    message = {\n      topic_id: topic.id,\n      message_type: DELETE_MESSAGE_TYPE\n    }\n\n    MessageBus.publish(\"/delete\", message.as_json, group_ids: group_ids)\n  end\n\n  def self.publish_destroy(topic)\n    group_ids = topic.category && topic.category.secure_group_ids\n\n    message = {\n      topic_id: topic.id,\n      message_type: DESTROY_MESSAGE_TYPE\n    }\n\n    MessageBus.publish(\"/destroy\", message.as_json, group_ids: group_ids)\n  end\n\n  def self.publish_read(topic_id, last_read_post_number, user_id, notification_level = nil)\n    highest_post_number = DB.query_single(\"SELECT highest_post_number FROM topics WHERE id = ?\", topic_id).first\n\n    message = {\n      topic_id: topic_id,\n      message_type: READ_MESSAGE_TYPE,\n      payload: {\n        last_read_post_number: last_read_post_number,\n        highest_post_number: highest_post_number,\n        notification_level: notification_level\n      }\n    }\n\n    MessageBus.publish(self.unread_channel_key(user_id), message.as_json, user_ids: [user_id])\n  end\n\n  def self.publish_dismiss_new(user_id, topic_ids: [])\n    message = {\n      message_type: DISMISS_NEW_MESSAGE_TYPE,\n      payload: {\n        topic_ids: topic_ids\n      }\n    }\n    MessageBus.publish(self.unread_channel_key(user_id), message.as_json, user_ids: [user_id])\n  end\n\n  def self.new_filter_sql\n    TopicQuery.new_filter(\n      Topic, treat_as_new_topic_clause_sql: treat_as_new_topic_clause\n    ).where_clause.ast.to_sql +\n      \" AND topics.created_at > :min_new_topic_date\" +\n      \" AND dismissed_topic_users.id IS NULL\"\n  end\n\n  def self.unread_filter_sql(staff: false)\n    TopicQuery.unread_filter(Topic, staff: staff).where_clause.ast.to_sql\n  end\n\n  def self.treat_as_new_topic_clause\n    User.where(\"GREATEST(CASE\n                  WHEN COALESCE(uo.new_topic_duration_minutes, :default_duration) = :always THEN u.created_at\n                  WHEN COALESCE(uo.new_topic_duration_minutes, :default_duration) = :last_visit THEN COALESCE(u.previous_visit_at,u.created_at)\n                  ELSE (:now::timestamp - INTERVAL '1 MINUTE' * COALESCE(uo.new_topic_duration_minutes, :default_duration))\n               END, u.created_at, :min_date)\",\n               treat_as_new_topic_params\n              ).where_clause.ast.to_sql\n  end\n\n  def self.treat_as_new_topic_params\n    {\n      now: DateTime.now,\n      last_visit: User::NewTopicDuration::LAST_VISIT,\n      always: User::NewTopicDuration::ALWAYS,\n      default_duration: SiteSetting.default_other_new_topic_duration_minutes,\n      min_date: Time.at(SiteSetting.min_new_topics_time).to_datetime\n    }\n  end\n\n  def self.include_tags_in_report?\n    SiteSetting.tagging_enabled && @include_tags_in_report\n  end\n\n  def self.include_tags_in_report=(v)\n    @include_tags_in_report = v\n  end\n\n  # Sam: this is a hairy report, in particular I need custom joins and fancy conditions\n  #  Dropping to sql_builder so I can make sense of it.\n  #\n  # Keep in mind, we need to be able to filter on a GROUP of users, and zero in on topic\n  #  all our existing scope work does not do this\n  #\n  # This code needs to be VERY efficient as it is triggered via the message bus and may steal\n  #  cycles from usual requests\n  def self.report(user, topic_id = nil)\n    tag_ids = muted_tag_ids(user)\n    sql = new_and_unread_sql(topic_id, user, tag_ids)\n    sql = tags_included_wrapped_sql(sql)\n\n    report = DB.query(\n      sql + \"\\n\\n LIMIT :max_topics\",\n      {\n        user_id: user.id,\n        topic_id: topic_id,\n        min_new_topic_date: Time.at(SiteSetting.min_new_topics_time).to_datetime,\n        max_topics: TopicTrackingState::MAX_TOPICS,\n      }\n      .merge(treat_as_new_topic_params)\n    )\n\n    report\n  end\n\n  def self.new_and_unread_sql(topic_id, user, tag_ids)\n    sql = report_raw_sql(\n      topic_id: topic_id,\n      skip_unread: true,\n      skip_order: true,\n      staff: user.staff?,\n      admin: user.admin?,\n      user: user,\n      muted_tag_ids: tag_ids\n    )\n\n    sql << \"\\nUNION ALL\\n\\n\"\n\n    sql << report_raw_sql(\n      topic_id: topic_id,\n      skip_new: true,\n      skip_order: true,\n      staff: user.staff?,\n      filter_old_unread: true,\n      admin: user.admin?,\n      user: user,\n      muted_tag_ids: tag_ids\n    )\n  end\n\n  def self.tags_included_wrapped_sql(sql)\n    if SiteSetting.tagging_enabled && TopicTrackingState.include_tags_in_report?\n      return <<~SQL\n        WITH tags_included_cte AS (\n          #{sql}\n        )\n        SELECT *, (\n          SELECT ARRAY_AGG(name) from topic_tags\n             JOIN tags on tags.id = topic_tags.tag_id\n             WHERE topic_id = tags_included_cte.topic_id\n          ) tags\n        FROM tags_included_cte\n      SQL\n    end\n\n    sql\n  end\n\n  def self.muted_tag_ids(user)\n    TagUser.lookup(user, :muted).pluck(:tag_id)\n  end\n\n  def self.report_raw_sql(\n    user:,\n    muted_tag_ids:,\n    topic_id: nil,\n    filter_old_unread: false,\n    skip_new: false,\n    skip_unread: false,\n    skip_order: false,\n    staff: false,\n    admin: false,\n    select: nil,\n    custom_state_filter: nil,\n    additional_join_sql: nil\n  )\n    unread =\n      if skip_unread\n        \"1=0\"\n      else\n        unread_filter_sql(staff: staff)\n      end\n\n    filter_old_unread_sql =\n      if filter_old_unread\n        \" topics.updated_at >= us.first_unread_at AND \"\n      else\n        \"\"\n      end\n\n    new =\n      if skip_new\n        \"1=0\"\n      else\n        new_filter_sql\n      end\n\n    select_sql = select || \"\n           DISTINCT topics.id as topic_id,\n           u.id as user_id,\n           topics.created_at,\n           topics.updated_at,\n           #{highest_post_number_column_select(staff)},\n           last_read_post_number,\n           c.id as category_id,\n           tu.notification_level,\n           us.first_unread_at,\n           GREATEST(\n              CASE\n              WHEN COALESCE(uo.new_topic_duration_minutes, :default_duration) = :always THEN u.created_at\n              WHEN COALESCE(uo.new_topic_duration_minutes, :default_duration) = :last_visit THEN COALESCE(\n                u.previous_visit_at,u.created_at\n              )\n              ELSE (:now::timestamp - INTERVAL '1 MINUTE' * COALESCE(uo.new_topic_duration_minutes, :default_duration))\n              END, u.created_at, :min_date\n           ) AS treat_as_new_topic_start_date\"\n\n    category_filter =\n      if admin\n        \"\"\n      else\n        append = \"OR u.admin\" if !admin\n        <<~SQL\n          (\n           NOT c.read_restricted #{append} OR c.id IN (\n              SELECT c2.id FROM categories c2\n              JOIN category_groups cg ON cg.category_id = c2.id\n              JOIN group_users gu ON gu.user_id = :user_id AND cg.group_id = gu.group_id\n              WHERE c2.read_restricted )\n          ) AND\n        SQL\n      end\n\n    visibility_filter =\n      if staff\n        \"\"\n      else\n        append = \"OR u.admin OR u.moderator\" if !staff\n        \"(topics.visible #{append}) AND\"\n      end\n\n    tags_filter = \"\"\n\n    if muted_tag_ids.present? && ['always', 'only_muted'].include?(SiteSetting.remove_muted_tags_from_latest)\n      existing_tags_sql = \"(select array_agg(tag_id) from topic_tags where topic_tags.topic_id = topics.id)\"\n      muted_tags_array_sql = \"ARRAY[#{muted_tag_ids.join(',')}]\"\n\n      if SiteSetting.remove_muted_tags_from_latest == 'always'\n        tags_filter = <<~SQL\n          NOT (\n            COALESCE(#{existing_tags_sql}, ARRAY[]::int[]) && #{muted_tags_array_sql}\n          ) AND\n        SQL\n      else # only muted\n        tags_filter = <<~SQL\n          NOT (\n            COALESCE(#{existing_tags_sql}, ARRAY[-999]) <@ #{muted_tags_array_sql}\n          ) AND\n        SQL\n      end\n    end\n\n    sql = +<<~SQL\n      SELECT #{select_sql}\n      FROM topics\n      JOIN users u on u.id = :user_id\n      JOIN user_stats AS us ON us.user_id = u.id\n      JOIN user_options AS uo ON uo.user_id = u.id\n      JOIN categories c ON c.id = topics.category_id\n      LEFT JOIN topic_users tu ON tu.topic_id = topics.id AND tu.user_id = u.id\n      LEFT JOIN category_users ON category_users.category_id = topics.category_id AND category_users.user_id = #{user.id}\n      LEFT JOIN dismissed_topic_users ON dismissed_topic_users.topic_id = topics.id AND dismissed_topic_users.user_id = #{user.id}\n      #{additional_join_sql}\n      WHERE u.id = :user_id AND\n            #{filter_old_unread_sql}\n            topics.archetype <> 'private_message' AND\n            #{custom_state_filter ? custom_state_filter : \"((#{unread}) OR (#{new})) AND\"}\n            #{visibility_filter}\n            #{tags_filter}\n            topics.deleted_at IS NULL AND\n            #{category_filter}\n            NOT (\n              #{(skip_new && skip_unread) ? \"\" : \"last_read_post_number IS NULL AND\"}\n              (\n                COALESCE(category_users.notification_level, #{CategoryUser.default_notification_level}) = #{CategoryUser.notification_levels[:muted]}\n                AND tu.notification_level <= #{TopicUser.notification_levels[:regular]}\n              )\n            )\n    SQL\n\n    if topic_id\n      sql << \" AND topics.id = :topic_id\"\n    end\n\n    unless skip_order\n      sql << \" ORDER BY topics.bumped_at DESC\"\n    end\n\n    sql\n  end\n\n  def self.highest_post_number_column_select(staff)\n    \"#{staff ? \"topics.highest_staff_post_number AS highest_post_number\" : \"topics.highest_post_number\"}\"\n  end\n\n  def self.publish_private_message(topic, archive_user_id: nil,\n                                          post: nil,\n                                          group_archive: false)\n\n    return unless topic.private_message?\n    channels = {}\n\n    allowed_user_ids = topic.allowed_users.pluck(:id)\n\n    if post && allowed_user_ids.include?(post.user_id)\n      channels[\"/private-messages/sent\"] = [post.user_id]\n    end\n\n    if archive_user_id\n      user_ids = [archive_user_id]\n\n      [\n        \"/private-messages/archive\",\n        \"/private-messages/inbox\",\n        \"/private-messages/sent\",\n      ].each do |channel|\n        channels[channel] = user_ids\n      end\n    end\n\n    if channels.except(\"/private-messages/sent\").blank?\n      channels[\"/private-messages/inbox\"] = allowed_user_ids\n    end\n\n    topic.allowed_groups.each do |group|\n      group_user_ids = group.users.pluck(:id)\n      next if group_user_ids.blank?\n      group_channels = []\n      channel_prefix = \"/private-messages/group/#{group.name.downcase}\"\n      group_channels << \"#{channel_prefix}/inbox\"\n      group_channels << \"#{channel_prefix}/archive\" if group_archive\n      group_channels.each { |channel| channels[channel] = group_user_ids }\n    end\n\n    message = {\n      topic_id: topic.id\n    }\n\n    channels.each do |channel, ids|\n      if ids.present?\n        MessageBus.publish(\n          channel,\n          message.as_json,\n          user_ids: ids\n        )\n      end\n    end\n  end\n\n  def self.publish_read_indicator_on_write(topic_id, last_read_post_number, user_id)\n    topic = Topic.includes(:allowed_groups).select(:highest_post_number, :archetype, :id).find_by(id: topic_id)\n\n    if topic&.private_message?\n      groups = read_allowed_groups_of(topic)\n      update_topic_list_read_indicator(topic, groups, topic.highest_post_number, user_id, true)\n    end\n  end\n\n  def self.publish_read_indicator_on_read(topic_id, last_read_post_number, user_id)\n    topic = Topic.includes(:allowed_groups).select(:highest_post_number, :archetype, :id).find_by(id: topic_id)\n\n    if topic&.private_message?\n      groups = read_allowed_groups_of(topic)\n      post = Post.find_by(topic_id: topic.id, post_number: last_read_post_number)\n      trigger_post_read_count_update(post, groups, last_read_post_number, user_id)\n      update_topic_list_read_indicator(topic, groups, last_read_post_number, user_id, false)\n    end\n  end\n\n  def self.read_allowed_groups_of(topic)\n    topic.allowed_groups\n      .joins(:group_users)\n      .where(publish_read_state: true)\n      .select('ARRAY_AGG(group_users.user_id) AS members', :name, :id)\n      .group('groups.id')\n  end\n\n  def self.update_topic_list_read_indicator(topic, groups, last_read_post_number, user_id, write_event)\n    return unless last_read_post_number == topic.highest_post_number\n    message = { topic_id: topic.id, show_indicator: write_event }.as_json\n    groups_to_update = []\n\n    groups.each do |group|\n      member = group.members.include?(user_id)\n\n      member_writing = (write_event && member)\n      non_member_reading = (!write_event && !member)\n      next if non_member_reading || member_writing\n\n      groups_to_update << group\n    end\n\n    return if groups_to_update.empty?\n    MessageBus.publish(\"/private-messages/unread-indicator/#{topic.id}\", message, user_ids: groups_to_update.flat_map(&:members))\n  end\n\n  def self.trigger_post_read_count_update(post, groups, last_read_post_number, user_id)\n    return if !post\n    return if groups.empty?\n    opts = { readers_count: post.readers_count, reader_id: user_id }\n    post.publish_change_to_clients!(:read, opts)\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'post_creator'\nrequire 'topic_subtype'\n\ndescribe PostCreator do\n\n  fab!(:user) { Fabricate(:user) }\n  let(:topic) { Fabricate(:topic, user: user) }\n\n  context \"new topic\" do\n    fab!(:category) { Fabricate(:category, user: user) }\n    let(:basic_topic_params) { { title: \"hello world topic\", raw: \"my name is fred\", archetype_id: 1 } }\n    let(:image_sizes) { { 'http://an.image.host/image.jpg' => { \"width\" => 111, \"height\" => 222 } } }\n\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n    let(:creator_with_category) { PostCreator.new(user, basic_topic_params.merge(category: category.id)) }\n    let(:creator_with_meta_data) { PostCreator.new(user, basic_topic_params.merge(meta_data: { hello: \"world\" })) }\n    let(:creator_with_image_sizes) { PostCreator.new(user, basic_topic_params.merge(image_sizes: image_sizes)) }\n    let(:creator_with_featured_link) { PostCreator.new(user, title: \"featured link topic\", archetype_id: 1, featured_link: \"http://www.discourse.org\", raw: \"http://www.discourse.org\") }\n\n    it \"can create a topic with null byte central\" do\n      post = PostCreator.create(user, title: \"hello\\u0000world this is title\", raw: \"this is my\\u0000 first topic\")\n      expect(post.raw).to eq 'this is my first topic'\n      expect(post.topic.title).to eq 'Helloworld this is title'\n    end\n\n    it \"can be created with auto tracking disabled\" do\n      p = PostCreator.create(user, basic_topic_params.merge(auto_track: false))\n      # must be 0 otherwise it will think we read the topic which is clearly untrue\n      expect(TopicUser.where(user_id: p.user_id, topic_id: p.topic_id).count).to eq(0)\n    end\n\n    it \"can be created with first post as wiki\" do\n      cat = Fabricate(:category)\n      cat.all_topics_wiki = true\n      cat.save\n      post = PostCreator.create(user, basic_topic_params.merge(category: cat.id))\n      expect(post.wiki).to eq(true)\n    end\n\n    it \"can be created with a hidden reason\" do\n      hri = Post.hidden_reasons[:flag_threshold_reached]\n      post = PostCreator.create(user, basic_topic_params.merge(hidden_reason_id: hri))\n      expect(post.hidden).to eq(true)\n      expect(post.hidden_at).to be_present\n      expect(post.hidden_reason_id).to eq(hri)\n      expect(post.topic.visible).to eq(false)\n    end\n\n    it \"ensures the user can create the topic\" do\n      Guardian.any_instance.expects(:can_create?).with(Topic, nil).returns(false)\n      expect { creator.create }.to raise_error(Discourse::InvalidAccess)\n    end\n\n    it \"can be created with custom fields\" do\n      post = PostCreator.create(user, basic_topic_params.merge(topic_opts: { custom_fields: { hello: \"world\" } }))\n      expect(post.topic.custom_fields).to eq(\"hello\" => \"world\")\n    end\n\n    context \"reply to post number\" do\n      it \"omits reply to post number if received on a new topic\" do\n        p = PostCreator.new(user, basic_topic_params.merge(reply_to_post_number: 3)).create\n        expect(p.reply_to_post_number).to be_nil\n      end\n    end\n\n    context \"invalid title\" do\n      let(:creator_invalid_title) { PostCreator.new(user, basic_topic_params.merge(title: 'a')) }\n\n      it \"has errors\" do\n        creator_invalid_title.create\n        expect(creator_invalid_title.errors).to be_present\n      end\n    end\n\n    context \"invalid raw\" do\n      let(:creator_invalid_raw) { PostCreator.new(user, basic_topic_params.merge(raw: '')) }\n\n      it \"has errors\" do\n        creator_invalid_raw.create\n        expect(creator_invalid_raw.errors).to be_present\n      end\n    end\n\n    context \"success\" do\n      before { creator }\n\n      it \"is not hidden\" do\n        p = creator.create\n        expect(p.hidden).to eq(false)\n        expect(p.hidden_at).not_to be_present\n        expect(p.hidden_reason_id).to eq(nil)\n        expect(p.topic.visible).to eq(true)\n      end\n\n      it \"doesn't return true for spam\" do\n        creator.create\n        expect(creator.spam?).to eq(false)\n      end\n\n      it \"triggers extensibility events\" do\n        events = DiscourseEvent.track_events { creator.create }\n\n        expect(events.map { |event| event[:event_name] }).to include(\n          :before_create_post,\n          :validate_post,\n          :topic_created,\n          :post_created,\n          :after_validate_topic,\n          :before_create_topic,\n          :after_trigger_post_process,\n          :markdown_context,\n          :topic_notification_level_changed,\n        )\n      end\n\n      it \"does not notify on system messages\" do\n        admin = Fabricate(:admin)\n        messages = MessageBus.track_publish do\n          p = PostCreator.create(admin, basic_topic_params.merge(post_type: Post.types[:moderator_action]))\n          PostCreator.create(admin, basic_topic_params.merge(topic_id: p.topic_id, post_type: Post.types[:moderator_action]))\n        end\n        # don't notify on system messages they introduce too much noise\n        channels = messages.map(&:channel)\n        expect(channels.find { |s| s =~ /unread/ }).to eq(nil)\n        expect(channels.find { |s| s =~ /new/ }).to eq(nil)\n      end\n\n      it 'enqueues job to generate messages' do\n        p = creator.create\n        expect(job_enqueued?(job: :post_update_topic_tracking_state, args: { post_id: p.id })).to eq(true)\n      end\n\n      it \"generates the correct messages for a secure topic\" do\n        Jobs.run_immediately!\n        UserActionManager.enable\n\n        admin = Fabricate(:user)\n        admin.grant_admin!\n\n        cat = Fabricate(:category)\n        cat.set_permissions(admins: :full)\n        cat.save\n\n        created_post = nil\n\n        messages = MessageBus.track_publish do\n          created_post = PostCreator.new(admin, basic_topic_params.merge(category: cat.id)).create\n          _reply = PostCreator.new(admin, raw: \"this is my test reply 123 testing\", topic_id: created_post.topic_id).create\n        end\n\n        messages.filter! { |m| m.channel != \"/distributed_hash\" }\n\n        channels = messages.map { |m| m.channel }.sort\n\n        # 2 for topic, one to notify of new topic another for tracking state\n        expect(channels).to eq(\n          [\n            \"/new\",\n            \"/u/#{admin.username}\",\n            \"/u/#{admin.username}\",\n            \"/unread/#{admin.id}\",\n            \"/unread/#{admin.id}\",\n            \"/latest\",\n            \"/latest\",\n            \"/topic/#{created_post.topic_id}\",\n            \"/topic/#{created_post.topic_id}\",\n            \"/user\",\n            \"/user\",\n            \"/user\"\n          ].sort\n        )\n\n        admin_ids = [Group[:admins].id]\n        expect(messages.any? { |m| m.group_ids != admin_ids && m.user_ids != [admin.id] }).to eq(false)\n      end\n\n      it 'generates the correct messages for a normal topic' do\n        Jobs.run_immediately!\n        UserActionManager.enable\n\n        p = nil\n        messages = MessageBus.track_publish do\n          p = creator.create\n        end\n\n        latest = messages.find { |m| m.channel == \"/latest\" }\n        expect(latest).not_to eq(nil)\n\n        latest = messages.find { |m| m.channel == \"/new\" }\n        expect(latest).not_to eq(nil)\n\n        read = messages.find { |m| m.channel == \"/unread/#{p.user_id}\" }\n        expect(read).not_to eq(nil)\n\n        user_action = messages.find { |m| m.channel == \"/u/#{p.user.username}\" }\n        expect(user_action).not_to eq(nil)\n\n        draft_count = messages.find { |m| m.channel == \"/user\" }\n        expect(draft_count).not_to eq(nil)\n\n        expect(messages.filter { |m| m.channel != \"/distributed_hash\" }.length).to eq(7)\n      end\n\n      it 'extracts links from the post' do\n        create_post(raw: \"this is a link to the best site at https://google.com\")\n        creator.create\n        expect(TopicLink.count).to eq(1)\n      end\n\n      it 'queues up post processing job when saved' do\n        creator.create\n\n        post = Post.last\n        post_id = post.id\n        topic_id = post.topic_id\n\n        process_post_args = Jobs::ProcessPost.jobs.first[\"args\"].first\n        expect(process_post_args[\"post_id\"]).to eq(post_id)\n\n        feature_topic_users_args = Jobs::FeatureTopicUsers.jobs.first[\"args\"].first\n        expect(feature_topic_users_args[\"topic_id\"]).to eq(topic_id)\n\n        post_alert_args = Jobs::PostAlert.jobs.first[\"args\"].first\n        expect(post_alert_args[\"post_id\"]).to eq(post_id)\n\n        notify_mailing_list_subscribers_args =\n          Jobs::NotifyMailingListSubscribers.jobs.first[\"args\"].first\n\n        expect(notify_mailing_list_subscribers_args[\"post_id\"]).to eq(post_id)\n      end\n\n      it 'passes the invalidate_oneboxes along to the job if present' do\n        creator.opts[:invalidate_oneboxes] = true\n        creator.create\n\n        expect(job_enqueued?(job: :process_post, args: { invalidate_oneboxes: true })).to eq(true)\n      end\n\n      it 'passes the image_sizes along to the job if present' do\n        image_sizes = { 'http://an.image.host/image.jpg' => { 'width' => 17, 'height' => 31 } }\n        creator.opts[:image_sizes] = image_sizes\n        creator.create\n\n        expect(job_enqueued?(job: :process_post, args: { image_sizes: image_sizes })).to eq(true)\n      end\n\n      it 'assigns a category when supplied' do\n        expect(creator_with_category.create.topic.category).to eq(category)\n      end\n\n      it 'adds  meta data from the post' do\n        expect(creator_with_meta_data.create.topic.meta_data['hello']).to eq('world')\n      end\n\n      it 'passes the image sizes through' do\n        Post.any_instance.expects(:image_sizes=).with(image_sizes)\n        creator_with_image_sizes.create\n      end\n\n      it 'sets topic excerpt if first post, but not second post' do\n        first_post = creator.create\n        topic = first_post.topic.reload\n        expect(topic.excerpt).to be_present\n        expect {\n          PostCreator.new(first_post.user, topic_id: first_post.topic_id, raw: \"this is the second post\").create\n          topic.reload\n        }.to_not change { topic.excerpt }\n      end\n\n      it 'supports custom excerpts' do\n        raw = <<~MD\n          <div class='excerpt'>\n          I am\n\n          a custom excerpt\n          </div>\n\n          testing\n        MD\n        post = create_post(raw: raw)\n\n        expect(post.excerpt).to eq(\"I am\\na custom excerpt\")\n      end\n\n      it 'creates post stats' do\n        Draft.set(user, Draft::NEW_TOPIC, 0, \"test\")\n        Draft.set(user, Draft::NEW_TOPIC, 0, \"test1\")\n        expect(user.user_stat.draft_count).to eq(1)\n\n        begin\n          PostCreator.track_post_stats = true\n          post = creator.create\n          expect(post.post_stat.typing_duration_msecs).to eq(0)\n          expect(post.post_stat.drafts_saved).to eq(2)\n          expect(user.reload.user_stat.draft_count).to eq(0)\n        ensure\n          PostCreator.track_post_stats = false\n        end\n      end\n\n      it \"updates topic stats\" do\n        first_post = creator.create\n        topic = first_post.topic.reload\n\n        expect(topic.last_posted_at).to eq_time(first_post.created_at)\n        expect(topic.last_post_user_id).to eq(first_post.user_id)\n        expect(topic.word_count).to eq(4)\n      end\n\n      it 'creates a post with featured link' do\n        SiteSetting.topic_featured_link_enabled = true\n        SiteSetting.min_first_post_length = 100\n\n        post = creator_with_featured_link.create\n        expect(post.topic.featured_link).to eq('http://www.discourse.org')\n        expect(post.valid?).to eq(true)\n      end\n\n      it 'allows notification email to be skipped' do\n        user_2 = Fabricate(:user)\n\n        creator = PostCreator.new(user,\n          title: 'hi there welcome to my topic',\n          raw: \"this is my awesome message @#{user_2.username_lower}\",\n          archetype: Archetype.private_message,\n          target_usernames: [user_2.username],\n          post_alert_options: { skip_send_email: true }\n        )\n\n        NotificationEmailer.expects(:process_notification).never\n\n        creator.create\n      end\n\n      describe \"topic's auto close\" do\n        it \"doesn't update topic's auto close when it's not based on last post\" do\n          freeze_time\n\n          topic = Fabricate(:topic).set_or_create_timer(TopicTimer.types[:close], 12)\n          PostCreator.new(topic.user, topic_id: topic.id, raw: \"this is a second post\").create\n          topic.reload\n\n          topic_status_update = TopicTimer.last\n          expect(topic_status_update.execute_at).to eq_time(12.hours.from_now)\n          expect(topic_status_update.created_at).to eq_time(Time.zone.now)\n        end\n\n        describe \"topic's auto close based on last post\" do\n          fab!(:topic_timer) do\n            Fabricate(:topic_timer,\n              based_on_last_post: true,\n              execute_at: Time.zone.now - 12.hours,\n              created_at: Time.zone.now - 24.hours,\n              duration_minutes: 12 * 60\n            )\n          end\n\n          let(:topic) { topic_timer.topic }\n\n          fab!(:post) do\n            Fabricate(:post, topic: topic_timer.topic)\n          end\n\n          it \"updates topic's auto close date\" do\n            freeze_time\n            post\n\n            PostCreator.new(\n              topic.user,\n              topic_id: topic.id,\n              raw: \"this is a second post\"\n            ).create\n\n            topic_timer.reload\n\n            expect(topic_timer.execute_at).to eq_time(Time.zone.now + 12.hours)\n            expect(topic_timer.created_at).to eq_time(Time.zone.now)\n          end\n\n          describe \"when auto_close_topics_post_count has been reached\" do\n            before do\n              SiteSetting.auto_close_topics_post_count = 2\n            end\n\n            it \"closes the topic and deletes the topic timer\" do\n              freeze_time\n              post\n\n              PostCreator.new(\n                topic.user,\n                topic_id: topic.id,\n                raw: \"this is a second post\"\n              ).create\n\n              topic.reload\n\n              expect(topic.posts.last.raw).to eq(I18n.t(\n                'topic_statuses.autoclosed_topic_max_posts',\n                count: SiteSetting.auto_close_topics_post_count\n              ))\n\n              expect(topic.closed).to eq(true)\n              expect(topic_timer.reload.deleted_at).to eq_time(Time.zone.now)\n            end\n\n            it \"uses the system locale for the message\" do\n              post\n\n              I18n.with_locale(:fr) do\n                PostCreator.new(\n                  topic.user,\n                  topic_id: topic.id,\n                  raw: \"this is a second post\"\n                ).create\n              end\n\n              topic.reload\n\n              expect(topic.posts.last.raw).to eq(I18n.t(\n                'topic_statuses.autoclosed_topic_max_posts',\n                count: SiteSetting.auto_close_topics_post_count,\n                locale: :en\n              ))\n            end\n\n            describe \"auto_close_topics_create_linked_topic is enabled\" do\n              before do\n                SiteSetting.auto_close_topics_create_linked_topic = true\n              end\n\n              it \"enqueues a job to create a new linked topic\" do\n                freeze_time\n                post\n\n                post_2 = PostCreator.new(\n                  topic.user,\n                  topic_id: topic.id,\n                  raw: \"this is a second post\"\n                ).create\n\n                topic.reload\n\n                expect(topic.closed).to eq(true)\n                expect(topic_timer.reload.deleted_at).to eq_time(Time.zone.now)\n                expect(job_enqueued?(job: :create_linked_topic, args: { post_id: post_2.id })).to eq(true)\n              end\n            end\n          end\n        end\n      end\n\n      context \"tags\" do\n        let(:tag_names) { ['art', 'science', 'dance'] }\n        let(:creator_with_tags) { PostCreator.new(user, basic_topic_params.merge(tags: tag_names)) }\n\n        context \"tagging disabled\" do\n          before do\n            SiteSetting.tagging_enabled = false\n          end\n\n          it \"doesn't create tags\" do\n            expect { @post = creator_with_tags.create }.to change { Tag.count }.by(0)\n            expect(@post.topic&.tags&.size).to eq(nil)\n          end\n        end\n\n        context \"tagging enabled\" do\n          before do\n            SiteSetting.tagging_enabled = true\n          end\n\n          context \"can create tags\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 0\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            it \"can create all tags if none exist\" do\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(tag_names.size)\n              expect(@post.topic.tags.map(&:name).sort).to eq(tag_names.sort)\n            end\n\n            it \"creates missing tags if some exist\" do\n              _existing_tag1 = Fabricate(:tag, name: tag_names[0])\n              _existing_tag1 = Fabricate(:tag, name: tag_names[1])\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(tag_names.size - 2)\n              expect(@post.topic.tags.map(&:name).sort).to eq(tag_names.sort)\n            end\n          end\n\n          context \"cannot create tags\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 4\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            it \"only uses existing tags\" do\n              existing_tag1 = Fabricate(:tag, name: tag_names[1])\n              expect { @post = creator_with_tags.create }.to change { Tag.count }.by(0)\n              expect(@post.topic.tags.map(&:name)).to eq([existing_tag1.name])\n            end\n          end\n\n          context \"automatically tags first posts\" do\n            before do\n              SiteSetting.min_trust_to_create_tag = 0\n              SiteSetting.min_trust_level_to_tag_topics = 0\n            end\n\n            context \"without regular expressions\" do\n              it \"works with many tags\" do\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"HELLO\", replacement: \"greetings , hey\")\n\n                @post = creator.create\n                expect(@post.topic.tags.map(&:name)).to match_array(['greetings', 'hey'])\n              end\n\n              it \"works with overlapping words\" do\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"art\", replacement: \"about-art\")\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"artist*\", replacement: \"about-artists\")\n\n                post = PostCreator.new(user, title: \"hello world topic\", raw: \"this is topic abour artists\", archetype_id: 1).create\n                expect(post.topic.tags.map(&:name)).to match_array(['about-artists'])\n              end\n\n              it \"does not treat as regular expressions\" do\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"he(llo|y)\", replacement: \"greetings , hey\")\n\n                @post = creator_with_tags.create\n                expect(@post.topic.tags.map(&:name)).to match_array(tag_names)\n              end\n            end\n\n            context \"with regular expressions\" do\n              it \"works\" do\n                SiteSetting.watched_words_regular_expressions = true\n                Fabricate(:watched_word, action: WatchedWord.actions[:tag], word: \"he(llo|y)\", replacement: \"greetings , hey\")\n\n                @post = creator_with_tags.create\n                expect(@post.topic.tags.map(&:name)).to match_array(tag_names + ['greetings', 'hey'])\n              end\n            end\n          end\n        end\n      end\n    end\n\n    context 'when auto-close param is given' do\n      it 'ensures the user can auto-close the topic, but ignores auto-close param silently' do\n        Guardian.any_instance.stubs(:can_moderate?).returns(false)\n        expect {\n          PostCreator.new(user, basic_topic_params.merge(auto_close_time: 2)).create!\n        }.to_not change { TopicTimer.count }\n      end\n    end\n  end\n\n  context 'whisper' do\n    fab!(:topic) { Fabricate(:topic, user: user) }\n\n    it 'whispers do not mess up the public view' do\n      # turns out this can fail on leap years if we don't do this\n      freeze_time DateTime.parse('2010-01-01 12:00')\n\n      first = PostCreator.new(\n        user,\n        topic_id: topic.id,\n        raw: 'this is the first post'\n      ).create\n\n      freeze_time 1.year.from_now\n\n      user_stat = user.user_stat\n\n      whisper = PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: 1,\n        post_type: Post.types[:whisper],\n        raw: 'this is a whispered reply').create\n\n      # don't count whispers in user stats\n      expect(user_stat.reload.post_count).to eq(0)\n\n      expect(whisper).to be_present\n      expect(whisper.post_type).to eq(Post.types[:whisper])\n\n      whisper_reply = PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: whisper.post_number,\n        post_type: Post.types[:regular],\n        raw: 'replying to a whisper this time').create\n\n      expect(whisper_reply).to be_present\n      expect(whisper_reply.post_type).to eq(Post.types[:whisper])\n\n      expect(user_stat.reload.post_count).to eq(0)\n\n      user.reload\n      expect(user.last_posted_at).to eq_time(1.year.ago)\n\n      # date is not precise enough in db\n      whisper_reply.reload\n\n      first.reload\n      # does not leak into the OP\n      expect(first.reply_count).to eq(0)\n\n      topic.reload\n\n      # cause whispers should not muck up that number\n      expect(topic.highest_post_number).to eq(1)\n      expect(topic.reply_count).to eq(0)\n      expect(topic.posts_count).to eq(1)\n      expect(topic.highest_staff_post_number).to eq(3)\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.last_post_user_id).to eq(first.user_id)\n      expect(topic.word_count).to eq(5)\n\n      topic.update_columns(\n        highest_staff_post_number: 0,\n        highest_post_number: 0,\n        posts_count: 0,\n        last_posted_at: 1.year.ago\n      )\n\n      Topic.reset_highest(topic.id)\n\n      topic.reload\n      expect(topic.highest_post_number).to eq(1)\n      expect(topic.posts_count).to eq(1)\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.highest_staff_post_number).to eq(3)\n    end\n  end\n\n  context 'silent' do\n    fab!(:topic) { Fabricate(:topic, user: user) }\n\n    it 'silent do not mess up the public view' do\n      freeze_time DateTime.parse('2010-01-01 12:00')\n\n      first = PostCreator.new(\n        user,\n        topic_id: topic.id,\n        raw: 'this is the first post'\n      ).create\n\n      freeze_time 1.year.from_now\n\n      PostCreator.new(user,\n        topic_id: topic.id,\n        reply_to_post_number: 1,\n        silent: true,\n        post_type: Post.types[:regular],\n        raw: 'this is a whispered reply').create\n\n      topic.reload\n\n      # silent post should not muck up that number\n      expect(topic.last_posted_at).to eq_time(first.created_at)\n      expect(topic.last_post_user_id).to eq(first.user_id)\n      expect(topic.word_count).to eq(5)\n    end\n  end\n\n  context 'uniqueness' do\n\n    fab!(:topic) { Fabricate(:topic, user: user) }\n    let(:basic_topic_params) { { raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4 } }\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n\n    context \"disabled\" do\n      before do\n        SiteSetting.unique_posts_mins = 0\n        creator.create\n      end\n\n      it \"returns true for another post with the same content\" do\n        new_creator = PostCreator.new(user, basic_topic_params)\n        expect(new_creator.create).to be_present\n      end\n    end\n\n    context 'enabled' do\n      let(:new_post_creator) { PostCreator.new(user, basic_topic_params) }\n\n      before do\n        SiteSetting.unique_posts_mins = 10\n      end\n\n      it \"fails for dupe post across topic\" do\n        first = create_post(raw: \"this is a test #{SecureRandom.hex}\")\n        second = create_post(raw: \"this is a test #{SecureRandom.hex}\")\n\n        dupe = \"hello 123 test #{SecureRandom.hex}\"\n\n        response_1 = PostCreator.create(first.user, raw: dupe, topic_id: first.topic_id)\n        response_2 = PostCreator.create(first.user, raw: dupe, topic_id: second.topic_id)\n\n        expect(response_1.errors.count).to eq(0)\n        expect(response_2.errors.count).to eq(1)\n      end\n\n      it \"returns blank for another post with the same content\" do\n        creator.create\n        post = new_post_creator.create\n\n        expect(post.errors[:raw]).to include(I18n.t(:just_posted_that))\n      end\n\n      it \"returns a post for admins\" do\n        creator.create\n        user.admin = true\n        new_post_creator.create\n        expect(new_post_creator.errors).to be_blank\n      end\n\n      it \"returns a post for moderators\" do\n        creator.create\n        user.moderator = true\n        new_post_creator.create\n        expect(new_post_creator.errors).to be_blank\n      end\n    end\n\n  end\n\n  context \"host spam\" do\n\n    fab!(:topic) { Fabricate(:topic, user: user) }\n    let(:basic_topic_params) { { raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4 } }\n    let(:creator) { PostCreator.new(user, basic_topic_params) }\n\n    before do\n      Post.any_instance.expects(:has_host_spam?).returns(true)\n    end\n\n    it \"does not create the post\" do\n      GroupMessage.stubs(:create)\n      _post = creator.create\n\n      expect(creator.errors).to be_present\n      expect(creator.spam?).to eq(true)\n    end\n\n    it \"sends a message to moderators\" do\n      GroupMessage.expects(:create).with do |group_name, msg_type, params|\n        group_name == (Group[:moderators].name) && msg_type == (:spam_post_blocked) && params[:user].id == (user.id)\n      end\n      creator.create\n    end\n\n    it 'does not create a reviewable post if the review_every_post setting is enabled' do\n      SiteSetting.review_every_post = true\n      GroupMessage.stubs(:create)\n\n      expect { creator.create }.to change(ReviewablePost, :count).by(0)\n    end\n\n  end\n\n  # more integration testing ... maximise our testing\n  context 'existing topic' do\n    fab!(:topic) { Fabricate(:topic, user: user, title: 'topic title with 25 chars') }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'ensures the user can create the post' do\n      Guardian.any_instance.expects(:can_create?).with(Post, topic).returns(false)\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n\n    context 'success' do\n      it 'create correctly' do\n        post = creator.create\n        expect(Post.count).to eq(1)\n        expect(Topic.count).to eq(1)\n        expect(post.reply_to_post_number).to eq(4)\n      end\n    end\n\n    context \"when the user has bookmarks with auto_delete_preference on_owner_reply\" do\n      before do\n        Fabricate(:bookmark, topic: topic, user: user, auto_delete_preference: Bookmark.auto_delete_preferences[:on_owner_reply])\n        Fabricate(:bookmark, topic: topic, user: user, auto_delete_preference: Bookmark.auto_delete_preferences[:on_owner_reply])\n        TopicUser.create!(topic: topic, user: user, bookmarked: true)\n      end\n\n      it \"deletes the bookmarks, but not the ones without an auto_delete_preference\" do\n        Fabricate(:bookmark, topic: topic, user: user)\n        Fabricate(:bookmark, user: user)\n        creator.create\n        expect(Bookmark.where(user: user).count).to eq(2)\n        expect(TopicUser.find_by(topic: topic, user: user).bookmarked).to eq(true)\n      end\n\n      context \"when there are no bookmarks left in the topic\" do\n        it \"sets TopicUser.bookmarked to false\" do\n          creator.create\n          expect(TopicUser.find_by(topic: topic, user: user).bookmarked).to eq(false)\n        end\n      end\n    end\n\n    context \"topic stats\" do\n      before do\n        PostCreator.new(\n          Fabricate(:coding_horror),\n          raw: 'first post in topic',\n          topic_id: topic.id,\n          created_at: Time.zone.now - 24.hours\n        ).create\n      end\n\n      it \"updates topic stats\" do\n        post = creator.create\n        topic.reload\n\n        expect(topic.last_posted_at).to eq_time(post.created_at)\n        expect(topic.last_post_user_id).to eq(post.user_id)\n        expect(topic.word_count).to eq(6)\n      end\n\n      it \"updates topic stats even when topic fails validation\" do\n        topic.update_columns(title: 'below 15 chars')\n\n        post = creator.create\n        topic.reload\n\n        expect(topic.last_posted_at).to eq_time(post.created_at)\n        expect(topic.last_post_user_id).to eq(post.user_id)\n        expect(topic.word_count).to eq(6)\n      end\n    end\n\n    context 'when the topic is in slow mode' do\n      before do\n        one_day = 86400\n        topic.update!(slow_mode_seconds: one_day)\n      end\n\n      it 'fails if the user recently posted in this topic' do\n        TopicUser.create!(user: user, topic: topic, last_posted_at: 10.minutes.ago)\n\n        post = creator.create\n\n        expect(post).to be_blank\n        expect(creator.errors.count).to eq 1\n        expect(creator.errors.messages[:base][0]).to match I18n.t(:slow_mode_enabled)\n      end\n\n      it 'creates the topic if the user last post is older than the slow mode interval' do\n        TopicUser.create!(user: user, topic: topic, last_posted_at: 5.days.ago)\n\n        post = creator.create\n\n        expect(post).to be_present\n        expect(creator.errors.count).to be_zero\n      end\n\n      it 'creates the topic if the user is a staff member' do\n        admin = Fabricate(:admin)\n        post_creator = PostCreator.new(admin, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4)\n        TopicUser.create!(user: admin, topic: topic, last_posted_at: 10.minutes.ago)\n\n        post = post_creator.create\n\n        expect(post).to be_present\n        expect(post_creator.errors.count).to be_zero\n      end\n    end\n  end\n\n  context 'closed topic' do\n    fab!(:topic) { Fabricate(:topic, user: user, closed: true) }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'responds with an error message' do\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n  end\n\n  context 'missing topic' do\n    let(:topic) { Fabricate(:topic, user: user, deleted_at: 5.minutes.ago) }\n    let(:creator) { PostCreator.new(user, raw: 'test reply', topic_id: topic.id, reply_to_post_number: 4) }\n\n    it 'responds with an error message' do\n      post = creator.create\n      expect(post).to be_blank\n      expect(creator.errors.count).to eq 1\n      expect(creator.errors.messages[:base][0]).to match I18n.t(:topic_not_found)\n    end\n  end\n\n  context \"cooking options\" do\n    let(:raw) { \"this is my awesome message body hello world\" }\n\n    it \"passes the cooking options through correctly\" do\n      creator = PostCreator.new(user,\n                                title: 'hi there welcome to my topic',\n                                raw: raw,\n                                cooking_options: { traditional_markdown_linebreaks: true })\n\n      Post.any_instance.expects(:cook).with(raw, has_key(:traditional_markdown_linebreaks)).returns(raw)\n      creator.create\n    end\n  end\n\n  # integration test ... minimise db work\n  context 'private message' do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    fab!(:unrelated_user) { Fabricate(:user) }\n    let(:post) do\n      PostCreator.create!(user,\n        title: 'hi there welcome to my topic',\n        raw: \"this is my awesome message @#{unrelated_user.username_lower}\",\n        archetype: Archetype.private_message,\n        target_usernames: [target_user1.username, target_user2.username].join(','),\n        category: 1\n      )\n    end\n\n    it 'acts correctly' do\n      freeze_time\n\n      user.update_columns(last_posted_at: 1.year.ago)\n\n      # It's not a warning\n      expect(post.topic.user_warning).to be_blank\n\n      expect(post.topic.archetype).to eq(Archetype.private_message)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n      expect(post.topic.topic_allowed_users.count).to eq(3)\n\n      # PMs can't have a category\n      expect(post.topic.category).to eq(nil)\n\n      # does not notify an unrelated user\n      expect(unrelated_user.notifications.count).to eq(0)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n\n      # PMs do not increase post count or topic count\n      expect(post.user.user_stat.post_count).to eq(0)\n      expect(post.user.user_stat.topic_count).to eq(0)\n\n      user.reload\n      expect(user.last_posted_at).to eq_time(1.year.ago)\n\n      # archive this message and ensure archive is cleared for all users on reply\n      UserArchivedMessage.create(user_id: target_user2.id, topic_id: post.topic_id)\n\n      # if an admin replies they should be added to the allowed user list\n      admin = Fabricate(:admin)\n      PostCreator.create!(admin,\n        raw: 'hi there welcome topic, I am a mod',\n        topic_id: post.topic_id\n      )\n\n      post.topic.reload\n      expect(post.topic.topic_allowed_users.where(user_id: admin.id).count).to eq(1)\n\n      expect(UserArchivedMessage.where(user_id: target_user2.id, topic_id: post.topic_id).count).to eq(0)\n\n      # if another admin replies and is already member of the group, don't add them to topic_allowed_users\n      group = Fabricate(:group)\n      post.topic.topic_allowed_groups.create!(group: group)\n      admin2 = Fabricate(:admin)\n      group.add(admin2)\n\n      PostCreator.create!(admin2, raw: 'I am also an admin, and a mod', topic_id: post.topic_id)\n\n      expect(post.topic.topic_allowed_users.where(user_id: admin2.id).count).to eq(0)\n    end\n\n    it 'does not add whisperers to allowed users of the topic' do\n      SiteSetting.enable_whispers = true\n      unrelated_user.update!(admin: true)\n\n      PostCreator.create!(\n        unrelated_user,\n        raw: \"This is a whisper that I am testing\",\n        topic_id: post.topic_id,\n        post_type: Post.types[:whisper]\n      )\n\n      expect(post.topic.topic_allowed_users.map(&:user_id)).to contain_exactly(\n        target_user1.id, target_user2.id, user.id\n      )\n    end\n\n    it 'does not increase posts count for small actions' do\n      topic = Fabricate(:private_message_topic, user: Fabricate(:user))\n\n      Fabricate(:post, topic: topic)\n\n      1.upto(3) do |i|\n        user = Fabricate(:user)\n        topic.invite(topic.user, user.username)\n        topic.reload\n        expect(topic.posts_count).to eq(1)\n        expect(topic.posts.where(post_type: Post.types[:small_action]).count).to eq(i)\n      end\n\n      Fabricate(:post, topic: topic)\n      Topic.reset_highest(topic.id)\n      expect(topic.reload.posts_count).to eq(2)\n\n      Fabricate(:post, topic: topic)\n      Topic.reset_all_highest!\n      expect(topic.reload.posts_count).to eq(3)\n    end\n  end\n\n  context \"warnings\" do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    let(:base_args) do\n      { title: 'you need a warning buddy!',\n        raw: \"you did something bad and I'm telling you about it!\",\n        is_warning: true,\n        target_usernames: target_user1.username,\n        category: 1 }\n    end\n\n    it \"works as expected\" do\n      # Invalid archetype\n      creator = PostCreator.new(user, base_args)\n      creator.create\n      expect(creator.errors).to be_present\n\n      # Too many users\n      creator = PostCreator.new(user, base_args.merge(archetype: Archetype.private_message,\n                                                      target_usernames: [target_user1.username, target_user2.username].join(',')))\n      creator.create\n      expect(creator.errors).to be_present\n\n      # Success\n      creator = PostCreator.new(user, base_args.merge(archetype: Archetype.private_message))\n      post = creator.create\n      expect(creator.errors).to be_blank\n\n      topic = post.topic\n      expect(topic).to be_present\n      expect(topic.user_warning).to be_present\n      expect(topic.subtype).to eq(TopicSubtype.moderator_warning)\n      expect(topic.user_warning.user).to eq(target_user1)\n      expect(topic.user_warning.created_by).to eq(user)\n      expect(target_user1.user_warnings.count).to eq(1)\n    end\n  end\n\n  context 'auto closing' do\n    it 'closes private messages that have more than N posts' do\n      SiteSetting.auto_close_messages_post_count = 2\n\n      admin = Fabricate(:admin)\n\n      post1 = create_post(archetype: Archetype.private_message,\n                          target_usernames: [admin.username])\n\n      expect do\n        create_post(user: post1.user, topic_id: post1.topic_id)\n      end.to change { Post.count }.by(2)\n\n      post1.topic.reload\n\n      expect(post1.topic.posts.last.raw).to eq(I18n.t(\n        'topic_statuses.autoclosed_message_max_posts',\n        count: SiteSetting.auto_close_messages_post_count\n      ))\n\n      expect(post1.topic.closed).to eq(true)\n    end\n\n    it 'closes topics that have more than N posts' do\n      SiteSetting.auto_close_topics_post_count = 2\n\n      post1 = create_post\n\n      expect do\n        create_post(user: post1.user, topic_id: post1.topic_id)\n      end.to change { Post.count }.by(2)\n\n      post1.topic.reload\n\n      expect(post1.topic.posts.last.raw).to eq(I18n.t(\n        'topic_statuses.autoclosed_topic_max_posts',\n        count: SiteSetting.auto_close_topics_post_count\n      ))\n\n      expect(post1.topic.closed).to eq(true)\n    end\n  end\n\n  context 'private message to group' do\n    let(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:moderator) }\n    let(:group) do\n      g = Fabricate.build(:group, messageable_level: Group::ALIAS_LEVELS[:everyone])\n      g.add(target_user1)\n      g.add(target_user2)\n      g.save\n      g\n    end\n    fab!(:unrelated) { Fabricate(:user) }\n    let(:post) do\n      PostCreator.create!(user,\n        title: 'hi there welcome to my topic',\n        raw: \"this is my awesome message @#{unrelated.username_lower}\",\n        archetype: Archetype.private_message,\n        target_group_names: group.name\n      )\n    end\n\n    it 'can post to a group correctly' do\n      Jobs.run_immediately!\n\n      expect(post.topic.archetype).to eq(Archetype.private_message)\n      expect(post.topic.topic_allowed_users.count).to eq(1)\n      expect(post.topic.topic_allowed_groups.count).to eq(1)\n\n      # does not notify an unrelated user\n      expect(unrelated.notifications.count).to eq(0)\n      expect(post.topic.subtype).to eq(TopicSubtype.user_to_user)\n\n      expect(target_user1.notifications.count).to eq(1)\n      expect(target_user2.notifications.count).to eq(1)\n    end\n  end\n\n  context 'setting created_at' do\n    it 'supports Time instances' do\n      freeze_time\n\n      post1 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        title: 'This is a very interesting test post title',\n        created_at: 1.week.ago\n      )\n      topic = post1.topic\n\n      post2 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        topic_id: topic,\n        created_at: 1.week.ago\n      )\n\n      expect(post1.created_at).to eq_time(1.week.ago)\n      expect(post2.created_at).to eq_time(1.week.ago)\n      expect(topic.created_at).to eq_time(1.week.ago)\n    end\n\n    it 'supports strings' do\n      freeze_time\n\n      time = Time.zone.parse('2019-09-02')\n\n      post1 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        title: 'This is a very interesting test post title',\n        created_at: '2019-09-02'\n      )\n      topic = post1.topic\n\n      post2 = PostCreator.create(user,\n        raw: 'This is very interesting test post content',\n        topic_id: topic,\n        created_at: '2019-09-02 00:00:00 UTC'\n      )\n\n      expect(post1.created_at).to eq_time(time)\n      expect(post2.created_at).to eq_time(time)\n      expect(topic.created_at).to eq_time(time)\n    end\n  end\n\n  context 'disable validations' do\n    it 'can save a post' do\n      creator = PostCreator.new(user, raw: 'q', title: 'q', skip_validations: true)\n      creator.create\n      expect(creator.errors).to be_blank\n    end\n  end\n\n  describe \"word_count\" do\n    it \"has a word count\" do\n      creator = PostCreator.new(user, title: 'some inspired poetry for a rainy day', raw: 'mary had a little lamb, little lamb, little lamb. mary had a little lamb. \u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435')\n      post = creator.create\n      expect(post.word_count).to eq(15)\n\n      post.topic.reload\n      expect(post.topic.word_count).to eq(15)\n    end\n  end\n\n  describe \"embed_url\" do\n\n    let(:embed_url) { \"http://eviltrout.com/stupid-url\" }\n\n    it \"creates the topic_embed record\" do\n      creator = PostCreator.new(user,\n                                embed_url: embed_url,\n                                title: 'Reviews of Science Ovens',\n                                raw: 'Did you know that you can use microwaves to cook your dinner? Science!')\n      creator.create\n      expect(creator.errors).to be_blank\n      expect(TopicEmbed.where(embed_url: embed_url).exists?).to eq(true)\n\n      # If we try to create another topic with the embed url, should fail\n      creator = PostCreator.new(user,\n                                embed_url: embed_url,\n                                title: 'More Reviews of Science Ovens',\n                                raw: 'As if anyone ever wanted to learn more about them!')\n      result = creator.create\n      expect(result).to be_present\n      expect(creator.errors).to be_present\n    end\n  end\n\n  describe \"read credit for creator\" do\n    it \"should give credit to creator\" do\n      post = create_post\n      expect(PostTiming.find_by(topic_id: post.topic_id,\n                                post_number: post.post_number,\n                                user_id: post.user_id).msecs).to be > 0\n\n      expect(TopicUser.find_by(topic_id: post.topic_id,\n                               user_id: post.user_id).last_read_post_number).to eq(1)\n    end\n  end\n\n  describe \"suspended users\" do\n    it \"does not allow suspended users to create topics\" do\n      user = Fabricate(:user, suspended_at: 1.month.ago, suspended_till: 1.month.from_now)\n\n      creator = PostCreator.new(user, title: \"my test title 123\", raw: \"I should not be allowed to post\")\n      creator.create\n      expect(creator.errors.count).to be > 0\n    end\n  end\n\n  it \"doesn't strip starting whitespaces\" do\n    pc = PostCreator.new(user, title: \"testing whitespace stripping\", raw: \"    <-- whitespaces -->    \")\n    post = pc.create\n    expect(post.raw).to eq(\"    <-- whitespaces -->\")\n  end\n\n  context \"events\" do\n    before do\n      @posts_created = 0\n      @topics_created = 0\n\n      @increase_posts = -> (post, opts, user) { @posts_created += 1 }\n      @increase_topics = -> (topic, opts, user) { @topics_created += 1 }\n      DiscourseEvent.on(:post_created, &@increase_posts)\n      DiscourseEvent.on(:topic_created, &@increase_topics)\n    end\n\n    after do\n      DiscourseEvent.off(:post_created, &@increase_posts)\n      DiscourseEvent.off(:topic_created, &@increase_topics)\n    end\n\n    it \"fires both event when creating a topic\" do\n      pc = PostCreator.new(user, raw: 'this is the new content for my topic', title: 'this is my new topic title')\n      _post = pc.create\n      expect(@posts_created).to eq(1)\n      expect(@topics_created).to eq(1)\n    end\n\n    it \"fires only the post event when creating a post\" do\n      pc = PostCreator.new(user, topic_id: topic.id, raw: 'this is the new content for my post')\n      _post = pc.create\n      expect(@posts_created).to eq(1)\n      expect(@topics_created).to eq(0)\n    end\n  end\n\n  context \"staged users\" do\n    fab!(:staged) { Fabricate(:staged) }\n\n    it \"automatically watches all messages it participates in\" do\n      post = PostCreator.create(staged,\n        title: \"this is the title of a topic created by a staged user\",\n        raw: \"this is the content of a topic created by a staged user ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: staged.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:watching])\n      expect(topic_user.notifications_reason_id).to eq(TopicUser.notification_reasons[:auto_watch])\n    end\n  end\n\n  context \"topic tracking\" do\n    it \"automatically watches topic based on preference\" do\n      user.user_option.notification_level_when_replying = 3\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for watching notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a watching notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to watching ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:watching])\n    end\n\n    it \"topic notification level remains tracking based on preference\" do\n      user.user_option.notification_level_when_replying = 2\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for tracking notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a tracking notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to tracking ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:tracking])\n    end\n\n    it \"topic notification level is normal based on preference\" do\n      user.user_option.notification_level_when_replying = 1\n\n      admin = Fabricate(:admin)\n      topic = PostCreator.create(admin,\n                                 title: \"this is the title of a topic created by an admin for tracking notification\",\n                                 raw: \"this is the content of a topic created by an admin for keeping a tracking notification state on a topic ;)\"\n      )\n\n      post = PostCreator.create(user,\n                                topic_id: topic.topic_id,\n                                raw: \"this is a reply to set the tracking state to normal ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post.topic_id)\n      expect(topic_user.notification_level).to eq(TopicUser.notification_levels[:regular])\n    end\n\n    it \"user preferences for notification level when replying doesn't affect PMs\" do\n      user.user_option.update!(notification_level_when_replying: 1)\n\n      admin = Fabricate(:admin)\n      pm = Fabricate(:private_message_topic, user: admin)\n\n      pm.invite(admin, user.username)\n      PostCreator.create(\n        user,\n        topic_id: pm.id,\n        raw: \"this is a test reply 123 123 ;)\"\n      )\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: pm.id)\n      expect(topic_user.notification_level).to eq(3)\n    end\n\n    it 'sets the last_posted_at timestamp to track the last time the user posted' do\n      topic = Fabricate(:topic)\n\n      PostCreator.create(\n        user,\n        topic_id: topic.id,\n        raw: \"this is a test reply 123 123 ;)\"\n      )\n\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: topic.id)\n      expect(topic_user.last_posted_at).to be_present\n    end\n  end\n\n  describe '#create!' do\n    it \"should return the post if it was successfully created\" do\n      title = \"This is a valid title\"\n      raw = \"This is a really awesome post\"\n\n      post_creator = PostCreator.new(user, title: title, raw: raw)\n      post = post_creator.create\n\n      expect(post).to eq(Post.last)\n      expect(post.topic.title).to eq(title)\n      expect(post.raw).to eq(raw)\n    end\n\n    it \"should raise an error when post fails to be created\" do\n      post_creator = PostCreator.new(user, title: '', raw: '')\n      expect { post_creator.create! }.to raise_error(ActiveRecord::RecordNotSaved)\n    end\n\n    it \"does not generate an alert for empty posts\" do\n      Jobs.run_immediately!\n\n      user2 = Fabricate(:user)\n      topic = Fabricate(:private_message_topic,\n        topic_allowed_users: [\n          Fabricate.build(:topic_allowed_user, user: user),\n          Fabricate.build(:topic_allowed_user, user: user2)\n        ],\n      )\n      Fabricate(:topic_user,\n        topic: topic,\n        user: user2,\n        notification_level: TopicUser.notification_levels[:watching]\n      )\n\n      expect {\n        PostCreator.create!(user, raw: \"\", topic_id: topic.id, skip_validations: true)\n      }.to change { user2.notifications.count }.by(0)\n\n      expect {\n        PostCreator.create!(user, raw: \"hello world\", topic_id: topic.id, skip_validations: true)\n      }.to change { user2.notifications.count }.by(1)\n    end\n  end\n\n  context 'private message to a user that has disabled private messages' do\n    fab!(:another_user) { Fabricate(:user, username: 'HelloWorld') }\n\n    before do\n      another_user.user_option.update!(allow_private_messages: false)\n    end\n\n    it 'should not be valid' do\n      post_creator = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{another_user.username}\"\n      )\n\n      expect(post_creator).to_not be_valid\n\n      expect(post_creator.errors.full_messages).to include(I18n.t(\n        \"not_accepting_pms\", username: another_user.username\n      ))\n    end\n\n    it 'should not be valid if the name is downcased' do\n      post_creator = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{another_user.username.downcase}\"\n      )\n\n      expect(post_creator).to_not be_valid\n    end\n  end\n\n  context \"private message to a muted user\" do\n    fab!(:muted_me) { Fabricate(:evil_trout) }\n    fab!(:another_user) { Fabricate(:user) }\n\n    it 'should fail' do\n      updater = UserUpdater.new(muted_me, muted_me)\n      updater.update_muted_users(\"#{user.username}\")\n\n      pc = PostCreator.new(\n        user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{muted_me.username},#{another_user.username}\"\n      )\n\n      expect(pc).not_to be_valid\n\n      expect(pc.errors.full_messages).to contain_exactly(\n        I18n.t(:not_accepting_pms, username: muted_me.username)\n      )\n    end\n\n    fab!(:staff_user) { Fabricate(:admin) }\n\n    it 'succeeds if the user is staff' do\n      updater = UserUpdater.new(muted_me, muted_me)\n      updater.update_muted_users(\"#{staff_user.username}\")\n\n      pc = PostCreator.new(\n        staff_user,\n        title: 'this message is to someone who muted me!',\n        raw: \"you will have to see this even if you muted me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{muted_me.username}\"\n      )\n      expect(pc).to be_valid\n      expect(pc.errors).to be_blank\n    end\n  end\n\n  context \"private message to an ignored user\" do\n    fab!(:ignorer) { Fabricate(:evil_trout) }\n    fab!(:another_user) { Fabricate(:user) }\n\n    context \"when post author is ignored\" do\n      let!(:ignored_user) { Fabricate(:ignored_user, user: ignorer, ignored_user: user) }\n\n      it 'should fail' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is to someone who ignored me!',\n          raw: \"you will have to see this even if you ignored me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{ignorer.username},#{another_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: ignorer.username)\n                                           )\n      end\n    end\n\n    context \"when post author is admin who is ignored\" do\n      fab!(:staff_user) { Fabricate(:admin) }\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: ignorer, ignored_user: staff_user) }\n\n      it 'succeeds if the user is staff' do\n        pc = PostCreator.new(\n          staff_user,\n          title: 'this message is to someone who ignored me!',\n          raw: \"you will have to see this even if you ignored me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{ignorer.username}\"\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n  end\n\n  context \"private message to user in allow list\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n\n    context \"when post author is allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should succeed' do\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is in my allow list!',\n          raw: \"you will have to see this because I'm in your allow list!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username}\"\n        )\n\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n    context \"when personal messages are disabled\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should fail' do\n        allowed_user.user_option.update!(allow_private_messages: false)\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is in my allow list!',\n          raw: \"you will have to see this because I'm in your allow list!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: allowed_user.username)\n                                           )\n      end\n    end\n  end\n\n  context \"private message to user not in allow list\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n\n    context \"when post author is not allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: not_allowed_user, allowed_pm_user: allowed_user) }\n\n      it 'should fail' do\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{not_allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: not_allowed_user.username)\n                                           )\n      end\n\n      it 'should succeed when not enabled' do\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: false)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{not_allowed_user.username}\"\n        )\n\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n  end\n\n  context \"private message when post author is admin who is not in allow list\" do\n    fab!(:staff_user) { Fabricate(:admin) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n    fab!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: staff_user, allowed_pm_user: allowed_user) }\n\n    it 'succeeds if the user is staff' do\n      pc = PostCreator.new(\n        staff_user,\n        title: 'this message is to someone who did not allow me!',\n        raw: \"you will have to see this even if you did not allow me!\",\n        archetype: Archetype.private_message,\n        target_usernames: \"#{not_allowed_user.username}\"\n      )\n      expect(pc).to be_valid\n      expect(pc.errors).to be_blank\n    end\n  end\n\n  context \"private message to multiple users and one is not allowed\" do\n    fab!(:sender) { Fabricate(:evil_trout) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:not_allowed_user) { Fabricate(:user) }\n\n    context \"when post author is not allowed\" do\n      let!(:allowed_pm_user) { Fabricate(:allowed_pm_user, user: allowed_user, allowed_pm_user: sender) }\n\n      it 'should fail' do\n        allowed_user.user_option.update!(enable_allowed_pm_users: true)\n        not_allowed_user.user_option.update!(enable_allowed_pm_users: true)\n\n        pc = PostCreator.new(\n          sender,\n          title: 'this message is to someone who is not in my allowed list!',\n          raw: \"you will have to see this even if you don't want message from me!\",\n          archetype: Archetype.private_message,\n          target_usernames: \"#{allowed_user.username},#{not_allowed_user.username}\"\n        )\n\n        expect(pc).not_to be_valid\n        expect(pc.errors.full_messages).to contain_exactly(\n                                             I18n.t(:not_accepting_pms, username: not_allowed_user.username)\n                                           )\n      end\n    end\n  end\n\n  context \"private message recipients limit (max_allowed_message_recipients) reached\" do\n    fab!(:target_user1) { Fabricate(:coding_horror) }\n    fab!(:target_user2) { Fabricate(:evil_trout) }\n    fab!(:target_user3) { Fabricate(:walter_white) }\n\n    before do\n      SiteSetting.max_allowed_message_recipients = 2\n    end\n\n    context \"for normal user\" do\n      it 'fails when sending message to multiple recipients' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(',')\n        )\n        expect(pc).not_to be_valid\n        expect(pc.errors).to be_present\n      end\n\n      it 'succeeds when sending message to multiple recipients if skip_validations is true' do\n        pc = PostCreator.new(\n          user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(','),\n          skip_validations: true\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n\n    context \"always succeeds if the user is staff\" do\n      fab!(:staff_user) { Fabricate(:admin) }\n\n      it 'when sending message to multiple recipients' do\n        pc = PostCreator.new(\n          staff_user,\n          title: 'this message is for multiple recipients!',\n          raw: \"Lorem ipsum dolor sit amet, id elitr praesent mea, ut ius facilis fierent.\",\n          archetype: Archetype.private_message,\n          target_usernames: [target_user1.username, target_user2.username, target_user3.username].join(',')\n        )\n        expect(pc).to be_valid\n        expect(pc.errors).to be_blank\n      end\n    end\n  end\n\n  context \"#create_post_notice\" do\n    fab!(:user) { Fabricate(:user) }\n    fab!(:staged) { Fabricate(:staged) }\n    fab!(:anonymous) { Fabricate(:anonymous) }\n\n    it \"generates post notices for new users\" do\n      post = PostCreator.create!(user, title: \"one of my first topics\", raw: \"one of my first posts\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:new_user])\n\n      post = PostCreator.create!(user, title: \"another one of my first topics\", raw: \"another one of my first posts\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n    end\n\n    it \"generates post notices for returning users\" do\n      SiteSetting.returning_users_days = 30\n      old_post = Fabricate(:post, user: user, created_at: 31.days.ago)\n\n      post = PostCreator.create!(user, title: \"this is a returning topic\", raw: \"this is a post\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:returning_user], \"last_posted_at\" => old_post.created_at.iso8601)\n\n      post = PostCreator.create!(user, title: \"this is another topic\", raw: \"this is my another post\")\n      expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n    end\n\n    it \"does not generate for non-human, staged or anonymous users\" do\n      SiteSetting.allow_anonymous_posting = true\n\n      [anonymous, Discourse.system_user, staged].each do |user|\n        expect(user.posts.size).to eq(0)\n        post = PostCreator.create!(user, title: \"#{user.username}'s first topic\", raw: \"#{user.name}'s first post\")\n        expect(post.custom_fields[Post::NOTICE]).to eq(nil)\n      end\n    end\n  end\n\n  context \"secure media uploads\" do\n    fab!(:image_upload) { Fabricate(:upload, secure: true) }\n    fab!(:user2) { Fabricate(:user) }\n    fab!(:public_topic) { Fabricate(:topic) }\n\n    before do\n      setup_s3\n      SiteSetting.authorized_extensions = \"png|jpg|gif|mp4\"\n      SiteSetting.secure_media = true\n      stub_upload(image_upload)\n    end\n\n    it \"links post uploads\" do\n      _public_post = PostCreator.create(\n        user,\n        topic_id: public_topic.id,\n        raw: \"A public post with an image.\\n![](#{image_upload.short_path})\"\n      )\n    end\n  end\n\n  context 'queue for review' do\n    before { SiteSetting.review_every_post = true }\n\n    it 'created a reviewable post after creating the post' do\n      title = \"This is a valid title\"\n      raw = \"This is a really awesome post\"\n\n      post_creator = PostCreator.new(user, title: title, raw: raw)\n\n      expect { post_creator.create }.to change(ReviewablePost, :count).by(1)\n    end\n\n    it 'does not create a reviewable post if the post is not valid' do\n      post_creator = PostCreator.new(user, title: '', raw: '')\n\n      expect { post_creator.create }.to change(ReviewablePost, :count).by(0)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe TopicTrackingState do\n\n  fab!(:user) do\n    Fabricate(:user)\n  end\n\n  let(:post) do\n    create_post\n  end\n\n  let(:topic) { post.topic }\n  fab!(:private_message_post) { Fabricate(:private_message_post) }\n  let(:private_message_topic) { private_message_post.topic }\n\n  describe '#publish_latest' do\n    it 'can correctly publish latest' do\n      message = MessageBus.track_publish(\"/latest\") do\n        described_class.publish_latest(topic)\n      end.first\n\n      data = message.data\n\n      expect(data[\"topic_id\"]).to eq(topic.id)\n      expect(data[\"message_type\"]).to eq(described_class::LATEST_MESSAGE_TYPE)\n      expect(data[\"payload\"][\"archetype\"]).to eq(Archetype.default)\n    end\n\n    describe 'private message' do\n      it 'should not publish any message' do\n        messages = MessageBus.track_publish do\n          described_class.publish_latest(private_message_topic)\n        end\n\n        expect(messages).to eq([])\n      end\n    end\n  end\n\n  describe '#publish_unread' do\n    it \"can correctly publish unread\" do\n      message = MessageBus.track_publish(described_class.unread_channel_key(post.user.id)) do\n        TopicTrackingState.publish_unread(post)\n      end.first\n\n      data = message.data\n\n      expect(message.user_ids).to contain_exactly(post.user.id)\n      expect(message.group_ids).to eq(nil)\n      expect(data[\"topic_id\"]).to eq(topic.id)\n      expect(data[\"message_type\"]).to eq(described_class::UNREAD_MESSAGE_TYPE)\n      expect(data[\"payload\"][\"archetype\"]).to eq(Archetype.default)\n    end\n\n    it \"does not publish whisper post to non-staff users\" do\n      post.update!(post_type: Post.types[:whisper])\n\n      messages = MessageBus.track_publish(described_class.unread_channel_key(post.user_id)) do\n        TopicTrackingState.publish_unread(post)\n      end\n\n      expect(messages).to eq([])\n\n      post.user.grant_admin!\n\n      message = MessageBus.track_publish(described_class.unread_channel_key(post.user_id)) do\n        TopicTrackingState.publish_unread(post)\n      end.first\n\n      expect(message.user_ids).to contain_exactly(post.user_id)\n      expect(message.group_ids).to eq(nil)\n    end\n\n    it \"correctly publishes unread for a post in a restricted category\" do\n      group = Fabricate(:group)\n      category = Fabricate(:private_category, group: group)\n\n      post.topic.update!(category: category)\n\n      messages = MessageBus.track_publish(described_class.unread_channel_key(post.user_id)) do\n        TopicTrackingState.publish_unread(post)\n      end\n\n      expect(messages).to eq([])\n\n      group.add(post.user)\n\n      message = MessageBus.track_publish(described_class.unread_channel_key(post.user_id)) do\n        TopicTrackingState.publish_unread(post)\n      end.first\n\n      expect(message.user_ids).to contain_exactly(post.user_id)\n      expect(message.group_ids).to eq(nil)\n    end\n\n    describe 'for a private message' do\n      before do\n        TopicUser.change(\n          private_message_topic.allowed_users.first.id,\n          private_message_topic.id,\n          notification_level: TopicUser.notification_levels[:tracking]\n        )\n      end\n\n      it 'should not publish any message' do\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_unread(private_message_post)\n        end\n\n        expect(messages).to eq([])\n      end\n    end\n  end\n\n  describe '#publish_muted' do\n    let(:user) do\n      Fabricate(:user, last_seen_at: Date.today)\n    end\n    let(:post) do\n      create_post(user: user)\n    end\n\n    it 'can correctly publish muted' do\n      TopicUser.find_by(topic: topic, user: post.user).update(notification_level: 0)\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_muted(topic)\n      end\n\n      muted_message = messages.find { |message| message.data[\"message_type\"] == \"muted\" }\n\n      expect(muted_message.data[\"topic_id\"]).to eq(topic.id)\n      expect(muted_message.data[\"message_type\"]).to eq(described_class::MUTED_MESSAGE_TYPE)\n    end\n\n    it 'should not publish any message when notification level is not muted' do\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_muted(topic)\n      end\n      muted_messages = messages.select { |message| message.data[\"message_type\"] == \"muted\" }\n\n      expect(muted_messages).to eq([])\n    end\n\n    it 'should not publish any message when the user was not seen in the last 7 days' do\n      TopicUser.find_by(topic: topic, user: post.user).update(notification_level: 0)\n      post.user.update(last_seen_at: 8.days.ago)\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_muted(topic)\n      end\n      muted_messages = messages.select { |message| message.data[\"message_type\"] == \"muted\" }\n      expect(muted_messages).to eq([])\n    end\n  end\n\n  describe '#publish_unmuted' do\n    let(:user) do\n      Fabricate(:user, last_seen_at: Date.today)\n    end\n    let(:second_user) do\n      Fabricate(:user, last_seen_at: Date.today)\n    end\n    let(:third_user) do\n      Fabricate(:user, last_seen_at: Date.today)\n    end\n    let(:post) do\n      create_post(user: user)\n    end\n\n    it 'can correctly publish unmuted' do\n      Fabricate(:topic_tag, topic: topic)\n      SiteSetting.mute_all_categories_by_default = true\n      TopicUser.find_by(topic: topic, user: post.user).update(notification_level: 1)\n      CategoryUser.create!(category: topic.category, user: second_user, notification_level: 1)\n      TagUser.create!(tag: topic.tags.first, user: third_user, notification_level: 1)\n      TagUser.create!(tag: topic.tags.first, user: Fabricate(:user), notification_level: 0)\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_unmuted(topic)\n      end\n\n      unmuted_message = messages.find { |message| message.data[\"message_type\"] == \"unmuted\" }\n      expect(unmuted_message.user_ids.sort).to eq([user.id, second_user.id, third_user.id].sort)\n      expect(unmuted_message.data[\"topic_id\"]).to eq(topic.id)\n      expect(unmuted_message.data[\"message_type\"]).to eq(described_class::UNMUTED_MESSAGE_TYPE)\n    end\n\n    it 'should not publish any message when notification level is not muted' do\n      SiteSetting.mute_all_categories_by_default = true\n      TopicUser.find_by(topic: topic, user: post.user).update(notification_level: 0)\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_unmuted(topic)\n      end\n      unmuted_messages = messages.select { |message| message.data[\"message_type\"] == \"unmuted\" }\n\n      expect(unmuted_messages).to eq([])\n    end\n\n    it 'should not publish any message when the user was not seen in the last 7 days' do\n      TopicUser.find_by(topic: topic, user: post.user).update(notification_level: 1)\n      post.user.update(last_seen_at: 8.days.ago)\n      messages = MessageBus.track_publish(\"/latest\") do\n        TopicTrackingState.publish_unmuted(topic)\n      end\n      unmuted_messages = messages.select { |message| message.data[\"message_type\"] == \"unmuted\" }\n      expect(unmuted_messages).to eq([])\n    end\n  end\n\n  describe '#publish_private_message' do\n    fab!(:admin) { Fabricate(:admin) }\n\n    describe 'normal topic' do\n      it 'should publish the right message' do\n        allowed_users = private_message_topic.allowed_users\n\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_private_message(private_message_topic)\n        end\n\n        expect(messages.count).to eq(1)\n\n        message = messages.first\n\n        expect(message.channel).to eq('/private-messages/inbox')\n        expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n        expect(message.user_ids).to contain_exactly(*allowed_users.map(&:id))\n      end\n    end\n\n    describe 'topic with groups' do\n      fab!(:group1) { Fabricate(:group, users: [Fabricate(:user)]) }\n      fab!(:group2) { Fabricate(:group, users: [Fabricate(:user), Fabricate(:user)]) }\n\n      before do\n        [group1, group2].each do |group|\n          private_message_topic.allowed_groups << group\n        end\n      end\n\n      it \"should publish the right message\" do\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_private_message(\n            private_message_topic\n          )\n        end\n\n        expect(messages.map(&:channel)).to contain_exactly(\n          '/private-messages/inbox',\n          \"/private-messages/group/#{group1.name}/inbox\",\n          \"/private-messages/group/#{group2.name}/inbox\"\n        )\n\n        message = messages.find do |m|\n          m.channel == '/private-messages/inbox'\n        end\n\n        expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n        expect(message.user_ids).to eq(private_message_topic.allowed_users.map(&:id))\n\n        [group1, group2].each do |group|\n          message = messages.find do |m|\n            m.channel == \"/private-messages/group/#{group.name}/inbox\"\n          end\n\n          expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n          expect(message.user_ids).to eq(group.users.map(&:id))\n        end\n      end\n\n      describe \"archiving topic\" do\n        it \"should publish the right message\" do\n          messages = MessageBus.track_publish do\n            TopicTrackingState.publish_private_message(\n              private_message_topic,\n              group_archive: true\n            )\n          end\n\n          expect(messages.map(&:channel)).to contain_exactly(\n            '/private-messages/inbox',\n            \"/private-messages/group/#{group1.name}/inbox\",\n            \"/private-messages/group/#{group1.name}/archive\",\n            \"/private-messages/group/#{group2.name}/inbox\",\n            \"/private-messages/group/#{group2.name}/archive\",\n          )\n\n          message = messages.find { |m| m.channel == '/private-messages/inbox' }\n\n          expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n          expect(message.user_ids).to eq(private_message_topic.allowed_users.map(&:id))\n\n          [group1, group2].each do |group|\n            [\n              \"/private-messages/group/#{group.name}/inbox\",\n              \"/private-messages/group/#{group.name}/archive\"\n            ].each do |channel|\n              message = messages.find { |m| m.channel == channel }\n              expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n              expect(message.user_ids).to eq(group.users.map(&:id))\n            end\n          end\n        end\n      end\n    end\n\n    describe 'topic with new post' do\n      let(:user) { private_message_topic.allowed_users.last }\n\n      let!(:post) do\n        Fabricate(:post,\n          topic: private_message_topic,\n          user: user\n        )\n      end\n\n      let!(:group) do\n        group = Fabricate(:group, users: [Fabricate(:user)])\n        private_message_topic.allowed_groups << group\n        group\n      end\n\n      it 'should publish the right message' do\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_private_message(\n            private_message_topic,\n            post: post\n          )\n        end\n\n        expected_channels = [\n          '/private-messages/inbox',\n          '/private-messages/sent',\n          \"/private-messages/group/#{group.name}/inbox\"\n        ]\n\n        expect(messages.map(&:channel)).to contain_exactly(*expected_channels)\n\n        expected_channels.zip([\n          private_message_topic.allowed_users.map(&:id),\n          [user.id],\n          [group.users.first.id]\n        ]).each do |channel, user_ids|\n          message = messages.find { |m| m.channel == channel }\n\n          expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n          expect(message.user_ids).to eq(user_ids)\n        end\n      end\n    end\n\n    describe 'archived topic' do\n      it 'should publish the right message' do\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_private_message(\n            private_message_topic,\n            archive_user_id: private_message_post.user_id,\n          )\n        end\n\n        expected_channels = [\n          \"/private-messages/archive\",\n          \"/private-messages/inbox\",\n          \"/private-messages/sent\",\n        ]\n\n        expect(messages.map(&:channel)).to eq(expected_channels)\n\n        expected_channels.each do |channel|\n          message = messages.find { |m| m.channel = channel }\n          expect(message.data[\"topic_id\"]).to eq(private_message_topic.id)\n          expect(message.user_ids).to eq([private_message_post.user_id])\n        end\n      end\n    end\n\n    describe 'for a regular topic' do\n      it 'should not publish any message' do\n        topic.allowed_users << Fabricate(:user)\n\n        messages = MessageBus.track_publish do\n          TopicTrackingState.publish_private_message(topic)\n        end\n\n        expect(messages).to eq([])\n      end\n    end\n  end\n\n  describe '#publish_read_private_message' do\n    fab!(:group) { Fabricate(:group) }\n    let(:read_topic_key) { \"/private-messages/unread-indicator/#{group_message.id}\" }\n    let(:read_post_key) { \"/topic/#{group_message.id}\" }\n    let(:latest_post_number) { 3 }\n    let(:group_message) { Fabricate(:private_message_topic,\n        allowed_groups: [group],\n        topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: user)],\n        highest_post_number: latest_post_number\n      )\n    }\n    let!(:post) {\n      Fabricate(:post, topic: group_message, post_number: latest_post_number)\n    }\n\n    before do\n      group.add(user)\n    end\n\n    it 'does not trigger a read count update if no allowed groups have the option enabled' do\n      messages = MessageBus.track_publish(read_post_key) do\n        TopicTrackingState.publish_read_indicator_on_read(group_message.id, latest_post_number, user.id)\n      end\n\n      expect(messages).to be_empty\n    end\n\n    context 'when the read indicator is enabled' do\n      before { group.update!(publish_read_state: true) }\n\n      it 'publishes a message to hide the unread indicator' do\n        message = MessageBus.track_publish(read_topic_key) do\n          TopicTrackingState.publish_read_indicator_on_read(group_message.id, latest_post_number, user.id)\n        end.first\n\n        expect(message.data['topic_id']).to eq group_message.id\n        expect(message.data['show_indicator']).to eq false\n      end\n\n      it 'publishes a message to show the unread indicator when a non-member creates a new post' do\n        allowed_user = Fabricate(:topic_allowed_user, topic: group_message)\n        message = MessageBus.track_publish(read_topic_key) do\n          TopicTrackingState.publish_read_indicator_on_write(group_message.id, latest_post_number, allowed_user.id)\n        end.first\n\n        expect(message.data['topic_id']).to eq group_message.id\n        expect(message.data['show_indicator']).to eq true\n      end\n\n      it 'does not publish the unread indicator if the message is not the last one' do\n        not_last_post_number = latest_post_number - 1\n        Fabricate(:post, topic: group_message, post_number: not_last_post_number)\n        messages = MessageBus.track_publish(read_topic_key) do\n          TopicTrackingState.publish_read_indicator_on_read(group_message.id, not_last_post_number, user.id)\n        end\n\n        expect(messages).to be_empty\n      end\n\n      it 'does not publish the read indicator if the user is not a group member' do\n        allowed_user = Fabricate(:topic_allowed_user, topic: group_message)\n        messages = MessageBus.track_publish(read_topic_key) do\n          TopicTrackingState.publish_read_indicator_on_read(group_message.id, latest_post_number, allowed_user.user_id)\n        end\n\n        expect(messages).to be_empty\n      end\n\n      it 'publish a read count update to every client' do\n        message = MessageBus.track_publish(read_post_key) do\n          TopicTrackingState.publish_read_indicator_on_read(group_message.id, latest_post_number, user.id)\n        end.first\n\n        expect(message.data[:type]).to eq :read\n      end\n    end\n  end\n\n  it \"correctly handles muted categories\" do\n\n    user = Fabricate(:user)\n    post\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n\n    CategoryUser.create!(user_id: user.id,\n                         notification_level: CategoryUser.notification_levels[:muted],\n                         category_id: post.topic.category_id\n                         )\n\n    create_post(topic_id: post.topic_id)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(0)\n\n    TopicUser.create!(user_id: user.id, topic_id: post.topic_id, last_read_post_number: 1, notification_level: 3)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n  end\n\n  it \"correctly handles category_users with null notification level\" do\n    user = Fabricate(:user)\n    post\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n\n    CategoryUser.create!(user_id: user.id, category_id: post.topic.category_id)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n  end\n\n  it \"works when categories are default muted\" do\n    SiteSetting.mute_all_categories_by_default = true\n\n    user = Fabricate(:user)\n    post\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(0)\n\n    CategoryUser.create!(user_id: user.id,\n                         notification_level: CategoryUser.notification_levels[:regular],\n                         category_id: post.topic.category_id\n                         )\n\n    create_post(topic_id: post.topic_id)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n  end\n\n  context 'muted tags' do\n    it \"remove_muted_tags_from_latest is set to always\" do\n      SiteSetting.remove_muted_tags_from_latest = 'always'\n      user = Fabricate(:user)\n      tag1 = Fabricate(:tag)\n      tag2 = Fabricate(:tag)\n      Fabricate(:topic_tag, tag: tag1, topic: topic)\n      Fabricate(:topic_tag, tag: tag2, topic: topic)\n      post\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n\n      TagUser.create!(user_id: user.id,\n                      notification_level: TagUser.notification_levels[:muted],\n                      tag_id: tag1.id\n                     )\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(0)\n\n      TopicTag.where(topic_id: topic.id).delete_all\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n    end\n\n    it \"remove_muted_tags_from_latest is set to only_muted\" do\n      SiteSetting.remove_muted_tags_from_latest = 'only_muted'\n      user = Fabricate(:user)\n      tag1 = Fabricate(:tag)\n      tag2 = Fabricate(:tag)\n      Fabricate(:topic_tag, tag: tag1, topic: topic)\n      Fabricate(:topic_tag, tag: tag2, topic: topic)\n      post\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n\n      TagUser.create!(user_id: user.id,\n                      notification_level: TagUser.notification_levels[:muted],\n                      tag_id: tag1.id\n                     )\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n\n      TagUser.create!(user_id: user.id,\n                      notification_level: TagUser.notification_levels[:muted],\n                      tag_id: tag2.id\n                     )\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(0)\n\n      TopicTag.where(topic_id: topic.id).delete_all\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n    end\n\n    it \"remove_muted_tags_from_latest is set to never\" do\n      SiteSetting.remove_muted_tags_from_latest = 'never'\n      user = Fabricate(:user)\n      tag1 = Fabricate(:tag)\n      Fabricate(:topic_tag, tag: tag1, topic: topic)\n      post\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n\n      TagUser.create!(user_id: user.id,\n                      notification_level: TagUser.notification_levels[:muted],\n                      tag_id: tag1.id\n                     )\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n    end\n  end\n\n  it \"correctly handles dismissed topics\" do\n    freeze_time 1.minute.ago\n    user = Fabricate(:user)\n    post\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(1)\n\n    DismissedTopicUser.create!(user_id: user.id, topic_id: post.topic_id, created_at: Time.zone.now)\n    CategoryUser.create!(user_id: user.id,\n                         notification_level: CategoryUser.notification_levels[:regular],\n                         category_id: post.topic.category_id,\n                         last_seen_at: post.topic.created_at\n                         )\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(0)\n  end\n\n  it \"correctly handles capping\" do\n    user = Fabricate(:user)\n\n    post1 = create_post\n    Fabricate(:post, topic: post1.topic)\n\n    post2 = create_post\n    Fabricate(:post, topic: post2.topic)\n\n    post3 = create_post\n    Fabricate(:post, topic: post3.topic)\n\n    tracking = {\n      notification_level: TopicUser.notification_levels[:tracking],\n      last_read_post_number: 1,\n    }\n\n    TopicUser.change(user.id, post1.topic_id, tracking)\n    TopicUser.change(user.id, post2.topic_id, tracking)\n    TopicUser.change(user.id, post3.topic_id, tracking)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(3)\n\n  end\n\n  context \"tag support\" do\n    after do\n      # this is a bit of an odd hook, but this is a global change\n      # used by plugins that leverage tagging heavily and need\n      # tag information in topic tracking state\n      TopicTrackingState.include_tags_in_report = false\n    end\n\n    it \"correctly handles tags\" do\n      SiteSetting.tagging_enabled = true\n\n      post.topic.notifier.watch_topic!(post.topic.user_id)\n\n      DiscourseTagging.tag_topic_by_names(\n        post.topic,\n        Guardian.new(Discourse.system_user),\n        ['bananas', 'apples']\n      )\n\n      TopicTrackingState.include_tags_in_report = true\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n      row = report[0]\n      expect(row.tags).to contain_exactly(\"apples\", \"bananas\")\n\n      TopicTrackingState.include_tags_in_report = false\n\n      report = TopicTrackingState.report(user)\n      expect(report.length).to eq(1)\n      row = report[0]\n      expect(row.respond_to? :tags).to eq(false)\n    end\n  end\n\n  it \"correctly gets the tracking state\" do\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(0)\n\n    post.topic.notifier.watch_topic!(post.topic.user_id)\n\n    report = TopicTrackingState.report(user)\n\n    expect(report.length).to eq(1)\n    row = report[0]\n\n    expect(row.topic_id).to eq(post.topic_id)\n    expect(row.highest_post_number).to eq(1)\n    expect(row.last_read_post_number).to eq(nil)\n    expect(row.user_id).to eq(user.id)\n\n    # lets not leak out random users\n    expect(TopicTrackingState.report(post.user)).to be_empty\n\n    # lets not return anything if we scope on non-existing topic\n    expect(TopicTrackingState.report(user, post.topic_id + 1)).to be_empty\n\n    # when we reply the poster should have an unread row\n    create_post(user: user, topic: post.topic)\n\n    report = TopicTrackingState.report(user)\n    expect(report.length).to eq(0)\n\n    report = TopicTrackingState.report(post.user)\n    expect(report.length).to eq(1)\n\n    row = report[0]\n\n    expect(row.topic_id).to eq(post.topic_id)\n    expect(row.highest_post_number).to eq(2)\n    expect(row.last_read_post_number).to eq(1)\n    expect(row.user_id).to eq(post.user_id)\n\n    # when we have no permission to see a category, don't show its stats\n    category = Fabricate(:category, read_restricted: true)\n\n    post.topic.category_id = category.id\n    post.topic.save\n\n    expect(TopicTrackingState.report(post.user)).to be_empty\n    expect(TopicTrackingState.report(user)).to be_empty\n  end\n\n  describe \".report\" do\n    it \"correctly reports topics with staff posts\" do\n      create_post(\n        raw: \"this is a test post\",\n        topic: topic,\n        user: post.user\n      )\n\n      create_post(\n        raw: \"this is a test post\",\n        topic: topic,\n        post_type: Post.types[:whisper],\n        user: user\n      )\n\n      post.user.grant_admin!\n\n      state = TopicTrackingState.report(post.user)\n\n      expect(state.map(&:topic_id)).to contain_exactly(topic.id)\n    end\n  end\nend\n"], "filenames": ["app/models/topic_tracking_state.rb", "spec/components/post_creator_spec.rb", "spec/models/topic_tracking_state_spec.rb"], "buggy_code_start_loc": [147, 140, 50], "buggy_code_end_loc": [192, 141, 53], "fixing_code_start_loc": [148, 140, 51], "fixing_code_end_loc": [201, 142, 97], "type": "CWE-200", "message": "Discourse is an open-source platform for community discussion. In Discourse before versions 2.7.8 and 2.8.0.beta5, a user's read state for a topic such as the last read post number and the notification level is exposed.", "other": {"cve": {"id": "CVE-2021-37703", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-13T16:15:07.827", "lastModified": "2021-08-30T11:08:05.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open-source platform for community discussion. In Discourse before versions 2.7.8 and 2.8.0.beta5, a user's read state for a topic such as the last read post number and the notification level is exposed."}, {"lang": "es", "value": "Discourse es una plataforma de c\u00f3digo abierto para el debate comunitario. En Discourse versiones anteriores a 2.7.8 y 2.8.0.beta5, el estado de lectura de un usuario para un tema, como el n\u00famero de la \u00faltima publicaci\u00f3n le\u00edda y el nivel de notificaci\u00f3n, est\u00e1 expuesto."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.8", "matchCriteriaId": "2A85C6E2-A78D-47B2-AE03-A12AE6A2E8BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "9E7F8AC4-35D1-45E5-8A3A-B0205000A5D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "B9AE12FE-0396-4843-8D30-D8C44FAE01DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "F101AEAB-4FB7-4BE3-931B-595702D616C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "F6878B7F-2691-4D3F-8116-CB282FDAAAC7"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/aed65ec16d38886d7be7209d8c02df4ffd4937a4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-gq2h-qhg2-phf9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/aed65ec16d38886d7be7209d8c02df4ffd4937a4"}}