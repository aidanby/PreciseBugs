{"buggy_code": ["/*\n *\tipddp.c: IP to Appletalk-IP Encapsulation driver for Linux\n *\t\t Appletalk-IP to IP Decapsulation driver for Linux\n *\n *\tAuthors:\n *      - DDP-IP Encap by: Bradford W. Johnson <johns393@maroon.tc.umn.edu>\n *\t- DDP-IP Decap by: Jay Schulist <jschlst@samba.org>\n *\n *\tDerived from:\n *\t- Almost all code already existed in net/appletalk/ddp.c I just\n *\t  moved/reorginized it into a driver file. Original IP-over-DDP code\n *\t  was done by Bradford W. Johnson <johns393@maroon.tc.umn.edu>\n *      - skeleton.c: A network driver outline for linux.\n *        Written 1993-94 by Donald Becker.\n *\t- dummy.c: A dummy net driver. By Nick Holloway.\n *\t- MacGate: A user space Daemon for Appletalk-IP Decap for\n *\t  Linux by Jay Schulist <jschlst@samba.org>\n *\n *      Copyright 1993 United States Government as represented by the\n *      Director, National Security Agency.\n *\n *      This software may be used and distributed according to the terms\n *      of the GNU General Public License, incorporated herein by reference.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ip.h>\n#include <linux/atalk.h>\n#include <linux/if_arp.h>\n#include <linux/slab.h>\n#include <net/route.h>\n#include <linux/uaccess.h>\n\n#include \"ipddp.h\"\t\t/* Our stuff */\n\nstatic const char version[] = KERN_INFO \"ipddp.c:v0.01 8/28/97 Bradford W. Johnson <johns393@maroon.tc.umn.edu>\\n\";\n\nstatic struct ipddp_route *ipddp_route_list;\nstatic DEFINE_SPINLOCK(ipddp_route_lock);\n\n#ifdef CONFIG_IPDDP_ENCAP\nstatic int ipddp_mode = IPDDP_ENCAP;\n#else\nstatic int ipddp_mode = IPDDP_DECAP;\n#endif\n\n/* Index to functions, as function prototypes. */\nstatic netdev_tx_t ipddp_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev);\nstatic int ipddp_create(struct ipddp_route *new_rt);\nstatic int ipddp_delete(struct ipddp_route *rt);\nstatic struct ipddp_route* __ipddp_find_route(struct ipddp_route *rt);\nstatic int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);\n\nstatic const struct net_device_ops ipddp_netdev_ops = {\n\t.ndo_start_xmit\t\t= ipddp_xmit,\n\t.ndo_do_ioctl   \t= ipddp_ioctl,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic struct net_device * __init ipddp_init(void)\n{\n\tstatic unsigned version_printed;\n\tstruct net_device *dev;\n\tint err;\n\n\tdev = alloc_etherdev(0);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnetif_keep_dst(dev);\n\tstrcpy(dev->name, \"ipddp%d\");\n\n\tif (version_printed++ == 0)\n                printk(version);\n\n\t/* Initialize the device structure. */\n\tdev->netdev_ops = &ipddp_netdev_ops;\n\n        dev->type = ARPHRD_IPDDP;       \t/* IP over DDP tunnel */\n        dev->mtu = 585;\n        dev->flags |= IFF_NOARP;\n\n        /*\n         *      The worst case header we will need is currently a\n         *      ethernet header (14 bytes) and a ddp header (sizeof ddpehdr+1)\n         *      We send over SNAP so that takes another 8 bytes.\n         */\n        dev->hard_header_len = 14+8+sizeof(struct ddpehdr)+1;\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* Let the user now what mode we are in */\n\tif(ipddp_mode == IPDDP_ENCAP)\n\t\tprintk(\"%s: Appletalk-IP Encap. mode by Bradford W. Johnson <johns393@maroon.tc.umn.edu>\\n\", \n\t\t\tdev->name);\n\tif(ipddp_mode == IPDDP_DECAP)\n\t\tprintk(\"%s: Appletalk-IP Decap. mode by Jay Schulist <jschlst@samba.org>\\n\", \n\t\t\tdev->name);\n\n        return dev;\n}\n\n\n/*\n * Transmit LLAP/ELAP frame using aarp_send_ddp.\n */\nstatic netdev_tx_t ipddp_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\t__be32 paddr = skb_rtable(skb)->rt_gateway;\n        struct ddpehdr *ddp;\n        struct ipddp_route *rt;\n        struct atalk_addr *our_addr;\n\n\tspin_lock(&ipddp_route_lock);\n\n\t/*\n         * Find appropriate route to use, based only on IP number.\n         */\n        for(rt = ipddp_route_list; rt != NULL; rt = rt->next)\n        {\n                if(rt->ip == paddr)\n                        break;\n        }\n        if(rt == NULL) {\n\t\tspin_unlock(&ipddp_route_lock);\n                return NETDEV_TX_OK;\n\t}\n\n        our_addr = atalk_find_dev_addr(rt->dev);\n\n\tif(ipddp_mode == IPDDP_DECAP)\n\t\t/* \n\t\t * Pull off the excess room that should not be there.\n\t\t * This is due to a hard-header problem. This is the\n\t\t * quick fix for now though, till it breaks.\n\t\t */\n\t\tskb_pull(skb, 35-(sizeof(struct ddpehdr)+1));\n\n\t/* Create the Extended DDP header */\n\tddp = (struct ddpehdr *)skb->data;\n        ddp->deh_len_hops = htons(skb->len + (1<<10));\n        ddp->deh_sum = 0;\n\n\t/*\n         * For Localtalk we need aarp_send_ddp to strip the\n         * long DDP header and place a shot DDP header on it.\n         */\n        if(rt->dev->type == ARPHRD_LOCALTLK)\n        {\n                ddp->deh_dnet  = 0;   /* FIXME more hops?? */\n                ddp->deh_snet  = 0;\n        }\n        else\n        {\n                ddp->deh_dnet  = rt->at.s_net;   /* FIXME more hops?? */\n                ddp->deh_snet  = our_addr->s_net;\n        }\n        ddp->deh_dnode = rt->at.s_node;\n        ddp->deh_snode = our_addr->s_node;\n        ddp->deh_dport = 72;\n        ddp->deh_sport = 72;\n\n        *((__u8 *)(ddp+1)) = 22;        \t/* ddp type = IP */\n\n        skb->protocol = htons(ETH_P_ATALK);     /* Protocol has changed */\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\taarp_send_ddp(rt->dev, skb, &rt->at, NULL);\n\n\tspin_unlock(&ipddp_route_lock);\n\n        return NETDEV_TX_OK;\n}\n\n/*\n * Create a routing entry. We first verify that the\n * record does not already exist. If it does we return -EEXIST\n */\nstatic int ipddp_create(struct ipddp_route *new_rt)\n{\n        struct ipddp_route *rt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\n        if (rt == NULL)\n                return -ENOMEM;\n\n        rt->ip = new_rt->ip;\n        rt->at = new_rt->at;\n        rt->next = NULL;\n        if ((rt->dev = atrtr_get_dev(&rt->at)) == NULL) {\n\t\tkfree(rt);\n                return -ENETUNREACH;\n        }\n\n\tspin_lock_bh(&ipddp_route_lock);\n\tif (__ipddp_find_route(rt)) {\n\t\tspin_unlock_bh(&ipddp_route_lock);\n\t\tkfree(rt);\n\t\treturn -EEXIST;\n\t}\n\n        rt->next = ipddp_route_list;\n        ipddp_route_list = rt;\n\n\tspin_unlock_bh(&ipddp_route_lock);\n\n        return 0;\n}\n\n/*\n * Delete a route, we only delete a FULL match.\n * If route does not exist we return -ENOENT.\n */\nstatic int ipddp_delete(struct ipddp_route *rt)\n{\n        struct ipddp_route **r = &ipddp_route_list;\n        struct ipddp_route *tmp;\n\n\tspin_lock_bh(&ipddp_route_lock);\n        while((tmp = *r) != NULL)\n        {\n                if(tmp->ip == rt->ip &&\n\t\t   tmp->at.s_net == rt->at.s_net &&\n\t\t   tmp->at.s_node == rt->at.s_node)\n                {\n                        *r = tmp->next;\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n                        kfree(tmp);\n                        return 0;\n                }\n                r = &tmp->next;\n        }\n\n\tspin_unlock_bh(&ipddp_route_lock);\n        return -ENOENT;\n}\n\n/*\n * Find a routing entry, we only return a FULL match\n */\nstatic struct ipddp_route* __ipddp_find_route(struct ipddp_route *rt)\n{\n        struct ipddp_route *f;\n\n        for(f = ipddp_route_list; f != NULL; f = f->next)\n        {\n                if(f->ip == rt->ip &&\n\t\t   f->at.s_net == rt->at.s_net &&\n\t\t   f->at.s_node == rt->at.s_node)\n                        return f;\n        }\n\n        return NULL;\n}\n\nstatic int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n\n                case SIOCFINDIPDDPRT:\n\t\t\tspin_lock_bh(&ipddp_route_lock);\n\t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp)\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n\n\t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n\n                default:\n                        return -EINVAL;\n        }\n}\n\nstatic struct net_device *dev_ipddp;\n\nMODULE_LICENSE(\"GPL\");\nmodule_param(ipddp_mode, int, 0);\n\nstatic int __init ipddp_init_module(void)\n{\n\tdev_ipddp = ipddp_init();\n\treturn PTR_ERR_OR_ZERO(dev_ipddp);\n}\n\nstatic void __exit ipddp_cleanup_module(void)\n{\n        struct ipddp_route *p;\n\n\tunregister_netdev(dev_ipddp);\n        free_netdev(dev_ipddp);\n\n        while (ipddp_route_list) {\n                p = ipddp_route_list->next;\n                kfree(ipddp_route_list);\n                ipddp_route_list = p;\n        }\n}\n\nmodule_init(ipddp_init_module);\nmodule_exit(ipddp_cleanup_module);\n"], "fixing_code": ["/*\n *\tipddp.c: IP to Appletalk-IP Encapsulation driver for Linux\n *\t\t Appletalk-IP to IP Decapsulation driver for Linux\n *\n *\tAuthors:\n *      - DDP-IP Encap by: Bradford W. Johnson <johns393@maroon.tc.umn.edu>\n *\t- DDP-IP Decap by: Jay Schulist <jschlst@samba.org>\n *\n *\tDerived from:\n *\t- Almost all code already existed in net/appletalk/ddp.c I just\n *\t  moved/reorginized it into a driver file. Original IP-over-DDP code\n *\t  was done by Bradford W. Johnson <johns393@maroon.tc.umn.edu>\n *      - skeleton.c: A network driver outline for linux.\n *        Written 1993-94 by Donald Becker.\n *\t- dummy.c: A dummy net driver. By Nick Holloway.\n *\t- MacGate: A user space Daemon for Appletalk-IP Decap for\n *\t  Linux by Jay Schulist <jschlst@samba.org>\n *\n *      Copyright 1993 United States Government as represented by the\n *      Director, National Security Agency.\n *\n *      This software may be used and distributed according to the terms\n *      of the GNU General Public License, incorporated herein by reference.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ip.h>\n#include <linux/atalk.h>\n#include <linux/if_arp.h>\n#include <linux/slab.h>\n#include <net/route.h>\n#include <linux/uaccess.h>\n\n#include \"ipddp.h\"\t\t/* Our stuff */\n\nstatic const char version[] = KERN_INFO \"ipddp.c:v0.01 8/28/97 Bradford W. Johnson <johns393@maroon.tc.umn.edu>\\n\";\n\nstatic struct ipddp_route *ipddp_route_list;\nstatic DEFINE_SPINLOCK(ipddp_route_lock);\n\n#ifdef CONFIG_IPDDP_ENCAP\nstatic int ipddp_mode = IPDDP_ENCAP;\n#else\nstatic int ipddp_mode = IPDDP_DECAP;\n#endif\n\n/* Index to functions, as function prototypes. */\nstatic netdev_tx_t ipddp_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev);\nstatic int ipddp_create(struct ipddp_route *new_rt);\nstatic int ipddp_delete(struct ipddp_route *rt);\nstatic struct ipddp_route* __ipddp_find_route(struct ipddp_route *rt);\nstatic int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);\n\nstatic const struct net_device_ops ipddp_netdev_ops = {\n\t.ndo_start_xmit\t\t= ipddp_xmit,\n\t.ndo_do_ioctl   \t= ipddp_ioctl,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic struct net_device * __init ipddp_init(void)\n{\n\tstatic unsigned version_printed;\n\tstruct net_device *dev;\n\tint err;\n\n\tdev = alloc_etherdev(0);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnetif_keep_dst(dev);\n\tstrcpy(dev->name, \"ipddp%d\");\n\n\tif (version_printed++ == 0)\n                printk(version);\n\n\t/* Initialize the device structure. */\n\tdev->netdev_ops = &ipddp_netdev_ops;\n\n        dev->type = ARPHRD_IPDDP;       \t/* IP over DDP tunnel */\n        dev->mtu = 585;\n        dev->flags |= IFF_NOARP;\n\n        /*\n         *      The worst case header we will need is currently a\n         *      ethernet header (14 bytes) and a ddp header (sizeof ddpehdr+1)\n         *      We send over SNAP so that takes another 8 bytes.\n         */\n        dev->hard_header_len = 14+8+sizeof(struct ddpehdr)+1;\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* Let the user now what mode we are in */\n\tif(ipddp_mode == IPDDP_ENCAP)\n\t\tprintk(\"%s: Appletalk-IP Encap. mode by Bradford W. Johnson <johns393@maroon.tc.umn.edu>\\n\", \n\t\t\tdev->name);\n\tif(ipddp_mode == IPDDP_DECAP)\n\t\tprintk(\"%s: Appletalk-IP Decap. mode by Jay Schulist <jschlst@samba.org>\\n\", \n\t\t\tdev->name);\n\n        return dev;\n}\n\n\n/*\n * Transmit LLAP/ELAP frame using aarp_send_ddp.\n */\nstatic netdev_tx_t ipddp_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\t__be32 paddr = skb_rtable(skb)->rt_gateway;\n        struct ddpehdr *ddp;\n        struct ipddp_route *rt;\n        struct atalk_addr *our_addr;\n\n\tspin_lock(&ipddp_route_lock);\n\n\t/*\n         * Find appropriate route to use, based only on IP number.\n         */\n        for(rt = ipddp_route_list; rt != NULL; rt = rt->next)\n        {\n                if(rt->ip == paddr)\n                        break;\n        }\n        if(rt == NULL) {\n\t\tspin_unlock(&ipddp_route_lock);\n                return NETDEV_TX_OK;\n\t}\n\n        our_addr = atalk_find_dev_addr(rt->dev);\n\n\tif(ipddp_mode == IPDDP_DECAP)\n\t\t/* \n\t\t * Pull off the excess room that should not be there.\n\t\t * This is due to a hard-header problem. This is the\n\t\t * quick fix for now though, till it breaks.\n\t\t */\n\t\tskb_pull(skb, 35-(sizeof(struct ddpehdr)+1));\n\n\t/* Create the Extended DDP header */\n\tddp = (struct ddpehdr *)skb->data;\n        ddp->deh_len_hops = htons(skb->len + (1<<10));\n        ddp->deh_sum = 0;\n\n\t/*\n         * For Localtalk we need aarp_send_ddp to strip the\n         * long DDP header and place a shot DDP header on it.\n         */\n        if(rt->dev->type == ARPHRD_LOCALTLK)\n        {\n                ddp->deh_dnet  = 0;   /* FIXME more hops?? */\n                ddp->deh_snet  = 0;\n        }\n        else\n        {\n                ddp->deh_dnet  = rt->at.s_net;   /* FIXME more hops?? */\n                ddp->deh_snet  = our_addr->s_net;\n        }\n        ddp->deh_dnode = rt->at.s_node;\n        ddp->deh_snode = our_addr->s_node;\n        ddp->deh_dport = 72;\n        ddp->deh_sport = 72;\n\n        *((__u8 *)(ddp+1)) = 22;        \t/* ddp type = IP */\n\n        skb->protocol = htons(ETH_P_ATALK);     /* Protocol has changed */\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\taarp_send_ddp(rt->dev, skb, &rt->at, NULL);\n\n\tspin_unlock(&ipddp_route_lock);\n\n        return NETDEV_TX_OK;\n}\n\n/*\n * Create a routing entry. We first verify that the\n * record does not already exist. If it does we return -EEXIST\n */\nstatic int ipddp_create(struct ipddp_route *new_rt)\n{\n        struct ipddp_route *rt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\n        if (rt == NULL)\n                return -ENOMEM;\n\n        rt->ip = new_rt->ip;\n        rt->at = new_rt->at;\n        rt->next = NULL;\n        if ((rt->dev = atrtr_get_dev(&rt->at)) == NULL) {\n\t\tkfree(rt);\n                return -ENETUNREACH;\n        }\n\n\tspin_lock_bh(&ipddp_route_lock);\n\tif (__ipddp_find_route(rt)) {\n\t\tspin_unlock_bh(&ipddp_route_lock);\n\t\tkfree(rt);\n\t\treturn -EEXIST;\n\t}\n\n        rt->next = ipddp_route_list;\n        ipddp_route_list = rt;\n\n\tspin_unlock_bh(&ipddp_route_lock);\n\n        return 0;\n}\n\n/*\n * Delete a route, we only delete a FULL match.\n * If route does not exist we return -ENOENT.\n */\nstatic int ipddp_delete(struct ipddp_route *rt)\n{\n        struct ipddp_route **r = &ipddp_route_list;\n        struct ipddp_route *tmp;\n\n\tspin_lock_bh(&ipddp_route_lock);\n        while((tmp = *r) != NULL)\n        {\n                if(tmp->ip == rt->ip &&\n\t\t   tmp->at.s_net == rt->at.s_net &&\n\t\t   tmp->at.s_node == rt->at.s_node)\n                {\n                        *r = tmp->next;\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n                        kfree(tmp);\n                        return 0;\n                }\n                r = &tmp->next;\n        }\n\n\tspin_unlock_bh(&ipddp_route_lock);\n        return -ENOENT;\n}\n\n/*\n * Find a routing entry, we only return a FULL match\n */\nstatic struct ipddp_route* __ipddp_find_route(struct ipddp_route *rt)\n{\n        struct ipddp_route *f;\n\n        for(f = ipddp_route_list; f != NULL; f = f->next)\n        {\n                if(f->ip == rt->ip &&\n\t\t   f->at.s_net == rt->at.s_net &&\n\t\t   f->at.s_node == rt->at.s_node)\n                        return f;\n        }\n\n        return NULL;\n}\n\nstatic int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n\n                case SIOCFINDIPDDPRT:\n\t\t\tspin_lock_bh(&ipddp_route_lock);\n\t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp) {\n\t\t\t\tmemset(&rcp2, 0, sizeof(rcp2));\n\t\t\t\trcp2.ip    = rp->ip;\n\t\t\t\trcp2.at    = rp->at;\n\t\t\t\trcp2.flags = rp->flags;\n\t\t\t}\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n\n\t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n\n                default:\n                        return -EINVAL;\n        }\n}\n\nstatic struct net_device *dev_ipddp;\n\nMODULE_LICENSE(\"GPL\");\nmodule_param(ipddp_mode, int, 0);\n\nstatic int __init ipddp_init_module(void)\n{\n\tdev_ipddp = ipddp_init();\n\treturn PTR_ERR_OR_ZERO(dev_ipddp);\n}\n\nstatic void __exit ipddp_cleanup_module(void)\n{\n        struct ipddp_route *p;\n\n\tunregister_netdev(dev_ipddp);\n        free_netdev(dev_ipddp);\n\n        while (ipddp_route_list) {\n                p = ipddp_route_list->next;\n                kfree(ipddp_route_list);\n                ipddp_route_list = p;\n        }\n}\n\nmodule_init(ipddp_init_module);\nmodule_exit(ipddp_cleanup_module);\n"], "filenames": ["drivers/net/appletalk/ipddp.c"], "buggy_code_start_loc": [286], "buggy_code_end_loc": [288], "fixing_code_start_loc": [286], "fixing_code_end_loc": [292], "type": "CWE-200", "message": "An issue was discovered in the Linux kernel before 4.18.11. The ipddp_ioctl function in drivers/net/appletalk/ipddp.c allows local users to obtain sensitive kernel address information by leveraging CAP_NET_ADMIN to read the ipddp_route dev and next fields via an SIOCFINDIPDDPRT ioctl call.", "other": {"cve": {"id": "CVE-2018-20511", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-27T14:29:00.457", "lastModified": "2019-04-01T21:29:29.497", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 4.18.11. The ipddp_ioctl function in drivers/net/appletalk/ipddp.c allows local users to obtain sensitive kernel address information by leveraging CAP_NET_ADMIN to read the ipddp_route dev and next fields via an SIOCFINDIPDDPRT ioctl call."}, {"lang": "es", "value": "Se ha descubierto un problema en el kernel de Linux hasta antes de la versi\u00f3n 4.18.11. La funci\u00f3n ipddp_ioctl en drivers/net/appletalk/ipddp.c permite que los usuarios locales obtengan informaci\u00f3n sensible del kernel aprovechando CAP_NET_ADMIN para leer los campos dev y next de ipddp_route mediante una llamada IOCTL SIOCFINDIPDDPRT."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.18.11", "matchCriteriaId": "B42D0BD6-695A-4AC4-961F-3930A07868E8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=9824dfae5741275473a23a7ed5756c7b6efacc9d", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/106347", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.18.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/9824dfae5741275473a23a7ed5756c7b6efacc9d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00034.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/04/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://lkml.org/lkml/2018/9/27/480", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4094-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4118-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/9824dfae5741275473a23a7ed5756c7b6efacc9d"}}