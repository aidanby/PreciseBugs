{"buggy_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tRouting netlink socket interface: protocol independent part.\n *\n * Authors:\tAlexey Kuznetsov, <kuznet@ms2.inr.ac.ru>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n *\tFixes:\n *\tVitaly E. Lavrov\t\tRTA_OK arithmetics was wrong.\n */\n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/capability.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/if_addr.h>\n#include <linux/if_bridge.h>\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n\n#include <asm/uaccess.h>\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/arp.h>\n#include <net/route.h>\n#include <net/udp.h>\n#include <net/sock.h>\n#include <net/pkt_sched.h>\n#include <net/fib_rules.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n\nstruct rtnl_link {\n\trtnl_doit_func\t\tdoit;\n\trtnl_dumpit_func\tdumpit;\n\trtnl_calcit_func \tcalcit;\n};\n\nstatic DEFINE_MUTEX(rtnl_mutex);\n\nvoid rtnl_lock(void)\n{\n\tmutex_lock(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_lock);\n\nvoid __rtnl_unlock(void)\n{\n\tmutex_unlock(&rtnl_mutex);\n}\n\nvoid rtnl_unlock(void)\n{\n\t/* This fellow will unlock it for us. */\n\tnetdev_run_todo();\n}\nEXPORT_SYMBOL(rtnl_unlock);\n\nint rtnl_trylock(void)\n{\n\treturn mutex_trylock(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_trylock);\n\nint rtnl_is_locked(void)\n{\n\treturn mutex_is_locked(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_is_locked);\n\n#ifdef CONFIG_PROVE_LOCKING\nint lockdep_rtnl_is_held(void)\n{\n\treturn lockdep_is_held(&rtnl_mutex);\n}\nEXPORT_SYMBOL(lockdep_rtnl_is_held);\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n\nstatic struct rtnl_link *rtnl_msg_handlers[RTNL_FAMILY_MAX + 1];\n\nstatic inline int rtm_msgindex(int msgtype)\n{\n\tint msgindex = msgtype - RTM_BASE;\n\n\t/*\n\t * msgindex < 0 implies someone tried to register a netlink\n\t * control code. msgindex >= RTM_NR_MSGTYPES may indicate that\n\t * the message type has not been added to linux/rtnetlink.h\n\t */\n\tBUG_ON(msgindex < 0 || msgindex >= RTM_NR_MSGTYPES);\n\n\treturn msgindex;\n}\n\nstatic rtnl_doit_func rtnl_get_doit(int protocol, int msgindex)\n{\n\tstruct rtnl_link *tab;\n\n\tif (protocol <= RTNL_FAMILY_MAX)\n\t\ttab = rtnl_msg_handlers[protocol];\n\telse\n\t\ttab = NULL;\n\n\tif (tab == NULL || tab[msgindex].doit == NULL)\n\t\ttab = rtnl_msg_handlers[PF_UNSPEC];\n\n\treturn tab[msgindex].doit;\n}\n\nstatic rtnl_dumpit_func rtnl_get_dumpit(int protocol, int msgindex)\n{\n\tstruct rtnl_link *tab;\n\n\tif (protocol <= RTNL_FAMILY_MAX)\n\t\ttab = rtnl_msg_handlers[protocol];\n\telse\n\t\ttab = NULL;\n\n\tif (tab == NULL || tab[msgindex].dumpit == NULL)\n\t\ttab = rtnl_msg_handlers[PF_UNSPEC];\n\n\treturn tab[msgindex].dumpit;\n}\n\nstatic rtnl_calcit_func rtnl_get_calcit(int protocol, int msgindex)\n{\n\tstruct rtnl_link *tab;\n\n\tif (protocol <= RTNL_FAMILY_MAX)\n\t\ttab = rtnl_msg_handlers[protocol];\n\telse\n\t\ttab = NULL;\n\n\tif (tab == NULL || tab[msgindex].calcit == NULL)\n\t\ttab = rtnl_msg_handlers[PF_UNSPEC];\n\n\treturn tab[msgindex].calcit;\n}\n\n/**\n * __rtnl_register - Register a rtnetlink message type\n * @protocol: Protocol family or PF_UNSPEC\n * @msgtype: rtnetlink message type\n * @doit: Function pointer called for each request message\n * @dumpit: Function pointer called for each dump request (NLM_F_DUMP) message\n * @calcit: Function pointer to calc size of dump message\n *\n * Registers the specified function pointers (at least one of them has\n * to be non-NULL) to be called whenever a request message for the\n * specified protocol family and message type is received.\n *\n * The special protocol family PF_UNSPEC may be used to define fallback\n * function pointers for the case when no entry for the specific protocol\n * family exists.\n *\n * Returns 0 on success or a negative error code.\n */\nint __rtnl_register(int protocol, int msgtype,\n\t\t    rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t    rtnl_calcit_func calcit)\n{\n\tstruct rtnl_link *tab;\n\tint msgindex;\n\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\tmsgindex = rtm_msgindex(msgtype);\n\n\ttab = rtnl_msg_handlers[protocol];\n\tif (tab == NULL) {\n\t\ttab = kcalloc(RTM_NR_MSGTYPES, sizeof(*tab), GFP_KERNEL);\n\t\tif (tab == NULL)\n\t\t\treturn -ENOBUFS;\n\n\t\trtnl_msg_handlers[protocol] = tab;\n\t}\n\n\tif (doit)\n\t\ttab[msgindex].doit = doit;\n\n\tif (dumpit)\n\t\ttab[msgindex].dumpit = dumpit;\n\n\tif (calcit)\n\t\ttab[msgindex].calcit = calcit;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__rtnl_register);\n\n/**\n * rtnl_register - Register a rtnetlink message type\n *\n * Identical to __rtnl_register() but panics on failure. This is useful\n * as failure of this function is very unlikely, it can only happen due\n * to lack of memory when allocating the chain to store all message\n * handlers for a protocol. Meant for use in init functions where lack\n * of memory implies no sense in continuing.\n */\nvoid rtnl_register(int protocol, int msgtype,\n\t\t   rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t   rtnl_calcit_func calcit)\n{\n\tif (__rtnl_register(protocol, msgtype, doit, dumpit, calcit) < 0)\n\t\tpanic(\"Unable to register rtnetlink message handler, \"\n\t\t      \"protocol = %d, message type = %d\\n\",\n\t\t      protocol, msgtype);\n}\nEXPORT_SYMBOL_GPL(rtnl_register);\n\n/**\n * rtnl_unregister - Unregister a rtnetlink message type\n * @protocol: Protocol family or PF_UNSPEC\n * @msgtype: rtnetlink message type\n *\n * Returns 0 on success or a negative error code.\n */\nint rtnl_unregister(int protocol, int msgtype)\n{\n\tint msgindex;\n\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\tmsgindex = rtm_msgindex(msgtype);\n\n\tif (rtnl_msg_handlers[protocol] == NULL)\n\t\treturn -ENOENT;\n\n\trtnl_msg_handlers[protocol][msgindex].doit = NULL;\n\trtnl_msg_handlers[protocol][msgindex].dumpit = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtnl_unregister);\n\n/**\n * rtnl_unregister_all - Unregister all rtnetlink message type of a protocol\n * @protocol : Protocol family or PF_UNSPEC\n *\n * Identical to calling rtnl_unregster() for all registered message types\n * of a certain protocol family.\n */\nvoid rtnl_unregister_all(int protocol)\n{\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\n\tkfree(rtnl_msg_handlers[protocol]);\n\trtnl_msg_handlers[protocol] = NULL;\n}\nEXPORT_SYMBOL_GPL(rtnl_unregister_all);\n\nstatic LIST_HEAD(link_ops);\n\nstatic const struct rtnl_link_ops *rtnl_link_ops_get(const char *kind)\n{\n\tconst struct rtnl_link_ops *ops;\n\n\tlist_for_each_entry(ops, &link_ops, list) {\n\t\tif (!strcmp(ops->kind, kind))\n\t\t\treturn ops;\n\t}\n\treturn NULL;\n}\n\n/**\n * __rtnl_link_register - Register rtnl_link_ops with rtnetlink.\n * @ops: struct rtnl_link_ops * to register\n *\n * The caller must hold the rtnl_mutex. This function should be used\n * by drivers that create devices during module initialization. It\n * must be called before registering the devices.\n *\n * Returns 0 on success or a negative error code.\n */\nint __rtnl_link_register(struct rtnl_link_ops *ops)\n{\n\tif (rtnl_link_ops_get(ops->kind))\n\t\treturn -EEXIST;\n\n\tif (!ops->dellink)\n\t\tops->dellink = unregister_netdevice_queue;\n\n\tlist_add_tail(&ops->list, &link_ops);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__rtnl_link_register);\n\n/**\n * rtnl_link_register - Register rtnl_link_ops with rtnetlink.\n * @ops: struct rtnl_link_ops * to register\n *\n * Returns 0 on success or a negative error code.\n */\nint rtnl_link_register(struct rtnl_link_ops *ops)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = __rtnl_link_register(ops);\n\trtnl_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtnl_link_register);\n\nstatic void __rtnl_kill_links(struct net *net, struct rtnl_link_ops *ops)\n{\n\tstruct net_device *dev;\n\tLIST_HEAD(list_kill);\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->rtnl_link_ops == ops)\n\t\t\tops->dellink(dev, &list_kill);\n\t}\n\tunregister_netdevice_many(&list_kill);\n}\n\n/**\n * __rtnl_link_unregister - Unregister rtnl_link_ops from rtnetlink.\n * @ops: struct rtnl_link_ops * to unregister\n *\n * The caller must hold the rtnl_mutex.\n */\nvoid __rtnl_link_unregister(struct rtnl_link_ops *ops)\n{\n\tstruct net *net;\n\n\tfor_each_net(net) {\n\t\t__rtnl_kill_links(net, ops);\n\t}\n\tlist_del(&ops->list);\n}\nEXPORT_SYMBOL_GPL(__rtnl_link_unregister);\n\n/**\n * rtnl_link_unregister - Unregister rtnl_link_ops from rtnetlink.\n * @ops: struct rtnl_link_ops * to unregister\n */\nvoid rtnl_link_unregister(struct rtnl_link_ops *ops)\n{\n\trtnl_lock();\n\t__rtnl_link_unregister(ops);\n\trtnl_unlock();\n}\nEXPORT_SYMBOL_GPL(rtnl_link_unregister);\n\nstatic size_t rtnl_link_get_size(const struct net_device *dev)\n{\n\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\tsize_t size;\n\n\tif (!ops)\n\t\treturn 0;\n\n\tsize = nla_total_size(sizeof(struct nlattr)) + /* IFLA_LINKINFO */\n\t       nla_total_size(strlen(ops->kind) + 1);  /* IFLA_INFO_KIND */\n\n\tif (ops->get_size)\n\t\t/* IFLA_INFO_DATA + nested data */\n\t\tsize += nla_total_size(sizeof(struct nlattr)) +\n\t\t\tops->get_size(dev);\n\n\tif (ops->get_xstats_size)\n\t\t/* IFLA_INFO_XSTATS */\n\t\tsize += nla_total_size(ops->get_xstats_size(dev));\n\n\treturn size;\n}\n\nstatic LIST_HEAD(rtnl_af_ops);\n\nstatic const struct rtnl_af_ops *rtnl_af_lookup(const int family)\n{\n\tconst struct rtnl_af_ops *ops;\n\n\tlist_for_each_entry(ops, &rtnl_af_ops, list) {\n\t\tif (ops->family == family)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * __rtnl_af_register - Register rtnl_af_ops with rtnetlink.\n * @ops: struct rtnl_af_ops * to register\n *\n * The caller must hold the rtnl_mutex.\n *\n * Returns 0 on success or a negative error code.\n */\nint __rtnl_af_register(struct rtnl_af_ops *ops)\n{\n\tlist_add_tail(&ops->list, &rtnl_af_ops);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__rtnl_af_register);\n\n/**\n * rtnl_af_register - Register rtnl_af_ops with rtnetlink.\n * @ops: struct rtnl_af_ops * to register\n *\n * Returns 0 on success or a negative error code.\n */\nint rtnl_af_register(struct rtnl_af_ops *ops)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = __rtnl_af_register(ops);\n\trtnl_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtnl_af_register);\n\n/**\n * __rtnl_af_unregister - Unregister rtnl_af_ops from rtnetlink.\n * @ops: struct rtnl_af_ops * to unregister\n *\n * The caller must hold the rtnl_mutex.\n */\nvoid __rtnl_af_unregister(struct rtnl_af_ops *ops)\n{\n\tlist_del(&ops->list);\n}\nEXPORT_SYMBOL_GPL(__rtnl_af_unregister);\n\n/**\n * rtnl_af_unregister - Unregister rtnl_af_ops from rtnetlink.\n * @ops: struct rtnl_af_ops * to unregister\n */\nvoid rtnl_af_unregister(struct rtnl_af_ops *ops)\n{\n\trtnl_lock();\n\t__rtnl_af_unregister(ops);\n\trtnl_unlock();\n}\nEXPORT_SYMBOL_GPL(rtnl_af_unregister);\n\nstatic size_t rtnl_link_get_af_size(const struct net_device *dev)\n{\n\tstruct rtnl_af_ops *af_ops;\n\tsize_t size;\n\n\t/* IFLA_AF_SPEC */\n\tsize = nla_total_size(sizeof(struct nlattr));\n\n\tlist_for_each_entry(af_ops, &rtnl_af_ops, list) {\n\t\tif (af_ops->get_link_af_size) {\n\t\t\t/* AF_* + nested data */\n\t\t\tsize += nla_total_size(sizeof(struct nlattr)) +\n\t\t\t\taf_ops->get_link_af_size(dev);\n\t\t}\n\t}\n\n\treturn size;\n}\n\nstatic int rtnl_link_fill(struct sk_buff *skb, const struct net_device *dev)\n{\n\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\tstruct nlattr *linkinfo, *data;\n\tint err = -EMSGSIZE;\n\n\tlinkinfo = nla_nest_start(skb, IFLA_LINKINFO);\n\tif (linkinfo == NULL)\n\t\tgoto out;\n\n\tif (nla_put_string(skb, IFLA_INFO_KIND, ops->kind) < 0)\n\t\tgoto err_cancel_link;\n\tif (ops->fill_xstats) {\n\t\terr = ops->fill_xstats(skb, dev);\n\t\tif (err < 0)\n\t\t\tgoto err_cancel_link;\n\t}\n\tif (ops->fill_info) {\n\t\tdata = nla_nest_start(skb, IFLA_INFO_DATA);\n\t\tif (data == NULL)\n\t\t\tgoto err_cancel_link;\n\t\terr = ops->fill_info(skb, dev);\n\t\tif (err < 0)\n\t\t\tgoto err_cancel_data;\n\t\tnla_nest_end(skb, data);\n\t}\n\n\tnla_nest_end(skb, linkinfo);\n\treturn 0;\n\nerr_cancel_data:\n\tnla_nest_cancel(skb, data);\nerr_cancel_link:\n\tnla_nest_cancel(skb, linkinfo);\nout:\n\treturn err;\n}\n\nstatic const int rtm_min[RTM_NR_FAMILIES] =\n{\n\t[RTM_FAM(RTM_NEWLINK)]      = NLMSG_LENGTH(sizeof(struct ifinfomsg)),\n\t[RTM_FAM(RTM_NEWADDR)]      = NLMSG_LENGTH(sizeof(struct ifaddrmsg)),\n\t[RTM_FAM(RTM_NEWROUTE)]     = NLMSG_LENGTH(sizeof(struct rtmsg)),\n\t[RTM_FAM(RTM_NEWRULE)]      = NLMSG_LENGTH(sizeof(struct fib_rule_hdr)),\n\t[RTM_FAM(RTM_NEWQDISC)]     = NLMSG_LENGTH(sizeof(struct tcmsg)),\n\t[RTM_FAM(RTM_NEWTCLASS)]    = NLMSG_LENGTH(sizeof(struct tcmsg)),\n\t[RTM_FAM(RTM_NEWTFILTER)]   = NLMSG_LENGTH(sizeof(struct tcmsg)),\n\t[RTM_FAM(RTM_NEWACTION)]    = NLMSG_LENGTH(sizeof(struct tcamsg)),\n\t[RTM_FAM(RTM_GETMULTICAST)] = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n\t[RTM_FAM(RTM_GETANYCAST)]   = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n};\n\nstatic const int rta_max[RTM_NR_FAMILIES] =\n{\n\t[RTM_FAM(RTM_NEWLINK)]      = IFLA_MAX,\n\t[RTM_FAM(RTM_NEWADDR)]      = IFA_MAX,\n\t[RTM_FAM(RTM_NEWROUTE)]     = RTA_MAX,\n\t[RTM_FAM(RTM_NEWRULE)]      = FRA_MAX,\n\t[RTM_FAM(RTM_NEWQDISC)]     = TCA_MAX,\n\t[RTM_FAM(RTM_NEWTCLASS)]    = TCA_MAX,\n\t[RTM_FAM(RTM_NEWTFILTER)]   = TCA_MAX,\n\t[RTM_FAM(RTM_NEWACTION)]    = TCAA_MAX,\n};\n\nint rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, unsigned int group, int echo)\n{\n\tstruct sock *rtnl = net->rtnl;\n\tint err = 0;\n\n\tNETLINK_CB(skb).dst_group = group;\n\tif (echo)\n\t\tatomic_inc(&skb->users);\n\tnetlink_broadcast(rtnl, skb, pid, group, GFP_KERNEL);\n\tif (echo)\n\t\terr = netlink_unicast(rtnl, skb, pid, MSG_DONTWAIT);\n\treturn err;\n}\n\nint rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid)\n{\n\tstruct sock *rtnl = net->rtnl;\n\n\treturn nlmsg_unicast(rtnl, skb, pid);\n}\nEXPORT_SYMBOL(rtnl_unicast);\n\nvoid rtnl_notify(struct sk_buff *skb, struct net *net, u32 pid, u32 group,\n\t\t struct nlmsghdr *nlh, gfp_t flags)\n{\n\tstruct sock *rtnl = net->rtnl;\n\tint report = 0;\n\n\tif (nlh)\n\t\treport = nlmsg_report(nlh);\n\n\tnlmsg_notify(rtnl, skb, pid, group, report, flags);\n}\nEXPORT_SYMBOL(rtnl_notify);\n\nvoid rtnl_set_sk_err(struct net *net, u32 group, int error)\n{\n\tstruct sock *rtnl = net->rtnl;\n\n\tnetlink_set_err(rtnl, 0, group, error);\n}\nEXPORT_SYMBOL(rtnl_set_sk_err);\n\nint rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics)\n{\n\tstruct nlattr *mx;\n\tint i, valid = 0;\n\n\tmx = nla_nest_start(skb, RTA_METRICS);\n\tif (mx == NULL)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < RTAX_MAX; i++) {\n\t\tif (metrics[i]) {\n\t\t\tvalid++;\n\t\t\tif (nla_put_u32(skb, i+1, metrics[i]))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (!valid) {\n\t\tnla_nest_cancel(skb, mx);\n\t\treturn 0;\n\t}\n\n\treturn nla_nest_end(skb, mx);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, mx);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL(rtnetlink_put_metrics);\n\nint rtnl_put_cacheinfo(struct sk_buff *skb, struct dst_entry *dst, u32 id,\n\t\t       long expires, u32 error)\n{\n\tstruct rta_cacheinfo ci = {\n\t\t.rta_lastuse = jiffies_delta_to_clock_t(jiffies - dst->lastuse),\n\t\t.rta_used = dst->__use,\n\t\t.rta_clntref = atomic_read(&(dst->__refcnt)),\n\t\t.rta_error = error,\n\t\t.rta_id =  id,\n\t};\n\n\tif (expires) {\n\t\tunsigned long clock;\n\n\t\tclock = jiffies_to_clock_t(abs(expires));\n\t\tclock = min_t(unsigned long, clock, INT_MAX);\n\t\tci.rta_expires = (expires > 0) ? clock : -clock;\n\t}\n\treturn nla_put(skb, RTA_CACHEINFO, sizeof(ci), &ci);\n}\nEXPORT_SYMBOL_GPL(rtnl_put_cacheinfo);\n\nstatic void set_operstate(struct net_device *dev, unsigned char transition)\n{\n\tunsigned char operstate = dev->operstate;\n\n\tswitch (transition) {\n\tcase IF_OPER_UP:\n\t\tif ((operstate == IF_OPER_DORMANT ||\n\t\t     operstate == IF_OPER_UNKNOWN) &&\n\t\t    !netif_dormant(dev))\n\t\t\toperstate = IF_OPER_UP;\n\t\tbreak;\n\n\tcase IF_OPER_DORMANT:\n\t\tif (operstate == IF_OPER_UP ||\n\t\t    operstate == IF_OPER_UNKNOWN)\n\t\t\toperstate = IF_OPER_DORMANT;\n\t\tbreak;\n\t}\n\n\tif (dev->operstate != operstate) {\n\t\twrite_lock_bh(&dev_base_lock);\n\t\tdev->operstate = operstate;\n\t\twrite_unlock_bh(&dev_base_lock);\n\t\tnetdev_state_change(dev);\n\t}\n}\n\nstatic unsigned int rtnl_dev_get_flags(const struct net_device *dev)\n{\n\treturn (dev->flags & ~(IFF_PROMISC | IFF_ALLMULTI)) |\n\t       (dev->gflags & (IFF_PROMISC | IFF_ALLMULTI));\n}\n\nstatic unsigned int rtnl_dev_combine_flags(const struct net_device *dev,\n\t\t\t\t\t   const struct ifinfomsg *ifm)\n{\n\tunsigned int flags = ifm->ifi_flags;\n\n\t/* bugwards compatibility: ifi_change == 0 is treated as ~0 */\n\tif (ifm->ifi_change)\n\t\tflags = (flags & ifm->ifi_change) |\n\t\t\t(rtnl_dev_get_flags(dev) & ~ifm->ifi_change);\n\n\treturn flags;\n}\n\nstatic void copy_rtnl_link_stats(struct rtnl_link_stats *a,\n\t\t\t\t const struct rtnl_link_stats64 *b)\n{\n\ta->rx_packets = b->rx_packets;\n\ta->tx_packets = b->tx_packets;\n\ta->rx_bytes = b->rx_bytes;\n\ta->tx_bytes = b->tx_bytes;\n\ta->rx_errors = b->rx_errors;\n\ta->tx_errors = b->tx_errors;\n\ta->rx_dropped = b->rx_dropped;\n\ta->tx_dropped = b->tx_dropped;\n\n\ta->multicast = b->multicast;\n\ta->collisions = b->collisions;\n\n\ta->rx_length_errors = b->rx_length_errors;\n\ta->rx_over_errors = b->rx_over_errors;\n\ta->rx_crc_errors = b->rx_crc_errors;\n\ta->rx_frame_errors = b->rx_frame_errors;\n\ta->rx_fifo_errors = b->rx_fifo_errors;\n\ta->rx_missed_errors = b->rx_missed_errors;\n\n\ta->tx_aborted_errors = b->tx_aborted_errors;\n\ta->tx_carrier_errors = b->tx_carrier_errors;\n\ta->tx_fifo_errors = b->tx_fifo_errors;\n\ta->tx_heartbeat_errors = b->tx_heartbeat_errors;\n\ta->tx_window_errors = b->tx_window_errors;\n\n\ta->rx_compressed = b->rx_compressed;\n\ta->tx_compressed = b->tx_compressed;\n}\n\nstatic void copy_rtnl_link_stats64(void *v, const struct rtnl_link_stats64 *b)\n{\n\tmemcpy(v, b, sizeof(*b));\n}\n\n/* All VF info */\nstatic inline int rtnl_vfinfo_size(const struct net_device *dev,\n\t\t\t\t   u32 ext_filter_mask)\n{\n\tif (dev->dev.parent && dev_is_pci(dev->dev.parent) &&\n\t    (ext_filter_mask & RTEXT_FILTER_VF)) {\n\t\tint num_vfs = dev_num_vf(dev->dev.parent);\n\t\tsize_t size = nla_total_size(sizeof(struct nlattr));\n\t\tsize += nla_total_size(num_vfs * sizeof(struct nlattr));\n\t\tsize += num_vfs *\n\t\t\t(nla_total_size(sizeof(struct ifla_vf_mac)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_vlan)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_tx_rate)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_spoofchk)));\n\t\treturn size;\n\t} else\n\t\treturn 0;\n}\n\nstatic size_t rtnl_port_size(const struct net_device *dev)\n{\n\tsize_t port_size = nla_total_size(4)\t\t/* PORT_VF */\n\t\t+ nla_total_size(PORT_PROFILE_MAX)\t/* PORT_PROFILE */\n\t\t+ nla_total_size(sizeof(struct ifla_port_vsi))\n\t\t\t\t\t\t\t/* PORT_VSI_TYPE */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_INSTANCE_UUID */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_HOST_UUID */\n\t\t+ nla_total_size(1)\t\t\t/* PROT_VDP_REQUEST */\n\t\t+ nla_total_size(2);\t\t\t/* PORT_VDP_RESPONSE */\n\tsize_t vf_ports_size = nla_total_size(sizeof(struct nlattr));\n\tsize_t vf_port_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\tsize_t port_self_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\n\tif (!dev->netdev_ops->ndo_get_vf_port || !dev->dev.parent)\n\t\treturn 0;\n\tif (dev_num_vf(dev->dev.parent))\n\t\treturn port_self_size + vf_ports_size +\n\t\t\tvf_port_size * dev_num_vf(dev->dev.parent);\n\telse\n\t\treturn port_self_size;\n}\n\nstatic noinline size_t if_nlmsg_size(const struct net_device *dev,\n\t\t\t\t     u32 ext_filter_mask)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t       + nla_total_size(IFNAMSIZ) /* IFLA_IFNAME */\n\t       + nla_total_size(IFALIASZ) /* IFLA_IFALIAS */\n\t       + nla_total_size(IFNAMSIZ) /* IFLA_QDISC */\n\t       + nla_total_size(sizeof(struct rtnl_link_ifmap))\n\t       + nla_total_size(sizeof(struct rtnl_link_stats))\n\t       + nla_total_size(sizeof(struct rtnl_link_stats64))\n\t       + nla_total_size(MAX_ADDR_LEN) /* IFLA_ADDRESS */\n\t       + nla_total_size(MAX_ADDR_LEN) /* IFLA_BROADCAST */\n\t       + nla_total_size(4) /* IFLA_TXQLEN */\n\t       + nla_total_size(4) /* IFLA_WEIGHT */\n\t       + nla_total_size(4) /* IFLA_MTU */\n\t       + nla_total_size(4) /* IFLA_LINK */\n\t       + nla_total_size(4) /* IFLA_MASTER */\n\t       + nla_total_size(1) /* IFLA_CARRIER */\n\t       + nla_total_size(4) /* IFLA_PROMISCUITY */\n\t       + nla_total_size(4) /* IFLA_NUM_TX_QUEUES */\n\t       + nla_total_size(4) /* IFLA_NUM_RX_QUEUES */\n\t       + nla_total_size(1) /* IFLA_OPERSTATE */\n\t       + nla_total_size(1) /* IFLA_LINKMODE */\n\t       + nla_total_size(ext_filter_mask\n\t\t\t        & RTEXT_FILTER_VF ? 4 : 0) /* IFLA_NUM_VF */\n\t       + rtnl_vfinfo_size(dev, ext_filter_mask) /* IFLA_VFINFO_LIST */\n\t       + rtnl_port_size(dev) /* IFLA_VF_PORTS + IFLA_PORT_SELF */\n\t       + rtnl_link_get_size(dev) /* IFLA_LINKINFO */\n\t       + rtnl_link_get_af_size(dev); /* IFLA_AF_SPEC */\n}\n\nstatic int rtnl_vf_ports_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct nlattr *vf_ports;\n\tstruct nlattr *vf_port;\n\tint vf;\n\tint err;\n\n\tvf_ports = nla_nest_start(skb, IFLA_VF_PORTS);\n\tif (!vf_ports)\n\t\treturn -EMSGSIZE;\n\n\tfor (vf = 0; vf < dev_num_vf(dev->dev.parent); vf++) {\n\t\tvf_port = nla_nest_start(skb, IFLA_VF_PORT);\n\t\tif (!vf_port)\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_PORT_VF, vf))\n\t\t\tgoto nla_put_failure;\n\t\terr = dev->netdev_ops->ndo_get_vf_port(dev, vf, skb);\n\t\tif (err == -EMSGSIZE)\n\t\t\tgoto nla_put_failure;\n\t\tif (err) {\n\t\t\tnla_nest_cancel(skb, vf_port);\n\t\t\tcontinue;\n\t\t}\n\t\tnla_nest_end(skb, vf_port);\n\t}\n\n\tnla_nest_end(skb, vf_ports);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, vf_ports);\n\treturn -EMSGSIZE;\n}\n\nstatic int rtnl_port_self_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct nlattr *port_self;\n\tint err;\n\n\tport_self = nla_nest_start(skb, IFLA_PORT_SELF);\n\tif (!port_self)\n\t\treturn -EMSGSIZE;\n\n\terr = dev->netdev_ops->ndo_get_vf_port(dev, PORT_SELF_VF, skb);\n\tif (err) {\n\t\tnla_nest_cancel(skb, port_self);\n\t\treturn (err == -EMSGSIZE) ? err : 0;\n\t}\n\n\tnla_nest_end(skb, port_self);\n\n\treturn 0;\n}\n\nstatic int rtnl_port_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tint err;\n\n\tif (!dev->netdev_ops->ndo_get_vf_port || !dev->dev.parent)\n\t\treturn 0;\n\n\terr = rtnl_port_self_fill(skb, dev);\n\tif (err)\n\t\treturn err;\n\n\tif (dev_num_vf(dev->dev.parent)) {\n\t\terr = rtnl_vf_ports_fill(skb, dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,\n\t\t\t    int type, u32 pid, u32 seq, u32 change,\n\t\t\t    unsigned int flags, u32 ext_filter_mask)\n{\n\tstruct ifinfomsg *ifm;\n\tstruct nlmsghdr *nlh;\n\tstruct rtnl_link_stats64 temp;\n\tconst struct rtnl_link_stats64 *stats;\n\tstruct nlattr *attr, *af_spec;\n\tstruct rtnl_af_ops *af_ops;\n\tstruct net_device *upper_dev = netdev_master_upper_dev_get(dev);\n\n\tASSERT_RTNL();\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ifm), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifi_family = AF_UNSPEC;\n\tifm->__ifi_pad = 0;\n\tifm->ifi_type = dev->type;\n\tifm->ifi_index = dev->ifindex;\n\tifm->ifi_flags = dev_get_flags(dev);\n\tifm->ifi_change = change;\n\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    nla_put_u32(skb, IFLA_TXQLEN, dev->tx_queue_len) ||\n\t    nla_put_u8(skb, IFLA_OPERSTATE,\n\t\t       netif_running(dev) ? dev->operstate : IF_OPER_DOWN) ||\n\t    nla_put_u8(skb, IFLA_LINKMODE, dev->link_mode) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    nla_put_u32(skb, IFLA_GROUP, dev->group) ||\n\t    nla_put_u32(skb, IFLA_PROMISCUITY, dev->promiscuity) ||\n\t    nla_put_u32(skb, IFLA_NUM_TX_QUEUES, dev->num_tx_queues) ||\n#ifdef CONFIG_RPS\n\t    nla_put_u32(skb, IFLA_NUM_RX_QUEUES, dev->num_rx_queues) ||\n#endif\n\t    (dev->ifindex != dev->iflink &&\n\t     nla_put_u32(skb, IFLA_LINK, dev->iflink)) ||\n\t    (upper_dev &&\n\t     nla_put_u32(skb, IFLA_MASTER, upper_dev->ifindex)) ||\n\t    nla_put_u8(skb, IFLA_CARRIER, netif_carrier_ok(dev)) ||\n\t    (dev->qdisc &&\n\t     nla_put_string(skb, IFLA_QDISC, dev->qdisc->ops->id)) ||\n\t    (dev->ifalias &&\n\t     nla_put_string(skb, IFLA_IFALIAS, dev->ifalias)))\n\t\tgoto nla_put_failure;\n\n\tif (1) {\n\t\tstruct rtnl_link_ifmap map = {\n\t\t\t.mem_start   = dev->mem_start,\n\t\t\t.mem_end     = dev->mem_end,\n\t\t\t.base_addr   = dev->base_addr,\n\t\t\t.irq         = dev->irq,\n\t\t\t.dma         = dev->dma,\n\t\t\t.port        = dev->if_port,\n\t\t};\n\t\tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (dev->addr_len) {\n\t\tif (nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr) ||\n\t\t    nla_put(skb, IFLA_BROADCAST, dev->addr_len, dev->broadcast))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tattr = nla_reserve(skb, IFLA_STATS,\n\t\t\tsizeof(struct rtnl_link_stats));\n\tif (attr == NULL)\n\t\tgoto nla_put_failure;\n\n\tstats = dev_get_stats(dev, &temp);\n\tcopy_rtnl_link_stats(nla_data(attr), stats);\n\n\tattr = nla_reserve(skb, IFLA_STATS64,\n\t\t\tsizeof(struct rtnl_link_stats64));\n\tif (attr == NULL)\n\t\tgoto nla_put_failure;\n\tcopy_rtnl_link_stats64(nla_data(attr), stats);\n\n\tif (dev->dev.parent && (ext_filter_mask & RTEXT_FILTER_VF) &&\n\t    nla_put_u32(skb, IFLA_NUM_VF, dev_num_vf(dev->dev.parent)))\n\t\tgoto nla_put_failure;\n\n\tif (dev->netdev_ops->ndo_get_vf_config && dev->dev.parent\n\t    && (ext_filter_mask & RTEXT_FILTER_VF)) {\n\t\tint i;\n\n\t\tstruct nlattr *vfinfo, *vf;\n\t\tint num_vfs = dev_num_vf(dev->dev.parent);\n\n\t\tvfinfo = nla_nest_start(skb, IFLA_VFINFO_LIST);\n\t\tif (!vfinfo)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < num_vfs; i++) {\n\t\t\tstruct ifla_vf_info ivi;\n\t\t\tstruct ifla_vf_mac vf_mac;\n\t\t\tstruct ifla_vf_vlan vf_vlan;\n\t\t\tstruct ifla_vf_tx_rate vf_tx_rate;\n\t\t\tstruct ifla_vf_spoofchk vf_spoofchk;\n\n\t\t\t/*\n\t\t\t * Not all SR-IOV capable drivers support the\n\t\t\t * spoofcheck query.  Preset to -1 so the user\n\t\t\t * space tool can detect that the driver didn't\n\t\t\t * report anything.\n\t\t\t */\n\t\t\tivi.spoofchk = -1;\n\t\t\tif (dev->netdev_ops->ndo_get_vf_config(dev, i, &ivi))\n\t\t\t\tbreak;\n\t\t\tvf_mac.vf =\n\t\t\t\tvf_vlan.vf =\n\t\t\t\tvf_tx_rate.vf =\n\t\t\t\tvf_spoofchk.vf = ivi.vf;\n\n\t\t\tmemcpy(vf_mac.mac, ivi.mac, sizeof(ivi.mac));\n\t\t\tvf_vlan.vlan = ivi.vlan;\n\t\t\tvf_vlan.qos = ivi.qos;\n\t\t\tvf_tx_rate.rate = ivi.tx_rate;\n\t\t\tvf_spoofchk.setting = ivi.spoofchk;\n\t\t\tvf = nla_nest_start(skb, IFLA_VF_INFO);\n\t\t\tif (!vf) {\n\t\t\t\tnla_nest_cancel(skb, vfinfo);\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tif (nla_put(skb, IFLA_VF_MAC, sizeof(vf_mac), &vf_mac) ||\n\t\t\t    nla_put(skb, IFLA_VF_VLAN, sizeof(vf_vlan), &vf_vlan) ||\n\t\t\t    nla_put(skb, IFLA_VF_TX_RATE, sizeof(vf_tx_rate),\n\t\t\t\t    &vf_tx_rate) ||\n\t\t\t    nla_put(skb, IFLA_VF_SPOOFCHK, sizeof(vf_spoofchk),\n\t\t\t\t    &vf_spoofchk))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(skb, vf);\n\t\t}\n\t\tnla_nest_end(skb, vfinfo);\n\t}\n\n\tif (rtnl_port_fill(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (dev->rtnl_link_ops) {\n\t\tif (rtnl_link_fill(skb, dev) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (!(af_spec = nla_nest_start(skb, IFLA_AF_SPEC)))\n\t\tgoto nla_put_failure;\n\n\tlist_for_each_entry(af_ops, &rtnl_af_ops, list) {\n\t\tif (af_ops->fill_link_af) {\n\t\t\tstruct nlattr *af;\n\t\t\tint err;\n\n\t\t\tif (!(af = nla_nest_start(skb, af_ops->family)))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\terr = af_ops->fill_link_af(skb, dev);\n\n\t\t\t/*\n\t\t\t * Caller may return ENODATA to indicate that there\n\t\t\t * was no data to be dumped. This is not an error, it\n\t\t\t * means we should trim the attribute header and\n\t\t\t * continue.\n\t\t\t */\n\t\t\tif (err == -ENODATA)\n\t\t\t\tnla_nest_cancel(skb, af);\n\t\t\telse if (err < 0)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, af);\n\t\t}\n\t}\n\n\tnla_nest_end(skb, af_spec);\n\n\treturn nlmsg_end(skb, nlh);\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int rtnl_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint h, s_h;\n\tint idx = 0, s_idx;\n\tstruct net_device *dev;\n\tstruct hlist_head *head;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\n\ts_h = cb->args[0];\n\ts_idx = cb->args[1];\n\n\trcu_read_lock();\n\tcb->seq = net->dev_base_seq;\n\n\tif (nlmsg_parse(cb->nlh, sizeof(struct rtgenmsg), tb, IFLA_MAX,\n\t\t\tifla_policy) >= 0) {\n\n\t\tif (tb[IFLA_EXT_MASK])\n\t\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\t}\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (rtnl_fill_ifinfo(skb, dev, RTM_NEWLINK,\n\t\t\t\t\t     NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t     cb->nlh->nlmsg_seq, 0,\n\t\t\t\t\t     NLM_F_MULTI,\n\t\t\t\t\t     ext_filter_mask) <= 0)\n\t\t\t\tgoto out;\n\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\tcb->args[1] = idx;\n\tcb->args[0] = h;\n\n\treturn skb->len;\n}\n\nconst struct nla_policy ifla_policy[IFLA_MAX+1] = {\n\t[IFLA_IFNAME]\t\t= { .type = NLA_STRING, .len = IFNAMSIZ-1 },\n\t[IFLA_ADDRESS]\t\t= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n\t[IFLA_BROADCAST]\t= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n\t[IFLA_MAP]\t\t= { .len = sizeof(struct rtnl_link_ifmap) },\n\t[IFLA_MTU]\t\t= { .type = NLA_U32 },\n\t[IFLA_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_MASTER]\t\t= { .type = NLA_U32 },\n\t[IFLA_CARRIER]\t\t= { .type = NLA_U8 },\n\t[IFLA_TXQLEN]\t\t= { .type = NLA_U32 },\n\t[IFLA_WEIGHT]\t\t= { .type = NLA_U32 },\n\t[IFLA_OPERSTATE]\t= { .type = NLA_U8 },\n\t[IFLA_LINKMODE]\t\t= { .type = NLA_U8 },\n\t[IFLA_LINKINFO]\t\t= { .type = NLA_NESTED },\n\t[IFLA_NET_NS_PID]\t= { .type = NLA_U32 },\n\t[IFLA_NET_NS_FD]\t= { .type = NLA_U32 },\n\t[IFLA_IFALIAS]\t        = { .type = NLA_STRING, .len = IFALIASZ-1 },\n\t[IFLA_VFINFO_LIST]\t= {. type = NLA_NESTED },\n\t[IFLA_VF_PORTS]\t\t= { .type = NLA_NESTED },\n\t[IFLA_PORT_SELF]\t= { .type = NLA_NESTED },\n\t[IFLA_AF_SPEC]\t\t= { .type = NLA_NESTED },\n\t[IFLA_EXT_MASK]\t\t= { .type = NLA_U32 },\n\t[IFLA_PROMISCUITY]\t= { .type = NLA_U32 },\n\t[IFLA_NUM_TX_QUEUES]\t= { .type = NLA_U32 },\n\t[IFLA_NUM_RX_QUEUES]\t= { .type = NLA_U32 },\n};\nEXPORT_SYMBOL(ifla_policy);\n\nstatic const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {\n\t[IFLA_INFO_KIND]\t= { .type = NLA_STRING },\n\t[IFLA_INFO_DATA]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy ifla_vfinfo_policy[IFLA_VF_INFO_MAX+1] = {\n\t[IFLA_VF_INFO]\t\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {\n\t[IFLA_VF_MAC]\t\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_vf_mac) },\n\t[IFLA_VF_VLAN]\t\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_vf_vlan) },\n\t[IFLA_VF_TX_RATE]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_vf_tx_rate) },\n\t[IFLA_VF_SPOOFCHK]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_vf_spoofchk) },\n};\n\nstatic const struct nla_policy ifla_port_policy[IFLA_PORT_MAX+1] = {\n\t[IFLA_PORT_VF]\t\t= { .type = NLA_U32 },\n\t[IFLA_PORT_PROFILE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = PORT_PROFILE_MAX },\n\t[IFLA_PORT_VSI_TYPE]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_port_vsi)},\n\t[IFLA_PORT_INSTANCE_UUID] = { .type = NLA_BINARY,\n\t\t\t\t      .len = PORT_UUID_MAX },\n\t[IFLA_PORT_HOST_UUID]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = PORT_UUID_MAX },\n\t[IFLA_PORT_REQUEST]\t= { .type = NLA_U8, },\n\t[IFLA_PORT_RESPONSE]\t= { .type = NLA_U16, },\n};\n\nstruct net *rtnl_link_get_net(struct net *src_net, struct nlattr *tb[])\n{\n\tstruct net *net;\n\t/* Examine the link attributes and figure out which\n\t * network namespace we are talking about.\n\t */\n\tif (tb[IFLA_NET_NS_PID])\n\t\tnet = get_net_ns_by_pid(nla_get_u32(tb[IFLA_NET_NS_PID]));\n\telse if (tb[IFLA_NET_NS_FD])\n\t\tnet = get_net_ns_by_fd(nla_get_u32(tb[IFLA_NET_NS_FD]));\n\telse\n\t\tnet = get_net(src_net);\n\treturn net;\n}\nEXPORT_SYMBOL(rtnl_link_get_net);\n\nstatic int validate_linkmsg(struct net_device *dev, struct nlattr *tb[])\n{\n\tif (dev) {\n\t\tif (tb[IFLA_ADDRESS] &&\n\t\t    nla_len(tb[IFLA_ADDRESS]) < dev->addr_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (tb[IFLA_BROADCAST] &&\n\t\t    nla_len(tb[IFLA_BROADCAST]) < dev->addr_len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[IFLA_AF_SPEC]) {\n\t\tstruct nlattr *af;\n\t\tint rem, err;\n\n\t\tnla_for_each_nested(af, tb[IFLA_AF_SPEC], rem) {\n\t\t\tconst struct rtnl_af_ops *af_ops;\n\n\t\t\tif (!(af_ops = rtnl_af_lookup(nla_type(af))))\n\t\t\t\treturn -EAFNOSUPPORT;\n\n\t\t\tif (!af_ops->set_link_af)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tif (af_ops->validate_link_af) {\n\t\t\t\terr = af_ops->validate_link_af(dev, af);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int do_setvfinfo(struct net_device *dev, struct nlattr *attr)\n{\n\tint rem, err = -EINVAL;\n\tstruct nlattr *vf;\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tnla_for_each_nested(vf, attr, rem) {\n\t\tswitch (nla_type(vf)) {\n\t\tcase IFLA_VF_MAC: {\n\t\t\tstruct ifla_vf_mac *ivm;\n\t\t\tivm = nla_data(vf);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tif (ops->ndo_set_vf_mac)\n\t\t\t\terr = ops->ndo_set_vf_mac(dev, ivm->vf,\n\t\t\t\t\t\t\t  ivm->mac);\n\t\t\tbreak;\n\t\t}\n\t\tcase IFLA_VF_VLAN: {\n\t\t\tstruct ifla_vf_vlan *ivv;\n\t\t\tivv = nla_data(vf);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tif (ops->ndo_set_vf_vlan)\n\t\t\t\terr = ops->ndo_set_vf_vlan(dev, ivv->vf,\n\t\t\t\t\t\t\t   ivv->vlan,\n\t\t\t\t\t\t\t   ivv->qos);\n\t\t\tbreak;\n\t\t}\n\t\tcase IFLA_VF_TX_RATE: {\n\t\t\tstruct ifla_vf_tx_rate *ivt;\n\t\t\tivt = nla_data(vf);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tif (ops->ndo_set_vf_tx_rate)\n\t\t\t\terr = ops->ndo_set_vf_tx_rate(dev, ivt->vf,\n\t\t\t\t\t\t\t      ivt->rate);\n\t\t\tbreak;\n\t\t}\n\t\tcase IFLA_VF_SPOOFCHK: {\n\t\t\tstruct ifla_vf_spoofchk *ivs;\n\t\t\tivs = nla_data(vf);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tif (ops->ndo_set_vf_spoofchk)\n\t\t\t\terr = ops->ndo_set_vf_spoofchk(dev, ivs->vf,\n\t\t\t\t\t\t\t       ivs->setting);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic int do_set_master(struct net_device *dev, int ifindex)\n{\n\tstruct net_device *upper_dev = netdev_master_upper_dev_get(dev);\n\tconst struct net_device_ops *ops;\n\tint err;\n\n\tif (upper_dev) {\n\t\tif (upper_dev->ifindex == ifindex)\n\t\t\treturn 0;\n\t\tops = upper_dev->netdev_ops;\n\t\tif (ops->ndo_del_slave) {\n\t\t\terr = ops->ndo_del_slave(upper_dev, dev);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (ifindex) {\n\t\tupper_dev = __dev_get_by_index(dev_net(dev), ifindex);\n\t\tif (!upper_dev)\n\t\t\treturn -EINVAL;\n\t\tops = upper_dev->netdev_ops;\n\t\tif (ops->ndo_add_slave) {\n\t\t\terr = ops->ndo_add_slave(upper_dev, dev);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int do_setlink(struct net_device *dev, struct ifinfomsg *ifm,\n\t\t      struct nlattr **tb, char *ifname, int modified)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tint err;\n\n\tif (tb[IFLA_NET_NS_PID] || tb[IFLA_NET_NS_FD]) {\n\t\tstruct net *net = rtnl_link_get_net(dev_net(dev), tb);\n\t\tif (IS_ERR(net)) {\n\t\t\terr = PTR_ERR(net);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto errout;\n\t\t}\n\t\terr = dev_change_net_namespace(dev, net, ifname);\n\t\tput_net(net);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_MAP]) {\n\t\tstruct rtnl_link_ifmap *u_map;\n\t\tstruct ifmap k_map;\n\n\t\tif (!ops->ndo_set_config) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (!netif_device_present(dev)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tu_map = nla_data(tb[IFLA_MAP]);\n\t\tk_map.mem_start = (unsigned long) u_map->mem_start;\n\t\tk_map.mem_end = (unsigned long) u_map->mem_end;\n\t\tk_map.base_addr = (unsigned short) u_map->base_addr;\n\t\tk_map.irq = (unsigned char) u_map->irq;\n\t\tk_map.dma = (unsigned char) u_map->dma;\n\t\tk_map.port = (unsigned char) u_map->port;\n\n\t\terr = ops->ndo_set_config(dev, &k_map);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_ADDRESS]) {\n\t\tstruct sockaddr *sa;\n\t\tint len;\n\n\t\tlen = sizeof(sa_family_t) + dev->addr_len;\n\t\tsa = kmalloc(len, GFP_KERNEL);\n\t\tif (!sa) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout;\n\t\t}\n\t\tsa->sa_family = dev->type;\n\t\tmemcpy(sa->sa_data, nla_data(tb[IFLA_ADDRESS]),\n\t\t       dev->addr_len);\n\t\terr = dev_set_mac_address(dev, sa);\n\t\tkfree(sa);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_MTU]) {\n\t\terr = dev_set_mtu(dev, nla_get_u32(tb[IFLA_MTU]));\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_GROUP]) {\n\t\tdev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));\n\t\tmodified = 1;\n\t}\n\n\t/*\n\t * Interface selected by interface index but interface\n\t * name provided implies that a name change has been\n\t * requested.\n\t */\n\tif (ifm->ifi_index > 0 && ifname[0]) {\n\t\terr = dev_change_name(dev, ifname);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_IFALIAS]) {\n\t\terr = dev_set_alias(dev, nla_data(tb[IFLA_IFALIAS]),\n\t\t\t\t    nla_len(tb[IFLA_IFALIAS]));\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_BROADCAST]) {\n\t\tnla_memcpy(dev->broadcast, tb[IFLA_BROADCAST], dev->addr_len);\n\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\n\t}\n\n\tif (ifm->ifi_flags || ifm->ifi_change) {\n\t\terr = dev_change_flags(dev, rtnl_dev_combine_flags(dev, ifm));\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif (tb[IFLA_MASTER]) {\n\t\terr = do_set_master(dev, nla_get_u32(tb[IFLA_MASTER]));\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_CARRIER]) {\n\t\terr = dev_change_carrier(dev, nla_get_u8(tb[IFLA_CARRIER]));\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_TXQLEN])\n\t\tdev->tx_queue_len = nla_get_u32(tb[IFLA_TXQLEN]);\n\n\tif (tb[IFLA_OPERSTATE])\n\t\tset_operstate(dev, nla_get_u8(tb[IFLA_OPERSTATE]));\n\n\tif (tb[IFLA_LINKMODE]) {\n\t\twrite_lock_bh(&dev_base_lock);\n\t\tdev->link_mode = nla_get_u8(tb[IFLA_LINKMODE]);\n\t\twrite_unlock_bh(&dev_base_lock);\n\t}\n\n\tif (tb[IFLA_VFINFO_LIST]) {\n\t\tstruct nlattr *attr;\n\t\tint rem;\n\t\tnla_for_each_nested(attr, tb[IFLA_VFINFO_LIST], rem) {\n\t\t\tif (nla_type(attr) != IFLA_VF_INFO) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\terr = do_setvfinfo(dev, attr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tmodified = 1;\n\t\t}\n\t}\n\terr = 0;\n\n\tif (tb[IFLA_VF_PORTS]) {\n\t\tstruct nlattr *port[IFLA_PORT_MAX+1];\n\t\tstruct nlattr *attr;\n\t\tint vf;\n\t\tint rem;\n\n\t\terr = -EOPNOTSUPP;\n\t\tif (!ops->ndo_set_vf_port)\n\t\t\tgoto errout;\n\n\t\tnla_for_each_nested(attr, tb[IFLA_VF_PORTS], rem) {\n\t\t\tif (nla_type(attr) != IFLA_VF_PORT)\n\t\t\t\tcontinue;\n\t\t\terr = nla_parse_nested(port, IFLA_PORT_MAX,\n\t\t\t\tattr, ifla_port_policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tif (!port[IFLA_PORT_VF]) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tvf = nla_get_u32(port[IFLA_PORT_VF]);\n\t\t\terr = ops->ndo_set_vf_port(dev, vf, port);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tmodified = 1;\n\t\t}\n\t}\n\terr = 0;\n\n\tif (tb[IFLA_PORT_SELF]) {\n\t\tstruct nlattr *port[IFLA_PORT_MAX+1];\n\n\t\terr = nla_parse_nested(port, IFLA_PORT_MAX,\n\t\t\ttb[IFLA_PORT_SELF], ifla_port_policy);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_port)\n\t\t\terr = ops->ndo_set_vf_port(dev, PORT_SELF_VF, port);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_AF_SPEC]) {\n\t\tstruct nlattr *af;\n\t\tint rem;\n\n\t\tnla_for_each_nested(af, tb[IFLA_AF_SPEC], rem) {\n\t\t\tconst struct rtnl_af_ops *af_ops;\n\n\t\t\tif (!(af_ops = rtnl_af_lookup(nla_type(af))))\n\t\t\t\tBUG();\n\n\t\t\terr = af_ops->set_link_af(dev, af);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\n\t\t\tmodified = 1;\n\t\t}\n\t}\n\terr = 0;\n\nerrout:\n\tif (err < 0 && modified)\n\t\tnet_warn_ratelimited(\"A link change request failed with some changes committed already. Interface %s may have been left with an inconsistent configuration, please check.\\n\",\n\t\t\t\t     dev->name);\n\n\treturn err;\n}\n\nstatic int rtnl_setlink(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tint err;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tchar ifname[IFNAMSIZ];\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tifname[0] = '\\0';\n\n\terr = -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME])\n\t\tdev = __dev_get_by_name(net, ifname);\n\telse\n\t\tgoto errout;\n\n\tif (dev == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto errout;\n\t}\n\n\terr = validate_linkmsg(dev, tb);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = do_setlink(dev, ifm, tb, ifname, 0);\nerrout:\n\treturn err;\n}\n\nstatic int rtnl_dellink(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct rtnl_link_ops *ops;\n\tstruct net_device *dev;\n\tstruct ifinfomsg *ifm;\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tint err;\n\tLIST_HEAD(list_kill);\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME])\n\t\tdev = __dev_get_by_name(net, ifname);\n\telse\n\t\treturn -EINVAL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tops = dev->rtnl_link_ops;\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tops->dellink(dev, &list_kill);\n\tunregister_netdevice_many(&list_kill);\n\tlist_del(&list_kill);\n\treturn 0;\n}\n\nint rtnl_configure_link(struct net_device *dev, const struct ifinfomsg *ifm)\n{\n\tunsigned int old_flags;\n\tint err;\n\n\told_flags = dev->flags;\n\tif (ifm && (ifm->ifi_flags || ifm->ifi_change)) {\n\t\terr = __dev_change_flags(dev, rtnl_dev_combine_flags(dev, ifm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tdev->rtnl_link_state = RTNL_LINK_INITIALIZED;\n\trtmsg_ifinfo(RTM_NEWLINK, dev, ~0U);\n\n\t__dev_notify_flags(dev, old_flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(rtnl_configure_link);\n\nstruct net_device *rtnl_create_link(struct net *net,\n\tchar *ifname, const struct rtnl_link_ops *ops, struct nlattr *tb[])\n{\n\tint err;\n\tstruct net_device *dev;\n\tunsigned int num_tx_queues = 1;\n\tunsigned int num_rx_queues = 1;\n\n\tif (tb[IFLA_NUM_TX_QUEUES])\n\t\tnum_tx_queues = nla_get_u32(tb[IFLA_NUM_TX_QUEUES]);\n\telse if (ops->get_num_tx_queues)\n\t\tnum_tx_queues = ops->get_num_tx_queues();\n\n\tif (tb[IFLA_NUM_RX_QUEUES])\n\t\tnum_rx_queues = nla_get_u32(tb[IFLA_NUM_RX_QUEUES]);\n\telse if (ops->get_num_rx_queues)\n\t\tnum_rx_queues = ops->get_num_rx_queues();\n\n\terr = -ENOMEM;\n\tdev = alloc_netdev_mqs(ops->priv_size, ifname, ops->setup,\n\t\t\t       num_tx_queues, num_rx_queues);\n\tif (!dev)\n\t\tgoto err;\n\n\tdev_net_set(dev, net);\n\tdev->rtnl_link_ops = ops;\n\tdev->rtnl_link_state = RTNL_LINK_INITIALIZING;\n\n\tif (tb[IFLA_MTU])\n\t\tdev->mtu = nla_get_u32(tb[IFLA_MTU]);\n\tif (tb[IFLA_ADDRESS]) {\n\t\tmemcpy(dev->dev_addr, nla_data(tb[IFLA_ADDRESS]),\n\t\t\t\tnla_len(tb[IFLA_ADDRESS]));\n\t\tdev->addr_assign_type = NET_ADDR_SET;\n\t}\n\tif (tb[IFLA_BROADCAST])\n\t\tmemcpy(dev->broadcast, nla_data(tb[IFLA_BROADCAST]),\n\t\t\t\tnla_len(tb[IFLA_BROADCAST]));\n\tif (tb[IFLA_TXQLEN])\n\t\tdev->tx_queue_len = nla_get_u32(tb[IFLA_TXQLEN]);\n\tif (tb[IFLA_OPERSTATE])\n\t\tset_operstate(dev, nla_get_u8(tb[IFLA_OPERSTATE]));\n\tif (tb[IFLA_LINKMODE])\n\t\tdev->link_mode = nla_get_u8(tb[IFLA_LINKMODE]);\n\tif (tb[IFLA_GROUP])\n\t\tdev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));\n\n\treturn dev;\n\nerr:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(rtnl_create_link);\n\nstatic int rtnl_group_changelink(struct net *net, int group,\n\t\tstruct ifinfomsg *ifm,\n\t\tstruct nlattr **tb)\n{\n\tstruct net_device *dev;\n\tint err;\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\terr = do_setlink(dev, ifm, tb, NULL, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_newlink(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct rtnl_link_ops *ops;\n\tstruct net_device *dev;\n\tstruct ifinfomsg *ifm;\n\tchar kind[MODULE_NAME_LEN];\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tstruct nlattr *linkinfo[IFLA_INFO_MAX+1];\n\tint err;\n\n#ifdef CONFIG_MODULES\nreplay:\n#endif\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tifname[0] = '\\0';\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse {\n\t\tif (ifname[0])\n\t\t\tdev = __dev_get_by_name(net, ifname);\n\t\telse\n\t\t\tdev = NULL;\n\t}\n\n\terr = validate_linkmsg(dev, tb);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_LINKINFO]) {\n\t\terr = nla_parse_nested(linkinfo, IFLA_INFO_MAX,\n\t\t\t\t       tb[IFLA_LINKINFO], ifla_info_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else\n\t\tmemset(linkinfo, 0, sizeof(linkinfo));\n\n\tif (linkinfo[IFLA_INFO_KIND]) {\n\t\tnla_strlcpy(kind, linkinfo[IFLA_INFO_KIND], sizeof(kind));\n\t\tops = rtnl_link_ops_get(kind);\n\t} else {\n\t\tkind[0] = '\\0';\n\t\tops = NULL;\n\t}\n\n\tif (1) {\n\t\tstruct nlattr *attr[ops ? ops->maxtype + 1 : 0], **data = NULL;\n\t\tstruct net *dest_net;\n\n\t\tif (ops) {\n\t\t\tif (ops->maxtype && linkinfo[IFLA_INFO_DATA]) {\n\t\t\t\terr = nla_parse_nested(attr, ops->maxtype,\n\t\t\t\t\t\t       linkinfo[IFLA_INFO_DATA],\n\t\t\t\t\t\t       ops->policy);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\tdata = attr;\n\t\t\t}\n\t\t\tif (ops->validate) {\n\t\t\t\terr = ops->validate(tb, data);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tif (dev) {\n\t\t\tint modified = 0;\n\n\t\t\tif (nlh->nlmsg_flags & NLM_F_EXCL)\n\t\t\t\treturn -EEXIST;\n\t\t\tif (nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tif (linkinfo[IFLA_INFO_DATA]) {\n\t\t\t\tif (!ops || ops != dev->rtnl_link_ops ||\n\t\t\t\t    !ops->changelink)\n\t\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\t\terr = ops->changelink(dev, tb, data);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\tmodified = 1;\n\t\t\t}\n\n\t\t\treturn do_setlink(dev, ifm, tb, ifname, modified);\n\t\t}\n\n\t\tif (!(nlh->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tif (ifm->ifi_index == 0 && tb[IFLA_GROUP])\n\t\t\t\treturn rtnl_group_changelink(net,\n\t\t\t\t\t\tnla_get_u32(tb[IFLA_GROUP]),\n\t\t\t\t\t\tifm, tb);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (tb[IFLA_MAP] || tb[IFLA_MASTER] || tb[IFLA_PROTINFO])\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (!ops) {\n#ifdef CONFIG_MODULES\n\t\t\tif (kind[0]) {\n\t\t\t\t__rtnl_unlock();\n\t\t\t\trequest_module(\"rtnl-link-%s\", kind);\n\t\t\t\trtnl_lock();\n\t\t\t\tops = rtnl_link_ops_get(kind);\n\t\t\t\tif (ops)\n\t\t\t\t\tgoto replay;\n\t\t\t}\n#endif\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (!ifname[0])\n\t\t\tsnprintf(ifname, IFNAMSIZ, \"%s%%d\", ops->kind);\n\n\t\tdest_net = rtnl_link_get_net(net, tb);\n\t\tif (IS_ERR(dest_net))\n\t\t\treturn PTR_ERR(dest_net);\n\n\t\tdev = rtnl_create_link(dest_net, ifname, ops, tb);\n\t\tif (IS_ERR(dev)) {\n\t\t\terr = PTR_ERR(dev);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdev->ifindex = ifm->ifi_index;\n\n\t\tif (ops->newlink)\n\t\t\terr = ops->newlink(net, dev, tb, data);\n\t\telse\n\t\t\terr = register_netdevice(dev);\n\n\t\tif (err < 0 && !IS_ERR(dev))\n\t\t\tfree_netdev(dev);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\terr = rtnl_configure_link(dev, ifm);\n\t\tif (err < 0)\n\t\t\tunregister_netdevice(dev);\nout:\n\t\tput_net(dest_net);\n\t\treturn err;\n\t}\n}\n\nstatic int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tstruct net_device *dev = NULL;\n\tstruct sk_buff *nskb;\n\tint err;\n\tu32 ext_filter_mask = 0;\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\n\tif (tb[IFLA_EXT_MASK])\n\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME])\n\t\tdev = __dev_get_by_name(net, ifname);\n\telse\n\t\treturn -EINVAL;\n\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tnskb = nlmsg_new(if_nlmsg_size(dev, ext_filter_mask), GFP_KERNEL);\n\tif (nskb == NULL)\n\t\treturn -ENOBUFS;\n\n\terr = rtnl_fill_ifinfo(nskb, dev, RTM_NEWLINK, NETLINK_CB(skb).portid,\n\t\t\t       nlh->nlmsg_seq, 0, 0, ext_filter_mask);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in if_nlmsg_size */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(nskb);\n\t} else\n\t\terr = rtnl_unicast(nskb, net, NETLINK_CB(skb).portid);\n\n\treturn err;\n}\n\nstatic u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\tu16 min_ifinfo_dump_size = 0;\n\n\tif (nlmsg_parse(nlh, sizeof(struct rtgenmsg), tb, IFLA_MAX,\n\t\t\tifla_policy) >= 0) {\n\t\tif (tb[IFLA_EXT_MASK])\n\t\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\t}\n\n\tif (!ext_filter_mask)\n\t\treturn NLMSG_GOODSIZE;\n\t/*\n\t * traverse the list of net devices and compute the minimum\n\t * buffer size based upon the filter mask.\n\t */\n\tlist_for_each_entry(dev, &net->dev_base_head, dev_list) {\n\t\tmin_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,\n\t\t\t\t\t     if_nlmsg_size(dev,\n\t\t\t\t\t\t           ext_filter_mask));\n\t}\n\n\treturn min_ifinfo_dump_size;\n}\n\nstatic int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx;\n\tint s_idx = cb->family;\n\n\tif (s_idx == 0)\n\t\ts_idx = 1;\n\tfor (idx = 1; idx <= RTNL_FAMILY_MAX; idx++) {\n\t\tint type = cb->nlh->nlmsg_type-RTM_BASE;\n\t\tif (idx < s_idx || idx == PF_PACKET)\n\t\t\tcontinue;\n\t\tif (rtnl_msg_handlers[idx] == NULL ||\n\t\t    rtnl_msg_handlers[idx][type].dumpit == NULL)\n\t\t\tcontinue;\n\t\tif (idx > s_idx)\n\t\t\tmemset(&cb->args[0], 0, sizeof(cb->args));\n\t\tif (rtnl_msg_handlers[idx][type].dumpit(skb, cb))\n\t\t\tbreak;\n\t}\n\tcb->family = idx;\n\n\treturn skb->len;\n}\n\nvoid rtmsg_ifinfo(int type, struct net_device *dev, unsigned int change)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\tsize_t if_info_size;\n\n\tskb = nlmsg_new((if_info_size = if_nlmsg_size(dev, 0)), GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = rtnl_fill_ifinfo(skb, dev, type, 0, 0, change, 0, 0);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in if_nlmsg_size() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_KERNEL);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n}\nEXPORT_SYMBOL(rtmsg_ifinfo);\n\nstatic int nlmsg_populate_fdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   u8 *addr, u32 pid, u32 seq,\n\t\t\t\t   int type, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ndmsg *ndm;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ndm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tndm = nlmsg_data(nlh);\n\tndm->ndm_family  = AF_BRIDGE;\n\tndm->ndm_pad1\t = 0;\n\tndm->ndm_pad2    = 0;\n\tndm->ndm_flags\t = flags;\n\tndm->ndm_type\t = 0;\n\tndm->ndm_ifindex = dev->ifindex;\n\tndm->ndm_state   = NUD_PERMANENT;\n\n\tif (nla_put(skb, NDA_LLADDR, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\treturn nlmsg_end(skb, nlh);\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic inline size_t rtnl_fdb_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ndmsg)) + nla_total_size(ETH_ALEN);\n}\n\nstatic void rtnl_fdb_notify(struct net_device *dev, u8 *addr, int type)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(rtnl_fdb_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nlmsg_populate_fdb_fill(skb, dev, addr, 0, 0, type, NTF_SELF);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_NEIGH, err);\n}\n\nstatic int rtnl_fdb_add(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ndmsg *ndm;\n\tstruct nlattr *tb[NDA_MAX+1];\n\tstruct net_device *dev;\n\tu8 *addr;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*ndm), tb, NDA_MAX, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_ifindex == 0) {\n\t\tpr_info(\"PF_BRIDGE: RTM_NEWNEIGH with invalid ifindex\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\tif (dev == NULL) {\n\t\tpr_info(\"PF_BRIDGE: RTM_NEWNEIGH with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!tb[NDA_LLADDR] || nla_len(tb[NDA_LLADDR]) != ETH_ALEN) {\n\t\tpr_info(\"PF_BRIDGE: RTM_NEWNEIGH with invalid address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = nla_data(tb[NDA_LLADDR]);\n\tif (!is_valid_ether_addr(addr)) {\n\t\tpr_info(\"PF_BRIDGE: RTM_NEWNEIGH with invalid ether address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = -EOPNOTSUPP;\n\n\t/* Support fdb on master device the net/bridge default case */\n\tif ((!ndm->ndm_flags || ndm->ndm_flags & NTF_MASTER) &&\n\t    (dev->priv_flags & IFF_BRIDGE_PORT)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\t\tconst struct net_device_ops *ops = br_dev->netdev_ops;\n\n\t\terr = ops->ndo_fdb_add(ndm, tb, dev, addr, nlh->nlmsg_flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t\telse\n\t\t\tndm->ndm_flags &= ~NTF_MASTER;\n\t}\n\n\t/* Embedded bridge, macvlan, and any other device support */\n\tif ((ndm->ndm_flags & NTF_SELF) && dev->netdev_ops->ndo_fdb_add) {\n\t\terr = dev->netdev_ops->ndo_fdb_add(ndm, tb,\n\t\t\t\t\t\t   dev, addr,\n\t\t\t\t\t\t   nlh->nlmsg_flags);\n\n\t\tif (!err) {\n\t\t\trtnl_fdb_notify(dev, addr, RTM_NEWNEIGH);\n\t\t\tndm->ndm_flags &= ~NTF_SELF;\n\t\t}\n\t}\nout:\n\treturn err;\n}\n\nstatic int rtnl_fdb_del(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ndmsg *ndm;\n\tstruct nlattr *tb[NDA_MAX+1];\n\tstruct net_device *dev;\n\tint err = -EINVAL;\n\t__u8 *addr;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\terr = nlmsg_parse(nlh, sizeof(*ndm), tb, NDA_MAX, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_ifindex == 0) {\n\t\tpr_info(\"PF_BRIDGE: RTM_DELNEIGH with invalid ifindex\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\tif (dev == NULL) {\n\t\tpr_info(\"PF_BRIDGE: RTM_DELNEIGH with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!tb[NDA_LLADDR] || nla_len(tb[NDA_LLADDR]) != ETH_ALEN) {\n\t\tpr_info(\"PF_BRIDGE: RTM_DELNEIGH with invalid address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = nla_data(tb[NDA_LLADDR]);\n\tif (!is_valid_ether_addr(addr)) {\n\t\tpr_info(\"PF_BRIDGE: RTM_DELNEIGH with invalid ether address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = -EOPNOTSUPP;\n\n\t/* Support fdb on master device the net/bridge default case */\n\tif ((!ndm->ndm_flags || ndm->ndm_flags & NTF_MASTER) &&\n\t    (dev->priv_flags & IFF_BRIDGE_PORT)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\t\tconst struct net_device_ops *ops = br_dev->netdev_ops;\n\n\t\tif (ops->ndo_fdb_del)\n\t\t\terr = ops->ndo_fdb_del(ndm, tb, dev, addr);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t\telse\n\t\t\tndm->ndm_flags &= ~NTF_MASTER;\n\t}\n\n\t/* Embedded bridge, macvlan, and any other device support */\n\tif ((ndm->ndm_flags & NTF_SELF) && dev->netdev_ops->ndo_fdb_del) {\n\t\terr = dev->netdev_ops->ndo_fdb_del(ndm, tb, dev, addr);\n\n\t\tif (!err) {\n\t\t\trtnl_fdb_notify(dev, addr, RTM_DELNEIGH);\n\t\t\tndm->ndm_flags &= ~NTF_SELF;\n\t\t}\n\t}\nout:\n\treturn err;\n}\n\nstatic int nlmsg_populate_fdb(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb,\n\t\t\t      struct net_device *dev,\n\t\t\t      int *idx,\n\t\t\t      struct netdev_hw_addr_list *list)\n{\n\tstruct netdev_hw_addr *ha;\n\tint err;\n\tu32 portid, seq;\n\n\tportid = NETLINK_CB(cb->skb).portid;\n\tseq = cb->nlh->nlmsg_seq;\n\n\tlist_for_each_entry(ha, &list->list, list) {\n\t\tif (*idx < cb->args[0])\n\t\t\tgoto skip;\n\n\t\terr = nlmsg_populate_fdb_fill(skb, dev, ha->addr,\n\t\t\t\t\t      portid, seq,\n\t\t\t\t\t      RTM_NEWNEIGH, NTF_SELF);\n\t\tif (err < 0)\n\t\t\treturn err;\nskip:\n\t\t*idx += 1;\n\t}\n\treturn 0;\n}\n\n/**\n * ndo_dflt_fdb_dump - default netdevice operation to dump an FDB table.\n * @nlh: netlink message header\n * @dev: netdevice\n *\n * Default netdevice operation to dump the existing unicast address list.\n * Returns zero on success.\n */\nint ndo_dflt_fdb_dump(struct sk_buff *skb,\n\t\t      struct netlink_callback *cb,\n\t\t      struct net_device *dev,\n\t\t      int idx)\n{\n\tint err;\n\n\tnetif_addr_lock_bh(dev);\n\terr = nlmsg_populate_fdb(skb, cb, dev, &idx, &dev->uc);\n\tif (err)\n\t\tgoto out;\n\tnlmsg_populate_fdb(skb, cb, dev, &idx, &dev->mc);\nout:\n\tnetif_addr_unlock_bh(dev);\n\treturn idx;\n}\nEXPORT_SYMBOL(ndo_dflt_fdb_dump);\n\nstatic int rtnl_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_BRIDGE_PORT) {\n\t\t\tstruct net_device *br_dev;\n\t\t\tconst struct net_device_ops *ops;\n\n\t\t\tbr_dev = netdev_master_upper_dev_get(dev);\n\t\t\tops = br_dev->netdev_ops;\n\t\t\tif (ops->ndo_fdb_dump)\n\t\t\t\tidx = ops->ndo_fdb_dump(skb, cb, dev, idx);\n\t\t}\n\n\t\tif (dev->netdev_ops->ndo_fdb_dump)\n\t\t\tidx = dev->netdev_ops->ndo_fdb_dump(skb, cb, dev, idx);\n\t}\n\trcu_read_unlock();\n\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nint ndo_dflt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t    struct net_device *dev, u16 mode)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ifinfomsg *ifm;\n\tstruct nlattr *br_afspec;\n\tu8 operstate = netif_running(dev) ? dev->operstate : IF_OPER_DOWN;\n\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\tnlh = nlmsg_put(skb, pid, seq, RTM_NEWLINK, sizeof(*ifm), NLM_F_MULTI);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifi_family = AF_BRIDGE;\n\tifm->__ifi_pad = 0;\n\tifm->ifi_type = dev->type;\n\tifm->ifi_index = dev->ifindex;\n\tifm->ifi_flags = dev_get_flags(dev);\n\tifm->ifi_change = 0;\n\n\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    nla_put_u8(skb, IFLA_OPERSTATE, operstate) ||\n\t    (br_dev &&\n\t     nla_put_u32(skb, IFLA_MASTER, br_dev->ifindex)) ||\n\t    (dev->addr_len &&\n\t     nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||\n\t    (dev->ifindex != dev->iflink &&\n\t     nla_put_u32(skb, IFLA_LINK, dev->iflink)))\n\t\tgoto nla_put_failure;\n\n\tbr_afspec = nla_nest_start(skb, IFLA_AF_SPEC);\n\tif (!br_afspec)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, IFLA_BRIDGE_FLAGS, BRIDGE_FLAGS_SELF) ||\n\t    nla_put_u16(skb, IFLA_BRIDGE_MODE, mode)) {\n\t\tnla_nest_cancel(skb, br_afspec);\n\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, br_afspec);\n\n\treturn nlmsg_end(skb, nlh);\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL(ndo_dflt_bridge_getlink);\n\nstatic int rtnl_bridge_getlink(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tint idx = 0;\n\tu32 portid = NETLINK_CB(cb->skb).portid;\n\tu32 seq = cb->nlh->nlmsg_seq;\n\tstruct nlattr *extfilt;\n\tu32 filter_mask = 0;\n\n\textfilt = nlmsg_find_attr(cb->nlh, sizeof(struct rtgenmsg),\n\t\t\t\t  IFLA_EXT_MASK);\n\tif (extfilt)\n\t\tfilter_mask = nla_get_u32(extfilt);\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tconst struct net_device_ops *ops = dev->netdev_ops;\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (br_dev && br_dev->netdev_ops->ndo_bridge_getlink) {\n\t\t\tif (idx >= cb->args[0] &&\n\t\t\t    br_dev->netdev_ops->ndo_bridge_getlink(\n\t\t\t\t    skb, portid, seq, dev, filter_mask) < 0)\n\t\t\t\tbreak;\n\t\t\tidx++;\n\t\t}\n\n\t\tif (ops->ndo_bridge_getlink) {\n\t\t\tif (idx >= cb->args[0] &&\n\t\t\t    ops->ndo_bridge_getlink(skb, portid, seq, dev,\n\t\t\t\t\t\t    filter_mask) < 0)\n\t\t\t\tbreak;\n\t\t\tidx++;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\n\treturn skb->len;\n}\n\nstatic inline size_t bridge_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t\t+ nla_total_size(IFNAMSIZ)\t/* IFLA_IFNAME */\n\t\t+ nla_total_size(MAX_ADDR_LEN)\t/* IFLA_ADDRESS */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_MASTER */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_MTU */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_LINK */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_OPERSTATE */\n\t\t+ nla_total_size(sizeof(u8))\t/* IFLA_PROTINFO */\n\t\t+ nla_total_size(sizeof(struct nlattr))\t/* IFLA_AF_SPEC */\n\t\t+ nla_total_size(sizeof(u16))\t/* IFLA_BRIDGE_FLAGS */\n\t\t+ nla_total_size(sizeof(u16));\t/* IFLA_BRIDGE_MODE */\n}\n\nstatic int rtnl_bridge_notify(struct net_device *dev, u16 flags)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\tstruct sk_buff *skb;\n\tint err = -EOPNOTSUPP;\n\n\tskb = nlmsg_new(bridge_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tif ((!flags || (flags & BRIDGE_FLAGS_MASTER)) &&\n\t    br_dev && br_dev->netdev_ops->ndo_bridge_getlink) {\n\t\terr = br_dev->netdev_ops->ndo_bridge_getlink(skb, 0, 0, dev, 0);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif ((flags & BRIDGE_FLAGS_SELF) &&\n\t    dev->netdev_ops->ndo_bridge_getlink) {\n\t\terr = dev->netdev_ops->ndo_bridge_getlink(skb, 0, 0, dev, 0);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\n\treturn 0;\nerrout:\n\tWARN_ON(err == -EMSGSIZE);\n\tkfree_skb(skb);\n\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n\treturn err;\n}\n\nstatic int rtnl_bridge_setlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tstruct nlattr *br_spec, *attr = NULL;\n\tint rem, err = -EOPNOTSUPP;\n\tu16 oflags, flags = 0;\n\tbool have_flags = false;\n\n\tif (nlmsg_len(nlh) < sizeof(*ifm))\n\t\treturn -EINVAL;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_family != AF_BRIDGE)\n\t\treturn -EPFNOSUPPORT;\n\n\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\tif (!dev) {\n\t\tpr_info(\"PF_BRIDGE: RTM_SETLINK with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (br_spec) {\n\t\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_FLAGS) {\n\t\t\t\thave_flags = true;\n\t\t\t\tflags = nla_get_u16(attr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\toflags = flags;\n\n\tif (!flags || (flags & BRIDGE_FLAGS_MASTER)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (!br_dev || !br_dev->netdev_ops->ndo_bridge_setlink) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = br_dev->netdev_ops->ndo_bridge_setlink(dev, nlh);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tflags &= ~BRIDGE_FLAGS_MASTER;\n\t}\n\n\tif ((flags & BRIDGE_FLAGS_SELF)) {\n\t\tif (!dev->netdev_ops->ndo_bridge_setlink)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\terr = dev->netdev_ops->ndo_bridge_setlink(dev, nlh);\n\n\t\tif (!err)\n\t\t\tflags &= ~BRIDGE_FLAGS_SELF;\n\t}\n\n\tif (have_flags)\n\t\tmemcpy(nla_data(attr), &flags, sizeof(flags));\n\t/* Generate event to notify upper layer of bridge change */\n\tif (!err)\n\t\terr = rtnl_bridge_notify(dev, oflags);\nout:\n\treturn err;\n}\n\nstatic int rtnl_bridge_dellink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tstruct nlattr *br_spec, *attr = NULL;\n\tint rem, err = -EOPNOTSUPP;\n\tu16 oflags, flags = 0;\n\tbool have_flags = false;\n\n\tif (nlmsg_len(nlh) < sizeof(*ifm))\n\t\treturn -EINVAL;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_family != AF_BRIDGE)\n\t\treturn -EPFNOSUPPORT;\n\n\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\tif (!dev) {\n\t\tpr_info(\"PF_BRIDGE: RTM_SETLINK with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (br_spec) {\n\t\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_FLAGS) {\n\t\t\t\thave_flags = true;\n\t\t\t\tflags = nla_get_u16(attr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\toflags = flags;\n\n\tif (!flags || (flags & BRIDGE_FLAGS_MASTER)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (!br_dev || !br_dev->netdev_ops->ndo_bridge_dellink) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = br_dev->netdev_ops->ndo_bridge_dellink(dev, nlh);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tflags &= ~BRIDGE_FLAGS_MASTER;\n\t}\n\n\tif ((flags & BRIDGE_FLAGS_SELF)) {\n\t\tif (!dev->netdev_ops->ndo_bridge_dellink)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\terr = dev->netdev_ops->ndo_bridge_dellink(dev, nlh);\n\n\t\tif (!err)\n\t\t\tflags &= ~BRIDGE_FLAGS_SELF;\n\t}\n\n\tif (have_flags)\n\t\tmemcpy(nla_data(attr), &flags, sizeof(flags));\n\t/* Generate event to notify upper layer of bridge change */\n\tif (!err)\n\t\terr = rtnl_bridge_notify(dev, oflags);\nout:\n\treturn err;\n}\n\n/* Protected by RTNL sempahore.  */\nstatic struct rtattr **rta_buf;\nstatic int rtattr_max;\n\n/* Process one rtnetlink message. */\n\nstatic int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\trtnl_doit_func doit;\n\tint sz_idx, kind;\n\tint min_len;\n\tint family;\n\tint type;\n\tint err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > RTM_MAX)\n\t\treturn -EOPNOTSUPP;\n\n\ttype -= RTM_BASE;\n\n\t/* All the messages must have at least 1 byte length */\n\tif (nlh->nlmsg_len < NLMSG_LENGTH(sizeof(struct rtgenmsg)))\n\t\treturn 0;\n\n\tfamily = ((struct rtgenmsg *)NLMSG_DATA(nlh))->rtgen_family;\n\tsz_idx = type>>2;\n\tkind = type&3;\n\n\tif (kind != 2 && !ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (kind == 2 && nlh->nlmsg_flags&NLM_F_DUMP) {\n\t\tstruct sock *rtnl;\n\t\trtnl_dumpit_func dumpit;\n\t\trtnl_calcit_func calcit;\n\t\tu16 min_dump_alloc = 0;\n\n\t\tdumpit = rtnl_get_dumpit(family, type);\n\t\tif (dumpit == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\t\tcalcit = rtnl_get_calcit(family, type);\n\t\tif (calcit)\n\t\t\tmin_dump_alloc = calcit(skb, nlh);\n\n\t\t__rtnl_unlock();\n\t\trtnl = net->rtnl;\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump\t\t= dumpit,\n\t\t\t\t.min_dump_alloc\t= min_dump_alloc,\n\t\t\t};\n\t\t\terr = netlink_dump_start(rtnl, skb, nlh, &c);\n\t\t}\n\t\trtnl_lock();\n\t\treturn err;\n\t}\n\n\tmemset(rta_buf, 0, (rtattr_max * sizeof(struct rtattr *)));\n\n\tmin_len = rtm_min[sz_idx];\n\tif (nlh->nlmsg_len < min_len)\n\t\treturn -EINVAL;\n\n\tif (nlh->nlmsg_len > min_len) {\n\t\tint attrlen = nlh->nlmsg_len - NLMSG_ALIGN(min_len);\n\t\tstruct rtattr *attr = (void *)nlh + NLMSG_ALIGN(min_len);\n\n\t\twhile (RTA_OK(attr, attrlen)) {\n\t\t\tunsigned int flavor = attr->rta_type;\n\t\t\tif (flavor) {\n\t\t\t\tif (flavor > rta_max[sz_idx])\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\trta_buf[flavor-1] = attr;\n\t\t\t}\n\t\t\tattr = RTA_NEXT(attr, attrlen);\n\t\t}\n\t}\n\n\tdoit = rtnl_get_doit(family, type);\n\tif (doit == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\treturn doit(skb, nlh, (void *)&rta_buf[0]);\n}\n\nstatic void rtnetlink_rcv(struct sk_buff *skb)\n{\n\trtnl_lock();\n\tnetlink_rcv_skb(skb, &rtnetlink_rcv_msg);\n\trtnl_unlock();\n}\n\nstatic int rtnetlink_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = ptr;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\tcase NETDEV_DOWN:\n\tcase NETDEV_PRE_UP:\n\tcase NETDEV_POST_INIT:\n\tcase NETDEV_REGISTER:\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\tcase NETDEV_GOING_DOWN:\n\tcase NETDEV_UNREGISTER:\n\tcase NETDEV_UNREGISTER_FINAL:\n\tcase NETDEV_RELEASE:\n\tcase NETDEV_JOIN:\n\t\tbreak;\n\tdefault:\n\t\trtmsg_ifinfo(RTM_NEWLINK, dev, 0);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rtnetlink_dev_notifier = {\n\t.notifier_call\t= rtnetlink_event,\n};\n\n\nstatic int __net_init rtnetlink_net_init(struct net *net)\n{\n\tstruct sock *sk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t\t= RTNLGRP_MAX,\n\t\t.input\t\t= rtnetlink_rcv,\n\t\t.cb_mutex\t= &rtnl_mutex,\n\t\t.flags\t\t= NL_CFG_F_NONROOT_RECV,\n\t};\n\n\tsk = netlink_kernel_create(net, NETLINK_ROUTE, &cfg);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tnet->rtnl = sk;\n\treturn 0;\n}\n\nstatic void __net_exit rtnetlink_net_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->rtnl);\n\tnet->rtnl = NULL;\n}\n\nstatic struct pernet_operations rtnetlink_net_ops = {\n\t.init = rtnetlink_net_init,\n\t.exit = rtnetlink_net_exit,\n};\n\nvoid __init rtnetlink_init(void)\n{\n\tint i;\n\n\trtattr_max = 0;\n\tfor (i = 0; i < ARRAY_SIZE(rta_max); i++)\n\t\tif (rta_max[i] > rtattr_max)\n\t\t\trtattr_max = rta_max[i];\n\trta_buf = kmalloc(rtattr_max * sizeof(struct rtattr *), GFP_KERNEL);\n\tif (!rta_buf)\n\t\tpanic(\"rtnetlink_init: cannot allocate rta_buf\\n\");\n\n\tif (register_pernet_subsys(&rtnetlink_net_ops))\n\t\tpanic(\"rtnetlink_init: cannot initialize rtnetlink\\n\");\n\n\tregister_netdevice_notifier(&rtnetlink_dev_notifier);\n\n\trtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,\n\t\t      rtnl_dump_ifinfo, rtnl_calcit);\n\trtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL, NULL);\n\trtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL, NULL);\n\trtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL, NULL);\n\n\trtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all, NULL);\n\trtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all, NULL);\n\n\trtnl_register(PF_BRIDGE, RTM_NEWNEIGH, rtnl_fdb_add, NULL, NULL);\n\trtnl_register(PF_BRIDGE, RTM_DELNEIGH, rtnl_fdb_del, NULL, NULL);\n\trtnl_register(PF_BRIDGE, RTM_GETNEIGH, NULL, rtnl_fdb_dump, NULL);\n\n\trtnl_register(PF_BRIDGE, RTM_GETLINK, NULL, rtnl_bridge_getlink, NULL);\n\trtnl_register(PF_BRIDGE, RTM_DELLINK, rtnl_bridge_dellink, NULL, NULL);\n\trtnl_register(PF_BRIDGE, RTM_SETLINK, rtnl_bridge_setlink, NULL, NULL);\n}\n\n"], "fixing_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tRouting netlink socket interface: protocol independent part.\n *\n * Authors:\tAlexey Kuznetsov, <kuznet@ms2.inr.ac.ru>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n *\tFixes:\n *\tVitaly E. Lavrov\t\tRTA_OK arithmetics was wrong.\n */\n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/capability.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/if_addr.h>\n#include <linux/if_bridge.h>\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n\n#include <asm/uaccess.h>\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/arp.h>\n#include <net/route.h>\n#include <net/udp.h>\n#include <net/sock.h>\n#include <net/pkt_sched.h>\n#include <net/fib_rules.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n\nstruct rtnl_link {\n\trtnl_doit_func\t\tdoit;\n\trtnl_dumpit_func\tdumpit;\n\trtnl_calcit_func \tcalcit;\n};\n\nstatic DEFINE_MUTEX(rtnl_mutex);\n\nvoid rtnl_lock(void)\n{\n\tmutex_lock(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_lock);\n\nvoid __rtnl_unlock(void)\n{\n\tmutex_unlock(&rtnl_mutex);\n}\n\nvoid rtnl_unlock(void)\n{\n\t/* This fellow will unlock it for us. */\n\tnetdev_run_todo();\n}\nEXPORT_SYMBOL(rtnl_unlock);\n\nint rtnl_trylock(void)\n{\n\treturn mutex_trylock(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_trylock);\n\nint rtnl_is_locked(void)\n{\n\treturn mutex_is_locked(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_is_locked);\n\n#ifdef CONFIG_PROVE_LOCKING\nint lockdep_rtnl_is_held(void)\n{\n\treturn lockdep_is_held(&rtnl_mutex);\n}\nEXPORT_SYMBOL(lockdep_rtnl_is_held);\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n\nstatic struct rtnl_link *rtnl_msg_handlers[RTNL_FAMILY_MAX + 1];\n\nstatic inline int rtm_msgindex(int msgtype)\n{\n\tint msgindex = msgtype - RTM_BASE;\n\n\t/*\n\t * msgindex < 0 implies someone tried to register a netlink\n\t * control code. msgindex >= RTM_NR_MSGTYPES may indicate that\n\t * the message type has not been added to linux/rtnetlink.h\n\t */\n\tBUG_ON(msgindex < 0 || msgindex >= RTM_NR_MSGTYPES);\n\n\treturn msgindex;\n}\n\nstatic rtnl_doit_func rtnl_get_doit(int protocol, int msgindex)\n{\n\tstruct rtnl_link *tab;\n\n\tif (protocol <= RTNL_FAMILY_MAX)\n\t\ttab = rtnl_msg_handlers[protocol];\n\telse\n\t\ttab = NULL;\n\n\tif (tab == NULL || tab[msgindex].doit == NULL)\n\t\ttab = rtnl_msg_handlers[PF_UNSPEC];\n\n\treturn tab[msgindex].doit;\n}\n\nstatic rtnl_dumpit_func rtnl_get_dumpit(int protocol, int msgindex)\n{\n\tstruct rtnl_link *tab;\n\n\tif (protocol <= RTNL_FAMILY_MAX)\n\t\ttab = rtnl_msg_handlers[protocol];\n\telse\n\t\ttab = NULL;\n\n\tif (tab == NULL || tab[msgindex].dumpit == NULL)\n\t\ttab = rtnl_msg_handlers[PF_UNSPEC];\n\n\treturn tab[msgindex].dumpit;\n}\n\nstatic rtnl_calcit_func rtnl_get_calcit(int protocol, int msgindex)\n{\n\tstruct rtnl_link *tab;\n\n\tif (protocol <= RTNL_FAMILY_MAX)\n\t\ttab = rtnl_msg_handlers[protocol];\n\telse\n\t\ttab = NULL;\n\n\tif (tab == NULL || tab[msgindex].calcit == NULL)\n\t\ttab = rtnl_msg_handlers[PF_UNSPEC];\n\n\treturn tab[msgindex].calcit;\n}\n\n/**\n * __rtnl_register - Register a rtnetlink message type\n * @protocol: Protocol family or PF_UNSPEC\n * @msgtype: rtnetlink message type\n * @doit: Function pointer called for each request message\n * @dumpit: Function pointer called for each dump request (NLM_F_DUMP) message\n * @calcit: Function pointer to calc size of dump message\n *\n * Registers the specified function pointers (at least one of them has\n * to be non-NULL) to be called whenever a request message for the\n * specified protocol family and message type is received.\n *\n * The special protocol family PF_UNSPEC may be used to define fallback\n * function pointers for the case when no entry for the specific protocol\n * family exists.\n *\n * Returns 0 on success or a negative error code.\n */\nint __rtnl_register(int protocol, int msgtype,\n\t\t    rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t    rtnl_calcit_func calcit)\n{\n\tstruct rtnl_link *tab;\n\tint msgindex;\n\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\tmsgindex = rtm_msgindex(msgtype);\n\n\ttab = rtnl_msg_handlers[protocol];\n\tif (tab == NULL) {\n\t\ttab = kcalloc(RTM_NR_MSGTYPES, sizeof(*tab), GFP_KERNEL);\n\t\tif (tab == NULL)\n\t\t\treturn -ENOBUFS;\n\n\t\trtnl_msg_handlers[protocol] = tab;\n\t}\n\n\tif (doit)\n\t\ttab[msgindex].doit = doit;\n\n\tif (dumpit)\n\t\ttab[msgindex].dumpit = dumpit;\n\n\tif (calcit)\n\t\ttab[msgindex].calcit = calcit;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__rtnl_register);\n\n/**\n * rtnl_register - Register a rtnetlink message type\n *\n * Identical to __rtnl_register() but panics on failure. This is useful\n * as failure of this function is very unlikely, it can only happen due\n * to lack of memory when allocating the chain to store all message\n * handlers for a protocol. Meant for use in init functions where lack\n * of memory implies no sense in continuing.\n */\nvoid rtnl_register(int protocol, int msgtype,\n\t\t   rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t   rtnl_calcit_func calcit)\n{\n\tif (__rtnl_register(protocol, msgtype, doit, dumpit, calcit) < 0)\n\t\tpanic(\"Unable to register rtnetlink message handler, \"\n\t\t      \"protocol = %d, message type = %d\\n\",\n\t\t      protocol, msgtype);\n}\nEXPORT_SYMBOL_GPL(rtnl_register);\n\n/**\n * rtnl_unregister - Unregister a rtnetlink message type\n * @protocol: Protocol family or PF_UNSPEC\n * @msgtype: rtnetlink message type\n *\n * Returns 0 on success or a negative error code.\n */\nint rtnl_unregister(int protocol, int msgtype)\n{\n\tint msgindex;\n\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\tmsgindex = rtm_msgindex(msgtype);\n\n\tif (rtnl_msg_handlers[protocol] == NULL)\n\t\treturn -ENOENT;\n\n\trtnl_msg_handlers[protocol][msgindex].doit = NULL;\n\trtnl_msg_handlers[protocol][msgindex].dumpit = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtnl_unregister);\n\n/**\n * rtnl_unregister_all - Unregister all rtnetlink message type of a protocol\n * @protocol : Protocol family or PF_UNSPEC\n *\n * Identical to calling rtnl_unregster() for all registered message types\n * of a certain protocol family.\n */\nvoid rtnl_unregister_all(int protocol)\n{\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\n\tkfree(rtnl_msg_handlers[protocol]);\n\trtnl_msg_handlers[protocol] = NULL;\n}\nEXPORT_SYMBOL_GPL(rtnl_unregister_all);\n\nstatic LIST_HEAD(link_ops);\n\nstatic const struct rtnl_link_ops *rtnl_link_ops_get(const char *kind)\n{\n\tconst struct rtnl_link_ops *ops;\n\n\tlist_for_each_entry(ops, &link_ops, list) {\n\t\tif (!strcmp(ops->kind, kind))\n\t\t\treturn ops;\n\t}\n\treturn NULL;\n}\n\n/**\n * __rtnl_link_register - Register rtnl_link_ops with rtnetlink.\n * @ops: struct rtnl_link_ops * to register\n *\n * The caller must hold the rtnl_mutex. This function should be used\n * by drivers that create devices during module initialization. It\n * must be called before registering the devices.\n *\n * Returns 0 on success or a negative error code.\n */\nint __rtnl_link_register(struct rtnl_link_ops *ops)\n{\n\tif (rtnl_link_ops_get(ops->kind))\n\t\treturn -EEXIST;\n\n\tif (!ops->dellink)\n\t\tops->dellink = unregister_netdevice_queue;\n\n\tlist_add_tail(&ops->list, &link_ops);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__rtnl_link_register);\n\n/**\n * rtnl_link_register - Register rtnl_link_ops with rtnetlink.\n * @ops: struct rtnl_link_ops * to register\n *\n * Returns 0 on success or a negative error code.\n */\nint rtnl_link_register(struct rtnl_link_ops *ops)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = __rtnl_link_register(ops);\n\trtnl_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtnl_link_register);\n\nstatic void __rtnl_kill_links(struct net *net, struct rtnl_link_ops *ops)\n{\n\tstruct net_device *dev;\n\tLIST_HEAD(list_kill);\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->rtnl_link_ops == ops)\n\t\t\tops->dellink(dev, &list_kill);\n\t}\n\tunregister_netdevice_many(&list_kill);\n}\n\n/**\n * __rtnl_link_unregister - Unregister rtnl_link_ops from rtnetlink.\n * @ops: struct rtnl_link_ops * to unregister\n *\n * The caller must hold the rtnl_mutex.\n */\nvoid __rtnl_link_unregister(struct rtnl_link_ops *ops)\n{\n\tstruct net *net;\n\n\tfor_each_net(net) {\n\t\t__rtnl_kill_links(net, ops);\n\t}\n\tlist_del(&ops->list);\n}\nEXPORT_SYMBOL_GPL(__rtnl_link_unregister);\n\n/**\n * rtnl_link_unregister - Unregister rtnl_link_ops from rtnetlink.\n * @ops: struct rtnl_link_ops * to unregister\n */\nvoid rtnl_link_unregister(struct rtnl_link_ops *ops)\n{\n\trtnl_lock();\n\t__rtnl_link_unregister(ops);\n\trtnl_unlock();\n}\nEXPORT_SYMBOL_GPL(rtnl_link_unregister);\n\nstatic size_t rtnl_link_get_size(const struct net_device *dev)\n{\n\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\tsize_t size;\n\n\tif (!ops)\n\t\treturn 0;\n\n\tsize = nla_total_size(sizeof(struct nlattr)) + /* IFLA_LINKINFO */\n\t       nla_total_size(strlen(ops->kind) + 1);  /* IFLA_INFO_KIND */\n\n\tif (ops->get_size)\n\t\t/* IFLA_INFO_DATA + nested data */\n\t\tsize += nla_total_size(sizeof(struct nlattr)) +\n\t\t\tops->get_size(dev);\n\n\tif (ops->get_xstats_size)\n\t\t/* IFLA_INFO_XSTATS */\n\t\tsize += nla_total_size(ops->get_xstats_size(dev));\n\n\treturn size;\n}\n\nstatic LIST_HEAD(rtnl_af_ops);\n\nstatic const struct rtnl_af_ops *rtnl_af_lookup(const int family)\n{\n\tconst struct rtnl_af_ops *ops;\n\n\tlist_for_each_entry(ops, &rtnl_af_ops, list) {\n\t\tif (ops->family == family)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * __rtnl_af_register - Register rtnl_af_ops with rtnetlink.\n * @ops: struct rtnl_af_ops * to register\n *\n * The caller must hold the rtnl_mutex.\n *\n * Returns 0 on success or a negative error code.\n */\nint __rtnl_af_register(struct rtnl_af_ops *ops)\n{\n\tlist_add_tail(&ops->list, &rtnl_af_ops);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__rtnl_af_register);\n\n/**\n * rtnl_af_register - Register rtnl_af_ops with rtnetlink.\n * @ops: struct rtnl_af_ops * to register\n *\n * Returns 0 on success or a negative error code.\n */\nint rtnl_af_register(struct rtnl_af_ops *ops)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = __rtnl_af_register(ops);\n\trtnl_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtnl_af_register);\n\n/**\n * __rtnl_af_unregister - Unregister rtnl_af_ops from rtnetlink.\n * @ops: struct rtnl_af_ops * to unregister\n *\n * The caller must hold the rtnl_mutex.\n */\nvoid __rtnl_af_unregister(struct rtnl_af_ops *ops)\n{\n\tlist_del(&ops->list);\n}\nEXPORT_SYMBOL_GPL(__rtnl_af_unregister);\n\n/**\n * rtnl_af_unregister - Unregister rtnl_af_ops from rtnetlink.\n * @ops: struct rtnl_af_ops * to unregister\n */\nvoid rtnl_af_unregister(struct rtnl_af_ops *ops)\n{\n\trtnl_lock();\n\t__rtnl_af_unregister(ops);\n\trtnl_unlock();\n}\nEXPORT_SYMBOL_GPL(rtnl_af_unregister);\n\nstatic size_t rtnl_link_get_af_size(const struct net_device *dev)\n{\n\tstruct rtnl_af_ops *af_ops;\n\tsize_t size;\n\n\t/* IFLA_AF_SPEC */\n\tsize = nla_total_size(sizeof(struct nlattr));\n\n\tlist_for_each_entry(af_ops, &rtnl_af_ops, list) {\n\t\tif (af_ops->get_link_af_size) {\n\t\t\t/* AF_* + nested data */\n\t\t\tsize += nla_total_size(sizeof(struct nlattr)) +\n\t\t\t\taf_ops->get_link_af_size(dev);\n\t\t}\n\t}\n\n\treturn size;\n}\n\nstatic int rtnl_link_fill(struct sk_buff *skb, const struct net_device *dev)\n{\n\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\tstruct nlattr *linkinfo, *data;\n\tint err = -EMSGSIZE;\n\n\tlinkinfo = nla_nest_start(skb, IFLA_LINKINFO);\n\tif (linkinfo == NULL)\n\t\tgoto out;\n\n\tif (nla_put_string(skb, IFLA_INFO_KIND, ops->kind) < 0)\n\t\tgoto err_cancel_link;\n\tif (ops->fill_xstats) {\n\t\terr = ops->fill_xstats(skb, dev);\n\t\tif (err < 0)\n\t\t\tgoto err_cancel_link;\n\t}\n\tif (ops->fill_info) {\n\t\tdata = nla_nest_start(skb, IFLA_INFO_DATA);\n\t\tif (data == NULL)\n\t\t\tgoto err_cancel_link;\n\t\terr = ops->fill_info(skb, dev);\n\t\tif (err < 0)\n\t\t\tgoto err_cancel_data;\n\t\tnla_nest_end(skb, data);\n\t}\n\n\tnla_nest_end(skb, linkinfo);\n\treturn 0;\n\nerr_cancel_data:\n\tnla_nest_cancel(skb, data);\nerr_cancel_link:\n\tnla_nest_cancel(skb, linkinfo);\nout:\n\treturn err;\n}\n\nstatic const int rtm_min[RTM_NR_FAMILIES] =\n{\n\t[RTM_FAM(RTM_NEWLINK)]      = NLMSG_LENGTH(sizeof(struct ifinfomsg)),\n\t[RTM_FAM(RTM_NEWADDR)]      = NLMSG_LENGTH(sizeof(struct ifaddrmsg)),\n\t[RTM_FAM(RTM_NEWROUTE)]     = NLMSG_LENGTH(sizeof(struct rtmsg)),\n\t[RTM_FAM(RTM_NEWRULE)]      = NLMSG_LENGTH(sizeof(struct fib_rule_hdr)),\n\t[RTM_FAM(RTM_NEWQDISC)]     = NLMSG_LENGTH(sizeof(struct tcmsg)),\n\t[RTM_FAM(RTM_NEWTCLASS)]    = NLMSG_LENGTH(sizeof(struct tcmsg)),\n\t[RTM_FAM(RTM_NEWTFILTER)]   = NLMSG_LENGTH(sizeof(struct tcmsg)),\n\t[RTM_FAM(RTM_NEWACTION)]    = NLMSG_LENGTH(sizeof(struct tcamsg)),\n\t[RTM_FAM(RTM_GETMULTICAST)] = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n\t[RTM_FAM(RTM_GETANYCAST)]   = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n};\n\nstatic const int rta_max[RTM_NR_FAMILIES] =\n{\n\t[RTM_FAM(RTM_NEWLINK)]      = IFLA_MAX,\n\t[RTM_FAM(RTM_NEWADDR)]      = IFA_MAX,\n\t[RTM_FAM(RTM_NEWROUTE)]     = RTA_MAX,\n\t[RTM_FAM(RTM_NEWRULE)]      = FRA_MAX,\n\t[RTM_FAM(RTM_NEWQDISC)]     = TCA_MAX,\n\t[RTM_FAM(RTM_NEWTCLASS)]    = TCA_MAX,\n\t[RTM_FAM(RTM_NEWTFILTER)]   = TCA_MAX,\n\t[RTM_FAM(RTM_NEWACTION)]    = TCAA_MAX,\n};\n\nint rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, unsigned int group, int echo)\n{\n\tstruct sock *rtnl = net->rtnl;\n\tint err = 0;\n\n\tNETLINK_CB(skb).dst_group = group;\n\tif (echo)\n\t\tatomic_inc(&skb->users);\n\tnetlink_broadcast(rtnl, skb, pid, group, GFP_KERNEL);\n\tif (echo)\n\t\terr = netlink_unicast(rtnl, skb, pid, MSG_DONTWAIT);\n\treturn err;\n}\n\nint rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid)\n{\n\tstruct sock *rtnl = net->rtnl;\n\n\treturn nlmsg_unicast(rtnl, skb, pid);\n}\nEXPORT_SYMBOL(rtnl_unicast);\n\nvoid rtnl_notify(struct sk_buff *skb, struct net *net, u32 pid, u32 group,\n\t\t struct nlmsghdr *nlh, gfp_t flags)\n{\n\tstruct sock *rtnl = net->rtnl;\n\tint report = 0;\n\n\tif (nlh)\n\t\treport = nlmsg_report(nlh);\n\n\tnlmsg_notify(rtnl, skb, pid, group, report, flags);\n}\nEXPORT_SYMBOL(rtnl_notify);\n\nvoid rtnl_set_sk_err(struct net *net, u32 group, int error)\n{\n\tstruct sock *rtnl = net->rtnl;\n\n\tnetlink_set_err(rtnl, 0, group, error);\n}\nEXPORT_SYMBOL(rtnl_set_sk_err);\n\nint rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics)\n{\n\tstruct nlattr *mx;\n\tint i, valid = 0;\n\n\tmx = nla_nest_start(skb, RTA_METRICS);\n\tif (mx == NULL)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < RTAX_MAX; i++) {\n\t\tif (metrics[i]) {\n\t\t\tvalid++;\n\t\t\tif (nla_put_u32(skb, i+1, metrics[i]))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (!valid) {\n\t\tnla_nest_cancel(skb, mx);\n\t\treturn 0;\n\t}\n\n\treturn nla_nest_end(skb, mx);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, mx);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL(rtnetlink_put_metrics);\n\nint rtnl_put_cacheinfo(struct sk_buff *skb, struct dst_entry *dst, u32 id,\n\t\t       long expires, u32 error)\n{\n\tstruct rta_cacheinfo ci = {\n\t\t.rta_lastuse = jiffies_delta_to_clock_t(jiffies - dst->lastuse),\n\t\t.rta_used = dst->__use,\n\t\t.rta_clntref = atomic_read(&(dst->__refcnt)),\n\t\t.rta_error = error,\n\t\t.rta_id =  id,\n\t};\n\n\tif (expires) {\n\t\tunsigned long clock;\n\n\t\tclock = jiffies_to_clock_t(abs(expires));\n\t\tclock = min_t(unsigned long, clock, INT_MAX);\n\t\tci.rta_expires = (expires > 0) ? clock : -clock;\n\t}\n\treturn nla_put(skb, RTA_CACHEINFO, sizeof(ci), &ci);\n}\nEXPORT_SYMBOL_GPL(rtnl_put_cacheinfo);\n\nstatic void set_operstate(struct net_device *dev, unsigned char transition)\n{\n\tunsigned char operstate = dev->operstate;\n\n\tswitch (transition) {\n\tcase IF_OPER_UP:\n\t\tif ((operstate == IF_OPER_DORMANT ||\n\t\t     operstate == IF_OPER_UNKNOWN) &&\n\t\t    !netif_dormant(dev))\n\t\t\toperstate = IF_OPER_UP;\n\t\tbreak;\n\n\tcase IF_OPER_DORMANT:\n\t\tif (operstate == IF_OPER_UP ||\n\t\t    operstate == IF_OPER_UNKNOWN)\n\t\t\toperstate = IF_OPER_DORMANT;\n\t\tbreak;\n\t}\n\n\tif (dev->operstate != operstate) {\n\t\twrite_lock_bh(&dev_base_lock);\n\t\tdev->operstate = operstate;\n\t\twrite_unlock_bh(&dev_base_lock);\n\t\tnetdev_state_change(dev);\n\t}\n}\n\nstatic unsigned int rtnl_dev_get_flags(const struct net_device *dev)\n{\n\treturn (dev->flags & ~(IFF_PROMISC | IFF_ALLMULTI)) |\n\t       (dev->gflags & (IFF_PROMISC | IFF_ALLMULTI));\n}\n\nstatic unsigned int rtnl_dev_combine_flags(const struct net_device *dev,\n\t\t\t\t\t   const struct ifinfomsg *ifm)\n{\n\tunsigned int flags = ifm->ifi_flags;\n\n\t/* bugwards compatibility: ifi_change == 0 is treated as ~0 */\n\tif (ifm->ifi_change)\n\t\tflags = (flags & ifm->ifi_change) |\n\t\t\t(rtnl_dev_get_flags(dev) & ~ifm->ifi_change);\n\n\treturn flags;\n}\n\nstatic void copy_rtnl_link_stats(struct rtnl_link_stats *a,\n\t\t\t\t const struct rtnl_link_stats64 *b)\n{\n\ta->rx_packets = b->rx_packets;\n\ta->tx_packets = b->tx_packets;\n\ta->rx_bytes = b->rx_bytes;\n\ta->tx_bytes = b->tx_bytes;\n\ta->rx_errors = b->rx_errors;\n\ta->tx_errors = b->tx_errors;\n\ta->rx_dropped = b->rx_dropped;\n\ta->tx_dropped = b->tx_dropped;\n\n\ta->multicast = b->multicast;\n\ta->collisions = b->collisions;\n\n\ta->rx_length_errors = b->rx_length_errors;\n\ta->rx_over_errors = b->rx_over_errors;\n\ta->rx_crc_errors = b->rx_crc_errors;\n\ta->rx_frame_errors = b->rx_frame_errors;\n\ta->rx_fifo_errors = b->rx_fifo_errors;\n\ta->rx_missed_errors = b->rx_missed_errors;\n\n\ta->tx_aborted_errors = b->tx_aborted_errors;\n\ta->tx_carrier_errors = b->tx_carrier_errors;\n\ta->tx_fifo_errors = b->tx_fifo_errors;\n\ta->tx_heartbeat_errors = b->tx_heartbeat_errors;\n\ta->tx_window_errors = b->tx_window_errors;\n\n\ta->rx_compressed = b->rx_compressed;\n\ta->tx_compressed = b->tx_compressed;\n}\n\nstatic void copy_rtnl_link_stats64(void *v, const struct rtnl_link_stats64 *b)\n{\n\tmemcpy(v, b, sizeof(*b));\n}\n\n/* All VF info */\nstatic inline int rtnl_vfinfo_size(const struct net_device *dev,\n\t\t\t\t   u32 ext_filter_mask)\n{\n\tif (dev->dev.parent && dev_is_pci(dev->dev.parent) &&\n\t    (ext_filter_mask & RTEXT_FILTER_VF)) {\n\t\tint num_vfs = dev_num_vf(dev->dev.parent);\n\t\tsize_t size = nla_total_size(sizeof(struct nlattr));\n\t\tsize += nla_total_size(num_vfs * sizeof(struct nlattr));\n\t\tsize += num_vfs *\n\t\t\t(nla_total_size(sizeof(struct ifla_vf_mac)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_vlan)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_tx_rate)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_spoofchk)));\n\t\treturn size;\n\t} else\n\t\treturn 0;\n}\n\nstatic size_t rtnl_port_size(const struct net_device *dev)\n{\n\tsize_t port_size = nla_total_size(4)\t\t/* PORT_VF */\n\t\t+ nla_total_size(PORT_PROFILE_MAX)\t/* PORT_PROFILE */\n\t\t+ nla_total_size(sizeof(struct ifla_port_vsi))\n\t\t\t\t\t\t\t/* PORT_VSI_TYPE */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_INSTANCE_UUID */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_HOST_UUID */\n\t\t+ nla_total_size(1)\t\t\t/* PROT_VDP_REQUEST */\n\t\t+ nla_total_size(2);\t\t\t/* PORT_VDP_RESPONSE */\n\tsize_t vf_ports_size = nla_total_size(sizeof(struct nlattr));\n\tsize_t vf_port_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\tsize_t port_self_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\n\tif (!dev->netdev_ops->ndo_get_vf_port || !dev->dev.parent)\n\t\treturn 0;\n\tif (dev_num_vf(dev->dev.parent))\n\t\treturn port_self_size + vf_ports_size +\n\t\t\tvf_port_size * dev_num_vf(dev->dev.parent);\n\telse\n\t\treturn port_self_size;\n}\n\nstatic noinline size_t if_nlmsg_size(const struct net_device *dev,\n\t\t\t\t     u32 ext_filter_mask)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t       + nla_total_size(IFNAMSIZ) /* IFLA_IFNAME */\n\t       + nla_total_size(IFALIASZ) /* IFLA_IFALIAS */\n\t       + nla_total_size(IFNAMSIZ) /* IFLA_QDISC */\n\t       + nla_total_size(sizeof(struct rtnl_link_ifmap))\n\t       + nla_total_size(sizeof(struct rtnl_link_stats))\n\t       + nla_total_size(sizeof(struct rtnl_link_stats64))\n\t       + nla_total_size(MAX_ADDR_LEN) /* IFLA_ADDRESS */\n\t       + nla_total_size(MAX_ADDR_LEN) /* IFLA_BROADCAST */\n\t       + nla_total_size(4) /* IFLA_TXQLEN */\n\t       + nla_total_size(4) /* IFLA_WEIGHT */\n\t       + nla_total_size(4) /* IFLA_MTU */\n\t       + nla_total_size(4) /* IFLA_LINK */\n\t       + nla_total_size(4) /* IFLA_MASTER */\n\t       + nla_total_size(1) /* IFLA_CARRIER */\n\t       + nla_total_size(4) /* IFLA_PROMISCUITY */\n\t       + nla_total_size(4) /* IFLA_NUM_TX_QUEUES */\n\t       + nla_total_size(4) /* IFLA_NUM_RX_QUEUES */\n\t       + nla_total_size(1) /* IFLA_OPERSTATE */\n\t       + nla_total_size(1) /* IFLA_LINKMODE */\n\t       + nla_total_size(ext_filter_mask\n\t\t\t        & RTEXT_FILTER_VF ? 4 : 0) /* IFLA_NUM_VF */\n\t       + rtnl_vfinfo_size(dev, ext_filter_mask) /* IFLA_VFINFO_LIST */\n\t       + rtnl_port_size(dev) /* IFLA_VF_PORTS + IFLA_PORT_SELF */\n\t       + rtnl_link_get_size(dev) /* IFLA_LINKINFO */\n\t       + rtnl_link_get_af_size(dev); /* IFLA_AF_SPEC */\n}\n\nstatic int rtnl_vf_ports_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct nlattr *vf_ports;\n\tstruct nlattr *vf_port;\n\tint vf;\n\tint err;\n\n\tvf_ports = nla_nest_start(skb, IFLA_VF_PORTS);\n\tif (!vf_ports)\n\t\treturn -EMSGSIZE;\n\n\tfor (vf = 0; vf < dev_num_vf(dev->dev.parent); vf++) {\n\t\tvf_port = nla_nest_start(skb, IFLA_VF_PORT);\n\t\tif (!vf_port)\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_PORT_VF, vf))\n\t\t\tgoto nla_put_failure;\n\t\terr = dev->netdev_ops->ndo_get_vf_port(dev, vf, skb);\n\t\tif (err == -EMSGSIZE)\n\t\t\tgoto nla_put_failure;\n\t\tif (err) {\n\t\t\tnla_nest_cancel(skb, vf_port);\n\t\t\tcontinue;\n\t\t}\n\t\tnla_nest_end(skb, vf_port);\n\t}\n\n\tnla_nest_end(skb, vf_ports);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, vf_ports);\n\treturn -EMSGSIZE;\n}\n\nstatic int rtnl_port_self_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct nlattr *port_self;\n\tint err;\n\n\tport_self = nla_nest_start(skb, IFLA_PORT_SELF);\n\tif (!port_self)\n\t\treturn -EMSGSIZE;\n\n\terr = dev->netdev_ops->ndo_get_vf_port(dev, PORT_SELF_VF, skb);\n\tif (err) {\n\t\tnla_nest_cancel(skb, port_self);\n\t\treturn (err == -EMSGSIZE) ? err : 0;\n\t}\n\n\tnla_nest_end(skb, port_self);\n\n\treturn 0;\n}\n\nstatic int rtnl_port_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tint err;\n\n\tif (!dev->netdev_ops->ndo_get_vf_port || !dev->dev.parent)\n\t\treturn 0;\n\n\terr = rtnl_port_self_fill(skb, dev);\n\tif (err)\n\t\treturn err;\n\n\tif (dev_num_vf(dev->dev.parent)) {\n\t\terr = rtnl_vf_ports_fill(skb, dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,\n\t\t\t    int type, u32 pid, u32 seq, u32 change,\n\t\t\t    unsigned int flags, u32 ext_filter_mask)\n{\n\tstruct ifinfomsg *ifm;\n\tstruct nlmsghdr *nlh;\n\tstruct rtnl_link_stats64 temp;\n\tconst struct rtnl_link_stats64 *stats;\n\tstruct nlattr *attr, *af_spec;\n\tstruct rtnl_af_ops *af_ops;\n\tstruct net_device *upper_dev = netdev_master_upper_dev_get(dev);\n\n\tASSERT_RTNL();\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ifm), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifi_family = AF_UNSPEC;\n\tifm->__ifi_pad = 0;\n\tifm->ifi_type = dev->type;\n\tifm->ifi_index = dev->ifindex;\n\tifm->ifi_flags = dev_get_flags(dev);\n\tifm->ifi_change = change;\n\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    nla_put_u32(skb, IFLA_TXQLEN, dev->tx_queue_len) ||\n\t    nla_put_u8(skb, IFLA_OPERSTATE,\n\t\t       netif_running(dev) ? dev->operstate : IF_OPER_DOWN) ||\n\t    nla_put_u8(skb, IFLA_LINKMODE, dev->link_mode) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    nla_put_u32(skb, IFLA_GROUP, dev->group) ||\n\t    nla_put_u32(skb, IFLA_PROMISCUITY, dev->promiscuity) ||\n\t    nla_put_u32(skb, IFLA_NUM_TX_QUEUES, dev->num_tx_queues) ||\n#ifdef CONFIG_RPS\n\t    nla_put_u32(skb, IFLA_NUM_RX_QUEUES, dev->num_rx_queues) ||\n#endif\n\t    (dev->ifindex != dev->iflink &&\n\t     nla_put_u32(skb, IFLA_LINK, dev->iflink)) ||\n\t    (upper_dev &&\n\t     nla_put_u32(skb, IFLA_MASTER, upper_dev->ifindex)) ||\n\t    nla_put_u8(skb, IFLA_CARRIER, netif_carrier_ok(dev)) ||\n\t    (dev->qdisc &&\n\t     nla_put_string(skb, IFLA_QDISC, dev->qdisc->ops->id)) ||\n\t    (dev->ifalias &&\n\t     nla_put_string(skb, IFLA_IFALIAS, dev->ifalias)))\n\t\tgoto nla_put_failure;\n\n\tif (1) {\n\t\tstruct rtnl_link_ifmap map = {\n\t\t\t.mem_start   = dev->mem_start,\n\t\t\t.mem_end     = dev->mem_end,\n\t\t\t.base_addr   = dev->base_addr,\n\t\t\t.irq         = dev->irq,\n\t\t\t.dma         = dev->dma,\n\t\t\t.port        = dev->if_port,\n\t\t};\n\t\tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (dev->addr_len) {\n\t\tif (nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr) ||\n\t\t    nla_put(skb, IFLA_BROADCAST, dev->addr_len, dev->broadcast))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tattr = nla_reserve(skb, IFLA_STATS,\n\t\t\tsizeof(struct rtnl_link_stats));\n\tif (attr == NULL)\n\t\tgoto nla_put_failure;\n\n\tstats = dev_get_stats(dev, &temp);\n\tcopy_rtnl_link_stats(nla_data(attr), stats);\n\n\tattr = nla_reserve(skb, IFLA_STATS64,\n\t\t\tsizeof(struct rtnl_link_stats64));\n\tif (attr == NULL)\n\t\tgoto nla_put_failure;\n\tcopy_rtnl_link_stats64(nla_data(attr), stats);\n\n\tif (dev->dev.parent && (ext_filter_mask & RTEXT_FILTER_VF) &&\n\t    nla_put_u32(skb, IFLA_NUM_VF, dev_num_vf(dev->dev.parent)))\n\t\tgoto nla_put_failure;\n\n\tif (dev->netdev_ops->ndo_get_vf_config && dev->dev.parent\n\t    && (ext_filter_mask & RTEXT_FILTER_VF)) {\n\t\tint i;\n\n\t\tstruct nlattr *vfinfo, *vf;\n\t\tint num_vfs = dev_num_vf(dev->dev.parent);\n\n\t\tvfinfo = nla_nest_start(skb, IFLA_VFINFO_LIST);\n\t\tif (!vfinfo)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < num_vfs; i++) {\n\t\t\tstruct ifla_vf_info ivi;\n\t\t\tstruct ifla_vf_mac vf_mac;\n\t\t\tstruct ifla_vf_vlan vf_vlan;\n\t\t\tstruct ifla_vf_tx_rate vf_tx_rate;\n\t\t\tstruct ifla_vf_spoofchk vf_spoofchk;\n\n\t\t\t/*\n\t\t\t * Not all SR-IOV capable drivers support the\n\t\t\t * spoofcheck query.  Preset to -1 so the user\n\t\t\t * space tool can detect that the driver didn't\n\t\t\t * report anything.\n\t\t\t */\n\t\t\tivi.spoofchk = -1;\n\t\t\tmemset(ivi.mac, 0, sizeof(ivi.mac));\n\t\t\tif (dev->netdev_ops->ndo_get_vf_config(dev, i, &ivi))\n\t\t\t\tbreak;\n\t\t\tvf_mac.vf =\n\t\t\t\tvf_vlan.vf =\n\t\t\t\tvf_tx_rate.vf =\n\t\t\t\tvf_spoofchk.vf = ivi.vf;\n\n\t\t\tmemcpy(vf_mac.mac, ivi.mac, sizeof(ivi.mac));\n\t\t\tvf_vlan.vlan = ivi.vlan;\n\t\t\tvf_vlan.qos = ivi.qos;\n\t\t\tvf_tx_rate.rate = ivi.tx_rate;\n\t\t\tvf_spoofchk.setting = ivi.spoofchk;\n\t\t\tvf = nla_nest_start(skb, IFLA_VF_INFO);\n\t\t\tif (!vf) {\n\t\t\t\tnla_nest_cancel(skb, vfinfo);\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tif (nla_put(skb, IFLA_VF_MAC, sizeof(vf_mac), &vf_mac) ||\n\t\t\t    nla_put(skb, IFLA_VF_VLAN, sizeof(vf_vlan), &vf_vlan) ||\n\t\t\t    nla_put(skb, IFLA_VF_TX_RATE, sizeof(vf_tx_rate),\n\t\t\t\t    &vf_tx_rate) ||\n\t\t\t    nla_put(skb, IFLA_VF_SPOOFCHK, sizeof(vf_spoofchk),\n\t\t\t\t    &vf_spoofchk))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(skb, vf);\n\t\t}\n\t\tnla_nest_end(skb, vfinfo);\n\t}\n\n\tif (rtnl_port_fill(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (dev->rtnl_link_ops) {\n\t\tif (rtnl_link_fill(skb, dev) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (!(af_spec = nla_nest_start(skb, IFLA_AF_SPEC)))\n\t\tgoto nla_put_failure;\n\n\tlist_for_each_entry(af_ops, &rtnl_af_ops, list) {\n\t\tif (af_ops->fill_link_af) {\n\t\t\tstruct nlattr *af;\n\t\t\tint err;\n\n\t\t\tif (!(af = nla_nest_start(skb, af_ops->family)))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\terr = af_ops->fill_link_af(skb, dev);\n\n\t\t\t/*\n\t\t\t * Caller may return ENODATA to indicate that there\n\t\t\t * was no data to be dumped. This is not an error, it\n\t\t\t * means we should trim the attribute header and\n\t\t\t * continue.\n\t\t\t */\n\t\t\tif (err == -ENODATA)\n\t\t\t\tnla_nest_cancel(skb, af);\n\t\t\telse if (err < 0)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, af);\n\t\t}\n\t}\n\n\tnla_nest_end(skb, af_spec);\n\n\treturn nlmsg_end(skb, nlh);\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int rtnl_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint h, s_h;\n\tint idx = 0, s_idx;\n\tstruct net_device *dev;\n\tstruct hlist_head *head;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\n\ts_h = cb->args[0];\n\ts_idx = cb->args[1];\n\n\trcu_read_lock();\n\tcb->seq = net->dev_base_seq;\n\n\tif (nlmsg_parse(cb->nlh, sizeof(struct rtgenmsg), tb, IFLA_MAX,\n\t\t\tifla_policy) >= 0) {\n\n\t\tif (tb[IFLA_EXT_MASK])\n\t\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\t}\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (rtnl_fill_ifinfo(skb, dev, RTM_NEWLINK,\n\t\t\t\t\t     NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t     cb->nlh->nlmsg_seq, 0,\n\t\t\t\t\t     NLM_F_MULTI,\n\t\t\t\t\t     ext_filter_mask) <= 0)\n\t\t\t\tgoto out;\n\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\tcb->args[1] = idx;\n\tcb->args[0] = h;\n\n\treturn skb->len;\n}\n\nconst struct nla_policy ifla_policy[IFLA_MAX+1] = {\n\t[IFLA_IFNAME]\t\t= { .type = NLA_STRING, .len = IFNAMSIZ-1 },\n\t[IFLA_ADDRESS]\t\t= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n\t[IFLA_BROADCAST]\t= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n\t[IFLA_MAP]\t\t= { .len = sizeof(struct rtnl_link_ifmap) },\n\t[IFLA_MTU]\t\t= { .type = NLA_U32 },\n\t[IFLA_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_MASTER]\t\t= { .type = NLA_U32 },\n\t[IFLA_CARRIER]\t\t= { .type = NLA_U8 },\n\t[IFLA_TXQLEN]\t\t= { .type = NLA_U32 },\n\t[IFLA_WEIGHT]\t\t= { .type = NLA_U32 },\n\t[IFLA_OPERSTATE]\t= { .type = NLA_U8 },\n\t[IFLA_LINKMODE]\t\t= { .type = NLA_U8 },\n\t[IFLA_LINKINFO]\t\t= { .type = NLA_NESTED },\n\t[IFLA_NET_NS_PID]\t= { .type = NLA_U32 },\n\t[IFLA_NET_NS_FD]\t= { .type = NLA_U32 },\n\t[IFLA_IFALIAS]\t        = { .type = NLA_STRING, .len = IFALIASZ-1 },\n\t[IFLA_VFINFO_LIST]\t= {. type = NLA_NESTED },\n\t[IFLA_VF_PORTS]\t\t= { .type = NLA_NESTED },\n\t[IFLA_PORT_SELF]\t= { .type = NLA_NESTED },\n\t[IFLA_AF_SPEC]\t\t= { .type = NLA_NESTED },\n\t[IFLA_EXT_MASK]\t\t= { .type = NLA_U32 },\n\t[IFLA_PROMISCUITY]\t= { .type = NLA_U32 },\n\t[IFLA_NUM_TX_QUEUES]\t= { .type = NLA_U32 },\n\t[IFLA_NUM_RX_QUEUES]\t= { .type = NLA_U32 },\n};\nEXPORT_SYMBOL(ifla_policy);\n\nstatic const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {\n\t[IFLA_INFO_KIND]\t= { .type = NLA_STRING },\n\t[IFLA_INFO_DATA]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy ifla_vfinfo_policy[IFLA_VF_INFO_MAX+1] = {\n\t[IFLA_VF_INFO]\t\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {\n\t[IFLA_VF_MAC]\t\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_vf_mac) },\n\t[IFLA_VF_VLAN]\t\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_vf_vlan) },\n\t[IFLA_VF_TX_RATE]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_vf_tx_rate) },\n\t[IFLA_VF_SPOOFCHK]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_vf_spoofchk) },\n};\n\nstatic const struct nla_policy ifla_port_policy[IFLA_PORT_MAX+1] = {\n\t[IFLA_PORT_VF]\t\t= { .type = NLA_U32 },\n\t[IFLA_PORT_PROFILE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = PORT_PROFILE_MAX },\n\t[IFLA_PORT_VSI_TYPE]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_port_vsi)},\n\t[IFLA_PORT_INSTANCE_UUID] = { .type = NLA_BINARY,\n\t\t\t\t      .len = PORT_UUID_MAX },\n\t[IFLA_PORT_HOST_UUID]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = PORT_UUID_MAX },\n\t[IFLA_PORT_REQUEST]\t= { .type = NLA_U8, },\n\t[IFLA_PORT_RESPONSE]\t= { .type = NLA_U16, },\n};\n\nstruct net *rtnl_link_get_net(struct net *src_net, struct nlattr *tb[])\n{\n\tstruct net *net;\n\t/* Examine the link attributes and figure out which\n\t * network namespace we are talking about.\n\t */\n\tif (tb[IFLA_NET_NS_PID])\n\t\tnet = get_net_ns_by_pid(nla_get_u32(tb[IFLA_NET_NS_PID]));\n\telse if (tb[IFLA_NET_NS_FD])\n\t\tnet = get_net_ns_by_fd(nla_get_u32(tb[IFLA_NET_NS_FD]));\n\telse\n\t\tnet = get_net(src_net);\n\treturn net;\n}\nEXPORT_SYMBOL(rtnl_link_get_net);\n\nstatic int validate_linkmsg(struct net_device *dev, struct nlattr *tb[])\n{\n\tif (dev) {\n\t\tif (tb[IFLA_ADDRESS] &&\n\t\t    nla_len(tb[IFLA_ADDRESS]) < dev->addr_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (tb[IFLA_BROADCAST] &&\n\t\t    nla_len(tb[IFLA_BROADCAST]) < dev->addr_len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[IFLA_AF_SPEC]) {\n\t\tstruct nlattr *af;\n\t\tint rem, err;\n\n\t\tnla_for_each_nested(af, tb[IFLA_AF_SPEC], rem) {\n\t\t\tconst struct rtnl_af_ops *af_ops;\n\n\t\t\tif (!(af_ops = rtnl_af_lookup(nla_type(af))))\n\t\t\t\treturn -EAFNOSUPPORT;\n\n\t\t\tif (!af_ops->set_link_af)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tif (af_ops->validate_link_af) {\n\t\t\t\terr = af_ops->validate_link_af(dev, af);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int do_setvfinfo(struct net_device *dev, struct nlattr *attr)\n{\n\tint rem, err = -EINVAL;\n\tstruct nlattr *vf;\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tnla_for_each_nested(vf, attr, rem) {\n\t\tswitch (nla_type(vf)) {\n\t\tcase IFLA_VF_MAC: {\n\t\t\tstruct ifla_vf_mac *ivm;\n\t\t\tivm = nla_data(vf);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tif (ops->ndo_set_vf_mac)\n\t\t\t\terr = ops->ndo_set_vf_mac(dev, ivm->vf,\n\t\t\t\t\t\t\t  ivm->mac);\n\t\t\tbreak;\n\t\t}\n\t\tcase IFLA_VF_VLAN: {\n\t\t\tstruct ifla_vf_vlan *ivv;\n\t\t\tivv = nla_data(vf);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tif (ops->ndo_set_vf_vlan)\n\t\t\t\terr = ops->ndo_set_vf_vlan(dev, ivv->vf,\n\t\t\t\t\t\t\t   ivv->vlan,\n\t\t\t\t\t\t\t   ivv->qos);\n\t\t\tbreak;\n\t\t}\n\t\tcase IFLA_VF_TX_RATE: {\n\t\t\tstruct ifla_vf_tx_rate *ivt;\n\t\t\tivt = nla_data(vf);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tif (ops->ndo_set_vf_tx_rate)\n\t\t\t\terr = ops->ndo_set_vf_tx_rate(dev, ivt->vf,\n\t\t\t\t\t\t\t      ivt->rate);\n\t\t\tbreak;\n\t\t}\n\t\tcase IFLA_VF_SPOOFCHK: {\n\t\t\tstruct ifla_vf_spoofchk *ivs;\n\t\t\tivs = nla_data(vf);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tif (ops->ndo_set_vf_spoofchk)\n\t\t\t\terr = ops->ndo_set_vf_spoofchk(dev, ivs->vf,\n\t\t\t\t\t\t\t       ivs->setting);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic int do_set_master(struct net_device *dev, int ifindex)\n{\n\tstruct net_device *upper_dev = netdev_master_upper_dev_get(dev);\n\tconst struct net_device_ops *ops;\n\tint err;\n\n\tif (upper_dev) {\n\t\tif (upper_dev->ifindex == ifindex)\n\t\t\treturn 0;\n\t\tops = upper_dev->netdev_ops;\n\t\tif (ops->ndo_del_slave) {\n\t\t\terr = ops->ndo_del_slave(upper_dev, dev);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (ifindex) {\n\t\tupper_dev = __dev_get_by_index(dev_net(dev), ifindex);\n\t\tif (!upper_dev)\n\t\t\treturn -EINVAL;\n\t\tops = upper_dev->netdev_ops;\n\t\tif (ops->ndo_add_slave) {\n\t\t\terr = ops->ndo_add_slave(upper_dev, dev);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int do_setlink(struct net_device *dev, struct ifinfomsg *ifm,\n\t\t      struct nlattr **tb, char *ifname, int modified)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tint err;\n\n\tif (tb[IFLA_NET_NS_PID] || tb[IFLA_NET_NS_FD]) {\n\t\tstruct net *net = rtnl_link_get_net(dev_net(dev), tb);\n\t\tif (IS_ERR(net)) {\n\t\t\terr = PTR_ERR(net);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto errout;\n\t\t}\n\t\terr = dev_change_net_namespace(dev, net, ifname);\n\t\tput_net(net);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_MAP]) {\n\t\tstruct rtnl_link_ifmap *u_map;\n\t\tstruct ifmap k_map;\n\n\t\tif (!ops->ndo_set_config) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (!netif_device_present(dev)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tu_map = nla_data(tb[IFLA_MAP]);\n\t\tk_map.mem_start = (unsigned long) u_map->mem_start;\n\t\tk_map.mem_end = (unsigned long) u_map->mem_end;\n\t\tk_map.base_addr = (unsigned short) u_map->base_addr;\n\t\tk_map.irq = (unsigned char) u_map->irq;\n\t\tk_map.dma = (unsigned char) u_map->dma;\n\t\tk_map.port = (unsigned char) u_map->port;\n\n\t\terr = ops->ndo_set_config(dev, &k_map);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_ADDRESS]) {\n\t\tstruct sockaddr *sa;\n\t\tint len;\n\n\t\tlen = sizeof(sa_family_t) + dev->addr_len;\n\t\tsa = kmalloc(len, GFP_KERNEL);\n\t\tif (!sa) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout;\n\t\t}\n\t\tsa->sa_family = dev->type;\n\t\tmemcpy(sa->sa_data, nla_data(tb[IFLA_ADDRESS]),\n\t\t       dev->addr_len);\n\t\terr = dev_set_mac_address(dev, sa);\n\t\tkfree(sa);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_MTU]) {\n\t\terr = dev_set_mtu(dev, nla_get_u32(tb[IFLA_MTU]));\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_GROUP]) {\n\t\tdev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));\n\t\tmodified = 1;\n\t}\n\n\t/*\n\t * Interface selected by interface index but interface\n\t * name provided implies that a name change has been\n\t * requested.\n\t */\n\tif (ifm->ifi_index > 0 && ifname[0]) {\n\t\terr = dev_change_name(dev, ifname);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_IFALIAS]) {\n\t\terr = dev_set_alias(dev, nla_data(tb[IFLA_IFALIAS]),\n\t\t\t\t    nla_len(tb[IFLA_IFALIAS]));\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_BROADCAST]) {\n\t\tnla_memcpy(dev->broadcast, tb[IFLA_BROADCAST], dev->addr_len);\n\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\n\t}\n\n\tif (ifm->ifi_flags || ifm->ifi_change) {\n\t\terr = dev_change_flags(dev, rtnl_dev_combine_flags(dev, ifm));\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif (tb[IFLA_MASTER]) {\n\t\terr = do_set_master(dev, nla_get_u32(tb[IFLA_MASTER]));\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_CARRIER]) {\n\t\terr = dev_change_carrier(dev, nla_get_u8(tb[IFLA_CARRIER]));\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_TXQLEN])\n\t\tdev->tx_queue_len = nla_get_u32(tb[IFLA_TXQLEN]);\n\n\tif (tb[IFLA_OPERSTATE])\n\t\tset_operstate(dev, nla_get_u8(tb[IFLA_OPERSTATE]));\n\n\tif (tb[IFLA_LINKMODE]) {\n\t\twrite_lock_bh(&dev_base_lock);\n\t\tdev->link_mode = nla_get_u8(tb[IFLA_LINKMODE]);\n\t\twrite_unlock_bh(&dev_base_lock);\n\t}\n\n\tif (tb[IFLA_VFINFO_LIST]) {\n\t\tstruct nlattr *attr;\n\t\tint rem;\n\t\tnla_for_each_nested(attr, tb[IFLA_VFINFO_LIST], rem) {\n\t\t\tif (nla_type(attr) != IFLA_VF_INFO) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\terr = do_setvfinfo(dev, attr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tmodified = 1;\n\t\t}\n\t}\n\terr = 0;\n\n\tif (tb[IFLA_VF_PORTS]) {\n\t\tstruct nlattr *port[IFLA_PORT_MAX+1];\n\t\tstruct nlattr *attr;\n\t\tint vf;\n\t\tint rem;\n\n\t\terr = -EOPNOTSUPP;\n\t\tif (!ops->ndo_set_vf_port)\n\t\t\tgoto errout;\n\n\t\tnla_for_each_nested(attr, tb[IFLA_VF_PORTS], rem) {\n\t\t\tif (nla_type(attr) != IFLA_VF_PORT)\n\t\t\t\tcontinue;\n\t\t\terr = nla_parse_nested(port, IFLA_PORT_MAX,\n\t\t\t\tattr, ifla_port_policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tif (!port[IFLA_PORT_VF]) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tvf = nla_get_u32(port[IFLA_PORT_VF]);\n\t\t\terr = ops->ndo_set_vf_port(dev, vf, port);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tmodified = 1;\n\t\t}\n\t}\n\terr = 0;\n\n\tif (tb[IFLA_PORT_SELF]) {\n\t\tstruct nlattr *port[IFLA_PORT_MAX+1];\n\n\t\terr = nla_parse_nested(port, IFLA_PORT_MAX,\n\t\t\ttb[IFLA_PORT_SELF], ifla_port_policy);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_port)\n\t\t\terr = ops->ndo_set_vf_port(dev, PORT_SELF_VF, port);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tmodified = 1;\n\t}\n\n\tif (tb[IFLA_AF_SPEC]) {\n\t\tstruct nlattr *af;\n\t\tint rem;\n\n\t\tnla_for_each_nested(af, tb[IFLA_AF_SPEC], rem) {\n\t\t\tconst struct rtnl_af_ops *af_ops;\n\n\t\t\tif (!(af_ops = rtnl_af_lookup(nla_type(af))))\n\t\t\t\tBUG();\n\n\t\t\terr = af_ops->set_link_af(dev, af);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\n\t\t\tmodified = 1;\n\t\t}\n\t}\n\terr = 0;\n\nerrout:\n\tif (err < 0 && modified)\n\t\tnet_warn_ratelimited(\"A link change request failed with some changes committed already. Interface %s may have been left with an inconsistent configuration, please check.\\n\",\n\t\t\t\t     dev->name);\n\n\treturn err;\n}\n\nstatic int rtnl_setlink(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tint err;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tchar ifname[IFNAMSIZ];\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tifname[0] = '\\0';\n\n\terr = -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME])\n\t\tdev = __dev_get_by_name(net, ifname);\n\telse\n\t\tgoto errout;\n\n\tif (dev == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto errout;\n\t}\n\n\terr = validate_linkmsg(dev, tb);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = do_setlink(dev, ifm, tb, ifname, 0);\nerrout:\n\treturn err;\n}\n\nstatic int rtnl_dellink(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct rtnl_link_ops *ops;\n\tstruct net_device *dev;\n\tstruct ifinfomsg *ifm;\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tint err;\n\tLIST_HEAD(list_kill);\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME])\n\t\tdev = __dev_get_by_name(net, ifname);\n\telse\n\t\treturn -EINVAL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tops = dev->rtnl_link_ops;\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tops->dellink(dev, &list_kill);\n\tunregister_netdevice_many(&list_kill);\n\tlist_del(&list_kill);\n\treturn 0;\n}\n\nint rtnl_configure_link(struct net_device *dev, const struct ifinfomsg *ifm)\n{\n\tunsigned int old_flags;\n\tint err;\n\n\told_flags = dev->flags;\n\tif (ifm && (ifm->ifi_flags || ifm->ifi_change)) {\n\t\terr = __dev_change_flags(dev, rtnl_dev_combine_flags(dev, ifm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tdev->rtnl_link_state = RTNL_LINK_INITIALIZED;\n\trtmsg_ifinfo(RTM_NEWLINK, dev, ~0U);\n\n\t__dev_notify_flags(dev, old_flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(rtnl_configure_link);\n\nstruct net_device *rtnl_create_link(struct net *net,\n\tchar *ifname, const struct rtnl_link_ops *ops, struct nlattr *tb[])\n{\n\tint err;\n\tstruct net_device *dev;\n\tunsigned int num_tx_queues = 1;\n\tunsigned int num_rx_queues = 1;\n\n\tif (tb[IFLA_NUM_TX_QUEUES])\n\t\tnum_tx_queues = nla_get_u32(tb[IFLA_NUM_TX_QUEUES]);\n\telse if (ops->get_num_tx_queues)\n\t\tnum_tx_queues = ops->get_num_tx_queues();\n\n\tif (tb[IFLA_NUM_RX_QUEUES])\n\t\tnum_rx_queues = nla_get_u32(tb[IFLA_NUM_RX_QUEUES]);\n\telse if (ops->get_num_rx_queues)\n\t\tnum_rx_queues = ops->get_num_rx_queues();\n\n\terr = -ENOMEM;\n\tdev = alloc_netdev_mqs(ops->priv_size, ifname, ops->setup,\n\t\t\t       num_tx_queues, num_rx_queues);\n\tif (!dev)\n\t\tgoto err;\n\n\tdev_net_set(dev, net);\n\tdev->rtnl_link_ops = ops;\n\tdev->rtnl_link_state = RTNL_LINK_INITIALIZING;\n\n\tif (tb[IFLA_MTU])\n\t\tdev->mtu = nla_get_u32(tb[IFLA_MTU]);\n\tif (tb[IFLA_ADDRESS]) {\n\t\tmemcpy(dev->dev_addr, nla_data(tb[IFLA_ADDRESS]),\n\t\t\t\tnla_len(tb[IFLA_ADDRESS]));\n\t\tdev->addr_assign_type = NET_ADDR_SET;\n\t}\n\tif (tb[IFLA_BROADCAST])\n\t\tmemcpy(dev->broadcast, nla_data(tb[IFLA_BROADCAST]),\n\t\t\t\tnla_len(tb[IFLA_BROADCAST]));\n\tif (tb[IFLA_TXQLEN])\n\t\tdev->tx_queue_len = nla_get_u32(tb[IFLA_TXQLEN]);\n\tif (tb[IFLA_OPERSTATE])\n\t\tset_operstate(dev, nla_get_u8(tb[IFLA_OPERSTATE]));\n\tif (tb[IFLA_LINKMODE])\n\t\tdev->link_mode = nla_get_u8(tb[IFLA_LINKMODE]);\n\tif (tb[IFLA_GROUP])\n\t\tdev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));\n\n\treturn dev;\n\nerr:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(rtnl_create_link);\n\nstatic int rtnl_group_changelink(struct net *net, int group,\n\t\tstruct ifinfomsg *ifm,\n\t\tstruct nlattr **tb)\n{\n\tstruct net_device *dev;\n\tint err;\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\terr = do_setlink(dev, ifm, tb, NULL, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_newlink(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct rtnl_link_ops *ops;\n\tstruct net_device *dev;\n\tstruct ifinfomsg *ifm;\n\tchar kind[MODULE_NAME_LEN];\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tstruct nlattr *linkinfo[IFLA_INFO_MAX+1];\n\tint err;\n\n#ifdef CONFIG_MODULES\nreplay:\n#endif\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tifname[0] = '\\0';\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse {\n\t\tif (ifname[0])\n\t\t\tdev = __dev_get_by_name(net, ifname);\n\t\telse\n\t\t\tdev = NULL;\n\t}\n\n\terr = validate_linkmsg(dev, tb);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_LINKINFO]) {\n\t\terr = nla_parse_nested(linkinfo, IFLA_INFO_MAX,\n\t\t\t\t       tb[IFLA_LINKINFO], ifla_info_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else\n\t\tmemset(linkinfo, 0, sizeof(linkinfo));\n\n\tif (linkinfo[IFLA_INFO_KIND]) {\n\t\tnla_strlcpy(kind, linkinfo[IFLA_INFO_KIND], sizeof(kind));\n\t\tops = rtnl_link_ops_get(kind);\n\t} else {\n\t\tkind[0] = '\\0';\n\t\tops = NULL;\n\t}\n\n\tif (1) {\n\t\tstruct nlattr *attr[ops ? ops->maxtype + 1 : 0], **data = NULL;\n\t\tstruct net *dest_net;\n\n\t\tif (ops) {\n\t\t\tif (ops->maxtype && linkinfo[IFLA_INFO_DATA]) {\n\t\t\t\terr = nla_parse_nested(attr, ops->maxtype,\n\t\t\t\t\t\t       linkinfo[IFLA_INFO_DATA],\n\t\t\t\t\t\t       ops->policy);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\tdata = attr;\n\t\t\t}\n\t\t\tif (ops->validate) {\n\t\t\t\terr = ops->validate(tb, data);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tif (dev) {\n\t\t\tint modified = 0;\n\n\t\t\tif (nlh->nlmsg_flags & NLM_F_EXCL)\n\t\t\t\treturn -EEXIST;\n\t\t\tif (nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tif (linkinfo[IFLA_INFO_DATA]) {\n\t\t\t\tif (!ops || ops != dev->rtnl_link_ops ||\n\t\t\t\t    !ops->changelink)\n\t\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\t\terr = ops->changelink(dev, tb, data);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\tmodified = 1;\n\t\t\t}\n\n\t\t\treturn do_setlink(dev, ifm, tb, ifname, modified);\n\t\t}\n\n\t\tif (!(nlh->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tif (ifm->ifi_index == 0 && tb[IFLA_GROUP])\n\t\t\t\treturn rtnl_group_changelink(net,\n\t\t\t\t\t\tnla_get_u32(tb[IFLA_GROUP]),\n\t\t\t\t\t\tifm, tb);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (tb[IFLA_MAP] || tb[IFLA_MASTER] || tb[IFLA_PROTINFO])\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (!ops) {\n#ifdef CONFIG_MODULES\n\t\t\tif (kind[0]) {\n\t\t\t\t__rtnl_unlock();\n\t\t\t\trequest_module(\"rtnl-link-%s\", kind);\n\t\t\t\trtnl_lock();\n\t\t\t\tops = rtnl_link_ops_get(kind);\n\t\t\t\tif (ops)\n\t\t\t\t\tgoto replay;\n\t\t\t}\n#endif\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (!ifname[0])\n\t\t\tsnprintf(ifname, IFNAMSIZ, \"%s%%d\", ops->kind);\n\n\t\tdest_net = rtnl_link_get_net(net, tb);\n\t\tif (IS_ERR(dest_net))\n\t\t\treturn PTR_ERR(dest_net);\n\n\t\tdev = rtnl_create_link(dest_net, ifname, ops, tb);\n\t\tif (IS_ERR(dev)) {\n\t\t\terr = PTR_ERR(dev);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdev->ifindex = ifm->ifi_index;\n\n\t\tif (ops->newlink)\n\t\t\terr = ops->newlink(net, dev, tb, data);\n\t\telse\n\t\t\terr = register_netdevice(dev);\n\n\t\tif (err < 0 && !IS_ERR(dev))\n\t\t\tfree_netdev(dev);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\terr = rtnl_configure_link(dev, ifm);\n\t\tif (err < 0)\n\t\t\tunregister_netdevice(dev);\nout:\n\t\tput_net(dest_net);\n\t\treturn err;\n\t}\n}\n\nstatic int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tstruct net_device *dev = NULL;\n\tstruct sk_buff *nskb;\n\tint err;\n\tu32 ext_filter_mask = 0;\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\n\tif (tb[IFLA_EXT_MASK])\n\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME])\n\t\tdev = __dev_get_by_name(net, ifname);\n\telse\n\t\treturn -EINVAL;\n\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tnskb = nlmsg_new(if_nlmsg_size(dev, ext_filter_mask), GFP_KERNEL);\n\tif (nskb == NULL)\n\t\treturn -ENOBUFS;\n\n\terr = rtnl_fill_ifinfo(nskb, dev, RTM_NEWLINK, NETLINK_CB(skb).portid,\n\t\t\t       nlh->nlmsg_seq, 0, 0, ext_filter_mask);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in if_nlmsg_size */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(nskb);\n\t} else\n\t\terr = rtnl_unicast(nskb, net, NETLINK_CB(skb).portid);\n\n\treturn err;\n}\n\nstatic u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\tu16 min_ifinfo_dump_size = 0;\n\n\tif (nlmsg_parse(nlh, sizeof(struct rtgenmsg), tb, IFLA_MAX,\n\t\t\tifla_policy) >= 0) {\n\t\tif (tb[IFLA_EXT_MASK])\n\t\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\t}\n\n\tif (!ext_filter_mask)\n\t\treturn NLMSG_GOODSIZE;\n\t/*\n\t * traverse the list of net devices and compute the minimum\n\t * buffer size based upon the filter mask.\n\t */\n\tlist_for_each_entry(dev, &net->dev_base_head, dev_list) {\n\t\tmin_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,\n\t\t\t\t\t     if_nlmsg_size(dev,\n\t\t\t\t\t\t           ext_filter_mask));\n\t}\n\n\treturn min_ifinfo_dump_size;\n}\n\nstatic int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx;\n\tint s_idx = cb->family;\n\n\tif (s_idx == 0)\n\t\ts_idx = 1;\n\tfor (idx = 1; idx <= RTNL_FAMILY_MAX; idx++) {\n\t\tint type = cb->nlh->nlmsg_type-RTM_BASE;\n\t\tif (idx < s_idx || idx == PF_PACKET)\n\t\t\tcontinue;\n\t\tif (rtnl_msg_handlers[idx] == NULL ||\n\t\t    rtnl_msg_handlers[idx][type].dumpit == NULL)\n\t\t\tcontinue;\n\t\tif (idx > s_idx)\n\t\t\tmemset(&cb->args[0], 0, sizeof(cb->args));\n\t\tif (rtnl_msg_handlers[idx][type].dumpit(skb, cb))\n\t\t\tbreak;\n\t}\n\tcb->family = idx;\n\n\treturn skb->len;\n}\n\nvoid rtmsg_ifinfo(int type, struct net_device *dev, unsigned int change)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\tsize_t if_info_size;\n\n\tskb = nlmsg_new((if_info_size = if_nlmsg_size(dev, 0)), GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = rtnl_fill_ifinfo(skb, dev, type, 0, 0, change, 0, 0);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in if_nlmsg_size() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_KERNEL);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n}\nEXPORT_SYMBOL(rtmsg_ifinfo);\n\nstatic int nlmsg_populate_fdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   u8 *addr, u32 pid, u32 seq,\n\t\t\t\t   int type, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ndmsg *ndm;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ndm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tndm = nlmsg_data(nlh);\n\tndm->ndm_family  = AF_BRIDGE;\n\tndm->ndm_pad1\t = 0;\n\tndm->ndm_pad2    = 0;\n\tndm->ndm_flags\t = flags;\n\tndm->ndm_type\t = 0;\n\tndm->ndm_ifindex = dev->ifindex;\n\tndm->ndm_state   = NUD_PERMANENT;\n\n\tif (nla_put(skb, NDA_LLADDR, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\treturn nlmsg_end(skb, nlh);\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic inline size_t rtnl_fdb_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ndmsg)) + nla_total_size(ETH_ALEN);\n}\n\nstatic void rtnl_fdb_notify(struct net_device *dev, u8 *addr, int type)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(rtnl_fdb_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nlmsg_populate_fdb_fill(skb, dev, addr, 0, 0, type, NTF_SELF);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_NEIGH, err);\n}\n\nstatic int rtnl_fdb_add(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ndmsg *ndm;\n\tstruct nlattr *tb[NDA_MAX+1];\n\tstruct net_device *dev;\n\tu8 *addr;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*ndm), tb, NDA_MAX, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_ifindex == 0) {\n\t\tpr_info(\"PF_BRIDGE: RTM_NEWNEIGH with invalid ifindex\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\tif (dev == NULL) {\n\t\tpr_info(\"PF_BRIDGE: RTM_NEWNEIGH with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!tb[NDA_LLADDR] || nla_len(tb[NDA_LLADDR]) != ETH_ALEN) {\n\t\tpr_info(\"PF_BRIDGE: RTM_NEWNEIGH with invalid address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = nla_data(tb[NDA_LLADDR]);\n\tif (!is_valid_ether_addr(addr)) {\n\t\tpr_info(\"PF_BRIDGE: RTM_NEWNEIGH with invalid ether address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = -EOPNOTSUPP;\n\n\t/* Support fdb on master device the net/bridge default case */\n\tif ((!ndm->ndm_flags || ndm->ndm_flags & NTF_MASTER) &&\n\t    (dev->priv_flags & IFF_BRIDGE_PORT)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\t\tconst struct net_device_ops *ops = br_dev->netdev_ops;\n\n\t\terr = ops->ndo_fdb_add(ndm, tb, dev, addr, nlh->nlmsg_flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t\telse\n\t\t\tndm->ndm_flags &= ~NTF_MASTER;\n\t}\n\n\t/* Embedded bridge, macvlan, and any other device support */\n\tif ((ndm->ndm_flags & NTF_SELF) && dev->netdev_ops->ndo_fdb_add) {\n\t\terr = dev->netdev_ops->ndo_fdb_add(ndm, tb,\n\t\t\t\t\t\t   dev, addr,\n\t\t\t\t\t\t   nlh->nlmsg_flags);\n\n\t\tif (!err) {\n\t\t\trtnl_fdb_notify(dev, addr, RTM_NEWNEIGH);\n\t\t\tndm->ndm_flags &= ~NTF_SELF;\n\t\t}\n\t}\nout:\n\treturn err;\n}\n\nstatic int rtnl_fdb_del(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ndmsg *ndm;\n\tstruct nlattr *tb[NDA_MAX+1];\n\tstruct net_device *dev;\n\tint err = -EINVAL;\n\t__u8 *addr;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\terr = nlmsg_parse(nlh, sizeof(*ndm), tb, NDA_MAX, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_ifindex == 0) {\n\t\tpr_info(\"PF_BRIDGE: RTM_DELNEIGH with invalid ifindex\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\tif (dev == NULL) {\n\t\tpr_info(\"PF_BRIDGE: RTM_DELNEIGH with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!tb[NDA_LLADDR] || nla_len(tb[NDA_LLADDR]) != ETH_ALEN) {\n\t\tpr_info(\"PF_BRIDGE: RTM_DELNEIGH with invalid address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = nla_data(tb[NDA_LLADDR]);\n\tif (!is_valid_ether_addr(addr)) {\n\t\tpr_info(\"PF_BRIDGE: RTM_DELNEIGH with invalid ether address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = -EOPNOTSUPP;\n\n\t/* Support fdb on master device the net/bridge default case */\n\tif ((!ndm->ndm_flags || ndm->ndm_flags & NTF_MASTER) &&\n\t    (dev->priv_flags & IFF_BRIDGE_PORT)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\t\tconst struct net_device_ops *ops = br_dev->netdev_ops;\n\n\t\tif (ops->ndo_fdb_del)\n\t\t\terr = ops->ndo_fdb_del(ndm, tb, dev, addr);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t\telse\n\t\t\tndm->ndm_flags &= ~NTF_MASTER;\n\t}\n\n\t/* Embedded bridge, macvlan, and any other device support */\n\tif ((ndm->ndm_flags & NTF_SELF) && dev->netdev_ops->ndo_fdb_del) {\n\t\terr = dev->netdev_ops->ndo_fdb_del(ndm, tb, dev, addr);\n\n\t\tif (!err) {\n\t\t\trtnl_fdb_notify(dev, addr, RTM_DELNEIGH);\n\t\t\tndm->ndm_flags &= ~NTF_SELF;\n\t\t}\n\t}\nout:\n\treturn err;\n}\n\nstatic int nlmsg_populate_fdb(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb,\n\t\t\t      struct net_device *dev,\n\t\t\t      int *idx,\n\t\t\t      struct netdev_hw_addr_list *list)\n{\n\tstruct netdev_hw_addr *ha;\n\tint err;\n\tu32 portid, seq;\n\n\tportid = NETLINK_CB(cb->skb).portid;\n\tseq = cb->nlh->nlmsg_seq;\n\n\tlist_for_each_entry(ha, &list->list, list) {\n\t\tif (*idx < cb->args[0])\n\t\t\tgoto skip;\n\n\t\terr = nlmsg_populate_fdb_fill(skb, dev, ha->addr,\n\t\t\t\t\t      portid, seq,\n\t\t\t\t\t      RTM_NEWNEIGH, NTF_SELF);\n\t\tif (err < 0)\n\t\t\treturn err;\nskip:\n\t\t*idx += 1;\n\t}\n\treturn 0;\n}\n\n/**\n * ndo_dflt_fdb_dump - default netdevice operation to dump an FDB table.\n * @nlh: netlink message header\n * @dev: netdevice\n *\n * Default netdevice operation to dump the existing unicast address list.\n * Returns zero on success.\n */\nint ndo_dflt_fdb_dump(struct sk_buff *skb,\n\t\t      struct netlink_callback *cb,\n\t\t      struct net_device *dev,\n\t\t      int idx)\n{\n\tint err;\n\n\tnetif_addr_lock_bh(dev);\n\terr = nlmsg_populate_fdb(skb, cb, dev, &idx, &dev->uc);\n\tif (err)\n\t\tgoto out;\n\tnlmsg_populate_fdb(skb, cb, dev, &idx, &dev->mc);\nout:\n\tnetif_addr_unlock_bh(dev);\n\treturn idx;\n}\nEXPORT_SYMBOL(ndo_dflt_fdb_dump);\n\nstatic int rtnl_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_BRIDGE_PORT) {\n\t\t\tstruct net_device *br_dev;\n\t\t\tconst struct net_device_ops *ops;\n\n\t\t\tbr_dev = netdev_master_upper_dev_get(dev);\n\t\t\tops = br_dev->netdev_ops;\n\t\t\tif (ops->ndo_fdb_dump)\n\t\t\t\tidx = ops->ndo_fdb_dump(skb, cb, dev, idx);\n\t\t}\n\n\t\tif (dev->netdev_ops->ndo_fdb_dump)\n\t\t\tidx = dev->netdev_ops->ndo_fdb_dump(skb, cb, dev, idx);\n\t}\n\trcu_read_unlock();\n\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nint ndo_dflt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t    struct net_device *dev, u16 mode)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ifinfomsg *ifm;\n\tstruct nlattr *br_afspec;\n\tu8 operstate = netif_running(dev) ? dev->operstate : IF_OPER_DOWN;\n\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\tnlh = nlmsg_put(skb, pid, seq, RTM_NEWLINK, sizeof(*ifm), NLM_F_MULTI);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifi_family = AF_BRIDGE;\n\tifm->__ifi_pad = 0;\n\tifm->ifi_type = dev->type;\n\tifm->ifi_index = dev->ifindex;\n\tifm->ifi_flags = dev_get_flags(dev);\n\tifm->ifi_change = 0;\n\n\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    nla_put_u8(skb, IFLA_OPERSTATE, operstate) ||\n\t    (br_dev &&\n\t     nla_put_u32(skb, IFLA_MASTER, br_dev->ifindex)) ||\n\t    (dev->addr_len &&\n\t     nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||\n\t    (dev->ifindex != dev->iflink &&\n\t     nla_put_u32(skb, IFLA_LINK, dev->iflink)))\n\t\tgoto nla_put_failure;\n\n\tbr_afspec = nla_nest_start(skb, IFLA_AF_SPEC);\n\tif (!br_afspec)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, IFLA_BRIDGE_FLAGS, BRIDGE_FLAGS_SELF) ||\n\t    nla_put_u16(skb, IFLA_BRIDGE_MODE, mode)) {\n\t\tnla_nest_cancel(skb, br_afspec);\n\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, br_afspec);\n\n\treturn nlmsg_end(skb, nlh);\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL(ndo_dflt_bridge_getlink);\n\nstatic int rtnl_bridge_getlink(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tint idx = 0;\n\tu32 portid = NETLINK_CB(cb->skb).portid;\n\tu32 seq = cb->nlh->nlmsg_seq;\n\tstruct nlattr *extfilt;\n\tu32 filter_mask = 0;\n\n\textfilt = nlmsg_find_attr(cb->nlh, sizeof(struct rtgenmsg),\n\t\t\t\t  IFLA_EXT_MASK);\n\tif (extfilt)\n\t\tfilter_mask = nla_get_u32(extfilt);\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tconst struct net_device_ops *ops = dev->netdev_ops;\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (br_dev && br_dev->netdev_ops->ndo_bridge_getlink) {\n\t\t\tif (idx >= cb->args[0] &&\n\t\t\t    br_dev->netdev_ops->ndo_bridge_getlink(\n\t\t\t\t    skb, portid, seq, dev, filter_mask) < 0)\n\t\t\t\tbreak;\n\t\t\tidx++;\n\t\t}\n\n\t\tif (ops->ndo_bridge_getlink) {\n\t\t\tif (idx >= cb->args[0] &&\n\t\t\t    ops->ndo_bridge_getlink(skb, portid, seq, dev,\n\t\t\t\t\t\t    filter_mask) < 0)\n\t\t\t\tbreak;\n\t\t\tidx++;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\n\treturn skb->len;\n}\n\nstatic inline size_t bridge_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t\t+ nla_total_size(IFNAMSIZ)\t/* IFLA_IFNAME */\n\t\t+ nla_total_size(MAX_ADDR_LEN)\t/* IFLA_ADDRESS */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_MASTER */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_MTU */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_LINK */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_OPERSTATE */\n\t\t+ nla_total_size(sizeof(u8))\t/* IFLA_PROTINFO */\n\t\t+ nla_total_size(sizeof(struct nlattr))\t/* IFLA_AF_SPEC */\n\t\t+ nla_total_size(sizeof(u16))\t/* IFLA_BRIDGE_FLAGS */\n\t\t+ nla_total_size(sizeof(u16));\t/* IFLA_BRIDGE_MODE */\n}\n\nstatic int rtnl_bridge_notify(struct net_device *dev, u16 flags)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\tstruct sk_buff *skb;\n\tint err = -EOPNOTSUPP;\n\n\tskb = nlmsg_new(bridge_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tif ((!flags || (flags & BRIDGE_FLAGS_MASTER)) &&\n\t    br_dev && br_dev->netdev_ops->ndo_bridge_getlink) {\n\t\terr = br_dev->netdev_ops->ndo_bridge_getlink(skb, 0, 0, dev, 0);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif ((flags & BRIDGE_FLAGS_SELF) &&\n\t    dev->netdev_ops->ndo_bridge_getlink) {\n\t\terr = dev->netdev_ops->ndo_bridge_getlink(skb, 0, 0, dev, 0);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\n\treturn 0;\nerrout:\n\tWARN_ON(err == -EMSGSIZE);\n\tkfree_skb(skb);\n\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n\treturn err;\n}\n\nstatic int rtnl_bridge_setlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tstruct nlattr *br_spec, *attr = NULL;\n\tint rem, err = -EOPNOTSUPP;\n\tu16 oflags, flags = 0;\n\tbool have_flags = false;\n\n\tif (nlmsg_len(nlh) < sizeof(*ifm))\n\t\treturn -EINVAL;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_family != AF_BRIDGE)\n\t\treturn -EPFNOSUPPORT;\n\n\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\tif (!dev) {\n\t\tpr_info(\"PF_BRIDGE: RTM_SETLINK with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (br_spec) {\n\t\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_FLAGS) {\n\t\t\t\thave_flags = true;\n\t\t\t\tflags = nla_get_u16(attr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\toflags = flags;\n\n\tif (!flags || (flags & BRIDGE_FLAGS_MASTER)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (!br_dev || !br_dev->netdev_ops->ndo_bridge_setlink) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = br_dev->netdev_ops->ndo_bridge_setlink(dev, nlh);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tflags &= ~BRIDGE_FLAGS_MASTER;\n\t}\n\n\tif ((flags & BRIDGE_FLAGS_SELF)) {\n\t\tif (!dev->netdev_ops->ndo_bridge_setlink)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\terr = dev->netdev_ops->ndo_bridge_setlink(dev, nlh);\n\n\t\tif (!err)\n\t\t\tflags &= ~BRIDGE_FLAGS_SELF;\n\t}\n\n\tif (have_flags)\n\t\tmemcpy(nla_data(attr), &flags, sizeof(flags));\n\t/* Generate event to notify upper layer of bridge change */\n\tif (!err)\n\t\terr = rtnl_bridge_notify(dev, oflags);\nout:\n\treturn err;\n}\n\nstatic int rtnl_bridge_dellink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tstruct nlattr *br_spec, *attr = NULL;\n\tint rem, err = -EOPNOTSUPP;\n\tu16 oflags, flags = 0;\n\tbool have_flags = false;\n\n\tif (nlmsg_len(nlh) < sizeof(*ifm))\n\t\treturn -EINVAL;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_family != AF_BRIDGE)\n\t\treturn -EPFNOSUPPORT;\n\n\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\tif (!dev) {\n\t\tpr_info(\"PF_BRIDGE: RTM_SETLINK with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (br_spec) {\n\t\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_FLAGS) {\n\t\t\t\thave_flags = true;\n\t\t\t\tflags = nla_get_u16(attr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\toflags = flags;\n\n\tif (!flags || (flags & BRIDGE_FLAGS_MASTER)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (!br_dev || !br_dev->netdev_ops->ndo_bridge_dellink) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = br_dev->netdev_ops->ndo_bridge_dellink(dev, nlh);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tflags &= ~BRIDGE_FLAGS_MASTER;\n\t}\n\n\tif ((flags & BRIDGE_FLAGS_SELF)) {\n\t\tif (!dev->netdev_ops->ndo_bridge_dellink)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\terr = dev->netdev_ops->ndo_bridge_dellink(dev, nlh);\n\n\t\tif (!err)\n\t\t\tflags &= ~BRIDGE_FLAGS_SELF;\n\t}\n\n\tif (have_flags)\n\t\tmemcpy(nla_data(attr), &flags, sizeof(flags));\n\t/* Generate event to notify upper layer of bridge change */\n\tif (!err)\n\t\terr = rtnl_bridge_notify(dev, oflags);\nout:\n\treturn err;\n}\n\n/* Protected by RTNL sempahore.  */\nstatic struct rtattr **rta_buf;\nstatic int rtattr_max;\n\n/* Process one rtnetlink message. */\n\nstatic int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\trtnl_doit_func doit;\n\tint sz_idx, kind;\n\tint min_len;\n\tint family;\n\tint type;\n\tint err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > RTM_MAX)\n\t\treturn -EOPNOTSUPP;\n\n\ttype -= RTM_BASE;\n\n\t/* All the messages must have at least 1 byte length */\n\tif (nlh->nlmsg_len < NLMSG_LENGTH(sizeof(struct rtgenmsg)))\n\t\treturn 0;\n\n\tfamily = ((struct rtgenmsg *)NLMSG_DATA(nlh))->rtgen_family;\n\tsz_idx = type>>2;\n\tkind = type&3;\n\n\tif (kind != 2 && !ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (kind == 2 && nlh->nlmsg_flags&NLM_F_DUMP) {\n\t\tstruct sock *rtnl;\n\t\trtnl_dumpit_func dumpit;\n\t\trtnl_calcit_func calcit;\n\t\tu16 min_dump_alloc = 0;\n\n\t\tdumpit = rtnl_get_dumpit(family, type);\n\t\tif (dumpit == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\t\tcalcit = rtnl_get_calcit(family, type);\n\t\tif (calcit)\n\t\t\tmin_dump_alloc = calcit(skb, nlh);\n\n\t\t__rtnl_unlock();\n\t\trtnl = net->rtnl;\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump\t\t= dumpit,\n\t\t\t\t.min_dump_alloc\t= min_dump_alloc,\n\t\t\t};\n\t\t\terr = netlink_dump_start(rtnl, skb, nlh, &c);\n\t\t}\n\t\trtnl_lock();\n\t\treturn err;\n\t}\n\n\tmemset(rta_buf, 0, (rtattr_max * sizeof(struct rtattr *)));\n\n\tmin_len = rtm_min[sz_idx];\n\tif (nlh->nlmsg_len < min_len)\n\t\treturn -EINVAL;\n\n\tif (nlh->nlmsg_len > min_len) {\n\t\tint attrlen = nlh->nlmsg_len - NLMSG_ALIGN(min_len);\n\t\tstruct rtattr *attr = (void *)nlh + NLMSG_ALIGN(min_len);\n\n\t\twhile (RTA_OK(attr, attrlen)) {\n\t\t\tunsigned int flavor = attr->rta_type;\n\t\t\tif (flavor) {\n\t\t\t\tif (flavor > rta_max[sz_idx])\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\trta_buf[flavor-1] = attr;\n\t\t\t}\n\t\t\tattr = RTA_NEXT(attr, attrlen);\n\t\t}\n\t}\n\n\tdoit = rtnl_get_doit(family, type);\n\tif (doit == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\treturn doit(skb, nlh, (void *)&rta_buf[0]);\n}\n\nstatic void rtnetlink_rcv(struct sk_buff *skb)\n{\n\trtnl_lock();\n\tnetlink_rcv_skb(skb, &rtnetlink_rcv_msg);\n\trtnl_unlock();\n}\n\nstatic int rtnetlink_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = ptr;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\tcase NETDEV_DOWN:\n\tcase NETDEV_PRE_UP:\n\tcase NETDEV_POST_INIT:\n\tcase NETDEV_REGISTER:\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\tcase NETDEV_GOING_DOWN:\n\tcase NETDEV_UNREGISTER:\n\tcase NETDEV_UNREGISTER_FINAL:\n\tcase NETDEV_RELEASE:\n\tcase NETDEV_JOIN:\n\t\tbreak;\n\tdefault:\n\t\trtmsg_ifinfo(RTM_NEWLINK, dev, 0);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rtnetlink_dev_notifier = {\n\t.notifier_call\t= rtnetlink_event,\n};\n\n\nstatic int __net_init rtnetlink_net_init(struct net *net)\n{\n\tstruct sock *sk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t\t= RTNLGRP_MAX,\n\t\t.input\t\t= rtnetlink_rcv,\n\t\t.cb_mutex\t= &rtnl_mutex,\n\t\t.flags\t\t= NL_CFG_F_NONROOT_RECV,\n\t};\n\n\tsk = netlink_kernel_create(net, NETLINK_ROUTE, &cfg);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tnet->rtnl = sk;\n\treturn 0;\n}\n\nstatic void __net_exit rtnetlink_net_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->rtnl);\n\tnet->rtnl = NULL;\n}\n\nstatic struct pernet_operations rtnetlink_net_ops = {\n\t.init = rtnetlink_net_init,\n\t.exit = rtnetlink_net_exit,\n};\n\nvoid __init rtnetlink_init(void)\n{\n\tint i;\n\n\trtattr_max = 0;\n\tfor (i = 0; i < ARRAY_SIZE(rta_max); i++)\n\t\tif (rta_max[i] > rtattr_max)\n\t\t\trtattr_max = rta_max[i];\n\trta_buf = kmalloc(rtattr_max * sizeof(struct rtattr *), GFP_KERNEL);\n\tif (!rta_buf)\n\t\tpanic(\"rtnetlink_init: cannot allocate rta_buf\\n\");\n\n\tif (register_pernet_subsys(&rtnetlink_net_ops))\n\t\tpanic(\"rtnetlink_init: cannot initialize rtnetlink\\n\");\n\n\tregister_netdevice_notifier(&rtnetlink_dev_notifier);\n\n\trtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,\n\t\t      rtnl_dump_ifinfo, rtnl_calcit);\n\trtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL, NULL);\n\trtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL, NULL);\n\trtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL, NULL);\n\n\trtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all, NULL);\n\trtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all, NULL);\n\n\trtnl_register(PF_BRIDGE, RTM_NEWNEIGH, rtnl_fdb_add, NULL, NULL);\n\trtnl_register(PF_BRIDGE, RTM_DELNEIGH, rtnl_fdb_del, NULL, NULL);\n\trtnl_register(PF_BRIDGE, RTM_GETNEIGH, NULL, rtnl_fdb_dump, NULL);\n\n\trtnl_register(PF_BRIDGE, RTM_GETLINK, NULL, rtnl_bridge_getlink, NULL);\n\trtnl_register(PF_BRIDGE, RTM_DELLINK, rtnl_bridge_dellink, NULL, NULL);\n\trtnl_register(PF_BRIDGE, RTM_SETLINK, rtnl_bridge_setlink, NULL, NULL);\n}\n\n"], "filenames": ["net/core/rtnetlink.c"], "buggy_code_start_loc": [981], "buggy_code_end_loc": [981], "fixing_code_start_loc": [982], "fixing_code_end_loc": [983], "type": "CWE-399", "message": "The rtnl_fill_ifinfo function in net/core/rtnetlink.c in the Linux kernel before 3.8.4 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel stack memory via a crafted application.", "other": {"cve": {"id": "CVE-2013-2635", "sourceIdentifier": "cve@mitre.org", "published": "2013-03-22T11:59:11.993", "lastModified": "2014-02-07T04:47:16.560", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The rtnl_fill_ifinfo function in net/core/rtnetlink.c in the Linux kernel before 3.8.4 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."}, {"lang": "es", "value": "La funci\u00f3n rtnl_fill_ifinfo en net/core/rtnetlink.c en el kernel de Linux anterior a  v3.8.4 no inicializa un cierto miembro de la  estructura, lo que permite a atacantes locales obtener informaci\u00f3n sensible desde la memoria del kernel mediante una aplicaci\u00f3n especialmente dise\u00f1ada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.8.3", "matchCriteriaId": "7A40E2A8-BBC3-4763-B150-9193F30E9DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=84d73cd3fb142bf1298a8c13fd4ca50fd2432372", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-07/msg00018.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-12/msg00129.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1051.html", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.8.4", "source": "cve@mitre.org"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:176", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2013/03/20/1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-1809-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-1811-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-1812-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-1813-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-1814-1", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=923652", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/84d73cd3fb142bf1298a8c13fd4ca50fd2432372", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/84d73cd3fb142bf1298a8c13fd4ca50fd2432372"}}