{"buggy_code": ["/****************************************************************************\n**\n** Copyright (C) 2021 The Qt Company Ltd.\n** Contact: https://www.qt.io/licensing/\n**\n** This file is part of the Qt SVG module of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and The Qt Company. For licensing terms\n** and conditions see https://www.qt.io/terms-conditions. For further\n** information use the contact form at https://www.qt.io/contact-us.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 3 as published by the Free Software\n** Foundation and appearing in the file LICENSE.LGPL3 included in the\n** packaging of this file. Please review the following information to\n** ensure the GNU Lesser General Public License version 3 requirements\n** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.\n**\n** GNU General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU\n** General Public License version 2.0 or (at your option) the GNU General\n** Public license version 3 or any later version approved by the KDE Free\n** Qt Foundation. The licenses are as published by the Free Software\n** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3\n** included in the packaging of this file. Please review the following\n** information to ensure the GNU General Public License requirements will\n** be met: https://www.gnu.org/licenses/gpl-2.0.html and\n** https://www.gnu.org/licenses/gpl-3.0.html.\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#include \"qplatformdefs.h\"\n\n#include \"qsvghandler_p.h\"\n\n#include \"qsvgtinydocument_p.h\"\n#include \"qsvgstructure_p.h\"\n#include \"qsvggraphics_p.h\"\n#include \"qsvgnode_p.h\"\n#include \"qsvgfont_p.h\"\n\n#include \"qpen.h\"\n#include \"qpainterpath.h\"\n#include \"qbrush.h\"\n#include \"qcolor.h\"\n#include \"qtextformat.h\"\n#include \"qlist.h\"\n#include \"qfileinfo.h\"\n#include \"qfile.h\"\n#include \"qdir.h\"\n#include \"qdebug.h\"\n#include \"qmath.h\"\n#include \"qnumeric.h\"\n#include <qregularexpression.h>\n#include \"qtransform.h\"\n#include \"qvarlengtharray.h\"\n#include \"private/qmath_p.h\"\n\n#include \"float.h\"\n#include <cmath>\n\nQT_BEGIN_NAMESPACE\n\nQ_LOGGING_CATEGORY(lcSvgHandler, \"qt.svg\")\n\nstatic const char *qt_inherit_text = \"inherit\";\n#define QT_INHERIT QLatin1String(qt_inherit_text)\n\nstatic QByteArray prefixMessage(const QByteArray &msg, const QXmlStreamReader *r)\n{\n    QByteArray result;\n    if (r) {\n        if (const QFile *file = qobject_cast<const QFile *>(r->device()))\n            result.append(QFile::encodeName(QDir::toNativeSeparators(file->fileName())));\n        else\n            result.append(QByteArrayLiteral(\"<input>\"));\n        result.append(':');\n        result.append(QByteArray::number(r->lineNumber()));\n        if (const qint64 column = r->columnNumber()) {\n            result.append(':');\n            result.append(QByteArray::number(column));\n        }\n        result.append(QByteArrayLiteral(\": \"));\n    }\n    result.append(msg);\n    return result;\n}\n\nstatic inline QByteArray msgProblemParsing(const QString &localName, const QXmlStreamReader *r)\n{\n    return prefixMessage(QByteArrayLiteral(\"Problem parsing \") + localName.toLocal8Bit(), r);\n}\n\nstatic inline QByteArray msgCouldNotResolveProperty(const QString &id, const QXmlStreamReader *r)\n{\n    return prefixMessage(QByteArrayLiteral(\"Could not resolve property: \") + id.toLocal8Bit(), r);\n}\n\n// ======== duplicated from qcolor_p\n\nstatic inline int qsvg_h2i(char hex, bool *ok = nullptr)\n{\n    if (hex >= '0' && hex <= '9')\n        return hex - '0';\n    if (hex >= 'a' && hex <= 'f')\n        return hex - 'a' + 10;\n    if (hex >= 'A' && hex <= 'F')\n        return hex - 'A' + 10;\n    if (ok)\n        *ok = false;\n    return -1;\n}\n\nstatic inline int qsvg_hex2int(const char *s, bool *ok = nullptr)\n{\n    return (qsvg_h2i(s[0], ok) * 16) | qsvg_h2i(s[1], ok);\n}\n\nstatic inline int qsvg_hex2int(char s, bool *ok = nullptr)\n{\n    int h = qsvg_h2i(s, ok);\n    return (h * 16) | h;\n}\n\nbool qsvg_get_hex_rgb(const char *name, QRgb *rgb)\n{\n    if(name[0] != '#')\n        return false;\n    name++;\n    const size_t len = qstrlen(name);\n    int r, g, b;\n    bool ok = true;\n    if (len == 12) {\n        r = qsvg_hex2int(name, &ok);\n        g = qsvg_hex2int(name + 4, &ok);\n        b = qsvg_hex2int(name + 8, &ok);\n    } else if (len == 9) {\n        r = qsvg_hex2int(name, &ok);\n        g = qsvg_hex2int(name + 3, &ok);\n        b = qsvg_hex2int(name + 6, &ok);\n    } else if (len == 6) {\n        r = qsvg_hex2int(name, &ok);\n        g = qsvg_hex2int(name + 2, &ok);\n        b = qsvg_hex2int(name + 4, &ok);\n    } else if (len == 3) {\n        r = qsvg_hex2int(name[0], &ok);\n        g = qsvg_hex2int(name[1], &ok);\n        b = qsvg_hex2int(name[2], &ok);\n    } else {\n        r = g = b = -1;\n    }\n    if ((uint)r > 255 || (uint)g > 255 || (uint)b > 255 || !ok) {\n        *rgb = 0;\n        return false;\n    }\n    *rgb = qRgb(r, g ,b);\n    return true;\n}\n\nbool qsvg_get_hex_rgb(const QChar *str, int len, QRgb *rgb)\n{\n    if (len > 13)\n        return false;\n    char tmp[16];\n    for(int i = 0; i < len; ++i)\n        tmp[i] = str[i].toLatin1();\n    tmp[len] = 0;\n    return qsvg_get_hex_rgb(tmp, rgb);\n}\n\n// ======== end of qcolor_p duplicate\n\nstatic bool parsePathDataFast(QStringView data, QPainterPath &path);\n\nstatic inline QString someId(const QXmlStreamAttributes &attributes)\n{\n    QString id = attributes.value(QLatin1String(\"id\")).toString();\n    if (id.isEmpty())\n        id = attributes.value(QLatin1String(\"xml:id\")).toString();\n    return id;\n}\n\nstruct QSvgAttributes\n{\n    QSvgAttributes(const QXmlStreamAttributes &xmlAttributes, QSvgHandler *handler);\n\n    QString id;\n\n    QStringView color;\n    QStringView colorOpacity;\n    QStringView fill;\n    QStringView fillRule;\n    QStringView fillOpacity;\n    QStringView stroke;\n    QStringView strokeDashArray;\n    QStringView strokeDashOffset;\n    QStringView strokeLineCap;\n    QStringView strokeLineJoin;\n    QStringView strokeMiterLimit;\n    QStringView strokeOpacity;\n    QStringView strokeWidth;\n    QStringView vectorEffect;\n    QStringView fontFamily;\n    QStringView fontSize;\n    QStringView fontStyle;\n    QStringView fontWeight;\n    QStringView fontVariant;\n    QStringView textAnchor;\n    QStringView transform;\n    QStringView visibility;\n    QStringView opacity;\n    QStringView compOp;\n    QStringView display;\n    QStringView offset;\n    QStringView stopColor;\n    QStringView stopOpacity;\n    QStringView imageRendering;\n\n#ifndef QT_NO_CSSPARSER\n    QList<QSvgCssAttribute> m_cssAttributes;\n#endif\n};\n\nQSvgAttributes::QSvgAttributes(const QXmlStreamAttributes &xmlAttributes, QSvgHandler *handler)\n{\n#ifndef QT_NO_CSSPARSER\n    QStringView style = xmlAttributes.value(QLatin1String(\"style\"));\n    if (!style.isEmpty()) {\n        handler->parseCSStoXMLAttrs(style.toString(), &m_cssAttributes);\n        for (int j = 0; j < m_cssAttributes.count(); ++j) {\n            const QSvgCssAttribute &attribute = m_cssAttributes.at(j);\n            QStringView name = attribute.name;\n            QStringView value = attribute.value;\n            if (name.isEmpty())\n                continue;\n\n            switch (name.at(0).unicode()) {\n\n            case 'c':\n                if (name == QLatin1String(\"color\"))\n                    color = value;\n                else if (name == QLatin1String(\"color-opacity\"))\n                    colorOpacity = value;\n                else if (name == QLatin1String(\"comp-op\"))\n                    compOp = value;\n                break;\n\n            case 'd':\n                if (name == QLatin1String(\"display\"))\n                    display = value;\n                break;\n\n            case 'f':\n                if (name == QLatin1String(\"fill\"))\n                    fill = value;\n                else if (name == QLatin1String(\"fill-rule\"))\n                    fillRule = value;\n                else if (name == QLatin1String(\"fill-opacity\"))\n                    fillOpacity = value;\n                else if (name == QLatin1String(\"font-family\"))\n                    fontFamily = value;\n                else if (name == QLatin1String(\"font-size\"))\n                    fontSize = value;\n                else if (name == QLatin1String(\"font-style\"))\n                    fontStyle = value;\n                else if (name == QLatin1String(\"font-weight\"))\n                    fontWeight = value;\n                else if (name == QLatin1String(\"font-variant\"))\n                    fontVariant = value;\n                break;\n            case 'i':\n                if (name == QLatin1String(\"image-rendering\"))\n                    imageRendering = value;\n                break;\n\n            case 'o':\n                if (name == QLatin1String(\"opacity\"))\n                    opacity = value;\n                else if (name == QLatin1String(\"offset\"))\n                    offset = value;\n                break;\n\n            case 's':\n                if (name.length() > 5 && name.mid(1, 5) == QLatin1String(\"troke\")) {\n                    QStringView strokeRef = name.mid(6, name.length() - 6);\n                    if (strokeRef.isEmpty())\n                        stroke = value;\n                    else if (strokeRef == QLatin1String(\"-dasharray\"))\n                        strokeDashArray = value;\n                    else if (strokeRef == QLatin1String(\"-dashoffset\"))\n                        strokeDashOffset = value;\n                    else if (strokeRef == QLatin1String(\"-linecap\"))\n                        strokeLineCap = value;\n                    else if (strokeRef == QLatin1String(\"-linejoin\"))\n                        strokeLineJoin = value;\n                    else if (strokeRef == QLatin1String(\"-miterlimit\"))\n                        strokeMiterLimit = value;\n                    else if (strokeRef == QLatin1String(\"-opacity\"))\n                        strokeOpacity = value;\n                    else if (strokeRef == QLatin1String(\"-width\"))\n                        strokeWidth = value;\n                }\n                else if (name == QLatin1String(\"stop-color\"))\n                    stopColor = value;\n                else if (name == QLatin1String(\"stop-opacity\"))\n                    stopOpacity = value;\n                break;\n\n            case 't':\n                if (name == QLatin1String(\"text-anchor\"))\n                    textAnchor = value;\n                else if (name == QLatin1String(\"transform\"))\n                    transform = value;\n                break;\n\n            case 'v':\n                if (name == QLatin1String(\"vector-effect\"))\n                    vectorEffect = value;\n                else if (name == QLatin1String(\"visibility\"))\n                    visibility = value;\n                break;\n\n            default:\n                break;\n           }\n        }\n    }\n#else\n    Q_UNUSED(handler);\n#endif // QT_NO_CSSPARSER\n\n    for (int i = 0; i < xmlAttributes.count(); ++i) {\n        const QXmlStreamAttribute &attribute = xmlAttributes.at(i);\n        QStringView name = attribute.qualifiedName();\n        if (name.isEmpty())\n            continue;\n        QStringView value = attribute.value();\n\n        switch (name.at(0).unicode()) {\n\n        case 'c':\n            if (name == QLatin1String(\"color\"))\n                color = value;\n            else if (name == QLatin1String(\"color-opacity\"))\n                colorOpacity = value;\n            else if (name == QLatin1String(\"comp-op\"))\n                compOp = value;\n            break;\n\n        case 'd':\n            if (name == QLatin1String(\"display\"))\n                display = value;\n            break;\n\n        case 'f':\n            if (name == QLatin1String(\"fill\"))\n                fill = value;\n            else if (name == QLatin1String(\"fill-rule\"))\n                fillRule = value;\n            else if (name == QLatin1String(\"fill-opacity\"))\n                fillOpacity = value;\n            else if (name == QLatin1String(\"font-family\"))\n                fontFamily = value;\n            else if (name == QLatin1String(\"font-size\"))\n                fontSize = value;\n            else if (name == QLatin1String(\"font-style\"))\n                fontStyle = value;\n            else if (name == QLatin1String(\"font-weight\"))\n                fontWeight = value;\n            else if (name == QLatin1String(\"font-variant\"))\n                fontVariant = value;\n            break;\n\n        case 'i':\n            if (name == QLatin1String(\"id\"))\n                id = value.toString();\n            else if (name == QLatin1String(\"image-rendering\"))\n                imageRendering = value;\n            break;\n\n        case 'o':\n            if (name == QLatin1String(\"opacity\"))\n                opacity = value;\n            if (name == QLatin1String(\"offset\"))\n                offset = value;\n            break;\n\n        case 's':\n            if (name.length() > 5 && name.mid(1, 5) == QLatin1String(\"troke\")) {\n                QStringView strokeRef = name.mid(6, name.length() - 6);\n                if (strokeRef.isEmpty())\n                    stroke = value;\n                else if (strokeRef == QLatin1String(\"-dasharray\"))\n                    strokeDashArray = value;\n                else if (strokeRef == QLatin1String(\"-dashoffset\"))\n                    strokeDashOffset = value;\n                else if (strokeRef == QLatin1String(\"-linecap\"))\n                    strokeLineCap = value;\n                else if (strokeRef == QLatin1String(\"-linejoin\"))\n                    strokeLineJoin = value;\n                else if (strokeRef == QLatin1String(\"-miterlimit\"))\n                    strokeMiterLimit = value;\n                else if (strokeRef == QLatin1String(\"-opacity\"))\n                    strokeOpacity = value;\n                else if (strokeRef == QLatin1String(\"-width\"))\n                    strokeWidth = value;\n            }\n            else if (name == QLatin1String(\"stop-color\"))\n                stopColor = value;\n            else if (name == QLatin1String(\"stop-opacity\"))\n                stopOpacity = value;\n            break;\n\n        case 't':\n            if (name == QLatin1String(\"text-anchor\"))\n                textAnchor = value;\n            else if (name == QLatin1String(\"transform\"))\n                transform = value;\n            break;\n\n        case 'v':\n            if (name == QLatin1String(\"vector-effect\"))\n                vectorEffect = value;\n            else if (name == QLatin1String(\"visibility\"))\n                visibility = value;\n            break;\n\n        case 'x':\n            if (name == QLatin1String(\"xml:id\") && id.isEmpty())\n                id = value.toString();\n            break;\n\n        default:\n            break;\n        }\n    }\n\n}\n\n#ifndef QT_NO_CSSPARSER\n\nstatic const char * QSvgStyleSelector_nodeString[] = {\n    \"svg\",\n    \"g\",\n    \"defs\",\n    \"switch\",\n    \"animation\",\n    \"arc\",\n    \"circle\",\n    \"ellipse\",\n    \"image\",\n    \"line\",\n    \"path\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"text\",\n    \"textarea\",\n    \"tspan\",\n    \"use\",\n    \"video\"\n};\n\nclass QSvgStyleSelector : public QCss::StyleSelector\n{\npublic:\n    QSvgStyleSelector()\n    {\n        nameCaseSensitivity = Qt::CaseInsensitive;\n    }\n    virtual ~QSvgStyleSelector()\n    {\n    }\n\n    inline QString nodeToName(QSvgNode *node) const\n    {\n        return QLatin1String(QSvgStyleSelector_nodeString[node->type()]);\n    }\n\n    inline QSvgNode *svgNode(NodePtr node) const\n    {\n        return (QSvgNode*)node.ptr;\n    }\n    inline QSvgStructureNode *nodeToStructure(QSvgNode *n) const\n    {\n        if (n &&\n            (n->type() == QSvgNode::DOC ||\n             n->type() == QSvgNode::G ||\n             n->type() == QSvgNode::DEFS ||\n             n->type() == QSvgNode::SWITCH)) {\n            return (QSvgStructureNode*)n;\n        }\n        return 0;\n    }\n\n    inline QSvgStructureNode *svgStructure(NodePtr node) const\n    {\n        QSvgNode *n = svgNode(node);\n        QSvgStructureNode *st = nodeToStructure(n);\n        return st;\n    }\n\n    bool nodeNameEquals(NodePtr node, const QString& nodeName) const override\n    {\n        QSvgNode *n = svgNode(node);\n        if (!n)\n            return false;\n        QString name = nodeToName(n);\n        return QString::compare(name, nodeName, Qt::CaseInsensitive) == 0;\n    }\n    QString attribute(NodePtr node, const QString &name) const override\n    {\n        QSvgNode *n = svgNode(node);\n        if ((!n->nodeId().isEmpty() && (name == QLatin1String(\"id\") ||\n                                        name == QLatin1String(\"xml:id\"))))\n            return n->nodeId();\n        if (!n->xmlClass().isEmpty() && name == QLatin1String(\"class\"))\n            return n->xmlClass();\n        return QString();\n    }\n    bool hasAttributes(NodePtr node) const override\n    {\n        QSvgNode *n = svgNode(node);\n        return (n &&\n                (!n->nodeId().isEmpty() || !n->xmlClass().isEmpty()));\n    }\n\n    QStringList nodeIds(NodePtr node) const override\n    {\n        QSvgNode *n = svgNode(node);\n        QString nid;\n        if (n)\n            nid = n->nodeId();\n        QStringList lst; lst.append(nid);\n        return lst;\n    }\n\n    QStringList nodeNames(NodePtr node) const override\n    {\n        QSvgNode *n = svgNode(node);\n        if (n)\n           return QStringList(nodeToName(n));\n        return QStringList();\n    }\n\n    bool isNullNode(NodePtr node) const override\n    {\n        return !node.ptr;\n    }\n\n    NodePtr parentNode(NodePtr node) const override\n    {\n        QSvgNode *n = svgNode(node);\n        NodePtr newNode;\n        newNode.ptr = 0;\n        newNode.id = 0;\n        if (n) {\n            QSvgNode *svgParent = n->parent();\n            if (svgParent) {\n                newNode.ptr = svgParent;\n            }\n        }\n        return newNode;\n    }\n    NodePtr previousSiblingNode(NodePtr node) const override\n    {\n        NodePtr newNode;\n        newNode.ptr = 0;\n        newNode.id = 0;\n\n        QSvgNode *n = svgNode(node);\n        if (!n)\n            return newNode;\n        QSvgStructureNode *svgParent = nodeToStructure(n->parent());\n\n        if (svgParent) {\n            newNode.ptr = svgParent->previousSiblingNode(n);\n        }\n        return newNode;\n    }\n    NodePtr duplicateNode(NodePtr node) const override\n    {\n        NodePtr n;\n        n.ptr = node.ptr;\n        n.id  = node.id;\n        return n;\n    }\n    void freeNode(NodePtr node) const override\n    {\n        Q_UNUSED(node);\n    }\n};\n\n#endif // QT_NO_CSSPARSER\n\n// '0' is 0x30 and '9' is 0x39\nstatic inline bool isDigit(ushort ch)\n{\n    static quint16 magic = 0x3ff;\n    return ((ch >> 4) == 3) && (magic >> (ch & 15));\n}\n\nstatic qreal toDouble(const QChar *&str)\n{\n    const int maxLen = 255;//technically doubles can go til 308+ but whatever\n    char temp[maxLen+1];\n    int pos = 0;\n\n    if (*str == QLatin1Char('-')) {\n        temp[pos++] = '-';\n        ++str;\n    } else if (*str == QLatin1Char('+')) {\n        ++str;\n    }\n    while (isDigit(str->unicode()) && pos < maxLen) {\n        temp[pos++] = str->toLatin1();\n        ++str;\n    }\n    if (*str == QLatin1Char('.') && pos < maxLen) {\n        temp[pos++] = '.';\n        ++str;\n    }\n    while (isDigit(str->unicode()) && pos < maxLen) {\n        temp[pos++] = str->toLatin1();\n        ++str;\n    }\n    bool exponent = false;\n    if ((*str == QLatin1Char('e') || *str == QLatin1Char('E')) && pos < maxLen) {\n        exponent = true;\n        temp[pos++] = 'e';\n        ++str;\n        if ((*str == QLatin1Char('-') || *str == QLatin1Char('+')) && pos < maxLen) {\n            temp[pos++] = str->toLatin1();\n            ++str;\n        }\n        while (isDigit(str->unicode()) && pos < maxLen) {\n            temp[pos++] = str->toLatin1();\n            ++str;\n        }\n    }\n\n    temp[pos] = '\\0';\n\n    qreal val;\n    if (!exponent && pos < 10) {\n        int ival = 0;\n        const char *t = temp;\n        bool neg = false;\n        if(*t == '-') {\n            neg = true;\n            ++t;\n        }\n        while(*t && *t != '.') {\n            ival *= 10;\n            ival += (*t) - '0';\n            ++t;\n        }\n        if(*t == '.') {\n            ++t;\n            int div = 1;\n            while(*t) {\n                ival *= 10;\n                ival += (*t) - '0';\n                div *= 10;\n                ++t;\n            }\n            val = ((qreal)ival)/((qreal)div);\n        } else {\n            val = ival;\n        }\n        if (neg)\n            val = -val;\n    } else {\n        val = QByteArray::fromRawData(temp, pos).toDouble();\n        // Do not tolerate values too wild to be represented normally by floats\n        if (qFpClassify(float(val)) != FP_NORMAL)\n            val = 0;\n    }\n    return val;\n\n}\n\nstatic qreal toDouble(QStringView str, bool *ok = NULL)\n{\n    const QChar *c = str.constData();\n    qreal res = (c == nullptr ? qreal{} : toDouble(c));\n    if (ok)\n        *ok = (c == (str.constData() + str.length()));\n    return res;\n}\n\nstatic QList<qreal> parseNumbersList(const QChar *&str)\n{\n    QList<qreal> points;\n    if (!str)\n        return points;\n    points.reserve(32);\n\n    while (str->isSpace())\n        ++str;\n    while (isDigit(str->unicode()) ||\n           *str == QLatin1Char('-') || *str == QLatin1Char('+') ||\n           *str == QLatin1Char('.')) {\n\n        points.append(toDouble(str));\n\n        while (str->isSpace())\n            ++str;\n        if (*str == QLatin1Char(','))\n            ++str;\n\n        //eat the rest of space\n        while (str->isSpace())\n            ++str;\n    }\n\n    return points;\n}\n\nstatic inline void parseNumbersArray(const QChar *&str, QVarLengthArray<qreal, 8> &points,\n                                     const char *pattern = nullptr)\n{\n    const size_t patternLen = qstrlen(pattern);\n    while (str->isSpace())\n        ++str;\n    while (isDigit(str->unicode()) ||\n           *str == QLatin1Char('-') || *str == QLatin1Char('+') ||\n           *str == QLatin1Char('.')) {\n\n        if (patternLen && pattern[points.size() % patternLen] == 'f') {\n            // flag expected, may only be 0 or 1\n            if (*str != QLatin1Char('0') && *str != QLatin1Char('1'))\n                return;\n            points.append(*str == QLatin1Char('0') ? 0.0 : 1.0);\n            ++str;\n        } else {\n            points.append(toDouble(str));\n        }\n\n        while (str->isSpace())\n            ++str;\n        if (*str == QLatin1Char(','))\n            ++str;\n\n        //eat the rest of space\n        while (str->isSpace())\n            ++str;\n    }\n}\n\nstatic QList<qreal> parsePercentageList(const QChar *&str)\n{\n    QList<qreal> points;\n    if (!str)\n        return points;\n\n    while (str->isSpace())\n        ++str;\n    while ((*str >= QLatin1Char('0') && *str <= QLatin1Char('9')) ||\n           *str == QLatin1Char('-') || *str == QLatin1Char('+') ||\n           *str == QLatin1Char('.')) {\n\n        points.append(toDouble(str));\n\n        while (str->isSpace())\n            ++str;\n        if (*str == QLatin1Char('%'))\n            ++str;\n        while (str->isSpace())\n            ++str;\n        if (*str == QLatin1Char(','))\n            ++str;\n\n        //eat the rest of space\n        while (str->isSpace())\n            ++str;\n    }\n\n    return points;\n}\n\nstatic QString idFromUrl(const QString &url)\n{\n    // The form is url(<IRI>), where IRI can be\n    // just an ID on #<id> form.\n    QString::const_iterator itr = url.constBegin();\n    QString::const_iterator end = url.constEnd();\n    QString id;\n    while (itr != end && (*itr).isSpace())\n        ++itr;\n    if (itr != end && (*itr) == QLatin1Char('('))\n        ++itr;\n    else\n        return QString();\n    while (itr != end && (*itr).isSpace())\n        ++itr;\n    if (itr != end && (*itr) == QLatin1Char('#')) {\n        id += *itr;\n        ++itr;\n    } else {\n        return QString();\n    }\n    while (itr != end && (*itr) != QLatin1Char(')')) {\n        id += *itr;\n        ++itr;\n    }\n    if (itr == end || (*itr) != QLatin1Char(')'))\n        return QString();\n    return id;\n}\n\n/**\n * returns true when successfully set the color. false signifies\n * that the color should be inherited\n */\nstatic bool resolveColor(QStringView colorStr, QColor &color, QSvgHandler *handler)\n{\n    QStringView colorStrTr = colorStr.trimmed();\n    if (colorStrTr.isEmpty())\n        return false;\n\n    switch(colorStrTr.at(0).unicode()) {\n\n        case '#':\n            {\n                // #rrggbb is very very common, so let's tackle it here\n                // rather than falling back to QColor\n                QRgb rgb;\n                bool ok = qsvg_get_hex_rgb(colorStrTr.constData(), colorStrTr.length(), &rgb);\n                if (ok)\n                    color.setRgb(rgb);\n                return ok;\n            }\n            break;\n\n        case 'r':\n            {\n                // starts with \"rgb(\", ends with \")\" and consists of at least 7 characters \"rgb(,,)\"\n                if (colorStrTr.length() >= 7 && colorStrTr.at(colorStrTr.length() - 1) == QLatin1Char(')')\n                    && colorStrTr.mid(0, 4) == QLatin1String(\"rgb(\")) {\n                    const QChar *s = colorStrTr.constData() + 4;\n                    QList<qreal> compo = parseNumbersList(s);\n                    //1 means that it failed after reaching non-parsable\n                    //character which is going to be \"%\"\n                    if (compo.size() == 1) {\n                        s = colorStrTr.constData() + 4;\n                        compo = parsePercentageList(s);\n                        for (int i = 0; i < compo.size(); ++i)\n                            compo[i] *= (qreal)2.55;\n                    }\n\n                    if (compo.size() == 3) {\n                        color = QColor(int(compo[0]),\n                                       int(compo[1]),\n                                       int(compo[2]));\n                        return true;\n                    }\n                    return false;\n                }\n            }\n            break;\n\n        case 'c':\n            if (colorStrTr == QLatin1String(\"currentColor\")) {\n                color = handler->currentColor();\n                return true;\n            }\n            break;\n        case 'i':\n            if (colorStrTr == QT_INHERIT)\n                return false;\n            break;\n        default:\n            break;\n    }\n\n    color = QColor(colorStrTr.toString());\n    return color.isValid();\n}\n\nstatic bool constructColor(QStringView colorStr, QStringView opacity,\n                           QColor &color, QSvgHandler *handler)\n{\n    if (!resolveColor(colorStr, color, handler))\n        return false;\n    if (!opacity.isEmpty()) {\n        bool ok = true;\n        qreal op = qMin(qreal(1.0), qMax(qreal(0.0), toDouble(opacity, &ok)));\n        if (!ok)\n            op = 1.0;\n        color.setAlphaF(op);\n    }\n    return true;\n}\n\nstatic qreal parseLength(QStringView str, QSvgHandler::LengthType &type,\n                         QSvgHandler *handler, bool *ok = NULL)\n{\n    QStringView numStr = str.trimmed();\n\n    if (numStr.endsWith(QLatin1Char('%'))) {\n        numStr.chop(1);\n        type = QSvgHandler::LT_PERCENT;\n    } else if (numStr.endsWith(QLatin1String(\"px\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_PX;\n    } else if (numStr.endsWith(QLatin1String(\"pc\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_PC;\n    } else if (numStr.endsWith(QLatin1String(\"pt\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_PT;\n    } else if (numStr.endsWith(QLatin1String(\"mm\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_MM;\n    } else if (numStr.endsWith(QLatin1String(\"cm\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_CM;\n    } else if (numStr.endsWith(QLatin1String(\"in\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_IN;\n    } else {\n        type = handler->defaultCoordinateSystem();\n        //type = QSvgHandler::LT_OTHER;\n    }\n    qreal len = toDouble(numStr, ok);\n    //qDebug()<<\"len is \"<<len<<\", from '\"<<numStr << \"'\";\n    return len;\n}\n\nstatic inline qreal convertToNumber(QStringView str, QSvgHandler *handler, bool *ok = NULL)\n{\n    QSvgHandler::LengthType type;\n    qreal num = parseLength(str.toString(), type, handler, ok);\n    if (type == QSvgHandler::LT_PERCENT) {\n        num = num/100.0;\n    }\n    return num;\n}\n\nstatic bool createSvgGlyph(QSvgFont *font, const QXmlStreamAttributes &attributes)\n{\n    QStringView uncStr = attributes.value(QLatin1String(\"unicode\"));\n    QStringView havStr = attributes.value(QLatin1String(\"horiz-adv-x\"));\n    QStringView pathStr = attributes.value(QLatin1String(\"d\"));\n\n    QChar unicode = (uncStr.isEmpty()) ? u'\\0' : uncStr.at(0);\n    qreal havx = (havStr.isEmpty()) ? -1 : toDouble(havStr);\n    QPainterPath path;\n    path.setFillRule(Qt::WindingFill);\n    parsePathDataFast(pathStr, path);\n\n    font->addGlyph(unicode, path, havx);\n\n    return true;\n}\n\n// this should really be called convertToDefaultCoordinateSystem\n// and convert when type != QSvgHandler::defaultCoordinateSystem\nstatic qreal convertToPixels(qreal len, bool , QSvgHandler::LengthType type)\n{\n\n    switch (type) {\n    case QSvgHandler::LT_PERCENT:\n        break;\n    case QSvgHandler::LT_PX:\n        break;\n    case QSvgHandler::LT_PC:\n        break;\n    case QSvgHandler::LT_PT:\n        return len * 1.25;\n        break;\n    case QSvgHandler::LT_MM:\n        return len * 3.543307;\n        break;\n    case QSvgHandler::LT_CM:\n        return len * 35.43307;\n        break;\n    case QSvgHandler::LT_IN:\n        return len * 90;\n        break;\n    case QSvgHandler::LT_OTHER:\n        break;\n    default:\n        break;\n    }\n    return len;\n}\n\nstatic void parseColor(QSvgNode *,\n                       const QSvgAttributes &attributes,\n                       QSvgHandler *handler)\n{\n    QColor color;\n    if (constructColor(attributes.color, attributes.colorOpacity, color, handler)) {\n        handler->popColor();\n        handler->pushColor(color);\n    }\n}\n\nstatic QSvgStyleProperty *styleFromUrl(QSvgNode *node, const QString &url)\n{\n    return node ? node->styleProperty(idFromUrl(url)) : 0;\n}\n\nstatic void parseBrush(QSvgNode *node,\n                       const QSvgAttributes &attributes,\n                       QSvgHandler *handler)\n{\n    if (!attributes.fill.isEmpty() || !attributes.fillRule.isEmpty() || !attributes.fillOpacity.isEmpty()) {\n        QSvgFillStyle *prop = new QSvgFillStyle;\n\n        //fill-rule attribute handling\n        if (!attributes.fillRule.isEmpty() && attributes.fillRule != QT_INHERIT) {\n            if (attributes.fillRule == QLatin1String(\"evenodd\"))\n                prop->setFillRule(Qt::OddEvenFill);\n            else if (attributes.fillRule == QLatin1String(\"nonzero\"))\n                prop->setFillRule(Qt::WindingFill);\n        }\n\n        //fill-opacity attribute handling\n        if (!attributes.fillOpacity.isEmpty() && attributes.fillOpacity != QT_INHERIT) {\n            prop->setFillOpacity(qMin(qreal(1.0), qMax(qreal(0.0), toDouble(attributes.fillOpacity))));\n        }\n\n        //fill attribute handling\n        if ((!attributes.fill.isEmpty()) && (attributes.fill != QT_INHERIT) ) {\n            if (attributes.fill.length() > 3 && attributes.fill.mid(0, 3) == QLatin1String(\"url\")) {\n                QString value = attributes.fill.mid(3, attributes.fill.length() - 3).toString();\n                QSvgStyleProperty *style = styleFromUrl(node, value);\n                if (style) {\n                    if (style->type() == QSvgStyleProperty::SOLID_COLOR || style->type() == QSvgStyleProperty::GRADIENT)\n                        prop->setFillStyle(reinterpret_cast<QSvgFillStyleProperty *>(style));\n                } else {\n                    QString id = idFromUrl(value);\n                    prop->setGradientId(id);\n                    prop->setGradientResolved(false);\n                }\n            } else if (attributes.fill != QLatin1String(\"none\")) {\n                QColor color;\n                if (resolveColor(attributes.fill, color, handler))\n                    prop->setBrush(QBrush(color));\n            } else {\n                prop->setBrush(QBrush(Qt::NoBrush));\n            }\n        }\n        node->appendStyleProperty(prop, attributes.id);\n    }\n}\n\n\n\nstatic QTransform parseTransformationMatrix(QStringView value)\n{\n    if (value.isEmpty())\n        return QTransform();\n\n    QTransform matrix;\n    const QChar *str = value.constData();\n    const QChar *end = str + value.length();\n\n    while (str < end) {\n        if (str->isSpace() || *str == QLatin1Char(',')) {\n            ++str;\n            continue;\n        }\n        enum State {\n            Matrix,\n            Translate,\n            Rotate,\n            Scale,\n            SkewX,\n            SkewY\n        };\n        State state = Matrix;\n        if (*str == QLatin1Char('m')) {  //matrix\n            const char *ident = \"atrix\";\n            for (int i = 0; i < 5; ++i)\n                if (*(++str) != QLatin1Char(ident[i]))\n                    goto error;\n            ++str;\n            state = Matrix;\n        } else if (*str == QLatin1Char('t')) { //translate\n            const char *ident = \"ranslate\";\n            for (int i = 0; i < 8; ++i)\n                if (*(++str) != QLatin1Char(ident[i]))\n                    goto error;\n            ++str;\n            state = Translate;\n        } else if (*str == QLatin1Char('r')) { //rotate\n            const char *ident = \"otate\";\n            for (int i = 0; i < 5; ++i)\n                if (*(++str) != QLatin1Char(ident[i]))\n                    goto error;\n            ++str;\n            state = Rotate;\n        } else if (*str == QLatin1Char('s')) { //scale, skewX, skewY\n            ++str;\n            if (*str == QLatin1Char('c')) {\n                const char *ident = \"ale\";\n                for (int i = 0; i < 3; ++i)\n                    if (*(++str) != QLatin1Char(ident[i]))\n                        goto error;\n                ++str;\n                state = Scale;\n            } else if (*str == QLatin1Char('k')) {\n                if (*(++str) != QLatin1Char('e'))\n                    goto error;\n                if (*(++str) != QLatin1Char('w'))\n                    goto error;\n                ++str;\n                if (*str == QLatin1Char('X'))\n                    state = SkewX;\n                else if (*str == QLatin1Char('Y'))\n                    state = SkewY;\n                else\n                    goto error;\n                ++str;\n            } else {\n                goto error;\n            }\n        } else {\n            goto error;\n        }\n\n\n        while (str < end && str->isSpace())\n            ++str;\n        if (*str != QLatin1Char('('))\n            goto error;\n        ++str;\n        QVarLengthArray<qreal, 8> points;\n        parseNumbersArray(str, points);\n        if (*str != QLatin1Char(')'))\n            goto error;\n        ++str;\n\n        if(state == Matrix) {\n            if(points.count() != 6)\n                goto error;\n            matrix = QTransform(points[0], points[1],\n                                points[2], points[3],\n                                points[4], points[5]) * matrix;\n        } else if (state == Translate) {\n            if (points.count() == 1)\n                matrix.translate(points[0], 0);\n            else if (points.count() == 2)\n                matrix.translate(points[0], points[1]);\n            else\n                goto error;\n        } else if (state == Rotate) {\n            if(points.count() == 1) {\n                matrix.rotate(points[0]);\n            } else if (points.count() == 3) {\n                matrix.translate(points[1], points[2]);\n                matrix.rotate(points[0]);\n                matrix.translate(-points[1], -points[2]);\n            } else {\n                goto error;\n            }\n        } else if (state == Scale) {\n            if (points.count() < 1 || points.count() > 2)\n                goto error;\n            qreal sx = points[0];\n            qreal sy = sx;\n            if(points.count() == 2)\n                sy = points[1];\n            matrix.scale(sx, sy);\n        } else if (state == SkewX) {\n            if (points.count() != 1)\n                goto error;\n            matrix.shear(qTan(qDegreesToRadians(points[0])), 0);\n        } else if (state == SkewY) {\n            if (points.count() != 1)\n                goto error;\n            matrix.shear(0, qTan(qDegreesToRadians(points[0])));\n        }\n    }\n  error:\n    return matrix;\n}\n\nstatic void parsePen(QSvgNode *node,\n                     const QSvgAttributes &attributes,\n                     QSvgHandler *handler)\n{\n    //qDebug()<<\"Node \"<<node->type()<<\", attrs are \"<<value<<width;\n\n    if (!attributes.stroke.isEmpty() || !attributes.strokeDashArray.isEmpty() || !attributes.strokeDashOffset.isEmpty() || !attributes.strokeLineCap.isEmpty()\n        || !attributes.strokeLineJoin.isEmpty() || !attributes.strokeMiterLimit.isEmpty() || !attributes.strokeOpacity.isEmpty() || !attributes.strokeWidth.isEmpty()\n        || !attributes.vectorEffect.isEmpty()) {\n\n        QSvgStrokeStyle *prop = new QSvgStrokeStyle;\n\n        //stroke attribute handling\n        if ((!attributes.stroke.isEmpty()) && (attributes.stroke != QT_INHERIT) ) {\n            if (attributes.stroke.length() > 3 && attributes.stroke.mid(0, 3) == QLatin1String(\"url\")) {\n                 QString value = attributes.stroke.mid(3, attributes.stroke.length() - 3).toString();\n                    QSvgStyleProperty *style = styleFromUrl(node, value);\n                    if (style) {\n                        if (style->type() == QSvgStyleProperty::SOLID_COLOR || style->type() == QSvgStyleProperty::GRADIENT)\n                            prop->setStyle(reinterpret_cast<QSvgFillStyleProperty *>(style));\n                    } else {\n                        QString id = idFromUrl(value);\n                        prop->setGradientId(id);\n                        prop->setGradientResolved(false);\n                    }\n            } else if (attributes.stroke != QLatin1String(\"none\")) {\n                QColor color;\n                if (resolveColor(attributes.stroke, color, handler))\n                    prop->setStroke(QBrush(color));\n            } else {\n                prop->setStroke(QBrush(Qt::NoBrush));\n            }\n        }\n\n        //stroke-width handling\n        if (!attributes.strokeWidth.isEmpty() && attributes.strokeWidth != QT_INHERIT) {\n            QSvgHandler::LengthType lt;\n            prop->setWidth(parseLength(attributes.strokeWidth, lt, handler));\n        }\n\n        //stroke-dasharray\n        if (!attributes.strokeDashArray.isEmpty() && attributes.strokeDashArray != QT_INHERIT) {\n            if (attributes.strokeDashArray == QLatin1String(\"none\")) {\n                prop->setDashArrayNone();\n            } else {\n                QString dashArray  = attributes.strokeDashArray.toString();\n                const QChar *s = dashArray.constData();\n                QList<qreal> dashes = parseNumbersList(s);\n                // if the dash count is odd the dashes should be duplicated\n                if ((dashes.size() & 1) != 0)\n                    dashes << QList<qreal>(dashes);\n                prop->setDashArray(dashes);\n            }\n        }\n\n        //stroke-linejoin attribute handling\n        if (!attributes.strokeLineJoin.isEmpty()) {\n            if (attributes.strokeLineJoin == QLatin1String(\"miter\"))\n                prop->setLineJoin(Qt::SvgMiterJoin);\n            else if (attributes.strokeLineJoin == QLatin1String(\"round\"))\n                prop->setLineJoin(Qt::RoundJoin);\n            else if (attributes.strokeLineJoin == QLatin1String(\"bevel\"))\n                prop->setLineJoin(Qt::BevelJoin);\n        }\n\n        //stroke-linecap attribute handling\n        if (!attributes.strokeLineCap.isEmpty()) {\n            if (attributes.strokeLineCap == QLatin1String(\"butt\"))\n                prop->setLineCap(Qt::FlatCap);\n            else if (attributes.strokeLineCap == QLatin1String(\"round\"))\n                prop->setLineCap(Qt::RoundCap);\n            else if (attributes.strokeLineCap == QLatin1String(\"square\"))\n                prop->setLineCap(Qt::SquareCap);\n        }\n\n        //stroke-dashoffset attribute handling\n        if (!attributes.strokeDashOffset.isEmpty() && attributes.strokeDashOffset != QT_INHERIT)\n            prop->setDashOffset(toDouble(attributes.strokeDashOffset));\n\n        //vector-effect attribute handling\n        if (!attributes.vectorEffect.isEmpty()) {\n            if (attributes.vectorEffect == QLatin1String(\"non-scaling-stroke\"))\n                prop->setVectorEffect(true);\n            else if (attributes.vectorEffect == QLatin1String(\"none\"))\n                prop->setVectorEffect(false);\n        }\n\n        //stroke-miterlimit\n        if (!attributes.strokeMiterLimit.isEmpty() && attributes.strokeMiterLimit != QT_INHERIT)\n            prop->setMiterLimit(toDouble(attributes.strokeMiterLimit));\n\n        //stroke-opacity atttribute handling\n        if (!attributes.strokeOpacity.isEmpty() && attributes.strokeOpacity != QT_INHERIT)\n            prop->setOpacity(qMin(qreal(1.0), qMax(qreal(0.0), toDouble(attributes.strokeOpacity))));\n\n        node->appendStyleProperty(prop, attributes.id);\n    }\n}\n\nenum FontSizeSpec { XXSmall, XSmall, Small, Medium, Large, XLarge, XXLarge,\n                   FontSizeNone, FontSizeValue };\n\nstatic const qreal sizeTable[] =\n{ qreal(6.9), qreal(8.3), qreal(10.0), qreal(12.0), qreal(14.4), qreal(17.3), qreal(20.7) };\n\nQ_STATIC_ASSERT(sizeof(sizeTable)/sizeof(sizeTable[0]) == FontSizeNone);\n\nstatic FontSizeSpec fontSizeSpec(QStringView spec)\n{\n    switch (spec.at(0).unicode()) {\n    case 'x':\n        if (spec == QLatin1String(\"xx-small\"))\n            return XXSmall;\n        if (spec == QLatin1String(\"x-small\"))\n            return XSmall;\n        if (spec == QLatin1String(\"x-large\"))\n            return XLarge;\n        if (spec == QLatin1String(\"xx-large\"))\n            return XXLarge;\n        break;\n    case 's':\n        if (spec == QLatin1String(\"small\"))\n            return Small;\n        break;\n    case 'm':\n        if (spec == QLatin1String(\"medium\"))\n            return Medium;\n        break;\n    case 'l':\n        if (spec == QLatin1String(\"large\"))\n            return Large;\n        break;\n    case 'n':\n        if (spec == QLatin1String(\"none\"))\n            return FontSizeNone;\n        break;\n    default:\n        break;\n    }\n    return FontSizeValue;\n}\n\nstatic void parseFont(QSvgNode *node,\n                      const QSvgAttributes &attributes,\n                      QSvgHandler *handler)\n{\n    if (attributes.fontFamily.isEmpty() && attributes.fontSize.isEmpty() && attributes.fontStyle.isEmpty() &&\n        attributes.fontWeight.isEmpty() && attributes.fontVariant.isEmpty() && attributes.textAnchor.isEmpty())\n        return;\n\n    QSvgTinyDocument *doc = node->document();\n    QSvgFontStyle *fontStyle = nullptr;\n    if (!attributes.fontFamily.isEmpty()) {\n        QSvgFont *svgFont = doc->svgFont(attributes.fontFamily.toString());\n        if (svgFont)\n            fontStyle = new QSvgFontStyle(svgFont, doc);\n    }\n    if (!fontStyle)\n        fontStyle = new QSvgFontStyle;\n    if (!attributes.fontFamily.isEmpty() && attributes.fontFamily != QT_INHERIT) {\n        QString family = attributes.fontFamily.toString().trimmed();\n        if (family.at(0) == QLatin1Char('\\'') || family.at(0) == QLatin1Char('\\\"'))\n            family = family.mid(1, family.length() - 2);\n        fontStyle->setFamily(family);\n    }\n\n    if (!attributes.fontSize.isEmpty() && attributes.fontSize != QT_INHERIT) {\n        // TODO: Support relative sizes 'larger' and 'smaller'.\n        const FontSizeSpec spec = fontSizeSpec(attributes.fontSize);\n        switch (spec) {\n        case FontSizeNone:\n            break;\n        case FontSizeValue: {\n            QSvgHandler::LengthType type;\n            qreal fs = parseLength(attributes.fontSize, type, handler);\n            fs = convertToPixels(fs, true, type);\n            fontStyle->setSize(qMin(fs, qreal(0xffff)));\n        }\n            break;\n        default:\n            fontStyle->setSize(sizeTable[spec]);\n            break;\n        }\n    }\n\n    if (!attributes.fontStyle.isEmpty() && attributes.fontStyle != QT_INHERIT) {\n        if (attributes.fontStyle == QLatin1String(\"normal\")) {\n            fontStyle->setStyle(QFont::StyleNormal);\n        } else if (attributes.fontStyle == QLatin1String(\"italic\")) {\n            fontStyle->setStyle(QFont::StyleItalic);\n        } else if (attributes.fontStyle == QLatin1String(\"oblique\")) {\n            fontStyle->setStyle(QFont::StyleOblique);\n        }\n    }\n\n    if (!attributes.fontWeight.isEmpty() && attributes.fontWeight != QT_INHERIT) {\n        bool ok = false;\n        const int weightNum = attributes.fontWeight.toInt(&ok);\n        if (ok) {\n            fontStyle->setWeight(weightNum);\n        } else {\n            if (attributes.fontWeight == QLatin1String(\"normal\")) {\n                fontStyle->setWeight(QFont::Normal);\n            } else if (attributes.fontWeight == QLatin1String(\"bold\")) {\n                fontStyle->setWeight(QFont::Bold);\n            } else if (attributes.fontWeight == QLatin1String(\"bolder\")) {\n                fontStyle->setWeight(QSvgFontStyle::BOLDER);\n            } else if (attributes.fontWeight == QLatin1String(\"lighter\")) {\n                fontStyle->setWeight(QSvgFontStyle::LIGHTER);\n            }\n        }\n    }\n\n    if (!attributes.fontVariant.isEmpty() && attributes.fontVariant != QT_INHERIT) {\n        if (attributes.fontVariant == QLatin1String(\"normal\"))\n            fontStyle->setVariant(QFont::MixedCase);\n        else if (attributes.fontVariant == QLatin1String(\"small-caps\"))\n            fontStyle->setVariant(QFont::SmallCaps);\n    }\n\n    if (!attributes.textAnchor.isEmpty() && attributes.textAnchor != QT_INHERIT) {\n        if (attributes.textAnchor == QLatin1String(\"start\"))\n            fontStyle->setTextAnchor(Qt::AlignLeft);\n        if (attributes.textAnchor == QLatin1String(\"middle\"))\n           fontStyle->setTextAnchor(Qt::AlignHCenter);\n        else if (attributes.textAnchor == QLatin1String(\"end\"))\n           fontStyle->setTextAnchor(Qt::AlignRight);\n    }\n\n    node->appendStyleProperty(fontStyle, attributes.id);\n}\n\nstatic void parseTransform(QSvgNode *node,\n                           const QSvgAttributes &attributes,\n                           QSvgHandler *)\n{\n    if (attributes.transform.isEmpty())\n        return;\n    QTransform matrix = parseTransformationMatrix(attributes.transform.trimmed());\n\n    if (!matrix.isIdentity()) {\n        node->appendStyleProperty(new QSvgTransformStyle(QTransform(matrix)), attributes.id);\n    }\n\n}\n\nstatic void parseVisibility(QSvgNode *node,\n                            const QSvgAttributes &attributes,\n                            QSvgHandler *)\n{\n    QSvgNode *parent = node->parent();\n\n    if (parent && (attributes.visibility.isEmpty() || attributes.visibility == QT_INHERIT))\n        node->setVisible(parent->isVisible());\n    else if (attributes.visibility == QLatin1String(\"hidden\") || attributes.visibility == QLatin1String(\"collapse\")) {\n        node->setVisible(false);\n    } else\n        node->setVisible(true);\n}\n\nstatic void pathArcSegment(QPainterPath &path,\n                           qreal xc, qreal yc,\n                           qreal th0, qreal th1,\n                           qreal rx, qreal ry, qreal xAxisRotation)\n{\n    qreal sinTh, cosTh;\n    qreal a00, a01, a10, a11;\n    qreal x1, y1, x2, y2, x3, y3;\n    qreal t;\n    qreal thHalf;\n\n    sinTh = qSin(xAxisRotation * (Q_PI / 180.0));\n    cosTh = qCos(xAxisRotation * (Q_PI / 180.0));\n\n    a00 =  cosTh * rx;\n    a01 = -sinTh * ry;\n    a10 =  sinTh * rx;\n    a11 =  cosTh * ry;\n\n    thHalf = 0.5 * (th1 - th0);\n    t = (8.0 / 3.0) * qSin(thHalf * 0.5) * qSin(thHalf * 0.5) / qSin(thHalf);\n    x1 = xc + qCos(th0) - t * qSin(th0);\n    y1 = yc + qSin(th0) + t * qCos(th0);\n    x3 = xc + qCos(th1);\n    y3 = yc + qSin(th1);\n    x2 = x3 + t * qSin(th1);\n    y2 = y3 - t * qCos(th1);\n\n    path.cubicTo(a00 * x1 + a01 * y1, a10 * x1 + a11 * y1,\n                 a00 * x2 + a01 * y2, a10 * x2 + a11 * y2,\n                 a00 * x3 + a01 * y3, a10 * x3 + a11 * y3);\n}\n\n// the arc handling code underneath is from XSVG (BSD license)\n/*\n * Copyright  2002 USC/Information Sciences Institute\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without\n * fee, provided that the above copyright notice appear in all copies\n * and that both that copyright notice and this permission notice\n * appear in supporting documentation, and that the name of\n * Information Sciences Institute not be used in advertising or\n * publicity pertaining to distribution of the software without\n * specific, written prior permission.  Information Sciences Institute\n * makes no representations about the suitability of this software for\n * any purpose.  It is provided \"as is\" without express or implied\n * warranty.\n *\n * INFORMATION SCIENCES INSTITUTE DISCLAIMS ALL WARRANTIES WITH REGARD\n * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL INFORMATION SCIENCES\n * INSTITUTE BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA\n * OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n *\n */\nstatic void pathArc(QPainterPath &path,\n                    qreal               rx,\n                    qreal               ry,\n                    qreal               x_axis_rotation,\n                    int         large_arc_flag,\n                    int         sweep_flag,\n                    qreal               x,\n                    qreal               y,\n                    qreal curx, qreal cury)\n{\n    const qreal Pr1 = rx * rx;\n    const qreal Pr2 = ry * ry;\n\n    if (!Pr1 || !Pr2)\n        return;\n\n    qreal sin_th, cos_th;\n    qreal a00, a01, a10, a11;\n    qreal x0, y0, x1, y1, xc, yc;\n    qreal d, sfactor, sfactor_sq;\n    qreal th0, th1, th_arc;\n    int i, n_segs;\n    qreal dx, dy, dx1, dy1, Px, Py, check;\n\n    rx = qAbs(rx);\n    ry = qAbs(ry);\n\n    sin_th = qSin(x_axis_rotation * (Q_PI / 180.0));\n    cos_th = qCos(x_axis_rotation * (Q_PI / 180.0));\n\n    dx = (curx - x) / 2.0;\n    dy = (cury - y) / 2.0;\n    dx1 =  cos_th * dx + sin_th * dy;\n    dy1 = -sin_th * dx + cos_th * dy;\n    Px = dx1 * dx1;\n    Py = dy1 * dy1;\n    /* Spec : check if radii are large enough */\n    check = Px / Pr1 + Py / Pr2;\n    if (check > 1) {\n        rx = rx * qSqrt(check);\n        ry = ry * qSqrt(check);\n    }\n\n    a00 =  cos_th / rx;\n    a01 =  sin_th / rx;\n    a10 = -sin_th / ry;\n    a11 =  cos_th / ry;\n    x0 = a00 * curx + a01 * cury;\n    y0 = a10 * curx + a11 * cury;\n    x1 = a00 * x + a01 * y;\n    y1 = a10 * x + a11 * y;\n    /* (x0, y0) is current point in transformed coordinate space.\n       (x1, y1) is new point in transformed coordinate space.\n\n       The arc fits a unit-radius circle in this space.\n    */\n    d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n    if (!d)\n        return;\n    sfactor_sq = 1.0 / d - 0.25;\n    if (sfactor_sq < 0) sfactor_sq = 0;\n    sfactor = qSqrt(sfactor_sq);\n    if (sweep_flag == large_arc_flag) sfactor = -sfactor;\n    xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n    yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n    /* (xc, yc) is center of the circle. */\n\n    th0 = qAtan2(y0 - yc, x0 - xc);\n    th1 = qAtan2(y1 - yc, x1 - xc);\n\n    th_arc = th1 - th0;\n    if (th_arc < 0 && sweep_flag)\n        th_arc += 2 * Q_PI;\n    else if (th_arc > 0 && !sweep_flag)\n        th_arc -= 2 * Q_PI;\n\n    n_segs = qCeil(qAbs(th_arc / (Q_PI * 0.5 + 0.001)));\n\n    for (i = 0; i < n_segs; i++) {\n        pathArcSegment(path, xc, yc,\n                       th0 + i * th_arc / n_segs,\n                       th0 + (i + 1) * th_arc / n_segs,\n                       rx, ry, x_axis_rotation);\n    }\n}\n\nstatic bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n{\n    qreal x0 = 0, y0 = 0;              // starting point\n    qreal x = 0, y = 0;                // current point\n    char lastMode = 0;\n    QPointF ctrlPt;\n    const QChar *str = dataStr.constData();\n    const QChar *end = str + dataStr.size();\n\n    while (str != end) {\n        while (str->isSpace() && (str + 1) != end)\n            ++str;\n        QChar pathElem = *str;\n        ++str;\n        QChar endc = *end;\n        *const_cast<QChar *>(end) = u'\\0'; // parseNumbersArray requires 0-termination that QStringView cannot guarantee\n        const char *pattern = nullptr;\n        if (pathElem == QLatin1Char('a') || pathElem == QLatin1Char('A'))\n            pattern = \"rrrffrr\";\n        QVarLengthArray<qreal, 8> arg;\n        parseNumbersArray(str, arg, pattern);\n        *const_cast<QChar *>(end) = endc;\n        if (pathElem == QLatin1Char('z') || pathElem == QLatin1Char('Z'))\n            arg.append(0);//dummy\n        const qreal *num = arg.constData();\n        int count = arg.count();\n        while (count > 0) {\n            qreal offsetX = x;        // correction offsets\n            qreal offsetY = y;        // for relative commands\n            switch (pathElem.unicode()) {\n            case 'm': {\n                if (count < 2) {\n                    num++;\n                    count--;\n                    break;\n                }\n                x = x0 = num[0] + offsetX;\n                y = y0 = num[1] + offsetY;\n                num += 2;\n                count -= 2;\n                path.moveTo(x0, y0);\n\n                 // As per 1.2  spec 8.3.2 The \"moveto\" commands\n                 // If a 'moveto' is followed by multiple pairs of coordinates without explicit commands,\n                 // the subsequent pairs shall be treated as implicit 'lineto' commands.\n                 pathElem = QLatin1Char('l');\n            }\n                break;\n            case 'M': {\n                if (count < 2) {\n                    num++;\n                    count--;\n                    break;\n                }\n                x = x0 = num[0];\n                y = y0 = num[1];\n                num += 2;\n                count -= 2;\n                path.moveTo(x0, y0);\n\n                // As per 1.2  spec 8.3.2 The \"moveto\" commands\n                // If a 'moveto' is followed by multiple pairs of coordinates without explicit commands,\n                // the subsequent pairs shall be treated as implicit 'lineto' commands.\n                pathElem = QLatin1Char('L');\n            }\n                break;\n            case 'z':\n            case 'Z': {\n                x = x0;\n                y = y0;\n                count--; // skip dummy\n                num++;\n                path.closeSubpath();\n            }\n                break;\n            case 'l': {\n                if (count < 2) {\n                    num++;\n                    count--;\n                    break;\n                }\n                x = num[0] + offsetX;\n                y = num[1] + offsetY;\n                num += 2;\n                count -= 2;\n                path.lineTo(x, y);\n\n            }\n                break;\n            case 'L': {\n                if (count < 2) {\n                    num++;\n                    count--;\n                    break;\n                }\n                x = num[0];\n                y = num[1];\n                num += 2;\n                count -= 2;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'h': {\n                x = num[0] + offsetX;\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'H': {\n                x = num[0];\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'v': {\n                y = num[0] + offsetY;\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'V': {\n                y = num[0];\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'c': {\n                if (count < 6) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c1(num[0] + offsetX, num[1] + offsetY);\n                QPointF c2(num[2] + offsetX, num[3] + offsetY);\n                QPointF e(num[4] + offsetX, num[5] + offsetY);\n                num += 6;\n                count -= 6;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'C': {\n                if (count < 6) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c1(num[0], num[1]);\n                QPointF c2(num[2], num[3]);\n                QPointF e(num[4], num[5]);\n                num += 6;\n                count -= 6;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 's': {\n                if (count < 4) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c1;\n                if (lastMode == 'c' || lastMode == 'C' ||\n                    lastMode == 's' || lastMode == 'S')\n                    c1 = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c1 = QPointF(x, y);\n                QPointF c2(num[0] + offsetX, num[1] + offsetY);\n                QPointF e(num[2] + offsetX, num[3] + offsetY);\n                num += 4;\n                count -= 4;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'S': {\n                if (count < 4) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c1;\n                if (lastMode == 'c' || lastMode == 'C' ||\n                    lastMode == 's' || lastMode == 'S')\n                    c1 = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c1 = QPointF(x, y);\n                QPointF c2(num[0], num[1]);\n                QPointF e(num[2], num[3]);\n                num += 4;\n                count -= 4;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'q': {\n                if (count < 4) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c(num[0] + offsetX, num[1] + offsetY);\n                QPointF e(num[2] + offsetX, num[3] + offsetY);\n                num += 4;\n                count -= 4;\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'Q': {\n                if (count < 4) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c(num[0], num[1]);\n                QPointF e(num[2], num[3]);\n                num += 4;\n                count -= 4;\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 't': {\n                if (count < 2) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF e(num[0] + offsetX, num[1] + offsetY);\n                num += 2;\n                count -= 2;\n                QPointF c;\n                if (lastMode == 'q' || lastMode == 'Q' ||\n                    lastMode == 't' || lastMode == 'T')\n                    c = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c = QPointF(x, y);\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'T': {\n                if (count < 2) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF e(num[0], num[1]);\n                num += 2;\n                count -= 2;\n                QPointF c;\n                if (lastMode == 'q' || lastMode == 'Q' ||\n                    lastMode == 't' || lastMode == 'T')\n                    c = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c = QPointF(x, y);\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'a': {\n                if (count < 7) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                qreal rx = (*num++);\n                qreal ry = (*num++);\n                qreal xAxisRotation = (*num++);\n                qreal largeArcFlag  = (*num++);\n                qreal sweepFlag = (*num++);\n                qreal ex = (*num++) + offsetX;\n                qreal ey = (*num++) + offsetY;\n                count -= 7;\n                qreal curx = x;\n                qreal cury = y;\n                pathArc(path, rx, ry, xAxisRotation, int(largeArcFlag),\n                        int(sweepFlag), ex, ey, curx, cury);\n\n                x = ex;\n                y = ey;\n            }\n                break;\n            case 'A': {\n                if (count < 7) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                qreal rx = (*num++);\n                qreal ry = (*num++);\n                qreal xAxisRotation = (*num++);\n                qreal largeArcFlag  = (*num++);\n                qreal sweepFlag = (*num++);\n                qreal ex = (*num++);\n                qreal ey = (*num++);\n                count -= 7;\n                qreal curx = x;\n                qreal cury = y;\n                pathArc(path, rx, ry, xAxisRotation, int(largeArcFlag),\n                        int(sweepFlag), ex, ey, curx, cury);\n\n                x = ex;\n                y = ey;\n            }\n                break;\n            default:\n                return false;\n            }\n            lastMode = pathElem.toLatin1();\n        }\n    }\n    return true;\n}\n\nstatic bool parseStyle(QSvgNode *node,\n                       const QXmlStreamAttributes &attributes,\n                       QSvgHandler *);\n\nstatic bool parseStyle(QSvgNode *node,\n                       const QSvgAttributes &attributes,\n                       QSvgHandler *);\n\n#ifndef QT_NO_CSSPARSER\n\nstatic void parseCSStoXMLAttrs(const QList<QCss::Declaration> &declarations,\n                               QXmlStreamAttributes &attributes)\n{\n    for (int i = 0; i < declarations.count(); ++i) {\n        const QCss::Declaration &decl = declarations.at(i);\n        if (decl.d->property.isEmpty())\n            continue;\n        QCss::Value val = decl.d->values.first();\n        QString valueStr;\n        const int valCount = decl.d->values.count();\n        if (valCount != 1) {\n            for (int i = 0; i < valCount; ++i) {\n                valueStr += decl.d->values[i].toString();\n                if (i + 1 < valCount)\n                    valueStr += QLatin1Char(',');\n            }\n        } else {\n            valueStr = val.toString();\n        }\n        if (val.type == QCss::Value::Uri) {\n            valueStr.prepend(QLatin1String(\"url(\"));\n            valueStr.append(QLatin1Char(')'));\n        } else if (val.type == QCss::Value::Function) {\n            QStringList lst = val.variant.toStringList();\n            valueStr.append(lst.at(0));\n            valueStr.append(QLatin1Char('('));\n            for (int i = 1; i < lst.count(); ++i) {\n                valueStr.append(lst.at(i));\n                if ((i +1) < lst.count())\n                    valueStr.append(QLatin1Char(','));\n            }\n            valueStr.append(QLatin1Char(')'));\n        } else if (val.type == QCss::Value::KnownIdentifier) {\n            switch (val.variant.toInt()) {\n            case QCss::Value_None:\n                valueStr = QLatin1String(\"none\");\n                break;\n            default:\n                break;\n            }\n        }\n\n        attributes.append(QString(), decl.d->property, valueStr);\n    }\n}\n\nvoid QSvgHandler::parseCSStoXMLAttrs(const QString &css, QList<QSvgCssAttribute> *attributes)\n{\n    // preprocess (for unicode escapes), tokenize and remove comments\n    m_cssParser.init(css);\n    QString key;\n\n    attributes->reserve(10);\n\n    while (m_cssParser.hasNext()) {\n        m_cssParser.skipSpace();\n\n        if (!m_cssParser.hasNext())\n            break;\n        m_cssParser.next();\n\n        QString name;\n        if (m_cssParser.hasEscapeSequences) {\n            key = m_cssParser.lexem();\n            name = key;\n        } else {\n            const QCss::Symbol &sym = m_cssParser.symbol();\n            name = sym.text.mid(sym.start, sym.len);\n        }\n\n        m_cssParser.skipSpace();\n        if (!m_cssParser.test(QCss::COLON))\n            break;\n\n        m_cssParser.skipSpace();\n        if (!m_cssParser.hasNext())\n            break;\n\n        QSvgCssAttribute attribute;\n        attribute.name = name;\n\n        const int firstSymbol = m_cssParser.index;\n        int symbolCount = 0;\n        do {\n            m_cssParser.next();\n            ++symbolCount;\n        } while (m_cssParser.hasNext() && !m_cssParser.test(QCss::SEMICOLON));\n\n        bool canExtractValueByRef = !m_cssParser.hasEscapeSequences;\n        if (canExtractValueByRef) {\n            int len = m_cssParser.symbols.at(firstSymbol).len;\n            for (int i = firstSymbol + 1; i < firstSymbol + symbolCount; ++i) {\n                len += m_cssParser.symbols.at(i).len;\n\n                if (m_cssParser.symbols.at(i - 1).start + m_cssParser.symbols.at(i - 1).len\n                        != m_cssParser.symbols.at(i).start) {\n                    canExtractValueByRef = false;\n                    break;\n                }\n            }\n            if (canExtractValueByRef) {\n                const QCss::Symbol &sym = m_cssParser.symbols.at(firstSymbol);\n                attribute.value = sym.text.mid(sym.start, len);\n            }\n        }\n        if (!canExtractValueByRef) {\n            QString value;\n            for (int i = firstSymbol; i < m_cssParser.index - 1; ++i)\n                value += m_cssParser.symbols.at(i).lexem();\n            attribute.value = value;\n        }\n\n        attributes->append(attribute);\n\n        m_cssParser.skipSpace();\n    }\n}\n\nstatic void cssStyleLookup(QSvgNode *node,\n                           QSvgHandler *handler,\n                           QSvgStyleSelector *selector)\n{\n    QCss::StyleSelector::NodePtr cssNode;\n    cssNode.ptr = node;\n    QList<QCss::Declaration> decls = selector->declarationsForNode(cssNode);\n\n    QXmlStreamAttributes attributes;\n    parseCSStoXMLAttrs(decls, attributes);\n    parseStyle(node, attributes, handler);\n}\n\n#endif // QT_NO_CSSPARSER\n\nstatic inline QStringList stringToList(const QString &str)\n{\n    QStringList lst = str.split(QLatin1Char(','), Qt::SkipEmptyParts);\n    return lst;\n}\n\nstatic bool parseCoreNode(QSvgNode *node,\n                          const QXmlStreamAttributes &attributes)\n{\n    QStringList features;\n    QStringList extensions;\n    QStringList languages;\n    QStringList formats;\n    QStringList fonts;\n    QString xmlClassStr;\n\n    for (int i = 0; i < attributes.count(); ++i) {\n        const QXmlStreamAttribute &attribute = attributes.at(i);\n        QStringView name = attribute.qualifiedName();\n        if (name.isEmpty())\n            continue;\n        QStringView value = attribute.value();\n        switch (name.at(0).unicode()) {\n        case 'c':\n            if (name == QLatin1String(\"class\"))\n                xmlClassStr = value.toString();\n            break;\n        case 'r':\n            if (name == QLatin1String(\"requiredFeatures\"))\n                features = stringToList(value.toString());\n            else if (name == QLatin1String(\"requiredExtensions\"))\n                extensions = stringToList(value.toString());\n            else if (name == QLatin1String(\"requiredFormats\"))\n                formats = stringToList(value.toString());\n            else if (name == QLatin1String(\"requiredFonts\"))\n                fonts = stringToList(value.toString());\n            break;\n        case 's':\n            if (name == QLatin1String(\"systemLanguage\"))\n                languages = stringToList(value.toString());\n            break;\n        default:\n            break;\n        }\n    }\n\n    node->setRequiredFeatures(features);\n    node->setRequiredExtensions(extensions);\n    node->setRequiredLanguages(languages);\n    node->setRequiredFormats(formats);\n    node->setRequiredFonts(fonts);\n    node->setNodeId(someId(attributes));\n    node->setXmlClass(xmlClassStr);\n\n    return true;\n}\n\nstatic void parseOpacity(QSvgNode *node,\n                         const QSvgAttributes &attributes,\n                         QSvgHandler *)\n{\n    if (attributes.opacity.isEmpty())\n        return;\n\n    const QStringView value = attributes.opacity.trimmed();\n\n    bool ok = false;\n    qreal op = value.toDouble(&ok);\n\n    if (ok) {\n        QSvgOpacityStyle *opacity = new QSvgOpacityStyle(qBound(qreal(0.0), op, qreal(1.0)));\n        node->appendStyleProperty(opacity, attributes.id);\n    }\n}\n\nstatic QPainter::CompositionMode svgToQtCompositionMode(const QString &op)\n{\n#define NOOP qDebug()<<\"Operation: \"<<op<<\" is not implemented\"\n    if (op == QLatin1String(\"clear\")) {\n        return QPainter::CompositionMode_Clear;\n    } else if (op == QLatin1String(\"src\")) {\n        return QPainter::CompositionMode_Source;\n    } else if (op == QLatin1String(\"dst\")) {\n        return QPainter::CompositionMode_Destination;\n    } else if (op == QLatin1String(\"src-over\")) {\n        return QPainter::CompositionMode_SourceOver;\n    } else if (op == QLatin1String(\"dst-over\")) {\n        return QPainter::CompositionMode_DestinationOver;\n    } else if (op == QLatin1String(\"src-in\")) {\n        return QPainter::CompositionMode_SourceIn;\n    } else if (op == QLatin1String(\"dst-in\")) {\n        return QPainter::CompositionMode_DestinationIn;\n    } else if (op == QLatin1String(\"src-out\")) {\n        return QPainter::CompositionMode_SourceOut;\n    } else if (op == QLatin1String(\"dst-out\")) {\n        return QPainter::CompositionMode_DestinationOut;\n    } else if (op == QLatin1String(\"src-atop\")) {\n        return QPainter::CompositionMode_SourceAtop;\n    } else if (op == QLatin1String(\"dst-atop\")) {\n        return QPainter::CompositionMode_DestinationAtop;\n    } else if (op == QLatin1String(\"xor\")) {\n        return QPainter::CompositionMode_Xor;\n    } else if (op == QLatin1String(\"plus\")) {\n        return QPainter::CompositionMode_Plus;\n    } else if (op == QLatin1String(\"multiply\")) {\n        return QPainter::CompositionMode_Multiply;\n    } else if (op == QLatin1String(\"screen\")) {\n        return QPainter::CompositionMode_Screen;\n    } else if (op == QLatin1String(\"overlay\")) {\n        return QPainter::CompositionMode_Overlay;\n    } else if (op == QLatin1String(\"darken\")) {\n        return QPainter::CompositionMode_Darken;\n    } else if (op == QLatin1String(\"lighten\")) {\n        return QPainter::CompositionMode_Lighten;\n    } else if (op == QLatin1String(\"color-dodge\")) {\n        return QPainter::CompositionMode_ColorDodge;\n    } else if (op == QLatin1String(\"color-burn\")) {\n        return QPainter::CompositionMode_ColorBurn;\n    } else if (op == QLatin1String(\"hard-light\")) {\n        return QPainter::CompositionMode_HardLight;\n    } else if (op == QLatin1String(\"soft-light\")) {\n        return QPainter::CompositionMode_SoftLight;\n    } else if (op == QLatin1String(\"difference\")) {\n        return QPainter::CompositionMode_Difference;\n    } else if (op == QLatin1String(\"exclusion\")) {\n        return QPainter::CompositionMode_Exclusion;\n    } else {\n        NOOP;\n    }\n\n    return QPainter::CompositionMode_SourceOver;\n}\n\nstatic void parseCompOp(QSvgNode *node,\n                        const QSvgAttributes &attributes,\n                        QSvgHandler *)\n{\n    if (attributes.compOp.isEmpty())\n        return;\n    QString value = attributes.compOp.toString().trimmed();\n\n    if (!value.isEmpty()) {\n        QSvgCompOpStyle *compop = new QSvgCompOpStyle(svgToQtCompositionMode(value));\n        node->appendStyleProperty(compop, attributes.id);\n    }\n}\n\nstatic inline QSvgNode::DisplayMode displayStringToEnum(const QString &str)\n{\n    if (str == QLatin1String(\"inline\")) {\n        return QSvgNode::InlineMode;\n    } else if (str == QLatin1String(\"block\")) {\n        return QSvgNode::BlockMode;\n    } else if (str == QLatin1String(\"list-item\")) {\n        return QSvgNode::ListItemMode;\n    } else if (str == QLatin1String(\"run-in\")) {\n        return QSvgNode::RunInMode;\n    } else if (str == QLatin1String(\"compact\")) {\n        return QSvgNode::CompactMode;\n    } else if (str == QLatin1String(\"marker\")) {\n        return QSvgNode::MarkerMode;\n    } else if (str == QLatin1String(\"table\")) {\n        return QSvgNode::TableMode;\n    } else if (str == QLatin1String(\"inline-table\")) {\n        return QSvgNode::InlineTableMode;\n    } else if (str == QLatin1String(\"table-row-group\")) {\n        return QSvgNode::TableRowGroupMode;\n    } else if (str == QLatin1String(\"table-header-group\")) {\n        return QSvgNode::TableHeaderGroupMode;\n    } else if (str == QLatin1String(\"table-footer-group\")) {\n        return QSvgNode::TableFooterGroupMode;\n    } else if (str == QLatin1String(\"table-row\")) {\n        return QSvgNode::TableRowMode;\n    } else if (str == QLatin1String(\"table-column-group\")) {\n        return QSvgNode::TableColumnGroupMode;\n    } else if (str == QLatin1String(\"table-column\")) {\n        return QSvgNode::TableColumnMode;\n    } else if (str == QLatin1String(\"table-cell\")) {\n        return QSvgNode::TableCellMode;\n    } else if (str == QLatin1String(\"table-caption\")) {\n        return QSvgNode::TableCaptionMode;\n    } else if (str == QLatin1String(\"none\")) {\n        return QSvgNode::NoneMode;\n    } else if (str == QT_INHERIT) {\n        return QSvgNode::InheritMode;\n    }\n    return QSvgNode::BlockMode;\n}\n\nstatic void parseOthers(QSvgNode *node,\n                        const QSvgAttributes &attributes,\n                        QSvgHandler *)\n{\n    if (attributes.display.isEmpty())\n        return;\n    QString displayStr = attributes.display.toString().trimmed();\n\n    if (!displayStr.isEmpty()) {\n        node->setDisplayMode(displayStringToEnum(displayStr));\n    }\n}\n\nstatic void parseRenderingHints(QSvgNode *node,\n                                const QSvgAttributes &attributes,\n                                QSvgHandler *)\n{\n    if (attributes.imageRendering.isEmpty())\n        return;\n\n    QString ir = attributes.imageRendering.toString().trimmed();\n    QSvgQualityStyle *p = new QSvgQualityStyle(0);\n    if (ir == QLatin1String(\"auto\"))\n        p->setImageRendering(QSvgQualityStyle::ImageRenderingAuto);\n    else if (ir == QLatin1String(\"optimizeSpeed\"))\n        p->setImageRendering(QSvgQualityStyle::ImageRenderingOptimizeSpeed);\n    else if (ir == QLatin1String(\"optimizeQuality\"))\n        p->setImageRendering(QSvgQualityStyle::ImageRenderingOptimizeQuality);\n    node->appendStyleProperty(p, attributes.id);\n}\n\n\nstatic bool parseStyle(QSvgNode *node,\n                       const QSvgAttributes &attributes,\n                       QSvgHandler *handler)\n{\n    parseColor(node, attributes, handler);\n    parseBrush(node, attributes, handler);\n    parsePen(node, attributes, handler);\n    parseFont(node, attributes, handler);\n    parseTransform(node, attributes, handler);\n    parseVisibility(node, attributes, handler);\n    parseOpacity(node, attributes, handler);\n    parseCompOp(node, attributes, handler);\n    parseRenderingHints(node, attributes, handler);\n    parseOthers(node, attributes, handler);\n\n#if 0\n    value = attributes.value(\"audio-level\");\n\n    value = attributes.value(\"color-rendering\");\n\n    value = attributes.value(\"display-align\");\n\n    value = attributes.value(\"image-rendering\");\n\n    value = attributes.value(\"line-increment\");\n\n    value = attributes.value(\"pointer-events\");\n\n    value = attributes.value(\"shape-rendering\");\n\n    value = attributes.value(\"solid-color\");\n\n    value = attributes.value(\"solid-opacity\");\n\n    value = attributes.value(\"text-rendering\");\n\n    value = attributes.value(\"vector-effect\");\n\n    value = attributes.value(\"viewport-fill\");\n\n    value = attributes.value(\"viewport-fill-opacity\");\n#endif\n    return true;\n}\n\nstatic bool parseStyle(QSvgNode *node,\n                       const QXmlStreamAttributes &attrs,\n                       QSvgHandler *handler)\n{\n    return parseStyle(node, QSvgAttributes(attrs, handler), handler);\n}\n\nstatic bool parseAnchorNode(QSvgNode *parent,\n                            const QXmlStreamAttributes &attributes,\n                            QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseAnimateNode(QSvgNode *parent,\n                             const QXmlStreamAttributes &attributes,\n                             QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic int parseClockValue(QStringView str, bool *ok)\n{\n    int res = 0;\n    int ms = 1000;\n    str = str.trimmed();\n    if (str.endsWith(QLatin1String(\"ms\"))) {\n        str.chop(2);\n        ms = 1;\n    } else if (str.endsWith(QLatin1String(\"s\"))) {\n        str.chop(1);\n    }\n    double val = ms * toDouble(str, ok);\n    if (ok) {\n        if (val > std::numeric_limits<int>::min() && val < std::numeric_limits<int>::max())\n            res = static_cast<int>(val);\n        else\n            *ok = false;\n    }\n    return res;\n}\n\nstatic bool parseAnimateColorNode(QSvgNode *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *handler)\n{\n    QStringView fromStr    = attributes.value(QLatin1String(\"from\"));\n    QStringView toStr      = attributes.value(QLatin1String(\"to\"));\n    QString valuesStr  = attributes.value(QLatin1String(\"values\")).toString();\n    QString beginStr   = attributes.value(QLatin1String(\"begin\")).toString();\n    QString durStr     = attributes.value(QLatin1String(\"dur\")).toString();\n    QString targetStr  = attributes.value(QLatin1String(\"attributeName\")).toString();\n    QString repeatStr  = attributes.value(QLatin1String(\"repeatCount\")).toString();\n    QString fillStr    = attributes.value(QLatin1String(\"fill\")).toString();\n\n    QList<QColor> colors;\n    if (valuesStr.isEmpty()) {\n        QColor startColor, endColor;\n        resolveColor(fromStr, startColor, handler);\n        resolveColor(toStr, endColor, handler);\n        colors.reserve(2);\n        colors.append(startColor);\n        colors.append(endColor);\n    } else {\n        QStringList str = valuesStr.split(QLatin1Char(';'));\n        colors.reserve(str.count());\n        QStringList::const_iterator itr;\n        for (itr = str.constBegin(); itr != str.constEnd(); ++itr) {\n            QColor color;\n            resolveColor(*itr, color, handler);\n            colors.append(color);\n        }\n    }\n\n    bool ok = true;\n    int begin = parseClockValue(beginStr, &ok);\n    if (!ok)\n        return false;\n    int end = begin + parseClockValue(durStr, &ok);\n    if (!ok || end <= begin)\n        return false;\n\n    QSvgAnimateColor *anim = new QSvgAnimateColor(begin, end, 0);\n    anim->setArgs((targetStr == QLatin1String(\"fill\")), colors);\n    anim->setFreeze(fillStr == QLatin1String(\"freeze\"));\n    anim->setRepeatCount(\n        (repeatStr == QLatin1String(\"indefinite\")) ? -1 :\n            (repeatStr == QLatin1String(\"\")) ? 1 : toDouble(repeatStr));\n\n    parent->appendStyleProperty(anim, someId(attributes));\n    parent->document()->setAnimated(true);\n    handler->setAnimPeriod(begin, end);\n    return true;\n}\n\nstatic bool parseAimateMotionNode(QSvgNode *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic void parseNumberTriplet(QList<qreal> &values, const QChar *&s)\n{\n    QList<qreal> list = parseNumbersList(s);\n    values << list;\n    for (int i = 3 - list.size(); i > 0; --i)\n        values.append(0.0);\n}\n\nstatic bool parseAnimateTransformNode(QSvgNode *parent,\n                                      const QXmlStreamAttributes &attributes,\n                                      QSvgHandler *handler)\n{\n    QString typeStr    = attributes.value(QLatin1String(\"type\")).toString();\n    QString values     = attributes.value(QLatin1String(\"values\")).toString();\n    QString beginStr   = attributes.value(QLatin1String(\"begin\")).toString();\n    QString durStr     = attributes.value(QLatin1String(\"dur\")).toString();\n    QString repeatStr  = attributes.value(QLatin1String(\"repeatCount\")).toString();\n    QString fillStr    = attributes.value(QLatin1String(\"fill\")).toString();\n    QString fromStr    = attributes.value(QLatin1String(\"from\")).toString();\n    QString toStr      = attributes.value(QLatin1String(\"to\")).toString();\n    QString byStr      = attributes.value(QLatin1String(\"by\")).toString();\n    QString addtv      = attributes.value(QLatin1String(\"additive\")).toString();\n\n    QSvgAnimateTransform::Additive additive = QSvgAnimateTransform::Replace;\n    if (addtv == QLatin1String(\"sum\"))\n        additive = QSvgAnimateTransform::Sum;\n\n    QList<qreal> vals;\n    if (values.isEmpty()) {\n        const QChar *s;\n        if (fromStr.isEmpty()) {\n            if (!byStr.isEmpty()) {\n                // By-animation.\n                additive = QSvgAnimateTransform::Sum;\n                vals.append(0.0);\n                vals.append(0.0);\n                vals.append(0.0);\n                parseNumberTriplet(vals, s = byStr.constData());\n            } else {\n                // To-animation not defined.\n                return false;\n            }\n        } else {\n            if (!toStr.isEmpty()) {\n                // From-to-animation.\n                parseNumberTriplet(vals, s = fromStr.constData());\n                parseNumberTriplet(vals, s = toStr.constData());\n            } else if (!byStr.isEmpty()) {\n                // From-by-animation.\n                parseNumberTriplet(vals, s = fromStr.constData());\n                parseNumberTriplet(vals, s = byStr.constData());\n                for (int i = vals.size() - 3; i < vals.size(); ++i)\n                    vals[i] += vals[i - 3];\n            } else {\n                return false;\n            }\n        }\n    } else {\n        const QChar *s = values.constData();\n        while (s && *s != QLatin1Char(0)) {\n            parseNumberTriplet(vals, s);\n            if (*s == QLatin1Char(0))\n                break;\n            ++s;\n        }\n    }\n\n    bool ok = true;\n    int begin = parseClockValue(beginStr, &ok);\n    if (!ok)\n        return false;\n    int end = begin + parseClockValue(durStr, &ok);\n    if (!ok || end <= begin)\n        return false;\n\n    QSvgAnimateTransform::TransformType type = QSvgAnimateTransform::Empty;\n    if (typeStr == QLatin1String(\"translate\")) {\n        type = QSvgAnimateTransform::Translate;\n    } else if (typeStr == QLatin1String(\"scale\")) {\n        type = QSvgAnimateTransform::Scale;\n    } else if (typeStr == QLatin1String(\"rotate\")) {\n        type = QSvgAnimateTransform::Rotate;\n    } else if (typeStr == QLatin1String(\"skewX\")) {\n        type = QSvgAnimateTransform::SkewX;\n    } else if (typeStr == QLatin1String(\"skewY\")) {\n        type = QSvgAnimateTransform::SkewY;\n    } else {\n        return false;\n    }\n\n    QSvgAnimateTransform *anim = new QSvgAnimateTransform(begin, end, 0);\n    anim->setArgs(type, additive, vals);\n    anim->setFreeze(fillStr == QLatin1String(\"freeze\"));\n    anim->setRepeatCount(\n            (repeatStr == QLatin1String(\"indefinite\"))? -1 :\n            (repeatStr == QLatin1String(\"\"))? 1 : toDouble(repeatStr));\n\n    parent->appendStyleProperty(anim, someId(attributes));\n    parent->document()->setAnimated(true);\n    handler->setAnimPeriod(begin, end);\n    return true;\n}\n\nstatic QSvgNode * createAnimationNode(QSvgNode *parent,\n                                      const QXmlStreamAttributes &attributes,\n                                      QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return 0;\n}\n\nstatic bool parseAudioNode(QSvgNode *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createCircleNode(QSvgNode *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *)\n{\n    const QStringView cx = attributes.value(QLatin1String(\"cx\"));\n    const QStringView cy = attributes.value(QLatin1String(\"cy\"));\n    const QStringView r = attributes.value(QLatin1String(\"r\"));\n    qreal ncx = toDouble(cx);\n    qreal ncy = toDouble(cy);\n    qreal nr  = toDouble(r);\n    if (nr < 0.0)\n        return nullptr;\n\n    QRectF rect(ncx-nr, ncy-nr, nr*2, nr*2);\n    QSvgNode *circle = new QSvgCircle(parent, rect);\n    return circle;\n}\n\nstatic QSvgNode *createDefsNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    Q_UNUSED(attributes);\n    QSvgDefs *defs = new QSvgDefs(parent);\n    return defs;\n}\n\nstatic bool parseDescNode(QSvgNode *parent,\n                          const QXmlStreamAttributes &attributes,\n                          QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseDiscardNode(QSvgNode *parent,\n                             const QXmlStreamAttributes &attributes,\n                             QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createEllipseNode(QSvgNode *parent,\n                                   const QXmlStreamAttributes &attributes,\n                                   QSvgHandler *)\n{\n    const QStringView cx = attributes.value(QLatin1String(\"cx\"));\n    const QStringView cy = attributes.value(QLatin1String(\"cy\"));\n    const QStringView rx = attributes.value(QLatin1String(\"rx\"));\n    const QStringView ry = attributes.value(QLatin1String(\"ry\"));\n    qreal ncx = toDouble(cx);\n    qreal ncy = toDouble(cy);\n    qreal nrx = toDouble(rx);\n    qreal nry = toDouble(ry);\n\n    QRectF rect(ncx-nrx, ncy-nry, nrx*2, nry*2);\n    QSvgNode *ellipse = new QSvgEllipse(parent, rect);\n    return ellipse;\n}\n\nstatic QSvgStyleProperty *createFontNode(QSvgNode *parent,\n                                         const QXmlStreamAttributes &attributes,\n                                         QSvgHandler *)\n{\n    const QStringView hax = attributes.value(QLatin1String(\"horiz-adv-x\"));\n    QString myId     = someId(attributes);\n\n    qreal horizAdvX = toDouble(hax);\n\n    while (parent && parent->type() != QSvgNode::DOC) {\n        parent = parent->parent();\n    }\n\n    if (parent && !myId.isEmpty()) {\n        QSvgTinyDocument *doc = static_cast<QSvgTinyDocument*>(parent);\n        QSvgFont *font = doc->svgFont(myId);\n        if (!font) {\n            font = new QSvgFont(horizAdvX);\n            font->setFamilyName(myId);\n            doc->addSvgFont(font);\n        }\n        return new QSvgFontStyle(font, doc);\n    }\n    return nullptr;\n}\n\nstatic bool parseFontFaceNode(QSvgStyleProperty *parent,\n                              const QXmlStreamAttributes &attributes,\n                              QSvgHandler *)\n{\n    if (parent->type() != QSvgStyleProperty::FONT) {\n        return false;\n    }\n\n    QSvgFontStyle *style = static_cast<QSvgFontStyle*>(parent);\n    QSvgFont *font = style->svgFont();\n    QString name   = attributes.value(QLatin1String(\"font-family\")).toString();\n    const QStringView unitsPerEmStr = attributes.value(QLatin1String(\"units-per-em\"));\n\n    qreal unitsPerEm = toDouble(unitsPerEmStr);\n    if (!unitsPerEm)\n        unitsPerEm = 1000;\n\n    if (!name.isEmpty())\n        font->setFamilyName(name);\n    font->setUnitsPerEm(unitsPerEm);\n\n    if (!font->familyName().isEmpty())\n        if (!style->doc()->svgFont(font->familyName()))\n            style->doc()->addSvgFont(font);\n\n    return true;\n}\n\nstatic bool parseFontFaceNameNode(QSvgStyleProperty *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *)\n{\n    if (parent->type() != QSvgStyleProperty::FONT) {\n        return false;\n    }\n\n    QSvgFontStyle *style = static_cast<QSvgFontStyle*>(parent);\n    QSvgFont *font = style->svgFont();\n    QString name   = attributes.value(QLatin1String(\"name\")).toString();\n\n    if (!name.isEmpty())\n        font->setFamilyName(name);\n\n    if (!font->familyName().isEmpty())\n        if (!style->doc()->svgFont(font->familyName()))\n            style->doc()->addSvgFont(font);\n\n    return true;\n}\n\nstatic bool parseFontFaceSrcNode(QSvgStyleProperty *parent,\n                                 const QXmlStreamAttributes &attributes,\n                                 QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseFontFaceUriNode(QSvgStyleProperty *parent,\n                                 const QXmlStreamAttributes &attributes,\n                                 QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseForeignObjectNode(QSvgNode *parent,\n                                   const QXmlStreamAttributes &attributes,\n                                   QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createGNode(QSvgNode *parent,\n                             const QXmlStreamAttributes &attributes,\n                             QSvgHandler *)\n{\n    Q_UNUSED(attributes);\n    QSvgG *node = new QSvgG(parent);\n    return node;\n}\n\nstatic bool parseGlyphNode(QSvgStyleProperty *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *)\n{\n    if (parent->type() != QSvgStyleProperty::FONT) {\n        return false;\n    }\n\n    QSvgFontStyle *style = static_cast<QSvgFontStyle*>(parent);\n    QSvgFont *font = style->svgFont();\n    createSvgGlyph(font, attributes);\n    return true;\n}\n\nstatic bool parseHandlerNode(QSvgNode *parent,\n                             const QXmlStreamAttributes &attributes,\n                             QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseHkernNode(QSvgNode *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createImageNode(QSvgNode *parent,\n                                 const QXmlStreamAttributes &attributes,\n                                 QSvgHandler *handler)\n{\n    const QStringView x = attributes.value(QLatin1String(\"x\"));\n    const QStringView y = attributes.value(QLatin1String(\"y\"));\n    const QStringView width  = attributes.value(QLatin1String(\"width\"));\n    const QStringView height = attributes.value(QLatin1String(\"height\"));\n    QString filename = attributes.value(QLatin1String(\"xlink:href\")).toString();\n    qreal nx = toDouble(x);\n    qreal ny = toDouble(y);\n    QSvgHandler::LengthType type;\n    qreal nwidth = parseLength(width.toString(), type, handler);\n    nwidth = convertToPixels(nwidth, true, type);\n\n    qreal nheight = parseLength(height.toString(), type, handler);\n    nheight = convertToPixels(nheight, false, type);\n\n    filename = filename.trimmed();\n    if (filename.isEmpty()) {\n        qCWarning(lcSvgHandler) << \"QSvgHandler: Image filename is empty\";\n        return 0;\n    }\n    if (nwidth <= 0 || nheight <= 0) {\n        qCWarning(lcSvgHandler) << \"QSvgHandler: Width or height for\" << filename << \"image was not greater than 0\";\n        return 0;\n    }\n\n    QImage image;\n    if (filename.startsWith(QLatin1String(\"data\"))) {\n        int idx = filename.lastIndexOf(QLatin1String(\"base64,\"));\n        if (idx != -1) {\n            idx += 7;\n            const QString dataStr = filename.mid(idx);\n            QByteArray data = QByteArray::fromBase64(dataStr.toLatin1());\n            image = QImage::fromData(data);\n        } else {\n            qCDebug(lcSvgHandler) << \"QSvgHandler::createImageNode: Unrecognized inline image format!\";\n        }\n    } else {\n        const auto *file = qobject_cast<QFile *>(handler->device());\n        if (file) {\n            QUrl url(filename);\n            if (url.isRelative()) {\n                QFileInfo info(file->fileName());\n                filename = info.absoluteDir().absoluteFilePath(filename);\n            }\n        }\n        image = QImage(filename);\n    }\n\n    if (image.isNull()) {\n        qCWarning(lcSvgHandler) << \"Could not create image from\" << filename;\n        return 0;\n    }\n\n    if (image.format() == QImage::Format_ARGB32)\n        image = image.convertToFormat(QImage::Format_ARGB32_Premultiplied);\n\n    QSvgNode *img = new QSvgImage(parent,\n                                  image,\n                                  QRectF(nx,\n                                         ny,\n                                         nwidth,\n                                         nheight));\n    return img;\n}\n\nstatic QSvgNode *createLineNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    const QStringView x1 = attributes.value(QLatin1String(\"x1\"));\n    const QStringView y1 = attributes.value(QLatin1String(\"y1\"));\n    const QStringView x2 = attributes.value(QLatin1String(\"x2\"));\n    const QStringView y2 = attributes.value(QLatin1String(\"y2\"));\n    qreal nx1 = toDouble(x1);\n    qreal ny1 = toDouble(y1);\n    qreal nx2 = toDouble(x2);\n    qreal ny2 = toDouble(y2);\n\n    QLineF lineBounds(nx1, ny1, nx2, ny2);\n    QSvgNode *line = new QSvgLine(parent, lineBounds);\n    return line;\n}\n\n\nstatic void parseBaseGradient(QSvgNode *node,\n                              const QXmlStreamAttributes &attributes,\n                              QSvgGradientStyle *gradProp,\n                              QSvgHandler *handler)\n{\n    QString link   = attributes.value(QLatin1String(\"xlink:href\")).toString();\n    QStringView trans  = attributes.value(QLatin1String(\"gradientTransform\"));\n    QString spread = attributes.value(QLatin1String(\"spreadMethod\")).toString();\n    QString units = attributes.value(QLatin1String(\"gradientUnits\")).toString();\n    QStringView colorStr = attributes.value(QLatin1String(\"color\"));\n    QStringView colorOpacityStr = attributes.value(QLatin1String(\"color-opacity\"));\n\n    QColor color;\n    if (constructColor(colorStr, colorOpacityStr, color, handler)) {\n        handler->popColor();\n        handler->pushColor(color);\n    }\n\n    QTransform matrix;\n    QGradient *grad = gradProp->qgradient();\n    if (!link.isEmpty()) {\n        QSvgStyleProperty *prop = node->styleProperty(link);\n        //qDebug()<<\"inherited \"<<prop<<\" (\"<<link<<\")\";\n        if (prop && prop->type() == QSvgStyleProperty::GRADIENT) {\n            QSvgGradientStyle *inherited =\n                static_cast<QSvgGradientStyle*>(prop);\n            if (!inherited->stopLink().isEmpty()) {\n                gradProp->setStopLink(inherited->stopLink(), handler->document());\n            } else {\n                grad->setStops(inherited->qgradient()->stops());\n                gradProp->setGradientStopsSet(inherited->gradientStopsSet());\n            }\n\n            matrix = inherited->qtransform();\n        } else {\n            gradProp->setStopLink(link, handler->document());\n        }\n    }\n\n    if (!trans.isEmpty()) {\n        matrix = parseTransformationMatrix(trans);\n        gradProp->setTransform(matrix);\n    } else if (!matrix.isIdentity()) {\n        gradProp->setTransform(matrix);\n    }\n\n    if (!spread.isEmpty()) {\n        if (spread == QLatin1String(\"pad\")) {\n            grad->setSpread(QGradient::PadSpread);\n        } else if (spread == QLatin1String(\"reflect\")) {\n            grad->setSpread(QGradient::ReflectSpread);\n        } else if (spread == QLatin1String(\"repeat\")) {\n            grad->setSpread(QGradient::RepeatSpread);\n        }\n    }\n\n    if (units.isEmpty() || units == QLatin1String(\"objectBoundingBox\")) {\n         grad->setCoordinateMode(QGradient::ObjectMode);\n    }\n}\n\nstatic QSvgStyleProperty *createLinearGradientNode(QSvgNode *node,\n                                                   const QXmlStreamAttributes &attributes,\n                                                   QSvgHandler *handler)\n{\n    const QStringView x1 = attributes.value(QLatin1String(\"x1\"));\n    const QStringView y1 = attributes.value(QLatin1String(\"y1\"));\n    const QStringView x2 = attributes.value(QLatin1String(\"x2\"));\n    const QStringView y2 = attributes.value(QLatin1String(\"y2\"));\n\n    qreal nx1 = 0.0;\n    qreal ny1 = 0.0;\n    qreal nx2 = 1.0;\n    qreal ny2 = 0.0;\n\n    if (!x1.isEmpty())\n        nx1 =  convertToNumber(x1, handler);\n    if (!y1.isEmpty())\n        ny1 =  convertToNumber(y1, handler);\n    if (!x2.isEmpty())\n        nx2 =  convertToNumber(x2, handler);\n    if (!y2.isEmpty())\n        ny2 =  convertToNumber(y2, handler);\n\n    QSvgNode *itr = node;\n    while (itr && itr->type() != QSvgNode::DOC) {\n        itr = itr->parent();\n    }\n\n    QLinearGradient *grad = new QLinearGradient(nx1, ny1, nx2, ny2);\n    grad->setInterpolationMode(QGradient::ComponentInterpolation);\n    QSvgGradientStyle *prop = new QSvgGradientStyle(grad);\n    parseBaseGradient(node, attributes, prop, handler);\n\n    return prop;\n}\n\nstatic bool parseMetadataNode(QSvgNode *parent,\n                              const QXmlStreamAttributes &attributes,\n                              QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseMissingGlyphNode(QSvgStyleProperty *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *)\n{\n    if (parent->type() != QSvgStyleProperty::FONT) {\n        return false;\n    }\n\n    QSvgFontStyle *style = static_cast<QSvgFontStyle*>(parent);\n    QSvgFont *font = style->svgFont();\n    createSvgGlyph(font, attributes);\n    return true;\n}\n\nstatic bool parseMpathNode(QSvgNode *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringView data = attributes.value(QLatin1String(\"d\"));\n\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    //XXX do error handling\n    parsePathDataFast(data, qpath);\n\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}\n\nstatic QSvgNode *createPolygonNode(QSvgNode *parent,\n                                   const QXmlStreamAttributes &attributes,\n                                   QSvgHandler *)\n{\n    QString pointsStr  = attributes.value(QLatin1String(\"points\")).toString();\n\n    //same QPolygon parsing is in createPolylineNode\n    const QChar *s = pointsStr.constData();\n    QList<qreal> points = parseNumbersList(s);\n    QPolygonF poly(points.count()/2);\n    for (int i = 0; i < poly.size(); ++i)\n        poly[i] = QPointF(points.at(2 * i), points.at(2 * i + 1));\n    QSvgNode *polygon = new QSvgPolygon(parent, poly);\n    return polygon;\n}\n\nstatic QSvgNode *createPolylineNode(QSvgNode *parent,\n                                    const QXmlStreamAttributes &attributes,\n                                    QSvgHandler *)\n{\n    QString pointsStr  = attributes.value(QLatin1String(\"points\")).toString();\n\n    //same QPolygon parsing is in createPolygonNode\n    const QChar *s = pointsStr.constData();\n    QList<qreal> points = parseNumbersList(s);\n    QPolygonF poly(points.count()/2);\n    for (int i = 0; i < poly.size(); ++i)\n        poly[i] = QPointF(points.at(2 * i), points.at(2 * i + 1));\n\n    QSvgNode *line = new QSvgPolyline(parent, poly);\n    return line;\n}\n\nstatic bool parsePrefetchNode(QSvgNode *parent,\n                              const QXmlStreamAttributes &attributes,\n                              QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgStyleProperty *createRadialGradientNode(QSvgNode *node,\n                                                   const QXmlStreamAttributes &attributes,\n                                                   QSvgHandler *handler)\n{\n    const QStringView cx = attributes.value(QLatin1String(\"cx\"));\n    const QStringView cy = attributes.value(QLatin1String(\"cy\"));\n    const QStringView r  = attributes.value(QLatin1String(\"r\"));\n    const QStringView fx = attributes.value(QLatin1String(\"fx\"));\n    const QStringView fy = attributes.value(QLatin1String(\"fy\"));\n\n    qreal ncx = 0.5;\n    qreal ncy = 0.5;\n    if (!cx.isEmpty())\n        ncx = toDouble(cx);\n    if (!cy.isEmpty())\n        ncy = toDouble(cy);\n\n    qreal nr = 0.0;\n    if (!r.isEmpty())\n        nr = toDouble(r);\n    if (nr <= 0.0)\n        return nullptr;\n\n    qreal nfx = ncx;\n    if (!fx.isEmpty())\n        nfx = toDouble(fx);\n    qreal nfy = ncy;\n    if (!fy.isEmpty())\n        nfy = toDouble(fy);\n\n    QRadialGradient *grad = new QRadialGradient(ncx, ncy, nr, nfx, nfy, 0);\n    grad->setInterpolationMode(QGradient::ComponentInterpolation);\n\n    QSvgGradientStyle *prop = new QSvgGradientStyle(grad);\n    parseBaseGradient(node, attributes, prop, handler);\n\n    return prop;\n}\n\nstatic QSvgNode *createRectNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *handler)\n{\n    const QStringView x      = attributes.value(QLatin1String(\"x\"));\n    const QStringView y      = attributes.value(QLatin1String(\"y\"));\n    const QStringView width  = attributes.value(QLatin1String(\"width\"));\n    const QStringView height = attributes.value(QLatin1String(\"height\"));\n    const QStringView rx      = attributes.value(QLatin1String(\"rx\"));\n    const QStringView ry      = attributes.value(QLatin1String(\"ry\"));\n\n    bool ok = true;\n    QSvgHandler::LengthType type;\n    qreal nwidth = parseLength(width.toString(), type, handler, &ok);\n    if (!ok)\n        return nullptr;\n    nwidth = convertToPixels(nwidth, true, type);\n    qreal nheight = parseLength(height.toString(), type, handler, &ok);\n    if (!ok)\n        return nullptr;\n    nheight = convertToPixels(nheight, true, type);\n    qreal nrx = toDouble(rx);\n    qreal nry = toDouble(ry);\n\n    QRectF bounds(toDouble(x), toDouble(y), nwidth, nheight);\n    if (bounds.isEmpty())\n        return nullptr;\n\n    if (!rx.isEmpty() && ry.isEmpty())\n        nry = nrx;\n    else if (!ry.isEmpty() && rx.isEmpty())\n        nrx = nry;\n\n    //9.2 The 'rect'  element clearly specifies it\n    // but the case might in fact be handled because\n    // we draw rounded rectangles differently\n    if (nrx > bounds.width()/2)\n        nrx = bounds.width()/2;\n    if (nry > bounds.height()/2)\n        nry = bounds.height()/2;\n\n    //we draw rounded rect from 0...99\n    //svg from 0...bounds.width()/2 so we're adjusting the\n    //coordinates\n    nrx *= (100/(bounds.width()/2));\n    nry *= (100/(bounds.height()/2));\n\n    QSvgNode *rect = new QSvgRect(parent, bounds,\n                                  int(nrx),\n                                  int(nry));\n    return rect;\n}\n\nstatic bool parseScriptNode(QSvgNode *parent,\n                            const QXmlStreamAttributes &attributes,\n                            QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseSetNode(QSvgNode *parent,\n                         const QXmlStreamAttributes &attributes,\n                         QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgStyleProperty *createSolidColorNode(QSvgNode *parent,\n                                               const QXmlStreamAttributes &attributes,\n                                               QSvgHandler *handler)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    QStringView solidColorStr = attributes.value(QLatin1String(\"solid-color\"));\n    QStringView solidOpacityStr = attributes.value(QLatin1String(\"solid-opacity\"));\n\n    if (solidOpacityStr.isEmpty())\n        solidOpacityStr = attributes.value(QLatin1String(\"opacity\"));\n\n    QColor color;\n    if (!constructColor(solidColorStr, solidOpacityStr, color, handler))\n        return 0;\n    QSvgSolidColorStyle *style = new QSvgSolidColorStyle(color);\n    return style;\n}\n\nstatic bool parseStopNode(QSvgStyleProperty *parent,\n                          const QXmlStreamAttributes &attributes,\n                          QSvgHandler *handler)\n{\n    if (parent->type() != QSvgStyleProperty::GRADIENT)\n        return false;\n    QString nodeIdStr     = someId(attributes);\n    QString xmlClassStr   = attributes.value(QLatin1String(\"class\")).toString();\n\n    //### nasty hack because stop gradients are not in the rendering tree\n    //    we force a dummy node with the same id and class into a rendering\n    //    tree to figure out whether the selector has a style for it\n    //    QSvgStyleSelector should be coded in a way that could avoid it\n    QSvgAnimation anim;\n    anim.setNodeId(nodeIdStr);\n    anim.setXmlClass(xmlClassStr);\n\n    QXmlStreamAttributes xmlAttr = attributes;\n\n#ifndef QT_NO_CSSPARSER\n    QCss::StyleSelector::NodePtr cssNode;\n    cssNode.ptr = &anim;\n    QList<QCss::Declaration> decls = handler->selector()->declarationsForNode(cssNode);\n\n    for (int i = 0; i < decls.count(); ++i) {\n        const QCss::Declaration &decl = decls.at(i);\n\n        if (decl.d->property.isEmpty())\n            continue;\n        if (decl.d->values.count() != 1)\n            continue;\n        QCss::Value val = decl.d->values.first();\n        QString valueStr = val.toString();\n        if (val.type == QCss::Value::Uri) {\n            valueStr.prepend(QLatin1String(\"url(\"));\n            valueStr.append(QLatin1Char(')'));\n        }\n        xmlAttr.append(QString(), decl.d->property, valueStr);\n    }\n\n#endif\n\n    QSvgAttributes attrs(xmlAttr, handler);\n\n    QSvgGradientStyle *style =\n        static_cast<QSvgGradientStyle*>(parent);\n    QStringView colorStr    = attrs.stopColor;\n    QColor color;\n\n    bool ok = true;\n    qreal offset = convertToNumber(attrs.offset, handler, &ok);\n    if (!ok)\n        offset = 0.0;\n    QString black = QString::fromLatin1(\"#000000\");\n    if (colorStr.isEmpty()) {\n        colorStr = black;\n    }\n\n    constructColor(colorStr, attrs.stopOpacity, color, handler);\n\n    QGradient *grad = style->qgradient();\n\n    offset = qMin(qreal(1), qMax(qreal(0), offset)); // Clamp to range [0, 1]\n    QGradientStops stops;\n    if (style->gradientStopsSet()) {\n        stops = grad->stops();\n        // If the stop offset equals the one previously added, add an epsilon to make it greater.\n        if (offset <= stops.back().first)\n            offset = stops.back().first + FLT_EPSILON;\n    }\n\n    // If offset is greater than one, it must be clamped to one.\n    if (offset > 1.0) {\n        if ((stops.size() == 1) || (stops.at(stops.size() - 2).first < 1.0 - FLT_EPSILON)) {\n            stops.back().first = 1.0 - FLT_EPSILON;\n            grad->setStops(stops);\n        }\n        offset = 1.0;\n    }\n\n    grad->setColorAt(offset, color);\n    style->setGradientStopsSet(true);\n    return true;\n}\n\nstatic bool parseStyleNode(QSvgNode *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *handler)\n{\n    Q_UNUSED(parent);\n#ifdef QT_NO_CSSPARSER\n    Q_UNUSED(attributes);\n    Q_UNUSED(handler);\n#else\n    const QStringView type = attributes.value(QLatin1String(\"type\"));\n    if (type.compare(QLatin1String(\"text/css\"), Qt::CaseInsensitive) == 0 || type.isNull())\n        handler->setInStyle(true);\n#endif\n\n    return true;\n}\n\nstatic QSvgNode *createSvgNode(QSvgNode *parent,\n                               const QXmlStreamAttributes &attributes,\n                               QSvgHandler *handler)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n\n    QSvgTinyDocument *node = new QSvgTinyDocument();\n    const QStringView widthStr  = attributes.value(QLatin1String(\"width\"));\n    const QStringView heightStr = attributes.value(QLatin1String(\"height\"));\n    QString viewBoxStr = attributes.value(QLatin1String(\"viewBox\")).toString();\n\n    QSvgHandler::LengthType type = QSvgHandler::LT_PX; // FIXME: is the default correct?\n    qreal width = 0;\n    if (!widthStr.isEmpty()) {\n        width = parseLength(widthStr.toString(), type, handler);\n        if (type != QSvgHandler::LT_PT)\n            width = convertToPixels(width, true, type);\n        node->setWidth(int(width), type == QSvgHandler::LT_PERCENT);\n    }\n    qreal height = 0;\n    if (!heightStr.isEmpty()) {\n        height = parseLength(heightStr.toString(), type, handler);\n        if (type != QSvgHandler::LT_PT)\n            height = convertToPixels(height, false, type);\n        node->setHeight(int(height), type == QSvgHandler::LT_PERCENT);\n    }\n\n    QStringList viewBoxValues;\n    if (!viewBoxStr.isEmpty()) {\n        viewBoxStr = viewBoxStr.replace(QLatin1Char(' '), QLatin1Char(','));\n        viewBoxStr = viewBoxStr.replace(QLatin1Char('\\r'), QLatin1Char(','));\n        viewBoxStr = viewBoxStr.replace(QLatin1Char('\\n'), QLatin1Char(','));\n        viewBoxStr = viewBoxStr.replace(QLatin1Char('\\t'), QLatin1Char(','));\n        viewBoxValues = viewBoxStr.split(QLatin1Char(','), Qt::SkipEmptyParts);\n    }\n    if (viewBoxValues.count() == 4) {\n        QString xStr      = viewBoxValues.at(0).trimmed();\n        QString yStr      = viewBoxValues.at(1).trimmed();\n        QString widthStr  = viewBoxValues.at(2).trimmed();\n        QString heightStr = viewBoxValues.at(3).trimmed();\n\n        QSvgHandler::LengthType lt;\n        qreal x = parseLength(xStr, lt, handler);\n        qreal y = parseLength(yStr, lt, handler);\n        qreal w = parseLength(widthStr, lt, handler);\n        qreal h = parseLength(heightStr, lt, handler);\n\n        node->setViewBox(QRectF(x, y, w, h));\n\n    } else if (width && height) {\n        if (type == QSvgHandler::LT_PT) {\n            width = convertToPixels(width, false, type);\n            height = convertToPixels(height, false, type);\n        }\n        node->setViewBox(QRectF(0, 0, width, height));\n    }\n    handler->setDefaultCoordinateSystem(QSvgHandler::LT_PX);\n\n    return node;\n}\n\nstatic QSvgNode *createSwitchNode(QSvgNode *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *)\n{\n    Q_UNUSED(attributes);\n    QSvgSwitch *node = new QSvgSwitch(parent);\n    return node;\n}\n\nstatic bool parseTbreakNode(QSvgNode *parent,\n                            const QXmlStreamAttributes &,\n                            QSvgHandler *)\n{\n    if (parent->type() != QSvgNode::TEXTAREA)\n        return false;\n    static_cast<QSvgText*>(parent)->addLineBreak();\n    return true;\n}\n\nstatic QSvgNode *createTextNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *handler)\n{\n    const QStringView x = attributes.value(QLatin1String(\"x\"));\n    const QStringView y = attributes.value(QLatin1String(\"y\"));\n    //### editable and rotate not handled\n    QSvgHandler::LengthType type;\n    qreal nx = parseLength(x.toString(), type, handler);\n    nx = convertToPixels(nx, true, type);\n    qreal ny = parseLength(y.toString(), type, handler);\n    ny = convertToPixels(ny, true, type);\n\n    QSvgNode *text = new QSvgText(parent, QPointF(nx, ny));\n    return text;\n}\n\nstatic QSvgNode *createTextAreaNode(QSvgNode *parent,\n                                    const QXmlStreamAttributes &attributes,\n                                    QSvgHandler *handler)\n{\n    QSvgText *node = static_cast<QSvgText *>(createTextNode(parent, attributes, handler));\n    if (node) {\n        QSvgHandler::LengthType type;\n        qreal width = parseLength(attributes.value(QLatin1String(\"width\")), type, handler);\n        qreal height = parseLength(attributes.value(QLatin1String(\"height\")), type, handler);\n        node->setTextArea(QSizeF(width, height));\n    }\n    return node;\n}\n\nstatic QSvgNode *createTspanNode(QSvgNode *parent,\n                                    const QXmlStreamAttributes &,\n                                    QSvgHandler *)\n{\n    return new QSvgTspan(parent);\n}\n\nstatic bool parseTitleNode(QSvgNode *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createUseNode(QSvgNode *parent,\n                               const QXmlStreamAttributes &attributes,\n                               QSvgHandler *handler)\n{\n    QString linkId = attributes.value(QLatin1String(\"xlink:href\")).toString().remove(0, 1);\n    const QStringView xStr = attributes.value(QLatin1String(\"x\"));\n    const QStringView yStr = attributes.value(QLatin1String(\"y\"));\n    QSvgStructureNode *group = nullptr;\n\n    if (linkId.isEmpty())\n        linkId = attributes.value(QLatin1String(\"href\")).toString().remove(0, 1);\n    switch (parent->type()) {\n    case QSvgNode::DOC:\n    case QSvgNode::DEFS:\n    case QSvgNode::G:\n    case QSvgNode::SWITCH:\n        group = static_cast<QSvgStructureNode*>(parent);\n        break;\n    default:\n        break;\n    }\n\n    if (group) {\n        QPointF pt;\n        if (!xStr.isNull() || !yStr.isNull()) {\n            QSvgHandler::LengthType type;\n            qreal nx = parseLength(xStr.toString(), type, handler);\n            nx = convertToPixels(nx, true, type);\n\n            qreal ny = parseLength(yStr.toString(), type, handler);\n            ny = convertToPixels(ny, true, type);\n            pt = QPointF(nx, ny);\n        }\n\n        QSvgNode *link = group->scopeNode(linkId);\n        if (link) {\n            if (parent->isDescendantOf(link))\n                qCWarning(lcSvgHandler, \"link #%s is recursive!\", qPrintable(linkId));\n\n            return new QSvgUse(pt, parent, link);\n        }\n\n        //delay link resolving, link might have not been created yet\n        return new QSvgUse(pt, parent, linkId);\n    }\n\n    qCWarning(lcSvgHandler, \"<use> element %s in wrong context!\", qPrintable(linkId));\n    return 0;\n}\n\nstatic QSvgNode *createVideoNode(QSvgNode *parent,\n                                 const QXmlStreamAttributes &attributes,\n                                 QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return 0;\n}\n\ntypedef QSvgNode *(*FactoryMethod)(QSvgNode *, const QXmlStreamAttributes &, QSvgHandler *);\n\nstatic FactoryMethod findGroupFactory(const QString &name)\n{\n    if (name.isEmpty())\n        return 0;\n\n    QStringView ref = QStringView{name}.mid(1, name.length() - 1);\n    switch (name.at(0).unicode()) {\n    case 'd':\n        if (ref == QLatin1String(\"efs\")) return createDefsNode;\n        break;\n    case 'g':\n        if (ref.isEmpty()) return createGNode;\n        break;\n    case 's':\n        if (ref == QLatin1String(\"vg\")) return createSvgNode;\n        if (ref == QLatin1String(\"witch\")) return createSwitchNode;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\nstatic FactoryMethod findGraphicsFactory(const QString &name)\n{\n    if (name.isEmpty())\n        return 0;\n\n    QStringView ref = QStringView{name}.mid(1, name.length() - 1);\n    switch (name.at(0).unicode()) {\n    case 'a':\n        if (ref == QLatin1String(\"nimation\")) return createAnimationNode;\n        break;\n    case 'c':\n        if (ref == QLatin1String(\"ircle\")) return createCircleNode;\n        break;\n    case 'e':\n        if (ref == QLatin1String(\"llipse\")) return createEllipseNode;\n        break;\n    case 'i':\n        if (ref == QLatin1String(\"mage\")) return createImageNode;\n        break;\n    case 'l':\n        if (ref == QLatin1String(\"ine\")) return createLineNode;\n        break;\n    case 'p':\n        if (ref == QLatin1String(\"ath\")) return createPathNode;\n        if (ref == QLatin1String(\"olygon\")) return createPolygonNode;\n        if (ref == QLatin1String(\"olyline\")) return createPolylineNode;\n        break;\n    case 'r':\n        if (ref == QLatin1String(\"ect\")) return createRectNode;\n        break;\n    case 't':\n        if (ref == QLatin1String(\"ext\")) return createTextNode;\n        if (ref == QLatin1String(\"extArea\")) return createTextAreaNode;\n        if (ref == QLatin1String(\"span\")) return createTspanNode;\n        break;\n    case 'u':\n        if (ref == QLatin1String(\"se\")) return createUseNode;\n        break;\n    case 'v':\n        if (ref == QLatin1String(\"ideo\")) return createVideoNode;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\ntypedef bool (*ParseMethod)(QSvgNode *, const QXmlStreamAttributes &, QSvgHandler *);\n\nstatic ParseMethod findUtilFactory(const QString &name)\n{\n    if (name.isEmpty())\n        return 0;\n\n    QStringView ref = QStringView{name}.mid(1, name.length() - 1);\n    switch (name.at(0).unicode()) {\n    case 'a':\n        if (ref.isEmpty()) return parseAnchorNode;\n        if (ref == QLatin1String(\"nimate\")) return parseAnimateNode;\n        if (ref == QLatin1String(\"nimateColor\")) return parseAnimateColorNode;\n        if (ref == QLatin1String(\"nimateMotion\")) return parseAimateMotionNode;\n        if (ref == QLatin1String(\"nimateTransform\")) return parseAnimateTransformNode;\n        if (ref == QLatin1String(\"udio\")) return parseAudioNode;\n        break;\n    case 'd':\n        if (ref == QLatin1String(\"esc\")) return parseDescNode;\n        if (ref == QLatin1String(\"iscard\")) return parseDiscardNode;\n        break;\n    case 'f':\n        if (ref == QLatin1String(\"oreignObject\")) return parseForeignObjectNode;\n        break;\n    case 'h':\n        if (ref == QLatin1String(\"andler\")) return parseHandlerNode;\n        if (ref == QLatin1String(\"kern\")) return parseHkernNode;\n        break;\n    case 'm':\n        if (ref == QLatin1String(\"etadata\")) return parseMetadataNode;\n        if (ref == QLatin1String(\"path\")) return parseMpathNode;\n        break;\n    case 'p':\n        if (ref == QLatin1String(\"refetch\")) return parsePrefetchNode;\n        break;\n    case 's':\n        if (ref == QLatin1String(\"cript\")) return parseScriptNode;\n        if (ref == QLatin1String(\"et\")) return parseSetNode;\n        if (ref == QLatin1String(\"tyle\")) return parseStyleNode;\n        break;\n    case 't':\n        if (ref == QLatin1String(\"break\")) return parseTbreakNode;\n        if (ref == QLatin1String(\"itle\")) return parseTitleNode;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\ntypedef QSvgStyleProperty *(*StyleFactoryMethod)(QSvgNode *,\n                                                 const QXmlStreamAttributes &,\n                                                 QSvgHandler *);\n\nstatic StyleFactoryMethod findStyleFactoryMethod(const QString &name)\n{\n    if (name.isEmpty())\n        return 0;\n\n    QStringView ref = QStringView{name}.mid(1, name.length() - 1);\n    switch (name.at(0).unicode()) {\n    case 'f':\n        if (ref == QLatin1String(\"ont\")) return createFontNode;\n        break;\n    case 'l':\n        if (ref == QLatin1String(\"inearGradient\")) return createLinearGradientNode;\n        break;\n    case 'r':\n        if (ref == QLatin1String(\"adialGradient\")) return createRadialGradientNode;\n        break;\n    case 's':\n        if (ref == QLatin1String(\"olidColor\")) return createSolidColorNode;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\ntypedef bool (*StyleParseMethod)(QSvgStyleProperty *,\n                                 const QXmlStreamAttributes &,\n                                 QSvgHandler *);\n\nstatic StyleParseMethod findStyleUtilFactoryMethod(const QString &name)\n{\n    if (name.isEmpty())\n        return 0;\n\n    QStringView ref = QStringView{name}.mid(1, name.length() - 1);\n    switch (name.at(0).unicode()) {\n    case 'f':\n        if (ref == QLatin1String(\"ont-face\")) return parseFontFaceNode;\n        if (ref == QLatin1String(\"ont-face-name\")) return parseFontFaceNameNode;\n        if (ref == QLatin1String(\"ont-face-src\")) return parseFontFaceSrcNode;\n        if (ref == QLatin1String(\"ont-face-uri\")) return parseFontFaceUriNode;\n        break;\n    case 'g':\n        if (ref == QLatin1String(\"lyph\")) return parseGlyphNode;\n        break;\n    case 'm':\n        if (ref == QLatin1String(\"issing-glyph\")) return parseMissingGlyphNode;\n        break;\n    case 's':\n        if (ref == QLatin1String(\"top\")) return parseStopNode;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\nQSvgHandler::QSvgHandler(QIODevice *device) : xml(new QXmlStreamReader(device))\n                                             , m_ownsReader(true)\n{\n    init();\n}\n\nQSvgHandler::QSvgHandler(const QByteArray &data) : xml(new QXmlStreamReader(data))\n                                                 , m_ownsReader(true)\n{\n    init();\n}\n\nQSvgHandler::QSvgHandler(QXmlStreamReader *const reader) : xml(reader)\n                                                         , m_ownsReader(false)\n{\n    init();\n}\n\nvoid QSvgHandler::init()\n{\n    m_doc = 0;\n    m_style = 0;\n    m_animEnd = 0;\n    m_defaultCoords = LT_PX;\n    m_defaultPen = QPen(Qt::black, 1, Qt::SolidLine, Qt::FlatCap, Qt::SvgMiterJoin);\n    m_defaultPen.setMiterLimit(4);\n    parse();\n}\n\n// Having too many unfinished elements will cause a stack overflow\n// in the dtor of QSvgTinyDocument, see oss-fuzz issue 24000.\nstatic const int unfinishedElementsLimit = 2048;\n\nvoid QSvgHandler::parse()\n{\n    xml->setNamespaceProcessing(false);\n#ifndef QT_NO_CSSPARSER\n    m_selector = new QSvgStyleSelector;\n    m_inStyle = false;\n#endif\n    bool done = false;\n    int remainingUnfinishedElements = unfinishedElementsLimit;\n    while (!xml->atEnd() && !done) {\n        switch (xml->readNext()) {\n        case QXmlStreamReader::StartElement:\n            // he we could/should verify the namespaces, and simply\n            // call m_skipNodes(Unknown) if we don't know the\n            // namespace.  We do support http://www.w3.org/2000/svg\n            // but also http://www.w3.org/2000/svg-20000303-stylable\n            // And if the document uses an external dtd, the reported\n            // namespaceUri is empty. The only possible strategy at\n            // this point is to do what everyone else seems to do and\n            // ignore the reported namespaceUri completely.\n            if (remainingUnfinishedElements\n                    && startElement(xml->name().toString(), xml->attributes())) {\n                --remainingUnfinishedElements;\n            } else {\n                delete m_doc;\n                m_doc = 0;\n                return;\n            }\n            break;\n        case QXmlStreamReader::EndElement:\n            endElement(xml->name());\n            ++remainingUnfinishedElements;\n            // if we are using somebody else's qxmlstreamreader\n            // we should not read until the end of the stream\n            done = !m_ownsReader && (xml->name() == QLatin1String(\"svg\"));\n            break;\n        case QXmlStreamReader::Characters:\n            characters(xml->text());\n            break;\n        case QXmlStreamReader::ProcessingInstruction:\n            processingInstruction(xml->processingInstructionTarget().toString(), xml->processingInstructionData().toString());\n            break;\n        default:\n            break;\n        }\n    }\n    resolveGradients(m_doc);\n    resolveNodes();\n}\n\nbool QSvgHandler::startElement(const QString &localName,\n                               const QXmlStreamAttributes &attributes)\n{\n    QSvgNode *node = nullptr;\n\n    pushColorCopy();\n\n    /* The xml:space attribute may appear on any element. We do\n     * a lookup by the qualified name here, but this is namespace aware, since\n     * the XML namespace can only be bound to prefix \"xml.\" */\n    const QStringView xmlSpace(attributes.value(QLatin1String(\"xml:space\")));\n    if (xmlSpace.isNull()) {\n        // This element has no xml:space attribute.\n        m_whitespaceMode.push(m_whitespaceMode.isEmpty() ? QSvgText::Default : m_whitespaceMode.top());\n    } else if (xmlSpace == QLatin1String(\"preserve\")) {\n        m_whitespaceMode.push(QSvgText::Preserve);\n    } else if (xmlSpace == QLatin1String(\"default\")) {\n        m_whitespaceMode.push(QSvgText::Default);\n    } else {\n        const QByteArray msg = '\"' + xmlSpace.toString().toLocal8Bit()\n                               + \"\\\" is an invalid value for attribute xml:space. \"\n                                 \"Valid values are \\\"preserve\\\" and \\\"default\\\".\";\n        qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n        m_whitespaceMode.push(QSvgText::Default);\n    }\n\n    if (!m_doc && localName != QLatin1String(\"svg\"))\n        return false;\n\n    if (FactoryMethod method = findGroupFactory(localName)) {\n        //group\n        node = method(m_doc ? m_nodes.top() : 0, attributes, this);\n        Q_ASSERT(node);\n        if (!m_doc) {\n            Q_ASSERT(node->type() == QSvgNode::DOC);\n            m_doc = static_cast<QSvgTinyDocument*>(node);\n        } else {\n            switch (m_nodes.top()->type()) {\n            case QSvgNode::DOC:\n            case QSvgNode::G:\n            case QSvgNode::DEFS:\n            case QSvgNode::SWITCH:\n            {\n                QSvgStructureNode *group =\n                    static_cast<QSvgStructureNode*>(m_nodes.top());\n                group->addChild(node, someId(attributes));\n            }\n                break;\n            default:\n                const QByteArray msg = QByteArrayLiteral(\"Could not add child element to parent element because the types are incorrect.\");\n                qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n                delete node;\n                node = 0;\n                break;\n            }\n        }\n        if (node) {\n            parseCoreNode(node, attributes);\n#ifndef QT_NO_CSSPARSER\n            cssStyleLookup(node, this, m_selector);\n#endif\n            parseStyle(node, attributes, this);\n        }\n    } else if (FactoryMethod method = findGraphicsFactory(localName)) {\n        //rendering element\n        Q_ASSERT(!m_nodes.isEmpty());\n        node = method(m_nodes.top(), attributes, this);\n        if (node) {\n            switch (m_nodes.top()->type()) {\n            case QSvgNode::DOC:\n            case QSvgNode::G:\n            case QSvgNode::DEFS:\n            case QSvgNode::SWITCH:\n            {\n                if (node->type() == QSvgNode::TSPAN) {\n                    const QByteArray msg = QByteArrayLiteral(\"\\'tspan\\' element in wrong context.\");\n                    qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n                    delete node;\n                    node = 0;\n                    break;\n                }\n                QSvgStructureNode *group =\n                    static_cast<QSvgStructureNode*>(m_nodes.top());\n                group->addChild(node, someId(attributes));\n            }\n                break;\n            case QSvgNode::TEXT:\n            case QSvgNode::TEXTAREA:\n                if (node->type() == QSvgNode::TSPAN) {\n                    static_cast<QSvgText *>(m_nodes.top())->addTspan(static_cast<QSvgTspan *>(node));\n                } else {\n                    const QByteArray msg = QByteArrayLiteral(\"\\'text\\' or \\'textArea\\' element contains invalid element type.\");\n                    qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n                    delete node;\n                    node = 0;\n                }\n                break;\n            default:\n                const QByteArray msg = QByteArrayLiteral(\"Could not add child element to parent element because the types are incorrect.\");\n                qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n                delete node;\n                node = 0;\n                break;\n            }\n\n            if (node) {\n                parseCoreNode(node, attributes);\n#ifndef QT_NO_CSSPARSER\n                cssStyleLookup(node, this, m_selector);\n#endif\n                parseStyle(node, attributes, this);\n                if (node->type() == QSvgNode::TEXT || node->type() == QSvgNode::TEXTAREA) {\n                    static_cast<QSvgText *>(node)->setWhitespaceMode(m_whitespaceMode.top());\n                } else if (node->type() == QSvgNode::TSPAN) {\n                    static_cast<QSvgTspan *>(node)->setWhitespaceMode(m_whitespaceMode.top());\n                } else if (node->type() == QSvgNode::USE) {\n                    if (!static_cast<QSvgUse *>(node)->isResolved())\n                        m_resolveNodes.append(node);\n                }\n            }\n        }\n    } else if (ParseMethod method = findUtilFactory(localName)) {\n        Q_ASSERT(!m_nodes.isEmpty());\n        if (!method(m_nodes.top(), attributes, this))\n            qCWarning(lcSvgHandler, \"%s\", msgProblemParsing(localName, xml).constData());\n    } else if (StyleFactoryMethod method = findStyleFactoryMethod(localName)) {\n        QSvgStyleProperty *prop = method(m_nodes.top(), attributes, this);\n        if (prop) {\n            m_style = prop;\n            m_nodes.top()->appendStyleProperty(prop, someId(attributes));\n        } else {\n            const QByteArray msg = QByteArrayLiteral(\"Could not parse node: \") + localName.toLocal8Bit();\n            qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n        }\n    } else if (StyleParseMethod method = findStyleUtilFactoryMethod(localName)) {\n        if (m_style) {\n            if (!method(m_style, attributes, this))\n                qCWarning(lcSvgHandler, \"%s\", msgProblemParsing(localName, xml).constData());\n        }\n    } else {\n        //qCWarning(lcSvgHandler) <<\"Skipping unknown element!\"<<namespaceURI<<\"::\"<<localName;\n        m_skipNodes.push(Unknown);\n        return true;\n    }\n\n    if (node) {\n        m_nodes.push(node);\n        m_skipNodes.push(Graphics);\n    } else {\n        //qDebug()<<\"Skipping \"<<localName;\n        m_skipNodes.push(Style);\n    }\n    return true;\n}\n\nbool QSvgHandler::endElement(const QStringView localName)\n{\n    CurrentNode node = m_skipNodes.top();\n    m_skipNodes.pop();\n    m_whitespaceMode.pop();\n\n    popColor();\n\n    if (node == Unknown) {\n        return true;\n    }\n\n#ifdef QT_NO_CSSPARSER\n    Q_UNUSED(localName);\n#else\n    if (m_inStyle && localName == QLatin1String(\"style\"))\n        m_inStyle = false;\n#endif\n\n    if (node == Graphics)\n        m_nodes.pop();\n    else if (m_style && !m_skipNodes.isEmpty() && m_skipNodes.top() != Style)\n        m_style = 0;\n\n    return true;\n}\n\nvoid QSvgHandler::resolveGradients(QSvgNode *node, int nestedDepth)\n{\n    if (!node || (node->type() != QSvgNode::DOC && node->type() != QSvgNode::G\n        && node->type() != QSvgNode::DEFS && node->type() != QSvgNode::SWITCH)) {\n        return;\n    }\n\n    QSvgStructureNode *structureNode = static_cast<QSvgStructureNode *>(node);\n\n    const QList<QSvgNode *> ren = structureNode->renderers();\n    for (auto it = ren.begin(); it != ren.end(); ++it) {\n        QSvgFillStyle *fill = static_cast<QSvgFillStyle *>((*it)->styleProperty(QSvgStyleProperty::FILL));\n        if (fill && !fill->isGradientResolved()) {\n            QString id = fill->gradientId();\n            QSvgFillStyleProperty *style = structureNode->styleProperty(id);\n            if (style) {\n                fill->setFillStyle(style);\n            } else {\n                qCWarning(lcSvgHandler, \"%s\", msgCouldNotResolveProperty(id, xml).constData());\n                fill->setBrush(Qt::NoBrush);\n            }\n        }\n\n        QSvgStrokeStyle *stroke = static_cast<QSvgStrokeStyle *>((*it)->styleProperty(QSvgStyleProperty::STROKE));\n        if (stroke && !stroke->isGradientResolved()) {\n            QString id = stroke->gradientId();\n            QSvgFillStyleProperty *style = structureNode->styleProperty(id);\n            if (style) {\n                stroke->setStyle(style);\n            } else {\n                qCWarning(lcSvgHandler, \"%s\", msgCouldNotResolveProperty(id, xml).constData());\n                stroke->setStroke(Qt::NoBrush);\n            }\n        }\n\n        if (nestedDepth < 2048)\n            resolveGradients(*it, nestedDepth + 1);\n    }\n}\n\nvoid QSvgHandler::resolveNodes()\n{\n    for (QSvgNode *node : qAsConst(m_resolveNodes)) {\n        if (!node || !node->parent() || node->type() != QSvgNode::USE)\n            continue;\n        QSvgUse *useNode = static_cast<QSvgUse *>(node);\n        if (useNode->isResolved())\n            continue;\n        QSvgNode::Type t = useNode->parent()->type();\n        if (!(t == QSvgNode::DOC || t == QSvgNode::DEFS || t == QSvgNode::G || t == QSvgNode::SWITCH))\n            continue;\n\n        QSvgStructureNode *group = static_cast<QSvgStructureNode *>(useNode->parent());\n        QSvgNode *link = group->scopeNode(useNode->linkId());\n        if (!link) {\n            qCWarning(lcSvgHandler, \"link #%s is undefined!\", qPrintable(useNode->linkId()));\n            continue;\n        }\n\n        if (useNode->parent()->isDescendantOf(link))\n            qCWarning(lcSvgHandler, \"link #%s is recursive!\", qPrintable(useNode->linkId()));\n\n        useNode->setLink(link);\n    }\n    m_resolveNodes.clear();\n}\n\nbool QSvgHandler::characters(const QStringView str)\n{\n#ifndef QT_NO_CSSPARSER\n    if (m_inStyle) {\n        QString css = str.toString();\n        QCss::StyleSheet sheet;\n        QCss::Parser(css).parse(&sheet);\n        m_selector->styleSheets.append(sheet);\n        return true;\n    }\n#endif\n    if (m_skipNodes.isEmpty() || m_skipNodes.top() == Unknown || m_nodes.isEmpty())\n        return true;\n\n    if (m_nodes.top()->type() == QSvgNode::TEXT || m_nodes.top()->type() == QSvgNode::TEXTAREA) {\n        static_cast<QSvgText*>(m_nodes.top())->addText(str.toString());\n    } else if (m_nodes.top()->type() == QSvgNode::TSPAN) {\n        static_cast<QSvgTspan*>(m_nodes.top())->addText(str.toString());\n    }\n\n    return true;\n}\n\nQIODevice *QSvgHandler::device() const\n{\n    return xml->device();\n}\n\nQSvgTinyDocument * QSvgHandler::document() const\n{\n    return m_doc;\n}\n\nQSvgHandler::LengthType QSvgHandler::defaultCoordinateSystem() const\n{\n    return m_defaultCoords;\n}\n\nvoid QSvgHandler::setDefaultCoordinateSystem(LengthType type)\n{\n    m_defaultCoords = type;\n}\n\nvoid QSvgHandler::pushColor(const QColor &color)\n{\n    m_colorStack.push(color);\n    m_colorTagCount.push(1);\n}\n\nvoid QSvgHandler::pushColorCopy()\n{\n    if (m_colorTagCount.count())\n        ++m_colorTagCount.top();\n    else\n        pushColor(Qt::black);\n}\n\nvoid QSvgHandler::popColor()\n{\n    if (m_colorTagCount.count()) {\n        if (!--m_colorTagCount.top()) {\n            m_colorStack.pop();\n            m_colorTagCount.pop();\n        }\n    }\n}\n\nQColor QSvgHandler::currentColor() const\n{\n    if (!m_colorStack.isEmpty())\n        return m_colorStack.top();\n    else\n        return QColor(0, 0, 0);\n}\n\n#ifndef QT_NO_CSSPARSER\n\nvoid QSvgHandler::setInStyle(bool b)\n{\n    m_inStyle = b;\n}\n\nbool QSvgHandler::inStyle() const\n{\n    return m_inStyle;\n}\n\nQSvgStyleSelector * QSvgHandler::selector() const\n{\n    return m_selector;\n}\n\n#endif // QT_NO_CSSPARSER\n\nbool QSvgHandler::processingInstruction(const QString &target, const QString &data)\n{\n#ifdef QT_NO_CSSPARSER\n    Q_UNUSED(target);\n    Q_UNUSED(data);\n#else\n    if (target == QLatin1String(\"xml-stylesheet\")) {\n        QRegularExpression rx(QLatin1String(\"type=\\\\\\\"(.+)\\\\\\\"\"),\n                              QRegularExpression::InvertedGreedinessOption);\n        QRegularExpressionMatchIterator iter = rx.globalMatch(data);\n        bool isCss = false;\n        while (iter.hasNext()) {\n            QRegularExpressionMatch match = iter.next();\n            QString type = match.captured(1);\n            if (type.toLower() == QLatin1String(\"text/css\")) {\n                isCss = true;\n            }\n        }\n\n        if (isCss) {\n            QRegularExpression rx(QLatin1String(\"href=\\\\\\\"(.+)\\\\\\\"\"),\n                                  QRegularExpression::InvertedGreedinessOption);\n            QRegularExpressionMatch match = rx.match(data);\n            QString addr = match.captured(1);\n            QFileInfo fi(addr);\n            //qDebug()<<\"External CSS file \"<<fi.absoluteFilePath()<<fi.exists();\n            if (fi.exists()) {\n                QFile file(fi.absoluteFilePath());\n                if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n                    return true;\n                }\n                QByteArray cssData = file.readAll();\n                QString css = QString::fromUtf8(cssData);\n\n                QCss::StyleSheet sheet;\n                QCss::Parser(css).parse(&sheet);\n                m_selector->styleSheets.append(sheet);\n            }\n\n        }\n    }\n#endif\n\n    return true;\n}\n\nvoid QSvgHandler::setAnimPeriod(int start, int end)\n{\n    Q_UNUSED(start);\n    m_animEnd   = qMax(end, m_animEnd);\n}\n\nint QSvgHandler::animationDuration() const\n{\n    return m_animEnd;\n}\n\nQSvgHandler::~QSvgHandler()\n{\n#ifndef QT_NO_CSSPARSER\n    delete m_selector;\n    m_selector = 0;\n#endif\n\n    if(m_ownsReader)\n        delete xml;\n}\n\nQT_END_NAMESPACE\n"], "fixing_code": ["/****************************************************************************\n**\n** Copyright (C) 2021 The Qt Company Ltd.\n** Contact: https://www.qt.io/licensing/\n**\n** This file is part of the Qt SVG module of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and The Qt Company. For licensing terms\n** and conditions see https://www.qt.io/terms-conditions. For further\n** information use the contact form at https://www.qt.io/contact-us.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 3 as published by the Free Software\n** Foundation and appearing in the file LICENSE.LGPL3 included in the\n** packaging of this file. Please review the following information to\n** ensure the GNU Lesser General Public License version 3 requirements\n** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.\n**\n** GNU General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU\n** General Public License version 2.0 or (at your option) the GNU General\n** Public license version 3 or any later version approved by the KDE Free\n** Qt Foundation. The licenses are as published by the Free Software\n** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3\n** included in the packaging of this file. Please review the following\n** information to ensure the GNU General Public License requirements will\n** be met: https://www.gnu.org/licenses/gpl-2.0.html and\n** https://www.gnu.org/licenses/gpl-3.0.html.\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#include \"qplatformdefs.h\"\n\n#include \"qsvghandler_p.h\"\n\n#include \"qsvgtinydocument_p.h\"\n#include \"qsvgstructure_p.h\"\n#include \"qsvggraphics_p.h\"\n#include \"qsvgnode_p.h\"\n#include \"qsvgfont_p.h\"\n\n#include \"qpen.h\"\n#include \"qpainterpath.h\"\n#include \"qbrush.h\"\n#include \"qcolor.h\"\n#include \"qtextformat.h\"\n#include \"qlist.h\"\n#include \"qfileinfo.h\"\n#include \"qfile.h\"\n#include \"qdir.h\"\n#include \"qdebug.h\"\n#include \"qmath.h\"\n#include \"qnumeric.h\"\n#include <qregularexpression.h>\n#include \"qtransform.h\"\n#include \"qvarlengtharray.h\"\n#include \"private/qmath_p.h\"\n\n#include \"float.h\"\n#include <cmath>\n\nQT_BEGIN_NAMESPACE\n\nQ_LOGGING_CATEGORY(lcSvgHandler, \"qt.svg\")\n\nstatic const char *qt_inherit_text = \"inherit\";\n#define QT_INHERIT QLatin1String(qt_inherit_text)\n\nstatic QByteArray prefixMessage(const QByteArray &msg, const QXmlStreamReader *r)\n{\n    QByteArray result;\n    if (r) {\n        if (const QFile *file = qobject_cast<const QFile *>(r->device()))\n            result.append(QFile::encodeName(QDir::toNativeSeparators(file->fileName())));\n        else\n            result.append(QByteArrayLiteral(\"<input>\"));\n        result.append(':');\n        result.append(QByteArray::number(r->lineNumber()));\n        if (const qint64 column = r->columnNumber()) {\n            result.append(':');\n            result.append(QByteArray::number(column));\n        }\n        result.append(QByteArrayLiteral(\": \"));\n    }\n    result.append(msg);\n    return result;\n}\n\nstatic inline QByteArray msgProblemParsing(const QString &localName, const QXmlStreamReader *r)\n{\n    return prefixMessage(QByteArrayLiteral(\"Problem parsing \") + localName.toLocal8Bit(), r);\n}\n\nstatic inline QByteArray msgCouldNotResolveProperty(const QString &id, const QXmlStreamReader *r)\n{\n    return prefixMessage(QByteArrayLiteral(\"Could not resolve property: \") + id.toLocal8Bit(), r);\n}\n\n// ======== duplicated from qcolor_p\n\nstatic inline int qsvg_h2i(char hex, bool *ok = nullptr)\n{\n    if (hex >= '0' && hex <= '9')\n        return hex - '0';\n    if (hex >= 'a' && hex <= 'f')\n        return hex - 'a' + 10;\n    if (hex >= 'A' && hex <= 'F')\n        return hex - 'A' + 10;\n    if (ok)\n        *ok = false;\n    return -1;\n}\n\nstatic inline int qsvg_hex2int(const char *s, bool *ok = nullptr)\n{\n    return (qsvg_h2i(s[0], ok) * 16) | qsvg_h2i(s[1], ok);\n}\n\nstatic inline int qsvg_hex2int(char s, bool *ok = nullptr)\n{\n    int h = qsvg_h2i(s, ok);\n    return (h * 16) | h;\n}\n\nbool qsvg_get_hex_rgb(const char *name, QRgb *rgb)\n{\n    if(name[0] != '#')\n        return false;\n    name++;\n    const size_t len = qstrlen(name);\n    int r, g, b;\n    bool ok = true;\n    if (len == 12) {\n        r = qsvg_hex2int(name, &ok);\n        g = qsvg_hex2int(name + 4, &ok);\n        b = qsvg_hex2int(name + 8, &ok);\n    } else if (len == 9) {\n        r = qsvg_hex2int(name, &ok);\n        g = qsvg_hex2int(name + 3, &ok);\n        b = qsvg_hex2int(name + 6, &ok);\n    } else if (len == 6) {\n        r = qsvg_hex2int(name, &ok);\n        g = qsvg_hex2int(name + 2, &ok);\n        b = qsvg_hex2int(name + 4, &ok);\n    } else if (len == 3) {\n        r = qsvg_hex2int(name[0], &ok);\n        g = qsvg_hex2int(name[1], &ok);\n        b = qsvg_hex2int(name[2], &ok);\n    } else {\n        r = g = b = -1;\n    }\n    if ((uint)r > 255 || (uint)g > 255 || (uint)b > 255 || !ok) {\n        *rgb = 0;\n        return false;\n    }\n    *rgb = qRgb(r, g ,b);\n    return true;\n}\n\nbool qsvg_get_hex_rgb(const QChar *str, int len, QRgb *rgb)\n{\n    if (len > 13)\n        return false;\n    char tmp[16];\n    for(int i = 0; i < len; ++i)\n        tmp[i] = str[i].toLatin1();\n    tmp[len] = 0;\n    return qsvg_get_hex_rgb(tmp, rgb);\n}\n\n// ======== end of qcolor_p duplicate\n\nstatic bool parsePathDataFast(QStringView data, QPainterPath &path);\n\nstatic inline QString someId(const QXmlStreamAttributes &attributes)\n{\n    QString id = attributes.value(QLatin1String(\"id\")).toString();\n    if (id.isEmpty())\n        id = attributes.value(QLatin1String(\"xml:id\")).toString();\n    return id;\n}\n\nstruct QSvgAttributes\n{\n    QSvgAttributes(const QXmlStreamAttributes &xmlAttributes, QSvgHandler *handler);\n\n    QString id;\n\n    QStringView color;\n    QStringView colorOpacity;\n    QStringView fill;\n    QStringView fillRule;\n    QStringView fillOpacity;\n    QStringView stroke;\n    QStringView strokeDashArray;\n    QStringView strokeDashOffset;\n    QStringView strokeLineCap;\n    QStringView strokeLineJoin;\n    QStringView strokeMiterLimit;\n    QStringView strokeOpacity;\n    QStringView strokeWidth;\n    QStringView vectorEffect;\n    QStringView fontFamily;\n    QStringView fontSize;\n    QStringView fontStyle;\n    QStringView fontWeight;\n    QStringView fontVariant;\n    QStringView textAnchor;\n    QStringView transform;\n    QStringView visibility;\n    QStringView opacity;\n    QStringView compOp;\n    QStringView display;\n    QStringView offset;\n    QStringView stopColor;\n    QStringView stopOpacity;\n    QStringView imageRendering;\n\n#ifndef QT_NO_CSSPARSER\n    QList<QSvgCssAttribute> m_cssAttributes;\n#endif\n};\n\nQSvgAttributes::QSvgAttributes(const QXmlStreamAttributes &xmlAttributes, QSvgHandler *handler)\n{\n#ifndef QT_NO_CSSPARSER\n    QStringView style = xmlAttributes.value(QLatin1String(\"style\"));\n    if (!style.isEmpty()) {\n        handler->parseCSStoXMLAttrs(style.toString(), &m_cssAttributes);\n        for (int j = 0; j < m_cssAttributes.count(); ++j) {\n            const QSvgCssAttribute &attribute = m_cssAttributes.at(j);\n            QStringView name = attribute.name;\n            QStringView value = attribute.value;\n            if (name.isEmpty())\n                continue;\n\n            switch (name.at(0).unicode()) {\n\n            case 'c':\n                if (name == QLatin1String(\"color\"))\n                    color = value;\n                else if (name == QLatin1String(\"color-opacity\"))\n                    colorOpacity = value;\n                else if (name == QLatin1String(\"comp-op\"))\n                    compOp = value;\n                break;\n\n            case 'd':\n                if (name == QLatin1String(\"display\"))\n                    display = value;\n                break;\n\n            case 'f':\n                if (name == QLatin1String(\"fill\"))\n                    fill = value;\n                else if (name == QLatin1String(\"fill-rule\"))\n                    fillRule = value;\n                else if (name == QLatin1String(\"fill-opacity\"))\n                    fillOpacity = value;\n                else if (name == QLatin1String(\"font-family\"))\n                    fontFamily = value;\n                else if (name == QLatin1String(\"font-size\"))\n                    fontSize = value;\n                else if (name == QLatin1String(\"font-style\"))\n                    fontStyle = value;\n                else if (name == QLatin1String(\"font-weight\"))\n                    fontWeight = value;\n                else if (name == QLatin1String(\"font-variant\"))\n                    fontVariant = value;\n                break;\n            case 'i':\n                if (name == QLatin1String(\"image-rendering\"))\n                    imageRendering = value;\n                break;\n\n            case 'o':\n                if (name == QLatin1String(\"opacity\"))\n                    opacity = value;\n                else if (name == QLatin1String(\"offset\"))\n                    offset = value;\n                break;\n\n            case 's':\n                if (name.length() > 5 && name.mid(1, 5) == QLatin1String(\"troke\")) {\n                    QStringView strokeRef = name.mid(6, name.length() - 6);\n                    if (strokeRef.isEmpty())\n                        stroke = value;\n                    else if (strokeRef == QLatin1String(\"-dasharray\"))\n                        strokeDashArray = value;\n                    else if (strokeRef == QLatin1String(\"-dashoffset\"))\n                        strokeDashOffset = value;\n                    else if (strokeRef == QLatin1String(\"-linecap\"))\n                        strokeLineCap = value;\n                    else if (strokeRef == QLatin1String(\"-linejoin\"))\n                        strokeLineJoin = value;\n                    else if (strokeRef == QLatin1String(\"-miterlimit\"))\n                        strokeMiterLimit = value;\n                    else if (strokeRef == QLatin1String(\"-opacity\"))\n                        strokeOpacity = value;\n                    else if (strokeRef == QLatin1String(\"-width\"))\n                        strokeWidth = value;\n                }\n                else if (name == QLatin1String(\"stop-color\"))\n                    stopColor = value;\n                else if (name == QLatin1String(\"stop-opacity\"))\n                    stopOpacity = value;\n                break;\n\n            case 't':\n                if (name == QLatin1String(\"text-anchor\"))\n                    textAnchor = value;\n                else if (name == QLatin1String(\"transform\"))\n                    transform = value;\n                break;\n\n            case 'v':\n                if (name == QLatin1String(\"vector-effect\"))\n                    vectorEffect = value;\n                else if (name == QLatin1String(\"visibility\"))\n                    visibility = value;\n                break;\n\n            default:\n                break;\n           }\n        }\n    }\n#else\n    Q_UNUSED(handler);\n#endif // QT_NO_CSSPARSER\n\n    for (int i = 0; i < xmlAttributes.count(); ++i) {\n        const QXmlStreamAttribute &attribute = xmlAttributes.at(i);\n        QStringView name = attribute.qualifiedName();\n        if (name.isEmpty())\n            continue;\n        QStringView value = attribute.value();\n\n        switch (name.at(0).unicode()) {\n\n        case 'c':\n            if (name == QLatin1String(\"color\"))\n                color = value;\n            else if (name == QLatin1String(\"color-opacity\"))\n                colorOpacity = value;\n            else if (name == QLatin1String(\"comp-op\"))\n                compOp = value;\n            break;\n\n        case 'd':\n            if (name == QLatin1String(\"display\"))\n                display = value;\n            break;\n\n        case 'f':\n            if (name == QLatin1String(\"fill\"))\n                fill = value;\n            else if (name == QLatin1String(\"fill-rule\"))\n                fillRule = value;\n            else if (name == QLatin1String(\"fill-opacity\"))\n                fillOpacity = value;\n            else if (name == QLatin1String(\"font-family\"))\n                fontFamily = value;\n            else if (name == QLatin1String(\"font-size\"))\n                fontSize = value;\n            else if (name == QLatin1String(\"font-style\"))\n                fontStyle = value;\n            else if (name == QLatin1String(\"font-weight\"))\n                fontWeight = value;\n            else if (name == QLatin1String(\"font-variant\"))\n                fontVariant = value;\n            break;\n\n        case 'i':\n            if (name == QLatin1String(\"id\"))\n                id = value.toString();\n            else if (name == QLatin1String(\"image-rendering\"))\n                imageRendering = value;\n            break;\n\n        case 'o':\n            if (name == QLatin1String(\"opacity\"))\n                opacity = value;\n            if (name == QLatin1String(\"offset\"))\n                offset = value;\n            break;\n\n        case 's':\n            if (name.length() > 5 && name.mid(1, 5) == QLatin1String(\"troke\")) {\n                QStringView strokeRef = name.mid(6, name.length() - 6);\n                if (strokeRef.isEmpty())\n                    stroke = value;\n                else if (strokeRef == QLatin1String(\"-dasharray\"))\n                    strokeDashArray = value;\n                else if (strokeRef == QLatin1String(\"-dashoffset\"))\n                    strokeDashOffset = value;\n                else if (strokeRef == QLatin1String(\"-linecap\"))\n                    strokeLineCap = value;\n                else if (strokeRef == QLatin1String(\"-linejoin\"))\n                    strokeLineJoin = value;\n                else if (strokeRef == QLatin1String(\"-miterlimit\"))\n                    strokeMiterLimit = value;\n                else if (strokeRef == QLatin1String(\"-opacity\"))\n                    strokeOpacity = value;\n                else if (strokeRef == QLatin1String(\"-width\"))\n                    strokeWidth = value;\n            }\n            else if (name == QLatin1String(\"stop-color\"))\n                stopColor = value;\n            else if (name == QLatin1String(\"stop-opacity\"))\n                stopOpacity = value;\n            break;\n\n        case 't':\n            if (name == QLatin1String(\"text-anchor\"))\n                textAnchor = value;\n            else if (name == QLatin1String(\"transform\"))\n                transform = value;\n            break;\n\n        case 'v':\n            if (name == QLatin1String(\"vector-effect\"))\n                vectorEffect = value;\n            else if (name == QLatin1String(\"visibility\"))\n                visibility = value;\n            break;\n\n        case 'x':\n            if (name == QLatin1String(\"xml:id\") && id.isEmpty())\n                id = value.toString();\n            break;\n\n        default:\n            break;\n        }\n    }\n\n}\n\n#ifndef QT_NO_CSSPARSER\n\nstatic const char * QSvgStyleSelector_nodeString[] = {\n    \"svg\",\n    \"g\",\n    \"defs\",\n    \"switch\",\n    \"animation\",\n    \"arc\",\n    \"circle\",\n    \"ellipse\",\n    \"image\",\n    \"line\",\n    \"path\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"text\",\n    \"textarea\",\n    \"tspan\",\n    \"use\",\n    \"video\"\n};\n\nclass QSvgStyleSelector : public QCss::StyleSelector\n{\npublic:\n    QSvgStyleSelector()\n    {\n        nameCaseSensitivity = Qt::CaseInsensitive;\n    }\n    virtual ~QSvgStyleSelector()\n    {\n    }\n\n    inline QString nodeToName(QSvgNode *node) const\n    {\n        return QLatin1String(QSvgStyleSelector_nodeString[node->type()]);\n    }\n\n    inline QSvgNode *svgNode(NodePtr node) const\n    {\n        return (QSvgNode*)node.ptr;\n    }\n    inline QSvgStructureNode *nodeToStructure(QSvgNode *n) const\n    {\n        if (n &&\n            (n->type() == QSvgNode::DOC ||\n             n->type() == QSvgNode::G ||\n             n->type() == QSvgNode::DEFS ||\n             n->type() == QSvgNode::SWITCH)) {\n            return (QSvgStructureNode*)n;\n        }\n        return 0;\n    }\n\n    inline QSvgStructureNode *svgStructure(NodePtr node) const\n    {\n        QSvgNode *n = svgNode(node);\n        QSvgStructureNode *st = nodeToStructure(n);\n        return st;\n    }\n\n    bool nodeNameEquals(NodePtr node, const QString& nodeName) const override\n    {\n        QSvgNode *n = svgNode(node);\n        if (!n)\n            return false;\n        QString name = nodeToName(n);\n        return QString::compare(name, nodeName, Qt::CaseInsensitive) == 0;\n    }\n    QString attribute(NodePtr node, const QString &name) const override\n    {\n        QSvgNode *n = svgNode(node);\n        if ((!n->nodeId().isEmpty() && (name == QLatin1String(\"id\") ||\n                                        name == QLatin1String(\"xml:id\"))))\n            return n->nodeId();\n        if (!n->xmlClass().isEmpty() && name == QLatin1String(\"class\"))\n            return n->xmlClass();\n        return QString();\n    }\n    bool hasAttributes(NodePtr node) const override\n    {\n        QSvgNode *n = svgNode(node);\n        return (n &&\n                (!n->nodeId().isEmpty() || !n->xmlClass().isEmpty()));\n    }\n\n    QStringList nodeIds(NodePtr node) const override\n    {\n        QSvgNode *n = svgNode(node);\n        QString nid;\n        if (n)\n            nid = n->nodeId();\n        QStringList lst; lst.append(nid);\n        return lst;\n    }\n\n    QStringList nodeNames(NodePtr node) const override\n    {\n        QSvgNode *n = svgNode(node);\n        if (n)\n           return QStringList(nodeToName(n));\n        return QStringList();\n    }\n\n    bool isNullNode(NodePtr node) const override\n    {\n        return !node.ptr;\n    }\n\n    NodePtr parentNode(NodePtr node) const override\n    {\n        QSvgNode *n = svgNode(node);\n        NodePtr newNode;\n        newNode.ptr = 0;\n        newNode.id = 0;\n        if (n) {\n            QSvgNode *svgParent = n->parent();\n            if (svgParent) {\n                newNode.ptr = svgParent;\n            }\n        }\n        return newNode;\n    }\n    NodePtr previousSiblingNode(NodePtr node) const override\n    {\n        NodePtr newNode;\n        newNode.ptr = 0;\n        newNode.id = 0;\n\n        QSvgNode *n = svgNode(node);\n        if (!n)\n            return newNode;\n        QSvgStructureNode *svgParent = nodeToStructure(n->parent());\n\n        if (svgParent) {\n            newNode.ptr = svgParent->previousSiblingNode(n);\n        }\n        return newNode;\n    }\n    NodePtr duplicateNode(NodePtr node) const override\n    {\n        NodePtr n;\n        n.ptr = node.ptr;\n        n.id  = node.id;\n        return n;\n    }\n    void freeNode(NodePtr node) const override\n    {\n        Q_UNUSED(node);\n    }\n};\n\n#endif // QT_NO_CSSPARSER\n\n// '0' is 0x30 and '9' is 0x39\nstatic inline bool isDigit(ushort ch)\n{\n    static quint16 magic = 0x3ff;\n    return ((ch >> 4) == 3) && (magic >> (ch & 15));\n}\n\nstatic qreal toDouble(const QChar *&str)\n{\n    const int maxLen = 255;//technically doubles can go til 308+ but whatever\n    char temp[maxLen+1];\n    int pos = 0;\n\n    if (*str == QLatin1Char('-')) {\n        temp[pos++] = '-';\n        ++str;\n    } else if (*str == QLatin1Char('+')) {\n        ++str;\n    }\n    while (isDigit(str->unicode()) && pos < maxLen) {\n        temp[pos++] = str->toLatin1();\n        ++str;\n    }\n    if (*str == QLatin1Char('.') && pos < maxLen) {\n        temp[pos++] = '.';\n        ++str;\n    }\n    while (isDigit(str->unicode()) && pos < maxLen) {\n        temp[pos++] = str->toLatin1();\n        ++str;\n    }\n    bool exponent = false;\n    if ((*str == QLatin1Char('e') || *str == QLatin1Char('E')) && pos < maxLen) {\n        exponent = true;\n        temp[pos++] = 'e';\n        ++str;\n        if ((*str == QLatin1Char('-') || *str == QLatin1Char('+')) && pos < maxLen) {\n            temp[pos++] = str->toLatin1();\n            ++str;\n        }\n        while (isDigit(str->unicode()) && pos < maxLen) {\n            temp[pos++] = str->toLatin1();\n            ++str;\n        }\n    }\n\n    temp[pos] = '\\0';\n\n    qreal val;\n    if (!exponent && pos < 10) {\n        int ival = 0;\n        const char *t = temp;\n        bool neg = false;\n        if(*t == '-') {\n            neg = true;\n            ++t;\n        }\n        while(*t && *t != '.') {\n            ival *= 10;\n            ival += (*t) - '0';\n            ++t;\n        }\n        if(*t == '.') {\n            ++t;\n            int div = 1;\n            while(*t) {\n                ival *= 10;\n                ival += (*t) - '0';\n                div *= 10;\n                ++t;\n            }\n            val = ((qreal)ival)/((qreal)div);\n        } else {\n            val = ival;\n        }\n        if (neg)\n            val = -val;\n    } else {\n        val = QByteArray::fromRawData(temp, pos).toDouble();\n        // Do not tolerate values too wild to be represented normally by floats\n        if (qFpClassify(float(val)) != FP_NORMAL)\n            val = 0;\n    }\n    return val;\n\n}\n\nstatic qreal toDouble(QStringView str, bool *ok = NULL)\n{\n    const QChar *c = str.constData();\n    qreal res = (c == nullptr ? qreal{} : toDouble(c));\n    if (ok)\n        *ok = (c == (str.constData() + str.length()));\n    return res;\n}\n\nstatic QList<qreal> parseNumbersList(const QChar *&str)\n{\n    QList<qreal> points;\n    if (!str)\n        return points;\n    points.reserve(32);\n\n    while (str->isSpace())\n        ++str;\n    while (isDigit(str->unicode()) ||\n           *str == QLatin1Char('-') || *str == QLatin1Char('+') ||\n           *str == QLatin1Char('.')) {\n\n        points.append(toDouble(str));\n\n        while (str->isSpace())\n            ++str;\n        if (*str == QLatin1Char(','))\n            ++str;\n\n        //eat the rest of space\n        while (str->isSpace())\n            ++str;\n    }\n\n    return points;\n}\n\nstatic inline void parseNumbersArray(const QChar *&str, QVarLengthArray<qreal, 8> &points,\n                                     const char *pattern = nullptr)\n{\n    const size_t patternLen = qstrlen(pattern);\n    while (str->isSpace())\n        ++str;\n    while (isDigit(str->unicode()) ||\n           *str == QLatin1Char('-') || *str == QLatin1Char('+') ||\n           *str == QLatin1Char('.')) {\n\n        if (patternLen && pattern[points.size() % patternLen] == 'f') {\n            // flag expected, may only be 0 or 1\n            if (*str != QLatin1Char('0') && *str != QLatin1Char('1'))\n                return;\n            points.append(*str == QLatin1Char('0') ? 0.0 : 1.0);\n            ++str;\n        } else {\n            points.append(toDouble(str));\n        }\n\n        while (str->isSpace())\n            ++str;\n        if (*str == QLatin1Char(','))\n            ++str;\n\n        //eat the rest of space\n        while (str->isSpace())\n            ++str;\n    }\n}\n\nstatic QList<qreal> parsePercentageList(const QChar *&str)\n{\n    QList<qreal> points;\n    if (!str)\n        return points;\n\n    while (str->isSpace())\n        ++str;\n    while ((*str >= QLatin1Char('0') && *str <= QLatin1Char('9')) ||\n           *str == QLatin1Char('-') || *str == QLatin1Char('+') ||\n           *str == QLatin1Char('.')) {\n\n        points.append(toDouble(str));\n\n        while (str->isSpace())\n            ++str;\n        if (*str == QLatin1Char('%'))\n            ++str;\n        while (str->isSpace())\n            ++str;\n        if (*str == QLatin1Char(','))\n            ++str;\n\n        //eat the rest of space\n        while (str->isSpace())\n            ++str;\n    }\n\n    return points;\n}\n\nstatic QString idFromUrl(const QString &url)\n{\n    // The form is url(<IRI>), where IRI can be\n    // just an ID on #<id> form.\n    QString::const_iterator itr = url.constBegin();\n    QString::const_iterator end = url.constEnd();\n    QString id;\n    while (itr != end && (*itr).isSpace())\n        ++itr;\n    if (itr != end && (*itr) == QLatin1Char('('))\n        ++itr;\n    else\n        return QString();\n    while (itr != end && (*itr).isSpace())\n        ++itr;\n    if (itr != end && (*itr) == QLatin1Char('#')) {\n        id += *itr;\n        ++itr;\n    } else {\n        return QString();\n    }\n    while (itr != end && (*itr) != QLatin1Char(')')) {\n        id += *itr;\n        ++itr;\n    }\n    if (itr == end || (*itr) != QLatin1Char(')'))\n        return QString();\n    return id;\n}\n\n/**\n * returns true when successfully set the color. false signifies\n * that the color should be inherited\n */\nstatic bool resolveColor(QStringView colorStr, QColor &color, QSvgHandler *handler)\n{\n    QStringView colorStrTr = colorStr.trimmed();\n    if (colorStrTr.isEmpty())\n        return false;\n\n    switch(colorStrTr.at(0).unicode()) {\n\n        case '#':\n            {\n                // #rrggbb is very very common, so let's tackle it here\n                // rather than falling back to QColor\n                QRgb rgb;\n                bool ok = qsvg_get_hex_rgb(colorStrTr.constData(), colorStrTr.length(), &rgb);\n                if (ok)\n                    color.setRgb(rgb);\n                return ok;\n            }\n            break;\n\n        case 'r':\n            {\n                // starts with \"rgb(\", ends with \")\" and consists of at least 7 characters \"rgb(,,)\"\n                if (colorStrTr.length() >= 7 && colorStrTr.at(colorStrTr.length() - 1) == QLatin1Char(')')\n                    && colorStrTr.mid(0, 4) == QLatin1String(\"rgb(\")) {\n                    const QChar *s = colorStrTr.constData() + 4;\n                    QList<qreal> compo = parseNumbersList(s);\n                    //1 means that it failed after reaching non-parsable\n                    //character which is going to be \"%\"\n                    if (compo.size() == 1) {\n                        s = colorStrTr.constData() + 4;\n                        compo = parsePercentageList(s);\n                        for (int i = 0; i < compo.size(); ++i)\n                            compo[i] *= (qreal)2.55;\n                    }\n\n                    if (compo.size() == 3) {\n                        color = QColor(int(compo[0]),\n                                       int(compo[1]),\n                                       int(compo[2]));\n                        return true;\n                    }\n                    return false;\n                }\n            }\n            break;\n\n        case 'c':\n            if (colorStrTr == QLatin1String(\"currentColor\")) {\n                color = handler->currentColor();\n                return true;\n            }\n            break;\n        case 'i':\n            if (colorStrTr == QT_INHERIT)\n                return false;\n            break;\n        default:\n            break;\n    }\n\n    color = QColor(colorStrTr.toString());\n    return color.isValid();\n}\n\nstatic bool constructColor(QStringView colorStr, QStringView opacity,\n                           QColor &color, QSvgHandler *handler)\n{\n    if (!resolveColor(colorStr, color, handler))\n        return false;\n    if (!opacity.isEmpty()) {\n        bool ok = true;\n        qreal op = qMin(qreal(1.0), qMax(qreal(0.0), toDouble(opacity, &ok)));\n        if (!ok)\n            op = 1.0;\n        color.setAlphaF(op);\n    }\n    return true;\n}\n\nstatic qreal parseLength(QStringView str, QSvgHandler::LengthType &type,\n                         QSvgHandler *handler, bool *ok = NULL)\n{\n    QStringView numStr = str.trimmed();\n\n    if (numStr.endsWith(QLatin1Char('%'))) {\n        numStr.chop(1);\n        type = QSvgHandler::LT_PERCENT;\n    } else if (numStr.endsWith(QLatin1String(\"px\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_PX;\n    } else if (numStr.endsWith(QLatin1String(\"pc\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_PC;\n    } else if (numStr.endsWith(QLatin1String(\"pt\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_PT;\n    } else if (numStr.endsWith(QLatin1String(\"mm\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_MM;\n    } else if (numStr.endsWith(QLatin1String(\"cm\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_CM;\n    } else if (numStr.endsWith(QLatin1String(\"in\"))) {\n        numStr.chop(2);\n        type = QSvgHandler::LT_IN;\n    } else {\n        type = handler->defaultCoordinateSystem();\n        //type = QSvgHandler::LT_OTHER;\n    }\n    qreal len = toDouble(numStr, ok);\n    //qDebug()<<\"len is \"<<len<<\", from '\"<<numStr << \"'\";\n    return len;\n}\n\nstatic inline qreal convertToNumber(QStringView str, QSvgHandler *handler, bool *ok = NULL)\n{\n    QSvgHandler::LengthType type;\n    qreal num = parseLength(str.toString(), type, handler, ok);\n    if (type == QSvgHandler::LT_PERCENT) {\n        num = num/100.0;\n    }\n    return num;\n}\n\nstatic bool createSvgGlyph(QSvgFont *font, const QXmlStreamAttributes &attributes)\n{\n    QStringView uncStr = attributes.value(QLatin1String(\"unicode\"));\n    QStringView havStr = attributes.value(QLatin1String(\"horiz-adv-x\"));\n    QStringView pathStr = attributes.value(QLatin1String(\"d\"));\n\n    QChar unicode = (uncStr.isEmpty()) ? u'\\0' : uncStr.at(0);\n    qreal havx = (havStr.isEmpty()) ? -1 : toDouble(havStr);\n    QPainterPath path;\n    path.setFillRule(Qt::WindingFill);\n    parsePathDataFast(pathStr, path);\n\n    font->addGlyph(unicode, path, havx);\n\n    return true;\n}\n\n// this should really be called convertToDefaultCoordinateSystem\n// and convert when type != QSvgHandler::defaultCoordinateSystem\nstatic qreal convertToPixels(qreal len, bool , QSvgHandler::LengthType type)\n{\n\n    switch (type) {\n    case QSvgHandler::LT_PERCENT:\n        break;\n    case QSvgHandler::LT_PX:\n        break;\n    case QSvgHandler::LT_PC:\n        break;\n    case QSvgHandler::LT_PT:\n        return len * 1.25;\n        break;\n    case QSvgHandler::LT_MM:\n        return len * 3.543307;\n        break;\n    case QSvgHandler::LT_CM:\n        return len * 35.43307;\n        break;\n    case QSvgHandler::LT_IN:\n        return len * 90;\n        break;\n    case QSvgHandler::LT_OTHER:\n        break;\n    default:\n        break;\n    }\n    return len;\n}\n\nstatic void parseColor(QSvgNode *,\n                       const QSvgAttributes &attributes,\n                       QSvgHandler *handler)\n{\n    QColor color;\n    if (constructColor(attributes.color, attributes.colorOpacity, color, handler)) {\n        handler->popColor();\n        handler->pushColor(color);\n    }\n}\n\nstatic QSvgStyleProperty *styleFromUrl(QSvgNode *node, const QString &url)\n{\n    return node ? node->styleProperty(idFromUrl(url)) : 0;\n}\n\nstatic void parseBrush(QSvgNode *node,\n                       const QSvgAttributes &attributes,\n                       QSvgHandler *handler)\n{\n    if (!attributes.fill.isEmpty() || !attributes.fillRule.isEmpty() || !attributes.fillOpacity.isEmpty()) {\n        QSvgFillStyle *prop = new QSvgFillStyle;\n\n        //fill-rule attribute handling\n        if (!attributes.fillRule.isEmpty() && attributes.fillRule != QT_INHERIT) {\n            if (attributes.fillRule == QLatin1String(\"evenodd\"))\n                prop->setFillRule(Qt::OddEvenFill);\n            else if (attributes.fillRule == QLatin1String(\"nonzero\"))\n                prop->setFillRule(Qt::WindingFill);\n        }\n\n        //fill-opacity attribute handling\n        if (!attributes.fillOpacity.isEmpty() && attributes.fillOpacity != QT_INHERIT) {\n            prop->setFillOpacity(qMin(qreal(1.0), qMax(qreal(0.0), toDouble(attributes.fillOpacity))));\n        }\n\n        //fill attribute handling\n        if ((!attributes.fill.isEmpty()) && (attributes.fill != QT_INHERIT) ) {\n            if (attributes.fill.length() > 3 && attributes.fill.mid(0, 3) == QLatin1String(\"url\")) {\n                QString value = attributes.fill.mid(3, attributes.fill.length() - 3).toString();\n                QSvgStyleProperty *style = styleFromUrl(node, value);\n                if (style) {\n                    if (style->type() == QSvgStyleProperty::SOLID_COLOR || style->type() == QSvgStyleProperty::GRADIENT)\n                        prop->setFillStyle(reinterpret_cast<QSvgFillStyleProperty *>(style));\n                } else {\n                    QString id = idFromUrl(value);\n                    prop->setGradientId(id);\n                    prop->setGradientResolved(false);\n                }\n            } else if (attributes.fill != QLatin1String(\"none\")) {\n                QColor color;\n                if (resolveColor(attributes.fill, color, handler))\n                    prop->setBrush(QBrush(color));\n            } else {\n                prop->setBrush(QBrush(Qt::NoBrush));\n            }\n        }\n        node->appendStyleProperty(prop, attributes.id);\n    }\n}\n\n\n\nstatic QTransform parseTransformationMatrix(QStringView value)\n{\n    if (value.isEmpty())\n        return QTransform();\n\n    QTransform matrix;\n    const QChar *str = value.constData();\n    const QChar *end = str + value.length();\n\n    while (str < end) {\n        if (str->isSpace() || *str == QLatin1Char(',')) {\n            ++str;\n            continue;\n        }\n        enum State {\n            Matrix,\n            Translate,\n            Rotate,\n            Scale,\n            SkewX,\n            SkewY\n        };\n        State state = Matrix;\n        if (*str == QLatin1Char('m')) {  //matrix\n            const char *ident = \"atrix\";\n            for (int i = 0; i < 5; ++i)\n                if (*(++str) != QLatin1Char(ident[i]))\n                    goto error;\n            ++str;\n            state = Matrix;\n        } else if (*str == QLatin1Char('t')) { //translate\n            const char *ident = \"ranslate\";\n            for (int i = 0; i < 8; ++i)\n                if (*(++str) != QLatin1Char(ident[i]))\n                    goto error;\n            ++str;\n            state = Translate;\n        } else if (*str == QLatin1Char('r')) { //rotate\n            const char *ident = \"otate\";\n            for (int i = 0; i < 5; ++i)\n                if (*(++str) != QLatin1Char(ident[i]))\n                    goto error;\n            ++str;\n            state = Rotate;\n        } else if (*str == QLatin1Char('s')) { //scale, skewX, skewY\n            ++str;\n            if (*str == QLatin1Char('c')) {\n                const char *ident = \"ale\";\n                for (int i = 0; i < 3; ++i)\n                    if (*(++str) != QLatin1Char(ident[i]))\n                        goto error;\n                ++str;\n                state = Scale;\n            } else if (*str == QLatin1Char('k')) {\n                if (*(++str) != QLatin1Char('e'))\n                    goto error;\n                if (*(++str) != QLatin1Char('w'))\n                    goto error;\n                ++str;\n                if (*str == QLatin1Char('X'))\n                    state = SkewX;\n                else if (*str == QLatin1Char('Y'))\n                    state = SkewY;\n                else\n                    goto error;\n                ++str;\n            } else {\n                goto error;\n            }\n        } else {\n            goto error;\n        }\n\n\n        while (str < end && str->isSpace())\n            ++str;\n        if (*str != QLatin1Char('('))\n            goto error;\n        ++str;\n        QVarLengthArray<qreal, 8> points;\n        parseNumbersArray(str, points);\n        if (*str != QLatin1Char(')'))\n            goto error;\n        ++str;\n\n        if(state == Matrix) {\n            if(points.count() != 6)\n                goto error;\n            matrix = QTransform(points[0], points[1],\n                                points[2], points[3],\n                                points[4], points[5]) * matrix;\n        } else if (state == Translate) {\n            if (points.count() == 1)\n                matrix.translate(points[0], 0);\n            else if (points.count() == 2)\n                matrix.translate(points[0], points[1]);\n            else\n                goto error;\n        } else if (state == Rotate) {\n            if(points.count() == 1) {\n                matrix.rotate(points[0]);\n            } else if (points.count() == 3) {\n                matrix.translate(points[1], points[2]);\n                matrix.rotate(points[0]);\n                matrix.translate(-points[1], -points[2]);\n            } else {\n                goto error;\n            }\n        } else if (state == Scale) {\n            if (points.count() < 1 || points.count() > 2)\n                goto error;\n            qreal sx = points[0];\n            qreal sy = sx;\n            if(points.count() == 2)\n                sy = points[1];\n            matrix.scale(sx, sy);\n        } else if (state == SkewX) {\n            if (points.count() != 1)\n                goto error;\n            matrix.shear(qTan(qDegreesToRadians(points[0])), 0);\n        } else if (state == SkewY) {\n            if (points.count() != 1)\n                goto error;\n            matrix.shear(0, qTan(qDegreesToRadians(points[0])));\n        }\n    }\n  error:\n    return matrix;\n}\n\nstatic void parsePen(QSvgNode *node,\n                     const QSvgAttributes &attributes,\n                     QSvgHandler *handler)\n{\n    //qDebug()<<\"Node \"<<node->type()<<\", attrs are \"<<value<<width;\n\n    if (!attributes.stroke.isEmpty() || !attributes.strokeDashArray.isEmpty() || !attributes.strokeDashOffset.isEmpty() || !attributes.strokeLineCap.isEmpty()\n        || !attributes.strokeLineJoin.isEmpty() || !attributes.strokeMiterLimit.isEmpty() || !attributes.strokeOpacity.isEmpty() || !attributes.strokeWidth.isEmpty()\n        || !attributes.vectorEffect.isEmpty()) {\n\n        QSvgStrokeStyle *prop = new QSvgStrokeStyle;\n\n        //stroke attribute handling\n        if ((!attributes.stroke.isEmpty()) && (attributes.stroke != QT_INHERIT) ) {\n            if (attributes.stroke.length() > 3 && attributes.stroke.mid(0, 3) == QLatin1String(\"url\")) {\n                 QString value = attributes.stroke.mid(3, attributes.stroke.length() - 3).toString();\n                    QSvgStyleProperty *style = styleFromUrl(node, value);\n                    if (style) {\n                        if (style->type() == QSvgStyleProperty::SOLID_COLOR || style->type() == QSvgStyleProperty::GRADIENT)\n                            prop->setStyle(reinterpret_cast<QSvgFillStyleProperty *>(style));\n                    } else {\n                        QString id = idFromUrl(value);\n                        prop->setGradientId(id);\n                        prop->setGradientResolved(false);\n                    }\n            } else if (attributes.stroke != QLatin1String(\"none\")) {\n                QColor color;\n                if (resolveColor(attributes.stroke, color, handler))\n                    prop->setStroke(QBrush(color));\n            } else {\n                prop->setStroke(QBrush(Qt::NoBrush));\n            }\n        }\n\n        //stroke-width handling\n        if (!attributes.strokeWidth.isEmpty() && attributes.strokeWidth != QT_INHERIT) {\n            QSvgHandler::LengthType lt;\n            prop->setWidth(parseLength(attributes.strokeWidth, lt, handler));\n        }\n\n        //stroke-dasharray\n        if (!attributes.strokeDashArray.isEmpty() && attributes.strokeDashArray != QT_INHERIT) {\n            if (attributes.strokeDashArray == QLatin1String(\"none\")) {\n                prop->setDashArrayNone();\n            } else {\n                QString dashArray  = attributes.strokeDashArray.toString();\n                const QChar *s = dashArray.constData();\n                QList<qreal> dashes = parseNumbersList(s);\n                // if the dash count is odd the dashes should be duplicated\n                if ((dashes.size() & 1) != 0)\n                    dashes << QList<qreal>(dashes);\n                prop->setDashArray(dashes);\n            }\n        }\n\n        //stroke-linejoin attribute handling\n        if (!attributes.strokeLineJoin.isEmpty()) {\n            if (attributes.strokeLineJoin == QLatin1String(\"miter\"))\n                prop->setLineJoin(Qt::SvgMiterJoin);\n            else if (attributes.strokeLineJoin == QLatin1String(\"round\"))\n                prop->setLineJoin(Qt::RoundJoin);\n            else if (attributes.strokeLineJoin == QLatin1String(\"bevel\"))\n                prop->setLineJoin(Qt::BevelJoin);\n        }\n\n        //stroke-linecap attribute handling\n        if (!attributes.strokeLineCap.isEmpty()) {\n            if (attributes.strokeLineCap == QLatin1String(\"butt\"))\n                prop->setLineCap(Qt::FlatCap);\n            else if (attributes.strokeLineCap == QLatin1String(\"round\"))\n                prop->setLineCap(Qt::RoundCap);\n            else if (attributes.strokeLineCap == QLatin1String(\"square\"))\n                prop->setLineCap(Qt::SquareCap);\n        }\n\n        //stroke-dashoffset attribute handling\n        if (!attributes.strokeDashOffset.isEmpty() && attributes.strokeDashOffset != QT_INHERIT)\n            prop->setDashOffset(toDouble(attributes.strokeDashOffset));\n\n        //vector-effect attribute handling\n        if (!attributes.vectorEffect.isEmpty()) {\n            if (attributes.vectorEffect == QLatin1String(\"non-scaling-stroke\"))\n                prop->setVectorEffect(true);\n            else if (attributes.vectorEffect == QLatin1String(\"none\"))\n                prop->setVectorEffect(false);\n        }\n\n        //stroke-miterlimit\n        if (!attributes.strokeMiterLimit.isEmpty() && attributes.strokeMiterLimit != QT_INHERIT)\n            prop->setMiterLimit(toDouble(attributes.strokeMiterLimit));\n\n        //stroke-opacity atttribute handling\n        if (!attributes.strokeOpacity.isEmpty() && attributes.strokeOpacity != QT_INHERIT)\n            prop->setOpacity(qMin(qreal(1.0), qMax(qreal(0.0), toDouble(attributes.strokeOpacity))));\n\n        node->appendStyleProperty(prop, attributes.id);\n    }\n}\n\nenum FontSizeSpec { XXSmall, XSmall, Small, Medium, Large, XLarge, XXLarge,\n                   FontSizeNone, FontSizeValue };\n\nstatic const qreal sizeTable[] =\n{ qreal(6.9), qreal(8.3), qreal(10.0), qreal(12.0), qreal(14.4), qreal(17.3), qreal(20.7) };\n\nQ_STATIC_ASSERT(sizeof(sizeTable)/sizeof(sizeTable[0]) == FontSizeNone);\n\nstatic FontSizeSpec fontSizeSpec(QStringView spec)\n{\n    switch (spec.at(0).unicode()) {\n    case 'x':\n        if (spec == QLatin1String(\"xx-small\"))\n            return XXSmall;\n        if (spec == QLatin1String(\"x-small\"))\n            return XSmall;\n        if (spec == QLatin1String(\"x-large\"))\n            return XLarge;\n        if (spec == QLatin1String(\"xx-large\"))\n            return XXLarge;\n        break;\n    case 's':\n        if (spec == QLatin1String(\"small\"))\n            return Small;\n        break;\n    case 'm':\n        if (spec == QLatin1String(\"medium\"))\n            return Medium;\n        break;\n    case 'l':\n        if (spec == QLatin1String(\"large\"))\n            return Large;\n        break;\n    case 'n':\n        if (spec == QLatin1String(\"none\"))\n            return FontSizeNone;\n        break;\n    default:\n        break;\n    }\n    return FontSizeValue;\n}\n\nstatic void parseFont(QSvgNode *node,\n                      const QSvgAttributes &attributes,\n                      QSvgHandler *handler)\n{\n    if (attributes.fontFamily.isEmpty() && attributes.fontSize.isEmpty() && attributes.fontStyle.isEmpty() &&\n        attributes.fontWeight.isEmpty() && attributes.fontVariant.isEmpty() && attributes.textAnchor.isEmpty())\n        return;\n\n    QSvgTinyDocument *doc = node->document();\n    QSvgFontStyle *fontStyle = nullptr;\n    if (!attributes.fontFamily.isEmpty()) {\n        QSvgFont *svgFont = doc->svgFont(attributes.fontFamily.toString());\n        if (svgFont)\n            fontStyle = new QSvgFontStyle(svgFont, doc);\n    }\n    if (!fontStyle)\n        fontStyle = new QSvgFontStyle;\n    if (!attributes.fontFamily.isEmpty() && attributes.fontFamily != QT_INHERIT) {\n        QString family = attributes.fontFamily.toString().trimmed();\n        if (family.at(0) == QLatin1Char('\\'') || family.at(0) == QLatin1Char('\\\"'))\n            family = family.mid(1, family.length() - 2);\n        fontStyle->setFamily(family);\n    }\n\n    if (!attributes.fontSize.isEmpty() && attributes.fontSize != QT_INHERIT) {\n        // TODO: Support relative sizes 'larger' and 'smaller'.\n        const FontSizeSpec spec = fontSizeSpec(attributes.fontSize);\n        switch (spec) {\n        case FontSizeNone:\n            break;\n        case FontSizeValue: {\n            QSvgHandler::LengthType type;\n            qreal fs = parseLength(attributes.fontSize, type, handler);\n            fs = convertToPixels(fs, true, type);\n            fontStyle->setSize(qMin(fs, qreal(0xffff)));\n        }\n            break;\n        default:\n            fontStyle->setSize(sizeTable[spec]);\n            break;\n        }\n    }\n\n    if (!attributes.fontStyle.isEmpty() && attributes.fontStyle != QT_INHERIT) {\n        if (attributes.fontStyle == QLatin1String(\"normal\")) {\n            fontStyle->setStyle(QFont::StyleNormal);\n        } else if (attributes.fontStyle == QLatin1String(\"italic\")) {\n            fontStyle->setStyle(QFont::StyleItalic);\n        } else if (attributes.fontStyle == QLatin1String(\"oblique\")) {\n            fontStyle->setStyle(QFont::StyleOblique);\n        }\n    }\n\n    if (!attributes.fontWeight.isEmpty() && attributes.fontWeight != QT_INHERIT) {\n        bool ok = false;\n        const int weightNum = attributes.fontWeight.toInt(&ok);\n        if (ok) {\n            fontStyle->setWeight(weightNum);\n        } else {\n            if (attributes.fontWeight == QLatin1String(\"normal\")) {\n                fontStyle->setWeight(QFont::Normal);\n            } else if (attributes.fontWeight == QLatin1String(\"bold\")) {\n                fontStyle->setWeight(QFont::Bold);\n            } else if (attributes.fontWeight == QLatin1String(\"bolder\")) {\n                fontStyle->setWeight(QSvgFontStyle::BOLDER);\n            } else if (attributes.fontWeight == QLatin1String(\"lighter\")) {\n                fontStyle->setWeight(QSvgFontStyle::LIGHTER);\n            }\n        }\n    }\n\n    if (!attributes.fontVariant.isEmpty() && attributes.fontVariant != QT_INHERIT) {\n        if (attributes.fontVariant == QLatin1String(\"normal\"))\n            fontStyle->setVariant(QFont::MixedCase);\n        else if (attributes.fontVariant == QLatin1String(\"small-caps\"))\n            fontStyle->setVariant(QFont::SmallCaps);\n    }\n\n    if (!attributes.textAnchor.isEmpty() && attributes.textAnchor != QT_INHERIT) {\n        if (attributes.textAnchor == QLatin1String(\"start\"))\n            fontStyle->setTextAnchor(Qt::AlignLeft);\n        if (attributes.textAnchor == QLatin1String(\"middle\"))\n           fontStyle->setTextAnchor(Qt::AlignHCenter);\n        else if (attributes.textAnchor == QLatin1String(\"end\"))\n           fontStyle->setTextAnchor(Qt::AlignRight);\n    }\n\n    node->appendStyleProperty(fontStyle, attributes.id);\n}\n\nstatic void parseTransform(QSvgNode *node,\n                           const QSvgAttributes &attributes,\n                           QSvgHandler *)\n{\n    if (attributes.transform.isEmpty())\n        return;\n    QTransform matrix = parseTransformationMatrix(attributes.transform.trimmed());\n\n    if (!matrix.isIdentity()) {\n        node->appendStyleProperty(new QSvgTransformStyle(QTransform(matrix)), attributes.id);\n    }\n\n}\n\nstatic void parseVisibility(QSvgNode *node,\n                            const QSvgAttributes &attributes,\n                            QSvgHandler *)\n{\n    QSvgNode *parent = node->parent();\n\n    if (parent && (attributes.visibility.isEmpty() || attributes.visibility == QT_INHERIT))\n        node->setVisible(parent->isVisible());\n    else if (attributes.visibility == QLatin1String(\"hidden\") || attributes.visibility == QLatin1String(\"collapse\")) {\n        node->setVisible(false);\n    } else\n        node->setVisible(true);\n}\n\nstatic void pathArcSegment(QPainterPath &path,\n                           qreal xc, qreal yc,\n                           qreal th0, qreal th1,\n                           qreal rx, qreal ry, qreal xAxisRotation)\n{\n    qreal sinTh, cosTh;\n    qreal a00, a01, a10, a11;\n    qreal x1, y1, x2, y2, x3, y3;\n    qreal t;\n    qreal thHalf;\n\n    sinTh = qSin(xAxisRotation * (Q_PI / 180.0));\n    cosTh = qCos(xAxisRotation * (Q_PI / 180.0));\n\n    a00 =  cosTh * rx;\n    a01 = -sinTh * ry;\n    a10 =  sinTh * rx;\n    a11 =  cosTh * ry;\n\n    thHalf = 0.5 * (th1 - th0);\n    t = (8.0 / 3.0) * qSin(thHalf * 0.5) * qSin(thHalf * 0.5) / qSin(thHalf);\n    x1 = xc + qCos(th0) - t * qSin(th0);\n    y1 = yc + qSin(th0) + t * qCos(th0);\n    x3 = xc + qCos(th1);\n    y3 = yc + qSin(th1);\n    x2 = x3 + t * qSin(th1);\n    y2 = y3 - t * qCos(th1);\n\n    path.cubicTo(a00 * x1 + a01 * y1, a10 * x1 + a11 * y1,\n                 a00 * x2 + a01 * y2, a10 * x2 + a11 * y2,\n                 a00 * x3 + a01 * y3, a10 * x3 + a11 * y3);\n}\n\n// the arc handling code underneath is from XSVG (BSD license)\n/*\n * Copyright  2002 USC/Information Sciences Institute\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without\n * fee, provided that the above copyright notice appear in all copies\n * and that both that copyright notice and this permission notice\n * appear in supporting documentation, and that the name of\n * Information Sciences Institute not be used in advertising or\n * publicity pertaining to distribution of the software without\n * specific, written prior permission.  Information Sciences Institute\n * makes no representations about the suitability of this software for\n * any purpose.  It is provided \"as is\" without express or implied\n * warranty.\n *\n * INFORMATION SCIENCES INSTITUTE DISCLAIMS ALL WARRANTIES WITH REGARD\n * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL INFORMATION SCIENCES\n * INSTITUTE BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA\n * OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n *\n */\nstatic void pathArc(QPainterPath &path,\n                    qreal               rx,\n                    qreal               ry,\n                    qreal               x_axis_rotation,\n                    int         large_arc_flag,\n                    int         sweep_flag,\n                    qreal               x,\n                    qreal               y,\n                    qreal curx, qreal cury)\n{\n    const qreal Pr1 = rx * rx;\n    const qreal Pr2 = ry * ry;\n\n    if (!Pr1 || !Pr2)\n        return;\n\n    qreal sin_th, cos_th;\n    qreal a00, a01, a10, a11;\n    qreal x0, y0, x1, y1, xc, yc;\n    qreal d, sfactor, sfactor_sq;\n    qreal th0, th1, th_arc;\n    int i, n_segs;\n    qreal dx, dy, dx1, dy1, Px, Py, check;\n\n    rx = qAbs(rx);\n    ry = qAbs(ry);\n\n    sin_th = qSin(x_axis_rotation * (Q_PI / 180.0));\n    cos_th = qCos(x_axis_rotation * (Q_PI / 180.0));\n\n    dx = (curx - x) / 2.0;\n    dy = (cury - y) / 2.0;\n    dx1 =  cos_th * dx + sin_th * dy;\n    dy1 = -sin_th * dx + cos_th * dy;\n    Px = dx1 * dx1;\n    Py = dy1 * dy1;\n    /* Spec : check if radii are large enough */\n    check = Px / Pr1 + Py / Pr2;\n    if (check > 1) {\n        rx = rx * qSqrt(check);\n        ry = ry * qSqrt(check);\n    }\n\n    a00 =  cos_th / rx;\n    a01 =  sin_th / rx;\n    a10 = -sin_th / ry;\n    a11 =  cos_th / ry;\n    x0 = a00 * curx + a01 * cury;\n    y0 = a10 * curx + a11 * cury;\n    x1 = a00 * x + a01 * y;\n    y1 = a10 * x + a11 * y;\n    /* (x0, y0) is current point in transformed coordinate space.\n       (x1, y1) is new point in transformed coordinate space.\n\n       The arc fits a unit-radius circle in this space.\n    */\n    d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n    if (!d)\n        return;\n    sfactor_sq = 1.0 / d - 0.25;\n    if (sfactor_sq < 0) sfactor_sq = 0;\n    sfactor = qSqrt(sfactor_sq);\n    if (sweep_flag == large_arc_flag) sfactor = -sfactor;\n    xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n    yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n    /* (xc, yc) is center of the circle. */\n\n    th0 = qAtan2(y0 - yc, x0 - xc);\n    th1 = qAtan2(y1 - yc, x1 - xc);\n\n    th_arc = th1 - th0;\n    if (th_arc < 0 && sweep_flag)\n        th_arc += 2 * Q_PI;\n    else if (th_arc > 0 && !sweep_flag)\n        th_arc -= 2 * Q_PI;\n\n    n_segs = qCeil(qAbs(th_arc / (Q_PI * 0.5 + 0.001)));\n\n    for (i = 0; i < n_segs; i++) {\n        pathArcSegment(path, xc, yc,\n                       th0 + i * th_arc / n_segs,\n                       th0 + (i + 1) * th_arc / n_segs,\n                       rx, ry, x_axis_rotation);\n    }\n}\n\nstatic bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n{\n    const int maxElementCount = 0x7fff; // Assume file corruption if more path elements than this\n    qreal x0 = 0, y0 = 0;              // starting point\n    qreal x = 0, y = 0;                // current point\n    char lastMode = 0;\n    QPointF ctrlPt;\n    const QChar *str = dataStr.constData();\n    const QChar *end = str + dataStr.size();\n\n    bool ok = true;\n    while (ok && str != end) {\n        while (str->isSpace() && (str + 1) != end)\n            ++str;\n        QChar pathElem = *str;\n        ++str;\n        QChar endc = *end;\n        *const_cast<QChar *>(end) = u'\\0'; // parseNumbersArray requires 0-termination that QStringView cannot guarantee\n        const char *pattern = nullptr;\n        if (pathElem == QLatin1Char('a') || pathElem == QLatin1Char('A'))\n            pattern = \"rrrffrr\";\n        QVarLengthArray<qreal, 8> arg;\n        parseNumbersArray(str, arg, pattern);\n        *const_cast<QChar *>(end) = endc;\n        if (pathElem == QLatin1Char('z') || pathElem == QLatin1Char('Z'))\n            arg.append(0);//dummy\n        const qreal *num = arg.constData();\n        int count = arg.count();\n        while (ok && count > 0) {\n            qreal offsetX = x;        // correction offsets\n            qreal offsetY = y;        // for relative commands\n            switch (pathElem.unicode()) {\n            case 'm': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                x = x0 = num[0] + offsetX;\n                y = y0 = num[1] + offsetY;\n                num += 2;\n                count -= 2;\n                path.moveTo(x0, y0);\n\n                 // As per 1.2  spec 8.3.2 The \"moveto\" commands\n                 // If a 'moveto' is followed by multiple pairs of coordinates without explicit commands,\n                 // the subsequent pairs shall be treated as implicit 'lineto' commands.\n                 pathElem = QLatin1Char('l');\n            }\n                break;\n            case 'M': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                x = x0 = num[0];\n                y = y0 = num[1];\n                num += 2;\n                count -= 2;\n                path.moveTo(x0, y0);\n\n                // As per 1.2  spec 8.3.2 The \"moveto\" commands\n                // If a 'moveto' is followed by multiple pairs of coordinates without explicit commands,\n                // the subsequent pairs shall be treated as implicit 'lineto' commands.\n                pathElem = QLatin1Char('L');\n            }\n                break;\n            case 'z':\n            case 'Z': {\n                x = x0;\n                y = y0;\n                count--; // skip dummy\n                num++;\n                path.closeSubpath();\n            }\n                break;\n            case 'l': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                x = num[0] + offsetX;\n                y = num[1] + offsetY;\n                num += 2;\n                count -= 2;\n                path.lineTo(x, y);\n\n            }\n                break;\n            case 'L': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                x = num[0];\n                y = num[1];\n                num += 2;\n                count -= 2;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'h': {\n                x = num[0] + offsetX;\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'H': {\n                x = num[0];\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'v': {\n                y = num[0] + offsetY;\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'V': {\n                y = num[0];\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'c': {\n                if (count < 6) {\n                    ok = false;\n                    break;\n                }\n                QPointF c1(num[0] + offsetX, num[1] + offsetY);\n                QPointF c2(num[2] + offsetX, num[3] + offsetY);\n                QPointF e(num[4] + offsetX, num[5] + offsetY);\n                num += 6;\n                count -= 6;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'C': {\n                if (count < 6) {\n                    ok = false;\n                    break;\n                }\n                QPointF c1(num[0], num[1]);\n                QPointF c2(num[2], num[3]);\n                QPointF e(num[4], num[5]);\n                num += 6;\n                count -= 6;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 's': {\n                if (count < 4) {\n                    ok = false;\n                    break;\n                }\n                QPointF c1;\n                if (lastMode == 'c' || lastMode == 'C' ||\n                    lastMode == 's' || lastMode == 'S')\n                    c1 = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c1 = QPointF(x, y);\n                QPointF c2(num[0] + offsetX, num[1] + offsetY);\n                QPointF e(num[2] + offsetX, num[3] + offsetY);\n                num += 4;\n                count -= 4;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'S': {\n                if (count < 4) {\n                    ok = false;\n                    break;\n                }\n                QPointF c1;\n                if (lastMode == 'c' || lastMode == 'C' ||\n                    lastMode == 's' || lastMode == 'S')\n                    c1 = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c1 = QPointF(x, y);\n                QPointF c2(num[0], num[1]);\n                QPointF e(num[2], num[3]);\n                num += 4;\n                count -= 4;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'q': {\n                if (count < 4) {\n                    ok = false;\n                    break;\n                }\n                QPointF c(num[0] + offsetX, num[1] + offsetY);\n                QPointF e(num[2] + offsetX, num[3] + offsetY);\n                num += 4;\n                count -= 4;\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'Q': {\n                if (count < 4) {\n                    ok = false;\n                    break;\n                }\n                QPointF c(num[0], num[1]);\n                QPointF e(num[2], num[3]);\n                num += 4;\n                count -= 4;\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 't': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                QPointF e(num[0] + offsetX, num[1] + offsetY);\n                num += 2;\n                count -= 2;\n                QPointF c;\n                if (lastMode == 'q' || lastMode == 'Q' ||\n                    lastMode == 't' || lastMode == 'T')\n                    c = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c = QPointF(x, y);\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'T': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                QPointF e(num[0], num[1]);\n                num += 2;\n                count -= 2;\n                QPointF c;\n                if (lastMode == 'q' || lastMode == 'Q' ||\n                    lastMode == 't' || lastMode == 'T')\n                    c = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c = QPointF(x, y);\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'a': {\n                if (count < 7) {\n                    ok = false;\n                    break;\n                }\n                qreal rx = (*num++);\n                qreal ry = (*num++);\n                qreal xAxisRotation = (*num++);\n                qreal largeArcFlag  = (*num++);\n                qreal sweepFlag = (*num++);\n                qreal ex = (*num++) + offsetX;\n                qreal ey = (*num++) + offsetY;\n                count -= 7;\n                qreal curx = x;\n                qreal cury = y;\n                pathArc(path, rx, ry, xAxisRotation, int(largeArcFlag),\n                        int(sweepFlag), ex, ey, curx, cury);\n\n                x = ex;\n                y = ey;\n            }\n                break;\n            case 'A': {\n                if (count < 7) {\n                    ok = false;\n                    break;\n                }\n                qreal rx = (*num++);\n                qreal ry = (*num++);\n                qreal xAxisRotation = (*num++);\n                qreal largeArcFlag  = (*num++);\n                qreal sweepFlag = (*num++);\n                qreal ex = (*num++);\n                qreal ey = (*num++);\n                count -= 7;\n                qreal curx = x;\n                qreal cury = y;\n                pathArc(path, rx, ry, xAxisRotation, int(largeArcFlag),\n                        int(sweepFlag), ex, ey, curx, cury);\n\n                x = ex;\n                y = ey;\n            }\n                break;\n            default:\n                ok = false;\n                break;\n            }\n            lastMode = pathElem.toLatin1();\n            if (path.elementCount() > maxElementCount)\n                ok = false;\n        }\n    }\n    return ok;\n}\n\nstatic bool parseStyle(QSvgNode *node,\n                       const QXmlStreamAttributes &attributes,\n                       QSvgHandler *);\n\nstatic bool parseStyle(QSvgNode *node,\n                       const QSvgAttributes &attributes,\n                       QSvgHandler *);\n\n#ifndef QT_NO_CSSPARSER\n\nstatic void parseCSStoXMLAttrs(const QList<QCss::Declaration> &declarations,\n                               QXmlStreamAttributes &attributes)\n{\n    for (int i = 0; i < declarations.count(); ++i) {\n        const QCss::Declaration &decl = declarations.at(i);\n        if (decl.d->property.isEmpty())\n            continue;\n        QCss::Value val = decl.d->values.first();\n        QString valueStr;\n        const int valCount = decl.d->values.count();\n        if (valCount != 1) {\n            for (int i = 0; i < valCount; ++i) {\n                valueStr += decl.d->values[i].toString();\n                if (i + 1 < valCount)\n                    valueStr += QLatin1Char(',');\n            }\n        } else {\n            valueStr = val.toString();\n        }\n        if (val.type == QCss::Value::Uri) {\n            valueStr.prepend(QLatin1String(\"url(\"));\n            valueStr.append(QLatin1Char(')'));\n        } else if (val.type == QCss::Value::Function) {\n            QStringList lst = val.variant.toStringList();\n            valueStr.append(lst.at(0));\n            valueStr.append(QLatin1Char('('));\n            for (int i = 1; i < lst.count(); ++i) {\n                valueStr.append(lst.at(i));\n                if ((i +1) < lst.count())\n                    valueStr.append(QLatin1Char(','));\n            }\n            valueStr.append(QLatin1Char(')'));\n        } else if (val.type == QCss::Value::KnownIdentifier) {\n            switch (val.variant.toInt()) {\n            case QCss::Value_None:\n                valueStr = QLatin1String(\"none\");\n                break;\n            default:\n                break;\n            }\n        }\n\n        attributes.append(QString(), decl.d->property, valueStr);\n    }\n}\n\nvoid QSvgHandler::parseCSStoXMLAttrs(const QString &css, QList<QSvgCssAttribute> *attributes)\n{\n    // preprocess (for unicode escapes), tokenize and remove comments\n    m_cssParser.init(css);\n    QString key;\n\n    attributes->reserve(10);\n\n    while (m_cssParser.hasNext()) {\n        m_cssParser.skipSpace();\n\n        if (!m_cssParser.hasNext())\n            break;\n        m_cssParser.next();\n\n        QString name;\n        if (m_cssParser.hasEscapeSequences) {\n            key = m_cssParser.lexem();\n            name = key;\n        } else {\n            const QCss::Symbol &sym = m_cssParser.symbol();\n            name = sym.text.mid(sym.start, sym.len);\n        }\n\n        m_cssParser.skipSpace();\n        if (!m_cssParser.test(QCss::COLON))\n            break;\n\n        m_cssParser.skipSpace();\n        if (!m_cssParser.hasNext())\n            break;\n\n        QSvgCssAttribute attribute;\n        attribute.name = name;\n\n        const int firstSymbol = m_cssParser.index;\n        int symbolCount = 0;\n        do {\n            m_cssParser.next();\n            ++symbolCount;\n        } while (m_cssParser.hasNext() && !m_cssParser.test(QCss::SEMICOLON));\n\n        bool canExtractValueByRef = !m_cssParser.hasEscapeSequences;\n        if (canExtractValueByRef) {\n            int len = m_cssParser.symbols.at(firstSymbol).len;\n            for (int i = firstSymbol + 1; i < firstSymbol + symbolCount; ++i) {\n                len += m_cssParser.symbols.at(i).len;\n\n                if (m_cssParser.symbols.at(i - 1).start + m_cssParser.symbols.at(i - 1).len\n                        != m_cssParser.symbols.at(i).start) {\n                    canExtractValueByRef = false;\n                    break;\n                }\n            }\n            if (canExtractValueByRef) {\n                const QCss::Symbol &sym = m_cssParser.symbols.at(firstSymbol);\n                attribute.value = sym.text.mid(sym.start, len);\n            }\n        }\n        if (!canExtractValueByRef) {\n            QString value;\n            for (int i = firstSymbol; i < m_cssParser.index - 1; ++i)\n                value += m_cssParser.symbols.at(i).lexem();\n            attribute.value = value;\n        }\n\n        attributes->append(attribute);\n\n        m_cssParser.skipSpace();\n    }\n}\n\nstatic void cssStyleLookup(QSvgNode *node,\n                           QSvgHandler *handler,\n                           QSvgStyleSelector *selector)\n{\n    QCss::StyleSelector::NodePtr cssNode;\n    cssNode.ptr = node;\n    QList<QCss::Declaration> decls = selector->declarationsForNode(cssNode);\n\n    QXmlStreamAttributes attributes;\n    parseCSStoXMLAttrs(decls, attributes);\n    parseStyle(node, attributes, handler);\n}\n\n#endif // QT_NO_CSSPARSER\n\nstatic inline QStringList stringToList(const QString &str)\n{\n    QStringList lst = str.split(QLatin1Char(','), Qt::SkipEmptyParts);\n    return lst;\n}\n\nstatic bool parseCoreNode(QSvgNode *node,\n                          const QXmlStreamAttributes &attributes)\n{\n    QStringList features;\n    QStringList extensions;\n    QStringList languages;\n    QStringList formats;\n    QStringList fonts;\n    QString xmlClassStr;\n\n    for (int i = 0; i < attributes.count(); ++i) {\n        const QXmlStreamAttribute &attribute = attributes.at(i);\n        QStringView name = attribute.qualifiedName();\n        if (name.isEmpty())\n            continue;\n        QStringView value = attribute.value();\n        switch (name.at(0).unicode()) {\n        case 'c':\n            if (name == QLatin1String(\"class\"))\n                xmlClassStr = value.toString();\n            break;\n        case 'r':\n            if (name == QLatin1String(\"requiredFeatures\"))\n                features = stringToList(value.toString());\n            else if (name == QLatin1String(\"requiredExtensions\"))\n                extensions = stringToList(value.toString());\n            else if (name == QLatin1String(\"requiredFormats\"))\n                formats = stringToList(value.toString());\n            else if (name == QLatin1String(\"requiredFonts\"))\n                fonts = stringToList(value.toString());\n            break;\n        case 's':\n            if (name == QLatin1String(\"systemLanguage\"))\n                languages = stringToList(value.toString());\n            break;\n        default:\n            break;\n        }\n    }\n\n    node->setRequiredFeatures(features);\n    node->setRequiredExtensions(extensions);\n    node->setRequiredLanguages(languages);\n    node->setRequiredFormats(formats);\n    node->setRequiredFonts(fonts);\n    node->setNodeId(someId(attributes));\n    node->setXmlClass(xmlClassStr);\n\n    return true;\n}\n\nstatic void parseOpacity(QSvgNode *node,\n                         const QSvgAttributes &attributes,\n                         QSvgHandler *)\n{\n    if (attributes.opacity.isEmpty())\n        return;\n\n    const QStringView value = attributes.opacity.trimmed();\n\n    bool ok = false;\n    qreal op = value.toDouble(&ok);\n\n    if (ok) {\n        QSvgOpacityStyle *opacity = new QSvgOpacityStyle(qBound(qreal(0.0), op, qreal(1.0)));\n        node->appendStyleProperty(opacity, attributes.id);\n    }\n}\n\nstatic QPainter::CompositionMode svgToQtCompositionMode(const QString &op)\n{\n#define NOOP qDebug()<<\"Operation: \"<<op<<\" is not implemented\"\n    if (op == QLatin1String(\"clear\")) {\n        return QPainter::CompositionMode_Clear;\n    } else if (op == QLatin1String(\"src\")) {\n        return QPainter::CompositionMode_Source;\n    } else if (op == QLatin1String(\"dst\")) {\n        return QPainter::CompositionMode_Destination;\n    } else if (op == QLatin1String(\"src-over\")) {\n        return QPainter::CompositionMode_SourceOver;\n    } else if (op == QLatin1String(\"dst-over\")) {\n        return QPainter::CompositionMode_DestinationOver;\n    } else if (op == QLatin1String(\"src-in\")) {\n        return QPainter::CompositionMode_SourceIn;\n    } else if (op == QLatin1String(\"dst-in\")) {\n        return QPainter::CompositionMode_DestinationIn;\n    } else if (op == QLatin1String(\"src-out\")) {\n        return QPainter::CompositionMode_SourceOut;\n    } else if (op == QLatin1String(\"dst-out\")) {\n        return QPainter::CompositionMode_DestinationOut;\n    } else if (op == QLatin1String(\"src-atop\")) {\n        return QPainter::CompositionMode_SourceAtop;\n    } else if (op == QLatin1String(\"dst-atop\")) {\n        return QPainter::CompositionMode_DestinationAtop;\n    } else if (op == QLatin1String(\"xor\")) {\n        return QPainter::CompositionMode_Xor;\n    } else if (op == QLatin1String(\"plus\")) {\n        return QPainter::CompositionMode_Plus;\n    } else if (op == QLatin1String(\"multiply\")) {\n        return QPainter::CompositionMode_Multiply;\n    } else if (op == QLatin1String(\"screen\")) {\n        return QPainter::CompositionMode_Screen;\n    } else if (op == QLatin1String(\"overlay\")) {\n        return QPainter::CompositionMode_Overlay;\n    } else if (op == QLatin1String(\"darken\")) {\n        return QPainter::CompositionMode_Darken;\n    } else if (op == QLatin1String(\"lighten\")) {\n        return QPainter::CompositionMode_Lighten;\n    } else if (op == QLatin1String(\"color-dodge\")) {\n        return QPainter::CompositionMode_ColorDodge;\n    } else if (op == QLatin1String(\"color-burn\")) {\n        return QPainter::CompositionMode_ColorBurn;\n    } else if (op == QLatin1String(\"hard-light\")) {\n        return QPainter::CompositionMode_HardLight;\n    } else if (op == QLatin1String(\"soft-light\")) {\n        return QPainter::CompositionMode_SoftLight;\n    } else if (op == QLatin1String(\"difference\")) {\n        return QPainter::CompositionMode_Difference;\n    } else if (op == QLatin1String(\"exclusion\")) {\n        return QPainter::CompositionMode_Exclusion;\n    } else {\n        NOOP;\n    }\n\n    return QPainter::CompositionMode_SourceOver;\n}\n\nstatic void parseCompOp(QSvgNode *node,\n                        const QSvgAttributes &attributes,\n                        QSvgHandler *)\n{\n    if (attributes.compOp.isEmpty())\n        return;\n    QString value = attributes.compOp.toString().trimmed();\n\n    if (!value.isEmpty()) {\n        QSvgCompOpStyle *compop = new QSvgCompOpStyle(svgToQtCompositionMode(value));\n        node->appendStyleProperty(compop, attributes.id);\n    }\n}\n\nstatic inline QSvgNode::DisplayMode displayStringToEnum(const QString &str)\n{\n    if (str == QLatin1String(\"inline\")) {\n        return QSvgNode::InlineMode;\n    } else if (str == QLatin1String(\"block\")) {\n        return QSvgNode::BlockMode;\n    } else if (str == QLatin1String(\"list-item\")) {\n        return QSvgNode::ListItemMode;\n    } else if (str == QLatin1String(\"run-in\")) {\n        return QSvgNode::RunInMode;\n    } else if (str == QLatin1String(\"compact\")) {\n        return QSvgNode::CompactMode;\n    } else if (str == QLatin1String(\"marker\")) {\n        return QSvgNode::MarkerMode;\n    } else if (str == QLatin1String(\"table\")) {\n        return QSvgNode::TableMode;\n    } else if (str == QLatin1String(\"inline-table\")) {\n        return QSvgNode::InlineTableMode;\n    } else if (str == QLatin1String(\"table-row-group\")) {\n        return QSvgNode::TableRowGroupMode;\n    } else if (str == QLatin1String(\"table-header-group\")) {\n        return QSvgNode::TableHeaderGroupMode;\n    } else if (str == QLatin1String(\"table-footer-group\")) {\n        return QSvgNode::TableFooterGroupMode;\n    } else if (str == QLatin1String(\"table-row\")) {\n        return QSvgNode::TableRowMode;\n    } else if (str == QLatin1String(\"table-column-group\")) {\n        return QSvgNode::TableColumnGroupMode;\n    } else if (str == QLatin1String(\"table-column\")) {\n        return QSvgNode::TableColumnMode;\n    } else if (str == QLatin1String(\"table-cell\")) {\n        return QSvgNode::TableCellMode;\n    } else if (str == QLatin1String(\"table-caption\")) {\n        return QSvgNode::TableCaptionMode;\n    } else if (str == QLatin1String(\"none\")) {\n        return QSvgNode::NoneMode;\n    } else if (str == QT_INHERIT) {\n        return QSvgNode::InheritMode;\n    }\n    return QSvgNode::BlockMode;\n}\n\nstatic void parseOthers(QSvgNode *node,\n                        const QSvgAttributes &attributes,\n                        QSvgHandler *)\n{\n    if (attributes.display.isEmpty())\n        return;\n    QString displayStr = attributes.display.toString().trimmed();\n\n    if (!displayStr.isEmpty()) {\n        node->setDisplayMode(displayStringToEnum(displayStr));\n    }\n}\n\nstatic void parseRenderingHints(QSvgNode *node,\n                                const QSvgAttributes &attributes,\n                                QSvgHandler *)\n{\n    if (attributes.imageRendering.isEmpty())\n        return;\n\n    QString ir = attributes.imageRendering.toString().trimmed();\n    QSvgQualityStyle *p = new QSvgQualityStyle(0);\n    if (ir == QLatin1String(\"auto\"))\n        p->setImageRendering(QSvgQualityStyle::ImageRenderingAuto);\n    else if (ir == QLatin1String(\"optimizeSpeed\"))\n        p->setImageRendering(QSvgQualityStyle::ImageRenderingOptimizeSpeed);\n    else if (ir == QLatin1String(\"optimizeQuality\"))\n        p->setImageRendering(QSvgQualityStyle::ImageRenderingOptimizeQuality);\n    node->appendStyleProperty(p, attributes.id);\n}\n\n\nstatic bool parseStyle(QSvgNode *node,\n                       const QSvgAttributes &attributes,\n                       QSvgHandler *handler)\n{\n    parseColor(node, attributes, handler);\n    parseBrush(node, attributes, handler);\n    parsePen(node, attributes, handler);\n    parseFont(node, attributes, handler);\n    parseTransform(node, attributes, handler);\n    parseVisibility(node, attributes, handler);\n    parseOpacity(node, attributes, handler);\n    parseCompOp(node, attributes, handler);\n    parseRenderingHints(node, attributes, handler);\n    parseOthers(node, attributes, handler);\n\n#if 0\n    value = attributes.value(\"audio-level\");\n\n    value = attributes.value(\"color-rendering\");\n\n    value = attributes.value(\"display-align\");\n\n    value = attributes.value(\"image-rendering\");\n\n    value = attributes.value(\"line-increment\");\n\n    value = attributes.value(\"pointer-events\");\n\n    value = attributes.value(\"shape-rendering\");\n\n    value = attributes.value(\"solid-color\");\n\n    value = attributes.value(\"solid-opacity\");\n\n    value = attributes.value(\"text-rendering\");\n\n    value = attributes.value(\"vector-effect\");\n\n    value = attributes.value(\"viewport-fill\");\n\n    value = attributes.value(\"viewport-fill-opacity\");\n#endif\n    return true;\n}\n\nstatic bool parseStyle(QSvgNode *node,\n                       const QXmlStreamAttributes &attrs,\n                       QSvgHandler *handler)\n{\n    return parseStyle(node, QSvgAttributes(attrs, handler), handler);\n}\n\nstatic bool parseAnchorNode(QSvgNode *parent,\n                            const QXmlStreamAttributes &attributes,\n                            QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseAnimateNode(QSvgNode *parent,\n                             const QXmlStreamAttributes &attributes,\n                             QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic int parseClockValue(QStringView str, bool *ok)\n{\n    int res = 0;\n    int ms = 1000;\n    str = str.trimmed();\n    if (str.endsWith(QLatin1String(\"ms\"))) {\n        str.chop(2);\n        ms = 1;\n    } else if (str.endsWith(QLatin1String(\"s\"))) {\n        str.chop(1);\n    }\n    double val = ms * toDouble(str, ok);\n    if (ok) {\n        if (val > std::numeric_limits<int>::min() && val < std::numeric_limits<int>::max())\n            res = static_cast<int>(val);\n        else\n            *ok = false;\n    }\n    return res;\n}\n\nstatic bool parseAnimateColorNode(QSvgNode *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *handler)\n{\n    QStringView fromStr    = attributes.value(QLatin1String(\"from\"));\n    QStringView toStr      = attributes.value(QLatin1String(\"to\"));\n    QString valuesStr  = attributes.value(QLatin1String(\"values\")).toString();\n    QString beginStr   = attributes.value(QLatin1String(\"begin\")).toString();\n    QString durStr     = attributes.value(QLatin1String(\"dur\")).toString();\n    QString targetStr  = attributes.value(QLatin1String(\"attributeName\")).toString();\n    QString repeatStr  = attributes.value(QLatin1String(\"repeatCount\")).toString();\n    QString fillStr    = attributes.value(QLatin1String(\"fill\")).toString();\n\n    QList<QColor> colors;\n    if (valuesStr.isEmpty()) {\n        QColor startColor, endColor;\n        resolveColor(fromStr, startColor, handler);\n        resolveColor(toStr, endColor, handler);\n        colors.reserve(2);\n        colors.append(startColor);\n        colors.append(endColor);\n    } else {\n        QStringList str = valuesStr.split(QLatin1Char(';'));\n        colors.reserve(str.count());\n        QStringList::const_iterator itr;\n        for (itr = str.constBegin(); itr != str.constEnd(); ++itr) {\n            QColor color;\n            resolveColor(*itr, color, handler);\n            colors.append(color);\n        }\n    }\n\n    bool ok = true;\n    int begin = parseClockValue(beginStr, &ok);\n    if (!ok)\n        return false;\n    int end = begin + parseClockValue(durStr, &ok);\n    if (!ok || end <= begin)\n        return false;\n\n    QSvgAnimateColor *anim = new QSvgAnimateColor(begin, end, 0);\n    anim->setArgs((targetStr == QLatin1String(\"fill\")), colors);\n    anim->setFreeze(fillStr == QLatin1String(\"freeze\"));\n    anim->setRepeatCount(\n        (repeatStr == QLatin1String(\"indefinite\")) ? -1 :\n            (repeatStr == QLatin1String(\"\")) ? 1 : toDouble(repeatStr));\n\n    parent->appendStyleProperty(anim, someId(attributes));\n    parent->document()->setAnimated(true);\n    handler->setAnimPeriod(begin, end);\n    return true;\n}\n\nstatic bool parseAimateMotionNode(QSvgNode *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic void parseNumberTriplet(QList<qreal> &values, const QChar *&s)\n{\n    QList<qreal> list = parseNumbersList(s);\n    values << list;\n    for (int i = 3 - list.size(); i > 0; --i)\n        values.append(0.0);\n}\n\nstatic bool parseAnimateTransformNode(QSvgNode *parent,\n                                      const QXmlStreamAttributes &attributes,\n                                      QSvgHandler *handler)\n{\n    QString typeStr    = attributes.value(QLatin1String(\"type\")).toString();\n    QString values     = attributes.value(QLatin1String(\"values\")).toString();\n    QString beginStr   = attributes.value(QLatin1String(\"begin\")).toString();\n    QString durStr     = attributes.value(QLatin1String(\"dur\")).toString();\n    QString repeatStr  = attributes.value(QLatin1String(\"repeatCount\")).toString();\n    QString fillStr    = attributes.value(QLatin1String(\"fill\")).toString();\n    QString fromStr    = attributes.value(QLatin1String(\"from\")).toString();\n    QString toStr      = attributes.value(QLatin1String(\"to\")).toString();\n    QString byStr      = attributes.value(QLatin1String(\"by\")).toString();\n    QString addtv      = attributes.value(QLatin1String(\"additive\")).toString();\n\n    QSvgAnimateTransform::Additive additive = QSvgAnimateTransform::Replace;\n    if (addtv == QLatin1String(\"sum\"))\n        additive = QSvgAnimateTransform::Sum;\n\n    QList<qreal> vals;\n    if (values.isEmpty()) {\n        const QChar *s;\n        if (fromStr.isEmpty()) {\n            if (!byStr.isEmpty()) {\n                // By-animation.\n                additive = QSvgAnimateTransform::Sum;\n                vals.append(0.0);\n                vals.append(0.0);\n                vals.append(0.0);\n                parseNumberTriplet(vals, s = byStr.constData());\n            } else {\n                // To-animation not defined.\n                return false;\n            }\n        } else {\n            if (!toStr.isEmpty()) {\n                // From-to-animation.\n                parseNumberTriplet(vals, s = fromStr.constData());\n                parseNumberTriplet(vals, s = toStr.constData());\n            } else if (!byStr.isEmpty()) {\n                // From-by-animation.\n                parseNumberTriplet(vals, s = fromStr.constData());\n                parseNumberTriplet(vals, s = byStr.constData());\n                for (int i = vals.size() - 3; i < vals.size(); ++i)\n                    vals[i] += vals[i - 3];\n            } else {\n                return false;\n            }\n        }\n    } else {\n        const QChar *s = values.constData();\n        while (s && *s != QLatin1Char(0)) {\n            parseNumberTriplet(vals, s);\n            if (*s == QLatin1Char(0))\n                break;\n            ++s;\n        }\n    }\n\n    bool ok = true;\n    int begin = parseClockValue(beginStr, &ok);\n    if (!ok)\n        return false;\n    int end = begin + parseClockValue(durStr, &ok);\n    if (!ok || end <= begin)\n        return false;\n\n    QSvgAnimateTransform::TransformType type = QSvgAnimateTransform::Empty;\n    if (typeStr == QLatin1String(\"translate\")) {\n        type = QSvgAnimateTransform::Translate;\n    } else if (typeStr == QLatin1String(\"scale\")) {\n        type = QSvgAnimateTransform::Scale;\n    } else if (typeStr == QLatin1String(\"rotate\")) {\n        type = QSvgAnimateTransform::Rotate;\n    } else if (typeStr == QLatin1String(\"skewX\")) {\n        type = QSvgAnimateTransform::SkewX;\n    } else if (typeStr == QLatin1String(\"skewY\")) {\n        type = QSvgAnimateTransform::SkewY;\n    } else {\n        return false;\n    }\n\n    QSvgAnimateTransform *anim = new QSvgAnimateTransform(begin, end, 0);\n    anim->setArgs(type, additive, vals);\n    anim->setFreeze(fillStr == QLatin1String(\"freeze\"));\n    anim->setRepeatCount(\n            (repeatStr == QLatin1String(\"indefinite\"))? -1 :\n            (repeatStr == QLatin1String(\"\"))? 1 : toDouble(repeatStr));\n\n    parent->appendStyleProperty(anim, someId(attributes));\n    parent->document()->setAnimated(true);\n    handler->setAnimPeriod(begin, end);\n    return true;\n}\n\nstatic QSvgNode * createAnimationNode(QSvgNode *parent,\n                                      const QXmlStreamAttributes &attributes,\n                                      QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return 0;\n}\n\nstatic bool parseAudioNode(QSvgNode *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createCircleNode(QSvgNode *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *)\n{\n    const QStringView cx = attributes.value(QLatin1String(\"cx\"));\n    const QStringView cy = attributes.value(QLatin1String(\"cy\"));\n    const QStringView r = attributes.value(QLatin1String(\"r\"));\n    qreal ncx = toDouble(cx);\n    qreal ncy = toDouble(cy);\n    qreal nr  = toDouble(r);\n    if (nr < 0.0)\n        return nullptr;\n\n    QRectF rect(ncx-nr, ncy-nr, nr*2, nr*2);\n    QSvgNode *circle = new QSvgCircle(parent, rect);\n    return circle;\n}\n\nstatic QSvgNode *createDefsNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    Q_UNUSED(attributes);\n    QSvgDefs *defs = new QSvgDefs(parent);\n    return defs;\n}\n\nstatic bool parseDescNode(QSvgNode *parent,\n                          const QXmlStreamAttributes &attributes,\n                          QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseDiscardNode(QSvgNode *parent,\n                             const QXmlStreamAttributes &attributes,\n                             QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createEllipseNode(QSvgNode *parent,\n                                   const QXmlStreamAttributes &attributes,\n                                   QSvgHandler *)\n{\n    const QStringView cx = attributes.value(QLatin1String(\"cx\"));\n    const QStringView cy = attributes.value(QLatin1String(\"cy\"));\n    const QStringView rx = attributes.value(QLatin1String(\"rx\"));\n    const QStringView ry = attributes.value(QLatin1String(\"ry\"));\n    qreal ncx = toDouble(cx);\n    qreal ncy = toDouble(cy);\n    qreal nrx = toDouble(rx);\n    qreal nry = toDouble(ry);\n\n    QRectF rect(ncx-nrx, ncy-nry, nrx*2, nry*2);\n    QSvgNode *ellipse = new QSvgEllipse(parent, rect);\n    return ellipse;\n}\n\nstatic QSvgStyleProperty *createFontNode(QSvgNode *parent,\n                                         const QXmlStreamAttributes &attributes,\n                                         QSvgHandler *)\n{\n    const QStringView hax = attributes.value(QLatin1String(\"horiz-adv-x\"));\n    QString myId     = someId(attributes);\n\n    qreal horizAdvX = toDouble(hax);\n\n    while (parent && parent->type() != QSvgNode::DOC) {\n        parent = parent->parent();\n    }\n\n    if (parent && !myId.isEmpty()) {\n        QSvgTinyDocument *doc = static_cast<QSvgTinyDocument*>(parent);\n        QSvgFont *font = doc->svgFont(myId);\n        if (!font) {\n            font = new QSvgFont(horizAdvX);\n            font->setFamilyName(myId);\n            doc->addSvgFont(font);\n        }\n        return new QSvgFontStyle(font, doc);\n    }\n    return nullptr;\n}\n\nstatic bool parseFontFaceNode(QSvgStyleProperty *parent,\n                              const QXmlStreamAttributes &attributes,\n                              QSvgHandler *)\n{\n    if (parent->type() != QSvgStyleProperty::FONT) {\n        return false;\n    }\n\n    QSvgFontStyle *style = static_cast<QSvgFontStyle*>(parent);\n    QSvgFont *font = style->svgFont();\n    QString name   = attributes.value(QLatin1String(\"font-family\")).toString();\n    const QStringView unitsPerEmStr = attributes.value(QLatin1String(\"units-per-em\"));\n\n    qreal unitsPerEm = toDouble(unitsPerEmStr);\n    if (!unitsPerEm)\n        unitsPerEm = 1000;\n\n    if (!name.isEmpty())\n        font->setFamilyName(name);\n    font->setUnitsPerEm(unitsPerEm);\n\n    if (!font->familyName().isEmpty())\n        if (!style->doc()->svgFont(font->familyName()))\n            style->doc()->addSvgFont(font);\n\n    return true;\n}\n\nstatic bool parseFontFaceNameNode(QSvgStyleProperty *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *)\n{\n    if (parent->type() != QSvgStyleProperty::FONT) {\n        return false;\n    }\n\n    QSvgFontStyle *style = static_cast<QSvgFontStyle*>(parent);\n    QSvgFont *font = style->svgFont();\n    QString name   = attributes.value(QLatin1String(\"name\")).toString();\n\n    if (!name.isEmpty())\n        font->setFamilyName(name);\n\n    if (!font->familyName().isEmpty())\n        if (!style->doc()->svgFont(font->familyName()))\n            style->doc()->addSvgFont(font);\n\n    return true;\n}\n\nstatic bool parseFontFaceSrcNode(QSvgStyleProperty *parent,\n                                 const QXmlStreamAttributes &attributes,\n                                 QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseFontFaceUriNode(QSvgStyleProperty *parent,\n                                 const QXmlStreamAttributes &attributes,\n                                 QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseForeignObjectNode(QSvgNode *parent,\n                                   const QXmlStreamAttributes &attributes,\n                                   QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createGNode(QSvgNode *parent,\n                             const QXmlStreamAttributes &attributes,\n                             QSvgHandler *)\n{\n    Q_UNUSED(attributes);\n    QSvgG *node = new QSvgG(parent);\n    return node;\n}\n\nstatic bool parseGlyphNode(QSvgStyleProperty *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *)\n{\n    if (parent->type() != QSvgStyleProperty::FONT) {\n        return false;\n    }\n\n    QSvgFontStyle *style = static_cast<QSvgFontStyle*>(parent);\n    QSvgFont *font = style->svgFont();\n    createSvgGlyph(font, attributes);\n    return true;\n}\n\nstatic bool parseHandlerNode(QSvgNode *parent,\n                             const QXmlStreamAttributes &attributes,\n                             QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseHkernNode(QSvgNode *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createImageNode(QSvgNode *parent,\n                                 const QXmlStreamAttributes &attributes,\n                                 QSvgHandler *handler)\n{\n    const QStringView x = attributes.value(QLatin1String(\"x\"));\n    const QStringView y = attributes.value(QLatin1String(\"y\"));\n    const QStringView width  = attributes.value(QLatin1String(\"width\"));\n    const QStringView height = attributes.value(QLatin1String(\"height\"));\n    QString filename = attributes.value(QLatin1String(\"xlink:href\")).toString();\n    qreal nx = toDouble(x);\n    qreal ny = toDouble(y);\n    QSvgHandler::LengthType type;\n    qreal nwidth = parseLength(width.toString(), type, handler);\n    nwidth = convertToPixels(nwidth, true, type);\n\n    qreal nheight = parseLength(height.toString(), type, handler);\n    nheight = convertToPixels(nheight, false, type);\n\n    filename = filename.trimmed();\n    if (filename.isEmpty()) {\n        qCWarning(lcSvgHandler) << \"QSvgHandler: Image filename is empty\";\n        return 0;\n    }\n    if (nwidth <= 0 || nheight <= 0) {\n        qCWarning(lcSvgHandler) << \"QSvgHandler: Width or height for\" << filename << \"image was not greater than 0\";\n        return 0;\n    }\n\n    QImage image;\n    if (filename.startsWith(QLatin1String(\"data\"))) {\n        int idx = filename.lastIndexOf(QLatin1String(\"base64,\"));\n        if (idx != -1) {\n            idx += 7;\n            const QString dataStr = filename.mid(idx);\n            QByteArray data = QByteArray::fromBase64(dataStr.toLatin1());\n            image = QImage::fromData(data);\n        } else {\n            qCDebug(lcSvgHandler) << \"QSvgHandler::createImageNode: Unrecognized inline image format!\";\n        }\n    } else {\n        const auto *file = qobject_cast<QFile *>(handler->device());\n        if (file) {\n            QUrl url(filename);\n            if (url.isRelative()) {\n                QFileInfo info(file->fileName());\n                filename = info.absoluteDir().absoluteFilePath(filename);\n            }\n        }\n        image = QImage(filename);\n    }\n\n    if (image.isNull()) {\n        qCWarning(lcSvgHandler) << \"Could not create image from\" << filename;\n        return 0;\n    }\n\n    if (image.format() == QImage::Format_ARGB32)\n        image = image.convertToFormat(QImage::Format_ARGB32_Premultiplied);\n\n    QSvgNode *img = new QSvgImage(parent,\n                                  image,\n                                  QRectF(nx,\n                                         ny,\n                                         nwidth,\n                                         nheight));\n    return img;\n}\n\nstatic QSvgNode *createLineNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    const QStringView x1 = attributes.value(QLatin1String(\"x1\"));\n    const QStringView y1 = attributes.value(QLatin1String(\"y1\"));\n    const QStringView x2 = attributes.value(QLatin1String(\"x2\"));\n    const QStringView y2 = attributes.value(QLatin1String(\"y2\"));\n    qreal nx1 = toDouble(x1);\n    qreal ny1 = toDouble(y1);\n    qreal nx2 = toDouble(x2);\n    qreal ny2 = toDouble(y2);\n\n    QLineF lineBounds(nx1, ny1, nx2, ny2);\n    QSvgNode *line = new QSvgLine(parent, lineBounds);\n    return line;\n}\n\n\nstatic void parseBaseGradient(QSvgNode *node,\n                              const QXmlStreamAttributes &attributes,\n                              QSvgGradientStyle *gradProp,\n                              QSvgHandler *handler)\n{\n    QString link   = attributes.value(QLatin1String(\"xlink:href\")).toString();\n    QStringView trans  = attributes.value(QLatin1String(\"gradientTransform\"));\n    QString spread = attributes.value(QLatin1String(\"spreadMethod\")).toString();\n    QString units = attributes.value(QLatin1String(\"gradientUnits\")).toString();\n    QStringView colorStr = attributes.value(QLatin1String(\"color\"));\n    QStringView colorOpacityStr = attributes.value(QLatin1String(\"color-opacity\"));\n\n    QColor color;\n    if (constructColor(colorStr, colorOpacityStr, color, handler)) {\n        handler->popColor();\n        handler->pushColor(color);\n    }\n\n    QTransform matrix;\n    QGradient *grad = gradProp->qgradient();\n    if (!link.isEmpty()) {\n        QSvgStyleProperty *prop = node->styleProperty(link);\n        //qDebug()<<\"inherited \"<<prop<<\" (\"<<link<<\")\";\n        if (prop && prop->type() == QSvgStyleProperty::GRADIENT) {\n            QSvgGradientStyle *inherited =\n                static_cast<QSvgGradientStyle*>(prop);\n            if (!inherited->stopLink().isEmpty()) {\n                gradProp->setStopLink(inherited->stopLink(), handler->document());\n            } else {\n                grad->setStops(inherited->qgradient()->stops());\n                gradProp->setGradientStopsSet(inherited->gradientStopsSet());\n            }\n\n            matrix = inherited->qtransform();\n        } else {\n            gradProp->setStopLink(link, handler->document());\n        }\n    }\n\n    if (!trans.isEmpty()) {\n        matrix = parseTransformationMatrix(trans);\n        gradProp->setTransform(matrix);\n    } else if (!matrix.isIdentity()) {\n        gradProp->setTransform(matrix);\n    }\n\n    if (!spread.isEmpty()) {\n        if (spread == QLatin1String(\"pad\")) {\n            grad->setSpread(QGradient::PadSpread);\n        } else if (spread == QLatin1String(\"reflect\")) {\n            grad->setSpread(QGradient::ReflectSpread);\n        } else if (spread == QLatin1String(\"repeat\")) {\n            grad->setSpread(QGradient::RepeatSpread);\n        }\n    }\n\n    if (units.isEmpty() || units == QLatin1String(\"objectBoundingBox\")) {\n         grad->setCoordinateMode(QGradient::ObjectMode);\n    }\n}\n\nstatic QSvgStyleProperty *createLinearGradientNode(QSvgNode *node,\n                                                   const QXmlStreamAttributes &attributes,\n                                                   QSvgHandler *handler)\n{\n    const QStringView x1 = attributes.value(QLatin1String(\"x1\"));\n    const QStringView y1 = attributes.value(QLatin1String(\"y1\"));\n    const QStringView x2 = attributes.value(QLatin1String(\"x2\"));\n    const QStringView y2 = attributes.value(QLatin1String(\"y2\"));\n\n    qreal nx1 = 0.0;\n    qreal ny1 = 0.0;\n    qreal nx2 = 1.0;\n    qreal ny2 = 0.0;\n\n    if (!x1.isEmpty())\n        nx1 =  convertToNumber(x1, handler);\n    if (!y1.isEmpty())\n        ny1 =  convertToNumber(y1, handler);\n    if (!x2.isEmpty())\n        nx2 =  convertToNumber(x2, handler);\n    if (!y2.isEmpty())\n        ny2 =  convertToNumber(y2, handler);\n\n    QSvgNode *itr = node;\n    while (itr && itr->type() != QSvgNode::DOC) {\n        itr = itr->parent();\n    }\n\n    QLinearGradient *grad = new QLinearGradient(nx1, ny1, nx2, ny2);\n    grad->setInterpolationMode(QGradient::ComponentInterpolation);\n    QSvgGradientStyle *prop = new QSvgGradientStyle(grad);\n    parseBaseGradient(node, attributes, prop, handler);\n\n    return prop;\n}\n\nstatic bool parseMetadataNode(QSvgNode *parent,\n                              const QXmlStreamAttributes &attributes,\n                              QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseMissingGlyphNode(QSvgStyleProperty *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *)\n{\n    if (parent->type() != QSvgStyleProperty::FONT) {\n        return false;\n    }\n\n    QSvgFontStyle *style = static_cast<QSvgFontStyle*>(parent);\n    QSvgFont *font = style->svgFont();\n    createSvgGlyph(font, attributes);\n    return true;\n}\n\nstatic bool parseMpathNode(QSvgNode *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringView data = attributes.value(QLatin1String(\"d\"));\n\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    if (!parsePathDataFast(data, qpath))\n        qCWarning(lcSvgHandler, \"Invalid path data; path truncated.\");\n\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}\n\nstatic QSvgNode *createPolygonNode(QSvgNode *parent,\n                                   const QXmlStreamAttributes &attributes,\n                                   QSvgHandler *)\n{\n    QString pointsStr  = attributes.value(QLatin1String(\"points\")).toString();\n\n    //same QPolygon parsing is in createPolylineNode\n    const QChar *s = pointsStr.constData();\n    QList<qreal> points = parseNumbersList(s);\n    QPolygonF poly(points.count()/2);\n    for (int i = 0; i < poly.size(); ++i)\n        poly[i] = QPointF(points.at(2 * i), points.at(2 * i + 1));\n    QSvgNode *polygon = new QSvgPolygon(parent, poly);\n    return polygon;\n}\n\nstatic QSvgNode *createPolylineNode(QSvgNode *parent,\n                                    const QXmlStreamAttributes &attributes,\n                                    QSvgHandler *)\n{\n    QString pointsStr  = attributes.value(QLatin1String(\"points\")).toString();\n\n    //same QPolygon parsing is in createPolygonNode\n    const QChar *s = pointsStr.constData();\n    QList<qreal> points = parseNumbersList(s);\n    QPolygonF poly(points.count()/2);\n    for (int i = 0; i < poly.size(); ++i)\n        poly[i] = QPointF(points.at(2 * i), points.at(2 * i + 1));\n\n    QSvgNode *line = new QSvgPolyline(parent, poly);\n    return line;\n}\n\nstatic bool parsePrefetchNode(QSvgNode *parent,\n                              const QXmlStreamAttributes &attributes,\n                              QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgStyleProperty *createRadialGradientNode(QSvgNode *node,\n                                                   const QXmlStreamAttributes &attributes,\n                                                   QSvgHandler *handler)\n{\n    const QStringView cx = attributes.value(QLatin1String(\"cx\"));\n    const QStringView cy = attributes.value(QLatin1String(\"cy\"));\n    const QStringView r  = attributes.value(QLatin1String(\"r\"));\n    const QStringView fx = attributes.value(QLatin1String(\"fx\"));\n    const QStringView fy = attributes.value(QLatin1String(\"fy\"));\n\n    qreal ncx = 0.5;\n    qreal ncy = 0.5;\n    if (!cx.isEmpty())\n        ncx = toDouble(cx);\n    if (!cy.isEmpty())\n        ncy = toDouble(cy);\n\n    qreal nr = 0.0;\n    if (!r.isEmpty())\n        nr = toDouble(r);\n    if (nr <= 0.0)\n        return nullptr;\n\n    qreal nfx = ncx;\n    if (!fx.isEmpty())\n        nfx = toDouble(fx);\n    qreal nfy = ncy;\n    if (!fy.isEmpty())\n        nfy = toDouble(fy);\n\n    QRadialGradient *grad = new QRadialGradient(ncx, ncy, nr, nfx, nfy, 0);\n    grad->setInterpolationMode(QGradient::ComponentInterpolation);\n\n    QSvgGradientStyle *prop = new QSvgGradientStyle(grad);\n    parseBaseGradient(node, attributes, prop, handler);\n\n    return prop;\n}\n\nstatic QSvgNode *createRectNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *handler)\n{\n    const QStringView x      = attributes.value(QLatin1String(\"x\"));\n    const QStringView y      = attributes.value(QLatin1String(\"y\"));\n    const QStringView width  = attributes.value(QLatin1String(\"width\"));\n    const QStringView height = attributes.value(QLatin1String(\"height\"));\n    const QStringView rx      = attributes.value(QLatin1String(\"rx\"));\n    const QStringView ry      = attributes.value(QLatin1String(\"ry\"));\n\n    bool ok = true;\n    QSvgHandler::LengthType type;\n    qreal nwidth = parseLength(width.toString(), type, handler, &ok);\n    if (!ok)\n        return nullptr;\n    nwidth = convertToPixels(nwidth, true, type);\n    qreal nheight = parseLength(height.toString(), type, handler, &ok);\n    if (!ok)\n        return nullptr;\n    nheight = convertToPixels(nheight, true, type);\n    qreal nrx = toDouble(rx);\n    qreal nry = toDouble(ry);\n\n    QRectF bounds(toDouble(x), toDouble(y), nwidth, nheight);\n    if (bounds.isEmpty())\n        return nullptr;\n\n    if (!rx.isEmpty() && ry.isEmpty())\n        nry = nrx;\n    else if (!ry.isEmpty() && rx.isEmpty())\n        nrx = nry;\n\n    //9.2 The 'rect'  element clearly specifies it\n    // but the case might in fact be handled because\n    // we draw rounded rectangles differently\n    if (nrx > bounds.width()/2)\n        nrx = bounds.width()/2;\n    if (nry > bounds.height()/2)\n        nry = bounds.height()/2;\n\n    //we draw rounded rect from 0...99\n    //svg from 0...bounds.width()/2 so we're adjusting the\n    //coordinates\n    nrx *= (100/(bounds.width()/2));\n    nry *= (100/(bounds.height()/2));\n\n    QSvgNode *rect = new QSvgRect(parent, bounds,\n                                  int(nrx),\n                                  int(nry));\n    return rect;\n}\n\nstatic bool parseScriptNode(QSvgNode *parent,\n                            const QXmlStreamAttributes &attributes,\n                            QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic bool parseSetNode(QSvgNode *parent,\n                         const QXmlStreamAttributes &attributes,\n                         QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgStyleProperty *createSolidColorNode(QSvgNode *parent,\n                                               const QXmlStreamAttributes &attributes,\n                                               QSvgHandler *handler)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    QStringView solidColorStr = attributes.value(QLatin1String(\"solid-color\"));\n    QStringView solidOpacityStr = attributes.value(QLatin1String(\"solid-opacity\"));\n\n    if (solidOpacityStr.isEmpty())\n        solidOpacityStr = attributes.value(QLatin1String(\"opacity\"));\n\n    QColor color;\n    if (!constructColor(solidColorStr, solidOpacityStr, color, handler))\n        return 0;\n    QSvgSolidColorStyle *style = new QSvgSolidColorStyle(color);\n    return style;\n}\n\nstatic bool parseStopNode(QSvgStyleProperty *parent,\n                          const QXmlStreamAttributes &attributes,\n                          QSvgHandler *handler)\n{\n    if (parent->type() != QSvgStyleProperty::GRADIENT)\n        return false;\n    QString nodeIdStr     = someId(attributes);\n    QString xmlClassStr   = attributes.value(QLatin1String(\"class\")).toString();\n\n    //### nasty hack because stop gradients are not in the rendering tree\n    //    we force a dummy node with the same id and class into a rendering\n    //    tree to figure out whether the selector has a style for it\n    //    QSvgStyleSelector should be coded in a way that could avoid it\n    QSvgAnimation anim;\n    anim.setNodeId(nodeIdStr);\n    anim.setXmlClass(xmlClassStr);\n\n    QXmlStreamAttributes xmlAttr = attributes;\n\n#ifndef QT_NO_CSSPARSER\n    QCss::StyleSelector::NodePtr cssNode;\n    cssNode.ptr = &anim;\n    QList<QCss::Declaration> decls = handler->selector()->declarationsForNode(cssNode);\n\n    for (int i = 0; i < decls.count(); ++i) {\n        const QCss::Declaration &decl = decls.at(i);\n\n        if (decl.d->property.isEmpty())\n            continue;\n        if (decl.d->values.count() != 1)\n            continue;\n        QCss::Value val = decl.d->values.first();\n        QString valueStr = val.toString();\n        if (val.type == QCss::Value::Uri) {\n            valueStr.prepend(QLatin1String(\"url(\"));\n            valueStr.append(QLatin1Char(')'));\n        }\n        xmlAttr.append(QString(), decl.d->property, valueStr);\n    }\n\n#endif\n\n    QSvgAttributes attrs(xmlAttr, handler);\n\n    QSvgGradientStyle *style =\n        static_cast<QSvgGradientStyle*>(parent);\n    QStringView colorStr    = attrs.stopColor;\n    QColor color;\n\n    bool ok = true;\n    qreal offset = convertToNumber(attrs.offset, handler, &ok);\n    if (!ok)\n        offset = 0.0;\n    QString black = QString::fromLatin1(\"#000000\");\n    if (colorStr.isEmpty()) {\n        colorStr = black;\n    }\n\n    constructColor(colorStr, attrs.stopOpacity, color, handler);\n\n    QGradient *grad = style->qgradient();\n\n    offset = qMin(qreal(1), qMax(qreal(0), offset)); // Clamp to range [0, 1]\n    QGradientStops stops;\n    if (style->gradientStopsSet()) {\n        stops = grad->stops();\n        // If the stop offset equals the one previously added, add an epsilon to make it greater.\n        if (offset <= stops.back().first)\n            offset = stops.back().first + FLT_EPSILON;\n    }\n\n    // If offset is greater than one, it must be clamped to one.\n    if (offset > 1.0) {\n        if ((stops.size() == 1) || (stops.at(stops.size() - 2).first < 1.0 - FLT_EPSILON)) {\n            stops.back().first = 1.0 - FLT_EPSILON;\n            grad->setStops(stops);\n        }\n        offset = 1.0;\n    }\n\n    grad->setColorAt(offset, color);\n    style->setGradientStopsSet(true);\n    return true;\n}\n\nstatic bool parseStyleNode(QSvgNode *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *handler)\n{\n    Q_UNUSED(parent);\n#ifdef QT_NO_CSSPARSER\n    Q_UNUSED(attributes);\n    Q_UNUSED(handler);\n#else\n    const QStringView type = attributes.value(QLatin1String(\"type\"));\n    if (type.compare(QLatin1String(\"text/css\"), Qt::CaseInsensitive) == 0 || type.isNull())\n        handler->setInStyle(true);\n#endif\n\n    return true;\n}\n\nstatic QSvgNode *createSvgNode(QSvgNode *parent,\n                               const QXmlStreamAttributes &attributes,\n                               QSvgHandler *handler)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n\n    QSvgTinyDocument *node = new QSvgTinyDocument();\n    const QStringView widthStr  = attributes.value(QLatin1String(\"width\"));\n    const QStringView heightStr = attributes.value(QLatin1String(\"height\"));\n    QString viewBoxStr = attributes.value(QLatin1String(\"viewBox\")).toString();\n\n    QSvgHandler::LengthType type = QSvgHandler::LT_PX; // FIXME: is the default correct?\n    qreal width = 0;\n    if (!widthStr.isEmpty()) {\n        width = parseLength(widthStr.toString(), type, handler);\n        if (type != QSvgHandler::LT_PT)\n            width = convertToPixels(width, true, type);\n        node->setWidth(int(width), type == QSvgHandler::LT_PERCENT);\n    }\n    qreal height = 0;\n    if (!heightStr.isEmpty()) {\n        height = parseLength(heightStr.toString(), type, handler);\n        if (type != QSvgHandler::LT_PT)\n            height = convertToPixels(height, false, type);\n        node->setHeight(int(height), type == QSvgHandler::LT_PERCENT);\n    }\n\n    QStringList viewBoxValues;\n    if (!viewBoxStr.isEmpty()) {\n        viewBoxStr = viewBoxStr.replace(QLatin1Char(' '), QLatin1Char(','));\n        viewBoxStr = viewBoxStr.replace(QLatin1Char('\\r'), QLatin1Char(','));\n        viewBoxStr = viewBoxStr.replace(QLatin1Char('\\n'), QLatin1Char(','));\n        viewBoxStr = viewBoxStr.replace(QLatin1Char('\\t'), QLatin1Char(','));\n        viewBoxValues = viewBoxStr.split(QLatin1Char(','), Qt::SkipEmptyParts);\n    }\n    if (viewBoxValues.count() == 4) {\n        QString xStr      = viewBoxValues.at(0).trimmed();\n        QString yStr      = viewBoxValues.at(1).trimmed();\n        QString widthStr  = viewBoxValues.at(2).trimmed();\n        QString heightStr = viewBoxValues.at(3).trimmed();\n\n        QSvgHandler::LengthType lt;\n        qreal x = parseLength(xStr, lt, handler);\n        qreal y = parseLength(yStr, lt, handler);\n        qreal w = parseLength(widthStr, lt, handler);\n        qreal h = parseLength(heightStr, lt, handler);\n\n        node->setViewBox(QRectF(x, y, w, h));\n\n    } else if (width && height) {\n        if (type == QSvgHandler::LT_PT) {\n            width = convertToPixels(width, false, type);\n            height = convertToPixels(height, false, type);\n        }\n        node->setViewBox(QRectF(0, 0, width, height));\n    }\n    handler->setDefaultCoordinateSystem(QSvgHandler::LT_PX);\n\n    return node;\n}\n\nstatic QSvgNode *createSwitchNode(QSvgNode *parent,\n                                  const QXmlStreamAttributes &attributes,\n                                  QSvgHandler *)\n{\n    Q_UNUSED(attributes);\n    QSvgSwitch *node = new QSvgSwitch(parent);\n    return node;\n}\n\nstatic bool parseTbreakNode(QSvgNode *parent,\n                            const QXmlStreamAttributes &,\n                            QSvgHandler *)\n{\n    if (parent->type() != QSvgNode::TEXTAREA)\n        return false;\n    static_cast<QSvgText*>(parent)->addLineBreak();\n    return true;\n}\n\nstatic QSvgNode *createTextNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *handler)\n{\n    const QStringView x = attributes.value(QLatin1String(\"x\"));\n    const QStringView y = attributes.value(QLatin1String(\"y\"));\n    //### editable and rotate not handled\n    QSvgHandler::LengthType type;\n    qreal nx = parseLength(x.toString(), type, handler);\n    nx = convertToPixels(nx, true, type);\n    qreal ny = parseLength(y.toString(), type, handler);\n    ny = convertToPixels(ny, true, type);\n\n    QSvgNode *text = new QSvgText(parent, QPointF(nx, ny));\n    return text;\n}\n\nstatic QSvgNode *createTextAreaNode(QSvgNode *parent,\n                                    const QXmlStreamAttributes &attributes,\n                                    QSvgHandler *handler)\n{\n    QSvgText *node = static_cast<QSvgText *>(createTextNode(parent, attributes, handler));\n    if (node) {\n        QSvgHandler::LengthType type;\n        qreal width = parseLength(attributes.value(QLatin1String(\"width\")), type, handler);\n        qreal height = parseLength(attributes.value(QLatin1String(\"height\")), type, handler);\n        node->setTextArea(QSizeF(width, height));\n    }\n    return node;\n}\n\nstatic QSvgNode *createTspanNode(QSvgNode *parent,\n                                    const QXmlStreamAttributes &,\n                                    QSvgHandler *)\n{\n    return new QSvgTspan(parent);\n}\n\nstatic bool parseTitleNode(QSvgNode *parent,\n                           const QXmlStreamAttributes &attributes,\n                           QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return true;\n}\n\nstatic QSvgNode *createUseNode(QSvgNode *parent,\n                               const QXmlStreamAttributes &attributes,\n                               QSvgHandler *handler)\n{\n    QString linkId = attributes.value(QLatin1String(\"xlink:href\")).toString().remove(0, 1);\n    const QStringView xStr = attributes.value(QLatin1String(\"x\"));\n    const QStringView yStr = attributes.value(QLatin1String(\"y\"));\n    QSvgStructureNode *group = nullptr;\n\n    if (linkId.isEmpty())\n        linkId = attributes.value(QLatin1String(\"href\")).toString().remove(0, 1);\n    switch (parent->type()) {\n    case QSvgNode::DOC:\n    case QSvgNode::DEFS:\n    case QSvgNode::G:\n    case QSvgNode::SWITCH:\n        group = static_cast<QSvgStructureNode*>(parent);\n        break;\n    default:\n        break;\n    }\n\n    if (group) {\n        QPointF pt;\n        if (!xStr.isNull() || !yStr.isNull()) {\n            QSvgHandler::LengthType type;\n            qreal nx = parseLength(xStr.toString(), type, handler);\n            nx = convertToPixels(nx, true, type);\n\n            qreal ny = parseLength(yStr.toString(), type, handler);\n            ny = convertToPixels(ny, true, type);\n            pt = QPointF(nx, ny);\n        }\n\n        QSvgNode *link = group->scopeNode(linkId);\n        if (link) {\n            if (parent->isDescendantOf(link))\n                qCWarning(lcSvgHandler, \"link #%s is recursive!\", qPrintable(linkId));\n\n            return new QSvgUse(pt, parent, link);\n        }\n\n        //delay link resolving, link might have not been created yet\n        return new QSvgUse(pt, parent, linkId);\n    }\n\n    qCWarning(lcSvgHandler, \"<use> element %s in wrong context!\", qPrintable(linkId));\n    return 0;\n}\n\nstatic QSvgNode *createVideoNode(QSvgNode *parent,\n                                 const QXmlStreamAttributes &attributes,\n                                 QSvgHandler *)\n{\n    Q_UNUSED(parent); Q_UNUSED(attributes);\n    return 0;\n}\n\ntypedef QSvgNode *(*FactoryMethod)(QSvgNode *, const QXmlStreamAttributes &, QSvgHandler *);\n\nstatic FactoryMethod findGroupFactory(const QString &name)\n{\n    if (name.isEmpty())\n        return 0;\n\n    QStringView ref = QStringView{name}.mid(1, name.length() - 1);\n    switch (name.at(0).unicode()) {\n    case 'd':\n        if (ref == QLatin1String(\"efs\")) return createDefsNode;\n        break;\n    case 'g':\n        if (ref.isEmpty()) return createGNode;\n        break;\n    case 's':\n        if (ref == QLatin1String(\"vg\")) return createSvgNode;\n        if (ref == QLatin1String(\"witch\")) return createSwitchNode;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\nstatic FactoryMethod findGraphicsFactory(const QString &name)\n{\n    if (name.isEmpty())\n        return 0;\n\n    QStringView ref = QStringView{name}.mid(1, name.length() - 1);\n    switch (name.at(0).unicode()) {\n    case 'a':\n        if (ref == QLatin1String(\"nimation\")) return createAnimationNode;\n        break;\n    case 'c':\n        if (ref == QLatin1String(\"ircle\")) return createCircleNode;\n        break;\n    case 'e':\n        if (ref == QLatin1String(\"llipse\")) return createEllipseNode;\n        break;\n    case 'i':\n        if (ref == QLatin1String(\"mage\")) return createImageNode;\n        break;\n    case 'l':\n        if (ref == QLatin1String(\"ine\")) return createLineNode;\n        break;\n    case 'p':\n        if (ref == QLatin1String(\"ath\")) return createPathNode;\n        if (ref == QLatin1String(\"olygon\")) return createPolygonNode;\n        if (ref == QLatin1String(\"olyline\")) return createPolylineNode;\n        break;\n    case 'r':\n        if (ref == QLatin1String(\"ect\")) return createRectNode;\n        break;\n    case 't':\n        if (ref == QLatin1String(\"ext\")) return createTextNode;\n        if (ref == QLatin1String(\"extArea\")) return createTextAreaNode;\n        if (ref == QLatin1String(\"span\")) return createTspanNode;\n        break;\n    case 'u':\n        if (ref == QLatin1String(\"se\")) return createUseNode;\n        break;\n    case 'v':\n        if (ref == QLatin1String(\"ideo\")) return createVideoNode;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\ntypedef bool (*ParseMethod)(QSvgNode *, const QXmlStreamAttributes &, QSvgHandler *);\n\nstatic ParseMethod findUtilFactory(const QString &name)\n{\n    if (name.isEmpty())\n        return 0;\n\n    QStringView ref = QStringView{name}.mid(1, name.length() - 1);\n    switch (name.at(0).unicode()) {\n    case 'a':\n        if (ref.isEmpty()) return parseAnchorNode;\n        if (ref == QLatin1String(\"nimate\")) return parseAnimateNode;\n        if (ref == QLatin1String(\"nimateColor\")) return parseAnimateColorNode;\n        if (ref == QLatin1String(\"nimateMotion\")) return parseAimateMotionNode;\n        if (ref == QLatin1String(\"nimateTransform\")) return parseAnimateTransformNode;\n        if (ref == QLatin1String(\"udio\")) return parseAudioNode;\n        break;\n    case 'd':\n        if (ref == QLatin1String(\"esc\")) return parseDescNode;\n        if (ref == QLatin1String(\"iscard\")) return parseDiscardNode;\n        break;\n    case 'f':\n        if (ref == QLatin1String(\"oreignObject\")) return parseForeignObjectNode;\n        break;\n    case 'h':\n        if (ref == QLatin1String(\"andler\")) return parseHandlerNode;\n        if (ref == QLatin1String(\"kern\")) return parseHkernNode;\n        break;\n    case 'm':\n        if (ref == QLatin1String(\"etadata\")) return parseMetadataNode;\n        if (ref == QLatin1String(\"path\")) return parseMpathNode;\n        break;\n    case 'p':\n        if (ref == QLatin1String(\"refetch\")) return parsePrefetchNode;\n        break;\n    case 's':\n        if (ref == QLatin1String(\"cript\")) return parseScriptNode;\n        if (ref == QLatin1String(\"et\")) return parseSetNode;\n        if (ref == QLatin1String(\"tyle\")) return parseStyleNode;\n        break;\n    case 't':\n        if (ref == QLatin1String(\"break\")) return parseTbreakNode;\n        if (ref == QLatin1String(\"itle\")) return parseTitleNode;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\ntypedef QSvgStyleProperty *(*StyleFactoryMethod)(QSvgNode *,\n                                                 const QXmlStreamAttributes &,\n                                                 QSvgHandler *);\n\nstatic StyleFactoryMethod findStyleFactoryMethod(const QString &name)\n{\n    if (name.isEmpty())\n        return 0;\n\n    QStringView ref = QStringView{name}.mid(1, name.length() - 1);\n    switch (name.at(0).unicode()) {\n    case 'f':\n        if (ref == QLatin1String(\"ont\")) return createFontNode;\n        break;\n    case 'l':\n        if (ref == QLatin1String(\"inearGradient\")) return createLinearGradientNode;\n        break;\n    case 'r':\n        if (ref == QLatin1String(\"adialGradient\")) return createRadialGradientNode;\n        break;\n    case 's':\n        if (ref == QLatin1String(\"olidColor\")) return createSolidColorNode;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\ntypedef bool (*StyleParseMethod)(QSvgStyleProperty *,\n                                 const QXmlStreamAttributes &,\n                                 QSvgHandler *);\n\nstatic StyleParseMethod findStyleUtilFactoryMethod(const QString &name)\n{\n    if (name.isEmpty())\n        return 0;\n\n    QStringView ref = QStringView{name}.mid(1, name.length() - 1);\n    switch (name.at(0).unicode()) {\n    case 'f':\n        if (ref == QLatin1String(\"ont-face\")) return parseFontFaceNode;\n        if (ref == QLatin1String(\"ont-face-name\")) return parseFontFaceNameNode;\n        if (ref == QLatin1String(\"ont-face-src\")) return parseFontFaceSrcNode;\n        if (ref == QLatin1String(\"ont-face-uri\")) return parseFontFaceUriNode;\n        break;\n    case 'g':\n        if (ref == QLatin1String(\"lyph\")) return parseGlyphNode;\n        break;\n    case 'm':\n        if (ref == QLatin1String(\"issing-glyph\")) return parseMissingGlyphNode;\n        break;\n    case 's':\n        if (ref == QLatin1String(\"top\")) return parseStopNode;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\nQSvgHandler::QSvgHandler(QIODevice *device) : xml(new QXmlStreamReader(device))\n                                             , m_ownsReader(true)\n{\n    init();\n}\n\nQSvgHandler::QSvgHandler(const QByteArray &data) : xml(new QXmlStreamReader(data))\n                                                 , m_ownsReader(true)\n{\n    init();\n}\n\nQSvgHandler::QSvgHandler(QXmlStreamReader *const reader) : xml(reader)\n                                                         , m_ownsReader(false)\n{\n    init();\n}\n\nvoid QSvgHandler::init()\n{\n    m_doc = 0;\n    m_style = 0;\n    m_animEnd = 0;\n    m_defaultCoords = LT_PX;\n    m_defaultPen = QPen(Qt::black, 1, Qt::SolidLine, Qt::FlatCap, Qt::SvgMiterJoin);\n    m_defaultPen.setMiterLimit(4);\n    parse();\n}\n\n// Having too many unfinished elements will cause a stack overflow\n// in the dtor of QSvgTinyDocument, see oss-fuzz issue 24000.\nstatic const int unfinishedElementsLimit = 2048;\n\nvoid QSvgHandler::parse()\n{\n    xml->setNamespaceProcessing(false);\n#ifndef QT_NO_CSSPARSER\n    m_selector = new QSvgStyleSelector;\n    m_inStyle = false;\n#endif\n    bool done = false;\n    int remainingUnfinishedElements = unfinishedElementsLimit;\n    while (!xml->atEnd() && !done) {\n        switch (xml->readNext()) {\n        case QXmlStreamReader::StartElement:\n            // he we could/should verify the namespaces, and simply\n            // call m_skipNodes(Unknown) if we don't know the\n            // namespace.  We do support http://www.w3.org/2000/svg\n            // but also http://www.w3.org/2000/svg-20000303-stylable\n            // And if the document uses an external dtd, the reported\n            // namespaceUri is empty. The only possible strategy at\n            // this point is to do what everyone else seems to do and\n            // ignore the reported namespaceUri completely.\n            if (remainingUnfinishedElements\n                    && startElement(xml->name().toString(), xml->attributes())) {\n                --remainingUnfinishedElements;\n            } else {\n                delete m_doc;\n                m_doc = 0;\n                return;\n            }\n            break;\n        case QXmlStreamReader::EndElement:\n            endElement(xml->name());\n            ++remainingUnfinishedElements;\n            // if we are using somebody else's qxmlstreamreader\n            // we should not read until the end of the stream\n            done = !m_ownsReader && (xml->name() == QLatin1String(\"svg\"));\n            break;\n        case QXmlStreamReader::Characters:\n            characters(xml->text());\n            break;\n        case QXmlStreamReader::ProcessingInstruction:\n            processingInstruction(xml->processingInstructionTarget().toString(), xml->processingInstructionData().toString());\n            break;\n        default:\n            break;\n        }\n    }\n    resolveGradients(m_doc);\n    resolveNodes();\n}\n\nbool QSvgHandler::startElement(const QString &localName,\n                               const QXmlStreamAttributes &attributes)\n{\n    QSvgNode *node = nullptr;\n\n    pushColorCopy();\n\n    /* The xml:space attribute may appear on any element. We do\n     * a lookup by the qualified name here, but this is namespace aware, since\n     * the XML namespace can only be bound to prefix \"xml.\" */\n    const QStringView xmlSpace(attributes.value(QLatin1String(\"xml:space\")));\n    if (xmlSpace.isNull()) {\n        // This element has no xml:space attribute.\n        m_whitespaceMode.push(m_whitespaceMode.isEmpty() ? QSvgText::Default : m_whitespaceMode.top());\n    } else if (xmlSpace == QLatin1String(\"preserve\")) {\n        m_whitespaceMode.push(QSvgText::Preserve);\n    } else if (xmlSpace == QLatin1String(\"default\")) {\n        m_whitespaceMode.push(QSvgText::Default);\n    } else {\n        const QByteArray msg = '\"' + xmlSpace.toString().toLocal8Bit()\n                               + \"\\\" is an invalid value for attribute xml:space. \"\n                                 \"Valid values are \\\"preserve\\\" and \\\"default\\\".\";\n        qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n        m_whitespaceMode.push(QSvgText::Default);\n    }\n\n    if (!m_doc && localName != QLatin1String(\"svg\"))\n        return false;\n\n    if (FactoryMethod method = findGroupFactory(localName)) {\n        //group\n        node = method(m_doc ? m_nodes.top() : 0, attributes, this);\n        Q_ASSERT(node);\n        if (!m_doc) {\n            Q_ASSERT(node->type() == QSvgNode::DOC);\n            m_doc = static_cast<QSvgTinyDocument*>(node);\n        } else {\n            switch (m_nodes.top()->type()) {\n            case QSvgNode::DOC:\n            case QSvgNode::G:\n            case QSvgNode::DEFS:\n            case QSvgNode::SWITCH:\n            {\n                QSvgStructureNode *group =\n                    static_cast<QSvgStructureNode*>(m_nodes.top());\n                group->addChild(node, someId(attributes));\n            }\n                break;\n            default:\n                const QByteArray msg = QByteArrayLiteral(\"Could not add child element to parent element because the types are incorrect.\");\n                qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n                delete node;\n                node = 0;\n                break;\n            }\n        }\n        if (node) {\n            parseCoreNode(node, attributes);\n#ifndef QT_NO_CSSPARSER\n            cssStyleLookup(node, this, m_selector);\n#endif\n            parseStyle(node, attributes, this);\n        }\n    } else if (FactoryMethod method = findGraphicsFactory(localName)) {\n        //rendering element\n        Q_ASSERT(!m_nodes.isEmpty());\n        node = method(m_nodes.top(), attributes, this);\n        if (node) {\n            switch (m_nodes.top()->type()) {\n            case QSvgNode::DOC:\n            case QSvgNode::G:\n            case QSvgNode::DEFS:\n            case QSvgNode::SWITCH:\n            {\n                if (node->type() == QSvgNode::TSPAN) {\n                    const QByteArray msg = QByteArrayLiteral(\"\\'tspan\\' element in wrong context.\");\n                    qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n                    delete node;\n                    node = 0;\n                    break;\n                }\n                QSvgStructureNode *group =\n                    static_cast<QSvgStructureNode*>(m_nodes.top());\n                group->addChild(node, someId(attributes));\n            }\n                break;\n            case QSvgNode::TEXT:\n            case QSvgNode::TEXTAREA:\n                if (node->type() == QSvgNode::TSPAN) {\n                    static_cast<QSvgText *>(m_nodes.top())->addTspan(static_cast<QSvgTspan *>(node));\n                } else {\n                    const QByteArray msg = QByteArrayLiteral(\"\\'text\\' or \\'textArea\\' element contains invalid element type.\");\n                    qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n                    delete node;\n                    node = 0;\n                }\n                break;\n            default:\n                const QByteArray msg = QByteArrayLiteral(\"Could not add child element to parent element because the types are incorrect.\");\n                qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n                delete node;\n                node = 0;\n                break;\n            }\n\n            if (node) {\n                parseCoreNode(node, attributes);\n#ifndef QT_NO_CSSPARSER\n                cssStyleLookup(node, this, m_selector);\n#endif\n                parseStyle(node, attributes, this);\n                if (node->type() == QSvgNode::TEXT || node->type() == QSvgNode::TEXTAREA) {\n                    static_cast<QSvgText *>(node)->setWhitespaceMode(m_whitespaceMode.top());\n                } else if (node->type() == QSvgNode::TSPAN) {\n                    static_cast<QSvgTspan *>(node)->setWhitespaceMode(m_whitespaceMode.top());\n                } else if (node->type() == QSvgNode::USE) {\n                    if (!static_cast<QSvgUse *>(node)->isResolved())\n                        m_resolveNodes.append(node);\n                }\n            }\n        }\n    } else if (ParseMethod method = findUtilFactory(localName)) {\n        Q_ASSERT(!m_nodes.isEmpty());\n        if (!method(m_nodes.top(), attributes, this))\n            qCWarning(lcSvgHandler, \"%s\", msgProblemParsing(localName, xml).constData());\n    } else if (StyleFactoryMethod method = findStyleFactoryMethod(localName)) {\n        QSvgStyleProperty *prop = method(m_nodes.top(), attributes, this);\n        if (prop) {\n            m_style = prop;\n            m_nodes.top()->appendStyleProperty(prop, someId(attributes));\n        } else {\n            const QByteArray msg = QByteArrayLiteral(\"Could not parse node: \") + localName.toLocal8Bit();\n            qCWarning(lcSvgHandler, \"%s\", prefixMessage(msg, xml).constData());\n        }\n    } else if (StyleParseMethod method = findStyleUtilFactoryMethod(localName)) {\n        if (m_style) {\n            if (!method(m_style, attributes, this))\n                qCWarning(lcSvgHandler, \"%s\", msgProblemParsing(localName, xml).constData());\n        }\n    } else {\n        //qCWarning(lcSvgHandler) <<\"Skipping unknown element!\"<<namespaceURI<<\"::\"<<localName;\n        m_skipNodes.push(Unknown);\n        return true;\n    }\n\n    if (node) {\n        m_nodes.push(node);\n        m_skipNodes.push(Graphics);\n    } else {\n        //qDebug()<<\"Skipping \"<<localName;\n        m_skipNodes.push(Style);\n    }\n    return true;\n}\n\nbool QSvgHandler::endElement(const QStringView localName)\n{\n    CurrentNode node = m_skipNodes.top();\n    m_skipNodes.pop();\n    m_whitespaceMode.pop();\n\n    popColor();\n\n    if (node == Unknown) {\n        return true;\n    }\n\n#ifdef QT_NO_CSSPARSER\n    Q_UNUSED(localName);\n#else\n    if (m_inStyle && localName == QLatin1String(\"style\"))\n        m_inStyle = false;\n#endif\n\n    if (node == Graphics)\n        m_nodes.pop();\n    else if (m_style && !m_skipNodes.isEmpty() && m_skipNodes.top() != Style)\n        m_style = 0;\n\n    return true;\n}\n\nvoid QSvgHandler::resolveGradients(QSvgNode *node, int nestedDepth)\n{\n    if (!node || (node->type() != QSvgNode::DOC && node->type() != QSvgNode::G\n        && node->type() != QSvgNode::DEFS && node->type() != QSvgNode::SWITCH)) {\n        return;\n    }\n\n    QSvgStructureNode *structureNode = static_cast<QSvgStructureNode *>(node);\n\n    const QList<QSvgNode *> ren = structureNode->renderers();\n    for (auto it = ren.begin(); it != ren.end(); ++it) {\n        QSvgFillStyle *fill = static_cast<QSvgFillStyle *>((*it)->styleProperty(QSvgStyleProperty::FILL));\n        if (fill && !fill->isGradientResolved()) {\n            QString id = fill->gradientId();\n            QSvgFillStyleProperty *style = structureNode->styleProperty(id);\n            if (style) {\n                fill->setFillStyle(style);\n            } else {\n                qCWarning(lcSvgHandler, \"%s\", msgCouldNotResolveProperty(id, xml).constData());\n                fill->setBrush(Qt::NoBrush);\n            }\n        }\n\n        QSvgStrokeStyle *stroke = static_cast<QSvgStrokeStyle *>((*it)->styleProperty(QSvgStyleProperty::STROKE));\n        if (stroke && !stroke->isGradientResolved()) {\n            QString id = stroke->gradientId();\n            QSvgFillStyleProperty *style = structureNode->styleProperty(id);\n            if (style) {\n                stroke->setStyle(style);\n            } else {\n                qCWarning(lcSvgHandler, \"%s\", msgCouldNotResolveProperty(id, xml).constData());\n                stroke->setStroke(Qt::NoBrush);\n            }\n        }\n\n        if (nestedDepth < 2048)\n            resolveGradients(*it, nestedDepth + 1);\n    }\n}\n\nvoid QSvgHandler::resolveNodes()\n{\n    for (QSvgNode *node : qAsConst(m_resolveNodes)) {\n        if (!node || !node->parent() || node->type() != QSvgNode::USE)\n            continue;\n        QSvgUse *useNode = static_cast<QSvgUse *>(node);\n        if (useNode->isResolved())\n            continue;\n        QSvgNode::Type t = useNode->parent()->type();\n        if (!(t == QSvgNode::DOC || t == QSvgNode::DEFS || t == QSvgNode::G || t == QSvgNode::SWITCH))\n            continue;\n\n        QSvgStructureNode *group = static_cast<QSvgStructureNode *>(useNode->parent());\n        QSvgNode *link = group->scopeNode(useNode->linkId());\n        if (!link) {\n            qCWarning(lcSvgHandler, \"link #%s is undefined!\", qPrintable(useNode->linkId()));\n            continue;\n        }\n\n        if (useNode->parent()->isDescendantOf(link))\n            qCWarning(lcSvgHandler, \"link #%s is recursive!\", qPrintable(useNode->linkId()));\n\n        useNode->setLink(link);\n    }\n    m_resolveNodes.clear();\n}\n\nbool QSvgHandler::characters(const QStringView str)\n{\n#ifndef QT_NO_CSSPARSER\n    if (m_inStyle) {\n        QString css = str.toString();\n        QCss::StyleSheet sheet;\n        QCss::Parser(css).parse(&sheet);\n        m_selector->styleSheets.append(sheet);\n        return true;\n    }\n#endif\n    if (m_skipNodes.isEmpty() || m_skipNodes.top() == Unknown || m_nodes.isEmpty())\n        return true;\n\n    if (m_nodes.top()->type() == QSvgNode::TEXT || m_nodes.top()->type() == QSvgNode::TEXTAREA) {\n        static_cast<QSvgText*>(m_nodes.top())->addText(str.toString());\n    } else if (m_nodes.top()->type() == QSvgNode::TSPAN) {\n        static_cast<QSvgTspan*>(m_nodes.top())->addText(str.toString());\n    }\n\n    return true;\n}\n\nQIODevice *QSvgHandler::device() const\n{\n    return xml->device();\n}\n\nQSvgTinyDocument * QSvgHandler::document() const\n{\n    return m_doc;\n}\n\nQSvgHandler::LengthType QSvgHandler::defaultCoordinateSystem() const\n{\n    return m_defaultCoords;\n}\n\nvoid QSvgHandler::setDefaultCoordinateSystem(LengthType type)\n{\n    m_defaultCoords = type;\n}\n\nvoid QSvgHandler::pushColor(const QColor &color)\n{\n    m_colorStack.push(color);\n    m_colorTagCount.push(1);\n}\n\nvoid QSvgHandler::pushColorCopy()\n{\n    if (m_colorTagCount.count())\n        ++m_colorTagCount.top();\n    else\n        pushColor(Qt::black);\n}\n\nvoid QSvgHandler::popColor()\n{\n    if (m_colorTagCount.count()) {\n        if (!--m_colorTagCount.top()) {\n            m_colorStack.pop();\n            m_colorTagCount.pop();\n        }\n    }\n}\n\nQColor QSvgHandler::currentColor() const\n{\n    if (!m_colorStack.isEmpty())\n        return m_colorStack.top();\n    else\n        return QColor(0, 0, 0);\n}\n\n#ifndef QT_NO_CSSPARSER\n\nvoid QSvgHandler::setInStyle(bool b)\n{\n    m_inStyle = b;\n}\n\nbool QSvgHandler::inStyle() const\n{\n    return m_inStyle;\n}\n\nQSvgStyleSelector * QSvgHandler::selector() const\n{\n    return m_selector;\n}\n\n#endif // QT_NO_CSSPARSER\n\nbool QSvgHandler::processingInstruction(const QString &target, const QString &data)\n{\n#ifdef QT_NO_CSSPARSER\n    Q_UNUSED(target);\n    Q_UNUSED(data);\n#else\n    if (target == QLatin1String(\"xml-stylesheet\")) {\n        QRegularExpression rx(QLatin1String(\"type=\\\\\\\"(.+)\\\\\\\"\"),\n                              QRegularExpression::InvertedGreedinessOption);\n        QRegularExpressionMatchIterator iter = rx.globalMatch(data);\n        bool isCss = false;\n        while (iter.hasNext()) {\n            QRegularExpressionMatch match = iter.next();\n            QString type = match.captured(1);\n            if (type.toLower() == QLatin1String(\"text/css\")) {\n                isCss = true;\n            }\n        }\n\n        if (isCss) {\n            QRegularExpression rx(QLatin1String(\"href=\\\\\\\"(.+)\\\\\\\"\"),\n                                  QRegularExpression::InvertedGreedinessOption);\n            QRegularExpressionMatch match = rx.match(data);\n            QString addr = match.captured(1);\n            QFileInfo fi(addr);\n            //qDebug()<<\"External CSS file \"<<fi.absoluteFilePath()<<fi.exists();\n            if (fi.exists()) {\n                QFile file(fi.absoluteFilePath());\n                if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n                    return true;\n                }\n                QByteArray cssData = file.readAll();\n                QString css = QString::fromUtf8(cssData);\n\n                QCss::StyleSheet sheet;\n                QCss::Parser(css).parse(&sheet);\n                m_selector->styleSheets.append(sheet);\n            }\n\n        }\n    }\n#endif\n\n    return true;\n}\n\nvoid QSvgHandler::setAnimPeriod(int start, int end)\n{\n    Q_UNUSED(start);\n    m_animEnd   = qMax(end, m_animEnd);\n}\n\nint QSvgHandler::animationDuration() const\n{\n    return m_animEnd;\n}\n\nQSvgHandler::~QSvgHandler()\n{\n#ifndef QT_NO_CSSPARSER\n    delete m_selector;\n    m_selector = 0;\n#endif\n\n    if(m_ownsReader)\n        delete xml;\n}\n\nQT_END_NAMESPACE\n"], "filenames": ["src/svg/qsvghandler.cpp"], "buggy_code_start_loc": [1597], "buggy_code_end_loc": [2990], "fixing_code_start_loc": [1598], "fixing_code_end_loc": [2981], "type": "CWE-787", "message": "Qt SVG in Qt 5.0.0 through 5.15.2 and 6.0.0 through 6.2.1 has an out-of-bounds write in QtPrivate::QCommonArrayOps<QPainterPath::Element>::growAppend (called from QPainterPath::addPath and QPathClipper::intersect).", "other": {"cve": {"id": "CVE-2021-45930", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-01T01:15:08.420", "lastModified": "2022-02-10T14:52:17.643", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Qt SVG in Qt 5.0.0 through 5.15.2 and 6.0.0 through 6.2.1 has an out-of-bounds write in QtPrivate::QCommonArrayOps<QPainterPath::Element>::growAppend (called from QPainterPath::addPath and QPathClipper::intersect)."}, {"lang": "es", "value": "Qt SVG en Qt versiones 5.0.0 hasta 6.2.1, presenta una escritura fuera de l\u00edmites en la funci\u00f3n QtPrivate::QCommonArrayOps(QPainterPath::Element)::growAppend (llamada desde QPainterPath::addPath y QPathClipper::intersect).\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qt:qtsvg:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndIncluding": "5.15.2", "matchCriteriaId": "23718B27-5A94-439F-88A2-65A53C21C995"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qt:qtsvg:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndIncluding": "6.2.1", "matchCriteriaId": "745516F5-E281-411F-8DDC-F29E4ECE4531"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=37025", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=37306", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/qt/OSV-2021-1121.yaml", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/qt/qtsvg/commit/36cfd9efb9b22b891adee9c48d30202289cfa620", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qt/qtsvg/commit/79bb9f51fa374106a612d17c9d98d35d807be670", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qt/qtsvg/commit/a3b753c2d077313fc9eb93af547051b956e383fc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/01/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/01/msg00022.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4GKOKVCSDZSOWWR3HOW5XUIUJC4MKQY5/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GZIXNSX7FV733TWTTLY6FHSH3SCNQKKD/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/V75XNX4GDB64N5BSOAN474RUXXS5OHRU/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/qt/qtsvg/commit/36cfd9efb9b22b891adee9c48d30202289cfa620"}}