{"buggy_code": ["/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n#include \"xkbcomp-priv.h\"\n#include \"text.h\"\n#include \"expr.h\"\n\ntypedef bool (*IdentLookupFunc)(struct xkb_context *ctx, const void *priv,\n                                xkb_atom_t field, enum expr_value_type type,\n                                unsigned int *val_rtrn);\n\nbool\nExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}\n\nstatic bool\nSimpleLookup(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n             enum expr_value_type type, unsigned int *val_rtrn)\n{\n    const LookupEntry *entry;\n    const char *str;\n\n    if (!priv || field == XKB_ATOM_NONE || type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n    for (entry = priv; entry && entry->name; entry++) {\n        if (istreq(str, entry->name)) {\n            *val_rtrn = entry->value;\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/* Data passed in the *priv argument for LookupModMask. */\ntypedef struct {\n    const struct xkb_mod_set *mods;\n    enum mod_type mod_type;\n} LookupModMaskPriv;\n\nstatic bool\nLookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n\n    if (type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n\n    *val_rtrn = (1u << ndx);\n    return true;\n}\n\nbool\nExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_INVERT:\n    case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n        if (ok)\n            *set_rtrn = !*set_rtrn;\n        return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n\nbool\nExprResolveKeyCode(struct xkb_context *ctx, const ExprDef *expr,\n                   xkb_keycode_t *kc)\n{\n    xkb_keycode_t leftRtrn, rightRtrn;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_INT) {\n            log_err(ctx,\n                    \"Found constant of type %s where an int was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n\n        *kc = (xkb_keycode_t) expr->integer.ival;\n        return true;\n\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n        if (!ExprResolveKeyCode(ctx, expr->binary.left, &leftRtrn) ||\n            !ExprResolveKeyCode(ctx, expr->binary.right, &rightRtrn))\n            return false;\n\n        switch (expr->expr.op) {\n        case EXPR_ADD:\n            *kc = leftRtrn + rightRtrn;\n            break;\n        case EXPR_SUBTRACT:\n            *kc = leftRtrn - rightRtrn;\n            break;\n        case EXPR_MULTIPLY:\n            *kc = leftRtrn * rightRtrn;\n            break;\n        case EXPR_DIVIDE:\n            if (rightRtrn == 0) {\n                log_err(ctx, \"Cannot divide by zero: %d / %d\\n\",\n                        leftRtrn, rightRtrn);\n                return false;\n            }\n\n            *kc = leftRtrn / rightRtrn;\n            break;\n        default:\n            break;\n        }\n\n        return true;\n\n    case EXPR_NEGATE:\n        if (!ExprResolveKeyCode(ctx, expr->unary.child, &leftRtrn))\n            return false;\n\n        *kc = ~leftRtrn;\n        return true;\n\n    case EXPR_UNARY_PLUS:\n        return ExprResolveKeyCode(ctx, expr->unary.child, kc);\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveKeyCode\\n\",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n\n/**\n * This function returns ... something.  It's a bit of a guess, really.\n *\n * If an integer is given in value ctx, it will be returned in ival.\n * If an ident or field reference is given, the lookup function (if given)\n * will be called.  At the moment, only SimpleLookup use this, and they both\n * return the results in uval.  And don't support field references.\n *\n * Cool.\n */\nstatic bool\nExprResolveIntegerLookup(struct xkb_context *ctx, const ExprDef *expr,\n                         int *val_rtrn, IdentLookupFunc lookup,\n                         const void *lookupPriv)\n{\n    bool ok = false;\n    int l, r;\n    unsigned u;\n    ExprDef *left, *right;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_INT) {\n            log_err(ctx,\n                    \"Found constant of type %s where an int was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n\n        *val_rtrn = expr->integer.ival;\n        return true;\n\n    case EXPR_IDENT:\n        if (lookup)\n            ok = lookup(ctx, lookupPriv, expr->ident.ident, EXPR_TYPE_INT, &u);\n\n        if (!ok)\n            log_err(ctx, \"Identifier \\\"%s\\\" of type int is unknown\\n\",\n                    xkb_atom_text(ctx, expr->ident.ident));\n        else\n            *val_rtrn = (int) u;\n\n        return ok;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type int is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n        left = expr->binary.left;\n        right = expr->binary.right;\n        if (!ExprResolveIntegerLookup(ctx, left, &l, lookup, lookupPriv) ||\n            !ExprResolveIntegerLookup(ctx, right, &r, lookup, lookupPriv))\n            return false;\n\n        switch (expr->expr.op) {\n        case EXPR_ADD:\n            *val_rtrn = l + r;\n            break;\n        case EXPR_SUBTRACT:\n            *val_rtrn = l - r;\n            break;\n        case EXPR_MULTIPLY:\n            *val_rtrn = l * r;\n            break;\n        case EXPR_DIVIDE:\n            if (r == 0) {\n                log_err(ctx, \"Cannot divide by zero: %d / %d\\n\", l, r);\n                return false;\n            }\n            *val_rtrn = l / r;\n            break;\n        default:\n            log_err(ctx, \"%s of integers not permitted\\n\",\n                    expr_op_type_to_string(expr->expr.op));\n            return false;\n        }\n\n        return true;\n\n    case EXPR_ASSIGN:\n        log_wsgo(ctx, \"Assignment operator not implemented yet\\n\");\n        break;\n\n    case EXPR_NOT:\n        log_err(ctx, \"The ! operator cannot be applied to an integer\\n\");\n        return false;\n\n    case EXPR_INVERT:\n    case EXPR_NEGATE:\n        left = expr->unary.child;\n        if (!ExprResolveIntegerLookup(ctx, left, &l, lookup, lookupPriv))\n            return false;\n\n        *val_rtrn = (expr->expr.op == EXPR_NEGATE ? -l : ~l);\n        return true;\n\n    case EXPR_UNARY_PLUS:\n        left = expr->unary.child;\n        return ExprResolveIntegerLookup(ctx, left, val_rtrn, lookup,\n                                        lookupPriv);\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveInteger\\n\",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n\nbool\nExprResolveInteger(struct xkb_context *ctx, const ExprDef *expr,\n                   int *val_rtrn)\n{\n    return ExprResolveIntegerLookup(ctx, expr, val_rtrn, NULL, NULL);\n}\n\nbool\nExprResolveGroup(struct xkb_context *ctx, const ExprDef *expr,\n                 xkb_layout_index_t *group_rtrn)\n{\n    bool ok;\n    int result;\n\n    ok = ExprResolveIntegerLookup(ctx, expr, &result, SimpleLookup,\n                                  groupNames);\n    if (!ok)\n        return false;\n\n    if (result <= 0 || result > XKB_MAX_GROUPS) {\n        log_err(ctx, \"Group index %u is out of range (1..%d)\\n\",\n                result, XKB_MAX_GROUPS);\n        return false;\n    }\n\n    *group_rtrn = (xkb_layout_index_t) result;\n    return true;\n}\n\nbool\nExprResolveLevel(struct xkb_context *ctx, const ExprDef *expr,\n                 xkb_level_index_t *level_rtrn)\n{\n    bool ok;\n    int result;\n\n    ok = ExprResolveIntegerLookup(ctx, expr, &result, SimpleLookup,\n                                  levelNames);\n    if (!ok)\n        return false;\n\n    if (result < 1) {\n        log_err(ctx, \"Shift level %d is out of range\\n\", result);\n        return false;\n    }\n\n    /* Level is zero-indexed from now on. */\n    *level_rtrn = (unsigned int) (result - 1);\n    return true;\n}\n\nbool\nExprResolveButton(struct xkb_context *ctx, const ExprDef *expr, int *btn_rtrn)\n{\n    return ExprResolveIntegerLookup(ctx, expr, btn_rtrn, SimpleLookup,\n                                    buttonNames);\n}\n\nbool\nExprResolveString(struct xkb_context *ctx, const ExprDef *expr,\n                  xkb_atom_t *val_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_STRING) {\n            log_err(ctx, \"Found constant of type %s, expected a string\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n\n        *val_rtrn = expr->string.str;\n        return true;\n\n    case EXPR_IDENT:\n        log_err(ctx, \"Identifier \\\"%s\\\" of type string not found\\n\",\n                xkb_atom_text(ctx, expr->ident.ident));\n        return false;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type string not found\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_INVERT:\n    case EXPR_NOT:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of strings not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        return false;\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveString\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}\n\nbool\nExprResolveEnum(struct xkb_context *ctx, const ExprDef *expr,\n                unsigned int *val_rtrn, const LookupEntry *values)\n{\n    if (expr->expr.op != EXPR_IDENT) {\n        log_err(ctx, \"Found a %s where an enumerated value was expected\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        return false;\n    }\n\n    if (!SimpleLookup(ctx, values, expr->ident.ident, EXPR_TYPE_INT,\n                      val_rtrn)) {\n        log_err(ctx, \"Illegal identifier %s; expected one of:\\n\",\n                xkb_atom_text(ctx, expr->ident.ident));\n        while (values && values->name)\n        {\n            log_err(ctx, \"\\t%s\\n\", values->name);\n            values++;\n        }\n        return false;\n    }\n\n    return true;\n}\n\nstatic bool\nExprResolveMaskLookup(struct xkb_context *ctx, const ExprDef *expr,\n                      unsigned int *val_rtrn, IdentLookupFunc lookup,\n                      const void *lookupPriv)\n{\n    bool ok = false;\n    unsigned int l = 0, r = 0;\n    int v;\n    ExprDef *left, *right;\n    const char *bogus = NULL;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_INT) {\n            log_err(ctx,\n                    \"Found constant of type %s where a mask was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *val_rtrn = (unsigned int) expr->integer.ival;\n        return true;\n\n    case EXPR_IDENT:\n        ok = lookup(ctx, lookupPriv, expr->ident.ident, EXPR_TYPE_INT,\n                    val_rtrn);\n        if (!ok)\n            log_err(ctx, \"Identifier \\\"%s\\\" of type int is unknown\\n\",\n                    xkb_atom_text(ctx, expr->ident.ident));\n        return ok;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type int is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_ARRAY_REF:\n        bogus = \"array reference\";\n\t/* fallthrough */\n    case EXPR_ACTION_DECL:\n        if (bogus == NULL)\n            bogus = \"function use\";\n        log_err(ctx,\n                \"Unexpected %s in mask expression; Expression Ignored\\n\",\n                bogus);\n        return false;\n\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n        left = expr->binary.left;\n        right = expr->binary.right;\n        if (!ExprResolveMaskLookup(ctx, left, &l, lookup, lookupPriv) ||\n            !ExprResolveMaskLookup(ctx, right, &r, lookup, lookupPriv))\n            return false;\n\n        switch (expr->expr.op) {\n        case EXPR_ADD:\n            *val_rtrn = l | r;\n            break;\n        case EXPR_SUBTRACT:\n            *val_rtrn = l & (~r);\n            break;\n        case EXPR_MULTIPLY:\n        case EXPR_DIVIDE:\n            log_err(ctx, \"Cannot %s masks; Illegal operation ignored\\n\",\n                    (expr->expr.op == EXPR_DIVIDE ? \"divide\" : \"multiply\"));\n            return false;\n        default:\n            break;\n        }\n\n        return true;\n\n    case EXPR_ASSIGN:\n        log_wsgo(ctx, \"Assignment operator not implemented yet\\n\");\n        break;\n\n    case EXPR_INVERT:\n        left = expr->unary.child;\n        if (!ExprResolveIntegerLookup(ctx, left, &v, lookup, lookupPriv))\n            return false;\n\n        *val_rtrn = ~v;\n        return true;\n\n    case EXPR_UNARY_PLUS:\n    case EXPR_NEGATE:\n    case EXPR_NOT:\n        left = expr->unary.child;\n        if (!ExprResolveIntegerLookup(ctx, left, &v, lookup, lookupPriv))\n            log_err(ctx, \"The %s operator cannot be used with a mask\\n\",\n                    (expr->expr.op == EXPR_NEGATE ? \"-\" : \"!\"));\n        return false;\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveMask\\n\",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n\nbool\nExprResolveMask(struct xkb_context *ctx, const ExprDef *expr,\n                unsigned int *mask_rtrn, const LookupEntry *values)\n{\n    return ExprResolveMaskLookup(ctx, expr, mask_rtrn, SimpleLookup, values);\n}\n\nbool\nExprResolveModMask(struct xkb_context *ctx, const ExprDef *expr,\n                   enum mod_type mod_type, const struct xkb_mod_set *mods,\n                   xkb_mod_mask_t *mask_rtrn)\n{\n    LookupModMaskPriv priv = { .mods = mods, .mod_type = mod_type };\n    return ExprResolveMaskLookup(ctx, expr, mask_rtrn, LookupModMask, &priv);\n}\n\nbool\nExprResolveKeySym(struct xkb_context *ctx, const ExprDef *expr,\n                  xkb_keysym_t *sym_rtrn)\n{\n    int val;\n\n    if (expr->expr.op == EXPR_IDENT) {\n        const char *str = xkb_atom_text(ctx, expr->ident.ident);\n        *sym_rtrn = xkb_keysym_from_name(str, 0);\n        if (*sym_rtrn != XKB_KEY_NoSymbol)\n            return true;\n    }\n\n    if (!ExprResolveInteger(ctx, expr, &val))\n        return false;\n\n    if (val < 0 || val >= 10)\n        return false;\n\n    *sym_rtrn = XKB_KEY_0 + (xkb_keysym_t) val;\n    return true;\n}\n\nbool\nExprResolveMod(struct xkb_context *ctx, const ExprDef *def,\n               enum mod_type mod_type, const struct xkb_mod_set *mods,\n               xkb_mod_index_t *ndx_rtrn)\n{\n    xkb_mod_index_t ndx;\n    xkb_atom_t name;\n\n    if (def->expr.op != EXPR_IDENT) {\n        log_err(ctx,\n                \"Cannot resolve virtual modifier: \"\n                \"found %s where a virtual modifier name was expected\\n\",\n                expr_op_type_to_string(def->expr.op));\n        return false;\n    }\n\n    name = def->ident.ident;\n    ndx = XkbModNameToIndex(mods, name, mod_type);\n    if (ndx == XKB_MOD_INVALID) {\n        log_err(ctx,\n                \"Cannot resolve virtual modifier: \"\n                \"\\\"%s\\\" was not previously declared\\n\",\n                xkb_atom_text(ctx, name));\n        return false;\n    }\n\n    *ndx_rtrn = ndx;\n    return true;\n}\n"], "fixing_code": ["/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n#include \"xkbcomp-priv.h\"\n#include \"text.h\"\n#include \"expr.h\"\n\ntypedef bool (*IdentLookupFunc)(struct xkb_context *ctx, const void *priv,\n                                xkb_atom_t field, enum expr_value_type type,\n                                unsigned int *val_rtrn);\n\nbool\nExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}\n\nstatic bool\nSimpleLookup(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n             enum expr_value_type type, unsigned int *val_rtrn)\n{\n    const LookupEntry *entry;\n    const char *str;\n\n    if (!priv || field == XKB_ATOM_NONE || type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n    for (entry = priv; entry && entry->name; entry++) {\n        if (istreq(str, entry->name)) {\n            *val_rtrn = entry->value;\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/* Data passed in the *priv argument for LookupModMask. */\ntypedef struct {\n    const struct xkb_mod_set *mods;\n    enum mod_type mod_type;\n} LookupModMaskPriv;\n\nstatic bool\nLookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n\n    if (type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n\n    *val_rtrn = (1u << ndx);\n    return true;\n}\n\nbool\nExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_INVERT:\n    case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);\n        if (ok)\n            *set_rtrn = !*set_rtrn;\n        return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n\nbool\nExprResolveKeyCode(struct xkb_context *ctx, const ExprDef *expr,\n                   xkb_keycode_t *kc)\n{\n    xkb_keycode_t leftRtrn, rightRtrn;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_INT) {\n            log_err(ctx,\n                    \"Found constant of type %s where an int was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n\n        *kc = (xkb_keycode_t) expr->integer.ival;\n        return true;\n\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n        if (!ExprResolveKeyCode(ctx, expr->binary.left, &leftRtrn) ||\n            !ExprResolveKeyCode(ctx, expr->binary.right, &rightRtrn))\n            return false;\n\n        switch (expr->expr.op) {\n        case EXPR_ADD:\n            *kc = leftRtrn + rightRtrn;\n            break;\n        case EXPR_SUBTRACT:\n            *kc = leftRtrn - rightRtrn;\n            break;\n        case EXPR_MULTIPLY:\n            *kc = leftRtrn * rightRtrn;\n            break;\n        case EXPR_DIVIDE:\n            if (rightRtrn == 0) {\n                log_err(ctx, \"Cannot divide by zero: %d / %d\\n\",\n                        leftRtrn, rightRtrn);\n                return false;\n            }\n\n            *kc = leftRtrn / rightRtrn;\n            break;\n        default:\n            break;\n        }\n\n        return true;\n\n    case EXPR_NEGATE:\n        if (!ExprResolveKeyCode(ctx, expr->unary.child, &leftRtrn))\n            return false;\n\n        *kc = ~leftRtrn;\n        return true;\n\n    case EXPR_UNARY_PLUS:\n        return ExprResolveKeyCode(ctx, expr->unary.child, kc);\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveKeyCode\\n\",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n\n/**\n * This function returns ... something.  It's a bit of a guess, really.\n *\n * If an integer is given in value ctx, it will be returned in ival.\n * If an ident or field reference is given, the lookup function (if given)\n * will be called.  At the moment, only SimpleLookup use this, and they both\n * return the results in uval.  And don't support field references.\n *\n * Cool.\n */\nstatic bool\nExprResolveIntegerLookup(struct xkb_context *ctx, const ExprDef *expr,\n                         int *val_rtrn, IdentLookupFunc lookup,\n                         const void *lookupPriv)\n{\n    bool ok = false;\n    int l, r;\n    unsigned u;\n    ExprDef *left, *right;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_INT) {\n            log_err(ctx,\n                    \"Found constant of type %s where an int was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n\n        *val_rtrn = expr->integer.ival;\n        return true;\n\n    case EXPR_IDENT:\n        if (lookup)\n            ok = lookup(ctx, lookupPriv, expr->ident.ident, EXPR_TYPE_INT, &u);\n\n        if (!ok)\n            log_err(ctx, \"Identifier \\\"%s\\\" of type int is unknown\\n\",\n                    xkb_atom_text(ctx, expr->ident.ident));\n        else\n            *val_rtrn = (int) u;\n\n        return ok;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type int is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n        left = expr->binary.left;\n        right = expr->binary.right;\n        if (!ExprResolveIntegerLookup(ctx, left, &l, lookup, lookupPriv) ||\n            !ExprResolveIntegerLookup(ctx, right, &r, lookup, lookupPriv))\n            return false;\n\n        switch (expr->expr.op) {\n        case EXPR_ADD:\n            *val_rtrn = l + r;\n            break;\n        case EXPR_SUBTRACT:\n            *val_rtrn = l - r;\n            break;\n        case EXPR_MULTIPLY:\n            *val_rtrn = l * r;\n            break;\n        case EXPR_DIVIDE:\n            if (r == 0) {\n                log_err(ctx, \"Cannot divide by zero: %d / %d\\n\", l, r);\n                return false;\n            }\n            *val_rtrn = l / r;\n            break;\n        default:\n            log_err(ctx, \"%s of integers not permitted\\n\",\n                    expr_op_type_to_string(expr->expr.op));\n            return false;\n        }\n\n        return true;\n\n    case EXPR_ASSIGN:\n        log_wsgo(ctx, \"Assignment operator not implemented yet\\n\");\n        break;\n\n    case EXPR_NOT:\n        log_err(ctx, \"The ! operator cannot be applied to an integer\\n\");\n        return false;\n\n    case EXPR_INVERT:\n    case EXPR_NEGATE:\n        left = expr->unary.child;\n        if (!ExprResolveIntegerLookup(ctx, left, &l, lookup, lookupPriv))\n            return false;\n\n        *val_rtrn = (expr->expr.op == EXPR_NEGATE ? -l : ~l);\n        return true;\n\n    case EXPR_UNARY_PLUS:\n        left = expr->unary.child;\n        return ExprResolveIntegerLookup(ctx, left, val_rtrn, lookup,\n                                        lookupPriv);\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveInteger\\n\",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n\nbool\nExprResolveInteger(struct xkb_context *ctx, const ExprDef *expr,\n                   int *val_rtrn)\n{\n    return ExprResolveIntegerLookup(ctx, expr, val_rtrn, NULL, NULL);\n}\n\nbool\nExprResolveGroup(struct xkb_context *ctx, const ExprDef *expr,\n                 xkb_layout_index_t *group_rtrn)\n{\n    bool ok;\n    int result;\n\n    ok = ExprResolveIntegerLookup(ctx, expr, &result, SimpleLookup,\n                                  groupNames);\n    if (!ok)\n        return false;\n\n    if (result <= 0 || result > XKB_MAX_GROUPS) {\n        log_err(ctx, \"Group index %u is out of range (1..%d)\\n\",\n                result, XKB_MAX_GROUPS);\n        return false;\n    }\n\n    *group_rtrn = (xkb_layout_index_t) result;\n    return true;\n}\n\nbool\nExprResolveLevel(struct xkb_context *ctx, const ExprDef *expr,\n                 xkb_level_index_t *level_rtrn)\n{\n    bool ok;\n    int result;\n\n    ok = ExprResolveIntegerLookup(ctx, expr, &result, SimpleLookup,\n                                  levelNames);\n    if (!ok)\n        return false;\n\n    if (result < 1) {\n        log_err(ctx, \"Shift level %d is out of range\\n\", result);\n        return false;\n    }\n\n    /* Level is zero-indexed from now on. */\n    *level_rtrn = (unsigned int) (result - 1);\n    return true;\n}\n\nbool\nExprResolveButton(struct xkb_context *ctx, const ExprDef *expr, int *btn_rtrn)\n{\n    return ExprResolveIntegerLookup(ctx, expr, btn_rtrn, SimpleLookup,\n                                    buttonNames);\n}\n\nbool\nExprResolveString(struct xkb_context *ctx, const ExprDef *expr,\n                  xkb_atom_t *val_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_STRING) {\n            log_err(ctx, \"Found constant of type %s, expected a string\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n\n        *val_rtrn = expr->string.str;\n        return true;\n\n    case EXPR_IDENT:\n        log_err(ctx, \"Identifier \\\"%s\\\" of type string not found\\n\",\n                xkb_atom_text(ctx, expr->ident.ident));\n        return false;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type string not found\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_INVERT:\n    case EXPR_NOT:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of strings not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        return false;\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveString\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}\n\nbool\nExprResolveEnum(struct xkb_context *ctx, const ExprDef *expr,\n                unsigned int *val_rtrn, const LookupEntry *values)\n{\n    if (expr->expr.op != EXPR_IDENT) {\n        log_err(ctx, \"Found a %s where an enumerated value was expected\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        return false;\n    }\n\n    if (!SimpleLookup(ctx, values, expr->ident.ident, EXPR_TYPE_INT,\n                      val_rtrn)) {\n        log_err(ctx, \"Illegal identifier %s; expected one of:\\n\",\n                xkb_atom_text(ctx, expr->ident.ident));\n        while (values && values->name)\n        {\n            log_err(ctx, \"\\t%s\\n\", values->name);\n            values++;\n        }\n        return false;\n    }\n\n    return true;\n}\n\nstatic bool\nExprResolveMaskLookup(struct xkb_context *ctx, const ExprDef *expr,\n                      unsigned int *val_rtrn, IdentLookupFunc lookup,\n                      const void *lookupPriv)\n{\n    bool ok = false;\n    unsigned int l = 0, r = 0;\n    int v;\n    ExprDef *left, *right;\n    const char *bogus = NULL;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_INT) {\n            log_err(ctx,\n                    \"Found constant of type %s where a mask was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *val_rtrn = (unsigned int) expr->integer.ival;\n        return true;\n\n    case EXPR_IDENT:\n        ok = lookup(ctx, lookupPriv, expr->ident.ident, EXPR_TYPE_INT,\n                    val_rtrn);\n        if (!ok)\n            log_err(ctx, \"Identifier \\\"%s\\\" of type int is unknown\\n\",\n                    xkb_atom_text(ctx, expr->ident.ident));\n        return ok;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type int is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_ARRAY_REF:\n        bogus = \"array reference\";\n\t/* fallthrough */\n    case EXPR_ACTION_DECL:\n        if (bogus == NULL)\n            bogus = \"function use\";\n        log_err(ctx,\n                \"Unexpected %s in mask expression; Expression Ignored\\n\",\n                bogus);\n        return false;\n\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n        left = expr->binary.left;\n        right = expr->binary.right;\n        if (!ExprResolveMaskLookup(ctx, left, &l, lookup, lookupPriv) ||\n            !ExprResolveMaskLookup(ctx, right, &r, lookup, lookupPriv))\n            return false;\n\n        switch (expr->expr.op) {\n        case EXPR_ADD:\n            *val_rtrn = l | r;\n            break;\n        case EXPR_SUBTRACT:\n            *val_rtrn = l & (~r);\n            break;\n        case EXPR_MULTIPLY:\n        case EXPR_DIVIDE:\n            log_err(ctx, \"Cannot %s masks; Illegal operation ignored\\n\",\n                    (expr->expr.op == EXPR_DIVIDE ? \"divide\" : \"multiply\"));\n            return false;\n        default:\n            break;\n        }\n\n        return true;\n\n    case EXPR_ASSIGN:\n        log_wsgo(ctx, \"Assignment operator not implemented yet\\n\");\n        break;\n\n    case EXPR_INVERT:\n        left = expr->unary.child;\n        if (!ExprResolveIntegerLookup(ctx, left, &v, lookup, lookupPriv))\n            return false;\n\n        *val_rtrn = ~v;\n        return true;\n\n    case EXPR_UNARY_PLUS:\n    case EXPR_NEGATE:\n    case EXPR_NOT:\n        left = expr->unary.child;\n        if (!ExprResolveIntegerLookup(ctx, left, &v, lookup, lookupPriv))\n            log_err(ctx, \"The %s operator cannot be used with a mask\\n\",\n                    (expr->expr.op == EXPR_NEGATE ? \"-\" : \"!\"));\n        return false;\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveMask\\n\",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n\nbool\nExprResolveMask(struct xkb_context *ctx, const ExprDef *expr,\n                unsigned int *mask_rtrn, const LookupEntry *values)\n{\n    return ExprResolveMaskLookup(ctx, expr, mask_rtrn, SimpleLookup, values);\n}\n\nbool\nExprResolveModMask(struct xkb_context *ctx, const ExprDef *expr,\n                   enum mod_type mod_type, const struct xkb_mod_set *mods,\n                   xkb_mod_mask_t *mask_rtrn)\n{\n    LookupModMaskPriv priv = { .mods = mods, .mod_type = mod_type };\n    return ExprResolveMaskLookup(ctx, expr, mask_rtrn, LookupModMask, &priv);\n}\n\nbool\nExprResolveKeySym(struct xkb_context *ctx, const ExprDef *expr,\n                  xkb_keysym_t *sym_rtrn)\n{\n    int val;\n\n    if (expr->expr.op == EXPR_IDENT) {\n        const char *str = xkb_atom_text(ctx, expr->ident.ident);\n        *sym_rtrn = xkb_keysym_from_name(str, 0);\n        if (*sym_rtrn != XKB_KEY_NoSymbol)\n            return true;\n    }\n\n    if (!ExprResolveInteger(ctx, expr, &val))\n        return false;\n\n    if (val < 0 || val >= 10)\n        return false;\n\n    *sym_rtrn = XKB_KEY_0 + (xkb_keysym_t) val;\n    return true;\n}\n\nbool\nExprResolveMod(struct xkb_context *ctx, const ExprDef *def,\n               enum mod_type mod_type, const struct xkb_mod_set *mods,\n               xkb_mod_index_t *ndx_rtrn)\n{\n    xkb_mod_index_t ndx;\n    xkb_atom_t name;\n\n    if (def->expr.op != EXPR_IDENT) {\n        log_err(ctx,\n                \"Cannot resolve virtual modifier: \"\n                \"found %s where a virtual modifier name was expected\\n\",\n                expr_op_type_to_string(def->expr.op));\n        return false;\n    }\n\n    name = def->ident.ident;\n    ndx = XkbModNameToIndex(mods, name, mod_type);\n    if (ndx == XKB_MOD_INVALID) {\n        log_err(ctx,\n                \"Cannot resolve virtual modifier: \"\n                \"\\\"%s\\\" was not previously declared\\n\",\n                xkb_atom_text(ctx, name));\n        return false;\n    }\n\n    *ndx_rtrn = ndx;\n    return true;\n}\n"], "filenames": ["src/xkbcomp/expr.c"], "buggy_code_start_loc": [168], "buggy_code_end_loc": [169], "fixing_code_start_loc": [168], "fixing_code_end_loc": [169], "type": "CWE-400", "message": "Endless recursion exists in xkbcomp/expr.c in xkbcommon and libxkbcommon before 0.8.1, which could be used by local attackers to crash xkbcommon users by supplying a crafted keymap file that triggers boolean negation.", "other": {"cve": {"id": "CVE-2018-15853", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-25T21:29:01.483", "lastModified": "2019-08-06T17:15:24.803", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Endless recursion exists in xkbcomp/expr.c in xkbcommon and libxkbcommon before 0.8.1, which could be used by local attackers to crash xkbcommon users by supplying a crafted keymap file that triggers boolean negation."}, {"lang": "es", "value": "Existe recursi\u00f3n infinita en xkbcomp/expr.c en xkbcommon y libxkbcommon en versiones anteriores a la 0.8.1, lo que podr\u00eda ser empleado por atacantes locales para provocar el cierre inesperado de usuarios xkbcommon proporcionando un archivo keymap manipulado que desencadena la negaci\u00f3n booleana."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon:libxkbcommon:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.1", "matchCriteriaId": "33CC7ED5-C297-470D-B26A-25D0EB694460"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon:xkbcommon:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.1", "matchCriteriaId": "C7D955F4-3540-42A7-8551-EA1A266DDEA6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2079", "source": "cve@mitre.org"}, {"url": "https://github.com/xkbcommon/libxkbcommon/commit/1f9d1248c07cda8aaff762429c0dce146de8632a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.freedesktop.org/archives/wayland-devel/2018-August/039232.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/1f9d1248c07cda8aaff762429c0dce146de8632a"}}