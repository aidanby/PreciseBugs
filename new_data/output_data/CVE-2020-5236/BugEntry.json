{"buggy_code": ["\"\"\"\nThis contains a bunch of RFC7230 definitions and regular expressions that are\nneeded to properly parse HTTP messages.\n\"\"\"\n\nimport re\n\nfrom .compat import tobytes\n\nWS = \"[ \\t]\"\nOWS = WS + \"{0,}?\"\nRWS = WS + \"{1,}?\"\nBWS = OWS\n\n# RFC 7230 Section 3.2.6 \"Field Value Components\":\n# tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n#                / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n#                / DIGIT / ALPHA\n# obs-text      = %x80-FF\nTCHAR = r\"[!#$%&'*+\\-.^_`|~0-9A-Za-z]\"\nOBS_TEXT = r\"\\x80-\\xff\"\n\nTOKEN = TCHAR + \"{1,}\"\n\n# RFC 5234 Appendix B.1 \"Core Rules\":\n# VCHAR         =  %x21-7E\n#                  ; visible (printing) characters\nVCHAR = r\"\\x21-\\x7e\"\n\n# header-field   = field-name \":\" OWS field-value OWS\n# field-name     = token\n# field-value    = *( field-content / obs-fold )\n# field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n# field-vchar    = VCHAR / obs-text\n\n# Errata from: https://www.rfc-editor.org/errata_search.php?rfc=7230&eid=4189\n# changes field-content to:\n#\n# field-content  = field-vchar [ 1*( SP / HTAB / field-vchar )\n#                  field-vchar ]\n\nFIELD_VCHAR = \"[\" + VCHAR + OBS_TEXT + \"]\"\nFIELD_CONTENT = FIELD_VCHAR + \"([ \\t\" + VCHAR + OBS_TEXT + \"]+\" + FIELD_VCHAR + \"){,1}\"\nFIELD_VALUE = \"(\" + FIELD_CONTENT + \"){0,}\"\n\nHEADER_FIELD = re.compile(\n    tobytes(\n        \"^(?P<name>\" + TOKEN + \"):\" + OWS + \"(?P<value>\" + FIELD_VALUE + \")\" + OWS + \"$\"\n    )\n)\n\nOWS_STRIP = re.compile(OWS + \"(?P<value>.*?)\" + OWS)\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"HTTP Request Parser tests\n\"\"\"\nimport unittest\n\nfrom waitress.compat import text_, tobytes\n\n\nclass TestHTTPRequestParser(unittest.TestCase):\n    def setUp(self):\n        from waitress.parser import HTTPRequestParser\n        from waitress.adjustments import Adjustments\n\n        my_adj = Adjustments()\n        self.parser = HTTPRequestParser(my_adj)\n\n    def test_get_body_stream_None(self):\n        self.parser.body_recv = None\n        result = self.parser.get_body_stream()\n        self.assertEqual(result.getvalue(), b\"\")\n\n    def test_get_body_stream_nonNone(self):\n        body_rcv = DummyBodyStream()\n        self.parser.body_rcv = body_rcv\n        result = self.parser.get_body_stream()\n        self.assertEqual(result, body_rcv)\n\n    def test_received_get_no_headers(self):\n        data = b\"HTTP/1.0 GET /foobar\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 24)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_bad_host_header(self):\n        from waitress.utilities import BadRequest\n\n        data = b\"HTTP/1.0 GET /foobar\\r\\n Host: foo\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 36)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.error.__class__, BadRequest)\n\n    def test_received_bad_transfer_encoding(self):\n        from waitress.utilities import ServerNotImplemented\n        data = (\n            b\"GET /foobar HTTP/1.1\\r\\n\"\n            b\"Transfer-Encoding: foo\\r\\n\"\n            b\"\\r\\n\"\n            b\"1d;\\r\\n\"\n            b\"This string has 29 characters\\r\\n\"\n            b\"0\\r\\n\\r\\n\"\n        )\n        result = self.parser.received(data)\n        self.assertEqual(result, 48)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.error.__class__, ServerNotImplemented)\n\n    def test_received_nonsense_nothing(self):\n        data = b\"\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 4)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_no_doublecr(self):\n        data = b\"GET /foobar HTTP/8.4\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 22)\n        self.assertFalse(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_already_completed(self):\n        self.parser.completed = True\n        result = self.parser.received(b\"a\")\n        self.assertEqual(result, 0)\n\n    def test_received_cl_too_large(self):\n        from waitress.utilities import RequestEntityTooLarge\n\n        self.parser.adj.max_request_body_size = 2\n        data = b\"GET /foobar HTTP/8.4\\r\\nContent-Length: 10\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 44)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))\n\n    def test_received_headers_too_large(self):\n        from waitress.utilities import RequestHeaderFieldsTooLarge\n\n        self.parser.adj.max_request_header_size = 2\n        data = b\"GET /foobar HTTP/8.4\\r\\nX-Foo: 1\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 34)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestHeaderFieldsTooLarge))\n\n    def test_received_body_too_large(self):\n        from waitress.utilities import RequestEntityTooLarge\n\n        self.parser.adj.max_request_body_size = 2\n        data = (\n            b\"GET /foobar HTTP/1.1\\r\\n\"\n            b\"Transfer-Encoding: chunked\\r\\n\"\n            b\"X-Foo: 1\\r\\n\"\n            b\"\\r\\n\"\n            b\"1d;\\r\\n\"\n            b\"This string has 29 characters\\r\\n\"\n            b\"0\\r\\n\\r\\n\"\n        )\n\n        result = self.parser.received(data)\n        self.assertEqual(result, 62)\n        self.parser.received(data[result:])\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))\n\n    def test_received_error_from_parser(self):\n        from waitress.utilities import BadRequest\n\n        data = (\n            b\"GET /foobar HTTP/1.1\\r\\n\"\n            b\"Transfer-Encoding: chunked\\r\\n\"\n            b\"X-Foo: 1\\r\\n\"\n            b\"\\r\\n\"\n            b\"garbage\\r\\n\"\n        )\n        # header\n        result = self.parser.received(data)\n        # body\n        result = self.parser.received(data[result:])\n        self.assertEqual(result, 9)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, BadRequest))\n\n    def test_received_chunked_completed_sets_content_length(self):\n        data = (\n            b\"GET /foobar HTTP/1.1\\r\\n\"\n            b\"Transfer-Encoding: chunked\\r\\n\"\n            b\"X-Foo: 1\\r\\n\"\n            b\"\\r\\n\"\n            b\"1d;\\r\\n\"\n            b\"This string has 29 characters\\r\\n\"\n            b\"0\\r\\n\\r\\n\"\n        )\n        result = self.parser.received(data)\n        self.assertEqual(result, 62)\n        data = data[result:]\n        result = self.parser.received(data)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(self.parser.error is None)\n        self.assertEqual(self.parser.headers[\"CONTENT_LENGTH\"], \"29\")\n\n    def test_parse_header_gardenpath(self):\n        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: bar\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.first_line, b\"GET /foobar HTTP/8.4\")\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar\")\n\n    def test_parse_header_no_cr_in_headerplus(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\"\n\n        try:\n            self.parser.parse_header(data)\n        except ParsingError:\n            pass\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_bad_content_length(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: abc\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Content-Length is invalid\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_multiple_content_length(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: 10\\r\\ncontent-length: 20\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Content-Length is invalid\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_11_te_chunked(self):\n        # NB: test that capitalization of header value is unimportant\n        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: ChUnKed\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.body_rcv.__class__.__name__, \"ChunkedReceiver\")\n\n\n    def test_parse_header_transfer_encoding_invalid(self):\n        from waitress.parser import TransferEncodingNotImplemented\n\n        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: gzip\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except TransferEncodingNotImplemented as e:\n            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_transfer_encoding_invalid_multiple(self):\n        from waitress.parser import TransferEncodingNotImplemented\n\n        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: gzip\\r\\ntransfer-encoding: chunked\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except TransferEncodingNotImplemented as e:\n            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_transfer_encoding_invalid_whitespace(self):\n        from waitress.parser import TransferEncodingNotImplemented\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nTransfer-Encoding:\\x85chunked\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except TransferEncodingNotImplemented as e:\n            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_transfer_encoding_invalid_unicode(self):\n        from waitress.parser import TransferEncodingNotImplemented\n\n        # This is the binary encoding for the UTF-8 character\n        # https://www.compart.com/en/unicode/U+212A \"unicode character \"K\"\"\n        # which if waitress were to accidentally do the wrong thing get\n        # lowercased to just the ascii \"k\" due to unicode collisions during\n        # transformation\n        data = b\"GET /foobar HTTP/1.1\\r\\nTransfer-Encoding: chun\\xe2\\x84\\xaaed\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except TransferEncodingNotImplemented as e:\n            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_11_expect_continue(self):\n        data = b\"GET /foobar HTTP/1.1\\r\\nexpect: 100-continue\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.expect_continue, True)\n\n    def test_parse_header_connection_close(self):\n        data = b\"GET /foobar HTTP/1.1\\r\\nConnection: close\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.connection_close, True)\n\n    def test_close_with_body_rcv(self):\n        body_rcv = DummyBodyStream()\n        self.parser.body_rcv = body_rcv\n        self.parser.close()\n        self.assertTrue(body_rcv.closed)\n\n    def test_close_with_no_body_rcv(self):\n        self.parser.body_rcv = None\n        self.parser.close()  # doesn't raise\n\n    def test_parse_header_lf_only(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\nfoo: bar\"\n\n        try:\n            self.parser.parse_header(data)\n        except ParsingError:\n            pass\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_cr_only(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\rfoo: bar\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError:\n            pass\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_extra_lf_in_header(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: \\nbar\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Bare CR or LF found in header line\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_extra_lf_in_first_line(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar\\n HTTP/8.4\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Bare CR or LF found in HTTP message\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_invalid_whitespace(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\r\\nfoo : bar\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Invalid header\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_invalid_whitespace_vtab(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo:\\x0bbar\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Invalid header\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_invalid_no_colon(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\nnotvalid\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Invalid header\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_invalid_folding_spacing(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\n\\t\\x0bbaz\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Invalid header\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_invalid_chars(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\n\\foo: \\x0bbaz\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Invalid header\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_empty(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\nempty:\\r\\n\"\n        self.parser.parse_header(data)\n\n        self.assertIn(\"EMPTY\", self.parser.headers)\n        self.assertIn(\"FOO\", self.parser.headers)\n        self.assertEqual(self.parser.headers[\"EMPTY\"], \"\")\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar\")\n\n    def test_parse_header_multiple_values(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever, more, please, yes\\r\\n\"\n        self.parser.parse_header(data)\n\n        self.assertIn(\"FOO\", self.parser.headers)\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")\n\n    def test_parse_header_multiple_values_header_folded(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever,\\r\\n more, please, yes\\r\\n\"\n        self.parser.parse_header(data)\n\n        self.assertIn(\"FOO\", self.parser.headers)\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")\n\n    def test_parse_header_multiple_values_header_folded_multiple(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever,\\r\\n more\\r\\nfoo: please, yes\\r\\n\"\n        self.parser.parse_header(data)\n\n        self.assertIn(\"FOO\", self.parser.headers)\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")\n\n    def test_parse_header_multiple_values_extra_space(self):\n        # Tests errata from: https://www.rfc-editor.org/errata_search.php?rfc=7230&eid=4189\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: abrowser/0.001 (C O M M E N T)\\r\\n\"\n        self.parser.parse_header(data)\n\n        self.assertIn(\"FOO\", self.parser.headers)\n        self.assertEqual(self.parser.headers[\"FOO\"], \"abrowser/0.001 (C O M M E N T)\")\n\n\nclass Test_split_uri(unittest.TestCase):\n    def _callFUT(self, uri):\n        from waitress.parser import split_uri\n\n        (\n            self.proxy_scheme,\n            self.proxy_netloc,\n            self.path,\n            self.query,\n            self.fragment,\n        ) = split_uri(uri)\n\n    def test_split_uri_unquoting_unneeded(self):\n        self._callFUT(b\"http://localhost:8080/abc def\")\n        self.assertEqual(self.path, \"/abc def\")\n\n    def test_split_uri_unquoting_needed(self):\n        self._callFUT(b\"http://localhost:8080/abc%20def\")\n        self.assertEqual(self.path, \"/abc def\")\n\n    def test_split_url_with_query(self):\n        self._callFUT(b\"http://localhost:8080/abc?a=1&b=2\")\n        self.assertEqual(self.path, \"/abc\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n\n    def test_split_url_with_query_empty(self):\n        self._callFUT(b\"http://localhost:8080/abc?\")\n        self.assertEqual(self.path, \"/abc\")\n        self.assertEqual(self.query, \"\")\n\n    def test_split_url_with_fragment(self):\n        self._callFUT(b\"http://localhost:8080/#foo\")\n        self.assertEqual(self.path, \"/\")\n        self.assertEqual(self.fragment, \"foo\")\n\n    def test_split_url_https(self):\n        self._callFUT(b\"https://localhost:8080/\")\n        self.assertEqual(self.path, \"/\")\n        self.assertEqual(self.proxy_scheme, \"https\")\n        self.assertEqual(self.proxy_netloc, \"localhost:8080\")\n\n    def test_split_uri_unicode_error_raises_parsing_error(self):\n        # See https://github.com/Pylons/waitress/issues/64\n        from waitress.parser import ParsingError\n\n        # Either pass or throw a ParsingError, just don't throw another type of\n        # exception as that will cause the connection to close badly:\n        try:\n            self._callFUT(b\"/\\xd0\")\n        except ParsingError:\n            pass\n\n    def test_split_uri_path(self):\n        self._callFUT(b\"//testing/whatever\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"\")\n        self.assertEqual(self.fragment, \"\")\n\n    def test_split_uri_path_query(self):\n        self._callFUT(b\"//testing/whatever?a=1&b=2\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n        self.assertEqual(self.fragment, \"\")\n\n    def test_split_uri_path_query_fragment(self):\n        self._callFUT(b\"//testing/whatever?a=1&b=2#fragment\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n        self.assertEqual(self.fragment, \"fragment\")\n\n\nclass Test_get_header_lines(unittest.TestCase):\n    def _callFUT(self, data):\n        from waitress.parser import get_header_lines\n\n        return get_header_lines(data)\n\n    def test_get_header_lines(self):\n        result = self._callFUT(b\"slam\\r\\nslim\")\n        self.assertEqual(result, [b\"slam\", b\"slim\"])\n\n    def test_get_header_lines_folded(self):\n        # From RFC2616:\n        # HTTP/1.1 header field values can be folded onto multiple lines if the\n        # continuation line begins with a space or horizontal tab. All linear\n        # white space, including folding, has the same semantics as SP. A\n        # recipient MAY replace any linear white space with a single SP before\n        # interpreting the field value or forwarding the message downstream.\n\n        # We are just preserving the whitespace that indicates folding.\n        result = self._callFUT(b\"slim\\r\\n slam\")\n        self.assertEqual(result, [b\"slim slam\"])\n\n    def test_get_header_lines_tabbed(self):\n        result = self._callFUT(b\"slam\\r\\n\\tslim\")\n        self.assertEqual(result, [b\"slam\\tslim\"])\n\n    def test_get_header_lines_malformed(self):\n        # https://corte.si/posts/code/pathod/pythonservers/index.html\n        from waitress.parser import ParsingError\n\n        self.assertRaises(ParsingError, self._callFUT, b\" Host: localhost\\r\\n\\r\\n\")\n\n\nclass Test_crack_first_line(unittest.TestCase):\n    def _callFUT(self, line):\n        from waitress.parser import crack_first_line\n\n        return crack_first_line(line)\n\n    def test_crack_first_line_matchok(self):\n        result = self._callFUT(b\"GET / HTTP/1.0\")\n        self.assertEqual(result, (b\"GET\", b\"/\", b\"1.0\"))\n\n    def test_crack_first_line_lowercase_method(self):\n        from waitress.parser import ParsingError\n\n        self.assertRaises(ParsingError, self._callFUT, b\"get / HTTP/1.0\")\n\n    def test_crack_first_line_nomatch(self):\n        result = self._callFUT(b\"GET / bleh\")\n        self.assertEqual(result, (b\"\", b\"\", b\"\"))\n\n        result = self._callFUT(b\"GET /info?txtAirPlay&txtRAOP RTSP/1.0\")\n        self.assertEqual(result, (b\"\", b\"\", b\"\"))\n\n    def test_crack_first_line_missing_version(self):\n        result = self._callFUT(b\"GET /\")\n        self.assertEqual(result, (b\"GET\", b\"/\", b\"\"))\n\n\nclass TestHTTPRequestParserIntegration(unittest.TestCase):\n    def setUp(self):\n        from waitress.parser import HTTPRequestParser\n        from waitress.adjustments import Adjustments\n\n        my_adj = Adjustments()\n        self.parser = HTTPRequestParser(my_adj)\n\n    def feed(self, data):\n        parser = self.parser\n\n        for n in range(100):  # make sure we never loop forever\n            consumed = parser.received(data)\n            data = data[consumed:]\n\n            if parser.completed:\n                return\n        raise ValueError(\"Looping\")  # pragma: no cover\n\n    def testSimpleGET(self):\n        data = (\n            b\"GET /foobar HTTP/8.4\\r\\n\"\n            b\"FirstName: mickey\\r\\n\"\n            b\"lastname: Mouse\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        parser = self.parser\n        self.feed(data)\n        self.assertTrue(parser.completed)\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(\n            parser.headers,\n            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"6\",},\n        )\n        self.assertEqual(parser.path, \"/foobar\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.query, \"\")\n        self.assertEqual(parser.proxy_scheme, \"\")\n        self.assertEqual(parser.proxy_netloc, \"\")\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")\n\n    def testComplexGET(self):\n        data = (\n            b\"GET /foo/a+%2B%2F%C3%A4%3D%26a%3Aint?d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6 HTTP/8.4\\r\\n\"\n            b\"FirstName: mickey\\r\\n\"\n            b\"lastname: Mouse\\r\\n\"\n            b\"content-length: 10\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello mickey.\"\n        )\n        parser = self.parser\n        self.feed(data)\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(\n            parser.headers,\n            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"10\"},\n        )\n        # path should be utf-8 encoded\n        self.assertEqual(\n            tobytes(parser.path).decode(\"utf-8\"),\n            text_(b\"/foo/a++/\\xc3\\xa4=&a:int\", \"utf-8\"),\n        )\n        self.assertEqual(\n            parser.query, \"d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6\"\n        )\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello mick\")\n\n    def testProxyGET(self):\n        data = (\n            b\"GET https://example.com:8080/foobar HTTP/8.4\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        parser = self.parser\n        self.feed(data)\n        self.assertTrue(parser.completed)\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(parser.headers, {\"CONTENT_LENGTH\": \"6\"})\n        self.assertEqual(parser.path, \"/foobar\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.proxy_scheme, \"https\")\n        self.assertEqual(parser.proxy_netloc, \"example.com:8080\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.query, \"\")\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")\n\n    def testDuplicateHeaders(self):\n        # Ensure that headers with the same key get concatenated as per\n        # RFC2616.\n        data = (\n            b\"GET /foobar HTTP/8.4\\r\\n\"\n            b\"x-forwarded-for: 10.11.12.13\\r\\n\"\n            b\"x-forwarded-for: unknown,127.0.0.1\\r\\n\"\n            b\"X-Forwarded_for: 255.255.255.255\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        self.feed(data)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(\n            self.parser.headers,\n            {\n                \"CONTENT_LENGTH\": \"6\",\n                \"X_FORWARDED_FOR\": \"10.11.12.13, unknown,127.0.0.1\",\n            },\n        )\n\n    def testSpoofedHeadersDropped(self):\n        data = (\n            b\"GET /foobar HTTP/8.4\\r\\n\"\n            b\"x-auth_user: bob\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        self.feed(data)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {\"CONTENT_LENGTH\": \"6\",})\n\n\nclass DummyBodyStream(object):\n    def getfile(self):\n        return self\n\n    def getbuf(self):\n        return self\n\n    def close(self):\n        self.closed = True\n"], "fixing_code": ["\"\"\"\nThis contains a bunch of RFC7230 definitions and regular expressions that are\nneeded to properly parse HTTP messages.\n\"\"\"\n\nimport re\n\nfrom .compat import tobytes\n\nWS = \"[ \\t]\"\nOWS = WS + \"{0,}?\"\nRWS = WS + \"{1,}?\"\nBWS = OWS\n\n# RFC 7230 Section 3.2.6 \"Field Value Components\":\n# tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n#                / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n#                / DIGIT / ALPHA\n# obs-text      = %x80-FF\nTCHAR = r\"[!#$%&'*+\\-.^_`|~0-9A-Za-z]\"\nOBS_TEXT = r\"\\x80-\\xff\"\n\nTOKEN = TCHAR + \"{1,}\"\n\n# RFC 5234 Appendix B.1 \"Core Rules\":\n# VCHAR         =  %x21-7E\n#                  ; visible (printing) characters\nVCHAR = r\"\\x21-\\x7e\"\n\n# header-field   = field-name \":\" OWS field-value OWS\n# field-name     = token\n# field-value    = *( field-content / obs-fold )\n# field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n# field-vchar    = VCHAR / obs-text\n\n# Errata from: https://www.rfc-editor.org/errata_search.php?rfc=7230&eid=4189\n# changes field-content to:\n#\n# field-content  = field-vchar [ 1*( SP / HTAB / field-vchar )\n#                  field-vchar ]\n\nFIELD_VCHAR = \"[\" + VCHAR + OBS_TEXT + \"]\"\n# Field content is more greedy than the ABNF, in that it will match the whole value\nFIELD_CONTENT = FIELD_VCHAR + \"+(?:[ \\t]+\" + FIELD_VCHAR + \"+)*\"\n# Which allows the field value here to just see if there is even a value in the first place\nFIELD_VALUE = \"(?:\" + FIELD_CONTENT + \")?\"\n\nHEADER_FIELD = re.compile(\n    tobytes(\n        \"^(?P<name>\" + TOKEN + \"):\" + OWS + \"(?P<value>\" + FIELD_VALUE + \")\" + OWS + \"$\"\n    )\n)\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\n\"\"\"HTTP Request Parser tests\n\"\"\"\nimport unittest\n\nfrom waitress.compat import text_, tobytes\n\n\nclass TestHTTPRequestParser(unittest.TestCase):\n    def setUp(self):\n        from waitress.parser import HTTPRequestParser\n        from waitress.adjustments import Adjustments\n\n        my_adj = Adjustments()\n        self.parser = HTTPRequestParser(my_adj)\n\n    def test_get_body_stream_None(self):\n        self.parser.body_recv = None\n        result = self.parser.get_body_stream()\n        self.assertEqual(result.getvalue(), b\"\")\n\n    def test_get_body_stream_nonNone(self):\n        body_rcv = DummyBodyStream()\n        self.parser.body_rcv = body_rcv\n        result = self.parser.get_body_stream()\n        self.assertEqual(result, body_rcv)\n\n    def test_received_get_no_headers(self):\n        data = b\"HTTP/1.0 GET /foobar\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 24)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_bad_host_header(self):\n        from waitress.utilities import BadRequest\n\n        data = b\"HTTP/1.0 GET /foobar\\r\\n Host: foo\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 36)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.error.__class__, BadRequest)\n\n    def test_received_bad_transfer_encoding(self):\n        from waitress.utilities import ServerNotImplemented\n\n        data = (\n            b\"GET /foobar HTTP/1.1\\r\\n\"\n            b\"Transfer-Encoding: foo\\r\\n\"\n            b\"\\r\\n\"\n            b\"1d;\\r\\n\"\n            b\"This string has 29 characters\\r\\n\"\n            b\"0\\r\\n\\r\\n\"\n        )\n        result = self.parser.received(data)\n        self.assertEqual(result, 48)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.error.__class__, ServerNotImplemented)\n\n    def test_received_nonsense_nothing(self):\n        data = b\"\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 4)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_no_doublecr(self):\n        data = b\"GET /foobar HTTP/8.4\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 22)\n        self.assertFalse(self.parser.completed)\n        self.assertEqual(self.parser.headers, {})\n\n    def test_received_already_completed(self):\n        self.parser.completed = True\n        result = self.parser.received(b\"a\")\n        self.assertEqual(result, 0)\n\n    def test_received_cl_too_large(self):\n        from waitress.utilities import RequestEntityTooLarge\n\n        self.parser.adj.max_request_body_size = 2\n        data = b\"GET /foobar HTTP/8.4\\r\\nContent-Length: 10\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 44)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))\n\n    def test_received_headers_too_large(self):\n        from waitress.utilities import RequestHeaderFieldsTooLarge\n\n        self.parser.adj.max_request_header_size = 2\n        data = b\"GET /foobar HTTP/8.4\\r\\nX-Foo: 1\\r\\n\\r\\n\"\n        result = self.parser.received(data)\n        self.assertEqual(result, 34)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestHeaderFieldsTooLarge))\n\n    def test_received_body_too_large(self):\n        from waitress.utilities import RequestEntityTooLarge\n\n        self.parser.adj.max_request_body_size = 2\n        data = (\n            b\"GET /foobar HTTP/1.1\\r\\n\"\n            b\"Transfer-Encoding: chunked\\r\\n\"\n            b\"X-Foo: 1\\r\\n\"\n            b\"\\r\\n\"\n            b\"1d;\\r\\n\"\n            b\"This string has 29 characters\\r\\n\"\n            b\"0\\r\\n\\r\\n\"\n        )\n\n        result = self.parser.received(data)\n        self.assertEqual(result, 62)\n        self.parser.received(data[result:])\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))\n\n    def test_received_error_from_parser(self):\n        from waitress.utilities import BadRequest\n\n        data = (\n            b\"GET /foobar HTTP/1.1\\r\\n\"\n            b\"Transfer-Encoding: chunked\\r\\n\"\n            b\"X-Foo: 1\\r\\n\"\n            b\"\\r\\n\"\n            b\"garbage\\r\\n\"\n        )\n        # header\n        result = self.parser.received(data)\n        # body\n        result = self.parser.received(data[result:])\n        self.assertEqual(result, 9)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(isinstance(self.parser.error, BadRequest))\n\n    def test_received_chunked_completed_sets_content_length(self):\n        data = (\n            b\"GET /foobar HTTP/1.1\\r\\n\"\n            b\"Transfer-Encoding: chunked\\r\\n\"\n            b\"X-Foo: 1\\r\\n\"\n            b\"\\r\\n\"\n            b\"1d;\\r\\n\"\n            b\"This string has 29 characters\\r\\n\"\n            b\"0\\r\\n\\r\\n\"\n        )\n        result = self.parser.received(data)\n        self.assertEqual(result, 62)\n        data = data[result:]\n        result = self.parser.received(data)\n        self.assertTrue(self.parser.completed)\n        self.assertTrue(self.parser.error is None)\n        self.assertEqual(self.parser.headers[\"CONTENT_LENGTH\"], \"29\")\n\n    def test_parse_header_gardenpath(self):\n        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: bar\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.first_line, b\"GET /foobar HTTP/8.4\")\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar\")\n\n    def test_parse_header_no_cr_in_headerplus(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\"\n\n        try:\n            self.parser.parse_header(data)\n        except ParsingError:\n            pass\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_bad_content_length(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: abc\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Content-Length is invalid\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_multiple_content_length(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: 10\\r\\ncontent-length: 20\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Content-Length is invalid\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_11_te_chunked(self):\n        # NB: test that capitalization of header value is unimportant\n        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: ChUnKed\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.body_rcv.__class__.__name__, \"ChunkedReceiver\")\n\n    def test_parse_header_transfer_encoding_invalid(self):\n        from waitress.parser import TransferEncodingNotImplemented\n\n        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: gzip\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except TransferEncodingNotImplemented as e:\n            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_transfer_encoding_invalid_multiple(self):\n        from waitress.parser import TransferEncodingNotImplemented\n\n        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: gzip\\r\\ntransfer-encoding: chunked\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except TransferEncodingNotImplemented as e:\n            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_transfer_encoding_invalid_whitespace(self):\n        from waitress.parser import TransferEncodingNotImplemented\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nTransfer-Encoding:\\x85chunked\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except TransferEncodingNotImplemented as e:\n            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_transfer_encoding_invalid_unicode(self):\n        from waitress.parser import TransferEncodingNotImplemented\n\n        # This is the binary encoding for the UTF-8 character\n        # https://www.compart.com/en/unicode/U+212A \"unicode character \"K\"\"\n        # which if waitress were to accidentally do the wrong thing get\n        # lowercased to just the ascii \"k\" due to unicode collisions during\n        # transformation\n        data = b\"GET /foobar HTTP/1.1\\r\\nTransfer-Encoding: chun\\xe2\\x84\\xaaed\\r\\n\"\n\n        try:\n            self.parser.parse_header(data)\n        except TransferEncodingNotImplemented as e:\n            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_11_expect_continue(self):\n        data = b\"GET /foobar HTTP/1.1\\r\\nexpect: 100-continue\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.expect_continue, True)\n\n    def test_parse_header_connection_close(self):\n        data = b\"GET /foobar HTTP/1.1\\r\\nConnection: close\\r\\n\"\n        self.parser.parse_header(data)\n        self.assertEqual(self.parser.connection_close, True)\n\n    def test_close_with_body_rcv(self):\n        body_rcv = DummyBodyStream()\n        self.parser.body_rcv = body_rcv\n        self.parser.close()\n        self.assertTrue(body_rcv.closed)\n\n    def test_close_with_no_body_rcv(self):\n        self.parser.body_rcv = None\n        self.parser.close()  # doesn't raise\n\n    def test_parse_header_lf_only(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\nfoo: bar\"\n\n        try:\n            self.parser.parse_header(data)\n        except ParsingError:\n            pass\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_cr_only(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\rfoo: bar\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError:\n            pass\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_extra_lf_in_header(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: \\nbar\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Bare CR or LF found in header line\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_extra_lf_in_first_line(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar\\n HTTP/8.4\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Bare CR or LF found in HTTP message\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_invalid_whitespace(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/8.4\\r\\nfoo : bar\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Invalid header\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_invalid_whitespace_vtab(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo:\\x0bbar\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Invalid header\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_invalid_no_colon(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\nnotvalid\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Invalid header\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_invalid_folding_spacing(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\n\\t\\x0bbaz\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Invalid header\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_invalid_chars(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\nfoo: \\x0bbaz\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Invalid header\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_empty(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\nempty:\\r\\n\"\n        self.parser.parse_header(data)\n\n        self.assertIn(\"EMPTY\", self.parser.headers)\n        self.assertIn(\"FOO\", self.parser.headers)\n        self.assertEqual(self.parser.headers[\"EMPTY\"], \"\")\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar\")\n\n    def test_parse_header_multiple_values(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever, more, please, yes\\r\\n\"\n        self.parser.parse_header(data)\n\n        self.assertIn(\"FOO\", self.parser.headers)\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")\n\n    def test_parse_header_multiple_values_header_folded(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever,\\r\\n more, please, yes\\r\\n\"\n        self.parser.parse_header(data)\n\n        self.assertIn(\"FOO\", self.parser.headers)\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")\n\n    def test_parse_header_multiple_values_header_folded_multiple(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever,\\r\\n more\\r\\nfoo: please, yes\\r\\n\"\n        self.parser.parse_header(data)\n\n        self.assertIn(\"FOO\", self.parser.headers)\n        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")\n\n    def test_parse_header_multiple_values_extra_space(self):\n        # Tests errata from: https://www.rfc-editor.org/errata_search.php?rfc=7230&eid=4189\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: abrowser/0.001 (C O M M E N T)\\r\\n\"\n        self.parser.parse_header(data)\n\n        self.assertIn(\"FOO\", self.parser.headers)\n        self.assertEqual(self.parser.headers[\"FOO\"], \"abrowser/0.001 (C O M M E N T)\")\n\n    def test_parse_header_invalid_backtrack_bad(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\nfoo: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\x10\\r\\n\"\n        try:\n            self.parser.parse_header(data)\n        except ParsingError as e:\n            self.assertIn(\"Invalid header\", e.args[0])\n        else:  # pragma: nocover\n            self.assertTrue(False)\n\n    def test_parse_header_short_values(self):\n        from waitress.parser import ParsingError\n\n        data = b\"GET /foobar HTTP/1.1\\r\\none: 1\\r\\ntwo: 22\\r\\n\"\n        self.parser.parse_header(data)\n\n        self.assertIn(\"ONE\", self.parser.headers)\n        self.assertIn(\"TWO\", self.parser.headers)\n        self.assertEqual(self.parser.headers[\"ONE\"], \"1\")\n        self.assertEqual(self.parser.headers[\"TWO\"], \"22\")\n\n\nclass Test_split_uri(unittest.TestCase):\n    def _callFUT(self, uri):\n        from waitress.parser import split_uri\n\n        (\n            self.proxy_scheme,\n            self.proxy_netloc,\n            self.path,\n            self.query,\n            self.fragment,\n        ) = split_uri(uri)\n\n    def test_split_uri_unquoting_unneeded(self):\n        self._callFUT(b\"http://localhost:8080/abc def\")\n        self.assertEqual(self.path, \"/abc def\")\n\n    def test_split_uri_unquoting_needed(self):\n        self._callFUT(b\"http://localhost:8080/abc%20def\")\n        self.assertEqual(self.path, \"/abc def\")\n\n    def test_split_url_with_query(self):\n        self._callFUT(b\"http://localhost:8080/abc?a=1&b=2\")\n        self.assertEqual(self.path, \"/abc\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n\n    def test_split_url_with_query_empty(self):\n        self._callFUT(b\"http://localhost:8080/abc?\")\n        self.assertEqual(self.path, \"/abc\")\n        self.assertEqual(self.query, \"\")\n\n    def test_split_url_with_fragment(self):\n        self._callFUT(b\"http://localhost:8080/#foo\")\n        self.assertEqual(self.path, \"/\")\n        self.assertEqual(self.fragment, \"foo\")\n\n    def test_split_url_https(self):\n        self._callFUT(b\"https://localhost:8080/\")\n        self.assertEqual(self.path, \"/\")\n        self.assertEqual(self.proxy_scheme, \"https\")\n        self.assertEqual(self.proxy_netloc, \"localhost:8080\")\n\n    def test_split_uri_unicode_error_raises_parsing_error(self):\n        # See https://github.com/Pylons/waitress/issues/64\n        from waitress.parser import ParsingError\n\n        # Either pass or throw a ParsingError, just don't throw another type of\n        # exception as that will cause the connection to close badly:\n        try:\n            self._callFUT(b\"/\\xd0\")\n        except ParsingError:\n            pass\n\n    def test_split_uri_path(self):\n        self._callFUT(b\"//testing/whatever\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"\")\n        self.assertEqual(self.fragment, \"\")\n\n    def test_split_uri_path_query(self):\n        self._callFUT(b\"//testing/whatever?a=1&b=2\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n        self.assertEqual(self.fragment, \"\")\n\n    def test_split_uri_path_query_fragment(self):\n        self._callFUT(b\"//testing/whatever?a=1&b=2#fragment\")\n        self.assertEqual(self.path, \"//testing/whatever\")\n        self.assertEqual(self.proxy_scheme, \"\")\n        self.assertEqual(self.proxy_netloc, \"\")\n        self.assertEqual(self.query, \"a=1&b=2\")\n        self.assertEqual(self.fragment, \"fragment\")\n\n\nclass Test_get_header_lines(unittest.TestCase):\n    def _callFUT(self, data):\n        from waitress.parser import get_header_lines\n\n        return get_header_lines(data)\n\n    def test_get_header_lines(self):\n        result = self._callFUT(b\"slam\\r\\nslim\")\n        self.assertEqual(result, [b\"slam\", b\"slim\"])\n\n    def test_get_header_lines_folded(self):\n        # From RFC2616:\n        # HTTP/1.1 header field values can be folded onto multiple lines if the\n        # continuation line begins with a space or horizontal tab. All linear\n        # white space, including folding, has the same semantics as SP. A\n        # recipient MAY replace any linear white space with a single SP before\n        # interpreting the field value or forwarding the message downstream.\n\n        # We are just preserving the whitespace that indicates folding.\n        result = self._callFUT(b\"slim\\r\\n slam\")\n        self.assertEqual(result, [b\"slim slam\"])\n\n    def test_get_header_lines_tabbed(self):\n        result = self._callFUT(b\"slam\\r\\n\\tslim\")\n        self.assertEqual(result, [b\"slam\\tslim\"])\n\n    def test_get_header_lines_malformed(self):\n        # https://corte.si/posts/code/pathod/pythonservers/index.html\n        from waitress.parser import ParsingError\n\n        self.assertRaises(ParsingError, self._callFUT, b\" Host: localhost\\r\\n\\r\\n\")\n\n\nclass Test_crack_first_line(unittest.TestCase):\n    def _callFUT(self, line):\n        from waitress.parser import crack_first_line\n\n        return crack_first_line(line)\n\n    def test_crack_first_line_matchok(self):\n        result = self._callFUT(b\"GET / HTTP/1.0\")\n        self.assertEqual(result, (b\"GET\", b\"/\", b\"1.0\"))\n\n    def test_crack_first_line_lowercase_method(self):\n        from waitress.parser import ParsingError\n\n        self.assertRaises(ParsingError, self._callFUT, b\"get / HTTP/1.0\")\n\n    def test_crack_first_line_nomatch(self):\n        result = self._callFUT(b\"GET / bleh\")\n        self.assertEqual(result, (b\"\", b\"\", b\"\"))\n\n        result = self._callFUT(b\"GET /info?txtAirPlay&txtRAOP RTSP/1.0\")\n        self.assertEqual(result, (b\"\", b\"\", b\"\"))\n\n    def test_crack_first_line_missing_version(self):\n        result = self._callFUT(b\"GET /\")\n        self.assertEqual(result, (b\"GET\", b\"/\", b\"\"))\n\n\nclass TestHTTPRequestParserIntegration(unittest.TestCase):\n    def setUp(self):\n        from waitress.parser import HTTPRequestParser\n        from waitress.adjustments import Adjustments\n\n        my_adj = Adjustments()\n        self.parser = HTTPRequestParser(my_adj)\n\n    def feed(self, data):\n        parser = self.parser\n\n        for n in range(100):  # make sure we never loop forever\n            consumed = parser.received(data)\n            data = data[consumed:]\n\n            if parser.completed:\n                return\n        raise ValueError(\"Looping\")  # pragma: no cover\n\n    def testSimpleGET(self):\n        data = (\n            b\"GET /foobar HTTP/8.4\\r\\n\"\n            b\"FirstName: mickey\\r\\n\"\n            b\"lastname: Mouse\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        parser = self.parser\n        self.feed(data)\n        self.assertTrue(parser.completed)\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(\n            parser.headers,\n            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"6\",},\n        )\n        self.assertEqual(parser.path, \"/foobar\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.query, \"\")\n        self.assertEqual(parser.proxy_scheme, \"\")\n        self.assertEqual(parser.proxy_netloc, \"\")\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")\n\n    def testComplexGET(self):\n        data = (\n            b\"GET /foo/a+%2B%2F%C3%A4%3D%26a%3Aint?d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6 HTTP/8.4\\r\\n\"\n            b\"FirstName: mickey\\r\\n\"\n            b\"lastname: Mouse\\r\\n\"\n            b\"content-length: 10\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello mickey.\"\n        )\n        parser = self.parser\n        self.feed(data)\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(\n            parser.headers,\n            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"10\"},\n        )\n        # path should be utf-8 encoded\n        self.assertEqual(\n            tobytes(parser.path).decode(\"utf-8\"),\n            text_(b\"/foo/a++/\\xc3\\xa4=&a:int\", \"utf-8\"),\n        )\n        self.assertEqual(\n            parser.query, \"d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6\"\n        )\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello mick\")\n\n    def testProxyGET(self):\n        data = (\n            b\"GET https://example.com:8080/foobar HTTP/8.4\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        parser = self.parser\n        self.feed(data)\n        self.assertTrue(parser.completed)\n        self.assertEqual(parser.version, \"8.4\")\n        self.assertFalse(parser.empty)\n        self.assertEqual(parser.headers, {\"CONTENT_LENGTH\": \"6\"})\n        self.assertEqual(parser.path, \"/foobar\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.proxy_scheme, \"https\")\n        self.assertEqual(parser.proxy_netloc, \"example.com:8080\")\n        self.assertEqual(parser.command, \"GET\")\n        self.assertEqual(parser.query, \"\")\n        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")\n\n    def testDuplicateHeaders(self):\n        # Ensure that headers with the same key get concatenated as per\n        # RFC2616.\n        data = (\n            b\"GET /foobar HTTP/8.4\\r\\n\"\n            b\"x-forwarded-for: 10.11.12.13\\r\\n\"\n            b\"x-forwarded-for: unknown,127.0.0.1\\r\\n\"\n            b\"X-Forwarded_for: 255.255.255.255\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        self.feed(data)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(\n            self.parser.headers,\n            {\n                \"CONTENT_LENGTH\": \"6\",\n                \"X_FORWARDED_FOR\": \"10.11.12.13, unknown,127.0.0.1\",\n            },\n        )\n\n    def testSpoofedHeadersDropped(self):\n        data = (\n            b\"GET /foobar HTTP/8.4\\r\\n\"\n            b\"x-auth_user: bob\\r\\n\"\n            b\"content-length: 6\\r\\n\"\n            b\"\\r\\n\"\n            b\"Hello.\"\n        )\n        self.feed(data)\n        self.assertTrue(self.parser.completed)\n        self.assertEqual(self.parser.headers, {\"CONTENT_LENGTH\": \"6\",})\n\n\nclass DummyBodyStream(object):\n    def getfile(self):\n        return self\n\n    def getbuf(self):\n        return self\n\n    def close(self):\n        self.closed = True\n"], "filenames": ["waitress/rfc7230.py", "waitress/tests/test_parser.py"], "buggy_code_start_loc": [43, 57], "buggy_code_end_loc": [53, 434], "fixing_code_start_loc": [43, 58], "fixing_code_end_loc": [52, 457], "type": "CWE-400", "message": "Waitress version 1.4.2 allows a DOS attack When waitress receives a header that contains invalid characters. When a header like \"Bad-header: xxxxxxxxxxxxxxx\\x10\" is received, it will cause the regular expression engine to catastrophically backtrack causing the process to use 100% CPU time and blocking any other interactions. This allows an attacker to send a single request with an invalid header and take the service offline. This issue was introduced in version 1.4.2 when the regular expression was updated to attempt to match the behaviour required by errata associated with RFC7230. The regular expression that is used to validate incoming headers has been updated in version 1.4.3, it is recommended that people upgrade to the new version of Waitress as soon as possible.", "other": {"cve": {"id": "CVE-2020-5236", "sourceIdentifier": "security-advisories@github.com", "published": "2020-02-04T03:15:10.750", "lastModified": "2020-02-06T18:46:27.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Waitress version 1.4.2 allows a DOS attack When waitress receives a header that contains invalid characters. When a header like \"Bad-header: xxxxxxxxxxxxxxx\\x10\" is received, it will cause the regular expression engine to catastrophically backtrack causing the process to use 100% CPU time and blocking any other interactions. This allows an attacker to send a single request with an invalid header and take the service offline. This issue was introduced in version 1.4.2 when the regular expression was updated to attempt to match the behaviour required by errata associated with RFC7230. The regular expression that is used to validate incoming headers has been updated in version 1.4.3, it is recommended that people upgrade to the new version of Waitress as soon as possible."}, {"lang": "es", "value": "Waitress versi\u00f3n 1.4.2, permite un ataque de DOS cuando waitress recibe un encabezado que contiene caracteres no v\u00e1lidos. Cuando un encabezado como \"Bad-header: xxxxxxxxxxxxxxx\\x10\" es recibido, causar\u00e1 que el motor de expresi\u00f3n regular retroceda catastr\u00f3ficamente, provocando que el proceso utilice el 100% del tiempo de CPU y bloquee cualquier otras interacciones. Esto permite a un atacante enviar una \u00fanica petici\u00f3n con un encabezado no v\u00e1lido y desconectar el servicio. Este problema fue introducido en la versi\u00f3n 1.4.2 cuando se actualiz\u00f3 la expresi\u00f3n regular para intentar hacer coincidir el comportamiento requerido por las erratas asociadas con RFC7230. La expresi\u00f3n regular que se usa para comprobar los encabezados entrantes se actualiz\u00f3 en la versi\u00f3n 1.4.3, se recomienda que las personas actualicen a la nueva versi\u00f3n de Waitress tan pronto como sea posible."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:agendaless:waitress:1.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "3C433875-4299-4F58-AB6A-D7E9A815329B"}]}]}], "references": [{"url": "https://github.com/Pylons/waitress/commit/6e46f9e3f014d64dd7d1e258eaf626e39870ee1f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Pylons/waitress/security/advisories/GHSA-73m2-3pwg-5fgc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Pylons/waitress/commit/6e46f9e3f014d64dd7d1e258eaf626e39870ee1f"}}