{"buggy_code": ["'use strict';\n\nfunction clone(value) {\n  if (typeof value === 'object' && value !== null) {\n    return _merge(Array.isArray(value) ? [] : {}, value);\n  }\n  return value;\n}\n\nfunction isObjectOrArrayOrFunction(value) {\n  return (\n    typeof value === 'function' ||\n    Array.isArray(value) ||\n    Object.prototype.toString.call(value) === '[object Object]'\n  );\n}\n\nfunction _merge(target, source) {\n  if (target === source) {\n    return target;\n  }\n\n  for (var key in source) {\n    if (!Object.prototype.hasOwnProperty.call(source, key)) {\n      continue;\n    }\n\n    var sourceVal = source[key];\n    var targetVal = target[key];\n\n    if (typeof targetVal !== 'undefined' && typeof sourceVal === 'undefined') {\n      continue;\n    }\n\n    if (isObjectOrArrayOrFunction(targetVal) && isObjectOrArrayOrFunction(sourceVal)) {\n      target[key] = _merge(targetVal, sourceVal);\n    } else {\n      target[key] = clone(sourceVal);\n    }\n  }\n  return target;\n}\n\n/**\n * This method is like Object.assign, but recursively merges own and inherited\n * enumerable keyed properties of source objects into the destination object.\n *\n * NOTE: this behaves like lodash/merge, but:\n * - does mutate functions if they are a source\n * - treats non-plain objects as plain\n * - does not work for circular objects\n * - treats sparse arrays as sparse\n * - does not convert Array-like objects (Arguments, NodeLists, etc.) to arrays\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n */\n\nfunction merge(target) {\n  if (!isObjectOrArrayOrFunction(target)) {\n    target = {};\n  }\n\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    var source = arguments[i];\n\n    if (isObjectOrArrayOrFunction(source)) {\n      _merge(target, source);\n    }\n  }\n  return target;\n}\n\nmodule.exports = merge;\n", "'use strict';\n\nvar clone = require('lodash/clone');\nvar defaults = require('../../../src/functions/defaultsPure');\n\n// tests modified from lodash source\n\nit('should assign source properties if missing on `object`', function() {\n  var actual = defaults({'a': 1}, {'a': 2, 'b': 2});\n  expect(actual).toEqual({'a': 1, 'b': 2});\n});\n\nit('should accept multiple sources', function() {\n  var expected = {'a': 1, 'b': 2, 'c': 3};\n  var actual = defaults({'a': 1, 'b': 2}, {'b': 3}, {'c': 3});\n\n  expect(actual).toEqual(expected);\n\n  actual = defaults({'a': 1, 'b': 2}, {'b': 3, 'c': 3}, {'c': 2});\n  expect(actual).toEqual(expected);\n});\n\nit('should not overwrite `null` values', function() {\n  var actual = defaults({'a': null}, {'a': 1});\n  expect(actual.a).toBe(null);\n});\n\nit('should overwrite `undefined` values', function() {\n  var actual = defaults({'a': undefined}, {'a': 1});\n  expect(actual.a).toBe(1);\n});\n\nit('should assign `undefined` values', function() {\n  var source = {'a': undefined, 'b': 1};\n  var actual = defaults({}, source);\n\n  expect(actual).toEqual({'a': undefined, 'b': 1});\n});\n\nit('should assign properties that shadow those on `Object.prototype`', function() {\n  var object = {\n    'constructor': Object.prototype.constructor,\n    'hasOwnProperty': Object.prototype.hasOwnProperty,\n    'isPrototypeOf': Object.prototype.isPrototypeOf,\n    'propertyIsEnumerable': Object.prototype.propertyIsEnumerable,\n    'toLocaleString': Object.prototype.toLocaleString,\n    'toString': Object.prototype.toString,\n    'valueOf': Object.prototype.valueOf\n  };\n\n  var source = {\n    'constructor': 1,\n    'hasOwnProperty': 2,\n    'isPrototypeOf': 3,\n    'propertyIsEnumerable': 4,\n    'toLocaleString': 5,\n    'toString': 6,\n    'valueOf': 7\n  };\n\n  var expected = clone(source);\n  expect(defaults({}, source)).toEqual(expected);\n\n  expected = clone(object);\n  expect(defaults({}, object, source)).toEqual(expected);\n});\n\nit('should keep the keys order with facets', function() {\n  var actual = defaults(\n    {},\n    {\n      'Insignia\u2122': 551,\n      'Samsung': 511,\n      'Apple': 386\n    },\n    {\n      'Apple': 386\n    }\n  );\n  expect(Object.keys(actual)).toEqual(['Insignia\u2122', 'Samsung', 'Apple']);\n});\n\nit('should keep the keys order when adding facet refinements', function() {\n  var actual = defaults(\n    {},\n    {\n      'facet2': ['facetValue']\n    },\n    {\n      'facet1': ['facetValue']\n    }\n  );\n  expect(Object.keys(actual)).toEqual(['facet1', 'facet2']);\n});\n", "'use strict';\n\nvar intersection = require('../../../src/functions/intersection');\n\ntest('it should find intersection between two array', function() {\n  var actual = intersection([2, 1], [2]);\n  expect(actual).toStrictEqual([2]);\n});\n\ntest('it should keep the order of the first array', function() {\n  expect(intersection([0, 1, 2, 3, 4], [4, 0, 3])).toStrictEqual([0, 3, 4]);\n});\n\ntest('it should not produce duplicate primitive values', function() {\n  expect(intersection([0, 0, 1, 2], [0, 2])).toStrictEqual([0, 2]);\n  expect(intersection(['0', '0', '1', '2'], ['0', '2'])).toStrictEqual([\n    '0',\n    '2'\n  ]);\n});\n\n", "'use strict';\nconst merge = require('../../../src/functions/merge');\n\nit('should merge `source` into `object`', function() {\n  var names = {\n    characters: [{name: 'barney'}, {name: 'fred'}]\n  };\n\n  var ages = {\n    characters: [{age: 36}, {age: 40}]\n  };\n\n  var heights = {\n    characters: [{height: '5\\'4\"'}, {height: '5\\'5\"'}]\n  };\n\n  var expected = {\n    characters: [\n      {name: 'barney', age: 36, height: '5\\'4\"'},\n      {name: 'fred', age: 40, height: '5\\'5\"'}\n    ]\n  };\n\n  expect(merge(names, ages, heights)).toStrictEqual(expected);\n});\n\nit('should work with four arguments', function() {\n  var expected = {a: 4};\n  var actual = merge({a: 1}, {a: 2}, {a: 3}, expected);\n\n  expect(actual).toStrictEqual(expected);\n});\n\nit('should merge onto function `object` values', function() {\n  function Foo() {}\n\n  var source = {a: 1};\n  var actual = merge(Foo, source);\n\n  expect(actual).toStrictEqual(Foo);\n  expect(Foo.a).toStrictEqual(1);\n});\n\nit('should merge first source object properties to function', function() {\n  var fn = function() {};\n  var object = {prop: {}};\n  var actual = merge({prop: fn}, object);\n\n  expect(actual.prop).toBeInstanceOf(Function);\n});\n\n// TODO: differs from lodash, but seems to make more sense to me\nit('should merge first and second source object properties to function', function() {\n  var fn = function() {};\n  var object = {prop: {dogs: 'out'}};\n  var actual = merge({prop: fn}, {prop: fn}, object);\n\n  expect(actual.prop).toBe(fn);\n  expect(actual.prop.dogs).toBe('out');\n});\n\nit('should merge onto non-plain `object` values', function() {\n  function Foo() {}\n\n  var object = new Foo();\n  var actual = merge(object, {a: 1});\n\n  expect(actual).toBe(object);\n  expect(object.a).toBe(1);\n});\n\nit('should assign `null` values', function() {\n  var actual = merge({a: 1}, {a: null});\n  expect(actual.a).toBe(null);\n});\n\nit('should not augment source objects for inner objects', function() {\n  var source1 = {a: [{a: 1}]};\n  var source2 = {a: [{b: 2}]};\n  var actual = merge({}, source1, source2);\n\n  expect(source1.a).toStrictEqual([{a: 1}]);\n  expect(source2.a).toStrictEqual([{b: 2}]);\n  expect(actual.a).toStrictEqual([{a: 1, b: 2}]);\n});\n\nit('should not augment source objects for inner arrays', function() {\n  var source1 = {a: [[1, 2, 3]]};\n  var source2 = {a: [[3, 4]]};\n  var actual = merge({}, source1, source2);\n\n  expect(source1.a).toStrictEqual([[1, 2, 3]]);\n  expect(source2.a).toStrictEqual([[3, 4]]);\n  expect(actual.a).toStrictEqual([[3, 4, 3]]);\n});\n\nit('should merge plain objects onto non-plain objects', function() {\n  function Foo(object) {\n    Object.assign(this, object);\n  }\n\n  var object = {a: 1};\n  var actual = merge(new Foo(), object);\n\n  expect(actual instanceof Foo).toBe(true);\n  expect(actual).toStrictEqual(new Foo(object));\n\n  actual = merge([new Foo()], [object]);\n  expect(actual[0] instanceof Foo).toBe(true);\n  expect(actual).toStrictEqual([new Foo(object)]);\n});\n\nit('should not overwrite existing values with `undefined` values of object sources', function() {\n  var actual = merge({a: 1}, {a: undefined, b: undefined});\n  expect(actual).toStrictEqual({a: 1, b: undefined});\n});\n\nit('should not overwrite existing values with `undefined` values of array sources', function() {\n  var array = [1];\n  array[2] = 3;\n\n  var actual = merge([4, 5, 6], array);\n  var expected = [1, 5, 3];\n\n  expect(actual).toStrictEqual(expected);\n\n  array = [1, undefined, 3];\n\n  actual = merge([4, 5, 6], array);\n  expect(actual).toStrictEqual(expected);\n});\n\nit('should skip merging when `object` and `source` are the same value', function() {\n  var object = {};\n  var pass = true;\n\n  Object.defineProperty(object, 'a', {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      pass = false;\n    },\n    set: function() {\n      pass = false;\n    }\n  });\n\n  merge(object, object);\n  expect(pass).toBe(true);\n});\n\nit('should not convert objects to arrays when merging arrays of `source`', function() {\n  var object = {a: {'1': 'y', 'b': 'z', 'length': 2}};\n  var actual = merge(object, {a: ['x']});\n\n  expect(actual).toStrictEqual({a: {\n    '0': 'x',\n    '1': 'y',\n    'b': 'z',\n    'length': 2\n  }});\n\n  actual = merge({a: {}}, {a: []});\n  expect(actual).toStrictEqual({a: {}});\n});\n\nit('should not convert strings to arrays when merging arrays of `source`', function() {\n  var object = {a: 'abcde'};\n  var actual = merge(object, {a: ['x', 'y', 'z']});\n\n  expect(actual).toStrictEqual({a: ['x', 'y', 'z']});\n});\n"], "fixing_code": ["'use strict';\n\nfunction clone(value) {\n  if (typeof value === 'object' && value !== null) {\n    return _merge(Array.isArray(value) ? [] : {}, value);\n  }\n  return value;\n}\n\nfunction isObjectOrArrayOrFunction(value) {\n  return (\n    typeof value === 'function' ||\n    Array.isArray(value) ||\n    Object.prototype.toString.call(value) === '[object Object]'\n  );\n}\n\nfunction _merge(target, source) {\n  if (target === source) {\n    return target;\n  }\n\n  for (var key in source) {\n    if (\n      !Object.prototype.hasOwnProperty.call(source, key) ||\n      key === '__proto__'\n    ) {\n      continue;\n    }\n\n    var sourceVal = source[key];\n    var targetVal = target[key];\n\n    if (typeof targetVal !== 'undefined' && typeof sourceVal === 'undefined') {\n      continue;\n    }\n\n    if (\n      isObjectOrArrayOrFunction(targetVal) &&\n      isObjectOrArrayOrFunction(sourceVal)\n    ) {\n      target[key] = _merge(targetVal, sourceVal);\n    } else {\n      target[key] = clone(sourceVal);\n    }\n  }\n  return target;\n}\n\n/**\n * This method is like Object.assign, but recursively merges own and inherited\n * enumerable keyed properties of source objects into the destination object.\n *\n * NOTE: this behaves like lodash/merge, but:\n * - does mutate functions if they are a source\n * - treats non-plain objects as plain\n * - does not work for circular objects\n * - treats sparse arrays as sparse\n * - does not convert Array-like objects (Arguments, NodeLists, etc.) to arrays\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n */\n\nfunction merge(target) {\n  if (!isObjectOrArrayOrFunction(target)) {\n    target = {};\n  }\n\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    var source = arguments[i];\n\n    if (isObjectOrArrayOrFunction(source)) {\n      _merge(target, source);\n    }\n  }\n  return target;\n}\n\nmodule.exports = merge;\n", "'use strict';\n\nvar clone = require('lodash/clone');\nvar defaults = require('../../../src/functions/defaultsPure');\n\n// tests modified from lodash source\n\nit('should assign source properties if missing on `object`', function() {\n  var actual = defaults({'a': 1}, {'a': 2, 'b': 2});\n  expect(actual).toEqual({'a': 1, 'b': 2});\n});\n\nit('should accept multiple sources', function() {\n  var expected = {'a': 1, 'b': 2, 'c': 3};\n  var actual = defaults({'a': 1, 'b': 2}, {'b': 3}, {'c': 3});\n\n  expect(actual).toEqual(expected);\n\n  actual = defaults({'a': 1, 'b': 2}, {'b': 3, 'c': 3}, {'c': 2});\n  expect(actual).toEqual(expected);\n});\n\nit('should not overwrite `null` values', function() {\n  var actual = defaults({'a': null}, {'a': 1});\n  expect(actual.a).toBe(null);\n});\n\nit('should overwrite `undefined` values', function() {\n  var actual = defaults({'a': undefined}, {'a': 1});\n  expect(actual.a).toBe(1);\n});\n\nit('should assign `undefined` values', function() {\n  var source = {'a': undefined, 'b': 1};\n  var actual = defaults({}, source);\n\n  expect(actual).toEqual({'a': undefined, 'b': 1});\n});\n\nit('should assign properties that shadow those on `Object.prototype`', function() {\n  var object = {\n    'constructor': Object.prototype.constructor,\n    'hasOwnProperty': Object.prototype.hasOwnProperty,\n    'isPrototypeOf': Object.prototype.isPrototypeOf,\n    'propertyIsEnumerable': Object.prototype.propertyIsEnumerable,\n    'toLocaleString': Object.prototype.toLocaleString,\n    'toString': Object.prototype.toString,\n    'valueOf': Object.prototype.valueOf\n  };\n\n  var source = {\n    'constructor': 1,\n    'hasOwnProperty': 2,\n    'isPrototypeOf': 3,\n    'propertyIsEnumerable': 4,\n    'toLocaleString': 5,\n    'toString': 6,\n    'valueOf': 7\n  };\n\n  var expected = clone(source);\n  expect(defaults({}, source)).toEqual(expected);\n\n  expected = clone(object);\n  expect(defaults({}, object, source)).toEqual(expected);\n});\n\nit('should keep the keys order with facets', function() {\n  var actual = defaults(\n    {},\n    {\n      'Insignia\u2122': 551,\n      'Samsung': 511,\n      'Apple': 386\n    },\n    {\n      'Apple': 386\n    }\n  );\n  expect(Object.keys(actual)).toEqual(['Insignia\u2122', 'Samsung', 'Apple']);\n});\n\nit('should keep the keys order when adding facet refinements', function() {\n  var actual = defaults(\n    {},\n    {\n      'facet2': ['facetValue']\n    },\n    {\n      'facet1': ['facetValue']\n    }\n  );\n  expect(Object.keys(actual)).toEqual(['facet1', 'facet2']);\n});\n\nit('does not pollute the prototype', () => {\n  var payload = JSON.parse('{\"__proto__\": {\"polluted\": \"vulnerable to PP\"}}');\n  var subject = {};\n\n  expect(subject.polluted).toBe(undefined);\n\n  const out = defaults({}, payload);\n\n  expect(out).toEqual({});\n\n  expect({}.polluted).toBe(undefined);\n});\n", "'use strict';\n\nvar intersection = require('../../../src/functions/intersection');\n\ntest('it should find intersection between two array', function() {\n  var actual = intersection([2, 1], [2]);\n  expect(actual).toStrictEqual([2]);\n});\n\ntest('it should keep the order of the first array', function() {\n  expect(intersection([0, 1, 2, 3, 4], [4, 0, 3])).toStrictEqual([0, 3, 4]);\n});\n\ntest('it should not produce duplicate primitive values', function() {\n  expect(intersection([0, 0, 1, 2], [0, 2])).toStrictEqual([0, 2]);\n  expect(intersection(['0', '0', '1', '2'], ['0', '2'])).toStrictEqual([\n    '0',\n    '2'\n  ]);\n});\n", "'use strict';\nconst merge = require('../../../src/functions/merge');\n\nit('should merge `source` into `object`', function() {\n  var names = {\n    characters: [{name: 'barney'}, {name: 'fred'}]\n  };\n\n  var ages = {\n    characters: [{age: 36}, {age: 40}]\n  };\n\n  var heights = {\n    characters: [{height: '5\\'4\"'}, {height: '5\\'5\"'}]\n  };\n\n  var expected = {\n    characters: [\n      {name: 'barney', age: 36, height: '5\\'4\"'},\n      {name: 'fred', age: 40, height: '5\\'5\"'}\n    ]\n  };\n\n  expect(merge(names, ages, heights)).toStrictEqual(expected);\n});\n\nit('should work with four arguments', function() {\n  var expected = {a: 4};\n  var actual = merge({a: 1}, {a: 2}, {a: 3}, expected);\n\n  expect(actual).toStrictEqual(expected);\n});\n\nit('should merge onto function `object` values', function() {\n  function Foo() {}\n\n  var source = {a: 1};\n  var actual = merge(Foo, source);\n\n  expect(actual).toStrictEqual(Foo);\n  expect(Foo.a).toStrictEqual(1);\n});\n\nit('should merge first source object properties to function', function() {\n  var fn = function() {};\n  var object = {prop: {}};\n  var actual = merge({prop: fn}, object);\n\n  expect(actual.prop).toBeInstanceOf(Function);\n});\n\n// TODO: differs from lodash, but seems to make more sense to me\nit('should merge first and second source object properties to function', function() {\n  var fn = function() {};\n  var object = {prop: {dogs: 'out'}};\n  var actual = merge({prop: fn}, {prop: fn}, object);\n\n  expect(actual.prop).toBe(fn);\n  expect(actual.prop.dogs).toBe('out');\n});\n\nit('should merge onto non-plain `object` values', function() {\n  function Foo() {}\n\n  var object = new Foo();\n  var actual = merge(object, {a: 1});\n\n  expect(actual).toBe(object);\n  expect(object.a).toBe(1);\n});\n\nit('should assign `null` values', function() {\n  var actual = merge({a: 1}, {a: null});\n  expect(actual.a).toBe(null);\n});\n\nit('should not augment source objects for inner objects', function() {\n  var source1 = {a: [{a: 1}]};\n  var source2 = {a: [{b: 2}]};\n  var actual = merge({}, source1, source2);\n\n  expect(source1.a).toStrictEqual([{a: 1}]);\n  expect(source2.a).toStrictEqual([{b: 2}]);\n  expect(actual.a).toStrictEqual([{a: 1, b: 2}]);\n});\n\nit('should not augment source objects for inner arrays', function() {\n  var source1 = {a: [[1, 2, 3]]};\n  var source2 = {a: [[3, 4]]};\n  var actual = merge({}, source1, source2);\n\n  expect(source1.a).toStrictEqual([[1, 2, 3]]);\n  expect(source2.a).toStrictEqual([[3, 4]]);\n  expect(actual.a).toStrictEqual([[3, 4, 3]]);\n});\n\nit('should merge plain objects onto non-plain objects', function() {\n  function Foo(object) {\n    Object.assign(this, object);\n  }\n\n  var object = {a: 1};\n  var actual = merge(new Foo(), object);\n\n  expect(actual instanceof Foo).toBe(true);\n  expect(actual).toStrictEqual(new Foo(object));\n\n  actual = merge([new Foo()], [object]);\n  expect(actual[0] instanceof Foo).toBe(true);\n  expect(actual).toStrictEqual([new Foo(object)]);\n});\n\nit('should not overwrite existing values with `undefined` values of object sources', function() {\n  var actual = merge({a: 1}, {a: undefined, b: undefined});\n  expect(actual).toStrictEqual({a: 1, b: undefined});\n});\n\nit('should not overwrite existing values with `undefined` values of array sources', function() {\n  var array = [1];\n  array[2] = 3;\n\n  var actual = merge([4, 5, 6], array);\n  var expected = [1, 5, 3];\n\n  expect(actual).toStrictEqual(expected);\n\n  array = [1, undefined, 3];\n\n  actual = merge([4, 5, 6], array);\n  expect(actual).toStrictEqual(expected);\n});\n\nit('should skip merging when `object` and `source` are the same value', function() {\n  var object = {};\n  var pass = true;\n\n  Object.defineProperty(object, 'a', {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      pass = false;\n    },\n    set: function() {\n      pass = false;\n    }\n  });\n\n  merge(object, object);\n  expect(pass).toBe(true);\n});\n\nit('should not convert objects to arrays when merging arrays of `source`', function() {\n  var object = {a: {'1': 'y', 'b': 'z', 'length': 2}};\n  var actual = merge(object, {a: ['x']});\n\n  expect(actual).toStrictEqual({a: {\n    '0': 'x',\n    '1': 'y',\n    'b': 'z',\n    'length': 2\n  }});\n\n  actual = merge({a: {}}, {a: []});\n  expect(actual).toStrictEqual({a: {}});\n});\n\nit('should not convert strings to arrays when merging arrays of `source`', function() {\n  var object = {a: 'abcde'};\n  var actual = merge(object, {a: ['x', 'y', 'z']});\n\n  expect(actual).toStrictEqual({a: ['x', 'y', 'z']});\n});\n\nit('does not pollute the prototype', () => {\n  var payload = JSON.parse('{\"__proto__\": {\"polluted\": \"vulnerable to PP\"}}');\n  var subject = {};\n\n  expect(subject.polluted).toBe(undefined);\n\n  const out = merge({}, payload);\n\n  expect(out).toEqual({});\n\n  expect({}.polluted).toBe(undefined);\n});\n"], "filenames": ["src/functions/merge.js", "test/spec/functions/defaultsPure.js", "test/spec/functions/intersection.js", "test/spec/functions/merge.js"], "buggy_code_start_loc": [24, 94, 21, 172], "buggy_code_end_loc": [36, 94, 22, 172], "fixing_code_start_loc": [24, 95, 20, 173], "fixing_code_end_loc": [42, 108, 20, 186], "type": "CWE-1321", "message": "The package algoliasearch-helper before 3.6.2 are vulnerable to Prototype Pollution due to use of the merge function in src/SearchParameters/index.jsSearchParameters._parseNumbers without any protection against prototype properties. Note that this vulnerability is only exploitable if the implementation allows users to define arbitrary search patterns.", "other": {"cve": {"id": "CVE-2021-23433", "sourceIdentifier": "report@snyk.io", "published": "2021-11-19T20:15:17.903", "lastModified": "2022-06-28T14:11:45.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package algoliasearch-helper before 3.6.2 are vulnerable to Prototype Pollution due to use of the merge function in src/SearchParameters/index.jsSearchParameters._parseNumbers without any protection against prototype properties. Note that this vulnerability is only exploitable if the implementation allows users to define arbitrary search patterns."}, {"lang": "es", "value": "El paquete algoliasearch-helper versiones anteriores a 3.6.2, es vulnerable a una contaminaci\u00f3n de prototipos debido al uso de la funci\u00f3n merge en el archivo src/SearchParameters/index.jsSearchParameters._parseNumbers sin ninguna protecci\u00f3n contra las propiedades del prototipo. Tenga en cuenta que esta vulnerabilidad s\u00f3lo es explotable si la implementaci\u00f3n permite a usuarios definir patrones de b\u00fasqueda arbitrarios"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:algolia:algoliasearch-helper:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.6.2", "matchCriteriaId": "57BA50D8-5658-4579-950F-FC8C3286C6C4"}]}]}], "references": [{"url": "https://github.com/algolia/algoliasearch-helper-js/blob/3.5.5/src/SearchParameters/index.js%23L291", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/algolia/algoliasearch-helper-js/commit/4ff542b70b92a6b81cce8b9255700b0bc0817edd", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-ALGOLIASEARCHHELPER-1570421", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/algolia/algoliasearch-helper-js/commit/4ff542b70b92a6b81cce8b9255700b0bc0817edd"}}