{"buggy_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JP2 Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#include <stdlib.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jp2_cod.h\"\n\n/******************************************************************************\\\n* Function prototypes.\n\\******************************************************************************/\n\n#define\tONES(n)\t((1 << (n)) - 1)\n\njp2_boxinfo_t *jp2_boxinfolookup(int type);\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val);\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val);\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val);\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val);\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val);\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val);\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val);\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val);\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val);\n\njp2_box_t *jp2_box_get(jas_stream_t *in);\nvoid jp2_box_dump(jp2_box_t *box, FILE *out);\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_bpcc_destroy(jp2_box_t *box);\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_colr_destroy(jp2_box_t *box);\nstatic void jp2_cdef_destroy(jp2_box_t *box);\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_cmap_destroy(jp2_box_t *box);\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_pclr_destroy(jp2_box_t *box);\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\njp2_boxinfo_t jp2_boxinfos[] = {\n\t{JP2_BOX_JP, \"JP\", 0,\n\t  {0, 0, jp2_jp_getdata, jp2_jp_putdata, 0}},\n\t{JP2_BOX_FTYP, \"FTYP\", 0,\n\t  {0, 0, jp2_ftyp_getdata, jp2_ftyp_putdata, 0}},\n\t{JP2_BOX_JP2H, \"JP2H\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_IHDR, \"IHDR\", 0,\n\t  {0, 0, jp2_ihdr_getdata, jp2_ihdr_putdata, 0}},\n\t{JP2_BOX_BPCC, \"BPCC\", 0,\n\t  {0, jp2_bpcc_destroy, jp2_bpcc_getdata, jp2_bpcc_putdata, 0}},\n\t{JP2_BOX_COLR, \"COLR\", 0,\n\t  {0, jp2_colr_destroy, jp2_colr_getdata, jp2_colr_putdata, jp2_colr_dumpdata}},\n\t{JP2_BOX_PCLR, \"PCLR\", 0,\n\t  {0, jp2_pclr_destroy, jp2_pclr_getdata, jp2_pclr_putdata, jp2_pclr_dumpdata}},\n\t{JP2_BOX_CMAP, \"CMAP\", 0,\n\t  {0, jp2_cmap_destroy, jp2_cmap_getdata, jp2_cmap_putdata, jp2_cmap_dumpdata}},\n\t{JP2_BOX_CDEF, \"CDEF\", 0,\n\t  {0, jp2_cdef_destroy, jp2_cdef_getdata, jp2_cdef_putdata, jp2_cdef_dumpdata}},\n\t{JP2_BOX_RES, \"RES\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESC, \"RESC\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESD, \"RESD\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2C, \"JP2C\", JP2_BOX_NODATA,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2I, \"JP2I\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_XML, \"XML\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UUID, \"UUID\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UINF, \"UINF\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_ULST, \"ULST\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_URL, \"URL\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{0, 0, 0, {0, 0, 0, 0, 0}},\n};\n\njp2_boxinfo_t jp2_boxinfo_unk = {\n\t0, \"Unknown\", 0, {0, 0, 0, 0, 0}\n};\n\n/******************************************************************************\\\n* Box constructor.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}\n\n/******************************************************************************\\\n* Box destructor.\n\\******************************************************************************/\n\nvoid jp2_box_destroy(jp2_box_t *box)\n{\n\tif (box->ops->destroy) {\n\t\t(*box->ops->destroy)(box);\n\t}\n\tjas_free(box);\n}\n\nstatic void jp2_bpcc_destroy(jp2_box_t *box)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tif (bpcc->bpcs) {\n\t\tjas_free(bpcc->bpcs);\n\t\tbpcc->bpcs = 0;\n\t}\n}\n\nstatic void jp2_cdef_destroy(jp2_box_t *box)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tif (cdef->ents) {\n\t\tjas_free(cdef->ents);\n\t\tcdef->ents = 0;\n\t}\n}\n\n/******************************************************************************\\\n* Box input.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\t// Mark the box data as never having been constructed\n\t\t\t// so that we will not errantly attempt to destroy it later.\n\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n\nvoid jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"', boxinfo->name,\n\t  '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_getuint32(in, &jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_getuint32(in, &ftyp->majver) || jp2_getuint32(in, &ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tftyp->numcompatcodes = (box->datalen - 8) / 4;\n\tif (ftyp->numcompatcodes > JP2_FTYP_MAXCOMPATCODES) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_getuint32(in, &ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_getuint32(in, &ihdr->height) || jp2_getuint32(in, &ihdr->width) ||\n\t  jp2_getuint16(in, &ihdr->numcmpts) || jp2_getuint8(in, &ihdr->bpc) ||\n\t  jp2_getuint8(in, &ihdr->comptype) || jp2_getuint8(in, &ihdr->csunk) ||\n\t  jp2_getuint8(in, &ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tfprintf(out, \"method=%d; pri=%d; approx=%d\\n\", (int)colr->method, (int)colr->pri, (int)colr->approx);\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tfprintf(out, \"csid=%d\\n\", (int)colr->csid);\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tjas_memdump(out, colr->iccp, colr->iccplen);\n\t\tbreak;\n\t}\n}\n\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tcolr->csid = 0;\n\tcolr->iccp = 0;\n\tcolr->iccplen = 0;\n\n\tif (jp2_getuint8(in, &colr->method) || jp2_getuint8(in, &colr->pri) ||\n\t  jp2_getuint8(in, &colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_getuint32(in, &colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tcolr->iccplen = box->datalen - 3;\n\t\tif (!(colr->iccp = jas_alloc2(colr->iccplen, sizeof(uint_fast8_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, colr->iccp, colr->iccplen) != colr->iccplen) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tfprintf(out,\n\t\t  \"channo=%\"PRIuFAST16\"; type=%\"PRIuFAST16\"; assoc=%\"PRIuFAST16\"\\n\",\n\t\t  cdef->ents[i].channo, cdef->ents[i].type, cdef->ents[i].assoc);\n\t}\n}\n\nstatic void jp2_colr_destroy(jp2_box_t *box)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (colr->iccp) {\n\t\tjas_free(colr->iccp);\n\t}\n}\n\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Box output.\n\\******************************************************************************/\n\nint jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}\n\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_putuint32(out, jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_putuint32(out, ftyp->majver) || jp2_putuint32(out, ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_putuint32(out, ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_putuint32(out, ihdr->height) || jp2_putuint32(out, ihdr->width) ||\n\t  jp2_putuint16(out, ihdr->numcmpts) || jp2_putuint8(out, ihdr->bpc) ||\n\t  jp2_putuint8(out, ihdr->comptype) || jp2_putuint8(out, ihdr->csunk) ||\n\t  jp2_putuint8(out, ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_putuint8(out, bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (jp2_putuint8(out, colr->method) || jp2_putuint8(out, colr->pri) ||\n\t  jp2_putuint8(out, colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_putuint32(out, colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tif (jas_stream_write(out, colr->iccp,\n\t\t  JAS_CAST(int, colr->iccplen)) != JAS_CAST(int, colr->iccplen))\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tjp2_cdefchan_t *ent;\n\n\tif (jp2_putuint16(out, cdef->numchans)) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tent = &cdef->ents[i];\n\t\tif (jp2_putuint16(out, ent->channo) ||\n\t\t  jp2_putuint16(out, ent->type) ||\n\t\t  jp2_putuint16(out, ent->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Input operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val)\n{\n\tuint_fast16_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val)\n{\n\tuint_fast32_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val)\n{\n\tuint_fast64_t tmpval;\n\tint i;\n\tint c;\n\n\ttmpval = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\ttmpval <<= 8;\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\ttmpval |= (c & 0xff);\n\t}\n\t*val = tmpval;\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Output operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val)\n{\n\tif (jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val)\n{\n\tif (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val)\n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val)\n{\n\tif (jp2_putuint32(out, (val >> 32) & 0xffffffffUL) ||\n\t  jp2_putuint32(out, val & 0xffffffffUL)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\njp2_boxinfo_t *jp2_boxinfolookup(int type)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tfor (boxinfo = jp2_boxinfos; boxinfo->name; ++boxinfo) {\n\t\tif (boxinfo->type == type) {\n\t\t\treturn boxinfo;\n\t\t}\n\t}\n\treturn &jp2_boxinfo_unk;\n}\n\n\n\n\n\nstatic void jp2_cmap_destroy(jp2_box_t *box)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tif (cmap->ents) {\n\t\tjas_free(cmap->ents);\n\t}\n}\n\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tbox = 0;\n\tout = 0;\n\n\treturn -1;\n}\n\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tunsigned int i;\n\tjp2_cmapent_t *ent;\n\tfprintf(out, \"numchans = %d\\n\", (int) cmap->numchans);\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tfprintf(out, \"cmptno=%d; map=%d; pcol=%d\\n\",\n\t\t  (int) ent->cmptno, (int) ent->map, (int) ent->pcol);\n\t}\n}\n\nstatic void jp2_pclr_destroy(jp2_box_t *box)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tif (pclr->lutdata) {\n\t\tjas_free(pclr->lutdata);\n\t}\n\tif (pclr->bpc)\n\t\tjas_free(pclr->bpc);\n}\n\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n/* Eliminate warning about unused variable. */\nbox = 0;\nout = 0;\n\treturn -1;\n}\n\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tunsigned int i;\n\tint j;\n\tfprintf(out, \"numents=%d; numchans=%d\\n\", (int) pclr->numlutents,\n\t  (int) pclr->numchans);\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tfprintf(out, \"LUT[%d][%d]=%\"PRIiFAST32\"\\n\", i, j,\n\t\t\t  pclr->lutdata[i * pclr->numchans + j]);\n\t\t}\n\t}\n}\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val)\n{\n\tint c;\n\tint i;\n\tuint_fast32_t v;\n\tint m;\n\n\tm = (n + 7) / 8;\n\n\tv = 0;\n\tfor (i = 0; i < m; ++i) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 8) | c;\n\t}\n\tv &= ONES(n);\n\tif (s) {\n\t\tint sb;\n\t\tsb = v & (1 << (8 * m - 1));\n\t\t*val = ((~v) + 1) & ONES(8 * m);\n\t\tif (sb) {\n\t\t\t*val = -*val;\n\t\t}\n\t} else {\n\t\t*val = v;\n\t}\n\n\treturn 0;\n}\n\njp2_cdefchan_t *jp2_cdef_lookup(jp2_cdef_t *cdef, int channo)\n{\n\tunsigned int i;\n\tjp2_cdefchan_t *cdefent;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tcdefent = &cdef->ents[i];\n\t\tif (cdefent->channo == JAS_CAST(unsigned int, channo)) {\n\t\t\treturn cdefent;\n\t\t}\n\t}\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JP2 Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#include <stdlib.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jp2_cod.h\"\n\n/******************************************************************************\\\n* Function prototypes.\n\\******************************************************************************/\n\n#define\tONES(n)\t((1 << (n)) - 1)\n\njp2_boxinfo_t *jp2_boxinfolookup(int type);\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val);\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val);\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val);\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val);\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val);\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val);\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val);\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val);\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val);\n\njp2_box_t *jp2_box_get(jas_stream_t *in);\nvoid jp2_box_dump(jp2_box_t *box, FILE *out);\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_bpcc_destroy(jp2_box_t *box);\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_colr_destroy(jp2_box_t *box);\nstatic void jp2_cdef_destroy(jp2_box_t *box);\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_cmap_destroy(jp2_box_t *box);\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_pclr_destroy(jp2_box_t *box);\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\njp2_boxinfo_t jp2_boxinfos[] = {\n\t{JP2_BOX_JP, \"JP\", 0,\n\t  {0, 0, jp2_jp_getdata, jp2_jp_putdata, 0}},\n\t{JP2_BOX_FTYP, \"FTYP\", 0,\n\t  {0, 0, jp2_ftyp_getdata, jp2_ftyp_putdata, 0}},\n\t{JP2_BOX_JP2H, \"JP2H\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_IHDR, \"IHDR\", 0,\n\t  {0, 0, jp2_ihdr_getdata, jp2_ihdr_putdata, 0}},\n\t{JP2_BOX_BPCC, \"BPCC\", 0,\n\t  {0, jp2_bpcc_destroy, jp2_bpcc_getdata, jp2_bpcc_putdata, 0}},\n\t{JP2_BOX_COLR, \"COLR\", 0,\n\t  {0, jp2_colr_destroy, jp2_colr_getdata, jp2_colr_putdata, jp2_colr_dumpdata}},\n\t{JP2_BOX_PCLR, \"PCLR\", 0,\n\t  {0, jp2_pclr_destroy, jp2_pclr_getdata, jp2_pclr_putdata, jp2_pclr_dumpdata}},\n\t{JP2_BOX_CMAP, \"CMAP\", 0,\n\t  {0, jp2_cmap_destroy, jp2_cmap_getdata, jp2_cmap_putdata, jp2_cmap_dumpdata}},\n\t{JP2_BOX_CDEF, \"CDEF\", 0,\n\t  {0, jp2_cdef_destroy, jp2_cdef_getdata, jp2_cdef_putdata, jp2_cdef_dumpdata}},\n\t{JP2_BOX_RES, \"RES\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESC, \"RESC\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESD, \"RESD\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2C, \"JP2C\", JP2_BOX_NODATA,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2I, \"JP2I\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_XML, \"XML\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UUID, \"UUID\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UINF, \"UINF\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_ULST, \"ULST\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_URL, \"URL\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{0, 0, 0, {0, 0, 0, 0, 0}},\n};\n\njp2_boxinfo_t jp2_boxinfo_unk = {\n\t0, \"Unknown\", 0, {0, 0, 0, 0, 0}\n};\n\n/******************************************************************************\\\n* Box constructor.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}\n\n/******************************************************************************\\\n* Box destructor.\n\\******************************************************************************/\n\nvoid jp2_box_destroy(jp2_box_t *box)\n{\n\tif (box->ops->destroy) {\n\t\t(*box->ops->destroy)(box);\n\t}\n\tjas_free(box);\n}\n\nstatic void jp2_bpcc_destroy(jp2_box_t *box)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tif (bpcc->bpcs) {\n\t\tjas_free(bpcc->bpcs);\n\t\tbpcc->bpcs = 0;\n\t}\n}\n\nstatic void jp2_cdef_destroy(jp2_box_t *box)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tif (cdef->ents) {\n\t\tjas_free(cdef->ents);\n\t\tcdef->ents = 0;\n\t}\n}\n\n/******************************************************************************\\\n* Box input.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n\nvoid jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"',\n\t  boxinfo->name, '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_getuint32(in, &jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_getuint32(in, &ftyp->majver) || jp2_getuint32(in, &ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tftyp->numcompatcodes = (box->datalen - 8) / 4;\n\tif (ftyp->numcompatcodes > JP2_FTYP_MAXCOMPATCODES) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_getuint32(in, &ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_getuint32(in, &ihdr->height) || jp2_getuint32(in, &ihdr->width) ||\n\t  jp2_getuint16(in, &ihdr->numcmpts) || jp2_getuint8(in, &ihdr->bpc) ||\n\t  jp2_getuint8(in, &ihdr->comptype) || jp2_getuint8(in, &ihdr->csunk) ||\n\t  jp2_getuint8(in, &ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tfprintf(out, \"method=%d; pri=%d; approx=%d\\n\", (int)colr->method, (int)colr->pri, (int)colr->approx);\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tfprintf(out, \"csid=%d\\n\", (int)colr->csid);\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tjas_memdump(out, colr->iccp, colr->iccplen);\n\t\tbreak;\n\t}\n}\n\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tcolr->csid = 0;\n\tcolr->iccp = 0;\n\tcolr->iccplen = 0;\n\n\tif (jp2_getuint8(in, &colr->method) || jp2_getuint8(in, &colr->pri) ||\n\t  jp2_getuint8(in, &colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_getuint32(in, &colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tcolr->iccplen = box->datalen - 3;\n\t\tif (!(colr->iccp = jas_alloc2(colr->iccplen, sizeof(uint_fast8_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, colr->iccp, colr->iccplen) != colr->iccplen) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tfprintf(out,\n\t\t  \"channo=%\"PRIuFAST16\"; type=%\"PRIuFAST16\"; assoc=%\"PRIuFAST16\"\\n\",\n\t\t  cdef->ents[i].channo, cdef->ents[i].type, cdef->ents[i].assoc);\n\t}\n}\n\nstatic void jp2_colr_destroy(jp2_box_t *box)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (colr->iccp) {\n\t\tjas_free(colr->iccp);\n\t}\n}\n\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Box output.\n\\******************************************************************************/\n\nint jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}\n\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_putuint32(out, jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_putuint32(out, ftyp->majver) || jp2_putuint32(out, ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_putuint32(out, ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_putuint32(out, ihdr->height) || jp2_putuint32(out, ihdr->width) ||\n\t  jp2_putuint16(out, ihdr->numcmpts) || jp2_putuint8(out, ihdr->bpc) ||\n\t  jp2_putuint8(out, ihdr->comptype) || jp2_putuint8(out, ihdr->csunk) ||\n\t  jp2_putuint8(out, ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_putuint8(out, bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (jp2_putuint8(out, colr->method) || jp2_putuint8(out, colr->pri) ||\n\t  jp2_putuint8(out, colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_putuint32(out, colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tif (jas_stream_write(out, colr->iccp,\n\t\t  JAS_CAST(int, colr->iccplen)) != JAS_CAST(int, colr->iccplen))\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tjp2_cdefchan_t *ent;\n\n\tif (jp2_putuint16(out, cdef->numchans)) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tent = &cdef->ents[i];\n\t\tif (jp2_putuint16(out, ent->channo) ||\n\t\t  jp2_putuint16(out, ent->type) ||\n\t\t  jp2_putuint16(out, ent->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Input operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val)\n{\n\tuint_fast16_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val)\n{\n\tuint_fast32_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val)\n{\n\tuint_fast64_t tmpval;\n\tint i;\n\tint c;\n\n\ttmpval = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\ttmpval <<= 8;\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\ttmpval |= (c & 0xff);\n\t}\n\t*val = tmpval;\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Output operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val)\n{\n\tif (jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val)\n{\n\tif (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val)\n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val)\n{\n\tif (jp2_putuint32(out, (val >> 32) & 0xffffffffUL) ||\n\t  jp2_putuint32(out, val & 0xffffffffUL)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\njp2_boxinfo_t *jp2_boxinfolookup(int type)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tfor (boxinfo = jp2_boxinfos; boxinfo->name; ++boxinfo) {\n\t\tif (boxinfo->type == type) {\n\t\t\treturn boxinfo;\n\t\t}\n\t}\n\treturn &jp2_boxinfo_unk;\n}\n\n\n\n\n\nstatic void jp2_cmap_destroy(jp2_box_t *box)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tif (cmap->ents) {\n\t\tjas_free(cmap->ents);\n\t}\n}\n\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tbox = 0;\n\tout = 0;\n\n\treturn -1;\n}\n\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tunsigned int i;\n\tjp2_cmapent_t *ent;\n\tfprintf(out, \"numchans = %d\\n\", (int) cmap->numchans);\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tfprintf(out, \"cmptno=%d; map=%d; pcol=%d\\n\",\n\t\t  (int) ent->cmptno, (int) ent->map, (int) ent->pcol);\n\t}\n}\n\nstatic void jp2_pclr_destroy(jp2_box_t *box)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tif (pclr->lutdata) {\n\t\tjas_free(pclr->lutdata);\n\t}\n\tif (pclr->bpc)\n\t\tjas_free(pclr->bpc);\n}\n\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n/* Eliminate warning about unused variable. */\nbox = 0;\nout = 0;\n\treturn -1;\n}\n\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tunsigned int i;\n\tint j;\n\tfprintf(out, \"numents=%d; numchans=%d\\n\", (int) pclr->numlutents,\n\t  (int) pclr->numchans);\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tfprintf(out, \"LUT[%d][%d]=%\"PRIiFAST32\"\\n\", i, j,\n\t\t\t  pclr->lutdata[i * pclr->numchans + j]);\n\t\t}\n\t}\n}\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val)\n{\n\tint c;\n\tint i;\n\tuint_fast32_t v;\n\tint m;\n\n\tm = (n + 7) / 8;\n\n\tv = 0;\n\tfor (i = 0; i < m; ++i) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 8) | c;\n\t}\n\tv &= ONES(n);\n\tif (s) {\n\t\tint sb;\n\t\tsb = v & (1 << (8 * m - 1));\n\t\t*val = ((~v) + 1) & ONES(8 * m);\n\t\tif (sb) {\n\t\t\t*val = -*val;\n\t\t}\n\t} else {\n\t\t*val = v;\n\t}\n\n\treturn 0;\n}\n\njp2_cdefchan_t *jp2_cdef_lookup(jp2_cdef_t *cdef, int channo)\n{\n\tunsigned int i;\n\tjp2_cdefchan_t *cdefent;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tcdefent = &cdef->ents[i];\n\t\tif (cdefent->channo == JAS_CAST(unsigned int, channo)) {\n\t\t\treturn cdefent;\n\t\t}\n\t}\n\treturn 0;\n}\n"], "filenames": ["src/libjasper/jp2/jp2_cod.c"], "buggy_code_start_loc": [253], "buggy_code_end_loc": [332], "fixing_code_start_loc": [254], "fixing_code_end_loc": [336], "type": "CWE-476", "message": "The jp2_colr_destroy function in jp2_cod.c in JasPer before 1.900.13 allows remote attackers to cause a denial of service (NULL pointer dereference) by leveraging incorrect cleanup of JP2 box data on error. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8887.", "other": {"cve": {"id": "CVE-2016-10250", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T14:59:00.353", "lastModified": "2018-06-29T01:29:00.580", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The jp2_colr_destroy function in jp2_cod.c in JasPer before 1.900.13 allows remote attackers to cause a denial of service (NULL pointer dereference) by leveraging incorrect cleanup of JP2 box data on error. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8887."}, {"lang": "es", "value": "La funci\u00f3n jp2_colr_destroy en jp2_cod.c en JasPer en versiones anteriores a 1.900.13 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL) aprovechando la limpieza incorrecta de datos de la caja JP2 en caso de error. NOTA: esta vulnerabilidad existe debido a una correcci\u00f3n incompleta para CVE-2016-8887."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.900.12", "matchCriteriaId": "73F7150A-500A-4CE6-83A7-47E1BC9B19DC"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2016/10/23/jasper-null-pointer-dereference-in-jp2_colr_destroy-jp2_cod-c-incomplete-fix-for-cve-2016-8887/", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/mdadams/jasper/commit/bdfe95a6e81ffb4b2fad31a76b57943695beed20", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3693-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/bdfe95a6e81ffb4b2fad31a76b57943695beed20"}}