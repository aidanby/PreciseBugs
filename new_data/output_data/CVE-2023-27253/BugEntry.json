{"buggy_code": ["<?php\n/*\n * config.lib.inc\n *\n * part of pfSense (https://www.pfsense.org)\n * Copyright (c) 2004-2013 BSD Perimeter\n * Copyright (c) 2013-2016 Electric Sheep Fencing\n * Copyright (c) 2014-2022 Rubicon Communications, LLC (Netgate)\n * Copyright (c) 2009 Erik Kristensen\n * All rights reserved.\n *\n * originally part of m0n0wall (http://m0n0.ch/wall)\n * Copyright (c) 2003-2004 Manuel Kasper <mk@neon1.net>.\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nrequire_once('util.inc');\n\n/****f* config/encrypted_configxml\n * NAME\n *   encrypted_configxml - Checks to see if config.xml is encrypted and if so, prompts to unlock.\n * INPUTS\n *   None\n * RESULT\n *   $config \t- rewrites config.xml without encryption\n ******/\nfunction encrypted_configxml() {\n\tglobal $g, $config;\n\n\tif (!file_exists(g_get('conf_path') . \"/config.xml\")) {\n\t\treturn;\n\t}\n\n\tif (!platform_booting()) {\n\t\treturn;\n\t}\n\n\t$configtxt = file_get_contents(g_get('conf_path') . \"/config.xml\");\n\tif (tagfile_deformat($configtxt, $configtxt, \"config.xml\")) {\n\t\t$fp = fopen('php://stdin', 'r');\n\t\t$data = \"\";\n\t\techo \"\\n\\n*** Encrypted config.xml detected ***\\n\";\n\t\twhile ($data == \"\") {\n\t\t\techo \"\\nEnter the password to decrypt config.xml: \";\n\t\t\t$decrypt_password = chop(fgets($fp));\n\t\t\t$data = decrypt_data($configtxt, $decrypt_password);\n\t\t\tif (!strstr($data, \"<pfsense>\")) {\n\t\t\t\t$data = \"\";\n\t\t\t}\n\t\t\tif ($data) {\n\t\t\t\t$fd = fopen(g_get('conf_path') . \"/config.xml.tmp\", \"w\");\n\t\t\t\tfwrite($fd, $data);\n\t\t\t\tfclose($fd);\n\t\t\t\texec(\"/bin/mv {$g['conf_path']}/config.xml.tmp {$g['conf_path']}/config.xml\");\n\t\t\t\techo \"\\n\" . gettext(\"Config.xml unlocked.\") . \"\\n\";\n\t\t\t\tfclose($fp);\n\t\t\t\t//pfSense_fsync(\"{$g['conf_path']}/config.xml\");\n\t\t\t} else {\n\t\t\t\techo \"\\n\" . gettext(\"Invalid password entered.  Please try again.\") . \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}\n\n/****f* config/parse_config\n * NAME\n *   parse_config - Read in config.cache or config.xml if needed and return $config array\n * INPUTS\n *   $parse       - boolean to force parse_config() to read config.xml and generate config.cache\n * RESULT\n *   $config      - array containing all configuration variables\n ******/\nfunction parse_config($parse = false) {\n\tglobal $g, $config_parsed, $config_extra;\n\n\t$lockkey = lock('config');\n\t$config_parsed = false;\n\n\tif (!file_exists(\"{$g['conf_path']}/config.xml\") || filesize(\"{$g['conf_path']}/config.xml\") == 0) {\n\t\t$last_backup = discover_last_backup();\n\t\tif ($last_backup) {\n\t\t\tlog_error(gettext(\"No config.xml found, attempting last known config restore.\"));\n\t\t\tfile_notice(\"config.xml\", gettext(\"No config.xml found, attempting last known config restore.\"), \"pfSenseConfigurator\", \"\");\n\t\t\trestore_backup(\"{$g['conf_path']}/backup/{$last_backup}\");\n\t\t} else {\n\t\t\tunlock($lockkey);\n\t\t\tdie(gettext(\"Config.xml is corrupted and is 0 bytes.  Could not restore a previous backup.\"));\n\t\t}\n\t}\n\n\tif (platform_booting(true)) {\n\t\techo \".\";\n\t}\n\n\t// Check for encrypted config.xml\n\tencrypted_configxml();\n\n\tif (!$parse) {\n\t\tif (file_exists(g_get('tmp_path') . '/config.cache')) {\n\t\t\t$config = unserialize(file_get_contents(g_get('tmp_path') . '/config.cache'));\n\t\t\tif (!is_array($config)) {\n\t\t\t\t$parse = true;\n\t\t\t}\n\t\t} else {\n\t\t\t$parse = true;\n\t\t}\n\t}\n\tif ($parse == true) {\n\t\tif (!file_exists(g_get('conf_path') . \"/config.xml\")) {\n\t\t\tif (platform_booting(true)) {\n\t\t\t\techo \".\";\n\t\t\t}\n\t\t\tlog_error(\"No config.xml found, attempting last known config restore.\");\n\t\t\tfile_notice(\"config.xml\", \"No config.xml found, attempting last known config restore.\", \"pfSenseConfigurator\", \"\");\n\t\t\t$last_backup = discover_last_backup();\n\t\t\tif ($last_backup) {\n\t\t\t\trestore_backup(\"/cf/conf/backup/{$last_backup}\");\n\t\t\t} else {\n\t\t\t\tlog_error(gettext(\"Could not restore config.xml.\"));\n\t\t\t\tunlock($lockkey);\n\t\t\t\tdie(gettext(\"Config.xml is corrupted and is 0 bytes.  Could not restore a previous backup.\"));\n\t\t\t}\n\t\t}\n\t\t$config = parse_xml_config(g_get('conf_path') . '/config.xml', array(g_get('xml_rootobj'), 'pfsense'));\n\t\tif ($config == -1) {\n\t\t\t$last_backup = discover_last_backup();\n\t\t\tif ($last_backup) {\n\t\t\t\trestore_backup(\"/cf/conf/backup/{$last_backup}\");\n\t\t\t} else {\n\t\t\t\tlog_error(gettext(\"Could not restore config.xml.\"));\n\t\t\t\tunlock($lockkey);\n\t\t\t\tdie(\"Config.xml is corrupted and is 0 bytes.  Could not restore a previous backup.\");\n\t\t\t}\n\t\t}\n\t\tgenerate_config_cache($config);\n\t}\n\n\tif (platform_booting(true)) {\n\t\techo \".\";\n\t}\n\n\t$config_parsed = true;\n\tunlock($lockkey);\n\n\treturn $config;\n}\n\n/****f* config/generate_config_cache\n * NAME\n *   generate_config_cache - Write serialized configuration to cache.\n * INPUTS\n *   $config\t- array containing current firewall configuration\n * RESULT\n *   boolean\t- true on completion\n ******/\nfunction generate_config_cache($config) {\n\tglobal $g, $config_extra;\n\n\t$configcache = fopen(g_get('tmp_path') . '/config.cache', \"w\");\n\tfwrite($configcache, serialize($config));\n\tfclose($configcache);\n\t//pfSense_fsync(\"{$g['tmp_path']}/config.cache\");\n\n\tunset($configcache);\n\t/* Used for config.extra.xml */\n\tif (file_exists(g_get('tmp_path') . '/config.extra.cache') && $config_extra) {\n\t\t$configcacheextra = fopen(g_get('tmp_path') . '/config.extra.cache', \"w\");\n\t\tfwrite($configcacheextra, serialize($config_extra));\n\t\tfclose($configcacheextra);\n\t\t//pfSense_fsync(\"{$g['tmp_path']}/config.extra.cache\");\n\t\tunset($configcacheextra);\n\t}\n}\n\nfunction discover_last_backup() {\n\tglobal $g;\n\n\t$backups = glob('/cf/conf/backup/*.xml');\n\tforeach (array_reverse($backups) as $backup) {\n\t\t/* checking multiple backups when detecting invalid configuration\n\t\t * https://redmine.pfsense.org/issues/11748 */\n\t\tif (filesize($backup) != 0) {\n\t\t\t$testconfig = parse_xml_config($backup, g_get('xml_rootobj'));\n\t\t\tif ($testconfig != -1) {\n\t\t\t\treturn basename($backup);\n\t\t\t}\n\t\t} \n\t}\n\n\treturn false;\n}\n\nfunction restore_backup($file) {\n\tglobal $g;\n\n\tif (file_exists($file)) {\n\t\t/* restore rrddata/xmldata and clear appropriate data,\n\t\t * see https://redmine.pfsense.org/issues/11050 */\n\t\t$data = file_get_contents(\"$file\");\n\t\t$conf = parse_xml_config(\"$file\", g_get('xml_rootobj'));\n\t\tif ($conf['rrddata']) {\n\t\t\trestore_rrddata($conf);\n\t\t\t$data = clear_tagdata(\"rrd\", $data);\n\t\t}\n\t\tif ($conf['sshdata']) {\n\t\t\trestore_sshdata($conf);\n\t\t\t$data = clear_tagdata(\"ssh\", $data);\n\t\t}\n\t\tforeach (g_get('backuppath') as $bk => $path) {\n\t\t\tif (!empty($conf[$bk][$bk.'data'])) {\n\t\t\t\trestore_xmldatafile($bk, $conf);\n\t\t\t\t$data = clear_tagdata($bk, $data);\n\t\t\t}\n\t\t}\n\t\tfile_put_contents($file, $data);\n\t\tunlink_if_exists(\"{$g['tmp_path']}/config.cache\");\n\t\tcopy(\"$file\", \"/cf/conf/config.xml\");\n\t\t//pfSense_fsync(\"/cf/conf/config.xml\");\n\t\t//pfSense_fsync($g['conf_path']);\n\t\tdisable_security_checks();\n\t\tlog_error(sprintf(gettext('%1$s is restoring the configuration %2$s'), g_get('product_label'), $file));\n\t\tfile_notice(\"config.xml\", sprintf(gettext('%1$s is restoring the configuration %2$s'), g_get('product_label'), $file), \"pfSenseConfigurator\", \"\");\n\t}\n}\n\n/*\n *\tBackup RRD/XML Data\n */\n\n/* If the config on disk had rrddata/xmldata tags already, remove that section first.\n * See https://redmine.pfsense.org/issues/8994,\n *     https://redmine.pfsense.org/issues/10508, \n *     https://redmine.pfsense.org/issues/11050 */\nfunction clear_tagdata($tag, $data) {\n\t$data = preg_replace(\"/[[:blank:]]*<{$tag}data>.*<\\\\/{$tag}data>[[:blank:]]*\\n*/s\", \"\", $data);\n\t$data = preg_replace(\"/[[:blank:]]*<{$tag}data\\\\/>[[:blank:]]*\\n*/\", \"\", $data);\n\n\treturn $data;\n}\n\nfunction restore_xmldatafile($type='voucher', $conf = false) {\n\tglobal $config, $g;\n\n\tif (!$conf) {\n\t\t$conf = & $config;\n\t}\n\n\tforeach ($conf[$type][\"{$type}data\"][\"xmldatafile\"] as $file) {\n\t\t$basename = basename($file['filename']);\n\t\t$dirname = dirname($g['backuppath'][$type]);\n\t\t$xmldata_file = \"{$dirname}/{$basename}\";\n\t\tif (!is_dir($dirname)) {\n\t\t\tsafe_mkdir($dirname);\n\t\t}\n\t\tif (file_put_contents($xmldata_file, gzinflate(base64_decode($file['data']))) === false) {\n\t\t\tlog_error(sprintf(gettext(\"Cannot write %s\"), $xmldata_file));\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nfunction restore_rrddata($conf = false) {\n\tglobal $config, $g, $rrdtool, $input_errors;\n\n\tif (!$conf) {\n\t\t$conf = & $config;\n\t}\n\n\tforeach ($conf['rrddata']['rrddatafile'] as $rrd) {\n\t\tif ($rrd['xmldata']) {\n\t\t\t$rrd_file = \"{$g['vardb_path']}/rrd/{$rrd['filename']}\";\n\t\t\t$xml_file = preg_replace('/\\.rrd$/', \".xml\", $rrd_file);\n\t\t\tif (file_put_contents($xml_file, gzinflate(base64_decode($rrd['xmldata']))) === false) {\n\t\t\t\tlog_error(sprintf(gettext(\"Cannot write %s\"), $xml_file));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$output = array();\n\t\t\t$status = null;\n\t\t\texec(\"$rrdtool restore -f '{$xml_file}' '{$rrd_file}'\", $output, $status);\n\t\t\tif ($status) {\n\t\t\t\tlog_error(\"rrdtool restore -f '{$xml_file}' '{$rrd_file}' failed returning {$status}.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlink($xml_file);\n\t\t} else if ($rrd['data']) {\n\t\t\t$rrd_file = \"{$g['vardb_path']}/rrd/{$rrd['filename']}\";\n\t\t\t$rrd_fd = fopen($rrd_file, \"w\");\n\t\t\tif (!$rrd_fd) {\n\t\t\t\tlog_error(sprintf(gettext(\"Cannot write %s\"), $rrd_file));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$data = base64_decode($rrd['data']);\n\t\t\t/* Try to decompress the data. */\n\t\t\t$dcomp = @gzinflate($data);\n\t\t\tif ($dcomp) {\n\t\t\t\t/* If the decompression worked, write the decompressed data */\n\t\t\t\tif (fwrite($rrd_fd, $dcomp) === false) {\n\t\t\t\t\tlog_error(sprintf(gettext(\"fwrite %s failed\"), $rrd_file));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* If the decompression failed, it wasn't compressed, so write raw data */\n\t\t\t\tif (fwrite($rrd_fd, $data) === false) {\n\t\t\t\t\tlog_error(sprintf(gettext(\"fwrite %s failed\"), $rrd_file));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fclose($rrd_fd) === false) {\n\t\t\t\tlog_error(sprintf(gettext(\"fclose %s failed\"), $rrd_file));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction restore_sshdata($conf = false) {\n\tglobal $config, $sshConfigDir;\n\n\tif (!$conf) {\n\t\t$conf = & $config;\n\t}\n\n\t$oldmask = umask();\n\tforeach ($conf[\"sshdata\"][\"sshkeyfile\"] as $sshkey) {\n\t\t$keypath = \"{$sshConfigDir}/{$sshkey['filename']}\";\n\t\tif (strstr($sshkey['filename'], 'pub')) {\n\t\t\tumask(0133);\n\t\t} else {\n\t\t\tumask(0177);\n\t\t}\n\t\tif (file_put_contents($keypath, gzinflate(base64_decode($sshkey['xmldata']))) === false) {\n\t\t\tlog_error(sprintf(gettext(\"Cannot write %s\"), $sshkey['filename']));\n\t\t\tcontinue;\n\t\t}\n\t}\n\tumask($oldmask);\n}\n\n/****f* config/parse_config_bootup\n * NAME\n *   parse_config_bootup - Bootup-specific configuration checks.\n * RESULT\n *   null\n ******/\nfunction parse_config_bootup() {\n\tglobal $config, $g;\n\n\tif (platform_booting()) {\n\t\techo \".\";\n\t}\n\n\t$lockkey = lock('config');\n\tif (!file_exists(\"{$g['conf_path']}/config.xml\")) {\n\t\tif (platform_booting()) {\n\t\t\t$last_backup = discover_last_backup();\n\t\t\tif ($last_backup) {\n\t\t\t\tlog_error(\"No config.xml found, attempting last known config restore.\");\n\t\t\t\tfile_notice(\"config.xml\", gettext(\"No config.xml found, attempting last known config restore.\"), \"pfSenseConfigurator\", \"\");\n\t\t\t\trestore_backup(\"/cf/conf/backup/{$last_backup}\");\n\t\t\t}\n\t\t\tif (!file_exists(\"{$g['conf_path']}/config.xml\")) {\n\t\t\t\techo sprintf(gettext(\"XML configuration file not found.  %s cannot continue booting.\"), g_get('product_label')) . \"\\n\";\n\t\t\t\tunlock($lockkey);\n\t\t\t\tdie(gettext(\"Could not find a usable configuration file or it's backup! Exiting....\"));\n\t\t\t} else {\n\t\t\t\tlog_error(\"Last known config found and restored.  Please double check the configuration file for accuracy.\");\n\t\t\t\tfile_notice(\"config.xml\", gettext(\"Last known config found and restored.  Please double check the configuration file for accuracy.\"), \"pfSenseConfigurator\", \"\");\n\t\t\t}\n\t\t} else {\n\t\t\tunlock($lockkey);\n\t\t\tlog_error(gettext(\"Could not find a usable configuration file! Exiting....\"));\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tif (filesize(\"{$g['conf_path']}/config.xml\") == 0) {\n\t\t$last_backup = discover_last_backup();\n\t\tif ($last_backup) {\n\t\t\tlog_error(gettext(\"No config.xml found, attempting last known config restore.\"));\n\t\t\tfile_notice(\"config.xml\", gettext(\"No config.xml found, attempting last known config restore.\"), \"pfSenseConfigurator\", \"\");\n\t\t\trestore_backup(\"{$g['conf_path']}/backup/{$last_backup}\");\n\t\t} else {\n\t\t\tunlock($lockkey);\n\t\t\tdie(gettext(\"Config.xml is corrupted and is 0 bytes.  Could not restore a previous backup.\"));\n\t\t}\n\t}\n\tunlock($lockkey);\n\n\t$config = parse_config(true);\n\n\tif ((float)$config['version'] > (float)g_get('latest_config')) {\n\t\techo <<<EOD\n\n\n*******************************************************************************\n* WARNING!                                                                    *\n* The current configuration has been created with a newer version of {$g['product_label']}  *\n* than this one! This can lead to serious misbehavior and even security       *\n* holes! You are urged to either upgrade to a newer version of {$g['product_label']} or     *\n* revert to the default configuration immediately!                            *\n*******************************************************************************\n\n\nEOD;\n\t\t}\n\n\t/* make alias table (for faster lookups) */\n\talias_make_table();\n}\n\n/****f* config/conf_mount_rw\n * NAME\n *   conf_mount_rw - Mount filesystems read/write.\n * RESULT\n *   null\n ******/\n/* mount flash card read/write */\nfunction conf_mount_rw() {\n\t/* Obsoleted. Keep it here until all calls are removed */\n\treturn;\n}\n\n/****f* config/conf_mount_ro\n * NAME\n *   conf_mount_ro - Mount filesystems readonly.\n * RESULT\n *   null\n ******/\nfunction conf_mount_ro() {\n\t/* Obsoleted. Keep it here until all calls are removed */\n\treturn;\n}\n\n/****f* config/convert_config\n * NAME\n *   convert_config - Attempt to update config.xml.\n * DESCRIPTION\n *   convert_config() reads the current global configuration\n *   and attempts to convert it to conform to the latest\n *   config.xml version. This allows major formatting changes\n *   to be made with a minimum of breakage.\n * RESULT\n *   null\n ******/\n/* convert configuration, if necessary */\nfunction convert_config() {\n\tglobal $config, $g;\n\t$now = date(\"H:i:s\");\n\tlog_error(sprintf(gettext(\"Start Configuration upgrade at %s, set execution timeout to 15 minutes\"), $now));\n\t//ini_set(\"max_execution_time\", \"900\");\n\n\t/* special case upgrades */\n\t/* fix every minute crontab bogons entry */\n\tif (is_array($config['cron'])) {\n\t\t$cron_item_count = count($config['cron']['item']);\n\t\tfor ($x = 0; $x < $cron_item_count; $x++) {\n\t\t\tif (stristr($config['cron']['item'][$x]['command'], \"rc.update_bogons.sh\")) {\n\t\t\t\tif ($config['cron']['item'][$x]['hour'] == \"*\") {\n\t\t\t\t\t$config['cron']['item'][$x]['hour'] = \"3\";\n\t\t\t\t\twrite_config(gettext(\"Updated bogon update frequency to 3am\"));\n\t\t\t\t\tlog_error(gettext(\"Updated bogon update frequency to 3am\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Save off config version\n\t$prev_version = config_get_path('version');\n\n\tinclude_once('auth.inc');\n\tinclude_once('upgrade_config.inc');\n\tif (file_exists(\"/etc/inc/upgrade_config_custom.inc\")) {\n\t\tinclude_once(\"upgrade_config_custom.inc\");\n\t}\n\n\tif ($config['version'] == g_get('latest_config')) {\n\t\tadditional_config_upgrade();\n\t\treturn;\t\t/* already at latest version */\n\t}\n\n\tif (!is_array($config['system']['already_run_config_upgrade'])) {\n\t\t$config['system']['already_run_config_upgrade'] = array();\n\t}\n\t$already_run = config_get_path('system/already_run_config_upgrade');\n\n\t/* Loop and run upgrade_VER_to_VER() until we're at current version */\n\twhile ($config['version'] < g_get('latest_config')) {\n\t\t$cur = $config['version'] * 10;\n\t\t$next = $cur + 1;\n\t\t$migration_function = sprintf('upgrade_%03d_to_%03d', $cur,\n\t\t    $next);\n\n\t\tforeach (array(\"\", \"_custom\") as $suffix) {\n\t\t\t$migration_function .= $suffix;\n\t\t\tif (!function_exists($migration_function)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isset($already_run[$migration_function])) {\n\t\t\t\tconfig_del_path(\"system/already_run_config_upgrade/{$migration_function}\");\n\t\t\t} else {\n\t\t\t\t$migration_function();\n\t\t\t}\n\t\t}\n\t\t$config['version'] = sprintf('%.1f', $next / 10);\n\t\tif (platform_booting()) {\n\t\t\techo \".\";\n\t\t}\n\t}\n\n\tif ($prev_version != $config['version']) {\n\t\t$now = date(\"H:i:s\");\n\t\tlog_error(sprintf(gettext(\"Ended Configuration upgrade at %s\"), $now));\n\n\t\twrite_config(sprintf(gettext('Upgraded config version level from %1$s to %2$s'), $prev_version, $config['version']));\n\t}\n\n\tadditional_config_upgrade();\n}\n\n/****f* config/safe_write_file\n * NAME\n *   safe_write_file - Write a file out atomically\n * DESCRIPTION\n *   safe_write_file() Writes a file out atomically by first writing to a\n *   temporary file of the same name but ending with the pid of the current\n *   process, them renaming the temporary file over the original.\n * INPUTS\n *   $filename  - string containing the filename of the file to write\n *   $content   - string or array containing the file content to write to file\n *   $force_binary      - boolean denoting whether we should force binary\n *   mode writing.\n * RESULT\n *   boolean - true if successful, false if not\n ******/\nfunction safe_write_file($file, $content, $force_binary = false) {\n\t$tmp_file = $file . \".\" . getmypid();\n\t$write_mode = $force_binary ? \"wb\" : \"w\";\n\n\t$fd = fopen($tmp_file, $write_mode);\n\tif (!$fd) {\n\t\t// Unable to open temporary file for writing\n\t\treturn false;\n\t}\n\tif (is_array($content)) {\n\t\tforeach ($content as $line) {\n\t\t\tif (!fwrite($fd, $line . \"\\n\")) {\n\t\t\t\t// Unable to write to temporary file\n\t\t\t\tfclose($fd);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} elseif (!fwrite($fd, $content)) {\n\t\t// Unable to write to temporary file\n\t\tfclose($fd);\n\t\treturn false;\n\t}\n\tfflush($fd);\n\tfclose($fd);\n\n\t/* XXX Re-add pfSense_fsync() call here after it's fixed */\n\t// if (!pfSense_fsync($tmp_file) || !rename($tmp_file, $file)) {\n\tif (!rename($tmp_file, $file)) {\n\t\t// Unable to move temporary file to original\n\t\t@unlink($tmp_file);\n\t\treturn false;\n\t}\n\n\t// Sync file before returning\n\t//return pfSense_fsync($file);\n\treturn true;\n}\n\n/****f* config/write_config\n * NAME\n *   write_config - Backup and write the firewall configuration.\n * DESCRIPTION\n *   write_config() handles backing up the current configuration,\n *   applying changes, and regenerating the configuration cache.\n * INPUTS\n *   $desc\t- string containing the a description of configuration changes\n *   $backup\t- boolean: do not back up current configuration if false.\n *   $write_config_only\t- boolean: do not sync or reload anything; just save the configuration if true.\n * RESULT\n *   null\n ******/\n/* save the system configuration */\nfunction write_config($desc=\"Unknown\", $backup = true, $write_config_only = false) {\n\tglobal $config, $g;\n\n\t// Certain strings may be embedded in the $desc (reason) parameter to trigger certain behavior.\n\t// If detected, those strings are removed and a variable set.\n\t$doacb = true;\n\t$manual_acb = false;\n\t$rcnt = 0;\n\n\t$desc = str_replace(\"-MaNuAlBaCkUp\", \"\", $desc, $rcnt);\n\tif ($rcnt > 0) {\n\t\t$manual_acb = true; // Manual backups require special processing on the server\n\t}\n\n\t$rcnt = 0;\n\t$desc = str_replace(\"-NoReMoTeBaCkUp\", \"\", $desc, $rcnt);\n\tif ($rcnt > 0) {\n\t\t$doacb = false; // No ACB will be performed if this string is detected\n\t}\n\n\t/*\n\t* Syncing vouchers happens every minute and sometimes multiple times. We don't\n\t* want to fill up our db with a lot of the same config so just ignore that case.\n\t*/\n\tif((strpos($desc, 'Syncing vouchers') !== false ||\n\t\tstrpos($desc, 'Captive Portal Voucher database synchronized') !== false) ) {\n\t\t$doacb = false;\n\t}\n\n\tif (!empty($_SERVER['REMOTE_ADDR'])) {\n\t\t@phpsession_begin();\n\t\tif (!empty($_SESSION['Username']) && ($_SESSION['Username'] != \"admin\")) {\n\t\t\t$user = getUserEntry($_SESSION['Username']);\n\t\t\tif (is_array($user) && userHasPrivilege($user, \"user-config-readonly\")) {\n\t\t\t\tsyslog(LOG_AUTHPRIV, sprintf(gettext(\"Save config permission denied by the 'User - Config: Deny Config Write' permission for user '%s'.\"), get_config_user()));\n\t\t\t\tphpsession_end(true);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (!isset($argc)) {\n\t\t\tphpsession_end(true);\n\t\t}\n\t}\n\n\tif (isset($config['reset_factory_defaults'])) {\n\t\t/*\n\t\t   We have put a default config.xml on disk and are about to reboot\n\t\t   or reload it. Do not let any system or package code try to save\n\t\t   state to config because that would overwrite the default config\n\t\t   with the running config.\n\t\t*/\n\t\treturn false;\n\t}\n\n\tif ($backup) {\n\t\tbackup_config();\n\t}\n\n\tif ($desc == \"Unknown\") {\n\t\tfile_notice(\"config.xml\", gettext(\n\t\t    'WARNING: write_config() was called without description'));\n\t}\n\t$config['revision'] = make_config_revision_entry($desc);\n\n\t$lockkey = lock('config', LOCK_EX);\n\n\t/* generate configuration XML */\n\t$xmlconfig = dump_xml_config($config, g_get('xml_rootobj'));\n\n\t/* write new configuration */\n\tif (!safe_write_file(\"{$g['cf_conf_path']}/config.xml\", $xmlconfig)) {\n\t\tlog_error(gettext(\"WARNING: Config contents could not be saved. Could not open file!\"));\n\t\tunlock($lockkey);\n\t\tfile_notice(\"config.xml\", sprintf(gettext('Unable to open %1$s/config.xml for writing in write_config()%2$s'), g_get('cf_conf_path'), \"\\n\"));\n\t\treturn -1;\n\t}\n\n\tif (config_get_path('syslog/logconfigchanges') != \"disabled\") {\n\t\tlog_error(gettext(\"Configuration Change\") . \": {$config['revision']['description']}\");\n\t}\n\n\tcleanup_backupcache(true);\n\n\t/* re-read configuration */\n\t/* NOTE: We assume that the file can be parsed since we wrote it. */\n\t$config = parse_xml_config(\"{$g['conf_path']}/config.xml\", g_get('xml_rootobj'));\n\tif ($config == -1) {\n\t\tcopy(\"{$g['conf_path']}/config.xml\", \"{$g['conf_path']}/config.xml.bad\");\n\t\t$last_backup = discover_last_backup();\n\t\tif ($last_backup) {\n\t\t\trestore_backup(\"/cf/conf/backup/{$last_backup}\");\n\t\t\t$config = parse_xml_config(\"{$g['conf_path']}/config.xml\", g_get('xml_rootobj'));\n\t\t\tif (platform_booting()) {\n\t\t\t\techo \"\\n\\n ************** WARNING **************\";\n\t\t\t\techo \"\\n\\n Configuration could not be validated. A previous configuration was restored. \\n\";\n\t\t\t\techo \"\\n The failed configuration file has been saved as {$g['conf_path']}/config.xml.bad \\n\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\tlog_error(gettext(\"Could not restore config.xml.\"));\n\t\t}\n\t} else {\n\t\tgenerate_config_cache($config);\n\t}\n\n\tunlock($lockkey);\n\n\tif ($write_config_only) {\n\t\treturn $config;\n\t}\n\n\tunlink_if_exists(\"/usr/local/pkg/pf/carp_sync_client.php\");\n\n\t/* sync carp entries to other firewalls */\n\tcarp_sync_client();\n\n\tif (is_dir(\"/usr/local/pkg/write_config\")) {\n\t\t/* process packager manager custom rules */\n\t\trun_plugins(\"/usr/local/pkg/write_config/\");\n\t}\n\n\t// Try the core AutoConfigBackup system\n\tif (is_array($config['system']['acb']) && $config['system']['acb']['enable'] == \"yes\" &&\n\t    (!isset($config['system']['acb']['frequency']) || $config['system']['acb']['frequency'] == \"every\") || file_exists(\"/tmp/forceacb\")) {\n\t    if ($doacb) {\n\t\t\trequire_once(\"acb.inc\");\n\t\t\tupload_config($manual_acb);\n\t\t}\n\n\t\tif (file_exists(\"/tmp/forceacb\")) {\n\t\t\tunlink(\"/tmp/forceacb\");\n\t\t}\n\t}\n\n\treturn $config;\n}\n\n/****f* config/reset_factory_defaults\n * NAME\n *   reset_factory_defaults - Reset the system to its default configuration.\n * RESULT\n *   integer\t- indicates completion\n ******/\nfunction reset_factory_defaults($lock = false, $reboot_required = true) {\n\tglobal $config, $g;\n\n\t/* Remove all additional packages */\n\tmwexec(\"/bin/sh /usr/local/sbin/{$g['product_name']}-upgrade \" .\n\t    \"-r ALL_PACKAGES -f\");\n\n\tif (!$lock) {\n\t\t$lockkey = lock('config', LOCK_EX);\n\t}\n\n\t/* create conf directory, if necessary */\n\tsafe_mkdir(g_get('cf_conf_path'));\n\n\t/* clear out /conf */\n\t$dh = opendir(g_get('conf_path'));\n\twhile ($filename = readdir($dh)) {\n\t\tif (($filename != \".\") && ($filename != \"..\") &&\n\t\t    (!is_dir(g_get('conf_path') . \"/\" . $filename))) {\n\t\t\tif ($filename == \"enableserial_force\")\n\t\t\t\tcontinue;\n\t\t\tunlink_if_exists(g_get('conf_path') . \"/\" . $filename);\n\t\t}\n\t}\n\tclosedir($dh);\n\tunlink_if_exists(g_get('tmp_path') . \"/config.cache\");\n\n\t/* copy default configuration */\n\tcopy(\"{$g['conf_default_path']}/config.xml\",\n\t    \"{$g['cf_conf_path']}/config.xml\");\n\n\tdisable_security_checks();\n\n\t/*\n\t   Let write_config know that we are awaiting reload of the current config\n\t   to factory defaults. Either the system is about to reboot, throwing away\n\t   the current in-memory config as it shuts down, or the in-memory config\n\t   is about to be reloaded on-the-fly by parse_config.\n\n\t   In both cases, we want to ensure that write_config does not flush the\n\t   in-memory config back to disk.\n\t*/\n\t$config['reset_factory_defaults'] = true;\n\n\t/* call the wizard */\n\tif ($reboot_required) {\n\t\t// If we need a reboot first then touch a different trigger file.\n\t\ttouch(\"/conf/trigger_initial_wizard_after_reboot\");\n\t} else {\n\t\ttouch(\"/conf/trigger_initial_wizard\");\n\t}\n\tif (!$lock) {\n\t\tunlock($lockkey);\n\t}\n\tconsole_configure();\n\treturn 0;\n}\n\nfunction config_restore($conffile) {\n\tglobal $config, $g;\n\n\tif (!file_exists($conffile)) {\n\t\treturn 1;\n\t}\n\n\tbackup_config();\n\n\n\t$lockkey = lock('config', LOCK_EX);\n\n\tunlink_if_exists(\"{$g['tmp_path']}/config.cache\");\n\tcopy($conffile, \"{$g['cf_conf_path']}/config.xml\");\n\n\tdisable_security_checks();\n\n\tunlock($lockkey);\n\n\t$config = parse_config(true);\n\n\n\twrite_config(sprintf(gettext(\"Reverted to %s.\"), array_pop(explode(\"/\", $conffile))), false);\n\n\treturn 0;\n}\n\nfunction config_install($conffile) {\n\tglobal $config, $g;\n\n\tif (!file_exists($conffile)) {\n\t\treturn 1;\n\t}\n\n\tif (!config_validate(\"{$conffile}\")) {\n\t\treturn 1;\n\t}\n\n\tif (platform_booting()) {\n\t\techo gettext(\"Installing configuration...\") . \"\\n\";\n\t} else {\n\t\tlog_error(gettext(\"Installing configuration ....\"));\n\t}\n\n\t$lockkey = lock('config', LOCK_EX);\n\n\tcopy($conffile, \"{$g['conf_path']}/config.xml\");\n\n\tdisable_security_checks();\n\n\t/* unlink cache file if it exists */\n\tif (file_exists(\"{$g['tmp_path']}/config.cache\")) {\n\t\tunlink(\"{$g['tmp_path']}/config.cache\");\n\t}\n\n\tunlock($lockkey);\n\n\treturn 0;\n}\n\n/*\n * Disable security checks for DNS rebind and HTTP referrer until next time\n * they pass (or reboot), to aid in preventing accidental lockout when\n * restoring settings like hostname, domain, IP addresses, and settings\n * related to the DNS rebind and HTTP referrer checks.\n * Intended for use when restoring a configuration or directly\n * modifying config.xml without an unconditional reboot.\n */\nfunction disable_security_checks() {\n\tglobal $g;\n\ttouch(\"{$g['tmp_path']}/disable_security_checks\");\n}\n\n/* Restores security checks.  Should be called after all succeed. */\nfunction restore_security_checks() {\n\tglobal $g;\n\tunlink_if_exists(\"{$g['tmp_path']}/disable_security_checks\");\n}\n\n/* Returns status of security check temporary disable. */\nfunction security_checks_disabled() {\n\tglobal $g;\n\treturn file_exists(\"{$g['tmp_path']}/disable_security_checks\");\n}\n\nfunction config_validate($conffile) {\n\n\tglobal $g, $xmlerr;\n\n\t$xml_parser = xml_parser_create();\n\n\tif (!($fp = fopen($conffile, \"r\"))) {\n\t\t$xmlerr = gettext(\"XML error: unable to open file\");\n\t\treturn false;\n\t}\n\n\twhile ($data = fread($fp, 4096)) {\n\t\tif (!xml_parse($xml_parser, $data, feof($fp))) {\n\t\t\t$xmlerr = sprintf(gettext('%1$s at line %2$d'),\n\t\t\t\t\t\txml_error_string(xml_get_error_code($xml_parser)),\n\t\t\t\t\t\txml_get_current_line_number($xml_parser));\n\t\t\treturn false;\n\t\t}\n\t}\n\txml_parser_free($xml_parser);\n\n\tfclose($fp);\n\n\treturn true;\n}\n\nfunction cleanup_backupcache($lock = false) {\n\tglobal $config, $g;\n\t$i = false;\n\n\t$revisions = intval(is_numericint($config['system']['backupcount']) ? $config['system']['backupcount'] : g_get('default_config_backup_count'));\n\n\tif (!$lock) {\n\t\t$lockkey = lock('config');\n\t}\n\n\n\t$backups = get_backups();\n\tif ($backups) {\n\t\t$baktimes = $backups['versions'];\n\t\tunset($backups['versions']);\n\t} else {\n\t\t$backups = array();\n\t\t$baktimes = array();\n\t}\n\t$newbaks = array();\n\t$bakfiles = glob(g_get('cf_conf_path') . \"/backup/config-*\");\n\t$tocache = array();\n\n\tforeach ($bakfiles as $backup) { // Check for backups in the directory not represented in the cache.\n\t\t$backupsize = filesize($backup);\n\t\tif ($backupsize == 0) {\n\t\t\tunlink($backup);\n\t\t\tcontinue;\n\t\t}\n\t\t$backupexp = explode('-', $backup);\n\t\t$backupexp = explode('.', array_pop($backupexp));\n\t\t$tocheck = array_shift($backupexp);\n\t\tunset($backupexp);\n\t\tif (!in_array($tocheck, $baktimes)) {\n\t\t\t$i = true;\n\t\t\tif (platform_booting()) {\n\t\t\t\techo \".\";\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t$newxml = parse_xml_config($backup, array(g_get('xml_rootobj'), 'pfsense'));\n\t\t\t} catch (Exception $exc) {\n\t\t\t\tlog_error(sprintf(gettext(\"The backup cache file %s is corrupted. Parser error message: %s\"), $backup, $exc->getMessage()));\n\t\t\t\t$newxml = \"-1\";\n\t\t\t}\n\n\t\t\tif ($newxml == \"-1\") {\n\t\t\t\tlog_error(sprintf(gettext(\"The backup cache file %s is corrupted.  Unlinking.\"), $backup));\n\t\t\t\tunlink($backup);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ($newxml['revision']['description'] == \"\") {\n\t\t\t\t$newxml['revision']['description'] = \"Unknown\";\n\t\t\t}\n\t\t\tif ($newxml['version'] == \"\") {\n\t\t\t\t$newxml['version'] = \"?\";\n\t\t\t}\n\t\t\t$tocache[$tocheck] = array('description' => $newxml['revision']['description'], 'version' => $newxml['version'], 'filesize' => $backupsize);\n\t\t}\n\t}\n\tforeach ($backups as $checkbak) {\n\t\tif (count(preg_grep('/' . $checkbak['time'] . '/i', $bakfiles)) != 0) {\n\t\t\t$newbaks[] = $checkbak;\n\t\t} else {\n\t\t\t$i = true;\n\t\t\tif (platform_booting()) print \" \" . $tocheck . \"r\";\n\t\t}\n\t}\n\tforeach ($newbaks as $todo) {\n\t\t$tocache[$todo['time']] = array('description' => $todo['description'], 'version' => $todo['version'], 'filesize' => $todo['filesize']);\n\t}\n\tif (is_int($revisions) and (count($tocache) > $revisions)) {\n\t\t$toslice = array_slice(array_keys($tocache), 0, $revisions);\n\t\t$newcache = array();\n\t\tforeach ($toslice as $sliced) {\n\t\t\t$newcache[$sliced] = $tocache[$sliced];\n\t\t}\n\t\tforeach ($tocache as $version => $versioninfo) {\n\t\t\tif (!in_array($version, array_keys($newcache))) {\n\t\t\t\tunlink_if_exists(g_get('conf_path') . '/backup/config-' . $version . '.xml');\n\t\t\t}\n\t\t}\n\t\t$tocache = $newcache;\n\t}\n\t$bakout = fopen(g_get('cf_conf_path') . '/backup/backup.cache', \"w\");\n\tfwrite($bakout, serialize($tocache));\n\tfclose($bakout);\n\t//pfSense_fsync(\"{$g['cf_conf_path']}/backup/backup.cache\");\n\n\tif (!$lock) {\n\t\tunlock($lockkey);\n\t}\n}\n\nfunction get_backups() {\n\tglobal $g;\n\tif (file_exists(\"{$g['cf_conf_path']}/backup/backup.cache\")) {\n\t\t$confvers = unserialize(file_get_contents(\"{$g['cf_conf_path']}/backup/backup.cache\"));\n\t\t$bakvers = array_keys($confvers);\n\t\t$toreturn = array();\n\t\tsort($bakvers);\n\t\t// \t$bakvers = array_reverse($bakvers);\n\t\tforeach (array_reverse($bakvers) as $bakver) {\n\t\t\t$toreturn[] = array('time' => $bakver, 'description' => $confvers[$bakver]['description'], 'version' => $confvers[$bakver]['version'], 'filesize' => $confvers[$bakver]['filesize']);\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\t$toreturn['versions'] = $bakvers;\n\treturn $toreturn;\n}\n\nfunction backup_config() {\n\tglobal $config, $g;\n\n\n\t/* Create backup directory if needed */\n\tsafe_mkdir(\"{$g['cf_conf_path']}/backup\");\n\tif ($config['revision']['time'] == \"\") {\n\t\t$baktime = 0;\n\t} else {\n\t\t$baktime = config_get_path('revision/time');\n\t}\n\n\tif ($config['revision']['description'] == \"\") {\n\t\t$bakdesc = \"Unknown\";\n\t} else {\n\t\t$bakdesc = config_get_path('revision/description');\n\t}\n\n\t$bakver = ($config['version'] == \"\") ? \"?\" : $config['version'];\n\t$bakfilename = g_get('cf_conf_path') . '/backup/config-' . $baktime . '.xml';\n\tcopy(g_get('cf_conf_path') . '/config.xml', $bakfilename);\n\n\tif (file_exists(g_get('cf_conf_path') . '/backup/backup.cache')) {\n\t\t$backupcache = unserialize(file_get_contents(g_get('cf_conf_path') . '/backup/backup.cache'));\n\t} else {\n\t\t$backupcache = array();\n\t}\n\t$backupcache[$baktime] = array('description' => $bakdesc, 'version' => $bakver, 'filesize' => filesize($bakfilename));\n\t$bakout = fopen(g_get('cf_conf_path') . '/backup/backup.cache', \"w\");\n\tfwrite($bakout, serialize($backupcache));\n\tfclose($bakout);\n\t//pfSense_fsync(\"{$g['cf_conf_path']}/backup/backup.cache\");\n\n\n\treturn true;\n}\n\nfunction backup_info($backup_info, $number) {\n\tif ($backup_info['time'] != 0) {\n\t\t$date = date(gettext(\"n/j/y H:i:s\"), $backup_info['time']);\n\t} else {\n\t\t$date = gettext(\"Unknown\");\n\t}\n\n\tlist($page, $reason) = explode(\": \", $backup_info['description'], 2);\n\tif (empty($reason)) {\n\t\t$reason = $page;\n\t\t$page = gettext(\"Unknown Page\");\n\t}\n\n\t$backup_info = sprintf(\"%02d\", $number) . \". {$date}\\tv{$backup_info['version']}\\t{$page}\\n\";\n\tif ($reason) {\n\t\t$backup_info .= \"    {$reason}\\n\";\n\t}\n\treturn $backup_info;\n}\n\nfunction set_device_perms() {\n\t$devices = array(\n\t\t'pf' => array(\n\t\t\t'user' => 'root',\n\t\t\t'group' => 'proxy',\n\t\t\t'mode' => 0660),\n\t\t);\n\n\tforeach ($devices as $name => $attr) {\n\t\t$path = \"/dev/$name\";\n\t\tif (file_exists($path)) {\n\t\t\tchown($path, $attr['user']);\n\t\t\tchgrp($path, $attr['group']);\n\t\t\tchmod($path, $attr['mode']);\n\t\t}\n\t}\n}\n\nfunction get_config_user() {\n\tif (empty($_SESSION[\"Username\"])) {\n\t\t$username = getenv(\"USER\");\n\t\tif (empty($conuser) || $conuser == \"root\") {\n\t\t\t$username = \"(system)\";\n\t\t}\n\t} else {\n\t\t$username = $_SESSION[\"Username\"];\n\t}\n\n\tif (!empty($_SERVER['REMOTE_ADDR'])) {\n\t\t$username .= '@' . get_user_remote_address() . get_user_remote_authsource();\n\t}\n\n\treturn $username;\n}\n\nfunction make_config_revision_entry($desc = null, $override_user = null) {\n\tif (empty($override_user)) {\n\t\t$username = get_config_user();\n\t} else {\n\t\t$username = $override_user;\n\t}\n\n\t$revision = array();\n\n\tif (time() > mktime(0, 0, 0, 9, 1, 2004)) {     /* make sure the clock settings are plausible */\n\t\t$revision['time'] = time();\n\t}\n\n\t/* Log the running script so it's not entirely unlogged what changed */\n\tif ($desc == \"Unknown\") {\n\t\t$desc = sprintf(gettext(\"%s made unknown change\"), $_SERVER['SCRIPT_NAME']);\n\t}\n\tif (!empty($desc)) {\n\t\t$revision['description'] = \"{$username}: \" . $desc;\n\t}\n\t$revision['username'] = $username;\n\treturn $revision;\n}\n\nfunction pfSense_clear_globals() {\n\tglobal $config, $g, $FilterIfList, $GatewaysList, $filterdns, $aliases, $aliastable;\n\n\t$error = error_get_last();\n\n\t// Errors generated by user code (diag_commands.php) are identified by path and not added to notices\n\tif ($error !== NULL && !preg_match('|^' . preg_quote(g_get('tmp_path_user_code')) . '/[^/]{1,16}$|', $error['file'])) {\n\t\tif (in_array($error['type'], array(E_ERROR, E_COMPILE_ERROR, E_CORE_ERROR, E_RECOVERABLE_ERROR))) {\n\t\t\t$errorstr = \"PHP ERROR: Type: {$error['type']}, File: {$error['file']}, Line: {$error['line']}, Message: {$error['message']}\";\n\t\t\tprint($errorstr);\n\t\t\tlog_error($errorstr);\n\t\t\tfile_notice(\"phperror\", $errorstr, 'PHP errors');\n\t\t} else if ($error['type'] != E_NOTICE) {\n\t\t\t$errorstr = \"PHP WARNING: Type: {$error['type']}, File: {$error['file']}, Line: {$error['line']}, Message: {$error['message']}\";\n\t\t\t// XXX: comment out for now, should re-enable post-2.2\n\t\t\t//print($errorstr);\n\t\t\t//log_error($errorstr);\n\t\t\t//file_notice(\"phpwarning\", $errorstr, 'PHP warning');\n\t\t}\n\t}\n\n\tif (isset($FilterIfList)) {\n\t\tunset($FilterIfList);\n\t}\n\n\tif (isset($GatewaysList)) {\n\t\tunset($GatewaysList);\n\t}\n\n\t/* Used for the hostname dns resolver */\n\tif (isset($filterdns)) {\n\t\tunset($filterdns);\n\t}\n\n\t/* Used for aliases and interface macros */\n\tif (isset($aliases)) {\n\t\tunset($aliases);\n\t}\n\tif (isset($aliastable)) {\n\t\tunset($aliastable);\n\t}\n\n\tunset($config);\n}\n\n/*\n * Same semantics as init_config_arr(), but with the new\n * path string interface.\n */\nfunction config_init_path(string $path) {\n\tglobal $config;\n\tarray_init_path($config, $path);\n}\n\n/* \n * Notice: Use config_init_path() instead, if you must...\n *\n * This is retained for compatibility with older code\n *\n * Initialize a config array multiple levels deep only if unset\n * Pass it an array of keys to test and create\n * init_config_arr(array('virtualip', 'vip'));\n */\nfunction init_config_arr($keys) {\n\t// just translate the old signature to the new one\n\tconfig_init_path(implode('/', $keys));\n}\n\n/**\n * Return a value specified by path in the config, if it exists.\n * @param $path string path with '/' separators\n * @param $default mixed value to return if the path is not found\n * @returns mixed value at path or $default if the path does not exist or if the\n *          path keys an empty string and $default is non-null\n */\nfunction config_get_path(string $path, $default = null) {\n\tglobal $config;\n\treturn(array_get_path($config, $path, $default));\n}\n\n/**\n * Set a value by path in the config, creating arrays for intermediary keys as\n * necessary. If the path cannot be reached because an intermediary exists but\n * is not empty or an array, return $default.\n * @param $path string path with '/' separators\n * @param $val mixed \n * @param $default mixed value to return if the path is not found\n * @returns mixed $val or $default if the path prefix does not exist\n */\nfunction config_set_path(string $path, $value, $default = null) {\n\tglobal $config;\n\treturn (array_set_path($config, $path, $value, $default));\n}\n\n/**\n * Determine whether a path in the config has a non-null value keyed by\n * $enable_key. Some parts of the config historically identify services as\n * enabled by having a key to a non-null value named 'enable', and checking it\n * with isset(). This can be counter-intuitive as isset() will return true if\n * the array element is any non-null value that evaluates to false.\n * @param $path string path with '/' separators\n * @param $enable_key string an optional alternative key value for the enable key\n * @returns bool true if $enable_key exists in the array at $path, and has a\n * non-null value, otherwise false.\n */\nfunction config_path_enabled(string $path, $enable_key = \"enable\") {\n\tglobal $config;\n\treturn (array_path_enabled($config, $path, $enable_key));\n}\n\n/**\n * Remove a key from the config by path\n * @param $path string path with '/' separators\n * @returns array copy of the removed value or null\n */\nfunction config_del_path(string $path) {\n\tglobal $config;\n\treturn (array_del_path($config, $path));\n}\nregister_shutdown_function('pfSense_clear_globals');\n\n?>\n", "<?php\n/*\n * backup.inc\n *\n * part of pfSense (https://www.pfsense.org)\n * Copyright (c) 2004-2013 BSD Perimeter\n * Copyright (c) 2013-2016 Electric Sheep Fencing\n * Copyright (c) 2014-2022 Rubicon Communications, LLC (Netgate)\n * All rights reserved.\n *\n * originally based on m0n0wall (http://m0n0.ch/wall)\n * Copyright (c) 2003-2004 Manuel Kasper <mk@neon1.net>.\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* Allow additional execution time 0 = no limit. */\nini_set('max_execution_time', '0');\nini_set('max_input_time', '0');\n\n/* omit no-cache headers because it confuses IE with file downloads */\n$omit_nocacheheaders = true;\nrequire_once(\"config.gui.inc\");\nrequire_once(\"config.lib.inc\");\nrequire_once(\"functions.inc\");\nrequire_once(\"filter.inc\");\nrequire_once(\"shaper.inc\");\nrequire_once(\"pkg-utils.inc\");\n\n$rrddbpath = \"/var/db/rrd\";\n$rrdtool = \"/usr/bin/nice -n20 /usr/local/bin/rrdtool\";\n\nfunction rrd_data_xml() {\n\tglobal $rrddbpath;\n\tglobal $rrdtool;\n\n\t$result = \"\\t<rrddata>\\n\";\n\t$rrd_files = glob(\"{$rrddbpath}/*.rrd\");\n\t$xml_files = array();\n\tforeach ($rrd_files as $rrd_file) {\n\t\t$basename = basename($rrd_file);\n\t\t$xml_file = preg_replace('/\\.rrd$/', \".xml\", $rrd_file);\n\t\texec(\"$rrdtool dump '{$rrd_file}' '{$xml_file}'\");\n\t\t$xml_data = file_get_contents($xml_file);\n\t\tunlink($xml_file);\n\t\tif ($xml_data !== false) {\n\t\t\t$result .= \"\\t\\t<rrddatafile>\\n\";\n\t\t\t$result .= \"\\t\\t\\t<filename>{$basename}</filename>\\n\";\n\t\t\t$result .= \"\\t\\t\\t<xmldata>\" . base64_encode(gzdeflate($xml_data)) . \"</xmldata>\\n\";\n\t\t\t$result .= \"\\t\\t</rrddatafile>\\n\";\n\t\t}\n\t}\n\t$result .= \"\\t</rrddata>\\n\";\n\treturn $result;\n}\n\nfunction backup_xmldatafile($tab=false, $type='voucher') {\n\tglobal $g;\n\n\t$xmldata_files = glob(\"{$g['backuppath'][$type]}\");\n\tif (empty($xmldata_files)) {\n\t\treturn;\n\t}\n\t$t = ($tab) ? \"\\t\" : \"\";\n\t$result = \"{$t}\\t<{$type}data>\\n\";\n\tforeach ($xmldata_files as $xmldata_file) {\n\t\t$basename = basename($xmldata_file);\n\t\t$data = file_get_contents($xmldata_file);\n\t\tif ($data !== false) {\n\t\t\t$result .= \"{$t}\\t\\t<xmldatafile>\\n\";\n\t\t\t$result .= \"{$t}\\t\\t\\t<filename>{$basename}</filename>\\n\";\n\t\t\t$result .= \"{$t}\\t\\t\\t<data>\" . base64_encode(gzdeflate($data)) . \"</data>\\n\";\n\t\t\t$result .= \"{$t}\\t\\t</xmldatafile>\\n\";\n\t\t}\n\t}\n\t$result .= \"{$t}\\t</{$type}data>\\n\";\n\n\treturn $result;\n}\n\nfunction ssh_keys_xml() {\n\tglobal $ssh_keys, $sshConfigDir;\n\n\t$keyfiles = array();\n\tforeach ($ssh_keys as $key) {\n\t\t$keyfiles[] = \"ssh_host_{$key['suffix']}key\";\n\t\t$keyfiles[] = \"ssh_host_{$key['suffix']}key.pub\";\n\t}\n\n\t$result = \"\\t<sshdata>\\n\";\n\tforeach ($keyfiles as $f2c) {\n\t\t$keyfile = \"{$sshConfigDir}/{$f2c}\";\n\t\tif (file_exists($keyfile) && (filesize($keyfile) != 0)) {\n\t\t\t$result .= \"\\t\\t<sshkeyfile>\\n\";\n\t\t\t$result .= \"\\t\\t\\t<filename>{$f2c}</filename>\\n\";\n\t\t\t$result .= \"\\t\\t\\t<xmldata>\" . base64_encode(gzdeflate(file_get_contents($keyfile))) . \"</xmldata>\\n\";\n\t\t\t$result .= \"\\t\\t</sshkeyfile>\\n\";\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\t$result .= \"\\t</sshdata>\\n\";\n\treturn $result;\n}\n\nfunction check_and_returnif_section_exists($section) {\n\tglobal $config;\n\tif (is_array($config[$section])) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction execPost($post, $postfiles, $ui = true) {\n\tglobal $config, $g;\n\n\tunset($input_errors);\n\n\tif ($post['restore']) {\n\t\t$mode = \"restore\";\n\t} else if ($post['download']) {\n\t\t$mode = \"download\";\n\t}\n\tif ($post[\"nopackages\"] <> \"\") {\n\t\t$options = \"nopackages\";\n\t}\n\n\tif ($mode) {\n\t\tif ($mode == \"download\") {\n\t\t\tif ($post['encrypt']) {\n\t\t\t\tif (!$post['encrypt_password'] || ($post['encrypt_password'] != $post['encrypt_password_confirm'])) {\n\t\t\t\t\t$input_errors[] = gettext(\"Supplied password and confirmation do not match.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$input_errors) {\n\t\t\t\t$host = \"{$config['system']['hostname']}.{$config['system']['domain']}\";\n\t\t\t\t$name = \"config-{$host}-\".date(\"YmdHis\").\".xml\";\n\t\t\t\t$data = \"\";\n\n\t\t\t\tif ($options == \"nopackages\") {\n\t\t\t\t\tif (!$post['backuparea']) {\n\t\t\t\t\t\t/* backup entire configuration */\n\t\t\t\t\t\t$data = file_get_contents(\"{$g['conf_path']}/config.xml\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* backup specific area of configuration */\n\t\t\t\t\t\t$data = backup_config_section($post['backuparea']);\n\t\t\t\t\t\t$name = \"{$post['backuparea']}-{$name}\";\n\t\t\t\t\t}\n\t\t\t\t\t$data = preg_replace('/\\t*<installedpackages>.*<\\/installedpackages>\\n/sm', '', $data);\n\t\t\t\t} else {\n\t\t\t\t\tif (!$post['backuparea']) {\n\t\t\t\t\t\t/* backup entire configuration */\n\t\t\t\t\t\t$data = file_get_contents(\"{$g['conf_path']}/config.xml\");\n\t\t\t\t\t} else if ($post['backuparea'] === \"rrddata\") {\n\t\t\t\t\t\t$data = rrd_data_xml();\n\t\t\t\t\t\t$name = \"{$post['backuparea']}-{$name}\";\n\t\t\t\t\t} else if (array_key_exists($post['backuparea'], g_get('backuppath')) && $post['backupdata']) {\n\t\t\t\t\t\t$data = backup_config_section($post['backuparea']);\n\t\t\t\t\t\t$data = clear_tagdata($post['backuparea'], $data);\n\t\t\t\t\t\t$dataxml = backup_xmldatafile(false, $post['backuparea']);\n\t\t\t\t\t\t$closing_tag = \"</{$post['backuparea']}>\";\n\t\t\t\t\t\t$data = str_replace($closing_tag, $dataxml . $closing_tag, $data);\n\t\t\t\t\t\t$name = \"{$post['backuparea']}-{$name}\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* backup specific area of configuration */\n\t\t\t\t\t\t$data = backup_config_section($post['backuparea']);\n\t\t\t\t\t\t$name = \"{$post['backuparea']}-{$name}\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($post['backuparea'] != \"rrddata\") {\n\t\t\t\t\t$data = clear_tagdata('rrd', $data);\n\t\t\t\t}\n\n\t\t\t\tif (!$post['backuparea'] && $post['backupdata']) {\n\t\t\t\t\tforeach (g_get('backuppath') as $bk => $path) {\n\t\t\t\t\t\tif (!empty($config[$bk])) {\n\t\t\t\t\t\t\t$data = clear_tagdata($bk, $data);\n\t\t\t\t\t\t\t$dataxml = backup_xmldatafile(true, $bk);\n\t\t\t\t\t\t\t$closing_tag = \"\\t</{$bk}>\";\n\t\t\t\t\t\t\t$data = str_replace($closing_tag, $dataxml . $closing_tag, $data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* If the config on disk contains any rrddata/sshdata tags, remove them to\n\t\t\t\t * avoid forming invalid XML in the resulting backup.\n\t\t\t\t * See Redmine issues:\n\t\t\t\t * https://redmine.pfsense.org/issues/8994\n\t\t\t\t * https://redmine.pfsense.org/issues/10508\n\t\t\t\t * https://redmine.pfsense.org/issues/13132\n\t\t\t\t */\n\t\t\t\tforeach (array('rrd', 'ssh') as $tag) {\n\t\t\t\t\t/* Match across multiple lines for the tags and data within to remove */\n\t\t\t\t\t$data = preg_replace(\"/[[:blank:]]*<{$tag}data>.*<\\\\/{$tag}data>[[:blank:]]*\\n*/s\", \"\", $data);\n\t\t\t\t\t$data = preg_replace(\"/[[:blank:]]*<{$tag}data\\\\/>[[:blank:]]*\\n*/\", \"\", $data);\n\t\t\t\t}\n\n\t\t\t\tif (($post['backuparea'] != \"rrddata\") && !$post['donotbackuprrd']) {\n\t\t\t\t\t$rrd_data_xml = rrd_data_xml();\n\t\t\t\t\t$closing_tag = \"</\" . g_get('xml_rootobj') . \">\";\n\t\t\t\t\t$data = str_replace($closing_tag, $rrd_data_xml . $closing_tag, $data);\n\t\t\t\t}\n\n\t\t\t\tif ($post['backupssh']) {\n\t\t\t\t\t$ssh_keys_xml = ssh_keys_xml();\n\t\t\t\t\t$closing_tag = \"</\" . g_get('xml_rootobj') . \">\";\n\t\t\t\t\t$data = str_replace($closing_tag, $ssh_keys_xml . $closing_tag, $data);\n\t\t\t\t}\n\n\t\t\t\tif ($post['encrypt']) {\n\t\t\t\t\t$data = encrypt_data($data, $post['encrypt_password']);\n\t\t\t\t\ttagfile_reformat($data, $data, \"config.xml\");\n\t\t\t\t}\n\n\t\t\t\tif ($ui) {\n\t\t\t\t\tsend_user_download('data', $data, $name);\n\t\t\t\t} else {\n\t\t\t\t\treturn json_encode(array(\"contents\" => base64_encode($data), \"name\" => $name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($mode == \"restore\") {\n\t\t\tif ($post['decrypt']) {\n\t\t\t\tif (!$post['decrypt_password']) {\n\t\t\t\t\t$input_errors[] = gettext(\"A password for decryption must be supplied and confirmed.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$input_errors) {\n\t\t\t\tif (!$ui || is_uploaded_file($postfiles['conffile']['tmp_name'])) {\n\t\t\t\t\t/* check for empty file */\n\t\t\t\t\tif (!filesize($postfiles['conffile']['tmp_name'])) {\n\t\t\t\t\t\t$input_errors[] = gettext(\"The uploaded file is empty.\");\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t/* read the file contents */\n\t\t\t\t\t\t$data = $ui ? file_get_contents($postfiles['conffile']['tmp_name']) : $postfiles['conffile']['tmp_name'];\n\t\t\t\t\t\tif (!$data) {\n\t\t\t\t\t\t\t$input_errors[] = gettext(\"Warning, could not read file {$postfiles['conffile']['tmp_name']}\");\n\t\t\t\t\t\t} elseif ($post['decrypt']) {\n\t\t\t\t\t\t\tif (!tagfile_deformat($data, $data, \"config.xml\")) {\n\t\t\t\t\t\t\t\t$input_errors[] = sprintf(gettext(\n\t\t\t\t\t\t\t\t    \"The uploaded file does not appear to contain an encrypted %s configuration.\"),\n\t\t\t\t\t\t\t\t    g_get('product_label'));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$data = decrypt_data($data, $post['decrypt_password']);\n\t\t\t\t\t\t\t\tif (empty($data)) {\n\t\t\t\t\t\t\t\t\t$input_errors[] = gettext(\"File decryption failed. Incorrect password or file is invalid.\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If the config on disk contains duplicate or empty rrddata/sshdata\n\t\t\t\t\t * tags, remove them to avoid XML parsing errors.\n\t\t\t\t\t * See Redmine issues\n\t\t\t\t\t * https://redmine.pfsense.org/issues/8994\n\t\t\t\t\t * https://redmine.pfsense.org/issues/10508\n\t\t\t\t\t * https://redmine.pfsense.org/issues/13132\n\t\t\t\t\t */\n\t\t\t\t\tforeach (array('rrd', 'ssh') as $tag) {\n\t\t\t\t\t\t/* Look for empty tags (no data) */\n\t\t\t\t\t\t$data = preg_replace(\"/<{$tag}data><\\\\/{$tag}data>/\", \"\", $data);\n\t\t\t\t\t\t$data = preg_replace(\"/<{$tag}data\\\\/>/\", \"\", $data);\n\t\t\t\t\t\t/* Match across multiple lines for the tags and data within to remove,\n\t\t\t\t\t\t * but use an ungreedy match and a limit to ensure only the most\n\t\t\t\t\t\t * recent entry is retained.\n\t\t\t\t\t\t */\n\t\t\t\t\t\t$data_pattern = \"/[[:blank:]]*<{$tag}data>.*<\\\\/{$tag}data>[[:blank:]]*\\n*/sU\";\n\t\t\t\t\t\t$dmatch = [];\n\t\t\t\t\t\tpreg_match_all($data_pattern, $data, $dmatch);\n\t\t\t\t\t\t/* More than one match, so remove all but one. */\n\t\t\t\t\t\tif (count($dmatch[0]) > 1) {\n\t\t\t\t\t\t\t$data = preg_replace($data_pattern, \"\", $data, (count($dmatch[0]) - 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($post['restorearea'] && !$input_errors) {\n\t\t\t\t\t\t/* restore a specific area of the configuration */\n\t\t\t\t\t\tif (!stristr($data, \"<\" . $post['restorearea'] . \">\")) {\n\t\t\t\t\t\t\t$input_errors[] = gettext(\"An area to restore was selected but the correct xml tag could not be located.\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!restore_config_section($post['restorearea'], $data)) {\n\t\t\t\t\t\t\t\t$input_errors[] = gettext(\"An area to restore was selected but the correct xml tag could not be located.\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$conf_change = false;\n\t\t\t\t\t\t\t\tif ($config['rrddata']) {\n\t\t\t\t\t\t\t\t\trestore_rrddata();\n\t\t\t\t\t\t\t\t\tconfig_del_path('rrddata');\n\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ($config['sshdata']) {\n\t\t\t\t\t\t\t\t\trestore_sshdata();\n\t\t\t\t\t\t\t\t\tconfig_del_path('sshdata');\n\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!empty($config[$post['restorearea']][$post['restorearea'].'data'])) {\n\t\t\t\t\t\t\t\t\trestore_xmldatafile($post['restorearea']);\n\t\t\t\t\t\t\t\t\tconfig_del_path(\"{$post['restorearea']}/{$post['restorearea']}data\");\n\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ($conf_change) {\n\t\t\t\t\t\t\t\t\twrite_config(sprintf(gettext(\"Unset RRD and extra data from configuration after restoring %s configuration area\"), $post['restorearea']));\n\t\t\t\t\t\t\t\t\tunlink_if_exists(\"{$g['tmp_path']}/config.cache\");\n\t\t\t\t\t\t\t\t\tconvert_config();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfilter_configure();\n\t\t\t\t\t\t\t\t$savemsg = gettext(\"The configuration area has been restored. The firewall may need to be rebooted.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif (!$input_errors) {\n\t\t\t\t\t\tif (!stristr($data, \"<\" . g_get('xml_rootobj') . \">\")) {\n\t\t\t\t\t\t\t$input_errors[] = sprintf(gettext(\"A full configuration restore was selected but a %s tag could not be located.\"), g_get('xml_rootobj'));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* restore the entire configuration */\n\t\t\t\t\t\t\tfile_put_contents($postfiles['conffile']['tmp_name'], $data);\n\t\t\t\t\t\t\tif (config_install($postfiles['conffile']['tmp_name']) == 0) {\n\t\t\t\t\t\t\t\t/* Save current pkg repo to re-add on new config */\n\t\t\t\t\t\t\t\tunset($pkg_repo_conf_path);\n\t\t\t\t\t\t\t\tif (isset($config['system']['pkg_repo_conf_path'])) {\n\t\t\t\t\t\t\t\t\t$pkg_repo_conf_path = config_get_path('system/pkg_repo_conf_path');\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/* this will be picked up by /index.php */\n\t\t\t\t\t\t\t\tmark_subsystem_dirty(\"restore\");\n\t\t\t\t\t\t\t\ttouch(\"/conf/needs_package_sync\");\n\t\t\t\t\t\t\t\t/* remove cache, we will force a config reboot */\n\t\t\t\t\t\t\t\tif (file_exists(\"{$g['tmp_path']}/config.cache\")) {\n\t\t\t\t\t\t\t\t\tunlink(\"{$g['tmp_path']}/config.cache\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$config = parse_config(true);\n\n\t\t\t\t\t\t\t\t/* Restore previously pkg repo configured */\n\t\t\t\t\t\t\t\t$pkg_repo_restored = false;\n\t\t\t\t\t\t\t\tif (isset($pkg_repo_conf_path)) {\n\t\t\t\t\t\t\t\t\t$config['system']['pkg_repo_conf_path'] =\n\t\t\t\t\t\t\t\t\t    $pkg_repo_conf_path;\n\t\t\t\t\t\t\t\t\t$pkg_repo_restored = true;\n\t\t\t\t\t\t\t\t} elseif (isset($config['system']['pkg_repo_conf_path'])) {\n\t\t\t\t\t\t\t\t\tconfig_del_path('system/pkg_repo_conf_path');\n\t\t\t\t\t\t\t\t\t$pkg_repo_restored = true;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ($pkg_repo_restored) {\n\t\t\t\t\t\t\t\t\twrite_config(gettext(\"Removing pkg repository set after restoring full configuration\"));\n\t\t\t\t\t\t\t\t\tpkg_update(true);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (file_exists(\"/boot/loader.conf\")) {\n\t\t\t\t\t\t\t\t\t$loaderconf = file_get_contents(\"/boot/loader.conf\");\n\t\t\t\t\t\t\t\t\tif (strpos($loaderconf, \"console=\\\"comconsole\") ||\n\t\t\t\t\t\t\t\t\t    strpos($loaderconf, \"boot_serial=\\\"YES\")) {\n\t\t\t\t\t\t\t\t\t\t$config['system']['enableserial'] = true;\n\t\t\t\t\t\t\t\t\t\twrite_config(gettext(\"Restore serial console enabling in configuration.\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tunset($loaderconf);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (file_exists(\"/boot/loader.conf.local\")) {\n\t\t\t\t\t\t\t\t\t$loaderconf = file_get_contents(\"/boot/loader.conf.local\");\n\t\t\t\t\t\t\t\t\tif (strpos($loaderconf, \"console=\\\"comconsole\") ||\n\t\t\t\t\t\t\t\t\t    strpos($loaderconf, \"boot_serial=\\\"YES\")) {\n\t\t\t\t\t\t\t\t\t\t$config['system']['enableserial'] = true;\n\t\t\t\t\t\t\t\t\t\twrite_config(gettext(\"Restore serial console enabling in configuration.\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tunset($loaderconf);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/* extract out rrd items, unset from $config when done */\n\t\t\t\t\t\t\t\t$conf_change = false;\n\t\t\t\t\t\t\t\tif ($config['rrddata']) {\n\t\t\t\t\t\t\t\t\trestore_rrddata();\n\t\t\t\t\t\t\t\t\tconfig_del_path('rrddata');\n\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ($config['sshdata']) {\n\t\t\t\t\t\t\t\t\trestore_sshdata();\n\t\t\t\t\t\t\t\t\tconfig_del_path('sshdata');\n\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tforeach (g_get('backuppath') as $bk => $path) {\n\t\t\t\t\t\t\t\t\tif (!empty($config[$bk][$bk.'data'])) {\n\t\t\t\t\t\t\t\t\t\trestore_xmldatafile($bk);\n\t\t\t\t\t\t\t\t\t\tconfig_del_path(\"{$bk}/{$bk}data\");\n\t\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ($conf_change) {\n\t\t\t\t\t\t\t\t\twrite_config(gettext(\"Unset RRD and extra data from configuration after full restore.\"));\n\t\t\t\t\t\t\t\t\tunlink_if_exists(\"{$g['tmp_path']}/config.cache\");\n\t\t\t\t\t\t\t\t\tconvert_config();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (is_array($config['captiveportal'])) {\n\t\t\t\t\t\t\t\t\tforeach ($config['captiveportal'] as $cp) {\n\t\t\t\t\t\t\t\t\t\tif (isset($cp['enable'])) {\n\t\t\t\t\t\t\t\t\t\t\t/* for some reason ipfw doesn't init correctly except on bootup sequence */\n\t\t\t\t\t\t\t\t\t\t\tmark_subsystem_dirty(\"restore\");\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconsole_configure();\n\t\t\t\t\t\t\t\tif (is_interface_mismatch() == true) {\n\t\t\t\t\t\t\t\t\ttouch(\"/var/run/interface_mismatch_reboot_needed\");\n\t\t\t\t\t\t\t\t\tclear_subsystem_dirty(\"restore\");\n\t\t\t\t\t\t\t\t\tconvert_config();\n\t\t\t\t\t\t\t\t\tif ($ui) {\n\t\t\t\t\t\t\t\t\t\theader(\"Location: interfaces_assign.php\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\texit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (is_interface_vlan_mismatch() == true) {\n\t\t\t\t\t\t\t\t\ttouch(\"/var/run/interface_mismatch_reboot_needed\");\n\t\t\t\t\t\t\t\t\tclear_subsystem_dirty(\"restore\");\n\t\t\t\t\t\t\t\t\tconvert_config();\n\t\t\t\t\t\t\t\t\tif ($ui) {\n\t\t\t\t\t\t\t\t\t\theader(\"Location: interfaces_assign.php\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\texit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$input_errors[] = gettext(\"The configuration could not be restored.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$input_errors[] = gettext(\"The configuration could not be restored (file upload error).\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn array(\"input_errors\" => $input_errors, \"savemsg\" => $savemsg);\n}\n\n// Compose a list of recent backups formatted as a JSON array\nfunction listBackupsJSON() {\n\tglobal $g;\n\n\tcleanup_backupcache(false);\n\n\t$raw = unserialize(file_get_contents(g_get('cf_conf_path') . \"/backup/backup.cache\"));\n\n\t$backups = array();\n\tforeach($raw as $key => $value) {\n\t    $backups[] = array(\"time\" => $key, \"desc\" => $value['description'], \"size\" => $value['filesize'], \"vers\" => $value['version']);\n\t}\n\n\treturn json_encode($backups);\n}\n\n?>\n"], "fixing_code": ["<?php\n/*\n * config.lib.inc\n *\n * part of pfSense (https://www.pfsense.org)\n * Copyright (c) 2004-2013 BSD Perimeter\n * Copyright (c) 2013-2016 Electric Sheep Fencing\n * Copyright (c) 2014-2022 Rubicon Communications, LLC (Netgate)\n * Copyright (c) 2009 Erik Kristensen\n * All rights reserved.\n *\n * originally part of m0n0wall (http://m0n0.ch/wall)\n * Copyright (c) 2003-2004 Manuel Kasper <mk@neon1.net>.\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nrequire_once('util.inc');\n\n/****f* config/encrypted_configxml\n * NAME\n *   encrypted_configxml - Checks to see if config.xml is encrypted and if so, prompts to unlock.\n * INPUTS\n *   None\n * RESULT\n *   $config \t- rewrites config.xml without encryption\n ******/\nfunction encrypted_configxml() {\n\tglobal $g, $config;\n\n\tif (!file_exists(g_get('conf_path') . \"/config.xml\")) {\n\t\treturn;\n\t}\n\n\tif (!platform_booting()) {\n\t\treturn;\n\t}\n\n\t$configtxt = file_get_contents(g_get('conf_path') . \"/config.xml\");\n\tif (tagfile_deformat($configtxt, $configtxt, \"config.xml\")) {\n\t\t$fp = fopen('php://stdin', 'r');\n\t\t$data = \"\";\n\t\techo \"\\n\\n*** Encrypted config.xml detected ***\\n\";\n\t\twhile ($data == \"\") {\n\t\t\techo \"\\nEnter the password to decrypt config.xml: \";\n\t\t\t$decrypt_password = chop(fgets($fp));\n\t\t\t$data = decrypt_data($configtxt, $decrypt_password);\n\t\t\tif (!strstr($data, \"<pfsense>\")) {\n\t\t\t\t$data = \"\";\n\t\t\t}\n\t\t\tif ($data) {\n\t\t\t\t$fd = fopen(g_get('conf_path') . \"/config.xml.tmp\", \"w\");\n\t\t\t\tfwrite($fd, $data);\n\t\t\t\tfclose($fd);\n\t\t\t\texec(\"/bin/mv {$g['conf_path']}/config.xml.tmp {$g['conf_path']}/config.xml\");\n\t\t\t\techo \"\\n\" . gettext(\"Config.xml unlocked.\") . \"\\n\";\n\t\t\t\tfclose($fp);\n\t\t\t\t//pfSense_fsync(\"{$g['conf_path']}/config.xml\");\n\t\t\t} else {\n\t\t\t\techo \"\\n\" . gettext(\"Invalid password entered.  Please try again.\") . \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}\n\n/****f* config/parse_config\n * NAME\n *   parse_config - Read in config.cache or config.xml if needed and return $config array\n * INPUTS\n *   $parse       - boolean to force parse_config() to read config.xml and generate config.cache\n * RESULT\n *   $config      - array containing all configuration variables\n ******/\nfunction parse_config($parse = false) {\n\tglobal $g, $config_parsed, $config_extra;\n\n\t$lockkey = lock('config');\n\t$config_parsed = false;\n\n\tif (!file_exists(\"{$g['conf_path']}/config.xml\") || filesize(\"{$g['conf_path']}/config.xml\") == 0) {\n\t\t$last_backup = discover_last_backup();\n\t\tif ($last_backup) {\n\t\t\tlog_error(gettext(\"No config.xml found, attempting last known config restore.\"));\n\t\t\tfile_notice(\"config.xml\", gettext(\"No config.xml found, attempting last known config restore.\"), \"pfSenseConfigurator\", \"\");\n\t\t\trestore_backup(\"{$g['conf_path']}/backup/{$last_backup}\");\n\t\t} else {\n\t\t\tunlock($lockkey);\n\t\t\tdie(gettext(\"Config.xml is corrupted and is 0 bytes.  Could not restore a previous backup.\"));\n\t\t}\n\t}\n\n\tif (platform_booting(true)) {\n\t\techo \".\";\n\t}\n\n\t// Check for encrypted config.xml\n\tencrypted_configxml();\n\n\tif (!$parse) {\n\t\tif (file_exists(g_get('tmp_path') . '/config.cache')) {\n\t\t\t$config = unserialize(file_get_contents(g_get('tmp_path') . '/config.cache'));\n\t\t\tif (!is_array($config)) {\n\t\t\t\t$parse = true;\n\t\t\t}\n\t\t} else {\n\t\t\t$parse = true;\n\t\t}\n\t}\n\tif ($parse == true) {\n\t\tif (!file_exists(g_get('conf_path') . \"/config.xml\")) {\n\t\t\tif (platform_booting(true)) {\n\t\t\t\techo \".\";\n\t\t\t}\n\t\t\tlog_error(\"No config.xml found, attempting last known config restore.\");\n\t\t\tfile_notice(\"config.xml\", \"No config.xml found, attempting last known config restore.\", \"pfSenseConfigurator\", \"\");\n\t\t\t$last_backup = discover_last_backup();\n\t\t\tif ($last_backup) {\n\t\t\t\trestore_backup(\"/cf/conf/backup/{$last_backup}\");\n\t\t\t} else {\n\t\t\t\tlog_error(gettext(\"Could not restore config.xml.\"));\n\t\t\t\tunlock($lockkey);\n\t\t\t\tdie(gettext(\"Config.xml is corrupted and is 0 bytes.  Could not restore a previous backup.\"));\n\t\t\t}\n\t\t}\n\t\t$config = parse_xml_config(g_get('conf_path') . '/config.xml', array(g_get('xml_rootobj'), 'pfsense'));\n\t\tif ($config == -1) {\n\t\t\t$last_backup = discover_last_backup();\n\t\t\tif ($last_backup) {\n\t\t\t\trestore_backup(\"/cf/conf/backup/{$last_backup}\");\n\t\t\t} else {\n\t\t\t\tlog_error(gettext(\"Could not restore config.xml.\"));\n\t\t\t\tunlock($lockkey);\n\t\t\t\tdie(\"Config.xml is corrupted and is 0 bytes.  Could not restore a previous backup.\");\n\t\t\t}\n\t\t}\n\t\tgenerate_config_cache($config);\n\t}\n\n\tif (platform_booting(true)) {\n\t\techo \".\";\n\t}\n\n\t$config_parsed = true;\n\tunlock($lockkey);\n\n\treturn $config;\n}\n\n/****f* config/generate_config_cache\n * NAME\n *   generate_config_cache - Write serialized configuration to cache.\n * INPUTS\n *   $config\t- array containing current firewall configuration\n * RESULT\n *   boolean\t- true on completion\n ******/\nfunction generate_config_cache($config) {\n\tglobal $g, $config_extra;\n\n\t$configcache = fopen(g_get('tmp_path') . '/config.cache', \"w\");\n\tfwrite($configcache, serialize($config));\n\tfclose($configcache);\n\t//pfSense_fsync(\"{$g['tmp_path']}/config.cache\");\n\n\tunset($configcache);\n\t/* Used for config.extra.xml */\n\tif (file_exists(g_get('tmp_path') . '/config.extra.cache') && $config_extra) {\n\t\t$configcacheextra = fopen(g_get('tmp_path') . '/config.extra.cache', \"w\");\n\t\tfwrite($configcacheextra, serialize($config_extra));\n\t\tfclose($configcacheextra);\n\t\t//pfSense_fsync(\"{$g['tmp_path']}/config.extra.cache\");\n\t\tunset($configcacheextra);\n\t}\n}\n\nfunction discover_last_backup() {\n\tglobal $g;\n\n\t$backups = glob('/cf/conf/backup/*.xml');\n\tforeach (array_reverse($backups) as $backup) {\n\t\t/* checking multiple backups when detecting invalid configuration\n\t\t * https://redmine.pfsense.org/issues/11748 */\n\t\tif (filesize($backup) != 0) {\n\t\t\t$testconfig = parse_xml_config($backup, g_get('xml_rootobj'));\n\t\t\tif ($testconfig != -1) {\n\t\t\t\treturn basename($backup);\n\t\t\t}\n\t\t} \n\t}\n\n\treturn false;\n}\n\nfunction restore_backup($file) {\n\tglobal $g;\n\n\tif (file_exists($file)) {\n\t\t/* restore rrddata/xmldata and clear appropriate data,\n\t\t * see https://redmine.pfsense.org/issues/11050 */\n\t\t$data = file_get_contents(\"$file\");\n\t\t$conf = parse_xml_config(\"$file\", g_get('xml_rootobj'));\n\t\tif ($conf['rrddata']) {\n\t\t\trestore_rrddata($conf);\n\t\t\t$data = clear_tagdata(\"rrd\", $data);\n\t\t}\n\t\tif ($conf['sshdata']) {\n\t\t\trestore_sshdata($conf);\n\t\t\t$data = clear_tagdata(\"ssh\", $data);\n\t\t}\n\t\tforeach (g_get('backuppath') as $bk => $path) {\n\t\t\tif (!empty($conf[$bk][$bk.'data'])) {\n\t\t\t\trestore_xmldatafile($bk, $conf);\n\t\t\t\t$data = clear_tagdata($bk, $data);\n\t\t\t}\n\t\t}\n\t\tfile_put_contents($file, $data);\n\t\tunlink_if_exists(\"{$g['tmp_path']}/config.cache\");\n\t\tcopy(\"$file\", \"/cf/conf/config.xml\");\n\t\t//pfSense_fsync(\"/cf/conf/config.xml\");\n\t\t//pfSense_fsync($g['conf_path']);\n\t\tdisable_security_checks();\n\t\tlog_error(sprintf(gettext('%1$s is restoring the configuration %2$s'), g_get('product_label'), $file));\n\t\tfile_notice(\"config.xml\", sprintf(gettext('%1$s is restoring the configuration %2$s'), g_get('product_label'), $file), \"pfSenseConfigurator\", \"\");\n\t}\n}\n\n/*\n *\tBackup RRD/XML Data\n */\n\n/* If the config on disk had rrddata/xmldata tags already, remove that section first.\n * See https://redmine.pfsense.org/issues/8994,\n *     https://redmine.pfsense.org/issues/10508, \n *     https://redmine.pfsense.org/issues/11050 */\nfunction clear_tagdata($tag, $data) {\n\t$data = preg_replace(\"/[[:blank:]]*<{$tag}data>.*<\\\\/{$tag}data>[[:blank:]]*\\n*/s\", \"\", $data);\n\t$data = preg_replace(\"/[[:blank:]]*<{$tag}data\\\\/>[[:blank:]]*\\n*/\", \"\", $data);\n\n\treturn $data;\n}\n\nfunction restore_xmldatafile($type='voucher', $conf = false) {\n\tglobal $config, $g;\n\n\tif (!$conf) {\n\t\t$conf = & $config;\n\t}\n\n\tforeach ($conf[$type][\"{$type}data\"][\"xmldatafile\"] as $file) {\n\t\t$basename = basename($file['filename']);\n\t\t$dirname = dirname($g['backuppath'][$type]);\n\t\t$xmldata_file = \"{$dirname}/{$basename}\";\n\t\tif (!is_dir($dirname)) {\n\t\t\tsafe_mkdir($dirname);\n\t\t}\n\t\tif (file_put_contents($xmldata_file, gzinflate(base64_decode($file['data']))) === false) {\n\t\t\tlog_error(sprintf(gettext(\"Cannot write %s\"), $xmldata_file));\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nfunction restore_rrddata($conf = false) {\n\tglobal $config, $g, $rrdtool, $input_errors;\n\n\tif (!$conf) {\n\t\t$conf = & $config;\n\t}\n\n\tforeach ($conf['rrddata']['rrddatafile'] as $rrd) {\n\t\tif ($rrd['xmldata']) {\n\t\t\t$rrd_file = \"{$g['vardb_path']}/rrd/\" . basename($rrd['filename']);\n\t\t\t$xml_file = preg_replace('/\\.rrd$/', \".xml\", $rrd_file);\n\t\t\tif (file_put_contents($xml_file, gzinflate(base64_decode($rrd['xmldata']))) === false) {\n\t\t\t\tlog_error(sprintf(gettext(\"Cannot write %s\"), $xml_file));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$output = array();\n\t\t\t$status = null;\n\t\t\texec(\"{$rrdtool} restore -f \" . escapeshellarg($xml_file) . ' ' . escapeshellarg($rrd_file), $output, $status);\n\t\t\tif ($status) {\n\t\t\t\tlog_error(\"rrdtool restore -f '{$xml_file}' '{$rrd_file}' failed returning {$status}.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlink($xml_file);\n\t\t} else if ($rrd['data']) {\n\t\t\t$rrd_file = \"{$g['vardb_path']}/rrd/\" . basename($rrd['filename']);\n\t\t\t$rrd_fd = fopen($rrd_file, \"w\");\n\t\t\tif (!$rrd_fd) {\n\t\t\t\tlog_error(sprintf(gettext(\"Cannot write %s\"), $rrd_file));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$data = base64_decode($rrd['data']);\n\t\t\t/* Try to decompress the data. */\n\t\t\t$dcomp = @gzinflate($data);\n\t\t\tif ($dcomp) {\n\t\t\t\t/* If the decompression worked, write the decompressed data */\n\t\t\t\tif (fwrite($rrd_fd, $dcomp) === false) {\n\t\t\t\t\tlog_error(sprintf(gettext(\"fwrite %s failed\"), $rrd_file));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* If the decompression failed, it wasn't compressed, so write raw data */\n\t\t\t\tif (fwrite($rrd_fd, $data) === false) {\n\t\t\t\t\tlog_error(sprintf(gettext(\"fwrite %s failed\"), $rrd_file));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fclose($rrd_fd) === false) {\n\t\t\t\tlog_error(sprintf(gettext(\"fclose %s failed\"), $rrd_file));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction restore_sshdata($conf = false) {\n\tglobal $config, $sshConfigDir;\n\n\tif (!$conf) {\n\t\t$conf = & $config;\n\t}\n\n\t$oldmask = umask();\n\tforeach ($conf[\"sshdata\"][\"sshkeyfile\"] as $sshkey) {\n\t\t$keypath = \"{$sshConfigDir}/{$sshkey['filename']}\";\n\t\tif (strstr($sshkey['filename'], 'pub')) {\n\t\t\tumask(0133);\n\t\t} else {\n\t\t\tumask(0177);\n\t\t}\n\t\tif (file_put_contents($keypath, gzinflate(base64_decode($sshkey['xmldata']))) === false) {\n\t\t\tlog_error(sprintf(gettext(\"Cannot write %s\"), $sshkey['filename']));\n\t\t\tcontinue;\n\t\t}\n\t}\n\tumask($oldmask);\n}\n\n/****f* config/parse_config_bootup\n * NAME\n *   parse_config_bootup - Bootup-specific configuration checks.\n * RESULT\n *   null\n ******/\nfunction parse_config_bootup() {\n\tglobal $config, $g;\n\n\tif (platform_booting()) {\n\t\techo \".\";\n\t}\n\n\t$lockkey = lock('config');\n\tif (!file_exists(\"{$g['conf_path']}/config.xml\")) {\n\t\tif (platform_booting()) {\n\t\t\t$last_backup = discover_last_backup();\n\t\t\tif ($last_backup) {\n\t\t\t\tlog_error(\"No config.xml found, attempting last known config restore.\");\n\t\t\t\tfile_notice(\"config.xml\", gettext(\"No config.xml found, attempting last known config restore.\"), \"pfSenseConfigurator\", \"\");\n\t\t\t\trestore_backup(\"/cf/conf/backup/{$last_backup}\");\n\t\t\t}\n\t\t\tif (!file_exists(\"{$g['conf_path']}/config.xml\")) {\n\t\t\t\techo sprintf(gettext(\"XML configuration file not found.  %s cannot continue booting.\"), g_get('product_label')) . \"\\n\";\n\t\t\t\tunlock($lockkey);\n\t\t\t\tdie(gettext(\"Could not find a usable configuration file or it's backup! Exiting....\"));\n\t\t\t} else {\n\t\t\t\tlog_error(\"Last known config found and restored.  Please double check the configuration file for accuracy.\");\n\t\t\t\tfile_notice(\"config.xml\", gettext(\"Last known config found and restored.  Please double check the configuration file for accuracy.\"), \"pfSenseConfigurator\", \"\");\n\t\t\t}\n\t\t} else {\n\t\t\tunlock($lockkey);\n\t\t\tlog_error(gettext(\"Could not find a usable configuration file! Exiting....\"));\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tif (filesize(\"{$g['conf_path']}/config.xml\") == 0) {\n\t\t$last_backup = discover_last_backup();\n\t\tif ($last_backup) {\n\t\t\tlog_error(gettext(\"No config.xml found, attempting last known config restore.\"));\n\t\t\tfile_notice(\"config.xml\", gettext(\"No config.xml found, attempting last known config restore.\"), \"pfSenseConfigurator\", \"\");\n\t\t\trestore_backup(\"{$g['conf_path']}/backup/{$last_backup}\");\n\t\t} else {\n\t\t\tunlock($lockkey);\n\t\t\tdie(gettext(\"Config.xml is corrupted and is 0 bytes.  Could not restore a previous backup.\"));\n\t\t}\n\t}\n\tunlock($lockkey);\n\n\t$config = parse_config(true);\n\n\tif ((float)$config['version'] > (float)g_get('latest_config')) {\n\t\techo <<<EOD\n\n\n*******************************************************************************\n* WARNING!                                                                    *\n* The current configuration has been created with a newer version of {$g['product_label']}  *\n* than this one! This can lead to serious misbehavior and even security       *\n* holes! You are urged to either upgrade to a newer version of {$g['product_label']} or     *\n* revert to the default configuration immediately!                            *\n*******************************************************************************\n\n\nEOD;\n\t\t}\n\n\t/* make alias table (for faster lookups) */\n\talias_make_table();\n}\n\n/****f* config/conf_mount_rw\n * NAME\n *   conf_mount_rw - Mount filesystems read/write.\n * RESULT\n *   null\n ******/\n/* mount flash card read/write */\nfunction conf_mount_rw() {\n\t/* Obsoleted. Keep it here until all calls are removed */\n\treturn;\n}\n\n/****f* config/conf_mount_ro\n * NAME\n *   conf_mount_ro - Mount filesystems readonly.\n * RESULT\n *   null\n ******/\nfunction conf_mount_ro() {\n\t/* Obsoleted. Keep it here until all calls are removed */\n\treturn;\n}\n\n/****f* config/convert_config\n * NAME\n *   convert_config - Attempt to update config.xml.\n * DESCRIPTION\n *   convert_config() reads the current global configuration\n *   and attempts to convert it to conform to the latest\n *   config.xml version. This allows major formatting changes\n *   to be made with a minimum of breakage.\n * RESULT\n *   null\n ******/\n/* convert configuration, if necessary */\nfunction convert_config() {\n\tglobal $config, $g;\n\t$now = date(\"H:i:s\");\n\tlog_error(sprintf(gettext(\"Start Configuration upgrade at %s, set execution timeout to 15 minutes\"), $now));\n\t//ini_set(\"max_execution_time\", \"900\");\n\n\t/* special case upgrades */\n\t/* fix every minute crontab bogons entry */\n\tif (is_array($config['cron'])) {\n\t\t$cron_item_count = count($config['cron']['item']);\n\t\tfor ($x = 0; $x < $cron_item_count; $x++) {\n\t\t\tif (stristr($config['cron']['item'][$x]['command'], \"rc.update_bogons.sh\")) {\n\t\t\t\tif ($config['cron']['item'][$x]['hour'] == \"*\") {\n\t\t\t\t\t$config['cron']['item'][$x]['hour'] = \"3\";\n\t\t\t\t\twrite_config(gettext(\"Updated bogon update frequency to 3am\"));\n\t\t\t\t\tlog_error(gettext(\"Updated bogon update frequency to 3am\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Save off config version\n\t$prev_version = config_get_path('version');\n\n\tinclude_once('auth.inc');\n\tinclude_once('upgrade_config.inc');\n\tif (file_exists(\"/etc/inc/upgrade_config_custom.inc\")) {\n\t\tinclude_once(\"upgrade_config_custom.inc\");\n\t}\n\n\tif ($config['version'] == g_get('latest_config')) {\n\t\tadditional_config_upgrade();\n\t\treturn;\t\t/* already at latest version */\n\t}\n\n\tif (!is_array($config['system']['already_run_config_upgrade'])) {\n\t\t$config['system']['already_run_config_upgrade'] = array();\n\t}\n\t$already_run = config_get_path('system/already_run_config_upgrade');\n\n\t/* Loop and run upgrade_VER_to_VER() until we're at current version */\n\twhile ($config['version'] < g_get('latest_config')) {\n\t\t$cur = $config['version'] * 10;\n\t\t$next = $cur + 1;\n\t\t$migration_function = sprintf('upgrade_%03d_to_%03d', $cur,\n\t\t    $next);\n\n\t\tforeach (array(\"\", \"_custom\") as $suffix) {\n\t\t\t$migration_function .= $suffix;\n\t\t\tif (!function_exists($migration_function)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isset($already_run[$migration_function])) {\n\t\t\t\tconfig_del_path(\"system/already_run_config_upgrade/{$migration_function}\");\n\t\t\t} else {\n\t\t\t\t$migration_function();\n\t\t\t}\n\t\t}\n\t\t$config['version'] = sprintf('%.1f', $next / 10);\n\t\tif (platform_booting()) {\n\t\t\techo \".\";\n\t\t}\n\t}\n\n\tif ($prev_version != $config['version']) {\n\t\t$now = date(\"H:i:s\");\n\t\tlog_error(sprintf(gettext(\"Ended Configuration upgrade at %s\"), $now));\n\n\t\twrite_config(sprintf(gettext('Upgraded config version level from %1$s to %2$s'), $prev_version, $config['version']));\n\t}\n\n\tadditional_config_upgrade();\n}\n\n/****f* config/safe_write_file\n * NAME\n *   safe_write_file - Write a file out atomically\n * DESCRIPTION\n *   safe_write_file() Writes a file out atomically by first writing to a\n *   temporary file of the same name but ending with the pid of the current\n *   process, them renaming the temporary file over the original.\n * INPUTS\n *   $filename  - string containing the filename of the file to write\n *   $content   - string or array containing the file content to write to file\n *   $force_binary      - boolean denoting whether we should force binary\n *   mode writing.\n * RESULT\n *   boolean - true if successful, false if not\n ******/\nfunction safe_write_file($file, $content, $force_binary = false) {\n\t$tmp_file = $file . \".\" . getmypid();\n\t$write_mode = $force_binary ? \"wb\" : \"w\";\n\n\t$fd = fopen($tmp_file, $write_mode);\n\tif (!$fd) {\n\t\t// Unable to open temporary file for writing\n\t\treturn false;\n\t}\n\tif (is_array($content)) {\n\t\tforeach ($content as $line) {\n\t\t\tif (!fwrite($fd, $line . \"\\n\")) {\n\t\t\t\t// Unable to write to temporary file\n\t\t\t\tfclose($fd);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} elseif (!fwrite($fd, $content)) {\n\t\t// Unable to write to temporary file\n\t\tfclose($fd);\n\t\treturn false;\n\t}\n\tfflush($fd);\n\tfclose($fd);\n\n\t/* XXX Re-add pfSense_fsync() call here after it's fixed */\n\t// if (!pfSense_fsync($tmp_file) || !rename($tmp_file, $file)) {\n\tif (!rename($tmp_file, $file)) {\n\t\t// Unable to move temporary file to original\n\t\t@unlink($tmp_file);\n\t\treturn false;\n\t}\n\n\t// Sync file before returning\n\t//return pfSense_fsync($file);\n\treturn true;\n}\n\n/****f* config/write_config\n * NAME\n *   write_config - Backup and write the firewall configuration.\n * DESCRIPTION\n *   write_config() handles backing up the current configuration,\n *   applying changes, and regenerating the configuration cache.\n * INPUTS\n *   $desc\t- string containing the a description of configuration changes\n *   $backup\t- boolean: do not back up current configuration if false.\n *   $write_config_only\t- boolean: do not sync or reload anything; just save the configuration if true.\n * RESULT\n *   null\n ******/\n/* save the system configuration */\nfunction write_config($desc=\"Unknown\", $backup = true, $write_config_only = false) {\n\tglobal $config, $g;\n\n\t// Certain strings may be embedded in the $desc (reason) parameter to trigger certain behavior.\n\t// If detected, those strings are removed and a variable set.\n\t$doacb = true;\n\t$manual_acb = false;\n\t$rcnt = 0;\n\n\t$desc = str_replace(\"-MaNuAlBaCkUp\", \"\", $desc, $rcnt);\n\tif ($rcnt > 0) {\n\t\t$manual_acb = true; // Manual backups require special processing on the server\n\t}\n\n\t$rcnt = 0;\n\t$desc = str_replace(\"-NoReMoTeBaCkUp\", \"\", $desc, $rcnt);\n\tif ($rcnt > 0) {\n\t\t$doacb = false; // No ACB will be performed if this string is detected\n\t}\n\n\t/*\n\t* Syncing vouchers happens every minute and sometimes multiple times. We don't\n\t* want to fill up our db with a lot of the same config so just ignore that case.\n\t*/\n\tif((strpos($desc, 'Syncing vouchers') !== false ||\n\t\tstrpos($desc, 'Captive Portal Voucher database synchronized') !== false) ) {\n\t\t$doacb = false;\n\t}\n\n\tif (!empty($_SERVER['REMOTE_ADDR'])) {\n\t\t@phpsession_begin();\n\t\tif (!empty($_SESSION['Username']) && ($_SESSION['Username'] != \"admin\")) {\n\t\t\t$user = getUserEntry($_SESSION['Username']);\n\t\t\tif (is_array($user) && userHasPrivilege($user, \"user-config-readonly\")) {\n\t\t\t\tsyslog(LOG_AUTHPRIV, sprintf(gettext(\"Save config permission denied by the 'User - Config: Deny Config Write' permission for user '%s'.\"), get_config_user()));\n\t\t\t\tphpsession_end(true);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (!isset($argc)) {\n\t\t\tphpsession_end(true);\n\t\t}\n\t}\n\n\tif (isset($config['reset_factory_defaults'])) {\n\t\t/*\n\t\t   We have put a default config.xml on disk and are about to reboot\n\t\t   or reload it. Do not let any system or package code try to save\n\t\t   state to config because that would overwrite the default config\n\t\t   with the running config.\n\t\t*/\n\t\treturn false;\n\t}\n\n\tif ($backup) {\n\t\tbackup_config();\n\t}\n\n\tif ($desc == \"Unknown\") {\n\t\tfile_notice(\"config.xml\", gettext(\n\t\t    'WARNING: write_config() was called without description'));\n\t}\n\t$config['revision'] = make_config_revision_entry($desc);\n\n\t$lockkey = lock('config', LOCK_EX);\n\n\t/* generate configuration XML */\n\t$xmlconfig = dump_xml_config($config, g_get('xml_rootobj'));\n\n\t/* write new configuration */\n\tif (!safe_write_file(\"{$g['cf_conf_path']}/config.xml\", $xmlconfig)) {\n\t\tlog_error(gettext(\"WARNING: Config contents could not be saved. Could not open file!\"));\n\t\tunlock($lockkey);\n\t\tfile_notice(\"config.xml\", sprintf(gettext('Unable to open %1$s/config.xml for writing in write_config()%2$s'), g_get('cf_conf_path'), \"\\n\"));\n\t\treturn -1;\n\t}\n\n\tif (config_get_path('syslog/logconfigchanges') != \"disabled\") {\n\t\tlog_error(gettext(\"Configuration Change\") . \": {$config['revision']['description']}\");\n\t}\n\n\tcleanup_backupcache(true);\n\n\t/* re-read configuration */\n\t/* NOTE: We assume that the file can be parsed since we wrote it. */\n\t$config = parse_xml_config(\"{$g['conf_path']}/config.xml\", g_get('xml_rootobj'));\n\tif ($config == -1) {\n\t\tcopy(\"{$g['conf_path']}/config.xml\", \"{$g['conf_path']}/config.xml.bad\");\n\t\t$last_backup = discover_last_backup();\n\t\tif ($last_backup) {\n\t\t\trestore_backup(\"/cf/conf/backup/{$last_backup}\");\n\t\t\t$config = parse_xml_config(\"{$g['conf_path']}/config.xml\", g_get('xml_rootobj'));\n\t\t\tif (platform_booting()) {\n\t\t\t\techo \"\\n\\n ************** WARNING **************\";\n\t\t\t\techo \"\\n\\n Configuration could not be validated. A previous configuration was restored. \\n\";\n\t\t\t\techo \"\\n The failed configuration file has been saved as {$g['conf_path']}/config.xml.bad \\n\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\tlog_error(gettext(\"Could not restore config.xml.\"));\n\t\t}\n\t} else {\n\t\tgenerate_config_cache($config);\n\t}\n\n\tunlock($lockkey);\n\n\tif ($write_config_only) {\n\t\treturn $config;\n\t}\n\n\tunlink_if_exists(\"/usr/local/pkg/pf/carp_sync_client.php\");\n\n\t/* sync carp entries to other firewalls */\n\tcarp_sync_client();\n\n\tif (is_dir(\"/usr/local/pkg/write_config\")) {\n\t\t/* process packager manager custom rules */\n\t\trun_plugins(\"/usr/local/pkg/write_config/\");\n\t}\n\n\t// Try the core AutoConfigBackup system\n\tif (is_array($config['system']['acb']) && $config['system']['acb']['enable'] == \"yes\" &&\n\t    (!isset($config['system']['acb']['frequency']) || $config['system']['acb']['frequency'] == \"every\") || file_exists(\"/tmp/forceacb\")) {\n\t    if ($doacb) {\n\t\t\trequire_once(\"acb.inc\");\n\t\t\tupload_config($manual_acb);\n\t\t}\n\n\t\tif (file_exists(\"/tmp/forceacb\")) {\n\t\t\tunlink(\"/tmp/forceacb\");\n\t\t}\n\t}\n\n\treturn $config;\n}\n\n/****f* config/reset_factory_defaults\n * NAME\n *   reset_factory_defaults - Reset the system to its default configuration.\n * RESULT\n *   integer\t- indicates completion\n ******/\nfunction reset_factory_defaults($lock = false, $reboot_required = true) {\n\tglobal $config, $g;\n\n\t/* Remove all additional packages */\n\tmwexec(\"/bin/sh /usr/local/sbin/{$g['product_name']}-upgrade \" .\n\t    \"-r ALL_PACKAGES -f\");\n\n\tif (!$lock) {\n\t\t$lockkey = lock('config', LOCK_EX);\n\t}\n\n\t/* create conf directory, if necessary */\n\tsafe_mkdir(g_get('cf_conf_path'));\n\n\t/* clear out /conf */\n\t$dh = opendir(g_get('conf_path'));\n\twhile ($filename = readdir($dh)) {\n\t\tif (($filename != \".\") && ($filename != \"..\") &&\n\t\t    (!is_dir(g_get('conf_path') . \"/\" . $filename))) {\n\t\t\tif ($filename == \"enableserial_force\")\n\t\t\t\tcontinue;\n\t\t\tunlink_if_exists(g_get('conf_path') . \"/\" . $filename);\n\t\t}\n\t}\n\tclosedir($dh);\n\tunlink_if_exists(g_get('tmp_path') . \"/config.cache\");\n\n\t/* copy default configuration */\n\tcopy(\"{$g['conf_default_path']}/config.xml\",\n\t    \"{$g['cf_conf_path']}/config.xml\");\n\n\tdisable_security_checks();\n\n\t/*\n\t   Let write_config know that we are awaiting reload of the current config\n\t   to factory defaults. Either the system is about to reboot, throwing away\n\t   the current in-memory config as it shuts down, or the in-memory config\n\t   is about to be reloaded on-the-fly by parse_config.\n\n\t   In both cases, we want to ensure that write_config does not flush the\n\t   in-memory config back to disk.\n\t*/\n\t$config['reset_factory_defaults'] = true;\n\n\t/* call the wizard */\n\tif ($reboot_required) {\n\t\t// If we need a reboot first then touch a different trigger file.\n\t\ttouch(\"/conf/trigger_initial_wizard_after_reboot\");\n\t} else {\n\t\ttouch(\"/conf/trigger_initial_wizard\");\n\t}\n\tif (!$lock) {\n\t\tunlock($lockkey);\n\t}\n\tconsole_configure();\n\treturn 0;\n}\n\nfunction config_restore($conffile) {\n\tglobal $config, $g;\n\n\tif (!file_exists($conffile)) {\n\t\treturn 1;\n\t}\n\n\tbackup_config();\n\n\n\t$lockkey = lock('config', LOCK_EX);\n\n\tunlink_if_exists(\"{$g['tmp_path']}/config.cache\");\n\tcopy($conffile, \"{$g['cf_conf_path']}/config.xml\");\n\n\tdisable_security_checks();\n\n\tunlock($lockkey);\n\n\t$config = parse_config(true);\n\n\n\twrite_config(sprintf(gettext(\"Reverted to %s.\"), array_pop(explode(\"/\", $conffile))), false);\n\n\treturn 0;\n}\n\nfunction config_install($conffile) {\n\tglobal $config, $g;\n\n\tif (!file_exists($conffile)) {\n\t\treturn 1;\n\t}\n\n\tif (!config_validate(\"{$conffile}\")) {\n\t\treturn 1;\n\t}\n\n\tif (platform_booting()) {\n\t\techo gettext(\"Installing configuration...\") . \"\\n\";\n\t} else {\n\t\tlog_error(gettext(\"Installing configuration ....\"));\n\t}\n\n\t$lockkey = lock('config', LOCK_EX);\n\n\tcopy($conffile, \"{$g['conf_path']}/config.xml\");\n\n\tdisable_security_checks();\n\n\t/* unlink cache file if it exists */\n\tif (file_exists(\"{$g['tmp_path']}/config.cache\")) {\n\t\tunlink(\"{$g['tmp_path']}/config.cache\");\n\t}\n\n\tunlock($lockkey);\n\n\treturn 0;\n}\n\n/*\n * Disable security checks for DNS rebind and HTTP referrer until next time\n * they pass (or reboot), to aid in preventing accidental lockout when\n * restoring settings like hostname, domain, IP addresses, and settings\n * related to the DNS rebind and HTTP referrer checks.\n * Intended for use when restoring a configuration or directly\n * modifying config.xml without an unconditional reboot.\n */\nfunction disable_security_checks() {\n\tglobal $g;\n\ttouch(\"{$g['tmp_path']}/disable_security_checks\");\n}\n\n/* Restores security checks.  Should be called after all succeed. */\nfunction restore_security_checks() {\n\tglobal $g;\n\tunlink_if_exists(\"{$g['tmp_path']}/disable_security_checks\");\n}\n\n/* Returns status of security check temporary disable. */\nfunction security_checks_disabled() {\n\tglobal $g;\n\treturn file_exists(\"{$g['tmp_path']}/disable_security_checks\");\n}\n\nfunction config_validate($conffile) {\n\n\tglobal $g, $xmlerr;\n\n\t$xml_parser = xml_parser_create();\n\n\tif (!($fp = fopen($conffile, \"r\"))) {\n\t\t$xmlerr = gettext(\"XML error: unable to open file\");\n\t\treturn false;\n\t}\n\n\twhile ($data = fread($fp, 4096)) {\n\t\tif (!xml_parse($xml_parser, $data, feof($fp))) {\n\t\t\t$xmlerr = sprintf(gettext('%1$s at line %2$d'),\n\t\t\t\t\t\txml_error_string(xml_get_error_code($xml_parser)),\n\t\t\t\t\t\txml_get_current_line_number($xml_parser));\n\t\t\treturn false;\n\t\t}\n\t}\n\txml_parser_free($xml_parser);\n\n\tfclose($fp);\n\n\treturn true;\n}\n\nfunction cleanup_backupcache($lock = false) {\n\tglobal $config, $g;\n\t$i = false;\n\n\t$revisions = intval(is_numericint($config['system']['backupcount']) ? $config['system']['backupcount'] : g_get('default_config_backup_count'));\n\n\tif (!$lock) {\n\t\t$lockkey = lock('config');\n\t}\n\n\n\t$backups = get_backups();\n\tif ($backups) {\n\t\t$baktimes = $backups['versions'];\n\t\tunset($backups['versions']);\n\t} else {\n\t\t$backups = array();\n\t\t$baktimes = array();\n\t}\n\t$newbaks = array();\n\t$bakfiles = glob(g_get('cf_conf_path') . \"/backup/config-*\");\n\t$tocache = array();\n\n\tforeach ($bakfiles as $backup) { // Check for backups in the directory not represented in the cache.\n\t\t$backupsize = filesize($backup);\n\t\tif ($backupsize == 0) {\n\t\t\tunlink($backup);\n\t\t\tcontinue;\n\t\t}\n\t\t$backupexp = explode('-', $backup);\n\t\t$backupexp = explode('.', array_pop($backupexp));\n\t\t$tocheck = array_shift($backupexp);\n\t\tunset($backupexp);\n\t\tif (!in_array($tocheck, $baktimes)) {\n\t\t\t$i = true;\n\t\t\tif (platform_booting()) {\n\t\t\t\techo \".\";\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t$newxml = parse_xml_config($backup, array(g_get('xml_rootobj'), 'pfsense'));\n\t\t\t} catch (Exception $exc) {\n\t\t\t\tlog_error(sprintf(gettext(\"The backup cache file %s is corrupted. Parser error message: %s\"), $backup, $exc->getMessage()));\n\t\t\t\t$newxml = \"-1\";\n\t\t\t}\n\n\t\t\tif ($newxml == \"-1\") {\n\t\t\t\tlog_error(sprintf(gettext(\"The backup cache file %s is corrupted.  Unlinking.\"), $backup));\n\t\t\t\tunlink($backup);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ($newxml['revision']['description'] == \"\") {\n\t\t\t\t$newxml['revision']['description'] = \"Unknown\";\n\t\t\t}\n\t\t\tif ($newxml['version'] == \"\") {\n\t\t\t\t$newxml['version'] = \"?\";\n\t\t\t}\n\t\t\t$tocache[$tocheck] = array('description' => $newxml['revision']['description'], 'version' => $newxml['version'], 'filesize' => $backupsize);\n\t\t}\n\t}\n\tforeach ($backups as $checkbak) {\n\t\tif (count(preg_grep('/' . $checkbak['time'] . '/i', $bakfiles)) != 0) {\n\t\t\t$newbaks[] = $checkbak;\n\t\t} else {\n\t\t\t$i = true;\n\t\t\tif (platform_booting()) print \" \" . $tocheck . \"r\";\n\t\t}\n\t}\n\tforeach ($newbaks as $todo) {\n\t\t$tocache[$todo['time']] = array('description' => $todo['description'], 'version' => $todo['version'], 'filesize' => $todo['filesize']);\n\t}\n\tif (is_int($revisions) and (count($tocache) > $revisions)) {\n\t\t$toslice = array_slice(array_keys($tocache), 0, $revisions);\n\t\t$newcache = array();\n\t\tforeach ($toslice as $sliced) {\n\t\t\t$newcache[$sliced] = $tocache[$sliced];\n\t\t}\n\t\tforeach ($tocache as $version => $versioninfo) {\n\t\t\tif (!in_array($version, array_keys($newcache))) {\n\t\t\t\tunlink_if_exists(g_get('conf_path') . '/backup/config-' . $version . '.xml');\n\t\t\t}\n\t\t}\n\t\t$tocache = $newcache;\n\t}\n\t$bakout = fopen(g_get('cf_conf_path') . '/backup/backup.cache', \"w\");\n\tfwrite($bakout, serialize($tocache));\n\tfclose($bakout);\n\t//pfSense_fsync(\"{$g['cf_conf_path']}/backup/backup.cache\");\n\n\tif (!$lock) {\n\t\tunlock($lockkey);\n\t}\n}\n\nfunction get_backups() {\n\tglobal $g;\n\tif (file_exists(\"{$g['cf_conf_path']}/backup/backup.cache\")) {\n\t\t$confvers = unserialize(file_get_contents(\"{$g['cf_conf_path']}/backup/backup.cache\"));\n\t\t$bakvers = array_keys($confvers);\n\t\t$toreturn = array();\n\t\tsort($bakvers);\n\t\t// \t$bakvers = array_reverse($bakvers);\n\t\tforeach (array_reverse($bakvers) as $bakver) {\n\t\t\t$toreturn[] = array('time' => $bakver, 'description' => $confvers[$bakver]['description'], 'version' => $confvers[$bakver]['version'], 'filesize' => $confvers[$bakver]['filesize']);\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\t$toreturn['versions'] = $bakvers;\n\treturn $toreturn;\n}\n\nfunction backup_config() {\n\tglobal $config, $g;\n\n\n\t/* Create backup directory if needed */\n\tsafe_mkdir(\"{$g['cf_conf_path']}/backup\");\n\tif ($config['revision']['time'] == \"\") {\n\t\t$baktime = 0;\n\t} else {\n\t\t$baktime = config_get_path('revision/time');\n\t}\n\n\tif ($config['revision']['description'] == \"\") {\n\t\t$bakdesc = \"Unknown\";\n\t} else {\n\t\t$bakdesc = config_get_path('revision/description');\n\t}\n\n\t$bakver = ($config['version'] == \"\") ? \"?\" : $config['version'];\n\t$bakfilename = g_get('cf_conf_path') . '/backup/config-' . $baktime . '.xml';\n\tcopy(g_get('cf_conf_path') . '/config.xml', $bakfilename);\n\n\tif (file_exists(g_get('cf_conf_path') . '/backup/backup.cache')) {\n\t\t$backupcache = unserialize(file_get_contents(g_get('cf_conf_path') . '/backup/backup.cache'));\n\t} else {\n\t\t$backupcache = array();\n\t}\n\t$backupcache[$baktime] = array('description' => $bakdesc, 'version' => $bakver, 'filesize' => filesize($bakfilename));\n\t$bakout = fopen(g_get('cf_conf_path') . '/backup/backup.cache', \"w\");\n\tfwrite($bakout, serialize($backupcache));\n\tfclose($bakout);\n\t//pfSense_fsync(\"{$g['cf_conf_path']}/backup/backup.cache\");\n\n\n\treturn true;\n}\n\nfunction backup_info($backup_info, $number) {\n\tif ($backup_info['time'] != 0) {\n\t\t$date = date(gettext(\"n/j/y H:i:s\"), $backup_info['time']);\n\t} else {\n\t\t$date = gettext(\"Unknown\");\n\t}\n\n\tlist($page, $reason) = explode(\": \", $backup_info['description'], 2);\n\tif (empty($reason)) {\n\t\t$reason = $page;\n\t\t$page = gettext(\"Unknown Page\");\n\t}\n\n\t$backup_info = sprintf(\"%02d\", $number) . \". {$date}\\tv{$backup_info['version']}\\t{$page}\\n\";\n\tif ($reason) {\n\t\t$backup_info .= \"    {$reason}\\n\";\n\t}\n\treturn $backup_info;\n}\n\nfunction set_device_perms() {\n\t$devices = array(\n\t\t'pf' => array(\n\t\t\t'user' => 'root',\n\t\t\t'group' => 'proxy',\n\t\t\t'mode' => 0660),\n\t\t);\n\n\tforeach ($devices as $name => $attr) {\n\t\t$path = \"/dev/$name\";\n\t\tif (file_exists($path)) {\n\t\t\tchown($path, $attr['user']);\n\t\t\tchgrp($path, $attr['group']);\n\t\t\tchmod($path, $attr['mode']);\n\t\t}\n\t}\n}\n\nfunction get_config_user() {\n\tif (empty($_SESSION[\"Username\"])) {\n\t\t$username = getenv(\"USER\");\n\t\tif (empty($conuser) || $conuser == \"root\") {\n\t\t\t$username = \"(system)\";\n\t\t}\n\t} else {\n\t\t$username = $_SESSION[\"Username\"];\n\t}\n\n\tif (!empty($_SERVER['REMOTE_ADDR'])) {\n\t\t$username .= '@' . get_user_remote_address() . get_user_remote_authsource();\n\t}\n\n\treturn $username;\n}\n\nfunction make_config_revision_entry($desc = null, $override_user = null) {\n\tif (empty($override_user)) {\n\t\t$username = get_config_user();\n\t} else {\n\t\t$username = $override_user;\n\t}\n\n\t$revision = array();\n\n\tif (time() > mktime(0, 0, 0, 9, 1, 2004)) {     /* make sure the clock settings are plausible */\n\t\t$revision['time'] = time();\n\t}\n\n\t/* Log the running script so it's not entirely unlogged what changed */\n\tif ($desc == \"Unknown\") {\n\t\t$desc = sprintf(gettext(\"%s made unknown change\"), $_SERVER['SCRIPT_NAME']);\n\t}\n\tif (!empty($desc)) {\n\t\t$revision['description'] = \"{$username}: \" . $desc;\n\t}\n\t$revision['username'] = $username;\n\treturn $revision;\n}\n\nfunction pfSense_clear_globals() {\n\tglobal $config, $g, $FilterIfList, $GatewaysList, $filterdns, $aliases, $aliastable;\n\n\t$error = error_get_last();\n\n\t// Errors generated by user code (diag_commands.php) are identified by path and not added to notices\n\tif ($error !== NULL && !preg_match('|^' . preg_quote(g_get('tmp_path_user_code')) . '/[^/]{1,16}$|', $error['file'])) {\n\t\tif (in_array($error['type'], array(E_ERROR, E_COMPILE_ERROR, E_CORE_ERROR, E_RECOVERABLE_ERROR))) {\n\t\t\t$errorstr = \"PHP ERROR: Type: {$error['type']}, File: {$error['file']}, Line: {$error['line']}, Message: {$error['message']}\";\n\t\t\tprint($errorstr);\n\t\t\tlog_error($errorstr);\n\t\t\tfile_notice(\"phperror\", $errorstr, 'PHP errors');\n\t\t} else if ($error['type'] != E_NOTICE) {\n\t\t\t$errorstr = \"PHP WARNING: Type: {$error['type']}, File: {$error['file']}, Line: {$error['line']}, Message: {$error['message']}\";\n\t\t\t// XXX: comment out for now, should re-enable post-2.2\n\t\t\t//print($errorstr);\n\t\t\t//log_error($errorstr);\n\t\t\t//file_notice(\"phpwarning\", $errorstr, 'PHP warning');\n\t\t}\n\t}\n\n\tif (isset($FilterIfList)) {\n\t\tunset($FilterIfList);\n\t}\n\n\tif (isset($GatewaysList)) {\n\t\tunset($GatewaysList);\n\t}\n\n\t/* Used for the hostname dns resolver */\n\tif (isset($filterdns)) {\n\t\tunset($filterdns);\n\t}\n\n\t/* Used for aliases and interface macros */\n\tif (isset($aliases)) {\n\t\tunset($aliases);\n\t}\n\tif (isset($aliastable)) {\n\t\tunset($aliastable);\n\t}\n\n\tunset($config);\n}\n\n/*\n * Same semantics as init_config_arr(), but with the new\n * path string interface.\n */\nfunction config_init_path(string $path) {\n\tglobal $config;\n\tarray_init_path($config, $path);\n}\n\n/* \n * Notice: Use config_init_path() instead, if you must...\n *\n * This is retained for compatibility with older code\n *\n * Initialize a config array multiple levels deep only if unset\n * Pass it an array of keys to test and create\n * init_config_arr(array('virtualip', 'vip'));\n */\nfunction init_config_arr($keys) {\n\t// just translate the old signature to the new one\n\tconfig_init_path(implode('/', $keys));\n}\n\n/**\n * Return a value specified by path in the config, if it exists.\n * @param $path string path with '/' separators\n * @param $default mixed value to return if the path is not found\n * @returns mixed value at path or $default if the path does not exist or if the\n *          path keys an empty string and $default is non-null\n */\nfunction config_get_path(string $path, $default = null) {\n\tglobal $config;\n\treturn(array_get_path($config, $path, $default));\n}\n\n/**\n * Set a value by path in the config, creating arrays for intermediary keys as\n * necessary. If the path cannot be reached because an intermediary exists but\n * is not empty or an array, return $default.\n * @param $path string path with '/' separators\n * @param $val mixed \n * @param $default mixed value to return if the path is not found\n * @returns mixed $val or $default if the path prefix does not exist\n */\nfunction config_set_path(string $path, $value, $default = null) {\n\tglobal $config;\n\treturn (array_set_path($config, $path, $value, $default));\n}\n\n/**\n * Determine whether a path in the config has a non-null value keyed by\n * $enable_key. Some parts of the config historically identify services as\n * enabled by having a key to a non-null value named 'enable', and checking it\n * with isset(). This can be counter-intuitive as isset() will return true if\n * the array element is any non-null value that evaluates to false.\n * @param $path string path with '/' separators\n * @param $enable_key string an optional alternative key value for the enable key\n * @returns bool true if $enable_key exists in the array at $path, and has a\n * non-null value, otherwise false.\n */\nfunction config_path_enabled(string $path, $enable_key = \"enable\") {\n\tglobal $config;\n\treturn (array_path_enabled($config, $path, $enable_key));\n}\n\n/**\n * Remove a key from the config by path\n * @param $path string path with '/' separators\n * @returns array copy of the removed value or null\n */\nfunction config_del_path(string $path) {\n\tglobal $config;\n\treturn (array_del_path($config, $path));\n}\nregister_shutdown_function('pfSense_clear_globals');\n\n?>\n", "<?php\n/*\n * backup.inc\n *\n * part of pfSense (https://www.pfsense.org)\n * Copyright (c) 2004-2013 BSD Perimeter\n * Copyright (c) 2013-2016 Electric Sheep Fencing\n * Copyright (c) 2014-2022 Rubicon Communications, LLC (Netgate)\n * All rights reserved.\n *\n * originally based on m0n0wall (http://m0n0.ch/wall)\n * Copyright (c) 2003-2004 Manuel Kasper <mk@neon1.net>.\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* Allow additional execution time 0 = no limit. */\nini_set('max_execution_time', '0');\nini_set('max_input_time', '0');\n\n/* omit no-cache headers because it confuses IE with file downloads */\n$omit_nocacheheaders = true;\nrequire_once(\"config.gui.inc\");\nrequire_once(\"config.lib.inc\");\nrequire_once(\"functions.inc\");\nrequire_once(\"filter.inc\");\nrequire_once(\"shaper.inc\");\nrequire_once(\"pkg-utils.inc\");\n\n$rrddbpath = \"/var/db/rrd\";\n$rrdtool = \"/usr/bin/nice -n20 /usr/local/bin/rrdtool\";\n\nfunction rrd_data_xml() {\n\tglobal $rrddbpath;\n\tglobal $rrdtool;\n\n\t$result = \"\\t<rrddata>\\n\";\n\t$rrd_files = glob(\"{$rrddbpath}/*.rrd\");\n\t$xml_files = array();\n\tforeach ($rrd_files as $rrd_file) {\n\t\t$basename = basename($rrd_file);\n\t\t$xml_file = preg_replace('/\\.rrd$/', \".xml\", $rrd_file);\n\t\texec(\"{$rrdtool} dump \" . escapeshellarg($rrd_file) . ' ' . escapeshellarg($xml_file));\n\t\t$xml_data = file_get_contents($xml_file);\n\t\tunlink($xml_file);\n\t\tif ($xml_data !== false) {\n\t\t\t$result .= \"\\t\\t<rrddatafile>\\n\";\n\t\t\t$result .= \"\\t\\t\\t<filename>{$basename}</filename>\\n\";\n\t\t\t$result .= \"\\t\\t\\t<xmldata>\" . base64_encode(gzdeflate($xml_data)) . \"</xmldata>\\n\";\n\t\t\t$result .= \"\\t\\t</rrddatafile>\\n\";\n\t\t}\n\t}\n\t$result .= \"\\t</rrddata>\\n\";\n\treturn $result;\n}\n\nfunction backup_xmldatafile($tab=false, $type='voucher') {\n\tglobal $g;\n\n\t$xmldata_files = glob(\"{$g['backuppath'][$type]}\");\n\tif (empty($xmldata_files)) {\n\t\treturn;\n\t}\n\t$t = ($tab) ? \"\\t\" : \"\";\n\t$result = \"{$t}\\t<{$type}data>\\n\";\n\tforeach ($xmldata_files as $xmldata_file) {\n\t\t$basename = basename($xmldata_file);\n\t\t$data = file_get_contents($xmldata_file);\n\t\tif ($data !== false) {\n\t\t\t$result .= \"{$t}\\t\\t<xmldatafile>\\n\";\n\t\t\t$result .= \"{$t}\\t\\t\\t<filename>{$basename}</filename>\\n\";\n\t\t\t$result .= \"{$t}\\t\\t\\t<data>\" . base64_encode(gzdeflate($data)) . \"</data>\\n\";\n\t\t\t$result .= \"{$t}\\t\\t</xmldatafile>\\n\";\n\t\t}\n\t}\n\t$result .= \"{$t}\\t</{$type}data>\\n\";\n\n\treturn $result;\n}\n\nfunction ssh_keys_xml() {\n\tglobal $ssh_keys, $sshConfigDir;\n\n\t$keyfiles = array();\n\tforeach ($ssh_keys as $key) {\n\t\t$keyfiles[] = \"ssh_host_{$key['suffix']}key\";\n\t\t$keyfiles[] = \"ssh_host_{$key['suffix']}key.pub\";\n\t}\n\n\t$result = \"\\t<sshdata>\\n\";\n\tforeach ($keyfiles as $f2c) {\n\t\t$keyfile = \"{$sshConfigDir}/{$f2c}\";\n\t\tif (file_exists($keyfile) && (filesize($keyfile) != 0)) {\n\t\t\t$result .= \"\\t\\t<sshkeyfile>\\n\";\n\t\t\t$result .= \"\\t\\t\\t<filename>{$f2c}</filename>\\n\";\n\t\t\t$result .= \"\\t\\t\\t<xmldata>\" . base64_encode(gzdeflate(file_get_contents($keyfile))) . \"</xmldata>\\n\";\n\t\t\t$result .= \"\\t\\t</sshkeyfile>\\n\";\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\t$result .= \"\\t</sshdata>\\n\";\n\treturn $result;\n}\n\nfunction check_and_returnif_section_exists($section) {\n\tglobal $config;\n\tif (is_array($config[$section])) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction execPost($post, $postfiles, $ui = true) {\n\tglobal $config, $g;\n\n\tunset($input_errors);\n\n\tif ($post['restore']) {\n\t\t$mode = \"restore\";\n\t} else if ($post['download']) {\n\t\t$mode = \"download\";\n\t}\n\tif ($post[\"nopackages\"] <> \"\") {\n\t\t$options = \"nopackages\";\n\t}\n\n\tif ($mode) {\n\t\tif ($mode == \"download\") {\n\t\t\tif ($post['encrypt']) {\n\t\t\t\tif (!$post['encrypt_password'] || ($post['encrypt_password'] != $post['encrypt_password_confirm'])) {\n\t\t\t\t\t$input_errors[] = gettext(\"Supplied password and confirmation do not match.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$input_errors) {\n\t\t\t\t$host = \"{$config['system']['hostname']}.{$config['system']['domain']}\";\n\t\t\t\t$name = \"config-{$host}-\".date(\"YmdHis\").\".xml\";\n\t\t\t\t$data = \"\";\n\n\t\t\t\tif ($options == \"nopackages\") {\n\t\t\t\t\tif (!$post['backuparea']) {\n\t\t\t\t\t\t/* backup entire configuration */\n\t\t\t\t\t\t$data = file_get_contents(\"{$g['conf_path']}/config.xml\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* backup specific area of configuration */\n\t\t\t\t\t\t$data = backup_config_section($post['backuparea']);\n\t\t\t\t\t\t$name = \"{$post['backuparea']}-{$name}\";\n\t\t\t\t\t}\n\t\t\t\t\t$data = preg_replace('/\\t*<installedpackages>.*<\\/installedpackages>\\n/sm', '', $data);\n\t\t\t\t} else {\n\t\t\t\t\tif (!$post['backuparea']) {\n\t\t\t\t\t\t/* backup entire configuration */\n\t\t\t\t\t\t$data = file_get_contents(\"{$g['conf_path']}/config.xml\");\n\t\t\t\t\t} else if ($post['backuparea'] === \"rrddata\") {\n\t\t\t\t\t\t$data = rrd_data_xml();\n\t\t\t\t\t\t$name = \"{$post['backuparea']}-{$name}\";\n\t\t\t\t\t} else if (array_key_exists($post['backuparea'], g_get('backuppath')) && $post['backupdata']) {\n\t\t\t\t\t\t$data = backup_config_section($post['backuparea']);\n\t\t\t\t\t\t$data = clear_tagdata($post['backuparea'], $data);\n\t\t\t\t\t\t$dataxml = backup_xmldatafile(false, $post['backuparea']);\n\t\t\t\t\t\t$closing_tag = \"</{$post['backuparea']}>\";\n\t\t\t\t\t\t$data = str_replace($closing_tag, $dataxml . $closing_tag, $data);\n\t\t\t\t\t\t$name = \"{$post['backuparea']}-{$name}\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* backup specific area of configuration */\n\t\t\t\t\t\t$data = backup_config_section($post['backuparea']);\n\t\t\t\t\t\t$name = \"{$post['backuparea']}-{$name}\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($post['backuparea'] != \"rrddata\") {\n\t\t\t\t\t$data = clear_tagdata('rrd', $data);\n\t\t\t\t}\n\n\t\t\t\tif (!$post['backuparea'] && $post['backupdata']) {\n\t\t\t\t\tforeach (g_get('backuppath') as $bk => $path) {\n\t\t\t\t\t\tif (!empty($config[$bk])) {\n\t\t\t\t\t\t\t$data = clear_tagdata($bk, $data);\n\t\t\t\t\t\t\t$dataxml = backup_xmldatafile(true, $bk);\n\t\t\t\t\t\t\t$closing_tag = \"\\t</{$bk}>\";\n\t\t\t\t\t\t\t$data = str_replace($closing_tag, $dataxml . $closing_tag, $data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* If the config on disk contains any rrddata/sshdata tags, remove them to\n\t\t\t\t * avoid forming invalid XML in the resulting backup.\n\t\t\t\t * See Redmine issues:\n\t\t\t\t * https://redmine.pfsense.org/issues/8994\n\t\t\t\t * https://redmine.pfsense.org/issues/10508\n\t\t\t\t * https://redmine.pfsense.org/issues/13132\n\t\t\t\t */\n\t\t\t\tforeach (array('rrd', 'ssh') as $tag) {\n\t\t\t\t\t/* Match across multiple lines for the tags and data within to remove */\n\t\t\t\t\t$data = preg_replace(\"/[[:blank:]]*<{$tag}data>.*<\\\\/{$tag}data>[[:blank:]]*\\n*/s\", \"\", $data);\n\t\t\t\t\t$data = preg_replace(\"/[[:blank:]]*<{$tag}data\\\\/>[[:blank:]]*\\n*/\", \"\", $data);\n\t\t\t\t}\n\n\t\t\t\tif (($post['backuparea'] != \"rrddata\") && !$post['donotbackuprrd']) {\n\t\t\t\t\t$rrd_data_xml = rrd_data_xml();\n\t\t\t\t\t$closing_tag = \"</\" . g_get('xml_rootobj') . \">\";\n\t\t\t\t\t$data = str_replace($closing_tag, $rrd_data_xml . $closing_tag, $data);\n\t\t\t\t}\n\n\t\t\t\tif ($post['backupssh']) {\n\t\t\t\t\t$ssh_keys_xml = ssh_keys_xml();\n\t\t\t\t\t$closing_tag = \"</\" . g_get('xml_rootobj') . \">\";\n\t\t\t\t\t$data = str_replace($closing_tag, $ssh_keys_xml . $closing_tag, $data);\n\t\t\t\t}\n\n\t\t\t\tif ($post['encrypt']) {\n\t\t\t\t\t$data = encrypt_data($data, $post['encrypt_password']);\n\t\t\t\t\ttagfile_reformat($data, $data, \"config.xml\");\n\t\t\t\t}\n\n\t\t\t\tif ($ui) {\n\t\t\t\t\tsend_user_download('data', $data, $name);\n\t\t\t\t} else {\n\t\t\t\t\treturn json_encode(array(\"contents\" => base64_encode($data), \"name\" => $name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($mode == \"restore\") {\n\t\t\tif ($post['decrypt']) {\n\t\t\t\tif (!$post['decrypt_password']) {\n\t\t\t\t\t$input_errors[] = gettext(\"A password for decryption must be supplied and confirmed.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$input_errors) {\n\t\t\t\tif (!$ui || is_uploaded_file($postfiles['conffile']['tmp_name'])) {\n\t\t\t\t\t/* check for empty file */\n\t\t\t\t\tif (!filesize($postfiles['conffile']['tmp_name'])) {\n\t\t\t\t\t\t$input_errors[] = gettext(\"The uploaded file is empty.\");\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t/* read the file contents */\n\t\t\t\t\t\t$data = $ui ? file_get_contents($postfiles['conffile']['tmp_name']) : $postfiles['conffile']['tmp_name'];\n\t\t\t\t\t\tif (!$data) {\n\t\t\t\t\t\t\t$input_errors[] = gettext(\"Warning, could not read file {$postfiles['conffile']['tmp_name']}\");\n\t\t\t\t\t\t} elseif ($post['decrypt']) {\n\t\t\t\t\t\t\tif (!tagfile_deformat($data, $data, \"config.xml\")) {\n\t\t\t\t\t\t\t\t$input_errors[] = sprintf(gettext(\n\t\t\t\t\t\t\t\t    \"The uploaded file does not appear to contain an encrypted %s configuration.\"),\n\t\t\t\t\t\t\t\t    g_get('product_label'));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$data = decrypt_data($data, $post['decrypt_password']);\n\t\t\t\t\t\t\t\tif (empty($data)) {\n\t\t\t\t\t\t\t\t\t$input_errors[] = gettext(\"File decryption failed. Incorrect password or file is invalid.\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If the config on disk contains duplicate or empty rrddata/sshdata\n\t\t\t\t\t * tags, remove them to avoid XML parsing errors.\n\t\t\t\t\t * See Redmine issues\n\t\t\t\t\t * https://redmine.pfsense.org/issues/8994\n\t\t\t\t\t * https://redmine.pfsense.org/issues/10508\n\t\t\t\t\t * https://redmine.pfsense.org/issues/13132\n\t\t\t\t\t */\n\t\t\t\t\tforeach (array('rrd', 'ssh') as $tag) {\n\t\t\t\t\t\t/* Look for empty tags (no data) */\n\t\t\t\t\t\t$data = preg_replace(\"/<{$tag}data><\\\\/{$tag}data>/\", \"\", $data);\n\t\t\t\t\t\t$data = preg_replace(\"/<{$tag}data\\\\/>/\", \"\", $data);\n\t\t\t\t\t\t/* Match across multiple lines for the tags and data within to remove,\n\t\t\t\t\t\t * but use an ungreedy match and a limit to ensure only the most\n\t\t\t\t\t\t * recent entry is retained.\n\t\t\t\t\t\t */\n\t\t\t\t\t\t$data_pattern = \"/[[:blank:]]*<{$tag}data>.*<\\\\/{$tag}data>[[:blank:]]*\\n*/sU\";\n\t\t\t\t\t\t$dmatch = [];\n\t\t\t\t\t\tpreg_match_all($data_pattern, $data, $dmatch);\n\t\t\t\t\t\t/* More than one match, so remove all but one. */\n\t\t\t\t\t\tif (count($dmatch[0]) > 1) {\n\t\t\t\t\t\t\t$data = preg_replace($data_pattern, \"\", $data, (count($dmatch[0]) - 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($post['restorearea'] && !$input_errors) {\n\t\t\t\t\t\t/* restore a specific area of the configuration */\n\t\t\t\t\t\tif (!stristr($data, \"<\" . $post['restorearea'] . \">\")) {\n\t\t\t\t\t\t\t$input_errors[] = gettext(\"An area to restore was selected but the correct xml tag could not be located.\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!restore_config_section($post['restorearea'], $data)) {\n\t\t\t\t\t\t\t\t$input_errors[] = gettext(\"An area to restore was selected but the correct xml tag could not be located.\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$conf_change = false;\n\t\t\t\t\t\t\t\tif ($config['rrddata']) {\n\t\t\t\t\t\t\t\t\trestore_rrddata();\n\t\t\t\t\t\t\t\t\tconfig_del_path('rrddata');\n\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ($config['sshdata']) {\n\t\t\t\t\t\t\t\t\trestore_sshdata();\n\t\t\t\t\t\t\t\t\tconfig_del_path('sshdata');\n\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!empty($config[$post['restorearea']][$post['restorearea'].'data'])) {\n\t\t\t\t\t\t\t\t\trestore_xmldatafile($post['restorearea']);\n\t\t\t\t\t\t\t\t\tconfig_del_path(\"{$post['restorearea']}/{$post['restorearea']}data\");\n\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ($conf_change) {\n\t\t\t\t\t\t\t\t\twrite_config(sprintf(gettext(\"Unset RRD and extra data from configuration after restoring %s configuration area\"), $post['restorearea']));\n\t\t\t\t\t\t\t\t\tunlink_if_exists(\"{$g['tmp_path']}/config.cache\");\n\t\t\t\t\t\t\t\t\tconvert_config();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfilter_configure();\n\t\t\t\t\t\t\t\t$savemsg = gettext(\"The configuration area has been restored. The firewall may need to be rebooted.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif (!$input_errors) {\n\t\t\t\t\t\tif (!stristr($data, \"<\" . g_get('xml_rootobj') . \">\")) {\n\t\t\t\t\t\t\t$input_errors[] = sprintf(gettext(\"A full configuration restore was selected but a %s tag could not be located.\"), g_get('xml_rootobj'));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* restore the entire configuration */\n\t\t\t\t\t\t\tfile_put_contents($postfiles['conffile']['tmp_name'], $data);\n\t\t\t\t\t\t\tif (config_install($postfiles['conffile']['tmp_name']) == 0) {\n\t\t\t\t\t\t\t\t/* Save current pkg repo to re-add on new config */\n\t\t\t\t\t\t\t\tunset($pkg_repo_conf_path);\n\t\t\t\t\t\t\t\tif (isset($config['system']['pkg_repo_conf_path'])) {\n\t\t\t\t\t\t\t\t\t$pkg_repo_conf_path = config_get_path('system/pkg_repo_conf_path');\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/* this will be picked up by /index.php */\n\t\t\t\t\t\t\t\tmark_subsystem_dirty(\"restore\");\n\t\t\t\t\t\t\t\ttouch(\"/conf/needs_package_sync\");\n\t\t\t\t\t\t\t\t/* remove cache, we will force a config reboot */\n\t\t\t\t\t\t\t\tif (file_exists(\"{$g['tmp_path']}/config.cache\")) {\n\t\t\t\t\t\t\t\t\tunlink(\"{$g['tmp_path']}/config.cache\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$config = parse_config(true);\n\n\t\t\t\t\t\t\t\t/* Restore previously pkg repo configured */\n\t\t\t\t\t\t\t\t$pkg_repo_restored = false;\n\t\t\t\t\t\t\t\tif (isset($pkg_repo_conf_path)) {\n\t\t\t\t\t\t\t\t\t$config['system']['pkg_repo_conf_path'] =\n\t\t\t\t\t\t\t\t\t    $pkg_repo_conf_path;\n\t\t\t\t\t\t\t\t\t$pkg_repo_restored = true;\n\t\t\t\t\t\t\t\t} elseif (isset($config['system']['pkg_repo_conf_path'])) {\n\t\t\t\t\t\t\t\t\tconfig_del_path('system/pkg_repo_conf_path');\n\t\t\t\t\t\t\t\t\t$pkg_repo_restored = true;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ($pkg_repo_restored) {\n\t\t\t\t\t\t\t\t\twrite_config(gettext(\"Removing pkg repository set after restoring full configuration\"));\n\t\t\t\t\t\t\t\t\tpkg_update(true);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (file_exists(\"/boot/loader.conf\")) {\n\t\t\t\t\t\t\t\t\t$loaderconf = file_get_contents(\"/boot/loader.conf\");\n\t\t\t\t\t\t\t\t\tif (strpos($loaderconf, \"console=\\\"comconsole\") ||\n\t\t\t\t\t\t\t\t\t    strpos($loaderconf, \"boot_serial=\\\"YES\")) {\n\t\t\t\t\t\t\t\t\t\t$config['system']['enableserial'] = true;\n\t\t\t\t\t\t\t\t\t\twrite_config(gettext(\"Restore serial console enabling in configuration.\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tunset($loaderconf);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (file_exists(\"/boot/loader.conf.local\")) {\n\t\t\t\t\t\t\t\t\t$loaderconf = file_get_contents(\"/boot/loader.conf.local\");\n\t\t\t\t\t\t\t\t\tif (strpos($loaderconf, \"console=\\\"comconsole\") ||\n\t\t\t\t\t\t\t\t\t    strpos($loaderconf, \"boot_serial=\\\"YES\")) {\n\t\t\t\t\t\t\t\t\t\t$config['system']['enableserial'] = true;\n\t\t\t\t\t\t\t\t\t\twrite_config(gettext(\"Restore serial console enabling in configuration.\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tunset($loaderconf);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/* extract out rrd items, unset from $config when done */\n\t\t\t\t\t\t\t\t$conf_change = false;\n\t\t\t\t\t\t\t\tif ($config['rrddata']) {\n\t\t\t\t\t\t\t\t\trestore_rrddata();\n\t\t\t\t\t\t\t\t\tconfig_del_path('rrddata');\n\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ($config['sshdata']) {\n\t\t\t\t\t\t\t\t\trestore_sshdata();\n\t\t\t\t\t\t\t\t\tconfig_del_path('sshdata');\n\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tforeach (g_get('backuppath') as $bk => $path) {\n\t\t\t\t\t\t\t\t\tif (!empty($config[$bk][$bk.'data'])) {\n\t\t\t\t\t\t\t\t\t\trestore_xmldatafile($bk);\n\t\t\t\t\t\t\t\t\t\tconfig_del_path(\"{$bk}/{$bk}data\");\n\t\t\t\t\t\t\t\t\t\t$conf_change = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ($conf_change) {\n\t\t\t\t\t\t\t\t\twrite_config(gettext(\"Unset RRD and extra data from configuration after full restore.\"));\n\t\t\t\t\t\t\t\t\tunlink_if_exists(\"{$g['tmp_path']}/config.cache\");\n\t\t\t\t\t\t\t\t\tconvert_config();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (is_array($config['captiveportal'])) {\n\t\t\t\t\t\t\t\t\tforeach ($config['captiveportal'] as $cp) {\n\t\t\t\t\t\t\t\t\t\tif (isset($cp['enable'])) {\n\t\t\t\t\t\t\t\t\t\t\t/* for some reason ipfw doesn't init correctly except on bootup sequence */\n\t\t\t\t\t\t\t\t\t\t\tmark_subsystem_dirty(\"restore\");\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconsole_configure();\n\t\t\t\t\t\t\t\tif (is_interface_mismatch() == true) {\n\t\t\t\t\t\t\t\t\ttouch(\"/var/run/interface_mismatch_reboot_needed\");\n\t\t\t\t\t\t\t\t\tclear_subsystem_dirty(\"restore\");\n\t\t\t\t\t\t\t\t\tconvert_config();\n\t\t\t\t\t\t\t\t\tif ($ui) {\n\t\t\t\t\t\t\t\t\t\theader(\"Location: interfaces_assign.php\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\texit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (is_interface_vlan_mismatch() == true) {\n\t\t\t\t\t\t\t\t\ttouch(\"/var/run/interface_mismatch_reboot_needed\");\n\t\t\t\t\t\t\t\t\tclear_subsystem_dirty(\"restore\");\n\t\t\t\t\t\t\t\t\tconvert_config();\n\t\t\t\t\t\t\t\t\tif ($ui) {\n\t\t\t\t\t\t\t\t\t\theader(\"Location: interfaces_assign.php\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\texit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$input_errors[] = gettext(\"The configuration could not be restored.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$input_errors[] = gettext(\"The configuration could not be restored (file upload error).\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn array(\"input_errors\" => $input_errors, \"savemsg\" => $savemsg);\n}\n\n// Compose a list of recent backups formatted as a JSON array\nfunction listBackupsJSON() {\n\tglobal $g;\n\n\tcleanup_backupcache(false);\n\n\t$raw = unserialize(file_get_contents(g_get('cf_conf_path') . \"/backup/backup.cache\"));\n\n\t$backups = array();\n\tforeach($raw as $key => $value) {\n\t    $backups[] = array(\"time\" => $key, \"desc\" => $value['description'], \"size\" => $value['filesize'], \"vers\" => $value['version']);\n\t}\n\n\treturn json_encode($backups);\n}\n\n?>\n"], "filenames": ["src/etc/inc/config.lib.inc", "src/usr/local/pfSense/include/www/backup.inc"], "buggy_code_start_loc": [283, 54], "buggy_code_end_loc": [299, 55], "fixing_code_start_loc": [283, 54], "fixing_code_end_loc": [299, 55], "type": "CWE-91", "message": "A command injection vulnerability in the function restore_rrddata() of Netgate pfSense v2.7.0 allows authenticated attackers to execute arbitrary commands via manipulating the contents of an XML file supplied to the component config.xml.", "other": {"cve": {"id": "CVE-2023-27253", "sourceIdentifier": "cve@mitre.org", "published": "2023-03-17T22:15:11.227", "lastModified": "2023-03-23T14:18:48.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A command injection vulnerability in the function restore_rrddata() of Netgate pfSense v2.7.0 allows authenticated attackers to execute arbitrary commands via manipulating the contents of an XML file supplied to the component config.xml."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-91"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netgate:pfsense:2.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "6B0402C4-6897-44F9-A290-09A7A7E61683"}]}]}], "references": [{"url": "https://github.com/pfsense/pfsense/commit/ca80d18493f8f91b21933ebd6b714215ae1e5e94", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://redmine.pfsense.org/issues/13935", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pfsense/pfsense/commit/ca80d18493f8f91b21933ebd6b714215ae1e5e94"}}