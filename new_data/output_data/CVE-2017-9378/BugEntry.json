{"buggy_code": ["<?php\n\t/*\n\t\tClass: BigTreeAdmin\n\t\t\tThe main class used by the admin for manipulating and retrieving data.\n\t*/\n\n\tclass BigTreeAdminBase {\n\n\t\tstatic $IRLPrefixes = false;\n\t\tstatic $IRLsCreated = array();\n\t\tstatic $PerPage = 15;\t\t\n\n\t\t// !View Types\n\t\tstatic $ViewTypes = array(\n\t\t\t\"searchable\" => \"Searchable List\",\n\t\t\t\"draggable\" => \"Draggable List\",\n\t\t\t\"nested\" => \"Nested Draggable List\",\n\t\t\t\"grouped\" => \"Grouped List\",\n\t\t\t\"images\" => \"Image List\",\n\t\t\t\"images-grouped\" => \"Grouped Image List\"\n\t\t);\n\n\t\t// !Reserved Column Names\n\t\tstatic $ReservedColumns = array(\n\t\t\t\"id\",\n\t\t\t\"position\",\n\t\t\t\"archived\",\n\t\t\t\"approved\"\n\t\t);\n\n\t\t// !Reserved Top Level Routes\n\t\tstatic $ReservedTLRoutes = array(\n\t\t\t\"ajax\",\n\t\t\t\"css\",\n\t\t\t\"feeds\",\n\t\t\t\"js\",\n\t\t\t\"sitemap.xml\",\n\t\t\t\"_preview\",\n\t\t\t\"_preview-pending\"\n\t\t);\n\n\t\t// !View Actions\n\t\tstatic $ViewActions = array(\n\t\t\t\"approve\" => array(\n\t\t\t\t\"key\" => \"approved\",\n\t\t\t\t\"name\" => \"Approve\",\n\t\t\t\t\"class\" => \"icon_approve icon_approve_on\"\n\t\t\t),\n\t\t\t\"archive\" => array(\n\t\t\t\t\"key\" => \"archived\",\n\t\t\t\t\"name\" => \"Archive\",\n\t\t\t\t\"class\" => \"icon_archive\"\n\t\t\t),\n\t\t\t\"feature\" => array(\n\t\t\t\t\"key\" => \"featured\",\n\t\t\t\t\"name\" => \"Feature\",\n\t\t\t\t\"class\" => \"icon_feature icon_feature_on\"\n\t\t\t),\n\t\t\t\"edit\" => array(\n\t\t\t\t\"key\" => \"id\",\n\t\t\t\t\"name\" => \"Edit\",\n\t\t\t\t\"class\" => \"icon_edit\"\n\t\t\t),\n\t\t\t\"delete\" => array(\n\t\t\t\t\"key\" => \"id\",\n\t\t\t\t\"name\" => \"Delete\",\n\t\t\t\t\"class\" => \"icon_delete\"\n\t\t\t)\n\t\t);\n\n\t\t// !Icon Classes\n\t\tstatic $IconClasses = array(\"gear\",\"truck\",\"token\",\"export\",\"redirect\",\"help\",\"error\",\"ignored\",\"world\",\"server\",\"clock\",\"network\",\"car\",\"key\",\"folder\",\"calendar\",\"search\",\"setup\",\"page\",\"computer\",\"picture\",\"news\",\"events\",\"blog\",\"form\",\"category\",\"map\",\"user\",\"question\",\"sports\",\"credit_card\",\"cart\",\"cash_register\",\"lock_key\",\"bar_graph\",\"comments\",\"email\",\"weather\",\"pin\",\"planet\",\"mug\",\"atom\",\"shovel\",\"cone\",\"lifesaver\",\"target\",\"ribbon\",\"dice\",\"ticket\",\"pallet\",\"camera\",\"video\",\"twitter\",\"facebook\");\n\t\tstatic $ActionClasses = array(\"add\",\"delete\",\"list\",\"edit\",\"refresh\",\"gear\",\"truck\",\"token\",\"export\",\"redirect\",\"help\",\"error\",\"ignored\",\"world\",\"server\",\"clock\",\"network\",\"car\",\"key\",\"folder\",\"calendar\",\"search\",\"setup\",\"page\",\"computer\",\"picture\",\"news\",\"events\",\"blog\",\"form\",\"category\",\"map\",\"user\",\"question\",\"sports\",\"credit_card\",\"cart\",\"cash_register\",\"lock_key\",\"bar_graph\",\"comments\",\"email\",\"weather\",\"pin\",\"planet\",\"mug\",\"atom\",\"shovel\",\"cone\",\"lifesaver\",\"target\",\"ribbon\",\"dice\",\"ticket\",\"pallet\",\"lightning\",\"camera\",\"video\",\"twitter\",\"facebook\");\n\n\t\t/*\n\t\t\tConstructor:\n\t\t\t\tInitializes the user's permissions.\n\t\t*/\n\n\t\tfunction __construct() {\n\t\t\t$this->checkPOSTError();\n\n\t\t\tif (isset($_SESSION[\"bigtree_admin\"][\"email\"]) && isset($_SESSION[\"bigtree_admin\"][\"csrf_token\"])) {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE id = '\".$_SESSION[\"bigtree_admin\"][\"id\"].\"' AND email = '\".sqlescape($_SESSION[\"bigtree_admin\"][\"email\"]).\"'\"));\n\t\t\t\tif ($f) {\n\t\t\t\t\t$this->ID = $f[\"id\"];\n\t\t\t\t\t$this->User = $f[\"email\"];\n\t\t\t\t\t$this->Level = $f[\"level\"];\n\t\t\t\t\t$this->Name = $f[\"name\"];\n\t\t\t\t\t$this->Permissions = json_decode($f[\"permissions\"],true);\n\t\t\t\t\t$this->CSRFToken = $_SESSION[\"bigtree_admin\"][\"csrf_token\"];\n\t\t\t\t\t$this->CSRFTokenField = $_SESSION[\"bigtree_admin\"][\"csrf_token_field\"];\n\t\t\t\t}\n\t\t\t} elseif (isset($_COOKIE[\"bigtree_admin\"][\"email\"])) {\n\t\t\t\t$user = sqlescape($_COOKIE[\"bigtree_admin\"][\"email\"]);\n\n\t\t\t\t// Get chain and session broken out\n\t\t\t\tlist($session,$chain) = json_decode($_COOKIE[\"bigtree_admin\"][\"login\"], true);\n\n\t\t\t\t// See if this is the current chain and session\n\t\t\t\t$chain_entry = sqlfetch(sqlquery(\"SELECT * FROM bigtree_user_sessions WHERE email = '$user' AND chain = '\".sqlescape($chain).\"'\"));\n\n\t\t\t\tif ($chain_entry && $chain_entry[\"csrf_token\"]) {\n\t\t\t\t\t// If both chain and session are legit, log them in\n\t\t\t\t\tif ($chain_entry[\"id\"] == $session) {\n\t\t\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE email = '$user'\"));\n\t\t\t\t\t\tif ($f) {\n\t\t\t\t\t\t\t// Generate a random CSRF token\n\t\t\t\t\t\t\t$csrf_token = base64_encode(openssl_random_pseudo_bytes(32));\n\t\t\t\t\t\t\t$csrf_token_field = \"__csrf_token_\".BigTree::randomString(32).\"__\";\n\t\t\t\t\n\t\t\t\t\t\t\t// Setup session\n\t\t\t\t\t\t\t$this->ID = $f[\"id\"];\n\t\t\t\t\t\t\t$this->User = $user;\n\t\t\t\t\t\t\t$this->Level = $f[\"level\"];\n\t\t\t\t\t\t\t$this->Name = $f[\"name\"];\n\t\t\t\t\t\t\t$this->Permissions = json_decode($f[\"permissions\"],true);\n\t\t\t\t\t\t\t$this->CSRFToken = $csrf_token;\n\t\t\t\t\t\t\t$this->CSRFTokenField = $csrf_token_field;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"id\"] = $f[\"id\"];\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"email\"] = $f[\"email\"];\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"name\"] = $f[\"name\"];\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"level\"] = $f[\"level\"];\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token\"] = $csrf_token;\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token_field\"] = $csrf_token_field;\n\n\t\t\t\t\t\t\t// Delete existing session\n\t\t\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_user_sessions WHERE id = '\".sqlescape($session).\"'\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Generate a random session id\n\t\t\t\t\t\t\t$session = uniqid(\"session-\",true);\n\t\t\t\t\t\t\twhile (sqlrows(sqlquery(\"SELECT id FROM bigtree_user_sessions WHERE id = '\".sqlescape($session).\"'\"))) {\n\t\t\t\t\t\t\t\t$session = uniqid(\"session-\",true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Create a new session with the same chain\n\t\t\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_user_sessions (`id`,`chain`,`email`,`csrf_token`,`csrf_token_field`) VALUES ('\".sqlescape($session).\"','\".sqlescape($chain).\"','$user','$csrf_token','$csrf_token_field')\");\n\t\t\t\t\t\t\tsetcookie('bigtree_admin[login]',json_encode(array($session,$chain)),strtotime(\"+1 month\"),str_replace(DOMAIN,\"\",WWW_ROOT),\"\",false,true);\n\t\t\t\t\t\t}\n\t\t\t\t\t// Chain is legit and session isn't -- someone has taken your cookies\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Delete existing cookies\n\t\t\t\t\t\tsetcookie(\"bigtree_admin[email]\",\"\",time()-3600,str_replace(DOMAIN,\"\",WWW_ROOT));\n\t\t\t\t\t\tsetcookie(\"bigtree_admin[login]\",\"\",time()-3600,str_replace(DOMAIN,\"\",WWW_ROOT));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Delete all sessions for this user\n\t\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_user_sessions WHERE email = '$user'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Clean up\n\t\t\t\tunset($user,$f,$session,$chain,$chain_entry);\n\t\t\t}\n\n\t\t\t// Check the permissions to see if we should show the pages tab.\n\t\t\tif (!$this->Level) {\n\t\t\t\t$this->HidePages = true;\n\t\t\t\tif (is_array($this->Permissions[\"page\"])) {\n\t\t\t\t\tforeach ($this->Permissions[\"page\"] as $k => $v) {\n\t\t\t\t\t\tif ($v != \"n\" && $v != \"i\") {\n\t\t\t\t\t\t\t$this->HidePages = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->HidePages = false;\n\t\t\t}\n\n\t\t\t// Update the reserved top level routes with the admin's route\n\t\t\t$ar = explode(\"/\",str_replace(WWW_ROOT,\"\",rtrim(ADMIN_ROOT,\"/\")));\n\t\t\tstatic::$ReservedTLRoutes[] = $ar[0];\n\t\t\tunset($ar);\n\n\t\t\t// Check for Per Page value\n\t\t\t$pp = static::getSetting(\"bigtree-internal-per-page\",false);\n\t\t\t$v = intval($pp[\"value\"]);\n\t\t\tif ($v) {\n\t\t\t\tstatic::$PerPage = $v;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: allocateResources\n\t\t\t\tAssigns resources from $this->IRLsCreated\n\n\t\t\tParameters:\n\t\t\t\tmodule - Module ID to assign to\n\t\t\t\tentry - Entry ID to assign to\n\t\t*/\n\n\t\tstatic function allocateResources($module,$entry) {\n\t\t\t$module = sqlescape($module);\n\t\t\t$entry = sqlescape($entry);\n\t\t\tsqlquery(\"DELETE FROM bigtree_resource_allocation WHERE module = '$module' AND entry = '$entry'\");\n\t\t\tforeach (static::$IRLsCreated as $resource) {\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_resource_allocation (`module`,`entry`,`resource`,`updated_at`) VALUES ('$module','$entry','\".sqlescape($resource).\"',NOW())\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: archivePage\n\t\t\t\tArchives a page.\n\n\t\t\tParameters:\n\t\t\t\tpage - Either a page id or page entry.\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful. false if the logged in user doesn't have permission.\n\n\t\t\tSee Also:\n\t\t\t\t<archivePageChildren>\n\t\t*/\n\n\t\tfunction archivePage($page) {\n\t\t\tif (is_array($page)) {\n\t\t\t\t$page = sqlescape($page[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$page = sqlescape($page);\n\t\t\t}\n\n\t\t\t$access = $this->getPageAccessLevel($page);\n\t\t\tif ($access == \"p\" && $this->canModifyChildren(BigTreeCMS::getPage($page))) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_pages SET archived = 'on' WHERE id = '$page'\");\n\t\t\t\t$this->archivePageChildren($page);\n\t\t\t\tstatic::growl(\"Pages\",\"Archived Page\");\n\t\t\t\t$this->track(\"bigtree_pages\",$page,\"archived\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: archivePageChildren\n\t\t\t\tArchives a page's children and sets the archive status to inherited.\n\n\t\t\tParameters:\n\t\t\t\tpage - A page id.\n\n\t\t\tSee Also:\n\t\t\t\t<archivePage>\n\t\t*/\n\n\t\tfunction archivePageChildren($page) {\n\t\t\t$page = sqlescape($page);\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE parent = '$page' AND archived != 'on'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$this->track(\"bigtree_pages\",$f[\"id\"],\"archived-inherited\");\n\t\t\t\t$this->archivePageChildren($f[\"id\"]);\n\t\t\t}\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET archived = 'on', archived_inherited = 'on' WHERE parent = '$page' AND archived != 'on'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: autoIPL\n\t\t\t\tAutomatically converts links to internal page links.\n\n\t\t\tParameters:\n\t\t\t\thtml - A string of contents that may contain URLs\n\n\t\t\tReturns:\n\t\t\t\tA string with hard links converted into internal page links.\n\t\t*/\n\n\t\tstatic function autoIPL($html) {\n\t\t\t// If this string is actually just a URL, IPL it.\n\t\t\tif ((substr($html,0,7) == \"http://\" || substr($html,0,8) == \"https://\") && strpos($html,\"\\n\") === false && strpos($html,\"\\r\") === false) {\n\t\t\t\t$html = static::makeIPL($html);\n\t\t\t// Otherwise, switch all the image srcs and javascripts srcs and whatnot to {wwwroot}.\n\t\t\t} else {\n\t\t\t\t$html = preg_replace_callback('/href=\"([^\"]*)\"/',array(\"BigTreeAdmin\",\"autoIPLCallbackHref\"),$html);\n\t\t\t\t$html = preg_replace_callback('/src=\"([^\"]*)\"/',array(\"BigTreeAdmin\",\"autoIPLCallbackSrc\"),$html);\n\t\t\t\t$html = BigTreeCMS::replaceHardRoots($html);\n\t\t\t}\n\t\t\treturn $html;\n\t\t}\n\t\t\n\t\tprivate static function autoIPLCallbackHref($matches) {\n\t\t\t$href = static::makeIPL(BigTreeCMS::replaceRelativeRoots($matches[1]));\n\t\t\treturn 'href=\"'.$href.'\"';\n\t\t}\n\t\tprivate static function autoIPLCallbackSrc($matches) {\n\t\t\t$src = static::makeIPL(BigTreeCMS::replaceRelativeRoots($matches[1]));\n\t\t\treturn 'src=\"'.$src.'\"';\n\t\t}\n\n\t\t/*\n\t\t\tFunction: backupDatabase\n\t\t\t\tBacks up the entire database to a given file.\n\n\t\t\tParameters:\n\t\t\t\tfile - Full file path to dump the database to.\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful.\n\t\t*/\n\n\t\tstatic function backupDatabase($file) {\n\t\t\tif (!BigTree::isDirectoryWritable($file)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$pointer = fopen($file,\"w\");\n\t\t\tfwrite($pointer,\"SET SESSION sql_mode = 'NO_AUTO_VALUE_ON_ZERO';\\n\");\n\t\t\tfwrite($pointer,\"SET foreign_key_checks = 0;\\n\\n\");\n\n\t\t\t// We need to dump the bigtree tables in the proper order or they will not properly be recreated with the right foreign keys\n\t\t\t$q = sqlquery(\"SHOW TABLES\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$table = current($f);\n\t\t\t\t\n\t\t\t\t// Write the drop / create statements\n\t\t\t\tfwrite($pointer,\"DROP TABLE IF EXISTS `$table`;\\n\");\n\t\t\t\t$definition = sqlfetch(sqlquery(\"SHOW CREATE TABLE `$table`\"));\n\t\t\t\tfwrite($pointer,str_replace(array(\"\\n\t\",\"\\n\"),\"\",end($definition)).\";\\n\");\n\n\t\t\t\t// Get all the table contents, write them out\n\t\t\t\t$rows = BigTree::tableContents($table);\n\t\t\t\tforeach ($rows as $row) {\n\t\t\t\t\tfwrite($pointer,$row.\";\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Separate it from the next table\n\t\t\t\tfwrite($pointer,\"\\n\");\n\t\t\t}\n\n\t\t\tfwrite($pointer,\"\\nSET foreign_key_checks = 1;\");\n\t\t\tfclose($pointer);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: canAccessGroup\n\t\t\t\tReturns whether or not the logged in user can access a module group.\n\t\t\t\tUtility for form field types / views -- we already know module group permissions are enabled so we skip some overhead\n\n\t\t\tParameters:\n\t\t\t\tmodule - A module entry.\n\t\t\t\tgroup - A group id.\n\n\t\t\tReturns:\n\t\t\t\tThe permission level if the user can access this group, otherwise false.\n\t\t*/\n\n\t\tfunction canAccessGroup($module,$group) {\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\n\t\t\t$id = $module[\"id\"];\n\t\t\t$level = false;\n\n\t\t\tif ($this->Permissions[\"module\"][$id] && $this->Permissions[\"module\"][$id] != \"n\") {\n\t\t\t\t$level = $this->Permissions[\"module\"][$id];\n\t\t\t}\n\n\t\t\tif (is_array($this->Permissions[\"module_gbp\"][$id])) {\n\t\t\t\t$gp = $this->Permissions[\"module_gbp\"][$id][$group];\n\t\t\t\tif ($gp != \"n\") {\n\t\t\t\t\tif ($gp == \"p\" || !$level) {\n\t\t\t\t\t\t$level = $gp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $level;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: canModifyChildren\n\t\t\t\tChecks whether the logged in user can modify all child pages of a page.\n\t\t\t\tAssumes we already know that we're a publisher of the parent.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page entry to check children for.\n\n\t\t\tReturns:\n\t\t\t\ttrue if the user can modify all the page children, otherwise false.\n\t\t*/\n\n\t\tfunction canModifyChildren($page) {\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_pages WHERE path LIKE '\".sqlescape($page[\"path\"]).\"%'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$perm = $this->Permissions[\"page\"][$f[\"id\"]];\n\t\t\t\tif ($perm == \"n\" || $perm == \"e\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: changePassword\n\t\t\t\tChanges a user's password via a password change hash and redirects to a success page.\n\n\t\t\tParameters:\n\t\t\t\thash - The unique hash generated by <forgotPassword>.\n\t\t\t\tpassword - The user's new password.\n\n\t\t\tSee Also:\n\t\t\t\t<forgotPassword>\n\n\t\t*/\n\n\t\tstatic function changePassword($hash,$password) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$hash = sqlescape($hash);\n\t\t\t$user = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE change_password_hash = '$hash'\"));\n\n\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], TRUE);\n\t\t\t$password = sqlescape($phpass->HashPassword(trim($password)));\n\n\t\t\tsqlquery(\"UPDATE bigtree_users SET password = '$password', change_password_hash = '' WHERE id = '\".$user[\"id\"].\"'\");\n\t\t\tsqlquery(\"UPDATE bigtree_login_bans SET expires = DATE_SUB(NOW(),INTERVAL 1 MINUTE) WHERE user = '\".$user[\"id\"].\"'\");\n\t\t\tBigTree::redirect(($bigtree[\"config\"][\"force_secure_login\"] ? str_replace(\"http://\",\"https://\",ADMIN_ROOT) : ADMIN_ROOT).\"login/reset-success/\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: checkAccess\n\t\t\t\tDetermines whether the logged in user has access to a module or not.\n\n\t\t\tParameters:\n\t\t\t\tmodule - Either a module id or module entry.\n\t\t\t\taction - Optionally, a module action array to also check levels against.\n\n\t\t\tReturns:\n\t\t\t\ttrue if the user can access the module, otherwise false.\n\t\t*/\n\n\t\tfunction checkAccess($module,$action = false) {\n\t\t\tif (is_array($module)) {\n\t\t\t\t$module = $module[\"id\"];\n\t\t\t}\n\n\t\t\tif (is_array($action) && $action[\"level\"] > $this->Level) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tif ($this->Permissions[\"module\"][$module] && $this->Permissions[\"module\"][$module] != \"n\") {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (isset($this->Permissions[\"module_gbp\"])) {\n\t\t\t\tif (is_array($this->Permissions[\"module_gbp\"][$module])) {\n\t\t\t\t\tforeach ($this->Permissions[\"module_gbp\"][$module] as $p) {\n\t\t\t\t\t\tif ($p != \"n\") {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: checkPOSTError\n\t\t\t\tChecks if an error occurred during a POST and redirects back to the originating page with a session var.\n\t\t*/\n\n\t\tfunction checkPOSTError() {\n\t\t\tglobal $bigtree;\n\n\t\t\tif (is_null($bigtree[\"php_boot_error\"])) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$error = false;\n\t\t\t$message = $bigtree[\"php_boot_error\"][\"message\"];\n\n\t\t\tif (strpos($message, \"POST Content-Length\") !== false) {\n\t\t\t\t$error = \"post_max_size\";\n\t\t\t}\n\n\t\t\tif (strpos($message, \"max_input_vars\") !== false) {\n\t\t\t\t$error = \"max_input_vars\";\n\t\t\t}\n\n\t\t\tif ($error) {\n\t\t\t\t$_SESSION[\"bigtree_admin\"][\"post_error\"] = $error;\n\n\t\t\t\tBigTree::redirect($_SERVER[\"HTTP_REFERER\"]);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: checkHTML\n\t\t\t\tChecks a block of HTML for broken links/images\n\n\t\t\tParameters:\n\t\t\t\trelative_path - The starting path of the page containing the HTML (so that relative links, i.e. \"good/\" know where to begin)\n\t\t\t\thtml - A string of HTML\n\t\t\t\texternal - Whether to check external links (slow) or not\n\n\t\t\tReturns:\n\t\t\t\tAn array containing two possible keys (a and img) which each could contain an array of errors.\n\t\t*/\n\n\t\tstatic function checkHTML($relative_path,$html,$external = false) {\n\t\t\tif (!$html) {\n\t\t\t\treturn array();\n\t\t\t}\n\t\t\t$errors = array();\n\t\t\t$doc = new DOMDocument();\n\t\t\t@$doc->loadHTML($html); // Silenced because the HTML could be invalid.\n\t\t\t// Check A tags.\n\t\t\t$links = $doc->getElementsByTagName(\"a\");\n\t\t\tforeach ($links as $link) {\n\t\t\t\t$href = $link->getAttribute(\"href\");\n\t\t\t\t$href = str_replace(array(\"{wwwroot}\",\"%7Bwwwroot%7D\",\"{staticroot}\",\"%7Bstaticroot%7D\"),array(WWW_ROOT,WWW_ROOT,STATIC_ROOT,STATIC_ROOT),$href);\n\t\t\t\tif ((substr($href,0,2) == \"//\" || substr($href,0,4) == \"http\") && strpos($href,WWW_ROOT) === false) {\n\t\t\t\t\t// External link, not much we can do but alert that it's dead\n\t\t\t\t\tif ($external) {\n\t\t\t\t\t\tif (strpos($href,\"#\") !== false) {\n\t\t\t\t\t\t\t$href = substr($href,0,strpos($href,\"#\")-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!static::urlExists($href)) {\n\t\t\t\t\t\t\t$errors[\"a\"][] = $href;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,6) == \"ipl://\") {\n\t\t\t\t\tif (!static::iplExists($href)) {\n\t\t\t\t\t\t$errors[\"a\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,6) == \"irl://\") {\n\t\t\t\t\tif (!static::irlExists($href)) {\n\t\t\t\t\t\t$errors[\"a\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,7) == \"mailto:\" || substr($href,0,1) == \"#\" || substr($href,0,5) == \"data:\" || substr($href,0,4) == \"tel:\") {\n\t\t\t\t\t// Don't do anything, it's a page mark, data URI, or email address\n\t\t\t\t} elseif (substr($href,0,4) == \"http\") {\n\t\t\t\t\t// It's a local hard link\n\t\t\t\t\tif (!static::urlExists($href)) {\n\t\t\t\t\t\t$errors[\"a\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,2) == \"//\") {\n\t\t\t\t\t// Protocol agnostic link\n\t\t\t\t\tif (!static::urlExists(\"http:\".$href)) {\n\t\t\t\t\t\t$errors[\"a\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Local file.\n\t\t\t\t\t$local = $relative_path.$href;\n\t\t\t\t\tif (!static::urlExists($local)) {\n\t\t\t\t\t\t$errors[\"a\"][] = $local;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check IMG tags.\n\t\t\t$images = $doc->getElementsByTagName(\"img\");\n\t\t\tforeach ($images as $image) {\n\t\t\t\t$href = $image->getAttribute(\"src\");\n\t\t\t\t$href = str_replace(array(\"{wwwroot}\",\"%7Bwwwroot%7D\",\"{staticroot}\",\"%7Bstaticroot%7D\"),array(WWW_ROOT,WWW_ROOT,STATIC_ROOT,STATIC_ROOT),$href);\n\t\t\t\tif (substr($href,0,4) == \"http\" && strpos($href,WWW_ROOT) === false) {\n\t\t\t\t\t// External link, not much we can do but alert that it's dead\n\t\t\t\t\tif ($external) {\n\t\t\t\t\t\tif (!static::urlExists($href)) {\n\t\t\t\t\t\t\t$errors[\"img\"][] = $href;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,6) == \"irl://\") {\n\t\t\t\t\tif (!static::irlExists($href)) {\n\t\t\t\t\t\t$errors[\"img\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,5) == \"data:\") {\n\t\t\t\t\t// Do nothing, it's a data URI\n\t\t\t\t} elseif (substr($href,0,4) == \"http\") {\n\t\t\t\t\t// It's a local hard link\n\t\t\t\t\tif (!static::urlExists($href)) {\n\t\t\t\t\t\t$errors[\"img\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,2) == \"//\") {\n\t\t\t\t\t// Protocol agnostic src\n\t\t\t\t\tif (!static::urlExists(\"http:\".$href)) {\n\t\t\t\t\t\t$errors[\"img\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Local file.\n\t\t\t\t\t$local = $relative_path.$href;\n\t\t\t\t\tif (!static::urlExists($local)) {\n\t\t\t\t\t\t$errors[\"img\"][] = $local;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $errors;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: clearCache\n\t\t\t\tRemoves all files in the cache directory.\n\t\t*/\n\n\t\tstatic function clearCache() {\n\t\t\t$d = opendir(SERVER_ROOT.\"cache/\");\n\t\t\twhile ($f = readdir($d)) {\n\t\t\t\tif ($f != \".\" && $f != \"..\" && !is_dir(SERVER_ROOT.\"cache/\".$f)) {\n\t\t\t\t\tunlink(SERVER_ROOT.\"cache/\".$f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: clearDead404s\n\t\t\t\tRemoves all 404s that don't have 301 redirects.\n\t\t*/\n\n\t\tfunction clearDead404s() {\n\t\t\tsqlquery(\"DELETE FROM bigtree_404s WHERE redirect_url = ''\");\n\t\t\t$this->track(\"bigtree_404s\",\"All\",\"Cleared Empty\");\n\t\t\tstatic::growl(\"404 Report\",\"Cleared 404s\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: create301\n\t\t\t\tCreates a 301 redirect.\n\n\t\t\tParameters:\n\t\t\t\tfrom - The 404 path\n\t\t\t\tto - The 301 target\n\t\t*/\n\n\t\tfunction create301($from,$to) {\n\t\t\t$from = sqlescape(htmlspecialchars(strip_tags(rtrim(str_replace(WWW_ROOT,\"\",$from),\"/\"))));\n\t\t\t$to = sqlescape(htmlspecialchars($this->autoIPL($to)));\n\n\t\t\t// See if the from already exists\n\t\t\t$existing = sqlfetch(sqlquery(\"SELECT * FROM bigtree_404s WHERE `broken_url` = '$from'\"));\n\t\t\tif ($existing) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_404s SET `redirect_url` = '$to' WHERE id = '\".$existing[\"id\"].\"'\");\n\t\t\t\t$this->track(\"bigtree_404s\",$existing[\"id\"],\"updated\");\n\t\t\t} else {\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_404s (`broken_url`,`redirect_url`) VALUES ('$from','$to')\");\n\t\t\t\t$this->track(\"bigtree_404s\",sqlid(),\"created\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createCallout\n\t\t\t\tCreates a callout and its files.\n\n\t\t\tParameters:\n\t\t\t\tid - The id.\n\t\t\t\tname - The name.\n\t\t\t\tdescription - The description.\n\t\t\t\tlevel - Access level (0 for everyone, 1 for administrators, 2 for developers).\n\t\t\t\tresources - An array of resources.\n\t\t\t\tdisplay_field - The field to use as the display field describing a user's callout\n\t\t\t\tdisplay_default - The text string to use in the event the display_field is blank or non-existent\n\t\t*/\n\n\t\tfunction createCallout($id,$name,$description,$level,$resources,$display_field,$display_default) {\n\t\t\t// Check to see if it's a valid ID\n\t\t\tif (!ctype_alnum(str_replace(array(\"-\",\"_\"),\"\",$id)) || strlen($id) > 127) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If we're creating a new file, let's populate it with some convenience things to show what resources are available.\n\t\t\t$file_contents = '<?\n\t/*\n\t\tResources Available:\n';\n\n\t\t\t$cached_types = $this->getCachedFieldTypes();\n\t\t\t$types = $cached_types[\"callouts\"];\n\n\t\t\t$clean_resources = array();\n\t\t\tforeach ($resources as $resource) {\n\t\t\t\t// \"type\" is still a reserved keyword due to the way we save callout data when editing.\n\t\t\t\tif ($resource[\"id\"] && $resource[\"id\"] != \"type\") {\n\t\t\t\t\t$field = array(\n\t\t\t\t\t\t\"id\" => BigTree::safeEncode($resource[\"id\"]),\n\t\t\t\t\t\t\"type\" => BigTree::safeEncode($resource[\"type\"]),\n\t\t\t\t\t\t\"title\" => BigTree::safeEncode($resource[\"title\"]),\n\t\t\t\t\t\t\"subtitle\" => BigTree::safeEncode($resource[\"subtitle\"]),\n\t\t\t\t\t\t\"options\" => BigTree::translateArray((array) @json_decode($resource[\"options\"],true))\n\t\t\t\t\t);\n\n\t\t\t\t\t// Backwards compatibility with BigTree 4.1 package imports\n\t\t\t\t\tforeach ($resource as $k => $v) {\n\t\t\t\t\t\tif (!in_array($k,array(\"id\",\"title\",\"subtitle\",\"type\",\"options\"))) {\n\t\t\t\t\t\t\t$field[\"options\"][$k] = $v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$clean_resources[] = $field;\n\n\t\t\t\t\t$file_contents .= '\t\t\"'.$resource[\"id\"].'\" = '.$resource[\"title\"].' - '.$types[$resource[\"type\"]][\"name\"].\"\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$file_contents .= '\t*/\n?>';\n\n\t\t\t// Clean up the post variables\n\t\t\t$id = sqlescape(BigTree::safeEncode($id));\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$level = sqlescape($level);\n\t\t\t$resources = BigTree::json($clean_resources,true);\n\t\t\t$display_default = sqlescape($display_default);\n\t\t\t$display_field = sqlescape($display_field);\n\n\t\t\tif (!file_exists(SERVER_ROOT.\"templates/callouts/\".$id.\".php\")) {\n\t\t\t\tBigTree::putFile(SERVER_ROOT.\"templates/callouts/\".$id.\".php\",$file_contents);\n\t\t\t}\n\n\t\t\t// Increase the count of the positions on all templates by 1 so that this new template is for sure in last position.\n\t\t\tsqlquery(\"UPDATE bigtree_callouts SET position = position + 1\");\n\t\t\tsqlquery(\"INSERT INTO bigtree_callouts (`id`,`name`,`description`,`resources`,`level`,`display_field`,`display_default`) VALUES ('$id','$name','$description','$resources','$level','$display_field','$display_default')\");\n\t\t\t$this->track(\"bigtree_callouts\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createCalloutGroup\n\t\t\t\tCreates a callout group.\n\n\t\t\tParameters:\n\t\t\t\tname - The name of the group.\n\t\t\t\tcallouts - An array of callout IDs to assign to the group.\n\n\t\t\tReturns:\n\t\t\t\tThe id of the newly created group.\n\t\t*/\n\n\t\tfunction createCalloutGroup($name,$callouts) {\n\t\t\tsort($callouts);\n\t\t\t$callouts = BigTree::json($callouts,true);\n\t\t\tsqlquery(\"INSERT INTO bigtree_callout_groups (`name`,`callouts`) VALUES ('\".sqlescape(BigTree::safeEncode($name)).\"','$callouts')\");\n\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_callout_groups\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createFeed\n\t\t\t\tCreates a feed.\n\n\t\t\tParameters:\n\t\t\t\tname - The name.\n\t\t\t\tdescription - The description.\n\t\t\t\ttable - The data table.\n\t\t\t\ttype - The feed type.\n\t\t\t\toptions - The feed type options.\n\t\t\t\tfields - The fields.\n\n\t\t\tReturns:\n\t\t\t\tThe route to the new feed.\n\t\t*/\n\n\t\tfunction createFeed($name,$description,$table,$type,$options,$fields) {\n\t\t\t// Options were encoded before submitting the form, so let's get them back.\n\t\t\t$options = json_decode($options,true);\n\t\t\tif (is_array($options)) {\n\t\t\t\tforeach ($options as &$option) {\n\t\t\t\t\t$option = BigTreeCMS::replaceHardRoots($option);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get a unique route!\n\t\t\t$route = BigTreeCMS::urlify($name);\n\t\t\t$x = 2;\n\t\t\t$oroute = $route;\n\t\t\t$f = BigTreeCMS::getFeedByRoute($route);\n\t\t\twhile ($f) {\n\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t$f = BigTreeCMS::getFeedByRoute($route);\n\t\t\t\t$x++;\n\t\t\t}\n\n\t\t\t// Fix stuff up for the db.\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\t\t\t$options = BigTree::json($options,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\t$route = sqlescape($route);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_feeds (`route`,`name`,`description`,`type`,`table`,`fields`,`options`) VALUES ('$route','$name','$description','$type','$table','$fields','$options')\");\n\t\t\t$this->track(\"bigtree_feeds\",sqlid(),\"created\");\n\n\t\t\treturn $route;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createFieldType\n\t\t\t\tCreates a field type and its files.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the field type.\n\t\t\t\tname - The name.\n\t\t\t\tuse_cases - Associate array of sections in which the field type can be used (i.e. array(\"pages\" => \"on\", \"modules\" => \"\",\"callouts\" => \"\",\"settings\" => \"\"))\n\t\t\t\tself_draw - Whether this field type will draw its <fieldset> and <label> (\"on\" or a falsey value)\n\t\t*/\n\n\t\tfunction createFieldType($id,$name,$use_cases,$self_draw) {\n\t\t\t// Check to see if it's a valid ID\n\t\t\tif (!ctype_alnum(str_replace(array(\"-\",\"_\"),\"\",$id)) || strlen($id) > 127) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$use_cases = sqlescape(json_encode($use_cases));\n\t\t\t$self_draw = $self_draw ? \"'on'\" : \"NULL\";\n\n\t\t\t$file = \"$id.php\";\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_field_types (`id`,`name`,`use_cases`,`self_draw`) VALUES ('$id','$name','$use_cases',$self_draw)\");\n\n\t\t\t// Make the files for draw and process and options if they don't exist.\n\t\t\tif (!file_exists(SERVER_ROOT.\"custom/admin/form-field-types/draw/$file\")) {\n\t\t\t\tBigTree::putFile(SERVER_ROOT.\"custom/admin/form-field-types/draw/$file\",'<?\n\t/*\n\t\tWhen drawing a field type you are provided with the $field array with the following keys:\n\t\t\t\"title\" \u2014 The title given by the developer to draw as the label (drawn automatically)\n\t\t\t\"subtitle\" \u2014 The subtitle given by the developer to draw as the smaller part of the label (drawn automatically)\n\t\t\t\"key\" \u2014 The value you should use for the \"name\" attribute of your form field\n\t\t\t\"value\" \u2014 The existing value for this form field\n\t\t\t\"id\" \u2014 A unique ID you can assign to your form field for use in JavaScript\n\t\t\t\"tabindex\" \u2014 The current tab index you can use for the \"tabindex\" attribute of your form field\n\t\t\t\"options\" \u2014 An array of options provided by the developer\n\t\t\t\"required\" \u2014 A boolean value of whether this form field is required or not\n\t*/\n\n\tinclude BigTree::path(\"admin/form-field-types/draw/text.php\");\n?>');\n\t\t\t\tBigTree::setPermissions(SERVER_ROOT.\"custom/admin/form-field-types/draw/$file\");\n\t\t\t}\n\t\t\tif (!file_exists(SERVER_ROOT.\"custom/admin/form-field-types/process/$file\")) {\n\t\t\t\tBigTree::putFile(SERVER_ROOT.\"custom/admin/form-field-types/process/$file\",'<?\n\t/*\n\t\tWhen processing a field type you are provided with the $field array with the following keys:\n\t\t\t\"key\" \u2014 The key of the field (this could be the database column for a module or the ID of the template or callout resource)\n\t\t\t\"options\" \u2014 An array of options provided by the developer\n\t\t\t\"input\" \u2014 The end user\\'s $_POST data input for this field\n\t\t\t\"file_input\" \u2014 The end user\\'s uploaded files for this field in a normalized entry from the $_FILES array in the same formatting you\\'d expect from \"input\"\n\n\t\tBigTree expects you to set $field[\"output\"] to the value you wish to store. If you want to ignore this field, set $field[\"ignore\"] to true.\n\t\tAlmost all text that is meant for drawing on the front end is expected to be run through PHP\\'s htmlspecialchars function as seen in the example below.\n\t\tIf you intend to allow HTML tags you will want to run htmlspecialchars in your drawing file on your value and leave it off in the process file.\n\t*/\n\n\t$field[\"output\"] = htmlspecialchars($field[\"input\"]);\n?>');\n\t\t\t\tBigTree::setPermissions(SERVER_ROOT.\"custom/admin/form-field-types/process/$file\");\n\t\t\t}\n\t\t\tif (!file_exists(SERVER_ROOT.\"custom/admin/ajax/developer/field-options/$file\")) {\n\t\t\t\tBigTree::touchFile(SERVER_ROOT.\"custom/admin/ajax/developer/field-options/$file\");\n\t\t\t\tBigTree::setPermissions(SERVER_ROOT.\"custom/admin/ajax/developer/field-options/$file\");\n\t\t\t}\n\n\t\t\tunlink(SERVER_ROOT.\"cache/bigtree-form-field-types.json\");\n\n\t\t\t$this->track(\"bigtree_field_types\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createMessage\n\t\t\t\tCreates a message in message center.\n\n\t\t\tParameters:\n\t\t\t\tsubject - The subject line.\n\t\t\t\tmessage - The message.\n\t\t\t\trecipients - The recipients.\n\t\t\t\tin_response_to - The message being replied to.\n\t\t*/\n\n\t\tfunction createMessage($subject,$message,$recipients,$in_response_to = 0) {\n\t\t\t// Clear tags out of the subject, sanitize the message body of XSS attacks.\n\t\t\t$subject = sqlescape(htmlspecialchars(strip_tags($subject)));\n\t\t\t$message = sqlescape(strip_tags($message,\"<p><b><strong><em><i><a>\"));\n\t\t\t$in_response_to = sqlescape($in_response_to);\n\n\t\t\t// We build the send_to field this way so that we don't have to create a second table of recipients.\n\t\t\t// Is it faster database wise using a LIKE over a JOIN? I don't know, but it makes for one less table.\n\t\t\t$send_to = \"|\";\n\t\t\tforeach ($recipients as $r) {\n\t\t\t\t// Make sure they actually put in a number and didn't try to screw with the $_POST\n\t\t\t\t$send_to .= intval($r).\"|\";\n\t\t\t}\n\n\t\t\t$send_to = sqlescape($send_to);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_messages (`sender`,`recipients`,`subject`,`message`,`date`,`response_to`) VALUES ('\".$this->ID.\"','$send_to','$subject','$message',NOW(),'$in_response_to')\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModule\n\t\t\t\tCreates a module and its class file.\n\n\t\t\tParameters:\n\t\t\t\tname - The name of the module.\n\t\t\t\tgroup - The group for the module.\n\t\t\t\tclass - The module class to create.\n\t\t\t\ttable - The table this module relates to.\n\t\t\t\tpermissions - The group-based permissions.\n\t\t\t\ticon - The icon to use.\n\t\t\t\troute - Desired route to use (defaults to auto generating if this is left false).\n\n\t\t\tReturns:\n\t\t\t\tThe new module id.\n\t\t*/\n\n\t\tfunction createModule($name,$group,$class,$table,$permissions,$icon,$route = false) {\n\t\t\t// Find an available module route.\n\t\t\t$route = $route ? $route : BigTreeCMS::urlify($name);\n\t\t\tif (!ctype_alnum(str_replace(\"-\",\"\",$route)) || strlen($route) > 127) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Go through the hard coded modules\n\t\t\t$existing = array();\n\t\t\t$d = opendir(SERVER_ROOT.\"core/admin/modules/\");\n\t\t\twhile ($f = readdir($d)) {\n\t\t\t\tif ($f != \".\" && $f != \"..\") {\n\t\t\t\t\t$existing[] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Go through the directories (really ajax, css, images, js)\n\t\t\t$d = opendir(SERVER_ROOT.\"core/admin/\");\n\t\t\twhile ($f = readdir($d)) {\n\t\t\t\tif ($f != \".\" && $f != \"..\") {\n\t\t\t\t\t$existing[] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Go through the hard coded pages\n\t\t\t$d = opendir(SERVER_ROOT.\"core/admin/pages/\");\n\t\t\twhile ($f = readdir($d)) {\n\t\t\t\tif ($f != \".\" && $f != \"..\") {\n\t\t\t\t\t// Drop the .php\n\t\t\t\t\t$existing[] = substr($f,0,-4);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Go through already created modules\n\t\t\t$q = sqlquery(\"SELECT route FROM bigtree_modules\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$existing[] = $f[\"route\"];\n\t\t\t}\n\n\t\t\t// Get a unique route\n\t\t\t$x = 2;\n\t\t\t$oroute = $route;\n\t\t\twhile (in_array($route,$existing)) {\n\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t$x++;\n\t\t\t}\n\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$route = sqlescape($route);\n\t\t\t$class = sqlescape($class);\n\t\t\t$group = $group ? \"'\".sqlescape($group).\"'\" : \"NULL\";\n\t\t\t$gbp = BigTree::json($permissions,true);\n\t\t\t$icon = sqlescape($icon);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_modules (`name`,`route`,`class`,`icon`,`group`,`gbp`) VALUES ('$name','$route','$class','$icon',$group,'$gbp')\");\n\t\t\t$id = sqlid();\n\n\t\t\tif ($class) {\n\t\t\t\t// Create class module.\n\t\t\t\t$f = fopen(SERVER_ROOT.\"custom/inc/modules/$route.php\",\"w\");\n\t\t\t\tfwrite($f,\"<?\\n\");\n\t\t\t\tfwrite($f,\"\tclass $class extends BigTreeModule {\\n\");\n\t\t\t\tfwrite($f,'\t\tvar $Table = \"'.$table.'\";'.\"\\n\");\n\t\t\t\tfwrite($f,\"\t}\\n\");\n\t\t\t\tfwrite($f,\"?>\\n\");\n\t\t\t\tfclose($f);\n\t\t\t\tBigTree::setPermissions(SERVER_ROOT.\"custom/inc/modules/$route.php\");\n\n\t\t\t\t// Remove cached class list.\n\t\t\t\tunlink(SERVER_ROOT.\"cache/bigtree-module-class-list.json\");\n\t\t\t}\n\n\t\t\t$this->track(\"bigtree_modules\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleAction\n\t\t\t\tCreates a module action.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module to create an action for.\n\t\t\t\tname - The name of the action.\n\t\t\t\troute - The action route.\n\t\t\t\tin_nav - Whether the action is in the navigation.\n\t\t\t\ticon - The icon class for the action.\n\t\t\t\tform - The associated form.\n\t\t\t\tview - The associated view.\n\t\t\t\treport - The associated report.\n\t\t\t\tlevel - The required access level.\n\t\t\t\tposition - The position in navigation.\n\n\t\t\tReturns:\n\t\t\t\tThe action's route.\n\t\t*/\n\n\t\tfunction createModuleAction($module,$name,$route,$in_nav,$icon,$form = 0,$view = 0,$report = 0,$level = 0,$position = 0) {\n\t\t\t$module = sqlescape($module);\n\t\t\t$route = sqlescape(BigTree::safeEncode($route));\n\t\t\t$in_nav = sqlescape($in_nav);\n\t\t\t$icon = sqlescape($icon);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$form = $form ? \"'\".sqlescape($form).\"'\" : \"NULL\";\n\t\t\t$view = $view ? \"'\".sqlescape($view).\"'\" : \"NULL\";\n\t\t\t$report = $report ? \"'\".sqlescape($report).\"'\" : \"NULL\";\n\t\t\t$level = sqlescape($level);\n\t\t\t$position = sqlescape($position);\n\t\t\t$route = $this->uniqueModuleActionRoute($module,$route);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_actions (`module`,`name`,`route`,`in_nav`,`class`,`level`,`form`,`view`,`report`,`position`) VALUES ('$module','$name','$route','$in_nav','$icon','$level',$form,$view,$report,'$position')\");\n\t\t\t\n\t\t\t$this->track(\"bigtree_module_actions\",sqlid(),\"created\");\n\n\t\t\treturn $route;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleEmbedForm\n\t\t\t\tCreates an embeddable form.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module ID that this form relates to.\n\t\t\t\ttitle - The title of the form.\n\t\t\t\ttable - The table for the form data.\n\t\t\t\tfields - The form fields.\n\t\t\t\thooks - An array of \"pre\", \"post\", and \"publish\" keys that can be function names to call\n\t\t\t\tdefault_position - Default position for entries to the form (if the view is positioned).\n\t\t\t\tdefault_pending - Whether the submissions to default to pending or not (\"on\" or \"\").\n\t\t\t\tcss - URL of a CSS file to include.\n\t\t\t\tredirect_url - The URL to redirect to upon completion of submission.\n\t\t\t\tthank_you_message - The message to display upon completeion of submission.\n\n\t\t\tReturns:\n\t\t\t\tThe embed code.\n\t\t*/\n\n\t\tfunction createModuleEmbedForm($module,$title,$table,$fields,$hooks = array(),$default_position = \"\",$default_pending = \"\",$css = \"\",$redirect_url = \"\",$thank_you_message = \"\") {\n\t\t\t$module = sqlescape($module);\n\t\t\t$sql_title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$hooks = BigTree::json(json_decode($hooks),true);\n\t\t\t$default_position = sqlescape($default_position);\n\t\t\t$default_pending = $default_pending ? \"on\" : \"\";\n\t\t\t$css = sqlescape(BigTree::safeEncode($this->makeIPL($css)));\n\t\t\t$redirect_url = sqlescape(BigTree::safeEncode($redirect_url));\n\t\t\t$thank_you_message = sqlescape($thank_you_message);\n\t\t\t$hash = uniqid();\n\n\t\t\t$clean_fields = array();\n\t\t\tforeach ($fields as $key => $field) {\n\t\t\t\t$field[\"options\"] = BigTree::translateArray(json_decode($field[\"options\"],true));\n\t\t\t\t$field[\"column\"] = $key;\n\t\t\t\t$clean_fields[] = $field;\n\t\t\t}\n\t\t\t$fields = BigTree::json($clean_fields,true);\n\n\t\t\t// Make sure this isn't used already\n\t\t\twhile (sqlrows(sqlquery(\"SELECT * FROM bigtree_module_embeds WHERE hash = '$hash'\"))) {\n\t\t\t\t$hash = uniqid();\n\t\t\t}\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_embeds (`module`,`title`,`table`,`fields`,`default_position`,`default_pending`,`css`,`redirect_url`,`thank_you_message`,`hash`,`hooks`) VALUES ('$module','$sql_title','$table','$fields','$default_position','$default_pending','$css','$redirect_url','$thank_you_message','$hash','$hooks')\");\n\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_module_embeds\",$id,\"created\");\n\n\t\t\treturn htmlspecialchars('<div id=\"bigtree_embeddable_form_container_'.$id.'\">'.$title.'</div>'.\"\\n\".'<script type=\"text/javascript\" src=\"'.ADMIN_ROOT.'js/embeddable-form.js?id='.$id.'&hash='.$hash.'\"></script>');\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleForm\n\t\t\t\tCreates a module form.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module ID that this form relates to.\n\t\t\t\ttitle - The title of the form.\n\t\t\t\ttable - The table for the form data.\n\t\t\t\tfields - The form fields.\n\t\t\t\thooks - An array of \"pre\", \"post\", and \"publish\" keys that can be function names to call\n\t\t\t\tdefault_position - Default position for entries to the form (if the view is positioned).\n\t\t\t\treturn_view - The view to return to after completing the form.\n\t\t\t\treturn_url - The alternative URL to return to after completing the form.\n\t\t\t\ttagging - Whether or not to enable tagging.\n\n\t\t\tReturns:\n\t\t\t\tThe new form id.\n\t\t*/\n\n\t\tfunction createModuleForm($module,$title,$table,$fields,$hooks = array(),$default_position = \"\",$return_view = false,$return_url = \"\",$tagging = \"\") {\n\t\t\t$module = sqlescape($module);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$hooks = BigTree::json(is_array($hooks) ? $hooks : json_decode($hooks),true);\n\t\t\t$default_position = sqlescape($default_position);\n\t\t\t$return_view = $return_view ? \"'\".sqlescape($return_view).\"'\" : \"NULL\";\n\t\t\t$return_url = sqlescape($this->makeIPL($return_url));\n\t\t\t$tagging = $tagging ? \"on\" : \"\";\n\n\t\t\t$clean_fields = array();\n\t\t\tforeach ($fields as $key => $data) {\n\t\t\t\t$field = array(\n\t\t\t\t\t\"column\" => $data[\"column\"] ? $data[\"column\"] : $key,\n\t\t\t\t\t\"type\" => BigTree::safeEncode($data[\"type\"]),\n\t\t\t\t\t\"title\" => BigTree::safeEncode($data[\"title\"]),\n\t\t\t\t\t\"subtitle\" => BigTree::safeEncode($data[\"subtitle\"]),\n\t\t\t\t\t\"options\" => BigTree::translateArray(is_array($data[\"options\"]) ? $data[\"options\"] : (array)@json_decode($data[\"options\"],true))\n\t\t\t\t);\n\t\t\t\t// Backwards compatibility with BigTree 4.1 package imports\n\t\t\t\tforeach ($data as $k => $v) {\n\t\t\t\t\tif (!in_array($k,array(\"title\",\"subtitle\",\"type\",\"options\"))) {\n\t\t\t\t\t\t$field[\"options\"][$k] = $v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$clean_fields[] = $field;\n\t\t\t}\n\t\t\t$fields = BigTree::json($clean_fields,true);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_forms (`module`,`title`,`table`,`fields`,`default_position`,`return_view`,`return_url`,`tagging`,`hooks`) VALUES ('$module','$title','$table','$fields','$default_position',$return_view,'$return_url','$tagging','$hooks')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_module_forms\",$id,\"created\");\n\n\t\t\t// Get related views for this table and update numeric status\n\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_module_views WHERE `table` = '$table'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tstatic::updateModuleViewColumnNumericStatus(BigTreeAutoModule::getView($f[\"id\"]));\n\t\t\t}\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleGroup\n\t\t\t\tCreates a module group.\n\n\t\t\tParameters:\n\t\t\t\tname - The name of the group.\n\n\t\t\tReturns:\n\t\t\t\tThe id of the newly created group.\n\t\t*/\n\n\t\tfunction createModuleGroup($name) {\n\t\t\t// Get a unique route\n\t\t\t$x = 2;\n\t\t\t$route = BigTreeCMS::urlify($name);\n\t\t\t$oroute = $route;\n\t\t\twhile ($this->getModuleGroupByRoute($route)) {\n\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t$x++;\n\t\t\t}\n\n\t\t\t$route = sqlescape($route);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_groups (`name`,`route`) VALUES ('$name','$route')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_module_groups\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleReport\n\t\t\t\tCreates a module report and the associated module action.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module ID that this report relates to.\n\t\t\t\ttitle - The title of the report.\n\t\t\t\ttable - The table for the report data.\n\t\t\t\ttype - The type of report (csv or view).\n\t\t\t\tfilters - The filters a user can use to create the report.\n\t\t\t\tfields - The fields to show in the CSV export (if type = csv).\n\t\t\t\tparser - An optional parser function to run on the CSV export data (if type = csv).\n\t\t\t\tview - A module view ID to use (if type = view).\n\n\t\t\tReturns:\n\t\t\t\tThe id of the report.\n\t\t*/\n\n\t\tfunction createModuleReport($module,$title,$table,$type,$filters,$fields = \"\",$parser = \"\",$view = \"\") {\n\t\t\t$module = sqlescape($module);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\t\t\t$filters = BigTree::json($filters,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\t$parser = sqlescape($parser);\n\t\t\t$view = $view ? \"'\".sqlescape($view).\"'\" : \"NULL\";\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_reports (`module`,`title`,`table`,`type`,`filters`,`fields`,`parser`,`view`) VALUES ('$module','$title','$table','$type','$filters','$fields','$parser',$view)\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_module_reports\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleView\n\t\t\t\tCreates a module view.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module ID that this view relates to.\n\t\t\t\ttitle - View title.\n\t\t\t\tdescription - Description.\n\t\t\t\ttable - Data table.\n\t\t\t\ttype - View type.\n\t\t\t\toptions - View options array.\n\t\t\t\tfields - Field array.\n\t\t\t\tactions - Actions array.\n\t\t\t\trelated_form - Form ID to handle edits.\n\t\t\t\tpreview_url - Optional preview URL.\n\n\t\t\tReturns:\n\t\t\t\tThe id for view.\n\t\t*/\n\n\t\tfunction createModuleView($module,$title,$description,$table,$type,$options,$fields,$actions,$related_form,$preview_url = \"\") {\n\t\t\t$module = sqlescape($module);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\n\t\t\t$options = BigTree::json($options,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\t$actions = BigTree::json($actions,true);\n\t\t\t$related_form = $related_form ? intval($related_form) : \"NULL\";\n\t\t\t$preview_url = sqlescape(BigTree::safeEncode($this->makeIPL($preview_url)));\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_views (`module`,`title`,`description`,`type`,`fields`,`actions`,`table`,`options`,`preview_url`,`related_form`) VALUES ('$module','$title','$description','$type','$fields','$actions','$table','$options','$preview_url',$related_form)\");\n\n\t\t\t$id = sqlid();\n\t\t\tstatic::updateModuleViewColumnNumericStatus(BigTreeAutoModule::getView($id));\n\t\t\t$this->track(\"bigtree_module_views\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createPage\n\t\t\t\tCreates a page.\n\t\t\t\tDoes not check permissions.\n\n\t\t\tParameters:\n\t\t\t\tdata - An array of page information.\n\n\t\t\tReturns:\n\t\t\t\tThe id of the newly created page.\n\t\t*/\n\n\t\tfunction createPage($data) {\n\t\t\t// Defaults\n\t\t\t$parent = 0;\n\t\t\t$title = $nav_title = $meta_description = $meta_keywords = $external = $template = $in_nav = \"\";\n\t\t\t$seo_invisible = $publish_at = $expire_at = $trunk = $new_window = $max_age = false;\n\t\t\t$resources = array();\n\n\t\t\t// Loop through the posted data, make sure no session hijacking is done.\n\t\t\tforeach ($data as $key => $val) {\n\t\t\t\tif (substr($key,0,1) != \"_\") {\n\t\t\t\t\tif (is_array($val)) {\n\t\t\t\t\t\t$$key = BigTree::json($val,true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$key = sqlescape($val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there's an external link, make sure it's a relative URL\n\t\t\tif ($external) {\n\t\t\t\t$external = $this->makeIPL($external);\n\t\t\t}\n\n\n\t\t\t// Who knows what they may have put in for a route, so we're not going to use the sqlescape version.\n\t\t\t$route = $data[\"route\"];\n\t\t\tif (!$route) {\n\t\t\t\t// If they didn't specify a route use the navigation title\n\t\t\t\t$route = BigTreeCMS::urlify($data[\"nav_title\"]);\n\t\t\t} else {\n\t\t\t\t// Otherwise sanitize the one they did provide.\n\t\t\t\t$route = BigTreeCMS::urlify($route);\n\t\t\t}\n\n\t\t\t// We need to figure out a unique route for the page. Make sure it doesn't match a directory in /site/\n\t\t\t$original_route = $route;\n\t\t\t$x = 2;\n\t\t\t// Reserved paths.\n\t\t\tif ($parent == 0) {\n\t\t\t\twhile (file_exists(SERVER_ROOT.\"site/\".$route.\"/\")) {\n\t\t\t\t\t$route = $original_route.\"-\".$x;\n\t\t\t\t\t$x++;\n\t\t\t\t}\n\t\t\t\twhile (in_array($route,static::$ReservedTLRoutes)) {\n\t\t\t\t\t$route = $original_route.\"-\".$x;\n\t\t\t\t\t$x++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make sure it doesn't have the same route as any of its siblings.\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pages WHERE `route` = '$route' AND parent = '$parent'\"));\n\t\t\twhile ($f) {\n\t\t\t\t$route = $original_route.\"-\".$x;\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pages WHERE `route` = '$route' AND parent = '$parent'\"));\n\t\t\t\t$x++;\n\t\t\t}\n\n\t\t\t// Make sure route isn't longer than 255\n\t\t\t$route = substr($route,0,255);\n\n\t\t\t// If we have a parent, get the full navigation path, otherwise, just use this route as the path since it's top level.\n\t\t\tif ($parent) {\n\t\t\t\t$path = $this->getFullNavigationPath($parent).\"/\".$route;\n\t\t\t} else {\n\t\t\t\t$path = $route;\n\t\t\t}\n\n\t\t\t// If we set a publish at date, make it the proper MySQL format.\n\t\t\tif ($publish_at && $publish_at != \"NULL\") {\n\t\t\t\t$publish_at = \"'\".date(\"Y-m-d\",strtotime($publish_at)).\"'\";\n\t\t\t} else {\n\t\t\t\t$publish_at = \"NULL\";\n\t\t\t}\n\n\t\t\t// If we set an expiration date, make it the proper MySQL format.\n\t\t\tif ($expire_at && $expire_at != \"NULL\") {\n\t\t\t\t$expire_at = \"'\".date(\"Y-m-d\",strtotime($expire_at)).\"'\";\n\t\t\t} else {\n\t\t\t\t$expire_at = \"NULL\";\n\t\t\t}\n\n\t\t\t// Make the title, navigation title, description, keywords, and external link htmlspecialchar'd -- these are all things we'll be echoing in the HTML so we might as well make them valid now instead of at display time.\n\n\t\t\t$title = htmlspecialchars($title);\n\t\t\t$nav_title = htmlspecialchars($nav_title);\n\t\t\t$meta_description = htmlspecialchars($meta_description);\n\t\t\t$meta_keywords = htmlspecialchars($meta_keywords);\n\t\t\t$seo_invisible = $seo_invisible ? \"on\" : \"\";\n\t\t\t$external = htmlspecialchars($external);\n\n\t\t\t// Set the trunk flag back to no if the user isn't a developer\n\t\t\tif ($this->Level < 2) {\n\t\t\t\t$trunk = \"\";\n\t\t\t} else {\n\t\t\t\t$trunk = sqlescape($trunk);\n\t\t\t}\n\n\t\t\t// Make the page!\n\t\t\tsqlquery(\"INSERT INTO bigtree_pages (`trunk`,`parent`,`nav_title`,`route`,`path`,`in_nav`,`title`,`template`,`external`,`new_window`,`resources`,`meta_keywords`,`meta_description`,`seo_invisible`,`last_edited_by`,`created_at`,`updated_at`,`publish_at`,`expire_at`,`max_age`) VALUES ('$trunk','$parent','$nav_title','$route','$path','$in_nav','$title','$template','$external','$new_window','$resources','$meta_keywords','$meta_description','$seo_invisible','\".$this->ID.\"',NOW(),NOW(),$publish_at,$expire_at,'$max_age')\");\n\n\t\t\t$id = sqlid();\n\n\t\t\t// Handle tags\n\t\t\tif (is_array($data[\"_tags\"])) {\n\t\t\t\tforeach ($data[\"_tags\"] as $tag) {\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_tags_rel (`table`,`entry`,`tag`) VALUES ('bigtree_pages','$id','$tag')\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there was an old page that had previously used this path, dump its history so we can take over the path.\n\t\t\tsqlquery(\"DELETE FROM bigtree_route_history WHERE old_route = '$path'\");\n\n\t\t\t// Dump the cache, we don't really know how many pages may be showing this now in their nav.\n\t\t\t$this->clearCache();\n\t\t\t// Let search engines know this page now exists.\n\t\t\t$this->pingSearchEngines();\n\t\t\t// Audit trail.\n\t\t\t$this->track(\"bigtree_pages\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createPendingChange\n\t\t\t\tCreates a pending change.\n\n\t\t\tParameters:\n\t\t\t\ttable - The table the change applies to.\n\t\t\t\titem_id - The entry the change applies to's id.\n\t\t\t\tchanges - The changes to the fields in the entry.\n\t\t\t\tmtm_changes - Many to Many changes.\n\t\t\t\ttags_changes - Tags changes.\n\t\t\t\tmodule - The module id for the change.\n\n\t\t\tReturns:\n\t\t\t\tThe change id.\n\t\t*/\n\n\t\tfunction createPendingChange($table,$item_id,$changes,$mtm_changes = array(),$tags_changes = array(),$module = 0) {\n\t\t\t$table = sqlescape($table);\n\t\t\t$item_id = ($item_id !== false) ? \"'\".sqlescape($item_id).\"'\" : \"NULL\";\n\t\t\t$changes = BigTree::json($changes,true);\n\t\t\t$mtm_changes = BigTree::json($mtm_changes,true);\n\t\t\t$tags_changes = BigTree::json($tags_changes,true);\n\t\t\t$module = sqlescape($module);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_pending_changes (`user`,`date`,`table`,`item_id`,`changes`,`mtm_changes`,`tags_changes`,`module`) VALUES ('\".$this->ID.\"',NOW(),'$table',$item_id,'$changes','$mtm_changes','$tags_changes','$module')\");\n\t\t\treturn sqlid();\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createPendingPage\n\t\t\t\tCreates a pending page entry in bigtree_pending_changes\n\n\t\t\tParameters:\n\t\t\t\tdata - An array of page information.\n\n\t\t\tReturns:\n\t\t\t\tThe id of the pending change.\n\t\t*/\n\n\t\tfunction createPendingPage($data) {\n\t\t\t// Make a relative URL for external links.\n\t\t\tif ($data[\"external\"]) {\n\t\t\t\t$data[\"external\"] = $this->makeIPL($data[\"external\"]);\n\t\t\t}\n\n\t\t\t// Save the tags, then dump them from the saved changes array.\n\t\t\t$tags = BigTree::json($data[\"_tags\"],true);\n\t\t\tunset($data[\"_tags\"]);\n\n\t\t\t// Make the nav title, title, external link, keywords, and description htmlspecialchar'd for displaying on the front end / the form again.\n\t\t\t$data[\"nav_title\"] = htmlspecialchars($data[\"nav_title\"]);\n\t\t\t$data[\"title\"] = htmlspecialchars($data[\"title\"]);\n\t\t\t$data[\"external\"] = htmlspecialchars($data[\"external\"]);\n\t\t\t$data[\"meta_keywords\"] = htmlspecialchars($data[\"meta_keywords\"]);\n\t\t\t$data[\"meta_description\"] = htmlspecialchars($data[\"meta_description\"]);\n\n\t\t\t// Set the trunk flag back to no if the user isn't a developer\n\t\t\tif ($this->Level < 2) {\n\t\t\t\t$data[\"trunk\"] = \"\";\n\t\t\t} else {\n\t\t\t\t$data[\"trunk\"] = sqlescape($data[\"trunk\"]);\n\t\t\t}\n\n\t\t\t$parent = sqlescape($data[\"parent\"]);\n\n\t\t\t// JSON encode the changes and stick them in the database.\n\t\t\tunset($data[\"MAX_FILE_SIZE\"]);\n\t\t\tunset($data[\"ptype\"]);\n\t\t\t$data = BigTree::json($data,true);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_pending_changes (`user`,`date`,`title`,`table`,`changes`,`tags_changes`,`type`,`module`,`pending_page_parent`) VALUES ('\".$this->ID.\"',NOW(),'New Page Created','bigtree_pages','$data','$tags','NEW','','$parent')\");\n\t\t\t$id = sqlid();\n\n\t\t\t// Audit trail\n\t\t\t$this->track(\"bigtree_pages\",\"p$id\",\"created-pending\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createResource\n\t\t\t\tCreates a resource.\n\n\t\t\tParameters:\n\t\t\t\tfolder - The folder to place it in.\n\t\t\t\tfile - The file path.\n\t\t\t\tmd5 - The MD5 hash of the file.\n\t\t\t\tname - The file name.\n\t\t\t\ttype - The file type.\n\t\t\t\tis_image - Whether the resource is an image.\n\t\t\t\theight - The image height (if it's an image).\n\t\t\t\twidth - The image width (if it's an image).\n\t\t\t\tthumbs - An array of thumbnails (if it's an image).\n\n\t\t\tReturns:\n\t\t\t\tThe new resource id.\n\t\t*/\n\n\t\tfunction createResource($folder,$file,$md5,$name,$type,$is_image = \"\",$height = 0,$width = 0,$thumbs = array()) {\n\t\t\t$folder = $folder ? \"'\".sqlescape($folder).\"'\" : \"NULL\";\n\t\t\t$file = sqlescape(BigTreeCMS::replaceHardRoots($file));\n\t\t\t$name = sqlescape(htmlspecialchars($name));\n\t\t\t$type = sqlescape($type);\n\t\t\t$is_image = sqlescape($is_image);\n\t\t\t$height = intval($height);\n\t\t\t$width = intval($width);\n\t\t\t$thumbs = BigTree::json($thumbs,true);\n\t\t\t$md5 = sqlescape($md5);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_resources (`file`,`md5`,`date`,`name`,`type`,`folder`,`is_image`,`height`,`width`,`thumbs`) VALUES ('$file','$md5',NOW(),'$name','$type',$folder,'$is_image','$height','$width','$thumbs')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_resources\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createResourceFolder\n\t\t\t\tCreates a resource folder.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tparent - The parent folder.\n\t\t\t\tname - The name of the new folder.\n\n\t\t\tReturns:\n\t\t\t\tThe new folder id.\n\t\t*/\n\n\t\tfunction createResourceFolder($parent,$name) {\n\t\t\t$perm = $this->getResourceFolderPermission($parent);\n\t\t\tif ($perm != \"p\") {\n\t\t\t\tdie(\"You don't have permission to make a folder here.\");\n\t\t\t}\n\n\t\t\t$parent = sqlescape($parent);\n\t\t\t$name = sqlescape(htmlspecialchars(trim($name)));\n\n\t\t\tif (!$name) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_resource_folders (`name`,`parent`) VALUES ('$name','$parent')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_resource_folders\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createSetting\n\t\t\t\tCreates a setting.\n\n\t\t\tParameters:\n\t\t\t\tdata - An array of settings information. Available fields: \"id\", \"name\", \"description\", \"type\", \"locked\", \"module\", \"encrypted\", \"system\"\n\n\t\t\tReturns:\n\t\t\t\tTrue if successful, false if a setting already exists with the ID given.\n\t\t*/\n\n\t\tfunction createSetting($data) {\n\t\t\t// Setup defaults\n\t\t\t$id = $name = $extension = $description = $type = $options = $locked = $encrypted = $system = \"\";\n\t\t\tforeach ($data as $key => $val) {\n\t\t\t\tif (substr($key,0,1) != \"_\" && !is_array($val)) {\n\t\t\t\t\t$$key = sqlescape(htmlspecialchars($val));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$extension = $extension ? \"'$extension'\" : \"NULL\";\n\n\t\t\t// If an extension is creating a setting, make it a reference back to the extension\n\t\t\tif (defined(\"EXTENSION_ROOT\")) {\n\t\t\t\t$extension = sqlescape(rtrim(str_replace(SERVER_ROOT.\"extensions/\",\"\",EXTENSION_ROOT),\"/\"));\n\t\t\t\t// Don't append extension again if it's already being called via the namespace\n\t\t\t\tif (strpos($id,\"$extension*\") === false) {\n\t\t\t\t\t$id = \"$extension*$id\";\n\t\t\t\t}\n\t\t\t\t$extension = \"'$extension'\";\n\t\t\t}\n\n\t\t\t// We don't want this encoded since it's a WYSIWYG field.\n\t\t\t$description = isset($data[\"description\"]) ? sqlescape($data[\"description\"]) : \"\";\n\t\t\t\n\t\t\t// We don't want this encoded since it's JSON\n\t\t\tif (isset($data[\"options\"])) {\n\t\t\t\tif (is_string($data[\"options\"])) {\n\t\t\t\t\t$data[\"options\"] = json_decode($data[\"options\"], true);\n\t\t\t\t}\n\n\t\t\t\tforeach ($data[\"options\"] as $key => $value) {\n\t\t\t\t\tif ($key == \"options\" && is_string($value)) {\n\t\t\t\t\t\t$data[\"options\"][$key] = json_decode($value, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t$options = BigTree::json(BigTree::translateArray($data[\"options\"]), true);\n\t\t\t}\n\n\t\t\t// See if there's already a setting with this ID\n\t\t\t$r = sqlrows(sqlquery(\"SELECT id FROM bigtree_settings WHERE id = '$id'\"));\n\t\t\tif ($r) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_settings (`id`,`name`,`description`,`type`,`options`,`locked`,`encrypted`,`system`,`extension`) VALUES ('$id','$name','$description','$type','$options','$locked','$encrypted','$system',$extension)\");\n\t\t\t$this->track(\"bigtree_settings\",$id,\"created\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createTag\n\t\t\t\tCreates a new tag, or returns the id of an existing one.\n\n\t\t\tParameters:\n\t\t\t\ttag - The tag.\n\n\t\t\tReturns:\n\t\t\t\tIf the tag exists, returns the existing tag's id.\n\t\t\t\tOtherwise, returns the new tag id.\n\t\t*/\n\n\t\tfunction createTag($tag) {\n\t\t\t$tag = strtolower(html_entity_decode(trim($tag)));\n\t\t\t// Check if the tag exists already.\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE tag = '\".sqlescape($tag).\"'\"));\n\n\t\t\tif (!$f) {\n\t\t\t\t$meta = metaphone($tag);\n\t\t\t\t$route = BigTreeCMS::urlify($tag);\n\t\t\t\t$oroute = $route;\n\t\t\t\t$x = 2;\n\t\t\t\twhile ($f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE route = '$route'\"))) {\n\t\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t\t$x++;\n\t\t\t\t}\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_tags (`tag`,`metaphone`,`route`) VALUES ('\".sqlescape($tag).\"','$meta','$route')\");\n\t\t\t\t$id = sqlid();\n\t\t\t} else {\n\t\t\t\t$id = $f[\"id\"];\n\t\t\t}\n\n\t\t\t$this->track(\"bigtree_tags\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createTemplate\n\t\t\t\tCreates a template and its default files/directories.\n\n\t\t\tParameters:\n\t\t\t\tid - Id for the template.\n\t\t\t\tname - Name\n\t\t\t\trouted - Basic (\"\") or Routed (\"on\")\n\t\t\t\tlevel - Access level (0 for everyone, 1 for administrators, 2 for developers)\n\t\t\t\tmodule - Related module id\n\t\t\t\tresources - An array of resources\n\t\t*/\n\n\t\tfunction createTemplate($id,$name,$routed,$level,$module,$resources) {\n\t\t\t// Check to see if it's a valid ID\n\t\t\tif (!ctype_alnum(str_replace(array(\"-\",\"_\"),\"\",$id)) || strlen($id) > 127) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If we're creating a new file, let's populate it with some convenience things to show what resources are available.\n\t\t\t$file_contents = \"<?\\n\t/*\\n\t\tResources Available:\\n\";\n\n\t\t\t$types = $this->getCachedFieldTypes();\n\t\t\t$types = $types[\"templates\"];\n\n\t\t\t$clean_resources = array();\n\t\t\tforeach ($resources as $resource) {\n\t\t\t\tif ($resource[\"id\"]) {\n\t\t\t\t\t$field = array(\n\t\t\t\t\t\t\"id\" => BigTree::safeEncode($resource[\"id\"]),\n\t\t\t\t\t\t\"type\" => BigTree::safeEncode($resource[\"type\"]),\n\t\t\t\t\t\t\"title\" => BigTree::safeEncode($resource[\"title\"]),\n\t\t\t\t\t\t\"subtitle\" => BigTree::safeEncode($resource[\"subtitle\"]),\n\t\t\t\t\t\t\"options\" => BigTree::translateArray((array)@json_decode($resource[\"options\"],true))\n\t\t\t\t\t);\n\n\t\t\t\t\t// Backwards compatibility with BigTree 4.1 package imports\n\t\t\t\t\tforeach ($resource as $k => $v) {\n\t\t\t\t\t\tif (!in_array($k,array(\"id\",\"title\",\"subtitle\",\"type\",\"options\"))) {\n\t\t\t\t\t\t\t$field[\"options\"][$k] = $v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$clean_resources[] = $field;\n\n\t\t\t\t\t$file_contents .= '\t\t$'.$resource[\"id\"].' = '.$resource[\"title\"].' - '.$types[$resource[\"type\"]][\"name\"].\"\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$file_contents .= '\t*/\n?>';\n\t\t\tif (!count($clean_resources)) {\n\t\t\t\t$file_contents = \"\";\n\t\t\t}\n\n\t\t\tif ($routed == \"on\") {\n\t\t\t\tif (!file_exists(SERVER_ROOT.\"templates/routed/\".$id.\"/default.php\")) {\n\t\t\t\t\tBigTree::putFile(SERVER_ROOT.\"templates/routed/\".$id.\"/default.php\",$file_contents);\n\t\t\t\t}\n\t\t\t} elseif (!file_exists(SERVER_ROOT.\"templates/basic/\".$id.\".php\")) {\n\t\t\t\tBigTree::putFile(SERVER_ROOT.\"templates/basic/\".$id.\".php\",$file_contents);\n\t\t\t}\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(htmlspecialchars($name));\n\t\t\t$module = sqlescape($module);\n\t\t\t$resources = BigTree::json($clean_resources,true);\n\t\t\t$level = sqlescape($level);\n\t\t\t$routed = sqlescape($routed);\n\n\t\t\t// Increase the count of the positions on all templates by 1 so that this new template is for sure in last position.\n\t\t\tsqlquery(\"UPDATE bigtree_templates SET position = position + 1\");\n\t\t\tsqlquery(\"INSERT INTO bigtree_templates (`id`,`name`,`module`,`resources`,`level`,`routed`) VALUES ('$id','$name','$module','$resources','$level','$routed')\");\n\t\t\t$this->track(\"bigtree_templates\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createUser\n\t\t\t\tCreates a user.\n\t\t\t\tChecks for developer access.\n\n\t\t\tParameters:\n\t\t\t\tdata - An array of user data. (\"email\", \"password\", \"name\", \"company\", \"level\", \"permissions\",\"alerts\")\n\n\t\t\tReturns:\n\t\t\t\tid of the newly created user or false if a user already exists with the provided email.\n\t\t*/\n\n\t\tfunction createUser($data) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$level = intval($data[\"level\"]);\n\t\t\t$email = sqlescape($data[\"email\"]);\n\t\t\t$name = sqlescape(htmlspecialchars($data[\"name\"]));\n\t\t\t$company = sqlescape(htmlspecialchars($data[\"company\"]));\n\t\t\t$daily_digest = $data[\"daily_digest\"] ? \"on\" : \"\";\n\n\t\t\t// See if the user already exists\n\t\t\t$r = sqlrows(sqlquery(\"SELECT * FROM bigtree_users WHERE email = '$email'\"));\n\t\t\tif ($r > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$permissions = $data[\"permissions\"] ? BigTree::json($data[\"permissions\"],true) : \"[]\";\n\t\t\t$alerts = $data[\"alerts\"] ? BigTree::json($data[\"alerts\"],true) : \"[]\";\n\n\t\t\t// Don't allow the level to be set higher than the logged in user's level\n\t\t\tif ($level > $this->Level) {\n\t\t\t\t$level = $this->Level;\n\t\t\t}\n\n\t\t\t// Hash the password.\n\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], TRUE);\n\t\t\t$password = sqlescape($phpass->HashPassword(trim($data[\"password\"])));\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_users (`email`,`password`,`name`,`company`,`level`,`permissions`,`alerts`,`daily_digest`) VALUES ('$email','$password','$name','$company','$level','$permissions','$alerts','$daily_digest')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_users\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: delete404\n\t\t\t\tDeletes a 404 error.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the reported 404.\n\t\t*/\n\n\t\tfunction delete404($id) {\n\t\t\t$this->requireLevel(1);\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_404s WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_404s\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteCallout\n\t\t\t\tDeletes a callout and removes its file.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout.\n\t\t*/\n\n\t\tfunction deleteCallout($id) {\n\t\t\t$id = sqlescape($id);\n\n\t\t\t// Delete the callout and its related file\n\t\t\tsqlquery(\"DELETE FROM bigtree_callouts WHERE id = '$id'\");\n\t\t\tunlink(SERVER_ROOT.\"templates/callouts/$id.php\");\n\n\t\t\t// Remove the callout from any groups it lives in\n\t\t\t$groups = sqlquery(\"SELECT id, callouts FROM bigtree_callout_groups WHERE callouts LIKE '%\\\"$id\\\"%'\");\n\t\t\twhile ($f = sqlfetch($groups)) {\n\t\t\t\t$callouts = array_filter((array)json_decode($f[\"callouts\"],true));\n\t\t\t\t$new = BigTree::json(array_diff($callouts, array($id)), true);\n\t\t\t\tsqlquery(\"UPDATE bigtree_callout_groups SET callouts = '$new' WHERE id = '\".$f[\"id\"].\"'\");\n\t\t\t}\n\n\t\t\t// Track deletion\n\t\t\t$this->track(\"bigtree_callouts\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteCalloutGroup\n\t\t\t\tDeletes a callout group.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout group.\n\t\t*/\n\n\t\tfunction deleteCalloutGroup($id) {\n\t\t\tsqlquery(\"DELETE FROM bigtree_callout_groups WHERE id = '\".sqlescape($id).\"'\");\n\t\t\t$this->track(\"bigtree_callout_groups\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteExtension\n\t\t\t\tUninstalls an extension from BigTree and removes its related components and files.\n\n\t\t\tParameters:\n\t\t\t\tid - The extension ID.\n\t\t*/\n\n\t\tfunction deleteExtension($id) {\n\t\t\t$extension = $this->getExtension($id);\n\n\t\t\tif (!$extension) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$j = json_decode($extension[\"manifest\"],true);\n\t\t\t\n\t\t\t// Don't delete the whole directory if the manifest fails to load\n\t\t\tif ($j[\"id\"]) {\n\t\t\t\t// Delete site files\n\t\t\t\tBigTree::deleteDirectory(SITE_ROOT.\"extensions/\".$j[\"id\"].\"/\");\n\t\t\t\t// Delete extensions directory\n\t\t\t\tBigTree::deleteDirectory(SERVER_ROOT.\"extensions/\".$j[\"id\"].\"/\");\n\t\t\t}\n\t\t\n\t\t\t// Delete components\n\t\t\tforeach ($j[\"components\"] as $type => $list) {\n\t\t\t\tif ($type == \"tables\") {\n\t\t\t\t\t// Turn off foreign key checks since we're going to be dropping tables.\n\t\t\t\t\tsqlquery(\"SET SESSION foreign_key_checks = 0\");\n\t\t\t\t\tforeach ($list as $table => $create_statement) {\n\t\t\t\t\t\tsqlquery(\"DROP TABLE IF EXISTS `$table`\");\n\t\t\t\t\t}\n\t\t\t\t\tsqlquery(\"SET SESSION foreign_key_checks = 1\");\n\t\t\t\t} else {\n\t\t\t\t\tforeach ($list as $item) {\n\t\t\t\t\t\tsqlquery(\"DELETE FROM `bigtree_$type` WHERE id = '\".sqlescape($item[\"id\"]).\"'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Delete extension entry\n\t\t\tsqlquery(\"DELETE FROM bigtree_extensions WHERE id = '\".sqlescape($extension[\"id\"]).\"'\");\n\t\t\t$this->track(\"bigtree_extensions\",$extension[\"id\"],\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteFeed\n\t\t\t\tDeletes a feed.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the feed.\n\t\t*/\n\n\t\tfunction deleteFeed($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_feeds WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_feeds\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteFieldType\n\t\t\t\tDeletes a field type and erases its files.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the field type.\n\t\t*/\n\n\t\tfunction deleteFieldType($id) {\n\t\t\t@unlink(SERVER_ROOT.\"custom/admin/form-field-types/draw/$id.php\");\n\t\t\t@unlink(SERVER_ROOT.\"custom/admin/form-field-types/process/$id.php\");\n\t\t\t@unlink(SERVER_ROOT.\"custom/admin/ajax/developer/field-options/$id.php\");\n\t\t\t@unlink(SERVER_ROOT.\"cache/bigtree-form-field-types.json\");\n\t\t\t\n\t\t\tsqlquery(\"DELETE FROM bigtree_field_types WHERE id = '\".sqlescape($id).\"'\");\n\t\t\t$this->track(\"bigtree_field_types\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModule\n\t\t\t\tDeletes a module.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module.\n\t\t*/\n\n\t\tfunction deleteModule($id) {\n\t\t\t$id = sqlescape($id);\n\n\t\t\t// Get info and delete the class.\n\t\t\t$module = $this->getModule($id);\n\t\t\tunlink(SERVER_ROOT.\"custom/inc/modules/\".$module[\"route\"].\".php\");\n\t\t\tBigTree::deleteDirectory(SERVER_ROOT.\"custom/admin/modules/\".$module[\"route\"].\"/\");\n\n\t\t\t// Delete all the related auto module actions\n\t\t\t$actions = $this->getModuleActions($id);\n\t\t\tforeach ($actions as $action) {\n\t\t\t\tif ($action[\"form\"]) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_forms WHERE id = '\".$action[\"form\"].\"'\");\n\t\t\t\t}\n\t\t\t\tif ($action[\"view\"]) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_views WHERE id = '\".$action[\"view\"].\"'\");\n\t\t\t\t}\n\t\t\t\tif ($action[\"report\"]) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_reports WHERE id = '\".$action[\"report\"].\"'\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Delete actions\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_actions WHERE module = '$id'\");\n\n\t\t\t// Delete embeds\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_embeds WHERE module = '$id'\");\n\n\t\t\t// Delete the module\n\t\t\tsqlquery(\"DELETE FROM bigtree_modules WHERE id = '$id'\");\n\n\t\t\t$this->track(\"bigtree_modules\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleAction\n\t\t\t\tDeletes a module action.\n\t\t\t\tAlso deletes the related form or view if no other action is using it.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the action to delete.\n\t\t*/\n\n\t\tfunction deleteModuleAction($id) {\n\t\t\t$id = sqlescape($id);\n\n\t\t\t$a = $this->getModuleAction($id);\n\t\t\tif ($a[\"form\"]) {\n\t\t\t\t// Only delete the auto-ness if it's the only one using it.\n\t\t\t\tif (sqlrows(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE form = '\".$a[\"form\"].\"'\")) == 1) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_forms WHERE id = '\".$a[\"form\"].\"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($a[\"view\"]) {\n\t\t\t\t// Only delete the auto-ness if it's the only one using it.\n\t\t\t\tif (sqlrows(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE view = '\".$a[\"view\"].\"'\")) == 1) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_views WHERE id = '\".$a[\"view\"].\"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_actions WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_module_actions\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleEmbedForm\n\t\t\t\tDeletes an embeddable module form.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the embeddable form.\n\t\t*/\n\n\t\tfunction deleteModuleEmbedForm($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_embeds WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleForm\n\t\t\t\tDeletes a module form and its related actions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module form.\n\t\t*/\n\n\t\tfunction deleteModuleForm($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_forms WHERE id = '$id'\");\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_actions WHERE form = '$id'\");\n\t\t\t$this->track(\"bigtree_module_forms\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleGroup\n\t\t\t\tDeletes a module group. Sets modules in the group to Misc.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module group.\n\t\t*/\n\n\t\tfunction deleteModuleGroup($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_groups WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_module_groups\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleReport\n\t\t\t\tDeletes a module report and its related actions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module report.\n\t\t*/\n\n\t\tfunction deleteModuleReport($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_reports WHERE id = '$id'\");\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_actions WHERE report = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleView\n\t\t\t\tDeletes a module view and its related actions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module view.\n\t\t*/\n\n\t\tfunction deleteModuleView($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_views WHERE id = '$id'\");\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_actions WHERE view = '$id'\");\n\t\t\t$this->track(\"bigtree_module_views\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePackage\n\t\t\t\tUninstalls a package from BigTree and removes its related components and files.\n\n\t\t\tParameters:\n\t\t\t\tid - The package ID.\n\t\t*/\n\n\t\tfunction deletePackage($id) {\n\t\t\t$package = $this->getPackage($id);\n\t\t\t$j = json_decode($package[\"manifest\"],true);\n\t\t\n\t\t\t// Delete related files\n\t\t\tforeach ($j[\"files\"] as $file) {\n\t\t\t\t@unlink(SERVER_ROOT.$file);\n\t\t\t}\n\t\t\n\t\t\t// Delete components\n\t\t\tforeach ($j[\"components\"] as $type => $list) {\n\t\t\t\tif ($type == \"tables\") {\n\t\t\t\t\t// Turn off foreign key checks since we're going to be dropping tables.\n\t\t\t\t\tsqlquery(\"SET SESSION foreign_key_checks = 0\");\n\t\t\t\t\tforeach ($list as $table) {\n\t\t\t\t\t\tsqlquery(\"DROP TABLE IF EXISTS `$table`\");\n\t\t\t\t\t}\n\t\t\t\t\tsqlquery(\"SET SESSION foreign_key_checks = 1\");\n\t\t\t\t} else {\n\t\t\t\t\tforeach ($list as $item) {\n\t\t\t\t\t\tsqlquery(\"DELETE FROM `bigtree_$type` WHERE id = '\".sqlescape($item[\"id\"]).\"'\");\n\t\t\t\t\t}\n\t\t\t\t\t// Modules might have their own directories\n\t\t\t\t\tif ($type == \"modules\") {\n\t\t\t\t\t\tforeach ($list as $item) {\n\t\t\t\t\t\t\t@rmdir(SERVER_ROOT.\"custom/admin/modules/\".$item[\"route\"].\"/\");\n\t\t\t\t\t\t\t@rmdir(SERVER_ROOT.\"custom/admin/ajax/\".$item[\"route\"].\"/\");\n\t\t\t\t\t\t\t@rmdir(SERVER_ROOT.\"custom/admin/images/\".$item[\"route\"].\"/\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif ($type == \"templates\") {\n\t\t\t\t\t\tforeach ($list as $item) {\n\t\t\t\t\t\t\t@rmdir(SERVER_ROOT.\"templates/routed/\".$item[\"id\"].\"/\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tsqlquery(\"DELETE FROM bigtree_extensions WHERE id = '\".sqlescape($package[\"id\"]).\"'\");\n\t\t\t$this->track(\"bigtree_extensions\",$package[\"id\"],\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePage\n\t\t\t\tDeletes a page or a pending page.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tpage - A page id or a pending page id prefixed with a \"p\"\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful. Stops page execution if permission issues occur.\n\t\t*/\n\n\t\tfunction deletePage($page) {\n\t\t\t$page = sqlescape($page);\n\n\t\t\t$r = $this->getPageAccessLevel($page);\n\t\t\tif ($r == \"p\" && $this->canModifyChildren(BigTreeCMS::getPage($page))) {\n\t\t\t\t// If the page isn't numeric it's most likely prefixed by the \"p\" so it's pending.\n\t\t\t\tif (!is_numeric($page)) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_pending_changes WHERE id = '\".sqlescape(substr($page,1)).\"'\");\n\t\t\t\t\tstatic::growl(\"Pages\",\"Deleted Page\");\n\t\t\t\t\t$this->track(\"bigtree_pages\",\"p$page\",\"deleted-pending\");\n\t\t\t\t} else {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_pages WHERE id = '$page'\");\n\t\t\t\t\t// Delete the children as well.\n\t\t\t\t\t$this->deletePageChildren($page);\n\t\t\t\t\tstatic::growl(\"Pages\",\"Deleted Page\");\n\t\t\t\t\t$this->track(\"bigtree_pages\",$page,\"deleted\");\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t$this->stop(\"You do not have permission to delete this page.\");\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePageChildren\n\t\t\t\tDeletes the children of a page and recurses downward.\n\t\t\t\tDoes not check permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The parent id to delete children for.\n\t\t*/\n\n\t\tfunction deletePageChildren($id) {\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE parent = '$id'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$this->deletePageChildren($f[\"id\"]);\n\t\t\t\t$this->track(\"bigtree_pages\",$f[\"id\"],\"deleted-inherited\");\n\t\t\t}\n\t\t\tsqlquery(\"DELETE FROM bigtree_pages WHERE parent = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePageDraft\n\t\t\t\tDeletes a page draft.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The page id to delete the draft for.\n\t\t*/\n\n\t\tfunction deletePageDraft($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t// Get the version, check if the user has access to the page the version refers to.\n\t\t\t$access = $this->getPageAccessLevel($id);\n\t\t\tif ($access != \"p\") {\n\t\t\t\t$this->stop(\"You must be a publisher to manage revisions.\");\n\t\t\t}\n\n\t\t\t// Get draft copy's ID\n\t\t\t$draft = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND `item_id` = '$id'\"));\n\n\t\t\t// Delete draft copy\n\t\t\tsqlquery(\"DELETE FROM bigtree_pending_changes WHERE id = '\".$draft[\"id\"].\"'\");\n\t\t\t$this->track(\"bigtree_pending_changes\",$draft[\"id\"],\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePageRevision\n\t\t\t\tDeletes a page revision.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The page version id.\n\t\t*/\n\n\t\tfunction deletePageRevision($id) {\n\t\t\t// Get the version, check if the user has access to the page the version refers to.\n\t\t\t$revision = $this->getPageRevision($id);\n\t\t\t$access = $this->getPageAccessLevel($revision[\"page\"]);\n\t\t\tif ($access != \"p\") {\n\t\t\t\t$this->stop(\"You must be a publisher to manage revisions.\");\n\t\t\t}\n\n\t\t\t// Delete the revision\n\t\t\tsqlquery(\"DELETE FROM bigtree_page_revisions WHERE id = '\".$revision[\"id\"].\"'\");\n\t\t\t$this->track(\"bigtree_page_revisions\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePendingChange\n\t\t\t\tDeletes a pending change.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the change.\n\t\t*/\n\n\t\tfunction deletePendingChange($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_pending_changes WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_pending_changes\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteResource\n\t\t\t\tDeletes a resource.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the resource.\n\t\t*/\n\n\t\tfunction deleteResource($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$r = $this->getResource($id);\n\t\t\tif ($r) {\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_resources WHERE id = '\".sqlescape($r[\"id\"]).\"'\");\n\n\t\t\t\t// If this file isn't located in any other folders, delete it from the file system\n\t\t\t\tif (!sqlrows(sqlquery(\"SELECT id FROM bigtree_resources WHERE file = '\".sqlescape($r[\"file\"]).\"'\"))) {\n\t\t\t\t\t$storage = new BigTreeStorage;\n\t\t\t\t\t$storage->delete($r[\"file\"]);\n\t\t\t\t\tforeach ($r[\"thumbs\"] as $thumb) {\n\t\t\t\t\t\t$storage->delete($thumb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$this->track(\"bigtree_resources\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteResourceFolder\n\t\t\t\tDeletes a resource folder and all of its sub folders and resources.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the resource folder.\n\t\t*/\n\n\t\tfunction deleteResourceFolder($id) {\n\t\t\t$items = $this->getContentsOfResourceFolder($id);\n\t\t\tforeach ($items[\"folders\"] as $folder) {\n\t\t\t\t$this->deleteResourceFolder($folder[\"id\"]);\n\t\t\t}\n\t\t\tforeach ($items[\"resources\"] as $resource) {\n\t\t\t\t$this->deleteResource($resource[\"id\"]);\n\t\t\t}\n\t\t\tsqlquery(\"DELETE FROM bigtree_resource_folders WHERE id = '\".sqlescape($id).\"'\");\n\t\t\t$this->track(\"bigtree_resource_folders\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteSetting\n\t\t\t\tDeletes a setting.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the setting.\n\t\t*/\n\n\t\tfunction deleteSetting($id) {\n\t\t\t$id = BigTreeCMS::extensionSettingCheck($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_settings WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_settings\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteTemplate\n\t\t\t\tDeletes a template and its related files.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the template.\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful.\n\t\t*/\n\n\t\tfunction deleteTemplate($id) {\n\t\t\t$template = BigTreeCMS::getTemplate($id);\n\t\t\tif (!$template) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($template[\"routed\"]) {\n\t\t\t\tBigTree::deleteDirectory(SERVER_ROOT.\"templates/routed/\".$template[\"id\"].\"/\");\n\t\t\t} else {\n\t\t\t\t@unlink(SERVER_ROOT.\"templates/basic/\".$template[\"id\"].\".php\");\n\t\t\t}\n\t\t\tsqlquery(\"DELETE FROM bigtree_templates WHERE id = '\".sqlescape($template[\"id\"]).\"'\");\n\t\t\t$this->track(\"bigtree_templates\",$template[\"id\"],\"deleted\");\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteUser\n\t\t\t\tDeletes a user.\n\t\t\t\tChecks for developer access.\n\n\t\t\tParameters:\n\t\t\t\tid - The user id to delete.\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful. false if the logged in user does not have permission to delete the user.\n\t\t*/\n\n\t\tfunction deleteUser($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t// If this person has higher access levels than the person trying to update them, fail.\n\t\t\t$current = static::getUser($id);\n\t\t\tif ($current[\"level\"] > $this->Level) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsqlquery(\"DELETE FROM bigtree_users WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_users\",$id,\"deleted\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: disconnectGoogleAnalytics\n\t\t\t\tTurns of Google Analytics settings in BigTree and deletes cached information.\n\t\t*/\n\n\t\tfunction disconnectGoogleAnalytics() {\n\t\t\tunlink(SERVER_ROOT.\"cache/analytics.json\");\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET ga_page_views = NULL\");\n\t\t\tsqlquery(\"DELETE FROM bigtree_caches WHERE identifier = 'org.bigtreecms.api.analytics.google'\");\n\t\t\tstatic::growl(\"Analytics\",\"Disconnected\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: doesModuleActionExist\n\t\t\t\tChecks to see if an action exists for a given route and module.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module to check.\n\t\t\t\troute - The route of the action to check.\n\n\t\t\tReturns:\n\t\t\t\ttrue if an action exists, otherwise false.\n\t\t*/\n\n\t\tstatic function doesModuleActionExist($module,$route) {\n\t\t\t$module = sqlescape($module);\n\t\t\t$route = sqlescape($route);\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT id FROM bigtree_module_actions WHERE module = '$module' AND route = '$route'\"));\n\t\t\tif ($f) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: doesModuleEditActionExist\n\t\t\t\tDetermines whether there is already an edit action for a module.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module id to check.\n\n\t\t\tReturns:\n\t\t\t\t1 or 0, for true or false.\n\t\t*/\n\n\t\tstatic function doesModuleEditActionExist($module) {\n\t\t\treturn sqlrows(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '\".sqlescape($module).\"' AND route = 'edit'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: doesModuleLandingActionExist\n\t\t\t\tDetermines whether there is already a landing action for a module.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module id to check.\n\n\t\t\tReturns:\n\t\t\t\t1 or 0, for true or false.\n\t\t*/\n\n\t\tstatic function doesModuleLandingActionExist($module) {\n\t\t\treturn sqlrows(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '\".sqlescape($module).\"' AND route = ''\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: drawArrayLevel\n\t\t\t\tAn internal function used for drawing callout and matrix resource data.\n\t\t*/\n\n\t\tstatic function drawArrayLevel($keys,$level,$field = false) {\n\t\t\t// Backwards compatibility in case any external developers used this\n\t\t\tif ($field === false) {\n\t\t\t\tglobal $field;\n\t\t\t}\n\t\t\tforeach ($level as $key => $value) {\n\t\t\t\tif (is_array($value)) {\n\t\t\t\t\tstatic::drawArrayLevel(array_merge($keys,array($key)),$value,$field);\n\t\t\t\t} else {\n?>\n<input type=\"hidden\" name=\"<?=$field[\"key\"]?>[<?=implode(\"][\",$keys)?>][<?=$key?>]\" value=\"<?=BigTree::safeEncode($value)?>\" />\n<?\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: drawField\n\t\t\t\tA helper function that draws a field type.\n\n\t\t\tParameters:\n\t\t\t\tfield - Field array\n\t\t*/\n\n\t\tstatic function drawField($field) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\n\t\t\t// Give the field a unique id\n\t\t\t$bigtree[\"field_counter\"]++;\n\t\t\t$field[\"id\"] = $bigtree[\"field_namespace\"].$bigtree[\"field_counter\"];\n\n\t\t\t// Make sure options is an array to prevent warnings\n\t\t\tif (!is_array($field[\"options\"])) {\n\t\t\t\t$field[\"options\"] = array();\n\t\t\t}\n\n\t\t\t$field[\"options\"] = BigTree::untranslateArray($field[\"options\"]);\n\n\t\t\t// Setup Validation Classes\n\t\t\t$label_validation_class = \"\";\n\t\t\t$field[\"required\"] = false;\n\t\t\tif (!empty($field[\"options\"][\"validation\"])) {\n\t\t\t\tif (strpos($field[\"options\"][\"validation\"],\"required\") !== false) {\n\t\t\t\t\t$label_validation_class = ' class=\"required\"';\n\t\t\t\t\t$field[\"required\"] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Prevent path abuse\n\t\t\t$field[\"type\"] = BigTree::cleanFile($field[\"type\"]);\n\n\t\t\t// Save current context\n\t\t\t$bigtree[\"saved_extension_context\"] = $bigtree[\"extension_context\"];\n\n\t\t\t// Get path and set context\n\t\t\tif (strpos($field[\"type\"],\"*\") !== false) {\n\t\t\t\tlist($extension,$field_type) = explode(\"*\",$field[\"type\"]);\n\n\t\t\t\t$bigtree[\"extension_context\"] = $extension;\n\t\t\t\t$field_type_path = SERVER_ROOT.\"extensions/$extension/field-types/$field_type/draw.php\";\n\t\t\t} else {\n\t\t\t\t$field_type_path = BigTree::path(\"admin/form-field-types/draw/\".$field[\"type\"].\".php\");\n\t\t\t}\n\n\t\t\tif (file_exists($field_type_path)) {\n\t\t\t\t// Don't draw the fieldset for field types that are declared as self drawing.\n\t\t\t\tif ($bigtree[\"field_types\"][$field[\"type\"]][\"self_draw\"]) {\n\t\t\t\t\tinclude $field_type_path;\n\t\t\t\t} else {\n?>\n<fieldset<? if ($field[\"matrix_title_field\"]) { ?> class=\"matrix_title_field\"<? } ?>>\n\t<? if ($field[\"title\"] && $field[\"type\"] != \"checkbox\") { ?>\n\t<label<?=$label_validation_class?>><?=$field[\"title\"]?><? if ($field[\"subtitle\"]) { ?> <small><?=$field[\"subtitle\"]?></small><? } ?></label>\n\t<? } ?>\n\t<? include $field_type_path ?>\n</fieldset>\n<?\n\t\t\t\t\t$bigtree[\"tabindex\"]++;\n\t\t\t\t}\n\n\t\t\t\t$bigtree[\"last_resource_type\"] = $field[\"type\"];\n\t\t\t}\n\n\t\t\t// Restore context\n\t\t\t$bigtree[\"extension_context\"] = $bigtree[\"saved_extension_context\"];\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: drawCSRFToken\n\t\t\t\tDraws an input field for the CSRF token.\n\t\t*/\n\t\t\n\t\tfunction drawCSRFToken() {\n\t\t\techo '<input type=\"hidden\" value=\"'.htmlspecialchars($this->CSRFToken).'\" name=\"'.$this->CSRFTokenField.'\" />';\n\t\t}\n\n\t\t/*\n\t\t\tFunction: drawCSRFTokenGET\n\t\t\t\tDraws a GET variable in a URL for the CSRF token.\n\t\t*/\n\t\t\n\t\tfunction drawCSRFTokenGET() {\n\t\t\techo '&'.$this->CSRFTokenField.'='.urlencode($this->CSRFToken);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: drawPOSTErrorMessage\n\t\t\t\tIf a POST error occurred, draws a message for the form.\n\n\t\t\tReturns:\n\t\t\t\ttrue if a message was displayed\n\t\t*/\n\n\t\tstatic function drawPOSTErrorMessage($dont_unset = false) {\n\t\t\tif (!empty($_SESSION[\"bigtree_admin\"][\"post_error\"])) {\n\t\t\t\t$error_code = $_SESSION[\"bigtree_admin\"][\"post_error\"];\n\n\t\t\t\tif ($dont_unset == false) {\n\t\t\t\t\tunset($_SESSION[\"bigtree_admin\"][\"post_error\"]);\n\t\t\t\t}\n\n\t\t\t\tif ($error_code == \"max_input_vars\") {\n\t\t\t\t\t$message = \"The maximum number of input variables was exceeded and the submission failed.<br>Please ask your system administrator to increase the max_input_vars limit in php.ini\";\n\t\t\t\t} elseif ($error_code == \"post_max_size\") {\n\t\t\t\t\t$message = \"The submission exceeded the web server's maximum submission size.<br>If you uploaded multiple files, try uploading one at a time or ask your system administrator to increase the post_max_size and upload_max_filesize settings in php.ini\";\n\t\t\t\t}\n\n\t\t\t\tif (!$message) {\n\t\t\t\t\t$message = \"An unknown error occurred.\";\n\t\t\t\t}\n\n\t\t\t\techo '<p class=\"warning_message\">'.$message.'</p>';\n\t\t\t\techo '<hr>';\n\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: emailDailyDigest\n\t\t\t\tSends out a daily digest email to all who have subscribed.\n\t\t*/\n\n\t\tfunction emailDailyDigest() {\n\t\t\tglobal $bigtree;\n\n\t\t\t$home_page = sqlfetch(sqlquery(\"SELECT `nav_title` FROM `bigtree_pages` WHERE id = 0\"));\n\t\t\t$site_title = $home_page[\"nav_title\"];\n\t\t\t$image_root = $bigtree[\"config\"][\"admin_root\"].\"images/email/\";\n\n\t\t\t$qusers = sqlquery(\"SELECT * FROM bigtree_users where daily_digest = 'on'\");\n\t\t\twhile ($user = sqlfetch($qusers)) {\n\t\t\t\t$changes = $this->getPublishableChanges($user[\"id\"]);\n\t\t\t\t$alerts = $this->getContentAlerts($user[\"id\"]);\n\t\t\t\t$messages = $this->getMessages($user[\"id\"]);\n\t\t\t\t$unread = $messages[\"unread\"];\n\n\t\t\t\t// Start building the email\n\t\t\t\t$body_alerts = $body_changes = $body_messages = \"\";\n\n\t\t\t\t// Alerts\n\t\t\t\tif (is_array($alerts) && count($alerts)) {\n\t\t\t\t\tforeach ($alerts as $alert) {\n\t\t\t\t\t\t$body_alerts .= '<tr>';\n\t\t\t\t\t\t$body_alerts .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.$alert[\"nav_title\"].'</td>';\n\t\t\t\t\t\t$body_alerts .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 20px 10px 15px; text-align: right;\">'.$alert[\"current_age\"].' Days</td>';\n\n\t\t\t\t\t\t$body_alerts .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0; text-align: center;\"><a href=\"'.$bigtree[\"config\"][\"www_root\"].$alert[\"path\"].'/\"><img src=\"'.$image_root.'launch.gif\" alt=\"Launch\" /></a></td>';\n\n\t\t\t\t\t\t$body_alerts .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0; text-align: center;\"><a href=\"'.$bigtree[\"config\"][\"admin_root\"].\"pages/edit/\".$alert[\"id\"].'/\"><img src=\"'.$image_root.'edit.gif\" alt=\"Edit\" /></a></td>';\n\t\t\t\t\t\t$body_alerts .= '</tr>';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$body_alerts = '<tr><td colspan=\"4\" style=\"border-bottom: 1px solid #eee; color: #999; padding: 10px 0 10px 15px;\"><p>No Content Age Alerts</p></td></tr>';\n\t\t\t\t}\n\n\t\t\t\t// Changes\n\t\t\t\tif (count($changes)) {\n\t\t\t\t\tforeach ($changes as $change) {\n\t\t\t\t\t\t$body_changes .= '<tr>';\n\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.$change[\"user\"][\"name\"].'</td>';\n\t\t\t\t\t\tif ($change[\"title\"]) {\n\t\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">Pages</td>';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.$change[\"mod\"][\"name\"].'</td>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_null($change[\"item_id\"])) {\n\t\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">Addition</td>';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">Edit</td>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0; text-align: center;\"><a href=\"'.static::getChangeEditLink($change).'\"><img src=\"'.$image_root.'launch.gif\" alt=\"Launch\" /></a></td>' . \"\\r\\n\";\n\t\t\t\t\t\t$body_changes .= '</tr>';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$body_changes = '<tr><td colspan=\"4\" style=\"border-bottom: 1px solid #eee; color: #999; padding: 10px 0 10px 15px;\"><p>No Pending Changes</p></td></tr>';\n\t\t\t\t}\n\n\t\t\t\t// Messages\n\t\t\t\tif (count($unread)) {\n\t\t\t\t\tforeach ($unread as $message) {\n\t\t\t\t\t\t$body_messages .= '<tr>';\n\t\t\t\t\t\t$body_messages .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.$message[\"sender_name\"].'</td>';\n\t\t\t\t\t\t$body_messages .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.$message[\"subject\"].'</td>';\n\t\t\t\t\t\t$body_messages .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.date(\"n/j/y g:ia\",strtotime($message[\"date\"])).'</td>';\n\t\t\t\t\t\t$body_messages .= '</tr>';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$body_messages = '<tr><td colspan=\"3\" style=\"border-bottom: 1px solid #eee; color: #999; padding: 10px 0 10px 15px;\"><p>No Unread Messages</p></td></tr>';\n\t\t\t\t}\n\n\t\t\t\t// Send it\n\t\t\t\t$es = new BigTreeEmailService;\n\t\t\t\tif ((is_array($alerts) && count($alerts)) || count($changes) || count($unread)) {\n\t\t\t\t\t$body = file_get_contents(BigTree::path(\"admin/email/daily-digest.html\"));\n\t\t\t\t\t$body = str_ireplace(\"{www_root}\", $bigtree[\"config\"][\"www_root\"], $body);\n\t\t\t\t\t$body = str_ireplace(\"{admin_root}\", $bigtree[\"config\"][\"admin_root\"], $body);\n\t\t\t\t\t$body = str_ireplace(\"{site_title}\", $site_title, $body);\n\t\t\t\t\t$body = str_ireplace(\"{date}\", date(\"F j, Y\",time()), $body);\n\t\t\t\t\t$body = str_ireplace(\"{content_alerts}\", $body_alerts, $body);\n\t\t\t\t\t$body = str_ireplace(\"{pending_changes}\", $body_changes, $body);\n\t\t\t\t\t$body = str_ireplace(\"{unread_messages}\", $body_messages, $body);\n\n\t\t\t\t\t// If we don't have a from email set, third parties most likely will fail so we're going to use local sending\n\t\t\t\t\tif ($es->Settings[\"bigtree_from\"]) {\n\t\t\t\t\t\t$reply_to = \"no-reply@\".(isset($_SERVER[\"HTTP_HOST\"]) ? str_replace(\"www.\",\"\",$_SERVER[\"HTTP_HOST\"]) : str_replace(array(\"http://www.\",\"https://www.\",\"http://\",\"https://\"),\"\",DOMAIN));\n\t\t\t\t\t\t$es->sendEmail(\"$site_title Daily Digest\",$body,$user[\"email\"],$es->Settings[\"bigtree_from\"],\"BigTree CMS\",$reply_to);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tBigTree::sendEmail($user[\"email\"],\"$site_title Daily Digest\",$body);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: forgotPassword\n\t\t\t\tCreates a new password change hash and sends an email to the user.\n\n\t\t\tParameters:\n\t\t\t\temail - The user's email address\n\n\t\t\tReturns:\n\t\t\t\tRedirects if the email address was found, returns false if the user doesn't exist.\n\n\t\t\tSee Also:\n\t\t\t\t<changePassword>\n\t\t*/\n\n\t\tstatic function forgotPassword($email) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$home_page = sqlfetch(sqlquery(\"SELECT `nav_title` FROM `bigtree_pages` WHERE id = 0\"));\n\t\t\t$site_title = $home_page[\"nav_title\"];\n\n\t\t\t$email = sqlescape($email);\n\t\t\t$user = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE email = '$email'\"));\n\t\t\tif (!$user) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$hash = sqlescape(md5(md5($user[\"password\"]).md5(uniqid(\"bigtree-hash\".microtime(true)))));\n\t\t\tsqlquery(\"UPDATE bigtree_users SET change_password_hash = '$hash' WHERE id = '\".$user[\"id\"].\"'\");\n\n\t\t\t$login_root = ($bigtree[\"config\"][\"force_secure_login\"] ? str_replace(\"http://\",\"https://\",ADMIN_ROOT) : ADMIN_ROOT).\"login/\";\n\n\t\t\t$html = file_get_contents(BigTree::path(\"admin/email/reset-password.html\"));\n\t\t\t$html = str_ireplace(\"{www_root}\",WWW_ROOT,$html);\n\t\t\t$html = str_ireplace(\"{admin_root}\",ADMIN_ROOT,$html);\n\t\t\t$html = str_ireplace(\"{site_title}\",$site_title,$html);\n\t\t\t$html = str_ireplace(\"{reset_link}\",$login_root.\"reset-password/$hash/\",$html);\n\n\t\t\t$es = new BigTreeEmailService;\n\t\t\t\n\t\t\t// Only use a custom email service if a from email has been set\n\t\t\tif ($es->Settings[\"bigtree_from\"]) {\n\t\t\t\t$reply_to = \"no-reply@\".(isset($_SERVER[\"HTTP_HOST\"]) ? str_replace(\"www.\",\"\",$_SERVER[\"HTTP_HOST\"]) : str_replace(array(\"http://www.\",\"https://www.\",\"http://\",\"https://\"),\"\",DOMAIN));\n\t\t\t\t$es->sendEmail(\"Reset Your Password\",$html,$user[\"email\"],$es->Settings[\"bigtree_from\"],\"BigTree CMS\",$reply_to);\n\t\t\t} else {\n\t\t\t\tBigTree::sendEmail($user[\"email\"],\"Reset Your Password\",$html);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: get404Total\n\t\t\t\tGet the total number of 404s of a certain type.\n\n\t\t\tParameters:\n\t\t\t\ttype - The type to retrieve the count for (301, ignored, 404)\n\n\t\t\tReturns:\n\t\t\t\tThe number of 404s in the table of the given type.\n\t\t*/\n\n\t\tstatic function get404Total($type) {\n\t\t\tif ($type == \"404\") {\n\t\t\t\t$total = sqlfetch(sqlquery(\"SELECT COUNT(id) AS `total` FROM bigtree_404s WHERE ignored = '' AND redirect_url = ''\"));\n\t\t\t} elseif ($type == \"301\") {\n\t\t\t\t$total = sqlfetch(sqlquery(\"SELECT COUNT(id) AS `total` FROM bigtree_404s WHERE ignored = '' AND redirect_url != ''\"));\n\t\t\t} elseif ($type == \"ignored\") {\n\t\t\t\t$total = sqlfetch(sqlquery(\"SELECT COUNT(id) AS `total` FROM bigtree_404s WHERE ignored = 'on'\"));\n\t\t\t}\n\n\t\t\tif (!empty($total)) {\n\t\t\t\treturn $total[\"total\"];\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getAccessGroups\n\t\t\t\tReturns a list of all groups the logged in user has access to in a module.\n\n\t\t\tParameters:\n\t\t\t\tmodule - A module id or module entry.\n\n\t\t\tReturns:\n\t\t\t\tAn array of groups if a user has limited access to a module or \"true\" if the user has access to all groups.\n\t\t*/\n\n\t\tfunction getAccessGroups($module) {\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (is_array($module)) {\n\t\t\t\t$module = $module[\"id\"];\n\t\t\t}\n\n\t\t\tif ($this->Permissions[\"module\"][$module] && $this->Permissions[\"module\"][$module] != \"n\") {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t$groups = array();\n\t\t\tif (is_array($this->Permissions[\"module_gbp\"][$module])) {\n\t\t\t\tforeach ($this->Permissions[\"module_gbp\"][$module] as $group => $permission) {\n\t\t\t\t\tif ($permission && $permission != \"n\") {\n\t\t\t\t\t\t$groups[] = $group;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $groups;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getAccessLevel\n\t\t\t\tReturns the permission level for a given module and item.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module id or entry to check access for.\n\t\t\t\titem - (optional) The item of the module to check access for.\n\t\t\t\ttable - (optional) The group based table.\n\t\t\t\tuser - (optional) User array if checking for a user other than the logged in user.\n\n\t\t\tReturns:\n\t\t\t\tThe permission level for the given item or module (if item was not passed).\n\n\t\t\tSee Also:\n\t\t\t\t<getCachedAccessLevel>\n\t\t*/\n\n\t\tfunction getAccessLevel($module,$item = array(),$table = \"\",$user = false) {\n\t\t\tif (!$user) {\n\t\t\t\t$level = $this->Level;\n\t\t\t\t$permissions = $this->Permissions;\n\t\t\t} else {\n\t\t\t\t$level = $user[\"level\"];\n\t\t\t\t$permissions = $user[\"permissions\"];\n\t\t\t}\n\n\t\t\tif ($level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\n\t\t\t$id = is_array($module) ? $module[\"id\"] : $module;\n\n\t\t\t$perm = $permissions[\"module\"][$id];\n\n\t\t\t// If group based permissions aren't on or we're a publisher of this module it's an easy solution\u2026 or if we're not even using the table.\n\t\t\tif (!$item || !$module[\"gbp\"][\"enabled\"] || $perm == \"p\" || $table != $module[\"gbp\"][\"table\"]) {\n\t\t\t\treturn $perm;\n\t\t\t}\n\n\t\t\tif (is_array($permissions[\"module_gbp\"][$id])) {\n\t\t\t\t$gv = $item[$module[\"gbp\"][\"group_field\"]];\n\t\t\t\t$gp = $permissions[\"module_gbp\"][$id][$gv];\n\n\t\t\t\tif ($gp != \"n\") {\n\t\t\t\t\treturn $gp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $perm;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getActionClass\n\t\t\t\tReturns the button class for the given action and item.\n\n\t\t\tParameters:\n\t\t\t\taction - The action for the item (edit, feature, approve, etc)\n\t\t\t\titem - The entry to check the action for.\n\n\t\t\tReturns:\n\t\t\t\tClass name for the <a> tag.\n\n\t\t\t\tFor example, if the item is already featured, this returns \"icon_featured icon_featured_on\" for the \"feature\" action.\n\t\t\t\tIf the item isn't already featured, it would simply return \"icon_featured\" for the \"feature\" action.\n\t\t*/\n\n\t\tstatic function getActionClass($action,$item) {\n\t\t\t$class = \"\";\n\t\t\tif (isset($item[\"bigtree_pending\"]) && $action != \"edit\" && $action != \"delete\") {\n\t\t\t\treturn \"icon_disabled js-disabled-hook\";\n\t\t\t}\n\t\t\tif ($action == \"feature\") {\n\t\t\t\t$class = \"icon_feature js-feature-hook\";\n\t\t\t\t\n\t\t\t\tif ($item[\"featured\"]) {\n\t\t\t\t\t$class .= \" icon_feature_on\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($action == \"edit\") {\n\t\t\t\t$class = \"icon_edit\";\n\t\t\t}\n\t\t\tif ($action == \"delete\") {\n\t\t\t\t$class = \"icon_delete js-delete-hook\";\n\t\t\t}\n\t\t\tif ($action == \"approve\") {\n\t\t\t\t$class = \"icon_approve js-approve-hook\";\n\t\t\t\tif ($item[\"approved\"]) {\n\t\t\t\t\t$class .= \" icon_approve_on\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($action == \"archive\") {\n\t\t\t\t$class = \"icon_archive js-archive-hook\";\n\t\t\t\tif ($item[\"archived\"]) {\n\t\t\t\t\t$class .= \" icon_archive_on\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($action == \"preview\") {\n\t\t\t\t$class = \"icon_preview\";\n\t\t\t}\n\t\t\treturn $class;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getArchivedNavigationByParent\n\t\t\t\tReturns an alphabetic list of navigation that is archived under the given parent.\n\n\t\t\tParameters:\n\t\t\t\tparent - The ID of the parent page\n\n\t\t\tReturns:\n\t\t\t\tAn array of page entries.\n\t\t*/\n\n\t\tstatic function getArchivedNavigationByParent($parent) {\n\t\t\t$nav = array();\n\t\t\t$q = sqlquery(\"SELECT id,nav_title as title,parent,external,new_window,template,publish_at,expire_at,path,ga_page_views FROM bigtree_pages WHERE parent = '$parent' AND archived = 'on' ORDER BY nav_title asc\");\n\t\t\twhile ($nav_item = sqlfetch($q)) {\n\t\t\t\t$nav_item[\"external\"] = BigTreeCMS::replaceRelativeRoots($nav_item[\"external\"]);\n\t\t\t\t$nav[] = $nav_item;\n\t\t\t}\n\t\t\treturn $nav;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getAutoModuleActions\n\t\t\t\tReturn a list of module forms and views.\n\t\t\t\tUsed by the API for reconstructing forms and views.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module id to pull forms/views for.\n\n\t\t\tReturns:\n\t\t\t\tAn array of module actions with \"form\" and \"view\" columns replaced with form and view data.\n\n\t\t\tSee Also:\n\t\t\t\t<BigTreeAutoModule.getForm>\n\t\t\t\t<BigTreeAutoModule.getView>\n\t\t*/\n\n\t\tstatic function getAutoModuleActions($module) {\n\t\t\t$items = array();\n\t\t\t$id = sqlescape($module);\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '$id' AND (form != 0 OR view != 0) AND in_nav = 'on' ORDER BY position DESC, id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($f[\"form\"]) {\n\t\t\t\t\t$f[\"form\"] = BigTreeAutoModule::getForm($f[\"form\"]);\n\t\t\t\t\t$f[\"type\"] = \"form\";\n\t\t\t\t} elseif ($f[\"view\"]) {\n\t\t\t\t\t$f[\"view\"] = BigTreeAutoModule::getView($f[\"view\"]);\n\t\t\t\t\t$f[\"type\"] = \"view\";\n\t\t\t\t}\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getBasicTemplates\n\t\t\t\tReturns a list of non-routed templates ordered by position.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tsort - Sort order, defaults to positioned\n\n\t\t\tReturns:\n\t\t\t\tAn array of template entries.\n\t\t*/\n\n\t\tfunction getBasicTemplates($sort = \"position DESC, id ASC\") {\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_templates WHERE level <= '\".$this->Level.\"' ORDER BY $sort\");\n\t\t\t$items = array();\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif (!$f[\"routed\"]) {\n\t\t\t\t\t$items[] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCachedAccessLevel\n\t\t\t\tReturns the permission level for a given module and cached view entry.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module id or entry to check access for.\n\t\t\t\titem - (optional) The item of the module to check access for.\n\t\t\t\ttable - (optional) The group based table.\n\n\t\t\tReturns:\n\t\t\t\tThe permission level for the given item or module (if item was not passed).\n\n\t\t\tSee Also:\n\t\t\t\t<getAccessLevel>\n\t\t*/\n\n\t\t// Since cached items don't use their normal columns...\n\t\tfunction getCachedAccessLevel($module,$item = array(),$table = \"\") {\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\n\t\t\t$id = is_array($module) ? $module[\"id\"] : $module;\n\n\t\t\t$perm = $this->Permissions[\"module\"][$id];\n\n\t\t\t// If group based permissions aren't on or we're a publisher of this module it's an easy solution\u2026 or if we're not even using the table.\n\t\t\tif (!$item || !$module[\"gbp\"][\"enabled\"] || $perm == \"p\" || $table != $module[\"gbp\"][\"table\"]) {\n\t\t\t\treturn $perm;\n\t\t\t}\n\n\t\t\tif (is_array($this->Permissions[\"module_gbp\"][$id])) {\n\t\t\t\t$current_gbp_value = $item[\"gbp_field\"];\n\t\t\t\t$original_gbp_value = $item[\"published_gbp_field\"];\n\n\t\t\t\t$access_level = $this->Permissions[\"module_gbp\"][$id][$current_gbp_value];\n\t\t\t\tif ($access_level != \"n\") {\n\t\t\t\t\t$original_access_level = $this->Permissions[\"module_gbp\"][$id][$original_gbp_value];\n\t\t\t\t\tif ($original_access_level != \"p\") {\n\t\t\t\t\t\t$access_level = $original_access_level;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($access_level != \"n\") {\n\t\t\t\t\treturn $access_level;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $perm;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCachedFieldTypes\n\t\t\t\tCaches available field types and returns them.\n\n\t\t\tParameters:\n\t\t\t\tsplit - Whether to split the field types into separate default / custom arrays (defaults to false)\n\n\t\t\tReturns:\n\t\t\t\tArray of three arrays of field types (template, module, and callout).\n\t\t*/\n\n\t\tstatic function getCachedFieldTypes($split = false) {\n\t\t\t// Used cached values if available, otherwise query the DB\n\t\t\tif (file_exists(SERVER_ROOT.\"cache/bigtree-form-field-types.json\")) {\n\t\t\t\t$types = json_decode(file_get_contents(SERVER_ROOT.\"cache/bigtree-form-field-types.json\"),true);\n\t\t\t} else {\n\t\t\t\t$types[\"modules\"] = $types[\"templates\"] = $types[\"callouts\"] = $types[\"settings\"] = array(\n\t\t\t\t\t\"default\" => array(\n\t\t\t\t\t\t\"text\" => array(\"name\" => \"Text\", \"self_draw\" => false),\n\t\t\t\t\t\t\"textarea\" => array(\"name\" => \"Text Area\", \"self_draw\" => false),\n\t\t\t\t\t\t\"html\" => array(\"name\" => \"HTML Area\", \"self_draw\" => false),\n\t\t\t\t\t\t\"upload\" => array(\"name\" => \"Upload\", \"self_draw\" => false),\n\t\t\t\t\t\t\"list\" => array(\"name\" => \"List\", \"self_draw\" => false),\n\t\t\t\t\t\t\"checkbox\" => array(\"name\" => \"Checkbox\", \"self_draw\" => false),\n\t\t\t\t\t\t\"date\" => array(\"name\" => \"Date Picker\", \"self_draw\" => false),\n\t\t\t\t\t\t\"time\" => array(\"name\" => \"Time Picker\", \"self_draw\" => false),\n\t\t\t\t\t\t\"datetime\" => array(\"name\" => \"Date &amp; Time Picker\", \"self_draw\" => false),\n\t\t\t\t\t\t\"photo-gallery\" => array(\"name\" => \"Photo Gallery\", \"self_draw\" => false),\n\t\t\t\t\t\t\"callouts\" => array(\"name\" => \"Callouts\", \"self_draw\" => true),\n\t\t\t\t\t\t\"matrix\" => array(\"name\" => \"Matrix\", \"self_draw\" => true),\n\t\t\t\t\t\t\"one-to-many\" => array(\"name\" => \"One to Many\", \"self_draw\" => false)\n\t\t\t\t\t),\n\t\t\t\t\t\"custom\" => array()\n\t\t\t\t);\n\n\t\t\t\t$types[\"modules\"][\"default\"][\"route\"] = array(\"name\" => \"Generated Route\",\"self_draw\" => true);\n\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_field_types ORDER BY name\");\n\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t$use_cases = json_decode($f[\"use_cases\"],true);\n\t\t\t\t\tforeach ((array)$use_cases as $case => $val) {\n\t\t\t\t\t\tif ($val) {\n\t\t\t\t\t\t\t$types[$case][\"custom\"][$f[\"id\"]] = array(\"name\" => $f[\"name\"],\"self_draw\" => $f[\"self_draw\"]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tBigTree::putFile(SERVER_ROOT.\"cache/bigtree-form-field-types.json\",BigTree::json($types));\n\t\t\t}\n\n\t\t\t// Re-merge if we don't want them split\n\t\t\tif (!$split) {\n\t\t\t\tforeach ($types as $use_case => $list) {\n\t\t\t\t\t$types[$use_case] = array_merge($list[\"default\"],$list[\"custom\"]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $types;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCallout\n\t\t\t\tReturns a callout entry.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout.\n\n\t\t\tReturns:\n\t\t\t\tA callout entry from bigtree_callouts with resources decoded.\n\t\t*/\n\n\t\tstatic function getCallout($id) {\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_callouts WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\tif (!$item) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$item[\"resources\"] = json_decode($item[\"resources\"],true);\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCalloutGroup\n\t\t\t\tReturns a callout group entry from the bigtree_callout_groups table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout group.\n\n\t\t\tReturns:\n\t\t\t\tA callout group entry.\n\t\t*/\n\n\t\tstatic function getCalloutGroup($id) {\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_callout_groups WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\tif (!$f) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$f[\"callouts\"] = array_filter((array)json_decode($f[\"callouts\"],true));\n\t\t\treturn $f;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCalloutGroups\n\t\t\t\tReturns a list of callout groups sorted by name.\n\n\t\t\tReturns:\n\t\t\t\tAn array of callout group entries from bigtree_callout_groups.\n\t\t*/\n\n\t\tstatic function getCalloutGroups() {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_callout_groups ORDER BY name ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"callouts\"] = json_decode($f[\"callouts\"]);\n\t\t\t\t$items[$f[\"id\"]] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCallouts\n\t\t\t\tReturns a list of callouts.\n\n\t\t\tParameters:\n\t\t\t\tsort - The order to return the callouts. Defaults to positioned.\n\n\t\t\tReturns:\n\t\t\t\tAn array of callout entries from bigtree_callouts.\n\t\t*/\n\n\t\tstatic function getCallouts($sort = \"position DESC, id ASC\") {\n\t\t\t$callouts = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_callouts ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$callouts[] = $f;\n\t\t\t}\n\t\t\treturn $callouts;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCalloutsAllowed\n\t\t\t\tReturns a list of callouts the logged-in user is allowed access to.\n\n\t\t\tParameters:\n\t\t\t\tsort - The order to return the callouts. Defaults to positioned.\n\n\t\t\tReturns:\n\t\t\t\tAn array of callout entries from bigtree_callouts.\n\t\t*/\n\n\t\tfunction getCalloutsAllowed($sort = \"position DESC, id ASC\") {\n\t\t\t$callouts = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_callouts WHERE level <= '\".$this->Level.\"' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$callouts[] = $f;\n\t\t\t}\n\t\t\treturn $callouts;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCalloutsInGroups\n\t\t\t\tReturns a list of callouts in a given set of groups.\n\n\t\t\tParameters:\n\t\t\t\tgroups - An array of group IDs to retrieve callouts for.\n\t\t\t\tauth - If set to true, only returns callouts the logged in user has access to. Defaults to true.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from the bigtree_callouts table.\n\t\t*/\n\n\t\tfunction getCalloutsInGroups($groups,$auth = true) {\n\t\t\t$ids = array();\n\t\t\t$items = array();\n\t\t\t$names = array();\n\n\t\t\tforeach ($groups as $group_id) {\n\t\t\t\t$group = $this->getCalloutGroup($group_id);\n\t\t\t\tif (!$group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tforeach ($group[\"callouts\"] as $callout_id) {\n\t\t\t\t\tif (!in_array($callout_id,$ids)) {\n\t\t\t\t\t\t$callout = $this->getCallout($callout_id);\n\t\t\t\t\t\tif (!$auth || $this->Level >= $callout[\"level\"]) {\n\t\t\t\t\t\t\t$items[] = $callout;\n\t\t\t\t\t\t\t$ids[] = $callout_id;\n\t\t\t\t\t\t\t$names[] = $callout[\"name\"];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tarray_multisort($names,$items);\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getChange\n\t\t\t\tGet a pending change.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the pending change.\n\n\t\t\tReturns:\n\t\t\t\tA pending change entry from the bigtree_pending_changes table.\n\t\t*/\n\n\t\tstatic function getChange($id) {\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE id = '$id'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getChangeEditLink\n\t\t\t\tReturns a link to where the item involved in the pending change can be edited.\n\n\t\t\tParameters:\n\t\t\t\tchange - The ID of the change or the change array from the database.\n\n\t\t\tReturns:\n\t\t\t\tA string containing a link to the admin.\n\t\t*/\n\n\t\tstatic function getChangeEditLink($change) {\n\t\t\tglobal $bigtree;\n\n\t\t\tif (!is_array($change)) {\n\t\t\t\t$change = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE id = '$change'\"));\n\t\t\t}\n\n\t\t\tif ($change[\"table\"] == \"bigtree_pages\" && $change[\"item_id\"]) {\n\t\t\t\treturn $bigtree[\"config\"][\"admin_root\"].\"pages/edit/\".$change[\"item_id\"].\"/\";\n\t\t\t}\n\n\t\t\tif ($change[\"table\"] == \"bigtree_pages\") {\n\t\t\t\treturn $bigtree[\"config\"][\"admin_root\"].\"pages/edit/p\".$change[\"id\"].\"/\";\n\t\t\t}\n\n\t\t\t$modid = $change[\"module\"];\n\t\t\t$module = sqlfetch(sqlquery(\"SELECT * FROM bigtree_modules WHERE id = '$modid'\"));\n\t\t\t$form = sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_forms WHERE `table` = '\".$change[\"table\"].\"'\"));\n\t\t\t$action = sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE `form` = '\".$form[\"id\"].\"' AND in_nav = ''\"));\n\n\t\t\tif (!$change[\"item_id\"]) {\n\t\t\t\t$change[\"item_id\"] = \"p\".$change[\"id\"];\n\t\t\t}\n\n\t\t\tif ($action) {\n\t\t\t\treturn $bigtree[\"config\"][\"admin_root\"].$module[\"route\"].\"/\".$action[\"route\"].\"/\".$change[\"item_id\"].\"/\";\n\t\t\t} else {\n\t\t\t\treturn $bigtree[\"config\"][\"admin_root\"].$module[\"route\"].\"/edit/\".$change[\"item_id\"].\"/\";\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getContentAlerts\n\t\t\t\tGets a list of pages with content older than their Max Content Age that a user follows.\n\n\t\t\tParameters:\n\t\t\t\tuser - The user id to pull alerts for or a user entry (defaults to the logged in user)\n\n\t\t\tReturns:\n\t\t\t\tAn array of arrays containing a page title, path, and id.\n\t\t*/\n\n\t\tfunction getContentAlerts($user = false) {\n\t\t\tif (is_array($user)) {\n\t\t\t\t$user = static::getUser($user[\"id\"]);\n\t\t\t} elseif ($user) {\n\t\t\t\t$user = static::getUser($user);\n\t\t\t} else {\n\t\t\t\t$user = static::getUser($this->ID);\n\t\t\t}\n\n\t\t\tif (!is_array($user[\"alerts\"])) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$alerts = array();\n\t\t\t// We're going to generate a list of pages the user cares about first to get their paths.\n\t\t\t$where = array();\n\t\t\tforeach ($user[\"alerts\"] as $alert => $status) {\n\t\t\t\t$where[] = \"id = '\".sqlescape($alert).\"'\";\n\t\t\t}\n\t\t\tif (!count($where)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If we care about the whole tree, skip the madness.\n\t\t\tif ($user[\"alerts\"][0] == \"on\") {\n\t\t\t\t$q = sqlquery(\"SELECT nav_title,id,path,updated_at,DATEDIFF('\".date(\"Y-m-d\").\"',updated_at) AS current_age FROM bigtree_pages WHERE max_age > 0 AND DATEDIFF('\".date(\"Y-m-d\").\"',updated_at) > max_age ORDER BY current_age DESC\");\n\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t$alerts[] = $f;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$paths = array();\n\t\t\t\t$q = sqlquery(\"SELECT path FROM bigtree_pages WHERE \".implode(\" OR \",$where));\n\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t$paths[] = \"path = '\".sqlescape($f[\"path\"]).\"' OR path LIKE '\".sqlescape($f[\"path\"]).\"/%'\";\n\t\t\t\t}\n\t\t\t\tif (count($paths)) {\n\t\t\t\t\t// Find all the pages that are old that contain our paths\n\t\t\t\t\t$q = sqlquery(\"SELECT nav_title,id,path,updated_at,DATEDIFF('\".date(\"Y-m-d\").\"',updated_at) AS current_age FROM bigtree_pages WHERE max_age > 0 AND (\".implode(\" OR \",$paths).\") AND DATEDIFF('\".date(\"Y-m-d\").\"',updated_at) > max_age ORDER BY current_age DESC\");\n\t\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t\t$alerts[] = $f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $alerts;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getExtension\n\t\t\t\tReturns information about a package or extension.\n\n\t\t\tParameters:\n\t\t\t\tid - The package/extension ID.\n\n\t\t\tReturns:\n\t\t\t\tA package/extension.\n\t\t*/\n\t\t\n\t\tstatic function getExtension($id) {\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_extensions WHERE id = '\".sqlescape($id).\"'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getExtensions\n\t\t\t\tReturns a list of installed/created extensions.\n\n\t\t\tParameters:\n\t\t\t\tsort - Column/direction to sort (defaults to last_updated DESC)\n\n\t\t\tReturns:\n\t\t\t\tAn array of extensions.\n\t\t*/\n\t\t\n\t\tstatic function getExtensions($sort = \"last_updated DESC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_extensions WHERE type = 'extension' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getFeeds\n\t\t\t\tReturns a list of feeds.\n\n\t\t\tParameters:\n\t\t\t\tsort - The sort direction, defaults to name.\n\n\t\t\tReturns:\n\t\t\t\tAn array of feed elements from bigtree_feeds sorted by name.\n\t\t*/\n\n\t\tstatic function getFeeds($sort = \"name ASC\") {\n\t\t\t$feeds = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_feeds ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$feeds[] = $f;\n\t\t\t}\n\t\t\treturn $feeds;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getFieldType\n\t\t\t\tReturns a field type.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the file type.\n\n\t\t\tReturns:\n\t\t\t\tA field type entry with the \"files\" column decoded.\n\t\t*/\n\n\t\tstatic function getFieldType($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_field_types WHERE id = '$id'\"));\n\t\t\tif (!$item) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$item[\"use_cases\"] = json_decode($item[\"use_cases\"],true);\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getFieldTypes\n\t\t\t\tReturns a list of field types.\n\n\t\t\tParameters:\n\t\t\t\tsort - The sort directon, defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_field_types.\n\t\t*/\n\n\t\tstatic function getFieldTypes($sort = \"name ASC\") {\n\t\t\t$types = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_field_types ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$types[] = $f;\n\t\t\t}\n\t\t\treturn $types;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getFullNavigationPath\n\t\t\t\tCalculates the full navigation path for a given page ID.\n\n\t\t\tParameters:\n\t\t\t\tid - The page ID to calculate the navigation path for.\n\n\t\t\tReturns:\n\t\t\t\tThe navigation path (normally found in the \"path\" column in bigtree_pages).\n\t\t*/\n\n\t\tstatic function getFullNavigationPath($id, $path = array()) {\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT route,id,parent FROM bigtree_pages WHERE id = '$id'\"));\n\t\t\t$path[] = BigTreeCMS::urlify($f[\"route\"]);\n\t\t\tif ($f[\"parent\"] != 0) {\n\t\t\t\treturn static::getFullNavigationPath($f[\"parent\"],$path);\n\t\t\t}\n\t\t\t$path = implode(\"/\",array_reverse($path));\n\t\t\treturn $path;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getHiddenNavigationByParent\n\t\t\t\tReturns an alphabetic list of navigation that is hidden under the given parent.\n\n\t\t\tParameters:\n\t\t\t\tparent - The ID of the parent page\n\n\t\t\tReturns:\n\t\t\t\tAn array of page entries.\n\t\t*/\n\n\t\tstatic function getHiddenNavigationByParent($parent) {\n\t\t\t$nav = array();\n\t\t\t$q = sqlquery(\"SELECT id,nav_title as title,parent,external,new_window,template,publish_at,expire_at,path,ga_page_views FROM bigtree_pages WHERE parent = '$parent' AND in_nav = '' AND archived != 'on' ORDER BY nav_title asc\");\n\t\t\twhile ($nav_item = sqlfetch($q)) {\n\t\t\t\t$nav_item[\"external\"] = BigTreeCMS::replaceRelativeRoots($nav_item[\"external\"]);\n\t\t\t\t$nav[] = $nav_item;\n\t\t\t}\n\t\t\treturn $nav;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getMessage\n\t\t\t\tReturns a message from message center.\n\t\t\t\tVerifies that the user calling this method is either the sender or a recipient.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the message.\n\n\t\t\tReturns:\n\t\t\t\tAn entry from bigtree_messages.\n\t\t*/\n\n\t\tfunction getMessage($id) {\n\t\t\t$message = sqlfetch(sqlquery(\"SELECT * FROM bigtree_messages WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\tif (!$message) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($message[\"sender\"] != $this->ID && strpos($message[\"recipients\"],\"|\".$this->ID.\"|\") === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn $message;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getMessageChain\n\t\t\t\tGets a full chain of messages based on one ID in the chain\n\n\t\t\tParameters:\n\t\t\t\tid - The ID of one message in the chain.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_messages with the message entry that was requested having the \"selected\" column set.\n\t\t*/\n\n\t\tfunction getMessageChain($id) {\n\t\t\t$message = $m = $this->getMessage($id);\n\t\t\t$message[\"selected\"] = true;\n\t\t\tif (!$message) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$chain = array($message);\n\n\t\t\t// Find parents\n\t\t\twhile ($m[\"response_to\"]) {\n\t\t\t\t$m = $this->getMessage($m[\"response_to\"]);\n\t\t\t\t// Prepend this message to the chain\n\t\t\t\t$chain = array_merge(array($m),$chain);\n\t\t\t}\n\n\t\t\t// Find children\n\t\t\t$m = $message;\n\t\t\twhile ($f = sqlfetch(sqlquery(\"SELECT id FROM bigtree_messages WHERE response_to = '\".$m[\"id\"].\"'\"))) {\n\t\t\t\t$m = $this->getMessage($f[\"id\"]);\n\t\t\t\t$chain[] = $m;\n\t\t\t}\n\n\t\t\treturn $chain;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getMessages\n\t\t\t\tReturns all a user's messages.\n\n\t\t\tParameters:\n\t\t\t\tuser - Optional user ID (defaults to logged in user)\n\n\t\t\tReturns:\n\t\t\t\tAn array containing \"sent\", \"read\", and \"unread\" keys that contain an array of messages each.\n\t\t*/\n\n\t\tfunction getMessages($user = false) {\n\t\t\tif ($user) {\n\t\t\t\t$user = sqlescape($user);\n\t\t\t} else {\n\t\t\t\t$user = $this->ID;\n\t\t\t}\n\t\t\t$sent = array();\n\t\t\t$read = array();\n\t\t\t$unread = array();\n\t\t\t$q = sqlquery(\"SELECT bigtree_messages.*, bigtree_users.name AS sender_name, bigtree_users.email AS sender_email FROM bigtree_messages JOIN bigtree_users ON bigtree_messages.sender = bigtree_users.id WHERE sender = '$user' OR recipients LIKE '%|$user|%' ORDER BY date DESC\");\n\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t// If we're the sender put it in the sent array.\n\t\t\t\tif ($f[\"sender\"] == $user) {\n\t\t\t\t\t$sent[] = $f;\n\t\t\t\t} else {\n\t\t\t\t\t// If we've been marked read, put it in the read array.\n\t\t\t\t\tif ($f[\"read_by\"] && strpos($f[\"read_by\"],\"|\".$user.\"|\") !== false) {\n\t\t\t\t\t\t$read[] = $f;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$unread[] = $f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array(\"sent\" => $sent, \"read\" => $read, \"unread\" => $unread);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModule\n\t\t\t\tReturns an entry from the bigtree_modules table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module.\n\n\t\t\tReturns:\n\t\t\t\tA module entry with the \"gbp\" column decoded.\n\t\t*/\n\n\t\tstatic function getModule($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$module = sqlfetch(sqlquery(\"SELECT * FROM bigtree_modules WHERE id = '$id'\"));\n\t\t\tif (!$module) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$module[\"gbp\"] = json_decode($module[\"gbp\"],true);\n\t\t\treturn $module;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleAction\n\t\t\t\tReturns an entry from the bigtree_module_actions table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the action.\n\n\t\t\tReturns:\n\t\t\t\tA module action entry.\n\t\t*/\n\n\t\tstatic function getModuleAction($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE id = '$id'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleActionByRoute\n\t\t\t\tReturns an entry from the bigtree_module_actions table for the given module and route.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module to lookup an action for.\n\t\t\t\troute - The route of the action.\n\n\t\t\tReturns:\n\t\t\t\tA module action entry.\n\t\t*/\n\n\t\tstatic function getModuleActionByRoute($module,$route) {\n\t\t\t// For landing routes.\n\t\t\tif (!count($route)) {\n\t\t\t\t$route = array(\"\");\n\t\t\t}\n\t\t\t$module = sqlescape($module);\n\t\t\t$commands = array();\n\t\t\t$action = false;\n\t\t\twhile (count($route) && !$action) {\n\t\t\t\t$route_string = sqlescape(implode(\"/\",$route));\n\t\t\t\t$action = sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '$module' AND route = '$route_string'\"));\n\t\t\t\tif ($action) {\n\t\t\t\t\treturn array(\"action\" => $action, \"commands\" => array_reverse($commands));\n\t\t\t\t}\n\t\t\t\t$commands[] = end($route);\n\t\t\t\t$route = array_slice($route,0,-1);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleActionForForm\n\t\t\t\tReturns the related module action for an auto module form. Prioritizes edit action over add.\n\n\t\t\tParameters:\n\t\t\t\tform - The id of a form or a form entry.\n\n\t\t\tReturns:\n\t\t\t\tA module action entry.\n\t\t*/\n\n\t\tstatic function getModuleActionForForm($form) {\n\t\t\tif (is_array($form)) {\n\t\t\t\t$form = sqlescape($form[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$form = sqlescape($form);\n\t\t\t}\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE form = '$form' ORDER BY route DESC\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleActionForReport\n\t\t\t\tReturns the related module action for an auto module report.\n\n\t\t\tParameters:\n\t\t\t\treport - The id of a report or a report entry.\n\n\t\t\tReturns:\n\t\t\t\tA module action entry.\n\t\t*/\n\n\t\tstatic function getModuleActionForReport($report) {\n\t\t\tif (is_array($report)) {\n\t\t\t\t$report = sqlescape($report[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$report = sqlescape($report);\n\t\t\t}\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE report = '$report'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleActionForView\n\t\t\t\tReturns the related module action for an auto module view.\n\n\t\t\tParameters:\n\t\t\t\tview - The id of a view or a view entry.\n\n\t\t\tReturns:\n\t\t\t\tA module action entry.\n\t\t*/\n\n\t\tstatic function getModuleActionForView($view) {\n\t\t\tif (is_array($view)) {\n\t\t\t\t$view = sqlescape($view[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$view = sqlescape($view);\n\t\t\t}\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE view = '$view'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleActions\n\t\t\t\tReturns a list of module actions in positioned order.\n\n\t\t\tParameters:\n\t\t\t\tmodule - A module id or a module entry.\n\n\t\t\tReturns:\n\t\t\t\tAn array of module action entries.\n\t\t*/\n\n\t\tstatic function getModuleActions($module) {\n\t\t\tif (is_array($module)) {\n\t\t\t\t$module = sqlescape($module[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$module = sqlescape($module);\n\t\t\t}\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '$module' ORDER BY position DESC, id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleByClass\n\t\t\t\tReturns a module entry for the given class name.\n\n\t\t\tParameters:\n\t\t\t\tclass - A module class.\n\n\t\t\tReturns:\n\t\t\t\tA module entry with the \"gbp\" column decoded or false if a module was not found.\n\t\t*/\n\n\t\tstatic function getModuleByClass($class) {\n\t\t\t$class = sqlescape($class);\n\t\t\t$module = sqlfetch(sqlquery(\"SELECT * FROM bigtree_modules WHERE class = '$class'\"));\n\t\t\tif (!$module) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$module[\"gbp\"] = json_decode($module[\"gbp\"],true);\n\t\t\treturn $module;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleByRoute\n\t\t\t\tReturns a module entry for the given route.\n\n\t\t\tParameters:\n\t\t\t\troute - A module route.\n\n\t\t\tReturns:\n\t\t\t\tA module entry with the \"gbp\" column decoded or false if a module was not found.\n\t\t*/\n\n\t\tstatic function getModuleByRoute($route) {\n\t\t\t$route = sqlescape($route);\n\t\t\t$module = sqlfetch(sqlquery(\"SELECT * FROM bigtree_modules WHERE route = '$route'\"));\n\t\t\tif (!$module) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$module[\"gbp\"] = json_decode($module[\"gbp\"],true);\n\t\t\treturn $module;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleEmbedForms\n\t\t\t\tGets forms from bigtree_module_embeds with fields decoded.\n\n\t\t\tParameters:\n\t\t\t\tsort - The field to sort by.\n\t\t\t\tmodule - Specific module to pull forms for (defaults to all modules).\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_module_embeds with \"fields\" decoded.\n\t\t*/\n\n\t\tstatic function getModuleEmbedForms($sort = \"title\",$module = false) {\n\t\t\t$items = array();\n\t\t\tif ($module) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_embeds WHERE module = '\".sqlescape($module).\"' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_embeds ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"fields\"] = json_decode($f[\"fields\"],true);\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleForms\n\t\t\t\tGets forms from bigtree_module_forms with fields decoded.\n\n\t\t\tParameters:\n\t\t\t\tsort - The field to sort by.\n\t\t\t\tmodule - Specific module to pull forms for (defaults to all modules).\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_module_forms with \"fields\" decoded.\n\t\t*/\n\n\t\tstatic function getModuleForms($sort = \"title\",$module = false) {\n\t\t\t$items = array();\n\t\t\tif ($module) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_forms WHERE module = '\".sqlescape($module).\"' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_forms ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"fields\"] = json_decode($f[\"fields\"],true);\n\t\t\t\t$f[\"hooks\"] = json_decode($f[\"hooks\"],true);\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleGroup\n\t\t\t\tReturns a module group entry from the bigtree_module_groups table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module group.\n\n\t\t\tReturns:\n\t\t\t\tA module group entry.\n\n\t\t\tSee Also:\n\t\t\t\t<getModuleGroupByName>\n\t\t\t\t<getModuleGroupByRoute>\n\t\t*/\n\n\t\tstatic function getModuleGroup($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_groups WHERE id = '$id'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleGroupByName\n\t\t\t\tReturns a module group entry from the bigtree_module_groups table.\n\n\t\t\tParameters:\n\t\t\t\tname - The name of the module group.\n\n\t\t\tReturns:\n\t\t\t\tA module group entry.\n\n\t\t\tSee Also:\n\t\t\t\t<getModuleGroup>\n\t\t\t\t<getModuleGroupByRoute>\n\t\t*/\n\n\n\t\tstatic function getModuleGroupByName($name) {\n\t\t\t$name = sqlescape(strtolower($name));\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_groups WHERE LOWER(name) = '$name'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleGroupByRoute\n\t\t\t\tReturns a module group entry from the bigtree_module_groups table.\n\n\t\t\tParameters:\n\t\t\t\troute - The route of the module group.\n\n\t\t\tReturns:\n\t\t\t\tA module group entry.\n\n\t\t\tSee Also:\n\t\t\t\t<getModuleGroup>\n\t\t\t\t<getModuleGroupByName>\n\t\t*/\n\n\t\tstatic function getModuleGroupByRoute($route) {\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_groups WHERE route = '\".sqlescape($route).\"'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleGroups\n\t\t\t\tReturns a list of module groups.\n\n\t\t\tParameters:\n\t\t\t\tsort - Sort by (defaults to positioned)\n\n\t\t\tReturns:\n\t\t\t\tAn array of module group entries from bigtree_module_groups.\n\t\t*/\n\n\t\tstatic function getModuleGroups($sort = \"position DESC, id ASC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_groups ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[$f[\"id\"]] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleNavigation\n\t\t\t\tReturns a list of module actions that are in navigation.\n\n\t\t\tParameters:\n\t\t\t\tmodule - A module id or a module entry.\n\n\t\t\tReturns:\n\t\t\t\tAn array of module actions from bigtree_module_actions.\n\t\t*/\n\n\t\tstatic function getModuleNavigation($module) {\n\t\t\tif (is_array($module)) {\n\t\t\t\t$module = sqlescape($module[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$module = sqlescape($module);\n\t\t\t}\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '$module' AND in_nav = 'on' ORDER BY position DESC, id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleReports\n\t\t\t\tGets reports from the bigtree_module_reports table.\n\n\t\t\tParameters:\n\t\t\t\tsort - The field to sort by.\n\t\t\t\tmodule - Specific module to pull reports for (defaults to all modules).\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_module_reports.\n\t\t*/\n\n\t\tstatic function getModuleReports($sort = \"title\",$module = false) {\n\t\t\t$items = array();\n\t\t\tif ($module) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_reports WHERE module = '\".sqlescape($module).\"' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_reports ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"fields\"] = json_decode($f[\"fields\"],true);\n\t\t\t\t$f[\"filters\"] = json_decode($f[\"filters\"],true);\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModules\n\t\t\t\tReturns a list of modules.\n\n\t\t\tParameters:\n\t\t\t\tsort - The sort order (defaults to oldest first).\n\t\t\t\tauth - If set to true, only returns modules the logged in user has access to. Defaults to true.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from the bigtree_modules table with an additional \"group_name\" column for the group the module is in.\n\t\t*/\n\n\t\tfunction getModules($sort = \"id ASC\",$auth = true) {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT bigtree_modules.*,bigtree_module_groups.name AS group_name FROM bigtree_modules LEFT JOIN bigtree_module_groups ON bigtree_modules.`group` = bigtree_module_groups.id ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif (!$auth || $this->checkAccess($f[\"id\"])) {\n\t\t\t\t\t$items[$f[\"id\"]] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModulesByGroup\n\t\t\t\tReturns a list of modules in a given group.\n\n\t\t\tParameters:\n\t\t\t\tgroup - The group to return modules for.\n\t\t\t\tsort - The sort order (defaults to positioned)\n\t\t\t\tauth - If set to true, only returns modules the logged in user has access to. Defaults to true.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from the bigtree_modules table.\n\t\t*/\n\n\t\tfunction getModulesByGroup($group,$sort = \"position DESC, id ASC\",$auth = true) {\n\t\t\tif (is_array($group)) {\n\t\t\t\t$group = sqlescape($group[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$group = sqlescape($group);\n\t\t\t}\n\t\t\t$items = array();\n\t\t\tif ($group) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_modules WHERE `group` = '$group' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_modules WHERE `group` = 0 OR `group` IS NULL ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($this->checkAccess($f[\"id\"]) || !$auth) {\n\t\t\t\t\t$items[$f[\"id\"]] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleViews\n\t\t\t\tReturns a list of all entries in the bigtree_module_views table.\n\n\t\t\tParameters:\n\t\t\t\tsort - The column to sort by.\n\t\t\t\tmodule - Specific module to pull views for (defaults to all modules).\n\n\t\t\tReturns:\n\t\t\t\tAn array of view entries with \"fields\" decoded.\n\t\t*/\n\n\t\tstatic function getModuleViews($sort = \"title\",$module = false) {\n\t\t\t$items = array();\n\t\t\tif ($module !== false) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_views WHERE module = '\".sqlescape($module).\"' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_views ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($view = sqlfetch($q)) {\n\t\t\t\t$view[\"fields\"] = json_decode($view[\"fields\"],true);\n\t\t\t\t$view[\"actions\"] = json_decode($view[\"actions\"],true);\n\t\t\t\t$view[\"options\"] = json_decode($view[\"options\"],true);\t\t\n\t\t\t\t$items[] = $view;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getNaturalNavigationByParent\n\t\t\t\tReturns a list of positioned navigation that is in navigation under the given parent.\n\t\t\t\tDoes not return module navigation.\n\n\t\t\tParameters:\n\t\t\t\tparent - The ID of the parent page\n\n\t\t\tReturns:\n\t\t\t\tAn array of page entries.\n\t\t*/\n\n\t\tstatic function getNaturalNavigationByParent($parent,$levels = 1) {\n\t\t\t$nav = array();\n\t\t\t$q = sqlquery(\"SELECT id,nav_title AS title,parent,external,new_window,template,publish_at,expire_at,path,ga_page_views FROM bigtree_pages WHERE parent = '$parent' AND in_nav = 'on' AND archived != 'on' ORDER BY position DESC, id ASC\");\n\t\t\twhile ($nav_item = sqlfetch($q)) {\n\t\t\t\t$nav_item[\"external\"] = BigTreeCMS::replaceRelativeRoots($nav_item[\"external\"]);\n\t\t\t\tif ($levels > 1) {\n\t\t\t\t\t$nav_item[\"children\"] = static::getNaturalNavigationByParent($nav_item[\"id\"],$levels - 1);\n\t\t\t\t}\n\t\t\t\t$nav[] = $nav_item;\n\t\t\t}\n\t\t\treturn $nav;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPackage\n\t\t\t\tReturns information about a package or extension.\n\n\t\t\tParameters:\n\t\t\t\tid - The package/extension ID.\n\n\t\t\tReturns:\n\t\t\t\tA package/extension.\n\t\t*/\n\n\t\tstatic function getPackage($id) {\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_extensions WHERE id = '\".sqlescape($id).\"'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPackages\n\t\t\t\tReturns a list of installed/created packages.\n\n\t\t\tParameters:\n\t\t\t\tsort - Column/direction to sort (defaults to last_updated DESC)\n\n\t\t\tReturns:\n\t\t\t\tAn array of packages.\n\t\t*/\n\n\t\tstatic function getPackages($sort = \"last_updated DESC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_extensions WHERE type = 'package' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageAccessLevel\n\t\t\t\tReturns the access level for the logged in user to a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\n\t\t\tReturns:\n\t\t\t\t\"p\" for publisher, \"e\" for editor, false for no access.\n\n\t\t\tSee Also:\n\t\t\t\t<getPageAccessLevelForUser>\n\t\t*/\n\n\t\tfunction getPageAccessLevel($page) {\n\t\t\treturn $this->getPageAccessLevelByUser($page,$this->ID);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageAccessLevelByUser\n\t\t\t\tReturns the access level for the given user to a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\t\t\t\tuser - The user id.\n\n\t\t\tReturns:\n\t\t\t\t\"p\" for publisher, \"e\" for editor, false for no access.\n\n\t\t\tSee Also:\n\t\t\t\t<getPageAccessLevel>\n\t\t*/\n\n\t\tfunction getPageAccessLevelByUser($page,$user) {\n\t\t\t// See if this is a pending change, if so, grab the change's parent page and check permission levels for that instead.\n\t\t\tif (!is_numeric($page) && $page[0] == \"p\") {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE id = '\".sqlescape(substr($page,1)).\"'\"));\n\t\t\t\t$changes = json_decode($f[\"changes\"],true);\n\t\t\t\treturn $this->getPageAccessLevelByUser($changes[\"parent\"],$user);\n\t\t\t}\n\n\t\t\t// If we're checking the logged in user, just use the info we already have\n\t\t\tif ($user == $this->ID) {\n\t\t\t\t$level = $this->Level;\n\t\t\t\t$permissions = $this->Permissions;\n\t\t\t// Not the logged in user? Look up the person.\n\t\t\t} else {\n\t\t\t\t$u = static::getUser($user);\n\t\t\t\t$level = $u[\"level\"];\n\t\t\t\t$permissions = $u[\"permissions\"];\n\t\t\t}\n\n\t\t\t// See if the user is an administrator, if so we can skip permissions.\n\t\t\tif ($level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\n\t\t\t// See if this page has an explicit permission set and return it if so.\n\t\t\t$explicit_permission = $permissions[\"page\"][$page];\n\t\t\tif ($explicit_permission == \"n\") {\n\t\t\t\treturn false;\n\t\t\t} elseif ($explicit_permission && $explicit_permission != \"i\") {\n\t\t\t\treturn $explicit_permission;\n\t\t\t}\n\n\t\t\t// We're now assuming that this page should inherit permissions from farther up the tree, so let's grab the first parent.\n\t\t\t$page_data = sqlfetch(sqlquery(\"SELECT parent FROM bigtree_pages WHERE id = '\".sqlescape($page).\"'\"));\n\n\t\t\t// Grab the parent's permission. Keep going until we find a permission that isn't inherit or until we hit a parent of 0.\n\t\t\t$parent_permission = $permissions[\"page\"][$page_data[\"parent\"]];\n\t\t\twhile ((!$parent_permission || $parent_permission == \"i\") && $page_data[\"parent\"]) {\n\t\t\t\t$page_data = sqlfetch(sqlquery(\"SELECT parent FROM bigtree_pages WHERE id = '\".$page_data[\"parent\"].\"'\"));\n\t\t\t\t$parent_permission = $permissions[\"page\"][$page_data[\"parent\"]];\n\t\t\t}\n\n\t\t\t// If no permissions are set on the page (we hit page 0 and still nothing) or permission is \"n\", return not allowed.\n\t\t\tif (!$parent_permission || $parent_permission == \"i\" || $parent_permission == \"n\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Return whatever we found.\n\t\t\treturn $parent_permission;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageAdminLinks\n\t\t\t\tGets a list of pages that link back to the admin.\n\n\t\t\tReturns:\n\t\t\t\tAn array of pages that link to the admin.\n\t\t*/\n\n\t\tstatic function getPageAdminLinks() {\n\t\t\tglobal $bigtree;\n\t\t\t$pages = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE REPLACE(resources,'{adminroot}js/embeddable-form.js','') LIKE '%{adminroot}%' OR resources LIKE '%\".$bigtree[\"config\"][\"admin_root\"].\"%' OR resources LIKE '%\".str_replace($bigtree[\"config\"][\"www_root\"],\"{wwwroot}\",$bigtree[\"config\"][\"admin_root\"]).\"%'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$pages[] = $f;\n\t\t\t}\n\t\t\treturn $pages;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageChanges\n\t\t\t\tReturns pending changes for a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\n\t\t\tReturns:\n\t\t\t\tAn entry from bigtree_pending_changes with changes decoded.\n\t\t*/\n\n\t\tstatic function getPageChanges($page) {\n\t\t\t$page = sqlescape($page);\n\t\t\t$c = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND item_id = '$page'\"));\n\t\t\tif (!$c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$c[\"changes\"] = json_decode($c[\"changes\"],true);\n\t\t\treturn $c;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageChildren\n\t\t\t\tReturns all non-archived children of a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id to pull children for.\n\t\t\t\tsort - The way to sort results. Defaults to nav_title ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of pages.\n\t\t*/\n\n\t\tstatic function getPageChildren($page,$sort = \"nav_title ASC\") {\n\t\t\t$page = sqlescape($page);\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE parent = '$page' AND archived != 'on' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageLineage\n\t\t\t\tReturns all the ids of pages above this page.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpage - Page ID\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tArray of IDs\n\t\t*/\n\t\t\n\t\tfunction getPageLineage($page) {\n\t\t\t$parents = array();\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT parent FROM bigtree_pages WHERE id = '\".sqlescape($page).\"'\"));\n\t\t\t$parents[] = $f[\"parent\"];\n\t\t\twhile ($f[\"parent\"]) {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT parent FROM bigtree_pages WHERE id = '\".sqlescape($f[\"parent\"]).\"'\"));\n\t\t\t\tif ($f[\"parent\"]) {\n\t\t\t\t\t$parents[] = $f[\"parent\"];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $parents;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageIds\n\t\t\t\tReturns all the IDs in bigtree_pages for pages that aren't archived.\n\n\t\t\tReturns:\n\t\t\t\tAn array of page ids.\n\t\t*/\n\n\t\tstatic function getPageIds() {\n\t\t\t$ids = array();\n\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_pages WHERE archived != 'on' ORDER BY id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$ids[] = $f[\"id\"];\n\t\t\t}\n\t\t\treturn $ids;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageIDForPath\n\t\t\t\tProvides the page ID for a given path array.\n\t\t\t\tThis is equivalent to BigTreeCMS::getNavId.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpath - An array of path elements from a URL\n\t\t\t\tpreviewing - Whether we are previewing or not.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array containing the page ID and any additional commands.\n\t\t*/\n\t\t\n\t\tstatic function getPageIDForPath($path,$previewing = false) {\n\t\t\t$commands = array();\n\n\t\t\t// Reset array keys\n\t\t\t$path = array_values($path);\n\t\t\t\n\t\t\tif (!$previewing) {\n\t\t\t\t$publish_at = \"AND (publish_at <= NOW() OR publish_at IS NULL) AND (expire_at >= NOW() OR expire_at IS NULL)\";\n\t\t\t} else {\n\t\t\t\t$publish_at = \"\";\n\t\t\t}\n\t\t\t\n\t\t\t// See if we have a straight up perfect match to the path.\n\t\t\t$spath = sqlescape(implode(\"/\",$path));\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT bigtree_pages.id,bigtree_templates.routed FROM bigtree_pages LEFT JOIN bigtree_templates ON bigtree_pages.template = bigtree_templates.id WHERE path = '$spath' AND archived = '' $publish_at\"));\n\t\t\tif ($f) {\n\t\t\t\treturn array($f[\"id\"],$commands,$f[\"routed\"]);\n\t\t\t}\n\t\t\t\n\t\t\t// Guess we don't, let's chop off commands until we find a page.\n\t\t\t$x = 0;\n\t\t\twhile ($x < count($path)) {\n\t\t\t\t$x++;\n\t\t\t\t$commands[] = $path[count($path)-$x];\n\t\t\t\t$spath = sqlescape(implode(\"/\",array_slice($path,0,-1 * $x)));\n\t\t\t\t// We have additional commands, so we're now making sure the template is also routed, otherwise it's a 404.\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT bigtree_pages.id FROM bigtree_pages JOIN bigtree_templates ON bigtree_pages.template = bigtree_templates.id WHERE bigtree_pages.path = '$spath' AND bigtree_pages.archived = '' AND bigtree_templates.routed = 'on' $publish_at\"));\n\t\t\t\tif ($f) {\n\t\t\t\t\treturn array($f[\"id\"],array_reverse($commands),\"on\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn array(false,false,false);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageOfSettings\n\t\t\t\tReturns a page of settings the logged in user has access to.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page to return.\n\t\t\t\tquery - Optional query string to search against.\n\t\t\t\tsort - Sort order. Defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_settings.\n\t\t\t\tIf the setting is encrypted the value will be \"[Encrypted Text]\", otherwise it will be decoded.\n\t\t\t\tIf the calling user is a developer, returns locked settings, otherwise they are left out.\n\t\t*/\n\n\t\tfunction getPageOfSettings($page = 1,$query = \"\") {\n\t\t\t// If we're querying...\n\t\t\tif ($query) {\n\t\t\t\t$qparts = explode(\" \",$query);\n\t\t\t\t$qp = array();\n\t\t\t\tforeach ($qparts as $part) {\n\t\t\t\t\t$part = sqlescape(strtolower($part));\n\t\t\t\t\t$qp[] = \"(LOWER(name) LIKE '%$part%' OR LOWER(`value`) LIKE '%$part%')\";\n\t\t\t\t}\n\t\t\t\t// If we're not a developer, leave out locked settings\n\t\t\t\tif ($this->Level < 2) {\n\t\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE \".implode(\" AND \",$qp).\" AND locked = '' AND system = '' ORDER BY name LIMIT \".(($page - 1) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t\t// If we are a developer, show them.\n\t\t\t\t} else {\n\t\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE \".implode(\" AND \",$qp).\" AND system = '' ORDER BY name LIMIT \".(($page - 1) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If we're not a developer, leave out locked settings\n\t\t\t\tif ($this->Level < 2) {\n\t\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE locked = '' AND system = '' ORDER BY name LIMIT \".(($page - 1) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t\t// If we are a developer, show them.\n\t\t\t\t} else {\n\t\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE system = '' ORDER BY name LIMIT \".(($page - 1 ) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$items = array();\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"value\"] = json_decode($f[\"value\"],true);\n\t\t\t\tif (is_array($f[\"value\"])) {\n\t\t\t\t\t$f[\"value\"] = BigTree::untranslateArray($f[\"value\"]);\n\t\t\t\t} else {\n\t\t\t\t\t$f[\"value\"] = BigTreeCMS::replaceInternalPageLinks($f[\"value\"]);\n\t\t\t\t}\n\t\t\t\t$f[\"description\"] = BigTreeCMS::replaceInternalPageLinks($f[\"description\"]);\n\t\t\t\tif ($f[\"encrypted\"]) {\n\t\t\t\t\t$f[\"value\"] = \"[Encrypted Text]\";\n\t\t\t\t}\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageOfUsers\n\t\t\t\tReturns a page of users.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page of users to return.\n\t\t\t\tquery - Optional query string to search against.\n\t\t\t\tsort - Order to sort the results by. Defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_users.\n\t\t*/\n\n\t\tstatic function getPageOfUsers($page = 1,$query = \"\",$sort = \"name ASC\") {\n\t\t\t// If we're searching.\n\t\t\tif ($query) {\n\t\t\t\t$qparts = explode(\" \",$query);\n\t\t\t\t$qp = array();\n\t\t\t\tforeach ($qparts as $part) {\n\t\t\t\t\t$part = sqlescape(strtolower($part));\n\t\t\t\t\t$qp[] = \"(LOWER(name) LIKE '%$part%' OR LOWER(email) LIKE '%$part%' OR LOWER(company) LIKE '%$part%')\";\n\t\t\t\t}\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_users WHERE \".implode(\" AND \",$qp).\" ORDER BY $sort LIMIT \".(($page - 1) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t// If we're grabbing anyone.\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_users ORDER BY $sort LIMIT \".(($page - 1) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t}\n\n\t\t\t$items = array();\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageRevision\n\t\t\t\tReturns a version of a page from the bigtree_page_revisions table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the page version.\n\n\t\t\tReturns:\n\t\t\t\tA page version entry from the table.\n\t\t*/\n\n\t\tstatic function getPageRevision($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_page_revisions WHERE id = '$id'\"));\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageRevisions\n\t\t\t\tGet all revisions for a page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id to get revisions for.\n\n\t\t\tReturns:\n\t\t\t\tAn array of \"saved\" revisions and \"unsaved\" revisions.\n\t\t*/\n\n\t\tstatic function getPageRevisions($page) {\n\t\t\t$page = sqlescape($page);\n\n\t\t\t// Get all previous revisions, add them to the saved or unsaved list\n\t\t\t$unsaved = array();\n\t\t\t$saved = array();\n\t\t\t$q = sqlquery(\"SELECT bigtree_users.name, bigtree_users.email, bigtree_page_revisions.saved, bigtree_page_revisions.saved_description, bigtree_page_revisions.updated_at, bigtree_page_revisions.id FROM bigtree_page_revisions JOIN bigtree_users ON bigtree_page_revisions.author = bigtree_users.id WHERE page = '$page' ORDER BY updated_at DESC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($f[\"saved\"]) {\n\t\t\t\t\t$saved[] = $f;\n\t\t\t\t} else {\n\t\t\t\t\t$unsaved[] = $f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array(\"saved\" => $saved, \"unsaved\" => $unsaved);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPages\n\t\t\t\tReturns all pages from the database.\n\n\t\t\tReturns:\n\t\t\t\tArray of unmodified entries from bigtree_pages.\n\t\t*/\n\n\t\tstatic function getPages() {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages ORDER BY id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageSEORating\n\t\t\t\tReturns the SEO rating for a page.\n\n\t\t\tParameters:\n\t\t\t\tpage - A page array.\n\t\t\t\tcontent - An array of resources.\n\n\t\t\tReturns:\n\t\t\t\tAn array of SEO data.\n\t\t\t\t\"score\" reflects a score from 0 to 100 points.\n\t\t\t\t\"recommendations\" is an array of recommendations to improve SEO score.\n\t\t\t\t\"color\" is a color reflecting the SEO score.\n\n\t\t\t\tScore Parameters\n\t\t\t\t- Having a title - 5 points\n\t\t\t\t- Having a unique title - 5 points\n\t\t\t\t- Title does not exceed 72 characters and has at least 4 words - 5 points\n\t\t\t\t- Having a meta description - 5 points\n\t\t\t\t- Meta description that is less than 165 characters - 5 points\n\t\t\t\t- Having an h1 - 10 points\n\t\t\t\t- Having page content - 5 points\n\t\t\t\t- Having at least 300 words in your content - 15 points\n\t\t\t\t- Having links in your content - 5 points\n\t\t\t\t- Having external links in your content - 5 points\n\t\t\t\t- Having one link for every 120 words of content - 5 points\n\t\t\t\t- Readability Score - up to 20 points\n\t\t\t\t- Fresh content - up to 10 points\n\t\t*/\n\n\t\tstatic function getPageSEORating($page,$content) {\n\t\t\t$template = BigTreeCMS::getTemplate($page[\"template\"]);\n\t\t\t$tsources = array();\n\t\t\t$h1_field = \"\";\n\t\t\t$body_fields = array();\n\n\t\t\tif (is_array($template[\"resources\"])) {\n\t\t\t\tforeach ($template[\"resources\"] as $item) {\n\t\t\t\t\tif (isset($item[\"seo_body\"]) && $item[\"seo_body\"]) {\n\t\t\t\t\t\t$body_fields[] = $item[\"id\"];\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($item[\"seo_h1\"]) && $item[\"seo_h1\"]) {\n\t\t\t\t\t\t$h1_field = $item[\"id\"];\n\t\t\t\t\t}\n\t\t\t\t\t$tsources[$item[\"id\"]] = $item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$h1_field && $tsources[\"page_header\"]) {\n\t\t\t\t$h1_field = \"page_header\";\n\t\t\t}\n\t\t\tif (!count($body_fields) && $tsources[\"page_content\"]) {\n\t\t\t\t$body_fields[] = \"page_content\";\n\t\t\t}\n\n\t\t\t$textStats = new TextStatistics;\n\t\t\t$recommendations = array();\n\n\t\t\t$score = 0;\n\n\t\t\t// Check if they have a page title.\n\t\t\tif ($page[\"title\"]) {\n\t\t\t\t$score += 5;\n\t\t\t\t// They have a title, let's see if it's unique\n\t\t\t\t$r = sqlrows(sqlquery(\"SELECT * FROM bigtree_pages WHERE title = '\".sqlescape($page[\"title\"]).\"' AND id != '\".sqlescape($page[\"id\"]).\"'\"));\n\t\t\t\tif ($r == 0) {\n\t\t\t\t\t// They have a unique title\n\t\t\t\t\t$score += 5;\n\t\t\t\t} else {\n\t\t\t\t\t$recommendations[] = \"Your page title should be unique. \".($r-1).\" other page(s) have the same title.\";\n\t\t\t\t}\n\t\t\t\t$words = $textStats->word_count($page[\"title\"]);\n\t\t\t\t$length = mb_strlen($page[\"title\"]);\n\t\t\t\tif ($words >= 4 && $length <= 72) {\n\t\t\t\t\t// Fits the bill!\n\t\t\t\t\t$score += 5;\n\t\t\t\t} else {\n\t\t\t\t\t$recommendations[] = \"Your page title should be no more than 72 characters and should contain at least 4 words.\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$recommendations[] = \"You should enter a page title.\";\n\t\t\t}\n\n\t\t\t// Check for meta description\n\t\t\tif ($page[\"meta_description\"]) {\n\t\t\t\t$score += 5;\n\t\t\t\t// They have a meta description, let's see if it's no more than 165 characters.\n\t\t\t\tif (mb_strlen($page[\"meta_description\"]) <= 165) {\n\t\t\t\t\t$score += 5;\n\t\t\t\t} else {\n\t\t\t\t\t$recommendations[] = \"Your meta description should be no more than 165 characters. It is currently \".mb_strlen($page[\"meta_description\"]).\" characters.\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$recommendations[] = \"You should enter a meta description.\";\n\t\t\t}\n\n\t\t\t// Check for an H1\n\t\t\tif (!$h1_field || $content[$h1_field]) {\n\t\t\t\t$score += 10;\n\t\t\t} else {\n\t\t\t\t$recommendations[] = \"You should enter a page header.\";\n\t\t\t}\n\t\t\t// Check the content!\n\t\t\tif (!count($body_fields)) {\n\t\t\t\t// If this template doesn't for some reason have a seo body resource, give the benefit of the doubt.\n\t\t\t\t$score += 65;\n\t\t\t} else {\n\t\t\t\t$regular_text = \"\";\n\t\t\t\t$stripped_text = \"\";\n\t\t\t\tforeach ($body_fields as $field) {\n\t\t\t\t\tif (!is_array($content[$field])) {\n\t\t\t\t\t\t$regular_text .= $content[$field].\" \";\n\t\t\t\t\t\t$stripped_text .= strip_tags($content[$field]).\" \";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Check to see if there is any content\n\t\t\t\tif ($stripped_text) {\n\t\t\t\t\t$score += 5;\n\t\t\t\t\t$words = $textStats->word_count($stripped_text);\n\t\t\t\t\t$readability = $textStats->flesch_kincaid_reading_ease($stripped_text);\n\t\t\t\t\tif ($readability < 0) {\n\t\t\t\t\t\t$readability = 0;\n\t\t\t\t\t}\n\t\t\t\t\t$number_of_links = substr_count($regular_text,\"<a \");\n\t\t\t\t\t$number_of_external_links = substr_count($regular_text,'href=\"http://');\n\n\t\t\t\t\t// See if there are at least 300 words.\n\t\t\t\t\tif ($words >= 300) {\n\t\t\t\t\t\t$score += 15;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$recommendations[] = \"You should enter at least 300 words of page content. You currently have \".$words.\" word(s).\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// See if we have any links\n\t\t\t\t\tif ($number_of_links) {\n\t\t\t\t\t\t$score += 5;\n\t\t\t\t\t\t// See if we have at least one link per 120 words.\n\t\t\t\t\t\tif (floor($words / 120) <= $number_of_links) {\n\t\t\t\t\t\t\t$score += 5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$recommendations[] = \"You should have at least one link for every 120 words of page content. You currently have $number_of_links link(s). You should have at least \".floor($words / 120).\".\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// See if we have any external links.\n\t\t\t\t\t\tif ($number_of_external_links) {\n\t\t\t\t\t\t\t$score += 5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$recommendations[] = \"Having an external link helps build Page Rank.\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$recommendations[] = \"You should have at least one link in your content.\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check on our readability score.\n\t\t\t\t\tif ($readability >= 90) {\n\t\t\t\t\t\t$score += 20;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$read_score = round(($readability / 90),2);\n\t\t\t\t\t\t$recommendations[] = \"Your readability score is \".($read_score*100).\"%. Using shorter sentences and words with fewer syllables will make your site easier to read by search engines and users.\";\n\t\t\t\t\t\t$score += ceil($read_score * 20);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$recommendations[] = \"You should enter page content.\";\n\t\t\t\t}\n\n\t\t\t\t// Check page freshness\n\t\t\t\t$updated = strtotime($page[\"updated_at\"]);\n\t\t\t\t$age = time()-$updated-(60*24*60*60);\n\t\t\t\t// See how much older it is than 2 months.\n\t\t\t\tif ($age > 0) {\n\t\t\t\t\t$age_score = 10 - floor(2 * ($age / (30*24*60*60)));\n\t\t\t\t\tif ($age_score < 0) {\n\t\t\t\t\t\t$age_score = 0;\n\t\t\t\t\t}\n\t\t\t\t\t$score += $age_score;\n\t\t\t\t\t$recommendations[] = \"Your content is around \".ceil(2 + ($age / (30*24*60*60))).\" months old. Updating your page more frequently will make it rank higher.\";\n\t\t\t\t} else {\n\t\t\t\t\t$score += 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$color = \"#008000\";\n\t\t\tif ($score <= 50) {\n\t\t\t\t$color = BigTree::colorMesh(\"#CCAC00\",\"#FF0000\",100-(100 * $score / 50));\n\t\t\t} elseif ($score <= 80) {\n\t\t\t\t$color = BigTree::colorMesh(\"#008000\",\"#CCAC00\",100-(100 * ($score-50) / 30));\n\t\t\t}\n\n\t\t\treturn array(\"score\" => $score, \"recommendations\" => $recommendations, \"color\" => $color);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPendingChange\n\t\t\t\tReturns a pending change from the bigtree_pending_changes table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the change.\n\n\t\t\tReturns:\n\t\t\t\tA entry from the table with the \"changes\" column decoded.\n\t\t*/\n\n\t\tstatic function getPendingChange($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE id = '$id'\"));\n\t\t\tif (!$item) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$item[\"changes\"] = json_decode($item[\"changes\"],true);\n\t\t\t$item[\"mtm_changes\"] = json_decode($item[\"mtm_changes\"],true);\n\t\t\t$item[\"tags_changes\"] = json_decode($item[\"tags_changes\"],true);\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPublishableChanges\n\t\t\t\tReturns a list of changes that the logged in user has access to publish.\n\n\t\t\tParameters:\n\t\t\t\tuser - The user id to retrieve changes for. Defaults to the logged in user.\n\n\t\t\tReturns:\n\t\t\t\tAn array of changes sorted by most recent.\n\t\t*/\n\n\t\tfunction getPublishableChanges($user = false) {\n\t\t\tif (!$user) {\n\t\t\t\t$user = static::getUser($this->ID);\n\t\t\t} else {\n\t\t\t\t$user = static::getUser($user);\n\t\t\t}\n\n\t\t\t$changes = array();\n\t\t\t// Setup the default search array to just be pages\n\t\t\t$search = array(\"`module` = ''\");\n\t\t\t// Add each module the user has publisher permissions to\n\t\t\tif (is_array($user[\"permissions\"][\"module\"])) {\n\t\t\t\tforeach ($user[\"permissions\"][\"module\"] as $module => $permission) {\n\t\t\t\t\tif ($permission == \"p\") {\n\t\t\t\t\t\t$search[] = \"`module` = '$module'\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add module group based permissions as well\n\t\t\tif (isset($user[\"permissions\"][\"module_gbp\"]) && is_array($user[\"permissions\"][\"module_gbp\"])) {\n\t\t\t\tforeach ($user[\"permissions\"][\"module_gbp\"] as $module => $groups) {\n\t\t\t\t\tforeach ($groups as $group => $permission) {\n\t\t\t\t\t\tif ($permission == \"p\") {\n\t\t\t\t\t\t\t$search[] = \"`module` = '$module'\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE \".implode(\" OR \",$search).\" ORDER BY date DESC\");\n\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$ok = false;\n\n\t\t\t\tif (!$f[\"item_id\"]) {\n\t\t\t\t\t$id = \"p\".$f[\"id\"];\n\t\t\t\t} else {\n\t\t\t\t\t$id = $f[\"item_id\"];\n\t\t\t\t}\n\n\t\t\t\t// If they're an admin, they've got it.\n\t\t\t\tif ($user[\"level\"] > 0) {\n\t\t\t\t\t$ok = true;\n\t\t\t\t// Check permissions on a page if it's a page.\n\t\t\t\t} elseif ($f[\"table\"] == \"bigtree_pages\") {\n\t\t\t\t\t$r = $this->getPageAccessLevelByUser($id,$user[\"id\"]);\n\t\t\t\t\t// If we're a publisher, this is ours!\n\t\t\t\t\tif ($r == \"p\") {\n\t\t\t\t\t\t$ok = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Check our list of modules.\n\t\t\t\t\tif ($user[\"permissions\"][\"module\"][$f[\"module\"]] == \"p\") {\n\t\t\t\t\t\t$ok = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Check our group based permissions\n\t\t\t\t\t\t$item = BigTreeAutoModule::getPendingItem($f[\"table\"],$id);\n\t\t\t\t\t\t$level = $this->getAccessLevel(static::getModule($f[\"module\"]),$item[\"item\"],$f[\"table\"],$user);\n\t\t\t\t\t\tif ($level == \"p\") {\n\t\t\t\t\t\t\t$ok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We're a publisher, get the info about the change and put it in the change list.\n\t\t\t\tif ($ok) {\n\t\t\t\t\t$f[\"mod\"] = static::getModule($f[\"module\"]);\n\t\t\t\t\t$f[\"user\"] = static::getUser($f[\"user\"]);\n\t\t\t\t\t$changes[] = $f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $changes;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPendingChanges\n\t\t\t\tReturns a list of changes for a given user.\n\n\t\t\tParameters:\n\t\t\t\tuser - The user id to retrieve changes for. Defaults to the logged in user.\n\n\t\t\tReturns:\n\t\t\t\tAn array of changes sorted by most recent.\n\t\t*/\n\n\t\tfunction getPendingChanges($user = false) {\n\t\t\tif (is_array($user)) {\n\t\t\t\t$user = $user[\"id\"];\n\t\t\t} elseif (!$user) {\n\t\t\t\t$user = $this->ID;\n\t\t\t}\n\n\t\t\t$changes = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE user = '\".sqlescape($user).\"' ORDER BY date DESC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$changes[] = $f;\n\t\t\t}\n\n\t\t\treturn $changes;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPendingNavigationByParent\n\t\t\t\tReturns a list of pending pages under a given parent ordered by most recent.\n\n\t\t\tParameters:\n\t\t\t\tparent - The ID of the parent page\n\t\t\t\tin_nav - true returns pages in navigation, false returns hidden pages\n\n\t\t\tReturns:\n\t\t\t\tAn array of pending page titles/ids.\n\t\t*/\n\n\t\tstatic function getPendingNavigationByParent($parent,$in_nav = true) {\n\t\t\t$nav = array();\n\t\t\t$titles = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE pending_page_parent = '$parent' AND `table` = 'bigtree_pages' AND type = 'NEW' ORDER BY date DESC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$page = json_decode($f[\"changes\"],true);\n\t\t\t\tif (($page[\"in_nav\"] && $in_nav) || (!$page[\"in_nav\"] && !$in_nav)) {\n\t\t\t\t\t$titles[] = $page[\"nav_title\"];\n\t\t\t\t\t$page[\"bigtree_pending\"] = true;\n\t\t\t\t\t$page[\"title\"] = $page[\"nav_title\"];\n\t\t\t\t\t$page[\"id\"] = \"p\".$f[\"id\"];\n\t\t\t\t\t$nav[] = $page;\n\t\t\t\t}\n\t\t\t}\n\t\t\tarray_multisort($titles,$nav);\n\t\t\treturn $nav;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getContentsOfResourceFolder\n\t\t\t\tReturns a list of resources and subfolders in a folder.\n\n\t\t\tParameters:\n\t\t\t\tfolder - The id of a folder or a folder entry.\n\t\t\t\tsort - The column to sort the folder's files on (default: date DESC).\n\n\t\t\tReturns:\n\t\t\t\tAn array of two arrays - folders and resources.\n\t\t*/\n\n\t\tstatic function getContentsOfResourceFolder($folder, $sort = \"date DESC\") {\n\t\t\tif (is_array($folder)) {\n\t\t\t\t$folder = $folder[\"id\"];\n\t\t\t}\n\t\t\t$folder = sqlescape($folder);\n\n\t\t\t$folders = array();\n\t\t\t$resources = array();\n\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resource_folders WHERE parent = '$folder' ORDER BY name\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$folders[] = $f;\n\t\t\t}\n\n\t\t\tif ($folder) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resources WHERE folder = '$folder' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resources WHERE folder = 0 OR folder IS NULL ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$resources[] = $f;\n\t\t\t}\n\n\t\t\treturn array(\"folders\" => $folders, \"resources\" => $resources);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceByFile\n\t\t\t\tReturns a resource with the given file name.\n\n\t\t\tParameters:\n\t\t\t\tfile - The file name.\n\n\t\t\tReturns:\n\t\t\t\tAn entry from bigtree_resources with file and thumbs decoded.\n\t\t*/\n\n\t\tstatic function getResourceByFile($file) {\n\t\t\tif (static::$IRLPrefixes === false) {\n\t\t\t\tstatic::$IRLPrefixes = array();\n\t\t\t\t$thumbnail_sizes = static::getSetting(\"bigtree-file-manager-thumbnail-sizes\");\n\t\t\t\t\n\t\t\t\tforeach ($thumbnail_sizes[\"value\"] as $ts) {\n\t\t\t\t\tstatic::$IRLPrefixes[] = $ts[\"prefix\"];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$last_prefix = false;\n\t\t\t$tokenized_file = BigTreeCMS::replaceHardRoots($file);\n\t\t\t$single_domain_tokenized_file = static::stripMultipleRootTokens($tokenized_file);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_resources WHERE file = '\".sqlescape($file).\"' OR file = '\".sqlescape($tokenized_file).\"' OR file = '\".sqlescape($single_domain_tokenized_file).\"'\"));\n\t\t\t\n\t\t\tif (!$item) {\n\t\t\t\tforeach (static::$IRLPrefixes as $prefix) {\n\t\t\t\t\tif (!$item) {\n\t\t\t\t\t\t$sfile = str_replace(\"files/resources/$prefix\", \"files/resources/\", $file);\n\t\t\t\t\t\t$tokenized_file = BigTreeCMS::replaceHardRoots($sfile);\n\t\t\t\t\t\t$single_domain_tokenized_file = static::stripMultipleRootTokens($tokenized_file);\n\t\t\t\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_resources WHERE file = '\".sqlescape($sfile).\"' OR file = '\".sqlescape($tokenized_file).\"' OR file = '\".sqlescape($single_domain_tokenized_file).\"'\"));\n\t\t\t\t\t\t$last_prefix = $prefix;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!$item) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$item[\"prefix\"] = $last_prefix;\n\t\t\t$item[\"file\"] = BigTreeCMS::replaceRelativeRoots($item[\"file\"]);\n\t\t\t$item[\"thumbs\"] = json_decode($item[\"thumbs\"],true);\n\t\t\t\n\t\t\tforeach ($item[\"thumbs\"] as &$thumb) {\n\t\t\t\t$thumb = BigTreeCMS::replaceRelativeRoots($thumb);\n\t\t\t}\n\t\t\t\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResource\n\t\t\t\tReturns a resource.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the resource.\n\n\t\t\tReturns:\n\t\t\t\tA resource entry.\n\t\t*/\n\n\t\tstatic function getResource($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_resources WHERE id = '$id'\"));\n\t\t\t$f[\"thumbs\"] = json_decode($f[\"thumbs\"],true);\n\t\t\treturn $f;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceAllocation\n\t\t\t\tReturns the places a resource is used.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the resource.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from the bigtree_resource_allocation table.\n\t\t*/\n\n\t\tstatic function getResourceAllocation($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resource_allocation WHERE resource = '$id' ORDER BY updated_at DESC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceFolder\n\t\t\t\tReturns a resource folder.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the folder.\n\n\t\t\tReturns:\n\t\t\t\tA resource folder entry.\n\t\t*/\n\n\t\tstatic function getResourceFolder($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_resource_folders WHERE id = '$id'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceFolderAllocationCounts\n\t\t\t\tReturns the number of items inside a folder and it's subfolders and the number of allocations of the contained resources.\n\n\t\t\tParameters:\n\t\t\t\tfolder - The id of the folder.\n\n\t\t\tReturns:\n\t\t\t\tA keyed array of \"resources\", \"folders\", and \"allocations\" for the number of resources, sub folders, and allocations.\n\t\t*/\n\n\t\tstatic function getResourceFolderAllocationCounts($folder) {\n\t\t\t$allocations = $folders = $resources = 0;\n\n\t\t\t$items = static::getContentsOfResourceFolder($folder);\n\t\t\tforeach ($items[\"folders\"] as $folder) {\n\t\t\t\t$folders++;\n\t\t\t\t$subs = static::getResourceFolderAllocationCounts($folder[\"id\"]);\n\t\t\t\t$allocations += $subs[\"allocations\"];\n\t\t\t\t$folders += $subs[\"folders\"];\n\t\t\t\t$resources += $subs[\"resources\"];\n\t\t\t}\n\t\t\tforeach ($items[\"resources\"] as $resource) {\n\t\t\t\t$resources++;\n\t\t\t\t$allocations += count(static::getResourceAllocation($resource[\"id\"]));\n\t\t\t}\n\t\t\treturn array(\"allocations\" => $allocations,\"folders\" => $folders,\"resources\" => $resources);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceFolderBreadcrumb\n\t\t\t\tReturns a breadcrumb of the given folder.\n\n\t\t\tParameters:\n\t\t\t\tfolder - The id of a folder or a folder entry.\n\n\t\t\tReturns:\n\t\t\t\tAn array of arrays containing the name and id of folders above.\n\t\t*/\n\n\t\tstatic function getResourceFolderBreadcrumb($folder,$crumb = array()) {\n\t\t\tif (!is_array($folder)) {\n\t\t\t\t$folder = sqlfetch(sqlquery(\"SELECT * FROM bigtree_resource_folders WHERE id = '\".sqlescape($folder).\"'\"));\n\t\t\t}\n\n\t\t\tif ($folder) {\n\t\t\t\t$crumb[] = array(\"id\" => $folder[\"id\"], \"name\" => $folder[\"name\"]);\n\t\t\t}\n\n\t\t\tif ($folder[\"parent\"]) {\n\t\t\t\treturn static::getResourceFolderBreadcrumb($folder[\"parent\"],$crumb);\n\t\t\t} else {\n\t\t\t\t$crumb[] = array(\"id\" => 0, \"name\" => \"Home\");\n\t\t\t\treturn array_reverse($crumb);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceFolderChildren\n\t\t\t\tReturns the child folders of a resource folder.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the parent folder.\n\n\t\t\tReturns:\n\t\t\t\tAn array of resource folder entries.\n\t\t*/\n\n\t\tstatic function getResourceFolderChildren($id) {\n\t\t\t$items = array();\n\t\t\t$id = sqlescape($id);\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resource_folders WHERE parent = '$id' ORDER BY name ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceFolderPermission\n\t\t\t\tReturns the permission level of the current user for the folder.\n\n\t\t\tParameters:\n\t\t\t\tfolder - The id of a folder or a folder entry.\n\n\t\t\tReturns:\n\t\t\t\t\"p\" if a user can create folders and upload files, \"e\" if the user can see/use files, \"n\" if a user can't access this folder.\n\t\t*/\n\n\t\tfunction getResourceFolderPermission($folder) {\n\t\t\t// User is an admin or developer\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\n\t\t\t// We're going to save the folder entry in case we need its parent later.\n\t\t\tif (is_array($folder)) {\n\t\t\t\t$id = $folder[\"id\"];\n\t\t\t} else {\n\t\t\t\t$id = $folder;\n\t\t\t}\n\n\t\t\t$p = $this->Permissions[\"resources\"][$id];\n\t\t\t// If p is already no, creator, or consumer we can just return it.\n\t\t\tif ($p && $p != \"i\") {\n\t\t\t\treturn $p;\n\t\t\t} else {\n\t\t\t\t// If folder is 0, we're already at home and can't check a higher folder for permissions.\n\t\t\t\tif (!$folder) {\n\t\t\t\t\treturn \"e\";\n\t\t\t\t}\n\n\t\t\t\t// If a folder entry wasn't passed in, we need it to find its parent.\n\t\t\t\tif (!is_array($folder)) {\n\t\t\t\t\t$folder = sqlfetch(sqlquery(\"SELECT parent FROM bigtree_resource_folders WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\t\t}\n\t\t\t\t// If we couldn't find the folder anymore, just say they can consume.\n\t\t\t\tif (!$folder) {\n\t\t\t\t\treturn \"e\";\n\t\t\t\t}\n\n\t\t\t\t// Return the parent's permissions\n\t\t\t\treturn $this->getResourceFolderPermission($folder[\"parent\"]);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getRoutedTemplates\n\t\t\t\tReturns a list of routed templates ordered by position that the logged in user has access to.\n\n\t\t\tParameters:\n\t\t\t\tsort - Sort order, defaults to positioned\n\n\t\t\tReturns:\n\t\t\t\tAn array of template entries.\n\t\t*/\n\n\t\tfunction getRoutedTemplates($sort = \"position DESC, id ASC\") {\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_templates WHERE level <= '\".$this->Level.\"' ORDER BY $sort\");\n\t\t\t$items = array();\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($f[\"routed\"]) {\n\t\t\t\t\t$items[] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getSetting\n\t\t\t\tReturns a setting.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the setting to return.\n\t\t\t\tdecode - Whether to decode the array or not. Large data sets may want to set this to false if there aren't internal page links.\n\n\t\t\tReturns:\n\t\t\t\tA setting entry with its value properly decoded and decrypted.\n\t\t\t\tReturns false if the setting could not be found.\n\t\t*/\n\n\t\tstatic function getSetting($id,$decode = true) {\n\t\t\tglobal $bigtree;\n\t\t\t$id = BigTreeCMS::extensionSettingCheck($id);\n\t\t\t$setting = sqlfetch(sqlquery(\"SELECT * FROM bigtree_settings WHERE id = '$id'\"));\n\t\t\t\n\t\t\t// Setting doesn't exist\n\t\t\tif (!$setting) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Encrypted setting\n\t\t\tif ($setting[\"encrypted\"]) {\n\t\t\t\t$v = sqlfetch(sqlquery(\"SELECT AES_DECRYPT(`value`,'\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') AS `value` FROM bigtree_settings WHERE id = '$id'\"));\n\t\t\t\t$setting[\"value\"] = $v[\"value\"];\n\t\t\t}\n\n\t\t\t// Decode the JSON value\n\t\t\tif ($decode) {\n\t\t\t\t$setting[\"value\"] = json_decode($setting[\"value\"],true);\n\t\n\t\t\t\tif (is_array($setting[\"value\"])) {\n\t\t\t\t\t$setting[\"value\"] = BigTree::untranslateArray($setting[\"value\"]);\n\t\t\t\t} else {\n\t\t\t\t\t$setting[\"value\"] = BigTreeCMS::replaceInternalPageLinks($setting[\"value\"]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $setting;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getSettings\n\t\t\t\tReturns a list of all settings that the logged in user has access to.\n\n\t\t\tParameters:\n\t\t\t\tsort - Order to return the settings. Defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_settings.\n\t\t\t\tIf the setting is encrypted the value will be \"[Encrypted Text]\", otherwise it will be decoded.\n\t\t\t\tIf the calling user is a developer, returns locked settings, otherwise they are left out.\n\t\t*/\n\n\t\tfunction getSettings($sort = \"name ASC\") {\n\t\t\t$items = array();\n\t\t\tif ($this->Level < 2) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE locked = '' AND system = '' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE system = '' ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tforeach ($f as $key => $val) {\n\t\t\t\t\t$f[$key] = BigTreeCMS::replaceRelativeRoots($val);\n\t\t\t\t}\n\t\t\t\t$f[\"value\"] = json_decode($f[\"value\"],true);\n\t\t\t\tif ($f[\"encrypted\"] == \"on\") {\n\t\t\t\t\t$f[\"value\"] = \"[Encrypted Text]\";\n\t\t\t\t}\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getSettingsPageCount\n\t\t\t\tReturns the number of pages of settings that the logged in user has access to.\n\n\t\t\tParameters:\n\t\t\t\tquery - Optional string to query against.\n\n\t\t\tReturns:\n\t\t\t\tThe number of pages of settings.\n\t\t*/\n\n\t\tfunction getSettingsPageCount($query = \"\") {\n\t\t\t// If we're searching.\n\t\t\tif ($query) {\n\t\t\t\t$qparts = explode(\" \",$query);\n\t\t\t\t$qp = array();\n\t\t\t\tforeach ($qparts as $part) {\n\t\t\t\t\t$part = sqlescape(strtolower($part));\n\t\t\t\t\t$qp[] = \"(LOWER(name) LIKE '%$part%' OR LOWER(value) LIKE '%$part%')\";\n\t\t\t\t}\n\t\t\t\t// Administrator\n\t\t\t\tif ($this->Level < 2) {\n\t\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_settings WHERE system = '' AND locked = '' AND \".implode(\" AND \",$qp));\n\t\t\t\t// Developer\n\t\t\t\t} else {\n\t\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_settings WHERE system = '' AND \".implode(\" AND \",$qp));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Administrator\n\t\t\t\tif ($this->Level < 2) {\n\t\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_settings WHERE system = '' AND locked = ''\");\n\t\t\t\t// Developer\n\t\t\t\t} else {\n\t\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_settings WHERE system = ''\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$r = sqlrows($q);\n\t\t\t$pages = ceil($r / static::$PerPage);\n\t\t\tif ($pages == 0) {\n\t\t\t\t$pages = 1;\n\t\t\t}\n\n\t\t\treturn $pages;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getSystemSettings\n\t\t\t\tReturns a list of user defined (no bigtree-internal- prefix) system settings without decoded values.\n\n\t\t\tParameters:\n\t\t\t\tsort - Order to return the settings. Defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_settings.\n\t\t*/\n\n\t\tstatic function getSystemSettings($sort = \"name ASC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE id NOT LIKE 'bigtree-internal-%' AND system != '' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getTag\n\t\t\t\tReturns a tag for the given id.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the tag.\n\n\t\t\tReturns:\n\t\t\t\tA bigtree_tags entry.\n\t\t*/\n\n\t\tstatic function getTag($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE id = '$id'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getTemplates\n\t\t\t\tReturns a list of templates.\n\n\t\t\tParameters:\n\t\t\t\tsort - Sort order, defaults to positioned.\n\n\t\t\tReturns:\n\t\t\t\tAn array of template entries.\n\t\t*/\n\n\t\tstatic function getTemplates($sort = \"position DESC, name ASC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_templates ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUnreadMessageCount\n\t\t\t\tReturns the number of unread messages for the logged in user.\n\n\t\t\tReturns:\n\t\t\t\tThe number of unread messages.\n\t\t*/\n\n\t\tfunction getUnreadMessageCount() {\n\t\t\treturn sqlrows(sqlquery(\"SELECT id FROM bigtree_messages WHERE recipients LIKE '%|\".$this->ID.\"|%' AND read_by NOT LIKE '%|\".$this->ID.\"|%'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUser\n\t\t\t\tGets a user's decoded information.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the user to return.\n\n\t\t\tReturns:\n\t\t\t\tA user entry from bigtree_users with permissions and alerts decoded.\n\t\t*/\n\n\t\tstatic function getUser($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE id = '$id'\"));\n\t\t\tif (!$item) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($item[\"level\"] > 0) {\n\t\t\t\t$permissions = array();\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_modules\");\n\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t$permissions[\"module\"][$f[\"id\"]] = \"p\";\n\t\t\t\t}\n\t\t\t\t$item[\"permissions\"] = $permissions;\n\t\t\t} else {\n\t\t\t\t$item[\"permissions\"] = json_decode($item[\"permissions\"],true);\n\t\t\t}\n\t\t\t$item[\"alerts\"] = json_decode($item[\"alerts\"],true);\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUserByEmail\n\t\t\t\tGets a user entry for a given email.\n\n\t\t\tParameters:\n\t\t\t\temail - The email to find.\n\n\t\t\tReturns:\n\t\t\t\tA user entry from bigtree_users.\n\t\t*/\n\n\t\tstatic function getUserByEmail($email) {\n\t\t\t$email = sqlescape($email);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE email = '$email'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUserByHash\n\t\t\t\tGets a user entry for a change password hash.\n\n\t\t\tParameters:\n\t\t\t\thash - The hash to find.\n\n\t\t\tReturns:\n\t\t\t\tA user entry from bigtree_users.\n\t\t*/\n\n\t\tstatic function getUserByHash($hash) {\n\t\t\t$hash = sqlescape($hash);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE change_password_hash = '$hash'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUsers\n\t\t\t\tReturns a list of all users.\n\n\t\t\tParameters:\n\t\t\t\tsort - Order to sort the list. Defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_users.\n\t\t\t\tThe keys of the array are the ids of the user.\n\t\t*/\n\n\t\tstatic function getUsers($sort = \"name ASC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_users ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[$f[\"id\"]] = $f;\n\t\t\t}\n\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUsersPageCount\n\t\t\t\tReturns the number of pages of users.\n\n\t\t\tParameters:\n\t\t\t\tquery - Optional query string to search against.\n\n\t\t\tReturns:\n\t\t\t\tThe number of pages of results.\n\t\t*/\n\n\t\tstatic function getUsersPageCount($query = \"\") {\n\t\t\t// If we're searching.\n\t\t\tif ($query) {\n\t\t\t\t$qparts = explode(\" \",$query);\n\t\t\t\t$qp = array();\n\t\t\t\tforeach ($qparts as $part) {\n\t\t\t\t\t$part = sqlescape(strtolower($part));\n\t\t\t\t\t$qp[] = \"(LOWER(name) LIKE '%$part%' OR LOWER(email) LIKE '%$part%' OR LOWER(company) LIKE '%$part%')\";\n\t\t\t\t}\n\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_users WHERE \".implode(\" AND \",$qp));\n\t\t\t// If we're showing all.\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_users\");\n\t\t\t}\n\n\t\t\t$r = sqlrows($q);\n\t\t\t$pages = ceil($r / static::$PerPage);\n\t\t\tif ($pages == 0) {\n\t\t\t\t$pages = 1;\n\t\t\t}\n\n\t\t\treturn $pages;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: growl\n\t\t\t\tSets up a growl session for the next page reload.\n\n\t\t\tParameters:\n\t\t\t\ttitle - The section message for the growl.\n\t\t\t\tmessage - The description of what happened.\n\t\t\t\ttype - The icon to draw.\n\t\t*/\n\n\t\tstatic function growl($title,$message,$type = \"success\") {\n\t\t\t$_SESSION[\"bigtree_admin\"][\"growl\"] = array(\"message\" => $message, \"title\" => $title, \"type\" => $type);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: htmlClean\n\t\t\t\tRemoves things that shouldn't be in the <body> of an HTML document from a string.\n\n\t\t\tParameters:\n\t\t\t\thtml - A string of HTML\n\n\t\t\tReturns:\n\t\t\t\tA clean string of HTML for echoing in <body>\n\t\t*/\n\n\t\tstatic function htmlClean($html) {\n\t\t\treturn str_replace(\"<br></br>\",\"<br />\",strip_tags($html,\"<a><abbr><address><area><article><aside><audio><b><base><bdo><blockquote><body><br><button><canvas><caption><cite><code><col><colgroup><command><datalist><dd><del><details><dfn><div><dl><dt><em><emded><fieldset><figcaption><figure><footer><form><h1><h2><h3><h4><h5><h6><header><hgroup><hr><i><iframe><img><input><ins><keygen><kbd><label><legend><li><link><map><mark><menu><meter><nav><noscript><object><ol><optgroup><option><output><p><param><pre><progress><q><rp><rt><ruby><s><samp><script><section><select><small><source><span><strong><style><sub><summary><sup><table><tbody><td><textarea><tfoot><th><thead><time><title><tr><ul><var><video><wbr>\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: ignore404\n\t\t\t\tIgnores a 404 error.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the reported 404.\n\t\t*/\n\n\t\tfunction ignore404($id) {\n\t\t\t$this->requireLevel(1);\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"UPDATE bigtree_404s SET ignored = 'on' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_404s\",$id,\"ignored\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: initSecurity\n\t\t\t\tSets up security environment variables and runs white/blacklists for IP checks.\n\t\t*/\n\n\t\tfunction initSecurity() {\n\t\t\tglobal $bigtree;\n\t\t\t$ip = ip2long($_SERVER[\"REMOTE_ADDR\"]);\n\t\t\t$bigtree[\"security-policy\"] = $p = BigTreeCMS::getSetting(\"bigtree-internal-security-policy\");\n\n\t\t\t// Check banned IPs list for the user's IP\n\t\t\tif (!empty($p[\"banned_ips\"])) {\n\t\t\t\t$banned = explode(\"\\n\",$p[\"banned_ips\"]);\n\t\t\t\tforeach ($banned as $address) {\n\t\t\t\t\tif (ip2long(trim($address)) == $ip) {\n\t\t\t\t\t\t$bigtree[\"layout\"] = \"login\";\n\t\t\t\t\t\t$this->stop(file_get_contents(BigTree::path(\"admin/pages/ip-restriction.php\")));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check allowed IP ranges list for user's IP\n\t\t\tif (!empty($p[\"allowed_ips\"])) {\n\t\t\t\t$allowed = false;\n\t\t\t\t// Go through the list and see if our IP address is allowed\n\t\t\t\t$list = explode(\"\\n\",$p[\"allowed_ips\"]);\n\t\t\t\tforeach ($list as $item) {\n\t\t\t\t\tlist($begin,$end) = explode(\",\",$item);\n\t\t\t\t\t$begin = ip2long(trim($begin));\n\t\t\t\t\t$end = ip2long(trim($end));\n\t\t\t\t\tif ($begin <= $ip && $end >= $ip) {\n\t\t\t\t\t\t$allowed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!$allowed) {\n\t\t\t\t\t$bigtree[\"layout\"] = \"login\";\n\t\t\t\t\t$this->stop(file_get_contents(BigTree::path(\"admin/pages/ip-restriction.php\")));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: installExtension\n\t\t\t\tInstalls an extension.\n\n\t\t\tParameters:\n\t\t\t\tmanifest - Manifest array\n\t\t\t\tupgrade - Old manifest array (if doing an upgrade, otherwise leave false)\n\n\t\t\tReturns:\n\t\t\t\tModified manifest array.\n\t\t*/\n\n\t\tfunction installExtension($manifest,$upgrade = false) {\n\t\t\t$bigtree[\"group_match\"] = $bigtree[\"module_match\"] = $bigtree[\"route_match\"] = $bigtree[\"class_name_match\"] = $bigtree[\"form_id_match\"] = $bigtree[\"view_id_match\"] = $bigtree[\"report_id_match\"] = array();\n\t\t\t$extension = sqlescape($manifest[\"id\"]);\n\n\t\t\t// Turn off foreign key checks so we can reference the extension before creating it\n\t\t\tsqlquery(\"SET foreign_key_checks = 0\");\n\n\t\t\t// Upgrades drop existing modules, templates, etc -- we don't drop settings because they have user data\n\t\t\tif (is_array($upgrade)) {\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_groups WHERE extension = '$extension'\");\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_modules WHERE extension = '$extension'\");\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_templates WHERE extension = '$extension'\");\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_callouts WHERE extension = '$extension'\");\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_field_types WHERE extension = '$extension'\");\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_feeds WHERE extension = '$extension'\");\n\n\t\t\t// Import tables for new installs\n\t\t\t} else { \n\t\t\t\tforeach ($manifest[\"components\"][\"tables\"] as $table_name => $sql_statement) {\n\t\t\t\t\tsqlquery(\"DROP TABLE IF EXISTS `$table_name`\");\n\t\t\t\t\tsqlquery($sql_statement);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Import module groups\n\t\t\tforeach ($manifest[\"components\"][\"module_groups\"] as &$group) {\n\t\t\t\tif ($group) {\n\t\t\t\t\t$bigtree[\"group_match\"][$group[\"id\"]] = $this->createModuleGroup($group[\"name\"]);\n\t\t\t\t\t// Update the group ID since we're going to save this manifest locally for uninstalling\n\t\t\t\t\t$group[\"id\"] = $bigtree[\"group_match\"][$group[\"id\"]];\n\t\t\t\t\tsqlquery(\"UPDATE bigtree_module_groups SET extension = '$extension' WHERE id = '\".$group[\"id\"].\"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import modules\n\t\t\tforeach ($manifest[\"components\"][\"modules\"] as &$module) {\n\t\t\t\tif ($module) {\n\t\t\t\t\t$group = ($module[\"group\"] && isset($bigtree[\"group_match\"][$module[\"group\"]])) ? $bigtree[\"group_match\"][$module[\"group\"]] : \"NULL\";\n\t\t\t\t\t$gbp = sqlescape(is_array($module[\"gbp\"]) ? BigTree::json($module[\"gbp\"]) : $module[\"gbp\"]);\n\t\t\t\t\t// Find a unique route\n\t\t\t\t\t$oroute = $route = $module[\"route\"];\n\t\t\t\t\t$x = 2;\n\t\t\t\t\twhile (sqlrows(sqlquery(\"SELECT * FROM bigtree_modules WHERE route = '\".sqlescape($route).\"'\"))) {\n\t\t\t\t\t\t$route = $oroute.\"-$x\";\n\t\t\t\t\t\t$x++;\n\t\t\t\t\t}\n\t\t\t\t\t// Create the module\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_modules (`name`,`route`,`class`,`icon`,`group`,`gbp`,`extension`) VALUES ('\".sqlescape($module[\"name\"]).\"','\".sqlescape($route).\"','\".sqlescape($module[\"class\"]).\"','\".sqlescape($module[\"icon\"]).\"',$group,'$gbp','$extension')\");\n\t\t\t\t\t$module_id = sqlid();\n\t\t\t\t\t$bigtree[\"module_match\"][$module[\"id\"]] = $module_id;\n\t\t\t\t\t$bigtree[\"route_match\"][$module[\"route\"]] = $route;\n\t\t\t\t\t// Update the module ID since we're going to save this manifest locally for uninstalling\n\t\t\t\t\t$module[\"id\"] = $module_id;\n\t\t\t\n\t\t\t\t\t// Create the embed forms\n\t\t\t\t\tforeach ($module[\"embed_forms\"] as $form) {\n\t\t\t\t\t\t$this->createModuleEmbedForm($module_id,$form[\"title\"],$form[\"table\"],(is_array($form[\"fields\"]) ? $form[\"fields\"] : json_decode($form[\"fields\"],true)),$form[\"hooks\"],$form[\"default_position\"],$form[\"default_pending\"],$form[\"css\"],$form[\"redirect_url\"],$form[\"thank_you_message\"]);\n\t\t\t\t\t}\n\t\t\t\t\t// Create views\n\t\t\t\t\tforeach ($module[\"views\"] as $view) {\n\t\t\t\t\t\t$bigtree[\"view_id_match\"][$view[\"id\"]] = $this->createModuleView($module_id,$view[\"title\"],$view[\"description\"],$view[\"table\"],$view[\"type\"],(is_array($view[\"options\"]) ? $view[\"options\"] : json_decode($view[\"options\"],true)),(is_array($view[\"fields\"]) ? $view[\"fields\"] : json_decode($view[\"fields\"],true)),(is_array($view[\"actions\"]) ? $view[\"actions\"] : json_decode($view[\"actions\"],true)),$view[\"suffix\"],$view[\"preview_url\"]);\n\t\t\t\t\t}\n\t\t\t\t\t// Create regular forms\n\t\t\t\t\tforeach ($module[\"forms\"] as $form) {\n\t\t\t\t\t\t$bigtree[\"form_id_match\"][$form[\"id\"]] = $this->createModuleForm($module_id,$form[\"title\"],$form[\"table\"],(is_array($form[\"fields\"]) ? $form[\"fields\"] : json_decode($form[\"fields\"],true)),$form[\"hooks\"],$form[\"default_position\"],($form[\"return_view\"] ? $bigtree[\"view_id_match\"][$form[\"return_view\"]] : false),$form[\"return_url\"],$form[\"tagging\"]);\n\t\t\t\t\t}\n\t\t\t\t\t// Create reports\n\t\t\t\t\tforeach ($module[\"reports\"] as $report) {\n\t\t\t\t\t\t$bigtree[\"report_id_match\"][$report[\"id\"]] = $this->createModuleReport($module_id,$report[\"title\"],$report[\"table\"],$report[\"type\"],(is_array($report[\"filters\"]) ? $report[\"filters\"] : json_decode($report[\"filters\"],true)),(is_array($report[\"fields\"]) ? $report[\"fields\"] : json_decode($report[\"fields\"],true)),$report[\"parser\"],($report[\"view\"] ? $bigtree[\"view_id_match\"][$report[\"view\"]] : false));\n\t\t\t\t\t}\n\t\t\t\t\t// Create actions\n\t\t\t\t\tforeach ($module[\"actions\"] as $action) {\n\t\t\t\t\t\t$this->createModuleAction($module_id,$action[\"name\"],$action[\"route\"],$action[\"in_nav\"],$action[\"class\"],$bigtree[\"form_id_match\"][$action[\"form\"]],$bigtree[\"view_id_match\"][$action[\"view\"]],$bigtree[\"report_id_match\"][$action[\"report\"]],$action[\"level\"],$action[\"position\"]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import templates\n\t\t\tforeach ($manifest[\"components\"][\"templates\"] as $template) {\n\t\t\t\tif ($template) {\n\t\t\t\t\t$resources = sqlescape(is_array($template[\"resources\"]) ? BigTree::json($template[\"resources\"]) : $template[\"resources\"]);\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_templates (`id`,`name`,`module`,`resources`,`level`,`routed`,`extension`) VALUES ('\".sqlescape($template[\"id\"]).\"','\".sqlescape($template[\"name\"]).\"','\".$bigtree[\"module_match\"][$template[\"module\"]].\"','$resources','\".sqlescape($template[\"level\"]).\"','\".sqlescape($template[\"routed\"]).\"','$extension')\");\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import callouts\n\t\t\tforeach ($manifest[\"components\"][\"callouts\"] as $callout) {\n\t\t\t\tif ($callout) {\n\t\t\t\t\t$resources = sqlescape(is_array($callout[\"resources\"]) ? BigTree::json($callout[\"resources\"]) : $callout[\"resources\"]);\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_callouts (`id`,`name`,`description`,`display_default`,`display_field`,`resources`,`level`,`position`,`extension`) VALUES ('\".sqlescape($callout[\"id\"]).\"','\".sqlescape($callout[\"name\"]).\"','\".sqlescape($callout[\"description\"]).\"','\".sqlescape($callout[\"display_default\"]).\"','\".sqlescape($callout[\"display_field\"]).\"','$resources','\".sqlescape($callout[\"level\"]).\"','\".sqlescape($callout[\"position\"]).\"','$extension')\");\t\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import Settings\n\t\t\tforeach ($manifest[\"components\"][\"settings\"] as $setting) {\n\t\t\t\tif ($setting) {\n\t\t\t\t\t$this->createSetting($setting);\n\t\t\t\t\tsqlquery(\"UPDATE bigtree_settings SET extension = '$extension' WHERE id = '\".sqlescape($setting[\"id\"]).\"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import Feeds\n\t\t\tforeach ($manifest[\"components\"][\"feeds\"] as $feed) {\n\t\t\t\tif ($feed) {\n\t\t\t\t\t$fields = sqlescape(is_array($feed[\"fields\"]) ? BigTree::json($feed[\"fields\"]) : $feed[\"fields\"]);\n\t\t\t\t\t$options = sqlescape(is_array($feed[\"options\"]) ? BigTree::json($feed[\"options\"]) : $feed[\"options\"]);\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_feeds (`route`,`name`,`description`,`type`,`table`,`fields`,`options`,`extension`) VALUES ('\".sqlescape($feed[\"route\"]).\"','\".sqlescape($feed[\"name\"]).\"','\".sqlescape($feed[\"description\"]).\"','\".sqlescape($feed[\"type\"]).\"','\".sqlescape($feed[\"table\"]).\"','$fields','$options','$extension')\");\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import Field Types\n\t\t\tforeach ($manifest[\"components\"][\"field_types\"] as $type) {\n\t\t\t\tif ($type) {\n\t\t\t\t\t$self_draw = $type[\"self_draw\"] ? \"'on'\" : \"NULL\";\n\t\t\t\t\t$use_cases = sqlescape(is_array($type[\"use_cases\"]) ? json_encode($type[\"use_cases\"]) : $type[\"use_cases\"]);\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_field_types (`id`,`name`,`use_cases`,`self_draw`,`extension`) VALUES ('\".sqlescape($type[\"id\"]).\"','\".sqlescape($type[\"name\"]).\"','$use_cases',$self_draw,'$extension')\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Upgrades don't drop tables, we run the SQL revisions instead\n\t\t\tif (is_array($upgrade)) {\n\t\t\t\t$old_revision = $upgrade[\"revision\"];\n\t\t\t\t$sql_revisions = $manifest[\"sql_revisions\"];\n\n\t\t\t\t// Go through all the SQL updates, we ksort first to ensure if the manifest somehow got out of order that we run the SQL update sequentially\n\t\t\t\tksort($sql_revisions);\n\t\t\t\tforeach ($sql_revisions as $key => $statements) {\n\t\t\t\t\tif ($key > $old_revision) {\n\t\t\t\t\t\tforeach ($statements as $sql_statement) {\n\t\t\t\t\t\t\tsqlquery($sql_statement);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Update the extension\n\t\t\t\tsqlquery(\"UPDATE bigtree_extensions SET name = '\".sqlescape($manifest[\"title\"]).\"', version = '\".sqlescape($manifest[\"version\"]).\"', last_updated = NOW(), manifest = '\".BigTree::json($manifest,true).\"' WHERE id = '\".sqlescape($manifest[\"id\"]).\"'\");\n\t\t\t\n\t\t\t// Straight installs move files into place locally\n\t\t\t} else {\n\t\t\t\t// Make sure destination doesn't exist\n\t\t\t\t$destination_path = SERVER_ROOT.\"extensions/\".$manifest[\"id\"].\"/\"; \n\t\t\t\tBigTree::deleteDirectory($destination_path);\n\n\t\t\t\t// Move the package to the extension directory\n\t\t\t\trename(SERVER_ROOT.\"cache/package/\",$destination_path);\n\t\t\t\tBigTree::setDirectoryPermissions($destination_path);\n\n\t\t\t\t// Create the extension\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_extensions (`id`,`type`,`name`,`version`,`last_updated`,`manifest`) VALUES ('\".sqlescape($manifest[\"id\"]).\"','extension','\".sqlescape($manifest[\"title\"]).\"','\".sqlescape($manifest[\"version\"]).\"',NOW(),'\".BigTree::json($manifest,true).\"')\");\t\n\t\t\t}\n\n\t\t\t// Re-enable foreign key checks\n\t\t\tsqlquery(\"SET foreign_key_checks = 1\");\n\n\t\t\t// Empty view cache\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_view_cache\");\n\n\t\t\t// Move public files into the site directory\n\t\t\t$public_dir = SERVER_ROOT.\"extensions/\".$manifest[\"id\"].\"/public/\";\n\t\t\t$site_contents = file_exists($public_dir) ? BigTree::directoryContents($public_dir) : array();\n\t\t\tforeach ($site_contents as $file_path) {\n\t\t\t\t$destination_path = str_replace($public_dir,SITE_ROOT.\"extensions/\".$manifest[\"id\"].\"/\",$file_path);\n\t\t\t\tBigTree::copyFile($file_path,$destination_path);\n\t\t\t}\n\n\t\t\t// Clear module class cache and field type cache.\n\t\t\t@unlink(SERVER_ROOT.\"cache/bigtree-module-class-list.json\");\n\t\t\t@unlink(SERVER_ROOT.\"cache/bigtree-form-field-types.json\");\n\n\t\t\treturn $manifest;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: iplExists\n\t\t\t\tDetermines whether an internal page link still exists or not.\n\n\t\t\tParameters:\n\t\t\t\tipl - An internal page link\n\n\t\t\tReturns:\n\t\t\t\tTrue if it is still a valid link, otherwise false.\n\t\t*/\n\n\t\tstatic function iplExists($ipl) {\n\t\t\t$ipl = explode(\"//\",$ipl);\n\n\t\t\t// See if the page it references still exists.\n\t\t\t$nav_id = $ipl[1];\n\t\t\tif (!sqlrows(sqlquery(\"SELECT id FROM bigtree_pages WHERE id = '$nav_id'\"))) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Decode the commands attached to the page\n\t\t\t$commands = json_decode(base64_decode($ipl[2]),true);\n\t\t\t// If there are no commands, we're good.\n\t\t\tif (empty($commands[0])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// If it's a hash tag link, we're also good.\n\t\t\tif (substr($commands[0],0,1) == \"#\") {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Get template for the navigation id to see if it's a routed template\n\t\t\t$t = sqlfetch(sqlquery(\"SELECT bigtree_templates.routed FROM bigtree_templates JOIN bigtree_pages ON bigtree_templates.id = bigtree_pages.template WHERE bigtree_pages.id = '$nav_id'\"));\n\t\t\t// If we're a routed template, we're good.\n\t\t\tif ($t[\"routed\"]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// We may have been on a page, but there's extra routes that don't go anywhere or do anything so it's a 404.\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: irlExists\n\t\t\t\tDetermines whether an internal resource link still exists or not.\n\n\t\t\tParameters:\n\t\t\t\tirl - An internal resource link\n\n\t\t\tReturns:\n\t\t\t\tTrue if it is still a valid link, otherwise false.\n\t\t*/\n\n\t\tstatic function irlExists($irl) {\n\t\t\t$irl = explode(\"//\",$irl);\n\t\t\t$resource = static::getResource($irl[1]);\n\t\t\tif ($resource) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: lockCheck\n\t\t\t\tChecks if a lock exists.\n\t\t\t\tIf a lock exists and it's currently active, stops page execution and shows the lock page.\n\t\t\t\tIf a lock is yours, refreshes the lock.\n\t\t\t\tIf there is no lock, creates one for you.\n\n\t\t\tParameters:\n\t\t\t\ttable - The table to check.\n\t\t\t\tid - The id of the entry to check.\n\t\t\t\tinclude - The lock page to include (relative to /core/ or /custom/)\n\t\t\t\tforce - Whether to force through the lock or not.\n\t\t\t\tin_admin - Whether to call stop()\n\n\t\t\tReturns:\n\t\t\t\tYour lock id.\n\t\t*/\n\n\t\tfunction lockCheck($table,$id,$include,$force = false,$in_admin = true) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\t\t\t$table = sqlescape($table);\n\t\t\t$id = sqlescape($id);\n\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_locks WHERE `table` = '$table' AND item_id = '$id'\"));\n\t\t\tif ($f && $f[\"user\"] != $this->ID && strtotime($f[\"last_accessed\"]) > (time()-300) && !$force) {\n\t\t\t\t$locked_by = static::getUser($f[\"user\"]);\n\t\t\t\t$last_accessed = $f[\"last_accessed\"];\n\t\t\t\tinclude BigTree::path($include);\n\t\t\t\tif ($in_admin) {\n\t\t\t\t\t$this->stop();\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ($f) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_locks SET last_accessed = NOW(), user = '\".$this->ID.\"' WHERE id = '\".$f[\"id\"].\"'\");\n\t\t\t\treturn $f[\"id\"];\n\t\t\t} else {\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_locks (`table`,`item_id`,`user`,`title`) VALUES ('$table','$id','\".$this->ID.\"','Page')\");\n\t\t\t\treturn sqlid();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: login\n\t\t\t\tAttempts to login a user to the CMS.\n\n\t\t\tParameters:\n\t\t\t\temail - The email address of the user.\n\t\t\t\tpassword - The password of the user.\n\t\t\t\tstay_logged_in - Whether to set a cookie to keep the user logged in.\n\n\t\t\tReturns:\n\t\t\t\tfalse if login failed, otherwise redirects back to the page the person requested.\n\t\t*/\n\n\t\tstatic function login($email,$password,$stay_logged_in = false) {\n\t\t\tglobal $bigtree;\n\n\t\t\t// Check to see if this IP is already banned from logging in.\n\t\t\t$ip = ip2long($_SERVER[\"REMOTE_ADDR\"]);\n\t\t\t$ban = sqlfetch(sqlquery(\"SELECT * FROM bigtree_login_bans WHERE expires > NOW() AND ip = '$ip'\"));\n\t\t\t\n\t\t\tif ($ban) {\n\t\t\t\t$bigtree[\"ban_expiration\"] = date(\"F j, Y @ g:ia\",strtotime($ban[\"expires\"]));\n\t\t\t\t$bigtree[\"ban_is_user\"] = false;\n\t\t\t\t\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Get rid of whitespace and make the email lowercase for consistency\n\t\t\t$email = trim(strtolower($email));\n\t\t\t$password = trim($password);\n\t\t\t$user = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE LOWER(email) = '\".sqlescape($email).\"'\"));\n\n\t\t\t// See if this user is banned due to failed login attempts\n\t\t\t$ban = sqlfetch(sqlquery(\"SELECT * FROM bigtree_login_bans WHERE expires > NOW() AND `user` = '\".$user[\"id\"].\"'\"));\n\t\t\t\n\t\t\tif ($ban) {\n\t\t\t\t$bigtree[\"ban_expiration\"] = date(\"F j, Y @ g:ia\",strtotime($ban[\"expires\"]));\n\t\t\t\t$bigtree[\"ban_is_user\"] = true;\n\t\t\t\t\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], true);\n\t\t\t$ok = $phpass->CheckPassword($password, $user[\"password\"]);\n\t\t\t\n\t\t\tif ($ok) {\n\t\t\t\t// Generate a random CSRF token\n\t\t\t\t$csrf_token = base64_encode(openssl_random_pseudo_bytes(32));\n\t\t\t\t$csrf_token_field = \"__csrf_token_\".BigTree::randomString(32).\"__\";\n\t\t\t\t\n\t\t\t\t// Generate a random chain id\n\t\t\t\t$chain = uniqid(\"chain-\",true);\n\n\t\t\t\twhile (sqlrows(sqlquery(\"SELECT id FROM bigtree_user_sessions WHERE chain = '\".sqlescape($chain).\"'\"))) {\n\t\t\t\t\t$chain = uniqid(\"chain-\",true);\n\t\t\t\t}\n\n\t\t\t\t// Generate a random session id\n\t\t\t\t$session = uniqid(\"session-\",true);\n\n\t\t\t\twhile (sqlrows(sqlquery(\"SELECT id FROM bigtree_user_sessions WHERE id = '\".sqlescape($session).\"'\"))) {\n\t\t\t\t\t$session = uniqid(\"session-\",true);\n\t\t\t\t}\n\n\t\t\t\t// Create the new session chain\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_user_sessions (`id`,`chain`,`email`,`csrf_token`,`csrf_token_field`) VALUES ('\".sqlescape($session).\"','\".sqlescape($chain).\"','\".sqlescape($user[\"email\"]).\"','$csrf_token','$csrf_token_field')\");\n\t\t\t\t\n\t\t\t\tif (!empty($bigtree[\"config\"][\"sites\"]) && count($bigtree[\"config\"][\"sites\"])) {\n\t\t\t\t\t// Create another unique cache session for logins across domains\n\t\t\t\t\t$cache_data = array(\n\t\t\t\t\t\t\"user_id\" => $user[\"id\"],\n\t\t\t\t\t\t\"session\" => $session,\n\t\t\t\t\t\t\"chain\" => $chain,\n\t\t\t\t\t\t\"stay_logged_in\" => $stay_logged_in,\n\t\t\t\t\t\t\"login_redirect\" => isset($_SESSION[\"bigtree_login_redirect\"]) ? $_SESSION[\"bigtree_login_redirect\"] : false,\n\t\t\t\t\t\t\"remaining_sites\" => array(),\n\t\t\t\t\t\t\"csrf_token\" => $csrf_token,\n\t\t\t\t\t\t\"csrf_token_field\" => $csrf_token_field\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\tforeach ($bigtree[\"config\"][\"sites\"] as $site_key => $site_configuration) {\n\t\t\t\t\t\t$cache_data[\"remaining_sites\"][$site_key] = $site_configuration[\"www_root\"];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$cache_session_key = BigTreeCMS::cacheUnique(\"org.bigtreecms.login-session\", $cache_data);\n\t\t\t\t\t$next_site = array_shift(array_values($cache_data[\"remaining_sites\"]));\n\t\t\t\t\t\n\t\t\t\t\t// Start the login chain\n\t\t\t\t\tBigTree::redirect($next_site.\"?bigtree_login_redirect_session_key=\".$cache_session_key);\n\t\t\t\t} else {\n\t\t\t\t\t$cookie_domain = str_replace(DOMAIN,\"\",WWW_ROOT);\n\t\t\t\t\t$cookie_value = json_encode(array($session, $chain));\n\t\t\t\t\t\n\t\t\t\t\t// We still set the email for BigTree bar usage even if they're not being \"remembered\"\n\t\t\t\t\tsetcookie('bigtree_admin[email]', $user[\"email\"], strtotime(\"+1 month\"), $cookie_domain, \"\", false, true);\n\t\t\t\t\t\n\t\t\t\t\tif ($stay_logged_in) {\n\t\t\t\t\t\tsetcookie('bigtree_admin[login]', $cookie_value, strtotime(\"+1 month\"), $cookie_domain, \"\", false, true);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"id\"] = $user[\"id\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"email\"] = $user[\"email\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"level\"] = $user[\"level\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"name\"] = $user[\"name\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"permissions\"] = json_decode($user[\"permissions\"],true);\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token\"] = $csrf_token;\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token_field\"] = $csrf_token_field;\n\t\t\t\t\t\n\t\t\t\t\tif (isset($_SESSION[\"bigtree_login_redirect\"])) {\n\t\t\t\t\t\tBigTree::redirect($_SESSION[\"bigtree_login_redirect\"]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tBigTree::redirect(ADMIN_ROOT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Log it as a failed attempt for a user if the email address matched\n\t\t\t\tif ($user) {\n\t\t\t\t\t$user_id = \"'\".$user[\"id\"].\"'\";\n\t\t\t\t} else {\n\t\t\t\t\t$user_id = \"NULL\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_login_attempts (`ip`,`user`) VALUES ('$ip', $user_id)\");\n\n\t\t\t\t// See if this attempt earns the user a ban - first verify the policy is completely filled out (3 parts)\n\t\t\t\tif ($user[\"id\"] && count(array_filter((array)$bigtree[\"security-policy\"][\"user_fails\"])) == 3) {\n\t\t\t\t\t$p = $bigtree[\"security-policy\"][\"user_fails\"];\n\t\t\t\t\t$r = sqlrows(sqlquery(\"SELECT * FROM bigtree_login_attempts WHERE `user` = $user_id AND `timestamp` >= DATE_SUB(NOW(),INTERVAL \".$p[\"time\"].\" MINUTE)\"));\n\t\t\t\t\t\n\t\t\t\t\t// Earned a ban\n\t\t\t\t\tif ($r >= $p[\"count\"]) {\n\t\t\t\t\t\t// See if they have an existing ban that hasn't expired, if so, extend it\n\t\t\t\t\t\t$existing = sqlfetch(sqlquery(\"SELECT * FROM bigtree_login_bans WHERE `user` = $user_id AND expires >= NOW()\"));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ($existing) {\n\t\t\t\t\t\t\tsqlquery(\"UPDATE bigtree_login_bans SET expires = DATE_ADD(NOW(),INTERVAL \".$p[\"ban\"].\" MINUTE) WHERE id = '\".$existing[\"id\"].\"'\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_login_bans (`ip`,`user`,`expires`) VALUES ('$ip', $user_id, DATE_ADD(NOW(), INTERVAL \".$p[\"ban\"].\" MINUTE))\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$bigtree[\"ban_expiration\"] = date(\"F j, Y @ g:ia\",strtotime(\"+\".$p[\"ban\"].\" minutes\"));\n\t\t\t\t\t\t$bigtree[\"ban_is_user\"] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// See if this attempt earns the IP as a whole a ban - first verify the policy is completely filled out (3 parts)\n\t\t\t\tif (count(array_filter((array)$bigtree[\"security-policy\"][\"ip_fails\"])) == 3) {\n\t\t\t\t\t$p = $bigtree[\"security-policy\"][\"ip_fails\"];\n\t\t\t\t\t$r = sqlrows(sqlquery(\"SELECT * FROM bigtree_login_attempts WHERE `ip` = '$ip' AND `timestamp` >= DATE_SUB(NOW(),INTERVAL \".$p[\"time\"].\" MINUTE)\"));\n\t\t\t\t\t\n\t\t\t\t\t// Earned a ban\n\t\t\t\t\tif ($r >= $p[\"count\"]) {\n\t\t\t\t\t\t$existing = sqlfetch(sqlquery(\"SELECT * FROM bigtree_login_bans WHERE `ip` = '$ip' AND expires >= NOW()\"));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ($existing) {\n\t\t\t\t\t\t\tsqlquery(\"UPDATE bigtree_login_bans SET expires = DATE_ADD(NOW(),INTERVAL \".$p[\"ban\"].\" HOUR) WHERE id = '\".$existing[\"id\"].\"'\");\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_login_bans (`ip`,`expires`) VALUES ('$ip',DATE_ADD(NOW(),INTERVAL \".$p[\"ban\"].\" HOUR))\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$bigtree[\"ban_expiration\"] = date(\"F j, Y @ g:ia\", strtotime(\"+\".$p[\"ban\"].\" hours\"));\n\t\t\t\t\t\t$bigtree[\"ban_is_user\"] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tstatic function loginSession($session_key) {\n\t\t\t$cache_data = BigTreeCMS::cacheGet(\"org.bigtreecms.login-session\", $session_key);\n\t\t\t$user = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE id = '\".$cache_data[\"user_id\"].\"'\"));\n\t\t\t\n\t\t\tforeach ($cache_data[\"remaining_sites\"] as $site_key => $www_root) {\n\t\t\t\tif ($site_key == BIGTREE_SITE_KEY) {\n\t\t\t\t\t$cookie_domain = str_replace(DOMAIN, \"\", WWW_ROOT);\n\t\t\t\t\t$cookie_value = json_encode(array($cache_data[\"session\"], $cache_data[\"chain\"]));\n\n\t\t\t\t\t// We still set the email for BigTree bar usage even if they're not being \"remembered\"\n\t\t\t\t\tsetcookie('bigtree_admin[email]', $user[\"email\"], strtotime(\"+1 month\"), $cookie_domain, \"\", false, true);\n\t\t\t\t\t\n\t\t\t\t\tif ($cache_data[\"stay_logged_in\"]) {\n\t\t\t\t\t\tsetcookie('bigtree_admin[login]', $cookie_value, strtotime(\"+1 month\"), $cookie_domain, \"\", false, true);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"id\"] = $user[\"id\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"email\"] = $user[\"email\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"level\"] = $user[\"level\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"name\"] = $user[\"name\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"permissions\"] = json_decode($user[\"permissions\"], true);\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token\"] = $cache_data[\"csrf_token\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token_field\"] = $cache_data[\"csrf_token_field\"];\n\t\t\t\t\t\n\t\t\t\t\tunset($cache_data[\"remaining_sites\"][$site_key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (count($cache_data[\"remaining_sites\"]) == 0) {\n\t\t\t\t// Done logging in, delete session\n\t\t\t\tBigTreeCMS::cacheDelete(\"org.bigtreecms.login-session\", $session_key);\n\t\t\t\t\n\t\t\t\tif (!empty($cache_data[\"login_redirect\"])) {\n\t\t\t\t\tBigTree::redirect($cache_data[\"login_redirect\"]);\n\t\t\t\t} else {\n\t\t\t\t\tBigTree::redirect(ADMIN_ROOT);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$next_site = array_shift(array_values($cache_data[\"remaining_sites\"]));\n\t\t\t\tBigTreeCMS::cachePut(\"org.bigtreecms.login-session\", $session_key, $cache_data);\n\t\t\t\t\n\t\t\t\t// Redirect to the next site that needs a session/cookie\n\t\t\t\tBigTree::redirect($next_site.\"?bigtree_login_redirect_session_key=\".$session_key);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: logout\n\t\t\t\tLogs out of the CMS.\n\t\t\t\tDestroys the user's session and unsets the login cookies, then sends the user back to the login page.\n\t\t*/\n\n\t\tstatic function logout() {\n\t\t\t// If the user asked to be remembered, drop their chain from the legit sessions and remove cookies\n\t\t\tif (!empty($_COOKIE[\"bigtree_admin\"][\"login\"])) {\n\t\t\t\tlist($session,$chain) = json_decode($_COOKIE[\"bigtree_admin\"][\"login\"], true);\n\n\t\t\t\t// Make sure this session/chain is legit before removing everything with the given chain\n\t\t\t\t$chain = sqlescape($chain);\n\t\t\t\t$session = sqlescape($session);\n\n\t\t\t\tif (sqlrows(sqlquery(\"SELECT * FROM bigtree_user_sessions WHERE id = '$session' AND chain = '$chain'\"))) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_user_sessions WHERE chain = '$chain'\");\n\t\t\t\t}\n\n\t\t\t\tsetcookie(\"bigtree_admin[email]\",\"\",time()-3600,str_replace(DOMAIN,\"\",WWW_ROOT));\n\t\t\t\tsetcookie(\"bigtree_admin[login]\",\"\",time()-3600,str_replace(DOMAIN,\"\",WWW_ROOT));\n\t\t\t}\n\n\t\t\tunset($_COOKIE[\"bigtree_admin\"]);\n\t\t\tunset($_SESSION[\"bigtree_admin\"]);\n\n\t\t\tBigTree::redirect(ADMIN_ROOT);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: makeIPL\n\t\t\t\tCreates an internal page link out of a URL.\n\n\t\t\tParameters:\n\t\t\t\turl - A URL\n\n\t\t\tReturns:\n\t\t\t\tAn internal page link (if possible) or just the same URL (if it's not internal).\n\t\t*/\n\n\t\tstatic function makeIPL($url) {\n\t\t\t$path_components = explode(\"/\", rtrim(str_replace(WWW_ROOT, \"\", $url), \"/\"));\n\t\t\t\n\t\t\t// See if this is a file\n\t\t\t$local_path = str_replace(WWW_ROOT,SITE_ROOT,$url);\n\t\t\t\n\t\t\tif (($path_components[0] != \"files\" || $path_components[1] != \"resources\") && \n\t\t\t\t(substr($local_path,0,1) == \"/\" || substr($local_path,0,2) == \"\\\\\\\\\") && \n\t\t\t\tfile_exists($local_path)) {\n\t\t\t\t\n\t\t\t\treturn BigTreeCMS::replaceHardRoots($url);\n\t\t\t}\n\n\t\t\t// If we have multiple sites, try each domain\n\t\t\tif (defined(\"BIGTREE_SITE_KEY\")) {\n\t\t\t\tglobal $bigtree;\n\t\t\t\t\n\t\t\t\tforeach ($bigtree[\"config\"][\"sites\"] as $site_key => $configuration) {\n\t\t\t\t\t// This is the site we're pointing to\n\t\t\t\t\tif (strpos($url, $configuration[\"www_root\"]) !== false) {\n\t\t\t\t\t\t$path_components = explode(\"/\", rtrim(str_replace($configuration[\"www_root\"], \"\", $url), \"/\"));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Check for resource link\n\t\t\t\t\t\tif ($path_components[0] == \"files\" && $path_components[1] == \"resources\") {\n\t\t\t\t\t\t\t$resource = static::getResourceByFile($url);\n\n\t\t\t\t\t\t\tif ($resource) {\n\t\t\t\t\t\t\t\tstatic::$IRLsCreated[] = $resource[\"id\"];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\treturn \"irl://\".$resource[\"id\"].\"//\".$resource[\"prefix\"];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the root path of the site for calculating an IPL and add it to the path components\n\t\t\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT path FROM bigtree_pages WHERE id = '\".$configuration[\"trunk\"].\"'\"));\n\t\t\t\t\t\t$path_components = array_filter(array_merge(explode(\"/\", $f[\"path\"]), $path_components));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Check for page link\n\t\t\t\t\t\tlist($navid, $commands) = static::getPageIDForPath($path_components);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ($navid) {\n\t\t\t\t\t\t\treturn \"ipl://\".$navid.\"//\".base64_encode(json_encode($commands));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn BigTreeCMS::replaceHardRoots($url);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn BigTreeCMS::replaceHardRoots($url);\n\t\t\t} else {\n\t\t\t\t// Check for resource link\n\t\t\t\tif ($path_components[0] == \"files\" && $path_components[1] == \"resources\") {\n\t\t\t\t\t$resource = static::getResourceByFile($url);\n\t\t\t\t\tif ($resource) {\n\t\t\t\t\t\tstatic::$IRLsCreated[] = $resource[\"id\"];\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn \"irl://\".$resource[\"id\"].\"//\".$resource[\"prefix\"];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check for page link\n\t\t\t\tlist($navid, $commands) = static::getPageIDForPath($path_components);\n\t\t\t}\n\t\t\t\n\t\t\tif (!$navid) {\n\t\t\t\treturn BigTreeCMS::replaceHardRoots($url);\n\t\t\t}\n\t\t\t\n\t\t\treturn \"ipl://\".$navid.\"//\".base64_encode(json_encode($commands));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: markMessageRead\n\t\t\t\tMarks a message as read by the currently logged in user.\n\n\t\t\tParameters:\n\t\t\t\tid - The message id.\n\t\t*/\n\n\t\tfunction markMessageRead($id) {\n\t\t\t$message = $this->getMessage($id);\n\t\t\tif (!$message) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$read_by = str_replace(\"|\".$this->ID.\"|\",\"\",$message[\"read_by\"]).\"|\".$this->ID.\"|\";\n\t\t\tsqlquery(\"UPDATE bigtree_messages SET read_by = '\".sqlescape($read_by).\"' WHERE id = '\".$message[\"id\"].\"'\");\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: matchResourceMD5\n\t\t\t\tChecks if the given file is a MD5 match for any existing resources.\n\t\t\t\tIf a match is found, the resource is \"copied\" into the given folder (unless it already exists in that folder).\n\n\t\t\tParameters:\n\t\t\t\tfile - Uploaded file to run MD5 hash on\n\t\t\t\tnew_folder - Folder the given file is being uploaded into\n\n\t\t\tReturns:\n\t\t\t\ttrue if a match was found. If the file was already in the given folder, the date is simply updated.\n\t\t*/\n\n\t\tstatic function matchResourceMD5($file,$new_folder) {\n\t\t\t$md5 = sqlescape(md5_file($file));\n\t\t\t$resource = sqlfetch(sqlquery(\"SELECT * FROM bigtree_resources WHERE md5 = '$md5' LIMIT 1\"));\n\t\t\tif (!$resource) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If we already have this exact resource in this exact folder, just update its modification time\n\t\t\tif ($resource[\"folder\"] == $new_folder) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_resources SET date = NOW() WHERE id = '\".$resource[\"id\"].\"'\");\n\t\t\t} else {\n\t\t\t\tforeach ($resource as $key => $val) {\n\t\t\t\t\t$$key = \"'\".sqlescape($val).\"'\";\n\t\t\t\t}\n\t\t\t\t$new_folder = $new_folder ? \"'\".sqlescape($new_folder).\"'\" : \"NULL\";\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_resources (`folder`,`file`,`md5`,`date`,`name`,`type`,`is_image`,`height`,`width`,`crops`,`thumbs`,`list_thumb_margin`) VALUES ($new_folder,$file,$md5,NOW(),$name,$type,$is_image,$height,$width,$crops,$thumbs,$list_thumb_margin)\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: pageChangeExists\n\t\t\t\tReturns whether pending changes exist for a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\n\t\t\tReturns:\n\t\t\t\ttrue or false\n\t\t*/\n\n\t\tstatic function pageChangeExists($page) {\n\t\t\t$page = sqlescape($page);\n\t\t\t$c = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND item_id = '$page'\"));\n\t\t\tif (!$c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: pingSearchEngines\n\t\t\t\tSends the latest sitemap.xml out to search engine ping services if enabled in settings.\n\t\t*/\n\n\t\tstatic function pingSearchEngines() {\n\t\t\t$setting = static::getSetting(\"ping-search-engines\");\n\t\t\tif ($setting[\"value\"] == \"on\") {\n\t\t\t\t// Google\n\t\t\t\tfile_get_contents(\"http://www.google.com/webmasters/tools/ping?sitemap=\".urlencode(WWW_ROOT.\"sitemap.xml\"));\n\t\t\t\t// Bing\n\t\t\t\tfile_get_contents(\"http://www.bing.com/webmaster/ping.aspx?siteMap=\".urlencode(WWW_ROOT.\"sitemap.xml\"));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: processCrops\n\t\t\t\tProcesses a list of cropped images.\n\n\t\t\tParameters:\n\t\t\t\tcrop_key - A cache key pointing to the location of crop data.\n\t\t*/\n\n\t\tstatic function processCrops($crop_key) {\n\t\t\t$storage = new BigTreeStorage;\n\n\t\t\t// Get and remove the crop data\n\t\t\t$crops = BigTreeCMS::cacheGet(\"org.bigtreecms.crops\",$crop_key);\n\t\t\tBigTreeCMS::cacheDelete(\"org.bigtreecms.crops\",$crop_key);\n\n\t\t\tforeach ($crops as $key => $crop) {\n\t\t\t\t$image_src = $crop[\"image\"];\n\t\t\t\t$target_width = $crop[\"width\"];\n\t\t\t\t$target_height = $crop[\"height\"];\n\t\t\t\t$x = $_POST[\"x\"][$key];\n\t\t\t\t$y = $_POST[\"y\"][$key];\n\t\t\t\t$width = $_POST[\"width\"][$key];\n\t\t\t\t$height = $_POST[\"height\"][$key];\n\t\t\t\t$thumbs = $crop[\"thumbs\"];\n\t\t\t\t$center_crops = $crop[\"center_crops\"];\n\n\t\t\t\t$pinfo = pathinfo($image_src);\n\n\t\t\t\t// Create the crop and put it in a temporary location\n\t\t\t\t$temp_crop = SITE_ROOT.\"files/\".uniqid(\"temp-\").\".\".$pinfo[\"extension\"];\n\t\t\t\tBigTree::createCrop($image_src,$temp_crop,$x,$y,$target_width,$target_height,$width,$height,$crop[\"retina\"],$crop[\"grayscale\"]);\n\t\t\t\t\n\t\t\t\t// Make thumbnails for the crop\n\t\t\t\tif (is_array($thumbs)) {\n\t\t\t\t\tforeach ($thumbs as $thumb) {\n\t\t\t\t\t\tif (is_array($thumb) && ($thumb[\"height\"] || $thumb[\"width\"])) {\n\t\t\t\t\t\t\t// We're going to figure out what size the thumbs will be so we can re-crop the original image so we don't lose image quality.\n\t\t\t\t\t\t\tlist($type,$w,$h,$result_width,$result_height) = BigTree::getThumbnailSizes($temp_crop,$thumb[\"width\"],$thumb[\"height\"]);\n\n\t\t\t\t\t\t\t$temp_thumb = SITE_ROOT.\"files/\".uniqid(\"temp-\").\".\".$pinfo[\"extension\"];\n\t\t\t\t\t\t\tBigTree::createCrop($image_src,$temp_thumb,$x,$y,$result_width,$result_height,$width,$height,$crop[\"retina\"],$thumb[\"grayscale\"]);\n\t\t\t\t\t\t\t$storage->replace($temp_thumb,$thumb[\"prefix\"].$crop[\"name\"],$crop[\"directory\"]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Make center crops of the crop\n\t\t\t\tif (is_array($center_crops)) {\n\t\t\t\t\tforeach ($center_crops as $center_crop) {\n\t\t\t\t\t\tif (is_array($center_crop) && $center_crop[\"height\"] && $center_crop[\"width\"]) {\n\t\t\t\t\t\t\t$temp_center_crop = SITE_ROOT.\"files/\".uniqid(\"temp-\").\".\".$pinfo[\"extension\"];\n\t\t\t\t\t\t\tBigTree::centerCrop($temp_crop,$temp_center_crop,$center_crop[\"width\"],$center_crop[\"height\"],$crop[\"retina\"],$center_crop[\"grayscale\"]);\n\t\t\t\t\t\t\t$storage->replace($temp_center_crop,$center_crop[\"prefix\"].$crop[\"name\"],$crop[\"directory\"]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Move crop into its resting place\n\t\t\t\t$storage->replace($temp_crop,$crop[\"prefix\"].$crop[\"name\"],$crop[\"directory\"]);\n\t\t\t}\n\n\t\t\t// Remove all the temporary images\n\t\t\tforeach ($crops as $crop) {\n\t\t\t\t@unlink($crop[\"image\"]);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: processField\n\t\t\t\tA helper function for field type processing.\n\n\t\t\tParameters:\n\t\t\t\tfield - Field information\n\n\t\t\tReturns:\n\t\t\t\tField output.\n\t\t*/\n\n\t\tstatic function processField($field) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\n\t\t\t// Save current context\n\t\t\t$bigtree[\"saved_extension_context\"] = $bigtree[\"extension_context\"];\n\n\t\t\t// Check if the field type is stored in an extension\n\t\t\tif (strpos($field[\"type\"],\"*\") !== false) {\n\t\t\t\tlist($extension,$field_type) = explode(\"*\",$field[\"type\"]);\n\n\t\t\t\t$bigtree[\"extension_context\"] = $extension;\n\t\t\t\t$field_type_path = SERVER_ROOT.\"extensions/$extension/field-types/$field_type/process.php\";\n\t\t\t} else {\n\t\t\t\t$field_type_path = BigTree::path(\"admin/form-field-types/process/\".$field[\"type\"].\".php\");\n\t\t\t}\n\n\t\t\t// If we have a customized handler for this data type, run it.\n\t\t\tif (file_exists($field_type_path)) {\n\t\t\t\tinclude $field_type_path;\n\n\t\t\t\t// If it's explicitly ignored return null\n\t\t\t\tif ($field[\"ignore\"]) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t$output = $field[\"output\"];\n\t\t\t\t}\n\n\t\t\t// Fall back to default handling\n\t\t\t} else {\n\t\t\t\tif (is_array($field[\"input\"])) {\n\t\t\t\t\t$output = $field[\"input\"];\n\t\t\t\t} else {\n\t\t\t\t\t$output = BigTree::safeEncode($field[\"input\"]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check validation\n\t\t\tif (!BigTreeAutoModule::validate($output,$field[\"options\"][\"validation\"])) {\n\t\t\t\t$error = $field[\"options\"][\"error_message\"] ? $field[\"options\"][\"error_message\"] : BigTreeAutoModule::validationErrorMessage($output,$field[\"options\"][\"validation\"]);\n\t\t\t\t$bigtree[\"errors\"][] = array(\n\t\t\t\t\t\"field\" => $field[\"title\"],\n\t\t\t\t\t\"error\" => $error\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Translation of internal links\n\t\t\tif (is_array($output)) {\n\t\t\t\t$output = BigTree::translateArray($output);\n\t\t\t} else {\n\t\t\t\t$output = $admin->autoIPL($output);\n\t\t\t}\n\n\t\t\t// Restore context\n\t\t\t$bigtree[\"extension_context\"] = $bigtree[\"saved_extension_context\"];\n\n\t\t\treturn $output;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: processImageUpload\n\t\t\t\tProcesses image upload data for form fields.\n\t\t\t\tIf you're emulating field information, the following keys are of interest in the field array:\n\t\t\t\t\"file_input\" - a keyed array that needs at least \"name\" and \"tmp_name\" keys that contain the desired name of the file and the source file location, respectively.\n\t\t\t\t\"options\" - a keyed array of options for the field, keys of interest for photo processing are:\n\t\t\t\t\t\"min_height\" - Minimum Height required for the image\n\t\t\t\t\t\"min_width\" - Minimum Width required for the image\n\t\t\t\t\t\"retina\" - Whether to try to create a 2x size image when thumbnailing / cropping (if the source file / crop is large enough)\n\t\t\t\t\t\"thumbs\" - An array of thumbnail arrays, each of which has \"prefix\", \"width\", \"height\", and \"grayscale\" keys (prefix is prepended to the file name when creating the thumbnail, grayscale will make the thumbnail grayscale)\n\t\t\t\t\t\"crops\" - An array of crop arrays, each of which has \"prefix\", \"width\", \"height\" and \"grayscale\" keys (prefix is prepended to the file name when creating the crop, grayscale will make the thumbnail grayscale)). Crops can also have their own \"thumbs\" key that creates thumbnails of each crop (format mirrors that of \"thumbs\")\n\n\t\t\tParameters:\n\t\t\t\tfield - Field information (normally set to $field when running a field type's process file)\n\t\t*/\n\n\t\tstatic function processImageUpload($field) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$failed = false;\n\t\t\t$name = $field[\"file_input\"][\"name\"];\n\t\t\t$temp_name = $field[\"file_input\"][\"tmp_name\"];\n\t\t\t$error = $field[\"file_input\"][\"error\"];\n\n\t\t\t// If a file upload error occurred, return the old image and set errors\n\t\t\tif ($error == 1 || $error == 2) {\n\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"The file you uploaded ($name) was too large &mdash; <strong>Max file size: \".ini_get(\"upload_max_filesize\").\"</strong>\");\n\t\t\t\treturn false;\n\t\t\t} elseif ($error == 3) {\n\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"The file upload failed ($name).\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// We're going to tell BigTreeStorage to handle forcing images into JPEGs instead of writing the code 20x\n\t\t\t$storage = new BigTreeStorage;\n\t\t\t$storage->AutoJPEG = $bigtree[\"config\"][\"image_force_jpeg\"];\n\n\t\t\t// Let's check the minimum requirements for the image first before we store it anywhere.\n\t\t\t$image_info = @getimagesize($temp_name);\n\t\t\t$iwidth = $image_info[0];\n\t\t\t$iheight = $image_info[1];\n\t\t\t$itype = $image_info[2];\n\t\t\t$channels = $image_info[\"channels\"];\n\n\t\t\t// See if we're using image presets\n\t\t\tif ($field[\"options\"][\"preset\"]) {\n\t\t\t\t$media_settings = BigTreeCMS::getSetting(\"bigtree-internal-media-settings\");\n\t\t\t\t$preset = $media_settings[\"presets\"][$field[\"options\"][\"preset\"]];\n\t\t\t\t// If the preset still exists, copy its properties over to our options\n\t\t\t\tif ($preset) {\n\t\t\t\t\tforeach ($preset as $key => $val) {\n\t\t\t\t\t\t$field[\"options\"][$key] = $val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the minimum height or width is not meant, do NOT let the image through. Erase the change or update from the database.\n\t\t\tif ((isset($field[\"options\"][\"min_height\"]) && $iheight < $field[\"options\"][\"min_height\"]) || (isset($field[\"options\"][\"min_width\"]) && $iwidth < $field[\"options\"][\"min_width\"])) {\n\t\t\t\t$error = \"Image uploaded (\".htmlspecialchars($name).\") did not meet the minimum size of \";\n\t\t\t\tif ($field[\"options\"][\"min_height\"] && $field[\"options\"][\"min_width\"]) {\n\t\t\t\t\t$error .= $field[\"options\"][\"min_width\"].\"x\".$field[\"options\"][\"min_height\"].\" pixels.\";\n\t\t\t\t} elseif ($field[\"options\"][\"min_height\"]) {\n\t\t\t\t\t$error .= $field[\"options\"][\"min_height\"].\" pixels tall.\";\n\t\t\t\t} elseif ($field[\"options\"][\"min_width\"]) {\n\t\t\t\t\t$error .= $field[\"options\"][\"min_width\"].\" pixels wide.\";\n\t\t\t\t}\n\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => $error);\n\t\t\t\t$failed = true;\n\t\t\t}\n\n\t\t\t// If it's not a valid image, throw it out!\n\t\t\tif ($itype != IMAGETYPE_GIF && $itype != IMAGETYPE_JPEG && $itype != IMAGETYPE_PNG) {\n\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"An invalid file was uploaded. Valid file types: JPG, GIF, PNG.\");\n\t\t\t\t$failed = true;\n\t\t\t}\n\n\t\t\t// See if it's CMYK\n\t\t\tif ($channels == 4) {\n\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"A CMYK encoded file was uploaded. Please upload an RBG image.\");\n\t\t\t\t$failed = true;\n\t\t\t}\n\n\t\t\t// See if we have enough memory for all our crops and thumbnails\n\t\t\tif (!$failed && ((is_array($field[\"options\"][\"crops\"]) && count($field[\"options\"][\"crops\"])) || (is_array($field[\"options\"][\"thumbs\"]) && count($field[\"options\"][\"thumbs\"])))) {\n\t\t\t\tif (is_array($field[\"options\"][\"crops\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"crops\"] as $crop) {\n\t\t\t\t\t\tif (!$failed && is_array($crop) && array_filter($crop)) {\n\t\t\t\t\t\t\tif ($field[\"options\"][\"retina\"]) {\n\t\t\t\t\t\t\t\t$crop[\"width\"] *= 2;\n\t\t\t\t\t\t\t\t$crop[\"height\"] *= 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// We don't want to add multiple errors so we check if we've already failed\n\t\t\t\t\t\t\tif (!BigTree::imageManipulationMemoryAvailable($temp_name,$crop[\"width\"],$crop[\"height\"],$iwidth,$iheight)) {\n\t\t\t\t\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"Image uploaded is too large for the server to manipulate. Please upload a smaller version of this image.\");\n\t\t\t\t\t\t\t\t$failed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (is_array($field[\"options\"][\"thumbs\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"thumbs\"] as $thumb) {\n\t\t\t\t\t\t// We don't want to add multiple errors and we also don't want to waste effort getting thumbnail sizes if we already failed.\n\t\t\t\t\t\tif (!$failed && is_array($thumb) && array_filter($thumb)) {\n\t\t\t\t\t\t\tif ($field[\"options\"][\"retina\"]) {\n\t\t\t\t\t\t\t\t$thumb[\"width\"] *= 2;\n\t\t\t\t\t\t\t\t$thumb[\"height\"] *= 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$sizes = BigTree::getThumbnailSizes($temp_name,$thumb[\"width\"],$thumb[\"height\"]);\n\t\t\t\t\t\t\tif (!BigTree::imageManipulationMemoryAvailable($temp_name,$sizes[3],$sizes[4],$iwidth,$iheight)) {\n\t\t\t\t\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"Image uploaded is too large for the server to manipulate. Please upload a smaller version of this image.\");\n\t\t\t\t\t\t\t\t$failed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (is_array($field[\"options\"][\"center_crops\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"center_crops\"] as $crop) {\n\t\t\t\t\t\t// We don't want to add multiple errors and we also don't want to waste effort getting thumbnail sizes if we already failed.\n\t\t\t\t\t\tif (!$failed && is_array($crop) && array_filter($crop)) {\n\t\t\t\t\t\t\tlist($w,$h) = getimagesize($temp_name);\n\t\t\t\t\t\t\tif (!BigTree::imageManipulationMemoryAvailable($temp_name,$w,$h,$crop[\"width\"],$crop[\"height\"])) {\n\t\t\t\t\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"Image uploaded is too large for the server to manipulate. Please upload a smaller version of this image.\");\n\t\t\t\t\t\t\t\t$failed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$failed) {\n\t\t\t\t// Make a temporary copy to be used for thumbnails and crops.\n\t\t\t\t$itype_exts = array(IMAGETYPE_PNG => \".png\", IMAGETYPE_JPEG => \".jpg\", IMAGETYPE_GIF => \".gif\");\n\n\t\t\t\t// Make a first copy\n\t\t\t\t$first_copy = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\tBigTree::moveFile($temp_name,$first_copy);\n\n\t\t\t\t// Do EXIF Image Rotation\n\t\t\t\tif ($itype == IMAGETYPE_JPEG && function_exists(\"exif_read_data\")) {\n\t\t\t\t\t$exif = @exif_read_data($first_copy);\n\t\t\t\t\t$o = $exif['Orientation'];\n\t\t\t\t\tif ($o == 3 || $o == 6 || $o == 8) {\n\t\t\t\t\t\t$source = imagecreatefromjpeg($first_copy);\n\n\t\t\t\t\t\tif ($o == 3) {\n\t\t\t\t\t\t\t$source = imagerotate($source,180,0);\n\t\t\t\t\t\t} elseif ($o == 6) {\n\t\t\t\t\t\t\t$source = imagerotate($source,270,0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$source = imagerotate($source,90,0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We're going to create a PNG so that we don't lose quality when we resave\n\t\t\t\t\t\timagepng($source,$first_copy);\n\t\t\t\t\t\trename($first_copy,substr($first_copy,0,-3).\"png\");\n\t\t\t\t\t\t$first_copy = substr($first_copy,0,-3).\"png\";\n\n\t\t\t\t\t\t// Force JPEG since we made the first copy a PNG\n\t\t\t\t\t\t$storage->AutoJPEG = true;\n\n\t\t\t\t\t\t// Clean up memory\n\t\t\t\t\t\timagedestroy($source);\n\n\t\t\t\t\t\t// Get new width/height/type\n\t\t\t\t\t\tlist($iwidth,$iheight,$itype,$iattr) = getimagesize($first_copy);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create a temporary copy that we will use later for crops and thumbnails\n\t\t\t\t$temp_copy = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\tBigTree::copyFile($first_copy,$temp_copy);\n\n\t\t\t\t// Gather up an array of file prefixes\n\t\t\t\t$prefixes = array();\n\t\t\t\tif (is_array($field[\"options\"][\"thumbs\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"thumbs\"] as $thumb) {\n\t\t\t\t\t\tif (!empty($thumb[\"prefix\"])) {\n\t\t\t\t\t\t\t$prefixes[] = $thumb[\"prefix\"];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (is_array($field[\"options\"][\"center_crops\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"center_crops\"] as $crop) {\n\t\t\t\t\t\tif (!empty($crop[\"prefix\"])) {\n\t\t\t\t\t\t\t$prefixes[] = $crop[\"prefix\"];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (is_array($field[\"options\"][\"crops\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"crops\"] as $crop) {\n\t\t\t\t\t\tif (is_array($crop)) {\n\t\t\t\t\t\t\tif (!empty($crop[\"prefix\"])) {\n\t\t\t\t\t\t\t\t$prefixes[] = $crop[\"prefix\"];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (is_array($crop[\"thumbs\"])) {\n\t\t\t\t\t\t\t\tforeach ($crop[\"thumbs\"] as $thumb) {\n\t\t\t\t\t\t\t\t\tif (!empty($thumb[\"prefix\"])) {\n\t\t\t\t\t\t\t\t\t\t$prefixes[] = $thumb[\"prefix\"];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (is_array($crop[\"center_crops\"])) {\n\t\t\t\t\t\t\t\tforeach ($crop[\"center_crops\"] as $center_crop) {\n\t\t\t\t\t\t\t\t\tif (!empty($center_crop[\"prefix\"])) {\n\t\t\t\t\t\t\t\t\t\t$prefixes[] = $center_crop[\"prefix\"];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Upload the original to the proper place.\n\t\t\t\t$field[\"output\"] = $storage->store($first_copy,$name,$field[\"options\"][\"directory\"],true,$prefixes);\n\n \t\t\t\t// If the upload service didn't return a value, we failed to upload it for one reason or another.\n \t\t\t\tif (!$field[\"output\"]) {\n \t\t\t\t\tif ($storage->DisabledFileError) {\n\t\t\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"Could not upload file. The file extension is not allowed.\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"Could not upload file. The destination is not writable.\");\n\t\t\t\t\t}\n\t\t\t\t\tunlink($temp_copy);\n\t\t\t\t\tunlink($first_copy);\n\n\t\t\t\t\t// Failed, we keep the current value\n\t\t\t\t\treturn false;\n\t\t\t\t// If we did upload it successfully, check on thumbs and crops.\n\t\t\t\t} else {\n\t\t\t\t\t// Get path info on the file.\n\t\t\t\t\t$pinfo = BigTree::pathInfo($field[\"output\"]);\n\n\t\t\t\t\t// Handle Crops\n\t\t\t\t\tif (is_array($field[\"options\"][\"crops\"])) {\n\t\t\t\t\t\tforeach ($field[\"options\"][\"crops\"] as $crop) {\n\t\t\t\t\t\t\tif (is_array($crop)) {\n\t\t\t\t\t\t\t\t// Make sure the crops have a width/height and it's numeric\n\t\t\t\t\t\t\t\tif ($crop[\"width\"] && $crop[\"height\"] && is_numeric($crop[\"width\"]) && is_numeric($crop[\"height\"])) {\n\t\t\t\t\t\t\t\t\t$cwidth = $crop[\"width\"];\n\t\t\t\t\t\t\t\t\t$cheight = $crop[\"height\"];\n\t\t\n\t\t\t\t\t\t\t\t\t// Check to make sure each dimension is greater then or equal to, but not both equal to the crop.\n\t\t\t\t\t\t\t\t\tif (($iheight >= $cheight && $iwidth > $cwidth) || ($iwidth >= $cwidth && $iheight > $cheight)) {\n\t\t\t\t\t\t\t\t\t\t// Make a square if for some reason someone only entered one dimension for a crop.\n\t\t\t\t\t\t\t\t\t\tif (!$cwidth) {\n\t\t\t\t\t\t\t\t\t\t\t$cwidth = $cheight;\n\t\t\t\t\t\t\t\t\t\t} elseif (!$cheight) {\n\t\t\t\t\t\t\t\t\t\t\t$cheight = $cwidth;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t$bigtree[\"crops\"][] = array(\n\t\t\t\t\t\t\t\t\t\t\t\"image\" => $temp_copy,\n\t\t\t\t\t\t\t\t\t\t\t\"directory\" => $field[\"options\"][\"directory\"],\n\t\t\t\t\t\t\t\t\t\t\t\"retina\" => $field[\"options\"][\"retina\"],\n\t\t\t\t\t\t\t\t\t\t\t\"name\" => $pinfo[\"basename\"],\n\t\t\t\t\t\t\t\t\t\t\t\"width\" => $cwidth,\n\t\t\t\t\t\t\t\t\t\t\t\"height\" => $cheight,\n\t\t\t\t\t\t\t\t\t\t\t\"prefix\" => $crop[\"prefix\"],\n\t\t\t\t\t\t\t\t\t\t\t\"thumbs\" => $crop[\"thumbs\"],\n\t\t\t\t\t\t\t\t\t\t\t\"center_crops\" => $crop[\"center_crops\"],\n\t\t\t\t\t\t\t\t\t\t\t\"grayscale\" => $crop[\"grayscale\"]\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t// If it's the same dimensions, let's see if they're looking for a prefix for whatever reason...\n\t\t\t\t\t\t\t\t\t} elseif ($iheight == $cheight && $iwidth == $cwidth) {\n\t\t\t\t\t\t\t\t\t\t// See if we want thumbnails\n\t\t\t\t\t\t\t\t\t\tif (is_array($crop[\"thumbs\"])) {\n\t\t\t\t\t\t\t\t\t\t\tforeach ($crop[\"thumbs\"] as $thumb) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Make sure the thumbnail has a width or height and it's numeric\n\t\t\t\t\t\t\t\t\t\t\t\tif (($thumb[\"width\"] && is_numeric($thumb[\"width\"])) || ($thumb[\"height\"] && is_numeric($thumb[\"height\"]))) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Create a temporary thumbnail of the image on the server before moving it to it's destination.\n\t\t\t\t\t\t\t\t\t\t\t\t\t$temp_thumb = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\t\t\t\t\t\t\t\t\t\tBigTree::createThumbnail($temp_copy,$temp_thumb,$thumb[\"width\"],$thumb[\"height\"],$field[\"options\"][\"retina\"],$thumb[\"grayscale\"]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t// We use replace here instead of upload because we want to be 100% sure that this file name doesn't change.\n\t\t\t\t\t\t\t\t\t\t\t\t\t$storage->replace($temp_thumb,$thumb[\"prefix\"].$pinfo[\"basename\"],$field[\"options\"][\"directory\"]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t// See if we want center crops\n\t\t\t\t\t\t\t\t\t\tif (is_array($crop[\"center_crops\"])) {\n\t\t\t\t\t\t\t\t\t\t\tforeach ($crop[\"center_crops\"] as $center_crop) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Make sure the crop has a width and height and it's numeric\n\t\t\t\t\t\t\t\t\t\t\t\tif ($center_crop[\"width\"] && is_numeric($center_crop[\"width\"]) && $center_crop[\"height\"] && is_numeric($center_crop[\"height\"])) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Create a temporary crop of the image on the server before moving it to it's destination.\n\t\t\t\t\t\t\t\t\t\t\t\t\t$temp_crop = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\t\t\t\t\t\t\t\t\t\tBigTree::centerCrop($temp_copy,$temp_crop,$center_crop[\"width\"],$center_crop[\"height\"],$field[\"options\"][\"retina\"],$center_crop[\"grayscale\"]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t// We use replace here instead of upload because we want to be 100% sure that this file name doesn't change.\n\t\t\t\t\t\t\t\t\t\t\t\t\t$storage->replace($temp_crop,$center_crop[\"prefix\"].$pinfo[\"basename\"],$field[\"options\"][\"directory\"]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif ($crop[\"prefix\"]) {\n\t\t\t\t\t\t\t\t\t\t\t$storage->replace($temp_copy,$crop[\"prefix\"].$pinfo[\"basename\"],$field[\"options\"][\"directory\"],false,array(),true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle thumbnailing\n\t\t\t\t\tif (is_array($field[\"options\"][\"thumbs\"])) {\n\t\t\t\t\t\tforeach ($field[\"options\"][\"thumbs\"] as $thumb) {\n\t\t\t\t\t\t\t// Make sure the thumbnail has a width or height and it's numeric\n\t\t\t\t\t\t\tif (($thumb[\"width\"] && is_numeric($thumb[\"width\"])) || ($thumb[\"height\"] && is_numeric($thumb[\"height\"]))) {\n\t\t\t\t\t\t\t\t$temp_thumb = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\t\t\t\t\tBigTree::createThumbnail($temp_copy,$temp_thumb,$thumb[\"width\"],$thumb[\"height\"],$field[\"options\"][\"retina\"],$thumb[\"grayscale\"]);\n\t\t\t\t\t\t\t\t// We use replace here instead of upload because we want to be 100% sure that this file name doesn't change.\n\t\t\t\t\t\t\t\t$storage->replace($temp_thumb,$thumb[\"prefix\"].$pinfo[\"basename\"],$field[\"options\"][\"directory\"]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle center crops\n\t\t\t\t\tif (is_array($field[\"options\"][\"center_crops\"])) {\n\t\t\t\t\t\tforeach ($field[\"options\"][\"center_crops\"] as $crop) {\n\t\t\t\t\t\t\t// Make sure the crop has a width and height and it's numeric\n\t\t\t\t\t\t\tif ($crop[\"width\"] && is_numeric($crop[\"width\"]) && $crop[\"height\"] && is_numeric($crop[\"height\"])) {\n\t\t\t\t\t\t\t\t$temp_crop = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\t\t\t\t\tBigTree::centerCrop($temp_copy,$temp_crop,$crop[\"width\"],$crop[\"height\"],$field[\"options\"][\"retina\"],$crop[\"grayscale\"]);\n\t\t\t\t\t\t\t\t// We use replace here instead of upload because we want to be 100% sure that this file name doesn't change.\n\t\t\t\t\t\t\t\t$storage->replace($temp_crop,$crop[\"prefix\"].$pinfo[\"basename\"],$field[\"options\"][\"directory\"]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we don't have any crops, get rid of the temporary image we made.\n\t\t\t\t\tif (!count($bigtree[\"crops\"])) {\n\t\t\t\t\t\tunlink($temp_copy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// We failed, keep the current value.\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn $field[\"output\"];\n\t\t}\n\n\t\t/*\n\t\t\tFunction: refreshLock\n\t\t\t\tRefreshes a lock.\n\n\t\t\tParameters:\n\t\t\t\ttable - The table for the lock.\n\t\t\t\tid - The id of the item.\n\t\t*/\n\n\t\tfunction refreshLock($table,$id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$table = sqlescape($table);\n\t\t\tsqlquery(\"UPDATE bigtree_locks SET last_accessed = NOW() WHERE `table` = '$table' AND item_id = '$id' AND user = '\".$this->ID.\"'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: requireAccess\n\t\t\t\tChecks the logged in user's access to a given module.\n\t\t\t\tThrows a permission denied page and stops page execution if the user doesn't have access.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The id of the module to check access to.\n\n\t\t\tReturns:\n\t\t\t\tThe permission level of the logged in user.\n\t\t*/\n\n\t\tfunction requireAccess($module) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\t\t\tif (!isset($this->Permissions[$module]) || $this->Permissions[$module] == \"\") {\n\t\t\t\tdefine(\"BIGTREE_ACCESS_DENIED\",true);\n\t\t\t\t$this->stop(file_get_contents(BigTree::path(\"admin/pages/_denied.php\")));\n\t\t\t}\n\t\t\treturn $this->Permissions[$module];\n\t\t}\n\n\t\t/*\n\t\t\tFunction: requireLevel\n\t\t\t\tRequires the logged in user to have a certain access level to continue.\n\t\t\t\tThrows a permission denied page and stops page execution if the user doesn't have access.\n\n\t\t\tParameters:\n\t\t\t\tlevel - An access level (0 being normal user, 1 being administrator, 2 being developer)\n\t\t*/\n\n\t\tfunction requireLevel($level) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\t\t\tif (!isset($this->Level) || $this->Level < $level) {\n\t\t\t\tdefine(\"BIGTREE_ACCESS_DENIED\",true);\n\t\t\t\t$this->stop(file_get_contents(BigTree::path(\"admin/pages/_denied.php\")));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: requirePublisher\n\t\t\t\tChecks the logged in user's access to a given module to make sure they are a publisher.\n\t\t\t\tThrows a permission denied page and stops page execution if the user doesn't have access.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The id of the module to check access to.\n\t\t*/\n\n\t\tfunction requirePublisher($module) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ($this->Permissions[$module] != \"p\") {\n\t\t\t\tob_clean();\n\t\t\t\tinclude BigTree::path(\"admin/pages/_denied.php\");\n\t\t\t\t$bigtree[\"content\"] = ob_get_clean();\n\t\t\t\tinclude BigTree::path(\"admin/layouts/default.php\");\n\t\t\t\tdie();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: saveCurrentPageRevision\n\t\t\t\tSaves the currently published page as a revision.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\t\t\t\tdescription - The revision description.\n\n\t\t\tReturns:\n\t\t\t\tThe new revision id.\n\t\t*/\n\n\t\tfunction saveCurrentPageRevision($page,$description) {\n\t\t\t$access = $this->getPageAccessLevel($page);\n\t\t\t\n\t\t\tif ($access != \"p\") {\n\t\t\t\t$this->stop(\"You must be a publisher to manage revisions.\");\n\t\t\t}\n\n\t\t\t$page = sqlescape($page);\n\t\t\t$description = sqlescape($description);\n\n\t\t\t// Get the current page.\n\t\t\t$current = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pages WHERE id = '$page'\"));\n\t\t\tforeach ($current as $key => $val) {\n\t\t\t\t$$key = sqlescape($val);\n\t\t\t}\n\n\t\t\t// Copy it to the saved versions\n\t\t\tsqlquery(\"INSERT INTO bigtree_page_revisions (`page`,`title`,`meta_keywords`,`meta_description`,`template`,`external`,`new_window`,`resources`,`author`,`updated_at`,`saved`,`saved_description`) VALUES ('$page','$title','$meta_keywords','$meta_description','$template','$external','$new_window','$resources','$last_edited_by','$updated_at','on','$description')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_page_revisions\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: search404s\n\t\t\t\tSearches 404s, returns results.\n\n\t\t\tParameters:\n\t\t\t\ttype - The type of results (301, 404, or ignored).\n\t\t\t\tquery - The search query.\n\t\t\t\tpage - The page to return.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_404s.\n\t\t*/\n\n\t\tstatic function search404s($type,$query = \"\",$page = 1) {\n\t\t\t$items = array();\n\n\t\t\tif ($query) {\n\t\t\t\t$s = sqlescape(strtolower($query));\n\t\t\t\tif ($type == \"301\") {\n\t\t\t\t\t$where = \"ignored = '' AND (LOWER(broken_url) LIKE '%$s%' OR LOWER(redirect_url) LIKE '%$s%') AND redirect_url != ''\";\n\t\t\t\t} elseif ($type == \"ignored\") {\n\t\t\t\t\t$where = \"ignored != '' AND (LOWER(broken_url) LIKE '%$s%' OR LOWER(redirect_url) LIKE '%$s%')\";\n\t\t\t\t} else {\n\t\t\t\t\t$where = \"ignored = '' AND LOWER(broken_url) LIKE '%$s%' AND redirect_url = ''\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($type == \"301\") {\n\t\t\t\t\t$where = \"ignored = '' AND redirect_url != ''\";\n\t\t\t\t} elseif ($type == \"ignored\") {\n\t\t\t\t\t$where = \"ignored != ''\";\n\t\t\t\t} else {\n\t\t\t\t\t$where = \"ignored = '' AND redirect_url = ''\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get the page count\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT COUNT(id) AS `count` FROM bigtree_404s WHERE $where\"));\n\t\t\t$pages = ceil($f[\"count\"] / 20);\n\t\t\t$pages = ($pages < 1) ? 1 : $pages;\n\n\t\t\t// Get the results\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_404s WHERE $where ORDER BY requests DESC LIMIT \".(($page - 1) * 20).\",20\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"redirect_url\"] = BigTreeCMS::replaceInternalPageLinks($f[\"redirect_url\"]);\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\n\t\t\treturn array($pages,$items);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: searchAuditTrail\n\t\t\t\tSearches the audit trail for a set of data.\n\n\t\t\tParameters:\n\t\t\t\tuser - User to restrict results to (optional)\n\t\t\t\ttable - Table to restrict results to (optional)\n\t\t\t\tentry - Entry to restrict results to (optional)\n\t\t\t\tstart - Start date/time to restrict results to (optional)\n\t\t\t\tend - End date/time to restrict results to (optional)\n\n\t\t\tReturns:\n\t\t\t\tAn array of adds/edits/deletions from the audit trail.\n\t\t*/\n\n\t\tstatic function searchAuditTrail($user = false,$table = false,$entry = false,$start = false,$end = false) {\n\t\t\t$users = $items = $where = array();\n\t\t\t$query = \"SELECT * FROM bigtree_audit_trail\";\n\n\t\t\tif ($user) {\n\t\t\t\t$where[] = \"user = '\".sqlescape($user).\"'\";\n\t\t\t}\n\t\t\tif ($table) {\n\t\t\t\t$where[] = \"`table` = '\".sqlescape($table).\"'\";\n\t\t\t}\n\t\t\tif ($entry) {\n\t\t\t\t$where[] = \"entry = '\".sqlescape($entry).\"'\";\n\t\t\t}\n\t\t\tif ($start) {\n\t\t\t\t$where[] = \"`date` >= '\".date(\"Y-m-d H:i:s\",strtotime($start)).\"'\";\n\t\t\t}\n\t\t\tif ($end) {\n\t\t\t\t$where[] = \"`date` <= '\".date(\"Y-m-d H:i:s\",strtotime($end)).\"'\";\n\t\t\t}\n\t\t\tif (count($where)) {\n\t\t\t\t$query .= \" WHERE \".implode(\" AND \",$where);\n\t\t\t}\n\n\t\t\t$q = sqlquery($query.\" ORDER BY `date` DESC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif (!$users[$f[\"user\"]]) {\n\t\t\t\t\t$u = static::getUser($f[\"user\"]);\n\t\t\t\t\t$users[$f[\"user\"]] = array(\"id\" => $u[\"id\"],\"name\" => $u[\"name\"],\"email\" => $u[\"email\"],\"level\" => $u[\"level\"]);\n\t\t\t\t}\n\t\t\t\t$f[\"user\"] = $users[$f[\"user\"]];\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: searchPages\n\t\t\t\tSearches for pages.\n\n\t\t\tParameters:\n\t\t\t\tquery - Query string to search against.\n\t\t\t\tfields - Fields to search.\n\t\t\t\tmax - Maximum number of results to return.\n\n\t\t\tReturns:\n\t\t\t\tAn array of pages.\n\t\t*/\n\n\t\tstatic function searchPages($query,$fields = array(\"nav_title\"),$max = 10) {\n\t\t\t// Since we're in JSON we have to do stupid things to the /s for URL searches.\n\t\t\t$query = str_replace('/','\\\\\\/',$query);\n\n\t\t\t$results = array();\n\t\t\t$terms = explode(\" \",$query);\n\t\t\t$qpart = array(\"archived != 'on'\");\n\n\t\t\tforeach ($terms as $term) {\n\t\t\t\t$term = sqlescape(strtolower($term));\n\t\t\t\t$or_parts = array();\n\t\t\t\tforeach ($fields as $field) {\n\t\t\t\t\t$or_parts[] = \"LOWER(`$field`) LIKE '%$term%'\";\n\t\t\t\t}\n\t\t\t\t$qpart[] = \"(\".implode(\" OR \",$or_parts).\")\";\n\t\t\t}\n\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE \".implode(\" AND \",$qpart).\" ORDER BY nav_title LIMIT $max\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$results[] = $f;\n\t\t\t}\n\t\t\treturn $results;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: searchResources\n\t\t\t\tReturns a list of folders and files that match the given query string.\n\n\t\t\tParameters:\n\t\t\t\tquery - A string of text to search folders' and files' names to.\n\t\t\t\tsort - The column to sort the files on (default: date DESC).\n\n\t\t\tReturns:\n\t\t\t\tAn array of two arrays - folders and files - with permission levels.\n\t\t*/\n\n\t\tfunction searchResources($query, $sort = \"date DESC\") {\n\t\t\t$query = sqlescape(strtolower($query));\n\t\t\t$folders = array();\n\t\t\t$resources = array();\n\t\t\t$permission_cache = array();\n\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resource_folders WHERE LOWER(name) LIKE '%$query%' ORDER BY name\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"permission\"] = $this->getResourceFolderPermission($f);\n\t\t\t\t// We're going to cache the folder permissions so we don't have to fetch them a bunch of times if many files have the same folder.\n\t\t\t\t$permission_cache[$f[\"id\"]] = $f[\"permission\"];\n\n\t\t\t\t$folders[] = $f;\n\t\t\t}\n\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resources WHERE LOWER(name) LIKE '%$query%' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t// If we've already got the permission cahced, use it. Otherwise, fetch it and cache it.\n\t\t\t\tif ($permission_cache[$f[\"folder\"]]) {\n\t\t\t\t\t$f[\"permission\"] = $permission_cache[$f[\"folder\"]];\n\t\t\t\t} else {\n\t\t\t\t\t$f[\"permission\"] = $this->getResourceFolderPermission($f[\"folder\"]);\n\t\t\t\t\t$permission_cache[$f[\"folder\"]] = $f[\"permission\"];\n\t\t\t\t}\n\n\t\t\t\t$resources[] = $f;\n\t\t\t}\n\n\t\t\treturn array(\"folders\" => $folders, \"resources\" => $resources);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: searchTags\n\t\t\t\tFinds existing tags that are similar.\n\n\t\t\tParameters:\n\t\t\t\ttag - A tag to find similar tags for.\n\n\t\t\tReturns:\n\t\t\t\tAn array of up to 8 similar tags.\n\t\t*/\n\n\t\tstatic function searchTags($tag) {\n\t\t\t$tags = $dist = array();\n\t\t\t$meta = metaphone($tag);\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_tags\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$distance = levenshtein($f[\"metaphone\"],$meta);\n\t\t\t\tif ($distance < 2) {\n\t\t\t\t\t$tags[] = $f[\"tag\"];\n\t\t\t\t\t$dist[] = $distance;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tarray_multisort($dist,SORT_ASC,$tags);\n\t\t\treturn array_slice($tags,0,8);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: set404Redirect\n\t\t\t\tSets the redirect address for a 404.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the 404.\n\t\t\t\turl - The redirect URL.\n\t\t*/\n\n\t\tfunction set404Redirect($id,$url) {\n\t\t\t$this->requireLevel(1);\n\t\t\t$id = sqlescape($id);\n\n\t\t\t// Try to convert the short URL into a full one\n\t\t\tif (strpos($url,\"//\") === false) {\n\t\t\t\t$url = WWW_ROOT.ltrim($url,\"/\");\n\t\t\t}\n\t\t\t$url = sqlescape(htmlspecialchars($this->autoIPL($url)));\n\n\t\t\t// Don't use static roots if they're the same as www just in case they are different when moving environments\n\t\t\tif (WWW_ROOT === STATIC_ROOT) {\n\t\t\t\t$url = str_replace(\"{staticroot}\",\"{wwwroot}\",$url);\n\t\t\t}\n\n\t\t\tsqlquery(\"UPDATE bigtree_404s SET redirect_url = '$url' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_404s\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setCalloutPosition\n\t\t\t\tSets the position of a callout.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setCalloutPosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_callouts SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setModuleActionPosition\n\t\t\t\tSets the position of a module action.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module action.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setModuleActionPosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setModuleGroupPosition\n\t\t\t\tSets the position of a module group.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module group.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setModuleGroupPosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_module_groups SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setModulePosition\n\t\t\t\tSets the position of a module.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setModulePosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_modules SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setPagePosition\n\t\t\t\tSets the position of a page.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the page.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setPagePosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setPasswordHashForUser\n\t\t\t\tCreates a change password hash for a user.\n\n\t\t\tParameters:\n\t\t\t\tuser - A user entry.\n\n\t\t\tReturns:\n\t\t\t\tA change password hash.\n\t\t*/\n\n\t\tstatic function setPasswordHashForUser($user) {\n\t\t\t$hash = md5(microtime().$user[\"password\"]);\n\t\t\tsqlquery(\"UPDATE bigtree_users SET change_password_hash = '$hash' WHERE id = '\".$user[\"id\"].\"'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setTemplatePosition\n\t\t\t\tSets the position of a template.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the template.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setTemplatePosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_templates SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: settingExists\n\t\t\t\tDetermines whether a setting exists for a given id.\n\n\t\t\tParameters:\n\t\t\t\tid - The setting id to check for.\n\n\t\t\tReturns:\n\t\t\t\t1 if the setting exists, otherwise 0.\n\t\t*/\n\n\t\tstatic function settingExists($id) {\n\t\t\t$id = BigTreeCMS::extensionSettingCheck($id);\n\t\t\treturn sqlrows(sqlquery(\"SELECT id FROM bigtree_settings WHERE id = '\".sqlescape($id).\"'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: stop\n\t\t\t\tStops processing of the Admin area and shows a message in the default layout.\n\n\t\t\tParameters:\n\t\t\t\tmessage - Content to show (error, permission denied, etc)\n\t\t*/\n\n\t\tfunction stop($message = \"\") {\n\t\t\tglobal $admin,$bigtree,$cms;\n\t\t\techo $message;\n\t\t\t$bigtree[\"content\"] = ob_get_clean();\n\t\t\tinclude BigTree::path(\"admin/layouts/\".$bigtree[\"layout\"].\".php\");\n\t\t\tdie();\n\t\t}\n\n\t\t/*\n\t\t\tFunction: stripMultipleRootTokens\n\t\t\t\tStrips the multi-domain root tokens from a string and replaces them with standard {wwwroot} and {staticroot}\n\n\t\t\tParameters:\n\t\t\t\tstring - A string\n\n\t\t\tReturns:\n\t\t\t\tA modified string.\n\t\t*/\n\n\t\tstatic function stripMultipleRootTokens($string) {\n\t\t\tglobal $bigtree;\n\n\t\t\tif (empty($bigtree[\"config\"][\"sites\"]) || !array_filter((array) $bigtree[\"config\"][\"sites\"])) {\n\t\t\t\treturn $string;\n\t\t\t}\n\n\t\t\tforeach ($bigtree[\"config\"][\"sites\"] as $key => $data) {\n\t\t\t\t$string = str_replace(\n\t\t\t\t\tarray(\"{wwwroot:$key}\", \"{staticroot:$key}\"),\n\t\t\t\t\tarray(\"{wwwroot}\", \"{staticroot}\"),\n\t\t\t\t\t$string\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn $string;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: submitPageChange\n\t\t\t\tAdds a pending change to the bigtree_pending_changes table for the page.\n\t\t\t\tDetermines what has changed and only stores the changed fields.\n\t\t\t\tDoes not check permissions.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id or pending page id (prefixed with a \"p\")\n\t\t\t\tchanges - An array of changes\n\t\t*/\n\n\t\tfunction submitPageChange($page,$changes) {\n\t\t\t$page = sqlescape($page);\n\t\t\t\n\t\t\tif ($page[0] == \"p\") {\n\t\t\t\t// It's still pending...\n\t\t\t\t$type = \"NEW\";\n\t\t\t\t$pending = true;\n\t\t\t\t$existing_page = array();\n\t\t\t\t$existing_pending_change = array(\"id\" => substr($page,1));\n\t\t\t} else {\n\t\t\t\t// It's an existing page\n\t\t\t\t$type = \"EDIT\";\n\t\t\t\t$pending = false;\n\t\t\t\t$existing_page = BigTreeCMS::getPage($page);\n\t\t\t\t$existing_pending_change = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND item_id = '$page'\"));\n\t\t\t}\n\n\t\t\t// Save tags separately\n\t\t\t$tags = BigTree::json($changes[\"_tags\"],true);\n\t\t\tunset($changes[\"_tags\"]);\n\n\t\t\t// Convert to an IPL\n\t\t\tif (!empty($changes[\"external\"])) {\n\t\t\t\t$changes[\"external\"] = $this->makeIPL($changes[\"external\"]);\n\t\t\t}\n\n\t\t\t// Unset the trunk flag if the user isn't a developer\n\t\t\tif ($this->Level < 2) {\n\t\t\t\tunset($changes[\"trunk\"]);\n\t\t\t// Make sure the value is changed -- since it's a check box it may not have come through\n\t\t\t} else {\n\t\t\t\t$changes[\"trunk\"] = !empty($changes[\"trunk\"]) ? \"on\" : \"\";\n\t\t\t}\n\n\t\t\t// Set the in_nav flag, since it's not in the post if the checkbox became unclicked\n\t\t\t$changes[\"in_nav\"] = !empty($changes[\"in_nav\"]) ? \"on\" : \"\";\n\n\t\t\t// If there's already a change in the queue, update it with this latest info.\n\t\t\tif ($existing_pending_change) {\n\t\t\t\t// If this is a pending page, just replace all the changes\n\t\t\t\tif ($pending) {\n\t\t\t\t\t$changes = BigTree::json($changes,true);\n\t\t\t\t// Otherwise, we need to check what's changed.\n\t\t\t\t} else {\n\n\t\t\t\t\t// We don't want to indiscriminately put post data in as changes, so we ensure it matches a column in the bigtree_pages table\n\t\t\t\t\t$diff = array();\n\t\t\t\t\tforeach ($changes as $key => $val) {\n\t\t\t\t\t\tif (array_key_exists($key,$existing_page) && $existing_page[$key] != $val) {\n\t\t\t\t\t\t\t$diff[$key] = $val;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$changes = BigTree::json($diff,true);\n\t\t\t\t}\n\n\t\t\t\t// Update existing draft and track\n\t\t\t\tsqlquery(\"UPDATE bigtree_pending_changes SET changes = '$changes', tags_changes = '$tags', date = NOW(), user = '\".$this->ID.\"', type = '$type' WHERE id = '\".$existing_pending_change[\"id\"].\"'\");\n\t\t\t\t$this->track(\"bigtree_pages\",$page,\"updated-draft\");\n\n\t\t\t// We're submitting a change to a presently published page with no pending changes.\n\t\t\t} else {\n\t\t\t\t$diff = array();\n\t\t\t\tforeach ($changes as $key => $val) {\n\t\t\t\t\tif (array_key_exists($key,$existing_page) && $val != $existing_page[$key]) {\n\t\t\t\t\t\t$diff[$key] = $val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$changes = BigTree::json($diff,true);\n\n\t\t\t\t// Create draft and track\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_pending_changes (`user`,`date`,`table`,`item_id`,`changes`,`tags_changes`,`type`,`title`) VALUES ('\".$this->ID.\"',NOW(),'bigtree_pages','$page','$changes','$tags','EDIT','Page Change Pending')\");\n\t\t\t\t$this->track(\"bigtree_pages\",$page,\"saved-draft\");\n\t\t\t}\n\n\t\t\treturn sqlid();\n\t\t}\n\n\t\t/*\n\t\t\tFunction: track\n\t\t\t\tLogs a user's actions to the audit trail table.\n\n\t\t\tParameters:\n\t\t\t\ttable - The table affected by the user.\n\t\t\t\tentry - The primary key of the entry affected by the user.\n\t\t\t\ttype - The action taken by the user (delete, edit, create, etc.)\n\t\t*/\n\n\t\tfunction track($table,$entry,$type) {\n\t\t\t// If this is running fron cron or something, nobody is logged in so don't track.\n\t\t\tif (isset($this->ID)) {\n\t\t\t\t$table = sqlescape($table);\n\t\t\t\t$entry = sqlescape($entry);\n\t\t\t\t$type = sqlescape($type);\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_audit_trail (`table`,`user`,`entry`,`date`,`type`) VALUES ('$table','\".$this->ID.\"','$entry',NOW(),'$type')\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: unarchivePage\n\t\t\t\tUnarchives a page and all its children that inherited archived status.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id or page entry.\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful. false if permission was denied.\n\t\t*/\n\n\t\tfunction unarchivePage($page) {\n\t\t\tif (is_array($page)) {\n\t\t\t\t$page = sqlescape($page[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$page = sqlescape($page);\n\t\t\t}\n\t\t\t$access = $this->getPageAccessLevel($page);\n\t\t\tif ($access == \"p\" && $this->canModifyChildren(BigTreeCMS::getPage($page))) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_pages SET archived = '' WHERE id = '$page'\");\n\t\t\t\t$this->track(\"bigtree_pages\",$page,\"unarchived\");\n\t\t\t\t$this->unarchivePageChildren($page);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: unarchivePageChildren\n\t\t\t\tUnarchives a page's children that have the archived_inherited status.\n\t\t\t\tDoes not checks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The parent page id.\n\t\t*/\n\n\t\tfunction unarchivePageChildren($id) {\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE parent = '$id' AND archived_inherited = 'on'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$this->track(\"bigtree_pages\",$f[\"id\"],\"unarchived-inherited\");\n\t\t\t\t$this->unarchivePageChildren($f[\"id\"]);\n\t\t\t}\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET archived = '', archived_inherited = '' WHERE parent = '$id' AND archived_inherited = 'on'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: ungrowl\n\t\t\t\tDestroys the growl session.\n\t\t*/\n\n\t\tstatic function ungrowl() {\n\t\t\tunset($_SESSION[\"bigtree_admin\"][\"growl\"]);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: urlExists\n\t\t\t\tAttempts to connect to a URL using cURL.\n\t\t\t\tThis is now an alias for BigTree::urlExists\n\n\t\t\tParameters:\n\t\t\t\turl - The URL to connect to.\n\n\t\t\tReturns:\n\t\t\t\ttrue if it can connect, false if connection failed.\n\n\t\t\tSee Also:\n\t\t\t\tBigTree::urlExists\n\t\t*/\n\n\t\tstatic function urlExists($url) {\n\t\t\treturn BigTree::urlExists($url);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: unCache\n\t\t\t\tRemoves the cached copy of a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - Either a page id or a page entry.\n\t\t*/\n\n\t\tstatic function unCache($page) {\n\t\t\t$url = \"\";\n\n\t\t\t// Already have the path\n\t\t\tif (is_array($page)) {\n\t\t\t\t$url = $page[\"path\"].\"/\";\n\t\t\t} else {\n\t\t\t\tif ($page != 0) {\n\t\t\t\t\t$url = str_replace(WWW_ROOT,\"\",BigTreeCMS::getLink($page));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@unlink(md5(json_encode(array(\"bigtree_htaccess_url\" => $url))).\".page\");\n\t\t\t@unlink(md5(json_encode(array(\"bigtree_htaccess_url\" => rtrim($url,\"/\")))).\".page\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: unignore404\n\t\t\t\tUnignores a 404.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the 404.\n\t\t*/\n\n\t\tfunction unignore404($id) {\n\t\t\t$this->requireLevel(1);\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"UPDATE bigtree_404s SET ignored = '' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_404s\",$id,\"unignored\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: uniqueModuleActionRoute\n\t\t\t\tReturns a unique module action route.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module to create a route for.\n\t\t\t\troute - The desired route.\n\t\t\t\taction - The ID of the action you're trying to set a new route for (optional)\n\n\t\t\tReturns:\n\t\t\t\tA unique action route.\n\t\t*/\n\n\t\tstatic function uniqueModuleActionRoute($module,$route,$action = false) {\n\t\t\t$module = sqlescape($module);\n\t\t\t$oroute = $route = sqlescape($route);\n\t\t\t$x = 2;\n\t\t\t$query_add = ($action !== false) ? \" AND id != '\".sqlescape($action).\"'\" : \"\";\n\t\t\twhile (sqlrows(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '$module' AND route = '$route' $query_add\"))) {\n\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t$x++;\n\t\t\t}\n\t\t\treturn $route;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: unlock\n\t\t\t\tRemoves a lock from a table entry.\n\n\t\t\tParameters:\n\t\t\t\ttable - The table the entry is in.\n\t\t\t\tid - The id of the entry.\n\t\t*/\n\n\t\tstatic function unlock($table,$id) {\n\t\t\tsqlquery(\"DELETE FROM bigtree_locks WHERE `table` = '\".sqlescape($table).\"' AND item_id = '\".sqlescape($id).\"'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateCallout\n\t\t\t\tUpdates a callout.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout to update.\n\t\t\t\tname - The name.\n\t\t\t\tdescription - The description.\n\t\t\t\tlevel - The access level (0 for all users, 1 for administrators, 2 for developers)\n\t\t\t\tresources - An array of resources.\n\t\t\t\tdisplay_field - The field to use as the display field describing a user's callout\n\t\t\t\tdisplay_default - The text string to use in the event the display_field is blank or non-existent\n\t\t*/\n\n\t\tfunction updateCallout($id,$name,$description,$level,$resources,$display_field,$display_default) {\n\t\t\t$clean_resources = array();\n\t\t\tforeach ($resources as $resource) {\n\t\t\t\t// \"type\" is still a reserved keyword due to the way we save callout data when editing.\n\t\t\t\tif ($resource[\"id\"] && $resource[\"id\"] != \"type\") {\n\t\t\t\t\t$clean_resources[] = array(\n\t\t\t\t\t\t\"id\" => BigTree::safeEncode($resource[\"id\"]),\n\t\t\t\t\t\t\"type\" => BigTree::safeEncode($resource[\"type\"]),\n\t\t\t\t\t\t\"title\" => BigTree::safeEncode($resource[\"title\"]),\n\t\t\t\t\t\t\"subtitle\" => BigTree::safeEncode($resource[\"subtitle\"]),\n\t\t\t\t\t\t\"options\" => BigTree::translateArray(json_decode($resource[\"options\"],true))\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$level = sqlescape($level);\n\t\t\t$resources = BigTree::json($clean_resources,true);\n\t\t\t$display_default = sqlescape($display_default);\n\t\t\t$display_field = sqlescape($display_field);\n\n\t\t\tsqlquery(\"UPDATE bigtree_callouts SET resources = '$resources', name = '$name', description = '$description', level = '$level', display_field = '$display_field', display_default = '$display_default' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_callouts\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateCalloutGroup\n\t\t\t\tUpdates a callout group's name and callout list.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout group to update.\n\t\t\t\tname - The name.\n\t\t\t\tcallouts - An array of callout IDs to assign to the group.\n\t\t*/\n\n\t\tfunction updateCalloutGroup($id,$name,$callouts) {\n\t\t\tsort($callouts);\n\t\t\t$callouts = BigTree::json($callouts,true);\n\t\t\tsqlquery(\"UPDATE bigtree_callout_groups SET name = '\".sqlescape(BigTree::safeEncode($name)).\"', callouts = '$callouts' WHERE id = '\".sqlescape($id).\"'\");\n\t\t\t$this->track(\"bigtree_callout_groups\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateChildPagePaths\n\t\t\t\tUpdates the paths for pages who are descendants of a given page to reflect the page's new route.\n\t\t\t\tAlso sets route history if the page has changed paths.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\t\t*/\n\n\t\tstatic function updateChildPagePaths($page) {\n\t\t\t$page = sqlescape($page);\n\t\t\t$q = sqlquery(\"SELECT id,path FROM bigtree_pages WHERE parent = '$page'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$oldpath = $f[\"path\"];\n\t\t\t\t$path = static::getFullNavigationPath($f[\"id\"]);\n\t\t\t\tif ($oldpath != $path) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_route_history WHERE old_route = '$path' OR old_route = '$oldpath'\");\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_route_history (`old_route`,`new_route`) VALUES ('$oldpath','$path')\");\n\t\t\t\t\tsqlquery(\"UPDATE bigtree_pages SET path = '$path' WHERE id = '\".$f[\"id\"].\"'\");\n\t\t\t\t\tstatic::updateChildPagePaths($f[\"id\"]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateFeed\n\t\t\t\tUpdates a feed.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the feed to update.\n\t\t\t\tname - The name.\n\t\t\t\tdescription - The description.\n\t\t\t\ttable - The data table.\n\t\t\t\ttype - The feed type.\n\t\t\t\toptions - The feed type options.\n\t\t\t\tfields - The fields.\n\t\t*/\n\n\t\tfunction updateFeed($id,$name,$description,$table,$type,$options,$fields) {\n\t\t\t$options = json_decode($options,true);\n\t\t\tforeach ($options as &$option) {\n\t\t\t\t$option = BigTreeCMS::replaceHardRoots($option);\n\t\t\t}\n\n\t\t\t// Fix stuff up for the db.\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\t\t\t$options = BigTree::json($options,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\n\t\t\tsqlquery(\"UPDATE bigtree_feeds SET name = '$name', description = '$description', `table` = '$table', type = '$type', fields = '$fields', options = '$options' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_feeds\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateFieldType\n\t\t\t\tUpdates a field type.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the field type.\n\t\t\t\tname - The name.\n\t\t\t\tuse_cases - Associate array of sections in which the field type can be used (i.e. array(\"pages\" => \"on\", \"modules\" => \"\",\"callouts\" => \"\",\"settings\" => \"\"))\n\t\t\t\tself_draw - Whether this field type will draw its <fieldset> and <label> (\"on\" or a falsey value)\n\t\t*/\n\n\t\tfunction updateFieldType($id,$name,$use_cases,$self_draw) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$use_cases = sqlescape(json_encode($use_cases));\n\t\t\t$self_draw = $self_draw ? \"'on'\" : \"NULL\";\n\n\t\t\tsqlquery(\"UPDATE bigtree_field_types SET name = '$name', use_cases = '$use_cases', self_draw = $self_draw WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_field_types\",$id,\"updated\");\n\n\t\t\tunlink(SERVER_ROOT.\"cache/bigtree-form-field-types.json\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModule\n\t\t\t\tUpdates a module.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module to update.\n\t\t\t\tname - The name of the module.\n\t\t\t\tgroup - The group for the module.\n\t\t\t\tclass - The module class to create.\n\t\t\t\tpermissions - The group-based permissions.\n\t\t\t\ticon - The icon to use.\n\t\t*/\n\n\t\tfunction updateModule($id,$name,$group,$class,$permissions,$icon) {\n\t\t\t// If this has a permissions table, wipe that table's view cache\n\t\t\tif ($permissions[\"table\"]) {\n\t\t\t\tBigTreeAutoModule::clearCache($permissions[\"table\"]);\n\t\t\t}\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$group = $group ? \"'\".sqlescape($group).\"'\" : \"NULL\";\n\t\t\t$class = sqlescape($class);\n\t\t\t$permissions = BigTree::json($permissions,true);\n\t\t\t$icon = sqlescape($icon);\n\n\t\t\tsqlquery(\"UPDATE bigtree_modules SET name = '$name', `group` = $group, class = '$class', icon = '$icon', `gbp` = '$permissions' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_modules\",$id,\"updated\");\n\n\t\t\t// Remove cached class list.\n\t\t\tunlink(SERVER_ROOT.\"cache/bigtree-module-class-list.json\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleAction\n\t\t\t\tUpdates a module action.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module action to update.\n\t\t\t\tname - The name of the action.\n\t\t\t\troute - The action route.\n\t\t\t\tin_nav - Whether the action is in the navigation.\n\t\t\t\ticon - The icon class for the action.\n\t\t\t\tform - The associated form.\n\t\t\t\tview - The associated view.\n\t\t\t\treport - The associated report.\n\t\t\t\tlevel - The required access level.\n\t\t\t\tposition - The position in navigation.\n\t\t*/\n\n\t\tfunction updateModuleAction($id,$name,$route,$in_nav,$icon,$form,$view,$report,$level,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$route = sqlescape(BigTree::safeEncode($route));\n\t\t\t$in_nav = sqlescape($in_nav);\n\t\t\t$icon = sqlescape($icon);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$level = sqlescape($level);\n\t\t\t$form = $form ? \"'\".sqlescape($form).\"'\" : \"NULL\";\n\t\t\t$view = $view ? \"'\".sqlescape($view).\"'\" : \"NULL\";\n\t\t\t$report = $report ? \"'\".sqlescape($report).\"'\" : \"NULL\";\n\t\t\t$position = sqlescape($position);\n\n\t\t\t$item = $this->getModuleAction($id);\n\t\t\t$route = $this->uniqueModuleActionRoute($item[\"module\"],$route,$id);\n\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET name = '$name', route = '$route', class = '$icon', in_nav = '$in_nav', level = '$level', position = '$position', form = $form, view = $view, report = $report WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_module_actions\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleEmbedForm\n\t\t\t\tUpdates an embeddable form.\n\n\t\t\tParameters:\n\t\t\t\tid - The ID of the form.\n\t\t\t\ttitle - The title of the form.\n\t\t\t\ttable - The table for the form data.\n\t\t\t\tfields - The form fields.\n\t\t\t\thooks - An array of \"pre\", \"post\", and \"publish\" keys that can be function names to call\n\t\t\t\tdefault_position - Default position for entries to the form (if the view is positioned).\n\t\t\t\tdefault_pending - Whether the submissions to default to pending or not (\"on\" or \"\").\n\t\t\t\tcss - URL of a CSS file to include.\n\t\t\t\tredirect_url - The URL to redirect to upon completion of submission.\n\t\t\t\tthank_you_message - The message to display upon completeion of submission.\n\t\t*/\n\n\t\tfunction updateModuleEmbedForm($id,$title,$table,$fields,$hooks = array(),$default_position = \"\",$default_pending = \"\",$css = \"\",$redirect_url = \"\",$thank_you_message = \"\") {\n\t\t\t$id = sqlescape($id);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$hooks = BigTree::json(json_decode($hooks),true);\n\t\t\t$default_position = sqlescape($default_position);\n\t\t\t$default_pending = $default_pending ? \"on\" : \"\";\n\t\t\t$css = sqlescape(BigTree::safeEncode($this->makeIPL($css)));\n\t\t\t$redirect_url = sqlescape(BigTree::safeEncode($redirect_url));\n\t\t\t$thank_you_message = sqlescape($thank_you_message);\n\n\t\t\t$clean_fields = array();\n\t\t\tforeach ($fields as $key => $field) {\n\t\t\t\t$field[\"options\"] = BigTree::translateArray(json_decode($field[\"options\"],true));\n\t\t\t\t$field[\"column\"] = $key;\n\t\t\t\t$clean_fields[] = $field;\n\t\t\t}\n\t\t\t$fields = BigTree::json($clean_fields,true);\n\n\t\t\tsqlquery(\"UPDATE bigtree_module_embeds SET `title` = '$title', `table` = '$table', `fields` = '$fields', `default_position` = '$default_position', `default_pending` = '$default_pending', `css` = '$css', `redirect_url` = '$redirect_url', `thank_you_message` = '$thank_you_message', `hooks` = '$hooks' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_module_embeds\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleForm\n\t\t\t\tUpdates a module form.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the form.\n\t\t\t\ttitle - The title of the form.\n\t\t\t\ttable - The table for the form data.\n\t\t\t\tfields - The form fields.\n\t\t\t\thooks - An array of \"pre\", \"post\", and \"publish\" keys that can be function names to call\n\t\t\t\tdefault_position - Default position for entries to the form (if the view is positioned).\n\t\t\t\treturn_view - The view to return to when the form is completed.\n\t\t\t\treturn_url - The alternative URL to return to when the form is completed.\n\t\t\t\ttagging - Whether or not to enable tagging.\n\t\t*/\n\n\t\tfunction updateModuleForm($id,$title,$table,$fields,$hooks = array(),$default_position = \"\",$return_view = false,$return_url = \"\",$tagging = \"\") {\n\t\t\t$id = sqlescape($id);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$hooks = BigTree::json(json_decode($hooks),true);\n\t\t\t$default_position = sqlescape($default_position);\n\t\t\t$return_view = $return_view ? \"'\".sqlescape($return_view).\"'\" : \"NULL\";\n\t\t\t$return_url = sqlescape($this->makeIPL($return_url));\n\t\t\t$tagging = $tagging ? \"on\" : \"\";\n\n\t\t\t$clean_fields = array();\n\t\t\tforeach ($fields as $key => $field) {\n\t\t\t\t$field[\"options\"] = BigTree::translateArray(json_decode($field[\"options\"],true));\n\t\t\t\t$field[\"column\"] = $key;\n\t\t\t\t$field[\"title\"] = BigTree::safeEncode($field[\"title\"]);\n\t\t\t\t$field[\"subtitle\"] = BigTree::safeEncode($field[\"subtitle\"]);\n\t\t\t\t$clean_fields[] = $field;\n\t\t\t}\n\t\t\t$fields = BigTree::json($clean_fields,true);\n\n\t\t\tsqlquery(\"UPDATE bigtree_module_forms SET title = '$title', `table` = '$table', fields = '$fields', default_position = '$default_position', return_view = $return_view, return_url = '$return_url', `tagging` = '$tagging', `hooks` = '$hooks' WHERE id = '$id'\");\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET name = 'Add $title' WHERE form = '$id' AND route LIKE 'add%'\");\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET name = 'Edit $title' WHERE form = '$id' AND route LIKE 'edit%'\");\n\n\t\t\t// Get related views for this table and update numeric status\n\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_module_views WHERE `table` = '$table'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tstatic::updateModuleViewColumnNumericStatus(BigTreeAutoModule::getView($f[\"id\"]));\n\t\t\t}\n\n\t\t\t$this->track(\"bigtree_module_forms\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleGroup\n\t\t\t\tUpdates a module group's name.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module group to update.\n\t\t\t\tname - The name of the module group.\n\t\t*/\n\n\t\tfunction updateModuleGroup($id,$name) {\n\t\t\t// Get a unique route\n\t\t\t$x = 2;\n\t\t\t$route = BigTreeCMS::urlify($name);\n\t\t\t$oroute = $route;\n\t\t\t$existing = $this->getModuleGroupByRoute($route);\n\t\t\twhile ($existing && $existing[\"id\"] != $id) {\n\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t$existing = $this->getModuleGroupByRoute($route);\n\t\t\t\t$x++;\n\t\t\t}\n\n\t\t\t$route = sqlescape($route);\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\n\t\t\tsqlquery(\"UPDATE bigtree_module_groups SET name = '$name', route = '$route' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_module_groups\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleReport\n\t\t\t\tUpdates a module report.\n\n\t\t\tParameters:\n\t\t\t\tid - The ID of the report to update.\n\t\t\t\ttitle - The title of the report.\n\t\t\t\ttable - The table for the report data.\n\t\t\t\ttype - The type of report (csv or view).\n\t\t\t\tfilters - The filters a user can use to create the report.\n\t\t\t\tfields - The fields to show in the CSV export (if type = csv).\n\t\t\t\tparser - An optional parser function to run on the CSV export data (if type = csv).\n\t\t\t\tview - A module view ID to use (if type = view).\n\t\t*/\n\n\t\tfunction updateModuleReport($id,$title,$table,$type,$filters,$fields = \"\",$parser = \"\",$view = \"\") {\n\t\t\t$id = sqlescape($id);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\t\t\t$filters = BigTree::json($filters,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\t$parser = sqlescape($parser);\n\t\t\t$view = $view ? \"'\".sqlescape($view).\"'\" : \"NULL\";\n\t\t\tsqlquery(\"UPDATE bigtree_module_reports SET `title` = '$title', `table` = '$table', `type` = '$type', `filters` = '$filters', `fields` = '$fields', `parser` = '$parser', `view` = $view WHERE id = '$id'\");\n\t\t\t// Update the module action\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET `name` = '$title' WHERE `report` = '$id'\");\n\t\t\t$this->track(\"bigtree_module_reports\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleView\n\t\t\t\tUpdates a module view.\n\n\t\t\tParameters:\n\t\t\t\tid - The view id.\n\t\t\t\ttitle - View title.\n\t\t\t\tdescription - Description.\n\t\t\t\ttable - Data table.\n\t\t\t\ttype - View type.\n\t\t\t\toptions - View options array.\n\t\t\t\tfields - Field array.\n\t\t\t\tactions - Actions array.\n\t\t\t\trelated_form - Form ID to handle edits.\n\t\t\t\tpreview_url - Optional preview URL.\n\n\t\t\tReturns:\n\t\t\t\tThe id for view.\n\t\t*/\n\n\t\tfunction updateModuleView($id,$title,$description,$table,$type,$options,$fields,$actions,$related_form,$preview_url = \"\") {\n\t\t\t$id = sqlescape($id);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\n\t\t\t$options = BigTree::json($options,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\t$actions = BigTree::json($actions,true);\n\t\t\t$related_form = $related_form ? intval($related_form) : \"NULL\";\n\t\t\t$preview_url = sqlescape(BigTree::safeEncode($this->makeIPL($preview_url)));\n\n\t\t\tsqlquery(\"UPDATE bigtree_module_views SET title = '$title', description = '$description', `table` = '$table', type = '$type', options = '$options', fields = '$fields', actions = '$actions', preview_url = '$preview_url', related_form = $related_form WHERE id = '$id'\");\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET name = 'View $title' WHERE view = '$id'\");\n\n\t\t\tstatic::updateModuleViewColumnNumericStatus(BigTreeAutoModule::getView($id));\n\t\t\t$this->track(\"bigtree_module_views\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleViewColumnNumericStatus\n\t\t\t\tUpdates a module view's columns to designate whether they are numeric or not based on parsers, column type, and related forms.\n\n\t\t\tParameters:\n\t\t\t\tview - The view entry to update.\n\t\t*/\n\n\t\tstatic function updateModuleViewColumnNumericStatus($view) {\n\t\t\tif (is_array($view[\"fields\"])) {\n\t\t\t\t$form = BigTreeAutoModule::getRelatedFormForView($view);\n\t\t\t\t$table = BigTree::describeTable($view[\"table\"]);\n\n\t\t\t\tforeach ($view[\"fields\"] as $key => $field) {\n\t\t\t\t\t$numeric = false;\n\t\t\t\t\t$t = $table[\"columns\"][$key][\"type\"];\n\t\t\t\t\tif ($t == \"int\" || $t == \"float\" || $t == \"double\" || $t == \"double precision\" || $t == \"tinyint\" || $t == \"smallint\" || $t == \"mediumint\" || $t == \"bigint\" || $t == \"real\" || $t == \"decimal\" || $t == \"dec\" || $t == \"fixed\" || $t == \"numeric\") {\n\t\t\t\t\t\t$numeric = true;\n\t\t\t\t\t}\n\t\t\t\t\tif ($field[\"parser\"] || ($form[\"fields\"][$key][\"type\"] == \"list\" && $form[\"fields\"][$key][\"list_type\"] == \"db\")) {\n\t\t\t\t\t\t$numeric = false;\n\t\t\t\t\t}\n\n\t\t\t\t\t$view[\"fields\"][$key][\"numeric\"] = $numeric;\n\t\t\t\t}\n\n\t\t\t\t$fields = BigTree::json($view[\"fields\"],true);\n\t\t\t\tsqlquery(\"UPDATE bigtree_module_views SET fields = '$fields' WHERE id = '\".$view[\"id\"].\"'\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleViewFields\n\t\t\t\tUpdates the fields for a module view.\n\n\t\t\tParameters:\n\t\t\t\tview - The view id.\n\t\t\t\tfields - A fields array.\n\t\t*/\n\n\t\tfunction updateModuleViewFields($view,$fields) {\n\t\t\t$view = sqlescape($view);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\tsqlquery(\"UPDATE bigtree_module_views SET `fields` = '$fields' WHERE id = '$view'\");\n\t\t\t$this->track(\"bigtree_module_views\",$view,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updatePage\n\t\t\t\tUpdates a page.\n\t\t\t\tChecks some (but not all) permissions.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id to update.\n\t\t\t\tdata - The page data to update with.\n\t\t*/\n\n\t\tfunction updatePage($page,$data) {\n\t\t\t$page = sqlescape($page);\n\n\t\t\t// Save the existing copy as a draft, remove drafts for this page that are one month old or older.\n\t\t\t$current = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pages WHERE id = '$page'\"));\n\t\t\tforeach ($current as $key => $val) {\n\t\t\t\t$$key = sqlescape($val);\n\t\t\t}\n\t\t\t// Figure out if we currently have a template that the user isn't allowed to use. If they do, we're not letting them change it.\n\t\t\t$template_data = BigTreeCMS::getTemplate($template);\n\t\t\tif (is_array($template_data) && $template_data[\"level\"] > $this->Level) {\n\t\t\t\t$data[\"template\"] = $template;\n\t\t\t}\n\t\t\t// Copy it to the saved versions\n\t\t\tsqlquery(\"INSERT INTO bigtree_page_revisions (`page`,`title`,`meta_keywords`,`meta_description`,`template`,`external`,`new_window`,`resources`,`author`,`updated_at`) VALUES ('$page','$title','$meta_keywords','$meta_description','$template','$external','$new_window','$resources','$last_edited_by','$updated_at')\");\n\t\t\t// Count the page revisions\n\t\t\t$r = sqlrows(sqlquery(\"SELECT id FROM bigtree_page_revisions WHERE page = '$page' AND saved = ''\"));\n\t\t\t// If we have more than 10, delete any that are more than a month old\n\t\t\tif ($r > 10) {\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_page_revisions WHERE page = '$page' AND updated_at < '\".date(\"Y-m-d\",strtotime(\"-1 month\")).\"' AND saved = '' ORDER BY updated_at ASC LIMIT \".($r - 10));\n\t\t\t}\n\n\t\t\t// Remove this page from the cache\n\t\t\tstatic::unCache($page);\n\n\t\t\t// Set local variables in a clean fashion that prevents _SESSION exploitation. Also, don't let them somehow overwrite $page and $current.\n\t\t\tforeach ($data as $key => $val) {\n\t\t\t\tif (substr($key,0,1) != \"_\" && $key != \"current\" && $key != \"page\") {\n\t\t\t\t\tif (is_array($val)) {\n\t\t\t\t\t\t$$key = BigTree::json($val,true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$key = sqlescape($val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the trunk flag back to the current value if the user isn't a developer\n\t\t\tif ($this->Level < 2) {\n\t\t\t\t$trunk = $current[\"trunk\"];\n\t\t\t} else {\n\t\t\t\t$trunk = sqlescape($data[\"trunk\"]);\n\t\t\t}\n\n\t\t\t// If this is top level nav and the user isn't a developer, use what the current state is.\n\t\t\tif (!$current[\"parent\"] && $this->Level < 2) {\n\t\t\t\t$in_nav = sqlescape($current[\"in_nav\"]);\n\t\t\t} else {\n\t\t\t\t$in_nav = sqlescape($data[\"in_nav\"]);\n\t\t\t}\n\n\t\t\t// Make an ipl:// or {wwwroot}'d version of the URL\n\t\t\tif ($external) {\n\t\t\t\t$external = static::makeIPL($external);\n\t\t\t}\n\n\t\t\t// If somehow we didn't provide a parent page (like, say, the user didn't have the right to change it) then pull the one from before. Actually, this might be exploitable\u2026 look into it later.\n\t\t\tif (!isset($data[\"parent\"])) {\n\t\t\t\t$parent = $current[\"parent\"];\n\t\t\t}\n\n\t\t\tif ($page == 0) {\n\t\t\t\t// Home page doesn't get a route - fixes sitemap bug\n\t\t\t\t$route = \"\";\n\t\t\t} else {\n\t\t\t\t// Create a route if we don't have one, otherwise, make sure the one they provided doesn't suck.\n\t\t\t\t$route = $data[\"route\"];\n\t\t\t\tif (!$route) {\n\t\t\t\t\t$route = BigTreeCMS::urlify($data[\"nav_title\"]);\n\t\t\t\t} else {\n\t\t\t\t\t$route = BigTreeCMS::urlify($route);\n\t\t\t\t}\n\n\t\t\t\t// Get a unique route\n\t\t\t\t$oroute = $route;\n\t\t\t\t$x = 2;\n\t\t\t\t// Reserved paths.\n\t\t\t\tif ($parent == 0) {\n\t\t\t\t\twhile (file_exists(SERVER_ROOT.\"site/\".$route.\"/\")) {\n\t\t\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t\t\t$x++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (in_array($route,static::$ReservedTLRoutes)) {\n\t\t\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t\t\t$x++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Existing pages.\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pages WHERE `route` = '$route' AND parent = '$parent' AND id != '$page'\"));\n\t\t\t\twhile ($f) {\n\t\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pages WHERE `route` = '$route' AND parent = '$parent' AND id != '$page'\"));\n\t\t\t\t\t$x++;\n\t\t\t\t}\n\n\t\t\t\t// Make sure route isn't longer than 255\n\t\t\t\t$route = substr($route,0,255);\n\t\t\t}\n\n\t\t\t// We have no idea how this affects the nav, just wipe it all.\n\t\t\tif ($current[\"nav_title\"] != $nav_title || $current[\"route\"] != $route || $current[\"in_nav\"] != $in_nav || $current[\"parent\"] != $parent) {\n\t\t\t\tstatic::clearCache();\n\t\t\t}\n\n\t\t\t// Make sure we set the publish date to NULL if it wasn't provided or we'll have a page that got published at 0000-00-00\n\t\t\tif ($publish_at && $publish_at != \"NULL\") {\n\t\t\t\t$publish_at = \"'\".date(\"Y-m-d\",strtotime($publish_at)).\"'\";\n\t\t\t} else {\n\t\t\t\t$publish_at = \"NULL\";\n\t\t\t}\n\n\t\t\t// If we set an expiration date, make it the proper MySQL format.\n\t\t\tif ($expire_at && $expire_at != \"NULL\") {\n\t\t\t\t$expire_at = \"'\".date(\"Y-m-d\",strtotime($expire_at)).\"'\";\n\t\t\t} else {\n\t\t\t\t$expire_at = \"NULL\";\n\t\t\t}\n\n\t\t\t// Set the full path, saves DB access time on the front end.\n\t\t\tif ($parent > 0) {\n\t\t\t\t$path = static::getFullNavigationPath($parent).\"/\".$route;\n\t\t\t} else {\n\t\t\t\t$path = $route;\n\t\t\t}\n\n\t\t\t// htmlspecialchars stuff so that it doesn't need to be re-encoded when echo'd on the front end.\n\t\t\t$title = htmlspecialchars($title);\n\t\t\t$nav_title = htmlspecialchars($nav_title);\n\t\t\t$meta_description = htmlspecialchars($meta_description);\n\t\t\t$meta_keywords = htmlspecialchars($meta_keywords);\n\t\t\t$seo_invisible = $data[\"seo_invisible\"] ? \"on\" : \"\";\n\t\t\t$external = htmlspecialchars($external);\n\n\t\t\t// Update the database\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET `trunk` = '$trunk', `parent` = '$parent', `nav_title` = '$nav_title', `route` = '$route', `path` = '$path', `in_nav` = '$in_nav', `title` = '$title', `template` = '$template', `external` = '$external', `new_window` = '$new_window', `resources` = '$resources', `meta_keywords` = '$meta_keywords', `meta_description` = '$meta_description', `seo_invisible` = '$seo_invisible', `last_edited_by` = '\".$this->ID.\"', updated_at = NOW(), publish_at = $publish_at, expire_at = $expire_at, max_age = '$max_age' WHERE id = '$page'\");\n\n\t\t\t// Remove any pending drafts\n\t\t\tsqlquery(\"DELETE FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND item_id = '$page'\");\n\n\t\t\t// Remove old paths from the redirect list\n\t\t\tsqlquery(\"DELETE FROM bigtree_route_history WHERE old_route = '$path' OR old_route = '\".$current[\"path\"].\"'\");\n\n\t\t\t// Create an automatic redirect from the old path to the new one.\n\t\t\tif ($current[\"path\"] != $path) {\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_route_history (`old_route`,`new_route`) VALUES ('\".$current[\"path\"].\"','$path')\");\n\n\t\t\t\t// Update all child page routes, ping those engines, clean those caches\n\t\t\t\tstatic::updateChildPagePaths($page);\n\t\t\t\tstatic::pingSearchEngines();\n\t\t\t\tstatic::clearCache();\n\t\t\t}\n\n\t\t\t// Handle tags\n\t\t\tsqlquery(\"DELETE FROM bigtree_tags_rel WHERE `table` = 'bigtree_pages' AND entry = '$page'\");\n\t\t\tif (is_array($data[\"_tags\"])) {\n\t\t\t\tforeach ($data[\"_tags\"] as $tag) {\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_tags_rel (`table`,`entry`,`tag`) VALUES ('bigtree_pages','$page','$tag')\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Audit trail.\n\t\t\t$this->track(\"bigtree_pages\",$page,\"updated\");\n\t\t\t\n\t\t\t// If this page is a trunk in a multi-site setup, wipe the cache\n\t\t\tforeach (BigTreeCMS::$SiteRoots as $site_path => $site_data) {\n\t\t\t\tif ($site_data[\"trunk\"] == $page) {\n\t\t\t\t\tunlink(SERVER_ROOT.\"cache/multi-site-cache.json\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $page;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updatePageParent\n\t\t\t\tChanges a page's parent.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page to update.\n\t\t\t\tparent - The parent to switch to.\n\t\t*/\n\n\t\tfunction updatePageParent($page,$parent) {\n\t\t\t$page = sqlescape($page);\n\t\t\t$parent = sqlescape($parent);\n\n\t\t\tif ($this->Level < 1) {\n\t\t\t\t$this->stop(\"You are not allowed to move pages.\");\n\t\t\t}\n\n\t\t\t// Get the existing path so we can create a route history\n\t\t\t$current = sqlfetch(sqlquery(\"SELECT in_nav,path FROM bigtree_pages WHERE id = '$page'\"));\n\t\t\t$old_path = sqlescape($current[\"path\"]);\n\n\t\t\t// If the current user isn't a developer and is moving the page to top level, set it to not be visible\n\t\t\t$in_nav = $current[\"in_nav\"] ? \"on\" : \"\";\n\t\t\tif ($this->Level < 2 && $parent == 0) {\n\t\t\t\t$in_nav = \"\";\n\t\t\t}\n\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET in_nav = '$in_nav', parent = '$parent' WHERE id = '$page'\");\n\t\t\t$path = sqlescape($this->getFullNavigationPath($page));\n\n\t\t\t// Set the route history\n\t\t\tsqlquery(\"DELETE FROM bigtree_route_history WHERE old_route = '$path' OR old_route = '$old_path'\");\n\t\t\tsqlquery(\"INSERT INTO bigtree_route_history (`old_route`,`new_route`) VALUES ('$old_path','$path')\");\n\n\t\t\t// Update the page with its new path.\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET path = '$path' WHERE id = '$page'\");\n\n\t\t\t// Update the paths of any child pages.\n\t\t\t$this->updateChildPagePaths($page);\n\t\t\t$this->track(\"bigtree_pages\",$page,\"moved\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updatePageRevision\n\t\t\t\tUpdates a page revision to save it as a favorite.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The page revision id.\n\t\t\t\tdescription - Saved description.\n\t\t*/\n\n\t\tfunction updatePageRevision($id,$description) {\n\t\t\t// Get the version, check if the user has access to the page the version refers to.\n\t\t\t$revision = $this->getPageRevision($id);\n\t\t\t$access = $this->getPageAccessLevel($revision[\"page\"]);\n\t\t\tif ($access != \"p\") {\n\t\t\t\t$this->stop(\"You must be a publisher to manage revisions.\");\n\t\t\t}\n\n\t\t\t// Save the version's description and saved status\n\t\t\t$description = sqlescape(htmlspecialchars($description));\n\t\t\tsqlquery(\"UPDATE bigtree_page_revisions SET saved = 'on', saved_description = '$description' WHERE id = '\".$revision[\"id\"].\"'\");\n\t\t\t$this->track(\"bigtree_page_revisions\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updatePendingChange\n\t\t\t\tUpdates a pending change.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the pending change.\n\t\t\t\tchanges - The changes to the fields in the entry.\n\t\t\t\tmtm_changes - Many to Many changes.\n\t\t\t\ttags_changes - Tags changes.\n\t\t*/\n\n\t\tfunction updatePendingChange($id,$changes,$mtm_changes = array(),$tags_changes = array()) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$changes = BigTree::json($changes,true);\n\t\t\t$mtm_changes = BigTree::json($mtm_changes,true);\n\t\t\t$tags_changes = BigTree::json($tags_changes,true);\n\n\t\t\tsqlquery(\"UPDATE bigtree_pending_changes SET changes = '$changes', mtm_changes = '$mtm_changes', tags_changes = '$tags_changes', date = NOW(), user = '\".$this->ID.\"' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_pending_changes\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateProfile\n\t\t\t\tUpdates a user's name, company, digest setting, and (optionally) password.\n\n\t\t\tParameters:\n\t\t\t\tdata - Array containing name / company / daily_digest / password.\n\t\t*/\n\n\t\tfunction updateProfile($data) {\n\t\t\tglobal $bigtree;\n\n\t\t\tforeach ($data as $key => $val) {\n\t\t\t\tif (substr($key,0,1) != \"_\" && !is_array($val)) {\n\t\t\t\t\t$$key = sqlescape($val);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$id = sqlescape($this->ID);\n\n\t\t\tif ($data[\"password\"]) {\n\t\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], TRUE);\n\t\t\t\t$password = sqlescape($phpass->HashPassword($data[\"password\"]));\n\t\t\t\tsqlquery(\"UPDATE bigtree_users SET `password` = '$password', `name` = '$name', `company` = '$company', `daily_digest` = '$daily_digest' WHERE id = '$id'\");\n\t\t\t} else {\n\t\t\t\tsqlquery(\"UPDATE bigtree_users SET `name` = '$name', `company` = '$company', `daily_digest` = '$daily_digest' WHERE id = '$id'\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateResource\n\t\t\t\tUpdates a resource.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the resource.\n\t\t\t\tattributes - A key/value array of fields to update.\n\t\t*/\n\n\t\tfunction updateResource($id,$attributes) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$fields = array();\n\t\t\tforeach ($attributes as $key => $val) {\n\t\t\t\t$fields[] = \"`$key` = '\".sqlescape($val).\"'\";\n\t\t\t}\n\t\t\tsqlquery(\"UPDATE bigtree_resources SET \".implode(\", \",$fields).\" WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_resources\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateSetting\n\t\t\t\tUpdates a setting.\n\n\t\t\tParameters:\n\t\t\t\told_id - The current id of the setting to update.\n\t\t\t\tdata - The new data for the setting (\"id\", \"type\", \"name\", \"description\", \"locked\", \"system\", \"encrypted\")\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful, false if a setting exists for the new id already.\n\t\t*/\n\n\t\tfunction updateSetting($old_id,$data) {\n\t\t\tglobal $bigtree;\n\n\t\t\t// Get the existing setting information.\n\t\t\t$existing = static::getSetting($old_id);\n\t\t\t$old_id = sqlescape($existing[\"id\"]);\n\n\t\t\t// Globalize the data and clean it up.\n\t\t\tforeach ($data as $key => $val) {\n\t\t\t\tif (substr($key,0,1) != \"_\" && !is_array($val)) {\n\t\t\t\t\t$$key = sqlescape(htmlspecialchars($val));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We don't want this encoded since it's a WYSIWYG field.\n\t\t\t$description = sqlescape($data[\"description\"]);\n\n\t\t\t// Stored as JSON encoded already\n\t\t\t$options = json_decode($data[\"options\"], true);\n\n\t\t\tforeach ($options as $key => $value) {\n\t\t\t\tif ($key == \"options\" && is_string($value)) {\n\t\t\t\t\t$options[$key] = json_decode($value, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$options = BigTree::json(BigTree::translateArray($options), true);\n\n\t\t\t// See if we have an id collision with the new id.\n\t\t\tif ($old_id != $id && static::settingExists($id)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsqlquery(\"UPDATE bigtree_settings SET id = '$id', type = '$type', `options` = '$options', name = '$name', description = '$description', locked = '$locked', system = '$system', encrypted = '$encrypted' WHERE id = '$old_id'\");\n\n\t\t\t// If encryption status has changed, update the value\n\t\t\tif ($existing[\"encrypted\"] && !$encrypted) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_settings SET value = AES_DECRYPT(value,'\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') WHERE id = '$id'\");\n\t\t\t}\n\t\t\tif (!$existing[\"encrypted\"] && $encrypted) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_settings SET value = AES_ENCRYPT(value,'\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') WHERE id = '$id'\");\n\t\t\t}\n\n\t\t\t// Audit trail.\n\t\t\t$this->track(\"bigtree_settings\",$id,\"updated\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateSettingValue\n\t\t\t\tUpdates the value of a setting.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the setting to update.\n\t\t\t\tvalue - A value to set (can be a string or array).\n\t\t*/\n\n\t\tstatic function updateSettingValue($id,$value) {\n\t\t\tglobal $bigtree,$admin;\n\n\t\t\t$item = static::getSetting($id,false);\n\t\t\t$id = sqlescape(BigTreeCMS::extensionSettingCheck($id));\n\n\t\t\tif (is_array($value)) {\n\t\t\t\t$value = BigTree::translateArray($value);\n\t\t\t} else {\n\t\t\t\t$value = static::autoIPL($value);\n\t\t\t}\n\n\t\t\t$value = BigTree::json($value,true);\n\n\t\t\tif ($item[\"encrypted\"]) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_settings SET `value` = AES_ENCRYPT('$value','\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') WHERE id = '$id'\");\n\t\t\t} else {\n\t\t\t\tsqlquery(\"UPDATE bigtree_settings SET `value` = '$value' WHERE id = '$id'\");\n\t\t\t}\n\n\t\t\tif ($admin && !$item[\"system\"]) {\n\t\t\t\t// Audit trail.\n\t\t\t\t$admin->track(\"bigtree_settings\",$id,\"updated\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateTemplate\n\t\t\t\tUpdates a template.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the template to update.\n\t\t\t\tname - Name\n\t\t\t\tlevel - Access level (0 for everyone, 1 for administrators, 2 for developers)\n\t\t\t\tmodule - Related module id\n\t\t\t\tresources - An array of resources\n\t\t*/\n\n\t\tfunction updateTemplate($id,$name,$level,$module,$resources) {\n\t\t\t$clean_resources = array();\n\t\t\tforeach ($resources as $resource) {\n\t\t\t\tif ($resource[\"id\"]) {\n\t\t\t\t\t$clean_resources[] = array(\n\t\t\t\t\t\t\"id\" => BigTree::safeEncode($resource[\"id\"]),\n\t\t\t\t\t\t\"title\" => BigTree::safeEncode($resource[\"title\"]),\n\t\t\t\t\t\t\"subtitle\" => BigTree::safeEncode($resource[\"subtitle\"]),\n\t\t\t\t\t\t\"type\" => BigTree::safeEncode($resource[\"type\"]),\n\t\t\t\t\t\t\"options\" => BigTree::translateArray(json_decode($resource[\"options\"],true))\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(htmlspecialchars($name));\n\t\t\t$module = sqlescape($module);\n\t\t\t$resources = BigTree::json($clean_resources,true);\n\t\t\t$level = sqlescape($level);\n\n\t\t\tsqlquery(\"UPDATE bigtree_templates SET resources = '$resources', name = '$name', module = '$module', level = '$level' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_templates\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateUser\n\t\t\t\tUpdates a user.\n\n\t\t\tParameters:\n\t\t\t\tid - The user's \"id\"\n\t\t\t\tdata - A key/value array containing email, name, company, level, permissions, alerts, daily_digest, and (optionally) password.\n\n\t\t\tReturns:\n\t\t\t\tTrue if successful. False if the logged in user doesn't have permission to change the user or there was an email collision.\n\t\t*/\n\n\t\tfunction updateUser($id,$data) {\n\t\t\tglobal $bigtree;\n\t\t\t$id = sqlescape($id);\n\n\t\t\t// See if there's an email collission\n\t\t\t$r = sqlrows(sqlquery(\"SELECT * FROM bigtree_users WHERE email = '\".sqlescape($data[\"email\"]).\"' AND id != '$id'\"));\n\t\t\tif ($r) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If this person has higher access levels than the person trying to update them, fail.\n\t\t\t$current = static::getUser($id);\n\t\t\tif ($current[\"level\"] > $this->Level) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$level = intval($data[\"level\"]);\n\t\t\t$email = sqlescape($data[\"email\"]);\n\t\t\t$name = sqlescape(htmlspecialchars($data[\"name\"]));\n\t\t\t$company = sqlescape(htmlspecialchars($data[\"company\"]));\n\t\t\t$daily_digest = $data[\"daily_digest\"] ? \"on\" : \"\";\n\n\t\t\t$permissions = BigTree::json($data[\"permissions\"],true);\n\t\t\t$alerts = BigTree::json($data[\"alerts\"],true);\n\n\t\t\t// If the user is editing themselves, they can't change the level.\n\t\t\tif ($this->ID == $current[\"id\"]) {\n\t\t\t\t$level = $current[\"level\"];\n\t\t\t}\n\n\t\t\t// Don't allow the level to be set higher than the logged in user's level\n\t\t\tif ($level > $this->Level) {\n\t\t\t\t$level = $this->Level;\n\t\t\t}\n\n\t\t\tif ($data[\"password\"]) {\n\t\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], TRUE);\n\t\t\t\t$password = sqlescape($phpass->HashPassword(trim($data[\"password\"])));\n\t\t\t\tsqlquery(\"UPDATE bigtree_users SET `email` = '$email', `password` = '$password', `name` = '$name', `company` = '$company', `level` = '$level', `permissions` = '$permissions', `alerts` = '$alerts', `daily_digest` = '$daily_digest' WHERE id = '$id'\");\n\t\t\t} else {\n\t\t\t\tsqlquery(\"UPDATE bigtree_users SET `email` = '$email', `name` = '$name', `company` = '$company', `level` = '$level', `permissions` = '$permissions', `alerts` = '$alerts', `daily_digest` = '$daily_digest' WHERE id = '$id'\");\n\t\t\t}\n\n\t\t\t$this->track(\"bigtree_users\",$id,\"updated\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateUserPassword\n\t\t\t\tUpdates a user's password.\n\n\t\t\tParameters:\n\t\t\t\tid - The user's id.\n\t\t\t\tpassword - The new password.\n\t\t*/\n\n\t\tstatic function updateUserPassword($id,$password) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], TRUE);\n\t\t\t$password = sqlescape($phpass->HashPassword(trim($password)));\n\t\t\tsqlquery(\"UPDATE bigtree_users SET password = '$password' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: validatePassword\n\t\t\t\tValidates a password against the security policy.\n\n\t\t\tParameters:\n\t\t\t\tpassword - Password to validate.\n\n\t\t\tReturns:\n\t\t\t\ttrue if it passes all password criteria.\n\t\t*/\n\n\t\tstatic function validatePassword($password) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$policy = $bigtree[\"security-policy\"][\"password\"];\n\t\t\t$failed = false;\n\n\t\t\t// Check length policy\n\t\t\tif ($policy[\"length\"] && strlen($password) < $policy[\"length\"]) {\n\t\t\t\t$failed = true;\n\t\t\t}\n\t\t\t// Check case policy\n\t\t\tif ($policy[\"multicase\"] && strtolower($password) === $password) {\n\t\t\t\t$failed = true;\n\t\t\t}\n\t\t\t// Check numeric policy\n\t\t\tif ($policy[\"numbers\"] && !preg_match(\"/[0-9]/\",$password)) {\n\t\t\t\t$failed = true;\n\t\t\t}\n\t\t\t// Check non-alphanumeric policy\n\t\t\tif ($policy[\"nonalphanumeric\"] && ctype_alnum($password)) {\n\t\t\t\t$failed = true;\n\t\t\t}\n\t\t\treturn !$failed;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: verifyCSRFToken\n\t\t\t\tVerifies the referring host and session token and stops processing if they fail.\n\t\t*/\n\t\t\n\t\tfunction verifyCSRFToken() {\n\t\t\t$clean_referer = str_replace(array(\"http://\",\"https://\"),\"//\",$_SERVER[\"HTTP_REFERER\"]);\n\t\t\t$clean_domain = str_replace(array(\"http://\",\"https://\"),\"//\",DOMAIN);\n\t\t\t$token = isset($_POST[$this->CSRFTokenField]) ? $_POST[$this->CSRFTokenField] : $_GET[$this->CSRFTokenField];\n\t\t\t\n\t\t\tif (strpos($clean_referer, $clean_domain) !== 0 || $token != $this->CSRFToken) {\n\t\t\t\t$this->stop(\"Cross site request forgery detected.\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: versionToDecimal\n\t\t\t\tReturns a decimal number of a BigTree version for numeric comparisons.\n\n\t\t\tParameters:\n\t\t\t\tversion - BigTree version number (i.e. 4.2.0)\n\n\t\t\tReturns:\n\t\t\t\tA number\n\t\t*/\n\n\t\tstatic function versionToDecimal($version) {\n\t\t\t$pieces = explode(\".\",$version);\n\t\t\t$number = $pieces[0] * 10000;\n\t\t\tif (isset($pieces[1])) {\n\t\t\t\t$number += $pieces[1] * 100;\n\t\t\t}\n\t\t\tif (isset($pieces[2])) {\n\t\t\t\t$number += $pieces[2];\n\t\t\t}\n\t\t\treturn $number;\n\t\t}\n\t}\n"], "fixing_code": ["<?php\n\t/*\n\t\tClass: BigTreeAdmin\n\t\t\tThe main class used by the admin for manipulating and retrieving data.\n\t*/\n\n\tclass BigTreeAdminBase {\n\n\t\tstatic $IRLPrefixes = false;\n\t\tstatic $IRLsCreated = array();\n\t\tstatic $PerPage = 15;\t\t\n\n\t\t// !View Types\n\t\tstatic $ViewTypes = array(\n\t\t\t\"searchable\" => \"Searchable List\",\n\t\t\t\"draggable\" => \"Draggable List\",\n\t\t\t\"nested\" => \"Nested Draggable List\",\n\t\t\t\"grouped\" => \"Grouped List\",\n\t\t\t\"images\" => \"Image List\",\n\t\t\t\"images-grouped\" => \"Grouped Image List\"\n\t\t);\n\n\t\t// !Reserved Column Names\n\t\tstatic $ReservedColumns = array(\n\t\t\t\"id\",\n\t\t\t\"position\",\n\t\t\t\"archived\",\n\t\t\t\"approved\"\n\t\t);\n\n\t\t// !Reserved Top Level Routes\n\t\tstatic $ReservedTLRoutes = array(\n\t\t\t\"ajax\",\n\t\t\t\"css\",\n\t\t\t\"feeds\",\n\t\t\t\"js\",\n\t\t\t\"sitemap.xml\",\n\t\t\t\"_preview\",\n\t\t\t\"_preview-pending\"\n\t\t);\n\n\t\t// !View Actions\n\t\tstatic $ViewActions = array(\n\t\t\t\"approve\" => array(\n\t\t\t\t\"key\" => \"approved\",\n\t\t\t\t\"name\" => \"Approve\",\n\t\t\t\t\"class\" => \"icon_approve icon_approve_on\"\n\t\t\t),\n\t\t\t\"archive\" => array(\n\t\t\t\t\"key\" => \"archived\",\n\t\t\t\t\"name\" => \"Archive\",\n\t\t\t\t\"class\" => \"icon_archive\"\n\t\t\t),\n\t\t\t\"feature\" => array(\n\t\t\t\t\"key\" => \"featured\",\n\t\t\t\t\"name\" => \"Feature\",\n\t\t\t\t\"class\" => \"icon_feature icon_feature_on\"\n\t\t\t),\n\t\t\t\"edit\" => array(\n\t\t\t\t\"key\" => \"id\",\n\t\t\t\t\"name\" => \"Edit\",\n\t\t\t\t\"class\" => \"icon_edit\"\n\t\t\t),\n\t\t\t\"delete\" => array(\n\t\t\t\t\"key\" => \"id\",\n\t\t\t\t\"name\" => \"Delete\",\n\t\t\t\t\"class\" => \"icon_delete\"\n\t\t\t)\n\t\t);\n\n\t\t// !Icon Classes\n\t\tstatic $IconClasses = array(\"gear\",\"truck\",\"token\",\"export\",\"redirect\",\"help\",\"error\",\"ignored\",\"world\",\"server\",\"clock\",\"network\",\"car\",\"key\",\"folder\",\"calendar\",\"search\",\"setup\",\"page\",\"computer\",\"picture\",\"news\",\"events\",\"blog\",\"form\",\"category\",\"map\",\"user\",\"question\",\"sports\",\"credit_card\",\"cart\",\"cash_register\",\"lock_key\",\"bar_graph\",\"comments\",\"email\",\"weather\",\"pin\",\"planet\",\"mug\",\"atom\",\"shovel\",\"cone\",\"lifesaver\",\"target\",\"ribbon\",\"dice\",\"ticket\",\"pallet\",\"camera\",\"video\",\"twitter\",\"facebook\");\n\t\tstatic $ActionClasses = array(\"add\",\"delete\",\"list\",\"edit\",\"refresh\",\"gear\",\"truck\",\"token\",\"export\",\"redirect\",\"help\",\"error\",\"ignored\",\"world\",\"server\",\"clock\",\"network\",\"car\",\"key\",\"folder\",\"calendar\",\"search\",\"setup\",\"page\",\"computer\",\"picture\",\"news\",\"events\",\"blog\",\"form\",\"category\",\"map\",\"user\",\"question\",\"sports\",\"credit_card\",\"cart\",\"cash_register\",\"lock_key\",\"bar_graph\",\"comments\",\"email\",\"weather\",\"pin\",\"planet\",\"mug\",\"atom\",\"shovel\",\"cone\",\"lifesaver\",\"target\",\"ribbon\",\"dice\",\"ticket\",\"pallet\",\"lightning\",\"camera\",\"video\",\"twitter\",\"facebook\");\n\n\t\t/*\n\t\t\tConstructor:\n\t\t\t\tInitializes the user's permissions.\n\t\t*/\n\n\t\tfunction __construct() {\n\t\t\t$this->checkPOSTError();\n\n\t\t\tif (isset($_SESSION[\"bigtree_admin\"][\"email\"]) && isset($_SESSION[\"bigtree_admin\"][\"csrf_token\"])) {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE id = '\".$_SESSION[\"bigtree_admin\"][\"id\"].\"' AND email = '\".sqlescape($_SESSION[\"bigtree_admin\"][\"email\"]).\"'\"));\n\t\t\t\tif ($f) {\n\t\t\t\t\t$this->ID = $f[\"id\"];\n\t\t\t\t\t$this->User = $f[\"email\"];\n\t\t\t\t\t$this->Level = $f[\"level\"];\n\t\t\t\t\t$this->Name = $f[\"name\"];\n\t\t\t\t\t$this->Permissions = json_decode($f[\"permissions\"],true);\n\t\t\t\t\t$this->CSRFToken = $_SESSION[\"bigtree_admin\"][\"csrf_token\"];\n\t\t\t\t\t$this->CSRFTokenField = $_SESSION[\"bigtree_admin\"][\"csrf_token_field\"];\n\t\t\t\t}\n\t\t\t} elseif (isset($_COOKIE[\"bigtree_admin\"][\"email\"])) {\n\t\t\t\t$user = sqlescape($_COOKIE[\"bigtree_admin\"][\"email\"]);\n\n\t\t\t\t// Get chain and session broken out\n\t\t\t\tlist($session,$chain) = json_decode($_COOKIE[\"bigtree_admin\"][\"login\"], true);\n\n\t\t\t\t// See if this is the current chain and session\n\t\t\t\t$chain_entry = sqlfetch(sqlquery(\"SELECT * FROM bigtree_user_sessions WHERE email = '$user' AND chain = '\".sqlescape($chain).\"'\"));\n\n\t\t\t\tif ($chain_entry && $chain_entry[\"csrf_token\"]) {\n\t\t\t\t\t// If both chain and session are legit, log them in\n\t\t\t\t\tif ($chain_entry[\"id\"] == $session) {\n\t\t\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE email = '$user'\"));\n\t\t\t\t\t\tif ($f) {\n\t\t\t\t\t\t\t// Generate a random CSRF token\n\t\t\t\t\t\t\t$csrf_token = base64_encode(openssl_random_pseudo_bytes(32));\n\t\t\t\t\t\t\t$csrf_token_field = \"__csrf_token_\".BigTree::randomString(32).\"__\";\n\t\t\t\t\n\t\t\t\t\t\t\t// Setup session\n\t\t\t\t\t\t\t$this->ID = $f[\"id\"];\n\t\t\t\t\t\t\t$this->User = $user;\n\t\t\t\t\t\t\t$this->Level = $f[\"level\"];\n\t\t\t\t\t\t\t$this->Name = $f[\"name\"];\n\t\t\t\t\t\t\t$this->Permissions = json_decode($f[\"permissions\"],true);\n\t\t\t\t\t\t\t$this->CSRFToken = $csrf_token;\n\t\t\t\t\t\t\t$this->CSRFTokenField = $csrf_token_field;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"id\"] = $f[\"id\"];\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"email\"] = $f[\"email\"];\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"name\"] = $f[\"name\"];\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"level\"] = $f[\"level\"];\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token\"] = $csrf_token;\n\t\t\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token_field\"] = $csrf_token_field;\n\n\t\t\t\t\t\t\t// Delete existing session\n\t\t\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_user_sessions WHERE id = '\".sqlescape($session).\"'\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Generate a random session id\n\t\t\t\t\t\t\t$session = uniqid(\"session-\",true);\n\t\t\t\t\t\t\twhile (sqlrows(sqlquery(\"SELECT id FROM bigtree_user_sessions WHERE id = '\".sqlescape($session).\"'\"))) {\n\t\t\t\t\t\t\t\t$session = uniqid(\"session-\",true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Create a new session with the same chain\n\t\t\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_user_sessions (`id`,`chain`,`email`,`csrf_token`,`csrf_token_field`) VALUES ('\".sqlescape($session).\"','\".sqlescape($chain).\"','$user','$csrf_token','$csrf_token_field')\");\n\t\t\t\t\t\t\tsetcookie('bigtree_admin[login]',json_encode(array($session,$chain)),strtotime(\"+1 month\"),str_replace(DOMAIN,\"\",WWW_ROOT),\"\",false,true);\n\t\t\t\t\t\t}\n\t\t\t\t\t// Chain is legit and session isn't -- someone has taken your cookies\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Delete existing cookies\n\t\t\t\t\t\tsetcookie(\"bigtree_admin[email]\",\"\",time()-3600,str_replace(DOMAIN,\"\",WWW_ROOT));\n\t\t\t\t\t\tsetcookie(\"bigtree_admin[login]\",\"\",time()-3600,str_replace(DOMAIN,\"\",WWW_ROOT));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Delete all sessions for this user\n\t\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_user_sessions WHERE email = '$user'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Clean up\n\t\t\t\tunset($user,$f,$session,$chain,$chain_entry);\n\t\t\t}\n\n\t\t\t// Check the permissions to see if we should show the pages tab.\n\t\t\tif (!$this->Level) {\n\t\t\t\t$this->HidePages = true;\n\t\t\t\tif (is_array($this->Permissions[\"page\"])) {\n\t\t\t\t\tforeach ($this->Permissions[\"page\"] as $k => $v) {\n\t\t\t\t\t\tif ($v != \"n\" && $v != \"i\") {\n\t\t\t\t\t\t\t$this->HidePages = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->HidePages = false;\n\t\t\t}\n\n\t\t\t// Update the reserved top level routes with the admin's route\n\t\t\t$ar = explode(\"/\",str_replace(WWW_ROOT,\"\",rtrim(ADMIN_ROOT,\"/\")));\n\t\t\tstatic::$ReservedTLRoutes[] = $ar[0];\n\t\t\tunset($ar);\n\n\t\t\t// Check for Per Page value\n\t\t\t$pp = static::getSetting(\"bigtree-internal-per-page\",false);\n\t\t\t$v = intval($pp[\"value\"]);\n\t\t\tif ($v) {\n\t\t\t\tstatic::$PerPage = $v;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: allocateResources\n\t\t\t\tAssigns resources from $this->IRLsCreated\n\n\t\t\tParameters:\n\t\t\t\tmodule - Module ID to assign to\n\t\t\t\tentry - Entry ID to assign to\n\t\t*/\n\n\t\tstatic function allocateResources($module,$entry) {\n\t\t\t$module = sqlescape($module);\n\t\t\t$entry = sqlescape($entry);\n\t\t\tsqlquery(\"DELETE FROM bigtree_resource_allocation WHERE module = '$module' AND entry = '$entry'\");\n\t\t\tforeach (static::$IRLsCreated as $resource) {\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_resource_allocation (`module`,`entry`,`resource`,`updated_at`) VALUES ('$module','$entry','\".sqlescape($resource).\"',NOW())\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: archivePage\n\t\t\t\tArchives a page.\n\n\t\t\tParameters:\n\t\t\t\tpage - Either a page id or page entry.\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful. false if the logged in user doesn't have permission.\n\n\t\t\tSee Also:\n\t\t\t\t<archivePageChildren>\n\t\t*/\n\n\t\tfunction archivePage($page) {\n\t\t\tif (is_array($page)) {\n\t\t\t\t$page = sqlescape($page[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$page = sqlescape($page);\n\t\t\t}\n\n\t\t\t$access = $this->getPageAccessLevel($page);\n\t\t\tif ($access == \"p\" && $this->canModifyChildren(BigTreeCMS::getPage($page))) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_pages SET archived = 'on' WHERE id = '$page'\");\n\t\t\t\t$this->archivePageChildren($page);\n\t\t\t\tstatic::growl(\"Pages\",\"Archived Page\");\n\t\t\t\t$this->track(\"bigtree_pages\",$page,\"archived\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: archivePageChildren\n\t\t\t\tArchives a page's children and sets the archive status to inherited.\n\n\t\t\tParameters:\n\t\t\t\tpage - A page id.\n\n\t\t\tSee Also:\n\t\t\t\t<archivePage>\n\t\t*/\n\n\t\tfunction archivePageChildren($page) {\n\t\t\t$page = sqlescape($page);\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE parent = '$page' AND archived != 'on'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$this->track(\"bigtree_pages\",$f[\"id\"],\"archived-inherited\");\n\t\t\t\t$this->archivePageChildren($f[\"id\"]);\n\t\t\t}\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET archived = 'on', archived_inherited = 'on' WHERE parent = '$page' AND archived != 'on'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: autoIPL\n\t\t\t\tAutomatically converts links to internal page links.\n\n\t\t\tParameters:\n\t\t\t\thtml - A string of contents that may contain URLs\n\n\t\t\tReturns:\n\t\t\t\tA string with hard links converted into internal page links.\n\t\t*/\n\n\t\tstatic function autoIPL($html) {\n\t\t\t// If this string is actually just a URL, IPL it.\n\t\t\tif ((substr($html,0,7) == \"http://\" || substr($html,0,8) == \"https://\") && strpos($html,\"\\n\") === false && strpos($html,\"\\r\") === false) {\n\t\t\t\t$html = static::makeIPL($html);\n\t\t\t// Otherwise, switch all the image srcs and javascripts srcs and whatnot to {wwwroot}.\n\t\t\t} else {\n\t\t\t\t$html = preg_replace_callback('/href=\"([^\"]*)\"/',array(\"BigTreeAdmin\",\"autoIPLCallbackHref\"),$html);\n\t\t\t\t$html = preg_replace_callback('/src=\"([^\"]*)\"/',array(\"BigTreeAdmin\",\"autoIPLCallbackSrc\"),$html);\n\t\t\t\t$html = BigTreeCMS::replaceHardRoots($html);\n\t\t\t}\n\t\t\treturn $html;\n\t\t}\n\t\t\n\t\tprivate static function autoIPLCallbackHref($matches) {\n\t\t\t$href = static::makeIPL(BigTreeCMS::replaceRelativeRoots($matches[1]));\n\t\t\treturn 'href=\"'.$href.'\"';\n\t\t}\n\t\tprivate static function autoIPLCallbackSrc($matches) {\n\t\t\t$src = static::makeIPL(BigTreeCMS::replaceRelativeRoots($matches[1]));\n\t\t\treturn 'src=\"'.$src.'\"';\n\t\t}\n\n\t\t/*\n\t\t\tFunction: backupDatabase\n\t\t\t\tBacks up the entire database to a given file.\n\n\t\t\tParameters:\n\t\t\t\tfile - Full file path to dump the database to.\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful.\n\t\t*/\n\n\t\tstatic function backupDatabase($file) {\n\t\t\tif (!BigTree::isDirectoryWritable($file)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$pointer = fopen($file,\"w\");\n\t\t\tfwrite($pointer,\"SET SESSION sql_mode = 'NO_AUTO_VALUE_ON_ZERO';\\n\");\n\t\t\tfwrite($pointer,\"SET foreign_key_checks = 0;\\n\\n\");\n\n\t\t\t// We need to dump the bigtree tables in the proper order or they will not properly be recreated with the right foreign keys\n\t\t\t$q = sqlquery(\"SHOW TABLES\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$table = current($f);\n\t\t\t\t\n\t\t\t\t// Write the drop / create statements\n\t\t\t\tfwrite($pointer,\"DROP TABLE IF EXISTS `$table`;\\n\");\n\t\t\t\t$definition = sqlfetch(sqlquery(\"SHOW CREATE TABLE `$table`\"));\n\t\t\t\tfwrite($pointer,str_replace(array(\"\\n\t\",\"\\n\"),\"\",end($definition)).\";\\n\");\n\n\t\t\t\t// Get all the table contents, write them out\n\t\t\t\t$rows = BigTree::tableContents($table);\n\t\t\t\tforeach ($rows as $row) {\n\t\t\t\t\tfwrite($pointer,$row.\";\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Separate it from the next table\n\t\t\t\tfwrite($pointer,\"\\n\");\n\t\t\t}\n\n\t\t\tfwrite($pointer,\"\\nSET foreign_key_checks = 1;\");\n\t\t\tfclose($pointer);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: canAccessGroup\n\t\t\t\tReturns whether or not the logged in user can access a module group.\n\t\t\t\tUtility for form field types / views -- we already know module group permissions are enabled so we skip some overhead\n\n\t\t\tParameters:\n\t\t\t\tmodule - A module entry.\n\t\t\t\tgroup - A group id.\n\n\t\t\tReturns:\n\t\t\t\tThe permission level if the user can access this group, otherwise false.\n\t\t*/\n\n\t\tfunction canAccessGroup($module,$group) {\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\n\t\t\t$id = $module[\"id\"];\n\t\t\t$level = false;\n\n\t\t\tif ($this->Permissions[\"module\"][$id] && $this->Permissions[\"module\"][$id] != \"n\") {\n\t\t\t\t$level = $this->Permissions[\"module\"][$id];\n\t\t\t}\n\n\t\t\tif (is_array($this->Permissions[\"module_gbp\"][$id])) {\n\t\t\t\t$gp = $this->Permissions[\"module_gbp\"][$id][$group];\n\t\t\t\tif ($gp != \"n\") {\n\t\t\t\t\tif ($gp == \"p\" || !$level) {\n\t\t\t\t\t\t$level = $gp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $level;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: canModifyChildren\n\t\t\t\tChecks whether the logged in user can modify all child pages of a page.\n\t\t\t\tAssumes we already know that we're a publisher of the parent.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page entry to check children for.\n\n\t\t\tReturns:\n\t\t\t\ttrue if the user can modify all the page children, otherwise false.\n\t\t*/\n\n\t\tfunction canModifyChildren($page) {\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_pages WHERE path LIKE '\".sqlescape($page[\"path\"]).\"%'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$perm = $this->Permissions[\"page\"][$f[\"id\"]];\n\t\t\t\tif ($perm == \"n\" || $perm == \"e\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: changePassword\n\t\t\t\tChanges a user's password via a password change hash and redirects to a success page.\n\n\t\t\tParameters:\n\t\t\t\thash - The unique hash generated by <forgotPassword>.\n\t\t\t\tpassword - The user's new password.\n\n\t\t\tSee Also:\n\t\t\t\t<forgotPassword>\n\n\t\t*/\n\n\t\tstatic function changePassword($hash,$password) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$hash = sqlescape($hash);\n\t\t\t$user = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE change_password_hash = '$hash'\"));\n\n\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], TRUE);\n\t\t\t$password = sqlescape($phpass->HashPassword(trim($password)));\n\n\t\t\tsqlquery(\"UPDATE bigtree_users SET password = '$password', change_password_hash = '' WHERE id = '\".$user[\"id\"].\"'\");\n\t\t\tsqlquery(\"UPDATE bigtree_login_bans SET expires = DATE_SUB(NOW(),INTERVAL 1 MINUTE) WHERE user = '\".$user[\"id\"].\"'\");\n\t\t\tBigTree::redirect(($bigtree[\"config\"][\"force_secure_login\"] ? str_replace(\"http://\",\"https://\",ADMIN_ROOT) : ADMIN_ROOT).\"login/reset-success/\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: checkAccess\n\t\t\t\tDetermines whether the logged in user has access to a module or not.\n\n\t\t\tParameters:\n\t\t\t\tmodule - Either a module id or module entry.\n\t\t\t\taction - Optionally, a module action array to also check levels against.\n\n\t\t\tReturns:\n\t\t\t\ttrue if the user can access the module, otherwise false.\n\t\t*/\n\n\t\tfunction checkAccess($module,$action = false) {\n\t\t\tif (is_array($module)) {\n\t\t\t\t$module = $module[\"id\"];\n\t\t\t}\n\n\t\t\tif (is_array($action) && $action[\"level\"] > $this->Level) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tif ($this->Permissions[\"module\"][$module] && $this->Permissions[\"module\"][$module] != \"n\") {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (isset($this->Permissions[\"module_gbp\"])) {\n\t\t\t\tif (is_array($this->Permissions[\"module_gbp\"][$module])) {\n\t\t\t\t\tforeach ($this->Permissions[\"module_gbp\"][$module] as $p) {\n\t\t\t\t\t\tif ($p != \"n\") {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: checkPOSTError\n\t\t\t\tChecks if an error occurred during a POST and redirects back to the originating page with a session var.\n\t\t*/\n\n\t\tfunction checkPOSTError() {\n\t\t\tglobal $bigtree;\n\n\t\t\tif (is_null($bigtree[\"php_boot_error\"])) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$error = false;\n\t\t\t$message = $bigtree[\"php_boot_error\"][\"message\"];\n\n\t\t\tif (strpos($message, \"POST Content-Length\") !== false) {\n\t\t\t\t$error = \"post_max_size\";\n\t\t\t}\n\n\t\t\tif (strpos($message, \"max_input_vars\") !== false) {\n\t\t\t\t$error = \"max_input_vars\";\n\t\t\t}\n\n\t\t\tif ($error) {\n\t\t\t\t$_SESSION[\"bigtree_admin\"][\"post_error\"] = $error;\n\n\t\t\t\tBigTree::redirect($_SERVER[\"HTTP_REFERER\"]);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: checkHTML\n\t\t\t\tChecks a block of HTML for broken links/images\n\n\t\t\tParameters:\n\t\t\t\trelative_path - The starting path of the page containing the HTML (so that relative links, i.e. \"good/\" know where to begin)\n\t\t\t\thtml - A string of HTML\n\t\t\t\texternal - Whether to check external links (slow) or not\n\n\t\t\tReturns:\n\t\t\t\tAn array containing two possible keys (a and img) which each could contain an array of errors.\n\t\t*/\n\n\t\tstatic function checkHTML($relative_path,$html,$external = false) {\n\t\t\tif (!$html) {\n\t\t\t\treturn array();\n\t\t\t}\n\t\t\t$errors = array();\n\t\t\t$doc = new DOMDocument();\n\t\t\t@$doc->loadHTML($html); // Silenced because the HTML could be invalid.\n\t\t\t// Check A tags.\n\t\t\t$links = $doc->getElementsByTagName(\"a\");\n\t\t\tforeach ($links as $link) {\n\t\t\t\t$href = $link->getAttribute(\"href\");\n\t\t\t\t$href = str_replace(array(\"{wwwroot}\",\"%7Bwwwroot%7D\",\"{staticroot}\",\"%7Bstaticroot%7D\"),array(WWW_ROOT,WWW_ROOT,STATIC_ROOT,STATIC_ROOT),$href);\n\t\t\t\tif ((substr($href,0,2) == \"//\" || substr($href,0,4) == \"http\") && strpos($href,WWW_ROOT) === false) {\n\t\t\t\t\t// External link, not much we can do but alert that it's dead\n\t\t\t\t\tif ($external) {\n\t\t\t\t\t\tif (strpos($href,\"#\") !== false) {\n\t\t\t\t\t\t\t$href = substr($href,0,strpos($href,\"#\")-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!static::urlExists($href)) {\n\t\t\t\t\t\t\t$errors[\"a\"][] = $href;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,6) == \"ipl://\") {\n\t\t\t\t\tif (!static::iplExists($href)) {\n\t\t\t\t\t\t$errors[\"a\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,6) == \"irl://\") {\n\t\t\t\t\tif (!static::irlExists($href)) {\n\t\t\t\t\t\t$errors[\"a\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,7) == \"mailto:\" || substr($href,0,1) == \"#\" || substr($href,0,5) == \"data:\" || substr($href,0,4) == \"tel:\") {\n\t\t\t\t\t// Don't do anything, it's a page mark, data URI, or email address\n\t\t\t\t} elseif (substr($href,0,4) == \"http\") {\n\t\t\t\t\t// It's a local hard link\n\t\t\t\t\tif (!static::urlExists($href)) {\n\t\t\t\t\t\t$errors[\"a\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,2) == \"//\") {\n\t\t\t\t\t// Protocol agnostic link\n\t\t\t\t\tif (!static::urlExists(\"http:\".$href)) {\n\t\t\t\t\t\t$errors[\"a\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Local file.\n\t\t\t\t\t$local = $relative_path.$href;\n\t\t\t\t\tif (!static::urlExists($local)) {\n\t\t\t\t\t\t$errors[\"a\"][] = $local;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check IMG tags.\n\t\t\t$images = $doc->getElementsByTagName(\"img\");\n\t\t\tforeach ($images as $image) {\n\t\t\t\t$href = $image->getAttribute(\"src\");\n\t\t\t\t$href = str_replace(array(\"{wwwroot}\",\"%7Bwwwroot%7D\",\"{staticroot}\",\"%7Bstaticroot%7D\"),array(WWW_ROOT,WWW_ROOT,STATIC_ROOT,STATIC_ROOT),$href);\n\t\t\t\tif (substr($href,0,4) == \"http\" && strpos($href,WWW_ROOT) === false) {\n\t\t\t\t\t// External link, not much we can do but alert that it's dead\n\t\t\t\t\tif ($external) {\n\t\t\t\t\t\tif (!static::urlExists($href)) {\n\t\t\t\t\t\t\t$errors[\"img\"][] = $href;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,6) == \"irl://\") {\n\t\t\t\t\tif (!static::irlExists($href)) {\n\t\t\t\t\t\t$errors[\"img\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,5) == \"data:\") {\n\t\t\t\t\t// Do nothing, it's a data URI\n\t\t\t\t} elseif (substr($href,0,4) == \"http\") {\n\t\t\t\t\t// It's a local hard link\n\t\t\t\t\tif (!static::urlExists($href)) {\n\t\t\t\t\t\t$errors[\"img\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} elseif (substr($href,0,2) == \"//\") {\n\t\t\t\t\t// Protocol agnostic src\n\t\t\t\t\tif (!static::urlExists(\"http:\".$href)) {\n\t\t\t\t\t\t$errors[\"img\"][] = $href;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Local file.\n\t\t\t\t\t$local = $relative_path.$href;\n\t\t\t\t\tif (!static::urlExists($local)) {\n\t\t\t\t\t\t$errors[\"img\"][] = $local;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $errors;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: clearCache\n\t\t\t\tRemoves all files in the cache directory.\n\t\t*/\n\n\t\tstatic function clearCache() {\n\t\t\t$d = opendir(SERVER_ROOT.\"cache/\");\n\t\t\twhile ($f = readdir($d)) {\n\t\t\t\tif ($f != \".\" && $f != \"..\" && !is_dir(SERVER_ROOT.\"cache/\".$f)) {\n\t\t\t\t\tunlink(SERVER_ROOT.\"cache/\".$f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: clearDead404s\n\t\t\t\tRemoves all 404s that don't have 301 redirects.\n\t\t*/\n\n\t\tfunction clearDead404s() {\n\t\t\tsqlquery(\"DELETE FROM bigtree_404s WHERE redirect_url = ''\");\n\t\t\t$this->track(\"bigtree_404s\",\"All\",\"Cleared Empty\");\n\t\t\tstatic::growl(\"404 Report\",\"Cleared 404s\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: create301\n\t\t\t\tCreates a 301 redirect.\n\n\t\t\tParameters:\n\t\t\t\tfrom - The 404 path\n\t\t\t\tto - The 301 target\n\t\t*/\n\n\t\tfunction create301($from,$to) {\n\t\t\t$from = sqlescape(htmlspecialchars(strip_tags(rtrim(str_replace(WWW_ROOT,\"\",$from),\"/\"))));\n\t\t\t$to = sqlescape(htmlspecialchars($this->autoIPL($to)));\n\n\t\t\t// See if the from already exists\n\t\t\t$existing = sqlfetch(sqlquery(\"SELECT * FROM bigtree_404s WHERE `broken_url` = '$from'\"));\n\t\t\tif ($existing) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_404s SET `redirect_url` = '$to' WHERE id = '\".$existing[\"id\"].\"'\");\n\t\t\t\t$this->track(\"bigtree_404s\",$existing[\"id\"],\"updated\");\n\t\t\t} else {\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_404s (`broken_url`,`redirect_url`) VALUES ('$from','$to')\");\n\t\t\t\t$this->track(\"bigtree_404s\",sqlid(),\"created\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createCallout\n\t\t\t\tCreates a callout and its files.\n\n\t\t\tParameters:\n\t\t\t\tid - The id.\n\t\t\t\tname - The name.\n\t\t\t\tdescription - The description.\n\t\t\t\tlevel - Access level (0 for everyone, 1 for administrators, 2 for developers).\n\t\t\t\tresources - An array of resources.\n\t\t\t\tdisplay_field - The field to use as the display field describing a user's callout\n\t\t\t\tdisplay_default - The text string to use in the event the display_field is blank or non-existent\n\t\t*/\n\n\t\tfunction createCallout($id,$name,$description,$level,$resources,$display_field,$display_default) {\n\t\t\t// Check to see if it's a valid ID\n\t\t\tif (!ctype_alnum(str_replace(array(\"-\",\"_\"),\"\",$id)) || strlen($id) > 127) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If we're creating a new file, let's populate it with some convenience things to show what resources are available.\n\t\t\t$file_contents = '<?\n\t/*\n\t\tResources Available:\n';\n\n\t\t\t$cached_types = $this->getCachedFieldTypes();\n\t\t\t$types = $cached_types[\"callouts\"];\n\n\t\t\t$clean_resources = array();\n\t\t\tforeach ($resources as $resource) {\n\t\t\t\t// \"type\" is still a reserved keyword due to the way we save callout data when editing.\n\t\t\t\tif ($resource[\"id\"] && $resource[\"id\"] != \"type\") {\n\t\t\t\t\t$field = array(\n\t\t\t\t\t\t\"id\" => BigTree::safeEncode($resource[\"id\"]),\n\t\t\t\t\t\t\"type\" => BigTree::safeEncode($resource[\"type\"]),\n\t\t\t\t\t\t\"title\" => BigTree::safeEncode($resource[\"title\"]),\n\t\t\t\t\t\t\"subtitle\" => BigTree::safeEncode($resource[\"subtitle\"]),\n\t\t\t\t\t\t\"options\" => BigTree::translateArray((array) @json_decode($resource[\"options\"],true))\n\t\t\t\t\t);\n\n\t\t\t\t\t// Backwards compatibility with BigTree 4.1 package imports\n\t\t\t\t\tforeach ($resource as $k => $v) {\n\t\t\t\t\t\tif (!in_array($k,array(\"id\",\"title\",\"subtitle\",\"type\",\"options\"))) {\n\t\t\t\t\t\t\t$field[\"options\"][$k] = $v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$clean_resources[] = $field;\n\n\t\t\t\t\t$file_contents .= '\t\t\"'.$resource[\"id\"].'\" = '.$resource[\"title\"].' - '.$types[$resource[\"type\"]][\"name\"].\"\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$file_contents .= '\t*/\n?>';\n\n\t\t\t// Clean up the post variables\n\t\t\t$id = sqlescape(BigTree::safeEncode($id));\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$level = sqlescape($level);\n\t\t\t$resources = BigTree::json($clean_resources,true);\n\t\t\t$display_default = sqlescape($display_default);\n\t\t\t$display_field = sqlescape($display_field);\n\n\t\t\tif (!file_exists(SERVER_ROOT.\"templates/callouts/\".$id.\".php\")) {\n\t\t\t\tBigTree::putFile(SERVER_ROOT.\"templates/callouts/\".$id.\".php\",$file_contents);\n\t\t\t}\n\n\t\t\t// Increase the count of the positions on all templates by 1 so that this new template is for sure in last position.\n\t\t\tsqlquery(\"UPDATE bigtree_callouts SET position = position + 1\");\n\t\t\tsqlquery(\"INSERT INTO bigtree_callouts (`id`,`name`,`description`,`resources`,`level`,`display_field`,`display_default`) VALUES ('$id','$name','$description','$resources','$level','$display_field','$display_default')\");\n\t\t\t$this->track(\"bigtree_callouts\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createCalloutGroup\n\t\t\t\tCreates a callout group.\n\n\t\t\tParameters:\n\t\t\t\tname - The name of the group.\n\t\t\t\tcallouts - An array of callout IDs to assign to the group.\n\n\t\t\tReturns:\n\t\t\t\tThe id of the newly created group.\n\t\t*/\n\n\t\tfunction createCalloutGroup($name,$callouts) {\n\t\t\tsort($callouts);\n\t\t\t$callouts = BigTree::json($callouts,true);\n\t\t\tsqlquery(\"INSERT INTO bigtree_callout_groups (`name`,`callouts`) VALUES ('\".sqlescape(BigTree::safeEncode($name)).\"','$callouts')\");\n\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_callout_groups\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createFeed\n\t\t\t\tCreates a feed.\n\n\t\t\tParameters:\n\t\t\t\tname - The name.\n\t\t\t\tdescription - The description.\n\t\t\t\ttable - The data table.\n\t\t\t\ttype - The feed type.\n\t\t\t\toptions - The feed type options.\n\t\t\t\tfields - The fields.\n\n\t\t\tReturns:\n\t\t\t\tThe route to the new feed.\n\t\t*/\n\n\t\tfunction createFeed($name,$description,$table,$type,$options,$fields) {\n\t\t\t// Options were encoded before submitting the form, so let's get them back.\n\t\t\t$options = json_decode($options,true);\n\t\t\tif (is_array($options)) {\n\t\t\t\tforeach ($options as &$option) {\n\t\t\t\t\t$option = BigTreeCMS::replaceHardRoots($option);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get a unique route!\n\t\t\t$route = BigTreeCMS::urlify($name);\n\t\t\t$x = 2;\n\t\t\t$oroute = $route;\n\t\t\t$f = BigTreeCMS::getFeedByRoute($route);\n\t\t\twhile ($f) {\n\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t$f = BigTreeCMS::getFeedByRoute($route);\n\t\t\t\t$x++;\n\t\t\t}\n\n\t\t\t// Fix stuff up for the db.\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\t\t\t$options = BigTree::json($options,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\t$route = sqlescape($route);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_feeds (`route`,`name`,`description`,`type`,`table`,`fields`,`options`) VALUES ('$route','$name','$description','$type','$table','$fields','$options')\");\n\t\t\t$this->track(\"bigtree_feeds\",sqlid(),\"created\");\n\n\t\t\treturn $route;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createFieldType\n\t\t\t\tCreates a field type and its files.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the field type.\n\t\t\t\tname - The name.\n\t\t\t\tuse_cases - Associate array of sections in which the field type can be used (i.e. array(\"pages\" => \"on\", \"modules\" => \"\",\"callouts\" => \"\",\"settings\" => \"\"))\n\t\t\t\tself_draw - Whether this field type will draw its <fieldset> and <label> (\"on\" or a falsey value)\n\t\t*/\n\n\t\tfunction createFieldType($id,$name,$use_cases,$self_draw) {\n\t\t\t// Check to see if it's a valid ID\n\t\t\tif (!ctype_alnum(str_replace(array(\"-\",\"_\"),\"\",$id)) || strlen($id) > 127) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$use_cases = sqlescape(json_encode($use_cases));\n\t\t\t$self_draw = $self_draw ? \"'on'\" : \"NULL\";\n\n\t\t\t$file = \"$id.php\";\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_field_types (`id`,`name`,`use_cases`,`self_draw`) VALUES ('$id','$name','$use_cases',$self_draw)\");\n\n\t\t\t// Make the files for draw and process and options if they don't exist.\n\t\t\tif (!file_exists(SERVER_ROOT.\"custom/admin/form-field-types/draw/$file\")) {\n\t\t\t\tBigTree::putFile(SERVER_ROOT.\"custom/admin/form-field-types/draw/$file\",'<?\n\t/*\n\t\tWhen drawing a field type you are provided with the $field array with the following keys:\n\t\t\t\"title\" \u2014 The title given by the developer to draw as the label (drawn automatically)\n\t\t\t\"subtitle\" \u2014 The subtitle given by the developer to draw as the smaller part of the label (drawn automatically)\n\t\t\t\"key\" \u2014 The value you should use for the \"name\" attribute of your form field\n\t\t\t\"value\" \u2014 The existing value for this form field\n\t\t\t\"id\" \u2014 A unique ID you can assign to your form field for use in JavaScript\n\t\t\t\"tabindex\" \u2014 The current tab index you can use for the \"tabindex\" attribute of your form field\n\t\t\t\"options\" \u2014 An array of options provided by the developer\n\t\t\t\"required\" \u2014 A boolean value of whether this form field is required or not\n\t*/\n\n\tinclude BigTree::path(\"admin/form-field-types/draw/text.php\");\n?>');\n\t\t\t\tBigTree::setPermissions(SERVER_ROOT.\"custom/admin/form-field-types/draw/$file\");\n\t\t\t}\n\t\t\tif (!file_exists(SERVER_ROOT.\"custom/admin/form-field-types/process/$file\")) {\n\t\t\t\tBigTree::putFile(SERVER_ROOT.\"custom/admin/form-field-types/process/$file\",'<?\n\t/*\n\t\tWhen processing a field type you are provided with the $field array with the following keys:\n\t\t\t\"key\" \u2014 The key of the field (this could be the database column for a module or the ID of the template or callout resource)\n\t\t\t\"options\" \u2014 An array of options provided by the developer\n\t\t\t\"input\" \u2014 The end user\\'s $_POST data input for this field\n\t\t\t\"file_input\" \u2014 The end user\\'s uploaded files for this field in a normalized entry from the $_FILES array in the same formatting you\\'d expect from \"input\"\n\n\t\tBigTree expects you to set $field[\"output\"] to the value you wish to store. If you want to ignore this field, set $field[\"ignore\"] to true.\n\t\tAlmost all text that is meant for drawing on the front end is expected to be run through PHP\\'s htmlspecialchars function as seen in the example below.\n\t\tIf you intend to allow HTML tags you will want to run htmlspecialchars in your drawing file on your value and leave it off in the process file.\n\t*/\n\n\t$field[\"output\"] = htmlspecialchars($field[\"input\"]);\n?>');\n\t\t\t\tBigTree::setPermissions(SERVER_ROOT.\"custom/admin/form-field-types/process/$file\");\n\t\t\t}\n\t\t\tif (!file_exists(SERVER_ROOT.\"custom/admin/ajax/developer/field-options/$file\")) {\n\t\t\t\tBigTree::touchFile(SERVER_ROOT.\"custom/admin/ajax/developer/field-options/$file\");\n\t\t\t\tBigTree::setPermissions(SERVER_ROOT.\"custom/admin/ajax/developer/field-options/$file\");\n\t\t\t}\n\n\t\t\tunlink(SERVER_ROOT.\"cache/bigtree-form-field-types.json\");\n\n\t\t\t$this->track(\"bigtree_field_types\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createMessage\n\t\t\t\tCreates a message in message center.\n\n\t\t\tParameters:\n\t\t\t\tsubject - The subject line.\n\t\t\t\tmessage - The message.\n\t\t\t\trecipients - The recipients.\n\t\t\t\tin_response_to - The message being replied to.\n\t\t*/\n\n\t\tfunction createMessage($subject,$message,$recipients,$in_response_to = 0) {\n\t\t\t// Clear tags out of the subject, sanitize the message body of XSS attacks.\n\t\t\t$subject = sqlescape(htmlspecialchars(strip_tags($subject)));\n\t\t\t$message = sqlescape(strip_tags($message,\"<p><b><strong><em><i><a>\"));\n\t\t\t$in_response_to = sqlescape($in_response_to);\n\n\t\t\t// We build the send_to field this way so that we don't have to create a second table of recipients.\n\t\t\t// Is it faster database wise using a LIKE over a JOIN? I don't know, but it makes for one less table.\n\t\t\t$send_to = \"|\";\n\t\t\tforeach ($recipients as $r) {\n\t\t\t\t// Make sure they actually put in a number and didn't try to screw with the $_POST\n\t\t\t\t$send_to .= intval($r).\"|\";\n\t\t\t}\n\n\t\t\t$send_to = sqlescape($send_to);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_messages (`sender`,`recipients`,`subject`,`message`,`date`,`response_to`) VALUES ('\".$this->ID.\"','$send_to','$subject','$message',NOW(),'$in_response_to')\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModule\n\t\t\t\tCreates a module and its class file.\n\n\t\t\tParameters:\n\t\t\t\tname - The name of the module.\n\t\t\t\tgroup - The group for the module.\n\t\t\t\tclass - The module class to create.\n\t\t\t\ttable - The table this module relates to.\n\t\t\t\tpermissions - The group-based permissions.\n\t\t\t\ticon - The icon to use.\n\t\t\t\troute - Desired route to use (defaults to auto generating if this is left false).\n\n\t\t\tReturns:\n\t\t\t\tThe new module id.\n\t\t*/\n\n\t\tfunction createModule($name,$group,$class,$table,$permissions,$icon,$route = false) {\n\t\t\t// Find an available module route.\n\t\t\t$route = $route ? $route : BigTreeCMS::urlify($name);\n\t\t\tif (!ctype_alnum(str_replace(\"-\",\"\",$route)) || strlen($route) > 127) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Go through the hard coded modules\n\t\t\t$existing = array();\n\t\t\t$d = opendir(SERVER_ROOT.\"core/admin/modules/\");\n\t\t\twhile ($f = readdir($d)) {\n\t\t\t\tif ($f != \".\" && $f != \"..\") {\n\t\t\t\t\t$existing[] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Go through the directories (really ajax, css, images, js)\n\t\t\t$d = opendir(SERVER_ROOT.\"core/admin/\");\n\t\t\twhile ($f = readdir($d)) {\n\t\t\t\tif ($f != \".\" && $f != \"..\") {\n\t\t\t\t\t$existing[] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Go through the hard coded pages\n\t\t\t$d = opendir(SERVER_ROOT.\"core/admin/pages/\");\n\t\t\twhile ($f = readdir($d)) {\n\t\t\t\tif ($f != \".\" && $f != \"..\") {\n\t\t\t\t\t// Drop the .php\n\t\t\t\t\t$existing[] = substr($f,0,-4);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Go through already created modules\n\t\t\t$q = sqlquery(\"SELECT route FROM bigtree_modules\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$existing[] = $f[\"route\"];\n\t\t\t}\n\n\t\t\t// Get a unique route\n\t\t\t$x = 2;\n\t\t\t$oroute = $route;\n\t\t\twhile (in_array($route,$existing)) {\n\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t$x++;\n\t\t\t}\n\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$route = sqlescape($route);\n\t\t\t$class = sqlescape($class);\n\t\t\t$group = $group ? \"'\".sqlescape($group).\"'\" : \"NULL\";\n\t\t\t$gbp = BigTree::json($permissions,true);\n\t\t\t$icon = sqlescape($icon);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_modules (`name`,`route`,`class`,`icon`,`group`,`gbp`) VALUES ('$name','$route','$class','$icon',$group,'$gbp')\");\n\t\t\t$id = sqlid();\n\n\t\t\tif ($class) {\n\t\t\t\t// Create class module.\n\t\t\t\t$f = fopen(SERVER_ROOT.\"custom/inc/modules/$route.php\",\"w\");\n\t\t\t\tfwrite($f,\"<?\\n\");\n\t\t\t\tfwrite($f,\"\tclass $class extends BigTreeModule {\\n\");\n\t\t\t\tfwrite($f,'\t\tvar $Table = \"'.$table.'\";'.\"\\n\");\n\t\t\t\tfwrite($f,\"\t}\\n\");\n\t\t\t\tfwrite($f,\"?>\\n\");\n\t\t\t\tfclose($f);\n\t\t\t\tBigTree::setPermissions(SERVER_ROOT.\"custom/inc/modules/$route.php\");\n\n\t\t\t\t// Remove cached class list.\n\t\t\t\tunlink(SERVER_ROOT.\"cache/bigtree-module-class-list.json\");\n\t\t\t}\n\n\t\t\t$this->track(\"bigtree_modules\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleAction\n\t\t\t\tCreates a module action.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module to create an action for.\n\t\t\t\tname - The name of the action.\n\t\t\t\troute - The action route.\n\t\t\t\tin_nav - Whether the action is in the navigation.\n\t\t\t\ticon - The icon class for the action.\n\t\t\t\tform - The associated form.\n\t\t\t\tview - The associated view.\n\t\t\t\treport - The associated report.\n\t\t\t\tlevel - The required access level.\n\t\t\t\tposition - The position in navigation.\n\n\t\t\tReturns:\n\t\t\t\tThe action's route.\n\t\t*/\n\n\t\tfunction createModuleAction($module,$name,$route,$in_nav,$icon,$form = 0,$view = 0,$report = 0,$level = 0,$position = 0) {\n\t\t\t$module = sqlescape($module);\n\t\t\t$route = sqlescape(BigTree::safeEncode($route));\n\t\t\t$in_nav = sqlescape($in_nav);\n\t\t\t$icon = sqlescape($icon);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$form = $form ? \"'\".sqlescape($form).\"'\" : \"NULL\";\n\t\t\t$view = $view ? \"'\".sqlescape($view).\"'\" : \"NULL\";\n\t\t\t$report = $report ? \"'\".sqlescape($report).\"'\" : \"NULL\";\n\t\t\t$level = sqlescape($level);\n\t\t\t$position = sqlescape($position);\n\t\t\t$route = $this->uniqueModuleActionRoute($module,$route);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_actions (`module`,`name`,`route`,`in_nav`,`class`,`level`,`form`,`view`,`report`,`position`) VALUES ('$module','$name','$route','$in_nav','$icon','$level',$form,$view,$report,'$position')\");\n\t\t\t\n\t\t\t$this->track(\"bigtree_module_actions\",sqlid(),\"created\");\n\n\t\t\treturn $route;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleEmbedForm\n\t\t\t\tCreates an embeddable form.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module ID that this form relates to.\n\t\t\t\ttitle - The title of the form.\n\t\t\t\ttable - The table for the form data.\n\t\t\t\tfields - The form fields.\n\t\t\t\thooks - An array of \"pre\", \"post\", and \"publish\" keys that can be function names to call\n\t\t\t\tdefault_position - Default position for entries to the form (if the view is positioned).\n\t\t\t\tdefault_pending - Whether the submissions to default to pending or not (\"on\" or \"\").\n\t\t\t\tcss - URL of a CSS file to include.\n\t\t\t\tredirect_url - The URL to redirect to upon completion of submission.\n\t\t\t\tthank_you_message - The message to display upon completeion of submission.\n\n\t\t\tReturns:\n\t\t\t\tThe embed code.\n\t\t*/\n\n\t\tfunction createModuleEmbedForm($module,$title,$table,$fields,$hooks = array(),$default_position = \"\",$default_pending = \"\",$css = \"\",$redirect_url = \"\",$thank_you_message = \"\") {\n\t\t\t$module = sqlescape($module);\n\t\t\t$sql_title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$hooks = BigTree::json(json_decode($hooks),true);\n\t\t\t$default_position = sqlescape($default_position);\n\t\t\t$default_pending = $default_pending ? \"on\" : \"\";\n\t\t\t$css = sqlescape(BigTree::safeEncode($this->makeIPL($css)));\n\t\t\t$redirect_url = sqlescape(BigTree::safeEncode($redirect_url));\n\t\t\t$thank_you_message = sqlescape($thank_you_message);\n\t\t\t$hash = uniqid();\n\n\t\t\t$clean_fields = array();\n\t\t\tforeach ($fields as $key => $field) {\n\t\t\t\t$field[\"options\"] = BigTree::translateArray(json_decode($field[\"options\"],true));\n\t\t\t\t$field[\"column\"] = $key;\n\t\t\t\t$clean_fields[] = $field;\n\t\t\t}\n\t\t\t$fields = BigTree::json($clean_fields,true);\n\n\t\t\t// Make sure this isn't used already\n\t\t\twhile (sqlrows(sqlquery(\"SELECT * FROM bigtree_module_embeds WHERE hash = '$hash'\"))) {\n\t\t\t\t$hash = uniqid();\n\t\t\t}\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_embeds (`module`,`title`,`table`,`fields`,`default_position`,`default_pending`,`css`,`redirect_url`,`thank_you_message`,`hash`,`hooks`) VALUES ('$module','$sql_title','$table','$fields','$default_position','$default_pending','$css','$redirect_url','$thank_you_message','$hash','$hooks')\");\n\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_module_embeds\",$id,\"created\");\n\n\t\t\treturn htmlspecialchars('<div id=\"bigtree_embeddable_form_container_'.$id.'\">'.$title.'</div>'.\"\\n\".'<script type=\"text/javascript\" src=\"'.ADMIN_ROOT.'js/embeddable-form.js?id='.$id.'&hash='.$hash.'\"></script>');\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleForm\n\t\t\t\tCreates a module form.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module ID that this form relates to.\n\t\t\t\ttitle - The title of the form.\n\t\t\t\ttable - The table for the form data.\n\t\t\t\tfields - The form fields.\n\t\t\t\thooks - An array of \"pre\", \"post\", and \"publish\" keys that can be function names to call\n\t\t\t\tdefault_position - Default position for entries to the form (if the view is positioned).\n\t\t\t\treturn_view - The view to return to after completing the form.\n\t\t\t\treturn_url - The alternative URL to return to after completing the form.\n\t\t\t\ttagging - Whether or not to enable tagging.\n\n\t\t\tReturns:\n\t\t\t\tThe new form id.\n\t\t*/\n\n\t\tfunction createModuleForm($module,$title,$table,$fields,$hooks = array(),$default_position = \"\",$return_view = false,$return_url = \"\",$tagging = \"\") {\n\t\t\t$module = sqlescape($module);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$hooks = BigTree::json(is_array($hooks) ? $hooks : json_decode($hooks),true);\n\t\t\t$default_position = sqlescape($default_position);\n\t\t\t$return_view = $return_view ? \"'\".sqlescape($return_view).\"'\" : \"NULL\";\n\t\t\t$return_url = sqlescape($this->makeIPL($return_url));\n\t\t\t$tagging = $tagging ? \"on\" : \"\";\n\n\t\t\t$clean_fields = array();\n\t\t\tforeach ($fields as $key => $data) {\n\t\t\t\t$field = array(\n\t\t\t\t\t\"column\" => $data[\"column\"] ? $data[\"column\"] : $key,\n\t\t\t\t\t\"type\" => BigTree::safeEncode($data[\"type\"]),\n\t\t\t\t\t\"title\" => BigTree::safeEncode($data[\"title\"]),\n\t\t\t\t\t\"subtitle\" => BigTree::safeEncode($data[\"subtitle\"]),\n\t\t\t\t\t\"options\" => BigTree::translateArray(is_array($data[\"options\"]) ? $data[\"options\"] : (array)@json_decode($data[\"options\"],true))\n\t\t\t\t);\n\t\t\t\t// Backwards compatibility with BigTree 4.1 package imports\n\t\t\t\tforeach ($data as $k => $v) {\n\t\t\t\t\tif (!in_array($k,array(\"title\",\"subtitle\",\"type\",\"options\"))) {\n\t\t\t\t\t\t$field[\"options\"][$k] = $v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$clean_fields[] = $field;\n\t\t\t}\n\t\t\t$fields = BigTree::json($clean_fields,true);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_forms (`module`,`title`,`table`,`fields`,`default_position`,`return_view`,`return_url`,`tagging`,`hooks`) VALUES ('$module','$title','$table','$fields','$default_position',$return_view,'$return_url','$tagging','$hooks')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_module_forms\",$id,\"created\");\n\n\t\t\t// Get related views for this table and update numeric status\n\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_module_views WHERE `table` = '$table'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tstatic::updateModuleViewColumnNumericStatus(BigTreeAutoModule::getView($f[\"id\"]));\n\t\t\t}\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleGroup\n\t\t\t\tCreates a module group.\n\n\t\t\tParameters:\n\t\t\t\tname - The name of the group.\n\n\t\t\tReturns:\n\t\t\t\tThe id of the newly created group.\n\t\t*/\n\n\t\tfunction createModuleGroup($name) {\n\t\t\t// Get a unique route\n\t\t\t$x = 2;\n\t\t\t$route = BigTreeCMS::urlify($name);\n\t\t\t$oroute = $route;\n\t\t\twhile ($this->getModuleGroupByRoute($route)) {\n\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t$x++;\n\t\t\t}\n\n\t\t\t$route = sqlescape($route);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_groups (`name`,`route`) VALUES ('$name','$route')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_module_groups\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleReport\n\t\t\t\tCreates a module report and the associated module action.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module ID that this report relates to.\n\t\t\t\ttitle - The title of the report.\n\t\t\t\ttable - The table for the report data.\n\t\t\t\ttype - The type of report (csv or view).\n\t\t\t\tfilters - The filters a user can use to create the report.\n\t\t\t\tfields - The fields to show in the CSV export (if type = csv).\n\t\t\t\tparser - An optional parser function to run on the CSV export data (if type = csv).\n\t\t\t\tview - A module view ID to use (if type = view).\n\n\t\t\tReturns:\n\t\t\t\tThe id of the report.\n\t\t*/\n\n\t\tfunction createModuleReport($module,$title,$table,$type,$filters,$fields = \"\",$parser = \"\",$view = \"\") {\n\t\t\t$module = sqlescape($module);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\t\t\t$filters = BigTree::json($filters,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\t$parser = sqlescape($parser);\n\t\t\t$view = $view ? \"'\".sqlescape($view).\"'\" : \"NULL\";\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_reports (`module`,`title`,`table`,`type`,`filters`,`fields`,`parser`,`view`) VALUES ('$module','$title','$table','$type','$filters','$fields','$parser',$view)\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_module_reports\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createModuleView\n\t\t\t\tCreates a module view.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module ID that this view relates to.\n\t\t\t\ttitle - View title.\n\t\t\t\tdescription - Description.\n\t\t\t\ttable - Data table.\n\t\t\t\ttype - View type.\n\t\t\t\toptions - View options array.\n\t\t\t\tfields - Field array.\n\t\t\t\tactions - Actions array.\n\t\t\t\trelated_form - Form ID to handle edits.\n\t\t\t\tpreview_url - Optional preview URL.\n\n\t\t\tReturns:\n\t\t\t\tThe id for view.\n\t\t*/\n\n\t\tfunction createModuleView($module,$title,$description,$table,$type,$options,$fields,$actions,$related_form,$preview_url = \"\") {\n\t\t\t$module = sqlescape($module);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\n\t\t\t$options = BigTree::json($options,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\t$actions = BigTree::json($actions,true);\n\t\t\t$related_form = $related_form ? intval($related_form) : \"NULL\";\n\t\t\t$preview_url = sqlescape(BigTree::safeEncode($this->makeIPL($preview_url)));\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_module_views (`module`,`title`,`description`,`type`,`fields`,`actions`,`table`,`options`,`preview_url`,`related_form`) VALUES ('$module','$title','$description','$type','$fields','$actions','$table','$options','$preview_url',$related_form)\");\n\n\t\t\t$id = sqlid();\n\t\t\tstatic::updateModuleViewColumnNumericStatus(BigTreeAutoModule::getView($id));\n\t\t\t$this->track(\"bigtree_module_views\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createPage\n\t\t\t\tCreates a page.\n\t\t\t\tDoes not check permissions.\n\n\t\t\tParameters:\n\t\t\t\tdata - An array of page information.\n\n\t\t\tReturns:\n\t\t\t\tThe id of the newly created page.\n\t\t*/\n\n\t\tfunction createPage($data) {\n\t\t\t// Defaults\n\t\t\t$parent = 0;\n\t\t\t$title = $nav_title = $meta_description = $meta_keywords = $external = $template = $in_nav = \"\";\n\t\t\t$seo_invisible = $publish_at = $expire_at = $trunk = $new_window = $max_age = false;\n\t\t\t$resources = array();\n\n\t\t\t// Loop through the posted data, make sure no session hijacking is done.\n\t\t\tforeach ($data as $key => $val) {\n\t\t\t\tif (substr($key,0,1) != \"_\") {\n\t\t\t\t\tif (is_array($val)) {\n\t\t\t\t\t\t$$key = BigTree::json($val,true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$key = sqlescape($val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there's an external link, make sure it's a relative URL\n\t\t\tif ($external) {\n\t\t\t\t$external = $this->makeIPL($external);\n\t\t\t}\n\n\n\t\t\t// Who knows what they may have put in for a route, so we're not going to use the sqlescape version.\n\t\t\t$route = $data[\"route\"];\n\t\t\tif (!$route) {\n\t\t\t\t// If they didn't specify a route use the navigation title\n\t\t\t\t$route = BigTreeCMS::urlify($data[\"nav_title\"]);\n\t\t\t} else {\n\t\t\t\t// Otherwise sanitize the one they did provide.\n\t\t\t\t$route = BigTreeCMS::urlify($route);\n\t\t\t}\n\n\t\t\t// We need to figure out a unique route for the page. Make sure it doesn't match a directory in /site/\n\t\t\t$original_route = $route;\n\t\t\t$x = 2;\n\t\t\t// Reserved paths.\n\t\t\tif ($parent == 0) {\n\t\t\t\twhile (file_exists(SERVER_ROOT.\"site/\".$route.\"/\")) {\n\t\t\t\t\t$route = $original_route.\"-\".$x;\n\t\t\t\t\t$x++;\n\t\t\t\t}\n\t\t\t\twhile (in_array($route,static::$ReservedTLRoutes)) {\n\t\t\t\t\t$route = $original_route.\"-\".$x;\n\t\t\t\t\t$x++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make sure it doesn't have the same route as any of its siblings.\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pages WHERE `route` = '$route' AND parent = '$parent'\"));\n\t\t\twhile ($f) {\n\t\t\t\t$route = $original_route.\"-\".$x;\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pages WHERE `route` = '$route' AND parent = '$parent'\"));\n\t\t\t\t$x++;\n\t\t\t}\n\n\t\t\t// Make sure route isn't longer than 255\n\t\t\t$route = substr($route,0,255);\n\n\t\t\t// If we have a parent, get the full navigation path, otherwise, just use this route as the path since it's top level.\n\t\t\tif ($parent) {\n\t\t\t\t$path = $this->getFullNavigationPath($parent).\"/\".$route;\n\t\t\t} else {\n\t\t\t\t$path = $route;\n\t\t\t}\n\n\t\t\t// If we set a publish at date, make it the proper MySQL format.\n\t\t\tif ($publish_at && $publish_at != \"NULL\") {\n\t\t\t\t$publish_at = \"'\".date(\"Y-m-d\",strtotime($publish_at)).\"'\";\n\t\t\t} else {\n\t\t\t\t$publish_at = \"NULL\";\n\t\t\t}\n\n\t\t\t// If we set an expiration date, make it the proper MySQL format.\n\t\t\tif ($expire_at && $expire_at != \"NULL\") {\n\t\t\t\t$expire_at = \"'\".date(\"Y-m-d\",strtotime($expire_at)).\"'\";\n\t\t\t} else {\n\t\t\t\t$expire_at = \"NULL\";\n\t\t\t}\n\n\t\t\t// Make the title, navigation title, description, keywords, and external link htmlspecialchar'd -- these are all things we'll be echoing in the HTML so we might as well make them valid now instead of at display time.\n\n\t\t\t$title = htmlspecialchars($title);\n\t\t\t$nav_title = htmlspecialchars($nav_title);\n\t\t\t$meta_description = htmlspecialchars($meta_description);\n\t\t\t$meta_keywords = htmlspecialchars($meta_keywords);\n\t\t\t$seo_invisible = $seo_invisible ? \"on\" : \"\";\n\t\t\t$external = htmlspecialchars($external);\n\n\t\t\t// Set the trunk flag back to no if the user isn't a developer\n\t\t\tif ($this->Level < 2) {\n\t\t\t\t$trunk = \"\";\n\t\t\t} else {\n\t\t\t\t$trunk = sqlescape($trunk);\n\t\t\t}\n\n\t\t\t// Make the page!\n\t\t\tsqlquery(\"INSERT INTO bigtree_pages (`trunk`,`parent`,`nav_title`,`route`,`path`,`in_nav`,`title`,`template`,`external`,`new_window`,`resources`,`meta_keywords`,`meta_description`,`seo_invisible`,`last_edited_by`,`created_at`,`updated_at`,`publish_at`,`expire_at`,`max_age`) VALUES ('$trunk','$parent','$nav_title','$route','$path','$in_nav','$title','$template','$external','$new_window','$resources','$meta_keywords','$meta_description','$seo_invisible','\".$this->ID.\"',NOW(),NOW(),$publish_at,$expire_at,'$max_age')\");\n\n\t\t\t$id = sqlid();\n\n\t\t\t// Handle tags\n\t\t\tif (is_array($data[\"_tags\"])) {\n\t\t\t\tforeach ($data[\"_tags\"] as $tag) {\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_tags_rel (`table`,`entry`,`tag`) VALUES ('bigtree_pages','$id','$tag')\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there was an old page that had previously used this path, dump its history so we can take over the path.\n\t\t\tsqlquery(\"DELETE FROM bigtree_route_history WHERE old_route = '$path'\");\n\n\t\t\t// Dump the cache, we don't really know how many pages may be showing this now in their nav.\n\t\t\t$this->clearCache();\n\t\t\t// Let search engines know this page now exists.\n\t\t\t$this->pingSearchEngines();\n\t\t\t// Audit trail.\n\t\t\t$this->track(\"bigtree_pages\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createPendingChange\n\t\t\t\tCreates a pending change.\n\n\t\t\tParameters:\n\t\t\t\ttable - The table the change applies to.\n\t\t\t\titem_id - The entry the change applies to's id.\n\t\t\t\tchanges - The changes to the fields in the entry.\n\t\t\t\tmtm_changes - Many to Many changes.\n\t\t\t\ttags_changes - Tags changes.\n\t\t\t\tmodule - The module id for the change.\n\n\t\t\tReturns:\n\t\t\t\tThe change id.\n\t\t*/\n\n\t\tfunction createPendingChange($table,$item_id,$changes,$mtm_changes = array(),$tags_changes = array(),$module = 0) {\n\t\t\t$table = sqlescape($table);\n\t\t\t$item_id = ($item_id !== false) ? \"'\".sqlescape($item_id).\"'\" : \"NULL\";\n\t\t\t$changes = BigTree::json($changes,true);\n\t\t\t$mtm_changes = BigTree::json($mtm_changes,true);\n\t\t\t$tags_changes = BigTree::json($tags_changes,true);\n\t\t\t$module = sqlescape($module);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_pending_changes (`user`,`date`,`table`,`item_id`,`changes`,`mtm_changes`,`tags_changes`,`module`) VALUES ('\".$this->ID.\"',NOW(),'$table',$item_id,'$changes','$mtm_changes','$tags_changes','$module')\");\n\t\t\treturn sqlid();\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createPendingPage\n\t\t\t\tCreates a pending page entry in bigtree_pending_changes\n\n\t\t\tParameters:\n\t\t\t\tdata - An array of page information.\n\n\t\t\tReturns:\n\t\t\t\tThe id of the pending change.\n\t\t*/\n\n\t\tfunction createPendingPage($data) {\n\t\t\t// Make a relative URL for external links.\n\t\t\tif ($data[\"external\"]) {\n\t\t\t\t$data[\"external\"] = $this->makeIPL($data[\"external\"]);\n\t\t\t}\n\n\t\t\t// Save the tags, then dump them from the saved changes array.\n\t\t\t$tags = BigTree::json($data[\"_tags\"],true);\n\t\t\tunset($data[\"_tags\"]);\n\n\t\t\t// Make the nav title, title, external link, keywords, and description htmlspecialchar'd for displaying on the front end / the form again.\n\t\t\t$data[\"nav_title\"] = htmlspecialchars($data[\"nav_title\"]);\n\t\t\t$data[\"title\"] = htmlspecialchars($data[\"title\"]);\n\t\t\t$data[\"external\"] = htmlspecialchars($data[\"external\"]);\n\t\t\t$data[\"meta_keywords\"] = htmlspecialchars($data[\"meta_keywords\"]);\n\t\t\t$data[\"meta_description\"] = htmlspecialchars($data[\"meta_description\"]);\n\n\t\t\t// Set the trunk flag back to no if the user isn't a developer\n\t\t\tif ($this->Level < 2) {\n\t\t\t\t$data[\"trunk\"] = \"\";\n\t\t\t} else {\n\t\t\t\t$data[\"trunk\"] = sqlescape($data[\"trunk\"]);\n\t\t\t}\n\n\t\t\t$parent = sqlescape($data[\"parent\"]);\n\n\t\t\t// JSON encode the changes and stick them in the database.\n\t\t\tunset($data[\"MAX_FILE_SIZE\"]);\n\t\t\tunset($data[\"ptype\"]);\n\t\t\t$data = BigTree::json($data,true);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_pending_changes (`user`,`date`,`title`,`table`,`changes`,`tags_changes`,`type`,`module`,`pending_page_parent`) VALUES ('\".$this->ID.\"',NOW(),'New Page Created','bigtree_pages','$data','$tags','NEW','','$parent')\");\n\t\t\t$id = sqlid();\n\n\t\t\t// Audit trail\n\t\t\t$this->track(\"bigtree_pages\",\"p$id\",\"created-pending\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createResource\n\t\t\t\tCreates a resource.\n\n\t\t\tParameters:\n\t\t\t\tfolder - The folder to place it in.\n\t\t\t\tfile - The file path.\n\t\t\t\tmd5 - The MD5 hash of the file.\n\t\t\t\tname - The file name.\n\t\t\t\ttype - The file type.\n\t\t\t\tis_image - Whether the resource is an image.\n\t\t\t\theight - The image height (if it's an image).\n\t\t\t\twidth - The image width (if it's an image).\n\t\t\t\tthumbs - An array of thumbnails (if it's an image).\n\n\t\t\tReturns:\n\t\t\t\tThe new resource id.\n\t\t*/\n\n\t\tfunction createResource($folder,$file,$md5,$name,$type,$is_image = \"\",$height = 0,$width = 0,$thumbs = array()) {\n\t\t\t$folder = $folder ? \"'\".sqlescape($folder).\"'\" : \"NULL\";\n\t\t\t$file = sqlescape(BigTreeCMS::replaceHardRoots($file));\n\t\t\t$name = sqlescape(htmlspecialchars($name));\n\t\t\t$type = sqlescape($type);\n\t\t\t$is_image = sqlescape($is_image);\n\t\t\t$height = intval($height);\n\t\t\t$width = intval($width);\n\t\t\t$thumbs = BigTree::json($thumbs,true);\n\t\t\t$md5 = sqlescape($md5);\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_resources (`file`,`md5`,`date`,`name`,`type`,`folder`,`is_image`,`height`,`width`,`thumbs`) VALUES ('$file','$md5',NOW(),'$name','$type',$folder,'$is_image','$height','$width','$thumbs')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_resources\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createResourceFolder\n\t\t\t\tCreates a resource folder.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tparent - The parent folder.\n\t\t\t\tname - The name of the new folder.\n\n\t\t\tReturns:\n\t\t\t\tThe new folder id.\n\t\t*/\n\n\t\tfunction createResourceFolder($parent,$name) {\n\t\t\t$perm = $this->getResourceFolderPermission($parent);\n\t\t\tif ($perm != \"p\") {\n\t\t\t\tdie(\"You don't have permission to make a folder here.\");\n\t\t\t}\n\n\t\t\t$parent = sqlescape($parent);\n\t\t\t$name = sqlescape(htmlspecialchars(trim($name)));\n\n\t\t\tif (!$name) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_resource_folders (`name`,`parent`) VALUES ('$name','$parent')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_resource_folders\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createSetting\n\t\t\t\tCreates a setting.\n\n\t\t\tParameters:\n\t\t\t\tdata - An array of settings information. Available fields: \"id\", \"name\", \"description\", \"type\", \"locked\", \"module\", \"encrypted\", \"system\"\n\n\t\t\tReturns:\n\t\t\t\tTrue if successful, false if a setting already exists with the ID given.\n\t\t*/\n\n\t\tfunction createSetting($data) {\n\t\t\t// Setup defaults\n\t\t\t$id = $name = $extension = $description = $type = $options = $locked = $encrypted = $system = \"\";\n\t\t\tforeach ($data as $key => $val) {\n\t\t\t\tif (substr($key,0,1) != \"_\" && !is_array($val)) {\n\t\t\t\t\t$$key = sqlescape(htmlspecialchars($val));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$extension = $extension ? \"'$extension'\" : \"NULL\";\n\n\t\t\t// If an extension is creating a setting, make it a reference back to the extension\n\t\t\tif (defined(\"EXTENSION_ROOT\")) {\n\t\t\t\t$extension = sqlescape(rtrim(str_replace(SERVER_ROOT.\"extensions/\",\"\",EXTENSION_ROOT),\"/\"));\n\t\t\t\t// Don't append extension again if it's already being called via the namespace\n\t\t\t\tif (strpos($id,\"$extension*\") === false) {\n\t\t\t\t\t$id = \"$extension*$id\";\n\t\t\t\t}\n\t\t\t\t$extension = \"'$extension'\";\n\t\t\t}\n\n\t\t\t// We don't want this encoded since it's a WYSIWYG field.\n\t\t\t$description = isset($data[\"description\"]) ? sqlescape($data[\"description\"]) : \"\";\n\t\t\t\n\t\t\t// We don't want this encoded since it's JSON\n\t\t\tif (isset($data[\"options\"])) {\n\t\t\t\tif (is_string($data[\"options\"])) {\n\t\t\t\t\t$data[\"options\"] = json_decode($data[\"options\"], true);\n\t\t\t\t}\n\n\t\t\t\tforeach ($data[\"options\"] as $key => $value) {\n\t\t\t\t\tif ($key == \"options\" && is_string($value)) {\n\t\t\t\t\t\t$data[\"options\"][$key] = json_decode($value, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t$options = BigTree::json(BigTree::translateArray($data[\"options\"]), true);\n\t\t\t}\n\n\t\t\t// See if there's already a setting with this ID\n\t\t\t$r = sqlrows(sqlquery(\"SELECT id FROM bigtree_settings WHERE id = '$id'\"));\n\t\t\tif ($r) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_settings (`id`,`name`,`description`,`type`,`options`,`locked`,`encrypted`,`system`,`extension`) VALUES ('$id','$name','$description','$type','$options','$locked','$encrypted','$system',$extension)\");\n\t\t\t$this->track(\"bigtree_settings\",$id,\"created\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createTag\n\t\t\t\tCreates a new tag, or returns the id of an existing one.\n\n\t\t\tParameters:\n\t\t\t\ttag - The tag.\n\n\t\t\tReturns:\n\t\t\t\tIf the tag exists, returns the existing tag's id.\n\t\t\t\tOtherwise, returns the new tag id.\n\t\t*/\n\n\t\tfunction createTag($tag) {\n\t\t\t$tag = strtolower(html_entity_decode(trim($tag)));\n\t\t\t// Check if the tag exists already.\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE tag = '\".sqlescape($tag).\"'\"));\n\n\t\t\tif (!$f) {\n\t\t\t\t$meta = metaphone($tag);\n\t\t\t\t$route = BigTreeCMS::urlify($tag);\n\t\t\t\t$oroute = $route;\n\t\t\t\t$x = 2;\n\t\t\t\twhile ($f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE route = '$route'\"))) {\n\t\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t\t$x++;\n\t\t\t\t}\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_tags (`tag`,`metaphone`,`route`) VALUES ('\".sqlescape($tag).\"','$meta','$route')\");\n\t\t\t\t$id = sqlid();\n\t\t\t} else {\n\t\t\t\t$id = $f[\"id\"];\n\t\t\t}\n\n\t\t\t$this->track(\"bigtree_tags\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createTemplate\n\t\t\t\tCreates a template and its default files/directories.\n\n\t\t\tParameters:\n\t\t\t\tid - Id for the template.\n\t\t\t\tname - Name\n\t\t\t\trouted - Basic (\"\") or Routed (\"on\")\n\t\t\t\tlevel - Access level (0 for everyone, 1 for administrators, 2 for developers)\n\t\t\t\tmodule - Related module id\n\t\t\t\tresources - An array of resources\n\t\t*/\n\n\t\tfunction createTemplate($id,$name,$routed,$level,$module,$resources) {\n\t\t\t// Check to see if it's a valid ID\n\t\t\tif (!ctype_alnum(str_replace(array(\"-\",\"_\"),\"\",$id)) || strlen($id) > 127) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If we're creating a new file, let's populate it with some convenience things to show what resources are available.\n\t\t\t$file_contents = \"<?\\n\t/*\\n\t\tResources Available:\\n\";\n\n\t\t\t$types = $this->getCachedFieldTypes();\n\t\t\t$types = $types[\"templates\"];\n\n\t\t\t$clean_resources = array();\n\t\t\tforeach ($resources as $resource) {\n\t\t\t\tif ($resource[\"id\"]) {\n\t\t\t\t\t$field = array(\n\t\t\t\t\t\t\"id\" => BigTree::safeEncode($resource[\"id\"]),\n\t\t\t\t\t\t\"type\" => BigTree::safeEncode($resource[\"type\"]),\n\t\t\t\t\t\t\"title\" => BigTree::safeEncode($resource[\"title\"]),\n\t\t\t\t\t\t\"subtitle\" => BigTree::safeEncode($resource[\"subtitle\"]),\n\t\t\t\t\t\t\"options\" => BigTree::translateArray((array)@json_decode($resource[\"options\"],true))\n\t\t\t\t\t);\n\n\t\t\t\t\t// Backwards compatibility with BigTree 4.1 package imports\n\t\t\t\t\tforeach ($resource as $k => $v) {\n\t\t\t\t\t\tif (!in_array($k,array(\"id\",\"title\",\"subtitle\",\"type\",\"options\"))) {\n\t\t\t\t\t\t\t$field[\"options\"][$k] = $v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$clean_resources[] = $field;\n\n\t\t\t\t\t$file_contents .= '\t\t$'.$resource[\"id\"].' = '.$resource[\"title\"].' - '.$types[$resource[\"type\"]][\"name\"].\"\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$file_contents .= '\t*/\n?>';\n\t\t\tif (!count($clean_resources)) {\n\t\t\t\t$file_contents = \"\";\n\t\t\t}\n\n\t\t\tif ($routed == \"on\") {\n\t\t\t\tif (!file_exists(SERVER_ROOT.\"templates/routed/\".$id.\"/default.php\")) {\n\t\t\t\t\tBigTree::putFile(SERVER_ROOT.\"templates/routed/\".$id.\"/default.php\",$file_contents);\n\t\t\t\t}\n\t\t\t} elseif (!file_exists(SERVER_ROOT.\"templates/basic/\".$id.\".php\")) {\n\t\t\t\tBigTree::putFile(SERVER_ROOT.\"templates/basic/\".$id.\".php\",$file_contents);\n\t\t\t}\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(htmlspecialchars($name));\n\t\t\t$module = sqlescape($module);\n\t\t\t$resources = BigTree::json($clean_resources,true);\n\t\t\t$level = sqlescape($level);\n\t\t\t$routed = sqlescape($routed);\n\n\t\t\t// Increase the count of the positions on all templates by 1 so that this new template is for sure in last position.\n\t\t\tsqlquery(\"UPDATE bigtree_templates SET position = position + 1\");\n\t\t\tsqlquery(\"INSERT INTO bigtree_templates (`id`,`name`,`module`,`resources`,`level`,`routed`) VALUES ('$id','$name','$module','$resources','$level','$routed')\");\n\t\t\t$this->track(\"bigtree_templates\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: createUser\n\t\t\t\tCreates a user.\n\t\t\t\tChecks for developer access.\n\n\t\t\tParameters:\n\t\t\t\tdata - An array of user data. (\"email\", \"password\", \"name\", \"company\", \"level\", \"permissions\",\"alerts\")\n\n\t\t\tReturns:\n\t\t\t\tid of the newly created user or false if a user already exists with the provided email.\n\t\t*/\n\n\t\tfunction createUser($data) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$level = intval($data[\"level\"]);\n\t\t\t$email = sqlescape($data[\"email\"]);\n\t\t\t$name = sqlescape(htmlspecialchars($data[\"name\"]));\n\t\t\t$company = sqlescape(htmlspecialchars($data[\"company\"]));\n\t\t\t$daily_digest = $data[\"daily_digest\"] ? \"on\" : \"\";\n\n\t\t\t// See if the user already exists\n\t\t\t$r = sqlrows(sqlquery(\"SELECT * FROM bigtree_users WHERE email = '$email'\"));\n\t\t\tif ($r > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$permissions = $data[\"permissions\"] ? BigTree::json($data[\"permissions\"],true) : \"[]\";\n\t\t\t$alerts = $data[\"alerts\"] ? BigTree::json($data[\"alerts\"],true) : \"[]\";\n\n\t\t\t// Don't allow the level to be set higher than the logged in user's level\n\t\t\tif ($level > $this->Level) {\n\t\t\t\t$level = $this->Level;\n\t\t\t}\n\n\t\t\t// Hash the password.\n\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], TRUE);\n\t\t\t$password = sqlescape($phpass->HashPassword(trim($data[\"password\"])));\n\n\t\t\tsqlquery(\"INSERT INTO bigtree_users (`email`,`password`,`name`,`company`,`level`,`permissions`,`alerts`,`daily_digest`) VALUES ('$email','$password','$name','$company','$level','$permissions','$alerts','$daily_digest')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_users\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: delete404\n\t\t\t\tDeletes a 404 error.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the reported 404.\n\t\t*/\n\n\t\tfunction delete404($id) {\n\t\t\t$this->requireLevel(1);\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_404s WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_404s\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteCallout\n\t\t\t\tDeletes a callout and removes its file.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout.\n\t\t*/\n\n\t\tfunction deleteCallout($id) {\n\t\t\t$id = sqlescape($id);\n\n\t\t\t// Delete the callout and its related file\n\t\t\tsqlquery(\"DELETE FROM bigtree_callouts WHERE id = '$id'\");\n\t\t\tunlink(SERVER_ROOT.\"templates/callouts/$id.php\");\n\n\t\t\t// Remove the callout from any groups it lives in\n\t\t\t$groups = sqlquery(\"SELECT id, callouts FROM bigtree_callout_groups WHERE callouts LIKE '%\\\"$id\\\"%'\");\n\t\t\twhile ($f = sqlfetch($groups)) {\n\t\t\t\t$callouts = array_filter((array)json_decode($f[\"callouts\"],true));\n\t\t\t\t$new = BigTree::json(array_diff($callouts, array($id)), true);\n\t\t\t\tsqlquery(\"UPDATE bigtree_callout_groups SET callouts = '$new' WHERE id = '\".$f[\"id\"].\"'\");\n\t\t\t}\n\n\t\t\t// Track deletion\n\t\t\t$this->track(\"bigtree_callouts\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteCalloutGroup\n\t\t\t\tDeletes a callout group.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout group.\n\t\t*/\n\n\t\tfunction deleteCalloutGroup($id) {\n\t\t\tsqlquery(\"DELETE FROM bigtree_callout_groups WHERE id = '\".sqlescape($id).\"'\");\n\t\t\t$this->track(\"bigtree_callout_groups\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteExtension\n\t\t\t\tUninstalls an extension from BigTree and removes its related components and files.\n\n\t\t\tParameters:\n\t\t\t\tid - The extension ID.\n\t\t*/\n\n\t\tfunction deleteExtension($id) {\n\t\t\t$extension = $this->getExtension($id);\n\n\t\t\tif (!$extension) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$j = json_decode($extension[\"manifest\"],true);\n\t\t\t\n\t\t\t// Don't delete the whole directory if the manifest fails to load\n\t\t\tif ($j[\"id\"]) {\n\t\t\t\t// Delete site files\n\t\t\t\tBigTree::deleteDirectory(SITE_ROOT.\"extensions/\".$j[\"id\"].\"/\");\n\t\t\t\t// Delete extensions directory\n\t\t\t\tBigTree::deleteDirectory(SERVER_ROOT.\"extensions/\".$j[\"id\"].\"/\");\n\t\t\t}\n\t\t\n\t\t\t// Delete components\n\t\t\tforeach ($j[\"components\"] as $type => $list) {\n\t\t\t\tif ($type == \"tables\") {\n\t\t\t\t\t// Turn off foreign key checks since we're going to be dropping tables.\n\t\t\t\t\tsqlquery(\"SET SESSION foreign_key_checks = 0\");\n\t\t\t\t\tforeach ($list as $table => $create_statement) {\n\t\t\t\t\t\tsqlquery(\"DROP TABLE IF EXISTS `$table`\");\n\t\t\t\t\t}\n\t\t\t\t\tsqlquery(\"SET SESSION foreign_key_checks = 1\");\n\t\t\t\t} else {\n\t\t\t\t\tforeach ($list as $item) {\n\t\t\t\t\t\tsqlquery(\"DELETE FROM `bigtree_$type` WHERE id = '\".sqlescape($item[\"id\"]).\"'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Delete extension entry\n\t\t\tsqlquery(\"DELETE FROM bigtree_extensions WHERE id = '\".sqlescape($extension[\"id\"]).\"'\");\n\t\t\t$this->track(\"bigtree_extensions\",$extension[\"id\"],\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteFeed\n\t\t\t\tDeletes a feed.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the feed.\n\t\t*/\n\n\t\tfunction deleteFeed($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_feeds WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_feeds\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteFieldType\n\t\t\t\tDeletes a field type and erases its files.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the field type.\n\t\t*/\n\n\t\tfunction deleteFieldType($id) {\n\t\t\t@unlink(SERVER_ROOT.\"custom/admin/form-field-types/draw/$id.php\");\n\t\t\t@unlink(SERVER_ROOT.\"custom/admin/form-field-types/process/$id.php\");\n\t\t\t@unlink(SERVER_ROOT.\"custom/admin/ajax/developer/field-options/$id.php\");\n\t\t\t@unlink(SERVER_ROOT.\"cache/bigtree-form-field-types.json\");\n\t\t\t\n\t\t\tsqlquery(\"DELETE FROM bigtree_field_types WHERE id = '\".sqlescape($id).\"'\");\n\t\t\t$this->track(\"bigtree_field_types\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModule\n\t\t\t\tDeletes a module.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module.\n\t\t*/\n\n\t\tfunction deleteModule($id) {\n\t\t\t$id = sqlescape($id);\n\n\t\t\t// Get info and delete the class.\n\t\t\t$module = $this->getModule($id);\n\t\t\tunlink(SERVER_ROOT.\"custom/inc/modules/\".$module[\"route\"].\".php\");\n\t\t\tBigTree::deleteDirectory(SERVER_ROOT.\"custom/admin/modules/\".$module[\"route\"].\"/\");\n\n\t\t\t// Delete all the related auto module actions\n\t\t\t$actions = $this->getModuleActions($id);\n\t\t\tforeach ($actions as $action) {\n\t\t\t\tif ($action[\"form\"]) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_forms WHERE id = '\".$action[\"form\"].\"'\");\n\t\t\t\t}\n\t\t\t\tif ($action[\"view\"]) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_views WHERE id = '\".$action[\"view\"].\"'\");\n\t\t\t\t}\n\t\t\t\tif ($action[\"report\"]) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_reports WHERE id = '\".$action[\"report\"].\"'\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Delete actions\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_actions WHERE module = '$id'\");\n\n\t\t\t// Delete embeds\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_embeds WHERE module = '$id'\");\n\n\t\t\t// Delete the module\n\t\t\tsqlquery(\"DELETE FROM bigtree_modules WHERE id = '$id'\");\n\n\t\t\t$this->track(\"bigtree_modules\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleAction\n\t\t\t\tDeletes a module action.\n\t\t\t\tAlso deletes the related form or view if no other action is using it.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the action to delete.\n\t\t*/\n\n\t\tfunction deleteModuleAction($id) {\n\t\t\t$id = sqlescape($id);\n\n\t\t\t$a = $this->getModuleAction($id);\n\t\t\tif ($a[\"form\"]) {\n\t\t\t\t// Only delete the auto-ness if it's the only one using it.\n\t\t\t\tif (sqlrows(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE form = '\".$a[\"form\"].\"'\")) == 1) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_forms WHERE id = '\".$a[\"form\"].\"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($a[\"view\"]) {\n\t\t\t\t// Only delete the auto-ness if it's the only one using it.\n\t\t\t\tif (sqlrows(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE view = '\".$a[\"view\"].\"'\")) == 1) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_views WHERE id = '\".$a[\"view\"].\"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_actions WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_module_actions\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleEmbedForm\n\t\t\t\tDeletes an embeddable module form.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the embeddable form.\n\t\t*/\n\n\t\tfunction deleteModuleEmbedForm($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_embeds WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleForm\n\t\t\t\tDeletes a module form and its related actions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module form.\n\t\t*/\n\n\t\tfunction deleteModuleForm($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_forms WHERE id = '$id'\");\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_actions WHERE form = '$id'\");\n\t\t\t$this->track(\"bigtree_module_forms\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleGroup\n\t\t\t\tDeletes a module group. Sets modules in the group to Misc.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module group.\n\t\t*/\n\n\t\tfunction deleteModuleGroup($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_groups WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_module_groups\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleReport\n\t\t\t\tDeletes a module report and its related actions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module report.\n\t\t*/\n\n\t\tfunction deleteModuleReport($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_reports WHERE id = '$id'\");\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_actions WHERE report = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteModuleView\n\t\t\t\tDeletes a module view and its related actions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module view.\n\t\t*/\n\n\t\tfunction deleteModuleView($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_views WHERE id = '$id'\");\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_actions WHERE view = '$id'\");\n\t\t\t$this->track(\"bigtree_module_views\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePackage\n\t\t\t\tUninstalls a package from BigTree and removes its related components and files.\n\n\t\t\tParameters:\n\t\t\t\tid - The package ID.\n\t\t*/\n\n\t\tfunction deletePackage($id) {\n\t\t\t$package = $this->getPackage($id);\n\t\t\t$j = json_decode($package[\"manifest\"],true);\n\t\t\n\t\t\t// Delete related files\n\t\t\tforeach ($j[\"files\"] as $file) {\n\t\t\t\t@unlink(SERVER_ROOT.$file);\n\t\t\t}\n\t\t\n\t\t\t// Delete components\n\t\t\tforeach ($j[\"components\"] as $type => $list) {\n\t\t\t\tif ($type == \"tables\") {\n\t\t\t\t\t// Turn off foreign key checks since we're going to be dropping tables.\n\t\t\t\t\tsqlquery(\"SET SESSION foreign_key_checks = 0\");\n\t\t\t\t\tforeach ($list as $table) {\n\t\t\t\t\t\tsqlquery(\"DROP TABLE IF EXISTS `$table`\");\n\t\t\t\t\t}\n\t\t\t\t\tsqlquery(\"SET SESSION foreign_key_checks = 1\");\n\t\t\t\t} else {\n\t\t\t\t\tforeach ($list as $item) {\n\t\t\t\t\t\tsqlquery(\"DELETE FROM `bigtree_$type` WHERE id = '\".sqlescape($item[\"id\"]).\"'\");\n\t\t\t\t\t}\n\t\t\t\t\t// Modules might have their own directories\n\t\t\t\t\tif ($type == \"modules\") {\n\t\t\t\t\t\tforeach ($list as $item) {\n\t\t\t\t\t\t\t@rmdir(SERVER_ROOT.\"custom/admin/modules/\".$item[\"route\"].\"/\");\n\t\t\t\t\t\t\t@rmdir(SERVER_ROOT.\"custom/admin/ajax/\".$item[\"route\"].\"/\");\n\t\t\t\t\t\t\t@rmdir(SERVER_ROOT.\"custom/admin/images/\".$item[\"route\"].\"/\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif ($type == \"templates\") {\n\t\t\t\t\t\tforeach ($list as $item) {\n\t\t\t\t\t\t\t@rmdir(SERVER_ROOT.\"templates/routed/\".$item[\"id\"].\"/\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tsqlquery(\"DELETE FROM bigtree_extensions WHERE id = '\".sqlescape($package[\"id\"]).\"'\");\n\t\t\t$this->track(\"bigtree_extensions\",$package[\"id\"],\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePage\n\t\t\t\tDeletes a page or a pending page.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tpage - A page id or a pending page id prefixed with a \"p\"\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful. Stops page execution if permission issues occur.\n\t\t*/\n\n\t\tfunction deletePage($page) {\n\t\t\t$page = sqlescape($page);\n\n\t\t\t$r = $this->getPageAccessLevel($page);\n\t\t\tif ($r == \"p\" && $this->canModifyChildren(BigTreeCMS::getPage($page))) {\n\t\t\t\t// If the page isn't numeric it's most likely prefixed by the \"p\" so it's pending.\n\t\t\t\tif (!is_numeric($page)) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_pending_changes WHERE id = '\".sqlescape(substr($page,1)).\"'\");\n\t\t\t\t\tstatic::growl(\"Pages\",\"Deleted Page\");\n\t\t\t\t\t$this->track(\"bigtree_pages\",\"p$page\",\"deleted-pending\");\n\t\t\t\t} else {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_pages WHERE id = '$page'\");\n\t\t\t\t\t// Delete the children as well.\n\t\t\t\t\t$this->deletePageChildren($page);\n\t\t\t\t\tstatic::growl(\"Pages\",\"Deleted Page\");\n\t\t\t\t\t$this->track(\"bigtree_pages\",$page,\"deleted\");\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t$this->stop(\"You do not have permission to delete this page.\");\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePageChildren\n\t\t\t\tDeletes the children of a page and recurses downward.\n\t\t\t\tDoes not check permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The parent id to delete children for.\n\t\t*/\n\n\t\tfunction deletePageChildren($id) {\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE parent = '$id'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$this->deletePageChildren($f[\"id\"]);\n\t\t\t\t$this->track(\"bigtree_pages\",$f[\"id\"],\"deleted-inherited\");\n\t\t\t}\n\t\t\tsqlquery(\"DELETE FROM bigtree_pages WHERE parent = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePageDraft\n\t\t\t\tDeletes a page draft.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The page id to delete the draft for.\n\t\t*/\n\n\t\tfunction deletePageDraft($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t// Get the version, check if the user has access to the page the version refers to.\n\t\t\t$access = $this->getPageAccessLevel($id);\n\t\t\tif ($access != \"p\") {\n\t\t\t\t$this->stop(\"You must be a publisher to manage revisions.\");\n\t\t\t}\n\n\t\t\t// Get draft copy's ID\n\t\t\t$draft = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND `item_id` = '$id'\"));\n\n\t\t\t// Delete draft copy\n\t\t\tsqlquery(\"DELETE FROM bigtree_pending_changes WHERE id = '\".$draft[\"id\"].\"'\");\n\t\t\t$this->track(\"bigtree_pending_changes\",$draft[\"id\"],\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePageRevision\n\t\t\t\tDeletes a page revision.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The page version id.\n\t\t*/\n\n\t\tfunction deletePageRevision($id) {\n\t\t\t// Get the version, check if the user has access to the page the version refers to.\n\t\t\t$revision = $this->getPageRevision($id);\n\t\t\t$access = $this->getPageAccessLevel($revision[\"page\"]);\n\t\t\tif ($access != \"p\") {\n\t\t\t\t$this->stop(\"You must be a publisher to manage revisions.\");\n\t\t\t}\n\n\t\t\t// Delete the revision\n\t\t\tsqlquery(\"DELETE FROM bigtree_page_revisions WHERE id = '\".$revision[\"id\"].\"'\");\n\t\t\t$this->track(\"bigtree_page_revisions\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deletePendingChange\n\t\t\t\tDeletes a pending change.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the change.\n\t\t*/\n\n\t\tfunction deletePendingChange($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_pending_changes WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_pending_changes\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteResource\n\t\t\t\tDeletes a resource.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the resource.\n\t\t*/\n\n\t\tfunction deleteResource($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$r = $this->getResource($id);\n\t\t\tif ($r) {\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_resources WHERE id = '\".sqlescape($r[\"id\"]).\"'\");\n\n\t\t\t\t// If this file isn't located in any other folders, delete it from the file system\n\t\t\t\tif (!sqlrows(sqlquery(\"SELECT id FROM bigtree_resources WHERE file = '\".sqlescape($r[\"file\"]).\"'\"))) {\n\t\t\t\t\t$storage = new BigTreeStorage;\n\t\t\t\t\t$storage->delete($r[\"file\"]);\n\t\t\t\t\tforeach ($r[\"thumbs\"] as $thumb) {\n\t\t\t\t\t\t$storage->delete($thumb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$this->track(\"bigtree_resources\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteResourceFolder\n\t\t\t\tDeletes a resource folder and all of its sub folders and resources.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the resource folder.\n\t\t*/\n\n\t\tfunction deleteResourceFolder($id) {\n\t\t\t$items = $this->getContentsOfResourceFolder($id);\n\t\t\tforeach ($items[\"folders\"] as $folder) {\n\t\t\t\t$this->deleteResourceFolder($folder[\"id\"]);\n\t\t\t}\n\t\t\tforeach ($items[\"resources\"] as $resource) {\n\t\t\t\t$this->deleteResource($resource[\"id\"]);\n\t\t\t}\n\t\t\tsqlquery(\"DELETE FROM bigtree_resource_folders WHERE id = '\".sqlescape($id).\"'\");\n\t\t\t$this->track(\"bigtree_resource_folders\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteSetting\n\t\t\t\tDeletes a setting.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the setting.\n\t\t*/\n\n\t\tfunction deleteSetting($id) {\n\t\t\t$id = BigTreeCMS::extensionSettingCheck($id);\n\t\t\tsqlquery(\"DELETE FROM bigtree_settings WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_settings\",$id,\"deleted\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteTemplate\n\t\t\t\tDeletes a template and its related files.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the template.\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful.\n\t\t*/\n\n\t\tfunction deleteTemplate($id) {\n\t\t\t$template = BigTreeCMS::getTemplate($id);\n\t\t\tif (!$template) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($template[\"routed\"]) {\n\t\t\t\tBigTree::deleteDirectory(SERVER_ROOT.\"templates/routed/\".$template[\"id\"].\"/\");\n\t\t\t} else {\n\t\t\t\t@unlink(SERVER_ROOT.\"templates/basic/\".$template[\"id\"].\".php\");\n\t\t\t}\n\t\t\tsqlquery(\"DELETE FROM bigtree_templates WHERE id = '\".sqlescape($template[\"id\"]).\"'\");\n\t\t\t$this->track(\"bigtree_templates\",$template[\"id\"],\"deleted\");\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: deleteUser\n\t\t\t\tDeletes a user.\n\t\t\t\tChecks for developer access.\n\n\t\t\tParameters:\n\t\t\t\tid - The user id to delete.\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful. false if the logged in user does not have permission to delete the user.\n\t\t*/\n\n\t\tfunction deleteUser($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t// If this person has higher access levels than the person trying to update them, fail.\n\t\t\t$current = static::getUser($id);\n\n\t\t\tif ($current[\"level\"] > $this->Level || $id == $this->ID) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsqlquery(\"DELETE FROM bigtree_users WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_users\",$id,\"deleted\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: disconnectGoogleAnalytics\n\t\t\t\tTurns of Google Analytics settings in BigTree and deletes cached information.\n\t\t*/\n\n\t\tfunction disconnectGoogleAnalytics() {\n\t\t\tunlink(SERVER_ROOT.\"cache/analytics.json\");\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET ga_page_views = NULL\");\n\t\t\tsqlquery(\"DELETE FROM bigtree_caches WHERE identifier = 'org.bigtreecms.api.analytics.google'\");\n\t\t\tstatic::growl(\"Analytics\",\"Disconnected\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: doesModuleActionExist\n\t\t\t\tChecks to see if an action exists for a given route and module.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module to check.\n\t\t\t\troute - The route of the action to check.\n\n\t\t\tReturns:\n\t\t\t\ttrue if an action exists, otherwise false.\n\t\t*/\n\n\t\tstatic function doesModuleActionExist($module,$route) {\n\t\t\t$module = sqlescape($module);\n\t\t\t$route = sqlescape($route);\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT id FROM bigtree_module_actions WHERE module = '$module' AND route = '$route'\"));\n\t\t\tif ($f) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: doesModuleEditActionExist\n\t\t\t\tDetermines whether there is already an edit action for a module.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module id to check.\n\n\t\t\tReturns:\n\t\t\t\t1 or 0, for true or false.\n\t\t*/\n\n\t\tstatic function doesModuleEditActionExist($module) {\n\t\t\treturn sqlrows(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '\".sqlescape($module).\"' AND route = 'edit'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: doesModuleLandingActionExist\n\t\t\t\tDetermines whether there is already a landing action for a module.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module id to check.\n\n\t\t\tReturns:\n\t\t\t\t1 or 0, for true or false.\n\t\t*/\n\n\t\tstatic function doesModuleLandingActionExist($module) {\n\t\t\treturn sqlrows(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '\".sqlescape($module).\"' AND route = ''\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: drawArrayLevel\n\t\t\t\tAn internal function used for drawing callout and matrix resource data.\n\t\t*/\n\n\t\tstatic function drawArrayLevel($keys,$level,$field = false) {\n\t\t\t// Backwards compatibility in case any external developers used this\n\t\t\tif ($field === false) {\n\t\t\t\tglobal $field;\n\t\t\t}\n\t\t\tforeach ($level as $key => $value) {\n\t\t\t\tif (is_array($value)) {\n\t\t\t\t\tstatic::drawArrayLevel(array_merge($keys,array($key)),$value,$field);\n\t\t\t\t} else {\n?>\n<input type=\"hidden\" name=\"<?=$field[\"key\"]?>[<?=implode(\"][\",$keys)?>][<?=$key?>]\" value=\"<?=BigTree::safeEncode($value)?>\" />\n<?\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: drawField\n\t\t\t\tA helper function that draws a field type.\n\n\t\t\tParameters:\n\t\t\t\tfield - Field array\n\t\t*/\n\n\t\tstatic function drawField($field) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\n\t\t\t// Give the field a unique id\n\t\t\t$bigtree[\"field_counter\"]++;\n\t\t\t$field[\"id\"] = $bigtree[\"field_namespace\"].$bigtree[\"field_counter\"];\n\n\t\t\t// Make sure options is an array to prevent warnings\n\t\t\tif (!is_array($field[\"options\"])) {\n\t\t\t\t$field[\"options\"] = array();\n\t\t\t}\n\n\t\t\t$field[\"options\"] = BigTree::untranslateArray($field[\"options\"]);\n\n\t\t\t// Setup Validation Classes\n\t\t\t$label_validation_class = \"\";\n\t\t\t$field[\"required\"] = false;\n\t\t\tif (!empty($field[\"options\"][\"validation\"])) {\n\t\t\t\tif (strpos($field[\"options\"][\"validation\"],\"required\") !== false) {\n\t\t\t\t\t$label_validation_class = ' class=\"required\"';\n\t\t\t\t\t$field[\"required\"] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Prevent path abuse\n\t\t\t$field[\"type\"] = BigTree::cleanFile($field[\"type\"]);\n\n\t\t\t// Save current context\n\t\t\t$bigtree[\"saved_extension_context\"] = $bigtree[\"extension_context\"];\n\n\t\t\t// Get path and set context\n\t\t\tif (strpos($field[\"type\"],\"*\") !== false) {\n\t\t\t\tlist($extension,$field_type) = explode(\"*\",$field[\"type\"]);\n\n\t\t\t\t$bigtree[\"extension_context\"] = $extension;\n\t\t\t\t$field_type_path = SERVER_ROOT.\"extensions/$extension/field-types/$field_type/draw.php\";\n\t\t\t} else {\n\t\t\t\t$field_type_path = BigTree::path(\"admin/form-field-types/draw/\".$field[\"type\"].\".php\");\n\t\t\t}\n\n\t\t\tif (file_exists($field_type_path)) {\n\t\t\t\t// Don't draw the fieldset for field types that are declared as self drawing.\n\t\t\t\tif ($bigtree[\"field_types\"][$field[\"type\"]][\"self_draw\"]) {\n\t\t\t\t\tinclude $field_type_path;\n\t\t\t\t} else {\n?>\n<fieldset<? if ($field[\"matrix_title_field\"]) { ?> class=\"matrix_title_field\"<? } ?>>\n\t<? if ($field[\"title\"] && $field[\"type\"] != \"checkbox\") { ?>\n\t<label<?=$label_validation_class?>><?=$field[\"title\"]?><? if ($field[\"subtitle\"]) { ?> <small><?=$field[\"subtitle\"]?></small><? } ?></label>\n\t<? } ?>\n\t<? include $field_type_path ?>\n</fieldset>\n<?\n\t\t\t\t\t$bigtree[\"tabindex\"]++;\n\t\t\t\t}\n\n\t\t\t\t$bigtree[\"last_resource_type\"] = $field[\"type\"];\n\t\t\t}\n\n\t\t\t// Restore context\n\t\t\t$bigtree[\"extension_context\"] = $bigtree[\"saved_extension_context\"];\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: drawCSRFToken\n\t\t\t\tDraws an input field for the CSRF token.\n\t\t*/\n\t\t\n\t\tfunction drawCSRFToken() {\n\t\t\techo '<input type=\"hidden\" value=\"'.htmlspecialchars($this->CSRFToken).'\" name=\"'.$this->CSRFTokenField.'\" />';\n\t\t}\n\n\t\t/*\n\t\t\tFunction: drawCSRFTokenGET\n\t\t\t\tDraws a GET variable in a URL for the CSRF token.\n\t\t*/\n\t\t\n\t\tfunction drawCSRFTokenGET() {\n\t\t\techo '&'.$this->CSRFTokenField.'='.urlencode($this->CSRFToken);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: drawPOSTErrorMessage\n\t\t\t\tIf a POST error occurred, draws a message for the form.\n\n\t\t\tReturns:\n\t\t\t\ttrue if a message was displayed\n\t\t*/\n\n\t\tstatic function drawPOSTErrorMessage($dont_unset = false) {\n\t\t\tif (!empty($_SESSION[\"bigtree_admin\"][\"post_error\"])) {\n\t\t\t\t$error_code = $_SESSION[\"bigtree_admin\"][\"post_error\"];\n\n\t\t\t\tif ($dont_unset == false) {\n\t\t\t\t\tunset($_SESSION[\"bigtree_admin\"][\"post_error\"]);\n\t\t\t\t}\n\n\t\t\t\tif ($error_code == \"max_input_vars\") {\n\t\t\t\t\t$message = \"The maximum number of input variables was exceeded and the submission failed.<br>Please ask your system administrator to increase the max_input_vars limit in php.ini\";\n\t\t\t\t} elseif ($error_code == \"post_max_size\") {\n\t\t\t\t\t$message = \"The submission exceeded the web server's maximum submission size.<br>If you uploaded multiple files, try uploading one at a time or ask your system administrator to increase the post_max_size and upload_max_filesize settings in php.ini\";\n\t\t\t\t}\n\n\t\t\t\tif (!$message) {\n\t\t\t\t\t$message = \"An unknown error occurred.\";\n\t\t\t\t}\n\n\t\t\t\techo '<p class=\"warning_message\">'.$message.'</p>';\n\t\t\t\techo '<hr>';\n\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: emailDailyDigest\n\t\t\t\tSends out a daily digest email to all who have subscribed.\n\t\t*/\n\n\t\tfunction emailDailyDigest() {\n\t\t\tglobal $bigtree;\n\n\t\t\t$home_page = sqlfetch(sqlquery(\"SELECT `nav_title` FROM `bigtree_pages` WHERE id = 0\"));\n\t\t\t$site_title = $home_page[\"nav_title\"];\n\t\t\t$image_root = $bigtree[\"config\"][\"admin_root\"].\"images/email/\";\n\n\t\t\t$qusers = sqlquery(\"SELECT * FROM bigtree_users where daily_digest = 'on'\");\n\t\t\twhile ($user = sqlfetch($qusers)) {\n\t\t\t\t$changes = $this->getPublishableChanges($user[\"id\"]);\n\t\t\t\t$alerts = $this->getContentAlerts($user[\"id\"]);\n\t\t\t\t$messages = $this->getMessages($user[\"id\"]);\n\t\t\t\t$unread = $messages[\"unread\"];\n\n\t\t\t\t// Start building the email\n\t\t\t\t$body_alerts = $body_changes = $body_messages = \"\";\n\n\t\t\t\t// Alerts\n\t\t\t\tif (is_array($alerts) && count($alerts)) {\n\t\t\t\t\tforeach ($alerts as $alert) {\n\t\t\t\t\t\t$body_alerts .= '<tr>';\n\t\t\t\t\t\t$body_alerts .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.$alert[\"nav_title\"].'</td>';\n\t\t\t\t\t\t$body_alerts .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 20px 10px 15px; text-align: right;\">'.$alert[\"current_age\"].' Days</td>';\n\n\t\t\t\t\t\t$body_alerts .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0; text-align: center;\"><a href=\"'.$bigtree[\"config\"][\"www_root\"].$alert[\"path\"].'/\"><img src=\"'.$image_root.'launch.gif\" alt=\"Launch\" /></a></td>';\n\n\t\t\t\t\t\t$body_alerts .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0; text-align: center;\"><a href=\"'.$bigtree[\"config\"][\"admin_root\"].\"pages/edit/\".$alert[\"id\"].'/\"><img src=\"'.$image_root.'edit.gif\" alt=\"Edit\" /></a></td>';\n\t\t\t\t\t\t$body_alerts .= '</tr>';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$body_alerts = '<tr><td colspan=\"4\" style=\"border-bottom: 1px solid #eee; color: #999; padding: 10px 0 10px 15px;\"><p>No Content Age Alerts</p></td></tr>';\n\t\t\t\t}\n\n\t\t\t\t// Changes\n\t\t\t\tif (count($changes)) {\n\t\t\t\t\tforeach ($changes as $change) {\n\t\t\t\t\t\t$body_changes .= '<tr>';\n\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.$change[\"user\"][\"name\"].'</td>';\n\t\t\t\t\t\tif ($change[\"title\"]) {\n\t\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">Pages</td>';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.$change[\"mod\"][\"name\"].'</td>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_null($change[\"item_id\"])) {\n\t\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">Addition</td>';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">Edit</td>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$body_changes .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0; text-align: center;\"><a href=\"'.static::getChangeEditLink($change).'\"><img src=\"'.$image_root.'launch.gif\" alt=\"Launch\" /></a></td>' . \"\\r\\n\";\n\t\t\t\t\t\t$body_changes .= '</tr>';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$body_changes = '<tr><td colspan=\"4\" style=\"border-bottom: 1px solid #eee; color: #999; padding: 10px 0 10px 15px;\"><p>No Pending Changes</p></td></tr>';\n\t\t\t\t}\n\n\t\t\t\t// Messages\n\t\t\t\tif (count($unread)) {\n\t\t\t\t\tforeach ($unread as $message) {\n\t\t\t\t\t\t$body_messages .= '<tr>';\n\t\t\t\t\t\t$body_messages .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.$message[\"sender_name\"].'</td>';\n\t\t\t\t\t\t$body_messages .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.$message[\"subject\"].'</td>';\n\t\t\t\t\t\t$body_messages .= '<td style=\"border-bottom: 1px solid #eee; padding: 10px 0 10px 15px;\">'.date(\"n/j/y g:ia\",strtotime($message[\"date\"])).'</td>';\n\t\t\t\t\t\t$body_messages .= '</tr>';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$body_messages = '<tr><td colspan=\"3\" style=\"border-bottom: 1px solid #eee; color: #999; padding: 10px 0 10px 15px;\"><p>No Unread Messages</p></td></tr>';\n\t\t\t\t}\n\n\t\t\t\t// Send it\n\t\t\t\t$es = new BigTreeEmailService;\n\t\t\t\tif ((is_array($alerts) && count($alerts)) || count($changes) || count($unread)) {\n\t\t\t\t\t$body = file_get_contents(BigTree::path(\"admin/email/daily-digest.html\"));\n\t\t\t\t\t$body = str_ireplace(\"{www_root}\", $bigtree[\"config\"][\"www_root\"], $body);\n\t\t\t\t\t$body = str_ireplace(\"{admin_root}\", $bigtree[\"config\"][\"admin_root\"], $body);\n\t\t\t\t\t$body = str_ireplace(\"{site_title}\", $site_title, $body);\n\t\t\t\t\t$body = str_ireplace(\"{date}\", date(\"F j, Y\",time()), $body);\n\t\t\t\t\t$body = str_ireplace(\"{content_alerts}\", $body_alerts, $body);\n\t\t\t\t\t$body = str_ireplace(\"{pending_changes}\", $body_changes, $body);\n\t\t\t\t\t$body = str_ireplace(\"{unread_messages}\", $body_messages, $body);\n\n\t\t\t\t\t// If we don't have a from email set, third parties most likely will fail so we're going to use local sending\n\t\t\t\t\tif ($es->Settings[\"bigtree_from\"]) {\n\t\t\t\t\t\t$reply_to = \"no-reply@\".(isset($_SERVER[\"HTTP_HOST\"]) ? str_replace(\"www.\",\"\",$_SERVER[\"HTTP_HOST\"]) : str_replace(array(\"http://www.\",\"https://www.\",\"http://\",\"https://\"),\"\",DOMAIN));\n\t\t\t\t\t\t$es->sendEmail(\"$site_title Daily Digest\",$body,$user[\"email\"],$es->Settings[\"bigtree_from\"],\"BigTree CMS\",$reply_to);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tBigTree::sendEmail($user[\"email\"],\"$site_title Daily Digest\",$body);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: forgotPassword\n\t\t\t\tCreates a new password change hash and sends an email to the user.\n\n\t\t\tParameters:\n\t\t\t\temail - The user's email address\n\n\t\t\tReturns:\n\t\t\t\tRedirects if the email address was found, returns false if the user doesn't exist.\n\n\t\t\tSee Also:\n\t\t\t\t<changePassword>\n\t\t*/\n\n\t\tstatic function forgotPassword($email) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$home_page = sqlfetch(sqlquery(\"SELECT `nav_title` FROM `bigtree_pages` WHERE id = 0\"));\n\t\t\t$site_title = $home_page[\"nav_title\"];\n\n\t\t\t$email = sqlescape($email);\n\t\t\t$user = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE email = '$email'\"));\n\t\t\tif (!$user) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$hash = sqlescape(md5(md5($user[\"password\"]).md5(uniqid(\"bigtree-hash\".microtime(true)))));\n\t\t\tsqlquery(\"UPDATE bigtree_users SET change_password_hash = '$hash' WHERE id = '\".$user[\"id\"].\"'\");\n\n\t\t\t$login_root = ($bigtree[\"config\"][\"force_secure_login\"] ? str_replace(\"http://\",\"https://\",ADMIN_ROOT) : ADMIN_ROOT).\"login/\";\n\n\t\t\t$html = file_get_contents(BigTree::path(\"admin/email/reset-password.html\"));\n\t\t\t$html = str_ireplace(\"{www_root}\",WWW_ROOT,$html);\n\t\t\t$html = str_ireplace(\"{admin_root}\",ADMIN_ROOT,$html);\n\t\t\t$html = str_ireplace(\"{site_title}\",$site_title,$html);\n\t\t\t$html = str_ireplace(\"{reset_link}\",$login_root.\"reset-password/$hash/\",$html);\n\n\t\t\t$es = new BigTreeEmailService;\n\t\t\t\n\t\t\t// Only use a custom email service if a from email has been set\n\t\t\tif ($es->Settings[\"bigtree_from\"]) {\n\t\t\t\t$reply_to = \"no-reply@\".(isset($_SERVER[\"HTTP_HOST\"]) ? str_replace(\"www.\",\"\",$_SERVER[\"HTTP_HOST\"]) : str_replace(array(\"http://www.\",\"https://www.\",\"http://\",\"https://\"),\"\",DOMAIN));\n\t\t\t\t$es->sendEmail(\"Reset Your Password\",$html,$user[\"email\"],$es->Settings[\"bigtree_from\"],\"BigTree CMS\",$reply_to);\n\t\t\t} else {\n\t\t\t\tBigTree::sendEmail($user[\"email\"],\"Reset Your Password\",$html);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: get404Total\n\t\t\t\tGet the total number of 404s of a certain type.\n\n\t\t\tParameters:\n\t\t\t\ttype - The type to retrieve the count for (301, ignored, 404)\n\n\t\t\tReturns:\n\t\t\t\tThe number of 404s in the table of the given type.\n\t\t*/\n\n\t\tstatic function get404Total($type) {\n\t\t\tif ($type == \"404\") {\n\t\t\t\t$total = sqlfetch(sqlquery(\"SELECT COUNT(id) AS `total` FROM bigtree_404s WHERE ignored = '' AND redirect_url = ''\"));\n\t\t\t} elseif ($type == \"301\") {\n\t\t\t\t$total = sqlfetch(sqlquery(\"SELECT COUNT(id) AS `total` FROM bigtree_404s WHERE ignored = '' AND redirect_url != ''\"));\n\t\t\t} elseif ($type == \"ignored\") {\n\t\t\t\t$total = sqlfetch(sqlquery(\"SELECT COUNT(id) AS `total` FROM bigtree_404s WHERE ignored = 'on'\"));\n\t\t\t}\n\n\t\t\tif (!empty($total)) {\n\t\t\t\treturn $total[\"total\"];\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getAccessGroups\n\t\t\t\tReturns a list of all groups the logged in user has access to in a module.\n\n\t\t\tParameters:\n\t\t\t\tmodule - A module id or module entry.\n\n\t\t\tReturns:\n\t\t\t\tAn array of groups if a user has limited access to a module or \"true\" if the user has access to all groups.\n\t\t*/\n\n\t\tfunction getAccessGroups($module) {\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (is_array($module)) {\n\t\t\t\t$module = $module[\"id\"];\n\t\t\t}\n\n\t\t\tif ($this->Permissions[\"module\"][$module] && $this->Permissions[\"module\"][$module] != \"n\") {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t$groups = array();\n\t\t\tif (is_array($this->Permissions[\"module_gbp\"][$module])) {\n\t\t\t\tforeach ($this->Permissions[\"module_gbp\"][$module] as $group => $permission) {\n\t\t\t\t\tif ($permission && $permission != \"n\") {\n\t\t\t\t\t\t$groups[] = $group;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $groups;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getAccessLevel\n\t\t\t\tReturns the permission level for a given module and item.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module id or entry to check access for.\n\t\t\t\titem - (optional) The item of the module to check access for.\n\t\t\t\ttable - (optional) The group based table.\n\t\t\t\tuser - (optional) User array if checking for a user other than the logged in user.\n\n\t\t\tReturns:\n\t\t\t\tThe permission level for the given item or module (if item was not passed).\n\n\t\t\tSee Also:\n\t\t\t\t<getCachedAccessLevel>\n\t\t*/\n\n\t\tfunction getAccessLevel($module,$item = array(),$table = \"\",$user = false) {\n\t\t\tif (!$user) {\n\t\t\t\t$level = $this->Level;\n\t\t\t\t$permissions = $this->Permissions;\n\t\t\t} else {\n\t\t\t\t$level = $user[\"level\"];\n\t\t\t\t$permissions = $user[\"permissions\"];\n\t\t\t}\n\n\t\t\tif ($level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\n\t\t\t$id = is_array($module) ? $module[\"id\"] : $module;\n\n\t\t\t$perm = $permissions[\"module\"][$id];\n\n\t\t\t// If group based permissions aren't on or we're a publisher of this module it's an easy solution\u2026 or if we're not even using the table.\n\t\t\tif (!$item || !$module[\"gbp\"][\"enabled\"] || $perm == \"p\" || $table != $module[\"gbp\"][\"table\"]) {\n\t\t\t\treturn $perm;\n\t\t\t}\n\n\t\t\tif (is_array($permissions[\"module_gbp\"][$id])) {\n\t\t\t\t$gv = $item[$module[\"gbp\"][\"group_field\"]];\n\t\t\t\t$gp = $permissions[\"module_gbp\"][$id][$gv];\n\n\t\t\t\tif ($gp != \"n\") {\n\t\t\t\t\treturn $gp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $perm;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getActionClass\n\t\t\t\tReturns the button class for the given action and item.\n\n\t\t\tParameters:\n\t\t\t\taction - The action for the item (edit, feature, approve, etc)\n\t\t\t\titem - The entry to check the action for.\n\n\t\t\tReturns:\n\t\t\t\tClass name for the <a> tag.\n\n\t\t\t\tFor example, if the item is already featured, this returns \"icon_featured icon_featured_on\" for the \"feature\" action.\n\t\t\t\tIf the item isn't already featured, it would simply return \"icon_featured\" for the \"feature\" action.\n\t\t*/\n\n\t\tstatic function getActionClass($action,$item) {\n\t\t\t$class = \"\";\n\t\t\tif (isset($item[\"bigtree_pending\"]) && $action != \"edit\" && $action != \"delete\") {\n\t\t\t\treturn \"icon_disabled js-disabled-hook\";\n\t\t\t}\n\t\t\tif ($action == \"feature\") {\n\t\t\t\t$class = \"icon_feature js-feature-hook\";\n\t\t\t\t\n\t\t\t\tif ($item[\"featured\"]) {\n\t\t\t\t\t$class .= \" icon_feature_on\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($action == \"edit\") {\n\t\t\t\t$class = \"icon_edit\";\n\t\t\t}\n\t\t\tif ($action == \"delete\") {\n\t\t\t\t$class = \"icon_delete js-delete-hook\";\n\t\t\t}\n\t\t\tif ($action == \"approve\") {\n\t\t\t\t$class = \"icon_approve js-approve-hook\";\n\t\t\t\tif ($item[\"approved\"]) {\n\t\t\t\t\t$class .= \" icon_approve_on\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($action == \"archive\") {\n\t\t\t\t$class = \"icon_archive js-archive-hook\";\n\t\t\t\tif ($item[\"archived\"]) {\n\t\t\t\t\t$class .= \" icon_archive_on\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($action == \"preview\") {\n\t\t\t\t$class = \"icon_preview\";\n\t\t\t}\n\t\t\treturn $class;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getArchivedNavigationByParent\n\t\t\t\tReturns an alphabetic list of navigation that is archived under the given parent.\n\n\t\t\tParameters:\n\t\t\t\tparent - The ID of the parent page\n\n\t\t\tReturns:\n\t\t\t\tAn array of page entries.\n\t\t*/\n\n\t\tstatic function getArchivedNavigationByParent($parent) {\n\t\t\t$nav = array();\n\t\t\t$q = sqlquery(\"SELECT id,nav_title as title,parent,external,new_window,template,publish_at,expire_at,path,ga_page_views FROM bigtree_pages WHERE parent = '$parent' AND archived = 'on' ORDER BY nav_title asc\");\n\t\t\twhile ($nav_item = sqlfetch($q)) {\n\t\t\t\t$nav_item[\"external\"] = BigTreeCMS::replaceRelativeRoots($nav_item[\"external\"]);\n\t\t\t\t$nav[] = $nav_item;\n\t\t\t}\n\t\t\treturn $nav;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getAutoModuleActions\n\t\t\t\tReturn a list of module forms and views.\n\t\t\t\tUsed by the API for reconstructing forms and views.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module id to pull forms/views for.\n\n\t\t\tReturns:\n\t\t\t\tAn array of module actions with \"form\" and \"view\" columns replaced with form and view data.\n\n\t\t\tSee Also:\n\t\t\t\t<BigTreeAutoModule.getForm>\n\t\t\t\t<BigTreeAutoModule.getView>\n\t\t*/\n\n\t\tstatic function getAutoModuleActions($module) {\n\t\t\t$items = array();\n\t\t\t$id = sqlescape($module);\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '$id' AND (form != 0 OR view != 0) AND in_nav = 'on' ORDER BY position DESC, id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($f[\"form\"]) {\n\t\t\t\t\t$f[\"form\"] = BigTreeAutoModule::getForm($f[\"form\"]);\n\t\t\t\t\t$f[\"type\"] = \"form\";\n\t\t\t\t} elseif ($f[\"view\"]) {\n\t\t\t\t\t$f[\"view\"] = BigTreeAutoModule::getView($f[\"view\"]);\n\t\t\t\t\t$f[\"type\"] = \"view\";\n\t\t\t\t}\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getBasicTemplates\n\t\t\t\tReturns a list of non-routed templates ordered by position.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tsort - Sort order, defaults to positioned\n\n\t\t\tReturns:\n\t\t\t\tAn array of template entries.\n\t\t*/\n\n\t\tfunction getBasicTemplates($sort = \"position DESC, id ASC\") {\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_templates WHERE level <= '\".$this->Level.\"' ORDER BY $sort\");\n\t\t\t$items = array();\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif (!$f[\"routed\"]) {\n\t\t\t\t\t$items[] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCachedAccessLevel\n\t\t\t\tReturns the permission level for a given module and cached view entry.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module id or entry to check access for.\n\t\t\t\titem - (optional) The item of the module to check access for.\n\t\t\t\ttable - (optional) The group based table.\n\n\t\t\tReturns:\n\t\t\t\tThe permission level for the given item or module (if item was not passed).\n\n\t\t\tSee Also:\n\t\t\t\t<getAccessLevel>\n\t\t*/\n\n\t\t// Since cached items don't use their normal columns...\n\t\tfunction getCachedAccessLevel($module,$item = array(),$table = \"\") {\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\n\t\t\t$id = is_array($module) ? $module[\"id\"] : $module;\n\n\t\t\t$perm = $this->Permissions[\"module\"][$id];\n\n\t\t\t// If group based permissions aren't on or we're a publisher of this module it's an easy solution\u2026 or if we're not even using the table.\n\t\t\tif (!$item || !$module[\"gbp\"][\"enabled\"] || $perm == \"p\" || $table != $module[\"gbp\"][\"table\"]) {\n\t\t\t\treturn $perm;\n\t\t\t}\n\n\t\t\tif (is_array($this->Permissions[\"module_gbp\"][$id])) {\n\t\t\t\t$current_gbp_value = $item[\"gbp_field\"];\n\t\t\t\t$original_gbp_value = $item[\"published_gbp_field\"];\n\n\t\t\t\t$access_level = $this->Permissions[\"module_gbp\"][$id][$current_gbp_value];\n\t\t\t\tif ($access_level != \"n\") {\n\t\t\t\t\t$original_access_level = $this->Permissions[\"module_gbp\"][$id][$original_gbp_value];\n\t\t\t\t\tif ($original_access_level != \"p\") {\n\t\t\t\t\t\t$access_level = $original_access_level;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($access_level != \"n\") {\n\t\t\t\t\treturn $access_level;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $perm;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCachedFieldTypes\n\t\t\t\tCaches available field types and returns them.\n\n\t\t\tParameters:\n\t\t\t\tsplit - Whether to split the field types into separate default / custom arrays (defaults to false)\n\n\t\t\tReturns:\n\t\t\t\tArray of three arrays of field types (template, module, and callout).\n\t\t*/\n\n\t\tstatic function getCachedFieldTypes($split = false) {\n\t\t\t// Used cached values if available, otherwise query the DB\n\t\t\tif (file_exists(SERVER_ROOT.\"cache/bigtree-form-field-types.json\")) {\n\t\t\t\t$types = json_decode(file_get_contents(SERVER_ROOT.\"cache/bigtree-form-field-types.json\"),true);\n\t\t\t} else {\n\t\t\t\t$types[\"modules\"] = $types[\"templates\"] = $types[\"callouts\"] = $types[\"settings\"] = array(\n\t\t\t\t\t\"default\" => array(\n\t\t\t\t\t\t\"text\" => array(\"name\" => \"Text\", \"self_draw\" => false),\n\t\t\t\t\t\t\"textarea\" => array(\"name\" => \"Text Area\", \"self_draw\" => false),\n\t\t\t\t\t\t\"html\" => array(\"name\" => \"HTML Area\", \"self_draw\" => false),\n\t\t\t\t\t\t\"upload\" => array(\"name\" => \"Upload\", \"self_draw\" => false),\n\t\t\t\t\t\t\"list\" => array(\"name\" => \"List\", \"self_draw\" => false),\n\t\t\t\t\t\t\"checkbox\" => array(\"name\" => \"Checkbox\", \"self_draw\" => false),\n\t\t\t\t\t\t\"date\" => array(\"name\" => \"Date Picker\", \"self_draw\" => false),\n\t\t\t\t\t\t\"time\" => array(\"name\" => \"Time Picker\", \"self_draw\" => false),\n\t\t\t\t\t\t\"datetime\" => array(\"name\" => \"Date &amp; Time Picker\", \"self_draw\" => false),\n\t\t\t\t\t\t\"photo-gallery\" => array(\"name\" => \"Photo Gallery\", \"self_draw\" => false),\n\t\t\t\t\t\t\"callouts\" => array(\"name\" => \"Callouts\", \"self_draw\" => true),\n\t\t\t\t\t\t\"matrix\" => array(\"name\" => \"Matrix\", \"self_draw\" => true),\n\t\t\t\t\t\t\"one-to-many\" => array(\"name\" => \"One to Many\", \"self_draw\" => false)\n\t\t\t\t\t),\n\t\t\t\t\t\"custom\" => array()\n\t\t\t\t);\n\n\t\t\t\t$types[\"modules\"][\"default\"][\"route\"] = array(\"name\" => \"Generated Route\",\"self_draw\" => true);\n\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_field_types ORDER BY name\");\n\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t$use_cases = json_decode($f[\"use_cases\"],true);\n\t\t\t\t\tforeach ((array)$use_cases as $case => $val) {\n\t\t\t\t\t\tif ($val) {\n\t\t\t\t\t\t\t$types[$case][\"custom\"][$f[\"id\"]] = array(\"name\" => $f[\"name\"],\"self_draw\" => $f[\"self_draw\"]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tBigTree::putFile(SERVER_ROOT.\"cache/bigtree-form-field-types.json\",BigTree::json($types));\n\t\t\t}\n\n\t\t\t// Re-merge if we don't want them split\n\t\t\tif (!$split) {\n\t\t\t\tforeach ($types as $use_case => $list) {\n\t\t\t\t\t$types[$use_case] = array_merge($list[\"default\"],$list[\"custom\"]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $types;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCallout\n\t\t\t\tReturns a callout entry.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout.\n\n\t\t\tReturns:\n\t\t\t\tA callout entry from bigtree_callouts with resources decoded.\n\t\t*/\n\n\t\tstatic function getCallout($id) {\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_callouts WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\tif (!$item) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$item[\"resources\"] = json_decode($item[\"resources\"],true);\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCalloutGroup\n\t\t\t\tReturns a callout group entry from the bigtree_callout_groups table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout group.\n\n\t\t\tReturns:\n\t\t\t\tA callout group entry.\n\t\t*/\n\n\t\tstatic function getCalloutGroup($id) {\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_callout_groups WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\tif (!$f) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$f[\"callouts\"] = array_filter((array)json_decode($f[\"callouts\"],true));\n\t\t\treturn $f;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCalloutGroups\n\t\t\t\tReturns a list of callout groups sorted by name.\n\n\t\t\tReturns:\n\t\t\t\tAn array of callout group entries from bigtree_callout_groups.\n\t\t*/\n\n\t\tstatic function getCalloutGroups() {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_callout_groups ORDER BY name ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"callouts\"] = json_decode($f[\"callouts\"]);\n\t\t\t\t$items[$f[\"id\"]] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCallouts\n\t\t\t\tReturns a list of callouts.\n\n\t\t\tParameters:\n\t\t\t\tsort - The order to return the callouts. Defaults to positioned.\n\n\t\t\tReturns:\n\t\t\t\tAn array of callout entries from bigtree_callouts.\n\t\t*/\n\n\t\tstatic function getCallouts($sort = \"position DESC, id ASC\") {\n\t\t\t$callouts = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_callouts ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$callouts[] = $f;\n\t\t\t}\n\t\t\treturn $callouts;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCalloutsAllowed\n\t\t\t\tReturns a list of callouts the logged-in user is allowed access to.\n\n\t\t\tParameters:\n\t\t\t\tsort - The order to return the callouts. Defaults to positioned.\n\n\t\t\tReturns:\n\t\t\t\tAn array of callout entries from bigtree_callouts.\n\t\t*/\n\n\t\tfunction getCalloutsAllowed($sort = \"position DESC, id ASC\") {\n\t\t\t$callouts = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_callouts WHERE level <= '\".$this->Level.\"' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$callouts[] = $f;\n\t\t\t}\n\t\t\treturn $callouts;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getCalloutsInGroups\n\t\t\t\tReturns a list of callouts in a given set of groups.\n\n\t\t\tParameters:\n\t\t\t\tgroups - An array of group IDs to retrieve callouts for.\n\t\t\t\tauth - If set to true, only returns callouts the logged in user has access to. Defaults to true.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from the bigtree_callouts table.\n\t\t*/\n\n\t\tfunction getCalloutsInGroups($groups,$auth = true) {\n\t\t\t$ids = array();\n\t\t\t$items = array();\n\t\t\t$names = array();\n\n\t\t\tforeach ($groups as $group_id) {\n\t\t\t\t$group = $this->getCalloutGroup($group_id);\n\t\t\t\tif (!$group) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tforeach ($group[\"callouts\"] as $callout_id) {\n\t\t\t\t\tif (!in_array($callout_id,$ids)) {\n\t\t\t\t\t\t$callout = $this->getCallout($callout_id);\n\t\t\t\t\t\tif (!$auth || $this->Level >= $callout[\"level\"]) {\n\t\t\t\t\t\t\t$items[] = $callout;\n\t\t\t\t\t\t\t$ids[] = $callout_id;\n\t\t\t\t\t\t\t$names[] = $callout[\"name\"];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tarray_multisort($names,$items);\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getChange\n\t\t\t\tGet a pending change.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the pending change.\n\n\t\t\tReturns:\n\t\t\t\tA pending change entry from the bigtree_pending_changes table.\n\t\t*/\n\n\t\tstatic function getChange($id) {\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE id = '$id'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getChangeEditLink\n\t\t\t\tReturns a link to where the item involved in the pending change can be edited.\n\n\t\t\tParameters:\n\t\t\t\tchange - The ID of the change or the change array from the database.\n\n\t\t\tReturns:\n\t\t\t\tA string containing a link to the admin.\n\t\t*/\n\n\t\tstatic function getChangeEditLink($change) {\n\t\t\tglobal $bigtree;\n\n\t\t\tif (!is_array($change)) {\n\t\t\t\t$change = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE id = '$change'\"));\n\t\t\t}\n\n\t\t\tif ($change[\"table\"] == \"bigtree_pages\" && $change[\"item_id\"]) {\n\t\t\t\treturn $bigtree[\"config\"][\"admin_root\"].\"pages/edit/\".$change[\"item_id\"].\"/\";\n\t\t\t}\n\n\t\t\tif ($change[\"table\"] == \"bigtree_pages\") {\n\t\t\t\treturn $bigtree[\"config\"][\"admin_root\"].\"pages/edit/p\".$change[\"id\"].\"/\";\n\t\t\t}\n\n\t\t\t$modid = $change[\"module\"];\n\t\t\t$module = sqlfetch(sqlquery(\"SELECT * FROM bigtree_modules WHERE id = '$modid'\"));\n\t\t\t$form = sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_forms WHERE `table` = '\".$change[\"table\"].\"'\"));\n\t\t\t$action = sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE `form` = '\".$form[\"id\"].\"' AND in_nav = ''\"));\n\n\t\t\tif (!$change[\"item_id\"]) {\n\t\t\t\t$change[\"item_id\"] = \"p\".$change[\"id\"];\n\t\t\t}\n\n\t\t\tif ($action) {\n\t\t\t\treturn $bigtree[\"config\"][\"admin_root\"].$module[\"route\"].\"/\".$action[\"route\"].\"/\".$change[\"item_id\"].\"/\";\n\t\t\t} else {\n\t\t\t\treturn $bigtree[\"config\"][\"admin_root\"].$module[\"route\"].\"/edit/\".$change[\"item_id\"].\"/\";\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getContentAlerts\n\t\t\t\tGets a list of pages with content older than their Max Content Age that a user follows.\n\n\t\t\tParameters:\n\t\t\t\tuser - The user id to pull alerts for or a user entry (defaults to the logged in user)\n\n\t\t\tReturns:\n\t\t\t\tAn array of arrays containing a page title, path, and id.\n\t\t*/\n\n\t\tfunction getContentAlerts($user = false) {\n\t\t\tif (is_array($user)) {\n\t\t\t\t$user = static::getUser($user[\"id\"]);\n\t\t\t} elseif ($user) {\n\t\t\t\t$user = static::getUser($user);\n\t\t\t} else {\n\t\t\t\t$user = static::getUser($this->ID);\n\t\t\t}\n\n\t\t\tif (!is_array($user[\"alerts\"])) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$alerts = array();\n\t\t\t// We're going to generate a list of pages the user cares about first to get their paths.\n\t\t\t$where = array();\n\t\t\tforeach ($user[\"alerts\"] as $alert => $status) {\n\t\t\t\t$where[] = \"id = '\".sqlescape($alert).\"'\";\n\t\t\t}\n\t\t\tif (!count($where)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If we care about the whole tree, skip the madness.\n\t\t\tif ($user[\"alerts\"][0] == \"on\") {\n\t\t\t\t$q = sqlquery(\"SELECT nav_title,id,path,updated_at,DATEDIFF('\".date(\"Y-m-d\").\"',updated_at) AS current_age FROM bigtree_pages WHERE max_age > 0 AND DATEDIFF('\".date(\"Y-m-d\").\"',updated_at) > max_age ORDER BY current_age DESC\");\n\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t$alerts[] = $f;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$paths = array();\n\t\t\t\t$q = sqlquery(\"SELECT path FROM bigtree_pages WHERE \".implode(\" OR \",$where));\n\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t$paths[] = \"path = '\".sqlescape($f[\"path\"]).\"' OR path LIKE '\".sqlescape($f[\"path\"]).\"/%'\";\n\t\t\t\t}\n\t\t\t\tif (count($paths)) {\n\t\t\t\t\t// Find all the pages that are old that contain our paths\n\t\t\t\t\t$q = sqlquery(\"SELECT nav_title,id,path,updated_at,DATEDIFF('\".date(\"Y-m-d\").\"',updated_at) AS current_age FROM bigtree_pages WHERE max_age > 0 AND (\".implode(\" OR \",$paths).\") AND DATEDIFF('\".date(\"Y-m-d\").\"',updated_at) > max_age ORDER BY current_age DESC\");\n\t\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t\t$alerts[] = $f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $alerts;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getExtension\n\t\t\t\tReturns information about a package or extension.\n\n\t\t\tParameters:\n\t\t\t\tid - The package/extension ID.\n\n\t\t\tReturns:\n\t\t\t\tA package/extension.\n\t\t*/\n\t\t\n\t\tstatic function getExtension($id) {\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_extensions WHERE id = '\".sqlescape($id).\"'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getExtensions\n\t\t\t\tReturns a list of installed/created extensions.\n\n\t\t\tParameters:\n\t\t\t\tsort - Column/direction to sort (defaults to last_updated DESC)\n\n\t\t\tReturns:\n\t\t\t\tAn array of extensions.\n\t\t*/\n\t\t\n\t\tstatic function getExtensions($sort = \"last_updated DESC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_extensions WHERE type = 'extension' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getFeeds\n\t\t\t\tReturns a list of feeds.\n\n\t\t\tParameters:\n\t\t\t\tsort - The sort direction, defaults to name.\n\n\t\t\tReturns:\n\t\t\t\tAn array of feed elements from bigtree_feeds sorted by name.\n\t\t*/\n\n\t\tstatic function getFeeds($sort = \"name ASC\") {\n\t\t\t$feeds = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_feeds ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$feeds[] = $f;\n\t\t\t}\n\t\t\treturn $feeds;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getFieldType\n\t\t\t\tReturns a field type.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the file type.\n\n\t\t\tReturns:\n\t\t\t\tA field type entry with the \"files\" column decoded.\n\t\t*/\n\n\t\tstatic function getFieldType($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_field_types WHERE id = '$id'\"));\n\t\t\tif (!$item) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$item[\"use_cases\"] = json_decode($item[\"use_cases\"],true);\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getFieldTypes\n\t\t\t\tReturns a list of field types.\n\n\t\t\tParameters:\n\t\t\t\tsort - The sort directon, defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_field_types.\n\t\t*/\n\n\t\tstatic function getFieldTypes($sort = \"name ASC\") {\n\t\t\t$types = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_field_types ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$types[] = $f;\n\t\t\t}\n\t\t\treturn $types;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getFullNavigationPath\n\t\t\t\tCalculates the full navigation path for a given page ID.\n\n\t\t\tParameters:\n\t\t\t\tid - The page ID to calculate the navigation path for.\n\n\t\t\tReturns:\n\t\t\t\tThe navigation path (normally found in the \"path\" column in bigtree_pages).\n\t\t*/\n\n\t\tstatic function getFullNavigationPath($id, $path = array()) {\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT route,id,parent FROM bigtree_pages WHERE id = '$id'\"));\n\t\t\t$path[] = BigTreeCMS::urlify($f[\"route\"]);\n\t\t\tif ($f[\"parent\"] != 0) {\n\t\t\t\treturn static::getFullNavigationPath($f[\"parent\"],$path);\n\t\t\t}\n\t\t\t$path = implode(\"/\",array_reverse($path));\n\t\t\treturn $path;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getHiddenNavigationByParent\n\t\t\t\tReturns an alphabetic list of navigation that is hidden under the given parent.\n\n\t\t\tParameters:\n\t\t\t\tparent - The ID of the parent page\n\n\t\t\tReturns:\n\t\t\t\tAn array of page entries.\n\t\t*/\n\n\t\tstatic function getHiddenNavigationByParent($parent) {\n\t\t\t$nav = array();\n\t\t\t$q = sqlquery(\"SELECT id,nav_title as title,parent,external,new_window,template,publish_at,expire_at,path,ga_page_views FROM bigtree_pages WHERE parent = '$parent' AND in_nav = '' AND archived != 'on' ORDER BY nav_title asc\");\n\t\t\twhile ($nav_item = sqlfetch($q)) {\n\t\t\t\t$nav_item[\"external\"] = BigTreeCMS::replaceRelativeRoots($nav_item[\"external\"]);\n\t\t\t\t$nav[] = $nav_item;\n\t\t\t}\n\t\t\treturn $nav;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getMessage\n\t\t\t\tReturns a message from message center.\n\t\t\t\tVerifies that the user calling this method is either the sender or a recipient.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the message.\n\n\t\t\tReturns:\n\t\t\t\tAn entry from bigtree_messages.\n\t\t*/\n\n\t\tfunction getMessage($id) {\n\t\t\t$message = sqlfetch(sqlquery(\"SELECT * FROM bigtree_messages WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\tif (!$message) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($message[\"sender\"] != $this->ID && strpos($message[\"recipients\"],\"|\".$this->ID.\"|\") === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn $message;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getMessageChain\n\t\t\t\tGets a full chain of messages based on one ID in the chain\n\n\t\t\tParameters:\n\t\t\t\tid - The ID of one message in the chain.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_messages with the message entry that was requested having the \"selected\" column set.\n\t\t*/\n\n\t\tfunction getMessageChain($id) {\n\t\t\t$message = $m = $this->getMessage($id);\n\t\t\t$message[\"selected\"] = true;\n\t\t\tif (!$message) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$chain = array($message);\n\n\t\t\t// Find parents\n\t\t\twhile ($m[\"response_to\"]) {\n\t\t\t\t$m = $this->getMessage($m[\"response_to\"]);\n\t\t\t\t// Prepend this message to the chain\n\t\t\t\t$chain = array_merge(array($m),$chain);\n\t\t\t}\n\n\t\t\t// Find children\n\t\t\t$m = $message;\n\t\t\twhile ($f = sqlfetch(sqlquery(\"SELECT id FROM bigtree_messages WHERE response_to = '\".$m[\"id\"].\"'\"))) {\n\t\t\t\t$m = $this->getMessage($f[\"id\"]);\n\t\t\t\t$chain[] = $m;\n\t\t\t}\n\n\t\t\treturn $chain;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getMessages\n\t\t\t\tReturns all a user's messages.\n\n\t\t\tParameters:\n\t\t\t\tuser - Optional user ID (defaults to logged in user)\n\n\t\t\tReturns:\n\t\t\t\tAn array containing \"sent\", \"read\", and \"unread\" keys that contain an array of messages each.\n\t\t*/\n\n\t\tfunction getMessages($user = false) {\n\t\t\tif ($user) {\n\t\t\t\t$user = sqlescape($user);\n\t\t\t} else {\n\t\t\t\t$user = $this->ID;\n\t\t\t}\n\t\t\t$sent = array();\n\t\t\t$read = array();\n\t\t\t$unread = array();\n\t\t\t$q = sqlquery(\"SELECT bigtree_messages.*, bigtree_users.name AS sender_name, bigtree_users.email AS sender_email FROM bigtree_messages JOIN bigtree_users ON bigtree_messages.sender = bigtree_users.id WHERE sender = '$user' OR recipients LIKE '%|$user|%' ORDER BY date DESC\");\n\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t// If we're the sender put it in the sent array.\n\t\t\t\tif ($f[\"sender\"] == $user) {\n\t\t\t\t\t$sent[] = $f;\n\t\t\t\t} else {\n\t\t\t\t\t// If we've been marked read, put it in the read array.\n\t\t\t\t\tif ($f[\"read_by\"] && strpos($f[\"read_by\"],\"|\".$user.\"|\") !== false) {\n\t\t\t\t\t\t$read[] = $f;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$unread[] = $f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array(\"sent\" => $sent, \"read\" => $read, \"unread\" => $unread);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModule\n\t\t\t\tReturns an entry from the bigtree_modules table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module.\n\n\t\t\tReturns:\n\t\t\t\tA module entry with the \"gbp\" column decoded.\n\t\t*/\n\n\t\tstatic function getModule($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$module = sqlfetch(sqlquery(\"SELECT * FROM bigtree_modules WHERE id = '$id'\"));\n\t\t\tif (!$module) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$module[\"gbp\"] = json_decode($module[\"gbp\"],true);\n\t\t\treturn $module;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleAction\n\t\t\t\tReturns an entry from the bigtree_module_actions table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the action.\n\n\t\t\tReturns:\n\t\t\t\tA module action entry.\n\t\t*/\n\n\t\tstatic function getModuleAction($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE id = '$id'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleActionByRoute\n\t\t\t\tReturns an entry from the bigtree_module_actions table for the given module and route.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module to lookup an action for.\n\t\t\t\troute - The route of the action.\n\n\t\t\tReturns:\n\t\t\t\tA module action entry.\n\t\t*/\n\n\t\tstatic function getModuleActionByRoute($module,$route) {\n\t\t\t// For landing routes.\n\t\t\tif (!count($route)) {\n\t\t\t\t$route = array(\"\");\n\t\t\t}\n\t\t\t$module = sqlescape($module);\n\t\t\t$commands = array();\n\t\t\t$action = false;\n\t\t\twhile (count($route) && !$action) {\n\t\t\t\t$route_string = sqlescape(implode(\"/\",$route));\n\t\t\t\t$action = sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '$module' AND route = '$route_string'\"));\n\t\t\t\tif ($action) {\n\t\t\t\t\treturn array(\"action\" => $action, \"commands\" => array_reverse($commands));\n\t\t\t\t}\n\t\t\t\t$commands[] = end($route);\n\t\t\t\t$route = array_slice($route,0,-1);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleActionForForm\n\t\t\t\tReturns the related module action for an auto module form. Prioritizes edit action over add.\n\n\t\t\tParameters:\n\t\t\t\tform - The id of a form or a form entry.\n\n\t\t\tReturns:\n\t\t\t\tA module action entry.\n\t\t*/\n\n\t\tstatic function getModuleActionForForm($form) {\n\t\t\tif (is_array($form)) {\n\t\t\t\t$form = sqlescape($form[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$form = sqlescape($form);\n\t\t\t}\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE form = '$form' ORDER BY route DESC\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleActionForReport\n\t\t\t\tReturns the related module action for an auto module report.\n\n\t\t\tParameters:\n\t\t\t\treport - The id of a report or a report entry.\n\n\t\t\tReturns:\n\t\t\t\tA module action entry.\n\t\t*/\n\n\t\tstatic function getModuleActionForReport($report) {\n\t\t\tif (is_array($report)) {\n\t\t\t\t$report = sqlescape($report[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$report = sqlescape($report);\n\t\t\t}\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE report = '$report'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleActionForView\n\t\t\t\tReturns the related module action for an auto module view.\n\n\t\t\tParameters:\n\t\t\t\tview - The id of a view or a view entry.\n\n\t\t\tReturns:\n\t\t\t\tA module action entry.\n\t\t*/\n\n\t\tstatic function getModuleActionForView($view) {\n\t\t\tif (is_array($view)) {\n\t\t\t\t$view = sqlescape($view[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$view = sqlescape($view);\n\t\t\t}\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE view = '$view'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleActions\n\t\t\t\tReturns a list of module actions in positioned order.\n\n\t\t\tParameters:\n\t\t\t\tmodule - A module id or a module entry.\n\n\t\t\tReturns:\n\t\t\t\tAn array of module action entries.\n\t\t*/\n\n\t\tstatic function getModuleActions($module) {\n\t\t\tif (is_array($module)) {\n\t\t\t\t$module = sqlescape($module[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$module = sqlescape($module);\n\t\t\t}\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '$module' ORDER BY position DESC, id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleByClass\n\t\t\t\tReturns a module entry for the given class name.\n\n\t\t\tParameters:\n\t\t\t\tclass - A module class.\n\n\t\t\tReturns:\n\t\t\t\tA module entry with the \"gbp\" column decoded or false if a module was not found.\n\t\t*/\n\n\t\tstatic function getModuleByClass($class) {\n\t\t\t$class = sqlescape($class);\n\t\t\t$module = sqlfetch(sqlquery(\"SELECT * FROM bigtree_modules WHERE class = '$class'\"));\n\t\t\tif (!$module) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$module[\"gbp\"] = json_decode($module[\"gbp\"],true);\n\t\t\treturn $module;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleByRoute\n\t\t\t\tReturns a module entry for the given route.\n\n\t\t\tParameters:\n\t\t\t\troute - A module route.\n\n\t\t\tReturns:\n\t\t\t\tA module entry with the \"gbp\" column decoded or false if a module was not found.\n\t\t*/\n\n\t\tstatic function getModuleByRoute($route) {\n\t\t\t$route = sqlescape($route);\n\t\t\t$module = sqlfetch(sqlquery(\"SELECT * FROM bigtree_modules WHERE route = '$route'\"));\n\t\t\tif (!$module) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$module[\"gbp\"] = json_decode($module[\"gbp\"],true);\n\t\t\treturn $module;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleEmbedForms\n\t\t\t\tGets forms from bigtree_module_embeds with fields decoded.\n\n\t\t\tParameters:\n\t\t\t\tsort - The field to sort by.\n\t\t\t\tmodule - Specific module to pull forms for (defaults to all modules).\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_module_embeds with \"fields\" decoded.\n\t\t*/\n\n\t\tstatic function getModuleEmbedForms($sort = \"title\",$module = false) {\n\t\t\t$items = array();\n\t\t\tif ($module) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_embeds WHERE module = '\".sqlescape($module).\"' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_embeds ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"fields\"] = json_decode($f[\"fields\"],true);\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleForms\n\t\t\t\tGets forms from bigtree_module_forms with fields decoded.\n\n\t\t\tParameters:\n\t\t\t\tsort - The field to sort by.\n\t\t\t\tmodule - Specific module to pull forms for (defaults to all modules).\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_module_forms with \"fields\" decoded.\n\t\t*/\n\n\t\tstatic function getModuleForms($sort = \"title\",$module = false) {\n\t\t\t$items = array();\n\t\t\tif ($module) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_forms WHERE module = '\".sqlescape($module).\"' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_forms ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"fields\"] = json_decode($f[\"fields\"],true);\n\t\t\t\t$f[\"hooks\"] = json_decode($f[\"hooks\"],true);\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleGroup\n\t\t\t\tReturns a module group entry from the bigtree_module_groups table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module group.\n\n\t\t\tReturns:\n\t\t\t\tA module group entry.\n\n\t\t\tSee Also:\n\t\t\t\t<getModuleGroupByName>\n\t\t\t\t<getModuleGroupByRoute>\n\t\t*/\n\n\t\tstatic function getModuleGroup($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_groups WHERE id = '$id'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleGroupByName\n\t\t\t\tReturns a module group entry from the bigtree_module_groups table.\n\n\t\t\tParameters:\n\t\t\t\tname - The name of the module group.\n\n\t\t\tReturns:\n\t\t\t\tA module group entry.\n\n\t\t\tSee Also:\n\t\t\t\t<getModuleGroup>\n\t\t\t\t<getModuleGroupByRoute>\n\t\t*/\n\n\n\t\tstatic function getModuleGroupByName($name) {\n\t\t\t$name = sqlescape(strtolower($name));\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_groups WHERE LOWER(name) = '$name'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleGroupByRoute\n\t\t\t\tReturns a module group entry from the bigtree_module_groups table.\n\n\t\t\tParameters:\n\t\t\t\troute - The route of the module group.\n\n\t\t\tReturns:\n\t\t\t\tA module group entry.\n\n\t\t\tSee Also:\n\t\t\t\t<getModuleGroup>\n\t\t\t\t<getModuleGroupByName>\n\t\t*/\n\n\t\tstatic function getModuleGroupByRoute($route) {\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_module_groups WHERE route = '\".sqlescape($route).\"'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleGroups\n\t\t\t\tReturns a list of module groups.\n\n\t\t\tParameters:\n\t\t\t\tsort - Sort by (defaults to positioned)\n\n\t\t\tReturns:\n\t\t\t\tAn array of module group entries from bigtree_module_groups.\n\t\t*/\n\n\t\tstatic function getModuleGroups($sort = \"position DESC, id ASC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_groups ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[$f[\"id\"]] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleNavigation\n\t\t\t\tReturns a list of module actions that are in navigation.\n\n\t\t\tParameters:\n\t\t\t\tmodule - A module id or a module entry.\n\n\t\t\tReturns:\n\t\t\t\tAn array of module actions from bigtree_module_actions.\n\t\t*/\n\n\t\tstatic function getModuleNavigation($module) {\n\t\t\tif (is_array($module)) {\n\t\t\t\t$module = sqlescape($module[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$module = sqlescape($module);\n\t\t\t}\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '$module' AND in_nav = 'on' ORDER BY position DESC, id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleReports\n\t\t\t\tGets reports from the bigtree_module_reports table.\n\n\t\t\tParameters:\n\t\t\t\tsort - The field to sort by.\n\t\t\t\tmodule - Specific module to pull reports for (defaults to all modules).\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_module_reports.\n\t\t*/\n\n\t\tstatic function getModuleReports($sort = \"title\",$module = false) {\n\t\t\t$items = array();\n\t\t\tif ($module) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_reports WHERE module = '\".sqlescape($module).\"' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_reports ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"fields\"] = json_decode($f[\"fields\"],true);\n\t\t\t\t$f[\"filters\"] = json_decode($f[\"filters\"],true);\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModules\n\t\t\t\tReturns a list of modules.\n\n\t\t\tParameters:\n\t\t\t\tsort - The sort order (defaults to oldest first).\n\t\t\t\tauth - If set to true, only returns modules the logged in user has access to. Defaults to true.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from the bigtree_modules table with an additional \"group_name\" column for the group the module is in.\n\t\t*/\n\n\t\tfunction getModules($sort = \"id ASC\",$auth = true) {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT bigtree_modules.*,bigtree_module_groups.name AS group_name FROM bigtree_modules LEFT JOIN bigtree_module_groups ON bigtree_modules.`group` = bigtree_module_groups.id ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif (!$auth || $this->checkAccess($f[\"id\"])) {\n\t\t\t\t\t$items[$f[\"id\"]] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModulesByGroup\n\t\t\t\tReturns a list of modules in a given group.\n\n\t\t\tParameters:\n\t\t\t\tgroup - The group to return modules for.\n\t\t\t\tsort - The sort order (defaults to positioned)\n\t\t\t\tauth - If set to true, only returns modules the logged in user has access to. Defaults to true.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from the bigtree_modules table.\n\t\t*/\n\n\t\tfunction getModulesByGroup($group,$sort = \"position DESC, id ASC\",$auth = true) {\n\t\t\tif (is_array($group)) {\n\t\t\t\t$group = sqlescape($group[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$group = sqlescape($group);\n\t\t\t}\n\t\t\t$items = array();\n\t\t\tif ($group) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_modules WHERE `group` = '$group' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_modules WHERE `group` = 0 OR `group` IS NULL ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($this->checkAccess($f[\"id\"]) || !$auth) {\n\t\t\t\t\t$items[$f[\"id\"]] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getModuleViews\n\t\t\t\tReturns a list of all entries in the bigtree_module_views table.\n\n\t\t\tParameters:\n\t\t\t\tsort - The column to sort by.\n\t\t\t\tmodule - Specific module to pull views for (defaults to all modules).\n\n\t\t\tReturns:\n\t\t\t\tAn array of view entries with \"fields\" decoded.\n\t\t*/\n\n\t\tstatic function getModuleViews($sort = \"title\",$module = false) {\n\t\t\t$items = array();\n\t\t\tif ($module !== false) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_views WHERE module = '\".sqlescape($module).\"' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_module_views ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($view = sqlfetch($q)) {\n\t\t\t\t$view[\"fields\"] = json_decode($view[\"fields\"],true);\n\t\t\t\t$view[\"actions\"] = json_decode($view[\"actions\"],true);\n\t\t\t\t$view[\"options\"] = json_decode($view[\"options\"],true);\t\t\n\t\t\t\t$items[] = $view;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getNaturalNavigationByParent\n\t\t\t\tReturns a list of positioned navigation that is in navigation under the given parent.\n\t\t\t\tDoes not return module navigation.\n\n\t\t\tParameters:\n\t\t\t\tparent - The ID of the parent page\n\n\t\t\tReturns:\n\t\t\t\tAn array of page entries.\n\t\t*/\n\n\t\tstatic function getNaturalNavigationByParent($parent,$levels = 1) {\n\t\t\t$nav = array();\n\t\t\t$q = sqlquery(\"SELECT id,nav_title AS title,parent,external,new_window,template,publish_at,expire_at,path,ga_page_views FROM bigtree_pages WHERE parent = '$parent' AND in_nav = 'on' AND archived != 'on' ORDER BY position DESC, id ASC\");\n\t\t\twhile ($nav_item = sqlfetch($q)) {\n\t\t\t\t$nav_item[\"external\"] = BigTreeCMS::replaceRelativeRoots($nav_item[\"external\"]);\n\t\t\t\tif ($levels > 1) {\n\t\t\t\t\t$nav_item[\"children\"] = static::getNaturalNavigationByParent($nav_item[\"id\"],$levels - 1);\n\t\t\t\t}\n\t\t\t\t$nav[] = $nav_item;\n\t\t\t}\n\t\t\treturn $nav;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPackage\n\t\t\t\tReturns information about a package or extension.\n\n\t\t\tParameters:\n\t\t\t\tid - The package/extension ID.\n\n\t\t\tReturns:\n\t\t\t\tA package/extension.\n\t\t*/\n\n\t\tstatic function getPackage($id) {\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_extensions WHERE id = '\".sqlescape($id).\"'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPackages\n\t\t\t\tReturns a list of installed/created packages.\n\n\t\t\tParameters:\n\t\t\t\tsort - Column/direction to sort (defaults to last_updated DESC)\n\n\t\t\tReturns:\n\t\t\t\tAn array of packages.\n\t\t*/\n\n\t\tstatic function getPackages($sort = \"last_updated DESC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_extensions WHERE type = 'package' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageAccessLevel\n\t\t\t\tReturns the access level for the logged in user to a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\n\t\t\tReturns:\n\t\t\t\t\"p\" for publisher, \"e\" for editor, false for no access.\n\n\t\t\tSee Also:\n\t\t\t\t<getPageAccessLevelForUser>\n\t\t*/\n\n\t\tfunction getPageAccessLevel($page) {\n\t\t\treturn $this->getPageAccessLevelByUser($page,$this->ID);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageAccessLevelByUser\n\t\t\t\tReturns the access level for the given user to a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\t\t\t\tuser - The user id.\n\n\t\t\tReturns:\n\t\t\t\t\"p\" for publisher, \"e\" for editor, false for no access.\n\n\t\t\tSee Also:\n\t\t\t\t<getPageAccessLevel>\n\t\t*/\n\n\t\tfunction getPageAccessLevelByUser($page,$user) {\n\t\t\t// See if this is a pending change, if so, grab the change's parent page and check permission levels for that instead.\n\t\t\tif (!is_numeric($page) && $page[0] == \"p\") {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE id = '\".sqlescape(substr($page,1)).\"'\"));\n\t\t\t\t$changes = json_decode($f[\"changes\"],true);\n\t\t\t\treturn $this->getPageAccessLevelByUser($changes[\"parent\"],$user);\n\t\t\t}\n\n\t\t\t// If we're checking the logged in user, just use the info we already have\n\t\t\tif ($user == $this->ID) {\n\t\t\t\t$level = $this->Level;\n\t\t\t\t$permissions = $this->Permissions;\n\t\t\t// Not the logged in user? Look up the person.\n\t\t\t} else {\n\t\t\t\t$u = static::getUser($user);\n\t\t\t\t$level = $u[\"level\"];\n\t\t\t\t$permissions = $u[\"permissions\"];\n\t\t\t}\n\n\t\t\t// See if the user is an administrator, if so we can skip permissions.\n\t\t\tif ($level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\n\t\t\t// See if this page has an explicit permission set and return it if so.\n\t\t\t$explicit_permission = $permissions[\"page\"][$page];\n\t\t\tif ($explicit_permission == \"n\") {\n\t\t\t\treturn false;\n\t\t\t} elseif ($explicit_permission && $explicit_permission != \"i\") {\n\t\t\t\treturn $explicit_permission;\n\t\t\t}\n\n\t\t\t// We're now assuming that this page should inherit permissions from farther up the tree, so let's grab the first parent.\n\t\t\t$page_data = sqlfetch(sqlquery(\"SELECT parent FROM bigtree_pages WHERE id = '\".sqlescape($page).\"'\"));\n\n\t\t\t// Grab the parent's permission. Keep going until we find a permission that isn't inherit or until we hit a parent of 0.\n\t\t\t$parent_permission = $permissions[\"page\"][$page_data[\"parent\"]];\n\t\t\twhile ((!$parent_permission || $parent_permission == \"i\") && $page_data[\"parent\"]) {\n\t\t\t\t$page_data = sqlfetch(sqlquery(\"SELECT parent FROM bigtree_pages WHERE id = '\".$page_data[\"parent\"].\"'\"));\n\t\t\t\t$parent_permission = $permissions[\"page\"][$page_data[\"parent\"]];\n\t\t\t}\n\n\t\t\t// If no permissions are set on the page (we hit page 0 and still nothing) or permission is \"n\", return not allowed.\n\t\t\tif (!$parent_permission || $parent_permission == \"i\" || $parent_permission == \"n\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Return whatever we found.\n\t\t\treturn $parent_permission;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageAdminLinks\n\t\t\t\tGets a list of pages that link back to the admin.\n\n\t\t\tReturns:\n\t\t\t\tAn array of pages that link to the admin.\n\t\t*/\n\n\t\tstatic function getPageAdminLinks() {\n\t\t\tglobal $bigtree;\n\t\t\t$pages = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE REPLACE(resources,'{adminroot}js/embeddable-form.js','') LIKE '%{adminroot}%' OR resources LIKE '%\".$bigtree[\"config\"][\"admin_root\"].\"%' OR resources LIKE '%\".str_replace($bigtree[\"config\"][\"www_root\"],\"{wwwroot}\",$bigtree[\"config\"][\"admin_root\"]).\"%'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$pages[] = $f;\n\t\t\t}\n\t\t\treturn $pages;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageChanges\n\t\t\t\tReturns pending changes for a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\n\t\t\tReturns:\n\t\t\t\tAn entry from bigtree_pending_changes with changes decoded.\n\t\t*/\n\n\t\tstatic function getPageChanges($page) {\n\t\t\t$page = sqlescape($page);\n\t\t\t$c = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND item_id = '$page'\"));\n\t\t\tif (!$c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$c[\"changes\"] = json_decode($c[\"changes\"],true);\n\t\t\treturn $c;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageChildren\n\t\t\t\tReturns all non-archived children of a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id to pull children for.\n\t\t\t\tsort - The way to sort results. Defaults to nav_title ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of pages.\n\t\t*/\n\n\t\tstatic function getPageChildren($page,$sort = \"nav_title ASC\") {\n\t\t\t$page = sqlescape($page);\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE parent = '$page' AND archived != 'on' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageLineage\n\t\t\t\tReturns all the ids of pages above this page.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpage - Page ID\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tArray of IDs\n\t\t*/\n\t\t\n\t\tfunction getPageLineage($page) {\n\t\t\t$parents = array();\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT parent FROM bigtree_pages WHERE id = '\".sqlescape($page).\"'\"));\n\t\t\t$parents[] = $f[\"parent\"];\n\t\t\twhile ($f[\"parent\"]) {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT parent FROM bigtree_pages WHERE id = '\".sqlescape($f[\"parent\"]).\"'\"));\n\t\t\t\tif ($f[\"parent\"]) {\n\t\t\t\t\t$parents[] = $f[\"parent\"];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $parents;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageIds\n\t\t\t\tReturns all the IDs in bigtree_pages for pages that aren't archived.\n\n\t\t\tReturns:\n\t\t\t\tAn array of page ids.\n\t\t*/\n\n\t\tstatic function getPageIds() {\n\t\t\t$ids = array();\n\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_pages WHERE archived != 'on' ORDER BY id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$ids[] = $f[\"id\"];\n\t\t\t}\n\t\t\treturn $ids;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageIDForPath\n\t\t\t\tProvides the page ID for a given path array.\n\t\t\t\tThis is equivalent to BigTreeCMS::getNavId.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpath - An array of path elements from a URL\n\t\t\t\tpreviewing - Whether we are previewing or not.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array containing the page ID and any additional commands.\n\t\t*/\n\t\t\n\t\tstatic function getPageIDForPath($path,$previewing = false) {\n\t\t\t$commands = array();\n\n\t\t\t// Reset array keys\n\t\t\t$path = array_values($path);\n\t\t\t\n\t\t\tif (!$previewing) {\n\t\t\t\t$publish_at = \"AND (publish_at <= NOW() OR publish_at IS NULL) AND (expire_at >= NOW() OR expire_at IS NULL)\";\n\t\t\t} else {\n\t\t\t\t$publish_at = \"\";\n\t\t\t}\n\t\t\t\n\t\t\t// See if we have a straight up perfect match to the path.\n\t\t\t$spath = sqlescape(implode(\"/\",$path));\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT bigtree_pages.id,bigtree_templates.routed FROM bigtree_pages LEFT JOIN bigtree_templates ON bigtree_pages.template = bigtree_templates.id WHERE path = '$spath' AND archived = '' $publish_at\"));\n\t\t\tif ($f) {\n\t\t\t\treturn array($f[\"id\"],$commands,$f[\"routed\"]);\n\t\t\t}\n\t\t\t\n\t\t\t// Guess we don't, let's chop off commands until we find a page.\n\t\t\t$x = 0;\n\t\t\twhile ($x < count($path)) {\n\t\t\t\t$x++;\n\t\t\t\t$commands[] = $path[count($path)-$x];\n\t\t\t\t$spath = sqlescape(implode(\"/\",array_slice($path,0,-1 * $x)));\n\t\t\t\t// We have additional commands, so we're now making sure the template is also routed, otherwise it's a 404.\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT bigtree_pages.id FROM bigtree_pages JOIN bigtree_templates ON bigtree_pages.template = bigtree_templates.id WHERE bigtree_pages.path = '$spath' AND bigtree_pages.archived = '' AND bigtree_templates.routed = 'on' $publish_at\"));\n\t\t\t\tif ($f) {\n\t\t\t\t\treturn array($f[\"id\"],array_reverse($commands),\"on\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn array(false,false,false);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageOfSettings\n\t\t\t\tReturns a page of settings the logged in user has access to.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page to return.\n\t\t\t\tquery - Optional query string to search against.\n\t\t\t\tsort - Sort order. Defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_settings.\n\t\t\t\tIf the setting is encrypted the value will be \"[Encrypted Text]\", otherwise it will be decoded.\n\t\t\t\tIf the calling user is a developer, returns locked settings, otherwise they are left out.\n\t\t*/\n\n\t\tfunction getPageOfSettings($page = 1,$query = \"\") {\n\t\t\t// If we're querying...\n\t\t\tif ($query) {\n\t\t\t\t$qparts = explode(\" \",$query);\n\t\t\t\t$qp = array();\n\t\t\t\tforeach ($qparts as $part) {\n\t\t\t\t\t$part = sqlescape(strtolower($part));\n\t\t\t\t\t$qp[] = \"(LOWER(name) LIKE '%$part%' OR LOWER(`value`) LIKE '%$part%')\";\n\t\t\t\t}\n\t\t\t\t// If we're not a developer, leave out locked settings\n\t\t\t\tif ($this->Level < 2) {\n\t\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE \".implode(\" AND \",$qp).\" AND locked = '' AND system = '' ORDER BY name LIMIT \".(($page - 1) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t\t// If we are a developer, show them.\n\t\t\t\t} else {\n\t\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE \".implode(\" AND \",$qp).\" AND system = '' ORDER BY name LIMIT \".(($page - 1) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If we're not a developer, leave out locked settings\n\t\t\t\tif ($this->Level < 2) {\n\t\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE locked = '' AND system = '' ORDER BY name LIMIT \".(($page - 1) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t\t// If we are a developer, show them.\n\t\t\t\t} else {\n\t\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE system = '' ORDER BY name LIMIT \".(($page - 1 ) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$items = array();\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"value\"] = json_decode($f[\"value\"],true);\n\t\t\t\tif (is_array($f[\"value\"])) {\n\t\t\t\t\t$f[\"value\"] = BigTree::untranslateArray($f[\"value\"]);\n\t\t\t\t} else {\n\t\t\t\t\t$f[\"value\"] = BigTreeCMS::replaceInternalPageLinks($f[\"value\"]);\n\t\t\t\t}\n\t\t\t\t$f[\"description\"] = BigTreeCMS::replaceInternalPageLinks($f[\"description\"]);\n\t\t\t\tif ($f[\"encrypted\"]) {\n\t\t\t\t\t$f[\"value\"] = \"[Encrypted Text]\";\n\t\t\t\t}\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageOfUsers\n\t\t\t\tReturns a page of users.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page of users to return.\n\t\t\t\tquery - Optional query string to search against.\n\t\t\t\tsort - Order to sort the results by. Defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_users.\n\t\t*/\n\n\t\tstatic function getPageOfUsers($page = 1,$query = \"\",$sort = \"name ASC\") {\n\t\t\t// If we're searching.\n\t\t\tif ($query) {\n\t\t\t\t$qparts = explode(\" \",$query);\n\t\t\t\t$qp = array();\n\t\t\t\tforeach ($qparts as $part) {\n\t\t\t\t\t$part = sqlescape(strtolower($part));\n\t\t\t\t\t$qp[] = \"(LOWER(name) LIKE '%$part%' OR LOWER(email) LIKE '%$part%' OR LOWER(company) LIKE '%$part%')\";\n\t\t\t\t}\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_users WHERE \".implode(\" AND \",$qp).\" ORDER BY $sort LIMIT \".(($page - 1) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t// If we're grabbing anyone.\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_users ORDER BY $sort LIMIT \".(($page - 1) * static::$PerPage).\",\".static::$PerPage);\n\t\t\t}\n\n\t\t\t$items = array();\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageRevision\n\t\t\t\tReturns a version of a page from the bigtree_page_revisions table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the page version.\n\n\t\t\tReturns:\n\t\t\t\tA page version entry from the table.\n\t\t*/\n\n\t\tstatic function getPageRevision($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_page_revisions WHERE id = '$id'\"));\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageRevisions\n\t\t\t\tGet all revisions for a page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id to get revisions for.\n\n\t\t\tReturns:\n\t\t\t\tAn array of \"saved\" revisions and \"unsaved\" revisions.\n\t\t*/\n\n\t\tstatic function getPageRevisions($page) {\n\t\t\t$page = sqlescape($page);\n\n\t\t\t// Get all previous revisions, add them to the saved or unsaved list\n\t\t\t$unsaved = array();\n\t\t\t$saved = array();\n\t\t\t$q = sqlquery(\"SELECT bigtree_users.name, bigtree_users.email, bigtree_page_revisions.saved, bigtree_page_revisions.saved_description, bigtree_page_revisions.updated_at, bigtree_page_revisions.id FROM bigtree_page_revisions JOIN bigtree_users ON bigtree_page_revisions.author = bigtree_users.id WHERE page = '$page' ORDER BY updated_at DESC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($f[\"saved\"]) {\n\t\t\t\t\t$saved[] = $f;\n\t\t\t\t} else {\n\t\t\t\t\t$unsaved[] = $f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array(\"saved\" => $saved, \"unsaved\" => $unsaved);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPages\n\t\t\t\tReturns all pages from the database.\n\n\t\t\tReturns:\n\t\t\t\tArray of unmodified entries from bigtree_pages.\n\t\t*/\n\n\t\tstatic function getPages() {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages ORDER BY id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPageSEORating\n\t\t\t\tReturns the SEO rating for a page.\n\n\t\t\tParameters:\n\t\t\t\tpage - A page array.\n\t\t\t\tcontent - An array of resources.\n\n\t\t\tReturns:\n\t\t\t\tAn array of SEO data.\n\t\t\t\t\"score\" reflects a score from 0 to 100 points.\n\t\t\t\t\"recommendations\" is an array of recommendations to improve SEO score.\n\t\t\t\t\"color\" is a color reflecting the SEO score.\n\n\t\t\t\tScore Parameters\n\t\t\t\t- Having a title - 5 points\n\t\t\t\t- Having a unique title - 5 points\n\t\t\t\t- Title does not exceed 72 characters and has at least 4 words - 5 points\n\t\t\t\t- Having a meta description - 5 points\n\t\t\t\t- Meta description that is less than 165 characters - 5 points\n\t\t\t\t- Having an h1 - 10 points\n\t\t\t\t- Having page content - 5 points\n\t\t\t\t- Having at least 300 words in your content - 15 points\n\t\t\t\t- Having links in your content - 5 points\n\t\t\t\t- Having external links in your content - 5 points\n\t\t\t\t- Having one link for every 120 words of content - 5 points\n\t\t\t\t- Readability Score - up to 20 points\n\t\t\t\t- Fresh content - up to 10 points\n\t\t*/\n\n\t\tstatic function getPageSEORating($page,$content) {\n\t\t\t$template = BigTreeCMS::getTemplate($page[\"template\"]);\n\t\t\t$tsources = array();\n\t\t\t$h1_field = \"\";\n\t\t\t$body_fields = array();\n\n\t\t\tif (is_array($template[\"resources\"])) {\n\t\t\t\tforeach ($template[\"resources\"] as $item) {\n\t\t\t\t\tif (isset($item[\"seo_body\"]) && $item[\"seo_body\"]) {\n\t\t\t\t\t\t$body_fields[] = $item[\"id\"];\n\t\t\t\t\t}\n\t\t\t\t\tif (isset($item[\"seo_h1\"]) && $item[\"seo_h1\"]) {\n\t\t\t\t\t\t$h1_field = $item[\"id\"];\n\t\t\t\t\t}\n\t\t\t\t\t$tsources[$item[\"id\"]] = $item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$h1_field && $tsources[\"page_header\"]) {\n\t\t\t\t$h1_field = \"page_header\";\n\t\t\t}\n\t\t\tif (!count($body_fields) && $tsources[\"page_content\"]) {\n\t\t\t\t$body_fields[] = \"page_content\";\n\t\t\t}\n\n\t\t\t$textStats = new TextStatistics;\n\t\t\t$recommendations = array();\n\n\t\t\t$score = 0;\n\n\t\t\t// Check if they have a page title.\n\t\t\tif ($page[\"title\"]) {\n\t\t\t\t$score += 5;\n\t\t\t\t// They have a title, let's see if it's unique\n\t\t\t\t$r = sqlrows(sqlquery(\"SELECT * FROM bigtree_pages WHERE title = '\".sqlescape($page[\"title\"]).\"' AND id != '\".sqlescape($page[\"id\"]).\"'\"));\n\t\t\t\tif ($r == 0) {\n\t\t\t\t\t// They have a unique title\n\t\t\t\t\t$score += 5;\n\t\t\t\t} else {\n\t\t\t\t\t$recommendations[] = \"Your page title should be unique. \".($r-1).\" other page(s) have the same title.\";\n\t\t\t\t}\n\t\t\t\t$words = $textStats->word_count($page[\"title\"]);\n\t\t\t\t$length = mb_strlen($page[\"title\"]);\n\t\t\t\tif ($words >= 4 && $length <= 72) {\n\t\t\t\t\t// Fits the bill!\n\t\t\t\t\t$score += 5;\n\t\t\t\t} else {\n\t\t\t\t\t$recommendations[] = \"Your page title should be no more than 72 characters and should contain at least 4 words.\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$recommendations[] = \"You should enter a page title.\";\n\t\t\t}\n\n\t\t\t// Check for meta description\n\t\t\tif ($page[\"meta_description\"]) {\n\t\t\t\t$score += 5;\n\t\t\t\t// They have a meta description, let's see if it's no more than 165 characters.\n\t\t\t\tif (mb_strlen($page[\"meta_description\"]) <= 165) {\n\t\t\t\t\t$score += 5;\n\t\t\t\t} else {\n\t\t\t\t\t$recommendations[] = \"Your meta description should be no more than 165 characters. It is currently \".mb_strlen($page[\"meta_description\"]).\" characters.\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$recommendations[] = \"You should enter a meta description.\";\n\t\t\t}\n\n\t\t\t// Check for an H1\n\t\t\tif (!$h1_field || $content[$h1_field]) {\n\t\t\t\t$score += 10;\n\t\t\t} else {\n\t\t\t\t$recommendations[] = \"You should enter a page header.\";\n\t\t\t}\n\t\t\t// Check the content!\n\t\t\tif (!count($body_fields)) {\n\t\t\t\t// If this template doesn't for some reason have a seo body resource, give the benefit of the doubt.\n\t\t\t\t$score += 65;\n\t\t\t} else {\n\t\t\t\t$regular_text = \"\";\n\t\t\t\t$stripped_text = \"\";\n\t\t\t\tforeach ($body_fields as $field) {\n\t\t\t\t\tif (!is_array($content[$field])) {\n\t\t\t\t\t\t$regular_text .= $content[$field].\" \";\n\t\t\t\t\t\t$stripped_text .= strip_tags($content[$field]).\" \";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Check to see if there is any content\n\t\t\t\tif ($stripped_text) {\n\t\t\t\t\t$score += 5;\n\t\t\t\t\t$words = $textStats->word_count($stripped_text);\n\t\t\t\t\t$readability = $textStats->flesch_kincaid_reading_ease($stripped_text);\n\t\t\t\t\tif ($readability < 0) {\n\t\t\t\t\t\t$readability = 0;\n\t\t\t\t\t}\n\t\t\t\t\t$number_of_links = substr_count($regular_text,\"<a \");\n\t\t\t\t\t$number_of_external_links = substr_count($regular_text,'href=\"http://');\n\n\t\t\t\t\t// See if there are at least 300 words.\n\t\t\t\t\tif ($words >= 300) {\n\t\t\t\t\t\t$score += 15;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$recommendations[] = \"You should enter at least 300 words of page content. You currently have \".$words.\" word(s).\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// See if we have any links\n\t\t\t\t\tif ($number_of_links) {\n\t\t\t\t\t\t$score += 5;\n\t\t\t\t\t\t// See if we have at least one link per 120 words.\n\t\t\t\t\t\tif (floor($words / 120) <= $number_of_links) {\n\t\t\t\t\t\t\t$score += 5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$recommendations[] = \"You should have at least one link for every 120 words of page content. You currently have $number_of_links link(s). You should have at least \".floor($words / 120).\".\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// See if we have any external links.\n\t\t\t\t\t\tif ($number_of_external_links) {\n\t\t\t\t\t\t\t$score += 5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$recommendations[] = \"Having an external link helps build Page Rank.\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$recommendations[] = \"You should have at least one link in your content.\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check on our readability score.\n\t\t\t\t\tif ($readability >= 90) {\n\t\t\t\t\t\t$score += 20;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$read_score = round(($readability / 90),2);\n\t\t\t\t\t\t$recommendations[] = \"Your readability score is \".($read_score*100).\"%. Using shorter sentences and words with fewer syllables will make your site easier to read by search engines and users.\";\n\t\t\t\t\t\t$score += ceil($read_score * 20);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$recommendations[] = \"You should enter page content.\";\n\t\t\t\t}\n\n\t\t\t\t// Check page freshness\n\t\t\t\t$updated = strtotime($page[\"updated_at\"]);\n\t\t\t\t$age = time()-$updated-(60*24*60*60);\n\t\t\t\t// See how much older it is than 2 months.\n\t\t\t\tif ($age > 0) {\n\t\t\t\t\t$age_score = 10 - floor(2 * ($age / (30*24*60*60)));\n\t\t\t\t\tif ($age_score < 0) {\n\t\t\t\t\t\t$age_score = 0;\n\t\t\t\t\t}\n\t\t\t\t\t$score += $age_score;\n\t\t\t\t\t$recommendations[] = \"Your content is around \".ceil(2 + ($age / (30*24*60*60))).\" months old. Updating your page more frequently will make it rank higher.\";\n\t\t\t\t} else {\n\t\t\t\t\t$score += 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$color = \"#008000\";\n\t\t\tif ($score <= 50) {\n\t\t\t\t$color = BigTree::colorMesh(\"#CCAC00\",\"#FF0000\",100-(100 * $score / 50));\n\t\t\t} elseif ($score <= 80) {\n\t\t\t\t$color = BigTree::colorMesh(\"#008000\",\"#CCAC00\",100-(100 * ($score-50) / 30));\n\t\t\t}\n\n\t\t\treturn array(\"score\" => $score, \"recommendations\" => $recommendations, \"color\" => $color);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPendingChange\n\t\t\t\tReturns a pending change from the bigtree_pending_changes table.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the change.\n\n\t\t\tReturns:\n\t\t\t\tA entry from the table with the \"changes\" column decoded.\n\t\t*/\n\n\t\tstatic function getPendingChange($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE id = '$id'\"));\n\t\t\tif (!$item) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$item[\"changes\"] = json_decode($item[\"changes\"],true);\n\t\t\t$item[\"mtm_changes\"] = json_decode($item[\"mtm_changes\"],true);\n\t\t\t$item[\"tags_changes\"] = json_decode($item[\"tags_changes\"],true);\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPublishableChanges\n\t\t\t\tReturns a list of changes that the logged in user has access to publish.\n\n\t\t\tParameters:\n\t\t\t\tuser - The user id to retrieve changes for. Defaults to the logged in user.\n\n\t\t\tReturns:\n\t\t\t\tAn array of changes sorted by most recent.\n\t\t*/\n\n\t\tfunction getPublishableChanges($user = false) {\n\t\t\tif (!$user) {\n\t\t\t\t$user = static::getUser($this->ID);\n\t\t\t} else {\n\t\t\t\t$user = static::getUser($user);\n\t\t\t}\n\n\t\t\t$changes = array();\n\t\t\t// Setup the default search array to just be pages\n\t\t\t$search = array(\"`module` = ''\");\n\t\t\t// Add each module the user has publisher permissions to\n\t\t\tif (is_array($user[\"permissions\"][\"module\"])) {\n\t\t\t\tforeach ($user[\"permissions\"][\"module\"] as $module => $permission) {\n\t\t\t\t\tif ($permission == \"p\") {\n\t\t\t\t\t\t$search[] = \"`module` = '$module'\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add module group based permissions as well\n\t\t\tif (isset($user[\"permissions\"][\"module_gbp\"]) && is_array($user[\"permissions\"][\"module_gbp\"])) {\n\t\t\t\tforeach ($user[\"permissions\"][\"module_gbp\"] as $module => $groups) {\n\t\t\t\t\tforeach ($groups as $group => $permission) {\n\t\t\t\t\t\tif ($permission == \"p\") {\n\t\t\t\t\t\t\t$search[] = \"`module` = '$module'\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE \".implode(\" OR \",$search).\" ORDER BY date DESC\");\n\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$ok = false;\n\n\t\t\t\tif (!$f[\"item_id\"]) {\n\t\t\t\t\t$id = \"p\".$f[\"id\"];\n\t\t\t\t} else {\n\t\t\t\t\t$id = $f[\"item_id\"];\n\t\t\t\t}\n\n\t\t\t\t// If they're an admin, they've got it.\n\t\t\t\tif ($user[\"level\"] > 0) {\n\t\t\t\t\t$ok = true;\n\t\t\t\t// Check permissions on a page if it's a page.\n\t\t\t\t} elseif ($f[\"table\"] == \"bigtree_pages\") {\n\t\t\t\t\t$r = $this->getPageAccessLevelByUser($id,$user[\"id\"]);\n\t\t\t\t\t// If we're a publisher, this is ours!\n\t\t\t\t\tif ($r == \"p\") {\n\t\t\t\t\t\t$ok = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Check our list of modules.\n\t\t\t\t\tif ($user[\"permissions\"][\"module\"][$f[\"module\"]] == \"p\") {\n\t\t\t\t\t\t$ok = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Check our group based permissions\n\t\t\t\t\t\t$item = BigTreeAutoModule::getPendingItem($f[\"table\"],$id);\n\t\t\t\t\t\t$level = $this->getAccessLevel(static::getModule($f[\"module\"]),$item[\"item\"],$f[\"table\"],$user);\n\t\t\t\t\t\tif ($level == \"p\") {\n\t\t\t\t\t\t\t$ok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We're a publisher, get the info about the change and put it in the change list.\n\t\t\t\tif ($ok) {\n\t\t\t\t\t$f[\"mod\"] = static::getModule($f[\"module\"]);\n\t\t\t\t\t$f[\"user\"] = static::getUser($f[\"user\"]);\n\t\t\t\t\t$changes[] = $f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $changes;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPendingChanges\n\t\t\t\tReturns a list of changes for a given user.\n\n\t\t\tParameters:\n\t\t\t\tuser - The user id to retrieve changes for. Defaults to the logged in user.\n\n\t\t\tReturns:\n\t\t\t\tAn array of changes sorted by most recent.\n\t\t*/\n\n\t\tfunction getPendingChanges($user = false) {\n\t\t\tif (is_array($user)) {\n\t\t\t\t$user = $user[\"id\"];\n\t\t\t} elseif (!$user) {\n\t\t\t\t$user = $this->ID;\n\t\t\t}\n\n\t\t\t$changes = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE user = '\".sqlescape($user).\"' ORDER BY date DESC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$changes[] = $f;\n\t\t\t}\n\n\t\t\treturn $changes;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getPendingNavigationByParent\n\t\t\t\tReturns a list of pending pages under a given parent ordered by most recent.\n\n\t\t\tParameters:\n\t\t\t\tparent - The ID of the parent page\n\t\t\t\tin_nav - true returns pages in navigation, false returns hidden pages\n\n\t\t\tReturns:\n\t\t\t\tAn array of pending page titles/ids.\n\t\t*/\n\n\t\tstatic function getPendingNavigationByParent($parent,$in_nav = true) {\n\t\t\t$nav = array();\n\t\t\t$titles = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE pending_page_parent = '$parent' AND `table` = 'bigtree_pages' AND type = 'NEW' ORDER BY date DESC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$page = json_decode($f[\"changes\"],true);\n\t\t\t\tif (($page[\"in_nav\"] && $in_nav) || (!$page[\"in_nav\"] && !$in_nav)) {\n\t\t\t\t\t$titles[] = $page[\"nav_title\"];\n\t\t\t\t\t$page[\"bigtree_pending\"] = true;\n\t\t\t\t\t$page[\"title\"] = $page[\"nav_title\"];\n\t\t\t\t\t$page[\"id\"] = \"p\".$f[\"id\"];\n\t\t\t\t\t$nav[] = $page;\n\t\t\t\t}\n\t\t\t}\n\t\t\tarray_multisort($titles,$nav);\n\t\t\treturn $nav;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getContentsOfResourceFolder\n\t\t\t\tReturns a list of resources and subfolders in a folder.\n\n\t\t\tParameters:\n\t\t\t\tfolder - The id of a folder or a folder entry.\n\t\t\t\tsort - The column to sort the folder's files on (default: date DESC).\n\n\t\t\tReturns:\n\t\t\t\tAn array of two arrays - folders and resources.\n\t\t*/\n\n\t\tstatic function getContentsOfResourceFolder($folder, $sort = \"date DESC\") {\n\t\t\tif (is_array($folder)) {\n\t\t\t\t$folder = $folder[\"id\"];\n\t\t\t}\n\t\t\t$folder = sqlescape($folder);\n\n\t\t\t$folders = array();\n\t\t\t$resources = array();\n\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resource_folders WHERE parent = '$folder' ORDER BY name\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$folders[] = $f;\n\t\t\t}\n\n\t\t\tif ($folder) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resources WHERE folder = '$folder' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resources WHERE folder = 0 OR folder IS NULL ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$resources[] = $f;\n\t\t\t}\n\n\t\t\treturn array(\"folders\" => $folders, \"resources\" => $resources);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceByFile\n\t\t\t\tReturns a resource with the given file name.\n\n\t\t\tParameters:\n\t\t\t\tfile - The file name.\n\n\t\t\tReturns:\n\t\t\t\tAn entry from bigtree_resources with file and thumbs decoded.\n\t\t*/\n\n\t\tstatic function getResourceByFile($file) {\n\t\t\tif (static::$IRLPrefixes === false) {\n\t\t\t\tstatic::$IRLPrefixes = array();\n\t\t\t\t$thumbnail_sizes = static::getSetting(\"bigtree-file-manager-thumbnail-sizes\");\n\t\t\t\t\n\t\t\t\tforeach ($thumbnail_sizes[\"value\"] as $ts) {\n\t\t\t\t\tstatic::$IRLPrefixes[] = $ts[\"prefix\"];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$last_prefix = false;\n\t\t\t$tokenized_file = BigTreeCMS::replaceHardRoots($file);\n\t\t\t$single_domain_tokenized_file = static::stripMultipleRootTokens($tokenized_file);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_resources WHERE file = '\".sqlescape($file).\"' OR file = '\".sqlescape($tokenized_file).\"' OR file = '\".sqlescape($single_domain_tokenized_file).\"'\"));\n\t\t\t\n\t\t\tif (!$item) {\n\t\t\t\tforeach (static::$IRLPrefixes as $prefix) {\n\t\t\t\t\tif (!$item) {\n\t\t\t\t\t\t$sfile = str_replace(\"files/resources/$prefix\", \"files/resources/\", $file);\n\t\t\t\t\t\t$tokenized_file = BigTreeCMS::replaceHardRoots($sfile);\n\t\t\t\t\t\t$single_domain_tokenized_file = static::stripMultipleRootTokens($tokenized_file);\n\t\t\t\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_resources WHERE file = '\".sqlescape($sfile).\"' OR file = '\".sqlescape($tokenized_file).\"' OR file = '\".sqlescape($single_domain_tokenized_file).\"'\"));\n\t\t\t\t\t\t$last_prefix = $prefix;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!$item) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$item[\"prefix\"] = $last_prefix;\n\t\t\t$item[\"file\"] = BigTreeCMS::replaceRelativeRoots($item[\"file\"]);\n\t\t\t$item[\"thumbs\"] = json_decode($item[\"thumbs\"],true);\n\t\t\t\n\t\t\tforeach ($item[\"thumbs\"] as &$thumb) {\n\t\t\t\t$thumb = BigTreeCMS::replaceRelativeRoots($thumb);\n\t\t\t}\n\t\t\t\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResource\n\t\t\t\tReturns a resource.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the resource.\n\n\t\t\tReturns:\n\t\t\t\tA resource entry.\n\t\t*/\n\n\t\tstatic function getResource($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_resources WHERE id = '$id'\"));\n\t\t\t$f[\"thumbs\"] = json_decode($f[\"thumbs\"],true);\n\t\t\treturn $f;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceAllocation\n\t\t\t\tReturns the places a resource is used.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the resource.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from the bigtree_resource_allocation table.\n\t\t*/\n\n\t\tstatic function getResourceAllocation($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resource_allocation WHERE resource = '$id' ORDER BY updated_at DESC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceFolder\n\t\t\t\tReturns a resource folder.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the folder.\n\n\t\t\tReturns:\n\t\t\t\tA resource folder entry.\n\t\t*/\n\n\t\tstatic function getResourceFolder($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_resource_folders WHERE id = '$id'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceFolderAllocationCounts\n\t\t\t\tReturns the number of items inside a folder and it's subfolders and the number of allocations of the contained resources.\n\n\t\t\tParameters:\n\t\t\t\tfolder - The id of the folder.\n\n\t\t\tReturns:\n\t\t\t\tA keyed array of \"resources\", \"folders\", and \"allocations\" for the number of resources, sub folders, and allocations.\n\t\t*/\n\n\t\tstatic function getResourceFolderAllocationCounts($folder) {\n\t\t\t$allocations = $folders = $resources = 0;\n\n\t\t\t$items = static::getContentsOfResourceFolder($folder);\n\t\t\tforeach ($items[\"folders\"] as $folder) {\n\t\t\t\t$folders++;\n\t\t\t\t$subs = static::getResourceFolderAllocationCounts($folder[\"id\"]);\n\t\t\t\t$allocations += $subs[\"allocations\"];\n\t\t\t\t$folders += $subs[\"folders\"];\n\t\t\t\t$resources += $subs[\"resources\"];\n\t\t\t}\n\t\t\tforeach ($items[\"resources\"] as $resource) {\n\t\t\t\t$resources++;\n\t\t\t\t$allocations += count(static::getResourceAllocation($resource[\"id\"]));\n\t\t\t}\n\t\t\treturn array(\"allocations\" => $allocations,\"folders\" => $folders,\"resources\" => $resources);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceFolderBreadcrumb\n\t\t\t\tReturns a breadcrumb of the given folder.\n\n\t\t\tParameters:\n\t\t\t\tfolder - The id of a folder or a folder entry.\n\n\t\t\tReturns:\n\t\t\t\tAn array of arrays containing the name and id of folders above.\n\t\t*/\n\n\t\tstatic function getResourceFolderBreadcrumb($folder,$crumb = array()) {\n\t\t\tif (!is_array($folder)) {\n\t\t\t\t$folder = sqlfetch(sqlquery(\"SELECT * FROM bigtree_resource_folders WHERE id = '\".sqlescape($folder).\"'\"));\n\t\t\t}\n\n\t\t\tif ($folder) {\n\t\t\t\t$crumb[] = array(\"id\" => $folder[\"id\"], \"name\" => $folder[\"name\"]);\n\t\t\t}\n\n\t\t\tif ($folder[\"parent\"]) {\n\t\t\t\treturn static::getResourceFolderBreadcrumb($folder[\"parent\"],$crumb);\n\t\t\t} else {\n\t\t\t\t$crumb[] = array(\"id\" => 0, \"name\" => \"Home\");\n\t\t\t\treturn array_reverse($crumb);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceFolderChildren\n\t\t\t\tReturns the child folders of a resource folder.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the parent folder.\n\n\t\t\tReturns:\n\t\t\t\tAn array of resource folder entries.\n\t\t*/\n\n\t\tstatic function getResourceFolderChildren($id) {\n\t\t\t$items = array();\n\t\t\t$id = sqlescape($id);\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resource_folders WHERE parent = '$id' ORDER BY name ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getResourceFolderPermission\n\t\t\t\tReturns the permission level of the current user for the folder.\n\n\t\t\tParameters:\n\t\t\t\tfolder - The id of a folder or a folder entry.\n\n\t\t\tReturns:\n\t\t\t\t\"p\" if a user can create folders and upload files, \"e\" if the user can see/use files, \"n\" if a user can't access this folder.\n\t\t*/\n\n\t\tfunction getResourceFolderPermission($folder) {\n\t\t\t// User is an admin or developer\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\n\t\t\t// We're going to save the folder entry in case we need its parent later.\n\t\t\tif (is_array($folder)) {\n\t\t\t\t$id = $folder[\"id\"];\n\t\t\t} else {\n\t\t\t\t$id = $folder;\n\t\t\t}\n\n\t\t\t$p = $this->Permissions[\"resources\"][$id];\n\t\t\t// If p is already no, creator, or consumer we can just return it.\n\t\t\tif ($p && $p != \"i\") {\n\t\t\t\treturn $p;\n\t\t\t} else {\n\t\t\t\t// If folder is 0, we're already at home and can't check a higher folder for permissions.\n\t\t\t\tif (!$folder) {\n\t\t\t\t\treturn \"e\";\n\t\t\t\t}\n\n\t\t\t\t// If a folder entry wasn't passed in, we need it to find its parent.\n\t\t\t\tif (!is_array($folder)) {\n\t\t\t\t\t$folder = sqlfetch(sqlquery(\"SELECT parent FROM bigtree_resource_folders WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\t\t}\n\t\t\t\t// If we couldn't find the folder anymore, just say they can consume.\n\t\t\t\tif (!$folder) {\n\t\t\t\t\treturn \"e\";\n\t\t\t\t}\n\n\t\t\t\t// Return the parent's permissions\n\t\t\t\treturn $this->getResourceFolderPermission($folder[\"parent\"]);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getRoutedTemplates\n\t\t\t\tReturns a list of routed templates ordered by position that the logged in user has access to.\n\n\t\t\tParameters:\n\t\t\t\tsort - Sort order, defaults to positioned\n\n\t\t\tReturns:\n\t\t\t\tAn array of template entries.\n\t\t*/\n\n\t\tfunction getRoutedTemplates($sort = \"position DESC, id ASC\") {\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_templates WHERE level <= '\".$this->Level.\"' ORDER BY $sort\");\n\t\t\t$items = array();\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($f[\"routed\"]) {\n\t\t\t\t\t$items[] = $f;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getSetting\n\t\t\t\tReturns a setting.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the setting to return.\n\t\t\t\tdecode - Whether to decode the array or not. Large data sets may want to set this to false if there aren't internal page links.\n\n\t\t\tReturns:\n\t\t\t\tA setting entry with its value properly decoded and decrypted.\n\t\t\t\tReturns false if the setting could not be found.\n\t\t*/\n\n\t\tstatic function getSetting($id,$decode = true) {\n\t\t\tglobal $bigtree;\n\t\t\t$id = BigTreeCMS::extensionSettingCheck($id);\n\t\t\t$setting = sqlfetch(sqlquery(\"SELECT * FROM bigtree_settings WHERE id = '$id'\"));\n\t\t\t\n\t\t\t// Setting doesn't exist\n\t\t\tif (!$setting) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Encrypted setting\n\t\t\tif ($setting[\"encrypted\"]) {\n\t\t\t\t$v = sqlfetch(sqlquery(\"SELECT AES_DECRYPT(`value`,'\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') AS `value` FROM bigtree_settings WHERE id = '$id'\"));\n\t\t\t\t$setting[\"value\"] = $v[\"value\"];\n\t\t\t}\n\n\t\t\t// Decode the JSON value\n\t\t\tif ($decode) {\n\t\t\t\t$setting[\"value\"] = json_decode($setting[\"value\"],true);\n\t\n\t\t\t\tif (is_array($setting[\"value\"])) {\n\t\t\t\t\t$setting[\"value\"] = BigTree::untranslateArray($setting[\"value\"]);\n\t\t\t\t} else {\n\t\t\t\t\t$setting[\"value\"] = BigTreeCMS::replaceInternalPageLinks($setting[\"value\"]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $setting;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getSettings\n\t\t\t\tReturns a list of all settings that the logged in user has access to.\n\n\t\t\tParameters:\n\t\t\t\tsort - Order to return the settings. Defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_settings.\n\t\t\t\tIf the setting is encrypted the value will be \"[Encrypted Text]\", otherwise it will be decoded.\n\t\t\t\tIf the calling user is a developer, returns locked settings, otherwise they are left out.\n\t\t*/\n\n\t\tfunction getSettings($sort = \"name ASC\") {\n\t\t\t$items = array();\n\t\t\tif ($this->Level < 2) {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE locked = '' AND system = '' ORDER BY $sort\");\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE system = '' ORDER BY $sort\");\n\t\t\t}\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tforeach ($f as $key => $val) {\n\t\t\t\t\t$f[$key] = BigTreeCMS::replaceRelativeRoots($val);\n\t\t\t\t}\n\t\t\t\t$f[\"value\"] = json_decode($f[\"value\"],true);\n\t\t\t\tif ($f[\"encrypted\"] == \"on\") {\n\t\t\t\t\t$f[\"value\"] = \"[Encrypted Text]\";\n\t\t\t\t}\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getSettingsPageCount\n\t\t\t\tReturns the number of pages of settings that the logged in user has access to.\n\n\t\t\tParameters:\n\t\t\t\tquery - Optional string to query against.\n\n\t\t\tReturns:\n\t\t\t\tThe number of pages of settings.\n\t\t*/\n\n\t\tfunction getSettingsPageCount($query = \"\") {\n\t\t\t// If we're searching.\n\t\t\tif ($query) {\n\t\t\t\t$qparts = explode(\" \",$query);\n\t\t\t\t$qp = array();\n\t\t\t\tforeach ($qparts as $part) {\n\t\t\t\t\t$part = sqlescape(strtolower($part));\n\t\t\t\t\t$qp[] = \"(LOWER(name) LIKE '%$part%' OR LOWER(value) LIKE '%$part%')\";\n\t\t\t\t}\n\t\t\t\t// Administrator\n\t\t\t\tif ($this->Level < 2) {\n\t\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_settings WHERE system = '' AND locked = '' AND \".implode(\" AND \",$qp));\n\t\t\t\t// Developer\n\t\t\t\t} else {\n\t\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_settings WHERE system = '' AND \".implode(\" AND \",$qp));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Administrator\n\t\t\t\tif ($this->Level < 2) {\n\t\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_settings WHERE system = '' AND locked = ''\");\n\t\t\t\t// Developer\n\t\t\t\t} else {\n\t\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_settings WHERE system = ''\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$r = sqlrows($q);\n\t\t\t$pages = ceil($r / static::$PerPage);\n\t\t\tif ($pages == 0) {\n\t\t\t\t$pages = 1;\n\t\t\t}\n\n\t\t\treturn $pages;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getSystemSettings\n\t\t\t\tReturns a list of user defined (no bigtree-internal- prefix) system settings without decoded values.\n\n\t\t\tParameters:\n\t\t\t\tsort - Order to return the settings. Defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_settings.\n\t\t*/\n\n\t\tstatic function getSystemSettings($sort = \"name ASC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE id NOT LIKE 'bigtree-internal-%' AND system != '' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getTag\n\t\t\t\tReturns a tag for the given id.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the tag.\n\n\t\t\tReturns:\n\t\t\t\tA bigtree_tags entry.\n\t\t*/\n\n\t\tstatic function getTag($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE id = '$id'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getTemplates\n\t\t\t\tReturns a list of templates.\n\n\t\t\tParameters:\n\t\t\t\tsort - Sort order, defaults to positioned.\n\n\t\t\tReturns:\n\t\t\t\tAn array of template entries.\n\t\t*/\n\n\t\tstatic function getTemplates($sort = \"position DESC, name ASC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_templates ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUnreadMessageCount\n\t\t\t\tReturns the number of unread messages for the logged in user.\n\n\t\t\tReturns:\n\t\t\t\tThe number of unread messages.\n\t\t*/\n\n\t\tfunction getUnreadMessageCount() {\n\t\t\treturn sqlrows(sqlquery(\"SELECT id FROM bigtree_messages WHERE recipients LIKE '%|\".$this->ID.\"|%' AND read_by NOT LIKE '%|\".$this->ID.\"|%'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUser\n\t\t\t\tGets a user's decoded information.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the user to return.\n\n\t\t\tReturns:\n\t\t\t\tA user entry from bigtree_users with permissions and alerts decoded.\n\t\t*/\n\n\t\tstatic function getUser($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE id = '$id'\"));\n\t\t\tif (!$item) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($item[\"level\"] > 0) {\n\t\t\t\t$permissions = array();\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_modules\");\n\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t$permissions[\"module\"][$f[\"id\"]] = \"p\";\n\t\t\t\t}\n\t\t\t\t$item[\"permissions\"] = $permissions;\n\t\t\t} else {\n\t\t\t\t$item[\"permissions\"] = json_decode($item[\"permissions\"],true);\n\t\t\t}\n\t\t\t$item[\"alerts\"] = json_decode($item[\"alerts\"],true);\n\t\t\treturn $item;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUserByEmail\n\t\t\t\tGets a user entry for a given email.\n\n\t\t\tParameters:\n\t\t\t\temail - The email to find.\n\n\t\t\tReturns:\n\t\t\t\tA user entry from bigtree_users.\n\t\t*/\n\n\t\tstatic function getUserByEmail($email) {\n\t\t\t$email = sqlescape($email);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE email = '$email'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUserByHash\n\t\t\t\tGets a user entry for a change password hash.\n\n\t\t\tParameters:\n\t\t\t\thash - The hash to find.\n\n\t\t\tReturns:\n\t\t\t\tA user entry from bigtree_users.\n\t\t*/\n\n\t\tstatic function getUserByHash($hash) {\n\t\t\t$hash = sqlescape($hash);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE change_password_hash = '$hash'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUsers\n\t\t\t\tReturns a list of all users.\n\n\t\t\tParameters:\n\t\t\t\tsort - Order to sort the list. Defaults to name ASC.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_users.\n\t\t\t\tThe keys of the array are the ids of the user.\n\t\t*/\n\n\t\tstatic function getUsers($sort = \"name ASC\") {\n\t\t\t$items = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_users ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$items[$f[\"id\"]] = $f;\n\t\t\t}\n\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: getUsersPageCount\n\t\t\t\tReturns the number of pages of users.\n\n\t\t\tParameters:\n\t\t\t\tquery - Optional query string to search against.\n\n\t\t\tReturns:\n\t\t\t\tThe number of pages of results.\n\t\t*/\n\n\t\tstatic function getUsersPageCount($query = \"\") {\n\t\t\t// If we're searching.\n\t\t\tif ($query) {\n\t\t\t\t$qparts = explode(\" \",$query);\n\t\t\t\t$qp = array();\n\t\t\t\tforeach ($qparts as $part) {\n\t\t\t\t\t$part = sqlescape(strtolower($part));\n\t\t\t\t\t$qp[] = \"(LOWER(name) LIKE '%$part%' OR LOWER(email) LIKE '%$part%' OR LOWER(company) LIKE '%$part%')\";\n\t\t\t\t}\n\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_users WHERE \".implode(\" AND \",$qp));\n\t\t\t// If we're showing all.\n\t\t\t} else {\n\t\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_users\");\n\t\t\t}\n\n\t\t\t$r = sqlrows($q);\n\t\t\t$pages = ceil($r / static::$PerPage);\n\t\t\tif ($pages == 0) {\n\t\t\t\t$pages = 1;\n\t\t\t}\n\n\t\t\treturn $pages;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: growl\n\t\t\t\tSets up a growl session for the next page reload.\n\n\t\t\tParameters:\n\t\t\t\ttitle - The section message for the growl.\n\t\t\t\tmessage - The description of what happened.\n\t\t\t\ttype - The icon to draw.\n\t\t*/\n\n\t\tstatic function growl($title,$message,$type = \"success\") {\n\t\t\t$_SESSION[\"bigtree_admin\"][\"growl\"] = array(\"message\" => $message, \"title\" => $title, \"type\" => $type);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: htmlClean\n\t\t\t\tRemoves things that shouldn't be in the <body> of an HTML document from a string.\n\n\t\t\tParameters:\n\t\t\t\thtml - A string of HTML\n\n\t\t\tReturns:\n\t\t\t\tA clean string of HTML for echoing in <body>\n\t\t*/\n\n\t\tstatic function htmlClean($html) {\n\t\t\treturn str_replace(\"<br></br>\",\"<br />\",strip_tags($html,\"<a><abbr><address><area><article><aside><audio><b><base><bdo><blockquote><body><br><button><canvas><caption><cite><code><col><colgroup><command><datalist><dd><del><details><dfn><div><dl><dt><em><emded><fieldset><figcaption><figure><footer><form><h1><h2><h3><h4><h5><h6><header><hgroup><hr><i><iframe><img><input><ins><keygen><kbd><label><legend><li><link><map><mark><menu><meter><nav><noscript><object><ol><optgroup><option><output><p><param><pre><progress><q><rp><rt><ruby><s><samp><script><section><select><small><source><span><strong><style><sub><summary><sup><table><tbody><td><textarea><tfoot><th><thead><time><title><tr><ul><var><video><wbr>\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: ignore404\n\t\t\t\tIgnores a 404 error.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the reported 404.\n\t\t*/\n\n\t\tfunction ignore404($id) {\n\t\t\t$this->requireLevel(1);\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"UPDATE bigtree_404s SET ignored = 'on' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_404s\",$id,\"ignored\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: initSecurity\n\t\t\t\tSets up security environment variables and runs white/blacklists for IP checks.\n\t\t*/\n\n\t\tfunction initSecurity() {\n\t\t\tglobal $bigtree;\n\t\t\t$ip = ip2long($_SERVER[\"REMOTE_ADDR\"]);\n\t\t\t$bigtree[\"security-policy\"] = $p = BigTreeCMS::getSetting(\"bigtree-internal-security-policy\");\n\n\t\t\t// Check banned IPs list for the user's IP\n\t\t\tif (!empty($p[\"banned_ips\"])) {\n\t\t\t\t$banned = explode(\"\\n\",$p[\"banned_ips\"]);\n\t\t\t\tforeach ($banned as $address) {\n\t\t\t\t\tif (ip2long(trim($address)) == $ip) {\n\t\t\t\t\t\t$bigtree[\"layout\"] = \"login\";\n\t\t\t\t\t\t$this->stop(file_get_contents(BigTree::path(\"admin/pages/ip-restriction.php\")));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check allowed IP ranges list for user's IP\n\t\t\tif (!empty($p[\"allowed_ips\"])) {\n\t\t\t\t$allowed = false;\n\t\t\t\t// Go through the list and see if our IP address is allowed\n\t\t\t\t$list = explode(\"\\n\",$p[\"allowed_ips\"]);\n\t\t\t\tforeach ($list as $item) {\n\t\t\t\t\tlist($begin,$end) = explode(\",\",$item);\n\t\t\t\t\t$begin = ip2long(trim($begin));\n\t\t\t\t\t$end = ip2long(trim($end));\n\t\t\t\t\tif ($begin <= $ip && $end >= $ip) {\n\t\t\t\t\t\t$allowed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!$allowed) {\n\t\t\t\t\t$bigtree[\"layout\"] = \"login\";\n\t\t\t\t\t$this->stop(file_get_contents(BigTree::path(\"admin/pages/ip-restriction.php\")));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: installExtension\n\t\t\t\tInstalls an extension.\n\n\t\t\tParameters:\n\t\t\t\tmanifest - Manifest array\n\t\t\t\tupgrade - Old manifest array (if doing an upgrade, otherwise leave false)\n\n\t\t\tReturns:\n\t\t\t\tModified manifest array.\n\t\t*/\n\n\t\tfunction installExtension($manifest,$upgrade = false) {\n\t\t\t$bigtree[\"group_match\"] = $bigtree[\"module_match\"] = $bigtree[\"route_match\"] = $bigtree[\"class_name_match\"] = $bigtree[\"form_id_match\"] = $bigtree[\"view_id_match\"] = $bigtree[\"report_id_match\"] = array();\n\t\t\t$extension = sqlescape($manifest[\"id\"]);\n\n\t\t\t// Turn off foreign key checks so we can reference the extension before creating it\n\t\t\tsqlquery(\"SET foreign_key_checks = 0\");\n\n\t\t\t// Upgrades drop existing modules, templates, etc -- we don't drop settings because they have user data\n\t\t\tif (is_array($upgrade)) {\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_module_groups WHERE extension = '$extension'\");\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_modules WHERE extension = '$extension'\");\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_templates WHERE extension = '$extension'\");\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_callouts WHERE extension = '$extension'\");\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_field_types WHERE extension = '$extension'\");\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_feeds WHERE extension = '$extension'\");\n\n\t\t\t// Import tables for new installs\n\t\t\t} else { \n\t\t\t\tforeach ($manifest[\"components\"][\"tables\"] as $table_name => $sql_statement) {\n\t\t\t\t\tsqlquery(\"DROP TABLE IF EXISTS `$table_name`\");\n\t\t\t\t\tsqlquery($sql_statement);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Import module groups\n\t\t\tforeach ($manifest[\"components\"][\"module_groups\"] as &$group) {\n\t\t\t\tif ($group) {\n\t\t\t\t\t$bigtree[\"group_match\"][$group[\"id\"]] = $this->createModuleGroup($group[\"name\"]);\n\t\t\t\t\t// Update the group ID since we're going to save this manifest locally for uninstalling\n\t\t\t\t\t$group[\"id\"] = $bigtree[\"group_match\"][$group[\"id\"]];\n\t\t\t\t\tsqlquery(\"UPDATE bigtree_module_groups SET extension = '$extension' WHERE id = '\".$group[\"id\"].\"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import modules\n\t\t\tforeach ($manifest[\"components\"][\"modules\"] as &$module) {\n\t\t\t\tif ($module) {\n\t\t\t\t\t$group = ($module[\"group\"] && isset($bigtree[\"group_match\"][$module[\"group\"]])) ? $bigtree[\"group_match\"][$module[\"group\"]] : \"NULL\";\n\t\t\t\t\t$gbp = sqlescape(is_array($module[\"gbp\"]) ? BigTree::json($module[\"gbp\"]) : $module[\"gbp\"]);\n\t\t\t\t\t// Find a unique route\n\t\t\t\t\t$oroute = $route = $module[\"route\"];\n\t\t\t\t\t$x = 2;\n\t\t\t\t\twhile (sqlrows(sqlquery(\"SELECT * FROM bigtree_modules WHERE route = '\".sqlescape($route).\"'\"))) {\n\t\t\t\t\t\t$route = $oroute.\"-$x\";\n\t\t\t\t\t\t$x++;\n\t\t\t\t\t}\n\t\t\t\t\t// Create the module\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_modules (`name`,`route`,`class`,`icon`,`group`,`gbp`,`extension`) VALUES ('\".sqlescape($module[\"name\"]).\"','\".sqlescape($route).\"','\".sqlescape($module[\"class\"]).\"','\".sqlescape($module[\"icon\"]).\"',$group,'$gbp','$extension')\");\n\t\t\t\t\t$module_id = sqlid();\n\t\t\t\t\t$bigtree[\"module_match\"][$module[\"id\"]] = $module_id;\n\t\t\t\t\t$bigtree[\"route_match\"][$module[\"route\"]] = $route;\n\t\t\t\t\t// Update the module ID since we're going to save this manifest locally for uninstalling\n\t\t\t\t\t$module[\"id\"] = $module_id;\n\t\t\t\n\t\t\t\t\t// Create the embed forms\n\t\t\t\t\tforeach ($module[\"embed_forms\"] as $form) {\n\t\t\t\t\t\t$this->createModuleEmbedForm($module_id,$form[\"title\"],$form[\"table\"],(is_array($form[\"fields\"]) ? $form[\"fields\"] : json_decode($form[\"fields\"],true)),$form[\"hooks\"],$form[\"default_position\"],$form[\"default_pending\"],$form[\"css\"],$form[\"redirect_url\"],$form[\"thank_you_message\"]);\n\t\t\t\t\t}\n\t\t\t\t\t// Create views\n\t\t\t\t\tforeach ($module[\"views\"] as $view) {\n\t\t\t\t\t\t$bigtree[\"view_id_match\"][$view[\"id\"]] = $this->createModuleView($module_id,$view[\"title\"],$view[\"description\"],$view[\"table\"],$view[\"type\"],(is_array($view[\"options\"]) ? $view[\"options\"] : json_decode($view[\"options\"],true)),(is_array($view[\"fields\"]) ? $view[\"fields\"] : json_decode($view[\"fields\"],true)),(is_array($view[\"actions\"]) ? $view[\"actions\"] : json_decode($view[\"actions\"],true)),$view[\"suffix\"],$view[\"preview_url\"]);\n\t\t\t\t\t}\n\t\t\t\t\t// Create regular forms\n\t\t\t\t\tforeach ($module[\"forms\"] as $form) {\n\t\t\t\t\t\t$bigtree[\"form_id_match\"][$form[\"id\"]] = $this->createModuleForm($module_id,$form[\"title\"],$form[\"table\"],(is_array($form[\"fields\"]) ? $form[\"fields\"] : json_decode($form[\"fields\"],true)),$form[\"hooks\"],$form[\"default_position\"],($form[\"return_view\"] ? $bigtree[\"view_id_match\"][$form[\"return_view\"]] : false),$form[\"return_url\"],$form[\"tagging\"]);\n\t\t\t\t\t}\n\t\t\t\t\t// Create reports\n\t\t\t\t\tforeach ($module[\"reports\"] as $report) {\n\t\t\t\t\t\t$bigtree[\"report_id_match\"][$report[\"id\"]] = $this->createModuleReport($module_id,$report[\"title\"],$report[\"table\"],$report[\"type\"],(is_array($report[\"filters\"]) ? $report[\"filters\"] : json_decode($report[\"filters\"],true)),(is_array($report[\"fields\"]) ? $report[\"fields\"] : json_decode($report[\"fields\"],true)),$report[\"parser\"],($report[\"view\"] ? $bigtree[\"view_id_match\"][$report[\"view\"]] : false));\n\t\t\t\t\t}\n\t\t\t\t\t// Create actions\n\t\t\t\t\tforeach ($module[\"actions\"] as $action) {\n\t\t\t\t\t\t$this->createModuleAction($module_id,$action[\"name\"],$action[\"route\"],$action[\"in_nav\"],$action[\"class\"],$bigtree[\"form_id_match\"][$action[\"form\"]],$bigtree[\"view_id_match\"][$action[\"view\"]],$bigtree[\"report_id_match\"][$action[\"report\"]],$action[\"level\"],$action[\"position\"]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import templates\n\t\t\tforeach ($manifest[\"components\"][\"templates\"] as $template) {\n\t\t\t\tif ($template) {\n\t\t\t\t\t$resources = sqlescape(is_array($template[\"resources\"]) ? BigTree::json($template[\"resources\"]) : $template[\"resources\"]);\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_templates (`id`,`name`,`module`,`resources`,`level`,`routed`,`extension`) VALUES ('\".sqlescape($template[\"id\"]).\"','\".sqlescape($template[\"name\"]).\"','\".$bigtree[\"module_match\"][$template[\"module\"]].\"','$resources','\".sqlescape($template[\"level\"]).\"','\".sqlescape($template[\"routed\"]).\"','$extension')\");\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import callouts\n\t\t\tforeach ($manifest[\"components\"][\"callouts\"] as $callout) {\n\t\t\t\tif ($callout) {\n\t\t\t\t\t$resources = sqlescape(is_array($callout[\"resources\"]) ? BigTree::json($callout[\"resources\"]) : $callout[\"resources\"]);\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_callouts (`id`,`name`,`description`,`display_default`,`display_field`,`resources`,`level`,`position`,`extension`) VALUES ('\".sqlescape($callout[\"id\"]).\"','\".sqlescape($callout[\"name\"]).\"','\".sqlescape($callout[\"description\"]).\"','\".sqlescape($callout[\"display_default\"]).\"','\".sqlescape($callout[\"display_field\"]).\"','$resources','\".sqlescape($callout[\"level\"]).\"','\".sqlescape($callout[\"position\"]).\"','$extension')\");\t\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import Settings\n\t\t\tforeach ($manifest[\"components\"][\"settings\"] as $setting) {\n\t\t\t\tif ($setting) {\n\t\t\t\t\t$this->createSetting($setting);\n\t\t\t\t\tsqlquery(\"UPDATE bigtree_settings SET extension = '$extension' WHERE id = '\".sqlescape($setting[\"id\"]).\"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import Feeds\n\t\t\tforeach ($manifest[\"components\"][\"feeds\"] as $feed) {\n\t\t\t\tif ($feed) {\n\t\t\t\t\t$fields = sqlescape(is_array($feed[\"fields\"]) ? BigTree::json($feed[\"fields\"]) : $feed[\"fields\"]);\n\t\t\t\t\t$options = sqlescape(is_array($feed[\"options\"]) ? BigTree::json($feed[\"options\"]) : $feed[\"options\"]);\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_feeds (`route`,`name`,`description`,`type`,`table`,`fields`,`options`,`extension`) VALUES ('\".sqlescape($feed[\"route\"]).\"','\".sqlescape($feed[\"name\"]).\"','\".sqlescape($feed[\"description\"]).\"','\".sqlescape($feed[\"type\"]).\"','\".sqlescape($feed[\"table\"]).\"','$fields','$options','$extension')\");\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t// Import Field Types\n\t\t\tforeach ($manifest[\"components\"][\"field_types\"] as $type) {\n\t\t\t\tif ($type) {\n\t\t\t\t\t$self_draw = $type[\"self_draw\"] ? \"'on'\" : \"NULL\";\n\t\t\t\t\t$use_cases = sqlescape(is_array($type[\"use_cases\"]) ? json_encode($type[\"use_cases\"]) : $type[\"use_cases\"]);\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_field_types (`id`,`name`,`use_cases`,`self_draw`,`extension`) VALUES ('\".sqlescape($type[\"id\"]).\"','\".sqlescape($type[\"name\"]).\"','$use_cases',$self_draw,'$extension')\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Upgrades don't drop tables, we run the SQL revisions instead\n\t\t\tif (is_array($upgrade)) {\n\t\t\t\t$old_revision = $upgrade[\"revision\"];\n\t\t\t\t$sql_revisions = $manifest[\"sql_revisions\"];\n\n\t\t\t\t// Go through all the SQL updates, we ksort first to ensure if the manifest somehow got out of order that we run the SQL update sequentially\n\t\t\t\tksort($sql_revisions);\n\t\t\t\tforeach ($sql_revisions as $key => $statements) {\n\t\t\t\t\tif ($key > $old_revision) {\n\t\t\t\t\t\tforeach ($statements as $sql_statement) {\n\t\t\t\t\t\t\tsqlquery($sql_statement);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Update the extension\n\t\t\t\tsqlquery(\"UPDATE bigtree_extensions SET name = '\".sqlescape($manifest[\"title\"]).\"', version = '\".sqlescape($manifest[\"version\"]).\"', last_updated = NOW(), manifest = '\".BigTree::json($manifest,true).\"' WHERE id = '\".sqlescape($manifest[\"id\"]).\"'\");\n\t\t\t\n\t\t\t// Straight installs move files into place locally\n\t\t\t} else {\n\t\t\t\t// Make sure destination doesn't exist\n\t\t\t\t$destination_path = SERVER_ROOT.\"extensions/\".$manifest[\"id\"].\"/\"; \n\t\t\t\tBigTree::deleteDirectory($destination_path);\n\n\t\t\t\t// Move the package to the extension directory\n\t\t\t\trename(SERVER_ROOT.\"cache/package/\",$destination_path);\n\t\t\t\tBigTree::setDirectoryPermissions($destination_path);\n\n\t\t\t\t// Create the extension\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_extensions (`id`,`type`,`name`,`version`,`last_updated`,`manifest`) VALUES ('\".sqlescape($manifest[\"id\"]).\"','extension','\".sqlescape($manifest[\"title\"]).\"','\".sqlescape($manifest[\"version\"]).\"',NOW(),'\".BigTree::json($manifest,true).\"')\");\t\n\t\t\t}\n\n\t\t\t// Re-enable foreign key checks\n\t\t\tsqlquery(\"SET foreign_key_checks = 1\");\n\n\t\t\t// Empty view cache\n\t\t\tsqlquery(\"DELETE FROM bigtree_module_view_cache\");\n\n\t\t\t// Move public files into the site directory\n\t\t\t$public_dir = SERVER_ROOT.\"extensions/\".$manifest[\"id\"].\"/public/\";\n\t\t\t$site_contents = file_exists($public_dir) ? BigTree::directoryContents($public_dir) : array();\n\t\t\tforeach ($site_contents as $file_path) {\n\t\t\t\t$destination_path = str_replace($public_dir,SITE_ROOT.\"extensions/\".$manifest[\"id\"].\"/\",$file_path);\n\t\t\t\tBigTree::copyFile($file_path,$destination_path);\n\t\t\t}\n\n\t\t\t// Clear module class cache and field type cache.\n\t\t\t@unlink(SERVER_ROOT.\"cache/bigtree-module-class-list.json\");\n\t\t\t@unlink(SERVER_ROOT.\"cache/bigtree-form-field-types.json\");\n\n\t\t\treturn $manifest;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: iplExists\n\t\t\t\tDetermines whether an internal page link still exists or not.\n\n\t\t\tParameters:\n\t\t\t\tipl - An internal page link\n\n\t\t\tReturns:\n\t\t\t\tTrue if it is still a valid link, otherwise false.\n\t\t*/\n\n\t\tstatic function iplExists($ipl) {\n\t\t\t$ipl = explode(\"//\",$ipl);\n\n\t\t\t// See if the page it references still exists.\n\t\t\t$nav_id = $ipl[1];\n\t\t\tif (!sqlrows(sqlquery(\"SELECT id FROM bigtree_pages WHERE id = '$nav_id'\"))) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Decode the commands attached to the page\n\t\t\t$commands = json_decode(base64_decode($ipl[2]),true);\n\t\t\t// If there are no commands, we're good.\n\t\t\tif (empty($commands[0])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// If it's a hash tag link, we're also good.\n\t\t\tif (substr($commands[0],0,1) == \"#\") {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Get template for the navigation id to see if it's a routed template\n\t\t\t$t = sqlfetch(sqlquery(\"SELECT bigtree_templates.routed FROM bigtree_templates JOIN bigtree_pages ON bigtree_templates.id = bigtree_pages.template WHERE bigtree_pages.id = '$nav_id'\"));\n\t\t\t// If we're a routed template, we're good.\n\t\t\tif ($t[\"routed\"]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// We may have been on a page, but there's extra routes that don't go anywhere or do anything so it's a 404.\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: irlExists\n\t\t\t\tDetermines whether an internal resource link still exists or not.\n\n\t\t\tParameters:\n\t\t\t\tirl - An internal resource link\n\n\t\t\tReturns:\n\t\t\t\tTrue if it is still a valid link, otherwise false.\n\t\t*/\n\n\t\tstatic function irlExists($irl) {\n\t\t\t$irl = explode(\"//\",$irl);\n\t\t\t$resource = static::getResource($irl[1]);\n\t\t\tif ($resource) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: lockCheck\n\t\t\t\tChecks if a lock exists.\n\t\t\t\tIf a lock exists and it's currently active, stops page execution and shows the lock page.\n\t\t\t\tIf a lock is yours, refreshes the lock.\n\t\t\t\tIf there is no lock, creates one for you.\n\n\t\t\tParameters:\n\t\t\t\ttable - The table to check.\n\t\t\t\tid - The id of the entry to check.\n\t\t\t\tinclude - The lock page to include (relative to /core/ or /custom/)\n\t\t\t\tforce - Whether to force through the lock or not.\n\t\t\t\tin_admin - Whether to call stop()\n\n\t\t\tReturns:\n\t\t\t\tYour lock id.\n\t\t*/\n\n\t\tfunction lockCheck($table,$id,$include,$force = false,$in_admin = true) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\t\t\t$table = sqlescape($table);\n\t\t\t$id = sqlescape($id);\n\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_locks WHERE `table` = '$table' AND item_id = '$id'\"));\n\t\t\tif ($f && $f[\"user\"] != $this->ID && strtotime($f[\"last_accessed\"]) > (time()-300) && !$force) {\n\t\t\t\t$locked_by = static::getUser($f[\"user\"]);\n\t\t\t\t$last_accessed = $f[\"last_accessed\"];\n\t\t\t\tinclude BigTree::path($include);\n\t\t\t\tif ($in_admin) {\n\t\t\t\t\t$this->stop();\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ($f) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_locks SET last_accessed = NOW(), user = '\".$this->ID.\"' WHERE id = '\".$f[\"id\"].\"'\");\n\t\t\t\treturn $f[\"id\"];\n\t\t\t} else {\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_locks (`table`,`item_id`,`user`,`title`) VALUES ('$table','$id','\".$this->ID.\"','Page')\");\n\t\t\t\treturn sqlid();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: login\n\t\t\t\tAttempts to login a user to the CMS.\n\n\t\t\tParameters:\n\t\t\t\temail - The email address of the user.\n\t\t\t\tpassword - The password of the user.\n\t\t\t\tstay_logged_in - Whether to set a cookie to keep the user logged in.\n\n\t\t\tReturns:\n\t\t\t\tfalse if login failed, otherwise redirects back to the page the person requested.\n\t\t*/\n\n\t\tstatic function login($email,$password,$stay_logged_in = false) {\n\t\t\tglobal $bigtree;\n\n\t\t\t// Check to see if this IP is already banned from logging in.\n\t\t\t$ip = ip2long($_SERVER[\"REMOTE_ADDR\"]);\n\t\t\t$ban = sqlfetch(sqlquery(\"SELECT * FROM bigtree_login_bans WHERE expires > NOW() AND ip = '$ip'\"));\n\t\t\t\n\t\t\tif ($ban) {\n\t\t\t\t$bigtree[\"ban_expiration\"] = date(\"F j, Y @ g:ia\",strtotime($ban[\"expires\"]));\n\t\t\t\t$bigtree[\"ban_is_user\"] = false;\n\t\t\t\t\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Get rid of whitespace and make the email lowercase for consistency\n\t\t\t$email = trim(strtolower($email));\n\t\t\t$password = trim($password);\n\t\t\t$user = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE LOWER(email) = '\".sqlescape($email).\"'\"));\n\n\t\t\t// See if this user is banned due to failed login attempts\n\t\t\t$ban = sqlfetch(sqlquery(\"SELECT * FROM bigtree_login_bans WHERE expires > NOW() AND `user` = '\".$user[\"id\"].\"'\"));\n\t\t\t\n\t\t\tif ($ban) {\n\t\t\t\t$bigtree[\"ban_expiration\"] = date(\"F j, Y @ g:ia\",strtotime($ban[\"expires\"]));\n\t\t\t\t$bigtree[\"ban_is_user\"] = true;\n\t\t\t\t\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], true);\n\t\t\t$ok = $phpass->CheckPassword($password, $user[\"password\"]);\n\t\t\t\n\t\t\tif ($ok) {\n\t\t\t\t// Generate a random CSRF token\n\t\t\t\t$csrf_token = base64_encode(openssl_random_pseudo_bytes(32));\n\t\t\t\t$csrf_token_field = \"__csrf_token_\".BigTree::randomString(32).\"__\";\n\t\t\t\t\n\t\t\t\t// Generate a random chain id\n\t\t\t\t$chain = uniqid(\"chain-\",true);\n\n\t\t\t\twhile (sqlrows(sqlquery(\"SELECT id FROM bigtree_user_sessions WHERE chain = '\".sqlescape($chain).\"'\"))) {\n\t\t\t\t\t$chain = uniqid(\"chain-\",true);\n\t\t\t\t}\n\n\t\t\t\t// Generate a random session id\n\t\t\t\t$session = uniqid(\"session-\",true);\n\n\t\t\t\twhile (sqlrows(sqlquery(\"SELECT id FROM bigtree_user_sessions WHERE id = '\".sqlescape($session).\"'\"))) {\n\t\t\t\t\t$session = uniqid(\"session-\",true);\n\t\t\t\t}\n\n\t\t\t\t// Create the new session chain\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_user_sessions (`id`,`chain`,`email`,`csrf_token`,`csrf_token_field`) VALUES ('\".sqlescape($session).\"','\".sqlescape($chain).\"','\".sqlescape($user[\"email\"]).\"','$csrf_token','$csrf_token_field')\");\n\t\t\t\t\n\t\t\t\tif (!empty($bigtree[\"config\"][\"sites\"]) && count($bigtree[\"config\"][\"sites\"])) {\n\t\t\t\t\t// Create another unique cache session for logins across domains\n\t\t\t\t\t$cache_data = array(\n\t\t\t\t\t\t\"user_id\" => $user[\"id\"],\n\t\t\t\t\t\t\"session\" => $session,\n\t\t\t\t\t\t\"chain\" => $chain,\n\t\t\t\t\t\t\"stay_logged_in\" => $stay_logged_in,\n\t\t\t\t\t\t\"login_redirect\" => isset($_SESSION[\"bigtree_login_redirect\"]) ? $_SESSION[\"bigtree_login_redirect\"] : false,\n\t\t\t\t\t\t\"remaining_sites\" => array(),\n\t\t\t\t\t\t\"csrf_token\" => $csrf_token,\n\t\t\t\t\t\t\"csrf_token_field\" => $csrf_token_field\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\tforeach ($bigtree[\"config\"][\"sites\"] as $site_key => $site_configuration) {\n\t\t\t\t\t\t$cache_data[\"remaining_sites\"][$site_key] = $site_configuration[\"www_root\"];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$cache_session_key = BigTreeCMS::cacheUnique(\"org.bigtreecms.login-session\", $cache_data);\n\t\t\t\t\t$next_site = array_shift(array_values($cache_data[\"remaining_sites\"]));\n\t\t\t\t\t\n\t\t\t\t\t// Start the login chain\n\t\t\t\t\tBigTree::redirect($next_site.\"?bigtree_login_redirect_session_key=\".$cache_session_key);\n\t\t\t\t} else {\n\t\t\t\t\t$cookie_domain = str_replace(DOMAIN,\"\",WWW_ROOT);\n\t\t\t\t\t$cookie_value = json_encode(array($session, $chain));\n\t\t\t\t\t\n\t\t\t\t\t// We still set the email for BigTree bar usage even if they're not being \"remembered\"\n\t\t\t\t\tsetcookie('bigtree_admin[email]', $user[\"email\"], strtotime(\"+1 month\"), $cookie_domain, \"\", false, true);\n\t\t\t\t\t\n\t\t\t\t\tif ($stay_logged_in) {\n\t\t\t\t\t\tsetcookie('bigtree_admin[login]', $cookie_value, strtotime(\"+1 month\"), $cookie_domain, \"\", false, true);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"id\"] = $user[\"id\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"email\"] = $user[\"email\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"level\"] = $user[\"level\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"name\"] = $user[\"name\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"permissions\"] = json_decode($user[\"permissions\"],true);\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token\"] = $csrf_token;\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token_field\"] = $csrf_token_field;\n\t\t\t\t\t\n\t\t\t\t\tif (isset($_SESSION[\"bigtree_login_redirect\"])) {\n\t\t\t\t\t\tBigTree::redirect($_SESSION[\"bigtree_login_redirect\"]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tBigTree::redirect(ADMIN_ROOT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Log it as a failed attempt for a user if the email address matched\n\t\t\t\tif ($user) {\n\t\t\t\t\t$user_id = \"'\".$user[\"id\"].\"'\";\n\t\t\t\t} else {\n\t\t\t\t\t$user_id = \"NULL\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_login_attempts (`ip`,`user`) VALUES ('$ip', $user_id)\");\n\n\t\t\t\t// See if this attempt earns the user a ban - first verify the policy is completely filled out (3 parts)\n\t\t\t\tif ($user[\"id\"] && count(array_filter((array)$bigtree[\"security-policy\"][\"user_fails\"])) == 3) {\n\t\t\t\t\t$p = $bigtree[\"security-policy\"][\"user_fails\"];\n\t\t\t\t\t$r = sqlrows(sqlquery(\"SELECT * FROM bigtree_login_attempts WHERE `user` = $user_id AND `timestamp` >= DATE_SUB(NOW(),INTERVAL \".$p[\"time\"].\" MINUTE)\"));\n\t\t\t\t\t\n\t\t\t\t\t// Earned a ban\n\t\t\t\t\tif ($r >= $p[\"count\"]) {\n\t\t\t\t\t\t// See if they have an existing ban that hasn't expired, if so, extend it\n\t\t\t\t\t\t$existing = sqlfetch(sqlquery(\"SELECT * FROM bigtree_login_bans WHERE `user` = $user_id AND expires >= NOW()\"));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ($existing) {\n\t\t\t\t\t\t\tsqlquery(\"UPDATE bigtree_login_bans SET expires = DATE_ADD(NOW(),INTERVAL \".$p[\"ban\"].\" MINUTE) WHERE id = '\".$existing[\"id\"].\"'\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_login_bans (`ip`,`user`,`expires`) VALUES ('$ip', $user_id, DATE_ADD(NOW(), INTERVAL \".$p[\"ban\"].\" MINUTE))\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$bigtree[\"ban_expiration\"] = date(\"F j, Y @ g:ia\",strtotime(\"+\".$p[\"ban\"].\" minutes\"));\n\t\t\t\t\t\t$bigtree[\"ban_is_user\"] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// See if this attempt earns the IP as a whole a ban - first verify the policy is completely filled out (3 parts)\n\t\t\t\tif (count(array_filter((array)$bigtree[\"security-policy\"][\"ip_fails\"])) == 3) {\n\t\t\t\t\t$p = $bigtree[\"security-policy\"][\"ip_fails\"];\n\t\t\t\t\t$r = sqlrows(sqlquery(\"SELECT * FROM bigtree_login_attempts WHERE `ip` = '$ip' AND `timestamp` >= DATE_SUB(NOW(),INTERVAL \".$p[\"time\"].\" MINUTE)\"));\n\t\t\t\t\t\n\t\t\t\t\t// Earned a ban\n\t\t\t\t\tif ($r >= $p[\"count\"]) {\n\t\t\t\t\t\t$existing = sqlfetch(sqlquery(\"SELECT * FROM bigtree_login_bans WHERE `ip` = '$ip' AND expires >= NOW()\"));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ($existing) {\n\t\t\t\t\t\t\tsqlquery(\"UPDATE bigtree_login_bans SET expires = DATE_ADD(NOW(),INTERVAL \".$p[\"ban\"].\" HOUR) WHERE id = '\".$existing[\"id\"].\"'\");\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_login_bans (`ip`,`expires`) VALUES ('$ip',DATE_ADD(NOW(),INTERVAL \".$p[\"ban\"].\" HOUR))\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$bigtree[\"ban_expiration\"] = date(\"F j, Y @ g:ia\", strtotime(\"+\".$p[\"ban\"].\" hours\"));\n\t\t\t\t\t\t$bigtree[\"ban_is_user\"] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tstatic function loginSession($session_key) {\n\t\t\t$cache_data = BigTreeCMS::cacheGet(\"org.bigtreecms.login-session\", $session_key);\n\t\t\t$user = sqlfetch(sqlquery(\"SELECT * FROM bigtree_users WHERE id = '\".$cache_data[\"user_id\"].\"'\"));\n\t\t\t\n\t\t\tforeach ($cache_data[\"remaining_sites\"] as $site_key => $www_root) {\n\t\t\t\tif ($site_key == BIGTREE_SITE_KEY) {\n\t\t\t\t\t$cookie_domain = str_replace(DOMAIN, \"\", WWW_ROOT);\n\t\t\t\t\t$cookie_value = json_encode(array($cache_data[\"session\"], $cache_data[\"chain\"]));\n\n\t\t\t\t\t// We still set the email for BigTree bar usage even if they're not being \"remembered\"\n\t\t\t\t\tsetcookie('bigtree_admin[email]', $user[\"email\"], strtotime(\"+1 month\"), $cookie_domain, \"\", false, true);\n\t\t\t\t\t\n\t\t\t\t\tif ($cache_data[\"stay_logged_in\"]) {\n\t\t\t\t\t\tsetcookie('bigtree_admin[login]', $cookie_value, strtotime(\"+1 month\"), $cookie_domain, \"\", false, true);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"id\"] = $user[\"id\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"email\"] = $user[\"email\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"level\"] = $user[\"level\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"name\"] = $user[\"name\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"permissions\"] = json_decode($user[\"permissions\"], true);\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token\"] = $cache_data[\"csrf_token\"];\n\t\t\t\t\t$_SESSION[\"bigtree_admin\"][\"csrf_token_field\"] = $cache_data[\"csrf_token_field\"];\n\t\t\t\t\t\n\t\t\t\t\tunset($cache_data[\"remaining_sites\"][$site_key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (count($cache_data[\"remaining_sites\"]) == 0) {\n\t\t\t\t// Done logging in, delete session\n\t\t\t\tBigTreeCMS::cacheDelete(\"org.bigtreecms.login-session\", $session_key);\n\t\t\t\t\n\t\t\t\tif (!empty($cache_data[\"login_redirect\"])) {\n\t\t\t\t\tBigTree::redirect($cache_data[\"login_redirect\"]);\n\t\t\t\t} else {\n\t\t\t\t\tBigTree::redirect(ADMIN_ROOT);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$next_site = array_shift(array_values($cache_data[\"remaining_sites\"]));\n\t\t\t\tBigTreeCMS::cachePut(\"org.bigtreecms.login-session\", $session_key, $cache_data);\n\t\t\t\t\n\t\t\t\t// Redirect to the next site that needs a session/cookie\n\t\t\t\tBigTree::redirect($next_site.\"?bigtree_login_redirect_session_key=\".$session_key);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: logout\n\t\t\t\tLogs out of the CMS.\n\t\t\t\tDestroys the user's session and unsets the login cookies, then sends the user back to the login page.\n\t\t*/\n\n\t\tstatic function logout() {\n\t\t\t// If the user asked to be remembered, drop their chain from the legit sessions and remove cookies\n\t\t\tif (!empty($_COOKIE[\"bigtree_admin\"][\"login\"])) {\n\t\t\t\tlist($session,$chain) = json_decode($_COOKIE[\"bigtree_admin\"][\"login\"], true);\n\n\t\t\t\t// Make sure this session/chain is legit before removing everything with the given chain\n\t\t\t\t$chain = sqlescape($chain);\n\t\t\t\t$session = sqlescape($session);\n\n\t\t\t\tif (sqlrows(sqlquery(\"SELECT * FROM bigtree_user_sessions WHERE id = '$session' AND chain = '$chain'\"))) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_user_sessions WHERE chain = '$chain'\");\n\t\t\t\t}\n\n\t\t\t\tsetcookie(\"bigtree_admin[email]\",\"\",time()-3600,str_replace(DOMAIN,\"\",WWW_ROOT));\n\t\t\t\tsetcookie(\"bigtree_admin[login]\",\"\",time()-3600,str_replace(DOMAIN,\"\",WWW_ROOT));\n\t\t\t}\n\n\t\t\tunset($_COOKIE[\"bigtree_admin\"]);\n\t\t\tunset($_SESSION[\"bigtree_admin\"]);\n\n\t\t\tBigTree::redirect(ADMIN_ROOT);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: makeIPL\n\t\t\t\tCreates an internal page link out of a URL.\n\n\t\t\tParameters:\n\t\t\t\turl - A URL\n\n\t\t\tReturns:\n\t\t\t\tAn internal page link (if possible) or just the same URL (if it's not internal).\n\t\t*/\n\n\t\tstatic function makeIPL($url) {\n\t\t\t$path_components = explode(\"/\", rtrim(str_replace(WWW_ROOT, \"\", $url), \"/\"));\n\t\t\t\n\t\t\t// See if this is a file\n\t\t\t$local_path = str_replace(WWW_ROOT,SITE_ROOT,$url);\n\t\t\t\n\t\t\tif (($path_components[0] != \"files\" || $path_components[1] != \"resources\") && \n\t\t\t\t(substr($local_path,0,1) == \"/\" || substr($local_path,0,2) == \"\\\\\\\\\") && \n\t\t\t\tfile_exists($local_path)) {\n\t\t\t\t\n\t\t\t\treturn BigTreeCMS::replaceHardRoots($url);\n\t\t\t}\n\n\t\t\t// If we have multiple sites, try each domain\n\t\t\tif (defined(\"BIGTREE_SITE_KEY\")) {\n\t\t\t\tglobal $bigtree;\n\t\t\t\t\n\t\t\t\tforeach ($bigtree[\"config\"][\"sites\"] as $site_key => $configuration) {\n\t\t\t\t\t// This is the site we're pointing to\n\t\t\t\t\tif (strpos($url, $configuration[\"www_root\"]) !== false) {\n\t\t\t\t\t\t$path_components = explode(\"/\", rtrim(str_replace($configuration[\"www_root\"], \"\", $url), \"/\"));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Check for resource link\n\t\t\t\t\t\tif ($path_components[0] == \"files\" && $path_components[1] == \"resources\") {\n\t\t\t\t\t\t\t$resource = static::getResourceByFile($url);\n\n\t\t\t\t\t\t\tif ($resource) {\n\t\t\t\t\t\t\t\tstatic::$IRLsCreated[] = $resource[\"id\"];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\treturn \"irl://\".$resource[\"id\"].\"//\".$resource[\"prefix\"];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the root path of the site for calculating an IPL and add it to the path components\n\t\t\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT path FROM bigtree_pages WHERE id = '\".$configuration[\"trunk\"].\"'\"));\n\t\t\t\t\t\t$path_components = array_filter(array_merge(explode(\"/\", $f[\"path\"]), $path_components));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Check for page link\n\t\t\t\t\t\tlist($navid, $commands) = static::getPageIDForPath($path_components);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ($navid) {\n\t\t\t\t\t\t\treturn \"ipl://\".$navid.\"//\".base64_encode(json_encode($commands));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn BigTreeCMS::replaceHardRoots($url);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn BigTreeCMS::replaceHardRoots($url);\n\t\t\t} else {\n\t\t\t\t// Check for resource link\n\t\t\t\tif ($path_components[0] == \"files\" && $path_components[1] == \"resources\") {\n\t\t\t\t\t$resource = static::getResourceByFile($url);\n\t\t\t\t\tif ($resource) {\n\t\t\t\t\t\tstatic::$IRLsCreated[] = $resource[\"id\"];\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn \"irl://\".$resource[\"id\"].\"//\".$resource[\"prefix\"];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check for page link\n\t\t\t\tlist($navid, $commands) = static::getPageIDForPath($path_components);\n\t\t\t}\n\t\t\t\n\t\t\tif (!$navid) {\n\t\t\t\treturn BigTreeCMS::replaceHardRoots($url);\n\t\t\t}\n\t\t\t\n\t\t\treturn \"ipl://\".$navid.\"//\".base64_encode(json_encode($commands));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: markMessageRead\n\t\t\t\tMarks a message as read by the currently logged in user.\n\n\t\t\tParameters:\n\t\t\t\tid - The message id.\n\t\t*/\n\n\t\tfunction markMessageRead($id) {\n\t\t\t$message = $this->getMessage($id);\n\t\t\tif (!$message) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$read_by = str_replace(\"|\".$this->ID.\"|\",\"\",$message[\"read_by\"]).\"|\".$this->ID.\"|\";\n\t\t\tsqlquery(\"UPDATE bigtree_messages SET read_by = '\".sqlescape($read_by).\"' WHERE id = '\".$message[\"id\"].\"'\");\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: matchResourceMD5\n\t\t\t\tChecks if the given file is a MD5 match for any existing resources.\n\t\t\t\tIf a match is found, the resource is \"copied\" into the given folder (unless it already exists in that folder).\n\n\t\t\tParameters:\n\t\t\t\tfile - Uploaded file to run MD5 hash on\n\t\t\t\tnew_folder - Folder the given file is being uploaded into\n\n\t\t\tReturns:\n\t\t\t\ttrue if a match was found. If the file was already in the given folder, the date is simply updated.\n\t\t*/\n\n\t\tstatic function matchResourceMD5($file,$new_folder) {\n\t\t\t$md5 = sqlescape(md5_file($file));\n\t\t\t$resource = sqlfetch(sqlquery(\"SELECT * FROM bigtree_resources WHERE md5 = '$md5' LIMIT 1\"));\n\t\t\tif (!$resource) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If we already have this exact resource in this exact folder, just update its modification time\n\t\t\tif ($resource[\"folder\"] == $new_folder) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_resources SET date = NOW() WHERE id = '\".$resource[\"id\"].\"'\");\n\t\t\t} else {\n\t\t\t\tforeach ($resource as $key => $val) {\n\t\t\t\t\t$$key = \"'\".sqlescape($val).\"'\";\n\t\t\t\t}\n\t\t\t\t$new_folder = $new_folder ? \"'\".sqlescape($new_folder).\"'\" : \"NULL\";\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_resources (`folder`,`file`,`md5`,`date`,`name`,`type`,`is_image`,`height`,`width`,`crops`,`thumbs`,`list_thumb_margin`) VALUES ($new_folder,$file,$md5,NOW(),$name,$type,$is_image,$height,$width,$crops,$thumbs,$list_thumb_margin)\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: pageChangeExists\n\t\t\t\tReturns whether pending changes exist for a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\n\t\t\tReturns:\n\t\t\t\ttrue or false\n\t\t*/\n\n\t\tstatic function pageChangeExists($page) {\n\t\t\t$page = sqlescape($page);\n\t\t\t$c = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND item_id = '$page'\"));\n\t\t\tif (!$c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: pingSearchEngines\n\t\t\t\tSends the latest sitemap.xml out to search engine ping services if enabled in settings.\n\t\t*/\n\n\t\tstatic function pingSearchEngines() {\n\t\t\t$setting = static::getSetting(\"ping-search-engines\");\n\t\t\tif ($setting[\"value\"] == \"on\") {\n\t\t\t\t// Google\n\t\t\t\tfile_get_contents(\"http://www.google.com/webmasters/tools/ping?sitemap=\".urlencode(WWW_ROOT.\"sitemap.xml\"));\n\t\t\t\t// Bing\n\t\t\t\tfile_get_contents(\"http://www.bing.com/webmaster/ping.aspx?siteMap=\".urlencode(WWW_ROOT.\"sitemap.xml\"));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: processCrops\n\t\t\t\tProcesses a list of cropped images.\n\n\t\t\tParameters:\n\t\t\t\tcrop_key - A cache key pointing to the location of crop data.\n\t\t*/\n\n\t\tstatic function processCrops($crop_key) {\n\t\t\t$storage = new BigTreeStorage;\n\n\t\t\t// Get and remove the crop data\n\t\t\t$crops = BigTreeCMS::cacheGet(\"org.bigtreecms.crops\",$crop_key);\n\t\t\tBigTreeCMS::cacheDelete(\"org.bigtreecms.crops\",$crop_key);\n\n\t\t\tforeach ($crops as $key => $crop) {\n\t\t\t\t$image_src = $crop[\"image\"];\n\t\t\t\t$target_width = $crop[\"width\"];\n\t\t\t\t$target_height = $crop[\"height\"];\n\t\t\t\t$x = $_POST[\"x\"][$key];\n\t\t\t\t$y = $_POST[\"y\"][$key];\n\t\t\t\t$width = $_POST[\"width\"][$key];\n\t\t\t\t$height = $_POST[\"height\"][$key];\n\t\t\t\t$thumbs = $crop[\"thumbs\"];\n\t\t\t\t$center_crops = $crop[\"center_crops\"];\n\n\t\t\t\t$pinfo = pathinfo($image_src);\n\n\t\t\t\t// Create the crop and put it in a temporary location\n\t\t\t\t$temp_crop = SITE_ROOT.\"files/\".uniqid(\"temp-\").\".\".$pinfo[\"extension\"];\n\t\t\t\tBigTree::createCrop($image_src,$temp_crop,$x,$y,$target_width,$target_height,$width,$height,$crop[\"retina\"],$crop[\"grayscale\"]);\n\t\t\t\t\n\t\t\t\t// Make thumbnails for the crop\n\t\t\t\tif (is_array($thumbs)) {\n\t\t\t\t\tforeach ($thumbs as $thumb) {\n\t\t\t\t\t\tif (is_array($thumb) && ($thumb[\"height\"] || $thumb[\"width\"])) {\n\t\t\t\t\t\t\t// We're going to figure out what size the thumbs will be so we can re-crop the original image so we don't lose image quality.\n\t\t\t\t\t\t\tlist($type,$w,$h,$result_width,$result_height) = BigTree::getThumbnailSizes($temp_crop,$thumb[\"width\"],$thumb[\"height\"]);\n\n\t\t\t\t\t\t\t$temp_thumb = SITE_ROOT.\"files/\".uniqid(\"temp-\").\".\".$pinfo[\"extension\"];\n\t\t\t\t\t\t\tBigTree::createCrop($image_src,$temp_thumb,$x,$y,$result_width,$result_height,$width,$height,$crop[\"retina\"],$thumb[\"grayscale\"]);\n\t\t\t\t\t\t\t$storage->replace($temp_thumb,$thumb[\"prefix\"].$crop[\"name\"],$crop[\"directory\"]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Make center crops of the crop\n\t\t\t\tif (is_array($center_crops)) {\n\t\t\t\t\tforeach ($center_crops as $center_crop) {\n\t\t\t\t\t\tif (is_array($center_crop) && $center_crop[\"height\"] && $center_crop[\"width\"]) {\n\t\t\t\t\t\t\t$temp_center_crop = SITE_ROOT.\"files/\".uniqid(\"temp-\").\".\".$pinfo[\"extension\"];\n\t\t\t\t\t\t\tBigTree::centerCrop($temp_crop,$temp_center_crop,$center_crop[\"width\"],$center_crop[\"height\"],$crop[\"retina\"],$center_crop[\"grayscale\"]);\n\t\t\t\t\t\t\t$storage->replace($temp_center_crop,$center_crop[\"prefix\"].$crop[\"name\"],$crop[\"directory\"]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Move crop into its resting place\n\t\t\t\t$storage->replace($temp_crop,$crop[\"prefix\"].$crop[\"name\"],$crop[\"directory\"]);\n\t\t\t}\n\n\t\t\t// Remove all the temporary images\n\t\t\tforeach ($crops as $crop) {\n\t\t\t\t@unlink($crop[\"image\"]);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: processField\n\t\t\t\tA helper function for field type processing.\n\n\t\t\tParameters:\n\t\t\t\tfield - Field information\n\n\t\t\tReturns:\n\t\t\t\tField output.\n\t\t*/\n\n\t\tstatic function processField($field) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\n\t\t\t// Save current context\n\t\t\t$bigtree[\"saved_extension_context\"] = $bigtree[\"extension_context\"];\n\n\t\t\t// Check if the field type is stored in an extension\n\t\t\tif (strpos($field[\"type\"],\"*\") !== false) {\n\t\t\t\tlist($extension,$field_type) = explode(\"*\",$field[\"type\"]);\n\n\t\t\t\t$bigtree[\"extension_context\"] = $extension;\n\t\t\t\t$field_type_path = SERVER_ROOT.\"extensions/$extension/field-types/$field_type/process.php\";\n\t\t\t} else {\n\t\t\t\t$field_type_path = BigTree::path(\"admin/form-field-types/process/\".$field[\"type\"].\".php\");\n\t\t\t}\n\n\t\t\t// If we have a customized handler for this data type, run it.\n\t\t\tif (file_exists($field_type_path)) {\n\t\t\t\tinclude $field_type_path;\n\n\t\t\t\t// If it's explicitly ignored return null\n\t\t\t\tif ($field[\"ignore\"]) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t$output = $field[\"output\"];\n\t\t\t\t}\n\n\t\t\t// Fall back to default handling\n\t\t\t} else {\n\t\t\t\tif (is_array($field[\"input\"])) {\n\t\t\t\t\t$output = $field[\"input\"];\n\t\t\t\t} else {\n\t\t\t\t\t$output = BigTree::safeEncode($field[\"input\"]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check validation\n\t\t\tif (!BigTreeAutoModule::validate($output,$field[\"options\"][\"validation\"])) {\n\t\t\t\t$error = $field[\"options\"][\"error_message\"] ? $field[\"options\"][\"error_message\"] : BigTreeAutoModule::validationErrorMessage($output,$field[\"options\"][\"validation\"]);\n\t\t\t\t$bigtree[\"errors\"][] = array(\n\t\t\t\t\t\"field\" => $field[\"title\"],\n\t\t\t\t\t\"error\" => $error\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Translation of internal links\n\t\t\tif (is_array($output)) {\n\t\t\t\t$output = BigTree::translateArray($output);\n\t\t\t} else {\n\t\t\t\t$output = $admin->autoIPL($output);\n\t\t\t}\n\n\t\t\t// Restore context\n\t\t\t$bigtree[\"extension_context\"] = $bigtree[\"saved_extension_context\"];\n\n\t\t\treturn $output;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: processImageUpload\n\t\t\t\tProcesses image upload data for form fields.\n\t\t\t\tIf you're emulating field information, the following keys are of interest in the field array:\n\t\t\t\t\"file_input\" - a keyed array that needs at least \"name\" and \"tmp_name\" keys that contain the desired name of the file and the source file location, respectively.\n\t\t\t\t\"options\" - a keyed array of options for the field, keys of interest for photo processing are:\n\t\t\t\t\t\"min_height\" - Minimum Height required for the image\n\t\t\t\t\t\"min_width\" - Minimum Width required for the image\n\t\t\t\t\t\"retina\" - Whether to try to create a 2x size image when thumbnailing / cropping (if the source file / crop is large enough)\n\t\t\t\t\t\"thumbs\" - An array of thumbnail arrays, each of which has \"prefix\", \"width\", \"height\", and \"grayscale\" keys (prefix is prepended to the file name when creating the thumbnail, grayscale will make the thumbnail grayscale)\n\t\t\t\t\t\"crops\" - An array of crop arrays, each of which has \"prefix\", \"width\", \"height\" and \"grayscale\" keys (prefix is prepended to the file name when creating the crop, grayscale will make the thumbnail grayscale)). Crops can also have their own \"thumbs\" key that creates thumbnails of each crop (format mirrors that of \"thumbs\")\n\n\t\t\tParameters:\n\t\t\t\tfield - Field information (normally set to $field when running a field type's process file)\n\t\t*/\n\n\t\tstatic function processImageUpload($field) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$failed = false;\n\t\t\t$name = $field[\"file_input\"][\"name\"];\n\t\t\t$temp_name = $field[\"file_input\"][\"tmp_name\"];\n\t\t\t$error = $field[\"file_input\"][\"error\"];\n\n\t\t\t// If a file upload error occurred, return the old image and set errors\n\t\t\tif ($error == 1 || $error == 2) {\n\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"The file you uploaded ($name) was too large &mdash; <strong>Max file size: \".ini_get(\"upload_max_filesize\").\"</strong>\");\n\t\t\t\treturn false;\n\t\t\t} elseif ($error == 3) {\n\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"The file upload failed ($name).\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// We're going to tell BigTreeStorage to handle forcing images into JPEGs instead of writing the code 20x\n\t\t\t$storage = new BigTreeStorage;\n\t\t\t$storage->AutoJPEG = $bigtree[\"config\"][\"image_force_jpeg\"];\n\n\t\t\t// Let's check the minimum requirements for the image first before we store it anywhere.\n\t\t\t$image_info = @getimagesize($temp_name);\n\t\t\t$iwidth = $image_info[0];\n\t\t\t$iheight = $image_info[1];\n\t\t\t$itype = $image_info[2];\n\t\t\t$channels = $image_info[\"channels\"];\n\n\t\t\t// See if we're using image presets\n\t\t\tif ($field[\"options\"][\"preset\"]) {\n\t\t\t\t$media_settings = BigTreeCMS::getSetting(\"bigtree-internal-media-settings\");\n\t\t\t\t$preset = $media_settings[\"presets\"][$field[\"options\"][\"preset\"]];\n\t\t\t\t// If the preset still exists, copy its properties over to our options\n\t\t\t\tif ($preset) {\n\t\t\t\t\tforeach ($preset as $key => $val) {\n\t\t\t\t\t\t$field[\"options\"][$key] = $val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the minimum height or width is not meant, do NOT let the image through. Erase the change or update from the database.\n\t\t\tif ((isset($field[\"options\"][\"min_height\"]) && $iheight < $field[\"options\"][\"min_height\"]) || (isset($field[\"options\"][\"min_width\"]) && $iwidth < $field[\"options\"][\"min_width\"])) {\n\t\t\t\t$error = \"Image uploaded (\".htmlspecialchars($name).\") did not meet the minimum size of \";\n\t\t\t\tif ($field[\"options\"][\"min_height\"] && $field[\"options\"][\"min_width\"]) {\n\t\t\t\t\t$error .= $field[\"options\"][\"min_width\"].\"x\".$field[\"options\"][\"min_height\"].\" pixels.\";\n\t\t\t\t} elseif ($field[\"options\"][\"min_height\"]) {\n\t\t\t\t\t$error .= $field[\"options\"][\"min_height\"].\" pixels tall.\";\n\t\t\t\t} elseif ($field[\"options\"][\"min_width\"]) {\n\t\t\t\t\t$error .= $field[\"options\"][\"min_width\"].\" pixels wide.\";\n\t\t\t\t}\n\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => $error);\n\t\t\t\t$failed = true;\n\t\t\t}\n\n\t\t\t// If it's not a valid image, throw it out!\n\t\t\tif ($itype != IMAGETYPE_GIF && $itype != IMAGETYPE_JPEG && $itype != IMAGETYPE_PNG) {\n\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"An invalid file was uploaded. Valid file types: JPG, GIF, PNG.\");\n\t\t\t\t$failed = true;\n\t\t\t}\n\n\t\t\t// See if it's CMYK\n\t\t\tif ($channels == 4) {\n\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"A CMYK encoded file was uploaded. Please upload an RBG image.\");\n\t\t\t\t$failed = true;\n\t\t\t}\n\n\t\t\t// See if we have enough memory for all our crops and thumbnails\n\t\t\tif (!$failed && ((is_array($field[\"options\"][\"crops\"]) && count($field[\"options\"][\"crops\"])) || (is_array($field[\"options\"][\"thumbs\"]) && count($field[\"options\"][\"thumbs\"])))) {\n\t\t\t\tif (is_array($field[\"options\"][\"crops\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"crops\"] as $crop) {\n\t\t\t\t\t\tif (!$failed && is_array($crop) && array_filter($crop)) {\n\t\t\t\t\t\t\tif ($field[\"options\"][\"retina\"]) {\n\t\t\t\t\t\t\t\t$crop[\"width\"] *= 2;\n\t\t\t\t\t\t\t\t$crop[\"height\"] *= 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// We don't want to add multiple errors so we check if we've already failed\n\t\t\t\t\t\t\tif (!BigTree::imageManipulationMemoryAvailable($temp_name,$crop[\"width\"],$crop[\"height\"],$iwidth,$iheight)) {\n\t\t\t\t\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"Image uploaded is too large for the server to manipulate. Please upload a smaller version of this image.\");\n\t\t\t\t\t\t\t\t$failed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (is_array($field[\"options\"][\"thumbs\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"thumbs\"] as $thumb) {\n\t\t\t\t\t\t// We don't want to add multiple errors and we also don't want to waste effort getting thumbnail sizes if we already failed.\n\t\t\t\t\t\tif (!$failed && is_array($thumb) && array_filter($thumb)) {\n\t\t\t\t\t\t\tif ($field[\"options\"][\"retina\"]) {\n\t\t\t\t\t\t\t\t$thumb[\"width\"] *= 2;\n\t\t\t\t\t\t\t\t$thumb[\"height\"] *= 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$sizes = BigTree::getThumbnailSizes($temp_name,$thumb[\"width\"],$thumb[\"height\"]);\n\t\t\t\t\t\t\tif (!BigTree::imageManipulationMemoryAvailable($temp_name,$sizes[3],$sizes[4],$iwidth,$iheight)) {\n\t\t\t\t\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"Image uploaded is too large for the server to manipulate. Please upload a smaller version of this image.\");\n\t\t\t\t\t\t\t\t$failed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (is_array($field[\"options\"][\"center_crops\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"center_crops\"] as $crop) {\n\t\t\t\t\t\t// We don't want to add multiple errors and we also don't want to waste effort getting thumbnail sizes if we already failed.\n\t\t\t\t\t\tif (!$failed && is_array($crop) && array_filter($crop)) {\n\t\t\t\t\t\t\tlist($w,$h) = getimagesize($temp_name);\n\t\t\t\t\t\t\tif (!BigTree::imageManipulationMemoryAvailable($temp_name,$w,$h,$crop[\"width\"],$crop[\"height\"])) {\n\t\t\t\t\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"Image uploaded is too large for the server to manipulate. Please upload a smaller version of this image.\");\n\t\t\t\t\t\t\t\t$failed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$failed) {\n\t\t\t\t// Make a temporary copy to be used for thumbnails and crops.\n\t\t\t\t$itype_exts = array(IMAGETYPE_PNG => \".png\", IMAGETYPE_JPEG => \".jpg\", IMAGETYPE_GIF => \".gif\");\n\n\t\t\t\t// Make a first copy\n\t\t\t\t$first_copy = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\tBigTree::moveFile($temp_name,$first_copy);\n\n\t\t\t\t// Do EXIF Image Rotation\n\t\t\t\tif ($itype == IMAGETYPE_JPEG && function_exists(\"exif_read_data\")) {\n\t\t\t\t\t$exif = @exif_read_data($first_copy);\n\t\t\t\t\t$o = $exif['Orientation'];\n\t\t\t\t\tif ($o == 3 || $o == 6 || $o == 8) {\n\t\t\t\t\t\t$source = imagecreatefromjpeg($first_copy);\n\n\t\t\t\t\t\tif ($o == 3) {\n\t\t\t\t\t\t\t$source = imagerotate($source,180,0);\n\t\t\t\t\t\t} elseif ($o == 6) {\n\t\t\t\t\t\t\t$source = imagerotate($source,270,0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$source = imagerotate($source,90,0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We're going to create a PNG so that we don't lose quality when we resave\n\t\t\t\t\t\timagepng($source,$first_copy);\n\t\t\t\t\t\trename($first_copy,substr($first_copy,0,-3).\"png\");\n\t\t\t\t\t\t$first_copy = substr($first_copy,0,-3).\"png\";\n\n\t\t\t\t\t\t// Force JPEG since we made the first copy a PNG\n\t\t\t\t\t\t$storage->AutoJPEG = true;\n\n\t\t\t\t\t\t// Clean up memory\n\t\t\t\t\t\timagedestroy($source);\n\n\t\t\t\t\t\t// Get new width/height/type\n\t\t\t\t\t\tlist($iwidth,$iheight,$itype,$iattr) = getimagesize($first_copy);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create a temporary copy that we will use later for crops and thumbnails\n\t\t\t\t$temp_copy = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\tBigTree::copyFile($first_copy,$temp_copy);\n\n\t\t\t\t// Gather up an array of file prefixes\n\t\t\t\t$prefixes = array();\n\t\t\t\tif (is_array($field[\"options\"][\"thumbs\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"thumbs\"] as $thumb) {\n\t\t\t\t\t\tif (!empty($thumb[\"prefix\"])) {\n\t\t\t\t\t\t\t$prefixes[] = $thumb[\"prefix\"];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (is_array($field[\"options\"][\"center_crops\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"center_crops\"] as $crop) {\n\t\t\t\t\t\tif (!empty($crop[\"prefix\"])) {\n\t\t\t\t\t\t\t$prefixes[] = $crop[\"prefix\"];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (is_array($field[\"options\"][\"crops\"])) {\n\t\t\t\t\tforeach ($field[\"options\"][\"crops\"] as $crop) {\n\t\t\t\t\t\tif (is_array($crop)) {\n\t\t\t\t\t\t\tif (!empty($crop[\"prefix\"])) {\n\t\t\t\t\t\t\t\t$prefixes[] = $crop[\"prefix\"];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (is_array($crop[\"thumbs\"])) {\n\t\t\t\t\t\t\t\tforeach ($crop[\"thumbs\"] as $thumb) {\n\t\t\t\t\t\t\t\t\tif (!empty($thumb[\"prefix\"])) {\n\t\t\t\t\t\t\t\t\t\t$prefixes[] = $thumb[\"prefix\"];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (is_array($crop[\"center_crops\"])) {\n\t\t\t\t\t\t\t\tforeach ($crop[\"center_crops\"] as $center_crop) {\n\t\t\t\t\t\t\t\t\tif (!empty($center_crop[\"prefix\"])) {\n\t\t\t\t\t\t\t\t\t\t$prefixes[] = $center_crop[\"prefix\"];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Upload the original to the proper place.\n\t\t\t\t$field[\"output\"] = $storage->store($first_copy,$name,$field[\"options\"][\"directory\"],true,$prefixes);\n\n \t\t\t\t// If the upload service didn't return a value, we failed to upload it for one reason or another.\n \t\t\t\tif (!$field[\"output\"]) {\n \t\t\t\t\tif ($storage->DisabledFileError) {\n\t\t\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"Could not upload file. The file extension is not allowed.\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$bigtree[\"errors\"][] = array(\"field\" => $field[\"title\"], \"error\" => \"Could not upload file. The destination is not writable.\");\n\t\t\t\t\t}\n\t\t\t\t\tunlink($temp_copy);\n\t\t\t\t\tunlink($first_copy);\n\n\t\t\t\t\t// Failed, we keep the current value\n\t\t\t\t\treturn false;\n\t\t\t\t// If we did upload it successfully, check on thumbs and crops.\n\t\t\t\t} else {\n\t\t\t\t\t// Get path info on the file.\n\t\t\t\t\t$pinfo = BigTree::pathInfo($field[\"output\"]);\n\n\t\t\t\t\t// Handle Crops\n\t\t\t\t\tif (is_array($field[\"options\"][\"crops\"])) {\n\t\t\t\t\t\tforeach ($field[\"options\"][\"crops\"] as $crop) {\n\t\t\t\t\t\t\tif (is_array($crop)) {\n\t\t\t\t\t\t\t\t// Make sure the crops have a width/height and it's numeric\n\t\t\t\t\t\t\t\tif ($crop[\"width\"] && $crop[\"height\"] && is_numeric($crop[\"width\"]) && is_numeric($crop[\"height\"])) {\n\t\t\t\t\t\t\t\t\t$cwidth = $crop[\"width\"];\n\t\t\t\t\t\t\t\t\t$cheight = $crop[\"height\"];\n\t\t\n\t\t\t\t\t\t\t\t\t// Check to make sure each dimension is greater then or equal to, but not both equal to the crop.\n\t\t\t\t\t\t\t\t\tif (($iheight >= $cheight && $iwidth > $cwidth) || ($iwidth >= $cwidth && $iheight > $cheight)) {\n\t\t\t\t\t\t\t\t\t\t// Make a square if for some reason someone only entered one dimension for a crop.\n\t\t\t\t\t\t\t\t\t\tif (!$cwidth) {\n\t\t\t\t\t\t\t\t\t\t\t$cwidth = $cheight;\n\t\t\t\t\t\t\t\t\t\t} elseif (!$cheight) {\n\t\t\t\t\t\t\t\t\t\t\t$cheight = $cwidth;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t$bigtree[\"crops\"][] = array(\n\t\t\t\t\t\t\t\t\t\t\t\"image\" => $temp_copy,\n\t\t\t\t\t\t\t\t\t\t\t\"directory\" => $field[\"options\"][\"directory\"],\n\t\t\t\t\t\t\t\t\t\t\t\"retina\" => $field[\"options\"][\"retina\"],\n\t\t\t\t\t\t\t\t\t\t\t\"name\" => $pinfo[\"basename\"],\n\t\t\t\t\t\t\t\t\t\t\t\"width\" => $cwidth,\n\t\t\t\t\t\t\t\t\t\t\t\"height\" => $cheight,\n\t\t\t\t\t\t\t\t\t\t\t\"prefix\" => $crop[\"prefix\"],\n\t\t\t\t\t\t\t\t\t\t\t\"thumbs\" => $crop[\"thumbs\"],\n\t\t\t\t\t\t\t\t\t\t\t\"center_crops\" => $crop[\"center_crops\"],\n\t\t\t\t\t\t\t\t\t\t\t\"grayscale\" => $crop[\"grayscale\"]\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t// If it's the same dimensions, let's see if they're looking for a prefix for whatever reason...\n\t\t\t\t\t\t\t\t\t} elseif ($iheight == $cheight && $iwidth == $cwidth) {\n\t\t\t\t\t\t\t\t\t\t// See if we want thumbnails\n\t\t\t\t\t\t\t\t\t\tif (is_array($crop[\"thumbs\"])) {\n\t\t\t\t\t\t\t\t\t\t\tforeach ($crop[\"thumbs\"] as $thumb) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Make sure the thumbnail has a width or height and it's numeric\n\t\t\t\t\t\t\t\t\t\t\t\tif (($thumb[\"width\"] && is_numeric($thumb[\"width\"])) || ($thumb[\"height\"] && is_numeric($thumb[\"height\"]))) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Create a temporary thumbnail of the image on the server before moving it to it's destination.\n\t\t\t\t\t\t\t\t\t\t\t\t\t$temp_thumb = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\t\t\t\t\t\t\t\t\t\tBigTree::createThumbnail($temp_copy,$temp_thumb,$thumb[\"width\"],$thumb[\"height\"],$field[\"options\"][\"retina\"],$thumb[\"grayscale\"]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t// We use replace here instead of upload because we want to be 100% sure that this file name doesn't change.\n\t\t\t\t\t\t\t\t\t\t\t\t\t$storage->replace($temp_thumb,$thumb[\"prefix\"].$pinfo[\"basename\"],$field[\"options\"][\"directory\"]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t// See if we want center crops\n\t\t\t\t\t\t\t\t\t\tif (is_array($crop[\"center_crops\"])) {\n\t\t\t\t\t\t\t\t\t\t\tforeach ($crop[\"center_crops\"] as $center_crop) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Make sure the crop has a width and height and it's numeric\n\t\t\t\t\t\t\t\t\t\t\t\tif ($center_crop[\"width\"] && is_numeric($center_crop[\"width\"]) && $center_crop[\"height\"] && is_numeric($center_crop[\"height\"])) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Create a temporary crop of the image on the server before moving it to it's destination.\n\t\t\t\t\t\t\t\t\t\t\t\t\t$temp_crop = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\t\t\t\t\t\t\t\t\t\tBigTree::centerCrop($temp_copy,$temp_crop,$center_crop[\"width\"],$center_crop[\"height\"],$field[\"options\"][\"retina\"],$center_crop[\"grayscale\"]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t// We use replace here instead of upload because we want to be 100% sure that this file name doesn't change.\n\t\t\t\t\t\t\t\t\t\t\t\t\t$storage->replace($temp_crop,$center_crop[\"prefix\"].$pinfo[\"basename\"],$field[\"options\"][\"directory\"]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif ($crop[\"prefix\"]) {\n\t\t\t\t\t\t\t\t\t\t\t$storage->replace($temp_copy,$crop[\"prefix\"].$pinfo[\"basename\"],$field[\"options\"][\"directory\"],false,array(),true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle thumbnailing\n\t\t\t\t\tif (is_array($field[\"options\"][\"thumbs\"])) {\n\t\t\t\t\t\tforeach ($field[\"options\"][\"thumbs\"] as $thumb) {\n\t\t\t\t\t\t\t// Make sure the thumbnail has a width or height and it's numeric\n\t\t\t\t\t\t\tif (($thumb[\"width\"] && is_numeric($thumb[\"width\"])) || ($thumb[\"height\"] && is_numeric($thumb[\"height\"]))) {\n\t\t\t\t\t\t\t\t$temp_thumb = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\t\t\t\t\tBigTree::createThumbnail($temp_copy,$temp_thumb,$thumb[\"width\"],$thumb[\"height\"],$field[\"options\"][\"retina\"],$thumb[\"grayscale\"]);\n\t\t\t\t\t\t\t\t// We use replace here instead of upload because we want to be 100% sure that this file name doesn't change.\n\t\t\t\t\t\t\t\t$storage->replace($temp_thumb,$thumb[\"prefix\"].$pinfo[\"basename\"],$field[\"options\"][\"directory\"]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle center crops\n\t\t\t\t\tif (is_array($field[\"options\"][\"center_crops\"])) {\n\t\t\t\t\t\tforeach ($field[\"options\"][\"center_crops\"] as $crop) {\n\t\t\t\t\t\t\t// Make sure the crop has a width and height and it's numeric\n\t\t\t\t\t\t\tif ($crop[\"width\"] && is_numeric($crop[\"width\"]) && $crop[\"height\"] && is_numeric($crop[\"height\"])) {\n\t\t\t\t\t\t\t\t$temp_crop = SITE_ROOT.\"files/\".uniqid(\"temp-\").$itype_exts[$itype];\n\t\t\t\t\t\t\t\tBigTree::centerCrop($temp_copy,$temp_crop,$crop[\"width\"],$crop[\"height\"],$field[\"options\"][\"retina\"],$crop[\"grayscale\"]);\n\t\t\t\t\t\t\t\t// We use replace here instead of upload because we want to be 100% sure that this file name doesn't change.\n\t\t\t\t\t\t\t\t$storage->replace($temp_crop,$crop[\"prefix\"].$pinfo[\"basename\"],$field[\"options\"][\"directory\"]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we don't have any crops, get rid of the temporary image we made.\n\t\t\t\t\tif (!count($bigtree[\"crops\"])) {\n\t\t\t\t\t\tunlink($temp_copy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// We failed, keep the current value.\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn $field[\"output\"];\n\t\t}\n\n\t\t/*\n\t\t\tFunction: refreshLock\n\t\t\t\tRefreshes a lock.\n\n\t\t\tParameters:\n\t\t\t\ttable - The table for the lock.\n\t\t\t\tid - The id of the item.\n\t\t*/\n\n\t\tfunction refreshLock($table,$id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$table = sqlescape($table);\n\t\t\tsqlquery(\"UPDATE bigtree_locks SET last_accessed = NOW() WHERE `table` = '$table' AND item_id = '$id' AND user = '\".$this->ID.\"'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: requireAccess\n\t\t\t\tChecks the logged in user's access to a given module.\n\t\t\t\tThrows a permission denied page and stops page execution if the user doesn't have access.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The id of the module to check access to.\n\n\t\t\tReturns:\n\t\t\t\tThe permission level of the logged in user.\n\t\t*/\n\n\t\tfunction requireAccess($module) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn \"p\";\n\t\t\t}\n\t\t\tif (!isset($this->Permissions[$module]) || $this->Permissions[$module] == \"\") {\n\t\t\t\tdefine(\"BIGTREE_ACCESS_DENIED\",true);\n\t\t\t\t$this->stop(file_get_contents(BigTree::path(\"admin/pages/_denied.php\")));\n\t\t\t}\n\t\t\treturn $this->Permissions[$module];\n\t\t}\n\n\t\t/*\n\t\t\tFunction: requireLevel\n\t\t\t\tRequires the logged in user to have a certain access level to continue.\n\t\t\t\tThrows a permission denied page and stops page execution if the user doesn't have access.\n\n\t\t\tParameters:\n\t\t\t\tlevel - An access level (0 being normal user, 1 being administrator, 2 being developer)\n\t\t*/\n\n\t\tfunction requireLevel($level) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\t\t\tif (!isset($this->Level) || $this->Level < $level) {\n\t\t\t\tdefine(\"BIGTREE_ACCESS_DENIED\",true);\n\t\t\t\t$this->stop(file_get_contents(BigTree::path(\"admin/pages/_denied.php\")));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: requirePublisher\n\t\t\t\tChecks the logged in user's access to a given module to make sure they are a publisher.\n\t\t\t\tThrows a permission denied page and stops page execution if the user doesn't have access.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The id of the module to check access to.\n\t\t*/\n\n\t\tfunction requirePublisher($module) {\n\t\t\tglobal $admin,$bigtree,$cms;\n\t\t\tif ($this->Level > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ($this->Permissions[$module] != \"p\") {\n\t\t\t\tob_clean();\n\t\t\t\tinclude BigTree::path(\"admin/pages/_denied.php\");\n\t\t\t\t$bigtree[\"content\"] = ob_get_clean();\n\t\t\t\tinclude BigTree::path(\"admin/layouts/default.php\");\n\t\t\t\tdie();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: saveCurrentPageRevision\n\t\t\t\tSaves the currently published page as a revision.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\t\t\t\tdescription - The revision description.\n\n\t\t\tReturns:\n\t\t\t\tThe new revision id.\n\t\t*/\n\n\t\tfunction saveCurrentPageRevision($page,$description) {\n\t\t\t$access = $this->getPageAccessLevel($page);\n\t\t\t\n\t\t\tif ($access != \"p\") {\n\t\t\t\t$this->stop(\"You must be a publisher to manage revisions.\");\n\t\t\t}\n\n\t\t\t$page = sqlescape($page);\n\t\t\t$description = sqlescape($description);\n\n\t\t\t// Get the current page.\n\t\t\t$current = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pages WHERE id = '$page'\"));\n\t\t\tforeach ($current as $key => $val) {\n\t\t\t\t$$key = sqlescape($val);\n\t\t\t}\n\n\t\t\t// Copy it to the saved versions\n\t\t\tsqlquery(\"INSERT INTO bigtree_page_revisions (`page`,`title`,`meta_keywords`,`meta_description`,`template`,`external`,`new_window`,`resources`,`author`,`updated_at`,`saved`,`saved_description`) VALUES ('$page','$title','$meta_keywords','$meta_description','$template','$external','$new_window','$resources','$last_edited_by','$updated_at','on','$description')\");\n\t\t\t$id = sqlid();\n\t\t\t$this->track(\"bigtree_page_revisions\",$id,\"created\");\n\n\t\t\treturn $id;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: search404s\n\t\t\t\tSearches 404s, returns results.\n\n\t\t\tParameters:\n\t\t\t\ttype - The type of results (301, 404, or ignored).\n\t\t\t\tquery - The search query.\n\t\t\t\tpage - The page to return.\n\n\t\t\tReturns:\n\t\t\t\tAn array of entries from bigtree_404s.\n\t\t*/\n\n\t\tstatic function search404s($type,$query = \"\",$page = 1) {\n\t\t\t$items = array();\n\n\t\t\tif ($query) {\n\t\t\t\t$s = sqlescape(strtolower($query));\n\t\t\t\tif ($type == \"301\") {\n\t\t\t\t\t$where = \"ignored = '' AND (LOWER(broken_url) LIKE '%$s%' OR LOWER(redirect_url) LIKE '%$s%') AND redirect_url != ''\";\n\t\t\t\t} elseif ($type == \"ignored\") {\n\t\t\t\t\t$where = \"ignored != '' AND (LOWER(broken_url) LIKE '%$s%' OR LOWER(redirect_url) LIKE '%$s%')\";\n\t\t\t\t} else {\n\t\t\t\t\t$where = \"ignored = '' AND LOWER(broken_url) LIKE '%$s%' AND redirect_url = ''\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($type == \"301\") {\n\t\t\t\t\t$where = \"ignored = '' AND redirect_url != ''\";\n\t\t\t\t} elseif ($type == \"ignored\") {\n\t\t\t\t\t$where = \"ignored != ''\";\n\t\t\t\t} else {\n\t\t\t\t\t$where = \"ignored = '' AND redirect_url = ''\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get the page count\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT COUNT(id) AS `count` FROM bigtree_404s WHERE $where\"));\n\t\t\t$pages = ceil($f[\"count\"] / 20);\n\t\t\t$pages = ($pages < 1) ? 1 : $pages;\n\n\t\t\t// Get the results\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_404s WHERE $where ORDER BY requests DESC LIMIT \".(($page - 1) * 20).\",20\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"redirect_url\"] = BigTreeCMS::replaceInternalPageLinks($f[\"redirect_url\"]);\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\n\t\t\treturn array($pages,$items);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: searchAuditTrail\n\t\t\t\tSearches the audit trail for a set of data.\n\n\t\t\tParameters:\n\t\t\t\tuser - User to restrict results to (optional)\n\t\t\t\ttable - Table to restrict results to (optional)\n\t\t\t\tentry - Entry to restrict results to (optional)\n\t\t\t\tstart - Start date/time to restrict results to (optional)\n\t\t\t\tend - End date/time to restrict results to (optional)\n\n\t\t\tReturns:\n\t\t\t\tAn array of adds/edits/deletions from the audit trail.\n\t\t*/\n\n\t\tstatic function searchAuditTrail($user = false,$table = false,$entry = false,$start = false,$end = false) {\n\t\t\t$users = $items = $where = array();\n\t\t\t$query = \"SELECT * FROM bigtree_audit_trail\";\n\n\t\t\tif ($user) {\n\t\t\t\t$where[] = \"user = '\".sqlescape($user).\"'\";\n\t\t\t}\n\t\t\tif ($table) {\n\t\t\t\t$where[] = \"`table` = '\".sqlescape($table).\"'\";\n\t\t\t}\n\t\t\tif ($entry) {\n\t\t\t\t$where[] = \"entry = '\".sqlescape($entry).\"'\";\n\t\t\t}\n\t\t\tif ($start) {\n\t\t\t\t$where[] = \"`date` >= '\".date(\"Y-m-d H:i:s\",strtotime($start)).\"'\";\n\t\t\t}\n\t\t\tif ($end) {\n\t\t\t\t$where[] = \"`date` <= '\".date(\"Y-m-d H:i:s\",strtotime($end)).\"'\";\n\t\t\t}\n\t\t\tif (count($where)) {\n\t\t\t\t$query .= \" WHERE \".implode(\" AND \",$where);\n\t\t\t}\n\n\t\t\t$q = sqlquery($query.\" ORDER BY `date` DESC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif (!$users[$f[\"user\"]]) {\n\t\t\t\t\t$u = static::getUser($f[\"user\"]);\n\t\t\t\t\t$users[$f[\"user\"]] = array(\"id\" => $u[\"id\"],\"name\" => $u[\"name\"],\"email\" => $u[\"email\"],\"level\" => $u[\"level\"]);\n\t\t\t\t}\n\t\t\t\t$f[\"user\"] = $users[$f[\"user\"]];\n\t\t\t\t$items[] = $f;\n\t\t\t}\n\n\t\t\treturn $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: searchPages\n\t\t\t\tSearches for pages.\n\n\t\t\tParameters:\n\t\t\t\tquery - Query string to search against.\n\t\t\t\tfields - Fields to search.\n\t\t\t\tmax - Maximum number of results to return.\n\n\t\t\tReturns:\n\t\t\t\tAn array of pages.\n\t\t*/\n\n\t\tstatic function searchPages($query,$fields = array(\"nav_title\"),$max = 10) {\n\t\t\t// Since we're in JSON we have to do stupid things to the /s for URL searches.\n\t\t\t$query = str_replace('/','\\\\\\/',$query);\n\n\t\t\t$results = array();\n\t\t\t$terms = explode(\" \",$query);\n\t\t\t$qpart = array(\"archived != 'on'\");\n\n\t\t\tforeach ($terms as $term) {\n\t\t\t\t$term = sqlescape(strtolower($term));\n\t\t\t\t$or_parts = array();\n\t\t\t\tforeach ($fields as $field) {\n\t\t\t\t\t$or_parts[] = \"LOWER(`$field`) LIKE '%$term%'\";\n\t\t\t\t}\n\t\t\t\t$qpart[] = \"(\".implode(\" OR \",$or_parts).\")\";\n\t\t\t}\n\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE \".implode(\" AND \",$qpart).\" ORDER BY nav_title LIMIT $max\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$results[] = $f;\n\t\t\t}\n\t\t\treturn $results;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: searchResources\n\t\t\t\tReturns a list of folders and files that match the given query string.\n\n\t\t\tParameters:\n\t\t\t\tquery - A string of text to search folders' and files' names to.\n\t\t\t\tsort - The column to sort the files on (default: date DESC).\n\n\t\t\tReturns:\n\t\t\t\tAn array of two arrays - folders and files - with permission levels.\n\t\t*/\n\n\t\tfunction searchResources($query, $sort = \"date DESC\") {\n\t\t\t$query = sqlescape(strtolower($query));\n\t\t\t$folders = array();\n\t\t\t$resources = array();\n\t\t\t$permission_cache = array();\n\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resource_folders WHERE LOWER(name) LIKE '%$query%' ORDER BY name\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$f[\"permission\"] = $this->getResourceFolderPermission($f);\n\t\t\t\t// We're going to cache the folder permissions so we don't have to fetch them a bunch of times if many files have the same folder.\n\t\t\t\t$permission_cache[$f[\"id\"]] = $f[\"permission\"];\n\n\t\t\t\t$folders[] = $f;\n\t\t\t}\n\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_resources WHERE LOWER(name) LIKE '%$query%' ORDER BY $sort\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t// If we've already got the permission cahced, use it. Otherwise, fetch it and cache it.\n\t\t\t\tif ($permission_cache[$f[\"folder\"]]) {\n\t\t\t\t\t$f[\"permission\"] = $permission_cache[$f[\"folder\"]];\n\t\t\t\t} else {\n\t\t\t\t\t$f[\"permission\"] = $this->getResourceFolderPermission($f[\"folder\"]);\n\t\t\t\t\t$permission_cache[$f[\"folder\"]] = $f[\"permission\"];\n\t\t\t\t}\n\n\t\t\t\t$resources[] = $f;\n\t\t\t}\n\n\t\t\treturn array(\"folders\" => $folders, \"resources\" => $resources);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: searchTags\n\t\t\t\tFinds existing tags that are similar.\n\n\t\t\tParameters:\n\t\t\t\ttag - A tag to find similar tags for.\n\n\t\t\tReturns:\n\t\t\t\tAn array of up to 8 similar tags.\n\t\t*/\n\n\t\tstatic function searchTags($tag) {\n\t\t\t$tags = $dist = array();\n\t\t\t$meta = metaphone($tag);\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_tags\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$distance = levenshtein($f[\"metaphone\"],$meta);\n\t\t\t\tif ($distance < 2) {\n\t\t\t\t\t$tags[] = $f[\"tag\"];\n\t\t\t\t\t$dist[] = $distance;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tarray_multisort($dist,SORT_ASC,$tags);\n\t\t\treturn array_slice($tags,0,8);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: set404Redirect\n\t\t\t\tSets the redirect address for a 404.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the 404.\n\t\t\t\turl - The redirect URL.\n\t\t*/\n\n\t\tfunction set404Redirect($id,$url) {\n\t\t\t$this->requireLevel(1);\n\t\t\t$id = sqlescape($id);\n\n\t\t\t// Try to convert the short URL into a full one\n\t\t\tif (strpos($url,\"//\") === false) {\n\t\t\t\t$url = WWW_ROOT.ltrim($url,\"/\");\n\t\t\t}\n\t\t\t$url = sqlescape(htmlspecialchars($this->autoIPL($url)));\n\n\t\t\t// Don't use static roots if they're the same as www just in case they are different when moving environments\n\t\t\tif (WWW_ROOT === STATIC_ROOT) {\n\t\t\t\t$url = str_replace(\"{staticroot}\",\"{wwwroot}\",$url);\n\t\t\t}\n\n\t\t\tsqlquery(\"UPDATE bigtree_404s SET redirect_url = '$url' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_404s\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setCalloutPosition\n\t\t\t\tSets the position of a callout.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setCalloutPosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_callouts SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setModuleActionPosition\n\t\t\t\tSets the position of a module action.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module action.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setModuleActionPosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setModuleGroupPosition\n\t\t\t\tSets the position of a module group.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module group.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setModuleGroupPosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_module_groups SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setModulePosition\n\t\t\t\tSets the position of a module.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setModulePosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_modules SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setPagePosition\n\t\t\t\tSets the position of a page.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the page.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setPagePosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setPasswordHashForUser\n\t\t\t\tCreates a change password hash for a user.\n\n\t\t\tParameters:\n\t\t\t\tuser - A user entry.\n\n\t\t\tReturns:\n\t\t\t\tA change password hash.\n\t\t*/\n\n\t\tstatic function setPasswordHashForUser($user) {\n\t\t\t$hash = md5(microtime().$user[\"password\"]);\n\t\t\tsqlquery(\"UPDATE bigtree_users SET change_password_hash = '$hash' WHERE id = '\".$user[\"id\"].\"'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: setTemplatePosition\n\t\t\t\tSets the position of a template.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the template.\n\t\t\t\tposition - The position to set.\n\t\t*/\n\n\t\tstatic function setTemplatePosition($id,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$position = sqlescape($position);\n\t\t\tsqlquery(\"UPDATE bigtree_templates SET position = '$position' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: settingExists\n\t\t\t\tDetermines whether a setting exists for a given id.\n\n\t\t\tParameters:\n\t\t\t\tid - The setting id to check for.\n\n\t\t\tReturns:\n\t\t\t\t1 if the setting exists, otherwise 0.\n\t\t*/\n\n\t\tstatic function settingExists($id) {\n\t\t\t$id = BigTreeCMS::extensionSettingCheck($id);\n\t\t\treturn sqlrows(sqlquery(\"SELECT id FROM bigtree_settings WHERE id = '\".sqlescape($id).\"'\"));\n\t\t}\n\n\t\t/*\n\t\t\tFunction: stop\n\t\t\t\tStops processing of the Admin area and shows a message in the default layout.\n\n\t\t\tParameters:\n\t\t\t\tmessage - Content to show (error, permission denied, etc)\n\t\t*/\n\n\t\tfunction stop($message = \"\") {\n\t\t\tglobal $admin,$bigtree,$cms;\n\t\t\techo $message;\n\t\t\t$bigtree[\"content\"] = ob_get_clean();\n\t\t\tinclude BigTree::path(\"admin/layouts/\".$bigtree[\"layout\"].\".php\");\n\t\t\tdie();\n\t\t}\n\n\t\t/*\n\t\t\tFunction: stripMultipleRootTokens\n\t\t\t\tStrips the multi-domain root tokens from a string and replaces them with standard {wwwroot} and {staticroot}\n\n\t\t\tParameters:\n\t\t\t\tstring - A string\n\n\t\t\tReturns:\n\t\t\t\tA modified string.\n\t\t*/\n\n\t\tstatic function stripMultipleRootTokens($string) {\n\t\t\tglobal $bigtree;\n\n\t\t\tif (empty($bigtree[\"config\"][\"sites\"]) || !array_filter((array) $bigtree[\"config\"][\"sites\"])) {\n\t\t\t\treturn $string;\n\t\t\t}\n\n\t\t\tforeach ($bigtree[\"config\"][\"sites\"] as $key => $data) {\n\t\t\t\t$string = str_replace(\n\t\t\t\t\tarray(\"{wwwroot:$key}\", \"{staticroot:$key}\"),\n\t\t\t\t\tarray(\"{wwwroot}\", \"{staticroot}\"),\n\t\t\t\t\t$string\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn $string;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: submitPageChange\n\t\t\t\tAdds a pending change to the bigtree_pending_changes table for the page.\n\t\t\t\tDetermines what has changed and only stores the changed fields.\n\t\t\t\tDoes not check permissions.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id or pending page id (prefixed with a \"p\")\n\t\t\t\tchanges - An array of changes\n\t\t*/\n\n\t\tfunction submitPageChange($page,$changes) {\n\t\t\t$page = sqlescape($page);\n\t\t\t\n\t\t\tif ($page[0] == \"p\") {\n\t\t\t\t// It's still pending...\n\t\t\t\t$type = \"NEW\";\n\t\t\t\t$pending = true;\n\t\t\t\t$existing_page = array();\n\t\t\t\t$existing_pending_change = array(\"id\" => substr($page,1));\n\t\t\t} else {\n\t\t\t\t// It's an existing page\n\t\t\t\t$type = \"EDIT\";\n\t\t\t\t$pending = false;\n\t\t\t\t$existing_page = BigTreeCMS::getPage($page);\n\t\t\t\t$existing_pending_change = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND item_id = '$page'\"));\n\t\t\t}\n\n\t\t\t// Save tags separately\n\t\t\t$tags = BigTree::json($changes[\"_tags\"],true);\n\t\t\tunset($changes[\"_tags\"]);\n\n\t\t\t// Convert to an IPL\n\t\t\tif (!empty($changes[\"external\"])) {\n\t\t\t\t$changes[\"external\"] = $this->makeIPL($changes[\"external\"]);\n\t\t\t}\n\n\t\t\t// Unset the trunk flag if the user isn't a developer\n\t\t\tif ($this->Level < 2) {\n\t\t\t\tunset($changes[\"trunk\"]);\n\t\t\t// Make sure the value is changed -- since it's a check box it may not have come through\n\t\t\t} else {\n\t\t\t\t$changes[\"trunk\"] = !empty($changes[\"trunk\"]) ? \"on\" : \"\";\n\t\t\t}\n\n\t\t\t// Set the in_nav flag, since it's not in the post if the checkbox became unclicked\n\t\t\t$changes[\"in_nav\"] = !empty($changes[\"in_nav\"]) ? \"on\" : \"\";\n\n\t\t\t// If there's already a change in the queue, update it with this latest info.\n\t\t\tif ($existing_pending_change) {\n\t\t\t\t// If this is a pending page, just replace all the changes\n\t\t\t\tif ($pending) {\n\t\t\t\t\t$changes = BigTree::json($changes,true);\n\t\t\t\t// Otherwise, we need to check what's changed.\n\t\t\t\t} else {\n\n\t\t\t\t\t// We don't want to indiscriminately put post data in as changes, so we ensure it matches a column in the bigtree_pages table\n\t\t\t\t\t$diff = array();\n\t\t\t\t\tforeach ($changes as $key => $val) {\n\t\t\t\t\t\tif (array_key_exists($key,$existing_page) && $existing_page[$key] != $val) {\n\t\t\t\t\t\t\t$diff[$key] = $val;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$changes = BigTree::json($diff,true);\n\t\t\t\t}\n\n\t\t\t\t// Update existing draft and track\n\t\t\t\tsqlquery(\"UPDATE bigtree_pending_changes SET changes = '$changes', tags_changes = '$tags', date = NOW(), user = '\".$this->ID.\"', type = '$type' WHERE id = '\".$existing_pending_change[\"id\"].\"'\");\n\t\t\t\t$this->track(\"bigtree_pages\",$page,\"updated-draft\");\n\n\t\t\t// We're submitting a change to a presently published page with no pending changes.\n\t\t\t} else {\n\t\t\t\t$diff = array();\n\t\t\t\tforeach ($changes as $key => $val) {\n\t\t\t\t\tif (array_key_exists($key,$existing_page) && $val != $existing_page[$key]) {\n\t\t\t\t\t\t$diff[$key] = $val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$changes = BigTree::json($diff,true);\n\n\t\t\t\t// Create draft and track\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_pending_changes (`user`,`date`,`table`,`item_id`,`changes`,`tags_changes`,`type`,`title`) VALUES ('\".$this->ID.\"',NOW(),'bigtree_pages','$page','$changes','$tags','EDIT','Page Change Pending')\");\n\t\t\t\t$this->track(\"bigtree_pages\",$page,\"saved-draft\");\n\t\t\t}\n\n\t\t\treturn sqlid();\n\t\t}\n\n\t\t/*\n\t\t\tFunction: track\n\t\t\t\tLogs a user's actions to the audit trail table.\n\n\t\t\tParameters:\n\t\t\t\ttable - The table affected by the user.\n\t\t\t\tentry - The primary key of the entry affected by the user.\n\t\t\t\ttype - The action taken by the user (delete, edit, create, etc.)\n\t\t*/\n\n\t\tfunction track($table,$entry,$type) {\n\t\t\t// If this is running fron cron or something, nobody is logged in so don't track.\n\t\t\tif (isset($this->ID)) {\n\t\t\t\t$table = sqlescape($table);\n\t\t\t\t$entry = sqlescape($entry);\n\t\t\t\t$type = sqlescape($type);\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_audit_trail (`table`,`user`,`entry`,`date`,`type`) VALUES ('$table','\".$this->ID.\"','$entry',NOW(),'$type')\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: unarchivePage\n\t\t\t\tUnarchives a page and all its children that inherited archived status.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id or page entry.\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful. false if permission was denied.\n\t\t*/\n\n\t\tfunction unarchivePage($page) {\n\t\t\tif (is_array($page)) {\n\t\t\t\t$page = sqlescape($page[\"id\"]);\n\t\t\t} else {\n\t\t\t\t$page = sqlescape($page);\n\t\t\t}\n\t\t\t$access = $this->getPageAccessLevel($page);\n\t\t\tif ($access == \"p\" && $this->canModifyChildren(BigTreeCMS::getPage($page))) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_pages SET archived = '' WHERE id = '$page'\");\n\t\t\t\t$this->track(\"bigtree_pages\",$page,\"unarchived\");\n\t\t\t\t$this->unarchivePageChildren($page);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: unarchivePageChildren\n\t\t\t\tUnarchives a page's children that have the archived_inherited status.\n\t\t\t\tDoes not checks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The parent page id.\n\t\t*/\n\n\t\tfunction unarchivePageChildren($id) {\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_pages WHERE parent = '$id' AND archived_inherited = 'on'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$this->track(\"bigtree_pages\",$f[\"id\"],\"unarchived-inherited\");\n\t\t\t\t$this->unarchivePageChildren($f[\"id\"]);\n\t\t\t}\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET archived = '', archived_inherited = '' WHERE parent = '$id' AND archived_inherited = 'on'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: ungrowl\n\t\t\t\tDestroys the growl session.\n\t\t*/\n\n\t\tstatic function ungrowl() {\n\t\t\tunset($_SESSION[\"bigtree_admin\"][\"growl\"]);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: urlExists\n\t\t\t\tAttempts to connect to a URL using cURL.\n\t\t\t\tThis is now an alias for BigTree::urlExists\n\n\t\t\tParameters:\n\t\t\t\turl - The URL to connect to.\n\n\t\t\tReturns:\n\t\t\t\ttrue if it can connect, false if connection failed.\n\n\t\t\tSee Also:\n\t\t\t\tBigTree::urlExists\n\t\t*/\n\n\t\tstatic function urlExists($url) {\n\t\t\treturn BigTree::urlExists($url);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: unCache\n\t\t\t\tRemoves the cached copy of a given page.\n\n\t\t\tParameters:\n\t\t\t\tpage - Either a page id or a page entry.\n\t\t*/\n\n\t\tstatic function unCache($page) {\n\t\t\t$url = \"\";\n\n\t\t\t// Already have the path\n\t\t\tif (is_array($page)) {\n\t\t\t\t$url = $page[\"path\"].\"/\";\n\t\t\t} else {\n\t\t\t\tif ($page != 0) {\n\t\t\t\t\t$url = str_replace(WWW_ROOT,\"\",BigTreeCMS::getLink($page));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@unlink(md5(json_encode(array(\"bigtree_htaccess_url\" => $url))).\".page\");\n\t\t\t@unlink(md5(json_encode(array(\"bigtree_htaccess_url\" => rtrim($url,\"/\")))).\".page\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: unignore404\n\t\t\t\tUnignores a 404.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the 404.\n\t\t*/\n\n\t\tfunction unignore404($id) {\n\t\t\t$this->requireLevel(1);\n\t\t\t$id = sqlescape($id);\n\t\t\tsqlquery(\"UPDATE bigtree_404s SET ignored = '' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_404s\",$id,\"unignored\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: uniqueModuleActionRoute\n\t\t\t\tReturns a unique module action route.\n\n\t\t\tParameters:\n\t\t\t\tmodule - The module to create a route for.\n\t\t\t\troute - The desired route.\n\t\t\t\taction - The ID of the action you're trying to set a new route for (optional)\n\n\t\t\tReturns:\n\t\t\t\tA unique action route.\n\t\t*/\n\n\t\tstatic function uniqueModuleActionRoute($module,$route,$action = false) {\n\t\t\t$module = sqlescape($module);\n\t\t\t$oroute = $route = sqlescape($route);\n\t\t\t$x = 2;\n\t\t\t$query_add = ($action !== false) ? \" AND id != '\".sqlescape($action).\"'\" : \"\";\n\t\t\twhile (sqlrows(sqlquery(\"SELECT * FROM bigtree_module_actions WHERE module = '$module' AND route = '$route' $query_add\"))) {\n\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t$x++;\n\t\t\t}\n\t\t\treturn $route;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: unlock\n\t\t\t\tRemoves a lock from a table entry.\n\n\t\t\tParameters:\n\t\t\t\ttable - The table the entry is in.\n\t\t\t\tid - The id of the entry.\n\t\t*/\n\n\t\tstatic function unlock($table,$id) {\n\t\t\tsqlquery(\"DELETE FROM bigtree_locks WHERE `table` = '\".sqlescape($table).\"' AND item_id = '\".sqlescape($id).\"'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateCallout\n\t\t\t\tUpdates a callout.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout to update.\n\t\t\t\tname - The name.\n\t\t\t\tdescription - The description.\n\t\t\t\tlevel - The access level (0 for all users, 1 for administrators, 2 for developers)\n\t\t\t\tresources - An array of resources.\n\t\t\t\tdisplay_field - The field to use as the display field describing a user's callout\n\t\t\t\tdisplay_default - The text string to use in the event the display_field is blank or non-existent\n\t\t*/\n\n\t\tfunction updateCallout($id,$name,$description,$level,$resources,$display_field,$display_default) {\n\t\t\t$clean_resources = array();\n\t\t\tforeach ($resources as $resource) {\n\t\t\t\t// \"type\" is still a reserved keyword due to the way we save callout data when editing.\n\t\t\t\tif ($resource[\"id\"] && $resource[\"id\"] != \"type\") {\n\t\t\t\t\t$clean_resources[] = array(\n\t\t\t\t\t\t\"id\" => BigTree::safeEncode($resource[\"id\"]),\n\t\t\t\t\t\t\"type\" => BigTree::safeEncode($resource[\"type\"]),\n\t\t\t\t\t\t\"title\" => BigTree::safeEncode($resource[\"title\"]),\n\t\t\t\t\t\t\"subtitle\" => BigTree::safeEncode($resource[\"subtitle\"]),\n\t\t\t\t\t\t\"options\" => BigTree::translateArray(json_decode($resource[\"options\"],true))\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$level = sqlescape($level);\n\t\t\t$resources = BigTree::json($clean_resources,true);\n\t\t\t$display_default = sqlescape($display_default);\n\t\t\t$display_field = sqlescape($display_field);\n\n\t\t\tsqlquery(\"UPDATE bigtree_callouts SET resources = '$resources', name = '$name', description = '$description', level = '$level', display_field = '$display_field', display_default = '$display_default' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_callouts\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateCalloutGroup\n\t\t\t\tUpdates a callout group's name and callout list.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the callout group to update.\n\t\t\t\tname - The name.\n\t\t\t\tcallouts - An array of callout IDs to assign to the group.\n\t\t*/\n\n\t\tfunction updateCalloutGroup($id,$name,$callouts) {\n\t\t\tsort($callouts);\n\t\t\t$callouts = BigTree::json($callouts,true);\n\t\t\tsqlquery(\"UPDATE bigtree_callout_groups SET name = '\".sqlescape(BigTree::safeEncode($name)).\"', callouts = '$callouts' WHERE id = '\".sqlescape($id).\"'\");\n\t\t\t$this->track(\"bigtree_callout_groups\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateChildPagePaths\n\t\t\t\tUpdates the paths for pages who are descendants of a given page to reflect the page's new route.\n\t\t\t\tAlso sets route history if the page has changed paths.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id.\n\t\t*/\n\n\t\tstatic function updateChildPagePaths($page) {\n\t\t\t$page = sqlescape($page);\n\t\t\t$q = sqlquery(\"SELECT id,path FROM bigtree_pages WHERE parent = '$page'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$oldpath = $f[\"path\"];\n\t\t\t\t$path = static::getFullNavigationPath($f[\"id\"]);\n\t\t\t\tif ($oldpath != $path) {\n\t\t\t\t\tsqlquery(\"DELETE FROM bigtree_route_history WHERE old_route = '$path' OR old_route = '$oldpath'\");\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_route_history (`old_route`,`new_route`) VALUES ('$oldpath','$path')\");\n\t\t\t\t\tsqlquery(\"UPDATE bigtree_pages SET path = '$path' WHERE id = '\".$f[\"id\"].\"'\");\n\t\t\t\t\tstatic::updateChildPagePaths($f[\"id\"]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateFeed\n\t\t\t\tUpdates a feed.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the feed to update.\n\t\t\t\tname - The name.\n\t\t\t\tdescription - The description.\n\t\t\t\ttable - The data table.\n\t\t\t\ttype - The feed type.\n\t\t\t\toptions - The feed type options.\n\t\t\t\tfields - The fields.\n\t\t*/\n\n\t\tfunction updateFeed($id,$name,$description,$table,$type,$options,$fields) {\n\t\t\t$options = json_decode($options,true);\n\t\t\tforeach ($options as &$option) {\n\t\t\t\t$option = BigTreeCMS::replaceHardRoots($option);\n\t\t\t}\n\n\t\t\t// Fix stuff up for the db.\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\t\t\t$options = BigTree::json($options,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\n\t\t\tsqlquery(\"UPDATE bigtree_feeds SET name = '$name', description = '$description', `table` = '$table', type = '$type', fields = '$fields', options = '$options' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_feeds\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateFieldType\n\t\t\t\tUpdates a field type.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the field type.\n\t\t\t\tname - The name.\n\t\t\t\tuse_cases - Associate array of sections in which the field type can be used (i.e. array(\"pages\" => \"on\", \"modules\" => \"\",\"callouts\" => \"\",\"settings\" => \"\"))\n\t\t\t\tself_draw - Whether this field type will draw its <fieldset> and <label> (\"on\" or a falsey value)\n\t\t*/\n\n\t\tfunction updateFieldType($id,$name,$use_cases,$self_draw) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$use_cases = sqlescape(json_encode($use_cases));\n\t\t\t$self_draw = $self_draw ? \"'on'\" : \"NULL\";\n\n\t\t\tsqlquery(\"UPDATE bigtree_field_types SET name = '$name', use_cases = '$use_cases', self_draw = $self_draw WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_field_types\",$id,\"updated\");\n\n\t\t\tunlink(SERVER_ROOT.\"cache/bigtree-form-field-types.json\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModule\n\t\t\t\tUpdates a module.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module to update.\n\t\t\t\tname - The name of the module.\n\t\t\t\tgroup - The group for the module.\n\t\t\t\tclass - The module class to create.\n\t\t\t\tpermissions - The group-based permissions.\n\t\t\t\ticon - The icon to use.\n\t\t*/\n\n\t\tfunction updateModule($id,$name,$group,$class,$permissions,$icon) {\n\t\t\t// If this has a permissions table, wipe that table's view cache\n\t\t\tif ($permissions[\"table\"]) {\n\t\t\t\tBigTreeAutoModule::clearCache($permissions[\"table\"]);\n\t\t\t}\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$group = $group ? \"'\".sqlescape($group).\"'\" : \"NULL\";\n\t\t\t$class = sqlescape($class);\n\t\t\t$permissions = BigTree::json($permissions,true);\n\t\t\t$icon = sqlescape($icon);\n\n\t\t\tsqlquery(\"UPDATE bigtree_modules SET name = '$name', `group` = $group, class = '$class', icon = '$icon', `gbp` = '$permissions' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_modules\",$id,\"updated\");\n\n\t\t\t// Remove cached class list.\n\t\t\tunlink(SERVER_ROOT.\"cache/bigtree-module-class-list.json\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleAction\n\t\t\t\tUpdates a module action.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module action to update.\n\t\t\t\tname - The name of the action.\n\t\t\t\troute - The action route.\n\t\t\t\tin_nav - Whether the action is in the navigation.\n\t\t\t\ticon - The icon class for the action.\n\t\t\t\tform - The associated form.\n\t\t\t\tview - The associated view.\n\t\t\t\treport - The associated report.\n\t\t\t\tlevel - The required access level.\n\t\t\t\tposition - The position in navigation.\n\t\t*/\n\n\t\tfunction updateModuleAction($id,$name,$route,$in_nav,$icon,$form,$view,$report,$level,$position) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$route = sqlescape(BigTree::safeEncode($route));\n\t\t\t$in_nav = sqlescape($in_nav);\n\t\t\t$icon = sqlescape($icon);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\t\t\t$level = sqlescape($level);\n\t\t\t$form = $form ? \"'\".sqlescape($form).\"'\" : \"NULL\";\n\t\t\t$view = $view ? \"'\".sqlescape($view).\"'\" : \"NULL\";\n\t\t\t$report = $report ? \"'\".sqlescape($report).\"'\" : \"NULL\";\n\t\t\t$position = sqlescape($position);\n\n\t\t\t$item = $this->getModuleAction($id);\n\t\t\t$route = $this->uniqueModuleActionRoute($item[\"module\"],$route,$id);\n\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET name = '$name', route = '$route', class = '$icon', in_nav = '$in_nav', level = '$level', position = '$position', form = $form, view = $view, report = $report WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_module_actions\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleEmbedForm\n\t\t\t\tUpdates an embeddable form.\n\n\t\t\tParameters:\n\t\t\t\tid - The ID of the form.\n\t\t\t\ttitle - The title of the form.\n\t\t\t\ttable - The table for the form data.\n\t\t\t\tfields - The form fields.\n\t\t\t\thooks - An array of \"pre\", \"post\", and \"publish\" keys that can be function names to call\n\t\t\t\tdefault_position - Default position for entries to the form (if the view is positioned).\n\t\t\t\tdefault_pending - Whether the submissions to default to pending or not (\"on\" or \"\").\n\t\t\t\tcss - URL of a CSS file to include.\n\t\t\t\tredirect_url - The URL to redirect to upon completion of submission.\n\t\t\t\tthank_you_message - The message to display upon completeion of submission.\n\t\t*/\n\n\t\tfunction updateModuleEmbedForm($id,$title,$table,$fields,$hooks = array(),$default_position = \"\",$default_pending = \"\",$css = \"\",$redirect_url = \"\",$thank_you_message = \"\") {\n\t\t\t$id = sqlescape($id);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$hooks = BigTree::json(json_decode($hooks),true);\n\t\t\t$default_position = sqlescape($default_position);\n\t\t\t$default_pending = $default_pending ? \"on\" : \"\";\n\t\t\t$css = sqlescape(BigTree::safeEncode($this->makeIPL($css)));\n\t\t\t$redirect_url = sqlescape(BigTree::safeEncode($redirect_url));\n\t\t\t$thank_you_message = sqlescape($thank_you_message);\n\n\t\t\t$clean_fields = array();\n\t\t\tforeach ($fields as $key => $field) {\n\t\t\t\t$field[\"options\"] = BigTree::translateArray(json_decode($field[\"options\"],true));\n\t\t\t\t$field[\"column\"] = $key;\n\t\t\t\t$clean_fields[] = $field;\n\t\t\t}\n\t\t\t$fields = BigTree::json($clean_fields,true);\n\n\t\t\tsqlquery(\"UPDATE bigtree_module_embeds SET `title` = '$title', `table` = '$table', `fields` = '$fields', `default_position` = '$default_position', `default_pending` = '$default_pending', `css` = '$css', `redirect_url` = '$redirect_url', `thank_you_message` = '$thank_you_message', `hooks` = '$hooks' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_module_embeds\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleForm\n\t\t\t\tUpdates a module form.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the form.\n\t\t\t\ttitle - The title of the form.\n\t\t\t\ttable - The table for the form data.\n\t\t\t\tfields - The form fields.\n\t\t\t\thooks - An array of \"pre\", \"post\", and \"publish\" keys that can be function names to call\n\t\t\t\tdefault_position - Default position for entries to the form (if the view is positioned).\n\t\t\t\treturn_view - The view to return to when the form is completed.\n\t\t\t\treturn_url - The alternative URL to return to when the form is completed.\n\t\t\t\ttagging - Whether or not to enable tagging.\n\t\t*/\n\n\t\tfunction updateModuleForm($id,$title,$table,$fields,$hooks = array(),$default_position = \"\",$return_view = false,$return_url = \"\",$tagging = \"\") {\n\t\t\t$id = sqlescape($id);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$hooks = BigTree::json(json_decode($hooks),true);\n\t\t\t$default_position = sqlescape($default_position);\n\t\t\t$return_view = $return_view ? \"'\".sqlescape($return_view).\"'\" : \"NULL\";\n\t\t\t$return_url = sqlescape($this->makeIPL($return_url));\n\t\t\t$tagging = $tagging ? \"on\" : \"\";\n\n\t\t\t$clean_fields = array();\n\t\t\tforeach ($fields as $key => $field) {\n\t\t\t\t$field[\"options\"] = BigTree::translateArray(json_decode($field[\"options\"],true));\n\t\t\t\t$field[\"column\"] = $key;\n\t\t\t\t$field[\"title\"] = BigTree::safeEncode($field[\"title\"]);\n\t\t\t\t$field[\"subtitle\"] = BigTree::safeEncode($field[\"subtitle\"]);\n\t\t\t\t$clean_fields[] = $field;\n\t\t\t}\n\t\t\t$fields = BigTree::json($clean_fields,true);\n\n\t\t\tsqlquery(\"UPDATE bigtree_module_forms SET title = '$title', `table` = '$table', fields = '$fields', default_position = '$default_position', return_view = $return_view, return_url = '$return_url', `tagging` = '$tagging', `hooks` = '$hooks' WHERE id = '$id'\");\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET name = 'Add $title' WHERE form = '$id' AND route LIKE 'add%'\");\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET name = 'Edit $title' WHERE form = '$id' AND route LIKE 'edit%'\");\n\n\t\t\t// Get related views for this table and update numeric status\n\t\t\t$q = sqlquery(\"SELECT id FROM bigtree_module_views WHERE `table` = '$table'\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tstatic::updateModuleViewColumnNumericStatus(BigTreeAutoModule::getView($f[\"id\"]));\n\t\t\t}\n\n\t\t\t$this->track(\"bigtree_module_forms\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleGroup\n\t\t\t\tUpdates a module group's name.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the module group to update.\n\t\t\t\tname - The name of the module group.\n\t\t*/\n\n\t\tfunction updateModuleGroup($id,$name) {\n\t\t\t// Get a unique route\n\t\t\t$x = 2;\n\t\t\t$route = BigTreeCMS::urlify($name);\n\t\t\t$oroute = $route;\n\t\t\t$existing = $this->getModuleGroupByRoute($route);\n\t\t\twhile ($existing && $existing[\"id\"] != $id) {\n\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t$existing = $this->getModuleGroupByRoute($route);\n\t\t\t\t$x++;\n\t\t\t}\n\n\t\t\t$route = sqlescape($route);\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(BigTree::safeEncode($name));\n\n\t\t\tsqlquery(\"UPDATE bigtree_module_groups SET name = '$name', route = '$route' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_module_groups\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleReport\n\t\t\t\tUpdates a module report.\n\n\t\t\tParameters:\n\t\t\t\tid - The ID of the report to update.\n\t\t\t\ttitle - The title of the report.\n\t\t\t\ttable - The table for the report data.\n\t\t\t\ttype - The type of report (csv or view).\n\t\t\t\tfilters - The filters a user can use to create the report.\n\t\t\t\tfields - The fields to show in the CSV export (if type = csv).\n\t\t\t\tparser - An optional parser function to run on the CSV export data (if type = csv).\n\t\t\t\tview - A module view ID to use (if type = view).\n\t\t*/\n\n\t\tfunction updateModuleReport($id,$title,$table,$type,$filters,$fields = \"\",$parser = \"\",$view = \"\") {\n\t\t\t$id = sqlescape($id);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\t\t\t$filters = BigTree::json($filters,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\t$parser = sqlescape($parser);\n\t\t\t$view = $view ? \"'\".sqlescape($view).\"'\" : \"NULL\";\n\t\t\tsqlquery(\"UPDATE bigtree_module_reports SET `title` = '$title', `table` = '$table', `type` = '$type', `filters` = '$filters', `fields` = '$fields', `parser` = '$parser', `view` = $view WHERE id = '$id'\");\n\t\t\t// Update the module action\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET `name` = '$title' WHERE `report` = '$id'\");\n\t\t\t$this->track(\"bigtree_module_reports\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleView\n\t\t\t\tUpdates a module view.\n\n\t\t\tParameters:\n\t\t\t\tid - The view id.\n\t\t\t\ttitle - View title.\n\t\t\t\tdescription - Description.\n\t\t\t\ttable - Data table.\n\t\t\t\ttype - View type.\n\t\t\t\toptions - View options array.\n\t\t\t\tfields - Field array.\n\t\t\t\tactions - Actions array.\n\t\t\t\trelated_form - Form ID to handle edits.\n\t\t\t\tpreview_url - Optional preview URL.\n\n\t\t\tReturns:\n\t\t\t\tThe id for view.\n\t\t*/\n\n\t\tfunction updateModuleView($id,$title,$description,$table,$type,$options,$fields,$actions,$related_form,$preview_url = \"\") {\n\t\t\t$id = sqlescape($id);\n\t\t\t$title = sqlescape(BigTree::safeEncode($title));\n\t\t\t$description = sqlescape(BigTree::safeEncode($description));\n\t\t\t$table = sqlescape($table);\n\t\t\t$type = sqlescape($type);\n\n\t\t\t$options = BigTree::json($options,true);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\t$actions = BigTree::json($actions,true);\n\t\t\t$related_form = $related_form ? intval($related_form) : \"NULL\";\n\t\t\t$preview_url = sqlescape(BigTree::safeEncode($this->makeIPL($preview_url)));\n\n\t\t\tsqlquery(\"UPDATE bigtree_module_views SET title = '$title', description = '$description', `table` = '$table', type = '$type', options = '$options', fields = '$fields', actions = '$actions', preview_url = '$preview_url', related_form = $related_form WHERE id = '$id'\");\n\t\t\tsqlquery(\"UPDATE bigtree_module_actions SET name = 'View $title' WHERE view = '$id'\");\n\n\t\t\tstatic::updateModuleViewColumnNumericStatus(BigTreeAutoModule::getView($id));\n\t\t\t$this->track(\"bigtree_module_views\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleViewColumnNumericStatus\n\t\t\t\tUpdates a module view's columns to designate whether they are numeric or not based on parsers, column type, and related forms.\n\n\t\t\tParameters:\n\t\t\t\tview - The view entry to update.\n\t\t*/\n\n\t\tstatic function updateModuleViewColumnNumericStatus($view) {\n\t\t\tif (is_array($view[\"fields\"])) {\n\t\t\t\t$form = BigTreeAutoModule::getRelatedFormForView($view);\n\t\t\t\t$table = BigTree::describeTable($view[\"table\"]);\n\n\t\t\t\tforeach ($view[\"fields\"] as $key => $field) {\n\t\t\t\t\t$numeric = false;\n\t\t\t\t\t$t = $table[\"columns\"][$key][\"type\"];\n\t\t\t\t\tif ($t == \"int\" || $t == \"float\" || $t == \"double\" || $t == \"double precision\" || $t == \"tinyint\" || $t == \"smallint\" || $t == \"mediumint\" || $t == \"bigint\" || $t == \"real\" || $t == \"decimal\" || $t == \"dec\" || $t == \"fixed\" || $t == \"numeric\") {\n\t\t\t\t\t\t$numeric = true;\n\t\t\t\t\t}\n\t\t\t\t\tif ($field[\"parser\"] || ($form[\"fields\"][$key][\"type\"] == \"list\" && $form[\"fields\"][$key][\"list_type\"] == \"db\")) {\n\t\t\t\t\t\t$numeric = false;\n\t\t\t\t\t}\n\n\t\t\t\t\t$view[\"fields\"][$key][\"numeric\"] = $numeric;\n\t\t\t\t}\n\n\t\t\t\t$fields = BigTree::json($view[\"fields\"],true);\n\t\t\t\tsqlquery(\"UPDATE bigtree_module_views SET fields = '$fields' WHERE id = '\".$view[\"id\"].\"'\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateModuleViewFields\n\t\t\t\tUpdates the fields for a module view.\n\n\t\t\tParameters:\n\t\t\t\tview - The view id.\n\t\t\t\tfields - A fields array.\n\t\t*/\n\n\t\tfunction updateModuleViewFields($view,$fields) {\n\t\t\t$view = sqlescape($view);\n\t\t\t$fields = BigTree::json($fields,true);\n\t\t\tsqlquery(\"UPDATE bigtree_module_views SET `fields` = '$fields' WHERE id = '$view'\");\n\t\t\t$this->track(\"bigtree_module_views\",$view,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updatePage\n\t\t\t\tUpdates a page.\n\t\t\t\tChecks some (but not all) permissions.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page id to update.\n\t\t\t\tdata - The page data to update with.\n\t\t*/\n\n\t\tfunction updatePage($page,$data) {\n\t\t\t$page = sqlescape($page);\n\n\t\t\t// Save the existing copy as a draft, remove drafts for this page that are one month old or older.\n\t\t\t$current = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pages WHERE id = '$page'\"));\n\t\t\tforeach ($current as $key => $val) {\n\t\t\t\t$$key = sqlescape($val);\n\t\t\t}\n\t\t\t// Figure out if we currently have a template that the user isn't allowed to use. If they do, we're not letting them change it.\n\t\t\t$template_data = BigTreeCMS::getTemplate($template);\n\t\t\tif (is_array($template_data) && $template_data[\"level\"] > $this->Level) {\n\t\t\t\t$data[\"template\"] = $template;\n\t\t\t}\n\t\t\t// Copy it to the saved versions\n\t\t\tsqlquery(\"INSERT INTO bigtree_page_revisions (`page`,`title`,`meta_keywords`,`meta_description`,`template`,`external`,`new_window`,`resources`,`author`,`updated_at`) VALUES ('$page','$title','$meta_keywords','$meta_description','$template','$external','$new_window','$resources','$last_edited_by','$updated_at')\");\n\t\t\t// Count the page revisions\n\t\t\t$r = sqlrows(sqlquery(\"SELECT id FROM bigtree_page_revisions WHERE page = '$page' AND saved = ''\"));\n\t\t\t// If we have more than 10, delete any that are more than a month old\n\t\t\tif ($r > 10) {\n\t\t\t\tsqlquery(\"DELETE FROM bigtree_page_revisions WHERE page = '$page' AND updated_at < '\".date(\"Y-m-d\",strtotime(\"-1 month\")).\"' AND saved = '' ORDER BY updated_at ASC LIMIT \".($r - 10));\n\t\t\t}\n\n\t\t\t// Remove this page from the cache\n\t\t\tstatic::unCache($page);\n\n\t\t\t// Set local variables in a clean fashion that prevents _SESSION exploitation. Also, don't let them somehow overwrite $page and $current.\n\t\t\tforeach ($data as $key => $val) {\n\t\t\t\tif (substr($key,0,1) != \"_\" && $key != \"current\" && $key != \"page\") {\n\t\t\t\t\tif (is_array($val)) {\n\t\t\t\t\t\t$$key = BigTree::json($val,true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$key = sqlescape($val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the trunk flag back to the current value if the user isn't a developer\n\t\t\tif ($this->Level < 2) {\n\t\t\t\t$trunk = $current[\"trunk\"];\n\t\t\t} else {\n\t\t\t\t$trunk = sqlescape($data[\"trunk\"]);\n\t\t\t}\n\n\t\t\t// If this is top level nav and the user isn't a developer, use what the current state is.\n\t\t\tif (!$current[\"parent\"] && $this->Level < 2) {\n\t\t\t\t$in_nav = sqlescape($current[\"in_nav\"]);\n\t\t\t} else {\n\t\t\t\t$in_nav = sqlescape($data[\"in_nav\"]);\n\t\t\t}\n\n\t\t\t// Make an ipl:// or {wwwroot}'d version of the URL\n\t\t\tif ($external) {\n\t\t\t\t$external = static::makeIPL($external);\n\t\t\t}\n\n\t\t\t// If somehow we didn't provide a parent page (like, say, the user didn't have the right to change it) then pull the one from before. Actually, this might be exploitable\u2026 look into it later.\n\t\t\tif (!isset($data[\"parent\"])) {\n\t\t\t\t$parent = $current[\"parent\"];\n\t\t\t}\n\n\t\t\tif ($page == 0) {\n\t\t\t\t// Home page doesn't get a route - fixes sitemap bug\n\t\t\t\t$route = \"\";\n\t\t\t} else {\n\t\t\t\t// Create a route if we don't have one, otherwise, make sure the one they provided doesn't suck.\n\t\t\t\t$route = $data[\"route\"];\n\t\t\t\tif (!$route) {\n\t\t\t\t\t$route = BigTreeCMS::urlify($data[\"nav_title\"]);\n\t\t\t\t} else {\n\t\t\t\t\t$route = BigTreeCMS::urlify($route);\n\t\t\t\t}\n\n\t\t\t\t// Get a unique route\n\t\t\t\t$oroute = $route;\n\t\t\t\t$x = 2;\n\t\t\t\t// Reserved paths.\n\t\t\t\tif ($parent == 0) {\n\t\t\t\t\twhile (file_exists(SERVER_ROOT.\"site/\".$route.\"/\")) {\n\t\t\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t\t\t$x++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (in_array($route,static::$ReservedTLRoutes)) {\n\t\t\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t\t\t$x++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Existing pages.\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pages WHERE `route` = '$route' AND parent = '$parent' AND id != '$page'\"));\n\t\t\t\twhile ($f) {\n\t\t\t\t\t$route = $oroute.\"-\".$x;\n\t\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pages WHERE `route` = '$route' AND parent = '$parent' AND id != '$page'\"));\n\t\t\t\t\t$x++;\n\t\t\t\t}\n\n\t\t\t\t// Make sure route isn't longer than 255\n\t\t\t\t$route = substr($route,0,255);\n\t\t\t}\n\n\t\t\t// We have no idea how this affects the nav, just wipe it all.\n\t\t\tif ($current[\"nav_title\"] != $nav_title || $current[\"route\"] != $route || $current[\"in_nav\"] != $in_nav || $current[\"parent\"] != $parent) {\n\t\t\t\tstatic::clearCache();\n\t\t\t}\n\n\t\t\t// Make sure we set the publish date to NULL if it wasn't provided or we'll have a page that got published at 0000-00-00\n\t\t\tif ($publish_at && $publish_at != \"NULL\") {\n\t\t\t\t$publish_at = \"'\".date(\"Y-m-d\",strtotime($publish_at)).\"'\";\n\t\t\t} else {\n\t\t\t\t$publish_at = \"NULL\";\n\t\t\t}\n\n\t\t\t// If we set an expiration date, make it the proper MySQL format.\n\t\t\tif ($expire_at && $expire_at != \"NULL\") {\n\t\t\t\t$expire_at = \"'\".date(\"Y-m-d\",strtotime($expire_at)).\"'\";\n\t\t\t} else {\n\t\t\t\t$expire_at = \"NULL\";\n\t\t\t}\n\n\t\t\t// Set the full path, saves DB access time on the front end.\n\t\t\tif ($parent > 0) {\n\t\t\t\t$path = static::getFullNavigationPath($parent).\"/\".$route;\n\t\t\t} else {\n\t\t\t\t$path = $route;\n\t\t\t}\n\n\t\t\t// htmlspecialchars stuff so that it doesn't need to be re-encoded when echo'd on the front end.\n\t\t\t$title = htmlspecialchars($title);\n\t\t\t$nav_title = htmlspecialchars($nav_title);\n\t\t\t$meta_description = htmlspecialchars($meta_description);\n\t\t\t$meta_keywords = htmlspecialchars($meta_keywords);\n\t\t\t$seo_invisible = $data[\"seo_invisible\"] ? \"on\" : \"\";\n\t\t\t$external = htmlspecialchars($external);\n\n\t\t\t// Update the database\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET `trunk` = '$trunk', `parent` = '$parent', `nav_title` = '$nav_title', `route` = '$route', `path` = '$path', `in_nav` = '$in_nav', `title` = '$title', `template` = '$template', `external` = '$external', `new_window` = '$new_window', `resources` = '$resources', `meta_keywords` = '$meta_keywords', `meta_description` = '$meta_description', `seo_invisible` = '$seo_invisible', `last_edited_by` = '\".$this->ID.\"', updated_at = NOW(), publish_at = $publish_at, expire_at = $expire_at, max_age = '$max_age' WHERE id = '$page'\");\n\n\t\t\t// Remove any pending drafts\n\t\t\tsqlquery(\"DELETE FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND item_id = '$page'\");\n\n\t\t\t// Remove old paths from the redirect list\n\t\t\tsqlquery(\"DELETE FROM bigtree_route_history WHERE old_route = '$path' OR old_route = '\".$current[\"path\"].\"'\");\n\n\t\t\t// Create an automatic redirect from the old path to the new one.\n\t\t\tif ($current[\"path\"] != $path) {\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_route_history (`old_route`,`new_route`) VALUES ('\".$current[\"path\"].\"','$path')\");\n\n\t\t\t\t// Update all child page routes, ping those engines, clean those caches\n\t\t\t\tstatic::updateChildPagePaths($page);\n\t\t\t\tstatic::pingSearchEngines();\n\t\t\t\tstatic::clearCache();\n\t\t\t}\n\n\t\t\t// Handle tags\n\t\t\tsqlquery(\"DELETE FROM bigtree_tags_rel WHERE `table` = 'bigtree_pages' AND entry = '$page'\");\n\t\t\tif (is_array($data[\"_tags\"])) {\n\t\t\t\tforeach ($data[\"_tags\"] as $tag) {\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_tags_rel (`table`,`entry`,`tag`) VALUES ('bigtree_pages','$page','$tag')\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Audit trail.\n\t\t\t$this->track(\"bigtree_pages\",$page,\"updated\");\n\t\t\t\n\t\t\t// If this page is a trunk in a multi-site setup, wipe the cache\n\t\t\tforeach (BigTreeCMS::$SiteRoots as $site_path => $site_data) {\n\t\t\t\tif ($site_data[\"trunk\"] == $page) {\n\t\t\t\t\tunlink(SERVER_ROOT.\"cache/multi-site-cache.json\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $page;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updatePageParent\n\t\t\t\tChanges a page's parent.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tpage - The page to update.\n\t\t\t\tparent - The parent to switch to.\n\t\t*/\n\n\t\tfunction updatePageParent($page,$parent) {\n\t\t\t$page = sqlescape($page);\n\t\t\t$parent = sqlescape($parent);\n\n\t\t\tif ($this->Level < 1) {\n\t\t\t\t$this->stop(\"You are not allowed to move pages.\");\n\t\t\t}\n\n\t\t\t// Get the existing path so we can create a route history\n\t\t\t$current = sqlfetch(sqlquery(\"SELECT in_nav,path FROM bigtree_pages WHERE id = '$page'\"));\n\t\t\t$old_path = sqlescape($current[\"path\"]);\n\n\t\t\t// If the current user isn't a developer and is moving the page to top level, set it to not be visible\n\t\t\t$in_nav = $current[\"in_nav\"] ? \"on\" : \"\";\n\t\t\tif ($this->Level < 2 && $parent == 0) {\n\t\t\t\t$in_nav = \"\";\n\t\t\t}\n\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET in_nav = '$in_nav', parent = '$parent' WHERE id = '$page'\");\n\t\t\t$path = sqlescape($this->getFullNavigationPath($page));\n\n\t\t\t// Set the route history\n\t\t\tsqlquery(\"DELETE FROM bigtree_route_history WHERE old_route = '$path' OR old_route = '$old_path'\");\n\t\t\tsqlquery(\"INSERT INTO bigtree_route_history (`old_route`,`new_route`) VALUES ('$old_path','$path')\");\n\n\t\t\t// Update the page with its new path.\n\t\t\tsqlquery(\"UPDATE bigtree_pages SET path = '$path' WHERE id = '$page'\");\n\n\t\t\t// Update the paths of any child pages.\n\t\t\t$this->updateChildPagePaths($page);\n\t\t\t$this->track(\"bigtree_pages\",$page,\"moved\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updatePageRevision\n\t\t\t\tUpdates a page revision to save it as a favorite.\n\t\t\t\tChecks permissions.\n\n\t\t\tParameters:\n\t\t\t\tid - The page revision id.\n\t\t\t\tdescription - Saved description.\n\t\t*/\n\n\t\tfunction updatePageRevision($id,$description) {\n\t\t\t// Get the version, check if the user has access to the page the version refers to.\n\t\t\t$revision = $this->getPageRevision($id);\n\t\t\t$access = $this->getPageAccessLevel($revision[\"page\"]);\n\t\t\tif ($access != \"p\") {\n\t\t\t\t$this->stop(\"You must be a publisher to manage revisions.\");\n\t\t\t}\n\n\t\t\t// Save the version's description and saved status\n\t\t\t$description = sqlescape(htmlspecialchars($description));\n\t\t\tsqlquery(\"UPDATE bigtree_page_revisions SET saved = 'on', saved_description = '$description' WHERE id = '\".$revision[\"id\"].\"'\");\n\t\t\t$this->track(\"bigtree_page_revisions\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updatePendingChange\n\t\t\t\tUpdates a pending change.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the pending change.\n\t\t\t\tchanges - The changes to the fields in the entry.\n\t\t\t\tmtm_changes - Many to Many changes.\n\t\t\t\ttags_changes - Tags changes.\n\t\t*/\n\n\t\tfunction updatePendingChange($id,$changes,$mtm_changes = array(),$tags_changes = array()) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$changes = BigTree::json($changes,true);\n\t\t\t$mtm_changes = BigTree::json($mtm_changes,true);\n\t\t\t$tags_changes = BigTree::json($tags_changes,true);\n\n\t\t\tsqlquery(\"UPDATE bigtree_pending_changes SET changes = '$changes', mtm_changes = '$mtm_changes', tags_changes = '$tags_changes', date = NOW(), user = '\".$this->ID.\"' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_pending_changes\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateProfile\n\t\t\t\tUpdates a user's name, company, digest setting, and (optionally) password.\n\n\t\t\tParameters:\n\t\t\t\tdata - Array containing name / company / daily_digest / password.\n\t\t*/\n\n\t\tfunction updateProfile($data) {\n\t\t\tglobal $bigtree;\n\n\t\t\tforeach ($data as $key => $val) {\n\t\t\t\tif (substr($key,0,1) != \"_\" && !is_array($val)) {\n\t\t\t\t\t$$key = sqlescape($val);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$id = sqlescape($this->ID);\n\n\t\t\tif ($data[\"password\"]) {\n\t\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], TRUE);\n\t\t\t\t$password = sqlescape($phpass->HashPassword($data[\"password\"]));\n\t\t\t\tsqlquery(\"UPDATE bigtree_users SET `password` = '$password', `name` = '$name', `company` = '$company', `daily_digest` = '$daily_digest' WHERE id = '$id'\");\n\t\t\t} else {\n\t\t\t\tsqlquery(\"UPDATE bigtree_users SET `name` = '$name', `company` = '$company', `daily_digest` = '$daily_digest' WHERE id = '$id'\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateResource\n\t\t\t\tUpdates a resource.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the resource.\n\t\t\t\tattributes - A key/value array of fields to update.\n\t\t*/\n\n\t\tfunction updateResource($id,$attributes) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$fields = array();\n\t\t\tforeach ($attributes as $key => $val) {\n\t\t\t\t$fields[] = \"`$key` = '\".sqlescape($val).\"'\";\n\t\t\t}\n\t\t\tsqlquery(\"UPDATE bigtree_resources SET \".implode(\", \",$fields).\" WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_resources\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateSetting\n\t\t\t\tUpdates a setting.\n\n\t\t\tParameters:\n\t\t\t\told_id - The current id of the setting to update.\n\t\t\t\tdata - The new data for the setting (\"id\", \"type\", \"name\", \"description\", \"locked\", \"system\", \"encrypted\")\n\n\t\t\tReturns:\n\t\t\t\ttrue if successful, false if a setting exists for the new id already.\n\t\t*/\n\n\t\tfunction updateSetting($old_id,$data) {\n\t\t\tglobal $bigtree;\n\n\t\t\t// Get the existing setting information.\n\t\t\t$existing = static::getSetting($old_id);\n\t\t\t$old_id = sqlescape($existing[\"id\"]);\n\n\t\t\t// Globalize the data and clean it up.\n\t\t\tforeach ($data as $key => $val) {\n\t\t\t\tif (substr($key,0,1) != \"_\" && !is_array($val)) {\n\t\t\t\t\t$$key = sqlescape(htmlspecialchars($val));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We don't want this encoded since it's a WYSIWYG field.\n\t\t\t$description = sqlescape($data[\"description\"]);\n\n\t\t\t// Stored as JSON encoded already\n\t\t\t$options = json_decode($data[\"options\"], true);\n\n\t\t\tforeach ($options as $key => $value) {\n\t\t\t\tif ($key == \"options\" && is_string($value)) {\n\t\t\t\t\t$options[$key] = json_decode($value, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$options = BigTree::json(BigTree::translateArray($options), true);\n\n\t\t\t// See if we have an id collision with the new id.\n\t\t\tif ($old_id != $id && static::settingExists($id)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsqlquery(\"UPDATE bigtree_settings SET id = '$id', type = '$type', `options` = '$options', name = '$name', description = '$description', locked = '$locked', system = '$system', encrypted = '$encrypted' WHERE id = '$old_id'\");\n\n\t\t\t// If encryption status has changed, update the value\n\t\t\tif ($existing[\"encrypted\"] && !$encrypted) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_settings SET value = AES_DECRYPT(value,'\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') WHERE id = '$id'\");\n\t\t\t}\n\t\t\tif (!$existing[\"encrypted\"] && $encrypted) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_settings SET value = AES_ENCRYPT(value,'\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') WHERE id = '$id'\");\n\t\t\t}\n\n\t\t\t// Audit trail.\n\t\t\t$this->track(\"bigtree_settings\",$id,\"updated\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateSettingValue\n\t\t\t\tUpdates the value of a setting.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the setting to update.\n\t\t\t\tvalue - A value to set (can be a string or array).\n\t\t*/\n\n\t\tstatic function updateSettingValue($id,$value) {\n\t\t\tglobal $bigtree,$admin;\n\n\t\t\t$item = static::getSetting($id,false);\n\t\t\t$id = sqlescape(BigTreeCMS::extensionSettingCheck($id));\n\n\t\t\tif (is_array($value)) {\n\t\t\t\t$value = BigTree::translateArray($value);\n\t\t\t} else {\n\t\t\t\t$value = static::autoIPL($value);\n\t\t\t}\n\n\t\t\t$value = BigTree::json($value,true);\n\n\t\t\tif ($item[\"encrypted\"]) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_settings SET `value` = AES_ENCRYPT('$value','\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') WHERE id = '$id'\");\n\t\t\t} else {\n\t\t\t\tsqlquery(\"UPDATE bigtree_settings SET `value` = '$value' WHERE id = '$id'\");\n\t\t\t}\n\n\t\t\tif ($admin && !$item[\"system\"]) {\n\t\t\t\t// Audit trail.\n\t\t\t\t$admin->track(\"bigtree_settings\",$id,\"updated\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateTemplate\n\t\t\t\tUpdates a template.\n\n\t\t\tParameters:\n\t\t\t\tid - The id of the template to update.\n\t\t\t\tname - Name\n\t\t\t\tlevel - Access level (0 for everyone, 1 for administrators, 2 for developers)\n\t\t\t\tmodule - Related module id\n\t\t\t\tresources - An array of resources\n\t\t*/\n\n\t\tfunction updateTemplate($id,$name,$level,$module,$resources) {\n\t\t\t$clean_resources = array();\n\t\t\tforeach ($resources as $resource) {\n\t\t\t\tif ($resource[\"id\"]) {\n\t\t\t\t\t$clean_resources[] = array(\n\t\t\t\t\t\t\"id\" => BigTree::safeEncode($resource[\"id\"]),\n\t\t\t\t\t\t\"title\" => BigTree::safeEncode($resource[\"title\"]),\n\t\t\t\t\t\t\"subtitle\" => BigTree::safeEncode($resource[\"subtitle\"]),\n\t\t\t\t\t\t\"type\" => BigTree::safeEncode($resource[\"type\"]),\n\t\t\t\t\t\t\"options\" => BigTree::translateArray(json_decode($resource[\"options\"],true))\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$name = sqlescape(htmlspecialchars($name));\n\t\t\t$module = sqlescape($module);\n\t\t\t$resources = BigTree::json($clean_resources,true);\n\t\t\t$level = sqlescape($level);\n\n\t\t\tsqlquery(\"UPDATE bigtree_templates SET resources = '$resources', name = '$name', module = '$module', level = '$level' WHERE id = '$id'\");\n\t\t\t$this->track(\"bigtree_templates\",$id,\"updated\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateUser\n\t\t\t\tUpdates a user.\n\n\t\t\tParameters:\n\t\t\t\tid - The user's \"id\"\n\t\t\t\tdata - A key/value array containing email, name, company, level, permissions, alerts, daily_digest, and (optionally) password.\n\n\t\t\tReturns:\n\t\t\t\tTrue if successful. False if the logged in user doesn't have permission to change the user or there was an email collision.\n\t\t*/\n\n\t\tfunction updateUser($id,$data) {\n\t\t\tglobal $bigtree;\n\t\t\t$id = sqlescape($id);\n\n\t\t\t// See if there's an email collission\n\t\t\t$r = sqlrows(sqlquery(\"SELECT * FROM bigtree_users WHERE email = '\".sqlescape($data[\"email\"]).\"' AND id != '$id'\"));\n\t\t\tif ($r) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If this person has higher access levels than the person trying to update them, fail.\n\t\t\t$current = static::getUser($id);\n\t\t\tif ($current[\"level\"] > $this->Level) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t$level = intval($data[\"level\"]);\n\t\t\t$email = sqlescape($data[\"email\"]);\n\t\t\t$name = sqlescape(htmlspecialchars($data[\"name\"]));\n\t\t\t$company = sqlescape(htmlspecialchars($data[\"company\"]));\n\t\t\t$daily_digest = $data[\"daily_digest\"] ? \"on\" : \"\";\n\n\t\t\t$permissions = BigTree::json($data[\"permissions\"],true);\n\t\t\t$alerts = BigTree::json($data[\"alerts\"],true);\n\n\t\t\t// If the user is editing themselves, they can't change the level.\n\t\t\tif ($this->ID == $current[\"id\"]) {\n\t\t\t\t$level = $current[\"level\"];\n\t\t\t}\n\n\t\t\t// Don't allow the level to be set higher than the logged in user's level\n\t\t\tif ($level > $this->Level) {\n\t\t\t\t$level = $this->Level;\n\t\t\t}\n\n\t\t\tif ($data[\"password\"]) {\n\t\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], TRUE);\n\t\t\t\t$password = sqlescape($phpass->HashPassword(trim($data[\"password\"])));\n\t\t\t\tsqlquery(\"UPDATE bigtree_users SET `email` = '$email', `password` = '$password', `name` = '$name', `company` = '$company', `level` = '$level', `permissions` = '$permissions', `alerts` = '$alerts', `daily_digest` = '$daily_digest' WHERE id = '$id'\");\n\t\t\t} else {\n\t\t\t\tsqlquery(\"UPDATE bigtree_users SET `email` = '$email', `name` = '$name', `company` = '$company', `level` = '$level', `permissions` = '$permissions', `alerts` = '$alerts', `daily_digest` = '$daily_digest' WHERE id = '$id'\");\n\t\t\t}\n\n\t\t\t$this->track(\"bigtree_users\",$id,\"updated\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: updateUserPassword\n\t\t\t\tUpdates a user's password.\n\n\t\t\tParameters:\n\t\t\t\tid - The user's id.\n\t\t\t\tpassword - The new password.\n\t\t*/\n\n\t\tstatic function updateUserPassword($id,$password) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$id = sqlescape($id);\n\t\t\t$phpass = new PasswordHash($bigtree[\"config\"][\"password_depth\"], TRUE);\n\t\t\t$password = sqlescape($phpass->HashPassword(trim($password)));\n\t\t\tsqlquery(\"UPDATE bigtree_users SET password = '$password' WHERE id = '$id'\");\n\t\t}\n\n\t\t/*\n\t\t\tFunction: validatePassword\n\t\t\t\tValidates a password against the security policy.\n\n\t\t\tParameters:\n\t\t\t\tpassword - Password to validate.\n\n\t\t\tReturns:\n\t\t\t\ttrue if it passes all password criteria.\n\t\t*/\n\n\t\tstatic function validatePassword($password) {\n\t\t\tglobal $bigtree;\n\n\t\t\t$policy = $bigtree[\"security-policy\"][\"password\"];\n\t\t\t$failed = false;\n\n\t\t\t// Check length policy\n\t\t\tif ($policy[\"length\"] && strlen($password) < $policy[\"length\"]) {\n\t\t\t\t$failed = true;\n\t\t\t}\n\t\t\t// Check case policy\n\t\t\tif ($policy[\"multicase\"] && strtolower($password) === $password) {\n\t\t\t\t$failed = true;\n\t\t\t}\n\t\t\t// Check numeric policy\n\t\t\tif ($policy[\"numbers\"] && !preg_match(\"/[0-9]/\",$password)) {\n\t\t\t\t$failed = true;\n\t\t\t}\n\t\t\t// Check non-alphanumeric policy\n\t\t\tif ($policy[\"nonalphanumeric\"] && ctype_alnum($password)) {\n\t\t\t\t$failed = true;\n\t\t\t}\n\t\t\treturn !$failed;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: verifyCSRFToken\n\t\t\t\tVerifies the referring host and session token and stops processing if they fail.\n\t\t*/\n\t\t\n\t\tfunction verifyCSRFToken() {\n\t\t\t$clean_referer = str_replace(array(\"http://\",\"https://\"),\"//\",$_SERVER[\"HTTP_REFERER\"]);\n\t\t\t$clean_domain = str_replace(array(\"http://\",\"https://\"),\"//\",DOMAIN);\n\t\t\t$token = isset($_POST[$this->CSRFTokenField]) ? $_POST[$this->CSRFTokenField] : $_GET[$this->CSRFTokenField];\n\t\t\t\n\t\t\tif (strpos($clean_referer, $clean_domain) !== 0 || $token != $this->CSRFToken) {\n\t\t\t\t$this->stop(\"Cross site request forgery detected.\");\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tFunction: versionToDecimal\n\t\t\t\tReturns a decimal number of a BigTree version for numeric comparisons.\n\n\t\t\tParameters:\n\t\t\t\tversion - BigTree version number (i.e. 4.2.0)\n\n\t\t\tReturns:\n\t\t\t\tA number\n\t\t*/\n\n\t\tstatic function versionToDecimal($version) {\n\t\t\t$pieces = explode(\".\",$version);\n\t\t\t$number = $pieces[0] * 10000;\n\t\t\tif (isset($pieces[1])) {\n\t\t\t\t$number += $pieces[1] * 100;\n\t\t\t}\n\t\t\tif (isset($pieces[2])) {\n\t\t\t\t$number += $pieces[2];\n\t\t\t}\n\t\t\treturn $number;\n\t\t}\n\t}\n"], "filenames": ["core/inc/bigtree/admin.php"], "buggy_code_start_loc": [2306], "buggy_code_end_loc": [2307], "fixing_code_start_loc": [2306], "fixing_code_end_loc": [2308], "type": "CWE-863", "message": "BigTree CMS through 4.2.18 does not prevent a user from deleting their own account. This could have security relevance because deletion was supposed to be an admin-only action, and the admin may have other tasks (such as data backups) to complete before a user is deleted.", "other": {"cve": {"id": "CVE-2017-9378", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-02T15:29:00.180", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "BigTree CMS through 4.2.18 does not prevent a user from deleting their own account. This could have security relevance because deletion was supposed to be an admin-only action, and the admin may have other tasks (such as data backups) to complete before a user is deleted."}, {"lang": "es", "value": "BigTree CMS hasta versi\u00f3n 4.2.18, impide a un usuario eliminar su propia cuenta. Esto podr\u00eda tener relevancia de seguridad porque se supon\u00eda que la eliminaci\u00f3n era una acci\u00f3n solo del administrador y el administrador puede tener otras tareas (como copias de seguridad de datos) a completar antes de que se elimine un usuario."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bigtreecms:bigtree_cms:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.2.18", "matchCriteriaId": "DF5ED7B4-C5CC-475B-8349-3F7979D7CE22"}]}]}], "references": [{"url": "https://github.com/bigtreecms/BigTree-CMS/commit/f7899701d7be91b7dc546b65e44a27b668eb3b76", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/bigtreecms/BigTree-CMS/issues/282", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/bigtreecms/BigTree-CMS/commit/f7899701d7be91b7dc546b65e44a27b668eb3b76"}}