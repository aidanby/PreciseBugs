{"buggy_code": ["# Copyright (C) 2009-2014 MongoDB Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nrequire \"digest/md5\"\nrequire \"socket\"\nrequire \"thread\"\n\nmodule BSON\n\n  # Represents object_id data.\n  #\n  # @see http://bsonspec.org/#/specification\n  #\n  # @since 2.0.0\n  class ObjectId\n    include Comparable\n    include JSON\n\n    # A object_id is type 0x07 in the BSON spec.\n    #\n    # @since 2.0.0\n    BSON_TYPE = 7.chr.force_encoding(BINARY).freeze\n\n    # Check equality of the object id with another object.\n    #\n    # @example Check if the object id is equal to the other.\n    #   object_id == other\n    #\n    # @param [ Object ] other The object to check against.\n    #\n    # @return [ true, false ] If the objects are equal.\n    #\n    # @since 2.0.0\n    def ==(other)\n      return false unless other.is_a?(ObjectId)\n      to_bson == other.to_bson\n    end\n    alias :eql? :==\n\n    # Check case equality on the object id.\n    #\n    # @example Check case equality.\n    #   object_id === other\n    #\n    # @param [ Object ] other The object to check against.\n    #\n    # @return [ true, false ] If the objects are equal in a case.\n    #\n    # @since 2.0.0\n    def ===(other)\n      return to_str === other.to_str if other.respond_to?(:to_str)\n      super\n    end\n\n    # Return the object id as a JSON hash representation.\n    #\n    # @example Get the object id as JSON.\n    #   object_id.as_json\n    #\n    # @return [ Hash ] The object id as a JSON hash.\n    #\n    # @since 2.0.0\n    def as_json(*args)\n      { \"$oid\" => to_s }\n    end\n\n    # Compare this object id with another object for use in sorting.\n    #\n    # @example Compare the object id with the other object.\n    #   object <=> other\n    #\n    # @param [ Object ] other The object to compare to.\n    #\n    # @return [ Integer ] The result of the comparison.\n    #\n    # @since 2.0.0\n    def <=>(other)\n      to_bson <=> other.to_bson\n    end\n\n    # Return the UTC time at which this ObjectId was generated. This may\n    # be used instread of a created_at timestamp since this information\n    # is always encoded in the object id.\n    #\n    # @example Get the generation time.\n    #   object_id.generation_time\n    #\n    # @return [ Time ] The time the id was generated.\n    #\n    # @since 2.0.0\n    def generation_time\n      ::Time.at(to_bson.unpack(\"N\")[0]).utc\n    end\n\n    # Get the hash value for the object id.\n    #\n    # @example Get the hash value.\n    #   object_id.hash\n    #\n    # @return [ Integer ] The hash value.\n    #\n    # @since 2.0.0\n    def hash\n      to_bson.hash\n    end\n\n    # Get a nice string for use with object inspection.\n    #\n    # @example Inspect the object id.\n    #   object_id.inspect\n    #\n    # @return [ String ] The object id in form BSON::ObjectId('id')\n    #\n    # @since 2.0.0\n    def inspect\n      \"<BSON::ObjectId:0x#{object_id} data=#{to_s}>\"\n    end\n\n    # Dump the raw bson when calling Marshal.dump.\n    #\n    # @example Dump the raw bson.\n    #   Marshal.dump(object_id)\n    #\n    # @return [ String ] The raw bson bytes.\n    #\n    # @since 2.0.0\n    def marshal_dump\n      to_bson\n    end\n\n    # Unmarshal the data into an object id.\n    #\n    # @example Unmarshal the data.\n    #   Marshal.load(data)\n    #\n    # @param [ String ] data The raw bson bytes.\n    #\n    # @return [ String ] The raw bson bytes.\n    #\n    # @since 2.0.0\n    def marshal_load(data)\n      @raw_data = data\n    end\n\n    # Get the object id as it's raw BSON data.\n    #\n    # @example Get the raw bson bytes.\n    #   object_id.to_bson\n    #\n    # @note Since Moped's BSON and MongoDB BSON before 2.0.0 have different\n    #   internal representations, we will attempt to repair the data for cases\n    #   where the object was instantiated in a non-standard way. (Like a\n    #   Marshal.load)\n    #\n    # @return [ String ] The raw bytes.\n    #\n    # @see http://bsonspec.org/#/specification\n    #\n    # @since 2.0.0\n    def to_bson(encoded = ''.force_encoding(BINARY))\n      repair if defined?(@data)\n      @raw_data ||= @@generator.next_object_id\n      encoded << @raw_data\n    end\n\n    # Get the string representation of the object id.\n    #\n    # @example Get the object id as a string.\n    #   object_id.to_s\n    #\n    # @return [ String ] The object id as a string.\n    #\n    # @since 2.0.0\n    def to_s\n      to_bson.to_hex_string.force_encoding(UTF8)\n    end\n    alias :to_str :to_s\n\n    # Raised when trying to create an object id with invalid data.\n    #\n    # @since 2.0.0\n    class Invalid < RuntimeError; end\n\n    private\n\n    def repair\n      @raw_data = @data.to_bson_object_id\n      remove_instance_variable(:@data)\n    end\n\n    class << self\n\n      # Deserialize the object id from raw BSON bytes.\n      #\n      # @example Get the object id from BSON.\n      #   ObjectId.from_bson(bson)\n      #\n      # @param [ String ] bson The raw BSON bytes.\n      #\n      # @return [ BSON::ObjectId ] The object id.\n      #\n      # @since 2.0.0\n      def from_bson(bson)\n        from_data(bson.read(12))\n      end\n\n      # Create a new object id from raw bytes.\n      #\n      # @example Create an object id from raw bytes.\n      #   BSON::ObjectId.from_data(data)\n      #\n      # @param [ String ] data The raw bytes.\n      #\n      # @return [ ObjectId ] The new object id.\n      #\n      # @since 2.0.0\n      def from_data(data)\n        object_id = allocate\n        object_id.instance_variable_set(:@raw_data, data)\n        object_id\n      end\n\n      # Create a new object id from a string.\n      #\n      # @example Create an object id from the string.\n      #   BSON::ObjectId.from_string(id)\n      #\n      # @param [ String ] string The string to create the id from.\n      #\n      # @raise [ BSON::ObjectId::Invalid ] If the provided string is invalid.\n      #\n      # @return [ BSON::ObjectId ] The new object id.\n      #\n      # @since 2.0.0\n      def from_string(string)\n        unless legal?(string)\n          raise Invalid.new(\"'#{string}' is an invalid ObjectId.\")\n        end\n        from_data([ string ].pack(\"H*\"))\n      end\n\n      # Create a new object id from a time.\n      #\n      # @example Create an object id from a time.\n      #   BSON::ObjectId.from_id(time)\n      #\n      # @example Create an object id from a time, ensuring uniqueness.\n      #   BSON::ObjectId.from_id(time, unique: true)\n      #\n      # @param [ Time ] time The time to generate from.\n      # @param [ Hash ] options The options.\n      #\n      # @option options [ true, false ] :unique Whether the id should be\n      #   unique.\n      #\n      # @return [ ObjectId ] The new object id.\n      #\n      # @since 2.0.0\n      def from_time(time, options = {})\n        from_data(options[:unique] ? @@generator.next_object_id(time.to_i) : [ time.to_i ].pack(\"Nx8\"))\n      end\n\n      # Determine if the provided string is a legal object id.\n      #\n      # @example Is the string a legal object id?\n      #   BSON::ObjectId.legal?(string)\n      #\n      # @param [ String ] The string to check.\n      #\n      # @return [ true, false ] If the string is legal.\n      #\n      # @since 2.0.0\n      def legal?(string)\n        string.to_s =~ /^[0-9a-f]{24}$/i ? true : false\n      end\n\n      # Executes the provided block only if the size of the provided object is\n      # 12. Used in legacy id repairs.\n      #\n      # @example Execute in a repairing block.\n      #   BSON::ObjectId.repair(\"test\") { obj }\n      #\n      # @param [ String, Array ] object The object to repair.\n      #\n      # @raise [ Invalid ] If the array is not 12 elements.\n      #\n      # @return [ String ] The result of the block.\n      #\n      # @since 2.0.0\n      def repair(object)\n        if object.size == 12\n          block_given? ? yield(object) : object\n        else\n          raise Invalid.new(\"#{object.inspect} is not a valid object id.\")\n        end\n      end\n    end\n\n    # Inner class that encapsulates the behaviour of actually generating each\n    # part of the ObjectId.\n    #\n    # @api private\n    #\n    # @since 2.0.0\n    class Generator\n\n      # @!attribute machine_id\n      #   @return [ String ] The unique machine id.\n      #   @since 2.0.0\n      attr_reader :machine_id\n\n      # Instantiate the new object id generator. Will set the machine id once\n      # on the initial instantiation.\n      #\n      # @example Instantiate the generator.\n      #   BSON::ObjectId::Generator.new\n      #\n      # @since 2.0.0\n      def initialize\n        @counter = 0\n        @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(\"N\")[0]\n        @mutex = Mutex.new\n      end\n\n      # Return object id data based on the current time, incrementing the\n      # object id counter. Will use the provided time if not nil.\n      #\n      # @example Get the next object id data.\n      #   generator.next_object_id\n      #\n      # @param [ Time ] time The optional time to generate with.\n      #\n      # @return [ String ] The raw object id bytes.\n      #\n      # @since 2.0.0\n      def next_object_id(time = nil)\n        @mutex.lock\n        begin\n          count = @counter = (@counter + 1) % 0xFFFFFF\n        ensure\n          @mutex.unlock rescue nil\n        end\n        generate(time || ::Time.new.to_i, count)\n      end\n\n      # Generate object id data for a given time using the provided counter.\n      #\n      # @example Generate the object id bytes.\n      #   generator.generate(time)\n      #\n      # @param [ Integer ] time The time since epoch in seconds.\n      # @param [ Integer ] counter The optional counter.\n      #\n      # @return [ String ] The raw object id bytes.\n      #\n      # @since 2.0.0\n      def generate(time, counter = 0)\n        [ time, machine_id, process_id, counter << 8 ].pack(\"N NX lXX NX\")\n      end\n\n      private\n\n      if Environment.jruby?\n        def process_id\n          \"#{Process.pid}#{Thread.current.object_id}\".hash % 0xFFFF\n        end\n      else\n        def process_id\n          Process.pid % 0xFFFF\n        end\n      end\n    end\n\n    # We keep one global generator for object ids.\n    #\n    # @since 2.0.0\n    @@generator = Generator.new\n\n    # Register this type when the module is loaded.\n    #\n    # @since 2.0.0\n    Registry.register(BSON_TYPE, self)\n  end\nend\n"], "fixing_code": ["# Copyright (C) 2009-2014 MongoDB Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nrequire \"digest/md5\"\nrequire \"socket\"\nrequire \"thread\"\n\nmodule BSON\n\n  # Represents object_id data.\n  #\n  # @see http://bsonspec.org/#/specification\n  #\n  # @since 2.0.0\n  class ObjectId\n    include Comparable\n    include JSON\n\n    # A object_id is type 0x07 in the BSON spec.\n    #\n    # @since 2.0.0\n    BSON_TYPE = 7.chr.force_encoding(BINARY).freeze\n\n    # Check equality of the object id with another object.\n    #\n    # @example Check if the object id is equal to the other.\n    #   object_id == other\n    #\n    # @param [ Object ] other The object to check against.\n    #\n    # @return [ true, false ] If the objects are equal.\n    #\n    # @since 2.0.0\n    def ==(other)\n      return false unless other.is_a?(ObjectId)\n      to_bson == other.to_bson\n    end\n    alias :eql? :==\n\n    # Check case equality on the object id.\n    #\n    # @example Check case equality.\n    #   object_id === other\n    #\n    # @param [ Object ] other The object to check against.\n    #\n    # @return [ true, false ] If the objects are equal in a case.\n    #\n    # @since 2.0.0\n    def ===(other)\n      return to_str === other.to_str if other.respond_to?(:to_str)\n      super\n    end\n\n    # Return the object id as a JSON hash representation.\n    #\n    # @example Get the object id as JSON.\n    #   object_id.as_json\n    #\n    # @return [ Hash ] The object id as a JSON hash.\n    #\n    # @since 2.0.0\n    def as_json(*args)\n      { \"$oid\" => to_s }\n    end\n\n    # Compare this object id with another object for use in sorting.\n    #\n    # @example Compare the object id with the other object.\n    #   object <=> other\n    #\n    # @param [ Object ] other The object to compare to.\n    #\n    # @return [ Integer ] The result of the comparison.\n    #\n    # @since 2.0.0\n    def <=>(other)\n      to_bson <=> other.to_bson\n    end\n\n    # Return the UTC time at which this ObjectId was generated. This may\n    # be used instread of a created_at timestamp since this information\n    # is always encoded in the object id.\n    #\n    # @example Get the generation time.\n    #   object_id.generation_time\n    #\n    # @return [ Time ] The time the id was generated.\n    #\n    # @since 2.0.0\n    def generation_time\n      ::Time.at(to_bson.unpack(\"N\")[0]).utc\n    end\n\n    # Get the hash value for the object id.\n    #\n    # @example Get the hash value.\n    #   object_id.hash\n    #\n    # @return [ Integer ] The hash value.\n    #\n    # @since 2.0.0\n    def hash\n      to_bson.hash\n    end\n\n    # Get a nice string for use with object inspection.\n    #\n    # @example Inspect the object id.\n    #   object_id.inspect\n    #\n    # @return [ String ] The object id in form BSON::ObjectId('id')\n    #\n    # @since 2.0.0\n    def inspect\n      \"<BSON::ObjectId:0x#{object_id} data=#{to_s}>\"\n    end\n\n    # Dump the raw bson when calling Marshal.dump.\n    #\n    # @example Dump the raw bson.\n    #   Marshal.dump(object_id)\n    #\n    # @return [ String ] The raw bson bytes.\n    #\n    # @since 2.0.0\n    def marshal_dump\n      to_bson\n    end\n\n    # Unmarshal the data into an object id.\n    #\n    # @example Unmarshal the data.\n    #   Marshal.load(data)\n    #\n    # @param [ String ] data The raw bson bytes.\n    #\n    # @return [ String ] The raw bson bytes.\n    #\n    # @since 2.0.0\n    def marshal_load(data)\n      @raw_data = data\n    end\n\n    # Get the object id as it's raw BSON data.\n    #\n    # @example Get the raw bson bytes.\n    #   object_id.to_bson\n    #\n    # @note Since Moped's BSON and MongoDB BSON before 2.0.0 have different\n    #   internal representations, we will attempt to repair the data for cases\n    #   where the object was instantiated in a non-standard way. (Like a\n    #   Marshal.load)\n    #\n    # @return [ String ] The raw bytes.\n    #\n    # @see http://bsonspec.org/#/specification\n    #\n    # @since 2.0.0\n    def to_bson(encoded = ''.force_encoding(BINARY))\n      repair if defined?(@data)\n      @raw_data ||= @@generator.next_object_id\n      encoded << @raw_data\n    end\n\n    # Get the string representation of the object id.\n    #\n    # @example Get the object id as a string.\n    #   object_id.to_s\n    #\n    # @return [ String ] The object id as a string.\n    #\n    # @since 2.0.0\n    def to_s\n      to_bson.to_hex_string.force_encoding(UTF8)\n    end\n    alias :to_str :to_s\n\n    # Raised when trying to create an object id with invalid data.\n    #\n    # @since 2.0.0\n    class Invalid < RuntimeError; end\n\n    private\n\n    def repair\n      @raw_data = @data.to_bson_object_id\n      remove_instance_variable(:@data)\n    end\n\n    class << self\n\n      # Deserialize the object id from raw BSON bytes.\n      #\n      # @example Get the object id from BSON.\n      #   ObjectId.from_bson(bson)\n      #\n      # @param [ String ] bson The raw BSON bytes.\n      #\n      # @return [ BSON::ObjectId ] The object id.\n      #\n      # @since 2.0.0\n      def from_bson(bson)\n        from_data(bson.read(12))\n      end\n\n      # Create a new object id from raw bytes.\n      #\n      # @example Create an object id from raw bytes.\n      #   BSON::ObjectId.from_data(data)\n      #\n      # @param [ String ] data The raw bytes.\n      #\n      # @return [ ObjectId ] The new object id.\n      #\n      # @since 2.0.0\n      def from_data(data)\n        object_id = allocate\n        object_id.instance_variable_set(:@raw_data, data)\n        object_id\n      end\n\n      # Create a new object id from a string.\n      #\n      # @example Create an object id from the string.\n      #   BSON::ObjectId.from_string(id)\n      #\n      # @param [ String ] string The string to create the id from.\n      #\n      # @raise [ BSON::ObjectId::Invalid ] If the provided string is invalid.\n      #\n      # @return [ BSON::ObjectId ] The new object id.\n      #\n      # @since 2.0.0\n      def from_string(string)\n        unless legal?(string)\n          raise Invalid.new(\"'#{string}' is an invalid ObjectId.\")\n        end\n        from_data([ string ].pack(\"H*\"))\n      end\n\n      # Create a new object id from a time.\n      #\n      # @example Create an object id from a time.\n      #   BSON::ObjectId.from_id(time)\n      #\n      # @example Create an object id from a time, ensuring uniqueness.\n      #   BSON::ObjectId.from_id(time, unique: true)\n      #\n      # @param [ Time ] time The time to generate from.\n      # @param [ Hash ] options The options.\n      #\n      # @option options [ true, false ] :unique Whether the id should be\n      #   unique.\n      #\n      # @return [ ObjectId ] The new object id.\n      #\n      # @since 2.0.0\n      def from_time(time, options = {})\n        from_data(options[:unique] ? @@generator.next_object_id(time.to_i) : [ time.to_i ].pack(\"Nx8\"))\n      end\n\n      # Determine if the provided string is a legal object id.\n      #\n      # @example Is the string a legal object id?\n      #   BSON::ObjectId.legal?(string)\n      #\n      # @param [ String ] The string to check.\n      #\n      # @return [ true, false ] If the string is legal.\n      #\n      # @since 2.0.0\n      def legal?(string)\n        string.to_s =~ /\\A[0-9a-f]{24}\\z/i ? true : false\n      end\n\n      # Executes the provided block only if the size of the provided object is\n      # 12. Used in legacy id repairs.\n      #\n      # @example Execute in a repairing block.\n      #   BSON::ObjectId.repair(\"test\") { obj }\n      #\n      # @param [ String, Array ] object The object to repair.\n      #\n      # @raise [ Invalid ] If the array is not 12 elements.\n      #\n      # @return [ String ] The result of the block.\n      #\n      # @since 2.0.0\n      def repair(object)\n        if object.size == 12\n          block_given? ? yield(object) : object\n        else\n          raise Invalid.new(\"#{object.inspect} is not a valid object id.\")\n        end\n      end\n    end\n\n    # Inner class that encapsulates the behaviour of actually generating each\n    # part of the ObjectId.\n    #\n    # @api private\n    #\n    # @since 2.0.0\n    class Generator\n\n      # @!attribute machine_id\n      #   @return [ String ] The unique machine id.\n      #   @since 2.0.0\n      attr_reader :machine_id\n\n      # Instantiate the new object id generator. Will set the machine id once\n      # on the initial instantiation.\n      #\n      # @example Instantiate the generator.\n      #   BSON::ObjectId::Generator.new\n      #\n      # @since 2.0.0\n      def initialize\n        @counter = 0\n        @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(\"N\")[0]\n        @mutex = Mutex.new\n      end\n\n      # Return object id data based on the current time, incrementing the\n      # object id counter. Will use the provided time if not nil.\n      #\n      # @example Get the next object id data.\n      #   generator.next_object_id\n      #\n      # @param [ Time ] time The optional time to generate with.\n      #\n      # @return [ String ] The raw object id bytes.\n      #\n      # @since 2.0.0\n      def next_object_id(time = nil)\n        @mutex.lock\n        begin\n          count = @counter = (@counter + 1) % 0xFFFFFF\n        ensure\n          @mutex.unlock rescue nil\n        end\n        generate(time || ::Time.new.to_i, count)\n      end\n\n      # Generate object id data for a given time using the provided counter.\n      #\n      # @example Generate the object id bytes.\n      #   generator.generate(time)\n      #\n      # @param [ Integer ] time The time since epoch in seconds.\n      # @param [ Integer ] counter The optional counter.\n      #\n      # @return [ String ] The raw object id bytes.\n      #\n      # @since 2.0.0\n      def generate(time, counter = 0)\n        [ time, machine_id, process_id, counter << 8 ].pack(\"N NX lXX NX\")\n      end\n\n      private\n\n      if Environment.jruby?\n        def process_id\n          \"#{Process.pid}#{Thread.current.object_id}\".hash % 0xFFFF\n        end\n      else\n        def process_id\n          Process.pid % 0xFFFF\n        end\n      end\n    end\n\n    # We keep one global generator for object ids.\n    #\n    # @since 2.0.0\n    @@generator = Generator.new\n\n    # Register this type when the module is loaded.\n    #\n    # @since 2.0.0\n    Registry.register(BSON_TYPE, self)\n  end\nend\n"], "filenames": ["lib/bson/object_id.rb"], "buggy_code_start_loc": [285], "buggy_code_end_loc": [286], "fixing_code_start_loc": [285], "fixing_code_end_loc": [286], "type": "CWE-400", "message": "The Moped::BSON::ObjecId.legal? method in mongodb/bson-ruby before 3.0.4 as used in rubygem-moped allows remote attackers to cause a denial of service (worker resource consumption) via a crafted string. NOTE: This issue is due to an incomplete fix to CVE-2015-4410.", "other": {"cve": {"id": "CVE-2015-4411", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-20T17:15:12.680", "lastModified": "2020-02-28T15:32:21.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Moped::BSON::ObjecId.legal? method in mongodb/bson-ruby before 3.0.4 as used in rubygem-moped allows remote attackers to cause a denial of service (worker resource consumption) via a crafted string. NOTE: This issue is due to an incomplete fix to CVE-2015-4410."}, {"lang": "es", "value": "El m\u00e9todo Moped::BSON::ObjecId.legal? en mongodb/bson-ruby, versiones anteriores a 3.0.4, como es usado en rubygem-moped, permite a atacantes remotos causar una denegaci\u00f3n de servicio (consumo de recursos de worker) por medio de una cadena dise\u00f1ada. NOTA: Este problema es debido a una correcci\u00f3n incompleta de CVE-2015-4410."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mongodb:bson:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "3.0.4", "matchCriteriaId": "3D6E20AF-0A66-4CD0-BEA4-88CB0A2D7C94"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:21:*:*:*:*:*:*:*", "matchCriteriaId": "56BDB5A0-0839-4A20-A003-B8CD56F48171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:22:*:*:*:*:*:*:*", "matchCriteriaId": "253C303A-E577-4488-93E6-68A8DD942C38"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-July/161964.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-July/161987.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/06/06/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/75045", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1229706", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/mongodb/bson-ruby/commit/976da329ff03ecdfca3030eb6efe3c85e6db9999", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/mongodb/bson-ruby/commit/fef6f75413511d653c76bf924a932374a183a24f#diff-8c8558c185bbb548ccb5a6d6ac4bfee5R191", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/mongodb/bson-ruby/compare/7446d7c6764dfda8dc4480ce16d5c023e74be5ca...28f34978a85b689a4480b4d343389bf4886522e7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/mongoid/moped/commit/dd5a7c14b5d2e466f7875d079af71ad19774609b#diff-3b93602f64c2fe46d38efd9f73ef5358R24", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://homakov.blogspot.ru/2012/05/saferweb-injects-in-various-ruby.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://sakurity.com/blog/2015/06/04/mongo_ruby_regexp.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://seclists.org/oss-sec/2015/q2/653", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2015-4411", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.securityfocus.com/bid/75045", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/mongodb/bson-ruby/commit/976da329ff03ecdfca3030eb6efe3c85e6db9999"}}