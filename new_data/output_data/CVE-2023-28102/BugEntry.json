{"buggy_code": ["# frozen_string_literal: true\n\n# This makes opus an optional dependency\nbegin\n  require 'opus-ruby'\n  OPUS_AVAILABLE = true\nrescue LoadError\n  OPUS_AVAILABLE = false\nend\n\n# Discord voice chat support\nmodule Discordrb::Voice\n  # This class conveniently abstracts opus and ffmpeg/avconv, for easy implementation of voice sending. It's not very\n  # useful for most users, but I guess it can be useful sometimes.\n  class Encoder\n    # Whether or not avconv should be used instead of ffmpeg. If possible, it is recommended to use ffmpeg instead,\n    # as it is better supported.\n    # @return [true, false] whether avconv should be used instead of ffmpeg.\n    attr_accessor :use_avconv\n\n    # @see VoiceBot#filter_volume=\n    # @return [Integer] the volume used as a filter to ffmpeg/avconv.\n    attr_accessor :filter_volume\n\n    # Create a new encoder\n    def initialize\n      sample_rate = 48_000\n      frame_size = 960\n      channels = 2\n      @filter_volume = 1\n\n      raise LoadError, 'Opus unavailable - voice not supported! Please install opus for voice support to work.' unless OPUS_AVAILABLE\n\n      @opus = Opus::Encoder.new(sample_rate, frame_size, channels)\n    end\n\n    # Set the opus encoding bitrate\n    # @param value [Integer] The new bitrate to use, in bits per second (so 64000 if you want 64 kbps)\n    def bitrate=(value)\n      @opus.bitrate = value\n    end\n\n    # Encodes the given buffer using opus.\n    # @param buffer [String] An unencoded PCM (s16le) buffer.\n    # @return [String] A buffer encoded using opus.\n    def encode(buffer)\n      @opus.encode(buffer, 1920)\n    end\n\n    # One frame of complete silence Opus encoded\n    OPUS_SILENCE = [0xF8, 0xFF, 0xFE].pack('C*').freeze\n\n    # Adjusts the volume of a given buffer of s16le PCM data.\n    # @param buf [String] An unencoded PCM (s16le) buffer.\n    # @param mult [Float] The volume multiplier, 1 for same volume.\n    # @return [String] The buffer with adjusted volume, s16le again\n    def adjust_volume(buf, mult)\n      # We don't need to adjust anything if the buf is nil so just return in that case\n      return unless buf\n\n      # buf is s16le so use 's<' for signed, 16 bit, LE\n      result = buf.unpack('s<*').map do |sample|\n        sample *= mult\n\n        # clamp to s16 range\n        [32_767, [-32_768, sample].max].min\n      end\n\n      # After modification, make it s16le again\n      result.pack('s<*')\n    end\n\n    # Encodes a given file (or rather, decodes it) using ffmpeg. This accepts pretty much any format, even videos with\n    # an audio track. For a list of supported formats, see https://ffmpeg.org/general.html#Audio-Codecs. It even accepts\n    # URLs, though encoding them is pretty slow - I recommend to make a stream of it and then use {#encode_io} instead.\n    # @param file [String] The path or URL to encode.\n    # @param options [String] ffmpeg options to pass after the -i flag\n    # @return [IO] the audio, encoded as s16le PCM\n    def encode_file(file, options = '')\n      command = \"#{ffmpeg_command} -loglevel 0 -i \\\"#{file}\\\" #{options} -f s16le -ar 48000 -ac 2 #{filter_volume_argument} pipe:1\"\n      IO.popen(command)\n    end\n\n    # Encodes an arbitrary IO audio stream using ffmpeg. Accepts pretty much any media format, even videos with audio\n    # tracks. For a list of supported audio formats, see https://ffmpeg.org/general.html#Audio-Codecs.\n    # @param io [IO] The stream to encode.\n    # @param options [String] ffmpeg options to pass after the -i flag\n    # @return [IO] the audio, encoded as s16le PCM\n    def encode_io(io, options = '')\n      command = \"#{ffmpeg_command} -loglevel 0 -i - #{options} -f s16le -ar 48000 -ac 2 #{filter_volume_argument} pipe:1\"\n      IO.popen(command, in: io)\n    end\n\n    private\n\n    def ffmpeg_command\n      @use_avconv ? 'avconv' : 'ffmpeg'\n    end\n\n    def filter_volume_argument\n      return '' if @filter_volume == 1\n\n      @use_avconv ? \"-vol #{(@filter_volume * 256).ceil}\" : \"-af volume=#{@filter_volume}\"\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\n# This makes opus an optional dependency\nbegin\n  require 'opus-ruby'\n  OPUS_AVAILABLE = true\nrescue LoadError\n  OPUS_AVAILABLE = false\nend\n\n# Discord voice chat support\nmodule Discordrb::Voice\n  # This class conveniently abstracts opus and ffmpeg/avconv, for easy implementation of voice sending. It's not very\n  # useful for most users, but I guess it can be useful sometimes.\n  class Encoder\n    # Whether or not avconv should be used instead of ffmpeg. If possible, it is recommended to use ffmpeg instead,\n    # as it is better supported.\n    # @return [true, false] whether avconv should be used instead of ffmpeg.\n    attr_accessor :use_avconv\n\n    # @see VoiceBot#filter_volume=\n    # @return [Integer] the volume used as a filter to ffmpeg/avconv.\n    attr_accessor :filter_volume\n\n    # Create a new encoder\n    def initialize\n      sample_rate = 48_000\n      frame_size = 960\n      channels = 2\n      @filter_volume = 1\n\n      raise LoadError, 'Opus unavailable - voice not supported! Please install opus for voice support to work.' unless OPUS_AVAILABLE\n\n      @opus = Opus::Encoder.new(sample_rate, frame_size, channels)\n    end\n\n    # Set the opus encoding bitrate\n    # @param value [Integer] The new bitrate to use, in bits per second (so 64000 if you want 64 kbps)\n    def bitrate=(value)\n      @opus.bitrate = value\n    end\n\n    # Encodes the given buffer using opus.\n    # @param buffer [String] An unencoded PCM (s16le) buffer.\n    # @return [String] A buffer encoded using opus.\n    def encode(buffer)\n      @opus.encode(buffer, 1920)\n    end\n\n    # One frame of complete silence Opus encoded\n    OPUS_SILENCE = [0xF8, 0xFF, 0xFE].pack('C*').freeze\n\n    # Adjusts the volume of a given buffer of s16le PCM data.\n    # @param buf [String] An unencoded PCM (s16le) buffer.\n    # @param mult [Float] The volume multiplier, 1 for same volume.\n    # @return [String] The buffer with adjusted volume, s16le again\n    def adjust_volume(buf, mult)\n      # We don't need to adjust anything if the buf is nil so just return in that case\n      return unless buf\n\n      # buf is s16le so use 's<' for signed, 16 bit, LE\n      result = buf.unpack('s<*').map do |sample|\n        sample *= mult\n\n        # clamp to s16 range\n        [32_767, [-32_768, sample].max].min\n      end\n\n      # After modification, make it s16le again\n      result.pack('s<*')\n    end\n\n    # Encodes a given file (or rather, decodes it) using ffmpeg. This accepts pretty much any format, even videos with\n    # an audio track. For a list of supported formats, see https://ffmpeg.org/general.html#Audio-Codecs. It even accepts\n    # URLs, though encoding them is pretty slow - I recommend to make a stream of it and then use {#encode_io} instead.\n    # @param file [String] The path or URL to encode.\n    # @param options [String] ffmpeg options to pass after the -i flag\n    # @return [IO] the audio, encoded as s16le PCM\n    def encode_file(file, options = '')\n      command = ffmpeg_command(input: file, options: options)\n      IO.popen(command)\n    end\n\n    # Encodes an arbitrary IO audio stream using ffmpeg. Accepts pretty much any media format, even videos with audio\n    # tracks. For a list of supported audio formats, see https://ffmpeg.org/general.html#Audio-Codecs.\n    # @param io [IO] The stream to encode.\n    # @param options [String] ffmpeg options to pass after the -i flag\n    # @return [IO] the audio, encoded as s16le PCM\n    def encode_io(io, options = '')\n      command = ffmpeg_command(options: options)\n      IO.popen(command, in: io)\n    end\n\n    private\n\n    def ffmpeg_command(input: '-', options: null)\n      [\n        @use_avconv ? 'avconv' : 'ffmpeg',\n        '-loglevel', '0',\n        '-i', input,\n        '-f', 's16le',\n        '-ar', '48000',\n        '-ac', '2',\n        'pipe:1',\n        filter_volume_argument,\n      ].concat(options.split).reject {|segment| segment.nil? || segment == '' }\n    end\n\n    def filter_volume_argument\n      return '' if @filter_volume == 1\n\n      @use_avconv ? \"-vol #{(@filter_volume * 256).ceil}\" : \"-af volume=#{@filter_volume}\"\n    end\n  end\nend\n"], "filenames": ["lib/discordrb/voice/encoder.rb"], "buggy_code_start_loc": [80], "buggy_code_end_loc": [98], "fixing_code_start_loc": [80], "fixing_code_end_loc": [107], "type": "CWE-78", "message": "discordrb is an implementation of the Discord API using Ruby. In discordrb before commit `91e13043ffa` the `encoder.rb` file unsafely constructs a shell string using the file parameter, which can potentially leave clients of discordrb vulnerable to command injection. The library is not directly exploitable: the exploit requires that some client of the library calls the vulnerable method with user input. However, if unsafe input reaches the library method, then an attacker can execute arbitrary shell commands on the host machine. Full impact will depend on the permissions of the process running the `discordrb` library and will likely not be total system access. This issue has been addressed in code, but a new release of the `discordrb` gem has not been uploaded to rubygems. This issue is also tracked as `GHSL-2022-094`.", "other": {"cve": {"id": "CVE-2023-28102", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-27T22:15:22.027", "lastModified": "2023-04-03T18:36:24.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "discordrb is an implementation of the Discord API using Ruby. In discordrb before commit `91e13043ffa` the `encoder.rb` file unsafely constructs a shell string using the file parameter, which can potentially leave clients of discordrb vulnerable to command injection. The library is not directly exploitable: the exploit requires that some client of the library calls the vulnerable method with user input. However, if unsafe input reaches the library method, then an attacker can execute arbitrary shell commands on the host machine. Full impact will depend on the permissions of the process running the `discordrb` library and will likely not be total system access. This issue has been addressed in code, but a new release of the `discordrb` gem has not been uploaded to rubygems. This issue is also tracked as `GHSL-2022-094`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discordrb_project:discordrb:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "2023-03-08", "matchCriteriaId": "B00BD68A-B86C-47E5-8272-47C8237BA601"}]}]}], "references": [{"url": "https://github.com/shardlab/discordrb/commit/91e13043ffa89227c3fcdc3408f06da237d28c95", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2022-094_discordrb/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/shardlab/discordrb/commit/91e13043ffa89227c3fcdc3408f06da237d28c95"}}