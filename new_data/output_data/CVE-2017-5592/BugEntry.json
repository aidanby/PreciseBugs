{"buggy_code": ["/*\n * message.c\n *\n * Copyright (C) 2012 - 2016 James Booth <boothj5@gmail.com>\n *\n * This file is part of Profanity.\n *\n * Profanity is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Profanity is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Profanity.  If not, see <https://www.gnu.org/licenses/>.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link the code of portions of this program with the OpenSSL library under\n * certain conditions as described in each individual source file, and\n * distribute linked combinations including the two.\n *\n * You must obey the GNU General Public License in all respects for all of the\n * code used other than OpenSSL. If you modify file(s) with this exception, you\n * may extend this exception to your version of the file(s), but you are not\n * obligated to do so. If you do not wish to do so, delete this exception\n * statement from your version. If you delete this exception statement from all\n * source files in the program, then also delete it here.\n *\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef HAVE_LIBMESODE\n#include <mesode.h>\n#endif\n\n#ifdef HAVE_LIBSTROPHE\n#include <strophe.h>\n#endif\n\n#include \"profanity.h\"\n#include \"log.h\"\n#include \"config/preferences.h\"\n#include \"event/server_events.h\"\n#include \"pgp/gpg.h\"\n#include \"plugins/plugins.h\"\n#include \"ui/ui.h\"\n#include \"xmpp/chat_session.h\"\n#include \"xmpp/muc.h\"\n#include \"xmpp/session.h\"\n#include \"xmpp/message.h\"\n#include \"xmpp/roster.h\"\n#include \"xmpp/roster_list.h\"\n#include \"xmpp/stanza.h\"\n#include \"xmpp/connection.h\"\n#include \"xmpp/xmpp.h\"\n\nstatic int _message_handler(xmpp_conn_t *const conn, xmpp_stanza_t *const stanza, void *const userdata);\n\nstatic void _handle_error(xmpp_stanza_t *const stanza);\nstatic void _handle_groupchat(xmpp_stanza_t *const stanza);\nstatic void _handel_muc_user(xmpp_stanza_t *const stanza);\nstatic void _handle_conference(xmpp_stanza_t *const stanza);\nstatic void _handle_captcha(xmpp_stanza_t *const stanza);\nstatic void _handle_receipt_received(xmpp_stanza_t *const stanza);\nstatic void _handle_chat(xmpp_stanza_t *const stanza);\n\nstatic void _send_message_stanza(xmpp_stanza_t *const stanza);\n\nstatic int\n_message_handler(xmpp_conn_t *const conn, xmpp_stanza_t *const stanza, void *const userdata)\n{\n    log_debug(\"Message stanza handler fired\");\n\n    char *text;\n    size_t text_size;\n    xmpp_stanza_to_text(stanza, &text, &text_size);\n    gboolean cont = plugins_on_message_stanza_receive(text);\n    xmpp_free(connection_get_ctx(), text);\n    if (!cont) {\n        return 1;\n    }\n\n    const char *type = xmpp_stanza_get_type(stanza);\n\n    if (g_strcmp0(type, STANZA_TYPE_ERROR) == 0) {\n        _handle_error(stanza);\n    }\n\n    if (g_strcmp0(type, STANZA_TYPE_GROUPCHAT) == 0) {\n        _handle_groupchat(stanza);\n    }\n\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    if (mucuser) {\n        _handel_muc_user(stanza);\n    }\n\n    xmpp_stanza_t *conference = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    if (conference) {\n        _handle_conference(stanza);\n    }\n\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CAPTCHA);\n    if (captcha) {\n        _handle_captcha(stanza);\n    }\n\n    xmpp_stanza_t *receipts = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_RECEIPTS);\n    if (receipts) {\n        _handle_receipt_received(stanza);\n    }\n\n    _handle_chat(stanza);\n\n    return 1;\n}\n\nvoid\nmessage_handlers_init(void)\n{\n    xmpp_conn_t * const conn = connection_get_conn();\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_handler_add(conn, _message_handler, NULL, STANZA_NAME_MESSAGE, NULL, ctx);\n}\n\nchar*\nmessage_send_chat(const char *const barejid, const char *const msg, const char *const oob_url,\n    gboolean request_receipt)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *state = chat_session_get_state(barejid);\n    char *jid = chat_session_get_jid(barejid);\n    char *id = create_unique_id(\"msg\");\n\n    xmpp_stanza_t *message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, jid, id);\n    xmpp_message_set_body(message, msg);\n    free(jid);\n\n    if (state) {\n        stanza_attach_state(ctx, message, state);\n    }\n\n    if (oob_url) {\n        stanza_attach_x_oob_url(ctx, message, oob_url);\n    }\n\n    if (request_receipt) {\n        stanza_attach_receipt_request(ctx, message);\n    }\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n\n    return id;\n}\n\nchar*\nmessage_send_chat_pgp(const char *const barejid, const char *const msg, gboolean request_receipt)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *state = chat_session_get_state(barejid);\n    char *jid = chat_session_get_jid(barejid);\n    char *id = create_unique_id(\"msg\");\n\n    xmpp_stanza_t *message = NULL;\n#ifdef HAVE_LIBGPGME\n    char *account_name = session_get_account_name();\n    ProfAccount *account = accounts_get_account(account_name);\n    if (account->pgp_keyid) {\n        Jid *jidp = jid_create(jid);\n        char *encrypted = p_gpg_encrypt(jidp->barejid, msg, account->pgp_keyid);\n        if (encrypted) {\n            message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, jid, id);\n            xmpp_message_set_body(message, \"This message is encrypted.\");\n            xmpp_stanza_t *x = xmpp_stanza_new(ctx);\n            xmpp_stanza_set_name(x, STANZA_NAME_X);\n            xmpp_stanza_set_ns(x, STANZA_NS_ENCRYPTED);\n            xmpp_stanza_t *enc_st = xmpp_stanza_new(ctx);\n            xmpp_stanza_set_text(enc_st, encrypted);\n            xmpp_stanza_add_child(x, enc_st);\n            xmpp_stanza_release(enc_st);\n            xmpp_stanza_add_child(message, x);\n            xmpp_stanza_release(x);\n            free(encrypted);\n        } else {\n            message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, jid, id);\n            xmpp_message_set_body(message, msg);\n        }\n        jid_destroy(jidp);\n    } else {\n        message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, jid, id);\n        xmpp_message_set_body(message, msg);\n    }\n    account_free(account);\n#else\n    message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, jid, id);\n    xmpp_message_set_body(message, msg);\n#endif\n    free(jid);\n\n    if (state) {\n        stanza_attach_state(ctx, message, state);\n    }\n\n    if (request_receipt) {\n        stanza_attach_receipt_request(ctx, message);\n    }\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n\n    return id;\n}\n\nchar*\nmessage_send_chat_otr(const char *const barejid, const char *const msg, gboolean request_receipt)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *state = chat_session_get_state(barejid);\n    char *jid = chat_session_get_jid(barejid);\n    char *id = create_unique_id(\"msg\");\n\n    xmpp_stanza_t *message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, barejid, id);\n    xmpp_message_set_body(message, msg);\n\n    free(jid);\n\n    if (state) {\n        stanza_attach_state(ctx, message, state);\n    }\n\n    stanza_attach_carbons_private(ctx, message);\n    stanza_attach_hints_no_copy(ctx, message);\n    stanza_attach_hints_no_store(ctx, message);\n\n    if (request_receipt) {\n        stanza_attach_receipt_request(ctx, message);\n    }\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n\n    return id;\n}\n\nvoid\nmessage_send_private(const char *const fulljid, const char *const msg, const char *const oob_url)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    char *id = create_unique_id(\"prv\");\n\n    xmpp_stanza_t *message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, fulljid, id);\n    xmpp_message_set_body(message, msg);\n\n    free(id);\n\n    if (oob_url) {\n        stanza_attach_x_oob_url(ctx, message, oob_url);\n    }\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n}\n\nvoid\nmessage_send_groupchat(const char *const roomjid, const char *const msg, const char *const oob_url)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    char *id = create_unique_id(\"muc\");\n\n    xmpp_stanza_t *message = xmpp_message_new(ctx, STANZA_TYPE_GROUPCHAT, roomjid, id);\n    xmpp_message_set_body(message, msg);\n\n    free(id);\n\n    if (oob_url) {\n        stanza_attach_x_oob_url(ctx, message, oob_url);\n    }\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n}\n\nvoid\nmessage_send_groupchat_subject(const char *const roomjid, const char *const subject)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_stanza_t *message = stanza_create_room_subject_message(ctx, roomjid, subject);\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n}\n\nvoid\nmessage_send_invite(const char *const roomjid, const char *const contact,\n    const char *const reason)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_stanza_t *stanza;\n\n    muc_member_type_t member_type = muc_member_type(roomjid);\n    if (member_type == MUC_MEMBER_TYPE_PUBLIC) {\n        log_debug(\"Sending direct invite to %s, for %s\", contact, roomjid);\n        char *password = muc_password(roomjid);\n        stanza = stanza_create_invite(ctx, roomjid, contact, reason, password);\n    } else {\n        log_debug(\"Sending mediated invite to %s, for %s\", contact, roomjid);\n        stanza = stanza_create_mediated_invite(ctx, roomjid, contact, reason);\n    }\n\n    _send_message_stanza(stanza);\n    xmpp_stanza_release(stanza);\n}\n\nvoid\nmessage_send_composing(const char *const jid)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    xmpp_stanza_t *stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_COMPOSING);\n    _send_message_stanza(stanza);\n    xmpp_stanza_release(stanza);\n\n}\n\nvoid\nmessage_send_paused(const char *const jid)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_stanza_t *stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_PAUSED);\n    _send_message_stanza(stanza);\n    xmpp_stanza_release(stanza);\n}\n\nvoid\nmessage_send_inactive(const char *const jid)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_stanza_t *stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_INACTIVE);\n\n    _send_message_stanza(stanza);\n    xmpp_stanza_release(stanza);\n}\n\nvoid\nmessage_send_gone(const char *const jid)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_stanza_t *stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_GONE);\n    _send_message_stanza(stanza);\n    xmpp_stanza_release(stanza);\n}\n\nstatic void\n_handle_error(xmpp_stanza_t *const stanza)\n{\n    const char *id = xmpp_stanza_get_id(stanza);\n    const char *jid = xmpp_stanza_get_from(stanza);\n    xmpp_stanza_t *error_stanza = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_ERROR);\n    const char *type = NULL;\n    if (error_stanza) {\n        type = xmpp_stanza_get_type(error_stanza);\n    }\n\n    // stanza_get_error never returns NULL\n    char *err_msg = stanza_get_error_message(stanza);\n\n    GString *log_msg = g_string_new(\"message stanza error received\");\n    if (id) {\n        g_string_append(log_msg, \" id=\");\n        g_string_append(log_msg, id);\n    }\n    if (jid) {\n        g_string_append(log_msg, \" from=\");\n        g_string_append(log_msg, jid);\n    }\n    if (type) {\n        g_string_append(log_msg, \" type=\");\n        g_string_append(log_msg, type);\n    }\n    g_string_append(log_msg, \" error=\");\n    g_string_append(log_msg, err_msg);\n\n    log_info(log_msg->str);\n\n    g_string_free(log_msg, TRUE);\n\n    if (!jid) {\n        ui_handle_error(err_msg);\n    } else if (type && (strcmp(type, \"cancel\") == 0)) {\n        log_info(\"Recipient %s not found: %s\", jid, err_msg);\n        Jid *jidp = jid_create(jid);\n        chat_session_remove(jidp->barejid);\n        jid_destroy(jidp);\n    } else {\n        ui_handle_recipient_error(jid, err_msg);\n    }\n\n    free(err_msg);\n}\n\nstatic void\n_handel_muc_user(xmpp_stanza_t *const stanza)\n{\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_stanza_t *xns_muc_user = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    const char *room = xmpp_stanza_get_from(stanza);\n\n    if (!room) {\n        log_warning(\"Message received with no from attribute, ignoring\");\n        return;\n    }\n\n    // XEP-0045\n    xmpp_stanza_t *invite = xmpp_stanza_get_child_by_name(xns_muc_user, STANZA_NAME_INVITE);\n    if (!invite) {\n        return;\n    }\n\n    const char *invitor_jid = xmpp_stanza_get_from(invite);\n    if (!invitor_jid) {\n        log_warning(\"Chat room invite received with no from attribute\");\n        return;\n    }\n\n    Jid *jidp = jid_create(invitor_jid);\n    if (!jidp) {\n        return;\n    }\n    char *invitor = jidp->barejid;\n\n    char *reason = NULL;\n    xmpp_stanza_t *reason_st = xmpp_stanza_get_child_by_name(invite, STANZA_NAME_REASON);\n    if (reason_st) {\n        reason = xmpp_stanza_get_text(reason_st);\n    }\n\n    char *password = NULL;\n    xmpp_stanza_t *password_st = xmpp_stanza_get_child_by_name(xns_muc_user, STANZA_NAME_PASSWORD);\n    if (password_st) {\n        password = xmpp_stanza_get_text(password_st);\n    }\n\n    sv_ev_room_invite(INVITE_MEDIATED, invitor, room, reason, password);\n    jid_destroy(jidp);\n    if (reason) {\n        xmpp_free(ctx, reason);\n    }\n    if (password) {\n        xmpp_free(ctx, password);\n    }\n}\n\nstatic void\n_handle_conference(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *xns_conference = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n\n    const char *from = xmpp_stanza_get_from(stanza);\n    if (!from) {\n        log_warning(\"Message received with no from attribute, ignoring\");\n        return;\n    }\n\n    Jid *jidp = jid_create(from);\n    if (!jidp) {\n        return;\n    }\n\n    // XEP-0249\n    const char *room = xmpp_stanza_get_attribute(xns_conference, STANZA_ATTR_JID);\n    if (!room) {\n        jid_destroy(jidp);\n        return;\n    }\n\n    const char *reason = xmpp_stanza_get_attribute(xns_conference, STANZA_ATTR_REASON);\n    const char *password = xmpp_stanza_get_attribute(xns_conference, STANZA_ATTR_PASSWORD);\n\n    sv_ev_room_invite(INVITE_DIRECT, jidp->barejid, room, reason, password);\n    jid_destroy(jidp);\n}\n\nstatic void\n_handle_captcha(xmpp_stanza_t *const stanza)\n{\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    const char *from = xmpp_stanza_get_from(stanza);\n\n    if (!from) {\n        log_warning(\"Message received with no from attribute, ignoring\");\n        return;\n    }\n\n    // XEP-0158\n    char *message = xmpp_message_get_body(stanza);\n    if (!message) {\n        return;\n    }\n\n    sv_ev_room_broadcast(from, message);\n    xmpp_free(ctx, message);\n}\n\nstatic void\n_handle_groupchat(xmpp_stanza_t *const stanza)\n{\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    char *message = NULL;\n    const char *room_jid = xmpp_stanza_get_from(stanza);\n    Jid *jid = jid_create(room_jid);\n\n    // handle room subject\n    xmpp_stanza_t *subject = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_SUBJECT);\n    if (subject) {\n        message = xmpp_stanza_get_text(subject);\n        sv_ev_room_subject(jid->barejid, jid->resourcepart, message);\n        xmpp_free(ctx, message);\n\n        jid_destroy(jid);\n        return;\n    }\n\n    // handle room broadcasts\n    if (!jid->resourcepart) {\n        message = xmpp_message_get_body(stanza);\n        if (!message) {\n            jid_destroy(jid);\n            return;\n        }\n\n        sv_ev_room_broadcast(room_jid, message);\n        xmpp_free(ctx, message);\n\n        jid_destroy(jid);\n        return;\n    }\n\n    if (!jid_is_valid_room_form(jid)) {\n        log_error(\"Invalid room JID: %s\", jid->str);\n        jid_destroy(jid);\n        return;\n    }\n\n    // room not active in profanity\n    if (!muc_active(jid->barejid)) {\n        log_error(\"Message received for inactive chat room: %s\", jid->str);\n        jid_destroy(jid);\n        return;\n    }\n\n    message = xmpp_message_get_body(stanza);\n    if (!message) {\n        jid_destroy(jid);\n        return;\n    }\n\n    // determine if the notifications happened whilst offline\n    GDateTime *timestamp = stanza_get_delay(stanza);\n    if (timestamp) {\n        sv_ev_room_history(jid->barejid, jid->resourcepart, timestamp, message);\n        g_date_time_unref(timestamp);\n    } else {\n        sv_ev_room_message(jid->barejid, jid->resourcepart, message);\n    }\n\n    xmpp_free(ctx, message);\n    jid_destroy(jid);\n}\n\nvoid\n_message_send_receipt(const char *const fulljid, const char *const message_id)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *id = create_unique_id(\"receipt\");\n    xmpp_stanza_t *message = xmpp_message_new(ctx, NULL, fulljid, id);\n    free(id);\n\n    xmpp_stanza_t *receipt = xmpp_stanza_new(ctx);\n    xmpp_stanza_set_name(receipt, \"received\");\n    xmpp_stanza_set_ns(receipt, STANZA_NS_RECEIPTS);\n    xmpp_stanza_set_id(receipt, message_id);\n\n    xmpp_stanza_add_child(message, receipt);\n    xmpp_stanza_release(receipt);\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n}\n\nstatic void\n_handle_receipt_received(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *receipt = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_RECEIPTS);\n    const char *name = xmpp_stanza_get_name(receipt);\n    if (g_strcmp0(name, \"received\") != 0) {\n        return;\n    }\n\n    const char *id = xmpp_stanza_get_id(receipt);\n    if (!id) {\n        return;\n    }\n\n    const char *fulljid = xmpp_stanza_get_from(stanza);\n    if (!fulljid) {\n        return;\n    }\n\n    Jid *jidp = jid_create(fulljid);\n    sv_ev_message_receipt(jidp->barejid, id);\n    jid_destroy(jidp);\n}\n\nvoid\n_receipt_request_handler(xmpp_stanza_t *const stanza)\n{\n    if (!prefs_get_boolean(PREF_RECEIPTS_SEND)) {\n        return;\n    }\n\n    const char *id = xmpp_stanza_get_id(stanza);\n    if (!id) {\n        return;\n    }\n\n    xmpp_stanza_t *receipts = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_RECEIPTS);\n    if (!receipts) {\n        return;\n    }\n\n    const char *receipts_name = xmpp_stanza_get_name(receipts);\n    if (g_strcmp0(receipts_name, \"request\") != 0) {\n        return;\n    }\n\n    const gchar *from = xmpp_stanza_get_from(stanza);\n    Jid *jid = jid_create(from);\n    _message_send_receipt(jid->fulljid, id);\n    jid_destroy(jid);\n}\n\nvoid\n_private_chat_handler(xmpp_stanza_t *const stanza, const char *const fulljid)\n{\n    char *message = xmpp_message_get_body(stanza);\n    if (!message) {\n        return;\n    }\n\n    GDateTime *timestamp = stanza_get_delay(stanza);\n    if (timestamp) {\n        sv_ev_delayed_private_message(fulljid, message, timestamp);\n        g_date_time_unref(timestamp);\n    } else {\n        sv_ev_incoming_private_message(fulljid, message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message);\n}\n\nstatic gboolean\n_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error(\"Unable to retrieve stanza name for Carbon\");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, \"private\") == 0) {\n        log_info(\"Carbon received with private element.\");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, \"received\") != 0) && (g_strcmp0(name, \"sent\") != 0)) {\n        log_warning(\"Carbon received with unrecognised stanza name: %s\", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning(\"Carbon received with no forwarded element\");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\"Carbon received with no message element\");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\"Carbon received with no message.\");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n    Jid *my_jid = jid_create(connection_get_fulljid());\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}\n\nstatic void\n_handle_chat(xmpp_stanza_t *const stanza)\n{\n    // ignore if type not chat or absent\n    const char *type = xmpp_stanza_get_type(stanza);\n    if (!(g_strcmp0(type, \"chat\") == 0 || type == NULL)) {\n        return;\n    }\n\n    // check if carbon message\n    gboolean res = _handle_carbons(stanza);\n    if (res) {\n        return;\n    }\n\n    // ignore handled namespaces\n    xmpp_stanza_t *conf = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CAPTCHA);\n    if (conf || captcha) {\n        return;\n    }\n\n    // some clients send the mucuser namespace with private messages\n    // if the namespace exists, and the stanza contains a body element, assume its a private message\n    // otherwise exit the handler\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    xmpp_stanza_t *body = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_BODY);\n    if (mucuser && body == NULL) {\n        return;\n    }\n\n    const gchar *from = xmpp_stanza_get_from(stanza);\n    Jid *jid = jid_create(from);\n\n    // private message from chat room use full jid (room/nick)\n    if (muc_active(jid->barejid)) {\n        _private_chat_handler(stanza, jid->fulljid);\n        jid_destroy(jid);\n        return;\n    }\n\n    // standard chat message, use jid without resource\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    GDateTime *timestamp = stanza_get_delay(stanza);\n    if (body) {\n        char *message = xmpp_stanza_get_text(body);\n        if (message) {\n            char *enc_message = NULL;\n            xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_ENCRYPTED);\n            if (x) {\n                enc_message = xmpp_stanza_get_text(x);\n            }\n            sv_ev_incoming_message(jid->barejid, jid->resourcepart, message, enc_message, timestamp);\n            xmpp_free(ctx, enc_message);\n\n            _receipt_request_handler(stanza);\n\n            xmpp_free(ctx, message);\n        }\n    }\n\n    // handle chat sessions and states\n    if (!timestamp && jid->resourcepart) {\n        gboolean gone = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_GONE) != NULL;\n        gboolean typing = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_COMPOSING) != NULL;\n        gboolean paused = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_PAUSED) != NULL;\n        gboolean inactive = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_INACTIVE) != NULL;\n        if (gone) {\n            sv_ev_gone(jid->barejid, jid->resourcepart);\n        } else if (typing) {\n            sv_ev_typing(jid->barejid, jid->resourcepart);\n        } else if (paused) {\n            sv_ev_paused(jid->barejid, jid->resourcepart);\n        } else if (inactive) {\n            sv_ev_inactive(jid->barejid, jid->resourcepart);\n        } else if (stanza_contains_chat_state(stanza)) {\n            sv_ev_activity(jid->barejid, jid->resourcepart, TRUE);\n        } else {\n            sv_ev_activity(jid->barejid, jid->resourcepart, FALSE);\n        }\n    }\n\n    if (timestamp) g_date_time_unref(timestamp);\n    jid_destroy(jid);\n}\n\nstatic void\n_send_message_stanza(xmpp_stanza_t *const stanza)\n{\n    char *text;\n    size_t text_size;\n    xmpp_stanza_to_text(stanza, &text, &text_size);\n\n    xmpp_conn_t *conn = connection_get_conn();\n    char *plugin_text = plugins_on_message_stanza_send(text);\n    if (plugin_text) {\n        xmpp_send_raw_string(conn, \"%s\", plugin_text);\n        free(plugin_text);\n    } else {\n        xmpp_send_raw_string(conn, \"%s\", text);\n    }\n    xmpp_free(connection_get_ctx(), text);\n}\n", "#include <glib.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <setjmp.h>\n#include <cmocka.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <stabber.h>\n#include <expect.h>\n\n#include \"proftest.h\"\n\nvoid\nsend_enable_carbons(void **state)\n{\n    prof_connect();\n\n    prof_input(\"/carbons on\");\n\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n}\n\nvoid\nconnect_with_carbons_enabled(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n}\n\nvoid\nsend_disable_carbons(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n\n    prof_input(\"/carbons off\");\n\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><disable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n}\n\nvoid\nreceive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}\n\nvoid\nreceive_self_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='stabber@localhost'>\"\n            \"<sent xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='59' xmlns='jabber:client' type='chat' to='buddy1@localhost/mobile' lang='en' from='stabber@localhost/profanity'>\"\n                        \"<body>self sent carbon</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</sent>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"me: .+self sent carbon\"));\n}\n\nvoid\nreceive_private_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n            \"<body>Private carbon</body>\"\n            \"<private xmlns='urn:xmpp:carbons:2'/>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+Private carbon\"));\n}\n"], "fixing_code": ["/*\n * message.c\n *\n * Copyright (C) 2012 - 2016 James Booth <boothj5@gmail.com>\n *\n * This file is part of Profanity.\n *\n * Profanity is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Profanity is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Profanity.  If not, see <https://www.gnu.org/licenses/>.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link the code of portions of this program with the OpenSSL library under\n * certain conditions as described in each individual source file, and\n * distribute linked combinations including the two.\n *\n * You must obey the GNU General Public License in all respects for all of the\n * code used other than OpenSSL. If you modify file(s) with this exception, you\n * may extend this exception to your version of the file(s), but you are not\n * obligated to do so. If you do not wish to do so, delete this exception\n * statement from your version. If you delete this exception statement from all\n * source files in the program, then also delete it here.\n *\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef HAVE_LIBMESODE\n#include <mesode.h>\n#endif\n\n#ifdef HAVE_LIBSTROPHE\n#include <strophe.h>\n#endif\n\n#include \"profanity.h\"\n#include \"log.h\"\n#include \"config/preferences.h\"\n#include \"event/server_events.h\"\n#include \"pgp/gpg.h\"\n#include \"plugins/plugins.h\"\n#include \"ui/ui.h\"\n#include \"xmpp/chat_session.h\"\n#include \"xmpp/muc.h\"\n#include \"xmpp/session.h\"\n#include \"xmpp/message.h\"\n#include \"xmpp/roster.h\"\n#include \"xmpp/roster_list.h\"\n#include \"xmpp/stanza.h\"\n#include \"xmpp/connection.h\"\n#include \"xmpp/xmpp.h\"\n\nstatic int _message_handler(xmpp_conn_t *const conn, xmpp_stanza_t *const stanza, void *const userdata);\n\nstatic void _handle_error(xmpp_stanza_t *const stanza);\nstatic void _handle_groupchat(xmpp_stanza_t *const stanza);\nstatic void _handel_muc_user(xmpp_stanza_t *const stanza);\nstatic void _handle_conference(xmpp_stanza_t *const stanza);\nstatic void _handle_captcha(xmpp_stanza_t *const stanza);\nstatic void _handle_receipt_received(xmpp_stanza_t *const stanza);\nstatic void _handle_chat(xmpp_stanza_t *const stanza);\n\nstatic void _send_message_stanza(xmpp_stanza_t *const stanza);\n\nstatic int\n_message_handler(xmpp_conn_t *const conn, xmpp_stanza_t *const stanza, void *const userdata)\n{\n    log_debug(\"Message stanza handler fired\");\n\n    char *text;\n    size_t text_size;\n    xmpp_stanza_to_text(stanza, &text, &text_size);\n    gboolean cont = plugins_on_message_stanza_receive(text);\n    xmpp_free(connection_get_ctx(), text);\n    if (!cont) {\n        return 1;\n    }\n\n    const char *type = xmpp_stanza_get_type(stanza);\n\n    if (g_strcmp0(type, STANZA_TYPE_ERROR) == 0) {\n        _handle_error(stanza);\n    }\n\n    if (g_strcmp0(type, STANZA_TYPE_GROUPCHAT) == 0) {\n        _handle_groupchat(stanza);\n    }\n\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    if (mucuser) {\n        _handel_muc_user(stanza);\n    }\n\n    xmpp_stanza_t *conference = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    if (conference) {\n        _handle_conference(stanza);\n    }\n\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CAPTCHA);\n    if (captcha) {\n        _handle_captcha(stanza);\n    }\n\n    xmpp_stanza_t *receipts = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_RECEIPTS);\n    if (receipts) {\n        _handle_receipt_received(stanza);\n    }\n\n    _handle_chat(stanza);\n\n    return 1;\n}\n\nvoid\nmessage_handlers_init(void)\n{\n    xmpp_conn_t * const conn = connection_get_conn();\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_handler_add(conn, _message_handler, NULL, STANZA_NAME_MESSAGE, NULL, ctx);\n}\n\nchar*\nmessage_send_chat(const char *const barejid, const char *const msg, const char *const oob_url,\n    gboolean request_receipt)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *state = chat_session_get_state(barejid);\n    char *jid = chat_session_get_jid(barejid);\n    char *id = create_unique_id(\"msg\");\n\n    xmpp_stanza_t *message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, jid, id);\n    xmpp_message_set_body(message, msg);\n    free(jid);\n\n    if (state) {\n        stanza_attach_state(ctx, message, state);\n    }\n\n    if (oob_url) {\n        stanza_attach_x_oob_url(ctx, message, oob_url);\n    }\n\n    if (request_receipt) {\n        stanza_attach_receipt_request(ctx, message);\n    }\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n\n    return id;\n}\n\nchar*\nmessage_send_chat_pgp(const char *const barejid, const char *const msg, gboolean request_receipt)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *state = chat_session_get_state(barejid);\n    char *jid = chat_session_get_jid(barejid);\n    char *id = create_unique_id(\"msg\");\n\n    xmpp_stanza_t *message = NULL;\n#ifdef HAVE_LIBGPGME\n    char *account_name = session_get_account_name();\n    ProfAccount *account = accounts_get_account(account_name);\n    if (account->pgp_keyid) {\n        Jid *jidp = jid_create(jid);\n        char *encrypted = p_gpg_encrypt(jidp->barejid, msg, account->pgp_keyid);\n        if (encrypted) {\n            message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, jid, id);\n            xmpp_message_set_body(message, \"This message is encrypted.\");\n            xmpp_stanza_t *x = xmpp_stanza_new(ctx);\n            xmpp_stanza_set_name(x, STANZA_NAME_X);\n            xmpp_stanza_set_ns(x, STANZA_NS_ENCRYPTED);\n            xmpp_stanza_t *enc_st = xmpp_stanza_new(ctx);\n            xmpp_stanza_set_text(enc_st, encrypted);\n            xmpp_stanza_add_child(x, enc_st);\n            xmpp_stanza_release(enc_st);\n            xmpp_stanza_add_child(message, x);\n            xmpp_stanza_release(x);\n            free(encrypted);\n        } else {\n            message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, jid, id);\n            xmpp_message_set_body(message, msg);\n        }\n        jid_destroy(jidp);\n    } else {\n        message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, jid, id);\n        xmpp_message_set_body(message, msg);\n    }\n    account_free(account);\n#else\n    message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, jid, id);\n    xmpp_message_set_body(message, msg);\n#endif\n    free(jid);\n\n    if (state) {\n        stanza_attach_state(ctx, message, state);\n    }\n\n    if (request_receipt) {\n        stanza_attach_receipt_request(ctx, message);\n    }\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n\n    return id;\n}\n\nchar*\nmessage_send_chat_otr(const char *const barejid, const char *const msg, gboolean request_receipt)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *state = chat_session_get_state(barejid);\n    char *jid = chat_session_get_jid(barejid);\n    char *id = create_unique_id(\"msg\");\n\n    xmpp_stanza_t *message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, barejid, id);\n    xmpp_message_set_body(message, msg);\n\n    free(jid);\n\n    if (state) {\n        stanza_attach_state(ctx, message, state);\n    }\n\n    stanza_attach_carbons_private(ctx, message);\n    stanza_attach_hints_no_copy(ctx, message);\n    stanza_attach_hints_no_store(ctx, message);\n\n    if (request_receipt) {\n        stanza_attach_receipt_request(ctx, message);\n    }\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n\n    return id;\n}\n\nvoid\nmessage_send_private(const char *const fulljid, const char *const msg, const char *const oob_url)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    char *id = create_unique_id(\"prv\");\n\n    xmpp_stanza_t *message = xmpp_message_new(ctx, STANZA_TYPE_CHAT, fulljid, id);\n    xmpp_message_set_body(message, msg);\n\n    free(id);\n\n    if (oob_url) {\n        stanza_attach_x_oob_url(ctx, message, oob_url);\n    }\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n}\n\nvoid\nmessage_send_groupchat(const char *const roomjid, const char *const msg, const char *const oob_url)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    char *id = create_unique_id(\"muc\");\n\n    xmpp_stanza_t *message = xmpp_message_new(ctx, STANZA_TYPE_GROUPCHAT, roomjid, id);\n    xmpp_message_set_body(message, msg);\n\n    free(id);\n\n    if (oob_url) {\n        stanza_attach_x_oob_url(ctx, message, oob_url);\n    }\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n}\n\nvoid\nmessage_send_groupchat_subject(const char *const roomjid, const char *const subject)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_stanza_t *message = stanza_create_room_subject_message(ctx, roomjid, subject);\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n}\n\nvoid\nmessage_send_invite(const char *const roomjid, const char *const contact,\n    const char *const reason)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_stanza_t *stanza;\n\n    muc_member_type_t member_type = muc_member_type(roomjid);\n    if (member_type == MUC_MEMBER_TYPE_PUBLIC) {\n        log_debug(\"Sending direct invite to %s, for %s\", contact, roomjid);\n        char *password = muc_password(roomjid);\n        stanza = stanza_create_invite(ctx, roomjid, contact, reason, password);\n    } else {\n        log_debug(\"Sending mediated invite to %s, for %s\", contact, roomjid);\n        stanza = stanza_create_mediated_invite(ctx, roomjid, contact, reason);\n    }\n\n    _send_message_stanza(stanza);\n    xmpp_stanza_release(stanza);\n}\n\nvoid\nmessage_send_composing(const char *const jid)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    xmpp_stanza_t *stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_COMPOSING);\n    _send_message_stanza(stanza);\n    xmpp_stanza_release(stanza);\n\n}\n\nvoid\nmessage_send_paused(const char *const jid)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_stanza_t *stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_PAUSED);\n    _send_message_stanza(stanza);\n    xmpp_stanza_release(stanza);\n}\n\nvoid\nmessage_send_inactive(const char *const jid)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_stanza_t *stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_INACTIVE);\n\n    _send_message_stanza(stanza);\n    xmpp_stanza_release(stanza);\n}\n\nvoid\nmessage_send_gone(const char *const jid)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_stanza_t *stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_GONE);\n    _send_message_stanza(stanza);\n    xmpp_stanza_release(stanza);\n}\n\nstatic void\n_handle_error(xmpp_stanza_t *const stanza)\n{\n    const char *id = xmpp_stanza_get_id(stanza);\n    const char *jid = xmpp_stanza_get_from(stanza);\n    xmpp_stanza_t *error_stanza = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_ERROR);\n    const char *type = NULL;\n    if (error_stanza) {\n        type = xmpp_stanza_get_type(error_stanza);\n    }\n\n    // stanza_get_error never returns NULL\n    char *err_msg = stanza_get_error_message(stanza);\n\n    GString *log_msg = g_string_new(\"message stanza error received\");\n    if (id) {\n        g_string_append(log_msg, \" id=\");\n        g_string_append(log_msg, id);\n    }\n    if (jid) {\n        g_string_append(log_msg, \" from=\");\n        g_string_append(log_msg, jid);\n    }\n    if (type) {\n        g_string_append(log_msg, \" type=\");\n        g_string_append(log_msg, type);\n    }\n    g_string_append(log_msg, \" error=\");\n    g_string_append(log_msg, err_msg);\n\n    log_info(log_msg->str);\n\n    g_string_free(log_msg, TRUE);\n\n    if (!jid) {\n        ui_handle_error(err_msg);\n    } else if (type && (strcmp(type, \"cancel\") == 0)) {\n        log_info(\"Recipient %s not found: %s\", jid, err_msg);\n        Jid *jidp = jid_create(jid);\n        chat_session_remove(jidp->barejid);\n        jid_destroy(jidp);\n    } else {\n        ui_handle_recipient_error(jid, err_msg);\n    }\n\n    free(err_msg);\n}\n\nstatic void\n_handel_muc_user(xmpp_stanza_t *const stanza)\n{\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_stanza_t *xns_muc_user = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    const char *room = xmpp_stanza_get_from(stanza);\n\n    if (!room) {\n        log_warning(\"Message received with no from attribute, ignoring\");\n        return;\n    }\n\n    // XEP-0045\n    xmpp_stanza_t *invite = xmpp_stanza_get_child_by_name(xns_muc_user, STANZA_NAME_INVITE);\n    if (!invite) {\n        return;\n    }\n\n    const char *invitor_jid = xmpp_stanza_get_from(invite);\n    if (!invitor_jid) {\n        log_warning(\"Chat room invite received with no from attribute\");\n        return;\n    }\n\n    Jid *jidp = jid_create(invitor_jid);\n    if (!jidp) {\n        return;\n    }\n    char *invitor = jidp->barejid;\n\n    char *reason = NULL;\n    xmpp_stanza_t *reason_st = xmpp_stanza_get_child_by_name(invite, STANZA_NAME_REASON);\n    if (reason_st) {\n        reason = xmpp_stanza_get_text(reason_st);\n    }\n\n    char *password = NULL;\n    xmpp_stanza_t *password_st = xmpp_stanza_get_child_by_name(xns_muc_user, STANZA_NAME_PASSWORD);\n    if (password_st) {\n        password = xmpp_stanza_get_text(password_st);\n    }\n\n    sv_ev_room_invite(INVITE_MEDIATED, invitor, room, reason, password);\n    jid_destroy(jidp);\n    if (reason) {\n        xmpp_free(ctx, reason);\n    }\n    if (password) {\n        xmpp_free(ctx, password);\n    }\n}\n\nstatic void\n_handle_conference(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *xns_conference = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n\n    const char *from = xmpp_stanza_get_from(stanza);\n    if (!from) {\n        log_warning(\"Message received with no from attribute, ignoring\");\n        return;\n    }\n\n    Jid *jidp = jid_create(from);\n    if (!jidp) {\n        return;\n    }\n\n    // XEP-0249\n    const char *room = xmpp_stanza_get_attribute(xns_conference, STANZA_ATTR_JID);\n    if (!room) {\n        jid_destroy(jidp);\n        return;\n    }\n\n    const char *reason = xmpp_stanza_get_attribute(xns_conference, STANZA_ATTR_REASON);\n    const char *password = xmpp_stanza_get_attribute(xns_conference, STANZA_ATTR_PASSWORD);\n\n    sv_ev_room_invite(INVITE_DIRECT, jidp->barejid, room, reason, password);\n    jid_destroy(jidp);\n}\n\nstatic void\n_handle_captcha(xmpp_stanza_t *const stanza)\n{\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    const char *from = xmpp_stanza_get_from(stanza);\n\n    if (!from) {\n        log_warning(\"Message received with no from attribute, ignoring\");\n        return;\n    }\n\n    // XEP-0158\n    char *message = xmpp_message_get_body(stanza);\n    if (!message) {\n        return;\n    }\n\n    sv_ev_room_broadcast(from, message);\n    xmpp_free(ctx, message);\n}\n\nstatic void\n_handle_groupchat(xmpp_stanza_t *const stanza)\n{\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    char *message = NULL;\n    const char *room_jid = xmpp_stanza_get_from(stanza);\n    Jid *jid = jid_create(room_jid);\n\n    // handle room subject\n    xmpp_stanza_t *subject = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_SUBJECT);\n    if (subject) {\n        message = xmpp_stanza_get_text(subject);\n        sv_ev_room_subject(jid->barejid, jid->resourcepart, message);\n        xmpp_free(ctx, message);\n\n        jid_destroy(jid);\n        return;\n    }\n\n    // handle room broadcasts\n    if (!jid->resourcepart) {\n        message = xmpp_message_get_body(stanza);\n        if (!message) {\n            jid_destroy(jid);\n            return;\n        }\n\n        sv_ev_room_broadcast(room_jid, message);\n        xmpp_free(ctx, message);\n\n        jid_destroy(jid);\n        return;\n    }\n\n    if (!jid_is_valid_room_form(jid)) {\n        log_error(\"Invalid room JID: %s\", jid->str);\n        jid_destroy(jid);\n        return;\n    }\n\n    // room not active in profanity\n    if (!muc_active(jid->barejid)) {\n        log_error(\"Message received for inactive chat room: %s\", jid->str);\n        jid_destroy(jid);\n        return;\n    }\n\n    message = xmpp_message_get_body(stanza);\n    if (!message) {\n        jid_destroy(jid);\n        return;\n    }\n\n    // determine if the notifications happened whilst offline\n    GDateTime *timestamp = stanza_get_delay(stanza);\n    if (timestamp) {\n        sv_ev_room_history(jid->barejid, jid->resourcepart, timestamp, message);\n        g_date_time_unref(timestamp);\n    } else {\n        sv_ev_room_message(jid->barejid, jid->resourcepart, message);\n    }\n\n    xmpp_free(ctx, message);\n    jid_destroy(jid);\n}\n\nvoid\n_message_send_receipt(const char *const fulljid, const char *const message_id)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *id = create_unique_id(\"receipt\");\n    xmpp_stanza_t *message = xmpp_message_new(ctx, NULL, fulljid, id);\n    free(id);\n\n    xmpp_stanza_t *receipt = xmpp_stanza_new(ctx);\n    xmpp_stanza_set_name(receipt, \"received\");\n    xmpp_stanza_set_ns(receipt, STANZA_NS_RECEIPTS);\n    xmpp_stanza_set_id(receipt, message_id);\n\n    xmpp_stanza_add_child(message, receipt);\n    xmpp_stanza_release(receipt);\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n}\n\nstatic void\n_handle_receipt_received(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *receipt = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_RECEIPTS);\n    const char *name = xmpp_stanza_get_name(receipt);\n    if (g_strcmp0(name, \"received\") != 0) {\n        return;\n    }\n\n    const char *id = xmpp_stanza_get_id(receipt);\n    if (!id) {\n        return;\n    }\n\n    const char *fulljid = xmpp_stanza_get_from(stanza);\n    if (!fulljid) {\n        return;\n    }\n\n    Jid *jidp = jid_create(fulljid);\n    sv_ev_message_receipt(jidp->barejid, id);\n    jid_destroy(jidp);\n}\n\nvoid\n_receipt_request_handler(xmpp_stanza_t *const stanza)\n{\n    if (!prefs_get_boolean(PREF_RECEIPTS_SEND)) {\n        return;\n    }\n\n    const char *id = xmpp_stanza_get_id(stanza);\n    if (!id) {\n        return;\n    }\n\n    xmpp_stanza_t *receipts = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_RECEIPTS);\n    if (!receipts) {\n        return;\n    }\n\n    const char *receipts_name = xmpp_stanza_get_name(receipts);\n    if (g_strcmp0(receipts_name, \"request\") != 0) {\n        return;\n    }\n\n    const gchar *from = xmpp_stanza_get_from(stanza);\n    Jid *jid = jid_create(from);\n    _message_send_receipt(jid->fulljid, id);\n    jid_destroy(jid);\n}\n\nvoid\n_private_chat_handler(xmpp_stanza_t *const stanza, const char *const fulljid)\n{\n    char *message = xmpp_message_get_body(stanza);\n    if (!message) {\n        return;\n    }\n\n    GDateTime *timestamp = stanza_get_delay(stanza);\n    if (timestamp) {\n        sv_ev_delayed_private_message(fulljid, message, timestamp);\n        g_date_time_unref(timestamp);\n    } else {\n        sv_ev_incoming_private_message(fulljid, message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message);\n}\n\nstatic gboolean\n_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error(\"Unable to retrieve stanza name for Carbon\");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, \"private\") == 0) {\n        log_info(\"Carbon received with private element.\");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, \"received\") != 0) && (g_strcmp0(name, \"sent\") != 0)) {\n        log_warning(\"Carbon received with unrecognised stanza name: %s\", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning(\"Carbon received with no forwarded element\");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\"Carbon received with no message element\");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\"Carbon received with no message.\");\n        return TRUE;\n    }\n\n    Jid *my_jid = jid_create(connection_get_fulljid());\n    const char *const stanza_from = xmpp_stanza_get_from(stanza);\n    Jid *msg_jid = jid_create(stanza_from);\n    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {\n        log_warning(\"Invalid carbon received, from: %s\", stanza_from);\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}\n\nstatic void\n_handle_chat(xmpp_stanza_t *const stanza)\n{\n    // ignore if type not chat or absent\n    const char *type = xmpp_stanza_get_type(stanza);\n    if (!(g_strcmp0(type, \"chat\") == 0 || type == NULL)) {\n        return;\n    }\n\n    // check if carbon message\n    gboolean res = _handle_carbons(stanza);\n    if (res) {\n        return;\n    }\n\n    // ignore handled namespaces\n    xmpp_stanza_t *conf = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CAPTCHA);\n    if (conf || captcha) {\n        return;\n    }\n\n    // some clients send the mucuser namespace with private messages\n    // if the namespace exists, and the stanza contains a body element, assume its a private message\n    // otherwise exit the handler\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    xmpp_stanza_t *body = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_BODY);\n    if (mucuser && body == NULL) {\n        return;\n    }\n\n    const gchar *from = xmpp_stanza_get_from(stanza);\n    Jid *jid = jid_create(from);\n\n    // private message from chat room use full jid (room/nick)\n    if (muc_active(jid->barejid)) {\n        _private_chat_handler(stanza, jid->fulljid);\n        jid_destroy(jid);\n        return;\n    }\n\n    // standard chat message, use jid without resource\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    GDateTime *timestamp = stanza_get_delay(stanza);\n    if (body) {\n        char *message = xmpp_stanza_get_text(body);\n        if (message) {\n            char *enc_message = NULL;\n            xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_ENCRYPTED);\n            if (x) {\n                enc_message = xmpp_stanza_get_text(x);\n            }\n            sv_ev_incoming_message(jid->barejid, jid->resourcepart, message, enc_message, timestamp);\n            xmpp_free(ctx, enc_message);\n\n            _receipt_request_handler(stanza);\n\n            xmpp_free(ctx, message);\n        }\n    }\n\n    // handle chat sessions and states\n    if (!timestamp && jid->resourcepart) {\n        gboolean gone = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_GONE) != NULL;\n        gboolean typing = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_COMPOSING) != NULL;\n        gboolean paused = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_PAUSED) != NULL;\n        gboolean inactive = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_INACTIVE) != NULL;\n        if (gone) {\n            sv_ev_gone(jid->barejid, jid->resourcepart);\n        } else if (typing) {\n            sv_ev_typing(jid->barejid, jid->resourcepart);\n        } else if (paused) {\n            sv_ev_paused(jid->barejid, jid->resourcepart);\n        } else if (inactive) {\n            sv_ev_inactive(jid->barejid, jid->resourcepart);\n        } else if (stanza_contains_chat_state(stanza)) {\n            sv_ev_activity(jid->barejid, jid->resourcepart, TRUE);\n        } else {\n            sv_ev_activity(jid->barejid, jid->resourcepart, FALSE);\n        }\n    }\n\n    if (timestamp) g_date_time_unref(timestamp);\n    jid_destroy(jid);\n}\n\nstatic void\n_send_message_stanza(xmpp_stanza_t *const stanza)\n{\n    char *text;\n    size_t text_size;\n    xmpp_stanza_to_text(stanza, &text, &text_size);\n\n    xmpp_conn_t *conn = connection_get_conn();\n    char *plugin_text = plugins_on_message_stanza_send(text);\n    if (plugin_text) {\n        xmpp_send_raw_string(conn, \"%s\", plugin_text);\n        free(plugin_text);\n    } else {\n        xmpp_send_raw_string(conn, \"%s\", text);\n    }\n    xmpp_free(connection_get_ctx(), text);\n}\n", "#include <glib.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <setjmp.h>\n#include <cmocka.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <stabber.h>\n#include <expect.h>\n\n#include \"proftest.h\"\n\nvoid\nsend_enable_carbons(void **state)\n{\n    prof_connect();\n\n    prof_input(\"/carbons on\");\n\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n}\n\nvoid\nconnect_with_carbons_enabled(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n}\n\nvoid\nsend_disable_carbons(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n\n    prof_input(\"/carbons off\");\n\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><disable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n}\n\nvoid\nreceive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='stabber@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}\n\nvoid\nreceive_self_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='stabber@localhost'>\"\n            \"<sent xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='59' xmlns='jabber:client' type='chat' to='buddy1@localhost/mobile' lang='en' from='stabber@localhost/profanity'>\"\n                        \"<body>self sent carbon</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</sent>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"me: .+self sent carbon\"));\n}\n\nvoid\nreceive_private_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n            \"<body>Private carbon</body>\"\n            \"<private xmlns='urn:xmpp:carbons:2'/>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+Private carbon\"));\n}\n"], "filenames": ["src/xmpp/message.c", "tests/functionaltests/test_carbons.c"], "buggy_code_start_loc": [716, 73], "buggy_code_end_loc": [726, 74], "fixing_code_start_loc": [717, 73], "fixing_code_end_loc": [732, 74], "type": "CWE-20", "message": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for profanity (0.4.7 - 0.5.0).", "other": {"cve": {"id": "CVE-2017-5592", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-09T20:59:00.293", "lastModified": "2020-01-23T18:29:56.687", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for profanity (0.4.7 - 0.5.0)."}, {"lang": "es", "value": "Una implementaci\u00f3n incorrecta de \"XEP-0280: Message Carbons\" en m\u00faltiples clientes XMPP permite a un atacante remoto personificar cualquier usuario, incluidos los contactos, en la pantalla de la aplicaci\u00f3n vulnerable. Esto permite varios tipos de ataques de ingenier\u00eda social. Esta CVE es para profanity (0.4.7 - 0.5.0)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-346"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:profanity_project:profanity:0.4.7:-:*:*:*:*:*:*", "matchCriteriaId": "F4C9F9D7-C8EC-44E4-A55B-06A4AD0F03F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:profanity_project:profanity:0.4.7:cyg1:*:*:*:*:*:*", "matchCriteriaId": "B3D0DE23-B7EE-4644-A9E8-7A97385132A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:profanity_project:profanity:0.4.7:cyg2:*:*:*:*:*:*", "matchCriteriaId": "7610BDB4-D5C8-4333-BD4B-6ADF4EC7B421"}, {"vulnerable": true, "criteria": "cpe:2.3:a:profanity_project:profanity:0.4.7:cyg3:*:*:*:*:*:*", "matchCriteriaId": "4F7A6765-DBEC-4984-B702-B798D72A665C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:profanity_project:profanity:0.4.7:patch1:*:*:*:*:*:*", "matchCriteriaId": "0945DFD2-C235-4E44-BD50-1C1F9D1C15D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:profanity_project:profanity:0.5.0:-:*:*:*:*:*:*", "matchCriteriaId": "6639BA25-1467-462A-82DD-9E62103CC42E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:profanity_project:profanity:0.5.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "CF8A3688-A998-4619-B1BC-828DD5871A28"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2017/02/09/29", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96173", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/boothj5/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://rt-solutions.de/en/2017/02/CVE-2017-5589_xmpp_carbons/", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://rt-solutions.de/wp-content/uploads/2017/02/CVE-2017-5589_xmpp_carbons.pdf", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/boothj5/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b"}}