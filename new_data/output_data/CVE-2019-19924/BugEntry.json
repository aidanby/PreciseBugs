{"buggy_code": ["C Detect\\sthe\\sinvalid\\suse\\sof\\sNULLS\\sLAST\\son\\san\\sINTEGER\\sPRIMARY\\sKEY\\sdefinition\\nof\\sa\\sWITHOUT\\sROWID\\stable.\nD 2019-12-19T17:42:27.314\nF .fossil-settings/empty-dirs dbb81e8fc0401ac46a1491ab34a7f2c7c0452f2f06b54ebb845d024ca8283ef1\nF .fossil-settings/ignore-glob 35175cdfcf539b2318cb04a9901442804be81cd677d8b889fcc9149c21f239ea\nF LICENSE.md df5091916dbb40e6e9686186587125e1b2ff51f022cc334e886c19a0e9982724\nF Makefile.in d3a862c9742f5a08230a3b295c0a47fd3067f19356dc39935280135f90474b04\nF Makefile.linux-gcc f609543700659711fbd230eced1f01353117621dccae7b9fb70daa64236c5241\nF Makefile.msc 0b0acbf34bb238170bdf1fd343a1fd37bc81c042ce029c1cc53fe15b5d4ed07b\nF README.md 1514a365ffca3c138e00c5cc839906108a01011a6b082bad19b09781e3aa498a\nF VERSION 081500f0aeaadc989d85aafbc717af45512018aebc73d89e5c2368fe62a600ff\nF aclocal.m4 a5c22d164aff7ed549d53a90fa56d56955281f50\nF art/sqlite370.eps aa97a671332b432a54e1d74ff5e8775be34200c2\nF art/sqlite370.ico af56c1d00fee7cd4753e8631ed60703ed0fc6e90\nF art/sqlite370.jpg d512473dae7e378a67e28ff96a34da7cb331def2\nF autoconf/INSTALL 83e4a25da9fd053c7b3665eaaaf7919707915903\nF autoconf/Makefile.am e14b629addaa1ce372b72043f28f40de2e32b7e211b6e0fc18dbb87989197e40\nF autoconf/Makefile.fallback 22fe523eb36dfce31e0f6349f782eb084e86a5620b2b0b4f84a2d6133f53f5ac\nF autoconf/Makefile.msc 492ea431c411378094593a5225b9a02645455a5d87a26d018b5461b723e52125\nF autoconf/README.first 6c4f34fe115ff55d4e8dbfa3cecf04a0188292f7\nF autoconf/README.txt 4f04b0819303aabaa35fff5f7b257fb0c1ef95f1\nF autoconf/configure.ac 308de24343e76ecfbe9a67f8fcd4c5216b790d230c5d9ce10210b7d5965d6192\nF autoconf/tea/Makefile.in b438a7020446c8a8156e8d97c8914a04833da6fd\nF autoconf/tea/README 3e9a3c060f29a44344ab50aec506f4db903fb873\nF autoconf/tea/aclocal.m4 52c47aac44ce0ddb1f918b6993e8beb8eee88f43\nF autoconf/tea/configure.ac 8aa16e3f0a5ca7959d4af198f46934ec187d395f\nF autoconf/tea/doc/sqlite3.n e1fe45d4f5286ee3d0ccc877aca2a0def488e9bb\nF autoconf/tea/license.terms 13bd403c9610fd2b76ece0ab50c4c5eda933d523\nF autoconf/tea/pkgIndex.tcl.in 3ef61715cf1c7bdcff56947ffadb26bc991ca39d\nF autoconf/tea/tclconfig/install-sh bdd5e293591621ae60d9824d86a4b1c5f22c3d00\nF autoconf/tea/tclconfig/tcl.m4 66ddf0a5d5e4b1d29bff472c0985fd7fa89d0fb5\nF autoconf/tea/win/makefile.vc f89d0184d0eee5f7e356ea407964dcd139939928\nF autoconf/tea/win/nmakehlp.c 247538ad8e8c508f33c03ec1fbd67d3a07ef6291\nF autoconf/tea/win/rules.vc c511f222b80064096b705dbeb97060ee1d6b6d63\nF config.guess 883205ddf25b46f10c181818bf42c09da9888884af96f79e1719264345053bd6\nF config.h.in 6376abec766e9a0785178b1823b5a587e9f1ccbc\nF config.sub c2d0260f17f3e4bc0b6808fccf1b291cb5e9126c14fc5890efc77b9fd0175559\nF configure fdc9f8d53360170679349d8f72fb2e5c79f511424891b7bb8a2f48de41c7a6ef x\nF configure.ac 3552d3aecade98a9d4b64bceb48ffb7726cbc85902efde956812942f060fbd0a\nF contrib/sqlitecon.tcl 210a913ad63f9f991070821e599d600bd913e0ad\nF doc/F2FS.txt c1d4a0ae9711cfe0e1d8b019d154f1c29e0d3abfe820787ba1e9ed7691160fcd\nF doc/lemon.html 24956ab2995e55fe171e55bdd04f22b553957dc8bb43501dbb9311e30187e0d3\nF doc/pager-invariants.txt 27fed9a70ddad2088750c4a2b493b63853da2710\nF doc/vfs-shm.txt e101f27ea02a8387ce46a05be2b1a902a021d37a\nF ext/README.md fd5f78013b0a2bc6f0067afb19e6ad040e89a10179b4f6f03eee58fac5f169bd\nF ext/async/README.txt e12275968f6fde133a80e04387d0e839b0c51f91\nF ext/async/sqlite3async.c 0f3070cc3f5ede78f2b9361fb3b629ce200d7d74\nF ext/async/sqlite3async.h f489b080af7e72aec0e1ee6f1d98ab6cf2e4dcef\nF ext/expert/README.md b321c2762bb93c18ea102d5a5f7753a4b8bac646cb392b3b437f633caf2020c3\nF ext/expert/expert.c d548d603a4cc9e61f446cc179c120c6713511c413f82a4a32b1e1e69d3f086a4\nF ext/expert/expert1.test e2afc53a27610e8251e44c7f961806607a5490ff204b3db342740d558e052662\nF ext/expert/sqlite3expert.c 3da865f2286433588260f41e796422c611bceaca3a0bbf9139a619cf7d062c19\nF ext/expert/sqlite3expert.h ca81efc2679a92373a13a3e76a6138d0310e32be53d6c3bfaedabd158ea8969b\nF ext/expert/test_expert.c d56c194b769bdc90cf829a14c9ecbc1edca9c850b837a4d0b13be14095c32a72\nF ext/fts1/README.txt 20ac73b006a70bcfd80069bdaf59214b6cf1db5e\nF ext/fts1/ft_hash.c 3927bd880e65329bdc6f506555b228b28924921b\nF ext/fts1/ft_hash.h 06df7bba40dadd19597aa400a875dbc2fed705ea\nF ext/fts1/fts1.c a39f7d21c2994d27c959ef9c3505c81542c81432\nF ext/fts1/fts1.h 6060b8f62c1d925ea8356cb1a6598073eb9159a6\nF ext/fts1/fts1_hash.c 3196cee866edbebb1c0521e21672e6d599965114\nF ext/fts1/fts1_hash.h e7f0d761353996a8175eda351104acfde23afcb0\nF ext/fts1/fts1_porter.c b1c7304b8988ba3f764a147cdd32043b4913ea7b\nF ext/fts1/fts1_tokenizer.h fdea722c38a9f82ed921642981234f666e47919c\nF ext/fts1/fts1_tokenizer1.c fd00d1fe4dc30dfc5c64cba695ce34f4af20d2fa\nF ext/fts1/fulltext.c 37698e1909584f6d8ea67d1485e3ad39dbf42d19\nF ext/fts1/fulltext.h 08525a47852d1d62a0be81d3fc3fe2d23b094efd\nF ext/fts1/simple_tokenizer.c bbfa4e3b2a26ef17d4edc6d98cd4a3f5396d998a\nF ext/fts1/tokenizer.h 0c53421b832366d20d720d21ea3e1f6e66a36ef9\nF ext/fts2/README.tokenizers 21e3684ea5a095b55d70f6878b4ce6af5932dfb7\nF ext/fts2/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts2/fts2.c 72c816a9ae448049fbbe8f18a85698765fc7956c\nF ext/fts2/fts2.h da5f76c65163301d1068a971fd32f4119e3c95fa\nF ext/fts2/fts2_hash.c 011a1d32de45bb1b519a1fd0048e857d6a843558\nF ext/fts2/fts2_hash.h 1824b99dfd8d0225facbdb26a2c87289b2e7dcf8\nF ext/fts2/fts2_icu.c 51c5cd3c04954badd329fa738c95fcdb717b5188\nF ext/fts2/fts2_porter.c 2cd4a507bf3c3085fe66f59b0f2a325f65aaacf5\nF ext/fts2/fts2_tokenizer.c b529493d55e55497213c37e1f31680a77746be26\nF ext/fts2/fts2_tokenizer.h 27a1a99ca2d615cf7e142839b8d79e8751b4529e\nF ext/fts2/fts2_tokenizer1.c 07e223eecb483d448313b5f1553a4f299a7fb7a1\nF ext/fts2/mkfts2amal.tcl 974d5d438cb3f7c4a652639262f82418c1e4cff0\nF ext/fts3/README.content fdc666a70d5257a64fee209f97cf89e0e6e32b51\nF ext/fts3/README.syntax a19711dc5458c20734b8e485e75fb1981ec2427a\nF ext/fts3/README.tokenizers b92bdeb8b46503f0dd301d364efc5ef59ef9fa8e2758b8e742f39fa93a2e422d\nF ext/fts3/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts3/fts3.c a05938725571651cc9bedc63a52ede4b39277fec17884c8ff6011dab2ff78c75\nF ext/fts3/fts3.h 3a10a0af180d502cecc50df77b1b22df142817fe\nF ext/fts3/fts3Int.h f091030b976045e7df91af2337935952b477cdbd9f48058c44c965684484cb50\nF ext/fts3/fts3_aux.c 96708c8b3a7d9b8ca1b68ea2b7e503e283f20e95f145becadedfad096dbd0f34\nF ext/fts3/fts3_expr.c b132af223e90e35b9f9efa9fe63d6ae737d34153a3b6066736086df8abc78a1f\nF ext/fts3/fts3_hash.c 8b6e31bfb0844c27dc6092c2620bdb1fca17ed613072db057d96952c6bdb48b7\nF ext/fts3/fts3_hash.h 39cf6874dc239d6b4e30479b1975fe5b22a3caaf\nF ext/fts3/fts3_icu.c 305ce7fb6036484085b5556a9c8e62acdc7763f0f4cdf5fd538212a9f3720116\nF ext/fts3/fts3_porter.c 3565faf04b626cddf85f03825e86056a4562c009\nF ext/fts3/fts3_snippet.c d62e40baa6a200586c3a425478109418f44926b1c318c870b59a4286afbe2795\nF ext/fts3/fts3_term.c f45a1e7c6ef464abb1231245d123dae12266b69e05cc56e14045b76591ae92d1\nF ext/fts3/fts3_test.c 73b16e229e517c1b1f0fb8e1046182a4e5dbc8dbe6eea8a5d4353fcce7dbbf39\nF ext/fts3/fts3_tokenize_vtab.c 1de9a61acfa2a0445ed989310c31839c57f6b6086dd9d5c97177ae734a17fd8b\nF ext/fts3/fts3_tokenizer.c a1ca0ab7c9c688ccb1d605645809f74f5df2bf4ca568e4bb37fb51113fd78e45\nF ext/fts3/fts3_tokenizer.h 64c6ef6c5272c51ebe60fc607a896e84288fcbc3\nF ext/fts3/fts3_tokenizer1.c 5c98225a53705e5ee34824087478cf477bdb7004\nF ext/fts3/fts3_unicode.c 4b9af6151c29b35ed09574937083cece7c31e911f69615e168a39677569b684d\nF ext/fts3/fts3_unicode2.c 416eb7e1e81142703520d284b768ca2751d40e31fa912cae24ba74860532bf0f\nF ext/fts3/fts3_write.c 51e0a4e3782ee17b6dd5e89949b7095fc98e36e87725c53de631734535507498\nF ext/fts3/fts3speed.tcl b54caf6a18d38174f1a6e84219950d85e98bb1e9\nF ext/fts3/mkfts3amal.tcl 252ecb7fe6467854f2aa237bf2c390b74e71f100\nF ext/fts3/tool/fts3cov.sh c331d006359456cf6f8f953e37f2b9c7d568f3863f00bb5f7eb87fea4ac01b73\nF ext/fts3/tool/fts3view.c 202801a2056995b763864d60c2dee744d46f1677\nF ext/fts3/unicode/CaseFolding.txt 8c678ca52ecc95e16bc7afc2dbf6fc9ffa05db8c\nF ext/fts3/unicode/UnicodeData.txt cd07314edb62d49fde34debdaf92fa2aa69011e7\nF ext/fts3/unicode/mkunicode.tcl bf7fcaa6d68e6d38223467983785d054f1cff4d9e3905dd51f6ed8801bb590d5\nF ext/fts3/unicode/parseunicode.tcl a981bd6466d12dd17967515801c3ff23f74a281be1a03cf1e6f52a6959fc77eb\nF ext/fts5/extract_api_docs.tcl a36e54ec777172ddd3f9a88daf593b00848368e0\nF ext/fts5/fts5.h c132a9323f22a972c4c93a8d5a3d901113a6e612faf30ca8e695788438c5ca2a\nF ext/fts5/fts5Int.h d7cbc214ee167496f70905667e18f73ea0402f7ef09236ce305e117e0efc866a\nF ext/fts5/fts5_aux.c dcc627d8b6e3fc773db528ff67b39955dab7b51628f9dba8e15849e5bedfd7fa\nF ext/fts5/fts5_buffer.c 5a5fe0159752c0fb0a5a93c722e9db2662822709490769d482b76a6dc8aaca70\nF ext/fts5/fts5_config.c b447948f35ad3354e8fe5e242e0a7e7b5b941555400b9404259944e3aa570037\nF ext/fts5/fts5_expr.c 2be456484786333d559dc2987a00f2750981fab91d52db8452a8046278c5f22e\nF ext/fts5/fts5_hash.c 1cc0095646f5f3b46721aa112fb4f9bf29ae175cb5338f89dcec66ed97acfe75\nF ext/fts5/fts5_index.c 99b77ae1f503978ca76985bcfff7345c822aed8bbaa8edb3747f804f614685b5\nF ext/fts5/fts5_main.c 9db1f173d299466aeff89bd949fb1eb0a181265726fb56f11e07ea292dcc9a73\nF ext/fts5/fts5_storage.c 167e3d8f8052a71032d498e32a2f2ed5ffe489e5d4d47e298adfa02ed55c7882\nF ext/fts5/fts5_tcl.c 39bcbae507f594aad778172fa914cad0f585bf92fd3b078c686e249282db0d95\nF ext/fts5/fts5_test_mi.c 08c11ec968148d4cb4119d96d819f8c1f329812c568bac3684f5464be177d3ee\nF ext/fts5/fts5_test_tok.c f96c6e193c466711d6d7828d5f190407fe7ab897062d371426dd3036f01258e7\nF ext/fts5/fts5_tokenize.c 2e508c6a3bd8ee56c48e98a38052e1a650e49b32a484cce9b189984114bc3b88\nF ext/fts5/fts5_unicode2.c 8bd0cd07396b74c1a05590e4070d635bccfc849812c305619f109e6c0485e250\nF ext/fts5/fts5_varint.c e64d2113f6e1bfee0032972cffc1207b77af63319746951bf1d09885d1dadf80\nF ext/fts5/fts5_vocab.c c3f12188570abb423303cd193b16dd19ba54e21c2e930e9b748d743de3b385f5\nF ext/fts5/fts5parse.y eb526940f892ade5693f22ffd6c4f2702543a9059942772526eac1fde256bb05\nF ext/fts5/mkportersteps.tcl 5acf962d2e0074f701620bb5308155fa1e4a63ba\nF ext/fts5/test/fts5_common.tcl b01c584144b5064f30e6c648145a2dd6bc440841\nF ext/fts5/test/fts5aa.test 5bd43427b7d08ce2e19c488a26534be450538b9232d4d5305049e8de236e9aa9\nF ext/fts5/test/fts5ab.test 9205c839332c908aaad2b01ab8670ece8b161e8f2ec8a9fabf18ca9385880bb7\nF ext/fts5/test/fts5ac.test a7aa7e1fefc6e1918aa4d3111d5c44a09177168e962c5fd2cca9620de8a7ed6d\nF ext/fts5/test/fts5ad.test e8cf959dfcd57c8e46d6f5f25665686f3b6627130a9a981371dafdf6482790de\nF ext/fts5/test/fts5ae.test 1142d16d9cc193894dc13cc8f9c7a8a21411ac61b5567a878514df6f9f0d7bb7\nF ext/fts5/test/fts5af.test 724247405b13f8f06cc6ce464dc4f152dc5dd4e86b12c2099685d8f19747bf7b\nF ext/fts5/test/fts5ag.test 7816f25a0707578f08145ab539fc0ca025f8951e788b28a6a18a06b2099469dd\nF ext/fts5/test/fts5ah.test 27b5a33bfd0363ca8a4dc659e6e2a5df3dea1c3c5b04bc51ca6aeb1277bd9b21\nF ext/fts5/test/fts5ai.test bc97e4758cc93e06bf851d61c98fdf4e8b8f8315ee28a84fb15f916360856414\nF ext/fts5/test/fts5aj.test 745020852d85f5dd49d11cb7ad11d3cc6dafc4fe6d6d24bc0875ac8f43ee4149\nF ext/fts5/test/fts5ak.test fc3595f8e6873bb86d70c9bd4b67d0413ce577bd4793c39a2b60a7b8825b60a6\nF ext/fts5/test/fts5al.test 00c4c1c6a1366b73aa48ce2068c634520867c3cf7f5d1676ebbb775ee1f35734\nF ext/fts5/test/fts5alter.test 5565f7e4605512b69171ac18ca84398603f9f6456dbe377beeca97e83cc242cd\nF ext/fts5/test/fts5auto.test 78989e6527ce69c9eddbef7392fea5c10b0010cd2b2ae68eec7bc869c471e691\nF ext/fts5/test/fts5aux.test ebf6f2ff7cb556e83f66991b7f12bff016d3c83d4eab36704b649dd6b1437318\nF ext/fts5/test/fts5auxdata.test eacc97ff04892f1a5f3d4df5a73f8bcbc3955ea1d12c9f24137eb1fc079e7611\nF ext/fts5/test/fts5bigpl.test 6466c89b38439f0aba26ac09e232a6b963f29b1cbe1304f6a664fe1e7a8f5fd3\nF ext/fts5/test/fts5bigtok.test 541119e616c637caea925a8c028c37c2c29e94383e00aa2f9198d530724b6e36\nF ext/fts5/test/fts5cat.test daba0b80659460b0cb60bd1f40b402478a761fe7ea414c3c94c2be25568cc33a\nF ext/fts5/test/fts5circref.test f880dfd0d99f6fb73b88ccacb0927d18e833672fd906cc47d6b4e529419eaa62\nF ext/fts5/test/fts5colset.test a30473451321bbf0b6218af62e96b4ae5fa99931cfdb210b5ecc804623b30f75\nF ext/fts5/test/fts5columnsize.test 45459ce4dd9fd853b6044cdc9674921bff89e3d840f348ca8c1630f9edbf5482\nF ext/fts5/test/fts5config.test 60094712debc59286c59aef0e6cf511c37d866802776a825ce437d26afe0817f\nF ext/fts5/test/fts5conflict.test 655925678e630d3cdf145d18725a558971806416f453ac8410ca8c04d934238d\nF ext/fts5/test/fts5connect.test 08030168fc96fc278fa81f28654fb7e90566f33aff269c073e19b3ae9126b2f4\nF ext/fts5/test/fts5content.test 213506436fb2c87567b8e31f6d43ab30aab99354cec74ed679f22aad0cdbf283\nF ext/fts5/test/fts5corrupt.test 77ae6f41a7eba10620efb921cf7dbe218b0ef232b04519deb43581cb17a57ebe\nF ext/fts5/test/fts5corrupt2.test 7453752ba12ce91690c469a6449d412561cc604b1dec994e16ab132952e7805f\nF ext/fts5/test/fts5corrupt3.test 5aaa2f8b44a85246a2ea76db1695bde38a75802979f3961702afa8f322d331c8\nF ext/fts5/test/fts5corrupt4.test ea805c4d7c68b5f185b9db5d2060a7ae5875339738dd48203c92162f41e7ca91\nF ext/fts5/test/fts5delete.test cbf87e3b8867c4d5cfcaed975c7475fd3f99d072bce2075fcedf43d1f82af775\nF ext/fts5/test/fts5detail.test 31b240dbf6d44ac3507e2f8b65f29fdc12465ffd531212378c7ce1066766f54e\nF ext/fts5/test/fts5determin.test 1b77879b2ae818b5b71c859e534ee334dac088b7cf3ff3bf76a2c82b1c788d11\nF ext/fts5/test/fts5dlidx.test b90852c55881b29dbac6380b274de27beae623ac4b6d567c6c8fb9cdc315a86e\nF ext/fts5/test/fts5doclist.test e39a6001495f1dc68e20323586ac965787986c2bf6f515b9b0285627b089d9e6\nF ext/fts5/test/fts5ea.test b01e3a18cdfabbff8104a96a5242a06a68a998a0\nF ext/fts5/test/fts5eb.test 239bb2f02571f8cccfc7018d08f502df1cd8cc6a69b65ed1dde5f6a070e3f669\nF ext/fts5/test/fts5fault1.test d28a65caee75db6897c3cf1358c5230d3bb2a3bf7fb31062c19c7e5382b3d2bd\nF ext/fts5/test/fts5fault2.test 69c8fdbef830cd0d450908d4504d5bb86609e255af99c421c20a0756251fe344\nF ext/fts5/test/fts5fault3.test da2f9e3e56ff5740d68ebdd6877c97089e7ed28ddff28a0da87a6afea27e5522\nF ext/fts5/test/fts5fault4.test 1c1db5fcfe59401e7833146100f1d8de284a0a686fac31ddac9fb56c459f725b\nF ext/fts5/test/fts5fault5.test a336e4e11847de24c9497f80cce18e00bb3fab7fb11f97d04eb9af898900a762\nF ext/fts5/test/fts5fault6.test a0fc0a8f99e4b16500c31dfc7e38e1defe0f1693ac47650517ac7b723b1956f8\nF ext/fts5/test/fts5fault7.test 0acbec416edb24b8881f154e99c31e9ccf73f539cfcd164090be139e9e97ed4c\nF ext/fts5/test/fts5fault8.test 318238659d35f82ad215ecb57ca4c87486ea85d45dbeedaee42f148ff5105ee2\nF ext/fts5/test/fts5fault9.test 098e6b894bbdf9b2192f994a30f4043673fb3f338b6b8ab1624c704422f39119\nF ext/fts5/test/fts5faultA.test be4487576bff8c22cee6597d1893b312f306504a8c6ccd3c53ca85af12290c8c\nF ext/fts5/test/fts5faultB.test d606bdb8e81aaeb6f41de3fc9fc7ae315733f0903fbff05cf54f5b045b729ab5\nF ext/fts5/test/fts5faultD.test cc5d1225556e356615e719c612e845d41bff7d5a\nF ext/fts5/test/fts5first.test 3fcf2365c00a15fc9704233674789a3b95131d12de18a9b996159f6909dc8079\nF ext/fts5/test/fts5full.test e1701a112354e0ff9a1fdffb0c940c576530c33732ee20ac5e8361777070d717\nF ext/fts5/test/fts5fuzz1.test 238d8c45f3b81342aa384de3e581ff2fa330bf922a7b69e484bbc06051a1080e\nF ext/fts5/test/fts5hash.test a4cf51acad99bfc43c16fb74f9d22495dc221ae0701fc5e908ca963a9b26a02b\nF ext/fts5/test/fts5integrity.test 4317561cd25eca7df16aa1f7d1a700ee958059fa639785f94aba0a84df9ab17b\nF ext/fts5/test/fts5interrupt.test 09613247b273a99889808ef852898177e671406fe71fdde7ea00e78ea283d227\nF ext/fts5/test/fts5lastrowid.test be98fe3e03235296585b72daad7aed5717ba0062bae5e5c18dd6e04e194c6b28\nF ext/fts5/test/fts5leftjoin.test c0b4cafb9661379e576dc4405c0891d8fcc2782680740513c4d1fc114b43d4ad\nF ext/fts5/test/fts5matchinfo.test 50d86da66ec5b27603dcd90ba0227f5d9deb10351cbc52974a88e24f6fc9b076\nF ext/fts5/test/fts5merge.test e92a8db28b45931e7a9c7b1bbd36101692759d00274df74d83fd29d25d53b3a6\nF ext/fts5/test/fts5merge2.test 3ebad1a59d6ad3fb66eff6523a09e95dc6367cbefb3cd73196801dea0425c8e2\nF ext/fts5/test/fts5misc.test a5b53328b5b79275915de8f67ae85905eb2133d8dbcc808411f67c094b1bd347\nF ext/fts5/test/fts5multi.test a15bc91cdb717492e6e1b66fec1c356cb57386b980c7ba5af1915f97fe878581\nF ext/fts5/test/fts5multiclient.test 5ff811c028d6108045ffef737f1e9f05028af2458e456c0937c1d1b8dea56d45\nF ext/fts5/test/fts5near.test 211477940142d733ac04fad97cb24095513ab2507073a99c2765c3ddd2ef58bd\nF ext/fts5/test/fts5onepass.test f9b7d9b2c334900c6542a869760290e2ab5382af8fbd618834bf1fcc3e7b84da\nF ext/fts5/test/fts5optimize.test 36a752d24c818792032e4ff502936fc9cc5ef938721696396fdc79214b2717f1\nF ext/fts5/test/fts5phrase.test 13e5d8e9083077b3d9c74315b3c92ec723cc6eb37c8155e0bfe1bba00559f07b\nF ext/fts5/test/fts5plan.test 771b999d161e24fd803ce0290adb7c6e7c9b9cc2c6a0adb344813fb89473aa32\nF ext/fts5/test/fts5porter.test 8d08010c28527db66bc3feebd2b8767504aaeb9b101a986342fa7833d49d0d15\nF ext/fts5/test/fts5porter2.test 0d251a673f02fa13ca7f011654873b3add20745f7402f108600a23e52d8c7457\nF ext/fts5/test/fts5prefix.test a0fa67b06650f2deaa7bf27745899d94e0fb547ad9ecbd08bfad98c04912c056\nF ext/fts5/test/fts5query.test ac363b17a442620bb0780e93c24f16a5f963dfe2f23dc85647b869efcfada728\nF ext/fts5/test/fts5rank.test c9fd4a1e36b4fa92d572ec13d846469b97da249d1c2f7fd3ee7e017ce46f2416\nF ext/fts5/test/fts5rebuild.test 55d6f17715cddbf825680dd6551efbc72ed916d8cf1cde40a46fc5d785b451e7\nF ext/fts5/test/fts5restart.test 835ecc8f449e3919f72509ab58056d0cedca40d1fe04108ccf8ac4c2ba41f415\nF ext/fts5/test/fts5rowid.test b8790ec170a8dc1942a15aef3db926a5f3061b1ff171013003d8297203a20ad6\nF ext/fts5/test/fts5simple.test a298670508c1458b88ce6030440f26a30673931884eb5f4094ac1773b3ba217b\nF ext/fts5/test/fts5simple2.test 258a1b0c590409bfa5271e872c79572b319d2a56554d0585f68f146a0da603f0\nF ext/fts5/test/fts5simple3.test d5c74a9d3ca71bd5dd5cacb7c55b86ea12cdddfc8b1910e3de2995206898380f\nF ext/fts5/test/fts5synonym.test 1651815b8008de170e8e600dcacc17521d765482ea8f074ae82cfa870d8bb7fb\nF ext/fts5/test/fts5synonym2.test b54cce5c34ec08ed616f646635538ae82e34a0e28f947ec60b6fadbc4b3fb17a\nF ext/fts5/test/fts5tok1.test ce6551e41ff56f30b69963577324624733bed0d1753589f06120d664d9cd45c9\nF ext/fts5/test/fts5tok2.test dcacb32d4a2a3f0dd3215d4a3987f78ae4be21a2\nF ext/fts5/test/fts5tokenizer.test ac3c9112b263a639fb0508ae73a3ee886bf4866d2153771a8e8a20c721305a43\nF ext/fts5/test/fts5umlaut.test a42fe2fe6387c40c49ab27ccbd070e1ae38e07f38d05926482cc0bccac9ad602\nF ext/fts5/test/fts5unicode.test 17056f4efe6b0a5d4f41fdf7a7dc9af2873004562eaa899d40633b93dc95f5a9\nF ext/fts5/test/fts5unicode2.test 9b3df486de05fb4bde4aa7ee8de2e6dae1df6eb90e3f2e242c9383b95d314e3e\nF ext/fts5/test/fts5unicode3.test 590c72e18195bda2446133f9d82d04a4e89d094bba58c75ae10f4afc6faa0744\nF ext/fts5/test/fts5unicode4.test 6463301d669f963c83988017aa354108be0b947d325aef58d3abddf27147b687\nF ext/fts5/test/fts5unindexed.test 9021af86a0fb9fc616f7a69a996db0116e7936d0db63892db6bafabbec21af4d\nF ext/fts5/test/fts5update.test b8affd796e45c94a4d19ad5c26606ea06065a0f162a9562d9f005b5a80ccf0bc\nF ext/fts5/test/fts5version.test c8f2cc105f0abf0224965f93e584633dee3e06c91478bc67e468f7cfdf97fd6a\nF ext/fts5/test/fts5vocab.test 648fb2fe86b55e08295e34504704718d92fba3e2cf3e1f5d72fa3682df4cd0f0\nF ext/fts5/test/fts5vocab2.test e0fdc3a3095f6eda68ac9bf9a443ff929a124d46f00af19933604085712e9d47\nF ext/fts5/tool/fts5speed.tcl b0056f91a55b2d1a3684ec05729de92b042e2f85\nF ext/fts5/tool/fts5txt2db.tcl 526a9979c963f1c54fd50976a05a502e533a4c59\nF ext/fts5/tool/loadfts5.tcl 95b03429ee6b138645703c6ca192c3ac96eaf093\nF ext/fts5/tool/mkfts5c.tcl d1c2a9ab8e0ec690a52316f33dd9b1d379942f45\nF ext/fts5/tool/showfts5.tcl d54da0e067306663e2d5d523965ca487698e722c\nF ext/icu/README.txt a295e91db742b153e8dce8f7efd31d28ad1eea4df31ef4daa3eedc85be2f5138\nF ext/icu/icu.c c2c7592574c08cd1270d909b8fb8797f6ea1f49e931e71dbcc25506b9b224580\nF ext/icu/sqliteicu.h 728867a802baa5a96de7495e9689a8e01715ef37\nF ext/lsm1/Makefile a553b728bba6c11201b795188c5708915cc4290f02b7df6ba7e8c4c943fd5cd9\nF ext/lsm1/Makefile.msc f8c878b467232226de288da320e1ac71c131f5ec91e08b21f502303347260013\nF ext/lsm1/lsm-test/README 87ea529d2abe615e856d4714bfe8bb185e6c2771b8612aa6298588b7b43e6f86\nF ext/lsm1/lsm-test/lsmtest.h cf58528ffe0cfe535e91b44584e2ec5fb1caacdabecef0d8dcf83bf83168bf28\nF ext/lsm1/lsm-test/lsmtest1.c ae6ba48a0851b39be69a7d0eb220bfb9521a526e926223d5014bd385df10abb3\nF ext/lsm1/lsm-test/lsmtest2.c 188b09aec776516aeedcfd13b9c6faf85ba16b3671a0897a2c740ee00a5dc4f8\nF ext/lsm1/lsm-test/lsmtest3.c 9ab87528a36dbf4a61d7c8ad954f5ee368c0878c127b84b942b2e2abe522de26\nF ext/lsm1/lsm-test/lsmtest4.c d258d6a245db5d8eaede096e2368d23f859c5e92c80ab9122463f708514fe10c\nF ext/lsm1/lsm-test/lsmtest5.c 8d5242a0f870d65eeada191c8945781fed9cb8ece3886573790ebd373b62dac5\nF ext/lsm1/lsm-test/lsmtest6.c 869cb4a172cd07d1a75b3aeaecd61d0a477787b3b8668bad0d3ff0f43b642b7c\nF ext/lsm1/lsm-test/lsmtest7.c 7a917455a0f956a8ed3f44f5c9387ec0ea6627714874464cc3fa5c5a9cabb2f2\nF ext/lsm1/lsm-test/lsmtest8.c 589b68c44531a0f04d5e879bb1e211be5f7100f48eed7e8631e07ed5cbd68f94\nF ext/lsm1/lsm-test/lsmtest9.c dd1a0ebf41134933a744d1e00e60429a2a21fc50d587ae7dd6bdb6e96d805bdc\nF ext/lsm1/lsm-test/lsmtest_bt.c d70d9a9be5eef9360af1251dd083948d74fd30137a08f61bef995f7ac04e037f\nF ext/lsm1/lsm-test/lsmtest_datasource.c 5d770be191d0ca51315926723009b2c25c0b4b8136840494ef710ac324aa916c\nF ext/lsm1/lsm-test/lsmtest_func.c 159aa401bc8032bfa3d8cf2977bd687abebab880255895a5eb45770d626fa38d\nF ext/lsm1/lsm-test/lsmtest_io.c cf11b27b129c6bd5818fa1d440176502dc27229f0db892b4479118d61993ea20\nF ext/lsm1/lsm-test/lsmtest_main.c a9bc647738c0dcaebf205d6d194b3ce4a6ef3925801cd2d919f0a4ea33a15aeb\nF ext/lsm1/lsm-test/lsmtest_mem.c 4e63c764345ab1df59d4f13a77980c6f3643798210b10d6cdbd785b4b888fda5\nF ext/lsm1/lsm-test/lsmtest_tdb.c 618a8619183fda4f5540fcde15f9068293c5e3180e1a246e34409b0c148758b3\nF ext/lsm1/lsm-test/lsmtest_tdb.h 8733eee249b12956a9df8322994b43d19bd8c02ad2e8b0bb5164db4d6ccc1735\nF ext/lsm1/lsm-test/lsmtest_tdb2.cc 99ea7f2dd9c7536c8fb9bdd329e4cfeb76899f3ddf6f48bdd3926e016922b715\nF ext/lsm1/lsm-test/lsmtest_tdb3.c 7a7ccae189f5bb25bcd1ec3bbd740529706eded7f6729a5a0a9eeaeb57785320\nF ext/lsm1/lsm-test/lsmtest_tdb4.c 47e8bb5eba266472d690fb8264f1855ebdba0ae5a0e541e35fcda61ebf1d277f\nF ext/lsm1/lsm-test/lsmtest_util.c 241622db5a332a09c8e6e7606b617d288a37b557f7d3bce0bb97809f67cc2806\nF ext/lsm1/lsm-test/lsmtest_win32.c 0e0a224674c4d3170631c41b026b56c7e1672b151f5261e1b4cc19068641da2d\nF ext/lsm1/lsm.h 0f6f64ff071471cb87bf98beb8386566f30ea001\nF ext/lsm1/lsmInt.h 5983690e05e83653cc01ba9d8fbf8455e534ddf8349ed9adedbf46a7549760b0\nF ext/lsm1/lsm_ckpt.c 0eabfaf812ddb4ea43add38f05e430694cd054eb622c3e35af4c43118a2d5321\nF ext/lsm1/lsm_file.c 3c51841d5b3e7da162693cbac9a9f47eeedf6bcbbe2969a4d25e30c428c9fe36\nF ext/lsm1/lsm_log.c a8bf334532109bba05b09a504ee45fc393828b0d034ca61ab45e3940709d9a7c\nF ext/lsm1/lsm_main.c b5703f8042e71d3a2d65e671f6832e077e79e89e9975818f67f969922618db63\nF ext/lsm1/lsm_mem.c 4c51ea9fa285ee6e35301b33491642d071740a0a\nF ext/lsm1/lsm_mutex.c 378edf0a2b142b4f7640ee982df06d50b98788ea\nF ext/lsm1/lsm_shared.c 76adfc1ed9ffebaf92746dde4b370ccc48143ca8b05b563816eadd2aadf1c525\nF ext/lsm1/lsm_sorted.c 6f7d8cf7a7d3d3f1ab5d9ba6347e8f39f3d73c00ec48afcd0c4bcbefd806f9b8\nF ext/lsm1/lsm_str.c 65e361b488c87b10bf3e5c0070b14ffc602cf84f094880bece77bbf6678bca82\nF ext/lsm1/lsm_tree.c 682679d7ef2b8b6f2fe77aeb532c8d29695bca671c220b0abac77069de5fb9fb\nF ext/lsm1/lsm_unix.c 57361bcf5b1a1a028f5d66571ee490e9064d2cfb145a2cc9e5ddade467bb551b\nF ext/lsm1/lsm_varint.c 43f954af668a66c7928b81597c14d6ad4be9fedbc276bbd80f52fa28a02fdb62\nF ext/lsm1/lsm_vtab.c 169bfe7ef8e6c9de9c77e17c4c50c9ae55fb0167d80be3d1be82c991184b6f35\nF ext/lsm1/lsm_win32.c 0a4acbd7e8d136dd3a5753f0a9e7a9802263a9d96cef3278cf120bcaa724db7c\nF ext/lsm1/test/lsm1_common.tcl 5ed4bab07c93be2e4f300ebe46007ecf4b3e20bc5fbe1dedaf04a8774a6d8d82\nF ext/lsm1/test/lsm1_simple.test a04d08e8661ae6fc53786c67f0bd102c6692f003e859dde03ed9ac3f12e066e5\nF ext/lsm1/tool/mklsm1c.tcl f31561bbee5349f0a554d1ad7236ac1991fc09176626f529f6078e07335398b0\nF ext/misc/README.md d6dd0fe1d8af77040216798a6a2b0c46c73054d2f0ea544fbbcdccf6f238c240\nF ext/misc/amatch.c 50a9ef2d38dabfa371f8c1904097d493271e63d58ccb0e9b79a4fa4a94e66660\nF ext/misc/anycollseq.c 5ffdfde9829eeac52219136ad6aa7cd9a4edb3b15f4f2532de52f4a22525eddb\nF ext/misc/appendvfs.c 3777f22ec1057dc4e5fd89f2fbddcc7a29fbeef1ad038c736c54411bb1967af7\nF ext/misc/blobio.c a867c4c4617f6ec223a307ebfe0eabb45e0992f74dd47722b96f3e631c0edb2a\nF ext/misc/btreeinfo.c 4f0ebf278f46e68e6306c667917766cebc5550fd35d5de17847988e22892d4d2\nF ext/misc/carray.c 91e9a7f512fda934894bed30464552fffa7d3073b5be04189ae0bd0c59f26bfd\nF ext/misc/closure.c dbfd8543b2a017ae6b1a5843986b22ddf99ff126ec9634a2f4047cd14c85c243\nF ext/misc/completion.c cec672d40604075bb341a7f11ac48393efdcd90a979269b8fe7977ea62d0547f\nF ext/misc/compress.c dd4f8a6d0baccff3c694757db5b430f3bbd821d8686d1fc24df55cf9f035b189\nF ext/misc/csv.c 7f047aeb68f5802e7ce6639292095d622a488bb43526ed04810e0649faa71ceb\nF ext/misc/dbdata.c e316fba936571584e55abd5b974a32a191727a6b746053a0c9d439bd2cf93940\nF ext/misc/dbdump.c baf6e37447c9d6968417b1cd34cbedb0b0ab3f91b5329501d8a8d5be3287c336\nF ext/misc/eval.c 4b4757592d00fd32e44c7a067e6a0e4839c81a4d57abc4131ee7806d1be3104e\nF ext/misc/explain.c d5c12962d79913ef774b297006872af1fccda388f61a11d37758f9179a09551f\nF ext/misc/fileio.c 288e7230e0fe464d71b0694e2d8bdd3a353118ac2e31da3964b95f460f09915f\nF ext/misc/fossildelta.c 7708651072eb5620ab21bbfb518d184f27b2c29c0131b09b9a2d8852a8016430\nF ext/misc/fuzzer.c c4e27daf41433a64cad5265cd27dbcb891147e9994d0422200ce81ce9a54b625\nF ext/misc/ieee754.c f190d0cc5182529acb15babd177781be1ac1718c\nF ext/misc/json1.c 760107d0b97ab422952591b0d7519327dcb482954a7706ee387a54c135f8aabf\nF ext/misc/memstat.c 3017a0832c645c0f8c773435620d663855f04690172316bd127270d1a7523d4d\nF ext/misc/memtrace.c 7c0d115d2ef716ad0ba632c91e05bd119cb16c1aedf3bec9f06196ead2d5537b\nF ext/misc/memvfs.c ab36f49e02ebcdf85a1e08dc4d8599ea8f343e073ac9e0bca18a98b7e1ec9567\nF ext/misc/mmapwarm.c 8c5fe90d807a23e44a8b93e96e8b812b19b300d5fd8c1d40a4fd1d8224e33f46\nF ext/misc/nextchar.c 279f80fe8ef5ba413242e2704e246503ac601f005eefb180d19e6c920338a0ba\nF ext/misc/normalize.c b4290464f542bae7a97b43f15bd197949b833ffd668b7c313631bd5d4610212c\nF ext/misc/percentile.c 148dd07286b16e50f232bb638a47850085ad37d51f270429905bd865e595d1ca\nF ext/misc/prefixes.c 7be86d17525cfae6ed462fc3c519efc44488ac329890f77491c8f82871f57e17\nF ext/misc/regexp.c 653b6ab5e89bcb5d45f9ebe0747d7f8f3f5706cac963fcbc9a3ddbe5fdc1efa2\nF ext/misc/remember.c add730f0f7e7436cd15ea3fd6a90fd83c3f706ab44169f7f048438b7d6baa69c\nF ext/misc/rot13.c 540a169cb0d74f15522a8930b0cccdcb37a4fd071d219a5a083a319fc6e8db77\nF ext/misc/scrub.c db9fff56fed322ca587d73727c6021b11ae79ce3f31b389e1d82891d144f22ad\nF ext/misc/series.c 0c97f63378fddc9f425e82ba139b9aaf902211f24ced115c2b6ae12b425f7334\nF ext/misc/sha1.c d8125a88ee9023bc17d6f87ea8850db33f906d5701b30d4fd9bddb57f231e60a\nF ext/misc/shathree.c 22ba7ca84a433d6466a7d05dcc876910b435a715da8cc462517db9351412b8c8\nF ext/misc/showauth.c 732578f0fe4ce42d577e1c86dc89dd14a006ab52\nF ext/misc/spellfix.c f88ecb2c0294453ce8b7704b211f5350c41b085b38c8e056852e3a08b0f5e484\nF ext/misc/sqlar.c 57d5bc45cd5492208e451f697404be88f8612527d64c9d42f96b325b64983d74\nF ext/misc/stmt.c 8a8dc4675042e4551e4afe99b8d0cc7a4a2fc1a8dacc0a9ce1b1bbff145da93d\nF ext/misc/templatevtab.c 8a16a91a5ceaccfcbd6aaaa56d46828806e460dd194965b3f77bf38f14b942c4\nF ext/misc/totype.c 5b6b1eafaa993e29f8df843319b3292b029f1b5cbbbf11c8a88e05d3f714159f\nF ext/misc/unionvtab.c 36237f0607ca954ac13a4a0e2d2ac40c33bc6e032a5f55f431713061ef1625f9\nF ext/misc/uuid.c db4db81e8c6a92ad6176ebd9f81dcb6870e331e1a286d0452f4319e3ba3df812\nF ext/misc/vfslog.c 3b25c2f56ba60788db247287be6ab024b53c4afffd412b4876db563389be0d35\nF ext/misc/vfsstat.c 77b5b4235c9f7f11eddf82487c0a422944ac2f132dafd5af3be7a68a057b1cdb\nF ext/misc/vtablog.c 5538acd0c8ddaae372331bee11608d76973436b77d6a91e8635cfc9432fba5ae\nF ext/misc/vtshim.c 1976e6dd68dd0d64508c91a6dfab8e75f8aaf6cd\nF ext/misc/wholenumber.c 784b12543d60702ebdd47da936e278aa03076212\nF ext/misc/zipfile.c 8f965eb309da3ae8c30088f6c3ebdddcdbdf9e0ef24f3bc7ae0756deb93da503\nF ext/misc/zorder.c b0ff58fa643afa1d846786d51ea8d5c4b6b35aa0254ab5a82617db92f3adda64\nF ext/rbu/rbu.c 8681f6157db6adc82c34af24b14ea8a3be0146ad2a3b6c1d5da6cb8a5796c8ce\nF ext/rbu/rbu1.test 221d9c18a5e600ac9ac6b1810d99d9f99163a7909ba61597876ab6e4d4beb3d6\nF ext/rbu/rbu10.test 0a201c32202143f23c81c0144503da339786fc20acb7a2fda11601b65659f314\nF ext/rbu/rbu11.test 5c834cf491086b45e071eabf71f708febc143e86a384a92de69e0b1a4cace144\nF ext/rbu/rbu12.test 29f8b2118f6c96fac3755bd6d2b55c2db24f878b1f11fbfbe294f3a230a3dcdc\nF ext/rbu/rbu13.test 1285298e3360ec74511764841b3c174dcfe21da2f618c22febf1a20abd0365c2\nF ext/rbu/rbu14.test 4a7bf0b3a4516d3ab0bc0ba4ceb53eb7e3324147ccda152e561060f659dbba31\nF ext/rbu/rbu3.test d6c6cc7a1326e8e23b9820f30bd3054f22092e503fadfd2a660ae006653f6d80\nF ext/rbu/rbu5.test 724b38ea5f722e3d22dc76343860bd998bb676c3f78c4bc8175df5c5d7720e23\nF ext/rbu/rbu6.test 401064236d3cf86b7edc01c586d7c5554f48553946fbfa1a3af35d7e47dce9e3\nF ext/rbu/rbu7.test ae25f47b56f178197fc1098537a35a39176cc73d1629b03dc9d795929fc36ec2\nF ext/rbu/rbu8.test b98a6fc58ead84a0e6ddee775b9702cd981f318d5d4fd1d4df0fa0c40db7251b\nF ext/rbu/rbu9.test 0e4d985e25620d61920597e8ea69c871c9e8c1f5a0be2ae9fa70bb641d74378c\nF ext/rbu/rbuA.test b34a90cb495682c25b5fc03a9d5e7a4fc99541c29256f25e2e2a4f6542b4f5b3\nF ext/rbu/rbuB.test 52b07158824c6927b7e25554ace92a695cdebfc296ae3d308ac386984aded9bc\nF ext/rbu/rbuC.test 80f1cc2fb74f44b1128fd0ed8eedab3a76fefeb72a947860e2869ef76fc8dc6b\nF ext/rbu/rbu_common.tcl 60d904133ff843fe72cc0514e9dd2486707181e6e0fbab20979da28c48d21de9\nF ext/rbu/rbucollate.test cac528a9a46318cba42e61258bb42660bbbf4fdb9a8c863de5a54ad0c658d197\nF ext/rbu/rbucrash.test 000981a1fe8a6e4d9a684232f6a129e66a3ef595f5ed74655e2f9c68ffa613b4\nF ext/rbu/rbucrash2.test efa143cc94228eb0266d3f1abfbee60a5838a84cef7cc3fcb8c145b74d96fd41\nF ext/rbu/rbudiff.test 156957851136b63c143478518dc1bda6c832103cdbe8ac1d7cdd47edb3cbe0a3\nF ext/rbu/rbudor.test e3e8623926012f43eebe51fedf06a102df2640750d971596b052495f2536db20\nF ext/rbu/rbuexpr.test 10d0420537c3bc7666e576d72adeffe7e86cfbb00dcc30aa9ce096c042415190\nF ext/rbu/rbufault.test 2d7f567b79d558f6e093c58808cab4354f8a174e3802f69e7790a9689b3c09f8\nF ext/rbu/rbufault2.test c81327a3ac2c385b9b954db3644d4e0df93eeebfc3de9f1f29975a1e73fd3d0c\nF ext/rbu/rbufault3.test b2fcc9db5c982b869f67d1d4688d8cb515d5b92f58011fff95665f2e62cec179\nF ext/rbu/rbufault4.test 03d2849c3df7d7bd14a622e789ff049e5080edd34a79cd432e01204db2a5930a\nF ext/rbu/rbufts.test 0ae8d1da191c75bd776b86e24456db0fb6e97b7c944259fae5407ea55d23c31d\nF ext/rbu/rbumisc.test 329986cf5dd51890c4eb906c2f960ebb773a79a64bed90f506b7c417825b37eb\nF ext/rbu/rbumulti.test 5fb139058f37ddc5a113c5b93238de915b769b7792de41b44c983bc7c18cf5b9\nF ext/rbu/rbupartial.test f25df014b8dbe3c5345851fba6e66f79ab237f57dc201b2d5f0dbae658ae5a4c\nF ext/rbu/rbuprogress.test 857cf1f8166c83ef977edb9ef4fc42d80f71fbd798652b46ae2f3a7031870f8d\nF ext/rbu/rburesume.test dbdc4ca504e9c76375a69e5f0d91205db967dcc509a5166ca80231f8fda49eb1\nF ext/rbu/rbusave.test f4190a1a86fccf84f723af5c93813365ae33feda35845ba107b59683d1cdd926\nF ext/rbu/rbusplit.test b37e7b40b38760881dc9c854bd40b4744c6b6cd74990754eca3bda0f407051e8\nF ext/rbu/rbutemplimit.test 05ceefa90a2e26a99f40dd48282ed63a00df5e59c1f2bfd479c143e201a1b0ba\nF ext/rbu/rbuvacuum.test 55e101e90168c2b31df6c9638fe73dc7f7cc666b6142266d1563697d79f73534\nF ext/rbu/rbuvacuum2.test b8e5b51dc8b2c0153373d024c0936be3f66f9234acbd6d0baab0869d56b14e6b\nF ext/rbu/rbuvacuum3.test 8addd82e4b83b4c93fa47428eae4fd0dbf410f8512c186f38e348feb49ba03dc\nF ext/rbu/rbuvacuum4.test a78898e438a44803eb2bc897ba3323373c9f277418e2d6d76e90f2f1dbccfd10\nF ext/rbu/sqlite3rbu.c f3a3e09f575157052813be667d6ab3b54f47fb02e6e1c9f767ad7bb8f1fb90b3\nF ext/rbu/sqlite3rbu.h 1dc88ab7bd32d0f15890ea08d23476c4198d3da3056985403991f8c9cd389812\nF ext/rbu/test_rbu.c 03f6f177096a5f822d68d8e4069ad8907fe572c62ff2d19b141f59742821828a\nF ext/repair/README.md 92f5e8aae749a4dae14f02eea8e1bb42d4db2b6ce5e83dbcdd6b1446997e0c15\nF ext/repair/checkfreelist.c 0dbae18c1b552f58d64f8969e4fb1e7f11930c60a8c2a9a8d50b7f15bdfd54bd\nF ext/repair/checkindex.c 7d28c01a2e012ac64257d230fc452b2cafb78311a91a343633d01d95220f66f3\nF ext/repair/sqlite3_checker.c.in 4a5a3af3f450fe503e5a2985e98516dc2a6b9ad247449e284c1cf140fc91720f\nF ext/repair/sqlite3_checker.tcl a9a2caa9660567257c177a91124d8c0dccdfa341e25c51e6da7f1fd9e601eafa\nF ext/repair/test/README.md 34b2f542cf5be7bffe479242b33ee3492cea30711e447cc4a1a86cb5915f419e\nF ext/repair/test/checkfreelist01.test 3e8aa6aeb4007680c94a8d07b41c339aa635cc78249442da72ff3f8297398a69\nF ext/repair/test/checkindex01.test b530f141413b587c9eb78ff734de6bb79bc3515c335096108c12c01bddbadcec\nF ext/repair/test/test.tcl 686d76d888dffd021f64260abf29a55c57b2cedfa7fc69150b42b1d6119aac3c\nF ext/rtree/README 6315c0d73ebf0ec40dedb5aa0e942bc8b54e3761\nF ext/rtree/geopoly.c c591164125808f8bba9659e92665b78412cd263e654b6f05294f3a8da7cdd9fb\nF ext/rtree/rtree.c 26fcb3f7a92fda9afcf5eee684cc3188b7367da69bc9c374492d844fb8ed4e25\nF ext/rtree/rtree.h 4a690463901cb5e6127cf05eb8e642f127012fd5003830dbc974eca5802d9412\nF ext/rtree/rtree1.test 4092a8bd2b5eafc4fafe4fe9024249c12b13e4bab23c2c3eaff57412fdf805fa\nF ext/rtree/rtree2.test 9d9deddbb16fd0c30c36e6b4fdc3ee3132d765567f0f9432ee71e1303d32603d\nF ext/rtree/rtree3.test 4ee5d7df86040efe3d8d84f141f2962a7745452200a7cba1db06f86d97050499\nF ext/rtree/rtree4.test 304de65d484540111b896827e4261815e5dca4ce28eeecd58be648cd73452c4b\nF ext/rtree/rtree5.test 49c9041d713d54560b315c2c7ef7207ee287eba1b20f8266968a06f2e55d3142\nF ext/rtree/rtree6.test 1252a0439da01d2f1f5cbbdeeb80455a2d68b9bae2a9787937b167a5e3957828\nF ext/rtree/rtree7.test c8fb2e555b128dd0f0bdb520c61380014f497f8a23c40f2e820acc9f9e4fdce5\nF ext/rtree/rtree8.test 2d99006a1386663978c9e1df167554671e4f711c419175b39f332719deb1ce0e\nF ext/rtree/rtree9.test c646f12c8c1c68ef015c6c043d86a0c42488e2e68ed1bb1b0771a7ca246cbabf\nF ext/rtree/rtreeA.test ed2f1be9c06dde0b1ab93a95dd9e87eeaa02db2d30bcb4b9179b69ee3dc3319b\nF ext/rtree/rtreeB.test 4cec297f8e5c588654bbf3c6ed0903f10612be8a2878055dd25faf8c71758bc9\nF ext/rtree/rtreeC.test 6aa87eba4d9a3003b941a1ba77db259c5cabc3fd92fc5a6360f5369520eb9a4d\nF ext/rtree/rtreeD.test fe46aa7f012e137bd58294409b16c0d43976c3bb92c8f710481e577c4a1100dc\nF ext/rtree/rtreeE.test e65d3fc625da1800b412fc8785817327d43ccfec5f5973912d8c9e471928caa9\nF ext/rtree/rtreeF.test 81ffa7ef51c4e4618d497a57328c265bf576990c7070633b623b23cd450ed331\nF ext/rtree/rtreeG.test 1b9ca6e3effb48f4161edaa463ddeaa8fca4b2526d084f9cbf5dbe4e0184939c\nF ext/rtree/rtreeH.test 0885151ee8429242625600ae47142cca935332c70a06737f35af53a7bd7aaf90\nF ext/rtree/rtreeI.test 608e77f7fde9be5a12eae316baef640fffaafcfa90a3d67443e78123e19c4ca4\nF ext/rtree/rtree_perf.tcl 6c18c1f23cd48e0f948930c98dfdd37dfccb5195\nF ext/rtree/rtree_util.tcl db734b4c5e75fed6acc56d9701f2235345acfdec750b5fc7b587936f5f6bceed\nF ext/rtree/rtreecheck.test d67d5b3e9e45bfa8cd90734e8e9302144ac415b8e9176c6f02d4f92892ee8a35\nF ext/rtree/rtreecirc.test aec664eb21ae943aeb344191407afff5d392d3ae9d12b9a112ced0d9c5de298e\nF ext/rtree/rtreeconnect.test 225ad3fcb483d36cbee423a25052a6bbae762c9576ae9268332360c68c170d3d\nF ext/rtree/rtreefuzz001.test eef1ed593bb15886cd5d5367a2f2492f81e315848896cdf7afb6e21454978827\nF ext/rtree/sqlite3rtree.h 03c8db3261e435fbddcfc961471795cbf12b24e03001d0015b2636b0f3881373\nF ext/rtree/tkt3363.test 142ab96eded44a3615ec79fba98c7bde7d0f96de\nF ext/rtree/util/randomshape.tcl 54ee03d0d4a1c621806f7f44d5b78d2db8fac26e0e8687c36c4bd0203b27dbff\nF ext/rtree/viewrtree.tcl eea6224b3553599ae665b239bd827e182b466024\nF ext/rtree/visual01.txt e9c2564083bcd30ec51b07f881bffbf0e12b50a3f6fced0c222c5c1d2f94ac66\nF ext/session/changeset.c 7a1e6a14c7e92d36ca177e92e88b5281acd709f3b726298dc34ec0fb58869cb5\nF ext/session/changesetfuzz.c 227076ab0ae4447d742c01ee88a564da6478bbf26b65108bf8fac9cd8b0b24aa\nF ext/session/changesetfuzz1.test 2e1b90d888fbf0eea5e1bd2f1e527a48cc85f8e0ff75df1ec4e320b21f580b3a\nF ext/session/session1.test 0b2f88995832ea040ae8e83a1ad4afa99c00b85c779d213da73a95ea4113233e\nF ext/session/session2.test 284de45abae4cc1082bc52012ee81521d5ac58e0\nF ext/session/session3.test ce9ce3dfa489473987f899e9f6a0f2db9bde3479\nF ext/session/session4.test 6778997065b44d99c51ff9cece047ff9244a32856b328735ae27ddef68979c40\nF ext/session/session5.test 716bc6fafd625ce60dfa62ae128971628c1a1169\nF ext/session/session6.test 443789bc2fca12e4f7075cf692c60b8a2bea1a26\nF ext/session/session8.test 8e194b3f655d861ca36de5d4de53f702751bab3b\nF ext/session/session9.test 5409d90d8141881d08285ed1c2c0d8d10fb92069\nF ext/session/sessionA.test 1feeab0b8e03527f08f2f1defb442da25480138f\nF ext/session/sessionB.test c4fb7f8a688787111606e123a555f18ee04f65bb9f2a4bb2aa71d55ce4e6d02c\nF ext/session/sessionC.test f8a5508bc059ae646e5ec9bdbca66ad24bc92fe99fda5790ac57e1f59fce2fdf\nF ext/session/sessionD.test 4f91d0ca8afc4c3969c72c9f0b5ea9527e21de29039937d0d973f821e8470724\nF ext/session/sessionE.test b2010949c9d7415306f64e3c2072ddabc4b8250c98478d3c0c4d064bce83111d\nF ext/session/sessionF.test d37ed800881e742c208df443537bf29aa49fd56eac520d0f0c6df3e6320f3401\nF ext/session/sessionG.test 3828b944cd1285f4379340fd36f8b64c464fc84df6ff3ccbc95578fd87140b9c\nF ext/session/sessionH.test a417559f29a7e775950fc5fc82b3d01256a7cbe793ddf1180df234df823d56e2\nF ext/session/session_common.tcl 29ec9910aca1e996ca1c8531b8cecabf96eb576aa53de65a8ff03d848b9a2a8b\nF ext/session/session_speed_test.c dcf0ef58d76b70c8fbd9eab3be77cf9deb8bc1638fed8be518b62d6cbdef88b3\nF ext/session/sessionat.test efe88965e74ff1bc2af9c310b28358c02d420c1fb2705cc7a28f0c1cc142c3ec\nF ext/session/sessiondiff.test ad13dd65664bae26744e1f18eb3cbd5588349b7e9118851d8f9364248d67bcec\nF ext/session/sessionfault.test da273f2712b6411e85e71465a1733b8501dbf6f7\nF ext/session/sessionfault2.test dd593f80b6b4786f7adfe83c5939620bc505559770cc181332da26f29cddd7bb\nF ext/session/sessioninvert.test ae1a003a9ab1f8d64227dbb5c3a4c97e65b561b01e7b2953cf48683fb2724169\nF ext/session/sessionrebase.test ccfa716b23bd1d3b03217ee58cfd90c78d4b99f53e6a9a2f05e82363b9142810\nF ext/session/sessionstat1.test 218d351cf9fcd6648f125a26b607b140310160184723c2666091b54450a68fb5\nF ext/session/sessionwor.test 67b5ab91d4f93ce65ff1f58240ac5ddf73f8670facc1ffa49cef56293d52818d\nF ext/session/sqlite3session.c a4dfb372f270df93422b0dc7666fd46849e6979b62a152f11287c21eed4ac21b\nF ext/session/sqlite3session.h a2db5b72b938d12c727b4b4ec632254ca493670a9c0de597af3271a7f774fc57\nF ext/session/test_session.c 98797aba475a799376c9a42214f2d1debf2d0c3cb657d9c8bbf4f70bf3fb4aec\nF ext/userauth/sqlite3userauth.h 7f3ea8c4686db8e40b0a0e7a8e0b00fac13aa7a3\nF ext/userauth/user-auth.txt e6641021a9210364665fe625d067617d03f27b04\nF ext/userauth/userauth.c f81aa5a3ecacf406f170c62a144405858f6f6de51dbdc0920134e629edbe2648\nF install-sh 9d4de14ab9fb0facae2f48780b874848cbf2f895 x\nF ltmain.sh 3ff0879076df340d2e23ae905484d8c15d5fdea8\nF magic.txt 8273bf49ba3b0c8559cb2774495390c31fd61c60\nF main.mk 7ce055f3df31a4f7d21e38f493f907c21db1f673863a573e231f55e2ab005023\nF mkso.sh fd21c06b063bb16a5d25deea1752c2da6ac3ed83\nF mptest/config01.test 3c6adcbc50b991866855f1977ff172eb6d901271\nF mptest/config02.test 4415dfe36c48785f751e16e32c20b077c28ae504\nF mptest/crash01.test 61e61469e257df0850df4293d7d4d6c2af301421\nF mptest/crash02.subtest f4ef05adcd15d60e5d2bd654204f2c008b519df8\nF mptest/mptest.c aa41ace6dbc5050d76b02548d3521e6bbccae4f0\nF mptest/multiwrite01.test dab5c5f8f9534971efce679152c5146da265222d\nF spec.template 86a4a43b99ebb3e75e6b9a735d5fd293a24e90ca\nF sqlite.pc.in 42b7bf0d02e08b9e77734a47798d1a55a9e0716b\nF sqlite3.1 fc7ad8990fc8409983309bb80de8c811a7506786\nF sqlite3.pc.in 48fed132e7cb71ab676105d2a4dc77127d8c1f3a\nF src/alter.c 14b5516be5b3815d30bf230b619978f6158e754a1d624f70a02cfe2178348b5c\nF src/analyze.c b3ceec3fc052df8a96ca8a8c858d455dc5029ba681b4be98bb5c5a9162cfa58c\nF src/attach.c b30c44333d55a68c0a12920b5b9d40b254cbd3d4509bda77417209eeed8b3d80\nF src/auth.c a3d5bfdba83d25abed1013a8c7a5f204e2e29b0c25242a56bc02bb0c07bf1e06\nF src/backup.c f70077d40c08b7787bfe934e4d1da8030cb0cc57d46b345fba2294b7d1be23ab\nF src/bitvec.c 17ea48eff8ba979f1f5b04cc484c7bb2be632f33\nF src/btmutex.c 8acc2f464ee76324bf13310df5692a262b801808984c1b79defb2503bbafadb6\nF src/btree.c d22498af716953400e314d2d98d1dac3ea5c3b01e0fd243ef9e9b132c74114ec\nF src/btree.h f27a33c49280209a93385e218306c4ee5f46ba8d7649d2f81a7166b282232484\nF src/btreeInt.h 91806f01fd1145a9a86ba3042f25c38d8faf6002701bf5e780742cf88bcff437\nF src/build.c 358e894867394839679982d2fe320fb44fd17c94a87feb898aa066c15a8066ea\nF src/callback.c 88615dfc0a82167b65b452b4b305dbf86be77200b3343c6ffc6d03e92a01d181\nF src/complete.c a3634ab1e687055cd002e11b8f43eb75c17da23e\nF src/ctime.c 1b0724e66f95f33b160b1af85caaf9cceb325d22abf39bd24df4f54a73982251\nF src/date.c e1d8ac7102f3f283e63e13867acb0efa33861cf34f0faf4cdbaf9fa7a1eb7041\nF src/dbpage.c 135eb3b5e74f9ef74bde5cec2571192c90c86984fa534c88bf4a055076fa19b7\nF src/dbstat.c 6c407e549406c10fde9ac3987f6d734459205239ad370369bc5fcd683084a4fa\nF src/delete.c a5c59b9c0251cf7682bc52af0d64f09b1aefc6781a63592c8f1136f7b73c66e4\nF src/expr.c 8f873d6a411483a0ba14367aebf63c1f9f4346ef755739ec11feb14fa662002d\nF src/fault.c 460f3e55994363812d9d60844b2a6de88826e007\nF src/fkey.c 92a248ec0fa4ed8ab60c98d9b188ce173aaf218f32e7737ba77deb2a684f9847\nF src/func.c ed33e38cd642058182a31a3f518f2e34f4bbe53aa483335705c153c4d3e50b12\nF src/global.c a1a8d698762ddd9a1543aac26c1e0029b20fcc3fcb56bfa41ec8cea2368f2798\nF src/hash.c 8d7dda241d0ebdafb6ffdeda3149a412d7df75102cecfc1021c98d6219823b19\nF src/hash.h 9d56a9079d523b648774c1784b74b89bd93fac7b365210157482e4319a468f38\nF src/hwtime.h cb1d7e3e1ed94b7aa6fde95ae2c2daccc3df826be26fc9ed7fd90d1750ae6144\nF src/in-operator.md 10cd8f4bcd225a32518407c2fb2484089112fd71\nF src/insert.c 831408b14a146e93a4e02ddba54dcdfd8097463b9c00ca2ed9daed790c5d452a\nF src/legacy.c d7874bc885906868cd51e6c2156698f2754f02d9eee1bae2d687323c3ca8e5aa\nF src/loadext.c d74f5e7bd51f3c9d283442473eb65aef359664efd6513591c03f01881c4ae2da\nF src/main.c 868ae7db7a54fe859bf2ca8b7a4f24e9fa03a6134abfb7c9801d08411ef5dacb\nF src/malloc.c 550021fcae36f0ffe9f8563d83e6385f9df307a854d55d7d0abb7241ee8dbcc6\nF src/mem0.c 6a55ebe57c46ca1a7d98da93aaa07f99f1059645\nF src/mem1.c c12a42539b1ba105e3707d0e628ad70e611040d8f5e38cf942cee30c867083de\nF src/mem2.c f1940d9e91948dd6a908fbb9ce3835c36b5d83c3\nF src/mem3.c 8768ac94694f31ffaf8b4d0ea5dc08af7010a35a\nF src/mem5.c 9bf955937b07f8c32541c8a9991f33ce3173d944\nF src/memdb.c 02a5fcec19b9d40dd449ca802dc1b2e8f93f255fbf2a886277a3c3800d8d35db\nF src/memjournal.c 7561c01c90958f3ba9bc6cb2d857123d932bdfa5539ea34427a0957b2e35154d\nF src/msvc.h 3a15918220367a8876be3fa4f2abe423a861491e84b864fb2b7426bf022a28f8\nF src/mutex.c bae36f8af32c22ad80bbf0ccebec63c252b6a2b86e4d3e42672ff287ebf4a604\nF src/mutex.h a7b2293c48db5f27007c3bdb21d438873637d12658f5a0bf8ad025bb96803c4a\nF src/mutex_noop.c 9d4309c075ba9cc7249e19412d3d62f7f94839c4\nF src/mutex_unix.c aaf9ebc3f89df28483c52208497a99a02cc3650011422fc9d4c57e4392f7fe58\nF src/mutex_w32.c 7670d770c94bbfe8289bec9d7f1394c5a00a57c37f892aab6b6612d085255235\nF src/notify.c 9711a7575036f0d3040ba61bc6e217f13a9888e7\nF src/os.c 669cc3839cc35d20f81faf0be1ab6d4581cea35e9d8f3a9d48a98d6571f7c285\nF src/os.h 48388821692e87da174ea198bf96b1b2d9d83be5dfc908f673ee21fafbe0d432\nF src/os_common.h b2f4707a603e36811d9b1a13278bffd757857b85\nF src/os_setup.h 0dbaea40a7d36bf311613d31342e0b99e2536586\nF src/os_unix.c 3e0e519f27683083a465e948e056759a8340728c222b5c394a135e0c57c220bc\nF src/os_win.c 035a813cbd17f355bdcad7ab894af214a9c13a1db8aeac902365350b98cd45a7\nF src/os_win.h 7b073010f1451abe501be30d12f6bc599824944a\nF src/pager.c 30f20d2263d3717f41a0d9a40f7a3d0f48ce1cfab461b875c6187ead9d6ad1c7\nF src/pager.h 217921e81eb5fe455caa5cda96061959706bcdd29ddb57166198645ef7822ac3\nF src/parse.y c8d2de64db469fd56e0fa24da46cd8ec8523eb98626567d2708df371b47fdc3f\nF src/pcache.c 385ff064bca69789d199a98e2169445dc16e4291fa807babd61d4890c3b34177\nF src/pcache.h 4f87acd914cef5016fae3030343540d75f5b85a1877eed1a2a19b9f284248586\nF src/pcache1.c 6596e10baf3d8f84cc1585d226cf1ab26564a5f5caf85a15757a281ff977d51a\nF src/pragma.c 26e9ee514138b9697d4be6d8f9ca84655053026390cf10de838862238aa4aba9\nF src/pragma.h ec3b31eac9b1df040f1cc8cb3d89bc06605c3b4cb3d76f833de8d6d6c3f77f04\nF src/prepare.c 6049beb71385f017af6fc320d2c75a4e50b75e280c54232442b785fbb83df057\nF src/printf.c 9be6945837c839ba57837b4bc3af349eba630920fa5532aa518816defe42a7d4\nF src/random.c 80f5d666f23feb3e6665a6ce04c7197212a88384\nF src/resolve.c 86a7773d2892227ba9ad1721c41bb03c501830f1bf6de5f78dd0062b82e10c9d\nF src/rowset.c d977b011993aaea002cab3e0bb2ce50cf346000dff94e944d547b989f4b1fe93\nF src/select.c dd7e40967760b28efe274ade35043d5bf5d72774208bb75d2cb4dd59cbd59ad1\nF src/shell.c.in 4a3a9e1c11847b1904f2b01d087af1c052f660902755abab457cab1756817ded\nF src/sqlite.h.in 2a23e8161775253d9cf383c2c6aa559005dc787d350dcb0be67a6c4cc3bd1d19\nF src/sqlite3.rc 5121c9e10c3964d5755191c80dd1180c122fc3a8\nF src/sqlite3ext.h 72af51aa4e912e14cd495fb6e7fac65f0940db80ed950d90911aff292cc47ce2\nF src/sqliteInt.h 60d92fad64da7c3e77bbc35ee306340814cdaa5df32892b0ec58d306d99b5733\nF src/sqliteLimit.h 1513bfb7b20378aa0041e7022d04acb73525de35b80b252f1b83fedb4de6a76b\nF src/status.c 46e7aec11f79dad50965a5ca5fa9de009f7d6bde08be2156f1538a0a296d4d0e\nF src/table.c b46ad567748f24a326d9de40e5b9659f96ffff34\nF src/tclsqlite.c 8cd2600e8de23dff6cdf84d39f46ca57139b061b28f6f80b166bace17d52ab1c\nF src/test1.c c654981c1d86ebc90dd23fcc0969e6c85e28112f0acc2e2224a97a2a33e7c42f\nF src/test2.c 3efb99ab7f1fc8d154933e02ae1378bac9637da5\nF src/test3.c 61798bb0d38b915067a8c8e03f5a534b431181f802659a6616f9b4ff7d872644\nF src/test4.c 405834f6a93ec395cc4c9bb8ecebf7c3d8079e7ca16ae65e82d01afd229694bb\nF src/test5.c 328aae2c010c57a9829d255dc099d6899311672d\nF src/test6.c e8d839fbc552ce044bec8234561a2d5b8819b48e29548ad0ba400471697946a8\nF src/test7.c 5612e9aecf934d6df7bba6ce861fdf5ba5456010\nF src/test8.c 3f7d0cc4e12e06832ba3db4455cb16867ccadafa602eb6ff5fcf097bffce56ed\nF src/test9.c 12e5ba554d2d1cbe0158f6ab3f7ffcd7a86ee4e5\nF src/test_async.c 195ab49da082053fdb0f949c114b806a49ca770a\nF src/test_autoext.c 915d245e736652a219a907909bb6710f0d587871\nF src/test_backup.c bf5da90c9926df0a4b941f2d92825a01bbe090a0\nF src/test_bestindex.c 78809f11026f18a93fcfd798d9479cba37e1201c830260bf1edc674b2fa9b857\nF src/test_blob.c ae4a0620b478548afb67963095a7417cd06a4ec0a56adb453542203bfdcb31ce\nF src/test_btree.c 8b2dc8b8848cf3a4db93f11578f075e82252a274\nF src/test_config.c e25826d693039cdd45963de378cbf39e3af0e8aa7a8a6fc159876f4e7b5a4f8c\nF src/test_delete.c e2fe07646dff6300b48d49b2fee2fe192ed389e834dd635e3b3bac0ce0bf9f8f\nF src/test_demovfs.c 86142ba864d4297d54c5b2e972e74f3141ae4b30f05b3a95824184ed2d3d7f91\nF src/test_devsym.c 6109b45c3db3ef7b002320947ed448c027356ab8b885156ff535fd8684d4a571\nF src/test_fs.c ba1e1dc18fd3159fdba0b9c4256f14032159785320dfbd6776eb9973cb75d480\nF src/test_func.c 181f992e5495644434c4f0e3cc72362a78c295eb2cf3ff4d02498b8bde7aa276\nF src/test_hexio.c d170d0e1a6431afdeac086a250d2595078288c2257615d37949355361399bcaa\nF src/test_init.c 4413c211a94b62157ca4c145b3f27c497f03c664\nF src/test_intarray.c 39b4181662a0f33a427748d87218e7578d913e683dc27eab7098bb41617cac71\nF src/test_intarray.h d57ae92f420cda25e22790dac474d60961bd0c500cbaa3338a05152d4a669ef7\nF src/test_journal.c a0b9709b2f12b1ec819eea8a1176f283bca6d688a6d4a502bd6fd79786f4e287\nF src/test_loadext.c 337056bae59f80b9eb00ba82088b39d0f4fe6dfd\nF src/test_malloc.c dec0aa821b230773aeb3dd11d652c1193f7cedb18a20b25659bc672288115242\nF src/test_md5.c 7268e1e8c399d4a5e181b64ac20e1e6f3bc4dd9fc87abac02db145a3d951fa8c\nF src/test_multiplex.c e054459f7633f3ff8ce1245da724f9a8be189e4e\nF src/test_multiplex.h 5436d03f2d0501d04f3ed50a75819e190495b635\nF src/test_mutex.c 7f4337ba23ee6b1d2ec81c189653608cb069926a\nF src/test_onefile.c f31e52e891c5fef6709b9fcef54ce660648a34172423a9cbdf4cbce3ba0049f4\nF src/test_osinst.c 98ef31ff03d55497829ca0f6c74a9f4e1aa48690\nF src/test_pcache.c a5cd24730cb43c5b18629043314548c9169abb00\nF src/test_quota.c 6cb9297115b551f433a9ad1741817a9831abed99\nF src/test_quota.h 2a8ad1952d1d2ca9af0ce0465e56e6c023b5e15d\nF src/test_rtree.c 671f3fae50ff116ef2e32a3bf1fe21b5615b4b7b\nF src/test_schema.c f575932cb6274d12147a77e13ea4b49d52408513\nF src/test_server.c a2615049954cbb9cfb4a62e18e2f0616e4dc38fe\nF src/test_sqllog.c 11e6ce7575f489155c604ac4b439f2ac1d3d5aef\nF src/test_superlock.c 4839644b9201da822f181c5bc406c0b2385f672e\nF src/test_syscall.c 1073306ba2e9bfc886771871a13d3de281ed3939\nF src/test_tclsh.c eeafce33ad2136d57e5dec10f1e9a4347447eb72ffd504a1c7b9c6bfe2e71578\nF src/test_tclvar.c 33ff42149494a39c5fbb0df3d25d6fafb2f668888e41c0688d07273dcb268dfc\nF src/test_thread.c 911d15fb14e19c0c542bdc8aabf981c2f10a4858\nF src/test_vdbecov.c f60c6f135ec42c0de013a1d5136777aa328a776d33277f92abac648930453d43\nF src/test_vfs.c 36822d696789535bdd0260f07d2c9a46546082fea8bb1d0a7354c7f9366e37ea\nF src/test_vfstrace.c bab9594adc976cbe696ff3970728830b4c5ed698\nF src/test_windirent.c a895e2c068a06644eef91a7f0a32182445a893b9a0f33d0cdb4283dca2486ac1\nF src/test_windirent.h 90dfbe95442c9762357fe128dc7ae3dc199d006de93eb33ba3972e0a90484215\nF src/test_window.c cdae419fdcea5bad6dcd9368c685abdad6deb59e9fc8b84b153de513d394ba3f\nF src/test_wsd.c 41cadfd9d97fe8e3e4e44f61a4a8ccd6f7ca8fe9\nF src/threads.c 4ae07fa022a3dc7c5beb373cf744a85d3c5c6c3c\nF src/tokenize.c 7b17f6e2f20f6cbcb0b215025a86b7457c38451fc7622f705e553d7a488c572d\nF src/treeview.c 41d928f04d65931b15f629b4938e9f2c7dc259f02eef34cb2cc6e293f5af813f\nF src/trigger.c 681ccdb910a87243940d63f99b26190d9c5d2534c2ded3c0825b7c0e315a342e\nF src/update.c 07a50767f7d3e26d4c887c31cd66448d700d3215caea6023acf7269336097df7\nF src/upsert.c b445315c8958d8f17ec3297d06842e61dacaad0633ccaec1e4e160de7e562212\nF src/utf.c 2f0fac345c7660d5c5bd3df9e9d8d33d4c27f366bcfb09e07443064d751a0507\nF src/util.c 2c92bc706bbdb1c45a25180291e7e05a56e297aa5dd7b2bcd2b1c47e8bb05b17\nF src/vacuum.c 82dcec9e7b1afa980288718ad11bc499651c722d7b9f32933c4d694d91cb6ebf\nF src/vdbe.c ab3f6e647235fe4fa16b71496468313a1da435eb3a2125c3ffdbb0be0d1cbcba\nF src/vdbe.h fdbc0a11e5768a702b46ce63286f60e22e71351a29bd98b3666405e1fccc7802\nF src/vdbeInt.h bd589b8b7273286858950717e0e1ec5c88b18af45079a3366dc1371865cea704\nF src/vdbeapi.c 1252d80c548711e47a6d84dae88ed4e95d3fbb4e7bd0eaa1347299af7efddf02\nF src/vdbeaux.c ede199fe272656338741dd831da86362a3b60e42fb12ef5389ea1325823e9686\nF src/vdbeblob.c 253ed82894924c362a7fa3079551d3554cd1cdace39aa833da77d3bc67e7c1b1\nF src/vdbemem.c 2eb00a4d1a7d2c97510a4d1ccaf4e12c9143f2ced1c6b96b5eddc372183c9121\nF src/vdbesort.c a3be032cc3fee0e3af31773af4a7a6f931b7230a34f53282ccf1d9a2a72343be\nF src/vdbetrace.c fa3bf238002f0bbbdfb66cc8afb0cea284ff9f148d6439bc1f6f2b4c3b7143f0\nF src/vtab.c 2736f853a1bd270581f76bae8e5d2e840b6258f3d85c1fa382e9454b3c414d1d\nF src/vxworks.h d2988f4e5a61a4dfe82c6524dd3d6e4f2ce3cdb9\nF src/wal.c 15a2845769f51ba132f9cf0b2c7a6887a91fc8437892dbcce9fcdc68b66d60a1\nF src/wal.h 606292549f5a7be50b6227bd685fa76e3a4affad71bb8ac5ce4cb5c79f6a176a\nF src/walker.c a137468bf36c92e64d2275caa80c83902e3a0fc59273591b96c6416d3253d05d\nF src/where.c c51ebd505c8417285ca1db8f94933a12224bf636ad93f27d821c07f93d59c035\nF src/whereInt.h 4a296fd4fa79fdcbc2b5e8c1b898901617655811223e1082b899c23ecb092217\nF src/wherecode.c 7efa97f4dc2f95548611deba68f0210ab357725899a9bae5391a525e48271875\nF src/whereexpr.c 39b6a538804c6e1248c22b33e09d00f89ae6a099c849c4d841ce3995562287b4\nF src/window.c 913a10696f5197adae32738a7c7cabc03e1f1553240d6c9ce868ee57f5cee88e\nF test/8_3_names.test ebbb5cd36741350040fd28b432ceadf495be25b2\nF test/affinity2.test ce1aafc86e110685b324e9a763eab4f2a73f737842ec3b687bd965867de90627\nF test/affinity3.test 6a101af2fc945ce2912f6fe54dd646018551710d\nF test/aggerror.test a867e273ef9e3d7919f03ef4f0e8c0d2767944f2\nF test/aggnested.test 12106f0748e8e9bfc1a8e6840e203e051eae06a26ed13fc9fd5db108a8d6db54\nF test/alias.test 4529fbc152f190268a15f9384a5651bbbabc9d87\nF test/all.test 2ecb8bbd52416642e41c9081182a8df05d42c75637afd4488aace78cc4b69e13\nF test/alter.test 16ed8d2470193f34bc711e51506ff1211ebfab8025ca3b9510ff2aef139874cb\nF test/alter2.test a966ccfcddf9ce0a4e0e6ff1aca9e6e7948e0e242cd7e43fc091948521807687\nF test/alter3.test 9351a9f0c59ff9dddecccaaa2f777ffee5369870c63d30d3a74add815254ec0f\nF test/alter4.test 74b22251c5e9c48093cfc4921ed9c11b59df84634aeeb00e501773320beb8424\nF test/alterauth.test 63442ba61ceb0c1eeb63aac1f4f5cebfa509d352276059d27106ae256bafc959\nF test/alterauth2.test c0a1ddf5b93d93cb0d15ba7acaf0c5c6fb515bbe861ede75b2d3fabad33b6499\nF test/altercol.test 54374d2ba18af25bb24e23acf18a60270d4ec120b7ec0558078b59d5aa1a31ad\nF test/alterlegacy.test 82022721ce0de29cedc9a7af63bc9fcc078b0ee000f8283b4b6ea9c3eab2f44b\nF test/altermalloc.test 167a47de41b5c638f5f5c6efb59784002b196fff70f98d9b4ed3cd74a3fb80c9\nF test/altermalloc2.test fa7b1c1139ea39b8dec407cf1feb032ca8e0076bd429574969b619175ad0174b\nF test/altertab.test 4d8b79b0b88b62b90b710390df14fe99e0a3578345526886eaa550e28e3065dc\nF test/altertab2.test 8883693952f6d7fb5f754dbf1d694ed780aa883027bef04cb1fb99a3b88c9272\nF test/altertab3.test 231881a8e9c4905a84213476c64c174a119e1ab75ce17d986dcbbacc07b2b544\nF test/amatch1.test b5ae7065f042b7f4c1c922933f4700add50cdb9f\nF test/analyze.test 547bb700f903107b38611b014ca645d6b5bb819f5210d7bf39c40802aafeb7d7\nF test/analyze3.test 01f0b122e3e54ad2544f14f7cc7dcb4c2cb8753cad5e88c6b8d49615b3fd6a2b\nF test/analyze4.test cdf88f3f72b0f0643a1ff6c730fc5af1e42464d47478d9fbac84c333f72c014e\nF test/analyze5.test fa5131952303ac4146aba101b116b9c8cb89e2637531c334a6df7f7d19dddc0d\nF test/analyze6.test 6c3f7df2996cb6872f355a6ac1eb6d5de00a5a9288214bad7ef25c97d9cc72dc\nF test/analyze7.test 6ef0b12369f61ddeadc7d8a705c40e6b52cb29f63de3a4c56581b510b46b5783\nF test/analyze8.test 36ce54947710bd44e4f9484e1ad07e725ef01a9d7078b417c1bc884356febe4d\nF test/analyze9.test 9fbf0e0101eef4f5dc149769aa14e10b76ee06e7c28598264b32173cd1999a54\nF test/analyzeC.test 489fe2ea3be3f17548e8dd895f1b41c9669b52de1b0861f5bffe6eec46eac710\nF test/analyzeD.test e50cd0b3e6063216cc0c88a1776e8645dc0bd65a6bb275769cbee33b7fd8d90c\nF test/analyzeE.test 8684e8ac5722fb97c251887ad97e5d496a98af1d\nF test/analyzeF.test 9e1a0537949eb5483642b1140a5c39e5b4025939024b935398471fa552f4dabb\nF test/analyzer1.test 459fa02c445ddbf0101a3bad47b34290a35f2e49\nF test/async.test 1d0e056ba1bb9729283a0f22718d3a25e82c277b\nF test/async2.test c0a9bd20816d7d6a2ceca7b8c03d3d69c28ffb8b\nF test/async3.test d73a062002376d7edc1fe3edff493edbec1fc2f7\nF test/async4.test 1787e3952128aa10238bf39945126de7ca23685a\nF test/async5.test 383ab533fdb9f7ad228cc99ee66e1acb34cc0dc0\nF test/atof1.test ff0b0156fd705b67c506e1f2bfe9e26102bea9bd\nF test/atomic.test 065a453dde33c77ff586d91ccaa6ed419829d492dbb1a5694b8a09f3f9d7d061\nF test/atomic2.test b6863b4aa552543874f80b42fb3063f1c8c2e3d8e56b6562f00a3cc347b5c1da\nF test/atrc.c ec92d56d8fbed9eb3e11aaf1ab98cf7dd59e69dae31f128013f1d97e54e7dfed\nF test/attach.test 21bce8681f780a8d631a5ec7ecd0d849bfe84611257b038ae4ffeccc609d8a4e\nF test/attach2.test 256bd240da1835fb8408dd59fb7ef71f8358c7a756c46662434d11d07ba3a0ce\nF test/attach3.test c59d92791070c59272e00183b7353eeb94915976\nF test/attach4.test aa05b1d8218b24eba5a7cccf4f224f514ba57ba705c9267f09d2bb63fed0eea1\nF test/attachmalloc.test 12c4f028e570acf9e0a4b0b7fe6f536e21f3d5ebddcece423603d0569beaf438\nF test/auth.test 2154625c05bc79f0e0ea72cb2358395a8041243caa0fd7ce7617d50da4331794\nF test/auth2.test 9eb7fce9f34bf1f50d3f366fb3e606be5a2000a1\nF test/auth3.test db21405b95257c24d29273b6b31d0efc59e1d337e3d5804ba2d1fd4897b1ae49\nF test/autoanalyze1.test b9cc3f32a990fa56669b668d237c6d53e983554ae80c0604992e18869a0b2dec\nF test/autoinc.test 997d6f185f138229dc4251583a1d04816423dddc2fc034871a01aeb1d728cb39\nF test/autoindex1.test 96185415f5faacd5b8d7a7f505efddd5abb1f111d58338e9c0b1dc40b87cd3cc\nF test/autoindex2.test 12ef578928102baaa0dc23ad397601a2f4ecb0df\nF test/autoindex3.test 2dd997d6590438b53e4f715f9278aa91c9299cf3f81246a0915269c35beb790e\nF test/autoindex4.test 49d3cd791a9baa16fb461d7ea3de80d019a819cf\nF test/autoindex5.test a5d72fe8c217cc0ea356dc6fa06a282a8a3fc53aa807709d79dba07a8f248102\nF test/autovacuum.test 0831cd34e14695d297187f7f6519265e3121c5b0a1720e548e86829e796129e9\nF test/autovacuum_ioerr2.test 8a367b224183ad801e0e24dcb7d1501f45f244b4\nF test/avtrans.test b7dc25459ecbd86c6fa9c606ee3068f59d81e225118617dcf2bbb6ded2ade89e\nF test/backcompat.test 3e64cedda754c778ef6bbe417b6e7a295e662a4d\nF test/backup.test dd4a5ff756e3df3931dacb1791db0584d4bad989\nF test/backup2.test 1fd1ad8c5b3d2d5b9c0cce4143a4fc610d51ddc6ae16a7a122973d43e6b50bbd\nF test/backup4.test 8f6fd48e0dfde77b9a3bb26dc471ede3e101df32\nF test/backup5.test ee5da6d7fe5082f5b9b0bbfa31d016f52412a2e4\nF test/backup_ioerr.test 4c3c7147cee85b024ecf6e150e090c32fdbb5135\nF test/backup_malloc.test 0c9abdf74c51e7bedb66d504cd684f28d4bd4027\nF test/badutf.test d5360fc31f643d37a973ab0d8b4fb85799c3169f\nF test/badutf2.test f310fd3b24a491b6b77bccdf14923b85d6ebcce751068c180d93a6b8ff854399\nF test/bc_common.tcl b5e42d80305be95697e6370e015af571e5333a1c\nF test/bestindex1.test 705b57d7f51d53ee5fd043dd9666236e1fc18f4d59abf51da0ea5ea1b4804947\nF test/bestindex2.test 9a0ccd320b6525eec3a706aae6cdab7e1b7b5abca75027e39f39f755e76e5928\nF test/bestindex3.test 7622e792ff2da16d262d3cea6ad914591ac4806d57ed128e6c940b7920b47b84\nF test/bestindex4.test 038e3d0789332f3f1d61474f9bbc9c6d08c6bd1783a978f31f38ad82688de601\nF test/bestindex5.test 67c1166131bb59f9e47c00118f7d432ca5491e6cae6ca3f87ca9db20103a78f9\nF test/bestindex6.test d856a9bb63d927493575823eed44053bc36251e241aa364e54d0f2a2d302e1d4\nF test/between.test 68137a6e941c221417c15b6fe2d55f27bb1b6ab48bdf9e2aa51efdd85bc53802\nF test/bigfile.test aa74f4e5db51c8e54a1d9de9fa65d01d1eb20b59\nF test/bigfile2.test 1b489a3a39ae90c7f027b79110d6b4e1dbc71bfc\nF test/bigmmap.test 31dad31573638bd32de866cdefd11843f75685be4ba6aec1a47918f098f1899b\nF test/bigrow.test f0aeb7573dcb8caaafea76454be3ade29b7fc747\nF test/bigsort.test 8299fa9298f4f1e02fc7d2712e8b77d6cd60e5a2\nF test/bind.test 1e136709b306f7ed3192d349c2930d89df6ab621654ad6f1a72381d3fe76f483\nF test/bindxfer.test efecd12c580c14df5f4ad3b3e83c667744a4f7e0\nF test/bitvec.test 75894a880520164d73b1305c1c3f96882615e142\nF test/blob.test e7ac6c7d3a985cc4678c64f325292529a69ae252\nF test/boundary1.tcl 6421b2d920d8b09539503a8673339d32f7609eb1\nF test/boundary1.test 66d7f4706ccdb42d58eafdb081de07b0eb42d77b\nF test/boundary2.tcl e34ef4e930cf1083150d4d2c603e146bd3b76bcb\nF test/boundary2.test 9ae758d7dab7e882c8b6cc4a6a10278385bff8fa\nF test/boundary3.tcl 23361e108a125dca9c4080c2feb884fe54d69243\nF test/boundary3.test 56ef82096b4329aca2be74fa1e2b0f762ea0eb45\nF test/boundary4.tcl 0bb4b1a94f4fc5ae59b79b9a2b7a140c405e2983\nF test/boundary4.test 89e02fa66397b8a325d5eb102b5806f961f8ec4b\nF test/btree01.test e08b3613540145b353f20c81cb18ead54ff12e0f\nF test/btree02.test 7555a5440453d900410160a52554fe6478af4faf53098f7235f1f443d5a1d6cc\nF test/btreefault.test c2bcb542685eea44621275cfedbd8a13f65201e3\nF test/busy.test 510dc6daaad18bcbbc085bcc6217d6dc418def5e73f72ce1475eea0cb7834727\nF test/cache.test 13bc046b26210471ca6f2889aceb1ea52dc717de\nF test/cacheflush.test af25bb1509df04c1da10e38d8f322d66eceedf61\nF test/cachespill.test 895997f84a25b323b166aecb69baab2d6380ea98f9e0bcc688c4493c535cfab9\nF test/capi2.test 34a1a9a96d543a2ec2c209696b11b164444f57253b1f2cba1c2e53fadede6c7b\nF test/capi3.test 3910a73c38ac76d69778dd9eb481ab7cd6ed59117fc047b4f6056a5c72529de1\nF test/capi3b.test efb2b9cfd127efa84433cd7a2d72ce0454ae0dc4\nF test/capi3c.test 54e2dc0c8fd7c34ad1590d1be6864397da2438c95a9f5aee2f8fbc60c112e44b\nF test/capi3d.test aba917805573a03deed961a21f07a5a84505ad0a616f7e3fc1508844a15bccc4\nF test/capi3e.test 3d49c01ef2a1a55f41d73cba2b23b5059ec460fe\nF test/cast.test 3619f0c58c2e4b2a94aa86e75607e497d34ef40ab74418e71aef7b4ca5155895\nF test/cffault.test 9d6b20606afe712374952eec4f8fd74b1a8097ef\nF test/check.test 25c6035302c846c7ff8e681cf8284473f6f01be94d327de60a688ad84ab01f8b\nF test/checkfault.test da6cb3d50247169efcb20bdf57863a3ccfa1d27d9e55cd324f0680096970f014\nF test/chunksize.test 427d87791743486cbf0c3b8c625002f3255cb3a89c6eba655a98923b1387b760\nF test/close.test eccbad8ecd611d974cbf47278c3d4e5874faf02d811338d5d348af42d56d647c\nF test/closure01.test 9905883f1b171a4638f98fc764879f154e214a306d3d8daf412a15e7f3a9b1e0\nF test/coalesce.test cee0dccb9fbd2d494b77234bccf9dc6c6786eb91\nF test/collate1.test 4178fda6f4cd757b7a278e6b83805868fb1eb46edafb6e3d4bcc2419f8d93202\nF test/collate2.test 9aaa410a00734e48bcb27f3872617d6f69b2a621\nF test/collate3.test 89defc49983ddfbf0a0555aca8c0521a676f56a5\nF test/collate4.test c953715fb498b87163e3e73dd94356bff1f317bd\nF test/collate5.test 65d928034d30d2d263a80f6359f7549ee1598ec6\nF test/collate6.test 8be65a182abaac8011a622131486dafb8076e907\nF test/collate7.test 8ec29d98f3ee4ccebce6e16ce3863fb6b8c7b868\nF test/collate8.test cd9b3d3f999b8520ffaa7cc1647061fc5bab1334\nF test/collate9.test 3adcc799229545940df2f25308dd1ad65869145a\nF test/collateA.test b8218ab90d1fa5c59dcf156efabb1b2599c580d6\nF test/collateB.test 1e68906951b846570f29f20102ed91d29e634854ee47454d725f2151ecac0b95\nF test/colmeta.test 2c765ea61ee37bc43bbe6d6047f89004e6508eb1\nF test/colname.test 87ad5458bb8709312dac0d6755fd30e8e4ca83298d0a9ef6e5c24277a3c3390e\nF test/conflict.test 58857e2533fb9f2e0358ea7cb191215657846be1dd9da3b3d6df3e750c02ae03\nF test/conflict2.test bb0b94cf7196c64a3cbd815c66d3ee98c2fecd9c\nF test/conflict3.test f62a2d0cad9162a60e6458fc913dff3a2208feca924120c21737cfee65a6a74a\nF test/contrib01.test 2a1cbc0f2f48955d7d073f725765da6fbceda6b4\nF test/corrupt.test d7cb0300e4a297147b6a05e92a1684bc8973635c3bcaa3d66e983c9cbdbf47a3\nF test/corrupt2.test bb50042cf9a1f1023d73af325d47eb02a6bb11e3c52f8812644b220c5d4bca35\nF test/corrupt3.test f95d7bf78109e0b84eb285a787ce91a3fd6a2dd7d0cb55882abff3bdc081a57e\nF test/corrupt4.test 8d1d86b850fcc43e417450454f2044e52d55778a\nF test/corrupt5.test 387be3250795e2a86e6234745558b80efb248a357d0cd8e53bce75c7463f545d\nF test/corrupt6.test fc6a891716139665dae0073b6945e3670bf92568\nF test/corrupt7.test b036f94bda4b0b23a2919bf717046ce9ecca4543\nF test/corrupt8.test 2399dfe40d2c0c63af86706e30f3e6302a8d0516\nF test/corrupt9.test 730a3db08d4ab9aa43392ea30d9c2b4879cbff85\nF test/corruptA.test 112f4b2ae0b95ebf3ea63718642fb969a93acea557ace3a307234d19c245989b\nF test/corruptB.test 73a8d6c0b9833697ecf16b63e3c5c05c945b5dec\nF test/corruptC.test 74d4498fd25759618b393f1e9cde111de828b88c1848ab320f6c179fd52b5a60\nF test/corruptD.test 33a37ce3ed56a20093ceee778cd2d7109c7085a59f3213d2baede11d952e8e50\nF test/corruptE.test 4143791f2dfb443aec5b7fabfa5821e6063eccc3b49b06f212c2f014715fd476\nF test/corruptF.test be9fde98e4c93648f1ba52b74e5318edc8f59fe4\nF test/corruptG.test adf79b669cbfd19e28c8191a610d083ae53a6d51\nF test/corruptH.test 79801d97ec5c2f9f3c87739aa1ec2eb786f96454\nF test/corruptI.test a17bbf54fdde78d43cf3cc34b0057719fd4a173a3d824285b67dc5257c064c7b\nF test/corruptJ.test 4d5ccc4bf959464229a836d60142831ef76a5aa4\nF test/corruptK.test 5b4212fe346699831c5ad559a62c54e11c0611bdde1ea8423a091f9c01aa32af\nF test/corruptL.test a22a7bbf8da7603960f0bfcc62a68d1c3c41963786bd832ff804ba5e2458fb9c\nF test/corruptM.test 7d574320e08c1b36caa3e47262061f186367d593a7e305d35f15289cc2c3e067\nF test/cost.test 51f4fcaae6e78ad5a57096831259ed6c760e2ac6876836e91c00030fad385b34\nF test/count.test cb2e0f934c6eb33670044520748d2ecccd46259c\nF test/countofview.test e17d6e6688cf74f22783c9ec6e788c0790ee4fbbaee713affd00b1ac0bb39b86\nF test/coveridxscan.test 5ec98719a2e2914e8908dc75f7247d9b54a26df04625f846ac7900d5483f7296\nF test/crash.test fb9dc4a02dcba30d4aa5c2c226f98b220b2b959f\nF test/crash2.test 5b14d4eb58b880e231361d3b609b216acda86651\nF test/crash3.test 8f5de9d32ab9ab95475a9efe7f47a940aa889418\nF test/crash4.test fe2821baf37168dc59dd733dcf7dba2a401487bc\nF test/crash5.test f14ff37eddc41991be4eb63568f86caa306fd9962a0ae3750db8836777bb7aae\nF test/crash6.test 4c56f1e40d0291e1110790a99807aa875b1647ba\nF test/crash7.test 1a194c4900a255258cf94b7fcbfd29536db572df\nF test/crash8.test 64366e459c28dd62edfb7ad87253a409c7533b92d16fcc479a6a8131bdcc3100\nF test/crashM.test d95f59046fa749b0d0822edf18a717788c8f318d\nF test/crashtest1.c 09c1c7d728ccf4feb9e481671e29dda5669bbcc2\nF test/createtab.test 85cdfdae5c3de331cd888d6c66e1aba575b47c2e3c3cc4a1d6f54140699f5165\nF test/cse.test 277350a26264495e86b1785f34d2d0c8600e021c\nF test/csv01.test c9c3af0d58c34e9ac970c5875a77939edb958762c8aafb95409e19a3f088b6cd\nF test/ctime.test 78749e6c9a5f0010d67985be80788f841e3cd2da18114e2ed6010399a7d807f3\nF test/cursorhint.test 7bc346788390475e77a345da2b92270d04d35856\nF test/cursorhint2.test 6f3aa9cb19e7418967a10ec6905209bcbb5968054da855fc36c8beee9ae9c42f\nF test/dataversion1.test 6e5e86ac681f0782e766ebcb56c019ae001522d114e0e111e5ebf68ccf2a7bb8\nF test/date.test 9b73bbeb1b82d9c1f44dec5cf563bf7da58d2373\nF test/date2.test 5ef8265c71460cda6b1698bf18f4bb0ffb40ac08c5092f6afe84d398c2feb5be\nF test/dbdata.test 042f49acff3438f940eeba5868d3af080ae64ddf26ae78f80c92bec3ca7d8603\nF test/dbfuzz.c 73047c920d6210e5912c87cdffd9a1c281d4252e\nF test/dbfuzz001.test 42aad1dcef6219fbee86a9b7d08832c9bbb2e41508f6f128ae91745927276292\nF test/dbfuzz2-seed1.db e6225c6f3d7b63f9c5b6867146a5f329d997ab105bee64644dc2b3a2f2aebaee\nF test/dbfuzz2.c c2c9cb40082a77b7e95ffb8b2da1e93322efadfb1c8c1e0001c95a0af1e156c2\nF test/dbpage.test 650234ba683b9d82b899c6c51439819787e7609f17a0cc40e0080a7b6443bc38\nF test/dbstatus.test 4a4221a883025ffd39696b3d1b3910b928fb097d77e671351acb35f3aed42759\nF test/dbstatus2.test f5fe0afed3fa45e57cfa70d1147606c20d2ba23feac78e9a172f2fe8ab5b78ef\nF test/default.test 3e46c421eebefd2787c2f96673efabf792d360f3a1d5073918cbe450ce672a62\nF test/delete.test 31832b0c45ecb51a54348c68db173be462985901e6ed7f403d6d7a8f70ab4ef0\nF test/delete2.test 3a03f2cca1f9a67ec469915cb8babd6485db43fa\nF test/delete3.test 555e84a00a99230b7d049d477a324a631126a6ab\nF test/delete4.test 6aa279f459f4aa792cc251435c3809415c1ecaf9f27dce91675e26f05b503db3\nF test/delete_db.test 096d828493c7907f9ea11a7098ea6a0f73edba89406487d5d6cc2228dc4ab8b0\nF test/descidx1.test edc8adee58d491b06c7157c50364eaf1c3605c9c19f8093cb1ea2b6184f3ac13\nF test/descidx2.test a0ba347037ff3b811f4c6ceca5fd0f9d5d72e74e59f2d9de346a9d2f6ad78298\nF test/descidx3.test 953c831df7ea219c73826dfbf2f6ee02d95040725aa88ccb4fa43d1a1999b926\nF test/diskfull.test 106391384780753ea6896b7b4f005d10e9866b6e\nF test/distinct.test a1783b960ad8c15a77cd9f207be072898db1026c\nF test/distinct2.test 11b0594c932098e969d084ba45ab81d5040f4d4e766db65d49146705a305ed98\nF test/distinctagg.test 1a6ef9c87a58669438fc771450d7a72577417376\nF test/e_blobbytes.test 439a945953b35cb6948a552edaec4dc31fd70a05\nF test/e_blobclose.test 4b3c8c60c2171164d472059c73e9f3c1844bb66d\nF test/e_blobopen.test e95e1d40f995056f6f322cd5e1a1b83a27e1a145\nF test/e_blobwrite.test f87ff598b67af5b3ec002a8d83e804dc8d23808e88cf0080c176612fc9ffce14\nF test/e_changes.test fd66105385153dbf21fdb35eb8ef6c3e1eade579\nF test/e_createtable.test 1c602347e73ab80b11b9fa083f47155861aaafcff8054aac9e0b76d0df33b0a7\nF test/e_delete.test ab39084f26ae1f033c940b70ebdbbd523dc4962e\nF test/e_droptrigger.test 3cd080807622c13e5bbb61fc9a57bd7754da2412\nF test/e_dropview.test 21ce09c361227ddbc9819a5608ee2700c276bdd5\nF test/e_expr.test 328d2d7c84f8e53e942a13eac771b337bcdfcf4c3569324001868b5639f3c857\nF test/e_fkey.test 2febb2084aef9b0186782421c07bc9d377abf067c9cb4efd49d9647ae31f5afe\nF test/e_fts3.test 17ba7c373aba4d4f5696ba147ee23fd1a1ef70782af050e03e262ca187c5ee07\nF test/e_insert.test f02f7f17852b2163732c6611d193f84fc67bc641fb4882c77a464076e5eba80e\nF test/e_reindex.test 2b0e29344497d9a8a999453a003cb476b6b1d2eef2d6c120f83c2d3a429f3164\nF test/e_resolve.test a61751c368b109db73df0f20fc75fb47e166b1d8\nF test/e_select.test f9474205669a7736ef725b29cc7ae9e8601919a3d0ffc0ab30745a028f2a4b61\nF test/e_select2.test aceb80ab927d46fba5ce7586ebabf23e2bb0604f\nF test/e_totalchanges.test b12ee5809d3e63aeb83238dd501a7bca7fd72c10\nF test/e_update.test f46c2554d915c9197548681e8d8c33a267e84528\nF test/e_uri.test 47eeb2960e74613f0f8722b2f13aef08fde69daa16e5380ac93df84dac8b1f72\nF test/e_vacuum.test 0d8832a2ce92350db0d0cff47b419465fd9772562e1f77ff7d9478c07a4980d2\nF test/e_wal.test ae9a593207a77d711443ee69ffe081fda9243625\nF test/e_walauto.test 248af31e73c98df23476a22bdb815524c9dc3ba8\nF test/e_walckpt.test 28c371a6bb5e5fe7f31679c1df1763a19d19e8a0\nF test/e_walhook.test 01b494287ba9e60b70f6ebf3c6c62e0ffe01788e344a4846b08e5de0b344cb66\nF test/emptytable.test a38110becbdfa6325cd65cb588dca658cd885f62\nF test/enc.test e54531cd6bf941ee6760be041dff19a104c7acea\nF test/enc2.test 83437a79ba1545a55fb549309175c683fb334473\nF test/enc3.test 6807f7a7740a00361ca8d0ccd66bc60c8dc5f2b6\nF test/enc4.test c8f1ce3618508fd0909945beb8b8831feef2c020\nF test/eqp.test 84879b63e3110552bf8ce648a3507dc3ceb72109ecec83c2aef0db37a27f6382\nF test/errmsg.test eae9f091eb39ce7e20305de45d8e5d115b68fa856fba4ea6757b6ca3705ff7f9\nF test/eval.test a64c9105d6ff163df7cf09d6ac29cdad5922078c\nF test/exclusive.test 1206b87e192497d78c7f35552e86a9d05421498da300fb1cce5ca5351ccde3c3\nF test/exclusive2.test 984090e8e9d1b331d2e8111daf6e5d61dda0bef7\nF test/exec.test e949714dc127eaa5ecc7d723efec1ec27118fdd7\nF test/exists.test 79a75323c78f02bbe9c251ea502a092f9ef63dac\nF test/expr.test 7cb55e80aeb41d65fec968c08212505123063fea60bdc355d764d747670e9eea\nF test/expr2.test c27327ae9c017a7ff6280123f67aff496f912da74d78c888926d68b46ec75fd8\nF test/extension01.test 00d13cec817f331a687a243e0e5a2d87b0e358c9\nF test/extraquick.test cb254400bd42bfb777ff675356aabf3287978f79\nF test/fallocate.test 37a62e396a68eeede8f8d2ecf23573a80faceb630788d314d0a073d862616717\nF test/filectrl.test 6e871c2d35dead1d9a88e176e8d2ca094fec6bb3\nF test/filefmt.test f393e80c4b8d493b7a7f8f3809a8425bbf4292af1f5140f01cb1427798a2bbd4\nF test/filter1.test fe7fcfeff48ca399fbc9577f55b60c8be8ccfdffc5e3b4ace21dc3c3e59f0f6a\nF test/filter2.tcl 44e525497ce07382915f01bd29ffd0fa49dab3adb87253b5e5103ba8f93393e8\nF test/filter2.test 485cf95d1f6d6ceee5632201ca52a71868599836f430cdee42e5f7f14666e30a\nF test/filterfault.test c08fb491d698e8df6c122c98f7db1c65ffcfcad2c1ab0e07fa8a5be1b34eaa8b\nF test/fkey1.test d11dbb8a93ead9b5c46ae5d02da016d61245d47662fb2d844c99214f6163f768\nF test/fkey2.test d35d1c81e7569bdd2b872e91750f7098117d2e8291369f70b7e3d50a0e523dc2\nF test/fkey3.test 76d475c80b84ee7a5d062e56ccb6ea68882e2b49\nF test/fkey4.test 86446017011273aad8f9a99c1a65019e7bd9ca9d\nF test/fkey5.test 24dd28eb3d9f1b5a174f47e9899ace5facb08373a4223593c8c631e6cf9f7d5a\nF test/fkey6.test d078a1e323a740062bed38df32b8a736fd320dc0\nF test/fkey7.test 64fb28da03da5dfe3cdef5967aa7e832c2507bf7fb8f0780cacbca1f2338d031\nF test/fkey8.test 48ef829d63f5f7b37aabd4df9363ac05f65539d1da8c4a44251631769d920579\nF test/fkey_malloc.test 594a7ea1fbab553c036c70813cd8bd9407d63749\nF test/fordelete.test eb93a2f34137bb87bdab88fcab06c0bd92719aff\nF test/format4.test eeae341953db8b6bda7f549044797c3278a6cc345d11ada81471671b654f8ef4\nF test/fts-9fd058691.test 78b887e30ae6816df0e1fed6259de4b5a64ad33c\nF test/fts1a.test 46090311f85da51bb33bd5ce84f7948359c6d8d7\nF test/fts1b.test 5d8a01aefbecc8b7442b36c94c05eb7a845462d5\nF test/fts1c.test 85a525ce7428907469b4cce13d5563ce542ce64c\nF test/fts1d.test a73deace5c18df4a549b12908bade4f05dcf1a2f\nF test/fts1e.test 77244843e925560b5a0b70069c3e7ab62f181ed2\nF test/fts1f.test 2d6cb10d8b7a4e6edc321bbdb3982f1f48774714\nF test/fts1i.test 6bfe08cdfdced063a39a50c8601da65e6274d879\nF test/fts1j.test e3797475796043a161e348c46a309664cac83f7f\nF test/fts1k.test 65d3b41487b9f738d11b0f00eca375c0ca6bd970\nF test/fts1l.test 15c119ed2362b2b28d5300c0540a6a43eab66c36\nF test/fts1m.test 2d9ca67b095d49f037a914087cc0a61e89da4f0c\nF test/fts1n.test a2317dcd27b1d087ee3878b30e0a59c593c98b7a\nF test/fts1o.test d1554caede42bba2c82fe613bcc921856c196b752449ead0470fac52a20fd3b8\nF test/fts1porter.test d86e9c3e0c7f8ff95add6582b4b585fb4e02b96d\nF test/fts2.test e3fb95f96a650411574efc136f3fb10eef479ed7\nF test/fts2a.test 473a5c8b473a4e21a8e3fddaed1e59666e0c6ab7\nF test/fts2b.test 964abc0236c849c07ca1ae496bb25c268ae94816\nF test/fts2c.test ffb5a35230ac72c4354535c547965ce6824537c0\nF test/fts2d.test b7eaa671ca9a16997f3e5b158ee777ae21052b0b\nF test/fts2e.test 2da13dbc2d009105f42196845c1e1ce136c03d38\nF test/fts2f.test cf84096235991709c1e61caa389632aa0a4f976d\nF test/fts2g.test 3d26fe171bda6133ebf5a380731d70eaa2ef2f6f73d79769cf8946e622b6d597\nF test/fts2h.test 223af921323b409d4b5b18ff4e51619541b174bb\nF test/fts2i.test 1b22451d1f13f7c509baec620dc3a4a754885dd6\nF test/fts2j.test 298fa1670aa21cd445b282d139b70c72e7ade12b\nF test/fts2k.test c7ebf4a4937594aa07459e3e1bca1251c1be8659\nF test/fts2l.test 3333336621524cf7d60bb62d6ef6ab69647866ed\nF test/fts2m.test 4b30142ead6f3ed076e880a2a464064c5ad58c51\nF test/fts2n.test 12b9c5352128cebd1c6b8395e43788d4b09087c2\nF test/fts2o.test 4054ac7433eb5440f1b1d200cfa449342dc4aabd991759139813e17c73e5bf9a\nF test/fts2p.test 4b48c35c91e6a7dbf5ac8d1e5691823cc999aafb\nF test/fts2q.test b2fbbe038b7a31a52a6079b215e71226d8c6a682\nF test/fts2r.test b154c30b63061d8725e320fba1a39e2201cadd5e\nF test/fts2token.test d8070b241a15ff13592a9ae4a8b7c171af6f445a\nF test/fts3.test 672a040ea57036fb4b6fdc09027c18d7d24ab654\nF test/fts3_common.tcl dffad248f9ce090800e272017d2898005c28ee6314fc1dd5550643a02666907a\nF test/fts3aa.test 814d60a1ba30b4a71d8f9306a6564bc7b636dd6efacd2ad80306f9b23ef3ebee\nF test/fts3ab.test 7f6cf260ae80dda064023df8e8e503e9a412b91f\nF test/fts3ac.test 636ed7486043055d4f126a0e385f2d5a82ebbf63\nF test/fts3ad.test e40570cb6f74f059129ad48bcef3d7cbc20dda49\nF test/fts3ae.test ce32a13b34b0260928e4213b4481acf801533bda\nF test/fts3af.test d394978c534eabf22dd0837e718b913fd66b499c\nF test/fts3ag.test c003672a215124df7fc6000036d896f498b26b53\nF test/fts3ah.test dc9f66c32c296f1bc8bcc4535126bddfeca62894\nF test/fts3ai.test 24058fdc6e9e5102c1fd8459591b114b6a85d285\nF test/fts3aj.test 0ed71e1dd9b03b843a857dc3eb9b15630e0104fc\nF test/fts3ak.test bd14deafe9d1586e8e9bf032411026ac4f8c925d\nF test/fts3al.test 07d64326e79bbdbab20ee87fc3328fbf01641c9f\nF test/fts3am.test 218aa6ba0dfc50c7c16b2022aac5c6be593d08d8\nF test/fts3an.test a49ccadc07a2f7d646ec1b81bc09da2d85a85b18\nF test/fts3ao.test 266989148fec6d9f1bb6c5382f7aa3dcea0e9cd444576e28dd2b9287ac7dd220\nF test/fts3atoken.test bef8a163490098a6b8a6ec5f5407269a3a15b9902c0fcf5e962825a81675b3a0\nF test/fts3auto.test bfe0857bd0b69d68dd685a931b58486411a69f5794a7f6d6fe808bfa31a99614\nF test/fts3aux1.test 7a170e172afdbceb67f5baa05941fd4fbf56af42f61daa3d140f4b4bf4cb68f6\nF test/fts3aux2.test 2459e7fa3e22734aed237d1e2ae192f5541c4d8b218956ad2d90754977bf907f\nF test/fts3b.test c15c4a9d04e210d0be67e54ce6a87b927168fbf9c1e3faec8c1a732c366fd491\nF test/fts3c.test fc723a9cf10b397fdfc2b32e73c53c8b1ec02958\nF test/fts3comp1.test a0f5b16a2df44dd0b15751787130af2183167c0c\nF test/fts3conf.test c84bbaec81281c1788aa545ac6e78a6bd6cde2bdbbce2da261690e3659f5a76b\nF test/fts3corrupt.test ce7f7b5eaeee5f1804584d061b978d85e64abf2af9adaa7577589fac6f7eae01\nF test/fts3corrupt2.test bf55c3fa0b0dc8ea1c0fe5543623bd27714585da6a129038fd6999fe3b0d25f3\nF test/fts3corrupt3.test 0d5b69a0998b4adf868cc301fc78f3d0707745f1d984ce044c205cdb764b491f\nF test/fts3corrupt4.test 00ecd7605d5b1478252a3b7c2465de2d427906b8cb73b7acb92628bab81f9903\nF test/fts3corrupt5.test 0549f85ec4bd22e992f645f13c59b99d652f2f5e643dac75568bfd23a6db7ed5\nF test/fts3cov.test 7eacdbefd756cfa4dc2241974e3db2834e9b372ca215880e00032222f32194cf\nF test/fts3d.test 2bd8c97bcb9975f2334147173b4872505b6a41359a4f9068960a36afe07a679f\nF test/fts3defer.test f4c20e4c7153d20a98ee49ee5f3faef624fefc9a067f8d8d629db380c4d9f1de\nF test/fts3defer2.test 3da52ca2114e300e9971eee2f0cc1a2e5f27e6a9ee67957d49e63e41fdfcc0e7\nF test/fts3defer3.test dd53fc13223c6d8264a98244e9b19abd35ed71cd\nF test/fts3drop.test 1b906e293d6773812587b3dc458cb9e8f3f0c297\nF test/fts3e.test 1f6c6ac9cc8b772ca256e6b22aaeed50c9350851\nF test/fts3expr.test ebae205a7a89446c32583bcd492dcb817b9f6b31819bb4dde2583bb99c77e526\nF test/fts3expr2.test 18da930352e5693eaa163a3eacf96233b7290d1a\nF test/fts3expr3.test c4d4a7d6327418428c96e0a3a1137c251b8dfbf8\nF test/fts3expr4.test f5b2832549f01b1f7f73389fa21d4b875499bc95bf7c8b36271844888c6a0938\nF test/fts3expr5.test a5b9a053becbdb8e973fbf4d6d3abaabeb42d511d1848bd57931f3e0a1cf983e\nF test/fts3fault.test 798e45af84be7978ca33d5bdc94246eb44724db24174b5d8e9b1ac46c57fb08d\nF test/fts3fault2.test 6a17a11d8034b1c4eca9f3091649273d56c49ff049e2173df8060f94341e9da0\nF test/fts3first.test dbdedd20914c8d539aa3206c9b34a23775644641\nF test/fts3fuzz001.test e3c7b0ce9b04cc02281dcc96812a277f02df03cd7dc082055d87e11eb18aaf56\nF test/fts3join.test 949b4f5ae3ae9cc2423cb865d711e32476bdb205ab2be923fdf48246e4a44166\nF test/fts3malloc.test b0e4c133b8d61d4f6d112d8110f8320e9e453ef6\nF test/fts3matchinfo.test aa66cc50615578b30f6df9984819ae5b702511cf8a94251ec7c594096a703a4a\nF test/fts3misc.test c47d2c1ea1351c51c32c688545b02c8180a3f22156d1aedc206a8c09b9d95905\nF test/fts3near.test 7e3354d46f155a822b59c0e957fd2a70c1d7e905\nF test/fts3offsets.test b85fd382abdc78ebce721d8117bd552dfb75094c\nF test/fts3prefix.test fa794eaab0bdae466494947b0b153d7844478ab2\nF test/fts3prefix2.test e1f0a822ca661dced7f12ce392e14eaf65609dce\nF test/fts3query.test ca033ff2ebcc22c69d89032fb0bc1850997d31e7e60ecd26440796ba1654e78f\nF test/fts3rank.test cd99bc83a3c923c8d52afd90d86979cf05fc41849f892faeac3988055ef37b99\nF test/fts3rnd.test 1320d8826a845e38a96e769562bf83d7a92a15d0\nF test/fts3shared.test 57e26a801f21027b7530da77db54286a6fe4997e\nF test/fts3snippet.test 430bb5ace2b31ccd99de4d71775d956da832c114c4b3e39589748f114458647c\nF test/fts3sort.test ed34c716a11cc2009a35210e84ad5f9c102362ca\nF test/fts3tok1.test a663f4cac22a9505400bc22aacb818d7055240409c28729669ea7d4cc2120d15\nF test/fts3tok_err.test 52273cd193b9036282f7bacb43da78c6be87418d\nF test/fts3varint.test 0b84a3fd4eba8a39f3687523804d18f3b322e6d4539a55bf342079c3614f2ada\nF test/fts4aa.test 4338ea7a67f7e19269bf6e6fb4a291352aa32296e7daed87f9823d57016a1ef7\nF test/fts4check.test 6259f856604445d7b684c9b306b2efb6346834c3f50e8fc4a59a2ca6d5319ad0\nF test/fts4content.test 73bbb123420d2c46ef2fb3b24761e9acdb78b0877179d3a5d7d57aada08066f6\nF test/fts4docid.test e33c383cfbdff0284685604d256f347a18fdbf01\nF test/fts4growth.test 289833c34ad45a5e6e6133b53b6a71647231fb89d36ddcb8d9c87211b6721d7f\nF test/fts4growth2.test 13ad4e76451af6e6906c95cdc725d01b00044269\nF test/fts4incr.test 4e353a0bd886ea984e56fce9e77724fc923b8d0d\nF test/fts4langid.test 2168ba330af34f8a1c8832de0aab4c4b6fa195a16419c9c0c8aad59ceb6ff714\nF test/fts4lastrowid.test 185835895948d5325c7710649824042373b2203149abe8024a9319d25234dfd7\nF test/fts4merge.test e2b2ec21e287d54ec09824ccfb41e66896eeca568fc818ba0e0eb2efd94c35d2\nF test/fts4merge2.test 5faa558d1b672f82b847d2a337465fa745e46891\nF test/fts4merge3.test 8d9ccb4a3d41c4c617a149d6c4b13ad02de797d0\nF test/fts4merge4.test d895b1057a7798b67e03455d0fa50e9ea836c47b\nF test/fts4merge5.test 69932d85cda8a1c4dcfb742865900ed8fbda51724b8cf9a45bbe226dfd06c596\nF test/fts4noti.test 5553d7bb2e20bf4a06b23e849352efc022ce6309\nF test/fts4onepass.test d69ddc4ee3415e40b0c5d1d0408488a87614d4f63ba9c44f3e52db541d6b7cc7\nF test/fts4opt.test 0fd0cc84000743ff2a883b9b84b4a5be07249f0ba790c8848a757164cdd46b2a\nF test/fts4record.test a48508f69a84c9287c8019d3a1ae712f5730d8335ffaf8e2101e691d078950bb\nF test/fts4rename.test 15fd9985c2bce6dea20da2245b22029ec89bd4710ed317c4c53abbe3cfd0c880\nF test/fts4umlaut.test fcaca4471de7e78c9d1f7e8976e3e8704d7d8ad979d57a739d00f3f757380429\nF test/fts4unicode.test ceca76422abc251818cb25dabe33d3c3970da5f7c90e1540f190824e6b3a7c95\nF test/full.test 6b3c8fb43c6beab6b95438c1675374b95fab245d\nF test/func.test 7d425f9a6eaa2c50baa751bef6b0c6c6af1751e0e0e1eb4863d426bb4c886788\nF test/func2.test 772d66227e4e6684b86053302e2d74a2500e1e0f\nF test/func3.test 2bb0f31ab7baaed690b962a88544d7be6b34fa389364bc36a44e441ed3e3f1e6\nF test/func4.test 6beacdfcb0e18c358e6c2dcacf1b65d1fa80955f\nF test/func5.test cdd224400bc3e48d891827cc913a57051a426fa4\nF test/func6.test 90e42b64c4f9fb6f04f44cb8a1da586c8542502e926b19c76504fe74ff2a9b7c\nF test/fuzz-oss1.test e58330d01cbbd8215ee636b17a03fe220b37dbfa\nF test/fuzz.test 96083052bf5765e4518c1ba686ce2bab785670d1\nF test/fuzz2.test 76dc35b32b6d6f965259508508abce75a6c4d7e1\nF test/fuzz3.test 9c813e6613b837cb7a277b0383cd66bfa07042b4cf0317157c35852f30043c31\nF test/fuzz4.test c229bcdb45518a89e1d208a21343e061503460ac69fae1539320a89f572eb634\nF test/fuzz_common.tcl a87dfbb88c2a6b08a38e9a070dabd129e617b45b\nF test/fuzz_malloc.test f348276e732e814802e39f042b1f6da6362a610af73a528d8f76898fde6b22f2\nF test/fuzzcheck.c 0df68e0df3b93a8c8fc24c9873127c7d78024b51444193545f985dbc90ac024e\nF test/fuzzdata1.db d36e88741b4f23bcbaaf55b006290669d03c6c891cf13c7b3a53bc1b097b693f\nF test/fuzzdata2.db 128b3feeb78918d075c9b14b48610145a0dd4c8d6f1ca7c2870c7e425f5bf31f\nF test/fuzzdata3.db c6586d3e3cef0fbc18108f9bb649aa77bfc38aba\nF test/fuzzdata4.db b502c7d5498261715812dd8b3c2005bad08b3a26e6489414bd13926cd3e42ed2\nF test/fuzzdata5.db e35f64af17ec48926481cfaf3b3855e436bd40d1cfe2d59a9474cb4b748a52a5\nF test/fuzzdata6.db 92a80e4afc172c24f662a10a612d188fb272de4a9bd19e017927c95f737de6d7\nF test/fuzzdata7.db e7a86fd83dda151d160445d542e32e5c6019c541b3a74c2a525b6ac640639711\nF test/fuzzdata8.db b45368bbe9f86d40d30603e8f780ac29807cbcc951a18d7a7fd9d0c0e904706e\nF test/fuzzer1.test 3d4c4b7e547aba5e5511a2991e3e3d07166cfbb8\nF test/fuzzer2.test a85ef814ce071293bce1ad8dffa217cbbaad4c14\nF test/fuzzerfault.test 8792cd77fd5bce765b05d0c8e01b9edcf8af8536\nF test/gcfault.test dd28c228a38976d6336a3fc42d7e5f1ad060cb8c\nF test/gencol1.test 69008f45faa46b7293cc6ce1236f356a7aff6061b0547334786b54a49b2f98cb\nF test/genesis.tcl 1e2e2e8e5cc4058549a154ff1892fe5c9de19f98\nF test/having.test e4098a4b8962f9596035c3b87a8928a10648acc509f1bb8d6f96413bbf79a1b3\nF test/hexlit.test 4a6a5f46e3c65c4bf1fa06f5dd5a9507a5627751\nF test/hidden.test 23c1393a79e846d68fd902d72c85d5e5dcf98711\nF test/hook.test 1604b3b2f5931430087540404555c1b6be3618600b81558657c66b533ed70b13\nF test/hook2.test b9ff3b8c6519fb67f33192f1afe86e7782ee4ac8\nF test/icu.test 41aa8847745a879b897a7febea0f8f9efc8e67fe8bf680589b6e07c7b0a1569a\nF test/ieee754.test 806fc0ce7f305f57e3331eaceeddcfec9339e607\nF test/imposter1.test c3f1db2d3db2c24611a6596a3fc0ffc14f1466c8\nF test/in.test 3e9bd58597a444123a40a9ac94cae0fec8897e17e9f519b02fc370bcf5ba5175\nF test/in2.test 5d4c61d17493c832f7d2d32bef785119e87bde75\nF test/in3.test 3cbf58c87f4052cee3a58b37b6389777505aa0c0\nF test/in4.test 0f77b0ff371549e6a119d0356be10bdba72258162e9701e83527a560482f5e98\nF test/in5.test b32ce7f4a93f44c5dee94af16886d922cc16ebe33c8e1765c73d4049d0f4b40f\nF test/in6.test 62d943a02f722948f4410ee0b53c3cb39acd7c41afb083df8d7004238fe90a20\nF test/incrblob.test c9b96afc292aeff43d6687bcb09b0280aa599822\nF test/incrblob2.test a494c9e848560039a23974b9119cfc2cf3ad3bd15cc2694ee6367ae537ef8f1f\nF test/incrblob3.test d8d036fde015d4a159cd3cbae9d29003b37227a4\nF test/incrblob4.test 21a52a6843a56cdcce968c6a86b72a7066d0e6ba\nF test/incrblob_err.test 89372a28f1d98254f03fed705f9efcd34ef61a674df16d2dbb4726944a2de5e9\nF test/incrblobfault.test 74dd8ac108304cea0b4a0df6df63a1567e558758\nF test/incrcorrupt.test 6c567fbf870aa9e91866fe52ce6f200cd548939a\nF test/incrvacuum.test 2aaee202b1f230e55779f70d155f6ba67bbdff8481d650214d256ab0f97d4a2b\nF test/incrvacuum2.test 7d26cfda66c7e55898d196de54ac4ec7d86a4e3d\nF test/incrvacuum3.test 75256fb1377e7c39ef2de62bfc42bbff67be295a\nF test/incrvacuum_ioerr.test 6ae2f783424e47a0033304808fe27789cf93e635\nF test/index.test a2e948ed949e575487b5c1d521767d4584ac42d352f2dcd8e48004638e7bc7dc\nF test/index2.test f835d5e13ca163bd78c4459ca15fd2e4ed487407\nF test/index3.test 51685f39345462b84fcf77eb8537af847fdf438cc96b05c45d6aaca4e473ade0\nF test/index4.test ab92e736d5946840236cd61ac3191f91a7856bf6\nF test/index5.test 8621491915800ec274609e42e02a97d67e9b13e7\nF test/index6.test f172653b35b20233e59200e8b92a76db61bf7285437bf777b93b306ba26a47e7\nF test/index7.test 1d764c0cca45f5a76150b08e127ccc8d52492cfa788b5fafed4be784a351b020\nF test/index8.test bc2e3db70e8e62459aaa1bd7e4a9b39664f8f9d7\nF test/index9.test 0aa3e509dddf81f93380396e40e9bb386904c1054924ba8fa9bcdfe85a8e7721\nF test/indexedby.test a52c8c6abfae4fbfb51d99440de4ca1840dbacc606b05e29328a2a8ba7cd914e\nF test/indexexpr1.test 284e119999d132cc8bf37735a928c9859b28e8e295d02b7a6a4f93977c7f9ba5\nF test/indexexpr2.test dba11dbb0a58fcba4cd694f46b4004976123b81b0501f525d43c9be59f0207b1\nF test/indexfault.test 98d78a8ff1f5335628b62f886a1cb7c7dac1ef6d48fa39c51ec871c87dce9811\nF test/init.test 15c823093fdabbf7b531fe22cf037134d09587a7\nF test/insert.test 4e3f0de67aac3c5be1f4aaedbcea11638f1b5cdc9a3115be14d19aa9db7623c6\nF test/insert2.test 4d14b8f1b810a41995f6286b64a6943215d52208\nF test/insert3.test 1b7db95a03ad9c5013fdf7d6722b6cd66ee55e30\nF test/insert4.test fb9e0f752c75f453555990250b449f6d123ae6a3ebf054d14e4470de4498dce3\nF test/insert5.test 394f96728d1258f406fe5f5aeb0aaf29487c39a6\nF test/insertfault.test ac63d14ea3b49c573673a572f4014b9117383a03e497c58f308b5c776e4a7f74\nF test/instr.test 107df2b9b74a4b59315916b575590a08f2a714de0754abe541f10a0971d0a2a4\nF test/instrfault.test 0f870b218ea17cd477bb19ed330eecdb460dd53a\nF test/intarray.test bb976b0b3df0ebb6a2eddfb61768280440e672beba5460ed49679ea984ccf440\nF test/interrupt.test 16ea879ec728cb76414c148c5f24afd5d1f91054\nF test/interrupt2.test e4408ca770a6feafbadb0801e54a0dcd1a8d108d\nF test/intpkey.test ac71107a49a06492b69b82aafaf225400598d3c8\nF test/intreal.test 2a87e85a5949bd55e41ef04c58f5800587c5380bdbc559ff1c79b614b0e6a533\nF test/io.test f95bca1783b01ea7761671560d023360d2dfa4cc\nF test/ioerr.test 470fcc78e9cd352d162baf782fe301ea807d764241f58a48fc58109c2dfcdb6b\nF test/ioerr2.test 2593563599e2cc6b6b4fcf5878b177bdd5d8df26\nF test/ioerr3.test d3cec5e1a11ad6d27527d0d38573fbff14c71bdd\nF test/ioerr4.test f130fe9e71008577b342b8874d52984bd04ede2c\nF test/ioerr5.test 2edfa4fb0f896f733071303b42224df8bedd9da4\nF test/ioerr6.test a395a6ab144b26a9e3e21059a1ab6a7149cca65b\nF test/istrue.test 75327829744e65cc8700e69340b8e6c192e10e39dfae7ccb0e970d3c4f49090a\nF test/join.test 99e1d82fada7a1df9002a7b1160bd231c91077b9372492d5e18bfa1d1694d43c\nF test/join2.test 10f7047e723ebd68b2f47189be8eed20451a6f665d8bf46f1774c640d1062417\nF test/join3.test 6f0c774ff1ba0489e6c88a3e77b9d3528fb4fda0\nF test/join4.test 1a352e4e267114444c29266ce79e941af5885916\nF test/join5.test 3a96dc62f0b45402d7207e22d1993fe0c2fce1c57644a11439891dd62b990eb7\nF test/join6.test cfe6503791ceb0cbb509966740286ec423cbf10b\nF test/journal1.test c7b768041b7f494471531e17abc2f4f5ebf9e5096984f43ed17c4eb80ba34497\nF test/journal2.test 9dac6b4ba0ca79c3b21446bbae993a462c2397c4\nF test/journal3.test 7c3cf23ffc77db06601c1fcfc9743de8441cb77db9d1aa931863d94f5ffa140e\nF test/jrnlmode.test 9b5bc01dac22223cb60ec2d5f97acf568d73820794386de5634dcadbea9e1946\nF test/jrnlmode2.test 8759a1d4657c064637f8b079592651530db738419e1d649c6df7048cd724363d\nF test/jrnlmode3.test 556b447a05be0e0963f4311e95ab1632b11c9eaa\nF test/json101.test bb71538005f2d9e18620bdd3b76839a93ca0be61903eb8d751a64e78cf99b8fb\nF test/json102.test eeb54efa221e50b74a2d6fb9259963b48d7414dca3ce2fdfdeed45cb28487bc1\nF test/json103.test aff6b7a4c17d5a20b487a7bc1a274bfdc63b829413bdfb83bedac42ec7f67e3b\nF test/json104.test 317f4ec4b2d87afbba4d2460cf5be297aea76f2285eb618d276dbcd40a50950f\nF test/json105.test 45f7d6a9a54c85f8a9589b68d3e7a1f42d02f2359911a8cdbad1f9988f571173\nF test/keyword1.test 37ef6bba5d2ed5b07ecdd6810571de2956599dff\nF test/kvtest.c 94da54bb66aae7a54e47cf7e4ea4acecc0f217560f79ad3abfcc0361d6d557ba\nF test/lastinsert.test 42e948fd6442f07d60acbd15d33fb86473e0ef63\nF test/laststmtchanges.test ae613f53819206b3222771828d024154d51db200\nF test/lemon-test01.y 58b764610fd934e189ffbb0bbfa33d171b9cb06019b55bdc04d090d6767e11d7\nF test/like.test 3d702d79bf871fa32985b1ce334294c587e3948d3ab972001e811a58577e8b3c\nF test/like2.test 3b2ee13149ba4a8a60b59756f4e5d345573852da\nF test/like3.test 4f940ad275c006319950054a7a65661f476772171b82b6fdf795e4dda36f246f\nF test/limit.test 0c99a27a87b14c646a9d583c7c89fd06c352663e\nF test/limit2.test 9409b033284642a859fafc95f29a5a6a557bd57c1f0d7c3f554bd64ed69df77e\nF test/loadext.test faa4f6eed07a5aac35d57fdd7bc07f8fc82464cfd327567c10cf0ba3c86cde04\nF test/loadext2.test 0408380b57adca04004247179837a18e866a74f7\nF test/lock.test be4fe08118fb988fed741f429b7dd5d65e1c90db\nF test/lock2.test 5242d8ac4e2d59c403aebff606af449b455aceff\nF test/lock3.test f271375930711ae044080f4fe6d6eda930870d00\nF test/lock4.test 27143363eda1622f03c133efc8db808fc331afd973486cb571ea71cd717d37b8\nF test/lock5.test c6c5e0ebcb21c61a572870cc86c0cb9f14cede38\nF test/lock6.test ad5b387a3a8096afd3c68a55b9535056431b0cf5\nF test/lock7.test 49f1eaff1cdc491cc5dee3669f3c671d9f172431\nF test/lock_common.tcl 2f3f7f2e9637f93ccf609df48ef5b27a50278b6b1cd752b445d52262e5841413\nF test/lookaside.test 5a828e7256f1ee4da8e1bdaa03373a3ccdb0f1ff98dfa82e9b76cb41a45b1083\nF test/main.test 6bbb3999fd461eb8fb335cbab97409a3d7f91bbb8da60635e8be3e4a04a77772\nF test/make-where7.tcl 05c16b5d4f5d6512881dfec560cb793915932ef9\nF test/malloc.test 18dd1c4188c81ca79cf123527c71b19ee0c31feb9947fdffb0dc6ceb1436816a\nF test/malloc3.test 6e88bae6312854a4adb4ecc2a6a5ea8c59b4db778b724ba718e1c43fc8c3c136\nF test/malloc4.test 957337613002b7058a85116493a262f679f3a261\nF test/malloc5.test 2e4ad7684a13389a44a840499cd47173a8d05f22f082d7d083eece433a7a64eb\nF test/malloc6.test 2f039d9821927eacae43e1831f815e157659a151\nF test/malloc7.test 7c68a32942858bc715284856c5507446bba88c3a\nF test/malloc8.test 9b7a3f8cb9cf0b12fff566e80a980b1767bd961d\nF test/malloc9.test 2307c6ee3703b0a21391f3ea92388b4b73f9105e\nF test/mallocA.test aea76f2dd8bcc2d19748f6b911e876cefda74a563753bf26af046e9d34bb97e6\nF test/mallocAll.test 98f1be74bc9f49a858bc4f361fc58e26486798be\nF test/mallocB.test bc475ab850cda896142ab935bbfbc74c24e51ed6\nF test/mallocC.test 3dffe16532f109293ce1ccecd0c31dca55ef08c4\nF test/mallocD.test f78c295e8e18ea3029e65ca08278690e00c22100\nF test/mallocE.test db1ed69d7eded1b080952e2a7c37f364ad241b08\nF test/mallocF.test 2d5c590ebc2fc7f0dcebdf5aa8498b9aed69107e\nF test/mallocG.test 0ff91b65c50bdaba680fb75d87fe4ad35bb7934f\nF test/mallocH.test 79b65aed612c9b3ed2dcdaa727c85895fd1bfbdb\nF test/mallocI.test 6c23a71df077fa5d387be90e7e669c5b368ca38a\nF test/mallocJ.test b5d1839da331d96223e5f458856f8ffe1366f62e\nF test/mallocK.test 1f4b5efbf61715ab79b20b38739ff4b3d110ceb53f54e5db6da1f01c083707ab\nF test/mallocL.test fb311ff80afddf3b1a75e52289081f4754d901dc\nF test/mallocM.test 78bbe9d3da84a5c679123cdb40d7b2010b18fc46e13897e4f253c6ba6fbff134\nF test/malloc_common.tcl aac62499b76be719fac31e7a3e54a7fd53272e7f\nF test/malloctraceviewer.tcl b7a54595270c1d201abf1c3f3d461f27eaf24cdef623ad08a0fe5e411264c8a9\nF test/manydb.test 28385ae2087967aa05c38624cec7d96ec74feb3e\nF test/mem5.test c6460fba403c5703141348cd90de1c294188c68f\nF test/memdb.test c1f2a343ad14398d5d6debda6ea33e80d0dafcc7\nF test/memdb1.test 58d92c2bf622cc5f0f41461e1b35cf64f3f787199544c2c1dada37d88753f9d4\nF test/memleak.test 10b9c6c57e19fc68c32941495e9ba1c50123f6e2\nF test/memsubsys1.test 9e7555a22173b8f1c96c281ce289b338fcba2abe8b157f8798ca195bbf1d347e\nF test/memsubsys2.test 3e4a8d0c05fd3e5fa92017c64666730a520c7e08\nF test/minmax.test 6751e87b409fe11b02e70a306d846fa544e25a41\nF test/minmax2.test 1edf66901ddfab26ae1e04165e8da834c8d3284e2b20aefb26b80ef217962eab\nF test/minmax3.test cc1e8b010136db0d01a6f2a29ba5a9f321034354\nF test/minmax4.test 272ca395257f05937dc96441c9dde4bc9fbf116a8d4fa02baeb0d13d50e36c87\nF test/misc1.test 7ce84b25df9872e7d7878613a96815d2ba5bc974ac4e15a50118dde8f3917599\nF test/misc2.test 00d7de54eda90e237fc9a38b9e5ccc769ebf6d4d\nF test/misc3.test cf3dda47d5dda3e53fc5804a100d3c82be736c9d\nF test/misc4.test 10cd6addb2fa9093df4751a1b92b50440175dd5468a6ec84d0386e78f087db0e\nF test/misc5.test c4aeaa0fa28faa08f2485309c38db4719e6cd1364215d5687a5b96d340a3fa58\nF test/misc6.test 953cc693924d88e6117aeba16f46f0bf5abede91\nF test/misc7.test 4f21954012e4eb0a923c54a311f38c81bf6798ccdd7b51584db46d4007f63daa\nF test/misc8.test 8fb0f31d7a8aed484d759773ab8ad12ec746a477f4a67394a4af0e677494c3ca\nF test/misuse.test 9e7f78402005e833af71dcab32d048003869eca5abcaccc985d4f8dc1d86bcc7\nF test/mjournal.test 28a08d5cb5fb5b5702a46e19176e45e964e0800d1f894677169e79f34030e152\nF test/mmap1.test fb04e0c10492455007624ade884ca0c8852ff3e4e11d95408f9709ca2ef7f626\nF test/mmap2.test 9d6dd9ddb4ad2379f29cc78f38ce1e63ed418022\nF test/mmap3.test b3c297e78e6a8520aafcc1a8f140535594c9086e\nF test/mmap4.test 2e2b4e32555b58da15176e6fe750f17c9dcf7f93\nF test/mmapfault.test d4c9eff9cd8c2dc14bc43e71e042f175b0a26fe3\nF test/mmapwarm.test 2272005969cd17a910077bd5082f70bc1fefad9a875afec7fc9af483898ecaf3\nF test/multiplex.test dc0d67b66f84b484a83cb8bbdf3f0a7f49562ccd\nF test/multiplex2.test 580ca5817c7edbe4cc68fa150609c9473393003a\nF test/multiplex3.test d228f59eac91839a977eac19f21d053f03e4d101\nF test/multiplex4.test e8ae4c4bd70606a5727743241f13b5701990abe4\nF test/mutex1.test ea2cc74d97f077b9e74c84cbd024f14d79a8126f\nF test/mutex2.test bfeaeac2e73095b2ac32285d2756e3a65e681660\nF test/nan.test 437d40e6d0778b050d7750726c0cbd2c9936b81962926e8f8c48ca698f00f4d1\nF test/nockpt.test 8c43b25af63b0bd620cf1b003529e37b6f1dc53bd22690e96a1bd73f78dde53a\nF test/nolock.test f196cf8b8fbea4e2ca345140a2b3f3b0da45c76e\nF test/normalize.test f23b6c5926c59548635fcf39678ac613e726121e073dd902a3062fbb83903b72\nF test/notify1.test 669b2b743618efdc18ca4b02f45423d5d2304abf\nF test/notify2.test 2ecabaa1305083856b7c39cf32816b612740c161\nF test/notify3.test 10ff25cde502e72a92053a2f215d64bece4ef934\nF test/notnull.test a37b663d5bb728d66fc182016613fb8e4a0a4bbf3d75b8876a7527f7d4ed3f18\nF test/null.test 0dcce4f04284ec66108c503327ad6d224c0752b3\nF test/nulls1.test c8fc1b223f06e60007e0cd3e498ccb10195cf75a18fc3312508b3cf679ecb806\nF test/numcast.test 5d126f7f581432e86a90d1e35cac625164aec4a1\nF test/numindex1.test 20a5450d4b056e48cd5db30e659f13347a099823\nF test/offset1.test f06b83657bcf26f9ce805e67450e189e282143b2\nF test/openv2.test 0d3040974bf402e19b7df4b783e447289d7ab394\nF test/optfuzz-db01.c a0c256905c8ac79f9a5de2f374a3d9f757bef0dca2a238dc7c10cc8a38031834\nF test/optfuzz-db01.txt 21f6bdeadc701cf11528276e2a55c70bfcb846ba42df327f979bd9e7b6ce7041\nF test/optfuzz.c 50e330304eb1992e15ddd11f3daaad9bcc0d9aaad09cb2bcc77f9515df2e88b1\nF test/orderby1.test e4501f54721f804ca56922e253403ac6775f88e9f07569994ce99212b3ca5b10\nF test/orderby2.test bc11009f7cd99d96b1b11e57b199b00633eb5b04\nF test/orderby3.test 8619d06a3debdcd80a27c0fdea5c40b468854b99\nF test/orderby4.test 4d39bfbaaa3ae64d026ca2ff166353d2edca4ba4\nF test/orderby5.test 5f4d6cb93cc2f6d3f4228354310a2ce1fbd95d5bbffcba8c6482eeb62a466407\nF test/orderby6.test 8b38138ab0972588240b3fca0985d2e400432859\nF test/orderby7.test 3d1383d52ade5b9eb3a173b3147fdd296f0202da\nF test/orderby8.test 23ef1a5d72bd3adcc2f65561c654295d1b8047bd\nF test/orderby9.test 87fb9548debcc2cd141c5299002dd94672fa76a3\nF test/orderbyA.test df608e59efc2ef50c1eddf1a773b272de3252e9401bfec86d04b52fd973866d5\nF test/oserror.test 1fc9746b83d778e70d115049747ba19c7fba154afce7cc165b09feb6ca6abbc5\nF test/ossfuzz.c 9636dad2092a05a32110df0ca06713038dd0c43dd89a77dabe4b8b0d71096715\nF test/ossshell.c f125c5bd16e537a2549aa579b328dd1c59905e7ab1338dfc210e755bb7b69f17\nF test/ovfl.test 199c482696defceacee8c8e0e0ef36da62726b2f\nF test/pager1.test 1e9ee778bdeaf4f7f09997d029cdaca6a42dfc2092edafe4f5e590acbf1eab13\nF test/pager2.test 67b8f40ae98112bcdba1f2b2d03ea83266418c71\nF test/pager3.test 4e9a83d6ca0838d7c602c9eb93d1357562d9059c1e02ffb138a8271020838370\nF test/pager4.test a122e9e6925d5b23b31e3dfef8c6a44bbf19590e\nF test/pagerfault.test 63c5da625562c66345ab4528790327ca63db2f6f9cbae2aba8cb7c51de3d1628\nF test/pagerfault2.test caf4c7facb914fd3b03a17b31ae2b180c8d6ca1f\nF test/pagerfault3.test 1003fcda009bf48a8e22a516e193b6ef0dd1bbd8\nF test/pageropt.test 84e4cc5cbca285357f7906e99b21be4f2bf5abc0\nF test/pagesize.test 5769fc62d8c890a83a503f67d47508dfdc543305\nF test/parser1.test 6ccdf5e459a5dc4673d3273dc311a7e9742ca952dd0551a6a6320d27035ce4b3\nF test/pcache.test c8acbedd3b6fd0f9a7ca887a83b11d24a007972b\nF test/pcache2.test af7f3deb1a819f77a6d0d81534e97d1cf62cd442\nF test/percentile.test 4243af26b8f3f4555abe166f723715a1f74c77ff\nF test/permutations.test 8587800fe1a0eb01456a3f4500b821e54e3347e78acf11dbf05f4990530f6cee\nF test/pg_common.tcl 222a1bad1c41c308fa366313cd7b51b3be7e9b21c8736a421b974ac941693b54\nF test/pragma.test 59becdfd720b80d463ab750f69f7118fde10dfd556aa5d554f3bf6b7e5ea7533\nF test/pragma2.test e5d5c176360c321344249354c0c16aec46214c9f\nF test/pragma3.test 8300aa9c63cff1027006ca34bf413a148abbd6dcd471fa9a1ded322fe18c0df9\nF test/pragma4.test 10c624e45a83c0096a82a7579a5ff658542391d3b77355192da6572c8c17c00b\nF test/pragma5.test 2be6a44c91e8585ccb4c71c5f221ccebe0692a49557215a912916ed391188959\nF test/pragmafault.test 275edaf3161771d37de60e5c2b412627ac94cef11739236bec12ed1258b240f8\nF test/prefixes.test b524a1c44bffec225b9aec98bd728480352aa8532ac4c15771fb85e8beef65d9\nF test/printf.test 0300699733e53101b2ce48800518427249edd4053bb50fa0621c6607482f0fdb\nF test/printf2.test 30b5dd0b4b992dc5626496846ecce17ff592cacbcb11c3e589f3ac4d7e129dae\nF test/progress.test ebab27f670bd0d4eb9d20d49cef96e68141d92fb\nF test/ptrchng.test ef1aa72d6cf35a2bbd0869a649b744e9d84977fc\nF test/pushdown.test 5e72c51c5e33253ed639ccee1e01ce62d62b6eee5ca893cd82334e4ee7b1d7fc\nF test/queryonly.test 5f653159e0f552f0552d43259890c1089391dcca\nF test/quick.test 1681febc928d686362d50057c642f77a02c62e57\nF test/quota-glob.test 32901e9eed6705d68ca3faee2a06b73b57cb3c26\nF test/quota.test bfb269ce81ea52f593f9648316cd5013d766dd2a\nF test/quota2.test 7dc12e08b11cbc4c16c9ba2aa2e040ea8d8ab4b8\nF test/quote.test 626149eda89ee64d81a3790de370f9f0211921b11568a49c28c861f394330508\nF test/randexpr1.tcl 40dec52119ed3a2b8b2a773bce24b63a3a746459\nF test/randexpr1.test eda062a97e60f9c38ae8d806b03b0ddf23d796df\nF test/rbu.test 168573d353cd0fd10196b87b0caa322c144ef736\nF test/rdonly.test 64e2696c322e3538df0b1ed624e21f9a23ed9ff8\nF test/recover.test ccb8c2623902a92ebb76770edd075cb4f75a4760bb7afde38026572c6e79070d\nF test/regexp1.test 497ea812f264d12b6198d6e50a76be4a1973a9d8\nF test/regexp2.test 40e894223b3d6672655481493f1be12012f2b33c\nF test/reindex.test cd9d6021729910ece82267b4f5e1b5ac2911a7566c43b43c176a6a4732e2118d\nF test/releasetest.tcl fb76d8fcc95ac29d6356cd9e52b726ab9e43a24082897618dfbcb7c2b0049153 x\nF test/releasetest_data.tcl 9919fc6ac5bc92f8878fecfd1840db15999f660a6c9f609240b41aa62b885c88\nF test/resetdb.test 8062cf10a09d8c048f8de7711e94571c38b38168db0e5877ba7561789e5eeb2b\nF test/resolver01.test f4022acafda7f4d40eca94dbf16bc5fc4ac30ceb\nF test/rollback.test 06680159bc6746d0f26276e339e3ae2f951c64812468308838e0a3362d911eaa\nF test/rollback2.test bc868d57899dc6972e2b4483faae0e03365a0556941474eec487ae21d8d38bb6\nF test/rollbackfault.test 0e646aeab8840c399cfbfa43daab46fd609cf04a\nF test/round1.test 768018b04522ca420b1aba8a24bd76091d269f3bce3902af3ec6ebcee41ab21e\nF test/rowallock.test 3f88ec6819489d0b2341c7a7528ae17c053ab7cc\nF test/rowhash.test 0bc1d31415e4575d10cacf31e1a66b5cc0f8be81\nF test/rowid.test bfbd7b97d9267660be3c8f28507c4ed7f205196b8877c0db42df347c2e8845e3\nF test/rowvalue.test c39cc0be5e33f5294fc9224216198d6709d713ea948fdf8f42d89568e97912c9\nF test/rowvalue2.test 060d238b7e5639a7c5630cb5e63e311b44efef2b\nF test/rowvalue3.test 3068f508753af69884b12125995f023da0dbb256\nF test/rowvalue4.test 02e35f7762371c2f57ebd856aa056eac56cb27ef7715a0bb31eac1895a745356\nF test/rowvalue5.test c81c7d8cf36711ab37675ad7376084ae2a359cb6\nF test/rowvalue6.test d19b54feb604d5601f8614b15e214e0774c01087\nF test/rowvalue7.test c1cbdbf407029db01f87764097c6ac02a1c5a37efd2776eff32a9cdfdf6f2dba\nF test/rowvalue8.test 5900eddad9e2c3c2e26f1a95f74aafc1232ee5e0\nF test/rowvalue9.test d8dd2c6ecac432dadaa79e41dc2434f007be1b6b\nF test/rowvaluefault.test 7cd9ccc6c2fbdd881672984087aad0491bb75504\nF test/rowvaluevtab.test d166df5b666662de1ebf40d6f3849f8a76b34e17183a6cc7f81b420c462ce447\nF test/rtree.test 0c8d9dd458d6824e59683c19ab2ffa9ef946f798\nF test/run-wordcount.sh 891e89c4c2d16e629cd45951d4ed899ad12afc09\nF test/savepoint.test 1f8a6b1aea9a0d05837adc463d4bf47bd9d0f1c842f1c2a9caccd639baf34bf9\nF test/savepoint2.test 9b8543940572a2f01a18298c3135ad0c9f4f67d7\nF test/savepoint4.test c8f8159ade6d2acd9128be61e1230f1c1edc6cc0\nF test/savepoint5.test 0735db177e0ebbaedc39812c8d065075d563c4fd\nF test/savepoint6.test f41279c5e137139fa5c21485773332c7adb98cd7\nF test/savepoint7.test cde525ea3075283eb950cdcdefe23ead4f700daa\nF test/savepointfault.test f044eac64b59f09746c7020ee261734de82bf9b2\nF test/scanstatus.test 874e35011779b07725a47dbf1dd6282b0ca04af7e028fb0b534ee544b571be42\nF test/schema.test 5dd11c96ba64744de955315d2e4f8992e447533690153b93377dffb2a5ef5431\nF test/schema2.test 906408621ea881fdb496d878b1822572a34e32c5\nF test/schema3.test 1bc1008e1f8cb5654b248c55f27249366eb7ed38\nF test/schema4.test 3b26c9fa916abb6dadf894137adcf41b7796f7b9\nF test/schema5.test 29699b4421f183c8f0e88bd28ce7d75d13ea653e\nF test/schema6.test e4bd1f23d368695eb9e7b51ef6e02ca0642ea2ab4a52579959826b5e7dce1f9b\nF test/schemafault.test 1936bceca55ac82c5efbcc9fc91a1933e45c8d1e1d106b9a7e56c972a5a2a51e\nF test/securedel.test 2f70b2449186a1921bd01ec9da407fbfa98c3a7a5521854c300c194b2ff09384\nF test/securedel2.test 2d54c28e46eb1fd6902089958b20b1b056c6f1c5\nF test/select1.test b887331202618dbdabed92446b661ebd95a55ef3923700af56ed71266e9c1157\nF test/select2.test 352480e0e9c66eda9c3044e412abdf5be0215b56\nF test/select3.test 3905450067c28766bc83ee397f6d87342de868baa60f2bcfd00f286dfbd62cb9\nF test/select4.test 5389d9895968d1196c457d59b3ee6515d771d328\nF test/select5.test df9ec0d218cedceb4fe7b63262025b547b50a55e59148c6f40b60ca25f1d4546\nF test/select6.test 319d45e414cdd321bf17cfacedaf19e3935ad64dac357c53f1492338c6e9b801\nF test/select7.test f659f231489349e8c5734e610803d7654207318f\nF test/select8.test 8c8f5ae43894c891efc5755ed905467d1d67ad5d\nF test/select9.test aebc2bb0c3bc44606125033cbcaac2c8d1f33a95\nF test/selectA.test b8a590f6493cad5b0bb4dfe1709bf7dcda0b6c40bb4caf32d1e36a89eebc8fc5\nF test/selectB.test 954e4e49cf1f896d61794e440669e03a27ceea25\nF test/selectC.test e25243f8ca503e06f252eb0218976d07cfeceac3\nF test/selectD.test fc20452847a01775710090383cfb4423275d2f745fed61f34fbf37573ac0d214\nF test/selectE.test a8730ca330fcf40ace158f134f4fe0eb00c7edbf\nF test/selectF.test 21c94e6438f76537b72532fa9fd4710cdd455fc3\nF test/selectG.test 089f7d3d7e6db91566f00b036cb353107a2cca6220eb1cb264085a836dae8840\nF test/server1.test c2b00864514a68a0e6fd518659dc95d0050307a357a08969872bef027d785dc4\nF test/session.test 78fa2365e93d3663a6e933f86e7afc395adf18be\nF test/sessionfuzz-data1.db 1f8d5def831f19b1c74571037f0d53a588ea49a6c4ca2a028fc0c27ef896dbcb\nF test/sessionfuzz.c be9c4d4afd359ce80024d8b541b9b8a880510aef5cf263df56fc0e9b947727f1\nF test/shared.test 1826673eb5eb745fb91a3bdac99a7737057742ae38dcb0fe076a384d6727578b\nF test/shared2.test 03eb4a8d372e290107d34b6ce1809919a698e879\nF test/shared3.test ab693f9b6e156b8bfb2a0ad94f29fe69602a5d38\nF test/shared4.test c75f476804e76e26bf6fa0e7b421fb0ca7d07558\nF test/shared6.test 866bb4982c45ce216c61ded5e8fde4e7e2f3ffa9\nF test/shared7.test a81e99f83e6c51b02ac99c96fb3a2a7b5978c956\nF test/shared8.test 933ed7d71f598bb6c7a8c192a3cd30f2562fdccf514df383798599c34ffa672f\nF test/shared9.test 5f2a8f79b4d6c7d107a01ffa1ed05ae7e6333e21\nF test/sharedA.test 49d87ec54ab640fbbc3786ee3c01de94aaa482a3a9f834ad3fe92770eb69e281\nF test/sharedB.test 16cc7178e20965d75278f410943109b77b2e645e\nF test/shared_err.test 32634e404a3317eeb94abc7a099c556a346fdb8fb3858dbe222a4cbb8926a939\nF test/sharedlock.test 5ede3c37439067c43b0198f580fd374ebf15d304\nF test/shell1.test 3c9707dce15e8fdca529503378660f099777d3ddcedccf801a37589a405c5942\nF test/shell2.test e242a9912f44f4c23c3d1d802a83e934e84c853b\nF test/shell3.test ac8c2b744014c3e9a0e26bfd829ab65f00923dc1a91ffd044863e9423cc91494\nF test/shell4.test 1c6aef11daaa2d6830acaba3ac9cbec93fbc1c3d5530743a637f39b3987d08ce\nF test/shell5.test 23939a4c51f0421330ea61dbd3c74f9c215f5f8d3d1a94846da6ffc777a35458\nF test/shell6.test 1ceb51b2678c472ba6cf1e5da96679ce8347889fe2c3bf93a0e0fa73f00b00d3\nF test/shell7.test 115132f66d0463417f408562cc2cf534f6bbc6d83a6d50f0072a9eb171bae97f\nF test/shell8.test 96be02ea0c21f05b24c1883d7b711a1fa8525a68ab7b636aacf6057876941013\nF test/shmlock.test 3dbf017d34ab0c60abe6a44e447d3552154bd0c87b41eaf5ceacd408dd13fda5\nF test/shortread1.test bb591ef20f0fd9ed26d0d12e80eee6d7ac8897a3\nF test/show_speedtest1_rtree.tcl 32e6c5f073d7426148a6936a0408f4b5b169aba5\nF test/shrink.test 1b4330b1fd9e818c04726d45cb28db73087535ce\nF test/sidedelete.test f0ad71abe6233e3b153100f3b8d679b19a488329\nF test/skipscan1.test 2a64ca7b3e6246bb86b47c9051bfd324603b1b60675fe606513535267713e080\nF test/skipscan2.test 3eb703ce794f139e7b83567911046298bcde29606116727f9b700ce34f559d2d\nF test/skipscan3.test ec5bab3f81c7038b43450e7b3062e04a198bdbb5\nF test/skipscan5.test 67817a4b6857c47e0e33ba3e506da6f23ef68de2\nF test/skipscan6.test 0b4cd1b4ac9f84d91454df513c99a4932fa07e8f27b8049bea605068b3e34ac7\nF test/snapshot.test a504f2e7009f512ef66c719f0ea1c55a556bdaf1e1312c80a04d46fc1a3e9632\nF test/snapshot2.test 8d6ff5dd9cc503f6e12d408a30409c3f9c653507b24408d9cd7195931c89bc54\nF test/snapshot3.test 8744313270c55f6e18574283553d3c5c5fe4c5970585663613a0e75c151e599b\nF test/snapshot4.test d4e9347ef2fcabc491fc893506c7bbaf334da3be111d6eb4f3a97cc623b78322\nF test/snapshot_fault.test f6c5ef7cb93bf92fbb4e864ecc5c87df7d3a250064838822db5b4d3a5563ede4\nF test/snapshot_up.test a0a29c4cf33475fcef07c3f8e64af795e24ab91b4cc68295863402a393cdd41c\nF test/soak.test 18944cf21b94a7fe0df02016a6ee1e9632bc4e8d095a0cb49d95e15d5cca2d5c\nF test/softheap1.test 843cd84db9891b2d01b9ab64cef3e9020f98d087\nF test/sort.test c2adc635c2564241fefec0b3a68391ef6868fd3b\nF test/sort2.test cc23b7c19d684657559e8a55b02f7fcee03851d0\nF test/sort3.test 1480ed7c4c157682542224e05e3b75faf4a149e5\nF test/sort4.test 5c34d9623a4ae5921d956dfa2b70e77ed0fc6e5c\nF test/sort5.test 6b43ae0e2169b5ceed441844492e55ba7f1ae0790528395ddf7888ab3094525d\nF test/sorterref.test a13ed207a0eea3c7898f308f979bfb518f68c598ec737d2c494dfd3deaa83506\nF test/sortfault.test d4ccf606a0c77498e2beb542764fd9394acb4d66\nF test/speed1.test f2974a91d79f58507ada01864c0e323093065452\nF test/speed1p.explain d841e650a04728b39e6740296b852dccdca9b2cb\nF test/speed1p.test b180e98609c7677382cf618c0ec9b69f789033a8\nF test/speed2.test 53177056baf6556dcbdcf032bbdfc41c1aa74ded\nF test/speed3.test 694affeb9100526007436334cf7d08f3d74b85ef\nF test/speed4.test abc0ad3399dcf9703abed2fff8705e4f8e416715\nF test/speed4p.explain 6b5f104ebeb34a038b2f714150f51d01143e59aa\nF test/speed4p.test 377a0c48e5a92e0b11c1c5ebb1bc9d83a7312c922bc0cb05970ef5d6a96d1f0c\nF test/speedtest1.c f3bfe3c6a87cbd88e4c4e38005d972bcc1019d1b2fe9569425f86629b11f6c31\nF test/spellfix.test 951a6405d49d1a23d6b78027d3877b4a33eeb8221dcab5704b499755bb4f552e\nF test/spellfix2.test dfc8f519a3fc204cb2dfa8b4f29821ae90f6f8c3\nF test/spellfix3.test 0f9efaaa502a0e0a09848028518a6fb096c8ad33\nF test/spellfix4.test 51c7c26514ade169855c66bcf130bd5acfb4d7fd090cc624645ab275ae6a41fb\nF test/sqldiff1.test 28cd737cf1b0078b1ec1bbf425e674c47785835e\nF test/sqllimits1.test 264f4b0f941800ba139d25e33ee919c5d95fea06dfbe8ac291d6811a30984ca5\nF test/sqllog.test 6af6cb0b09f4e44e1917e06ce85be7670302517a\nF test/stat.test 05669008edc5ed950e817c24e8c4b66840fda64d8c76bae27e5fc1bd23d95675\nF test/statfault.test f525a7bf633e50afd027700e9a486090684b1ac1\nF test/stmt.test 54ed2cc0764bf3e48a058331813c3dbd19fc1d0827c3d8369914a5d8f564ec75\nF test/stmtvtab1.test 6873dfb24f8e79cbb5b799b95c2e4349060eb7a3b811982749a84b359468e2d5\nF test/subjournal.test 8d4e2572c0ee9a15549f0d8e40863161295107e52f07a3e8012a2e1fdd093c49\nF test/subquery.test d7268d193dd33d5505df965399d3a594e76ae13f\nF test/subquery2.test 90cf944b9de8204569cf656028391e4af1ccc8c0cc02d4ef38ee3be8de1ffb12\nF test/subselect.test 0966aa8e720224dbd6a5e769a3ec2a723e332303\nF test/substr.test 18f57c4ca8a598805c4d64e304c418734d843c1a\nF test/subtype1.test 7fe09496352f97053af1437150751be2d0a0cae8\nF test/superlock.test ec94f0556b6488d97f71c79f9061ae08d9ab8f12\nF test/swarmvtab.test 9a3fd5ab3e9b3c976ad1b3d7646aab725114f2ac26b59395d0778b33bab6cdaf\nF test/swarmvtab2.test c948cb2fdfc5b01d85e8f6d6504854202dc1a0782ab2a0ed61538f27cbd0aa5c\nF test/swarmvtab3.test 247aa38b6ebd2b99db2075847ae47e789ac34f1c2ab5c720dfcffd990004c544\nF test/swarmvtabfault.test 8a67a9f27c61073a47990829e92bc0c64420a807cb642b15a25f6c788210ed95\nF test/symlink.test 72b22238d4405ba34df8e60b335d290a3b1129fd5c260835c944c1e4e77288a9\nF test/symlink2.test 9531f475a53d8781c4f81373f87faf2e2aff4f5fb2102ec6386e0c827916a670\nF test/sync.test 89539f4973c010eda5638407e71ca7fddbcd8e0594f4c9980229f804d4333092\nF test/sync2.test 8f9f7d4f6d5be8ca8941a8dadcc4299e558cb6a1ff653a9469146c7a76ef2039\nF test/syscall.test a39d9a36f852ae6e4800f861bc2f2e83f68bbc2112d9399931ecfadeabd2d69d\nF test/sysfault.test c9f2b0d8d677558f74de750c75e12a5454719d04\nF test/tabfunc01.test 5ca6d004157a3e886a55a9387b960cc0db41acd88753eb597ff409ec6cfb1be0\nF test/table.test eb3463b7add9f16a5bb836badf118cf391b809d09fdccd1f79684600d07ec132\nF test/tableapi.test ecbcc29c4ab62c1912c3717c48ea5c5e59f7d64e4a91034e6148bd2b82f177f4\nF test/tableopts.test dba698ba97251017b7c80d738c198d39ab747930\nF test/tclsqlite.test c4a5f5af3672fbe28a0aa322b88d9d1ce2225b6b1284ea11ede2e6d38e7c812c\nF test/tempdb.test 4cdaa23ddd8acb4d79cbb1b68ccdfd09b0537aaba909ca69a876157c2a2cbd08\nF test/tempdb2.test 353864e96fd3ae2f70773d0ffbf8b1fe48589b02c2ec05013b540879410c3440\nF test/tempfault.test 0c0d349c9a99bf5f374655742577f8712c647900\nF test/temptable.test d2c9b87a54147161bcd1822e30c1d1cd891e5b30\nF test/temptable2.test d2940417496e2b9548e01d09990763fbe88c316504033256d51493e1f1a5ce6a\nF test/temptable3.test d11a0974e52b347e45ee54ef1923c91ed91e4637\nF test/temptrigger.test 38f0ca479b1822d3117069e014daabcaacefffcc\nF test/tester.tcl abba168acd7f01dbfa3ffdbf402d151eb97e8a824d9208e845ab34c194441483\nF test/thread001.test b61a29dd87cf669f5f6ac96124a7c97d71b0c80d9012746072055877055cf9ef\nF test/thread002.test e630504f8a06c00bf8bbe68528774dd96aeb2e58\nF test/thread003.test ee4c9efc3b86a6a2767516a37bd64251272560a7\nF test/thread004.test f51dfc3936184aaf73ee85f315224baad272a87f\nF test/thread005.test 50d10b5684399676174bd96c94ad4250b1a2c8b6\nF test/thread1.test df115faa10a4ba1d456e9d4d9ec165016903eae4\nF test/thread2.test f35d2106452b77523b3a2b7d1dcde2e5ee8f9e46\nF test/thread_common.tcl 334639cadcb9f912bf82aa73f49efd5282e6cadd\nF test/threadtest1.c 6029d9c5567db28e6dc908a0c63099c3ba6c383b\nF test/threadtest2.c a70a8e94bef23339d34226eb9521015ef99f4df8\nF test/threadtest3.c 38a612ea62854349ed66372f330a40d73c5cf956\nF test/threadtest4.c c1e67136ceb6c7ec8184e56ac61db28f96bd2925\nF test/time-wordcount.sh 8e0b0f8109367827ad5d58f5cc849705731e4b90\nF test/tkt-02a8e81d44.test 6c80d9c7514e2a42d4918bf87bf6bc54f379110c\nF test/tkt-18458b1a.test 6a62cb1ee50fa3c620da59e3a6f531eb38fceaf7e2166203816b724524e6f1d6\nF test/tkt-26ff0c2d1e.test c15bec890c4d226c0da2f35ff30f9e84c169cfef90e73a8cb5cec11d723dfa96\nF test/tkt-2a5629202f.test 0521bd25658428baa26665aa53ffed9367d33af2\nF test/tkt-2d1a5c67d.test be1326f3061caec85085f4c9ee4490561ca037c0\nF test/tkt-2ea2425d34.test 1cf13e6f75d149b3209a0cb32927a82d3d79fb28\nF test/tkt-31338dca7e.test 6fb8807851964da0d24e942f2e19c7c705b9fb58\nF test/tkt-313723c356.test 4b306ad45c736cedf2f5221f6155b92143244b6d\nF test/tkt-385a5b56b9.test 5204a7cba0e28c99df0acbf95af5e1af4d32965a7a14de6eccebf949607618b1\nF test/tkt-38cb5df375.test f3cc8671f1eb604d4ae9cf886ed4366bec656678\nF test/tkt-3998683a16.test 6d1d04d551ed1704eb3396ca87bb9ccc8c5c1eb7\nF test/tkt-3a77c9714e.test 90e3e8455ee945a4076d4c44062b8845708af24a880355328fe7008f2047c9f0\nF test/tkt-3fe897352e.test 27e26eb0f1811aeba4d65aba43a4c52e99da5e70\nF test/tkt-4a03edc4c8.test 91c0e135888cdc3d4eea82406a44b05c8c1648d0\nF test/tkt-4c86b126f2.test cbcc611becd0396890169ab23102dd70048bbc9a\nF test/tkt-4dd95f6943.test 3d0ce415d2ee15d3d564121960016b9c7be79407\nF test/tkt-4ef7e3cfca.test 3965ae11cc9cf6e334f9d7d3c1e20bf8d56254b1\nF test/tkt-54844eea3f.test a12b851128f46a695e4e378cca67409b9b8f5894\nF test/tkt-5d863f876e.test 726e76d725f6fe0eb2fc8a522b721b79807380ee\nF test/tkt-5e10420e8d.test 904d1687b3c06d43e5b3555bbcf6802e7c0ffd84\nF test/tkt-5ee23731f.test 9db6e1d7209dc0794948b260d6f82b2b1de83a9f\nF test/tkt-6bfb98dfc0.test 24780633627b5cfc0635a5500c2389ebfb563336\nF test/tkt-752e1646fc.test ea78d88d14fe9866bdd991c634483334639e13bf\nF test/tkt-78e04e52ea.test cb44d0f5e7940223be740a39913a1b9b9b30d7e4a17ed3349141f893bae1b8f2\nF test/tkt-7a31705a7e6.test 9e9c057b6a9497c8f7ba7b16871029414ccf6550e7345d9085d6d71c9a56bb6f\nF test/tkt-7bbfb7d442.test 7b2cd79c7a17ae6750e75ec1a7846712a69c9d18\nF test/tkt-80ba201079.test 105a721e6aad0ae3c5946d7615d1e4d03f6145b8\nF test/tkt-80e031a00f.test 9ee36348b761bf7c14261e002b75a4c0d5a04d4c\nF test/tkt-8454a207b9.test c583a9f814a82a2b5ba95207f55001c9f0cd816c\nF test/tkt-868145d012.test a5f941107ece6a64410ca4755c6329b7eb57a356\nF test/tkt-8c63ff0ec.test 258b7fc8d7e4e1cb5362c7d65c143528b9c4cbed\nF test/tkt-91e2e8ba6f.test 08c4f94ae07696b05c9b822da0b4e5337a2f54c5\nF test/tkt-94c04eaadb.test f738c57c7f68ab8be1c054415af7774617cb6223\nF test/tkt-9a8b09f8e6.test b2ef151d0984b2ebf237760dbeaa50724e5a0667\nF test/tkt-9d68c883.test 16f7cb96781ba579bc2e19bb14b4ad609d9774b6\nF test/tkt-9f2eb3abac.test cb6123ac695a08b4454c3792fbe85108f67fabf8\nF test/tkt-a7b7803e.test 159ef554234fa1f9fb318c751b284bd1cf858da4\nF test/tkt-a7debbe0.test e295fa83cd4416a8ca37b354eb5fadefc5e81fb55253db538d35261fe9c95067\nF test/tkt-a8a0d2996a.test 002e1cde8fc30c39611b52cf981c88200b858765748556822da72e0d32fac73e\nF test/tkt-b1d3a2e531.test 8f7576e41ca179289ee1a8fee28386fd8e4b0550\nF test/tkt-b351d95f9.test d14a503c414c5c58fdde3e80f9a3cfef986498c0\nF test/tkt-b72787b1.test a95e8cdad0b98af1853ac7f0afd4ab27b77bf5f3\nF test/tkt-b75a9ca6b0.test ade89229d853a67a21bbd5e6e1e787a8f9d21f19908d1b7fca6bf3d4d5aa0767\nF test/tkt-ba7cbfaedc.test b4c0deccc12aeb55cfdb57935b16b5d67c5a9877\nF test/tkt-bd484a090c.test 60460bf946f79a79712b71f202eda501ca99b898\nF test/tkt-bdc6bbbb38.test fc38bb09bdd440e3513a1f5f98fc60a075182d7d\nF test/tkt-c48d99d690.test ba61977d62ab612fc515b3c488a6fbd6464a2447\nF test/tkt-c694113d5.test 82c461924ada5c14866c47e85535b0b0923ba16a2e907e370061a5ca77f65d77\nF test/tkt-cbd054fa6b.test 708475ef4d730a6853512c8ce363bcbd3becf0e26826e1f4cd46e2f52ff38edf\nF test/tkt-d11f09d36e.test d999b548fef885d1d1afa49a0e8544ecf436869d\nF test/tkt-d635236375.test 9d37e988b47d87505bc9445be0ca447002df5d09\nF test/tkt-d82e3f3721.test bcc0dfba658d15bab30fd4a9320c9e35d214ce30\nF test/tkt-f3e5abed55.test d5a0126118142d13e27f6ce9f4c47096e9321c00\nF test/tkt-f67b41381a.test a23bc124c981662db712167bacd0ed8ad11abac9\nF test/tkt-f777251dc7a.test d1a8fc3eefb7a9e64d19ff24d5c8c94c34a632fb\nF test/tkt-f7b4edec.test d998a08ff2b18b7f62edce8e3044317c45efe6c7\nF test/tkt-f973c7ac31.test 28ef85c7f015477916795246d8286aeda39d4ead\nF test/tkt-fa7bf5ec.test 9102dfea58aa371d78969da735f9392c57e2e035\nF test/tkt-fc62af4523.test 72825d3febdedcd5593a27989fc05accdbfc2bb4\nF test/tkt-fc7bd6358f.test 634bb4af7d661e82d6b61b80c86727bad698e08f\nF test/tkt1435.test f8c52c41de6e5ca02f1845f3a46e18e25cadac00\nF test/tkt1443.test bacc311da5c96a227bf8c167e77a30c99f8e8368\nF test/tkt1444.test a9d72f9e942708bd82dde6c707da61c489e213e9\nF test/tkt1449.test 93584a449752d52b07d2cfc280a69842b6e16ed5\nF test/tkt1473.test 9d000af3e11a4450d4c596f5e58b4b0d24eb0f8b\nF test/tkt1501.test 2064f98e00871848af4b2f517e46c1a7fb2e32db\nF test/tkt1512.test a1df1f66caf0b9122d6220c15dcee230298c2c2f\nF test/tkt1514.test ddef38e34fea72eb1ab935ded9f17a3fb71dd9df\nF test/tkt1536.test 83ff7a7b6e248016f8d682d4f7a4ae114070d466\nF test/tkt1537.test e3a14332de9770be8ff14bd15c19a49cbec10808\nF test/tkt1567.test 52f329386ac77e59260d4af1c58490d61377db20\nF test/tkt1644.test 80b6a2bb17885f3cf1cb886d97cdad13232bb869\nF test/tkt1667.test 4700d931ed19ea3983e8e703becb28079250b460\nF test/tkt1873.test 0e1b8c023050a430c2525179ed4022ddc7c31264\nF test/tkt2141.test f543d96f50d5a5dc0bc744f7db74ea166720ce46\nF test/tkt2192.test ff40157e5f42e65f844255d220fc6b290470942f\nF test/tkt2213.test a9702175601a57b61aba095a233b001d6f362474\nF test/tkt2251.test 5aab8c7898cd2df2a68fe19289cc29e8f5cf8c82\nF test/tkt2285.test cca17be61cf600b397188e77e7143844d2b977e9\nF test/tkt2332.test fc955609b958ca86dfa102832243370a0cc84070\nF test/tkt2339.test 73bd17818924cd2ac442e5fd9916b58565739450\nF test/tkt2391.test ab7a11be7402da8b51a5be603425367aa0684567\nF test/tkt2409.test be0d60e7d283f639dccea4b0b5e1cd3a4851fb5b\nF test/tkt2450.test 77ed94863f2049c1420288ddfea2d41e5e0971d6\nF test/tkt2565.test 8be666e927cb207aae88188f31c331870878b650\nF test/tkt2640.test 28134f5d1e05658ef182520cf0b680fa3de5211b\nF test/tkt2643.test 3f3ebb743da00d4fed4fcf6daed92a0e18e57813\nF test/tkt2686.test 6ee01c9b9e9c48f6d3a1fdd553b1cc4258f903d6\nF test/tkt2767.test 569000d842678f9cf2db7e0d1b27cbc9011381b0\nF test/tkt2817.test f31839e01f4243cff7399ef654d3af3558cb8d8d\nF test/tkt2820.test 39940276b3436d125deb7d8ebeee053e4cf13213\nF test/tkt2822.test f391776423a7c0d0949edfce375708bfb0f3141e\nF test/tkt2832.test a9b0b74a02dca166a04d9e37739c414b10929caa\nF test/tkt2854.test e432965db29e27e16f539b2ba7f502eb2ccc49af\nF test/tkt2920.test a8737380e4ae6424e00c0273dc12775704efbebf\nF test/tkt2927.test 4752868b9eeeb07a217f7f19f4cbaac98d6d086d\nF test/tkt2942.test c5c87d179799ca6d1fbe83c815510b87cd5ec7ce\nF test/tkt3080.test 1bca7579260920a66b4dd7e196e807c0f25ff804\nF test/tkt3093.test fbdbc5b4969244ad11f540759003e361fcaf391f\nF test/tkt3121.test 536df66a02838c26a12fe98639354ca1290ca68b\nF test/tkt3201.test f1500ccecc0d578dc4cde7d3242008297c4d59b3\nF test/tkt3292.test 7bad4423cf5eb075dbb58511d66d46fe816744754c9f0050ae60157f71a4fca7\nF test/tkt3298.test 20fd8773b825cb602e033aa04f8602e1ebdcd93c\nF test/tkt3334.test 9756631e3c4aa3c416362c279e3c0953a83b7ca8274cb81a13264bb56296d8b0\nF test/tkt3346.test 6f67c3ed7db94dfc5df4f5f0b63809a1f611e01a\nF test/tkt3357.test 77c37c6482b526fe89941ce951c22d011f5922ed\nF test/tkt3419.test 1bbf36d7ea03b638c15804251287c2391f5c1f6b\nF test/tkt3424.test 61f831bd2b071bd128fa5d00fbda57e656ca5812\nF test/tkt3442.test a1fc47c669e651d16494de3ff349bcb53281456f2ca02c8bc14220b6044bbfe8\nF test/tkt3457.test 5651e2cbb94645b677ec663160b9e192b87b7d365aecdfb24e19f749575a6fc2\nF test/tkt3461.test 228ea328a5a21e8663f80ee3d212a6ad92549a19\nF test/tkt3493.test 1686cbde85f8721fc1bdc0ee72f2ef2f63139218\nF test/tkt3508.test d75704db9501625c7f7deec119fcaf1696aefb7d\nF test/tkt3522.test 22ce2ebbcb04a6be56c0977d405c207967318fd6\nF test/tkt3527.test 1a6a48441b560bdc53aec581a868eb576234874d\nF test/tkt3541.test 5dc257bde9bc833ab9cc6844bf170b998dbb950a\nF test/tkt3554.test f599967f279077bace39220cbe76085c7b423725\nF test/tkt3581.test 1966b7193f1e3f14951cce8c66907ae69454e9a3\nF test/tkt35xx.test f38c1b03713179d414969187c941466e44945b35\nF test/tkt3630.test 9a934c58c259f89a0ae6bb6bb846c56285a6fd0f\nF test/tkt3718.test 3b59dcb5c4e7754dacd91e7fd353a61492cc402a\nF test/tkt3731.test 0c5f4cbffe102d43c3b2188af91a9e36348f974b\nF test/tkt3757.test 10cd679a88675c880533083fc79ac04324525595\nF test/tkt3761.test b95ea9c98f21cf91325f18a984887e62caceab33\nF test/tkt3762.test 4d439ff7abdc8d9323150269d182c37c2d514576\nF test/tkt3773.test 7bca904d2a647a6a4a291bd86d7fd7c73855b789\nF test/tkt3791.test a6624b9a80b216a26cf473607f42f3e51898c267\nF test/tkt3793.test d90ffd75c52413908d15e1c44fc2ea9c80fcc449\nF test/tkt3810.test 09608d81c63a6ff3aaf7bc70717909c51f5f4048\nF test/tkt3824.test 150aa00bb6220672e5f0eb14dc8eaa36750425f0\nF test/tkt3832.test 2300d10d57562b89875b72148338ac3e14f8847d\nF test/tkt3838.test 292e72489101cd1320d7278dc111c173ebf334d4\nF test/tkt3841.test 4659845bc53f809a5932c61c6ce8c5bb9d6b947f\nF test/tkt3871.test d921703d07c68f4fd5312073215a17fa34b0401d\nF test/tkt3879.test 2ad5bef2c87e9991ce941e054c31abe26ef7fb90\nF test/tkt3911.test 74cd324f3ba653040cc6d94cc4857b290d12d633\nF test/tkt3918.test ea78bf164e4d55cbde0d83c671ef6fbe930a0032\nF test/tkt3922.test f26be40ab4fe6c00795629bd2006d96e270d9b1a\nF test/tkt3929.test cdf67acf5aa936ec4ffead81db87f8a71fe40e59\nF test/tkt3935.test e15261fedb9e30a4305a311da614a5d8e693c767\nF test/tkt3992.test f3e7d548ac26f763b47bc0f750da3d03c81071da\nF test/tkt3997.test a335fa41ca3985660a139df7b734a26ef53284bd\nF test/tkt4018.test 18dbc6617f7a4b90e938d1bd6d26ad18daafaf08\nF test/tokenize.test ce430a7aed48fc98301611429595883fdfcab5d7\nF test/tpch01.test 7c4eb8cdd79c568f46d344b3e789c9fdb8a766d112871352704861f3fca32a2a\nF test/trace.test a659a9862957f4789e37a92b3bf6d2caf5c86b02cdeefc41e850ae53acf6992a\nF test/trace2.test f5cb67ad3bc09e0c58e8cca78dfd0b5639259983\nF test/trace3.test 1dff966888773ff1bfea01c080caf15417892b3f998408fe920c4791f7337144\nF test/trans.test 6e1b4c6a42dba31bd65f8fa5e61a2708e08ddde6\nF test/trans2.test 62bd045bfc7a1c14c5ba83ba64d21ade31583f76\nF test/trans3.test 91a100e5412b488e22a655fe423a14c26403ab94\nF test/transitive1.test 293300f46916569f08875cdb2fe2134be2c27677\nF test/trigger1.test 746dc327e2a0817a22bfc6f5a5e423483d3e77b3733ac20a8fe939e6541b5e53\nF test/trigger2.test d15da46f7012832faf3e0c536b47024409d5fb1722d2bb77e29c06d96d704bb1\nF test/trigger3.test aa640bb2bbb03edd5ff69c055117ea088f121945\nF test/trigger4.test 74700b76ebf3947b2f7a92405141eb2cf2a5d359\nF test/trigger5.test 619391a3e9fc194081d22cefd830d811e7badf83\nF test/trigger6.test 0e411654f122552da6590f0b4e6f781048a4a9b9\nF test/trigger7.test e7ce54bfda67a88d778aea42544e151c465547a7e617127b6914c2221a6d53c1\nF test/trigger8.test 30cb0530bd7c4728055420e3f739aa00412eafa4\nF test/trigger9.test 2226ec795a33b0460ab5cf8891e9054cc7edef41\nF test/triggerA.test 837be862d8721f903dba3f3ceff05b32e0bee5214cf6ea3da5fadf12d3650e9d\nF test/triggerB.test 56780c031b454abac2340dbb3b71ac5c56c3d7fe\nF test/triggerC.test 29f5a28d0fe39e6e2c01f6e1f53f08c0955170ae10a63ad023e33cb0a1682a51\nF test/triggerD.test 8e7f3921a92a5797d472732108109e44575fa650\nF test/triggerE.test ede2e4bce4ba802337bd69d39447fa04a938e06d84a8bfc53c76850fc36ed86d\nF test/triggerF.test 5d76f0a8c428ff87a4d5ed52da06f6096a2c787a1e21b846111dfac4123de3ad\nF test/triggerG.test d5caeef6144ede2426dd13211fd72248241ff2ebc68e12a4c0bf30f5faa21499\nF test/tt3_checkpoint.c 9e75cf7c1c364f52e1c47fd0f14c4340a9db0fe1\nF test/tt3_index.c 39eec10a35f57672225be4d182862152896dee4a\nF test/tt3_lookaside1.c 0377e202c3c2a50d688cb65ba203afeda6fafeb9\nF test/tt3_stress.c c57d804716165811d979d4a719e05baccd79277f\nF test/tt3_vacuum.c 1753f45917699c9c1f66b64c717a717c9379f776\nF test/types.test bf816ce73c7dfcfe26b700c19f97ef4050d194ff\nF test/types2.test 1aeb81976841a91eef292723649b5c4fe3bc3cac\nF test/types3.test 99e009491a54f4dc02c06bdbc0c5eea56ae3e25a\nF test/unionvtab.test e1704ab1b4c1bb3ffc9da4681f8e85a0b909fd80b937984fc94b27415ac8e5a4\nF test/unionvtabfault.test e8759f3d14fb938ce9657e2342db34aeac0fb9bc1692b0d1ebb0069630151d06\nF test/unique.test 93f8b2ef5ea51b9495f8d6493429b1fd0f465264\nF test/unique2.test 3674e9f2a3f1fbbfd4772ac74b7a97090d0f77d2\nF test/unixexcl.test d936ba2b06794018e136418addd59a2354eeae97\nF test/unordered.test ffeea7747d5ba962a8009a20b7e53d68cbae05b063604c68702c5998eb50c981\nF test/update.test 6a1193fbcb4546b4467d24635b1504b8e746b41d3b66dc6ace07581a62ce58fb\nF test/update2.test 67455bc61fcbcf96923c45b3bc4f87bc72be7d67575ad35f134906148c7b06d3\nF test/upsert1.test 0b740c8488fd2f5a06ac317c9913f7ef1eda8282f2db58b544b89480c51efab3\nF test/upsert2.test 9c3cdbb1a890227f6504ce4b0e3de68f4cdfa16bb21d8641208a9239896c5a09\nF test/upsert3.test 88d7d590a1948a9cb6eac1b54b0642f67a9f35a1fc0f19b200e97d5d39e3179c\nF test/upsert4.test 25d2a1da92f149331ae0c51ca6e3eee78189577585eab92de149900d62994fa5\nF test/upsertfault.test f21ca47740841fdb4d61acfa7b17646d773e67724fe8c185b71c018db8a94b35\nF test/uri.test 3481026f00ade6dfe8adb7acb6e1e47b04369568\nF test/uri2.test 9d3ba7a53ee167572d53a298ee4a5d38ec4a8fb7\nF test/userauth01.test e740a2697a7b40d7c5003a7d7edaee16acd349a9\nF test/utf16align.test 54cd35a27c005a9b6e7815d887718780b6a462ae\nF test/vacuum-into.test 48f4cec354fb6f27c98ef58d2fe49a11b71ff131af0cd9140efacc9858b9f670\nF test/vacuum.test ce91c39f7f91a4273bf620efad21086b5aa6ef1d\nF test/vacuum2.test aa048abee196c16c9ba308465494009057b79f9b\nF test/vacuum3.test 77ecdd54592b45a0bcb133339f99f1ae0ae94d0d\nF test/vacuum4.test 7ea76b769fffeb41f925303b04cbcf5a5bbeabe55e4c60ae754ff24eeeb7c010\nF test/vacuum5.test 263b144d537e92ad8e9ca8a73cc6e1583f41cfd0dda9432b87f7806174a2f48c\nF test/vacuummem.test 7b42abb3208bd82dd23a7536588396f295a314f2\nF test/varint.test bbce22cda8fc4d135bcc2b589574be8410614e62\nF test/veryquick.test 57ab846bacf7b90cf4e9a672721ea5c5b669b661\nF test/view.test 10ea54300a097d7c0337fd104abffe4a4786d1598b94017a37efe0e0d3e04dd5\nF test/vtab1.test c5d9e90ed02bcacd776dcbb7360199d290f7f53c26b484ddece543060c54319f\nF test/vtab2.test 14d4ab26cee13ba6cf5c5601b158e4f57552d3b055cdd9406cf7f711e9c84082\nF test/vtab3.test b45f47d20f225ccc9c28dc915d92740c2dee311e\nF test/vtab4.test 8e73ed268f3d596bc3590f45fc948fb40f28e9c3\nF test/vtab5.test 889f444970393c73f1e077e2bdc5d845e157a391\nF test/vtab6.test 8e789f526e6594cf7ae933d1adee0caa87dc9f78\nF test/vtab7.test 70c6f4a1d6177144a8236e4172d5fba92e683440374664ad1f04851fbb335d3c\nF test/vtab8.test e19fa4a538fcd1bb66c22825fa8f71618fb13583\nF test/vtab9.test ea58d2b95d61955f87226381716b2d0b1d4e4f9b\nF test/vtabA.test 1317f06a03597eee29f40a49b6c21e1aaba4285f\nF test/vtabB.test 04df5dc531b9f44d9ca65b9c1b79f12b5922a796\nF test/vtabC.test 4528f459a13136f982e75614d120aef165f17292\nF test/vtabD.test 05b3f1d77117271671089e48719524b676842e96\nF test/vtabE.test 2a143fe75a11275781d1fd1988d86b66a3f69cb98f4add62e3da8fd0f637b45f\nF test/vtabF.test 1918844c7c902f6a16c8dacf1ec8f84886d6e78b\nF test/vtabH.test 2efb5a24b0bb50796b21eca23032cfb77abfa4b0c03938e38ce5897abac404ca\nF test/vtabI.test 751b07636700dbdea328e4265b6077ccd6811a3f\nF test/vtabJ.test d7b73675708cf63cfcb9d443bb451fc01a028347275b7311e51f9fdf3ca6757f\nF test/vtab_alter.test 736e66fb5ec7b4fee58229aa3ada2f27ec58bc58c00edae4836890c3784c6783\nF test/vtab_err.test dcc8b7b9cb67522b3fe7a272c73856829dae4ab7fdb30399aea1b6981bda2b65\nF test/vtab_shared.test 5253bff2355a9a3f014c15337da7e177ab0ef8ad\nF test/vtabdrop.test 65d4cf6722972e5499bdaf0c0d70ee3b8133944a4e4bc31862563f32a7edca12\nF test/wal.test cdf0ca6cc0447520d19ef1c83287824ebeb3e82d75af856511ba96841a79fc9b\nF test/wal2.test 537f59e5c5932e3b45bf3591ae3e48a2601360c2e52821b633e222fe6ebd5b09\nF test/wal3.test 2a93004bc0fb2b5c29888964024695bade278ab2\nF test/wal4.test 4744e155cd6299c6bd99d3eab1c82f77db9cdb3c\nF test/wal5.test 9c11da7aeccd83a46d79a556ad11a18d3cb15aa9\nF test/wal6.test b602704e4b066199bc89d91ca9000f335dcf4572\nF test/wal64k.test 2a525c0f45d709bae3765c71045ccec5df7d100ccbd3a7860fdba46c9addb965\nF test/wal7.test 2ae8f427d240099cc4b2dfef63cff44e2a68a1bd\nF test/wal8.test d9df3fba4caad5854ed69ed673c68482514203c8\nF test/wal9.test 378e76a9ad09cd9bee06c172ad3547b0129a6750\nF test/wal_common.tcl a98f17fba96206122eff624db0ab13ec377be4fe\nF test/walbak.test 018d4e5a3d45c6298d11b99f09a8ef6876527946\nF test/walbig.test f437473a16cfb314867c6b5d1dbcd519e73e3434\nF test/walblock.test be48f3a75eff0b4456209f26b3ce186c2015497d\nF test/walcksum.test bb234a1bb42248b3515d992b719708015c384278\nF test/walcrash.test 21038858cc552077b0522f50b0fa87e38139306a\nF test/walcrash2.test a0edab4e5390f03b99a790de89aad15d6ec70b36\nF test/walcrash3.test e426aa58122d20f2b9fbe9a507f9eb8cab85b8af\nF test/walcrash4.test e7b6e7639a950a0cca8e210e248c8dad4d63bf20\nF test/walfault.test 09b8ad7e52d2f54bce50e31aa7ea51412bb9f70ac13c74e669ddcd8b48b0d98d\nF test/walfault2.test e039ac66c78d5561683cacde04097213cdad3b58e2b3f3fe1112862217bfd915\nF test/walhook.test ed00a40ba7255da22d6b66433ab61fab16a63483\nF test/walmode.test cd6e7cff618eaaa5910ce57c3657aa50110397f86213886a2400afb9bfec7b7b\nF test/walnoshm.test 84ca10c544632a756467336b7c3b864d493ee496\nF test/waloverwrite.test dad2f26567f1b45174e54fbf9a8dc1cb876a7f03\nF test/walpersist.test 8c6b7e3ec1ba91b5e4dc4e0921d6d3f87cd356a6\nF test/walprotocol.test a112aba0b79e3adeaa485fed09484b32c654e97df58e454aa8489ac2cd57bf84\nF test/walprotocol2.test 7d3b6b4bf0b12f8007121b1e6ef714bc99101fb3b48e46371df1db868eebc131\nF test/walro.test cb438d05ba0d191f10b688e39c4f0cd5b71569a1d1f4440e5bdf3c6880e08c20\nF test/walro2.test 0e79dd15cbdb4f482c01ea248373669c732414a726b357d04846a816afafb768\nF test/walrofault.test c70cb6e308c443867701856cce92ad8288cd99488fa52afab77cca6cfd51af68\nF test/walshared.test 0befc811dcf0b287efae21612304d15576e35417\nF test/walslow.test c05c68d4dc2700a982f89133ce103a1a84cc285f\nF test/walthread.test 14b20fcfa6ae152f5d8e12f5dc8a8a724b7ef189f5d8ef1e2ceab79f2af51747\nF test/walvfs.test ca81c9f427e0e5434076dfa948fd1d8e6d5ddd192b2fb6991635d81da5f3f5d4\nF test/wapp.tcl b440cd8cf57953d3a49e7ee81e6a18f18efdaf113b69f7d8482b0710a64566ec\nF test/wapptest.tcl 3cca775aede0591756a1fc0da55bbb3715d8c363873fd2cfdd4d555b0a4af57d x\nF test/where.test 19c709c9f0f6ed12c23f909f6592aa55fba34269d5a2898537aa27a22b9ce650\nF test/where2.test 478d2170637b9211f593120648858593bf2445a1\nF test/where3.test 2341a294e17193a6b1699ea7f192124a5286ca6acfcc3f4b06d16c931fbcda2c\nF test/where4.test 4a371bfcc607f41d233701bdec33ac2972908ba8\nF test/where5.test fdf66f96d29a064b63eb543e28da4dfdccd81ad2\nF test/where6.test 5da5a98cec820d488e82708301b96cb8c18a258b\nF test/where7.test 75722434c486ac9e74718caa6cce234f45ba34c0b6c0f9555b29eb8bb5f6ade1\nF test/where8.test 461ca40265ed996a6305da99bb024b0e41602bb586acf544c08f95922358e49f\nF test/where9.test 2c554b97bbdb2fdf26c57099f60db8a52bfcf7c147f2c256f9798fa0e267ca85\nF test/whereA.test 6c6a420ca7d313242f9b1bd471dc80e4d0f8323700ba9c78df0bb843d4daa3b4\nF test/whereB.test 0def95db3bdec220a731c7e4bec5930327c1d8c5\nF test/whereC.test cae295158703cb3fc23bf1a108a9ab730efff0f6\nF test/whereD.test 711d4df58d6d4fb9b3f5ce040b818564198be002\nF test/whereE.test b3a055eef928c992b0a33198a7b8dc10eea5ad2f\nF test/whereF.test 3d9412b1199d3e2bed34fcb76b4c48d0bf4df95d27e3f8dd27b6f8b4716d0d89\nF test/whereG.test 4cda56de49f0c7d9a4f2590a3ddc5f79a7f2a03d2229d0f5bb5d3981ce57f293\nF test/whereH.test e4b07f7a3c2f5d31195cd33710054c78667573b2\nF test/whereI.test a2874062140ed4aba9ffae76e6190a3df6fc73d1373fdfa8fd632945082a5364\nF test/whereJ.test 88287550f6ee604422403b053455b1ad894eeaa5c35d348532dfa1439286cb9a\nF test/whereK.test f8e3cf26a8513ecc7f514f54df9f0572c046c42b\nF test/whereL.test 0a19fc44cd1122040f56c934f1b14d0ca85bde28f270268a428dd9796ea0634c\nF test/wherefault.test 1374c3aa198388925246475f84ad4cd5f9528864\nF test/wherelfault.test 9012e4ef5259058b771606616bd007af5d154e64cc25fa9fd4170f6411db44e3\nF test/wherelimit.test 592081800806d297dd7449b1030c863d2883d6d42901837ccd2e5a9bd962edb0\nF test/wherelimit2.test 9bf0aa56cca40ea0e4c5e2915341355a2bbc0859ec4ce1589197fe2a9d94635f\nF test/win32heap.test 10fd891266bd00af68671e702317726375e5407561d859be1aa04696f2aeee74\nF test/win32lock.test fbf107c91d8f5512be5a5b87c4c42ab9fdd54972\nF test/win32longpath.test 169c75a3b2e43481f4a62122510210c67b08f26d\nF test/win32nolock.test ac4f08811a562e45a5755e661f45ca85892bdbbc\nF test/window1.test 6db2c38a0830af8554936a563df92e67962cc379253854cd10d0c3cf0a3120c4\nF test/window2.tcl 66db96fd9fd202bc31ee7f8ce7904cb469564864cff3f74e009bfef8102333f4\nF test/window2.test af2a001ded703bb8f2474fb0edfef170d5aba00f5c1f2aa9f65935b5da13df90\nF test/window3.tcl acea6e86a4324a210fd608d06741010ca83ded9fde438341cb978c49928faf03\nF test/window3.test e9959a993c8a71e96433be8daaa1827d78b8921e4f12debd7bdbeb3c856ef3cb\nF test/window4.tcl d732df0e81beedc0ba8a563ade68611d322d27303ad0c0c8e4444107c39e84ec\nF test/window4.test 807f3e6b15f9338e5b9742b87c5c7ca825b42b9657fde6096e890119370848e0\nF test/window5.test d328dd18221217c49c144181975eea17339eaeaf0e9aa558cee3afb84652821e\nF test/window6.test f8d674254b23289cc17c84d79dec7eda7caa1dfb7836c43122cfdf3640d1df32\nF test/window7.tcl 6a1210f05d40ec89c22960213a22cd3f98d4e2f2eb20646c83c8c30d4d76108f\nF test/window7.test 1d31276961ae7801edc72173edaf7593e3cbc79c06d1f1f09e20d8418af403cd\nF test/window8.tcl f2711aa3571e4e6b0dad98db8d95fd6cb8d9db0c92bbdf535f153b07606a1ce2\nF test/window8.test c4331b27a6f66d69fa8f8bab10cc731db1a81d293ae108a68f7c3487fa94e65b\nF test/window9.test b63f6f74d730547e63e78946f951f5d1a7d4e99f91f6d5906305469043d92a15\nF test/windowA.test 6d63dc1260daa17141a55007600581778523a8b420629f1282d2acfc36af23be\nF test/windowB.test 7a983ea1cc1cf72be7f378e4b32f6cb2d73014c5cd8b25aaee825164cd4269e5\nF test/windowerr.tcl f5acd6fbc210d7b5546c0e879d157888455cd4a17a1d3f28f07c1c8a387019e0\nF test/windowerr.test a8b752402109c15aa1c5efe1b93ccb0ce1ef84fa964ae1cd6684dd0b3cc1819b\nF test/windowfault.test a90b397837209f15e54afa62e8be39b2759a0101fae04e05a08bcc50e243a452\nF test/with1.test d32792084dcb5f6c047d77bb8a032822ef9fe050ade07d0aeffa37753a05e3c9\nF test/with2.test e0030e2f0267a910d6c0e4f46f2dfe941c1cc0d4f659ba69b3597728e7e8f1ab\nF test/with3.test 7de8dff2891aca0f9453463e4a2d6eb995baf137827d5596116fee53e22a4e29\nF test/with4.test 257be66c0c67fee1defbbac0f685c3465e2cad037f21ce65f23f86084f198205\nF test/withM.test 693b61765f2b387b5e3e24a4536e2e82de15ff64\nF test/without_rowid1.test 9cfb83705c506e3849fa7efc88a3c9a15f9a50bf9b1516b41757a7cef9bba8c3\nF test/without_rowid2.test af260339f79d13cb220288b67cd287fbcf81ad99\nF test/without_rowid3.test ea4b59dd1b0d7f5f5e4b7cca978cdb905752a9d7c57dc4344a591dba765a3691\nF test/without_rowid4.test 4e08bcbaee0399f35d58b5581881e7a6243d458a\nF test/without_rowid5.test 89b1c587bd92a0590e440da33e7666bf4891572a\nF test/without_rowid6.test 8463b20098e9f75a501a9f17dfb42fffc79068eac0b2775fe56ef2281d2df45e\nF test/without_rowid7.test d7c59a93d726b55812d620f8f284e01904a5b85f9ee9eea8f2f68571a5e8c40e\nF test/wordcount.c d721a4b6fae93e6e33449700bce1686bc23257c27425bc3ef1599dc912adec66\nF test/writecrash.test f1da7f7adfe8d7f09ea79b42e5ca6dcc41102f27f8e334ad71539501ddd910cc\nF test/zeroblob.test 07a5b11ab591d1f26c626945fb7f228f68b993533b2ada77273edf6ee29db174\nF test/zerodamage.test 9c41628db7e8d9e8a0181e59ea5f189df311a9f6ce99cc376dc461f66db6f8dc\nF test/zipfile.test daab4c9be151934fd6bbc71a0d2520351efc61719eabbf545920f953883d172a\nF test/zipfile2.test 9903388a602a3834189857a985106ff95c3bba6a3969e0134127df991889db5d\nF test/zipfilefault.test 44d4d7a7f7cca7521d569d7f71026b241d65a6b1757aa409c1a168827edbbc2c\nF tool/GetFile.cs 47852aa0d806fe47ed1ac5138bdce7f000fe87aaa7f28107d0cb1e26682aeb44\nF tool/GetTclKit.bat 8995df40c4209808b31f24de0b58f90930239a234f7591e3675d45bfbb990c5d\nF tool/Replace.cs 02c67258801c2fb5f63231e0ac0f220b4b36ba91\nF tool/build-all-msvc.bat c12328d06c45fec8baada5949e3d5af54bf8c887 x\nF tool/build-shell.sh 950f47c6174f1eea171319438b93ba67ff5bf367\nF tool/cg_anno.tcl c1f875f5a4c9caca3d59937b16aff716f8b1883935f1b4c9ae23124705bc8099 x\nF tool/checkSpacing.c 810e51703529a204fc4e1eb060e9ab663e3c06d2\nF tool/dbhash.c 19560c9a2aa2b269b6a5108259b93d26d12f8f0877c31fe9f8f61dfbd219ba63\nF tool/dbtotxt.c b2221864a20fb391c46bd31bc1fbdc4a96f5c8a89bef58f421eb9b9c36b1702c\nF tool/dbtotxt.md c9a57af8739957ef36d2cfad5c4b1443ff3688ed33e4901ee200c8b651f43f3c\nF tool/extract-sqlite3h.tcl 069ceab0cee26cba99952bfa08c0b23e35941c837acabe143f0c355d96c9e2eb x\nF tool/extract.c 054069d81b095fbdc189a6f5d4466e40380505e2\nF tool/fast_vacuum.c 5ba0d6f5963a0a63bdc42840f678bad75b2ebce1\nF tool/fragck.tcl 5265a95126abcf6ab357f7efa544787e5963f439\nF tool/fuzzershell.c e1d90a03ca790d7c331c2aae08ca46ff435f1ae1faa6cb9cc48f4687c18fdc6e\nF tool/genfkey.README cf68fddd4643bbe3ff8e31b8b6d8b0a1b85e20f4\nF tool/genfkey.test b6afd7b825d797a1e1274f519ab5695373552ecad5cd373530c63533638a5a4f\nF tool/getlock.c f4c39b651370156cae979501a7b156bdba50e7ce\nF tool/index_usage.c 9ec344d29cbeb03fdc0fce668eedfb7495792170de933adf95cf8d6904a166ad\nF tool/kvtest-speed.sh 4761a9c4b3530907562314d7757995787f7aef8f\nF tool/lemon.c a361b85fa230560b783006ac002a6a8bad214c3b9d7fa48980aecc2b691ddcad\nF tool/lempar.c e8899b28488f060d0ff931539ea6311b16b22dce068c086c788a06d5e8d01ab7\nF tool/libvers.c caafc3b689638a1d88d44bc5f526c2278760d9b9\nF tool/loadfts.c c3c64e4d5e90e8ba41159232c2189dba4be7b862\nF tool/logest.c 11346aa019e2e77a00902aa7d0cabd27bd2e8cca\nF tool/max-limits.c cbb635fbb37ae4d05f240bfb5b5270bb63c54439\nF tool/mkautoconfamal.sh 422fc365358a2e92876ffc62971a0ff28ed472fc8bcf9de0df921c736fdeca5e\nF tool/mkccode.tcl 86463e68ce9c15d3041610fedd285ce32a5cf7a58fc88b3202b8b76837650dbe x\nF tool/mkctimec.tcl dd183b73ae1c28249669741c250525f0407e579a70482371668fd5f130d9feb3\nF tool/mkkeywordhash.c 27ffc6f6e7e3ecbfc5bca1f1f11a09fc5badf6d67557a5fb2d3b069dbed90617\nF tool/mkmsvcmin.tcl cad0c7b54d7dd92bc87d59f36d4cc4f070eb2e625f14159dc2f5c4204e6a13ea\nF tool/mkopcodec.tcl d1b6362bd3aa80d5520d4d6f3765badf01f6c43c\nF tool/mkopcodeh.tcl 352a4319c0ad869eb26442bf7c3b015aa15594c21f1cce5a6420dbe999367c21\nF tool/mkopts.tcl 680f785fdb09729fd9ac50632413da4eadbdf9071535e3f26d03795828ab07fa\nF tool/mkpragmatab.tcl 70269c7013dab01c5d366b1bb4cee6e42fa1a3a8d179a052d14d6b31f11ad77f\nF tool/mkshellc.tcl 70a9978e363b0f3280ca9ce1c46d72563ff479c1930a12a7375e3881b7325712\nF tool/mksourceid.c 36aa8020014aed0836fd13c51d6dc9219b0df1761d6b5f58ff5b616211b079b9\nF tool/mkspeedsql.tcl a1a334d288f7adfe6e996f2e712becf076745c97\nF tool/mksqlite3c-noext.tcl 4f7cfef5152b0c91920355cbfc1d608a4ad242cb819f1aea07f6d0274f584a7f\nF tool/mksqlite3c.tcl 5fed3d75069d8f66f202d3b5200b0cea4aa7108481acd06732a06fdd42eb83a2\nF tool/mksqlite3h.tcl 080873e3856eceb9d289a08a00c4b30f875ea3feadcbece796bd509b1532792c\nF tool/mksqlite3internalh.tcl eb994013e833359137eb53a55acdad0b5ae1049b\nF tool/mkvsix.tcl b9e0777a213c23156b6542842c238479e496ebf5\nF tool/offsets.c fe4262fdfa378e8f5499a42136d17bf3b98f6091\nF tool/omittest.tcl 27f9413c3343bac200a28d81e8234adb0f5e141c4771893cb19b40235a91f1e0\nF tool/opcodesum.tcl 740ed206ba8c5040018988129abbf3089a0ccf4a\nF tool/pagesig.c ff0ca355fd3c2398e933da5e22439bbff89b803b\nF tool/replace.tcl 60f91e8dd06ab81f74d213ecbd9c9945f32ac048\nF tool/restore_jrnl.tcl 6957a34f8f1f0f8285e07536225ec3b292a9024a\nF tool/rollback-test.c 9fc98427d1e23e84429d7e6d07d9094fbdec65a5\nF tool/run-speed-test.sh f95d19fd669b68c4c38b6b475242841d47c66076\nF tool/showdb.c 97d14a1ce32d5edda84081a5c939bd8975abd89568a773b288940e67e4c7e3ad\nF tool/showjournal.c 5bad7ae8784a43d2b270d953060423b8bd480818\nF tool/showlocks.c 9920bcc64f58378ff1118caead34147201f48c68\nF tool/showshm.c a0ab6ec32dd1f11218ca2a4018f8fb875b59414801ab8ceed8b2e69b7b45a809\nF tool/showstat4.c 0682ebea7abf4d3657f53c4a243f2e7eab48eab344ed36a94bb75dcd19a5c2a1\nF tool/showwal.c ad9d768f96ca6199ad3a8c9562d679680bd032dd01204ea3e5ea6fb931d81847\nF tool/soak1.tcl 8d407956e1a45b485a8e072470a3e629a27037fe\nF tool/spaceanal.tcl 4bfd19aad7eb3ce0372ef0255f58035e0bba4ff5e9acfd763a10c6fb365c8dec\nF tool/speed-check.sh 2b042d703a9472f08c3b13be27afac658426f8e4fc87cd2d575953fda86f08d1\nF tool/speedtest.tcl 06c76698485ccf597b9e7dbb1ac70706eb873355\nF tool/speedtest16.c ecb6542862151c3e6509bbc00509b234562ae81e\nF tool/speedtest2.tcl ee2149167303ba8e95af97873c575c3e0fab58ff\nF tool/speedtest8.c 2902c46588c40b55661e471d7a86e4dd71a18224\nF tool/speedtest8inst1.c 7ce07da76b5e745783e703a834417d725b7d45fd\nF tool/split-sqlite3c.tcl 3efcd4240b738f6bb2b5af0aea7e1e0ef9bc1c61654f645076cec883030b710c\nF tool/sqldiff.c 7b9b7238284f02131dbb8f21a4e862409bff728045c5473139d28c67ac87580e\nF tool/sqlite3_analyzer.c.in 7eeaae8b0d7577662acaabbb11107af0659d1b41bc1dfdd4d91422de27127968\nF tool/sqltclsh.c.in 1bcc2e9da58fadf17b0bf6a50e68c1159e602ce057210b655d50bad5aaaef898\nF tool/sqltclsh.tcl 862f4cf1418df5e1315b5db3b5ebe88969e2a784525af5fbf9596592f14ed848\nF tool/srcck1.c 371de5363b70154012955544f86fdee8f6e5326f\nF tool/stack_usage.tcl f8e71b92cdb099a147dad572375595eae55eca43\nF tool/symbols-mingw.sh 4dbcea7e74768305384c9fd2ed2b41bbf9f0414d\nF tool/symbols.sh 1612bd947750e21e7b47befad5f6b3825b06cce0705441f903bf35ced65ae9b9\nF tool/varint.c 5d94cb5003db9dbbcbcc5df08d66f16071aee003\nF tool/vdbe-compress.tcl 5926c71f9c12d2ab73ef35c29376e756eb68361c\nF tool/vdbe_profile.tcl 246d0da094856d72d2c12efec03250d71639d19f\nF tool/warnings-clang.sh bbf6a1e685e534c92ec2bfba5b1745f34fb6f0bc2a362850723a9ee87c1b31a7\nF tool/warnings.sh 09311479bdc290e20ec8e35a3d1b14b096bbd96222277cfd6274c3a99b3d012f\nF tool/win/sqlite.vsix deb315d026cc8400325c5863eef847784a219a2f\nF vsixtest/App.xaml b76d3b48860e7454775c47ea38ffea9c4abe3e85\nF vsixtest/App.xaml.cpp c465147f50871165c60ca16955219f6c5812d6d8\nF vsixtest/App.xaml.h 4a9768e2983d05600ad1e1c2f1b00a132967da9f\nF vsixtest/Assets/LockScreenLogo.scale-200.png e820c9a3deb909197081b0bf3216c06e13905f0a\nF vsixtest/Assets/SplashScreen.scale-200.png cab70988ca71bebec7bfeb3b6dbafe17b9ab0b4a\nF vsixtest/Assets/Square150x150Logo.scale-200.png e17b40817db7a239fc239d83efcc951fb824e3ff\nF vsixtest/Assets/Square44x44Logo.scale-200.png 2f166237094dea94d952d10b9eeae81806844f1c\nF vsixtest/Assets/Square44x44Logo.targetsize-24_altform-unplated.png 5f6a6d391b95a3061ccca6e6fdd6955ede63b4ed\nF vsixtest/Assets/StoreLogo.png 0828b7257db74a4ecd5eeb6b7b4971f0fdc4d9d1\nF vsixtest/Assets/Wide310x150Logo.scale-200.png 04ddefe5bc5f43ae12a7433f6f236ddab101ac42\nF vsixtest/MainPage.xaml 34f49897e3ca533a7e74506ba0759b66eebce151\nF vsixtest/MainPage.xaml.cpp 7f31fc6de751b64676c0924c97a5485d950a91d7\nF vsixtest/MainPage.xaml.h cc05cca10d50a003f6c6e4448b701cdd07f52f29\nF vsixtest/Package.appxmanifest 6b6db1eb7df3a315c5d681059754d5f0e0c47a93\nF vsixtest/pch.cpp cb823cfac36f1a39a7eb0acbd7e9a0b0de8f23af\nF vsixtest/pch.h 9cab7980f2ac4baa40807d8b5e52af32a21cf78c\nF vsixtest/vsixtest.sln 77cadbe4e96c1fe1bf51cd77de9e9b0a12ada547\nF vsixtest/vsixtest.tcl 6a9a6ab600c25a91a7acc6293828957a386a8a93\nF vsixtest/vsixtest.vcxproj.data 2ed517e100c66dc455b492e1a33350c1b20fbcdc\nF vsixtest/vsixtest.vcxproj.filters 37e51ffedcdb064aad6ff33b6148725226cd608e\nF vsixtest/vsixtest_TemporaryKey.pfx e5b1b036facdb453873e7084e1cae9102ccc67a0\nP a80f84b511231204658304226de3e075a55afc2e3f39ac063716f7a57f585c06\nR 7a95b86f1a40201b7706c8c6219ee188\nU drh\nZ a9ed89712b19f96611f174486447a3a5\n", "4417c5bf0aabb34ed174f01afd981c924ae965a42128719d8d6735536631d12f", "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains routines used for analyzing expressions and\n** for generating VDBE code that evaluates expressions in SQLite.\n*/\n#include \"sqliteInt.h\"\n\n/* Forward declarations */\nstatic void exprCodeBetween(Parse*,Expr*,int,void(*)(Parse*,Expr*,int,int),int);\nstatic int exprCodeVector(Parse *pParse, Expr *p, int *piToFree);\n\n/*\n** Return the affinity character for a single column of a table.\n*/\nchar sqlite3TableColumnAffinity(Table *pTab, int iCol){\n  assert( iCol<pTab->nCol );\n  return iCol>=0 ? pTab->aCol[iCol].affinity : SQLITE_AFF_INTEGER;\n}\n\n/*\n** Return the 'affinity' of the expression pExpr if any.\n**\n** If pExpr is a column, a reference to a column via an 'AS' alias,\n** or a sub-select with a column as the return value, then the \n** affinity of that column is returned. Otherwise, 0x00 is returned,\n** indicating no affinity for the expression.\n**\n** i.e. the WHERE clause expressions in the following statements all\n** have an affinity:\n**\n** CREATE TABLE t1(a);\n** SELECT * FROM t1 WHERE a;\n** SELECT a AS b FROM t1 WHERE b;\n** SELECT * FROM t1 WHERE (select a from t1);\n*/\nchar sqlite3ExprAffinity(Expr *pExpr){\n  int op;\n  while( ExprHasProperty(pExpr, EP_Skip) ){\n    assert( pExpr->op==TK_COLLATE );\n    pExpr = pExpr->pLeft;\n    assert( pExpr!=0 );\n  }\n  op = pExpr->op;\n  if( op==TK_SELECT ){\n    assert( pExpr->flags&EP_xIsSelect );\n    return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);\n  }\n  if( op==TK_REGISTER ) op = pExpr->op2;\n#ifndef SQLITE_OMIT_CAST\n  if( op==TK_CAST ){\n    assert( !ExprHasProperty(pExpr, EP_IntValue) );\n    return sqlite3AffinityType(pExpr->u.zToken, 0);\n  }\n#endif\n  if( (op==TK_AGG_COLUMN || op==TK_COLUMN) && pExpr->y.pTab ){\n    return sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n  }\n  if( op==TK_SELECT_COLUMN ){\n    assert( pExpr->pLeft->flags&EP_xIsSelect );\n    return sqlite3ExprAffinity(\n        pExpr->pLeft->x.pSelect->pEList->a[pExpr->iColumn].pExpr\n    );\n  }\n  if( op==TK_VECTOR ){\n    return sqlite3ExprAffinity(pExpr->x.pList->a[0].pExpr);\n  }\n  return pExpr->affExpr;\n}\n\n/*\n** Set the collating sequence for expression pExpr to be the collating\n** sequence named by pToken.   Return a pointer to a new Expr node that\n** implements the COLLATE operator.\n**\n** If a memory allocation error occurs, that fact is recorded in pParse->db\n** and the pExpr parameter is returned unchanged.\n*/\nExpr *sqlite3ExprAddCollateToken(\n  Parse *pParse,           /* Parsing context */\n  Expr *pExpr,             /* Add the \"COLLATE\" clause to this expression */\n  const Token *pCollName,  /* Name of collating sequence */\n  int dequote              /* True to dequote pCollName */\n){\n  if( pCollName->n>0 ){\n    Expr *pNew = sqlite3ExprAlloc(pParse->db, TK_COLLATE, pCollName, dequote);\n    if( pNew ){\n      pNew->pLeft = pExpr;\n      pNew->flags |= EP_Collate|EP_Skip;\n      pExpr = pNew;\n    }\n  }\n  return pExpr;\n}\nExpr *sqlite3ExprAddCollateString(Parse *pParse, Expr *pExpr, const char *zC){\n  Token s;\n  assert( zC!=0 );\n  sqlite3TokenInit(&s, (char*)zC);\n  return sqlite3ExprAddCollateToken(pParse, pExpr, &s, 0);\n}\n\n/*\n** Skip over any TK_COLLATE operators.\n*/\nExpr *sqlite3ExprSkipCollate(Expr *pExpr){\n  while( pExpr && ExprHasProperty(pExpr, EP_Skip) ){\n    assert( pExpr->op==TK_COLLATE );\n    pExpr = pExpr->pLeft;\n  }   \n  return pExpr;\n}\n\n/*\n** Skip over any TK_COLLATE operators and/or any unlikely()\n** or likelihood() or likely() functions at the root of an\n** expression.\n*/\nExpr *sqlite3ExprSkipCollateAndLikely(Expr *pExpr){\n  while( pExpr && ExprHasProperty(pExpr, EP_Skip|EP_Unlikely) ){\n    if( ExprHasProperty(pExpr, EP_Unlikely) ){\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      assert( pExpr->x.pList->nExpr>0 );\n      assert( pExpr->op==TK_FUNCTION );\n      pExpr = pExpr->x.pList->a[0].pExpr;\n    }else{\n      assert( pExpr->op==TK_COLLATE );\n      pExpr = pExpr->pLeft;\n    }\n  }   \n  return pExpr;\n}\n\n/*\n** Return the collation sequence for the expression pExpr. If\n** there is no defined collating sequence, return NULL.\n**\n** See also: sqlite3ExprNNCollSeq()\n**\n** The sqlite3ExprNNCollSeq() works the same exact that it returns the\n** default collation if pExpr has no defined collation.\n**\n** The collating sequence might be determined by a COLLATE operator\n** or by the presence of a column with a defined collating sequence.\n** COLLATE operators take first precedence.  Left operands take\n** precedence over right operands.\n*/\nCollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){\n  sqlite3 *db = pParse->db;\n  CollSeq *pColl = 0;\n  Expr *p = pExpr;\n  while( p ){\n    int op = p->op;\n    if( op==TK_REGISTER ) op = p->op2;\n    if( (op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_TRIGGER)\n     && p->y.pTab!=0\n    ){\n      /* op==TK_REGISTER && p->y.pTab!=0 happens when pExpr was originally\n      ** a TK_COLUMN but was previously evaluated and cached in a register */\n      int j = p->iColumn;\n      if( j>=0 ){\n        const char *zColl = p->y.pTab->aCol[j].zColl;\n        pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);\n      }\n      break;\n    }\n    if( op==TK_CAST || op==TK_UPLUS ){\n      p = p->pLeft;\n      continue;\n    }\n    if( op==TK_VECTOR ){\n      p = p->x.pList->a[0].pExpr;\n      continue;\n    }\n    if( op==TK_COLLATE ){\n      pColl = sqlite3GetCollSeq(pParse, ENC(db), 0, p->u.zToken);\n      break;\n    }\n    if( p->flags & EP_Collate ){\n      if( p->pLeft && (p->pLeft->flags & EP_Collate)!=0 ){\n        p = p->pLeft;\n      }else{\n        Expr *pNext  = p->pRight;\n        /* The Expr.x union is never used at the same time as Expr.pRight */\n        assert( p->x.pList==0 || p->pRight==0 );\n        if( p->x.pList!=0 \n         && !db->mallocFailed\n         && ALWAYS(!ExprHasProperty(p, EP_xIsSelect))\n        ){\n          int i;\n          for(i=0; i<p->x.pList->nExpr; i++){\n            if( ExprHasProperty(p->x.pList->a[i].pExpr, EP_Collate) ){\n              pNext = p->x.pList->a[i].pExpr;\n              break;\n            }\n          }\n        }\n        p = pNext;\n      }\n    }else{\n      break;\n    }\n  }\n  if( sqlite3CheckCollSeq(pParse, pColl) ){ \n    pColl = 0;\n  }\n  return pColl;\n}\n\n/*\n** Return the collation sequence for the expression pExpr. If\n** there is no defined collating sequence, return a pointer to the\n** defautl collation sequence.\n**\n** See also: sqlite3ExprCollSeq()\n**\n** The sqlite3ExprCollSeq() routine works the same except that it\n** returns NULL if there is no defined collation.\n*/\nCollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr){\n  CollSeq *p = sqlite3ExprCollSeq(pParse, pExpr);\n  if( p==0 ) p = pParse->db->pDfltColl;\n  assert( p!=0 );\n  return p;\n}\n\n/*\n** Return TRUE if the two expressions have equivalent collating sequences.\n*/\nint sqlite3ExprCollSeqMatch(Parse *pParse, Expr *pE1, Expr *pE2){\n  CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pE1);\n  CollSeq *pColl2 = sqlite3ExprNNCollSeq(pParse, pE2);\n  return sqlite3StrICmp(pColl1->zName, pColl2->zName)==0;\n}\n\n/*\n** pExpr is an operand of a comparison operator.  aff2 is the\n** type affinity of the other operand.  This routine returns the\n** type affinity that should be used for the comparison operator.\n*/\nchar sqlite3CompareAffinity(Expr *pExpr, char aff2){\n  char aff1 = sqlite3ExprAffinity(pExpr);\n  if( aff1>SQLITE_AFF_NONE && aff2>SQLITE_AFF_NONE ){\n    /* Both sides of the comparison are columns. If one has numeric\n    ** affinity, use that. Otherwise use no affinity.\n    */\n    if( sqlite3IsNumericAffinity(aff1) || sqlite3IsNumericAffinity(aff2) ){\n      return SQLITE_AFF_NUMERIC;\n    }else{\n      return SQLITE_AFF_BLOB;\n    }\n  }else{\n    /* One side is a column, the other is not. Use the columns affinity. */\n    assert( aff1<=SQLITE_AFF_NONE || aff2<=SQLITE_AFF_NONE );\n    return (aff1<=SQLITE_AFF_NONE ? aff2 : aff1) | SQLITE_AFF_NONE;\n  }\n}\n\n/*\n** pExpr is a comparison operator.  Return the type affinity that should\n** be applied to both operands prior to doing the comparison.\n*/\nstatic char comparisonAffinity(Expr *pExpr){\n  char aff;\n  assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT ||\n          pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE ||\n          pExpr->op==TK_NE || pExpr->op==TK_IS || pExpr->op==TK_ISNOT );\n  assert( pExpr->pLeft );\n  aff = sqlite3ExprAffinity(pExpr->pLeft);\n  if( pExpr->pRight ){\n    aff = sqlite3CompareAffinity(pExpr->pRight, aff);\n  }else if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n    aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);\n  }else if( aff==0 ){\n    aff = SQLITE_AFF_BLOB;\n  }\n  return aff;\n}\n\n/*\n** pExpr is a comparison expression, eg. '=', '<', IN(...) etc.\n** idx_affinity is the affinity of an indexed column. Return true\n** if the index with affinity idx_affinity may be used to implement\n** the comparison in pExpr.\n*/\nint sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){\n  char aff = comparisonAffinity(pExpr);\n  if( aff<SQLITE_AFF_TEXT ){\n    return 1;\n  }\n  if( aff==SQLITE_AFF_TEXT ){\n    return idx_affinity==SQLITE_AFF_TEXT;\n  }\n  return sqlite3IsNumericAffinity(idx_affinity);\n}\n\n/*\n** Return the P5 value that should be used for a binary comparison\n** opcode (OP_Eq, OP_Ge etc.) used to compare pExpr1 and pExpr2.\n*/\nstatic u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){\n  u8 aff = (char)sqlite3ExprAffinity(pExpr2);\n  aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;\n  return aff;\n}\n\n/*\n** Return a pointer to the collation sequence that should be used by\n** a binary comparison operator comparing pLeft and pRight.\n**\n** If the left hand expression has a collating sequence type, then it is\n** used. Otherwise the collation sequence for the right hand expression\n** is used, or the default (BINARY) if neither expression has a collating\n** type.\n**\n** Argument pRight (but not pLeft) may be a null pointer. In this case,\n** it is not considered.\n*/\nCollSeq *sqlite3BinaryCompareCollSeq(\n  Parse *pParse, \n  Expr *pLeft, \n  Expr *pRight\n){\n  CollSeq *pColl;\n  assert( pLeft );\n  if( pLeft->flags & EP_Collate ){\n    pColl = sqlite3ExprCollSeq(pParse, pLeft);\n  }else if( pRight && (pRight->flags & EP_Collate)!=0 ){\n    pColl = sqlite3ExprCollSeq(pParse, pRight);\n  }else{\n    pColl = sqlite3ExprCollSeq(pParse, pLeft);\n    if( !pColl ){\n      pColl = sqlite3ExprCollSeq(pParse, pRight);\n    }\n  }\n  return pColl;\n}\n\n/* Expresssion p is a comparison operator.  Return a collation sequence\n** appropriate for the comparison operator.\n**\n** This is normally just a wrapper around sqlite3BinaryCompareCollSeq().\n** However, if the OP_Commuted flag is set, then the order of the operands\n** is reversed in the sqlite3BinaryCompareCollSeq() call so that the\n** correct collating sequence is found.\n*/\nCollSeq *sqlite3ExprCompareCollSeq(Parse *pParse, Expr *p){\n  if( ExprHasProperty(p, EP_Commuted) ){\n    return sqlite3BinaryCompareCollSeq(pParse, p->pRight, p->pLeft);\n  }else{\n    return sqlite3BinaryCompareCollSeq(pParse, p->pLeft, p->pRight);\n  }\n}\n\n/*\n** Generate code for a comparison operator.\n*/\nstatic int codeCompare(\n  Parse *pParse,    /* The parsing (and code generating) context */\n  Expr *pLeft,      /* The left operand */\n  Expr *pRight,     /* The right operand */\n  int opcode,       /* The comparison opcode */\n  int in1, int in2, /* Register holding operands */\n  int dest,         /* Jump here if true.  */\n  int jumpIfNull,   /* If true, jump if either operand is NULL */\n  int isCommuted    /* The comparison has been commuted */\n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}\n\n/*\n** Return true if expression pExpr is a vector, or false otherwise.\n**\n** A vector is defined as any expression that results in two or more\n** columns of result.  Every TK_VECTOR node is an vector because the\n** parser will not generate a TK_VECTOR with fewer than two entries.\n** But a TK_SELECT might be either a vector or a scalar. It is only\n** considered a vector if it has two or more result columns.\n*/\nint sqlite3ExprIsVector(Expr *pExpr){\n  return sqlite3ExprVectorSize(pExpr)>1;\n}\n\n/*\n** If the expression passed as the only argument is of type TK_VECTOR \n** return the number of expressions in the vector. Or, if the expression\n** is a sub-select, return the number of columns in the sub-select. For\n** any other type of expression, return 1.\n*/\nint sqlite3ExprVectorSize(Expr *pExpr){\n  u8 op = pExpr->op;\n  if( op==TK_REGISTER ) op = pExpr->op2;\n  if( op==TK_VECTOR ){\n    return pExpr->x.pList->nExpr;\n  }else if( op==TK_SELECT ){\n    return pExpr->x.pSelect->pEList->nExpr;\n  }else{\n    return 1;\n  }\n}\n\n/*\n** Return a pointer to a subexpression of pVector that is the i-th\n** column of the vector (numbered starting with 0).  The caller must\n** ensure that i is within range.\n**\n** If pVector is really a scalar (and \"scalar\" here includes subqueries\n** that return a single column!) then return pVector unmodified.\n**\n** pVector retains ownership of the returned subexpression.\n**\n** If the vector is a (SELECT ...) then the expression returned is\n** just the expression for the i-th term of the result set, and may\n** not be ready for evaluation because the table cursor has not yet\n** been positioned.\n*/\nExpr *sqlite3VectorFieldSubexpr(Expr *pVector, int i){\n  assert( i<sqlite3ExprVectorSize(pVector) );\n  if( sqlite3ExprIsVector(pVector) ){\n    assert( pVector->op2==0 || pVector->op==TK_REGISTER );\n    if( pVector->op==TK_SELECT || pVector->op2==TK_SELECT ){\n      return pVector->x.pSelect->pEList->a[i].pExpr;\n    }else{\n      return pVector->x.pList->a[i].pExpr;\n    }\n  }\n  return pVector;\n}\n\n/*\n** Compute and return a new Expr object which when passed to\n** sqlite3ExprCode() will generate all necessary code to compute\n** the iField-th column of the vector expression pVector.\n**\n** It is ok for pVector to be a scalar (as long as iField==0).  \n** In that case, this routine works like sqlite3ExprDup().\n**\n** The caller owns the returned Expr object and is responsible for\n** ensuring that the returned value eventually gets freed.\n**\n** The caller retains ownership of pVector.  If pVector is a TK_SELECT,\n** then the returned object will reference pVector and so pVector must remain\n** valid for the life of the returned object.  If pVector is a TK_VECTOR\n** or a scalar expression, then it can be deleted as soon as this routine\n** returns.\n**\n** A trick to cause a TK_SELECT pVector to be deleted together with\n** the returned Expr object is to attach the pVector to the pRight field\n** of the returned TK_SELECT_COLUMN Expr object.\n*/\nExpr *sqlite3ExprForVectorField(\n  Parse *pParse,       /* Parsing context */\n  Expr *pVector,       /* The vector.  List of expressions or a sub-SELECT */\n  int iField           /* Which column of the vector to return */\n){\n  Expr *pRet;\n  if( pVector->op==TK_SELECT ){\n    assert( pVector->flags & EP_xIsSelect );\n    /* The TK_SELECT_COLUMN Expr node:\n    **\n    ** pLeft:           pVector containing TK_SELECT.  Not deleted.\n    ** pRight:          not used.  But recursively deleted.\n    ** iColumn:         Index of a column in pVector\n    ** iTable:          0 or the number of columns on the LHS of an assignment\n    ** pLeft->iTable:   First in an array of register holding result, or 0\n    **                  if the result is not yet computed.\n    **\n    ** sqlite3ExprDelete() specifically skips the recursive delete of\n    ** pLeft on TK_SELECT_COLUMN nodes.  But pRight is followed, so pVector\n    ** can be attached to pRight to cause this node to take ownership of\n    ** pVector.  Typically there will be multiple TK_SELECT_COLUMN nodes\n    ** with the same pLeft pointer to the pVector, but only one of them\n    ** will own the pVector.\n    */\n    pRet = sqlite3PExpr(pParse, TK_SELECT_COLUMN, 0, 0);\n    if( pRet ){\n      pRet->iColumn = iField;\n      pRet->pLeft = pVector;\n    }\n    assert( pRet==0 || pRet->iTable==0 );\n  }else{\n    if( pVector->op==TK_VECTOR ) pVector = pVector->x.pList->a[iField].pExpr;\n    pRet = sqlite3ExprDup(pParse->db, pVector, 0);\n    sqlite3RenameTokenRemap(pParse, pRet, pVector);\n  }\n  return pRet;\n}\n\n/*\n** If expression pExpr is of type TK_SELECT, generate code to evaluate\n** it. Return the register in which the result is stored (or, if the \n** sub-select returns more than one column, the first in an array\n** of registers in which the result is stored).\n**\n** If pExpr is not a TK_SELECT expression, return 0.\n*/\nstatic int exprCodeSubselect(Parse *pParse, Expr *pExpr){\n  int reg = 0;\n#ifndef SQLITE_OMIT_SUBQUERY\n  if( pExpr->op==TK_SELECT ){\n    reg = sqlite3CodeSubselect(pParse, pExpr);\n  }\n#endif\n  return reg;\n}\n\n/*\n** Argument pVector points to a vector expression - either a TK_VECTOR\n** or TK_SELECT that returns more than one column. This function returns\n** the register number of a register that contains the value of\n** element iField of the vector.\n**\n** If pVector is a TK_SELECT expression, then code for it must have \n** already been generated using the exprCodeSubselect() routine. In this\n** case parameter regSelect should be the first in an array of registers\n** containing the results of the sub-select. \n**\n** If pVector is of type TK_VECTOR, then code for the requested field\n** is generated. In this case (*pRegFree) may be set to the number of\n** a temporary register to be freed by the caller before returning.\n**\n** Before returning, output parameter (*ppExpr) is set to point to the\n** Expr object corresponding to element iElem of the vector.\n*/\nstatic int exprVectorRegister(\n  Parse *pParse,                  /* Parse context */\n  Expr *pVector,                  /* Vector to extract element from */\n  int iField,                     /* Field to extract from pVector */\n  int regSelect,                  /* First in array of registers */\n  Expr **ppExpr,                  /* OUT: Expression element */\n  int *pRegFree                   /* OUT: Temp register to free */\n){\n  u8 op = pVector->op;\n  assert( op==TK_VECTOR || op==TK_REGISTER || op==TK_SELECT );\n  if( op==TK_REGISTER ){\n    *ppExpr = sqlite3VectorFieldSubexpr(pVector, iField);\n    return pVector->iTable+iField;\n  }\n  if( op==TK_SELECT ){\n    *ppExpr = pVector->x.pSelect->pEList->a[iField].pExpr;\n     return regSelect+iField;\n  }\n  *ppExpr = pVector->x.pList->a[iField].pExpr;\n  return sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree);\n}\n\n/*\n** Expression pExpr is a comparison between two vector values. Compute\n** the result of the comparison (1, 0, or NULL) and write that\n** result into register dest.\n**\n** The caller must satisfy the following preconditions:\n**\n**    if pExpr->op==TK_IS:      op==TK_EQ and p5==SQLITE_NULLEQ\n**    if pExpr->op==TK_ISNOT:   op==TK_NE and p5==SQLITE_NULLEQ\n**    otherwise:                op==pExpr->op and p5==0\n*/\nstatic void codeVectorCompare(\n  Parse *pParse,        /* Code generator context */\n  Expr *pExpr,          /* The comparison operation */\n  int dest,             /* Write results into this register */\n  u8 op,                /* Comparison operator */\n  u8 p5                 /* SQLITE_NULLEQ or zero */\n){\n  Vdbe *v = pParse->pVdbe;\n  Expr *pLeft = pExpr->pLeft;\n  Expr *pRight = pExpr->pRight;\n  int nLeft = sqlite3ExprVectorSize(pLeft);\n  int i;\n  int regLeft = 0;\n  int regRight = 0;\n  u8 opx = op;\n  int addrDone = sqlite3VdbeMakeLabel(pParse);\n  int isCommuted = ExprHasProperty(pExpr,EP_Commuted);\n\n  if( nLeft!=sqlite3ExprVectorSize(pRight) ){\n    sqlite3ErrorMsg(pParse, \"row value misused\");\n    return;\n  }\n  assert( pExpr->op==TK_EQ || pExpr->op==TK_NE \n       || pExpr->op==TK_IS || pExpr->op==TK_ISNOT \n       || pExpr->op==TK_LT || pExpr->op==TK_GT \n       || pExpr->op==TK_LE || pExpr->op==TK_GE \n  );\n  assert( pExpr->op==op || (pExpr->op==TK_IS && op==TK_EQ)\n            || (pExpr->op==TK_ISNOT && op==TK_NE) );\n  assert( p5==0 || pExpr->op!=op );\n  assert( p5==SQLITE_NULLEQ || pExpr->op==op );\n\n  p5 |= SQLITE_STOREP2;\n  if( opx==TK_LE ) opx = TK_LT;\n  if( opx==TK_GE ) opx = TK_GT;\n\n  regLeft = exprCodeSubselect(pParse, pLeft);\n  regRight = exprCodeSubselect(pParse, pRight);\n\n  for(i=0; 1 /*Loop exits by \"break\"*/; i++){\n    int regFree1 = 0, regFree2 = 0;\n    Expr *pL, *pR; \n    int r1, r2;\n    assert( i>=0 && i<nLeft );\n    r1 = exprVectorRegister(pParse, pLeft, i, regLeft, &pL, &regFree1);\n    r2 = exprVectorRegister(pParse, pRight, i, regRight, &pR, &regFree2);\n    codeCompare(pParse, pL, pR, opx, r1, r2, dest, p5, isCommuted);\n    testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n    testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n    testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n    testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n    testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);\n    testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n    if( i==nLeft-1 ){\n      break;\n    }\n    if( opx==TK_EQ ){\n      sqlite3VdbeAddOp2(v, OP_IfNot, dest, addrDone); VdbeCoverage(v);\n      p5 |= SQLITE_KEEPNULL;\n    }else if( opx==TK_NE ){\n      sqlite3VdbeAddOp2(v, OP_If, dest, addrDone); VdbeCoverage(v);\n      p5 |= SQLITE_KEEPNULL;\n    }else{\n      assert( op==TK_LT || op==TK_GT || op==TK_LE || op==TK_GE );\n      sqlite3VdbeAddOp2(v, OP_ElseNotEq, 0, addrDone);\n      VdbeCoverageIf(v, op==TK_LT);\n      VdbeCoverageIf(v, op==TK_GT);\n      VdbeCoverageIf(v, op==TK_LE);\n      VdbeCoverageIf(v, op==TK_GE);\n      if( i==nLeft-2 ) opx = op;\n    }\n  }\n  sqlite3VdbeResolveLabel(v, addrDone);\n}\n\n#if SQLITE_MAX_EXPR_DEPTH>0\n/*\n** Check that argument nHeight is less than or equal to the maximum\n** expression depth allowed. If it is not, leave an error message in\n** pParse.\n*/\nint sqlite3ExprCheckHeight(Parse *pParse, int nHeight){\n  int rc = SQLITE_OK;\n  int mxHeight = pParse->db->aLimit[SQLITE_LIMIT_EXPR_DEPTH];\n  if( nHeight>mxHeight ){\n    sqlite3ErrorMsg(pParse, \n       \"Expression tree is too large (maximum depth %d)\", mxHeight\n    );\n    rc = SQLITE_ERROR;\n  }\n  return rc;\n}\n\n/* The following three functions, heightOfExpr(), heightOfExprList()\n** and heightOfSelect(), are used to determine the maximum height\n** of any expression tree referenced by the structure passed as the\n** first argument.\n**\n** If this maximum height is greater than the current value pointed\n** to by pnHeight, the second parameter, then set *pnHeight to that\n** value.\n*/\nstatic void heightOfExpr(Expr *p, int *pnHeight){\n  if( p ){\n    if( p->nHeight>*pnHeight ){\n      *pnHeight = p->nHeight;\n    }\n  }\n}\nstatic void heightOfExprList(ExprList *p, int *pnHeight){\n  if( p ){\n    int i;\n    for(i=0; i<p->nExpr; i++){\n      heightOfExpr(p->a[i].pExpr, pnHeight);\n    }\n  }\n}\nstatic void heightOfSelect(Select *pSelect, int *pnHeight){\n  Select *p;\n  for(p=pSelect; p; p=p->pPrior){\n    heightOfExpr(p->pWhere, pnHeight);\n    heightOfExpr(p->pHaving, pnHeight);\n    heightOfExpr(p->pLimit, pnHeight);\n    heightOfExprList(p->pEList, pnHeight);\n    heightOfExprList(p->pGroupBy, pnHeight);\n    heightOfExprList(p->pOrderBy, pnHeight);\n  }\n}\n\n/*\n** Set the Expr.nHeight variable in the structure passed as an \n** argument. An expression with no children, Expr.pList or \n** Expr.pSelect member has a height of 1. Any other expression\n** has a height equal to the maximum height of any other \n** referenced Expr plus one.\n**\n** Also propagate EP_Propagate flags up from Expr.x.pList to Expr.flags,\n** if appropriate.\n*/\nstatic void exprSetHeight(Expr *p){\n  int nHeight = 0;\n  heightOfExpr(p->pLeft, &nHeight);\n  heightOfExpr(p->pRight, &nHeight);\n  if( ExprHasProperty(p, EP_xIsSelect) ){\n    heightOfSelect(p->x.pSelect, &nHeight);\n  }else if( p->x.pList ){\n    heightOfExprList(p->x.pList, &nHeight);\n    p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);\n  }\n  p->nHeight = nHeight + 1;\n}\n\n/*\n** Set the Expr.nHeight variable using the exprSetHeight() function. If\n** the height is greater than the maximum allowed expression depth,\n** leave an error in pParse.\n**\n** Also propagate all EP_Propagate flags from the Expr.x.pList into\n** Expr.flags. \n*/\nvoid sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){\n  if( pParse->nErr ) return;\n  exprSetHeight(p);\n  sqlite3ExprCheckHeight(pParse, p->nHeight);\n}\n\n/*\n** Return the maximum height of any expression tree referenced\n** by the select statement passed as an argument.\n*/\nint sqlite3SelectExprHeight(Select *p){\n  int nHeight = 0;\n  heightOfSelect(p, &nHeight);\n  return nHeight;\n}\n#else /* ABOVE:  Height enforcement enabled.  BELOW: Height enforcement off */\n/*\n** Propagate all EP_Propagate flags from the Expr.x.pList into\n** Expr.flags. \n*/\nvoid sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){\n  if( p && p->x.pList && !ExprHasProperty(p, EP_xIsSelect) ){\n    p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);\n  }\n}\n#define exprSetHeight(y)\n#endif /* SQLITE_MAX_EXPR_DEPTH>0 */\n\n/*\n** This routine is the core allocator for Expr nodes.\n**\n** Construct a new expression node and return a pointer to it.  Memory\n** for this node and for the pToken argument is a single allocation\n** obtained from sqlite3DbMalloc().  The calling function\n** is responsible for making sure the node eventually gets freed.\n**\n** If dequote is true, then the token (if it exists) is dequoted.\n** If dequote is false, no dequoting is performed.  The deQuote\n** parameter is ignored if pToken is NULL or if the token does not\n** appear to be quoted.  If the quotes were of the form \"...\" (double-quotes)\n** then the EP_DblQuoted flag is set on the expression node.\n**\n** Special case:  If op==TK_INTEGER and pToken points to a string that\n** can be translated into a 32-bit integer, then the token is not\n** stored in u.zToken.  Instead, the integer values is written\n** into u.iValue and the EP_IntValue flag is set.  No extra storage\n** is allocated to hold the integer text and the dequote flag is ignored.\n*/\nExpr *sqlite3ExprAlloc(\n  sqlite3 *db,            /* Handle for sqlite3DbMallocRawNN() */\n  int op,                 /* Expression opcode */\n  const Token *pToken,    /* Token argument.  Might be NULL */\n  int dequote             /* True to dequote */\n){\n  Expr *pNew;\n  int nExtra = 0;\n  int iValue = 0;\n\n  assert( db!=0 );\n  if( pToken ){\n    if( op!=TK_INTEGER || pToken->z==0\n          || sqlite3GetInt32(pToken->z, &iValue)==0 ){\n      nExtra = pToken->n+1;\n      assert( iValue>=0 );\n    }\n  }\n  pNew = sqlite3DbMallocRawNN(db, sizeof(Expr)+nExtra);\n  if( pNew ){\n    memset(pNew, 0, sizeof(Expr));\n    pNew->op = (u8)op;\n    pNew->iAgg = -1;\n    if( pToken ){\n      if( nExtra==0 ){\n        pNew->flags |= EP_IntValue|EP_Leaf|(iValue?EP_IsTrue:EP_IsFalse);\n        pNew->u.iValue = iValue;\n      }else{\n        pNew->u.zToken = (char*)&pNew[1];\n        assert( pToken->z!=0 || pToken->n==0 );\n        if( pToken->n ) memcpy(pNew->u.zToken, pToken->z, pToken->n);\n        pNew->u.zToken[pToken->n] = 0;\n        if( dequote && sqlite3Isquote(pNew->u.zToken[0]) ){\n          sqlite3DequoteExpr(pNew);\n        }\n      }\n    }\n#if SQLITE_MAX_EXPR_DEPTH>0\n    pNew->nHeight = 1;\n#endif  \n  }\n  return pNew;\n}\n\n/*\n** Allocate a new expression node from a zero-terminated token that has\n** already been dequoted.\n*/\nExpr *sqlite3Expr(\n  sqlite3 *db,            /* Handle for sqlite3DbMallocZero() (may be null) */\n  int op,                 /* Expression opcode */\n  const char *zToken      /* Token argument.  Might be NULL */\n){\n  Token x;\n  x.z = zToken;\n  x.n = sqlite3Strlen30(zToken);\n  return sqlite3ExprAlloc(db, op, &x, 0);\n}\n\n/*\n** Attach subtrees pLeft and pRight to the Expr node pRoot.\n**\n** If pRoot==NULL that means that a memory allocation error has occurred.\n** In that case, delete the subtrees pLeft and pRight.\n*/\nvoid sqlite3ExprAttachSubtrees(\n  sqlite3 *db,\n  Expr *pRoot,\n  Expr *pLeft,\n  Expr *pRight\n){\n  if( pRoot==0 ){\n    assert( db->mallocFailed );\n    sqlite3ExprDelete(db, pLeft);\n    sqlite3ExprDelete(db, pRight);\n  }else{\n    if( pRight ){\n      pRoot->pRight = pRight;\n      pRoot->flags |= EP_Propagate & pRight->flags;\n    }\n    if( pLeft ){\n      pRoot->pLeft = pLeft;\n      pRoot->flags |= EP_Propagate & pLeft->flags;\n    }\n    exprSetHeight(pRoot);\n  }\n}\n\n/*\n** Allocate an Expr node which joins as many as two subtrees.\n**\n** One or both of the subtrees can be NULL.  Return a pointer to the new\n** Expr node.  Or, if an OOM error occurs, set pParse->db->mallocFailed,\n** free the subtrees and return NULL.\n*/\nExpr *sqlite3PExpr(\n  Parse *pParse,          /* Parsing context */\n  int op,                 /* Expression opcode */\n  Expr *pLeft,            /* Left operand */\n  Expr *pRight            /* Right operand */\n){\n  Expr *p;\n  p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr));\n  if( p ){\n    memset(p, 0, sizeof(Expr));\n    p->op = op & 0xff;\n    p->iAgg = -1;\n    sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);\n    sqlite3ExprCheckHeight(pParse, p->nHeight);\n  }else{\n    sqlite3ExprDelete(pParse->db, pLeft);\n    sqlite3ExprDelete(pParse->db, pRight);\n  }\n  return p;\n}\n\n/*\n** Add pSelect to the Expr.x.pSelect field.  Or, if pExpr is NULL (due\n** do a memory allocation failure) then delete the pSelect object.\n*/\nvoid sqlite3PExprAddSelect(Parse *pParse, Expr *pExpr, Select *pSelect){\n  if( pExpr ){\n    pExpr->x.pSelect = pSelect;\n    ExprSetProperty(pExpr, EP_xIsSelect|EP_Subquery);\n    sqlite3ExprSetHeightAndFlags(pParse, pExpr);\n  }else{\n    assert( pParse->db->mallocFailed );\n    sqlite3SelectDelete(pParse->db, pSelect);\n  }\n}\n\n\n/*\n** Join two expressions using an AND operator.  If either expression is\n** NULL, then just return the other expression.\n**\n** If one side or the other of the AND is known to be false, then instead\n** of returning an AND expression, just return a constant expression with\n** a value of false.\n*/\nExpr *sqlite3ExprAnd(Parse *pParse, Expr *pLeft, Expr *pRight){\n  sqlite3 *db = pParse->db;\n  if( pLeft==0  ){\n    return pRight;\n  }else if( pRight==0 ){\n    return pLeft;\n  }else if( ExprAlwaysFalse(pLeft) || ExprAlwaysFalse(pRight) ){\n    sqlite3ExprUnmapAndDelete(pParse, pLeft);\n    sqlite3ExprUnmapAndDelete(pParse, pRight);\n    return sqlite3Expr(db, TK_INTEGER, \"0\");\n  }else{\n    return sqlite3PExpr(pParse, TK_AND, pLeft, pRight);\n  }\n}\n\n/*\n** Construct a new expression node for a function with multiple\n** arguments.\n*/\nExpr *sqlite3ExprFunction(\n  Parse *pParse,        /* Parsing context */\n  ExprList *pList,      /* Argument list */\n  Token *pToken,        /* Name of the function */\n  int eDistinct         /* SF_Distinct or SF_ALL or 0 */\n){\n  Expr *pNew;\n  sqlite3 *db = pParse->db;\n  assert( pToken );\n  pNew = sqlite3ExprAlloc(db, TK_FUNCTION, pToken, 1);\n  if( pNew==0 ){\n    sqlite3ExprListDelete(db, pList); /* Avoid memory leak when malloc fails */\n    return 0;\n  }\n  if( pList && pList->nExpr > pParse->db->aLimit[SQLITE_LIMIT_FUNCTION_ARG] ){\n    sqlite3ErrorMsg(pParse, \"too many arguments on function %T\", pToken);\n  }\n  pNew->x.pList = pList;\n  ExprSetProperty(pNew, EP_HasFunc);\n  assert( !ExprHasProperty(pNew, EP_xIsSelect) );\n  sqlite3ExprSetHeightAndFlags(pParse, pNew);\n  if( eDistinct==SF_Distinct ) ExprSetProperty(pNew, EP_Distinct);\n  return pNew;\n}\n\n/*\n** Assign a variable number to an expression that encodes a wildcard\n** in the original SQL statement.  \n**\n** Wildcards consisting of a single \"?\" are assigned the next sequential\n** variable number.\n**\n** Wildcards of the form \"?nnn\" are assigned the number \"nnn\".  We make\n** sure \"nnn\" is not too big to avoid a denial of service attack when\n** the SQL statement comes from an external source.\n**\n** Wildcards of the form \":aaa\", \"@aaa\", or \"$aaa\" are assigned the same number\n** as the previous instance of the same wildcard.  Or if this is the first\n** instance of the wildcard, the next sequential variable number is\n** assigned.\n*/\nvoid sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr, u32 n){\n  sqlite3 *db = pParse->db;\n  const char *z;\n  ynVar x;\n\n  if( pExpr==0 ) return;\n  assert( !ExprHasProperty(pExpr, EP_IntValue|EP_Reduced|EP_TokenOnly) );\n  z = pExpr->u.zToken;\n  assert( z!=0 );\n  assert( z[0]!=0 );\n  assert( n==(u32)sqlite3Strlen30(z) );\n  if( z[1]==0 ){\n    /* Wildcard of the form \"?\".  Assign the next variable number */\n    assert( z[0]=='?' );\n    x = (ynVar)(++pParse->nVar);\n  }else{\n    int doAdd = 0;\n    if( z[0]=='?' ){\n      /* Wildcard of the form \"?nnn\".  Convert \"nnn\" to an integer and\n      ** use it as the variable number */\n      i64 i;\n      int bOk;\n      if( n==2 ){ /*OPTIMIZATION-IF-TRUE*/\n        i = z[1]-'0';  /* The common case of ?N for a single digit N */\n        bOk = 1;\n      }else{\n        bOk = 0==sqlite3Atoi64(&z[1], &i, n-1, SQLITE_UTF8);\n      }\n      testcase( i==0 );\n      testcase( i==1 );\n      testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]-1 );\n      testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] );\n      if( bOk==0 || i<1 || i>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){\n        sqlite3ErrorMsg(pParse, \"variable number must be between ?1 and ?%d\",\n            db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]);\n        return;\n      }\n      x = (ynVar)i;\n      if( x>pParse->nVar ){\n        pParse->nVar = (int)x;\n        doAdd = 1;\n      }else if( sqlite3VListNumToName(pParse->pVList, x)==0 ){\n        doAdd = 1;\n      }\n    }else{\n      /* Wildcards like \":aaa\", \"$aaa\" or \"@aaa\".  Reuse the same variable\n      ** number as the prior appearance of the same name, or if the name\n      ** has never appeared before, reuse the same variable number\n      */\n      x = (ynVar)sqlite3VListNameToNum(pParse->pVList, z, n);\n      if( x==0 ){\n        x = (ynVar)(++pParse->nVar);\n        doAdd = 1;\n      }\n    }\n    if( doAdd ){\n      pParse->pVList = sqlite3VListAdd(db, pParse->pVList, z, n, x);\n    }\n  }\n  pExpr->iColumn = x;\n  if( x>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){\n    sqlite3ErrorMsg(pParse, \"too many SQL variables\");\n  }\n}\n\n/*\n** Recursively delete an expression tree.\n*/\nstatic SQLITE_NOINLINE void sqlite3ExprDeleteNN(sqlite3 *db, Expr *p){\n  assert( p!=0 );\n  /* Sanity check: Assert that the IntValue is non-negative if it exists */\n  assert( !ExprHasProperty(p, EP_IntValue) || p->u.iValue>=0 );\n\n  assert( !ExprHasProperty(p, EP_WinFunc) || p->y.pWin!=0 || db->mallocFailed );\n  assert( p->op!=TK_FUNCTION || ExprHasProperty(p, EP_TokenOnly|EP_Reduced)\n          || p->y.pWin==0 || ExprHasProperty(p, EP_WinFunc) );\n#ifdef SQLITE_DEBUG\n  if( ExprHasProperty(p, EP_Leaf) && !ExprHasProperty(p, EP_TokenOnly) ){\n    assert( p->pLeft==0 );\n    assert( p->pRight==0 );\n    assert( p->x.pSelect==0 );\n  }\n#endif\n  if( !ExprHasProperty(p, (EP_TokenOnly|EP_Leaf)) ){\n    /* The Expr.x union is never used at the same time as Expr.pRight */\n    assert( p->x.pList==0 || p->pRight==0 );\n    if( p->pLeft && p->op!=TK_SELECT_COLUMN ) sqlite3ExprDeleteNN(db, p->pLeft);\n    if( p->pRight ){\n      assert( !ExprHasProperty(p, EP_WinFunc) );\n      sqlite3ExprDeleteNN(db, p->pRight);\n    }else if( ExprHasProperty(p, EP_xIsSelect) ){\n      assert( !ExprHasProperty(p, EP_WinFunc) );\n      sqlite3SelectDelete(db, p->x.pSelect);\n    }else{\n      sqlite3ExprListDelete(db, p->x.pList);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      if( ExprHasProperty(p, EP_WinFunc) ){\n        sqlite3WindowDelete(db, p->y.pWin);\n      }\n#endif\n    }\n  }\n  if( ExprHasProperty(p, EP_MemToken) ) sqlite3DbFree(db, p->u.zToken);\n  if( !ExprHasProperty(p, EP_Static) ){\n    sqlite3DbFreeNN(db, p);\n  }\n}\nvoid sqlite3ExprDelete(sqlite3 *db, Expr *p){\n  if( p ) sqlite3ExprDeleteNN(db, p);\n}\n\n/* Invoke sqlite3RenameExprUnmap() and sqlite3ExprDelete() on the\n** expression.\n*/\nvoid sqlite3ExprUnmapAndDelete(Parse *pParse, Expr *p){\n  if( p ){\n    if( IN_RENAME_OBJECT ){\n      sqlite3RenameExprUnmap(pParse, p);\n    }\n    sqlite3ExprDeleteNN(pParse->db, p);\n  }\n}\n\n/*\n** Return the number of bytes allocated for the expression structure \n** passed as the first argument. This is always one of EXPR_FULLSIZE,\n** EXPR_REDUCEDSIZE or EXPR_TOKENONLYSIZE.\n*/\nstatic int exprStructSize(Expr *p){\n  if( ExprHasProperty(p, EP_TokenOnly) ) return EXPR_TOKENONLYSIZE;\n  if( ExprHasProperty(p, EP_Reduced) ) return EXPR_REDUCEDSIZE;\n  return EXPR_FULLSIZE;\n}\n\n/*\n** The dupedExpr*Size() routines each return the number of bytes required\n** to store a copy of an expression or expression tree.  They differ in\n** how much of the tree is measured.\n**\n**     dupedExprStructSize()     Size of only the Expr structure \n**     dupedExprNodeSize()       Size of Expr + space for token\n**     dupedExprSize()           Expr + token + subtree components\n**\n***************************************************************************\n**\n** The dupedExprStructSize() function returns two values OR-ed together:  \n** (1) the space required for a copy of the Expr structure only and \n** (2) the EP_xxx flags that indicate what the structure size should be.\n** The return values is always one of:\n**\n**      EXPR_FULLSIZE\n**      EXPR_REDUCEDSIZE   | EP_Reduced\n**      EXPR_TOKENONLYSIZE | EP_TokenOnly\n**\n** The size of the structure can be found by masking the return value\n** of this routine with 0xfff.  The flags can be found by masking the\n** return value with EP_Reduced|EP_TokenOnly.\n**\n** Note that with flags==EXPRDUP_REDUCE, this routines works on full-size\n** (unreduced) Expr objects as they or originally constructed by the parser.\n** During expression analysis, extra information is computed and moved into\n** later parts of the Expr object and that extra information might get chopped\n** off if the expression is reduced.  Note also that it does not work to\n** make an EXPRDUP_REDUCE copy of a reduced expression.  It is only legal\n** to reduce a pristine expression tree from the parser.  The implementation\n** of dupedExprStructSize() contain multiple assert() statements that attempt\n** to enforce this constraint.\n*/\nstatic int dupedExprStructSize(Expr *p, int flags){\n  int nSize;\n  assert( flags==EXPRDUP_REDUCE || flags==0 ); /* Only one flag value allowed */\n  assert( EXPR_FULLSIZE<=0xfff );\n  assert( (0xfff & (EP_Reduced|EP_TokenOnly))==0 );\n  if( 0==flags || p->op==TK_SELECT_COLUMN \n#ifndef SQLITE_OMIT_WINDOWFUNC\n   || ExprHasProperty(p, EP_WinFunc)\n#endif\n  ){\n    nSize = EXPR_FULLSIZE;\n  }else{\n    assert( !ExprHasProperty(p, EP_TokenOnly|EP_Reduced) );\n    assert( !ExprHasProperty(p, EP_FromJoin) ); \n    assert( !ExprHasProperty(p, EP_MemToken) );\n    assert( !ExprHasProperty(p, EP_NoReduce) );\n    if( p->pLeft || p->x.pList ){\n      nSize = EXPR_REDUCEDSIZE | EP_Reduced;\n    }else{\n      assert( p->pRight==0 );\n      nSize = EXPR_TOKENONLYSIZE | EP_TokenOnly;\n    }\n  }\n  return nSize;\n}\n\n/*\n** This function returns the space in bytes required to store the copy \n** of the Expr structure and a copy of the Expr.u.zToken string (if that\n** string is defined.)\n*/\nstatic int dupedExprNodeSize(Expr *p, int flags){\n  int nByte = dupedExprStructSize(p, flags) & 0xfff;\n  if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n    nByte += sqlite3Strlen30NN(p->u.zToken)+1;\n  }\n  return ROUND8(nByte);\n}\n\n/*\n** Return the number of bytes required to create a duplicate of the \n** expression passed as the first argument. The second argument is a\n** mask containing EXPRDUP_XXX flags.\n**\n** The value returned includes space to create a copy of the Expr struct\n** itself and the buffer referred to by Expr.u.zToken, if any.\n**\n** If the EXPRDUP_REDUCE flag is set, then the return value includes \n** space to duplicate all Expr nodes in the tree formed by Expr.pLeft \n** and Expr.pRight variables (but not for any structures pointed to or \n** descended from the Expr.x.pList or Expr.x.pSelect variables).\n*/\nstatic int dupedExprSize(Expr *p, int flags){\n  int nByte = 0;\n  if( p ){\n    nByte = dupedExprNodeSize(p, flags);\n    if( flags&EXPRDUP_REDUCE ){\n      nByte += dupedExprSize(p->pLeft, flags) + dupedExprSize(p->pRight, flags);\n    }\n  }\n  return nByte;\n}\n\n/*\n** This function is similar to sqlite3ExprDup(), except that if pzBuffer \n** is not NULL then *pzBuffer is assumed to point to a buffer large enough \n** to store the copy of expression p, the copies of p->u.zToken\n** (if applicable), and the copies of the p->pLeft and p->pRight expressions,\n** if any. Before returning, *pzBuffer is set to the first byte past the\n** portion of the buffer copied into by this function.\n*/\nstatic Expr *exprDup(sqlite3 *db, Expr *p, int dupFlags, u8 **pzBuffer){\n  Expr *pNew;           /* Value to return */\n  u8 *zAlloc;           /* Memory space from which to build Expr object */\n  u32 staticFlag;       /* EP_Static if space not obtained from malloc */\n\n  assert( db!=0 );\n  assert( p );\n  assert( dupFlags==0 || dupFlags==EXPRDUP_REDUCE );\n  assert( pzBuffer==0 || dupFlags==EXPRDUP_REDUCE );\n\n  /* Figure out where to write the new Expr structure. */\n  if( pzBuffer ){\n    zAlloc = *pzBuffer;\n    staticFlag = EP_Static;\n  }else{\n    zAlloc = sqlite3DbMallocRawNN(db, dupedExprSize(p, dupFlags));\n    staticFlag = 0;\n  }\n  pNew = (Expr *)zAlloc;\n\n  if( pNew ){\n    /* Set nNewSize to the size allocated for the structure pointed to\n    ** by pNew. This is either EXPR_FULLSIZE, EXPR_REDUCEDSIZE or\n    ** EXPR_TOKENONLYSIZE. nToken is set to the number of bytes consumed\n    ** by the copy of the p->u.zToken string (if any).\n    */\n    const unsigned nStructSize = dupedExprStructSize(p, dupFlags);\n    const int nNewSize = nStructSize & 0xfff;\n    int nToken;\n    if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n      nToken = sqlite3Strlen30(p->u.zToken) + 1;\n    }else{\n      nToken = 0;\n    }\n    if( dupFlags ){\n      assert( ExprHasProperty(p, EP_Reduced)==0 );\n      memcpy(zAlloc, p, nNewSize);\n    }else{\n      u32 nSize = (u32)exprStructSize(p);\n      memcpy(zAlloc, p, nSize);\n      if( nSize<EXPR_FULLSIZE ){ \n        memset(&zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);\n      }\n    }\n\n    /* Set the EP_Reduced, EP_TokenOnly, and EP_Static flags appropriately. */\n    pNew->flags &= ~(EP_Reduced|EP_TokenOnly|EP_Static|EP_MemToken);\n    pNew->flags |= nStructSize & (EP_Reduced|EP_TokenOnly);\n    pNew->flags |= staticFlag;\n\n    /* Copy the p->u.zToken string, if any. */\n    if( nToken ){\n      char *zToken = pNew->u.zToken = (char*)&zAlloc[nNewSize];\n      memcpy(zToken, p->u.zToken, nToken);\n    }\n\n    if( 0==((p->flags|pNew->flags) & (EP_TokenOnly|EP_Leaf)) ){\n      /* Fill in the pNew->x.pSelect or pNew->x.pList member. */\n      if( ExprHasProperty(p, EP_xIsSelect) ){\n        pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, dupFlags);\n      }else{\n        pNew->x.pList = sqlite3ExprListDup(db, p->x.pList, dupFlags);\n      }\n    }\n\n    /* Fill in pNew->pLeft and pNew->pRight. */\n    if( ExprHasProperty(pNew, EP_Reduced|EP_TokenOnly|EP_WinFunc) ){\n      zAlloc += dupedExprNodeSize(p, dupFlags);\n      if( !ExprHasProperty(pNew, EP_TokenOnly|EP_Leaf) ){\n        pNew->pLeft = p->pLeft ?\n                      exprDup(db, p->pLeft, EXPRDUP_REDUCE, &zAlloc) : 0;\n        pNew->pRight = p->pRight ?\n                       exprDup(db, p->pRight, EXPRDUP_REDUCE, &zAlloc) : 0;\n      }\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      if( ExprHasProperty(p, EP_WinFunc) ){\n        pNew->y.pWin = sqlite3WindowDup(db, pNew, p->y.pWin);\n        assert( ExprHasProperty(pNew, EP_WinFunc) );\n      }\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n      if( pzBuffer ){\n        *pzBuffer = zAlloc;\n      }\n    }else{\n      if( !ExprHasProperty(p, EP_TokenOnly|EP_Leaf) ){\n        if( pNew->op==TK_SELECT_COLUMN ){\n          pNew->pLeft = p->pLeft;\n          assert( p->iColumn==0 || p->pRight==0 );\n          assert( p->pRight==0  || p->pRight==p->pLeft );\n        }else{\n          pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0);\n        }\n        pNew->pRight = sqlite3ExprDup(db, p->pRight, 0);\n      }\n    }\n  }\n  return pNew;\n}\n\n/*\n** Create and return a deep copy of the object passed as the second \n** argument. If an OOM condition is encountered, NULL is returned\n** and the db->mallocFailed flag set.\n*/\n#ifndef SQLITE_OMIT_CTE\nstatic With *withDup(sqlite3 *db, With *p){\n  With *pRet = 0;\n  if( p ){\n    sqlite3_int64 nByte = sizeof(*p) + sizeof(p->a[0]) * (p->nCte-1);\n    pRet = sqlite3DbMallocZero(db, nByte);\n    if( pRet ){\n      int i;\n      pRet->nCte = p->nCte;\n      for(i=0; i<p->nCte; i++){\n        pRet->a[i].pSelect = sqlite3SelectDup(db, p->a[i].pSelect, 0);\n        pRet->a[i].pCols = sqlite3ExprListDup(db, p->a[i].pCols, 0);\n        pRet->a[i].zName = sqlite3DbStrDup(db, p->a[i].zName);\n      }\n    }\n  }\n  return pRet;\n}\n#else\n# define withDup(x,y) 0\n#endif\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n/*\n** The gatherSelectWindows() procedure and its helper routine\n** gatherSelectWindowsCallback() are used to scan all the expressions\n** an a newly duplicated SELECT statement and gather all of the Window\n** objects found there, assembling them onto the linked list at Select->pWin.\n*/\nstatic int gatherSelectWindowsCallback(Walker *pWalker, Expr *pExpr){\n  if( pExpr->op==TK_FUNCTION && ExprHasProperty(pExpr, EP_WinFunc) ){\n    Select *pSelect = pWalker->u.pSelect;\n    Window *pWin = pExpr->y.pWin;\n    assert( pWin );\n    assert( IsWindowFunc(pExpr) );\n    assert( pWin->ppThis==0 );\n    sqlite3WindowLink(pSelect, pWin);\n  }\n  return WRC_Continue;\n}\nstatic int gatherSelectWindowsSelectCallback(Walker *pWalker, Select *p){\n  return p==pWalker->u.pSelect ? WRC_Continue : WRC_Prune;\n}\nstatic void gatherSelectWindows(Select *p){\n  Walker w;\n  w.xExprCallback = gatherSelectWindowsCallback;\n  w.xSelectCallback = gatherSelectWindowsSelectCallback;\n  w.xSelectCallback2 = 0;\n  w.pParse = 0;\n  w.u.pSelect = p;\n  sqlite3WalkSelect(&w, p);\n}\n#endif\n\n\n/*\n** The following group of routines make deep copies of expressions,\n** expression lists, ID lists, and select statements.  The copies can\n** be deleted (by being passed to their respective ...Delete() routines)\n** without effecting the originals.\n**\n** The expression list, ID, and source lists return by sqlite3ExprListDup(),\n** sqlite3IdListDup(), and sqlite3SrcListDup() can not be further expanded \n** by subsequent calls to sqlite*ListAppend() routines.\n**\n** Any tables that the SrcList might point to are not duplicated.\n**\n** The flags parameter contains a combination of the EXPRDUP_XXX flags.\n** If the EXPRDUP_REDUCE flag is set, then the structure returned is a\n** truncated version of the usual Expr structure that will be stored as\n** part of the in-memory representation of the database schema.\n*/\nExpr *sqlite3ExprDup(sqlite3 *db, Expr *p, int flags){\n  assert( flags==0 || flags==EXPRDUP_REDUCE );\n  return p ? exprDup(db, p, flags, 0) : 0;\n}\nExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p, int flags){\n  ExprList *pNew;\n  struct ExprList_item *pItem, *pOldItem;\n  int i;\n  Expr *pPriorSelectCol = 0;\n  assert( db!=0 );\n  if( p==0 ) return 0;\n  pNew = sqlite3DbMallocRawNN(db, sqlite3DbMallocSize(db, p));\n  if( pNew==0 ) return 0;\n  pNew->nExpr = p->nExpr;\n  pItem = pNew->a;\n  pOldItem = p->a;\n  for(i=0; i<p->nExpr; i++, pItem++, pOldItem++){\n    Expr *pOldExpr = pOldItem->pExpr;\n    Expr *pNewExpr;\n    pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags);\n    if( pOldExpr \n     && pOldExpr->op==TK_SELECT_COLUMN\n     && (pNewExpr = pItem->pExpr)!=0 \n    ){\n      assert( pNewExpr->iColumn==0 || i>0 );\n      if( pNewExpr->iColumn==0 ){\n        assert( pOldExpr->pLeft==pOldExpr->pRight );\n        pPriorSelectCol = pNewExpr->pLeft = pNewExpr->pRight;\n      }else{\n        assert( i>0 );\n        assert( pItem[-1].pExpr!=0 );\n        assert( pNewExpr->iColumn==pItem[-1].pExpr->iColumn+1 );\n        assert( pPriorSelectCol==pItem[-1].pExpr->pLeft );\n        pNewExpr->pLeft = pPriorSelectCol;\n      }\n    }\n    pItem->zName = sqlite3DbStrDup(db, pOldItem->zName);\n    pItem->zSpan = sqlite3DbStrDup(db, pOldItem->zSpan);\n    pItem->sortFlags = pOldItem->sortFlags;\n    pItem->done = 0;\n    pItem->bNulls = pOldItem->bNulls;\n    pItem->bSpanIsTab = pOldItem->bSpanIsTab;\n    pItem->bSorterRef = pOldItem->bSorterRef;\n    pItem->u = pOldItem->u;\n  }\n  return pNew;\n}\n\n/*\n** If cursors, triggers, views and subqueries are all omitted from\n** the build, then none of the following routines, except for \n** sqlite3SelectDup(), can be called. sqlite3SelectDup() is sometimes\n** called with a NULL argument.\n*/\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER) \\\n || !defined(SQLITE_OMIT_SUBQUERY)\nSrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p, int flags){\n  SrcList *pNew;\n  int i;\n  int nByte;\n  assert( db!=0 );\n  if( p==0 ) return 0;\n  nByte = sizeof(*p) + (p->nSrc>0 ? sizeof(p->a[0]) * (p->nSrc-1) : 0);\n  pNew = sqlite3DbMallocRawNN(db, nByte );\n  if( pNew==0 ) return 0;\n  pNew->nSrc = pNew->nAlloc = p->nSrc;\n  for(i=0; i<p->nSrc; i++){\n    struct SrcList_item *pNewItem = &pNew->a[i];\n    struct SrcList_item *pOldItem = &p->a[i];\n    Table *pTab;\n    pNewItem->pSchema = pOldItem->pSchema;\n    pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase);\n    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);\n    pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias);\n    pNewItem->fg = pOldItem->fg;\n    pNewItem->iCursor = pOldItem->iCursor;\n    pNewItem->addrFillSub = pOldItem->addrFillSub;\n    pNewItem->regReturn = pOldItem->regReturn;\n    if( pNewItem->fg.isIndexedBy ){\n      pNewItem->u1.zIndexedBy = sqlite3DbStrDup(db, pOldItem->u1.zIndexedBy);\n    }\n    pNewItem->pIBIndex = pOldItem->pIBIndex;\n    if( pNewItem->fg.isTabFunc ){\n      pNewItem->u1.pFuncArg = \n          sqlite3ExprListDup(db, pOldItem->u1.pFuncArg, flags);\n    }\n    pTab = pNewItem->pTab = pOldItem->pTab;\n    if( pTab ){\n      pTab->nTabRef++;\n    }\n    pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect, flags);\n    pNewItem->pOn = sqlite3ExprDup(db, pOldItem->pOn, flags);\n    pNewItem->pUsing = sqlite3IdListDup(db, pOldItem->pUsing);\n    pNewItem->colUsed = pOldItem->colUsed;\n  }\n  return pNew;\n}\nIdList *sqlite3IdListDup(sqlite3 *db, IdList *p){\n  IdList *pNew;\n  int i;\n  assert( db!=0 );\n  if( p==0 ) return 0;\n  pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew) );\n  if( pNew==0 ) return 0;\n  pNew->nId = p->nId;\n  pNew->a = sqlite3DbMallocRawNN(db, p->nId*sizeof(p->a[0]) );\n  if( pNew->a==0 ){\n    sqlite3DbFreeNN(db, pNew);\n    return 0;\n  }\n  /* Note that because the size of the allocation for p->a[] is not\n  ** necessarily a power of two, sqlite3IdListAppend() may not be called\n  ** on the duplicate created by this function. */\n  for(i=0; i<p->nId; i++){\n    struct IdList_item *pNewItem = &pNew->a[i];\n    struct IdList_item *pOldItem = &p->a[i];\n    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);\n    pNewItem->idx = pOldItem->idx;\n  }\n  return pNew;\n}\nSelect *sqlite3SelectDup(sqlite3 *db, Select *pDup, int flags){\n  Select *pRet = 0;\n  Select *pNext = 0;\n  Select **pp = &pRet;\n  Select *p;\n\n  assert( db!=0 );\n  for(p=pDup; p; p=p->pPrior){\n    Select *pNew = sqlite3DbMallocRawNN(db, sizeof(*p) );\n    if( pNew==0 ) break;\n    pNew->pEList = sqlite3ExprListDup(db, p->pEList, flags);\n    pNew->pSrc = sqlite3SrcListDup(db, p->pSrc, flags);\n    pNew->pWhere = sqlite3ExprDup(db, p->pWhere, flags);\n    pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy, flags);\n    pNew->pHaving = sqlite3ExprDup(db, p->pHaving, flags);\n    pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, flags);\n    pNew->op = p->op;\n    pNew->pNext = pNext;\n    pNew->pPrior = 0;\n    pNew->pLimit = sqlite3ExprDup(db, p->pLimit, flags);\n    pNew->iLimit = 0;\n    pNew->iOffset = 0;\n    pNew->selFlags = p->selFlags & ~SF_UsesEphemeral;\n    pNew->addrOpenEphm[0] = -1;\n    pNew->addrOpenEphm[1] = -1;\n    pNew->nSelectRow = p->nSelectRow;\n    pNew->pWith = withDup(db, p->pWith);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    pNew->pWin = 0;\n    pNew->pWinDefn = sqlite3WindowListDup(db, p->pWinDefn);\n    if( p->pWin && db->mallocFailed==0 ) gatherSelectWindows(pNew);\n#endif\n    pNew->selId = p->selId;\n    *pp = pNew;\n    pp = &pNew->pPrior;\n    pNext = pNew;\n  }\n\n  return pRet;\n}\n#else\nSelect *sqlite3SelectDup(sqlite3 *db, Select *p, int flags){\n  assert( p==0 );\n  return 0;\n}\n#endif\n\n\n/*\n** Add a new element to the end of an expression list.  If pList is\n** initially NULL, then create a new expression list.\n**\n** The pList argument must be either NULL or a pointer to an ExprList\n** obtained from a prior call to sqlite3ExprListAppend().  This routine\n** may not be used with an ExprList obtained from sqlite3ExprListDup().\n** Reason:  This routine assumes that the number of slots in pList->a[]\n** is a power of two.  That is true for sqlite3ExprListAppend() returns\n** but is not necessarily true from the return value of sqlite3ExprListDup().\n**\n** If a memory allocation error occurs, the entire list is freed and\n** NULL is returned.  If non-NULL is returned, then it is guaranteed\n** that the new entry was successfully appended.\n*/\nExprList *sqlite3ExprListAppend(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to append. Might be NULL */\n  Expr *pExpr             /* Expression to be appended. Might be NULL */\n){\n  struct ExprList_item *pItem;\n  sqlite3 *db = pParse->db;\n  assert( db!=0 );\n  if( pList==0 ){\n    pList = sqlite3DbMallocRawNN(db, sizeof(ExprList) );\n    if( pList==0 ){\n      goto no_mem;\n    }\n    pList->nExpr = 0;\n  }else if( (pList->nExpr & (pList->nExpr-1))==0 ){\n    ExprList *pNew;\n    pNew = sqlite3DbRealloc(db, pList, \n         sizeof(*pList)+(2*(sqlite3_int64)pList->nExpr-1)*sizeof(pList->a[0]));\n    if( pNew==0 ){\n      goto no_mem;\n    }\n    pList = pNew;\n  }\n  pItem = &pList->a[pList->nExpr++];\n  assert( offsetof(struct ExprList_item,zName)==sizeof(pItem->pExpr) );\n  assert( offsetof(struct ExprList_item,pExpr)==0 );\n  memset(&pItem->zName,0,sizeof(*pItem)-offsetof(struct ExprList_item,zName));\n  pItem->pExpr = pExpr;\n  return pList;\n\nno_mem:     \n  /* Avoid leaking memory if malloc has failed. */\n  sqlite3ExprDelete(db, pExpr);\n  sqlite3ExprListDelete(db, pList);\n  return 0;\n}\n\n/*\n** pColumns and pExpr form a vector assignment which is part of the SET\n** clause of an UPDATE statement.  Like this:\n**\n**        (a,b,c) = (expr1,expr2,expr3)\n** Or:    (a,b,c) = (SELECT x,y,z FROM ....)\n**\n** For each term of the vector assignment, append new entries to the\n** expression list pList.  In the case of a subquery on the RHS, append\n** TK_SELECT_COLUMN expressions.\n*/\nExprList *sqlite3ExprListAppendVector(\n  Parse *pParse,         /* Parsing context */\n  ExprList *pList,       /* List to which to append. Might be NULL */\n  IdList *pColumns,      /* List of names of LHS of the assignment */\n  Expr *pExpr            /* Vector expression to be appended. Might be NULL */\n){\n  sqlite3 *db = pParse->db;\n  int n;\n  int i;\n  int iFirst = pList ? pList->nExpr : 0;\n  /* pColumns can only be NULL due to an OOM but an OOM will cause an\n  ** exit prior to this routine being invoked */\n  if( NEVER(pColumns==0) ) goto vector_append_error;\n  if( pExpr==0 ) goto vector_append_error;\n\n  /* If the RHS is a vector, then we can immediately check to see that \n  ** the size of the RHS and LHS match.  But if the RHS is a SELECT, \n  ** wildcards (\"*\") in the result set of the SELECT must be expanded before\n  ** we can do the size check, so defer the size check until code generation.\n  */\n  if( pExpr->op!=TK_SELECT && pColumns->nId!=(n=sqlite3ExprVectorSize(pExpr)) ){\n    sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\",\n                    pColumns->nId, n);\n    goto vector_append_error;\n  }\n\n  for(i=0; i<pColumns->nId; i++){\n    Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i);\n    assert( pSubExpr!=0 || db->mallocFailed );\n    assert( pSubExpr==0 || pSubExpr->iTable==0 );\n    if( pSubExpr==0 ) continue;\n    pSubExpr->iTable = pColumns->nId;\n    pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);\n    if( pList ){\n      assert( pList->nExpr==iFirst+i+1 );\n      pList->a[pList->nExpr-1].zName = pColumns->a[i].zName;\n      pColumns->a[i].zName = 0;\n    }\n  }\n\n  if( !db->mallocFailed && pExpr->op==TK_SELECT && ALWAYS(pList!=0) ){\n    Expr *pFirst = pList->a[iFirst].pExpr;\n    assert( pFirst!=0 );\n    assert( pFirst->op==TK_SELECT_COLUMN );\n     \n    /* Store the SELECT statement in pRight so it will be deleted when\n    ** sqlite3ExprListDelete() is called */\n    pFirst->pRight = pExpr;\n    pExpr = 0;\n\n    /* Remember the size of the LHS in iTable so that we can check that\n    ** the RHS and LHS sizes match during code generation. */\n    pFirst->iTable = pColumns->nId;\n  }\n\nvector_append_error:\n  sqlite3ExprUnmapAndDelete(pParse, pExpr);\n  sqlite3IdListDelete(db, pColumns);\n  return pList;\n}\n\n/*\n** Set the sort order for the last element on the given ExprList.\n*/\nvoid sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder, int eNulls){\n  struct ExprList_item *pItem;\n  if( p==0 ) return;\n  assert( p->nExpr>0 );\n\n  assert( SQLITE_SO_UNDEFINED<0 && SQLITE_SO_ASC==0 && SQLITE_SO_DESC>0 );\n  assert( iSortOrder==SQLITE_SO_UNDEFINED \n       || iSortOrder==SQLITE_SO_ASC \n       || iSortOrder==SQLITE_SO_DESC \n  );\n  assert( eNulls==SQLITE_SO_UNDEFINED \n       || eNulls==SQLITE_SO_ASC \n       || eNulls==SQLITE_SO_DESC \n  );\n\n  pItem = &p->a[p->nExpr-1];\n  assert( pItem->bNulls==0 );\n  if( iSortOrder==SQLITE_SO_UNDEFINED ){\n    iSortOrder = SQLITE_SO_ASC;\n  }\n  pItem->sortFlags = (u8)iSortOrder;\n\n  if( eNulls!=SQLITE_SO_UNDEFINED ){\n    pItem->bNulls = 1;\n    if( iSortOrder!=eNulls ){\n      pItem->sortFlags |= KEYINFO_ORDER_BIGNULL;\n    }\n  }\n}\n\n/*\n** Set the ExprList.a[].zName element of the most recently added item\n** on the expression list.\n**\n** pList might be NULL following an OOM error.  But pName should never be\n** NULL.  If a memory allocation fails, the pParse->db->mallocFailed flag\n** is set.\n*/\nvoid sqlite3ExprListSetName(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to add the span. */\n  Token *pName,           /* Name to be added */\n  int dequote             /* True to cause the name to be dequoted */\n){\n  assert( pList!=0 || pParse->db->mallocFailed!=0 );\n  if( pList ){\n    struct ExprList_item *pItem;\n    assert( pList->nExpr>0 );\n    pItem = &pList->a[pList->nExpr-1];\n    assert( pItem->zName==0 );\n    pItem->zName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n);\n    if( dequote ) sqlite3Dequote(pItem->zName);\n    if( IN_RENAME_OBJECT ){\n      sqlite3RenameTokenMap(pParse, (void*)pItem->zName, pName);\n    }\n  }\n}\n\n/*\n** Set the ExprList.a[].zSpan element of the most recently added item\n** on the expression list.\n**\n** pList might be NULL following an OOM error.  But pSpan should never be\n** NULL.  If a memory allocation fails, the pParse->db->mallocFailed flag\n** is set.\n*/\nvoid sqlite3ExprListSetSpan(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to add the span. */\n  const char *zStart,     /* Start of the span */\n  const char *zEnd        /* End of the span */\n){\n  sqlite3 *db = pParse->db;\n  assert( pList!=0 || db->mallocFailed!=0 );\n  if( pList ){\n    struct ExprList_item *pItem = &pList->a[pList->nExpr-1];\n    assert( pList->nExpr>0 );\n    sqlite3DbFree(db, pItem->zSpan);\n    pItem->zSpan = sqlite3DbSpanDup(db, zStart, zEnd);\n  }\n}\n\n/*\n** If the expression list pEList contains more than iLimit elements,\n** leave an error message in pParse.\n*/\nvoid sqlite3ExprListCheckLength(\n  Parse *pParse,\n  ExprList *pEList,\n  const char *zObject\n){\n  int mx = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];\n  testcase( pEList && pEList->nExpr==mx );\n  testcase( pEList && pEList->nExpr==mx+1 );\n  if( pEList && pEList->nExpr>mx ){\n    sqlite3ErrorMsg(pParse, \"too many columns in %s\", zObject);\n  }\n}\n\n/*\n** Delete an entire expression list.\n*/\nstatic SQLITE_NOINLINE void exprListDeleteNN(sqlite3 *db, ExprList *pList){\n  int i = pList->nExpr;\n  struct ExprList_item *pItem =  pList->a;\n  assert( pList->nExpr>0 );\n  do{\n    sqlite3ExprDelete(db, pItem->pExpr);\n    sqlite3DbFree(db, pItem->zName);\n    sqlite3DbFree(db, pItem->zSpan);\n    pItem++;\n  }while( --i>0 );\n  sqlite3DbFreeNN(db, pList);\n}\nvoid sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){\n  if( pList ) exprListDeleteNN(db, pList);\n}\n\n/*\n** Return the bitwise-OR of all Expr.flags fields in the given\n** ExprList.\n*/\nu32 sqlite3ExprListFlags(const ExprList *pList){\n  int i;\n  u32 m = 0;\n  assert( pList!=0 );\n  for(i=0; i<pList->nExpr; i++){\n     Expr *pExpr = pList->a[i].pExpr;\n     assert( pExpr!=0 );\n     m |= pExpr->flags;\n  }\n  return m;\n}\n\n/*\n** This is a SELECT-node callback for the expression walker that\n** always \"fails\".  By \"fail\" in this case, we mean set\n** pWalker->eCode to zero and abort.\n**\n** This callback is used by multiple expression walkers.\n*/\nint sqlite3SelectWalkFail(Walker *pWalker, Select *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  pWalker->eCode = 0;\n  return WRC_Abort;\n}\n\n/*\n** If the input expression is an ID with the name \"true\" or \"false\"\n** then convert it into an TK_TRUEFALSE term.  Return non-zero if\n** the conversion happened, and zero if the expression is unaltered.\n*/\nint sqlite3ExprIdToTrueFalse(Expr *pExpr){\n  assert( pExpr->op==TK_ID || pExpr->op==TK_STRING );\n  if( !ExprHasProperty(pExpr, EP_Quoted)\n   && (sqlite3StrICmp(pExpr->u.zToken, \"true\")==0\n       || sqlite3StrICmp(pExpr->u.zToken, \"false\")==0)\n  ){\n    pExpr->op = TK_TRUEFALSE;\n    ExprSetProperty(pExpr, pExpr->u.zToken[4]==0 ? EP_IsTrue : EP_IsFalse);\n    return 1;\n  }\n  return 0;\n}\n\n/*\n** The argument must be a TK_TRUEFALSE Expr node.  Return 1 if it is TRUE\n** and 0 if it is FALSE.\n*/\nint sqlite3ExprTruthValue(const Expr *pExpr){\n  pExpr = sqlite3ExprSkipCollate((Expr*)pExpr);\n  assert( pExpr->op==TK_TRUEFALSE );\n  assert( sqlite3StrICmp(pExpr->u.zToken,\"true\")==0\n       || sqlite3StrICmp(pExpr->u.zToken,\"false\")==0 );\n  return pExpr->u.zToken[4]==0;\n}\n\n/*\n** If pExpr is an AND or OR expression, try to simplify it by eliminating\n** terms that are always true or false.  Return the simplified expression.\n** Or return the original expression if no simplification is possible.\n**\n** Examples:\n**\n**     (x<10) AND true                =>   (x<10)\n**     (x<10) AND false               =>   false\n**     (x<10) AND (y=22 OR false)     =>   (x<10) AND (y=22)\n**     (x<10) AND (y=22 OR true)      =>   (x<10)\n**     (y=22) OR true                 =>   true\n*/\nExpr *sqlite3ExprSimplifiedAndOr(Expr *pExpr){\n  assert( pExpr!=0 );\n  if( pExpr->op==TK_AND || pExpr->op==TK_OR ){\n    Expr *pRight = sqlite3ExprSimplifiedAndOr(pExpr->pRight);\n    Expr *pLeft = sqlite3ExprSimplifiedAndOr(pExpr->pLeft);\n    if( ExprAlwaysTrue(pLeft) || ExprAlwaysFalse(pRight) ){\n      pExpr = pExpr->op==TK_AND ? pRight : pLeft;\n    }else if( ExprAlwaysTrue(pRight) || ExprAlwaysFalse(pLeft) ){\n      pExpr = pExpr->op==TK_AND ? pLeft : pRight;\n    }\n  }\n  return pExpr;\n}\n\n\n/*\n** These routines are Walker callbacks used to check expressions to\n** see if they are \"constant\" for some definition of constant.  The\n** Walker.eCode value determines the type of \"constant\" we are looking\n** for.\n**\n** These callback routines are used to implement the following:\n**\n**     sqlite3ExprIsConstant()                  pWalker->eCode==1\n**     sqlite3ExprIsConstantNotJoin()           pWalker->eCode==2\n**     sqlite3ExprIsTableConstant()             pWalker->eCode==3\n**     sqlite3ExprIsConstantOrFunction()        pWalker->eCode==4 or 5\n**\n** In all cases, the callbacks set Walker.eCode=0 and abort if the expression\n** is found to not be a constant.\n**\n** The sqlite3ExprIsConstantOrFunction() is used for evaluating expressions\n** in a CREATE TABLE statement.  The Walker.eCode value is 5 when parsing\n** an existing schema and 4 when processing a new statement.  A bound\n** parameter raises an error for new statements, but is silently converted\n** to NULL for existing schemas.  This allows sqlite_master tables that \n** contain a bound parameter because they were generated by older versions\n** of SQLite to be parsed by newer versions of SQLite without raising a\n** malformed schema error.\n*/\nstatic int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){\n\n  /* If pWalker->eCode is 2 then any term of the expression that comes from\n  ** the ON or USING clauses of a left join disqualifies the expression\n  ** from being considered constant. */\n  if( pWalker->eCode==2 && ExprHasProperty(pExpr, EP_FromJoin) ){\n    pWalker->eCode = 0;\n    return WRC_Abort;\n  }\n\n  switch( pExpr->op ){\n    /* Consider functions to be constant if all their arguments are constant\n    ** and either pWalker->eCode==4 or 5 or the function has the\n    ** SQLITE_FUNC_CONST flag. */\n    case TK_FUNCTION:\n      if( (pWalker->eCode>=4 || ExprHasProperty(pExpr,EP_ConstFunc))\n       && !ExprHasProperty(pExpr, EP_WinFunc)\n      ){\n        return WRC_Continue;\n      }else{\n        pWalker->eCode = 0;\n        return WRC_Abort;\n      }\n    case TK_ID:\n      /* Convert \"true\" or \"false\" in a DEFAULT clause into the\n      ** appropriate TK_TRUEFALSE operator */\n      if( sqlite3ExprIdToTrueFalse(pExpr) ){\n        return WRC_Prune;\n      }\n      /* Fall thru */\n    case TK_COLUMN:\n    case TK_AGG_FUNCTION:\n    case TK_AGG_COLUMN:\n      testcase( pExpr->op==TK_ID );\n      testcase( pExpr->op==TK_COLUMN );\n      testcase( pExpr->op==TK_AGG_FUNCTION );\n      testcase( pExpr->op==TK_AGG_COLUMN );\n      if( ExprHasProperty(pExpr, EP_FixedCol) && pWalker->eCode!=2 ){\n        return WRC_Continue;\n      }\n      if( pWalker->eCode==3 && pExpr->iTable==pWalker->u.iCur ){\n        return WRC_Continue;\n      }\n      /* Fall through */\n    case TK_IF_NULL_ROW:\n    case TK_REGISTER:\n      testcase( pExpr->op==TK_REGISTER );\n      testcase( pExpr->op==TK_IF_NULL_ROW );\n      pWalker->eCode = 0;\n      return WRC_Abort;\n    case TK_VARIABLE:\n      if( pWalker->eCode==5 ){\n        /* Silently convert bound parameters that appear inside of CREATE\n        ** statements into a NULL when parsing the CREATE statement text out\n        ** of the sqlite_master table */\n        pExpr->op = TK_NULL;\n      }else if( pWalker->eCode==4 ){\n        /* A bound parameter in a CREATE statement that originates from\n        ** sqlite3_prepare() causes an error */\n        pWalker->eCode = 0;\n        return WRC_Abort;\n      }\n      /* Fall through */\n    default:\n      testcase( pExpr->op==TK_SELECT ); /* sqlite3SelectWalkFail() disallows */\n      testcase( pExpr->op==TK_EXISTS ); /* sqlite3SelectWalkFail() disallows */\n      return WRC_Continue;\n  }\n}\nstatic int exprIsConst(Expr *p, int initFlag, int iCur){\n  Walker w;\n  w.eCode = initFlag;\n  w.xExprCallback = exprNodeIsConstant;\n  w.xSelectCallback = sqlite3SelectWalkFail;\n#ifdef SQLITE_DEBUG\n  w.xSelectCallback2 = sqlite3SelectWalkAssert2;\n#endif\n  w.u.iCur = iCur;\n  sqlite3WalkExpr(&w, p);\n  return w.eCode;\n}\n\n/*\n** Walk an expression tree.  Return non-zero if the expression is constant\n** and 0 if it involves variables or function calls.\n**\n** For the purposes of this function, a double-quoted string (ex: \"abc\")\n** is considered a variable but a single-quoted string (ex: 'abc') is\n** a constant.\n*/\nint sqlite3ExprIsConstant(Expr *p){\n  return exprIsConst(p, 1, 0);\n}\n\n/*\n** Walk an expression tree.  Return non-zero if\n**\n**   (1) the expression is constant, and\n**   (2) the expression does originate in the ON or USING clause\n**       of a LEFT JOIN, and\n**   (3) the expression does not contain any EP_FixedCol TK_COLUMN\n**       operands created by the constant propagation optimization.\n**\n** When this routine returns true, it indicates that the expression\n** can be added to the pParse->pConstExpr list and evaluated once when\n** the prepared statement starts up.  See sqlite3ExprCodeAtInit().\n*/\nint sqlite3ExprIsConstantNotJoin(Expr *p){\n  return exprIsConst(p, 2, 0);\n}\n\n/*\n** Walk an expression tree.  Return non-zero if the expression is constant\n** for any single row of the table with cursor iCur.  In other words, the\n** expression must not refer to any non-deterministic function nor any\n** table other than iCur.\n*/\nint sqlite3ExprIsTableConstant(Expr *p, int iCur){\n  return exprIsConst(p, 3, iCur);\n}\n\n\n/*\n** sqlite3WalkExpr() callback used by sqlite3ExprIsConstantOrGroupBy().\n*/\nstatic int exprNodeIsConstantOrGroupBy(Walker *pWalker, Expr *pExpr){\n  ExprList *pGroupBy = pWalker->u.pGroupBy;\n  int i;\n\n  /* Check if pExpr is identical to any GROUP BY term. If so, consider\n  ** it constant.  */\n  for(i=0; i<pGroupBy->nExpr; i++){\n    Expr *p = pGroupBy->a[i].pExpr;\n    if( sqlite3ExprCompare(0, pExpr, p, -1)<2 ){\n      CollSeq *pColl = sqlite3ExprNNCollSeq(pWalker->pParse, p);\n      if( sqlite3IsBinary(pColl) ){\n        return WRC_Prune;\n      }\n    }\n  }\n\n  /* Check if pExpr is a sub-select. If so, consider it variable. */\n  if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n    pWalker->eCode = 0;\n    return WRC_Abort;\n  }\n\n  return exprNodeIsConstant(pWalker, pExpr);\n}\n\n/*\n** Walk the expression tree passed as the first argument. Return non-zero\n** if the expression consists entirely of constants or copies of terms \n** in pGroupBy that sort with the BINARY collation sequence.\n**\n** This routine is used to determine if a term of the HAVING clause can\n** be promoted into the WHERE clause.  In order for such a promotion to work,\n** the value of the HAVING clause term must be the same for all members of\n** a \"group\".  The requirement that the GROUP BY term must be BINARY\n** assumes that no other collating sequence will have a finer-grained\n** grouping than binary.  In other words (A=B COLLATE binary) implies\n** A=B in every other collating sequence.  The requirement that the\n** GROUP BY be BINARY is stricter than necessary.  It would also work\n** to promote HAVING clauses that use the same alternative collating\n** sequence as the GROUP BY term, but that is much harder to check,\n** alternative collating sequences are uncommon, and this is only an\n** optimization, so we take the easy way out and simply require the\n** GROUP BY to use the BINARY collating sequence.\n*/\nint sqlite3ExprIsConstantOrGroupBy(Parse *pParse, Expr *p, ExprList *pGroupBy){\n  Walker w;\n  w.eCode = 1;\n  w.xExprCallback = exprNodeIsConstantOrGroupBy;\n  w.xSelectCallback = 0;\n  w.u.pGroupBy = pGroupBy;\n  w.pParse = pParse;\n  sqlite3WalkExpr(&w, p);\n  return w.eCode;\n}\n\n/*\n** Walk an expression tree.  Return non-zero if the expression is constant\n** or a function call with constant arguments.  Return and 0 if there\n** are any variables.\n**\n** For the purposes of this function, a double-quoted string (ex: \"abc\")\n** is considered a variable but a single-quoted string (ex: 'abc') is\n** a constant.\n*/\nint sqlite3ExprIsConstantOrFunction(Expr *p, u8 isInit){\n  assert( isInit==0 || isInit==1 );\n  return exprIsConst(p, 4+isInit, 0);\n}\n\n#ifdef SQLITE_ENABLE_CURSOR_HINTS\n/*\n** Walk an expression tree.  Return 1 if the expression contains a\n** subquery of some kind.  Return 0 if there are no subqueries.\n*/\nint sqlite3ExprContainsSubquery(Expr *p){\n  Walker w;\n  w.eCode = 1;\n  w.xExprCallback = sqlite3ExprWalkNoop;\n  w.xSelectCallback = sqlite3SelectWalkFail;\n#ifdef SQLITE_DEBUG\n  w.xSelectCallback2 = sqlite3SelectWalkAssert2;\n#endif\n  sqlite3WalkExpr(&w, p);\n  return w.eCode==0;\n}\n#endif\n\n/*\n** If the expression p codes a constant integer that is small enough\n** to fit in a 32-bit integer, return 1 and put the value of the integer\n** in *pValue.  If the expression is not an integer or if it is too big\n** to fit in a signed 32-bit integer, return 0 and leave *pValue unchanged.\n*/\nint sqlite3ExprIsInteger(Expr *p, int *pValue){\n  int rc = 0;\n  if( NEVER(p==0) ) return 0;  /* Used to only happen following on OOM */\n\n  /* If an expression is an integer literal that fits in a signed 32-bit\n  ** integer, then the EP_IntValue flag will have already been set */\n  assert( p->op!=TK_INTEGER || (p->flags & EP_IntValue)!=0\n           || sqlite3GetInt32(p->u.zToken, &rc)==0 );\n\n  if( p->flags & EP_IntValue ){\n    *pValue = p->u.iValue;\n    return 1;\n  }\n  switch( p->op ){\n    case TK_UPLUS: {\n      rc = sqlite3ExprIsInteger(p->pLeft, pValue);\n      break;\n    }\n    case TK_UMINUS: {\n      int v;\n      if( sqlite3ExprIsInteger(p->pLeft, &v) ){\n        assert( v!=(-2147483647-1) );\n        *pValue = -v;\n        rc = 1;\n      }\n      break;\n    }\n    default: break;\n  }\n  return rc;\n}\n\n/*\n** Return FALSE if there is no chance that the expression can be NULL.\n**\n** If the expression might be NULL or if the expression is too complex\n** to tell return TRUE.  \n**\n** This routine is used as an optimization, to skip OP_IsNull opcodes\n** when we know that a value cannot be NULL.  Hence, a false positive\n** (returning TRUE when in fact the expression can never be NULL) might\n** be a small performance hit but is otherwise harmless.  On the other\n** hand, a false negative (returning FALSE when the result could be NULL)\n** will likely result in an incorrect answer.  So when in doubt, return\n** TRUE.\n*/\nint sqlite3ExprCanBeNull(const Expr *p){\n  u8 op;\n  while( p->op==TK_UPLUS || p->op==TK_UMINUS ){\n    p = p->pLeft;\n  }\n  op = p->op;\n  if( op==TK_REGISTER ) op = p->op2;\n  switch( op ){\n    case TK_INTEGER:\n    case TK_STRING:\n    case TK_FLOAT:\n    case TK_BLOB:\n      return 0;\n    case TK_COLUMN:\n      return ExprHasProperty(p, EP_CanBeNull) ||\n             p->y.pTab==0 ||  /* Reference to column of index on expression */\n             (p->iColumn>=0 && p->y.pTab->aCol[p->iColumn].notNull==0);\n    default:\n      return 1;\n  }\n}\n\n/*\n** Return TRUE if the given expression is a constant which would be\n** unchanged by OP_Affinity with the affinity given in the second\n** argument.\n**\n** This routine is used to determine if the OP_Affinity operation\n** can be omitted.  When in doubt return FALSE.  A false negative\n** is harmless.  A false positive, however, can result in the wrong\n** answer.\n*/\nint sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff){\n  u8 op;\n  int unaryMinus = 0;\n  if( aff==SQLITE_AFF_BLOB ) return 1;\n  while( p->op==TK_UPLUS || p->op==TK_UMINUS ){\n    if( p->op==TK_UMINUS ) unaryMinus = 1;\n    p = p->pLeft;\n  }\n  op = p->op;\n  if( op==TK_REGISTER ) op = p->op2;\n  switch( op ){\n    case TK_INTEGER: {\n      return aff>=SQLITE_AFF_NUMERIC;\n    }\n    case TK_FLOAT: {\n      return aff>=SQLITE_AFF_NUMERIC;\n    }\n    case TK_STRING: {\n      return !unaryMinus && aff==SQLITE_AFF_TEXT;\n    }\n    case TK_BLOB: {\n      return !unaryMinus;\n    }\n    case TK_COLUMN: {\n      assert( p->iTable>=0 );  /* p cannot be part of a CHECK constraint */\n      return aff>=SQLITE_AFF_NUMERIC && p->iColumn<0;\n    }\n    default: {\n      return 0;\n    }\n  }\n}\n\n/*\n** Return TRUE if the given string is a row-id column name.\n*/\nint sqlite3IsRowid(const char *z){\n  if( sqlite3StrICmp(z, \"_ROWID_\")==0 ) return 1;\n  if( sqlite3StrICmp(z, \"ROWID\")==0 ) return 1;\n  if( sqlite3StrICmp(z, \"OID\")==0 ) return 1;\n  return 0;\n}\n\n/*\n** pX is the RHS of an IN operator.  If pX is a SELECT statement \n** that can be simplified to a direct table access, then return\n** a pointer to the SELECT statement.  If pX is not a SELECT statement,\n** or if the SELECT statement needs to be manifested into a transient\n** table, then return NULL.\n*/\n#ifndef SQLITE_OMIT_SUBQUERY\nstatic Select *isCandidateForInOpt(Expr *pX){\n  Select *p;\n  SrcList *pSrc;\n  ExprList *pEList;\n  Table *pTab;\n  int i;\n  if( !ExprHasProperty(pX, EP_xIsSelect) ) return 0;  /* Not a subquery */\n  if( ExprHasProperty(pX, EP_VarSelect)  ) return 0;  /* Correlated subq */\n  p = pX->x.pSelect;\n  if( p->pPrior ) return 0;              /* Not a compound SELECT */\n  if( p->selFlags & (SF_Distinct|SF_Aggregate) ){\n    testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );\n    testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );\n    return 0; /* No DISTINCT keyword and no aggregate functions */\n  }\n  assert( p->pGroupBy==0 );              /* Has no GROUP BY clause */\n  if( p->pLimit ) return 0;              /* Has no LIMIT clause */\n  if( p->pWhere ) return 0;              /* Has no WHERE clause */\n  pSrc = p->pSrc;\n  assert( pSrc!=0 );\n  if( pSrc->nSrc!=1 ) return 0;          /* Single term in FROM clause */\n  if( pSrc->a[0].pSelect ) return 0;     /* FROM is not a subquery or view */\n  pTab = pSrc->a[0].pTab;\n  assert( pTab!=0 );\n  assert( pTab->pSelect==0 );            /* FROM clause is not a view */\n  if( IsVirtual(pTab) ) return 0;        /* FROM clause not a virtual table */\n  pEList = p->pEList;\n  assert( pEList!=0 );\n  /* All SELECT results must be columns. */\n  for(i=0; i<pEList->nExpr; i++){\n    Expr *pRes = pEList->a[i].pExpr;\n    if( pRes->op!=TK_COLUMN ) return 0;\n    assert( pRes->iTable==pSrc->a[0].iCursor );  /* Not a correlated subquery */\n  }\n  return p;\n}\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Generate code that checks the left-most column of index table iCur to see if\n** it contains any NULL entries.  Cause the register at regHasNull to be set\n** to a non-NULL value if iCur contains no NULLs.  Cause register regHasNull\n** to be set to NULL if iCur contains one or more NULL values.\n*/\nstatic void sqlite3SetHasNullFlag(Vdbe *v, int iCur, int regHasNull){\n  int addr1;\n  sqlite3VdbeAddOp2(v, OP_Integer, 0, regHasNull);\n  addr1 = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);\n  sqlite3VdbeAddOp3(v, OP_Column, iCur, 0, regHasNull);\n  sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n  VdbeComment((v, \"first_entry_in(%d)\", iCur));\n  sqlite3VdbeJumpHere(v, addr1);\n}\n#endif\n\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** The argument is an IN operator with a list (not a subquery) on the \n** right-hand side.  Return TRUE if that list is constant.\n*/\nstatic int sqlite3InRhsIsConstant(Expr *pIn){\n  Expr *pLHS;\n  int res;\n  assert( !ExprHasProperty(pIn, EP_xIsSelect) );\n  pLHS = pIn->pLeft;\n  pIn->pLeft = 0;\n  res = sqlite3ExprIsConstant(pIn);\n  pIn->pLeft = pLHS;\n  return res;\n}\n#endif\n\n/*\n** This function is used by the implementation of the IN (...) operator.\n** The pX parameter is the expression on the RHS of the IN operator, which\n** might be either a list of expressions or a subquery.\n**\n** The job of this routine is to find or create a b-tree object that can\n** be used either to test for membership in the RHS set or to iterate through\n** all members of the RHS set, skipping duplicates.\n**\n** A cursor is opened on the b-tree object that is the RHS of the IN operator\n** and pX->iTable is set to the index of that cursor.\n**\n** The returned value of this function indicates the b-tree type, as follows:\n**\n**   IN_INDEX_ROWID      - The cursor was opened on a database table.\n**   IN_INDEX_INDEX_ASC  - The cursor was opened on an ascending index.\n**   IN_INDEX_INDEX_DESC - The cursor was opened on a descending index.\n**   IN_INDEX_EPH        - The cursor was opened on a specially created and\n**                         populated epheremal table.\n**   IN_INDEX_NOOP       - No cursor was allocated.  The IN operator must be\n**                         implemented as a sequence of comparisons.\n**\n** An existing b-tree might be used if the RHS expression pX is a simple\n** subquery such as:\n**\n**     SELECT <column1>, <column2>... FROM <table>\n**\n** If the RHS of the IN operator is a list or a more complex subquery, then\n** an ephemeral table might need to be generated from the RHS and then\n** pX->iTable made to point to the ephemeral table instead of an\n** existing table.\n**\n** The inFlags parameter must contain, at a minimum, one of the bits\n** IN_INDEX_MEMBERSHIP or IN_INDEX_LOOP but not both.  If inFlags contains\n** IN_INDEX_MEMBERSHIP, then the generated table will be used for a fast\n** membership test.  When the IN_INDEX_LOOP bit is set, the IN index will\n** be used to loop over all values of the RHS of the IN operator.\n**\n** When IN_INDEX_LOOP is used (and the b-tree will be used to iterate\n** through the set members) then the b-tree must not contain duplicates.\n** An epheremal table will be created unless the selected columns are guaranteed\n** to be unique - either because it is an INTEGER PRIMARY KEY or due to\n** a UNIQUE constraint or index.\n**\n** When IN_INDEX_MEMBERSHIP is used (and the b-tree will be used \n** for fast set membership tests) then an epheremal table must \n** be used unless <columns> is a single INTEGER PRIMARY KEY column or an \n** index can be found with the specified <columns> as its left-most.\n**\n** If the IN_INDEX_NOOP_OK and IN_INDEX_MEMBERSHIP are both set and\n** if the RHS of the IN operator is a list (not a subquery) then this\n** routine might decide that creating an ephemeral b-tree for membership\n** testing is too expensive and return IN_INDEX_NOOP.  In that case, the\n** calling routine should implement the IN operator using a sequence\n** of Eq or Ne comparison operations.\n**\n** When the b-tree is being used for membership tests, the calling function\n** might need to know whether or not the RHS side of the IN operator\n** contains a NULL.  If prRhsHasNull is not a NULL pointer and \n** if there is any chance that the (...) might contain a NULL value at\n** runtime, then a register is allocated and the register number written\n** to *prRhsHasNull. If there is no chance that the (...) contains a\n** NULL value, then *prRhsHasNull is left unchanged.\n**\n** If a register is allocated and its location stored in *prRhsHasNull, then\n** the value in that register will be NULL if the b-tree contains one or more\n** NULL values, and it will be some non-NULL value if the b-tree contains no\n** NULL values.\n**\n** If the aiMap parameter is not NULL, it must point to an array containing\n** one element for each column returned by the SELECT statement on the RHS\n** of the IN(...) operator. The i'th entry of the array is populated with the\n** offset of the index column that matches the i'th column returned by the\n** SELECT. For example, if the expression and selected index are:\n**\n**   (?,?,?) IN (SELECT a, b, c FROM t1)\n**   CREATE INDEX i1 ON t1(b, c, a);\n**\n** then aiMap[] is populated with {2, 0, 1}.\n*/\n#ifndef SQLITE_OMIT_SUBQUERY\nint sqlite3FindInIndex(\n  Parse *pParse,             /* Parsing context */\n  Expr *pX,                  /* The IN expression */\n  u32 inFlags,               /* IN_INDEX_LOOP, _MEMBERSHIP, and/or _NOOP_OK */\n  int *prRhsHasNull,         /* Register holding NULL status.  See notes */\n  int *aiMap,                /* Mapping from Index fields to RHS fields */\n  int *piTab                 /* OUT: index to use */\n){\n  Select *p;                            /* SELECT to the right of IN operator */\n  int eType = 0;                        /* Type of RHS table. IN_INDEX_* */\n  int iTab = pParse->nTab++;            /* Cursor of the RHS table */\n  int mustBeUnique;                     /* True if RHS must be unique */\n  Vdbe *v = sqlite3GetVdbe(pParse);     /* Virtual machine being coded */\n\n  assert( pX->op==TK_IN );\n  mustBeUnique = (inFlags & IN_INDEX_LOOP)!=0;\n\n  /* If the RHS of this IN(...) operator is a SELECT, and if it matters \n  ** whether or not the SELECT result contains NULL values, check whether\n  ** or not NULL is actually possible (it may not be, for example, due \n  ** to NOT NULL constraints in the schema). If no NULL values are possible,\n  ** set prRhsHasNull to 0 before continuing.  */\n  if( prRhsHasNull && (pX->flags & EP_xIsSelect) ){\n    int i;\n    ExprList *pEList = pX->x.pSelect->pEList;\n    for(i=0; i<pEList->nExpr; i++){\n      if( sqlite3ExprCanBeNull(pEList->a[i].pExpr) ) break;\n    }\n    if( i==pEList->nExpr ){\n      prRhsHasNull = 0;\n    }\n  }\n\n  /* Check to see if an existing table or index can be used to\n  ** satisfy the query.  This is preferable to generating a new \n  ** ephemeral table.  */\n  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){\n    sqlite3 *db = pParse->db;              /* Database connection */\n    Table *pTab;                           /* Table <table>. */\n    i16 iDb;                               /* Database idx for pTab */\n    ExprList *pEList = p->pEList;\n    int nExpr = pEList->nExpr;\n\n    assert( p->pEList!=0 );             /* Because of isCandidateForInOpt(p) */\n    assert( p->pEList->a[0].pExpr!=0 ); /* Because of isCandidateForInOpt(p) */\n    assert( p->pSrc!=0 );               /* Because of isCandidateForInOpt(p) */\n    pTab = p->pSrc->a[0].pTab;\n\n    /* Code an OP_Transaction and OP_TableLock for <table>. */\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    sqlite3CodeVerifySchema(pParse, iDb);\n    sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n    assert(v);  /* sqlite3GetVdbe() has always been previously called */\n    if( nExpr==1 && pEList->a[0].pExpr->iColumn<0 ){\n      /* The \"x IN (SELECT rowid FROM table)\" case */\n      int iAddr = sqlite3VdbeAddOp0(v, OP_Once);\n      VdbeCoverage(v);\n\n      sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);\n      eType = IN_INDEX_ROWID;\n      ExplainQueryPlan((pParse, 0,\n            \"USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR\",pTab->zName));\n      sqlite3VdbeJumpHere(v, iAddr);\n    }else{\n      Index *pIdx;                         /* Iterator variable */\n      int affinity_ok = 1;\n      int i;\n\n      /* Check that the affinity that will be used to perform each \n      ** comparison is the same as the affinity of each column in table\n      ** on the RHS of the IN operator.  If it not, it is not possible to\n      ** use any index of the RHS table.  */\n      for(i=0; i<nExpr && affinity_ok; i++){\n        Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);\n        int iCol = pEList->a[i].pExpr->iColumn;\n        char idxaff = sqlite3TableColumnAffinity(pTab,iCol); /* RHS table */\n        char cmpaff = sqlite3CompareAffinity(pLhs, idxaff);\n        testcase( cmpaff==SQLITE_AFF_BLOB );\n        testcase( cmpaff==SQLITE_AFF_TEXT );\n        switch( cmpaff ){\n          case SQLITE_AFF_BLOB:\n            break;\n          case SQLITE_AFF_TEXT:\n            /* sqlite3CompareAffinity() only returns TEXT if one side or the\n            ** other has no affinity and the other side is TEXT.  Hence,\n            ** the only way for cmpaff to be TEXT is for idxaff to be TEXT\n            ** and for the term on the LHS of the IN to have no affinity. */\n            assert( idxaff==SQLITE_AFF_TEXT );\n            break;\n          default:\n            affinity_ok = sqlite3IsNumericAffinity(idxaff);\n        }\n      }\n\n      if( affinity_ok ){\n        /* Search for an existing index that will work for this IN operator */\n        for(pIdx=pTab->pIndex; pIdx && eType==0; pIdx=pIdx->pNext){\n          Bitmask colUsed;      /* Columns of the index used */\n          Bitmask mCol;         /* Mask for the current column */\n          if( pIdx->nColumn<nExpr ) continue;\n          if( pIdx->pPartIdxWhere!=0 ) continue;\n          /* Maximum nColumn is BMS-2, not BMS-1, so that we can compute\n          ** BITMASK(nExpr) without overflowing */\n          testcase( pIdx->nColumn==BMS-2 );\n          testcase( pIdx->nColumn==BMS-1 );\n          if( pIdx->nColumn>=BMS-1 ) continue;\n          if( mustBeUnique ){\n            if( pIdx->nKeyCol>nExpr\n             ||(pIdx->nColumn>nExpr && !IsUniqueIndex(pIdx))\n            ){\n              continue;  /* This index is not unique over the IN RHS columns */\n            }\n          }\n  \n          colUsed = 0;   /* Columns of index used so far */\n          for(i=0; i<nExpr; i++){\n            Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);\n            Expr *pRhs = pEList->a[i].pExpr;\n            CollSeq *pReq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);\n            int j;\n  \n            assert( pReq!=0 || pRhs->iColumn==XN_ROWID || pParse->nErr );\n            for(j=0; j<nExpr; j++){\n              if( pIdx->aiColumn[j]!=pRhs->iColumn ) continue;\n              assert( pIdx->azColl[j] );\n              if( pReq!=0 && sqlite3StrICmp(pReq->zName, pIdx->azColl[j])!=0 ){\n                continue;\n              }\n              break;\n            }\n            if( j==nExpr ) break;\n            mCol = MASKBIT(j);\n            if( mCol & colUsed ) break; /* Each column used only once */\n            colUsed |= mCol;\n            if( aiMap ) aiMap[i] = j;\n          }\n  \n          assert( i==nExpr || colUsed!=(MASKBIT(nExpr)-1) );\n          if( colUsed==(MASKBIT(nExpr)-1) ){\n            /* If we reach this point, that means the index pIdx is usable */\n            int iAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n            ExplainQueryPlan((pParse, 0,\n                              \"USING INDEX %s FOR IN-OPERATOR\",pIdx->zName));\n            sqlite3VdbeAddOp3(v, OP_OpenRead, iTab, pIdx->tnum, iDb);\n            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n            VdbeComment((v, \"%s\", pIdx->zName));\n            assert( IN_INDEX_INDEX_DESC == IN_INDEX_INDEX_ASC+1 );\n            eType = IN_INDEX_INDEX_ASC + pIdx->aSortOrder[0];\n  \n            if( prRhsHasNull ){\n#ifdef SQLITE_ENABLE_COLUMN_USED_MASK\n              i64 mask = (1<<nExpr)-1;\n              sqlite3VdbeAddOp4Dup8(v, OP_ColumnsUsed, \n                  iTab, 0, 0, (u8*)&mask, P4_INT64);\n#endif\n              *prRhsHasNull = ++pParse->nMem;\n              if( nExpr==1 ){\n                sqlite3SetHasNullFlag(v, iTab, *prRhsHasNull);\n              }\n            }\n            sqlite3VdbeJumpHere(v, iAddr);\n          }\n        } /* End loop over indexes */\n      } /* End if( affinity_ok ) */\n    } /* End if not an rowid index */\n  } /* End attempt to optimize using an index */\n\n  /* If no preexisting index is available for the IN clause\n  ** and IN_INDEX_NOOP is an allowed reply\n  ** and the RHS of the IN operator is a list, not a subquery\n  ** and the RHS is not constant or has two or fewer terms,\n  ** then it is not worth creating an ephemeral table to evaluate\n  ** the IN operator so return IN_INDEX_NOOP.\n  */\n  if( eType==0\n   && (inFlags & IN_INDEX_NOOP_OK)\n   && !ExprHasProperty(pX, EP_xIsSelect)\n   && (!sqlite3InRhsIsConstant(pX) || pX->x.pList->nExpr<=2)\n  ){\n    eType = IN_INDEX_NOOP;\n  }\n\n  if( eType==0 ){\n    /* Could not find an existing table or index to use as the RHS b-tree.\n    ** We will have to generate an ephemeral table to do the job.\n    */\n    u32 savedNQueryLoop = pParse->nQueryLoop;\n    int rMayHaveNull = 0;\n    eType = IN_INDEX_EPH;\n    if( inFlags & IN_INDEX_LOOP ){\n      pParse->nQueryLoop = 0;\n    }else if( prRhsHasNull ){\n      *prRhsHasNull = rMayHaveNull = ++pParse->nMem;\n    }\n    assert( pX->op==TK_IN );\n    sqlite3CodeRhsOfIN(pParse, pX, iTab);\n    if( rMayHaveNull ){\n      sqlite3SetHasNullFlag(v, iTab, rMayHaveNull);\n    }\n    pParse->nQueryLoop = savedNQueryLoop;\n  }\n\n  if( aiMap && eType!=IN_INDEX_INDEX_ASC && eType!=IN_INDEX_INDEX_DESC ){\n    int i, n;\n    n = sqlite3ExprVectorSize(pX->pLeft);\n    for(i=0; i<n; i++) aiMap[i] = i;\n  }\n  *piTab = iTab;\n  return eType;\n}\n#endif\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Argument pExpr is an (?, ?...) IN(...) expression. This \n** function allocates and returns a nul-terminated string containing \n** the affinities to be used for each column of the comparison.\n**\n** It is the responsibility of the caller to ensure that the returned\n** string is eventually freed using sqlite3DbFree().\n*/\nstatic char *exprINAffinity(Parse *pParse, Expr *pExpr){\n  Expr *pLeft = pExpr->pLeft;\n  int nVal = sqlite3ExprVectorSize(pLeft);\n  Select *pSelect = (pExpr->flags & EP_xIsSelect) ? pExpr->x.pSelect : 0;\n  char *zRet;\n\n  assert( pExpr->op==TK_IN );\n  zRet = sqlite3DbMallocRaw(pParse->db, nVal+1);\n  if( zRet ){\n    int i;\n    for(i=0; i<nVal; i++){\n      Expr *pA = sqlite3VectorFieldSubexpr(pLeft, i);\n      char a = sqlite3ExprAffinity(pA);\n      if( pSelect ){\n        zRet[i] = sqlite3CompareAffinity(pSelect->pEList->a[i].pExpr, a);\n      }else{\n        zRet[i] = a;\n      }\n    }\n    zRet[nVal] = '\\0';\n  }\n  return zRet;\n}\n#endif\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Load the Parse object passed as the first argument with an error \n** message of the form:\n**\n**   \"sub-select returns N columns - expected M\"\n*/   \nvoid sqlite3SubselectError(Parse *pParse, int nActual, int nExpect){\n  const char *zFmt = \"sub-select returns %d columns - expected %d\";\n  sqlite3ErrorMsg(pParse, zFmt, nActual, nExpect);\n}\n#endif\n\n/*\n** Expression pExpr is a vector that has been used in a context where\n** it is not permitted. If pExpr is a sub-select vector, this routine \n** loads the Parse object with a message of the form:\n**\n**   \"sub-select returns N columns - expected 1\"\n**\n** Or, if it is a regular scalar vector:\n**\n**   \"row value misused\"\n*/   \nvoid sqlite3VectorErrorMsg(Parse *pParse, Expr *pExpr){\n#ifndef SQLITE_OMIT_SUBQUERY\n  if( pExpr->flags & EP_xIsSelect ){\n    sqlite3SubselectError(pParse, pExpr->x.pSelect->pEList->nExpr, 1);\n  }else\n#endif\n  {\n    sqlite3ErrorMsg(pParse, \"row value misused\");\n  }\n}\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Generate code that will construct an ephemeral table containing all terms\n** in the RHS of an IN operator.  The IN operator can be in either of two\n** forms:\n**\n**     x IN (4,5,11)              -- IN operator with list on right-hand side\n**     x IN (SELECT a FROM b)     -- IN operator with subquery on the right\n**\n** The pExpr parameter is the IN operator.  The cursor number for the\n** constructed ephermeral table is returned.  The first time the ephemeral\n** table is computed, the cursor number is also stored in pExpr->iTable,\n** however the cursor number returned might not be the same, as it might\n** have been duplicated using OP_OpenDup.\n**\n** If the LHS expression (\"x\" in the examples) is a column value, or\n** the SELECT statement returns a column value, then the affinity of that\n** column is used to build the index keys. If both 'x' and the\n** SELECT... statement are columns, then numeric affinity is used\n** if either column has NUMERIC or INTEGER affinity. If neither\n** 'x' nor the SELECT... statement are columns, then numeric affinity\n** is used.\n*/\nvoid sqlite3CodeRhsOfIN(\n  Parse *pParse,          /* Parsing context */\n  Expr *pExpr,            /* The IN operator */\n  int iTab                /* Use this cursor number */\n){\n  int addrOnce = 0;           /* Address of the OP_Once instruction at top */\n  int addr;                   /* Address of OP_OpenEphemeral instruction */\n  Expr *pLeft;                /* the LHS of the IN operator */\n  KeyInfo *pKeyInfo = 0;      /* Key information */\n  int nVal;                   /* Size of vector pLeft */\n  Vdbe *v;                    /* The prepared statement under construction */\n\n  v = pParse->pVdbe;\n  assert( v!=0 );\n\n  /* The evaluation of the IN must be repeated every time it\n  ** is encountered if any of the following is true:\n  **\n  **    *  The right-hand side is a correlated subquery\n  **    *  The right-hand side is an expression list containing variables\n  **    *  We are inside a trigger\n  **\n  ** If all of the above are false, then we can compute the RHS just once\n  ** and reuse it many names.\n  */\n  if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){\n    /* Reuse of the RHS is allowed */\n    /* If this routine has already been coded, but the previous code\n    ** might not have been invoked yet, so invoke it now as a subroutine. \n    */\n    if( ExprHasProperty(pExpr, EP_Subrtn) ){\n      addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n      if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n        ExplainQueryPlan((pParse, 0, \"REUSE LIST SUBQUERY %d\",\n              pExpr->x.pSelect->selId));\n      }\n      sqlite3VdbeAddOp2(v, OP_Gosub, pExpr->y.sub.regReturn,\n                        pExpr->y.sub.iAddr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, iTab, pExpr->iTable);\n      sqlite3VdbeJumpHere(v, addrOnce);\n      return;\n    }\n\n    /* Begin coding the subroutine */\n    ExprSetProperty(pExpr, EP_Subrtn);\n    pExpr->y.sub.regReturn = ++pParse->nMem;\n    pExpr->y.sub.iAddr =\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr->y.sub.regReturn) + 1;\n    VdbeComment((v, \"return address\"));\n\n    addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n  }\n\n  /* Check to see if this is a vector IN operator */\n  pLeft = pExpr->pLeft;\n  nVal = sqlite3ExprVectorSize(pLeft);\n\n  /* Construct the ephemeral table that will contain the content of\n  ** RHS of the IN operator.\n  */\n  pExpr->iTable = iTab;\n  addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pExpr->iTable, nVal);\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n  if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n    VdbeComment((v, \"Result of SELECT %u\", pExpr->x.pSelect->selId));\n  }else{\n    VdbeComment((v, \"RHS of IN operator\"));\n  }\n#endif\n  pKeyInfo = sqlite3KeyInfoAlloc(pParse->db, nVal, 1);\n\n  if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n    /* Case 1:     expr IN (SELECT ...)\n    **\n    ** Generate code to write the results of the select into the temporary\n    ** table allocated and opened above.\n    */\n    Select *pSelect = pExpr->x.pSelect;\n    ExprList *pEList = pSelect->pEList;\n\n    ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY %d\",\n        addrOnce?\"\":\"CORRELATED \", pSelect->selId\n    ));\n    /* If the LHS and RHS of the IN operator do not match, that\n    ** error will have been caught long before we reach this point. */\n    if( ALWAYS(pEList->nExpr==nVal) ){\n      SelectDest dest;\n      int i;\n      sqlite3SelectDestInit(&dest, SRT_Set, iTab);\n      dest.zAffSdst = exprINAffinity(pParse, pExpr);\n      pSelect->iLimit = 0;\n      testcase( pSelect->selFlags & SF_Distinct );\n      testcase( pKeyInfo==0 ); /* Caused by OOM in sqlite3KeyInfoAlloc() */\n      if( sqlite3Select(pParse, pSelect, &dest) ){\n        sqlite3DbFree(pParse->db, dest.zAffSdst);\n        sqlite3KeyInfoUnref(pKeyInfo);\n        return;\n      }\n      sqlite3DbFree(pParse->db, dest.zAffSdst);\n      assert( pKeyInfo!=0 ); /* OOM will cause exit after sqlite3Select() */\n      assert( pEList!=0 );\n      assert( pEList->nExpr>0 );\n      assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );\n      for(i=0; i<nVal; i++){\n        Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);\n        pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(\n            pParse, p, pEList->a[i].pExpr\n        );\n      }\n    }\n  }else if( ALWAYS(pExpr->x.pList!=0) ){\n    /* Case 2:     expr IN (exprlist)\n    **\n    ** For each expression, build an index key from the evaluation and\n    ** store it in the temporary table. If <expr> is a column, then use\n    ** that columns affinity when building index keys. If <expr> is not\n    ** a column, use numeric affinity.\n    */\n    char affinity;            /* Affinity of the LHS of the IN */\n    int i;\n    ExprList *pList = pExpr->x.pList;\n    struct ExprList_item *pItem;\n    int r1, r2;\n    affinity = sqlite3ExprAffinity(pLeft);\n    if( affinity<=SQLITE_AFF_NONE ){\n      affinity = SQLITE_AFF_BLOB;\n    }\n    if( pKeyInfo ){\n      assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );\n      pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n    }\n\n    /* Loop through each expression in <exprlist>. */\n    r1 = sqlite3GetTempReg(pParse);\n    r2 = sqlite3GetTempReg(pParse);\n    for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){\n      Expr *pE2 = pItem->pExpr;\n\n      /* If the expression is not constant then we will need to\n      ** disable the test that was generated above that makes sure\n      ** this code only executes once.  Because for a non-constant\n      ** expression we need to rerun this code each time.\n      */\n      if( addrOnce && !sqlite3ExprIsConstant(pE2) ){\n        sqlite3VdbeChangeToNoop(v, addrOnce);\n        ExprClearProperty(pExpr, EP_Subrtn);\n        addrOnce = 0;\n      }\n\n      /* Evaluate the expression and insert it into the temp table */\n      sqlite3ExprCode(pParse, pE2, r1);\n      sqlite3VdbeAddOp4(v, OP_MakeRecord, r1, 1, r2, &affinity, 1);\n      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r2, r1, 1);\n    }\n    sqlite3ReleaseTempReg(pParse, r1);\n    sqlite3ReleaseTempReg(pParse, r2);\n  }\n  if( pKeyInfo ){\n    sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);\n  }\n  if( addrOnce ){\n    sqlite3VdbeJumpHere(v, addrOnce);\n    /* Subroutine return */\n    sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);\n    sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);\n    sqlite3ClearTempRegCache(pParse);\n  }\n}\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n/*\n** Generate code for scalar subqueries used as a subquery expression\n** or EXISTS operator:\n**\n**     (SELECT a FROM b)          -- subquery\n**     EXISTS (SELECT a FROM b)   -- EXISTS subquery\n**\n** The pExpr parameter is the SELECT or EXISTS operator to be coded.\n**\n** Return the register that holds the result.  For a multi-column SELECT, \n** the result is stored in a contiguous array of registers and the\n** return value is the register of the left-most result column.\n** Return 0 if an error occurs.\n*/\n#ifndef SQLITE_OMIT_SUBQUERY\nint sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){\n  int addrOnce = 0;           /* Address of OP_Once at top of subroutine */\n  int rReg = 0;               /* Register storing resulting */\n  Select *pSel;               /* SELECT statement to encode */\n  SelectDest dest;            /* How to deal with SELECT result */\n  int nReg;                   /* Registers to allocate */\n  Expr *pLimit;               /* New limit expression */\n\n  Vdbe *v = pParse->pVdbe;\n  assert( v!=0 );\n  testcase( pExpr->op==TK_EXISTS );\n  testcase( pExpr->op==TK_SELECT );\n  assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );\n  assert( ExprHasProperty(pExpr, EP_xIsSelect) );\n  pSel = pExpr->x.pSelect;\n\n  /* The evaluation of the EXISTS/SELECT must be repeated every time it\n  ** is encountered if any of the following is true:\n  **\n  **    *  The right-hand side is a correlated subquery\n  **    *  The right-hand side is an expression list containing variables\n  **    *  We are inside a trigger\n  **\n  ** If all of the above are false, then we can run this code just once\n  ** save the results, and reuse the same result on subsequent invocations.\n  */\n  if( !ExprHasProperty(pExpr, EP_VarSelect) ){\n    /* If this routine has already been coded, then invoke it as a\n    ** subroutine. */\n    if( ExprHasProperty(pExpr, EP_Subrtn) ){\n      ExplainQueryPlan((pParse, 0, \"REUSE SUBQUERY %d\", pSel->selId));\n      sqlite3VdbeAddOp2(v, OP_Gosub, pExpr->y.sub.regReturn,\n                        pExpr->y.sub.iAddr);\n      return pExpr->iTable;\n    }\n\n    /* Begin coding the subroutine */\n    ExprSetProperty(pExpr, EP_Subrtn);\n    pExpr->y.sub.regReturn = ++pParse->nMem;\n    pExpr->y.sub.iAddr =\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr->y.sub.regReturn) + 1;\n    VdbeComment((v, \"return address\"));\n\n    addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n  }\n  \n  /* For a SELECT, generate code to put the values for all columns of\n  ** the first row into an array of registers and return the index of\n  ** the first register.\n  **\n  ** If this is an EXISTS, write an integer 0 (not exists) or 1 (exists)\n  ** into a register and return that register number.\n  **\n  ** In both cases, the query is augmented with \"LIMIT 1\".  Any \n  ** preexisting limit is discarded in place of the new LIMIT 1.\n  */\n  ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY %d\",\n        addrOnce?\"\":\"CORRELATED \", pSel->selId));\n  nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;\n  sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);\n  pParse->nMem += nReg;\n  if( pExpr->op==TK_SELECT ){\n    dest.eDest = SRT_Mem;\n    dest.iSdst = dest.iSDParm;\n    dest.nSdst = nReg;\n    sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);\n    VdbeComment((v, \"Init subquery result\"));\n  }else{\n    dest.eDest = SRT_Exists;\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);\n    VdbeComment((v, \"Init EXISTS result\"));\n  }\n  if( pSel->pLimit ){\n    /* The subquery already has a limit.  If the pre-existing limit is X\n    ** then make the new limit X<>0 so that the new limit is either 1 or 0 */\n    sqlite3 *db = pParse->db;\n    pLimit = sqlite3Expr(db, TK_INTEGER, \"0\");\n    if( pLimit ){\n      pLimit->affExpr = SQLITE_AFF_NUMERIC;\n      pLimit = sqlite3PExpr(pParse, TK_NE,\n                            sqlite3ExprDup(db, pSel->pLimit->pLeft, 0), pLimit);\n    }\n    sqlite3ExprDelete(db, pSel->pLimit->pLeft);\n    pSel->pLimit->pLeft = pLimit;\n  }else{\n    /* If there is no pre-existing limit add a limit of 1 */\n    pLimit = sqlite3Expr(pParse->db, TK_INTEGER, \"1\");\n    pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);\n  }\n  pSel->iLimit = 0;\n  if( sqlite3Select(pParse, pSel, &dest) ){\n    return 0;\n  }\n  pExpr->iTable = rReg = dest.iSDParm;\n  ExprSetVVAProperty(pExpr, EP_NoReduce);\n  if( addrOnce ){\n    sqlite3VdbeJumpHere(v, addrOnce);\n\n    /* Subroutine return */\n    sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);\n    sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);\n    sqlite3ClearTempRegCache(pParse);\n  }\n\n  return rReg;\n}\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Expr pIn is an IN(...) expression. This function checks that the \n** sub-select on the RHS of the IN() operator has the same number of \n** columns as the vector on the LHS. Or, if the RHS of the IN() is not \n** a sub-query, that the LHS is a vector of size 1.\n*/\nint sqlite3ExprCheckIN(Parse *pParse, Expr *pIn){\n  int nVector = sqlite3ExprVectorSize(pIn->pLeft);\n  if( (pIn->flags & EP_xIsSelect) ){\n    if( nVector!=pIn->x.pSelect->pEList->nExpr ){\n      sqlite3SubselectError(pParse, pIn->x.pSelect->pEList->nExpr, nVector);\n      return 1;\n    }\n  }else if( nVector!=1 ){\n    sqlite3VectorErrorMsg(pParse, pIn->pLeft);\n    return 1;\n  }\n  return 0;\n}\n#endif\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Generate code for an IN expression.\n**\n**      x IN (SELECT ...)\n**      x IN (value, value, ...)\n**\n** The left-hand side (LHS) is a scalar or vector expression.  The \n** right-hand side (RHS) is an array of zero or more scalar values, or a\n** subquery.  If the RHS is a subquery, the number of result columns must\n** match the number of columns in the vector on the LHS.  If the RHS is\n** a list of values, the LHS must be a scalar. \n**\n** The IN operator is true if the LHS value is contained within the RHS.\n** The result is false if the LHS is definitely not in the RHS.  The \n** result is NULL if the presence of the LHS in the RHS cannot be \n** determined due to NULLs.\n**\n** This routine generates code that jumps to destIfFalse if the LHS is not \n** contained within the RHS.  If due to NULLs we cannot determine if the LHS\n** is contained in the RHS then jump to destIfNull.  If the LHS is contained\n** within the RHS then fall through.\n**\n** See the separate in-operator.md documentation file in the canonical\n** SQLite source tree for additional information.\n*/\nstatic void sqlite3ExprCodeIN(\n  Parse *pParse,        /* Parsing and code generating context */\n  Expr *pExpr,          /* The IN expression */\n  int destIfFalse,      /* Jump here if LHS is not contained in the RHS */\n  int destIfNull        /* Jump here if the results are unknown due to NULLs */\n){\n  int rRhsHasNull = 0;  /* Register that is true if RHS contains NULL values */\n  int eType;            /* Type of the RHS */\n  int rLhs;             /* Register(s) holding the LHS values */\n  int rLhsOrig;         /* LHS values prior to reordering by aiMap[] */\n  Vdbe *v;              /* Statement under construction */\n  int *aiMap = 0;       /* Map from vector field to index column */\n  char *zAff = 0;       /* Affinity string for comparisons */\n  int nVector;          /* Size of vectors for this IN operator */\n  int iDummy;           /* Dummy parameter to exprCodeVector() */\n  Expr *pLeft;          /* The LHS of the IN operator */\n  int i;                /* loop counter */\n  int destStep2;        /* Where to jump when NULLs seen in step 2 */\n  int destStep6 = 0;    /* Start of code for Step 6 */\n  int addrTruthOp;      /* Address of opcode that determines the IN is true */\n  int destNotNull;      /* Jump here if a comparison is not true in step 6 */\n  int addrTop;          /* Top of the step-6 loop */ \n  int iTab = 0;         /* Index to use */\n\n  pLeft = pExpr->pLeft;\n  if( sqlite3ExprCheckIN(pParse, pExpr) ) return;\n  zAff = exprINAffinity(pParse, pExpr);\n  nVector = sqlite3ExprVectorSize(pExpr->pLeft);\n  aiMap = (int*)sqlite3DbMallocZero(\n      pParse->db, nVector*(sizeof(int) + sizeof(char)) + 1\n  );\n  if( pParse->db->mallocFailed ) goto sqlite3ExprCodeIN_oom_error;\n\n  /* Attempt to compute the RHS. After this step, if anything other than\n  ** IN_INDEX_NOOP is returned, the table opened with cursor iTab\n  ** contains the values that make up the RHS. If IN_INDEX_NOOP is returned,\n  ** the RHS has not yet been coded.  */\n  v = pParse->pVdbe;\n  assert( v!=0 );       /* OOM detected prior to this routine */\n  VdbeNoopComment((v, \"begin IN expr\"));\n  eType = sqlite3FindInIndex(pParse, pExpr,\n                             IN_INDEX_MEMBERSHIP | IN_INDEX_NOOP_OK,\n                             destIfFalse==destIfNull ? 0 : &rRhsHasNull,\n                             aiMap, &iTab);\n\n  assert( pParse->nErr || nVector==1 || eType==IN_INDEX_EPH\n       || eType==IN_INDEX_INDEX_ASC || eType==IN_INDEX_INDEX_DESC \n  );\n#ifdef SQLITE_DEBUG\n  /* Confirm that aiMap[] contains nVector integer values between 0 and\n  ** nVector-1. */\n  for(i=0; i<nVector; i++){\n    int j, cnt;\n    for(cnt=j=0; j<nVector; j++) if( aiMap[j]==i ) cnt++;\n    assert( cnt==1 );\n  }\n#endif\n\n  /* Code the LHS, the <expr> from \"<expr> IN (...)\". If the LHS is a \n  ** vector, then it is stored in an array of nVector registers starting \n  ** at r1.\n  **\n  ** sqlite3FindInIndex() might have reordered the fields of the LHS vector\n  ** so that the fields are in the same order as an existing index.   The\n  ** aiMap[] array contains a mapping from the original LHS field order to\n  ** the field order that matches the RHS index.\n  */\n  rLhsOrig = exprCodeVector(pParse, pLeft, &iDummy);\n  for(i=0; i<nVector && aiMap[i]==i; i++){} /* Are LHS fields reordered? */\n  if( i==nVector ){\n    /* LHS fields are not reordered */\n    rLhs = rLhsOrig;\n  }else{\n    /* Need to reorder the LHS fields according to aiMap */\n    rLhs = sqlite3GetTempRange(pParse, nVector);\n    for(i=0; i<nVector; i++){\n      sqlite3VdbeAddOp3(v, OP_Copy, rLhsOrig+i, rLhs+aiMap[i], 0);\n    }\n  }\n\n  /* If sqlite3FindInIndex() did not find or create an index that is\n  ** suitable for evaluating the IN operator, then evaluate using a\n  ** sequence of comparisons.\n  **\n  ** This is step (1) in the in-operator.md optimized algorithm.\n  */\n  if( eType==IN_INDEX_NOOP ){\n    ExprList *pList = pExpr->x.pList;\n    CollSeq *pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n    int labelOk = sqlite3VdbeMakeLabel(pParse);\n    int r2, regToFree;\n    int regCkNull = 0;\n    int ii;\n    int bLhsReal;  /* True if the LHS of the IN has REAL affinity */\n    assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n    if( destIfNull!=destIfFalse ){\n      regCkNull = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp3(v, OP_BitAnd, rLhs, rLhs, regCkNull);\n    }\n    bLhsReal = sqlite3ExprAffinity(pExpr->pLeft)==SQLITE_AFF_REAL;\n    for(ii=0; ii<pList->nExpr; ii++){\n      if( bLhsReal ){\n        r2 = regToFree = sqlite3GetTempReg(pParse);\n        sqlite3ExprCode(pParse, pList->a[ii].pExpr, r2);\n        sqlite3VdbeAddOp4(v, OP_Affinity, r2, 1, 0, \"E\", P4_STATIC);\n      }else{\n        r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);\n      }\n      if( regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr) ){\n        sqlite3VdbeAddOp3(v, OP_BitAnd, regCkNull, r2, regCkNull);\n      }\n      if( ii<pList->nExpr-1 || destIfNull!=destIfFalse ){\n        sqlite3VdbeAddOp4(v, OP_Eq, rLhs, labelOk, r2,\n                          (void*)pColl, P4_COLLSEQ);\n        VdbeCoverageIf(v, ii<pList->nExpr-1);\n        VdbeCoverageIf(v, ii==pList->nExpr-1);\n        sqlite3VdbeChangeP5(v, zAff[0]);\n      }else{\n        assert( destIfNull==destIfFalse );\n        sqlite3VdbeAddOp4(v, OP_Ne, rLhs, destIfFalse, r2,\n                          (void*)pColl, P4_COLLSEQ); VdbeCoverage(v);\n        sqlite3VdbeChangeP5(v, zAff[0] | SQLITE_JUMPIFNULL);\n      }\n      sqlite3ReleaseTempReg(pParse, regToFree);\n    }\n    if( regCkNull ){\n      sqlite3VdbeAddOp2(v, OP_IsNull, regCkNull, destIfNull); VdbeCoverage(v);\n      sqlite3VdbeGoto(v, destIfFalse);\n    }\n    sqlite3VdbeResolveLabel(v, labelOk);\n    sqlite3ReleaseTempReg(pParse, regCkNull);\n    goto sqlite3ExprCodeIN_finished;\n  }\n\n  /* Step 2: Check to see if the LHS contains any NULL columns.  If the\n  ** LHS does contain NULLs then the result must be either FALSE or NULL.\n  ** We will then skip the binary search of the RHS.\n  */\n  if( destIfNull==destIfFalse ){\n    destStep2 = destIfFalse;\n  }else{\n    destStep2 = destStep6 = sqlite3VdbeMakeLabel(pParse);\n  }\n  for(i=0; i<nVector; i++){\n    Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);\n    if( sqlite3ExprCanBeNull(p) ){\n      sqlite3VdbeAddOp2(v, OP_IsNull, rLhs+i, destStep2);\n      VdbeCoverage(v);\n    }\n  }\n\n  /* Step 3.  The LHS is now known to be non-NULL.  Do the binary search\n  ** of the RHS using the LHS as a probe.  If found, the result is\n  ** true.\n  */\n  if( eType==IN_INDEX_ROWID ){\n    /* In this case, the RHS is the ROWID of table b-tree and so we also\n    ** know that the RHS is non-NULL.  Hence, we combine steps 3 and 4\n    ** into a single opcode. */\n    sqlite3VdbeAddOp3(v, OP_SeekRowid, iTab, destIfFalse, rLhs);\n    VdbeCoverage(v);\n    addrTruthOp = sqlite3VdbeAddOp0(v, OP_Goto);  /* Return True */\n  }else{\n    sqlite3VdbeAddOp4(v, OP_Affinity, rLhs, nVector, 0, zAff, nVector);\n    if( destIfFalse==destIfNull ){\n      /* Combine Step 3 and Step 5 into a single opcode */\n      sqlite3VdbeAddOp4Int(v, OP_NotFound, iTab, destIfFalse,\n                           rLhs, nVector); VdbeCoverage(v);\n      goto sqlite3ExprCodeIN_finished;\n    }\n    /* Ordinary Step 3, for the case where FALSE and NULL are distinct */\n    addrTruthOp = sqlite3VdbeAddOp4Int(v, OP_Found, iTab, 0,\n                                      rLhs, nVector); VdbeCoverage(v);\n  }\n\n  /* Step 4.  If the RHS is known to be non-NULL and we did not find\n  ** an match on the search above, then the result must be FALSE.\n  */\n  if( rRhsHasNull && nVector==1 ){\n    sqlite3VdbeAddOp2(v, OP_NotNull, rRhsHasNull, destIfFalse);\n    VdbeCoverage(v);\n  }\n\n  /* Step 5.  If we do not care about the difference between NULL and\n  ** FALSE, then just return false. \n  */\n  if( destIfFalse==destIfNull ) sqlite3VdbeGoto(v, destIfFalse);\n\n  /* Step 6: Loop through rows of the RHS.  Compare each row to the LHS.\n  ** If any comparison is NULL, then the result is NULL.  If all\n  ** comparisons are FALSE then the final result is FALSE.\n  **\n  ** For a scalar LHS, it is sufficient to check just the first row\n  ** of the RHS.\n  */\n  if( destStep6 ) sqlite3VdbeResolveLabel(v, destStep6);\n  addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, destIfFalse);\n  VdbeCoverage(v);\n  if( nVector>1 ){\n    destNotNull = sqlite3VdbeMakeLabel(pParse);\n  }else{\n    /* For nVector==1, combine steps 6 and 7 by immediately returning\n    ** FALSE if the first comparison is not NULL */\n    destNotNull = destIfFalse;\n  }\n  for(i=0; i<nVector; i++){\n    Expr *p;\n    CollSeq *pColl;\n    int r3 = sqlite3GetTempReg(pParse);\n    p = sqlite3VectorFieldSubexpr(pLeft, i);\n    pColl = sqlite3ExprCollSeq(pParse, p);\n    sqlite3VdbeAddOp3(v, OP_Column, iTab, i, r3);\n    sqlite3VdbeAddOp4(v, OP_Ne, rLhs+i, destNotNull, r3,\n                      (void*)pColl, P4_COLLSEQ);\n    VdbeCoverage(v);\n    sqlite3ReleaseTempReg(pParse, r3);\n  }\n  sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfNull);\n  if( nVector>1 ){\n    sqlite3VdbeResolveLabel(v, destNotNull);\n    sqlite3VdbeAddOp2(v, OP_Next, iTab, addrTop+1);\n    VdbeCoverage(v);\n\n    /* Step 7:  If we reach this point, we know that the result must\n    ** be false. */\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfFalse);\n  }\n\n  /* Jumps here in order to return true. */\n  sqlite3VdbeJumpHere(v, addrTruthOp);\n\nsqlite3ExprCodeIN_finished:\n  if( rLhs!=rLhsOrig ) sqlite3ReleaseTempReg(pParse, rLhs);\n  VdbeComment((v, \"end IN expr\"));\nsqlite3ExprCodeIN_oom_error:\n  sqlite3DbFree(pParse->db, aiMap);\n  sqlite3DbFree(pParse->db, zAff);\n}\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n/*\n** Generate an instruction that will put the floating point\n** value described by z[0..n-1] into register iMem.\n**\n** The z[] string will probably not be zero-terminated.  But the \n** z[n] character is guaranteed to be something that does not look\n** like the continuation of the number.\n*/\nstatic void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem){\n  if( ALWAYS(z!=0) ){\n    double value;\n    sqlite3AtoF(z, &value, sqlite3Strlen30(z), SQLITE_UTF8);\n    assert( !sqlite3IsNaN(value) ); /* The new AtoF never returns NaN */\n    if( negateFlag ) value = -value;\n    sqlite3VdbeAddOp4Dup8(v, OP_Real, 0, iMem, 0, (u8*)&value, P4_REAL);\n  }\n}\n#endif\n\n\n/*\n** Generate an instruction that will put the integer describe by\n** text z[0..n-1] into register iMem.\n**\n** Expr.u.zToken is always UTF8 and zero-terminated.\n*/\nstatic void codeInteger(Parse *pParse, Expr *pExpr, int negFlag, int iMem){\n  Vdbe *v = pParse->pVdbe;\n  if( pExpr->flags & EP_IntValue ){\n    int i = pExpr->u.iValue;\n    assert( i>=0 );\n    if( negFlag ) i = -i;\n    sqlite3VdbeAddOp2(v, OP_Integer, i, iMem);\n  }else{\n    int c;\n    i64 value;\n    const char *z = pExpr->u.zToken;\n    assert( z!=0 );\n    c = sqlite3DecOrHexToI64(z, &value);\n    if( (c==3 && !negFlag) || (c==2) || (negFlag && value==SMALLEST_INT64)){\n#ifdef SQLITE_OMIT_FLOATING_POINT\n      sqlite3ErrorMsg(pParse, \"oversized integer: %s%s\", negFlag ? \"-\" : \"\", z);\n#else\n#ifndef SQLITE_OMIT_HEX_INTEGER\n      if( sqlite3_strnicmp(z,\"0x\",2)==0 ){\n        sqlite3ErrorMsg(pParse, \"hex literal too big: %s%s\", negFlag?\"-\":\"\",z);\n      }else\n#endif\n      {\n        codeReal(v, z, negFlag, iMem);\n      }\n#endif\n    }else{\n      if( negFlag ){ value = c==3 ? SMALLEST_INT64 : -value; }\n      sqlite3VdbeAddOp4Dup8(v, OP_Int64, 0, iMem, 0, (u8*)&value, P4_INT64);\n    }\n  }\n}\n\n\n/* Generate code that will load into register regOut a value that is\n** appropriate for the iIdxCol-th column of index pIdx.\n*/\nvoid sqlite3ExprCodeLoadIndexColumn(\n  Parse *pParse,  /* The parsing context */\n  Index *pIdx,    /* The index whose column is to be loaded */\n  int iTabCur,    /* Cursor pointing to a table row */\n  int iIdxCol,    /* The column of the index to be loaded */\n  int regOut      /* Store the index column value in this register */\n){\n  i16 iTabCol = pIdx->aiColumn[iIdxCol];\n  if( iTabCol==XN_EXPR ){\n    assert( pIdx->aColExpr );\n    assert( pIdx->aColExpr->nExpr>iIdxCol );\n    pParse->iSelfTab = iTabCur + 1;\n    sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[iIdxCol].pExpr, regOut);\n    pParse->iSelfTab = 0;\n  }else{\n    sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pIdx->pTable, iTabCur,\n                                    iTabCol, regOut);\n  }\n}\n\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n/*\n** Generate code that will compute the value of generated column pCol\n** and store the result in register regOut\n*/\nvoid sqlite3ExprCodeGeneratedColumn(\n  Parse *pParse,\n  Column *pCol,\n  int regOut\n){\n  int iAddr;\n  Vdbe *v = pParse->pVdbe;\n  assert( v!=0 );\n  assert( pParse->iSelfTab!=0 );\n  if( pParse->iSelfTab>0 ){\n    iAddr = sqlite3VdbeAddOp3(v, OP_IfNullRow, pParse->iSelfTab-1, 0, regOut);\n  }else{\n    iAddr = 0;\n  }\n  sqlite3ExprCode(pParse, pCol->pDflt, regOut);\n  if( pCol->affinity>=SQLITE_AFF_TEXT ){\n    sqlite3VdbeAddOp4(v, OP_Affinity, regOut, 1, 0, &pCol->affinity, 1);\n  }\n  if( iAddr ) sqlite3VdbeJumpHere(v, iAddr);\n}\n#endif /* SQLITE_OMIT_GENERATED_COLUMNS */\n\n/*\n** Generate code to extract the value of the iCol-th column of a table.\n*/\nvoid sqlite3ExprCodeGetColumnOfTable(\n  Vdbe *v,        /* Parsing context */\n  Table *pTab,    /* The table containing the value */\n  int iTabCur,    /* The table cursor.  Or the PK cursor for WITHOUT ROWID */\n  int iCol,       /* Index of the column to extract */\n  int regOut      /* Extract the value into this register */\n){\n  Column *pCol;\n  assert( v!=0 );\n  if( pTab==0 ){\n    sqlite3VdbeAddOp3(v, OP_Column, iTabCur, iCol, regOut);\n    return;\n  }\n  if( iCol<0 || iCol==pTab->iPKey ){\n    sqlite3VdbeAddOp2(v, OP_Rowid, iTabCur, regOut);\n  }else{\n    int op;\n    int x;\n    if( IsVirtual(pTab) ){\n      op = OP_VColumn;\n      x = iCol;\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n    }else if( (pCol = &pTab->aCol[iCol])->colFlags & COLFLAG_VIRTUAL ){\n      Parse *pParse = sqlite3VdbeParser(v);\n      if( pCol->colFlags & COLFLAG_BUSY ){\n        sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pCol->zName);\n      }else{\n        int savedSelfTab = pParse->iSelfTab;\n        pCol->colFlags |= COLFLAG_BUSY;\n        pParse->iSelfTab = iTabCur+1;\n        sqlite3ExprCodeGeneratedColumn(pParse, pCol, regOut);\n        pParse->iSelfTab = savedSelfTab;\n        pCol->colFlags &= ~COLFLAG_BUSY;\n      }\n      return;\n#endif\n    }else if( !HasRowid(pTab) ){\n      testcase( iCol!=sqlite3TableColumnToStorage(pTab, iCol) );\n      x = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), iCol);\n      op = OP_Column;\n    }else{\n      x = sqlite3TableColumnToStorage(pTab,iCol);\n      testcase( x!=iCol );\n      op = OP_Column;\n    }\n    sqlite3VdbeAddOp3(v, op, iTabCur, x, regOut);\n    sqlite3ColumnDefault(v, pTab, iCol, regOut);\n  }\n}\n\n/*\n** Generate code that will extract the iColumn-th column from\n** table pTab and store the column value in register iReg. \n**\n** There must be an open cursor to pTab in iTable when this routine\n** is called.  If iColumn<0 then code is generated that extracts the rowid.\n*/\nint sqlite3ExprCodeGetColumn(\n  Parse *pParse,   /* Parsing and code generating context */\n  Table *pTab,     /* Description of the table we are reading from */\n  int iColumn,     /* Index of the table column */\n  int iTable,      /* The cursor pointing to the table */\n  int iReg,        /* Store results here */\n  u8 p5            /* P5 value for OP_Column + FLAGS */\n){\n  assert( pParse->pVdbe!=0 );\n  sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pTab, iTable, iColumn, iReg);\n  if( p5 ){\n    VdbeOp *pOp = sqlite3VdbeGetOp(pParse->pVdbe,-1);\n    if( pOp->opcode==OP_Column ) pOp->p5 = p5;\n  }\n  return iReg;\n}\n\n/*\n** Generate code to move content from registers iFrom...iFrom+nReg-1\n** over to iTo..iTo+nReg-1.\n*/\nvoid sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg){\n  sqlite3VdbeAddOp3(pParse->pVdbe, OP_Move, iFrom, iTo, nReg);\n}\n\n/*\n** Convert a scalar expression node to a TK_REGISTER referencing\n** register iReg.  The caller must ensure that iReg already contains\n** the correct value for the expression.\n*/\nstatic void exprToRegister(Expr *pExpr, int iReg){\n  Expr *p = sqlite3ExprSkipCollateAndLikely(pExpr);\n  p->op2 = p->op;\n  p->op = TK_REGISTER;\n  p->iTable = iReg;\n  ExprClearProperty(p, EP_Skip);\n}\n\n/*\n** Evaluate an expression (either a vector or a scalar expression) and store\n** the result in continguous temporary registers.  Return the index of\n** the first register used to store the result.\n**\n** If the returned result register is a temporary scalar, then also write\n** that register number into *piFreeable.  If the returned result register\n** is not a temporary or if the expression is a vector set *piFreeable\n** to 0.\n*/\nstatic int exprCodeVector(Parse *pParse, Expr *p, int *piFreeable){\n  int iResult;\n  int nResult = sqlite3ExprVectorSize(p);\n  if( nResult==1 ){\n    iResult = sqlite3ExprCodeTemp(pParse, p, piFreeable);\n  }else{\n    *piFreeable = 0;\n    if( p->op==TK_SELECT ){\n#if SQLITE_OMIT_SUBQUERY\n      iResult = 0;\n#else\n      iResult = sqlite3CodeSubselect(pParse, p);\n#endif\n    }else{\n      int i;\n      iResult = pParse->nMem+1;\n      pParse->nMem += nResult;\n      for(i=0; i<nResult; i++){\n        sqlite3ExprCodeFactorable(pParse, p->x.pList->a[i].pExpr, i+iResult);\n      }\n    }\n  }\n  return iResult;\n}\n\n\n/*\n** Generate code into the current Vdbe to evaluate the given\n** expression.  Attempt to store the results in register \"target\".\n** Return the register where results are stored.\n**\n** With this routine, there is no guarantee that results will\n** be stored in target.  The result might be stored in some other\n** register if it is convenient to do so.  The calling function\n** must check the return code and move the results to the desired\n** register.\n*/\nint sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){\n  Vdbe *v = pParse->pVdbe;  /* The VM under construction */\n  int op;                   /* The opcode being coded */\n  int inReg = target;       /* Results stored in register inReg */\n  int regFree1 = 0;         /* If non-zero free this temporary register */\n  int regFree2 = 0;         /* If non-zero free this temporary register */\n  int r1, r2;               /* Various register numbers */\n  Expr tempX;               /* Temporary expression node */\n  int p5 = 0;\n\n  assert( target>0 && target<=pParse->nMem );\n  if( v==0 ){\n    assert( pParse->db->mallocFailed );\n    return 0;\n  }\n\nexpr_code_doover:\n  if( pExpr==0 ){\n    op = TK_NULL;\n  }else{\n    op = pExpr->op;\n  }\n  switch( op ){\n    case TK_AGG_COLUMN: {\n      AggInfo *pAggInfo = pExpr->pAggInfo;\n      struct AggInfo_col *pCol = &pAggInfo->aCol[pExpr->iAgg];\n      if( !pAggInfo->directMode ){\n        assert( pCol->iMem>0 );\n        return pCol->iMem;\n      }else if( pAggInfo->useSortingIdx ){\n        sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdxPTab,\n                              pCol->iSorterColumn, target);\n        return target;\n      }\n      /* Otherwise, fall thru into the TK_COLUMN case */\n    }\n    case TK_COLUMN: {\n      int iTab = pExpr->iTable;\n      if( ExprHasProperty(pExpr, EP_FixedCol) ){\n        /* This COLUMN expression is really a constant due to WHERE clause\n        ** constraints, and that constant is coded by the pExpr->pLeft\n        ** expresssion.  However, make sure the constant has the correct\n        ** datatype by applying the Affinity of the table column to the\n        ** constant.\n        */\n        int iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);\n        int aff;\n        if( pExpr->y.pTab ){\n          aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n        }else{\n          aff = pExpr->affExpr;\n        }\n        if( aff>SQLITE_AFF_BLOB ){\n          static const char zAff[] = \"B\\000C\\000D\\000E\";\n          assert( SQLITE_AFF_BLOB=='A' );\n          assert( SQLITE_AFF_TEXT=='B' );\n          if( iReg!=target ){\n            sqlite3VdbeAddOp2(v, OP_SCopy, iReg, target);\n            iReg = target;\n          }\n          sqlite3VdbeAddOp4(v, OP_Affinity, iReg, 1, 0,\n                            &zAff[(aff-'B')*2], P4_STATIC);\n        }\n        return iReg;\n      }\n      if( iTab<0 ){\n        if( pParse->iSelfTab<0 ){\n          /* Other columns in the same row for CHECK constraints or\n          ** generated columns or for inserting into partial index.\n          ** The row is unpacked into registers beginning at\n          ** 0-(pParse->iSelfTab).  The rowid (if any) is in a register\n          ** immediately prior to the first column.\n          */\n          Column *pCol;\n          Table *pTab = pExpr->y.pTab;\n          int iSrc;\n          int iCol = pExpr->iColumn;\n          assert( pTab!=0 );\n          assert( iCol>=XN_ROWID );\n          assert( iCol<pExpr->y.pTab->nCol );\n          if( iCol<0 ){\n            return -1-pParse->iSelfTab;\n          }\n          pCol = pTab->aCol + iCol;\n          testcase( iCol!=sqlite3TableColumnToStorage(pTab,iCol) );\n          iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n          if( pCol->colFlags & COLFLAG_GENERATED ){\n            if( pCol->colFlags & COLFLAG_BUSY ){\n              sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\",\n                              pCol->zName);\n              return 0;\n            }\n            pCol->colFlags |= COLFLAG_BUSY;\n            if( pCol->colFlags & COLFLAG_NOTAVAIL ){\n              sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);\n            }\n            pCol->colFlags &= ~(COLFLAG_BUSY|COLFLAG_NOTAVAIL);\n            return iSrc;\n          }else\n#endif /* SQLITE_OMIT_GENERATED_COLUMNS */\n          if( pCol->affinity==SQLITE_AFF_REAL ){\n            sqlite3VdbeAddOp2(v, OP_SCopy, iSrc, target);\n            sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n            return target;\n          }else{\n            return iSrc;\n          }\n        }else{\n          /* Coding an expression that is part of an index where column names\n          ** in the index refer to the table to which the index belongs */\n          iTab = pParse->iSelfTab - 1;\n        }\n      }\n      return sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab,\n                               pExpr->iColumn, iTab, target,\n                               pExpr->op2);\n    }\n    case TK_INTEGER: {\n      codeInteger(pParse, pExpr, 0, target);\n      return target;\n    }\n    case TK_TRUEFALSE: {\n      sqlite3VdbeAddOp2(v, OP_Integer, sqlite3ExprTruthValue(pExpr), target);\n      return target;\n    }\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    case TK_FLOAT: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      codeReal(v, pExpr->u.zToken, 0, target);\n      return target;\n    }\n#endif\n    case TK_STRING: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3VdbeLoadString(v, target, pExpr->u.zToken);\n      return target;\n    }\n    default: {\n      /* Make NULL the default case so that if a bug causes an illegal\n      ** Expr node to be passed into this function, it will be handled\n      ** sanely and not crash.  But keep an assert() to bring the problem\n      ** to the attention of the developers. */\n      assert( op==TK_NULL );\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      return target;\n    }\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n    case TK_BLOB: {\n      int n;\n      const char *z;\n      char *zBlob;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );\n      assert( pExpr->u.zToken[1]=='\\'' );\n      z = &pExpr->u.zToken[2];\n      n = sqlite3Strlen30(z) - 1;\n      assert( z[n]=='\\'' );\n      zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);\n      sqlite3VdbeAddOp4(v, OP_Blob, n/2, target, 0, zBlob, P4_DYNAMIC);\n      return target;\n    }\n#endif\n    case TK_VARIABLE: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken!=0 );\n      assert( pExpr->u.zToken[0]!=0 );\n      sqlite3VdbeAddOp2(v, OP_Variable, pExpr->iColumn, target);\n      if( pExpr->u.zToken[1]!=0 ){\n        const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);\n        assert( pExpr->u.zToken[0]=='?' || strcmp(pExpr->u.zToken, z)==0 );\n        pParse->pVList[0] = 0; /* Indicate VList may no longer be enlarged */\n        sqlite3VdbeAppendP4(v, (char*)z, P4_STATIC);\n      }\n      return target;\n    }\n    case TK_REGISTER: {\n      return pExpr->iTable;\n    }\n#ifndef SQLITE_OMIT_CAST\n    case TK_CAST: {\n      /* Expressions of the form:   CAST(pLeft AS token) */\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      if( inReg!=target ){\n        sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target);\n        inReg = target;\n      }\n      sqlite3VdbeAddOp2(v, OP_Cast, target,\n                        sqlite3AffinityType(pExpr->u.zToken, 0));\n      return inReg;\n    }\n#endif /* SQLITE_OMIT_CAST */\n    case TK_IS:\n    case TK_ISNOT:\n      op = (op==TK_IS) ? TK_EQ : TK_NE;\n      p5 = SQLITE_NULLEQ;\n      /* fall-through */\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      Expr *pLeft = pExpr->pLeft;\n      if( sqlite3ExprIsVector(pLeft) ){\n        codeVectorCompare(pParse, pExpr, target, op, p5);\n      }else{\n        r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);\n        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n        codeCompare(pParse, pLeft, pExpr->pRight, op,\n            r1, r2, inReg, SQLITE_STOREP2 | p5,\n            ExprHasProperty(pExpr,EP_Commuted));\n        assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n        assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n        assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n        assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n        assert(TK_EQ==OP_Eq); testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);\n        assert(TK_NE==OP_Ne); testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);\n        testcase( regFree1==0 );\n        testcase( regFree2==0 );\n      }\n      break;\n    }\n    case TK_AND:\n    case TK_OR:\n    case TK_PLUS:\n    case TK_STAR:\n    case TK_MINUS:\n    case TK_REM:\n    case TK_BITAND:\n    case TK_BITOR:\n    case TK_SLASH:\n    case TK_LSHIFT:\n    case TK_RSHIFT: \n    case TK_CONCAT: {\n      assert( TK_AND==OP_And );            testcase( op==TK_AND );\n      assert( TK_OR==OP_Or );              testcase( op==TK_OR );\n      assert( TK_PLUS==OP_Add );           testcase( op==TK_PLUS );\n      assert( TK_MINUS==OP_Subtract );     testcase( op==TK_MINUS );\n      assert( TK_REM==OP_Remainder );      testcase( op==TK_REM );\n      assert( TK_BITAND==OP_BitAnd );      testcase( op==TK_BITAND );\n      assert( TK_BITOR==OP_BitOr );        testcase( op==TK_BITOR );\n      assert( TK_SLASH==OP_Divide );       testcase( op==TK_SLASH );\n      assert( TK_LSHIFT==OP_ShiftLeft );   testcase( op==TK_LSHIFT );\n      assert( TK_RSHIFT==OP_ShiftRight );  testcase( op==TK_RSHIFT );\n      assert( TK_CONCAT==OP_Concat );      testcase( op==TK_CONCAT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      sqlite3VdbeAddOp3(v, op, r2, r1, target);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_UMINUS: {\n      Expr *pLeft = pExpr->pLeft;\n      assert( pLeft );\n      if( pLeft->op==TK_INTEGER ){\n        codeInteger(pParse, pLeft, 1, target);\n        return target;\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      }else if( pLeft->op==TK_FLOAT ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        codeReal(v, pLeft->u.zToken, 1, target);\n        return target;\n#endif\n      }else{\n        tempX.op = TK_INTEGER;\n        tempX.flags = EP_IntValue|EP_TokenOnly;\n        tempX.u.iValue = 0;\n        r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);\n        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);\n        sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target);\n        testcase( regFree2==0 );\n      }\n      break;\n    }\n    case TK_BITNOT:\n    case TK_NOT: {\n      assert( TK_BITNOT==OP_BitNot );   testcase( op==TK_BITNOT );\n      assert( TK_NOT==OP_Not );         testcase( op==TK_NOT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      sqlite3VdbeAddOp2(v, op, r1, inReg);\n      break;\n    }\n    case TK_TRUTH: {\n      int isTrue;    /* IS TRUE or IS NOT TRUE */\n      int bNormal;   /* IS TRUE or IS FALSE */\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n      bNormal = pExpr->op2==TK_IS;\n      testcase( isTrue && bNormal);\n      testcase( !isTrue && bNormal);\n      sqlite3VdbeAddOp4Int(v, OP_IsTrue, r1, inReg, !isTrue, isTrue ^ bNormal);\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      int addr;\n      assert( TK_ISNULL==OP_IsNull );   testcase( op==TK_ISNULL );\n      assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      addr = sqlite3VdbeAddOp1(v, op, r1);\n      VdbeCoverageIf(v, op==TK_ISNULL);\n      VdbeCoverageIf(v, op==TK_NOTNULL);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, target);\n      sqlite3VdbeJumpHere(v, addr);\n      break;\n    }\n    case TK_AGG_FUNCTION: {\n      AggInfo *pInfo = pExpr->pAggInfo;\n      if( pInfo==0 ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        sqlite3ErrorMsg(pParse, \"misuse of aggregate: %s()\", pExpr->u.zToken);\n      }else{\n        return pInfo->aFunc[pExpr->iAgg].iMem;\n      }\n      break;\n    }\n    case TK_FUNCTION: {\n      ExprList *pFarg;       /* List of function arguments */\n      int nFarg;             /* Number of function arguments */\n      FuncDef *pDef;         /* The function definition object */\n      const char *zId;       /* The function name */\n      u32 constMask = 0;     /* Mask of function arguments that are constant */\n      int i;                 /* Loop counter */\n      sqlite3 *db = pParse->db;  /* The database connection */\n      u8 enc = ENC(db);      /* The text encoding used by this database */\n      CollSeq *pColl = 0;    /* A collating sequence */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        return pExpr->y.pWin->regResult;\n      }\n#endif\n\n      if( ConstFactorOk(pParse) && sqlite3ExprIsConstantNotJoin(pExpr) ){\n        /* SQL functions can be expensive. So try to move constant functions\n        ** out of the inner loop, even if that means an extra OP_Copy. */\n        return sqlite3ExprCodeAtInit(pParse, pExpr, -1);\n      }\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      if( ExprHasProperty(pExpr, EP_TokenOnly) ){\n        pFarg = 0;\n      }else{\n        pFarg = pExpr->x.pList;\n      }\n      nFarg = pFarg ? pFarg->nExpr : 0;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      zId = pExpr->u.zToken;\n      pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);\n#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n      if( pDef==0 && pParse->explain ){\n        pDef = sqlite3FindFunction(db, \"unknown\", nFarg, enc, 0);\n      }\n#endif\n      if( pDef==0 || pDef->xFinalize!=0 ){\n        sqlite3ErrorMsg(pParse, \"unknown function: %s()\", zId);\n        break;\n      }\n\n      /* Attempt a direct implementation of the built-in COALESCE() and\n      ** IFNULL() functions.  This avoids unnecessary evaluation of\n      ** arguments past the first non-NULL argument.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_COALESCE ){\n        int endCoalesce = sqlite3VdbeMakeLabel(pParse);\n        assert( nFarg>=2 );\n        sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);\n        for(i=1; i<nFarg; i++){\n          sqlite3VdbeAddOp2(v, OP_NotNull, target, endCoalesce);\n          VdbeCoverage(v);\n          sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);\n        }\n        sqlite3VdbeResolveLabel(v, endCoalesce);\n        break;\n      }\n\n      /* The UNLIKELY() function is a no-op.  The result is the value\n      ** of the first argument.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_UNLIKELY ){\n        assert( nFarg>=1 );\n        return sqlite3ExprCodeTarget(pParse, pFarg->a[0].pExpr, target);\n      }\n\n#ifdef SQLITE_DEBUG\n      /* The AFFINITY() function evaluates to a string that describes\n      ** the type affinity of the argument.  This is used for testing of\n      ** the SQLite type logic.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_AFFINITY ){\n        const char *azAff[] = { \"blob\", \"text\", \"numeric\", \"integer\", \"real\" };\n        char aff;\n        assert( nFarg==1 );\n        aff = sqlite3ExprAffinity(pFarg->a[0].pExpr);\n        sqlite3VdbeLoadString(v, target, \n                (aff<=SQLITE_AFF_NONE) ? \"none\" : azAff[aff-SQLITE_AFF_BLOB]);\n        return target;\n      }\n#endif\n\n      for(i=0; i<nFarg; i++){\n        if( i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr) ){\n          testcase( i==31 );\n          constMask |= MASKBIT32(i);\n        }\n        if( (pDef->funcFlags & SQLITE_FUNC_NEEDCOLL)!=0 && !pColl ){\n          pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);\n        }\n      }\n      if( pFarg ){\n        if( constMask ){\n          r1 = pParse->nMem+1;\n          pParse->nMem += nFarg;\n        }else{\n          r1 = sqlite3GetTempRange(pParse, nFarg);\n        }\n\n        /* For length() and typeof() functions with a column argument,\n        ** set the P5 parameter to the OP_Column opcode to OPFLAG_LENGTHARG\n        ** or OPFLAG_TYPEOFARG respectively, to avoid unnecessary data\n        ** loading.\n        */\n        if( (pDef->funcFlags & (SQLITE_FUNC_LENGTH|SQLITE_FUNC_TYPEOF))!=0 ){\n          u8 exprOp;\n          assert( nFarg==1 );\n          assert( pFarg->a[0].pExpr!=0 );\n          exprOp = pFarg->a[0].pExpr->op;\n          if( exprOp==TK_COLUMN || exprOp==TK_AGG_COLUMN ){\n            assert( SQLITE_FUNC_LENGTH==OPFLAG_LENGTHARG );\n            assert( SQLITE_FUNC_TYPEOF==OPFLAG_TYPEOFARG );\n            testcase( pDef->funcFlags & OPFLAG_LENGTHARG );\n            pFarg->a[0].pExpr->op2 = \n                  pDef->funcFlags & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG);\n          }\n        }\n\n        sqlite3ExprCodeExprList(pParse, pFarg, r1, 0,\n                                SQLITE_ECEL_DUP|SQLITE_ECEL_FACTOR);\n      }else{\n        r1 = 0;\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n      /* Possibly overload the function if the first argument is\n      ** a virtual table column.\n      **\n      ** For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the\n      ** second argument, not the first, as the argument to test to\n      ** see if it is a column in a virtual table.  This is done because\n      ** the left operand of infix functions (the operand we want to\n      ** control overloading) ends up as the second argument to the\n      ** function.  The expression \"A glob B\" is equivalent to \n      ** \"glob(B,A).  We want to use the A in \"A glob B\" to test\n      ** for function overloading.  But we use the B term in \"glob(B,A)\".\n      */\n      if( nFarg>=2 && ExprHasProperty(pExpr, EP_InfixFunc) ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);\n      }else if( nFarg>0 ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);\n      }\n#endif\n      if( pDef->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n        if( !pColl ) pColl = db->pDfltColl; \n        sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);\n      }\n#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC\n      if( pDef->funcFlags & SQLITE_FUNC_OFFSET ){\n        Expr *pArg = pFarg->a[0].pExpr;\n        if( pArg->op==TK_COLUMN ){\n          sqlite3VdbeAddOp3(v, OP_Offset, pArg->iTable, pArg->iColumn, target);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n        }\n      }else\n#endif\n      {\n        sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,\n                                   pDef, pExpr->op2);\n      }\n      if( nFarg && constMask==0 ){\n        sqlite3ReleaseTempRange(pParse, r1, nFarg);\n      }\n      return target;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_EXISTS:\n    case TK_SELECT: {\n      int nCol;\n      testcase( op==TK_EXISTS );\n      testcase( op==TK_SELECT );\n      if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){\n        sqlite3SubselectError(pParse, nCol, 1);\n      }else{\n        return sqlite3CodeSubselect(pParse, pExpr);\n      }\n      break;\n    }\n    case TK_SELECT_COLUMN: {\n      int n;\n      if( pExpr->pLeft->iTable==0 ){\n        pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);\n      }\n      assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );\n      if( pExpr->iTable!=0\n       && pExpr->iTable!=(n = sqlite3ExprVectorSize(pExpr->pLeft))\n      ){\n        sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\",\n                                pExpr->iTable, n);\n      }\n      return pExpr->pLeft->iTable + pExpr->iColumn;\n    }\n    case TK_IN: {\n      int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n      int destIfNull = sqlite3VdbeMakeLabel(pParse);\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      sqlite3VdbeResolveLabel(v, destIfFalse);\n      sqlite3VdbeAddOp2(v, OP_AddImm, target, 0);\n      sqlite3VdbeResolveLabel(v, destIfNull);\n      return target;\n    }\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n\n    /*\n    **    x BETWEEN y AND z\n    **\n    ** This is equivalent to\n    **\n    **    x>=y AND x<=z\n    **\n    ** X is stored in pExpr->pLeft.\n    ** Y is stored in pExpr->pList->a[0].pExpr.\n    ** Z is stored in pExpr->pList->a[1].pExpr.\n    */\n    case TK_BETWEEN: {\n      exprCodeBetween(pParse, pExpr, target, 0, 0);\n      return target;\n    }\n    case TK_SPAN:\n    case TK_COLLATE: \n    case TK_UPLUS: {\n      pExpr = pExpr->pLeft;\n      goto expr_code_doover; /* 2018-04-28: Prevent deep recursion. OSSFuzz. */\n    }\n\n    case TK_TRIGGER: {\n      /* If the opcode is TK_TRIGGER, then the expression is a reference\n      ** to a column in the new.* or old.* pseudo-tables available to\n      ** trigger programs. In this case Expr.iTable is set to 1 for the\n      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumn\n      ** is set to the column of the pseudo-table to read, or to -1 to\n      ** read the rowid field.\n      **\n      ** The expression is implemented using an OP_Param opcode. The p1\n      ** parameter is set to 0 for an old.rowid reference, or to (i+1)\n      ** to reference another column of the old.* pseudo-table, where \n      ** i is the index of the column. For a new.rowid reference, p1 is\n      ** set to (n+1), where n is the number of columns in each pseudo-table.\n      ** For a reference to any other column in the new.* pseudo-table, p1\n      ** is set to (n+2+i), where n and i are as defined previously. For\n      ** example, if the table on which triggers are being fired is\n      ** declared as:\n      **\n      **   CREATE TABLE t1(a, b);\n      **\n      ** Then p1 is interpreted as follows:\n      **\n      **   p1==0   ->    old.rowid     p1==3   ->    new.rowid\n      **   p1==1   ->    old.a         p1==4   ->    new.a\n      **   p1==2   ->    old.b         p1==5   ->    new.b       \n      */\n      Table *pTab = pExpr->y.pTab;\n      int iCol = pExpr->iColumn;\n      int p1 = pExpr->iTable * (pTab->nCol+1) + 1 \n                     + sqlite3TableColumnToStorage(pTab, iCol);\n\n      assert( pExpr->iTable==0 || pExpr->iTable==1 );\n      assert( iCol>=-1 && iCol<pTab->nCol );\n      assert( pTab->iPKey<0 || iCol!=pTab->iPKey );\n      assert( p1>=0 && p1<(pTab->nCol*2+2) );\n\n      sqlite3VdbeAddOp2(v, OP_Param, p1, target);\n      VdbeComment((v, \"r[%d]=%s.%s\", target,\n        (pExpr->iTable ? \"new\" : \"old\"),\n        (pExpr->iColumn<0 ? \"rowid\" : pExpr->y.pTab->aCol[iCol].zName)\n      ));\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      /* If the column has REAL affinity, it may currently be stored as an\n      ** integer. Use OP_RealAffinity to make sure it is really real.\n      **\n      ** EVIDENCE-OF: R-60985-57662 SQLite will convert the value back to\n      ** floating point when extracting it from the record.  */\n      if( iCol>=0 && pTab->aCol[iCol].affinity==SQLITE_AFF_REAL ){\n        sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n      }\n#endif\n      break;\n    }\n\n    case TK_VECTOR: {\n      sqlite3ErrorMsg(pParse, \"row value misused\");\n      break;\n    }\n\n    /* TK_IF_NULL_ROW Expr nodes are inserted ahead of expressions\n    ** that derive from the right-hand table of a LEFT JOIN.  The\n    ** Expr.iTable value is the table number for the right-hand table.\n    ** The expression is only evaluated if that table is not currently\n    ** on a LEFT JOIN NULL row.\n    */\n    case TK_IF_NULL_ROW: {\n      int addrINR;\n      u8 okConstFactor = pParse->okConstFactor;\n      addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);\n      /* Temporarily disable factoring of constant expressions, since\n      ** even though expressions may appear to be constant, they are not\n      ** really constant because they originate from the right-hand side\n      ** of a LEFT JOIN. */\n      pParse->okConstFactor = 0;\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      pParse->okConstFactor = okConstFactor;\n      sqlite3VdbeJumpHere(v, addrINR);\n      sqlite3VdbeChangeP3(v, addrINR, inReg);\n      break;\n    }\n\n    /*\n    ** Form A:\n    **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form B:\n    **   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form A is can be transformed into the equivalent form B as follows:\n    **   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...\n    **        WHEN x=eN THEN rN ELSE y END\n    **\n    ** X (if it exists) is in pExpr->pLeft.\n    ** Y is in the last element of pExpr->x.pList if pExpr->x.pList->nExpr is\n    ** odd.  The Y is also optional.  If the number of elements in x.pList\n    ** is even, then Y is omitted and the \"otherwise\" result is NULL.\n    ** Ei is in pExpr->pList->a[i*2] and Ri is pExpr->pList->a[i*2+1].\n    **\n    ** The result of the expression is the Ri for the first matching Ei,\n    ** or if there is no matching Ei, the ELSE term Y, or if there is\n    ** no ELSE term, NULL.\n    */\n    case TK_CASE: {\n      int endLabel;                     /* GOTO label for end of CASE stmt */\n      int nextCase;                     /* GOTO label for next WHEN clause */\n      int nExpr;                        /* 2x number of WHEN terms */\n      int i;                            /* Loop counter */\n      ExprList *pEList;                 /* List of WHEN terms */\n      struct ExprList_item *aListelem;  /* Array of WHEN terms */\n      Expr opCompare;                   /* The X==Ei expression */\n      Expr *pX;                         /* The X expression */\n      Expr *pTest = 0;                  /* X==Ei (form A) or just Ei (form B) */\n      Expr *pDel = 0;\n      sqlite3 *db = pParse->db;\n\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList );\n      assert(pExpr->x.pList->nExpr > 0);\n      pEList = pExpr->x.pList;\n      aListelem = pEList->a;\n      nExpr = pEList->nExpr;\n      endLabel = sqlite3VdbeMakeLabel(pParse);\n      if( (pX = pExpr->pLeft)!=0 ){\n        pDel = sqlite3ExprDup(db, pX, 0);\n        if( db->mallocFailed ){\n          sqlite3ExprDelete(db, pDel);\n          break;\n        }\n        testcase( pX->op==TK_COLUMN );\n        exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n        testcase( regFree1==0 );\n        memset(&opCompare, 0, sizeof(opCompare));\n        opCompare.op = TK_EQ;\n        opCompare.pLeft = pDel;\n        pTest = &opCompare;\n        /* Ticket b351d95f9cd5ef17e9d9dbae18f5ca8611190001:\n        ** The value in regFree1 might get SCopy-ed into the file result.\n        ** So make sure that the regFree1 register is not reused for other\n        ** purposes and possibly overwritten.  */\n        regFree1 = 0;\n      }\n      for(i=0; i<nExpr-1; i=i+2){\n        if( pX ){\n          assert( pTest!=0 );\n          opCompare.pRight = aListelem[i].pExpr;\n        }else{\n          pTest = aListelem[i].pExpr;\n        }\n        nextCase = sqlite3VdbeMakeLabel(pParse);\n        testcase( pTest->op==TK_COLUMN );\n        sqlite3ExprIfFalse(pParse, pTest, nextCase, SQLITE_JUMPIFNULL);\n        testcase( aListelem[i+1].pExpr->op==TK_COLUMN );\n        sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);\n        sqlite3VdbeGoto(v, endLabel);\n        sqlite3VdbeResolveLabel(v, nextCase);\n      }\n      if( (nExpr&1)!=0 ){\n        sqlite3ExprCode(pParse, pEList->a[nExpr-1].pExpr, target);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      }\n      sqlite3ExprDelete(db, pDel);\n      sqlite3VdbeResolveLabel(v, endLabel);\n      break;\n    }\n#ifndef SQLITE_OMIT_TRIGGER\n    case TK_RAISE: {\n      assert( pExpr->affExpr==OE_Rollback \n           || pExpr->affExpr==OE_Abort\n           || pExpr->affExpr==OE_Fail\n           || pExpr->affExpr==OE_Ignore\n      );\n      if( !pParse->pTriggerTab ){\n        sqlite3ErrorMsg(pParse,\n                       \"RAISE() may only be used within a trigger-program\");\n        return 0;\n      }\n      if( pExpr->affExpr==OE_Abort ){\n        sqlite3MayAbort(pParse);\n      }\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      if( pExpr->affExpr==OE_Ignore ){\n        sqlite3VdbeAddOp4(\n            v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken,0);\n        VdbeCoverage(v);\n      }else{\n        sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_TRIGGER,\n                              pExpr->affExpr, pExpr->u.zToken, 0, 0);\n      }\n\n      break;\n    }\n#endif\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);\n  return inReg;\n}\n\n/*\n** Factor out the code of the given expression to initialization time.\n**\n** If regDest>=0 then the result is always stored in that register and the\n** result is not reusable.  If regDest<0 then this routine is free to \n** store the value whereever it wants.  The register where the expression \n** is stored is returned.  When regDest<0, two identical expressions will\n** code to the same register.\n*/\nint sqlite3ExprCodeAtInit(\n  Parse *pParse,    /* Parsing context */\n  Expr *pExpr,      /* The expression to code when the VDBE initializes */\n  int regDest       /* Store the value in this register */\n){\n  ExprList *p;\n  assert( ConstFactorOk(pParse) );\n  p = pParse->pConstExpr;\n  if( regDest<0 && p ){\n    struct ExprList_item *pItem;\n    int i;\n    for(pItem=p->a, i=p->nExpr; i>0; pItem++, i--){\n      if( pItem->reusable && sqlite3ExprCompare(0,pItem->pExpr,pExpr,-1)==0 ){\n        return pItem->u.iConstExprReg;\n      }\n    }\n  }\n  pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);\n  p = sqlite3ExprListAppend(pParse, p, pExpr);\n  if( p ){\n     struct ExprList_item *pItem = &p->a[p->nExpr-1];\n     pItem->reusable = regDest<0;\n     if( regDest<0 ) regDest = ++pParse->nMem;\n     pItem->u.iConstExprReg = regDest;\n  }\n  pParse->pConstExpr = p;\n  return regDest;\n}\n\n/*\n** Generate code to evaluate an expression and store the results\n** into a register.  Return the register number where the results\n** are stored.\n**\n** If the register is a temporary register that can be deallocated,\n** then write its number into *pReg.  If the result register is not\n** a temporary, then set *pReg to zero.\n**\n** If pExpr is a constant, then this routine might generate this\n** code to fill the register in the initialization section of the\n** VDBE program, in order to factor it out of the evaluation loop.\n*/\nint sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){\n  int r2;\n  pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);\n  if( ConstFactorOk(pParse)\n   && pExpr->op!=TK_REGISTER\n   && sqlite3ExprIsConstantNotJoin(pExpr)\n  ){\n    *pReg  = 0;\n    r2 = sqlite3ExprCodeAtInit(pParse, pExpr, -1);\n  }else{\n    int r1 = sqlite3GetTempReg(pParse);\n    r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);\n    if( r2==r1 ){\n      *pReg = r1;\n    }else{\n      sqlite3ReleaseTempReg(pParse, r1);\n      *pReg = 0;\n    }\n  }\n  return r2;\n}\n\n/*\n** Generate code that will evaluate expression pExpr and store the\n** results in register target.  The results are guaranteed to appear\n** in register target.\n*/\nvoid sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){\n  int inReg;\n\n  assert( target>0 && target<=pParse->nMem );\n  inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);\n  assert( pParse->pVdbe!=0 || pParse->db->mallocFailed );\n  if( inReg!=target && pParse->pVdbe ){\n    sqlite3VdbeAddOp2(pParse->pVdbe, OP_SCopy, inReg, target);\n  }\n}\n\n/*\n** Make a transient copy of expression pExpr and then code it using\n** sqlite3ExprCode().  This routine works just like sqlite3ExprCode()\n** except that the input expression is guaranteed to be unchanged.\n*/\nvoid sqlite3ExprCodeCopy(Parse *pParse, Expr *pExpr, int target){\n  sqlite3 *db = pParse->db;\n  pExpr = sqlite3ExprDup(db, pExpr, 0);\n  if( !db->mallocFailed ) sqlite3ExprCode(pParse, pExpr, target);\n  sqlite3ExprDelete(db, pExpr);\n}\n\n/*\n** Generate code that will evaluate expression pExpr and store the\n** results in register target.  The results are guaranteed to appear\n** in register target.  If the expression is constant, then this routine\n** might choose to code the expression at initialization time.\n*/\nvoid sqlite3ExprCodeFactorable(Parse *pParse, Expr *pExpr, int target){\n  if( pParse->okConstFactor && sqlite3ExprIsConstantNotJoin(pExpr) ){\n    sqlite3ExprCodeAtInit(pParse, pExpr, target);\n  }else{\n    sqlite3ExprCode(pParse, pExpr, target);\n  }\n}\n\n/*\n** Generate code that pushes the value of every element of the given\n** expression list into a sequence of registers beginning at target.\n**\n** Return the number of elements evaluated.  The number returned will\n** usually be pList->nExpr but might be reduced if SQLITE_ECEL_OMITREF\n** is defined.\n**\n** The SQLITE_ECEL_DUP flag prevents the arguments from being\n** filled using OP_SCopy.  OP_Copy must be used instead.\n**\n** The SQLITE_ECEL_FACTOR argument allows constant arguments to be\n** factored out into initialization code.\n**\n** The SQLITE_ECEL_REF flag means that expressions in the list with\n** ExprList.a[].u.x.iOrderByCol>0 have already been evaluated and stored\n** in registers at srcReg, and so the value can be copied from there.\n** If SQLITE_ECEL_OMITREF is also set, then the values with u.x.iOrderByCol>0\n** are simply omitted rather than being copied from srcReg.\n*/\nint sqlite3ExprCodeExprList(\n  Parse *pParse,     /* Parsing context */\n  ExprList *pList,   /* The expression list to be coded */\n  int target,        /* Where to write results */\n  int srcReg,        /* Source registers if SQLITE_ECEL_REF */\n  u8 flags           /* SQLITE_ECEL_* flags */\n){\n  struct ExprList_item *pItem;\n  int i, j, n;\n  u8 copyOp = (flags & SQLITE_ECEL_DUP) ? OP_Copy : OP_SCopy;\n  Vdbe *v = pParse->pVdbe;\n  assert( pList!=0 );\n  assert( target>0 );\n  assert( pParse->pVdbe!=0 );  /* Never gets this far otherwise */\n  n = pList->nExpr;\n  if( !ConstFactorOk(pParse) ) flags &= ~SQLITE_ECEL_FACTOR;\n  for(pItem=pList->a, i=0; i<n; i++, pItem++){\n    Expr *pExpr = pItem->pExpr;\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    if( pItem->bSorterRef ){\n      i--;\n      n--;\n    }else\n#endif\n    if( (flags & SQLITE_ECEL_REF)!=0 && (j = pItem->u.x.iOrderByCol)>0 ){\n      if( flags & SQLITE_ECEL_OMITREF ){\n        i--;\n        n--;\n      }else{\n        sqlite3VdbeAddOp2(v, copyOp, j+srcReg-1, target+i);\n      }\n    }else if( (flags & SQLITE_ECEL_FACTOR)!=0\n           && sqlite3ExprIsConstantNotJoin(pExpr)\n    ){\n      sqlite3ExprCodeAtInit(pParse, pExpr, target+i);\n    }else{\n      int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target+i);\n      if( inReg!=target+i ){\n        VdbeOp *pOp;\n        if( copyOp==OP_Copy\n         && (pOp=sqlite3VdbeGetOp(v, -1))->opcode==OP_Copy\n         && pOp->p1+pOp->p3+1==inReg\n         && pOp->p2+pOp->p3+1==target+i\n        ){\n          pOp->p3++;\n        }else{\n          sqlite3VdbeAddOp2(v, copyOp, inReg, target+i);\n        }\n      }\n    }\n  }\n  return n;\n}\n\n/*\n** Generate code for a BETWEEN operator.\n**\n**    x BETWEEN y AND z\n**\n** The above is equivalent to \n**\n**    x>=y AND x<=z\n**\n** Code it as such, taking care to do the common subexpression\n** elimination of x.\n**\n** The xJumpIf parameter determines details:\n**\n**    NULL:                   Store the boolean result in reg[dest]\n**    sqlite3ExprIfTrue:      Jump to dest if true\n**    sqlite3ExprIfFalse:     Jump to dest if false\n**\n** The jumpIfNull parameter is ignored if xJumpIf is NULL.\n*/\nstatic void exprCodeBetween(\n  Parse *pParse,    /* Parsing and code generating context */\n  Expr *pExpr,      /* The BETWEEN expression */\n  int dest,         /* Jump destination or storage location */\n  void (*xJump)(Parse*,Expr*,int,int), /* Action to take */\n  int jumpIfNull    /* Take the jump if the BETWEEN is NULL */\n){\n  Expr exprAnd;     /* The AND operator in  x>=y AND x<=z  */\n  Expr compLeft;    /* The  x>=y  term */\n  Expr compRight;   /* The  x<=z  term */\n  int regFree1 = 0; /* Temporary use register */\n  Expr *pDel = 0;\n  sqlite3 *db = pParse->db;\n\n  memset(&compLeft, 0, sizeof(Expr));\n  memset(&compRight, 0, sizeof(Expr));\n  memset(&exprAnd, 0, sizeof(Expr));\n\n  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n  pDel = sqlite3ExprDup(db, pExpr->pLeft, 0);\n  if( db->mallocFailed==0 ){\n    exprAnd.op = TK_AND;\n    exprAnd.pLeft = &compLeft;\n    exprAnd.pRight = &compRight;\n    compLeft.op = TK_GE;\n    compLeft.pLeft = pDel;\n    compLeft.pRight = pExpr->x.pList->a[0].pExpr;\n    compRight.op = TK_LE;\n    compRight.pLeft = pDel;\n    compRight.pRight = pExpr->x.pList->a[1].pExpr;\n    exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n    if( xJump ){\n      xJump(pParse, &exprAnd, dest, jumpIfNull);\n    }else{\n      /* Mark the expression is being from the ON or USING clause of a join\n      ** so that the sqlite3ExprCodeTarget() routine will not attempt to move\n      ** it into the Parse.pConstExpr list.  We should use a new bit for this,\n      ** for clarity, but we are out of bits in the Expr.flags field so we\n      ** have to reuse the EP_FromJoin bit.  Bummer. */\n      pDel->flags |= EP_FromJoin;\n      sqlite3ExprCodeTarget(pParse, &exprAnd, dest);\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n  }\n  sqlite3ExprDelete(db, pDel);\n\n  /* Ensure adequate test coverage */\n  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull==0 && regFree1==0 );\n  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull==0 && regFree1!=0 );\n  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull!=0 && regFree1==0 );\n  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull!=0 && regFree1!=0 );\n  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull==0 && regFree1==0 );\n  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull==0 && regFree1!=0 );\n  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull!=0 && regFree1==0 );\n  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull!=0 && regFree1!=0 );\n  testcase( xJump==0 );\n}\n\n/*\n** Generate code for a boolean expression such that a jump is made\n** to the label \"dest\" if the expression is true but execution\n** continues straight thru if the expression is false.\n**\n** If the expression evaluates to NULL (neither true nor false), then\n** take the jump if the jumpIfNull flag is SQLITE_JUMPIFNULL.\n**\n** This code depends on the fact that certain token values (ex: TK_EQ)\n** are the same as opcode values (ex: OP_Eq) that implement the corresponding\n** operation.  Special comments in vdbe.c and the mkopcodeh.awk script in\n** the make process cause these values to align.  Assert()s in the code\n** below verify that the numbers are aligned correctly.\n*/\nvoid sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){\n  Vdbe *v = pParse->pVdbe;\n  int op = 0;\n  int regFree1 = 0;\n  int regFree2 = 0;\n  int r1, r2;\n\n  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );\n  if( NEVER(v==0) )     return;  /* Existence of VDBE checked by caller */\n  if( NEVER(pExpr==0) ) return;  /* No way this can happen */\n  op = pExpr->op;\n  switch( op ){\n    case TK_AND:\n    case TK_OR: {\n      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n      if( pAlt!=pExpr ){\n        sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);\n      }else if( op==TK_AND ){\n        int d2 = sqlite3VdbeMakeLabel(pParse);\n        testcase( jumpIfNull==0 );\n        sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2,\n                           jumpIfNull^SQLITE_JUMPIFNULL);\n        sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n        sqlite3VdbeResolveLabel(v, d2);\n      }else{\n        testcase( jumpIfNull==0 );\n        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n        sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n      }\n      break;\n    }\n    case TK_NOT: {\n      testcase( jumpIfNull==0 );\n      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n      break;\n    }\n    case TK_TRUTH: {\n      int isNot;      /* IS NOT TRUE or IS NOT FALSE */\n      int isTrue;     /* IS TRUE or IS NOT TRUE */\n      testcase( jumpIfNull==0 );\n      isNot = pExpr->op2==TK_ISNOT;\n      isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n      testcase( isTrue && isNot );\n      testcase( !isTrue && isNot );\n      if( isTrue ^ isNot ){\n        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,\n                          isNot ? SQLITE_JUMPIFNULL : 0);\n      }else{\n        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,\n                           isNot ? SQLITE_JUMPIFNULL : 0);\n      }\n      break;\n    }\n    case TK_IS:\n    case TK_ISNOT:\n      testcase( op==TK_IS );\n      testcase( op==TK_ISNOT );\n      op = (op==TK_IS) ? TK_EQ : TK_NE;\n      jumpIfNull = SQLITE_NULLEQ;\n      /* Fall thru */\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;\n      testcase( jumpIfNull==0 );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,\n                  r1, r2, dest, jumpIfNull, ExprHasProperty(pExpr,EP_Commuted));\n      assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n      assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n      assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n      assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n      assert(TK_EQ==OP_Eq); testcase(op==OP_Eq);\n      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull==SQLITE_NULLEQ);\n      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull!=SQLITE_NULLEQ);\n      assert(TK_NE==OP_Ne); testcase(op==OP_Ne);\n      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull==SQLITE_NULLEQ);\n      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull!=SQLITE_NULLEQ);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      assert( TK_ISNULL==OP_IsNull );   testcase( op==TK_ISNULL );\n      assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      sqlite3VdbeAddOp2(v, op, r1, dest);\n      VdbeCoverageIf(v, op==TK_ISNULL);\n      VdbeCoverageIf(v, op==TK_NOTNULL);\n      testcase( regFree1==0 );\n      break;\n    }\n    case TK_BETWEEN: {\n      testcase( jumpIfNull==0 );\n      exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_IN: {\n      int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n      int destIfNull = jumpIfNull ? dest : destIfFalse;\n      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n      sqlite3VdbeGoto(v, dest);\n      sqlite3VdbeResolveLabel(v, destIfFalse);\n      break;\n    }\n#endif\n    default: {\n    default_expr:\n      if( ExprAlwaysTrue(pExpr) ){\n        sqlite3VdbeGoto(v, dest);\n      }else if( ExprAlwaysFalse(pExpr) ){\n        /* No-op */\n      }else{\n        r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n        sqlite3VdbeAddOp3(v, OP_If, r1, dest, jumpIfNull!=0);\n        VdbeCoverage(v);\n        testcase( regFree1==0 );\n        testcase( jumpIfNull==0 );\n      }\n      break;\n    }\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);  \n}\n\n/*\n** Generate code for a boolean expression such that a jump is made\n** to the label \"dest\" if the expression is false but execution\n** continues straight thru if the expression is true.\n**\n** If the expression evaluates to NULL (neither true nor false) then\n** jump if jumpIfNull is SQLITE_JUMPIFNULL or fall through if jumpIfNull\n** is 0.\n*/\nvoid sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){\n  Vdbe *v = pParse->pVdbe;\n  int op = 0;\n  int regFree1 = 0;\n  int regFree2 = 0;\n  int r1, r2;\n\n  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );\n  if( NEVER(v==0) ) return; /* Existence of VDBE checked by caller */\n  if( pExpr==0 )    return;\n\n  /* The value of pExpr->op and op are related as follows:\n  **\n  **       pExpr->op            op\n  **       ---------          ----------\n  **       TK_ISNULL          OP_NotNull\n  **       TK_NOTNULL         OP_IsNull\n  **       TK_NE              OP_Eq\n  **       TK_EQ              OP_Ne\n  **       TK_GT              OP_Le\n  **       TK_LE              OP_Gt\n  **       TK_GE              OP_Lt\n  **       TK_LT              OP_Ge\n  **\n  ** For other values of pExpr->op, op is undefined and unused.\n  ** The value of TK_ and OP_ constants are arranged such that we\n  ** can compute the mapping above using the following expression.\n  ** Assert()s verify that the computation is correct.\n  */\n  op = ((pExpr->op+(TK_ISNULL&1))^1)-(TK_ISNULL&1);\n\n  /* Verify correct alignment of TK_ and OP_ constants\n  */\n  assert( pExpr->op!=TK_ISNULL || op==OP_NotNull );\n  assert( pExpr->op!=TK_NOTNULL || op==OP_IsNull );\n  assert( pExpr->op!=TK_NE || op==OP_Eq );\n  assert( pExpr->op!=TK_EQ || op==OP_Ne );\n  assert( pExpr->op!=TK_LT || op==OP_Ge );\n  assert( pExpr->op!=TK_LE || op==OP_Gt );\n  assert( pExpr->op!=TK_GT || op==OP_Le );\n  assert( pExpr->op!=TK_GE || op==OP_Lt );\n\n  switch( pExpr->op ){\n    case TK_AND:\n    case TK_OR: {\n      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n      if( pAlt!=pExpr ){\n        sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);\n      }else if( pExpr->op==TK_AND ){\n        testcase( jumpIfNull==0 );\n        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n        sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n      }else{\n        int d2 = sqlite3VdbeMakeLabel(pParse);\n        testcase( jumpIfNull==0 );\n        sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2,\n                          jumpIfNull^SQLITE_JUMPIFNULL);\n        sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n        sqlite3VdbeResolveLabel(v, d2);\n      }\n      break;\n    }\n    case TK_NOT: {\n      testcase( jumpIfNull==0 );\n      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n      break;\n    }\n    case TK_TRUTH: {\n      int isNot;   /* IS NOT TRUE or IS NOT FALSE */\n      int isTrue;  /* IS TRUE or IS NOT TRUE */\n      testcase( jumpIfNull==0 );\n      isNot = pExpr->op2==TK_ISNOT;\n      isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n      testcase( isTrue && isNot );\n      testcase( !isTrue && isNot );\n      if( isTrue ^ isNot ){\n        /* IS TRUE and IS NOT FALSE */\n        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,\n                           isNot ? 0 : SQLITE_JUMPIFNULL);\n\n      }else{\n        /* IS FALSE and IS NOT TRUE */\n        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,\n                          isNot ? 0 : SQLITE_JUMPIFNULL);\n      }\n      break;\n    }\n    case TK_IS:\n    case TK_ISNOT:\n      testcase( pExpr->op==TK_IS );\n      testcase( pExpr->op==TK_ISNOT );\n      op = (pExpr->op==TK_IS) ? TK_NE : TK_EQ;\n      jumpIfNull = SQLITE_NULLEQ;\n      /* Fall thru */\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;\n      testcase( jumpIfNull==0 );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,\n                  r1, r2, dest, jumpIfNull,ExprHasProperty(pExpr,EP_Commuted));\n      assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n      assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n      assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n      assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n      assert(TK_EQ==OP_Eq); testcase(op==OP_Eq);\n      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull!=SQLITE_NULLEQ);\n      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull==SQLITE_NULLEQ);\n      assert(TK_NE==OP_Ne); testcase(op==OP_Ne);\n      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull!=SQLITE_NULLEQ);\n      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull==SQLITE_NULLEQ);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      sqlite3VdbeAddOp2(v, op, r1, dest);\n      testcase( op==TK_ISNULL );   VdbeCoverageIf(v, op==TK_ISNULL);\n      testcase( op==TK_NOTNULL );  VdbeCoverageIf(v, op==TK_NOTNULL);\n      testcase( regFree1==0 );\n      break;\n    }\n    case TK_BETWEEN: {\n      testcase( jumpIfNull==0 );\n      exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_IN: {\n      if( jumpIfNull ){\n        sqlite3ExprCodeIN(pParse, pExpr, dest, dest);\n      }else{\n        int destIfNull = sqlite3VdbeMakeLabel(pParse);\n        sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);\n        sqlite3VdbeResolveLabel(v, destIfNull);\n      }\n      break;\n    }\n#endif\n    default: {\n    default_expr: \n      if( ExprAlwaysFalse(pExpr) ){\n        sqlite3VdbeGoto(v, dest);\n      }else if( ExprAlwaysTrue(pExpr) ){\n        /* no-op */\n      }else{\n        r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n        sqlite3VdbeAddOp3(v, OP_IfNot, r1, dest, jumpIfNull!=0);\n        VdbeCoverage(v);\n        testcase( regFree1==0 );\n        testcase( jumpIfNull==0 );\n      }\n      break;\n    }\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);\n}\n\n/*\n** Like sqlite3ExprIfFalse() except that a copy is made of pExpr before\n** code generation, and that copy is deleted after code generation. This\n** ensures that the original pExpr is unchanged.\n*/\nvoid sqlite3ExprIfFalseDup(Parse *pParse, Expr *pExpr, int dest,int jumpIfNull){\n  sqlite3 *db = pParse->db;\n  Expr *pCopy = sqlite3ExprDup(db, pExpr, 0);\n  if( db->mallocFailed==0 ){\n    sqlite3ExprIfFalse(pParse, pCopy, dest, jumpIfNull);\n  }\n  sqlite3ExprDelete(db, pCopy);\n}\n\n/*\n** Expression pVar is guaranteed to be an SQL variable. pExpr may be any\n** type of expression.\n**\n** If pExpr is a simple SQL value - an integer, real, string, blob\n** or NULL value - then the VDBE currently being prepared is configured\n** to re-prepare each time a new value is bound to variable pVar.\n**\n** Additionally, if pExpr is a simple SQL value and the value is the\n** same as that currently bound to variable pVar, non-zero is returned.\n** Otherwise, if the values are not the same or if pExpr is not a simple\n** SQL value, zero is returned.\n*/\nstatic int exprCompareVariable(Parse *pParse, Expr *pVar, Expr *pExpr){\n  int res = 0;\n  int iVar;\n  sqlite3_value *pL, *pR = 0;\n  \n  sqlite3ValueFromExpr(pParse->db, pExpr, SQLITE_UTF8, SQLITE_AFF_BLOB, &pR);\n  if( pR ){\n    iVar = pVar->iColumn;\n    sqlite3VdbeSetVarmask(pParse->pVdbe, iVar);\n    pL = sqlite3VdbeGetBoundValue(pParse->pReprepare, iVar, SQLITE_AFF_BLOB);\n    if( pL ){\n      if( sqlite3_value_type(pL)==SQLITE_TEXT ){\n        sqlite3_value_text(pL); /* Make sure the encoding is UTF-8 */\n      }\n      res =  0==sqlite3MemCompare(pL, pR, 0);\n    }\n    sqlite3ValueFree(pR);\n    sqlite3ValueFree(pL);\n  }\n\n  return res;\n}\n\n/*\n** Do a deep comparison of two expression trees.  Return 0 if the two\n** expressions are completely identical.  Return 1 if they differ only\n** by a COLLATE operator at the top level.  Return 2 if there are differences\n** other than the top-level COLLATE operator.\n**\n** If any subelement of pB has Expr.iTable==(-1) then it is allowed\n** to compare equal to an equivalent element in pA with Expr.iTable==iTab.\n**\n** The pA side might be using TK_REGISTER.  If that is the case and pB is\n** not using TK_REGISTER but is otherwise equivalent, then still return 0.\n**\n** Sometimes this routine will return 2 even if the two expressions\n** really are equivalent.  If we cannot prove that the expressions are\n** identical, we return 2 just to be safe.  So if this routine\n** returns 2, then you do not really know for certain if the two\n** expressions are the same.  But if you get a 0 or 1 return, then you\n** can be sure the expressions are the same.  In the places where\n** this routine is used, it does not hurt to get an extra 2 - that\n** just might result in some slightly slower code.  But returning\n** an incorrect 0 or 1 could lead to a malfunction.\n**\n** If pParse is not NULL then TK_VARIABLE terms in pA with bindings in\n** pParse->pReprepare can be matched against literals in pB.  The \n** pParse->pVdbe->expmask bitmask is updated for each variable referenced.\n** If pParse is NULL (the normal case) then any TK_VARIABLE term in \n** Argument pParse should normally be NULL. If it is not NULL and pA or\n** pB causes a return value of 2.\n*/\nint sqlite3ExprCompare(Parse *pParse, Expr *pA, Expr *pB, int iTab){\n  u32 combinedFlags;\n  if( pA==0 || pB==0 ){\n    return pB==pA ? 0 : 2;\n  }\n  if( pParse && pA->op==TK_VARIABLE && exprCompareVariable(pParse, pA, pB) ){\n    return 0;\n  }\n  combinedFlags = pA->flags | pB->flags;\n  if( combinedFlags & EP_IntValue ){\n    if( (pA->flags&pB->flags&EP_IntValue)!=0 && pA->u.iValue==pB->u.iValue ){\n      return 0;\n    }\n    return 2;\n  }\n  if( pA->op!=pB->op || pA->op==TK_RAISE ){\n    if( pA->op==TK_COLLATE && sqlite3ExprCompare(pParse, pA->pLeft,pB,iTab)<2 ){\n      return 1;\n    }\n    if( pB->op==TK_COLLATE && sqlite3ExprCompare(pParse, pA,pB->pLeft,iTab)<2 ){\n      return 1;\n    }\n    return 2;\n  }\n  if( pA->op!=TK_COLUMN && pA->op!=TK_AGG_COLUMN && pA->u.zToken ){\n    if( pA->op==TK_FUNCTION || pA->op==TK_AGG_FUNCTION ){\n      if( sqlite3StrICmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      assert( pA->op==pB->op );\n      if( ExprHasProperty(pA,EP_WinFunc)!=ExprHasProperty(pB,EP_WinFunc) ){\n        return 2;\n      }\n      if( ExprHasProperty(pA,EP_WinFunc) ){\n        if( sqlite3WindowCompare(pParse, pA->y.pWin, pB->y.pWin, 1)!=0 ){\n          return 2;\n        }\n      }\n#endif\n    }else if( pA->op==TK_NULL ){\n      return 0;\n    }else if( pA->op==TK_COLLATE ){\n      if( sqlite3_stricmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;\n    }else if( ALWAYS(pB->u.zToken!=0) && strcmp(pA->u.zToken,pB->u.zToken)!=0 ){\n      return 2;\n    }\n  }\n  if( (pA->flags & (EP_Distinct|EP_Commuted))\n     != (pB->flags & (EP_Distinct|EP_Commuted)) ) return 2;\n  if( (combinedFlags & EP_TokenOnly)==0 ){\n    if( combinedFlags & EP_xIsSelect ) return 2;\n    if( (combinedFlags & EP_FixedCol)==0\n     && sqlite3ExprCompare(pParse, pA->pLeft, pB->pLeft, iTab) ) return 2;\n    if( sqlite3ExprCompare(pParse, pA->pRight, pB->pRight, iTab) ) return 2;\n    if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab) ) return 2;\n    if( pA->op!=TK_STRING\n     && pA->op!=TK_TRUEFALSE\n     && (combinedFlags & EP_Reduced)==0\n    ){\n      if( pA->iColumn!=pB->iColumn ) return 2;\n      if( pA->op2!=pB->op2 ){\n        if( pA->op==TK_TRUTH ) return 2;\n        if( pA->op==TK_FUNCTION && iTab<0 ){\n          /* Ex: CREATE TABLE t1(a CHECK( a<julianday('now') ));\n          **     INSERT INTO t1(a) VALUES(julianday('now')+10);\n          ** Without this test, sqlite3ExprCodeAtInit() will run on the\n          ** the julianday() of INSERT first, and remember that expression.\n          ** Then sqlite3ExprCodeInit() will see the julianday() in the CHECK\n          ** constraint as redundant, reusing the one from the INSERT, even\n          ** though the julianday() in INSERT lacks the critical NC_IsCheck\n          ** flag.  See ticket [830277d9db6c3ba1] (2019-10-30)\n          */\n          return 2;\n        }\n      }\n      if( pA->op!=TK_IN && pA->iTable!=pB->iTable && pA->iTable!=iTab ){\n        return 2;\n      }\n    }\n  }\n  return 0;\n}\n\n/*\n** Compare two ExprList objects.  Return 0 if they are identical and \n** non-zero if they differ in any way.\n**\n** If any subelement of pB has Expr.iTable==(-1) then it is allowed\n** to compare equal to an equivalent element in pA with Expr.iTable==iTab.\n**\n** This routine might return non-zero for equivalent ExprLists.  The\n** only consequence will be disabled optimizations.  But this routine\n** must never return 0 if the two ExprList objects are different, or\n** a malfunction will result.\n**\n** Two NULL pointers are considered to be the same.  But a NULL pointer\n** always differs from a non-NULL pointer.\n*/\nint sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){\n  int i;\n  if( pA==0 && pB==0 ) return 0;\n  if( pA==0 || pB==0 ) return 1;\n  if( pA->nExpr!=pB->nExpr ) return 1;\n  for(i=0; i<pA->nExpr; i++){\n    Expr *pExprA = pA->a[i].pExpr;\n    Expr *pExprB = pB->a[i].pExpr;\n    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;\n    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;\n  }\n  return 0;\n}\n\n/*\n** Like sqlite3ExprCompare() except COLLATE operators at the top-level\n** are ignored.\n*/\nint sqlite3ExprCompareSkip(Expr *pA, Expr *pB, int iTab){\n  return sqlite3ExprCompare(0,\n             sqlite3ExprSkipCollateAndLikely(pA),\n             sqlite3ExprSkipCollateAndLikely(pB),\n             iTab);\n}\n\n/*\n** Return non-zero if Expr p can only be true if pNN is not NULL.\n**\n** Or if seenNot is true, return non-zero if Expr p can only be\n** non-NULL if pNN is not NULL\n*/\nstatic int exprImpliesNotNull(\n  Parse *pParse,      /* Parsing context */\n  Expr *p,            /* The expression to be checked */\n  Expr *pNN,          /* The expression that is NOT NULL */\n  int iTab,           /* Table being evaluated */\n  int seenNot         /* Return true only if p can be any non-NULL value */\n){\n  assert( p );\n  assert( pNN );\n  if( sqlite3ExprCompare(pParse, p, pNN, iTab)==0 ){\n    return pNN->op!=TK_NULL;\n  }\n  switch( p->op ){\n    case TK_IN: {\n      if( seenNot && ExprHasProperty(p, EP_xIsSelect) ) return 0;\n      assert( ExprHasProperty(p,EP_xIsSelect)\n           || (p->x.pList!=0 && p->x.pList->nExpr>0) );\n      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n    }\n    case TK_BETWEEN: {\n      ExprList *pList = p->x.pList;\n      assert( pList!=0 );\n      assert( pList->nExpr==2 );\n      if( seenNot ) return 0;\n      if( exprImpliesNotNull(pParse, pList->a[0].pExpr, pNN, iTab, 1)\n       || exprImpliesNotNull(pParse, pList->a[1].pExpr, pNN, iTab, 1)\n      ){\n        return 1;\n      }\n      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n    }\n    case TK_EQ:\n    case TK_NE:\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_PLUS:\n    case TK_MINUS:\n    case TK_BITOR:\n    case TK_LSHIFT:\n    case TK_RSHIFT: \n    case TK_CONCAT: \n      seenNot = 1;\n      /* Fall thru */\n    case TK_STAR:\n    case TK_REM:\n    case TK_BITAND:\n    case TK_SLASH: {\n      if( exprImpliesNotNull(pParse, p->pRight, pNN, iTab, seenNot) ) return 1;\n      /* Fall thru into the next case */\n    }\n    case TK_SPAN:\n    case TK_COLLATE:\n    case TK_UPLUS:\n    case TK_UMINUS: {\n      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, seenNot);\n    }\n    case TK_TRUTH: {\n      if( seenNot ) return 0;\n      if( p->op2!=TK_IS ) return 0;\n      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n    }\n    case TK_BITNOT:\n    case TK_NOT: {\n      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n    }\n  }\n  return 0;\n}\n\n/*\n** Return true if we can prove the pE2 will always be true if pE1 is\n** true.  Return false if we cannot complete the proof or if pE2 might\n** be false.  Examples:\n**\n**     pE1: x==5       pE2: x==5             Result: true\n**     pE1: x>0        pE2: x==5             Result: false\n**     pE1: x=21       pE2: x=21 OR y=43     Result: true\n**     pE1: x!=123     pE2: x IS NOT NULL    Result: true\n**     pE1: x!=?1      pE2: x IS NOT NULL    Result: true\n**     pE1: x IS NULL  pE2: x IS NOT NULL    Result: false\n**     pE1: x IS ?2    pE2: x IS NOT NULL    Reuslt: false\n**\n** When comparing TK_COLUMN nodes between pE1 and pE2, if pE2 has\n** Expr.iTable<0 then assume a table number given by iTab.\n**\n** If pParse is not NULL, then the values of bound variables in pE1 are \n** compared against literal values in pE2 and pParse->pVdbe->expmask is\n** modified to record which bound variables are referenced.  If pParse \n** is NULL, then false will be returned if pE1 contains any bound variables.\n**\n** When in doubt, return false.  Returning true might give a performance\n** improvement.  Returning false might cause a performance reduction, but\n** it will always give the correct answer and is hence always safe.\n*/\nint sqlite3ExprImpliesExpr(Parse *pParse, Expr *pE1, Expr *pE2, int iTab){\n  if( sqlite3ExprCompare(pParse, pE1, pE2, iTab)==0 ){\n    return 1;\n  }\n  if( pE2->op==TK_OR\n   && (sqlite3ExprImpliesExpr(pParse, pE1, pE2->pLeft, iTab)\n             || sqlite3ExprImpliesExpr(pParse, pE1, pE2->pRight, iTab) )\n  ){\n    return 1;\n  }\n  if( pE2->op==TK_NOTNULL\n   && exprImpliesNotNull(pParse, pE1, pE2->pLeft, iTab, 0)\n  ){\n    return 1;\n  }\n  return 0;\n}\n\n/*\n** This is the Expr node callback for sqlite3ExprImpliesNonNullRow().\n** If the expression node requires that the table at pWalker->iCur\n** have one or more non-NULL column, then set pWalker->eCode to 1 and abort.\n**\n** This routine controls an optimization.  False positives (setting\n** pWalker->eCode to 1 when it should not be) are deadly, but false-negatives\n** (never setting pWalker->eCode) is a harmless missed optimization.\n*/\nstatic int impliesNotNullRow(Walker *pWalker, Expr *pExpr){\n  testcase( pExpr->op==TK_AGG_COLUMN );\n  testcase( pExpr->op==TK_AGG_FUNCTION );\n  if( ExprHasProperty(pExpr, EP_FromJoin) ) return WRC_Prune;\n  switch( pExpr->op ){\n    case TK_ISNOT:\n    case TK_ISNULL:\n    case TK_NOTNULL:\n    case TK_IS:\n    case TK_OR:\n    case TK_VECTOR:\n    case TK_CASE:\n    case TK_IN:\n    case TK_FUNCTION:\n    case TK_TRUTH:\n      testcase( pExpr->op==TK_ISNOT );\n      testcase( pExpr->op==TK_ISNULL );\n      testcase( pExpr->op==TK_NOTNULL );\n      testcase( pExpr->op==TK_IS );\n      testcase( pExpr->op==TK_OR );\n      testcase( pExpr->op==TK_VECTOR );\n      testcase( pExpr->op==TK_CASE );\n      testcase( pExpr->op==TK_IN );\n      testcase( pExpr->op==TK_FUNCTION );\n      testcase( pExpr->op==TK_TRUTH );\n      return WRC_Prune;\n    case TK_COLUMN:\n      if( pWalker->u.iCur==pExpr->iTable ){\n        pWalker->eCode = 1;\n        return WRC_Abort;\n      }\n      return WRC_Prune;\n\n    case TK_AND:\n      assert( pWalker->eCode==0 );\n      sqlite3WalkExpr(pWalker, pExpr->pLeft);\n      if( pWalker->eCode ){\n        pWalker->eCode = 0;\n        sqlite3WalkExpr(pWalker, pExpr->pRight);\n      }\n      return WRC_Prune;\n\n    case TK_BETWEEN:\n      sqlite3WalkExpr(pWalker, pExpr->pLeft);\n      return WRC_Prune;\n\n    /* Virtual tables are allowed to use constraints like x=NULL.  So\n    ** a term of the form x=y does not prove that y is not null if x\n    ** is the column of a virtual table */\n    case TK_EQ:\n    case TK_NE:\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n      testcase( pExpr->op==TK_EQ );\n      testcase( pExpr->op==TK_NE );\n      testcase( pExpr->op==TK_LT );\n      testcase( pExpr->op==TK_LE );\n      testcase( pExpr->op==TK_GT );\n      testcase( pExpr->op==TK_GE );\n      if( (pExpr->pLeft->op==TK_COLUMN && IsVirtual(pExpr->pLeft->y.pTab))\n       || (pExpr->pRight->op==TK_COLUMN && IsVirtual(pExpr->pRight->y.pTab))\n      ){\n       return WRC_Prune;\n      }\n\n    default:\n      return WRC_Continue;\n  }\n}\n\n/*\n** Return true (non-zero) if expression p can only be true if at least\n** one column of table iTab is non-null.  In other words, return true\n** if expression p will always be NULL or false if every column of iTab\n** is NULL.\n**\n** False negatives are acceptable.  In other words, it is ok to return\n** zero even if expression p will never be true of every column of iTab\n** is NULL.  A false negative is merely a missed optimization opportunity.\n**\n** False positives are not allowed, however.  A false positive may result\n** in an incorrect answer.\n**\n** Terms of p that are marked with EP_FromJoin (and hence that come from\n** the ON or USING clauses of LEFT JOINS) are excluded from the analysis.\n**\n** This routine is used to check if a LEFT JOIN can be converted into\n** an ordinary JOIN.  The p argument is the WHERE clause.  If the WHERE\n** clause requires that some column of the right table of the LEFT JOIN\n** be non-NULL, then the LEFT JOIN can be safely converted into an\n** ordinary join.\n*/\nint sqlite3ExprImpliesNonNullRow(Expr *p, int iTab){\n  Walker w;\n  p = sqlite3ExprSkipCollateAndLikely(p);\n  if( p==0 ) return 0;\n  if( p->op==TK_NOTNULL ){\n    p = p->pLeft;\n  }else{\n    while( p->op==TK_AND ){\n      if( sqlite3ExprImpliesNonNullRow(p->pLeft, iTab) ) return 1;\n      p = p->pRight;\n    }\n  }\n  w.xExprCallback = impliesNotNullRow;\n  w.xSelectCallback = 0;\n  w.xSelectCallback2 = 0;\n  w.eCode = 0;\n  w.u.iCur = iTab;\n  sqlite3WalkExpr(&w, p);\n  return w.eCode;\n}\n\n/*\n** An instance of the following structure is used by the tree walker\n** to determine if an expression can be evaluated by reference to the\n** index only, without having to do a search for the corresponding\n** table entry.  The IdxCover.pIdx field is the index.  IdxCover.iCur\n** is the cursor for the table.\n*/\nstruct IdxCover {\n  Index *pIdx;     /* The index to be tested for coverage */\n  int iCur;        /* Cursor number for the table corresponding to the index */\n};\n\n/*\n** Check to see if there are references to columns in table \n** pWalker->u.pIdxCover->iCur can be satisfied using the index\n** pWalker->u.pIdxCover->pIdx.\n*/\nstatic int exprIdxCover(Walker *pWalker, Expr *pExpr){\n  if( pExpr->op==TK_COLUMN\n   && pExpr->iTable==pWalker->u.pIdxCover->iCur\n   && sqlite3TableColumnToIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0\n  ){\n    pWalker->eCode = 1;\n    return WRC_Abort;\n  }\n  return WRC_Continue;\n}\n\n/*\n** Determine if an index pIdx on table with cursor iCur contains will\n** the expression pExpr.  Return true if the index does cover the\n** expression and false if the pExpr expression references table columns\n** that are not found in the index pIdx.\n**\n** An index covering an expression means that the expression can be\n** evaluated using only the index and without having to lookup the\n** corresponding table entry.\n*/\nint sqlite3ExprCoveredByIndex(\n  Expr *pExpr,        /* The index to be tested */\n  int iCur,           /* The cursor number for the corresponding table */\n  Index *pIdx         /* The index that might be used for coverage */\n){\n  Walker w;\n  struct IdxCover xcov;\n  memset(&w, 0, sizeof(w));\n  xcov.iCur = iCur;\n  xcov.pIdx = pIdx;\n  w.xExprCallback = exprIdxCover;\n  w.u.pIdxCover = &xcov;\n  sqlite3WalkExpr(&w, pExpr);\n  return !w.eCode;\n}\n\n\n/*\n** An instance of the following structure is used by the tree walker\n** to count references to table columns in the arguments of an \n** aggregate function, in order to implement the\n** sqlite3FunctionThisSrc() routine.\n*/\nstruct SrcCount {\n  SrcList *pSrc;   /* One particular FROM clause in a nested query */\n  int nThis;       /* Number of references to columns in pSrcList */\n  int nOther;      /* Number of references to columns in other FROM clauses */\n};\n\n/*\n** Count the number of references to columns.\n*/\nstatic int exprSrcCount(Walker *pWalker, Expr *pExpr){\n  /* The NEVER() on the second term is because sqlite3FunctionUsesThisSrc()\n  ** is always called before sqlite3ExprAnalyzeAggregates() and so the\n  ** TK_COLUMNs have not yet been converted into TK_AGG_COLUMN.  If\n  ** sqlite3FunctionUsesThisSrc() is used differently in the future, the\n  ** NEVER() will need to be removed. */\n  if( pExpr->op==TK_COLUMN || NEVER(pExpr->op==TK_AGG_COLUMN) ){\n    int i;\n    struct SrcCount *p = pWalker->u.pSrcCount;\n    SrcList *pSrc = p->pSrc;\n    int nSrc = pSrc ? pSrc->nSrc : 0;\n    for(i=0; i<nSrc; i++){\n      if( pExpr->iTable==pSrc->a[i].iCursor ) break;\n    }\n    if( i<nSrc ){\n      p->nThis++;\n    }else if( nSrc==0 || pExpr->iTable<pSrc->a[0].iCursor ){\n      /* In a well-formed parse tree (no name resolution errors),\n      ** TK_COLUMN nodes with smaller Expr.iTable values are in an\n      ** outer context.  Those are the only ones to count as \"other\" */\n      p->nOther++;\n    }\n  }\n  return WRC_Continue;\n}\n\n/*\n** Determine if any of the arguments to the pExpr Function reference\n** pSrcList.  Return true if they do.  Also return true if the function\n** has no arguments or has only constant arguments.  Return false if pExpr\n** references columns but not columns of tables found in pSrcList.\n*/\nint sqlite3FunctionUsesThisSrc(Expr *pExpr, SrcList *pSrcList){\n  Walker w;\n  struct SrcCount cnt;\n  assert( pExpr->op==TK_AGG_FUNCTION );\n  memset(&w, 0, sizeof(w));\n  w.xExprCallback = exprSrcCount;\n  w.xSelectCallback = sqlite3SelectWalkNoop;\n  w.u.pSrcCount = &cnt;\n  cnt.pSrc = pSrcList;\n  cnt.nThis = 0;\n  cnt.nOther = 0;\n  sqlite3WalkExprList(&w, pExpr->x.pList);\n  return cnt.nThis>0 || cnt.nOther==0;\n}\n\n/*\n** Add a new element to the pAggInfo->aCol[] array.  Return the index of\n** the new element.  Return a negative number if malloc fails.\n*/\nstatic int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){\n  int i;\n  pInfo->aCol = sqlite3ArrayAllocate(\n       db,\n       pInfo->aCol,\n       sizeof(pInfo->aCol[0]),\n       &pInfo->nColumn,\n       &i\n  );\n  return i;\n}    \n\n/*\n** Add a new element to the pAggInfo->aFunc[] array.  Return the index of\n** the new element.  Return a negative number if malloc fails.\n*/\nstatic int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){\n  int i;\n  pInfo->aFunc = sqlite3ArrayAllocate(\n       db, \n       pInfo->aFunc,\n       sizeof(pInfo->aFunc[0]),\n       &pInfo->nFunc,\n       &i\n  );\n  return i;\n}    \n\n/*\n** This is the xExprCallback for a tree walker.  It is used to\n** implement sqlite3ExprAnalyzeAggregates().  See sqlite3ExprAnalyzeAggregates\n** for additional information.\n*/\nstatic int analyzeAggregate(Walker *pWalker, Expr *pExpr){\n  int i;\n  NameContext *pNC = pWalker->u.pNC;\n  Parse *pParse = pNC->pParse;\n  SrcList *pSrcList = pNC->pSrcList;\n  AggInfo *pAggInfo = pNC->uNC.pAggInfo;\n\n  assert( pNC->ncFlags & NC_UAggInfo );\n  switch( pExpr->op ){\n    case TK_AGG_COLUMN:\n    case TK_COLUMN: {\n      testcase( pExpr->op==TK_AGG_COLUMN );\n      testcase( pExpr->op==TK_COLUMN );\n      /* Check to see if the column is in one of the tables in the FROM\n      ** clause of the aggregate query */\n      if( ALWAYS(pSrcList!=0) ){\n        struct SrcList_item *pItem = pSrcList->a;\n        for(i=0; i<pSrcList->nSrc; i++, pItem++){\n          struct AggInfo_col *pCol;\n          assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n          if( pExpr->iTable==pItem->iCursor ){\n            /* If we reach this point, it means that pExpr refers to a table\n            ** that is in the FROM clause of the aggregate query.  \n            **\n            ** Make an entry for the column in pAggInfo->aCol[] if there\n            ** is not an entry there already.\n            */\n            int k;\n            pCol = pAggInfo->aCol;\n            for(k=0; k<pAggInfo->nColumn; k++, pCol++){\n              if( pCol->iTable==pExpr->iTable &&\n                  pCol->iColumn==pExpr->iColumn ){\n                break;\n              }\n            }\n            if( (k>=pAggInfo->nColumn)\n             && (k = addAggInfoColumn(pParse->db, pAggInfo))>=0 \n            ){\n              pCol = &pAggInfo->aCol[k];\n              pCol->pTab = pExpr->y.pTab;\n              pCol->iTable = pExpr->iTable;\n              pCol->iColumn = pExpr->iColumn;\n              pCol->iMem = ++pParse->nMem;\n              pCol->iSorterColumn = -1;\n              pCol->pExpr = pExpr;\n              if( pAggInfo->pGroupBy ){\n                int j, n;\n                ExprList *pGB = pAggInfo->pGroupBy;\n                struct ExprList_item *pTerm = pGB->a;\n                n = pGB->nExpr;\n                for(j=0; j<n; j++, pTerm++){\n                  Expr *pE = pTerm->pExpr;\n                  if( pE->op==TK_COLUMN && pE->iTable==pExpr->iTable &&\n                      pE->iColumn==pExpr->iColumn ){\n                    pCol->iSorterColumn = j;\n                    break;\n                  }\n                }\n              }\n              if( pCol->iSorterColumn<0 ){\n                pCol->iSorterColumn = pAggInfo->nSortingColumn++;\n              }\n            }\n            /* There is now an entry for pExpr in pAggInfo->aCol[] (either\n            ** because it was there before or because we just created it).\n            ** Convert the pExpr to be a TK_AGG_COLUMN referring to that\n            ** pAggInfo->aCol[] entry.\n            */\n            ExprSetVVAProperty(pExpr, EP_NoReduce);\n            pExpr->pAggInfo = pAggInfo;\n            pExpr->op = TK_AGG_COLUMN;\n            pExpr->iAgg = (i16)k;\n            break;\n          } /* endif pExpr->iTable==pItem->iCursor */\n        } /* end loop over pSrcList */\n      }\n      return WRC_Prune;\n    }\n    case TK_AGG_FUNCTION: {\n      if( (pNC->ncFlags & NC_InAggFunc)==0\n       && pWalker->walkerDepth==pExpr->op2\n      ){\n        /* Check to see if pExpr is a duplicate of another aggregate \n        ** function that is already in the pAggInfo structure\n        */\n        struct AggInfo_func *pItem = pAggInfo->aFunc;\n        for(i=0; i<pAggInfo->nFunc; i++, pItem++){\n          if( sqlite3ExprCompare(0, pItem->pExpr, pExpr, -1)==0 ){\n            break;\n          }\n        }\n        if( i>=pAggInfo->nFunc ){\n          /* pExpr is original.  Make a new entry in pAggInfo->aFunc[]\n          */\n          u8 enc = ENC(pParse->db);\n          i = addAggInfoFunc(pParse->db, pAggInfo);\n          if( i>=0 ){\n            assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n            pItem = &pAggInfo->aFunc[i];\n            pItem->pExpr = pExpr;\n            pItem->iMem = ++pParse->nMem;\n            assert( !ExprHasProperty(pExpr, EP_IntValue) );\n            pItem->pFunc = sqlite3FindFunction(pParse->db,\n                   pExpr->u.zToken, \n                   pExpr->x.pList ? pExpr->x.pList->nExpr : 0, enc, 0);\n            if( pExpr->flags & EP_Distinct ){\n              pItem->iDistinct = pParse->nTab++;\n            }else{\n              pItem->iDistinct = -1;\n            }\n          }\n        }\n        /* Make pExpr point to the appropriate pAggInfo->aFunc[] entry\n        */\n        assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n        ExprSetVVAProperty(pExpr, EP_NoReduce);\n        pExpr->iAgg = (i16)i;\n        pExpr->pAggInfo = pAggInfo;\n        return WRC_Prune;\n      }else{\n        return WRC_Continue;\n      }\n    }\n  }\n  return WRC_Continue;\n}\nstatic int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect){\n  UNUSED_PARAMETER(pSelect);\n  pWalker->walkerDepth++;\n  return WRC_Continue;\n}\nstatic void analyzeAggregatesInSelectEnd(Walker *pWalker, Select *pSelect){\n  UNUSED_PARAMETER(pSelect);\n  pWalker->walkerDepth--;\n}\n\n/*\n** Analyze the pExpr expression looking for aggregate functions and\n** for variables that need to be added to AggInfo object that pNC->pAggInfo\n** points to.  Additional entries are made on the AggInfo object as\n** necessary.\n**\n** This routine should only be called after the expression has been\n** analyzed by sqlite3ResolveExprNames().\n*/\nvoid sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){\n  Walker w;\n  w.xExprCallback = analyzeAggregate;\n  w.xSelectCallback = analyzeAggregatesInSelect;\n  w.xSelectCallback2 = analyzeAggregatesInSelectEnd;\n  w.walkerDepth = 0;\n  w.u.pNC = pNC;\n  w.pParse = 0;\n  assert( pNC->pSrcList!=0 );\n  sqlite3WalkExpr(&w, pExpr);\n}\n\n/*\n** Call sqlite3ExprAnalyzeAggregates() for every expression in an\n** expression list.  Return the number of errors.\n**\n** If an error is found, the analysis is cut short.\n*/\nvoid sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){\n  struct ExprList_item *pItem;\n  int i;\n  if( pList ){\n    for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){\n      sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);\n    }\n  }\n}\n\n/*\n** Allocate a single new register for use to hold some intermediate result.\n*/\nint sqlite3GetTempReg(Parse *pParse){\n  if( pParse->nTempReg==0 ){\n    return ++pParse->nMem;\n  }\n  return pParse->aTempReg[--pParse->nTempReg];\n}\n\n/*\n** Deallocate a register, making available for reuse for some other\n** purpose.\n*/\nvoid sqlite3ReleaseTempReg(Parse *pParse, int iReg){\n  if( iReg && pParse->nTempReg<ArraySize(pParse->aTempReg) ){\n    pParse->aTempReg[pParse->nTempReg++] = iReg;\n  }\n}\n\n/*\n** Allocate or deallocate a block of nReg consecutive registers.\n*/\nint sqlite3GetTempRange(Parse *pParse, int nReg){\n  int i, n;\n  if( nReg==1 ) return sqlite3GetTempReg(pParse);\n  i = pParse->iRangeReg;\n  n = pParse->nRangeReg;\n  if( nReg<=n ){\n    pParse->iRangeReg += nReg;\n    pParse->nRangeReg -= nReg;\n  }else{\n    i = pParse->nMem+1;\n    pParse->nMem += nReg;\n  }\n  return i;\n}\nvoid sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){\n  if( nReg==1 ){\n    sqlite3ReleaseTempReg(pParse, iReg);\n    return;\n  }\n  if( nReg>pParse->nRangeReg ){\n    pParse->nRangeReg = nReg;\n    pParse->iRangeReg = iReg;\n  }\n}\n\n/*\n** Mark all temporary registers as being unavailable for reuse.\n**\n** Always invoke this procedure after coding a subroutine or co-routine\n** that might be invoked from other parts of the code, to ensure that\n** the sub/co-routine does not use registers in common with the code that\n** invokes the sub/co-routine.\n*/\nvoid sqlite3ClearTempRegCache(Parse *pParse){\n  pParse->nTempReg = 0;\n  pParse->nRangeReg = 0;\n}\n\n/*\n** Validate that no temporary register falls within the range of\n** iFirst..iLast, inclusive.  This routine is only call from within assert()\n** statements.\n*/\n#ifdef SQLITE_DEBUG\nint sqlite3NoTempsInRange(Parse *pParse, int iFirst, int iLast){\n  int i;\n  if( pParse->nRangeReg>0\n   && pParse->iRangeReg+pParse->nRangeReg > iFirst\n   && pParse->iRangeReg <= iLast\n  ){\n     return 0;\n  }\n  for(i=0; i<pParse->nTempReg; i++){\n    if( pParse->aTempReg[i]>=iFirst && pParse->aTempReg[i]<=iLast ){\n      return 0;\n    }\n  }\n  return 1;\n}\n#endif /* SQLITE_DEBUG */\n", "/*\n** 2003 September 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used for creating, destroying, and populating\n** a VDBE (or an \"sqlite3_stmt\" as it is known to the outside world.) \n*/\n#include \"sqliteInt.h\"\n#include \"vdbeInt.h\"\n\n/* Forward references */\nstatic void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef);\nstatic void vdbeFreeOpArray(sqlite3 *, Op *, int);\n\n/*\n** Create a new virtual database engine.\n*/\nVdbe *sqlite3VdbeCreate(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  Vdbe *p;\n  p = sqlite3DbMallocRawNN(db, sizeof(Vdbe) );\n  if( p==0 ) return 0;\n  memset(&p->aOp, 0, sizeof(Vdbe)-offsetof(Vdbe,aOp));\n  p->db = db;\n  if( db->pVdbe ){\n    db->pVdbe->pPrev = p;\n  }\n  p->pNext = db->pVdbe;\n  p->pPrev = 0;\n  db->pVdbe = p;\n  p->magic = VDBE_MAGIC_INIT;\n  p->pParse = pParse;\n  pParse->pVdbe = p;\n  assert( pParse->aLabel==0 );\n  assert( pParse->nLabel==0 );\n  assert( p->nOpAlloc==0 );\n  assert( pParse->szOpAlloc==0 );\n  sqlite3VdbeAddOp2(p, OP_Init, 0, 1);\n  return p;\n}\n\n/*\n** Return the Parse object that owns a Vdbe object.\n*/\nParse *sqlite3VdbeParser(Vdbe *p){\n  return p->pParse;\n}\n\n/*\n** Change the error string stored in Vdbe.zErrMsg\n*/\nvoid sqlite3VdbeError(Vdbe *p, const char *zFormat, ...){\n  va_list ap;\n  sqlite3DbFree(p->db, p->zErrMsg);\n  va_start(ap, zFormat);\n  p->zErrMsg = sqlite3VMPrintf(p->db, zFormat, ap);\n  va_end(ap);\n}\n\n/*\n** Remember the SQL string for a prepared statement.\n*/\nvoid sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, u8 prepFlags){\n  if( p==0 ) return;\n  p->prepFlags = prepFlags;\n  if( (prepFlags & SQLITE_PREPARE_SAVESQL)==0 ){\n    p->expmask = 0;\n  }\n  assert( p->zSql==0 );\n  p->zSql = sqlite3DbStrNDup(p->db, z, n);\n}\n\n#ifdef SQLITE_ENABLE_NORMALIZE\n/*\n** Add a new element to the Vdbe->pDblStr list.\n*/\nvoid sqlite3VdbeAddDblquoteStr(sqlite3 *db, Vdbe *p, const char *z){\n  if( p ){\n    int n = sqlite3Strlen30(z);\n    DblquoteStr *pStr = sqlite3DbMallocRawNN(db,\n                            sizeof(*pStr)+n+1-sizeof(pStr->z));\n    if( pStr ){\n      pStr->pNextStr = p->pDblStr;\n      p->pDblStr = pStr;\n      memcpy(pStr->z, z, n+1);\n    }\n  }\n}\n#endif\n\n#ifdef SQLITE_ENABLE_NORMALIZE\n/*\n** zId of length nId is a double-quoted identifier.  Check to see if\n** that identifier is really used as a string literal.\n*/\nint sqlite3VdbeUsesDoubleQuotedString(\n  Vdbe *pVdbe,            /* The prepared statement */\n  const char *zId         /* The double-quoted identifier, already dequoted */\n){\n  DblquoteStr *pStr;\n  assert( zId!=0 );\n  if( pVdbe->pDblStr==0 ) return 0;\n  for(pStr=pVdbe->pDblStr; pStr; pStr=pStr->pNextStr){\n    if( strcmp(zId, pStr->z)==0 ) return 1;\n  }\n  return 0;\n}\n#endif\n\n/*\n** Swap all content between two VDBE structures.\n*/\nvoid sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){\n  Vdbe tmp, *pTmp;\n  char *zTmp;\n  assert( pA->db==pB->db );\n  tmp = *pA;\n  *pA = *pB;\n  *pB = tmp;\n  pTmp = pA->pNext;\n  pA->pNext = pB->pNext;\n  pB->pNext = pTmp;\n  pTmp = pA->pPrev;\n  pA->pPrev = pB->pPrev;\n  pB->pPrev = pTmp;\n  zTmp = pA->zSql;\n  pA->zSql = pB->zSql;\n  pB->zSql = zTmp;\n#ifdef SQLITE_ENABLE_NORMALIZE\n  zTmp = pA->zNormSql;\n  pA->zNormSql = pB->zNormSql;\n  pB->zNormSql = zTmp;\n#endif\n  pB->expmask = pA->expmask;\n  pB->prepFlags = pA->prepFlags;\n  memcpy(pB->aCounter, pA->aCounter, sizeof(pB->aCounter));\n  pB->aCounter[SQLITE_STMTSTATUS_REPREPARE]++;\n}\n\n/*\n** Resize the Vdbe.aOp array so that it is at least nOp elements larger \n** than its current size. nOp is guaranteed to be less than or equal\n** to 1024/sizeof(Op).\n**\n** If an out-of-memory error occurs while resizing the array, return\n** SQLITE_NOMEM. In this case Vdbe.aOp and Vdbe.nOpAlloc remain \n** unchanged (this is so that any opcodes already allocated can be \n** correctly deallocated along with the rest of the Vdbe).\n*/\nstatic int growOpArray(Vdbe *v, int nOp){\n  VdbeOp *pNew;\n  Parse *p = v->pParse;\n\n  /* The SQLITE_TEST_REALLOC_STRESS compile-time option is designed to force\n  ** more frequent reallocs and hence provide more opportunities for \n  ** simulated OOM faults.  SQLITE_TEST_REALLOC_STRESS is generally used\n  ** during testing only.  With SQLITE_TEST_REALLOC_STRESS grow the op array\n  ** by the minimum* amount required until the size reaches 512.  Normal\n  ** operation (without SQLITE_TEST_REALLOC_STRESS) is to double the current\n  ** size of the op array or add 1KB of space, whichever is smaller. */\n#ifdef SQLITE_TEST_REALLOC_STRESS\n  sqlite3_int64 nNew = (v->nOpAlloc>=512 ? 2*(sqlite3_int64)v->nOpAlloc\n                        : (sqlite3_int64)v->nOpAlloc+nOp);\n#else\n  sqlite3_int64 nNew = (v->nOpAlloc ? 2*(sqlite3_int64)v->nOpAlloc\n                        : (sqlite3_int64)(1024/sizeof(Op)));\n  UNUSED_PARAMETER(nOp);\n#endif\n\n  /* Ensure that the size of a VDBE does not grow too large */\n  if( nNew > p->db->aLimit[SQLITE_LIMIT_VDBE_OP] ){\n    sqlite3OomFault(p->db);\n    return SQLITE_NOMEM;\n  }\n\n  assert( nOp<=(1024/sizeof(Op)) );\n  assert( nNew>=(v->nOpAlloc+nOp) );\n  pNew = sqlite3DbRealloc(p->db, v->aOp, nNew*sizeof(Op));\n  if( pNew ){\n    p->szOpAlloc = sqlite3DbMallocSize(p->db, pNew);\n    v->nOpAlloc = p->szOpAlloc/sizeof(Op);\n    v->aOp = pNew;\n  }\n  return (pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT);\n}\n\n#ifdef SQLITE_DEBUG\n/* This routine is just a convenient place to set a breakpoint that will\n** fire after each opcode is inserted and displayed using\n** \"PRAGMA vdbe_addoptrace=on\".\n*/\nstatic void test_addop_breakpoint(void){\n  static int n = 0;\n  n++;\n}\n#endif\n\n/*\n** Add a new instruction to the list of instructions current in the\n** VDBE.  Return the address of the new instruction.\n**\n** Parameters:\n**\n**    p               Pointer to the VDBE\n**\n**    op              The opcode for this instruction\n**\n**    p1, p2, p3      Operands\n**\n** Use the sqlite3VdbeResolveLabel() function to fix an address and\n** the sqlite3VdbeChangeP4() function to change the value of the P4\n** operand.\n*/\nstatic SQLITE_NOINLINE int growOp3(Vdbe *p, int op, int p1, int p2, int p3){\n  assert( p->nOpAlloc<=p->nOp );\n  if( growOpArray(p, 1) ) return 1;\n  assert( p->nOpAlloc>p->nOp );\n  return sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n}\nint sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){\n  int i;\n  VdbeOp *pOp;\n\n  i = p->nOp;\n  assert( p->magic==VDBE_MAGIC_INIT );\n  assert( op>=0 && op<0xff );\n  if( p->nOpAlloc<=i ){\n    return growOp3(p, op, p1, p2, p3);\n  }\n  p->nOp++;\n  pOp = &p->aOp[i];\n  pOp->opcode = (u8)op;\n  pOp->p5 = 0;\n  pOp->p1 = p1;\n  pOp->p2 = p2;\n  pOp->p3 = p3;\n  pOp->p4.p = 0;\n  pOp->p4type = P4_NOTUSED;\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n  pOp->zComment = 0;\n#endif\n#ifdef SQLITE_DEBUG\n  if( p->db->flags & SQLITE_VdbeAddopTrace ){\n    sqlite3VdbePrintOp(0, i, &p->aOp[i]);\n    test_addop_breakpoint();\n  }\n#endif\n#ifdef VDBE_PROFILE\n  pOp->cycles = 0;\n  pOp->cnt = 0;\n#endif\n#ifdef SQLITE_VDBE_COVERAGE\n  pOp->iSrcLine = 0;\n#endif\n  return i;\n}\nint sqlite3VdbeAddOp0(Vdbe *p, int op){\n  return sqlite3VdbeAddOp3(p, op, 0, 0, 0);\n}\nint sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){\n  return sqlite3VdbeAddOp3(p, op, p1, 0, 0);\n}\nint sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){\n  return sqlite3VdbeAddOp3(p, op, p1, p2, 0);\n}\n\n/* Generate code for an unconditional jump to instruction iDest\n*/\nint sqlite3VdbeGoto(Vdbe *p, int iDest){\n  return sqlite3VdbeAddOp3(p, OP_Goto, 0, iDest, 0);\n}\n\n/* Generate code to cause the string zStr to be loaded into\n** register iDest\n*/\nint sqlite3VdbeLoadString(Vdbe *p, int iDest, const char *zStr){\n  return sqlite3VdbeAddOp4(p, OP_String8, 0, iDest, 0, zStr, 0);\n}\n\n/*\n** Generate code that initializes multiple registers to string or integer\n** constants.  The registers begin with iDest and increase consecutively.\n** One register is initialized for each characgter in zTypes[].  For each\n** \"s\" character in zTypes[], the register is a string if the argument is\n** not NULL, or OP_Null if the value is a null pointer.  For each \"i\" character\n** in zTypes[], the register is initialized to an integer.\n**\n** If the input string does not end with \"X\" then an OP_ResultRow instruction\n** is generated for the values inserted.\n*/\nvoid sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes, ...){\n  va_list ap;\n  int i;\n  char c;\n  va_start(ap, zTypes);\n  for(i=0; (c = zTypes[i])!=0; i++){\n    if( c=='s' ){\n      const char *z = va_arg(ap, const char*);\n      sqlite3VdbeAddOp4(p, z==0 ? OP_Null : OP_String8, 0, iDest+i, 0, z, 0);\n    }else if( c=='i' ){\n      sqlite3VdbeAddOp2(p, OP_Integer, va_arg(ap, int), iDest+i);\n    }else{\n      goto skip_op_resultrow;\n    }\n  }\n  sqlite3VdbeAddOp2(p, OP_ResultRow, iDest, i);\nskip_op_resultrow:\n  va_end(ap);\n}\n\n/*\n** Add an opcode that includes the p4 value as a pointer.\n*/\nint sqlite3VdbeAddOp4(\n  Vdbe *p,            /* Add the opcode to this VM */\n  int op,             /* The new opcode */\n  int p1,             /* The P1 operand */\n  int p2,             /* The P2 operand */\n  int p3,             /* The P3 operand */\n  const char *zP4,    /* The P4 operand */\n  int p4type          /* P4 operand type */\n){\n  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n  sqlite3VdbeChangeP4(p, addr, zP4, p4type);\n  return addr;\n}\n\n/*\n** Add an OP_Function or OP_PureFunc opcode.\n**\n** The eCallCtx argument is information (typically taken from Expr.op2)\n** that describes the calling context of the function.  0 means a general\n** function call.  NC_IsCheck means called by a check constraint,\n** NC_IdxExpr means called as part of an index expression.  NC_PartIdx\n** means in the WHERE clause of a partial index.  NC_GenCol means called\n** while computing a generated column value.  0 is the usual case.\n*/\nint sqlite3VdbeAddFunctionCall(\n  Parse *pParse,        /* Parsing context */\n  int p1,               /* Constant argument mask */\n  int p2,               /* First argument register */\n  int p3,               /* Register into which results are written */\n  int nArg,             /* Number of argument */\n  const FuncDef *pFunc, /* The function to be invoked */\n  int eCallCtx          /* Calling context */\n){\n  Vdbe *v = pParse->pVdbe;\n  int nByte;\n  int addr;\n  sqlite3_context *pCtx;\n  assert( v );\n  nByte = sizeof(*pCtx) + (nArg-1)*sizeof(sqlite3_value*);\n  pCtx = sqlite3DbMallocRawNN(pParse->db, nByte);\n  if( pCtx==0 ){\n    assert( pParse->db->mallocFailed );\n    freeEphemeralFunction(pParse->db, (FuncDef*)pFunc);\n    return 0;\n  }\n  pCtx->pOut = 0;\n  pCtx->pFunc = (FuncDef*)pFunc;\n  pCtx->pVdbe = 0;\n  pCtx->isError = 0;\n  pCtx->argc = nArg;\n  pCtx->iOp = sqlite3VdbeCurrentAddr(v);\n  addr = sqlite3VdbeAddOp4(v, eCallCtx ? OP_PureFunc : OP_Function,\n                           p1, p2, p3, (char*)pCtx, P4_FUNCCTX);\n  sqlite3VdbeChangeP5(v, eCallCtx & NC_SelfRef);\n  return addr;\n}\n\n/*\n** Add an opcode that includes the p4 value with a P4_INT64 or\n** P4_REAL type.\n*/\nint sqlite3VdbeAddOp4Dup8(\n  Vdbe *p,            /* Add the opcode to this VM */\n  int op,             /* The new opcode */\n  int p1,             /* The P1 operand */\n  int p2,             /* The P2 operand */\n  int p3,             /* The P3 operand */\n  const u8 *zP4,      /* The P4 operand */\n  int p4type          /* P4 operand type */\n){\n  char *p4copy = sqlite3DbMallocRawNN(sqlite3VdbeDb(p), 8);\n  if( p4copy ) memcpy(p4copy, zP4, 8);\n  return sqlite3VdbeAddOp4(p, op, p1, p2, p3, p4copy, p4type);\n}\n\n#ifndef SQLITE_OMIT_EXPLAIN\n/*\n** Return the address of the current EXPLAIN QUERY PLAN baseline.\n** 0 means \"none\".\n*/\nint sqlite3VdbeExplainParent(Parse *pParse){\n  VdbeOp *pOp;\n  if( pParse->addrExplain==0 ) return 0;\n  pOp = sqlite3VdbeGetOp(pParse->pVdbe, pParse->addrExplain);\n  return pOp->p2;\n}\n\n/*\n** Set a debugger breakpoint on the following routine in order to\n** monitor the EXPLAIN QUERY PLAN code generation.\n*/\n#if defined(SQLITE_DEBUG)\nvoid sqlite3ExplainBreakpoint(const char *z1, const char *z2){\n  (void)z1;\n  (void)z2;\n}\n#endif\n\n/*\n** Add a new OP_ opcode.\n**\n** If the bPush flag is true, then make this opcode the parent for\n** subsequent Explains until sqlite3VdbeExplainPop() is called.\n*/\nvoid sqlite3VdbeExplain(Parse *pParse, u8 bPush, const char *zFmt, ...){\n#ifndef SQLITE_DEBUG\n  /* Always include the OP_Explain opcodes if SQLITE_DEBUG is defined.\n  ** But omit them (for performance) during production builds */\n  if( pParse->explain==2 )\n#endif\n  {\n    char *zMsg;\n    Vdbe *v;\n    va_list ap;\n    int iThis;\n    va_start(ap, zFmt);\n    zMsg = sqlite3VMPrintf(pParse->db, zFmt, ap);\n    va_end(ap);\n    v = pParse->pVdbe;\n    iThis = v->nOp;\n    sqlite3VdbeAddOp4(v, OP_Explain, iThis, pParse->addrExplain, 0,\n                      zMsg, P4_DYNAMIC);\n    sqlite3ExplainBreakpoint(bPush?\"PUSH\":\"\", sqlite3VdbeGetOp(v,-1)->p4.z);\n    if( bPush){\n      pParse->addrExplain = iThis;\n    }\n  }\n}\n\n/*\n** Pop the EXPLAIN QUERY PLAN stack one level.\n*/\nvoid sqlite3VdbeExplainPop(Parse *pParse){\n  sqlite3ExplainBreakpoint(\"POP\", 0);\n  pParse->addrExplain = sqlite3VdbeExplainParent(pParse);\n}\n#endif /* SQLITE_OMIT_EXPLAIN */\n\n/*\n** Add an OP_ParseSchema opcode.  This routine is broken out from\n** sqlite3VdbeAddOp4() since it needs to also needs to mark all btrees\n** as having been used.\n**\n** The zWhere string must have been obtained from sqlite3_malloc().\n** This routine will take ownership of the allocated memory.\n*/\nvoid sqlite3VdbeAddParseSchemaOp(Vdbe *p, int iDb, char *zWhere){\n  int j;\n  sqlite3VdbeAddOp4(p, OP_ParseSchema, iDb, 0, 0, zWhere, P4_DYNAMIC);\n  for(j=0; j<p->db->nDb; j++) sqlite3VdbeUsesBtree(p, j);\n}\n\n/*\n** Add an opcode that includes the p4 value as an integer.\n*/\nint sqlite3VdbeAddOp4Int(\n  Vdbe *p,            /* Add the opcode to this VM */\n  int op,             /* The new opcode */\n  int p1,             /* The P1 operand */\n  int p2,             /* The P2 operand */\n  int p3,             /* The P3 operand */\n  int p4              /* The P4 operand as an integer */\n){\n  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n  if( p->db->mallocFailed==0 ){\n    VdbeOp *pOp = &p->aOp[addr];\n    pOp->p4type = P4_INT32;\n    pOp->p4.i = p4;\n  }\n  return addr;\n}\n\n/* Insert the end of a co-routine\n*/\nvoid sqlite3VdbeEndCoroutine(Vdbe *v, int regYield){\n  sqlite3VdbeAddOp1(v, OP_EndCoroutine, regYield);\n\n  /* Clear the temporary register cache, thereby ensuring that each\n  ** co-routine has its own independent set of registers, because co-routines\n  ** might expect their registers to be preserved across an OP_Yield, and\n  ** that could cause problems if two or more co-routines are using the same\n  ** temporary register.\n  */\n  v->pParse->nTempReg = 0;\n  v->pParse->nRangeReg = 0;\n}\n\n/*\n** Create a new symbolic label for an instruction that has yet to be\n** coded.  The symbolic label is really just a negative number.  The\n** label can be used as the P2 value of an operation.  Later, when\n** the label is resolved to a specific address, the VDBE will scan\n** through its operation list and change all values of P2 which match\n** the label into the resolved address.\n**\n** The VDBE knows that a P2 value is a label because labels are\n** always negative and P2 values are suppose to be non-negative.\n** Hence, a negative P2 value is a label that has yet to be resolved.\n** (Later:) This is only true for opcodes that have the OPFLG_JUMP\n** property.\n**\n** Variable usage notes:\n**\n**     Parse.aLabel[x]     Stores the address that the x-th label resolves\n**                         into.  For testing (SQLITE_DEBUG), unresolved\n**                         labels stores -1, but that is not required.\n**     Parse.nLabelAlloc   Number of slots allocated to Parse.aLabel[]\n**     Parse.nLabel        The *negative* of the number of labels that have\n**                         been issued.  The negative is stored because\n**                         that gives a performance improvement over storing\n**                         the equivalent positive value.\n*/\nint sqlite3VdbeMakeLabel(Parse *pParse){\n  return --pParse->nLabel;\n}\n\n/*\n** Resolve label \"x\" to be the address of the next instruction to\n** be inserted.  The parameter \"x\" must have been obtained from\n** a prior call to sqlite3VdbeMakeLabel().\n*/\nstatic SQLITE_NOINLINE void resizeResolveLabel(Parse *p, Vdbe *v, int j){\n  int nNewSize = 10 - p->nLabel;\n  p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel,\n                     nNewSize*sizeof(p->aLabel[0]));\n  if( p->aLabel==0 ){\n    p->nLabelAlloc = 0;\n  }else{\n#ifdef SQLITE_DEBUG\n    int i;\n    for(i=p->nLabelAlloc; i<nNewSize; i++) p->aLabel[i] = -1;\n#endif\n    p->nLabelAlloc = nNewSize;\n    p->aLabel[j] = v->nOp;\n  }\n}\nvoid sqlite3VdbeResolveLabel(Vdbe *v, int x){\n  Parse *p = v->pParse;\n  int j = ADDR(x);\n  assert( v->magic==VDBE_MAGIC_INIT );\n  assert( j<-p->nLabel );\n  assert( j>=0 );\n#ifdef SQLITE_DEBUG\n  if( p->db->flags & SQLITE_VdbeAddopTrace ){\n    printf(\"RESOLVE LABEL %d to %d\\n\", x, v->nOp);\n  }\n#endif\n  if( p->nLabelAlloc + p->nLabel < 0 ){\n    resizeResolveLabel(p,v,j);\n  }else{\n    assert( p->aLabel[j]==(-1) ); /* Labels may only be resolved once */\n    p->aLabel[j] = v->nOp;\n  }\n}\n\n/*\n** Mark the VDBE as one that can only be run one time.\n*/\nvoid sqlite3VdbeRunOnlyOnce(Vdbe *p){\n  p->runOnlyOnce = 1;\n}\n\n/*\n** Mark the VDBE as one that can only be run multiple times.\n*/\nvoid sqlite3VdbeReusable(Vdbe *p){\n  p->runOnlyOnce = 0;\n}\n\n#ifdef SQLITE_DEBUG /* sqlite3AssertMayAbort() logic */\n\n/*\n** The following type and function are used to iterate through all opcodes\n** in a Vdbe main program and each of the sub-programs (triggers) it may \n** invoke directly or indirectly. It should be used as follows:\n**\n**   Op *pOp;\n**   VdbeOpIter sIter;\n**\n**   memset(&sIter, 0, sizeof(sIter));\n**   sIter.v = v;                            // v is of type Vdbe* \n**   while( (pOp = opIterNext(&sIter)) ){\n**     // Do something with pOp\n**   }\n**   sqlite3DbFree(v->db, sIter.apSub);\n** \n*/\ntypedef struct VdbeOpIter VdbeOpIter;\nstruct VdbeOpIter {\n  Vdbe *v;                   /* Vdbe to iterate through the opcodes of */\n  SubProgram **apSub;        /* Array of subprograms */\n  int nSub;                  /* Number of entries in apSub */\n  int iAddr;                 /* Address of next instruction to return */\n  int iSub;                  /* 0 = main program, 1 = first sub-program etc. */\n};\nstatic Op *opIterNext(VdbeOpIter *p){\n  Vdbe *v = p->v;\n  Op *pRet = 0;\n  Op *aOp;\n  int nOp;\n\n  if( p->iSub<=p->nSub ){\n\n    if( p->iSub==0 ){\n      aOp = v->aOp;\n      nOp = v->nOp;\n    }else{\n      aOp = p->apSub[p->iSub-1]->aOp;\n      nOp = p->apSub[p->iSub-1]->nOp;\n    }\n    assert( p->iAddr<nOp );\n\n    pRet = &aOp[p->iAddr];\n    p->iAddr++;\n    if( p->iAddr==nOp ){\n      p->iSub++;\n      p->iAddr = 0;\n    }\n  \n    if( pRet->p4type==P4_SUBPROGRAM ){\n      int nByte = (p->nSub+1)*sizeof(SubProgram*);\n      int j;\n      for(j=0; j<p->nSub; j++){\n        if( p->apSub[j]==pRet->p4.pProgram ) break;\n      }\n      if( j==p->nSub ){\n        p->apSub = sqlite3DbReallocOrFree(v->db, p->apSub, nByte);\n        if( !p->apSub ){\n          pRet = 0;\n        }else{\n          p->apSub[p->nSub++] = pRet->p4.pProgram;\n        }\n      }\n    }\n  }\n\n  return pRet;\n}\n\n/*\n** Check if the program stored in the VM associated with pParse may\n** throw an ABORT exception (causing the statement, but not entire transaction\n** to be rolled back). This condition is true if the main program or any\n** sub-programs contains any of the following:\n**\n**   *  OP_Halt with P1=SQLITE_CONSTRAINT and P2=OE_Abort.\n**   *  OP_HaltIfNull with P1=SQLITE_CONSTRAINT and P2=OE_Abort.\n**   *  OP_Destroy\n**   *  OP_VUpdate\n**   *  OP_VCreate\n**   *  OP_VRename\n**   *  OP_FkCounter with P2==0 (immediate foreign key constraint)\n**   *  OP_CreateBtree/BTREE_INTKEY and OP_InitCoroutine \n**      (for CREATE TABLE AS SELECT ...)\n**\n** Then check that the value of Parse.mayAbort is true if an\n** ABORT may be thrown, or false otherwise. Return true if it does\n** match, or false otherwise. This function is intended to be used as\n** part of an assert statement in the compiler. Similar to:\n**\n**   assert( sqlite3VdbeAssertMayAbort(pParse->pVdbe, pParse->mayAbort) );\n*/\nint sqlite3VdbeAssertMayAbort(Vdbe *v, int mayAbort){\n  int hasAbort = 0;\n  int hasFkCounter = 0;\n  int hasCreateTable = 0;\n  int hasCreateIndex = 0;\n  int hasInitCoroutine = 0;\n  Op *pOp;\n  VdbeOpIter sIter;\n  memset(&sIter, 0, sizeof(sIter));\n  sIter.v = v;\n\n  while( (pOp = opIterNext(&sIter))!=0 ){\n    int opcode = pOp->opcode;\n    if( opcode==OP_Destroy || opcode==OP_VUpdate || opcode==OP_VRename \n     || opcode==OP_VDestroy\n     || opcode==OP_VCreate\n     || (opcode==OP_ParseSchema && pOp->p4.z==0)\n     || ((opcode==OP_Halt || opcode==OP_HaltIfNull) \n      && ((pOp->p1)!=SQLITE_OK && pOp->p2==OE_Abort))\n    ){\n      hasAbort = 1;\n      break;\n    }\n    if( opcode==OP_CreateBtree && pOp->p3==BTREE_INTKEY ) hasCreateTable = 1;\n    if( mayAbort ){\n      /* hasCreateIndex may also be set for some DELETE statements that use\n      ** OP_Clear. So this routine may end up returning true in the case \n      ** where a \"DELETE FROM tbl\" has a statement-journal but does not\n      ** require one. This is not so bad - it is an inefficiency, not a bug. */\n      if( opcode==OP_CreateBtree && pOp->p3==BTREE_BLOBKEY ) hasCreateIndex = 1;\n      if( opcode==OP_Clear ) hasCreateIndex = 1;\n    }\n    if( opcode==OP_InitCoroutine ) hasInitCoroutine = 1;\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n    if( opcode==OP_FkCounter && pOp->p1==0 && pOp->p2==1 ){\n      hasFkCounter = 1;\n    }\n#endif\n  }\n  sqlite3DbFree(v->db, sIter.apSub);\n\n  /* Return true if hasAbort==mayAbort. Or if a malloc failure occurred.\n  ** If malloc failed, then the while() loop above may not have iterated\n  ** through all opcodes and hasAbort may be set incorrectly. Return\n  ** true for this case to prevent the assert() in the callers frame\n  ** from failing.  */\n  return ( v->db->mallocFailed || hasAbort==mayAbort || hasFkCounter\n        || (hasCreateTable && hasInitCoroutine) || hasCreateIndex\n  );\n}\n#endif /* SQLITE_DEBUG - the sqlite3AssertMayAbort() function */\n\n#ifdef SQLITE_DEBUG\n/*\n** Increment the nWrite counter in the VDBE if the cursor is not an\n** ephemeral cursor, or if the cursor argument is NULL.\n*/\nvoid sqlite3VdbeIncrWriteCounter(Vdbe *p, VdbeCursor *pC){\n  if( pC==0\n   || (pC->eCurType!=CURTYPE_SORTER\n       && pC->eCurType!=CURTYPE_PSEUDO\n       && !pC->isEphemeral)\n  ){\n    p->nWrite++;\n  }\n}\n#endif\n\n#ifdef SQLITE_DEBUG\n/*\n** Assert if an Abort at this point in time might result in a corrupt\n** database.\n*/\nvoid sqlite3VdbeAssertAbortable(Vdbe *p){\n  assert( p->nWrite==0 || p->usesStmtJournal );\n}\n#endif\n\n/*\n** This routine is called after all opcodes have been inserted.  It loops\n** through all the opcodes and fixes up some details.\n**\n** (1) For each jump instruction with a negative P2 value (a label)\n**     resolve the P2 value to an actual address.\n**\n** (2) Compute the maximum number of arguments used by any SQL function\n**     and store that value in *pMaxFuncArgs.\n**\n** (3) Update the Vdbe.readOnly and Vdbe.bIsReader flags to accurately\n**     indicate what the prepared statement actually does.\n**\n** (4) Initialize the p4.xAdvance pointer on opcodes that use it.\n**\n** (5) Reclaim the memory allocated for storing labels.\n**\n** This routine will only function correctly if the mkopcodeh.tcl generator\n** script numbers the opcodes correctly.  Changes to this routine must be\n** coordinated with changes to mkopcodeh.tcl.\n*/\nstatic void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){\n  int nMaxArgs = *pMaxFuncArgs;\n  Op *pOp;\n  Parse *pParse = p->pParse;\n  int *aLabel = pParse->aLabel;\n  p->readOnly = 1;\n  p->bIsReader = 0;\n  pOp = &p->aOp[p->nOp-1];\n  while(1){\n\n    /* Only JUMP opcodes and the short list of special opcodes in the switch\n    ** below need to be considered.  The mkopcodeh.tcl generator script groups\n    ** all these opcodes together near the front of the opcode list.  Skip\n    ** any opcode that does not need processing by virtual of the fact that\n    ** it is larger than SQLITE_MX_JUMP_OPCODE, as a performance optimization.\n    */\n    if( pOp->opcode<=SQLITE_MX_JUMP_OPCODE ){\n      /* NOTE: Be sure to update mkopcodeh.tcl when adding or removing\n      ** cases from this switch! */\n      switch( pOp->opcode ){\n        case OP_Transaction: {\n          if( pOp->p2!=0 ) p->readOnly = 0;\n          /* fall thru */\n        }\n        case OP_AutoCommit:\n        case OP_Savepoint: {\n          p->bIsReader = 1;\n          break;\n        }\n#ifndef SQLITE_OMIT_WAL\n        case OP_Checkpoint:\n#endif\n        case OP_Vacuum:\n        case OP_JournalMode: {\n          p->readOnly = 0;\n          p->bIsReader = 1;\n          break;\n        }\n        case OP_Next:\n        case OP_SorterNext: {\n          pOp->p4.xAdvance = sqlite3BtreeNext;\n          pOp->p4type = P4_ADVANCE;\n          /* The code generator never codes any of these opcodes as a jump\n          ** to a label.  They are always coded as a jump backwards to a \n          ** known address */\n          assert( pOp->p2>=0 );\n          break;\n        }\n        case OP_Prev: {\n          pOp->p4.xAdvance = sqlite3BtreePrevious;\n          pOp->p4type = P4_ADVANCE;\n          /* The code generator never codes any of these opcodes as a jump\n          ** to a label.  They are always coded as a jump backwards to a \n          ** known address */\n          assert( pOp->p2>=0 );\n          break;\n        }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n        case OP_VUpdate: {\n          if( pOp->p2>nMaxArgs ) nMaxArgs = pOp->p2;\n          break;\n        }\n        case OP_VFilter: {\n          int n;\n          assert( (pOp - p->aOp) >= 3 );\n          assert( pOp[-1].opcode==OP_Integer );\n          n = pOp[-1].p1;\n          if( n>nMaxArgs ) nMaxArgs = n;\n          /* Fall through into the default case */\n        }\n#endif\n        default: {\n          if( pOp->p2<0 ){\n            /* The mkopcodeh.tcl script has so arranged things that the only\n            ** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to\n            ** have non-negative values for P2. */\n            assert( (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_JUMP)!=0 );\n            assert( ADDR(pOp->p2)<-pParse->nLabel );\n            pOp->p2 = aLabel[ADDR(pOp->p2)];\n          }\n          break;\n        }\n      }\n      /* The mkopcodeh.tcl script has so arranged things that the only\n      ** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to\n      ** have non-negative values for P2. */\n      assert( (sqlite3OpcodeProperty[pOp->opcode]&OPFLG_JUMP)==0 || pOp->p2>=0);\n    }\n    if( pOp==p->aOp ) break;\n    pOp--;\n  }\n  sqlite3DbFree(p->db, pParse->aLabel);\n  pParse->aLabel = 0;\n  pParse->nLabel = 0;\n  *pMaxFuncArgs = nMaxArgs;\n  assert( p->bIsReader!=0 || DbMaskAllZero(p->btreeMask) );\n}\n\n/*\n** Return the address of the next instruction to be inserted.\n*/\nint sqlite3VdbeCurrentAddr(Vdbe *p){\n  assert( p->magic==VDBE_MAGIC_INIT );\n  return p->nOp;\n}\n\n/*\n** Verify that at least N opcode slots are available in p without\n** having to malloc for more space (except when compiled using\n** SQLITE_TEST_REALLOC_STRESS).  This interface is used during testing\n** to verify that certain calls to sqlite3VdbeAddOpList() can never\n** fail due to a OOM fault and hence that the return value from\n** sqlite3VdbeAddOpList() will always be non-NULL.\n*/\n#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)\nvoid sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N){\n  assert( p->nOp + N <= p->nOpAlloc );\n}\n#endif\n\n/*\n** Verify that the VM passed as the only argument does not contain\n** an OP_ResultRow opcode. Fail an assert() if it does. This is used\n** by code in pragma.c to ensure that the implementation of certain\n** pragmas comports with the flags specified in the mkpragmatab.tcl\n** script.\n*/\n#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)\nvoid sqlite3VdbeVerifyNoResultRow(Vdbe *p){\n  int i;\n  for(i=0; i<p->nOp; i++){\n    assert( p->aOp[i].opcode!=OP_ResultRow );\n  }\n}\n#endif\n\n/*\n** Generate code (a single OP_Abortable opcode) that will\n** verify that the VDBE program can safely call Abort in the current\n** context.\n*/\n#if defined(SQLITE_DEBUG)\nvoid sqlite3VdbeVerifyAbortable(Vdbe *p, int onError){\n  if( onError==OE_Abort ) sqlite3VdbeAddOp0(p, OP_Abortable);\n}\n#endif\n\n/*\n** This function returns a pointer to the array of opcodes associated with\n** the Vdbe passed as the first argument. It is the callers responsibility\n** to arrange for the returned array to be eventually freed using the \n** vdbeFreeOpArray() function.\n**\n** Before returning, *pnOp is set to the number of entries in the returned\n** array. Also, *pnMaxArg is set to the larger of its current value and \n** the number of entries in the Vdbe.apArg[] array required to execute the \n** returned program.\n*/\nVdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg){\n  VdbeOp *aOp = p->aOp;\n  assert( aOp && !p->db->mallocFailed );\n\n  /* Check that sqlite3VdbeUsesBtree() was not called on this VM */\n  assert( DbMaskAllZero(p->btreeMask) );\n\n  resolveP2Values(p, pnMaxArg);\n  *pnOp = p->nOp;\n  p->aOp = 0;\n  return aOp;\n}\n\n/*\n** Add a whole list of operations to the operation stack.  Return a\n** pointer to the first operation inserted.\n**\n** Non-zero P2 arguments to jump instructions are automatically adjusted\n** so that the jump target is relative to the first operation inserted.\n*/\nVdbeOp *sqlite3VdbeAddOpList(\n  Vdbe *p,                     /* Add opcodes to the prepared statement */\n  int nOp,                     /* Number of opcodes to add */\n  VdbeOpList const *aOp,       /* The opcodes to be added */\n  int iLineno                  /* Source-file line number of first opcode */\n){\n  int i;\n  VdbeOp *pOut, *pFirst;\n  assert( nOp>0 );\n  assert( p->magic==VDBE_MAGIC_INIT );\n  if( p->nOp + nOp > p->nOpAlloc && growOpArray(p, nOp) ){\n    return 0;\n  }\n  pFirst = pOut = &p->aOp[p->nOp];\n  for(i=0; i<nOp; i++, aOp++, pOut++){\n    pOut->opcode = aOp->opcode;\n    pOut->p1 = aOp->p1;\n    pOut->p2 = aOp->p2;\n    assert( aOp->p2>=0 );\n    if( (sqlite3OpcodeProperty[aOp->opcode] & OPFLG_JUMP)!=0 && aOp->p2>0 ){\n      pOut->p2 += p->nOp;\n    }\n    pOut->p3 = aOp->p3;\n    pOut->p4type = P4_NOTUSED;\n    pOut->p4.p = 0;\n    pOut->p5 = 0;\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n    pOut->zComment = 0;\n#endif\n#ifdef SQLITE_VDBE_COVERAGE\n    pOut->iSrcLine = iLineno+i;\n#else\n    (void)iLineno;\n#endif\n#ifdef SQLITE_DEBUG\n    if( p->db->flags & SQLITE_VdbeAddopTrace ){\n      sqlite3VdbePrintOp(0, i+p->nOp, &p->aOp[i+p->nOp]);\n    }\n#endif\n  }\n  p->nOp += nOp;\n  return pFirst;\n}\n\n#if defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n/*\n** Add an entry to the array of counters managed by sqlite3_stmt_scanstatus().\n*/\nvoid sqlite3VdbeScanStatus(\n  Vdbe *p,                        /* VM to add scanstatus() to */\n  int addrExplain,                /* Address of OP_Explain (or 0) */\n  int addrLoop,                   /* Address of loop counter */ \n  int addrVisit,                  /* Address of rows visited counter */\n  LogEst nEst,                    /* Estimated number of output rows */\n  const char *zName               /* Name of table or index being scanned */\n){\n  sqlite3_int64 nByte = (p->nScan+1) * sizeof(ScanStatus);\n  ScanStatus *aNew;\n  aNew = (ScanStatus*)sqlite3DbRealloc(p->db, p->aScan, nByte);\n  if( aNew ){\n    ScanStatus *pNew = &aNew[p->nScan++];\n    pNew->addrExplain = addrExplain;\n    pNew->addrLoop = addrLoop;\n    pNew->addrVisit = addrVisit;\n    pNew->nEst = nEst;\n    pNew->zName = sqlite3DbStrDup(p->db, zName);\n    p->aScan = aNew;\n  }\n}\n#endif\n\n\n/*\n** Change the value of the opcode, or P1, P2, P3, or P5 operands\n** for a specific instruction.\n*/\nvoid sqlite3VdbeChangeOpcode(Vdbe *p, int addr, u8 iNewOpcode){\n  sqlite3VdbeGetOp(p,addr)->opcode = iNewOpcode;\n}\nvoid sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){\n  sqlite3VdbeGetOp(p,addr)->p1 = val;\n}\nvoid sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){\n  sqlite3VdbeGetOp(p,addr)->p2 = val;\n}\nvoid sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){\n  sqlite3VdbeGetOp(p,addr)->p3 = val;\n}\nvoid sqlite3VdbeChangeP5(Vdbe *p, u16 p5){\n  assert( p->nOp>0 || p->db->mallocFailed );\n  if( p->nOp>0 ) p->aOp[p->nOp-1].p5 = p5;\n}\n\n/*\n** Change the P2 operand of instruction addr so that it points to\n** the address of the next instruction to be coded.\n*/\nvoid sqlite3VdbeJumpHere(Vdbe *p, int addr){\n  sqlite3VdbeChangeP2(p, addr, p->nOp);\n}\n\n\n/*\n** If the input FuncDef structure is ephemeral, then free it.  If\n** the FuncDef is not ephermal, then do nothing.\n*/\nstatic void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){\n  if( (pDef->funcFlags & SQLITE_FUNC_EPHEM)!=0 ){\n    sqlite3DbFreeNN(db, pDef);\n  }\n}\n\n/*\n** Delete a P4 value if necessary.\n*/\nstatic SQLITE_NOINLINE void freeP4Mem(sqlite3 *db, Mem *p){\n  if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);\n  sqlite3DbFreeNN(db, p);\n}\nstatic SQLITE_NOINLINE void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p){\n  freeEphemeralFunction(db, p->pFunc);\n  sqlite3DbFreeNN(db, p);\n}\nstatic void freeP4(sqlite3 *db, int p4type, void *p4){\n  assert( db );\n  switch( p4type ){\n    case P4_FUNCCTX: {\n      freeP4FuncCtx(db, (sqlite3_context*)p4);\n      break;\n    }\n    case P4_REAL:\n    case P4_INT64:\n    case P4_DYNAMIC:\n    case P4_DYNBLOB:\n    case P4_INTARRAY: {\n      sqlite3DbFree(db, p4);\n      break;\n    }\n    case P4_KEYINFO: {\n      if( db->pnBytesFreed==0 ) sqlite3KeyInfoUnref((KeyInfo*)p4);\n      break;\n    }\n#ifdef SQLITE_ENABLE_CURSOR_HINTS\n    case P4_EXPR: {\n      sqlite3ExprDelete(db, (Expr*)p4);\n      break;\n    }\n#endif\n    case P4_FUNCDEF: {\n      freeEphemeralFunction(db, (FuncDef*)p4);\n      break;\n    }\n    case P4_MEM: {\n      if( db->pnBytesFreed==0 ){\n        sqlite3ValueFree((sqlite3_value*)p4);\n      }else{\n        freeP4Mem(db, (Mem*)p4);\n      }\n      break;\n    }\n    case P4_VTAB : {\n      if( db->pnBytesFreed==0 ) sqlite3VtabUnlock((VTable *)p4);\n      break;\n    }\n  }\n}\n\n/*\n** Free the space allocated for aOp and any p4 values allocated for the\n** opcodes contained within. If aOp is not NULL it is assumed to contain \n** nOp entries. \n*/\nstatic void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){\n  if( aOp ){\n    Op *pOp;\n    for(pOp=&aOp[nOp-1]; pOp>=aOp; pOp--){\n      if( pOp->p4type <= P4_FREE_IF_LE ) freeP4(db, pOp->p4type, pOp->p4.p);\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n      sqlite3DbFree(db, pOp->zComment);\n#endif     \n    }\n    sqlite3DbFreeNN(db, aOp);\n  }\n}\n\n/*\n** Link the SubProgram object passed as the second argument into the linked\n** list at Vdbe.pSubProgram. This list is used to delete all sub-program\n** objects when the VM is no longer required.\n*/\nvoid sqlite3VdbeLinkSubProgram(Vdbe *pVdbe, SubProgram *p){\n  p->pNext = pVdbe->pProgram;\n  pVdbe->pProgram = p;\n}\n\n/*\n** Return true if the given Vdbe has any SubPrograms.\n*/\nint sqlite3VdbeHasSubProgram(Vdbe *pVdbe){\n  return pVdbe->pProgram!=0;\n}\n\n/*\n** Change the opcode at addr into OP_Noop\n*/\nint sqlite3VdbeChangeToNoop(Vdbe *p, int addr){\n  VdbeOp *pOp;\n  if( p->db->mallocFailed ) return 0;\n  assert( addr>=0 && addr<p->nOp );\n  pOp = &p->aOp[addr];\n  freeP4(p->db, pOp->p4type, pOp->p4.p);\n  pOp->p4type = P4_NOTUSED;\n  pOp->p4.z = 0;\n  pOp->opcode = OP_Noop;\n  return 1;\n}\n\n/*\n** If the last opcode is \"op\" and it is not a jump destination,\n** then remove it.  Return true if and only if an opcode was removed.\n*/\nint sqlite3VdbeDeletePriorOpcode(Vdbe *p, u8 op){\n  if( p->nOp>0 && p->aOp[p->nOp-1].opcode==op ){\n    return sqlite3VdbeChangeToNoop(p, p->nOp-1);\n  }else{\n    return 0;\n  }\n}\n\n/*\n** Change the value of the P4 operand for a specific instruction.\n** This routine is useful when a large program is loaded from a\n** static array using sqlite3VdbeAddOpList but we want to make a\n** few minor changes to the program.\n**\n** If n>=0 then the P4 operand is dynamic, meaning that a copy of\n** the string is made into memory obtained from sqlite3_malloc().\n** A value of n==0 means copy bytes of zP4 up to and including the\n** first null byte.  If n>0 then copy n+1 bytes of zP4.\n** \n** Other values of n (P4_STATIC, P4_COLLSEQ etc.) indicate that zP4 points\n** to a string or structure that is guaranteed to exist for the lifetime of\n** the Vdbe. In these cases we can just copy the pointer.\n**\n** If addr<0 then change P4 on the most recently inserted instruction.\n*/\nstatic void SQLITE_NOINLINE vdbeChangeP4Full(\n  Vdbe *p,\n  Op *pOp,\n  const char *zP4,\n  int n\n){\n  if( pOp->p4type ){\n    freeP4(p->db, pOp->p4type, pOp->p4.p);\n    pOp->p4type = 0;\n    pOp->p4.p = 0;\n  }\n  if( n<0 ){\n    sqlite3VdbeChangeP4(p, (int)(pOp - p->aOp), zP4, n);\n  }else{\n    if( n==0 ) n = sqlite3Strlen30(zP4);\n    pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n);\n    pOp->p4type = P4_DYNAMIC;\n  }\n}\nvoid sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){\n  Op *pOp;\n  sqlite3 *db;\n  assert( p!=0 );\n  db = p->db;\n  assert( p->magic==VDBE_MAGIC_INIT );\n  assert( p->aOp!=0 || db->mallocFailed );\n  if( db->mallocFailed ){\n    if( n!=P4_VTAB ) freeP4(db, n, (void*)*(char**)&zP4);\n    return;\n  }\n  assert( p->nOp>0 );\n  assert( addr<p->nOp );\n  if( addr<0 ){\n    addr = p->nOp - 1;\n  }\n  pOp = &p->aOp[addr];\n  if( n>=0 || pOp->p4type ){\n    vdbeChangeP4Full(p, pOp, zP4, n);\n    return;\n  }\n  if( n==P4_INT32 ){\n    /* Note: this cast is safe, because the origin data point was an int\n    ** that was cast to a (const char *). */\n    pOp->p4.i = SQLITE_PTR_TO_INT(zP4);\n    pOp->p4type = P4_INT32;\n  }else if( zP4!=0 ){\n    assert( n<0 );\n    pOp->p4.p = (void*)zP4;\n    pOp->p4type = (signed char)n;\n    if( n==P4_VTAB ) sqlite3VtabLock((VTable*)zP4);\n  }\n}\n\n/*\n** Change the P4 operand of the most recently coded instruction \n** to the value defined by the arguments.  This is a high-speed\n** version of sqlite3VdbeChangeP4().\n**\n** The P4 operand must not have been previously defined.  And the new\n** P4 must not be P4_INT32.  Use sqlite3VdbeChangeP4() in either of\n** those cases.\n*/\nvoid sqlite3VdbeAppendP4(Vdbe *p, void *pP4, int n){\n  VdbeOp *pOp;\n  assert( n!=P4_INT32 && n!=P4_VTAB );\n  assert( n<=0 );\n  if( p->db->mallocFailed ){\n    freeP4(p->db, n, pP4);\n  }else{\n    assert( pP4!=0 );\n    assert( p->nOp>0 );\n    pOp = &p->aOp[p->nOp-1];\n    assert( pOp->p4type==P4_NOTUSED );\n    pOp->p4type = n;\n    pOp->p4.p = pP4;\n  }\n}\n\n/*\n** Set the P4 on the most recently added opcode to the KeyInfo for the\n** index given.\n*/\nvoid sqlite3VdbeSetP4KeyInfo(Parse *pParse, Index *pIdx){\n  Vdbe *v = pParse->pVdbe;\n  KeyInfo *pKeyInfo;\n  assert( v!=0 );\n  assert( pIdx!=0 );\n  pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx);\n  if( pKeyInfo ) sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);\n}\n\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n/*\n** Change the comment on the most recently coded instruction.  Or\n** insert a No-op and add the comment to that new instruction.  This\n** makes the code easier to read during debugging.  None of this happens\n** in a production build.\n*/\nstatic void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}\nvoid sqlite3VdbeComment(Vdbe *p, const char *zFormat, ...){\n  va_list ap;\n  if( p ){\n    va_start(ap, zFormat);\n    vdbeVComment(p, zFormat, ap);\n    va_end(ap);\n  }\n}\nvoid sqlite3VdbeNoopComment(Vdbe *p, const char *zFormat, ...){\n  va_list ap;\n  if( p ){\n    sqlite3VdbeAddOp0(p, OP_Noop);\n    va_start(ap, zFormat);\n    vdbeVComment(p, zFormat, ap);\n    va_end(ap);\n  }\n}\n#endif  /* NDEBUG */\n\n#ifdef SQLITE_VDBE_COVERAGE\n/*\n** Set the value if the iSrcLine field for the previously coded instruction.\n*/\nvoid sqlite3VdbeSetLineNumber(Vdbe *v, int iLine){\n  sqlite3VdbeGetOp(v,-1)->iSrcLine = iLine;\n}\n#endif /* SQLITE_VDBE_COVERAGE */\n\n/*\n** Return the opcode for a given address.  If the address is -1, then\n** return the most recently inserted opcode.\n**\n** If a memory allocation error has occurred prior to the calling of this\n** routine, then a pointer to a dummy VdbeOp will be returned.  That opcode\n** is readable but not writable, though it is cast to a writable value.\n** The return of a dummy opcode allows the call to continue functioning\n** after an OOM fault without having to check to see if the return from \n** this routine is a valid pointer.  But because the dummy.opcode is 0,\n** dummy will never be written to.  This is verified by code inspection and\n** by running with Valgrind.\n*/\nVdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){\n  /* C89 specifies that the constant \"dummy\" will be initialized to all\n  ** zeros, which is correct.  MSVC generates a warning, nevertheless. */\n  static VdbeOp dummy;  /* Ignore the MSVC warning about no initializer */\n  assert( p->magic==VDBE_MAGIC_INIT );\n  if( addr<0 ){\n    addr = p->nOp - 1;\n  }\n  assert( (addr>=0 && addr<p->nOp) || p->db->mallocFailed );\n  if( p->db->mallocFailed ){\n    return (VdbeOp*)&dummy;\n  }else{\n    return &p->aOp[addr];\n  }\n}\n\n#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS)\n/*\n** Return an integer value for one of the parameters to the opcode pOp\n** determined by character c.\n*/\nstatic int translateP(char c, const Op *pOp){\n  if( c=='1' ) return pOp->p1;\n  if( c=='2' ) return pOp->p2;\n  if( c=='3' ) return pOp->p3;\n  if( c=='4' ) return pOp->p4.i;\n  return pOp->p5;\n}\n\n/*\n** Compute a string for the \"comment\" field of a VDBE opcode listing.\n**\n** The Synopsis: field in comments in the vdbe.c source file gets converted\n** to an extra string that is appended to the sqlite3OpcodeName().  In the\n** absence of other comments, this synopsis becomes the comment on the opcode.\n** Some translation occurs:\n**\n**       \"PX\"      ->  \"r[X]\"\n**       \"PX@PY\"   ->  \"r[X..X+Y-1]\"  or \"r[x]\" if y is 0 or 1\n**       \"PX@PY+1\" ->  \"r[X..X+Y]\"    or \"r[x]\" if y is 0\n**       \"PY..PY\"  ->  \"r[X..Y]\"      or \"r[x]\" if y<=x\n*/\nstatic int displayComment(\n  const Op *pOp,     /* The opcode to be commented */\n  const char *zP4,   /* Previously obtained value for P4 */\n  char *zTemp,       /* Write result here */\n  int nTemp          /* Space available in zTemp[] */\n){\n  const char *zOpName;\n  const char *zSynopsis;\n  int nOpName;\n  int ii, jj;\n  char zAlt[50];\n  zOpName = sqlite3OpcodeName(pOp->opcode);\n  nOpName = sqlite3Strlen30(zOpName);\n  if( zOpName[nOpName+1] ){\n    int seenCom = 0;\n    char c;\n    zSynopsis = zOpName += nOpName + 1;\n    if( strncmp(zSynopsis,\"IF \",3)==0 ){\n      if( pOp->p5 & SQLITE_STOREP2 ){\n        sqlite3_snprintf(sizeof(zAlt), zAlt, \"r[P2] = (%s)\", zSynopsis+3);\n      }else{\n        sqlite3_snprintf(sizeof(zAlt), zAlt, \"if %s goto P2\", zSynopsis+3);\n      }\n      zSynopsis = zAlt;\n    }\n    for(ii=jj=0; jj<nTemp-1 && (c = zSynopsis[ii])!=0; ii++){\n      if( c=='P' ){\n        c = zSynopsis[++ii];\n        if( c=='4' ){\n          sqlite3_snprintf(nTemp-jj, zTemp+jj, \"%s\", zP4);\n        }else if( c=='X' ){\n          sqlite3_snprintf(nTemp-jj, zTemp+jj, \"%s\", pOp->zComment);\n          seenCom = 1;\n        }else{\n          int v1 = translateP(c, pOp);\n          int v2;\n          sqlite3_snprintf(nTemp-jj, zTemp+jj, \"%d\", v1);\n          if( strncmp(zSynopsis+ii+1, \"@P\", 2)==0 ){\n            ii += 3;\n            jj += sqlite3Strlen30(zTemp+jj);\n            v2 = translateP(zSynopsis[ii], pOp);\n            if( strncmp(zSynopsis+ii+1,\"+1\",2)==0 ){\n              ii += 2;\n              v2++;\n            }\n            if( v2>1 ){\n              sqlite3_snprintf(nTemp-jj, zTemp+jj, \"..%d\", v1+v2-1);\n            }\n          }else if( strncmp(zSynopsis+ii+1, \"..P3\", 4)==0 && pOp->p3==0 ){\n            ii += 4;\n          }\n        }\n        jj += sqlite3Strlen30(zTemp+jj);\n      }else{\n        zTemp[jj++] = c;\n      }\n    }\n    if( !seenCom && jj<nTemp-5 && pOp->zComment ){\n      sqlite3_snprintf(nTemp-jj, zTemp+jj, \"; %s\", pOp->zComment);\n      jj += sqlite3Strlen30(zTemp+jj);\n    }\n    if( jj<nTemp ) zTemp[jj] = 0;\n  }else if( pOp->zComment ){\n    sqlite3_snprintf(nTemp, zTemp, \"%s\", pOp->zComment);\n    jj = sqlite3Strlen30(zTemp);\n  }else{\n    zTemp[0] = 0;\n    jj = 0;\n  }\n  return jj;\n}\n#endif /* SQLITE_DEBUG */\n\n#if VDBE_DISPLAY_P4 && defined(SQLITE_ENABLE_CURSOR_HINTS)\n/*\n** Translate the P4.pExpr value for an OP_CursorHint opcode into text\n** that can be displayed in the P4 column of EXPLAIN output.\n*/\nstatic void displayP4Expr(StrAccum *p, Expr *pExpr){\n  const char *zOp = 0;\n  switch( pExpr->op ){\n    case TK_STRING:\n      sqlite3_str_appendf(p, \"%Q\", pExpr->u.zToken);\n      break;\n    case TK_INTEGER:\n      sqlite3_str_appendf(p, \"%d\", pExpr->u.iValue);\n      break;\n    case TK_NULL:\n      sqlite3_str_appendf(p, \"NULL\");\n      break;\n    case TK_REGISTER: {\n      sqlite3_str_appendf(p, \"r[%d]\", pExpr->iTable);\n      break;\n    }\n    case TK_COLUMN: {\n      if( pExpr->iColumn<0 ){\n        sqlite3_str_appendf(p, \"rowid\");\n      }else{\n        sqlite3_str_appendf(p, \"c%d\", (int)pExpr->iColumn);\n      }\n      break;\n    }\n    case TK_LT:      zOp = \"LT\";      break;\n    case TK_LE:      zOp = \"LE\";      break;\n    case TK_GT:      zOp = \"GT\";      break;\n    case TK_GE:      zOp = \"GE\";      break;\n    case TK_NE:      zOp = \"NE\";      break;\n    case TK_EQ:      zOp = \"EQ\";      break;\n    case TK_IS:      zOp = \"IS\";      break;\n    case TK_ISNOT:   zOp = \"ISNOT\";   break;\n    case TK_AND:     zOp = \"AND\";     break;\n    case TK_OR:      zOp = \"OR\";      break;\n    case TK_PLUS:    zOp = \"ADD\";     break;\n    case TK_STAR:    zOp = \"MUL\";     break;\n    case TK_MINUS:   zOp = \"SUB\";     break;\n    case TK_REM:     zOp = \"REM\";     break;\n    case TK_BITAND:  zOp = \"BITAND\";  break;\n    case TK_BITOR:   zOp = \"BITOR\";   break;\n    case TK_SLASH:   zOp = \"DIV\";     break;\n    case TK_LSHIFT:  zOp = \"LSHIFT\";  break;\n    case TK_RSHIFT:  zOp = \"RSHIFT\";  break;\n    case TK_CONCAT:  zOp = \"CONCAT\";  break;\n    case TK_UMINUS:  zOp = \"MINUS\";   break;\n    case TK_UPLUS:   zOp = \"PLUS\";    break;\n    case TK_BITNOT:  zOp = \"BITNOT\";  break;\n    case TK_NOT:     zOp = \"NOT\";     break;\n    case TK_ISNULL:  zOp = \"ISNULL\";  break;\n    case TK_NOTNULL: zOp = \"NOTNULL\"; break;\n\n    default:\n      sqlite3_str_appendf(p, \"%s\", \"expr\");\n      break;\n  }\n\n  if( zOp ){\n    sqlite3_str_appendf(p, \"%s(\", zOp);\n    displayP4Expr(p, pExpr->pLeft);\n    if( pExpr->pRight ){\n      sqlite3_str_append(p, \",\", 1);\n      displayP4Expr(p, pExpr->pRight);\n    }\n    sqlite3_str_append(p, \")\", 1);\n  }\n}\n#endif /* VDBE_DISPLAY_P4 && defined(SQLITE_ENABLE_CURSOR_HINTS) */\n\n\n#if VDBE_DISPLAY_P4\n/*\n** Compute a string that describes the P4 parameter for an opcode.\n** Use zTemp for any required temporary buffer space.\n*/\nstatic char *displayP4(Op *pOp, char *zTemp, int nTemp){\n  char *zP4 = zTemp;\n  StrAccum x;\n  assert( nTemp>=20 );\n  sqlite3StrAccumInit(&x, 0, zTemp, nTemp, 0);\n  switch( pOp->p4type ){\n    case P4_KEYINFO: {\n      int j;\n      KeyInfo *pKeyInfo = pOp->p4.pKeyInfo;\n      assert( pKeyInfo->aSortFlags!=0 );\n      sqlite3_str_appendf(&x, \"k(%d\", pKeyInfo->nKeyField);\n      for(j=0; j<pKeyInfo->nKeyField; j++){\n        CollSeq *pColl = pKeyInfo->aColl[j];\n        const char *zColl = pColl ? pColl->zName : \"\";\n        if( strcmp(zColl, \"BINARY\")==0 ) zColl = \"B\";\n        sqlite3_str_appendf(&x, \",%s%s%s\", \n               (pKeyInfo->aSortFlags[j] & KEYINFO_ORDER_DESC) ? \"-\" : \"\", \n               (pKeyInfo->aSortFlags[j] & KEYINFO_ORDER_BIGNULL)? \"N.\" : \"\", \n               zColl);\n      }\n      sqlite3_str_append(&x, \")\", 1);\n      break;\n    }\n#ifdef SQLITE_ENABLE_CURSOR_HINTS\n    case P4_EXPR: {\n      displayP4Expr(&x, pOp->p4.pExpr);\n      break;\n    }\n#endif\n    case P4_COLLSEQ: {\n      CollSeq *pColl = pOp->p4.pColl;\n      sqlite3_str_appendf(&x, \"(%.20s)\", pColl->zName);\n      break;\n    }\n    case P4_FUNCDEF: {\n      FuncDef *pDef = pOp->p4.pFunc;\n      sqlite3_str_appendf(&x, \"%s(%d)\", pDef->zName, pDef->nArg);\n      break;\n    }\n    case P4_FUNCCTX: {\n      FuncDef *pDef = pOp->p4.pCtx->pFunc;\n      sqlite3_str_appendf(&x, \"%s(%d)\", pDef->zName, pDef->nArg);\n      break;\n    }\n    case P4_INT64: {\n      sqlite3_str_appendf(&x, \"%lld\", *pOp->p4.pI64);\n      break;\n    }\n    case P4_INT32: {\n      sqlite3_str_appendf(&x, \"%d\", pOp->p4.i);\n      break;\n    }\n    case P4_REAL: {\n      sqlite3_str_appendf(&x, \"%.16g\", *pOp->p4.pReal);\n      break;\n    }\n    case P4_MEM: {\n      Mem *pMem = pOp->p4.pMem;\n      if( pMem->flags & MEM_Str ){\n        zP4 = pMem->z;\n      }else if( pMem->flags & (MEM_Int|MEM_IntReal) ){\n        sqlite3_str_appendf(&x, \"%lld\", pMem->u.i);\n      }else if( pMem->flags & MEM_Real ){\n        sqlite3_str_appendf(&x, \"%.16g\", pMem->u.r);\n      }else if( pMem->flags & MEM_Null ){\n        zP4 = \"NULL\";\n      }else{\n        assert( pMem->flags & MEM_Blob );\n        zP4 = \"(blob)\";\n      }\n      break;\n    }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    case P4_VTAB: {\n      sqlite3_vtab *pVtab = pOp->p4.pVtab->pVtab;\n      sqlite3_str_appendf(&x, \"vtab:%p\", pVtab);\n      break;\n    }\n#endif\n    case P4_INTARRAY: {\n      int i;\n      int *ai = pOp->p4.ai;\n      int n = ai[0];   /* The first element of an INTARRAY is always the\n                       ** count of the number of elements to follow */\n      for(i=1; i<=n; i++){\n        sqlite3_str_appendf(&x, \",%d\", ai[i]);\n      }\n      zTemp[0] = '[';\n      sqlite3_str_append(&x, \"]\", 1);\n      break;\n    }\n    case P4_SUBPROGRAM: {\n      sqlite3_str_appendf(&x, \"program\");\n      break;\n    }\n    case P4_DYNBLOB:\n    case P4_ADVANCE: {\n      zTemp[0] = 0;\n      break;\n    }\n    case P4_TABLE: {\n      sqlite3_str_appendf(&x, \"%s\", pOp->p4.pTab->zName);\n      break;\n    }\n    default: {\n      zP4 = pOp->p4.z;\n      if( zP4==0 ){\n        zP4 = zTemp;\n        zTemp[0] = 0;\n      }\n    }\n  }\n  sqlite3StrAccumFinish(&x);\n  assert( zP4!=0 );\n  return zP4;\n}\n#endif /* VDBE_DISPLAY_P4 */\n\n/*\n** Declare to the Vdbe that the BTree object at db->aDb[i] is used.\n**\n** The prepared statements need to know in advance the complete set of\n** attached databases that will be use.  A mask of these databases\n** is maintained in p->btreeMask.  The p->lockMask value is the subset of\n** p->btreeMask of databases that will require a lock.\n*/\nvoid sqlite3VdbeUsesBtree(Vdbe *p, int i){\n  assert( i>=0 && i<p->db->nDb && i<(int)sizeof(yDbMask)*8 );\n  assert( i<(int)sizeof(p->btreeMask)*8 );\n  DbMaskSet(p->btreeMask, i);\n  if( i!=1 && sqlite3BtreeSharable(p->db->aDb[i].pBt) ){\n    DbMaskSet(p->lockMask, i);\n  }\n}\n\n#if !defined(SQLITE_OMIT_SHARED_CACHE)\n/*\n** If SQLite is compiled to support shared-cache mode and to be threadsafe,\n** this routine obtains the mutex associated with each BtShared structure\n** that may be accessed by the VM passed as an argument. In doing so it also\n** sets the BtShared.db member of each of the BtShared structures, ensuring\n** that the correct busy-handler callback is invoked if required.\n**\n** If SQLite is not threadsafe but does support shared-cache mode, then\n** sqlite3BtreeEnter() is invoked to set the BtShared.db variables\n** of all of BtShared structures accessible via the database handle \n** associated with the VM.\n**\n** If SQLite is not threadsafe and does not support shared-cache mode, this\n** function is a no-op.\n**\n** The p->btreeMask field is a bitmask of all btrees that the prepared \n** statement p will ever use.  Let N be the number of bits in p->btreeMask\n** corresponding to btrees that use shared cache.  Then the runtime of\n** this routine is N*N.  But as N is rarely more than 1, this should not\n** be a problem.\n*/\nvoid sqlite3VdbeEnter(Vdbe *p){\n  int i;\n  sqlite3 *db;\n  Db *aDb;\n  int nDb;\n  if( DbMaskAllZero(p->lockMask) ) return;  /* The common case */\n  db = p->db;\n  aDb = db->aDb;\n  nDb = db->nDb;\n  for(i=0; i<nDb; i++){\n    if( i!=1 && DbMaskTest(p->lockMask,i) && ALWAYS(aDb[i].pBt!=0) ){\n      sqlite3BtreeEnter(aDb[i].pBt);\n    }\n  }\n}\n#endif\n\n#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE>0\n/*\n** Unlock all of the btrees previously locked by a call to sqlite3VdbeEnter().\n*/\nstatic SQLITE_NOINLINE void vdbeLeave(Vdbe *p){\n  int i;\n  sqlite3 *db;\n  Db *aDb;\n  int nDb;\n  db = p->db;\n  aDb = db->aDb;\n  nDb = db->nDb;\n  for(i=0; i<nDb; i++){\n    if( i!=1 && DbMaskTest(p->lockMask,i) && ALWAYS(aDb[i].pBt!=0) ){\n      sqlite3BtreeLeave(aDb[i].pBt);\n    }\n  }\n}\nvoid sqlite3VdbeLeave(Vdbe *p){\n  if( DbMaskAllZero(p->lockMask) ) return;  /* The common case */\n  vdbeLeave(p);\n}\n#endif\n\n#if defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)\n/*\n** Print a single opcode.  This routine is used for debugging only.\n*/\nvoid sqlite3VdbePrintOp(FILE *pOut, int pc, VdbeOp *pOp){\n  char *zP4;\n  char zPtr[50];\n  char zCom[100];\n  static const char *zFormat1 = \"%4d %-13s %4d %4d %4d %-13s %.2X %s\\n\";\n  if( pOut==0 ) pOut = stdout;\n  zP4 = displayP4(pOp, zPtr, sizeof(zPtr));\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n  displayComment(pOp, zP4, zCom, sizeof(zCom));\n#else\n  zCom[0] = 0;\n#endif\n  /* NB:  The sqlite3OpcodeName() function is implemented by code created\n  ** by the mkopcodeh.awk and mkopcodec.awk scripts which extract the\n  ** information from the vdbe.c source text */\n  fprintf(pOut, zFormat1, pc, \n      sqlite3OpcodeName(pOp->opcode), pOp->p1, pOp->p2, pOp->p3, zP4, pOp->p5,\n      zCom\n  );\n  fflush(pOut);\n}\n#endif\n\n/*\n** Initialize an array of N Mem element.\n*/\nstatic void initMemArray(Mem *p, int N, sqlite3 *db, u16 flags){\n  while( (N--)>0 ){\n    p->db = db;\n    p->flags = flags;\n    p->szMalloc = 0;\n#ifdef SQLITE_DEBUG\n    p->pScopyFrom = 0;\n#endif\n    p++;\n  }\n}\n\n/*\n** Release an array of N Mem elements\n*/\nstatic void releaseMemArray(Mem *p, int N){\n  if( p && N ){\n    Mem *pEnd = &p[N];\n    sqlite3 *db = p->db;\n    if( db->pnBytesFreed ){\n      do{\n        if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);\n      }while( (++p)<pEnd );\n      return;\n    }\n    do{\n      assert( (&p[1])==pEnd || p[0].db==p[1].db );\n      assert( sqlite3VdbeCheckMemInvariants(p) );\n\n      /* This block is really an inlined version of sqlite3VdbeMemRelease()\n      ** that takes advantage of the fact that the memory cell value is \n      ** being set to NULL after releasing any dynamic resources.\n      **\n      ** The justification for duplicating code is that according to \n      ** callgrind, this causes a certain test case to hit the CPU 4.7 \n      ** percent less (x86 linux, gcc version 4.1.2, -O6) than if \n      ** sqlite3MemRelease() were called from here. With -O2, this jumps\n      ** to 6.6 percent. The test case is inserting 1000 rows into a table \n      ** with no indexes using a single prepared INSERT statement, bind() \n      ** and reset(). Inserts are grouped into a transaction.\n      */\n      testcase( p->flags & MEM_Agg );\n      testcase( p->flags & MEM_Dyn );\n      testcase( p->xDel==sqlite3VdbeFrameMemDel );\n      if( p->flags&(MEM_Agg|MEM_Dyn) ){\n        sqlite3VdbeMemRelease(p);\n      }else if( p->szMalloc ){\n        sqlite3DbFreeNN(db, p->zMalloc);\n        p->szMalloc = 0;\n      }\n\n      p->flags = MEM_Undefined;\n    }while( (++p)<pEnd );\n  }\n}\n\n#ifdef SQLITE_DEBUG\n/*\n** Verify that pFrame is a valid VdbeFrame pointer.  Return true if it is\n** and false if something is wrong.\n**\n** This routine is intended for use inside of assert() statements only.\n*/\nint sqlite3VdbeFrameIsValid(VdbeFrame *pFrame){\n  if( pFrame->iFrameMagic!=SQLITE_FRAME_MAGIC ) return 0;\n  return 1;\n}\n#endif\n\n\n/*\n** This is a destructor on a Mem object (which is really an sqlite3_value)\n** that deletes the Frame object that is attached to it as a blob.\n**\n** This routine does not delete the Frame right away.  It merely adds the\n** frame to a list of frames to be deleted when the Vdbe halts.\n*/\nvoid sqlite3VdbeFrameMemDel(void *pArg){\n  VdbeFrame *pFrame = (VdbeFrame*)pArg;\n  assert( sqlite3VdbeFrameIsValid(pFrame) );\n  pFrame->pParent = pFrame->v->pDelFrame;\n  pFrame->v->pDelFrame = pFrame;\n}\n\n\n/*\n** Delete a VdbeFrame object and its contents. VdbeFrame objects are\n** allocated by the OP_Program opcode in sqlite3VdbeExec().\n*/\nvoid sqlite3VdbeFrameDelete(VdbeFrame *p){\n  int i;\n  Mem *aMem = VdbeFrameMem(p);\n  VdbeCursor **apCsr = (VdbeCursor **)&aMem[p->nChildMem];\n  assert( sqlite3VdbeFrameIsValid(p) );\n  for(i=0; i<p->nChildCsr; i++){\n    sqlite3VdbeFreeCursor(p->v, apCsr[i]);\n  }\n  releaseMemArray(aMem, p->nChildMem);\n  sqlite3VdbeDeleteAuxData(p->v->db, &p->pAuxData, -1, 0);\n  sqlite3DbFree(p->v->db, p);\n}\n\n#ifndef SQLITE_OMIT_EXPLAIN\n/*\n** Give a listing of the program in the virtual machine.\n**\n** The interface is the same as sqlite3VdbeExec().  But instead of\n** running the code, it invokes the callback once for each instruction.\n** This feature is used to implement \"EXPLAIN\".\n**\n** When p->explain==1, each instruction is listed.  When\n** p->explain==2, only OP_Explain instructions are listed and these\n** are shown in a different format.  p->explain==2 is used to implement\n** EXPLAIN QUERY PLAN.\n** 2018-04-24:  In p->explain==2 mode, the OP_Init opcodes of triggers\n** are also shown, so that the boundaries between the main program and\n** each trigger are clear.\n**\n** When p->explain==1, first the main program is listed, then each of\n** the trigger subprograms are listed one by one.\n*/\nint sqlite3VdbeList(\n  Vdbe *p                   /* The VDBE */\n){\n  int nRow;                            /* Stop when row count reaches this */\n  int nSub = 0;                        /* Number of sub-vdbes seen so far */\n  SubProgram **apSub = 0;              /* Array of sub-vdbes */\n  Mem *pSub = 0;                       /* Memory cell hold array of subprogs */\n  sqlite3 *db = p->db;                 /* The database connection */\n  int i;                               /* Loop counter */\n  int rc = SQLITE_OK;                  /* Return code */\n  Mem *pMem = &p->aMem[1];             /* First Mem of result set */\n  int bListSubprogs = (p->explain==1 || (db->flags & SQLITE_TriggerEQP)!=0);\n  Op *pOp = 0;\n\n  assert( p->explain );\n  assert( p->magic==VDBE_MAGIC_RUN );\n  assert( p->rc==SQLITE_OK || p->rc==SQLITE_BUSY || p->rc==SQLITE_NOMEM );\n\n  /* Even though this opcode does not use dynamic strings for\n  ** the result, result columns may become dynamic if the user calls\n  ** sqlite3_column_text16(), causing a translation to UTF-16 encoding.\n  */\n  releaseMemArray(pMem, 8);\n  p->pResultSet = 0;\n\n  if( p->rc==SQLITE_NOMEM ){\n    /* This happens if a malloc() inside a call to sqlite3_column_text() or\n    ** sqlite3_column_text16() failed.  */\n    sqlite3OomFault(db);\n    return SQLITE_ERROR;\n  }\n\n  /* When the number of output rows reaches nRow, that means the\n  ** listing has finished and sqlite3_step() should return SQLITE_DONE.\n  ** nRow is the sum of the number of rows in the main program, plus\n  ** the sum of the number of rows in all trigger subprograms encountered\n  ** so far.  The nRow value will increase as new trigger subprograms are\n  ** encountered, but p->pc will eventually catch up to nRow.\n  */\n  nRow = p->nOp;\n  if( bListSubprogs ){\n    /* The first 8 memory cells are used for the result set.  So we will\n    ** commandeer the 9th cell to use as storage for an array of pointers\n    ** to trigger subprograms.  The VDBE is guaranteed to have at least 9\n    ** cells.  */\n    assert( p->nMem>9 );\n    pSub = &p->aMem[9];\n    if( pSub->flags&MEM_Blob ){\n      /* On the first call to sqlite3_step(), pSub will hold a NULL.  It is\n      ** initialized to a BLOB by the P4_SUBPROGRAM processing logic below */\n      nSub = pSub->n/sizeof(Vdbe*);\n      apSub = (SubProgram **)pSub->z;\n    }\n    for(i=0; i<nSub; i++){\n      nRow += apSub[i]->nOp;\n    }\n  }\n\n  while(1){  /* Loop exits via break */\n    i = p->pc++;\n    if( i>=nRow ){\n      p->rc = SQLITE_OK;\n      rc = SQLITE_DONE;\n      break;\n    }\n    if( i<p->nOp ){\n      /* The output line number is small enough that we are still in the\n      ** main program. */\n      pOp = &p->aOp[i];\n    }else{\n      /* We are currently listing subprograms.  Figure out which one and\n      ** pick up the appropriate opcode. */\n      int j;\n      i -= p->nOp;\n      assert( apSub!=0 );\n      assert( nSub>0 );\n      for(j=0; i>=apSub[j]->nOp; j++){\n        i -= apSub[j]->nOp;\n        assert( i<apSub[j]->nOp || j+1<nSub );\n      }\n      pOp = &apSub[j]->aOp[i];\n    }\n\n    /* When an OP_Program opcode is encounter (the only opcode that has\n    ** a P4_SUBPROGRAM argument), expand the size of the array of subprograms\n    ** kept in p->aMem[9].z to hold the new program - assuming this subprogram\n    ** has not already been seen.\n    */\n    if( bListSubprogs && pOp->p4type==P4_SUBPROGRAM ){\n      int nByte = (nSub+1)*sizeof(SubProgram*);\n      int j;\n      for(j=0; j<nSub; j++){\n        if( apSub[j]==pOp->p4.pProgram ) break;\n      }\n      if( j==nSub ){\n        p->rc = sqlite3VdbeMemGrow(pSub, nByte, nSub!=0);\n        if( p->rc!=SQLITE_OK ){\n          rc = SQLITE_ERROR;\n          break;\n        }\n        apSub = (SubProgram **)pSub->z;\n        apSub[nSub++] = pOp->p4.pProgram;\n        pSub->flags |= MEM_Blob;\n        pSub->n = nSub*sizeof(SubProgram*);\n        nRow += pOp->p4.pProgram->nOp;\n      }\n    }\n    if( p->explain<2 ) break;\n    if( pOp->opcode==OP_Explain ) break;\n    if( pOp->opcode==OP_Init && p->pc>1 ) break;\n  }\n\n  if( rc==SQLITE_OK ){\n    if( db->u1.isInterrupted ){\n      p->rc = SQLITE_INTERRUPT;\n      rc = SQLITE_ERROR;\n      sqlite3VdbeError(p, sqlite3ErrStr(p->rc));\n    }else{\n      char *zP4;\n      if( p->explain==1 ){\n        pMem->flags = MEM_Int;\n        pMem->u.i = i;                                /* Program counter */\n        pMem++;\n    \n        pMem->flags = MEM_Static|MEM_Str|MEM_Term;\n        pMem->z = (char*)sqlite3OpcodeName(pOp->opcode); /* Opcode */\n        assert( pMem->z!=0 );\n        pMem->n = sqlite3Strlen30(pMem->z);\n        pMem->enc = SQLITE_UTF8;\n        pMem++;\n      }\n\n      pMem->flags = MEM_Int;\n      pMem->u.i = pOp->p1;                          /* P1 */\n      pMem++;\n\n      pMem->flags = MEM_Int;\n      pMem->u.i = pOp->p2;                          /* P2 */\n      pMem++;\n\n      pMem->flags = MEM_Int;\n      pMem->u.i = pOp->p3;                          /* P3 */\n      pMem++;\n\n      if( sqlite3VdbeMemClearAndResize(pMem, 100) ){ /* P4 */\n        assert( p->db->mallocFailed );\n        return SQLITE_ERROR;\n      }\n      pMem->flags = MEM_Str|MEM_Term;\n      zP4 = displayP4(pOp, pMem->z, pMem->szMalloc);\n      if( zP4!=pMem->z ){\n        pMem->n = 0;\n        sqlite3VdbeMemSetStr(pMem, zP4, -1, SQLITE_UTF8, 0);\n      }else{\n        assert( pMem->z!=0 );\n        pMem->n = sqlite3Strlen30(pMem->z);\n        pMem->enc = SQLITE_UTF8;\n      }\n      pMem++;\n\n      if( p->explain==1 ){\n        if( sqlite3VdbeMemClearAndResize(pMem, 4) ){\n          assert( p->db->mallocFailed );\n          return SQLITE_ERROR;\n        }\n        pMem->flags = MEM_Str|MEM_Term;\n        pMem->n = 2;\n        sqlite3_snprintf(3, pMem->z, \"%.2x\", pOp->p5);   /* P5 */\n        pMem->enc = SQLITE_UTF8;\n        pMem++;\n    \n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n        if( sqlite3VdbeMemClearAndResize(pMem, 500) ){\n          assert( p->db->mallocFailed );\n          return SQLITE_ERROR;\n        }\n        pMem->flags = MEM_Str|MEM_Term;\n        pMem->n = displayComment(pOp, zP4, pMem->z, 500);\n        pMem->enc = SQLITE_UTF8;\n#else\n        pMem->flags = MEM_Null;                       /* Comment */\n#endif\n      }\n\n      p->nResColumn = 8 - 4*(p->explain-1);\n      p->pResultSet = &p->aMem[1];\n      p->rc = SQLITE_OK;\n      rc = SQLITE_ROW;\n    }\n  }\n  return rc;\n}\n#endif /* SQLITE_OMIT_EXPLAIN */\n\n#ifdef SQLITE_DEBUG\n/*\n** Print the SQL that was used to generate a VDBE program.\n*/\nvoid sqlite3VdbePrintSql(Vdbe *p){\n  const char *z = 0;\n  if( p->zSql ){\n    z = p->zSql;\n  }else if( p->nOp>=1 ){\n    const VdbeOp *pOp = &p->aOp[0];\n    if( pOp->opcode==OP_Init && pOp->p4.z!=0 ){\n      z = pOp->p4.z;\n      while( sqlite3Isspace(*z) ) z++;\n    }\n  }\n  if( z ) printf(\"SQL: [%s]\\n\", z);\n}\n#endif\n\n#if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE)\n/*\n** Print an IOTRACE message showing SQL content.\n*/\nvoid sqlite3VdbeIOTraceSql(Vdbe *p){\n  int nOp = p->nOp;\n  VdbeOp *pOp;\n  if( sqlite3IoTrace==0 ) return;\n  if( nOp<1 ) return;\n  pOp = &p->aOp[0];\n  if( pOp->opcode==OP_Init && pOp->p4.z!=0 ){\n    int i, j;\n    char z[1000];\n    sqlite3_snprintf(sizeof(z), z, \"%s\", pOp->p4.z);\n    for(i=0; sqlite3Isspace(z[i]); i++){}\n    for(j=0; z[i]; i++){\n      if( sqlite3Isspace(z[i]) ){\n        if( z[i-1]!=' ' ){\n          z[j++] = ' ';\n        }\n      }else{\n        z[j++] = z[i];\n      }\n    }\n    z[j] = 0;\n    sqlite3IoTrace(\"SQL %s\\n\", z);\n  }\n}\n#endif /* !SQLITE_OMIT_TRACE && SQLITE_ENABLE_IOTRACE */\n\n/* An instance of this object describes bulk memory available for use\n** by subcomponents of a prepared statement.  Space is allocated out\n** of a ReusableSpace object by the allocSpace() routine below.\n*/\nstruct ReusableSpace {\n  u8 *pSpace;            /* Available memory */\n  sqlite3_int64 nFree;   /* Bytes of available memory */\n  sqlite3_int64 nNeeded; /* Total bytes that could not be allocated */\n};\n\n/* Try to allocate nByte bytes of 8-byte aligned bulk memory for pBuf\n** from the ReusableSpace object.  Return a pointer to the allocated\n** memory on success.  If insufficient memory is available in the\n** ReusableSpace object, increase the ReusableSpace.nNeeded\n** value by the amount needed and return NULL.\n**\n** If pBuf is not initially NULL, that means that the memory has already\n** been allocated by a prior call to this routine, so just return a copy\n** of pBuf and leave ReusableSpace unchanged.\n**\n** This allocator is employed to repurpose unused slots at the end of the\n** opcode array of prepared state for other memory needs of the prepared\n** statement.\n*/\nstatic void *allocSpace(\n  struct ReusableSpace *p,  /* Bulk memory available for allocation */\n  void *pBuf,               /* Pointer to a prior allocation */\n  sqlite3_int64 nByte       /* Bytes of memory needed */\n){\n  assert( EIGHT_BYTE_ALIGNMENT(p->pSpace) );\n  if( pBuf==0 ){\n    nByte = ROUND8(nByte);\n    if( nByte <= p->nFree ){\n      p->nFree -= nByte;\n      pBuf = &p->pSpace[p->nFree];\n    }else{\n      p->nNeeded += nByte;\n    }\n  }\n  assert( EIGHT_BYTE_ALIGNMENT(pBuf) );\n  return pBuf;\n}\n\n/*\n** Rewind the VDBE back to the beginning in preparation for\n** running it.\n*/\nvoid sqlite3VdbeRewind(Vdbe *p){\n#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)\n  int i;\n#endif\n  assert( p!=0 );\n  assert( p->magic==VDBE_MAGIC_INIT || p->magic==VDBE_MAGIC_RESET );\n\n  /* There should be at least one opcode.\n  */\n  assert( p->nOp>0 );\n\n  /* Set the magic to VDBE_MAGIC_RUN sooner rather than later. */\n  p->magic = VDBE_MAGIC_RUN;\n\n#ifdef SQLITE_DEBUG\n  for(i=0; i<p->nMem; i++){\n    assert( p->aMem[i].db==p->db );\n  }\n#endif\n  p->pc = -1;\n  p->rc = SQLITE_OK;\n  p->errorAction = OE_Abort;\n  p->nChange = 0;\n  p->cacheCtr = 1;\n  p->minWriteFileFormat = 255;\n  p->iStatement = 0;\n  p->nFkConstraint = 0;\n#ifdef VDBE_PROFILE\n  for(i=0; i<p->nOp; i++){\n    p->aOp[i].cnt = 0;\n    p->aOp[i].cycles = 0;\n  }\n#endif\n}\n\n/*\n** Prepare a virtual machine for execution for the first time after\n** creating the virtual machine.  This involves things such\n** as allocating registers and initializing the program counter.\n** After the VDBE has be prepped, it can be executed by one or more\n** calls to sqlite3VdbeExec().  \n**\n** This function may be called exactly once on each virtual machine.\n** After this routine is called the VM has been \"packaged\" and is ready\n** to run.  After this routine is called, further calls to \n** sqlite3VdbeAddOp() functions are prohibited.  This routine disconnects\n** the Vdbe from the Parse object that helped generate it so that the\n** the Vdbe becomes an independent entity and the Parse object can be\n** destroyed.\n**\n** Use the sqlite3VdbeRewind() procedure to restore a virtual machine back\n** to its initial state after it has been run.\n*/\nvoid sqlite3VdbeMakeReady(\n  Vdbe *p,                       /* The VDBE */\n  Parse *pParse                  /* Parsing context */\n){\n  sqlite3 *db;                   /* The database connection */\n  int nVar;                      /* Number of parameters */\n  int nMem;                      /* Number of VM memory registers */\n  int nCursor;                   /* Number of cursors required */\n  int nArg;                      /* Number of arguments in subprograms */\n  int n;                         /* Loop counter */\n  struct ReusableSpace x;        /* Reusable bulk memory */\n\n  assert( p!=0 );\n  assert( p->nOp>0 );\n  assert( pParse!=0 );\n  assert( p->magic==VDBE_MAGIC_INIT );\n  assert( pParse==p->pParse );\n  db = p->db;\n  assert( db->mallocFailed==0 );\n  nVar = pParse->nVar;\n  nMem = pParse->nMem;\n  nCursor = pParse->nTab;\n  nArg = pParse->nMaxArg;\n  \n  /* Each cursor uses a memory cell.  The first cursor (cursor 0) can\n  ** use aMem[0] which is not otherwise used by the VDBE program.  Allocate\n  ** space at the end of aMem[] for cursors 1 and greater.\n  ** See also: allocateCursor().\n  */\n  nMem += nCursor;\n  if( nCursor==0 && nMem>0 ) nMem++;  /* Space for aMem[0] even if not used */\n\n  /* Figure out how much reusable memory is available at the end of the\n  ** opcode array.  This extra memory will be reallocated for other elements\n  ** of the prepared statement.\n  */\n  n = ROUND8(sizeof(Op)*p->nOp);              /* Bytes of opcode memory used */\n  x.pSpace = &((u8*)p->aOp)[n];               /* Unused opcode memory */\n  assert( EIGHT_BYTE_ALIGNMENT(x.pSpace) );\n  x.nFree = ROUNDDOWN8(pParse->szOpAlloc - n);  /* Bytes of unused memory */\n  assert( x.nFree>=0 );\n  assert( EIGHT_BYTE_ALIGNMENT(&x.pSpace[x.nFree]) );\n\n  resolveP2Values(p, &nArg);\n  p->usesStmtJournal = (u8)(pParse->isMultiWrite && pParse->mayAbort);\n  if( pParse->explain ){\n    static const char * const azColName[] = {\n       \"addr\", \"opcode\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"comment\",\n       \"id\", \"parent\", \"notused\", \"detail\"\n    };\n    int iFirst, mx, i;\n    if( nMem<10 ) nMem = 10;\n    if( pParse->explain==2 ){\n      sqlite3VdbeSetNumCols(p, 4);\n      iFirst = 8;\n      mx = 12;\n    }else{\n      sqlite3VdbeSetNumCols(p, 8);\n      iFirst = 0;\n      mx = 8;\n    }\n    for(i=iFirst; i<mx; i++){\n      sqlite3VdbeSetColName(p, i-iFirst, COLNAME_NAME,\n                            azColName[i], SQLITE_STATIC);\n    }\n  }\n  p->expired = 0;\n\n  /* Memory for registers, parameters, cursor, etc, is allocated in one or two\n  ** passes.  On the first pass, we try to reuse unused memory at the \n  ** end of the opcode array.  If we are unable to satisfy all memory\n  ** requirements by reusing the opcode array tail, then the second\n  ** pass will fill in the remainder using a fresh memory allocation.  \n  **\n  ** This two-pass approach that reuses as much memory as possible from\n  ** the leftover memory at the end of the opcode array.  This can significantly\n  ** reduce the amount of memory held by a prepared statement.\n  */\n  x.nNeeded = 0;\n  p->aMem = allocSpace(&x, 0, nMem*sizeof(Mem));\n  p->aVar = allocSpace(&x, 0, nVar*sizeof(Mem));\n  p->apArg = allocSpace(&x, 0, nArg*sizeof(Mem*));\n  p->apCsr = allocSpace(&x, 0, nCursor*sizeof(VdbeCursor*));\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n  p->anExec = allocSpace(&x, 0, p->nOp*sizeof(i64));\n#endif\n  if( x.nNeeded ){\n    x.pSpace = p->pFree = sqlite3DbMallocRawNN(db, x.nNeeded);\n    x.nFree = x.nNeeded;\n    if( !db->mallocFailed ){\n      p->aMem = allocSpace(&x, p->aMem, nMem*sizeof(Mem));\n      p->aVar = allocSpace(&x, p->aVar, nVar*sizeof(Mem));\n      p->apArg = allocSpace(&x, p->apArg, nArg*sizeof(Mem*));\n      p->apCsr = allocSpace(&x, p->apCsr, nCursor*sizeof(VdbeCursor*));\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n      p->anExec = allocSpace(&x, p->anExec, p->nOp*sizeof(i64));\n#endif\n    }\n  }\n\n  p->pVList = pParse->pVList;\n  pParse->pVList =  0;\n  p->explain = pParse->explain;\n  if( db->mallocFailed ){\n    p->nVar = 0;\n    p->nCursor = 0;\n    p->nMem = 0;\n  }else{\n    p->nCursor = nCursor;\n    p->nVar = (ynVar)nVar;\n    initMemArray(p->aVar, nVar, db, MEM_Null);\n    p->nMem = nMem;\n    initMemArray(p->aMem, nMem, db, MEM_Undefined);\n    memset(p->apCsr, 0, nCursor*sizeof(VdbeCursor*));\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n    memset(p->anExec, 0, p->nOp*sizeof(i64));\n#endif\n  }\n  sqlite3VdbeRewind(p);\n}\n\n/*\n** Close a VDBE cursor and release all the resources that cursor \n** happens to hold.\n*/\nvoid sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){\n  if( pCx==0 ){\n    return;\n  }\n  assert( pCx->pBtx==0 || pCx->eCurType==CURTYPE_BTREE );\n  switch( pCx->eCurType ){\n    case CURTYPE_SORTER: {\n      sqlite3VdbeSorterClose(p->db, pCx);\n      break;\n    }\n    case CURTYPE_BTREE: {\n      if( pCx->isEphemeral ){\n        if( pCx->pBtx ) sqlite3BtreeClose(pCx->pBtx);\n        /* The pCx->pCursor will be close automatically, if it exists, by\n        ** the call above. */\n      }else{\n        assert( pCx->uc.pCursor!=0 );\n        sqlite3BtreeCloseCursor(pCx->uc.pCursor);\n      }\n      break;\n    }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    case CURTYPE_VTAB: {\n      sqlite3_vtab_cursor *pVCur = pCx->uc.pVCur;\n      const sqlite3_module *pModule = pVCur->pVtab->pModule;\n      assert( pVCur->pVtab->nRef>0 );\n      pVCur->pVtab->nRef--;\n      pModule->xClose(pVCur);\n      break;\n    }\n#endif\n  }\n}\n\n/*\n** Close all cursors in the current frame.\n*/\nstatic void closeCursorsInFrame(Vdbe *p){\n  if( p->apCsr ){\n    int i;\n    for(i=0; i<p->nCursor; i++){\n      VdbeCursor *pC = p->apCsr[i];\n      if( pC ){\n        sqlite3VdbeFreeCursor(p, pC);\n        p->apCsr[i] = 0;\n      }\n    }\n  }\n}\n\n/*\n** Copy the values stored in the VdbeFrame structure to its Vdbe. This\n** is used, for example, when a trigger sub-program is halted to restore\n** control to the main program.\n*/\nint sqlite3VdbeFrameRestore(VdbeFrame *pFrame){\n  Vdbe *v = pFrame->v;\n  closeCursorsInFrame(v);\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n  v->anExec = pFrame->anExec;\n#endif\n  v->aOp = pFrame->aOp;\n  v->nOp = pFrame->nOp;\n  v->aMem = pFrame->aMem;\n  v->nMem = pFrame->nMem;\n  v->apCsr = pFrame->apCsr;\n  v->nCursor = pFrame->nCursor;\n  v->db->lastRowid = pFrame->lastRowid;\n  v->nChange = pFrame->nChange;\n  v->db->nChange = pFrame->nDbChange;\n  sqlite3VdbeDeleteAuxData(v->db, &v->pAuxData, -1, 0);\n  v->pAuxData = pFrame->pAuxData;\n  pFrame->pAuxData = 0;\n  return pFrame->pc;\n}\n\n/*\n** Close all cursors.\n**\n** Also release any dynamic memory held by the VM in the Vdbe.aMem memory \n** cell array. This is necessary as the memory cell array may contain\n** pointers to VdbeFrame objects, which may in turn contain pointers to\n** open cursors.\n*/\nstatic void closeAllCursors(Vdbe *p){\n  if( p->pFrame ){\n    VdbeFrame *pFrame;\n    for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);\n    sqlite3VdbeFrameRestore(pFrame);\n    p->pFrame = 0;\n    p->nFrame = 0;\n  }\n  assert( p->nFrame==0 );\n  closeCursorsInFrame(p);\n  if( p->aMem ){\n    releaseMemArray(p->aMem, p->nMem);\n  }\n  while( p->pDelFrame ){\n    VdbeFrame *pDel = p->pDelFrame;\n    p->pDelFrame = pDel->pParent;\n    sqlite3VdbeFrameDelete(pDel);\n  }\n\n  /* Delete any auxdata allocations made by the VM */\n  if( p->pAuxData ) sqlite3VdbeDeleteAuxData(p->db, &p->pAuxData, -1, 0);\n  assert( p->pAuxData==0 );\n}\n\n/*\n** Set the number of result columns that will be returned by this SQL\n** statement. This is now set at compile time, rather than during\n** execution of the vdbe program so that sqlite3_column_count() can\n** be called on an SQL statement before sqlite3_step().\n*/\nvoid sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){\n  int n;\n  sqlite3 *db = p->db;\n\n  if( p->nResColumn ){\n    releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);\n    sqlite3DbFree(db, p->aColName);\n  }\n  n = nResColumn*COLNAME_N;\n  p->nResColumn = (u16)nResColumn;\n  p->aColName = (Mem*)sqlite3DbMallocRawNN(db, sizeof(Mem)*n );\n  if( p->aColName==0 ) return;\n  initMemArray(p->aColName, n, db, MEM_Null);\n}\n\n/*\n** Set the name of the idx'th column to be returned by the SQL statement.\n** zName must be a pointer to a nul terminated string.\n**\n** This call must be made after a call to sqlite3VdbeSetNumCols().\n**\n** The final parameter, xDel, must be one of SQLITE_DYNAMIC, SQLITE_STATIC\n** or SQLITE_TRANSIENT. If it is SQLITE_DYNAMIC, then the buffer pointed\n** to by zName will be freed by sqlite3DbFree() when the vdbe is destroyed.\n*/\nint sqlite3VdbeSetColName(\n  Vdbe *p,                         /* Vdbe being configured */\n  int idx,                         /* Index of column zName applies to */\n  int var,                         /* One of the COLNAME_* constants */\n  const char *zName,               /* Pointer to buffer containing name */\n  void (*xDel)(void*)              /* Memory management strategy for zName */\n){\n  int rc;\n  Mem *pColName;\n  assert( idx<p->nResColumn );\n  assert( var<COLNAME_N );\n  if( p->db->mallocFailed ){\n    assert( !zName || xDel!=SQLITE_DYNAMIC );\n    return SQLITE_NOMEM_BKPT;\n  }\n  assert( p->aColName!=0 );\n  pColName = &(p->aColName[idx+var*p->nResColumn]);\n  rc = sqlite3VdbeMemSetStr(pColName, zName, -1, SQLITE_UTF8, xDel);\n  assert( rc!=0 || !zName || (pColName->flags&MEM_Term)!=0 );\n  return rc;\n}\n\n/*\n** A read or write transaction may or may not be active on database handle\n** db. If a transaction is active, commit it. If there is a\n** write-transaction spanning more than one database file, this routine\n** takes care of the master journal trickery.\n*/\nstatic int vdbeCommit(sqlite3 *db, Vdbe *p){\n  int i;\n  int nTrans = 0;  /* Number of databases with an active write-transaction\n                   ** that are candidates for a two-phase commit using a\n                   ** master-journal */\n  int rc = SQLITE_OK;\n  int needXcommit = 0;\n\n#ifdef SQLITE_OMIT_VIRTUALTABLE\n  /* With this option, sqlite3VtabSync() is defined to be simply \n  ** SQLITE_OK so p is not used. \n  */\n  UNUSED_PARAMETER(p);\n#endif\n\n  /* Before doing anything else, call the xSync() callback for any\n  ** virtual module tables written in this transaction. This has to\n  ** be done before determining whether a master journal file is \n  ** required, as an xSync() callback may add an attached database\n  ** to the transaction.\n  */\n  rc = sqlite3VtabSync(db, p);\n\n  /* This loop determines (a) if the commit hook should be invoked and\n  ** (b) how many database files have open write transactions, not \n  ** including the temp database. (b) is important because if more than \n  ** one database file has an open write transaction, a master journal\n  ** file is required for an atomic commit.\n  */ \n  for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ \n    Btree *pBt = db->aDb[i].pBt;\n    if( sqlite3BtreeIsInTrans(pBt) ){\n      /* Whether or not a database might need a master journal depends upon\n      ** its journal mode (among other things).  This matrix determines which\n      ** journal modes use a master journal and which do not */\n      static const u8 aMJNeeded[] = {\n        /* DELETE   */  1,\n        /* PERSIST   */ 1,\n        /* OFF       */ 0,\n        /* TRUNCATE  */ 1,\n        /* MEMORY    */ 0,\n        /* WAL       */ 0\n      };\n      Pager *pPager;   /* Pager associated with pBt */\n      needXcommit = 1;\n      sqlite3BtreeEnter(pBt);\n      pPager = sqlite3BtreePager(pBt);\n      if( db->aDb[i].safety_level!=PAGER_SYNCHRONOUS_OFF\n       && aMJNeeded[sqlite3PagerGetJournalMode(pPager)]\n       && sqlite3PagerIsMemdb(pPager)==0\n      ){ \n        assert( i!=1 );\n        nTrans++;\n      }\n      rc = sqlite3PagerExclusiveLock(pPager);\n      sqlite3BtreeLeave(pBt);\n    }\n  }\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  /* If there are any write-transactions at all, invoke the commit hook */\n  if( needXcommit && db->xCommitCallback ){\n    rc = db->xCommitCallback(db->pCommitArg);\n    if( rc ){\n      return SQLITE_CONSTRAINT_COMMITHOOK;\n    }\n  }\n\n  /* The simple case - no more than one database file (not counting the\n  ** TEMP database) has a transaction active.   There is no need for the\n  ** master-journal.\n  **\n  ** If the return value of sqlite3BtreeGetFilename() is a zero length\n  ** string, it means the main database is :memory: or a temp file.  In \n  ** that case we do not support atomic multi-file commits, so use the \n  ** simple case then too.\n  */\n  if( 0==sqlite3Strlen30(sqlite3BtreeGetFilename(db->aDb[0].pBt))\n   || nTrans<=1\n  ){\n    for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        rc = sqlite3BtreeCommitPhaseOne(pBt, 0);\n      }\n    }\n\n    /* Do the commit only if all databases successfully complete phase 1. \n    ** If one of the BtreeCommitPhaseOne() calls fails, this indicates an\n    ** IO error while deleting or truncating a journal file. It is unlikely,\n    ** but could happen. In this case abandon processing and return the error.\n    */\n    for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        rc = sqlite3BtreeCommitPhaseTwo(pBt, 0);\n      }\n    }\n    if( rc==SQLITE_OK ){\n      sqlite3VtabCommit(db);\n    }\n  }\n\n  /* The complex case - There is a multi-file write-transaction active.\n  ** This requires a master journal file to ensure the transaction is\n  ** committed atomically.\n  */\n#ifndef SQLITE_OMIT_DISKIO\n  else{\n    sqlite3_vfs *pVfs = db->pVfs;\n    char *zMaster = 0;   /* File-name for the master journal */\n    char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt);\n    sqlite3_file *pMaster = 0;\n    i64 offset = 0;\n    int res;\n    int retryCount = 0;\n    int nMainFile;\n\n    /* Select a master journal file name */\n    nMainFile = sqlite3Strlen30(zMainFile);\n    zMaster = sqlite3MPrintf(db, \"%s-mjXXXXXX9XXz%c%c\", zMainFile, 0, 0);\n    if( zMaster==0 ) return SQLITE_NOMEM_BKPT;\n    do {\n      u32 iRandom;\n      if( retryCount ){\n        if( retryCount>100 ){\n          sqlite3_log(SQLITE_FULL, \"MJ delete: %s\", zMaster);\n          sqlite3OsDelete(pVfs, zMaster, 0);\n          break;\n        }else if( retryCount==1 ){\n          sqlite3_log(SQLITE_FULL, \"MJ collide: %s\", zMaster);\n        }\n      }\n      retryCount++;\n      sqlite3_randomness(sizeof(iRandom), &iRandom);\n      sqlite3_snprintf(13, &zMaster[nMainFile], \"-mj%06X9%02X\",\n                               (iRandom>>8)&0xffffff, iRandom&0xff);\n      /* The antipenultimate character of the master journal name must\n      ** be \"9\" to avoid name collisions when using 8+3 filenames. */\n      assert( zMaster[sqlite3Strlen30(zMaster)-3]=='9' );\n      sqlite3FileSuffix3(zMainFile, zMaster);\n      rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res);\n    }while( rc==SQLITE_OK && res );\n    if( rc==SQLITE_OK ){\n      /* Open the master journal. */\n      rc = sqlite3OsOpenMalloc(pVfs, zMaster, &pMaster, \n          SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|\n          SQLITE_OPEN_EXCLUSIVE|SQLITE_OPEN_MASTER_JOURNAL, 0\n      );\n    }\n    if( rc!=SQLITE_OK ){\n      sqlite3DbFree(db, zMaster);\n      return rc;\n    }\n \n    /* Write the name of each database file in the transaction into the new\n    ** master journal file. If an error occurs at this point close\n    ** and delete the master journal file. All the individual journal files\n    ** still have 'null' as the master journal pointer, so they will roll\n    ** back independently if a failure occurs.\n    */\n    for(i=0; i<db->nDb; i++){\n      Btree *pBt = db->aDb[i].pBt;\n      if( sqlite3BtreeIsInTrans(pBt) ){\n        char const *zFile = sqlite3BtreeGetJournalname(pBt);\n        if( zFile==0 ){\n          continue;  /* Ignore TEMP and :memory: databases */\n        }\n        assert( zFile[0]!=0 );\n        rc = sqlite3OsWrite(pMaster, zFile, sqlite3Strlen30(zFile)+1, offset);\n        offset += sqlite3Strlen30(zFile)+1;\n        if( rc!=SQLITE_OK ){\n          sqlite3OsCloseFree(pMaster);\n          sqlite3OsDelete(pVfs, zMaster, 0);\n          sqlite3DbFree(db, zMaster);\n          return rc;\n        }\n      }\n    }\n\n    /* Sync the master journal file. If the IOCAP_SEQUENTIAL device\n    ** flag is set this is not required.\n    */\n    if( 0==(sqlite3OsDeviceCharacteristics(pMaster)&SQLITE_IOCAP_SEQUENTIAL)\n     && SQLITE_OK!=(rc = sqlite3OsSync(pMaster, SQLITE_SYNC_NORMAL))\n    ){\n      sqlite3OsCloseFree(pMaster);\n      sqlite3OsDelete(pVfs, zMaster, 0);\n      sqlite3DbFree(db, zMaster);\n      return rc;\n    }\n\n    /* Sync all the db files involved in the transaction. The same call\n    ** sets the master journal pointer in each individual journal. If\n    ** an error occurs here, do not delete the master journal file.\n    **\n    ** If the error occurs during the first call to\n    ** sqlite3BtreeCommitPhaseOne(), then there is a chance that the\n    ** master journal file will be orphaned. But we cannot delete it,\n    ** in case the master journal file name was written into the journal\n    ** file before the failure occurred.\n    */\n    for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ \n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        rc = sqlite3BtreeCommitPhaseOne(pBt, zMaster);\n      }\n    }\n    sqlite3OsCloseFree(pMaster);\n    assert( rc!=SQLITE_BUSY );\n    if( rc!=SQLITE_OK ){\n      sqlite3DbFree(db, zMaster);\n      return rc;\n    }\n\n    /* Delete the master journal file. This commits the transaction. After\n    ** doing this the directory is synced again before any individual\n    ** transaction files are deleted.\n    */\n    rc = sqlite3OsDelete(pVfs, zMaster, 1);\n    sqlite3DbFree(db, zMaster);\n    zMaster = 0;\n    if( rc ){\n      return rc;\n    }\n\n    /* All files and directories have already been synced, so the following\n    ** calls to sqlite3BtreeCommitPhaseTwo() are only closing files and\n    ** deleting or truncating journals. If something goes wrong while\n    ** this is happening we don't really care. The integrity of the\n    ** transaction is already guaranteed, but some stray 'cold' journals\n    ** may be lying around. Returning an error code won't help matters.\n    */\n    disable_simulated_io_errors();\n    sqlite3BeginBenignMalloc();\n    for(i=0; i<db->nDb; i++){ \n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        sqlite3BtreeCommitPhaseTwo(pBt, 1);\n      }\n    }\n    sqlite3EndBenignMalloc();\n    enable_simulated_io_errors();\n\n    sqlite3VtabCommit(db);\n  }\n#endif\n\n  return rc;\n}\n\n/* \n** This routine checks that the sqlite3.nVdbeActive count variable\n** matches the number of vdbe's in the list sqlite3.pVdbe that are\n** currently active. An assertion fails if the two counts do not match.\n** This is an internal self-check only - it is not an essential processing\n** step.\n**\n** This is a no-op if NDEBUG is defined.\n*/\n#ifndef NDEBUG\nstatic void checkActiveVdbeCnt(sqlite3 *db){\n  Vdbe *p;\n  int cnt = 0;\n  int nWrite = 0;\n  int nRead = 0;\n  p = db->pVdbe;\n  while( p ){\n    if( sqlite3_stmt_busy((sqlite3_stmt*)p) ){\n      cnt++;\n      if( p->readOnly==0 ) nWrite++;\n      if( p->bIsReader ) nRead++;\n    }\n    p = p->pNext;\n  }\n  assert( cnt==db->nVdbeActive );\n  assert( nWrite==db->nVdbeWrite );\n  assert( nRead==db->nVdbeRead );\n}\n#else\n#define checkActiveVdbeCnt(x)\n#endif\n\n/*\n** If the Vdbe passed as the first argument opened a statement-transaction,\n** close it now. Argument eOp must be either SAVEPOINT_ROLLBACK or\n** SAVEPOINT_RELEASE. If it is SAVEPOINT_ROLLBACK, then the statement\n** transaction is rolled back. If eOp is SAVEPOINT_RELEASE, then the \n** statement transaction is committed.\n**\n** If an IO error occurs, an SQLITE_IOERR_XXX error code is returned. \n** Otherwise SQLITE_OK.\n*/\nstatic SQLITE_NOINLINE int vdbeCloseStatement(Vdbe *p, int eOp){\n  sqlite3 *const db = p->db;\n  int rc = SQLITE_OK;\n  int i;\n  const int iSavepoint = p->iStatement-1;\n\n  assert( eOp==SAVEPOINT_ROLLBACK || eOp==SAVEPOINT_RELEASE);\n  assert( db->nStatement>0 );\n  assert( p->iStatement==(db->nStatement+db->nSavepoint) );\n\n  for(i=0; i<db->nDb; i++){ \n    int rc2 = SQLITE_OK;\n    Btree *pBt = db->aDb[i].pBt;\n    if( pBt ){\n      if( eOp==SAVEPOINT_ROLLBACK ){\n        rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_ROLLBACK, iSavepoint);\n      }\n      if( rc2==SQLITE_OK ){\n        rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_RELEASE, iSavepoint);\n      }\n      if( rc==SQLITE_OK ){\n        rc = rc2;\n      }\n    }\n  }\n  db->nStatement--;\n  p->iStatement = 0;\n\n  if( rc==SQLITE_OK ){\n    if( eOp==SAVEPOINT_ROLLBACK ){\n      rc = sqlite3VtabSavepoint(db, SAVEPOINT_ROLLBACK, iSavepoint);\n    }\n    if( rc==SQLITE_OK ){\n      rc = sqlite3VtabSavepoint(db, SAVEPOINT_RELEASE, iSavepoint);\n    }\n  }\n\n  /* If the statement transaction is being rolled back, also restore the \n  ** database handles deferred constraint counter to the value it had when \n  ** the statement transaction was opened.  */\n  if( eOp==SAVEPOINT_ROLLBACK ){\n    db->nDeferredCons = p->nStmtDefCons;\n    db->nDeferredImmCons = p->nStmtDefImmCons;\n  }\n  return rc;\n}\nint sqlite3VdbeCloseStatement(Vdbe *p, int eOp){\n  if( p->db->nStatement && p->iStatement ){\n    return vdbeCloseStatement(p, eOp);\n  }\n  return SQLITE_OK;\n}\n\n\n/*\n** This function is called when a transaction opened by the database \n** handle associated with the VM passed as an argument is about to be \n** committed. If there are outstanding deferred foreign key constraint\n** violations, return SQLITE_ERROR. Otherwise, SQLITE_OK.\n**\n** If there are outstanding FK violations and this function returns \n** SQLITE_ERROR, set the result of the VM to SQLITE_CONSTRAINT_FOREIGNKEY\n** and write an error message to it. Then return SQLITE_ERROR.\n*/\n#ifndef SQLITE_OMIT_FOREIGN_KEY\nint sqlite3VdbeCheckFk(Vdbe *p, int deferred){\n  sqlite3 *db = p->db;\n  if( (deferred && (db->nDeferredCons+db->nDeferredImmCons)>0) \n   || (!deferred && p->nFkConstraint>0) \n  ){\n    p->rc = SQLITE_CONSTRAINT_FOREIGNKEY;\n    p->errorAction = OE_Abort;\n    sqlite3VdbeError(p, \"FOREIGN KEY constraint failed\");\n    return SQLITE_ERROR;\n  }\n  return SQLITE_OK;\n}\n#endif\n\n/*\n** This routine is called the when a VDBE tries to halt.  If the VDBE\n** has made changes and is in autocommit mode, then commit those\n** changes.  If a rollback is needed, then do the rollback.\n**\n** This routine is the only way to move the state of a VM from\n** SQLITE_MAGIC_RUN to SQLITE_MAGIC_HALT.  It is harmless to\n** call this on a VM that is in the SQLITE_MAGIC_HALT state.\n**\n** Return an error code.  If the commit could not complete because of\n** lock contention, return SQLITE_BUSY.  If SQLITE_BUSY is returned, it\n** means the close did not happen and needs to be repeated.\n*/\nint sqlite3VdbeHalt(Vdbe *p){\n  int rc;                         /* Used to store transient return codes */\n  sqlite3 *db = p->db;\n\n  /* This function contains the logic that determines if a statement or\n  ** transaction will be committed or rolled back as a result of the\n  ** execution of this virtual machine. \n  **\n  ** If any of the following errors occur:\n  **\n  **     SQLITE_NOMEM\n  **     SQLITE_IOERR\n  **     SQLITE_FULL\n  **     SQLITE_INTERRUPT\n  **\n  ** Then the internal cache might have been left in an inconsistent\n  ** state.  We need to rollback the statement transaction, if there is\n  ** one, or the complete transaction if there is no statement transaction.\n  */\n\n  if( p->magic!=VDBE_MAGIC_RUN ){\n    return SQLITE_OK;\n  }\n  if( db->mallocFailed ){\n    p->rc = SQLITE_NOMEM_BKPT;\n  }\n  closeAllCursors(p);\n  checkActiveVdbeCnt(db);\n\n  /* No commit or rollback needed if the program never started or if the\n  ** SQL statement does not read or write a database file.  */\n  if( p->pc>=0 && p->bIsReader ){\n    int mrc;   /* Primary error code from p->rc */\n    int eStatementOp = 0;\n    int isSpecialError;            /* Set to true if a 'special' error */\n\n    /* Lock all btrees used by the statement */\n    sqlite3VdbeEnter(p);\n\n    /* Check for one of the special errors */\n    mrc = p->rc & 0xff;\n    isSpecialError = mrc==SQLITE_NOMEM || mrc==SQLITE_IOERR\n                     || mrc==SQLITE_INTERRUPT || mrc==SQLITE_FULL;\n    if( isSpecialError ){\n      /* If the query was read-only and the error code is SQLITE_INTERRUPT, \n      ** no rollback is necessary. Otherwise, at least a savepoint \n      ** transaction must be rolled back to restore the database to a \n      ** consistent state.\n      **\n      ** Even if the statement is read-only, it is important to perform\n      ** a statement or transaction rollback operation. If the error \n      ** occurred while writing to the journal, sub-journal or database\n      ** file as part of an effort to free up cache space (see function\n      ** pagerStress() in pager.c), the rollback is required to restore \n      ** the pager to a consistent state.\n      */\n      if( !p->readOnly || mrc!=SQLITE_INTERRUPT ){\n        if( (mrc==SQLITE_NOMEM || mrc==SQLITE_FULL) && p->usesStmtJournal ){\n          eStatementOp = SAVEPOINT_ROLLBACK;\n        }else{\n          /* We are forced to roll back the active transaction. Before doing\n          ** so, abort any other statements this handle currently has active.\n          */\n          sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);\n          sqlite3CloseSavepoints(db);\n          db->autoCommit = 1;\n          p->nChange = 0;\n        }\n      }\n    }\n\n    /* Check for immediate foreign key violations. */\n    if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){\n      sqlite3VdbeCheckFk(p, 0);\n    }\n  \n    /* If the auto-commit flag is set and this is the only active writer \n    ** VM, then we do either a commit or rollback of the current transaction. \n    **\n    ** Note: This block also runs if one of the special errors handled \n    ** above has occurred. \n    */\n    if( !sqlite3VtabInSync(db) \n     && db->autoCommit \n     && db->nVdbeWrite==(p->readOnly==0) \n    ){\n      if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){\n        rc = sqlite3VdbeCheckFk(p, 1);\n        if( rc!=SQLITE_OK ){\n          if( NEVER(p->readOnly) ){\n            sqlite3VdbeLeave(p);\n            return SQLITE_ERROR;\n          }\n          rc = SQLITE_CONSTRAINT_FOREIGNKEY;\n        }else{ \n          /* The auto-commit flag is true, the vdbe program was successful \n          ** or hit an 'OR FAIL' constraint and there are no deferred foreign\n          ** key constraints to hold up the transaction. This means a commit \n          ** is required. */\n          rc = vdbeCommit(db, p);\n        }\n        if( rc==SQLITE_BUSY && p->readOnly ){\n          sqlite3VdbeLeave(p);\n          return SQLITE_BUSY;\n        }else if( rc!=SQLITE_OK ){\n          p->rc = rc;\n          sqlite3RollbackAll(db, SQLITE_OK);\n          p->nChange = 0;\n        }else{\n          db->nDeferredCons = 0;\n          db->nDeferredImmCons = 0;\n          db->flags &= ~(u64)SQLITE_DeferFKs;\n          sqlite3CommitInternalChanges(db);\n        }\n      }else{\n        sqlite3RollbackAll(db, SQLITE_OK);\n        p->nChange = 0;\n      }\n      db->nStatement = 0;\n    }else if( eStatementOp==0 ){\n      if( p->rc==SQLITE_OK || p->errorAction==OE_Fail ){\n        eStatementOp = SAVEPOINT_RELEASE;\n      }else if( p->errorAction==OE_Abort ){\n        eStatementOp = SAVEPOINT_ROLLBACK;\n      }else{\n        sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);\n        sqlite3CloseSavepoints(db);\n        db->autoCommit = 1;\n        p->nChange = 0;\n      }\n    }\n  \n    /* If eStatementOp is non-zero, then a statement transaction needs to\n    ** be committed or rolled back. Call sqlite3VdbeCloseStatement() to\n    ** do so. If this operation returns an error, and the current statement\n    ** error code is SQLITE_OK or SQLITE_CONSTRAINT, then promote the\n    ** current statement error code.\n    */\n    if( eStatementOp ){\n      rc = sqlite3VdbeCloseStatement(p, eStatementOp);\n      if( rc ){\n        if( p->rc==SQLITE_OK || (p->rc&0xff)==SQLITE_CONSTRAINT ){\n          p->rc = rc;\n          sqlite3DbFree(db, p->zErrMsg);\n          p->zErrMsg = 0;\n        }\n        sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);\n        sqlite3CloseSavepoints(db);\n        db->autoCommit = 1;\n        p->nChange = 0;\n      }\n    }\n  \n    /* If this was an INSERT, UPDATE or DELETE and no statement transaction\n    ** has been rolled back, update the database connection change-counter. \n    */\n    if( p->changeCntOn ){\n      if( eStatementOp!=SAVEPOINT_ROLLBACK ){\n        sqlite3VdbeSetChanges(db, p->nChange);\n      }else{\n        sqlite3VdbeSetChanges(db, 0);\n      }\n      p->nChange = 0;\n    }\n\n    /* Release the locks */\n    sqlite3VdbeLeave(p);\n  }\n\n  /* We have successfully halted and closed the VM.  Record this fact. */\n  if( p->pc>=0 ){\n    db->nVdbeActive--;\n    if( !p->readOnly ) db->nVdbeWrite--;\n    if( p->bIsReader ) db->nVdbeRead--;\n    assert( db->nVdbeActive>=db->nVdbeRead );\n    assert( db->nVdbeRead>=db->nVdbeWrite );\n    assert( db->nVdbeWrite>=0 );\n  }\n  p->magic = VDBE_MAGIC_HALT;\n  checkActiveVdbeCnt(db);\n  if( db->mallocFailed ){\n    p->rc = SQLITE_NOMEM_BKPT;\n  }\n\n  /* If the auto-commit flag is set to true, then any locks that were held\n  ** by connection db have now been released. Call sqlite3ConnectionUnlocked() \n  ** to invoke any required unlock-notify callbacks.\n  */\n  if( db->autoCommit ){\n    sqlite3ConnectionUnlocked(db);\n  }\n\n  assert( db->nVdbeActive>0 || db->autoCommit==0 || db->nStatement==0 );\n  return (p->rc==SQLITE_BUSY ? SQLITE_BUSY : SQLITE_OK);\n}\n\n\n/*\n** Each VDBE holds the result of the most recent sqlite3_step() call\n** in p->rc.  This routine sets that result back to SQLITE_OK.\n*/\nvoid sqlite3VdbeResetStepResult(Vdbe *p){\n  p->rc = SQLITE_OK;\n}\n\n/*\n** Copy the error code and error message belonging to the VDBE passed\n** as the first argument to its database handle (so that they will be \n** returned by calls to sqlite3_errcode() and sqlite3_errmsg()).\n**\n** This function does not clear the VDBE error code or message, just\n** copies them to the database handle.\n*/\nint sqlite3VdbeTransferError(Vdbe *p){\n  sqlite3 *db = p->db;\n  int rc = p->rc;\n  if( p->zErrMsg ){\n    db->bBenignMalloc++;\n    sqlite3BeginBenignMalloc();\n    if( db->pErr==0 ) db->pErr = sqlite3ValueNew(db);\n    sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT);\n    sqlite3EndBenignMalloc();\n    db->bBenignMalloc--;\n  }else if( db->pErr ){\n    sqlite3ValueSetNull(db->pErr);\n  }\n  db->errCode = rc;\n  return rc;\n}\n\n#ifdef SQLITE_ENABLE_SQLLOG\n/*\n** If an SQLITE_CONFIG_SQLLOG hook is registered and the VM has been run, \n** invoke it.\n*/\nstatic void vdbeInvokeSqllog(Vdbe *v){\n  if( sqlite3GlobalConfig.xSqllog && v->rc==SQLITE_OK && v->zSql && v->pc>=0 ){\n    char *zExpanded = sqlite3VdbeExpandSql(v, v->zSql);\n    assert( v->db->init.busy==0 );\n    if( zExpanded ){\n      sqlite3GlobalConfig.xSqllog(\n          sqlite3GlobalConfig.pSqllogArg, v->db, zExpanded, 1\n      );\n      sqlite3DbFree(v->db, zExpanded);\n    }\n  }\n}\n#else\n# define vdbeInvokeSqllog(x)\n#endif\n\n/*\n** Clean up a VDBE after execution but do not delete the VDBE just yet.\n** Write any error messages into *pzErrMsg.  Return the result code.\n**\n** After this routine is run, the VDBE should be ready to be executed\n** again.\n**\n** To look at it another way, this routine resets the state of the\n** virtual machine from VDBE_MAGIC_RUN or VDBE_MAGIC_HALT back to\n** VDBE_MAGIC_INIT.\n*/\nint sqlite3VdbeReset(Vdbe *p){\n#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)\n  int i;\n#endif\n\n  sqlite3 *db;\n  db = p->db;\n\n  /* If the VM did not run to completion or if it encountered an\n  ** error, then it might not have been halted properly.  So halt\n  ** it now.\n  */\n  sqlite3VdbeHalt(p);\n\n  /* If the VDBE has been run even partially, then transfer the error code\n  ** and error message from the VDBE into the main database structure.  But\n  ** if the VDBE has just been set to run but has not actually executed any\n  ** instructions yet, leave the main database error information unchanged.\n  */\n  if( p->pc>=0 ){\n    vdbeInvokeSqllog(p);\n    sqlite3VdbeTransferError(p);\n    if( p->runOnlyOnce ) p->expired = 1;\n  }else if( p->rc && p->expired ){\n    /* The expired flag was set on the VDBE before the first call\n    ** to sqlite3_step(). For consistency (since sqlite3_step() was\n    ** called), set the database error in this case as well.\n    */\n    sqlite3ErrorWithMsg(db, p->rc, p->zErrMsg ? \"%s\" : 0, p->zErrMsg);\n  }\n\n  /* Reset register contents and reclaim error message memory.\n  */\n#ifdef SQLITE_DEBUG\n  /* Execute assert() statements to ensure that the Vdbe.apCsr[] and \n  ** Vdbe.aMem[] arrays have already been cleaned up.  */\n  if( p->apCsr ) for(i=0; i<p->nCursor; i++) assert( p->apCsr[i]==0 );\n  if( p->aMem ){\n    for(i=0; i<p->nMem; i++) assert( p->aMem[i].flags==MEM_Undefined );\n  }\n#endif\n  sqlite3DbFree(db, p->zErrMsg);\n  p->zErrMsg = 0;\n  p->pResultSet = 0;\n#ifdef SQLITE_DEBUG\n  p->nWrite = 0;\n#endif\n\n  /* Save profiling information from this VDBE run.\n  */\n#ifdef VDBE_PROFILE\n  {\n    FILE *out = fopen(\"vdbe_profile.out\", \"a\");\n    if( out ){\n      fprintf(out, \"---- \");\n      for(i=0; i<p->nOp; i++){\n        fprintf(out, \"%02x\", p->aOp[i].opcode);\n      }\n      fprintf(out, \"\\n\");\n      if( p->zSql ){\n        char c, pc = 0;\n        fprintf(out, \"-- \");\n        for(i=0; (c = p->zSql[i])!=0; i++){\n          if( pc=='\\n' ) fprintf(out, \"-- \");\n          putc(c, out);\n          pc = c;\n        }\n        if( pc!='\\n' ) fprintf(out, \"\\n\");\n      }\n      for(i=0; i<p->nOp; i++){\n        char zHdr[100];\n        sqlite3_snprintf(sizeof(zHdr), zHdr, \"%6u %12llu %8llu \",\n           p->aOp[i].cnt,\n           p->aOp[i].cycles,\n           p->aOp[i].cnt>0 ? p->aOp[i].cycles/p->aOp[i].cnt : 0\n        );\n        fprintf(out, \"%s\", zHdr);\n        sqlite3VdbePrintOp(out, i, &p->aOp[i]);\n      }\n      fclose(out);\n    }\n  }\n#endif\n  p->magic = VDBE_MAGIC_RESET;\n  return p->rc & db->errMask;\n}\n \n/*\n** Clean up and delete a VDBE after execution.  Return an integer which is\n** the result code.  Write any error message text into *pzErrMsg.\n*/\nint sqlite3VdbeFinalize(Vdbe *p){\n  int rc = SQLITE_OK;\n  if( p->magic==VDBE_MAGIC_RUN || p->magic==VDBE_MAGIC_HALT ){\n    rc = sqlite3VdbeReset(p);\n    assert( (rc & p->db->errMask)==rc );\n  }\n  sqlite3VdbeDelete(p);\n  return rc;\n}\n\n/*\n** If parameter iOp is less than zero, then invoke the destructor for\n** all auxiliary data pointers currently cached by the VM passed as\n** the first argument.\n**\n** Or, if iOp is greater than or equal to zero, then the destructor is\n** only invoked for those auxiliary data pointers created by the user \n** function invoked by the OP_Function opcode at instruction iOp of \n** VM pVdbe, and only then if:\n**\n**    * the associated function parameter is the 32nd or later (counting\n**      from left to right), or\n**\n**    * the corresponding bit in argument mask is clear (where the first\n**      function parameter corresponds to bit 0 etc.).\n*/\nvoid sqlite3VdbeDeleteAuxData(sqlite3 *db, AuxData **pp, int iOp, int mask){\n  while( *pp ){\n    AuxData *pAux = *pp;\n    if( (iOp<0)\n     || (pAux->iAuxOp==iOp\n          && pAux->iAuxArg>=0\n          && (pAux->iAuxArg>31 || !(mask & MASKBIT32(pAux->iAuxArg))))\n    ){\n      testcase( pAux->iAuxArg==31 );\n      if( pAux->xDeleteAux ){\n        pAux->xDeleteAux(pAux->pAux);\n      }\n      *pp = pAux->pNextAux;\n      sqlite3DbFree(db, pAux);\n    }else{\n      pp= &pAux->pNextAux;\n    }\n  }\n}\n\n/*\n** Free all memory associated with the Vdbe passed as the second argument,\n** except for object itself, which is preserved.\n**\n** The difference between this function and sqlite3VdbeDelete() is that\n** VdbeDelete() also unlinks the Vdbe from the list of VMs associated with\n** the database connection and frees the object itself.\n*/\nvoid sqlite3VdbeClearObject(sqlite3 *db, Vdbe *p){\n  SubProgram *pSub, *pNext;\n  assert( p->db==0 || p->db==db );\n  releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);\n  for(pSub=p->pProgram; pSub; pSub=pNext){\n    pNext = pSub->pNext;\n    vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);\n    sqlite3DbFree(db, pSub);\n  }\n  if( p->magic!=VDBE_MAGIC_INIT ){\n    releaseMemArray(p->aVar, p->nVar);\n    sqlite3DbFree(db, p->pVList);\n    sqlite3DbFree(db, p->pFree);\n  }\n  vdbeFreeOpArray(db, p->aOp, p->nOp);\n  sqlite3DbFree(db, p->aColName);\n  sqlite3DbFree(db, p->zSql);\n#ifdef SQLITE_ENABLE_NORMALIZE\n  sqlite3DbFree(db, p->zNormSql);\n  {\n    DblquoteStr *pThis, *pNext;\n    for(pThis=p->pDblStr; pThis; pThis=pNext){\n      pNext = pThis->pNextStr;\n      sqlite3DbFree(db, pThis);\n    }\n  }\n#endif\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n  {\n    int i;\n    for(i=0; i<p->nScan; i++){\n      sqlite3DbFree(db, p->aScan[i].zName);\n    }\n    sqlite3DbFree(db, p->aScan);\n  }\n#endif\n}\n\n/*\n** Delete an entire VDBE.\n*/\nvoid sqlite3VdbeDelete(Vdbe *p){\n  sqlite3 *db;\n\n  assert( p!=0 );\n  db = p->db;\n  assert( sqlite3_mutex_held(db->mutex) );\n  sqlite3VdbeClearObject(db, p);\n  if( p->pPrev ){\n    p->pPrev->pNext = p->pNext;\n  }else{\n    assert( db->pVdbe==p );\n    db->pVdbe = p->pNext;\n  }\n  if( p->pNext ){\n    p->pNext->pPrev = p->pPrev;\n  }\n  p->magic = VDBE_MAGIC_DEAD;\n  p->db = 0;\n  sqlite3DbFreeNN(db, p);\n}\n\n/*\n** The cursor \"p\" has a pending seek operation that has not yet been\n** carried out.  Seek the cursor now.  If an error occurs, return\n** the appropriate error code.\n*/\nstatic int SQLITE_NOINLINE handleDeferredMoveto(VdbeCursor *p){\n  int res, rc;\n#ifdef SQLITE_TEST\n  extern int sqlite3_search_count;\n#endif\n  assert( p->deferredMoveto );\n  assert( p->isTable );\n  assert( p->eCurType==CURTYPE_BTREE );\n  rc = sqlite3BtreeMovetoUnpacked(p->uc.pCursor, 0, p->movetoTarget, 0, &res);\n  if( rc ) return rc;\n  if( res!=0 ) return SQLITE_CORRUPT_BKPT;\n#ifdef SQLITE_TEST\n  sqlite3_search_count++;\n#endif\n  p->deferredMoveto = 0;\n  p->cacheStatus = CACHE_STALE;\n  return SQLITE_OK;\n}\n\n/*\n** Something has moved cursor \"p\" out of place.  Maybe the row it was\n** pointed to was deleted out from under it.  Or maybe the btree was\n** rebalanced.  Whatever the cause, try to restore \"p\" to the place it\n** is supposed to be pointing.  If the row was deleted out from under the\n** cursor, set the cursor to point to a NULL row.\n*/\nstatic int SQLITE_NOINLINE handleMovedCursor(VdbeCursor *p){\n  int isDifferentRow, rc;\n  assert( p->eCurType==CURTYPE_BTREE );\n  assert( p->uc.pCursor!=0 );\n  assert( sqlite3BtreeCursorHasMoved(p->uc.pCursor) );\n  rc = sqlite3BtreeCursorRestore(p->uc.pCursor, &isDifferentRow);\n  p->cacheStatus = CACHE_STALE;\n  if( isDifferentRow ) p->nullRow = 1;\n  return rc;\n}\n\n/*\n** Check to ensure that the cursor is valid.  Restore the cursor\n** if need be.  Return any I/O error from the restore operation.\n*/\nint sqlite3VdbeCursorRestore(VdbeCursor *p){\n  assert( p->eCurType==CURTYPE_BTREE );\n  if( sqlite3BtreeCursorHasMoved(p->uc.pCursor) ){\n    return handleMovedCursor(p);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Make sure the cursor p is ready to read or write the row to which it\n** was last positioned.  Return an error code if an OOM fault or I/O error\n** prevents us from positioning the cursor to its correct position.\n**\n** If a MoveTo operation is pending on the given cursor, then do that\n** MoveTo now.  If no move is pending, check to see if the row has been\n** deleted out from under the cursor and if it has, mark the row as\n** a NULL row.\n**\n** If the cursor is already pointing to the correct row and that row has\n** not been deleted out from under the cursor, then this routine is a no-op.\n*/\nint sqlite3VdbeCursorMoveto(VdbeCursor **pp, int *piCol){\n  VdbeCursor *p = *pp;\n  assert( p->eCurType==CURTYPE_BTREE || p->eCurType==CURTYPE_PSEUDO );\n  if( p->deferredMoveto ){\n    int iMap;\n    if( p->aAltMap && (iMap = p->aAltMap[1+*piCol])>0 ){\n      *pp = p->pAltCursor;\n      *piCol = iMap - 1;\n      return SQLITE_OK;\n    }\n    return handleDeferredMoveto(p);\n  }\n  if( sqlite3BtreeCursorHasMoved(p->uc.pCursor) ){\n    return handleMovedCursor(p);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** The following functions:\n**\n** sqlite3VdbeSerialType()\n** sqlite3VdbeSerialTypeLen()\n** sqlite3VdbeSerialLen()\n** sqlite3VdbeSerialPut()\n** sqlite3VdbeSerialGet()\n**\n** encapsulate the code that serializes values for storage in SQLite\n** data and index records. Each serialized value consists of a\n** 'serial-type' and a blob of data. The serial type is an 8-byte unsigned\n** integer, stored as a varint.\n**\n** In an SQLite index record, the serial type is stored directly before\n** the blob of data that it corresponds to. In a table record, all serial\n** types are stored at the start of the record, and the blobs of data at\n** the end. Hence these functions allow the caller to handle the\n** serial-type and data blob separately.\n**\n** The following table describes the various storage classes for data:\n**\n**   serial type        bytes of data      type\n**   --------------     ---------------    ---------------\n**      0                     0            NULL\n**      1                     1            signed integer\n**      2                     2            signed integer\n**      3                     3            signed integer\n**      4                     4            signed integer\n**      5                     6            signed integer\n**      6                     8            signed integer\n**      7                     8            IEEE float\n**      8                     0            Integer constant 0\n**      9                     0            Integer constant 1\n**     10,11                               reserved for expansion\n**    N>=12 and even       (N-12)/2        BLOB\n**    N>=13 and odd        (N-13)/2        text\n**\n** The 8 and 9 types were added in 3.3.0, file format 4.  Prior versions\n** of SQLite will not understand those serial types.\n*/\n\n#if 0 /* Inlined into the OP_MakeRecord opcode */\n/*\n** Return the serial-type for the value stored in pMem.\n**\n** This routine might convert a large MEM_IntReal value into MEM_Real.\n**\n** 2019-07-11:  The primary user of this subroutine was the OP_MakeRecord\n** opcode in the byte-code engine.  But by moving this routine in-line, we\n** can omit some redundant tests and make that opcode a lot faster.  So\n** this routine is now only used by the STAT3 logic and STAT3 support has\n** ended.  The code is kept here for historical reference only.\n*/\nu32 sqlite3VdbeSerialType(Mem *pMem, int file_format, u32 *pLen){\n  int flags = pMem->flags;\n  u32 n;\n\n  assert( pLen!=0 );\n  if( flags&MEM_Null ){\n    *pLen = 0;\n    return 0;\n  }\n  if( flags&(MEM_Int|MEM_IntReal) ){\n    /* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */\n#   define MAX_6BYTE ((((i64)0x00008000)<<32)-1)\n    i64 i = pMem->u.i;\n    u64 u;\n    testcase( flags & MEM_Int );\n    testcase( flags & MEM_IntReal );\n    if( i<0 ){\n      u = ~i;\n    }else{\n      u = i;\n    }\n    if( u<=127 ){\n      if( (i&1)==i && file_format>=4 ){\n        *pLen = 0;\n        return 8+(u32)u;\n      }else{\n        *pLen = 1;\n        return 1;\n      }\n    }\n    if( u<=32767 ){ *pLen = 2; return 2; }\n    if( u<=8388607 ){ *pLen = 3; return 3; }\n    if( u<=2147483647 ){ *pLen = 4; return 4; }\n    if( u<=MAX_6BYTE ){ *pLen = 6; return 5; }\n    *pLen = 8;\n    if( flags&MEM_IntReal ){\n      /* If the value is IntReal and is going to take up 8 bytes to store\n      ** as an integer, then we might as well make it an 8-byte floating\n      ** point value */\n      pMem->u.r = (double)pMem->u.i;\n      pMem->flags &= ~MEM_IntReal;\n      pMem->flags |= MEM_Real;\n      return 7;\n    }\n    return 6;\n  }\n  if( flags&MEM_Real ){\n    *pLen = 8;\n    return 7;\n  }\n  assert( pMem->db->mallocFailed || flags&(MEM_Str|MEM_Blob) );\n  assert( pMem->n>=0 );\n  n = (u32)pMem->n;\n  if( flags & MEM_Zero ){\n    n += pMem->u.nZero;\n  }\n  *pLen = n;\n  return ((n*2) + 12 + ((flags&MEM_Str)!=0));\n}\n#endif /* inlined into OP_MakeRecord */\n\n/*\n** The sizes for serial types less than 128\n*/\nstatic const u8 sqlite3SmallTypeSizes[] = {\n        /*  0   1   2   3   4   5   6   7   8   9 */   \n/*   0 */   0,  1,  2,  3,  4,  6,  8,  8,  0,  0,\n/*  10 */   0,  0,  0,  0,  1,  1,  2,  2,  3,  3,\n/*  20 */   4,  4,  5,  5,  6,  6,  7,  7,  8,  8,\n/*  30 */   9,  9, 10, 10, 11, 11, 12, 12, 13, 13,\n/*  40 */  14, 14, 15, 15, 16, 16, 17, 17, 18, 18,\n/*  50 */  19, 19, 20, 20, 21, 21, 22, 22, 23, 23,\n/*  60 */  24, 24, 25, 25, 26, 26, 27, 27, 28, 28,\n/*  70 */  29, 29, 30, 30, 31, 31, 32, 32, 33, 33,\n/*  80 */  34, 34, 35, 35, 36, 36, 37, 37, 38, 38,\n/*  90 */  39, 39, 40, 40, 41, 41, 42, 42, 43, 43,\n/* 100 */  44, 44, 45, 45, 46, 46, 47, 47, 48, 48,\n/* 110 */  49, 49, 50, 50, 51, 51, 52, 52, 53, 53,\n/* 120 */  54, 54, 55, 55, 56, 56, 57, 57\n};\n\n/*\n** Return the length of the data corresponding to the supplied serial-type.\n*/\nu32 sqlite3VdbeSerialTypeLen(u32 serial_type){\n  if( serial_type>=128 ){\n    return (serial_type-12)/2;\n  }else{\n    assert( serial_type<12 \n            || sqlite3SmallTypeSizes[serial_type]==(serial_type - 12)/2 );\n    return sqlite3SmallTypeSizes[serial_type];\n  }\n}\nu8 sqlite3VdbeOneByteSerialTypeLen(u8 serial_type){\n  assert( serial_type<128 );\n  return sqlite3SmallTypeSizes[serial_type];  \n}\n\n/*\n** If we are on an architecture with mixed-endian floating \n** points (ex: ARM7) then swap the lower 4 bytes with the \n** upper 4 bytes.  Return the result.\n**\n** For most architectures, this is a no-op.\n**\n** (later):  It is reported to me that the mixed-endian problem\n** on ARM7 is an issue with GCC, not with the ARM7 chip.  It seems\n** that early versions of GCC stored the two words of a 64-bit\n** float in the wrong order.  And that error has been propagated\n** ever since.  The blame is not necessarily with GCC, though.\n** GCC might have just copying the problem from a prior compiler.\n** I am also told that newer versions of GCC that follow a different\n** ABI get the byte order right.\n**\n** Developers using SQLite on an ARM7 should compile and run their\n** application using -DSQLITE_DEBUG=1 at least once.  With DEBUG\n** enabled, some asserts below will ensure that the byte order of\n** floating point values is correct.\n**\n** (2007-08-30)  Frank van Vugt has studied this problem closely\n** and has send his findings to the SQLite developers.  Frank\n** writes that some Linux kernels offer floating point hardware\n** emulation that uses only 32-bit mantissas instead of a full \n** 48-bits as required by the IEEE standard.  (This is the\n** CONFIG_FPE_FASTFPE option.)  On such systems, floating point\n** byte swapping becomes very complicated.  To avoid problems,\n** the necessary byte swapping is carried out using a 64-bit integer\n** rather than a 64-bit float.  Frank assures us that the code here\n** works for him.  We, the developers, have no way to independently\n** verify this, but Frank seems to know what he is talking about\n** so we trust him.\n*/\n#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT\nstatic u64 floatSwap(u64 in){\n  union {\n    u64 r;\n    u32 i[2];\n  } u;\n  u32 t;\n\n  u.r = in;\n  t = u.i[0];\n  u.i[0] = u.i[1];\n  u.i[1] = t;\n  return u.r;\n}\n# define swapMixedEndianFloat(X)  X = floatSwap(X)\n#else\n# define swapMixedEndianFloat(X)\n#endif\n\n/*\n** Write the serialized data blob for the value stored in pMem into \n** buf. It is assumed that the caller has allocated sufficient space.\n** Return the number of bytes written.\n**\n** nBuf is the amount of space left in buf[].  The caller is responsible\n** for allocating enough space to buf[] to hold the entire field, exclusive\n** of the pMem->u.nZero bytes for a MEM_Zero value.\n**\n** Return the number of bytes actually written into buf[].  The number\n** of bytes in the zero-filled tail is included in the return value only\n** if those bytes were zeroed in buf[].\n*/ \nu32 sqlite3VdbeSerialPut(u8 *buf, Mem *pMem, u32 serial_type){\n  u32 len;\n\n  /* Integer and Real */\n  if( serial_type<=7 && serial_type>0 ){\n    u64 v;\n    u32 i;\n    if( serial_type==7 ){\n      assert( sizeof(v)==sizeof(pMem->u.r) );\n      memcpy(&v, &pMem->u.r, sizeof(v));\n      swapMixedEndianFloat(v);\n    }else{\n      v = pMem->u.i;\n    }\n    len = i = sqlite3SmallTypeSizes[serial_type];\n    assert( i>0 );\n    do{\n      buf[--i] = (u8)(v&0xFF);\n      v >>= 8;\n    }while( i );\n    return len;\n  }\n\n  /* String or blob */\n  if( serial_type>=12 ){\n    assert( pMem->n + ((pMem->flags & MEM_Zero)?pMem->u.nZero:0)\n             == (int)sqlite3VdbeSerialTypeLen(serial_type) );\n    len = pMem->n;\n    if( len>0 ) memcpy(buf, pMem->z, len);\n    return len;\n  }\n\n  /* NULL or constants 0 or 1 */\n  return 0;\n}\n\n/* Input \"x\" is a sequence of unsigned characters that represent a\n** big-endian integer.  Return the equivalent native integer\n*/\n#define ONE_BYTE_INT(x)    ((i8)(x)[0])\n#define TWO_BYTE_INT(x)    (256*(i8)((x)[0])|(x)[1])\n#define THREE_BYTE_INT(x)  (65536*(i8)((x)[0])|((x)[1]<<8)|(x)[2])\n#define FOUR_BYTE_UINT(x)  (((u32)(x)[0]<<24)|((x)[1]<<16)|((x)[2]<<8)|(x)[3])\n#define FOUR_BYTE_INT(x) (16777216*(i8)((x)[0])|((x)[1]<<16)|((x)[2]<<8)|(x)[3])\n\n/*\n** Deserialize the data blob pointed to by buf as serial type serial_type\n** and store the result in pMem.  Return the number of bytes read.\n**\n** This function is implemented as two separate routines for performance.\n** The few cases that require local variables are broken out into a separate\n** routine so that in most cases the overhead of moving the stack pointer\n** is avoided.\n*/ \nstatic u32 serialGet(\n  const unsigned char *buf,     /* Buffer to deserialize from */\n  u32 serial_type,              /* Serial type to deserialize */\n  Mem *pMem                     /* Memory cell to write value into */\n){\n  u64 x = FOUR_BYTE_UINT(buf);\n  u32 y = FOUR_BYTE_UINT(buf+4);\n  x = (x<<32) + y;\n  if( serial_type==6 ){\n    /* EVIDENCE-OF: R-29851-52272 Value is a big-endian 64-bit\n    ** twos-complement integer. */\n    pMem->u.i = *(i64*)&x;\n    pMem->flags = MEM_Int;\n    testcase( pMem->u.i<0 );\n  }else{\n    /* EVIDENCE-OF: R-57343-49114 Value is a big-endian IEEE 754-2008 64-bit\n    ** floating point number. */\n#if !defined(NDEBUG) && !defined(SQLITE_OMIT_FLOATING_POINT)\n    /* Verify that integers and floating point values use the same\n    ** byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is\n    ** defined that 64-bit floating point values really are mixed\n    ** endian.\n    */\n    static const u64 t1 = ((u64)0x3ff00000)<<32;\n    static const double r1 = 1.0;\n    u64 t2 = t1;\n    swapMixedEndianFloat(t2);\n    assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, &t2, sizeof(r1))==0 );\n#endif\n    assert( sizeof(x)==8 && sizeof(pMem->u.r)==8 );\n    swapMixedEndianFloat(x);\n    memcpy(&pMem->u.r, &x, sizeof(x));\n    pMem->flags = IsNaN(x) ? MEM_Null : MEM_Real;\n  }\n  return 8;\n}\nu32 sqlite3VdbeSerialGet(\n  const unsigned char *buf,     /* Buffer to deserialize from */\n  u32 serial_type,              /* Serial type to deserialize */\n  Mem *pMem                     /* Memory cell to write value into */\n){\n  switch( serial_type ){\n    case 10: { /* Internal use only: NULL with virtual table\n               ** UPDATE no-change flag set */\n      pMem->flags = MEM_Null|MEM_Zero;\n      pMem->n = 0;\n      pMem->u.nZero = 0;\n      break;\n    }\n    case 11:   /* Reserved for future use */\n    case 0: {  /* Null */\n      /* EVIDENCE-OF: R-24078-09375 Value is a NULL. */\n      pMem->flags = MEM_Null;\n      break;\n    }\n    case 1: {\n      /* EVIDENCE-OF: R-44885-25196 Value is an 8-bit twos-complement\n      ** integer. */\n      pMem->u.i = ONE_BYTE_INT(buf);\n      pMem->flags = MEM_Int;\n      testcase( pMem->u.i<0 );\n      return 1;\n    }\n    case 2: { /* 2-byte signed integer */\n      /* EVIDENCE-OF: R-49794-35026 Value is a big-endian 16-bit\n      ** twos-complement integer. */\n      pMem->u.i = TWO_BYTE_INT(buf);\n      pMem->flags = MEM_Int;\n      testcase( pMem->u.i<0 );\n      return 2;\n    }\n    case 3: { /* 3-byte signed integer */\n      /* EVIDENCE-OF: R-37839-54301 Value is a big-endian 24-bit\n      ** twos-complement integer. */\n      pMem->u.i = THREE_BYTE_INT(buf);\n      pMem->flags = MEM_Int;\n      testcase( pMem->u.i<0 );\n      return 3;\n    }\n    case 4: { /* 4-byte signed integer */\n      /* EVIDENCE-OF: R-01849-26079 Value is a big-endian 32-bit\n      ** twos-complement integer. */\n      pMem->u.i = FOUR_BYTE_INT(buf);\n#ifdef __HP_cc \n      /* Work around a sign-extension bug in the HP compiler for HP/UX */\n      if( buf[0]&0x80 ) pMem->u.i |= 0xffffffff80000000LL;\n#endif\n      pMem->flags = MEM_Int;\n      testcase( pMem->u.i<0 );\n      return 4;\n    }\n    case 5: { /* 6-byte signed integer */\n      /* EVIDENCE-OF: R-50385-09674 Value is a big-endian 48-bit\n      ** twos-complement integer. */\n      pMem->u.i = FOUR_BYTE_UINT(buf+2) + (((i64)1)<<32)*TWO_BYTE_INT(buf);\n      pMem->flags = MEM_Int;\n      testcase( pMem->u.i<0 );\n      return 6;\n    }\n    case 6:   /* 8-byte signed integer */\n    case 7: { /* IEEE floating point */\n      /* These use local variables, so do them in a separate routine\n      ** to avoid having to move the frame pointer in the common case */\n      return serialGet(buf,serial_type,pMem);\n    }\n    case 8:    /* Integer 0 */\n    case 9: {  /* Integer 1 */\n      /* EVIDENCE-OF: R-12976-22893 Value is the integer 0. */\n      /* EVIDENCE-OF: R-18143-12121 Value is the integer 1. */\n      pMem->u.i = serial_type-8;\n      pMem->flags = MEM_Int;\n      return 0;\n    }\n    default: {\n      /* EVIDENCE-OF: R-14606-31564 Value is a BLOB that is (N-12)/2 bytes in\n      ** length.\n      ** EVIDENCE-OF: R-28401-00140 Value is a string in the text encoding and\n      ** (N-13)/2 bytes in length. */\n      static const u16 aFlag[] = { MEM_Blob|MEM_Ephem, MEM_Str|MEM_Ephem };\n      pMem->z = (char *)buf;\n      pMem->n = (serial_type-12)/2;\n      pMem->flags = aFlag[serial_type&1];\n      return pMem->n;\n    }\n  }\n  return 0;\n}\n/*\n** This routine is used to allocate sufficient space for an UnpackedRecord\n** structure large enough to be used with sqlite3VdbeRecordUnpack() if\n** the first argument is a pointer to KeyInfo structure pKeyInfo.\n**\n** The space is either allocated using sqlite3DbMallocRaw() or from within\n** the unaligned buffer passed via the second and third arguments (presumably\n** stack space). If the former, then *ppFree is set to a pointer that should\n** be eventually freed by the caller using sqlite3DbFree(). Or, if the \n** allocation comes from the pSpace/szSpace buffer, *ppFree is set to NULL\n** before returning.\n**\n** If an OOM error occurs, NULL is returned.\n*/\nUnpackedRecord *sqlite3VdbeAllocUnpackedRecord(\n  KeyInfo *pKeyInfo               /* Description of the record */\n){\n  UnpackedRecord *p;              /* Unpacked record to return */\n  int nByte;                      /* Number of bytes required for *p */\n  nByte = ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*(pKeyInfo->nKeyField+1);\n  p = (UnpackedRecord *)sqlite3DbMallocRaw(pKeyInfo->db, nByte);\n  if( !p ) return 0;\n  p->aMem = (Mem*)&((char*)p)[ROUND8(sizeof(UnpackedRecord))];\n  assert( pKeyInfo->aSortFlags!=0 );\n  p->pKeyInfo = pKeyInfo;\n  p->nField = pKeyInfo->nKeyField + 1;\n  return p;\n}\n\n/*\n** Given the nKey-byte encoding of a record in pKey[], populate the \n** UnpackedRecord structure indicated by the fourth argument with the\n** contents of the decoded record.\n*/ \nvoid sqlite3VdbeRecordUnpack(\n  KeyInfo *pKeyInfo,     /* Information about the record format */\n  int nKey,              /* Size of the binary record */\n  const void *pKey,      /* The binary record */\n  UnpackedRecord *p      /* Populate this structure before returning. */\n){\n  const unsigned char *aKey = (const unsigned char *)pKey;\n  u32 d; \n  u32 idx;                        /* Offset in aKey[] to read from */\n  u16 u;                          /* Unsigned loop counter */\n  u32 szHdr;\n  Mem *pMem = p->aMem;\n\n  p->default_rc = 0;\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n  idx = getVarint32(aKey, szHdr);\n  d = szHdr;\n  u = 0;\n  while( idx<szHdr && d<=(u32)nKey ){\n    u32 serial_type;\n\n    idx += getVarint32(&aKey[idx], serial_type);\n    pMem->enc = pKeyInfo->enc;\n    pMem->db = pKeyInfo->db;\n    /* pMem->flags = 0; // sqlite3VdbeSerialGet() will set this for us */\n    pMem->szMalloc = 0;\n    pMem->z = 0;\n    d += sqlite3VdbeSerialGet(&aKey[d], serial_type, pMem);\n    pMem++;\n    if( (++u)>=p->nField ) break;\n  }\n  if( d>(u32)nKey && u ){\n    assert( CORRUPT_DB );\n    /* In a corrupt record entry, the last pMem might have been set up using \n    ** uninitialized memory. Overwrite its value with NULL, to prevent\n    ** warnings from MSAN. */\n    sqlite3VdbeMemSetNull(pMem-1);\n  }\n  assert( u<=pKeyInfo->nKeyField + 1 );\n  p->nField = u;\n}\n\n#ifdef SQLITE_DEBUG\n/*\n** This function compares two index or table record keys in the same way\n** as the sqlite3VdbeRecordCompare() routine. Unlike VdbeRecordCompare(),\n** this function deserializes and compares values using the\n** sqlite3VdbeSerialGet() and sqlite3MemCompare() functions. It is used\n** in assert() statements to ensure that the optimized code in\n** sqlite3VdbeRecordCompare() returns results with these two primitives.\n**\n** Return true if the result of comparison is equivalent to desiredResult.\n** Return false if there is a disagreement.\n*/\nstatic int vdbeRecordCompareDebug(\n  int nKey1, const void *pKey1, /* Left key */\n  const UnpackedRecord *pPKey2, /* Right key */\n  int desiredResult             /* Correct answer */\n){\n  u32 d1;            /* Offset into aKey[] of next data element */\n  u32 idx1;          /* Offset into aKey[] of next header element */\n  u32 szHdr1;        /* Number of bytes in header */\n  int i = 0;\n  int rc = 0;\n  const unsigned char *aKey1 = (const unsigned char *)pKey1;\n  KeyInfo *pKeyInfo;\n  Mem mem1;\n\n  pKeyInfo = pPKey2->pKeyInfo;\n  if( pKeyInfo->db==0 ) return 1;\n  mem1.enc = pKeyInfo->enc;\n  mem1.db = pKeyInfo->db;\n  /* mem1.flags = 0;  // Will be initialized by sqlite3VdbeSerialGet() */\n  VVA_ONLY( mem1.szMalloc = 0; ) /* Only needed by assert() statements */\n\n  /* Compilers may complain that mem1.u.i is potentially uninitialized.\n  ** We could initialize it, as shown here, to silence those complaints.\n  ** But in fact, mem1.u.i will never actually be used uninitialized, and doing \n  ** the unnecessary initialization has a measurable negative performance\n  ** impact, since this routine is a very high runner.  And so, we choose\n  ** to ignore the compiler warnings and leave this variable uninitialized.\n  */\n  /*  mem1.u.i = 0;  // not needed, here to silence compiler warning */\n  \n  idx1 = getVarint32(aKey1, szHdr1);\n  if( szHdr1>98307 ) return SQLITE_CORRUPT;\n  d1 = szHdr1;\n  assert( pKeyInfo->nAllField>=pPKey2->nField || CORRUPT_DB );\n  assert( pKeyInfo->aSortFlags!=0 );\n  assert( pKeyInfo->nKeyField>0 );\n  assert( idx1<=szHdr1 || CORRUPT_DB );\n  do{\n    u32 serial_type1;\n\n    /* Read the serial types for the next element in each key. */\n    idx1 += getVarint32( aKey1+idx1, serial_type1 );\n\n    /* Verify that there is enough key space remaining to avoid\n    ** a buffer overread.  The \"d1+serial_type1+2\" subexpression will\n    ** always be greater than or equal to the amount of required key space.\n    ** Use that approximation to avoid the more expensive call to\n    ** sqlite3VdbeSerialTypeLen() in the common case.\n    */\n    if( d1+(u64)serial_type1+2>(u64)nKey1\n     && d1+(u64)sqlite3VdbeSerialTypeLen(serial_type1)>(u64)nKey1 \n    ){\n      break;\n    }\n\n    /* Extract the values to be compared.\n    */\n    d1 += sqlite3VdbeSerialGet(&aKey1[d1], serial_type1, &mem1);\n\n    /* Do the comparison\n    */\n    rc = sqlite3MemCompare(&mem1, &pPKey2->aMem[i],\n                           pKeyInfo->nAllField>i ? pKeyInfo->aColl[i] : 0);\n    if( rc!=0 ){\n      assert( mem1.szMalloc==0 );  /* See comment below */\n      if( (pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_BIGNULL)\n       && ((mem1.flags & MEM_Null) || (pPKey2->aMem[i].flags & MEM_Null)) \n      ){\n        rc = -rc;\n      }\n      if( pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_DESC ){\n        rc = -rc;  /* Invert the result for DESC sort order. */\n      }\n      goto debugCompareEnd;\n    }\n    i++;\n  }while( idx1<szHdr1 && i<pPKey2->nField );\n\n  /* No memory allocation is ever used on mem1.  Prove this using\n  ** the following assert().  If the assert() fails, it indicates a\n  ** memory leak and a need to call sqlite3VdbeMemRelease(&mem1).\n  */\n  assert( mem1.szMalloc==0 );\n\n  /* rc==0 here means that one of the keys ran out of fields and\n  ** all the fields up to that point were equal. Return the default_rc\n  ** value.  */\n  rc = pPKey2->default_rc;\n\ndebugCompareEnd:\n  if( desiredResult==0 && rc==0 ) return 1;\n  if( desiredResult<0 && rc<0 ) return 1;\n  if( desiredResult>0 && rc>0 ) return 1;\n  if( CORRUPT_DB ) return 1;\n  if( pKeyInfo->db->mallocFailed ) return 1;\n  return 0;\n}\n#endif\n\n#ifdef SQLITE_DEBUG\n/*\n** Count the number of fields (a.k.a. columns) in the record given by\n** pKey,nKey.  The verify that this count is less than or equal to the\n** limit given by pKeyInfo->nAllField.\n**\n** If this constraint is not satisfied, it means that the high-speed\n** vdbeRecordCompareInt() and vdbeRecordCompareString() routines will\n** not work correctly.  If this assert() ever fires, it probably means\n** that the KeyInfo.nKeyField or KeyInfo.nAllField values were computed\n** incorrectly.\n*/\nstatic void vdbeAssertFieldCountWithinLimits(\n  int nKey, const void *pKey,   /* The record to verify */ \n  const KeyInfo *pKeyInfo       /* Compare size with this KeyInfo */\n){\n  int nField = 0;\n  u32 szHdr;\n  u32 idx;\n  u32 notUsed;\n  const unsigned char *aKey = (const unsigned char*)pKey;\n\n  if( CORRUPT_DB ) return;\n  idx = getVarint32(aKey, szHdr);\n  assert( nKey>=0 );\n  assert( szHdr<=(u32)nKey );\n  while( idx<szHdr ){\n    idx += getVarint32(aKey+idx, notUsed);\n    nField++;\n  }\n  assert( nField <= pKeyInfo->nAllField );\n}\n#else\n# define vdbeAssertFieldCountWithinLimits(A,B,C)\n#endif\n\n/*\n** Both *pMem1 and *pMem2 contain string values. Compare the two values\n** using the collation sequence pColl. As usual, return a negative , zero\n** or positive value if *pMem1 is less than, equal to or greater than \n** *pMem2, respectively. Similar in spirit to \"rc = (*pMem1) - (*pMem2);\".\n*/\nstatic int vdbeCompareMemString(\n  const Mem *pMem1,\n  const Mem *pMem2,\n  const CollSeq *pColl,\n  u8 *prcErr                      /* If an OOM occurs, set to SQLITE_NOMEM */\n){\n  if( pMem1->enc==pColl->enc ){\n    /* The strings are already in the correct encoding.  Call the\n     ** comparison function directly */\n    return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);\n  }else{\n    int rc;\n    const void *v1, *v2;\n    Mem c1;\n    Mem c2;\n    sqlite3VdbeMemInit(&c1, pMem1->db, MEM_Null);\n    sqlite3VdbeMemInit(&c2, pMem1->db, MEM_Null);\n    sqlite3VdbeMemShallowCopy(&c1, pMem1, MEM_Ephem);\n    sqlite3VdbeMemShallowCopy(&c2, pMem2, MEM_Ephem);\n    v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);\n    v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);\n    if( (v1==0 || v2==0) ){\n      if( prcErr ) *prcErr = SQLITE_NOMEM_BKPT;\n      rc = 0;\n    }else{\n      rc = pColl->xCmp(pColl->pUser, c1.n, v1, c2.n, v2);\n    }\n    sqlite3VdbeMemRelease(&c1);\n    sqlite3VdbeMemRelease(&c2);\n    return rc;\n  }\n}\n\n/*\n** The input pBlob is guaranteed to be a Blob that is not marked\n** with MEM_Zero.  Return true if it could be a zero-blob.\n*/\nstatic int isAllZero(const char *z, int n){\n  int i;\n  for(i=0; i<n; i++){\n    if( z[i] ) return 0;\n  }\n  return 1;\n}\n\n/*\n** Compare two blobs.  Return negative, zero, or positive if the first\n** is less than, equal to, or greater than the second, respectively.\n** If one blob is a prefix of the other, then the shorter is the lessor.\n*/\nSQLITE_NOINLINE int sqlite3BlobCompare(const Mem *pB1, const Mem *pB2){\n  int c;\n  int n1 = pB1->n;\n  int n2 = pB2->n;\n\n  /* It is possible to have a Blob value that has some non-zero content\n  ** followed by zero content.  But that only comes up for Blobs formed\n  ** by the OP_MakeRecord opcode, and such Blobs never get passed into\n  ** sqlite3MemCompare(). */\n  assert( (pB1->flags & MEM_Zero)==0 || n1==0 );\n  assert( (pB2->flags & MEM_Zero)==0 || n2==0 );\n\n  if( (pB1->flags|pB2->flags) & MEM_Zero ){\n    if( pB1->flags & pB2->flags & MEM_Zero ){\n      return pB1->u.nZero - pB2->u.nZero;\n    }else if( pB1->flags & MEM_Zero ){\n      if( !isAllZero(pB2->z, pB2->n) ) return -1;\n      return pB1->u.nZero - n2;\n    }else{\n      if( !isAllZero(pB1->z, pB1->n) ) return +1;\n      return n1 - pB2->u.nZero;\n    }\n  }\n  c = memcmp(pB1->z, pB2->z, n1>n2 ? n2 : n1);\n  if( c ) return c;\n  return n1 - n2;\n}\n\n/*\n** Do a comparison between a 64-bit signed integer and a 64-bit floating-point\n** number.  Return negative, zero, or positive if the first (i64) is less than,\n** equal to, or greater than the second (double).\n*/\nstatic int sqlite3IntFloatCompare(i64 i, double r){\n  if( sizeof(LONGDOUBLE_TYPE)>8 ){\n    LONGDOUBLE_TYPE x = (LONGDOUBLE_TYPE)i;\n    if( x<r ) return -1;\n    if( x>r ) return +1;\n    return 0;\n  }else{\n    i64 y;\n    double s;\n    if( r<-9223372036854775808.0 ) return +1;\n    if( r>=9223372036854775808.0 ) return -1;\n    y = (i64)r;\n    if( i<y ) return -1;\n    if( i>y ) return +1;\n    s = (double)i;\n    if( s<r ) return -1;\n    if( s>r ) return +1;\n    return 0;\n  }\n}\n\n/*\n** Compare the values contained by the two memory cells, returning\n** negative, zero or positive if pMem1 is less than, equal to, or greater\n** than pMem2. Sorting order is NULL's first, followed by numbers (integers\n** and reals) sorted numerically, followed by text ordered by the collating\n** sequence pColl and finally blob's ordered by memcmp().\n**\n** Two NULL values are considered equal by this function.\n*/\nint sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){\n  int f1, f2;\n  int combined_flags;\n\n  f1 = pMem1->flags;\n  f2 = pMem2->flags;\n  combined_flags = f1|f2;\n  assert( !sqlite3VdbeMemIsRowSet(pMem1) && !sqlite3VdbeMemIsRowSet(pMem2) );\n \n  /* If one value is NULL, it is less than the other. If both values\n  ** are NULL, return 0.\n  */\n  if( combined_flags&MEM_Null ){\n    return (f2&MEM_Null) - (f1&MEM_Null);\n  }\n\n  /* At least one of the two values is a number\n  */\n  if( combined_flags&(MEM_Int|MEM_Real|MEM_IntReal) ){\n    testcase( combined_flags & MEM_Int );\n    testcase( combined_flags & MEM_Real );\n    testcase( combined_flags & MEM_IntReal );\n    if( (f1 & f2 & (MEM_Int|MEM_IntReal))!=0 ){\n      testcase( f1 & f2 & MEM_Int );\n      testcase( f1 & f2 & MEM_IntReal );\n      if( pMem1->u.i < pMem2->u.i ) return -1;\n      if( pMem1->u.i > pMem2->u.i ) return +1;\n      return 0;\n    }\n    if( (f1 & f2 & MEM_Real)!=0 ){\n      if( pMem1->u.r < pMem2->u.r ) return -1;\n      if( pMem1->u.r > pMem2->u.r ) return +1;\n      return 0;\n    }\n    if( (f1&(MEM_Int|MEM_IntReal))!=0 ){\n      testcase( f1 & MEM_Int );\n      testcase( f1 & MEM_IntReal );\n      if( (f2&MEM_Real)!=0 ){\n        return sqlite3IntFloatCompare(pMem1->u.i, pMem2->u.r);\n      }else if( (f2&(MEM_Int|MEM_IntReal))!=0 ){\n        if( pMem1->u.i < pMem2->u.i ) return -1;\n        if( pMem1->u.i > pMem2->u.i ) return +1;\n        return 0;\n      }else{\n        return -1;\n      }\n    }\n    if( (f1&MEM_Real)!=0 ){\n      if( (f2&(MEM_Int|MEM_IntReal))!=0 ){\n        testcase( f2 & MEM_Int );\n        testcase( f2 & MEM_IntReal );\n        return -sqlite3IntFloatCompare(pMem2->u.i, pMem1->u.r);\n      }else{\n        return -1;\n      }\n    }\n    return +1;\n  }\n\n  /* If one value is a string and the other is a blob, the string is less.\n  ** If both are strings, compare using the collating functions.\n  */\n  if( combined_flags&MEM_Str ){\n    if( (f1 & MEM_Str)==0 ){\n      return 1;\n    }\n    if( (f2 & MEM_Str)==0 ){\n      return -1;\n    }\n\n    assert( pMem1->enc==pMem2->enc || pMem1->db->mallocFailed );\n    assert( pMem1->enc==SQLITE_UTF8 || \n            pMem1->enc==SQLITE_UTF16LE || pMem1->enc==SQLITE_UTF16BE );\n\n    /* The collation sequence must be defined at this point, even if\n    ** the user deletes the collation sequence after the vdbe program is\n    ** compiled (this was not always the case).\n    */\n    assert( !pColl || pColl->xCmp );\n\n    if( pColl ){\n      return vdbeCompareMemString(pMem1, pMem2, pColl, 0);\n    }\n    /* If a NULL pointer was passed as the collate function, fall through\n    ** to the blob case and use memcmp().  */\n  }\n \n  /* Both values must be blobs.  Compare using memcmp().  */\n  return sqlite3BlobCompare(pMem1, pMem2);\n}\n\n\n/*\n** The first argument passed to this function is a serial-type that\n** corresponds to an integer - all values between 1 and 9 inclusive \n** except 7. The second points to a buffer containing an integer value\n** serialized according to serial_type. This function deserializes\n** and returns the value.\n*/\nstatic i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey){\n  u32 y;\n  assert( CORRUPT_DB || (serial_type>=1 && serial_type<=9 && serial_type!=7) );\n  switch( serial_type ){\n    case 0:\n    case 1:\n      testcase( aKey[0]&0x80 );\n      return ONE_BYTE_INT(aKey);\n    case 2:\n      testcase( aKey[0]&0x80 );\n      return TWO_BYTE_INT(aKey);\n    case 3:\n      testcase( aKey[0]&0x80 );\n      return THREE_BYTE_INT(aKey);\n    case 4: {\n      testcase( aKey[0]&0x80 );\n      y = FOUR_BYTE_UINT(aKey);\n      return (i64)*(int*)&y;\n    }\n    case 5: {\n      testcase( aKey[0]&0x80 );\n      return FOUR_BYTE_UINT(aKey+2) + (((i64)1)<<32)*TWO_BYTE_INT(aKey);\n    }\n    case 6: {\n      u64 x = FOUR_BYTE_UINT(aKey);\n      testcase( aKey[0]&0x80 );\n      x = (x<<32) | FOUR_BYTE_UINT(aKey+4);\n      return (i64)*(i64*)&x;\n    }\n  }\n\n  return (serial_type - 8);\n}\n\n/*\n** This function compares the two table rows or index records\n** specified by {nKey1, pKey1} and pPKey2.  It returns a negative, zero\n** or positive integer if key1 is less than, equal to or \n** greater than key2.  The {nKey1, pKey1} key must be a blob\n** created by the OP_MakeRecord opcode of the VDBE.  The pPKey2\n** key must be a parsed key such as obtained from\n** sqlite3VdbeParseRecord.\n**\n** If argument bSkip is non-zero, it is assumed that the caller has already\n** determined that the first fields of the keys are equal.\n**\n** Key1 and Key2 do not have to contain the same number of fields. If all \n** fields that appear in both keys are equal, then pPKey2->default_rc is \n** returned.\n**\n** If database corruption is discovered, set pPKey2->errCode to \n** SQLITE_CORRUPT and return 0. If an OOM error is encountered, \n** pPKey2->errCode is set to SQLITE_NOMEM and, if it is not NULL, the\n** malloc-failed flag set on database handle (pPKey2->pKeyInfo->db).\n*/\nint sqlite3VdbeRecordCompareWithSkip(\n  int nKey1, const void *pKey1,   /* Left key */\n  UnpackedRecord *pPKey2,         /* Right key */\n  int bSkip                       /* If true, skip the first field */\n){\n  u32 d1;                         /* Offset into aKey[] of next data element */\n  int i;                          /* Index of next field to compare */\n  u32 szHdr1;                     /* Size of record header in bytes */\n  u32 idx1;                       /* Offset of first type in header */\n  int rc = 0;                     /* Return value */\n  Mem *pRhs = pPKey2->aMem;       /* Next field of pPKey2 to compare */\n  KeyInfo *pKeyInfo;\n  const unsigned char *aKey1 = (const unsigned char *)pKey1;\n  Mem mem1;\n\n  /* If bSkip is true, then the caller has already determined that the first\n  ** two elements in the keys are equal. Fix the various stack variables so\n  ** that this routine begins comparing at the second field. */\n  if( bSkip ){\n    u32 s1;\n    idx1 = 1 + getVarint32(&aKey1[1], s1);\n    szHdr1 = aKey1[0];\n    d1 = szHdr1 + sqlite3VdbeSerialTypeLen(s1);\n    i = 1;\n    pRhs++;\n  }else{\n    idx1 = getVarint32(aKey1, szHdr1);\n    d1 = szHdr1;\n    i = 0;\n  }\n  if( d1>(unsigned)nKey1 ){ \n    pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;\n    return 0;  /* Corruption */\n  }\n\n  VVA_ONLY( mem1.szMalloc = 0; ) /* Only needed by assert() statements */\n  assert( pPKey2->pKeyInfo->nAllField>=pPKey2->nField \n       || CORRUPT_DB );\n  assert( pPKey2->pKeyInfo->aSortFlags!=0 );\n  assert( pPKey2->pKeyInfo->nKeyField>0 );\n  assert( idx1<=szHdr1 || CORRUPT_DB );\n  do{\n    u32 serial_type;\n\n    /* RHS is an integer */\n    if( pRhs->flags & (MEM_Int|MEM_IntReal) ){\n      testcase( pRhs->flags & MEM_Int );\n      testcase( pRhs->flags & MEM_IntReal );\n      serial_type = aKey1[idx1];\n      testcase( serial_type==12 );\n      if( serial_type>=10 ){\n        rc = +1;\n      }else if( serial_type==0 ){\n        rc = -1;\n      }else if( serial_type==7 ){\n        sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);\n        rc = -sqlite3IntFloatCompare(pRhs->u.i, mem1.u.r);\n      }else{\n        i64 lhs = vdbeRecordDecodeInt(serial_type, &aKey1[d1]);\n        i64 rhs = pRhs->u.i;\n        if( lhs<rhs ){\n          rc = -1;\n        }else if( lhs>rhs ){\n          rc = +1;\n        }\n      }\n    }\n\n    /* RHS is real */\n    else if( pRhs->flags & MEM_Real ){\n      serial_type = aKey1[idx1];\n      if( serial_type>=10 ){\n        /* Serial types 12 or greater are strings and blobs (greater than\n        ** numbers). Types 10 and 11 are currently \"reserved for future \n        ** use\", so it doesn't really matter what the results of comparing\n        ** them to numberic values are.  */\n        rc = +1;\n      }else if( serial_type==0 ){\n        rc = -1;\n      }else{\n        sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);\n        if( serial_type==7 ){\n          if( mem1.u.r<pRhs->u.r ){\n            rc = -1;\n          }else if( mem1.u.r>pRhs->u.r ){\n            rc = +1;\n          }\n        }else{\n          rc = sqlite3IntFloatCompare(mem1.u.i, pRhs->u.r);\n        }\n      }\n    }\n\n    /* RHS is a string */\n    else if( pRhs->flags & MEM_Str ){\n      getVarint32(&aKey1[idx1], serial_type);\n      testcase( serial_type==12 );\n      if( serial_type<12 ){\n        rc = -1;\n      }else if( !(serial_type & 0x01) ){\n        rc = +1;\n      }else{\n        mem1.n = (serial_type - 12) / 2;\n        testcase( (d1+mem1.n)==(unsigned)nKey1 );\n        testcase( (d1+mem1.n+1)==(unsigned)nKey1 );\n        if( (d1+mem1.n) > (unsigned)nKey1\n         || (pKeyInfo = pPKey2->pKeyInfo)->nAllField<=i\n        ){\n          pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;\n          return 0;                /* Corruption */\n        }else if( pKeyInfo->aColl[i] ){\n          mem1.enc = pKeyInfo->enc;\n          mem1.db = pKeyInfo->db;\n          mem1.flags = MEM_Str;\n          mem1.z = (char*)&aKey1[d1];\n          rc = vdbeCompareMemString(\n              &mem1, pRhs, pKeyInfo->aColl[i], &pPKey2->errCode\n          );\n        }else{\n          int nCmp = MIN(mem1.n, pRhs->n);\n          rc = memcmp(&aKey1[d1], pRhs->z, nCmp);\n          if( rc==0 ) rc = mem1.n - pRhs->n; \n        }\n      }\n    }\n\n    /* RHS is a blob */\n    else if( pRhs->flags & MEM_Blob ){\n      assert( (pRhs->flags & MEM_Zero)==0 || pRhs->n==0 );\n      getVarint32(&aKey1[idx1], serial_type);\n      testcase( serial_type==12 );\n      if( serial_type<12 || (serial_type & 0x01) ){\n        rc = -1;\n      }else{\n        int nStr = (serial_type - 12) / 2;\n        testcase( (d1+nStr)==(unsigned)nKey1 );\n        testcase( (d1+nStr+1)==(unsigned)nKey1 );\n        if( (d1+nStr) > (unsigned)nKey1 ){\n          pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;\n          return 0;                /* Corruption */\n        }else if( pRhs->flags & MEM_Zero ){\n          if( !isAllZero((const char*)&aKey1[d1],nStr) ){\n            rc = 1;\n          }else{\n            rc = nStr - pRhs->u.nZero;\n          }\n        }else{\n          int nCmp = MIN(nStr, pRhs->n);\n          rc = memcmp(&aKey1[d1], pRhs->z, nCmp);\n          if( rc==0 ) rc = nStr - pRhs->n;\n        }\n      }\n    }\n\n    /* RHS is null */\n    else{\n      serial_type = aKey1[idx1];\n      rc = (serial_type!=0);\n    }\n\n    if( rc!=0 ){\n      int sortFlags = pPKey2->pKeyInfo->aSortFlags[i];\n      if( sortFlags ){\n        if( (sortFlags & KEYINFO_ORDER_BIGNULL)==0\n         || ((sortFlags & KEYINFO_ORDER_DESC)\n           !=(serial_type==0 || (pRhs->flags&MEM_Null)))\n        ){\n          rc = -rc;\n        }\n      }\n      assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, rc) );\n      assert( mem1.szMalloc==0 );  /* See comment below */\n      return rc;\n    }\n\n    i++;\n    if( i==pPKey2->nField ) break;\n    pRhs++;\n    d1 += sqlite3VdbeSerialTypeLen(serial_type);\n    idx1 += sqlite3VarintLen(serial_type);\n  }while( idx1<(unsigned)szHdr1 && d1<=(unsigned)nKey1 );\n\n  /* No memory allocation is ever used on mem1.  Prove this using\n  ** the following assert().  If the assert() fails, it indicates a\n  ** memory leak and a need to call sqlite3VdbeMemRelease(&mem1).  */\n  assert( mem1.szMalloc==0 );\n\n  /* rc==0 here means that one or both of the keys ran out of fields and\n  ** all the fields up to that point were equal. Return the default_rc\n  ** value.  */\n  assert( CORRUPT_DB \n       || vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, pPKey2->default_rc) \n       || pPKey2->pKeyInfo->db->mallocFailed\n  );\n  pPKey2->eqSeen = 1;\n  return pPKey2->default_rc;\n}\nint sqlite3VdbeRecordCompare(\n  int nKey1, const void *pKey1,   /* Left key */\n  UnpackedRecord *pPKey2          /* Right key */\n){\n  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 0);\n}\n\n\n/*\n** This function is an optimized version of sqlite3VdbeRecordCompare() \n** that (a) the first field of pPKey2 is an integer, and (b) the \n** size-of-header varint at the start of (pKey1/nKey1) fits in a single\n** byte (i.e. is less than 128).\n**\n** To avoid concerns about buffer overreads, this routine is only used\n** on schemas where the maximum valid header size is 63 bytes or less.\n*/\nstatic int vdbeRecordCompareInt(\n  int nKey1, const void *pKey1, /* Left key */\n  UnpackedRecord *pPKey2        /* Right key */\n){\n  const u8 *aKey = &((const u8*)pKey1)[*(const u8*)pKey1 & 0x3F];\n  int serial_type = ((const u8*)pKey1)[1];\n  int res;\n  u32 y;\n  u64 x;\n  i64 v;\n  i64 lhs;\n\n  vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);\n  assert( (*(u8*)pKey1)<=0x3F || CORRUPT_DB );\n  switch( serial_type ){\n    case 1: { /* 1-byte signed integer */\n      lhs = ONE_BYTE_INT(aKey);\n      testcase( lhs<0 );\n      break;\n    }\n    case 2: { /* 2-byte signed integer */\n      lhs = TWO_BYTE_INT(aKey);\n      testcase( lhs<0 );\n      break;\n    }\n    case 3: { /* 3-byte signed integer */\n      lhs = THREE_BYTE_INT(aKey);\n      testcase( lhs<0 );\n      break;\n    }\n    case 4: { /* 4-byte signed integer */\n      y = FOUR_BYTE_UINT(aKey);\n      lhs = (i64)*(int*)&y;\n      testcase( lhs<0 );\n      break;\n    }\n    case 5: { /* 6-byte signed integer */\n      lhs = FOUR_BYTE_UINT(aKey+2) + (((i64)1)<<32)*TWO_BYTE_INT(aKey);\n      testcase( lhs<0 );\n      break;\n    }\n    case 6: { /* 8-byte signed integer */\n      x = FOUR_BYTE_UINT(aKey);\n      x = (x<<32) | FOUR_BYTE_UINT(aKey+4);\n      lhs = *(i64*)&x;\n      testcase( lhs<0 );\n      break;\n    }\n    case 8: \n      lhs = 0;\n      break;\n    case 9:\n      lhs = 1;\n      break;\n\n    /* This case could be removed without changing the results of running\n    ** this code. Including it causes gcc to generate a faster switch \n    ** statement (since the range of switch targets now starts at zero and\n    ** is contiguous) but does not cause any duplicate code to be generated\n    ** (as gcc is clever enough to combine the two like cases). Other \n    ** compilers might be similar.  */ \n    case 0: case 7:\n      return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);\n\n    default:\n      return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);\n  }\n\n  v = pPKey2->aMem[0].u.i;\n  if( v>lhs ){\n    res = pPKey2->r1;\n  }else if( v<lhs ){\n    res = pPKey2->r2;\n  }else if( pPKey2->nField>1 ){\n    /* The first fields of the two keys are equal. Compare the trailing \n    ** fields.  */\n    res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);\n  }else{\n    /* The first fields of the two keys are equal and there are no trailing\n    ** fields. Return pPKey2->default_rc in this case. */\n    res = pPKey2->default_rc;\n    pPKey2->eqSeen = 1;\n  }\n\n  assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res) );\n  return res;\n}\n\n/*\n** This function is an optimized version of sqlite3VdbeRecordCompare() \n** that (a) the first field of pPKey2 is a string, that (b) the first field\n** uses the collation sequence BINARY and (c) that the size-of-header varint \n** at the start of (pKey1/nKey1) fits in a single byte.\n*/\nstatic int vdbeRecordCompareString(\n  int nKey1, const void *pKey1, /* Left key */\n  UnpackedRecord *pPKey2        /* Right key */\n){\n  const u8 *aKey1 = (const u8*)pKey1;\n  int serial_type;\n  int res;\n\n  assert( pPKey2->aMem[0].flags & MEM_Str );\n  vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);\n  getVarint32(&aKey1[1], serial_type);\n  if( serial_type<12 ){\n    res = pPKey2->r1;      /* (pKey1/nKey1) is a number or a null */\n  }else if( !(serial_type & 0x01) ){ \n    res = pPKey2->r2;      /* (pKey1/nKey1) is a blob */\n  }else{\n    int nCmp;\n    int nStr;\n    int szHdr = aKey1[0];\n\n    nStr = (serial_type-12) / 2;\n    if( (szHdr + nStr) > nKey1 ){\n      pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;\n      return 0;    /* Corruption */\n    }\n    nCmp = MIN( pPKey2->aMem[0].n, nStr );\n    res = memcmp(&aKey1[szHdr], pPKey2->aMem[0].z, nCmp);\n\n    if( res>0 ){\n      res = pPKey2->r2;\n    }else if( res<0 ){\n      res = pPKey2->r1;\n    }else{\n      res = nStr - pPKey2->aMem[0].n;\n      if( res==0 ){\n        if( pPKey2->nField>1 ){\n          res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);\n        }else{\n          res = pPKey2->default_rc;\n          pPKey2->eqSeen = 1;\n        }\n      }else if( res>0 ){\n        res = pPKey2->r2;\n      }else{\n        res = pPKey2->r1;\n      }\n    }\n  }\n\n  assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res)\n       || CORRUPT_DB\n       || pPKey2->pKeyInfo->db->mallocFailed\n  );\n  return res;\n}\n\n/*\n** Return a pointer to an sqlite3VdbeRecordCompare() compatible function\n** suitable for comparing serialized records to the unpacked record passed\n** as the only argument.\n*/\nRecordCompare sqlite3VdbeFindCompare(UnpackedRecord *p){\n  /* varintRecordCompareInt() and varintRecordCompareString() both assume\n  ** that the size-of-header varint that occurs at the start of each record\n  ** fits in a single byte (i.e. is 127 or less). varintRecordCompareInt()\n  ** also assumes that it is safe to overread a buffer by at least the \n  ** maximum possible legal header size plus 8 bytes. Because there is\n  ** guaranteed to be at least 74 (but not 136) bytes of padding following each\n  ** buffer passed to varintRecordCompareInt() this makes it convenient to\n  ** limit the size of the header to 64 bytes in cases where the first field\n  ** is an integer.\n  **\n  ** The easiest way to enforce this limit is to consider only records with\n  ** 13 fields or less. If the first field is an integer, the maximum legal\n  ** header size is (12*5 + 1 + 1) bytes.  */\n  if( p->pKeyInfo->nAllField<=13 ){\n    int flags = p->aMem[0].flags;\n    if( p->pKeyInfo->aSortFlags[0] ){\n      if( p->pKeyInfo->aSortFlags[0] & KEYINFO_ORDER_BIGNULL ){\n        return sqlite3VdbeRecordCompare;\n      }\n      p->r1 = 1;\n      p->r2 = -1;\n    }else{\n      p->r1 = -1;\n      p->r2 = 1;\n    }\n    if( (flags & MEM_Int) ){\n      return vdbeRecordCompareInt;\n    }\n    testcase( flags & MEM_Real );\n    testcase( flags & MEM_Null );\n    testcase( flags & MEM_Blob );\n    if( (flags & (MEM_Real|MEM_IntReal|MEM_Null|MEM_Blob))==0\n     && p->pKeyInfo->aColl[0]==0\n    ){\n      assert( flags & MEM_Str );\n      return vdbeRecordCompareString;\n    }\n  }\n\n  return sqlite3VdbeRecordCompare;\n}\n\n/*\n** pCur points at an index entry created using the OP_MakeRecord opcode.\n** Read the rowid (the last field in the record) and store it in *rowid.\n** Return SQLITE_OK if everything works, or an error code otherwise.\n**\n** pCur might be pointing to text obtained from a corrupt database file.\n** So the content cannot be trusted.  Do appropriate checks on the content.\n*/\nint sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid){\n  i64 nCellKey = 0;\n  int rc;\n  u32 szHdr;        /* Size of the header */\n  u32 typeRowid;    /* Serial type of the rowid */\n  u32 lenRowid;     /* Size of the rowid */\n  Mem m, v;\n\n  /* Get the size of the index entry.  Only indices entries of less\n  ** than 2GiB are support - anything large must be database corruption.\n  ** Any corruption is detected in sqlite3BtreeParseCellPtr(), though, so\n  ** this code can safely assume that nCellKey is 32-bits  \n  */\n  assert( sqlite3BtreeCursorIsValid(pCur) );\n  nCellKey = sqlite3BtreePayloadSize(pCur);\n  assert( (nCellKey & SQLITE_MAX_U32)==(u64)nCellKey );\n\n  /* Read in the complete content of the index entry */\n  sqlite3VdbeMemInit(&m, db, 0);\n  rc = sqlite3VdbeMemFromBtree(pCur, 0, (u32)nCellKey, &m);\n  if( rc ){\n    return rc;\n  }\n\n  /* The index entry must begin with a header size */\n  (void)getVarint32((u8*)m.z, szHdr);\n  testcase( szHdr==3 );\n  testcase( szHdr==m.n );\n  testcase( szHdr>0x7fffffff );\n  assert( m.n>=0 );\n  if( unlikely(szHdr<3 || szHdr>(unsigned)m.n) ){\n    goto idx_rowid_corruption;\n  }\n\n  /* The last field of the index should be an integer - the ROWID.\n  ** Verify that the last entry really is an integer. */\n  (void)getVarint32((u8*)&m.z[szHdr-1], typeRowid);\n  testcase( typeRowid==1 );\n  testcase( typeRowid==2 );\n  testcase( typeRowid==3 );\n  testcase( typeRowid==4 );\n  testcase( typeRowid==5 );\n  testcase( typeRowid==6 );\n  testcase( typeRowid==8 );\n  testcase( typeRowid==9 );\n  if( unlikely(typeRowid<1 || typeRowid>9 || typeRowid==7) ){\n    goto idx_rowid_corruption;\n  }\n  lenRowid = sqlite3SmallTypeSizes[typeRowid];\n  testcase( (u32)m.n==szHdr+lenRowid );\n  if( unlikely((u32)m.n<szHdr+lenRowid) ){\n    goto idx_rowid_corruption;\n  }\n\n  /* Fetch the integer off the end of the index record */\n  sqlite3VdbeSerialGet((u8*)&m.z[m.n-lenRowid], typeRowid, &v);\n  *rowid = v.u.i;\n  sqlite3VdbeMemRelease(&m);\n  return SQLITE_OK;\n\n  /* Jump here if database corruption is detected after m has been\n  ** allocated.  Free the m object and return SQLITE_CORRUPT. */\nidx_rowid_corruption:\n  testcase( m.szMalloc!=0 );\n  sqlite3VdbeMemRelease(&m);\n  return SQLITE_CORRUPT_BKPT;\n}\n\n/*\n** Compare the key of the index entry that cursor pC is pointing to against\n** the key string in pUnpacked.  Write into *pRes a number\n** that is negative, zero, or positive if pC is less than, equal to,\n** or greater than pUnpacked.  Return SQLITE_OK on success.\n**\n** pUnpacked is either created without a rowid or is truncated so that it\n** omits the rowid at the end.  The rowid at the end of the index entry\n** is ignored as well.  Hence, this routine only compares the prefixes \n** of the keys prior to the final rowid, not the entire key.\n*/\nint sqlite3VdbeIdxKeyCompare(\n  sqlite3 *db,                     /* Database connection */\n  VdbeCursor *pC,                  /* The cursor to compare against */\n  UnpackedRecord *pUnpacked,       /* Unpacked version of key */\n  int *res                         /* Write the comparison result here */\n){\n  i64 nCellKey = 0;\n  int rc;\n  BtCursor *pCur;\n  Mem m;\n\n  assert( pC->eCurType==CURTYPE_BTREE );\n  pCur = pC->uc.pCursor;\n  assert( sqlite3BtreeCursorIsValid(pCur) );\n  nCellKey = sqlite3BtreePayloadSize(pCur);\n  /* nCellKey will always be between 0 and 0xffffffff because of the way\n  ** that btreeParseCellPtr() and sqlite3GetVarint32() are implemented */\n  if( nCellKey<=0 || nCellKey>0x7fffffff ){\n    *res = 0;\n    return SQLITE_CORRUPT_BKPT;\n  }\n  sqlite3VdbeMemInit(&m, db, 0);\n  rc = sqlite3VdbeMemFromBtree(pCur, 0, (u32)nCellKey, &m);\n  if( rc ){\n    return rc;\n  }\n  *res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, pUnpacked, 0);\n  sqlite3VdbeMemRelease(&m);\n  return SQLITE_OK;\n}\n\n/*\n** This routine sets the value to be returned by subsequent calls to\n** sqlite3_changes() on the database handle 'db'. \n*/\nvoid sqlite3VdbeSetChanges(sqlite3 *db, int nChange){\n  assert( sqlite3_mutex_held(db->mutex) );\n  db->nChange = nChange;\n  db->nTotalChange += nChange;\n}\n\n/*\n** Set a flag in the vdbe to update the change counter when it is finalised\n** or reset.\n*/\nvoid sqlite3VdbeCountChanges(Vdbe *v){\n  v->changeCntOn = 1;\n}\n\n/*\n** Mark every prepared statement associated with a database connection\n** as expired.\n**\n** An expired statement means that recompilation of the statement is\n** recommend.  Statements expire when things happen that make their\n** programs obsolete.  Removing user-defined functions or collating\n** sequences, or changing an authorization function are the types of\n** things that make prepared statements obsolete.\n**\n** If iCode is 1, then expiration is advisory.  The statement should\n** be reprepared before being restarted, but if it is already running\n** it is allowed to run to completion.\n**\n** Internally, this function just sets the Vdbe.expired flag on all\n** prepared statements.  The flag is set to 1 for an immediate expiration\n** and set to 2 for an advisory expiration.\n*/\nvoid sqlite3ExpirePreparedStatements(sqlite3 *db, int iCode){\n  Vdbe *p;\n  for(p = db->pVdbe; p; p=p->pNext){\n    p->expired = iCode+1;\n  }\n}\n\n/*\n** Return the database associated with the Vdbe.\n*/\nsqlite3 *sqlite3VdbeDb(Vdbe *v){\n  return v->db;\n}\n\n/*\n** Return the SQLITE_PREPARE flags for a Vdbe.\n*/\nu8 sqlite3VdbePrepareFlags(Vdbe *v){\n  return v->prepFlags;\n}\n\n/*\n** Return a pointer to an sqlite3_value structure containing the value bound\n** parameter iVar of VM v. Except, if the value is an SQL NULL, return \n** 0 instead. Unless it is NULL, apply affinity aff (one of the SQLITE_AFF_*\n** constants) to the value before returning it.\n**\n** The returned value must be freed by the caller using sqlite3ValueFree().\n*/\nsqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v, int iVar, u8 aff){\n  assert( iVar>0 );\n  if( v ){\n    Mem *pMem = &v->aVar[iVar-1];\n    assert( (v->db->flags & SQLITE_EnableQPSG)==0 );\n    if( 0==(pMem->flags & MEM_Null) ){\n      sqlite3_value *pRet = sqlite3ValueNew(v->db);\n      if( pRet ){\n        sqlite3VdbeMemCopy((Mem *)pRet, pMem);\n        sqlite3ValueApplyAffinity(pRet, aff, SQLITE_UTF8);\n      }\n      return pRet;\n    }\n  }\n  return 0;\n}\n\n/*\n** Configure SQL variable iVar so that binding a new value to it signals\n** to sqlite3_reoptimize() that re-preparing the statement may result\n** in a better query plan.\n*/\nvoid sqlite3VdbeSetVarmask(Vdbe *v, int iVar){\n  assert( iVar>0 );\n  assert( (v->db->flags & SQLITE_EnableQPSG)==0 );\n  if( iVar>=32 ){\n    v->expmask |= 0x80000000;\n  }else{\n    v->expmask |= ((u32)1 << (iVar-1));\n  }\n}\n\n/*\n** Cause a function to throw an error if it was call from OP_PureFunc\n** rather than OP_Function.\n**\n** OP_PureFunc means that the function must be deterministic, and should\n** throw an error if it is given inputs that would make it non-deterministic.\n** This routine is invoked by date/time functions that use non-deterministic\n** features such as 'now'.\n*/\nint sqlite3NotPureFunc(sqlite3_context *pCtx){\n  const VdbeOp *pOp;\n#ifdef SQLITE_ENABLE_STAT4\n  if( pCtx->pVdbe==0 ) return 1;\n#endif\n  pOp = pCtx->pVdbe->aOp + pCtx->iOp;\n  if( pOp->opcode==OP_PureFunc ){\n    const char *zContext;\n    char *zMsg;\n    if( pOp->p5 & NC_IsCheck ){\n      zContext = \"a CHECK constraint\";\n    }else if( pOp->p5 & NC_GenCol ){\n      zContext = \"a generated column\";\n    }else{\n      zContext = \"an index\";\n    }\n    zMsg = sqlite3_mprintf(\"non-deterministic use of %s() in %s\",\n                           pCtx->pFunc->zName, zContext);\n    sqlite3_result_error(pCtx, zMsg, -1);\n    sqlite3_free(zMsg);\n    return 0;\n  }\n  return 1;\n}\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/*\n** Transfer error message text from an sqlite3_vtab.zErrMsg (text stored\n** in memory obtained from sqlite3_malloc) into a Vdbe.zErrMsg (text stored\n** in memory obtained from sqlite3DbMalloc).\n*/\nvoid sqlite3VtabImportErrmsg(Vdbe *p, sqlite3_vtab *pVtab){\n  if( pVtab->zErrMsg ){\n    sqlite3 *db = p->db;\n    sqlite3DbFree(db, p->zErrMsg);\n    p->zErrMsg = sqlite3DbStrDup(db, pVtab->zErrMsg);\n    sqlite3_free(pVtab->zErrMsg);\n    pVtab->zErrMsg = 0;\n  }\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n\n/*\n** If the second argument is not NULL, release any allocations associated \n** with the memory cells in the p->aMem[] array. Also free the UnpackedRecord\n** structure itself, using sqlite3DbFree().\n**\n** This function is used to free UnpackedRecord structures allocated by\n** the vdbeUnpackRecord() function found in vdbeapi.c.\n*/\nstatic void vdbeFreeUnpacked(sqlite3 *db, int nField, UnpackedRecord *p){\n  if( p ){\n    int i;\n    for(i=0; i<nField; i++){\n      Mem *pMem = &p->aMem[i];\n      if( pMem->zMalloc ) sqlite3VdbeMemRelease(pMem);\n    }\n    sqlite3DbFreeNN(db, p);\n  }\n}\n#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */\n\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n/*\n** Invoke the pre-update hook. If this is an UPDATE or DELETE pre-update call,\n** then cursor passed as the second argument should point to the row about\n** to be update or deleted. If the application calls sqlite3_preupdate_old(),\n** the required value will be read from the row the cursor points to.\n*/\nvoid sqlite3VdbePreUpdateHook(\n  Vdbe *v,                        /* Vdbe pre-update hook is invoked by */\n  VdbeCursor *pCsr,               /* Cursor to grab old.* values from */\n  int op,                         /* SQLITE_INSERT, UPDATE or DELETE */\n  const char *zDb,                /* Database name */\n  Table *pTab,                    /* Modified table */\n  i64 iKey1,                      /* Initial key value */\n  int iReg                        /* Register for new.* record */\n){\n  sqlite3 *db = v->db;\n  i64 iKey2;\n  PreUpdate preupdate;\n  const char *zTbl = pTab->zName;\n  static const u8 fakeSortOrder = 0;\n\n  assert( db->pPreUpdate==0 );\n  memset(&preupdate, 0, sizeof(PreUpdate));\n  if( HasRowid(pTab)==0 ){\n    iKey1 = iKey2 = 0;\n    preupdate.pPk = sqlite3PrimaryKeyIndex(pTab);\n  }else{\n    if( op==SQLITE_UPDATE ){\n      iKey2 = v->aMem[iReg].u.i;\n    }else{\n      iKey2 = iKey1;\n    }\n  }\n\n  assert( pCsr->nField==pTab->nCol \n       || (pCsr->nField==pTab->nCol+1 && op==SQLITE_DELETE && iReg==-1)\n  );\n\n  preupdate.v = v;\n  preupdate.pCsr = pCsr;\n  preupdate.op = op;\n  preupdate.iNewReg = iReg;\n  preupdate.keyinfo.db = db;\n  preupdate.keyinfo.enc = ENC(db);\n  preupdate.keyinfo.nKeyField = pTab->nCol;\n  preupdate.keyinfo.aSortFlags = (u8*)&fakeSortOrder;\n  preupdate.iKey1 = iKey1;\n  preupdate.iKey2 = iKey2;\n  preupdate.pTab = pTab;\n\n  db->pPreUpdate = &preupdate;\n  db->xPreUpdateCallback(db->pPreUpdateArg, db, op, zDb, zTbl, iKey1, iKey2);\n  db->pPreUpdate = 0;\n  sqlite3DbFree(db, preupdate.aRecord);\n  vdbeFreeUnpacked(db, preupdate.keyinfo.nKeyField+1, preupdate.pUnpacked);\n  vdbeFreeUnpacked(db, preupdate.keyinfo.nKeyField+1, preupdate.pNewUnpacked);\n  if( preupdate.aNew ){\n    int i;\n    for(i=0; i<pCsr->nField; i++){\n      sqlite3VdbeMemRelease(&preupdate.aNew[i]);\n    }\n    sqlite3DbFreeNN(db, preupdate.aNew);\n  }\n}\n#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */\n", "/*\n** 2018 May 08\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n*/\n#include \"sqliteInt.h\"\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n\n/*\n** SELECT REWRITING\n**\n**   Any SELECT statement that contains one or more window functions in\n**   either the select list or ORDER BY clause (the only two places window\n**   functions may be used) is transformed by function sqlite3WindowRewrite()\n**   in order to support window function processing. For example, with the\n**   schema:\n**\n**     CREATE TABLE t1(a, b, c, d, e, f, g);\n**\n**   the statement:\n**\n**     SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM t1 ORDER BY e;\n**\n**   is transformed to:\n**\n**     SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM (\n**         SELECT a, e, c, d, b FROM t1 ORDER BY c, d\n**     ) ORDER BY e;\n**\n**   The flattening optimization is disabled when processing this transformed\n**   SELECT statement. This allows the implementation of the window function\n**   (in this case max()) to process rows sorted in order of (c, d), which\n**   makes things easier for obvious reasons. More generally:\n**\n**     * FROM, WHERE, GROUP BY and HAVING clauses are all moved to \n**       the sub-query.\n**\n**     * ORDER BY, LIMIT and OFFSET remain part of the parent query.\n**\n**     * Terminals from each of the expression trees that make up the \n**       select-list and ORDER BY expressions in the parent query are\n**       selected by the sub-query. For the purposes of the transformation,\n**       terminals are column references and aggregate functions.\n**\n**   If there is more than one window function in the SELECT that uses\n**   the same window declaration (the OVER bit), then a single scan may\n**   be used to process more than one window function. For example:\n**\n**     SELECT max(b) OVER (PARTITION BY c ORDER BY d), \n**            min(e) OVER (PARTITION BY c ORDER BY d) \n**     FROM t1;\n**\n**   is transformed in the same way as the example above. However:\n**\n**     SELECT max(b) OVER (PARTITION BY c ORDER BY d), \n**            min(e) OVER (PARTITION BY a ORDER BY b) \n**     FROM t1;\n**\n**   Must be transformed to:\n**\n**     SELECT max(b) OVER (PARTITION BY c ORDER BY d) FROM (\n**         SELECT e, min(e) OVER (PARTITION BY a ORDER BY b), c, d, b FROM\n**           SELECT a, e, c, d, b FROM t1 ORDER BY a, b\n**         ) ORDER BY c, d\n**     ) ORDER BY e;\n**\n**   so that both min() and max() may process rows in the order defined by\n**   their respective window declarations.\n**\n** INTERFACE WITH SELECT.C\n**\n**   When processing the rewritten SELECT statement, code in select.c calls\n**   sqlite3WhereBegin() to begin iterating through the results of the\n**   sub-query, which is always implemented as a co-routine. It then calls\n**   sqlite3WindowCodeStep() to process rows and finish the scan by calling\n**   sqlite3WhereEnd().\n**\n**   sqlite3WindowCodeStep() generates VM code so that, for each row returned\n**   by the sub-query a sub-routine (OP_Gosub) coded by select.c is invoked.\n**   When the sub-routine is invoked:\n**\n**     * The results of all window-functions for the row are stored\n**       in the associated Window.regResult registers.\n**\n**     * The required terminal values are stored in the current row of\n**       temp table Window.iEphCsr.\n**\n**   In some cases, depending on the window frame and the specific window\n**   functions invoked, sqlite3WindowCodeStep() caches each entire partition\n**   in a temp table before returning any rows. In other cases it does not.\n**   This detail is encapsulated within this file, the code generated by\n**   select.c is the same in either case.\n**\n** BUILT-IN WINDOW FUNCTIONS\n**\n**   This implementation features the following built-in window functions:\n**\n**     row_number()\n**     rank()\n**     dense_rank()\n**     percent_rank()\n**     cume_dist()\n**     ntile(N)\n**     lead(expr [, offset [, default]])\n**     lag(expr [, offset [, default]])\n**     first_value(expr)\n**     last_value(expr)\n**     nth_value(expr, N)\n**   \n**   These are the same built-in window functions supported by Postgres. \n**   Although the behaviour of aggregate window functions (functions that\n**   can be used as either aggregates or window funtions) allows them to\n**   be implemented using an API, built-in window functions are much more\n**   esoteric. Additionally, some window functions (e.g. nth_value()) \n**   may only be implemented by caching the entire partition in memory.\n**   As such, some built-in window functions use the same API as aggregate\n**   window functions and some are implemented directly using VDBE \n**   instructions. Additionally, for those functions that use the API, the\n**   window frame is sometimes modified before the SELECT statement is\n**   rewritten. For example, regardless of the specified window frame, the\n**   row_number() function always uses:\n**\n**     ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n**\n**   See sqlite3WindowUpdate() for details.\n**\n**   As well as some of the built-in window functions, aggregate window\n**   functions min() and max() are implemented using VDBE instructions if\n**   the start of the window frame is declared as anything other than \n**   UNBOUNDED PRECEDING.\n*/\n\n/*\n** Implementation of built-in window function row_number(). Assumes that the\n** window frame has been coerced to:\n**\n**   ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n*/\nstatic void row_numberStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ) (*p)++;\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n}\nstatic void row_numberValueFunc(sqlite3_context *pCtx){\n  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  sqlite3_result_int64(pCtx, (p ? *p : 0));\n}\n\n/*\n** Context object type used by rank(), dense_rank(), percent_rank() and\n** cume_dist().\n*/\nstruct CallCount {\n  i64 nValue;\n  i64 nStep;\n  i64 nTotal;\n};\n\n/*\n** Implementation of built-in window function dense_rank(). Assumes that\n** the window frame has been set to:\n**\n**   RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW \n*/\nstatic void dense_rankStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ) p->nStep = 1;\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n}\nstatic void dense_rankValueFunc(sqlite3_context *pCtx){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    if( p->nStep ){\n      p->nValue++;\n      p->nStep = 0;\n    }\n    sqlite3_result_int64(pCtx, p->nValue);\n  }\n}\n\n/*\n** Implementation of built-in window function nth_value(). This\n** implementation is used in \"slow mode\" only - when the EXCLUDE clause\n** is not set to the default value \"NO OTHERS\".\n*/\nstruct NthValueCtx {\n  i64 nStep;\n  sqlite3_value *pValue;\n};\nstatic void nth_valueStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct NthValueCtx *p;\n  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    i64 iVal;\n    switch( sqlite3_value_numeric_type(apArg[1]) ){\n      case SQLITE_INTEGER:\n        iVal = sqlite3_value_int64(apArg[1]);\n        break;\n      case SQLITE_FLOAT: {\n        double fVal = sqlite3_value_double(apArg[1]);\n        if( ((i64)fVal)!=fVal ) goto error_out;\n        iVal = (i64)fVal;\n        break;\n      }\n      default:\n        goto error_out;\n    }\n    if( iVal<=0 ) goto error_out;\n\n    p->nStep++;\n    if( iVal==p->nStep ){\n      p->pValue = sqlite3_value_dup(apArg[0]);\n      if( !p->pValue ){\n        sqlite3_result_error_nomem(pCtx);\n      }\n    }\n  }\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n  return;\n\n error_out:\n  sqlite3_result_error(\n      pCtx, \"second argument to nth_value must be a positive integer\", -1\n  );\n}\nstatic void nth_valueFinalizeFunc(sqlite3_context *pCtx){\n  struct NthValueCtx *p;\n  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, 0);\n  if( p && p->pValue ){\n    sqlite3_result_value(pCtx, p->pValue);\n    sqlite3_value_free(p->pValue);\n    p->pValue = 0;\n  }\n}\n#define nth_valueInvFunc noopStepFunc\n#define nth_valueValueFunc noopValueFunc\n\nstatic void first_valueStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct NthValueCtx *p;\n  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p && p->pValue==0 ){\n    p->pValue = sqlite3_value_dup(apArg[0]);\n    if( !p->pValue ){\n      sqlite3_result_error_nomem(pCtx);\n    }\n  }\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n}\nstatic void first_valueFinalizeFunc(sqlite3_context *pCtx){\n  struct NthValueCtx *p;\n  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p && p->pValue ){\n    sqlite3_result_value(pCtx, p->pValue);\n    sqlite3_value_free(p->pValue);\n    p->pValue = 0;\n  }\n}\n#define first_valueInvFunc noopStepFunc\n#define first_valueValueFunc noopValueFunc\n\n/*\n** Implementation of built-in window function rank(). Assumes that\n** the window frame has been set to:\n**\n**   RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW \n*/\nstatic void rankStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    p->nStep++;\n    if( p->nValue==0 ){\n      p->nValue = p->nStep;\n    }\n  }\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n}\nstatic void rankValueFunc(sqlite3_context *pCtx){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    sqlite3_result_int64(pCtx, p->nValue);\n    p->nValue = 0;\n  }\n}\n\n/*\n** Implementation of built-in window function percent_rank(). Assumes that\n** the window frame has been set to:\n**\n**   GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING\n*/\nstatic void percent_rankStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  UNUSED_PARAMETER(nArg); assert( nArg==0 );\n  UNUSED_PARAMETER(apArg);\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    p->nTotal++;\n  }\n}\nstatic void percent_rankInvFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  UNUSED_PARAMETER(nArg); assert( nArg==0 );\n  UNUSED_PARAMETER(apArg);\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  p->nStep++;\n}\nstatic void percent_rankValueFunc(sqlite3_context *pCtx){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    p->nValue = p->nStep;\n    if( p->nTotal>1 ){\n      double r = (double)p->nValue / (double)(p->nTotal-1);\n      sqlite3_result_double(pCtx, r);\n    }else{\n      sqlite3_result_double(pCtx, 0.0);\n    }\n  }\n}\n#define percent_rankFinalizeFunc percent_rankValueFunc\n\n/*\n** Implementation of built-in window function cume_dist(). Assumes that\n** the window frame has been set to:\n**\n**   GROUPS BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING\n*/\nstatic void cume_distStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  UNUSED_PARAMETER(nArg); assert( nArg==0 );\n  UNUSED_PARAMETER(apArg);\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    p->nTotal++;\n  }\n}\nstatic void cume_distInvFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  UNUSED_PARAMETER(nArg); assert( nArg==0 );\n  UNUSED_PARAMETER(apArg);\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  p->nStep++;\n}\nstatic void cume_distValueFunc(sqlite3_context *pCtx){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, 0);\n  if( p ){\n    double r = (double)(p->nStep) / (double)(p->nTotal);\n    sqlite3_result_double(pCtx, r);\n  }\n}\n#define cume_distFinalizeFunc cume_distValueFunc\n\n/*\n** Context object for ntile() window function.\n*/\nstruct NtileCtx {\n  i64 nTotal;                     /* Total rows in partition */\n  i64 nParam;                     /* Parameter passed to ntile(N) */\n  i64 iRow;                       /* Current row */\n};\n\n/*\n** Implementation of ntile(). This assumes that the window frame has\n** been coerced to:\n**\n**   ROWS CURRENT ROW AND UNBOUNDED FOLLOWING\n*/\nstatic void ntileStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct NtileCtx *p;\n  assert( nArg==1 ); UNUSED_PARAMETER(nArg);\n  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    if( p->nTotal==0 ){\n      p->nParam = sqlite3_value_int64(apArg[0]);\n      if( p->nParam<=0 ){\n        sqlite3_result_error(\n            pCtx, \"argument of ntile must be a positive integer\", -1\n        );\n      }\n    }\n    p->nTotal++;\n  }\n}\nstatic void ntileInvFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct NtileCtx *p;\n  assert( nArg==1 ); UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  p->iRow++;\n}\nstatic void ntileValueFunc(sqlite3_context *pCtx){\n  struct NtileCtx *p;\n  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p && p->nParam>0 ){\n    int nSize = (p->nTotal / p->nParam);\n    if( nSize==0 ){\n      sqlite3_result_int64(pCtx, p->iRow+1);\n    }else{\n      i64 nLarge = p->nTotal - p->nParam*nSize;\n      i64 iSmall = nLarge*(nSize+1);\n      i64 iRow = p->iRow;\n\n      assert( (nLarge*(nSize+1) + (p->nParam-nLarge)*nSize)==p->nTotal );\n\n      if( iRow<iSmall ){\n        sqlite3_result_int64(pCtx, 1 + iRow/(nSize+1));\n      }else{\n        sqlite3_result_int64(pCtx, 1 + nLarge + (iRow-iSmall)/nSize);\n      }\n    }\n  }\n}\n#define ntileFinalizeFunc ntileValueFunc\n\n/*\n** Context object for last_value() window function.\n*/\nstruct LastValueCtx {\n  sqlite3_value *pVal;\n  int nVal;\n};\n\n/*\n** Implementation of last_value().\n*/\nstatic void last_valueStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct LastValueCtx *p;\n  UNUSED_PARAMETER(nArg);\n  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    sqlite3_value_free(p->pVal);\n    p->pVal = sqlite3_value_dup(apArg[0]);\n    if( p->pVal==0 ){\n      sqlite3_result_error_nomem(pCtx);\n    }else{\n      p->nVal++;\n    }\n  }\n}\nstatic void last_valueInvFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct LastValueCtx *p;\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( ALWAYS(p) ){\n    p->nVal--;\n    if( p->nVal==0 ){\n      sqlite3_value_free(p->pVal);\n      p->pVal = 0;\n    }\n  }\n}\nstatic void last_valueValueFunc(sqlite3_context *pCtx){\n  struct LastValueCtx *p;\n  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, 0);\n  if( p && p->pVal ){\n    sqlite3_result_value(pCtx, p->pVal);\n  }\n}\nstatic void last_valueFinalizeFunc(sqlite3_context *pCtx){\n  struct LastValueCtx *p;\n  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p && p->pVal ){\n    sqlite3_result_value(pCtx, p->pVal);\n    sqlite3_value_free(p->pVal);\n    p->pVal = 0;\n  }\n}\n\n/*\n** Static names for the built-in window function names.  These static\n** names are used, rather than string literals, so that FuncDef objects\n** can be associated with a particular window function by direct\n** comparison of the zName pointer.  Example:\n**\n**       if( pFuncDef->zName==row_valueName ){ ... }\n*/\nstatic const char row_numberName[] =   \"row_number\";\nstatic const char dense_rankName[] =   \"dense_rank\";\nstatic const char rankName[] =         \"rank\";\nstatic const char percent_rankName[] = \"percent_rank\";\nstatic const char cume_distName[] =    \"cume_dist\";\nstatic const char ntileName[] =        \"ntile\";\nstatic const char last_valueName[] =   \"last_value\";\nstatic const char nth_valueName[] =    \"nth_value\";\nstatic const char first_valueName[] =  \"first_value\";\nstatic const char leadName[] =         \"lead\";\nstatic const char lagName[] =          \"lag\";\n\n/*\n** No-op implementations of xStep() and xFinalize().  Used as place-holders\n** for built-in window functions that never call those interfaces.\n**\n** The noopValueFunc() is called but is expected to do nothing.  The\n** noopStepFunc() is never called, and so it is marked with NO_TEST to\n** let the test coverage routine know not to expect this function to be\n** invoked.\n*/\nstatic void noopStepFunc(    /*NO_TEST*/\n  sqlite3_context *p,        /*NO_TEST*/\n  int n,                     /*NO_TEST*/\n  sqlite3_value **a          /*NO_TEST*/\n){                           /*NO_TEST*/\n  UNUSED_PARAMETER(p);       /*NO_TEST*/\n  UNUSED_PARAMETER(n);       /*NO_TEST*/\n  UNUSED_PARAMETER(a);       /*NO_TEST*/\n  assert(0);                 /*NO_TEST*/\n}                            /*NO_TEST*/\nstatic void noopValueFunc(sqlite3_context *p){ UNUSED_PARAMETER(p); /*no-op*/ }\n\n/* Window functions that use all window interfaces: xStep, xFinal,\n** xValue, and xInverse */\n#define WINDOWFUNCALL(name,nArg,extra) {                                   \\\n  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \\\n  name ## StepFunc, name ## FinalizeFunc, name ## ValueFunc,               \\\n  name ## InvFunc, name ## Name, {0}                                       \\\n}\n\n/* Window functions that are implemented using bytecode and thus have\n** no-op routines for their methods */\n#define WINDOWFUNCNOOP(name,nArg,extra) {                                  \\\n  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \\\n  noopStepFunc, noopValueFunc, noopValueFunc,                              \\\n  noopStepFunc, name ## Name, {0}                                          \\\n}\n\n/* Window functions that use all window interfaces: xStep, the\n** same routine for xFinalize and xValue and which never call\n** xInverse. */\n#define WINDOWFUNCX(name,nArg,extra) {                                     \\\n  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \\\n  name ## StepFunc, name ## ValueFunc, name ## ValueFunc,                  \\\n  noopStepFunc, name ## Name, {0}                                          \\\n}\n\n\n/*\n** Register those built-in window functions that are not also aggregates.\n*/\nvoid sqlite3WindowFunctions(void){\n  static FuncDef aWindowFuncs[] = {\n    WINDOWFUNCX(row_number, 0, 0),\n    WINDOWFUNCX(dense_rank, 0, 0),\n    WINDOWFUNCX(rank, 0, 0),\n    WINDOWFUNCALL(percent_rank, 0, 0),\n    WINDOWFUNCALL(cume_dist, 0, 0),\n    WINDOWFUNCALL(ntile, 1, 0),\n    WINDOWFUNCALL(last_value, 1, 0),\n    WINDOWFUNCALL(nth_value, 2, 0),\n    WINDOWFUNCALL(first_value, 1, 0),\n    WINDOWFUNCNOOP(lead, 1, 0),\n    WINDOWFUNCNOOP(lead, 2, 0),\n    WINDOWFUNCNOOP(lead, 3, 0),\n    WINDOWFUNCNOOP(lag, 1, 0),\n    WINDOWFUNCNOOP(lag, 2, 0),\n    WINDOWFUNCNOOP(lag, 3, 0),\n  };\n  sqlite3InsertBuiltinFuncs(aWindowFuncs, ArraySize(aWindowFuncs));\n}\n\nstatic Window *windowFind(Parse *pParse, Window *pList, const char *zName){\n  Window *p;\n  for(p=pList; p; p=p->pNextWin){\n    if( sqlite3StrICmp(p->zName, zName)==0 ) break;\n  }\n  if( p==0 ){\n    sqlite3ErrorMsg(pParse, \"no such window: %s\", zName);\n  }\n  return p;\n}\n\n/*\n** This function is called immediately after resolving the function name\n** for a window function within a SELECT statement. Argument pList is a\n** linked list of WINDOW definitions for the current SELECT statement.\n** Argument pFunc is the function definition just resolved and pWin\n** is the Window object representing the associated OVER clause. This\n** function updates the contents of pWin as follows:\n**\n**   * If the OVER clause refered to a named window (as in \"max(x) OVER win\"),\n**     search list pList for a matching WINDOW definition, and update pWin\n**     accordingly. If no such WINDOW clause can be found, leave an error\n**     in pParse.\n**\n**   * If the function is a built-in window function that requires the\n**     window to be coerced (see \"BUILT-IN WINDOW FUNCTIONS\" at the top\n**     of this file), pWin is updated here.\n*/\nvoid sqlite3WindowUpdate(\n  Parse *pParse, \n  Window *pList,                  /* List of named windows for this SELECT */\n  Window *pWin,                   /* Window frame to update */\n  FuncDef *pFunc                  /* Window function definition */\n){\n  if( pWin->zName && pWin->eFrmType==0 ){\n    Window *p = windowFind(pParse, pList, pWin->zName);\n    if( p==0 ) return;\n    pWin->pPartition = sqlite3ExprListDup(pParse->db, p->pPartition, 0);\n    pWin->pOrderBy = sqlite3ExprListDup(pParse->db, p->pOrderBy, 0);\n    pWin->pStart = sqlite3ExprDup(pParse->db, p->pStart, 0);\n    pWin->pEnd = sqlite3ExprDup(pParse->db, p->pEnd, 0);\n    pWin->eStart = p->eStart;\n    pWin->eEnd = p->eEnd;\n    pWin->eFrmType = p->eFrmType;\n    pWin->eExclude = p->eExclude;\n  }else{\n    sqlite3WindowChain(pParse, pWin, pList);\n  }\n  if( (pWin->eFrmType==TK_RANGE)\n   && (pWin->pStart || pWin->pEnd) \n   && (pWin->pOrderBy==0 || pWin->pOrderBy->nExpr!=1)\n  ){\n    sqlite3ErrorMsg(pParse, \n      \"RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression\"\n    );\n  }else\n  if( pFunc->funcFlags & SQLITE_FUNC_WINDOW ){\n    sqlite3 *db = pParse->db;\n    if( pWin->pFilter ){\n      sqlite3ErrorMsg(pParse, \n          \"FILTER clause may only be used with aggregate window functions\"\n      );\n    }else{\n      struct WindowUpdate {\n        const char *zFunc;\n        int eFrmType;\n        int eStart;\n        int eEnd;\n      } aUp[] = {\n        { row_numberName,   TK_ROWS,   TK_UNBOUNDED, TK_CURRENT }, \n        { dense_rankName,   TK_RANGE,  TK_UNBOUNDED, TK_CURRENT }, \n        { rankName,         TK_RANGE,  TK_UNBOUNDED, TK_CURRENT }, \n        { percent_rankName, TK_GROUPS, TK_CURRENT,   TK_UNBOUNDED }, \n        { cume_distName,    TK_GROUPS, TK_FOLLOWING, TK_UNBOUNDED }, \n        { ntileName,        TK_ROWS,   TK_CURRENT,   TK_UNBOUNDED }, \n        { leadName,         TK_ROWS,   TK_UNBOUNDED, TK_UNBOUNDED }, \n        { lagName,          TK_ROWS,   TK_UNBOUNDED, TK_CURRENT }, \n      };\n      int i;\n      for(i=0; i<ArraySize(aUp); i++){\n        if( pFunc->zName==aUp[i].zFunc ){\n          sqlite3ExprDelete(db, pWin->pStart);\n          sqlite3ExprDelete(db, pWin->pEnd);\n          pWin->pEnd = pWin->pStart = 0;\n          pWin->eFrmType = aUp[i].eFrmType;\n          pWin->eStart = aUp[i].eStart;\n          pWin->eEnd = aUp[i].eEnd;\n          pWin->eExclude = 0;\n          if( pWin->eStart==TK_FOLLOWING ){\n            pWin->pStart = sqlite3Expr(db, TK_INTEGER, \"1\");\n          }\n          break;\n        }\n      }\n    }\n  }\n  pWin->pFunc = pFunc;\n}\n\n/*\n** Context object passed through sqlite3WalkExprList() to\n** selectWindowRewriteExprCb() by selectWindowRewriteEList().\n*/\ntypedef struct WindowRewrite WindowRewrite;\nstruct WindowRewrite {\n  Window *pWin;\n  SrcList *pSrc;\n  ExprList *pSub;\n  Table *pTab;\n  Select *pSubSelect;             /* Current sub-select, if any */\n};\n\n/*\n** Callback function used by selectWindowRewriteEList(). If necessary,\n** this function appends to the output expression-list and updates \n** expression (*ppExpr) in place.\n*/\nstatic int selectWindowRewriteExprCb(Walker *pWalker, Expr *pExpr){\n  struct WindowRewrite *p = pWalker->u.pRewrite;\n  Parse *pParse = pWalker->pParse;\n  assert( p!=0 );\n  assert( p->pWin!=0 );\n\n  /* If this function is being called from within a scalar sub-select\n  ** that used by the SELECT statement being processed, only process\n  ** TK_COLUMN expressions that refer to it (the outer SELECT). Do\n  ** not process aggregates or window functions at all, as they belong\n  ** to the scalar sub-select.  */\n  if( p->pSubSelect ){\n    if( pExpr->op!=TK_COLUMN ){\n      return WRC_Continue;\n    }else{\n      int nSrc = p->pSrc->nSrc;\n      int i;\n      for(i=0; i<nSrc; i++){\n        if( pExpr->iTable==p->pSrc->a[i].iCursor ) break;\n      }\n      if( i==nSrc ) return WRC_Continue;\n    }\n  }\n\n  switch( pExpr->op ){\n\n    case TK_FUNCTION:\n      if( !ExprHasProperty(pExpr, EP_WinFunc) ){\n        break;\n      }else{\n        Window *pWin;\n        for(pWin=p->pWin; pWin; pWin=pWin->pNextWin){\n          if( pExpr->y.pWin==pWin ){\n            assert( pWin->pOwner==pExpr );\n            return WRC_Prune;\n          }\n        }\n      }\n      /* Fall through.  */\n\n    case TK_AGG_FUNCTION:\n    case TK_COLUMN: {\n      int iCol = -1;\n      if( p->pSub ){\n        int i;\n        for(i=0; i<p->pSub->nExpr; i++){\n          if( 0==sqlite3ExprCompare(0, p->pSub->a[i].pExpr, pExpr, -1) ){\n            iCol = i;\n            break;\n          }\n        }\n      }\n      if( iCol<0 ){\n        Expr *pDup = sqlite3ExprDup(pParse->db, pExpr, 0);\n        p->pSub = sqlite3ExprListAppend(pParse, p->pSub, pDup);\n      }\n      if( p->pSub ){\n        assert( ExprHasProperty(pExpr, EP_Static)==0 );\n        ExprSetProperty(pExpr, EP_Static);\n        sqlite3ExprDelete(pParse->db, pExpr);\n        ExprClearProperty(pExpr, EP_Static);\n        memset(pExpr, 0, sizeof(Expr));\n\n        pExpr->op = TK_COLUMN;\n        pExpr->iColumn = (iCol<0 ? p->pSub->nExpr-1: iCol);\n        pExpr->iTable = p->pWin->iEphCsr;\n        pExpr->y.pTab = p->pTab;\n      }\n      if( pParse->db->mallocFailed ) return WRC_Abort;\n      break;\n    }\n\n    default: /* no-op */\n      break;\n  }\n\n  return WRC_Continue;\n}\nstatic int selectWindowRewriteSelectCb(Walker *pWalker, Select *pSelect){\n  struct WindowRewrite *p = pWalker->u.pRewrite;\n  Select *pSave = p->pSubSelect;\n  if( pSave==pSelect ){\n    return WRC_Continue;\n  }else{\n    p->pSubSelect = pSelect;\n    sqlite3WalkSelect(pWalker, pSelect);\n    p->pSubSelect = pSave;\n  }\n  return WRC_Prune;\n}\n\n\n/*\n** Iterate through each expression in expression-list pEList. For each:\n**\n**   * TK_COLUMN,\n**   * aggregate function, or\n**   * window function with a Window object that is not a member of the \n**     Window list passed as the second argument (pWin).\n**\n** Append the node to output expression-list (*ppSub). And replace it\n** with a TK_COLUMN that reads the (N-1)th element of table \n** pWin->iEphCsr, where N is the number of elements in (*ppSub) after\n** appending the new one.\n*/\nstatic void selectWindowRewriteEList(\n  Parse *pParse, \n  Window *pWin,\n  SrcList *pSrc,\n  ExprList *pEList,               /* Rewrite expressions in this list */\n  Table *pTab,\n  ExprList **ppSub                /* IN/OUT: Sub-select expression-list */\n){\n  Walker sWalker;\n  WindowRewrite sRewrite;\n\n  assert( pWin!=0 );\n  memset(&sWalker, 0, sizeof(Walker));\n  memset(&sRewrite, 0, sizeof(WindowRewrite));\n\n  sRewrite.pSub = *ppSub;\n  sRewrite.pWin = pWin;\n  sRewrite.pSrc = pSrc;\n  sRewrite.pTab = pTab;\n\n  sWalker.pParse = pParse;\n  sWalker.xExprCallback = selectWindowRewriteExprCb;\n  sWalker.xSelectCallback = selectWindowRewriteSelectCb;\n  sWalker.u.pRewrite = &sRewrite;\n\n  (void)sqlite3WalkExprList(&sWalker, pEList);\n\n  *ppSub = sRewrite.pSub;\n}\n\n/*\n** Append a copy of each expression in expression-list pAppend to\n** expression list pList. Return a pointer to the result list.\n*/\nstatic ExprList *exprListAppendList(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to append. Might be NULL */\n  ExprList *pAppend,      /* List of values to append. Might be NULL */\n  int bIntToNull\n){\n  if( pAppend ){\n    int i;\n    int nInit = pList ? pList->nExpr : 0;\n    for(i=0; i<pAppend->nExpr; i++){\n      Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);\n      assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );\n      if( bIntToNull && pDup && pDup->op==TK_INTEGER ){\n        pDup->op = TK_NULL;\n        pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);\n        pDup->u.zToken = 0;\n      }\n      pList = sqlite3ExprListAppend(pParse, pList, pDup);\n      if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;\n    }\n  }\n  return pList;\n}\n\n/*\n** If the SELECT statement passed as the second argument does not invoke\n** any SQL window functions, this function is a no-op. Otherwise, it \n** rewrites the SELECT statement so that window function xStep functions\n** are invoked in the correct order as described under \"SELECT REWRITING\"\n** at the top of this file.\n*/\nint sqlite3WindowRewrite(Parse *pParse, Select *p){\n  int rc = SQLITE_OK;\n  if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    sqlite3 *db = pParse->db;\n    Select *pSub = 0;             /* The subquery */\n    SrcList *pSrc = p->pSrc;\n    Expr *pWhere = p->pWhere;\n    ExprList *pGroupBy = p->pGroupBy;\n    Expr *pHaving = p->pHaving;\n    ExprList *pSort = 0;\n\n    ExprList *pSublist = 0;       /* Expression list for sub-query */\n    Window *pMWin = p->pWin;      /* Master window object */\n    Window *pWin;                 /* Window object iterator */\n    Table *pTab;\n\n    pTab = sqlite3DbMallocZero(db, sizeof(Table));\n    if( pTab==0 ){\n      return SQLITE_NOMEM;\n    }\n\n    p->pSrc = 0;\n    p->pWhere = 0;\n    p->pGroupBy = 0;\n    p->pHaving = 0;\n    p->selFlags &= ~SF_Aggregate;\n    p->selFlags |= SF_WinRewrite;\n\n    /* Create the ORDER BY clause for the sub-select. This is the concatenation\n    ** of the window PARTITION and ORDER BY clauses. Then, if this makes it\n    ** redundant, remove the ORDER BY from the parent SELECT.  */\n    pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);\n    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);\n    if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){\n      int nSave = pSort->nExpr;\n      pSort->nExpr = p->pOrderBy->nExpr;\n      if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        p->pOrderBy = 0;\n      }\n      pSort->nExpr = nSave;\n    }\n\n    /* Assign a cursor number for the ephemeral table used to buffer rows.\n    ** The OpenEphemeral instruction is coded later, after it is known how\n    ** many columns the table will have.  */\n    pMWin->iEphCsr = pParse->nTab++;\n    pParse->nTab += 3;\n\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);\n    pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);\n\n    /* Append the PARTITION BY and ORDER BY expressions to the to the \n    ** sub-select expression list. They are required to figure out where \n    ** boundaries for partitions and sets of peer rows lie.  */\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);\n\n    /* Append the arguments passed to each window function to the\n    ** sub-select expression list. Also allocate two registers for each\n    ** window function - one for the accumulator, another for interim\n    ** results.  */\n    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n      ExprList *pArgs = pWin->pOwner->x.pList;\n      if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){\n        selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pWin->bExprArgs = 1;\n      }else{\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);\n      }\n      if( pWin->pFilter ){\n        Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);\n        pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);\n      }\n      pWin->regAccum = ++pParse->nMem;\n      pWin->regResult = ++pParse->nMem;\n      sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n    }\n\n    /* If there is no ORDER BY or PARTITION BY clause, and the window\n    ** function accepts zero arguments, and there are no other columns\n    ** selected (e.g. \"SELECT row_number() OVER () FROM t1\"), it is possible\n    ** that pSublist is still NULL here. Add a constant expression here to \n    ** keep everything legal in this case. \n    */\n    if( pSublist==0 ){\n      pSublist = sqlite3ExprListAppend(pParse, 0, \n        sqlite3Expr(db, TK_INTEGER, \"0\")\n      );\n    }\n\n    pSub = sqlite3SelectNew(\n        pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0\n    );\n    p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n    if( p->pSrc ){\n      Table *pTab2;\n      p->pSrc->a[0].pSelect = pSub;\n      sqlite3SrcListAssignCursors(pParse, p->pSrc);\n      pSub->selFlags |= SF_Expanded;\n      pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);\n      if( pTab2==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        memcpy(pTab, pTab2, sizeof(Table));\n        pTab->tabFlags |= TF_Ephemeral;\n        p->pSrc->a[0].pTab = pTab;\n        pTab = pTab2;\n      }\n      sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);\n    }else{\n      sqlite3SelectDelete(db, pSub);\n    }\n    if( db->mallocFailed ) rc = SQLITE_NOMEM;\n    sqlite3DbFree(db, pTab);\n  }\n\n  return rc;\n}\n\n/*\n** Unlink the Window object from the Select to which it is attached,\n** if it is attached.\n*/\nvoid sqlite3WindowUnlinkFromSelect(Window *p){\n  if( p->ppThis ){\n    *p->ppThis = p->pNextWin;\n    if( p->pNextWin ) p->pNextWin->ppThis = p->ppThis;\n    p->ppThis = 0;\n  }\n}\n\n/*\n** Free the Window object passed as the second argument.\n*/\nvoid sqlite3WindowDelete(sqlite3 *db, Window *p){\n  if( p ){\n    sqlite3WindowUnlinkFromSelect(p);\n    sqlite3ExprDelete(db, p->pFilter);\n    sqlite3ExprListDelete(db, p->pPartition);\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    sqlite3ExprDelete(db, p->pEnd);\n    sqlite3ExprDelete(db, p->pStart);\n    sqlite3DbFree(db, p->zName);\n    sqlite3DbFree(db, p->zBase);\n    sqlite3DbFree(db, p);\n  }\n}\n\n/*\n** Free the linked list of Window objects starting at the second argument.\n*/\nvoid sqlite3WindowListDelete(sqlite3 *db, Window *p){\n  while( p ){\n    Window *pNext = p->pNextWin;\n    sqlite3WindowDelete(db, p);\n    p = pNext;\n  }\n}\n\n/*\n** The argument expression is an PRECEDING or FOLLOWING offset.  The\n** value should be a non-negative integer.  If the value is not a\n** constant, change it to NULL.  The fact that it is then a non-negative\n** integer will be caught later.  But it is important not to leave\n** variable values in the expression tree.\n*/\nstatic Expr *sqlite3WindowOffsetExpr(Parse *pParse, Expr *pExpr){\n  if( 0==sqlite3ExprIsConstant(pExpr) ){\n    if( IN_RENAME_OBJECT ) sqlite3RenameExprUnmap(pParse, pExpr);\n    sqlite3ExprDelete(pParse->db, pExpr);\n    pExpr = sqlite3ExprAlloc(pParse->db, TK_NULL, 0, 0);\n  }\n  return pExpr;\n}\n\n/*\n** Allocate and return a new Window object describing a Window Definition.\n*/\nWindow *sqlite3WindowAlloc(\n  Parse *pParse,    /* Parsing context */\n  int eType,        /* Frame type. TK_RANGE, TK_ROWS, TK_GROUPS, or 0 */\n  int eStart,       /* Start type: CURRENT, PRECEDING, FOLLOWING, UNBOUNDED */\n  Expr *pStart,     /* Start window size if TK_PRECEDING or FOLLOWING */\n  int eEnd,         /* End type: CURRENT, FOLLOWING, TK_UNBOUNDED, PRECEDING */\n  Expr *pEnd,       /* End window size if TK_FOLLOWING or PRECEDING */\n  u8 eExclude       /* EXCLUDE clause */\n){\n  Window *pWin = 0;\n  int bImplicitFrame = 0;\n\n  /* Parser assures the following: */\n  assert( eType==0 || eType==TK_RANGE || eType==TK_ROWS || eType==TK_GROUPS );\n  assert( eStart==TK_CURRENT || eStart==TK_PRECEDING\n           || eStart==TK_UNBOUNDED || eStart==TK_FOLLOWING );\n  assert( eEnd==TK_CURRENT || eEnd==TK_FOLLOWING\n           || eEnd==TK_UNBOUNDED || eEnd==TK_PRECEDING );\n  assert( (eStart==TK_PRECEDING || eStart==TK_FOLLOWING)==(pStart!=0) );\n  assert( (eEnd==TK_FOLLOWING || eEnd==TK_PRECEDING)==(pEnd!=0) );\n\n  if( eType==0 ){\n    bImplicitFrame = 1;\n    eType = TK_RANGE;\n  }\n\n  /* Additionally, the\n  ** starting boundary type may not occur earlier in the following list than\n  ** the ending boundary type:\n  **\n  **   UNBOUNDED PRECEDING\n  **   <expr> PRECEDING\n  **   CURRENT ROW\n  **   <expr> FOLLOWING\n  **   UNBOUNDED FOLLOWING\n  **\n  ** The parser ensures that \"UNBOUNDED PRECEDING\" cannot be used as an ending\n  ** boundary, and than \"UNBOUNDED FOLLOWING\" cannot be used as a starting\n  ** frame boundary.\n  */\n  if( (eStart==TK_CURRENT && eEnd==TK_PRECEDING)\n   || (eStart==TK_FOLLOWING && (eEnd==TK_PRECEDING || eEnd==TK_CURRENT))\n  ){\n    sqlite3ErrorMsg(pParse, \"unsupported frame specification\");\n    goto windowAllocErr;\n  }\n\n  pWin = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n  if( pWin==0 ) goto windowAllocErr;\n  pWin->eFrmType = eType;\n  pWin->eStart = eStart;\n  pWin->eEnd = eEnd;\n  if( eExclude==0 && OptimizationDisabled(pParse->db, SQLITE_WindowFunc) ){\n    eExclude = TK_NO;\n  }\n  pWin->eExclude = eExclude;\n  pWin->bImplicitFrame = bImplicitFrame;\n  pWin->pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);\n  pWin->pStart = sqlite3WindowOffsetExpr(pParse, pStart);\n  return pWin;\n\nwindowAllocErr:\n  sqlite3ExprDelete(pParse->db, pEnd);\n  sqlite3ExprDelete(pParse->db, pStart);\n  return 0;\n}\n\n/*\n** Attach PARTITION and ORDER BY clauses pPartition and pOrderBy to window\n** pWin. Also, if parameter pBase is not NULL, set pWin->zBase to the\n** equivalent nul-terminated string.\n*/\nWindow *sqlite3WindowAssemble(\n  Parse *pParse, \n  Window *pWin, \n  ExprList *pPartition, \n  ExprList *pOrderBy, \n  Token *pBase\n){\n  if( pWin ){\n    pWin->pPartition = pPartition;\n    pWin->pOrderBy = pOrderBy;\n    if( pBase ){\n      pWin->zBase = sqlite3DbStrNDup(pParse->db, pBase->z, pBase->n);\n    }\n  }else{\n    sqlite3ExprListDelete(pParse->db, pPartition);\n    sqlite3ExprListDelete(pParse->db, pOrderBy);\n  }\n  return pWin;\n}\n\n/*\n** Window *pWin has just been created from a WINDOW clause. Tokne pBase\n** is the base window. Earlier windows from the same WINDOW clause are\n** stored in the linked list starting at pWin->pNextWin. This function\n** either updates *pWin according to the base specification, or else\n** leaves an error in pParse.\n*/\nvoid sqlite3WindowChain(Parse *pParse, Window *pWin, Window *pList){\n  if( pWin->zBase ){\n    sqlite3 *db = pParse->db;\n    Window *pExist = windowFind(pParse, pList, pWin->zBase);\n    if( pExist ){\n      const char *zErr = 0;\n      /* Check for errors */\n      if( pWin->pPartition ){\n        zErr = \"PARTITION clause\";\n      }else if( pExist->pOrderBy && pWin->pOrderBy ){\n        zErr = \"ORDER BY clause\";\n      }else if( pExist->bImplicitFrame==0 ){\n        zErr = \"frame specification\";\n      }\n      if( zErr ){\n        sqlite3ErrorMsg(pParse, \n            \"cannot override %s of window: %s\", zErr, pWin->zBase\n        );\n      }else{\n        pWin->pPartition = sqlite3ExprListDup(db, pExist->pPartition, 0);\n        if( pExist->pOrderBy ){\n          assert( pWin->pOrderBy==0 );\n          pWin->pOrderBy = sqlite3ExprListDup(db, pExist->pOrderBy, 0);\n        }\n        sqlite3DbFree(db, pWin->zBase);\n        pWin->zBase = 0;\n      }\n    }\n  }\n}\n\n/*\n** Attach window object pWin to expression p.\n*/\nvoid sqlite3WindowAttach(Parse *pParse, Expr *p, Window *pWin){\n  if( p ){\n    assert( p->op==TK_FUNCTION );\n    assert( pWin );\n    p->y.pWin = pWin;\n    ExprSetProperty(p, EP_WinFunc);\n    pWin->pOwner = p;\n    if( (p->flags & EP_Distinct) && pWin->eFrmType!=TK_FILTER ){\n      sqlite3ErrorMsg(pParse,\n          \"DISTINCT is not supported for window functions\"\n      );\n    }\n  }else{\n    sqlite3WindowDelete(pParse->db, pWin);\n  }\n}\n\n/*\n** Possibly link window pWin into the list at pSel->pWin (window functions\n** to be processed as part of SELECT statement pSel). The window is linked\n** in if either (a) there are no other windows already linked to this\n** SELECT, or (b) the windows already linked use a compatible window frame.\n*/\nvoid sqlite3WindowLink(Select *pSel, Window *pWin){\n  if( pSel!=0\n   && (0==pSel->pWin || 0==sqlite3WindowCompare(0, pSel->pWin, pWin, 0))\n  ){\n    pWin->pNextWin = pSel->pWin;\n    if( pSel->pWin ){\n      pSel->pWin->ppThis = &pWin->pNextWin;\n    }\n    pSel->pWin = pWin;\n    pWin->ppThis = &pSel->pWin;\n  }\n}\n\n/*\n** Return 0 if the two window objects are identical, or non-zero otherwise.\n** Identical window objects can be processed in a single scan.\n*/\nint sqlite3WindowCompare(Parse *pParse, Window *p1, Window *p2, int bFilter){\n  if( NEVER(p1==0) || NEVER(p2==0) ) return 1;\n  if( p1->eFrmType!=p2->eFrmType ) return 1;\n  if( p1->eStart!=p2->eStart ) return 1;\n  if( p1->eEnd!=p2->eEnd ) return 1;\n  if( p1->eExclude!=p2->eExclude ) return 1;\n  if( sqlite3ExprCompare(pParse, p1->pStart, p2->pStart, -1) ) return 1;\n  if( sqlite3ExprCompare(pParse, p1->pEnd, p2->pEnd, -1) ) return 1;\n  if( sqlite3ExprListCompare(p1->pPartition, p2->pPartition, -1) ) return 1;\n  if( sqlite3ExprListCompare(p1->pOrderBy, p2->pOrderBy, -1) ) return 1;\n  if( bFilter ){\n    if( sqlite3ExprCompare(pParse, p1->pFilter, p2->pFilter, -1) ) return 1;\n  }\n  return 0;\n}\n\n\n/*\n** This is called by code in select.c before it calls sqlite3WhereBegin()\n** to begin iterating through the sub-query results. It is used to allocate\n** and initialize registers and cursors used by sqlite3WindowCodeStep().\n*/\nvoid sqlite3WindowCodeInit(Parse *pParse, Window *pMWin){\n  Window *pWin;\n  Vdbe *v = sqlite3GetVdbe(pParse);\n\n  /* Allocate registers to use for PARTITION BY values, if any. Initialize\n  ** said registers to NULL.  */\n  if( pMWin->pPartition ){\n    int nExpr = pMWin->pPartition->nExpr;\n    pMWin->regPart = pParse->nMem+1;\n    pParse->nMem += nExpr;\n    sqlite3VdbeAddOp3(v, OP_Null, 0, pMWin->regPart, pMWin->regPart+nExpr-1);\n  }\n\n  pMWin->regOne = ++pParse->nMem;\n  sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regOne);\n\n  if( pMWin->eExclude ){\n    pMWin->regStartRowid = ++pParse->nMem;\n    pMWin->regEndRowid = ++pParse->nMem;\n    pMWin->csrApp = pParse->nTab++;\n    sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regStartRowid);\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, pMWin->regEndRowid);\n    sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->csrApp, pMWin->iEphCsr);\n    return;\n  }\n\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    FuncDef *p = pWin->pFunc;\n    if( (p->funcFlags & SQLITE_FUNC_MINMAX) && pWin->eStart!=TK_UNBOUNDED ){\n      /* The inline versions of min() and max() require a single ephemeral\n      ** table and 3 registers. The registers are used as follows:\n      **\n      **   regApp+0: slot to copy min()/max() argument to for MakeRecord\n      **   regApp+1: integer value used to ensure keys are unique\n      **   regApp+2: output of MakeRecord\n      */\n      ExprList *pList = pWin->pOwner->x.pList;\n      KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0);\n      pWin->csrApp = pParse->nTab++;\n      pWin->regApp = pParse->nMem+1;\n      pParse->nMem += 3;\n      if( pKeyInfo && pWin->pFunc->zName[1]=='i' ){\n        assert( pKeyInfo->aSortFlags[0]==0 );\n        pKeyInfo->aSortFlags[0] = KEYINFO_ORDER_DESC;\n      }\n      sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pWin->csrApp, 2);\n      sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);\n    }\n    else if( p->zName==nth_valueName || p->zName==first_valueName ){\n      /* Allocate two registers at pWin->regApp. These will be used to\n      ** store the start and end index of the current frame.  */\n      pWin->regApp = pParse->nMem+1;\n      pWin->csrApp = pParse->nTab++;\n      pParse->nMem += 2;\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pWin->csrApp, pMWin->iEphCsr);\n    }\n    else if( p->zName==leadName || p->zName==lagName ){\n      pWin->csrApp = pParse->nTab++;\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pWin->csrApp, pMWin->iEphCsr);\n    }\n  }\n}\n\n#define WINDOW_STARTING_INT  0\n#define WINDOW_ENDING_INT    1\n#define WINDOW_NTH_VALUE_INT 2\n#define WINDOW_STARTING_NUM  3\n#define WINDOW_ENDING_NUM    4\n\n/*\n** A \"PRECEDING <expr>\" (eCond==0) or \"FOLLOWING <expr>\" (eCond==1) or the\n** value of the second argument to nth_value() (eCond==2) has just been\n** evaluated and the result left in register reg. This function generates VM\n** code to check that the value is a non-negative integer and throws an\n** exception if it is not.\n*/\nstatic void windowCheckValue(Parse *pParse, int reg, int eCond){\n  static const char *azErr[] = {\n    \"frame starting offset must be a non-negative integer\",\n    \"frame ending offset must be a non-negative integer\",\n    \"second argument to nth_value must be a positive integer\",\n    \"frame starting offset must be a non-negative number\",\n    \"frame ending offset must be a non-negative number\",\n  };\n  static int aOp[] = { OP_Ge, OP_Ge, OP_Gt, OP_Ge, OP_Ge };\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  int regZero = sqlite3GetTempReg(pParse);\n  assert( eCond>=0 && eCond<ArraySize(azErr) );\n  sqlite3VdbeAddOp2(v, OP_Integer, 0, regZero);\n  if( eCond>=WINDOW_STARTING_NUM ){\n    int regString = sqlite3GetTempReg(pParse);\n    sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, \"\", P4_STATIC);\n    sqlite3VdbeAddOp3(v, OP_Ge, regString, sqlite3VdbeCurrentAddr(v)+2, reg);\n    sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC|SQLITE_JUMPIFNULL);\n    VdbeCoverage(v);\n    assert( eCond==3 || eCond==4 );\n    VdbeCoverageIf(v, eCond==3);\n    VdbeCoverageIf(v, eCond==4);\n  }else{\n    sqlite3VdbeAddOp2(v, OP_MustBeInt, reg, sqlite3VdbeCurrentAddr(v)+2);\n    VdbeCoverage(v);\n    assert( eCond==0 || eCond==1 || eCond==2 );\n    VdbeCoverageIf(v, eCond==0);\n    VdbeCoverageIf(v, eCond==1);\n    VdbeCoverageIf(v, eCond==2);\n  }\n  sqlite3VdbeAddOp3(v, aOp[eCond], regZero, sqlite3VdbeCurrentAddr(v)+2, reg);\n  VdbeCoverageNeverNullIf(v, eCond==0); /* NULL case captured by */\n  VdbeCoverageNeverNullIf(v, eCond==1); /*   the OP_MustBeInt */\n  VdbeCoverageNeverNullIf(v, eCond==2);\n  VdbeCoverageNeverNullIf(v, eCond==3); /* NULL case caught by */\n  VdbeCoverageNeverNullIf(v, eCond==4); /*   the OP_Ge */\n  sqlite3MayAbort(pParse);\n  sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_ERROR, OE_Abort);\n  sqlite3VdbeAppendP4(v, (void*)azErr[eCond], P4_STATIC);\n  sqlite3ReleaseTempReg(pParse, regZero);\n}\n\n/*\n** Return the number of arguments passed to the window-function associated\n** with the object passed as the only argument to this function.\n*/\nstatic int windowArgCount(Window *pWin){\n  ExprList *pList = pWin->pOwner->x.pList;\n  return (pList ? pList->nExpr : 0);\n}\n\ntypedef struct WindowCodeArg WindowCodeArg;\ntypedef struct WindowCsrAndReg WindowCsrAndReg;\n\n/*\n** See comments above struct WindowCodeArg.\n*/\nstruct WindowCsrAndReg {\n  int csr;                        /* Cursor number */\n  int reg;                        /* First in array of peer values */\n};\n\n/*\n** A single instance of this structure is allocated on the stack by \n** sqlite3WindowCodeStep() and a pointer to it passed to the various helper\n** routines. This is to reduce the number of arguments required by each\n** helper function.\n**\n** regArg:\n**   Each window function requires an accumulator register (just as an\n**   ordinary aggregate function does). This variable is set to the first\n**   in an array of accumulator registers - one for each window function\n**   in the WindowCodeArg.pMWin list.\n**\n** eDelete:\n**   The window functions implementation sometimes caches the input rows\n**   that it processes in a temporary table. If it is not zero, this\n**   variable indicates when rows may be removed from the temp table (in\n**   order to reduce memory requirements - it would always be safe just\n**   to leave them there). Possible values for eDelete are:\n**\n**      WINDOW_RETURN_ROW:\n**        An input row can be discarded after it is returned to the caller.\n**\n**      WINDOW_AGGINVERSE:\n**        An input row can be discarded after the window functions xInverse()\n**        callbacks have been invoked in it.\n**\n**      WINDOW_AGGSTEP:\n**        An input row can be discarded after the window functions xStep()\n**        callbacks have been invoked in it.\n**\n** start,current,end\n**   Consider a window-frame similar to the following:\n**\n**     (ORDER BY a, b GROUPS BETWEEN 2 PRECEDING AND 2 FOLLOWING)\n**\n**   The windows functions implmentation caches the input rows in a temp\n**   table, sorted by \"a, b\" (it actually populates the cache lazily, and\n**   aggressively removes rows once they are no longer required, but that's\n**   a mere detail). It keeps three cursors open on the temp table. One\n**   (current) that points to the next row to return to the query engine\n**   once its window function values have been calculated. Another (end)\n**   points to the next row to call the xStep() method of each window function\n**   on (so that it is 2 groups ahead of current). And a third (start) that\n**   points to the next row to call the xInverse() method of each window\n**   function on.\n**\n**   Each cursor (start, current and end) consists of a VDBE cursor\n**   (WindowCsrAndReg.csr) and an array of registers (starting at\n**   WindowCodeArg.reg) that always contains a copy of the peer values \n**   read from the corresponding cursor.\n**\n**   Depending on the window-frame in question, all three cursors may not\n**   be required. In this case both WindowCodeArg.csr and reg are set to\n**   0.\n*/\nstruct WindowCodeArg {\n  Parse *pParse;             /* Parse context */\n  Window *pMWin;             /* First in list of functions being processed */\n  Vdbe *pVdbe;               /* VDBE object */\n  int addrGosub;             /* OP_Gosub to this address to return one row */\n  int regGosub;              /* Register used with OP_Gosub(addrGosub) */\n  int regArg;                /* First in array of accumulator registers */\n  int eDelete;               /* See above */\n\n  WindowCsrAndReg start;\n  WindowCsrAndReg current;\n  WindowCsrAndReg end;\n};\n\n/*\n** Generate VM code to read the window frames peer values from cursor csr into\n** an array of registers starting at reg.\n*/\nstatic void windowReadPeerValues(\n  WindowCodeArg *p,\n  int csr,\n  int reg\n){\n  Window *pMWin = p->pMWin;\n  ExprList *pOrderBy = pMWin->pOrderBy;\n  if( pOrderBy ){\n    Vdbe *v = sqlite3GetVdbe(p->pParse);\n    ExprList *pPart = pMWin->pPartition;\n    int iColOff = pMWin->nBufferCol + (pPart ? pPart->nExpr : 0);\n    int i;\n    for(i=0; i<pOrderBy->nExpr; i++){\n      sqlite3VdbeAddOp3(v, OP_Column, csr, iColOff+i, reg+i);\n    }\n  }\n}\n\n/*\n** Generate VM code to invoke either xStep() (if bInverse is 0) or \n** xInverse (if bInverse is non-zero) for each window function in the \n** linked list starting at pMWin. Or, for built-in window functions\n** that do not use the standard function API, generate the required\n** inline VM code.\n**\n** If argument csr is greater than or equal to 0, then argument reg is\n** the first register in an array of registers guaranteed to be large\n** enough to hold the array of arguments for each function. In this case\n** the arguments are extracted from the current row of csr into the\n** array of registers before invoking OP_AggStep or OP_AggInverse\n**\n** Or, if csr is less than zero, then the array of registers at reg is\n** already populated with all columns from the current row of the sub-query.\n**\n** If argument regPartSize is non-zero, then it is a register containing the\n** number of rows in the current partition.\n*/\nstatic void windowAggStep(\n  WindowCodeArg *p,\n  Window *pMWin,                  /* Linked list of window functions */\n  int csr,                        /* Read arguments from this cursor */\n  int bInverse,                   /* True to invoke xInverse instead of xStep */\n  int reg                         /* Array of registers */\n){\n  Parse *pParse = p->pParse;\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  Window *pWin;\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    FuncDef *pFunc = pWin->pFunc;\n    int regArg;\n    int nArg = pWin->bExprArgs ? 0 : windowArgCount(pWin);\n    int i;\n\n    assert( bInverse==0 || pWin->eStart!=TK_UNBOUNDED );\n\n    /* All OVER clauses in the same window function aggregate step must\n    ** be the same. */\n    assert( pWin==pMWin || sqlite3WindowCompare(pParse,pWin,pMWin,0)==0 );\n\n    for(i=0; i<nArg; i++){\n      if( i!=1 || pFunc->zName!=nth_valueName ){\n        sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+i, reg+i);\n      }else{\n        sqlite3VdbeAddOp3(v, OP_Column, pMWin->iEphCsr, pWin->iArgCol+i, reg+i);\n      }\n    }\n    regArg = reg;\n\n    if( pMWin->regStartRowid==0\n     && (pFunc->funcFlags & SQLITE_FUNC_MINMAX) \n     && (pWin->eStart!=TK_UNBOUNDED)\n    ){\n      int addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regArg);\n      VdbeCoverage(v);\n      if( bInverse==0 ){\n        sqlite3VdbeAddOp2(v, OP_AddImm, pWin->regApp+1, 1);\n        sqlite3VdbeAddOp2(v, OP_SCopy, regArg, pWin->regApp);\n        sqlite3VdbeAddOp3(v, OP_MakeRecord, pWin->regApp, 2, pWin->regApp+2);\n        sqlite3VdbeAddOp2(v, OP_IdxInsert, pWin->csrApp, pWin->regApp+2);\n      }else{\n        sqlite3VdbeAddOp4Int(v, OP_SeekGE, pWin->csrApp, 0, regArg, 1);\n        VdbeCoverageNeverTaken(v);\n        sqlite3VdbeAddOp1(v, OP_Delete, pWin->csrApp);\n        sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);\n      }\n      sqlite3VdbeJumpHere(v, addrIsNull);\n    }else if( pWin->regApp ){\n      assert( pFunc->zName==nth_valueName\n           || pFunc->zName==first_valueName\n      );\n      assert( bInverse==0 || bInverse==1 );\n      sqlite3VdbeAddOp2(v, OP_AddImm, pWin->regApp+1-bInverse, 1);\n    }else if( pFunc->xSFunc!=noopStepFunc ){\n      int addrIf = 0;\n      if( pWin->pFilter ){\n        int regTmp;\n        assert( pWin->bExprArgs || !nArg ||nArg==pWin->pOwner->x.pList->nExpr );\n        assert( pWin->bExprArgs || nArg  ||pWin->pOwner->x.pList==0 );\n        regTmp = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+nArg,regTmp);\n        addrIf = sqlite3VdbeAddOp3(v, OP_IfNot, regTmp, 0, 1);\n        VdbeCoverage(v);\n        sqlite3ReleaseTempReg(pParse, regTmp);\n      }\n      \n      if( pWin->bExprArgs ){\n        int iStart = sqlite3VdbeCurrentAddr(v);\n        VdbeOp *pOp, *pEnd;\n\n        nArg = pWin->pOwner->x.pList->nExpr;\n        regArg = sqlite3GetTempRange(pParse, nArg);\n        sqlite3ExprCodeExprList(pParse, pWin->pOwner->x.pList, regArg, 0, 0);\n\n        pEnd = sqlite3VdbeGetOp(v, -1);\n        for(pOp=sqlite3VdbeGetOp(v, iStart); pOp<=pEnd; pOp++){\n          if( pOp->opcode==OP_Column && pOp->p1==pWin->iEphCsr ){\n            pOp->p1 = csr;\n          }\n        }\n      }\n      if( pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n        CollSeq *pColl;\n        assert( nArg>0 );\n        pColl = sqlite3ExprNNCollSeq(pParse, pWin->pOwner->x.pList->a[0].pExpr);\n        sqlite3VdbeAddOp4(v, OP_CollSeq, 0,0,0, (const char*)pColl, P4_COLLSEQ);\n      }\n      sqlite3VdbeAddOp3(v, bInverse? OP_AggInverse : OP_AggStep, \n                        bInverse, regArg, pWin->regAccum);\n      sqlite3VdbeAppendP4(v, pFunc, P4_FUNCDEF);\n      sqlite3VdbeChangeP5(v, (u8)nArg);\n      if( pWin->bExprArgs ){\n        sqlite3ReleaseTempRange(pParse, regArg, nArg);\n      }\n      if( addrIf ) sqlite3VdbeJumpHere(v, addrIf);\n    }\n  }\n}\n\n/*\n** Values that may be passed as the second argument to windowCodeOp().\n*/\n#define WINDOW_RETURN_ROW 1\n#define WINDOW_AGGINVERSE 2\n#define WINDOW_AGGSTEP    3\n\n/*\n** Generate VM code to invoke either xValue() (bFin==0) or xFinalize()\n** (bFin==1) for each window function in the linked list starting at\n** pMWin. Or, for built-in window-functions that do not use the standard\n** API, generate the equivalent VM code.\n*/\nstatic void windowAggFinal(WindowCodeArg *p, int bFin){\n  Parse *pParse = p->pParse;\n  Window *pMWin = p->pMWin;\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  Window *pWin;\n\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    if( pMWin->regStartRowid==0\n     && (pWin->pFunc->funcFlags & SQLITE_FUNC_MINMAX) \n     && (pWin->eStart!=TK_UNBOUNDED)\n    ){\n      sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);\n      sqlite3VdbeAddOp1(v, OP_Last, pWin->csrApp);\n      VdbeCoverage(v);\n      sqlite3VdbeAddOp3(v, OP_Column, pWin->csrApp, 0, pWin->regResult);\n      sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);\n    }else if( pWin->regApp ){\n      assert( pMWin->regStartRowid==0 );\n    }else{\n      int nArg = windowArgCount(pWin);\n      if( bFin ){\n        sqlite3VdbeAddOp2(v, OP_AggFinal, pWin->regAccum, nArg);\n        sqlite3VdbeAppendP4(v, pWin->pFunc, P4_FUNCDEF);\n        sqlite3VdbeAddOp2(v, OP_Copy, pWin->regAccum, pWin->regResult);\n        sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n      }else{\n        sqlite3VdbeAddOp3(v, OP_AggValue,pWin->regAccum,nArg,pWin->regResult);\n        sqlite3VdbeAppendP4(v, pWin->pFunc, P4_FUNCDEF);\n      }\n    }\n  }\n}\n\n/*\n** Generate code to calculate the current values of all window functions in the\n** p->pMWin list by doing a full scan of the current window frame. Store the\n** results in the Window.regResult registers, ready to return the upper\n** layer.\n*/\nstatic void windowFullScan(WindowCodeArg *p){\n  Window *pWin;\n  Parse *pParse = p->pParse;\n  Window *pMWin = p->pMWin;\n  Vdbe *v = p->pVdbe;\n\n  int regCRowid = 0;              /* Current rowid value */\n  int regCPeer = 0;               /* Current peer values */\n  int regRowid = 0;               /* AggStep rowid value */\n  int regPeer = 0;                /* AggStep peer values */\n\n  int nPeer;\n  int lblNext;\n  int lblBrk;\n  int addrNext;\n  int csr;\n\n  VdbeModuleComment((v, \"windowFullScan begin\"));\n\n  assert( pMWin!=0 );\n  csr = pMWin->csrApp;\n  nPeer = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);\n\n  lblNext = sqlite3VdbeMakeLabel(pParse);\n  lblBrk = sqlite3VdbeMakeLabel(pParse);\n\n  regCRowid = sqlite3GetTempReg(pParse);\n  regRowid = sqlite3GetTempReg(pParse);\n  if( nPeer ){\n    regCPeer = sqlite3GetTempRange(pParse, nPeer);\n    regPeer = sqlite3GetTempRange(pParse, nPeer);\n  }\n\n  sqlite3VdbeAddOp2(v, OP_Rowid, pMWin->iEphCsr, regCRowid);\n  windowReadPeerValues(p, pMWin->iEphCsr, regCPeer);\n\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n  }\n\n  sqlite3VdbeAddOp3(v, OP_SeekGE, csr, lblBrk, pMWin->regStartRowid);\n  VdbeCoverage(v);\n  addrNext = sqlite3VdbeCurrentAddr(v);\n  sqlite3VdbeAddOp2(v, OP_Rowid, csr, regRowid);\n  sqlite3VdbeAddOp3(v, OP_Gt, pMWin->regEndRowid, lblBrk, regRowid);\n  VdbeCoverageNeverNull(v);\n\n  if( pMWin->eExclude==TK_CURRENT ){\n    sqlite3VdbeAddOp3(v, OP_Eq, regCRowid, lblNext, regRowid);\n    VdbeCoverageNeverNull(v);\n  }else if( pMWin->eExclude!=TK_NO ){\n    int addr;\n    int addrEq = 0;\n    KeyInfo *pKeyInfo = 0;\n\n    if( pMWin->pOrderBy ){\n      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pMWin->pOrderBy, 0, 0);\n    }\n    if( pMWin->eExclude==TK_TIES ){\n      addrEq = sqlite3VdbeAddOp3(v, OP_Eq, regCRowid, 0, regRowid);\n      VdbeCoverageNeverNull(v);\n    }\n    if( pKeyInfo ){\n      windowReadPeerValues(p, csr, regPeer);\n      sqlite3VdbeAddOp3(v, OP_Compare, regPeer, regCPeer, nPeer);\n      sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);\n      addr = sqlite3VdbeCurrentAddr(v)+1;\n      sqlite3VdbeAddOp3(v, OP_Jump, addr, lblNext, addr);\n      VdbeCoverageEqNe(v);\n    }else{\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, lblNext);\n    }\n    if( addrEq ) sqlite3VdbeJumpHere(v, addrEq);\n  }\n\n  windowAggStep(p, pMWin, csr, 0, p->regArg);\n\n  sqlite3VdbeResolveLabel(v, lblNext);\n  sqlite3VdbeAddOp2(v, OP_Next, csr, addrNext);\n  VdbeCoverage(v);\n  sqlite3VdbeJumpHere(v, addrNext-1);\n  sqlite3VdbeJumpHere(v, addrNext+1);\n  sqlite3ReleaseTempReg(pParse, regRowid);\n  sqlite3ReleaseTempReg(pParse, regCRowid);\n  if( nPeer ){\n    sqlite3ReleaseTempRange(pParse, regPeer, nPeer);\n    sqlite3ReleaseTempRange(pParse, regCPeer, nPeer);\n  }\n\n  windowAggFinal(p, 1);\n  VdbeModuleComment((v, \"windowFullScan end\"));\n}\n\n/*\n** Invoke the sub-routine at regGosub (generated by code in select.c) to\n** return the current row of Window.iEphCsr. If all window functions are\n** aggregate window functions that use the standard API, a single\n** OP_Gosub instruction is all that this routine generates. Extra VM code\n** for per-row processing is only generated for the following built-in window\n** functions:\n**\n**   nth_value()\n**   first_value()\n**   lag()\n**   lead()\n*/\nstatic void windowReturnOneRow(WindowCodeArg *p){\n  Window *pMWin = p->pMWin;\n  Vdbe *v = p->pVdbe;\n\n  if( pMWin->regStartRowid ){\n    windowFullScan(p);\n  }else{\n    Parse *pParse = p->pParse;\n    Window *pWin;\n\n    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n      FuncDef *pFunc = pWin->pFunc;\n      if( pFunc->zName==nth_valueName\n       || pFunc->zName==first_valueName\n      ){\n        int csr = pWin->csrApp;\n        int lbl = sqlite3VdbeMakeLabel(pParse);\n        int tmpReg = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);\n  \n        if( pFunc->zName==nth_valueName ){\n          sqlite3VdbeAddOp3(v, OP_Column,pMWin->iEphCsr,pWin->iArgCol+1,tmpReg);\n          windowCheckValue(pParse, tmpReg, 2);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Integer, 1, tmpReg);\n        }\n        sqlite3VdbeAddOp3(v, OP_Add, tmpReg, pWin->regApp, tmpReg);\n        sqlite3VdbeAddOp3(v, OP_Gt, pWin->regApp+1, lbl, tmpReg);\n        VdbeCoverageNeverNull(v);\n        sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, 0, tmpReg);\n        VdbeCoverageNeverTaken(v);\n        sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);\n        sqlite3VdbeResolveLabel(v, lbl);\n        sqlite3ReleaseTempReg(pParse, tmpReg);\n      }\n      else if( pFunc->zName==leadName || pFunc->zName==lagName ){\n        int nArg = pWin->pOwner->x.pList->nExpr;\n        int csr = pWin->csrApp;\n        int lbl = sqlite3VdbeMakeLabel(pParse);\n        int tmpReg = sqlite3GetTempReg(pParse);\n        int iEph = pMWin->iEphCsr;\n  \n        if( nArg<3 ){\n          sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);\n        }else{\n          sqlite3VdbeAddOp3(v, OP_Column, iEph,pWin->iArgCol+2,pWin->regResult);\n        }\n        sqlite3VdbeAddOp2(v, OP_Rowid, iEph, tmpReg);\n        if( nArg<2 ){\n          int val = (pFunc->zName==leadName ? 1 : -1);\n          sqlite3VdbeAddOp2(v, OP_AddImm, tmpReg, val);\n        }else{\n          int op = (pFunc->zName==leadName ? OP_Add : OP_Subtract);\n          int tmpReg2 = sqlite3GetTempReg(pParse);\n          sqlite3VdbeAddOp3(v, OP_Column, iEph, pWin->iArgCol+1, tmpReg2);\n          sqlite3VdbeAddOp3(v, op, tmpReg2, tmpReg, tmpReg);\n          sqlite3ReleaseTempReg(pParse, tmpReg2);\n        }\n  \n        sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, lbl, tmpReg);\n        VdbeCoverage(v);\n        sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);\n        sqlite3VdbeResolveLabel(v, lbl);\n        sqlite3ReleaseTempReg(pParse, tmpReg);\n      }\n    }\n  }\n  sqlite3VdbeAddOp2(v, OP_Gosub, p->regGosub, p->addrGosub);\n}\n\n/*\n** Generate code to set the accumulator register for each window function\n** in the linked list passed as the second argument to NULL. And perform\n** any equivalent initialization required by any built-in window functions\n** in the list.\n*/\nstatic int windowInitAccum(Parse *pParse, Window *pMWin){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  int regArg;\n  int nArg = 0;\n  Window *pWin;\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    FuncDef *pFunc = pWin->pFunc;\n    sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n    nArg = MAX(nArg, windowArgCount(pWin));\n    if( pMWin->regStartRowid==0 ){\n      if( pFunc->zName==nth_valueName || pFunc->zName==first_valueName ){\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp);\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);\n      }\n\n      if( (pFunc->funcFlags & SQLITE_FUNC_MINMAX) && pWin->csrApp ){\n        assert( pWin->eStart!=TK_UNBOUNDED );\n        sqlite3VdbeAddOp1(v, OP_ResetSorter, pWin->csrApp);\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);\n      }\n    }\n  }\n  regArg = pParse->nMem+1;\n  pParse->nMem += nArg;\n  return regArg;\n}\n\n/* \n** Return true if the current frame should be cached in the ephemeral table,\n** even if there are no xInverse() calls required.\n*/\nstatic int windowCacheFrame(Window *pMWin){\n  Window *pWin;\n  if( pMWin->regStartRowid ) return 1;\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    FuncDef *pFunc = pWin->pFunc;\n    if( (pFunc->zName==nth_valueName)\n     || (pFunc->zName==first_valueName)\n     || (pFunc->zName==leadName)\n     || (pFunc->zName==lagName)\n    ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** regOld and regNew are each the first register in an array of size\n** pOrderBy->nExpr. This function generates code to compare the two\n** arrays of registers using the collation sequences and other comparison\n** parameters specified by pOrderBy. \n**\n** If the two arrays are not equal, the contents of regNew is copied to \n** regOld and control falls through. Otherwise, if the contents of the arrays\n** are equal, an OP_Goto is executed. The address of the OP_Goto is returned.\n*/\nstatic void windowIfNewPeer(\n  Parse *pParse,\n  ExprList *pOrderBy,\n  int regNew,                     /* First in array of new values */\n  int regOld,                     /* First in array of old values */\n  int addr                        /* Jump here */\n){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  if( pOrderBy ){\n    int nVal = pOrderBy->nExpr;\n    KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOrderBy, 0, 0);\n    sqlite3VdbeAddOp3(v, OP_Compare, regOld, regNew, nVal);\n    sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);\n    sqlite3VdbeAddOp3(v, OP_Jump, \n      sqlite3VdbeCurrentAddr(v)+1, addr, sqlite3VdbeCurrentAddr(v)+1\n    );\n    VdbeCoverageEqNe(v);\n    sqlite3VdbeAddOp3(v, OP_Copy, regNew, regOld, nVal-1);\n  }else{\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addr);\n  }\n}\n\n/*\n** This function is called as part of generating VM programs for RANGE\n** offset PRECEDING/FOLLOWING frame boundaries. Assuming \"ASC\" order for\n** the ORDER BY term in the window, and that argument op is OP_Ge, it generates\n** code equivalent to:\n**\n**   if( csr1.peerVal + regVal >= csr2.peerVal ) goto lbl;\n**\n** The value of parameter op may also be OP_Gt or OP_Le. In these cases the\n** operator in the above pseudo-code is replaced with \">\" or \"<=\", respectively.\n**\n** If the sort-order for the ORDER BY term in the window is DESC, then the\n** comparison is reversed. Instead of adding regVal to csr1.peerVal, it is\n** subtracted. And the comparison operator is inverted to - \">=\" becomes \"<=\",\n** \">\" becomes \"<\", and so on. So, with DESC sort order, if the argument op\n** is OP_Ge, the generated code is equivalent to:\n**\n**   if( csr1.peerVal - regVal <= csr2.peerVal ) goto lbl;\n**\n** A special type of arithmetic is used such that if csr1.peerVal is not\n** a numeric type (real or integer), then the result of the addition addition\n** or subtraction is a a copy of csr1.peerVal.\n*/\nstatic void windowCodeRangeTest(\n  WindowCodeArg *p, \n  int op,                         /* OP_Ge, OP_Gt, or OP_Le */\n  int csr1,                       /* Cursor number for cursor 1 */\n  int regVal,                     /* Register containing non-negative number */\n  int csr2,                       /* Cursor number for cursor 2 */\n  int lbl                         /* Jump destination if condition is true */\n){\n  Parse *pParse = p->pParse;\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  ExprList *pOrderBy = p->pMWin->pOrderBy;  /* ORDER BY clause for window */\n  int reg1 = sqlite3GetTempReg(pParse);     /* Reg. for csr1.peerVal+regVal */\n  int reg2 = sqlite3GetTempReg(pParse);     /* Reg. for csr2.peerVal */\n  int regString = ++pParse->nMem;           /* Reg. for constant value '' */\n  int arith = OP_Add;                       /* OP_Add or OP_Subtract */\n  int addrGe;                               /* Jump destination */\n\n  assert( op==OP_Ge || op==OP_Gt || op==OP_Le );\n  assert( pOrderBy && pOrderBy->nExpr==1 );\n  if( pOrderBy->a[0].sortFlags & KEYINFO_ORDER_DESC ){\n    switch( op ){\n      case OP_Ge: op = OP_Le; break;\n      case OP_Gt: op = OP_Lt; break;\n      default: assert( op==OP_Le ); op = OP_Ge; break;\n    }\n    arith = OP_Subtract;\n  }\n\n  /* Read the peer-value from each cursor into a register */\n  windowReadPeerValues(p, csr1, reg1);\n  windowReadPeerValues(p, csr2, reg2);\n\n  VdbeModuleComment((v, \"CodeRangeTest: if( R%d %s R%d %s R%d ) goto lbl\",\n      reg1, (arith==OP_Add ? \"+\" : \"-\"), regVal,\n      ((op==OP_Ge) ? \">=\" : (op==OP_Le) ? \"<=\" : (op==OP_Gt) ? \">\" : \"<\"), reg2\n  ));\n\n  /* Register reg1 currently contains csr1.peerVal (the peer-value from csr1).\n  ** This block adds (or subtracts for DESC) the numeric value in regVal\n  ** from it. Or, if reg1 is not numeric (it is a NULL, a text value or a blob),\n  ** then leave reg1 as it is. In pseudo-code, this is implemented as:\n  **\n  **   if( reg1>='' ) goto addrGe;\n  **   reg1 = reg1 +/- regVal\n  **   addrGe:\n  **\n  ** Since all strings and blobs are greater-than-or-equal-to an empty string,\n  ** the add/subtract is skipped for these, as required. If reg1 is a NULL,\n  ** then the arithmetic is performed, but since adding or subtracting from\n  ** NULL is always NULL anyway, this case is handled as required too.  */\n  sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, \"\", P4_STATIC);\n  addrGe = sqlite3VdbeAddOp3(v, OP_Ge, regString, 0, reg1);\n  VdbeCoverage(v);\n  sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1);\n  sqlite3VdbeJumpHere(v, addrGe);\n\n  /* If the BIGNULL flag is set for the ORDER BY, then it is required to \n  ** consider NULL values to be larger than all other values, instead of \n  ** the usual smaller. The VDBE opcodes OP_Ge and so on do not handle this\n  ** (and adding that capability causes a performance regression), so\n  ** instead if the BIGNULL flag is set then cases where either reg1 or\n  ** reg2 are NULL are handled separately in the following block. The code\n  ** generated is equivalent to:\n  **\n  **   if( reg1 IS NULL ){\n  **     if( op==OP_Ge ) goto lbl;\n  **     if( op==OP_Gt && reg2 IS NOT NULL ) goto lbl;\n  **     if( op==OP_Le && reg2 IS NULL ) goto lbl;\n  **   }else if( reg2 IS NULL ){\n  **     if( op==OP_Le ) goto lbl;\n  **   }\n  **\n  ** Additionally, if either reg1 or reg2 are NULL but the jump to lbl is \n  ** not taken, control jumps over the comparison operator coded below this\n  ** block.  */\n  if( pOrderBy->a[0].sortFlags & KEYINFO_ORDER_BIGNULL ){\n    /* This block runs if reg1 contains a NULL. */\n    int addr = sqlite3VdbeAddOp1(v, OP_NotNull, reg1); VdbeCoverage(v);\n    switch( op ){\n      case OP_Ge: \n        sqlite3VdbeAddOp2(v, OP_Goto, 0, lbl); \n        break;\n      case OP_Gt: \n        sqlite3VdbeAddOp2(v, OP_NotNull, reg2, lbl); \n        VdbeCoverage(v); \n        break;\n      case OP_Le: \n        sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl); \n        VdbeCoverage(v); \n        break;\n      default: assert( op==OP_Lt ); /* no-op */ break;\n    }\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, sqlite3VdbeCurrentAddr(v)+3);\n\n    /* This block runs if reg1 is not NULL, but reg2 is. */\n    sqlite3VdbeJumpHere(v, addr);\n    sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl); VdbeCoverage(v);\n    if( op==OP_Gt || op==OP_Ge ){\n      sqlite3VdbeChangeP2(v, -1, sqlite3VdbeCurrentAddr(v)+1);\n    }\n  }\n\n  /* Compare registers reg2 and reg1, taking the jump if required. Note that\n  ** control skips over this test if the BIGNULL flag is set and either\n  ** reg1 or reg2 contain a NULL value.  */\n  sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); VdbeCoverage(v);\n  sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);\n\n  assert( op==OP_Ge || op==OP_Gt || op==OP_Lt || op==OP_Le );\n  testcase(op==OP_Ge); VdbeCoverageIf(v, op==OP_Ge);\n  testcase(op==OP_Lt); VdbeCoverageIf(v, op==OP_Lt);\n  testcase(op==OP_Le); VdbeCoverageIf(v, op==OP_Le);\n  testcase(op==OP_Gt); VdbeCoverageIf(v, op==OP_Gt);\n  sqlite3ReleaseTempReg(pParse, reg1);\n  sqlite3ReleaseTempReg(pParse, reg2);\n\n  VdbeModuleComment((v, \"CodeRangeTest: end\"));\n}\n\n/*\n** Helper function for sqlite3WindowCodeStep(). Each call to this function\n** generates VM code for a single RETURN_ROW, AGGSTEP or AGGINVERSE \n** operation. Refer to the header comment for sqlite3WindowCodeStep() for\n** details.\n*/\nstatic int windowCodeOp(\n WindowCodeArg *p,                /* Context object */\n int op,                          /* WINDOW_RETURN_ROW, AGGSTEP or AGGINVERSE */\n int regCountdown,                /* Register for OP_IfPos countdown */\n int jumpOnEof                    /* Jump here if stepped cursor reaches EOF */\n){\n  int csr, reg;\n  Parse *pParse = p->pParse;\n  Window *pMWin = p->pMWin;\n  int ret = 0;\n  Vdbe *v = p->pVdbe;\n  int addrContinue = 0;\n  int bPeer = (pMWin->eFrmType!=TK_ROWS);\n\n  int lblDone = sqlite3VdbeMakeLabel(pParse);\n  int addrNextRange = 0;\n\n  /* Special case - WINDOW_AGGINVERSE is always a no-op if the frame\n  ** starts with UNBOUNDED PRECEDING. */\n  if( op==WINDOW_AGGINVERSE && pMWin->eStart==TK_UNBOUNDED ){\n    assert( regCountdown==0 && jumpOnEof==0 );\n    return 0;\n  }\n\n  if( regCountdown>0 ){\n    if( pMWin->eFrmType==TK_RANGE ){\n      addrNextRange = sqlite3VdbeCurrentAddr(v);\n      assert( op==WINDOW_AGGINVERSE || op==WINDOW_AGGSTEP );\n      if( op==WINDOW_AGGINVERSE ){\n        if( pMWin->eStart==TK_FOLLOWING ){\n          windowCodeRangeTest(\n              p, OP_Le, p->current.csr, regCountdown, p->start.csr, lblDone\n          );\n        }else{\n          windowCodeRangeTest(\n              p, OP_Ge, p->start.csr, regCountdown, p->current.csr, lblDone\n          );\n        }\n      }else{\n        windowCodeRangeTest(\n            p, OP_Gt, p->end.csr, regCountdown, p->current.csr, lblDone\n        );\n      }\n    }else{\n      sqlite3VdbeAddOp3(v, OP_IfPos, regCountdown, lblDone, 1);\n      VdbeCoverage(v);\n    }\n  }\n\n  if( op==WINDOW_RETURN_ROW && pMWin->regStartRowid==0 ){\n    windowAggFinal(p, 0);\n  }\n  addrContinue = sqlite3VdbeCurrentAddr(v);\n\n  /* If this is a (RANGE BETWEEN a FOLLOWING AND b FOLLOWING) or\n  ** (RANGE BETWEEN b PRECEDING AND a PRECEDING) frame, ensure the \n  ** start cursor does not advance past the end cursor within the \n  ** temporary table. It otherwise might, if (a>b).  */\n  if( pMWin->eStart==pMWin->eEnd && regCountdown\n   && pMWin->eFrmType==TK_RANGE && op==WINDOW_AGGINVERSE\n  ){\n    int regRowid1 = sqlite3GetTempReg(pParse);\n    int regRowid2 = sqlite3GetTempReg(pParse);\n    sqlite3VdbeAddOp2(v, OP_Rowid, p->start.csr, regRowid1);\n    sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid2);\n    sqlite3VdbeAddOp3(v, OP_Ge, regRowid2, lblDone, regRowid1);\n    VdbeCoverage(v);\n    sqlite3ReleaseTempReg(pParse, regRowid1);\n    sqlite3ReleaseTempReg(pParse, regRowid2);\n    assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING );\n  }\n\n  switch( op ){\n    case WINDOW_RETURN_ROW:\n      csr = p->current.csr;\n      reg = p->current.reg;\n      windowReturnOneRow(p);\n      break;\n\n    case WINDOW_AGGINVERSE:\n      csr = p->start.csr;\n      reg = p->start.reg;\n      if( pMWin->regStartRowid ){\n        assert( pMWin->regEndRowid );\n        sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regStartRowid, 1);\n      }else{\n        windowAggStep(p, pMWin, csr, 1, p->regArg);\n      }\n      break;\n\n    default:\n      assert( op==WINDOW_AGGSTEP );\n      csr = p->end.csr;\n      reg = p->end.reg;\n      if( pMWin->regStartRowid ){\n        assert( pMWin->regEndRowid );\n        sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);\n      }else{\n        windowAggStep(p, pMWin, csr, 0, p->regArg);\n      }\n      break;\n  }\n\n  if( op==p->eDelete ){\n    sqlite3VdbeAddOp1(v, OP_Delete, csr);\n    sqlite3VdbeChangeP5(v, OPFLAG_SAVEPOSITION);\n  }\n\n  if( jumpOnEof ){\n    sqlite3VdbeAddOp2(v, OP_Next, csr, sqlite3VdbeCurrentAddr(v)+2);\n    VdbeCoverage(v);\n    ret = sqlite3VdbeAddOp0(v, OP_Goto);\n  }else{\n    sqlite3VdbeAddOp2(v, OP_Next, csr, sqlite3VdbeCurrentAddr(v)+1+bPeer);\n    VdbeCoverage(v);\n    if( bPeer ){\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, lblDone);\n    }\n  }\n\n  if( bPeer ){\n    int nReg = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);\n    int regTmp = (nReg ? sqlite3GetTempRange(pParse, nReg) : 0);\n    windowReadPeerValues(p, csr, regTmp);\n    windowIfNewPeer(pParse, pMWin->pOrderBy, regTmp, reg, addrContinue);\n    sqlite3ReleaseTempRange(pParse, regTmp, nReg);\n  }\n\n  if( addrNextRange ){\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrNextRange);\n  }\n  sqlite3VdbeResolveLabel(v, lblDone);\n  return ret;\n}\n\n\n/*\n** Allocate and return a duplicate of the Window object indicated by the\n** third argument. Set the Window.pOwner field of the new object to\n** pOwner.\n*/\nWindow *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){\n  Window *pNew = 0;\n  if( ALWAYS(p) ){\n    pNew = sqlite3DbMallocZero(db, sizeof(Window));\n    if( pNew ){\n      pNew->zName = sqlite3DbStrDup(db, p->zName);\n      pNew->zBase = sqlite3DbStrDup(db, p->zBase);\n      pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);\n      pNew->pFunc = p->pFunc;\n      pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);\n      pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);\n      pNew->eFrmType = p->eFrmType;\n      pNew->eEnd = p->eEnd;\n      pNew->eStart = p->eStart;\n      pNew->eExclude = p->eExclude;\n      pNew->regResult = p->regResult;\n      pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);\n      pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);\n      pNew->pOwner = pOwner;\n      pNew->bImplicitFrame = p->bImplicitFrame;\n    }\n  }\n  return pNew;\n}\n\n/*\n** Return a copy of the linked list of Window objects passed as the\n** second argument.\n*/\nWindow *sqlite3WindowListDup(sqlite3 *db, Window *p){\n  Window *pWin;\n  Window *pRet = 0;\n  Window **pp = &pRet;\n\n  for(pWin=p; pWin; pWin=pWin->pNextWin){\n    *pp = sqlite3WindowDup(db, 0, pWin);\n    if( *pp==0 ) break;\n    pp = &((*pp)->pNextWin);\n  }\n\n  return pRet;\n}\n\n/*\n** Return true if it can be determined at compile time that expression \n** pExpr evaluates to a value that, when cast to an integer, is greater \n** than zero. False otherwise.\n**\n** If an OOM error occurs, this function sets the Parse.db.mallocFailed \n** flag and returns zero.\n*/\nstatic int windowExprGtZero(Parse *pParse, Expr *pExpr){\n  int ret = 0;\n  sqlite3 *db = pParse->db;\n  sqlite3_value *pVal = 0;\n  sqlite3ValueFromExpr(db, pExpr, db->enc, SQLITE_AFF_NUMERIC, &pVal);\n  if( pVal && sqlite3_value_int(pVal)>0 ){\n    ret = 1;\n  }\n  sqlite3ValueFree(pVal);\n  return ret;\n}\n\n/*\n** sqlite3WhereBegin() has already been called for the SELECT statement \n** passed as the second argument when this function is invoked. It generates\n** code to populate the Window.regResult register for each window function \n** and invoke the sub-routine at instruction addrGosub once for each row.\n** sqlite3WhereEnd() is always called before returning. \n**\n** This function handles several different types of window frames, which\n** require slightly different processing. The following pseudo code is\n** used to implement window frames of the form:\n**\n**   ROWS BETWEEN <expr1> PRECEDING AND <expr2> FOLLOWING\n**\n** Other window frame types use variants of the following:\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**       if( new partition ){\n**         Gosub flush\n**       }\n**       Insert new row into eph table.\n**       \n**       if( first row of partition ){\n**         // Rewind three cursors, all open on the eph table.\n**         Rewind(csrEnd);\n**         Rewind(csrStart);\n**         Rewind(csrCurrent);\n**       \n**         regEnd = <expr2>          // FOLLOWING expression\n**         regStart = <expr1>        // PRECEDING expression\n**       }else{\n**         // First time this branch is taken, the eph table contains two \n**         // rows. The first row in the partition, which all three cursors\n**         // currently point to, and the following row.\n**         AGGSTEP\n**         if( (regEnd--)<=0 ){\n**           RETURN_ROW\n**           if( (regStart--)<=0 ){\n**             AGGINVERSE\n**           }\n**         }\n**       }\n**     }\n**     flush:\n**       AGGSTEP\n**       while( 1 ){\n**         RETURN ROW\n**         if( csrCurrent is EOF ) break;\n**         if( (regStart--)<=0 ){\n**           AggInverse(csrStart)\n**           Next(csrStart)\n**         }\n**       }\n**\n** The pseudo-code above uses the following shorthand:\n**\n**   AGGSTEP:    invoke the aggregate xStep() function for each window function\n**               with arguments read from the current row of cursor csrEnd, then\n**               step cursor csrEnd forward one row (i.e. sqlite3BtreeNext()).\n**\n**   RETURN_ROW: return a row to the caller based on the contents of the \n**               current row of csrCurrent and the current state of all \n**               aggregates. Then step cursor csrCurrent forward one row.\n**\n**   AGGINVERSE: invoke the aggregate xInverse() function for each window \n**               functions with arguments read from the current row of cursor\n**               csrStart. Then step csrStart forward one row.\n**\n** There are two other ROWS window frames that are handled significantly\n** differently from the above - \"BETWEEN <expr> PRECEDING AND <expr> PRECEDING\"\n** and \"BETWEEN <expr> FOLLOWING AND <expr> FOLLOWING\". These are special \n** cases because they change the order in which the three cursors (csrStart,\n** csrCurrent and csrEnd) iterate through the ephemeral table. Cases that\n** use UNBOUNDED or CURRENT ROW are much simpler variations on one of these\n** three.\n**\n**   ROWS BETWEEN <expr1> PRECEDING AND <expr2> PRECEDING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**       if( new partition ){\n**         Gosub flush\n**       }\n**       Insert new row into eph table.\n**       if( first row of partition ){\n**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**         regEnd = <expr2>\n**         regStart = <expr1>\n**       }else{\n**         if( (regEnd--)<=0 ){\n**           AGGSTEP\n**         }\n**         RETURN_ROW\n**         if( (regStart--)<=0 ){\n**           AGGINVERSE\n**         }\n**       }\n**     }\n**     flush:\n**       if( (regEnd--)<=0 ){\n**         AGGSTEP\n**       }\n**       RETURN_ROW\n**\n**\n**   ROWS BETWEEN <expr1> FOLLOWING AND <expr2> FOLLOWING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**     if( new partition ){\n**       Gosub flush\n**     }\n**     Insert new row into eph table.\n**     if( first row of partition ){\n**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**       regEnd = <expr2>\n**       regStart = regEnd - <expr1>\n**     }else{\n**       AGGSTEP\n**       if( (regEnd--)<=0 ){\n**         RETURN_ROW\n**       }\n**       if( (regStart--)<=0 ){\n**         AGGINVERSE\n**       }\n**     }\n**   }\n**   flush:\n**     AGGSTEP\n**     while( 1 ){\n**       if( (regEnd--)<=0 ){\n**         RETURN_ROW\n**         if( eof ) break;\n**       }\n**       if( (regStart--)<=0 ){\n**         AGGINVERSE\n**         if( eof ) break\n**       }\n**     }\n**     while( !eof csrCurrent ){\n**       RETURN_ROW\n**     }\n**\n** For the most part, the patterns above are adapted to support UNBOUNDED by\n** assuming that it is equivalent to \"infinity PRECEDING/FOLLOWING\" and\n** CURRENT ROW by assuming that it is equivilent to \"0 PRECEDING/FOLLOWING\".\n** This is optimized of course - branches that will never be taken and\n** conditions that are always true are omitted from the VM code. The only\n** exceptional case is:\n**\n**   ROWS BETWEEN <expr1> FOLLOWING AND UNBOUNDED FOLLOWING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**     if( new partition ){\n**       Gosub flush\n**     }\n**     Insert new row into eph table.\n**     if( first row of partition ){\n**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**       regStart = <expr1>\n**     }else{\n**       AGGSTEP\n**     }\n**   }\n**   flush:\n**     AGGSTEP\n**     while( 1 ){\n**       if( (regStart--)<=0 ){\n**         AGGINVERSE\n**         if( eof ) break\n**       }\n**       RETURN_ROW\n**     }\n**     while( !eof csrCurrent ){\n**       RETURN_ROW\n**     }\n**\n** Also requiring special handling are the cases:\n**\n**   ROWS BETWEEN <expr1> PRECEDING AND <expr2> PRECEDING\n**   ROWS BETWEEN <expr1> FOLLOWING AND <expr2> FOLLOWING\n**\n** when (expr1 < expr2). This is detected at runtime, not by this function.\n** To handle this case, the pseudo-code programs depicted above are modified\n** slightly to be:\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**     if( new partition ){\n**       Gosub flush\n**     }\n**     Insert new row into eph table.\n**     if( first row of partition ){\n**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**       regEnd = <expr2>\n**       regStart = <expr1>\n**       if( regEnd < regStart ){\n**         RETURN_ROW\n**         delete eph table contents\n**         continue\n**       }\n**     ...\n**\n** The new \"continue\" statement in the above jumps to the next iteration\n** of the outer loop - the one started by sqlite3WhereBegin().\n**\n** The various GROUPS cases are implemented using the same patterns as\n** ROWS. The VM code is modified slightly so that:\n**\n**   1. The else branch in the main loop is only taken if the row just\n**      added to the ephemeral table is the start of a new group. In\n**      other words, it becomes:\n**\n**         ... loop started by sqlite3WhereBegin() ...\n**         if( new partition ){\n**           Gosub flush\n**         }\n**         Insert new row into eph table.\n**         if( first row of partition ){\n**           Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**           regEnd = <expr2>\n**           regStart = <expr1>\n**         }else if( new group ){\n**           ... \n**         }\n**       }\n**\n**   2. Instead of processing a single row, each RETURN_ROW, AGGSTEP or \n**      AGGINVERSE step processes the current row of the relevant cursor and\n**      all subsequent rows belonging to the same group.\n**\n** RANGE window frames are a little different again. As for GROUPS, the \n** main loop runs once per group only. And RETURN_ROW, AGGSTEP and AGGINVERSE\n** deal in groups instead of rows. As for ROWS and GROUPS, there are three\n** basic cases:\n**\n**   RANGE BETWEEN <expr1> PRECEDING AND <expr2> FOLLOWING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**       if( new partition ){\n**         Gosub flush\n**       }\n**       Insert new row into eph table.\n**       if( first row of partition ){\n**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**         regEnd = <expr2>\n**         regStart = <expr1>\n**       }else{\n**         AGGSTEP\n**         while( (csrCurrent.key + regEnd) < csrEnd.key ){\n**           RETURN_ROW\n**           while( csrStart.key + regStart) < csrCurrent.key ){\n**             AGGINVERSE\n**           }\n**         }\n**       }\n**     }\n**     flush:\n**       AGGSTEP\n**       while( 1 ){\n**         RETURN ROW\n**         if( csrCurrent is EOF ) break;\n**           while( csrStart.key + regStart) < csrCurrent.key ){\n**             AGGINVERSE\n**           }\n**         }\n**       }\n**\n** In the above notation, \"csr.key\" means the current value of the ORDER BY \n** expression (there is only ever 1 for a RANGE that uses an <expr> FOLLOWING\n** or <expr PRECEDING) read from cursor csr.\n**\n**   RANGE BETWEEN <expr1> PRECEDING AND <expr2> PRECEDING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**       if( new partition ){\n**         Gosub flush\n**       }\n**       Insert new row into eph table.\n**       if( first row of partition ){\n**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**         regEnd = <expr2>\n**         regStart = <expr1>\n**       }else{\n**         while( (csrEnd.key + regEnd) <= csrCurrent.key ){\n**           AGGSTEP\n**         }\n**         while( (csrStart.key + regStart) < csrCurrent.key ){\n**           AGGINVERSE\n**         }\n**         RETURN_ROW\n**       }\n**     }\n**     flush:\n**       while( (csrEnd.key + regEnd) <= csrCurrent.key ){\n**         AGGSTEP\n**       }\n**       while( (csrStart.key + regStart) < csrCurrent.key ){\n**         AGGINVERSE\n**       }\n**       RETURN_ROW\n**\n**   RANGE BETWEEN <expr1> FOLLOWING AND <expr2> FOLLOWING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**       if( new partition ){\n**         Gosub flush\n**       }\n**       Insert new row into eph table.\n**       if( first row of partition ){\n**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**         regEnd = <expr2>\n**         regStart = <expr1>\n**       }else{\n**         AGGSTEP\n**         while( (csrCurrent.key + regEnd) < csrEnd.key ){\n**           while( (csrCurrent.key + regStart) > csrStart.key ){\n**             AGGINVERSE\n**           }\n**           RETURN_ROW\n**         }\n**       }\n**     }\n**     flush:\n**       AGGSTEP\n**       while( 1 ){\n**         while( (csrCurrent.key + regStart) > csrStart.key ){\n**           AGGINVERSE\n**           if( eof ) break \"while( 1 )\" loop.\n**         }\n**         RETURN_ROW\n**       }\n**       while( !eof csrCurrent ){\n**         RETURN_ROW\n**       }\n**\n** The text above leaves out many details. Refer to the code and comments\n** below for a more complete picture.\n*/\nvoid sqlite3WindowCodeStep(\n  Parse *pParse,                  /* Parse context */\n  Select *p,                      /* Rewritten SELECT statement */\n  WhereInfo *pWInfo,              /* Context returned by sqlite3WhereBegin() */\n  int regGosub,                   /* Register for OP_Gosub */\n  int addrGosub                   /* OP_Gosub here to return each row */\n){\n  Window *pMWin = p->pWin;\n  ExprList *pOrderBy = pMWin->pOrderBy;\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  int csrWrite;                   /* Cursor used to write to eph. table */\n  int csrInput = p->pSrc->a[0].iCursor;     /* Cursor of sub-select */\n  int nInput = p->pSrc->a[0].pTab->nCol;    /* Number of cols returned by sub */\n  int iInput;                               /* To iterate through sub cols */\n  int addrNe;                     /* Address of OP_Ne */\n  int addrGosubFlush = 0;         /* Address of OP_Gosub to flush: */\n  int addrInteger = 0;            /* Address of OP_Integer */\n  int addrEmpty;                  /* Address of OP_Rewind in flush: */\n  int regNew;                     /* Array of registers holding new input row */\n  int regRecord;                  /* regNew array in record form */\n  int regRowid;                   /* Rowid for regRecord in eph table */\n  int regNewPeer = 0;             /* Peer values for new row (part of regNew) */\n  int regPeer = 0;                /* Peer values for current row */\n  int regFlushPart = 0;           /* Register for \"Gosub flush_partition\" */\n  WindowCodeArg s;                /* Context object for sub-routines */\n  int lblWhereEnd;                /* Label just before sqlite3WhereEnd() code */\n  int regStart = 0;               /* Value of <expr> PRECEDING */\n  int regEnd = 0;                 /* Value of <expr> FOLLOWING */\n\n  assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_CURRENT \n       || pMWin->eStart==TK_FOLLOWING || pMWin->eStart==TK_UNBOUNDED \n  );\n  assert( pMWin->eEnd==TK_FOLLOWING || pMWin->eEnd==TK_CURRENT \n       || pMWin->eEnd==TK_UNBOUNDED || pMWin->eEnd==TK_PRECEDING \n  );\n  assert( pMWin->eExclude==0 || pMWin->eExclude==TK_CURRENT\n       || pMWin->eExclude==TK_GROUP || pMWin->eExclude==TK_TIES\n       || pMWin->eExclude==TK_NO\n  );\n\n  lblWhereEnd = sqlite3VdbeMakeLabel(pParse);\n\n  /* Fill in the context object */\n  memset(&s, 0, sizeof(WindowCodeArg));\n  s.pParse = pParse;\n  s.pMWin = pMWin;\n  s.pVdbe = v;\n  s.regGosub = regGosub;\n  s.addrGosub = addrGosub;\n  s.current.csr = pMWin->iEphCsr;\n  csrWrite = s.current.csr+1;\n  s.start.csr = s.current.csr+2;\n  s.end.csr = s.current.csr+3;\n\n  /* Figure out when rows may be deleted from the ephemeral table. There\n  ** are four options - they may never be deleted (eDelete==0), they may \n  ** be deleted as soon as they are no longer part of the window frame\n  ** (eDelete==WINDOW_AGGINVERSE), they may be deleted as after the row \n  ** has been returned to the caller (WINDOW_RETURN_ROW), or they may\n  ** be deleted after they enter the frame (WINDOW_AGGSTEP). */\n  switch( pMWin->eStart ){\n    case TK_FOLLOWING:\n      if( pMWin->eFrmType!=TK_RANGE\n       && windowExprGtZero(pParse, pMWin->pStart)\n      ){\n        s.eDelete = WINDOW_RETURN_ROW;\n      }\n      break;\n    case TK_UNBOUNDED:\n      if( windowCacheFrame(pMWin)==0 ){\n        if( pMWin->eEnd==TK_PRECEDING ){\n          if( pMWin->eFrmType!=TK_RANGE\n           && windowExprGtZero(pParse, pMWin->pEnd)\n          ){\n            s.eDelete = WINDOW_AGGSTEP;\n          }\n        }else{\n          s.eDelete = WINDOW_RETURN_ROW;\n        }\n      }\n      break;\n    default:\n      s.eDelete = WINDOW_AGGINVERSE;\n      break;\n  }\n\n  /* Allocate registers for the array of values from the sub-query, the\n  ** samve values in record form, and the rowid used to insert said record\n  ** into the ephemeral table.  */\n  regNew = pParse->nMem+1;\n  pParse->nMem += nInput;\n  regRecord = ++pParse->nMem;\n  regRowid = ++pParse->nMem;\n\n  /* If the window frame contains an \"<expr> PRECEDING\" or \"<expr> FOLLOWING\"\n  ** clause, allocate registers to store the results of evaluating each\n  ** <expr>.  */\n  if( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING ){\n    regStart = ++pParse->nMem;\n  }\n  if( pMWin->eEnd==TK_PRECEDING || pMWin->eEnd==TK_FOLLOWING ){\n    regEnd = ++pParse->nMem;\n  }\n\n  /* If this is not a \"ROWS BETWEEN ...\" frame, then allocate arrays of\n  ** registers to store copies of the ORDER BY expressions (peer values) \n  ** for the main loop, and for each cursor (start, current and end). */\n  if( pMWin->eFrmType!=TK_ROWS ){\n    int nPeer = (pOrderBy ? pOrderBy->nExpr : 0);\n    regNewPeer = regNew + pMWin->nBufferCol;\n    if( pMWin->pPartition ) regNewPeer += pMWin->pPartition->nExpr;\n    regPeer = pParse->nMem+1;       pParse->nMem += nPeer;\n    s.start.reg = pParse->nMem+1;   pParse->nMem += nPeer;\n    s.current.reg = pParse->nMem+1; pParse->nMem += nPeer;\n    s.end.reg = pParse->nMem+1;     pParse->nMem += nPeer;\n  }\n\n  /* Load the column values for the row returned by the sub-select\n  ** into an array of registers starting at regNew. Assemble them into\n  ** a record in register regRecord. */\n  for(iInput=0; iInput<nInput; iInput++){\n    sqlite3VdbeAddOp3(v, OP_Column, csrInput, iInput, regNew+iInput);\n  }\n  sqlite3VdbeAddOp3(v, OP_MakeRecord, regNew, nInput, regRecord);\n\n  /* An input row has just been read into an array of registers starting\n  ** at regNew. If the window has a PARTITION clause, this block generates \n  ** VM code to check if the input row is the start of a new partition.\n  ** If so, it does an OP_Gosub to an address to be filled in later. The\n  ** address of the OP_Gosub is stored in local variable addrGosubFlush. */\n  if( pMWin->pPartition ){\n    int addr;\n    ExprList *pPart = pMWin->pPartition;\n    int nPart = pPart->nExpr;\n    int regNewPart = regNew + pMWin->nBufferCol;\n    KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, 0, 0);\n\n    regFlushPart = ++pParse->nMem;\n    addr = sqlite3VdbeAddOp3(v, OP_Compare, regNewPart, pMWin->regPart, nPart);\n    sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);\n    sqlite3VdbeAddOp3(v, OP_Jump, addr+2, addr+4, addr+2);\n    VdbeCoverageEqNe(v);\n    addrGosubFlush = sqlite3VdbeAddOp1(v, OP_Gosub, regFlushPart);\n    VdbeComment((v, \"call flush_partition\"));\n    sqlite3VdbeAddOp3(v, OP_Copy, regNewPart, pMWin->regPart, nPart-1);\n  }\n\n  /* Insert the new row into the ephemeral table */\n  sqlite3VdbeAddOp2(v, OP_NewRowid, csrWrite, regRowid);\n  sqlite3VdbeAddOp3(v, OP_Insert, csrWrite, regRecord, regRowid);\n  addrNe = sqlite3VdbeAddOp3(v, OP_Ne, pMWin->regOne, 0, regRowid);\n  VdbeCoverageNeverNull(v);\n\n  /* This block is run for the first row of each partition */\n  s.regArg = windowInitAccum(pParse, pMWin);\n\n  if( regStart ){\n    sqlite3ExprCode(pParse, pMWin->pStart, regStart);\n    windowCheckValue(pParse, regStart, 0 + (pMWin->eFrmType==TK_RANGE?3:0));\n  }\n  if( regEnd ){\n    sqlite3ExprCode(pParse, pMWin->pEnd, regEnd);\n    windowCheckValue(pParse, regEnd, 1 + (pMWin->eFrmType==TK_RANGE?3:0));\n  }\n\n  if( pMWin->eFrmType!=TK_RANGE && pMWin->eStart==pMWin->eEnd && regStart ){\n    int op = ((pMWin->eStart==TK_FOLLOWING) ? OP_Ge : OP_Le);\n    int addrGe = sqlite3VdbeAddOp3(v, op, regStart, 0, regEnd);\n    VdbeCoverageNeverNullIf(v, op==OP_Ge); /* NeverNull because bound <expr> */\n    VdbeCoverageNeverNullIf(v, op==OP_Le); /*   values previously checked */\n    windowAggFinal(&s, 0);\n    sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);\n    VdbeCoverageNeverTaken(v);\n    windowReturnOneRow(&s);\n    sqlite3VdbeAddOp1(v, OP_ResetSorter, s.current.csr);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, lblWhereEnd);\n    sqlite3VdbeJumpHere(v, addrGe);\n  }\n  if( pMWin->eStart==TK_FOLLOWING && pMWin->eFrmType!=TK_RANGE && regEnd ){\n    assert( pMWin->eEnd==TK_FOLLOWING );\n    sqlite3VdbeAddOp3(v, OP_Subtract, regStart, regEnd, regStart);\n  }\n\n  if( pMWin->eStart!=TK_UNBOUNDED ){\n    sqlite3VdbeAddOp2(v, OP_Rewind, s.start.csr, 1);\n    VdbeCoverageNeverTaken(v);\n  }\n  sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);\n  VdbeCoverageNeverTaken(v);\n  sqlite3VdbeAddOp2(v, OP_Rewind, s.end.csr, 1);\n  VdbeCoverageNeverTaken(v);\n  if( regPeer && pOrderBy ){\n    sqlite3VdbeAddOp3(v, OP_Copy, regNewPeer, regPeer, pOrderBy->nExpr-1);\n    sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.start.reg, pOrderBy->nExpr-1);\n    sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.current.reg, pOrderBy->nExpr-1);\n    sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.end.reg, pOrderBy->nExpr-1);\n  }\n\n  sqlite3VdbeAddOp2(v, OP_Goto, 0, lblWhereEnd);\n\n  sqlite3VdbeJumpHere(v, addrNe);\n\n  /* Beginning of the block executed for the second and subsequent rows. */\n  if( regPeer ){\n    windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer, lblWhereEnd);\n  }\n  if( pMWin->eStart==TK_FOLLOWING ){\n    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);\n    if( pMWin->eEnd!=TK_UNBOUNDED ){\n      if( pMWin->eFrmType==TK_RANGE ){\n        int lbl = sqlite3VdbeMakeLabel(pParse);\n        int addrNext = sqlite3VdbeCurrentAddr(v);\n        windowCodeRangeTest(&s, OP_Ge, s.current.csr, regEnd, s.end.csr, lbl);\n        windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n        windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);\n        sqlite3VdbeAddOp2(v, OP_Goto, 0, addrNext);\n        sqlite3VdbeResolveLabel(v, lbl);\n      }else{\n        windowCodeOp(&s, WINDOW_RETURN_ROW, regEnd, 0);\n        windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n      }\n    }\n  }else\n  if( pMWin->eEnd==TK_PRECEDING ){\n    int bRPS = (pMWin->eStart==TK_PRECEDING && pMWin->eFrmType==TK_RANGE);\n    windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);\n    if( bRPS ) windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n    windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);\n    if( !bRPS ) windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n  }else{\n    int addr = 0;\n    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);\n    if( pMWin->eEnd!=TK_UNBOUNDED ){\n      if( pMWin->eFrmType==TK_RANGE ){\n        int lbl = 0;\n        addr = sqlite3VdbeCurrentAddr(v);\n        if( regEnd ){\n          lbl = sqlite3VdbeMakeLabel(pParse);\n          windowCodeRangeTest(&s, OP_Ge, s.current.csr, regEnd, s.end.csr, lbl);\n        }\n        windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);\n        windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n        if( regEnd ){\n          sqlite3VdbeAddOp2(v, OP_Goto, 0, addr);\n          sqlite3VdbeResolveLabel(v, lbl);\n        }\n      }else{\n        if( regEnd ){\n          addr = sqlite3VdbeAddOp3(v, OP_IfPos, regEnd, 0, 1);\n          VdbeCoverage(v);\n        }\n        windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);\n        windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n        if( regEnd ) sqlite3VdbeJumpHere(v, addr);\n      }\n    }\n  }\n\n  /* End of the main input loop */\n  sqlite3VdbeResolveLabel(v, lblWhereEnd);\n  sqlite3WhereEnd(pWInfo);\n\n  /* Fall through */\n  if( pMWin->pPartition ){\n    addrInteger = sqlite3VdbeAddOp2(v, OP_Integer, 0, regFlushPart);\n    sqlite3VdbeJumpHere(v, addrGosubFlush);\n  }\n\n  addrEmpty = sqlite3VdbeAddOp1(v, OP_Rewind, csrWrite);\n  VdbeCoverage(v);\n  if( pMWin->eEnd==TK_PRECEDING ){\n    int bRPS = (pMWin->eStart==TK_PRECEDING && pMWin->eFrmType==TK_RANGE);\n    windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);\n    if( bRPS ) windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n    windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);\n  }else if( pMWin->eStart==TK_FOLLOWING ){\n    int addrStart;\n    int addrBreak1;\n    int addrBreak2;\n    int addrBreak3;\n    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);\n    if( pMWin->eFrmType==TK_RANGE ){\n      addrStart = sqlite3VdbeCurrentAddr(v);\n      addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 1);\n      addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);\n    }else\n    if( pMWin->eEnd==TK_UNBOUNDED ){\n      addrStart = sqlite3VdbeCurrentAddr(v);\n      addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, regStart, 1);\n      addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, 0, 1);\n    }else{\n      assert( pMWin->eEnd==TK_FOLLOWING );\n      addrStart = sqlite3VdbeCurrentAddr(v);\n      addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, regEnd, 1);\n      addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 1);\n    }\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);\n    sqlite3VdbeJumpHere(v, addrBreak2);\n    addrStart = sqlite3VdbeCurrentAddr(v);\n    addrBreak3 = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);\n    sqlite3VdbeJumpHere(v, addrBreak1);\n    sqlite3VdbeJumpHere(v, addrBreak3);\n  }else{\n    int addrBreak;\n    int addrStart;\n    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);\n    addrStart = sqlite3VdbeCurrentAddr(v);\n    addrBreak = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);\n    windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);\n    sqlite3VdbeJumpHere(v, addrBreak);\n  }\n  sqlite3VdbeJumpHere(v, addrEmpty);\n\n  sqlite3VdbeAddOp1(v, OP_ResetSorter, s.current.csr);\n  if( pMWin->pPartition ){\n    if( pMWin->regStartRowid ){\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regStartRowid);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, pMWin->regEndRowid);\n    }\n    sqlite3VdbeChangeP1(v, addrInteger, sqlite3VdbeCurrentAddr(v));\n    sqlite3VdbeAddOp1(v, OP_Return, regFlushPart);\n  }\n}\n\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n"], "fixing_code": ["C When\\san\\serror\\soccurs\\swhile\\srewriting\\sthe\\sparser\\stree\\sfor\\swindow\\sfunctions\\nin\\sthe\\ssqlite3WindowRewrite()\\sroutine,\\smake\\ssure\\sthat\\spParse->nErr\\sis\\sset,\\nand\\smake\\ssure\\sthat\\sthis\\sshuts\\sdown\\sany\\ssubsequent\\scode\\sgeneration\\sthat\\smight\\ndepend\\son\\sthe\\stransformations\\sthat\\swere\\simplemented.\\s\\sThis\\sfixes\\sa\\sproblem\\ndiscovered\\sby\\sthe\\sYongheng\\sand\\sRui\\sfuzzer.\nD 2019-12-19T20:37:32.070\nF .fossil-settings/empty-dirs dbb81e8fc0401ac46a1491ab34a7f2c7c0452f2f06b54ebb845d024ca8283ef1\nF .fossil-settings/ignore-glob 35175cdfcf539b2318cb04a9901442804be81cd677d8b889fcc9149c21f239ea\nF LICENSE.md df5091916dbb40e6e9686186587125e1b2ff51f022cc334e886c19a0e9982724\nF Makefile.in d3a862c9742f5a08230a3b295c0a47fd3067f19356dc39935280135f90474b04\nF Makefile.linux-gcc f609543700659711fbd230eced1f01353117621dccae7b9fb70daa64236c5241\nF Makefile.msc 0b0acbf34bb238170bdf1fd343a1fd37bc81c042ce029c1cc53fe15b5d4ed07b\nF README.md 1514a365ffca3c138e00c5cc839906108a01011a6b082bad19b09781e3aa498a\nF VERSION 081500f0aeaadc989d85aafbc717af45512018aebc73d89e5c2368fe62a600ff\nF aclocal.m4 a5c22d164aff7ed549d53a90fa56d56955281f50\nF art/sqlite370.eps aa97a671332b432a54e1d74ff5e8775be34200c2\nF art/sqlite370.ico af56c1d00fee7cd4753e8631ed60703ed0fc6e90\nF art/sqlite370.jpg d512473dae7e378a67e28ff96a34da7cb331def2\nF autoconf/INSTALL 83e4a25da9fd053c7b3665eaaaf7919707915903\nF autoconf/Makefile.am e14b629addaa1ce372b72043f28f40de2e32b7e211b6e0fc18dbb87989197e40\nF autoconf/Makefile.fallback 22fe523eb36dfce31e0f6349f782eb084e86a5620b2b0b4f84a2d6133f53f5ac\nF autoconf/Makefile.msc 492ea431c411378094593a5225b9a02645455a5d87a26d018b5461b723e52125\nF autoconf/README.first 6c4f34fe115ff55d4e8dbfa3cecf04a0188292f7\nF autoconf/README.txt 4f04b0819303aabaa35fff5f7b257fb0c1ef95f1\nF autoconf/configure.ac 308de24343e76ecfbe9a67f8fcd4c5216b790d230c5d9ce10210b7d5965d6192\nF autoconf/tea/Makefile.in b438a7020446c8a8156e8d97c8914a04833da6fd\nF autoconf/tea/README 3e9a3c060f29a44344ab50aec506f4db903fb873\nF autoconf/tea/aclocal.m4 52c47aac44ce0ddb1f918b6993e8beb8eee88f43\nF autoconf/tea/configure.ac 8aa16e3f0a5ca7959d4af198f46934ec187d395f\nF autoconf/tea/doc/sqlite3.n e1fe45d4f5286ee3d0ccc877aca2a0def488e9bb\nF autoconf/tea/license.terms 13bd403c9610fd2b76ece0ab50c4c5eda933d523\nF autoconf/tea/pkgIndex.tcl.in 3ef61715cf1c7bdcff56947ffadb26bc991ca39d\nF autoconf/tea/tclconfig/install-sh bdd5e293591621ae60d9824d86a4b1c5f22c3d00\nF autoconf/tea/tclconfig/tcl.m4 66ddf0a5d5e4b1d29bff472c0985fd7fa89d0fb5\nF autoconf/tea/win/makefile.vc f89d0184d0eee5f7e356ea407964dcd139939928\nF autoconf/tea/win/nmakehlp.c 247538ad8e8c508f33c03ec1fbd67d3a07ef6291\nF autoconf/tea/win/rules.vc c511f222b80064096b705dbeb97060ee1d6b6d63\nF config.guess 883205ddf25b46f10c181818bf42c09da9888884af96f79e1719264345053bd6\nF config.h.in 6376abec766e9a0785178b1823b5a587e9f1ccbc\nF config.sub c2d0260f17f3e4bc0b6808fccf1b291cb5e9126c14fc5890efc77b9fd0175559\nF configure fdc9f8d53360170679349d8f72fb2e5c79f511424891b7bb8a2f48de41c7a6ef x\nF configure.ac 3552d3aecade98a9d4b64bceb48ffb7726cbc85902efde956812942f060fbd0a\nF contrib/sqlitecon.tcl 210a913ad63f9f991070821e599d600bd913e0ad\nF doc/F2FS.txt c1d4a0ae9711cfe0e1d8b019d154f1c29e0d3abfe820787ba1e9ed7691160fcd\nF doc/lemon.html 24956ab2995e55fe171e55bdd04f22b553957dc8bb43501dbb9311e30187e0d3\nF doc/pager-invariants.txt 27fed9a70ddad2088750c4a2b493b63853da2710\nF doc/vfs-shm.txt e101f27ea02a8387ce46a05be2b1a902a021d37a\nF ext/README.md fd5f78013b0a2bc6f0067afb19e6ad040e89a10179b4f6f03eee58fac5f169bd\nF ext/async/README.txt e12275968f6fde133a80e04387d0e839b0c51f91\nF ext/async/sqlite3async.c 0f3070cc3f5ede78f2b9361fb3b629ce200d7d74\nF ext/async/sqlite3async.h f489b080af7e72aec0e1ee6f1d98ab6cf2e4dcef\nF ext/expert/README.md b321c2762bb93c18ea102d5a5f7753a4b8bac646cb392b3b437f633caf2020c3\nF ext/expert/expert.c d548d603a4cc9e61f446cc179c120c6713511c413f82a4a32b1e1e69d3f086a4\nF ext/expert/expert1.test e2afc53a27610e8251e44c7f961806607a5490ff204b3db342740d558e052662\nF ext/expert/sqlite3expert.c 3da865f2286433588260f41e796422c611bceaca3a0bbf9139a619cf7d062c19\nF ext/expert/sqlite3expert.h ca81efc2679a92373a13a3e76a6138d0310e32be53d6c3bfaedabd158ea8969b\nF ext/expert/test_expert.c d56c194b769bdc90cf829a14c9ecbc1edca9c850b837a4d0b13be14095c32a72\nF ext/fts1/README.txt 20ac73b006a70bcfd80069bdaf59214b6cf1db5e\nF ext/fts1/ft_hash.c 3927bd880e65329bdc6f506555b228b28924921b\nF ext/fts1/ft_hash.h 06df7bba40dadd19597aa400a875dbc2fed705ea\nF ext/fts1/fts1.c a39f7d21c2994d27c959ef9c3505c81542c81432\nF ext/fts1/fts1.h 6060b8f62c1d925ea8356cb1a6598073eb9159a6\nF ext/fts1/fts1_hash.c 3196cee866edbebb1c0521e21672e6d599965114\nF ext/fts1/fts1_hash.h e7f0d761353996a8175eda351104acfde23afcb0\nF ext/fts1/fts1_porter.c b1c7304b8988ba3f764a147cdd32043b4913ea7b\nF ext/fts1/fts1_tokenizer.h fdea722c38a9f82ed921642981234f666e47919c\nF ext/fts1/fts1_tokenizer1.c fd00d1fe4dc30dfc5c64cba695ce34f4af20d2fa\nF ext/fts1/fulltext.c 37698e1909584f6d8ea67d1485e3ad39dbf42d19\nF ext/fts1/fulltext.h 08525a47852d1d62a0be81d3fc3fe2d23b094efd\nF ext/fts1/simple_tokenizer.c bbfa4e3b2a26ef17d4edc6d98cd4a3f5396d998a\nF ext/fts1/tokenizer.h 0c53421b832366d20d720d21ea3e1f6e66a36ef9\nF ext/fts2/README.tokenizers 21e3684ea5a095b55d70f6878b4ce6af5932dfb7\nF ext/fts2/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts2/fts2.c 72c816a9ae448049fbbe8f18a85698765fc7956c\nF ext/fts2/fts2.h da5f76c65163301d1068a971fd32f4119e3c95fa\nF ext/fts2/fts2_hash.c 011a1d32de45bb1b519a1fd0048e857d6a843558\nF ext/fts2/fts2_hash.h 1824b99dfd8d0225facbdb26a2c87289b2e7dcf8\nF ext/fts2/fts2_icu.c 51c5cd3c04954badd329fa738c95fcdb717b5188\nF ext/fts2/fts2_porter.c 2cd4a507bf3c3085fe66f59b0f2a325f65aaacf5\nF ext/fts2/fts2_tokenizer.c b529493d55e55497213c37e1f31680a77746be26\nF ext/fts2/fts2_tokenizer.h 27a1a99ca2d615cf7e142839b8d79e8751b4529e\nF ext/fts2/fts2_tokenizer1.c 07e223eecb483d448313b5f1553a4f299a7fb7a1\nF ext/fts2/mkfts2amal.tcl 974d5d438cb3f7c4a652639262f82418c1e4cff0\nF ext/fts3/README.content fdc666a70d5257a64fee209f97cf89e0e6e32b51\nF ext/fts3/README.syntax a19711dc5458c20734b8e485e75fb1981ec2427a\nF ext/fts3/README.tokenizers b92bdeb8b46503f0dd301d364efc5ef59ef9fa8e2758b8e742f39fa93a2e422d\nF ext/fts3/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts3/fts3.c a05938725571651cc9bedc63a52ede4b39277fec17884c8ff6011dab2ff78c75\nF ext/fts3/fts3.h 3a10a0af180d502cecc50df77b1b22df142817fe\nF ext/fts3/fts3Int.h f091030b976045e7df91af2337935952b477cdbd9f48058c44c965684484cb50\nF ext/fts3/fts3_aux.c 96708c8b3a7d9b8ca1b68ea2b7e503e283f20e95f145becadedfad096dbd0f34\nF ext/fts3/fts3_expr.c b132af223e90e35b9f9efa9fe63d6ae737d34153a3b6066736086df8abc78a1f\nF ext/fts3/fts3_hash.c 8b6e31bfb0844c27dc6092c2620bdb1fca17ed613072db057d96952c6bdb48b7\nF ext/fts3/fts3_hash.h 39cf6874dc239d6b4e30479b1975fe5b22a3caaf\nF ext/fts3/fts3_icu.c 305ce7fb6036484085b5556a9c8e62acdc7763f0f4cdf5fd538212a9f3720116\nF ext/fts3/fts3_porter.c 3565faf04b626cddf85f03825e86056a4562c009\nF ext/fts3/fts3_snippet.c d62e40baa6a200586c3a425478109418f44926b1c318c870b59a4286afbe2795\nF ext/fts3/fts3_term.c f45a1e7c6ef464abb1231245d123dae12266b69e05cc56e14045b76591ae92d1\nF ext/fts3/fts3_test.c 73b16e229e517c1b1f0fb8e1046182a4e5dbc8dbe6eea8a5d4353fcce7dbbf39\nF ext/fts3/fts3_tokenize_vtab.c 1de9a61acfa2a0445ed989310c31839c57f6b6086dd9d5c97177ae734a17fd8b\nF ext/fts3/fts3_tokenizer.c a1ca0ab7c9c688ccb1d605645809f74f5df2bf4ca568e4bb37fb51113fd78e45\nF ext/fts3/fts3_tokenizer.h 64c6ef6c5272c51ebe60fc607a896e84288fcbc3\nF ext/fts3/fts3_tokenizer1.c 5c98225a53705e5ee34824087478cf477bdb7004\nF ext/fts3/fts3_unicode.c 4b9af6151c29b35ed09574937083cece7c31e911f69615e168a39677569b684d\nF ext/fts3/fts3_unicode2.c 416eb7e1e81142703520d284b768ca2751d40e31fa912cae24ba74860532bf0f\nF ext/fts3/fts3_write.c 51e0a4e3782ee17b6dd5e89949b7095fc98e36e87725c53de631734535507498\nF ext/fts3/fts3speed.tcl b54caf6a18d38174f1a6e84219950d85e98bb1e9\nF ext/fts3/mkfts3amal.tcl 252ecb7fe6467854f2aa237bf2c390b74e71f100\nF ext/fts3/tool/fts3cov.sh c331d006359456cf6f8f953e37f2b9c7d568f3863f00bb5f7eb87fea4ac01b73\nF ext/fts3/tool/fts3view.c 202801a2056995b763864d60c2dee744d46f1677\nF ext/fts3/unicode/CaseFolding.txt 8c678ca52ecc95e16bc7afc2dbf6fc9ffa05db8c\nF ext/fts3/unicode/UnicodeData.txt cd07314edb62d49fde34debdaf92fa2aa69011e7\nF ext/fts3/unicode/mkunicode.tcl bf7fcaa6d68e6d38223467983785d054f1cff4d9e3905dd51f6ed8801bb590d5\nF ext/fts3/unicode/parseunicode.tcl a981bd6466d12dd17967515801c3ff23f74a281be1a03cf1e6f52a6959fc77eb\nF ext/fts5/extract_api_docs.tcl a36e54ec777172ddd3f9a88daf593b00848368e0\nF ext/fts5/fts5.h c132a9323f22a972c4c93a8d5a3d901113a6e612faf30ca8e695788438c5ca2a\nF ext/fts5/fts5Int.h d7cbc214ee167496f70905667e18f73ea0402f7ef09236ce305e117e0efc866a\nF ext/fts5/fts5_aux.c dcc627d8b6e3fc773db528ff67b39955dab7b51628f9dba8e15849e5bedfd7fa\nF ext/fts5/fts5_buffer.c 5a5fe0159752c0fb0a5a93c722e9db2662822709490769d482b76a6dc8aaca70\nF ext/fts5/fts5_config.c b447948f35ad3354e8fe5e242e0a7e7b5b941555400b9404259944e3aa570037\nF ext/fts5/fts5_expr.c 2be456484786333d559dc2987a00f2750981fab91d52db8452a8046278c5f22e\nF ext/fts5/fts5_hash.c 1cc0095646f5f3b46721aa112fb4f9bf29ae175cb5338f89dcec66ed97acfe75\nF ext/fts5/fts5_index.c 99b77ae1f503978ca76985bcfff7345c822aed8bbaa8edb3747f804f614685b5\nF ext/fts5/fts5_main.c 9db1f173d299466aeff89bd949fb1eb0a181265726fb56f11e07ea292dcc9a73\nF ext/fts5/fts5_storage.c 167e3d8f8052a71032d498e32a2f2ed5ffe489e5d4d47e298adfa02ed55c7882\nF ext/fts5/fts5_tcl.c 39bcbae507f594aad778172fa914cad0f585bf92fd3b078c686e249282db0d95\nF ext/fts5/fts5_test_mi.c 08c11ec968148d4cb4119d96d819f8c1f329812c568bac3684f5464be177d3ee\nF ext/fts5/fts5_test_tok.c f96c6e193c466711d6d7828d5f190407fe7ab897062d371426dd3036f01258e7\nF ext/fts5/fts5_tokenize.c 2e508c6a3bd8ee56c48e98a38052e1a650e49b32a484cce9b189984114bc3b88\nF ext/fts5/fts5_unicode2.c 8bd0cd07396b74c1a05590e4070d635bccfc849812c305619f109e6c0485e250\nF ext/fts5/fts5_varint.c e64d2113f6e1bfee0032972cffc1207b77af63319746951bf1d09885d1dadf80\nF ext/fts5/fts5_vocab.c c3f12188570abb423303cd193b16dd19ba54e21c2e930e9b748d743de3b385f5\nF ext/fts5/fts5parse.y eb526940f892ade5693f22ffd6c4f2702543a9059942772526eac1fde256bb05\nF ext/fts5/mkportersteps.tcl 5acf962d2e0074f701620bb5308155fa1e4a63ba\nF ext/fts5/test/fts5_common.tcl b01c584144b5064f30e6c648145a2dd6bc440841\nF ext/fts5/test/fts5aa.test 5bd43427b7d08ce2e19c488a26534be450538b9232d4d5305049e8de236e9aa9\nF ext/fts5/test/fts5ab.test 9205c839332c908aaad2b01ab8670ece8b161e8f2ec8a9fabf18ca9385880bb7\nF ext/fts5/test/fts5ac.test a7aa7e1fefc6e1918aa4d3111d5c44a09177168e962c5fd2cca9620de8a7ed6d\nF ext/fts5/test/fts5ad.test e8cf959dfcd57c8e46d6f5f25665686f3b6627130a9a981371dafdf6482790de\nF ext/fts5/test/fts5ae.test 1142d16d9cc193894dc13cc8f9c7a8a21411ac61b5567a878514df6f9f0d7bb7\nF ext/fts5/test/fts5af.test 724247405b13f8f06cc6ce464dc4f152dc5dd4e86b12c2099685d8f19747bf7b\nF ext/fts5/test/fts5ag.test 7816f25a0707578f08145ab539fc0ca025f8951e788b28a6a18a06b2099469dd\nF ext/fts5/test/fts5ah.test 27b5a33bfd0363ca8a4dc659e6e2a5df3dea1c3c5b04bc51ca6aeb1277bd9b21\nF ext/fts5/test/fts5ai.test bc97e4758cc93e06bf851d61c98fdf4e8b8f8315ee28a84fb15f916360856414\nF ext/fts5/test/fts5aj.test 745020852d85f5dd49d11cb7ad11d3cc6dafc4fe6d6d24bc0875ac8f43ee4149\nF ext/fts5/test/fts5ak.test fc3595f8e6873bb86d70c9bd4b67d0413ce577bd4793c39a2b60a7b8825b60a6\nF ext/fts5/test/fts5al.test 00c4c1c6a1366b73aa48ce2068c634520867c3cf7f5d1676ebbb775ee1f35734\nF ext/fts5/test/fts5alter.test 5565f7e4605512b69171ac18ca84398603f9f6456dbe377beeca97e83cc242cd\nF ext/fts5/test/fts5auto.test 78989e6527ce69c9eddbef7392fea5c10b0010cd2b2ae68eec7bc869c471e691\nF ext/fts5/test/fts5aux.test ebf6f2ff7cb556e83f66991b7f12bff016d3c83d4eab36704b649dd6b1437318\nF ext/fts5/test/fts5auxdata.test eacc97ff04892f1a5f3d4df5a73f8bcbc3955ea1d12c9f24137eb1fc079e7611\nF ext/fts5/test/fts5bigpl.test 6466c89b38439f0aba26ac09e232a6b963f29b1cbe1304f6a664fe1e7a8f5fd3\nF ext/fts5/test/fts5bigtok.test 541119e616c637caea925a8c028c37c2c29e94383e00aa2f9198d530724b6e36\nF ext/fts5/test/fts5cat.test daba0b80659460b0cb60bd1f40b402478a761fe7ea414c3c94c2be25568cc33a\nF ext/fts5/test/fts5circref.test f880dfd0d99f6fb73b88ccacb0927d18e833672fd906cc47d6b4e529419eaa62\nF ext/fts5/test/fts5colset.test a30473451321bbf0b6218af62e96b4ae5fa99931cfdb210b5ecc804623b30f75\nF ext/fts5/test/fts5columnsize.test 45459ce4dd9fd853b6044cdc9674921bff89e3d840f348ca8c1630f9edbf5482\nF ext/fts5/test/fts5config.test 60094712debc59286c59aef0e6cf511c37d866802776a825ce437d26afe0817f\nF ext/fts5/test/fts5conflict.test 655925678e630d3cdf145d18725a558971806416f453ac8410ca8c04d934238d\nF ext/fts5/test/fts5connect.test 08030168fc96fc278fa81f28654fb7e90566f33aff269c073e19b3ae9126b2f4\nF ext/fts5/test/fts5content.test 213506436fb2c87567b8e31f6d43ab30aab99354cec74ed679f22aad0cdbf283\nF ext/fts5/test/fts5corrupt.test 77ae6f41a7eba10620efb921cf7dbe218b0ef232b04519deb43581cb17a57ebe\nF ext/fts5/test/fts5corrupt2.test 7453752ba12ce91690c469a6449d412561cc604b1dec994e16ab132952e7805f\nF ext/fts5/test/fts5corrupt3.test 5aaa2f8b44a85246a2ea76db1695bde38a75802979f3961702afa8f322d331c8\nF ext/fts5/test/fts5corrupt4.test ea805c4d7c68b5f185b9db5d2060a7ae5875339738dd48203c92162f41e7ca91\nF ext/fts5/test/fts5delete.test cbf87e3b8867c4d5cfcaed975c7475fd3f99d072bce2075fcedf43d1f82af775\nF ext/fts5/test/fts5detail.test 31b240dbf6d44ac3507e2f8b65f29fdc12465ffd531212378c7ce1066766f54e\nF ext/fts5/test/fts5determin.test 1b77879b2ae818b5b71c859e534ee334dac088b7cf3ff3bf76a2c82b1c788d11\nF ext/fts5/test/fts5dlidx.test b90852c55881b29dbac6380b274de27beae623ac4b6d567c6c8fb9cdc315a86e\nF ext/fts5/test/fts5doclist.test e39a6001495f1dc68e20323586ac965787986c2bf6f515b9b0285627b089d9e6\nF ext/fts5/test/fts5ea.test b01e3a18cdfabbff8104a96a5242a06a68a998a0\nF ext/fts5/test/fts5eb.test 239bb2f02571f8cccfc7018d08f502df1cd8cc6a69b65ed1dde5f6a070e3f669\nF ext/fts5/test/fts5fault1.test d28a65caee75db6897c3cf1358c5230d3bb2a3bf7fb31062c19c7e5382b3d2bd\nF ext/fts5/test/fts5fault2.test 69c8fdbef830cd0d450908d4504d5bb86609e255af99c421c20a0756251fe344\nF ext/fts5/test/fts5fault3.test da2f9e3e56ff5740d68ebdd6877c97089e7ed28ddff28a0da87a6afea27e5522\nF ext/fts5/test/fts5fault4.test 1c1db5fcfe59401e7833146100f1d8de284a0a686fac31ddac9fb56c459f725b\nF ext/fts5/test/fts5fault5.test a336e4e11847de24c9497f80cce18e00bb3fab7fb11f97d04eb9af898900a762\nF ext/fts5/test/fts5fault6.test a0fc0a8f99e4b16500c31dfc7e38e1defe0f1693ac47650517ac7b723b1956f8\nF ext/fts5/test/fts5fault7.test 0acbec416edb24b8881f154e99c31e9ccf73f539cfcd164090be139e9e97ed4c\nF ext/fts5/test/fts5fault8.test 318238659d35f82ad215ecb57ca4c87486ea85d45dbeedaee42f148ff5105ee2\nF ext/fts5/test/fts5fault9.test 098e6b894bbdf9b2192f994a30f4043673fb3f338b6b8ab1624c704422f39119\nF ext/fts5/test/fts5faultA.test be4487576bff8c22cee6597d1893b312f306504a8c6ccd3c53ca85af12290c8c\nF ext/fts5/test/fts5faultB.test d606bdb8e81aaeb6f41de3fc9fc7ae315733f0903fbff05cf54f5b045b729ab5\nF ext/fts5/test/fts5faultD.test cc5d1225556e356615e719c612e845d41bff7d5a\nF ext/fts5/test/fts5first.test 3fcf2365c00a15fc9704233674789a3b95131d12de18a9b996159f6909dc8079\nF ext/fts5/test/fts5full.test e1701a112354e0ff9a1fdffb0c940c576530c33732ee20ac5e8361777070d717\nF ext/fts5/test/fts5fuzz1.test 238d8c45f3b81342aa384de3e581ff2fa330bf922a7b69e484bbc06051a1080e\nF ext/fts5/test/fts5hash.test a4cf51acad99bfc43c16fb74f9d22495dc221ae0701fc5e908ca963a9b26a02b\nF ext/fts5/test/fts5integrity.test 4317561cd25eca7df16aa1f7d1a700ee958059fa639785f94aba0a84df9ab17b\nF ext/fts5/test/fts5interrupt.test 09613247b273a99889808ef852898177e671406fe71fdde7ea00e78ea283d227\nF ext/fts5/test/fts5lastrowid.test be98fe3e03235296585b72daad7aed5717ba0062bae5e5c18dd6e04e194c6b28\nF ext/fts5/test/fts5leftjoin.test c0b4cafb9661379e576dc4405c0891d8fcc2782680740513c4d1fc114b43d4ad\nF ext/fts5/test/fts5matchinfo.test 50d86da66ec5b27603dcd90ba0227f5d9deb10351cbc52974a88e24f6fc9b076\nF ext/fts5/test/fts5merge.test e92a8db28b45931e7a9c7b1bbd36101692759d00274df74d83fd29d25d53b3a6\nF ext/fts5/test/fts5merge2.test 3ebad1a59d6ad3fb66eff6523a09e95dc6367cbefb3cd73196801dea0425c8e2\nF ext/fts5/test/fts5misc.test a5b53328b5b79275915de8f67ae85905eb2133d8dbcc808411f67c094b1bd347\nF ext/fts5/test/fts5multi.test a15bc91cdb717492e6e1b66fec1c356cb57386b980c7ba5af1915f97fe878581\nF ext/fts5/test/fts5multiclient.test 5ff811c028d6108045ffef737f1e9f05028af2458e456c0937c1d1b8dea56d45\nF ext/fts5/test/fts5near.test 211477940142d733ac04fad97cb24095513ab2507073a99c2765c3ddd2ef58bd\nF ext/fts5/test/fts5onepass.test f9b7d9b2c334900c6542a869760290e2ab5382af8fbd618834bf1fcc3e7b84da\nF ext/fts5/test/fts5optimize.test 36a752d24c818792032e4ff502936fc9cc5ef938721696396fdc79214b2717f1\nF ext/fts5/test/fts5phrase.test 13e5d8e9083077b3d9c74315b3c92ec723cc6eb37c8155e0bfe1bba00559f07b\nF ext/fts5/test/fts5plan.test 771b999d161e24fd803ce0290adb7c6e7c9b9cc2c6a0adb344813fb89473aa32\nF ext/fts5/test/fts5porter.test 8d08010c28527db66bc3feebd2b8767504aaeb9b101a986342fa7833d49d0d15\nF ext/fts5/test/fts5porter2.test 0d251a673f02fa13ca7f011654873b3add20745f7402f108600a23e52d8c7457\nF ext/fts5/test/fts5prefix.test a0fa67b06650f2deaa7bf27745899d94e0fb547ad9ecbd08bfad98c04912c056\nF ext/fts5/test/fts5query.test ac363b17a442620bb0780e93c24f16a5f963dfe2f23dc85647b869efcfada728\nF ext/fts5/test/fts5rank.test c9fd4a1e36b4fa92d572ec13d846469b97da249d1c2f7fd3ee7e017ce46f2416\nF ext/fts5/test/fts5rebuild.test 55d6f17715cddbf825680dd6551efbc72ed916d8cf1cde40a46fc5d785b451e7\nF ext/fts5/test/fts5restart.test 835ecc8f449e3919f72509ab58056d0cedca40d1fe04108ccf8ac4c2ba41f415\nF ext/fts5/test/fts5rowid.test b8790ec170a8dc1942a15aef3db926a5f3061b1ff171013003d8297203a20ad6\nF ext/fts5/test/fts5simple.test a298670508c1458b88ce6030440f26a30673931884eb5f4094ac1773b3ba217b\nF ext/fts5/test/fts5simple2.test 258a1b0c590409bfa5271e872c79572b319d2a56554d0585f68f146a0da603f0\nF ext/fts5/test/fts5simple3.test d5c74a9d3ca71bd5dd5cacb7c55b86ea12cdddfc8b1910e3de2995206898380f\nF ext/fts5/test/fts5synonym.test 1651815b8008de170e8e600dcacc17521d765482ea8f074ae82cfa870d8bb7fb\nF ext/fts5/test/fts5synonym2.test b54cce5c34ec08ed616f646635538ae82e34a0e28f947ec60b6fadbc4b3fb17a\nF ext/fts5/test/fts5tok1.test ce6551e41ff56f30b69963577324624733bed0d1753589f06120d664d9cd45c9\nF ext/fts5/test/fts5tok2.test dcacb32d4a2a3f0dd3215d4a3987f78ae4be21a2\nF ext/fts5/test/fts5tokenizer.test ac3c9112b263a639fb0508ae73a3ee886bf4866d2153771a8e8a20c721305a43\nF ext/fts5/test/fts5umlaut.test a42fe2fe6387c40c49ab27ccbd070e1ae38e07f38d05926482cc0bccac9ad602\nF ext/fts5/test/fts5unicode.test 17056f4efe6b0a5d4f41fdf7a7dc9af2873004562eaa899d40633b93dc95f5a9\nF ext/fts5/test/fts5unicode2.test 9b3df486de05fb4bde4aa7ee8de2e6dae1df6eb90e3f2e242c9383b95d314e3e\nF ext/fts5/test/fts5unicode3.test 590c72e18195bda2446133f9d82d04a4e89d094bba58c75ae10f4afc6faa0744\nF ext/fts5/test/fts5unicode4.test 6463301d669f963c83988017aa354108be0b947d325aef58d3abddf27147b687\nF ext/fts5/test/fts5unindexed.test 9021af86a0fb9fc616f7a69a996db0116e7936d0db63892db6bafabbec21af4d\nF ext/fts5/test/fts5update.test b8affd796e45c94a4d19ad5c26606ea06065a0f162a9562d9f005b5a80ccf0bc\nF ext/fts5/test/fts5version.test c8f2cc105f0abf0224965f93e584633dee3e06c91478bc67e468f7cfdf97fd6a\nF ext/fts5/test/fts5vocab.test 648fb2fe86b55e08295e34504704718d92fba3e2cf3e1f5d72fa3682df4cd0f0\nF ext/fts5/test/fts5vocab2.test e0fdc3a3095f6eda68ac9bf9a443ff929a124d46f00af19933604085712e9d47\nF ext/fts5/tool/fts5speed.tcl b0056f91a55b2d1a3684ec05729de92b042e2f85\nF ext/fts5/tool/fts5txt2db.tcl 526a9979c963f1c54fd50976a05a502e533a4c59\nF ext/fts5/tool/loadfts5.tcl 95b03429ee6b138645703c6ca192c3ac96eaf093\nF ext/fts5/tool/mkfts5c.tcl d1c2a9ab8e0ec690a52316f33dd9b1d379942f45\nF ext/fts5/tool/showfts5.tcl d54da0e067306663e2d5d523965ca487698e722c\nF ext/icu/README.txt a295e91db742b153e8dce8f7efd31d28ad1eea4df31ef4daa3eedc85be2f5138\nF ext/icu/icu.c c2c7592574c08cd1270d909b8fb8797f6ea1f49e931e71dbcc25506b9b224580\nF ext/icu/sqliteicu.h 728867a802baa5a96de7495e9689a8e01715ef37\nF ext/lsm1/Makefile a553b728bba6c11201b795188c5708915cc4290f02b7df6ba7e8c4c943fd5cd9\nF ext/lsm1/Makefile.msc f8c878b467232226de288da320e1ac71c131f5ec91e08b21f502303347260013\nF ext/lsm1/lsm-test/README 87ea529d2abe615e856d4714bfe8bb185e6c2771b8612aa6298588b7b43e6f86\nF ext/lsm1/lsm-test/lsmtest.h cf58528ffe0cfe535e91b44584e2ec5fb1caacdabecef0d8dcf83bf83168bf28\nF ext/lsm1/lsm-test/lsmtest1.c ae6ba48a0851b39be69a7d0eb220bfb9521a526e926223d5014bd385df10abb3\nF ext/lsm1/lsm-test/lsmtest2.c 188b09aec776516aeedcfd13b9c6faf85ba16b3671a0897a2c740ee00a5dc4f8\nF ext/lsm1/lsm-test/lsmtest3.c 9ab87528a36dbf4a61d7c8ad954f5ee368c0878c127b84b942b2e2abe522de26\nF ext/lsm1/lsm-test/lsmtest4.c d258d6a245db5d8eaede096e2368d23f859c5e92c80ab9122463f708514fe10c\nF ext/lsm1/lsm-test/lsmtest5.c 8d5242a0f870d65eeada191c8945781fed9cb8ece3886573790ebd373b62dac5\nF ext/lsm1/lsm-test/lsmtest6.c 869cb4a172cd07d1a75b3aeaecd61d0a477787b3b8668bad0d3ff0f43b642b7c\nF ext/lsm1/lsm-test/lsmtest7.c 7a917455a0f956a8ed3f44f5c9387ec0ea6627714874464cc3fa5c5a9cabb2f2\nF ext/lsm1/lsm-test/lsmtest8.c 589b68c44531a0f04d5e879bb1e211be5f7100f48eed7e8631e07ed5cbd68f94\nF ext/lsm1/lsm-test/lsmtest9.c dd1a0ebf41134933a744d1e00e60429a2a21fc50d587ae7dd6bdb6e96d805bdc\nF ext/lsm1/lsm-test/lsmtest_bt.c d70d9a9be5eef9360af1251dd083948d74fd30137a08f61bef995f7ac04e037f\nF ext/lsm1/lsm-test/lsmtest_datasource.c 5d770be191d0ca51315926723009b2c25c0b4b8136840494ef710ac324aa916c\nF ext/lsm1/lsm-test/lsmtest_func.c 159aa401bc8032bfa3d8cf2977bd687abebab880255895a5eb45770d626fa38d\nF ext/lsm1/lsm-test/lsmtest_io.c cf11b27b129c6bd5818fa1d440176502dc27229f0db892b4479118d61993ea20\nF ext/lsm1/lsm-test/lsmtest_main.c a9bc647738c0dcaebf205d6d194b3ce4a6ef3925801cd2d919f0a4ea33a15aeb\nF ext/lsm1/lsm-test/lsmtest_mem.c 4e63c764345ab1df59d4f13a77980c6f3643798210b10d6cdbd785b4b888fda5\nF ext/lsm1/lsm-test/lsmtest_tdb.c 618a8619183fda4f5540fcde15f9068293c5e3180e1a246e34409b0c148758b3\nF ext/lsm1/lsm-test/lsmtest_tdb.h 8733eee249b12956a9df8322994b43d19bd8c02ad2e8b0bb5164db4d6ccc1735\nF ext/lsm1/lsm-test/lsmtest_tdb2.cc 99ea7f2dd9c7536c8fb9bdd329e4cfeb76899f3ddf6f48bdd3926e016922b715\nF ext/lsm1/lsm-test/lsmtest_tdb3.c 7a7ccae189f5bb25bcd1ec3bbd740529706eded7f6729a5a0a9eeaeb57785320\nF ext/lsm1/lsm-test/lsmtest_tdb4.c 47e8bb5eba266472d690fb8264f1855ebdba0ae5a0e541e35fcda61ebf1d277f\nF ext/lsm1/lsm-test/lsmtest_util.c 241622db5a332a09c8e6e7606b617d288a37b557f7d3bce0bb97809f67cc2806\nF ext/lsm1/lsm-test/lsmtest_win32.c 0e0a224674c4d3170631c41b026b56c7e1672b151f5261e1b4cc19068641da2d\nF ext/lsm1/lsm.h 0f6f64ff071471cb87bf98beb8386566f30ea001\nF ext/lsm1/lsmInt.h 5983690e05e83653cc01ba9d8fbf8455e534ddf8349ed9adedbf46a7549760b0\nF ext/lsm1/lsm_ckpt.c 0eabfaf812ddb4ea43add38f05e430694cd054eb622c3e35af4c43118a2d5321\nF ext/lsm1/lsm_file.c 3c51841d5b3e7da162693cbac9a9f47eeedf6bcbbe2969a4d25e30c428c9fe36\nF ext/lsm1/lsm_log.c a8bf334532109bba05b09a504ee45fc393828b0d034ca61ab45e3940709d9a7c\nF ext/lsm1/lsm_main.c b5703f8042e71d3a2d65e671f6832e077e79e89e9975818f67f969922618db63\nF ext/lsm1/lsm_mem.c 4c51ea9fa285ee6e35301b33491642d071740a0a\nF ext/lsm1/lsm_mutex.c 378edf0a2b142b4f7640ee982df06d50b98788ea\nF ext/lsm1/lsm_shared.c 76adfc1ed9ffebaf92746dde4b370ccc48143ca8b05b563816eadd2aadf1c525\nF ext/lsm1/lsm_sorted.c 6f7d8cf7a7d3d3f1ab5d9ba6347e8f39f3d73c00ec48afcd0c4bcbefd806f9b8\nF ext/lsm1/lsm_str.c 65e361b488c87b10bf3e5c0070b14ffc602cf84f094880bece77bbf6678bca82\nF ext/lsm1/lsm_tree.c 682679d7ef2b8b6f2fe77aeb532c8d29695bca671c220b0abac77069de5fb9fb\nF ext/lsm1/lsm_unix.c 57361bcf5b1a1a028f5d66571ee490e9064d2cfb145a2cc9e5ddade467bb551b\nF ext/lsm1/lsm_varint.c 43f954af668a66c7928b81597c14d6ad4be9fedbc276bbd80f52fa28a02fdb62\nF ext/lsm1/lsm_vtab.c 169bfe7ef8e6c9de9c77e17c4c50c9ae55fb0167d80be3d1be82c991184b6f35\nF ext/lsm1/lsm_win32.c 0a4acbd7e8d136dd3a5753f0a9e7a9802263a9d96cef3278cf120bcaa724db7c\nF ext/lsm1/test/lsm1_common.tcl 5ed4bab07c93be2e4f300ebe46007ecf4b3e20bc5fbe1dedaf04a8774a6d8d82\nF ext/lsm1/test/lsm1_simple.test a04d08e8661ae6fc53786c67f0bd102c6692f003e859dde03ed9ac3f12e066e5\nF ext/lsm1/tool/mklsm1c.tcl f31561bbee5349f0a554d1ad7236ac1991fc09176626f529f6078e07335398b0\nF ext/misc/README.md d6dd0fe1d8af77040216798a6a2b0c46c73054d2f0ea544fbbcdccf6f238c240\nF ext/misc/amatch.c 50a9ef2d38dabfa371f8c1904097d493271e63d58ccb0e9b79a4fa4a94e66660\nF ext/misc/anycollseq.c 5ffdfde9829eeac52219136ad6aa7cd9a4edb3b15f4f2532de52f4a22525eddb\nF ext/misc/appendvfs.c 3777f22ec1057dc4e5fd89f2fbddcc7a29fbeef1ad038c736c54411bb1967af7\nF ext/misc/blobio.c a867c4c4617f6ec223a307ebfe0eabb45e0992f74dd47722b96f3e631c0edb2a\nF ext/misc/btreeinfo.c 4f0ebf278f46e68e6306c667917766cebc5550fd35d5de17847988e22892d4d2\nF ext/misc/carray.c 91e9a7f512fda934894bed30464552fffa7d3073b5be04189ae0bd0c59f26bfd\nF ext/misc/closure.c dbfd8543b2a017ae6b1a5843986b22ddf99ff126ec9634a2f4047cd14c85c243\nF ext/misc/completion.c cec672d40604075bb341a7f11ac48393efdcd90a979269b8fe7977ea62d0547f\nF ext/misc/compress.c dd4f8a6d0baccff3c694757db5b430f3bbd821d8686d1fc24df55cf9f035b189\nF ext/misc/csv.c 7f047aeb68f5802e7ce6639292095d622a488bb43526ed04810e0649faa71ceb\nF ext/misc/dbdata.c e316fba936571584e55abd5b974a32a191727a6b746053a0c9d439bd2cf93940\nF ext/misc/dbdump.c baf6e37447c9d6968417b1cd34cbedb0b0ab3f91b5329501d8a8d5be3287c336\nF ext/misc/eval.c 4b4757592d00fd32e44c7a067e6a0e4839c81a4d57abc4131ee7806d1be3104e\nF ext/misc/explain.c d5c12962d79913ef774b297006872af1fccda388f61a11d37758f9179a09551f\nF ext/misc/fileio.c 288e7230e0fe464d71b0694e2d8bdd3a353118ac2e31da3964b95f460f09915f\nF ext/misc/fossildelta.c 7708651072eb5620ab21bbfb518d184f27b2c29c0131b09b9a2d8852a8016430\nF ext/misc/fuzzer.c c4e27daf41433a64cad5265cd27dbcb891147e9994d0422200ce81ce9a54b625\nF ext/misc/ieee754.c f190d0cc5182529acb15babd177781be1ac1718c\nF ext/misc/json1.c 760107d0b97ab422952591b0d7519327dcb482954a7706ee387a54c135f8aabf\nF ext/misc/memstat.c 3017a0832c645c0f8c773435620d663855f04690172316bd127270d1a7523d4d\nF ext/misc/memtrace.c 7c0d115d2ef716ad0ba632c91e05bd119cb16c1aedf3bec9f06196ead2d5537b\nF ext/misc/memvfs.c ab36f49e02ebcdf85a1e08dc4d8599ea8f343e073ac9e0bca18a98b7e1ec9567\nF ext/misc/mmapwarm.c 8c5fe90d807a23e44a8b93e96e8b812b19b300d5fd8c1d40a4fd1d8224e33f46\nF ext/misc/nextchar.c 279f80fe8ef5ba413242e2704e246503ac601f005eefb180d19e6c920338a0ba\nF ext/misc/normalize.c b4290464f542bae7a97b43f15bd197949b833ffd668b7c313631bd5d4610212c\nF ext/misc/percentile.c 148dd07286b16e50f232bb638a47850085ad37d51f270429905bd865e595d1ca\nF ext/misc/prefixes.c 7be86d17525cfae6ed462fc3c519efc44488ac329890f77491c8f82871f57e17\nF ext/misc/regexp.c 653b6ab5e89bcb5d45f9ebe0747d7f8f3f5706cac963fcbc9a3ddbe5fdc1efa2\nF ext/misc/remember.c add730f0f7e7436cd15ea3fd6a90fd83c3f706ab44169f7f048438b7d6baa69c\nF ext/misc/rot13.c 540a169cb0d74f15522a8930b0cccdcb37a4fd071d219a5a083a319fc6e8db77\nF ext/misc/scrub.c db9fff56fed322ca587d73727c6021b11ae79ce3f31b389e1d82891d144f22ad\nF ext/misc/series.c 0c97f63378fddc9f425e82ba139b9aaf902211f24ced115c2b6ae12b425f7334\nF ext/misc/sha1.c d8125a88ee9023bc17d6f87ea8850db33f906d5701b30d4fd9bddb57f231e60a\nF ext/misc/shathree.c 22ba7ca84a433d6466a7d05dcc876910b435a715da8cc462517db9351412b8c8\nF ext/misc/showauth.c 732578f0fe4ce42d577e1c86dc89dd14a006ab52\nF ext/misc/spellfix.c f88ecb2c0294453ce8b7704b211f5350c41b085b38c8e056852e3a08b0f5e484\nF ext/misc/sqlar.c 57d5bc45cd5492208e451f697404be88f8612527d64c9d42f96b325b64983d74\nF ext/misc/stmt.c 8a8dc4675042e4551e4afe99b8d0cc7a4a2fc1a8dacc0a9ce1b1bbff145da93d\nF ext/misc/templatevtab.c 8a16a91a5ceaccfcbd6aaaa56d46828806e460dd194965b3f77bf38f14b942c4\nF ext/misc/totype.c 5b6b1eafaa993e29f8df843319b3292b029f1b5cbbbf11c8a88e05d3f714159f\nF ext/misc/unionvtab.c 36237f0607ca954ac13a4a0e2d2ac40c33bc6e032a5f55f431713061ef1625f9\nF ext/misc/uuid.c db4db81e8c6a92ad6176ebd9f81dcb6870e331e1a286d0452f4319e3ba3df812\nF ext/misc/vfslog.c 3b25c2f56ba60788db247287be6ab024b53c4afffd412b4876db563389be0d35\nF ext/misc/vfsstat.c 77b5b4235c9f7f11eddf82487c0a422944ac2f132dafd5af3be7a68a057b1cdb\nF ext/misc/vtablog.c 5538acd0c8ddaae372331bee11608d76973436b77d6a91e8635cfc9432fba5ae\nF ext/misc/vtshim.c 1976e6dd68dd0d64508c91a6dfab8e75f8aaf6cd\nF ext/misc/wholenumber.c 784b12543d60702ebdd47da936e278aa03076212\nF ext/misc/zipfile.c 8f965eb309da3ae8c30088f6c3ebdddcdbdf9e0ef24f3bc7ae0756deb93da503\nF ext/misc/zorder.c b0ff58fa643afa1d846786d51ea8d5c4b6b35aa0254ab5a82617db92f3adda64\nF ext/rbu/rbu.c 8681f6157db6adc82c34af24b14ea8a3be0146ad2a3b6c1d5da6cb8a5796c8ce\nF ext/rbu/rbu1.test 221d9c18a5e600ac9ac6b1810d99d9f99163a7909ba61597876ab6e4d4beb3d6\nF ext/rbu/rbu10.test 0a201c32202143f23c81c0144503da339786fc20acb7a2fda11601b65659f314\nF ext/rbu/rbu11.test 5c834cf491086b45e071eabf71f708febc143e86a384a92de69e0b1a4cace144\nF ext/rbu/rbu12.test 29f8b2118f6c96fac3755bd6d2b55c2db24f878b1f11fbfbe294f3a230a3dcdc\nF ext/rbu/rbu13.test 1285298e3360ec74511764841b3c174dcfe21da2f618c22febf1a20abd0365c2\nF ext/rbu/rbu14.test 4a7bf0b3a4516d3ab0bc0ba4ceb53eb7e3324147ccda152e561060f659dbba31\nF ext/rbu/rbu3.test d6c6cc7a1326e8e23b9820f30bd3054f22092e503fadfd2a660ae006653f6d80\nF ext/rbu/rbu5.test 724b38ea5f722e3d22dc76343860bd998bb676c3f78c4bc8175df5c5d7720e23\nF ext/rbu/rbu6.test 401064236d3cf86b7edc01c586d7c5554f48553946fbfa1a3af35d7e47dce9e3\nF ext/rbu/rbu7.test ae25f47b56f178197fc1098537a35a39176cc73d1629b03dc9d795929fc36ec2\nF ext/rbu/rbu8.test b98a6fc58ead84a0e6ddee775b9702cd981f318d5d4fd1d4df0fa0c40db7251b\nF ext/rbu/rbu9.test 0e4d985e25620d61920597e8ea69c871c9e8c1f5a0be2ae9fa70bb641d74378c\nF ext/rbu/rbuA.test b34a90cb495682c25b5fc03a9d5e7a4fc99541c29256f25e2e2a4f6542b4f5b3\nF ext/rbu/rbuB.test 52b07158824c6927b7e25554ace92a695cdebfc296ae3d308ac386984aded9bc\nF ext/rbu/rbuC.test 80f1cc2fb74f44b1128fd0ed8eedab3a76fefeb72a947860e2869ef76fc8dc6b\nF ext/rbu/rbu_common.tcl 60d904133ff843fe72cc0514e9dd2486707181e6e0fbab20979da28c48d21de9\nF ext/rbu/rbucollate.test cac528a9a46318cba42e61258bb42660bbbf4fdb9a8c863de5a54ad0c658d197\nF ext/rbu/rbucrash.test 000981a1fe8a6e4d9a684232f6a129e66a3ef595f5ed74655e2f9c68ffa613b4\nF ext/rbu/rbucrash2.test efa143cc94228eb0266d3f1abfbee60a5838a84cef7cc3fcb8c145b74d96fd41\nF ext/rbu/rbudiff.test 156957851136b63c143478518dc1bda6c832103cdbe8ac1d7cdd47edb3cbe0a3\nF ext/rbu/rbudor.test e3e8623926012f43eebe51fedf06a102df2640750d971596b052495f2536db20\nF ext/rbu/rbuexpr.test 10d0420537c3bc7666e576d72adeffe7e86cfbb00dcc30aa9ce096c042415190\nF ext/rbu/rbufault.test 2d7f567b79d558f6e093c58808cab4354f8a174e3802f69e7790a9689b3c09f8\nF ext/rbu/rbufault2.test c81327a3ac2c385b9b954db3644d4e0df93eeebfc3de9f1f29975a1e73fd3d0c\nF ext/rbu/rbufault3.test b2fcc9db5c982b869f67d1d4688d8cb515d5b92f58011fff95665f2e62cec179\nF ext/rbu/rbufault4.test 03d2849c3df7d7bd14a622e789ff049e5080edd34a79cd432e01204db2a5930a\nF ext/rbu/rbufts.test 0ae8d1da191c75bd776b86e24456db0fb6e97b7c944259fae5407ea55d23c31d\nF ext/rbu/rbumisc.test 329986cf5dd51890c4eb906c2f960ebb773a79a64bed90f506b7c417825b37eb\nF ext/rbu/rbumulti.test 5fb139058f37ddc5a113c5b93238de915b769b7792de41b44c983bc7c18cf5b9\nF ext/rbu/rbupartial.test f25df014b8dbe3c5345851fba6e66f79ab237f57dc201b2d5f0dbae658ae5a4c\nF ext/rbu/rbuprogress.test 857cf1f8166c83ef977edb9ef4fc42d80f71fbd798652b46ae2f3a7031870f8d\nF ext/rbu/rburesume.test dbdc4ca504e9c76375a69e5f0d91205db967dcc509a5166ca80231f8fda49eb1\nF ext/rbu/rbusave.test f4190a1a86fccf84f723af5c93813365ae33feda35845ba107b59683d1cdd926\nF ext/rbu/rbusplit.test b37e7b40b38760881dc9c854bd40b4744c6b6cd74990754eca3bda0f407051e8\nF ext/rbu/rbutemplimit.test 05ceefa90a2e26a99f40dd48282ed63a00df5e59c1f2bfd479c143e201a1b0ba\nF ext/rbu/rbuvacuum.test 55e101e90168c2b31df6c9638fe73dc7f7cc666b6142266d1563697d79f73534\nF ext/rbu/rbuvacuum2.test b8e5b51dc8b2c0153373d024c0936be3f66f9234acbd6d0baab0869d56b14e6b\nF ext/rbu/rbuvacuum3.test 8addd82e4b83b4c93fa47428eae4fd0dbf410f8512c186f38e348feb49ba03dc\nF ext/rbu/rbuvacuum4.test a78898e438a44803eb2bc897ba3323373c9f277418e2d6d76e90f2f1dbccfd10\nF ext/rbu/sqlite3rbu.c f3a3e09f575157052813be667d6ab3b54f47fb02e6e1c9f767ad7bb8f1fb90b3\nF ext/rbu/sqlite3rbu.h 1dc88ab7bd32d0f15890ea08d23476c4198d3da3056985403991f8c9cd389812\nF ext/rbu/test_rbu.c 03f6f177096a5f822d68d8e4069ad8907fe572c62ff2d19b141f59742821828a\nF ext/repair/README.md 92f5e8aae749a4dae14f02eea8e1bb42d4db2b6ce5e83dbcdd6b1446997e0c15\nF ext/repair/checkfreelist.c 0dbae18c1b552f58d64f8969e4fb1e7f11930c60a8c2a9a8d50b7f15bdfd54bd\nF ext/repair/checkindex.c 7d28c01a2e012ac64257d230fc452b2cafb78311a91a343633d01d95220f66f3\nF ext/repair/sqlite3_checker.c.in 4a5a3af3f450fe503e5a2985e98516dc2a6b9ad247449e284c1cf140fc91720f\nF ext/repair/sqlite3_checker.tcl a9a2caa9660567257c177a91124d8c0dccdfa341e25c51e6da7f1fd9e601eafa\nF ext/repair/test/README.md 34b2f542cf5be7bffe479242b33ee3492cea30711e447cc4a1a86cb5915f419e\nF ext/repair/test/checkfreelist01.test 3e8aa6aeb4007680c94a8d07b41c339aa635cc78249442da72ff3f8297398a69\nF ext/repair/test/checkindex01.test b530f141413b587c9eb78ff734de6bb79bc3515c335096108c12c01bddbadcec\nF ext/repair/test/test.tcl 686d76d888dffd021f64260abf29a55c57b2cedfa7fc69150b42b1d6119aac3c\nF ext/rtree/README 6315c0d73ebf0ec40dedb5aa0e942bc8b54e3761\nF ext/rtree/geopoly.c c591164125808f8bba9659e92665b78412cd263e654b6f05294f3a8da7cdd9fb\nF ext/rtree/rtree.c 26fcb3f7a92fda9afcf5eee684cc3188b7367da69bc9c374492d844fb8ed4e25\nF ext/rtree/rtree.h 4a690463901cb5e6127cf05eb8e642f127012fd5003830dbc974eca5802d9412\nF ext/rtree/rtree1.test 4092a8bd2b5eafc4fafe4fe9024249c12b13e4bab23c2c3eaff57412fdf805fa\nF ext/rtree/rtree2.test 9d9deddbb16fd0c30c36e6b4fdc3ee3132d765567f0f9432ee71e1303d32603d\nF ext/rtree/rtree3.test 4ee5d7df86040efe3d8d84f141f2962a7745452200a7cba1db06f86d97050499\nF ext/rtree/rtree4.test 304de65d484540111b896827e4261815e5dca4ce28eeecd58be648cd73452c4b\nF ext/rtree/rtree5.test 49c9041d713d54560b315c2c7ef7207ee287eba1b20f8266968a06f2e55d3142\nF ext/rtree/rtree6.test 1252a0439da01d2f1f5cbbdeeb80455a2d68b9bae2a9787937b167a5e3957828\nF ext/rtree/rtree7.test c8fb2e555b128dd0f0bdb520c61380014f497f8a23c40f2e820acc9f9e4fdce5\nF ext/rtree/rtree8.test 2d99006a1386663978c9e1df167554671e4f711c419175b39f332719deb1ce0e\nF ext/rtree/rtree9.test c646f12c8c1c68ef015c6c043d86a0c42488e2e68ed1bb1b0771a7ca246cbabf\nF ext/rtree/rtreeA.test ed2f1be9c06dde0b1ab93a95dd9e87eeaa02db2d30bcb4b9179b69ee3dc3319b\nF ext/rtree/rtreeB.test 4cec297f8e5c588654bbf3c6ed0903f10612be8a2878055dd25faf8c71758bc9\nF ext/rtree/rtreeC.test 6aa87eba4d9a3003b941a1ba77db259c5cabc3fd92fc5a6360f5369520eb9a4d\nF ext/rtree/rtreeD.test fe46aa7f012e137bd58294409b16c0d43976c3bb92c8f710481e577c4a1100dc\nF ext/rtree/rtreeE.test e65d3fc625da1800b412fc8785817327d43ccfec5f5973912d8c9e471928caa9\nF ext/rtree/rtreeF.test 81ffa7ef51c4e4618d497a57328c265bf576990c7070633b623b23cd450ed331\nF ext/rtree/rtreeG.test 1b9ca6e3effb48f4161edaa463ddeaa8fca4b2526d084f9cbf5dbe4e0184939c\nF ext/rtree/rtreeH.test 0885151ee8429242625600ae47142cca935332c70a06737f35af53a7bd7aaf90\nF ext/rtree/rtreeI.test 608e77f7fde9be5a12eae316baef640fffaafcfa90a3d67443e78123e19c4ca4\nF ext/rtree/rtree_perf.tcl 6c18c1f23cd48e0f948930c98dfdd37dfccb5195\nF ext/rtree/rtree_util.tcl db734b4c5e75fed6acc56d9701f2235345acfdec750b5fc7b587936f5f6bceed\nF ext/rtree/rtreecheck.test d67d5b3e9e45bfa8cd90734e8e9302144ac415b8e9176c6f02d4f92892ee8a35\nF ext/rtree/rtreecirc.test aec664eb21ae943aeb344191407afff5d392d3ae9d12b9a112ced0d9c5de298e\nF ext/rtree/rtreeconnect.test 225ad3fcb483d36cbee423a25052a6bbae762c9576ae9268332360c68c170d3d\nF ext/rtree/rtreefuzz001.test eef1ed593bb15886cd5d5367a2f2492f81e315848896cdf7afb6e21454978827\nF ext/rtree/sqlite3rtree.h 03c8db3261e435fbddcfc961471795cbf12b24e03001d0015b2636b0f3881373\nF ext/rtree/tkt3363.test 142ab96eded44a3615ec79fba98c7bde7d0f96de\nF ext/rtree/util/randomshape.tcl 54ee03d0d4a1c621806f7f44d5b78d2db8fac26e0e8687c36c4bd0203b27dbff\nF ext/rtree/viewrtree.tcl eea6224b3553599ae665b239bd827e182b466024\nF ext/rtree/visual01.txt e9c2564083bcd30ec51b07f881bffbf0e12b50a3f6fced0c222c5c1d2f94ac66\nF ext/session/changeset.c 7a1e6a14c7e92d36ca177e92e88b5281acd709f3b726298dc34ec0fb58869cb5\nF ext/session/changesetfuzz.c 227076ab0ae4447d742c01ee88a564da6478bbf26b65108bf8fac9cd8b0b24aa\nF ext/session/changesetfuzz1.test 2e1b90d888fbf0eea5e1bd2f1e527a48cc85f8e0ff75df1ec4e320b21f580b3a\nF ext/session/session1.test 0b2f88995832ea040ae8e83a1ad4afa99c00b85c779d213da73a95ea4113233e\nF ext/session/session2.test 284de45abae4cc1082bc52012ee81521d5ac58e0\nF ext/session/session3.test ce9ce3dfa489473987f899e9f6a0f2db9bde3479\nF ext/session/session4.test 6778997065b44d99c51ff9cece047ff9244a32856b328735ae27ddef68979c40\nF ext/session/session5.test 716bc6fafd625ce60dfa62ae128971628c1a1169\nF ext/session/session6.test 443789bc2fca12e4f7075cf692c60b8a2bea1a26\nF ext/session/session8.test 8e194b3f655d861ca36de5d4de53f702751bab3b\nF ext/session/session9.test 5409d90d8141881d08285ed1c2c0d8d10fb92069\nF ext/session/sessionA.test 1feeab0b8e03527f08f2f1defb442da25480138f\nF ext/session/sessionB.test c4fb7f8a688787111606e123a555f18ee04f65bb9f2a4bb2aa71d55ce4e6d02c\nF ext/session/sessionC.test f8a5508bc059ae646e5ec9bdbca66ad24bc92fe99fda5790ac57e1f59fce2fdf\nF ext/session/sessionD.test 4f91d0ca8afc4c3969c72c9f0b5ea9527e21de29039937d0d973f821e8470724\nF ext/session/sessionE.test b2010949c9d7415306f64e3c2072ddabc4b8250c98478d3c0c4d064bce83111d\nF ext/session/sessionF.test d37ed800881e742c208df443537bf29aa49fd56eac520d0f0c6df3e6320f3401\nF ext/session/sessionG.test 3828b944cd1285f4379340fd36f8b64c464fc84df6ff3ccbc95578fd87140b9c\nF ext/session/sessionH.test a417559f29a7e775950fc5fc82b3d01256a7cbe793ddf1180df234df823d56e2\nF ext/session/session_common.tcl 29ec9910aca1e996ca1c8531b8cecabf96eb576aa53de65a8ff03d848b9a2a8b\nF ext/session/session_speed_test.c dcf0ef58d76b70c8fbd9eab3be77cf9deb8bc1638fed8be518b62d6cbdef88b3\nF ext/session/sessionat.test efe88965e74ff1bc2af9c310b28358c02d420c1fb2705cc7a28f0c1cc142c3ec\nF ext/session/sessiondiff.test ad13dd65664bae26744e1f18eb3cbd5588349b7e9118851d8f9364248d67bcec\nF ext/session/sessionfault.test da273f2712b6411e85e71465a1733b8501dbf6f7\nF ext/session/sessionfault2.test dd593f80b6b4786f7adfe83c5939620bc505559770cc181332da26f29cddd7bb\nF ext/session/sessioninvert.test ae1a003a9ab1f8d64227dbb5c3a4c97e65b561b01e7b2953cf48683fb2724169\nF ext/session/sessionrebase.test ccfa716b23bd1d3b03217ee58cfd90c78d4b99f53e6a9a2f05e82363b9142810\nF ext/session/sessionstat1.test 218d351cf9fcd6648f125a26b607b140310160184723c2666091b54450a68fb5\nF ext/session/sessionwor.test 67b5ab91d4f93ce65ff1f58240ac5ddf73f8670facc1ffa49cef56293d52818d\nF ext/session/sqlite3session.c a4dfb372f270df93422b0dc7666fd46849e6979b62a152f11287c21eed4ac21b\nF ext/session/sqlite3session.h a2db5b72b938d12c727b4b4ec632254ca493670a9c0de597af3271a7f774fc57\nF ext/session/test_session.c 98797aba475a799376c9a42214f2d1debf2d0c3cb657d9c8bbf4f70bf3fb4aec\nF ext/userauth/sqlite3userauth.h 7f3ea8c4686db8e40b0a0e7a8e0b00fac13aa7a3\nF ext/userauth/user-auth.txt e6641021a9210364665fe625d067617d03f27b04\nF ext/userauth/userauth.c f81aa5a3ecacf406f170c62a144405858f6f6de51dbdc0920134e629edbe2648\nF install-sh 9d4de14ab9fb0facae2f48780b874848cbf2f895 x\nF ltmain.sh 3ff0879076df340d2e23ae905484d8c15d5fdea8\nF magic.txt 8273bf49ba3b0c8559cb2774495390c31fd61c60\nF main.mk 7ce055f3df31a4f7d21e38f493f907c21db1f673863a573e231f55e2ab005023\nF mkso.sh fd21c06b063bb16a5d25deea1752c2da6ac3ed83\nF mptest/config01.test 3c6adcbc50b991866855f1977ff172eb6d901271\nF mptest/config02.test 4415dfe36c48785f751e16e32c20b077c28ae504\nF mptest/crash01.test 61e61469e257df0850df4293d7d4d6c2af301421\nF mptest/crash02.subtest f4ef05adcd15d60e5d2bd654204f2c008b519df8\nF mptest/mptest.c aa41ace6dbc5050d76b02548d3521e6bbccae4f0\nF mptest/multiwrite01.test dab5c5f8f9534971efce679152c5146da265222d\nF spec.template 86a4a43b99ebb3e75e6b9a735d5fd293a24e90ca\nF sqlite.pc.in 42b7bf0d02e08b9e77734a47798d1a55a9e0716b\nF sqlite3.1 fc7ad8990fc8409983309bb80de8c811a7506786\nF sqlite3.pc.in 48fed132e7cb71ab676105d2a4dc77127d8c1f3a\nF src/alter.c 14b5516be5b3815d30bf230b619978f6158e754a1d624f70a02cfe2178348b5c\nF src/analyze.c b3ceec3fc052df8a96ca8a8c858d455dc5029ba681b4be98bb5c5a9162cfa58c\nF src/attach.c b30c44333d55a68c0a12920b5b9d40b254cbd3d4509bda77417209eeed8b3d80\nF src/auth.c a3d5bfdba83d25abed1013a8c7a5f204e2e29b0c25242a56bc02bb0c07bf1e06\nF src/backup.c f70077d40c08b7787bfe934e4d1da8030cb0cc57d46b345fba2294b7d1be23ab\nF src/bitvec.c 17ea48eff8ba979f1f5b04cc484c7bb2be632f33\nF src/btmutex.c 8acc2f464ee76324bf13310df5692a262b801808984c1b79defb2503bbafadb6\nF src/btree.c d22498af716953400e314d2d98d1dac3ea5c3b01e0fd243ef9e9b132c74114ec\nF src/btree.h f27a33c49280209a93385e218306c4ee5f46ba8d7649d2f81a7166b282232484\nF src/btreeInt.h 91806f01fd1145a9a86ba3042f25c38d8faf6002701bf5e780742cf88bcff437\nF src/build.c 358e894867394839679982d2fe320fb44fd17c94a87feb898aa066c15a8066ea\nF src/callback.c 88615dfc0a82167b65b452b4b305dbf86be77200b3343c6ffc6d03e92a01d181\nF src/complete.c a3634ab1e687055cd002e11b8f43eb75c17da23e\nF src/ctime.c 1b0724e66f95f33b160b1af85caaf9cceb325d22abf39bd24df4f54a73982251\nF src/date.c e1d8ac7102f3f283e63e13867acb0efa33861cf34f0faf4cdbaf9fa7a1eb7041\nF src/dbpage.c 135eb3b5e74f9ef74bde5cec2571192c90c86984fa534c88bf4a055076fa19b7\nF src/dbstat.c 6c407e549406c10fde9ac3987f6d734459205239ad370369bc5fcd683084a4fa\nF src/delete.c a5c59b9c0251cf7682bc52af0d64f09b1aefc6781a63592c8f1136f7b73c66e4\nF src/expr.c 5099de2d6cca77f7c3b5131e0035787fc64ca3d27c267020e7e8bec0e226336c\nF src/fault.c 460f3e55994363812d9d60844b2a6de88826e007\nF src/fkey.c 92a248ec0fa4ed8ab60c98d9b188ce173aaf218f32e7737ba77deb2a684f9847\nF src/func.c ed33e38cd642058182a31a3f518f2e34f4bbe53aa483335705c153c4d3e50b12\nF src/global.c a1a8d698762ddd9a1543aac26c1e0029b20fcc3fcb56bfa41ec8cea2368f2798\nF src/hash.c 8d7dda241d0ebdafb6ffdeda3149a412d7df75102cecfc1021c98d6219823b19\nF src/hash.h 9d56a9079d523b648774c1784b74b89bd93fac7b365210157482e4319a468f38\nF src/hwtime.h cb1d7e3e1ed94b7aa6fde95ae2c2daccc3df826be26fc9ed7fd90d1750ae6144\nF src/in-operator.md 10cd8f4bcd225a32518407c2fb2484089112fd71\nF src/insert.c 831408b14a146e93a4e02ddba54dcdfd8097463b9c00ca2ed9daed790c5d452a\nF src/legacy.c d7874bc885906868cd51e6c2156698f2754f02d9eee1bae2d687323c3ca8e5aa\nF src/loadext.c d74f5e7bd51f3c9d283442473eb65aef359664efd6513591c03f01881c4ae2da\nF src/main.c 868ae7db7a54fe859bf2ca8b7a4f24e9fa03a6134abfb7c9801d08411ef5dacb\nF src/malloc.c 550021fcae36f0ffe9f8563d83e6385f9df307a854d55d7d0abb7241ee8dbcc6\nF src/mem0.c 6a55ebe57c46ca1a7d98da93aaa07f99f1059645\nF src/mem1.c c12a42539b1ba105e3707d0e628ad70e611040d8f5e38cf942cee30c867083de\nF src/mem2.c f1940d9e91948dd6a908fbb9ce3835c36b5d83c3\nF src/mem3.c 8768ac94694f31ffaf8b4d0ea5dc08af7010a35a\nF src/mem5.c 9bf955937b07f8c32541c8a9991f33ce3173d944\nF src/memdb.c 02a5fcec19b9d40dd449ca802dc1b2e8f93f255fbf2a886277a3c3800d8d35db\nF src/memjournal.c 7561c01c90958f3ba9bc6cb2d857123d932bdfa5539ea34427a0957b2e35154d\nF src/msvc.h 3a15918220367a8876be3fa4f2abe423a861491e84b864fb2b7426bf022a28f8\nF src/mutex.c bae36f8af32c22ad80bbf0ccebec63c252b6a2b86e4d3e42672ff287ebf4a604\nF src/mutex.h a7b2293c48db5f27007c3bdb21d438873637d12658f5a0bf8ad025bb96803c4a\nF src/mutex_noop.c 9d4309c075ba9cc7249e19412d3d62f7f94839c4\nF src/mutex_unix.c aaf9ebc3f89df28483c52208497a99a02cc3650011422fc9d4c57e4392f7fe58\nF src/mutex_w32.c 7670d770c94bbfe8289bec9d7f1394c5a00a57c37f892aab6b6612d085255235\nF src/notify.c 9711a7575036f0d3040ba61bc6e217f13a9888e7\nF src/os.c 669cc3839cc35d20f81faf0be1ab6d4581cea35e9d8f3a9d48a98d6571f7c285\nF src/os.h 48388821692e87da174ea198bf96b1b2d9d83be5dfc908f673ee21fafbe0d432\nF src/os_common.h b2f4707a603e36811d9b1a13278bffd757857b85\nF src/os_setup.h 0dbaea40a7d36bf311613d31342e0b99e2536586\nF src/os_unix.c 3e0e519f27683083a465e948e056759a8340728c222b5c394a135e0c57c220bc\nF src/os_win.c 035a813cbd17f355bdcad7ab894af214a9c13a1db8aeac902365350b98cd45a7\nF src/os_win.h 7b073010f1451abe501be30d12f6bc599824944a\nF src/pager.c 30f20d2263d3717f41a0d9a40f7a3d0f48ce1cfab461b875c6187ead9d6ad1c7\nF src/pager.h 217921e81eb5fe455caa5cda96061959706bcdd29ddb57166198645ef7822ac3\nF src/parse.y c8d2de64db469fd56e0fa24da46cd8ec8523eb98626567d2708df371b47fdc3f\nF src/pcache.c 385ff064bca69789d199a98e2169445dc16e4291fa807babd61d4890c3b34177\nF src/pcache.h 4f87acd914cef5016fae3030343540d75f5b85a1877eed1a2a19b9f284248586\nF src/pcache1.c 6596e10baf3d8f84cc1585d226cf1ab26564a5f5caf85a15757a281ff977d51a\nF src/pragma.c 26e9ee514138b9697d4be6d8f9ca84655053026390cf10de838862238aa4aba9\nF src/pragma.h ec3b31eac9b1df040f1cc8cb3d89bc06605c3b4cb3d76f833de8d6d6c3f77f04\nF src/prepare.c 6049beb71385f017af6fc320d2c75a4e50b75e280c54232442b785fbb83df057\nF src/printf.c 9be6945837c839ba57837b4bc3af349eba630920fa5532aa518816defe42a7d4\nF src/random.c 80f5d666f23feb3e6665a6ce04c7197212a88384\nF src/resolve.c 86a7773d2892227ba9ad1721c41bb03c501830f1bf6de5f78dd0062b82e10c9d\nF src/rowset.c d977b011993aaea002cab3e0bb2ce50cf346000dff94e944d547b989f4b1fe93\nF src/select.c dd7e40967760b28efe274ade35043d5bf5d72774208bb75d2cb4dd59cbd59ad1\nF src/shell.c.in 4a3a9e1c11847b1904f2b01d087af1c052f660902755abab457cab1756817ded\nF src/sqlite.h.in 2a23e8161775253d9cf383c2c6aa559005dc787d350dcb0be67a6c4cc3bd1d19\nF src/sqlite3.rc 5121c9e10c3964d5755191c80dd1180c122fc3a8\nF src/sqlite3ext.h 72af51aa4e912e14cd495fb6e7fac65f0940db80ed950d90911aff292cc47ce2\nF src/sqliteInt.h 60d92fad64da7c3e77bbc35ee306340814cdaa5df32892b0ec58d306d99b5733\nF src/sqliteLimit.h 1513bfb7b20378aa0041e7022d04acb73525de35b80b252f1b83fedb4de6a76b\nF src/status.c 46e7aec11f79dad50965a5ca5fa9de009f7d6bde08be2156f1538a0a296d4d0e\nF src/table.c b46ad567748f24a326d9de40e5b9659f96ffff34\nF src/tclsqlite.c 8cd2600e8de23dff6cdf84d39f46ca57139b061b28f6f80b166bace17d52ab1c\nF src/test1.c c654981c1d86ebc90dd23fcc0969e6c85e28112f0acc2e2224a97a2a33e7c42f\nF src/test2.c 3efb99ab7f1fc8d154933e02ae1378bac9637da5\nF src/test3.c 61798bb0d38b915067a8c8e03f5a534b431181f802659a6616f9b4ff7d872644\nF src/test4.c 405834f6a93ec395cc4c9bb8ecebf7c3d8079e7ca16ae65e82d01afd229694bb\nF src/test5.c 328aae2c010c57a9829d255dc099d6899311672d\nF src/test6.c e8d839fbc552ce044bec8234561a2d5b8819b48e29548ad0ba400471697946a8\nF src/test7.c 5612e9aecf934d6df7bba6ce861fdf5ba5456010\nF src/test8.c 3f7d0cc4e12e06832ba3db4455cb16867ccadafa602eb6ff5fcf097bffce56ed\nF src/test9.c 12e5ba554d2d1cbe0158f6ab3f7ffcd7a86ee4e5\nF src/test_async.c 195ab49da082053fdb0f949c114b806a49ca770a\nF src/test_autoext.c 915d245e736652a219a907909bb6710f0d587871\nF src/test_backup.c bf5da90c9926df0a4b941f2d92825a01bbe090a0\nF src/test_bestindex.c 78809f11026f18a93fcfd798d9479cba37e1201c830260bf1edc674b2fa9b857\nF src/test_blob.c ae4a0620b478548afb67963095a7417cd06a4ec0a56adb453542203bfdcb31ce\nF src/test_btree.c 8b2dc8b8848cf3a4db93f11578f075e82252a274\nF src/test_config.c e25826d693039cdd45963de378cbf39e3af0e8aa7a8a6fc159876f4e7b5a4f8c\nF src/test_delete.c e2fe07646dff6300b48d49b2fee2fe192ed389e834dd635e3b3bac0ce0bf9f8f\nF src/test_demovfs.c 86142ba864d4297d54c5b2e972e74f3141ae4b30f05b3a95824184ed2d3d7f91\nF src/test_devsym.c 6109b45c3db3ef7b002320947ed448c027356ab8b885156ff535fd8684d4a571\nF src/test_fs.c ba1e1dc18fd3159fdba0b9c4256f14032159785320dfbd6776eb9973cb75d480\nF src/test_func.c 181f992e5495644434c4f0e3cc72362a78c295eb2cf3ff4d02498b8bde7aa276\nF src/test_hexio.c d170d0e1a6431afdeac086a250d2595078288c2257615d37949355361399bcaa\nF src/test_init.c 4413c211a94b62157ca4c145b3f27c497f03c664\nF src/test_intarray.c 39b4181662a0f33a427748d87218e7578d913e683dc27eab7098bb41617cac71\nF src/test_intarray.h d57ae92f420cda25e22790dac474d60961bd0c500cbaa3338a05152d4a669ef7\nF src/test_journal.c a0b9709b2f12b1ec819eea8a1176f283bca6d688a6d4a502bd6fd79786f4e287\nF src/test_loadext.c 337056bae59f80b9eb00ba82088b39d0f4fe6dfd\nF src/test_malloc.c dec0aa821b230773aeb3dd11d652c1193f7cedb18a20b25659bc672288115242\nF src/test_md5.c 7268e1e8c399d4a5e181b64ac20e1e6f3bc4dd9fc87abac02db145a3d951fa8c\nF src/test_multiplex.c e054459f7633f3ff8ce1245da724f9a8be189e4e\nF src/test_multiplex.h 5436d03f2d0501d04f3ed50a75819e190495b635\nF src/test_mutex.c 7f4337ba23ee6b1d2ec81c189653608cb069926a\nF src/test_onefile.c f31e52e891c5fef6709b9fcef54ce660648a34172423a9cbdf4cbce3ba0049f4\nF src/test_osinst.c 98ef31ff03d55497829ca0f6c74a9f4e1aa48690\nF src/test_pcache.c a5cd24730cb43c5b18629043314548c9169abb00\nF src/test_quota.c 6cb9297115b551f433a9ad1741817a9831abed99\nF src/test_quota.h 2a8ad1952d1d2ca9af0ce0465e56e6c023b5e15d\nF src/test_rtree.c 671f3fae50ff116ef2e32a3bf1fe21b5615b4b7b\nF src/test_schema.c f575932cb6274d12147a77e13ea4b49d52408513\nF src/test_server.c a2615049954cbb9cfb4a62e18e2f0616e4dc38fe\nF src/test_sqllog.c 11e6ce7575f489155c604ac4b439f2ac1d3d5aef\nF src/test_superlock.c 4839644b9201da822f181c5bc406c0b2385f672e\nF src/test_syscall.c 1073306ba2e9bfc886771871a13d3de281ed3939\nF src/test_tclsh.c eeafce33ad2136d57e5dec10f1e9a4347447eb72ffd504a1c7b9c6bfe2e71578\nF src/test_tclvar.c 33ff42149494a39c5fbb0df3d25d6fafb2f668888e41c0688d07273dcb268dfc\nF src/test_thread.c 911d15fb14e19c0c542bdc8aabf981c2f10a4858\nF src/test_vdbecov.c f60c6f135ec42c0de013a1d5136777aa328a776d33277f92abac648930453d43\nF src/test_vfs.c 36822d696789535bdd0260f07d2c9a46546082fea8bb1d0a7354c7f9366e37ea\nF src/test_vfstrace.c bab9594adc976cbe696ff3970728830b4c5ed698\nF src/test_windirent.c a895e2c068a06644eef91a7f0a32182445a893b9a0f33d0cdb4283dca2486ac1\nF src/test_windirent.h 90dfbe95442c9762357fe128dc7ae3dc199d006de93eb33ba3972e0a90484215\nF src/test_window.c cdae419fdcea5bad6dcd9368c685abdad6deb59e9fc8b84b153de513d394ba3f\nF src/test_wsd.c 41cadfd9d97fe8e3e4e44f61a4a8ccd6f7ca8fe9\nF src/threads.c 4ae07fa022a3dc7c5beb373cf744a85d3c5c6c3c\nF src/tokenize.c 7b17f6e2f20f6cbcb0b215025a86b7457c38451fc7622f705e553d7a488c572d\nF src/treeview.c 41d928f04d65931b15f629b4938e9f2c7dc259f02eef34cb2cc6e293f5af813f\nF src/trigger.c 681ccdb910a87243940d63f99b26190d9c5d2534c2ded3c0825b7c0e315a342e\nF src/update.c 07a50767f7d3e26d4c887c31cd66448d700d3215caea6023acf7269336097df7\nF src/upsert.c b445315c8958d8f17ec3297d06842e61dacaad0633ccaec1e4e160de7e562212\nF src/utf.c 2f0fac345c7660d5c5bd3df9e9d8d33d4c27f366bcfb09e07443064d751a0507\nF src/util.c 2c92bc706bbdb1c45a25180291e7e05a56e297aa5dd7b2bcd2b1c47e8bb05b17\nF src/vacuum.c 82dcec9e7b1afa980288718ad11bc499651c722d7b9f32933c4d694d91cb6ebf\nF src/vdbe.c ab3f6e647235fe4fa16b71496468313a1da435eb3a2125c3ffdbb0be0d1cbcba\nF src/vdbe.h fdbc0a11e5768a702b46ce63286f60e22e71351a29bd98b3666405e1fccc7802\nF src/vdbeInt.h bd589b8b7273286858950717e0e1ec5c88b18af45079a3366dc1371865cea704\nF src/vdbeapi.c 1252d80c548711e47a6d84dae88ed4e95d3fbb4e7bd0eaa1347299af7efddf02\nF src/vdbeaux.c 858bb43a9d98846cc23fa8c8d0970ada805dd75bc6a01b69e972da608f7f59b1\nF src/vdbeblob.c 253ed82894924c362a7fa3079551d3554cd1cdace39aa833da77d3bc67e7c1b1\nF src/vdbemem.c 2eb00a4d1a7d2c97510a4d1ccaf4e12c9143f2ced1c6b96b5eddc372183c9121\nF src/vdbesort.c a3be032cc3fee0e3af31773af4a7a6f931b7230a34f53282ccf1d9a2a72343be\nF src/vdbetrace.c fa3bf238002f0bbbdfb66cc8afb0cea284ff9f148d6439bc1f6f2b4c3b7143f0\nF src/vtab.c 2736f853a1bd270581f76bae8e5d2e840b6258f3d85c1fa382e9454b3c414d1d\nF src/vxworks.h d2988f4e5a61a4dfe82c6524dd3d6e4f2ce3cdb9\nF src/wal.c 15a2845769f51ba132f9cf0b2c7a6887a91fc8437892dbcce9fcdc68b66d60a1\nF src/wal.h 606292549f5a7be50b6227bd685fa76e3a4affad71bb8ac5ce4cb5c79f6a176a\nF src/walker.c a137468bf36c92e64d2275caa80c83902e3a0fc59273591b96c6416d3253d05d\nF src/where.c c51ebd505c8417285ca1db8f94933a12224bf636ad93f27d821c07f93d59c035\nF src/whereInt.h 4a296fd4fa79fdcbc2b5e8c1b898901617655811223e1082b899c23ecb092217\nF src/wherecode.c 7efa97f4dc2f95548611deba68f0210ab357725899a9bae5391a525e48271875\nF src/whereexpr.c 39b6a538804c6e1248c22b33e09d00f89ae6a099c849c4d841ce3995562287b4\nF src/window.c da010455914c81037dcb5b0c6f4273f8a32c94567865c46a60060b937b018a96\nF test/8_3_names.test ebbb5cd36741350040fd28b432ceadf495be25b2\nF test/affinity2.test ce1aafc86e110685b324e9a763eab4f2a73f737842ec3b687bd965867de90627\nF test/affinity3.test 6a101af2fc945ce2912f6fe54dd646018551710d\nF test/aggerror.test a867e273ef9e3d7919f03ef4f0e8c0d2767944f2\nF test/aggnested.test 12106f0748e8e9bfc1a8e6840e203e051eae06a26ed13fc9fd5db108a8d6db54\nF test/alias.test 4529fbc152f190268a15f9384a5651bbbabc9d87\nF test/all.test 2ecb8bbd52416642e41c9081182a8df05d42c75637afd4488aace78cc4b69e13\nF test/alter.test 16ed8d2470193f34bc711e51506ff1211ebfab8025ca3b9510ff2aef139874cb\nF test/alter2.test a966ccfcddf9ce0a4e0e6ff1aca9e6e7948e0e242cd7e43fc091948521807687\nF test/alter3.test 9351a9f0c59ff9dddecccaaa2f777ffee5369870c63d30d3a74add815254ec0f\nF test/alter4.test 74b22251c5e9c48093cfc4921ed9c11b59df84634aeeb00e501773320beb8424\nF test/alterauth.test 63442ba61ceb0c1eeb63aac1f4f5cebfa509d352276059d27106ae256bafc959\nF test/alterauth2.test c0a1ddf5b93d93cb0d15ba7acaf0c5c6fb515bbe861ede75b2d3fabad33b6499\nF test/altercol.test 54374d2ba18af25bb24e23acf18a60270d4ec120b7ec0558078b59d5aa1a31ad\nF test/alterlegacy.test 82022721ce0de29cedc9a7af63bc9fcc078b0ee000f8283b4b6ea9c3eab2f44b\nF test/altermalloc.test 167a47de41b5c638f5f5c6efb59784002b196fff70f98d9b4ed3cd74a3fb80c9\nF test/altermalloc2.test fa7b1c1139ea39b8dec407cf1feb032ca8e0076bd429574969b619175ad0174b\nF test/altertab.test 4d8b79b0b88b62b90b710390df14fe99e0a3578345526886eaa550e28e3065dc\nF test/altertab2.test 8883693952f6d7fb5f754dbf1d694ed780aa883027bef04cb1fb99a3b88c9272\nF test/altertab3.test 231881a8e9c4905a84213476c64c174a119e1ab75ce17d986dcbbacc07b2b544\nF test/amatch1.test b5ae7065f042b7f4c1c922933f4700add50cdb9f\nF test/analyze.test 547bb700f903107b38611b014ca645d6b5bb819f5210d7bf39c40802aafeb7d7\nF test/analyze3.test 01f0b122e3e54ad2544f14f7cc7dcb4c2cb8753cad5e88c6b8d49615b3fd6a2b\nF test/analyze4.test cdf88f3f72b0f0643a1ff6c730fc5af1e42464d47478d9fbac84c333f72c014e\nF test/analyze5.test fa5131952303ac4146aba101b116b9c8cb89e2637531c334a6df7f7d19dddc0d\nF test/analyze6.test 6c3f7df2996cb6872f355a6ac1eb6d5de00a5a9288214bad7ef25c97d9cc72dc\nF test/analyze7.test 6ef0b12369f61ddeadc7d8a705c40e6b52cb29f63de3a4c56581b510b46b5783\nF test/analyze8.test 36ce54947710bd44e4f9484e1ad07e725ef01a9d7078b417c1bc884356febe4d\nF test/analyze9.test 9fbf0e0101eef4f5dc149769aa14e10b76ee06e7c28598264b32173cd1999a54\nF test/analyzeC.test 489fe2ea3be3f17548e8dd895f1b41c9669b52de1b0861f5bffe6eec46eac710\nF test/analyzeD.test e50cd0b3e6063216cc0c88a1776e8645dc0bd65a6bb275769cbee33b7fd8d90c\nF test/analyzeE.test 8684e8ac5722fb97c251887ad97e5d496a98af1d\nF test/analyzeF.test 9e1a0537949eb5483642b1140a5c39e5b4025939024b935398471fa552f4dabb\nF test/analyzer1.test 459fa02c445ddbf0101a3bad47b34290a35f2e49\nF test/async.test 1d0e056ba1bb9729283a0f22718d3a25e82c277b\nF test/async2.test c0a9bd20816d7d6a2ceca7b8c03d3d69c28ffb8b\nF test/async3.test d73a062002376d7edc1fe3edff493edbec1fc2f7\nF test/async4.test 1787e3952128aa10238bf39945126de7ca23685a\nF test/async5.test 383ab533fdb9f7ad228cc99ee66e1acb34cc0dc0\nF test/atof1.test ff0b0156fd705b67c506e1f2bfe9e26102bea9bd\nF test/atomic.test 065a453dde33c77ff586d91ccaa6ed419829d492dbb1a5694b8a09f3f9d7d061\nF test/atomic2.test b6863b4aa552543874f80b42fb3063f1c8c2e3d8e56b6562f00a3cc347b5c1da\nF test/atrc.c ec92d56d8fbed9eb3e11aaf1ab98cf7dd59e69dae31f128013f1d97e54e7dfed\nF test/attach.test 21bce8681f780a8d631a5ec7ecd0d849bfe84611257b038ae4ffeccc609d8a4e\nF test/attach2.test 256bd240da1835fb8408dd59fb7ef71f8358c7a756c46662434d11d07ba3a0ce\nF test/attach3.test c59d92791070c59272e00183b7353eeb94915976\nF test/attach4.test aa05b1d8218b24eba5a7cccf4f224f514ba57ba705c9267f09d2bb63fed0eea1\nF test/attachmalloc.test 12c4f028e570acf9e0a4b0b7fe6f536e21f3d5ebddcece423603d0569beaf438\nF test/auth.test 2154625c05bc79f0e0ea72cb2358395a8041243caa0fd7ce7617d50da4331794\nF test/auth2.test 9eb7fce9f34bf1f50d3f366fb3e606be5a2000a1\nF test/auth3.test db21405b95257c24d29273b6b31d0efc59e1d337e3d5804ba2d1fd4897b1ae49\nF test/autoanalyze1.test b9cc3f32a990fa56669b668d237c6d53e983554ae80c0604992e18869a0b2dec\nF test/autoinc.test 997d6f185f138229dc4251583a1d04816423dddc2fc034871a01aeb1d728cb39\nF test/autoindex1.test 96185415f5faacd5b8d7a7f505efddd5abb1f111d58338e9c0b1dc40b87cd3cc\nF test/autoindex2.test 12ef578928102baaa0dc23ad397601a2f4ecb0df\nF test/autoindex3.test 2dd997d6590438b53e4f715f9278aa91c9299cf3f81246a0915269c35beb790e\nF test/autoindex4.test 49d3cd791a9baa16fb461d7ea3de80d019a819cf\nF test/autoindex5.test a5d72fe8c217cc0ea356dc6fa06a282a8a3fc53aa807709d79dba07a8f248102\nF test/autovacuum.test 0831cd34e14695d297187f7f6519265e3121c5b0a1720e548e86829e796129e9\nF test/autovacuum_ioerr2.test 8a367b224183ad801e0e24dcb7d1501f45f244b4\nF test/avtrans.test b7dc25459ecbd86c6fa9c606ee3068f59d81e225118617dcf2bbb6ded2ade89e\nF test/backcompat.test 3e64cedda754c778ef6bbe417b6e7a295e662a4d\nF test/backup.test dd4a5ff756e3df3931dacb1791db0584d4bad989\nF test/backup2.test 1fd1ad8c5b3d2d5b9c0cce4143a4fc610d51ddc6ae16a7a122973d43e6b50bbd\nF test/backup4.test 8f6fd48e0dfde77b9a3bb26dc471ede3e101df32\nF test/backup5.test ee5da6d7fe5082f5b9b0bbfa31d016f52412a2e4\nF test/backup_ioerr.test 4c3c7147cee85b024ecf6e150e090c32fdbb5135\nF test/backup_malloc.test 0c9abdf74c51e7bedb66d504cd684f28d4bd4027\nF test/badutf.test d5360fc31f643d37a973ab0d8b4fb85799c3169f\nF test/badutf2.test f310fd3b24a491b6b77bccdf14923b85d6ebcce751068c180d93a6b8ff854399\nF test/bc_common.tcl b5e42d80305be95697e6370e015af571e5333a1c\nF test/bestindex1.test 705b57d7f51d53ee5fd043dd9666236e1fc18f4d59abf51da0ea5ea1b4804947\nF test/bestindex2.test 9a0ccd320b6525eec3a706aae6cdab7e1b7b5abca75027e39f39f755e76e5928\nF test/bestindex3.test 7622e792ff2da16d262d3cea6ad914591ac4806d57ed128e6c940b7920b47b84\nF test/bestindex4.test 038e3d0789332f3f1d61474f9bbc9c6d08c6bd1783a978f31f38ad82688de601\nF test/bestindex5.test 67c1166131bb59f9e47c00118f7d432ca5491e6cae6ca3f87ca9db20103a78f9\nF test/bestindex6.test d856a9bb63d927493575823eed44053bc36251e241aa364e54d0f2a2d302e1d4\nF test/between.test 68137a6e941c221417c15b6fe2d55f27bb1b6ab48bdf9e2aa51efdd85bc53802\nF test/bigfile.test aa74f4e5db51c8e54a1d9de9fa65d01d1eb20b59\nF test/bigfile2.test 1b489a3a39ae90c7f027b79110d6b4e1dbc71bfc\nF test/bigmmap.test 31dad31573638bd32de866cdefd11843f75685be4ba6aec1a47918f098f1899b\nF test/bigrow.test f0aeb7573dcb8caaafea76454be3ade29b7fc747\nF test/bigsort.test 8299fa9298f4f1e02fc7d2712e8b77d6cd60e5a2\nF test/bind.test 1e136709b306f7ed3192d349c2930d89df6ab621654ad6f1a72381d3fe76f483\nF test/bindxfer.test efecd12c580c14df5f4ad3b3e83c667744a4f7e0\nF test/bitvec.test 75894a880520164d73b1305c1c3f96882615e142\nF test/blob.test e7ac6c7d3a985cc4678c64f325292529a69ae252\nF test/boundary1.tcl 6421b2d920d8b09539503a8673339d32f7609eb1\nF test/boundary1.test 66d7f4706ccdb42d58eafdb081de07b0eb42d77b\nF test/boundary2.tcl e34ef4e930cf1083150d4d2c603e146bd3b76bcb\nF test/boundary2.test 9ae758d7dab7e882c8b6cc4a6a10278385bff8fa\nF test/boundary3.tcl 23361e108a125dca9c4080c2feb884fe54d69243\nF test/boundary3.test 56ef82096b4329aca2be74fa1e2b0f762ea0eb45\nF test/boundary4.tcl 0bb4b1a94f4fc5ae59b79b9a2b7a140c405e2983\nF test/boundary4.test 89e02fa66397b8a325d5eb102b5806f961f8ec4b\nF test/btree01.test e08b3613540145b353f20c81cb18ead54ff12e0f\nF test/btree02.test 7555a5440453d900410160a52554fe6478af4faf53098f7235f1f443d5a1d6cc\nF test/btreefault.test c2bcb542685eea44621275cfedbd8a13f65201e3\nF test/busy.test 510dc6daaad18bcbbc085bcc6217d6dc418def5e73f72ce1475eea0cb7834727\nF test/cache.test 13bc046b26210471ca6f2889aceb1ea52dc717de\nF test/cacheflush.test af25bb1509df04c1da10e38d8f322d66eceedf61\nF test/cachespill.test 895997f84a25b323b166aecb69baab2d6380ea98f9e0bcc688c4493c535cfab9\nF test/capi2.test 34a1a9a96d543a2ec2c209696b11b164444f57253b1f2cba1c2e53fadede6c7b\nF test/capi3.test 3910a73c38ac76d69778dd9eb481ab7cd6ed59117fc047b4f6056a5c72529de1\nF test/capi3b.test efb2b9cfd127efa84433cd7a2d72ce0454ae0dc4\nF test/capi3c.test 54e2dc0c8fd7c34ad1590d1be6864397da2438c95a9f5aee2f8fbc60c112e44b\nF test/capi3d.test aba917805573a03deed961a21f07a5a84505ad0a616f7e3fc1508844a15bccc4\nF test/capi3e.test 3d49c01ef2a1a55f41d73cba2b23b5059ec460fe\nF test/cast.test 3619f0c58c2e4b2a94aa86e75607e497d34ef40ab74418e71aef7b4ca5155895\nF test/cffault.test 9d6b20606afe712374952eec4f8fd74b1a8097ef\nF test/check.test 25c6035302c846c7ff8e681cf8284473f6f01be94d327de60a688ad84ab01f8b\nF test/checkfault.test da6cb3d50247169efcb20bdf57863a3ccfa1d27d9e55cd324f0680096970f014\nF test/chunksize.test 427d87791743486cbf0c3b8c625002f3255cb3a89c6eba655a98923b1387b760\nF test/close.test eccbad8ecd611d974cbf47278c3d4e5874faf02d811338d5d348af42d56d647c\nF test/closure01.test 9905883f1b171a4638f98fc764879f154e214a306d3d8daf412a15e7f3a9b1e0\nF test/coalesce.test cee0dccb9fbd2d494b77234bccf9dc6c6786eb91\nF test/collate1.test 4178fda6f4cd757b7a278e6b83805868fb1eb46edafb6e3d4bcc2419f8d93202\nF test/collate2.test 9aaa410a00734e48bcb27f3872617d6f69b2a621\nF test/collate3.test 89defc49983ddfbf0a0555aca8c0521a676f56a5\nF test/collate4.test c953715fb498b87163e3e73dd94356bff1f317bd\nF test/collate5.test 65d928034d30d2d263a80f6359f7549ee1598ec6\nF test/collate6.test 8be65a182abaac8011a622131486dafb8076e907\nF test/collate7.test 8ec29d98f3ee4ccebce6e16ce3863fb6b8c7b868\nF test/collate8.test cd9b3d3f999b8520ffaa7cc1647061fc5bab1334\nF test/collate9.test 3adcc799229545940df2f25308dd1ad65869145a\nF test/collateA.test b8218ab90d1fa5c59dcf156efabb1b2599c580d6\nF test/collateB.test 1e68906951b846570f29f20102ed91d29e634854ee47454d725f2151ecac0b95\nF test/colmeta.test 2c765ea61ee37bc43bbe6d6047f89004e6508eb1\nF test/colname.test 87ad5458bb8709312dac0d6755fd30e8e4ca83298d0a9ef6e5c24277a3c3390e\nF test/conflict.test 58857e2533fb9f2e0358ea7cb191215657846be1dd9da3b3d6df3e750c02ae03\nF test/conflict2.test bb0b94cf7196c64a3cbd815c66d3ee98c2fecd9c\nF test/conflict3.test f62a2d0cad9162a60e6458fc913dff3a2208feca924120c21737cfee65a6a74a\nF test/contrib01.test 2a1cbc0f2f48955d7d073f725765da6fbceda6b4\nF test/corrupt.test d7cb0300e4a297147b6a05e92a1684bc8973635c3bcaa3d66e983c9cbdbf47a3\nF test/corrupt2.test bb50042cf9a1f1023d73af325d47eb02a6bb11e3c52f8812644b220c5d4bca35\nF test/corrupt3.test f95d7bf78109e0b84eb285a787ce91a3fd6a2dd7d0cb55882abff3bdc081a57e\nF test/corrupt4.test 8d1d86b850fcc43e417450454f2044e52d55778a\nF test/corrupt5.test 387be3250795e2a86e6234745558b80efb248a357d0cd8e53bce75c7463f545d\nF test/corrupt6.test fc6a891716139665dae0073b6945e3670bf92568\nF test/corrupt7.test b036f94bda4b0b23a2919bf717046ce9ecca4543\nF test/corrupt8.test 2399dfe40d2c0c63af86706e30f3e6302a8d0516\nF test/corrupt9.test 730a3db08d4ab9aa43392ea30d9c2b4879cbff85\nF test/corruptA.test 112f4b2ae0b95ebf3ea63718642fb969a93acea557ace3a307234d19c245989b\nF test/corruptB.test 73a8d6c0b9833697ecf16b63e3c5c05c945b5dec\nF test/corruptC.test 74d4498fd25759618b393f1e9cde111de828b88c1848ab320f6c179fd52b5a60\nF test/corruptD.test 33a37ce3ed56a20093ceee778cd2d7109c7085a59f3213d2baede11d952e8e50\nF test/corruptE.test 4143791f2dfb443aec5b7fabfa5821e6063eccc3b49b06f212c2f014715fd476\nF test/corruptF.test be9fde98e4c93648f1ba52b74e5318edc8f59fe4\nF test/corruptG.test adf79b669cbfd19e28c8191a610d083ae53a6d51\nF test/corruptH.test 79801d97ec5c2f9f3c87739aa1ec2eb786f96454\nF test/corruptI.test a17bbf54fdde78d43cf3cc34b0057719fd4a173a3d824285b67dc5257c064c7b\nF test/corruptJ.test 4d5ccc4bf959464229a836d60142831ef76a5aa4\nF test/corruptK.test 5b4212fe346699831c5ad559a62c54e11c0611bdde1ea8423a091f9c01aa32af\nF test/corruptL.test a22a7bbf8da7603960f0bfcc62a68d1c3c41963786bd832ff804ba5e2458fb9c\nF test/corruptM.test 7d574320e08c1b36caa3e47262061f186367d593a7e305d35f15289cc2c3e067\nF test/cost.test 51f4fcaae6e78ad5a57096831259ed6c760e2ac6876836e91c00030fad385b34\nF test/count.test cb2e0f934c6eb33670044520748d2ecccd46259c\nF test/countofview.test e17d6e6688cf74f22783c9ec6e788c0790ee4fbbaee713affd00b1ac0bb39b86\nF test/coveridxscan.test 5ec98719a2e2914e8908dc75f7247d9b54a26df04625f846ac7900d5483f7296\nF test/crash.test fb9dc4a02dcba30d4aa5c2c226f98b220b2b959f\nF test/crash2.test 5b14d4eb58b880e231361d3b609b216acda86651\nF test/crash3.test 8f5de9d32ab9ab95475a9efe7f47a940aa889418\nF test/crash4.test fe2821baf37168dc59dd733dcf7dba2a401487bc\nF test/crash5.test f14ff37eddc41991be4eb63568f86caa306fd9962a0ae3750db8836777bb7aae\nF test/crash6.test 4c56f1e40d0291e1110790a99807aa875b1647ba\nF test/crash7.test 1a194c4900a255258cf94b7fcbfd29536db572df\nF test/crash8.test 64366e459c28dd62edfb7ad87253a409c7533b92d16fcc479a6a8131bdcc3100\nF test/crashM.test d95f59046fa749b0d0822edf18a717788c8f318d\nF test/crashtest1.c 09c1c7d728ccf4feb9e481671e29dda5669bbcc2\nF test/createtab.test 85cdfdae5c3de331cd888d6c66e1aba575b47c2e3c3cc4a1d6f54140699f5165\nF test/cse.test 277350a26264495e86b1785f34d2d0c8600e021c\nF test/csv01.test c9c3af0d58c34e9ac970c5875a77939edb958762c8aafb95409e19a3f088b6cd\nF test/ctime.test 78749e6c9a5f0010d67985be80788f841e3cd2da18114e2ed6010399a7d807f3\nF test/cursorhint.test 7bc346788390475e77a345da2b92270d04d35856\nF test/cursorhint2.test 6f3aa9cb19e7418967a10ec6905209bcbb5968054da855fc36c8beee9ae9c42f\nF test/dataversion1.test 6e5e86ac681f0782e766ebcb56c019ae001522d114e0e111e5ebf68ccf2a7bb8\nF test/date.test 9b73bbeb1b82d9c1f44dec5cf563bf7da58d2373\nF test/date2.test 5ef8265c71460cda6b1698bf18f4bb0ffb40ac08c5092f6afe84d398c2feb5be\nF test/dbdata.test 042f49acff3438f940eeba5868d3af080ae64ddf26ae78f80c92bec3ca7d8603\nF test/dbfuzz.c 73047c920d6210e5912c87cdffd9a1c281d4252e\nF test/dbfuzz001.test 42aad1dcef6219fbee86a9b7d08832c9bbb2e41508f6f128ae91745927276292\nF test/dbfuzz2-seed1.db e6225c6f3d7b63f9c5b6867146a5f329d997ab105bee64644dc2b3a2f2aebaee\nF test/dbfuzz2.c c2c9cb40082a77b7e95ffb8b2da1e93322efadfb1c8c1e0001c95a0af1e156c2\nF test/dbpage.test 650234ba683b9d82b899c6c51439819787e7609f17a0cc40e0080a7b6443bc38\nF test/dbstatus.test 4a4221a883025ffd39696b3d1b3910b928fb097d77e671351acb35f3aed42759\nF test/dbstatus2.test f5fe0afed3fa45e57cfa70d1147606c20d2ba23feac78e9a172f2fe8ab5b78ef\nF test/default.test 3e46c421eebefd2787c2f96673efabf792d360f3a1d5073918cbe450ce672a62\nF test/delete.test 31832b0c45ecb51a54348c68db173be462985901e6ed7f403d6d7a8f70ab4ef0\nF test/delete2.test 3a03f2cca1f9a67ec469915cb8babd6485db43fa\nF test/delete3.test 555e84a00a99230b7d049d477a324a631126a6ab\nF test/delete4.test 6aa279f459f4aa792cc251435c3809415c1ecaf9f27dce91675e26f05b503db3\nF test/delete_db.test 096d828493c7907f9ea11a7098ea6a0f73edba89406487d5d6cc2228dc4ab8b0\nF test/descidx1.test edc8adee58d491b06c7157c50364eaf1c3605c9c19f8093cb1ea2b6184f3ac13\nF test/descidx2.test a0ba347037ff3b811f4c6ceca5fd0f9d5d72e74e59f2d9de346a9d2f6ad78298\nF test/descidx3.test 953c831df7ea219c73826dfbf2f6ee02d95040725aa88ccb4fa43d1a1999b926\nF test/diskfull.test 106391384780753ea6896b7b4f005d10e9866b6e\nF test/distinct.test a1783b960ad8c15a77cd9f207be072898db1026c\nF test/distinct2.test 11b0594c932098e969d084ba45ab81d5040f4d4e766db65d49146705a305ed98\nF test/distinctagg.test 1a6ef9c87a58669438fc771450d7a72577417376\nF test/e_blobbytes.test 439a945953b35cb6948a552edaec4dc31fd70a05\nF test/e_blobclose.test 4b3c8c60c2171164d472059c73e9f3c1844bb66d\nF test/e_blobopen.test e95e1d40f995056f6f322cd5e1a1b83a27e1a145\nF test/e_blobwrite.test f87ff598b67af5b3ec002a8d83e804dc8d23808e88cf0080c176612fc9ffce14\nF test/e_changes.test fd66105385153dbf21fdb35eb8ef6c3e1eade579\nF test/e_createtable.test 1c602347e73ab80b11b9fa083f47155861aaafcff8054aac9e0b76d0df33b0a7\nF test/e_delete.test ab39084f26ae1f033c940b70ebdbbd523dc4962e\nF test/e_droptrigger.test 3cd080807622c13e5bbb61fc9a57bd7754da2412\nF test/e_dropview.test 21ce09c361227ddbc9819a5608ee2700c276bdd5\nF test/e_expr.test 328d2d7c84f8e53e942a13eac771b337bcdfcf4c3569324001868b5639f3c857\nF test/e_fkey.test 2febb2084aef9b0186782421c07bc9d377abf067c9cb4efd49d9647ae31f5afe\nF test/e_fts3.test 17ba7c373aba4d4f5696ba147ee23fd1a1ef70782af050e03e262ca187c5ee07\nF test/e_insert.test f02f7f17852b2163732c6611d193f84fc67bc641fb4882c77a464076e5eba80e\nF test/e_reindex.test 2b0e29344497d9a8a999453a003cb476b6b1d2eef2d6c120f83c2d3a429f3164\nF test/e_resolve.test a61751c368b109db73df0f20fc75fb47e166b1d8\nF test/e_select.test f9474205669a7736ef725b29cc7ae9e8601919a3d0ffc0ab30745a028f2a4b61\nF test/e_select2.test aceb80ab927d46fba5ce7586ebabf23e2bb0604f\nF test/e_totalchanges.test b12ee5809d3e63aeb83238dd501a7bca7fd72c10\nF test/e_update.test f46c2554d915c9197548681e8d8c33a267e84528\nF test/e_uri.test 47eeb2960e74613f0f8722b2f13aef08fde69daa16e5380ac93df84dac8b1f72\nF test/e_vacuum.test 0d8832a2ce92350db0d0cff47b419465fd9772562e1f77ff7d9478c07a4980d2\nF test/e_wal.test ae9a593207a77d711443ee69ffe081fda9243625\nF test/e_walauto.test 248af31e73c98df23476a22bdb815524c9dc3ba8\nF test/e_walckpt.test 28c371a6bb5e5fe7f31679c1df1763a19d19e8a0\nF test/e_walhook.test 01b494287ba9e60b70f6ebf3c6c62e0ffe01788e344a4846b08e5de0b344cb66\nF test/emptytable.test a38110becbdfa6325cd65cb588dca658cd885f62\nF test/enc.test e54531cd6bf941ee6760be041dff19a104c7acea\nF test/enc2.test 83437a79ba1545a55fb549309175c683fb334473\nF test/enc3.test 6807f7a7740a00361ca8d0ccd66bc60c8dc5f2b6\nF test/enc4.test c8f1ce3618508fd0909945beb8b8831feef2c020\nF test/eqp.test 84879b63e3110552bf8ce648a3507dc3ceb72109ecec83c2aef0db37a27f6382\nF test/errmsg.test eae9f091eb39ce7e20305de45d8e5d115b68fa856fba4ea6757b6ca3705ff7f9\nF test/eval.test a64c9105d6ff163df7cf09d6ac29cdad5922078c\nF test/exclusive.test 1206b87e192497d78c7f35552e86a9d05421498da300fb1cce5ca5351ccde3c3\nF test/exclusive2.test 984090e8e9d1b331d2e8111daf6e5d61dda0bef7\nF test/exec.test e949714dc127eaa5ecc7d723efec1ec27118fdd7\nF test/exists.test 79a75323c78f02bbe9c251ea502a092f9ef63dac\nF test/expr.test 7cb55e80aeb41d65fec968c08212505123063fea60bdc355d764d747670e9eea\nF test/expr2.test c27327ae9c017a7ff6280123f67aff496f912da74d78c888926d68b46ec75fd8\nF test/extension01.test 00d13cec817f331a687a243e0e5a2d87b0e358c9\nF test/extraquick.test cb254400bd42bfb777ff675356aabf3287978f79\nF test/fallocate.test 37a62e396a68eeede8f8d2ecf23573a80faceb630788d314d0a073d862616717\nF test/filectrl.test 6e871c2d35dead1d9a88e176e8d2ca094fec6bb3\nF test/filefmt.test f393e80c4b8d493b7a7f8f3809a8425bbf4292af1f5140f01cb1427798a2bbd4\nF test/filter1.test fe7fcfeff48ca399fbc9577f55b60c8be8ccfdffc5e3b4ace21dc3c3e59f0f6a\nF test/filter2.tcl 44e525497ce07382915f01bd29ffd0fa49dab3adb87253b5e5103ba8f93393e8\nF test/filter2.test 485cf95d1f6d6ceee5632201ca52a71868599836f430cdee42e5f7f14666e30a\nF test/filterfault.test c08fb491d698e8df6c122c98f7db1c65ffcfcad2c1ab0e07fa8a5be1b34eaa8b\nF test/fkey1.test d11dbb8a93ead9b5c46ae5d02da016d61245d47662fb2d844c99214f6163f768\nF test/fkey2.test d35d1c81e7569bdd2b872e91750f7098117d2e8291369f70b7e3d50a0e523dc2\nF test/fkey3.test 76d475c80b84ee7a5d062e56ccb6ea68882e2b49\nF test/fkey4.test 86446017011273aad8f9a99c1a65019e7bd9ca9d\nF test/fkey5.test 24dd28eb3d9f1b5a174f47e9899ace5facb08373a4223593c8c631e6cf9f7d5a\nF test/fkey6.test d078a1e323a740062bed38df32b8a736fd320dc0\nF test/fkey7.test 64fb28da03da5dfe3cdef5967aa7e832c2507bf7fb8f0780cacbca1f2338d031\nF test/fkey8.test 48ef829d63f5f7b37aabd4df9363ac05f65539d1da8c4a44251631769d920579\nF test/fkey_malloc.test 594a7ea1fbab553c036c70813cd8bd9407d63749\nF test/fordelete.test eb93a2f34137bb87bdab88fcab06c0bd92719aff\nF test/format4.test eeae341953db8b6bda7f549044797c3278a6cc345d11ada81471671b654f8ef4\nF test/fts-9fd058691.test 78b887e30ae6816df0e1fed6259de4b5a64ad33c\nF test/fts1a.test 46090311f85da51bb33bd5ce84f7948359c6d8d7\nF test/fts1b.test 5d8a01aefbecc8b7442b36c94c05eb7a845462d5\nF test/fts1c.test 85a525ce7428907469b4cce13d5563ce542ce64c\nF test/fts1d.test a73deace5c18df4a549b12908bade4f05dcf1a2f\nF test/fts1e.test 77244843e925560b5a0b70069c3e7ab62f181ed2\nF test/fts1f.test 2d6cb10d8b7a4e6edc321bbdb3982f1f48774714\nF test/fts1i.test 6bfe08cdfdced063a39a50c8601da65e6274d879\nF test/fts1j.test e3797475796043a161e348c46a309664cac83f7f\nF test/fts1k.test 65d3b41487b9f738d11b0f00eca375c0ca6bd970\nF test/fts1l.test 15c119ed2362b2b28d5300c0540a6a43eab66c36\nF test/fts1m.test 2d9ca67b095d49f037a914087cc0a61e89da4f0c\nF test/fts1n.test a2317dcd27b1d087ee3878b30e0a59c593c98b7a\nF test/fts1o.test d1554caede42bba2c82fe613bcc921856c196b752449ead0470fac52a20fd3b8\nF test/fts1porter.test d86e9c3e0c7f8ff95add6582b4b585fb4e02b96d\nF test/fts2.test e3fb95f96a650411574efc136f3fb10eef479ed7\nF test/fts2a.test 473a5c8b473a4e21a8e3fddaed1e59666e0c6ab7\nF test/fts2b.test 964abc0236c849c07ca1ae496bb25c268ae94816\nF test/fts2c.test ffb5a35230ac72c4354535c547965ce6824537c0\nF test/fts2d.test b7eaa671ca9a16997f3e5b158ee777ae21052b0b\nF test/fts2e.test 2da13dbc2d009105f42196845c1e1ce136c03d38\nF test/fts2f.test cf84096235991709c1e61caa389632aa0a4f976d\nF test/fts2g.test 3d26fe171bda6133ebf5a380731d70eaa2ef2f6f73d79769cf8946e622b6d597\nF test/fts2h.test 223af921323b409d4b5b18ff4e51619541b174bb\nF test/fts2i.test 1b22451d1f13f7c509baec620dc3a4a754885dd6\nF test/fts2j.test 298fa1670aa21cd445b282d139b70c72e7ade12b\nF test/fts2k.test c7ebf4a4937594aa07459e3e1bca1251c1be8659\nF test/fts2l.test 3333336621524cf7d60bb62d6ef6ab69647866ed\nF test/fts2m.test 4b30142ead6f3ed076e880a2a464064c5ad58c51\nF test/fts2n.test 12b9c5352128cebd1c6b8395e43788d4b09087c2\nF test/fts2o.test 4054ac7433eb5440f1b1d200cfa449342dc4aabd991759139813e17c73e5bf9a\nF test/fts2p.test 4b48c35c91e6a7dbf5ac8d1e5691823cc999aafb\nF test/fts2q.test b2fbbe038b7a31a52a6079b215e71226d8c6a682\nF test/fts2r.test b154c30b63061d8725e320fba1a39e2201cadd5e\nF test/fts2token.test d8070b241a15ff13592a9ae4a8b7c171af6f445a\nF test/fts3.test 672a040ea57036fb4b6fdc09027c18d7d24ab654\nF test/fts3_common.tcl dffad248f9ce090800e272017d2898005c28ee6314fc1dd5550643a02666907a\nF test/fts3aa.test 814d60a1ba30b4a71d8f9306a6564bc7b636dd6efacd2ad80306f9b23ef3ebee\nF test/fts3ab.test 7f6cf260ae80dda064023df8e8e503e9a412b91f\nF test/fts3ac.test 636ed7486043055d4f126a0e385f2d5a82ebbf63\nF test/fts3ad.test e40570cb6f74f059129ad48bcef3d7cbc20dda49\nF test/fts3ae.test ce32a13b34b0260928e4213b4481acf801533bda\nF test/fts3af.test d394978c534eabf22dd0837e718b913fd66b499c\nF test/fts3ag.test c003672a215124df7fc6000036d896f498b26b53\nF test/fts3ah.test dc9f66c32c296f1bc8bcc4535126bddfeca62894\nF test/fts3ai.test 24058fdc6e9e5102c1fd8459591b114b6a85d285\nF test/fts3aj.test 0ed71e1dd9b03b843a857dc3eb9b15630e0104fc\nF test/fts3ak.test bd14deafe9d1586e8e9bf032411026ac4f8c925d\nF test/fts3al.test 07d64326e79bbdbab20ee87fc3328fbf01641c9f\nF test/fts3am.test 218aa6ba0dfc50c7c16b2022aac5c6be593d08d8\nF test/fts3an.test a49ccadc07a2f7d646ec1b81bc09da2d85a85b18\nF test/fts3ao.test 266989148fec6d9f1bb6c5382f7aa3dcea0e9cd444576e28dd2b9287ac7dd220\nF test/fts3atoken.test bef8a163490098a6b8a6ec5f5407269a3a15b9902c0fcf5e962825a81675b3a0\nF test/fts3auto.test bfe0857bd0b69d68dd685a931b58486411a69f5794a7f6d6fe808bfa31a99614\nF test/fts3aux1.test 7a170e172afdbceb67f5baa05941fd4fbf56af42f61daa3d140f4b4bf4cb68f6\nF test/fts3aux2.test 2459e7fa3e22734aed237d1e2ae192f5541c4d8b218956ad2d90754977bf907f\nF test/fts3b.test c15c4a9d04e210d0be67e54ce6a87b927168fbf9c1e3faec8c1a732c366fd491\nF test/fts3c.test fc723a9cf10b397fdfc2b32e73c53c8b1ec02958\nF test/fts3comp1.test a0f5b16a2df44dd0b15751787130af2183167c0c\nF test/fts3conf.test c84bbaec81281c1788aa545ac6e78a6bd6cde2bdbbce2da261690e3659f5a76b\nF test/fts3corrupt.test ce7f7b5eaeee5f1804584d061b978d85e64abf2af9adaa7577589fac6f7eae01\nF test/fts3corrupt2.test bf55c3fa0b0dc8ea1c0fe5543623bd27714585da6a129038fd6999fe3b0d25f3\nF test/fts3corrupt3.test 0d5b69a0998b4adf868cc301fc78f3d0707745f1d984ce044c205cdb764b491f\nF test/fts3corrupt4.test 00ecd7605d5b1478252a3b7c2465de2d427906b8cb73b7acb92628bab81f9903\nF test/fts3corrupt5.test 0549f85ec4bd22e992f645f13c59b99d652f2f5e643dac75568bfd23a6db7ed5\nF test/fts3cov.test 7eacdbefd756cfa4dc2241974e3db2834e9b372ca215880e00032222f32194cf\nF test/fts3d.test 2bd8c97bcb9975f2334147173b4872505b6a41359a4f9068960a36afe07a679f\nF test/fts3defer.test f4c20e4c7153d20a98ee49ee5f3faef624fefc9a067f8d8d629db380c4d9f1de\nF test/fts3defer2.test 3da52ca2114e300e9971eee2f0cc1a2e5f27e6a9ee67957d49e63e41fdfcc0e7\nF test/fts3defer3.test dd53fc13223c6d8264a98244e9b19abd35ed71cd\nF test/fts3drop.test 1b906e293d6773812587b3dc458cb9e8f3f0c297\nF test/fts3e.test 1f6c6ac9cc8b772ca256e6b22aaeed50c9350851\nF test/fts3expr.test ebae205a7a89446c32583bcd492dcb817b9f6b31819bb4dde2583bb99c77e526\nF test/fts3expr2.test 18da930352e5693eaa163a3eacf96233b7290d1a\nF test/fts3expr3.test c4d4a7d6327418428c96e0a3a1137c251b8dfbf8\nF test/fts3expr4.test f5b2832549f01b1f7f73389fa21d4b875499bc95bf7c8b36271844888c6a0938\nF test/fts3expr5.test a5b9a053becbdb8e973fbf4d6d3abaabeb42d511d1848bd57931f3e0a1cf983e\nF test/fts3fault.test 798e45af84be7978ca33d5bdc94246eb44724db24174b5d8e9b1ac46c57fb08d\nF test/fts3fault2.test 6a17a11d8034b1c4eca9f3091649273d56c49ff049e2173df8060f94341e9da0\nF test/fts3first.test dbdedd20914c8d539aa3206c9b34a23775644641\nF test/fts3fuzz001.test e3c7b0ce9b04cc02281dcc96812a277f02df03cd7dc082055d87e11eb18aaf56\nF test/fts3join.test 949b4f5ae3ae9cc2423cb865d711e32476bdb205ab2be923fdf48246e4a44166\nF test/fts3malloc.test b0e4c133b8d61d4f6d112d8110f8320e9e453ef6\nF test/fts3matchinfo.test aa66cc50615578b30f6df9984819ae5b702511cf8a94251ec7c594096a703a4a\nF test/fts3misc.test c47d2c1ea1351c51c32c688545b02c8180a3f22156d1aedc206a8c09b9d95905\nF test/fts3near.test 7e3354d46f155a822b59c0e957fd2a70c1d7e905\nF test/fts3offsets.test b85fd382abdc78ebce721d8117bd552dfb75094c\nF test/fts3prefix.test fa794eaab0bdae466494947b0b153d7844478ab2\nF test/fts3prefix2.test e1f0a822ca661dced7f12ce392e14eaf65609dce\nF test/fts3query.test ca033ff2ebcc22c69d89032fb0bc1850997d31e7e60ecd26440796ba1654e78f\nF test/fts3rank.test cd99bc83a3c923c8d52afd90d86979cf05fc41849f892faeac3988055ef37b99\nF test/fts3rnd.test 1320d8826a845e38a96e769562bf83d7a92a15d0\nF test/fts3shared.test 57e26a801f21027b7530da77db54286a6fe4997e\nF test/fts3snippet.test 430bb5ace2b31ccd99de4d71775d956da832c114c4b3e39589748f114458647c\nF test/fts3sort.test ed34c716a11cc2009a35210e84ad5f9c102362ca\nF test/fts3tok1.test a663f4cac22a9505400bc22aacb818d7055240409c28729669ea7d4cc2120d15\nF test/fts3tok_err.test 52273cd193b9036282f7bacb43da78c6be87418d\nF test/fts3varint.test 0b84a3fd4eba8a39f3687523804d18f3b322e6d4539a55bf342079c3614f2ada\nF test/fts4aa.test 4338ea7a67f7e19269bf6e6fb4a291352aa32296e7daed87f9823d57016a1ef7\nF test/fts4check.test 6259f856604445d7b684c9b306b2efb6346834c3f50e8fc4a59a2ca6d5319ad0\nF test/fts4content.test 73bbb123420d2c46ef2fb3b24761e9acdb78b0877179d3a5d7d57aada08066f6\nF test/fts4docid.test e33c383cfbdff0284685604d256f347a18fdbf01\nF test/fts4growth.test 289833c34ad45a5e6e6133b53b6a71647231fb89d36ddcb8d9c87211b6721d7f\nF test/fts4growth2.test 13ad4e76451af6e6906c95cdc725d01b00044269\nF test/fts4incr.test 4e353a0bd886ea984e56fce9e77724fc923b8d0d\nF test/fts4langid.test 2168ba330af34f8a1c8832de0aab4c4b6fa195a16419c9c0c8aad59ceb6ff714\nF test/fts4lastrowid.test 185835895948d5325c7710649824042373b2203149abe8024a9319d25234dfd7\nF test/fts4merge.test e2b2ec21e287d54ec09824ccfb41e66896eeca568fc818ba0e0eb2efd94c35d2\nF test/fts4merge2.test 5faa558d1b672f82b847d2a337465fa745e46891\nF test/fts4merge3.test 8d9ccb4a3d41c4c617a149d6c4b13ad02de797d0\nF test/fts4merge4.test d895b1057a7798b67e03455d0fa50e9ea836c47b\nF test/fts4merge5.test 69932d85cda8a1c4dcfb742865900ed8fbda51724b8cf9a45bbe226dfd06c596\nF test/fts4noti.test 5553d7bb2e20bf4a06b23e849352efc022ce6309\nF test/fts4onepass.test d69ddc4ee3415e40b0c5d1d0408488a87614d4f63ba9c44f3e52db541d6b7cc7\nF test/fts4opt.test 0fd0cc84000743ff2a883b9b84b4a5be07249f0ba790c8848a757164cdd46b2a\nF test/fts4record.test a48508f69a84c9287c8019d3a1ae712f5730d8335ffaf8e2101e691d078950bb\nF test/fts4rename.test 15fd9985c2bce6dea20da2245b22029ec89bd4710ed317c4c53abbe3cfd0c880\nF test/fts4umlaut.test fcaca4471de7e78c9d1f7e8976e3e8704d7d8ad979d57a739d00f3f757380429\nF test/fts4unicode.test ceca76422abc251818cb25dabe33d3c3970da5f7c90e1540f190824e6b3a7c95\nF test/full.test 6b3c8fb43c6beab6b95438c1675374b95fab245d\nF test/func.test 7d425f9a6eaa2c50baa751bef6b0c6c6af1751e0e0e1eb4863d426bb4c886788\nF test/func2.test 772d66227e4e6684b86053302e2d74a2500e1e0f\nF test/func3.test 2bb0f31ab7baaed690b962a88544d7be6b34fa389364bc36a44e441ed3e3f1e6\nF test/func4.test 6beacdfcb0e18c358e6c2dcacf1b65d1fa80955f\nF test/func5.test cdd224400bc3e48d891827cc913a57051a426fa4\nF test/func6.test 90e42b64c4f9fb6f04f44cb8a1da586c8542502e926b19c76504fe74ff2a9b7c\nF test/fuzz-oss1.test e58330d01cbbd8215ee636b17a03fe220b37dbfa\nF test/fuzz.test 96083052bf5765e4518c1ba686ce2bab785670d1\nF test/fuzz2.test 76dc35b32b6d6f965259508508abce75a6c4d7e1\nF test/fuzz3.test 9c813e6613b837cb7a277b0383cd66bfa07042b4cf0317157c35852f30043c31\nF test/fuzz4.test c229bcdb45518a89e1d208a21343e061503460ac69fae1539320a89f572eb634\nF test/fuzz_common.tcl a87dfbb88c2a6b08a38e9a070dabd129e617b45b\nF test/fuzz_malloc.test f348276e732e814802e39f042b1f6da6362a610af73a528d8f76898fde6b22f2\nF test/fuzzcheck.c 0df68e0df3b93a8c8fc24c9873127c7d78024b51444193545f985dbc90ac024e\nF test/fuzzdata1.db d36e88741b4f23bcbaaf55b006290669d03c6c891cf13c7b3a53bc1b097b693f\nF test/fuzzdata2.db 128b3feeb78918d075c9b14b48610145a0dd4c8d6f1ca7c2870c7e425f5bf31f\nF test/fuzzdata3.db c6586d3e3cef0fbc18108f9bb649aa77bfc38aba\nF test/fuzzdata4.db b502c7d5498261715812dd8b3c2005bad08b3a26e6489414bd13926cd3e42ed2\nF test/fuzzdata5.db e35f64af17ec48926481cfaf3b3855e436bd40d1cfe2d59a9474cb4b748a52a5\nF test/fuzzdata6.db 92a80e4afc172c24f662a10a612d188fb272de4a9bd19e017927c95f737de6d7\nF test/fuzzdata7.db e7a86fd83dda151d160445d542e32e5c6019c541b3a74c2a525b6ac640639711\nF test/fuzzdata8.db b45368bbe9f86d40d30603e8f780ac29807cbcc951a18d7a7fd9d0c0e904706e\nF test/fuzzer1.test 3d4c4b7e547aba5e5511a2991e3e3d07166cfbb8\nF test/fuzzer2.test a85ef814ce071293bce1ad8dffa217cbbaad4c14\nF test/fuzzerfault.test 8792cd77fd5bce765b05d0c8e01b9edcf8af8536\nF test/gcfault.test dd28c228a38976d6336a3fc42d7e5f1ad060cb8c\nF test/gencol1.test 69008f45faa46b7293cc6ce1236f356a7aff6061b0547334786b54a49b2f98cb\nF test/genesis.tcl 1e2e2e8e5cc4058549a154ff1892fe5c9de19f98\nF test/having.test e4098a4b8962f9596035c3b87a8928a10648acc509f1bb8d6f96413bbf79a1b3\nF test/hexlit.test 4a6a5f46e3c65c4bf1fa06f5dd5a9507a5627751\nF test/hidden.test 23c1393a79e846d68fd902d72c85d5e5dcf98711\nF test/hook.test 1604b3b2f5931430087540404555c1b6be3618600b81558657c66b533ed70b13\nF test/hook2.test b9ff3b8c6519fb67f33192f1afe86e7782ee4ac8\nF test/icu.test 41aa8847745a879b897a7febea0f8f9efc8e67fe8bf680589b6e07c7b0a1569a\nF test/ieee754.test 806fc0ce7f305f57e3331eaceeddcfec9339e607\nF test/imposter1.test c3f1db2d3db2c24611a6596a3fc0ffc14f1466c8\nF test/in.test 3e9bd58597a444123a40a9ac94cae0fec8897e17e9f519b02fc370bcf5ba5175\nF test/in2.test 5d4c61d17493c832f7d2d32bef785119e87bde75\nF test/in3.test 3cbf58c87f4052cee3a58b37b6389777505aa0c0\nF test/in4.test 0f77b0ff371549e6a119d0356be10bdba72258162e9701e83527a560482f5e98\nF test/in5.test b32ce7f4a93f44c5dee94af16886d922cc16ebe33c8e1765c73d4049d0f4b40f\nF test/in6.test 62d943a02f722948f4410ee0b53c3cb39acd7c41afb083df8d7004238fe90a20\nF test/incrblob.test c9b96afc292aeff43d6687bcb09b0280aa599822\nF test/incrblob2.test a494c9e848560039a23974b9119cfc2cf3ad3bd15cc2694ee6367ae537ef8f1f\nF test/incrblob3.test d8d036fde015d4a159cd3cbae9d29003b37227a4\nF test/incrblob4.test 21a52a6843a56cdcce968c6a86b72a7066d0e6ba\nF test/incrblob_err.test 89372a28f1d98254f03fed705f9efcd34ef61a674df16d2dbb4726944a2de5e9\nF test/incrblobfault.test 74dd8ac108304cea0b4a0df6df63a1567e558758\nF test/incrcorrupt.test 6c567fbf870aa9e91866fe52ce6f200cd548939a\nF test/incrvacuum.test 2aaee202b1f230e55779f70d155f6ba67bbdff8481d650214d256ab0f97d4a2b\nF test/incrvacuum2.test 7d26cfda66c7e55898d196de54ac4ec7d86a4e3d\nF test/incrvacuum3.test 75256fb1377e7c39ef2de62bfc42bbff67be295a\nF test/incrvacuum_ioerr.test 6ae2f783424e47a0033304808fe27789cf93e635\nF test/index.test a2e948ed949e575487b5c1d521767d4584ac42d352f2dcd8e48004638e7bc7dc\nF test/index2.test f835d5e13ca163bd78c4459ca15fd2e4ed487407\nF test/index3.test 51685f39345462b84fcf77eb8537af847fdf438cc96b05c45d6aaca4e473ade0\nF test/index4.test ab92e736d5946840236cd61ac3191f91a7856bf6\nF test/index5.test 8621491915800ec274609e42e02a97d67e9b13e7\nF test/index6.test f172653b35b20233e59200e8b92a76db61bf7285437bf777b93b306ba26a47e7\nF test/index7.test 1d764c0cca45f5a76150b08e127ccc8d52492cfa788b5fafed4be784a351b020\nF test/index8.test bc2e3db70e8e62459aaa1bd7e4a9b39664f8f9d7\nF test/index9.test 0aa3e509dddf81f93380396e40e9bb386904c1054924ba8fa9bcdfe85a8e7721\nF test/indexedby.test a52c8c6abfae4fbfb51d99440de4ca1840dbacc606b05e29328a2a8ba7cd914e\nF test/indexexpr1.test 284e119999d132cc8bf37735a928c9859b28e8e295d02b7a6a4f93977c7f9ba5\nF test/indexexpr2.test dba11dbb0a58fcba4cd694f46b4004976123b81b0501f525d43c9be59f0207b1\nF test/indexfault.test 98d78a8ff1f5335628b62f886a1cb7c7dac1ef6d48fa39c51ec871c87dce9811\nF test/init.test 15c823093fdabbf7b531fe22cf037134d09587a7\nF test/insert.test 4e3f0de67aac3c5be1f4aaedbcea11638f1b5cdc9a3115be14d19aa9db7623c6\nF test/insert2.test 4d14b8f1b810a41995f6286b64a6943215d52208\nF test/insert3.test 1b7db95a03ad9c5013fdf7d6722b6cd66ee55e30\nF test/insert4.test fb9e0f752c75f453555990250b449f6d123ae6a3ebf054d14e4470de4498dce3\nF test/insert5.test 394f96728d1258f406fe5f5aeb0aaf29487c39a6\nF test/insertfault.test ac63d14ea3b49c573673a572f4014b9117383a03e497c58f308b5c776e4a7f74\nF test/instr.test 107df2b9b74a4b59315916b575590a08f2a714de0754abe541f10a0971d0a2a4\nF test/instrfault.test 0f870b218ea17cd477bb19ed330eecdb460dd53a\nF test/intarray.test bb976b0b3df0ebb6a2eddfb61768280440e672beba5460ed49679ea984ccf440\nF test/interrupt.test 16ea879ec728cb76414c148c5f24afd5d1f91054\nF test/interrupt2.test e4408ca770a6feafbadb0801e54a0dcd1a8d108d\nF test/intpkey.test ac71107a49a06492b69b82aafaf225400598d3c8\nF test/intreal.test 2a87e85a5949bd55e41ef04c58f5800587c5380bdbc559ff1c79b614b0e6a533\nF test/io.test f95bca1783b01ea7761671560d023360d2dfa4cc\nF test/ioerr.test 470fcc78e9cd352d162baf782fe301ea807d764241f58a48fc58109c2dfcdb6b\nF test/ioerr2.test 2593563599e2cc6b6b4fcf5878b177bdd5d8df26\nF test/ioerr3.test d3cec5e1a11ad6d27527d0d38573fbff14c71bdd\nF test/ioerr4.test f130fe9e71008577b342b8874d52984bd04ede2c\nF test/ioerr5.test 2edfa4fb0f896f733071303b42224df8bedd9da4\nF test/ioerr6.test a395a6ab144b26a9e3e21059a1ab6a7149cca65b\nF test/istrue.test 75327829744e65cc8700e69340b8e6c192e10e39dfae7ccb0e970d3c4f49090a\nF test/join.test 99e1d82fada7a1df9002a7b1160bd231c91077b9372492d5e18bfa1d1694d43c\nF test/join2.test 10f7047e723ebd68b2f47189be8eed20451a6f665d8bf46f1774c640d1062417\nF test/join3.test 6f0c774ff1ba0489e6c88a3e77b9d3528fb4fda0\nF test/join4.test 1a352e4e267114444c29266ce79e941af5885916\nF test/join5.test 3a96dc62f0b45402d7207e22d1993fe0c2fce1c57644a11439891dd62b990eb7\nF test/join6.test cfe6503791ceb0cbb509966740286ec423cbf10b\nF test/journal1.test c7b768041b7f494471531e17abc2f4f5ebf9e5096984f43ed17c4eb80ba34497\nF test/journal2.test 9dac6b4ba0ca79c3b21446bbae993a462c2397c4\nF test/journal3.test 7c3cf23ffc77db06601c1fcfc9743de8441cb77db9d1aa931863d94f5ffa140e\nF test/jrnlmode.test 9b5bc01dac22223cb60ec2d5f97acf568d73820794386de5634dcadbea9e1946\nF test/jrnlmode2.test 8759a1d4657c064637f8b079592651530db738419e1d649c6df7048cd724363d\nF test/jrnlmode3.test 556b447a05be0e0963f4311e95ab1632b11c9eaa\nF test/json101.test bb71538005f2d9e18620bdd3b76839a93ca0be61903eb8d751a64e78cf99b8fb\nF test/json102.test eeb54efa221e50b74a2d6fb9259963b48d7414dca3ce2fdfdeed45cb28487bc1\nF test/json103.test aff6b7a4c17d5a20b487a7bc1a274bfdc63b829413bdfb83bedac42ec7f67e3b\nF test/json104.test 317f4ec4b2d87afbba4d2460cf5be297aea76f2285eb618d276dbcd40a50950f\nF test/json105.test 45f7d6a9a54c85f8a9589b68d3e7a1f42d02f2359911a8cdbad1f9988f571173\nF test/keyword1.test 37ef6bba5d2ed5b07ecdd6810571de2956599dff\nF test/kvtest.c 94da54bb66aae7a54e47cf7e4ea4acecc0f217560f79ad3abfcc0361d6d557ba\nF test/lastinsert.test 42e948fd6442f07d60acbd15d33fb86473e0ef63\nF test/laststmtchanges.test ae613f53819206b3222771828d024154d51db200\nF test/lemon-test01.y 58b764610fd934e189ffbb0bbfa33d171b9cb06019b55bdc04d090d6767e11d7\nF test/like.test 3d702d79bf871fa32985b1ce334294c587e3948d3ab972001e811a58577e8b3c\nF test/like2.test 3b2ee13149ba4a8a60b59756f4e5d345573852da\nF test/like3.test 4f940ad275c006319950054a7a65661f476772171b82b6fdf795e4dda36f246f\nF test/limit.test 0c99a27a87b14c646a9d583c7c89fd06c352663e\nF test/limit2.test 9409b033284642a859fafc95f29a5a6a557bd57c1f0d7c3f554bd64ed69df77e\nF test/loadext.test faa4f6eed07a5aac35d57fdd7bc07f8fc82464cfd327567c10cf0ba3c86cde04\nF test/loadext2.test 0408380b57adca04004247179837a18e866a74f7\nF test/lock.test be4fe08118fb988fed741f429b7dd5d65e1c90db\nF test/lock2.test 5242d8ac4e2d59c403aebff606af449b455aceff\nF test/lock3.test f271375930711ae044080f4fe6d6eda930870d00\nF test/lock4.test 27143363eda1622f03c133efc8db808fc331afd973486cb571ea71cd717d37b8\nF test/lock5.test c6c5e0ebcb21c61a572870cc86c0cb9f14cede38\nF test/lock6.test ad5b387a3a8096afd3c68a55b9535056431b0cf5\nF test/lock7.test 49f1eaff1cdc491cc5dee3669f3c671d9f172431\nF test/lock_common.tcl 2f3f7f2e9637f93ccf609df48ef5b27a50278b6b1cd752b445d52262e5841413\nF test/lookaside.test 5a828e7256f1ee4da8e1bdaa03373a3ccdb0f1ff98dfa82e9b76cb41a45b1083\nF test/main.test 6bbb3999fd461eb8fb335cbab97409a3d7f91bbb8da60635e8be3e4a04a77772\nF test/make-where7.tcl 05c16b5d4f5d6512881dfec560cb793915932ef9\nF test/malloc.test 18dd1c4188c81ca79cf123527c71b19ee0c31feb9947fdffb0dc6ceb1436816a\nF test/malloc3.test 6e88bae6312854a4adb4ecc2a6a5ea8c59b4db778b724ba718e1c43fc8c3c136\nF test/malloc4.test 957337613002b7058a85116493a262f679f3a261\nF test/malloc5.test 2e4ad7684a13389a44a840499cd47173a8d05f22f082d7d083eece433a7a64eb\nF test/malloc6.test 2f039d9821927eacae43e1831f815e157659a151\nF test/malloc7.test 7c68a32942858bc715284856c5507446bba88c3a\nF test/malloc8.test 9b7a3f8cb9cf0b12fff566e80a980b1767bd961d\nF test/malloc9.test 2307c6ee3703b0a21391f3ea92388b4b73f9105e\nF test/mallocA.test aea76f2dd8bcc2d19748f6b911e876cefda74a563753bf26af046e9d34bb97e6\nF test/mallocAll.test 98f1be74bc9f49a858bc4f361fc58e26486798be\nF test/mallocB.test bc475ab850cda896142ab935bbfbc74c24e51ed6\nF test/mallocC.test 3dffe16532f109293ce1ccecd0c31dca55ef08c4\nF test/mallocD.test f78c295e8e18ea3029e65ca08278690e00c22100\nF test/mallocE.test db1ed69d7eded1b080952e2a7c37f364ad241b08\nF test/mallocF.test 2d5c590ebc2fc7f0dcebdf5aa8498b9aed69107e\nF test/mallocG.test 0ff91b65c50bdaba680fb75d87fe4ad35bb7934f\nF test/mallocH.test 79b65aed612c9b3ed2dcdaa727c85895fd1bfbdb\nF test/mallocI.test 6c23a71df077fa5d387be90e7e669c5b368ca38a\nF test/mallocJ.test b5d1839da331d96223e5f458856f8ffe1366f62e\nF test/mallocK.test 1f4b5efbf61715ab79b20b38739ff4b3d110ceb53f54e5db6da1f01c083707ab\nF test/mallocL.test fb311ff80afddf3b1a75e52289081f4754d901dc\nF test/mallocM.test 78bbe9d3da84a5c679123cdb40d7b2010b18fc46e13897e4f253c6ba6fbff134\nF test/malloc_common.tcl aac62499b76be719fac31e7a3e54a7fd53272e7f\nF test/malloctraceviewer.tcl b7a54595270c1d201abf1c3f3d461f27eaf24cdef623ad08a0fe5e411264c8a9\nF test/manydb.test 28385ae2087967aa05c38624cec7d96ec74feb3e\nF test/mem5.test c6460fba403c5703141348cd90de1c294188c68f\nF test/memdb.test c1f2a343ad14398d5d6debda6ea33e80d0dafcc7\nF test/memdb1.test 58d92c2bf622cc5f0f41461e1b35cf64f3f787199544c2c1dada37d88753f9d4\nF test/memleak.test 10b9c6c57e19fc68c32941495e9ba1c50123f6e2\nF test/memsubsys1.test 9e7555a22173b8f1c96c281ce289b338fcba2abe8b157f8798ca195bbf1d347e\nF test/memsubsys2.test 3e4a8d0c05fd3e5fa92017c64666730a520c7e08\nF test/minmax.test 6751e87b409fe11b02e70a306d846fa544e25a41\nF test/minmax2.test 1edf66901ddfab26ae1e04165e8da834c8d3284e2b20aefb26b80ef217962eab\nF test/minmax3.test cc1e8b010136db0d01a6f2a29ba5a9f321034354\nF test/minmax4.test 272ca395257f05937dc96441c9dde4bc9fbf116a8d4fa02baeb0d13d50e36c87\nF test/misc1.test 7ce84b25df9872e7d7878613a96815d2ba5bc974ac4e15a50118dde8f3917599\nF test/misc2.test 00d7de54eda90e237fc9a38b9e5ccc769ebf6d4d\nF test/misc3.test cf3dda47d5dda3e53fc5804a100d3c82be736c9d\nF test/misc4.test 10cd6addb2fa9093df4751a1b92b50440175dd5468a6ec84d0386e78f087db0e\nF test/misc5.test c4aeaa0fa28faa08f2485309c38db4719e6cd1364215d5687a5b96d340a3fa58\nF test/misc6.test 953cc693924d88e6117aeba16f46f0bf5abede91\nF test/misc7.test 4f21954012e4eb0a923c54a311f38c81bf6798ccdd7b51584db46d4007f63daa\nF test/misc8.test 8fb0f31d7a8aed484d759773ab8ad12ec746a477f4a67394a4af0e677494c3ca\nF test/misuse.test 9e7f78402005e833af71dcab32d048003869eca5abcaccc985d4f8dc1d86bcc7\nF test/mjournal.test 28a08d5cb5fb5b5702a46e19176e45e964e0800d1f894677169e79f34030e152\nF test/mmap1.test fb04e0c10492455007624ade884ca0c8852ff3e4e11d95408f9709ca2ef7f626\nF test/mmap2.test 9d6dd9ddb4ad2379f29cc78f38ce1e63ed418022\nF test/mmap3.test b3c297e78e6a8520aafcc1a8f140535594c9086e\nF test/mmap4.test 2e2b4e32555b58da15176e6fe750f17c9dcf7f93\nF test/mmapfault.test d4c9eff9cd8c2dc14bc43e71e042f175b0a26fe3\nF test/mmapwarm.test 2272005969cd17a910077bd5082f70bc1fefad9a875afec7fc9af483898ecaf3\nF test/multiplex.test dc0d67b66f84b484a83cb8bbdf3f0a7f49562ccd\nF test/multiplex2.test 580ca5817c7edbe4cc68fa150609c9473393003a\nF test/multiplex3.test d228f59eac91839a977eac19f21d053f03e4d101\nF test/multiplex4.test e8ae4c4bd70606a5727743241f13b5701990abe4\nF test/mutex1.test ea2cc74d97f077b9e74c84cbd024f14d79a8126f\nF test/mutex2.test bfeaeac2e73095b2ac32285d2756e3a65e681660\nF test/nan.test 437d40e6d0778b050d7750726c0cbd2c9936b81962926e8f8c48ca698f00f4d1\nF test/nockpt.test 8c43b25af63b0bd620cf1b003529e37b6f1dc53bd22690e96a1bd73f78dde53a\nF test/nolock.test f196cf8b8fbea4e2ca345140a2b3f3b0da45c76e\nF test/normalize.test f23b6c5926c59548635fcf39678ac613e726121e073dd902a3062fbb83903b72\nF test/notify1.test 669b2b743618efdc18ca4b02f45423d5d2304abf\nF test/notify2.test 2ecabaa1305083856b7c39cf32816b612740c161\nF test/notify3.test 10ff25cde502e72a92053a2f215d64bece4ef934\nF test/notnull.test a37b663d5bb728d66fc182016613fb8e4a0a4bbf3d75b8876a7527f7d4ed3f18\nF test/null.test 0dcce4f04284ec66108c503327ad6d224c0752b3\nF test/nulls1.test c8fc1b223f06e60007e0cd3e498ccb10195cf75a18fc3312508b3cf679ecb806\nF test/numcast.test 5d126f7f581432e86a90d1e35cac625164aec4a1\nF test/numindex1.test 20a5450d4b056e48cd5db30e659f13347a099823\nF test/offset1.test f06b83657bcf26f9ce805e67450e189e282143b2\nF test/openv2.test 0d3040974bf402e19b7df4b783e447289d7ab394\nF test/optfuzz-db01.c a0c256905c8ac79f9a5de2f374a3d9f757bef0dca2a238dc7c10cc8a38031834\nF test/optfuzz-db01.txt 21f6bdeadc701cf11528276e2a55c70bfcb846ba42df327f979bd9e7b6ce7041\nF test/optfuzz.c 50e330304eb1992e15ddd11f3daaad9bcc0d9aaad09cb2bcc77f9515df2e88b1\nF test/orderby1.test e4501f54721f804ca56922e253403ac6775f88e9f07569994ce99212b3ca5b10\nF test/orderby2.test bc11009f7cd99d96b1b11e57b199b00633eb5b04\nF test/orderby3.test 8619d06a3debdcd80a27c0fdea5c40b468854b99\nF test/orderby4.test 4d39bfbaaa3ae64d026ca2ff166353d2edca4ba4\nF test/orderby5.test 5f4d6cb93cc2f6d3f4228354310a2ce1fbd95d5bbffcba8c6482eeb62a466407\nF test/orderby6.test 8b38138ab0972588240b3fca0985d2e400432859\nF test/orderby7.test 3d1383d52ade5b9eb3a173b3147fdd296f0202da\nF test/orderby8.test 23ef1a5d72bd3adcc2f65561c654295d1b8047bd\nF test/orderby9.test 87fb9548debcc2cd141c5299002dd94672fa76a3\nF test/orderbyA.test df608e59efc2ef50c1eddf1a773b272de3252e9401bfec86d04b52fd973866d5\nF test/oserror.test 1fc9746b83d778e70d115049747ba19c7fba154afce7cc165b09feb6ca6abbc5\nF test/ossfuzz.c 9636dad2092a05a32110df0ca06713038dd0c43dd89a77dabe4b8b0d71096715\nF test/ossshell.c f125c5bd16e537a2549aa579b328dd1c59905e7ab1338dfc210e755bb7b69f17\nF test/ovfl.test 199c482696defceacee8c8e0e0ef36da62726b2f\nF test/pager1.test 1e9ee778bdeaf4f7f09997d029cdaca6a42dfc2092edafe4f5e590acbf1eab13\nF test/pager2.test 67b8f40ae98112bcdba1f2b2d03ea83266418c71\nF test/pager3.test 4e9a83d6ca0838d7c602c9eb93d1357562d9059c1e02ffb138a8271020838370\nF test/pager4.test a122e9e6925d5b23b31e3dfef8c6a44bbf19590e\nF test/pagerfault.test 63c5da625562c66345ab4528790327ca63db2f6f9cbae2aba8cb7c51de3d1628\nF test/pagerfault2.test caf4c7facb914fd3b03a17b31ae2b180c8d6ca1f\nF test/pagerfault3.test 1003fcda009bf48a8e22a516e193b6ef0dd1bbd8\nF test/pageropt.test 84e4cc5cbca285357f7906e99b21be4f2bf5abc0\nF test/pagesize.test 5769fc62d8c890a83a503f67d47508dfdc543305\nF test/parser1.test 6ccdf5e459a5dc4673d3273dc311a7e9742ca952dd0551a6a6320d27035ce4b3\nF test/pcache.test c8acbedd3b6fd0f9a7ca887a83b11d24a007972b\nF test/pcache2.test af7f3deb1a819f77a6d0d81534e97d1cf62cd442\nF test/percentile.test 4243af26b8f3f4555abe166f723715a1f74c77ff\nF test/permutations.test 8587800fe1a0eb01456a3f4500b821e54e3347e78acf11dbf05f4990530f6cee\nF test/pg_common.tcl 222a1bad1c41c308fa366313cd7b51b3be7e9b21c8736a421b974ac941693b54\nF test/pragma.test 59becdfd720b80d463ab750f69f7118fde10dfd556aa5d554f3bf6b7e5ea7533\nF test/pragma2.test e5d5c176360c321344249354c0c16aec46214c9f\nF test/pragma3.test 8300aa9c63cff1027006ca34bf413a148abbd6dcd471fa9a1ded322fe18c0df9\nF test/pragma4.test 10c624e45a83c0096a82a7579a5ff658542391d3b77355192da6572c8c17c00b\nF test/pragma5.test 2be6a44c91e8585ccb4c71c5f221ccebe0692a49557215a912916ed391188959\nF test/pragmafault.test 275edaf3161771d37de60e5c2b412627ac94cef11739236bec12ed1258b240f8\nF test/prefixes.test b524a1c44bffec225b9aec98bd728480352aa8532ac4c15771fb85e8beef65d9\nF test/printf.test 0300699733e53101b2ce48800518427249edd4053bb50fa0621c6607482f0fdb\nF test/printf2.test 30b5dd0b4b992dc5626496846ecce17ff592cacbcb11c3e589f3ac4d7e129dae\nF test/progress.test ebab27f670bd0d4eb9d20d49cef96e68141d92fb\nF test/ptrchng.test ef1aa72d6cf35a2bbd0869a649b744e9d84977fc\nF test/pushdown.test 5e72c51c5e33253ed639ccee1e01ce62d62b6eee5ca893cd82334e4ee7b1d7fc\nF test/queryonly.test 5f653159e0f552f0552d43259890c1089391dcca\nF test/quick.test 1681febc928d686362d50057c642f77a02c62e57\nF test/quota-glob.test 32901e9eed6705d68ca3faee2a06b73b57cb3c26\nF test/quota.test bfb269ce81ea52f593f9648316cd5013d766dd2a\nF test/quota2.test 7dc12e08b11cbc4c16c9ba2aa2e040ea8d8ab4b8\nF test/quote.test 626149eda89ee64d81a3790de370f9f0211921b11568a49c28c861f394330508\nF test/randexpr1.tcl 40dec52119ed3a2b8b2a773bce24b63a3a746459\nF test/randexpr1.test eda062a97e60f9c38ae8d806b03b0ddf23d796df\nF test/rbu.test 168573d353cd0fd10196b87b0caa322c144ef736\nF test/rdonly.test 64e2696c322e3538df0b1ed624e21f9a23ed9ff8\nF test/recover.test ccb8c2623902a92ebb76770edd075cb4f75a4760bb7afde38026572c6e79070d\nF test/regexp1.test 497ea812f264d12b6198d6e50a76be4a1973a9d8\nF test/regexp2.test 40e894223b3d6672655481493f1be12012f2b33c\nF test/reindex.test cd9d6021729910ece82267b4f5e1b5ac2911a7566c43b43c176a6a4732e2118d\nF test/releasetest.tcl fb76d8fcc95ac29d6356cd9e52b726ab9e43a24082897618dfbcb7c2b0049153 x\nF test/releasetest_data.tcl 9919fc6ac5bc92f8878fecfd1840db15999f660a6c9f609240b41aa62b885c88\nF test/resetdb.test 8062cf10a09d8c048f8de7711e94571c38b38168db0e5877ba7561789e5eeb2b\nF test/resolver01.test f4022acafda7f4d40eca94dbf16bc5fc4ac30ceb\nF test/rollback.test 06680159bc6746d0f26276e339e3ae2f951c64812468308838e0a3362d911eaa\nF test/rollback2.test bc868d57899dc6972e2b4483faae0e03365a0556941474eec487ae21d8d38bb6\nF test/rollbackfault.test 0e646aeab8840c399cfbfa43daab46fd609cf04a\nF test/round1.test 768018b04522ca420b1aba8a24bd76091d269f3bce3902af3ec6ebcee41ab21e\nF test/rowallock.test 3f88ec6819489d0b2341c7a7528ae17c053ab7cc\nF test/rowhash.test 0bc1d31415e4575d10cacf31e1a66b5cc0f8be81\nF test/rowid.test bfbd7b97d9267660be3c8f28507c4ed7f205196b8877c0db42df347c2e8845e3\nF test/rowvalue.test c39cc0be5e33f5294fc9224216198d6709d713ea948fdf8f42d89568e97912c9\nF test/rowvalue2.test 060d238b7e5639a7c5630cb5e63e311b44efef2b\nF test/rowvalue3.test 3068f508753af69884b12125995f023da0dbb256\nF test/rowvalue4.test 02e35f7762371c2f57ebd856aa056eac56cb27ef7715a0bb31eac1895a745356\nF test/rowvalue5.test c81c7d8cf36711ab37675ad7376084ae2a359cb6\nF test/rowvalue6.test d19b54feb604d5601f8614b15e214e0774c01087\nF test/rowvalue7.test c1cbdbf407029db01f87764097c6ac02a1c5a37efd2776eff32a9cdfdf6f2dba\nF test/rowvalue8.test 5900eddad9e2c3c2e26f1a95f74aafc1232ee5e0\nF test/rowvalue9.test d8dd2c6ecac432dadaa79e41dc2434f007be1b6b\nF test/rowvaluefault.test 7cd9ccc6c2fbdd881672984087aad0491bb75504\nF test/rowvaluevtab.test d166df5b666662de1ebf40d6f3849f8a76b34e17183a6cc7f81b420c462ce447\nF test/rtree.test 0c8d9dd458d6824e59683c19ab2ffa9ef946f798\nF test/run-wordcount.sh 891e89c4c2d16e629cd45951d4ed899ad12afc09\nF test/savepoint.test 1f8a6b1aea9a0d05837adc463d4bf47bd9d0f1c842f1c2a9caccd639baf34bf9\nF test/savepoint2.test 9b8543940572a2f01a18298c3135ad0c9f4f67d7\nF test/savepoint4.test c8f8159ade6d2acd9128be61e1230f1c1edc6cc0\nF test/savepoint5.test 0735db177e0ebbaedc39812c8d065075d563c4fd\nF test/savepoint6.test f41279c5e137139fa5c21485773332c7adb98cd7\nF test/savepoint7.test cde525ea3075283eb950cdcdefe23ead4f700daa\nF test/savepointfault.test f044eac64b59f09746c7020ee261734de82bf9b2\nF test/scanstatus.test 874e35011779b07725a47dbf1dd6282b0ca04af7e028fb0b534ee544b571be42\nF test/schema.test 5dd11c96ba64744de955315d2e4f8992e447533690153b93377dffb2a5ef5431\nF test/schema2.test 906408621ea881fdb496d878b1822572a34e32c5\nF test/schema3.test 1bc1008e1f8cb5654b248c55f27249366eb7ed38\nF test/schema4.test 3b26c9fa916abb6dadf894137adcf41b7796f7b9\nF test/schema5.test 29699b4421f183c8f0e88bd28ce7d75d13ea653e\nF test/schema6.test e4bd1f23d368695eb9e7b51ef6e02ca0642ea2ab4a52579959826b5e7dce1f9b\nF test/schemafault.test 1936bceca55ac82c5efbcc9fc91a1933e45c8d1e1d106b9a7e56c972a5a2a51e\nF test/securedel.test 2f70b2449186a1921bd01ec9da407fbfa98c3a7a5521854c300c194b2ff09384\nF test/securedel2.test 2d54c28e46eb1fd6902089958b20b1b056c6f1c5\nF test/select1.test b887331202618dbdabed92446b661ebd95a55ef3923700af56ed71266e9c1157\nF test/select2.test 352480e0e9c66eda9c3044e412abdf5be0215b56\nF test/select3.test 3905450067c28766bc83ee397f6d87342de868baa60f2bcfd00f286dfbd62cb9\nF test/select4.test 5389d9895968d1196c457d59b3ee6515d771d328\nF test/select5.test df9ec0d218cedceb4fe7b63262025b547b50a55e59148c6f40b60ca25f1d4546\nF test/select6.test 319d45e414cdd321bf17cfacedaf19e3935ad64dac357c53f1492338c6e9b801\nF test/select7.test f659f231489349e8c5734e610803d7654207318f\nF test/select8.test 8c8f5ae43894c891efc5755ed905467d1d67ad5d\nF test/select9.test aebc2bb0c3bc44606125033cbcaac2c8d1f33a95\nF test/selectA.test b8a590f6493cad5b0bb4dfe1709bf7dcda0b6c40bb4caf32d1e36a89eebc8fc5\nF test/selectB.test 954e4e49cf1f896d61794e440669e03a27ceea25\nF test/selectC.test e25243f8ca503e06f252eb0218976d07cfeceac3\nF test/selectD.test fc20452847a01775710090383cfb4423275d2f745fed61f34fbf37573ac0d214\nF test/selectE.test a8730ca330fcf40ace158f134f4fe0eb00c7edbf\nF test/selectF.test 21c94e6438f76537b72532fa9fd4710cdd455fc3\nF test/selectG.test 089f7d3d7e6db91566f00b036cb353107a2cca6220eb1cb264085a836dae8840\nF test/server1.test c2b00864514a68a0e6fd518659dc95d0050307a357a08969872bef027d785dc4\nF test/session.test 78fa2365e93d3663a6e933f86e7afc395adf18be\nF test/sessionfuzz-data1.db 1f8d5def831f19b1c74571037f0d53a588ea49a6c4ca2a028fc0c27ef896dbcb\nF test/sessionfuzz.c be9c4d4afd359ce80024d8b541b9b8a880510aef5cf263df56fc0e9b947727f1\nF test/shared.test 1826673eb5eb745fb91a3bdac99a7737057742ae38dcb0fe076a384d6727578b\nF test/shared2.test 03eb4a8d372e290107d34b6ce1809919a698e879\nF test/shared3.test ab693f9b6e156b8bfb2a0ad94f29fe69602a5d38\nF test/shared4.test c75f476804e76e26bf6fa0e7b421fb0ca7d07558\nF test/shared6.test 866bb4982c45ce216c61ded5e8fde4e7e2f3ffa9\nF test/shared7.test a81e99f83e6c51b02ac99c96fb3a2a7b5978c956\nF test/shared8.test 933ed7d71f598bb6c7a8c192a3cd30f2562fdccf514df383798599c34ffa672f\nF test/shared9.test 5f2a8f79b4d6c7d107a01ffa1ed05ae7e6333e21\nF test/sharedA.test 49d87ec54ab640fbbc3786ee3c01de94aaa482a3a9f834ad3fe92770eb69e281\nF test/sharedB.test 16cc7178e20965d75278f410943109b77b2e645e\nF test/shared_err.test 32634e404a3317eeb94abc7a099c556a346fdb8fb3858dbe222a4cbb8926a939\nF test/sharedlock.test 5ede3c37439067c43b0198f580fd374ebf15d304\nF test/shell1.test 3c9707dce15e8fdca529503378660f099777d3ddcedccf801a37589a405c5942\nF test/shell2.test e242a9912f44f4c23c3d1d802a83e934e84c853b\nF test/shell3.test ac8c2b744014c3e9a0e26bfd829ab65f00923dc1a91ffd044863e9423cc91494\nF test/shell4.test 1c6aef11daaa2d6830acaba3ac9cbec93fbc1c3d5530743a637f39b3987d08ce\nF test/shell5.test 23939a4c51f0421330ea61dbd3c74f9c215f5f8d3d1a94846da6ffc777a35458\nF test/shell6.test 1ceb51b2678c472ba6cf1e5da96679ce8347889fe2c3bf93a0e0fa73f00b00d3\nF test/shell7.test 115132f66d0463417f408562cc2cf534f6bbc6d83a6d50f0072a9eb171bae97f\nF test/shell8.test 96be02ea0c21f05b24c1883d7b711a1fa8525a68ab7b636aacf6057876941013\nF test/shmlock.test 3dbf017d34ab0c60abe6a44e447d3552154bd0c87b41eaf5ceacd408dd13fda5\nF test/shortread1.test bb591ef20f0fd9ed26d0d12e80eee6d7ac8897a3\nF test/show_speedtest1_rtree.tcl 32e6c5f073d7426148a6936a0408f4b5b169aba5\nF test/shrink.test 1b4330b1fd9e818c04726d45cb28db73087535ce\nF test/sidedelete.test f0ad71abe6233e3b153100f3b8d679b19a488329\nF test/skipscan1.test 2a64ca7b3e6246bb86b47c9051bfd324603b1b60675fe606513535267713e080\nF test/skipscan2.test 3eb703ce794f139e7b83567911046298bcde29606116727f9b700ce34f559d2d\nF test/skipscan3.test ec5bab3f81c7038b43450e7b3062e04a198bdbb5\nF test/skipscan5.test 67817a4b6857c47e0e33ba3e506da6f23ef68de2\nF test/skipscan6.test 0b4cd1b4ac9f84d91454df513c99a4932fa07e8f27b8049bea605068b3e34ac7\nF test/snapshot.test a504f2e7009f512ef66c719f0ea1c55a556bdaf1e1312c80a04d46fc1a3e9632\nF test/snapshot2.test 8d6ff5dd9cc503f6e12d408a30409c3f9c653507b24408d9cd7195931c89bc54\nF test/snapshot3.test 8744313270c55f6e18574283553d3c5c5fe4c5970585663613a0e75c151e599b\nF test/snapshot4.test d4e9347ef2fcabc491fc893506c7bbaf334da3be111d6eb4f3a97cc623b78322\nF test/snapshot_fault.test f6c5ef7cb93bf92fbb4e864ecc5c87df7d3a250064838822db5b4d3a5563ede4\nF test/snapshot_up.test a0a29c4cf33475fcef07c3f8e64af795e24ab91b4cc68295863402a393cdd41c\nF test/soak.test 18944cf21b94a7fe0df02016a6ee1e9632bc4e8d095a0cb49d95e15d5cca2d5c\nF test/softheap1.test 843cd84db9891b2d01b9ab64cef3e9020f98d087\nF test/sort.test c2adc635c2564241fefec0b3a68391ef6868fd3b\nF test/sort2.test cc23b7c19d684657559e8a55b02f7fcee03851d0\nF test/sort3.test 1480ed7c4c157682542224e05e3b75faf4a149e5\nF test/sort4.test 5c34d9623a4ae5921d956dfa2b70e77ed0fc6e5c\nF test/sort5.test 6b43ae0e2169b5ceed441844492e55ba7f1ae0790528395ddf7888ab3094525d\nF test/sorterref.test a13ed207a0eea3c7898f308f979bfb518f68c598ec737d2c494dfd3deaa83506\nF test/sortfault.test d4ccf606a0c77498e2beb542764fd9394acb4d66\nF test/speed1.test f2974a91d79f58507ada01864c0e323093065452\nF test/speed1p.explain d841e650a04728b39e6740296b852dccdca9b2cb\nF test/speed1p.test b180e98609c7677382cf618c0ec9b69f789033a8\nF test/speed2.test 53177056baf6556dcbdcf032bbdfc41c1aa74ded\nF test/speed3.test 694affeb9100526007436334cf7d08f3d74b85ef\nF test/speed4.test abc0ad3399dcf9703abed2fff8705e4f8e416715\nF test/speed4p.explain 6b5f104ebeb34a038b2f714150f51d01143e59aa\nF test/speed4p.test 377a0c48e5a92e0b11c1c5ebb1bc9d83a7312c922bc0cb05970ef5d6a96d1f0c\nF test/speedtest1.c f3bfe3c6a87cbd88e4c4e38005d972bcc1019d1b2fe9569425f86629b11f6c31\nF test/spellfix.test 951a6405d49d1a23d6b78027d3877b4a33eeb8221dcab5704b499755bb4f552e\nF test/spellfix2.test dfc8f519a3fc204cb2dfa8b4f29821ae90f6f8c3\nF test/spellfix3.test 0f9efaaa502a0e0a09848028518a6fb096c8ad33\nF test/spellfix4.test 51c7c26514ade169855c66bcf130bd5acfb4d7fd090cc624645ab275ae6a41fb\nF test/sqldiff1.test 28cd737cf1b0078b1ec1bbf425e674c47785835e\nF test/sqllimits1.test 264f4b0f941800ba139d25e33ee919c5d95fea06dfbe8ac291d6811a30984ca5\nF test/sqllog.test 6af6cb0b09f4e44e1917e06ce85be7670302517a\nF test/stat.test 05669008edc5ed950e817c24e8c4b66840fda64d8c76bae27e5fc1bd23d95675\nF test/statfault.test f525a7bf633e50afd027700e9a486090684b1ac1\nF test/stmt.test 54ed2cc0764bf3e48a058331813c3dbd19fc1d0827c3d8369914a5d8f564ec75\nF test/stmtvtab1.test 6873dfb24f8e79cbb5b799b95c2e4349060eb7a3b811982749a84b359468e2d5\nF test/subjournal.test 8d4e2572c0ee9a15549f0d8e40863161295107e52f07a3e8012a2e1fdd093c49\nF test/subquery.test d7268d193dd33d5505df965399d3a594e76ae13f\nF test/subquery2.test 90cf944b9de8204569cf656028391e4af1ccc8c0cc02d4ef38ee3be8de1ffb12\nF test/subselect.test 0966aa8e720224dbd6a5e769a3ec2a723e332303\nF test/substr.test 18f57c4ca8a598805c4d64e304c418734d843c1a\nF test/subtype1.test 7fe09496352f97053af1437150751be2d0a0cae8\nF test/superlock.test ec94f0556b6488d97f71c79f9061ae08d9ab8f12\nF test/swarmvtab.test 9a3fd5ab3e9b3c976ad1b3d7646aab725114f2ac26b59395d0778b33bab6cdaf\nF test/swarmvtab2.test c948cb2fdfc5b01d85e8f6d6504854202dc1a0782ab2a0ed61538f27cbd0aa5c\nF test/swarmvtab3.test 247aa38b6ebd2b99db2075847ae47e789ac34f1c2ab5c720dfcffd990004c544\nF test/swarmvtabfault.test 8a67a9f27c61073a47990829e92bc0c64420a807cb642b15a25f6c788210ed95\nF test/symlink.test 72b22238d4405ba34df8e60b335d290a3b1129fd5c260835c944c1e4e77288a9\nF test/symlink2.test 9531f475a53d8781c4f81373f87faf2e2aff4f5fb2102ec6386e0c827916a670\nF test/sync.test 89539f4973c010eda5638407e71ca7fddbcd8e0594f4c9980229f804d4333092\nF test/sync2.test 8f9f7d4f6d5be8ca8941a8dadcc4299e558cb6a1ff653a9469146c7a76ef2039\nF test/syscall.test a39d9a36f852ae6e4800f861bc2f2e83f68bbc2112d9399931ecfadeabd2d69d\nF test/sysfault.test c9f2b0d8d677558f74de750c75e12a5454719d04\nF test/tabfunc01.test 5ca6d004157a3e886a55a9387b960cc0db41acd88753eb597ff409ec6cfb1be0\nF test/table.test eb3463b7add9f16a5bb836badf118cf391b809d09fdccd1f79684600d07ec132\nF test/tableapi.test ecbcc29c4ab62c1912c3717c48ea5c5e59f7d64e4a91034e6148bd2b82f177f4\nF test/tableopts.test dba698ba97251017b7c80d738c198d39ab747930\nF test/tclsqlite.test c4a5f5af3672fbe28a0aa322b88d9d1ce2225b6b1284ea11ede2e6d38e7c812c\nF test/tempdb.test 4cdaa23ddd8acb4d79cbb1b68ccdfd09b0537aaba909ca69a876157c2a2cbd08\nF test/tempdb2.test 353864e96fd3ae2f70773d0ffbf8b1fe48589b02c2ec05013b540879410c3440\nF test/tempfault.test 0c0d349c9a99bf5f374655742577f8712c647900\nF test/temptable.test d2c9b87a54147161bcd1822e30c1d1cd891e5b30\nF test/temptable2.test d2940417496e2b9548e01d09990763fbe88c316504033256d51493e1f1a5ce6a\nF test/temptable3.test d11a0974e52b347e45ee54ef1923c91ed91e4637\nF test/temptrigger.test 38f0ca479b1822d3117069e014daabcaacefffcc\nF test/tester.tcl abba168acd7f01dbfa3ffdbf402d151eb97e8a824d9208e845ab34c194441483\nF test/thread001.test b61a29dd87cf669f5f6ac96124a7c97d71b0c80d9012746072055877055cf9ef\nF test/thread002.test e630504f8a06c00bf8bbe68528774dd96aeb2e58\nF test/thread003.test ee4c9efc3b86a6a2767516a37bd64251272560a7\nF test/thread004.test f51dfc3936184aaf73ee85f315224baad272a87f\nF test/thread005.test 50d10b5684399676174bd96c94ad4250b1a2c8b6\nF test/thread1.test df115faa10a4ba1d456e9d4d9ec165016903eae4\nF test/thread2.test f35d2106452b77523b3a2b7d1dcde2e5ee8f9e46\nF test/thread_common.tcl 334639cadcb9f912bf82aa73f49efd5282e6cadd\nF test/threadtest1.c 6029d9c5567db28e6dc908a0c63099c3ba6c383b\nF test/threadtest2.c a70a8e94bef23339d34226eb9521015ef99f4df8\nF test/threadtest3.c 38a612ea62854349ed66372f330a40d73c5cf956\nF test/threadtest4.c c1e67136ceb6c7ec8184e56ac61db28f96bd2925\nF test/time-wordcount.sh 8e0b0f8109367827ad5d58f5cc849705731e4b90\nF test/tkt-02a8e81d44.test 6c80d9c7514e2a42d4918bf87bf6bc54f379110c\nF test/tkt-18458b1a.test 6a62cb1ee50fa3c620da59e3a6f531eb38fceaf7e2166203816b724524e6f1d6\nF test/tkt-26ff0c2d1e.test c15bec890c4d226c0da2f35ff30f9e84c169cfef90e73a8cb5cec11d723dfa96\nF test/tkt-2a5629202f.test 0521bd25658428baa26665aa53ffed9367d33af2\nF test/tkt-2d1a5c67d.test be1326f3061caec85085f4c9ee4490561ca037c0\nF test/tkt-2ea2425d34.test 1cf13e6f75d149b3209a0cb32927a82d3d79fb28\nF test/tkt-31338dca7e.test 6fb8807851964da0d24e942f2e19c7c705b9fb58\nF test/tkt-313723c356.test 4b306ad45c736cedf2f5221f6155b92143244b6d\nF test/tkt-385a5b56b9.test 5204a7cba0e28c99df0acbf95af5e1af4d32965a7a14de6eccebf949607618b1\nF test/tkt-38cb5df375.test f3cc8671f1eb604d4ae9cf886ed4366bec656678\nF test/tkt-3998683a16.test 6d1d04d551ed1704eb3396ca87bb9ccc8c5c1eb7\nF test/tkt-3a77c9714e.test 90e3e8455ee945a4076d4c44062b8845708af24a880355328fe7008f2047c9f0\nF test/tkt-3fe897352e.test 27e26eb0f1811aeba4d65aba43a4c52e99da5e70\nF test/tkt-4a03edc4c8.test 91c0e135888cdc3d4eea82406a44b05c8c1648d0\nF test/tkt-4c86b126f2.test cbcc611becd0396890169ab23102dd70048bbc9a\nF test/tkt-4dd95f6943.test 3d0ce415d2ee15d3d564121960016b9c7be79407\nF test/tkt-4ef7e3cfca.test 3965ae11cc9cf6e334f9d7d3c1e20bf8d56254b1\nF test/tkt-54844eea3f.test a12b851128f46a695e4e378cca67409b9b8f5894\nF test/tkt-5d863f876e.test 726e76d725f6fe0eb2fc8a522b721b79807380ee\nF test/tkt-5e10420e8d.test 904d1687b3c06d43e5b3555bbcf6802e7c0ffd84\nF test/tkt-5ee23731f.test 9db6e1d7209dc0794948b260d6f82b2b1de83a9f\nF test/tkt-6bfb98dfc0.test 24780633627b5cfc0635a5500c2389ebfb563336\nF test/tkt-752e1646fc.test ea78d88d14fe9866bdd991c634483334639e13bf\nF test/tkt-78e04e52ea.test cb44d0f5e7940223be740a39913a1b9b9b30d7e4a17ed3349141f893bae1b8f2\nF test/tkt-7a31705a7e6.test 9e9c057b6a9497c8f7ba7b16871029414ccf6550e7345d9085d6d71c9a56bb6f\nF test/tkt-7bbfb7d442.test 7b2cd79c7a17ae6750e75ec1a7846712a69c9d18\nF test/tkt-80ba201079.test 105a721e6aad0ae3c5946d7615d1e4d03f6145b8\nF test/tkt-80e031a00f.test 9ee36348b761bf7c14261e002b75a4c0d5a04d4c\nF test/tkt-8454a207b9.test c583a9f814a82a2b5ba95207f55001c9f0cd816c\nF test/tkt-868145d012.test a5f941107ece6a64410ca4755c6329b7eb57a356\nF test/tkt-8c63ff0ec.test 258b7fc8d7e4e1cb5362c7d65c143528b9c4cbed\nF test/tkt-91e2e8ba6f.test 08c4f94ae07696b05c9b822da0b4e5337a2f54c5\nF test/tkt-94c04eaadb.test f738c57c7f68ab8be1c054415af7774617cb6223\nF test/tkt-9a8b09f8e6.test b2ef151d0984b2ebf237760dbeaa50724e5a0667\nF test/tkt-9d68c883.test 16f7cb96781ba579bc2e19bb14b4ad609d9774b6\nF test/tkt-9f2eb3abac.test cb6123ac695a08b4454c3792fbe85108f67fabf8\nF test/tkt-a7b7803e.test 159ef554234fa1f9fb318c751b284bd1cf858da4\nF test/tkt-a7debbe0.test e295fa83cd4416a8ca37b354eb5fadefc5e81fb55253db538d35261fe9c95067\nF test/tkt-a8a0d2996a.test 002e1cde8fc30c39611b52cf981c88200b858765748556822da72e0d32fac73e\nF test/tkt-b1d3a2e531.test 8f7576e41ca179289ee1a8fee28386fd8e4b0550\nF test/tkt-b351d95f9.test d14a503c414c5c58fdde3e80f9a3cfef986498c0\nF test/tkt-b72787b1.test a95e8cdad0b98af1853ac7f0afd4ab27b77bf5f3\nF test/tkt-b75a9ca6b0.test ade89229d853a67a21bbd5e6e1e787a8f9d21f19908d1b7fca6bf3d4d5aa0767\nF test/tkt-ba7cbfaedc.test b4c0deccc12aeb55cfdb57935b16b5d67c5a9877\nF test/tkt-bd484a090c.test 60460bf946f79a79712b71f202eda501ca99b898\nF test/tkt-bdc6bbbb38.test fc38bb09bdd440e3513a1f5f98fc60a075182d7d\nF test/tkt-c48d99d690.test ba61977d62ab612fc515b3c488a6fbd6464a2447\nF test/tkt-c694113d5.test 82c461924ada5c14866c47e85535b0b0923ba16a2e907e370061a5ca77f65d77\nF test/tkt-cbd054fa6b.test 708475ef4d730a6853512c8ce363bcbd3becf0e26826e1f4cd46e2f52ff38edf\nF test/tkt-d11f09d36e.test d999b548fef885d1d1afa49a0e8544ecf436869d\nF test/tkt-d635236375.test 9d37e988b47d87505bc9445be0ca447002df5d09\nF test/tkt-d82e3f3721.test bcc0dfba658d15bab30fd4a9320c9e35d214ce30\nF test/tkt-f3e5abed55.test d5a0126118142d13e27f6ce9f4c47096e9321c00\nF test/tkt-f67b41381a.test a23bc124c981662db712167bacd0ed8ad11abac9\nF test/tkt-f777251dc7a.test d1a8fc3eefb7a9e64d19ff24d5c8c94c34a632fb\nF test/tkt-f7b4edec.test d998a08ff2b18b7f62edce8e3044317c45efe6c7\nF test/tkt-f973c7ac31.test 28ef85c7f015477916795246d8286aeda39d4ead\nF test/tkt-fa7bf5ec.test 9102dfea58aa371d78969da735f9392c57e2e035\nF test/tkt-fc62af4523.test 72825d3febdedcd5593a27989fc05accdbfc2bb4\nF test/tkt-fc7bd6358f.test 634bb4af7d661e82d6b61b80c86727bad698e08f\nF test/tkt1435.test f8c52c41de6e5ca02f1845f3a46e18e25cadac00\nF test/tkt1443.test bacc311da5c96a227bf8c167e77a30c99f8e8368\nF test/tkt1444.test a9d72f9e942708bd82dde6c707da61c489e213e9\nF test/tkt1449.test 93584a449752d52b07d2cfc280a69842b6e16ed5\nF test/tkt1473.test 9d000af3e11a4450d4c596f5e58b4b0d24eb0f8b\nF test/tkt1501.test 2064f98e00871848af4b2f517e46c1a7fb2e32db\nF test/tkt1512.test a1df1f66caf0b9122d6220c15dcee230298c2c2f\nF test/tkt1514.test ddef38e34fea72eb1ab935ded9f17a3fb71dd9df\nF test/tkt1536.test 83ff7a7b6e248016f8d682d4f7a4ae114070d466\nF test/tkt1537.test e3a14332de9770be8ff14bd15c19a49cbec10808\nF test/tkt1567.test 52f329386ac77e59260d4af1c58490d61377db20\nF test/tkt1644.test 80b6a2bb17885f3cf1cb886d97cdad13232bb869\nF test/tkt1667.test 4700d931ed19ea3983e8e703becb28079250b460\nF test/tkt1873.test 0e1b8c023050a430c2525179ed4022ddc7c31264\nF test/tkt2141.test f543d96f50d5a5dc0bc744f7db74ea166720ce46\nF test/tkt2192.test ff40157e5f42e65f844255d220fc6b290470942f\nF test/tkt2213.test a9702175601a57b61aba095a233b001d6f362474\nF test/tkt2251.test 5aab8c7898cd2df2a68fe19289cc29e8f5cf8c82\nF test/tkt2285.test cca17be61cf600b397188e77e7143844d2b977e9\nF test/tkt2332.test fc955609b958ca86dfa102832243370a0cc84070\nF test/tkt2339.test 73bd17818924cd2ac442e5fd9916b58565739450\nF test/tkt2391.test ab7a11be7402da8b51a5be603425367aa0684567\nF test/tkt2409.test be0d60e7d283f639dccea4b0b5e1cd3a4851fb5b\nF test/tkt2450.test 77ed94863f2049c1420288ddfea2d41e5e0971d6\nF test/tkt2565.test 8be666e927cb207aae88188f31c331870878b650\nF test/tkt2640.test 28134f5d1e05658ef182520cf0b680fa3de5211b\nF test/tkt2643.test 3f3ebb743da00d4fed4fcf6daed92a0e18e57813\nF test/tkt2686.test 6ee01c9b9e9c48f6d3a1fdd553b1cc4258f903d6\nF test/tkt2767.test 569000d842678f9cf2db7e0d1b27cbc9011381b0\nF test/tkt2817.test f31839e01f4243cff7399ef654d3af3558cb8d8d\nF test/tkt2820.test 39940276b3436d125deb7d8ebeee053e4cf13213\nF test/tkt2822.test f391776423a7c0d0949edfce375708bfb0f3141e\nF test/tkt2832.test a9b0b74a02dca166a04d9e37739c414b10929caa\nF test/tkt2854.test e432965db29e27e16f539b2ba7f502eb2ccc49af\nF test/tkt2920.test a8737380e4ae6424e00c0273dc12775704efbebf\nF test/tkt2927.test 4752868b9eeeb07a217f7f19f4cbaac98d6d086d\nF test/tkt2942.test c5c87d179799ca6d1fbe83c815510b87cd5ec7ce\nF test/tkt3080.test 1bca7579260920a66b4dd7e196e807c0f25ff804\nF test/tkt3093.test fbdbc5b4969244ad11f540759003e361fcaf391f\nF test/tkt3121.test 536df66a02838c26a12fe98639354ca1290ca68b\nF test/tkt3201.test f1500ccecc0d578dc4cde7d3242008297c4d59b3\nF test/tkt3292.test 7bad4423cf5eb075dbb58511d66d46fe816744754c9f0050ae60157f71a4fca7\nF test/tkt3298.test 20fd8773b825cb602e033aa04f8602e1ebdcd93c\nF test/tkt3334.test 9756631e3c4aa3c416362c279e3c0953a83b7ca8274cb81a13264bb56296d8b0\nF test/tkt3346.test 6f67c3ed7db94dfc5df4f5f0b63809a1f611e01a\nF test/tkt3357.test 77c37c6482b526fe89941ce951c22d011f5922ed\nF test/tkt3419.test 1bbf36d7ea03b638c15804251287c2391f5c1f6b\nF test/tkt3424.test 61f831bd2b071bd128fa5d00fbda57e656ca5812\nF test/tkt3442.test a1fc47c669e651d16494de3ff349bcb53281456f2ca02c8bc14220b6044bbfe8\nF test/tkt3457.test 5651e2cbb94645b677ec663160b9e192b87b7d365aecdfb24e19f749575a6fc2\nF test/tkt3461.test 228ea328a5a21e8663f80ee3d212a6ad92549a19\nF test/tkt3493.test 1686cbde85f8721fc1bdc0ee72f2ef2f63139218\nF test/tkt3508.test d75704db9501625c7f7deec119fcaf1696aefb7d\nF test/tkt3522.test 22ce2ebbcb04a6be56c0977d405c207967318fd6\nF test/tkt3527.test 1a6a48441b560bdc53aec581a868eb576234874d\nF test/tkt3541.test 5dc257bde9bc833ab9cc6844bf170b998dbb950a\nF test/tkt3554.test f599967f279077bace39220cbe76085c7b423725\nF test/tkt3581.test 1966b7193f1e3f14951cce8c66907ae69454e9a3\nF test/tkt35xx.test f38c1b03713179d414969187c941466e44945b35\nF test/tkt3630.test 9a934c58c259f89a0ae6bb6bb846c56285a6fd0f\nF test/tkt3718.test 3b59dcb5c4e7754dacd91e7fd353a61492cc402a\nF test/tkt3731.test 0c5f4cbffe102d43c3b2188af91a9e36348f974b\nF test/tkt3757.test 10cd679a88675c880533083fc79ac04324525595\nF test/tkt3761.test b95ea9c98f21cf91325f18a984887e62caceab33\nF test/tkt3762.test 4d439ff7abdc8d9323150269d182c37c2d514576\nF test/tkt3773.test 7bca904d2a647a6a4a291bd86d7fd7c73855b789\nF test/tkt3791.test a6624b9a80b216a26cf473607f42f3e51898c267\nF test/tkt3793.test d90ffd75c52413908d15e1c44fc2ea9c80fcc449\nF test/tkt3810.test 09608d81c63a6ff3aaf7bc70717909c51f5f4048\nF test/tkt3824.test 150aa00bb6220672e5f0eb14dc8eaa36750425f0\nF test/tkt3832.test 2300d10d57562b89875b72148338ac3e14f8847d\nF test/tkt3838.test 292e72489101cd1320d7278dc111c173ebf334d4\nF test/tkt3841.test 4659845bc53f809a5932c61c6ce8c5bb9d6b947f\nF test/tkt3871.test d921703d07c68f4fd5312073215a17fa34b0401d\nF test/tkt3879.test 2ad5bef2c87e9991ce941e054c31abe26ef7fb90\nF test/tkt3911.test 74cd324f3ba653040cc6d94cc4857b290d12d633\nF test/tkt3918.test ea78bf164e4d55cbde0d83c671ef6fbe930a0032\nF test/tkt3922.test f26be40ab4fe6c00795629bd2006d96e270d9b1a\nF test/tkt3929.test cdf67acf5aa936ec4ffead81db87f8a71fe40e59\nF test/tkt3935.test e15261fedb9e30a4305a311da614a5d8e693c767\nF test/tkt3992.test f3e7d548ac26f763b47bc0f750da3d03c81071da\nF test/tkt3997.test a335fa41ca3985660a139df7b734a26ef53284bd\nF test/tkt4018.test 18dbc6617f7a4b90e938d1bd6d26ad18daafaf08\nF test/tokenize.test ce430a7aed48fc98301611429595883fdfcab5d7\nF test/tpch01.test 7c4eb8cdd79c568f46d344b3e789c9fdb8a766d112871352704861f3fca32a2a\nF test/trace.test a659a9862957f4789e37a92b3bf6d2caf5c86b02cdeefc41e850ae53acf6992a\nF test/trace2.test f5cb67ad3bc09e0c58e8cca78dfd0b5639259983\nF test/trace3.test 1dff966888773ff1bfea01c080caf15417892b3f998408fe920c4791f7337144\nF test/trans.test 6e1b4c6a42dba31bd65f8fa5e61a2708e08ddde6\nF test/trans2.test 62bd045bfc7a1c14c5ba83ba64d21ade31583f76\nF test/trans3.test 91a100e5412b488e22a655fe423a14c26403ab94\nF test/transitive1.test 293300f46916569f08875cdb2fe2134be2c27677\nF test/trigger1.test 746dc327e2a0817a22bfc6f5a5e423483d3e77b3733ac20a8fe939e6541b5e53\nF test/trigger2.test d15da46f7012832faf3e0c536b47024409d5fb1722d2bb77e29c06d96d704bb1\nF test/trigger3.test aa640bb2bbb03edd5ff69c055117ea088f121945\nF test/trigger4.test 74700b76ebf3947b2f7a92405141eb2cf2a5d359\nF test/trigger5.test 619391a3e9fc194081d22cefd830d811e7badf83\nF test/trigger6.test 0e411654f122552da6590f0b4e6f781048a4a9b9\nF test/trigger7.test e7ce54bfda67a88d778aea42544e151c465547a7e617127b6914c2221a6d53c1\nF test/trigger8.test 30cb0530bd7c4728055420e3f739aa00412eafa4\nF test/trigger9.test 2226ec795a33b0460ab5cf8891e9054cc7edef41\nF test/triggerA.test 837be862d8721f903dba3f3ceff05b32e0bee5214cf6ea3da5fadf12d3650e9d\nF test/triggerB.test 56780c031b454abac2340dbb3b71ac5c56c3d7fe\nF test/triggerC.test 29f5a28d0fe39e6e2c01f6e1f53f08c0955170ae10a63ad023e33cb0a1682a51\nF test/triggerD.test 8e7f3921a92a5797d472732108109e44575fa650\nF test/triggerE.test ede2e4bce4ba802337bd69d39447fa04a938e06d84a8bfc53c76850fc36ed86d\nF test/triggerF.test 5d76f0a8c428ff87a4d5ed52da06f6096a2c787a1e21b846111dfac4123de3ad\nF test/triggerG.test d5caeef6144ede2426dd13211fd72248241ff2ebc68e12a4c0bf30f5faa21499\nF test/tt3_checkpoint.c 9e75cf7c1c364f52e1c47fd0f14c4340a9db0fe1\nF test/tt3_index.c 39eec10a35f57672225be4d182862152896dee4a\nF test/tt3_lookaside1.c 0377e202c3c2a50d688cb65ba203afeda6fafeb9\nF test/tt3_stress.c c57d804716165811d979d4a719e05baccd79277f\nF test/tt3_vacuum.c 1753f45917699c9c1f66b64c717a717c9379f776\nF test/types.test bf816ce73c7dfcfe26b700c19f97ef4050d194ff\nF test/types2.test 1aeb81976841a91eef292723649b5c4fe3bc3cac\nF test/types3.test 99e009491a54f4dc02c06bdbc0c5eea56ae3e25a\nF test/unionvtab.test e1704ab1b4c1bb3ffc9da4681f8e85a0b909fd80b937984fc94b27415ac8e5a4\nF test/unionvtabfault.test e8759f3d14fb938ce9657e2342db34aeac0fb9bc1692b0d1ebb0069630151d06\nF test/unique.test 93f8b2ef5ea51b9495f8d6493429b1fd0f465264\nF test/unique2.test 3674e9f2a3f1fbbfd4772ac74b7a97090d0f77d2\nF test/unixexcl.test d936ba2b06794018e136418addd59a2354eeae97\nF test/unordered.test ffeea7747d5ba962a8009a20b7e53d68cbae05b063604c68702c5998eb50c981\nF test/update.test 6a1193fbcb4546b4467d24635b1504b8e746b41d3b66dc6ace07581a62ce58fb\nF test/update2.test 67455bc61fcbcf96923c45b3bc4f87bc72be7d67575ad35f134906148c7b06d3\nF test/upsert1.test 0b740c8488fd2f5a06ac317c9913f7ef1eda8282f2db58b544b89480c51efab3\nF test/upsert2.test 9c3cdbb1a890227f6504ce4b0e3de68f4cdfa16bb21d8641208a9239896c5a09\nF test/upsert3.test 88d7d590a1948a9cb6eac1b54b0642f67a9f35a1fc0f19b200e97d5d39e3179c\nF test/upsert4.test 25d2a1da92f149331ae0c51ca6e3eee78189577585eab92de149900d62994fa5\nF test/upsertfault.test f21ca47740841fdb4d61acfa7b17646d773e67724fe8c185b71c018db8a94b35\nF test/uri.test 3481026f00ade6dfe8adb7acb6e1e47b04369568\nF test/uri2.test 9d3ba7a53ee167572d53a298ee4a5d38ec4a8fb7\nF test/userauth01.test e740a2697a7b40d7c5003a7d7edaee16acd349a9\nF test/utf16align.test 54cd35a27c005a9b6e7815d887718780b6a462ae\nF test/vacuum-into.test 48f4cec354fb6f27c98ef58d2fe49a11b71ff131af0cd9140efacc9858b9f670\nF test/vacuum.test ce91c39f7f91a4273bf620efad21086b5aa6ef1d\nF test/vacuum2.test aa048abee196c16c9ba308465494009057b79f9b\nF test/vacuum3.test 77ecdd54592b45a0bcb133339f99f1ae0ae94d0d\nF test/vacuum4.test 7ea76b769fffeb41f925303b04cbcf5a5bbeabe55e4c60ae754ff24eeeb7c010\nF test/vacuum5.test 263b144d537e92ad8e9ca8a73cc6e1583f41cfd0dda9432b87f7806174a2f48c\nF test/vacuummem.test 7b42abb3208bd82dd23a7536588396f295a314f2\nF test/varint.test bbce22cda8fc4d135bcc2b589574be8410614e62\nF test/veryquick.test 57ab846bacf7b90cf4e9a672721ea5c5b669b661\nF test/view.test 10ea54300a097d7c0337fd104abffe4a4786d1598b94017a37efe0e0d3e04dd5\nF test/vtab1.test c5d9e90ed02bcacd776dcbb7360199d290f7f53c26b484ddece543060c54319f\nF test/vtab2.test 14d4ab26cee13ba6cf5c5601b158e4f57552d3b055cdd9406cf7f711e9c84082\nF test/vtab3.test b45f47d20f225ccc9c28dc915d92740c2dee311e\nF test/vtab4.test 8e73ed268f3d596bc3590f45fc948fb40f28e9c3\nF test/vtab5.test 889f444970393c73f1e077e2bdc5d845e157a391\nF test/vtab6.test 8e789f526e6594cf7ae933d1adee0caa87dc9f78\nF test/vtab7.test 70c6f4a1d6177144a8236e4172d5fba92e683440374664ad1f04851fbb335d3c\nF test/vtab8.test e19fa4a538fcd1bb66c22825fa8f71618fb13583\nF test/vtab9.test ea58d2b95d61955f87226381716b2d0b1d4e4f9b\nF test/vtabA.test 1317f06a03597eee29f40a49b6c21e1aaba4285f\nF test/vtabB.test 04df5dc531b9f44d9ca65b9c1b79f12b5922a796\nF test/vtabC.test 4528f459a13136f982e75614d120aef165f17292\nF test/vtabD.test 05b3f1d77117271671089e48719524b676842e96\nF test/vtabE.test 2a143fe75a11275781d1fd1988d86b66a3f69cb98f4add62e3da8fd0f637b45f\nF test/vtabF.test 1918844c7c902f6a16c8dacf1ec8f84886d6e78b\nF test/vtabH.test 2efb5a24b0bb50796b21eca23032cfb77abfa4b0c03938e38ce5897abac404ca\nF test/vtabI.test 751b07636700dbdea328e4265b6077ccd6811a3f\nF test/vtabJ.test d7b73675708cf63cfcb9d443bb451fc01a028347275b7311e51f9fdf3ca6757f\nF test/vtab_alter.test 736e66fb5ec7b4fee58229aa3ada2f27ec58bc58c00edae4836890c3784c6783\nF test/vtab_err.test dcc8b7b9cb67522b3fe7a272c73856829dae4ab7fdb30399aea1b6981bda2b65\nF test/vtab_shared.test 5253bff2355a9a3f014c15337da7e177ab0ef8ad\nF test/vtabdrop.test 65d4cf6722972e5499bdaf0c0d70ee3b8133944a4e4bc31862563f32a7edca12\nF test/wal.test cdf0ca6cc0447520d19ef1c83287824ebeb3e82d75af856511ba96841a79fc9b\nF test/wal2.test 537f59e5c5932e3b45bf3591ae3e48a2601360c2e52821b633e222fe6ebd5b09\nF test/wal3.test 2a93004bc0fb2b5c29888964024695bade278ab2\nF test/wal4.test 4744e155cd6299c6bd99d3eab1c82f77db9cdb3c\nF test/wal5.test 9c11da7aeccd83a46d79a556ad11a18d3cb15aa9\nF test/wal6.test b602704e4b066199bc89d91ca9000f335dcf4572\nF test/wal64k.test 2a525c0f45d709bae3765c71045ccec5df7d100ccbd3a7860fdba46c9addb965\nF test/wal7.test 2ae8f427d240099cc4b2dfef63cff44e2a68a1bd\nF test/wal8.test d9df3fba4caad5854ed69ed673c68482514203c8\nF test/wal9.test 378e76a9ad09cd9bee06c172ad3547b0129a6750\nF test/wal_common.tcl a98f17fba96206122eff624db0ab13ec377be4fe\nF test/walbak.test 018d4e5a3d45c6298d11b99f09a8ef6876527946\nF test/walbig.test f437473a16cfb314867c6b5d1dbcd519e73e3434\nF test/walblock.test be48f3a75eff0b4456209f26b3ce186c2015497d\nF test/walcksum.test bb234a1bb42248b3515d992b719708015c384278\nF test/walcrash.test 21038858cc552077b0522f50b0fa87e38139306a\nF test/walcrash2.test a0edab4e5390f03b99a790de89aad15d6ec70b36\nF test/walcrash3.test e426aa58122d20f2b9fbe9a507f9eb8cab85b8af\nF test/walcrash4.test e7b6e7639a950a0cca8e210e248c8dad4d63bf20\nF test/walfault.test 09b8ad7e52d2f54bce50e31aa7ea51412bb9f70ac13c74e669ddcd8b48b0d98d\nF test/walfault2.test e039ac66c78d5561683cacde04097213cdad3b58e2b3f3fe1112862217bfd915\nF test/walhook.test ed00a40ba7255da22d6b66433ab61fab16a63483\nF test/walmode.test cd6e7cff618eaaa5910ce57c3657aa50110397f86213886a2400afb9bfec7b7b\nF test/walnoshm.test 84ca10c544632a756467336b7c3b864d493ee496\nF test/waloverwrite.test dad2f26567f1b45174e54fbf9a8dc1cb876a7f03\nF test/walpersist.test 8c6b7e3ec1ba91b5e4dc4e0921d6d3f87cd356a6\nF test/walprotocol.test a112aba0b79e3adeaa485fed09484b32c654e97df58e454aa8489ac2cd57bf84\nF test/walprotocol2.test 7d3b6b4bf0b12f8007121b1e6ef714bc99101fb3b48e46371df1db868eebc131\nF test/walro.test cb438d05ba0d191f10b688e39c4f0cd5b71569a1d1f4440e5bdf3c6880e08c20\nF test/walro2.test 0e79dd15cbdb4f482c01ea248373669c732414a726b357d04846a816afafb768\nF test/walrofault.test c70cb6e308c443867701856cce92ad8288cd99488fa52afab77cca6cfd51af68\nF test/walshared.test 0befc811dcf0b287efae21612304d15576e35417\nF test/walslow.test c05c68d4dc2700a982f89133ce103a1a84cc285f\nF test/walthread.test 14b20fcfa6ae152f5d8e12f5dc8a8a724b7ef189f5d8ef1e2ceab79f2af51747\nF test/walvfs.test ca81c9f427e0e5434076dfa948fd1d8e6d5ddd192b2fb6991635d81da5f3f5d4\nF test/wapp.tcl b440cd8cf57953d3a49e7ee81e6a18f18efdaf113b69f7d8482b0710a64566ec\nF test/wapptest.tcl 3cca775aede0591756a1fc0da55bbb3715d8c363873fd2cfdd4d555b0a4af57d x\nF test/where.test 19c709c9f0f6ed12c23f909f6592aa55fba34269d5a2898537aa27a22b9ce650\nF test/where2.test 478d2170637b9211f593120648858593bf2445a1\nF test/where3.test 2341a294e17193a6b1699ea7f192124a5286ca6acfcc3f4b06d16c931fbcda2c\nF test/where4.test 4a371bfcc607f41d233701bdec33ac2972908ba8\nF test/where5.test fdf66f96d29a064b63eb543e28da4dfdccd81ad2\nF test/where6.test 5da5a98cec820d488e82708301b96cb8c18a258b\nF test/where7.test 75722434c486ac9e74718caa6cce234f45ba34c0b6c0f9555b29eb8bb5f6ade1\nF test/where8.test 461ca40265ed996a6305da99bb024b0e41602bb586acf544c08f95922358e49f\nF test/where9.test 2c554b97bbdb2fdf26c57099f60db8a52bfcf7c147f2c256f9798fa0e267ca85\nF test/whereA.test 6c6a420ca7d313242f9b1bd471dc80e4d0f8323700ba9c78df0bb843d4daa3b4\nF test/whereB.test 0def95db3bdec220a731c7e4bec5930327c1d8c5\nF test/whereC.test cae295158703cb3fc23bf1a108a9ab730efff0f6\nF test/whereD.test 711d4df58d6d4fb9b3f5ce040b818564198be002\nF test/whereE.test b3a055eef928c992b0a33198a7b8dc10eea5ad2f\nF test/whereF.test 3d9412b1199d3e2bed34fcb76b4c48d0bf4df95d27e3f8dd27b6f8b4716d0d89\nF test/whereG.test 4cda56de49f0c7d9a4f2590a3ddc5f79a7f2a03d2229d0f5bb5d3981ce57f293\nF test/whereH.test e4b07f7a3c2f5d31195cd33710054c78667573b2\nF test/whereI.test a2874062140ed4aba9ffae76e6190a3df6fc73d1373fdfa8fd632945082a5364\nF test/whereJ.test 88287550f6ee604422403b053455b1ad894eeaa5c35d348532dfa1439286cb9a\nF test/whereK.test f8e3cf26a8513ecc7f514f54df9f0572c046c42b\nF test/whereL.test 0a19fc44cd1122040f56c934f1b14d0ca85bde28f270268a428dd9796ea0634c\nF test/wherefault.test 1374c3aa198388925246475f84ad4cd5f9528864\nF test/wherelfault.test 9012e4ef5259058b771606616bd007af5d154e64cc25fa9fd4170f6411db44e3\nF test/wherelimit.test 592081800806d297dd7449b1030c863d2883d6d42901837ccd2e5a9bd962edb0\nF test/wherelimit2.test 9bf0aa56cca40ea0e4c5e2915341355a2bbc0859ec4ce1589197fe2a9d94635f\nF test/win32heap.test 10fd891266bd00af68671e702317726375e5407561d859be1aa04696f2aeee74\nF test/win32lock.test fbf107c91d8f5512be5a5b87c4c42ab9fdd54972\nF test/win32longpath.test 169c75a3b2e43481f4a62122510210c67b08f26d\nF test/win32nolock.test ac4f08811a562e45a5755e661f45ca85892bdbbc\nF test/window1.test 6db2c38a0830af8554936a563df92e67962cc379253854cd10d0c3cf0a3120c4\nF test/window2.tcl 66db96fd9fd202bc31ee7f8ce7904cb469564864cff3f74e009bfef8102333f4\nF test/window2.test af2a001ded703bb8f2474fb0edfef170d5aba00f5c1f2aa9f65935b5da13df90\nF test/window3.tcl acea6e86a4324a210fd608d06741010ca83ded9fde438341cb978c49928faf03\nF test/window3.test e9959a993c8a71e96433be8daaa1827d78b8921e4f12debd7bdbeb3c856ef3cb\nF test/window4.tcl d732df0e81beedc0ba8a563ade68611d322d27303ad0c0c8e4444107c39e84ec\nF test/window4.test 807f3e6b15f9338e5b9742b87c5c7ca825b42b9657fde6096e890119370848e0\nF test/window5.test d328dd18221217c49c144181975eea17339eaeaf0e9aa558cee3afb84652821e\nF test/window6.test f8d674254b23289cc17c84d79dec7eda7caa1dfb7836c43122cfdf3640d1df32\nF test/window7.tcl 6a1210f05d40ec89c22960213a22cd3f98d4e2f2eb20646c83c8c30d4d76108f\nF test/window7.test 1d31276961ae7801edc72173edaf7593e3cbc79c06d1f1f09e20d8418af403cd\nF test/window8.tcl f2711aa3571e4e6b0dad98db8d95fd6cb8d9db0c92bbdf535f153b07606a1ce2\nF test/window8.test c4331b27a6f66d69fa8f8bab10cc731db1a81d293ae108a68f7c3487fa94e65b\nF test/window9.test b63f6f74d730547e63e78946f951f5d1a7d4e99f91f6d5906305469043d92a15\nF test/windowA.test 6d63dc1260daa17141a55007600581778523a8b420629f1282d2acfc36af23be\nF test/windowB.test 7a983ea1cc1cf72be7f378e4b32f6cb2d73014c5cd8b25aaee825164cd4269e5\nF test/windowerr.tcl f5acd6fbc210d7b5546c0e879d157888455cd4a17a1d3f28f07c1c8a387019e0\nF test/windowerr.test a8b752402109c15aa1c5efe1b93ccb0ce1ef84fa964ae1cd6684dd0b3cc1819b\nF test/windowfault.test a90b397837209f15e54afa62e8be39b2759a0101fae04e05a08bcc50e243a452\nF test/with1.test d32792084dcb5f6c047d77bb8a032822ef9fe050ade07d0aeffa37753a05e3c9\nF test/with2.test e0030e2f0267a910d6c0e4f46f2dfe941c1cc0d4f659ba69b3597728e7e8f1ab\nF test/with3.test 7de8dff2891aca0f9453463e4a2d6eb995baf137827d5596116fee53e22a4e29\nF test/with4.test 257be66c0c67fee1defbbac0f685c3465e2cad037f21ce65f23f86084f198205\nF test/withM.test 693b61765f2b387b5e3e24a4536e2e82de15ff64\nF test/without_rowid1.test 9cfb83705c506e3849fa7efc88a3c9a15f9a50bf9b1516b41757a7cef9bba8c3\nF test/without_rowid2.test af260339f79d13cb220288b67cd287fbcf81ad99\nF test/without_rowid3.test ea4b59dd1b0d7f5f5e4b7cca978cdb905752a9d7c57dc4344a591dba765a3691\nF test/without_rowid4.test 4e08bcbaee0399f35d58b5581881e7a6243d458a\nF test/without_rowid5.test 89b1c587bd92a0590e440da33e7666bf4891572a\nF test/without_rowid6.test 8463b20098e9f75a501a9f17dfb42fffc79068eac0b2775fe56ef2281d2df45e\nF test/without_rowid7.test d7c59a93d726b55812d620f8f284e01904a5b85f9ee9eea8f2f68571a5e8c40e\nF test/wordcount.c d721a4b6fae93e6e33449700bce1686bc23257c27425bc3ef1599dc912adec66\nF test/writecrash.test f1da7f7adfe8d7f09ea79b42e5ca6dcc41102f27f8e334ad71539501ddd910cc\nF test/zeroblob.test 07a5b11ab591d1f26c626945fb7f228f68b993533b2ada77273edf6ee29db174\nF test/zerodamage.test 9c41628db7e8d9e8a0181e59ea5f189df311a9f6ce99cc376dc461f66db6f8dc\nF test/zipfile.test daab4c9be151934fd6bbc71a0d2520351efc61719eabbf545920f953883d172a\nF test/zipfile2.test 9903388a602a3834189857a985106ff95c3bba6a3969e0134127df991889db5d\nF test/zipfilefault.test 44d4d7a7f7cca7521d569d7f71026b241d65a6b1757aa409c1a168827edbbc2c\nF tool/GetFile.cs 47852aa0d806fe47ed1ac5138bdce7f000fe87aaa7f28107d0cb1e26682aeb44\nF tool/GetTclKit.bat 8995df40c4209808b31f24de0b58f90930239a234f7591e3675d45bfbb990c5d\nF tool/Replace.cs 02c67258801c2fb5f63231e0ac0f220b4b36ba91\nF tool/build-all-msvc.bat c12328d06c45fec8baada5949e3d5af54bf8c887 x\nF tool/build-shell.sh 950f47c6174f1eea171319438b93ba67ff5bf367\nF tool/cg_anno.tcl c1f875f5a4c9caca3d59937b16aff716f8b1883935f1b4c9ae23124705bc8099 x\nF tool/checkSpacing.c 810e51703529a204fc4e1eb060e9ab663e3c06d2\nF tool/dbhash.c 19560c9a2aa2b269b6a5108259b93d26d12f8f0877c31fe9f8f61dfbd219ba63\nF tool/dbtotxt.c b2221864a20fb391c46bd31bc1fbdc4a96f5c8a89bef58f421eb9b9c36b1702c\nF tool/dbtotxt.md c9a57af8739957ef36d2cfad5c4b1443ff3688ed33e4901ee200c8b651f43f3c\nF tool/extract-sqlite3h.tcl 069ceab0cee26cba99952bfa08c0b23e35941c837acabe143f0c355d96c9e2eb x\nF tool/extract.c 054069d81b095fbdc189a6f5d4466e40380505e2\nF tool/fast_vacuum.c 5ba0d6f5963a0a63bdc42840f678bad75b2ebce1\nF tool/fragck.tcl 5265a95126abcf6ab357f7efa544787e5963f439\nF tool/fuzzershell.c e1d90a03ca790d7c331c2aae08ca46ff435f1ae1faa6cb9cc48f4687c18fdc6e\nF tool/genfkey.README cf68fddd4643bbe3ff8e31b8b6d8b0a1b85e20f4\nF tool/genfkey.test b6afd7b825d797a1e1274f519ab5695373552ecad5cd373530c63533638a5a4f\nF tool/getlock.c f4c39b651370156cae979501a7b156bdba50e7ce\nF tool/index_usage.c 9ec344d29cbeb03fdc0fce668eedfb7495792170de933adf95cf8d6904a166ad\nF tool/kvtest-speed.sh 4761a9c4b3530907562314d7757995787f7aef8f\nF tool/lemon.c a361b85fa230560b783006ac002a6a8bad214c3b9d7fa48980aecc2b691ddcad\nF tool/lempar.c e8899b28488f060d0ff931539ea6311b16b22dce068c086c788a06d5e8d01ab7\nF tool/libvers.c caafc3b689638a1d88d44bc5f526c2278760d9b9\nF tool/loadfts.c c3c64e4d5e90e8ba41159232c2189dba4be7b862\nF tool/logest.c 11346aa019e2e77a00902aa7d0cabd27bd2e8cca\nF tool/max-limits.c cbb635fbb37ae4d05f240bfb5b5270bb63c54439\nF tool/mkautoconfamal.sh 422fc365358a2e92876ffc62971a0ff28ed472fc8bcf9de0df921c736fdeca5e\nF tool/mkccode.tcl 86463e68ce9c15d3041610fedd285ce32a5cf7a58fc88b3202b8b76837650dbe x\nF tool/mkctimec.tcl dd183b73ae1c28249669741c250525f0407e579a70482371668fd5f130d9feb3\nF tool/mkkeywordhash.c 27ffc6f6e7e3ecbfc5bca1f1f11a09fc5badf6d67557a5fb2d3b069dbed90617\nF tool/mkmsvcmin.tcl cad0c7b54d7dd92bc87d59f36d4cc4f070eb2e625f14159dc2f5c4204e6a13ea\nF tool/mkopcodec.tcl d1b6362bd3aa80d5520d4d6f3765badf01f6c43c\nF tool/mkopcodeh.tcl 352a4319c0ad869eb26442bf7c3b015aa15594c21f1cce5a6420dbe999367c21\nF tool/mkopts.tcl 680f785fdb09729fd9ac50632413da4eadbdf9071535e3f26d03795828ab07fa\nF tool/mkpragmatab.tcl 70269c7013dab01c5d366b1bb4cee6e42fa1a3a8d179a052d14d6b31f11ad77f\nF tool/mkshellc.tcl 70a9978e363b0f3280ca9ce1c46d72563ff479c1930a12a7375e3881b7325712\nF tool/mksourceid.c 36aa8020014aed0836fd13c51d6dc9219b0df1761d6b5f58ff5b616211b079b9\nF tool/mkspeedsql.tcl a1a334d288f7adfe6e996f2e712becf076745c97\nF tool/mksqlite3c-noext.tcl 4f7cfef5152b0c91920355cbfc1d608a4ad242cb819f1aea07f6d0274f584a7f\nF tool/mksqlite3c.tcl 5fed3d75069d8f66f202d3b5200b0cea4aa7108481acd06732a06fdd42eb83a2\nF tool/mksqlite3h.tcl 080873e3856eceb9d289a08a00c4b30f875ea3feadcbece796bd509b1532792c\nF tool/mksqlite3internalh.tcl eb994013e833359137eb53a55acdad0b5ae1049b\nF tool/mkvsix.tcl b9e0777a213c23156b6542842c238479e496ebf5\nF tool/offsets.c fe4262fdfa378e8f5499a42136d17bf3b98f6091\nF tool/omittest.tcl 27f9413c3343bac200a28d81e8234adb0f5e141c4771893cb19b40235a91f1e0\nF tool/opcodesum.tcl 740ed206ba8c5040018988129abbf3089a0ccf4a\nF tool/pagesig.c ff0ca355fd3c2398e933da5e22439bbff89b803b\nF tool/replace.tcl 60f91e8dd06ab81f74d213ecbd9c9945f32ac048\nF tool/restore_jrnl.tcl 6957a34f8f1f0f8285e07536225ec3b292a9024a\nF tool/rollback-test.c 9fc98427d1e23e84429d7e6d07d9094fbdec65a5\nF tool/run-speed-test.sh f95d19fd669b68c4c38b6b475242841d47c66076\nF tool/showdb.c 97d14a1ce32d5edda84081a5c939bd8975abd89568a773b288940e67e4c7e3ad\nF tool/showjournal.c 5bad7ae8784a43d2b270d953060423b8bd480818\nF tool/showlocks.c 9920bcc64f58378ff1118caead34147201f48c68\nF tool/showshm.c a0ab6ec32dd1f11218ca2a4018f8fb875b59414801ab8ceed8b2e69b7b45a809\nF tool/showstat4.c 0682ebea7abf4d3657f53c4a243f2e7eab48eab344ed36a94bb75dcd19a5c2a1\nF tool/showwal.c ad9d768f96ca6199ad3a8c9562d679680bd032dd01204ea3e5ea6fb931d81847\nF tool/soak1.tcl 8d407956e1a45b485a8e072470a3e629a27037fe\nF tool/spaceanal.tcl 4bfd19aad7eb3ce0372ef0255f58035e0bba4ff5e9acfd763a10c6fb365c8dec\nF tool/speed-check.sh 2b042d703a9472f08c3b13be27afac658426f8e4fc87cd2d575953fda86f08d1\nF tool/speedtest.tcl 06c76698485ccf597b9e7dbb1ac70706eb873355\nF tool/speedtest16.c ecb6542862151c3e6509bbc00509b234562ae81e\nF tool/speedtest2.tcl ee2149167303ba8e95af97873c575c3e0fab58ff\nF tool/speedtest8.c 2902c46588c40b55661e471d7a86e4dd71a18224\nF tool/speedtest8inst1.c 7ce07da76b5e745783e703a834417d725b7d45fd\nF tool/split-sqlite3c.tcl 3efcd4240b738f6bb2b5af0aea7e1e0ef9bc1c61654f645076cec883030b710c\nF tool/sqldiff.c 7b9b7238284f02131dbb8f21a4e862409bff728045c5473139d28c67ac87580e\nF tool/sqlite3_analyzer.c.in 7eeaae8b0d7577662acaabbb11107af0659d1b41bc1dfdd4d91422de27127968\nF tool/sqltclsh.c.in 1bcc2e9da58fadf17b0bf6a50e68c1159e602ce057210b655d50bad5aaaef898\nF tool/sqltclsh.tcl 862f4cf1418df5e1315b5db3b5ebe88969e2a784525af5fbf9596592f14ed848\nF tool/srcck1.c 371de5363b70154012955544f86fdee8f6e5326f\nF tool/stack_usage.tcl f8e71b92cdb099a147dad572375595eae55eca43\nF tool/symbols-mingw.sh 4dbcea7e74768305384c9fd2ed2b41bbf9f0414d\nF tool/symbols.sh 1612bd947750e21e7b47befad5f6b3825b06cce0705441f903bf35ced65ae9b9\nF tool/varint.c 5d94cb5003db9dbbcbcc5df08d66f16071aee003\nF tool/vdbe-compress.tcl 5926c71f9c12d2ab73ef35c29376e756eb68361c\nF tool/vdbe_profile.tcl 246d0da094856d72d2c12efec03250d71639d19f\nF tool/warnings-clang.sh bbf6a1e685e534c92ec2bfba5b1745f34fb6f0bc2a362850723a9ee87c1b31a7\nF tool/warnings.sh 09311479bdc290e20ec8e35a3d1b14b096bbd96222277cfd6274c3a99b3d012f\nF tool/win/sqlite.vsix deb315d026cc8400325c5863eef847784a219a2f\nF vsixtest/App.xaml b76d3b48860e7454775c47ea38ffea9c4abe3e85\nF vsixtest/App.xaml.cpp c465147f50871165c60ca16955219f6c5812d6d8\nF vsixtest/App.xaml.h 4a9768e2983d05600ad1e1c2f1b00a132967da9f\nF vsixtest/Assets/LockScreenLogo.scale-200.png e820c9a3deb909197081b0bf3216c06e13905f0a\nF vsixtest/Assets/SplashScreen.scale-200.png cab70988ca71bebec7bfeb3b6dbafe17b9ab0b4a\nF vsixtest/Assets/Square150x150Logo.scale-200.png e17b40817db7a239fc239d83efcc951fb824e3ff\nF vsixtest/Assets/Square44x44Logo.scale-200.png 2f166237094dea94d952d10b9eeae81806844f1c\nF vsixtest/Assets/Square44x44Logo.targetsize-24_altform-unplated.png 5f6a6d391b95a3061ccca6e6fdd6955ede63b4ed\nF vsixtest/Assets/StoreLogo.png 0828b7257db74a4ecd5eeb6b7b4971f0fdc4d9d1\nF vsixtest/Assets/Wide310x150Logo.scale-200.png 04ddefe5bc5f43ae12a7433f6f236ddab101ac42\nF vsixtest/MainPage.xaml 34f49897e3ca533a7e74506ba0759b66eebce151\nF vsixtest/MainPage.xaml.cpp 7f31fc6de751b64676c0924c97a5485d950a91d7\nF vsixtest/MainPage.xaml.h cc05cca10d50a003f6c6e4448b701cdd07f52f29\nF vsixtest/Package.appxmanifest 6b6db1eb7df3a315c5d681059754d5f0e0c47a93\nF vsixtest/pch.cpp cb823cfac36f1a39a7eb0acbd7e9a0b0de8f23af\nF vsixtest/pch.h 9cab7980f2ac4baa40807d8b5e52af32a21cf78c\nF vsixtest/vsixtest.sln 77cadbe4e96c1fe1bf51cd77de9e9b0a12ada547\nF vsixtest/vsixtest.tcl 6a9a6ab600c25a91a7acc6293828957a386a8a93\nF vsixtest/vsixtest.vcxproj.data 2ed517e100c66dc455b492e1a33350c1b20fbcdc\nF vsixtest/vsixtest.vcxproj.filters 37e51ffedcdb064aad6ff33b6148725226cd608e\nF vsixtest/vsixtest_TemporaryKey.pfx e5b1b036facdb453873e7084e1cae9102ccc67a0\nP 4417c5bf0aabb34ed174f01afd981c924ae965a42128719d8d6735536631d12f\nR f9500979ead80e4e63134871bf8fc127\nU drh\nZ b61065dbf7c71aac52e79a354be5735d\n", "e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f", "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains routines used for analyzing expressions and\n** for generating VDBE code that evaluates expressions in SQLite.\n*/\n#include \"sqliteInt.h\"\n\n/* Forward declarations */\nstatic void exprCodeBetween(Parse*,Expr*,int,void(*)(Parse*,Expr*,int,int),int);\nstatic int exprCodeVector(Parse *pParse, Expr *p, int *piToFree);\n\n/*\n** Return the affinity character for a single column of a table.\n*/\nchar sqlite3TableColumnAffinity(Table *pTab, int iCol){\n  assert( iCol<pTab->nCol );\n  return iCol>=0 ? pTab->aCol[iCol].affinity : SQLITE_AFF_INTEGER;\n}\n\n/*\n** Return the 'affinity' of the expression pExpr if any.\n**\n** If pExpr is a column, a reference to a column via an 'AS' alias,\n** or a sub-select with a column as the return value, then the \n** affinity of that column is returned. Otherwise, 0x00 is returned,\n** indicating no affinity for the expression.\n**\n** i.e. the WHERE clause expressions in the following statements all\n** have an affinity:\n**\n** CREATE TABLE t1(a);\n** SELECT * FROM t1 WHERE a;\n** SELECT a AS b FROM t1 WHERE b;\n** SELECT * FROM t1 WHERE (select a from t1);\n*/\nchar sqlite3ExprAffinity(Expr *pExpr){\n  int op;\n  while( ExprHasProperty(pExpr, EP_Skip) ){\n    assert( pExpr->op==TK_COLLATE );\n    pExpr = pExpr->pLeft;\n    assert( pExpr!=0 );\n  }\n  op = pExpr->op;\n  if( op==TK_SELECT ){\n    assert( pExpr->flags&EP_xIsSelect );\n    return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);\n  }\n  if( op==TK_REGISTER ) op = pExpr->op2;\n#ifndef SQLITE_OMIT_CAST\n  if( op==TK_CAST ){\n    assert( !ExprHasProperty(pExpr, EP_IntValue) );\n    return sqlite3AffinityType(pExpr->u.zToken, 0);\n  }\n#endif\n  if( (op==TK_AGG_COLUMN || op==TK_COLUMN) && pExpr->y.pTab ){\n    return sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n  }\n  if( op==TK_SELECT_COLUMN ){\n    assert( pExpr->pLeft->flags&EP_xIsSelect );\n    return sqlite3ExprAffinity(\n        pExpr->pLeft->x.pSelect->pEList->a[pExpr->iColumn].pExpr\n    );\n  }\n  if( op==TK_VECTOR ){\n    return sqlite3ExprAffinity(pExpr->x.pList->a[0].pExpr);\n  }\n  return pExpr->affExpr;\n}\n\n/*\n** Set the collating sequence for expression pExpr to be the collating\n** sequence named by pToken.   Return a pointer to a new Expr node that\n** implements the COLLATE operator.\n**\n** If a memory allocation error occurs, that fact is recorded in pParse->db\n** and the pExpr parameter is returned unchanged.\n*/\nExpr *sqlite3ExprAddCollateToken(\n  Parse *pParse,           /* Parsing context */\n  Expr *pExpr,             /* Add the \"COLLATE\" clause to this expression */\n  const Token *pCollName,  /* Name of collating sequence */\n  int dequote              /* True to dequote pCollName */\n){\n  if( pCollName->n>0 ){\n    Expr *pNew = sqlite3ExprAlloc(pParse->db, TK_COLLATE, pCollName, dequote);\n    if( pNew ){\n      pNew->pLeft = pExpr;\n      pNew->flags |= EP_Collate|EP_Skip;\n      pExpr = pNew;\n    }\n  }\n  return pExpr;\n}\nExpr *sqlite3ExprAddCollateString(Parse *pParse, Expr *pExpr, const char *zC){\n  Token s;\n  assert( zC!=0 );\n  sqlite3TokenInit(&s, (char*)zC);\n  return sqlite3ExprAddCollateToken(pParse, pExpr, &s, 0);\n}\n\n/*\n** Skip over any TK_COLLATE operators.\n*/\nExpr *sqlite3ExprSkipCollate(Expr *pExpr){\n  while( pExpr && ExprHasProperty(pExpr, EP_Skip) ){\n    assert( pExpr->op==TK_COLLATE );\n    pExpr = pExpr->pLeft;\n  }   \n  return pExpr;\n}\n\n/*\n** Skip over any TK_COLLATE operators and/or any unlikely()\n** or likelihood() or likely() functions at the root of an\n** expression.\n*/\nExpr *sqlite3ExprSkipCollateAndLikely(Expr *pExpr){\n  while( pExpr && ExprHasProperty(pExpr, EP_Skip|EP_Unlikely) ){\n    if( ExprHasProperty(pExpr, EP_Unlikely) ){\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      assert( pExpr->x.pList->nExpr>0 );\n      assert( pExpr->op==TK_FUNCTION );\n      pExpr = pExpr->x.pList->a[0].pExpr;\n    }else{\n      assert( pExpr->op==TK_COLLATE );\n      pExpr = pExpr->pLeft;\n    }\n  }   \n  return pExpr;\n}\n\n/*\n** Return the collation sequence for the expression pExpr. If\n** there is no defined collating sequence, return NULL.\n**\n** See also: sqlite3ExprNNCollSeq()\n**\n** The sqlite3ExprNNCollSeq() works the same exact that it returns the\n** default collation if pExpr has no defined collation.\n**\n** The collating sequence might be determined by a COLLATE operator\n** or by the presence of a column with a defined collating sequence.\n** COLLATE operators take first precedence.  Left operands take\n** precedence over right operands.\n*/\nCollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){\n  sqlite3 *db = pParse->db;\n  CollSeq *pColl = 0;\n  Expr *p = pExpr;\n  while( p ){\n    int op = p->op;\n    if( op==TK_REGISTER ) op = p->op2;\n    if( (op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_TRIGGER)\n     && p->y.pTab!=0\n    ){\n      /* op==TK_REGISTER && p->y.pTab!=0 happens when pExpr was originally\n      ** a TK_COLUMN but was previously evaluated and cached in a register */\n      int j = p->iColumn;\n      if( j>=0 ){\n        const char *zColl = p->y.pTab->aCol[j].zColl;\n        pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);\n      }\n      break;\n    }\n    if( op==TK_CAST || op==TK_UPLUS ){\n      p = p->pLeft;\n      continue;\n    }\n    if( op==TK_VECTOR ){\n      p = p->x.pList->a[0].pExpr;\n      continue;\n    }\n    if( op==TK_COLLATE ){\n      pColl = sqlite3GetCollSeq(pParse, ENC(db), 0, p->u.zToken);\n      break;\n    }\n    if( p->flags & EP_Collate ){\n      if( p->pLeft && (p->pLeft->flags & EP_Collate)!=0 ){\n        p = p->pLeft;\n      }else{\n        Expr *pNext  = p->pRight;\n        /* The Expr.x union is never used at the same time as Expr.pRight */\n        assert( p->x.pList==0 || p->pRight==0 );\n        if( p->x.pList!=0 \n         && !db->mallocFailed\n         && ALWAYS(!ExprHasProperty(p, EP_xIsSelect))\n        ){\n          int i;\n          for(i=0; i<p->x.pList->nExpr; i++){\n            if( ExprHasProperty(p->x.pList->a[i].pExpr, EP_Collate) ){\n              pNext = p->x.pList->a[i].pExpr;\n              break;\n            }\n          }\n        }\n        p = pNext;\n      }\n    }else{\n      break;\n    }\n  }\n  if( sqlite3CheckCollSeq(pParse, pColl) ){ \n    pColl = 0;\n  }\n  return pColl;\n}\n\n/*\n** Return the collation sequence for the expression pExpr. If\n** there is no defined collating sequence, return a pointer to the\n** defautl collation sequence.\n**\n** See also: sqlite3ExprCollSeq()\n**\n** The sqlite3ExprCollSeq() routine works the same except that it\n** returns NULL if there is no defined collation.\n*/\nCollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr){\n  CollSeq *p = sqlite3ExprCollSeq(pParse, pExpr);\n  if( p==0 ) p = pParse->db->pDfltColl;\n  assert( p!=0 );\n  return p;\n}\n\n/*\n** Return TRUE if the two expressions have equivalent collating sequences.\n*/\nint sqlite3ExprCollSeqMatch(Parse *pParse, Expr *pE1, Expr *pE2){\n  CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pE1);\n  CollSeq *pColl2 = sqlite3ExprNNCollSeq(pParse, pE2);\n  return sqlite3StrICmp(pColl1->zName, pColl2->zName)==0;\n}\n\n/*\n** pExpr is an operand of a comparison operator.  aff2 is the\n** type affinity of the other operand.  This routine returns the\n** type affinity that should be used for the comparison operator.\n*/\nchar sqlite3CompareAffinity(Expr *pExpr, char aff2){\n  char aff1 = sqlite3ExprAffinity(pExpr);\n  if( aff1>SQLITE_AFF_NONE && aff2>SQLITE_AFF_NONE ){\n    /* Both sides of the comparison are columns. If one has numeric\n    ** affinity, use that. Otherwise use no affinity.\n    */\n    if( sqlite3IsNumericAffinity(aff1) || sqlite3IsNumericAffinity(aff2) ){\n      return SQLITE_AFF_NUMERIC;\n    }else{\n      return SQLITE_AFF_BLOB;\n    }\n  }else{\n    /* One side is a column, the other is not. Use the columns affinity. */\n    assert( aff1<=SQLITE_AFF_NONE || aff2<=SQLITE_AFF_NONE );\n    return (aff1<=SQLITE_AFF_NONE ? aff2 : aff1) | SQLITE_AFF_NONE;\n  }\n}\n\n/*\n** pExpr is a comparison operator.  Return the type affinity that should\n** be applied to both operands prior to doing the comparison.\n*/\nstatic char comparisonAffinity(Expr *pExpr){\n  char aff;\n  assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT ||\n          pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE ||\n          pExpr->op==TK_NE || pExpr->op==TK_IS || pExpr->op==TK_ISNOT );\n  assert( pExpr->pLeft );\n  aff = sqlite3ExprAffinity(pExpr->pLeft);\n  if( pExpr->pRight ){\n    aff = sqlite3CompareAffinity(pExpr->pRight, aff);\n  }else if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n    aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);\n  }else if( aff==0 ){\n    aff = SQLITE_AFF_BLOB;\n  }\n  return aff;\n}\n\n/*\n** pExpr is a comparison expression, eg. '=', '<', IN(...) etc.\n** idx_affinity is the affinity of an indexed column. Return true\n** if the index with affinity idx_affinity may be used to implement\n** the comparison in pExpr.\n*/\nint sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){\n  char aff = comparisonAffinity(pExpr);\n  if( aff<SQLITE_AFF_TEXT ){\n    return 1;\n  }\n  if( aff==SQLITE_AFF_TEXT ){\n    return idx_affinity==SQLITE_AFF_TEXT;\n  }\n  return sqlite3IsNumericAffinity(idx_affinity);\n}\n\n/*\n** Return the P5 value that should be used for a binary comparison\n** opcode (OP_Eq, OP_Ge etc.) used to compare pExpr1 and pExpr2.\n*/\nstatic u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){\n  u8 aff = (char)sqlite3ExprAffinity(pExpr2);\n  aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;\n  return aff;\n}\n\n/*\n** Return a pointer to the collation sequence that should be used by\n** a binary comparison operator comparing pLeft and pRight.\n**\n** If the left hand expression has a collating sequence type, then it is\n** used. Otherwise the collation sequence for the right hand expression\n** is used, or the default (BINARY) if neither expression has a collating\n** type.\n**\n** Argument pRight (but not pLeft) may be a null pointer. In this case,\n** it is not considered.\n*/\nCollSeq *sqlite3BinaryCompareCollSeq(\n  Parse *pParse, \n  Expr *pLeft, \n  Expr *pRight\n){\n  CollSeq *pColl;\n  assert( pLeft );\n  if( pLeft->flags & EP_Collate ){\n    pColl = sqlite3ExprCollSeq(pParse, pLeft);\n  }else if( pRight && (pRight->flags & EP_Collate)!=0 ){\n    pColl = sqlite3ExprCollSeq(pParse, pRight);\n  }else{\n    pColl = sqlite3ExprCollSeq(pParse, pLeft);\n    if( !pColl ){\n      pColl = sqlite3ExprCollSeq(pParse, pRight);\n    }\n  }\n  return pColl;\n}\n\n/* Expresssion p is a comparison operator.  Return a collation sequence\n** appropriate for the comparison operator.\n**\n** This is normally just a wrapper around sqlite3BinaryCompareCollSeq().\n** However, if the OP_Commuted flag is set, then the order of the operands\n** is reversed in the sqlite3BinaryCompareCollSeq() call so that the\n** correct collating sequence is found.\n*/\nCollSeq *sqlite3ExprCompareCollSeq(Parse *pParse, Expr *p){\n  if( ExprHasProperty(p, EP_Commuted) ){\n    return sqlite3BinaryCompareCollSeq(pParse, p->pRight, p->pLeft);\n  }else{\n    return sqlite3BinaryCompareCollSeq(pParse, p->pLeft, p->pRight);\n  }\n}\n\n/*\n** Generate code for a comparison operator.\n*/\nstatic int codeCompare(\n  Parse *pParse,    /* The parsing (and code generating) context */\n  Expr *pLeft,      /* The left operand */\n  Expr *pRight,     /* The right operand */\n  int opcode,       /* The comparison opcode */\n  int in1, int in2, /* Register holding operands */\n  int dest,         /* Jump here if true.  */\n  int jumpIfNull,   /* If true, jump if either operand is NULL */\n  int isCommuted    /* The comparison has been commuted */\n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n\n  if( pParse->nErr ) return 0;\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}\n\n/*\n** Return true if expression pExpr is a vector, or false otherwise.\n**\n** A vector is defined as any expression that results in two or more\n** columns of result.  Every TK_VECTOR node is an vector because the\n** parser will not generate a TK_VECTOR with fewer than two entries.\n** But a TK_SELECT might be either a vector or a scalar. It is only\n** considered a vector if it has two or more result columns.\n*/\nint sqlite3ExprIsVector(Expr *pExpr){\n  return sqlite3ExprVectorSize(pExpr)>1;\n}\n\n/*\n** If the expression passed as the only argument is of type TK_VECTOR \n** return the number of expressions in the vector. Or, if the expression\n** is a sub-select, return the number of columns in the sub-select. For\n** any other type of expression, return 1.\n*/\nint sqlite3ExprVectorSize(Expr *pExpr){\n  u8 op = pExpr->op;\n  if( op==TK_REGISTER ) op = pExpr->op2;\n  if( op==TK_VECTOR ){\n    return pExpr->x.pList->nExpr;\n  }else if( op==TK_SELECT ){\n    return pExpr->x.pSelect->pEList->nExpr;\n  }else{\n    return 1;\n  }\n}\n\n/*\n** Return a pointer to a subexpression of pVector that is the i-th\n** column of the vector (numbered starting with 0).  The caller must\n** ensure that i is within range.\n**\n** If pVector is really a scalar (and \"scalar\" here includes subqueries\n** that return a single column!) then return pVector unmodified.\n**\n** pVector retains ownership of the returned subexpression.\n**\n** If the vector is a (SELECT ...) then the expression returned is\n** just the expression for the i-th term of the result set, and may\n** not be ready for evaluation because the table cursor has not yet\n** been positioned.\n*/\nExpr *sqlite3VectorFieldSubexpr(Expr *pVector, int i){\n  assert( i<sqlite3ExprVectorSize(pVector) );\n  if( sqlite3ExprIsVector(pVector) ){\n    assert( pVector->op2==0 || pVector->op==TK_REGISTER );\n    if( pVector->op==TK_SELECT || pVector->op2==TK_SELECT ){\n      return pVector->x.pSelect->pEList->a[i].pExpr;\n    }else{\n      return pVector->x.pList->a[i].pExpr;\n    }\n  }\n  return pVector;\n}\n\n/*\n** Compute and return a new Expr object which when passed to\n** sqlite3ExprCode() will generate all necessary code to compute\n** the iField-th column of the vector expression pVector.\n**\n** It is ok for pVector to be a scalar (as long as iField==0).  \n** In that case, this routine works like sqlite3ExprDup().\n**\n** The caller owns the returned Expr object and is responsible for\n** ensuring that the returned value eventually gets freed.\n**\n** The caller retains ownership of pVector.  If pVector is a TK_SELECT,\n** then the returned object will reference pVector and so pVector must remain\n** valid for the life of the returned object.  If pVector is a TK_VECTOR\n** or a scalar expression, then it can be deleted as soon as this routine\n** returns.\n**\n** A trick to cause a TK_SELECT pVector to be deleted together with\n** the returned Expr object is to attach the pVector to the pRight field\n** of the returned TK_SELECT_COLUMN Expr object.\n*/\nExpr *sqlite3ExprForVectorField(\n  Parse *pParse,       /* Parsing context */\n  Expr *pVector,       /* The vector.  List of expressions or a sub-SELECT */\n  int iField           /* Which column of the vector to return */\n){\n  Expr *pRet;\n  if( pVector->op==TK_SELECT ){\n    assert( pVector->flags & EP_xIsSelect );\n    /* The TK_SELECT_COLUMN Expr node:\n    **\n    ** pLeft:           pVector containing TK_SELECT.  Not deleted.\n    ** pRight:          not used.  But recursively deleted.\n    ** iColumn:         Index of a column in pVector\n    ** iTable:          0 or the number of columns on the LHS of an assignment\n    ** pLeft->iTable:   First in an array of register holding result, or 0\n    **                  if the result is not yet computed.\n    **\n    ** sqlite3ExprDelete() specifically skips the recursive delete of\n    ** pLeft on TK_SELECT_COLUMN nodes.  But pRight is followed, so pVector\n    ** can be attached to pRight to cause this node to take ownership of\n    ** pVector.  Typically there will be multiple TK_SELECT_COLUMN nodes\n    ** with the same pLeft pointer to the pVector, but only one of them\n    ** will own the pVector.\n    */\n    pRet = sqlite3PExpr(pParse, TK_SELECT_COLUMN, 0, 0);\n    if( pRet ){\n      pRet->iColumn = iField;\n      pRet->pLeft = pVector;\n    }\n    assert( pRet==0 || pRet->iTable==0 );\n  }else{\n    if( pVector->op==TK_VECTOR ) pVector = pVector->x.pList->a[iField].pExpr;\n    pRet = sqlite3ExprDup(pParse->db, pVector, 0);\n    sqlite3RenameTokenRemap(pParse, pRet, pVector);\n  }\n  return pRet;\n}\n\n/*\n** If expression pExpr is of type TK_SELECT, generate code to evaluate\n** it. Return the register in which the result is stored (or, if the \n** sub-select returns more than one column, the first in an array\n** of registers in which the result is stored).\n**\n** If pExpr is not a TK_SELECT expression, return 0.\n*/\nstatic int exprCodeSubselect(Parse *pParse, Expr *pExpr){\n  int reg = 0;\n#ifndef SQLITE_OMIT_SUBQUERY\n  if( pExpr->op==TK_SELECT ){\n    reg = sqlite3CodeSubselect(pParse, pExpr);\n  }\n#endif\n  return reg;\n}\n\n/*\n** Argument pVector points to a vector expression - either a TK_VECTOR\n** or TK_SELECT that returns more than one column. This function returns\n** the register number of a register that contains the value of\n** element iField of the vector.\n**\n** If pVector is a TK_SELECT expression, then code for it must have \n** already been generated using the exprCodeSubselect() routine. In this\n** case parameter regSelect should be the first in an array of registers\n** containing the results of the sub-select. \n**\n** If pVector is of type TK_VECTOR, then code for the requested field\n** is generated. In this case (*pRegFree) may be set to the number of\n** a temporary register to be freed by the caller before returning.\n**\n** Before returning, output parameter (*ppExpr) is set to point to the\n** Expr object corresponding to element iElem of the vector.\n*/\nstatic int exprVectorRegister(\n  Parse *pParse,                  /* Parse context */\n  Expr *pVector,                  /* Vector to extract element from */\n  int iField,                     /* Field to extract from pVector */\n  int regSelect,                  /* First in array of registers */\n  Expr **ppExpr,                  /* OUT: Expression element */\n  int *pRegFree                   /* OUT: Temp register to free */\n){\n  u8 op = pVector->op;\n  assert( op==TK_VECTOR || op==TK_REGISTER || op==TK_SELECT );\n  if( op==TK_REGISTER ){\n    *ppExpr = sqlite3VectorFieldSubexpr(pVector, iField);\n    return pVector->iTable+iField;\n  }\n  if( op==TK_SELECT ){\n    *ppExpr = pVector->x.pSelect->pEList->a[iField].pExpr;\n     return regSelect+iField;\n  }\n  *ppExpr = pVector->x.pList->a[iField].pExpr;\n  return sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree);\n}\n\n/*\n** Expression pExpr is a comparison between two vector values. Compute\n** the result of the comparison (1, 0, or NULL) and write that\n** result into register dest.\n**\n** The caller must satisfy the following preconditions:\n**\n**    if pExpr->op==TK_IS:      op==TK_EQ and p5==SQLITE_NULLEQ\n**    if pExpr->op==TK_ISNOT:   op==TK_NE and p5==SQLITE_NULLEQ\n**    otherwise:                op==pExpr->op and p5==0\n*/\nstatic void codeVectorCompare(\n  Parse *pParse,        /* Code generator context */\n  Expr *pExpr,          /* The comparison operation */\n  int dest,             /* Write results into this register */\n  u8 op,                /* Comparison operator */\n  u8 p5                 /* SQLITE_NULLEQ or zero */\n){\n  Vdbe *v = pParse->pVdbe;\n  Expr *pLeft = pExpr->pLeft;\n  Expr *pRight = pExpr->pRight;\n  int nLeft = sqlite3ExprVectorSize(pLeft);\n  int i;\n  int regLeft = 0;\n  int regRight = 0;\n  u8 opx = op;\n  int addrDone = sqlite3VdbeMakeLabel(pParse);\n  int isCommuted = ExprHasProperty(pExpr,EP_Commuted);\n\n  if( nLeft!=sqlite3ExprVectorSize(pRight) ){\n    sqlite3ErrorMsg(pParse, \"row value misused\");\n    return;\n  }\n  assert( pExpr->op==TK_EQ || pExpr->op==TK_NE \n       || pExpr->op==TK_IS || pExpr->op==TK_ISNOT \n       || pExpr->op==TK_LT || pExpr->op==TK_GT \n       || pExpr->op==TK_LE || pExpr->op==TK_GE \n  );\n  assert( pExpr->op==op || (pExpr->op==TK_IS && op==TK_EQ)\n            || (pExpr->op==TK_ISNOT && op==TK_NE) );\n  assert( p5==0 || pExpr->op!=op );\n  assert( p5==SQLITE_NULLEQ || pExpr->op==op );\n\n  p5 |= SQLITE_STOREP2;\n  if( opx==TK_LE ) opx = TK_LT;\n  if( opx==TK_GE ) opx = TK_GT;\n\n  regLeft = exprCodeSubselect(pParse, pLeft);\n  regRight = exprCodeSubselect(pParse, pRight);\n\n  for(i=0; 1 /*Loop exits by \"break\"*/; i++){\n    int regFree1 = 0, regFree2 = 0;\n    Expr *pL, *pR; \n    int r1, r2;\n    assert( i>=0 && i<nLeft );\n    r1 = exprVectorRegister(pParse, pLeft, i, regLeft, &pL, &regFree1);\n    r2 = exprVectorRegister(pParse, pRight, i, regRight, &pR, &regFree2);\n    codeCompare(pParse, pL, pR, opx, r1, r2, dest, p5, isCommuted);\n    testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n    testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n    testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n    testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n    testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);\n    testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n    if( i==nLeft-1 ){\n      break;\n    }\n    if( opx==TK_EQ ){\n      sqlite3VdbeAddOp2(v, OP_IfNot, dest, addrDone); VdbeCoverage(v);\n      p5 |= SQLITE_KEEPNULL;\n    }else if( opx==TK_NE ){\n      sqlite3VdbeAddOp2(v, OP_If, dest, addrDone); VdbeCoverage(v);\n      p5 |= SQLITE_KEEPNULL;\n    }else{\n      assert( op==TK_LT || op==TK_GT || op==TK_LE || op==TK_GE );\n      sqlite3VdbeAddOp2(v, OP_ElseNotEq, 0, addrDone);\n      VdbeCoverageIf(v, op==TK_LT);\n      VdbeCoverageIf(v, op==TK_GT);\n      VdbeCoverageIf(v, op==TK_LE);\n      VdbeCoverageIf(v, op==TK_GE);\n      if( i==nLeft-2 ) opx = op;\n    }\n  }\n  sqlite3VdbeResolveLabel(v, addrDone);\n}\n\n#if SQLITE_MAX_EXPR_DEPTH>0\n/*\n** Check that argument nHeight is less than or equal to the maximum\n** expression depth allowed. If it is not, leave an error message in\n** pParse.\n*/\nint sqlite3ExprCheckHeight(Parse *pParse, int nHeight){\n  int rc = SQLITE_OK;\n  int mxHeight = pParse->db->aLimit[SQLITE_LIMIT_EXPR_DEPTH];\n  if( nHeight>mxHeight ){\n    sqlite3ErrorMsg(pParse, \n       \"Expression tree is too large (maximum depth %d)\", mxHeight\n    );\n    rc = SQLITE_ERROR;\n  }\n  return rc;\n}\n\n/* The following three functions, heightOfExpr(), heightOfExprList()\n** and heightOfSelect(), are used to determine the maximum height\n** of any expression tree referenced by the structure passed as the\n** first argument.\n**\n** If this maximum height is greater than the current value pointed\n** to by pnHeight, the second parameter, then set *pnHeight to that\n** value.\n*/\nstatic void heightOfExpr(Expr *p, int *pnHeight){\n  if( p ){\n    if( p->nHeight>*pnHeight ){\n      *pnHeight = p->nHeight;\n    }\n  }\n}\nstatic void heightOfExprList(ExprList *p, int *pnHeight){\n  if( p ){\n    int i;\n    for(i=0; i<p->nExpr; i++){\n      heightOfExpr(p->a[i].pExpr, pnHeight);\n    }\n  }\n}\nstatic void heightOfSelect(Select *pSelect, int *pnHeight){\n  Select *p;\n  for(p=pSelect; p; p=p->pPrior){\n    heightOfExpr(p->pWhere, pnHeight);\n    heightOfExpr(p->pHaving, pnHeight);\n    heightOfExpr(p->pLimit, pnHeight);\n    heightOfExprList(p->pEList, pnHeight);\n    heightOfExprList(p->pGroupBy, pnHeight);\n    heightOfExprList(p->pOrderBy, pnHeight);\n  }\n}\n\n/*\n** Set the Expr.nHeight variable in the structure passed as an \n** argument. An expression with no children, Expr.pList or \n** Expr.pSelect member has a height of 1. Any other expression\n** has a height equal to the maximum height of any other \n** referenced Expr plus one.\n**\n** Also propagate EP_Propagate flags up from Expr.x.pList to Expr.flags,\n** if appropriate.\n*/\nstatic void exprSetHeight(Expr *p){\n  int nHeight = 0;\n  heightOfExpr(p->pLeft, &nHeight);\n  heightOfExpr(p->pRight, &nHeight);\n  if( ExprHasProperty(p, EP_xIsSelect) ){\n    heightOfSelect(p->x.pSelect, &nHeight);\n  }else if( p->x.pList ){\n    heightOfExprList(p->x.pList, &nHeight);\n    p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);\n  }\n  p->nHeight = nHeight + 1;\n}\n\n/*\n** Set the Expr.nHeight variable using the exprSetHeight() function. If\n** the height is greater than the maximum allowed expression depth,\n** leave an error in pParse.\n**\n** Also propagate all EP_Propagate flags from the Expr.x.pList into\n** Expr.flags. \n*/\nvoid sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){\n  if( pParse->nErr ) return;\n  exprSetHeight(p);\n  sqlite3ExprCheckHeight(pParse, p->nHeight);\n}\n\n/*\n** Return the maximum height of any expression tree referenced\n** by the select statement passed as an argument.\n*/\nint sqlite3SelectExprHeight(Select *p){\n  int nHeight = 0;\n  heightOfSelect(p, &nHeight);\n  return nHeight;\n}\n#else /* ABOVE:  Height enforcement enabled.  BELOW: Height enforcement off */\n/*\n** Propagate all EP_Propagate flags from the Expr.x.pList into\n** Expr.flags. \n*/\nvoid sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){\n  if( p && p->x.pList && !ExprHasProperty(p, EP_xIsSelect) ){\n    p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);\n  }\n}\n#define exprSetHeight(y)\n#endif /* SQLITE_MAX_EXPR_DEPTH>0 */\n\n/*\n** This routine is the core allocator for Expr nodes.\n**\n** Construct a new expression node and return a pointer to it.  Memory\n** for this node and for the pToken argument is a single allocation\n** obtained from sqlite3DbMalloc().  The calling function\n** is responsible for making sure the node eventually gets freed.\n**\n** If dequote is true, then the token (if it exists) is dequoted.\n** If dequote is false, no dequoting is performed.  The deQuote\n** parameter is ignored if pToken is NULL or if the token does not\n** appear to be quoted.  If the quotes were of the form \"...\" (double-quotes)\n** then the EP_DblQuoted flag is set on the expression node.\n**\n** Special case:  If op==TK_INTEGER and pToken points to a string that\n** can be translated into a 32-bit integer, then the token is not\n** stored in u.zToken.  Instead, the integer values is written\n** into u.iValue and the EP_IntValue flag is set.  No extra storage\n** is allocated to hold the integer text and the dequote flag is ignored.\n*/\nExpr *sqlite3ExprAlloc(\n  sqlite3 *db,            /* Handle for sqlite3DbMallocRawNN() */\n  int op,                 /* Expression opcode */\n  const Token *pToken,    /* Token argument.  Might be NULL */\n  int dequote             /* True to dequote */\n){\n  Expr *pNew;\n  int nExtra = 0;\n  int iValue = 0;\n\n  assert( db!=0 );\n  if( pToken ){\n    if( op!=TK_INTEGER || pToken->z==0\n          || sqlite3GetInt32(pToken->z, &iValue)==0 ){\n      nExtra = pToken->n+1;\n      assert( iValue>=0 );\n    }\n  }\n  pNew = sqlite3DbMallocRawNN(db, sizeof(Expr)+nExtra);\n  if( pNew ){\n    memset(pNew, 0, sizeof(Expr));\n    pNew->op = (u8)op;\n    pNew->iAgg = -1;\n    if( pToken ){\n      if( nExtra==0 ){\n        pNew->flags |= EP_IntValue|EP_Leaf|(iValue?EP_IsTrue:EP_IsFalse);\n        pNew->u.iValue = iValue;\n      }else{\n        pNew->u.zToken = (char*)&pNew[1];\n        assert( pToken->z!=0 || pToken->n==0 );\n        if( pToken->n ) memcpy(pNew->u.zToken, pToken->z, pToken->n);\n        pNew->u.zToken[pToken->n] = 0;\n        if( dequote && sqlite3Isquote(pNew->u.zToken[0]) ){\n          sqlite3DequoteExpr(pNew);\n        }\n      }\n    }\n#if SQLITE_MAX_EXPR_DEPTH>0\n    pNew->nHeight = 1;\n#endif  \n  }\n  return pNew;\n}\n\n/*\n** Allocate a new expression node from a zero-terminated token that has\n** already been dequoted.\n*/\nExpr *sqlite3Expr(\n  sqlite3 *db,            /* Handle for sqlite3DbMallocZero() (may be null) */\n  int op,                 /* Expression opcode */\n  const char *zToken      /* Token argument.  Might be NULL */\n){\n  Token x;\n  x.z = zToken;\n  x.n = sqlite3Strlen30(zToken);\n  return sqlite3ExprAlloc(db, op, &x, 0);\n}\n\n/*\n** Attach subtrees pLeft and pRight to the Expr node pRoot.\n**\n** If pRoot==NULL that means that a memory allocation error has occurred.\n** In that case, delete the subtrees pLeft and pRight.\n*/\nvoid sqlite3ExprAttachSubtrees(\n  sqlite3 *db,\n  Expr *pRoot,\n  Expr *pLeft,\n  Expr *pRight\n){\n  if( pRoot==0 ){\n    assert( db->mallocFailed );\n    sqlite3ExprDelete(db, pLeft);\n    sqlite3ExprDelete(db, pRight);\n  }else{\n    if( pRight ){\n      pRoot->pRight = pRight;\n      pRoot->flags |= EP_Propagate & pRight->flags;\n    }\n    if( pLeft ){\n      pRoot->pLeft = pLeft;\n      pRoot->flags |= EP_Propagate & pLeft->flags;\n    }\n    exprSetHeight(pRoot);\n  }\n}\n\n/*\n** Allocate an Expr node which joins as many as two subtrees.\n**\n** One or both of the subtrees can be NULL.  Return a pointer to the new\n** Expr node.  Or, if an OOM error occurs, set pParse->db->mallocFailed,\n** free the subtrees and return NULL.\n*/\nExpr *sqlite3PExpr(\n  Parse *pParse,          /* Parsing context */\n  int op,                 /* Expression opcode */\n  Expr *pLeft,            /* Left operand */\n  Expr *pRight            /* Right operand */\n){\n  Expr *p;\n  p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr));\n  if( p ){\n    memset(p, 0, sizeof(Expr));\n    p->op = op & 0xff;\n    p->iAgg = -1;\n    sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);\n    sqlite3ExprCheckHeight(pParse, p->nHeight);\n  }else{\n    sqlite3ExprDelete(pParse->db, pLeft);\n    sqlite3ExprDelete(pParse->db, pRight);\n  }\n  return p;\n}\n\n/*\n** Add pSelect to the Expr.x.pSelect field.  Or, if pExpr is NULL (due\n** do a memory allocation failure) then delete the pSelect object.\n*/\nvoid sqlite3PExprAddSelect(Parse *pParse, Expr *pExpr, Select *pSelect){\n  if( pExpr ){\n    pExpr->x.pSelect = pSelect;\n    ExprSetProperty(pExpr, EP_xIsSelect|EP_Subquery);\n    sqlite3ExprSetHeightAndFlags(pParse, pExpr);\n  }else{\n    assert( pParse->db->mallocFailed );\n    sqlite3SelectDelete(pParse->db, pSelect);\n  }\n}\n\n\n/*\n** Join two expressions using an AND operator.  If either expression is\n** NULL, then just return the other expression.\n**\n** If one side or the other of the AND is known to be false, then instead\n** of returning an AND expression, just return a constant expression with\n** a value of false.\n*/\nExpr *sqlite3ExprAnd(Parse *pParse, Expr *pLeft, Expr *pRight){\n  sqlite3 *db = pParse->db;\n  if( pLeft==0  ){\n    return pRight;\n  }else if( pRight==0 ){\n    return pLeft;\n  }else if( ExprAlwaysFalse(pLeft) || ExprAlwaysFalse(pRight) ){\n    sqlite3ExprUnmapAndDelete(pParse, pLeft);\n    sqlite3ExprUnmapAndDelete(pParse, pRight);\n    return sqlite3Expr(db, TK_INTEGER, \"0\");\n  }else{\n    return sqlite3PExpr(pParse, TK_AND, pLeft, pRight);\n  }\n}\n\n/*\n** Construct a new expression node for a function with multiple\n** arguments.\n*/\nExpr *sqlite3ExprFunction(\n  Parse *pParse,        /* Parsing context */\n  ExprList *pList,      /* Argument list */\n  Token *pToken,        /* Name of the function */\n  int eDistinct         /* SF_Distinct or SF_ALL or 0 */\n){\n  Expr *pNew;\n  sqlite3 *db = pParse->db;\n  assert( pToken );\n  pNew = sqlite3ExprAlloc(db, TK_FUNCTION, pToken, 1);\n  if( pNew==0 ){\n    sqlite3ExprListDelete(db, pList); /* Avoid memory leak when malloc fails */\n    return 0;\n  }\n  if( pList && pList->nExpr > pParse->db->aLimit[SQLITE_LIMIT_FUNCTION_ARG] ){\n    sqlite3ErrorMsg(pParse, \"too many arguments on function %T\", pToken);\n  }\n  pNew->x.pList = pList;\n  ExprSetProperty(pNew, EP_HasFunc);\n  assert( !ExprHasProperty(pNew, EP_xIsSelect) );\n  sqlite3ExprSetHeightAndFlags(pParse, pNew);\n  if( eDistinct==SF_Distinct ) ExprSetProperty(pNew, EP_Distinct);\n  return pNew;\n}\n\n/*\n** Assign a variable number to an expression that encodes a wildcard\n** in the original SQL statement.  \n**\n** Wildcards consisting of a single \"?\" are assigned the next sequential\n** variable number.\n**\n** Wildcards of the form \"?nnn\" are assigned the number \"nnn\".  We make\n** sure \"nnn\" is not too big to avoid a denial of service attack when\n** the SQL statement comes from an external source.\n**\n** Wildcards of the form \":aaa\", \"@aaa\", or \"$aaa\" are assigned the same number\n** as the previous instance of the same wildcard.  Or if this is the first\n** instance of the wildcard, the next sequential variable number is\n** assigned.\n*/\nvoid sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr, u32 n){\n  sqlite3 *db = pParse->db;\n  const char *z;\n  ynVar x;\n\n  if( pExpr==0 ) return;\n  assert( !ExprHasProperty(pExpr, EP_IntValue|EP_Reduced|EP_TokenOnly) );\n  z = pExpr->u.zToken;\n  assert( z!=0 );\n  assert( z[0]!=0 );\n  assert( n==(u32)sqlite3Strlen30(z) );\n  if( z[1]==0 ){\n    /* Wildcard of the form \"?\".  Assign the next variable number */\n    assert( z[0]=='?' );\n    x = (ynVar)(++pParse->nVar);\n  }else{\n    int doAdd = 0;\n    if( z[0]=='?' ){\n      /* Wildcard of the form \"?nnn\".  Convert \"nnn\" to an integer and\n      ** use it as the variable number */\n      i64 i;\n      int bOk;\n      if( n==2 ){ /*OPTIMIZATION-IF-TRUE*/\n        i = z[1]-'0';  /* The common case of ?N for a single digit N */\n        bOk = 1;\n      }else{\n        bOk = 0==sqlite3Atoi64(&z[1], &i, n-1, SQLITE_UTF8);\n      }\n      testcase( i==0 );\n      testcase( i==1 );\n      testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]-1 );\n      testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] );\n      if( bOk==0 || i<1 || i>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){\n        sqlite3ErrorMsg(pParse, \"variable number must be between ?1 and ?%d\",\n            db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]);\n        return;\n      }\n      x = (ynVar)i;\n      if( x>pParse->nVar ){\n        pParse->nVar = (int)x;\n        doAdd = 1;\n      }else if( sqlite3VListNumToName(pParse->pVList, x)==0 ){\n        doAdd = 1;\n      }\n    }else{\n      /* Wildcards like \":aaa\", \"$aaa\" or \"@aaa\".  Reuse the same variable\n      ** number as the prior appearance of the same name, or if the name\n      ** has never appeared before, reuse the same variable number\n      */\n      x = (ynVar)sqlite3VListNameToNum(pParse->pVList, z, n);\n      if( x==0 ){\n        x = (ynVar)(++pParse->nVar);\n        doAdd = 1;\n      }\n    }\n    if( doAdd ){\n      pParse->pVList = sqlite3VListAdd(db, pParse->pVList, z, n, x);\n    }\n  }\n  pExpr->iColumn = x;\n  if( x>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){\n    sqlite3ErrorMsg(pParse, \"too many SQL variables\");\n  }\n}\n\n/*\n** Recursively delete an expression tree.\n*/\nstatic SQLITE_NOINLINE void sqlite3ExprDeleteNN(sqlite3 *db, Expr *p){\n  assert( p!=0 );\n  /* Sanity check: Assert that the IntValue is non-negative if it exists */\n  assert( !ExprHasProperty(p, EP_IntValue) || p->u.iValue>=0 );\n\n  assert( !ExprHasProperty(p, EP_WinFunc) || p->y.pWin!=0 || db->mallocFailed );\n  assert( p->op!=TK_FUNCTION || ExprHasProperty(p, EP_TokenOnly|EP_Reduced)\n          || p->y.pWin==0 || ExprHasProperty(p, EP_WinFunc) );\n#ifdef SQLITE_DEBUG\n  if( ExprHasProperty(p, EP_Leaf) && !ExprHasProperty(p, EP_TokenOnly) ){\n    assert( p->pLeft==0 );\n    assert( p->pRight==0 );\n    assert( p->x.pSelect==0 );\n  }\n#endif\n  if( !ExprHasProperty(p, (EP_TokenOnly|EP_Leaf)) ){\n    /* The Expr.x union is never used at the same time as Expr.pRight */\n    assert( p->x.pList==0 || p->pRight==0 );\n    if( p->pLeft && p->op!=TK_SELECT_COLUMN ) sqlite3ExprDeleteNN(db, p->pLeft);\n    if( p->pRight ){\n      assert( !ExprHasProperty(p, EP_WinFunc) );\n      sqlite3ExprDeleteNN(db, p->pRight);\n    }else if( ExprHasProperty(p, EP_xIsSelect) ){\n      assert( !ExprHasProperty(p, EP_WinFunc) );\n      sqlite3SelectDelete(db, p->x.pSelect);\n    }else{\n      sqlite3ExprListDelete(db, p->x.pList);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      if( ExprHasProperty(p, EP_WinFunc) ){\n        sqlite3WindowDelete(db, p->y.pWin);\n      }\n#endif\n    }\n  }\n  if( ExprHasProperty(p, EP_MemToken) ) sqlite3DbFree(db, p->u.zToken);\n  if( !ExprHasProperty(p, EP_Static) ){\n    sqlite3DbFreeNN(db, p);\n  }\n}\nvoid sqlite3ExprDelete(sqlite3 *db, Expr *p){\n  if( p ) sqlite3ExprDeleteNN(db, p);\n}\n\n/* Invoke sqlite3RenameExprUnmap() and sqlite3ExprDelete() on the\n** expression.\n*/\nvoid sqlite3ExprUnmapAndDelete(Parse *pParse, Expr *p){\n  if( p ){\n    if( IN_RENAME_OBJECT ){\n      sqlite3RenameExprUnmap(pParse, p);\n    }\n    sqlite3ExprDeleteNN(pParse->db, p);\n  }\n}\n\n/*\n** Return the number of bytes allocated for the expression structure \n** passed as the first argument. This is always one of EXPR_FULLSIZE,\n** EXPR_REDUCEDSIZE or EXPR_TOKENONLYSIZE.\n*/\nstatic int exprStructSize(Expr *p){\n  if( ExprHasProperty(p, EP_TokenOnly) ) return EXPR_TOKENONLYSIZE;\n  if( ExprHasProperty(p, EP_Reduced) ) return EXPR_REDUCEDSIZE;\n  return EXPR_FULLSIZE;\n}\n\n/*\n** The dupedExpr*Size() routines each return the number of bytes required\n** to store a copy of an expression or expression tree.  They differ in\n** how much of the tree is measured.\n**\n**     dupedExprStructSize()     Size of only the Expr structure \n**     dupedExprNodeSize()       Size of Expr + space for token\n**     dupedExprSize()           Expr + token + subtree components\n**\n***************************************************************************\n**\n** The dupedExprStructSize() function returns two values OR-ed together:  \n** (1) the space required for a copy of the Expr structure only and \n** (2) the EP_xxx flags that indicate what the structure size should be.\n** The return values is always one of:\n**\n**      EXPR_FULLSIZE\n**      EXPR_REDUCEDSIZE   | EP_Reduced\n**      EXPR_TOKENONLYSIZE | EP_TokenOnly\n**\n** The size of the structure can be found by masking the return value\n** of this routine with 0xfff.  The flags can be found by masking the\n** return value with EP_Reduced|EP_TokenOnly.\n**\n** Note that with flags==EXPRDUP_REDUCE, this routines works on full-size\n** (unreduced) Expr objects as they or originally constructed by the parser.\n** During expression analysis, extra information is computed and moved into\n** later parts of the Expr object and that extra information might get chopped\n** off if the expression is reduced.  Note also that it does not work to\n** make an EXPRDUP_REDUCE copy of a reduced expression.  It is only legal\n** to reduce a pristine expression tree from the parser.  The implementation\n** of dupedExprStructSize() contain multiple assert() statements that attempt\n** to enforce this constraint.\n*/\nstatic int dupedExprStructSize(Expr *p, int flags){\n  int nSize;\n  assert( flags==EXPRDUP_REDUCE || flags==0 ); /* Only one flag value allowed */\n  assert( EXPR_FULLSIZE<=0xfff );\n  assert( (0xfff & (EP_Reduced|EP_TokenOnly))==0 );\n  if( 0==flags || p->op==TK_SELECT_COLUMN \n#ifndef SQLITE_OMIT_WINDOWFUNC\n   || ExprHasProperty(p, EP_WinFunc)\n#endif\n  ){\n    nSize = EXPR_FULLSIZE;\n  }else{\n    assert( !ExprHasProperty(p, EP_TokenOnly|EP_Reduced) );\n    assert( !ExprHasProperty(p, EP_FromJoin) ); \n    assert( !ExprHasProperty(p, EP_MemToken) );\n    assert( !ExprHasProperty(p, EP_NoReduce) );\n    if( p->pLeft || p->x.pList ){\n      nSize = EXPR_REDUCEDSIZE | EP_Reduced;\n    }else{\n      assert( p->pRight==0 );\n      nSize = EXPR_TOKENONLYSIZE | EP_TokenOnly;\n    }\n  }\n  return nSize;\n}\n\n/*\n** This function returns the space in bytes required to store the copy \n** of the Expr structure and a copy of the Expr.u.zToken string (if that\n** string is defined.)\n*/\nstatic int dupedExprNodeSize(Expr *p, int flags){\n  int nByte = dupedExprStructSize(p, flags) & 0xfff;\n  if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n    nByte += sqlite3Strlen30NN(p->u.zToken)+1;\n  }\n  return ROUND8(nByte);\n}\n\n/*\n** Return the number of bytes required to create a duplicate of the \n** expression passed as the first argument. The second argument is a\n** mask containing EXPRDUP_XXX flags.\n**\n** The value returned includes space to create a copy of the Expr struct\n** itself and the buffer referred to by Expr.u.zToken, if any.\n**\n** If the EXPRDUP_REDUCE flag is set, then the return value includes \n** space to duplicate all Expr nodes in the tree formed by Expr.pLeft \n** and Expr.pRight variables (but not for any structures pointed to or \n** descended from the Expr.x.pList or Expr.x.pSelect variables).\n*/\nstatic int dupedExprSize(Expr *p, int flags){\n  int nByte = 0;\n  if( p ){\n    nByte = dupedExprNodeSize(p, flags);\n    if( flags&EXPRDUP_REDUCE ){\n      nByte += dupedExprSize(p->pLeft, flags) + dupedExprSize(p->pRight, flags);\n    }\n  }\n  return nByte;\n}\n\n/*\n** This function is similar to sqlite3ExprDup(), except that if pzBuffer \n** is not NULL then *pzBuffer is assumed to point to a buffer large enough \n** to store the copy of expression p, the copies of p->u.zToken\n** (if applicable), and the copies of the p->pLeft and p->pRight expressions,\n** if any. Before returning, *pzBuffer is set to the first byte past the\n** portion of the buffer copied into by this function.\n*/\nstatic Expr *exprDup(sqlite3 *db, Expr *p, int dupFlags, u8 **pzBuffer){\n  Expr *pNew;           /* Value to return */\n  u8 *zAlloc;           /* Memory space from which to build Expr object */\n  u32 staticFlag;       /* EP_Static if space not obtained from malloc */\n\n  assert( db!=0 );\n  assert( p );\n  assert( dupFlags==0 || dupFlags==EXPRDUP_REDUCE );\n  assert( pzBuffer==0 || dupFlags==EXPRDUP_REDUCE );\n\n  /* Figure out where to write the new Expr structure. */\n  if( pzBuffer ){\n    zAlloc = *pzBuffer;\n    staticFlag = EP_Static;\n  }else{\n    zAlloc = sqlite3DbMallocRawNN(db, dupedExprSize(p, dupFlags));\n    staticFlag = 0;\n  }\n  pNew = (Expr *)zAlloc;\n\n  if( pNew ){\n    /* Set nNewSize to the size allocated for the structure pointed to\n    ** by pNew. This is either EXPR_FULLSIZE, EXPR_REDUCEDSIZE or\n    ** EXPR_TOKENONLYSIZE. nToken is set to the number of bytes consumed\n    ** by the copy of the p->u.zToken string (if any).\n    */\n    const unsigned nStructSize = dupedExprStructSize(p, dupFlags);\n    const int nNewSize = nStructSize & 0xfff;\n    int nToken;\n    if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n      nToken = sqlite3Strlen30(p->u.zToken) + 1;\n    }else{\n      nToken = 0;\n    }\n    if( dupFlags ){\n      assert( ExprHasProperty(p, EP_Reduced)==0 );\n      memcpy(zAlloc, p, nNewSize);\n    }else{\n      u32 nSize = (u32)exprStructSize(p);\n      memcpy(zAlloc, p, nSize);\n      if( nSize<EXPR_FULLSIZE ){ \n        memset(&zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);\n      }\n    }\n\n    /* Set the EP_Reduced, EP_TokenOnly, and EP_Static flags appropriately. */\n    pNew->flags &= ~(EP_Reduced|EP_TokenOnly|EP_Static|EP_MemToken);\n    pNew->flags |= nStructSize & (EP_Reduced|EP_TokenOnly);\n    pNew->flags |= staticFlag;\n\n    /* Copy the p->u.zToken string, if any. */\n    if( nToken ){\n      char *zToken = pNew->u.zToken = (char*)&zAlloc[nNewSize];\n      memcpy(zToken, p->u.zToken, nToken);\n    }\n\n    if( 0==((p->flags|pNew->flags) & (EP_TokenOnly|EP_Leaf)) ){\n      /* Fill in the pNew->x.pSelect or pNew->x.pList member. */\n      if( ExprHasProperty(p, EP_xIsSelect) ){\n        pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, dupFlags);\n      }else{\n        pNew->x.pList = sqlite3ExprListDup(db, p->x.pList, dupFlags);\n      }\n    }\n\n    /* Fill in pNew->pLeft and pNew->pRight. */\n    if( ExprHasProperty(pNew, EP_Reduced|EP_TokenOnly|EP_WinFunc) ){\n      zAlloc += dupedExprNodeSize(p, dupFlags);\n      if( !ExprHasProperty(pNew, EP_TokenOnly|EP_Leaf) ){\n        pNew->pLeft = p->pLeft ?\n                      exprDup(db, p->pLeft, EXPRDUP_REDUCE, &zAlloc) : 0;\n        pNew->pRight = p->pRight ?\n                       exprDup(db, p->pRight, EXPRDUP_REDUCE, &zAlloc) : 0;\n      }\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      if( ExprHasProperty(p, EP_WinFunc) ){\n        pNew->y.pWin = sqlite3WindowDup(db, pNew, p->y.pWin);\n        assert( ExprHasProperty(pNew, EP_WinFunc) );\n      }\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n      if( pzBuffer ){\n        *pzBuffer = zAlloc;\n      }\n    }else{\n      if( !ExprHasProperty(p, EP_TokenOnly|EP_Leaf) ){\n        if( pNew->op==TK_SELECT_COLUMN ){\n          pNew->pLeft = p->pLeft;\n          assert( p->iColumn==0 || p->pRight==0 );\n          assert( p->pRight==0  || p->pRight==p->pLeft );\n        }else{\n          pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0);\n        }\n        pNew->pRight = sqlite3ExprDup(db, p->pRight, 0);\n      }\n    }\n  }\n  return pNew;\n}\n\n/*\n** Create and return a deep copy of the object passed as the second \n** argument. If an OOM condition is encountered, NULL is returned\n** and the db->mallocFailed flag set.\n*/\n#ifndef SQLITE_OMIT_CTE\nstatic With *withDup(sqlite3 *db, With *p){\n  With *pRet = 0;\n  if( p ){\n    sqlite3_int64 nByte = sizeof(*p) + sizeof(p->a[0]) * (p->nCte-1);\n    pRet = sqlite3DbMallocZero(db, nByte);\n    if( pRet ){\n      int i;\n      pRet->nCte = p->nCte;\n      for(i=0; i<p->nCte; i++){\n        pRet->a[i].pSelect = sqlite3SelectDup(db, p->a[i].pSelect, 0);\n        pRet->a[i].pCols = sqlite3ExprListDup(db, p->a[i].pCols, 0);\n        pRet->a[i].zName = sqlite3DbStrDup(db, p->a[i].zName);\n      }\n    }\n  }\n  return pRet;\n}\n#else\n# define withDup(x,y) 0\n#endif\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n/*\n** The gatherSelectWindows() procedure and its helper routine\n** gatherSelectWindowsCallback() are used to scan all the expressions\n** an a newly duplicated SELECT statement and gather all of the Window\n** objects found there, assembling them onto the linked list at Select->pWin.\n*/\nstatic int gatherSelectWindowsCallback(Walker *pWalker, Expr *pExpr){\n  if( pExpr->op==TK_FUNCTION && ExprHasProperty(pExpr, EP_WinFunc) ){\n    Select *pSelect = pWalker->u.pSelect;\n    Window *pWin = pExpr->y.pWin;\n    assert( pWin );\n    assert( IsWindowFunc(pExpr) );\n    assert( pWin->ppThis==0 );\n    sqlite3WindowLink(pSelect, pWin);\n  }\n  return WRC_Continue;\n}\nstatic int gatherSelectWindowsSelectCallback(Walker *pWalker, Select *p){\n  return p==pWalker->u.pSelect ? WRC_Continue : WRC_Prune;\n}\nstatic void gatherSelectWindows(Select *p){\n  Walker w;\n  w.xExprCallback = gatherSelectWindowsCallback;\n  w.xSelectCallback = gatherSelectWindowsSelectCallback;\n  w.xSelectCallback2 = 0;\n  w.pParse = 0;\n  w.u.pSelect = p;\n  sqlite3WalkSelect(&w, p);\n}\n#endif\n\n\n/*\n** The following group of routines make deep copies of expressions,\n** expression lists, ID lists, and select statements.  The copies can\n** be deleted (by being passed to their respective ...Delete() routines)\n** without effecting the originals.\n**\n** The expression list, ID, and source lists return by sqlite3ExprListDup(),\n** sqlite3IdListDup(), and sqlite3SrcListDup() can not be further expanded \n** by subsequent calls to sqlite*ListAppend() routines.\n**\n** Any tables that the SrcList might point to are not duplicated.\n**\n** The flags parameter contains a combination of the EXPRDUP_XXX flags.\n** If the EXPRDUP_REDUCE flag is set, then the structure returned is a\n** truncated version of the usual Expr structure that will be stored as\n** part of the in-memory representation of the database schema.\n*/\nExpr *sqlite3ExprDup(sqlite3 *db, Expr *p, int flags){\n  assert( flags==0 || flags==EXPRDUP_REDUCE );\n  return p ? exprDup(db, p, flags, 0) : 0;\n}\nExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p, int flags){\n  ExprList *pNew;\n  struct ExprList_item *pItem, *pOldItem;\n  int i;\n  Expr *pPriorSelectCol = 0;\n  assert( db!=0 );\n  if( p==0 ) return 0;\n  pNew = sqlite3DbMallocRawNN(db, sqlite3DbMallocSize(db, p));\n  if( pNew==0 ) return 0;\n  pNew->nExpr = p->nExpr;\n  pItem = pNew->a;\n  pOldItem = p->a;\n  for(i=0; i<p->nExpr; i++, pItem++, pOldItem++){\n    Expr *pOldExpr = pOldItem->pExpr;\n    Expr *pNewExpr;\n    pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags);\n    if( pOldExpr \n     && pOldExpr->op==TK_SELECT_COLUMN\n     && (pNewExpr = pItem->pExpr)!=0 \n    ){\n      assert( pNewExpr->iColumn==0 || i>0 );\n      if( pNewExpr->iColumn==0 ){\n        assert( pOldExpr->pLeft==pOldExpr->pRight );\n        pPriorSelectCol = pNewExpr->pLeft = pNewExpr->pRight;\n      }else{\n        assert( i>0 );\n        assert( pItem[-1].pExpr!=0 );\n        assert( pNewExpr->iColumn==pItem[-1].pExpr->iColumn+1 );\n        assert( pPriorSelectCol==pItem[-1].pExpr->pLeft );\n        pNewExpr->pLeft = pPriorSelectCol;\n      }\n    }\n    pItem->zName = sqlite3DbStrDup(db, pOldItem->zName);\n    pItem->zSpan = sqlite3DbStrDup(db, pOldItem->zSpan);\n    pItem->sortFlags = pOldItem->sortFlags;\n    pItem->done = 0;\n    pItem->bNulls = pOldItem->bNulls;\n    pItem->bSpanIsTab = pOldItem->bSpanIsTab;\n    pItem->bSorterRef = pOldItem->bSorterRef;\n    pItem->u = pOldItem->u;\n  }\n  return pNew;\n}\n\n/*\n** If cursors, triggers, views and subqueries are all omitted from\n** the build, then none of the following routines, except for \n** sqlite3SelectDup(), can be called. sqlite3SelectDup() is sometimes\n** called with a NULL argument.\n*/\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER) \\\n || !defined(SQLITE_OMIT_SUBQUERY)\nSrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p, int flags){\n  SrcList *pNew;\n  int i;\n  int nByte;\n  assert( db!=0 );\n  if( p==0 ) return 0;\n  nByte = sizeof(*p) + (p->nSrc>0 ? sizeof(p->a[0]) * (p->nSrc-1) : 0);\n  pNew = sqlite3DbMallocRawNN(db, nByte );\n  if( pNew==0 ) return 0;\n  pNew->nSrc = pNew->nAlloc = p->nSrc;\n  for(i=0; i<p->nSrc; i++){\n    struct SrcList_item *pNewItem = &pNew->a[i];\n    struct SrcList_item *pOldItem = &p->a[i];\n    Table *pTab;\n    pNewItem->pSchema = pOldItem->pSchema;\n    pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase);\n    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);\n    pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias);\n    pNewItem->fg = pOldItem->fg;\n    pNewItem->iCursor = pOldItem->iCursor;\n    pNewItem->addrFillSub = pOldItem->addrFillSub;\n    pNewItem->regReturn = pOldItem->regReturn;\n    if( pNewItem->fg.isIndexedBy ){\n      pNewItem->u1.zIndexedBy = sqlite3DbStrDup(db, pOldItem->u1.zIndexedBy);\n    }\n    pNewItem->pIBIndex = pOldItem->pIBIndex;\n    if( pNewItem->fg.isTabFunc ){\n      pNewItem->u1.pFuncArg = \n          sqlite3ExprListDup(db, pOldItem->u1.pFuncArg, flags);\n    }\n    pTab = pNewItem->pTab = pOldItem->pTab;\n    if( pTab ){\n      pTab->nTabRef++;\n    }\n    pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect, flags);\n    pNewItem->pOn = sqlite3ExprDup(db, pOldItem->pOn, flags);\n    pNewItem->pUsing = sqlite3IdListDup(db, pOldItem->pUsing);\n    pNewItem->colUsed = pOldItem->colUsed;\n  }\n  return pNew;\n}\nIdList *sqlite3IdListDup(sqlite3 *db, IdList *p){\n  IdList *pNew;\n  int i;\n  assert( db!=0 );\n  if( p==0 ) return 0;\n  pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew) );\n  if( pNew==0 ) return 0;\n  pNew->nId = p->nId;\n  pNew->a = sqlite3DbMallocRawNN(db, p->nId*sizeof(p->a[0]) );\n  if( pNew->a==0 ){\n    sqlite3DbFreeNN(db, pNew);\n    return 0;\n  }\n  /* Note that because the size of the allocation for p->a[] is not\n  ** necessarily a power of two, sqlite3IdListAppend() may not be called\n  ** on the duplicate created by this function. */\n  for(i=0; i<p->nId; i++){\n    struct IdList_item *pNewItem = &pNew->a[i];\n    struct IdList_item *pOldItem = &p->a[i];\n    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);\n    pNewItem->idx = pOldItem->idx;\n  }\n  return pNew;\n}\nSelect *sqlite3SelectDup(sqlite3 *db, Select *pDup, int flags){\n  Select *pRet = 0;\n  Select *pNext = 0;\n  Select **pp = &pRet;\n  Select *p;\n\n  assert( db!=0 );\n  for(p=pDup; p; p=p->pPrior){\n    Select *pNew = sqlite3DbMallocRawNN(db, sizeof(*p) );\n    if( pNew==0 ) break;\n    pNew->pEList = sqlite3ExprListDup(db, p->pEList, flags);\n    pNew->pSrc = sqlite3SrcListDup(db, p->pSrc, flags);\n    pNew->pWhere = sqlite3ExprDup(db, p->pWhere, flags);\n    pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy, flags);\n    pNew->pHaving = sqlite3ExprDup(db, p->pHaving, flags);\n    pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, flags);\n    pNew->op = p->op;\n    pNew->pNext = pNext;\n    pNew->pPrior = 0;\n    pNew->pLimit = sqlite3ExprDup(db, p->pLimit, flags);\n    pNew->iLimit = 0;\n    pNew->iOffset = 0;\n    pNew->selFlags = p->selFlags & ~SF_UsesEphemeral;\n    pNew->addrOpenEphm[0] = -1;\n    pNew->addrOpenEphm[1] = -1;\n    pNew->nSelectRow = p->nSelectRow;\n    pNew->pWith = withDup(db, p->pWith);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    pNew->pWin = 0;\n    pNew->pWinDefn = sqlite3WindowListDup(db, p->pWinDefn);\n    if( p->pWin && db->mallocFailed==0 ) gatherSelectWindows(pNew);\n#endif\n    pNew->selId = p->selId;\n    *pp = pNew;\n    pp = &pNew->pPrior;\n    pNext = pNew;\n  }\n\n  return pRet;\n}\n#else\nSelect *sqlite3SelectDup(sqlite3 *db, Select *p, int flags){\n  assert( p==0 );\n  return 0;\n}\n#endif\n\n\n/*\n** Add a new element to the end of an expression list.  If pList is\n** initially NULL, then create a new expression list.\n**\n** The pList argument must be either NULL or a pointer to an ExprList\n** obtained from a prior call to sqlite3ExprListAppend().  This routine\n** may not be used with an ExprList obtained from sqlite3ExprListDup().\n** Reason:  This routine assumes that the number of slots in pList->a[]\n** is a power of two.  That is true for sqlite3ExprListAppend() returns\n** but is not necessarily true from the return value of sqlite3ExprListDup().\n**\n** If a memory allocation error occurs, the entire list is freed and\n** NULL is returned.  If non-NULL is returned, then it is guaranteed\n** that the new entry was successfully appended.\n*/\nExprList *sqlite3ExprListAppend(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to append. Might be NULL */\n  Expr *pExpr             /* Expression to be appended. Might be NULL */\n){\n  struct ExprList_item *pItem;\n  sqlite3 *db = pParse->db;\n  assert( db!=0 );\n  if( pList==0 ){\n    pList = sqlite3DbMallocRawNN(db, sizeof(ExprList) );\n    if( pList==0 ){\n      goto no_mem;\n    }\n    pList->nExpr = 0;\n  }else if( (pList->nExpr & (pList->nExpr-1))==0 ){\n    ExprList *pNew;\n    pNew = sqlite3DbRealloc(db, pList, \n         sizeof(*pList)+(2*(sqlite3_int64)pList->nExpr-1)*sizeof(pList->a[0]));\n    if( pNew==0 ){\n      goto no_mem;\n    }\n    pList = pNew;\n  }\n  pItem = &pList->a[pList->nExpr++];\n  assert( offsetof(struct ExprList_item,zName)==sizeof(pItem->pExpr) );\n  assert( offsetof(struct ExprList_item,pExpr)==0 );\n  memset(&pItem->zName,0,sizeof(*pItem)-offsetof(struct ExprList_item,zName));\n  pItem->pExpr = pExpr;\n  return pList;\n\nno_mem:     \n  /* Avoid leaking memory if malloc has failed. */\n  sqlite3ExprDelete(db, pExpr);\n  sqlite3ExprListDelete(db, pList);\n  return 0;\n}\n\n/*\n** pColumns and pExpr form a vector assignment which is part of the SET\n** clause of an UPDATE statement.  Like this:\n**\n**        (a,b,c) = (expr1,expr2,expr3)\n** Or:    (a,b,c) = (SELECT x,y,z FROM ....)\n**\n** For each term of the vector assignment, append new entries to the\n** expression list pList.  In the case of a subquery on the RHS, append\n** TK_SELECT_COLUMN expressions.\n*/\nExprList *sqlite3ExprListAppendVector(\n  Parse *pParse,         /* Parsing context */\n  ExprList *pList,       /* List to which to append. Might be NULL */\n  IdList *pColumns,      /* List of names of LHS of the assignment */\n  Expr *pExpr            /* Vector expression to be appended. Might be NULL */\n){\n  sqlite3 *db = pParse->db;\n  int n;\n  int i;\n  int iFirst = pList ? pList->nExpr : 0;\n  /* pColumns can only be NULL due to an OOM but an OOM will cause an\n  ** exit prior to this routine being invoked */\n  if( NEVER(pColumns==0) ) goto vector_append_error;\n  if( pExpr==0 ) goto vector_append_error;\n\n  /* If the RHS is a vector, then we can immediately check to see that \n  ** the size of the RHS and LHS match.  But if the RHS is a SELECT, \n  ** wildcards (\"*\") in the result set of the SELECT must be expanded before\n  ** we can do the size check, so defer the size check until code generation.\n  */\n  if( pExpr->op!=TK_SELECT && pColumns->nId!=(n=sqlite3ExprVectorSize(pExpr)) ){\n    sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\",\n                    pColumns->nId, n);\n    goto vector_append_error;\n  }\n\n  for(i=0; i<pColumns->nId; i++){\n    Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i);\n    assert( pSubExpr!=0 || db->mallocFailed );\n    assert( pSubExpr==0 || pSubExpr->iTable==0 );\n    if( pSubExpr==0 ) continue;\n    pSubExpr->iTable = pColumns->nId;\n    pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);\n    if( pList ){\n      assert( pList->nExpr==iFirst+i+1 );\n      pList->a[pList->nExpr-1].zName = pColumns->a[i].zName;\n      pColumns->a[i].zName = 0;\n    }\n  }\n\n  if( !db->mallocFailed && pExpr->op==TK_SELECT && ALWAYS(pList!=0) ){\n    Expr *pFirst = pList->a[iFirst].pExpr;\n    assert( pFirst!=0 );\n    assert( pFirst->op==TK_SELECT_COLUMN );\n     \n    /* Store the SELECT statement in pRight so it will be deleted when\n    ** sqlite3ExprListDelete() is called */\n    pFirst->pRight = pExpr;\n    pExpr = 0;\n\n    /* Remember the size of the LHS in iTable so that we can check that\n    ** the RHS and LHS sizes match during code generation. */\n    pFirst->iTable = pColumns->nId;\n  }\n\nvector_append_error:\n  sqlite3ExprUnmapAndDelete(pParse, pExpr);\n  sqlite3IdListDelete(db, pColumns);\n  return pList;\n}\n\n/*\n** Set the sort order for the last element on the given ExprList.\n*/\nvoid sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder, int eNulls){\n  struct ExprList_item *pItem;\n  if( p==0 ) return;\n  assert( p->nExpr>0 );\n\n  assert( SQLITE_SO_UNDEFINED<0 && SQLITE_SO_ASC==0 && SQLITE_SO_DESC>0 );\n  assert( iSortOrder==SQLITE_SO_UNDEFINED \n       || iSortOrder==SQLITE_SO_ASC \n       || iSortOrder==SQLITE_SO_DESC \n  );\n  assert( eNulls==SQLITE_SO_UNDEFINED \n       || eNulls==SQLITE_SO_ASC \n       || eNulls==SQLITE_SO_DESC \n  );\n\n  pItem = &p->a[p->nExpr-1];\n  assert( pItem->bNulls==0 );\n  if( iSortOrder==SQLITE_SO_UNDEFINED ){\n    iSortOrder = SQLITE_SO_ASC;\n  }\n  pItem->sortFlags = (u8)iSortOrder;\n\n  if( eNulls!=SQLITE_SO_UNDEFINED ){\n    pItem->bNulls = 1;\n    if( iSortOrder!=eNulls ){\n      pItem->sortFlags |= KEYINFO_ORDER_BIGNULL;\n    }\n  }\n}\n\n/*\n** Set the ExprList.a[].zName element of the most recently added item\n** on the expression list.\n**\n** pList might be NULL following an OOM error.  But pName should never be\n** NULL.  If a memory allocation fails, the pParse->db->mallocFailed flag\n** is set.\n*/\nvoid sqlite3ExprListSetName(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to add the span. */\n  Token *pName,           /* Name to be added */\n  int dequote             /* True to cause the name to be dequoted */\n){\n  assert( pList!=0 || pParse->db->mallocFailed!=0 );\n  if( pList ){\n    struct ExprList_item *pItem;\n    assert( pList->nExpr>0 );\n    pItem = &pList->a[pList->nExpr-1];\n    assert( pItem->zName==0 );\n    pItem->zName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n);\n    if( dequote ) sqlite3Dequote(pItem->zName);\n    if( IN_RENAME_OBJECT ){\n      sqlite3RenameTokenMap(pParse, (void*)pItem->zName, pName);\n    }\n  }\n}\n\n/*\n** Set the ExprList.a[].zSpan element of the most recently added item\n** on the expression list.\n**\n** pList might be NULL following an OOM error.  But pSpan should never be\n** NULL.  If a memory allocation fails, the pParse->db->mallocFailed flag\n** is set.\n*/\nvoid sqlite3ExprListSetSpan(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to add the span. */\n  const char *zStart,     /* Start of the span */\n  const char *zEnd        /* End of the span */\n){\n  sqlite3 *db = pParse->db;\n  assert( pList!=0 || db->mallocFailed!=0 );\n  if( pList ){\n    struct ExprList_item *pItem = &pList->a[pList->nExpr-1];\n    assert( pList->nExpr>0 );\n    sqlite3DbFree(db, pItem->zSpan);\n    pItem->zSpan = sqlite3DbSpanDup(db, zStart, zEnd);\n  }\n}\n\n/*\n** If the expression list pEList contains more than iLimit elements,\n** leave an error message in pParse.\n*/\nvoid sqlite3ExprListCheckLength(\n  Parse *pParse,\n  ExprList *pEList,\n  const char *zObject\n){\n  int mx = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];\n  testcase( pEList && pEList->nExpr==mx );\n  testcase( pEList && pEList->nExpr==mx+1 );\n  if( pEList && pEList->nExpr>mx ){\n    sqlite3ErrorMsg(pParse, \"too many columns in %s\", zObject);\n  }\n}\n\n/*\n** Delete an entire expression list.\n*/\nstatic SQLITE_NOINLINE void exprListDeleteNN(sqlite3 *db, ExprList *pList){\n  int i = pList->nExpr;\n  struct ExprList_item *pItem =  pList->a;\n  assert( pList->nExpr>0 );\n  do{\n    sqlite3ExprDelete(db, pItem->pExpr);\n    sqlite3DbFree(db, pItem->zName);\n    sqlite3DbFree(db, pItem->zSpan);\n    pItem++;\n  }while( --i>0 );\n  sqlite3DbFreeNN(db, pList);\n}\nvoid sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){\n  if( pList ) exprListDeleteNN(db, pList);\n}\n\n/*\n** Return the bitwise-OR of all Expr.flags fields in the given\n** ExprList.\n*/\nu32 sqlite3ExprListFlags(const ExprList *pList){\n  int i;\n  u32 m = 0;\n  assert( pList!=0 );\n  for(i=0; i<pList->nExpr; i++){\n     Expr *pExpr = pList->a[i].pExpr;\n     assert( pExpr!=0 );\n     m |= pExpr->flags;\n  }\n  return m;\n}\n\n/*\n** This is a SELECT-node callback for the expression walker that\n** always \"fails\".  By \"fail\" in this case, we mean set\n** pWalker->eCode to zero and abort.\n**\n** This callback is used by multiple expression walkers.\n*/\nint sqlite3SelectWalkFail(Walker *pWalker, Select *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  pWalker->eCode = 0;\n  return WRC_Abort;\n}\n\n/*\n** If the input expression is an ID with the name \"true\" or \"false\"\n** then convert it into an TK_TRUEFALSE term.  Return non-zero if\n** the conversion happened, and zero if the expression is unaltered.\n*/\nint sqlite3ExprIdToTrueFalse(Expr *pExpr){\n  assert( pExpr->op==TK_ID || pExpr->op==TK_STRING );\n  if( !ExprHasProperty(pExpr, EP_Quoted)\n   && (sqlite3StrICmp(pExpr->u.zToken, \"true\")==0\n       || sqlite3StrICmp(pExpr->u.zToken, \"false\")==0)\n  ){\n    pExpr->op = TK_TRUEFALSE;\n    ExprSetProperty(pExpr, pExpr->u.zToken[4]==0 ? EP_IsTrue : EP_IsFalse);\n    return 1;\n  }\n  return 0;\n}\n\n/*\n** The argument must be a TK_TRUEFALSE Expr node.  Return 1 if it is TRUE\n** and 0 if it is FALSE.\n*/\nint sqlite3ExprTruthValue(const Expr *pExpr){\n  pExpr = sqlite3ExprSkipCollate((Expr*)pExpr);\n  assert( pExpr->op==TK_TRUEFALSE );\n  assert( sqlite3StrICmp(pExpr->u.zToken,\"true\")==0\n       || sqlite3StrICmp(pExpr->u.zToken,\"false\")==0 );\n  return pExpr->u.zToken[4]==0;\n}\n\n/*\n** If pExpr is an AND or OR expression, try to simplify it by eliminating\n** terms that are always true or false.  Return the simplified expression.\n** Or return the original expression if no simplification is possible.\n**\n** Examples:\n**\n**     (x<10) AND true                =>   (x<10)\n**     (x<10) AND false               =>   false\n**     (x<10) AND (y=22 OR false)     =>   (x<10) AND (y=22)\n**     (x<10) AND (y=22 OR true)      =>   (x<10)\n**     (y=22) OR true                 =>   true\n*/\nExpr *sqlite3ExprSimplifiedAndOr(Expr *pExpr){\n  assert( pExpr!=0 );\n  if( pExpr->op==TK_AND || pExpr->op==TK_OR ){\n    Expr *pRight = sqlite3ExprSimplifiedAndOr(pExpr->pRight);\n    Expr *pLeft = sqlite3ExprSimplifiedAndOr(pExpr->pLeft);\n    if( ExprAlwaysTrue(pLeft) || ExprAlwaysFalse(pRight) ){\n      pExpr = pExpr->op==TK_AND ? pRight : pLeft;\n    }else if( ExprAlwaysTrue(pRight) || ExprAlwaysFalse(pLeft) ){\n      pExpr = pExpr->op==TK_AND ? pLeft : pRight;\n    }\n  }\n  return pExpr;\n}\n\n\n/*\n** These routines are Walker callbacks used to check expressions to\n** see if they are \"constant\" for some definition of constant.  The\n** Walker.eCode value determines the type of \"constant\" we are looking\n** for.\n**\n** These callback routines are used to implement the following:\n**\n**     sqlite3ExprIsConstant()                  pWalker->eCode==1\n**     sqlite3ExprIsConstantNotJoin()           pWalker->eCode==2\n**     sqlite3ExprIsTableConstant()             pWalker->eCode==3\n**     sqlite3ExprIsConstantOrFunction()        pWalker->eCode==4 or 5\n**\n** In all cases, the callbacks set Walker.eCode=0 and abort if the expression\n** is found to not be a constant.\n**\n** The sqlite3ExprIsConstantOrFunction() is used for evaluating expressions\n** in a CREATE TABLE statement.  The Walker.eCode value is 5 when parsing\n** an existing schema and 4 when processing a new statement.  A bound\n** parameter raises an error for new statements, but is silently converted\n** to NULL for existing schemas.  This allows sqlite_master tables that \n** contain a bound parameter because they were generated by older versions\n** of SQLite to be parsed by newer versions of SQLite without raising a\n** malformed schema error.\n*/\nstatic int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){\n\n  /* If pWalker->eCode is 2 then any term of the expression that comes from\n  ** the ON or USING clauses of a left join disqualifies the expression\n  ** from being considered constant. */\n  if( pWalker->eCode==2 && ExprHasProperty(pExpr, EP_FromJoin) ){\n    pWalker->eCode = 0;\n    return WRC_Abort;\n  }\n\n  switch( pExpr->op ){\n    /* Consider functions to be constant if all their arguments are constant\n    ** and either pWalker->eCode==4 or 5 or the function has the\n    ** SQLITE_FUNC_CONST flag. */\n    case TK_FUNCTION:\n      if( (pWalker->eCode>=4 || ExprHasProperty(pExpr,EP_ConstFunc))\n       && !ExprHasProperty(pExpr, EP_WinFunc)\n      ){\n        return WRC_Continue;\n      }else{\n        pWalker->eCode = 0;\n        return WRC_Abort;\n      }\n    case TK_ID:\n      /* Convert \"true\" or \"false\" in a DEFAULT clause into the\n      ** appropriate TK_TRUEFALSE operator */\n      if( sqlite3ExprIdToTrueFalse(pExpr) ){\n        return WRC_Prune;\n      }\n      /* Fall thru */\n    case TK_COLUMN:\n    case TK_AGG_FUNCTION:\n    case TK_AGG_COLUMN:\n      testcase( pExpr->op==TK_ID );\n      testcase( pExpr->op==TK_COLUMN );\n      testcase( pExpr->op==TK_AGG_FUNCTION );\n      testcase( pExpr->op==TK_AGG_COLUMN );\n      if( ExprHasProperty(pExpr, EP_FixedCol) && pWalker->eCode!=2 ){\n        return WRC_Continue;\n      }\n      if( pWalker->eCode==3 && pExpr->iTable==pWalker->u.iCur ){\n        return WRC_Continue;\n      }\n      /* Fall through */\n    case TK_IF_NULL_ROW:\n    case TK_REGISTER:\n      testcase( pExpr->op==TK_REGISTER );\n      testcase( pExpr->op==TK_IF_NULL_ROW );\n      pWalker->eCode = 0;\n      return WRC_Abort;\n    case TK_VARIABLE:\n      if( pWalker->eCode==5 ){\n        /* Silently convert bound parameters that appear inside of CREATE\n        ** statements into a NULL when parsing the CREATE statement text out\n        ** of the sqlite_master table */\n        pExpr->op = TK_NULL;\n      }else if( pWalker->eCode==4 ){\n        /* A bound parameter in a CREATE statement that originates from\n        ** sqlite3_prepare() causes an error */\n        pWalker->eCode = 0;\n        return WRC_Abort;\n      }\n      /* Fall through */\n    default:\n      testcase( pExpr->op==TK_SELECT ); /* sqlite3SelectWalkFail() disallows */\n      testcase( pExpr->op==TK_EXISTS ); /* sqlite3SelectWalkFail() disallows */\n      return WRC_Continue;\n  }\n}\nstatic int exprIsConst(Expr *p, int initFlag, int iCur){\n  Walker w;\n  w.eCode = initFlag;\n  w.xExprCallback = exprNodeIsConstant;\n  w.xSelectCallback = sqlite3SelectWalkFail;\n#ifdef SQLITE_DEBUG\n  w.xSelectCallback2 = sqlite3SelectWalkAssert2;\n#endif\n  w.u.iCur = iCur;\n  sqlite3WalkExpr(&w, p);\n  return w.eCode;\n}\n\n/*\n** Walk an expression tree.  Return non-zero if the expression is constant\n** and 0 if it involves variables or function calls.\n**\n** For the purposes of this function, a double-quoted string (ex: \"abc\")\n** is considered a variable but a single-quoted string (ex: 'abc') is\n** a constant.\n*/\nint sqlite3ExprIsConstant(Expr *p){\n  return exprIsConst(p, 1, 0);\n}\n\n/*\n** Walk an expression tree.  Return non-zero if\n**\n**   (1) the expression is constant, and\n**   (2) the expression does originate in the ON or USING clause\n**       of a LEFT JOIN, and\n**   (3) the expression does not contain any EP_FixedCol TK_COLUMN\n**       operands created by the constant propagation optimization.\n**\n** When this routine returns true, it indicates that the expression\n** can be added to the pParse->pConstExpr list and evaluated once when\n** the prepared statement starts up.  See sqlite3ExprCodeAtInit().\n*/\nint sqlite3ExprIsConstantNotJoin(Expr *p){\n  return exprIsConst(p, 2, 0);\n}\n\n/*\n** Walk an expression tree.  Return non-zero if the expression is constant\n** for any single row of the table with cursor iCur.  In other words, the\n** expression must not refer to any non-deterministic function nor any\n** table other than iCur.\n*/\nint sqlite3ExprIsTableConstant(Expr *p, int iCur){\n  return exprIsConst(p, 3, iCur);\n}\n\n\n/*\n** sqlite3WalkExpr() callback used by sqlite3ExprIsConstantOrGroupBy().\n*/\nstatic int exprNodeIsConstantOrGroupBy(Walker *pWalker, Expr *pExpr){\n  ExprList *pGroupBy = pWalker->u.pGroupBy;\n  int i;\n\n  /* Check if pExpr is identical to any GROUP BY term. If so, consider\n  ** it constant.  */\n  for(i=0; i<pGroupBy->nExpr; i++){\n    Expr *p = pGroupBy->a[i].pExpr;\n    if( sqlite3ExprCompare(0, pExpr, p, -1)<2 ){\n      CollSeq *pColl = sqlite3ExprNNCollSeq(pWalker->pParse, p);\n      if( sqlite3IsBinary(pColl) ){\n        return WRC_Prune;\n      }\n    }\n  }\n\n  /* Check if pExpr is a sub-select. If so, consider it variable. */\n  if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n    pWalker->eCode = 0;\n    return WRC_Abort;\n  }\n\n  return exprNodeIsConstant(pWalker, pExpr);\n}\n\n/*\n** Walk the expression tree passed as the first argument. Return non-zero\n** if the expression consists entirely of constants or copies of terms \n** in pGroupBy that sort with the BINARY collation sequence.\n**\n** This routine is used to determine if a term of the HAVING clause can\n** be promoted into the WHERE clause.  In order for such a promotion to work,\n** the value of the HAVING clause term must be the same for all members of\n** a \"group\".  The requirement that the GROUP BY term must be BINARY\n** assumes that no other collating sequence will have a finer-grained\n** grouping than binary.  In other words (A=B COLLATE binary) implies\n** A=B in every other collating sequence.  The requirement that the\n** GROUP BY be BINARY is stricter than necessary.  It would also work\n** to promote HAVING clauses that use the same alternative collating\n** sequence as the GROUP BY term, but that is much harder to check,\n** alternative collating sequences are uncommon, and this is only an\n** optimization, so we take the easy way out and simply require the\n** GROUP BY to use the BINARY collating sequence.\n*/\nint sqlite3ExprIsConstantOrGroupBy(Parse *pParse, Expr *p, ExprList *pGroupBy){\n  Walker w;\n  w.eCode = 1;\n  w.xExprCallback = exprNodeIsConstantOrGroupBy;\n  w.xSelectCallback = 0;\n  w.u.pGroupBy = pGroupBy;\n  w.pParse = pParse;\n  sqlite3WalkExpr(&w, p);\n  return w.eCode;\n}\n\n/*\n** Walk an expression tree.  Return non-zero if the expression is constant\n** or a function call with constant arguments.  Return and 0 if there\n** are any variables.\n**\n** For the purposes of this function, a double-quoted string (ex: \"abc\")\n** is considered a variable but a single-quoted string (ex: 'abc') is\n** a constant.\n*/\nint sqlite3ExprIsConstantOrFunction(Expr *p, u8 isInit){\n  assert( isInit==0 || isInit==1 );\n  return exprIsConst(p, 4+isInit, 0);\n}\n\n#ifdef SQLITE_ENABLE_CURSOR_HINTS\n/*\n** Walk an expression tree.  Return 1 if the expression contains a\n** subquery of some kind.  Return 0 if there are no subqueries.\n*/\nint sqlite3ExprContainsSubquery(Expr *p){\n  Walker w;\n  w.eCode = 1;\n  w.xExprCallback = sqlite3ExprWalkNoop;\n  w.xSelectCallback = sqlite3SelectWalkFail;\n#ifdef SQLITE_DEBUG\n  w.xSelectCallback2 = sqlite3SelectWalkAssert2;\n#endif\n  sqlite3WalkExpr(&w, p);\n  return w.eCode==0;\n}\n#endif\n\n/*\n** If the expression p codes a constant integer that is small enough\n** to fit in a 32-bit integer, return 1 and put the value of the integer\n** in *pValue.  If the expression is not an integer or if it is too big\n** to fit in a signed 32-bit integer, return 0 and leave *pValue unchanged.\n*/\nint sqlite3ExprIsInteger(Expr *p, int *pValue){\n  int rc = 0;\n  if( NEVER(p==0) ) return 0;  /* Used to only happen following on OOM */\n\n  /* If an expression is an integer literal that fits in a signed 32-bit\n  ** integer, then the EP_IntValue flag will have already been set */\n  assert( p->op!=TK_INTEGER || (p->flags & EP_IntValue)!=0\n           || sqlite3GetInt32(p->u.zToken, &rc)==0 );\n\n  if( p->flags & EP_IntValue ){\n    *pValue = p->u.iValue;\n    return 1;\n  }\n  switch( p->op ){\n    case TK_UPLUS: {\n      rc = sqlite3ExprIsInteger(p->pLeft, pValue);\n      break;\n    }\n    case TK_UMINUS: {\n      int v;\n      if( sqlite3ExprIsInteger(p->pLeft, &v) ){\n        assert( v!=(-2147483647-1) );\n        *pValue = -v;\n        rc = 1;\n      }\n      break;\n    }\n    default: break;\n  }\n  return rc;\n}\n\n/*\n** Return FALSE if there is no chance that the expression can be NULL.\n**\n** If the expression might be NULL or if the expression is too complex\n** to tell return TRUE.  \n**\n** This routine is used as an optimization, to skip OP_IsNull opcodes\n** when we know that a value cannot be NULL.  Hence, a false positive\n** (returning TRUE when in fact the expression can never be NULL) might\n** be a small performance hit but is otherwise harmless.  On the other\n** hand, a false negative (returning FALSE when the result could be NULL)\n** will likely result in an incorrect answer.  So when in doubt, return\n** TRUE.\n*/\nint sqlite3ExprCanBeNull(const Expr *p){\n  u8 op;\n  while( p->op==TK_UPLUS || p->op==TK_UMINUS ){\n    p = p->pLeft;\n  }\n  op = p->op;\n  if( op==TK_REGISTER ) op = p->op2;\n  switch( op ){\n    case TK_INTEGER:\n    case TK_STRING:\n    case TK_FLOAT:\n    case TK_BLOB:\n      return 0;\n    case TK_COLUMN:\n      return ExprHasProperty(p, EP_CanBeNull) ||\n             p->y.pTab==0 ||  /* Reference to column of index on expression */\n             (p->iColumn>=0 && p->y.pTab->aCol[p->iColumn].notNull==0);\n    default:\n      return 1;\n  }\n}\n\n/*\n** Return TRUE if the given expression is a constant which would be\n** unchanged by OP_Affinity with the affinity given in the second\n** argument.\n**\n** This routine is used to determine if the OP_Affinity operation\n** can be omitted.  When in doubt return FALSE.  A false negative\n** is harmless.  A false positive, however, can result in the wrong\n** answer.\n*/\nint sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff){\n  u8 op;\n  int unaryMinus = 0;\n  if( aff==SQLITE_AFF_BLOB ) return 1;\n  while( p->op==TK_UPLUS || p->op==TK_UMINUS ){\n    if( p->op==TK_UMINUS ) unaryMinus = 1;\n    p = p->pLeft;\n  }\n  op = p->op;\n  if( op==TK_REGISTER ) op = p->op2;\n  switch( op ){\n    case TK_INTEGER: {\n      return aff>=SQLITE_AFF_NUMERIC;\n    }\n    case TK_FLOAT: {\n      return aff>=SQLITE_AFF_NUMERIC;\n    }\n    case TK_STRING: {\n      return !unaryMinus && aff==SQLITE_AFF_TEXT;\n    }\n    case TK_BLOB: {\n      return !unaryMinus;\n    }\n    case TK_COLUMN: {\n      assert( p->iTable>=0 );  /* p cannot be part of a CHECK constraint */\n      return aff>=SQLITE_AFF_NUMERIC && p->iColumn<0;\n    }\n    default: {\n      return 0;\n    }\n  }\n}\n\n/*\n** Return TRUE if the given string is a row-id column name.\n*/\nint sqlite3IsRowid(const char *z){\n  if( sqlite3StrICmp(z, \"_ROWID_\")==0 ) return 1;\n  if( sqlite3StrICmp(z, \"ROWID\")==0 ) return 1;\n  if( sqlite3StrICmp(z, \"OID\")==0 ) return 1;\n  return 0;\n}\n\n/*\n** pX is the RHS of an IN operator.  If pX is a SELECT statement \n** that can be simplified to a direct table access, then return\n** a pointer to the SELECT statement.  If pX is not a SELECT statement,\n** or if the SELECT statement needs to be manifested into a transient\n** table, then return NULL.\n*/\n#ifndef SQLITE_OMIT_SUBQUERY\nstatic Select *isCandidateForInOpt(Expr *pX){\n  Select *p;\n  SrcList *pSrc;\n  ExprList *pEList;\n  Table *pTab;\n  int i;\n  if( !ExprHasProperty(pX, EP_xIsSelect) ) return 0;  /* Not a subquery */\n  if( ExprHasProperty(pX, EP_VarSelect)  ) return 0;  /* Correlated subq */\n  p = pX->x.pSelect;\n  if( p->pPrior ) return 0;              /* Not a compound SELECT */\n  if( p->selFlags & (SF_Distinct|SF_Aggregate) ){\n    testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );\n    testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );\n    return 0; /* No DISTINCT keyword and no aggregate functions */\n  }\n  assert( p->pGroupBy==0 );              /* Has no GROUP BY clause */\n  if( p->pLimit ) return 0;              /* Has no LIMIT clause */\n  if( p->pWhere ) return 0;              /* Has no WHERE clause */\n  pSrc = p->pSrc;\n  assert( pSrc!=0 );\n  if( pSrc->nSrc!=1 ) return 0;          /* Single term in FROM clause */\n  if( pSrc->a[0].pSelect ) return 0;     /* FROM is not a subquery or view */\n  pTab = pSrc->a[0].pTab;\n  assert( pTab!=0 );\n  assert( pTab->pSelect==0 );            /* FROM clause is not a view */\n  if( IsVirtual(pTab) ) return 0;        /* FROM clause not a virtual table */\n  pEList = p->pEList;\n  assert( pEList!=0 );\n  /* All SELECT results must be columns. */\n  for(i=0; i<pEList->nExpr; i++){\n    Expr *pRes = pEList->a[i].pExpr;\n    if( pRes->op!=TK_COLUMN ) return 0;\n    assert( pRes->iTable==pSrc->a[0].iCursor );  /* Not a correlated subquery */\n  }\n  return p;\n}\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Generate code that checks the left-most column of index table iCur to see if\n** it contains any NULL entries.  Cause the register at regHasNull to be set\n** to a non-NULL value if iCur contains no NULLs.  Cause register regHasNull\n** to be set to NULL if iCur contains one or more NULL values.\n*/\nstatic void sqlite3SetHasNullFlag(Vdbe *v, int iCur, int regHasNull){\n  int addr1;\n  sqlite3VdbeAddOp2(v, OP_Integer, 0, regHasNull);\n  addr1 = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);\n  sqlite3VdbeAddOp3(v, OP_Column, iCur, 0, regHasNull);\n  sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n  VdbeComment((v, \"first_entry_in(%d)\", iCur));\n  sqlite3VdbeJumpHere(v, addr1);\n}\n#endif\n\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** The argument is an IN operator with a list (not a subquery) on the \n** right-hand side.  Return TRUE if that list is constant.\n*/\nstatic int sqlite3InRhsIsConstant(Expr *pIn){\n  Expr *pLHS;\n  int res;\n  assert( !ExprHasProperty(pIn, EP_xIsSelect) );\n  pLHS = pIn->pLeft;\n  pIn->pLeft = 0;\n  res = sqlite3ExprIsConstant(pIn);\n  pIn->pLeft = pLHS;\n  return res;\n}\n#endif\n\n/*\n** This function is used by the implementation of the IN (...) operator.\n** The pX parameter is the expression on the RHS of the IN operator, which\n** might be either a list of expressions or a subquery.\n**\n** The job of this routine is to find or create a b-tree object that can\n** be used either to test for membership in the RHS set or to iterate through\n** all members of the RHS set, skipping duplicates.\n**\n** A cursor is opened on the b-tree object that is the RHS of the IN operator\n** and pX->iTable is set to the index of that cursor.\n**\n** The returned value of this function indicates the b-tree type, as follows:\n**\n**   IN_INDEX_ROWID      - The cursor was opened on a database table.\n**   IN_INDEX_INDEX_ASC  - The cursor was opened on an ascending index.\n**   IN_INDEX_INDEX_DESC - The cursor was opened on a descending index.\n**   IN_INDEX_EPH        - The cursor was opened on a specially created and\n**                         populated epheremal table.\n**   IN_INDEX_NOOP       - No cursor was allocated.  The IN operator must be\n**                         implemented as a sequence of comparisons.\n**\n** An existing b-tree might be used if the RHS expression pX is a simple\n** subquery such as:\n**\n**     SELECT <column1>, <column2>... FROM <table>\n**\n** If the RHS of the IN operator is a list or a more complex subquery, then\n** an ephemeral table might need to be generated from the RHS and then\n** pX->iTable made to point to the ephemeral table instead of an\n** existing table.\n**\n** The inFlags parameter must contain, at a minimum, one of the bits\n** IN_INDEX_MEMBERSHIP or IN_INDEX_LOOP but not both.  If inFlags contains\n** IN_INDEX_MEMBERSHIP, then the generated table will be used for a fast\n** membership test.  When the IN_INDEX_LOOP bit is set, the IN index will\n** be used to loop over all values of the RHS of the IN operator.\n**\n** When IN_INDEX_LOOP is used (and the b-tree will be used to iterate\n** through the set members) then the b-tree must not contain duplicates.\n** An epheremal table will be created unless the selected columns are guaranteed\n** to be unique - either because it is an INTEGER PRIMARY KEY or due to\n** a UNIQUE constraint or index.\n**\n** When IN_INDEX_MEMBERSHIP is used (and the b-tree will be used \n** for fast set membership tests) then an epheremal table must \n** be used unless <columns> is a single INTEGER PRIMARY KEY column or an \n** index can be found with the specified <columns> as its left-most.\n**\n** If the IN_INDEX_NOOP_OK and IN_INDEX_MEMBERSHIP are both set and\n** if the RHS of the IN operator is a list (not a subquery) then this\n** routine might decide that creating an ephemeral b-tree for membership\n** testing is too expensive and return IN_INDEX_NOOP.  In that case, the\n** calling routine should implement the IN operator using a sequence\n** of Eq or Ne comparison operations.\n**\n** When the b-tree is being used for membership tests, the calling function\n** might need to know whether or not the RHS side of the IN operator\n** contains a NULL.  If prRhsHasNull is not a NULL pointer and \n** if there is any chance that the (...) might contain a NULL value at\n** runtime, then a register is allocated and the register number written\n** to *prRhsHasNull. If there is no chance that the (...) contains a\n** NULL value, then *prRhsHasNull is left unchanged.\n**\n** If a register is allocated and its location stored in *prRhsHasNull, then\n** the value in that register will be NULL if the b-tree contains one or more\n** NULL values, and it will be some non-NULL value if the b-tree contains no\n** NULL values.\n**\n** If the aiMap parameter is not NULL, it must point to an array containing\n** one element for each column returned by the SELECT statement on the RHS\n** of the IN(...) operator. The i'th entry of the array is populated with the\n** offset of the index column that matches the i'th column returned by the\n** SELECT. For example, if the expression and selected index are:\n**\n**   (?,?,?) IN (SELECT a, b, c FROM t1)\n**   CREATE INDEX i1 ON t1(b, c, a);\n**\n** then aiMap[] is populated with {2, 0, 1}.\n*/\n#ifndef SQLITE_OMIT_SUBQUERY\nint sqlite3FindInIndex(\n  Parse *pParse,             /* Parsing context */\n  Expr *pX,                  /* The IN expression */\n  u32 inFlags,               /* IN_INDEX_LOOP, _MEMBERSHIP, and/or _NOOP_OK */\n  int *prRhsHasNull,         /* Register holding NULL status.  See notes */\n  int *aiMap,                /* Mapping from Index fields to RHS fields */\n  int *piTab                 /* OUT: index to use */\n){\n  Select *p;                            /* SELECT to the right of IN operator */\n  int eType = 0;                        /* Type of RHS table. IN_INDEX_* */\n  int iTab = pParse->nTab++;            /* Cursor of the RHS table */\n  int mustBeUnique;                     /* True if RHS must be unique */\n  Vdbe *v = sqlite3GetVdbe(pParse);     /* Virtual machine being coded */\n\n  assert( pX->op==TK_IN );\n  mustBeUnique = (inFlags & IN_INDEX_LOOP)!=0;\n\n  /* If the RHS of this IN(...) operator is a SELECT, and if it matters \n  ** whether or not the SELECT result contains NULL values, check whether\n  ** or not NULL is actually possible (it may not be, for example, due \n  ** to NOT NULL constraints in the schema). If no NULL values are possible,\n  ** set prRhsHasNull to 0 before continuing.  */\n  if( prRhsHasNull && (pX->flags & EP_xIsSelect) ){\n    int i;\n    ExprList *pEList = pX->x.pSelect->pEList;\n    for(i=0; i<pEList->nExpr; i++){\n      if( sqlite3ExprCanBeNull(pEList->a[i].pExpr) ) break;\n    }\n    if( i==pEList->nExpr ){\n      prRhsHasNull = 0;\n    }\n  }\n\n  /* Check to see if an existing table or index can be used to\n  ** satisfy the query.  This is preferable to generating a new \n  ** ephemeral table.  */\n  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){\n    sqlite3 *db = pParse->db;              /* Database connection */\n    Table *pTab;                           /* Table <table>. */\n    i16 iDb;                               /* Database idx for pTab */\n    ExprList *pEList = p->pEList;\n    int nExpr = pEList->nExpr;\n\n    assert( p->pEList!=0 );             /* Because of isCandidateForInOpt(p) */\n    assert( p->pEList->a[0].pExpr!=0 ); /* Because of isCandidateForInOpt(p) */\n    assert( p->pSrc!=0 );               /* Because of isCandidateForInOpt(p) */\n    pTab = p->pSrc->a[0].pTab;\n\n    /* Code an OP_Transaction and OP_TableLock for <table>. */\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    sqlite3CodeVerifySchema(pParse, iDb);\n    sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n    assert(v);  /* sqlite3GetVdbe() has always been previously called */\n    if( nExpr==1 && pEList->a[0].pExpr->iColumn<0 ){\n      /* The \"x IN (SELECT rowid FROM table)\" case */\n      int iAddr = sqlite3VdbeAddOp0(v, OP_Once);\n      VdbeCoverage(v);\n\n      sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);\n      eType = IN_INDEX_ROWID;\n      ExplainQueryPlan((pParse, 0,\n            \"USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR\",pTab->zName));\n      sqlite3VdbeJumpHere(v, iAddr);\n    }else{\n      Index *pIdx;                         /* Iterator variable */\n      int affinity_ok = 1;\n      int i;\n\n      /* Check that the affinity that will be used to perform each \n      ** comparison is the same as the affinity of each column in table\n      ** on the RHS of the IN operator.  If it not, it is not possible to\n      ** use any index of the RHS table.  */\n      for(i=0; i<nExpr && affinity_ok; i++){\n        Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);\n        int iCol = pEList->a[i].pExpr->iColumn;\n        char idxaff = sqlite3TableColumnAffinity(pTab,iCol); /* RHS table */\n        char cmpaff = sqlite3CompareAffinity(pLhs, idxaff);\n        testcase( cmpaff==SQLITE_AFF_BLOB );\n        testcase( cmpaff==SQLITE_AFF_TEXT );\n        switch( cmpaff ){\n          case SQLITE_AFF_BLOB:\n            break;\n          case SQLITE_AFF_TEXT:\n            /* sqlite3CompareAffinity() only returns TEXT if one side or the\n            ** other has no affinity and the other side is TEXT.  Hence,\n            ** the only way for cmpaff to be TEXT is for idxaff to be TEXT\n            ** and for the term on the LHS of the IN to have no affinity. */\n            assert( idxaff==SQLITE_AFF_TEXT );\n            break;\n          default:\n            affinity_ok = sqlite3IsNumericAffinity(idxaff);\n        }\n      }\n\n      if( affinity_ok ){\n        /* Search for an existing index that will work for this IN operator */\n        for(pIdx=pTab->pIndex; pIdx && eType==0; pIdx=pIdx->pNext){\n          Bitmask colUsed;      /* Columns of the index used */\n          Bitmask mCol;         /* Mask for the current column */\n          if( pIdx->nColumn<nExpr ) continue;\n          if( pIdx->pPartIdxWhere!=0 ) continue;\n          /* Maximum nColumn is BMS-2, not BMS-1, so that we can compute\n          ** BITMASK(nExpr) without overflowing */\n          testcase( pIdx->nColumn==BMS-2 );\n          testcase( pIdx->nColumn==BMS-1 );\n          if( pIdx->nColumn>=BMS-1 ) continue;\n          if( mustBeUnique ){\n            if( pIdx->nKeyCol>nExpr\n             ||(pIdx->nColumn>nExpr && !IsUniqueIndex(pIdx))\n            ){\n              continue;  /* This index is not unique over the IN RHS columns */\n            }\n          }\n  \n          colUsed = 0;   /* Columns of index used so far */\n          for(i=0; i<nExpr; i++){\n            Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);\n            Expr *pRhs = pEList->a[i].pExpr;\n            CollSeq *pReq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);\n            int j;\n  \n            assert( pReq!=0 || pRhs->iColumn==XN_ROWID || pParse->nErr );\n            for(j=0; j<nExpr; j++){\n              if( pIdx->aiColumn[j]!=pRhs->iColumn ) continue;\n              assert( pIdx->azColl[j] );\n              if( pReq!=0 && sqlite3StrICmp(pReq->zName, pIdx->azColl[j])!=0 ){\n                continue;\n              }\n              break;\n            }\n            if( j==nExpr ) break;\n            mCol = MASKBIT(j);\n            if( mCol & colUsed ) break; /* Each column used only once */\n            colUsed |= mCol;\n            if( aiMap ) aiMap[i] = j;\n          }\n  \n          assert( i==nExpr || colUsed!=(MASKBIT(nExpr)-1) );\n          if( colUsed==(MASKBIT(nExpr)-1) ){\n            /* If we reach this point, that means the index pIdx is usable */\n            int iAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n            ExplainQueryPlan((pParse, 0,\n                              \"USING INDEX %s FOR IN-OPERATOR\",pIdx->zName));\n            sqlite3VdbeAddOp3(v, OP_OpenRead, iTab, pIdx->tnum, iDb);\n            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n            VdbeComment((v, \"%s\", pIdx->zName));\n            assert( IN_INDEX_INDEX_DESC == IN_INDEX_INDEX_ASC+1 );\n            eType = IN_INDEX_INDEX_ASC + pIdx->aSortOrder[0];\n  \n            if( prRhsHasNull ){\n#ifdef SQLITE_ENABLE_COLUMN_USED_MASK\n              i64 mask = (1<<nExpr)-1;\n              sqlite3VdbeAddOp4Dup8(v, OP_ColumnsUsed, \n                  iTab, 0, 0, (u8*)&mask, P4_INT64);\n#endif\n              *prRhsHasNull = ++pParse->nMem;\n              if( nExpr==1 ){\n                sqlite3SetHasNullFlag(v, iTab, *prRhsHasNull);\n              }\n            }\n            sqlite3VdbeJumpHere(v, iAddr);\n          }\n        } /* End loop over indexes */\n      } /* End if( affinity_ok ) */\n    } /* End if not an rowid index */\n  } /* End attempt to optimize using an index */\n\n  /* If no preexisting index is available for the IN clause\n  ** and IN_INDEX_NOOP is an allowed reply\n  ** and the RHS of the IN operator is a list, not a subquery\n  ** and the RHS is not constant or has two or fewer terms,\n  ** then it is not worth creating an ephemeral table to evaluate\n  ** the IN operator so return IN_INDEX_NOOP.\n  */\n  if( eType==0\n   && (inFlags & IN_INDEX_NOOP_OK)\n   && !ExprHasProperty(pX, EP_xIsSelect)\n   && (!sqlite3InRhsIsConstant(pX) || pX->x.pList->nExpr<=2)\n  ){\n    eType = IN_INDEX_NOOP;\n  }\n\n  if( eType==0 ){\n    /* Could not find an existing table or index to use as the RHS b-tree.\n    ** We will have to generate an ephemeral table to do the job.\n    */\n    u32 savedNQueryLoop = pParse->nQueryLoop;\n    int rMayHaveNull = 0;\n    eType = IN_INDEX_EPH;\n    if( inFlags & IN_INDEX_LOOP ){\n      pParse->nQueryLoop = 0;\n    }else if( prRhsHasNull ){\n      *prRhsHasNull = rMayHaveNull = ++pParse->nMem;\n    }\n    assert( pX->op==TK_IN );\n    sqlite3CodeRhsOfIN(pParse, pX, iTab);\n    if( rMayHaveNull ){\n      sqlite3SetHasNullFlag(v, iTab, rMayHaveNull);\n    }\n    pParse->nQueryLoop = savedNQueryLoop;\n  }\n\n  if( aiMap && eType!=IN_INDEX_INDEX_ASC && eType!=IN_INDEX_INDEX_DESC ){\n    int i, n;\n    n = sqlite3ExprVectorSize(pX->pLeft);\n    for(i=0; i<n; i++) aiMap[i] = i;\n  }\n  *piTab = iTab;\n  return eType;\n}\n#endif\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Argument pExpr is an (?, ?...) IN(...) expression. This \n** function allocates and returns a nul-terminated string containing \n** the affinities to be used for each column of the comparison.\n**\n** It is the responsibility of the caller to ensure that the returned\n** string is eventually freed using sqlite3DbFree().\n*/\nstatic char *exprINAffinity(Parse *pParse, Expr *pExpr){\n  Expr *pLeft = pExpr->pLeft;\n  int nVal = sqlite3ExprVectorSize(pLeft);\n  Select *pSelect = (pExpr->flags & EP_xIsSelect) ? pExpr->x.pSelect : 0;\n  char *zRet;\n\n  assert( pExpr->op==TK_IN );\n  zRet = sqlite3DbMallocRaw(pParse->db, nVal+1);\n  if( zRet ){\n    int i;\n    for(i=0; i<nVal; i++){\n      Expr *pA = sqlite3VectorFieldSubexpr(pLeft, i);\n      char a = sqlite3ExprAffinity(pA);\n      if( pSelect ){\n        zRet[i] = sqlite3CompareAffinity(pSelect->pEList->a[i].pExpr, a);\n      }else{\n        zRet[i] = a;\n      }\n    }\n    zRet[nVal] = '\\0';\n  }\n  return zRet;\n}\n#endif\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Load the Parse object passed as the first argument with an error \n** message of the form:\n**\n**   \"sub-select returns N columns - expected M\"\n*/   \nvoid sqlite3SubselectError(Parse *pParse, int nActual, int nExpect){\n  const char *zFmt = \"sub-select returns %d columns - expected %d\";\n  sqlite3ErrorMsg(pParse, zFmt, nActual, nExpect);\n}\n#endif\n\n/*\n** Expression pExpr is a vector that has been used in a context where\n** it is not permitted. If pExpr is a sub-select vector, this routine \n** loads the Parse object with a message of the form:\n**\n**   \"sub-select returns N columns - expected 1\"\n**\n** Or, if it is a regular scalar vector:\n**\n**   \"row value misused\"\n*/   \nvoid sqlite3VectorErrorMsg(Parse *pParse, Expr *pExpr){\n#ifndef SQLITE_OMIT_SUBQUERY\n  if( pExpr->flags & EP_xIsSelect ){\n    sqlite3SubselectError(pParse, pExpr->x.pSelect->pEList->nExpr, 1);\n  }else\n#endif\n  {\n    sqlite3ErrorMsg(pParse, \"row value misused\");\n  }\n}\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Generate code that will construct an ephemeral table containing all terms\n** in the RHS of an IN operator.  The IN operator can be in either of two\n** forms:\n**\n**     x IN (4,5,11)              -- IN operator with list on right-hand side\n**     x IN (SELECT a FROM b)     -- IN operator with subquery on the right\n**\n** The pExpr parameter is the IN operator.  The cursor number for the\n** constructed ephermeral table is returned.  The first time the ephemeral\n** table is computed, the cursor number is also stored in pExpr->iTable,\n** however the cursor number returned might not be the same, as it might\n** have been duplicated using OP_OpenDup.\n**\n** If the LHS expression (\"x\" in the examples) is a column value, or\n** the SELECT statement returns a column value, then the affinity of that\n** column is used to build the index keys. If both 'x' and the\n** SELECT... statement are columns, then numeric affinity is used\n** if either column has NUMERIC or INTEGER affinity. If neither\n** 'x' nor the SELECT... statement are columns, then numeric affinity\n** is used.\n*/\nvoid sqlite3CodeRhsOfIN(\n  Parse *pParse,          /* Parsing context */\n  Expr *pExpr,            /* The IN operator */\n  int iTab                /* Use this cursor number */\n){\n  int addrOnce = 0;           /* Address of the OP_Once instruction at top */\n  int addr;                   /* Address of OP_OpenEphemeral instruction */\n  Expr *pLeft;                /* the LHS of the IN operator */\n  KeyInfo *pKeyInfo = 0;      /* Key information */\n  int nVal;                   /* Size of vector pLeft */\n  Vdbe *v;                    /* The prepared statement under construction */\n\n  v = pParse->pVdbe;\n  assert( v!=0 );\n\n  /* The evaluation of the IN must be repeated every time it\n  ** is encountered if any of the following is true:\n  **\n  **    *  The right-hand side is a correlated subquery\n  **    *  The right-hand side is an expression list containing variables\n  **    *  We are inside a trigger\n  **\n  ** If all of the above are false, then we can compute the RHS just once\n  ** and reuse it many names.\n  */\n  if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){\n    /* Reuse of the RHS is allowed */\n    /* If this routine has already been coded, but the previous code\n    ** might not have been invoked yet, so invoke it now as a subroutine. \n    */\n    if( ExprHasProperty(pExpr, EP_Subrtn) ){\n      addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n      if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n        ExplainQueryPlan((pParse, 0, \"REUSE LIST SUBQUERY %d\",\n              pExpr->x.pSelect->selId));\n      }\n      sqlite3VdbeAddOp2(v, OP_Gosub, pExpr->y.sub.regReturn,\n                        pExpr->y.sub.iAddr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, iTab, pExpr->iTable);\n      sqlite3VdbeJumpHere(v, addrOnce);\n      return;\n    }\n\n    /* Begin coding the subroutine */\n    ExprSetProperty(pExpr, EP_Subrtn);\n    pExpr->y.sub.regReturn = ++pParse->nMem;\n    pExpr->y.sub.iAddr =\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr->y.sub.regReturn) + 1;\n    VdbeComment((v, \"return address\"));\n\n    addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n  }\n\n  /* Check to see if this is a vector IN operator */\n  pLeft = pExpr->pLeft;\n  nVal = sqlite3ExprVectorSize(pLeft);\n\n  /* Construct the ephemeral table that will contain the content of\n  ** RHS of the IN operator.\n  */\n  pExpr->iTable = iTab;\n  addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pExpr->iTable, nVal);\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n  if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n    VdbeComment((v, \"Result of SELECT %u\", pExpr->x.pSelect->selId));\n  }else{\n    VdbeComment((v, \"RHS of IN operator\"));\n  }\n#endif\n  pKeyInfo = sqlite3KeyInfoAlloc(pParse->db, nVal, 1);\n\n  if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n    /* Case 1:     expr IN (SELECT ...)\n    **\n    ** Generate code to write the results of the select into the temporary\n    ** table allocated and opened above.\n    */\n    Select *pSelect = pExpr->x.pSelect;\n    ExprList *pEList = pSelect->pEList;\n\n    ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY %d\",\n        addrOnce?\"\":\"CORRELATED \", pSelect->selId\n    ));\n    /* If the LHS and RHS of the IN operator do not match, that\n    ** error will have been caught long before we reach this point. */\n    if( ALWAYS(pEList->nExpr==nVal) ){\n      SelectDest dest;\n      int i;\n      sqlite3SelectDestInit(&dest, SRT_Set, iTab);\n      dest.zAffSdst = exprINAffinity(pParse, pExpr);\n      pSelect->iLimit = 0;\n      testcase( pSelect->selFlags & SF_Distinct );\n      testcase( pKeyInfo==0 ); /* Caused by OOM in sqlite3KeyInfoAlloc() */\n      if( sqlite3Select(pParse, pSelect, &dest) ){\n        sqlite3DbFree(pParse->db, dest.zAffSdst);\n        sqlite3KeyInfoUnref(pKeyInfo);\n        return;\n      }\n      sqlite3DbFree(pParse->db, dest.zAffSdst);\n      assert( pKeyInfo!=0 ); /* OOM will cause exit after sqlite3Select() */\n      assert( pEList!=0 );\n      assert( pEList->nExpr>0 );\n      assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );\n      for(i=0; i<nVal; i++){\n        Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);\n        pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(\n            pParse, p, pEList->a[i].pExpr\n        );\n      }\n    }\n  }else if( ALWAYS(pExpr->x.pList!=0) ){\n    /* Case 2:     expr IN (exprlist)\n    **\n    ** For each expression, build an index key from the evaluation and\n    ** store it in the temporary table. If <expr> is a column, then use\n    ** that columns affinity when building index keys. If <expr> is not\n    ** a column, use numeric affinity.\n    */\n    char affinity;            /* Affinity of the LHS of the IN */\n    int i;\n    ExprList *pList = pExpr->x.pList;\n    struct ExprList_item *pItem;\n    int r1, r2;\n    affinity = sqlite3ExprAffinity(pLeft);\n    if( affinity<=SQLITE_AFF_NONE ){\n      affinity = SQLITE_AFF_BLOB;\n    }\n    if( pKeyInfo ){\n      assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );\n      pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n    }\n\n    /* Loop through each expression in <exprlist>. */\n    r1 = sqlite3GetTempReg(pParse);\n    r2 = sqlite3GetTempReg(pParse);\n    for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){\n      Expr *pE2 = pItem->pExpr;\n\n      /* If the expression is not constant then we will need to\n      ** disable the test that was generated above that makes sure\n      ** this code only executes once.  Because for a non-constant\n      ** expression we need to rerun this code each time.\n      */\n      if( addrOnce && !sqlite3ExprIsConstant(pE2) ){\n        sqlite3VdbeChangeToNoop(v, addrOnce);\n        ExprClearProperty(pExpr, EP_Subrtn);\n        addrOnce = 0;\n      }\n\n      /* Evaluate the expression and insert it into the temp table */\n      sqlite3ExprCode(pParse, pE2, r1);\n      sqlite3VdbeAddOp4(v, OP_MakeRecord, r1, 1, r2, &affinity, 1);\n      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r2, r1, 1);\n    }\n    sqlite3ReleaseTempReg(pParse, r1);\n    sqlite3ReleaseTempReg(pParse, r2);\n  }\n  if( pKeyInfo ){\n    sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);\n  }\n  if( addrOnce ){\n    sqlite3VdbeJumpHere(v, addrOnce);\n    /* Subroutine return */\n    sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);\n    sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);\n    sqlite3ClearTempRegCache(pParse);\n  }\n}\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n/*\n** Generate code for scalar subqueries used as a subquery expression\n** or EXISTS operator:\n**\n**     (SELECT a FROM b)          -- subquery\n**     EXISTS (SELECT a FROM b)   -- EXISTS subquery\n**\n** The pExpr parameter is the SELECT or EXISTS operator to be coded.\n**\n** Return the register that holds the result.  For a multi-column SELECT, \n** the result is stored in a contiguous array of registers and the\n** return value is the register of the left-most result column.\n** Return 0 if an error occurs.\n*/\n#ifndef SQLITE_OMIT_SUBQUERY\nint sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){\n  int addrOnce = 0;           /* Address of OP_Once at top of subroutine */\n  int rReg = 0;               /* Register storing resulting */\n  Select *pSel;               /* SELECT statement to encode */\n  SelectDest dest;            /* How to deal with SELECT result */\n  int nReg;                   /* Registers to allocate */\n  Expr *pLimit;               /* New limit expression */\n\n  Vdbe *v = pParse->pVdbe;\n  assert( v!=0 );\n  testcase( pExpr->op==TK_EXISTS );\n  testcase( pExpr->op==TK_SELECT );\n  assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );\n  assert( ExprHasProperty(pExpr, EP_xIsSelect) );\n  pSel = pExpr->x.pSelect;\n\n  /* The evaluation of the EXISTS/SELECT must be repeated every time it\n  ** is encountered if any of the following is true:\n  **\n  **    *  The right-hand side is a correlated subquery\n  **    *  The right-hand side is an expression list containing variables\n  **    *  We are inside a trigger\n  **\n  ** If all of the above are false, then we can run this code just once\n  ** save the results, and reuse the same result on subsequent invocations.\n  */\n  if( !ExprHasProperty(pExpr, EP_VarSelect) ){\n    /* If this routine has already been coded, then invoke it as a\n    ** subroutine. */\n    if( ExprHasProperty(pExpr, EP_Subrtn) ){\n      ExplainQueryPlan((pParse, 0, \"REUSE SUBQUERY %d\", pSel->selId));\n      sqlite3VdbeAddOp2(v, OP_Gosub, pExpr->y.sub.regReturn,\n                        pExpr->y.sub.iAddr);\n      return pExpr->iTable;\n    }\n\n    /* Begin coding the subroutine */\n    ExprSetProperty(pExpr, EP_Subrtn);\n    pExpr->y.sub.regReturn = ++pParse->nMem;\n    pExpr->y.sub.iAddr =\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr->y.sub.regReturn) + 1;\n    VdbeComment((v, \"return address\"));\n\n    addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n  }\n  \n  /* For a SELECT, generate code to put the values for all columns of\n  ** the first row into an array of registers and return the index of\n  ** the first register.\n  **\n  ** If this is an EXISTS, write an integer 0 (not exists) or 1 (exists)\n  ** into a register and return that register number.\n  **\n  ** In both cases, the query is augmented with \"LIMIT 1\".  Any \n  ** preexisting limit is discarded in place of the new LIMIT 1.\n  */\n  ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY %d\",\n        addrOnce?\"\":\"CORRELATED \", pSel->selId));\n  nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;\n  sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);\n  pParse->nMem += nReg;\n  if( pExpr->op==TK_SELECT ){\n    dest.eDest = SRT_Mem;\n    dest.iSdst = dest.iSDParm;\n    dest.nSdst = nReg;\n    sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);\n    VdbeComment((v, \"Init subquery result\"));\n  }else{\n    dest.eDest = SRT_Exists;\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);\n    VdbeComment((v, \"Init EXISTS result\"));\n  }\n  if( pSel->pLimit ){\n    /* The subquery already has a limit.  If the pre-existing limit is X\n    ** then make the new limit X<>0 so that the new limit is either 1 or 0 */\n    sqlite3 *db = pParse->db;\n    pLimit = sqlite3Expr(db, TK_INTEGER, \"0\");\n    if( pLimit ){\n      pLimit->affExpr = SQLITE_AFF_NUMERIC;\n      pLimit = sqlite3PExpr(pParse, TK_NE,\n                            sqlite3ExprDup(db, pSel->pLimit->pLeft, 0), pLimit);\n    }\n    sqlite3ExprDelete(db, pSel->pLimit->pLeft);\n    pSel->pLimit->pLeft = pLimit;\n  }else{\n    /* If there is no pre-existing limit add a limit of 1 */\n    pLimit = sqlite3Expr(pParse->db, TK_INTEGER, \"1\");\n    pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);\n  }\n  pSel->iLimit = 0;\n  if( sqlite3Select(pParse, pSel, &dest) ){\n    return 0;\n  }\n  pExpr->iTable = rReg = dest.iSDParm;\n  ExprSetVVAProperty(pExpr, EP_NoReduce);\n  if( addrOnce ){\n    sqlite3VdbeJumpHere(v, addrOnce);\n\n    /* Subroutine return */\n    sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);\n    sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);\n    sqlite3ClearTempRegCache(pParse);\n  }\n\n  return rReg;\n}\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Expr pIn is an IN(...) expression. This function checks that the \n** sub-select on the RHS of the IN() operator has the same number of \n** columns as the vector on the LHS. Or, if the RHS of the IN() is not \n** a sub-query, that the LHS is a vector of size 1.\n*/\nint sqlite3ExprCheckIN(Parse *pParse, Expr *pIn){\n  int nVector = sqlite3ExprVectorSize(pIn->pLeft);\n  if( (pIn->flags & EP_xIsSelect) ){\n    if( nVector!=pIn->x.pSelect->pEList->nExpr ){\n      sqlite3SubselectError(pParse, pIn->x.pSelect->pEList->nExpr, nVector);\n      return 1;\n    }\n  }else if( nVector!=1 ){\n    sqlite3VectorErrorMsg(pParse, pIn->pLeft);\n    return 1;\n  }\n  return 0;\n}\n#endif\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Generate code for an IN expression.\n**\n**      x IN (SELECT ...)\n**      x IN (value, value, ...)\n**\n** The left-hand side (LHS) is a scalar or vector expression.  The \n** right-hand side (RHS) is an array of zero or more scalar values, or a\n** subquery.  If the RHS is a subquery, the number of result columns must\n** match the number of columns in the vector on the LHS.  If the RHS is\n** a list of values, the LHS must be a scalar. \n**\n** The IN operator is true if the LHS value is contained within the RHS.\n** The result is false if the LHS is definitely not in the RHS.  The \n** result is NULL if the presence of the LHS in the RHS cannot be \n** determined due to NULLs.\n**\n** This routine generates code that jumps to destIfFalse if the LHS is not \n** contained within the RHS.  If due to NULLs we cannot determine if the LHS\n** is contained in the RHS then jump to destIfNull.  If the LHS is contained\n** within the RHS then fall through.\n**\n** See the separate in-operator.md documentation file in the canonical\n** SQLite source tree for additional information.\n*/\nstatic void sqlite3ExprCodeIN(\n  Parse *pParse,        /* Parsing and code generating context */\n  Expr *pExpr,          /* The IN expression */\n  int destIfFalse,      /* Jump here if LHS is not contained in the RHS */\n  int destIfNull        /* Jump here if the results are unknown due to NULLs */\n){\n  int rRhsHasNull = 0;  /* Register that is true if RHS contains NULL values */\n  int eType;            /* Type of the RHS */\n  int rLhs;             /* Register(s) holding the LHS values */\n  int rLhsOrig;         /* LHS values prior to reordering by aiMap[] */\n  Vdbe *v;              /* Statement under construction */\n  int *aiMap = 0;       /* Map from vector field to index column */\n  char *zAff = 0;       /* Affinity string for comparisons */\n  int nVector;          /* Size of vectors for this IN operator */\n  int iDummy;           /* Dummy parameter to exprCodeVector() */\n  Expr *pLeft;          /* The LHS of the IN operator */\n  int i;                /* loop counter */\n  int destStep2;        /* Where to jump when NULLs seen in step 2 */\n  int destStep6 = 0;    /* Start of code for Step 6 */\n  int addrTruthOp;      /* Address of opcode that determines the IN is true */\n  int destNotNull;      /* Jump here if a comparison is not true in step 6 */\n  int addrTop;          /* Top of the step-6 loop */ \n  int iTab = 0;         /* Index to use */\n\n  pLeft = pExpr->pLeft;\n  if( sqlite3ExprCheckIN(pParse, pExpr) ) return;\n  zAff = exprINAffinity(pParse, pExpr);\n  nVector = sqlite3ExprVectorSize(pExpr->pLeft);\n  aiMap = (int*)sqlite3DbMallocZero(\n      pParse->db, nVector*(sizeof(int) + sizeof(char)) + 1\n  );\n  if( pParse->db->mallocFailed ) goto sqlite3ExprCodeIN_oom_error;\n\n  /* Attempt to compute the RHS. After this step, if anything other than\n  ** IN_INDEX_NOOP is returned, the table opened with cursor iTab\n  ** contains the values that make up the RHS. If IN_INDEX_NOOP is returned,\n  ** the RHS has not yet been coded.  */\n  v = pParse->pVdbe;\n  assert( v!=0 );       /* OOM detected prior to this routine */\n  VdbeNoopComment((v, \"begin IN expr\"));\n  eType = sqlite3FindInIndex(pParse, pExpr,\n                             IN_INDEX_MEMBERSHIP | IN_INDEX_NOOP_OK,\n                             destIfFalse==destIfNull ? 0 : &rRhsHasNull,\n                             aiMap, &iTab);\n\n  assert( pParse->nErr || nVector==1 || eType==IN_INDEX_EPH\n       || eType==IN_INDEX_INDEX_ASC || eType==IN_INDEX_INDEX_DESC \n  );\n#ifdef SQLITE_DEBUG\n  /* Confirm that aiMap[] contains nVector integer values between 0 and\n  ** nVector-1. */\n  for(i=0; i<nVector; i++){\n    int j, cnt;\n    for(cnt=j=0; j<nVector; j++) if( aiMap[j]==i ) cnt++;\n    assert( cnt==1 );\n  }\n#endif\n\n  /* Code the LHS, the <expr> from \"<expr> IN (...)\". If the LHS is a \n  ** vector, then it is stored in an array of nVector registers starting \n  ** at r1.\n  **\n  ** sqlite3FindInIndex() might have reordered the fields of the LHS vector\n  ** so that the fields are in the same order as an existing index.   The\n  ** aiMap[] array contains a mapping from the original LHS field order to\n  ** the field order that matches the RHS index.\n  */\n  rLhsOrig = exprCodeVector(pParse, pLeft, &iDummy);\n  for(i=0; i<nVector && aiMap[i]==i; i++){} /* Are LHS fields reordered? */\n  if( i==nVector ){\n    /* LHS fields are not reordered */\n    rLhs = rLhsOrig;\n  }else{\n    /* Need to reorder the LHS fields according to aiMap */\n    rLhs = sqlite3GetTempRange(pParse, nVector);\n    for(i=0; i<nVector; i++){\n      sqlite3VdbeAddOp3(v, OP_Copy, rLhsOrig+i, rLhs+aiMap[i], 0);\n    }\n  }\n\n  /* If sqlite3FindInIndex() did not find or create an index that is\n  ** suitable for evaluating the IN operator, then evaluate using a\n  ** sequence of comparisons.\n  **\n  ** This is step (1) in the in-operator.md optimized algorithm.\n  */\n  if( eType==IN_INDEX_NOOP ){\n    ExprList *pList = pExpr->x.pList;\n    CollSeq *pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n    int labelOk = sqlite3VdbeMakeLabel(pParse);\n    int r2, regToFree;\n    int regCkNull = 0;\n    int ii;\n    int bLhsReal;  /* True if the LHS of the IN has REAL affinity */\n    assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n    if( destIfNull!=destIfFalse ){\n      regCkNull = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp3(v, OP_BitAnd, rLhs, rLhs, regCkNull);\n    }\n    bLhsReal = sqlite3ExprAffinity(pExpr->pLeft)==SQLITE_AFF_REAL;\n    for(ii=0; ii<pList->nExpr; ii++){\n      if( bLhsReal ){\n        r2 = regToFree = sqlite3GetTempReg(pParse);\n        sqlite3ExprCode(pParse, pList->a[ii].pExpr, r2);\n        sqlite3VdbeAddOp4(v, OP_Affinity, r2, 1, 0, \"E\", P4_STATIC);\n      }else{\n        r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);\n      }\n      if( regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr) ){\n        sqlite3VdbeAddOp3(v, OP_BitAnd, regCkNull, r2, regCkNull);\n      }\n      if( ii<pList->nExpr-1 || destIfNull!=destIfFalse ){\n        sqlite3VdbeAddOp4(v, OP_Eq, rLhs, labelOk, r2,\n                          (void*)pColl, P4_COLLSEQ);\n        VdbeCoverageIf(v, ii<pList->nExpr-1);\n        VdbeCoverageIf(v, ii==pList->nExpr-1);\n        sqlite3VdbeChangeP5(v, zAff[0]);\n      }else{\n        assert( destIfNull==destIfFalse );\n        sqlite3VdbeAddOp4(v, OP_Ne, rLhs, destIfFalse, r2,\n                          (void*)pColl, P4_COLLSEQ); VdbeCoverage(v);\n        sqlite3VdbeChangeP5(v, zAff[0] | SQLITE_JUMPIFNULL);\n      }\n      sqlite3ReleaseTempReg(pParse, regToFree);\n    }\n    if( regCkNull ){\n      sqlite3VdbeAddOp2(v, OP_IsNull, regCkNull, destIfNull); VdbeCoverage(v);\n      sqlite3VdbeGoto(v, destIfFalse);\n    }\n    sqlite3VdbeResolveLabel(v, labelOk);\n    sqlite3ReleaseTempReg(pParse, regCkNull);\n    goto sqlite3ExprCodeIN_finished;\n  }\n\n  /* Step 2: Check to see if the LHS contains any NULL columns.  If the\n  ** LHS does contain NULLs then the result must be either FALSE or NULL.\n  ** We will then skip the binary search of the RHS.\n  */\n  if( destIfNull==destIfFalse ){\n    destStep2 = destIfFalse;\n  }else{\n    destStep2 = destStep6 = sqlite3VdbeMakeLabel(pParse);\n  }\n  for(i=0; i<nVector; i++){\n    Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);\n    if( sqlite3ExprCanBeNull(p) ){\n      sqlite3VdbeAddOp2(v, OP_IsNull, rLhs+i, destStep2);\n      VdbeCoverage(v);\n    }\n  }\n\n  /* Step 3.  The LHS is now known to be non-NULL.  Do the binary search\n  ** of the RHS using the LHS as a probe.  If found, the result is\n  ** true.\n  */\n  if( eType==IN_INDEX_ROWID ){\n    /* In this case, the RHS is the ROWID of table b-tree and so we also\n    ** know that the RHS is non-NULL.  Hence, we combine steps 3 and 4\n    ** into a single opcode. */\n    sqlite3VdbeAddOp3(v, OP_SeekRowid, iTab, destIfFalse, rLhs);\n    VdbeCoverage(v);\n    addrTruthOp = sqlite3VdbeAddOp0(v, OP_Goto);  /* Return True */\n  }else{\n    sqlite3VdbeAddOp4(v, OP_Affinity, rLhs, nVector, 0, zAff, nVector);\n    if( destIfFalse==destIfNull ){\n      /* Combine Step 3 and Step 5 into a single opcode */\n      sqlite3VdbeAddOp4Int(v, OP_NotFound, iTab, destIfFalse,\n                           rLhs, nVector); VdbeCoverage(v);\n      goto sqlite3ExprCodeIN_finished;\n    }\n    /* Ordinary Step 3, for the case where FALSE and NULL are distinct */\n    addrTruthOp = sqlite3VdbeAddOp4Int(v, OP_Found, iTab, 0,\n                                      rLhs, nVector); VdbeCoverage(v);\n  }\n\n  /* Step 4.  If the RHS is known to be non-NULL and we did not find\n  ** an match on the search above, then the result must be FALSE.\n  */\n  if( rRhsHasNull && nVector==1 ){\n    sqlite3VdbeAddOp2(v, OP_NotNull, rRhsHasNull, destIfFalse);\n    VdbeCoverage(v);\n  }\n\n  /* Step 5.  If we do not care about the difference between NULL and\n  ** FALSE, then just return false. \n  */\n  if( destIfFalse==destIfNull ) sqlite3VdbeGoto(v, destIfFalse);\n\n  /* Step 6: Loop through rows of the RHS.  Compare each row to the LHS.\n  ** If any comparison is NULL, then the result is NULL.  If all\n  ** comparisons are FALSE then the final result is FALSE.\n  **\n  ** For a scalar LHS, it is sufficient to check just the first row\n  ** of the RHS.\n  */\n  if( destStep6 ) sqlite3VdbeResolveLabel(v, destStep6);\n  addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, destIfFalse);\n  VdbeCoverage(v);\n  if( nVector>1 ){\n    destNotNull = sqlite3VdbeMakeLabel(pParse);\n  }else{\n    /* For nVector==1, combine steps 6 and 7 by immediately returning\n    ** FALSE if the first comparison is not NULL */\n    destNotNull = destIfFalse;\n  }\n  for(i=0; i<nVector; i++){\n    Expr *p;\n    CollSeq *pColl;\n    int r3 = sqlite3GetTempReg(pParse);\n    p = sqlite3VectorFieldSubexpr(pLeft, i);\n    pColl = sqlite3ExprCollSeq(pParse, p);\n    sqlite3VdbeAddOp3(v, OP_Column, iTab, i, r3);\n    sqlite3VdbeAddOp4(v, OP_Ne, rLhs+i, destNotNull, r3,\n                      (void*)pColl, P4_COLLSEQ);\n    VdbeCoverage(v);\n    sqlite3ReleaseTempReg(pParse, r3);\n  }\n  sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfNull);\n  if( nVector>1 ){\n    sqlite3VdbeResolveLabel(v, destNotNull);\n    sqlite3VdbeAddOp2(v, OP_Next, iTab, addrTop+1);\n    VdbeCoverage(v);\n\n    /* Step 7:  If we reach this point, we know that the result must\n    ** be false. */\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfFalse);\n  }\n\n  /* Jumps here in order to return true. */\n  sqlite3VdbeJumpHere(v, addrTruthOp);\n\nsqlite3ExprCodeIN_finished:\n  if( rLhs!=rLhsOrig ) sqlite3ReleaseTempReg(pParse, rLhs);\n  VdbeComment((v, \"end IN expr\"));\nsqlite3ExprCodeIN_oom_error:\n  sqlite3DbFree(pParse->db, aiMap);\n  sqlite3DbFree(pParse->db, zAff);\n}\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n/*\n** Generate an instruction that will put the floating point\n** value described by z[0..n-1] into register iMem.\n**\n** The z[] string will probably not be zero-terminated.  But the \n** z[n] character is guaranteed to be something that does not look\n** like the continuation of the number.\n*/\nstatic void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem){\n  if( ALWAYS(z!=0) ){\n    double value;\n    sqlite3AtoF(z, &value, sqlite3Strlen30(z), SQLITE_UTF8);\n    assert( !sqlite3IsNaN(value) ); /* The new AtoF never returns NaN */\n    if( negateFlag ) value = -value;\n    sqlite3VdbeAddOp4Dup8(v, OP_Real, 0, iMem, 0, (u8*)&value, P4_REAL);\n  }\n}\n#endif\n\n\n/*\n** Generate an instruction that will put the integer describe by\n** text z[0..n-1] into register iMem.\n**\n** Expr.u.zToken is always UTF8 and zero-terminated.\n*/\nstatic void codeInteger(Parse *pParse, Expr *pExpr, int negFlag, int iMem){\n  Vdbe *v = pParse->pVdbe;\n  if( pExpr->flags & EP_IntValue ){\n    int i = pExpr->u.iValue;\n    assert( i>=0 );\n    if( negFlag ) i = -i;\n    sqlite3VdbeAddOp2(v, OP_Integer, i, iMem);\n  }else{\n    int c;\n    i64 value;\n    const char *z = pExpr->u.zToken;\n    assert( z!=0 );\n    c = sqlite3DecOrHexToI64(z, &value);\n    if( (c==3 && !negFlag) || (c==2) || (negFlag && value==SMALLEST_INT64)){\n#ifdef SQLITE_OMIT_FLOATING_POINT\n      sqlite3ErrorMsg(pParse, \"oversized integer: %s%s\", negFlag ? \"-\" : \"\", z);\n#else\n#ifndef SQLITE_OMIT_HEX_INTEGER\n      if( sqlite3_strnicmp(z,\"0x\",2)==0 ){\n        sqlite3ErrorMsg(pParse, \"hex literal too big: %s%s\", negFlag?\"-\":\"\",z);\n      }else\n#endif\n      {\n        codeReal(v, z, negFlag, iMem);\n      }\n#endif\n    }else{\n      if( negFlag ){ value = c==3 ? SMALLEST_INT64 : -value; }\n      sqlite3VdbeAddOp4Dup8(v, OP_Int64, 0, iMem, 0, (u8*)&value, P4_INT64);\n    }\n  }\n}\n\n\n/* Generate code that will load into register regOut a value that is\n** appropriate for the iIdxCol-th column of index pIdx.\n*/\nvoid sqlite3ExprCodeLoadIndexColumn(\n  Parse *pParse,  /* The parsing context */\n  Index *pIdx,    /* The index whose column is to be loaded */\n  int iTabCur,    /* Cursor pointing to a table row */\n  int iIdxCol,    /* The column of the index to be loaded */\n  int regOut      /* Store the index column value in this register */\n){\n  i16 iTabCol = pIdx->aiColumn[iIdxCol];\n  if( iTabCol==XN_EXPR ){\n    assert( pIdx->aColExpr );\n    assert( pIdx->aColExpr->nExpr>iIdxCol );\n    pParse->iSelfTab = iTabCur + 1;\n    sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[iIdxCol].pExpr, regOut);\n    pParse->iSelfTab = 0;\n  }else{\n    sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pIdx->pTable, iTabCur,\n                                    iTabCol, regOut);\n  }\n}\n\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n/*\n** Generate code that will compute the value of generated column pCol\n** and store the result in register regOut\n*/\nvoid sqlite3ExprCodeGeneratedColumn(\n  Parse *pParse,\n  Column *pCol,\n  int regOut\n){\n  int iAddr;\n  Vdbe *v = pParse->pVdbe;\n  assert( v!=0 );\n  assert( pParse->iSelfTab!=0 );\n  if( pParse->iSelfTab>0 ){\n    iAddr = sqlite3VdbeAddOp3(v, OP_IfNullRow, pParse->iSelfTab-1, 0, regOut);\n  }else{\n    iAddr = 0;\n  }\n  sqlite3ExprCode(pParse, pCol->pDflt, regOut);\n  if( pCol->affinity>=SQLITE_AFF_TEXT ){\n    sqlite3VdbeAddOp4(v, OP_Affinity, regOut, 1, 0, &pCol->affinity, 1);\n  }\n  if( iAddr ) sqlite3VdbeJumpHere(v, iAddr);\n}\n#endif /* SQLITE_OMIT_GENERATED_COLUMNS */\n\n/*\n** Generate code to extract the value of the iCol-th column of a table.\n*/\nvoid sqlite3ExprCodeGetColumnOfTable(\n  Vdbe *v,        /* Parsing context */\n  Table *pTab,    /* The table containing the value */\n  int iTabCur,    /* The table cursor.  Or the PK cursor for WITHOUT ROWID */\n  int iCol,       /* Index of the column to extract */\n  int regOut      /* Extract the value into this register */\n){\n  Column *pCol;\n  assert( v!=0 );\n  if( pTab==0 ){\n    sqlite3VdbeAddOp3(v, OP_Column, iTabCur, iCol, regOut);\n    return;\n  }\n  if( iCol<0 || iCol==pTab->iPKey ){\n    sqlite3VdbeAddOp2(v, OP_Rowid, iTabCur, regOut);\n  }else{\n    int op;\n    int x;\n    if( IsVirtual(pTab) ){\n      op = OP_VColumn;\n      x = iCol;\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n    }else if( (pCol = &pTab->aCol[iCol])->colFlags & COLFLAG_VIRTUAL ){\n      Parse *pParse = sqlite3VdbeParser(v);\n      if( pCol->colFlags & COLFLAG_BUSY ){\n        sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pCol->zName);\n      }else{\n        int savedSelfTab = pParse->iSelfTab;\n        pCol->colFlags |= COLFLAG_BUSY;\n        pParse->iSelfTab = iTabCur+1;\n        sqlite3ExprCodeGeneratedColumn(pParse, pCol, regOut);\n        pParse->iSelfTab = savedSelfTab;\n        pCol->colFlags &= ~COLFLAG_BUSY;\n      }\n      return;\n#endif\n    }else if( !HasRowid(pTab) ){\n      testcase( iCol!=sqlite3TableColumnToStorage(pTab, iCol) );\n      x = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), iCol);\n      op = OP_Column;\n    }else{\n      x = sqlite3TableColumnToStorage(pTab,iCol);\n      testcase( x!=iCol );\n      op = OP_Column;\n    }\n    sqlite3VdbeAddOp3(v, op, iTabCur, x, regOut);\n    sqlite3ColumnDefault(v, pTab, iCol, regOut);\n  }\n}\n\n/*\n** Generate code that will extract the iColumn-th column from\n** table pTab and store the column value in register iReg. \n**\n** There must be an open cursor to pTab in iTable when this routine\n** is called.  If iColumn<0 then code is generated that extracts the rowid.\n*/\nint sqlite3ExprCodeGetColumn(\n  Parse *pParse,   /* Parsing and code generating context */\n  Table *pTab,     /* Description of the table we are reading from */\n  int iColumn,     /* Index of the table column */\n  int iTable,      /* The cursor pointing to the table */\n  int iReg,        /* Store results here */\n  u8 p5            /* P5 value for OP_Column + FLAGS */\n){\n  assert( pParse->pVdbe!=0 );\n  sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pTab, iTable, iColumn, iReg);\n  if( p5 ){\n    VdbeOp *pOp = sqlite3VdbeGetOp(pParse->pVdbe,-1);\n    if( pOp->opcode==OP_Column ) pOp->p5 = p5;\n  }\n  return iReg;\n}\n\n/*\n** Generate code to move content from registers iFrom...iFrom+nReg-1\n** over to iTo..iTo+nReg-1.\n*/\nvoid sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg){\n  sqlite3VdbeAddOp3(pParse->pVdbe, OP_Move, iFrom, iTo, nReg);\n}\n\n/*\n** Convert a scalar expression node to a TK_REGISTER referencing\n** register iReg.  The caller must ensure that iReg already contains\n** the correct value for the expression.\n*/\nstatic void exprToRegister(Expr *pExpr, int iReg){\n  Expr *p = sqlite3ExprSkipCollateAndLikely(pExpr);\n  p->op2 = p->op;\n  p->op = TK_REGISTER;\n  p->iTable = iReg;\n  ExprClearProperty(p, EP_Skip);\n}\n\n/*\n** Evaluate an expression (either a vector or a scalar expression) and store\n** the result in continguous temporary registers.  Return the index of\n** the first register used to store the result.\n**\n** If the returned result register is a temporary scalar, then also write\n** that register number into *piFreeable.  If the returned result register\n** is not a temporary or if the expression is a vector set *piFreeable\n** to 0.\n*/\nstatic int exprCodeVector(Parse *pParse, Expr *p, int *piFreeable){\n  int iResult;\n  int nResult = sqlite3ExprVectorSize(p);\n  if( nResult==1 ){\n    iResult = sqlite3ExprCodeTemp(pParse, p, piFreeable);\n  }else{\n    *piFreeable = 0;\n    if( p->op==TK_SELECT ){\n#if SQLITE_OMIT_SUBQUERY\n      iResult = 0;\n#else\n      iResult = sqlite3CodeSubselect(pParse, p);\n#endif\n    }else{\n      int i;\n      iResult = pParse->nMem+1;\n      pParse->nMem += nResult;\n      for(i=0; i<nResult; i++){\n        sqlite3ExprCodeFactorable(pParse, p->x.pList->a[i].pExpr, i+iResult);\n      }\n    }\n  }\n  return iResult;\n}\n\n\n/*\n** Generate code into the current Vdbe to evaluate the given\n** expression.  Attempt to store the results in register \"target\".\n** Return the register where results are stored.\n**\n** With this routine, there is no guarantee that results will\n** be stored in target.  The result might be stored in some other\n** register if it is convenient to do so.  The calling function\n** must check the return code and move the results to the desired\n** register.\n*/\nint sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){\n  Vdbe *v = pParse->pVdbe;  /* The VM under construction */\n  int op;                   /* The opcode being coded */\n  int inReg = target;       /* Results stored in register inReg */\n  int regFree1 = 0;         /* If non-zero free this temporary register */\n  int regFree2 = 0;         /* If non-zero free this temporary register */\n  int r1, r2;               /* Various register numbers */\n  Expr tempX;               /* Temporary expression node */\n  int p5 = 0;\n\n  assert( target>0 && target<=pParse->nMem );\n  if( v==0 ){\n    assert( pParse->db->mallocFailed );\n    return 0;\n  }\n\nexpr_code_doover:\n  if( pExpr==0 ){\n    op = TK_NULL;\n  }else{\n    op = pExpr->op;\n  }\n  switch( op ){\n    case TK_AGG_COLUMN: {\n      AggInfo *pAggInfo = pExpr->pAggInfo;\n      struct AggInfo_col *pCol = &pAggInfo->aCol[pExpr->iAgg];\n      if( !pAggInfo->directMode ){\n        assert( pCol->iMem>0 );\n        return pCol->iMem;\n      }else if( pAggInfo->useSortingIdx ){\n        sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdxPTab,\n                              pCol->iSorterColumn, target);\n        return target;\n      }\n      /* Otherwise, fall thru into the TK_COLUMN case */\n    }\n    case TK_COLUMN: {\n      int iTab = pExpr->iTable;\n      if( ExprHasProperty(pExpr, EP_FixedCol) ){\n        /* This COLUMN expression is really a constant due to WHERE clause\n        ** constraints, and that constant is coded by the pExpr->pLeft\n        ** expresssion.  However, make sure the constant has the correct\n        ** datatype by applying the Affinity of the table column to the\n        ** constant.\n        */\n        int iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);\n        int aff;\n        if( pExpr->y.pTab ){\n          aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n        }else{\n          aff = pExpr->affExpr;\n        }\n        if( aff>SQLITE_AFF_BLOB ){\n          static const char zAff[] = \"B\\000C\\000D\\000E\";\n          assert( SQLITE_AFF_BLOB=='A' );\n          assert( SQLITE_AFF_TEXT=='B' );\n          if( iReg!=target ){\n            sqlite3VdbeAddOp2(v, OP_SCopy, iReg, target);\n            iReg = target;\n          }\n          sqlite3VdbeAddOp4(v, OP_Affinity, iReg, 1, 0,\n                            &zAff[(aff-'B')*2], P4_STATIC);\n        }\n        return iReg;\n      }\n      if( iTab<0 ){\n        if( pParse->iSelfTab<0 ){\n          /* Other columns in the same row for CHECK constraints or\n          ** generated columns or for inserting into partial index.\n          ** The row is unpacked into registers beginning at\n          ** 0-(pParse->iSelfTab).  The rowid (if any) is in a register\n          ** immediately prior to the first column.\n          */\n          Column *pCol;\n          Table *pTab = pExpr->y.pTab;\n          int iSrc;\n          int iCol = pExpr->iColumn;\n          assert( pTab!=0 );\n          assert( iCol>=XN_ROWID );\n          assert( iCol<pExpr->y.pTab->nCol );\n          if( iCol<0 ){\n            return -1-pParse->iSelfTab;\n          }\n          pCol = pTab->aCol + iCol;\n          testcase( iCol!=sqlite3TableColumnToStorage(pTab,iCol) );\n          iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n          if( pCol->colFlags & COLFLAG_GENERATED ){\n            if( pCol->colFlags & COLFLAG_BUSY ){\n              sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\",\n                              pCol->zName);\n              return 0;\n            }\n            pCol->colFlags |= COLFLAG_BUSY;\n            if( pCol->colFlags & COLFLAG_NOTAVAIL ){\n              sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);\n            }\n            pCol->colFlags &= ~(COLFLAG_BUSY|COLFLAG_NOTAVAIL);\n            return iSrc;\n          }else\n#endif /* SQLITE_OMIT_GENERATED_COLUMNS */\n          if( pCol->affinity==SQLITE_AFF_REAL ){\n            sqlite3VdbeAddOp2(v, OP_SCopy, iSrc, target);\n            sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n            return target;\n          }else{\n            return iSrc;\n          }\n        }else{\n          /* Coding an expression that is part of an index where column names\n          ** in the index refer to the table to which the index belongs */\n          iTab = pParse->iSelfTab - 1;\n        }\n      }\n      return sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab,\n                               pExpr->iColumn, iTab, target,\n                               pExpr->op2);\n    }\n    case TK_INTEGER: {\n      codeInteger(pParse, pExpr, 0, target);\n      return target;\n    }\n    case TK_TRUEFALSE: {\n      sqlite3VdbeAddOp2(v, OP_Integer, sqlite3ExprTruthValue(pExpr), target);\n      return target;\n    }\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    case TK_FLOAT: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      codeReal(v, pExpr->u.zToken, 0, target);\n      return target;\n    }\n#endif\n    case TK_STRING: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3VdbeLoadString(v, target, pExpr->u.zToken);\n      return target;\n    }\n    default: {\n      /* Make NULL the default case so that if a bug causes an illegal\n      ** Expr node to be passed into this function, it will be handled\n      ** sanely and not crash.  But keep an assert() to bring the problem\n      ** to the attention of the developers. */\n      assert( op==TK_NULL );\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      return target;\n    }\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n    case TK_BLOB: {\n      int n;\n      const char *z;\n      char *zBlob;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );\n      assert( pExpr->u.zToken[1]=='\\'' );\n      z = &pExpr->u.zToken[2];\n      n = sqlite3Strlen30(z) - 1;\n      assert( z[n]=='\\'' );\n      zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);\n      sqlite3VdbeAddOp4(v, OP_Blob, n/2, target, 0, zBlob, P4_DYNAMIC);\n      return target;\n    }\n#endif\n    case TK_VARIABLE: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken!=0 );\n      assert( pExpr->u.zToken[0]!=0 );\n      sqlite3VdbeAddOp2(v, OP_Variable, pExpr->iColumn, target);\n      if( pExpr->u.zToken[1]!=0 ){\n        const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);\n        assert( pExpr->u.zToken[0]=='?' || strcmp(pExpr->u.zToken, z)==0 );\n        pParse->pVList[0] = 0; /* Indicate VList may no longer be enlarged */\n        sqlite3VdbeAppendP4(v, (char*)z, P4_STATIC);\n      }\n      return target;\n    }\n    case TK_REGISTER: {\n      return pExpr->iTable;\n    }\n#ifndef SQLITE_OMIT_CAST\n    case TK_CAST: {\n      /* Expressions of the form:   CAST(pLeft AS token) */\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      if( inReg!=target ){\n        sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target);\n        inReg = target;\n      }\n      sqlite3VdbeAddOp2(v, OP_Cast, target,\n                        sqlite3AffinityType(pExpr->u.zToken, 0));\n      return inReg;\n    }\n#endif /* SQLITE_OMIT_CAST */\n    case TK_IS:\n    case TK_ISNOT:\n      op = (op==TK_IS) ? TK_EQ : TK_NE;\n      p5 = SQLITE_NULLEQ;\n      /* fall-through */\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      Expr *pLeft = pExpr->pLeft;\n      if( sqlite3ExprIsVector(pLeft) ){\n        codeVectorCompare(pParse, pExpr, target, op, p5);\n      }else{\n        r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);\n        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n        codeCompare(pParse, pLeft, pExpr->pRight, op,\n            r1, r2, inReg, SQLITE_STOREP2 | p5,\n            ExprHasProperty(pExpr,EP_Commuted));\n        assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n        assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n        assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n        assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n        assert(TK_EQ==OP_Eq); testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);\n        assert(TK_NE==OP_Ne); testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);\n        testcase( regFree1==0 );\n        testcase( regFree2==0 );\n      }\n      break;\n    }\n    case TK_AND:\n    case TK_OR:\n    case TK_PLUS:\n    case TK_STAR:\n    case TK_MINUS:\n    case TK_REM:\n    case TK_BITAND:\n    case TK_BITOR:\n    case TK_SLASH:\n    case TK_LSHIFT:\n    case TK_RSHIFT: \n    case TK_CONCAT: {\n      assert( TK_AND==OP_And );            testcase( op==TK_AND );\n      assert( TK_OR==OP_Or );              testcase( op==TK_OR );\n      assert( TK_PLUS==OP_Add );           testcase( op==TK_PLUS );\n      assert( TK_MINUS==OP_Subtract );     testcase( op==TK_MINUS );\n      assert( TK_REM==OP_Remainder );      testcase( op==TK_REM );\n      assert( TK_BITAND==OP_BitAnd );      testcase( op==TK_BITAND );\n      assert( TK_BITOR==OP_BitOr );        testcase( op==TK_BITOR );\n      assert( TK_SLASH==OP_Divide );       testcase( op==TK_SLASH );\n      assert( TK_LSHIFT==OP_ShiftLeft );   testcase( op==TK_LSHIFT );\n      assert( TK_RSHIFT==OP_ShiftRight );  testcase( op==TK_RSHIFT );\n      assert( TK_CONCAT==OP_Concat );      testcase( op==TK_CONCAT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      sqlite3VdbeAddOp3(v, op, r2, r1, target);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_UMINUS: {\n      Expr *pLeft = pExpr->pLeft;\n      assert( pLeft );\n      if( pLeft->op==TK_INTEGER ){\n        codeInteger(pParse, pLeft, 1, target);\n        return target;\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      }else if( pLeft->op==TK_FLOAT ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        codeReal(v, pLeft->u.zToken, 1, target);\n        return target;\n#endif\n      }else{\n        tempX.op = TK_INTEGER;\n        tempX.flags = EP_IntValue|EP_TokenOnly;\n        tempX.u.iValue = 0;\n        r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);\n        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);\n        sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target);\n        testcase( regFree2==0 );\n      }\n      break;\n    }\n    case TK_BITNOT:\n    case TK_NOT: {\n      assert( TK_BITNOT==OP_BitNot );   testcase( op==TK_BITNOT );\n      assert( TK_NOT==OP_Not );         testcase( op==TK_NOT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      sqlite3VdbeAddOp2(v, op, r1, inReg);\n      break;\n    }\n    case TK_TRUTH: {\n      int isTrue;    /* IS TRUE or IS NOT TRUE */\n      int bNormal;   /* IS TRUE or IS FALSE */\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n      bNormal = pExpr->op2==TK_IS;\n      testcase( isTrue && bNormal);\n      testcase( !isTrue && bNormal);\n      sqlite3VdbeAddOp4Int(v, OP_IsTrue, r1, inReg, !isTrue, isTrue ^ bNormal);\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      int addr;\n      assert( TK_ISNULL==OP_IsNull );   testcase( op==TK_ISNULL );\n      assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      addr = sqlite3VdbeAddOp1(v, op, r1);\n      VdbeCoverageIf(v, op==TK_ISNULL);\n      VdbeCoverageIf(v, op==TK_NOTNULL);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, target);\n      sqlite3VdbeJumpHere(v, addr);\n      break;\n    }\n    case TK_AGG_FUNCTION: {\n      AggInfo *pInfo = pExpr->pAggInfo;\n      if( pInfo==0 ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        sqlite3ErrorMsg(pParse, \"misuse of aggregate: %s()\", pExpr->u.zToken);\n      }else{\n        return pInfo->aFunc[pExpr->iAgg].iMem;\n      }\n      break;\n    }\n    case TK_FUNCTION: {\n      ExprList *pFarg;       /* List of function arguments */\n      int nFarg;             /* Number of function arguments */\n      FuncDef *pDef;         /* The function definition object */\n      const char *zId;       /* The function name */\n      u32 constMask = 0;     /* Mask of function arguments that are constant */\n      int i;                 /* Loop counter */\n      sqlite3 *db = pParse->db;  /* The database connection */\n      u8 enc = ENC(db);      /* The text encoding used by this database */\n      CollSeq *pColl = 0;    /* A collating sequence */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        return pExpr->y.pWin->regResult;\n      }\n#endif\n\n      if( ConstFactorOk(pParse) && sqlite3ExprIsConstantNotJoin(pExpr) ){\n        /* SQL functions can be expensive. So try to move constant functions\n        ** out of the inner loop, even if that means an extra OP_Copy. */\n        return sqlite3ExprCodeAtInit(pParse, pExpr, -1);\n      }\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      if( ExprHasProperty(pExpr, EP_TokenOnly) ){\n        pFarg = 0;\n      }else{\n        pFarg = pExpr->x.pList;\n      }\n      nFarg = pFarg ? pFarg->nExpr : 0;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      zId = pExpr->u.zToken;\n      pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);\n#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n      if( pDef==0 && pParse->explain ){\n        pDef = sqlite3FindFunction(db, \"unknown\", nFarg, enc, 0);\n      }\n#endif\n      if( pDef==0 || pDef->xFinalize!=0 ){\n        sqlite3ErrorMsg(pParse, \"unknown function: %s()\", zId);\n        break;\n      }\n\n      /* Attempt a direct implementation of the built-in COALESCE() and\n      ** IFNULL() functions.  This avoids unnecessary evaluation of\n      ** arguments past the first non-NULL argument.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_COALESCE ){\n        int endCoalesce = sqlite3VdbeMakeLabel(pParse);\n        assert( nFarg>=2 );\n        sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);\n        for(i=1; i<nFarg; i++){\n          sqlite3VdbeAddOp2(v, OP_NotNull, target, endCoalesce);\n          VdbeCoverage(v);\n          sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);\n        }\n        sqlite3VdbeResolveLabel(v, endCoalesce);\n        break;\n      }\n\n      /* The UNLIKELY() function is a no-op.  The result is the value\n      ** of the first argument.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_UNLIKELY ){\n        assert( nFarg>=1 );\n        return sqlite3ExprCodeTarget(pParse, pFarg->a[0].pExpr, target);\n      }\n\n#ifdef SQLITE_DEBUG\n      /* The AFFINITY() function evaluates to a string that describes\n      ** the type affinity of the argument.  This is used for testing of\n      ** the SQLite type logic.\n      */\n      if( pDef->funcFlags & SQLITE_FUNC_AFFINITY ){\n        const char *azAff[] = { \"blob\", \"text\", \"numeric\", \"integer\", \"real\" };\n        char aff;\n        assert( nFarg==1 );\n        aff = sqlite3ExprAffinity(pFarg->a[0].pExpr);\n        sqlite3VdbeLoadString(v, target, \n                (aff<=SQLITE_AFF_NONE) ? \"none\" : azAff[aff-SQLITE_AFF_BLOB]);\n        return target;\n      }\n#endif\n\n      for(i=0; i<nFarg; i++){\n        if( i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr) ){\n          testcase( i==31 );\n          constMask |= MASKBIT32(i);\n        }\n        if( (pDef->funcFlags & SQLITE_FUNC_NEEDCOLL)!=0 && !pColl ){\n          pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);\n        }\n      }\n      if( pFarg ){\n        if( constMask ){\n          r1 = pParse->nMem+1;\n          pParse->nMem += nFarg;\n        }else{\n          r1 = sqlite3GetTempRange(pParse, nFarg);\n        }\n\n        /* For length() and typeof() functions with a column argument,\n        ** set the P5 parameter to the OP_Column opcode to OPFLAG_LENGTHARG\n        ** or OPFLAG_TYPEOFARG respectively, to avoid unnecessary data\n        ** loading.\n        */\n        if( (pDef->funcFlags & (SQLITE_FUNC_LENGTH|SQLITE_FUNC_TYPEOF))!=0 ){\n          u8 exprOp;\n          assert( nFarg==1 );\n          assert( pFarg->a[0].pExpr!=0 );\n          exprOp = pFarg->a[0].pExpr->op;\n          if( exprOp==TK_COLUMN || exprOp==TK_AGG_COLUMN ){\n            assert( SQLITE_FUNC_LENGTH==OPFLAG_LENGTHARG );\n            assert( SQLITE_FUNC_TYPEOF==OPFLAG_TYPEOFARG );\n            testcase( pDef->funcFlags & OPFLAG_LENGTHARG );\n            pFarg->a[0].pExpr->op2 = \n                  pDef->funcFlags & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG);\n          }\n        }\n\n        sqlite3ExprCodeExprList(pParse, pFarg, r1, 0,\n                                SQLITE_ECEL_DUP|SQLITE_ECEL_FACTOR);\n      }else{\n        r1 = 0;\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n      /* Possibly overload the function if the first argument is\n      ** a virtual table column.\n      **\n      ** For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the\n      ** second argument, not the first, as the argument to test to\n      ** see if it is a column in a virtual table.  This is done because\n      ** the left operand of infix functions (the operand we want to\n      ** control overloading) ends up as the second argument to the\n      ** function.  The expression \"A glob B\" is equivalent to \n      ** \"glob(B,A).  We want to use the A in \"A glob B\" to test\n      ** for function overloading.  But we use the B term in \"glob(B,A)\".\n      */\n      if( nFarg>=2 && ExprHasProperty(pExpr, EP_InfixFunc) ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);\n      }else if( nFarg>0 ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);\n      }\n#endif\n      if( pDef->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n        if( !pColl ) pColl = db->pDfltColl; \n        sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);\n      }\n#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC\n      if( pDef->funcFlags & SQLITE_FUNC_OFFSET ){\n        Expr *pArg = pFarg->a[0].pExpr;\n        if( pArg->op==TK_COLUMN ){\n          sqlite3VdbeAddOp3(v, OP_Offset, pArg->iTable, pArg->iColumn, target);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n        }\n      }else\n#endif\n      {\n        sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,\n                                   pDef, pExpr->op2);\n      }\n      if( nFarg && constMask==0 ){\n        sqlite3ReleaseTempRange(pParse, r1, nFarg);\n      }\n      return target;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_EXISTS:\n    case TK_SELECT: {\n      int nCol;\n      testcase( op==TK_EXISTS );\n      testcase( op==TK_SELECT );\n      if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){\n        sqlite3SubselectError(pParse, nCol, 1);\n      }else{\n        return sqlite3CodeSubselect(pParse, pExpr);\n      }\n      break;\n    }\n    case TK_SELECT_COLUMN: {\n      int n;\n      if( pExpr->pLeft->iTable==0 ){\n        pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);\n      }\n      assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );\n      if( pExpr->iTable!=0\n       && pExpr->iTable!=(n = sqlite3ExprVectorSize(pExpr->pLeft))\n      ){\n        sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\",\n                                pExpr->iTable, n);\n      }\n      return pExpr->pLeft->iTable + pExpr->iColumn;\n    }\n    case TK_IN: {\n      int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n      int destIfNull = sqlite3VdbeMakeLabel(pParse);\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      sqlite3VdbeResolveLabel(v, destIfFalse);\n      sqlite3VdbeAddOp2(v, OP_AddImm, target, 0);\n      sqlite3VdbeResolveLabel(v, destIfNull);\n      return target;\n    }\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n\n    /*\n    **    x BETWEEN y AND z\n    **\n    ** This is equivalent to\n    **\n    **    x>=y AND x<=z\n    **\n    ** X is stored in pExpr->pLeft.\n    ** Y is stored in pExpr->pList->a[0].pExpr.\n    ** Z is stored in pExpr->pList->a[1].pExpr.\n    */\n    case TK_BETWEEN: {\n      exprCodeBetween(pParse, pExpr, target, 0, 0);\n      return target;\n    }\n    case TK_SPAN:\n    case TK_COLLATE: \n    case TK_UPLUS: {\n      pExpr = pExpr->pLeft;\n      goto expr_code_doover; /* 2018-04-28: Prevent deep recursion. OSSFuzz. */\n    }\n\n    case TK_TRIGGER: {\n      /* If the opcode is TK_TRIGGER, then the expression is a reference\n      ** to a column in the new.* or old.* pseudo-tables available to\n      ** trigger programs. In this case Expr.iTable is set to 1 for the\n      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumn\n      ** is set to the column of the pseudo-table to read, or to -1 to\n      ** read the rowid field.\n      **\n      ** The expression is implemented using an OP_Param opcode. The p1\n      ** parameter is set to 0 for an old.rowid reference, or to (i+1)\n      ** to reference another column of the old.* pseudo-table, where \n      ** i is the index of the column. For a new.rowid reference, p1 is\n      ** set to (n+1), where n is the number of columns in each pseudo-table.\n      ** For a reference to any other column in the new.* pseudo-table, p1\n      ** is set to (n+2+i), where n and i are as defined previously. For\n      ** example, if the table on which triggers are being fired is\n      ** declared as:\n      **\n      **   CREATE TABLE t1(a, b);\n      **\n      ** Then p1 is interpreted as follows:\n      **\n      **   p1==0   ->    old.rowid     p1==3   ->    new.rowid\n      **   p1==1   ->    old.a         p1==4   ->    new.a\n      **   p1==2   ->    old.b         p1==5   ->    new.b       \n      */\n      Table *pTab = pExpr->y.pTab;\n      int iCol = pExpr->iColumn;\n      int p1 = pExpr->iTable * (pTab->nCol+1) + 1 \n                     + sqlite3TableColumnToStorage(pTab, iCol);\n\n      assert( pExpr->iTable==0 || pExpr->iTable==1 );\n      assert( iCol>=-1 && iCol<pTab->nCol );\n      assert( pTab->iPKey<0 || iCol!=pTab->iPKey );\n      assert( p1>=0 && p1<(pTab->nCol*2+2) );\n\n      sqlite3VdbeAddOp2(v, OP_Param, p1, target);\n      VdbeComment((v, \"r[%d]=%s.%s\", target,\n        (pExpr->iTable ? \"new\" : \"old\"),\n        (pExpr->iColumn<0 ? \"rowid\" : pExpr->y.pTab->aCol[iCol].zName)\n      ));\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      /* If the column has REAL affinity, it may currently be stored as an\n      ** integer. Use OP_RealAffinity to make sure it is really real.\n      **\n      ** EVIDENCE-OF: R-60985-57662 SQLite will convert the value back to\n      ** floating point when extracting it from the record.  */\n      if( iCol>=0 && pTab->aCol[iCol].affinity==SQLITE_AFF_REAL ){\n        sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n      }\n#endif\n      break;\n    }\n\n    case TK_VECTOR: {\n      sqlite3ErrorMsg(pParse, \"row value misused\");\n      break;\n    }\n\n    /* TK_IF_NULL_ROW Expr nodes are inserted ahead of expressions\n    ** that derive from the right-hand table of a LEFT JOIN.  The\n    ** Expr.iTable value is the table number for the right-hand table.\n    ** The expression is only evaluated if that table is not currently\n    ** on a LEFT JOIN NULL row.\n    */\n    case TK_IF_NULL_ROW: {\n      int addrINR;\n      u8 okConstFactor = pParse->okConstFactor;\n      addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);\n      /* Temporarily disable factoring of constant expressions, since\n      ** even though expressions may appear to be constant, they are not\n      ** really constant because they originate from the right-hand side\n      ** of a LEFT JOIN. */\n      pParse->okConstFactor = 0;\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      pParse->okConstFactor = okConstFactor;\n      sqlite3VdbeJumpHere(v, addrINR);\n      sqlite3VdbeChangeP3(v, addrINR, inReg);\n      break;\n    }\n\n    /*\n    ** Form A:\n    **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form B:\n    **   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form A is can be transformed into the equivalent form B as follows:\n    **   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...\n    **        WHEN x=eN THEN rN ELSE y END\n    **\n    ** X (if it exists) is in pExpr->pLeft.\n    ** Y is in the last element of pExpr->x.pList if pExpr->x.pList->nExpr is\n    ** odd.  The Y is also optional.  If the number of elements in x.pList\n    ** is even, then Y is omitted and the \"otherwise\" result is NULL.\n    ** Ei is in pExpr->pList->a[i*2] and Ri is pExpr->pList->a[i*2+1].\n    **\n    ** The result of the expression is the Ri for the first matching Ei,\n    ** or if there is no matching Ei, the ELSE term Y, or if there is\n    ** no ELSE term, NULL.\n    */\n    case TK_CASE: {\n      int endLabel;                     /* GOTO label for end of CASE stmt */\n      int nextCase;                     /* GOTO label for next WHEN clause */\n      int nExpr;                        /* 2x number of WHEN terms */\n      int i;                            /* Loop counter */\n      ExprList *pEList;                 /* List of WHEN terms */\n      struct ExprList_item *aListelem;  /* Array of WHEN terms */\n      Expr opCompare;                   /* The X==Ei expression */\n      Expr *pX;                         /* The X expression */\n      Expr *pTest = 0;                  /* X==Ei (form A) or just Ei (form B) */\n      Expr *pDel = 0;\n      sqlite3 *db = pParse->db;\n\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList );\n      assert(pExpr->x.pList->nExpr > 0);\n      pEList = pExpr->x.pList;\n      aListelem = pEList->a;\n      nExpr = pEList->nExpr;\n      endLabel = sqlite3VdbeMakeLabel(pParse);\n      if( (pX = pExpr->pLeft)!=0 ){\n        pDel = sqlite3ExprDup(db, pX, 0);\n        if( db->mallocFailed ){\n          sqlite3ExprDelete(db, pDel);\n          break;\n        }\n        testcase( pX->op==TK_COLUMN );\n        exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n        testcase( regFree1==0 );\n        memset(&opCompare, 0, sizeof(opCompare));\n        opCompare.op = TK_EQ;\n        opCompare.pLeft = pDel;\n        pTest = &opCompare;\n        /* Ticket b351d95f9cd5ef17e9d9dbae18f5ca8611190001:\n        ** The value in regFree1 might get SCopy-ed into the file result.\n        ** So make sure that the regFree1 register is not reused for other\n        ** purposes and possibly overwritten.  */\n        regFree1 = 0;\n      }\n      for(i=0; i<nExpr-1; i=i+2){\n        if( pX ){\n          assert( pTest!=0 );\n          opCompare.pRight = aListelem[i].pExpr;\n        }else{\n          pTest = aListelem[i].pExpr;\n        }\n        nextCase = sqlite3VdbeMakeLabel(pParse);\n        testcase( pTest->op==TK_COLUMN );\n        sqlite3ExprIfFalse(pParse, pTest, nextCase, SQLITE_JUMPIFNULL);\n        testcase( aListelem[i+1].pExpr->op==TK_COLUMN );\n        sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);\n        sqlite3VdbeGoto(v, endLabel);\n        sqlite3VdbeResolveLabel(v, nextCase);\n      }\n      if( (nExpr&1)!=0 ){\n        sqlite3ExprCode(pParse, pEList->a[nExpr-1].pExpr, target);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      }\n      sqlite3ExprDelete(db, pDel);\n      sqlite3VdbeResolveLabel(v, endLabel);\n      break;\n    }\n#ifndef SQLITE_OMIT_TRIGGER\n    case TK_RAISE: {\n      assert( pExpr->affExpr==OE_Rollback \n           || pExpr->affExpr==OE_Abort\n           || pExpr->affExpr==OE_Fail\n           || pExpr->affExpr==OE_Ignore\n      );\n      if( !pParse->pTriggerTab ){\n        sqlite3ErrorMsg(pParse,\n                       \"RAISE() may only be used within a trigger-program\");\n        return 0;\n      }\n      if( pExpr->affExpr==OE_Abort ){\n        sqlite3MayAbort(pParse);\n      }\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      if( pExpr->affExpr==OE_Ignore ){\n        sqlite3VdbeAddOp4(\n            v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken,0);\n        VdbeCoverage(v);\n      }else{\n        sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_TRIGGER,\n                              pExpr->affExpr, pExpr->u.zToken, 0, 0);\n      }\n\n      break;\n    }\n#endif\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);\n  return inReg;\n}\n\n/*\n** Factor out the code of the given expression to initialization time.\n**\n** If regDest>=0 then the result is always stored in that register and the\n** result is not reusable.  If regDest<0 then this routine is free to \n** store the value whereever it wants.  The register where the expression \n** is stored is returned.  When regDest<0, two identical expressions will\n** code to the same register.\n*/\nint sqlite3ExprCodeAtInit(\n  Parse *pParse,    /* Parsing context */\n  Expr *pExpr,      /* The expression to code when the VDBE initializes */\n  int regDest       /* Store the value in this register */\n){\n  ExprList *p;\n  assert( ConstFactorOk(pParse) );\n  p = pParse->pConstExpr;\n  if( regDest<0 && p ){\n    struct ExprList_item *pItem;\n    int i;\n    for(pItem=p->a, i=p->nExpr; i>0; pItem++, i--){\n      if( pItem->reusable && sqlite3ExprCompare(0,pItem->pExpr,pExpr,-1)==0 ){\n        return pItem->u.iConstExprReg;\n      }\n    }\n  }\n  pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);\n  p = sqlite3ExprListAppend(pParse, p, pExpr);\n  if( p ){\n     struct ExprList_item *pItem = &p->a[p->nExpr-1];\n     pItem->reusable = regDest<0;\n     if( regDest<0 ) regDest = ++pParse->nMem;\n     pItem->u.iConstExprReg = regDest;\n  }\n  pParse->pConstExpr = p;\n  return regDest;\n}\n\n/*\n** Generate code to evaluate an expression and store the results\n** into a register.  Return the register number where the results\n** are stored.\n**\n** If the register is a temporary register that can be deallocated,\n** then write its number into *pReg.  If the result register is not\n** a temporary, then set *pReg to zero.\n**\n** If pExpr is a constant, then this routine might generate this\n** code to fill the register in the initialization section of the\n** VDBE program, in order to factor it out of the evaluation loop.\n*/\nint sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){\n  int r2;\n  pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);\n  if( ConstFactorOk(pParse)\n   && pExpr->op!=TK_REGISTER\n   && sqlite3ExprIsConstantNotJoin(pExpr)\n  ){\n    *pReg  = 0;\n    r2 = sqlite3ExprCodeAtInit(pParse, pExpr, -1);\n  }else{\n    int r1 = sqlite3GetTempReg(pParse);\n    r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);\n    if( r2==r1 ){\n      *pReg = r1;\n    }else{\n      sqlite3ReleaseTempReg(pParse, r1);\n      *pReg = 0;\n    }\n  }\n  return r2;\n}\n\n/*\n** Generate code that will evaluate expression pExpr and store the\n** results in register target.  The results are guaranteed to appear\n** in register target.\n*/\nvoid sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){\n  int inReg;\n\n  assert( target>0 && target<=pParse->nMem );\n  inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);\n  assert( pParse->pVdbe!=0 || pParse->db->mallocFailed );\n  if( inReg!=target && pParse->pVdbe ){\n    sqlite3VdbeAddOp2(pParse->pVdbe, OP_SCopy, inReg, target);\n  }\n}\n\n/*\n** Make a transient copy of expression pExpr and then code it using\n** sqlite3ExprCode().  This routine works just like sqlite3ExprCode()\n** except that the input expression is guaranteed to be unchanged.\n*/\nvoid sqlite3ExprCodeCopy(Parse *pParse, Expr *pExpr, int target){\n  sqlite3 *db = pParse->db;\n  pExpr = sqlite3ExprDup(db, pExpr, 0);\n  if( !db->mallocFailed ) sqlite3ExprCode(pParse, pExpr, target);\n  sqlite3ExprDelete(db, pExpr);\n}\n\n/*\n** Generate code that will evaluate expression pExpr and store the\n** results in register target.  The results are guaranteed to appear\n** in register target.  If the expression is constant, then this routine\n** might choose to code the expression at initialization time.\n*/\nvoid sqlite3ExprCodeFactorable(Parse *pParse, Expr *pExpr, int target){\n  if( pParse->okConstFactor && sqlite3ExprIsConstantNotJoin(pExpr) ){\n    sqlite3ExprCodeAtInit(pParse, pExpr, target);\n  }else{\n    sqlite3ExprCode(pParse, pExpr, target);\n  }\n}\n\n/*\n** Generate code that pushes the value of every element of the given\n** expression list into a sequence of registers beginning at target.\n**\n** Return the number of elements evaluated.  The number returned will\n** usually be pList->nExpr but might be reduced if SQLITE_ECEL_OMITREF\n** is defined.\n**\n** The SQLITE_ECEL_DUP flag prevents the arguments from being\n** filled using OP_SCopy.  OP_Copy must be used instead.\n**\n** The SQLITE_ECEL_FACTOR argument allows constant arguments to be\n** factored out into initialization code.\n**\n** The SQLITE_ECEL_REF flag means that expressions in the list with\n** ExprList.a[].u.x.iOrderByCol>0 have already been evaluated and stored\n** in registers at srcReg, and so the value can be copied from there.\n** If SQLITE_ECEL_OMITREF is also set, then the values with u.x.iOrderByCol>0\n** are simply omitted rather than being copied from srcReg.\n*/\nint sqlite3ExprCodeExprList(\n  Parse *pParse,     /* Parsing context */\n  ExprList *pList,   /* The expression list to be coded */\n  int target,        /* Where to write results */\n  int srcReg,        /* Source registers if SQLITE_ECEL_REF */\n  u8 flags           /* SQLITE_ECEL_* flags */\n){\n  struct ExprList_item *pItem;\n  int i, j, n;\n  u8 copyOp = (flags & SQLITE_ECEL_DUP) ? OP_Copy : OP_SCopy;\n  Vdbe *v = pParse->pVdbe;\n  assert( pList!=0 );\n  assert( target>0 );\n  assert( pParse->pVdbe!=0 );  /* Never gets this far otherwise */\n  n = pList->nExpr;\n  if( !ConstFactorOk(pParse) ) flags &= ~SQLITE_ECEL_FACTOR;\n  for(pItem=pList->a, i=0; i<n; i++, pItem++){\n    Expr *pExpr = pItem->pExpr;\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    if( pItem->bSorterRef ){\n      i--;\n      n--;\n    }else\n#endif\n    if( (flags & SQLITE_ECEL_REF)!=0 && (j = pItem->u.x.iOrderByCol)>0 ){\n      if( flags & SQLITE_ECEL_OMITREF ){\n        i--;\n        n--;\n      }else{\n        sqlite3VdbeAddOp2(v, copyOp, j+srcReg-1, target+i);\n      }\n    }else if( (flags & SQLITE_ECEL_FACTOR)!=0\n           && sqlite3ExprIsConstantNotJoin(pExpr)\n    ){\n      sqlite3ExprCodeAtInit(pParse, pExpr, target+i);\n    }else{\n      int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target+i);\n      if( inReg!=target+i ){\n        VdbeOp *pOp;\n        if( copyOp==OP_Copy\n         && (pOp=sqlite3VdbeGetOp(v, -1))->opcode==OP_Copy\n         && pOp->p1+pOp->p3+1==inReg\n         && pOp->p2+pOp->p3+1==target+i\n        ){\n          pOp->p3++;\n        }else{\n          sqlite3VdbeAddOp2(v, copyOp, inReg, target+i);\n        }\n      }\n    }\n  }\n  return n;\n}\n\n/*\n** Generate code for a BETWEEN operator.\n**\n**    x BETWEEN y AND z\n**\n** The above is equivalent to \n**\n**    x>=y AND x<=z\n**\n** Code it as such, taking care to do the common subexpression\n** elimination of x.\n**\n** The xJumpIf parameter determines details:\n**\n**    NULL:                   Store the boolean result in reg[dest]\n**    sqlite3ExprIfTrue:      Jump to dest if true\n**    sqlite3ExprIfFalse:     Jump to dest if false\n**\n** The jumpIfNull parameter is ignored if xJumpIf is NULL.\n*/\nstatic void exprCodeBetween(\n  Parse *pParse,    /* Parsing and code generating context */\n  Expr *pExpr,      /* The BETWEEN expression */\n  int dest,         /* Jump destination or storage location */\n  void (*xJump)(Parse*,Expr*,int,int), /* Action to take */\n  int jumpIfNull    /* Take the jump if the BETWEEN is NULL */\n){\n  Expr exprAnd;     /* The AND operator in  x>=y AND x<=z  */\n  Expr compLeft;    /* The  x>=y  term */\n  Expr compRight;   /* The  x<=z  term */\n  int regFree1 = 0; /* Temporary use register */\n  Expr *pDel = 0;\n  sqlite3 *db = pParse->db;\n\n  memset(&compLeft, 0, sizeof(Expr));\n  memset(&compRight, 0, sizeof(Expr));\n  memset(&exprAnd, 0, sizeof(Expr));\n\n  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n  pDel = sqlite3ExprDup(db, pExpr->pLeft, 0);\n  if( db->mallocFailed==0 ){\n    exprAnd.op = TK_AND;\n    exprAnd.pLeft = &compLeft;\n    exprAnd.pRight = &compRight;\n    compLeft.op = TK_GE;\n    compLeft.pLeft = pDel;\n    compLeft.pRight = pExpr->x.pList->a[0].pExpr;\n    compRight.op = TK_LE;\n    compRight.pLeft = pDel;\n    compRight.pRight = pExpr->x.pList->a[1].pExpr;\n    exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n    if( xJump ){\n      xJump(pParse, &exprAnd, dest, jumpIfNull);\n    }else{\n      /* Mark the expression is being from the ON or USING clause of a join\n      ** so that the sqlite3ExprCodeTarget() routine will not attempt to move\n      ** it into the Parse.pConstExpr list.  We should use a new bit for this,\n      ** for clarity, but we are out of bits in the Expr.flags field so we\n      ** have to reuse the EP_FromJoin bit.  Bummer. */\n      pDel->flags |= EP_FromJoin;\n      sqlite3ExprCodeTarget(pParse, &exprAnd, dest);\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n  }\n  sqlite3ExprDelete(db, pDel);\n\n  /* Ensure adequate test coverage */\n  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull==0 && regFree1==0 );\n  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull==0 && regFree1!=0 );\n  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull!=0 && regFree1==0 );\n  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull!=0 && regFree1!=0 );\n  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull==0 && regFree1==0 );\n  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull==0 && regFree1!=0 );\n  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull!=0 && regFree1==0 );\n  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull!=0 && regFree1!=0 );\n  testcase( xJump==0 );\n}\n\n/*\n** Generate code for a boolean expression such that a jump is made\n** to the label \"dest\" if the expression is true but execution\n** continues straight thru if the expression is false.\n**\n** If the expression evaluates to NULL (neither true nor false), then\n** take the jump if the jumpIfNull flag is SQLITE_JUMPIFNULL.\n**\n** This code depends on the fact that certain token values (ex: TK_EQ)\n** are the same as opcode values (ex: OP_Eq) that implement the corresponding\n** operation.  Special comments in vdbe.c and the mkopcodeh.awk script in\n** the make process cause these values to align.  Assert()s in the code\n** below verify that the numbers are aligned correctly.\n*/\nvoid sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){\n  Vdbe *v = pParse->pVdbe;\n  int op = 0;\n  int regFree1 = 0;\n  int regFree2 = 0;\n  int r1, r2;\n\n  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );\n  if( NEVER(v==0) )     return;  /* Existence of VDBE checked by caller */\n  if( NEVER(pExpr==0) ) return;  /* No way this can happen */\n  op = pExpr->op;\n  switch( op ){\n    case TK_AND:\n    case TK_OR: {\n      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n      if( pAlt!=pExpr ){\n        sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);\n      }else if( op==TK_AND ){\n        int d2 = sqlite3VdbeMakeLabel(pParse);\n        testcase( jumpIfNull==0 );\n        sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2,\n                           jumpIfNull^SQLITE_JUMPIFNULL);\n        sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n        sqlite3VdbeResolveLabel(v, d2);\n      }else{\n        testcase( jumpIfNull==0 );\n        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n        sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n      }\n      break;\n    }\n    case TK_NOT: {\n      testcase( jumpIfNull==0 );\n      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n      break;\n    }\n    case TK_TRUTH: {\n      int isNot;      /* IS NOT TRUE or IS NOT FALSE */\n      int isTrue;     /* IS TRUE or IS NOT TRUE */\n      testcase( jumpIfNull==0 );\n      isNot = pExpr->op2==TK_ISNOT;\n      isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n      testcase( isTrue && isNot );\n      testcase( !isTrue && isNot );\n      if( isTrue ^ isNot ){\n        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,\n                          isNot ? SQLITE_JUMPIFNULL : 0);\n      }else{\n        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,\n                           isNot ? SQLITE_JUMPIFNULL : 0);\n      }\n      break;\n    }\n    case TK_IS:\n    case TK_ISNOT:\n      testcase( op==TK_IS );\n      testcase( op==TK_ISNOT );\n      op = (op==TK_IS) ? TK_EQ : TK_NE;\n      jumpIfNull = SQLITE_NULLEQ;\n      /* Fall thru */\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;\n      testcase( jumpIfNull==0 );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,\n                  r1, r2, dest, jumpIfNull, ExprHasProperty(pExpr,EP_Commuted));\n      assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n      assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n      assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n      assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n      assert(TK_EQ==OP_Eq); testcase(op==OP_Eq);\n      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull==SQLITE_NULLEQ);\n      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull!=SQLITE_NULLEQ);\n      assert(TK_NE==OP_Ne); testcase(op==OP_Ne);\n      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull==SQLITE_NULLEQ);\n      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull!=SQLITE_NULLEQ);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      assert( TK_ISNULL==OP_IsNull );   testcase( op==TK_ISNULL );\n      assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      sqlite3VdbeAddOp2(v, op, r1, dest);\n      VdbeCoverageIf(v, op==TK_ISNULL);\n      VdbeCoverageIf(v, op==TK_NOTNULL);\n      testcase( regFree1==0 );\n      break;\n    }\n    case TK_BETWEEN: {\n      testcase( jumpIfNull==0 );\n      exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_IN: {\n      int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n      int destIfNull = jumpIfNull ? dest : destIfFalse;\n      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n      sqlite3VdbeGoto(v, dest);\n      sqlite3VdbeResolveLabel(v, destIfFalse);\n      break;\n    }\n#endif\n    default: {\n    default_expr:\n      if( ExprAlwaysTrue(pExpr) ){\n        sqlite3VdbeGoto(v, dest);\n      }else if( ExprAlwaysFalse(pExpr) ){\n        /* No-op */\n      }else{\n        r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n        sqlite3VdbeAddOp3(v, OP_If, r1, dest, jumpIfNull!=0);\n        VdbeCoverage(v);\n        testcase( regFree1==0 );\n        testcase( jumpIfNull==0 );\n      }\n      break;\n    }\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);  \n}\n\n/*\n** Generate code for a boolean expression such that a jump is made\n** to the label \"dest\" if the expression is false but execution\n** continues straight thru if the expression is true.\n**\n** If the expression evaluates to NULL (neither true nor false) then\n** jump if jumpIfNull is SQLITE_JUMPIFNULL or fall through if jumpIfNull\n** is 0.\n*/\nvoid sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){\n  Vdbe *v = pParse->pVdbe;\n  int op = 0;\n  int regFree1 = 0;\n  int regFree2 = 0;\n  int r1, r2;\n\n  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );\n  if( NEVER(v==0) ) return; /* Existence of VDBE checked by caller */\n  if( pExpr==0 )    return;\n\n  /* The value of pExpr->op and op are related as follows:\n  **\n  **       pExpr->op            op\n  **       ---------          ----------\n  **       TK_ISNULL          OP_NotNull\n  **       TK_NOTNULL         OP_IsNull\n  **       TK_NE              OP_Eq\n  **       TK_EQ              OP_Ne\n  **       TK_GT              OP_Le\n  **       TK_LE              OP_Gt\n  **       TK_GE              OP_Lt\n  **       TK_LT              OP_Ge\n  **\n  ** For other values of pExpr->op, op is undefined and unused.\n  ** The value of TK_ and OP_ constants are arranged such that we\n  ** can compute the mapping above using the following expression.\n  ** Assert()s verify that the computation is correct.\n  */\n  op = ((pExpr->op+(TK_ISNULL&1))^1)-(TK_ISNULL&1);\n\n  /* Verify correct alignment of TK_ and OP_ constants\n  */\n  assert( pExpr->op!=TK_ISNULL || op==OP_NotNull );\n  assert( pExpr->op!=TK_NOTNULL || op==OP_IsNull );\n  assert( pExpr->op!=TK_NE || op==OP_Eq );\n  assert( pExpr->op!=TK_EQ || op==OP_Ne );\n  assert( pExpr->op!=TK_LT || op==OP_Ge );\n  assert( pExpr->op!=TK_LE || op==OP_Gt );\n  assert( pExpr->op!=TK_GT || op==OP_Le );\n  assert( pExpr->op!=TK_GE || op==OP_Lt );\n\n  switch( pExpr->op ){\n    case TK_AND:\n    case TK_OR: {\n      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n      if( pAlt!=pExpr ){\n        sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);\n      }else if( pExpr->op==TK_AND ){\n        testcase( jumpIfNull==0 );\n        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n        sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n      }else{\n        int d2 = sqlite3VdbeMakeLabel(pParse);\n        testcase( jumpIfNull==0 );\n        sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2,\n                          jumpIfNull^SQLITE_JUMPIFNULL);\n        sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n        sqlite3VdbeResolveLabel(v, d2);\n      }\n      break;\n    }\n    case TK_NOT: {\n      testcase( jumpIfNull==0 );\n      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n      break;\n    }\n    case TK_TRUTH: {\n      int isNot;   /* IS NOT TRUE or IS NOT FALSE */\n      int isTrue;  /* IS TRUE or IS NOT TRUE */\n      testcase( jumpIfNull==0 );\n      isNot = pExpr->op2==TK_ISNOT;\n      isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n      testcase( isTrue && isNot );\n      testcase( !isTrue && isNot );\n      if( isTrue ^ isNot ){\n        /* IS TRUE and IS NOT FALSE */\n        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,\n                           isNot ? 0 : SQLITE_JUMPIFNULL);\n\n      }else{\n        /* IS FALSE and IS NOT TRUE */\n        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,\n                          isNot ? 0 : SQLITE_JUMPIFNULL);\n      }\n      break;\n    }\n    case TK_IS:\n    case TK_ISNOT:\n      testcase( pExpr->op==TK_IS );\n      testcase( pExpr->op==TK_ISNOT );\n      op = (pExpr->op==TK_IS) ? TK_NE : TK_EQ;\n      jumpIfNull = SQLITE_NULLEQ;\n      /* Fall thru */\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;\n      testcase( jumpIfNull==0 );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,\n                  r1, r2, dest, jumpIfNull,ExprHasProperty(pExpr,EP_Commuted));\n      assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n      assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n      assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n      assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n      assert(TK_EQ==OP_Eq); testcase(op==OP_Eq);\n      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull!=SQLITE_NULLEQ);\n      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull==SQLITE_NULLEQ);\n      assert(TK_NE==OP_Ne); testcase(op==OP_Ne);\n      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull!=SQLITE_NULLEQ);\n      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull==SQLITE_NULLEQ);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      sqlite3VdbeAddOp2(v, op, r1, dest);\n      testcase( op==TK_ISNULL );   VdbeCoverageIf(v, op==TK_ISNULL);\n      testcase( op==TK_NOTNULL );  VdbeCoverageIf(v, op==TK_NOTNULL);\n      testcase( regFree1==0 );\n      break;\n    }\n    case TK_BETWEEN: {\n      testcase( jumpIfNull==0 );\n      exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_IN: {\n      if( jumpIfNull ){\n        sqlite3ExprCodeIN(pParse, pExpr, dest, dest);\n      }else{\n        int destIfNull = sqlite3VdbeMakeLabel(pParse);\n        sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);\n        sqlite3VdbeResolveLabel(v, destIfNull);\n      }\n      break;\n    }\n#endif\n    default: {\n    default_expr: \n      if( ExprAlwaysFalse(pExpr) ){\n        sqlite3VdbeGoto(v, dest);\n      }else if( ExprAlwaysTrue(pExpr) ){\n        /* no-op */\n      }else{\n        r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n        sqlite3VdbeAddOp3(v, OP_IfNot, r1, dest, jumpIfNull!=0);\n        VdbeCoverage(v);\n        testcase( regFree1==0 );\n        testcase( jumpIfNull==0 );\n      }\n      break;\n    }\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);\n}\n\n/*\n** Like sqlite3ExprIfFalse() except that a copy is made of pExpr before\n** code generation, and that copy is deleted after code generation. This\n** ensures that the original pExpr is unchanged.\n*/\nvoid sqlite3ExprIfFalseDup(Parse *pParse, Expr *pExpr, int dest,int jumpIfNull){\n  sqlite3 *db = pParse->db;\n  Expr *pCopy = sqlite3ExprDup(db, pExpr, 0);\n  if( db->mallocFailed==0 ){\n    sqlite3ExprIfFalse(pParse, pCopy, dest, jumpIfNull);\n  }\n  sqlite3ExprDelete(db, pCopy);\n}\n\n/*\n** Expression pVar is guaranteed to be an SQL variable. pExpr may be any\n** type of expression.\n**\n** If pExpr is a simple SQL value - an integer, real, string, blob\n** or NULL value - then the VDBE currently being prepared is configured\n** to re-prepare each time a new value is bound to variable pVar.\n**\n** Additionally, if pExpr is a simple SQL value and the value is the\n** same as that currently bound to variable pVar, non-zero is returned.\n** Otherwise, if the values are not the same or if pExpr is not a simple\n** SQL value, zero is returned.\n*/\nstatic int exprCompareVariable(Parse *pParse, Expr *pVar, Expr *pExpr){\n  int res = 0;\n  int iVar;\n  sqlite3_value *pL, *pR = 0;\n  \n  sqlite3ValueFromExpr(pParse->db, pExpr, SQLITE_UTF8, SQLITE_AFF_BLOB, &pR);\n  if( pR ){\n    iVar = pVar->iColumn;\n    sqlite3VdbeSetVarmask(pParse->pVdbe, iVar);\n    pL = sqlite3VdbeGetBoundValue(pParse->pReprepare, iVar, SQLITE_AFF_BLOB);\n    if( pL ){\n      if( sqlite3_value_type(pL)==SQLITE_TEXT ){\n        sqlite3_value_text(pL); /* Make sure the encoding is UTF-8 */\n      }\n      res =  0==sqlite3MemCompare(pL, pR, 0);\n    }\n    sqlite3ValueFree(pR);\n    sqlite3ValueFree(pL);\n  }\n\n  return res;\n}\n\n/*\n** Do a deep comparison of two expression trees.  Return 0 if the two\n** expressions are completely identical.  Return 1 if they differ only\n** by a COLLATE operator at the top level.  Return 2 if there are differences\n** other than the top-level COLLATE operator.\n**\n** If any subelement of pB has Expr.iTable==(-1) then it is allowed\n** to compare equal to an equivalent element in pA with Expr.iTable==iTab.\n**\n** The pA side might be using TK_REGISTER.  If that is the case and pB is\n** not using TK_REGISTER but is otherwise equivalent, then still return 0.\n**\n** Sometimes this routine will return 2 even if the two expressions\n** really are equivalent.  If we cannot prove that the expressions are\n** identical, we return 2 just to be safe.  So if this routine\n** returns 2, then you do not really know for certain if the two\n** expressions are the same.  But if you get a 0 or 1 return, then you\n** can be sure the expressions are the same.  In the places where\n** this routine is used, it does not hurt to get an extra 2 - that\n** just might result in some slightly slower code.  But returning\n** an incorrect 0 or 1 could lead to a malfunction.\n**\n** If pParse is not NULL then TK_VARIABLE terms in pA with bindings in\n** pParse->pReprepare can be matched against literals in pB.  The \n** pParse->pVdbe->expmask bitmask is updated for each variable referenced.\n** If pParse is NULL (the normal case) then any TK_VARIABLE term in \n** Argument pParse should normally be NULL. If it is not NULL and pA or\n** pB causes a return value of 2.\n*/\nint sqlite3ExprCompare(Parse *pParse, Expr *pA, Expr *pB, int iTab){\n  u32 combinedFlags;\n  if( pA==0 || pB==0 ){\n    return pB==pA ? 0 : 2;\n  }\n  if( pParse && pA->op==TK_VARIABLE && exprCompareVariable(pParse, pA, pB) ){\n    return 0;\n  }\n  combinedFlags = pA->flags | pB->flags;\n  if( combinedFlags & EP_IntValue ){\n    if( (pA->flags&pB->flags&EP_IntValue)!=0 && pA->u.iValue==pB->u.iValue ){\n      return 0;\n    }\n    return 2;\n  }\n  if( pA->op!=pB->op || pA->op==TK_RAISE ){\n    if( pA->op==TK_COLLATE && sqlite3ExprCompare(pParse, pA->pLeft,pB,iTab)<2 ){\n      return 1;\n    }\n    if( pB->op==TK_COLLATE && sqlite3ExprCompare(pParse, pA,pB->pLeft,iTab)<2 ){\n      return 1;\n    }\n    return 2;\n  }\n  if( pA->op!=TK_COLUMN && pA->op!=TK_AGG_COLUMN && pA->u.zToken ){\n    if( pA->op==TK_FUNCTION || pA->op==TK_AGG_FUNCTION ){\n      if( sqlite3StrICmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      assert( pA->op==pB->op );\n      if( ExprHasProperty(pA,EP_WinFunc)!=ExprHasProperty(pB,EP_WinFunc) ){\n        return 2;\n      }\n      if( ExprHasProperty(pA,EP_WinFunc) ){\n        if( sqlite3WindowCompare(pParse, pA->y.pWin, pB->y.pWin, 1)!=0 ){\n          return 2;\n        }\n      }\n#endif\n    }else if( pA->op==TK_NULL ){\n      return 0;\n    }else if( pA->op==TK_COLLATE ){\n      if( sqlite3_stricmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;\n    }else if( ALWAYS(pB->u.zToken!=0) && strcmp(pA->u.zToken,pB->u.zToken)!=0 ){\n      return 2;\n    }\n  }\n  if( (pA->flags & (EP_Distinct|EP_Commuted))\n     != (pB->flags & (EP_Distinct|EP_Commuted)) ) return 2;\n  if( (combinedFlags & EP_TokenOnly)==0 ){\n    if( combinedFlags & EP_xIsSelect ) return 2;\n    if( (combinedFlags & EP_FixedCol)==0\n     && sqlite3ExprCompare(pParse, pA->pLeft, pB->pLeft, iTab) ) return 2;\n    if( sqlite3ExprCompare(pParse, pA->pRight, pB->pRight, iTab) ) return 2;\n    if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab) ) return 2;\n    if( pA->op!=TK_STRING\n     && pA->op!=TK_TRUEFALSE\n     && (combinedFlags & EP_Reduced)==0\n    ){\n      if( pA->iColumn!=pB->iColumn ) return 2;\n      if( pA->op2!=pB->op2 ){\n        if( pA->op==TK_TRUTH ) return 2;\n        if( pA->op==TK_FUNCTION && iTab<0 ){\n          /* Ex: CREATE TABLE t1(a CHECK( a<julianday('now') ));\n          **     INSERT INTO t1(a) VALUES(julianday('now')+10);\n          ** Without this test, sqlite3ExprCodeAtInit() will run on the\n          ** the julianday() of INSERT first, and remember that expression.\n          ** Then sqlite3ExprCodeInit() will see the julianday() in the CHECK\n          ** constraint as redundant, reusing the one from the INSERT, even\n          ** though the julianday() in INSERT lacks the critical NC_IsCheck\n          ** flag.  See ticket [830277d9db6c3ba1] (2019-10-30)\n          */\n          return 2;\n        }\n      }\n      if( pA->op!=TK_IN && pA->iTable!=pB->iTable && pA->iTable!=iTab ){\n        return 2;\n      }\n    }\n  }\n  return 0;\n}\n\n/*\n** Compare two ExprList objects.  Return 0 if they are identical and \n** non-zero if they differ in any way.\n**\n** If any subelement of pB has Expr.iTable==(-1) then it is allowed\n** to compare equal to an equivalent element in pA with Expr.iTable==iTab.\n**\n** This routine might return non-zero for equivalent ExprLists.  The\n** only consequence will be disabled optimizations.  But this routine\n** must never return 0 if the two ExprList objects are different, or\n** a malfunction will result.\n**\n** Two NULL pointers are considered to be the same.  But a NULL pointer\n** always differs from a non-NULL pointer.\n*/\nint sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){\n  int i;\n  if( pA==0 && pB==0 ) return 0;\n  if( pA==0 || pB==0 ) return 1;\n  if( pA->nExpr!=pB->nExpr ) return 1;\n  for(i=0; i<pA->nExpr; i++){\n    Expr *pExprA = pA->a[i].pExpr;\n    Expr *pExprB = pB->a[i].pExpr;\n    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;\n    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;\n  }\n  return 0;\n}\n\n/*\n** Like sqlite3ExprCompare() except COLLATE operators at the top-level\n** are ignored.\n*/\nint sqlite3ExprCompareSkip(Expr *pA, Expr *pB, int iTab){\n  return sqlite3ExprCompare(0,\n             sqlite3ExprSkipCollateAndLikely(pA),\n             sqlite3ExprSkipCollateAndLikely(pB),\n             iTab);\n}\n\n/*\n** Return non-zero if Expr p can only be true if pNN is not NULL.\n**\n** Or if seenNot is true, return non-zero if Expr p can only be\n** non-NULL if pNN is not NULL\n*/\nstatic int exprImpliesNotNull(\n  Parse *pParse,      /* Parsing context */\n  Expr *p,            /* The expression to be checked */\n  Expr *pNN,          /* The expression that is NOT NULL */\n  int iTab,           /* Table being evaluated */\n  int seenNot         /* Return true only if p can be any non-NULL value */\n){\n  assert( p );\n  assert( pNN );\n  if( sqlite3ExprCompare(pParse, p, pNN, iTab)==0 ){\n    return pNN->op!=TK_NULL;\n  }\n  switch( p->op ){\n    case TK_IN: {\n      if( seenNot && ExprHasProperty(p, EP_xIsSelect) ) return 0;\n      assert( ExprHasProperty(p,EP_xIsSelect)\n           || (p->x.pList!=0 && p->x.pList->nExpr>0) );\n      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n    }\n    case TK_BETWEEN: {\n      ExprList *pList = p->x.pList;\n      assert( pList!=0 );\n      assert( pList->nExpr==2 );\n      if( seenNot ) return 0;\n      if( exprImpliesNotNull(pParse, pList->a[0].pExpr, pNN, iTab, 1)\n       || exprImpliesNotNull(pParse, pList->a[1].pExpr, pNN, iTab, 1)\n      ){\n        return 1;\n      }\n      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n    }\n    case TK_EQ:\n    case TK_NE:\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_PLUS:\n    case TK_MINUS:\n    case TK_BITOR:\n    case TK_LSHIFT:\n    case TK_RSHIFT: \n    case TK_CONCAT: \n      seenNot = 1;\n      /* Fall thru */\n    case TK_STAR:\n    case TK_REM:\n    case TK_BITAND:\n    case TK_SLASH: {\n      if( exprImpliesNotNull(pParse, p->pRight, pNN, iTab, seenNot) ) return 1;\n      /* Fall thru into the next case */\n    }\n    case TK_SPAN:\n    case TK_COLLATE:\n    case TK_UPLUS:\n    case TK_UMINUS: {\n      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, seenNot);\n    }\n    case TK_TRUTH: {\n      if( seenNot ) return 0;\n      if( p->op2!=TK_IS ) return 0;\n      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n    }\n    case TK_BITNOT:\n    case TK_NOT: {\n      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n    }\n  }\n  return 0;\n}\n\n/*\n** Return true if we can prove the pE2 will always be true if pE1 is\n** true.  Return false if we cannot complete the proof or if pE2 might\n** be false.  Examples:\n**\n**     pE1: x==5       pE2: x==5             Result: true\n**     pE1: x>0        pE2: x==5             Result: false\n**     pE1: x=21       pE2: x=21 OR y=43     Result: true\n**     pE1: x!=123     pE2: x IS NOT NULL    Result: true\n**     pE1: x!=?1      pE2: x IS NOT NULL    Result: true\n**     pE1: x IS NULL  pE2: x IS NOT NULL    Result: false\n**     pE1: x IS ?2    pE2: x IS NOT NULL    Reuslt: false\n**\n** When comparing TK_COLUMN nodes between pE1 and pE2, if pE2 has\n** Expr.iTable<0 then assume a table number given by iTab.\n**\n** If pParse is not NULL, then the values of bound variables in pE1 are \n** compared against literal values in pE2 and pParse->pVdbe->expmask is\n** modified to record which bound variables are referenced.  If pParse \n** is NULL, then false will be returned if pE1 contains any bound variables.\n**\n** When in doubt, return false.  Returning true might give a performance\n** improvement.  Returning false might cause a performance reduction, but\n** it will always give the correct answer and is hence always safe.\n*/\nint sqlite3ExprImpliesExpr(Parse *pParse, Expr *pE1, Expr *pE2, int iTab){\n  if( sqlite3ExprCompare(pParse, pE1, pE2, iTab)==0 ){\n    return 1;\n  }\n  if( pE2->op==TK_OR\n   && (sqlite3ExprImpliesExpr(pParse, pE1, pE2->pLeft, iTab)\n             || sqlite3ExprImpliesExpr(pParse, pE1, pE2->pRight, iTab) )\n  ){\n    return 1;\n  }\n  if( pE2->op==TK_NOTNULL\n   && exprImpliesNotNull(pParse, pE1, pE2->pLeft, iTab, 0)\n  ){\n    return 1;\n  }\n  return 0;\n}\n\n/*\n** This is the Expr node callback for sqlite3ExprImpliesNonNullRow().\n** If the expression node requires that the table at pWalker->iCur\n** have one or more non-NULL column, then set pWalker->eCode to 1 and abort.\n**\n** This routine controls an optimization.  False positives (setting\n** pWalker->eCode to 1 when it should not be) are deadly, but false-negatives\n** (never setting pWalker->eCode) is a harmless missed optimization.\n*/\nstatic int impliesNotNullRow(Walker *pWalker, Expr *pExpr){\n  testcase( pExpr->op==TK_AGG_COLUMN );\n  testcase( pExpr->op==TK_AGG_FUNCTION );\n  if( ExprHasProperty(pExpr, EP_FromJoin) ) return WRC_Prune;\n  switch( pExpr->op ){\n    case TK_ISNOT:\n    case TK_ISNULL:\n    case TK_NOTNULL:\n    case TK_IS:\n    case TK_OR:\n    case TK_VECTOR:\n    case TK_CASE:\n    case TK_IN:\n    case TK_FUNCTION:\n    case TK_TRUTH:\n      testcase( pExpr->op==TK_ISNOT );\n      testcase( pExpr->op==TK_ISNULL );\n      testcase( pExpr->op==TK_NOTNULL );\n      testcase( pExpr->op==TK_IS );\n      testcase( pExpr->op==TK_OR );\n      testcase( pExpr->op==TK_VECTOR );\n      testcase( pExpr->op==TK_CASE );\n      testcase( pExpr->op==TK_IN );\n      testcase( pExpr->op==TK_FUNCTION );\n      testcase( pExpr->op==TK_TRUTH );\n      return WRC_Prune;\n    case TK_COLUMN:\n      if( pWalker->u.iCur==pExpr->iTable ){\n        pWalker->eCode = 1;\n        return WRC_Abort;\n      }\n      return WRC_Prune;\n\n    case TK_AND:\n      assert( pWalker->eCode==0 );\n      sqlite3WalkExpr(pWalker, pExpr->pLeft);\n      if( pWalker->eCode ){\n        pWalker->eCode = 0;\n        sqlite3WalkExpr(pWalker, pExpr->pRight);\n      }\n      return WRC_Prune;\n\n    case TK_BETWEEN:\n      sqlite3WalkExpr(pWalker, pExpr->pLeft);\n      return WRC_Prune;\n\n    /* Virtual tables are allowed to use constraints like x=NULL.  So\n    ** a term of the form x=y does not prove that y is not null if x\n    ** is the column of a virtual table */\n    case TK_EQ:\n    case TK_NE:\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n      testcase( pExpr->op==TK_EQ );\n      testcase( pExpr->op==TK_NE );\n      testcase( pExpr->op==TK_LT );\n      testcase( pExpr->op==TK_LE );\n      testcase( pExpr->op==TK_GT );\n      testcase( pExpr->op==TK_GE );\n      if( (pExpr->pLeft->op==TK_COLUMN && IsVirtual(pExpr->pLeft->y.pTab))\n       || (pExpr->pRight->op==TK_COLUMN && IsVirtual(pExpr->pRight->y.pTab))\n      ){\n       return WRC_Prune;\n      }\n\n    default:\n      return WRC_Continue;\n  }\n}\n\n/*\n** Return true (non-zero) if expression p can only be true if at least\n** one column of table iTab is non-null.  In other words, return true\n** if expression p will always be NULL or false if every column of iTab\n** is NULL.\n**\n** False negatives are acceptable.  In other words, it is ok to return\n** zero even if expression p will never be true of every column of iTab\n** is NULL.  A false negative is merely a missed optimization opportunity.\n**\n** False positives are not allowed, however.  A false positive may result\n** in an incorrect answer.\n**\n** Terms of p that are marked with EP_FromJoin (and hence that come from\n** the ON or USING clauses of LEFT JOINS) are excluded from the analysis.\n**\n** This routine is used to check if a LEFT JOIN can be converted into\n** an ordinary JOIN.  The p argument is the WHERE clause.  If the WHERE\n** clause requires that some column of the right table of the LEFT JOIN\n** be non-NULL, then the LEFT JOIN can be safely converted into an\n** ordinary join.\n*/\nint sqlite3ExprImpliesNonNullRow(Expr *p, int iTab){\n  Walker w;\n  p = sqlite3ExprSkipCollateAndLikely(p);\n  if( p==0 ) return 0;\n  if( p->op==TK_NOTNULL ){\n    p = p->pLeft;\n  }else{\n    while( p->op==TK_AND ){\n      if( sqlite3ExprImpliesNonNullRow(p->pLeft, iTab) ) return 1;\n      p = p->pRight;\n    }\n  }\n  w.xExprCallback = impliesNotNullRow;\n  w.xSelectCallback = 0;\n  w.xSelectCallback2 = 0;\n  w.eCode = 0;\n  w.u.iCur = iTab;\n  sqlite3WalkExpr(&w, p);\n  return w.eCode;\n}\n\n/*\n** An instance of the following structure is used by the tree walker\n** to determine if an expression can be evaluated by reference to the\n** index only, without having to do a search for the corresponding\n** table entry.  The IdxCover.pIdx field is the index.  IdxCover.iCur\n** is the cursor for the table.\n*/\nstruct IdxCover {\n  Index *pIdx;     /* The index to be tested for coverage */\n  int iCur;        /* Cursor number for the table corresponding to the index */\n};\n\n/*\n** Check to see if there are references to columns in table \n** pWalker->u.pIdxCover->iCur can be satisfied using the index\n** pWalker->u.pIdxCover->pIdx.\n*/\nstatic int exprIdxCover(Walker *pWalker, Expr *pExpr){\n  if( pExpr->op==TK_COLUMN\n   && pExpr->iTable==pWalker->u.pIdxCover->iCur\n   && sqlite3TableColumnToIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0\n  ){\n    pWalker->eCode = 1;\n    return WRC_Abort;\n  }\n  return WRC_Continue;\n}\n\n/*\n** Determine if an index pIdx on table with cursor iCur contains will\n** the expression pExpr.  Return true if the index does cover the\n** expression and false if the pExpr expression references table columns\n** that are not found in the index pIdx.\n**\n** An index covering an expression means that the expression can be\n** evaluated using only the index and without having to lookup the\n** corresponding table entry.\n*/\nint sqlite3ExprCoveredByIndex(\n  Expr *pExpr,        /* The index to be tested */\n  int iCur,           /* The cursor number for the corresponding table */\n  Index *pIdx         /* The index that might be used for coverage */\n){\n  Walker w;\n  struct IdxCover xcov;\n  memset(&w, 0, sizeof(w));\n  xcov.iCur = iCur;\n  xcov.pIdx = pIdx;\n  w.xExprCallback = exprIdxCover;\n  w.u.pIdxCover = &xcov;\n  sqlite3WalkExpr(&w, pExpr);\n  return !w.eCode;\n}\n\n\n/*\n** An instance of the following structure is used by the tree walker\n** to count references to table columns in the arguments of an \n** aggregate function, in order to implement the\n** sqlite3FunctionThisSrc() routine.\n*/\nstruct SrcCount {\n  SrcList *pSrc;   /* One particular FROM clause in a nested query */\n  int nThis;       /* Number of references to columns in pSrcList */\n  int nOther;      /* Number of references to columns in other FROM clauses */\n};\n\n/*\n** Count the number of references to columns.\n*/\nstatic int exprSrcCount(Walker *pWalker, Expr *pExpr){\n  /* The NEVER() on the second term is because sqlite3FunctionUsesThisSrc()\n  ** is always called before sqlite3ExprAnalyzeAggregates() and so the\n  ** TK_COLUMNs have not yet been converted into TK_AGG_COLUMN.  If\n  ** sqlite3FunctionUsesThisSrc() is used differently in the future, the\n  ** NEVER() will need to be removed. */\n  if( pExpr->op==TK_COLUMN || NEVER(pExpr->op==TK_AGG_COLUMN) ){\n    int i;\n    struct SrcCount *p = pWalker->u.pSrcCount;\n    SrcList *pSrc = p->pSrc;\n    int nSrc = pSrc ? pSrc->nSrc : 0;\n    for(i=0; i<nSrc; i++){\n      if( pExpr->iTable==pSrc->a[i].iCursor ) break;\n    }\n    if( i<nSrc ){\n      p->nThis++;\n    }else if( nSrc==0 || pExpr->iTable<pSrc->a[0].iCursor ){\n      /* In a well-formed parse tree (no name resolution errors),\n      ** TK_COLUMN nodes with smaller Expr.iTable values are in an\n      ** outer context.  Those are the only ones to count as \"other\" */\n      p->nOther++;\n    }\n  }\n  return WRC_Continue;\n}\n\n/*\n** Determine if any of the arguments to the pExpr Function reference\n** pSrcList.  Return true if they do.  Also return true if the function\n** has no arguments or has only constant arguments.  Return false if pExpr\n** references columns but not columns of tables found in pSrcList.\n*/\nint sqlite3FunctionUsesThisSrc(Expr *pExpr, SrcList *pSrcList){\n  Walker w;\n  struct SrcCount cnt;\n  assert( pExpr->op==TK_AGG_FUNCTION );\n  memset(&w, 0, sizeof(w));\n  w.xExprCallback = exprSrcCount;\n  w.xSelectCallback = sqlite3SelectWalkNoop;\n  w.u.pSrcCount = &cnt;\n  cnt.pSrc = pSrcList;\n  cnt.nThis = 0;\n  cnt.nOther = 0;\n  sqlite3WalkExprList(&w, pExpr->x.pList);\n  return cnt.nThis>0 || cnt.nOther==0;\n}\n\n/*\n** Add a new element to the pAggInfo->aCol[] array.  Return the index of\n** the new element.  Return a negative number if malloc fails.\n*/\nstatic int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){\n  int i;\n  pInfo->aCol = sqlite3ArrayAllocate(\n       db,\n       pInfo->aCol,\n       sizeof(pInfo->aCol[0]),\n       &pInfo->nColumn,\n       &i\n  );\n  return i;\n}    \n\n/*\n** Add a new element to the pAggInfo->aFunc[] array.  Return the index of\n** the new element.  Return a negative number if malloc fails.\n*/\nstatic int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){\n  int i;\n  pInfo->aFunc = sqlite3ArrayAllocate(\n       db, \n       pInfo->aFunc,\n       sizeof(pInfo->aFunc[0]),\n       &pInfo->nFunc,\n       &i\n  );\n  return i;\n}    \n\n/*\n** This is the xExprCallback for a tree walker.  It is used to\n** implement sqlite3ExprAnalyzeAggregates().  See sqlite3ExprAnalyzeAggregates\n** for additional information.\n*/\nstatic int analyzeAggregate(Walker *pWalker, Expr *pExpr){\n  int i;\n  NameContext *pNC = pWalker->u.pNC;\n  Parse *pParse = pNC->pParse;\n  SrcList *pSrcList = pNC->pSrcList;\n  AggInfo *pAggInfo = pNC->uNC.pAggInfo;\n\n  assert( pNC->ncFlags & NC_UAggInfo );\n  switch( pExpr->op ){\n    case TK_AGG_COLUMN:\n    case TK_COLUMN: {\n      testcase( pExpr->op==TK_AGG_COLUMN );\n      testcase( pExpr->op==TK_COLUMN );\n      /* Check to see if the column is in one of the tables in the FROM\n      ** clause of the aggregate query */\n      if( ALWAYS(pSrcList!=0) ){\n        struct SrcList_item *pItem = pSrcList->a;\n        for(i=0; i<pSrcList->nSrc; i++, pItem++){\n          struct AggInfo_col *pCol;\n          assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n          if( pExpr->iTable==pItem->iCursor ){\n            /* If we reach this point, it means that pExpr refers to a table\n            ** that is in the FROM clause of the aggregate query.  \n            **\n            ** Make an entry for the column in pAggInfo->aCol[] if there\n            ** is not an entry there already.\n            */\n            int k;\n            pCol = pAggInfo->aCol;\n            for(k=0; k<pAggInfo->nColumn; k++, pCol++){\n              if( pCol->iTable==pExpr->iTable &&\n                  pCol->iColumn==pExpr->iColumn ){\n                break;\n              }\n            }\n            if( (k>=pAggInfo->nColumn)\n             && (k = addAggInfoColumn(pParse->db, pAggInfo))>=0 \n            ){\n              pCol = &pAggInfo->aCol[k];\n              pCol->pTab = pExpr->y.pTab;\n              pCol->iTable = pExpr->iTable;\n              pCol->iColumn = pExpr->iColumn;\n              pCol->iMem = ++pParse->nMem;\n              pCol->iSorterColumn = -1;\n              pCol->pExpr = pExpr;\n              if( pAggInfo->pGroupBy ){\n                int j, n;\n                ExprList *pGB = pAggInfo->pGroupBy;\n                struct ExprList_item *pTerm = pGB->a;\n                n = pGB->nExpr;\n                for(j=0; j<n; j++, pTerm++){\n                  Expr *pE = pTerm->pExpr;\n                  if( pE->op==TK_COLUMN && pE->iTable==pExpr->iTable &&\n                      pE->iColumn==pExpr->iColumn ){\n                    pCol->iSorterColumn = j;\n                    break;\n                  }\n                }\n              }\n              if( pCol->iSorterColumn<0 ){\n                pCol->iSorterColumn = pAggInfo->nSortingColumn++;\n              }\n            }\n            /* There is now an entry for pExpr in pAggInfo->aCol[] (either\n            ** because it was there before or because we just created it).\n            ** Convert the pExpr to be a TK_AGG_COLUMN referring to that\n            ** pAggInfo->aCol[] entry.\n            */\n            ExprSetVVAProperty(pExpr, EP_NoReduce);\n            pExpr->pAggInfo = pAggInfo;\n            pExpr->op = TK_AGG_COLUMN;\n            pExpr->iAgg = (i16)k;\n            break;\n          } /* endif pExpr->iTable==pItem->iCursor */\n        } /* end loop over pSrcList */\n      }\n      return WRC_Prune;\n    }\n    case TK_AGG_FUNCTION: {\n      if( (pNC->ncFlags & NC_InAggFunc)==0\n       && pWalker->walkerDepth==pExpr->op2\n      ){\n        /* Check to see if pExpr is a duplicate of another aggregate \n        ** function that is already in the pAggInfo structure\n        */\n        struct AggInfo_func *pItem = pAggInfo->aFunc;\n        for(i=0; i<pAggInfo->nFunc; i++, pItem++){\n          if( sqlite3ExprCompare(0, pItem->pExpr, pExpr, -1)==0 ){\n            break;\n          }\n        }\n        if( i>=pAggInfo->nFunc ){\n          /* pExpr is original.  Make a new entry in pAggInfo->aFunc[]\n          */\n          u8 enc = ENC(pParse->db);\n          i = addAggInfoFunc(pParse->db, pAggInfo);\n          if( i>=0 ){\n            assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n            pItem = &pAggInfo->aFunc[i];\n            pItem->pExpr = pExpr;\n            pItem->iMem = ++pParse->nMem;\n            assert( !ExprHasProperty(pExpr, EP_IntValue) );\n            pItem->pFunc = sqlite3FindFunction(pParse->db,\n                   pExpr->u.zToken, \n                   pExpr->x.pList ? pExpr->x.pList->nExpr : 0, enc, 0);\n            if( pExpr->flags & EP_Distinct ){\n              pItem->iDistinct = pParse->nTab++;\n            }else{\n              pItem->iDistinct = -1;\n            }\n          }\n        }\n        /* Make pExpr point to the appropriate pAggInfo->aFunc[] entry\n        */\n        assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n        ExprSetVVAProperty(pExpr, EP_NoReduce);\n        pExpr->iAgg = (i16)i;\n        pExpr->pAggInfo = pAggInfo;\n        return WRC_Prune;\n      }else{\n        return WRC_Continue;\n      }\n    }\n  }\n  return WRC_Continue;\n}\nstatic int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect){\n  UNUSED_PARAMETER(pSelect);\n  pWalker->walkerDepth++;\n  return WRC_Continue;\n}\nstatic void analyzeAggregatesInSelectEnd(Walker *pWalker, Select *pSelect){\n  UNUSED_PARAMETER(pSelect);\n  pWalker->walkerDepth--;\n}\n\n/*\n** Analyze the pExpr expression looking for aggregate functions and\n** for variables that need to be added to AggInfo object that pNC->pAggInfo\n** points to.  Additional entries are made on the AggInfo object as\n** necessary.\n**\n** This routine should only be called after the expression has been\n** analyzed by sqlite3ResolveExprNames().\n*/\nvoid sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){\n  Walker w;\n  w.xExprCallback = analyzeAggregate;\n  w.xSelectCallback = analyzeAggregatesInSelect;\n  w.xSelectCallback2 = analyzeAggregatesInSelectEnd;\n  w.walkerDepth = 0;\n  w.u.pNC = pNC;\n  w.pParse = 0;\n  assert( pNC->pSrcList!=0 );\n  sqlite3WalkExpr(&w, pExpr);\n}\n\n/*\n** Call sqlite3ExprAnalyzeAggregates() for every expression in an\n** expression list.  Return the number of errors.\n**\n** If an error is found, the analysis is cut short.\n*/\nvoid sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){\n  struct ExprList_item *pItem;\n  int i;\n  if( pList ){\n    for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){\n      sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);\n    }\n  }\n}\n\n/*\n** Allocate a single new register for use to hold some intermediate result.\n*/\nint sqlite3GetTempReg(Parse *pParse){\n  if( pParse->nTempReg==0 ){\n    return ++pParse->nMem;\n  }\n  return pParse->aTempReg[--pParse->nTempReg];\n}\n\n/*\n** Deallocate a register, making available for reuse for some other\n** purpose.\n*/\nvoid sqlite3ReleaseTempReg(Parse *pParse, int iReg){\n  if( iReg && pParse->nTempReg<ArraySize(pParse->aTempReg) ){\n    pParse->aTempReg[pParse->nTempReg++] = iReg;\n  }\n}\n\n/*\n** Allocate or deallocate a block of nReg consecutive registers.\n*/\nint sqlite3GetTempRange(Parse *pParse, int nReg){\n  int i, n;\n  if( nReg==1 ) return sqlite3GetTempReg(pParse);\n  i = pParse->iRangeReg;\n  n = pParse->nRangeReg;\n  if( nReg<=n ){\n    pParse->iRangeReg += nReg;\n    pParse->nRangeReg -= nReg;\n  }else{\n    i = pParse->nMem+1;\n    pParse->nMem += nReg;\n  }\n  return i;\n}\nvoid sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){\n  if( nReg==1 ){\n    sqlite3ReleaseTempReg(pParse, iReg);\n    return;\n  }\n  if( nReg>pParse->nRangeReg ){\n    pParse->nRangeReg = nReg;\n    pParse->iRangeReg = iReg;\n  }\n}\n\n/*\n** Mark all temporary registers as being unavailable for reuse.\n**\n** Always invoke this procedure after coding a subroutine or co-routine\n** that might be invoked from other parts of the code, to ensure that\n** the sub/co-routine does not use registers in common with the code that\n** invokes the sub/co-routine.\n*/\nvoid sqlite3ClearTempRegCache(Parse *pParse){\n  pParse->nTempReg = 0;\n  pParse->nRangeReg = 0;\n}\n\n/*\n** Validate that no temporary register falls within the range of\n** iFirst..iLast, inclusive.  This routine is only call from within assert()\n** statements.\n*/\n#ifdef SQLITE_DEBUG\nint sqlite3NoTempsInRange(Parse *pParse, int iFirst, int iLast){\n  int i;\n  if( pParse->nRangeReg>0\n   && pParse->iRangeReg+pParse->nRangeReg > iFirst\n   && pParse->iRangeReg <= iLast\n  ){\n     return 0;\n  }\n  for(i=0; i<pParse->nTempReg; i++){\n    if( pParse->aTempReg[i]>=iFirst && pParse->aTempReg[i]<=iLast ){\n      return 0;\n    }\n  }\n  return 1;\n}\n#endif /* SQLITE_DEBUG */\n", "/*\n** 2003 September 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used for creating, destroying, and populating\n** a VDBE (or an \"sqlite3_stmt\" as it is known to the outside world.) \n*/\n#include \"sqliteInt.h\"\n#include \"vdbeInt.h\"\n\n/* Forward references */\nstatic void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef);\nstatic void vdbeFreeOpArray(sqlite3 *, Op *, int);\n\n/*\n** Create a new virtual database engine.\n*/\nVdbe *sqlite3VdbeCreate(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  Vdbe *p;\n  p = sqlite3DbMallocRawNN(db, sizeof(Vdbe) );\n  if( p==0 ) return 0;\n  memset(&p->aOp, 0, sizeof(Vdbe)-offsetof(Vdbe,aOp));\n  p->db = db;\n  if( db->pVdbe ){\n    db->pVdbe->pPrev = p;\n  }\n  p->pNext = db->pVdbe;\n  p->pPrev = 0;\n  db->pVdbe = p;\n  p->magic = VDBE_MAGIC_INIT;\n  p->pParse = pParse;\n  pParse->pVdbe = p;\n  assert( pParse->aLabel==0 );\n  assert( pParse->nLabel==0 );\n  assert( p->nOpAlloc==0 );\n  assert( pParse->szOpAlloc==0 );\n  sqlite3VdbeAddOp2(p, OP_Init, 0, 1);\n  return p;\n}\n\n/*\n** Return the Parse object that owns a Vdbe object.\n*/\nParse *sqlite3VdbeParser(Vdbe *p){\n  return p->pParse;\n}\n\n/*\n** Change the error string stored in Vdbe.zErrMsg\n*/\nvoid sqlite3VdbeError(Vdbe *p, const char *zFormat, ...){\n  va_list ap;\n  sqlite3DbFree(p->db, p->zErrMsg);\n  va_start(ap, zFormat);\n  p->zErrMsg = sqlite3VMPrintf(p->db, zFormat, ap);\n  va_end(ap);\n}\n\n/*\n** Remember the SQL string for a prepared statement.\n*/\nvoid sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, u8 prepFlags){\n  if( p==0 ) return;\n  p->prepFlags = prepFlags;\n  if( (prepFlags & SQLITE_PREPARE_SAVESQL)==0 ){\n    p->expmask = 0;\n  }\n  assert( p->zSql==0 );\n  p->zSql = sqlite3DbStrNDup(p->db, z, n);\n}\n\n#ifdef SQLITE_ENABLE_NORMALIZE\n/*\n** Add a new element to the Vdbe->pDblStr list.\n*/\nvoid sqlite3VdbeAddDblquoteStr(sqlite3 *db, Vdbe *p, const char *z){\n  if( p ){\n    int n = sqlite3Strlen30(z);\n    DblquoteStr *pStr = sqlite3DbMallocRawNN(db,\n                            sizeof(*pStr)+n+1-sizeof(pStr->z));\n    if( pStr ){\n      pStr->pNextStr = p->pDblStr;\n      p->pDblStr = pStr;\n      memcpy(pStr->z, z, n+1);\n    }\n  }\n}\n#endif\n\n#ifdef SQLITE_ENABLE_NORMALIZE\n/*\n** zId of length nId is a double-quoted identifier.  Check to see if\n** that identifier is really used as a string literal.\n*/\nint sqlite3VdbeUsesDoubleQuotedString(\n  Vdbe *pVdbe,            /* The prepared statement */\n  const char *zId         /* The double-quoted identifier, already dequoted */\n){\n  DblquoteStr *pStr;\n  assert( zId!=0 );\n  if( pVdbe->pDblStr==0 ) return 0;\n  for(pStr=pVdbe->pDblStr; pStr; pStr=pStr->pNextStr){\n    if( strcmp(zId, pStr->z)==0 ) return 1;\n  }\n  return 0;\n}\n#endif\n\n/*\n** Swap all content between two VDBE structures.\n*/\nvoid sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){\n  Vdbe tmp, *pTmp;\n  char *zTmp;\n  assert( pA->db==pB->db );\n  tmp = *pA;\n  *pA = *pB;\n  *pB = tmp;\n  pTmp = pA->pNext;\n  pA->pNext = pB->pNext;\n  pB->pNext = pTmp;\n  pTmp = pA->pPrev;\n  pA->pPrev = pB->pPrev;\n  pB->pPrev = pTmp;\n  zTmp = pA->zSql;\n  pA->zSql = pB->zSql;\n  pB->zSql = zTmp;\n#ifdef SQLITE_ENABLE_NORMALIZE\n  zTmp = pA->zNormSql;\n  pA->zNormSql = pB->zNormSql;\n  pB->zNormSql = zTmp;\n#endif\n  pB->expmask = pA->expmask;\n  pB->prepFlags = pA->prepFlags;\n  memcpy(pB->aCounter, pA->aCounter, sizeof(pB->aCounter));\n  pB->aCounter[SQLITE_STMTSTATUS_REPREPARE]++;\n}\n\n/*\n** Resize the Vdbe.aOp array so that it is at least nOp elements larger \n** than its current size. nOp is guaranteed to be less than or equal\n** to 1024/sizeof(Op).\n**\n** If an out-of-memory error occurs while resizing the array, return\n** SQLITE_NOMEM. In this case Vdbe.aOp and Vdbe.nOpAlloc remain \n** unchanged (this is so that any opcodes already allocated can be \n** correctly deallocated along with the rest of the Vdbe).\n*/\nstatic int growOpArray(Vdbe *v, int nOp){\n  VdbeOp *pNew;\n  Parse *p = v->pParse;\n\n  /* The SQLITE_TEST_REALLOC_STRESS compile-time option is designed to force\n  ** more frequent reallocs and hence provide more opportunities for \n  ** simulated OOM faults.  SQLITE_TEST_REALLOC_STRESS is generally used\n  ** during testing only.  With SQLITE_TEST_REALLOC_STRESS grow the op array\n  ** by the minimum* amount required until the size reaches 512.  Normal\n  ** operation (without SQLITE_TEST_REALLOC_STRESS) is to double the current\n  ** size of the op array or add 1KB of space, whichever is smaller. */\n#ifdef SQLITE_TEST_REALLOC_STRESS\n  sqlite3_int64 nNew = (v->nOpAlloc>=512 ? 2*(sqlite3_int64)v->nOpAlloc\n                        : (sqlite3_int64)v->nOpAlloc+nOp);\n#else\n  sqlite3_int64 nNew = (v->nOpAlloc ? 2*(sqlite3_int64)v->nOpAlloc\n                        : (sqlite3_int64)(1024/sizeof(Op)));\n  UNUSED_PARAMETER(nOp);\n#endif\n\n  /* Ensure that the size of a VDBE does not grow too large */\n  if( nNew > p->db->aLimit[SQLITE_LIMIT_VDBE_OP] ){\n    sqlite3OomFault(p->db);\n    return SQLITE_NOMEM;\n  }\n\n  assert( nOp<=(1024/sizeof(Op)) );\n  assert( nNew>=(v->nOpAlloc+nOp) );\n  pNew = sqlite3DbRealloc(p->db, v->aOp, nNew*sizeof(Op));\n  if( pNew ){\n    p->szOpAlloc = sqlite3DbMallocSize(p->db, pNew);\n    v->nOpAlloc = p->szOpAlloc/sizeof(Op);\n    v->aOp = pNew;\n  }\n  return (pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT);\n}\n\n#ifdef SQLITE_DEBUG\n/* This routine is just a convenient place to set a breakpoint that will\n** fire after each opcode is inserted and displayed using\n** \"PRAGMA vdbe_addoptrace=on\".\n*/\nstatic void test_addop_breakpoint(void){\n  static int n = 0;\n  n++;\n}\n#endif\n\n/*\n** Add a new instruction to the list of instructions current in the\n** VDBE.  Return the address of the new instruction.\n**\n** Parameters:\n**\n**    p               Pointer to the VDBE\n**\n**    op              The opcode for this instruction\n**\n**    p1, p2, p3      Operands\n**\n** Use the sqlite3VdbeResolveLabel() function to fix an address and\n** the sqlite3VdbeChangeP4() function to change the value of the P4\n** operand.\n*/\nstatic SQLITE_NOINLINE int growOp3(Vdbe *p, int op, int p1, int p2, int p3){\n  assert( p->nOpAlloc<=p->nOp );\n  if( growOpArray(p, 1) ) return 1;\n  assert( p->nOpAlloc>p->nOp );\n  return sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n}\nint sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){\n  int i;\n  VdbeOp *pOp;\n\n  i = p->nOp;\n  assert( p->magic==VDBE_MAGIC_INIT );\n  assert( op>=0 && op<0xff );\n  if( p->nOpAlloc<=i ){\n    return growOp3(p, op, p1, p2, p3);\n  }\n  p->nOp++;\n  pOp = &p->aOp[i];\n  pOp->opcode = (u8)op;\n  pOp->p5 = 0;\n  pOp->p1 = p1;\n  pOp->p2 = p2;\n  pOp->p3 = p3;\n  pOp->p4.p = 0;\n  pOp->p4type = P4_NOTUSED;\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n  pOp->zComment = 0;\n#endif\n#ifdef SQLITE_DEBUG\n  if( p->db->flags & SQLITE_VdbeAddopTrace ){\n    sqlite3VdbePrintOp(0, i, &p->aOp[i]);\n    test_addop_breakpoint();\n  }\n#endif\n#ifdef VDBE_PROFILE\n  pOp->cycles = 0;\n  pOp->cnt = 0;\n#endif\n#ifdef SQLITE_VDBE_COVERAGE\n  pOp->iSrcLine = 0;\n#endif\n  return i;\n}\nint sqlite3VdbeAddOp0(Vdbe *p, int op){\n  return sqlite3VdbeAddOp3(p, op, 0, 0, 0);\n}\nint sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){\n  return sqlite3VdbeAddOp3(p, op, p1, 0, 0);\n}\nint sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){\n  return sqlite3VdbeAddOp3(p, op, p1, p2, 0);\n}\n\n/* Generate code for an unconditional jump to instruction iDest\n*/\nint sqlite3VdbeGoto(Vdbe *p, int iDest){\n  return sqlite3VdbeAddOp3(p, OP_Goto, 0, iDest, 0);\n}\n\n/* Generate code to cause the string zStr to be loaded into\n** register iDest\n*/\nint sqlite3VdbeLoadString(Vdbe *p, int iDest, const char *zStr){\n  return sqlite3VdbeAddOp4(p, OP_String8, 0, iDest, 0, zStr, 0);\n}\n\n/*\n** Generate code that initializes multiple registers to string or integer\n** constants.  The registers begin with iDest and increase consecutively.\n** One register is initialized for each characgter in zTypes[].  For each\n** \"s\" character in zTypes[], the register is a string if the argument is\n** not NULL, or OP_Null if the value is a null pointer.  For each \"i\" character\n** in zTypes[], the register is initialized to an integer.\n**\n** If the input string does not end with \"X\" then an OP_ResultRow instruction\n** is generated for the values inserted.\n*/\nvoid sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes, ...){\n  va_list ap;\n  int i;\n  char c;\n  va_start(ap, zTypes);\n  for(i=0; (c = zTypes[i])!=0; i++){\n    if( c=='s' ){\n      const char *z = va_arg(ap, const char*);\n      sqlite3VdbeAddOp4(p, z==0 ? OP_Null : OP_String8, 0, iDest+i, 0, z, 0);\n    }else if( c=='i' ){\n      sqlite3VdbeAddOp2(p, OP_Integer, va_arg(ap, int), iDest+i);\n    }else{\n      goto skip_op_resultrow;\n    }\n  }\n  sqlite3VdbeAddOp2(p, OP_ResultRow, iDest, i);\nskip_op_resultrow:\n  va_end(ap);\n}\n\n/*\n** Add an opcode that includes the p4 value as a pointer.\n*/\nint sqlite3VdbeAddOp4(\n  Vdbe *p,            /* Add the opcode to this VM */\n  int op,             /* The new opcode */\n  int p1,             /* The P1 operand */\n  int p2,             /* The P2 operand */\n  int p3,             /* The P3 operand */\n  const char *zP4,    /* The P4 operand */\n  int p4type          /* P4 operand type */\n){\n  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n  sqlite3VdbeChangeP4(p, addr, zP4, p4type);\n  return addr;\n}\n\n/*\n** Add an OP_Function or OP_PureFunc opcode.\n**\n** The eCallCtx argument is information (typically taken from Expr.op2)\n** that describes the calling context of the function.  0 means a general\n** function call.  NC_IsCheck means called by a check constraint,\n** NC_IdxExpr means called as part of an index expression.  NC_PartIdx\n** means in the WHERE clause of a partial index.  NC_GenCol means called\n** while computing a generated column value.  0 is the usual case.\n*/\nint sqlite3VdbeAddFunctionCall(\n  Parse *pParse,        /* Parsing context */\n  int p1,               /* Constant argument mask */\n  int p2,               /* First argument register */\n  int p3,               /* Register into which results are written */\n  int nArg,             /* Number of argument */\n  const FuncDef *pFunc, /* The function to be invoked */\n  int eCallCtx          /* Calling context */\n){\n  Vdbe *v = pParse->pVdbe;\n  int nByte;\n  int addr;\n  sqlite3_context *pCtx;\n  assert( v );\n  nByte = sizeof(*pCtx) + (nArg-1)*sizeof(sqlite3_value*);\n  pCtx = sqlite3DbMallocRawNN(pParse->db, nByte);\n  if( pCtx==0 ){\n    assert( pParse->db->mallocFailed );\n    freeEphemeralFunction(pParse->db, (FuncDef*)pFunc);\n    return 0;\n  }\n  pCtx->pOut = 0;\n  pCtx->pFunc = (FuncDef*)pFunc;\n  pCtx->pVdbe = 0;\n  pCtx->isError = 0;\n  pCtx->argc = nArg;\n  pCtx->iOp = sqlite3VdbeCurrentAddr(v);\n  addr = sqlite3VdbeAddOp4(v, eCallCtx ? OP_PureFunc : OP_Function,\n                           p1, p2, p3, (char*)pCtx, P4_FUNCCTX);\n  sqlite3VdbeChangeP5(v, eCallCtx & NC_SelfRef);\n  return addr;\n}\n\n/*\n** Add an opcode that includes the p4 value with a P4_INT64 or\n** P4_REAL type.\n*/\nint sqlite3VdbeAddOp4Dup8(\n  Vdbe *p,            /* Add the opcode to this VM */\n  int op,             /* The new opcode */\n  int p1,             /* The P1 operand */\n  int p2,             /* The P2 operand */\n  int p3,             /* The P3 operand */\n  const u8 *zP4,      /* The P4 operand */\n  int p4type          /* P4 operand type */\n){\n  char *p4copy = sqlite3DbMallocRawNN(sqlite3VdbeDb(p), 8);\n  if( p4copy ) memcpy(p4copy, zP4, 8);\n  return sqlite3VdbeAddOp4(p, op, p1, p2, p3, p4copy, p4type);\n}\n\n#ifndef SQLITE_OMIT_EXPLAIN\n/*\n** Return the address of the current EXPLAIN QUERY PLAN baseline.\n** 0 means \"none\".\n*/\nint sqlite3VdbeExplainParent(Parse *pParse){\n  VdbeOp *pOp;\n  if( pParse->addrExplain==0 ) return 0;\n  pOp = sqlite3VdbeGetOp(pParse->pVdbe, pParse->addrExplain);\n  return pOp->p2;\n}\n\n/*\n** Set a debugger breakpoint on the following routine in order to\n** monitor the EXPLAIN QUERY PLAN code generation.\n*/\n#if defined(SQLITE_DEBUG)\nvoid sqlite3ExplainBreakpoint(const char *z1, const char *z2){\n  (void)z1;\n  (void)z2;\n}\n#endif\n\n/*\n** Add a new OP_ opcode.\n**\n** If the bPush flag is true, then make this opcode the parent for\n** subsequent Explains until sqlite3VdbeExplainPop() is called.\n*/\nvoid sqlite3VdbeExplain(Parse *pParse, u8 bPush, const char *zFmt, ...){\n#ifndef SQLITE_DEBUG\n  /* Always include the OP_Explain opcodes if SQLITE_DEBUG is defined.\n  ** But omit them (for performance) during production builds */\n  if( pParse->explain==2 )\n#endif\n  {\n    char *zMsg;\n    Vdbe *v;\n    va_list ap;\n    int iThis;\n    va_start(ap, zFmt);\n    zMsg = sqlite3VMPrintf(pParse->db, zFmt, ap);\n    va_end(ap);\n    v = pParse->pVdbe;\n    iThis = v->nOp;\n    sqlite3VdbeAddOp4(v, OP_Explain, iThis, pParse->addrExplain, 0,\n                      zMsg, P4_DYNAMIC);\n    sqlite3ExplainBreakpoint(bPush?\"PUSH\":\"\", sqlite3VdbeGetOp(v,-1)->p4.z);\n    if( bPush){\n      pParse->addrExplain = iThis;\n    }\n  }\n}\n\n/*\n** Pop the EXPLAIN QUERY PLAN stack one level.\n*/\nvoid sqlite3VdbeExplainPop(Parse *pParse){\n  sqlite3ExplainBreakpoint(\"POP\", 0);\n  pParse->addrExplain = sqlite3VdbeExplainParent(pParse);\n}\n#endif /* SQLITE_OMIT_EXPLAIN */\n\n/*\n** Add an OP_ParseSchema opcode.  This routine is broken out from\n** sqlite3VdbeAddOp4() since it needs to also needs to mark all btrees\n** as having been used.\n**\n** The zWhere string must have been obtained from sqlite3_malloc().\n** This routine will take ownership of the allocated memory.\n*/\nvoid sqlite3VdbeAddParseSchemaOp(Vdbe *p, int iDb, char *zWhere){\n  int j;\n  sqlite3VdbeAddOp4(p, OP_ParseSchema, iDb, 0, 0, zWhere, P4_DYNAMIC);\n  for(j=0; j<p->db->nDb; j++) sqlite3VdbeUsesBtree(p, j);\n}\n\n/*\n** Add an opcode that includes the p4 value as an integer.\n*/\nint sqlite3VdbeAddOp4Int(\n  Vdbe *p,            /* Add the opcode to this VM */\n  int op,             /* The new opcode */\n  int p1,             /* The P1 operand */\n  int p2,             /* The P2 operand */\n  int p3,             /* The P3 operand */\n  int p4              /* The P4 operand as an integer */\n){\n  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n  if( p->db->mallocFailed==0 ){\n    VdbeOp *pOp = &p->aOp[addr];\n    pOp->p4type = P4_INT32;\n    pOp->p4.i = p4;\n  }\n  return addr;\n}\n\n/* Insert the end of a co-routine\n*/\nvoid sqlite3VdbeEndCoroutine(Vdbe *v, int regYield){\n  sqlite3VdbeAddOp1(v, OP_EndCoroutine, regYield);\n\n  /* Clear the temporary register cache, thereby ensuring that each\n  ** co-routine has its own independent set of registers, because co-routines\n  ** might expect their registers to be preserved across an OP_Yield, and\n  ** that could cause problems if two or more co-routines are using the same\n  ** temporary register.\n  */\n  v->pParse->nTempReg = 0;\n  v->pParse->nRangeReg = 0;\n}\n\n/*\n** Create a new symbolic label for an instruction that has yet to be\n** coded.  The symbolic label is really just a negative number.  The\n** label can be used as the P2 value of an operation.  Later, when\n** the label is resolved to a specific address, the VDBE will scan\n** through its operation list and change all values of P2 which match\n** the label into the resolved address.\n**\n** The VDBE knows that a P2 value is a label because labels are\n** always negative and P2 values are suppose to be non-negative.\n** Hence, a negative P2 value is a label that has yet to be resolved.\n** (Later:) This is only true for opcodes that have the OPFLG_JUMP\n** property.\n**\n** Variable usage notes:\n**\n**     Parse.aLabel[x]     Stores the address that the x-th label resolves\n**                         into.  For testing (SQLITE_DEBUG), unresolved\n**                         labels stores -1, but that is not required.\n**     Parse.nLabelAlloc   Number of slots allocated to Parse.aLabel[]\n**     Parse.nLabel        The *negative* of the number of labels that have\n**                         been issued.  The negative is stored because\n**                         that gives a performance improvement over storing\n**                         the equivalent positive value.\n*/\nint sqlite3VdbeMakeLabel(Parse *pParse){\n  return --pParse->nLabel;\n}\n\n/*\n** Resolve label \"x\" to be the address of the next instruction to\n** be inserted.  The parameter \"x\" must have been obtained from\n** a prior call to sqlite3VdbeMakeLabel().\n*/\nstatic SQLITE_NOINLINE void resizeResolveLabel(Parse *p, Vdbe *v, int j){\n  int nNewSize = 10 - p->nLabel;\n  p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel,\n                     nNewSize*sizeof(p->aLabel[0]));\n  if( p->aLabel==0 ){\n    p->nLabelAlloc = 0;\n  }else{\n#ifdef SQLITE_DEBUG\n    int i;\n    for(i=p->nLabelAlloc; i<nNewSize; i++) p->aLabel[i] = -1;\n#endif\n    p->nLabelAlloc = nNewSize;\n    p->aLabel[j] = v->nOp;\n  }\n}\nvoid sqlite3VdbeResolveLabel(Vdbe *v, int x){\n  Parse *p = v->pParse;\n  int j = ADDR(x);\n  assert( v->magic==VDBE_MAGIC_INIT );\n  assert( j<-p->nLabel );\n  assert( j>=0 );\n#ifdef SQLITE_DEBUG\n  if( p->db->flags & SQLITE_VdbeAddopTrace ){\n    printf(\"RESOLVE LABEL %d to %d\\n\", x, v->nOp);\n  }\n#endif\n  if( p->nLabelAlloc + p->nLabel < 0 ){\n    resizeResolveLabel(p,v,j);\n  }else{\n    assert( p->aLabel[j]==(-1) ); /* Labels may only be resolved once */\n    p->aLabel[j] = v->nOp;\n  }\n}\n\n/*\n** Mark the VDBE as one that can only be run one time.\n*/\nvoid sqlite3VdbeRunOnlyOnce(Vdbe *p){\n  p->runOnlyOnce = 1;\n}\n\n/*\n** Mark the VDBE as one that can only be run multiple times.\n*/\nvoid sqlite3VdbeReusable(Vdbe *p){\n  p->runOnlyOnce = 0;\n}\n\n#ifdef SQLITE_DEBUG /* sqlite3AssertMayAbort() logic */\n\n/*\n** The following type and function are used to iterate through all opcodes\n** in a Vdbe main program and each of the sub-programs (triggers) it may \n** invoke directly or indirectly. It should be used as follows:\n**\n**   Op *pOp;\n**   VdbeOpIter sIter;\n**\n**   memset(&sIter, 0, sizeof(sIter));\n**   sIter.v = v;                            // v is of type Vdbe* \n**   while( (pOp = opIterNext(&sIter)) ){\n**     // Do something with pOp\n**   }\n**   sqlite3DbFree(v->db, sIter.apSub);\n** \n*/\ntypedef struct VdbeOpIter VdbeOpIter;\nstruct VdbeOpIter {\n  Vdbe *v;                   /* Vdbe to iterate through the opcodes of */\n  SubProgram **apSub;        /* Array of subprograms */\n  int nSub;                  /* Number of entries in apSub */\n  int iAddr;                 /* Address of next instruction to return */\n  int iSub;                  /* 0 = main program, 1 = first sub-program etc. */\n};\nstatic Op *opIterNext(VdbeOpIter *p){\n  Vdbe *v = p->v;\n  Op *pRet = 0;\n  Op *aOp;\n  int nOp;\n\n  if( p->iSub<=p->nSub ){\n\n    if( p->iSub==0 ){\n      aOp = v->aOp;\n      nOp = v->nOp;\n    }else{\n      aOp = p->apSub[p->iSub-1]->aOp;\n      nOp = p->apSub[p->iSub-1]->nOp;\n    }\n    assert( p->iAddr<nOp );\n\n    pRet = &aOp[p->iAddr];\n    p->iAddr++;\n    if( p->iAddr==nOp ){\n      p->iSub++;\n      p->iAddr = 0;\n    }\n  \n    if( pRet->p4type==P4_SUBPROGRAM ){\n      int nByte = (p->nSub+1)*sizeof(SubProgram*);\n      int j;\n      for(j=0; j<p->nSub; j++){\n        if( p->apSub[j]==pRet->p4.pProgram ) break;\n      }\n      if( j==p->nSub ){\n        p->apSub = sqlite3DbReallocOrFree(v->db, p->apSub, nByte);\n        if( !p->apSub ){\n          pRet = 0;\n        }else{\n          p->apSub[p->nSub++] = pRet->p4.pProgram;\n        }\n      }\n    }\n  }\n\n  return pRet;\n}\n\n/*\n** Check if the program stored in the VM associated with pParse may\n** throw an ABORT exception (causing the statement, but not entire transaction\n** to be rolled back). This condition is true if the main program or any\n** sub-programs contains any of the following:\n**\n**   *  OP_Halt with P1=SQLITE_CONSTRAINT and P2=OE_Abort.\n**   *  OP_HaltIfNull with P1=SQLITE_CONSTRAINT and P2=OE_Abort.\n**   *  OP_Destroy\n**   *  OP_VUpdate\n**   *  OP_VCreate\n**   *  OP_VRename\n**   *  OP_FkCounter with P2==0 (immediate foreign key constraint)\n**   *  OP_CreateBtree/BTREE_INTKEY and OP_InitCoroutine \n**      (for CREATE TABLE AS SELECT ...)\n**\n** Then check that the value of Parse.mayAbort is true if an\n** ABORT may be thrown, or false otherwise. Return true if it does\n** match, or false otherwise. This function is intended to be used as\n** part of an assert statement in the compiler. Similar to:\n**\n**   assert( sqlite3VdbeAssertMayAbort(pParse->pVdbe, pParse->mayAbort) );\n*/\nint sqlite3VdbeAssertMayAbort(Vdbe *v, int mayAbort){\n  int hasAbort = 0;\n  int hasFkCounter = 0;\n  int hasCreateTable = 0;\n  int hasCreateIndex = 0;\n  int hasInitCoroutine = 0;\n  Op *pOp;\n  VdbeOpIter sIter;\n  memset(&sIter, 0, sizeof(sIter));\n  sIter.v = v;\n\n  while( (pOp = opIterNext(&sIter))!=0 ){\n    int opcode = pOp->opcode;\n    if( opcode==OP_Destroy || opcode==OP_VUpdate || opcode==OP_VRename \n     || opcode==OP_VDestroy\n     || opcode==OP_VCreate\n     || (opcode==OP_ParseSchema && pOp->p4.z==0)\n     || ((opcode==OP_Halt || opcode==OP_HaltIfNull) \n      && ((pOp->p1)!=SQLITE_OK && pOp->p2==OE_Abort))\n    ){\n      hasAbort = 1;\n      break;\n    }\n    if( opcode==OP_CreateBtree && pOp->p3==BTREE_INTKEY ) hasCreateTable = 1;\n    if( mayAbort ){\n      /* hasCreateIndex may also be set for some DELETE statements that use\n      ** OP_Clear. So this routine may end up returning true in the case \n      ** where a \"DELETE FROM tbl\" has a statement-journal but does not\n      ** require one. This is not so bad - it is an inefficiency, not a bug. */\n      if( opcode==OP_CreateBtree && pOp->p3==BTREE_BLOBKEY ) hasCreateIndex = 1;\n      if( opcode==OP_Clear ) hasCreateIndex = 1;\n    }\n    if( opcode==OP_InitCoroutine ) hasInitCoroutine = 1;\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n    if( opcode==OP_FkCounter && pOp->p1==0 && pOp->p2==1 ){\n      hasFkCounter = 1;\n    }\n#endif\n  }\n  sqlite3DbFree(v->db, sIter.apSub);\n\n  /* Return true if hasAbort==mayAbort. Or if a malloc failure occurred.\n  ** If malloc failed, then the while() loop above may not have iterated\n  ** through all opcodes and hasAbort may be set incorrectly. Return\n  ** true for this case to prevent the assert() in the callers frame\n  ** from failing.  */\n  return ( v->db->mallocFailed || hasAbort==mayAbort || hasFkCounter\n        || (hasCreateTable && hasInitCoroutine) || hasCreateIndex\n  );\n}\n#endif /* SQLITE_DEBUG - the sqlite3AssertMayAbort() function */\n\n#ifdef SQLITE_DEBUG\n/*\n** Increment the nWrite counter in the VDBE if the cursor is not an\n** ephemeral cursor, or if the cursor argument is NULL.\n*/\nvoid sqlite3VdbeIncrWriteCounter(Vdbe *p, VdbeCursor *pC){\n  if( pC==0\n   || (pC->eCurType!=CURTYPE_SORTER\n       && pC->eCurType!=CURTYPE_PSEUDO\n       && !pC->isEphemeral)\n  ){\n    p->nWrite++;\n  }\n}\n#endif\n\n#ifdef SQLITE_DEBUG\n/*\n** Assert if an Abort at this point in time might result in a corrupt\n** database.\n*/\nvoid sqlite3VdbeAssertAbortable(Vdbe *p){\n  assert( p->nWrite==0 || p->usesStmtJournal );\n}\n#endif\n\n/*\n** This routine is called after all opcodes have been inserted.  It loops\n** through all the opcodes and fixes up some details.\n**\n** (1) For each jump instruction with a negative P2 value (a label)\n**     resolve the P2 value to an actual address.\n**\n** (2) Compute the maximum number of arguments used by any SQL function\n**     and store that value in *pMaxFuncArgs.\n**\n** (3) Update the Vdbe.readOnly and Vdbe.bIsReader flags to accurately\n**     indicate what the prepared statement actually does.\n**\n** (4) Initialize the p4.xAdvance pointer on opcodes that use it.\n**\n** (5) Reclaim the memory allocated for storing labels.\n**\n** This routine will only function correctly if the mkopcodeh.tcl generator\n** script numbers the opcodes correctly.  Changes to this routine must be\n** coordinated with changes to mkopcodeh.tcl.\n*/\nstatic void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){\n  int nMaxArgs = *pMaxFuncArgs;\n  Op *pOp;\n  Parse *pParse = p->pParse;\n  int *aLabel = pParse->aLabel;\n  p->readOnly = 1;\n  p->bIsReader = 0;\n  pOp = &p->aOp[p->nOp-1];\n  while(1){\n\n    /* Only JUMP opcodes and the short list of special opcodes in the switch\n    ** below need to be considered.  The mkopcodeh.tcl generator script groups\n    ** all these opcodes together near the front of the opcode list.  Skip\n    ** any opcode that does not need processing by virtual of the fact that\n    ** it is larger than SQLITE_MX_JUMP_OPCODE, as a performance optimization.\n    */\n    if( pOp->opcode<=SQLITE_MX_JUMP_OPCODE ){\n      /* NOTE: Be sure to update mkopcodeh.tcl when adding or removing\n      ** cases from this switch! */\n      switch( pOp->opcode ){\n        case OP_Transaction: {\n          if( pOp->p2!=0 ) p->readOnly = 0;\n          /* fall thru */\n        }\n        case OP_AutoCommit:\n        case OP_Savepoint: {\n          p->bIsReader = 1;\n          break;\n        }\n#ifndef SQLITE_OMIT_WAL\n        case OP_Checkpoint:\n#endif\n        case OP_Vacuum:\n        case OP_JournalMode: {\n          p->readOnly = 0;\n          p->bIsReader = 1;\n          break;\n        }\n        case OP_Next:\n        case OP_SorterNext: {\n          pOp->p4.xAdvance = sqlite3BtreeNext;\n          pOp->p4type = P4_ADVANCE;\n          /* The code generator never codes any of these opcodes as a jump\n          ** to a label.  They are always coded as a jump backwards to a \n          ** known address */\n          assert( pOp->p2>=0 );\n          break;\n        }\n        case OP_Prev: {\n          pOp->p4.xAdvance = sqlite3BtreePrevious;\n          pOp->p4type = P4_ADVANCE;\n          /* The code generator never codes any of these opcodes as a jump\n          ** to a label.  They are always coded as a jump backwards to a \n          ** known address */\n          assert( pOp->p2>=0 );\n          break;\n        }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n        case OP_VUpdate: {\n          if( pOp->p2>nMaxArgs ) nMaxArgs = pOp->p2;\n          break;\n        }\n        case OP_VFilter: {\n          int n;\n          assert( (pOp - p->aOp) >= 3 );\n          assert( pOp[-1].opcode==OP_Integer );\n          n = pOp[-1].p1;\n          if( n>nMaxArgs ) nMaxArgs = n;\n          /* Fall through into the default case */\n        }\n#endif\n        default: {\n          if( pOp->p2<0 ){\n            /* The mkopcodeh.tcl script has so arranged things that the only\n            ** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to\n            ** have non-negative values for P2. */\n            assert( (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_JUMP)!=0 );\n            assert( ADDR(pOp->p2)<-pParse->nLabel );\n            pOp->p2 = aLabel[ADDR(pOp->p2)];\n          }\n          break;\n        }\n      }\n      /* The mkopcodeh.tcl script has so arranged things that the only\n      ** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to\n      ** have non-negative values for P2. */\n      assert( (sqlite3OpcodeProperty[pOp->opcode]&OPFLG_JUMP)==0 || pOp->p2>=0);\n    }\n    if( pOp==p->aOp ) break;\n    pOp--;\n  }\n  sqlite3DbFree(p->db, pParse->aLabel);\n  pParse->aLabel = 0;\n  pParse->nLabel = 0;\n  *pMaxFuncArgs = nMaxArgs;\n  assert( p->bIsReader!=0 || DbMaskAllZero(p->btreeMask) );\n}\n\n/*\n** Return the address of the next instruction to be inserted.\n*/\nint sqlite3VdbeCurrentAddr(Vdbe *p){\n  assert( p->magic==VDBE_MAGIC_INIT );\n  return p->nOp;\n}\n\n/*\n** Verify that at least N opcode slots are available in p without\n** having to malloc for more space (except when compiled using\n** SQLITE_TEST_REALLOC_STRESS).  This interface is used during testing\n** to verify that certain calls to sqlite3VdbeAddOpList() can never\n** fail due to a OOM fault and hence that the return value from\n** sqlite3VdbeAddOpList() will always be non-NULL.\n*/\n#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)\nvoid sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N){\n  assert( p->nOp + N <= p->nOpAlloc );\n}\n#endif\n\n/*\n** Verify that the VM passed as the only argument does not contain\n** an OP_ResultRow opcode. Fail an assert() if it does. This is used\n** by code in pragma.c to ensure that the implementation of certain\n** pragmas comports with the flags specified in the mkpragmatab.tcl\n** script.\n*/\n#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)\nvoid sqlite3VdbeVerifyNoResultRow(Vdbe *p){\n  int i;\n  for(i=0; i<p->nOp; i++){\n    assert( p->aOp[i].opcode!=OP_ResultRow );\n  }\n}\n#endif\n\n/*\n** Generate code (a single OP_Abortable opcode) that will\n** verify that the VDBE program can safely call Abort in the current\n** context.\n*/\n#if defined(SQLITE_DEBUG)\nvoid sqlite3VdbeVerifyAbortable(Vdbe *p, int onError){\n  if( onError==OE_Abort ) sqlite3VdbeAddOp0(p, OP_Abortable);\n}\n#endif\n\n/*\n** This function returns a pointer to the array of opcodes associated with\n** the Vdbe passed as the first argument. It is the callers responsibility\n** to arrange for the returned array to be eventually freed using the \n** vdbeFreeOpArray() function.\n**\n** Before returning, *pnOp is set to the number of entries in the returned\n** array. Also, *pnMaxArg is set to the larger of its current value and \n** the number of entries in the Vdbe.apArg[] array required to execute the \n** returned program.\n*/\nVdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg){\n  VdbeOp *aOp = p->aOp;\n  assert( aOp && !p->db->mallocFailed );\n\n  /* Check that sqlite3VdbeUsesBtree() was not called on this VM */\n  assert( DbMaskAllZero(p->btreeMask) );\n\n  resolveP2Values(p, pnMaxArg);\n  *pnOp = p->nOp;\n  p->aOp = 0;\n  return aOp;\n}\n\n/*\n** Add a whole list of operations to the operation stack.  Return a\n** pointer to the first operation inserted.\n**\n** Non-zero P2 arguments to jump instructions are automatically adjusted\n** so that the jump target is relative to the first operation inserted.\n*/\nVdbeOp *sqlite3VdbeAddOpList(\n  Vdbe *p,                     /* Add opcodes to the prepared statement */\n  int nOp,                     /* Number of opcodes to add */\n  VdbeOpList const *aOp,       /* The opcodes to be added */\n  int iLineno                  /* Source-file line number of first opcode */\n){\n  int i;\n  VdbeOp *pOut, *pFirst;\n  assert( nOp>0 );\n  assert( p->magic==VDBE_MAGIC_INIT );\n  if( p->nOp + nOp > p->nOpAlloc && growOpArray(p, nOp) ){\n    return 0;\n  }\n  pFirst = pOut = &p->aOp[p->nOp];\n  for(i=0; i<nOp; i++, aOp++, pOut++){\n    pOut->opcode = aOp->opcode;\n    pOut->p1 = aOp->p1;\n    pOut->p2 = aOp->p2;\n    assert( aOp->p2>=0 );\n    if( (sqlite3OpcodeProperty[aOp->opcode] & OPFLG_JUMP)!=0 && aOp->p2>0 ){\n      pOut->p2 += p->nOp;\n    }\n    pOut->p3 = aOp->p3;\n    pOut->p4type = P4_NOTUSED;\n    pOut->p4.p = 0;\n    pOut->p5 = 0;\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n    pOut->zComment = 0;\n#endif\n#ifdef SQLITE_VDBE_COVERAGE\n    pOut->iSrcLine = iLineno+i;\n#else\n    (void)iLineno;\n#endif\n#ifdef SQLITE_DEBUG\n    if( p->db->flags & SQLITE_VdbeAddopTrace ){\n      sqlite3VdbePrintOp(0, i+p->nOp, &p->aOp[i+p->nOp]);\n    }\n#endif\n  }\n  p->nOp += nOp;\n  return pFirst;\n}\n\n#if defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n/*\n** Add an entry to the array of counters managed by sqlite3_stmt_scanstatus().\n*/\nvoid sqlite3VdbeScanStatus(\n  Vdbe *p,                        /* VM to add scanstatus() to */\n  int addrExplain,                /* Address of OP_Explain (or 0) */\n  int addrLoop,                   /* Address of loop counter */ \n  int addrVisit,                  /* Address of rows visited counter */\n  LogEst nEst,                    /* Estimated number of output rows */\n  const char *zName               /* Name of table or index being scanned */\n){\n  sqlite3_int64 nByte = (p->nScan+1) * sizeof(ScanStatus);\n  ScanStatus *aNew;\n  aNew = (ScanStatus*)sqlite3DbRealloc(p->db, p->aScan, nByte);\n  if( aNew ){\n    ScanStatus *pNew = &aNew[p->nScan++];\n    pNew->addrExplain = addrExplain;\n    pNew->addrLoop = addrLoop;\n    pNew->addrVisit = addrVisit;\n    pNew->nEst = nEst;\n    pNew->zName = sqlite3DbStrDup(p->db, zName);\n    p->aScan = aNew;\n  }\n}\n#endif\n\n\n/*\n** Change the value of the opcode, or P1, P2, P3, or P5 operands\n** for a specific instruction.\n*/\nvoid sqlite3VdbeChangeOpcode(Vdbe *p, int addr, u8 iNewOpcode){\n  sqlite3VdbeGetOp(p,addr)->opcode = iNewOpcode;\n}\nvoid sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){\n  sqlite3VdbeGetOp(p,addr)->p1 = val;\n}\nvoid sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){\n  sqlite3VdbeGetOp(p,addr)->p2 = val;\n}\nvoid sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){\n  sqlite3VdbeGetOp(p,addr)->p3 = val;\n}\nvoid sqlite3VdbeChangeP5(Vdbe *p, u16 p5){\n  assert( p->nOp>0 || p->db->mallocFailed );\n  if( p->nOp>0 ) p->aOp[p->nOp-1].p5 = p5;\n}\n\n/*\n** Change the P2 operand of instruction addr so that it points to\n** the address of the next instruction to be coded.\n*/\nvoid sqlite3VdbeJumpHere(Vdbe *p, int addr){\n  sqlite3VdbeChangeP2(p, addr, p->nOp);\n}\n\n\n/*\n** If the input FuncDef structure is ephemeral, then free it.  If\n** the FuncDef is not ephermal, then do nothing.\n*/\nstatic void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){\n  if( (pDef->funcFlags & SQLITE_FUNC_EPHEM)!=0 ){\n    sqlite3DbFreeNN(db, pDef);\n  }\n}\n\n/*\n** Delete a P4 value if necessary.\n*/\nstatic SQLITE_NOINLINE void freeP4Mem(sqlite3 *db, Mem *p){\n  if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);\n  sqlite3DbFreeNN(db, p);\n}\nstatic SQLITE_NOINLINE void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p){\n  freeEphemeralFunction(db, p->pFunc);\n  sqlite3DbFreeNN(db, p);\n}\nstatic void freeP4(sqlite3 *db, int p4type, void *p4){\n  assert( db );\n  switch( p4type ){\n    case P4_FUNCCTX: {\n      freeP4FuncCtx(db, (sqlite3_context*)p4);\n      break;\n    }\n    case P4_REAL:\n    case P4_INT64:\n    case P4_DYNAMIC:\n    case P4_DYNBLOB:\n    case P4_INTARRAY: {\n      sqlite3DbFree(db, p4);\n      break;\n    }\n    case P4_KEYINFO: {\n      if( db->pnBytesFreed==0 ) sqlite3KeyInfoUnref((KeyInfo*)p4);\n      break;\n    }\n#ifdef SQLITE_ENABLE_CURSOR_HINTS\n    case P4_EXPR: {\n      sqlite3ExprDelete(db, (Expr*)p4);\n      break;\n    }\n#endif\n    case P4_FUNCDEF: {\n      freeEphemeralFunction(db, (FuncDef*)p4);\n      break;\n    }\n    case P4_MEM: {\n      if( db->pnBytesFreed==0 ){\n        sqlite3ValueFree((sqlite3_value*)p4);\n      }else{\n        freeP4Mem(db, (Mem*)p4);\n      }\n      break;\n    }\n    case P4_VTAB : {\n      if( db->pnBytesFreed==0 ) sqlite3VtabUnlock((VTable *)p4);\n      break;\n    }\n  }\n}\n\n/*\n** Free the space allocated for aOp and any p4 values allocated for the\n** opcodes contained within. If aOp is not NULL it is assumed to contain \n** nOp entries. \n*/\nstatic void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){\n  if( aOp ){\n    Op *pOp;\n    for(pOp=&aOp[nOp-1]; pOp>=aOp; pOp--){\n      if( pOp->p4type <= P4_FREE_IF_LE ) freeP4(db, pOp->p4type, pOp->p4.p);\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n      sqlite3DbFree(db, pOp->zComment);\n#endif     \n    }\n    sqlite3DbFreeNN(db, aOp);\n  }\n}\n\n/*\n** Link the SubProgram object passed as the second argument into the linked\n** list at Vdbe.pSubProgram. This list is used to delete all sub-program\n** objects when the VM is no longer required.\n*/\nvoid sqlite3VdbeLinkSubProgram(Vdbe *pVdbe, SubProgram *p){\n  p->pNext = pVdbe->pProgram;\n  pVdbe->pProgram = p;\n}\n\n/*\n** Return true if the given Vdbe has any SubPrograms.\n*/\nint sqlite3VdbeHasSubProgram(Vdbe *pVdbe){\n  return pVdbe->pProgram!=0;\n}\n\n/*\n** Change the opcode at addr into OP_Noop\n*/\nint sqlite3VdbeChangeToNoop(Vdbe *p, int addr){\n  VdbeOp *pOp;\n  if( p->db->mallocFailed ) return 0;\n  assert( addr>=0 && addr<p->nOp );\n  pOp = &p->aOp[addr];\n  freeP4(p->db, pOp->p4type, pOp->p4.p);\n  pOp->p4type = P4_NOTUSED;\n  pOp->p4.z = 0;\n  pOp->opcode = OP_Noop;\n  return 1;\n}\n\n/*\n** If the last opcode is \"op\" and it is not a jump destination,\n** then remove it.  Return true if and only if an opcode was removed.\n*/\nint sqlite3VdbeDeletePriorOpcode(Vdbe *p, u8 op){\n  if( p->nOp>0 && p->aOp[p->nOp-1].opcode==op ){\n    return sqlite3VdbeChangeToNoop(p, p->nOp-1);\n  }else{\n    return 0;\n  }\n}\n\n/*\n** Change the value of the P4 operand for a specific instruction.\n** This routine is useful when a large program is loaded from a\n** static array using sqlite3VdbeAddOpList but we want to make a\n** few minor changes to the program.\n**\n** If n>=0 then the P4 operand is dynamic, meaning that a copy of\n** the string is made into memory obtained from sqlite3_malloc().\n** A value of n==0 means copy bytes of zP4 up to and including the\n** first null byte.  If n>0 then copy n+1 bytes of zP4.\n** \n** Other values of n (P4_STATIC, P4_COLLSEQ etc.) indicate that zP4 points\n** to a string or structure that is guaranteed to exist for the lifetime of\n** the Vdbe. In these cases we can just copy the pointer.\n**\n** If addr<0 then change P4 on the most recently inserted instruction.\n*/\nstatic void SQLITE_NOINLINE vdbeChangeP4Full(\n  Vdbe *p,\n  Op *pOp,\n  const char *zP4,\n  int n\n){\n  if( pOp->p4type ){\n    freeP4(p->db, pOp->p4type, pOp->p4.p);\n    pOp->p4type = 0;\n    pOp->p4.p = 0;\n  }\n  if( n<0 ){\n    sqlite3VdbeChangeP4(p, (int)(pOp - p->aOp), zP4, n);\n  }else{\n    if( n==0 ) n = sqlite3Strlen30(zP4);\n    pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n);\n    pOp->p4type = P4_DYNAMIC;\n  }\n}\nvoid sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){\n  Op *pOp;\n  sqlite3 *db;\n  assert( p!=0 );\n  db = p->db;\n  assert( p->magic==VDBE_MAGIC_INIT );\n  assert( p->aOp!=0 || db->mallocFailed );\n  if( db->mallocFailed ){\n    if( n!=P4_VTAB ) freeP4(db, n, (void*)*(char**)&zP4);\n    return;\n  }\n  assert( p->nOp>0 );\n  assert( addr<p->nOp );\n  if( addr<0 ){\n    addr = p->nOp - 1;\n  }\n  pOp = &p->aOp[addr];\n  if( n>=0 || pOp->p4type ){\n    vdbeChangeP4Full(p, pOp, zP4, n);\n    return;\n  }\n  if( n==P4_INT32 ){\n    /* Note: this cast is safe, because the origin data point was an int\n    ** that was cast to a (const char *). */\n    pOp->p4.i = SQLITE_PTR_TO_INT(zP4);\n    pOp->p4type = P4_INT32;\n  }else if( zP4!=0 ){\n    assert( n<0 );\n    pOp->p4.p = (void*)zP4;\n    pOp->p4type = (signed char)n;\n    if( n==P4_VTAB ) sqlite3VtabLock((VTable*)zP4);\n  }\n}\n\n/*\n** Change the P4 operand of the most recently coded instruction \n** to the value defined by the arguments.  This is a high-speed\n** version of sqlite3VdbeChangeP4().\n**\n** The P4 operand must not have been previously defined.  And the new\n** P4 must not be P4_INT32.  Use sqlite3VdbeChangeP4() in either of\n** those cases.\n*/\nvoid sqlite3VdbeAppendP4(Vdbe *p, void *pP4, int n){\n  VdbeOp *pOp;\n  assert( n!=P4_INT32 && n!=P4_VTAB );\n  assert( n<=0 );\n  if( p->db->mallocFailed ){\n    freeP4(p->db, n, pP4);\n  }else{\n    assert( pP4!=0 );\n    assert( p->nOp>0 );\n    pOp = &p->aOp[p->nOp-1];\n    assert( pOp->p4type==P4_NOTUSED );\n    pOp->p4type = n;\n    pOp->p4.p = pP4;\n  }\n}\n\n/*\n** Set the P4 on the most recently added opcode to the KeyInfo for the\n** index given.\n*/\nvoid sqlite3VdbeSetP4KeyInfo(Parse *pParse, Index *pIdx){\n  Vdbe *v = pParse->pVdbe;\n  KeyInfo *pKeyInfo;\n  assert( v!=0 );\n  assert( pIdx!=0 );\n  pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx);\n  if( pKeyInfo ) sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);\n}\n\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n/*\n** Change the comment on the most recently coded instruction.  Or\n** insert a No-op and add the comment to that new instruction.  This\n** makes the code easier to read during debugging.  None of this happens\n** in a production build.\n*/\nstatic void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed\n          || p->pParse->nErr>0 );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}\nvoid sqlite3VdbeComment(Vdbe *p, const char *zFormat, ...){\n  va_list ap;\n  if( p ){\n    va_start(ap, zFormat);\n    vdbeVComment(p, zFormat, ap);\n    va_end(ap);\n  }\n}\nvoid sqlite3VdbeNoopComment(Vdbe *p, const char *zFormat, ...){\n  va_list ap;\n  if( p ){\n    sqlite3VdbeAddOp0(p, OP_Noop);\n    va_start(ap, zFormat);\n    vdbeVComment(p, zFormat, ap);\n    va_end(ap);\n  }\n}\n#endif  /* NDEBUG */\n\n#ifdef SQLITE_VDBE_COVERAGE\n/*\n** Set the value if the iSrcLine field for the previously coded instruction.\n*/\nvoid sqlite3VdbeSetLineNumber(Vdbe *v, int iLine){\n  sqlite3VdbeGetOp(v,-1)->iSrcLine = iLine;\n}\n#endif /* SQLITE_VDBE_COVERAGE */\n\n/*\n** Return the opcode for a given address.  If the address is -1, then\n** return the most recently inserted opcode.\n**\n** If a memory allocation error has occurred prior to the calling of this\n** routine, then a pointer to a dummy VdbeOp will be returned.  That opcode\n** is readable but not writable, though it is cast to a writable value.\n** The return of a dummy opcode allows the call to continue functioning\n** after an OOM fault without having to check to see if the return from \n** this routine is a valid pointer.  But because the dummy.opcode is 0,\n** dummy will never be written to.  This is verified by code inspection and\n** by running with Valgrind.\n*/\nVdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){\n  /* C89 specifies that the constant \"dummy\" will be initialized to all\n  ** zeros, which is correct.  MSVC generates a warning, nevertheless. */\n  static VdbeOp dummy;  /* Ignore the MSVC warning about no initializer */\n  assert( p->magic==VDBE_MAGIC_INIT );\n  if( addr<0 ){\n    addr = p->nOp - 1;\n  }\n  assert( (addr>=0 && addr<p->nOp) || p->db->mallocFailed );\n  if( p->db->mallocFailed ){\n    return (VdbeOp*)&dummy;\n  }else{\n    return &p->aOp[addr];\n  }\n}\n\n#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS)\n/*\n** Return an integer value for one of the parameters to the opcode pOp\n** determined by character c.\n*/\nstatic int translateP(char c, const Op *pOp){\n  if( c=='1' ) return pOp->p1;\n  if( c=='2' ) return pOp->p2;\n  if( c=='3' ) return pOp->p3;\n  if( c=='4' ) return pOp->p4.i;\n  return pOp->p5;\n}\n\n/*\n** Compute a string for the \"comment\" field of a VDBE opcode listing.\n**\n** The Synopsis: field in comments in the vdbe.c source file gets converted\n** to an extra string that is appended to the sqlite3OpcodeName().  In the\n** absence of other comments, this synopsis becomes the comment on the opcode.\n** Some translation occurs:\n**\n**       \"PX\"      ->  \"r[X]\"\n**       \"PX@PY\"   ->  \"r[X..X+Y-1]\"  or \"r[x]\" if y is 0 or 1\n**       \"PX@PY+1\" ->  \"r[X..X+Y]\"    or \"r[x]\" if y is 0\n**       \"PY..PY\"  ->  \"r[X..Y]\"      or \"r[x]\" if y<=x\n*/\nstatic int displayComment(\n  const Op *pOp,     /* The opcode to be commented */\n  const char *zP4,   /* Previously obtained value for P4 */\n  char *zTemp,       /* Write result here */\n  int nTemp          /* Space available in zTemp[] */\n){\n  const char *zOpName;\n  const char *zSynopsis;\n  int nOpName;\n  int ii, jj;\n  char zAlt[50];\n  zOpName = sqlite3OpcodeName(pOp->opcode);\n  nOpName = sqlite3Strlen30(zOpName);\n  if( zOpName[nOpName+1] ){\n    int seenCom = 0;\n    char c;\n    zSynopsis = zOpName += nOpName + 1;\n    if( strncmp(zSynopsis,\"IF \",3)==0 ){\n      if( pOp->p5 & SQLITE_STOREP2 ){\n        sqlite3_snprintf(sizeof(zAlt), zAlt, \"r[P2] = (%s)\", zSynopsis+3);\n      }else{\n        sqlite3_snprintf(sizeof(zAlt), zAlt, \"if %s goto P2\", zSynopsis+3);\n      }\n      zSynopsis = zAlt;\n    }\n    for(ii=jj=0; jj<nTemp-1 && (c = zSynopsis[ii])!=0; ii++){\n      if( c=='P' ){\n        c = zSynopsis[++ii];\n        if( c=='4' ){\n          sqlite3_snprintf(nTemp-jj, zTemp+jj, \"%s\", zP4);\n        }else if( c=='X' ){\n          sqlite3_snprintf(nTemp-jj, zTemp+jj, \"%s\", pOp->zComment);\n          seenCom = 1;\n        }else{\n          int v1 = translateP(c, pOp);\n          int v2;\n          sqlite3_snprintf(nTemp-jj, zTemp+jj, \"%d\", v1);\n          if( strncmp(zSynopsis+ii+1, \"@P\", 2)==0 ){\n            ii += 3;\n            jj += sqlite3Strlen30(zTemp+jj);\n            v2 = translateP(zSynopsis[ii], pOp);\n            if( strncmp(zSynopsis+ii+1,\"+1\",2)==0 ){\n              ii += 2;\n              v2++;\n            }\n            if( v2>1 ){\n              sqlite3_snprintf(nTemp-jj, zTemp+jj, \"..%d\", v1+v2-1);\n            }\n          }else if( strncmp(zSynopsis+ii+1, \"..P3\", 4)==0 && pOp->p3==0 ){\n            ii += 4;\n          }\n        }\n        jj += sqlite3Strlen30(zTemp+jj);\n      }else{\n        zTemp[jj++] = c;\n      }\n    }\n    if( !seenCom && jj<nTemp-5 && pOp->zComment ){\n      sqlite3_snprintf(nTemp-jj, zTemp+jj, \"; %s\", pOp->zComment);\n      jj += sqlite3Strlen30(zTemp+jj);\n    }\n    if( jj<nTemp ) zTemp[jj] = 0;\n  }else if( pOp->zComment ){\n    sqlite3_snprintf(nTemp, zTemp, \"%s\", pOp->zComment);\n    jj = sqlite3Strlen30(zTemp);\n  }else{\n    zTemp[0] = 0;\n    jj = 0;\n  }\n  return jj;\n}\n#endif /* SQLITE_DEBUG */\n\n#if VDBE_DISPLAY_P4 && defined(SQLITE_ENABLE_CURSOR_HINTS)\n/*\n** Translate the P4.pExpr value for an OP_CursorHint opcode into text\n** that can be displayed in the P4 column of EXPLAIN output.\n*/\nstatic void displayP4Expr(StrAccum *p, Expr *pExpr){\n  const char *zOp = 0;\n  switch( pExpr->op ){\n    case TK_STRING:\n      sqlite3_str_appendf(p, \"%Q\", pExpr->u.zToken);\n      break;\n    case TK_INTEGER:\n      sqlite3_str_appendf(p, \"%d\", pExpr->u.iValue);\n      break;\n    case TK_NULL:\n      sqlite3_str_appendf(p, \"NULL\");\n      break;\n    case TK_REGISTER: {\n      sqlite3_str_appendf(p, \"r[%d]\", pExpr->iTable);\n      break;\n    }\n    case TK_COLUMN: {\n      if( pExpr->iColumn<0 ){\n        sqlite3_str_appendf(p, \"rowid\");\n      }else{\n        sqlite3_str_appendf(p, \"c%d\", (int)pExpr->iColumn);\n      }\n      break;\n    }\n    case TK_LT:      zOp = \"LT\";      break;\n    case TK_LE:      zOp = \"LE\";      break;\n    case TK_GT:      zOp = \"GT\";      break;\n    case TK_GE:      zOp = \"GE\";      break;\n    case TK_NE:      zOp = \"NE\";      break;\n    case TK_EQ:      zOp = \"EQ\";      break;\n    case TK_IS:      zOp = \"IS\";      break;\n    case TK_ISNOT:   zOp = \"ISNOT\";   break;\n    case TK_AND:     zOp = \"AND\";     break;\n    case TK_OR:      zOp = \"OR\";      break;\n    case TK_PLUS:    zOp = \"ADD\";     break;\n    case TK_STAR:    zOp = \"MUL\";     break;\n    case TK_MINUS:   zOp = \"SUB\";     break;\n    case TK_REM:     zOp = \"REM\";     break;\n    case TK_BITAND:  zOp = \"BITAND\";  break;\n    case TK_BITOR:   zOp = \"BITOR\";   break;\n    case TK_SLASH:   zOp = \"DIV\";     break;\n    case TK_LSHIFT:  zOp = \"LSHIFT\";  break;\n    case TK_RSHIFT:  zOp = \"RSHIFT\";  break;\n    case TK_CONCAT:  zOp = \"CONCAT\";  break;\n    case TK_UMINUS:  zOp = \"MINUS\";   break;\n    case TK_UPLUS:   zOp = \"PLUS\";    break;\n    case TK_BITNOT:  zOp = \"BITNOT\";  break;\n    case TK_NOT:     zOp = \"NOT\";     break;\n    case TK_ISNULL:  zOp = \"ISNULL\";  break;\n    case TK_NOTNULL: zOp = \"NOTNULL\"; break;\n\n    default:\n      sqlite3_str_appendf(p, \"%s\", \"expr\");\n      break;\n  }\n\n  if( zOp ){\n    sqlite3_str_appendf(p, \"%s(\", zOp);\n    displayP4Expr(p, pExpr->pLeft);\n    if( pExpr->pRight ){\n      sqlite3_str_append(p, \",\", 1);\n      displayP4Expr(p, pExpr->pRight);\n    }\n    sqlite3_str_append(p, \")\", 1);\n  }\n}\n#endif /* VDBE_DISPLAY_P4 && defined(SQLITE_ENABLE_CURSOR_HINTS) */\n\n\n#if VDBE_DISPLAY_P4\n/*\n** Compute a string that describes the P4 parameter for an opcode.\n** Use zTemp for any required temporary buffer space.\n*/\nstatic char *displayP4(Op *pOp, char *zTemp, int nTemp){\n  char *zP4 = zTemp;\n  StrAccum x;\n  assert( nTemp>=20 );\n  sqlite3StrAccumInit(&x, 0, zTemp, nTemp, 0);\n  switch( pOp->p4type ){\n    case P4_KEYINFO: {\n      int j;\n      KeyInfo *pKeyInfo = pOp->p4.pKeyInfo;\n      assert( pKeyInfo->aSortFlags!=0 );\n      sqlite3_str_appendf(&x, \"k(%d\", pKeyInfo->nKeyField);\n      for(j=0; j<pKeyInfo->nKeyField; j++){\n        CollSeq *pColl = pKeyInfo->aColl[j];\n        const char *zColl = pColl ? pColl->zName : \"\";\n        if( strcmp(zColl, \"BINARY\")==0 ) zColl = \"B\";\n        sqlite3_str_appendf(&x, \",%s%s%s\", \n               (pKeyInfo->aSortFlags[j] & KEYINFO_ORDER_DESC) ? \"-\" : \"\", \n               (pKeyInfo->aSortFlags[j] & KEYINFO_ORDER_BIGNULL)? \"N.\" : \"\", \n               zColl);\n      }\n      sqlite3_str_append(&x, \")\", 1);\n      break;\n    }\n#ifdef SQLITE_ENABLE_CURSOR_HINTS\n    case P4_EXPR: {\n      displayP4Expr(&x, pOp->p4.pExpr);\n      break;\n    }\n#endif\n    case P4_COLLSEQ: {\n      CollSeq *pColl = pOp->p4.pColl;\n      sqlite3_str_appendf(&x, \"(%.20s)\", pColl->zName);\n      break;\n    }\n    case P4_FUNCDEF: {\n      FuncDef *pDef = pOp->p4.pFunc;\n      sqlite3_str_appendf(&x, \"%s(%d)\", pDef->zName, pDef->nArg);\n      break;\n    }\n    case P4_FUNCCTX: {\n      FuncDef *pDef = pOp->p4.pCtx->pFunc;\n      sqlite3_str_appendf(&x, \"%s(%d)\", pDef->zName, pDef->nArg);\n      break;\n    }\n    case P4_INT64: {\n      sqlite3_str_appendf(&x, \"%lld\", *pOp->p4.pI64);\n      break;\n    }\n    case P4_INT32: {\n      sqlite3_str_appendf(&x, \"%d\", pOp->p4.i);\n      break;\n    }\n    case P4_REAL: {\n      sqlite3_str_appendf(&x, \"%.16g\", *pOp->p4.pReal);\n      break;\n    }\n    case P4_MEM: {\n      Mem *pMem = pOp->p4.pMem;\n      if( pMem->flags & MEM_Str ){\n        zP4 = pMem->z;\n      }else if( pMem->flags & (MEM_Int|MEM_IntReal) ){\n        sqlite3_str_appendf(&x, \"%lld\", pMem->u.i);\n      }else if( pMem->flags & MEM_Real ){\n        sqlite3_str_appendf(&x, \"%.16g\", pMem->u.r);\n      }else if( pMem->flags & MEM_Null ){\n        zP4 = \"NULL\";\n      }else{\n        assert( pMem->flags & MEM_Blob );\n        zP4 = \"(blob)\";\n      }\n      break;\n    }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    case P4_VTAB: {\n      sqlite3_vtab *pVtab = pOp->p4.pVtab->pVtab;\n      sqlite3_str_appendf(&x, \"vtab:%p\", pVtab);\n      break;\n    }\n#endif\n    case P4_INTARRAY: {\n      int i;\n      int *ai = pOp->p4.ai;\n      int n = ai[0];   /* The first element of an INTARRAY is always the\n                       ** count of the number of elements to follow */\n      for(i=1; i<=n; i++){\n        sqlite3_str_appendf(&x, \",%d\", ai[i]);\n      }\n      zTemp[0] = '[';\n      sqlite3_str_append(&x, \"]\", 1);\n      break;\n    }\n    case P4_SUBPROGRAM: {\n      sqlite3_str_appendf(&x, \"program\");\n      break;\n    }\n    case P4_DYNBLOB:\n    case P4_ADVANCE: {\n      zTemp[0] = 0;\n      break;\n    }\n    case P4_TABLE: {\n      sqlite3_str_appendf(&x, \"%s\", pOp->p4.pTab->zName);\n      break;\n    }\n    default: {\n      zP4 = pOp->p4.z;\n      if( zP4==0 ){\n        zP4 = zTemp;\n        zTemp[0] = 0;\n      }\n    }\n  }\n  sqlite3StrAccumFinish(&x);\n  assert( zP4!=0 );\n  return zP4;\n}\n#endif /* VDBE_DISPLAY_P4 */\n\n/*\n** Declare to the Vdbe that the BTree object at db->aDb[i] is used.\n**\n** The prepared statements need to know in advance the complete set of\n** attached databases that will be use.  A mask of these databases\n** is maintained in p->btreeMask.  The p->lockMask value is the subset of\n** p->btreeMask of databases that will require a lock.\n*/\nvoid sqlite3VdbeUsesBtree(Vdbe *p, int i){\n  assert( i>=0 && i<p->db->nDb && i<(int)sizeof(yDbMask)*8 );\n  assert( i<(int)sizeof(p->btreeMask)*8 );\n  DbMaskSet(p->btreeMask, i);\n  if( i!=1 && sqlite3BtreeSharable(p->db->aDb[i].pBt) ){\n    DbMaskSet(p->lockMask, i);\n  }\n}\n\n#if !defined(SQLITE_OMIT_SHARED_CACHE)\n/*\n** If SQLite is compiled to support shared-cache mode and to be threadsafe,\n** this routine obtains the mutex associated with each BtShared structure\n** that may be accessed by the VM passed as an argument. In doing so it also\n** sets the BtShared.db member of each of the BtShared structures, ensuring\n** that the correct busy-handler callback is invoked if required.\n**\n** If SQLite is not threadsafe but does support shared-cache mode, then\n** sqlite3BtreeEnter() is invoked to set the BtShared.db variables\n** of all of BtShared structures accessible via the database handle \n** associated with the VM.\n**\n** If SQLite is not threadsafe and does not support shared-cache mode, this\n** function is a no-op.\n**\n** The p->btreeMask field is a bitmask of all btrees that the prepared \n** statement p will ever use.  Let N be the number of bits in p->btreeMask\n** corresponding to btrees that use shared cache.  Then the runtime of\n** this routine is N*N.  But as N is rarely more than 1, this should not\n** be a problem.\n*/\nvoid sqlite3VdbeEnter(Vdbe *p){\n  int i;\n  sqlite3 *db;\n  Db *aDb;\n  int nDb;\n  if( DbMaskAllZero(p->lockMask) ) return;  /* The common case */\n  db = p->db;\n  aDb = db->aDb;\n  nDb = db->nDb;\n  for(i=0; i<nDb; i++){\n    if( i!=1 && DbMaskTest(p->lockMask,i) && ALWAYS(aDb[i].pBt!=0) ){\n      sqlite3BtreeEnter(aDb[i].pBt);\n    }\n  }\n}\n#endif\n\n#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE>0\n/*\n** Unlock all of the btrees previously locked by a call to sqlite3VdbeEnter().\n*/\nstatic SQLITE_NOINLINE void vdbeLeave(Vdbe *p){\n  int i;\n  sqlite3 *db;\n  Db *aDb;\n  int nDb;\n  db = p->db;\n  aDb = db->aDb;\n  nDb = db->nDb;\n  for(i=0; i<nDb; i++){\n    if( i!=1 && DbMaskTest(p->lockMask,i) && ALWAYS(aDb[i].pBt!=0) ){\n      sqlite3BtreeLeave(aDb[i].pBt);\n    }\n  }\n}\nvoid sqlite3VdbeLeave(Vdbe *p){\n  if( DbMaskAllZero(p->lockMask) ) return;  /* The common case */\n  vdbeLeave(p);\n}\n#endif\n\n#if defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)\n/*\n** Print a single opcode.  This routine is used for debugging only.\n*/\nvoid sqlite3VdbePrintOp(FILE *pOut, int pc, VdbeOp *pOp){\n  char *zP4;\n  char zPtr[50];\n  char zCom[100];\n  static const char *zFormat1 = \"%4d %-13s %4d %4d %4d %-13s %.2X %s\\n\";\n  if( pOut==0 ) pOut = stdout;\n  zP4 = displayP4(pOp, zPtr, sizeof(zPtr));\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n  displayComment(pOp, zP4, zCom, sizeof(zCom));\n#else\n  zCom[0] = 0;\n#endif\n  /* NB:  The sqlite3OpcodeName() function is implemented by code created\n  ** by the mkopcodeh.awk and mkopcodec.awk scripts which extract the\n  ** information from the vdbe.c source text */\n  fprintf(pOut, zFormat1, pc, \n      sqlite3OpcodeName(pOp->opcode), pOp->p1, pOp->p2, pOp->p3, zP4, pOp->p5,\n      zCom\n  );\n  fflush(pOut);\n}\n#endif\n\n/*\n** Initialize an array of N Mem element.\n*/\nstatic void initMemArray(Mem *p, int N, sqlite3 *db, u16 flags){\n  while( (N--)>0 ){\n    p->db = db;\n    p->flags = flags;\n    p->szMalloc = 0;\n#ifdef SQLITE_DEBUG\n    p->pScopyFrom = 0;\n#endif\n    p++;\n  }\n}\n\n/*\n** Release an array of N Mem elements\n*/\nstatic void releaseMemArray(Mem *p, int N){\n  if( p && N ){\n    Mem *pEnd = &p[N];\n    sqlite3 *db = p->db;\n    if( db->pnBytesFreed ){\n      do{\n        if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);\n      }while( (++p)<pEnd );\n      return;\n    }\n    do{\n      assert( (&p[1])==pEnd || p[0].db==p[1].db );\n      assert( sqlite3VdbeCheckMemInvariants(p) );\n\n      /* This block is really an inlined version of sqlite3VdbeMemRelease()\n      ** that takes advantage of the fact that the memory cell value is \n      ** being set to NULL after releasing any dynamic resources.\n      **\n      ** The justification for duplicating code is that according to \n      ** callgrind, this causes a certain test case to hit the CPU 4.7 \n      ** percent less (x86 linux, gcc version 4.1.2, -O6) than if \n      ** sqlite3MemRelease() were called from here. With -O2, this jumps\n      ** to 6.6 percent. The test case is inserting 1000 rows into a table \n      ** with no indexes using a single prepared INSERT statement, bind() \n      ** and reset(). Inserts are grouped into a transaction.\n      */\n      testcase( p->flags & MEM_Agg );\n      testcase( p->flags & MEM_Dyn );\n      testcase( p->xDel==sqlite3VdbeFrameMemDel );\n      if( p->flags&(MEM_Agg|MEM_Dyn) ){\n        sqlite3VdbeMemRelease(p);\n      }else if( p->szMalloc ){\n        sqlite3DbFreeNN(db, p->zMalloc);\n        p->szMalloc = 0;\n      }\n\n      p->flags = MEM_Undefined;\n    }while( (++p)<pEnd );\n  }\n}\n\n#ifdef SQLITE_DEBUG\n/*\n** Verify that pFrame is a valid VdbeFrame pointer.  Return true if it is\n** and false if something is wrong.\n**\n** This routine is intended for use inside of assert() statements only.\n*/\nint sqlite3VdbeFrameIsValid(VdbeFrame *pFrame){\n  if( pFrame->iFrameMagic!=SQLITE_FRAME_MAGIC ) return 0;\n  return 1;\n}\n#endif\n\n\n/*\n** This is a destructor on a Mem object (which is really an sqlite3_value)\n** that deletes the Frame object that is attached to it as a blob.\n**\n** This routine does not delete the Frame right away.  It merely adds the\n** frame to a list of frames to be deleted when the Vdbe halts.\n*/\nvoid sqlite3VdbeFrameMemDel(void *pArg){\n  VdbeFrame *pFrame = (VdbeFrame*)pArg;\n  assert( sqlite3VdbeFrameIsValid(pFrame) );\n  pFrame->pParent = pFrame->v->pDelFrame;\n  pFrame->v->pDelFrame = pFrame;\n}\n\n\n/*\n** Delete a VdbeFrame object and its contents. VdbeFrame objects are\n** allocated by the OP_Program opcode in sqlite3VdbeExec().\n*/\nvoid sqlite3VdbeFrameDelete(VdbeFrame *p){\n  int i;\n  Mem *aMem = VdbeFrameMem(p);\n  VdbeCursor **apCsr = (VdbeCursor **)&aMem[p->nChildMem];\n  assert( sqlite3VdbeFrameIsValid(p) );\n  for(i=0; i<p->nChildCsr; i++){\n    sqlite3VdbeFreeCursor(p->v, apCsr[i]);\n  }\n  releaseMemArray(aMem, p->nChildMem);\n  sqlite3VdbeDeleteAuxData(p->v->db, &p->pAuxData, -1, 0);\n  sqlite3DbFree(p->v->db, p);\n}\n\n#ifndef SQLITE_OMIT_EXPLAIN\n/*\n** Give a listing of the program in the virtual machine.\n**\n** The interface is the same as sqlite3VdbeExec().  But instead of\n** running the code, it invokes the callback once for each instruction.\n** This feature is used to implement \"EXPLAIN\".\n**\n** When p->explain==1, each instruction is listed.  When\n** p->explain==2, only OP_Explain instructions are listed and these\n** are shown in a different format.  p->explain==2 is used to implement\n** EXPLAIN QUERY PLAN.\n** 2018-04-24:  In p->explain==2 mode, the OP_Init opcodes of triggers\n** are also shown, so that the boundaries between the main program and\n** each trigger are clear.\n**\n** When p->explain==1, first the main program is listed, then each of\n** the trigger subprograms are listed one by one.\n*/\nint sqlite3VdbeList(\n  Vdbe *p                   /* The VDBE */\n){\n  int nRow;                            /* Stop when row count reaches this */\n  int nSub = 0;                        /* Number of sub-vdbes seen so far */\n  SubProgram **apSub = 0;              /* Array of sub-vdbes */\n  Mem *pSub = 0;                       /* Memory cell hold array of subprogs */\n  sqlite3 *db = p->db;                 /* The database connection */\n  int i;                               /* Loop counter */\n  int rc = SQLITE_OK;                  /* Return code */\n  Mem *pMem = &p->aMem[1];             /* First Mem of result set */\n  int bListSubprogs = (p->explain==1 || (db->flags & SQLITE_TriggerEQP)!=0);\n  Op *pOp = 0;\n\n  assert( p->explain );\n  assert( p->magic==VDBE_MAGIC_RUN );\n  assert( p->rc==SQLITE_OK || p->rc==SQLITE_BUSY || p->rc==SQLITE_NOMEM );\n\n  /* Even though this opcode does not use dynamic strings for\n  ** the result, result columns may become dynamic if the user calls\n  ** sqlite3_column_text16(), causing a translation to UTF-16 encoding.\n  */\n  releaseMemArray(pMem, 8);\n  p->pResultSet = 0;\n\n  if( p->rc==SQLITE_NOMEM ){\n    /* This happens if a malloc() inside a call to sqlite3_column_text() or\n    ** sqlite3_column_text16() failed.  */\n    sqlite3OomFault(db);\n    return SQLITE_ERROR;\n  }\n\n  /* When the number of output rows reaches nRow, that means the\n  ** listing has finished and sqlite3_step() should return SQLITE_DONE.\n  ** nRow is the sum of the number of rows in the main program, plus\n  ** the sum of the number of rows in all trigger subprograms encountered\n  ** so far.  The nRow value will increase as new trigger subprograms are\n  ** encountered, but p->pc will eventually catch up to nRow.\n  */\n  nRow = p->nOp;\n  if( bListSubprogs ){\n    /* The first 8 memory cells are used for the result set.  So we will\n    ** commandeer the 9th cell to use as storage for an array of pointers\n    ** to trigger subprograms.  The VDBE is guaranteed to have at least 9\n    ** cells.  */\n    assert( p->nMem>9 );\n    pSub = &p->aMem[9];\n    if( pSub->flags&MEM_Blob ){\n      /* On the first call to sqlite3_step(), pSub will hold a NULL.  It is\n      ** initialized to a BLOB by the P4_SUBPROGRAM processing logic below */\n      nSub = pSub->n/sizeof(Vdbe*);\n      apSub = (SubProgram **)pSub->z;\n    }\n    for(i=0; i<nSub; i++){\n      nRow += apSub[i]->nOp;\n    }\n  }\n\n  while(1){  /* Loop exits via break */\n    i = p->pc++;\n    if( i>=nRow ){\n      p->rc = SQLITE_OK;\n      rc = SQLITE_DONE;\n      break;\n    }\n    if( i<p->nOp ){\n      /* The output line number is small enough that we are still in the\n      ** main program. */\n      pOp = &p->aOp[i];\n    }else{\n      /* We are currently listing subprograms.  Figure out which one and\n      ** pick up the appropriate opcode. */\n      int j;\n      i -= p->nOp;\n      assert( apSub!=0 );\n      assert( nSub>0 );\n      for(j=0; i>=apSub[j]->nOp; j++){\n        i -= apSub[j]->nOp;\n        assert( i<apSub[j]->nOp || j+1<nSub );\n      }\n      pOp = &apSub[j]->aOp[i];\n    }\n\n    /* When an OP_Program opcode is encounter (the only opcode that has\n    ** a P4_SUBPROGRAM argument), expand the size of the array of subprograms\n    ** kept in p->aMem[9].z to hold the new program - assuming this subprogram\n    ** has not already been seen.\n    */\n    if( bListSubprogs && pOp->p4type==P4_SUBPROGRAM ){\n      int nByte = (nSub+1)*sizeof(SubProgram*);\n      int j;\n      for(j=0; j<nSub; j++){\n        if( apSub[j]==pOp->p4.pProgram ) break;\n      }\n      if( j==nSub ){\n        p->rc = sqlite3VdbeMemGrow(pSub, nByte, nSub!=0);\n        if( p->rc!=SQLITE_OK ){\n          rc = SQLITE_ERROR;\n          break;\n        }\n        apSub = (SubProgram **)pSub->z;\n        apSub[nSub++] = pOp->p4.pProgram;\n        pSub->flags |= MEM_Blob;\n        pSub->n = nSub*sizeof(SubProgram*);\n        nRow += pOp->p4.pProgram->nOp;\n      }\n    }\n    if( p->explain<2 ) break;\n    if( pOp->opcode==OP_Explain ) break;\n    if( pOp->opcode==OP_Init && p->pc>1 ) break;\n  }\n\n  if( rc==SQLITE_OK ){\n    if( db->u1.isInterrupted ){\n      p->rc = SQLITE_INTERRUPT;\n      rc = SQLITE_ERROR;\n      sqlite3VdbeError(p, sqlite3ErrStr(p->rc));\n    }else{\n      char *zP4;\n      if( p->explain==1 ){\n        pMem->flags = MEM_Int;\n        pMem->u.i = i;                                /* Program counter */\n        pMem++;\n    \n        pMem->flags = MEM_Static|MEM_Str|MEM_Term;\n        pMem->z = (char*)sqlite3OpcodeName(pOp->opcode); /* Opcode */\n        assert( pMem->z!=0 );\n        pMem->n = sqlite3Strlen30(pMem->z);\n        pMem->enc = SQLITE_UTF8;\n        pMem++;\n      }\n\n      pMem->flags = MEM_Int;\n      pMem->u.i = pOp->p1;                          /* P1 */\n      pMem++;\n\n      pMem->flags = MEM_Int;\n      pMem->u.i = pOp->p2;                          /* P2 */\n      pMem++;\n\n      pMem->flags = MEM_Int;\n      pMem->u.i = pOp->p3;                          /* P3 */\n      pMem++;\n\n      if( sqlite3VdbeMemClearAndResize(pMem, 100) ){ /* P4 */\n        assert( p->db->mallocFailed );\n        return SQLITE_ERROR;\n      }\n      pMem->flags = MEM_Str|MEM_Term;\n      zP4 = displayP4(pOp, pMem->z, pMem->szMalloc);\n      if( zP4!=pMem->z ){\n        pMem->n = 0;\n        sqlite3VdbeMemSetStr(pMem, zP4, -1, SQLITE_UTF8, 0);\n      }else{\n        assert( pMem->z!=0 );\n        pMem->n = sqlite3Strlen30(pMem->z);\n        pMem->enc = SQLITE_UTF8;\n      }\n      pMem++;\n\n      if( p->explain==1 ){\n        if( sqlite3VdbeMemClearAndResize(pMem, 4) ){\n          assert( p->db->mallocFailed );\n          return SQLITE_ERROR;\n        }\n        pMem->flags = MEM_Str|MEM_Term;\n        pMem->n = 2;\n        sqlite3_snprintf(3, pMem->z, \"%.2x\", pOp->p5);   /* P5 */\n        pMem->enc = SQLITE_UTF8;\n        pMem++;\n    \n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n        if( sqlite3VdbeMemClearAndResize(pMem, 500) ){\n          assert( p->db->mallocFailed );\n          return SQLITE_ERROR;\n        }\n        pMem->flags = MEM_Str|MEM_Term;\n        pMem->n = displayComment(pOp, zP4, pMem->z, 500);\n        pMem->enc = SQLITE_UTF8;\n#else\n        pMem->flags = MEM_Null;                       /* Comment */\n#endif\n      }\n\n      p->nResColumn = 8 - 4*(p->explain-1);\n      p->pResultSet = &p->aMem[1];\n      p->rc = SQLITE_OK;\n      rc = SQLITE_ROW;\n    }\n  }\n  return rc;\n}\n#endif /* SQLITE_OMIT_EXPLAIN */\n\n#ifdef SQLITE_DEBUG\n/*\n** Print the SQL that was used to generate a VDBE program.\n*/\nvoid sqlite3VdbePrintSql(Vdbe *p){\n  const char *z = 0;\n  if( p->zSql ){\n    z = p->zSql;\n  }else if( p->nOp>=1 ){\n    const VdbeOp *pOp = &p->aOp[0];\n    if( pOp->opcode==OP_Init && pOp->p4.z!=0 ){\n      z = pOp->p4.z;\n      while( sqlite3Isspace(*z) ) z++;\n    }\n  }\n  if( z ) printf(\"SQL: [%s]\\n\", z);\n}\n#endif\n\n#if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE)\n/*\n** Print an IOTRACE message showing SQL content.\n*/\nvoid sqlite3VdbeIOTraceSql(Vdbe *p){\n  int nOp = p->nOp;\n  VdbeOp *pOp;\n  if( sqlite3IoTrace==0 ) return;\n  if( nOp<1 ) return;\n  pOp = &p->aOp[0];\n  if( pOp->opcode==OP_Init && pOp->p4.z!=0 ){\n    int i, j;\n    char z[1000];\n    sqlite3_snprintf(sizeof(z), z, \"%s\", pOp->p4.z);\n    for(i=0; sqlite3Isspace(z[i]); i++){}\n    for(j=0; z[i]; i++){\n      if( sqlite3Isspace(z[i]) ){\n        if( z[i-1]!=' ' ){\n          z[j++] = ' ';\n        }\n      }else{\n        z[j++] = z[i];\n      }\n    }\n    z[j] = 0;\n    sqlite3IoTrace(\"SQL %s\\n\", z);\n  }\n}\n#endif /* !SQLITE_OMIT_TRACE && SQLITE_ENABLE_IOTRACE */\n\n/* An instance of this object describes bulk memory available for use\n** by subcomponents of a prepared statement.  Space is allocated out\n** of a ReusableSpace object by the allocSpace() routine below.\n*/\nstruct ReusableSpace {\n  u8 *pSpace;            /* Available memory */\n  sqlite3_int64 nFree;   /* Bytes of available memory */\n  sqlite3_int64 nNeeded; /* Total bytes that could not be allocated */\n};\n\n/* Try to allocate nByte bytes of 8-byte aligned bulk memory for pBuf\n** from the ReusableSpace object.  Return a pointer to the allocated\n** memory on success.  If insufficient memory is available in the\n** ReusableSpace object, increase the ReusableSpace.nNeeded\n** value by the amount needed and return NULL.\n**\n** If pBuf is not initially NULL, that means that the memory has already\n** been allocated by a prior call to this routine, so just return a copy\n** of pBuf and leave ReusableSpace unchanged.\n**\n** This allocator is employed to repurpose unused slots at the end of the\n** opcode array of prepared state for other memory needs of the prepared\n** statement.\n*/\nstatic void *allocSpace(\n  struct ReusableSpace *p,  /* Bulk memory available for allocation */\n  void *pBuf,               /* Pointer to a prior allocation */\n  sqlite3_int64 nByte       /* Bytes of memory needed */\n){\n  assert( EIGHT_BYTE_ALIGNMENT(p->pSpace) );\n  if( pBuf==0 ){\n    nByte = ROUND8(nByte);\n    if( nByte <= p->nFree ){\n      p->nFree -= nByte;\n      pBuf = &p->pSpace[p->nFree];\n    }else{\n      p->nNeeded += nByte;\n    }\n  }\n  assert( EIGHT_BYTE_ALIGNMENT(pBuf) );\n  return pBuf;\n}\n\n/*\n** Rewind the VDBE back to the beginning in preparation for\n** running it.\n*/\nvoid sqlite3VdbeRewind(Vdbe *p){\n#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)\n  int i;\n#endif\n  assert( p!=0 );\n  assert( p->magic==VDBE_MAGIC_INIT || p->magic==VDBE_MAGIC_RESET );\n\n  /* There should be at least one opcode.\n  */\n  assert( p->nOp>0 );\n\n  /* Set the magic to VDBE_MAGIC_RUN sooner rather than later. */\n  p->magic = VDBE_MAGIC_RUN;\n\n#ifdef SQLITE_DEBUG\n  for(i=0; i<p->nMem; i++){\n    assert( p->aMem[i].db==p->db );\n  }\n#endif\n  p->pc = -1;\n  p->rc = SQLITE_OK;\n  p->errorAction = OE_Abort;\n  p->nChange = 0;\n  p->cacheCtr = 1;\n  p->minWriteFileFormat = 255;\n  p->iStatement = 0;\n  p->nFkConstraint = 0;\n#ifdef VDBE_PROFILE\n  for(i=0; i<p->nOp; i++){\n    p->aOp[i].cnt = 0;\n    p->aOp[i].cycles = 0;\n  }\n#endif\n}\n\n/*\n** Prepare a virtual machine for execution for the first time after\n** creating the virtual machine.  This involves things such\n** as allocating registers and initializing the program counter.\n** After the VDBE has be prepped, it can be executed by one or more\n** calls to sqlite3VdbeExec().  \n**\n** This function may be called exactly once on each virtual machine.\n** After this routine is called the VM has been \"packaged\" and is ready\n** to run.  After this routine is called, further calls to \n** sqlite3VdbeAddOp() functions are prohibited.  This routine disconnects\n** the Vdbe from the Parse object that helped generate it so that the\n** the Vdbe becomes an independent entity and the Parse object can be\n** destroyed.\n**\n** Use the sqlite3VdbeRewind() procedure to restore a virtual machine back\n** to its initial state after it has been run.\n*/\nvoid sqlite3VdbeMakeReady(\n  Vdbe *p,                       /* The VDBE */\n  Parse *pParse                  /* Parsing context */\n){\n  sqlite3 *db;                   /* The database connection */\n  int nVar;                      /* Number of parameters */\n  int nMem;                      /* Number of VM memory registers */\n  int nCursor;                   /* Number of cursors required */\n  int nArg;                      /* Number of arguments in subprograms */\n  int n;                         /* Loop counter */\n  struct ReusableSpace x;        /* Reusable bulk memory */\n\n  assert( p!=0 );\n  assert( p->nOp>0 );\n  assert( pParse!=0 );\n  assert( p->magic==VDBE_MAGIC_INIT );\n  assert( pParse==p->pParse );\n  db = p->db;\n  assert( db->mallocFailed==0 );\n  nVar = pParse->nVar;\n  nMem = pParse->nMem;\n  nCursor = pParse->nTab;\n  nArg = pParse->nMaxArg;\n  \n  /* Each cursor uses a memory cell.  The first cursor (cursor 0) can\n  ** use aMem[0] which is not otherwise used by the VDBE program.  Allocate\n  ** space at the end of aMem[] for cursors 1 and greater.\n  ** See also: allocateCursor().\n  */\n  nMem += nCursor;\n  if( nCursor==0 && nMem>0 ) nMem++;  /* Space for aMem[0] even if not used */\n\n  /* Figure out how much reusable memory is available at the end of the\n  ** opcode array.  This extra memory will be reallocated for other elements\n  ** of the prepared statement.\n  */\n  n = ROUND8(sizeof(Op)*p->nOp);              /* Bytes of opcode memory used */\n  x.pSpace = &((u8*)p->aOp)[n];               /* Unused opcode memory */\n  assert( EIGHT_BYTE_ALIGNMENT(x.pSpace) );\n  x.nFree = ROUNDDOWN8(pParse->szOpAlloc - n);  /* Bytes of unused memory */\n  assert( x.nFree>=0 );\n  assert( EIGHT_BYTE_ALIGNMENT(&x.pSpace[x.nFree]) );\n\n  resolveP2Values(p, &nArg);\n  p->usesStmtJournal = (u8)(pParse->isMultiWrite && pParse->mayAbort);\n  if( pParse->explain ){\n    static const char * const azColName[] = {\n       \"addr\", \"opcode\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"comment\",\n       \"id\", \"parent\", \"notused\", \"detail\"\n    };\n    int iFirst, mx, i;\n    if( nMem<10 ) nMem = 10;\n    if( pParse->explain==2 ){\n      sqlite3VdbeSetNumCols(p, 4);\n      iFirst = 8;\n      mx = 12;\n    }else{\n      sqlite3VdbeSetNumCols(p, 8);\n      iFirst = 0;\n      mx = 8;\n    }\n    for(i=iFirst; i<mx; i++){\n      sqlite3VdbeSetColName(p, i-iFirst, COLNAME_NAME,\n                            azColName[i], SQLITE_STATIC);\n    }\n  }\n  p->expired = 0;\n\n  /* Memory for registers, parameters, cursor, etc, is allocated in one or two\n  ** passes.  On the first pass, we try to reuse unused memory at the \n  ** end of the opcode array.  If we are unable to satisfy all memory\n  ** requirements by reusing the opcode array tail, then the second\n  ** pass will fill in the remainder using a fresh memory allocation.  \n  **\n  ** This two-pass approach that reuses as much memory as possible from\n  ** the leftover memory at the end of the opcode array.  This can significantly\n  ** reduce the amount of memory held by a prepared statement.\n  */\n  x.nNeeded = 0;\n  p->aMem = allocSpace(&x, 0, nMem*sizeof(Mem));\n  p->aVar = allocSpace(&x, 0, nVar*sizeof(Mem));\n  p->apArg = allocSpace(&x, 0, nArg*sizeof(Mem*));\n  p->apCsr = allocSpace(&x, 0, nCursor*sizeof(VdbeCursor*));\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n  p->anExec = allocSpace(&x, 0, p->nOp*sizeof(i64));\n#endif\n  if( x.nNeeded ){\n    x.pSpace = p->pFree = sqlite3DbMallocRawNN(db, x.nNeeded);\n    x.nFree = x.nNeeded;\n    if( !db->mallocFailed ){\n      p->aMem = allocSpace(&x, p->aMem, nMem*sizeof(Mem));\n      p->aVar = allocSpace(&x, p->aVar, nVar*sizeof(Mem));\n      p->apArg = allocSpace(&x, p->apArg, nArg*sizeof(Mem*));\n      p->apCsr = allocSpace(&x, p->apCsr, nCursor*sizeof(VdbeCursor*));\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n      p->anExec = allocSpace(&x, p->anExec, p->nOp*sizeof(i64));\n#endif\n    }\n  }\n\n  p->pVList = pParse->pVList;\n  pParse->pVList =  0;\n  p->explain = pParse->explain;\n  if( db->mallocFailed ){\n    p->nVar = 0;\n    p->nCursor = 0;\n    p->nMem = 0;\n  }else{\n    p->nCursor = nCursor;\n    p->nVar = (ynVar)nVar;\n    initMemArray(p->aVar, nVar, db, MEM_Null);\n    p->nMem = nMem;\n    initMemArray(p->aMem, nMem, db, MEM_Undefined);\n    memset(p->apCsr, 0, nCursor*sizeof(VdbeCursor*));\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n    memset(p->anExec, 0, p->nOp*sizeof(i64));\n#endif\n  }\n  sqlite3VdbeRewind(p);\n}\n\n/*\n** Close a VDBE cursor and release all the resources that cursor \n** happens to hold.\n*/\nvoid sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){\n  if( pCx==0 ){\n    return;\n  }\n  assert( pCx->pBtx==0 || pCx->eCurType==CURTYPE_BTREE );\n  switch( pCx->eCurType ){\n    case CURTYPE_SORTER: {\n      sqlite3VdbeSorterClose(p->db, pCx);\n      break;\n    }\n    case CURTYPE_BTREE: {\n      if( pCx->isEphemeral ){\n        if( pCx->pBtx ) sqlite3BtreeClose(pCx->pBtx);\n        /* The pCx->pCursor will be close automatically, if it exists, by\n        ** the call above. */\n      }else{\n        assert( pCx->uc.pCursor!=0 );\n        sqlite3BtreeCloseCursor(pCx->uc.pCursor);\n      }\n      break;\n    }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    case CURTYPE_VTAB: {\n      sqlite3_vtab_cursor *pVCur = pCx->uc.pVCur;\n      const sqlite3_module *pModule = pVCur->pVtab->pModule;\n      assert( pVCur->pVtab->nRef>0 );\n      pVCur->pVtab->nRef--;\n      pModule->xClose(pVCur);\n      break;\n    }\n#endif\n  }\n}\n\n/*\n** Close all cursors in the current frame.\n*/\nstatic void closeCursorsInFrame(Vdbe *p){\n  if( p->apCsr ){\n    int i;\n    for(i=0; i<p->nCursor; i++){\n      VdbeCursor *pC = p->apCsr[i];\n      if( pC ){\n        sqlite3VdbeFreeCursor(p, pC);\n        p->apCsr[i] = 0;\n      }\n    }\n  }\n}\n\n/*\n** Copy the values stored in the VdbeFrame structure to its Vdbe. This\n** is used, for example, when a trigger sub-program is halted to restore\n** control to the main program.\n*/\nint sqlite3VdbeFrameRestore(VdbeFrame *pFrame){\n  Vdbe *v = pFrame->v;\n  closeCursorsInFrame(v);\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n  v->anExec = pFrame->anExec;\n#endif\n  v->aOp = pFrame->aOp;\n  v->nOp = pFrame->nOp;\n  v->aMem = pFrame->aMem;\n  v->nMem = pFrame->nMem;\n  v->apCsr = pFrame->apCsr;\n  v->nCursor = pFrame->nCursor;\n  v->db->lastRowid = pFrame->lastRowid;\n  v->nChange = pFrame->nChange;\n  v->db->nChange = pFrame->nDbChange;\n  sqlite3VdbeDeleteAuxData(v->db, &v->pAuxData, -1, 0);\n  v->pAuxData = pFrame->pAuxData;\n  pFrame->pAuxData = 0;\n  return pFrame->pc;\n}\n\n/*\n** Close all cursors.\n**\n** Also release any dynamic memory held by the VM in the Vdbe.aMem memory \n** cell array. This is necessary as the memory cell array may contain\n** pointers to VdbeFrame objects, which may in turn contain pointers to\n** open cursors.\n*/\nstatic void closeAllCursors(Vdbe *p){\n  if( p->pFrame ){\n    VdbeFrame *pFrame;\n    for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);\n    sqlite3VdbeFrameRestore(pFrame);\n    p->pFrame = 0;\n    p->nFrame = 0;\n  }\n  assert( p->nFrame==0 );\n  closeCursorsInFrame(p);\n  if( p->aMem ){\n    releaseMemArray(p->aMem, p->nMem);\n  }\n  while( p->pDelFrame ){\n    VdbeFrame *pDel = p->pDelFrame;\n    p->pDelFrame = pDel->pParent;\n    sqlite3VdbeFrameDelete(pDel);\n  }\n\n  /* Delete any auxdata allocations made by the VM */\n  if( p->pAuxData ) sqlite3VdbeDeleteAuxData(p->db, &p->pAuxData, -1, 0);\n  assert( p->pAuxData==0 );\n}\n\n/*\n** Set the number of result columns that will be returned by this SQL\n** statement. This is now set at compile time, rather than during\n** execution of the vdbe program so that sqlite3_column_count() can\n** be called on an SQL statement before sqlite3_step().\n*/\nvoid sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){\n  int n;\n  sqlite3 *db = p->db;\n\n  if( p->nResColumn ){\n    releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);\n    sqlite3DbFree(db, p->aColName);\n  }\n  n = nResColumn*COLNAME_N;\n  p->nResColumn = (u16)nResColumn;\n  p->aColName = (Mem*)sqlite3DbMallocRawNN(db, sizeof(Mem)*n );\n  if( p->aColName==0 ) return;\n  initMemArray(p->aColName, n, db, MEM_Null);\n}\n\n/*\n** Set the name of the idx'th column to be returned by the SQL statement.\n** zName must be a pointer to a nul terminated string.\n**\n** This call must be made after a call to sqlite3VdbeSetNumCols().\n**\n** The final parameter, xDel, must be one of SQLITE_DYNAMIC, SQLITE_STATIC\n** or SQLITE_TRANSIENT. If it is SQLITE_DYNAMIC, then the buffer pointed\n** to by zName will be freed by sqlite3DbFree() when the vdbe is destroyed.\n*/\nint sqlite3VdbeSetColName(\n  Vdbe *p,                         /* Vdbe being configured */\n  int idx,                         /* Index of column zName applies to */\n  int var,                         /* One of the COLNAME_* constants */\n  const char *zName,               /* Pointer to buffer containing name */\n  void (*xDel)(void*)              /* Memory management strategy for zName */\n){\n  int rc;\n  Mem *pColName;\n  assert( idx<p->nResColumn );\n  assert( var<COLNAME_N );\n  if( p->db->mallocFailed ){\n    assert( !zName || xDel!=SQLITE_DYNAMIC );\n    return SQLITE_NOMEM_BKPT;\n  }\n  assert( p->aColName!=0 );\n  pColName = &(p->aColName[idx+var*p->nResColumn]);\n  rc = sqlite3VdbeMemSetStr(pColName, zName, -1, SQLITE_UTF8, xDel);\n  assert( rc!=0 || !zName || (pColName->flags&MEM_Term)!=0 );\n  return rc;\n}\n\n/*\n** A read or write transaction may or may not be active on database handle\n** db. If a transaction is active, commit it. If there is a\n** write-transaction spanning more than one database file, this routine\n** takes care of the master journal trickery.\n*/\nstatic int vdbeCommit(sqlite3 *db, Vdbe *p){\n  int i;\n  int nTrans = 0;  /* Number of databases with an active write-transaction\n                   ** that are candidates for a two-phase commit using a\n                   ** master-journal */\n  int rc = SQLITE_OK;\n  int needXcommit = 0;\n\n#ifdef SQLITE_OMIT_VIRTUALTABLE\n  /* With this option, sqlite3VtabSync() is defined to be simply \n  ** SQLITE_OK so p is not used. \n  */\n  UNUSED_PARAMETER(p);\n#endif\n\n  /* Before doing anything else, call the xSync() callback for any\n  ** virtual module tables written in this transaction. This has to\n  ** be done before determining whether a master journal file is \n  ** required, as an xSync() callback may add an attached database\n  ** to the transaction.\n  */\n  rc = sqlite3VtabSync(db, p);\n\n  /* This loop determines (a) if the commit hook should be invoked and\n  ** (b) how many database files have open write transactions, not \n  ** including the temp database. (b) is important because if more than \n  ** one database file has an open write transaction, a master journal\n  ** file is required for an atomic commit.\n  */ \n  for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ \n    Btree *pBt = db->aDb[i].pBt;\n    if( sqlite3BtreeIsInTrans(pBt) ){\n      /* Whether or not a database might need a master journal depends upon\n      ** its journal mode (among other things).  This matrix determines which\n      ** journal modes use a master journal and which do not */\n      static const u8 aMJNeeded[] = {\n        /* DELETE   */  1,\n        /* PERSIST   */ 1,\n        /* OFF       */ 0,\n        /* TRUNCATE  */ 1,\n        /* MEMORY    */ 0,\n        /* WAL       */ 0\n      };\n      Pager *pPager;   /* Pager associated with pBt */\n      needXcommit = 1;\n      sqlite3BtreeEnter(pBt);\n      pPager = sqlite3BtreePager(pBt);\n      if( db->aDb[i].safety_level!=PAGER_SYNCHRONOUS_OFF\n       && aMJNeeded[sqlite3PagerGetJournalMode(pPager)]\n       && sqlite3PagerIsMemdb(pPager)==0\n      ){ \n        assert( i!=1 );\n        nTrans++;\n      }\n      rc = sqlite3PagerExclusiveLock(pPager);\n      sqlite3BtreeLeave(pBt);\n    }\n  }\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  /* If there are any write-transactions at all, invoke the commit hook */\n  if( needXcommit && db->xCommitCallback ){\n    rc = db->xCommitCallback(db->pCommitArg);\n    if( rc ){\n      return SQLITE_CONSTRAINT_COMMITHOOK;\n    }\n  }\n\n  /* The simple case - no more than one database file (not counting the\n  ** TEMP database) has a transaction active.   There is no need for the\n  ** master-journal.\n  **\n  ** If the return value of sqlite3BtreeGetFilename() is a zero length\n  ** string, it means the main database is :memory: or a temp file.  In \n  ** that case we do not support atomic multi-file commits, so use the \n  ** simple case then too.\n  */\n  if( 0==sqlite3Strlen30(sqlite3BtreeGetFilename(db->aDb[0].pBt))\n   || nTrans<=1\n  ){\n    for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        rc = sqlite3BtreeCommitPhaseOne(pBt, 0);\n      }\n    }\n\n    /* Do the commit only if all databases successfully complete phase 1. \n    ** If one of the BtreeCommitPhaseOne() calls fails, this indicates an\n    ** IO error while deleting or truncating a journal file. It is unlikely,\n    ** but could happen. In this case abandon processing and return the error.\n    */\n    for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        rc = sqlite3BtreeCommitPhaseTwo(pBt, 0);\n      }\n    }\n    if( rc==SQLITE_OK ){\n      sqlite3VtabCommit(db);\n    }\n  }\n\n  /* The complex case - There is a multi-file write-transaction active.\n  ** This requires a master journal file to ensure the transaction is\n  ** committed atomically.\n  */\n#ifndef SQLITE_OMIT_DISKIO\n  else{\n    sqlite3_vfs *pVfs = db->pVfs;\n    char *zMaster = 0;   /* File-name for the master journal */\n    char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt);\n    sqlite3_file *pMaster = 0;\n    i64 offset = 0;\n    int res;\n    int retryCount = 0;\n    int nMainFile;\n\n    /* Select a master journal file name */\n    nMainFile = sqlite3Strlen30(zMainFile);\n    zMaster = sqlite3MPrintf(db, \"%s-mjXXXXXX9XXz%c%c\", zMainFile, 0, 0);\n    if( zMaster==0 ) return SQLITE_NOMEM_BKPT;\n    do {\n      u32 iRandom;\n      if( retryCount ){\n        if( retryCount>100 ){\n          sqlite3_log(SQLITE_FULL, \"MJ delete: %s\", zMaster);\n          sqlite3OsDelete(pVfs, zMaster, 0);\n          break;\n        }else if( retryCount==1 ){\n          sqlite3_log(SQLITE_FULL, \"MJ collide: %s\", zMaster);\n        }\n      }\n      retryCount++;\n      sqlite3_randomness(sizeof(iRandom), &iRandom);\n      sqlite3_snprintf(13, &zMaster[nMainFile], \"-mj%06X9%02X\",\n                               (iRandom>>8)&0xffffff, iRandom&0xff);\n      /* The antipenultimate character of the master journal name must\n      ** be \"9\" to avoid name collisions when using 8+3 filenames. */\n      assert( zMaster[sqlite3Strlen30(zMaster)-3]=='9' );\n      sqlite3FileSuffix3(zMainFile, zMaster);\n      rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res);\n    }while( rc==SQLITE_OK && res );\n    if( rc==SQLITE_OK ){\n      /* Open the master journal. */\n      rc = sqlite3OsOpenMalloc(pVfs, zMaster, &pMaster, \n          SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|\n          SQLITE_OPEN_EXCLUSIVE|SQLITE_OPEN_MASTER_JOURNAL, 0\n      );\n    }\n    if( rc!=SQLITE_OK ){\n      sqlite3DbFree(db, zMaster);\n      return rc;\n    }\n \n    /* Write the name of each database file in the transaction into the new\n    ** master journal file. If an error occurs at this point close\n    ** and delete the master journal file. All the individual journal files\n    ** still have 'null' as the master journal pointer, so they will roll\n    ** back independently if a failure occurs.\n    */\n    for(i=0; i<db->nDb; i++){\n      Btree *pBt = db->aDb[i].pBt;\n      if( sqlite3BtreeIsInTrans(pBt) ){\n        char const *zFile = sqlite3BtreeGetJournalname(pBt);\n        if( zFile==0 ){\n          continue;  /* Ignore TEMP and :memory: databases */\n        }\n        assert( zFile[0]!=0 );\n        rc = sqlite3OsWrite(pMaster, zFile, sqlite3Strlen30(zFile)+1, offset);\n        offset += sqlite3Strlen30(zFile)+1;\n        if( rc!=SQLITE_OK ){\n          sqlite3OsCloseFree(pMaster);\n          sqlite3OsDelete(pVfs, zMaster, 0);\n          sqlite3DbFree(db, zMaster);\n          return rc;\n        }\n      }\n    }\n\n    /* Sync the master journal file. If the IOCAP_SEQUENTIAL device\n    ** flag is set this is not required.\n    */\n    if( 0==(sqlite3OsDeviceCharacteristics(pMaster)&SQLITE_IOCAP_SEQUENTIAL)\n     && SQLITE_OK!=(rc = sqlite3OsSync(pMaster, SQLITE_SYNC_NORMAL))\n    ){\n      sqlite3OsCloseFree(pMaster);\n      sqlite3OsDelete(pVfs, zMaster, 0);\n      sqlite3DbFree(db, zMaster);\n      return rc;\n    }\n\n    /* Sync all the db files involved in the transaction. The same call\n    ** sets the master journal pointer in each individual journal. If\n    ** an error occurs here, do not delete the master journal file.\n    **\n    ** If the error occurs during the first call to\n    ** sqlite3BtreeCommitPhaseOne(), then there is a chance that the\n    ** master journal file will be orphaned. But we cannot delete it,\n    ** in case the master journal file name was written into the journal\n    ** file before the failure occurred.\n    */\n    for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ \n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        rc = sqlite3BtreeCommitPhaseOne(pBt, zMaster);\n      }\n    }\n    sqlite3OsCloseFree(pMaster);\n    assert( rc!=SQLITE_BUSY );\n    if( rc!=SQLITE_OK ){\n      sqlite3DbFree(db, zMaster);\n      return rc;\n    }\n\n    /* Delete the master journal file. This commits the transaction. After\n    ** doing this the directory is synced again before any individual\n    ** transaction files are deleted.\n    */\n    rc = sqlite3OsDelete(pVfs, zMaster, 1);\n    sqlite3DbFree(db, zMaster);\n    zMaster = 0;\n    if( rc ){\n      return rc;\n    }\n\n    /* All files and directories have already been synced, so the following\n    ** calls to sqlite3BtreeCommitPhaseTwo() are only closing files and\n    ** deleting or truncating journals. If something goes wrong while\n    ** this is happening we don't really care. The integrity of the\n    ** transaction is already guaranteed, but some stray 'cold' journals\n    ** may be lying around. Returning an error code won't help matters.\n    */\n    disable_simulated_io_errors();\n    sqlite3BeginBenignMalloc();\n    for(i=0; i<db->nDb; i++){ \n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        sqlite3BtreeCommitPhaseTwo(pBt, 1);\n      }\n    }\n    sqlite3EndBenignMalloc();\n    enable_simulated_io_errors();\n\n    sqlite3VtabCommit(db);\n  }\n#endif\n\n  return rc;\n}\n\n/* \n** This routine checks that the sqlite3.nVdbeActive count variable\n** matches the number of vdbe's in the list sqlite3.pVdbe that are\n** currently active. An assertion fails if the two counts do not match.\n** This is an internal self-check only - it is not an essential processing\n** step.\n**\n** This is a no-op if NDEBUG is defined.\n*/\n#ifndef NDEBUG\nstatic void checkActiveVdbeCnt(sqlite3 *db){\n  Vdbe *p;\n  int cnt = 0;\n  int nWrite = 0;\n  int nRead = 0;\n  p = db->pVdbe;\n  while( p ){\n    if( sqlite3_stmt_busy((sqlite3_stmt*)p) ){\n      cnt++;\n      if( p->readOnly==0 ) nWrite++;\n      if( p->bIsReader ) nRead++;\n    }\n    p = p->pNext;\n  }\n  assert( cnt==db->nVdbeActive );\n  assert( nWrite==db->nVdbeWrite );\n  assert( nRead==db->nVdbeRead );\n}\n#else\n#define checkActiveVdbeCnt(x)\n#endif\n\n/*\n** If the Vdbe passed as the first argument opened a statement-transaction,\n** close it now. Argument eOp must be either SAVEPOINT_ROLLBACK or\n** SAVEPOINT_RELEASE. If it is SAVEPOINT_ROLLBACK, then the statement\n** transaction is rolled back. If eOp is SAVEPOINT_RELEASE, then the \n** statement transaction is committed.\n**\n** If an IO error occurs, an SQLITE_IOERR_XXX error code is returned. \n** Otherwise SQLITE_OK.\n*/\nstatic SQLITE_NOINLINE int vdbeCloseStatement(Vdbe *p, int eOp){\n  sqlite3 *const db = p->db;\n  int rc = SQLITE_OK;\n  int i;\n  const int iSavepoint = p->iStatement-1;\n\n  assert( eOp==SAVEPOINT_ROLLBACK || eOp==SAVEPOINT_RELEASE);\n  assert( db->nStatement>0 );\n  assert( p->iStatement==(db->nStatement+db->nSavepoint) );\n\n  for(i=0; i<db->nDb; i++){ \n    int rc2 = SQLITE_OK;\n    Btree *pBt = db->aDb[i].pBt;\n    if( pBt ){\n      if( eOp==SAVEPOINT_ROLLBACK ){\n        rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_ROLLBACK, iSavepoint);\n      }\n      if( rc2==SQLITE_OK ){\n        rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_RELEASE, iSavepoint);\n      }\n      if( rc==SQLITE_OK ){\n        rc = rc2;\n      }\n    }\n  }\n  db->nStatement--;\n  p->iStatement = 0;\n\n  if( rc==SQLITE_OK ){\n    if( eOp==SAVEPOINT_ROLLBACK ){\n      rc = sqlite3VtabSavepoint(db, SAVEPOINT_ROLLBACK, iSavepoint);\n    }\n    if( rc==SQLITE_OK ){\n      rc = sqlite3VtabSavepoint(db, SAVEPOINT_RELEASE, iSavepoint);\n    }\n  }\n\n  /* If the statement transaction is being rolled back, also restore the \n  ** database handles deferred constraint counter to the value it had when \n  ** the statement transaction was opened.  */\n  if( eOp==SAVEPOINT_ROLLBACK ){\n    db->nDeferredCons = p->nStmtDefCons;\n    db->nDeferredImmCons = p->nStmtDefImmCons;\n  }\n  return rc;\n}\nint sqlite3VdbeCloseStatement(Vdbe *p, int eOp){\n  if( p->db->nStatement && p->iStatement ){\n    return vdbeCloseStatement(p, eOp);\n  }\n  return SQLITE_OK;\n}\n\n\n/*\n** This function is called when a transaction opened by the database \n** handle associated with the VM passed as an argument is about to be \n** committed. If there are outstanding deferred foreign key constraint\n** violations, return SQLITE_ERROR. Otherwise, SQLITE_OK.\n**\n** If there are outstanding FK violations and this function returns \n** SQLITE_ERROR, set the result of the VM to SQLITE_CONSTRAINT_FOREIGNKEY\n** and write an error message to it. Then return SQLITE_ERROR.\n*/\n#ifndef SQLITE_OMIT_FOREIGN_KEY\nint sqlite3VdbeCheckFk(Vdbe *p, int deferred){\n  sqlite3 *db = p->db;\n  if( (deferred && (db->nDeferredCons+db->nDeferredImmCons)>0) \n   || (!deferred && p->nFkConstraint>0) \n  ){\n    p->rc = SQLITE_CONSTRAINT_FOREIGNKEY;\n    p->errorAction = OE_Abort;\n    sqlite3VdbeError(p, \"FOREIGN KEY constraint failed\");\n    return SQLITE_ERROR;\n  }\n  return SQLITE_OK;\n}\n#endif\n\n/*\n** This routine is called the when a VDBE tries to halt.  If the VDBE\n** has made changes and is in autocommit mode, then commit those\n** changes.  If a rollback is needed, then do the rollback.\n**\n** This routine is the only way to move the state of a VM from\n** SQLITE_MAGIC_RUN to SQLITE_MAGIC_HALT.  It is harmless to\n** call this on a VM that is in the SQLITE_MAGIC_HALT state.\n**\n** Return an error code.  If the commit could not complete because of\n** lock contention, return SQLITE_BUSY.  If SQLITE_BUSY is returned, it\n** means the close did not happen and needs to be repeated.\n*/\nint sqlite3VdbeHalt(Vdbe *p){\n  int rc;                         /* Used to store transient return codes */\n  sqlite3 *db = p->db;\n\n  /* This function contains the logic that determines if a statement or\n  ** transaction will be committed or rolled back as a result of the\n  ** execution of this virtual machine. \n  **\n  ** If any of the following errors occur:\n  **\n  **     SQLITE_NOMEM\n  **     SQLITE_IOERR\n  **     SQLITE_FULL\n  **     SQLITE_INTERRUPT\n  **\n  ** Then the internal cache might have been left in an inconsistent\n  ** state.  We need to rollback the statement transaction, if there is\n  ** one, or the complete transaction if there is no statement transaction.\n  */\n\n  if( p->magic!=VDBE_MAGIC_RUN ){\n    return SQLITE_OK;\n  }\n  if( db->mallocFailed ){\n    p->rc = SQLITE_NOMEM_BKPT;\n  }\n  closeAllCursors(p);\n  checkActiveVdbeCnt(db);\n\n  /* No commit or rollback needed if the program never started or if the\n  ** SQL statement does not read or write a database file.  */\n  if( p->pc>=0 && p->bIsReader ){\n    int mrc;   /* Primary error code from p->rc */\n    int eStatementOp = 0;\n    int isSpecialError;            /* Set to true if a 'special' error */\n\n    /* Lock all btrees used by the statement */\n    sqlite3VdbeEnter(p);\n\n    /* Check for one of the special errors */\n    mrc = p->rc & 0xff;\n    isSpecialError = mrc==SQLITE_NOMEM || mrc==SQLITE_IOERR\n                     || mrc==SQLITE_INTERRUPT || mrc==SQLITE_FULL;\n    if( isSpecialError ){\n      /* If the query was read-only and the error code is SQLITE_INTERRUPT, \n      ** no rollback is necessary. Otherwise, at least a savepoint \n      ** transaction must be rolled back to restore the database to a \n      ** consistent state.\n      **\n      ** Even if the statement is read-only, it is important to perform\n      ** a statement or transaction rollback operation. If the error \n      ** occurred while writing to the journal, sub-journal or database\n      ** file as part of an effort to free up cache space (see function\n      ** pagerStress() in pager.c), the rollback is required to restore \n      ** the pager to a consistent state.\n      */\n      if( !p->readOnly || mrc!=SQLITE_INTERRUPT ){\n        if( (mrc==SQLITE_NOMEM || mrc==SQLITE_FULL) && p->usesStmtJournal ){\n          eStatementOp = SAVEPOINT_ROLLBACK;\n        }else{\n          /* We are forced to roll back the active transaction. Before doing\n          ** so, abort any other statements this handle currently has active.\n          */\n          sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);\n          sqlite3CloseSavepoints(db);\n          db->autoCommit = 1;\n          p->nChange = 0;\n        }\n      }\n    }\n\n    /* Check for immediate foreign key violations. */\n    if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){\n      sqlite3VdbeCheckFk(p, 0);\n    }\n  \n    /* If the auto-commit flag is set and this is the only active writer \n    ** VM, then we do either a commit or rollback of the current transaction. \n    **\n    ** Note: This block also runs if one of the special errors handled \n    ** above has occurred. \n    */\n    if( !sqlite3VtabInSync(db) \n     && db->autoCommit \n     && db->nVdbeWrite==(p->readOnly==0) \n    ){\n      if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){\n        rc = sqlite3VdbeCheckFk(p, 1);\n        if( rc!=SQLITE_OK ){\n          if( NEVER(p->readOnly) ){\n            sqlite3VdbeLeave(p);\n            return SQLITE_ERROR;\n          }\n          rc = SQLITE_CONSTRAINT_FOREIGNKEY;\n        }else{ \n          /* The auto-commit flag is true, the vdbe program was successful \n          ** or hit an 'OR FAIL' constraint and there are no deferred foreign\n          ** key constraints to hold up the transaction. This means a commit \n          ** is required. */\n          rc = vdbeCommit(db, p);\n        }\n        if( rc==SQLITE_BUSY && p->readOnly ){\n          sqlite3VdbeLeave(p);\n          return SQLITE_BUSY;\n        }else if( rc!=SQLITE_OK ){\n          p->rc = rc;\n          sqlite3RollbackAll(db, SQLITE_OK);\n          p->nChange = 0;\n        }else{\n          db->nDeferredCons = 0;\n          db->nDeferredImmCons = 0;\n          db->flags &= ~(u64)SQLITE_DeferFKs;\n          sqlite3CommitInternalChanges(db);\n        }\n      }else{\n        sqlite3RollbackAll(db, SQLITE_OK);\n        p->nChange = 0;\n      }\n      db->nStatement = 0;\n    }else if( eStatementOp==0 ){\n      if( p->rc==SQLITE_OK || p->errorAction==OE_Fail ){\n        eStatementOp = SAVEPOINT_RELEASE;\n      }else if( p->errorAction==OE_Abort ){\n        eStatementOp = SAVEPOINT_ROLLBACK;\n      }else{\n        sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);\n        sqlite3CloseSavepoints(db);\n        db->autoCommit = 1;\n        p->nChange = 0;\n      }\n    }\n  \n    /* If eStatementOp is non-zero, then a statement transaction needs to\n    ** be committed or rolled back. Call sqlite3VdbeCloseStatement() to\n    ** do so. If this operation returns an error, and the current statement\n    ** error code is SQLITE_OK or SQLITE_CONSTRAINT, then promote the\n    ** current statement error code.\n    */\n    if( eStatementOp ){\n      rc = sqlite3VdbeCloseStatement(p, eStatementOp);\n      if( rc ){\n        if( p->rc==SQLITE_OK || (p->rc&0xff)==SQLITE_CONSTRAINT ){\n          p->rc = rc;\n          sqlite3DbFree(db, p->zErrMsg);\n          p->zErrMsg = 0;\n        }\n        sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);\n        sqlite3CloseSavepoints(db);\n        db->autoCommit = 1;\n        p->nChange = 0;\n      }\n    }\n  \n    /* If this was an INSERT, UPDATE or DELETE and no statement transaction\n    ** has been rolled back, update the database connection change-counter. \n    */\n    if( p->changeCntOn ){\n      if( eStatementOp!=SAVEPOINT_ROLLBACK ){\n        sqlite3VdbeSetChanges(db, p->nChange);\n      }else{\n        sqlite3VdbeSetChanges(db, 0);\n      }\n      p->nChange = 0;\n    }\n\n    /* Release the locks */\n    sqlite3VdbeLeave(p);\n  }\n\n  /* We have successfully halted and closed the VM.  Record this fact. */\n  if( p->pc>=0 ){\n    db->nVdbeActive--;\n    if( !p->readOnly ) db->nVdbeWrite--;\n    if( p->bIsReader ) db->nVdbeRead--;\n    assert( db->nVdbeActive>=db->nVdbeRead );\n    assert( db->nVdbeRead>=db->nVdbeWrite );\n    assert( db->nVdbeWrite>=0 );\n  }\n  p->magic = VDBE_MAGIC_HALT;\n  checkActiveVdbeCnt(db);\n  if( db->mallocFailed ){\n    p->rc = SQLITE_NOMEM_BKPT;\n  }\n\n  /* If the auto-commit flag is set to true, then any locks that were held\n  ** by connection db have now been released. Call sqlite3ConnectionUnlocked() \n  ** to invoke any required unlock-notify callbacks.\n  */\n  if( db->autoCommit ){\n    sqlite3ConnectionUnlocked(db);\n  }\n\n  assert( db->nVdbeActive>0 || db->autoCommit==0 || db->nStatement==0 );\n  return (p->rc==SQLITE_BUSY ? SQLITE_BUSY : SQLITE_OK);\n}\n\n\n/*\n** Each VDBE holds the result of the most recent sqlite3_step() call\n** in p->rc.  This routine sets that result back to SQLITE_OK.\n*/\nvoid sqlite3VdbeResetStepResult(Vdbe *p){\n  p->rc = SQLITE_OK;\n}\n\n/*\n** Copy the error code and error message belonging to the VDBE passed\n** as the first argument to its database handle (so that they will be \n** returned by calls to sqlite3_errcode() and sqlite3_errmsg()).\n**\n** This function does not clear the VDBE error code or message, just\n** copies them to the database handle.\n*/\nint sqlite3VdbeTransferError(Vdbe *p){\n  sqlite3 *db = p->db;\n  int rc = p->rc;\n  if( p->zErrMsg ){\n    db->bBenignMalloc++;\n    sqlite3BeginBenignMalloc();\n    if( db->pErr==0 ) db->pErr = sqlite3ValueNew(db);\n    sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT);\n    sqlite3EndBenignMalloc();\n    db->bBenignMalloc--;\n  }else if( db->pErr ){\n    sqlite3ValueSetNull(db->pErr);\n  }\n  db->errCode = rc;\n  return rc;\n}\n\n#ifdef SQLITE_ENABLE_SQLLOG\n/*\n** If an SQLITE_CONFIG_SQLLOG hook is registered and the VM has been run, \n** invoke it.\n*/\nstatic void vdbeInvokeSqllog(Vdbe *v){\n  if( sqlite3GlobalConfig.xSqllog && v->rc==SQLITE_OK && v->zSql && v->pc>=0 ){\n    char *zExpanded = sqlite3VdbeExpandSql(v, v->zSql);\n    assert( v->db->init.busy==0 );\n    if( zExpanded ){\n      sqlite3GlobalConfig.xSqllog(\n          sqlite3GlobalConfig.pSqllogArg, v->db, zExpanded, 1\n      );\n      sqlite3DbFree(v->db, zExpanded);\n    }\n  }\n}\n#else\n# define vdbeInvokeSqllog(x)\n#endif\n\n/*\n** Clean up a VDBE after execution but do not delete the VDBE just yet.\n** Write any error messages into *pzErrMsg.  Return the result code.\n**\n** After this routine is run, the VDBE should be ready to be executed\n** again.\n**\n** To look at it another way, this routine resets the state of the\n** virtual machine from VDBE_MAGIC_RUN or VDBE_MAGIC_HALT back to\n** VDBE_MAGIC_INIT.\n*/\nint sqlite3VdbeReset(Vdbe *p){\n#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)\n  int i;\n#endif\n\n  sqlite3 *db;\n  db = p->db;\n\n  /* If the VM did not run to completion or if it encountered an\n  ** error, then it might not have been halted properly.  So halt\n  ** it now.\n  */\n  sqlite3VdbeHalt(p);\n\n  /* If the VDBE has been run even partially, then transfer the error code\n  ** and error message from the VDBE into the main database structure.  But\n  ** if the VDBE has just been set to run but has not actually executed any\n  ** instructions yet, leave the main database error information unchanged.\n  */\n  if( p->pc>=0 ){\n    vdbeInvokeSqllog(p);\n    sqlite3VdbeTransferError(p);\n    if( p->runOnlyOnce ) p->expired = 1;\n  }else if( p->rc && p->expired ){\n    /* The expired flag was set on the VDBE before the first call\n    ** to sqlite3_step(). For consistency (since sqlite3_step() was\n    ** called), set the database error in this case as well.\n    */\n    sqlite3ErrorWithMsg(db, p->rc, p->zErrMsg ? \"%s\" : 0, p->zErrMsg);\n  }\n\n  /* Reset register contents and reclaim error message memory.\n  */\n#ifdef SQLITE_DEBUG\n  /* Execute assert() statements to ensure that the Vdbe.apCsr[] and \n  ** Vdbe.aMem[] arrays have already been cleaned up.  */\n  if( p->apCsr ) for(i=0; i<p->nCursor; i++) assert( p->apCsr[i]==0 );\n  if( p->aMem ){\n    for(i=0; i<p->nMem; i++) assert( p->aMem[i].flags==MEM_Undefined );\n  }\n#endif\n  sqlite3DbFree(db, p->zErrMsg);\n  p->zErrMsg = 0;\n  p->pResultSet = 0;\n#ifdef SQLITE_DEBUG\n  p->nWrite = 0;\n#endif\n\n  /* Save profiling information from this VDBE run.\n  */\n#ifdef VDBE_PROFILE\n  {\n    FILE *out = fopen(\"vdbe_profile.out\", \"a\");\n    if( out ){\n      fprintf(out, \"---- \");\n      for(i=0; i<p->nOp; i++){\n        fprintf(out, \"%02x\", p->aOp[i].opcode);\n      }\n      fprintf(out, \"\\n\");\n      if( p->zSql ){\n        char c, pc = 0;\n        fprintf(out, \"-- \");\n        for(i=0; (c = p->zSql[i])!=0; i++){\n          if( pc=='\\n' ) fprintf(out, \"-- \");\n          putc(c, out);\n          pc = c;\n        }\n        if( pc!='\\n' ) fprintf(out, \"\\n\");\n      }\n      for(i=0; i<p->nOp; i++){\n        char zHdr[100];\n        sqlite3_snprintf(sizeof(zHdr), zHdr, \"%6u %12llu %8llu \",\n           p->aOp[i].cnt,\n           p->aOp[i].cycles,\n           p->aOp[i].cnt>0 ? p->aOp[i].cycles/p->aOp[i].cnt : 0\n        );\n        fprintf(out, \"%s\", zHdr);\n        sqlite3VdbePrintOp(out, i, &p->aOp[i]);\n      }\n      fclose(out);\n    }\n  }\n#endif\n  p->magic = VDBE_MAGIC_RESET;\n  return p->rc & db->errMask;\n}\n \n/*\n** Clean up and delete a VDBE after execution.  Return an integer which is\n** the result code.  Write any error message text into *pzErrMsg.\n*/\nint sqlite3VdbeFinalize(Vdbe *p){\n  int rc = SQLITE_OK;\n  if( p->magic==VDBE_MAGIC_RUN || p->magic==VDBE_MAGIC_HALT ){\n    rc = sqlite3VdbeReset(p);\n    assert( (rc & p->db->errMask)==rc );\n  }\n  sqlite3VdbeDelete(p);\n  return rc;\n}\n\n/*\n** If parameter iOp is less than zero, then invoke the destructor for\n** all auxiliary data pointers currently cached by the VM passed as\n** the first argument.\n**\n** Or, if iOp is greater than or equal to zero, then the destructor is\n** only invoked for those auxiliary data pointers created by the user \n** function invoked by the OP_Function opcode at instruction iOp of \n** VM pVdbe, and only then if:\n**\n**    * the associated function parameter is the 32nd or later (counting\n**      from left to right), or\n**\n**    * the corresponding bit in argument mask is clear (where the first\n**      function parameter corresponds to bit 0 etc.).\n*/\nvoid sqlite3VdbeDeleteAuxData(sqlite3 *db, AuxData **pp, int iOp, int mask){\n  while( *pp ){\n    AuxData *pAux = *pp;\n    if( (iOp<0)\n     || (pAux->iAuxOp==iOp\n          && pAux->iAuxArg>=0\n          && (pAux->iAuxArg>31 || !(mask & MASKBIT32(pAux->iAuxArg))))\n    ){\n      testcase( pAux->iAuxArg==31 );\n      if( pAux->xDeleteAux ){\n        pAux->xDeleteAux(pAux->pAux);\n      }\n      *pp = pAux->pNextAux;\n      sqlite3DbFree(db, pAux);\n    }else{\n      pp= &pAux->pNextAux;\n    }\n  }\n}\n\n/*\n** Free all memory associated with the Vdbe passed as the second argument,\n** except for object itself, which is preserved.\n**\n** The difference between this function and sqlite3VdbeDelete() is that\n** VdbeDelete() also unlinks the Vdbe from the list of VMs associated with\n** the database connection and frees the object itself.\n*/\nvoid sqlite3VdbeClearObject(sqlite3 *db, Vdbe *p){\n  SubProgram *pSub, *pNext;\n  assert( p->db==0 || p->db==db );\n  releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);\n  for(pSub=p->pProgram; pSub; pSub=pNext){\n    pNext = pSub->pNext;\n    vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);\n    sqlite3DbFree(db, pSub);\n  }\n  if( p->magic!=VDBE_MAGIC_INIT ){\n    releaseMemArray(p->aVar, p->nVar);\n    sqlite3DbFree(db, p->pVList);\n    sqlite3DbFree(db, p->pFree);\n  }\n  vdbeFreeOpArray(db, p->aOp, p->nOp);\n  sqlite3DbFree(db, p->aColName);\n  sqlite3DbFree(db, p->zSql);\n#ifdef SQLITE_ENABLE_NORMALIZE\n  sqlite3DbFree(db, p->zNormSql);\n  {\n    DblquoteStr *pThis, *pNext;\n    for(pThis=p->pDblStr; pThis; pThis=pNext){\n      pNext = pThis->pNextStr;\n      sqlite3DbFree(db, pThis);\n    }\n  }\n#endif\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n  {\n    int i;\n    for(i=0; i<p->nScan; i++){\n      sqlite3DbFree(db, p->aScan[i].zName);\n    }\n    sqlite3DbFree(db, p->aScan);\n  }\n#endif\n}\n\n/*\n** Delete an entire VDBE.\n*/\nvoid sqlite3VdbeDelete(Vdbe *p){\n  sqlite3 *db;\n\n  assert( p!=0 );\n  db = p->db;\n  assert( sqlite3_mutex_held(db->mutex) );\n  sqlite3VdbeClearObject(db, p);\n  if( p->pPrev ){\n    p->pPrev->pNext = p->pNext;\n  }else{\n    assert( db->pVdbe==p );\n    db->pVdbe = p->pNext;\n  }\n  if( p->pNext ){\n    p->pNext->pPrev = p->pPrev;\n  }\n  p->magic = VDBE_MAGIC_DEAD;\n  p->db = 0;\n  sqlite3DbFreeNN(db, p);\n}\n\n/*\n** The cursor \"p\" has a pending seek operation that has not yet been\n** carried out.  Seek the cursor now.  If an error occurs, return\n** the appropriate error code.\n*/\nstatic int SQLITE_NOINLINE handleDeferredMoveto(VdbeCursor *p){\n  int res, rc;\n#ifdef SQLITE_TEST\n  extern int sqlite3_search_count;\n#endif\n  assert( p->deferredMoveto );\n  assert( p->isTable );\n  assert( p->eCurType==CURTYPE_BTREE );\n  rc = sqlite3BtreeMovetoUnpacked(p->uc.pCursor, 0, p->movetoTarget, 0, &res);\n  if( rc ) return rc;\n  if( res!=0 ) return SQLITE_CORRUPT_BKPT;\n#ifdef SQLITE_TEST\n  sqlite3_search_count++;\n#endif\n  p->deferredMoveto = 0;\n  p->cacheStatus = CACHE_STALE;\n  return SQLITE_OK;\n}\n\n/*\n** Something has moved cursor \"p\" out of place.  Maybe the row it was\n** pointed to was deleted out from under it.  Or maybe the btree was\n** rebalanced.  Whatever the cause, try to restore \"p\" to the place it\n** is supposed to be pointing.  If the row was deleted out from under the\n** cursor, set the cursor to point to a NULL row.\n*/\nstatic int SQLITE_NOINLINE handleMovedCursor(VdbeCursor *p){\n  int isDifferentRow, rc;\n  assert( p->eCurType==CURTYPE_BTREE );\n  assert( p->uc.pCursor!=0 );\n  assert( sqlite3BtreeCursorHasMoved(p->uc.pCursor) );\n  rc = sqlite3BtreeCursorRestore(p->uc.pCursor, &isDifferentRow);\n  p->cacheStatus = CACHE_STALE;\n  if( isDifferentRow ) p->nullRow = 1;\n  return rc;\n}\n\n/*\n** Check to ensure that the cursor is valid.  Restore the cursor\n** if need be.  Return any I/O error from the restore operation.\n*/\nint sqlite3VdbeCursorRestore(VdbeCursor *p){\n  assert( p->eCurType==CURTYPE_BTREE );\n  if( sqlite3BtreeCursorHasMoved(p->uc.pCursor) ){\n    return handleMovedCursor(p);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Make sure the cursor p is ready to read or write the row to which it\n** was last positioned.  Return an error code if an OOM fault or I/O error\n** prevents us from positioning the cursor to its correct position.\n**\n** If a MoveTo operation is pending on the given cursor, then do that\n** MoveTo now.  If no move is pending, check to see if the row has been\n** deleted out from under the cursor and if it has, mark the row as\n** a NULL row.\n**\n** If the cursor is already pointing to the correct row and that row has\n** not been deleted out from under the cursor, then this routine is a no-op.\n*/\nint sqlite3VdbeCursorMoveto(VdbeCursor **pp, int *piCol){\n  VdbeCursor *p = *pp;\n  assert( p->eCurType==CURTYPE_BTREE || p->eCurType==CURTYPE_PSEUDO );\n  if( p->deferredMoveto ){\n    int iMap;\n    if( p->aAltMap && (iMap = p->aAltMap[1+*piCol])>0 ){\n      *pp = p->pAltCursor;\n      *piCol = iMap - 1;\n      return SQLITE_OK;\n    }\n    return handleDeferredMoveto(p);\n  }\n  if( sqlite3BtreeCursorHasMoved(p->uc.pCursor) ){\n    return handleMovedCursor(p);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** The following functions:\n**\n** sqlite3VdbeSerialType()\n** sqlite3VdbeSerialTypeLen()\n** sqlite3VdbeSerialLen()\n** sqlite3VdbeSerialPut()\n** sqlite3VdbeSerialGet()\n**\n** encapsulate the code that serializes values for storage in SQLite\n** data and index records. Each serialized value consists of a\n** 'serial-type' and a blob of data. The serial type is an 8-byte unsigned\n** integer, stored as a varint.\n**\n** In an SQLite index record, the serial type is stored directly before\n** the blob of data that it corresponds to. In a table record, all serial\n** types are stored at the start of the record, and the blobs of data at\n** the end. Hence these functions allow the caller to handle the\n** serial-type and data blob separately.\n**\n** The following table describes the various storage classes for data:\n**\n**   serial type        bytes of data      type\n**   --------------     ---------------    ---------------\n**      0                     0            NULL\n**      1                     1            signed integer\n**      2                     2            signed integer\n**      3                     3            signed integer\n**      4                     4            signed integer\n**      5                     6            signed integer\n**      6                     8            signed integer\n**      7                     8            IEEE float\n**      8                     0            Integer constant 0\n**      9                     0            Integer constant 1\n**     10,11                               reserved for expansion\n**    N>=12 and even       (N-12)/2        BLOB\n**    N>=13 and odd        (N-13)/2        text\n**\n** The 8 and 9 types were added in 3.3.0, file format 4.  Prior versions\n** of SQLite will not understand those serial types.\n*/\n\n#if 0 /* Inlined into the OP_MakeRecord opcode */\n/*\n** Return the serial-type for the value stored in pMem.\n**\n** This routine might convert a large MEM_IntReal value into MEM_Real.\n**\n** 2019-07-11:  The primary user of this subroutine was the OP_MakeRecord\n** opcode in the byte-code engine.  But by moving this routine in-line, we\n** can omit some redundant tests and make that opcode a lot faster.  So\n** this routine is now only used by the STAT3 logic and STAT3 support has\n** ended.  The code is kept here for historical reference only.\n*/\nu32 sqlite3VdbeSerialType(Mem *pMem, int file_format, u32 *pLen){\n  int flags = pMem->flags;\n  u32 n;\n\n  assert( pLen!=0 );\n  if( flags&MEM_Null ){\n    *pLen = 0;\n    return 0;\n  }\n  if( flags&(MEM_Int|MEM_IntReal) ){\n    /* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */\n#   define MAX_6BYTE ((((i64)0x00008000)<<32)-1)\n    i64 i = pMem->u.i;\n    u64 u;\n    testcase( flags & MEM_Int );\n    testcase( flags & MEM_IntReal );\n    if( i<0 ){\n      u = ~i;\n    }else{\n      u = i;\n    }\n    if( u<=127 ){\n      if( (i&1)==i && file_format>=4 ){\n        *pLen = 0;\n        return 8+(u32)u;\n      }else{\n        *pLen = 1;\n        return 1;\n      }\n    }\n    if( u<=32767 ){ *pLen = 2; return 2; }\n    if( u<=8388607 ){ *pLen = 3; return 3; }\n    if( u<=2147483647 ){ *pLen = 4; return 4; }\n    if( u<=MAX_6BYTE ){ *pLen = 6; return 5; }\n    *pLen = 8;\n    if( flags&MEM_IntReal ){\n      /* If the value is IntReal and is going to take up 8 bytes to store\n      ** as an integer, then we might as well make it an 8-byte floating\n      ** point value */\n      pMem->u.r = (double)pMem->u.i;\n      pMem->flags &= ~MEM_IntReal;\n      pMem->flags |= MEM_Real;\n      return 7;\n    }\n    return 6;\n  }\n  if( flags&MEM_Real ){\n    *pLen = 8;\n    return 7;\n  }\n  assert( pMem->db->mallocFailed || flags&(MEM_Str|MEM_Blob) );\n  assert( pMem->n>=0 );\n  n = (u32)pMem->n;\n  if( flags & MEM_Zero ){\n    n += pMem->u.nZero;\n  }\n  *pLen = n;\n  return ((n*2) + 12 + ((flags&MEM_Str)!=0));\n}\n#endif /* inlined into OP_MakeRecord */\n\n/*\n** The sizes for serial types less than 128\n*/\nstatic const u8 sqlite3SmallTypeSizes[] = {\n        /*  0   1   2   3   4   5   6   7   8   9 */   \n/*   0 */   0,  1,  2,  3,  4,  6,  8,  8,  0,  0,\n/*  10 */   0,  0,  0,  0,  1,  1,  2,  2,  3,  3,\n/*  20 */   4,  4,  5,  5,  6,  6,  7,  7,  8,  8,\n/*  30 */   9,  9, 10, 10, 11, 11, 12, 12, 13, 13,\n/*  40 */  14, 14, 15, 15, 16, 16, 17, 17, 18, 18,\n/*  50 */  19, 19, 20, 20, 21, 21, 22, 22, 23, 23,\n/*  60 */  24, 24, 25, 25, 26, 26, 27, 27, 28, 28,\n/*  70 */  29, 29, 30, 30, 31, 31, 32, 32, 33, 33,\n/*  80 */  34, 34, 35, 35, 36, 36, 37, 37, 38, 38,\n/*  90 */  39, 39, 40, 40, 41, 41, 42, 42, 43, 43,\n/* 100 */  44, 44, 45, 45, 46, 46, 47, 47, 48, 48,\n/* 110 */  49, 49, 50, 50, 51, 51, 52, 52, 53, 53,\n/* 120 */  54, 54, 55, 55, 56, 56, 57, 57\n};\n\n/*\n** Return the length of the data corresponding to the supplied serial-type.\n*/\nu32 sqlite3VdbeSerialTypeLen(u32 serial_type){\n  if( serial_type>=128 ){\n    return (serial_type-12)/2;\n  }else{\n    assert( serial_type<12 \n            || sqlite3SmallTypeSizes[serial_type]==(serial_type - 12)/2 );\n    return sqlite3SmallTypeSizes[serial_type];\n  }\n}\nu8 sqlite3VdbeOneByteSerialTypeLen(u8 serial_type){\n  assert( serial_type<128 );\n  return sqlite3SmallTypeSizes[serial_type];  \n}\n\n/*\n** If we are on an architecture with mixed-endian floating \n** points (ex: ARM7) then swap the lower 4 bytes with the \n** upper 4 bytes.  Return the result.\n**\n** For most architectures, this is a no-op.\n**\n** (later):  It is reported to me that the mixed-endian problem\n** on ARM7 is an issue with GCC, not with the ARM7 chip.  It seems\n** that early versions of GCC stored the two words of a 64-bit\n** float in the wrong order.  And that error has been propagated\n** ever since.  The blame is not necessarily with GCC, though.\n** GCC might have just copying the problem from a prior compiler.\n** I am also told that newer versions of GCC that follow a different\n** ABI get the byte order right.\n**\n** Developers using SQLite on an ARM7 should compile and run their\n** application using -DSQLITE_DEBUG=1 at least once.  With DEBUG\n** enabled, some asserts below will ensure that the byte order of\n** floating point values is correct.\n**\n** (2007-08-30)  Frank van Vugt has studied this problem closely\n** and has send his findings to the SQLite developers.  Frank\n** writes that some Linux kernels offer floating point hardware\n** emulation that uses only 32-bit mantissas instead of a full \n** 48-bits as required by the IEEE standard.  (This is the\n** CONFIG_FPE_FASTFPE option.)  On such systems, floating point\n** byte swapping becomes very complicated.  To avoid problems,\n** the necessary byte swapping is carried out using a 64-bit integer\n** rather than a 64-bit float.  Frank assures us that the code here\n** works for him.  We, the developers, have no way to independently\n** verify this, but Frank seems to know what he is talking about\n** so we trust him.\n*/\n#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT\nstatic u64 floatSwap(u64 in){\n  union {\n    u64 r;\n    u32 i[2];\n  } u;\n  u32 t;\n\n  u.r = in;\n  t = u.i[0];\n  u.i[0] = u.i[1];\n  u.i[1] = t;\n  return u.r;\n}\n# define swapMixedEndianFloat(X)  X = floatSwap(X)\n#else\n# define swapMixedEndianFloat(X)\n#endif\n\n/*\n** Write the serialized data blob for the value stored in pMem into \n** buf. It is assumed that the caller has allocated sufficient space.\n** Return the number of bytes written.\n**\n** nBuf is the amount of space left in buf[].  The caller is responsible\n** for allocating enough space to buf[] to hold the entire field, exclusive\n** of the pMem->u.nZero bytes for a MEM_Zero value.\n**\n** Return the number of bytes actually written into buf[].  The number\n** of bytes in the zero-filled tail is included in the return value only\n** if those bytes were zeroed in buf[].\n*/ \nu32 sqlite3VdbeSerialPut(u8 *buf, Mem *pMem, u32 serial_type){\n  u32 len;\n\n  /* Integer and Real */\n  if( serial_type<=7 && serial_type>0 ){\n    u64 v;\n    u32 i;\n    if( serial_type==7 ){\n      assert( sizeof(v)==sizeof(pMem->u.r) );\n      memcpy(&v, &pMem->u.r, sizeof(v));\n      swapMixedEndianFloat(v);\n    }else{\n      v = pMem->u.i;\n    }\n    len = i = sqlite3SmallTypeSizes[serial_type];\n    assert( i>0 );\n    do{\n      buf[--i] = (u8)(v&0xFF);\n      v >>= 8;\n    }while( i );\n    return len;\n  }\n\n  /* String or blob */\n  if( serial_type>=12 ){\n    assert( pMem->n + ((pMem->flags & MEM_Zero)?pMem->u.nZero:0)\n             == (int)sqlite3VdbeSerialTypeLen(serial_type) );\n    len = pMem->n;\n    if( len>0 ) memcpy(buf, pMem->z, len);\n    return len;\n  }\n\n  /* NULL or constants 0 or 1 */\n  return 0;\n}\n\n/* Input \"x\" is a sequence of unsigned characters that represent a\n** big-endian integer.  Return the equivalent native integer\n*/\n#define ONE_BYTE_INT(x)    ((i8)(x)[0])\n#define TWO_BYTE_INT(x)    (256*(i8)((x)[0])|(x)[1])\n#define THREE_BYTE_INT(x)  (65536*(i8)((x)[0])|((x)[1]<<8)|(x)[2])\n#define FOUR_BYTE_UINT(x)  (((u32)(x)[0]<<24)|((x)[1]<<16)|((x)[2]<<8)|(x)[3])\n#define FOUR_BYTE_INT(x) (16777216*(i8)((x)[0])|((x)[1]<<16)|((x)[2]<<8)|(x)[3])\n\n/*\n** Deserialize the data blob pointed to by buf as serial type serial_type\n** and store the result in pMem.  Return the number of bytes read.\n**\n** This function is implemented as two separate routines for performance.\n** The few cases that require local variables are broken out into a separate\n** routine so that in most cases the overhead of moving the stack pointer\n** is avoided.\n*/ \nstatic u32 serialGet(\n  const unsigned char *buf,     /* Buffer to deserialize from */\n  u32 serial_type,              /* Serial type to deserialize */\n  Mem *pMem                     /* Memory cell to write value into */\n){\n  u64 x = FOUR_BYTE_UINT(buf);\n  u32 y = FOUR_BYTE_UINT(buf+4);\n  x = (x<<32) + y;\n  if( serial_type==6 ){\n    /* EVIDENCE-OF: R-29851-52272 Value is a big-endian 64-bit\n    ** twos-complement integer. */\n    pMem->u.i = *(i64*)&x;\n    pMem->flags = MEM_Int;\n    testcase( pMem->u.i<0 );\n  }else{\n    /* EVIDENCE-OF: R-57343-49114 Value is a big-endian IEEE 754-2008 64-bit\n    ** floating point number. */\n#if !defined(NDEBUG) && !defined(SQLITE_OMIT_FLOATING_POINT)\n    /* Verify that integers and floating point values use the same\n    ** byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is\n    ** defined that 64-bit floating point values really are mixed\n    ** endian.\n    */\n    static const u64 t1 = ((u64)0x3ff00000)<<32;\n    static const double r1 = 1.0;\n    u64 t2 = t1;\n    swapMixedEndianFloat(t2);\n    assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, &t2, sizeof(r1))==0 );\n#endif\n    assert( sizeof(x)==8 && sizeof(pMem->u.r)==8 );\n    swapMixedEndianFloat(x);\n    memcpy(&pMem->u.r, &x, sizeof(x));\n    pMem->flags = IsNaN(x) ? MEM_Null : MEM_Real;\n  }\n  return 8;\n}\nu32 sqlite3VdbeSerialGet(\n  const unsigned char *buf,     /* Buffer to deserialize from */\n  u32 serial_type,              /* Serial type to deserialize */\n  Mem *pMem                     /* Memory cell to write value into */\n){\n  switch( serial_type ){\n    case 10: { /* Internal use only: NULL with virtual table\n               ** UPDATE no-change flag set */\n      pMem->flags = MEM_Null|MEM_Zero;\n      pMem->n = 0;\n      pMem->u.nZero = 0;\n      break;\n    }\n    case 11:   /* Reserved for future use */\n    case 0: {  /* Null */\n      /* EVIDENCE-OF: R-24078-09375 Value is a NULL. */\n      pMem->flags = MEM_Null;\n      break;\n    }\n    case 1: {\n      /* EVIDENCE-OF: R-44885-25196 Value is an 8-bit twos-complement\n      ** integer. */\n      pMem->u.i = ONE_BYTE_INT(buf);\n      pMem->flags = MEM_Int;\n      testcase( pMem->u.i<0 );\n      return 1;\n    }\n    case 2: { /* 2-byte signed integer */\n      /* EVIDENCE-OF: R-49794-35026 Value is a big-endian 16-bit\n      ** twos-complement integer. */\n      pMem->u.i = TWO_BYTE_INT(buf);\n      pMem->flags = MEM_Int;\n      testcase( pMem->u.i<0 );\n      return 2;\n    }\n    case 3: { /* 3-byte signed integer */\n      /* EVIDENCE-OF: R-37839-54301 Value is a big-endian 24-bit\n      ** twos-complement integer. */\n      pMem->u.i = THREE_BYTE_INT(buf);\n      pMem->flags = MEM_Int;\n      testcase( pMem->u.i<0 );\n      return 3;\n    }\n    case 4: { /* 4-byte signed integer */\n      /* EVIDENCE-OF: R-01849-26079 Value is a big-endian 32-bit\n      ** twos-complement integer. */\n      pMem->u.i = FOUR_BYTE_INT(buf);\n#ifdef __HP_cc \n      /* Work around a sign-extension bug in the HP compiler for HP/UX */\n      if( buf[0]&0x80 ) pMem->u.i |= 0xffffffff80000000LL;\n#endif\n      pMem->flags = MEM_Int;\n      testcase( pMem->u.i<0 );\n      return 4;\n    }\n    case 5: { /* 6-byte signed integer */\n      /* EVIDENCE-OF: R-50385-09674 Value is a big-endian 48-bit\n      ** twos-complement integer. */\n      pMem->u.i = FOUR_BYTE_UINT(buf+2) + (((i64)1)<<32)*TWO_BYTE_INT(buf);\n      pMem->flags = MEM_Int;\n      testcase( pMem->u.i<0 );\n      return 6;\n    }\n    case 6:   /* 8-byte signed integer */\n    case 7: { /* IEEE floating point */\n      /* These use local variables, so do them in a separate routine\n      ** to avoid having to move the frame pointer in the common case */\n      return serialGet(buf,serial_type,pMem);\n    }\n    case 8:    /* Integer 0 */\n    case 9: {  /* Integer 1 */\n      /* EVIDENCE-OF: R-12976-22893 Value is the integer 0. */\n      /* EVIDENCE-OF: R-18143-12121 Value is the integer 1. */\n      pMem->u.i = serial_type-8;\n      pMem->flags = MEM_Int;\n      return 0;\n    }\n    default: {\n      /* EVIDENCE-OF: R-14606-31564 Value is a BLOB that is (N-12)/2 bytes in\n      ** length.\n      ** EVIDENCE-OF: R-28401-00140 Value is a string in the text encoding and\n      ** (N-13)/2 bytes in length. */\n      static const u16 aFlag[] = { MEM_Blob|MEM_Ephem, MEM_Str|MEM_Ephem };\n      pMem->z = (char *)buf;\n      pMem->n = (serial_type-12)/2;\n      pMem->flags = aFlag[serial_type&1];\n      return pMem->n;\n    }\n  }\n  return 0;\n}\n/*\n** This routine is used to allocate sufficient space for an UnpackedRecord\n** structure large enough to be used with sqlite3VdbeRecordUnpack() if\n** the first argument is a pointer to KeyInfo structure pKeyInfo.\n**\n** The space is either allocated using sqlite3DbMallocRaw() or from within\n** the unaligned buffer passed via the second and third arguments (presumably\n** stack space). If the former, then *ppFree is set to a pointer that should\n** be eventually freed by the caller using sqlite3DbFree(). Or, if the \n** allocation comes from the pSpace/szSpace buffer, *ppFree is set to NULL\n** before returning.\n**\n** If an OOM error occurs, NULL is returned.\n*/\nUnpackedRecord *sqlite3VdbeAllocUnpackedRecord(\n  KeyInfo *pKeyInfo               /* Description of the record */\n){\n  UnpackedRecord *p;              /* Unpacked record to return */\n  int nByte;                      /* Number of bytes required for *p */\n  nByte = ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*(pKeyInfo->nKeyField+1);\n  p = (UnpackedRecord *)sqlite3DbMallocRaw(pKeyInfo->db, nByte);\n  if( !p ) return 0;\n  p->aMem = (Mem*)&((char*)p)[ROUND8(sizeof(UnpackedRecord))];\n  assert( pKeyInfo->aSortFlags!=0 );\n  p->pKeyInfo = pKeyInfo;\n  p->nField = pKeyInfo->nKeyField + 1;\n  return p;\n}\n\n/*\n** Given the nKey-byte encoding of a record in pKey[], populate the \n** UnpackedRecord structure indicated by the fourth argument with the\n** contents of the decoded record.\n*/ \nvoid sqlite3VdbeRecordUnpack(\n  KeyInfo *pKeyInfo,     /* Information about the record format */\n  int nKey,              /* Size of the binary record */\n  const void *pKey,      /* The binary record */\n  UnpackedRecord *p      /* Populate this structure before returning. */\n){\n  const unsigned char *aKey = (const unsigned char *)pKey;\n  u32 d; \n  u32 idx;                        /* Offset in aKey[] to read from */\n  u16 u;                          /* Unsigned loop counter */\n  u32 szHdr;\n  Mem *pMem = p->aMem;\n\n  p->default_rc = 0;\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n  idx = getVarint32(aKey, szHdr);\n  d = szHdr;\n  u = 0;\n  while( idx<szHdr && d<=(u32)nKey ){\n    u32 serial_type;\n\n    idx += getVarint32(&aKey[idx], serial_type);\n    pMem->enc = pKeyInfo->enc;\n    pMem->db = pKeyInfo->db;\n    /* pMem->flags = 0; // sqlite3VdbeSerialGet() will set this for us */\n    pMem->szMalloc = 0;\n    pMem->z = 0;\n    d += sqlite3VdbeSerialGet(&aKey[d], serial_type, pMem);\n    pMem++;\n    if( (++u)>=p->nField ) break;\n  }\n  if( d>(u32)nKey && u ){\n    assert( CORRUPT_DB );\n    /* In a corrupt record entry, the last pMem might have been set up using \n    ** uninitialized memory. Overwrite its value with NULL, to prevent\n    ** warnings from MSAN. */\n    sqlite3VdbeMemSetNull(pMem-1);\n  }\n  assert( u<=pKeyInfo->nKeyField + 1 );\n  p->nField = u;\n}\n\n#ifdef SQLITE_DEBUG\n/*\n** This function compares two index or table record keys in the same way\n** as the sqlite3VdbeRecordCompare() routine. Unlike VdbeRecordCompare(),\n** this function deserializes and compares values using the\n** sqlite3VdbeSerialGet() and sqlite3MemCompare() functions. It is used\n** in assert() statements to ensure that the optimized code in\n** sqlite3VdbeRecordCompare() returns results with these two primitives.\n**\n** Return true if the result of comparison is equivalent to desiredResult.\n** Return false if there is a disagreement.\n*/\nstatic int vdbeRecordCompareDebug(\n  int nKey1, const void *pKey1, /* Left key */\n  const UnpackedRecord *pPKey2, /* Right key */\n  int desiredResult             /* Correct answer */\n){\n  u32 d1;            /* Offset into aKey[] of next data element */\n  u32 idx1;          /* Offset into aKey[] of next header element */\n  u32 szHdr1;        /* Number of bytes in header */\n  int i = 0;\n  int rc = 0;\n  const unsigned char *aKey1 = (const unsigned char *)pKey1;\n  KeyInfo *pKeyInfo;\n  Mem mem1;\n\n  pKeyInfo = pPKey2->pKeyInfo;\n  if( pKeyInfo->db==0 ) return 1;\n  mem1.enc = pKeyInfo->enc;\n  mem1.db = pKeyInfo->db;\n  /* mem1.flags = 0;  // Will be initialized by sqlite3VdbeSerialGet() */\n  VVA_ONLY( mem1.szMalloc = 0; ) /* Only needed by assert() statements */\n\n  /* Compilers may complain that mem1.u.i is potentially uninitialized.\n  ** We could initialize it, as shown here, to silence those complaints.\n  ** But in fact, mem1.u.i will never actually be used uninitialized, and doing \n  ** the unnecessary initialization has a measurable negative performance\n  ** impact, since this routine is a very high runner.  And so, we choose\n  ** to ignore the compiler warnings and leave this variable uninitialized.\n  */\n  /*  mem1.u.i = 0;  // not needed, here to silence compiler warning */\n  \n  idx1 = getVarint32(aKey1, szHdr1);\n  if( szHdr1>98307 ) return SQLITE_CORRUPT;\n  d1 = szHdr1;\n  assert( pKeyInfo->nAllField>=pPKey2->nField || CORRUPT_DB );\n  assert( pKeyInfo->aSortFlags!=0 );\n  assert( pKeyInfo->nKeyField>0 );\n  assert( idx1<=szHdr1 || CORRUPT_DB );\n  do{\n    u32 serial_type1;\n\n    /* Read the serial types for the next element in each key. */\n    idx1 += getVarint32( aKey1+idx1, serial_type1 );\n\n    /* Verify that there is enough key space remaining to avoid\n    ** a buffer overread.  The \"d1+serial_type1+2\" subexpression will\n    ** always be greater than or equal to the amount of required key space.\n    ** Use that approximation to avoid the more expensive call to\n    ** sqlite3VdbeSerialTypeLen() in the common case.\n    */\n    if( d1+(u64)serial_type1+2>(u64)nKey1\n     && d1+(u64)sqlite3VdbeSerialTypeLen(serial_type1)>(u64)nKey1 \n    ){\n      break;\n    }\n\n    /* Extract the values to be compared.\n    */\n    d1 += sqlite3VdbeSerialGet(&aKey1[d1], serial_type1, &mem1);\n\n    /* Do the comparison\n    */\n    rc = sqlite3MemCompare(&mem1, &pPKey2->aMem[i],\n                           pKeyInfo->nAllField>i ? pKeyInfo->aColl[i] : 0);\n    if( rc!=0 ){\n      assert( mem1.szMalloc==0 );  /* See comment below */\n      if( (pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_BIGNULL)\n       && ((mem1.flags & MEM_Null) || (pPKey2->aMem[i].flags & MEM_Null)) \n      ){\n        rc = -rc;\n      }\n      if( pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_DESC ){\n        rc = -rc;  /* Invert the result for DESC sort order. */\n      }\n      goto debugCompareEnd;\n    }\n    i++;\n  }while( idx1<szHdr1 && i<pPKey2->nField );\n\n  /* No memory allocation is ever used on mem1.  Prove this using\n  ** the following assert().  If the assert() fails, it indicates a\n  ** memory leak and a need to call sqlite3VdbeMemRelease(&mem1).\n  */\n  assert( mem1.szMalloc==0 );\n\n  /* rc==0 here means that one of the keys ran out of fields and\n  ** all the fields up to that point were equal. Return the default_rc\n  ** value.  */\n  rc = pPKey2->default_rc;\n\ndebugCompareEnd:\n  if( desiredResult==0 && rc==0 ) return 1;\n  if( desiredResult<0 && rc<0 ) return 1;\n  if( desiredResult>0 && rc>0 ) return 1;\n  if( CORRUPT_DB ) return 1;\n  if( pKeyInfo->db->mallocFailed ) return 1;\n  return 0;\n}\n#endif\n\n#ifdef SQLITE_DEBUG\n/*\n** Count the number of fields (a.k.a. columns) in the record given by\n** pKey,nKey.  The verify that this count is less than or equal to the\n** limit given by pKeyInfo->nAllField.\n**\n** If this constraint is not satisfied, it means that the high-speed\n** vdbeRecordCompareInt() and vdbeRecordCompareString() routines will\n** not work correctly.  If this assert() ever fires, it probably means\n** that the KeyInfo.nKeyField or KeyInfo.nAllField values were computed\n** incorrectly.\n*/\nstatic void vdbeAssertFieldCountWithinLimits(\n  int nKey, const void *pKey,   /* The record to verify */ \n  const KeyInfo *pKeyInfo       /* Compare size with this KeyInfo */\n){\n  int nField = 0;\n  u32 szHdr;\n  u32 idx;\n  u32 notUsed;\n  const unsigned char *aKey = (const unsigned char*)pKey;\n\n  if( CORRUPT_DB ) return;\n  idx = getVarint32(aKey, szHdr);\n  assert( nKey>=0 );\n  assert( szHdr<=(u32)nKey );\n  while( idx<szHdr ){\n    idx += getVarint32(aKey+idx, notUsed);\n    nField++;\n  }\n  assert( nField <= pKeyInfo->nAllField );\n}\n#else\n# define vdbeAssertFieldCountWithinLimits(A,B,C)\n#endif\n\n/*\n** Both *pMem1 and *pMem2 contain string values. Compare the two values\n** using the collation sequence pColl. As usual, return a negative , zero\n** or positive value if *pMem1 is less than, equal to or greater than \n** *pMem2, respectively. Similar in spirit to \"rc = (*pMem1) - (*pMem2);\".\n*/\nstatic int vdbeCompareMemString(\n  const Mem *pMem1,\n  const Mem *pMem2,\n  const CollSeq *pColl,\n  u8 *prcErr                      /* If an OOM occurs, set to SQLITE_NOMEM */\n){\n  if( pMem1->enc==pColl->enc ){\n    /* The strings are already in the correct encoding.  Call the\n     ** comparison function directly */\n    return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);\n  }else{\n    int rc;\n    const void *v1, *v2;\n    Mem c1;\n    Mem c2;\n    sqlite3VdbeMemInit(&c1, pMem1->db, MEM_Null);\n    sqlite3VdbeMemInit(&c2, pMem1->db, MEM_Null);\n    sqlite3VdbeMemShallowCopy(&c1, pMem1, MEM_Ephem);\n    sqlite3VdbeMemShallowCopy(&c2, pMem2, MEM_Ephem);\n    v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);\n    v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);\n    if( (v1==0 || v2==0) ){\n      if( prcErr ) *prcErr = SQLITE_NOMEM_BKPT;\n      rc = 0;\n    }else{\n      rc = pColl->xCmp(pColl->pUser, c1.n, v1, c2.n, v2);\n    }\n    sqlite3VdbeMemRelease(&c1);\n    sqlite3VdbeMemRelease(&c2);\n    return rc;\n  }\n}\n\n/*\n** The input pBlob is guaranteed to be a Blob that is not marked\n** with MEM_Zero.  Return true if it could be a zero-blob.\n*/\nstatic int isAllZero(const char *z, int n){\n  int i;\n  for(i=0; i<n; i++){\n    if( z[i] ) return 0;\n  }\n  return 1;\n}\n\n/*\n** Compare two blobs.  Return negative, zero, or positive if the first\n** is less than, equal to, or greater than the second, respectively.\n** If one blob is a prefix of the other, then the shorter is the lessor.\n*/\nSQLITE_NOINLINE int sqlite3BlobCompare(const Mem *pB1, const Mem *pB2){\n  int c;\n  int n1 = pB1->n;\n  int n2 = pB2->n;\n\n  /* It is possible to have a Blob value that has some non-zero content\n  ** followed by zero content.  But that only comes up for Blobs formed\n  ** by the OP_MakeRecord opcode, and such Blobs never get passed into\n  ** sqlite3MemCompare(). */\n  assert( (pB1->flags & MEM_Zero)==0 || n1==0 );\n  assert( (pB2->flags & MEM_Zero)==0 || n2==0 );\n\n  if( (pB1->flags|pB2->flags) & MEM_Zero ){\n    if( pB1->flags & pB2->flags & MEM_Zero ){\n      return pB1->u.nZero - pB2->u.nZero;\n    }else if( pB1->flags & MEM_Zero ){\n      if( !isAllZero(pB2->z, pB2->n) ) return -1;\n      return pB1->u.nZero - n2;\n    }else{\n      if( !isAllZero(pB1->z, pB1->n) ) return +1;\n      return n1 - pB2->u.nZero;\n    }\n  }\n  c = memcmp(pB1->z, pB2->z, n1>n2 ? n2 : n1);\n  if( c ) return c;\n  return n1 - n2;\n}\n\n/*\n** Do a comparison between a 64-bit signed integer and a 64-bit floating-point\n** number.  Return negative, zero, or positive if the first (i64) is less than,\n** equal to, or greater than the second (double).\n*/\nstatic int sqlite3IntFloatCompare(i64 i, double r){\n  if( sizeof(LONGDOUBLE_TYPE)>8 ){\n    LONGDOUBLE_TYPE x = (LONGDOUBLE_TYPE)i;\n    if( x<r ) return -1;\n    if( x>r ) return +1;\n    return 0;\n  }else{\n    i64 y;\n    double s;\n    if( r<-9223372036854775808.0 ) return +1;\n    if( r>=9223372036854775808.0 ) return -1;\n    y = (i64)r;\n    if( i<y ) return -1;\n    if( i>y ) return +1;\n    s = (double)i;\n    if( s<r ) return -1;\n    if( s>r ) return +1;\n    return 0;\n  }\n}\n\n/*\n** Compare the values contained by the two memory cells, returning\n** negative, zero or positive if pMem1 is less than, equal to, or greater\n** than pMem2. Sorting order is NULL's first, followed by numbers (integers\n** and reals) sorted numerically, followed by text ordered by the collating\n** sequence pColl and finally blob's ordered by memcmp().\n**\n** Two NULL values are considered equal by this function.\n*/\nint sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){\n  int f1, f2;\n  int combined_flags;\n\n  f1 = pMem1->flags;\n  f2 = pMem2->flags;\n  combined_flags = f1|f2;\n  assert( !sqlite3VdbeMemIsRowSet(pMem1) && !sqlite3VdbeMemIsRowSet(pMem2) );\n \n  /* If one value is NULL, it is less than the other. If both values\n  ** are NULL, return 0.\n  */\n  if( combined_flags&MEM_Null ){\n    return (f2&MEM_Null) - (f1&MEM_Null);\n  }\n\n  /* At least one of the two values is a number\n  */\n  if( combined_flags&(MEM_Int|MEM_Real|MEM_IntReal) ){\n    testcase( combined_flags & MEM_Int );\n    testcase( combined_flags & MEM_Real );\n    testcase( combined_flags & MEM_IntReal );\n    if( (f1 & f2 & (MEM_Int|MEM_IntReal))!=0 ){\n      testcase( f1 & f2 & MEM_Int );\n      testcase( f1 & f2 & MEM_IntReal );\n      if( pMem1->u.i < pMem2->u.i ) return -1;\n      if( pMem1->u.i > pMem2->u.i ) return +1;\n      return 0;\n    }\n    if( (f1 & f2 & MEM_Real)!=0 ){\n      if( pMem1->u.r < pMem2->u.r ) return -1;\n      if( pMem1->u.r > pMem2->u.r ) return +1;\n      return 0;\n    }\n    if( (f1&(MEM_Int|MEM_IntReal))!=0 ){\n      testcase( f1 & MEM_Int );\n      testcase( f1 & MEM_IntReal );\n      if( (f2&MEM_Real)!=0 ){\n        return sqlite3IntFloatCompare(pMem1->u.i, pMem2->u.r);\n      }else if( (f2&(MEM_Int|MEM_IntReal))!=0 ){\n        if( pMem1->u.i < pMem2->u.i ) return -1;\n        if( pMem1->u.i > pMem2->u.i ) return +1;\n        return 0;\n      }else{\n        return -1;\n      }\n    }\n    if( (f1&MEM_Real)!=0 ){\n      if( (f2&(MEM_Int|MEM_IntReal))!=0 ){\n        testcase( f2 & MEM_Int );\n        testcase( f2 & MEM_IntReal );\n        return -sqlite3IntFloatCompare(pMem2->u.i, pMem1->u.r);\n      }else{\n        return -1;\n      }\n    }\n    return +1;\n  }\n\n  /* If one value is a string and the other is a blob, the string is less.\n  ** If both are strings, compare using the collating functions.\n  */\n  if( combined_flags&MEM_Str ){\n    if( (f1 & MEM_Str)==0 ){\n      return 1;\n    }\n    if( (f2 & MEM_Str)==0 ){\n      return -1;\n    }\n\n    assert( pMem1->enc==pMem2->enc || pMem1->db->mallocFailed );\n    assert( pMem1->enc==SQLITE_UTF8 || \n            pMem1->enc==SQLITE_UTF16LE || pMem1->enc==SQLITE_UTF16BE );\n\n    /* The collation sequence must be defined at this point, even if\n    ** the user deletes the collation sequence after the vdbe program is\n    ** compiled (this was not always the case).\n    */\n    assert( !pColl || pColl->xCmp );\n\n    if( pColl ){\n      return vdbeCompareMemString(pMem1, pMem2, pColl, 0);\n    }\n    /* If a NULL pointer was passed as the collate function, fall through\n    ** to the blob case and use memcmp().  */\n  }\n \n  /* Both values must be blobs.  Compare using memcmp().  */\n  return sqlite3BlobCompare(pMem1, pMem2);\n}\n\n\n/*\n** The first argument passed to this function is a serial-type that\n** corresponds to an integer - all values between 1 and 9 inclusive \n** except 7. The second points to a buffer containing an integer value\n** serialized according to serial_type. This function deserializes\n** and returns the value.\n*/\nstatic i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey){\n  u32 y;\n  assert( CORRUPT_DB || (serial_type>=1 && serial_type<=9 && serial_type!=7) );\n  switch( serial_type ){\n    case 0:\n    case 1:\n      testcase( aKey[0]&0x80 );\n      return ONE_BYTE_INT(aKey);\n    case 2:\n      testcase( aKey[0]&0x80 );\n      return TWO_BYTE_INT(aKey);\n    case 3:\n      testcase( aKey[0]&0x80 );\n      return THREE_BYTE_INT(aKey);\n    case 4: {\n      testcase( aKey[0]&0x80 );\n      y = FOUR_BYTE_UINT(aKey);\n      return (i64)*(int*)&y;\n    }\n    case 5: {\n      testcase( aKey[0]&0x80 );\n      return FOUR_BYTE_UINT(aKey+2) + (((i64)1)<<32)*TWO_BYTE_INT(aKey);\n    }\n    case 6: {\n      u64 x = FOUR_BYTE_UINT(aKey);\n      testcase( aKey[0]&0x80 );\n      x = (x<<32) | FOUR_BYTE_UINT(aKey+4);\n      return (i64)*(i64*)&x;\n    }\n  }\n\n  return (serial_type - 8);\n}\n\n/*\n** This function compares the two table rows or index records\n** specified by {nKey1, pKey1} and pPKey2.  It returns a negative, zero\n** or positive integer if key1 is less than, equal to or \n** greater than key2.  The {nKey1, pKey1} key must be a blob\n** created by the OP_MakeRecord opcode of the VDBE.  The pPKey2\n** key must be a parsed key such as obtained from\n** sqlite3VdbeParseRecord.\n**\n** If argument bSkip is non-zero, it is assumed that the caller has already\n** determined that the first fields of the keys are equal.\n**\n** Key1 and Key2 do not have to contain the same number of fields. If all \n** fields that appear in both keys are equal, then pPKey2->default_rc is \n** returned.\n**\n** If database corruption is discovered, set pPKey2->errCode to \n** SQLITE_CORRUPT and return 0. If an OOM error is encountered, \n** pPKey2->errCode is set to SQLITE_NOMEM and, if it is not NULL, the\n** malloc-failed flag set on database handle (pPKey2->pKeyInfo->db).\n*/\nint sqlite3VdbeRecordCompareWithSkip(\n  int nKey1, const void *pKey1,   /* Left key */\n  UnpackedRecord *pPKey2,         /* Right key */\n  int bSkip                       /* If true, skip the first field */\n){\n  u32 d1;                         /* Offset into aKey[] of next data element */\n  int i;                          /* Index of next field to compare */\n  u32 szHdr1;                     /* Size of record header in bytes */\n  u32 idx1;                       /* Offset of first type in header */\n  int rc = 0;                     /* Return value */\n  Mem *pRhs = pPKey2->aMem;       /* Next field of pPKey2 to compare */\n  KeyInfo *pKeyInfo;\n  const unsigned char *aKey1 = (const unsigned char *)pKey1;\n  Mem mem1;\n\n  /* If bSkip is true, then the caller has already determined that the first\n  ** two elements in the keys are equal. Fix the various stack variables so\n  ** that this routine begins comparing at the second field. */\n  if( bSkip ){\n    u32 s1;\n    idx1 = 1 + getVarint32(&aKey1[1], s1);\n    szHdr1 = aKey1[0];\n    d1 = szHdr1 + sqlite3VdbeSerialTypeLen(s1);\n    i = 1;\n    pRhs++;\n  }else{\n    idx1 = getVarint32(aKey1, szHdr1);\n    d1 = szHdr1;\n    i = 0;\n  }\n  if( d1>(unsigned)nKey1 ){ \n    pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;\n    return 0;  /* Corruption */\n  }\n\n  VVA_ONLY( mem1.szMalloc = 0; ) /* Only needed by assert() statements */\n  assert( pPKey2->pKeyInfo->nAllField>=pPKey2->nField \n       || CORRUPT_DB );\n  assert( pPKey2->pKeyInfo->aSortFlags!=0 );\n  assert( pPKey2->pKeyInfo->nKeyField>0 );\n  assert( idx1<=szHdr1 || CORRUPT_DB );\n  do{\n    u32 serial_type;\n\n    /* RHS is an integer */\n    if( pRhs->flags & (MEM_Int|MEM_IntReal) ){\n      testcase( pRhs->flags & MEM_Int );\n      testcase( pRhs->flags & MEM_IntReal );\n      serial_type = aKey1[idx1];\n      testcase( serial_type==12 );\n      if( serial_type>=10 ){\n        rc = +1;\n      }else if( serial_type==0 ){\n        rc = -1;\n      }else if( serial_type==7 ){\n        sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);\n        rc = -sqlite3IntFloatCompare(pRhs->u.i, mem1.u.r);\n      }else{\n        i64 lhs = vdbeRecordDecodeInt(serial_type, &aKey1[d1]);\n        i64 rhs = pRhs->u.i;\n        if( lhs<rhs ){\n          rc = -1;\n        }else if( lhs>rhs ){\n          rc = +1;\n        }\n      }\n    }\n\n    /* RHS is real */\n    else if( pRhs->flags & MEM_Real ){\n      serial_type = aKey1[idx1];\n      if( serial_type>=10 ){\n        /* Serial types 12 or greater are strings and blobs (greater than\n        ** numbers). Types 10 and 11 are currently \"reserved for future \n        ** use\", so it doesn't really matter what the results of comparing\n        ** them to numberic values are.  */\n        rc = +1;\n      }else if( serial_type==0 ){\n        rc = -1;\n      }else{\n        sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);\n        if( serial_type==7 ){\n          if( mem1.u.r<pRhs->u.r ){\n            rc = -1;\n          }else if( mem1.u.r>pRhs->u.r ){\n            rc = +1;\n          }\n        }else{\n          rc = sqlite3IntFloatCompare(mem1.u.i, pRhs->u.r);\n        }\n      }\n    }\n\n    /* RHS is a string */\n    else if( pRhs->flags & MEM_Str ){\n      getVarint32(&aKey1[idx1], serial_type);\n      testcase( serial_type==12 );\n      if( serial_type<12 ){\n        rc = -1;\n      }else if( !(serial_type & 0x01) ){\n        rc = +1;\n      }else{\n        mem1.n = (serial_type - 12) / 2;\n        testcase( (d1+mem1.n)==(unsigned)nKey1 );\n        testcase( (d1+mem1.n+1)==(unsigned)nKey1 );\n        if( (d1+mem1.n) > (unsigned)nKey1\n         || (pKeyInfo = pPKey2->pKeyInfo)->nAllField<=i\n        ){\n          pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;\n          return 0;                /* Corruption */\n        }else if( pKeyInfo->aColl[i] ){\n          mem1.enc = pKeyInfo->enc;\n          mem1.db = pKeyInfo->db;\n          mem1.flags = MEM_Str;\n          mem1.z = (char*)&aKey1[d1];\n          rc = vdbeCompareMemString(\n              &mem1, pRhs, pKeyInfo->aColl[i], &pPKey2->errCode\n          );\n        }else{\n          int nCmp = MIN(mem1.n, pRhs->n);\n          rc = memcmp(&aKey1[d1], pRhs->z, nCmp);\n          if( rc==0 ) rc = mem1.n - pRhs->n; \n        }\n      }\n    }\n\n    /* RHS is a blob */\n    else if( pRhs->flags & MEM_Blob ){\n      assert( (pRhs->flags & MEM_Zero)==0 || pRhs->n==0 );\n      getVarint32(&aKey1[idx1], serial_type);\n      testcase( serial_type==12 );\n      if( serial_type<12 || (serial_type & 0x01) ){\n        rc = -1;\n      }else{\n        int nStr = (serial_type - 12) / 2;\n        testcase( (d1+nStr)==(unsigned)nKey1 );\n        testcase( (d1+nStr+1)==(unsigned)nKey1 );\n        if( (d1+nStr) > (unsigned)nKey1 ){\n          pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;\n          return 0;                /* Corruption */\n        }else if( pRhs->flags & MEM_Zero ){\n          if( !isAllZero((const char*)&aKey1[d1],nStr) ){\n            rc = 1;\n          }else{\n            rc = nStr - pRhs->u.nZero;\n          }\n        }else{\n          int nCmp = MIN(nStr, pRhs->n);\n          rc = memcmp(&aKey1[d1], pRhs->z, nCmp);\n          if( rc==0 ) rc = nStr - pRhs->n;\n        }\n      }\n    }\n\n    /* RHS is null */\n    else{\n      serial_type = aKey1[idx1];\n      rc = (serial_type!=0);\n    }\n\n    if( rc!=0 ){\n      int sortFlags = pPKey2->pKeyInfo->aSortFlags[i];\n      if( sortFlags ){\n        if( (sortFlags & KEYINFO_ORDER_BIGNULL)==0\n         || ((sortFlags & KEYINFO_ORDER_DESC)\n           !=(serial_type==0 || (pRhs->flags&MEM_Null)))\n        ){\n          rc = -rc;\n        }\n      }\n      assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, rc) );\n      assert( mem1.szMalloc==0 );  /* See comment below */\n      return rc;\n    }\n\n    i++;\n    if( i==pPKey2->nField ) break;\n    pRhs++;\n    d1 += sqlite3VdbeSerialTypeLen(serial_type);\n    idx1 += sqlite3VarintLen(serial_type);\n  }while( idx1<(unsigned)szHdr1 && d1<=(unsigned)nKey1 );\n\n  /* No memory allocation is ever used on mem1.  Prove this using\n  ** the following assert().  If the assert() fails, it indicates a\n  ** memory leak and a need to call sqlite3VdbeMemRelease(&mem1).  */\n  assert( mem1.szMalloc==0 );\n\n  /* rc==0 here means that one or both of the keys ran out of fields and\n  ** all the fields up to that point were equal. Return the default_rc\n  ** value.  */\n  assert( CORRUPT_DB \n       || vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, pPKey2->default_rc) \n       || pPKey2->pKeyInfo->db->mallocFailed\n  );\n  pPKey2->eqSeen = 1;\n  return pPKey2->default_rc;\n}\nint sqlite3VdbeRecordCompare(\n  int nKey1, const void *pKey1,   /* Left key */\n  UnpackedRecord *pPKey2          /* Right key */\n){\n  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 0);\n}\n\n\n/*\n** This function is an optimized version of sqlite3VdbeRecordCompare() \n** that (a) the first field of pPKey2 is an integer, and (b) the \n** size-of-header varint at the start of (pKey1/nKey1) fits in a single\n** byte (i.e. is less than 128).\n**\n** To avoid concerns about buffer overreads, this routine is only used\n** on schemas where the maximum valid header size is 63 bytes or less.\n*/\nstatic int vdbeRecordCompareInt(\n  int nKey1, const void *pKey1, /* Left key */\n  UnpackedRecord *pPKey2        /* Right key */\n){\n  const u8 *aKey = &((const u8*)pKey1)[*(const u8*)pKey1 & 0x3F];\n  int serial_type = ((const u8*)pKey1)[1];\n  int res;\n  u32 y;\n  u64 x;\n  i64 v;\n  i64 lhs;\n\n  vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);\n  assert( (*(u8*)pKey1)<=0x3F || CORRUPT_DB );\n  switch( serial_type ){\n    case 1: { /* 1-byte signed integer */\n      lhs = ONE_BYTE_INT(aKey);\n      testcase( lhs<0 );\n      break;\n    }\n    case 2: { /* 2-byte signed integer */\n      lhs = TWO_BYTE_INT(aKey);\n      testcase( lhs<0 );\n      break;\n    }\n    case 3: { /* 3-byte signed integer */\n      lhs = THREE_BYTE_INT(aKey);\n      testcase( lhs<0 );\n      break;\n    }\n    case 4: { /* 4-byte signed integer */\n      y = FOUR_BYTE_UINT(aKey);\n      lhs = (i64)*(int*)&y;\n      testcase( lhs<0 );\n      break;\n    }\n    case 5: { /* 6-byte signed integer */\n      lhs = FOUR_BYTE_UINT(aKey+2) + (((i64)1)<<32)*TWO_BYTE_INT(aKey);\n      testcase( lhs<0 );\n      break;\n    }\n    case 6: { /* 8-byte signed integer */\n      x = FOUR_BYTE_UINT(aKey);\n      x = (x<<32) | FOUR_BYTE_UINT(aKey+4);\n      lhs = *(i64*)&x;\n      testcase( lhs<0 );\n      break;\n    }\n    case 8: \n      lhs = 0;\n      break;\n    case 9:\n      lhs = 1;\n      break;\n\n    /* This case could be removed without changing the results of running\n    ** this code. Including it causes gcc to generate a faster switch \n    ** statement (since the range of switch targets now starts at zero and\n    ** is contiguous) but does not cause any duplicate code to be generated\n    ** (as gcc is clever enough to combine the two like cases). Other \n    ** compilers might be similar.  */ \n    case 0: case 7:\n      return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);\n\n    default:\n      return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);\n  }\n\n  v = pPKey2->aMem[0].u.i;\n  if( v>lhs ){\n    res = pPKey2->r1;\n  }else if( v<lhs ){\n    res = pPKey2->r2;\n  }else if( pPKey2->nField>1 ){\n    /* The first fields of the two keys are equal. Compare the trailing \n    ** fields.  */\n    res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);\n  }else{\n    /* The first fields of the two keys are equal and there are no trailing\n    ** fields. Return pPKey2->default_rc in this case. */\n    res = pPKey2->default_rc;\n    pPKey2->eqSeen = 1;\n  }\n\n  assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res) );\n  return res;\n}\n\n/*\n** This function is an optimized version of sqlite3VdbeRecordCompare() \n** that (a) the first field of pPKey2 is a string, that (b) the first field\n** uses the collation sequence BINARY and (c) that the size-of-header varint \n** at the start of (pKey1/nKey1) fits in a single byte.\n*/\nstatic int vdbeRecordCompareString(\n  int nKey1, const void *pKey1, /* Left key */\n  UnpackedRecord *pPKey2        /* Right key */\n){\n  const u8 *aKey1 = (const u8*)pKey1;\n  int serial_type;\n  int res;\n\n  assert( pPKey2->aMem[0].flags & MEM_Str );\n  vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);\n  getVarint32(&aKey1[1], serial_type);\n  if( serial_type<12 ){\n    res = pPKey2->r1;      /* (pKey1/nKey1) is a number or a null */\n  }else if( !(serial_type & 0x01) ){ \n    res = pPKey2->r2;      /* (pKey1/nKey1) is a blob */\n  }else{\n    int nCmp;\n    int nStr;\n    int szHdr = aKey1[0];\n\n    nStr = (serial_type-12) / 2;\n    if( (szHdr + nStr) > nKey1 ){\n      pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;\n      return 0;    /* Corruption */\n    }\n    nCmp = MIN( pPKey2->aMem[0].n, nStr );\n    res = memcmp(&aKey1[szHdr], pPKey2->aMem[0].z, nCmp);\n\n    if( res>0 ){\n      res = pPKey2->r2;\n    }else if( res<0 ){\n      res = pPKey2->r1;\n    }else{\n      res = nStr - pPKey2->aMem[0].n;\n      if( res==0 ){\n        if( pPKey2->nField>1 ){\n          res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);\n        }else{\n          res = pPKey2->default_rc;\n          pPKey2->eqSeen = 1;\n        }\n      }else if( res>0 ){\n        res = pPKey2->r2;\n      }else{\n        res = pPKey2->r1;\n      }\n    }\n  }\n\n  assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res)\n       || CORRUPT_DB\n       || pPKey2->pKeyInfo->db->mallocFailed\n  );\n  return res;\n}\n\n/*\n** Return a pointer to an sqlite3VdbeRecordCompare() compatible function\n** suitable for comparing serialized records to the unpacked record passed\n** as the only argument.\n*/\nRecordCompare sqlite3VdbeFindCompare(UnpackedRecord *p){\n  /* varintRecordCompareInt() and varintRecordCompareString() both assume\n  ** that the size-of-header varint that occurs at the start of each record\n  ** fits in a single byte (i.e. is 127 or less). varintRecordCompareInt()\n  ** also assumes that it is safe to overread a buffer by at least the \n  ** maximum possible legal header size plus 8 bytes. Because there is\n  ** guaranteed to be at least 74 (but not 136) bytes of padding following each\n  ** buffer passed to varintRecordCompareInt() this makes it convenient to\n  ** limit the size of the header to 64 bytes in cases where the first field\n  ** is an integer.\n  **\n  ** The easiest way to enforce this limit is to consider only records with\n  ** 13 fields or less. If the first field is an integer, the maximum legal\n  ** header size is (12*5 + 1 + 1) bytes.  */\n  if( p->pKeyInfo->nAllField<=13 ){\n    int flags = p->aMem[0].flags;\n    if( p->pKeyInfo->aSortFlags[0] ){\n      if( p->pKeyInfo->aSortFlags[0] & KEYINFO_ORDER_BIGNULL ){\n        return sqlite3VdbeRecordCompare;\n      }\n      p->r1 = 1;\n      p->r2 = -1;\n    }else{\n      p->r1 = -1;\n      p->r2 = 1;\n    }\n    if( (flags & MEM_Int) ){\n      return vdbeRecordCompareInt;\n    }\n    testcase( flags & MEM_Real );\n    testcase( flags & MEM_Null );\n    testcase( flags & MEM_Blob );\n    if( (flags & (MEM_Real|MEM_IntReal|MEM_Null|MEM_Blob))==0\n     && p->pKeyInfo->aColl[0]==0\n    ){\n      assert( flags & MEM_Str );\n      return vdbeRecordCompareString;\n    }\n  }\n\n  return sqlite3VdbeRecordCompare;\n}\n\n/*\n** pCur points at an index entry created using the OP_MakeRecord opcode.\n** Read the rowid (the last field in the record) and store it in *rowid.\n** Return SQLITE_OK if everything works, or an error code otherwise.\n**\n** pCur might be pointing to text obtained from a corrupt database file.\n** So the content cannot be trusted.  Do appropriate checks on the content.\n*/\nint sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid){\n  i64 nCellKey = 0;\n  int rc;\n  u32 szHdr;        /* Size of the header */\n  u32 typeRowid;    /* Serial type of the rowid */\n  u32 lenRowid;     /* Size of the rowid */\n  Mem m, v;\n\n  /* Get the size of the index entry.  Only indices entries of less\n  ** than 2GiB are support - anything large must be database corruption.\n  ** Any corruption is detected in sqlite3BtreeParseCellPtr(), though, so\n  ** this code can safely assume that nCellKey is 32-bits  \n  */\n  assert( sqlite3BtreeCursorIsValid(pCur) );\n  nCellKey = sqlite3BtreePayloadSize(pCur);\n  assert( (nCellKey & SQLITE_MAX_U32)==(u64)nCellKey );\n\n  /* Read in the complete content of the index entry */\n  sqlite3VdbeMemInit(&m, db, 0);\n  rc = sqlite3VdbeMemFromBtree(pCur, 0, (u32)nCellKey, &m);\n  if( rc ){\n    return rc;\n  }\n\n  /* The index entry must begin with a header size */\n  (void)getVarint32((u8*)m.z, szHdr);\n  testcase( szHdr==3 );\n  testcase( szHdr==m.n );\n  testcase( szHdr>0x7fffffff );\n  assert( m.n>=0 );\n  if( unlikely(szHdr<3 || szHdr>(unsigned)m.n) ){\n    goto idx_rowid_corruption;\n  }\n\n  /* The last field of the index should be an integer - the ROWID.\n  ** Verify that the last entry really is an integer. */\n  (void)getVarint32((u8*)&m.z[szHdr-1], typeRowid);\n  testcase( typeRowid==1 );\n  testcase( typeRowid==2 );\n  testcase( typeRowid==3 );\n  testcase( typeRowid==4 );\n  testcase( typeRowid==5 );\n  testcase( typeRowid==6 );\n  testcase( typeRowid==8 );\n  testcase( typeRowid==9 );\n  if( unlikely(typeRowid<1 || typeRowid>9 || typeRowid==7) ){\n    goto idx_rowid_corruption;\n  }\n  lenRowid = sqlite3SmallTypeSizes[typeRowid];\n  testcase( (u32)m.n==szHdr+lenRowid );\n  if( unlikely((u32)m.n<szHdr+lenRowid) ){\n    goto idx_rowid_corruption;\n  }\n\n  /* Fetch the integer off the end of the index record */\n  sqlite3VdbeSerialGet((u8*)&m.z[m.n-lenRowid], typeRowid, &v);\n  *rowid = v.u.i;\n  sqlite3VdbeMemRelease(&m);\n  return SQLITE_OK;\n\n  /* Jump here if database corruption is detected after m has been\n  ** allocated.  Free the m object and return SQLITE_CORRUPT. */\nidx_rowid_corruption:\n  testcase( m.szMalloc!=0 );\n  sqlite3VdbeMemRelease(&m);\n  return SQLITE_CORRUPT_BKPT;\n}\n\n/*\n** Compare the key of the index entry that cursor pC is pointing to against\n** the key string in pUnpacked.  Write into *pRes a number\n** that is negative, zero, or positive if pC is less than, equal to,\n** or greater than pUnpacked.  Return SQLITE_OK on success.\n**\n** pUnpacked is either created without a rowid or is truncated so that it\n** omits the rowid at the end.  The rowid at the end of the index entry\n** is ignored as well.  Hence, this routine only compares the prefixes \n** of the keys prior to the final rowid, not the entire key.\n*/\nint sqlite3VdbeIdxKeyCompare(\n  sqlite3 *db,                     /* Database connection */\n  VdbeCursor *pC,                  /* The cursor to compare against */\n  UnpackedRecord *pUnpacked,       /* Unpacked version of key */\n  int *res                         /* Write the comparison result here */\n){\n  i64 nCellKey = 0;\n  int rc;\n  BtCursor *pCur;\n  Mem m;\n\n  assert( pC->eCurType==CURTYPE_BTREE );\n  pCur = pC->uc.pCursor;\n  assert( sqlite3BtreeCursorIsValid(pCur) );\n  nCellKey = sqlite3BtreePayloadSize(pCur);\n  /* nCellKey will always be between 0 and 0xffffffff because of the way\n  ** that btreeParseCellPtr() and sqlite3GetVarint32() are implemented */\n  if( nCellKey<=0 || nCellKey>0x7fffffff ){\n    *res = 0;\n    return SQLITE_CORRUPT_BKPT;\n  }\n  sqlite3VdbeMemInit(&m, db, 0);\n  rc = sqlite3VdbeMemFromBtree(pCur, 0, (u32)nCellKey, &m);\n  if( rc ){\n    return rc;\n  }\n  *res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, pUnpacked, 0);\n  sqlite3VdbeMemRelease(&m);\n  return SQLITE_OK;\n}\n\n/*\n** This routine sets the value to be returned by subsequent calls to\n** sqlite3_changes() on the database handle 'db'. \n*/\nvoid sqlite3VdbeSetChanges(sqlite3 *db, int nChange){\n  assert( sqlite3_mutex_held(db->mutex) );\n  db->nChange = nChange;\n  db->nTotalChange += nChange;\n}\n\n/*\n** Set a flag in the vdbe to update the change counter when it is finalised\n** or reset.\n*/\nvoid sqlite3VdbeCountChanges(Vdbe *v){\n  v->changeCntOn = 1;\n}\n\n/*\n** Mark every prepared statement associated with a database connection\n** as expired.\n**\n** An expired statement means that recompilation of the statement is\n** recommend.  Statements expire when things happen that make their\n** programs obsolete.  Removing user-defined functions or collating\n** sequences, or changing an authorization function are the types of\n** things that make prepared statements obsolete.\n**\n** If iCode is 1, then expiration is advisory.  The statement should\n** be reprepared before being restarted, but if it is already running\n** it is allowed to run to completion.\n**\n** Internally, this function just sets the Vdbe.expired flag on all\n** prepared statements.  The flag is set to 1 for an immediate expiration\n** and set to 2 for an advisory expiration.\n*/\nvoid sqlite3ExpirePreparedStatements(sqlite3 *db, int iCode){\n  Vdbe *p;\n  for(p = db->pVdbe; p; p=p->pNext){\n    p->expired = iCode+1;\n  }\n}\n\n/*\n** Return the database associated with the Vdbe.\n*/\nsqlite3 *sqlite3VdbeDb(Vdbe *v){\n  return v->db;\n}\n\n/*\n** Return the SQLITE_PREPARE flags for a Vdbe.\n*/\nu8 sqlite3VdbePrepareFlags(Vdbe *v){\n  return v->prepFlags;\n}\n\n/*\n** Return a pointer to an sqlite3_value structure containing the value bound\n** parameter iVar of VM v. Except, if the value is an SQL NULL, return \n** 0 instead. Unless it is NULL, apply affinity aff (one of the SQLITE_AFF_*\n** constants) to the value before returning it.\n**\n** The returned value must be freed by the caller using sqlite3ValueFree().\n*/\nsqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v, int iVar, u8 aff){\n  assert( iVar>0 );\n  if( v ){\n    Mem *pMem = &v->aVar[iVar-1];\n    assert( (v->db->flags & SQLITE_EnableQPSG)==0 );\n    if( 0==(pMem->flags & MEM_Null) ){\n      sqlite3_value *pRet = sqlite3ValueNew(v->db);\n      if( pRet ){\n        sqlite3VdbeMemCopy((Mem *)pRet, pMem);\n        sqlite3ValueApplyAffinity(pRet, aff, SQLITE_UTF8);\n      }\n      return pRet;\n    }\n  }\n  return 0;\n}\n\n/*\n** Configure SQL variable iVar so that binding a new value to it signals\n** to sqlite3_reoptimize() that re-preparing the statement may result\n** in a better query plan.\n*/\nvoid sqlite3VdbeSetVarmask(Vdbe *v, int iVar){\n  assert( iVar>0 );\n  assert( (v->db->flags & SQLITE_EnableQPSG)==0 );\n  if( iVar>=32 ){\n    v->expmask |= 0x80000000;\n  }else{\n    v->expmask |= ((u32)1 << (iVar-1));\n  }\n}\n\n/*\n** Cause a function to throw an error if it was call from OP_PureFunc\n** rather than OP_Function.\n**\n** OP_PureFunc means that the function must be deterministic, and should\n** throw an error if it is given inputs that would make it non-deterministic.\n** This routine is invoked by date/time functions that use non-deterministic\n** features such as 'now'.\n*/\nint sqlite3NotPureFunc(sqlite3_context *pCtx){\n  const VdbeOp *pOp;\n#ifdef SQLITE_ENABLE_STAT4\n  if( pCtx->pVdbe==0 ) return 1;\n#endif\n  pOp = pCtx->pVdbe->aOp + pCtx->iOp;\n  if( pOp->opcode==OP_PureFunc ){\n    const char *zContext;\n    char *zMsg;\n    if( pOp->p5 & NC_IsCheck ){\n      zContext = \"a CHECK constraint\";\n    }else if( pOp->p5 & NC_GenCol ){\n      zContext = \"a generated column\";\n    }else{\n      zContext = \"an index\";\n    }\n    zMsg = sqlite3_mprintf(\"non-deterministic use of %s() in %s\",\n                           pCtx->pFunc->zName, zContext);\n    sqlite3_result_error(pCtx, zMsg, -1);\n    sqlite3_free(zMsg);\n    return 0;\n  }\n  return 1;\n}\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/*\n** Transfer error message text from an sqlite3_vtab.zErrMsg (text stored\n** in memory obtained from sqlite3_malloc) into a Vdbe.zErrMsg (text stored\n** in memory obtained from sqlite3DbMalloc).\n*/\nvoid sqlite3VtabImportErrmsg(Vdbe *p, sqlite3_vtab *pVtab){\n  if( pVtab->zErrMsg ){\n    sqlite3 *db = p->db;\n    sqlite3DbFree(db, p->zErrMsg);\n    p->zErrMsg = sqlite3DbStrDup(db, pVtab->zErrMsg);\n    sqlite3_free(pVtab->zErrMsg);\n    pVtab->zErrMsg = 0;\n  }\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n\n/*\n** If the second argument is not NULL, release any allocations associated \n** with the memory cells in the p->aMem[] array. Also free the UnpackedRecord\n** structure itself, using sqlite3DbFree().\n**\n** This function is used to free UnpackedRecord structures allocated by\n** the vdbeUnpackRecord() function found in vdbeapi.c.\n*/\nstatic void vdbeFreeUnpacked(sqlite3 *db, int nField, UnpackedRecord *p){\n  if( p ){\n    int i;\n    for(i=0; i<nField; i++){\n      Mem *pMem = &p->aMem[i];\n      if( pMem->zMalloc ) sqlite3VdbeMemRelease(pMem);\n    }\n    sqlite3DbFreeNN(db, p);\n  }\n}\n#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */\n\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n/*\n** Invoke the pre-update hook. If this is an UPDATE or DELETE pre-update call,\n** then cursor passed as the second argument should point to the row about\n** to be update or deleted. If the application calls sqlite3_preupdate_old(),\n** the required value will be read from the row the cursor points to.\n*/\nvoid sqlite3VdbePreUpdateHook(\n  Vdbe *v,                        /* Vdbe pre-update hook is invoked by */\n  VdbeCursor *pCsr,               /* Cursor to grab old.* values from */\n  int op,                         /* SQLITE_INSERT, UPDATE or DELETE */\n  const char *zDb,                /* Database name */\n  Table *pTab,                    /* Modified table */\n  i64 iKey1,                      /* Initial key value */\n  int iReg                        /* Register for new.* record */\n){\n  sqlite3 *db = v->db;\n  i64 iKey2;\n  PreUpdate preupdate;\n  const char *zTbl = pTab->zName;\n  static const u8 fakeSortOrder = 0;\n\n  assert( db->pPreUpdate==0 );\n  memset(&preupdate, 0, sizeof(PreUpdate));\n  if( HasRowid(pTab)==0 ){\n    iKey1 = iKey2 = 0;\n    preupdate.pPk = sqlite3PrimaryKeyIndex(pTab);\n  }else{\n    if( op==SQLITE_UPDATE ){\n      iKey2 = v->aMem[iReg].u.i;\n    }else{\n      iKey2 = iKey1;\n    }\n  }\n\n  assert( pCsr->nField==pTab->nCol \n       || (pCsr->nField==pTab->nCol+1 && op==SQLITE_DELETE && iReg==-1)\n  );\n\n  preupdate.v = v;\n  preupdate.pCsr = pCsr;\n  preupdate.op = op;\n  preupdate.iNewReg = iReg;\n  preupdate.keyinfo.db = db;\n  preupdate.keyinfo.enc = ENC(db);\n  preupdate.keyinfo.nKeyField = pTab->nCol;\n  preupdate.keyinfo.aSortFlags = (u8*)&fakeSortOrder;\n  preupdate.iKey1 = iKey1;\n  preupdate.iKey2 = iKey2;\n  preupdate.pTab = pTab;\n\n  db->pPreUpdate = &preupdate;\n  db->xPreUpdateCallback(db->pPreUpdateArg, db, op, zDb, zTbl, iKey1, iKey2);\n  db->pPreUpdate = 0;\n  sqlite3DbFree(db, preupdate.aRecord);\n  vdbeFreeUnpacked(db, preupdate.keyinfo.nKeyField+1, preupdate.pUnpacked);\n  vdbeFreeUnpacked(db, preupdate.keyinfo.nKeyField+1, preupdate.pNewUnpacked);\n  if( preupdate.aNew ){\n    int i;\n    for(i=0; i<pCsr->nField; i++){\n      sqlite3VdbeMemRelease(&preupdate.aNew[i]);\n    }\n    sqlite3DbFreeNN(db, preupdate.aNew);\n  }\n}\n#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */\n", "/*\n** 2018 May 08\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n*/\n#include \"sqliteInt.h\"\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n\n/*\n** SELECT REWRITING\n**\n**   Any SELECT statement that contains one or more window functions in\n**   either the select list or ORDER BY clause (the only two places window\n**   functions may be used) is transformed by function sqlite3WindowRewrite()\n**   in order to support window function processing. For example, with the\n**   schema:\n**\n**     CREATE TABLE t1(a, b, c, d, e, f, g);\n**\n**   the statement:\n**\n**     SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM t1 ORDER BY e;\n**\n**   is transformed to:\n**\n**     SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM (\n**         SELECT a, e, c, d, b FROM t1 ORDER BY c, d\n**     ) ORDER BY e;\n**\n**   The flattening optimization is disabled when processing this transformed\n**   SELECT statement. This allows the implementation of the window function\n**   (in this case max()) to process rows sorted in order of (c, d), which\n**   makes things easier for obvious reasons. More generally:\n**\n**     * FROM, WHERE, GROUP BY and HAVING clauses are all moved to \n**       the sub-query.\n**\n**     * ORDER BY, LIMIT and OFFSET remain part of the parent query.\n**\n**     * Terminals from each of the expression trees that make up the \n**       select-list and ORDER BY expressions in the parent query are\n**       selected by the sub-query. For the purposes of the transformation,\n**       terminals are column references and aggregate functions.\n**\n**   If there is more than one window function in the SELECT that uses\n**   the same window declaration (the OVER bit), then a single scan may\n**   be used to process more than one window function. For example:\n**\n**     SELECT max(b) OVER (PARTITION BY c ORDER BY d), \n**            min(e) OVER (PARTITION BY c ORDER BY d) \n**     FROM t1;\n**\n**   is transformed in the same way as the example above. However:\n**\n**     SELECT max(b) OVER (PARTITION BY c ORDER BY d), \n**            min(e) OVER (PARTITION BY a ORDER BY b) \n**     FROM t1;\n**\n**   Must be transformed to:\n**\n**     SELECT max(b) OVER (PARTITION BY c ORDER BY d) FROM (\n**         SELECT e, min(e) OVER (PARTITION BY a ORDER BY b), c, d, b FROM\n**           SELECT a, e, c, d, b FROM t1 ORDER BY a, b\n**         ) ORDER BY c, d\n**     ) ORDER BY e;\n**\n**   so that both min() and max() may process rows in the order defined by\n**   their respective window declarations.\n**\n** INTERFACE WITH SELECT.C\n**\n**   When processing the rewritten SELECT statement, code in select.c calls\n**   sqlite3WhereBegin() to begin iterating through the results of the\n**   sub-query, which is always implemented as a co-routine. It then calls\n**   sqlite3WindowCodeStep() to process rows and finish the scan by calling\n**   sqlite3WhereEnd().\n**\n**   sqlite3WindowCodeStep() generates VM code so that, for each row returned\n**   by the sub-query a sub-routine (OP_Gosub) coded by select.c is invoked.\n**   When the sub-routine is invoked:\n**\n**     * The results of all window-functions for the row are stored\n**       in the associated Window.regResult registers.\n**\n**     * The required terminal values are stored in the current row of\n**       temp table Window.iEphCsr.\n**\n**   In some cases, depending on the window frame and the specific window\n**   functions invoked, sqlite3WindowCodeStep() caches each entire partition\n**   in a temp table before returning any rows. In other cases it does not.\n**   This detail is encapsulated within this file, the code generated by\n**   select.c is the same in either case.\n**\n** BUILT-IN WINDOW FUNCTIONS\n**\n**   This implementation features the following built-in window functions:\n**\n**     row_number()\n**     rank()\n**     dense_rank()\n**     percent_rank()\n**     cume_dist()\n**     ntile(N)\n**     lead(expr [, offset [, default]])\n**     lag(expr [, offset [, default]])\n**     first_value(expr)\n**     last_value(expr)\n**     nth_value(expr, N)\n**   \n**   These are the same built-in window functions supported by Postgres. \n**   Although the behaviour of aggregate window functions (functions that\n**   can be used as either aggregates or window funtions) allows them to\n**   be implemented using an API, built-in window functions are much more\n**   esoteric. Additionally, some window functions (e.g. nth_value()) \n**   may only be implemented by caching the entire partition in memory.\n**   As such, some built-in window functions use the same API as aggregate\n**   window functions and some are implemented directly using VDBE \n**   instructions. Additionally, for those functions that use the API, the\n**   window frame is sometimes modified before the SELECT statement is\n**   rewritten. For example, regardless of the specified window frame, the\n**   row_number() function always uses:\n**\n**     ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n**\n**   See sqlite3WindowUpdate() for details.\n**\n**   As well as some of the built-in window functions, aggregate window\n**   functions min() and max() are implemented using VDBE instructions if\n**   the start of the window frame is declared as anything other than \n**   UNBOUNDED PRECEDING.\n*/\n\n/*\n** Implementation of built-in window function row_number(). Assumes that the\n** window frame has been coerced to:\n**\n**   ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n*/\nstatic void row_numberStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ) (*p)++;\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n}\nstatic void row_numberValueFunc(sqlite3_context *pCtx){\n  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  sqlite3_result_int64(pCtx, (p ? *p : 0));\n}\n\n/*\n** Context object type used by rank(), dense_rank(), percent_rank() and\n** cume_dist().\n*/\nstruct CallCount {\n  i64 nValue;\n  i64 nStep;\n  i64 nTotal;\n};\n\n/*\n** Implementation of built-in window function dense_rank(). Assumes that\n** the window frame has been set to:\n**\n**   RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW \n*/\nstatic void dense_rankStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ) p->nStep = 1;\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n}\nstatic void dense_rankValueFunc(sqlite3_context *pCtx){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    if( p->nStep ){\n      p->nValue++;\n      p->nStep = 0;\n    }\n    sqlite3_result_int64(pCtx, p->nValue);\n  }\n}\n\n/*\n** Implementation of built-in window function nth_value(). This\n** implementation is used in \"slow mode\" only - when the EXCLUDE clause\n** is not set to the default value \"NO OTHERS\".\n*/\nstruct NthValueCtx {\n  i64 nStep;\n  sqlite3_value *pValue;\n};\nstatic void nth_valueStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct NthValueCtx *p;\n  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    i64 iVal;\n    switch( sqlite3_value_numeric_type(apArg[1]) ){\n      case SQLITE_INTEGER:\n        iVal = sqlite3_value_int64(apArg[1]);\n        break;\n      case SQLITE_FLOAT: {\n        double fVal = sqlite3_value_double(apArg[1]);\n        if( ((i64)fVal)!=fVal ) goto error_out;\n        iVal = (i64)fVal;\n        break;\n      }\n      default:\n        goto error_out;\n    }\n    if( iVal<=0 ) goto error_out;\n\n    p->nStep++;\n    if( iVal==p->nStep ){\n      p->pValue = sqlite3_value_dup(apArg[0]);\n      if( !p->pValue ){\n        sqlite3_result_error_nomem(pCtx);\n      }\n    }\n  }\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n  return;\n\n error_out:\n  sqlite3_result_error(\n      pCtx, \"second argument to nth_value must be a positive integer\", -1\n  );\n}\nstatic void nth_valueFinalizeFunc(sqlite3_context *pCtx){\n  struct NthValueCtx *p;\n  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, 0);\n  if( p && p->pValue ){\n    sqlite3_result_value(pCtx, p->pValue);\n    sqlite3_value_free(p->pValue);\n    p->pValue = 0;\n  }\n}\n#define nth_valueInvFunc noopStepFunc\n#define nth_valueValueFunc noopValueFunc\n\nstatic void first_valueStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct NthValueCtx *p;\n  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p && p->pValue==0 ){\n    p->pValue = sqlite3_value_dup(apArg[0]);\n    if( !p->pValue ){\n      sqlite3_result_error_nomem(pCtx);\n    }\n  }\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n}\nstatic void first_valueFinalizeFunc(sqlite3_context *pCtx){\n  struct NthValueCtx *p;\n  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p && p->pValue ){\n    sqlite3_result_value(pCtx, p->pValue);\n    sqlite3_value_free(p->pValue);\n    p->pValue = 0;\n  }\n}\n#define first_valueInvFunc noopStepFunc\n#define first_valueValueFunc noopValueFunc\n\n/*\n** Implementation of built-in window function rank(). Assumes that\n** the window frame has been set to:\n**\n**   RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW \n*/\nstatic void rankStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    p->nStep++;\n    if( p->nValue==0 ){\n      p->nValue = p->nStep;\n    }\n  }\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n}\nstatic void rankValueFunc(sqlite3_context *pCtx){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    sqlite3_result_int64(pCtx, p->nValue);\n    p->nValue = 0;\n  }\n}\n\n/*\n** Implementation of built-in window function percent_rank(). Assumes that\n** the window frame has been set to:\n**\n**   GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING\n*/\nstatic void percent_rankStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  UNUSED_PARAMETER(nArg); assert( nArg==0 );\n  UNUSED_PARAMETER(apArg);\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    p->nTotal++;\n  }\n}\nstatic void percent_rankInvFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  UNUSED_PARAMETER(nArg); assert( nArg==0 );\n  UNUSED_PARAMETER(apArg);\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  p->nStep++;\n}\nstatic void percent_rankValueFunc(sqlite3_context *pCtx){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    p->nValue = p->nStep;\n    if( p->nTotal>1 ){\n      double r = (double)p->nValue / (double)(p->nTotal-1);\n      sqlite3_result_double(pCtx, r);\n    }else{\n      sqlite3_result_double(pCtx, 0.0);\n    }\n  }\n}\n#define percent_rankFinalizeFunc percent_rankValueFunc\n\n/*\n** Implementation of built-in window function cume_dist(). Assumes that\n** the window frame has been set to:\n**\n**   GROUPS BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING\n*/\nstatic void cume_distStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  UNUSED_PARAMETER(nArg); assert( nArg==0 );\n  UNUSED_PARAMETER(apArg);\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    p->nTotal++;\n  }\n}\nstatic void cume_distInvFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  UNUSED_PARAMETER(nArg); assert( nArg==0 );\n  UNUSED_PARAMETER(apArg);\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  p->nStep++;\n}\nstatic void cume_distValueFunc(sqlite3_context *pCtx){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, 0);\n  if( p ){\n    double r = (double)(p->nStep) / (double)(p->nTotal);\n    sqlite3_result_double(pCtx, r);\n  }\n}\n#define cume_distFinalizeFunc cume_distValueFunc\n\n/*\n** Context object for ntile() window function.\n*/\nstruct NtileCtx {\n  i64 nTotal;                     /* Total rows in partition */\n  i64 nParam;                     /* Parameter passed to ntile(N) */\n  i64 iRow;                       /* Current row */\n};\n\n/*\n** Implementation of ntile(). This assumes that the window frame has\n** been coerced to:\n**\n**   ROWS CURRENT ROW AND UNBOUNDED FOLLOWING\n*/\nstatic void ntileStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct NtileCtx *p;\n  assert( nArg==1 ); UNUSED_PARAMETER(nArg);\n  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    if( p->nTotal==0 ){\n      p->nParam = sqlite3_value_int64(apArg[0]);\n      if( p->nParam<=0 ){\n        sqlite3_result_error(\n            pCtx, \"argument of ntile must be a positive integer\", -1\n        );\n      }\n    }\n    p->nTotal++;\n  }\n}\nstatic void ntileInvFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct NtileCtx *p;\n  assert( nArg==1 ); UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  p->iRow++;\n}\nstatic void ntileValueFunc(sqlite3_context *pCtx){\n  struct NtileCtx *p;\n  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p && p->nParam>0 ){\n    int nSize = (p->nTotal / p->nParam);\n    if( nSize==0 ){\n      sqlite3_result_int64(pCtx, p->iRow+1);\n    }else{\n      i64 nLarge = p->nTotal - p->nParam*nSize;\n      i64 iSmall = nLarge*(nSize+1);\n      i64 iRow = p->iRow;\n\n      assert( (nLarge*(nSize+1) + (p->nParam-nLarge)*nSize)==p->nTotal );\n\n      if( iRow<iSmall ){\n        sqlite3_result_int64(pCtx, 1 + iRow/(nSize+1));\n      }else{\n        sqlite3_result_int64(pCtx, 1 + nLarge + (iRow-iSmall)/nSize);\n      }\n    }\n  }\n}\n#define ntileFinalizeFunc ntileValueFunc\n\n/*\n** Context object for last_value() window function.\n*/\nstruct LastValueCtx {\n  sqlite3_value *pVal;\n  int nVal;\n};\n\n/*\n** Implementation of last_value().\n*/\nstatic void last_valueStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct LastValueCtx *p;\n  UNUSED_PARAMETER(nArg);\n  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ){\n    sqlite3_value_free(p->pVal);\n    p->pVal = sqlite3_value_dup(apArg[0]);\n    if( p->pVal==0 ){\n      sqlite3_result_error_nomem(pCtx);\n    }else{\n      p->nVal++;\n    }\n  }\n}\nstatic void last_valueInvFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct LastValueCtx *p;\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( ALWAYS(p) ){\n    p->nVal--;\n    if( p->nVal==0 ){\n      sqlite3_value_free(p->pVal);\n      p->pVal = 0;\n    }\n  }\n}\nstatic void last_valueValueFunc(sqlite3_context *pCtx){\n  struct LastValueCtx *p;\n  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, 0);\n  if( p && p->pVal ){\n    sqlite3_result_value(pCtx, p->pVal);\n  }\n}\nstatic void last_valueFinalizeFunc(sqlite3_context *pCtx){\n  struct LastValueCtx *p;\n  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p && p->pVal ){\n    sqlite3_result_value(pCtx, p->pVal);\n    sqlite3_value_free(p->pVal);\n    p->pVal = 0;\n  }\n}\n\n/*\n** Static names for the built-in window function names.  These static\n** names are used, rather than string literals, so that FuncDef objects\n** can be associated with a particular window function by direct\n** comparison of the zName pointer.  Example:\n**\n**       if( pFuncDef->zName==row_valueName ){ ... }\n*/\nstatic const char row_numberName[] =   \"row_number\";\nstatic const char dense_rankName[] =   \"dense_rank\";\nstatic const char rankName[] =         \"rank\";\nstatic const char percent_rankName[] = \"percent_rank\";\nstatic const char cume_distName[] =    \"cume_dist\";\nstatic const char ntileName[] =        \"ntile\";\nstatic const char last_valueName[] =   \"last_value\";\nstatic const char nth_valueName[] =    \"nth_value\";\nstatic const char first_valueName[] =  \"first_value\";\nstatic const char leadName[] =         \"lead\";\nstatic const char lagName[] =          \"lag\";\n\n/*\n** No-op implementations of xStep() and xFinalize().  Used as place-holders\n** for built-in window functions that never call those interfaces.\n**\n** The noopValueFunc() is called but is expected to do nothing.  The\n** noopStepFunc() is never called, and so it is marked with NO_TEST to\n** let the test coverage routine know not to expect this function to be\n** invoked.\n*/\nstatic void noopStepFunc(    /*NO_TEST*/\n  sqlite3_context *p,        /*NO_TEST*/\n  int n,                     /*NO_TEST*/\n  sqlite3_value **a          /*NO_TEST*/\n){                           /*NO_TEST*/\n  UNUSED_PARAMETER(p);       /*NO_TEST*/\n  UNUSED_PARAMETER(n);       /*NO_TEST*/\n  UNUSED_PARAMETER(a);       /*NO_TEST*/\n  assert(0);                 /*NO_TEST*/\n}                            /*NO_TEST*/\nstatic void noopValueFunc(sqlite3_context *p){ UNUSED_PARAMETER(p); /*no-op*/ }\n\n/* Window functions that use all window interfaces: xStep, xFinal,\n** xValue, and xInverse */\n#define WINDOWFUNCALL(name,nArg,extra) {                                   \\\n  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \\\n  name ## StepFunc, name ## FinalizeFunc, name ## ValueFunc,               \\\n  name ## InvFunc, name ## Name, {0}                                       \\\n}\n\n/* Window functions that are implemented using bytecode and thus have\n** no-op routines for their methods */\n#define WINDOWFUNCNOOP(name,nArg,extra) {                                  \\\n  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \\\n  noopStepFunc, noopValueFunc, noopValueFunc,                              \\\n  noopStepFunc, name ## Name, {0}                                          \\\n}\n\n/* Window functions that use all window interfaces: xStep, the\n** same routine for xFinalize and xValue and which never call\n** xInverse. */\n#define WINDOWFUNCX(name,nArg,extra) {                                     \\\n  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \\\n  name ## StepFunc, name ## ValueFunc, name ## ValueFunc,                  \\\n  noopStepFunc, name ## Name, {0}                                          \\\n}\n\n\n/*\n** Register those built-in window functions that are not also aggregates.\n*/\nvoid sqlite3WindowFunctions(void){\n  static FuncDef aWindowFuncs[] = {\n    WINDOWFUNCX(row_number, 0, 0),\n    WINDOWFUNCX(dense_rank, 0, 0),\n    WINDOWFUNCX(rank, 0, 0),\n    WINDOWFUNCALL(percent_rank, 0, 0),\n    WINDOWFUNCALL(cume_dist, 0, 0),\n    WINDOWFUNCALL(ntile, 1, 0),\n    WINDOWFUNCALL(last_value, 1, 0),\n    WINDOWFUNCALL(nth_value, 2, 0),\n    WINDOWFUNCALL(first_value, 1, 0),\n    WINDOWFUNCNOOP(lead, 1, 0),\n    WINDOWFUNCNOOP(lead, 2, 0),\n    WINDOWFUNCNOOP(lead, 3, 0),\n    WINDOWFUNCNOOP(lag, 1, 0),\n    WINDOWFUNCNOOP(lag, 2, 0),\n    WINDOWFUNCNOOP(lag, 3, 0),\n  };\n  sqlite3InsertBuiltinFuncs(aWindowFuncs, ArraySize(aWindowFuncs));\n}\n\nstatic Window *windowFind(Parse *pParse, Window *pList, const char *zName){\n  Window *p;\n  for(p=pList; p; p=p->pNextWin){\n    if( sqlite3StrICmp(p->zName, zName)==0 ) break;\n  }\n  if( p==0 ){\n    sqlite3ErrorMsg(pParse, \"no such window: %s\", zName);\n  }\n  return p;\n}\n\n/*\n** This function is called immediately after resolving the function name\n** for a window function within a SELECT statement. Argument pList is a\n** linked list of WINDOW definitions for the current SELECT statement.\n** Argument pFunc is the function definition just resolved and pWin\n** is the Window object representing the associated OVER clause. This\n** function updates the contents of pWin as follows:\n**\n**   * If the OVER clause refered to a named window (as in \"max(x) OVER win\"),\n**     search list pList for a matching WINDOW definition, and update pWin\n**     accordingly. If no such WINDOW clause can be found, leave an error\n**     in pParse.\n**\n**   * If the function is a built-in window function that requires the\n**     window to be coerced (see \"BUILT-IN WINDOW FUNCTIONS\" at the top\n**     of this file), pWin is updated here.\n*/\nvoid sqlite3WindowUpdate(\n  Parse *pParse, \n  Window *pList,                  /* List of named windows for this SELECT */\n  Window *pWin,                   /* Window frame to update */\n  FuncDef *pFunc                  /* Window function definition */\n){\n  if( pWin->zName && pWin->eFrmType==0 ){\n    Window *p = windowFind(pParse, pList, pWin->zName);\n    if( p==0 ) return;\n    pWin->pPartition = sqlite3ExprListDup(pParse->db, p->pPartition, 0);\n    pWin->pOrderBy = sqlite3ExprListDup(pParse->db, p->pOrderBy, 0);\n    pWin->pStart = sqlite3ExprDup(pParse->db, p->pStart, 0);\n    pWin->pEnd = sqlite3ExprDup(pParse->db, p->pEnd, 0);\n    pWin->eStart = p->eStart;\n    pWin->eEnd = p->eEnd;\n    pWin->eFrmType = p->eFrmType;\n    pWin->eExclude = p->eExclude;\n  }else{\n    sqlite3WindowChain(pParse, pWin, pList);\n  }\n  if( (pWin->eFrmType==TK_RANGE)\n   && (pWin->pStart || pWin->pEnd) \n   && (pWin->pOrderBy==0 || pWin->pOrderBy->nExpr!=1)\n  ){\n    sqlite3ErrorMsg(pParse, \n      \"RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression\"\n    );\n  }else\n  if( pFunc->funcFlags & SQLITE_FUNC_WINDOW ){\n    sqlite3 *db = pParse->db;\n    if( pWin->pFilter ){\n      sqlite3ErrorMsg(pParse, \n          \"FILTER clause may only be used with aggregate window functions\"\n      );\n    }else{\n      struct WindowUpdate {\n        const char *zFunc;\n        int eFrmType;\n        int eStart;\n        int eEnd;\n      } aUp[] = {\n        { row_numberName,   TK_ROWS,   TK_UNBOUNDED, TK_CURRENT }, \n        { dense_rankName,   TK_RANGE,  TK_UNBOUNDED, TK_CURRENT }, \n        { rankName,         TK_RANGE,  TK_UNBOUNDED, TK_CURRENT }, \n        { percent_rankName, TK_GROUPS, TK_CURRENT,   TK_UNBOUNDED }, \n        { cume_distName,    TK_GROUPS, TK_FOLLOWING, TK_UNBOUNDED }, \n        { ntileName,        TK_ROWS,   TK_CURRENT,   TK_UNBOUNDED }, \n        { leadName,         TK_ROWS,   TK_UNBOUNDED, TK_UNBOUNDED }, \n        { lagName,          TK_ROWS,   TK_UNBOUNDED, TK_CURRENT }, \n      };\n      int i;\n      for(i=0; i<ArraySize(aUp); i++){\n        if( pFunc->zName==aUp[i].zFunc ){\n          sqlite3ExprDelete(db, pWin->pStart);\n          sqlite3ExprDelete(db, pWin->pEnd);\n          pWin->pEnd = pWin->pStart = 0;\n          pWin->eFrmType = aUp[i].eFrmType;\n          pWin->eStart = aUp[i].eStart;\n          pWin->eEnd = aUp[i].eEnd;\n          pWin->eExclude = 0;\n          if( pWin->eStart==TK_FOLLOWING ){\n            pWin->pStart = sqlite3Expr(db, TK_INTEGER, \"1\");\n          }\n          break;\n        }\n      }\n    }\n  }\n  pWin->pFunc = pFunc;\n}\n\n/*\n** Context object passed through sqlite3WalkExprList() to\n** selectWindowRewriteExprCb() by selectWindowRewriteEList().\n*/\ntypedef struct WindowRewrite WindowRewrite;\nstruct WindowRewrite {\n  Window *pWin;\n  SrcList *pSrc;\n  ExprList *pSub;\n  Table *pTab;\n  Select *pSubSelect;             /* Current sub-select, if any */\n};\n\n/*\n** Callback function used by selectWindowRewriteEList(). If necessary,\n** this function appends to the output expression-list and updates \n** expression (*ppExpr) in place.\n*/\nstatic int selectWindowRewriteExprCb(Walker *pWalker, Expr *pExpr){\n  struct WindowRewrite *p = pWalker->u.pRewrite;\n  Parse *pParse = pWalker->pParse;\n  assert( p!=0 );\n  assert( p->pWin!=0 );\n\n  /* If this function is being called from within a scalar sub-select\n  ** that used by the SELECT statement being processed, only process\n  ** TK_COLUMN expressions that refer to it (the outer SELECT). Do\n  ** not process aggregates or window functions at all, as they belong\n  ** to the scalar sub-select.  */\n  if( p->pSubSelect ){\n    if( pExpr->op!=TK_COLUMN ){\n      return WRC_Continue;\n    }else{\n      int nSrc = p->pSrc->nSrc;\n      int i;\n      for(i=0; i<nSrc; i++){\n        if( pExpr->iTable==p->pSrc->a[i].iCursor ) break;\n      }\n      if( i==nSrc ) return WRC_Continue;\n    }\n  }\n\n  switch( pExpr->op ){\n\n    case TK_FUNCTION:\n      if( !ExprHasProperty(pExpr, EP_WinFunc) ){\n        break;\n      }else{\n        Window *pWin;\n        for(pWin=p->pWin; pWin; pWin=pWin->pNextWin){\n          if( pExpr->y.pWin==pWin ){\n            assert( pWin->pOwner==pExpr );\n            return WRC_Prune;\n          }\n        }\n      }\n      /* Fall through.  */\n\n    case TK_AGG_FUNCTION:\n    case TK_COLUMN: {\n      int iCol = -1;\n      if( p->pSub ){\n        int i;\n        for(i=0; i<p->pSub->nExpr; i++){\n          if( 0==sqlite3ExprCompare(0, p->pSub->a[i].pExpr, pExpr, -1) ){\n            iCol = i;\n            break;\n          }\n        }\n      }\n      if( iCol<0 ){\n        Expr *pDup = sqlite3ExprDup(pParse->db, pExpr, 0);\n        p->pSub = sqlite3ExprListAppend(pParse, p->pSub, pDup);\n      }\n      if( p->pSub ){\n        assert( ExprHasProperty(pExpr, EP_Static)==0 );\n        ExprSetProperty(pExpr, EP_Static);\n        sqlite3ExprDelete(pParse->db, pExpr);\n        ExprClearProperty(pExpr, EP_Static);\n        memset(pExpr, 0, sizeof(Expr));\n\n        pExpr->op = TK_COLUMN;\n        pExpr->iColumn = (iCol<0 ? p->pSub->nExpr-1: iCol);\n        pExpr->iTable = p->pWin->iEphCsr;\n        pExpr->y.pTab = p->pTab;\n      }\n      if( pParse->db->mallocFailed ) return WRC_Abort;\n      break;\n    }\n\n    default: /* no-op */\n      break;\n  }\n\n  return WRC_Continue;\n}\nstatic int selectWindowRewriteSelectCb(Walker *pWalker, Select *pSelect){\n  struct WindowRewrite *p = pWalker->u.pRewrite;\n  Select *pSave = p->pSubSelect;\n  if( pSave==pSelect ){\n    return WRC_Continue;\n  }else{\n    p->pSubSelect = pSelect;\n    sqlite3WalkSelect(pWalker, pSelect);\n    p->pSubSelect = pSave;\n  }\n  return WRC_Prune;\n}\n\n\n/*\n** Iterate through each expression in expression-list pEList. For each:\n**\n**   * TK_COLUMN,\n**   * aggregate function, or\n**   * window function with a Window object that is not a member of the \n**     Window list passed as the second argument (pWin).\n**\n** Append the node to output expression-list (*ppSub). And replace it\n** with a TK_COLUMN that reads the (N-1)th element of table \n** pWin->iEphCsr, where N is the number of elements in (*ppSub) after\n** appending the new one.\n*/\nstatic void selectWindowRewriteEList(\n  Parse *pParse, \n  Window *pWin,\n  SrcList *pSrc,\n  ExprList *pEList,               /* Rewrite expressions in this list */\n  Table *pTab,\n  ExprList **ppSub                /* IN/OUT: Sub-select expression-list */\n){\n  Walker sWalker;\n  WindowRewrite sRewrite;\n\n  assert( pWin!=0 );\n  memset(&sWalker, 0, sizeof(Walker));\n  memset(&sRewrite, 0, sizeof(WindowRewrite));\n\n  sRewrite.pSub = *ppSub;\n  sRewrite.pWin = pWin;\n  sRewrite.pSrc = pSrc;\n  sRewrite.pTab = pTab;\n\n  sWalker.pParse = pParse;\n  sWalker.xExprCallback = selectWindowRewriteExprCb;\n  sWalker.xSelectCallback = selectWindowRewriteSelectCb;\n  sWalker.u.pRewrite = &sRewrite;\n\n  (void)sqlite3WalkExprList(&sWalker, pEList);\n\n  *ppSub = sRewrite.pSub;\n}\n\n/*\n** Append a copy of each expression in expression-list pAppend to\n** expression list pList. Return a pointer to the result list.\n*/\nstatic ExprList *exprListAppendList(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to append. Might be NULL */\n  ExprList *pAppend,      /* List of values to append. Might be NULL */\n  int bIntToNull\n){\n  if( pAppend ){\n    int i;\n    int nInit = pList ? pList->nExpr : 0;\n    for(i=0; i<pAppend->nExpr; i++){\n      Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);\n      assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );\n      if( bIntToNull && pDup && pDup->op==TK_INTEGER ){\n        pDup->op = TK_NULL;\n        pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);\n        pDup->u.zToken = 0;\n      }\n      pList = sqlite3ExprListAppend(pParse, pList, pDup);\n      if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;\n    }\n  }\n  return pList;\n}\n\n/*\n** If the SELECT statement passed as the second argument does not invoke\n** any SQL window functions, this function is a no-op. Otherwise, it \n** rewrites the SELECT statement so that window function xStep functions\n** are invoked in the correct order as described under \"SELECT REWRITING\"\n** at the top of this file.\n*/\nint sqlite3WindowRewrite(Parse *pParse, Select *p){\n  int rc = SQLITE_OK;\n  if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    sqlite3 *db = pParse->db;\n    Select *pSub = 0;             /* The subquery */\n    SrcList *pSrc = p->pSrc;\n    Expr *pWhere = p->pWhere;\n    ExprList *pGroupBy = p->pGroupBy;\n    Expr *pHaving = p->pHaving;\n    ExprList *pSort = 0;\n\n    ExprList *pSublist = 0;       /* Expression list for sub-query */\n    Window *pMWin = p->pWin;      /* Master window object */\n    Window *pWin;                 /* Window object iterator */\n    Table *pTab;\n\n    pTab = sqlite3DbMallocZero(db, sizeof(Table));\n    if( pTab==0 ){\n      return sqlite3ErrorToParser(db, SQLITE_NOMEM);\n    }\n\n    p->pSrc = 0;\n    p->pWhere = 0;\n    p->pGroupBy = 0;\n    p->pHaving = 0;\n    p->selFlags &= ~SF_Aggregate;\n    p->selFlags |= SF_WinRewrite;\n\n    /* Create the ORDER BY clause for the sub-select. This is the concatenation\n    ** of the window PARTITION and ORDER BY clauses. Then, if this makes it\n    ** redundant, remove the ORDER BY from the parent SELECT.  */\n    pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);\n    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);\n    if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){\n      int nSave = pSort->nExpr;\n      pSort->nExpr = p->pOrderBy->nExpr;\n      if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        p->pOrderBy = 0;\n      }\n      pSort->nExpr = nSave;\n    }\n\n    /* Assign a cursor number for the ephemeral table used to buffer rows.\n    ** The OpenEphemeral instruction is coded later, after it is known how\n    ** many columns the table will have.  */\n    pMWin->iEphCsr = pParse->nTab++;\n    pParse->nTab += 3;\n\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);\n    pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);\n\n    /* Append the PARTITION BY and ORDER BY expressions to the to the \n    ** sub-select expression list. They are required to figure out where \n    ** boundaries for partitions and sets of peer rows lie.  */\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);\n\n    /* Append the arguments passed to each window function to the\n    ** sub-select expression list. Also allocate two registers for each\n    ** window function - one for the accumulator, another for interim\n    ** results.  */\n    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n      ExprList *pArgs = pWin->pOwner->x.pList;\n      if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){\n        selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pWin->bExprArgs = 1;\n      }else{\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);\n      }\n      if( pWin->pFilter ){\n        Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);\n        pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);\n      }\n      pWin->regAccum = ++pParse->nMem;\n      pWin->regResult = ++pParse->nMem;\n      sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n    }\n\n    /* If there is no ORDER BY or PARTITION BY clause, and the window\n    ** function accepts zero arguments, and there are no other columns\n    ** selected (e.g. \"SELECT row_number() OVER () FROM t1\"), it is possible\n    ** that pSublist is still NULL here. Add a constant expression here to \n    ** keep everything legal in this case. \n    */\n    if( pSublist==0 ){\n      pSublist = sqlite3ExprListAppend(pParse, 0, \n        sqlite3Expr(db, TK_INTEGER, \"0\")\n      );\n    }\n\n    pSub = sqlite3SelectNew(\n        pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0\n    );\n    p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n    if( p->pSrc ){\n      Table *pTab2;\n      p->pSrc->a[0].pSelect = pSub;\n      sqlite3SrcListAssignCursors(pParse, p->pSrc);\n      pSub->selFlags |= SF_Expanded;\n      pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);\n      if( pTab2==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        memcpy(pTab, pTab2, sizeof(Table));\n        pTab->tabFlags |= TF_Ephemeral;\n        p->pSrc->a[0].pTab = pTab;\n        pTab = pTab2;\n      }\n      sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);\n    }else{\n      sqlite3SelectDelete(db, pSub);\n    }\n    if( db->mallocFailed ) rc = SQLITE_NOMEM;\n    sqlite3DbFree(db, pTab);\n  }\n\n  if( rc && pParse->nErr==0 ){\n    assert( pParse->db->mallocFailed );\n    return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);\n  }\n  return rc;\n}\n\n/*\n** Unlink the Window object from the Select to which it is attached,\n** if it is attached.\n*/\nvoid sqlite3WindowUnlinkFromSelect(Window *p){\n  if( p->ppThis ){\n    *p->ppThis = p->pNextWin;\n    if( p->pNextWin ) p->pNextWin->ppThis = p->ppThis;\n    p->ppThis = 0;\n  }\n}\n\n/*\n** Free the Window object passed as the second argument.\n*/\nvoid sqlite3WindowDelete(sqlite3 *db, Window *p){\n  if( p ){\n    sqlite3WindowUnlinkFromSelect(p);\n    sqlite3ExprDelete(db, p->pFilter);\n    sqlite3ExprListDelete(db, p->pPartition);\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    sqlite3ExprDelete(db, p->pEnd);\n    sqlite3ExprDelete(db, p->pStart);\n    sqlite3DbFree(db, p->zName);\n    sqlite3DbFree(db, p->zBase);\n    sqlite3DbFree(db, p);\n  }\n}\n\n/*\n** Free the linked list of Window objects starting at the second argument.\n*/\nvoid sqlite3WindowListDelete(sqlite3 *db, Window *p){\n  while( p ){\n    Window *pNext = p->pNextWin;\n    sqlite3WindowDelete(db, p);\n    p = pNext;\n  }\n}\n\n/*\n** The argument expression is an PRECEDING or FOLLOWING offset.  The\n** value should be a non-negative integer.  If the value is not a\n** constant, change it to NULL.  The fact that it is then a non-negative\n** integer will be caught later.  But it is important not to leave\n** variable values in the expression tree.\n*/\nstatic Expr *sqlite3WindowOffsetExpr(Parse *pParse, Expr *pExpr){\n  if( 0==sqlite3ExprIsConstant(pExpr) ){\n    if( IN_RENAME_OBJECT ) sqlite3RenameExprUnmap(pParse, pExpr);\n    sqlite3ExprDelete(pParse->db, pExpr);\n    pExpr = sqlite3ExprAlloc(pParse->db, TK_NULL, 0, 0);\n  }\n  return pExpr;\n}\n\n/*\n** Allocate and return a new Window object describing a Window Definition.\n*/\nWindow *sqlite3WindowAlloc(\n  Parse *pParse,    /* Parsing context */\n  int eType,        /* Frame type. TK_RANGE, TK_ROWS, TK_GROUPS, or 0 */\n  int eStart,       /* Start type: CURRENT, PRECEDING, FOLLOWING, UNBOUNDED */\n  Expr *pStart,     /* Start window size if TK_PRECEDING or FOLLOWING */\n  int eEnd,         /* End type: CURRENT, FOLLOWING, TK_UNBOUNDED, PRECEDING */\n  Expr *pEnd,       /* End window size if TK_FOLLOWING or PRECEDING */\n  u8 eExclude       /* EXCLUDE clause */\n){\n  Window *pWin = 0;\n  int bImplicitFrame = 0;\n\n  /* Parser assures the following: */\n  assert( eType==0 || eType==TK_RANGE || eType==TK_ROWS || eType==TK_GROUPS );\n  assert( eStart==TK_CURRENT || eStart==TK_PRECEDING\n           || eStart==TK_UNBOUNDED || eStart==TK_FOLLOWING );\n  assert( eEnd==TK_CURRENT || eEnd==TK_FOLLOWING\n           || eEnd==TK_UNBOUNDED || eEnd==TK_PRECEDING );\n  assert( (eStart==TK_PRECEDING || eStart==TK_FOLLOWING)==(pStart!=0) );\n  assert( (eEnd==TK_FOLLOWING || eEnd==TK_PRECEDING)==(pEnd!=0) );\n\n  if( eType==0 ){\n    bImplicitFrame = 1;\n    eType = TK_RANGE;\n  }\n\n  /* Additionally, the\n  ** starting boundary type may not occur earlier in the following list than\n  ** the ending boundary type:\n  **\n  **   UNBOUNDED PRECEDING\n  **   <expr> PRECEDING\n  **   CURRENT ROW\n  **   <expr> FOLLOWING\n  **   UNBOUNDED FOLLOWING\n  **\n  ** The parser ensures that \"UNBOUNDED PRECEDING\" cannot be used as an ending\n  ** boundary, and than \"UNBOUNDED FOLLOWING\" cannot be used as a starting\n  ** frame boundary.\n  */\n  if( (eStart==TK_CURRENT && eEnd==TK_PRECEDING)\n   || (eStart==TK_FOLLOWING && (eEnd==TK_PRECEDING || eEnd==TK_CURRENT))\n  ){\n    sqlite3ErrorMsg(pParse, \"unsupported frame specification\");\n    goto windowAllocErr;\n  }\n\n  pWin = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n  if( pWin==0 ) goto windowAllocErr;\n  pWin->eFrmType = eType;\n  pWin->eStart = eStart;\n  pWin->eEnd = eEnd;\n  if( eExclude==0 && OptimizationDisabled(pParse->db, SQLITE_WindowFunc) ){\n    eExclude = TK_NO;\n  }\n  pWin->eExclude = eExclude;\n  pWin->bImplicitFrame = bImplicitFrame;\n  pWin->pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);\n  pWin->pStart = sqlite3WindowOffsetExpr(pParse, pStart);\n  return pWin;\n\nwindowAllocErr:\n  sqlite3ExprDelete(pParse->db, pEnd);\n  sqlite3ExprDelete(pParse->db, pStart);\n  return 0;\n}\n\n/*\n** Attach PARTITION and ORDER BY clauses pPartition and pOrderBy to window\n** pWin. Also, if parameter pBase is not NULL, set pWin->zBase to the\n** equivalent nul-terminated string.\n*/\nWindow *sqlite3WindowAssemble(\n  Parse *pParse, \n  Window *pWin, \n  ExprList *pPartition, \n  ExprList *pOrderBy, \n  Token *pBase\n){\n  if( pWin ){\n    pWin->pPartition = pPartition;\n    pWin->pOrderBy = pOrderBy;\n    if( pBase ){\n      pWin->zBase = sqlite3DbStrNDup(pParse->db, pBase->z, pBase->n);\n    }\n  }else{\n    sqlite3ExprListDelete(pParse->db, pPartition);\n    sqlite3ExprListDelete(pParse->db, pOrderBy);\n  }\n  return pWin;\n}\n\n/*\n** Window *pWin has just been created from a WINDOW clause. Tokne pBase\n** is the base window. Earlier windows from the same WINDOW clause are\n** stored in the linked list starting at pWin->pNextWin. This function\n** either updates *pWin according to the base specification, or else\n** leaves an error in pParse.\n*/\nvoid sqlite3WindowChain(Parse *pParse, Window *pWin, Window *pList){\n  if( pWin->zBase ){\n    sqlite3 *db = pParse->db;\n    Window *pExist = windowFind(pParse, pList, pWin->zBase);\n    if( pExist ){\n      const char *zErr = 0;\n      /* Check for errors */\n      if( pWin->pPartition ){\n        zErr = \"PARTITION clause\";\n      }else if( pExist->pOrderBy && pWin->pOrderBy ){\n        zErr = \"ORDER BY clause\";\n      }else if( pExist->bImplicitFrame==0 ){\n        zErr = \"frame specification\";\n      }\n      if( zErr ){\n        sqlite3ErrorMsg(pParse, \n            \"cannot override %s of window: %s\", zErr, pWin->zBase\n        );\n      }else{\n        pWin->pPartition = sqlite3ExprListDup(db, pExist->pPartition, 0);\n        if( pExist->pOrderBy ){\n          assert( pWin->pOrderBy==0 );\n          pWin->pOrderBy = sqlite3ExprListDup(db, pExist->pOrderBy, 0);\n        }\n        sqlite3DbFree(db, pWin->zBase);\n        pWin->zBase = 0;\n      }\n    }\n  }\n}\n\n/*\n** Attach window object pWin to expression p.\n*/\nvoid sqlite3WindowAttach(Parse *pParse, Expr *p, Window *pWin){\n  if( p ){\n    assert( p->op==TK_FUNCTION );\n    assert( pWin );\n    p->y.pWin = pWin;\n    ExprSetProperty(p, EP_WinFunc);\n    pWin->pOwner = p;\n    if( (p->flags & EP_Distinct) && pWin->eFrmType!=TK_FILTER ){\n      sqlite3ErrorMsg(pParse,\n          \"DISTINCT is not supported for window functions\"\n      );\n    }\n  }else{\n    sqlite3WindowDelete(pParse->db, pWin);\n  }\n}\n\n/*\n** Possibly link window pWin into the list at pSel->pWin (window functions\n** to be processed as part of SELECT statement pSel). The window is linked\n** in if either (a) there are no other windows already linked to this\n** SELECT, or (b) the windows already linked use a compatible window frame.\n*/\nvoid sqlite3WindowLink(Select *pSel, Window *pWin){\n  if( pSel!=0\n   && (0==pSel->pWin || 0==sqlite3WindowCompare(0, pSel->pWin, pWin, 0))\n  ){\n    pWin->pNextWin = pSel->pWin;\n    if( pSel->pWin ){\n      pSel->pWin->ppThis = &pWin->pNextWin;\n    }\n    pSel->pWin = pWin;\n    pWin->ppThis = &pSel->pWin;\n  }\n}\n\n/*\n** Return 0 if the two window objects are identical, or non-zero otherwise.\n** Identical window objects can be processed in a single scan.\n*/\nint sqlite3WindowCompare(Parse *pParse, Window *p1, Window *p2, int bFilter){\n  if( NEVER(p1==0) || NEVER(p2==0) ) return 1;\n  if( p1->eFrmType!=p2->eFrmType ) return 1;\n  if( p1->eStart!=p2->eStart ) return 1;\n  if( p1->eEnd!=p2->eEnd ) return 1;\n  if( p1->eExclude!=p2->eExclude ) return 1;\n  if( sqlite3ExprCompare(pParse, p1->pStart, p2->pStart, -1) ) return 1;\n  if( sqlite3ExprCompare(pParse, p1->pEnd, p2->pEnd, -1) ) return 1;\n  if( sqlite3ExprListCompare(p1->pPartition, p2->pPartition, -1) ) return 1;\n  if( sqlite3ExprListCompare(p1->pOrderBy, p2->pOrderBy, -1) ) return 1;\n  if( bFilter ){\n    if( sqlite3ExprCompare(pParse, p1->pFilter, p2->pFilter, -1) ) return 1;\n  }\n  return 0;\n}\n\n\n/*\n** This is called by code in select.c before it calls sqlite3WhereBegin()\n** to begin iterating through the sub-query results. It is used to allocate\n** and initialize registers and cursors used by sqlite3WindowCodeStep().\n*/\nvoid sqlite3WindowCodeInit(Parse *pParse, Window *pMWin){\n  Window *pWin;\n  Vdbe *v = sqlite3GetVdbe(pParse);\n\n  /* Allocate registers to use for PARTITION BY values, if any. Initialize\n  ** said registers to NULL.  */\n  if( pMWin->pPartition ){\n    int nExpr = pMWin->pPartition->nExpr;\n    pMWin->regPart = pParse->nMem+1;\n    pParse->nMem += nExpr;\n    sqlite3VdbeAddOp3(v, OP_Null, 0, pMWin->regPart, pMWin->regPart+nExpr-1);\n  }\n\n  pMWin->regOne = ++pParse->nMem;\n  sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regOne);\n\n  if( pMWin->eExclude ){\n    pMWin->regStartRowid = ++pParse->nMem;\n    pMWin->regEndRowid = ++pParse->nMem;\n    pMWin->csrApp = pParse->nTab++;\n    sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regStartRowid);\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, pMWin->regEndRowid);\n    sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->csrApp, pMWin->iEphCsr);\n    return;\n  }\n\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    FuncDef *p = pWin->pFunc;\n    if( (p->funcFlags & SQLITE_FUNC_MINMAX) && pWin->eStart!=TK_UNBOUNDED ){\n      /* The inline versions of min() and max() require a single ephemeral\n      ** table and 3 registers. The registers are used as follows:\n      **\n      **   regApp+0: slot to copy min()/max() argument to for MakeRecord\n      **   regApp+1: integer value used to ensure keys are unique\n      **   regApp+2: output of MakeRecord\n      */\n      ExprList *pList = pWin->pOwner->x.pList;\n      KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0);\n      pWin->csrApp = pParse->nTab++;\n      pWin->regApp = pParse->nMem+1;\n      pParse->nMem += 3;\n      if( pKeyInfo && pWin->pFunc->zName[1]=='i' ){\n        assert( pKeyInfo->aSortFlags[0]==0 );\n        pKeyInfo->aSortFlags[0] = KEYINFO_ORDER_DESC;\n      }\n      sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pWin->csrApp, 2);\n      sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);\n    }\n    else if( p->zName==nth_valueName || p->zName==first_valueName ){\n      /* Allocate two registers at pWin->regApp. These will be used to\n      ** store the start and end index of the current frame.  */\n      pWin->regApp = pParse->nMem+1;\n      pWin->csrApp = pParse->nTab++;\n      pParse->nMem += 2;\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pWin->csrApp, pMWin->iEphCsr);\n    }\n    else if( p->zName==leadName || p->zName==lagName ){\n      pWin->csrApp = pParse->nTab++;\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pWin->csrApp, pMWin->iEphCsr);\n    }\n  }\n}\n\n#define WINDOW_STARTING_INT  0\n#define WINDOW_ENDING_INT    1\n#define WINDOW_NTH_VALUE_INT 2\n#define WINDOW_STARTING_NUM  3\n#define WINDOW_ENDING_NUM    4\n\n/*\n** A \"PRECEDING <expr>\" (eCond==0) or \"FOLLOWING <expr>\" (eCond==1) or the\n** value of the second argument to nth_value() (eCond==2) has just been\n** evaluated and the result left in register reg. This function generates VM\n** code to check that the value is a non-negative integer and throws an\n** exception if it is not.\n*/\nstatic void windowCheckValue(Parse *pParse, int reg, int eCond){\n  static const char *azErr[] = {\n    \"frame starting offset must be a non-negative integer\",\n    \"frame ending offset must be a non-negative integer\",\n    \"second argument to nth_value must be a positive integer\",\n    \"frame starting offset must be a non-negative number\",\n    \"frame ending offset must be a non-negative number\",\n  };\n  static int aOp[] = { OP_Ge, OP_Ge, OP_Gt, OP_Ge, OP_Ge };\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  int regZero = sqlite3GetTempReg(pParse);\n  assert( eCond>=0 && eCond<ArraySize(azErr) );\n  sqlite3VdbeAddOp2(v, OP_Integer, 0, regZero);\n  if( eCond>=WINDOW_STARTING_NUM ){\n    int regString = sqlite3GetTempReg(pParse);\n    sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, \"\", P4_STATIC);\n    sqlite3VdbeAddOp3(v, OP_Ge, regString, sqlite3VdbeCurrentAddr(v)+2, reg);\n    sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC|SQLITE_JUMPIFNULL);\n    VdbeCoverage(v);\n    assert( eCond==3 || eCond==4 );\n    VdbeCoverageIf(v, eCond==3);\n    VdbeCoverageIf(v, eCond==4);\n  }else{\n    sqlite3VdbeAddOp2(v, OP_MustBeInt, reg, sqlite3VdbeCurrentAddr(v)+2);\n    VdbeCoverage(v);\n    assert( eCond==0 || eCond==1 || eCond==2 );\n    VdbeCoverageIf(v, eCond==0);\n    VdbeCoverageIf(v, eCond==1);\n    VdbeCoverageIf(v, eCond==2);\n  }\n  sqlite3VdbeAddOp3(v, aOp[eCond], regZero, sqlite3VdbeCurrentAddr(v)+2, reg);\n  VdbeCoverageNeverNullIf(v, eCond==0); /* NULL case captured by */\n  VdbeCoverageNeverNullIf(v, eCond==1); /*   the OP_MustBeInt */\n  VdbeCoverageNeverNullIf(v, eCond==2);\n  VdbeCoverageNeverNullIf(v, eCond==3); /* NULL case caught by */\n  VdbeCoverageNeverNullIf(v, eCond==4); /*   the OP_Ge */\n  sqlite3MayAbort(pParse);\n  sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_ERROR, OE_Abort);\n  sqlite3VdbeAppendP4(v, (void*)azErr[eCond], P4_STATIC);\n  sqlite3ReleaseTempReg(pParse, regZero);\n}\n\n/*\n** Return the number of arguments passed to the window-function associated\n** with the object passed as the only argument to this function.\n*/\nstatic int windowArgCount(Window *pWin){\n  ExprList *pList = pWin->pOwner->x.pList;\n  return (pList ? pList->nExpr : 0);\n}\n\ntypedef struct WindowCodeArg WindowCodeArg;\ntypedef struct WindowCsrAndReg WindowCsrAndReg;\n\n/*\n** See comments above struct WindowCodeArg.\n*/\nstruct WindowCsrAndReg {\n  int csr;                        /* Cursor number */\n  int reg;                        /* First in array of peer values */\n};\n\n/*\n** A single instance of this structure is allocated on the stack by \n** sqlite3WindowCodeStep() and a pointer to it passed to the various helper\n** routines. This is to reduce the number of arguments required by each\n** helper function.\n**\n** regArg:\n**   Each window function requires an accumulator register (just as an\n**   ordinary aggregate function does). This variable is set to the first\n**   in an array of accumulator registers - one for each window function\n**   in the WindowCodeArg.pMWin list.\n**\n** eDelete:\n**   The window functions implementation sometimes caches the input rows\n**   that it processes in a temporary table. If it is not zero, this\n**   variable indicates when rows may be removed from the temp table (in\n**   order to reduce memory requirements - it would always be safe just\n**   to leave them there). Possible values for eDelete are:\n**\n**      WINDOW_RETURN_ROW:\n**        An input row can be discarded after it is returned to the caller.\n**\n**      WINDOW_AGGINVERSE:\n**        An input row can be discarded after the window functions xInverse()\n**        callbacks have been invoked in it.\n**\n**      WINDOW_AGGSTEP:\n**        An input row can be discarded after the window functions xStep()\n**        callbacks have been invoked in it.\n**\n** start,current,end\n**   Consider a window-frame similar to the following:\n**\n**     (ORDER BY a, b GROUPS BETWEEN 2 PRECEDING AND 2 FOLLOWING)\n**\n**   The windows functions implmentation caches the input rows in a temp\n**   table, sorted by \"a, b\" (it actually populates the cache lazily, and\n**   aggressively removes rows once they are no longer required, but that's\n**   a mere detail). It keeps three cursors open on the temp table. One\n**   (current) that points to the next row to return to the query engine\n**   once its window function values have been calculated. Another (end)\n**   points to the next row to call the xStep() method of each window function\n**   on (so that it is 2 groups ahead of current). And a third (start) that\n**   points to the next row to call the xInverse() method of each window\n**   function on.\n**\n**   Each cursor (start, current and end) consists of a VDBE cursor\n**   (WindowCsrAndReg.csr) and an array of registers (starting at\n**   WindowCodeArg.reg) that always contains a copy of the peer values \n**   read from the corresponding cursor.\n**\n**   Depending on the window-frame in question, all three cursors may not\n**   be required. In this case both WindowCodeArg.csr and reg are set to\n**   0.\n*/\nstruct WindowCodeArg {\n  Parse *pParse;             /* Parse context */\n  Window *pMWin;             /* First in list of functions being processed */\n  Vdbe *pVdbe;               /* VDBE object */\n  int addrGosub;             /* OP_Gosub to this address to return one row */\n  int regGosub;              /* Register used with OP_Gosub(addrGosub) */\n  int regArg;                /* First in array of accumulator registers */\n  int eDelete;               /* See above */\n\n  WindowCsrAndReg start;\n  WindowCsrAndReg current;\n  WindowCsrAndReg end;\n};\n\n/*\n** Generate VM code to read the window frames peer values from cursor csr into\n** an array of registers starting at reg.\n*/\nstatic void windowReadPeerValues(\n  WindowCodeArg *p,\n  int csr,\n  int reg\n){\n  Window *pMWin = p->pMWin;\n  ExprList *pOrderBy = pMWin->pOrderBy;\n  if( pOrderBy ){\n    Vdbe *v = sqlite3GetVdbe(p->pParse);\n    ExprList *pPart = pMWin->pPartition;\n    int iColOff = pMWin->nBufferCol + (pPart ? pPart->nExpr : 0);\n    int i;\n    for(i=0; i<pOrderBy->nExpr; i++){\n      sqlite3VdbeAddOp3(v, OP_Column, csr, iColOff+i, reg+i);\n    }\n  }\n}\n\n/*\n** Generate VM code to invoke either xStep() (if bInverse is 0) or \n** xInverse (if bInverse is non-zero) for each window function in the \n** linked list starting at pMWin. Or, for built-in window functions\n** that do not use the standard function API, generate the required\n** inline VM code.\n**\n** If argument csr is greater than or equal to 0, then argument reg is\n** the first register in an array of registers guaranteed to be large\n** enough to hold the array of arguments for each function. In this case\n** the arguments are extracted from the current row of csr into the\n** array of registers before invoking OP_AggStep or OP_AggInverse\n**\n** Or, if csr is less than zero, then the array of registers at reg is\n** already populated with all columns from the current row of the sub-query.\n**\n** If argument regPartSize is non-zero, then it is a register containing the\n** number of rows in the current partition.\n*/\nstatic void windowAggStep(\n  WindowCodeArg *p,\n  Window *pMWin,                  /* Linked list of window functions */\n  int csr,                        /* Read arguments from this cursor */\n  int bInverse,                   /* True to invoke xInverse instead of xStep */\n  int reg                         /* Array of registers */\n){\n  Parse *pParse = p->pParse;\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  Window *pWin;\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    FuncDef *pFunc = pWin->pFunc;\n    int regArg;\n    int nArg = pWin->bExprArgs ? 0 : windowArgCount(pWin);\n    int i;\n\n    assert( bInverse==0 || pWin->eStart!=TK_UNBOUNDED );\n\n    /* All OVER clauses in the same window function aggregate step must\n    ** be the same. */\n    assert( pWin==pMWin || sqlite3WindowCompare(pParse,pWin,pMWin,0)==0 );\n\n    for(i=0; i<nArg; i++){\n      if( i!=1 || pFunc->zName!=nth_valueName ){\n        sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+i, reg+i);\n      }else{\n        sqlite3VdbeAddOp3(v, OP_Column, pMWin->iEphCsr, pWin->iArgCol+i, reg+i);\n      }\n    }\n    regArg = reg;\n\n    if( pMWin->regStartRowid==0\n     && (pFunc->funcFlags & SQLITE_FUNC_MINMAX) \n     && (pWin->eStart!=TK_UNBOUNDED)\n    ){\n      int addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regArg);\n      VdbeCoverage(v);\n      if( bInverse==0 ){\n        sqlite3VdbeAddOp2(v, OP_AddImm, pWin->regApp+1, 1);\n        sqlite3VdbeAddOp2(v, OP_SCopy, regArg, pWin->regApp);\n        sqlite3VdbeAddOp3(v, OP_MakeRecord, pWin->regApp, 2, pWin->regApp+2);\n        sqlite3VdbeAddOp2(v, OP_IdxInsert, pWin->csrApp, pWin->regApp+2);\n      }else{\n        sqlite3VdbeAddOp4Int(v, OP_SeekGE, pWin->csrApp, 0, regArg, 1);\n        VdbeCoverageNeverTaken(v);\n        sqlite3VdbeAddOp1(v, OP_Delete, pWin->csrApp);\n        sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);\n      }\n      sqlite3VdbeJumpHere(v, addrIsNull);\n    }else if( pWin->regApp ){\n      assert( pFunc->zName==nth_valueName\n           || pFunc->zName==first_valueName\n      );\n      assert( bInverse==0 || bInverse==1 );\n      sqlite3VdbeAddOp2(v, OP_AddImm, pWin->regApp+1-bInverse, 1);\n    }else if( pFunc->xSFunc!=noopStepFunc ){\n      int addrIf = 0;\n      if( pWin->pFilter ){\n        int regTmp;\n        assert( pWin->bExprArgs || !nArg ||nArg==pWin->pOwner->x.pList->nExpr );\n        assert( pWin->bExprArgs || nArg  ||pWin->pOwner->x.pList==0 );\n        regTmp = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+nArg,regTmp);\n        addrIf = sqlite3VdbeAddOp3(v, OP_IfNot, regTmp, 0, 1);\n        VdbeCoverage(v);\n        sqlite3ReleaseTempReg(pParse, regTmp);\n      }\n      \n      if( pWin->bExprArgs ){\n        int iStart = sqlite3VdbeCurrentAddr(v);\n        VdbeOp *pOp, *pEnd;\n\n        nArg = pWin->pOwner->x.pList->nExpr;\n        regArg = sqlite3GetTempRange(pParse, nArg);\n        sqlite3ExprCodeExprList(pParse, pWin->pOwner->x.pList, regArg, 0, 0);\n\n        pEnd = sqlite3VdbeGetOp(v, -1);\n        for(pOp=sqlite3VdbeGetOp(v, iStart); pOp<=pEnd; pOp++){\n          if( pOp->opcode==OP_Column && pOp->p1==pWin->iEphCsr ){\n            pOp->p1 = csr;\n          }\n        }\n      }\n      if( pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n        CollSeq *pColl;\n        assert( nArg>0 );\n        pColl = sqlite3ExprNNCollSeq(pParse, pWin->pOwner->x.pList->a[0].pExpr);\n        sqlite3VdbeAddOp4(v, OP_CollSeq, 0,0,0, (const char*)pColl, P4_COLLSEQ);\n      }\n      sqlite3VdbeAddOp3(v, bInverse? OP_AggInverse : OP_AggStep, \n                        bInverse, regArg, pWin->regAccum);\n      sqlite3VdbeAppendP4(v, pFunc, P4_FUNCDEF);\n      sqlite3VdbeChangeP5(v, (u8)nArg);\n      if( pWin->bExprArgs ){\n        sqlite3ReleaseTempRange(pParse, regArg, nArg);\n      }\n      if( addrIf ) sqlite3VdbeJumpHere(v, addrIf);\n    }\n  }\n}\n\n/*\n** Values that may be passed as the second argument to windowCodeOp().\n*/\n#define WINDOW_RETURN_ROW 1\n#define WINDOW_AGGINVERSE 2\n#define WINDOW_AGGSTEP    3\n\n/*\n** Generate VM code to invoke either xValue() (bFin==0) or xFinalize()\n** (bFin==1) for each window function in the linked list starting at\n** pMWin. Or, for built-in window-functions that do not use the standard\n** API, generate the equivalent VM code.\n*/\nstatic void windowAggFinal(WindowCodeArg *p, int bFin){\n  Parse *pParse = p->pParse;\n  Window *pMWin = p->pMWin;\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  Window *pWin;\n\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    if( pMWin->regStartRowid==0\n     && (pWin->pFunc->funcFlags & SQLITE_FUNC_MINMAX) \n     && (pWin->eStart!=TK_UNBOUNDED)\n    ){\n      sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);\n      sqlite3VdbeAddOp1(v, OP_Last, pWin->csrApp);\n      VdbeCoverage(v);\n      sqlite3VdbeAddOp3(v, OP_Column, pWin->csrApp, 0, pWin->regResult);\n      sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);\n    }else if( pWin->regApp ){\n      assert( pMWin->regStartRowid==0 );\n    }else{\n      int nArg = windowArgCount(pWin);\n      if( bFin ){\n        sqlite3VdbeAddOp2(v, OP_AggFinal, pWin->regAccum, nArg);\n        sqlite3VdbeAppendP4(v, pWin->pFunc, P4_FUNCDEF);\n        sqlite3VdbeAddOp2(v, OP_Copy, pWin->regAccum, pWin->regResult);\n        sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n      }else{\n        sqlite3VdbeAddOp3(v, OP_AggValue,pWin->regAccum,nArg,pWin->regResult);\n        sqlite3VdbeAppendP4(v, pWin->pFunc, P4_FUNCDEF);\n      }\n    }\n  }\n}\n\n/*\n** Generate code to calculate the current values of all window functions in the\n** p->pMWin list by doing a full scan of the current window frame. Store the\n** results in the Window.regResult registers, ready to return the upper\n** layer.\n*/\nstatic void windowFullScan(WindowCodeArg *p){\n  Window *pWin;\n  Parse *pParse = p->pParse;\n  Window *pMWin = p->pMWin;\n  Vdbe *v = p->pVdbe;\n\n  int regCRowid = 0;              /* Current rowid value */\n  int regCPeer = 0;               /* Current peer values */\n  int regRowid = 0;               /* AggStep rowid value */\n  int regPeer = 0;                /* AggStep peer values */\n\n  int nPeer;\n  int lblNext;\n  int lblBrk;\n  int addrNext;\n  int csr;\n\n  VdbeModuleComment((v, \"windowFullScan begin\"));\n\n  assert( pMWin!=0 );\n  csr = pMWin->csrApp;\n  nPeer = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);\n\n  lblNext = sqlite3VdbeMakeLabel(pParse);\n  lblBrk = sqlite3VdbeMakeLabel(pParse);\n\n  regCRowid = sqlite3GetTempReg(pParse);\n  regRowid = sqlite3GetTempReg(pParse);\n  if( nPeer ){\n    regCPeer = sqlite3GetTempRange(pParse, nPeer);\n    regPeer = sqlite3GetTempRange(pParse, nPeer);\n  }\n\n  sqlite3VdbeAddOp2(v, OP_Rowid, pMWin->iEphCsr, regCRowid);\n  windowReadPeerValues(p, pMWin->iEphCsr, regCPeer);\n\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n  }\n\n  sqlite3VdbeAddOp3(v, OP_SeekGE, csr, lblBrk, pMWin->regStartRowid);\n  VdbeCoverage(v);\n  addrNext = sqlite3VdbeCurrentAddr(v);\n  sqlite3VdbeAddOp2(v, OP_Rowid, csr, regRowid);\n  sqlite3VdbeAddOp3(v, OP_Gt, pMWin->regEndRowid, lblBrk, regRowid);\n  VdbeCoverageNeverNull(v);\n\n  if( pMWin->eExclude==TK_CURRENT ){\n    sqlite3VdbeAddOp3(v, OP_Eq, regCRowid, lblNext, regRowid);\n    VdbeCoverageNeverNull(v);\n  }else if( pMWin->eExclude!=TK_NO ){\n    int addr;\n    int addrEq = 0;\n    KeyInfo *pKeyInfo = 0;\n\n    if( pMWin->pOrderBy ){\n      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pMWin->pOrderBy, 0, 0);\n    }\n    if( pMWin->eExclude==TK_TIES ){\n      addrEq = sqlite3VdbeAddOp3(v, OP_Eq, regCRowid, 0, regRowid);\n      VdbeCoverageNeverNull(v);\n    }\n    if( pKeyInfo ){\n      windowReadPeerValues(p, csr, regPeer);\n      sqlite3VdbeAddOp3(v, OP_Compare, regPeer, regCPeer, nPeer);\n      sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);\n      addr = sqlite3VdbeCurrentAddr(v)+1;\n      sqlite3VdbeAddOp3(v, OP_Jump, addr, lblNext, addr);\n      VdbeCoverageEqNe(v);\n    }else{\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, lblNext);\n    }\n    if( addrEq ) sqlite3VdbeJumpHere(v, addrEq);\n  }\n\n  windowAggStep(p, pMWin, csr, 0, p->regArg);\n\n  sqlite3VdbeResolveLabel(v, lblNext);\n  sqlite3VdbeAddOp2(v, OP_Next, csr, addrNext);\n  VdbeCoverage(v);\n  sqlite3VdbeJumpHere(v, addrNext-1);\n  sqlite3VdbeJumpHere(v, addrNext+1);\n  sqlite3ReleaseTempReg(pParse, regRowid);\n  sqlite3ReleaseTempReg(pParse, regCRowid);\n  if( nPeer ){\n    sqlite3ReleaseTempRange(pParse, regPeer, nPeer);\n    sqlite3ReleaseTempRange(pParse, regCPeer, nPeer);\n  }\n\n  windowAggFinal(p, 1);\n  VdbeModuleComment((v, \"windowFullScan end\"));\n}\n\n/*\n** Invoke the sub-routine at regGosub (generated by code in select.c) to\n** return the current row of Window.iEphCsr. If all window functions are\n** aggregate window functions that use the standard API, a single\n** OP_Gosub instruction is all that this routine generates. Extra VM code\n** for per-row processing is only generated for the following built-in window\n** functions:\n**\n**   nth_value()\n**   first_value()\n**   lag()\n**   lead()\n*/\nstatic void windowReturnOneRow(WindowCodeArg *p){\n  Window *pMWin = p->pMWin;\n  Vdbe *v = p->pVdbe;\n\n  if( pMWin->regStartRowid ){\n    windowFullScan(p);\n  }else{\n    Parse *pParse = p->pParse;\n    Window *pWin;\n\n    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n      FuncDef *pFunc = pWin->pFunc;\n      if( pFunc->zName==nth_valueName\n       || pFunc->zName==first_valueName\n      ){\n        int csr = pWin->csrApp;\n        int lbl = sqlite3VdbeMakeLabel(pParse);\n        int tmpReg = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);\n  \n        if( pFunc->zName==nth_valueName ){\n          sqlite3VdbeAddOp3(v, OP_Column,pMWin->iEphCsr,pWin->iArgCol+1,tmpReg);\n          windowCheckValue(pParse, tmpReg, 2);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Integer, 1, tmpReg);\n        }\n        sqlite3VdbeAddOp3(v, OP_Add, tmpReg, pWin->regApp, tmpReg);\n        sqlite3VdbeAddOp3(v, OP_Gt, pWin->regApp+1, lbl, tmpReg);\n        VdbeCoverageNeverNull(v);\n        sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, 0, tmpReg);\n        VdbeCoverageNeverTaken(v);\n        sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);\n        sqlite3VdbeResolveLabel(v, lbl);\n        sqlite3ReleaseTempReg(pParse, tmpReg);\n      }\n      else if( pFunc->zName==leadName || pFunc->zName==lagName ){\n        int nArg = pWin->pOwner->x.pList->nExpr;\n        int csr = pWin->csrApp;\n        int lbl = sqlite3VdbeMakeLabel(pParse);\n        int tmpReg = sqlite3GetTempReg(pParse);\n        int iEph = pMWin->iEphCsr;\n  \n        if( nArg<3 ){\n          sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);\n        }else{\n          sqlite3VdbeAddOp3(v, OP_Column, iEph,pWin->iArgCol+2,pWin->regResult);\n        }\n        sqlite3VdbeAddOp2(v, OP_Rowid, iEph, tmpReg);\n        if( nArg<2 ){\n          int val = (pFunc->zName==leadName ? 1 : -1);\n          sqlite3VdbeAddOp2(v, OP_AddImm, tmpReg, val);\n        }else{\n          int op = (pFunc->zName==leadName ? OP_Add : OP_Subtract);\n          int tmpReg2 = sqlite3GetTempReg(pParse);\n          sqlite3VdbeAddOp3(v, OP_Column, iEph, pWin->iArgCol+1, tmpReg2);\n          sqlite3VdbeAddOp3(v, op, tmpReg2, tmpReg, tmpReg);\n          sqlite3ReleaseTempReg(pParse, tmpReg2);\n        }\n  \n        sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, lbl, tmpReg);\n        VdbeCoverage(v);\n        sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);\n        sqlite3VdbeResolveLabel(v, lbl);\n        sqlite3ReleaseTempReg(pParse, tmpReg);\n      }\n    }\n  }\n  sqlite3VdbeAddOp2(v, OP_Gosub, p->regGosub, p->addrGosub);\n}\n\n/*\n** Generate code to set the accumulator register for each window function\n** in the linked list passed as the second argument to NULL. And perform\n** any equivalent initialization required by any built-in window functions\n** in the list.\n*/\nstatic int windowInitAccum(Parse *pParse, Window *pMWin){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  int regArg;\n  int nArg = 0;\n  Window *pWin;\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    FuncDef *pFunc = pWin->pFunc;\n    sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n    nArg = MAX(nArg, windowArgCount(pWin));\n    if( pMWin->regStartRowid==0 ){\n      if( pFunc->zName==nth_valueName || pFunc->zName==first_valueName ){\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp);\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);\n      }\n\n      if( (pFunc->funcFlags & SQLITE_FUNC_MINMAX) && pWin->csrApp ){\n        assert( pWin->eStart!=TK_UNBOUNDED );\n        sqlite3VdbeAddOp1(v, OP_ResetSorter, pWin->csrApp);\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);\n      }\n    }\n  }\n  regArg = pParse->nMem+1;\n  pParse->nMem += nArg;\n  return regArg;\n}\n\n/* \n** Return true if the current frame should be cached in the ephemeral table,\n** even if there are no xInverse() calls required.\n*/\nstatic int windowCacheFrame(Window *pMWin){\n  Window *pWin;\n  if( pMWin->regStartRowid ) return 1;\n  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n    FuncDef *pFunc = pWin->pFunc;\n    if( (pFunc->zName==nth_valueName)\n     || (pFunc->zName==first_valueName)\n     || (pFunc->zName==leadName)\n     || (pFunc->zName==lagName)\n    ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** regOld and regNew are each the first register in an array of size\n** pOrderBy->nExpr. This function generates code to compare the two\n** arrays of registers using the collation sequences and other comparison\n** parameters specified by pOrderBy. \n**\n** If the two arrays are not equal, the contents of regNew is copied to \n** regOld and control falls through. Otherwise, if the contents of the arrays\n** are equal, an OP_Goto is executed. The address of the OP_Goto is returned.\n*/\nstatic void windowIfNewPeer(\n  Parse *pParse,\n  ExprList *pOrderBy,\n  int regNew,                     /* First in array of new values */\n  int regOld,                     /* First in array of old values */\n  int addr                        /* Jump here */\n){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  if( pOrderBy ){\n    int nVal = pOrderBy->nExpr;\n    KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOrderBy, 0, 0);\n    sqlite3VdbeAddOp3(v, OP_Compare, regOld, regNew, nVal);\n    sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);\n    sqlite3VdbeAddOp3(v, OP_Jump, \n      sqlite3VdbeCurrentAddr(v)+1, addr, sqlite3VdbeCurrentAddr(v)+1\n    );\n    VdbeCoverageEqNe(v);\n    sqlite3VdbeAddOp3(v, OP_Copy, regNew, regOld, nVal-1);\n  }else{\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addr);\n  }\n}\n\n/*\n** This function is called as part of generating VM programs for RANGE\n** offset PRECEDING/FOLLOWING frame boundaries. Assuming \"ASC\" order for\n** the ORDER BY term in the window, and that argument op is OP_Ge, it generates\n** code equivalent to:\n**\n**   if( csr1.peerVal + regVal >= csr2.peerVal ) goto lbl;\n**\n** The value of parameter op may also be OP_Gt or OP_Le. In these cases the\n** operator in the above pseudo-code is replaced with \">\" or \"<=\", respectively.\n**\n** If the sort-order for the ORDER BY term in the window is DESC, then the\n** comparison is reversed. Instead of adding regVal to csr1.peerVal, it is\n** subtracted. And the comparison operator is inverted to - \">=\" becomes \"<=\",\n** \">\" becomes \"<\", and so on. So, with DESC sort order, if the argument op\n** is OP_Ge, the generated code is equivalent to:\n**\n**   if( csr1.peerVal - regVal <= csr2.peerVal ) goto lbl;\n**\n** A special type of arithmetic is used such that if csr1.peerVal is not\n** a numeric type (real or integer), then the result of the addition addition\n** or subtraction is a a copy of csr1.peerVal.\n*/\nstatic void windowCodeRangeTest(\n  WindowCodeArg *p, \n  int op,                         /* OP_Ge, OP_Gt, or OP_Le */\n  int csr1,                       /* Cursor number for cursor 1 */\n  int regVal,                     /* Register containing non-negative number */\n  int csr2,                       /* Cursor number for cursor 2 */\n  int lbl                         /* Jump destination if condition is true */\n){\n  Parse *pParse = p->pParse;\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  ExprList *pOrderBy = p->pMWin->pOrderBy;  /* ORDER BY clause for window */\n  int reg1 = sqlite3GetTempReg(pParse);     /* Reg. for csr1.peerVal+regVal */\n  int reg2 = sqlite3GetTempReg(pParse);     /* Reg. for csr2.peerVal */\n  int regString = ++pParse->nMem;           /* Reg. for constant value '' */\n  int arith = OP_Add;                       /* OP_Add or OP_Subtract */\n  int addrGe;                               /* Jump destination */\n\n  assert( op==OP_Ge || op==OP_Gt || op==OP_Le );\n  assert( pOrderBy && pOrderBy->nExpr==1 );\n  if( pOrderBy->a[0].sortFlags & KEYINFO_ORDER_DESC ){\n    switch( op ){\n      case OP_Ge: op = OP_Le; break;\n      case OP_Gt: op = OP_Lt; break;\n      default: assert( op==OP_Le ); op = OP_Ge; break;\n    }\n    arith = OP_Subtract;\n  }\n\n  /* Read the peer-value from each cursor into a register */\n  windowReadPeerValues(p, csr1, reg1);\n  windowReadPeerValues(p, csr2, reg2);\n\n  VdbeModuleComment((v, \"CodeRangeTest: if( R%d %s R%d %s R%d ) goto lbl\",\n      reg1, (arith==OP_Add ? \"+\" : \"-\"), regVal,\n      ((op==OP_Ge) ? \">=\" : (op==OP_Le) ? \"<=\" : (op==OP_Gt) ? \">\" : \"<\"), reg2\n  ));\n\n  /* Register reg1 currently contains csr1.peerVal (the peer-value from csr1).\n  ** This block adds (or subtracts for DESC) the numeric value in regVal\n  ** from it. Or, if reg1 is not numeric (it is a NULL, a text value or a blob),\n  ** then leave reg1 as it is. In pseudo-code, this is implemented as:\n  **\n  **   if( reg1>='' ) goto addrGe;\n  **   reg1 = reg1 +/- regVal\n  **   addrGe:\n  **\n  ** Since all strings and blobs are greater-than-or-equal-to an empty string,\n  ** the add/subtract is skipped for these, as required. If reg1 is a NULL,\n  ** then the arithmetic is performed, but since adding or subtracting from\n  ** NULL is always NULL anyway, this case is handled as required too.  */\n  sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, \"\", P4_STATIC);\n  addrGe = sqlite3VdbeAddOp3(v, OP_Ge, regString, 0, reg1);\n  VdbeCoverage(v);\n  sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1);\n  sqlite3VdbeJumpHere(v, addrGe);\n\n  /* If the BIGNULL flag is set for the ORDER BY, then it is required to \n  ** consider NULL values to be larger than all other values, instead of \n  ** the usual smaller. The VDBE opcodes OP_Ge and so on do not handle this\n  ** (and adding that capability causes a performance regression), so\n  ** instead if the BIGNULL flag is set then cases where either reg1 or\n  ** reg2 are NULL are handled separately in the following block. The code\n  ** generated is equivalent to:\n  **\n  **   if( reg1 IS NULL ){\n  **     if( op==OP_Ge ) goto lbl;\n  **     if( op==OP_Gt && reg2 IS NOT NULL ) goto lbl;\n  **     if( op==OP_Le && reg2 IS NULL ) goto lbl;\n  **   }else if( reg2 IS NULL ){\n  **     if( op==OP_Le ) goto lbl;\n  **   }\n  **\n  ** Additionally, if either reg1 or reg2 are NULL but the jump to lbl is \n  ** not taken, control jumps over the comparison operator coded below this\n  ** block.  */\n  if( pOrderBy->a[0].sortFlags & KEYINFO_ORDER_BIGNULL ){\n    /* This block runs if reg1 contains a NULL. */\n    int addr = sqlite3VdbeAddOp1(v, OP_NotNull, reg1); VdbeCoverage(v);\n    switch( op ){\n      case OP_Ge: \n        sqlite3VdbeAddOp2(v, OP_Goto, 0, lbl); \n        break;\n      case OP_Gt: \n        sqlite3VdbeAddOp2(v, OP_NotNull, reg2, lbl); \n        VdbeCoverage(v); \n        break;\n      case OP_Le: \n        sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl); \n        VdbeCoverage(v); \n        break;\n      default: assert( op==OP_Lt ); /* no-op */ break;\n    }\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, sqlite3VdbeCurrentAddr(v)+3);\n\n    /* This block runs if reg1 is not NULL, but reg2 is. */\n    sqlite3VdbeJumpHere(v, addr);\n    sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl); VdbeCoverage(v);\n    if( op==OP_Gt || op==OP_Ge ){\n      sqlite3VdbeChangeP2(v, -1, sqlite3VdbeCurrentAddr(v)+1);\n    }\n  }\n\n  /* Compare registers reg2 and reg1, taking the jump if required. Note that\n  ** control skips over this test if the BIGNULL flag is set and either\n  ** reg1 or reg2 contain a NULL value.  */\n  sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); VdbeCoverage(v);\n  sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);\n\n  assert( op==OP_Ge || op==OP_Gt || op==OP_Lt || op==OP_Le );\n  testcase(op==OP_Ge); VdbeCoverageIf(v, op==OP_Ge);\n  testcase(op==OP_Lt); VdbeCoverageIf(v, op==OP_Lt);\n  testcase(op==OP_Le); VdbeCoverageIf(v, op==OP_Le);\n  testcase(op==OP_Gt); VdbeCoverageIf(v, op==OP_Gt);\n  sqlite3ReleaseTempReg(pParse, reg1);\n  sqlite3ReleaseTempReg(pParse, reg2);\n\n  VdbeModuleComment((v, \"CodeRangeTest: end\"));\n}\n\n/*\n** Helper function for sqlite3WindowCodeStep(). Each call to this function\n** generates VM code for a single RETURN_ROW, AGGSTEP or AGGINVERSE \n** operation. Refer to the header comment for sqlite3WindowCodeStep() for\n** details.\n*/\nstatic int windowCodeOp(\n WindowCodeArg *p,                /* Context object */\n int op,                          /* WINDOW_RETURN_ROW, AGGSTEP or AGGINVERSE */\n int regCountdown,                /* Register for OP_IfPos countdown */\n int jumpOnEof                    /* Jump here if stepped cursor reaches EOF */\n){\n  int csr, reg;\n  Parse *pParse = p->pParse;\n  Window *pMWin = p->pMWin;\n  int ret = 0;\n  Vdbe *v = p->pVdbe;\n  int addrContinue = 0;\n  int bPeer = (pMWin->eFrmType!=TK_ROWS);\n\n  int lblDone = sqlite3VdbeMakeLabel(pParse);\n  int addrNextRange = 0;\n\n  /* Special case - WINDOW_AGGINVERSE is always a no-op if the frame\n  ** starts with UNBOUNDED PRECEDING. */\n  if( op==WINDOW_AGGINVERSE && pMWin->eStart==TK_UNBOUNDED ){\n    assert( regCountdown==0 && jumpOnEof==0 );\n    return 0;\n  }\n\n  if( regCountdown>0 ){\n    if( pMWin->eFrmType==TK_RANGE ){\n      addrNextRange = sqlite3VdbeCurrentAddr(v);\n      assert( op==WINDOW_AGGINVERSE || op==WINDOW_AGGSTEP );\n      if( op==WINDOW_AGGINVERSE ){\n        if( pMWin->eStart==TK_FOLLOWING ){\n          windowCodeRangeTest(\n              p, OP_Le, p->current.csr, regCountdown, p->start.csr, lblDone\n          );\n        }else{\n          windowCodeRangeTest(\n              p, OP_Ge, p->start.csr, regCountdown, p->current.csr, lblDone\n          );\n        }\n      }else{\n        windowCodeRangeTest(\n            p, OP_Gt, p->end.csr, regCountdown, p->current.csr, lblDone\n        );\n      }\n    }else{\n      sqlite3VdbeAddOp3(v, OP_IfPos, regCountdown, lblDone, 1);\n      VdbeCoverage(v);\n    }\n  }\n\n  if( op==WINDOW_RETURN_ROW && pMWin->regStartRowid==0 ){\n    windowAggFinal(p, 0);\n  }\n  addrContinue = sqlite3VdbeCurrentAddr(v);\n\n  /* If this is a (RANGE BETWEEN a FOLLOWING AND b FOLLOWING) or\n  ** (RANGE BETWEEN b PRECEDING AND a PRECEDING) frame, ensure the \n  ** start cursor does not advance past the end cursor within the \n  ** temporary table. It otherwise might, if (a>b).  */\n  if( pMWin->eStart==pMWin->eEnd && regCountdown\n   && pMWin->eFrmType==TK_RANGE && op==WINDOW_AGGINVERSE\n  ){\n    int regRowid1 = sqlite3GetTempReg(pParse);\n    int regRowid2 = sqlite3GetTempReg(pParse);\n    sqlite3VdbeAddOp2(v, OP_Rowid, p->start.csr, regRowid1);\n    sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid2);\n    sqlite3VdbeAddOp3(v, OP_Ge, regRowid2, lblDone, regRowid1);\n    VdbeCoverage(v);\n    sqlite3ReleaseTempReg(pParse, regRowid1);\n    sqlite3ReleaseTempReg(pParse, regRowid2);\n    assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING );\n  }\n\n  switch( op ){\n    case WINDOW_RETURN_ROW:\n      csr = p->current.csr;\n      reg = p->current.reg;\n      windowReturnOneRow(p);\n      break;\n\n    case WINDOW_AGGINVERSE:\n      csr = p->start.csr;\n      reg = p->start.reg;\n      if( pMWin->regStartRowid ){\n        assert( pMWin->regEndRowid );\n        sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regStartRowid, 1);\n      }else{\n        windowAggStep(p, pMWin, csr, 1, p->regArg);\n      }\n      break;\n\n    default:\n      assert( op==WINDOW_AGGSTEP );\n      csr = p->end.csr;\n      reg = p->end.reg;\n      if( pMWin->regStartRowid ){\n        assert( pMWin->regEndRowid );\n        sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);\n      }else{\n        windowAggStep(p, pMWin, csr, 0, p->regArg);\n      }\n      break;\n  }\n\n  if( op==p->eDelete ){\n    sqlite3VdbeAddOp1(v, OP_Delete, csr);\n    sqlite3VdbeChangeP5(v, OPFLAG_SAVEPOSITION);\n  }\n\n  if( jumpOnEof ){\n    sqlite3VdbeAddOp2(v, OP_Next, csr, sqlite3VdbeCurrentAddr(v)+2);\n    VdbeCoverage(v);\n    ret = sqlite3VdbeAddOp0(v, OP_Goto);\n  }else{\n    sqlite3VdbeAddOp2(v, OP_Next, csr, sqlite3VdbeCurrentAddr(v)+1+bPeer);\n    VdbeCoverage(v);\n    if( bPeer ){\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, lblDone);\n    }\n  }\n\n  if( bPeer ){\n    int nReg = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);\n    int regTmp = (nReg ? sqlite3GetTempRange(pParse, nReg) : 0);\n    windowReadPeerValues(p, csr, regTmp);\n    windowIfNewPeer(pParse, pMWin->pOrderBy, regTmp, reg, addrContinue);\n    sqlite3ReleaseTempRange(pParse, regTmp, nReg);\n  }\n\n  if( addrNextRange ){\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrNextRange);\n  }\n  sqlite3VdbeResolveLabel(v, lblDone);\n  return ret;\n}\n\n\n/*\n** Allocate and return a duplicate of the Window object indicated by the\n** third argument. Set the Window.pOwner field of the new object to\n** pOwner.\n*/\nWindow *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){\n  Window *pNew = 0;\n  if( ALWAYS(p) ){\n    pNew = sqlite3DbMallocZero(db, sizeof(Window));\n    if( pNew ){\n      pNew->zName = sqlite3DbStrDup(db, p->zName);\n      pNew->zBase = sqlite3DbStrDup(db, p->zBase);\n      pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);\n      pNew->pFunc = p->pFunc;\n      pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);\n      pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);\n      pNew->eFrmType = p->eFrmType;\n      pNew->eEnd = p->eEnd;\n      pNew->eStart = p->eStart;\n      pNew->eExclude = p->eExclude;\n      pNew->regResult = p->regResult;\n      pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);\n      pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);\n      pNew->pOwner = pOwner;\n      pNew->bImplicitFrame = p->bImplicitFrame;\n    }\n  }\n  return pNew;\n}\n\n/*\n** Return a copy of the linked list of Window objects passed as the\n** second argument.\n*/\nWindow *sqlite3WindowListDup(sqlite3 *db, Window *p){\n  Window *pWin;\n  Window *pRet = 0;\n  Window **pp = &pRet;\n\n  for(pWin=p; pWin; pWin=pWin->pNextWin){\n    *pp = sqlite3WindowDup(db, 0, pWin);\n    if( *pp==0 ) break;\n    pp = &((*pp)->pNextWin);\n  }\n\n  return pRet;\n}\n\n/*\n** Return true if it can be determined at compile time that expression \n** pExpr evaluates to a value that, when cast to an integer, is greater \n** than zero. False otherwise.\n**\n** If an OOM error occurs, this function sets the Parse.db.mallocFailed \n** flag and returns zero.\n*/\nstatic int windowExprGtZero(Parse *pParse, Expr *pExpr){\n  int ret = 0;\n  sqlite3 *db = pParse->db;\n  sqlite3_value *pVal = 0;\n  sqlite3ValueFromExpr(db, pExpr, db->enc, SQLITE_AFF_NUMERIC, &pVal);\n  if( pVal && sqlite3_value_int(pVal)>0 ){\n    ret = 1;\n  }\n  sqlite3ValueFree(pVal);\n  return ret;\n}\n\n/*\n** sqlite3WhereBegin() has already been called for the SELECT statement \n** passed as the second argument when this function is invoked. It generates\n** code to populate the Window.regResult register for each window function \n** and invoke the sub-routine at instruction addrGosub once for each row.\n** sqlite3WhereEnd() is always called before returning. \n**\n** This function handles several different types of window frames, which\n** require slightly different processing. The following pseudo code is\n** used to implement window frames of the form:\n**\n**   ROWS BETWEEN <expr1> PRECEDING AND <expr2> FOLLOWING\n**\n** Other window frame types use variants of the following:\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**       if( new partition ){\n**         Gosub flush\n**       }\n**       Insert new row into eph table.\n**       \n**       if( first row of partition ){\n**         // Rewind three cursors, all open on the eph table.\n**         Rewind(csrEnd);\n**         Rewind(csrStart);\n**         Rewind(csrCurrent);\n**       \n**         regEnd = <expr2>          // FOLLOWING expression\n**         regStart = <expr1>        // PRECEDING expression\n**       }else{\n**         // First time this branch is taken, the eph table contains two \n**         // rows. The first row in the partition, which all three cursors\n**         // currently point to, and the following row.\n**         AGGSTEP\n**         if( (regEnd--)<=0 ){\n**           RETURN_ROW\n**           if( (regStart--)<=0 ){\n**             AGGINVERSE\n**           }\n**         }\n**       }\n**     }\n**     flush:\n**       AGGSTEP\n**       while( 1 ){\n**         RETURN ROW\n**         if( csrCurrent is EOF ) break;\n**         if( (regStart--)<=0 ){\n**           AggInverse(csrStart)\n**           Next(csrStart)\n**         }\n**       }\n**\n** The pseudo-code above uses the following shorthand:\n**\n**   AGGSTEP:    invoke the aggregate xStep() function for each window function\n**               with arguments read from the current row of cursor csrEnd, then\n**               step cursor csrEnd forward one row (i.e. sqlite3BtreeNext()).\n**\n**   RETURN_ROW: return a row to the caller based on the contents of the \n**               current row of csrCurrent and the current state of all \n**               aggregates. Then step cursor csrCurrent forward one row.\n**\n**   AGGINVERSE: invoke the aggregate xInverse() function for each window \n**               functions with arguments read from the current row of cursor\n**               csrStart. Then step csrStart forward one row.\n**\n** There are two other ROWS window frames that are handled significantly\n** differently from the above - \"BETWEEN <expr> PRECEDING AND <expr> PRECEDING\"\n** and \"BETWEEN <expr> FOLLOWING AND <expr> FOLLOWING\". These are special \n** cases because they change the order in which the three cursors (csrStart,\n** csrCurrent and csrEnd) iterate through the ephemeral table. Cases that\n** use UNBOUNDED or CURRENT ROW are much simpler variations on one of these\n** three.\n**\n**   ROWS BETWEEN <expr1> PRECEDING AND <expr2> PRECEDING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**       if( new partition ){\n**         Gosub flush\n**       }\n**       Insert new row into eph table.\n**       if( first row of partition ){\n**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**         regEnd = <expr2>\n**         regStart = <expr1>\n**       }else{\n**         if( (regEnd--)<=0 ){\n**           AGGSTEP\n**         }\n**         RETURN_ROW\n**         if( (regStart--)<=0 ){\n**           AGGINVERSE\n**         }\n**       }\n**     }\n**     flush:\n**       if( (regEnd--)<=0 ){\n**         AGGSTEP\n**       }\n**       RETURN_ROW\n**\n**\n**   ROWS BETWEEN <expr1> FOLLOWING AND <expr2> FOLLOWING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**     if( new partition ){\n**       Gosub flush\n**     }\n**     Insert new row into eph table.\n**     if( first row of partition ){\n**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**       regEnd = <expr2>\n**       regStart = regEnd - <expr1>\n**     }else{\n**       AGGSTEP\n**       if( (regEnd--)<=0 ){\n**         RETURN_ROW\n**       }\n**       if( (regStart--)<=0 ){\n**         AGGINVERSE\n**       }\n**     }\n**   }\n**   flush:\n**     AGGSTEP\n**     while( 1 ){\n**       if( (regEnd--)<=0 ){\n**         RETURN_ROW\n**         if( eof ) break;\n**       }\n**       if( (regStart--)<=0 ){\n**         AGGINVERSE\n**         if( eof ) break\n**       }\n**     }\n**     while( !eof csrCurrent ){\n**       RETURN_ROW\n**     }\n**\n** For the most part, the patterns above are adapted to support UNBOUNDED by\n** assuming that it is equivalent to \"infinity PRECEDING/FOLLOWING\" and\n** CURRENT ROW by assuming that it is equivilent to \"0 PRECEDING/FOLLOWING\".\n** This is optimized of course - branches that will never be taken and\n** conditions that are always true are omitted from the VM code. The only\n** exceptional case is:\n**\n**   ROWS BETWEEN <expr1> FOLLOWING AND UNBOUNDED FOLLOWING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**     if( new partition ){\n**       Gosub flush\n**     }\n**     Insert new row into eph table.\n**     if( first row of partition ){\n**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**       regStart = <expr1>\n**     }else{\n**       AGGSTEP\n**     }\n**   }\n**   flush:\n**     AGGSTEP\n**     while( 1 ){\n**       if( (regStart--)<=0 ){\n**         AGGINVERSE\n**         if( eof ) break\n**       }\n**       RETURN_ROW\n**     }\n**     while( !eof csrCurrent ){\n**       RETURN_ROW\n**     }\n**\n** Also requiring special handling are the cases:\n**\n**   ROWS BETWEEN <expr1> PRECEDING AND <expr2> PRECEDING\n**   ROWS BETWEEN <expr1> FOLLOWING AND <expr2> FOLLOWING\n**\n** when (expr1 < expr2). This is detected at runtime, not by this function.\n** To handle this case, the pseudo-code programs depicted above are modified\n** slightly to be:\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**     if( new partition ){\n**       Gosub flush\n**     }\n**     Insert new row into eph table.\n**     if( first row of partition ){\n**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**       regEnd = <expr2>\n**       regStart = <expr1>\n**       if( regEnd < regStart ){\n**         RETURN_ROW\n**         delete eph table contents\n**         continue\n**       }\n**     ...\n**\n** The new \"continue\" statement in the above jumps to the next iteration\n** of the outer loop - the one started by sqlite3WhereBegin().\n**\n** The various GROUPS cases are implemented using the same patterns as\n** ROWS. The VM code is modified slightly so that:\n**\n**   1. The else branch in the main loop is only taken if the row just\n**      added to the ephemeral table is the start of a new group. In\n**      other words, it becomes:\n**\n**         ... loop started by sqlite3WhereBegin() ...\n**         if( new partition ){\n**           Gosub flush\n**         }\n**         Insert new row into eph table.\n**         if( first row of partition ){\n**           Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**           regEnd = <expr2>\n**           regStart = <expr1>\n**         }else if( new group ){\n**           ... \n**         }\n**       }\n**\n**   2. Instead of processing a single row, each RETURN_ROW, AGGSTEP or \n**      AGGINVERSE step processes the current row of the relevant cursor and\n**      all subsequent rows belonging to the same group.\n**\n** RANGE window frames are a little different again. As for GROUPS, the \n** main loop runs once per group only. And RETURN_ROW, AGGSTEP and AGGINVERSE\n** deal in groups instead of rows. As for ROWS and GROUPS, there are three\n** basic cases:\n**\n**   RANGE BETWEEN <expr1> PRECEDING AND <expr2> FOLLOWING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**       if( new partition ){\n**         Gosub flush\n**       }\n**       Insert new row into eph table.\n**       if( first row of partition ){\n**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**         regEnd = <expr2>\n**         regStart = <expr1>\n**       }else{\n**         AGGSTEP\n**         while( (csrCurrent.key + regEnd) < csrEnd.key ){\n**           RETURN_ROW\n**           while( csrStart.key + regStart) < csrCurrent.key ){\n**             AGGINVERSE\n**           }\n**         }\n**       }\n**     }\n**     flush:\n**       AGGSTEP\n**       while( 1 ){\n**         RETURN ROW\n**         if( csrCurrent is EOF ) break;\n**           while( csrStart.key + regStart) < csrCurrent.key ){\n**             AGGINVERSE\n**           }\n**         }\n**       }\n**\n** In the above notation, \"csr.key\" means the current value of the ORDER BY \n** expression (there is only ever 1 for a RANGE that uses an <expr> FOLLOWING\n** or <expr PRECEDING) read from cursor csr.\n**\n**   RANGE BETWEEN <expr1> PRECEDING AND <expr2> PRECEDING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**       if( new partition ){\n**         Gosub flush\n**       }\n**       Insert new row into eph table.\n**       if( first row of partition ){\n**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**         regEnd = <expr2>\n**         regStart = <expr1>\n**       }else{\n**         while( (csrEnd.key + regEnd) <= csrCurrent.key ){\n**           AGGSTEP\n**         }\n**         while( (csrStart.key + regStart) < csrCurrent.key ){\n**           AGGINVERSE\n**         }\n**         RETURN_ROW\n**       }\n**     }\n**     flush:\n**       while( (csrEnd.key + regEnd) <= csrCurrent.key ){\n**         AGGSTEP\n**       }\n**       while( (csrStart.key + regStart) < csrCurrent.key ){\n**         AGGINVERSE\n**       }\n**       RETURN_ROW\n**\n**   RANGE BETWEEN <expr1> FOLLOWING AND <expr2> FOLLOWING\n**\n**     ... loop started by sqlite3WhereBegin() ...\n**       if( new partition ){\n**         Gosub flush\n**       }\n**       Insert new row into eph table.\n**       if( first row of partition ){\n**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)\n**         regEnd = <expr2>\n**         regStart = <expr1>\n**       }else{\n**         AGGSTEP\n**         while( (csrCurrent.key + regEnd) < csrEnd.key ){\n**           while( (csrCurrent.key + regStart) > csrStart.key ){\n**             AGGINVERSE\n**           }\n**           RETURN_ROW\n**         }\n**       }\n**     }\n**     flush:\n**       AGGSTEP\n**       while( 1 ){\n**         while( (csrCurrent.key + regStart) > csrStart.key ){\n**           AGGINVERSE\n**           if( eof ) break \"while( 1 )\" loop.\n**         }\n**         RETURN_ROW\n**       }\n**       while( !eof csrCurrent ){\n**         RETURN_ROW\n**       }\n**\n** The text above leaves out many details. Refer to the code and comments\n** below for a more complete picture.\n*/\nvoid sqlite3WindowCodeStep(\n  Parse *pParse,                  /* Parse context */\n  Select *p,                      /* Rewritten SELECT statement */\n  WhereInfo *pWInfo,              /* Context returned by sqlite3WhereBegin() */\n  int regGosub,                   /* Register for OP_Gosub */\n  int addrGosub                   /* OP_Gosub here to return each row */\n){\n  Window *pMWin = p->pWin;\n  ExprList *pOrderBy = pMWin->pOrderBy;\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  int csrWrite;                   /* Cursor used to write to eph. table */\n  int csrInput = p->pSrc->a[0].iCursor;     /* Cursor of sub-select */\n  int nInput = p->pSrc->a[0].pTab->nCol;    /* Number of cols returned by sub */\n  int iInput;                               /* To iterate through sub cols */\n  int addrNe;                     /* Address of OP_Ne */\n  int addrGosubFlush = 0;         /* Address of OP_Gosub to flush: */\n  int addrInteger = 0;            /* Address of OP_Integer */\n  int addrEmpty;                  /* Address of OP_Rewind in flush: */\n  int regNew;                     /* Array of registers holding new input row */\n  int regRecord;                  /* regNew array in record form */\n  int regRowid;                   /* Rowid for regRecord in eph table */\n  int regNewPeer = 0;             /* Peer values for new row (part of regNew) */\n  int regPeer = 0;                /* Peer values for current row */\n  int regFlushPart = 0;           /* Register for \"Gosub flush_partition\" */\n  WindowCodeArg s;                /* Context object for sub-routines */\n  int lblWhereEnd;                /* Label just before sqlite3WhereEnd() code */\n  int regStart = 0;               /* Value of <expr> PRECEDING */\n  int regEnd = 0;                 /* Value of <expr> FOLLOWING */\n\n  assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_CURRENT \n       || pMWin->eStart==TK_FOLLOWING || pMWin->eStart==TK_UNBOUNDED \n  );\n  assert( pMWin->eEnd==TK_FOLLOWING || pMWin->eEnd==TK_CURRENT \n       || pMWin->eEnd==TK_UNBOUNDED || pMWin->eEnd==TK_PRECEDING \n  );\n  assert( pMWin->eExclude==0 || pMWin->eExclude==TK_CURRENT\n       || pMWin->eExclude==TK_GROUP || pMWin->eExclude==TK_TIES\n       || pMWin->eExclude==TK_NO\n  );\n\n  lblWhereEnd = sqlite3VdbeMakeLabel(pParse);\n\n  /* Fill in the context object */\n  memset(&s, 0, sizeof(WindowCodeArg));\n  s.pParse = pParse;\n  s.pMWin = pMWin;\n  s.pVdbe = v;\n  s.regGosub = regGosub;\n  s.addrGosub = addrGosub;\n  s.current.csr = pMWin->iEphCsr;\n  csrWrite = s.current.csr+1;\n  s.start.csr = s.current.csr+2;\n  s.end.csr = s.current.csr+3;\n\n  /* Figure out when rows may be deleted from the ephemeral table. There\n  ** are four options - they may never be deleted (eDelete==0), they may \n  ** be deleted as soon as they are no longer part of the window frame\n  ** (eDelete==WINDOW_AGGINVERSE), they may be deleted as after the row \n  ** has been returned to the caller (WINDOW_RETURN_ROW), or they may\n  ** be deleted after they enter the frame (WINDOW_AGGSTEP). */\n  switch( pMWin->eStart ){\n    case TK_FOLLOWING:\n      if( pMWin->eFrmType!=TK_RANGE\n       && windowExprGtZero(pParse, pMWin->pStart)\n      ){\n        s.eDelete = WINDOW_RETURN_ROW;\n      }\n      break;\n    case TK_UNBOUNDED:\n      if( windowCacheFrame(pMWin)==0 ){\n        if( pMWin->eEnd==TK_PRECEDING ){\n          if( pMWin->eFrmType!=TK_RANGE\n           && windowExprGtZero(pParse, pMWin->pEnd)\n          ){\n            s.eDelete = WINDOW_AGGSTEP;\n          }\n        }else{\n          s.eDelete = WINDOW_RETURN_ROW;\n        }\n      }\n      break;\n    default:\n      s.eDelete = WINDOW_AGGINVERSE;\n      break;\n  }\n\n  /* Allocate registers for the array of values from the sub-query, the\n  ** samve values in record form, and the rowid used to insert said record\n  ** into the ephemeral table.  */\n  regNew = pParse->nMem+1;\n  pParse->nMem += nInput;\n  regRecord = ++pParse->nMem;\n  regRowid = ++pParse->nMem;\n\n  /* If the window frame contains an \"<expr> PRECEDING\" or \"<expr> FOLLOWING\"\n  ** clause, allocate registers to store the results of evaluating each\n  ** <expr>.  */\n  if( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING ){\n    regStart = ++pParse->nMem;\n  }\n  if( pMWin->eEnd==TK_PRECEDING || pMWin->eEnd==TK_FOLLOWING ){\n    regEnd = ++pParse->nMem;\n  }\n\n  /* If this is not a \"ROWS BETWEEN ...\" frame, then allocate arrays of\n  ** registers to store copies of the ORDER BY expressions (peer values) \n  ** for the main loop, and for each cursor (start, current and end). */\n  if( pMWin->eFrmType!=TK_ROWS ){\n    int nPeer = (pOrderBy ? pOrderBy->nExpr : 0);\n    regNewPeer = regNew + pMWin->nBufferCol;\n    if( pMWin->pPartition ) regNewPeer += pMWin->pPartition->nExpr;\n    regPeer = pParse->nMem+1;       pParse->nMem += nPeer;\n    s.start.reg = pParse->nMem+1;   pParse->nMem += nPeer;\n    s.current.reg = pParse->nMem+1; pParse->nMem += nPeer;\n    s.end.reg = pParse->nMem+1;     pParse->nMem += nPeer;\n  }\n\n  /* Load the column values for the row returned by the sub-select\n  ** into an array of registers starting at regNew. Assemble them into\n  ** a record in register regRecord. */\n  for(iInput=0; iInput<nInput; iInput++){\n    sqlite3VdbeAddOp3(v, OP_Column, csrInput, iInput, regNew+iInput);\n  }\n  sqlite3VdbeAddOp3(v, OP_MakeRecord, regNew, nInput, regRecord);\n\n  /* An input row has just been read into an array of registers starting\n  ** at regNew. If the window has a PARTITION clause, this block generates \n  ** VM code to check if the input row is the start of a new partition.\n  ** If so, it does an OP_Gosub to an address to be filled in later. The\n  ** address of the OP_Gosub is stored in local variable addrGosubFlush. */\n  if( pMWin->pPartition ){\n    int addr;\n    ExprList *pPart = pMWin->pPartition;\n    int nPart = pPart->nExpr;\n    int regNewPart = regNew + pMWin->nBufferCol;\n    KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, 0, 0);\n\n    regFlushPart = ++pParse->nMem;\n    addr = sqlite3VdbeAddOp3(v, OP_Compare, regNewPart, pMWin->regPart, nPart);\n    sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);\n    sqlite3VdbeAddOp3(v, OP_Jump, addr+2, addr+4, addr+2);\n    VdbeCoverageEqNe(v);\n    addrGosubFlush = sqlite3VdbeAddOp1(v, OP_Gosub, regFlushPart);\n    VdbeComment((v, \"call flush_partition\"));\n    sqlite3VdbeAddOp3(v, OP_Copy, regNewPart, pMWin->regPart, nPart-1);\n  }\n\n  /* Insert the new row into the ephemeral table */\n  sqlite3VdbeAddOp2(v, OP_NewRowid, csrWrite, regRowid);\n  sqlite3VdbeAddOp3(v, OP_Insert, csrWrite, regRecord, regRowid);\n  addrNe = sqlite3VdbeAddOp3(v, OP_Ne, pMWin->regOne, 0, regRowid);\n  VdbeCoverageNeverNull(v);\n\n  /* This block is run for the first row of each partition */\n  s.regArg = windowInitAccum(pParse, pMWin);\n\n  if( regStart ){\n    sqlite3ExprCode(pParse, pMWin->pStart, regStart);\n    windowCheckValue(pParse, regStart, 0 + (pMWin->eFrmType==TK_RANGE?3:0));\n  }\n  if( regEnd ){\n    sqlite3ExprCode(pParse, pMWin->pEnd, regEnd);\n    windowCheckValue(pParse, regEnd, 1 + (pMWin->eFrmType==TK_RANGE?3:0));\n  }\n\n  if( pMWin->eFrmType!=TK_RANGE && pMWin->eStart==pMWin->eEnd && regStart ){\n    int op = ((pMWin->eStart==TK_FOLLOWING) ? OP_Ge : OP_Le);\n    int addrGe = sqlite3VdbeAddOp3(v, op, regStart, 0, regEnd);\n    VdbeCoverageNeverNullIf(v, op==OP_Ge); /* NeverNull because bound <expr> */\n    VdbeCoverageNeverNullIf(v, op==OP_Le); /*   values previously checked */\n    windowAggFinal(&s, 0);\n    sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);\n    VdbeCoverageNeverTaken(v);\n    windowReturnOneRow(&s);\n    sqlite3VdbeAddOp1(v, OP_ResetSorter, s.current.csr);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, lblWhereEnd);\n    sqlite3VdbeJumpHere(v, addrGe);\n  }\n  if( pMWin->eStart==TK_FOLLOWING && pMWin->eFrmType!=TK_RANGE && regEnd ){\n    assert( pMWin->eEnd==TK_FOLLOWING );\n    sqlite3VdbeAddOp3(v, OP_Subtract, regStart, regEnd, regStart);\n  }\n\n  if( pMWin->eStart!=TK_UNBOUNDED ){\n    sqlite3VdbeAddOp2(v, OP_Rewind, s.start.csr, 1);\n    VdbeCoverageNeverTaken(v);\n  }\n  sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);\n  VdbeCoverageNeverTaken(v);\n  sqlite3VdbeAddOp2(v, OP_Rewind, s.end.csr, 1);\n  VdbeCoverageNeverTaken(v);\n  if( regPeer && pOrderBy ){\n    sqlite3VdbeAddOp3(v, OP_Copy, regNewPeer, regPeer, pOrderBy->nExpr-1);\n    sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.start.reg, pOrderBy->nExpr-1);\n    sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.current.reg, pOrderBy->nExpr-1);\n    sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.end.reg, pOrderBy->nExpr-1);\n  }\n\n  sqlite3VdbeAddOp2(v, OP_Goto, 0, lblWhereEnd);\n\n  sqlite3VdbeJumpHere(v, addrNe);\n\n  /* Beginning of the block executed for the second and subsequent rows. */\n  if( regPeer ){\n    windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer, lblWhereEnd);\n  }\n  if( pMWin->eStart==TK_FOLLOWING ){\n    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);\n    if( pMWin->eEnd!=TK_UNBOUNDED ){\n      if( pMWin->eFrmType==TK_RANGE ){\n        int lbl = sqlite3VdbeMakeLabel(pParse);\n        int addrNext = sqlite3VdbeCurrentAddr(v);\n        windowCodeRangeTest(&s, OP_Ge, s.current.csr, regEnd, s.end.csr, lbl);\n        windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n        windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);\n        sqlite3VdbeAddOp2(v, OP_Goto, 0, addrNext);\n        sqlite3VdbeResolveLabel(v, lbl);\n      }else{\n        windowCodeOp(&s, WINDOW_RETURN_ROW, regEnd, 0);\n        windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n      }\n    }\n  }else\n  if( pMWin->eEnd==TK_PRECEDING ){\n    int bRPS = (pMWin->eStart==TK_PRECEDING && pMWin->eFrmType==TK_RANGE);\n    windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);\n    if( bRPS ) windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n    windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);\n    if( !bRPS ) windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n  }else{\n    int addr = 0;\n    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);\n    if( pMWin->eEnd!=TK_UNBOUNDED ){\n      if( pMWin->eFrmType==TK_RANGE ){\n        int lbl = 0;\n        addr = sqlite3VdbeCurrentAddr(v);\n        if( regEnd ){\n          lbl = sqlite3VdbeMakeLabel(pParse);\n          windowCodeRangeTest(&s, OP_Ge, s.current.csr, regEnd, s.end.csr, lbl);\n        }\n        windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);\n        windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n        if( regEnd ){\n          sqlite3VdbeAddOp2(v, OP_Goto, 0, addr);\n          sqlite3VdbeResolveLabel(v, lbl);\n        }\n      }else{\n        if( regEnd ){\n          addr = sqlite3VdbeAddOp3(v, OP_IfPos, regEnd, 0, 1);\n          VdbeCoverage(v);\n        }\n        windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);\n        windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n        if( regEnd ) sqlite3VdbeJumpHere(v, addr);\n      }\n    }\n  }\n\n  /* End of the main input loop */\n  sqlite3VdbeResolveLabel(v, lblWhereEnd);\n  sqlite3WhereEnd(pWInfo);\n\n  /* Fall through */\n  if( pMWin->pPartition ){\n    addrInteger = sqlite3VdbeAddOp2(v, OP_Integer, 0, regFlushPart);\n    sqlite3VdbeJumpHere(v, addrGosubFlush);\n  }\n\n  addrEmpty = sqlite3VdbeAddOp1(v, OP_Rewind, csrWrite);\n  VdbeCoverage(v);\n  if( pMWin->eEnd==TK_PRECEDING ){\n    int bRPS = (pMWin->eStart==TK_PRECEDING && pMWin->eFrmType==TK_RANGE);\n    windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);\n    if( bRPS ) windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n    windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);\n  }else if( pMWin->eStart==TK_FOLLOWING ){\n    int addrStart;\n    int addrBreak1;\n    int addrBreak2;\n    int addrBreak3;\n    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);\n    if( pMWin->eFrmType==TK_RANGE ){\n      addrStart = sqlite3VdbeCurrentAddr(v);\n      addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 1);\n      addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);\n    }else\n    if( pMWin->eEnd==TK_UNBOUNDED ){\n      addrStart = sqlite3VdbeCurrentAddr(v);\n      addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, regStart, 1);\n      addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, 0, 1);\n    }else{\n      assert( pMWin->eEnd==TK_FOLLOWING );\n      addrStart = sqlite3VdbeCurrentAddr(v);\n      addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, regEnd, 1);\n      addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 1);\n    }\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);\n    sqlite3VdbeJumpHere(v, addrBreak2);\n    addrStart = sqlite3VdbeCurrentAddr(v);\n    addrBreak3 = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);\n    sqlite3VdbeJumpHere(v, addrBreak1);\n    sqlite3VdbeJumpHere(v, addrBreak3);\n  }else{\n    int addrBreak;\n    int addrStart;\n    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);\n    addrStart = sqlite3VdbeCurrentAddr(v);\n    addrBreak = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);\n    windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);\n    sqlite3VdbeJumpHere(v, addrBreak);\n  }\n  sqlite3VdbeJumpHere(v, addrEmpty);\n\n  sqlite3VdbeAddOp1(v, OP_ResetSorter, s.current.csr);\n  if( pMWin->pPartition ){\n    if( pMWin->regStartRowid ){\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regStartRowid);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, pMWin->regEndRowid);\n    }\n    sqlite3VdbeChangeP1(v, addrInteger, sqlite3VdbeCurrentAddr(v));\n    sqlite3VdbeAddOp1(v, OP_Return, regFlushPart);\n  }\n}\n\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n"], "filenames": ["manifest", "manifest.uuid", "src/expr.c", "src/vdbeaux.c", "src/window.c"], "buggy_code_start_loc": [1, 1, 378, 1306, 937], "buggy_code_end_loc": [1859, 2, 378, 1307, 1041], "fixing_code_start_loc": [1, 1, 379, 1306, 937], "fixing_code_end_loc": [1859, 2, 380, 1308, 1046], "type": "CWE-755", "message": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.", "other": {"cve": {"id": "CVE-2019-19924", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-24T16:15:11.370", "lastModified": "2022-04-15T16:18:37.353", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling."}, {"lang": "es", "value": "SQLite versi\u00f3n 3.30.1 maneja inapropiadamente cierta reescritura de \u00e1rbol de an\u00e1lisis, relacionada con los archivos expr.c, vdbeaux.c y window.c. Esto es causado por un manejo incorrecto de errores de la funci\u00f3n sqlite3WindowRewrite()."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sqlite:sqlite:3.30.1:*:*:*:*:*:*:*", "matchCriteriaId": "0175D7DA-13DD-44A4-91BB-77489F76C878"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:siemens:sinec_infrastructure_network_services:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1.1", "matchCriteriaId": "B0F46497-4AB0-49A7-9453-CC26837BF253"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:bookkeeper:4.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "FB293558-0DB0-4EEB-A91C-7B00A9FA634E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql_workbench:*:*:*:*:*:*:*:*", "versionEndIncluding": "8.0.19", "matchCriteriaId": "7B4DA1DD-9BC1-4D76-BB41-6E6D69838571"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}]}]}], "references": [{"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r58af02e294bd07f487e2c64ffc0a29b837db5600e33b6e698b9d696b@%3Cissues.bookkeeper.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf4c02775860db415b4955778a131c2795223f61cb8c6a450893651e4@%3Cissues.bookkeeper.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200114-0003/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4298-1/", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2020.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3"}}