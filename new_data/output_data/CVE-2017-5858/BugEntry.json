{"buggy_code": ["# Changelog\n\n## 2.0.5 (Unreleased)\n- #743, #751, #753 Update to Strophe 1.2.12. SASL-EXTERNAL now has reduced priority, so it won't\n  be prioritized above other auth mechanisms. [jcbrand]\n- #755: create composer.json to add this project in packagist.org [fabiomontefuscolo]\n- #758: Bugfix. Render all resize drag handles for ChatRoomView. [LeoYReyes]\n- Bugfix. Cancel button shown while registration form is being fetched wasn't working\n  properly. [jcbrand]\n- Bugfix. Login form wasn't rendered after logging out (when `auto_reconnect` is `true`). [jcbrand]\n- Bugfix. Properly disconnect upon \"host-unknown\" error. [jcbrand]\n- Bugfix. Minimized chats weren't removed when logging out. [jcbrand]\n\n## 2.0.4 (2016-12-13)\n- #737: Bugfix. Translations weren't being applied. [jcbrand]\n- Fetch room info and store it on the room model.\n  For context, see: http://xmpp.org/extensions/xep-0045.html#disco-roominfo [jcbrand]\n- Bugfix. Switching from bookmarks form to config form shows only the spinner. [jcbrand]\n- Bugfix. Other room occupants sometimes not shown when reloading the page. [jcbrand]\n- Bugfix. Due to changes in `converse-core` the controlbox wasn't aware anymore of\n  disconnection or reconnection events. [jcbrand]\n- Optimize fetching of MAM messages (in some cases happened on each page load). [jcbrand]\n- Fix empty controlbox toggle after disconnect. [jcbrand]\n- When inviting someone to a members-only room, first add them to the member\n  list. [jcbrand]\n- New configuration setting [muc_disable_moderator_commands](https://conversejs.org/docs/html/configuration.html#muc-disable-moderator-commands) [jcbrand]\n\n## 2.0.3 (2016-11-30)\n- #735 Room configuration button not visible. [jcbrand]\n- CSS fix for fadeIn animation. [jcbrand]\n\n## 2.0.2 (2016-11-30)\n- #721 keepalive not working with anonymous authentication [jcbrand]\n- #723 Bugfix: Arrays in configuration settings were ignored. [jcbrand]\n- #734 Bugfix. `converse.rooms.open` ignored the `muc_nickname_from_jid` setting. [jcbrand]\n- Enable new rooms to be configured automatically, with a default config, via `rooms.open`.\n  For details, refer to the [relevant documentation](https://conversejs.org/docs/html/developer_api.html#the-rooms-grouping) [jcbrand]\n- Bugfix: Chatboxes aren't closed when logging out. [jcbrand]\n- Bugfix: Trying to save data on the `ControlBox` model before `ChatBoxes`\n  collection has its `browserStorage` configured.\n  Causes `Error: A \"url\" property or function must be specified`. [jcbrand]\n- Don't open the controlbox on contact requests. [jcbrand]\n- Bugfix: Reconnection fails when original connection was never established. [jcbrand]\n- If a `credentials_url` is provided, then keep on attempting to reconnect when connection is down.  [jcbrand]\n- Remove (undocumented) `callback` config parameter for `converse.initialize`.\n  Instead, `converse.initialize` returns a promise which will resolve once\n  initialization is complete. [jcbrand]\n- New event ['reconnecting'](https://conversejs.org/docs/html/development.html#reconnecting) [jcbrand]\n- New configuration setting [allow_bookmarks](https://conversejs.org/docs/html/configuration.html#allow-bookmarks) [jcbrand]\n- The `rooms.open` API method will no longer maximize rooms that are minimized (unless `maximize: true` is passed in). [jcbrand]\n\n## 2.0.1 (2016-11-07)\n- #203 New configuration setting [muc_domain](https://conversejs.org/docs/html/configuration.html#muc-domain) [jcbrand]\n- #705 White content after submitting password on chatrooms [jcbrand]\n- #712 Controlbox clicks stop responding after auto-reconnect [jcbrand]\n- Removed shared state between tests. All tests are now isolated. [jcbrand]\n- Allow the context (i.e. `this` value) to be passed in when registering event\n  listeners with `converse.listen.on` and `converse.listen.once`. [jcbrand]\n- New event ['rosterContactsFetched'](https://conversejs.org/docs/html/development.html#rosterContactsFetched) [jcbrand]\n- New event ['rosterGroupsFetched'](https://conversejs.org/docs/html/development.html#rosterGroupsFetched) [jcbrand]\n- HTML templates are now loaded in the respective modules/plugins. [jcbrand]\n- Start improving Content-Security-Policy compatibility by removing inline CSS. [mathiasertl]\n- Add support for XEP-0048, chat room bookmarks [jcbrand]\n- New configuration setting [connection_options](https://conversejs.org/docs/html/configuration.html#connection-options) [jcbrand]\n\n## 2.0.0 (2016-09-16)\n- #656 Online users count not shown initially [amanzur]\n- #674 Polish translation updated [ser]\n- Backwards incompatible change: the `_super` attribute in plugins is now named `__super__`. [jcbrand]\n- Continuously attempt to resurrect dead connections when `auto_reconnect` is `true`. [jcbrand]\n- Update the 'rooms' API to allow user to pass in room attributes. [jcbrand]\n- New configuration setting [message_storage](https://conversejs.org/docs/html/configuration.html#message-storage) [jcbrand]\n- Hardcode the storage for roster contacts and chatroom occupants to `sessionStorage`. [jcbrand]\n- Fixed wrong chat state value, should be `chat`, not `chatty`.\n  See [RFC 3921](https://xmpp.org/rfcs/rfc3921.html#rfc.section.2.1.2.2). [jcbrand]\n- Adds support for SASL-EXTERNAL. [jcbrand]\n\n## 1.0.6 (2016-08-12)\n- #632 Offline and Logout states do not properly update once users start\n  chatting. [chrisuehlinger, jcband]\n- #674 Polish translation updated to the current master. [ser]\n- #677 Chatbox does not open after close. [jcbrand]\n- The behavior of `converse.chats.get` has changed. If the chat box is not\n  already open, then `undefined` will be returned. [jcbrand]\n- Typing (i.e. chat state) notifications are now also sent out from MUC rooms. [jcbrand]\n- `ChatRoomView.onChatRoomMessageSubmitted` has been renamed to\n  `onMessageSubmitted`, to make it the same as the method on `ChatBoxView`. [jcbrand]\n- New configuration setting [muc_nickname_from_jid](https://conversejs.org/docs/html/configuration.html#muc-nickname-from-jid) [jcbrand]\n- New configuration setting [muc_instant_rooms](https://conversejs.org/docs/html/configuration.html#muc-instant-rooms) [jcbrand]\n\n## 1.0.5 (2016-07-28)\n- In case of nickname conflict when joining a room, allow the user to choose a new one.\n  [jcbrand]\n- Check whether the user has a reserved nickname before entering a room, and if so,\n  use it. [jcbrand]\n- Mention someone in your chat room message by clicking on their name in the occupants\n  list. [jcbrand]\n- #645 When accepting a contact request, the contact didn't appear in the\n  pending contacts group. [jcbrand]\n- Bugfix: allow multiple MAM queries to be made simultaneously. [jcbrand]\n\n## 1.0.4 (2016-07-26)\n\n- Restrict occupants sidebar to 30% chatroom width. [jcbrand]\n- Made requesting contacts more visible, by placing them at the top of the roster. [jcbrand]\n- `insertIntoPage` method of `ChatBoxView` has been renamed to `insertIntoDOM`,\n  to make it the same as the method of `ChatRoomView`. [jcbrand]\n- Render error messages received from the server (for undelivered chat messages). [jcbrand]\n- Don't hide requesting contacts when filtering by chat state. [jcbrand]\n- When logging in anonymously, the server JID can now be passed in via `converse.initialize`\n  or via `converse.user.login`. [jcbrand]\n\n## 1.0.3 (2016-06-20)\n\n- Update the plugin architecture to allow plugins to have optional dependencies [jcbrand]\n- Bugfix. Login form doesn't render after logging out, when `auto_reconnect = false` [jcbrand]\n- Also indicate new day for the first day's messages. [jcbrand]\n- Chat bot messages don't appear when they have the same ids as their commands. [jcbrand]\n- Updated onDisconnected method to fire disconnected event even if `auto_reconnect = false`. [kamranzafar]\n- Bugfix: MAM messages weren't being fetched oldest first. [jcbrand]\n- Add processing hints to chat state notifications [jcbrand]\n- Don't use sound and desktop notifications for OTR messages (when setting up the session) [jcbrand]\n- New config option [default_state](https://conversejs.org/docs/html/configuration.html#default_state) [jcbrand]\n- New API method `converse.rooms.close()` [jcbrand]\n- New configuration setting [allow_muc_invites](https://conversejs.org/docs/html/configuration.html#allow-muc-invites) [jcbrand]\n- Add new event [pluginsInitialized](https://conversejs.org/docs/html/development.html#pluginsInitialized) [jcbrand]\n- #553 Add processing hints to OTR messages [jcbrand]\n- #650 Don't ignore incoming messages with same JID as current user (might be MAM archived) [jcbrand]\n- #656 online users count in minimized chat window on initialization corrected [amanzur]\n\n## 1.0.2 (2016-05-24)\n\n- Bugfix. Bind `sendPresence` to the right context. Bug that slipped in during\n  the release of `1.0.1`. [jcbrand]\n\n## 1.0.1 (2016-05-24)\n\n- Bugfix. Roster filter sometimes gets hidden when it shouldn't. [jcbrand]\n- Chat boxes weren't being initialized due to typo. [jcbrand]\n- Flush request queue just after connection. Solves a problem with PubSub and\n  Prosody, whereby BOSH HTTP responses weren't being received. [jcbrand]\n\n## 1.0.0 (2016-05-03)\n\n- Add catalan language [JoseMariaRubioMoral]\n- Split converse.js up into different plugin modules. [jcbrand]\n- Better Sass/CSS for responsive/mobile views. New mobile-only build. [jcbrand]\n- Roster contacts can now be filtered by chat state and roster filters are\n  remembered across page loads. [jcbrand]\n- Add support for messages with type `headline`, often used for notifications\n  from the server. [jcbrand]\n- Add stanza-specific event listener `converse.listen.stanza`.\n  As a result `converse.listen.on('message');` has been deprecated, use\n  `converse.stanza.on('message');` instead. [jcbrand]\n- Emit an event `chatBoxInitialized` once a chat box's initialize method has been called. [jcbrand]\n- Emit an event `statusInitialized` once the user's own status has been initialized upon startup. [jcbrand]\n- New config option [chatstate_notification_blacklist](https://conversejs.org/docs/html/configuration.html#chatstate-notification-blacklist) [jcbrand]\n- New config option [sticky_controlbox](https://conversejs.org/docs/html/configuration.html#sticky-controlbox) [jcbrand]\n- New config option [credentials_url](https://conversejs.org/docs/html/configuration.html#credentials-url) [jcbrand]\n- Don't play sound notifications for OTR messages which are setting up an\n  encrypted session. [jcbrand]\n- Bugfix: RID, SID and JID tokens ignored when `keepalive` set to `true`. [jcbrand]\n- Removed the `account.logout` API, instead use `user.logout`. [jcbrand]\n- Use `rel=noopener` with links that contain `target=_blank` to prevent potential\n  phishing attacks. [More info here](https://mathiasbynens.github.io/rel-noopener/)\n  [jcbrand]\n- #156 Add the option `auto_join_rooms` which allows you to automatically\n  connect to certain rooms once logged in. [jcbrand]\n- #261 `show_controlbox_by_default` config not working [diditopher]\n- #443 HTML5 notifications of received messages [jcbrand]\n- #534 Updated Russian translation [badfiles]\n- #566 Do not steal the focus when the chatbox opens automatically [rlanvin]\n- #573 xgettext build error: `'javascript' unknown` [jcbrand]\n- #577 New config variable [message_archiving_timeout](https://conversejs.org/docs/html/configuration.html#message-archiving-timeout) [jcbrand]\n- #587 Fix issue when logging out with `auto_logout=true` [davec82]\n- #589 Save scroll position on minimize and restore it on maximize [rlanvin]\n- #592 Add random resource for `auto_login`, add method generateResource to\n  generate random resource [davec82]\n- #598 Add option `synchronize_availability` [davec82]\n- #600 Fix change xmpp status also on icon-status click [davec82]\n- #616 converse-otr should depend on converse-minimize  [jcbrand]\n- #609 Remove split of fullname [lixmal]\n\n## 0.10.1 (2016-02-06)\n\n- #352 When the user has manually scrolled up in a chat window, don't scroll\n  down on chat event notifications. [jcbrand]\n- #524 Added [auto_join_on_invite](https://conversejs.org/docs/html/configuration.html#auto_join_on_invite)\n  parameter for automatically joining chatrooms. [ben]\n- #520 Set specific domain. Two new options [default_domain](https://conversejs.org/docs/html/configuration.html#default_domain)\n  and [locked_domain](https://conversejs.org/docs/html/configuration.html#locked_domain). [jcbrand]\n- #521 Not sending presence when connecting after disconnection. [jcbrand]\n- #535 Messages not received when room with mixed-case JID is used. [jcbrand]\n- #536 Presence not sent out (in cases where it should) after page refresh. [jcbrand]\n- #540 `bind is not a function` error for plugins without `initialize` method. [jcbrand]\n- #547 By default the `offline` state is no longer choosable.\n  See [include_offline_state](https://conversejs.org/docs/html/configuration.html#include-offline-state) for details. [jcbrand]\n- A chatroom invite might come from someone not in your roster list. [ben]\n- #487 Empty the resources array when the resource is null [rlanvin]\n- #534 Updated Russian translation [LaconicTranslator]\n- #555 The status restored from sessionStorage is never updated [jcbrand]\n- #559 Remove reconnection timer once connected succesfully [m0cs]\n\n## 0.10.0 (2015-11-05)\n\n**Note:**\n*This release drops CSS support for IE8 and IE9.*\n\n- #459 Wrong datatype passed to converse.chatboxes.getChatBox. [hobblegobber, jcbrand]\n- #493 Roster push fix [jcbrand]\n- #403 emit an event `rosterPush` when a roster push happens [teseo]\n- #502. Chat room not opened in non_amd version. [rjanbiah]\n- #505 Typo caused [object Object] in room info [gromiak]\n- #508 \"Is typing\" doesn't automatically disappear [jcbrand]\n- #509 Updated Polish translations [ser]\n- #510 MUC room memberlist is being cleared with page reload when keepalive option is set. [jcbrand]\n- Add the ability to also drag-resize chat boxes horizontally. [jcbrand]\n- Updated Sass files and created a new style. [jcbrand]\n\n\n## 0.9.6 (2015-10-12)\n\n- Bugfix. Spinner doesn't disappear when scrolling up (when server doesn't support XEP-0313). [jcbrand]\n- #462 Fix MUC rooms with names containing special characters not working [1st8]\n- #467 Fix outgoing chat messages not having a msgid when being put into sessionStorage [1st8]\n- #468 Fix [object Object] being sometimes shown as status [1st8]\n- #472 Fix \"Cannot read property 'splitOnce' of undefined\" when typing /clear in a chat room. [jcbrand]\n- #493 Roster wasn't being updated after a Roster push update [teseo, jcbrand]\n- #496 Bugfix. Pings weren't being sent out. [teseo, jcbrand]\n- #499 Message not received due to non-unique message ids. [jcbrand]\n\n## 0.9.5 (2015-08-24)\n\n- #306 XEP-0313: Message Archive Management [jcbrand]\n- #439 auto_login and keepalive not working [jcbrand]\n- #440 null added as resource to contact [jcbrand]\n- Add new event serviceDiscovered [jcbrand]\n- Add a new configuration setting [muc_history_max_stanzas](https://conversejs.org/docs/html/configuration.html#muc-history-max-stanzas>). [jcbrand]\n\n## 0.9.4 (2015-07-04)\n\n- #144 Add Ping functionality and Pong handler [thierrytiti]\n- #234, #431 Messages aren't received when the user logs in with a mixed-case JID. [jcbrand]\n- #367 API methods for changing chat status (online, busy, away etc.) and status message [jcbrand]\n- #389 Allow login panel placeholders and roster item 'Name' translations. [gbonvehi]\n- #394 Option to allow chatting with pending contacts [thierrytiti]\n- #396 Add automatic Away mode and XEP-0352 support [thierrytiti]\n- #400, #410 Allow offline pretty status and placeholder for \"Insert a smiley\" to be translated [thierrytiti]\n- #401 Updated French translation [thierrytiti]\n- #404 CSS fix: position and width of the div #conversejs [thierrytiti]\n- #407 CSS: Fonts Path: editabable $font-path via sass/variables.scss [thierrytiti]\n- #408 MUC: missing toggle call handler and updated documentation about call [thierrytiti]\n- #413 Auto-detect user's locale to show date and time in the right format [thierrytiti]\n- #415 closeAllChatBoxes is giving ReferenceError when 2 chats are open [nevcos, jcbrand]\n- #416 Add icon for XA status [thierrytiti]\n- #418 Logging out with `auto_reconnect=true` causes reconnection retries [jcbrand]\n- #420 Updated German translation [1st8]\n- #427 Converse.js does not subscribe back to a contact not in the roster. [emmanuel-florent]\n- Add offline pretty status to enable translation [thierrytiti]\n- Bugfix. ClearSessions during unload event would throw an error when not logged in. [gbonvehi]\n- Bugfix. Manual login doesn't work when only websocket_url is set and not bosh_service_url. [jcbrand]\n- Bugfix. Wrong callback argument mapping in XmppStatus initialize: fullname is null [thierrytiti]\n- CSS fix: room-info bug on hover after room description loaded [thierrytiti]\n- CSS: Fonts Path: editabable $font-path via sass/variables.scss [thierrytiti]\n- Chat boxes returned by the API now have an `is_chatroom` attribute [jcbrand]\n- Decouple automatic away and XEP-0352 support. [jcbrand]\n- Don't carbon copy OTR messages. [jcbrand]\n- I18N: Autodetection of User Locale if no i18n setting is set. [thierrytiti]\n- Refactored in order to remove the strophe.roster.js dependency. [jcbrand]\n- Refactored the plugin architecture. Add `overrides` convention for\n  automatically overriding converse.js's methods and Backbone views and models. [jcbrand]\n- With keepalive, don't send out a presence stanza on each page load [jcbrand]\n\n## 0.9.3 (2015-05-01)\n\n- Add the ability to log in automatically. [jcbrand]\n- Remove `type=email` from JID field in login form. Resulting validation error confuses people. [jcbrand]\n- Add Ukranian translations [Andriy Kopystyansky]\n- #244 Add the ability to log in anonymously. [jcbrand]\n- #344 Enable the path to the sound files to be configured [thierrytiti and jcbrand]\n- #370 Unable to register a new user to ejabberd 2.1.11. [gbonvehi]\n- #372 Some offline users have a visible empty `<dd>` in the roster. [floriancargoet]\n- #374 Fix collapsed group visibility on page load. [floriancargoet]\n- #378 Expect full JIDs to be returned via XHR user search [thierrytiti]\n- #379 Updated French translations [thierrytiti]\n- #379 Fix for bower not finding crypto-js-evanvosberg#3.1.2-5 any more. [jcbrand]\n\n## 0.9.2 (2015-04-09)\n\n- Bugfix. Prevent attaching twice during initialization. [jcbrand]\n- API method chats.get can now also return chat boxes which haven't been opened yet. [jcbrand]\n- Add API method contacts.add. [pzia]\n- #356 Fix the plugin extend function. [floriancargoet]\n- #357 Fix the known bug where a state notification reopens a chat box. [floriancargoet]\n- #358 Bugfix. Chat rooms show the same occupants bug. [floriancargoet]\n- #359 Fix a timeout bug in chat state notifications. [floriancargoet]\n- #360 Incorrect roster height when `allow_contact_requests=true`. [floriancargoet, jcbrand]\n- #362 Add API for retrieving and opening rooms. [pzia]\n- #364 Text selection in chat boxes not shown in Firefox. [jcbrand]\n\n## 0.9.1 (2015-03-26)\n\n- Set the JID input field in the login form to `type=email`. [chatme]\n- New configuration setting [allow_contact_removal](https://conversejs.org/docs/html/configuration.html#allow-contact-removal) [jcbrand]\n- Document that event handlers receive 'event' obj as first arg. [jcbrand]\n- Add a test to check that notifications are played in chat rooms. [jcbrand]\n- #333 Enable automatic reconnection when `prebind` and `prebind_url` are specified. [jcbrand]\n- #339 Require the JID to be specified when using `keepalive` with `prebind`. Also add a logout API method. [jcbrand]\n- #349 Indicate visitors in chat rooms. [c143]\n\n## 0.9.0 (2015-03-06)\n\n- #204 Support websocket connections. [jcbrand]\n- #252, 253 Add fullname and jid to contact's tooltip in roster. [gbonvehi]\n- #292 Better support for XEP-0085 Chat State Notifications. [jcbrand]\n- #295 Document \"allow_registration\". [gbonvehi]\n- #304 Added Polish translations. [ser]\n- #305 presence/show text in XMPP request isn't allowed by specification. [gbonvehi]\n- Add new API method `chats.open` to open chat boxes. [jcbrand]\n- Add new API method to set and get configuration settings. [jcbrand]\n- Add responsiveness to CSS. We now use Sass preprocessor for generating CSS. [jcbrand]\n- Bugfix. Custom status message form doesn't submit/disappear. [jcbrand]\n- Calling the API method `contacts.get()` without parameters now returns all contacts. [jcbrand]\n- Don't send out the message carbons IQ stanza on each page load. [jcbrand]\n- New Makefile.win to build in Windows environments. [gbonvehi]\n- Norwegian Bokm\u00e5l translations. [Andreas Lorentsen]\n- Removed deprecated API methods. [jcbrand]\n- Strophe.log and Strophe.error now uses converse.log to output messages. [gbonvehi]\n- The API method `chats.get` now only returns already opened chat boxes. [jcbrand]\n- Updated Afrikaans translations. [jcbrand]\n- Add new configuration setting [prebind_url](https://conversejs.org/docs/html/configuration.html#prebind-url) [jcbrand]\n\n## 0.8.6 (2014-12-07)\n\n- Bugfix. Login panel didn't appear under certain conditions. [jcbrand]\n- Bugfix. Error when trying to render chat room configuration form. [jcbrand]\n- Text on the registration form was not configurable or i18n aware. [jcbrand]\n- #285 With prebind the jid, rid and sid settings were ignored. [jcbrand]\n\n## 0.8.5 (2014-12-01)\n\n- #117 JIDs or nicknames not shown in chat rooms. [jcbrand]\n- #282 XEP-0077 In-band registration. [jcbrand]\n\n## 0.8.4 (2014-11-15)\n\n**note:**\n*Certain API methods have been deprecated in favor of a new API and will be removed in the 0.9.0 release.*\n\n- Bugfix. Error when trying to use prebind and keepalive together. [heban and jcbrand]\n- Bugfix. Cannot read property \"top\" of undefined. [jcbrand]\n- Add new event, noResumeableSession, for when keepalive=true and there aren't\n  any prebind session tokens. [jcbrand]\n- #46 Refactor the API and add new methods. [jcbrand]\n- #151 Browser locks/freezes with many roster users. [jcbrand]\n- #177 Setting status to offline does nothing. [jcbrand]\n- #232 Always get full name from model. [jcbrand]\n- #237 Unable to create room when `hide_muc_server` is `true`. [jcbrand]\n- #238 Rooms are not shown when `hide_offline_users` is `true`. [jcbrand]\n- #251 Non-minified builds for debugging. [jcbrand]\n- #260 Sent message carbons are not displayed. [jcbrand]\n- #262 Contact requests are not shown if page is reloaded. [jcbrand]\n- #264 Remove unnecessary commas for ie8 compatibility. [Deuteu]\n- #267 Unread messages counter wrongly gets incremented by chat state notifications. [Deuteu]\n- #274 Roster filtering results change with presence changes. [jcbrand]\n- #275 Custom status message doesn't reset. [jcbrand]\n- #278 Unread messages counter doesn't unbind it's events. [Deuteu]\n- #279 Handle more field types for MUC config forms. [gbonvehi]\n- #280 New config option, `hide_offline_users` [gbonvehi]\n\n## 0.8.3 (2014-09-22)\n\n- The Javascript build files in the 0.8.2 release weren't updated due to a\n  unnoticed build error. [jcbrand]\n\n## 0.8.2 (2014-09-22)\n\n- Converse.js now has the ability to maintain sessions across page loads.\n  Previously, the session tokens had to be handled externally and passed in.\n  See the [keepalive](https://conversejs.org/docs/html/configuration.html#keepalive) configuration setting. [jcbrand]\n- Allow changing of nickname in a chat room via /nick command. [jcbrand]\n- Allow a chat room user to be muted or unmuted with the /mute and /voice commands. [jcbrand]\n- Add a chat room toolbar button for toggling the list of occupants. [jcbrand]\n- Converse.js now responds to XEP-0030: Service Discovery requests. [jcbrand]\n- Bugfix. Roster groups all appear offline after page reload (with prebind).\n  See http://librelist.com/browser//conversejs/2014/8/26/problem-with-contact-list-everyone-is-offline/ [heban and jcbrand]\n- Bugfix concerning trimmed chats. Chats were being trimmed even though there was enough room. [jcbrand]\n- #62 Sound notifications will now also play when you are mentioned in a chat room. [jcbrand]\n- #212 Bugfix. Groups weren't being show again after the live filter was cleared. [jcbrand]\n- #215 (and also #75) XEP-0249: Direct MUC Invitations. [jcbrand]\n- #216 Contacts tab empty when using xhr_user_search. [hcderaad and jcbrand]\n- #219 New contacts added need page refresh to be accepted and become visible. [hcderaad and jcbrand]\n- #220 Non-AMD example page was not working. [xavier83ar and jcbrand]\n- #222 Control box state not remembered. [priyadi and jcbrand]\n- #223 Provide API to query buddy status. [priyadi and jcbrand]\n- #227 Updated Hebrew translations [GreenLunar]\n\n## 0.8.1 (2014-08-23)\n\n- Bugfix: Roster contacts' cache key too vague. [jcbrand]\n- Bugfix: Roster contacts weren't properly sorted according to chat status. [jcbrand]\n- #63 Support for sound notification when message is received. [jcbrand]\n- #212 Provide a live filter of the roster contacts. [jcbrand]\n\n## 0.8.0 (2014-08-04)\n\n**note**:\n    1. Converse.js is now relicensed under the [Mozilla Public License](http://www.mozilla.org/MPL/2.0/).\n    2. Configuration options for the chat toolbar have changed. Please refer to the [relevant documentation](http://devbox:8890/docs/html/configuration.html#visible-toolbar-buttons).\n    3. This release has reduced support for IE8 (some features won't work).\n    4. Events have been renamed to remove \"on\" prefix (sorry for any inconvenience).\n\n- No initial HTML markup is now needed in the document body for converse.js to work. [jcbrand]\n- All date handling is now done with moment.js. [jcbrand]\n- Add a new toolbar button for clearing chat messages. [jcbrand]\n- Chat boxes and rooms can now be resized vertically. [jcbrand]\n- Upgraded dependencies to their latest versions. [jcbrand]\n- Add new configuration setting [forwarded_messages](https://conversejs.org/docs/html/configuration.html#forwarded-messages).\n  Message forwarding was before a default behavior but is now optional (and disabled by default). [jcbrand]\n- Newly opened chat boxes always appear immediately left of the controlbox. [jcbrand]\n- #71 Chat boxes and rooms can be minimized. [jcbrand]\n- #83 Roster contacts can be shown according to their groups. [jcbrand]\n    Note: Converse.js can show users under groups if you have assigned them\n    already via another client or server configuration. There is not yet a way\n    to assign contacts to groups from within converse.js itself.\n- #123 Show converse.js in the resource assigned to a user. [jcbrand]\n- #130 Fixed bootstrap conflicts. [jcbrand]\n- #132 Support for [XEP-0280: Message Carbons](https://xmpp.org/extensions/xep-0280.html).\n    Configured via [message_carbons](https://conversejs.org/docs/html/configuration.html#message-carbons) [hejazee]\n- #176 Add support for caching in sessionStorage as opposed to localStorage. [jcbrand]\n- #180 RID and SID undefined [g8g3]\n- #191 No messages history [heban]\n- #192 Error: xhr_user_search_url is not defined. [jcbrand]\n- #195 Chinese translations. [lancelothuxi]\n- #196 [Safari v7.0.5] TypeError: Attempted to assign to readonly property. [g8g3]\n- #199 Improved Spanish translations [chilicuil]\n- #201 Add zh-locale to fix build task [schoetty]\n\n## 0.7.4 (2014-03-05)\n\n**note:**\n*This release contains an important security fix. Thanks to Renaud Dubourguais from [Synacktiv](http://synacktiv.com) for reporting the vulnerability.*\n\n- #125 Bugfix: crypto dependencies loaded in wrong order [jcbrand]\n- Bugfix: action messages (i.e. /me) didn't work in OTR mode. [jcbrand]\n- Security fix: Ensure that message URLs are properly encoded. [jcbrand]\n\n## 0.7.3 (2014-02-23)\n\n- #93 Add API methods exposing the RID and SID values. Can be disabled. [jcbrand]\n- #102 Option to enable OTR by default. [Aupajo]\n- #103 Option to display a call button in the chatbox toolbar, to allow third-party libraries to provide a calling feature. [Aupajo]\n- #108 Japanese Translations [mako09]\n- #111 OTR not working when using converse.js with prebinding. [jseidl, jcbrand]\n- #114, #124 Hewbrew Translations [GreenLunar]\n- #115 Indonesian Translations [priyadi]\n\n## 0.7.2 (2013-12-18)\n\n**note**\n*This release contains an important security fix. Thanks to hejsan for reporting the vulnerability.*\n\n- #48 Add event emitter support and emit events. [jcbrand]\n- #97 Wrong number of online contacts shown with config option `show_only_online_users`. [jcbrand]\n- #100 Make the fetching of vCards optional (enabled by default). [jcbrand]\n- Sanitize message text to avoid Javascript injection attacks.  [jcbrand]\n\n## 0.7.1 (2013-11-17)\n\n- Don't load OTR crypto if the browser doesn't have a CSRNG [jcbrand]\n- Don't break when crypto libraries aren't defined. [jcbrand]\n- Check if canvas is supported before trying to render the user avatar [jcbrand]\n- Use newest strophe.muc plugin. Fixes #85 [jcbrand]\n\n**note:**\nIf you are using the development libraries, you'll need to run ``bower update``\nto fetch the newest strophe.muc.plugin (for bugfix of #85).\n\nThis release contains 3 different builds:\n- converse.min.js\n- converse-no-otr.min.js (Without OTR encryption)\n- converse-no-locales-no-otr.min.js (Without OTR encryption or any translations)\n\n## 0.7.0 (2013-11-13)\n\n### Important:\n\nThis release includes support for [Off-the-record encryption](https://otr.cypherpunks.ca).\nFor this to work, your browser needs a CSPRNG (Cryptographically secure pseudorandom number generator).\n\nInternet Explorer of all versions doesn't have one at all, neither does older versions of Firefox.\n\nIf you need to support older browsers, please download the latest release from the 0.6 bran\n\n#### Features:\n\n- Add a toolbar to the chat boxes [jcbrand]\n- Add support for OTR (off-the-record) encryption [jcbrand]\n- Add support for smileys [jcbrand]\n- Simplified boilerplate markup [jcbrand]\n- New configuration settings, `xhr_custom_status_url` and `xhr_user_search_url` [jcbrand]\n\n**note:**\n*This release introduces a backward incompatible change. The boilerplate\nHTML needed in your webpage for converse.js to work has been reduced to a\nsingle div: `<div id=\"conversejs\"></div>`*\n\n#### Bugfixes:\n\n- #58 Contact's name gets replaced with their JID [jcbrand]\n- #81 Requesting contacts appear as pending contacts [jcbrand]\n\n## 0.6.6 (2013-10-16)\n\n- Bugfix: Presence stanza must be sent out after roster has been initialized [jcbrand]\n- Bugfix: Don't reconnect while still disconnecting, causes endless authentication loops. [jcbrand]\n- Dutch translation [maartenkling]\n\n## 0.6.5 (2013-10-08)\n\n- Fetch vCards asynchronously once a roster contact is added [jcbrand]\n- Hungarian translation [w3host]\n- Russian translation [bkocherov]\n- Update CSS to avoid clash with bootstrap [seocam]\n- New config option `allow_muc` toggles multi-user chat (MUC) [jcbrand]\n- New config option `allow_contact_requests` toggles user adding [jcbrand]\n- New config option `show_only_online_users` [jcbrand]\n\n## 0.6.4 (2013-09-15)\n\n- Add icon for the unavailable chat state. [jcbrand]\n- Chat state descriptions weren't translation aware. [jcbrand]\n- Clear messages from localStorage when user types \"/clear\". [jcbrand]\n- The 'xa' chat state wasn't being handled properly. [jcbrand]\n- Updated pt-BR translations [seocam]\n- Updated af and de translations [jcbrand]\n\n## 0.6.3 (2013-09-12)\n\n*NB: This release contains an important security fix. Please don't use older\nversions of the 0.6 branch.*\n\n- French translations. [tdesvenain]\n- Bugfix: Messages were stored against buddy JID and not own JID. [jcbrand]\n\n## 0.6.2 (2013-08-29)\n\n- Bugfix. The remove icon wasn't appearing in the contacts roster. [jcbrand]\n- Bugfix. With auto_subscribe=True, the \"Pending Contacts\" header didn't disappear\n  after a new user was accepted. [jcbrand]\n\n## 0.6.1 (2013-08-28)\n\n- IE9 and IE8 CSS fixes. [jcbrand]\n- Bugfix: Pencil icon not visible (for setting status update). [jcbrand]\n- Bugfix: RID, JID and SID initialization values were being ignored. [jcbrand]\n- Bugfix: Fall back to English if a non-existing locale was specified. [jcbrand]\n\n## 0.6.0 (2013-08-26)\n\n- #39 Documentation for minifying JS is wrong. [jcbrand]\n- #41 prebind and show_controlbox_by_default true fails. [jcbrand]\n- With prebinding, attaching to the connection now happens inside Converse and\n  not as a separate step after initialization. [jcbrand]\n- Register presence and message handlers before fetching the roster. Otherwise\n  some presence notifications might be missed. [jcbrand]\n- Add a debug option (logs to the browser console). [jcbrand]\n- Use font icons from http://icomoon.io [jcbrand]\n- Added a static mockup to aid CSS/design process. [jcbrand]\n- Save language codes with hyphens. Thanks to @seocam. [jcbrand]\n- The combined and minified JS file now uses almond and not require.js. [jcbrand]\n\n## 0.5.2 (2013-08-05)\n\n- Important security update. Don't expose the Strophe connection object globally. [jcbrand]\n\n## 0.5.1 (2013-08-04)\n\n- #13, #14: Messages sent between to GTalk accounts weren't being received. [jcbrand]\n- #32: Default status was offline when user didn't have contacts. [jcbrand]\n- Attach panels to the DOM upon initialize. [jcbrand]\n\n## 0.5.0 (2013-07-30)\n\n- #09 Remove dependency on AMD/require.js [jcbrand]\n- #22 Fixed compare operator in strophe.muc [sonata82]\n- #23 Add Italian translations [ctrlaltca]\n- #24 Add Spanish translations [macagua]\n- #25 Using span with css instead of img [matheus-morfi]\n- #26 Only the first minute digit shown in chatbox. [jcbrand]\n- #28 Add Brazilian Portuguese translations [matheus-morfi]\n- Use Bower to manage 3rd party dependencies. [jcbrand]\n\n## 0.4.0 (2013-06-03)\n\n- CSS tweaks: fixed overflowing text in status message and chatrooms list. [jcbrand]\n- Bugfix: Couldn't join chatroom when clicking from a list of rooms. [jcbrand]\n- Add better support for kicking or banning users from chatrooms. [jcbrand]\n- Fixed alignment of chat messages in Firefox. [jcbrand]\n- More intelligent fetching of vCards. [jcbrand]\n- Fixed a race condition bug. Make sure that the roster is populated before sending initial presence. [jcbrand]\n- Reconnect automatically when the connection drops. [jcbrand]\n- Add support for internationalization. [jcbrand]\n\n## 0.3.0 (2013-05-21)\n\n- Add vCard support [jcbrand]\n- Remember custom status messages upon reload. [jcbrand]\n- Remove jquery-ui dependency. [jcbrand]\n- Use backbone.localStorage to store the contacts roster, open chatboxes and chat messages. [jcbrand]\n- Fixed user status handling, which wasn't 100% according to the spec. [jcbrand]\n- Separate messages according to day in chats. [jcbrand]\n- Add support for specifying the BOSH bind URL as configuration setting. [jcbrand]\n- #8 Improve the message counter to only increment when the window is not focused [witekdev]\n- Make fetching of list of chatrooms on a server a configuration option. [jcbrand]\n- Use service discovery to show all available features on a room. [jcbrand]\n- Multi-user chatrooms are now configurable. [jcbrand]\n\n## 0.2.0 (2013-03-28)\n\n- Performance enhancements and general script cleanup [ichim-david]\n- Add \"Connecting to chat...\" info [alecghica]\n- Various smaller improvements and bugfixes [jcbrand]\n\n## 0.1.0 (2012-06-12)\n\n- Created [jcbrand]\n", "(function (root, factory) {\n    define([\n        \"utils\",\n        \"converse-api\",\n        \"mock\",\n        \"test_utils\"\n        ], factory);\n} (this, function (utils, converse_api, mock, test_utils) {\n    \"use strict\";\n    var _ = converse_api.env._;\n    var $ = converse_api.env.jQuery;\n    var $msg = converse_api.env.$msg;\n    var Strophe = converse_api.env.Strophe;\n    var moment = converse_api.env.moment;\n\n    return describe(\"Chatboxes\", function() {\n        describe(\"A Chatbox\", function () {\n            afterEach(function () {\n                converse_api.user.logout();\n                converse_api.listen.not();\n                test_utils.clearBrowserStorage();\n            });\n\n            it(\"is created when you click on a roster item\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                var i, $el, jid, chatboxview;\n                // openControlBox was called earlier, so the controlbox is\n                // visible, but no other chat boxes have been created.\n                expect(converse.chatboxes.length).toEqual(1);\n                spyOn(converse.chatboxviews, 'trimChats');\n                expect($(\"#conversejs .chatbox\").length).toBe(1); // Controlbox is open\n\n                var online_contacts = converse.rosterview.$el.find('dt.roster-group').siblings('dd.current-xmpp-contact').find('a.open-chat');\n                for (i=0; i<online_contacts.length; i++) {\n                    $el = $(online_contacts[i]);\n                    jid = $el.text().replace(/ /g,'.').toLowerCase() + '@localhost';\n                    $el.click();\n                    chatboxview = converse.chatboxviews.get(jid);\n                    expect(converse.chatboxes.length).toEqual(i+2);\n                    expect(converse.chatboxviews.trimChats).toHaveBeenCalled();\n                    // Check that new chat boxes are created to the left of the\n                    // controlbox (but to the right of all existing chat boxes)\n                    expect($(\"#conversejs .chatbox\").length).toBe(i+2);\n                    expect($(\"#conversejs .chatbox\")[1].id).toBe(chatboxview.model.get('box_id'));\n                }\n            }));\n\n            it(\"can be trimmed to conserve space\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                var i, $el, jid, chatbox, chatboxview, trimmedview;\n                // openControlBox was called earlier, so the controlbox is\n                // visible, but no other chat boxes have been created.\n                var trimmed_chatboxes = converse.minimized_chats;\n                expect(converse.chatboxes.length).toEqual(1);\n                spyOn(converse.chatboxviews, 'trimChats');\n                spyOn(trimmed_chatboxes, 'addChat').andCallThrough();\n                spyOn(trimmed_chatboxes, 'removeChat').andCallThrough();\n                expect($(\"#conversejs .chatbox\").length).toBe(1); // Controlbox is open\n\n                // Test that they can be trimmed\n                runs(function () {\n                    converse.rosterview.update(); // XXX: Hack to make sure $roster element is attaced.\n                });\n                waits(50);\n                runs(function () {\n                    // Test that they can be maximized again\n                    var online_contacts = converse.rosterview.$el.find('dt.roster-group').siblings('dd.current-xmpp-contact').find('a.open-chat');\n                    for (i=0; i<online_contacts.length; i++) {\n                        $el = $(online_contacts[i]);\n                        jid = $el.text().replace(/ /g,'.').toLowerCase() + '@localhost';\n                        $el.click();\n                        expect(converse.chatboxviews.trimChats).toHaveBeenCalled();\n\n                        chatboxview = converse.chatboxviews.get(jid);\n                        spyOn(chatboxview, 'minimize').andCallThrough();\n                        chatboxview.model.set({'minimized': true});\n                        expect(trimmed_chatboxes.addChat).toHaveBeenCalled();\n                        expect(chatboxview.minimize).toHaveBeenCalled();\n                        trimmedview = trimmed_chatboxes.get(jid);\n                    }\n                    var key = converse.chatboxviews.keys()[1];\n                    trimmedview = trimmed_chatboxes.get(key);\n                    chatbox = trimmedview.model;\n                    spyOn(chatbox, 'maximize').andCallThrough();\n                    spyOn(trimmedview, 'restore').andCallThrough();\n                    trimmedview.delegateEvents();\n                    trimmedview.$(\"a.restore-chat\").click();\n                });\n                waits(250);\n                runs(function () {\n                    expect(trimmedview.restore).toHaveBeenCalled();\n                    expect(chatbox.maximize).toHaveBeenCalled();\n                    expect(converse.chatboxviews.trimChats).toHaveBeenCalled();\n                });\n            }));\n\n            it(\"is focused if its already open and you click on its corresponding roster item\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost';\n                var $el, jid, chatboxview, chatbox;\n                // openControlBox was called earlier, so the controlbox is\n                // visible, but no other chat boxes have been created.\n                expect(converse.chatboxes.length).toEqual(1);\n                chatbox = test_utils.openChatBoxFor(converse, contact_jid);\n                chatboxview = converse.chatboxviews.get(contact_jid);\n                spyOn(chatboxview, 'focus');\n                // Test that they can be trimmed\n                runs(function () {\n                    converse.rosterview.update(); // XXX: Hack to make sure $roster element is attaced.\n                });\n                waits(300); // ChatBox.show() is debounced for 250ms\n                runs(function () {\n                    $el = converse.rosterview.$el.find('a.open-chat:contains(\"'+chatbox.get('fullname')+'\")');\n                    jid = $el.text().replace(/ /g,'.').toLowerCase() + '@localhost';\n                    $el.click();\n                    expect(converse.chatboxes.length).toEqual(2);\n                    expect(chatboxview.focus).toHaveBeenCalled();\n                });\n            }));\n\n            it(\"can be saved to, and retrieved from, browserStorage\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                spyOn(converse, 'emit');\n                spyOn(converse.chatboxviews, 'trimChats');\n                runs(function () {\n                    test_utils.openControlBox();\n                });\n                waits(250);\n                runs(function () {\n                    test_utils.openChatBoxes(converse, 6);\n                    expect(converse.chatboxviews.trimChats).toHaveBeenCalled();\n                    // We instantiate a new ChatBoxes collection, which by default\n                    // will be empty.\n                    var newchatboxes = new converse.ChatBoxes();\n                    expect(newchatboxes.length).toEqual(0);\n                    // The chatboxes will then be fetched from browserStorage inside the\n                    // onConnected method\n                    newchatboxes.onConnected();\n                    expect(newchatboxes.length).toEqual(7);\n                    // Check that the chatboxes items retrieved from browserStorage\n                    // have the same attributes values as the original ones.\n                    var attrs = ['id', 'box_id', 'visible'];\n                    var new_attrs, old_attrs;\n                    for (var i=0; i<attrs.length; i++) {\n                        new_attrs = _.pluck(_.pluck(newchatboxes.models, 'attributes'), attrs[i]);\n                        old_attrs = _.pluck(_.pluck(converse.chatboxes.models, 'attributes'), attrs[i]);\n                        expect(_.isEqual(new_attrs, old_attrs)).toEqual(true);\n                    }\n                    converse.rosterview.render();\n                });\n            }));\n\n            it(\"can be closed by clicking a DOM element with class 'close-chatbox-button'\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                var chatbox = test_utils.openChatBoxes(converse, 1)[0],\n                    controlview = converse.chatboxviews.get('controlbox'), // The controlbox is currently open\n                    chatview = converse.chatboxviews.get(chatbox.get('jid'));\n                spyOn(chatview, 'close').andCallThrough();\n                spyOn(controlview, 'close').andCallThrough();\n                spyOn(converse, 'emit');\n\n                // We need to rebind all events otherwise our spy won't be called\n                controlview.delegateEvents();\n                chatview.delegateEvents();\n\n                runs(function () {\n                    controlview.$el.find('.close-chatbox-button').click();\n                });\n                waits(250);\n                runs(function () {\n                    expect(controlview.close).toHaveBeenCalled();\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxClosed', jasmine.any(Object));\n                    expect(converse.emit.callCount, 1);\n                    chatview.$el.find('.close-chatbox-button').click();\n                });\n                waits(250);\n                runs(function () {\n                    expect(chatview.close).toHaveBeenCalled();\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxClosed', jasmine.any(Object));\n                    expect(converse.emit.callCount, 2);\n                });\n            }));\n\n            it(\"can be minimized by clicking a DOM element with class 'toggle-chatbox-button'\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                var chatbox = test_utils.openChatBoxes(converse, 1)[0],\n                    chatview = converse.chatboxviews.get(chatbox.get('jid')),\n                    trimmed_chatboxes = converse.minimized_chats,\n                    trimmedview;\n                spyOn(chatview, 'minimize').andCallThrough();\n                spyOn(converse, 'emit');\n                // We need to rebind all events otherwise our spy won't be called\n                chatview.delegateEvents();\n\n                runs(function () {\n                    chatview.$el.find('.toggle-chatbox-button').click();\n                });\n                waits(250);\n                runs(function () {\n                    expect(chatview.minimize).toHaveBeenCalled();\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxMinimized', jasmine.any(Object));\n                    expect(converse.emit.callCount, 2);\n                    expect(chatview.$el.is(':visible')).toBeFalsy();\n                    expect(chatview.model.get('minimized')).toBeTruthy();\n                    chatview.$el.find('.toggle-chatbox-button').click();\n                    trimmedview = trimmed_chatboxes.get(chatview.model.get('id'));\n                    spyOn(trimmedview, 'restore').andCallThrough();\n                    trimmedview.delegateEvents();\n                    trimmedview.$(\"a.restore-chat\").click();\n                });\n                waits(250);\n                runs(function () {\n                    expect(trimmedview.restore).toHaveBeenCalled();\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxMaximized', jasmine.any(Object));\n                    expect(chatview.$el.find('.chat-body').is(':visible')).toBeTruthy();\n                    expect(chatview.$el.find('.toggle-chatbox-button').hasClass('icon-minus')).toBeTruthy();\n                    expect(chatview.$el.find('.toggle-chatbox-button').hasClass('icon-plus')).toBeFalsy();\n                    expect(chatview.model.get('minimized')).toBeFalsy();\n                });\n            }));\n\n            it(\"will be removed from browserStorage when closed\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                spyOn(converse, 'emit');\n                spyOn(converse.chatboxviews, 'trimChats');\n                converse.chatboxes.browserStorage._clear();\n                runs(function () {\n                    test_utils.closeControlBox();\n                });\n                waits(50);\n                runs(function () {\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxClosed', jasmine.any(Object));\n                    expect(converse.chatboxes.length).toEqual(1);\n                    expect(converse.chatboxes.pluck('id')).toEqual(['controlbox']);\n                    test_utils.openChatBoxes(converse, 6);\n                    expect(converse.chatboxviews.trimChats).toHaveBeenCalled();\n                    expect(converse.chatboxes.length).toEqual(7);\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxOpened', jasmine.any(Object));\n                    test_utils.closeAllChatBoxes(converse);\n                });\n                waits(50);\n                runs(function () {\n                    expect(converse.chatboxes.length).toEqual(1);\n                    expect(converse.chatboxes.pluck('id')).toEqual(['controlbox']);\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxClosed', jasmine.any(Object));\n                    var newchatboxes = new converse.ChatBoxes();\n                    expect(newchatboxes.length).toEqual(0);\n                    expect(converse.chatboxes.pluck('id')).toEqual(['controlbox']);\n                    // onConnected will fetch chatboxes in browserStorage, but\n                    // because there aren't any open chatboxes, there won't be any\n                    // in browserStorage either. XXX except for the controlbox\n                    newchatboxes.onConnected();\n                    expect(newchatboxes.length).toEqual(1);\n                    expect(newchatboxes.models[0].id).toBe(\"controlbox\");\n                });\n            }));\n\n            describe(\"A chat toolbar\", function () {\n                afterEach(function () {\n                    converse_api.user.logout();\n                    converse_api.listen.not();\n                    test_utils.clearBrowserStorage();\n                });\n\n                it(\"can be found on each chat box\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var chatbox = converse.chatboxes.get(contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    expect(chatbox).toBeDefined();\n                    expect(view).toBeDefined();\n                    var $toolbar = view.$el.find('ul.chat-toolbar');\n                    expect($toolbar.length).toBe(1);\n                    expect($toolbar.children('li').length).toBe(3);\n                }));\n\n                it(\"contains a button for inserting emoticons\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost',\n                        view, $toolbar, $textarea;\n                    waits(300); // ChatBox.show() is debounced for 250ms\n                    runs(function () {\n                        test_utils.openChatBoxFor(converse, contact_jid);\n                        view = converse.chatboxviews.get(contact_jid);\n                        $toolbar = view.$el.find('ul.chat-toolbar');\n                        $textarea = view.$el.find('textarea.chat-textarea');\n                        expect($toolbar.children('li.toggle-smiley').length).toBe(1);\n                        // Register spies\n                        spyOn(view, 'toggleEmoticonMenu').andCallThrough();\n                        spyOn(view, 'insertEmoticon').andCallThrough();\n                        view.delegateEvents(); // We need to rebind all events otherwise our spy won't be called\n                        $toolbar.children('li.toggle-smiley').click();\n                    });\n                    waits(250);\n                    runs(function () {\n                        expect(view.toggleEmoticonMenu).toHaveBeenCalled();\n                        var $menu = view.$el.find('.toggle-smiley ul');\n                        var $items = $menu.children('li');\n                        expect($menu.is(':visible')).toBeTruthy();\n                        expect($items.length).toBe(13);\n                        expect($($items[0]).children('a').data('emoticon')).toBe(':)');\n                        expect($($items[1]).children('a').data('emoticon')).toBe(';)');\n                        expect($($items[2]).children('a').data('emoticon')).toBe(':D');\n                        expect($($items[3]).children('a').data('emoticon')).toBe(':P');\n                        expect($($items[4]).children('a').data('emoticon')).toBe('8)');\n                        expect($($items[5]).children('a').data('emoticon')).toBe('>:)');\n                        expect($($items[6]).children('a').data('emoticon')).toBe(':S');\n                        expect($($items[7]).children('a').data('emoticon')).toBe(':\\\\');\n                        expect($($items[8]).children('a').data('emoticon')).toBe('>:(');\n                        expect($($items[9]).children('a').data('emoticon')).toBe(':(');\n                        expect($($items[10]).children('a').data('emoticon')).toBe(':O');\n                        expect($($items[11]).children('a').data('emoticon')).toBe('(^.^)b');\n                        expect($($items[12]).children('a').data('emoticon')).toBe('<3');\n                        $items.first().click();\n                    });\n                    waits(250);\n                    runs(function () {\n                        expect(view.insertEmoticon).toHaveBeenCalled();\n                        expect($textarea.val()).toBe(':) ');\n                        expect(view.$el.find('.toggle-smiley ul').is(':visible')).toBeFalsy();\n                        $toolbar.children('li.toggle-smiley').click();\n                    });\n                    waits(250);\n                    runs(function () {\n                        expect(view.toggleEmoticonMenu).toHaveBeenCalled();\n                        expect(view.$el.find('.toggle-smiley ul').is(':visible')).toBeTruthy();\n                        view.$el.find('.toggle-smiley ul').children('li').last().click();\n                    });\n                    waits(250);\n                    runs(function () {\n                        expect(view.insertEmoticon).toHaveBeenCalled();\n                        expect(view.$el.find('.toggle-smiley ul').is(':visible')).toBeFalsy();\n                        expect($textarea.val()).toBe(':) <3 ');\n                    });\n                }));\n\n                it(\"contains a button for starting an encrypted chat session\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    // TODO: More tests can be added here...\n                    var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    var $toolbar = view.$el.find('ul.chat-toolbar');\n                    expect($toolbar.children('li.toggle-otr').length).toBe(1);\n                    // Register spies\n                    spyOn(view, 'toggleOTRMenu').andCallThrough();\n                    view.delegateEvents(); // We need to rebind all events otherwise our spy won't be called\n\n                    runs(function () {\n                        $toolbar.children('li.toggle-otr').click();\n                    });\n                    waits(250);\n                    runs(function () {\n                        expect(view.toggleOTRMenu).toHaveBeenCalled();\n                        var $menu = view.$el.find('.toggle-otr ul');\n                        expect($menu.is(':visible')).toBeTruthy();\n                        expect($menu.children('li').length).toBe(2);\n                    });\n\n                }));\n\n                it(\"can contain a button for starting a call\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var view, callButton, $toolbar;\n                    var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    spyOn(converse, 'emit');\n                    // First check that the button doesn't show if it's not enabled\n                    // via \"visible_toolbar_buttons\"\n                    converse.visible_toolbar_buttons.call = false;\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    view = converse.chatboxviews.get(contact_jid);\n                    $toolbar = view.$el.find('ul.chat-toolbar');\n                    callButton = $toolbar.find('.toggle-call');\n                    expect(callButton.length).toBe(0);\n                    view.close();\n                    // Now check that it's shown if enabled and that it emits\n                    // callButtonClicked\n                    converse.visible_toolbar_buttons.call = true; // enable the button\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    view = converse.chatboxviews.get(contact_jid);\n                    $toolbar = view.$el.find('ul.chat-toolbar');\n                    callButton = $toolbar.find('.toggle-call');\n                    expect(callButton.length).toBe(1);\n                    callButton.click();\n                    expect(converse.emit).toHaveBeenCalledWith('callButtonClicked', jasmine.any(Object));\n                }));\n\n                it(\"can contain a button for clearing messages\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var view, clearButton, $toolbar;\n                    var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    // First check that the button doesn't show if it's not enabled\n                    // via \"visible_toolbar_buttons\"\n                    converse.visible_toolbar_buttons.clear = false;\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    view = converse.chatboxviews.get(contact_jid);\n                    view = converse.chatboxviews.get(contact_jid);\n                    $toolbar = view.$el.find('ul.chat-toolbar');\n                    clearButton = $toolbar.find('.toggle-clear');\n                    expect(clearButton.length).toBe(0);\n                    view.close();\n                    // Now check that it's shown if enabled and that it calls\n                    // clearMessages\n                    converse.visible_toolbar_buttons.clear = true; // enable the button\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    view = converse.chatboxviews.get(contact_jid);\n                    $toolbar = view.$el.find('ul.chat-toolbar');\n                    clearButton = $toolbar.find('.toggle-clear');\n                    expect(clearButton.length).toBe(1);\n                    spyOn(view, 'clearMessages');\n                    view.delegateEvents(); // We need to rebind all events otherwise our spy won't be called\n                    clearButton.click();\n                    expect(view.clearMessages).toHaveBeenCalled();\n                }));\n            });\n\n            describe(\"A Chat Message\", function () {\n                afterEach(function () {\n                    converse_api.user.logout();\n                    converse_api.listen.not();\n                    test_utils.clearBrowserStorage();\n                });\n\n                describe(\"when received from someone else\", function () {\n                    it(\"can be received which will open a chatbox and be displayed inside it\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        spyOn(converse, 'emit');\n                        var message = 'converse is a received message';\n                        var sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        var msg = $msg({\n                                from: sender_jid,\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').t(message).up()\n                            .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n\n                        // We don't already have an open chatbox for this user\n                        expect(converse.chatboxes.get(sender_jid)).not.toBeDefined();\n\n                        runs(function () {\n                            // onMessage is a handler for received XMPP messages\n                            converse.chatboxes.onMessage(msg);\n                            expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        });\n                        waits(50);\n                        runs(function () {\n                            // Check that the chatbox and its view now exist\n                            var chatbox = converse.chatboxes.get(sender_jid);\n                            var chatboxview = converse.chatboxviews.get(sender_jid);\n                            expect(chatbox).toBeDefined();\n                            expect(chatboxview).toBeDefined();\n                            // Check that the message was received and check the message parameters\n                            expect(chatbox.messages.length).toEqual(1);\n                            var msg_obj = chatbox.messages.models[0];\n                            expect(msg_obj.get('message')).toEqual(message);\n                            expect(msg_obj.get('fullname')).toEqual(mock.cur_names[0]);\n                            expect(msg_obj.get('sender')).toEqual('them');\n                            expect(msg_obj.get('delayed')).toEqual(false);\n                            // Now check that the message appears inside the chatbox in the DOM\n                            var $chat_content = chatboxview.$el.find('.chat-content');\n                            var msg_txt = $chat_content.find('.chat-message').find('.chat-msg-content').text();\n                            expect(msg_txt).toEqual(message);\n                            var sender_txt = $chat_content.find('span.chat-msg-them').text();\n                            expect(sender_txt.match(/^[0-9][0-9]:[0-9][0-9] /)).toBeTruthy();\n                        });\n                    }));\n\n                    describe(\"and for which then an error message is received from the server\", function () {\n                        afterEach(function () {\n                            converse_api.user.logout();\n                            converse_api.listen.not();\n                            test_utils.clearBrowserStorage();\n                        });\n\n                        it(\"will have the error message displayed after itself\", mock.initConverse(function (converse) {\n                            test_utils.createContacts(converse, 'current');\n                            test_utils.openControlBox();\n                            test_utils.openContactsPanel(converse);\n\n                            // TODO: what could still be done for error\n                            // messages... if the <error> element has type\n                            // \"cancel\", then we know the messages wasn't sent,\n                            // and can give the user a nicer indication of\n                            // that.\n\n                            /* <message from=\"scotty@enterprise.com/converse.js-84843526\"\n                             *          to=\"kirk@enterprise.com.com\"\n                             *          type=\"chat\"\n                             *          id=\"82bc02ce-9651-4336-baf0-fa04762ed8d2\"\n                             *          xmlns=\"jabber:client\">\n                             *      <body>yo</body>\n                             *      <active xmlns=\"http://jabber.org/protocol/chatstates\"/>\n                             *  </message>\n                             */\n                            var sender_jid = mock.cur_names[5].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            var fullname = converse.xmppstatus.get('fullname');\n                            fullname = _.isEmpty(fullname)? converse.bare_jid: fullname;\n                            converse_api.chats.open(sender_jid);\n                            var msg_text = 'This message will not be sent, due to an error';\n                            var view = converse.chatboxviews.get(sender_jid);\n                            var message = view.model.messages.create({\n                                'msgid': '82bc02ce-9651-4336-baf0-fa04762ed8d2',\n                                'fullname': fullname,\n                                'sender': 'me',\n                                'time': moment().format(),\n                                'message': msg_text\n                            });\n                            view.sendMessage(message);\n                            var $chat_content = view.$el.find('.chat-content');\n                            var msg_txt = $chat_content.find('.chat-message:last').find('.chat-msg-content').text();\n                            expect(msg_txt).toEqual(msg_text);\n\n                            // We send another message, for which an error will\n                            // not be received, to test that errors appear\n                            // after the relevant message.\n                            msg_text = 'This message will be sent, and not receive an error';\n                            message = view.model.messages.create({\n                                'msgid': '6fcdeee3-000f-4ce8-a17e-9ce28f0ae104',\n                                'fullname': fullname,\n                                'sender': 'me',\n                                'time': moment().format(),\n                                'message': msg_text\n                            });\n                            view.sendMessage(message);\n                            msg_txt = $chat_content.find('.chat-message:last').find('.chat-msg-content').text();\n                            expect(msg_txt).toEqual(msg_text);\n\n                            /* <message xmlns=\"jabber:client\"\n                             *          to=\"scotty@enterprise.com/converse.js-84843526\"\n                             *          type=\"error\"\n                             *          id=\"82bc02ce-9651-4336-baf0-fa04762ed8d2\"\n                             *          from=\"kirk@enterprise.com.com\">\n                             *     <error type=\"cancel\">\n                             *         <remote-server-not-found xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\"/>\n                             *         <text xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\">Server-to-server connection failed: Connecting failed: connection timeout</text>\n                             *     </error>\n                             * </message>\n                             */\n                            var error_txt = 'Server-to-server connection failed: Connecting failed: connection timeout';\n                            var stanza = $msg({\n                                    'to': converse.connection.jid,\n                                    'type':'error',\n                                    'id':'82bc02ce-9651-4336-baf0-fa04762ed8d2',\n                                    'from': sender_jid\n                                })\n                                .c('error', {'type': 'cancel'})\n                                .c('remote-server-not-found', { 'xmlns': \"urn:ietf:params:xml:ns:xmpp-stanzas\" }).up()\n                                .c('text', { 'xmlns': \"urn:ietf:params:xml:ns:xmpp-stanzas\" })\n                                    .t('Server-to-server connection failed: Connecting failed: connection timeout');\n                            converse.connection._dataRecv(test_utils.createRequest(stanza));\n                            expect($chat_content.find('.chat-error').text()).toEqual(error_txt);\n\n                            /* Incoming error messages that are not tied to a\n                             * certain show message (via the msgid attribute),\n                             * are not shown at all. The reason for this is\n                             * that we may get error messages for chat state\n                             * notifications as well.\n                             */\n                            stanza = $msg({\n                                    'to': converse.connection.jid,\n                                    'type':'error',\n                                    'id':'some-other-unused-id',\n                                    'from': sender_jid\n                                })\n                                .c('error', {'type': 'cancel'})\n                                .c('remote-server-not-found', { 'xmlns': \"urn:ietf:params:xml:ns:xmpp-stanzas\" }).up()\n                                .c('text', { 'xmlns': \"urn:ietf:params:xml:ns:xmpp-stanzas\" })\n                                    .t('Server-to-server connection failed: Connecting failed: connection timeout');\n                            converse.connection._dataRecv(test_utils.createRequest(stanza));\n                            expect($chat_content.find('.chat-error').length).toEqual(1);\n                        }));\n                    });\n\n                    it(\"will cause the chat area to be scrolled down only if it was at the bottom already\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        var message = 'This message is received while the chat area is scrolled up';\n                        var sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        test_utils.openChatBoxFor(converse, sender_jid);\n                        var chatboxview = converse.chatboxviews.get(sender_jid);\n                        spyOn(chatboxview, 'scrollDown').andCallThrough();\n                        runs(function () {\n                            /* Create enough messages so that there's a\n                             * scrollbar.\n                             */\n                            for (var i=0; i<20; i++) {\n                                converse.chatboxes.onMessage($msg({\n                                        from: sender_jid,\n                                        to: converse.connection.jid,\n                                        type: 'chat',\n                                        id: (new Date()).getTime()\n                                    }).c('body').t('Message: '+i).up()\n                                    .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree());\n                            }\n                        });\n                        waits(50);\n                        runs(function () {\n                            chatboxview.$content.scrollTop(0);\n                        });\n                        waits(250);\n                        runs(function () {\n                            converse.chatboxes.onMessage($msg({\n                                    from: sender_jid,\n                                    to: converse.connection.jid,\n                                    type: 'chat',\n                                    id: (new Date()).getTime()\n                                }).c('body').t(message).up()\n                                .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree());\n                        });\n                        waits(150);\n                        runs(function () {\n                            // Now check that the message appears inside the chatbox in the DOM\n                            var $chat_content = chatboxview.$el.find('.chat-content');\n                            var msg_txt = $chat_content.find('.chat-message:last').find('.chat-msg-content').text();\n                            expect(msg_txt).toEqual(message);\n                            expect(chatboxview.model.get('scrolled')).toBeTruthy();\n                            expect(chatboxview.$content.scrollTop()).toBe(0);\n                            expect(chatboxview.$('.new-msgs-indicator').is(':visible')).toBeTruthy();\n                            // Scroll down again\n                            chatboxview.$content.scrollTop(chatboxview.$content[0].scrollHeight);\n                        });\n                        waits(250);\n                        runs(function () {\n                            expect(chatboxview.$('.new-msgs-indicator').is(':visible')).toBeFalsy();\n                        });\n                    }));\n\n                    it(\"is ignored if it's intended for a different resource and filter_by_resource is set to true\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        // Send a message from a different resource\n                        var message, sender_jid, msg;\n                        spyOn(converse, 'log');\n                        spyOn(converse.chatboxes, 'getChatBox').andCallThrough();\n                        runs(function () {\n                            converse.filter_by_resource = true;\n                            sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            msg = $msg({\n                                    from: sender_jid,\n                                    to: converse.bare_jid+'/'+\"some-other-resource\",\n                                    type: 'chat',\n                                    id: (new Date()).getTime()\n                                }).c('body').t(\"This message will not be shown\").up()\n                                .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                            converse.chatboxes.onMessage(msg);\n                        });\n                        waits(50);\n                        runs(function () {\n                            expect(converse.log).toHaveBeenCalledWith(\n                                    \"onMessage: Ignoring incoming message intended for a different resource: dummy@localhost/some-other-resource\", \"info\");\n                            expect(converse.chatboxes.getChatBox).not.toHaveBeenCalled();\n                            converse.filter_by_resource = false;\n                        });\n                        waits(50);\n                        runs(function () {\n                            message = \"This message sent to a different resource will be shown\";\n                            msg = $msg({\n                                    from: sender_jid,\n                                    to: converse.bare_jid+'/'+\"some-other-resource\",\n                                    type: 'chat',\n                                    id: '134234623462346'\n                                }).c('body').t(message).up()\n                                .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                            converse.chatboxes.onMessage(msg);\n                        });\n                        waits(50);\n                        runs(function () {\n                            expect(converse.chatboxes.getChatBox).toHaveBeenCalled();\n                            var chatboxview = converse.chatboxviews.get(sender_jid);\n                            var $chat_content = chatboxview.$el.find('.chat-content:last');\n                            var msg_txt = $chat_content.find('.chat-message').find('.chat-msg-content').text();\n                            expect(msg_txt).toEqual(message);\n                        });\n                    }));\n                });\n\n                describe(\"when sent by the current user\", function () {\n                    it(\"will always cause the chat area to be scrolled down\", mock.initConverse(function (converse) {\n                        // TODO\n                    }));\n                });\n\n                it(\"is ignored if it's a malformed headline message\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    /* Ideally we wouldn't have to filter out headline\n                     * messages, but Prosody gives them the wrong 'type' :(\n                     */\n                    sinon.spy(converse, 'log');\n                    sinon.spy(converse.chatboxes, 'getChatBox');\n                    sinon.spy(utils, 'isHeadlineMessage');\n                    var msg = $msg({\n                            from: 'localhost',\n                            to: converse.bare_jid,\n                            type: 'chat',\n                            id: (new Date()).getTime()\n                        }).c('body').t(\"This headline message will not be shown\").tree();\n                    converse.chatboxes.onMessage(msg);\n                    expect(converse.log.calledWith(\n                        \"onMessage: Ignoring incoming headline message sent with type 'chat' from JID: localhost\",\n                        \"info\"\n                    )).toBeTruthy();\n                    expect(utils.isHeadlineMessage.called).toBeTruthy();\n                    expect(utils.isHeadlineMessage.returned(true)).toBeTruthy();\n                    expect(converse.chatboxes.getChatBox.called).toBeFalsy();\n                    // Remove sinon spies\n                    converse.log.restore();\n                    converse.chatboxes.getChatBox.restore();\n                    utils.isHeadlineMessage.restore();\n                }));\n\n                it(\"can be a carbon message, as defined in XEP-0280\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    // Send a message from a different resource\n                    spyOn(converse, 'log');\n                    var msgtext = 'This is a carbon message';\n                    var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    var msg = $msg({\n                            'from': converse.bare_jid,\n                            'id': (new Date()).getTime(),\n                            'to': converse.connection.jid,\n                            'type': 'chat',\n                            'xmlns': 'jabber:client'\n                        }).c('received', {'xmlns': 'urn:xmpp:carbons:2'})\n                          .c('forwarded', {'xmlns': 'urn:xmpp:forward:0'})\n                          .c('message', {\n                                'xmlns': 'jabber:client',\n                                'from': sender_jid,\n                                'to': converse.bare_jid+'/another-resource',\n                                'type': 'chat'\n                        }).c('body').t(msgtext).tree();\n                    converse.chatboxes.onMessage(msg);\n\n                    // Check that the chatbox and its view now exist\n                    var chatbox = converse.chatboxes.get(sender_jid);\n                    var chatboxview = converse.chatboxviews.get(sender_jid);\n                    expect(chatbox).toBeDefined();\n                    expect(chatboxview).toBeDefined();\n                    // Check that the message was received and check the message parameters\n                    expect(chatbox.messages.length).toEqual(1);\n                    var msg_obj = chatbox.messages.models[0];\n                    expect(msg_obj.get('message')).toEqual(msgtext);\n                    expect(msg_obj.get('fullname')).toEqual(mock.cur_names[1]);\n                    expect(msg_obj.get('sender')).toEqual('them');\n                    expect(msg_obj.get('delayed')).toEqual(false);\n                    // Now check that the message appears inside the chatbox in the DOM\n                    var $chat_content = chatboxview.$el.find('.chat-content');\n                    var msg_txt = $chat_content.find('.chat-message').find('.chat-msg-content').text();\n                    expect(msg_txt).toEqual(msgtext);\n                    var sender_txt = $chat_content.find('span.chat-msg-them').text();\n                    expect(sender_txt.match(/^[0-9][0-9]:[0-9][0-9] /)).toBeTruthy();\n                }));\n\n                it(\"can be a carbon message that this user sent from a different client, as defined in XEP-0280\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    // Send a message from a different resource\n                    spyOn(converse, 'log');\n                    var msgtext = 'This is a sent carbon message';\n                    var recipient_jid = mock.cur_names[5].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    var msg = $msg({\n                            'from': converse.bare_jid,\n                            'id': (new Date()).getTime(),\n                            'to': converse.connection.jid,\n                            'type': 'chat',\n                            'xmlns': 'jabber:client'\n                        }).c('sent', {'xmlns': 'urn:xmpp:carbons:2'})\n                          .c('forwarded', {'xmlns': 'urn:xmpp:forward:0'})\n                          .c('message', {\n                                'xmlns': 'jabber:client',\n                                'from': converse.bare_jid+'/another-resource',\n                                'to': recipient_jid,\n                                'type': 'chat'\n                        }).c('body').t(msgtext).tree();\n                    converse.chatboxes.onMessage(msg);\n\n                    // Check that the chatbox and its view now exist\n                    var chatbox = converse.chatboxes.get(recipient_jid);\n                    var chatboxview = converse.chatboxviews.get(recipient_jid);\n                    expect(chatbox).toBeDefined();\n                    expect(chatboxview).toBeDefined();\n                    // Check that the message was received and check the message parameters\n                    expect(chatbox.messages.length).toEqual(1);\n                    var msg_obj = chatbox.messages.models[0];\n                    expect(msg_obj.get('message')).toEqual(msgtext);\n                    expect(msg_obj.get('fullname')).toEqual(mock.cur_names[5]);\n                    expect(msg_obj.get('sender')).toEqual('me');\n                    expect(msg_obj.get('delayed')).toEqual(false);\n                    // Now check that the message appears inside the chatbox in the DOM\n                    var $chat_content = chatboxview.$el.find('.chat-content');\n                    var msg_txt = $chat_content.find('.chat-message').find('.chat-msg-content').text();\n                    expect(msg_txt).toEqual(msgtext);\n                }));\n\n                it(\"received for a minimized chat box will increment a counter on its header\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n                    var contact_name = mock.cur_names[0];\n                    var contact_jid = contact_name.replace(/ /g,'.').toLowerCase() + '@localhost';\n                    runs(function () {\n                        spyOn(converse, 'emit').andCallThrough();\n                        test_utils.openChatBoxFor(converse, contact_jid);\n                        var chatview = converse.chatboxviews.get(contact_jid);\n                        expect(chatview.$el.is(':visible')).toBeTruthy();\n                        expect(chatview.model.get('minimized')).toBeFalsy();\n                        chatview.$el.find('.toggle-chatbox-button').click();\n                        expect(chatview.model.get('minimized')).toBeTruthy();\n                        var message = 'This message is sent to a minimized chatbox';\n                        var sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        var msg = $msg({\n                            from: sender_jid,\n                            to: converse.connection.jid,\n                            type: 'chat',\n                            id: (new Date()).getTime()\n                        }).c('body').t(message).up()\n                        .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                        converse.chatboxes.onMessage(msg);\n                        expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        var trimmed_chatboxes = converse.minimized_chats;\n                        var trimmedview = trimmed_chatboxes.get(contact_jid);\n                        var $count = trimmedview.$el.find('.chat-head-message-count');\n                        expect(chatview.$el.is(':visible')).toBeFalsy();\n                        expect(trimmedview.model.get('minimized')).toBeTruthy();\n                        expect($count.is(':visible')).toBeTruthy();\n                        expect($count.html()).toBe('1');\n                        converse.chatboxes.onMessage(\n                            $msg({\n                                from: mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost',\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').t('This message is also sent to a minimized chatbox').up()\n                            .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree()\n                        );\n                        expect(chatview.$el.is(':visible')).toBeFalsy();\n                        expect(trimmedview.model.get('minimized')).toBeTruthy();\n                        $count = trimmedview.$el.find('.chat-head-message-count');\n                        expect($count.is(':visible')).toBeTruthy();\n                        expect($count.html()).toBe('2');\n                        trimmedview.$el.find('.restore-chat').click();\n                        expect(trimmed_chatboxes.keys().length).toBe(0);\n                    });\n                }));\n\n                it(\"will indicate when it has a time difference of more than a day between it and its predecessor\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    spyOn(converse, 'emit');\n                    var contact_name = mock.cur_names[1];\n                    var contact_jid = contact_name.replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    test_utils.clearChatBoxMessages(converse, contact_jid);\n                    var one_day_ago = moment();\n                    one_day_ago.subtract('days', 1);\n                    var message = 'This is a day old message';\n                    var chatbox = converse.chatboxes.get(contact_jid);\n                    var chatboxview = converse.chatboxviews.get(contact_jid);\n                    var $chat_content = chatboxview.$el.find('.chat-content');\n                    var msg_obj;\n                    var msg_txt;\n                    var sender_txt;\n\n                    var msg = $msg({\n                        from: contact_jid,\n                        to: converse.connection.jid,\n                        type: 'chat',\n                        id: one_day_ago.unix()\n                    }).c('body').t(message).up()\n                      .c('delay', { xmlns:'urn:xmpp:delay', from: 'localhost', stamp: one_day_ago.format() })\n                      .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                    converse.chatboxes.onMessage(msg);\n                    expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                    expect(chatbox.messages.length).toEqual(1);\n                    msg_obj = chatbox.messages.models[0];\n                    expect(msg_obj.get('message')).toEqual(message);\n                    expect(msg_obj.get('fullname')).toEqual(contact_name);\n                    expect(msg_obj.get('sender')).toEqual('them');\n                    expect(msg_obj.get('delayed')).toEqual(true);\n                    msg_txt = $chat_content.find('.chat-message').find('.chat-msg-content').text();\n                    expect(msg_txt).toEqual(message);\n                    sender_txt = $chat_content.find('span.chat-msg-them').text();\n                    expect(sender_txt.match(/^[0-9][0-9]:[0-9][0-9] /)).toBeTruthy();\n\n                    var $time = $chat_content.find('time');\n                    expect($time.length).toEqual(1);\n                    expect($time.attr('class')).toEqual('chat-info chat-date');\n                    expect($time.data('isodate')).toEqual(moment(one_day_ago.startOf('day')).format());\n                    expect($time.text()).toEqual(moment(one_day_ago.startOf('day')).format(\"dddd MMM Do YYYY\"));\n\n                    message = 'This is a current message';\n                    msg = $msg({\n                        from: contact_jid,\n                        to: converse.connection.jid,\n                        type: 'chat',\n                        id: new Date().getTime()\n                    }).c('body').t(message).up()\n                      .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                    converse.chatboxes.onMessage(msg);\n                    expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                    // Check that there is a <time> element, with the required\n                    // props.\n                    $time = $chat_content.find('time');\n                    expect($time.length).toEqual(2); // There are now two time elements\n                    $time = $chat_content.find('time:last'); // We check the last one\n                    var message_date = new Date();\n                    expect($time.attr('class')).toEqual('chat-info chat-date');\n                    expect($time.data('isodate')).toEqual(moment(message_date).startOf('day').format());\n                    expect($time.text()).toEqual(moment(message_date).startOf('day').format(\"dddd MMM Do YYYY\"));\n\n                    // Normal checks for the 2nd message\n                    expect(chatbox.messages.length).toEqual(2);\n                    msg_obj = chatbox.messages.models[1];\n                    expect(msg_obj.get('message')).toEqual(message);\n                    expect(msg_obj.get('fullname')).toEqual(contact_name);\n                    expect(msg_obj.get('sender')).toEqual('them');\n                    expect(msg_obj.get('delayed')).toEqual(false);\n                    msg_txt = $chat_content.find('.chat-message').last().find('.chat-msg-content').text();\n                    expect(msg_txt).toEqual(message);\n                    sender_txt = $chat_content.find('span.chat-msg-them').last().text();\n                    expect(sender_txt.match(/^[0-9][0-9]:[0-9][0-9] /)).toBeTruthy();\n                }));\n\n                it(\"can be sent from a chatbox, and will appear inside it\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    spyOn(converse, 'emit');\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxFocused', jasmine.any(Object));\n                    var view = converse.chatboxviews.get(contact_jid);\n                    var message = 'This message is sent from this chatbox';\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    test_utils.sendMessage(view, message);\n                    expect(view.sendMessage).toHaveBeenCalled();\n                    expect(view.model.messages.length, 2);\n                    expect(converse.emit.mostRecentCall.args, ['messageSend', message]);\n                    expect(view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content').text()).toEqual(message);\n                }));\n\n                it(\"is sanitized to prevent Javascript injection attacks\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    var message = '<p>This message contains <em>some</em> <b>markup</b></p>';\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    test_utils.sendMessage(view, message);\n                    expect(view.sendMessage).toHaveBeenCalled();\n                    var msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                    expect(msg.text()).toEqual(message);\n                    expect(msg.html()).toEqual('&lt;p&gt;This message contains &lt;em&gt;some&lt;/em&gt; &lt;b&gt;markup&lt;/b&gt;&lt;/p&gt;');\n                }));\n\n                it(\"should display emoticons correctly\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    var messages = [':)', ';)', ':D', ':P', '8)', '>:)', ':S', ':\\\\', '>:(', ':(', ':O', '(^.^)b', '<3'];\n                    var emoticons = [\n                        '<span class=\"emoticon icon-smiley\"></span>', '<span class=\"emoticon icon-wink\"></span>',\n                        '<span class=\"emoticon icon-grin\"></span>', '<span class=\"emoticon icon-tongue\"></span>',\n                        '<span class=\"emoticon icon-cool\"></span>', '<span class=\"emoticon icon-evil\"></span>',\n                        '<span class=\"emoticon icon-confused\"></span>', '<span class=\"emoticon icon-wondering\"></span>',\n                        '<span class=\"emoticon icon-angry\"></span>', '<span class=\"emoticon icon-sad\"></span>',\n                        '<span class=\"emoticon icon-shocked\"></span>', '<span class=\"emoticon icon-thumbs-up\"></span>',\n                        '<span class=\"emoticon icon-heart\"></span>'\n                        ];\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    for (var i = 0; i < messages.length; i++) {\n                        var message = messages[i];\n                        test_utils.sendMessage(view, message);\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        var msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.html()).toEqual(emoticons[i]);\n                    }\n                }));\n\n                it(\"can contain hyperlinks, which will be clickable\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    var message = 'This message contains a hyperlink: www.opkode.com';\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    runs(function () {\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(500);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        var msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.text()).toEqual(message);\n                        expect(msg.html()).toEqual('This message contains a hyperlink: <a target=\"_blank\" rel=\"noopener\" href=\"http://www.opkode.com\">www.opkode.com</a>');\n                    });\n                }));\n\n                it(\"will have properly escaped URLs\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var message, msg;\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    runs(function () {\n                        message = \"http://www.opkode.com/'onmouseover='alert(1)'whatever\";\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(50);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.text()).toEqual(message);\n                        expect(msg.html()).toEqual('<a target=\"_blank\" rel=\"noopener\" href=\"http://www.opkode.com/%27onmouseover=%27alert%281%29%27whatever\">http://www.opkode.com/\\'onmouseover=\\'alert(1)\\'whatever</a>');\n\n                        message = 'http://www.opkode.com/\"onmouseover=\"alert(1)\"whatever';\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(50);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.text()).toEqual(message);\n                        expect(msg.html()).toEqual('<a target=\"_blank\" rel=\"noopener\" href=\"http://www.opkode.com/%22onmouseover=%22alert%281%29%22whatever\">http://www.opkode.com/\"onmouseover=\"alert(1)\"whatever</a>');\n\n                        message = \"https://en.wikipedia.org/wiki/Ender's_Game\";\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(50);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.text()).toEqual(message);\n                        expect(msg.html()).toEqual('<a target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Ender%27s_Game\">https://en.wikipedia.org/wiki/Ender\\'s_Game</a>');\n\n                        message = \"https://en.wikipedia.org/wiki/Ender%27s_Game\";\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(50);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.text()).toEqual(message);\n                        expect(msg.html()).toEqual('<a target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Ender%27s_Game\">https://en.wikipedia.org/wiki/Ender%27s_Game</a>');\n                    });\n                }));\n\n                it(\"will render images from their URLs\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    if (/PhantomJS/.test(window.navigator.userAgent)) {\n                        // Doesn't work when running tests in PhantomJS, since\n                        // the page is loaded via file:///\n                        return;\n                    }\n                    var message = document.URL.split(window.location.pathname)[0] + \"/logo/conversejs.svg\";\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    runs(function () {\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(500);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        var msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.html()).toEqual('<img src=\"'+message+'\" class=\"chat-image\">');\n                    });\n                }));\n\n            });\n\n            describe(\"A Chat Status Notification\", function () {\n                afterEach(function () {\n                    converse_api.user.logout();\n                    converse_api.listen.not();\n                    test_utils.clearBrowserStorage();\n                });\n\n                it(\"does not open automatically if a chat state notification is received\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    spyOn(converse, 'emit');\n                    var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    // <composing> state\n                    var msg = $msg({\n                            from: sender_jid,\n                            to: converse.connection.jid,\n                            type: 'chat',\n                            id: (new Date()).getTime()\n                        }).c('composing', {'xmlns': Strophe.NS.CHATSTATES}).tree();\n                    converse.chatboxes.onMessage(msg);\n                    expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                }));\n\n                describe(\"An active notification\", function () {\n                    afterEach(function () {\n                        converse_api.user.logout();\n                        converse_api.listen.not();\n                        test_utils.clearBrowserStorage();\n                    });\n\n                    it(\"is sent when the user opens a chat box\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        waits(300); // ChatBox.show() is debounced for 250ms\n                        runs(function () {\n                            spyOn(converse.connection, 'send');\n                            var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            test_utils.openChatBoxFor(converse, contact_jid);\n                            var view = converse.chatboxviews.get(contact_jid);\n                            expect(view.model.get('chat_state')).toBe('active');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().length).toBe(3);\n                            expect($stanza.children().get(0).tagName).toBe('active');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n                        });\n                    }));\n\n                    it(\"is sent when the user maximizes a minimized a chat box\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n                        var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n\n                        runs(function () {\n                            test_utils.openChatBoxFor(converse, contact_jid);\n                        });\n                        waits(300); // ChatBox.show() is debounced for 250ms\n                        runs(function () {\n                            var view = converse.chatboxviews.get(contact_jid);\n                            view.model.minimize();\n                            expect(view.model.get('chat_state')).toBe('inactive');\n                            spyOn(converse.connection, 'send');\n                            view.model.maximize();\n                            expect(view.model.get('chat_state')).toBe('active');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().length).toBe(3);\n                            expect($stanza.children().get(0).tagName).toBe('active');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n                        });\n                    }));\n                });\n\n                describe(\"A composing notification\", function () {\n                    afterEach(function () {\n                        converse_api.user.logout();\n                        converse_api.listen.not();\n                        test_utils.clearBrowserStorage();\n                    });\n\n                    it(\"is sent as soon as the user starts typing a message which is not a command\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        waits(300); // ChatBox.show() is debounced for 250ms\n                        runs(function () {\n                            var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            test_utils.openChatBoxFor(converse, contact_jid);\n                            var view = converse.chatboxviews.get(contact_jid);\n                            expect(view.model.get('chat_state')).toBe('active');\n                            spyOn(converse.connection, 'send');\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.model.get('chat_state')).toBe('composing');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().get(0).tagName).toBe('composing');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n\n                            // The notification is not sent again\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.model.get('chat_state')).toBe('composing');\n                            expect(converse.emit.callCount, 1);\n                        });\n                    }));\n\n                    it(\"will be shown if received\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        // See XEP-0085 http://xmpp.org/extensions/xep-0085.html#definitions\n                        spyOn(converse, 'emit');\n                        var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n\n                        // <composing> state\n                        var msg = $msg({\n                                from: sender_jid,\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').c('composing', {'xmlns': Strophe.NS.CHATSTATES}).tree();\n                        converse.chatboxes.onMessage(msg);\n                        expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        var chatboxview = converse.chatboxviews.get(sender_jid);\n                        expect(chatboxview).toBeDefined();\n                        // Check that the notification appears inside the chatbox in the DOM\n                        var $events = chatboxview.$el.find('.chat-event');\n                        expect($events.text()).toEqual(mock.cur_names[1] + ' is typing');\n                    }));\n                });\n\n                describe(\"A paused notification\", function () {\n                    afterEach(function () {\n                        converse_api.user.logout();\n                        converse_api.listen.not();\n                        test_utils.clearBrowserStorage();\n                    });\n\n                    it(\"is sent if the user has stopped typing since 30 seconds\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        var view, contact_jid;\n                        converse.TIMEOUTS.PAUSED = 200; // Make the timeout shorter so that we can test\n                        waits(300); // ChatBox.show() is debounced for 250ms\n                        runs(function () {\n                            contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            test_utils.openChatBoxFor(converse, contact_jid);\n                            view = converse.chatboxviews.get(contact_jid);\n                            spyOn(converse.connection, 'send');\n                            spyOn(view, 'setChatState').andCallThrough();\n                            expect(view.model.get('chat_state')).toBe('active');\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.model.get('chat_state')).toBe('composing');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.children().get(0).tagName).toBe('composing');\n                        });\n                        waits(250);\n                        runs(function () {\n                            expect(view.model.get('chat_state')).toBe('paused');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[1][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().length).toBe(3);\n                            expect($stanza.children().get(0).tagName).toBe('paused');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n                            // Test #359. A paused notification should not be sent\n                            // out if the user simply types longer than the\n                            // timeout.\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.setChatState).toHaveBeenCalled();\n                            expect(view.model.get('chat_state')).toBe('composing');\n                        });\n                        waits(100);\n                        runs(function () {\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.model.get('chat_state')).toBe('composing');\n                        });\n                        waits(150);\n                        runs(function () {\n                            expect(view.model.get('chat_state')).toBe('composing');\n                        });\n                    }));\n\n                    it(\"will be shown if received\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        // TODO: only show paused state if the previous state was composing\n                        // See XEP-0085 http://xmpp.org/extensions/xep-0085.html#definitions\n                        spyOn(converse, 'emit');\n                        var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        // <paused> state\n                        var msg = $msg({\n                                from: sender_jid,\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').c('paused', {'xmlns': Strophe.NS.CHATSTATES}).tree();\n                        converse.chatboxes.onMessage(msg);\n                        expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        var chatboxview = converse.chatboxviews.get(sender_jid);\n                        var $events = chatboxview.$el.find('.chat-event');\n                        expect($events.text()).toEqual(mock.cur_names[1] + ' has stopped typing');\n                    }));\n                });\n\n                describe(\"An inactive notifciation\", function () {\n                    afterEach(function () {\n                        converse_api.user.logout();\n                        converse_api.listen.not();\n                        test_utils.clearBrowserStorage();\n                    });\n\n                    it(\"is sent if the user has stopped typing since 2 minutes\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        // Make the timeouts shorter so that we can test\n                        converse.TIMEOUTS.PAUSED = 200;\n                        converse.TIMEOUTS.INACTIVE = 200;\n                        var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        test_utils.openChatBoxFor(converse, contact_jid);\n                        var view = converse.chatboxviews.get(contact_jid);\n                        runs(function () {\n                            expect(view.model.get('chat_state')).toBe('active');\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.model.get('chat_state')).toBe('composing');\n                        });\n                        waits(250);\n                        runs(function () {\n                            expect(view.model.get('chat_state')).toBe('paused');\n                            spyOn(converse.connection, 'send');\n                        });\n                        waits(250);\n                        runs(function () {\n                            expect(view.model.get('chat_state')).toBe('inactive');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().length).toBe(3);\n                            expect($stanza.children().get(0).tagName).toBe('inactive');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n\n                        });\n                    }));\n\n                    it(\"is sent when the user a minimizes a chat box\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        test_utils.openChatBoxFor(converse, contact_jid);\n                        var view = converse.chatboxviews.get(contact_jid);\n                        spyOn(converse.connection, 'send');\n                        view.minimize();\n                        expect(view.model.get('chat_state')).toBe('inactive');\n                        expect(converse.connection.send).toHaveBeenCalled();\n                        var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                        expect($stanza.attr('to')).toBe(contact_jid);\n                        expect($stanza.children().get(0).tagName).toBe('inactive');\n                    }));\n\n                    it(\"is sent if the user closes a chat box\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        waits(300); // ChatBox.show() is debounced for 250ms\n                        runs(function () {\n                            var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            test_utils.openChatBoxFor(converse, contact_jid);\n                            var view = converse.chatboxviews.get(contact_jid);\n                            expect(view.model.get('chat_state')).toBe('active');\n                            spyOn(converse.connection, 'send');\n                            view.close();\n                            expect(view.model.get('chat_state')).toBe('inactive');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().length).toBe(3);\n                            expect($stanza.children().get(0).tagName).toBe('inactive');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n                        });\n                    }));\n\n                    it(\"will clear any other chat status notifications if its received\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        // See XEP-0085 http://xmpp.org/extensions/xep-0085.html#definitions\n                        spyOn(converse, 'emit');\n                        var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        test_utils.openChatBoxFor(converse, sender_jid);\n                        var view = converse.chatboxviews.get(sender_jid);\n                        expect(view.$el.find('.chat-event').length).toBe(0);\n                        view.showStatusNotification(sender_jid+' '+'is typing');\n                        expect(view.$el.find('.chat-event').length).toBe(1);\n                        var msg = $msg({\n                                from: sender_jid,\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').c('inactive', {'xmlns': Strophe.NS.CHATSTATES}).tree();\n                        converse.chatboxes.onMessage(msg);\n                        expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        expect(view.$el.find('.chat-event').length).toBe(0);\n                    }));\n\n                });\n\n                describe(\"A gone notifciation\", function () {\n                    afterEach(function () {\n                        converse_api.user.logout();\n                        converse_api.listen.not();\n                        test_utils.clearBrowserStorage();\n                    });\n\n                    it(\"will be shown if received\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        spyOn(converse, 'emit');\n                        var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        // <paused> state\n                        var msg = $msg({\n                                from: sender_jid,\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').c('gone', {'xmlns': Strophe.NS.CHATSTATES}).tree();\n                        converse.chatboxes.onMessage(msg);\n                        expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        var chatboxview = converse.chatboxviews.get(sender_jid);\n                        var $events = chatboxview.$el.find('.chat-event');\n                        expect($events.text()).toEqual(mock.cur_names[1] + ' has gone away');\n                    }));\n                });\n            });\n        });\n\n        describe(\"Special Messages\", function () {\n            afterEach(function () {\n                converse_api.user.logout();\n                converse_api.listen.not();\n                test_utils.clearBrowserStorage();\n            });\n\n            it(\"'/clear' can be used to clear messages in a conversation\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                spyOn(converse, 'emit');\n                var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                test_utils.openChatBoxFor(converse, contact_jid);\n                var view = converse.chatboxviews.get(contact_jid);\n                var message = 'This message is another sent from this chatbox';\n                // Lets make sure there is at least one message already\n                // (e.g for when this test is run on its own).\n                test_utils.sendMessage(view, message);\n                expect(view.model.messages.length > 0).toBeTruthy();\n                expect(view.model.messages.browserStorage.records.length > 0).toBeTruthy();\n                expect(converse.emit).toHaveBeenCalledWith('messageSend', message);\n\n                message = '/clear';\n                spyOn(view, 'onMessageSubmitted').andCallThrough();\n                spyOn(view, 'clearMessages').andCallThrough();\n                spyOn(window, 'confirm').andCallFake(function () {\n                    return true;\n                });\n                test_utils.sendMessage(view, message);\n                expect(view.onMessageSubmitted).toHaveBeenCalled();\n                expect(view.clearMessages).toHaveBeenCalled();\n                expect(window.confirm).toHaveBeenCalled();\n                expect(view.model.messages.length, 0); // The messages must be removed from the chatbox\n                expect(view.model.messages.browserStorage.records.length, 0); // And also from browserStorage\n                expect(converse.emit.callCount, 1);\n                expect(converse.emit.mostRecentCall.args, ['messageSend', message]);\n            }));\n        });\n\n        describe(\"A Message Counter\", function () {\n            afterEach(function () {\n                converse_api.user.logout();\n                converse_api.listen.not();\n                test_utils.clearBrowserStorage();\n            });\n\n            it(\"is incremented when the message is received and the window is not focused\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                spyOn(converse, 'emit');\n                expect(converse.msg_counter).toBe(0);\n                spyOn(converse, 'incrementMsgCounter').andCallThrough();\n                var previous_state = converse.windowState;\n                var message = 'This message will increment the message counter';\n                var sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost',\n                    msg = $msg({\n                        from: sender_jid,\n                        to: converse.connection.jid,\n                        type: 'chat',\n                        id: (new Date()).getTime()\n                    }).c('body').t(message).up()\n                      .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                converse.windowState = 'hidden';\n                converse.chatboxes.onMessage(msg);\n                expect(converse.incrementMsgCounter).toHaveBeenCalled();\n                expect(converse.msg_counter).toBe(1);\n                expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                converse.windowSate = previous_state;\n            }));\n\n            it(\"is cleared when the window is focused\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                converse.windowState = 'hidden';\n                spyOn(converse, 'clearMsgCounter').andCallThrough();\n                runs(function () {\n                    converse.saveWindowState(null, 'focus');\n                    converse.saveWindowState(null, 'blur');\n                });\n                waits(50);\n                runs(function () {\n                    expect(converse.clearMsgCounter).toHaveBeenCalled();\n                });\n            }));\n\n            it(\"is not incremented when the message is received and the window is focused\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                expect(converse.msg_counter).toBe(0);\n                spyOn(converse, 'incrementMsgCounter').andCallThrough();\n                converse.saveWindowState(null, 'focus');\n                var message = 'This message will not increment the message counter';\n                var sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost',\n                    msg = $msg({\n                        from: sender_jid,\n                        to: converse.connection.jid,\n                        type: 'chat',\n                        id: (new Date()).getTime()\n                    }).c('body').t(message).up()\n                      .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                converse.chatboxes.onMessage(msg);\n                expect(converse.incrementMsgCounter).not.toHaveBeenCalled();\n                expect(converse.msg_counter).toBe(0);\n            }));\n        });\n    });\n}));\n", "// Converse.js (A browser based XMPP chat client)\n// http://conversejs.org\n//\n// Copyright (c) 2012-2016, Jan-Carel Brand <jc@opkode.com>\n// Licensed under the Mozilla Public License (MPLv2)\n//\n/*global Backbone, define, window, document */\n\n(function (root, factory) {\n    define(\"converse-core\", [\n        \"jquery\",\n        \"underscore\",\n        \"polyfill\",\n        \"utils\",\n        \"moment_with_locales\",\n        \"strophe\",\n        \"pluggable\",\n        \"strophe.disco\",\n        \"backbone.browserStorage\",\n        \"backbone.overview\",\n    ], factory);\n}(this, function ($, _, dummy, utils, moment, Strophe, pluggable) {\n    /*\n     * Cannot use this due to Safari bug.\n     * See https://github.com/jcbrand/converse.js/issues/196\n     */\n    // \"use strict\";\n\n    // Strophe globals\n    var $build = Strophe.$build;\n    var $iq = Strophe.$iq;\n    var $pres = Strophe.$pres;\n    var b64_sha1 = Strophe.SHA1.b64_sha1;\n    Strophe = Strophe.Strophe;\n\n    // Use Mustache style syntax for variable interpolation\n    /* Configuration of underscore templates (this config is distinct to the\n     * config of requirejs-tpl in main.js). This one is for normal inline templates.\n     */\n    _.templateSettings = {\n        evaluate : /\\{\\[([\\s\\S]+?)\\]\\}/g,\n        interpolate : /\\{\\{([\\s\\S]+?)\\}\\}/g\n    };\n\n    // We create an object to act as the \"this\" context for event handlers (as\n    // defined below and accessible via converse_api.listen).\n    // We don't want the inner converse object to be the context, since it\n    // contains sensitive information, and we don't want it to be something in\n    // the DOM or window, because then anyone can trigger converse events.\n    var event_context = {};\n\n    var converse = {\n        templates: {},\n\n        emit: function (evt, data) {\n            $(event_context).trigger(evt, data);\n        },\n\n        once: function (evt, handler, context) {\n            if (context) {\n                handler = handler.bind(context);\n            }\n            $(event_context).one(evt, handler);\n        },\n\n        on: function (evt, handler, context) {\n            if (_.contains(['ready', 'initialized'], evt)) {\n                converse.log('Warning: The \"'+evt+'\" event has been deprecated and will be removed, please use \"connected\".');\n            }\n            if (context) {\n                handler = handler.bind(context);\n            }\n            $(event_context).bind(evt, handler);\n        },\n\n        off: function (evt, handler) {\n            $(event_context).unbind(evt, handler);\n        }\n    };\n\n    // Make converse pluggable\n    pluggable.enable(converse, 'converse', 'pluggable');\n\n    // Module-level constants\n    converse.STATUS_WEIGHTS = {\n        'offline':      6,\n        'unavailable':  5,\n        'xa':           4,\n        'away':         3,\n        'dnd':          2,\n        'chat':         1, // We currently don't differentiate between \"chat\" and \"online\"\n        'online':       1\n    };\n    converse.ANONYMOUS  = \"anonymous\";\n    converse.CLOSED = 'closed';\n    converse.EXTERNAL = \"external\";\n    converse.LOGIN = \"login\";\n    converse.LOGOUT = \"logout\";\n    converse.OPENED = 'opened';\n    converse.PREBIND = \"prebind\";\n\n    var PRETTY_CONNECTION_STATUS = {\n        0: 'ERROR',\n        1: 'CONNECTING',\n        2: 'CONNFAIL',\n        3: 'AUTHENTICATING',\n        4: 'AUTHFAIL',\n        5: 'CONNECTED',\n        6: 'DISCONNECTED',\n        7: 'DISCONNECTING',\n        8: 'ATTACHED',\n        9: 'REDIRECT'\n    };\n\n    converse.log = function (txt, level) {\n        var logger;\n        if (typeof console === \"undefined\" || typeof console.log === \"undefined\") {\n            logger = { log: function () {}, error: function () {} };\n        } else {\n            logger = console;\n        }\n        if (converse.debug) {\n            if (level === 'error') {\n                logger.log('ERROR: '+txt);\n            } else {\n                logger.log(txt);\n            }\n        }\n    };\n\n\n    converse.initialize = function (settings, callback) {\n        \"use strict\";\n        settings = typeof settings !== \"undefined\" ? settings : {};\n        var init_deferred = new $.Deferred();\n        var converse = this;\n\n        if (typeof converse.chatboxes !== 'undefined') {\n            // Looks like converse.initialized was called again without logging\n            // out or disconnecting in the previous session.\n            // This happens in tests.\n            // We therefore first clean up.\n            converse.connection.reset();\n            converse._tearDown();\n        }\n\n        var unloadevent;\n        if ('onpagehide' in window) {\n            // Pagehide gets thrown in more cases than unload. Specifically it\n            // gets thrown when the page is cached and not just\n            // closed/destroyed. It's the only viable event on mobile Safari.\n            // https://www.webkit.org/blog/516/webkit-page-cache-ii-the-unload-event/\n            unloadevent = 'pagehide';\n        } else if ('onbeforeunload' in window) {\n            unloadevent = 'beforeunload';\n        } else if ('onunload' in window) {\n            unloadevent = 'unload';\n        }\n\n        // Logging\n        Strophe.log = function (level, msg) { converse.log(level+' '+msg, level); };\n        Strophe.error = function (msg) { converse.log(msg, 'error'); };\n\n        // Add Strophe Namespaces\n        Strophe.addNamespace('CARBONS', 'urn:xmpp:carbons:2');\n        Strophe.addNamespace('CHATSTATES', 'http://jabber.org/protocol/chatstates');\n        Strophe.addNamespace('CSI', 'urn:xmpp:csi:0');\n        Strophe.addNamespace('ROSTERX', 'http://jabber.org/protocol/rosterx');\n        Strophe.addNamespace('XFORM', 'jabber:x:data');\n        Strophe.addNamespace('NICK', 'http://jabber.org/protocol/nick');\n        Strophe.addNamespace('HINTS', 'urn:xmpp:hints');\n        Strophe.addNamespace('PUBSUB', 'http://jabber.org/protocol/pubsub');\n\n        // Instance level constants\n        this.TIMEOUTS = { // Set as module attr so that we can override in tests.\n            'PAUSED':     10000,\n            'INACTIVE':   90000\n        };\n\n        // XEP-0085 Chat states\n        // http://xmpp.org/extensions/xep-0085.html\n        this.INACTIVE = 'inactive';\n        this.ACTIVE = 'active';\n        this.COMPOSING = 'composing';\n        this.PAUSED = 'paused';\n        this.GONE = 'gone';\n\n        // Detect support for the user's locale\n        // ------------------------------------\n        var locales = typeof locales === \"undefined\" ? {} : locales;\n        this.isConverseLocale = function (locale) { return typeof locales[locale] !== \"undefined\"; };\n        this.isMomentLocale = function (locale) { return moment.locale() !== moment.locale(locale); };\n        if (!moment.locale) { //moment.lang is deprecated after 2.8.1, use moment.locale instead\n            moment.locale = moment.lang;\n        }\n        moment.locale(utils.detectLocale(this.isMomentLocale));\n        this.i18n = settings.i18n ? settings.i18n : locales[utils.detectLocale(this.isConverseLocale)] || {};\n\n        // Translation machinery\n        // ---------------------\n        var __ = utils.__.bind(this);\n        var DESC_GROUP_TOGGLE = __('Click to hide these contacts');\n\n        // Default configuration values\n        // ----------------------------\n        this.default_settings = {\n            allow_contact_requests: true,\n            animate: true,\n            authentication: 'login', // Available values are \"login\", \"prebind\", \"anonymous\" and \"external\".\n            auto_away: 0, // Seconds after which user status is set to 'away'\n            auto_login: false, // Currently only used in connection with anonymous login\n            auto_reconnect: false,\n            auto_subscribe: false,\n            auto_xa: 0, // Seconds after which user status is set to 'xa'\n            bosh_service_url: undefined, // The BOSH connection manager URL.\n            connection_options: {},\n            credentials_url: null, // URL from where login credentials can be fetched\n            csi_waiting_time: 0, // Support for XEP-0352. Seconds before client is considered idle and CSI is sent out.\n            debug: false,\n            default_state: 'online',\n            expose_rid_and_sid: false,\n            filter_by_resource: false,\n            forward_messages: false,\n            hide_offline_users: false,\n            include_offline_state: false,\n            jid: undefined,\n            keepalive: false,\n            locked_domain: undefined,\n            message_carbons: false, // Support for XEP-280\n            password: undefined,\n            prebind: false, // XXX: Deprecated, use \"authentication\" instead.\n            prebind_url: null,\n            rid: undefined,\n            roster_groups: false,\n            show_only_online_users: false,\n            sid: undefined,\n            storage: 'session',\n            message_storage: 'session',\n            strict_plugin_dependencies: false,\n            synchronize_availability: true, // Set to false to not sync with other clients or with resource name of the particular client that it should synchronize with\n            websocket_url: undefined,\n            xhr_custom_status: false,\n            xhr_custom_status_url: '',\n        };\n        _.extend(this, this.default_settings);\n        // Allow only whitelisted configuration attributes to be overwritten\n        _.extend(this, _.pick(settings, Object.keys(this.default_settings)));\n\n        // BBB\n        if (this.prebind === true) { this.authentication = converse.PREBIND; }\n\n        if (this.authentication === converse.ANONYMOUS) {\n            if (this.auto_login && !this.jid) {\n                throw new Error(\"Config Error: you need to provide the server's \" +\n                      \"domain via the 'jid' option when using anonymous \" +\n                      \"authentication with auto_login.\");\n            }\n        }\n\n        $.fx.off = !this.animate;\n\n        // Module-level variables\n        // ----------------------\n        this.callback = callback || function () {};\n        /* When reloading the page:\n         * For new sessions, we need to send out a presence stanza to notify\n         * the server/network that we're online.\n         * When re-attaching to an existing session (e.g. via the keepalive\n         * option), we don't need to again send out a presence stanza, because\n         * it's as if \"we never left\" (see onConnectStatusChanged).\n         * https://github.com/jcbrand/converse.js/issues/521\n         */\n        this.send_initial_presence = true;\n        this.msg_counter = 0;\n        this.user_settings = settings; // Save the user settings so that they can be used by plugins\n\n        // Module-level functions\n        // ----------------------\n        this.wrappedChatBox = function (chatbox) {\n            /* Wrap a chatbox for outside consumption (i.e. so that it can be\n             * returned via the API.\n             */\n            if (!chatbox) { return; }\n            var view = converse.chatboxviews.get(chatbox.get('id'));\n            return {\n                'close': view.close.bind(view),\n                'focus': view.focus.bind(view),\n                'get': chatbox.get.bind(chatbox),\n                'open': view.show.bind(view),\n                'set': chatbox.set.bind(chatbox)\n            };\n        };\n\n        this.generateResource = function () {\n            return '/converse.js-' + Math.floor(Math.random()*139749825).toString();\n        };\n\n        this.sendCSI = function (stat) {\n            /* Send out a Chat Status Notification (XEP-0352) */\n            if (converse.features[Strophe.NS.CSI] || true) {\n                converse.connection.send($build(stat, {xmlns: Strophe.NS.CSI}));\n                converse.inactive = (stat === converse.INACTIVE) ? true : false;\n            }\n        };\n\n        this.onUserActivity = function () {\n            /* Resets counters and flags relating to CSI and auto_away/auto_xa */\n            if (converse.idle_seconds > 0) {\n                converse.idle_seconds = 0;\n            }\n            if (!converse.connection.authenticated) {\n                // We can't send out any stanzas when there's no authenticated connection.\n                // converse can happen when the connection reconnects.\n                return;\n            }\n            if (converse.inactive) {\n                converse.sendCSI(converse.ACTIVE);\n            }\n            if (converse.auto_changed_status === true) {\n                converse.auto_changed_status = false;\n                // XXX: we should really remember the original state here, and\n                // then set it back to that...\n                converse.xmppstatus.setStatus(converse.default_state);\n            }\n        };\n\n        this.onEverySecond = function () {\n            /* An interval handler running every second.\n             * Used for CSI and the auto_away and auto_xa features.\n             */\n            if (!converse.connection.authenticated) {\n                // We can't send out any stanzas when there's no authenticated connection.\n                // This can happen when the connection reconnects.\n                return;\n            }\n            var stat = converse.xmppstatus.getStatus();\n            converse.idle_seconds++;\n            if (converse.csi_waiting_time > 0 &&\n                    converse.idle_seconds > converse.csi_waiting_time &&\n                    !converse.inactive) {\n                converse.sendCSI(converse.INACTIVE);\n            }\n            if (converse.auto_away > 0 &&\n                    converse.idle_seconds > converse.auto_away &&\n                    stat !== 'away' && stat !== 'xa') {\n                converse.auto_changed_status = true;\n                converse.xmppstatus.setStatus('away');\n            } else if (converse.auto_xa > 0 &&\n                    converse.idle_seconds > converse.auto_xa && stat !== 'xa') {\n                converse.auto_changed_status = true;\n                converse.xmppstatus.setStatus('xa');\n            }\n        };\n\n        this.registerIntervalHandler = function () {\n            /* Set an interval of one second and register a handler for it.\n             * Required for the auto_away, auto_xa and csi_waiting_time features.\n             */\n            if (converse.auto_away < 1 && converse.auto_xa < 1 && converse.csi_waiting_time < 1) {\n                // Waiting time of less then one second means features aren't used.\n                return;\n            }\n            converse.idle_seconds = 0;\n            converse.auto_changed_status = false; // Was the user's status changed by converse.js?\n            $(window).on('click mousemove keypress focus'+unloadevent, converse.onUserActivity);\n            converse.everySecondTrigger = window.setInterval(converse.onEverySecond, 1000);\n        };\n\n        this.giveFeedback = function (subject, klass, message) {\n            $('.conn-feedback').each(function (idx, el) {\n                var $el = $(el);\n                $el.addClass('conn-feedback').text(subject);\n                if (klass) {\n                    $el.addClass(klass);\n                } else {\n                    $el.removeClass('error');\n                }\n            });\n            converse.emit('feedback', {\n                'klass': klass,\n                'message': message,\n                'subject': subject\n            });\n        };\n\n        this.rejectPresenceSubscription = function (jid, message) {\n            /* Reject or cancel another user's subscription to our presence updates.\n             *  Parameters:\n             *    (String) jid - The Jabber ID of the user whose subscription\n             *      is being canceled.\n             *    (String) message - An optional message to the user\n             */\n            var pres = $pres({to: jid, type: \"unsubscribed\"});\n            if (message && message !== \"\") { pres.c(\"status\").t(message); }\n            converse.connection.send(pres);\n        };\n\n\n        this.reconnect = _.debounce(function (condition) {\n            converse.log('The connection has dropped, attempting to reconnect.');\n            converse.giveFeedback(\n                __(\"Reconnecting\"),\n                'warn',\n                __('The connection has dropped, attempting to reconnect.')\n            );\n            converse.connection.reconnecting = true;\n            converse.connection.disconnect('re-connecting');\n            converse._tearDown();\n            converse.logIn(null, true);\n        }, 1000, {'leading': true});\n\n        this.disconnect = function () {\n            delete converse.connection.reconnecting;\n            converse.connection.reset();\n            converse._tearDown();\n            converse.chatboxviews.closeAllChatBoxes();\n            converse.emit('disconnected');\n            converse.log('DISCONNECTED');\n            return 'disconnected';\n        };\n\n        this.onDisconnected = function (condition) {\n            if (_.includes([converse.LOGOUT, Strophe.Status.AUTHFAIL], converse.disconnection_cause) ||\n                    converse.disconnection_reason === \"host-unknown\" ||\n                    !converse.auto_reconnect) {\n                return this.disconnect();\n            }\n            if (converse.disconnection_cause === Strophe.Status.CONNFAIL) {\n                converse.reconnect(condition);\n                converse.log('RECONNECTING');\n            } else if (converse.disconnection_cause === Strophe.Status.DISCONNECTING ||\n                        converse.disconnection_cause === Strophe.Status.DISCONNECTED) {\n                window.setTimeout(_.partial(converse.reconnect, condition), 3000);\n                converse.log('RECONNECTING IN 3 SECONDS');\n            }\n            converse.emit('reconnecting');\n            return 'reconnecting';\n        };\n\n        this.setDisconnectionCause = function (cause, reason, override) {\n            if (_.isUndefined(converse.disconnection_cause) || override) {\n                converse.disconnection_cause = cause;\n                converse.disconnection_reason = reason;\n            }\n        };\n\n        this.onConnectStatusChanged = function (status, condition) {\n            converse.log(\"Status changed to: \"+PRETTY_CONNECTION_STATUS[status]);\n            if (status === Strophe.Status.CONNECTED || status === Strophe.Status.ATTACHED) {\n                // By default we always want to send out an initial presence stanza.\n                converse.send_initial_presence = true;\n                delete converse.disconnection_cause;\n                delete converse.disconnection_reason;\n                if (converse.connection.reconnecting) {\n                    converse.log(status === Strophe.Status.CONNECTED ? 'Reconnected' : 'Reattached');\n                    converse.onConnected(true);\n                } else {\n                    converse.log(status === Strophe.Status.CONNECTED ? 'Connected' : 'Attached');\n                    if (converse.connection.restored) {\n                        // No need to send an initial presence stanza when\n                        // we're restoring an existing session.\n                        converse.send_initial_presence = false;\n                    }\n                    converse.onConnected();\n                }\n            } else if (status === Strophe.Status.DISCONNECTED) {\n                converse.setDisconnectionCause(status, condition);\n                converse.onDisconnected(condition);\n            } else if (status === Strophe.Status.ERROR) {\n                converse.giveFeedback(\n                    __('Connection error'), 'error',\n                    __('An error occurred while connecting to the chat server.')\n                );\n            } else if (status === Strophe.Status.CONNECTING) {\n                converse.giveFeedback(__('Connecting'));\n            } else if (status === Strophe.Status.AUTHENTICATING) {\n                converse.giveFeedback(__('Authenticating'));\n            } else if (status === Strophe.Status.AUTHFAIL) {\n                converse.giveFeedback(__('Authentication Failed'), 'error');\n                converse.connection.disconnect();\n                converse.setDisconnectionCause(status, condition, true);\n            } else if (status === Strophe.Status.CONNFAIL) {\n                converse.giveFeedback(\n                    __('Connection failed'), 'error',\n                    __('An error occurred while connecting to the chat server: '+condition)\n                );\n                converse.setDisconnectionCause(status, condition);\n            } else if (status === Strophe.Status.DISCONNECTING) {\n                converse.setDisconnectionCause(status, condition);\n            }\n        };\n\n        this.updateMsgCounter = function () {\n            if (this.msg_counter > 0) {\n                if (document.title.search(/^Messages \\(\\d+\\) /) === -1) {\n                    document.title = \"Messages (\" + this.msg_counter + \") \" + document.title;\n                } else {\n                    document.title = document.title.replace(/^Messages \\(\\d+\\) /, \"Messages (\" + this.msg_counter + \") \");\n                }\n            } else if (document.title.search(/^Messages \\(\\d+\\) /) !== -1) {\n                document.title = document.title.replace(/^Messages \\(\\d+\\) /, \"\");\n            }\n        };\n\n        this.incrementMsgCounter = function () {\n            this.msg_counter += 1;\n            this.updateMsgCounter();\n        };\n\n        this.clearMsgCounter = function () {\n            this.msg_counter = 0;\n            this.updateMsgCounter();\n        };\n\n        this.initStatus = function () {\n            var deferred = new $.Deferred();\n            this.xmppstatus = new this.XMPPStatus();\n            var id = b64_sha1('converse.xmppstatus-'+converse.bare_jid);\n            this.xmppstatus.id = id; // Appears to be necessary for backbone.browserStorage\n            this.xmppstatus.browserStorage = new Backbone.BrowserStorage[converse.storage](id);\n            this.xmppstatus.fetch({\n                success: deferred.resolve,\n                error: deferred.resolve\n            });\n            converse.emit('statusInitialized');\n            return deferred.promise();\n        };\n\n        this.initSession = function () {\n            this.session = new this.Session();\n            var id = b64_sha1('converse.bosh-session');\n            this.session.id = id; // Appears to be necessary for backbone.browserStorage\n            this.session.browserStorage = new Backbone.BrowserStorage[converse.storage](id);\n            this.session.fetch();\n        };\n\n        this.clearSession = function () {\n            if (!_.isUndefined(this.roster)) {\n                this.roster.browserStorage._clear();\n            }\n            this.session.browserStorage._clear();\n        };\n\n        this.logOut = function () {\n            converse.setDisconnectionCause(converse.LOGOUT, undefined, true);\n            if (typeof converse.connection !== 'undefined') {\n                converse.connection.disconnect();\n            }\n            converse.chatboxviews.closeAllChatBoxes();\n            converse.clearSession();\n            converse._tearDown();\n            converse.emit('logout');\n        };\n\n        this.saveWindowState = function (ev, hidden) {\n            // XXX: eventually we should be able to just use\n            // document.visibilityState (when we drop support for older\n            // browsers).\n            var state;\n            var v = \"visible\", h = \"hidden\",\n                event_map = {\n                    'focus': v,\n                    'focusin': v,\n                    'pageshow': v,\n                    'blur': h,\n                    'focusout': h,\n                    'pagehide': h\n                };\n            ev = ev || document.createEvent('Events');\n            if (ev.type in event_map) {\n                state = event_map[ev.type];\n            } else {\n                state = document[hidden] ? \"hidden\" : \"visible\";\n            }\n            if (state  === 'visible') {\n                converse.clearMsgCounter();\n            }\n            converse.windowState = state;\n        };\n\n        this.registerGlobalEventHandlers = function () {\n            // Taken from:\n            // http://stackoverflow.com/questions/1060008/is-there-a-way-to-detect-if-a-browser-window-is-not-currently-active\n            var hidden = \"hidden\";\n            // Standards:\n            if (hidden in document) {\n                document.addEventListener(\"visibilitychange\", _.partial(converse.saveWindowState, _, hidden));\n            } else if ((hidden = \"mozHidden\") in document) {\n                document.addEventListener(\"mozvisibilitychange\", _.partial(converse.saveWindowState, _, hidden));\n            } else if ((hidden = \"webkitHidden\") in document) {\n                document.addEventListener(\"webkitvisibilitychange\", _.partial(converse.saveWindowState, _, hidden));\n            } else if ((hidden = \"msHidden\") in document) {\n                document.addEventListener(\"msvisibilitychange\", _.partial(converse.saveWindowState, _, hidden));\n            } else if (\"onfocusin\" in document) {\n                // IE 9 and lower:\n                document.onfocusin = document.onfocusout = _.partial(converse.saveWindowState, _, hidden);\n            } else {\n                // All others:\n                window.onpageshow = window.onpagehide = window.onfocus = window.onblur = _.partial(converse.saveWindowState, _, hidden);\n            }\n            // set the initial state (but only if browser supports the Page Visibility API)\n            if( document[hidden] !== undefined ) {\n                _.partial(converse.saveWindowState, _, hidden)({type: document[hidden] ? \"blur\" : \"focus\"});\n            }\n        };\n\n        this.enableCarbons = function () {\n            /* Ask the XMPP server to enable Message Carbons\n             * See XEP-0280 https://xmpp.org/extensions/xep-0280.html#enabling\n             */\n            if (!this.message_carbons || this.session.get('carbons_enabled')) {\n                return;\n            }\n            var carbons_iq = new Strophe.Builder('iq', {\n                from: this.connection.jid,\n                id: 'enablecarbons',\n                type: 'set'\n              })\n              .c('enable', {xmlns: Strophe.NS.CARBONS});\n            this.connection.addHandler(function (iq) {\n                if ($(iq).find('error').length > 0) {\n                    converse.log('ERROR: An error occured while trying to enable message carbons.');\n                } else {\n                    this.session.save({carbons_enabled: true});\n                    converse.log('Message carbons have been enabled.');\n                }\n            }.bind(this), null, \"iq\", null, \"enablecarbons\");\n            this.connection.send(carbons_iq);\n        };\n\n        this.initRoster = function () {\n            /* Initialize the Bakcbone collections that represent the contats\n             * roster and the roster groups.\n             */\n            converse.roster = new converse.RosterContacts();\n            converse.roster.browserStorage = new Backbone.BrowserStorage.session(\n                b64_sha1('converse.contacts-'+converse.bare_jid));\n            converse.rostergroups = new converse.RosterGroups();\n            converse.rostergroups.browserStorage = new Backbone.BrowserStorage.session(\n                b64_sha1('converse.roster.groups'+converse.bare_jid));\n            converse.emit('rosterInitialized');\n        };\n\n        this.populateRoster = function () {\n            /* Fetch all the roster groups, and then the roster contacts.\n             * Emit an event after fetching is done in each case.\n             */\n            converse.rostergroups.fetchRosterGroups().then(function () {\n                converse.emit('rosterGroupsFetched');\n                converse.roster.fetchRosterContacts().then(function () {\n                    converse.emit('rosterContactsFetched');\n                    converse.sendInitialPresence();\n                });\n            });\n        };\n\n        this.unregisterPresenceHandler = function () {\n            if (typeof converse.presence_ref !== 'undefined') {\n                converse.connection.deleteHandler(converse.presence_ref);\n                delete converse.presence_ref;\n            }\n        };\n\n        this.registerPresenceHandler = function () {\n            converse.unregisterPresenceHandler();\n            converse.presence_ref = converse.connection.addHandler(\n                function (presence) {\n                    converse.roster.presenceHandler(presence);\n                    return true;\n                }, null, 'presence', null);\n        };\n\n\n        this.sendInitialPresence = function () {\n            if (converse.send_initial_presence) {\n                converse.xmppstatus.sendPresence();\n            }\n        };\n\n        this.onStatusInitialized = function (reconnecting) {\n            /* Continue with session establishment (e.g. fetching chat boxes,\n             * populating the roster etc.) necessary once the connection has\n             * been established.\n             */\n            if (reconnecting) {\n                // No need to recreate the roster, otherwise we lose our\n                // cached data. However we still emit an event, to give\n                // event handlers a chance to register views for the\n                // roster and its groups, before we start populating.\n                converse.emit('rosterReadyAfterReconnection');\n            } else {\n                converse.registerIntervalHandler();\n                converse.initRoster();\n            }\n            // First set up chat boxes, before populating the roster, so that\n            // the controlbox is properly set up and ready for the rosterview.\n            converse.chatboxes.onConnected();\n            converse.populateRoster();\n            converse.registerPresenceHandler();\n            converse.giveFeedback(__('Contacts'));\n            if (reconnecting) {\n                converse.xmppstatus.sendPresence();\n            } else {\n                init_deferred.resolve();\n                converse.emit('initialized');\n            }\n        };\n\n        this.setUserJid = function () {\n            converse.jid = converse.connection.jid;\n            converse.bare_jid = Strophe.getBareJidFromJid(converse.connection.jid);\n            converse.resource = Strophe.getResourceFromJid(converse.connection.jid);\n            converse.domain = Strophe.getDomainFromJid(converse.connection.jid);\n        };\n\n        this.onConnected = function (reconnecting) {\n            /* Called as soon as a new connection has been established, either\n             * by logging in or by attaching to an existing BOSH session.\n             */\n            // Solves problem of returned PubSub BOSH response not received\n            // by browser.\n            converse.connection.flush();\n\n            converse.setUserJid();\n            converse.enableCarbons();\n\n            // If there's no xmppstatus obj, then we were never connected to\n            // begin with, so we set reconnecting to false.\n            reconnecting = _.isUndefined(converse.xmppstatus) ? false : reconnecting;\n\n            if (reconnecting) {\n                converse.onStatusInitialized(true);\n                converse.emit('reconnected');\n            } else {\n                // There might be some open chat boxes. We don't\n                // know whether these boxes are of the same account or not, so we\n                // close them now.\n                converse.chatboxviews.closeAllChatBoxes();\n                converse.features = new converse.Features();\n                converse.initStatus().done(_.partial(converse.onStatusInitialized, false));\n                converse.emit('connected');\n            }\n        };\n\n        this.RosterContact = Backbone.Model.extend({\n\n            initialize: function (attributes, options) {\n                var jid = attributes.jid;\n                var bare_jid = Strophe.getBareJidFromJid(jid);\n                var resource = Strophe.getResourceFromJid(jid);\n                attributes.jid = bare_jid;\n                this.set(_.extend({\n                    'id': bare_jid,\n                    'jid': bare_jid,\n                    'fullname': bare_jid,\n                    'chat_status': 'offline',\n                    'user_id': Strophe.getNodeFromJid(jid),\n                    'resources': resource ? [resource] : [],\n                    'groups': [],\n                    'image_type': 'image/png',\n                    'image': \"iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gwHCy455JBsggAABkJJREFUeNrtnM1PE1sUwHvvTD8otWLHST/Gimi1CEgr6M6FEWuIBo2pujDVsNDEP8GN/4MbN7oxrlipG2OCgZgYlxAbkRYw1KqkIDRCSkM7nXvvW8x7vjyNeQ9m7p1p3z1LQk/v/Dhz7vkEXL161cHl9wI5Ag6IA+KAOCAOiAPigDggLhwQB2S+iNZ+PcYY/SWEEP2HAAAIoSAIoihCCP+ngDDGtVotGAz29/cfOXJEUZSOjg6n06lp2sbGRqlUWlhYyGazS0tLbrdbEASrzgksyeYJId3d3el0uqenRxRFAAAA4KdfIIRgjD9+/Pj8+fOpqSndslofEIQwHA6Pjo4mEon//qmFhYXHjx8vLi4ihBgDEnp7e9l8E0Jo165dQ0NDd+/eDYVC2/qsJElDQ0OEkKWlpa2tLZamxAhQo9EIBoOjo6MXL17csZLe3l5FUT59+lQul5l5JRaAVFWNRqN37tw5ceKEQVWRSOTw4cOFQuHbt2+iKLYCIISQLMu3b99OJpOmKAwEAgcPHszn8+vr6wzsiG6UQQhxuVyXLl0aGBgwUW0sFstkMl6v90fo1KyAMMYDAwPnzp0zXfPg4GAqlWo0Gk0MiBAiy/L58+edTqf5Aa4onj59OhaLYYybFRCEMBaL0fNxBw4cSCQStN0QRUBut3t4eJjq6U+dOiVJElVPRBFQIBDo6+ujCqirqyscDlONGykC2lYyYSR6pBoQQapHZwAoHo/TuARYAOrs7GQASFEUqn6aIiBJkhgA6ujooFpUo6iaTa7koFwnaoWadLNe81tbWwzoaJrWrICWl5cZAFpbW6OabVAEtLi4yABQsVjUNK0pAWWzWQaAcrlcswKanZ1VVZUqHYRQEwOq1Wpv3ryhCmh6erpcLjdrNl+v1ycnJ+l5UELI27dvv3//3qxxEADgy5cvExMT9Mznw4cPtFtAdAPFarU6Pj5eKpVM17yxsfHy5cvV1VXazXu62gVBKBQKT58+rdVqJqrFGL948eLdu3dU8/g/H4FBUaJYLAqC0NPTY9brMD4+PjY25mDSracOCABACJmZmXE6nUePHjWu8NWrV48ePSKEsGlAs7Agfd5nenq6Wq0mk0kjDzY2NvbkyRMIIbP2PLvhBUEQ8vl8NpuNx+M+n29bzhVjvLKycv/+/YmJCcazQuwA6YzW1tYmJyf1SY+2trZ/rRk1Go1SqfT69esHDx4UCgVmNaa/zZ/9ABUhRFXVYDB48uTJeDweiUQkSfL7/T9MA2NcqVTK5fLy8vL8/PzU1FSxWHS5XJaM4wGr9sUwxqqqer3eUCgkSZJuUBBCfTRvc3OzXC6vrKxUKhWn02nhCJ5lM4oQQo/HgxD6+vXr58+fHf8sDOp+HQDg8XgclorFU676dKLlo6yWRdItIBwQB8QBcUCtfosRQjRNQwhhjPUC4w46WXryBSHU1zgEQWBz99EFhDGu1+t+v//48ePxeFxRlD179ng8nh0Efgiher2+vr6ur3HMzMysrq7uTJVdACGEurq6Ll++nEgkPB7Pj9jPoDHqOxyqqubz+WfPnuVyuV9XPeyeagAAAoHArVu3BgcHab8CuVzu4cOHpVKJUnfA5GweY+xyuc6cOXPv3r1IJMLAR8iyPDw8XK/Xi8Wiqqqmm5KZgBBC7e3tN27cuHbtGuPVpf7+/lAoNDs7W61WzfVKpgHSSzw3b95MpVKW3MfRaDQSiczNzVUqFRMZmQOIEOL1eq9fv3727FlL1t50URRFluX5+flqtWpWEGAOIFEUU6nUlStXLKSjy759+xwOx9zcnKZpphzGHMzhcDiTydgk9r1w4YIp7RPTAAmCkMlk2FeLf/tIEKbTab/fbwtAhJBoNGrutpNx6e7uPnTokC1eMU3T0um0DZPMkZER6wERQnw+n/FFSxpy7Nix3bt3WwwIIcRgIWnHkkwmjecfRgGx7DtuV/r6+iwGhDHev3+/bQF1dnYaH6E2CkiWZdsC2rt3r8WAHA5HW1ubbQGZcjajgOwTH/4qNko1Wlg4IA6IA+KAOKBWBUQIsfNojyliKIoRRfH9+/dut9umf3wzpoUNNQ4BAJubmwz+ic+OxefzWWlBhJD29nbug7iT5sIBcUAcEAfEAXFAHBAHxOVn+QMrmWpuPZx12gAAAABJRU5ErkJggg==\",\n                    'status': ''\n                }, attributes));\n\n                this.on('destroy', function () { this.removeFromRoster(); }.bind(this));\n                this.on('change:chat_status', function (item) {\n                    converse.emit('contactStatusChanged', item.attributes);\n                });\n            },\n\n            subscribe: function (message) {\n                /* Send a presence subscription request to this roster contact\n                 *\n                 * Parameters:\n                 *    (String) message - An optional message to explain the\n                 *      reason for the subscription request.\n                 */\n                this.save('ask', \"subscribe\"); // ask === 'subscribe' Means we have ask to subscribe to them.\n                var pres = $pres({to: this.get('jid'), type: \"subscribe\"});\n                if (message && message !== \"\") {\n                    pres.c(\"status\").t(message).up();\n                }\n                var nick = converse.xmppstatus.get('fullname');\n                if (nick && nick !== \"\") {\n                    pres.c('nick', {'xmlns': Strophe.NS.NICK}).t(nick).up();\n                }\n                converse.connection.send(pres);\n                return this;\n            },\n\n            ackSubscribe: function () {\n                /* Upon receiving the presence stanza of type \"subscribed\",\n                 * the user SHOULD acknowledge receipt of that subscription\n                 * state notification by sending a presence stanza of type\n                 * \"subscribe\" to the contact\n                 */\n                converse.connection.send($pres({\n                    'type': 'subscribe',\n                    'to': this.get('jid')\n                }));\n            },\n\n            ackUnsubscribe: function (jid) {\n                /* Upon receiving the presence stanza of type \"unsubscribed\",\n                 * the user SHOULD acknowledge receipt of that subscription state\n                 * notification by sending a presence stanza of type \"unsubscribe\"\n                 * this step lets the user's server know that it MUST no longer\n                 * send notification of the subscription state change to the user.\n                 *  Parameters:\n                 *    (String) jid - The Jabber ID of the user who is unsubscribing\n                 */\n                converse.connection.send($pres({'type': 'unsubscribe', 'to': this.get('jid')}));\n                this.destroy(); // Will cause removeFromRoster to be called.\n            },\n\n            unauthorize: function (message) {\n                /* Unauthorize this contact's presence subscription\n                 * Parameters:\n                 *   (String) message - Optional message to send to the person being unauthorized\n                 */\n                converse.rejectPresenceSubscription(this.get('jid'), message);\n                return this;\n            },\n\n            authorize: function (message) {\n                /* Authorize presence subscription\n                 * Parameters:\n                 *   (String) message - Optional message to send to the person being authorized\n                 */\n                var pres = $pres({to: this.get('jid'), type: \"subscribed\"});\n                if (message && message !== \"\") {\n                    pres.c(\"status\").t(message);\n                }\n                converse.connection.send(pres);\n                return this;\n            },\n\n            removeResource: function (resource) {\n                var resources = this.get('resources'), idx;\n                if (resource) {\n                    idx = _.indexOf(resources, resource);\n                    if (idx !== -1) {\n                        resources.splice(idx, 1);\n                        this.save({'resources': resources});\n                    }\n                }\n                else {\n                    // if there is no resource (resource is null), it probably\n                    // means that the user is now completely offline. To make sure\n                    // that there isn't any \"ghost\" resources left, we empty the array\n                    this.save({'resources': []});\n                    return 0;\n                }\n                return resources.length;\n            },\n\n            removeFromRoster: function (callback) {\n                /* Instruct the XMPP server to remove this contact from our roster\n                 * Parameters:\n                 *   (Function) callback\n                 */\n                var iq = $iq({type: 'set'})\n                    .c('query', {xmlns: Strophe.NS.ROSTER})\n                    .c('item', {jid: this.get('jid'), subscription: \"remove\"});\n                converse.connection.sendIQ(iq, callback, callback);\n                return this;\n            }\n        });\n\n\n        this.RosterContacts = Backbone.Collection.extend({\n            model: converse.RosterContact,\n\n            comparator: function (contact1, contact2) {\n                var name1, name2;\n                var status1 = contact1.get('chat_status') || 'offline';\n                var status2 = contact2.get('chat_status') || 'offline';\n                if (converse.STATUS_WEIGHTS[status1] === converse.STATUS_WEIGHTS[status2]) {\n                    name1 = contact1.get('fullname').toLowerCase();\n                    name2 = contact2.get('fullname').toLowerCase();\n                    return name1 < name2 ? -1 : (name1 > name2? 1 : 0);\n                } else  {\n                    return converse.STATUS_WEIGHTS[status1] < converse.STATUS_WEIGHTS[status2] ? -1 : 1;\n                }\n            },\n\n            fetchRosterContacts: function () {\n                /* Fetches the roster contacts, first by trying the\n                 * sessionStorage cache, and if that's empty, then by querying\n                 * the XMPP server.\n                 *\n                 * Returns a promise which resolves once the contacts have been\n                 * fetched.\n                 */\n                var deferred = new $.Deferred();\n                this.fetch({\n                    add: true,\n                    success: function (collection) {\n                        if (collection.length === 0) {\n                            /* We don't have any roster contacts stored in sessionStorage,\n                             * so lets fetch the roster from the XMPP server. We pass in\n                             * 'sendPresence' as callback method, because after initially\n                             * fetching the roster we are ready to receive presence\n                             * updates from our contacts.\n                             */\n                            converse.send_initial_presence = true;\n                            converse.roster.fetchFromServer(deferred.resolve);\n                        } else {\n                            converse.emit('cachedRoster', collection);\n                            deferred.resolve();\n                        }\n                    }\n                });\n                return deferred.promise();\n            },\n\n            subscribeToSuggestedItems: function (msg) {\n                $(msg).find('item').each(function (i, items) {\n                    if (this.getAttribute('action') === 'add') {\n                        converse.roster.addAndSubscribe(\n                                this.getAttribute('jid'), null, converse.xmppstatus.get('fullname'));\n                    }\n                });\n                return true;\n            },\n\n            isSelf: function (jid) {\n                return (Strophe.getBareJidFromJid(jid) === Strophe.getBareJidFromJid(converse.connection.jid));\n            },\n\n            addAndSubscribe: function (jid, name, groups, message, attributes) {\n                /* Add a roster contact and then once we have confirmation from\n                 * the XMPP server we subscribe to that contact's presence updates.\n                 *  Parameters:\n                 *    (String) jid - The Jabber ID of the user being added and subscribed to.\n                 *    (String) name - The name of that user\n                 *    (Array of Strings) groups - Any roster groups the user might belong to\n                 *    (String) message - An optional message to explain the\n                 *      reason for the subscription request.\n                 *    (Object) attributes - Any additional attributes to be stored on the user's model.\n                 */\n                this.addContact(jid, name, groups, attributes).done(function (contact) {\n                    if (contact instanceof converse.RosterContact) {\n                        contact.subscribe(message);\n                    }\n                });\n            },\n\n            sendContactAddIQ: function (jid, name, groups, callback, errback) {\n                /*  Send an IQ stanza to the XMPP server to add a new roster contact.\n                 *\n                 *  Parameters:\n                 *    (String) jid - The Jabber ID of the user being added\n                 *    (String) name - The name of that user\n                 *    (Array of Strings) groups - Any roster groups the user might belong to\n                 *    (Function) callback - A function to call once the IQ is returned\n                 *    (Function) errback - A function to call if an error occured\n                 */\n                name = _.isEmpty(name)? jid: name;\n                var iq = $iq({type: 'set'})\n                    .c('query', {xmlns: Strophe.NS.ROSTER})\n                    .c('item', { jid: jid, name: name });\n                _.map(groups, function (group) { iq.c('group').t(group).up(); });\n                converse.connection.sendIQ(iq, callback, errback);\n            },\n\n            addContact: function (jid, name, groups, attributes) {\n                /* Adds a RosterContact instance to converse.roster and\n                 * registers the contact on the XMPP server.\n                 * Returns a promise which is resolved once the XMPP server has\n                 * responded.\n                 *\n                 *  Parameters:\n                 *    (String) jid - The Jabber ID of the user being added and subscribed to.\n                 *    (String) name - The name of that user\n                 *    (Array of Strings) groups - Any roster groups the user might belong to\n                 *    (Object) attributes - Any additional attributes to be stored on the user's model.\n                 */\n                var deferred = new $.Deferred();\n                groups = groups || [];\n                name = _.isEmpty(name)? jid: name;\n                this.sendContactAddIQ(jid, name, groups,\n                    function (iq) {\n                        var contact = this.create(_.extend({\n                            ask: undefined,\n                            fullname: name,\n                            groups: groups,\n                            jid: jid,\n                            requesting: false,\n                            subscription: 'none'\n                        }, attributes), {sort: false});\n                        deferred.resolve(contact);\n                    }.bind(this),\n                    function (err) {\n                        alert(__(\"Sorry, there was an error while trying to add \"+name+\" as a contact.\"));\n                        converse.log(err);\n                        deferred.resolve(err);\n                    }\n                );\n                return deferred.promise();\n            },\n\n            addResource: function (bare_jid, resource) {\n                var item = this.get(bare_jid),\n                    resources;\n                if (item) {\n                    resources = item.get('resources');\n                    if (resources) {\n                        if (_.indexOf(resources, resource) === -1) {\n                            resources.push(resource);\n                            item.set({'resources': resources});\n                        }\n                    } else  {\n                        item.set({'resources': [resource]});\n                    }\n                }\n            },\n\n            subscribeBack: function (bare_jid) {\n                var contact = this.get(bare_jid);\n                if (contact instanceof converse.RosterContact) {\n                    contact.authorize().subscribe();\n                } else {\n                    // Can happen when a subscription is retried or roster was deleted\n                    this.addContact(bare_jid, '', [], { 'subscription': 'from' }).done(function (contact) {\n                        if (contact instanceof converse.RosterContact) {\n                            contact.authorize().subscribe();\n                        }\n                    });\n                }\n            },\n\n            getNumOnlineContacts: function () {\n                var count = 0,\n                    ignored = ['offline', 'unavailable'],\n                    models = this.models,\n                    models_length = models.length,\n                    i;\n                if (converse.show_only_online_users) {\n                    ignored = _.union(ignored, ['dnd', 'xa', 'away']);\n                }\n                for (i=0; i<models_length; i++) {\n                    if (_.indexOf(ignored, models[i].get('chat_status')) === -1) {\n                        count++;\n                    }\n                }\n                return count;\n            },\n\n            onRosterPush: function (iq) {\n                /* Handle roster updates from the XMPP server.\n                 * See: https://xmpp.org/rfcs/rfc6121.html#roster-syntax-actions-push\n                 *\n                 * Parameters:\n                 *    (XMLElement) IQ - The IQ stanza received from the XMPP server.\n                 */\n                var id = iq.getAttribute('id');\n                var from = iq.getAttribute('from');\n                if (from && from !== \"\" && Strophe.getBareJidFromJid(from) !== converse.bare_jid) {\n                    // Receiving client MUST ignore stanza unless it has no from or from = user's bare JID.\n                    // XXX: Some naughty servers apparently send from a full\n                    // JID so we need to explicitly compare bare jids here.\n                    // https://github.com/jcbrand/converse.js/issues/493\n                    converse.connection.send(\n                        $iq({type: 'error', id: id, from: converse.connection.jid})\n                            .c('error', {'type': 'cancel'})\n                            .c('service-unavailable', {'xmlns': Strophe.NS.ROSTER })\n                    );\n                    return true;\n                }\n                converse.connection.send($iq({type: 'result', id: id, from: converse.connection.jid}));\n                $(iq).children('query').find('item').each(function (idx, item) {\n                    this.updateContact(item);\n                }.bind(this));\n\n                converse.emit('rosterPush', iq);\n                return true;\n            },\n\n            fetchFromServer: function (callback) {\n                /* Get the roster from the XMPP server */\n                var iq = $iq({type: 'get', 'id': converse.connection.getUniqueId('roster')})\n                        .c('query', {xmlns: Strophe.NS.ROSTER});\n                return converse.connection.sendIQ(iq, function () {\n                        this.onReceivedFromServer.apply(this, arguments);\n                        callback.apply(this, arguments);\n                    }.bind(this));\n            },\n\n            onReceivedFromServer: function (iq) {\n                /* An IQ stanza containing the roster has been received from\n                 * the XMPP server.\n                 */\n                $(iq).children('query').find('item').each(function (idx, item) {\n                    this.updateContact(item);\n                }.bind(this));\n                converse.emit('roster', iq);\n            },\n\n            updateContact: function (item) {\n                /* Update or create RosterContact models based on items\n                 * received in the IQ from the server.\n                 */\n                var jid = item.getAttribute('jid');\n                if (this.isSelf(jid)) { return; }\n                var groups = [],\n                    contact = this.get(jid),\n                    ask = item.getAttribute(\"ask\"),\n                    subscription = item.getAttribute(\"subscription\");\n                $.map(item.getElementsByTagName('group'), function (group) {\n                    groups.push(Strophe.getText(group));\n                });\n                if (!contact) {\n                    if ((subscription === \"none\" && ask === null) || (subscription === \"remove\")) {\n                        return; // We're lazy when adding contacts.\n                    }\n                    this.create({\n                        ask: ask,\n                        fullname: item.getAttribute(\"name\") || jid,\n                        groups: groups,\n                        jid: jid,\n                        subscription: subscription\n                    }, {sort: false});\n                } else {\n                    if (subscription === \"remove\") {\n                        return contact.destroy(); // will trigger removeFromRoster\n                    }\n                    // We only find out about requesting contacts via the\n                    // presence handler, so if we receive a contact\n                    // here, we know they aren't requesting anymore.\n                    // see docs/DEVELOPER.rst\n                    contact.save({\n                        subscription: subscription,\n                        ask: ask,\n                        requesting: null,\n                        groups: groups\n                    });\n                }\n            },\n\n            createRequestingContact: function (presence) {\n                /* Creates a Requesting Contact.\n                 *\n                 * Note: this method gets completely overridden by converse-vcard.js\n                 */\n                var bare_jid = Strophe.getBareJidFromJid(presence.getAttribute('from'));\n                var nick = $(presence).children('nick[xmlns='+Strophe.NS.NICK+']').text();\n                var user_data = {\n                    jid: bare_jid,\n                    subscription: 'none',\n                    ask: null,\n                    requesting: true,\n                    fullname: nick || bare_jid,\n                };\n                this.create(user_data);\n                converse.emit('contactRequest', user_data);\n            },\n\n            handleIncomingSubscription: function (presence) {\n                var jid = presence.getAttribute('from');\n                var bare_jid = Strophe.getBareJidFromJid(jid);\n                var contact = this.get(bare_jid);\n                if (!converse.allow_contact_requests) {\n                    converse.rejectPresenceSubscription(\n                        jid,\n                        __(\"This client does not allow presence subscriptions\")\n                    );\n                }\n                if (converse.auto_subscribe) {\n                    if ((!contact) || (contact.get('subscription') !== 'to')) {\n                        this.subscribeBack(bare_jid);\n                    } else {\n                        contact.authorize();\n                    }\n                } else {\n                    if (contact) {\n                        if (contact.get('subscription') !== 'none')  {\n                            contact.authorize();\n                        } else if (contact.get('ask') === \"subscribe\") {\n                            contact.authorize();\n                        }\n                    } else if (!contact) {\n                        this.createRequestingContact(presence);\n                    }\n                }\n            },\n\n            presenceHandler: function (presence) {\n                var $presence = $(presence),\n                    presence_type = presence.getAttribute('type');\n                if (presence_type === 'error') { return true; }\n                var jid = presence.getAttribute('from'),\n                    bare_jid = Strophe.getBareJidFromJid(jid),\n                    resource = Strophe.getResourceFromJid(jid),\n                    chat_status = $presence.find('show').text() || 'online',\n                    status_message = $presence.find('status'),\n                    contact = this.get(bare_jid);\n\n                if (this.isSelf(bare_jid)) {\n                    if ((converse.connection.jid !== jid) &&\n                        (presence_type !== 'unavailable') &&\n                        (converse.synchronize_availability === true ||\n                         converse.synchronize_availability === resource)) {\n                        // Another resource has changed its status and\n                        // synchronize_availability option set to update,\n                        // we'll update ours as well.\n                        converse.xmppstatus.save({'status': chat_status});\n                        if (status_message.length) {\n                            converse.xmppstatus.save({\n                                'status_message': status_message.text()\n                            });\n                        }\n                    }\n                    return;\n                } else if (($presence.find('x').attr('xmlns') || '').indexOf(Strophe.NS.MUC) === 0) {\n                    return; // Ignore MUC\n                }\n                if (contact && (status_message.text() !== contact.get('status'))) {\n                    contact.save({'status': status_message.text()});\n                }\n                if (presence_type === 'subscribed' && contact) {\n                    contact.ackSubscribe();\n                } else if (presence_type === 'unsubscribed' && contact) {\n                    contact.ackUnsubscribe();\n                } else if (presence_type === 'unsubscribe') {\n                    return;\n                } else if (presence_type === 'subscribe') {\n                    this.handleIncomingSubscription(presence);\n                } else if (presence_type === 'unavailable' && contact) {\n                    // Only set the user to offline if there aren't any\n                    // other resources still available.\n                    if (contact.removeResource(resource) === 0) {\n                        contact.save({'chat_status': \"offline\"});\n                    }\n                } else if (contact) { // presence_type is undefined\n                    this.addResource(bare_jid, resource);\n                    contact.save({'chat_status': chat_status});\n                }\n            }\n        });\n\n\n        this.RosterGroup = Backbone.Model.extend({\n            initialize: function (attributes, options) {\n                this.set(_.extend({\n                    description: DESC_GROUP_TOGGLE,\n                    state: converse.OPENED\n                }, attributes));\n                // Collection of contacts belonging to this group.\n                this.contacts = new converse.RosterContacts();\n            }\n        });\n\n\n        this.RosterGroups = Backbone.Collection.extend({\n            model: converse.RosterGroup,\n\n            fetchRosterGroups: function () {\n                /* Fetches all the roster groups from sessionStorage.\n                 *\n                 * Returns a promise which resolves once the groups have been\n                 * returned.\n                 */\n                var deferred = new $.Deferred();\n                this.fetch({\n                    silent: true, // We need to first have all groups before\n                                  // we can start positioning them, so we set\n                                  // 'silent' to true.\n                    success: deferred.resolve\n                });\n                return deferred.promise();\n            }\n        });\n\n\n        this.Message = Backbone.Model.extend({\n            defaults: function(){\n                return {\n                    msgid: converse.connection.getUniqueId()\n                };\n            }\n        });\n\n\n        this.Messages = Backbone.Collection.extend({\n            model: converse.Message,\n            comparator: 'time'\n        });\n\n\n        this.ChatBox = Backbone.Model.extend({\n\n            initialize: function () {\n                this.messages = new converse.Messages();\n                this.messages.browserStorage = new Backbone.BrowserStorage[converse.message_storage](\n                    b64_sha1('converse.messages'+this.get('jid')+converse.bare_jid));\n                this.save({\n                    // The chat_state will be set to ACTIVE once the chat box is opened\n                    // and we listen for change:chat_state, so shouldn't set it to ACTIVE here.\n                    'box_id' : b64_sha1(this.get('jid')),\n                    'chat_state': undefined,\n                    'num_unread': this.get('num_unread') || 0,\n                    'time_opened': this.get('time_opened') || moment().valueOf(),\n                    'url': '',\n                    'user_id' : Strophe.getNodeFromJid(this.get('jid'))\n                });\n            },\n\n            getMessageAttributes: function ($message, $delay, original_stanza) {\n                $delay = $delay || $message.find('delay');\n                var type = $message.attr('type'),\n                    body, stamp, time, sender, from;\n\n                if (type === 'error') {\n                    body = $message.find('error').children('text').text();\n                } else {\n                    body = $message.children('body').text();\n                }\n                var delayed = $delay.length > 0,\n                    fullname = this.get('fullname'),\n                    is_groupchat = type === 'groupchat',\n                    chat_state = $message.find(converse.COMPOSING).length && converse.COMPOSING ||\n                        $message.find(converse.PAUSED).length && converse.PAUSED ||\n                        $message.find(converse.INACTIVE).length && converse.INACTIVE ||\n                        $message.find(converse.ACTIVE).length && converse.ACTIVE ||\n                        $message.find(converse.GONE).length && converse.GONE;\n\n                if (is_groupchat) {\n                    from = Strophe.unescapeNode(Strophe.getResourceFromJid($message.attr('from')));\n                } else {\n                    from = Strophe.getBareJidFromJid($message.attr('from'));\n                }\n                if (_.isEmpty(fullname)) {\n                    fullname = from;\n                }\n                if (delayed) {\n                    stamp = $delay.attr('stamp');\n                    time = stamp;\n                } else {\n                    time = moment().format();\n                }\n                if ((is_groupchat && from === this.get('nick')) || (!is_groupchat && from === converse.bare_jid)) {\n                    sender = 'me';\n                } else {\n                    sender = 'them';\n                }\n                return {\n                    'type': type,\n                    'chat_state': chat_state,\n                    'delayed': delayed,\n                    'fullname': fullname,\n                    'message': body || undefined,\n                    'msgid': $message.attr('id'),\n                    'sender': sender,\n                    'time': time\n                };\n            },\n\n            createMessage: function ($message, $delay, original_stanza) {\n                return this.messages.create(this.getMessageAttributes.apply(this, arguments));\n            }\n        });\n\n        this.ChatBoxes = Backbone.Collection.extend({\n            model: converse.ChatBox,\n            comparator: 'time_opened',\n\n            registerMessageHandler: function () {\n                converse.connection.addHandler(this.onMessage.bind(this), null, 'message', 'chat');\n                converse.connection.addHandler(this.onErrorMessage.bind(this), null, 'message', 'error');\n            },\n\n            chatBoxMayBeShown: function (chatbox) {\n                return true;\n            },\n\n            onChatBoxesFetched: function (collection) {\n                /* Show chat boxes upon receiving them from sessionStorage\n                 *\n                 * This method gets overridden entirely in src/converse-controlbox.js\n                 * if the controlbox plugin is active.\n                 */\n                var that = this;\n                collection.each(function (chatbox) {\n                    if (that.chatBoxMayBeShown(chatbox)) {\n                        chatbox.trigger('show');\n                    }\n                });\n                converse.emit('chatBoxesFetched');\n            },\n\n            onConnected: function () {\n                this.browserStorage = new Backbone.BrowserStorage[converse.storage](\n                    b64_sha1('converse.chatboxes-'+converse.bare_jid));\n                this.registerMessageHandler();\n                this.fetch({\n                    add: true,\n                    success: this.onChatBoxesFetched.bind(this)\n                });\n            },\n\n            onErrorMessage: function (message) {\n                /* Handler method for all incoming error message stanzas\n                 */\n                // TODO: we can likely just reuse \"onMessage\" below\n                var $message = $(message),\n                    from_jid =  Strophe.getBareJidFromJid($message.attr('from'));\n                if (from_jid === converse.bare_jid) {\n                    return true;\n                }\n                // Get chat box, but only create a new one when the message has a body.\n                var chatbox = this.getChatBox(from_jid);\n                if (!chatbox) {\n                    return true;\n                }\n                chatbox.createMessage($message, null, message);\n                return true;\n            },\n\n            onMessage: function (message) {\n                /* Handler method for all incoming single-user chat \"message\"\n                 * stanzas.\n                 */\n                var $message = $(message),\n                    contact_jid, $forwarded, $delay, from_bare_jid,\n                    from_resource, is_me, msgid,\n                    chatbox, resource,\n                    from_jid = $message.attr('from'),\n                    to_jid = $message.attr('to'),\n                    to_resource = Strophe.getResourceFromJid(to_jid);\n\n                if (converse.filter_by_resource && (to_resource && to_resource !== converse.resource)) {\n                    converse.log(\n                        'onMessage: Ignoring incoming message intended for a different resource: '+to_jid,\n                        'info'\n                    );\n                    return true;\n                } else if (utils.isHeadlineMessage(message)) {\n                    // XXX: Ideally we wouldn't have to check for headline\n                    // messages, but Prosody sends headline messages with the\n                    // wrong type ('chat'), so we need to filter them out here.\n                    converse.log(\n                        \"onMessage: Ignoring incoming headline message sent with type 'chat' from JID: \"+from_jid,\n                        'info'\n                    );\n                    return true;\n                }\n                $forwarded = $message.find('forwarded');\n                if ($forwarded.length) {\n                    $message = $forwarded.children('message');\n                    $delay = $forwarded.children('delay');\n                    from_jid = $message.attr('from');\n                    to_jid = $message.attr('to');\n                }\n                from_bare_jid = Strophe.getBareJidFromJid(from_jid);\n                from_resource = Strophe.getResourceFromJid(from_jid);\n                is_me = from_bare_jid === converse.bare_jid;\n                msgid = $message.attr('id');\n                if (is_me) {\n                    // I am the sender, so this must be a forwarded message...\n                    contact_jid = Strophe.getBareJidFromJid(to_jid);\n                    resource = Strophe.getResourceFromJid(to_jid);\n                } else {\n                    contact_jid = from_bare_jid;\n                    resource = from_resource;\n                }\n                converse.emit('message', message);\n                // Get chat box, but only create a new one when the message has a body.\n                chatbox = this.getChatBox(contact_jid, $message.find('body').length > 0);\n                if (!chatbox) {\n                    return true;\n                }\n                if (msgid && chatbox.messages.findWhere({msgid: msgid})) {\n                    return true; // We already have this message stored.\n                }\n                chatbox.createMessage($message, $delay, message);\n                return true;\n            },\n\n            getChatBox: function (jid, create, attrs) {\n                /* Returns a chat box or optionally return a newly\n                 * created one if one doesn't exist.\n                 *\n                 * Parameters:\n                 *    (String) jid - The JID of the user whose chat box we want\n                 *    (Boolean) create - Should a new chat box be created if none exists?\n                 */\n                jid = jid.toLowerCase();\n                var bare_jid = Strophe.getBareJidFromJid(jid);\n                var chatbox = this.get(bare_jid);\n                if (!chatbox && create) {\n                    var roster_item = converse.roster.get(bare_jid);\n                    if (roster_item === undefined) {\n                        converse.log('Could not get roster item for JID '+bare_jid, 'error');\n                        return;\n                    }\n                    chatbox = this.create(_.extend({\n                        'id': bare_jid,\n                        'jid': bare_jid,\n                        'fullname': _.isEmpty(roster_item.get('fullname'))? jid: roster_item.get('fullname'),\n                        'image_type': roster_item.get('image_type'),\n                        'image': roster_item.get('image'),\n                        'url': roster_item.get('url')\n                    }, attrs || {}));\n                }\n                return chatbox;\n            }\n        });\n\n        this.ChatBoxViews = Backbone.Overview.extend({\n\n            initialize: function () {\n                this.model.on(\"add\", this.onChatBoxAdded, this);\n                this.model.on(\"destroy\", this.removeChat, this);\n            },\n\n            _ensureElement: function () {\n                /* Override method from backbone.js\n                 * If the #conversejs element doesn't exist, create it.\n                 */\n                if (!this.el) {\n                    var $el = $('#conversejs');\n                    if (!$el.length) {\n                        $el = $('<div id=\"conversejs\">');\n                        $('body').append($el);\n                    }\n                    $el.html('');\n                    this.setElement($el, false);\n                } else {\n                    this.setElement(_.result(this, 'el'), false);\n                }\n            },\n\n            onChatBoxAdded: function (item) {\n                // Views aren't created here, since the core code doesn't\n                // contain any views. Instead, they're created in overrides in\n                // plugins, such as in converse-chatview.js and converse-muc.js\n                return this.get(item.get('id'));\n            },\n\n            removeChat: function (item) {\n                this.remove(item.get('id'));\n            },\n\n            closeAllChatBoxes: function () {\n                /* This method gets overridden in src/converse-controlbox.js if\n                 * the controlbox plugin is active.\n                 */\n                this.each(function (view) { view.close(); });\n                return this;\n            },\n\n            chatBoxMayBeShown: function (chatbox) {\n                return this.model.chatBoxMayBeShown(chatbox);\n            },\n\n            getChatBox: function (attrs, create) {\n                var chatbox  = this.model.get(attrs.jid);\n                if (!chatbox && create) {\n                    chatbox = this.model.create(attrs, {\n                        'error': function (model, response) {\n                            converse.log(response.responseText);\n                        }\n                    });\n                }\n                return chatbox;\n            },\n\n            showChat: function (attrs) {\n                /* Find the chat box and show it (if it may be shown).\n                 * If it doesn't exist, create it.\n                 */\n                var chatbox = this.getChatBox(attrs, true);\n                if (this.chatBoxMayBeShown(chatbox)) {\n                    chatbox.trigger('show', true);\n                }\n                return chatbox;\n            }\n        });\n\n\n        this.XMPPStatus = Backbone.Model.extend({\n            initialize: function () {\n                this.set({\n                    'status' : this.getStatus()\n                });\n                this.on('change', function (item) {\n                    if (_.has(item.changed, 'status')) {\n                        converse.emit('statusChanged', this.get('status'));\n                    }\n                    if (_.has(item.changed, 'status_message')) {\n                        converse.emit('statusMessageChanged', this.get('status_message'));\n                    }\n                }.bind(this));\n            },\n\n            constructPresence: function (type, status_message) {\n                var presence;\n                type = typeof type === 'string' ? type : (this.get('status') || converse.default_state);\n                status_message = typeof status_message === 'string' ? status_message : undefined;\n                // Most of these presence types are actually not explicitly sent,\n                // but I add all of them here for reference and future proofing.\n                if ((type === 'unavailable') ||\n                        (type === 'probe') ||\n                        (type === 'error') ||\n                        (type === 'unsubscribe') ||\n                        (type === 'unsubscribed') ||\n                        (type === 'subscribe') ||\n                        (type === 'subscribed')) {\n                    presence = $pres({'type': type});\n                } else if (type === 'offline') {\n                    presence = $pres({'type': 'unavailable'});\n                } else if (type === 'online') {\n                    presence = $pres();\n                } else {\n                    presence = $pres().c('show').t(type).up();\n                }\n                if (status_message) {\n                    presence.c('status').t(status_message);\n                }\n                return presence;\n            },\n\n            sendPresence: function (type, status_message) {\n                converse.connection.send(this.constructPresence(type, status_message));\n            },\n\n            setStatus: function (value) {\n                this.sendPresence(value);\n                this.save({'status': value});\n            },\n\n            getStatus: function () {\n                return this.get('status') || converse.default_state;\n            },\n\n            setStatusMessage: function (status_message) {\n                this.sendPresence(this.getStatus(), status_message);\n                var prev_status = this.get('status_message');\n                this.save({'status_message': status_message});\n                if (this.xhr_custom_status) {\n                    $.ajax({\n                        url:  this.xhr_custom_status_url,\n                        type: 'POST',\n                        data: {'msg': status_message}\n                    });\n                }\n                if (prev_status === status_message) {\n                    this.trigger(\"update-status-ui\", this);\n                }\n            }\n        });\n\n        this.Session = Backbone.Model; // General session settings to be saved to sessionStorage.\n        this.Feature = Backbone.Model;\n        this.Features = Backbone.Collection.extend({\n            /* Service Discovery\n             * -----------------\n             * This collection stores Feature Models, representing features\n             * provided by available XMPP entities (e.g. servers)\n             * See XEP-0030 for more details: http://xmpp.org/extensions/xep-0030.html\n             * All features are shown here: http://xmpp.org/registrar/disco-features.html\n             */\n            model: converse.Feature,\n            initialize: function () {\n                this.addClientIdentities().addClientFeatures();\n                this.browserStorage = new Backbone.BrowserStorage[converse.storage](\n                    b64_sha1('converse.features'+converse.bare_jid)\n                );\n                this.on('add', this.onFeatureAdded, this);\n                if (this.browserStorage.records.length === 0) {\n                    // browserStorage is empty, so we've likely never queried this\n                    // domain for features yet\n                    converse.connection.disco.info(converse.domain, null, this.onInfo.bind(this));\n                    converse.connection.disco.items(converse.domain, null, this.onItems.bind(this));\n                } else {\n                    this.fetch({add:true});\n                }\n            },\n\n            onFeatureAdded: function (feature) {\n                converse.emit('serviceDiscovered', feature);\n            },\n\n            addClientIdentities: function () {\n                /* See http://xmpp.org/registrar/disco-categories.html\n                 */\n                 converse.connection.disco.addIdentity('client', 'web', 'Converse.js');\n                 return this;\n            },\n\n            addClientFeatures: function () {\n                /* The strophe.disco.js plugin keeps a list of features which\n                 * it will advertise to any #info queries made to it.\n                 *\n                 * See: http://xmpp.org/extensions/xep-0030.html#info\n                 */\n                converse.connection.disco.addFeature(Strophe.NS.BOSH);\n                converse.connection.disco.addFeature(Strophe.NS.CHATSTATES);\n                converse.connection.disco.addFeature(Strophe.NS.DISCO_INFO);\n                converse.connection.disco.addFeature(Strophe.NS.ROSTERX); // Limited support\n                if (converse.message_carbons) {\n                    converse.connection.disco.addFeature(Strophe.NS.CARBONS);\n                }\n                return this;\n            },\n\n            onItems: function (stanza) {\n                $(stanza).find('query item').each(function (idx, item) {\n                    converse.connection.disco.info(\n                        $(item).attr('jid'),\n                        null,\n                        this.onInfo.bind(this));\n                }.bind(this));\n            },\n\n            onInfo: function (stanza) {\n                var $stanza = $(stanza);\n                if (($stanza.find('identity[category=server][type=im]').length === 0) &&\n                    ($stanza.find('identity[category=conference][type=text]').length === 0)) {\n                    // This isn't an IM server component\n                    return;\n                }\n                $stanza.find('feature').each(function (idx, feature) {\n                    var namespace = $(feature).attr('var');\n                    this[namespace] = true;\n                    this.create({\n                        'var': namespace,\n                        'from': $stanza.attr('from')\n                    });\n                }.bind(this));\n            }\n        });\n\n        this.setUpXMLLogging = function () {\n            Strophe.log = function (level, msg) {\n                converse.log(msg, level);\n            };\n            if (this.debug) {\n                this.connection.xmlInput = function (body) { converse.log(body.outerHTML); };\n                this.connection.xmlOutput = function (body) { converse.log(body.outerHTML); };\n            }\n        };\n\n        this.fetchLoginCredentials = function () {\n            var deferred = new $.Deferred();\n            $.ajax({\n                url:  converse.credentials_url,\n                type: 'GET',\n                dataType: \"json\",\n                success: function (response) {\n                    deferred.resolve({\n                        'jid': response.jid,\n                        'password': response.password\n                    });\n                },\n                error: function (response) {\n                    delete converse.connection;\n                    converse.emit('noResumeableSession');\n                    deferred.reject(response);\n                }\n            });\n            return deferred.promise();\n        };\n\n        this.startNewBOSHSession = function () {\n            var that = this;\n            $.ajax({\n                url:  this.prebind_url,\n                type: 'GET',\n                dataType: \"json\",\n                success: function (response) {\n                    that.connection.attach(\n                            response.jid,\n                            response.sid,\n                            response.rid,\n                            that.onConnectStatusChanged\n                    );\n                },\n                error: function (response) {\n                    delete that.connection;\n                    that.emit('noResumeableSession');\n                }\n            });\n        };\n\n        this.attemptPreboundSession = function (reconnecting) {\n            /* Handle session resumption or initialization when prebind is being used.\n             */\n            if (!reconnecting && this.keepalive) {\n                if (!this.jid) {\n                    throw new Error(\"attemptPreboundSession: when using 'keepalive' with 'prebind, \"+\n                                    \"you must supply the JID of the current user.\");\n                }\n                try {\n                    return this.connection.restore(this.jid, this.onConnectStatusChanged);\n                } catch (e) {\n                    this.log(\"Could not restore session for jid: \"+this.jid+\" Error message: \"+e.message);\n                    this.clearSession(); // If there's a roster, we want to clear it (see #555)\n                }\n            }\n\n            // No keepalive, or session resumption has failed.\n            if (!reconnecting && this.jid && this.sid && this.rid) {\n                return this.connection.attach(this.jid, this.sid, this.rid, this.onConnectStatusChanged);\n            } else if (this.prebind_url) {\n                return this.startNewBOSHSession();\n            } else {\n                throw new Error(\"attemptPreboundSession: If you use prebind and not keepalive, \"+\n                    \"then you MUST supply JID, RID and SID values or a prebind_url.\");\n            }\n        };\n\n        this.autoLogin = function (credentials) {\n            if (credentials) {\n                // If passed in, then they come from credentials_url, so we\n                // set them on the converse object.\n                this.jid = credentials.jid;\n                this.password = credentials.password;\n            }\n            if (this.authentication === converse.ANONYMOUS) {\n                if (!this.jid) {\n                    throw new Error(\"Config Error: when using anonymous login \" +\n                        \"you need to provide the server's domain via the 'jid' option. \" +\n                        \"Either when calling converse.initialize, or when calling \" +\n                        \"converse.user.login.\");\n                }\n                this.connection.connect(this.jid.toLowerCase(), null, this.onConnectStatusChanged);\n            } else if (this.authentication === converse.LOGIN) {\n                var password = converse.connection.pass || this.password;\n                if (!password) {\n                    if (this.auto_login && !this.password) {\n                        throw new Error(\"initConnection: If you use auto_login and \"+\n                            \"authentication='login' then you also need to provide a password.\");\n                    }\n                    converse.setDisconnectionCause(Strophe.Status.AUTHFAIL, undefined, true);\n                    converse.disconnect();\n                    return;\n                }\n                var resource = Strophe.getResourceFromJid(this.jid);\n                if (!resource) {\n                    this.jid = this.jid.toLowerCase() + converse.generateResource();\n                } else {\n                    this.jid = Strophe.getBareJidFromJid(this.jid).toLowerCase()+'/'+resource;\n                }\n                this.connection.connect(this.jid, password, this.onConnectStatusChanged);\n            }\n        };\n\n        this.attemptNonPreboundSession = function (credentials, reconnecting) {\n            /* Handle session resumption or initialization when prebind is not being used.\n             *\n             * Two potential options exist and are handled in this method:\n             *  1. keepalive\n             *  2. auto_login\n             */\n            if (this.keepalive && !reconnecting) {\n                try {\n                    return this.connection.restore(this.jid, this.onConnectStatusChanged);\n                } catch (e) {\n                    this.log(\"Could not restore session. Error message: \"+e.message);\n                    this.clearSession(); // If there's a roster, we want to clear it (see #555)\n                }\n            }\n            if (this.auto_login) {\n                if (credentials) {\n                    // When credentials are passed in, they override prebinding\n                    // or credentials fetching via HTTP\n                    this.autoLogin(credentials);\n                } else if (this.credentials_url) {\n                    this.fetchLoginCredentials().done(this.autoLogin.bind(this));\n                } else if (!this.jid) {\n                    throw new Error(\n                        \"initConnection: If you use auto_login, you also need\"+\n                        \"to give either a jid value (and if applicable a \"+\n                        \"password) or you need to pass in a URL from where the \"+\n                        \"username and password can be fetched (via credentials_url).\"\n                    );\n                } else {\n                    // Probably ANONYMOUS login\n                    this.autoLogin();\n                }\n            } else if (reconnecting) {\n                this.autoLogin();\n            }\n        };\n\n        this.logIn = function (credentials, reconnecting) {\n            // We now try to resume or automatically set up a new session.\n            // Otherwise the user will be shown a login form.\n            if (this.authentication === converse.PREBIND) {\n                this.attemptPreboundSession(reconnecting);\n            } else {\n                this.attemptNonPreboundSession(credentials, reconnecting);\n            }\n        };\n\n        this.initConnection = function () {\n            if (this.connection) {\n                return;\n            }\n            if (!this.bosh_service_url && ! this.websocket_url) {\n                throw new Error(\"initConnection: you must supply a value for either the bosh_service_url or websocket_url or both.\");\n            }\n            if (('WebSocket' in window || 'MozWebSocket' in window) && this.websocket_url) {\n                this.connection = new Strophe.Connection(this.websocket_url, this.connection_options);\n            } else if (this.bosh_service_url) {\n                this.connection = new Strophe.Connection(\n                    this.bosh_service_url,\n                    _.extend(this.connection_options, {'keepalive': this.keepalive})\n                );\n            } else {\n                throw new Error(\"initConnection: this browser does not support websockets and bosh_service_url wasn't specified.\");\n            }\n        };\n\n        this._tearDown = function () {\n            /* Remove those views which are only allowed with a valid\n             * connection.\n             */\n            this.unregisterPresenceHandler();\n            if (this.roster) {\n                this.roster.off().reset(); // Removes roster contacts\n            }\n            this.chatboxes.remove(); // Don't call off(), events won't get re-registered upon reconnect.\n            if (this.features) {\n                this.features.reset();\n            }\n            $(window).off('click mousemove keypress focus'+unloadevent, converse.onUserActivity);\n            window.clearInterval(converse.everySecondTrigger);\n            return this;\n        };\n\n        this.initChatBoxes = function () {\n            this.chatboxes = new this.ChatBoxes();\n            this.chatboxviews = new this.ChatBoxViews({model: this.chatboxes});\n        };\n\n        this._initialize = function () {\n            this.initChatBoxes();\n            this.initSession();\n            this.initConnection();\n            this.setUpXMLLogging();\n            this.logIn();\n            return this;\n        };\n\n        // Initialization\n        // --------------\n        // This is the end of the initialize method.\n        if (settings.connection) {\n            this.connection = settings.connection;\n        }\n        var updateSettings = function (settings) {\n            /* Helper method which gets put on the plugin and allows it to\n             * add more user-facing config settings to converse.js.\n             */\n            utils.merge(converse.default_settings, settings);\n            utils.merge(converse, settings);\n            utils.applyUserSettings(converse, settings, converse.user_settings);\n        };\n\n        // If initialize gets called a second time (e.g. during tests), then we\n        // need to re-apply all plugins (for a new converse instance), and we\n        // therefore need to clear this array that prevents plugins from being\n        // initialized twice.\n        // If initialize is called for the first time, then this array is empty\n        // in any case.\n        converse.pluggable.initialized_plugins = [];\n\n        converse.pluggable.initializePlugins({\n            'updateSettings': updateSettings,\n            'converse': converse\n        });\n        converse.emit('pluginsInitialized');\n        converse._initialize();\n        converse.registerGlobalEventHandlers();\n\n        if (!_.isUndefined(converse.connection) &&\n            converse.connection.service === 'jasmine tests') {\n            return converse;\n        } else {\n            return init_deferred.promise();\n        }\n    };\n    return converse;\n}));\n"], "fixing_code": ["# Changelog\n\n## 2.0.5 (Unreleased)\n- #743, #751, #753 Update to Strophe 1.2.12. SASL-EXTERNAL now has reduced priority, so it won't\n  be prioritized above other auth mechanisms. [jcbrand]\n- #755: create composer.json to add this project in packagist.org [fabiomontefuscolo]\n- #758: Bugfix. Render all resize drag handles for ChatRoomView. [LeoYReyes]\n- Bugfix. Cancel button shown while registration form is being fetched wasn't working\n  properly. [jcbrand]\n- Bugfix. Login form wasn't rendered after logging out (when `auto_reconnect` is `true`). [jcbrand]\n- Bugfix. Properly disconnect upon \"host-unknown\" error. [jcbrand]\n- Bugfix. Minimized chats weren't removed when logging out. [jcbrand]\n- Security fix: Prevent message forging via carbons. (Thanks to ge0rg) [jcbrand]\n\n## 2.0.4 (2016-12-13)\n- #737: Bugfix. Translations weren't being applied. [jcbrand]\n- Fetch room info and store it on the room model.\n  For context, see: http://xmpp.org/extensions/xep-0045.html#disco-roominfo [jcbrand]\n- Bugfix. Switching from bookmarks form to config form shows only the spinner. [jcbrand]\n- Bugfix. Other room occupants sometimes not shown when reloading the page. [jcbrand]\n- Bugfix. Due to changes in `converse-core` the controlbox wasn't aware anymore of\n  disconnection or reconnection events. [jcbrand]\n- Optimize fetching of MAM messages (in some cases happened on each page load). [jcbrand]\n- Fix empty controlbox toggle after disconnect. [jcbrand]\n- When inviting someone to a members-only room, first add them to the member\n  list. [jcbrand]\n- New configuration setting [muc_disable_moderator_commands](https://conversejs.org/docs/html/configuration.html#muc-disable-moderator-commands) [jcbrand]\n\n## 2.0.3 (2016-11-30)\n- #735 Room configuration button not visible. [jcbrand]\n- CSS fix for fadeIn animation. [jcbrand]\n\n## 2.0.2 (2016-11-30)\n- #721 keepalive not working with anonymous authentication [jcbrand]\n- #723 Bugfix: Arrays in configuration settings were ignored. [jcbrand]\n- #734 Bugfix. `converse.rooms.open` ignored the `muc_nickname_from_jid` setting. [jcbrand]\n- Enable new rooms to be configured automatically, with a default config, via `rooms.open`.\n  For details, refer to the [relevant documentation](https://conversejs.org/docs/html/developer_api.html#the-rooms-grouping) [jcbrand]\n- Bugfix: Chatboxes aren't closed when logging out. [jcbrand]\n- Bugfix: Trying to save data on the `ControlBox` model before `ChatBoxes`\n  collection has its `browserStorage` configured.\n  Causes `Error: A \"url\" property or function must be specified`. [jcbrand]\n- Don't open the controlbox on contact requests. [jcbrand]\n- Bugfix: Reconnection fails when original connection was never established. [jcbrand]\n- If a `credentials_url` is provided, then keep on attempting to reconnect when connection is down.  [jcbrand]\n- Remove (undocumented) `callback` config parameter for `converse.initialize`.\n  Instead, `converse.initialize` returns a promise which will resolve once\n  initialization is complete. [jcbrand]\n- New event ['reconnecting'](https://conversejs.org/docs/html/development.html#reconnecting) [jcbrand]\n- New configuration setting [allow_bookmarks](https://conversejs.org/docs/html/configuration.html#allow-bookmarks) [jcbrand]\n- The `rooms.open` API method will no longer maximize rooms that are minimized (unless `maximize: true` is passed in). [jcbrand]\n\n## 2.0.1 (2016-11-07)\n- #203 New configuration setting [muc_domain](https://conversejs.org/docs/html/configuration.html#muc-domain) [jcbrand]\n- #705 White content after submitting password on chatrooms [jcbrand]\n- #712 Controlbox clicks stop responding after auto-reconnect [jcbrand]\n- Removed shared state between tests. All tests are now isolated. [jcbrand]\n- Allow the context (i.e. `this` value) to be passed in when registering event\n  listeners with `converse.listen.on` and `converse.listen.once`. [jcbrand]\n- New event ['rosterContactsFetched'](https://conversejs.org/docs/html/development.html#rosterContactsFetched) [jcbrand]\n- New event ['rosterGroupsFetched'](https://conversejs.org/docs/html/development.html#rosterGroupsFetched) [jcbrand]\n- HTML templates are now loaded in the respective modules/plugins. [jcbrand]\n- Start improving Content-Security-Policy compatibility by removing inline CSS. [mathiasertl]\n- Add support for XEP-0048, chat room bookmarks [jcbrand]\n- New configuration setting [connection_options](https://conversejs.org/docs/html/configuration.html#connection-options) [jcbrand]\n\n## 2.0.0 (2016-09-16)\n- #656 Online users count not shown initially [amanzur]\n- #674 Polish translation updated [ser]\n- Backwards incompatible change: the `_super` attribute in plugins is now named `__super__`. [jcbrand]\n- Continuously attempt to resurrect dead connections when `auto_reconnect` is `true`. [jcbrand]\n- Update the 'rooms' API to allow user to pass in room attributes. [jcbrand]\n- New configuration setting [message_storage](https://conversejs.org/docs/html/configuration.html#message-storage) [jcbrand]\n- Hardcode the storage for roster contacts and chatroom occupants to `sessionStorage`. [jcbrand]\n- Fixed wrong chat state value, should be `chat`, not `chatty`.\n  See [RFC 3921](https://xmpp.org/rfcs/rfc3921.html#rfc.section.2.1.2.2). [jcbrand]\n- Adds support for SASL-EXTERNAL. [jcbrand]\n\n## 1.0.6 (2016-08-12)\n- #632 Offline and Logout states do not properly update once users start\n  chatting. [chrisuehlinger, jcband]\n- #674 Polish translation updated to the current master. [ser]\n- #677 Chatbox does not open after close. [jcbrand]\n- The behavior of `converse.chats.get` has changed. If the chat box is not\n  already open, then `undefined` will be returned. [jcbrand]\n- Typing (i.e. chat state) notifications are now also sent out from MUC rooms. [jcbrand]\n- `ChatRoomView.onChatRoomMessageSubmitted` has been renamed to\n  `onMessageSubmitted`, to make it the same as the method on `ChatBoxView`. [jcbrand]\n- New configuration setting [muc_nickname_from_jid](https://conversejs.org/docs/html/configuration.html#muc-nickname-from-jid) [jcbrand]\n- New configuration setting [muc_instant_rooms](https://conversejs.org/docs/html/configuration.html#muc-instant-rooms) [jcbrand]\n\n## 1.0.5 (2016-07-28)\n- In case of nickname conflict when joining a room, allow the user to choose a new one.\n  [jcbrand]\n- Check whether the user has a reserved nickname before entering a room, and if so,\n  use it. [jcbrand]\n- Mention someone in your chat room message by clicking on their name in the occupants\n  list. [jcbrand]\n- #645 When accepting a contact request, the contact didn't appear in the\n  pending contacts group. [jcbrand]\n- Bugfix: allow multiple MAM queries to be made simultaneously. [jcbrand]\n\n## 1.0.4 (2016-07-26)\n\n- Restrict occupants sidebar to 30% chatroom width. [jcbrand]\n- Made requesting contacts more visible, by placing them at the top of the roster. [jcbrand]\n- `insertIntoPage` method of `ChatBoxView` has been renamed to `insertIntoDOM`,\n  to make it the same as the method of `ChatRoomView`. [jcbrand]\n- Render error messages received from the server (for undelivered chat messages). [jcbrand]\n- Don't hide requesting contacts when filtering by chat state. [jcbrand]\n- When logging in anonymously, the server JID can now be passed in via `converse.initialize`\n  or via `converse.user.login`. [jcbrand]\n\n## 1.0.3 (2016-06-20)\n\n- Update the plugin architecture to allow plugins to have optional dependencies [jcbrand]\n- Bugfix. Login form doesn't render after logging out, when `auto_reconnect = false` [jcbrand]\n- Also indicate new day for the first day's messages. [jcbrand]\n- Chat bot messages don't appear when they have the same ids as their commands. [jcbrand]\n- Updated onDisconnected method to fire disconnected event even if `auto_reconnect = false`. [kamranzafar]\n- Bugfix: MAM messages weren't being fetched oldest first. [jcbrand]\n- Add processing hints to chat state notifications [jcbrand]\n- Don't use sound and desktop notifications for OTR messages (when setting up the session) [jcbrand]\n- New config option [default_state](https://conversejs.org/docs/html/configuration.html#default_state) [jcbrand]\n- New API method `converse.rooms.close()` [jcbrand]\n- New configuration setting [allow_muc_invites](https://conversejs.org/docs/html/configuration.html#allow-muc-invites) [jcbrand]\n- Add new event [pluginsInitialized](https://conversejs.org/docs/html/development.html#pluginsInitialized) [jcbrand]\n- #553 Add processing hints to OTR messages [jcbrand]\n- #650 Don't ignore incoming messages with same JID as current user (might be MAM archived) [jcbrand]\n- #656 online users count in minimized chat window on initialization corrected [amanzur]\n\n## 1.0.2 (2016-05-24)\n\n- Bugfix. Bind `sendPresence` to the right context. Bug that slipped in during\n  the release of `1.0.1`. [jcbrand]\n\n## 1.0.1 (2016-05-24)\n\n- Bugfix. Roster filter sometimes gets hidden when it shouldn't. [jcbrand]\n- Chat boxes weren't being initialized due to typo. [jcbrand]\n- Flush request queue just after connection. Solves a problem with PubSub and\n  Prosody, whereby BOSH HTTP responses weren't being received. [jcbrand]\n\n## 1.0.0 (2016-05-03)\n\n- Add catalan language [JoseMariaRubioMoral]\n- Split converse.js up into different plugin modules. [jcbrand]\n- Better Sass/CSS for responsive/mobile views. New mobile-only build. [jcbrand]\n- Roster contacts can now be filtered by chat state and roster filters are\n  remembered across page loads. [jcbrand]\n- Add support for messages with type `headline`, often used for notifications\n  from the server. [jcbrand]\n- Add stanza-specific event listener `converse.listen.stanza`.\n  As a result `converse.listen.on('message');` has been deprecated, use\n  `converse.stanza.on('message');` instead. [jcbrand]\n- Emit an event `chatBoxInitialized` once a chat box's initialize method has been called. [jcbrand]\n- Emit an event `statusInitialized` once the user's own status has been initialized upon startup. [jcbrand]\n- New config option [chatstate_notification_blacklist](https://conversejs.org/docs/html/configuration.html#chatstate-notification-blacklist) [jcbrand]\n- New config option [sticky_controlbox](https://conversejs.org/docs/html/configuration.html#sticky-controlbox) [jcbrand]\n- New config option [credentials_url](https://conversejs.org/docs/html/configuration.html#credentials-url) [jcbrand]\n- Don't play sound notifications for OTR messages which are setting up an\n  encrypted session. [jcbrand]\n- Bugfix: RID, SID and JID tokens ignored when `keepalive` set to `true`. [jcbrand]\n- Removed the `account.logout` API, instead use `user.logout`. [jcbrand]\n- Use `rel=noopener` with links that contain `target=_blank` to prevent potential\n  phishing attacks. [More info here](https://mathiasbynens.github.io/rel-noopener/)\n  [jcbrand]\n- #156 Add the option `auto_join_rooms` which allows you to automatically\n  connect to certain rooms once logged in. [jcbrand]\n- #261 `show_controlbox_by_default` config not working [diditopher]\n- #443 HTML5 notifications of received messages [jcbrand]\n- #534 Updated Russian translation [badfiles]\n- #566 Do not steal the focus when the chatbox opens automatically [rlanvin]\n- #573 xgettext build error: `'javascript' unknown` [jcbrand]\n- #577 New config variable [message_archiving_timeout](https://conversejs.org/docs/html/configuration.html#message-archiving-timeout) [jcbrand]\n- #587 Fix issue when logging out with `auto_logout=true` [davec82]\n- #589 Save scroll position on minimize and restore it on maximize [rlanvin]\n- #592 Add random resource for `auto_login`, add method generateResource to\n  generate random resource [davec82]\n- #598 Add option `synchronize_availability` [davec82]\n- #600 Fix change xmpp status also on icon-status click [davec82]\n- #616 converse-otr should depend on converse-minimize  [jcbrand]\n- #609 Remove split of fullname [lixmal]\n\n## 0.10.1 (2016-02-06)\n\n- #352 When the user has manually scrolled up in a chat window, don't scroll\n  down on chat event notifications. [jcbrand]\n- #524 Added [auto_join_on_invite](https://conversejs.org/docs/html/configuration.html#auto_join_on_invite)\n  parameter for automatically joining chatrooms. [ben]\n- #520 Set specific domain. Two new options [default_domain](https://conversejs.org/docs/html/configuration.html#default_domain)\n  and [locked_domain](https://conversejs.org/docs/html/configuration.html#locked_domain). [jcbrand]\n- #521 Not sending presence when connecting after disconnection. [jcbrand]\n- #535 Messages not received when room with mixed-case JID is used. [jcbrand]\n- #536 Presence not sent out (in cases where it should) after page refresh. [jcbrand]\n- #540 `bind is not a function` error for plugins without `initialize` method. [jcbrand]\n- #547 By default the `offline` state is no longer choosable.\n  See [include_offline_state](https://conversejs.org/docs/html/configuration.html#include-offline-state) for details. [jcbrand]\n- A chatroom invite might come from someone not in your roster list. [ben]\n- #487 Empty the resources array when the resource is null [rlanvin]\n- #534 Updated Russian translation [LaconicTranslator]\n- #555 The status restored from sessionStorage is never updated [jcbrand]\n- #559 Remove reconnection timer once connected succesfully [m0cs]\n\n## 0.10.0 (2015-11-05)\n\n**Note:**\n*This release drops CSS support for IE8 and IE9.*\n\n- #459 Wrong datatype passed to converse.chatboxes.getChatBox. [hobblegobber, jcbrand]\n- #493 Roster push fix [jcbrand]\n- #403 emit an event `rosterPush` when a roster push happens [teseo]\n- #502. Chat room not opened in non_amd version. [rjanbiah]\n- #505 Typo caused [object Object] in room info [gromiak]\n- #508 \"Is typing\" doesn't automatically disappear [jcbrand]\n- #509 Updated Polish translations [ser]\n- #510 MUC room memberlist is being cleared with page reload when keepalive option is set. [jcbrand]\n- Add the ability to also drag-resize chat boxes horizontally. [jcbrand]\n- Updated Sass files and created a new style. [jcbrand]\n\n\n## 0.9.6 (2015-10-12)\n\n- Bugfix. Spinner doesn't disappear when scrolling up (when server doesn't support XEP-0313). [jcbrand]\n- #462 Fix MUC rooms with names containing special characters not working [1st8]\n- #467 Fix outgoing chat messages not having a msgid when being put into sessionStorage [1st8]\n- #468 Fix [object Object] being sometimes shown as status [1st8]\n- #472 Fix \"Cannot read property 'splitOnce' of undefined\" when typing /clear in a chat room. [jcbrand]\n- #493 Roster wasn't being updated after a Roster push update [teseo, jcbrand]\n- #496 Bugfix. Pings weren't being sent out. [teseo, jcbrand]\n- #499 Message not received due to non-unique message ids. [jcbrand]\n\n## 0.9.5 (2015-08-24)\n\n- #306 XEP-0313: Message Archive Management [jcbrand]\n- #439 auto_login and keepalive not working [jcbrand]\n- #440 null added as resource to contact [jcbrand]\n- Add new event serviceDiscovered [jcbrand]\n- Add a new configuration setting [muc_history_max_stanzas](https://conversejs.org/docs/html/configuration.html#muc-history-max-stanzas>). [jcbrand]\n\n## 0.9.4 (2015-07-04)\n\n- #144 Add Ping functionality and Pong handler [thierrytiti]\n- #234, #431 Messages aren't received when the user logs in with a mixed-case JID. [jcbrand]\n- #367 API methods for changing chat status (online, busy, away etc.) and status message [jcbrand]\n- #389 Allow login panel placeholders and roster item 'Name' translations. [gbonvehi]\n- #394 Option to allow chatting with pending contacts [thierrytiti]\n- #396 Add automatic Away mode and XEP-0352 support [thierrytiti]\n- #400, #410 Allow offline pretty status and placeholder for \"Insert a smiley\" to be translated [thierrytiti]\n- #401 Updated French translation [thierrytiti]\n- #404 CSS fix: position and width of the div #conversejs [thierrytiti]\n- #407 CSS: Fonts Path: editabable $font-path via sass/variables.scss [thierrytiti]\n- #408 MUC: missing toggle call handler and updated documentation about call [thierrytiti]\n- #413 Auto-detect user's locale to show date and time in the right format [thierrytiti]\n- #415 closeAllChatBoxes is giving ReferenceError when 2 chats are open [nevcos, jcbrand]\n- #416 Add icon for XA status [thierrytiti]\n- #418 Logging out with `auto_reconnect=true` causes reconnection retries [jcbrand]\n- #420 Updated German translation [1st8]\n- #427 Converse.js does not subscribe back to a contact not in the roster. [emmanuel-florent]\n- Add offline pretty status to enable translation [thierrytiti]\n- Bugfix. ClearSessions during unload event would throw an error when not logged in. [gbonvehi]\n- Bugfix. Manual login doesn't work when only websocket_url is set and not bosh_service_url. [jcbrand]\n- Bugfix. Wrong callback argument mapping in XmppStatus initialize: fullname is null [thierrytiti]\n- CSS fix: room-info bug on hover after room description loaded [thierrytiti]\n- CSS: Fonts Path: editabable $font-path via sass/variables.scss [thierrytiti]\n- Chat boxes returned by the API now have an `is_chatroom` attribute [jcbrand]\n- Decouple automatic away and XEP-0352 support. [jcbrand]\n- Don't carbon copy OTR messages. [jcbrand]\n- I18N: Autodetection of User Locale if no i18n setting is set. [thierrytiti]\n- Refactored in order to remove the strophe.roster.js dependency. [jcbrand]\n- Refactored the plugin architecture. Add `overrides` convention for\n  automatically overriding converse.js's methods and Backbone views and models. [jcbrand]\n- With keepalive, don't send out a presence stanza on each page load [jcbrand]\n\n## 0.9.3 (2015-05-01)\n\n- Add the ability to log in automatically. [jcbrand]\n- Remove `type=email` from JID field in login form. Resulting validation error confuses people. [jcbrand]\n- Add Ukranian translations [Andriy Kopystyansky]\n- #244 Add the ability to log in anonymously. [jcbrand]\n- #344 Enable the path to the sound files to be configured [thierrytiti and jcbrand]\n- #370 Unable to register a new user to ejabberd 2.1.11. [gbonvehi]\n- #372 Some offline users have a visible empty `<dd>` in the roster. [floriancargoet]\n- #374 Fix collapsed group visibility on page load. [floriancargoet]\n- #378 Expect full JIDs to be returned via XHR user search [thierrytiti]\n- #379 Updated French translations [thierrytiti]\n- #379 Fix for bower not finding crypto-js-evanvosberg#3.1.2-5 any more. [jcbrand]\n\n## 0.9.2 (2015-04-09)\n\n- Bugfix. Prevent attaching twice during initialization. [jcbrand]\n- API method chats.get can now also return chat boxes which haven't been opened yet. [jcbrand]\n- Add API method contacts.add. [pzia]\n- #356 Fix the plugin extend function. [floriancargoet]\n- #357 Fix the known bug where a state notification reopens a chat box. [floriancargoet]\n- #358 Bugfix. Chat rooms show the same occupants bug. [floriancargoet]\n- #359 Fix a timeout bug in chat state notifications. [floriancargoet]\n- #360 Incorrect roster height when `allow_contact_requests=true`. [floriancargoet, jcbrand]\n- #362 Add API for retrieving and opening rooms. [pzia]\n- #364 Text selection in chat boxes not shown in Firefox. [jcbrand]\n\n## 0.9.1 (2015-03-26)\n\n- Set the JID input field in the login form to `type=email`. [chatme]\n- New configuration setting [allow_contact_removal](https://conversejs.org/docs/html/configuration.html#allow-contact-removal) [jcbrand]\n- Document that event handlers receive 'event' obj as first arg. [jcbrand]\n- Add a test to check that notifications are played in chat rooms. [jcbrand]\n- #333 Enable automatic reconnection when `prebind` and `prebind_url` are specified. [jcbrand]\n- #339 Require the JID to be specified when using `keepalive` with `prebind`. Also add a logout API method. [jcbrand]\n- #349 Indicate visitors in chat rooms. [c143]\n\n## 0.9.0 (2015-03-06)\n\n- #204 Support websocket connections. [jcbrand]\n- #252, 253 Add fullname and jid to contact's tooltip in roster. [gbonvehi]\n- #292 Better support for XEP-0085 Chat State Notifications. [jcbrand]\n- #295 Document \"allow_registration\". [gbonvehi]\n- #304 Added Polish translations. [ser]\n- #305 presence/show text in XMPP request isn't allowed by specification. [gbonvehi]\n- Add new API method `chats.open` to open chat boxes. [jcbrand]\n- Add new API method to set and get configuration settings. [jcbrand]\n- Add responsiveness to CSS. We now use Sass preprocessor for generating CSS. [jcbrand]\n- Bugfix. Custom status message form doesn't submit/disappear. [jcbrand]\n- Calling the API method `contacts.get()` without parameters now returns all contacts. [jcbrand]\n- Don't send out the message carbons IQ stanza on each page load. [jcbrand]\n- New Makefile.win to build in Windows environments. [gbonvehi]\n- Norwegian Bokm\u00e5l translations. [Andreas Lorentsen]\n- Removed deprecated API methods. [jcbrand]\n- Strophe.log and Strophe.error now uses converse.log to output messages. [gbonvehi]\n- The API method `chats.get` now only returns already opened chat boxes. [jcbrand]\n- Updated Afrikaans translations. [jcbrand]\n- Add new configuration setting [prebind_url](https://conversejs.org/docs/html/configuration.html#prebind-url) [jcbrand]\n\n## 0.8.6 (2014-12-07)\n\n- Bugfix. Login panel didn't appear under certain conditions. [jcbrand]\n- Bugfix. Error when trying to render chat room configuration form. [jcbrand]\n- Text on the registration form was not configurable or i18n aware. [jcbrand]\n- #285 With prebind the jid, rid and sid settings were ignored. [jcbrand]\n\n## 0.8.5 (2014-12-01)\n\n- #117 JIDs or nicknames not shown in chat rooms. [jcbrand]\n- #282 XEP-0077 In-band registration. [jcbrand]\n\n## 0.8.4 (2014-11-15)\n\n**note:**\n*Certain API methods have been deprecated in favor of a new API and will be removed in the 0.9.0 release.*\n\n- Bugfix. Error when trying to use prebind and keepalive together. [heban and jcbrand]\n- Bugfix. Cannot read property \"top\" of undefined. [jcbrand]\n- Add new event, noResumeableSession, for when keepalive=true and there aren't\n  any prebind session tokens. [jcbrand]\n- #46 Refactor the API and add new methods. [jcbrand]\n- #151 Browser locks/freezes with many roster users. [jcbrand]\n- #177 Setting status to offline does nothing. [jcbrand]\n- #232 Always get full name from model. [jcbrand]\n- #237 Unable to create room when `hide_muc_server` is `true`. [jcbrand]\n- #238 Rooms are not shown when `hide_offline_users` is `true`. [jcbrand]\n- #251 Non-minified builds for debugging. [jcbrand]\n- #260 Sent message carbons are not displayed. [jcbrand]\n- #262 Contact requests are not shown if page is reloaded. [jcbrand]\n- #264 Remove unnecessary commas for ie8 compatibility. [Deuteu]\n- #267 Unread messages counter wrongly gets incremented by chat state notifications. [Deuteu]\n- #274 Roster filtering results change with presence changes. [jcbrand]\n- #275 Custom status message doesn't reset. [jcbrand]\n- #278 Unread messages counter doesn't unbind it's events. [Deuteu]\n- #279 Handle more field types for MUC config forms. [gbonvehi]\n- #280 New config option, `hide_offline_users` [gbonvehi]\n\n## 0.8.3 (2014-09-22)\n\n- The Javascript build files in the 0.8.2 release weren't updated due to a\n  unnoticed build error. [jcbrand]\n\n## 0.8.2 (2014-09-22)\n\n- Converse.js now has the ability to maintain sessions across page loads.\n  Previously, the session tokens had to be handled externally and passed in.\n  See the [keepalive](https://conversejs.org/docs/html/configuration.html#keepalive) configuration setting. [jcbrand]\n- Allow changing of nickname in a chat room via /nick command. [jcbrand]\n- Allow a chat room user to be muted or unmuted with the /mute and /voice commands. [jcbrand]\n- Add a chat room toolbar button for toggling the list of occupants. [jcbrand]\n- Converse.js now responds to XEP-0030: Service Discovery requests. [jcbrand]\n- Bugfix. Roster groups all appear offline after page reload (with prebind).\n  See http://librelist.com/browser//conversejs/2014/8/26/problem-with-contact-list-everyone-is-offline/ [heban and jcbrand]\n- Bugfix concerning trimmed chats. Chats were being trimmed even though there was enough room. [jcbrand]\n- #62 Sound notifications will now also play when you are mentioned in a chat room. [jcbrand]\n- #212 Bugfix. Groups weren't being show again after the live filter was cleared. [jcbrand]\n- #215 (and also #75) XEP-0249: Direct MUC Invitations. [jcbrand]\n- #216 Contacts tab empty when using xhr_user_search. [hcderaad and jcbrand]\n- #219 New contacts added need page refresh to be accepted and become visible. [hcderaad and jcbrand]\n- #220 Non-AMD example page was not working. [xavier83ar and jcbrand]\n- #222 Control box state not remembered. [priyadi and jcbrand]\n- #223 Provide API to query buddy status. [priyadi and jcbrand]\n- #227 Updated Hebrew translations [GreenLunar]\n\n## 0.8.1 (2014-08-23)\n\n- Bugfix: Roster contacts' cache key too vague. [jcbrand]\n- Bugfix: Roster contacts weren't properly sorted according to chat status. [jcbrand]\n- #63 Support for sound notification when message is received. [jcbrand]\n- #212 Provide a live filter of the roster contacts. [jcbrand]\n\n## 0.8.0 (2014-08-04)\n\n**note**:\n    1. Converse.js is now relicensed under the [Mozilla Public License](http://www.mozilla.org/MPL/2.0/).\n    2. Configuration options for the chat toolbar have changed. Please refer to the [relevant documentation](http://devbox:8890/docs/html/configuration.html#visible-toolbar-buttons).\n    3. This release has reduced support for IE8 (some features won't work).\n    4. Events have been renamed to remove \"on\" prefix (sorry for any inconvenience).\n\n- No initial HTML markup is now needed in the document body for converse.js to work. [jcbrand]\n- All date handling is now done with moment.js. [jcbrand]\n- Add a new toolbar button for clearing chat messages. [jcbrand]\n- Chat boxes and rooms can now be resized vertically. [jcbrand]\n- Upgraded dependencies to their latest versions. [jcbrand]\n- Add new configuration setting [forwarded_messages](https://conversejs.org/docs/html/configuration.html#forwarded-messages).\n  Message forwarding was before a default behavior but is now optional (and disabled by default). [jcbrand]\n- Newly opened chat boxes always appear immediately left of the controlbox. [jcbrand]\n- #71 Chat boxes and rooms can be minimized. [jcbrand]\n- #83 Roster contacts can be shown according to their groups. [jcbrand]\n    Note: Converse.js can show users under groups if you have assigned them\n    already via another client or server configuration. There is not yet a way\n    to assign contacts to groups from within converse.js itself.\n- #123 Show converse.js in the resource assigned to a user. [jcbrand]\n- #130 Fixed bootstrap conflicts. [jcbrand]\n- #132 Support for [XEP-0280: Message Carbons](https://xmpp.org/extensions/xep-0280.html).\n    Configured via [message_carbons](https://conversejs.org/docs/html/configuration.html#message-carbons) [hejazee]\n- #176 Add support for caching in sessionStorage as opposed to localStorage. [jcbrand]\n- #180 RID and SID undefined [g8g3]\n- #191 No messages history [heban]\n- #192 Error: xhr_user_search_url is not defined. [jcbrand]\n- #195 Chinese translations. [lancelothuxi]\n- #196 [Safari v7.0.5] TypeError: Attempted to assign to readonly property. [g8g3]\n- #199 Improved Spanish translations [chilicuil]\n- #201 Add zh-locale to fix build task [schoetty]\n\n## 0.7.4 (2014-03-05)\n\n**note:**\n*This release contains an important security fix. Thanks to Renaud Dubourguais from [Synacktiv](http://synacktiv.com) for reporting the vulnerability.*\n\n- #125 Bugfix: crypto dependencies loaded in wrong order [jcbrand]\n- Bugfix: action messages (i.e. /me) didn't work in OTR mode. [jcbrand]\n- Security fix: Ensure that message URLs are properly encoded. [jcbrand]\n\n## 0.7.3 (2014-02-23)\n\n- #93 Add API methods exposing the RID and SID values. Can be disabled. [jcbrand]\n- #102 Option to enable OTR by default. [Aupajo]\n- #103 Option to display a call button in the chatbox toolbar, to allow third-party libraries to provide a calling feature. [Aupajo]\n- #108 Japanese Translations [mako09]\n- #111 OTR not working when using converse.js with prebinding. [jseidl, jcbrand]\n- #114, #124 Hewbrew Translations [GreenLunar]\n- #115 Indonesian Translations [priyadi]\n\n## 0.7.2 (2013-12-18)\n\n**note**\n*This release contains an important security fix. Thanks to hejsan for reporting the vulnerability.*\n\n- #48 Add event emitter support and emit events. [jcbrand]\n- #97 Wrong number of online contacts shown with config option `show_only_online_users`. [jcbrand]\n- #100 Make the fetching of vCards optional (enabled by default). [jcbrand]\n- Sanitize message text to avoid Javascript injection attacks.  [jcbrand]\n\n## 0.7.1 (2013-11-17)\n\n- Don't load OTR crypto if the browser doesn't have a CSRNG [jcbrand]\n- Don't break when crypto libraries aren't defined. [jcbrand]\n- Check if canvas is supported before trying to render the user avatar [jcbrand]\n- Use newest strophe.muc plugin. Fixes #85 [jcbrand]\n\n**note:**\nIf you are using the development libraries, you'll need to run ``bower update``\nto fetch the newest strophe.muc.plugin (for bugfix of #85).\n\nThis release contains 3 different builds:\n- converse.min.js\n- converse-no-otr.min.js (Without OTR encryption)\n- converse-no-locales-no-otr.min.js (Without OTR encryption or any translations)\n\n## 0.7.0 (2013-11-13)\n\n### Important:\n\nThis release includes support for [Off-the-record encryption](https://otr.cypherpunks.ca).\nFor this to work, your browser needs a CSPRNG (Cryptographically secure pseudorandom number generator).\n\nInternet Explorer of all versions doesn't have one at all, neither does older versions of Firefox.\n\nIf you need to support older browsers, please download the latest release from the 0.6 bran\n\n#### Features:\n\n- Add a toolbar to the chat boxes [jcbrand]\n- Add support for OTR (off-the-record) encryption [jcbrand]\n- Add support for smileys [jcbrand]\n- Simplified boilerplate markup [jcbrand]\n- New configuration settings, `xhr_custom_status_url` and `xhr_user_search_url` [jcbrand]\n\n**note:**\n*This release introduces a backward incompatible change. The boilerplate\nHTML needed in your webpage for converse.js to work has been reduced to a\nsingle div: `<div id=\"conversejs\"></div>`*\n\n#### Bugfixes:\n\n- #58 Contact's name gets replaced with their JID [jcbrand]\n- #81 Requesting contacts appear as pending contacts [jcbrand]\n\n## 0.6.6 (2013-10-16)\n\n- Bugfix: Presence stanza must be sent out after roster has been initialized [jcbrand]\n- Bugfix: Don't reconnect while still disconnecting, causes endless authentication loops. [jcbrand]\n- Dutch translation [maartenkling]\n\n## 0.6.5 (2013-10-08)\n\n- Fetch vCards asynchronously once a roster contact is added [jcbrand]\n- Hungarian translation [w3host]\n- Russian translation [bkocherov]\n- Update CSS to avoid clash with bootstrap [seocam]\n- New config option `allow_muc` toggles multi-user chat (MUC) [jcbrand]\n- New config option `allow_contact_requests` toggles user adding [jcbrand]\n- New config option `show_only_online_users` [jcbrand]\n\n## 0.6.4 (2013-09-15)\n\n- Add icon for the unavailable chat state. [jcbrand]\n- Chat state descriptions weren't translation aware. [jcbrand]\n- Clear messages from localStorage when user types \"/clear\". [jcbrand]\n- The 'xa' chat state wasn't being handled properly. [jcbrand]\n- Updated pt-BR translations [seocam]\n- Updated af and de translations [jcbrand]\n\n## 0.6.3 (2013-09-12)\n\n*NB: This release contains an important security fix. Please don't use older\nversions of the 0.6 branch.*\n\n- French translations. [tdesvenain]\n- Bugfix: Messages were stored against buddy JID and not own JID. [jcbrand]\n\n## 0.6.2 (2013-08-29)\n\n- Bugfix. The remove icon wasn't appearing in the contacts roster. [jcbrand]\n- Bugfix. With auto_subscribe=True, the \"Pending Contacts\" header didn't disappear\n  after a new user was accepted. [jcbrand]\n\n## 0.6.1 (2013-08-28)\n\n- IE9 and IE8 CSS fixes. [jcbrand]\n- Bugfix: Pencil icon not visible (for setting status update). [jcbrand]\n- Bugfix: RID, JID and SID initialization values were being ignored. [jcbrand]\n- Bugfix: Fall back to English if a non-existing locale was specified. [jcbrand]\n\n## 0.6.0 (2013-08-26)\n\n- #39 Documentation for minifying JS is wrong. [jcbrand]\n- #41 prebind and show_controlbox_by_default true fails. [jcbrand]\n- With prebinding, attaching to the connection now happens inside Converse and\n  not as a separate step after initialization. [jcbrand]\n- Register presence and message handlers before fetching the roster. Otherwise\n  some presence notifications might be missed. [jcbrand]\n- Add a debug option (logs to the browser console). [jcbrand]\n- Use font icons from http://icomoon.io [jcbrand]\n- Added a static mockup to aid CSS/design process. [jcbrand]\n- Save language codes with hyphens. Thanks to @seocam. [jcbrand]\n- The combined and minified JS file now uses almond and not require.js. [jcbrand]\n\n## 0.5.2 (2013-08-05)\n\n- Important security update. Don't expose the Strophe connection object globally. [jcbrand]\n\n## 0.5.1 (2013-08-04)\n\n- #13, #14: Messages sent between to GTalk accounts weren't being received. [jcbrand]\n- #32: Default status was offline when user didn't have contacts. [jcbrand]\n- Attach panels to the DOM upon initialize. [jcbrand]\n\n## 0.5.0 (2013-07-30)\n\n- #09 Remove dependency on AMD/require.js [jcbrand]\n- #22 Fixed compare operator in strophe.muc [sonata82]\n- #23 Add Italian translations [ctrlaltca]\n- #24 Add Spanish translations [macagua]\n- #25 Using span with css instead of img [matheus-morfi]\n- #26 Only the first minute digit shown in chatbox. [jcbrand]\n- #28 Add Brazilian Portuguese translations [matheus-morfi]\n- Use Bower to manage 3rd party dependencies. [jcbrand]\n\n## 0.4.0 (2013-06-03)\n\n- CSS tweaks: fixed overflowing text in status message and chatrooms list. [jcbrand]\n- Bugfix: Couldn't join chatroom when clicking from a list of rooms. [jcbrand]\n- Add better support for kicking or banning users from chatrooms. [jcbrand]\n- Fixed alignment of chat messages in Firefox. [jcbrand]\n- More intelligent fetching of vCards. [jcbrand]\n- Fixed a race condition bug. Make sure that the roster is populated before sending initial presence. [jcbrand]\n- Reconnect automatically when the connection drops. [jcbrand]\n- Add support for internationalization. [jcbrand]\n\n## 0.3.0 (2013-05-21)\n\n- Add vCard support [jcbrand]\n- Remember custom status messages upon reload. [jcbrand]\n- Remove jquery-ui dependency. [jcbrand]\n- Use backbone.localStorage to store the contacts roster, open chatboxes and chat messages. [jcbrand]\n- Fixed user status handling, which wasn't 100% according to the spec. [jcbrand]\n- Separate messages according to day in chats. [jcbrand]\n- Add support for specifying the BOSH bind URL as configuration setting. [jcbrand]\n- #8 Improve the message counter to only increment when the window is not focused [witekdev]\n- Make fetching of list of chatrooms on a server a configuration option. [jcbrand]\n- Use service discovery to show all available features on a room. [jcbrand]\n- Multi-user chatrooms are now configurable. [jcbrand]\n\n## 0.2.0 (2013-03-28)\n\n- Performance enhancements and general script cleanup [ichim-david]\n- Add \"Connecting to chat...\" info [alecghica]\n- Various smaller improvements and bugfixes [jcbrand]\n\n## 0.1.0 (2012-06-12)\n\n- Created [jcbrand]\n", "(function (root, factory) {\n    define([\n        \"utils\",\n        \"converse-api\",\n        \"mock\",\n        \"test_utils\"\n        ], factory);\n} (this, function (utils, converse_api, mock, test_utils) {\n    \"use strict\";\n    var _ = converse_api.env._;\n    var $ = converse_api.env.jQuery;\n    var $msg = converse_api.env.$msg;\n    var Strophe = converse_api.env.Strophe;\n    var moment = converse_api.env.moment;\n\n    return describe(\"Chatboxes\", function() {\n        describe(\"A Chatbox\", function () {\n            afterEach(function () {\n                converse_api.user.logout();\n                converse_api.listen.not();\n                test_utils.clearBrowserStorage();\n            });\n\n            it(\"is created when you click on a roster item\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                var i, $el, jid, chatboxview;\n                // openControlBox was called earlier, so the controlbox is\n                // visible, but no other chat boxes have been created.\n                expect(converse.chatboxes.length).toEqual(1);\n                spyOn(converse.chatboxviews, 'trimChats');\n                expect($(\"#conversejs .chatbox\").length).toBe(1); // Controlbox is open\n\n                var online_contacts = converse.rosterview.$el.find('dt.roster-group').siblings('dd.current-xmpp-contact').find('a.open-chat');\n                for (i=0; i<online_contacts.length; i++) {\n                    $el = $(online_contacts[i]);\n                    jid = $el.text().replace(/ /g,'.').toLowerCase() + '@localhost';\n                    $el.click();\n                    chatboxview = converse.chatboxviews.get(jid);\n                    expect(converse.chatboxes.length).toEqual(i+2);\n                    expect(converse.chatboxviews.trimChats).toHaveBeenCalled();\n                    // Check that new chat boxes are created to the left of the\n                    // controlbox (but to the right of all existing chat boxes)\n                    expect($(\"#conversejs .chatbox\").length).toBe(i+2);\n                    expect($(\"#conversejs .chatbox\")[1].id).toBe(chatboxview.model.get('box_id'));\n                }\n            }));\n\n            it(\"can be trimmed to conserve space\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                var i, $el, jid, chatbox, chatboxview, trimmedview;\n                // openControlBox was called earlier, so the controlbox is\n                // visible, but no other chat boxes have been created.\n                var trimmed_chatboxes = converse.minimized_chats;\n                expect(converse.chatboxes.length).toEqual(1);\n                spyOn(converse.chatboxviews, 'trimChats');\n                spyOn(trimmed_chatboxes, 'addChat').andCallThrough();\n                spyOn(trimmed_chatboxes, 'removeChat').andCallThrough();\n                expect($(\"#conversejs .chatbox\").length).toBe(1); // Controlbox is open\n\n                // Test that they can be trimmed\n                runs(function () {\n                    converse.rosterview.update(); // XXX: Hack to make sure $roster element is attaced.\n                });\n                waits(50);\n                runs(function () {\n                    // Test that they can be maximized again\n                    var online_contacts = converse.rosterview.$el.find('dt.roster-group').siblings('dd.current-xmpp-contact').find('a.open-chat');\n                    for (i=0; i<online_contacts.length; i++) {\n                        $el = $(online_contacts[i]);\n                        jid = $el.text().replace(/ /g,'.').toLowerCase() + '@localhost';\n                        $el.click();\n                        expect(converse.chatboxviews.trimChats).toHaveBeenCalled();\n\n                        chatboxview = converse.chatboxviews.get(jid);\n                        spyOn(chatboxview, 'minimize').andCallThrough();\n                        chatboxview.model.set({'minimized': true});\n                        expect(trimmed_chatboxes.addChat).toHaveBeenCalled();\n                        expect(chatboxview.minimize).toHaveBeenCalled();\n                        trimmedview = trimmed_chatboxes.get(jid);\n                    }\n                    var key = converse.chatboxviews.keys()[1];\n                    trimmedview = trimmed_chatboxes.get(key);\n                    chatbox = trimmedview.model;\n                    spyOn(chatbox, 'maximize').andCallThrough();\n                    spyOn(trimmedview, 'restore').andCallThrough();\n                    trimmedview.delegateEvents();\n                    trimmedview.$(\"a.restore-chat\").click();\n                });\n                waits(250);\n                runs(function () {\n                    expect(trimmedview.restore).toHaveBeenCalled();\n                    expect(chatbox.maximize).toHaveBeenCalled();\n                    expect(converse.chatboxviews.trimChats).toHaveBeenCalled();\n                });\n            }));\n\n            it(\"is focused if its already open and you click on its corresponding roster item\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost';\n                var $el, jid, chatboxview, chatbox;\n                // openControlBox was called earlier, so the controlbox is\n                // visible, but no other chat boxes have been created.\n                expect(converse.chatboxes.length).toEqual(1);\n                chatbox = test_utils.openChatBoxFor(converse, contact_jid);\n                chatboxview = converse.chatboxviews.get(contact_jid);\n                spyOn(chatboxview, 'focus');\n                // Test that they can be trimmed\n                runs(function () {\n                    converse.rosterview.update(); // XXX: Hack to make sure $roster element is attaced.\n                });\n                waits(300); // ChatBox.show() is debounced for 250ms\n                runs(function () {\n                    $el = converse.rosterview.$el.find('a.open-chat:contains(\"'+chatbox.get('fullname')+'\")');\n                    jid = $el.text().replace(/ /g,'.').toLowerCase() + '@localhost';\n                    $el.click();\n                    expect(converse.chatboxes.length).toEqual(2);\n                    expect(chatboxview.focus).toHaveBeenCalled();\n                });\n            }));\n\n            it(\"can be saved to, and retrieved from, browserStorage\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                spyOn(converse, 'emit');\n                spyOn(converse.chatboxviews, 'trimChats');\n                runs(function () {\n                    test_utils.openControlBox();\n                });\n                waits(250);\n                runs(function () {\n                    test_utils.openChatBoxes(converse, 6);\n                    expect(converse.chatboxviews.trimChats).toHaveBeenCalled();\n                    // We instantiate a new ChatBoxes collection, which by default\n                    // will be empty.\n                    var newchatboxes = new converse.ChatBoxes();\n                    expect(newchatboxes.length).toEqual(0);\n                    // The chatboxes will then be fetched from browserStorage inside the\n                    // onConnected method\n                    newchatboxes.onConnected();\n                    expect(newchatboxes.length).toEqual(7);\n                    // Check that the chatboxes items retrieved from browserStorage\n                    // have the same attributes values as the original ones.\n                    var attrs = ['id', 'box_id', 'visible'];\n                    var new_attrs, old_attrs;\n                    for (var i=0; i<attrs.length; i++) {\n                        new_attrs = _.pluck(_.pluck(newchatboxes.models, 'attributes'), attrs[i]);\n                        old_attrs = _.pluck(_.pluck(converse.chatboxes.models, 'attributes'), attrs[i]);\n                        expect(_.isEqual(new_attrs, old_attrs)).toEqual(true);\n                    }\n                    converse.rosterview.render();\n                });\n            }));\n\n            it(\"can be closed by clicking a DOM element with class 'close-chatbox-button'\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                var chatbox = test_utils.openChatBoxes(converse, 1)[0],\n                    controlview = converse.chatboxviews.get('controlbox'), // The controlbox is currently open\n                    chatview = converse.chatboxviews.get(chatbox.get('jid'));\n                spyOn(chatview, 'close').andCallThrough();\n                spyOn(controlview, 'close').andCallThrough();\n                spyOn(converse, 'emit');\n\n                // We need to rebind all events otherwise our spy won't be called\n                controlview.delegateEvents();\n                chatview.delegateEvents();\n\n                runs(function () {\n                    controlview.$el.find('.close-chatbox-button').click();\n                });\n                waits(250);\n                runs(function () {\n                    expect(controlview.close).toHaveBeenCalled();\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxClosed', jasmine.any(Object));\n                    expect(converse.emit.callCount, 1);\n                    chatview.$el.find('.close-chatbox-button').click();\n                });\n                waits(250);\n                runs(function () {\n                    expect(chatview.close).toHaveBeenCalled();\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxClosed', jasmine.any(Object));\n                    expect(converse.emit.callCount, 2);\n                });\n            }));\n\n            it(\"can be minimized by clicking a DOM element with class 'toggle-chatbox-button'\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                var chatbox = test_utils.openChatBoxes(converse, 1)[0],\n                    chatview = converse.chatboxviews.get(chatbox.get('jid')),\n                    trimmed_chatboxes = converse.minimized_chats,\n                    trimmedview;\n                spyOn(chatview, 'minimize').andCallThrough();\n                spyOn(converse, 'emit');\n                // We need to rebind all events otherwise our spy won't be called\n                chatview.delegateEvents();\n\n                runs(function () {\n                    chatview.$el.find('.toggle-chatbox-button').click();\n                });\n                waits(250);\n                runs(function () {\n                    expect(chatview.minimize).toHaveBeenCalled();\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxMinimized', jasmine.any(Object));\n                    expect(converse.emit.callCount, 2);\n                    expect(chatview.$el.is(':visible')).toBeFalsy();\n                    expect(chatview.model.get('minimized')).toBeTruthy();\n                    chatview.$el.find('.toggle-chatbox-button').click();\n                    trimmedview = trimmed_chatboxes.get(chatview.model.get('id'));\n                    spyOn(trimmedview, 'restore').andCallThrough();\n                    trimmedview.delegateEvents();\n                    trimmedview.$(\"a.restore-chat\").click();\n                });\n                waits(250);\n                runs(function () {\n                    expect(trimmedview.restore).toHaveBeenCalled();\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxMaximized', jasmine.any(Object));\n                    expect(chatview.$el.find('.chat-body').is(':visible')).toBeTruthy();\n                    expect(chatview.$el.find('.toggle-chatbox-button').hasClass('icon-minus')).toBeTruthy();\n                    expect(chatview.$el.find('.toggle-chatbox-button').hasClass('icon-plus')).toBeFalsy();\n                    expect(chatview.model.get('minimized')).toBeFalsy();\n                });\n            }));\n\n            it(\"will be removed from browserStorage when closed\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                spyOn(converse, 'emit');\n                spyOn(converse.chatboxviews, 'trimChats');\n                converse.chatboxes.browserStorage._clear();\n                runs(function () {\n                    test_utils.closeControlBox();\n                });\n                waits(50);\n                runs(function () {\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxClosed', jasmine.any(Object));\n                    expect(converse.chatboxes.length).toEqual(1);\n                    expect(converse.chatboxes.pluck('id')).toEqual(['controlbox']);\n                    test_utils.openChatBoxes(converse, 6);\n                    expect(converse.chatboxviews.trimChats).toHaveBeenCalled();\n                    expect(converse.chatboxes.length).toEqual(7);\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxOpened', jasmine.any(Object));\n                    test_utils.closeAllChatBoxes(converse);\n                });\n                waits(50);\n                runs(function () {\n                    expect(converse.chatboxes.length).toEqual(1);\n                    expect(converse.chatboxes.pluck('id')).toEqual(['controlbox']);\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxClosed', jasmine.any(Object));\n                    var newchatboxes = new converse.ChatBoxes();\n                    expect(newchatboxes.length).toEqual(0);\n                    expect(converse.chatboxes.pluck('id')).toEqual(['controlbox']);\n                    // onConnected will fetch chatboxes in browserStorage, but\n                    // because there aren't any open chatboxes, there won't be any\n                    // in browserStorage either. XXX except for the controlbox\n                    newchatboxes.onConnected();\n                    expect(newchatboxes.length).toEqual(1);\n                    expect(newchatboxes.models[0].id).toBe(\"controlbox\");\n                });\n            }));\n\n            describe(\"A chat toolbar\", function () {\n                afterEach(function () {\n                    converse_api.user.logout();\n                    converse_api.listen.not();\n                    test_utils.clearBrowserStorage();\n                });\n\n                it(\"can be found on each chat box\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var chatbox = converse.chatboxes.get(contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    expect(chatbox).toBeDefined();\n                    expect(view).toBeDefined();\n                    var $toolbar = view.$el.find('ul.chat-toolbar');\n                    expect($toolbar.length).toBe(1);\n                    expect($toolbar.children('li').length).toBe(3);\n                }));\n\n                it(\"contains a button for inserting emoticons\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost',\n                        view, $toolbar, $textarea;\n                    waits(300); // ChatBox.show() is debounced for 250ms\n                    runs(function () {\n                        test_utils.openChatBoxFor(converse, contact_jid);\n                        view = converse.chatboxviews.get(contact_jid);\n                        $toolbar = view.$el.find('ul.chat-toolbar');\n                        $textarea = view.$el.find('textarea.chat-textarea');\n                        expect($toolbar.children('li.toggle-smiley').length).toBe(1);\n                        // Register spies\n                        spyOn(view, 'toggleEmoticonMenu').andCallThrough();\n                        spyOn(view, 'insertEmoticon').andCallThrough();\n                        view.delegateEvents(); // We need to rebind all events otherwise our spy won't be called\n                        $toolbar.children('li.toggle-smiley').click();\n                    });\n                    waits(250);\n                    runs(function () {\n                        expect(view.toggleEmoticonMenu).toHaveBeenCalled();\n                        var $menu = view.$el.find('.toggle-smiley ul');\n                        var $items = $menu.children('li');\n                        expect($menu.is(':visible')).toBeTruthy();\n                        expect($items.length).toBe(13);\n                        expect($($items[0]).children('a').data('emoticon')).toBe(':)');\n                        expect($($items[1]).children('a').data('emoticon')).toBe(';)');\n                        expect($($items[2]).children('a').data('emoticon')).toBe(':D');\n                        expect($($items[3]).children('a').data('emoticon')).toBe(':P');\n                        expect($($items[4]).children('a').data('emoticon')).toBe('8)');\n                        expect($($items[5]).children('a').data('emoticon')).toBe('>:)');\n                        expect($($items[6]).children('a').data('emoticon')).toBe(':S');\n                        expect($($items[7]).children('a').data('emoticon')).toBe(':\\\\');\n                        expect($($items[8]).children('a').data('emoticon')).toBe('>:(');\n                        expect($($items[9]).children('a').data('emoticon')).toBe(':(');\n                        expect($($items[10]).children('a').data('emoticon')).toBe(':O');\n                        expect($($items[11]).children('a').data('emoticon')).toBe('(^.^)b');\n                        expect($($items[12]).children('a').data('emoticon')).toBe('<3');\n                        $items.first().click();\n                    });\n                    waits(250);\n                    runs(function () {\n                        expect(view.insertEmoticon).toHaveBeenCalled();\n                        expect($textarea.val()).toBe(':) ');\n                        expect(view.$el.find('.toggle-smiley ul').is(':visible')).toBeFalsy();\n                        $toolbar.children('li.toggle-smiley').click();\n                    });\n                    waits(250);\n                    runs(function () {\n                        expect(view.toggleEmoticonMenu).toHaveBeenCalled();\n                        expect(view.$el.find('.toggle-smiley ul').is(':visible')).toBeTruthy();\n                        view.$el.find('.toggle-smiley ul').children('li').last().click();\n                    });\n                    waits(250);\n                    runs(function () {\n                        expect(view.insertEmoticon).toHaveBeenCalled();\n                        expect(view.$el.find('.toggle-smiley ul').is(':visible')).toBeFalsy();\n                        expect($textarea.val()).toBe(':) <3 ');\n                    });\n                }));\n\n                it(\"contains a button for starting an encrypted chat session\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    // TODO: More tests can be added here...\n                    var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    var $toolbar = view.$el.find('ul.chat-toolbar');\n                    expect($toolbar.children('li.toggle-otr').length).toBe(1);\n                    // Register spies\n                    spyOn(view, 'toggleOTRMenu').andCallThrough();\n                    view.delegateEvents(); // We need to rebind all events otherwise our spy won't be called\n\n                    runs(function () {\n                        $toolbar.children('li.toggle-otr').click();\n                    });\n                    waits(250);\n                    runs(function () {\n                        expect(view.toggleOTRMenu).toHaveBeenCalled();\n                        var $menu = view.$el.find('.toggle-otr ul');\n                        expect($menu.is(':visible')).toBeTruthy();\n                        expect($menu.children('li').length).toBe(2);\n                    });\n\n                }));\n\n                it(\"can contain a button for starting a call\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var view, callButton, $toolbar;\n                    var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    spyOn(converse, 'emit');\n                    // First check that the button doesn't show if it's not enabled\n                    // via \"visible_toolbar_buttons\"\n                    converse.visible_toolbar_buttons.call = false;\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    view = converse.chatboxviews.get(contact_jid);\n                    $toolbar = view.$el.find('ul.chat-toolbar');\n                    callButton = $toolbar.find('.toggle-call');\n                    expect(callButton.length).toBe(0);\n                    view.close();\n                    // Now check that it's shown if enabled and that it emits\n                    // callButtonClicked\n                    converse.visible_toolbar_buttons.call = true; // enable the button\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    view = converse.chatboxviews.get(contact_jid);\n                    $toolbar = view.$el.find('ul.chat-toolbar');\n                    callButton = $toolbar.find('.toggle-call');\n                    expect(callButton.length).toBe(1);\n                    callButton.click();\n                    expect(converse.emit).toHaveBeenCalledWith('callButtonClicked', jasmine.any(Object));\n                }));\n\n                it(\"can contain a button for clearing messages\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var view, clearButton, $toolbar;\n                    var contact_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    // First check that the button doesn't show if it's not enabled\n                    // via \"visible_toolbar_buttons\"\n                    converse.visible_toolbar_buttons.clear = false;\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    view = converse.chatboxviews.get(contact_jid);\n                    view = converse.chatboxviews.get(contact_jid);\n                    $toolbar = view.$el.find('ul.chat-toolbar');\n                    clearButton = $toolbar.find('.toggle-clear');\n                    expect(clearButton.length).toBe(0);\n                    view.close();\n                    // Now check that it's shown if enabled and that it calls\n                    // clearMessages\n                    converse.visible_toolbar_buttons.clear = true; // enable the button\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    view = converse.chatboxviews.get(contact_jid);\n                    $toolbar = view.$el.find('ul.chat-toolbar');\n                    clearButton = $toolbar.find('.toggle-clear');\n                    expect(clearButton.length).toBe(1);\n                    spyOn(view, 'clearMessages');\n                    view.delegateEvents(); // We need to rebind all events otherwise our spy won't be called\n                    clearButton.click();\n                    expect(view.clearMessages).toHaveBeenCalled();\n                }));\n            });\n\n            describe(\"A Chat Message\", function () {\n                afterEach(function () {\n                    converse_api.user.logout();\n                    converse_api.listen.not();\n                    test_utils.clearBrowserStorage();\n                });\n\n                describe(\"when received from someone else\", function () {\n                    it(\"can be received which will open a chatbox and be displayed inside it\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        spyOn(converse, 'emit');\n                        var message = 'converse is a received message';\n                        var sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        var msg = $msg({\n                                from: sender_jid,\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').t(message).up()\n                            .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n\n                        // We don't already have an open chatbox for this user\n                        expect(converse.chatboxes.get(sender_jid)).not.toBeDefined();\n\n                        runs(function () {\n                            // onMessage is a handler for received XMPP messages\n                            converse.chatboxes.onMessage(msg);\n                            expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        });\n                        waits(50);\n                        runs(function () {\n                            // Check that the chatbox and its view now exist\n                            var chatbox = converse.chatboxes.get(sender_jid);\n                            var chatboxview = converse.chatboxviews.get(sender_jid);\n                            expect(chatbox).toBeDefined();\n                            expect(chatboxview).toBeDefined();\n                            // Check that the message was received and check the message parameters\n                            expect(chatbox.messages.length).toEqual(1);\n                            var msg_obj = chatbox.messages.models[0];\n                            expect(msg_obj.get('message')).toEqual(message);\n                            expect(msg_obj.get('fullname')).toEqual(mock.cur_names[0]);\n                            expect(msg_obj.get('sender')).toEqual('them');\n                            expect(msg_obj.get('delayed')).toEqual(false);\n                            // Now check that the message appears inside the chatbox in the DOM\n                            var $chat_content = chatboxview.$el.find('.chat-content');\n                            var msg_txt = $chat_content.find('.chat-message').find('.chat-msg-content').text();\n                            expect(msg_txt).toEqual(message);\n                            var sender_txt = $chat_content.find('span.chat-msg-them').text();\n                            expect(sender_txt.match(/^[0-9][0-9]:[0-9][0-9] /)).toBeTruthy();\n                        });\n                    }));\n\n                    describe(\"and for which then an error message is received from the server\", function () {\n                        afterEach(function () {\n                            converse_api.user.logout();\n                            converse_api.listen.not();\n                            test_utils.clearBrowserStorage();\n                        });\n\n                        it(\"will have the error message displayed after itself\", mock.initConverse(function (converse) {\n                            test_utils.createContacts(converse, 'current');\n                            test_utils.openControlBox();\n                            test_utils.openContactsPanel(converse);\n\n                            // TODO: what could still be done for error\n                            // messages... if the <error> element has type\n                            // \"cancel\", then we know the messages wasn't sent,\n                            // and can give the user a nicer indication of\n                            // that.\n\n                            /* <message from=\"scotty@enterprise.com/converse.js-84843526\"\n                             *          to=\"kirk@enterprise.com.com\"\n                             *          type=\"chat\"\n                             *          id=\"82bc02ce-9651-4336-baf0-fa04762ed8d2\"\n                             *          xmlns=\"jabber:client\">\n                             *      <body>yo</body>\n                             *      <active xmlns=\"http://jabber.org/protocol/chatstates\"/>\n                             *  </message>\n                             */\n                            var sender_jid = mock.cur_names[5].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            var fullname = converse.xmppstatus.get('fullname');\n                            fullname = _.isEmpty(fullname)? converse.bare_jid: fullname;\n                            converse_api.chats.open(sender_jid);\n                            var msg_text = 'This message will not be sent, due to an error';\n                            var view = converse.chatboxviews.get(sender_jid);\n                            var message = view.model.messages.create({\n                                'msgid': '82bc02ce-9651-4336-baf0-fa04762ed8d2',\n                                'fullname': fullname,\n                                'sender': 'me',\n                                'time': moment().format(),\n                                'message': msg_text\n                            });\n                            view.sendMessage(message);\n                            var $chat_content = view.$el.find('.chat-content');\n                            var msg_txt = $chat_content.find('.chat-message:last').find('.chat-msg-content').text();\n                            expect(msg_txt).toEqual(msg_text);\n\n                            // We send another message, for which an error will\n                            // not be received, to test that errors appear\n                            // after the relevant message.\n                            msg_text = 'This message will be sent, and not receive an error';\n                            message = view.model.messages.create({\n                                'msgid': '6fcdeee3-000f-4ce8-a17e-9ce28f0ae104',\n                                'fullname': fullname,\n                                'sender': 'me',\n                                'time': moment().format(),\n                                'message': msg_text\n                            });\n                            view.sendMessage(message);\n                            msg_txt = $chat_content.find('.chat-message:last').find('.chat-msg-content').text();\n                            expect(msg_txt).toEqual(msg_text);\n\n                            /* <message xmlns=\"jabber:client\"\n                             *          to=\"scotty@enterprise.com/converse.js-84843526\"\n                             *          type=\"error\"\n                             *          id=\"82bc02ce-9651-4336-baf0-fa04762ed8d2\"\n                             *          from=\"kirk@enterprise.com.com\">\n                             *     <error type=\"cancel\">\n                             *         <remote-server-not-found xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\"/>\n                             *         <text xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\">Server-to-server connection failed: Connecting failed: connection timeout</text>\n                             *     </error>\n                             * </message>\n                             */\n                            var error_txt = 'Server-to-server connection failed: Connecting failed: connection timeout';\n                            var stanza = $msg({\n                                    'to': converse.connection.jid,\n                                    'type':'error',\n                                    'id':'82bc02ce-9651-4336-baf0-fa04762ed8d2',\n                                    'from': sender_jid\n                                })\n                                .c('error', {'type': 'cancel'})\n                                .c('remote-server-not-found', { 'xmlns': \"urn:ietf:params:xml:ns:xmpp-stanzas\" }).up()\n                                .c('text', { 'xmlns': \"urn:ietf:params:xml:ns:xmpp-stanzas\" })\n                                    .t('Server-to-server connection failed: Connecting failed: connection timeout');\n                            converse.connection._dataRecv(test_utils.createRequest(stanza));\n                            expect($chat_content.find('.chat-error').text()).toEqual(error_txt);\n\n                            /* Incoming error messages that are not tied to a\n                             * certain show message (via the msgid attribute),\n                             * are not shown at all. The reason for this is\n                             * that we may get error messages for chat state\n                             * notifications as well.\n                             */\n                            stanza = $msg({\n                                    'to': converse.connection.jid,\n                                    'type':'error',\n                                    'id':'some-other-unused-id',\n                                    'from': sender_jid\n                                })\n                                .c('error', {'type': 'cancel'})\n                                .c('remote-server-not-found', { 'xmlns': \"urn:ietf:params:xml:ns:xmpp-stanzas\" }).up()\n                                .c('text', { 'xmlns': \"urn:ietf:params:xml:ns:xmpp-stanzas\" })\n                                    .t('Server-to-server connection failed: Connecting failed: connection timeout');\n                            converse.connection._dataRecv(test_utils.createRequest(stanza));\n                            expect($chat_content.find('.chat-error').length).toEqual(1);\n                        }));\n                    });\n\n                    it(\"will cause the chat area to be scrolled down only if it was at the bottom already\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        var message = 'This message is received while the chat area is scrolled up';\n                        var sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        test_utils.openChatBoxFor(converse, sender_jid);\n                        var chatboxview = converse.chatboxviews.get(sender_jid);\n                        spyOn(chatboxview, 'scrollDown').andCallThrough();\n                        runs(function () {\n                            /* Create enough messages so that there's a\n                             * scrollbar.\n                             */\n                            for (var i=0; i<20; i++) {\n                                converse.chatboxes.onMessage($msg({\n                                        from: sender_jid,\n                                        to: converse.connection.jid,\n                                        type: 'chat',\n                                        id: (new Date()).getTime()\n                                    }).c('body').t('Message: '+i).up()\n                                    .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree());\n                            }\n                        });\n                        waits(50);\n                        runs(function () {\n                            chatboxview.$content.scrollTop(0);\n                        });\n                        waits(250);\n                        runs(function () {\n                            converse.chatboxes.onMessage($msg({\n                                    from: sender_jid,\n                                    to: converse.connection.jid,\n                                    type: 'chat',\n                                    id: (new Date()).getTime()\n                                }).c('body').t(message).up()\n                                .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree());\n                        });\n                        waits(150);\n                        runs(function () {\n                            // Now check that the message appears inside the chatbox in the DOM\n                            var $chat_content = chatboxview.$el.find('.chat-content');\n                            var msg_txt = $chat_content.find('.chat-message:last').find('.chat-msg-content').text();\n                            expect(msg_txt).toEqual(message);\n                            expect(chatboxview.model.get('scrolled')).toBeTruthy();\n                            expect(chatboxview.$content.scrollTop()).toBe(0);\n                            expect(chatboxview.$('.new-msgs-indicator').is(':visible')).toBeTruthy();\n                            // Scroll down again\n                            chatboxview.$content.scrollTop(chatboxview.$content[0].scrollHeight);\n                        });\n                        waits(250);\n                        runs(function () {\n                            expect(chatboxview.$('.new-msgs-indicator').is(':visible')).toBeFalsy();\n                        });\n                    }));\n\n                    it(\"is ignored if it's intended for a different resource and filter_by_resource is set to true\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        // Send a message from a different resource\n                        var message, sender_jid, msg;\n                        spyOn(converse, 'log');\n                        spyOn(converse.chatboxes, 'getChatBox').andCallThrough();\n                        runs(function () {\n                            converse.filter_by_resource = true;\n                            sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            msg = $msg({\n                                    from: sender_jid,\n                                    to: converse.bare_jid+'/'+\"some-other-resource\",\n                                    type: 'chat',\n                                    id: (new Date()).getTime()\n                                }).c('body').t(\"This message will not be shown\").up()\n                                .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                            converse.chatboxes.onMessage(msg);\n                        });\n                        waits(50);\n                        runs(function () {\n                            expect(converse.log).toHaveBeenCalledWith(\n                                    \"onMessage: Ignoring incoming message intended for a different resource: dummy@localhost/some-other-resource\", \"info\");\n                            expect(converse.chatboxes.getChatBox).not.toHaveBeenCalled();\n                            converse.filter_by_resource = false;\n                        });\n                        waits(50);\n                        runs(function () {\n                            message = \"This message sent to a different resource will be shown\";\n                            msg = $msg({\n                                    from: sender_jid,\n                                    to: converse.bare_jid+'/'+\"some-other-resource\",\n                                    type: 'chat',\n                                    id: '134234623462346'\n                                }).c('body').t(message).up()\n                                .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                            converse.chatboxes.onMessage(msg);\n                        });\n                        waits(50);\n                        runs(function () {\n                            expect(converse.chatboxes.getChatBox).toHaveBeenCalled();\n                            var chatboxview = converse.chatboxviews.get(sender_jid);\n                            var $chat_content = chatboxview.$el.find('.chat-content:last');\n                            var msg_txt = $chat_content.find('.chat-message').find('.chat-msg-content').text();\n                            expect(msg_txt).toEqual(message);\n                        });\n                    }));\n                });\n\n                describe(\"when sent by the current user\", function () {\n                    it(\"will always cause the chat area to be scrolled down\", mock.initConverse(function (converse) {\n                        // TODO\n                    }));\n                });\n\n                it(\"is ignored if it's a malformed headline message\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    /* Ideally we wouldn't have to filter out headline\n                     * messages, but Prosody gives them the wrong 'type' :(\n                     */\n                    sinon.spy(converse, 'log');\n                    sinon.spy(converse.chatboxes, 'getChatBox');\n                    sinon.spy(utils, 'isHeadlineMessage');\n                    var msg = $msg({\n                            from: 'localhost',\n                            to: converse.bare_jid,\n                            type: 'chat',\n                            id: (new Date()).getTime()\n                        }).c('body').t(\"This headline message will not be shown\").tree();\n                    converse.chatboxes.onMessage(msg);\n                    expect(converse.log.calledWith(\n                        \"onMessage: Ignoring incoming headline message sent with type 'chat' from JID: localhost\",\n                        \"info\"\n                    )).toBeTruthy();\n                    expect(utils.isHeadlineMessage.called).toBeTruthy();\n                    expect(utils.isHeadlineMessage.returned(true)).toBeTruthy();\n                    expect(converse.chatboxes.getChatBox.called).toBeFalsy();\n                    // Remove sinon spies\n                    converse.log.restore();\n                    converse.chatboxes.getChatBox.restore();\n                    utils.isHeadlineMessage.restore();\n                }));\n\n                it(\"can be a carbon message, as defined in XEP-0280\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    // Send a message from a different resource\n                    spyOn(converse, 'log');\n                    var msgtext = 'This is a carbon message';\n                    var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    var msg = $msg({\n                            'from': sender_jid,\n                            'id': (new Date()).getTime(),\n                            'to': converse.connection.jid,\n                            'type': 'chat',\n                            'xmlns': 'jabber:client'\n                        }).c('received', {'xmlns': 'urn:xmpp:carbons:2'})\n                          .c('forwarded', {'xmlns': 'urn:xmpp:forward:0'})\n                          .c('message', {\n                                'xmlns': 'jabber:client',\n                                'from': sender_jid,\n                                'to': converse.bare_jid+'/another-resource',\n                                'type': 'chat'\n                        }).c('body').t(msgtext).tree();\n                    converse.chatboxes.onMessage(msg);\n\n                    // Check that the chatbox and its view now exist\n                    var chatbox = converse.chatboxes.get(sender_jid);\n                    var chatboxview = converse.chatboxviews.get(sender_jid);\n                    expect(chatbox).toBeDefined();\n                    expect(chatboxview).toBeDefined();\n                    // Check that the message was received and check the message parameters\n                    expect(chatbox.messages.length).toEqual(1);\n                    var msg_obj = chatbox.messages.models[0];\n                    expect(msg_obj.get('message')).toEqual(msgtext);\n                    expect(msg_obj.get('fullname')).toEqual(mock.cur_names[1]);\n                    expect(msg_obj.get('sender')).toEqual('them');\n                    expect(msg_obj.get('delayed')).toEqual(false);\n                    // Now check that the message appears inside the chatbox in the DOM\n                    var $chat_content = chatboxview.$el.find('.chat-content');\n                    var msg_txt = $chat_content.find('.chat-message').find('.chat-msg-content').text();\n                    expect(msg_txt).toEqual(msgtext);\n                    var sender_txt = $chat_content.find('span.chat-msg-them').text();\n                    expect(sender_txt.match(/^[0-9][0-9]:[0-9][0-9] /)).toBeTruthy();\n                }));\n\n                it(\"can be a carbon message that this user sent from a different client, as defined in XEP-0280\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    // Send a message from a different resource\n                    spyOn(converse, 'log');\n                    var msgtext = 'This is a sent carbon message';\n                    var recipient_jid = mock.cur_names[5].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    var msg = $msg({\n                            'from': converse.bare_jid,\n                            'id': (new Date()).getTime(),\n                            'to': converse.connection.jid,\n                            'type': 'chat',\n                            'xmlns': 'jabber:client'\n                        }).c('sent', {'xmlns': 'urn:xmpp:carbons:2'})\n                          .c('forwarded', {'xmlns': 'urn:xmpp:forward:0'})\n                          .c('message', {\n                                'xmlns': 'jabber:client',\n                                'from': converse.bare_jid+'/another-resource',\n                                'to': recipient_jid,\n                                'type': 'chat'\n                        }).c('body').t(msgtext).tree();\n                    converse.chatboxes.onMessage(msg);\n\n                    // Check that the chatbox and its view now exist\n                    var chatbox = converse.chatboxes.get(recipient_jid);\n                    var chatboxview = converse.chatboxviews.get(recipient_jid);\n                    expect(chatbox).toBeDefined();\n                    expect(chatboxview).toBeDefined();\n                    // Check that the message was received and check the message parameters\n                    expect(chatbox.messages.length).toEqual(1);\n                    var msg_obj = chatbox.messages.models[0];\n                    expect(msg_obj.get('message')).toEqual(msgtext);\n                    expect(msg_obj.get('fullname')).toEqual(mock.cur_names[5]);\n                    expect(msg_obj.get('sender')).toEqual('me');\n                    expect(msg_obj.get('delayed')).toEqual(false);\n                    // Now check that the message appears inside the chatbox in the DOM\n                    var $chat_content = chatboxview.$el.find('.chat-content');\n                    var msg_txt = $chat_content.find('.chat-message').find('.chat-msg-content').text();\n                    expect(msg_txt).toEqual(msgtext);\n                }));\n\n                it(\"will be discarded if it's a malicious message meant to look like a carbon copy\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n                    /* <message from=\"mallory@evil.example\" to=\"b@xmpp.example\">\n                     *    <received xmlns='urn:xmpp:carbons:2'>\n                     *      <forwarded xmlns='urn:xmpp:forward:0'>\n                     *          <message from=\"alice@xmpp.example\" to=\"bob@xmpp.example/client1\">\n                     *              <body>Please come to Creepy Valley tonight, alone!</body>\n                     *          </message>\n                     *      </forwarded>\n                     *    </received>\n                     * </message>\n                     */\n                    spyOn(converse, 'log');\n                    var msgtext = 'Please come to Creepy Valley tonight, alone!';\n                    var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    var impersonated_jid = mock.cur_names[2].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    var msg = $msg({\n                            'from': sender_jid,\n                            'id': (new Date()).getTime(),\n                            'to': converse.connection.jid,\n                            'type': 'chat',\n                            'xmlns': 'jabber:client'\n                        }).c('received', {'xmlns': 'urn:xmpp:carbons:2'})\n                          .c('forwarded', {'xmlns': 'urn:xmpp:forward:0'})\n                          .c('message', {\n                                'xmlns': 'jabber:client',\n                                'from': impersonated_jid,\n                                'to': converse.connection.jid,\n                                'type': 'chat'\n                        }).c('body').t(msgtext).tree();\n                    converse.chatboxes.onMessage(msg);\n\n                    // Check that chatbox for impersonated user is not created.\n                    var chatbox = converse.chatboxes.get(impersonated_jid);\n                    expect(chatbox).not.toBeDefined();\n\n                    // Check that the chatbox for the malicous user is not created\n                    chatbox = converse.chatboxes.get(sender_jid);\n                    expect(chatbox).not.toBeDefined();\n                }));\n\n                it(\"received for a minimized chat box will increment a counter on its header\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n                    var contact_name = mock.cur_names[0];\n                    var contact_jid = contact_name.replace(/ /g,'.').toLowerCase() + '@localhost';\n                    runs(function () {\n                        spyOn(converse, 'emit').andCallThrough();\n                        test_utils.openChatBoxFor(converse, contact_jid);\n                        var chatview = converse.chatboxviews.get(contact_jid);\n                        expect(chatview.$el.is(':visible')).toBeTruthy();\n                        expect(chatview.model.get('minimized')).toBeFalsy();\n                        chatview.$el.find('.toggle-chatbox-button').click();\n                        expect(chatview.model.get('minimized')).toBeTruthy();\n                        var message = 'This message is sent to a minimized chatbox';\n                        var sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        var msg = $msg({\n                            from: sender_jid,\n                            to: converse.connection.jid,\n                            type: 'chat',\n                            id: (new Date()).getTime()\n                        }).c('body').t(message).up()\n                        .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                        converse.chatboxes.onMessage(msg);\n                        expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        var trimmed_chatboxes = converse.minimized_chats;\n                        var trimmedview = trimmed_chatboxes.get(contact_jid);\n                        var $count = trimmedview.$el.find('.chat-head-message-count');\n                        expect(chatview.$el.is(':visible')).toBeFalsy();\n                        expect(trimmedview.model.get('minimized')).toBeTruthy();\n                        expect($count.is(':visible')).toBeTruthy();\n                        expect($count.html()).toBe('1');\n                        converse.chatboxes.onMessage(\n                            $msg({\n                                from: mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost',\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').t('This message is also sent to a minimized chatbox').up()\n                            .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree()\n                        );\n                        expect(chatview.$el.is(':visible')).toBeFalsy();\n                        expect(trimmedview.model.get('minimized')).toBeTruthy();\n                        $count = trimmedview.$el.find('.chat-head-message-count');\n                        expect($count.is(':visible')).toBeTruthy();\n                        expect($count.html()).toBe('2');\n                        trimmedview.$el.find('.restore-chat').click();\n                        expect(trimmed_chatboxes.keys().length).toBe(0);\n                    });\n                }));\n\n                it(\"will indicate when it has a time difference of more than a day between it and its predecessor\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    spyOn(converse, 'emit');\n                    var contact_name = mock.cur_names[1];\n                    var contact_jid = contact_name.replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    test_utils.clearChatBoxMessages(converse, contact_jid);\n                    var one_day_ago = moment();\n                    one_day_ago.subtract('days', 1);\n                    var message = 'This is a day old message';\n                    var chatbox = converse.chatboxes.get(contact_jid);\n                    var chatboxview = converse.chatboxviews.get(contact_jid);\n                    var $chat_content = chatboxview.$el.find('.chat-content');\n                    var msg_obj;\n                    var msg_txt;\n                    var sender_txt;\n\n                    var msg = $msg({\n                        from: contact_jid,\n                        to: converse.connection.jid,\n                        type: 'chat',\n                        id: one_day_ago.unix()\n                    }).c('body').t(message).up()\n                      .c('delay', { xmlns:'urn:xmpp:delay', from: 'localhost', stamp: one_day_ago.format() })\n                      .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                    converse.chatboxes.onMessage(msg);\n                    expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                    expect(chatbox.messages.length).toEqual(1);\n                    msg_obj = chatbox.messages.models[0];\n                    expect(msg_obj.get('message')).toEqual(message);\n                    expect(msg_obj.get('fullname')).toEqual(contact_name);\n                    expect(msg_obj.get('sender')).toEqual('them');\n                    expect(msg_obj.get('delayed')).toEqual(true);\n                    msg_txt = $chat_content.find('.chat-message').find('.chat-msg-content').text();\n                    expect(msg_txt).toEqual(message);\n                    sender_txt = $chat_content.find('span.chat-msg-them').text();\n                    expect(sender_txt.match(/^[0-9][0-9]:[0-9][0-9] /)).toBeTruthy();\n\n                    var $time = $chat_content.find('time');\n                    expect($time.length).toEqual(1);\n                    expect($time.attr('class')).toEqual('chat-info chat-date');\n                    expect($time.data('isodate')).toEqual(moment(one_day_ago.startOf('day')).format());\n                    expect($time.text()).toEqual(moment(one_day_ago.startOf('day')).format(\"dddd MMM Do YYYY\"));\n\n                    message = 'This is a current message';\n                    msg = $msg({\n                        from: contact_jid,\n                        to: converse.connection.jid,\n                        type: 'chat',\n                        id: new Date().getTime()\n                    }).c('body').t(message).up()\n                      .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                    converse.chatboxes.onMessage(msg);\n                    expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                    // Check that there is a <time> element, with the required\n                    // props.\n                    $time = $chat_content.find('time');\n                    expect($time.length).toEqual(2); // There are now two time elements\n                    $time = $chat_content.find('time:last'); // We check the last one\n                    var message_date = new Date();\n                    expect($time.attr('class')).toEqual('chat-info chat-date');\n                    expect($time.data('isodate')).toEqual(moment(message_date).startOf('day').format());\n                    expect($time.text()).toEqual(moment(message_date).startOf('day').format(\"dddd MMM Do YYYY\"));\n\n                    // Normal checks for the 2nd message\n                    expect(chatbox.messages.length).toEqual(2);\n                    msg_obj = chatbox.messages.models[1];\n                    expect(msg_obj.get('message')).toEqual(message);\n                    expect(msg_obj.get('fullname')).toEqual(contact_name);\n                    expect(msg_obj.get('sender')).toEqual('them');\n                    expect(msg_obj.get('delayed')).toEqual(false);\n                    msg_txt = $chat_content.find('.chat-message').last().find('.chat-msg-content').text();\n                    expect(msg_txt).toEqual(message);\n                    sender_txt = $chat_content.find('span.chat-msg-them').last().text();\n                    expect(sender_txt.match(/^[0-9][0-9]:[0-9][0-9] /)).toBeTruthy();\n                }));\n\n                it(\"can be sent from a chatbox, and will appear inside it\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    spyOn(converse, 'emit');\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    expect(converse.emit).toHaveBeenCalledWith('chatBoxFocused', jasmine.any(Object));\n                    var view = converse.chatboxviews.get(contact_jid);\n                    var message = 'This message is sent from this chatbox';\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    test_utils.sendMessage(view, message);\n                    expect(view.sendMessage).toHaveBeenCalled();\n                    expect(view.model.messages.length, 2);\n                    expect(converse.emit.mostRecentCall.args, ['messageSend', message]);\n                    expect(view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content').text()).toEqual(message);\n                }));\n\n                it(\"is sanitized to prevent Javascript injection attacks\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    var message = '<p>This message contains <em>some</em> <b>markup</b></p>';\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    test_utils.sendMessage(view, message);\n                    expect(view.sendMessage).toHaveBeenCalled();\n                    var msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                    expect(msg.text()).toEqual(message);\n                    expect(msg.html()).toEqual('&lt;p&gt;This message contains &lt;em&gt;some&lt;/em&gt; &lt;b&gt;markup&lt;/b&gt;&lt;/p&gt;');\n                }));\n\n                it(\"should display emoticons correctly\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    var messages = [':)', ';)', ':D', ':P', '8)', '>:)', ':S', ':\\\\', '>:(', ':(', ':O', '(^.^)b', '<3'];\n                    var emoticons = [\n                        '<span class=\"emoticon icon-smiley\"></span>', '<span class=\"emoticon icon-wink\"></span>',\n                        '<span class=\"emoticon icon-grin\"></span>', '<span class=\"emoticon icon-tongue\"></span>',\n                        '<span class=\"emoticon icon-cool\"></span>', '<span class=\"emoticon icon-evil\"></span>',\n                        '<span class=\"emoticon icon-confused\"></span>', '<span class=\"emoticon icon-wondering\"></span>',\n                        '<span class=\"emoticon icon-angry\"></span>', '<span class=\"emoticon icon-sad\"></span>',\n                        '<span class=\"emoticon icon-shocked\"></span>', '<span class=\"emoticon icon-thumbs-up\"></span>',\n                        '<span class=\"emoticon icon-heart\"></span>'\n                        ];\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    for (var i = 0; i < messages.length; i++) {\n                        var message = messages[i];\n                        test_utils.sendMessage(view, message);\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        var msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.html()).toEqual(emoticons[i]);\n                    }\n                }));\n\n                it(\"can contain hyperlinks, which will be clickable\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    var message = 'This message contains a hyperlink: www.opkode.com';\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    runs(function () {\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(500);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        var msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.text()).toEqual(message);\n                        expect(msg.html()).toEqual('This message contains a hyperlink: <a target=\"_blank\" rel=\"noopener\" href=\"http://www.opkode.com\">www.opkode.com</a>');\n                    });\n                }));\n\n                it(\"will have properly escaped URLs\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    var message, msg;\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    runs(function () {\n                        message = \"http://www.opkode.com/'onmouseover='alert(1)'whatever\";\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(50);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.text()).toEqual(message);\n                        expect(msg.html()).toEqual('<a target=\"_blank\" rel=\"noopener\" href=\"http://www.opkode.com/%27onmouseover=%27alert%281%29%27whatever\">http://www.opkode.com/\\'onmouseover=\\'alert(1)\\'whatever</a>');\n\n                        message = 'http://www.opkode.com/\"onmouseover=\"alert(1)\"whatever';\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(50);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.text()).toEqual(message);\n                        expect(msg.html()).toEqual('<a target=\"_blank\" rel=\"noopener\" href=\"http://www.opkode.com/%22onmouseover=%22alert%281%29%22whatever\">http://www.opkode.com/\"onmouseover=\"alert(1)\"whatever</a>');\n\n                        message = \"https://en.wikipedia.org/wiki/Ender's_Game\";\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(50);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.text()).toEqual(message);\n                        expect(msg.html()).toEqual('<a target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Ender%27s_Game\">https://en.wikipedia.org/wiki/Ender\\'s_Game</a>');\n\n                        message = \"https://en.wikipedia.org/wiki/Ender%27s_Game\";\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(50);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.text()).toEqual(message);\n                        expect(msg.html()).toEqual('<a target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Ender%27s_Game\">https://en.wikipedia.org/wiki/Ender%27s_Game</a>');\n                    });\n                }));\n\n                it(\"will render images from their URLs\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    if (/PhantomJS/.test(window.navigator.userAgent)) {\n                        // Doesn't work when running tests in PhantomJS, since\n                        // the page is loaded via file:///\n                        return;\n                    }\n                    var message = document.URL.split(window.location.pathname)[0] + \"/logo/conversejs.svg\";\n                    var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    test_utils.openChatBoxFor(converse, contact_jid);\n                    var view = converse.chatboxviews.get(contact_jid);\n                    spyOn(view, 'sendMessage').andCallThrough();\n                    runs(function () {\n                        test_utils.sendMessage(view, message);\n                    });\n                    waits(500);\n                    runs(function () {\n                        expect(view.sendMessage).toHaveBeenCalled();\n                        var msg = view.$el.find('.chat-content').find('.chat-message').last().find('.chat-msg-content');\n                        expect(msg.html()).toEqual('<img src=\"'+message+'\" class=\"chat-image\">');\n                    });\n                }));\n\n            });\n\n            describe(\"A Chat Status Notification\", function () {\n                afterEach(function () {\n                    converse_api.user.logout();\n                    converse_api.listen.not();\n                    test_utils.clearBrowserStorage();\n                });\n\n                it(\"does not open automatically if a chat state notification is received\", mock.initConverse(function (converse) {\n                    test_utils.createContacts(converse, 'current');\n                    test_utils.openControlBox();\n                    test_utils.openContactsPanel(converse);\n\n                    spyOn(converse, 'emit');\n                    var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n                    // <composing> state\n                    var msg = $msg({\n                            from: sender_jid,\n                            to: converse.connection.jid,\n                            type: 'chat',\n                            id: (new Date()).getTime()\n                        }).c('composing', {'xmlns': Strophe.NS.CHATSTATES}).tree();\n                    converse.chatboxes.onMessage(msg);\n                    expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                }));\n\n                describe(\"An active notification\", function () {\n                    afterEach(function () {\n                        converse_api.user.logout();\n                        converse_api.listen.not();\n                        test_utils.clearBrowserStorage();\n                    });\n\n                    it(\"is sent when the user opens a chat box\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        waits(300); // ChatBox.show() is debounced for 250ms\n                        runs(function () {\n                            spyOn(converse.connection, 'send');\n                            var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            test_utils.openChatBoxFor(converse, contact_jid);\n                            var view = converse.chatboxviews.get(contact_jid);\n                            expect(view.model.get('chat_state')).toBe('active');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().length).toBe(3);\n                            expect($stanza.children().get(0).tagName).toBe('active');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n                        });\n                    }));\n\n                    it(\"is sent when the user maximizes a minimized a chat box\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n                        var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n\n                        runs(function () {\n                            test_utils.openChatBoxFor(converse, contact_jid);\n                        });\n                        waits(300); // ChatBox.show() is debounced for 250ms\n                        runs(function () {\n                            var view = converse.chatboxviews.get(contact_jid);\n                            view.model.minimize();\n                            expect(view.model.get('chat_state')).toBe('inactive');\n                            spyOn(converse.connection, 'send');\n                            view.model.maximize();\n                            expect(view.model.get('chat_state')).toBe('active');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().length).toBe(3);\n                            expect($stanza.children().get(0).tagName).toBe('active');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n                        });\n                    }));\n                });\n\n                describe(\"A composing notification\", function () {\n                    afterEach(function () {\n                        converse_api.user.logout();\n                        converse_api.listen.not();\n                        test_utils.clearBrowserStorage();\n                    });\n\n                    it(\"is sent as soon as the user starts typing a message which is not a command\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        waits(300); // ChatBox.show() is debounced for 250ms\n                        runs(function () {\n                            var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            test_utils.openChatBoxFor(converse, contact_jid);\n                            var view = converse.chatboxviews.get(contact_jid);\n                            expect(view.model.get('chat_state')).toBe('active');\n                            spyOn(converse.connection, 'send');\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.model.get('chat_state')).toBe('composing');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().get(0).tagName).toBe('composing');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n\n                            // The notification is not sent again\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.model.get('chat_state')).toBe('composing');\n                            expect(converse.emit.callCount, 1);\n                        });\n                    }));\n\n                    it(\"will be shown if received\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        // See XEP-0085 http://xmpp.org/extensions/xep-0085.html#definitions\n                        spyOn(converse, 'emit');\n                        var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n\n                        // <composing> state\n                        var msg = $msg({\n                                from: sender_jid,\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').c('composing', {'xmlns': Strophe.NS.CHATSTATES}).tree();\n                        converse.chatboxes.onMessage(msg);\n                        expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        var chatboxview = converse.chatboxviews.get(sender_jid);\n                        expect(chatboxview).toBeDefined();\n                        // Check that the notification appears inside the chatbox in the DOM\n                        var $events = chatboxview.$el.find('.chat-event');\n                        expect($events.text()).toEqual(mock.cur_names[1] + ' is typing');\n                    }));\n                });\n\n                describe(\"A paused notification\", function () {\n                    afterEach(function () {\n                        converse_api.user.logout();\n                        converse_api.listen.not();\n                        test_utils.clearBrowserStorage();\n                    });\n\n                    it(\"is sent if the user has stopped typing since 30 seconds\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        var view, contact_jid;\n                        converse.TIMEOUTS.PAUSED = 200; // Make the timeout shorter so that we can test\n                        waits(300); // ChatBox.show() is debounced for 250ms\n                        runs(function () {\n                            contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            test_utils.openChatBoxFor(converse, contact_jid);\n                            view = converse.chatboxviews.get(contact_jid);\n                            spyOn(converse.connection, 'send');\n                            spyOn(view, 'setChatState').andCallThrough();\n                            expect(view.model.get('chat_state')).toBe('active');\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.model.get('chat_state')).toBe('composing');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.children().get(0).tagName).toBe('composing');\n                        });\n                        waits(250);\n                        runs(function () {\n                            expect(view.model.get('chat_state')).toBe('paused');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[1][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().length).toBe(3);\n                            expect($stanza.children().get(0).tagName).toBe('paused');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n                            // Test #359. A paused notification should not be sent\n                            // out if the user simply types longer than the\n                            // timeout.\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.setChatState).toHaveBeenCalled();\n                            expect(view.model.get('chat_state')).toBe('composing');\n                        });\n                        waits(100);\n                        runs(function () {\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.model.get('chat_state')).toBe('composing');\n                        });\n                        waits(150);\n                        runs(function () {\n                            expect(view.model.get('chat_state')).toBe('composing');\n                        });\n                    }));\n\n                    it(\"will be shown if received\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        // TODO: only show paused state if the previous state was composing\n                        // See XEP-0085 http://xmpp.org/extensions/xep-0085.html#definitions\n                        spyOn(converse, 'emit');\n                        var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        // <paused> state\n                        var msg = $msg({\n                                from: sender_jid,\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').c('paused', {'xmlns': Strophe.NS.CHATSTATES}).tree();\n                        converse.chatboxes.onMessage(msg);\n                        expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        var chatboxview = converse.chatboxviews.get(sender_jid);\n                        var $events = chatboxview.$el.find('.chat-event');\n                        expect($events.text()).toEqual(mock.cur_names[1] + ' has stopped typing');\n                    }));\n                });\n\n                describe(\"An inactive notifciation\", function () {\n                    afterEach(function () {\n                        converse_api.user.logout();\n                        converse_api.listen.not();\n                        test_utils.clearBrowserStorage();\n                    });\n\n                    it(\"is sent if the user has stopped typing since 2 minutes\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        // Make the timeouts shorter so that we can test\n                        converse.TIMEOUTS.PAUSED = 200;\n                        converse.TIMEOUTS.INACTIVE = 200;\n                        var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        test_utils.openChatBoxFor(converse, contact_jid);\n                        var view = converse.chatboxviews.get(contact_jid);\n                        runs(function () {\n                            expect(view.model.get('chat_state')).toBe('active');\n                            view.keyPressed({\n                                target: view.$el.find('textarea.chat-textarea'),\n                                keyCode: 1\n                            });\n                            expect(view.model.get('chat_state')).toBe('composing');\n                        });\n                        waits(250);\n                        runs(function () {\n                            expect(view.model.get('chat_state')).toBe('paused');\n                            spyOn(converse.connection, 'send');\n                        });\n                        waits(250);\n                        runs(function () {\n                            expect(view.model.get('chat_state')).toBe('inactive');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().length).toBe(3);\n                            expect($stanza.children().get(0).tagName).toBe('inactive');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n\n                        });\n                    }));\n\n                    it(\"is sent when the user a minimizes a chat box\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        test_utils.openChatBoxFor(converse, contact_jid);\n                        var view = converse.chatboxviews.get(contact_jid);\n                        spyOn(converse.connection, 'send');\n                        view.minimize();\n                        expect(view.model.get('chat_state')).toBe('inactive');\n                        expect(converse.connection.send).toHaveBeenCalled();\n                        var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                        expect($stanza.attr('to')).toBe(contact_jid);\n                        expect($stanza.children().get(0).tagName).toBe('inactive');\n                    }));\n\n                    it(\"is sent if the user closes a chat box\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        waits(300); // ChatBox.show() is debounced for 250ms\n                        runs(function () {\n                            var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                            test_utils.openChatBoxFor(converse, contact_jid);\n                            var view = converse.chatboxviews.get(contact_jid);\n                            expect(view.model.get('chat_state')).toBe('active');\n                            spyOn(converse.connection, 'send');\n                            view.close();\n                            expect(view.model.get('chat_state')).toBe('inactive');\n                            expect(converse.connection.send).toHaveBeenCalled();\n                            var $stanza = $(converse.connection.send.argsForCall[0][0].tree());\n                            expect($stanza.attr('to')).toBe(contact_jid);\n                            expect($stanza.children().length).toBe(3);\n                            expect($stanza.children().get(0).tagName).toBe('inactive');\n                            expect($stanza.children().get(1).tagName).toBe('no-store');\n                            expect($stanza.children().get(2).tagName).toBe('no-permanent-store');\n                        });\n                    }));\n\n                    it(\"will clear any other chat status notifications if its received\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        // See XEP-0085 http://xmpp.org/extensions/xep-0085.html#definitions\n                        spyOn(converse, 'emit');\n                        var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        test_utils.openChatBoxFor(converse, sender_jid);\n                        var view = converse.chatboxviews.get(sender_jid);\n                        expect(view.$el.find('.chat-event').length).toBe(0);\n                        view.showStatusNotification(sender_jid+' '+'is typing');\n                        expect(view.$el.find('.chat-event').length).toBe(1);\n                        var msg = $msg({\n                                from: sender_jid,\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').c('inactive', {'xmlns': Strophe.NS.CHATSTATES}).tree();\n                        converse.chatboxes.onMessage(msg);\n                        expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        expect(view.$el.find('.chat-event').length).toBe(0);\n                    }));\n\n                });\n\n                describe(\"A gone notifciation\", function () {\n                    afterEach(function () {\n                        converse_api.user.logout();\n                        converse_api.listen.not();\n                        test_utils.clearBrowserStorage();\n                    });\n\n                    it(\"will be shown if received\", mock.initConverse(function (converse) {\n                        test_utils.createContacts(converse, 'current');\n                        test_utils.openControlBox();\n                        test_utils.openContactsPanel(converse);\n\n                        spyOn(converse, 'emit');\n                        var sender_jid = mock.cur_names[1].replace(/ /g,'.').toLowerCase() + '@localhost';\n                        // <paused> state\n                        var msg = $msg({\n                                from: sender_jid,\n                                to: converse.connection.jid,\n                                type: 'chat',\n                                id: (new Date()).getTime()\n                            }).c('body').c('gone', {'xmlns': Strophe.NS.CHATSTATES}).tree();\n                        converse.chatboxes.onMessage(msg);\n                        expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                        var chatboxview = converse.chatboxviews.get(sender_jid);\n                        var $events = chatboxview.$el.find('.chat-event');\n                        expect($events.text()).toEqual(mock.cur_names[1] + ' has gone away');\n                    }));\n                });\n            });\n        });\n\n        describe(\"Special Messages\", function () {\n            afterEach(function () {\n                converse_api.user.logout();\n                converse_api.listen.not();\n                test_utils.clearBrowserStorage();\n            });\n\n            it(\"'/clear' can be used to clear messages in a conversation\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                spyOn(converse, 'emit');\n                var contact_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost';\n                test_utils.openChatBoxFor(converse, contact_jid);\n                var view = converse.chatboxviews.get(contact_jid);\n                var message = 'This message is another sent from this chatbox';\n                // Lets make sure there is at least one message already\n                // (e.g for when this test is run on its own).\n                test_utils.sendMessage(view, message);\n                expect(view.model.messages.length > 0).toBeTruthy();\n                expect(view.model.messages.browserStorage.records.length > 0).toBeTruthy();\n                expect(converse.emit).toHaveBeenCalledWith('messageSend', message);\n\n                message = '/clear';\n                spyOn(view, 'onMessageSubmitted').andCallThrough();\n                spyOn(view, 'clearMessages').andCallThrough();\n                spyOn(window, 'confirm').andCallFake(function () {\n                    return true;\n                });\n                test_utils.sendMessage(view, message);\n                expect(view.onMessageSubmitted).toHaveBeenCalled();\n                expect(view.clearMessages).toHaveBeenCalled();\n                expect(window.confirm).toHaveBeenCalled();\n                expect(view.model.messages.length, 0); // The messages must be removed from the chatbox\n                expect(view.model.messages.browserStorage.records.length, 0); // And also from browserStorage\n                expect(converse.emit.callCount, 1);\n                expect(converse.emit.mostRecentCall.args, ['messageSend', message]);\n            }));\n        });\n\n        describe(\"A Message Counter\", function () {\n            afterEach(function () {\n                converse_api.user.logout();\n                converse_api.listen.not();\n                test_utils.clearBrowserStorage();\n            });\n\n            it(\"is incremented when the message is received and the window is not focused\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                spyOn(converse, 'emit');\n                expect(converse.msg_counter).toBe(0);\n                spyOn(converse, 'incrementMsgCounter').andCallThrough();\n                var previous_state = converse.windowState;\n                var message = 'This message will increment the message counter';\n                var sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost',\n                    msg = $msg({\n                        from: sender_jid,\n                        to: converse.connection.jid,\n                        type: 'chat',\n                        id: (new Date()).getTime()\n                    }).c('body').t(message).up()\n                      .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                converse.windowState = 'hidden';\n                converse.chatboxes.onMessage(msg);\n                expect(converse.incrementMsgCounter).toHaveBeenCalled();\n                expect(converse.msg_counter).toBe(1);\n                expect(converse.emit).toHaveBeenCalledWith('message', msg);\n                converse.windowSate = previous_state;\n            }));\n\n            it(\"is cleared when the window is focused\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                converse.windowState = 'hidden';\n                spyOn(converse, 'clearMsgCounter').andCallThrough();\n                runs(function () {\n                    converse.saveWindowState(null, 'focus');\n                    converse.saveWindowState(null, 'blur');\n                });\n                waits(50);\n                runs(function () {\n                    expect(converse.clearMsgCounter).toHaveBeenCalled();\n                });\n            }));\n\n            it(\"is not incremented when the message is received and the window is focused\", mock.initConverse(function (converse) {\n                test_utils.createContacts(converse, 'current');\n                test_utils.openControlBox();\n                test_utils.openContactsPanel(converse);\n\n                expect(converse.msg_counter).toBe(0);\n                spyOn(converse, 'incrementMsgCounter').andCallThrough();\n                converse.saveWindowState(null, 'focus');\n                var message = 'This message will not increment the message counter';\n                var sender_jid = mock.cur_names[0].replace(/ /g,'.').toLowerCase() + '@localhost',\n                    msg = $msg({\n                        from: sender_jid,\n                        to: converse.connection.jid,\n                        type: 'chat',\n                        id: (new Date()).getTime()\n                    }).c('body').t(message).up()\n                      .c('active', {'xmlns': 'http://jabber.org/protocol/chatstates'}).tree();\n                converse.chatboxes.onMessage(msg);\n                expect(converse.incrementMsgCounter).not.toHaveBeenCalled();\n                expect(converse.msg_counter).toBe(0);\n            }));\n        });\n    });\n}));\n", "// Converse.js (A browser based XMPP chat client)\n// http://conversejs.org\n//\n// Copyright (c) 2012-2016, Jan-Carel Brand <jc@opkode.com>\n// Licensed under the Mozilla Public License (MPLv2)\n//\n/*global Backbone, define, window, document */\n\n(function (root, factory) {\n    define(\"converse-core\", [\n        \"jquery\",\n        \"underscore\",\n        \"polyfill\",\n        \"utils\",\n        \"moment_with_locales\",\n        \"strophe\",\n        \"pluggable\",\n        \"strophe.disco\",\n        \"backbone.browserStorage\",\n        \"backbone.overview\",\n    ], factory);\n}(this, function ($, _, dummy, utils, moment, Strophe, pluggable) {\n    /*\n     * Cannot use this due to Safari bug.\n     * See https://github.com/jcbrand/converse.js/issues/196\n     */\n    // \"use strict\";\n\n    // Strophe globals\n    var $build = Strophe.$build;\n    var $iq = Strophe.$iq;\n    var $pres = Strophe.$pres;\n    var b64_sha1 = Strophe.SHA1.b64_sha1;\n    Strophe = Strophe.Strophe;\n\n    // Use Mustache style syntax for variable interpolation\n    /* Configuration of underscore templates (this config is distinct to the\n     * config of requirejs-tpl in main.js). This one is for normal inline templates.\n     */\n    _.templateSettings = {\n        evaluate : /\\{\\[([\\s\\S]+?)\\]\\}/g,\n        interpolate : /\\{\\{([\\s\\S]+?)\\}\\}/g\n    };\n\n    // We create an object to act as the \"this\" context for event handlers (as\n    // defined below and accessible via converse_api.listen).\n    // We don't want the inner converse object to be the context, since it\n    // contains sensitive information, and we don't want it to be something in\n    // the DOM or window, because then anyone can trigger converse events.\n    var event_context = {};\n\n    var converse = {\n        templates: {},\n\n        emit: function (evt, data) {\n            $(event_context).trigger(evt, data);\n        },\n\n        once: function (evt, handler, context) {\n            if (context) {\n                handler = handler.bind(context);\n            }\n            $(event_context).one(evt, handler);\n        },\n\n        on: function (evt, handler, context) {\n            if (_.contains(['ready', 'initialized'], evt)) {\n                converse.log('Warning: The \"'+evt+'\" event has been deprecated and will be removed, please use \"connected\".');\n            }\n            if (context) {\n                handler = handler.bind(context);\n            }\n            $(event_context).bind(evt, handler);\n        },\n\n        off: function (evt, handler) {\n            $(event_context).unbind(evt, handler);\n        }\n    };\n\n    // Make converse pluggable\n    pluggable.enable(converse, 'converse', 'pluggable');\n\n    // Module-level constants\n    converse.STATUS_WEIGHTS = {\n        'offline':      6,\n        'unavailable':  5,\n        'xa':           4,\n        'away':         3,\n        'dnd':          2,\n        'chat':         1, // We currently don't differentiate between \"chat\" and \"online\"\n        'online':       1\n    };\n    converse.ANONYMOUS  = \"anonymous\";\n    converse.CLOSED = 'closed';\n    converse.EXTERNAL = \"external\";\n    converse.LOGIN = \"login\";\n    converse.LOGOUT = \"logout\";\n    converse.OPENED = 'opened';\n    converse.PREBIND = \"prebind\";\n\n    var PRETTY_CONNECTION_STATUS = {\n        0: 'ERROR',\n        1: 'CONNECTING',\n        2: 'CONNFAIL',\n        3: 'AUTHENTICATING',\n        4: 'AUTHFAIL',\n        5: 'CONNECTED',\n        6: 'DISCONNECTED',\n        7: 'DISCONNECTING',\n        8: 'ATTACHED',\n        9: 'REDIRECT'\n    };\n\n    converse.log = function (txt, level) {\n        var logger;\n        if (typeof console === \"undefined\" || typeof console.log === \"undefined\") {\n            logger = { log: function () {}, error: function () {} };\n        } else {\n            logger = console;\n        }\n        if (converse.debug) {\n            if (level === 'error') {\n                logger.log('ERROR: '+txt);\n            } else {\n                logger.log(txt);\n            }\n        }\n    };\n\n\n    converse.initialize = function (settings, callback) {\n        \"use strict\";\n        settings = typeof settings !== \"undefined\" ? settings : {};\n        var init_deferred = new $.Deferred();\n        var converse = this;\n\n        if (typeof converse.chatboxes !== 'undefined') {\n            // Looks like converse.initialized was called again without logging\n            // out or disconnecting in the previous session.\n            // This happens in tests.\n            // We therefore first clean up.\n            converse.connection.reset();\n            converse._tearDown();\n        }\n\n        var unloadevent;\n        if ('onpagehide' in window) {\n            // Pagehide gets thrown in more cases than unload. Specifically it\n            // gets thrown when the page is cached and not just\n            // closed/destroyed. It's the only viable event on mobile Safari.\n            // https://www.webkit.org/blog/516/webkit-page-cache-ii-the-unload-event/\n            unloadevent = 'pagehide';\n        } else if ('onbeforeunload' in window) {\n            unloadevent = 'beforeunload';\n        } else if ('onunload' in window) {\n            unloadevent = 'unload';\n        }\n\n        // Logging\n        Strophe.log = function (level, msg) { converse.log(level+' '+msg, level); };\n        Strophe.error = function (msg) { converse.log(msg, 'error'); };\n\n        // Add Strophe Namespaces\n        Strophe.addNamespace('CARBONS', 'urn:xmpp:carbons:2');\n        Strophe.addNamespace('CHATSTATES', 'http://jabber.org/protocol/chatstates');\n        Strophe.addNamespace('CSI', 'urn:xmpp:csi:0');\n        Strophe.addNamespace('ROSTERX', 'http://jabber.org/protocol/rosterx');\n        Strophe.addNamespace('XFORM', 'jabber:x:data');\n        Strophe.addNamespace('NICK', 'http://jabber.org/protocol/nick');\n        Strophe.addNamespace('HINTS', 'urn:xmpp:hints');\n        Strophe.addNamespace('PUBSUB', 'http://jabber.org/protocol/pubsub');\n\n        // Instance level constants\n        this.TIMEOUTS = { // Set as module attr so that we can override in tests.\n            'PAUSED':     10000,\n            'INACTIVE':   90000\n        };\n\n        // XEP-0085 Chat states\n        // http://xmpp.org/extensions/xep-0085.html\n        this.INACTIVE = 'inactive';\n        this.ACTIVE = 'active';\n        this.COMPOSING = 'composing';\n        this.PAUSED = 'paused';\n        this.GONE = 'gone';\n\n        // Detect support for the user's locale\n        // ------------------------------------\n        var locales = typeof locales === \"undefined\" ? {} : locales;\n        this.isConverseLocale = function (locale) { return typeof locales[locale] !== \"undefined\"; };\n        this.isMomentLocale = function (locale) { return moment.locale() !== moment.locale(locale); };\n        if (!moment.locale) { //moment.lang is deprecated after 2.8.1, use moment.locale instead\n            moment.locale = moment.lang;\n        }\n        moment.locale(utils.detectLocale(this.isMomentLocale));\n        this.i18n = settings.i18n ? settings.i18n : locales[utils.detectLocale(this.isConverseLocale)] || {};\n\n        // Translation machinery\n        // ---------------------\n        var __ = utils.__.bind(this);\n        var DESC_GROUP_TOGGLE = __('Click to hide these contacts');\n\n        // Default configuration values\n        // ----------------------------\n        this.default_settings = {\n            allow_contact_requests: true,\n            animate: true,\n            authentication: 'login', // Available values are \"login\", \"prebind\", \"anonymous\" and \"external\".\n            auto_away: 0, // Seconds after which user status is set to 'away'\n            auto_login: false, // Currently only used in connection with anonymous login\n            auto_reconnect: false,\n            auto_subscribe: false,\n            auto_xa: 0, // Seconds after which user status is set to 'xa'\n            bosh_service_url: undefined, // The BOSH connection manager URL.\n            connection_options: {},\n            credentials_url: null, // URL from where login credentials can be fetched\n            csi_waiting_time: 0, // Support for XEP-0352. Seconds before client is considered idle and CSI is sent out.\n            debug: false,\n            default_state: 'online',\n            expose_rid_and_sid: false,\n            filter_by_resource: false,\n            forward_messages: false,\n            hide_offline_users: false,\n            include_offline_state: false,\n            jid: undefined,\n            keepalive: false,\n            locked_domain: undefined,\n            message_carbons: false, // Support for XEP-280\n            password: undefined,\n            prebind: false, // XXX: Deprecated, use \"authentication\" instead.\n            prebind_url: null,\n            rid: undefined,\n            roster_groups: false,\n            show_only_online_users: false,\n            sid: undefined,\n            storage: 'session',\n            message_storage: 'session',\n            strict_plugin_dependencies: false,\n            synchronize_availability: true, // Set to false to not sync with other clients or with resource name of the particular client that it should synchronize with\n            websocket_url: undefined,\n            xhr_custom_status: false,\n            xhr_custom_status_url: '',\n        };\n        _.extend(this, this.default_settings);\n        // Allow only whitelisted configuration attributes to be overwritten\n        _.extend(this, _.pick(settings, Object.keys(this.default_settings)));\n\n        // BBB\n        if (this.prebind === true) { this.authentication = converse.PREBIND; }\n\n        if (this.authentication === converse.ANONYMOUS) {\n            if (this.auto_login && !this.jid) {\n                throw new Error(\"Config Error: you need to provide the server's \" +\n                      \"domain via the 'jid' option when using anonymous \" +\n                      \"authentication with auto_login.\");\n            }\n        }\n\n        $.fx.off = !this.animate;\n\n        // Module-level variables\n        // ----------------------\n        this.callback = callback || function () {};\n        /* When reloading the page:\n         * For new sessions, we need to send out a presence stanza to notify\n         * the server/network that we're online.\n         * When re-attaching to an existing session (e.g. via the keepalive\n         * option), we don't need to again send out a presence stanza, because\n         * it's as if \"we never left\" (see onConnectStatusChanged).\n         * https://github.com/jcbrand/converse.js/issues/521\n         */\n        this.send_initial_presence = true;\n        this.msg_counter = 0;\n        this.user_settings = settings; // Save the user settings so that they can be used by plugins\n\n        // Module-level functions\n        // ----------------------\n        this.wrappedChatBox = function (chatbox) {\n            /* Wrap a chatbox for outside consumption (i.e. so that it can be\n             * returned via the API.\n             */\n            if (!chatbox) { return; }\n            var view = converse.chatboxviews.get(chatbox.get('id'));\n            return {\n                'close': view.close.bind(view),\n                'focus': view.focus.bind(view),\n                'get': chatbox.get.bind(chatbox),\n                'open': view.show.bind(view),\n                'set': chatbox.set.bind(chatbox)\n            };\n        };\n\n        this.generateResource = function () {\n            return '/converse.js-' + Math.floor(Math.random()*139749825).toString();\n        };\n\n        this.sendCSI = function (stat) {\n            /* Send out a Chat Status Notification (XEP-0352) */\n            if (converse.features[Strophe.NS.CSI] || true) {\n                converse.connection.send($build(stat, {xmlns: Strophe.NS.CSI}));\n                converse.inactive = (stat === converse.INACTIVE) ? true : false;\n            }\n        };\n\n        this.onUserActivity = function () {\n            /* Resets counters and flags relating to CSI and auto_away/auto_xa */\n            if (converse.idle_seconds > 0) {\n                converse.idle_seconds = 0;\n            }\n            if (!converse.connection.authenticated) {\n                // We can't send out any stanzas when there's no authenticated connection.\n                // converse can happen when the connection reconnects.\n                return;\n            }\n            if (converse.inactive) {\n                converse.sendCSI(converse.ACTIVE);\n            }\n            if (converse.auto_changed_status === true) {\n                converse.auto_changed_status = false;\n                // XXX: we should really remember the original state here, and\n                // then set it back to that...\n                converse.xmppstatus.setStatus(converse.default_state);\n            }\n        };\n\n        this.onEverySecond = function () {\n            /* An interval handler running every second.\n             * Used for CSI and the auto_away and auto_xa features.\n             */\n            if (!converse.connection.authenticated) {\n                // We can't send out any stanzas when there's no authenticated connection.\n                // This can happen when the connection reconnects.\n                return;\n            }\n            var stat = converse.xmppstatus.getStatus();\n            converse.idle_seconds++;\n            if (converse.csi_waiting_time > 0 &&\n                    converse.idle_seconds > converse.csi_waiting_time &&\n                    !converse.inactive) {\n                converse.sendCSI(converse.INACTIVE);\n            }\n            if (converse.auto_away > 0 &&\n                    converse.idle_seconds > converse.auto_away &&\n                    stat !== 'away' && stat !== 'xa') {\n                converse.auto_changed_status = true;\n                converse.xmppstatus.setStatus('away');\n            } else if (converse.auto_xa > 0 &&\n                    converse.idle_seconds > converse.auto_xa && stat !== 'xa') {\n                converse.auto_changed_status = true;\n                converse.xmppstatus.setStatus('xa');\n            }\n        };\n\n        this.registerIntervalHandler = function () {\n            /* Set an interval of one second and register a handler for it.\n             * Required for the auto_away, auto_xa and csi_waiting_time features.\n             */\n            if (converse.auto_away < 1 && converse.auto_xa < 1 && converse.csi_waiting_time < 1) {\n                // Waiting time of less then one second means features aren't used.\n                return;\n            }\n            converse.idle_seconds = 0;\n            converse.auto_changed_status = false; // Was the user's status changed by converse.js?\n            $(window).on('click mousemove keypress focus'+unloadevent, converse.onUserActivity);\n            converse.everySecondTrigger = window.setInterval(converse.onEverySecond, 1000);\n        };\n\n        this.giveFeedback = function (subject, klass, message) {\n            $('.conn-feedback').each(function (idx, el) {\n                var $el = $(el);\n                $el.addClass('conn-feedback').text(subject);\n                if (klass) {\n                    $el.addClass(klass);\n                } else {\n                    $el.removeClass('error');\n                }\n            });\n            converse.emit('feedback', {\n                'klass': klass,\n                'message': message,\n                'subject': subject\n            });\n        };\n\n        this.rejectPresenceSubscription = function (jid, message) {\n            /* Reject or cancel another user's subscription to our presence updates.\n             *  Parameters:\n             *    (String) jid - The Jabber ID of the user whose subscription\n             *      is being canceled.\n             *    (String) message - An optional message to the user\n             */\n            var pres = $pres({to: jid, type: \"unsubscribed\"});\n            if (message && message !== \"\") { pres.c(\"status\").t(message); }\n            converse.connection.send(pres);\n        };\n\n\n        this.reconnect = _.debounce(function (condition) {\n            converse.log('The connection has dropped, attempting to reconnect.');\n            converse.giveFeedback(\n                __(\"Reconnecting\"),\n                'warn',\n                __('The connection has dropped, attempting to reconnect.')\n            );\n            converse.connection.reconnecting = true;\n            converse.connection.disconnect('re-connecting');\n            converse._tearDown();\n            converse.logIn(null, true);\n        }, 1000, {'leading': true});\n\n        this.disconnect = function () {\n            delete converse.connection.reconnecting;\n            converse.connection.reset();\n            converse._tearDown();\n            converse.chatboxviews.closeAllChatBoxes();\n            converse.emit('disconnected');\n            converse.log('DISCONNECTED');\n            return 'disconnected';\n        };\n\n        this.onDisconnected = function (condition) {\n            if (_.includes([converse.LOGOUT, Strophe.Status.AUTHFAIL], converse.disconnection_cause) ||\n                    converse.disconnection_reason === \"host-unknown\" ||\n                    !converse.auto_reconnect) {\n                return this.disconnect();\n            }\n            if (converse.disconnection_cause === Strophe.Status.CONNFAIL) {\n                converse.reconnect(condition);\n                converse.log('RECONNECTING');\n            } else if (converse.disconnection_cause === Strophe.Status.DISCONNECTING ||\n                        converse.disconnection_cause === Strophe.Status.DISCONNECTED) {\n                window.setTimeout(_.partial(converse.reconnect, condition), 3000);\n                converse.log('RECONNECTING IN 3 SECONDS');\n            }\n            converse.emit('reconnecting');\n            return 'reconnecting';\n        };\n\n        this.setDisconnectionCause = function (cause, reason, override) {\n            if (_.isUndefined(converse.disconnection_cause) || override) {\n                converse.disconnection_cause = cause;\n                converse.disconnection_reason = reason;\n            }\n        };\n\n        this.onConnectStatusChanged = function (status, condition) {\n            converse.log(\"Status changed to: \"+PRETTY_CONNECTION_STATUS[status]);\n            if (status === Strophe.Status.CONNECTED || status === Strophe.Status.ATTACHED) {\n                // By default we always want to send out an initial presence stanza.\n                converse.send_initial_presence = true;\n                delete converse.disconnection_cause;\n                delete converse.disconnection_reason;\n                if (converse.connection.reconnecting) {\n                    converse.log(status === Strophe.Status.CONNECTED ? 'Reconnected' : 'Reattached');\n                    converse.onConnected(true);\n                } else {\n                    converse.log(status === Strophe.Status.CONNECTED ? 'Connected' : 'Attached');\n                    if (converse.connection.restored) {\n                        // No need to send an initial presence stanza when\n                        // we're restoring an existing session.\n                        converse.send_initial_presence = false;\n                    }\n                    converse.onConnected();\n                }\n            } else if (status === Strophe.Status.DISCONNECTED) {\n                converse.setDisconnectionCause(status, condition);\n                converse.onDisconnected(condition);\n            } else if (status === Strophe.Status.ERROR) {\n                converse.giveFeedback(\n                    __('Connection error'), 'error',\n                    __('An error occurred while connecting to the chat server.')\n                );\n            } else if (status === Strophe.Status.CONNECTING) {\n                converse.giveFeedback(__('Connecting'));\n            } else if (status === Strophe.Status.AUTHENTICATING) {\n                converse.giveFeedback(__('Authenticating'));\n            } else if (status === Strophe.Status.AUTHFAIL) {\n                converse.giveFeedback(__('Authentication Failed'), 'error');\n                converse.connection.disconnect();\n                converse.setDisconnectionCause(status, condition, true);\n            } else if (status === Strophe.Status.CONNFAIL) {\n                converse.giveFeedback(\n                    __('Connection failed'), 'error',\n                    __('An error occurred while connecting to the chat server: '+condition)\n                );\n                converse.setDisconnectionCause(status, condition);\n            } else if (status === Strophe.Status.DISCONNECTING) {\n                converse.setDisconnectionCause(status, condition);\n            }\n        };\n\n        this.updateMsgCounter = function () {\n            if (this.msg_counter > 0) {\n                if (document.title.search(/^Messages \\(\\d+\\) /) === -1) {\n                    document.title = \"Messages (\" + this.msg_counter + \") \" + document.title;\n                } else {\n                    document.title = document.title.replace(/^Messages \\(\\d+\\) /, \"Messages (\" + this.msg_counter + \") \");\n                }\n            } else if (document.title.search(/^Messages \\(\\d+\\) /) !== -1) {\n                document.title = document.title.replace(/^Messages \\(\\d+\\) /, \"\");\n            }\n        };\n\n        this.incrementMsgCounter = function () {\n            this.msg_counter += 1;\n            this.updateMsgCounter();\n        };\n\n        this.clearMsgCounter = function () {\n            this.msg_counter = 0;\n            this.updateMsgCounter();\n        };\n\n        this.initStatus = function () {\n            var deferred = new $.Deferred();\n            this.xmppstatus = new this.XMPPStatus();\n            var id = b64_sha1('converse.xmppstatus-'+converse.bare_jid);\n            this.xmppstatus.id = id; // Appears to be necessary for backbone.browserStorage\n            this.xmppstatus.browserStorage = new Backbone.BrowserStorage[converse.storage](id);\n            this.xmppstatus.fetch({\n                success: deferred.resolve,\n                error: deferred.resolve\n            });\n            converse.emit('statusInitialized');\n            return deferred.promise();\n        };\n\n        this.initSession = function () {\n            this.session = new this.Session();\n            var id = b64_sha1('converse.bosh-session');\n            this.session.id = id; // Appears to be necessary for backbone.browserStorage\n            this.session.browserStorage = new Backbone.BrowserStorage[converse.storage](id);\n            this.session.fetch();\n        };\n\n        this.clearSession = function () {\n            if (!_.isUndefined(this.roster)) {\n                this.roster.browserStorage._clear();\n            }\n            this.session.browserStorage._clear();\n        };\n\n        this.logOut = function () {\n            converse.setDisconnectionCause(converse.LOGOUT, undefined, true);\n            if (typeof converse.connection !== 'undefined') {\n                converse.connection.disconnect();\n            }\n            converse.chatboxviews.closeAllChatBoxes();\n            converse.clearSession();\n            converse._tearDown();\n            converse.emit('logout');\n        };\n\n        this.saveWindowState = function (ev, hidden) {\n            // XXX: eventually we should be able to just use\n            // document.visibilityState (when we drop support for older\n            // browsers).\n            var state;\n            var v = \"visible\", h = \"hidden\",\n                event_map = {\n                    'focus': v,\n                    'focusin': v,\n                    'pageshow': v,\n                    'blur': h,\n                    'focusout': h,\n                    'pagehide': h\n                };\n            ev = ev || document.createEvent('Events');\n            if (ev.type in event_map) {\n                state = event_map[ev.type];\n            } else {\n                state = document[hidden] ? \"hidden\" : \"visible\";\n            }\n            if (state  === 'visible') {\n                converse.clearMsgCounter();\n            }\n            converse.windowState = state;\n        };\n\n        this.registerGlobalEventHandlers = function () {\n            // Taken from:\n            // http://stackoverflow.com/questions/1060008/is-there-a-way-to-detect-if-a-browser-window-is-not-currently-active\n            var hidden = \"hidden\";\n            // Standards:\n            if (hidden in document) {\n                document.addEventListener(\"visibilitychange\", _.partial(converse.saveWindowState, _, hidden));\n            } else if ((hidden = \"mozHidden\") in document) {\n                document.addEventListener(\"mozvisibilitychange\", _.partial(converse.saveWindowState, _, hidden));\n            } else if ((hidden = \"webkitHidden\") in document) {\n                document.addEventListener(\"webkitvisibilitychange\", _.partial(converse.saveWindowState, _, hidden));\n            } else if ((hidden = \"msHidden\") in document) {\n                document.addEventListener(\"msvisibilitychange\", _.partial(converse.saveWindowState, _, hidden));\n            } else if (\"onfocusin\" in document) {\n                // IE 9 and lower:\n                document.onfocusin = document.onfocusout = _.partial(converse.saveWindowState, _, hidden);\n            } else {\n                // All others:\n                window.onpageshow = window.onpagehide = window.onfocus = window.onblur = _.partial(converse.saveWindowState, _, hidden);\n            }\n            // set the initial state (but only if browser supports the Page Visibility API)\n            if( document[hidden] !== undefined ) {\n                _.partial(converse.saveWindowState, _, hidden)({type: document[hidden] ? \"blur\" : \"focus\"});\n            }\n        };\n\n        this.enableCarbons = function () {\n            /* Ask the XMPP server to enable Message Carbons\n             * See XEP-0280 https://xmpp.org/extensions/xep-0280.html#enabling\n             */\n            if (!this.message_carbons || this.session.get('carbons_enabled')) {\n                return;\n            }\n            var carbons_iq = new Strophe.Builder('iq', {\n                from: this.connection.jid,\n                id: 'enablecarbons',\n                type: 'set'\n              })\n              .c('enable', {xmlns: Strophe.NS.CARBONS});\n            this.connection.addHandler(function (iq) {\n                if ($(iq).find('error').length > 0) {\n                    converse.log('ERROR: An error occured while trying to enable message carbons.');\n                } else {\n                    this.session.save({carbons_enabled: true});\n                    converse.log('Message carbons have been enabled.');\n                }\n            }.bind(this), null, \"iq\", null, \"enablecarbons\");\n            this.connection.send(carbons_iq);\n        };\n\n        this.initRoster = function () {\n            /* Initialize the Bakcbone collections that represent the contats\n             * roster and the roster groups.\n             */\n            converse.roster = new converse.RosterContacts();\n            converse.roster.browserStorage = new Backbone.BrowserStorage.session(\n                b64_sha1('converse.contacts-'+converse.bare_jid));\n            converse.rostergroups = new converse.RosterGroups();\n            converse.rostergroups.browserStorage = new Backbone.BrowserStorage.session(\n                b64_sha1('converse.roster.groups'+converse.bare_jid));\n            converse.emit('rosterInitialized');\n        };\n\n        this.populateRoster = function () {\n            /* Fetch all the roster groups, and then the roster contacts.\n             * Emit an event after fetching is done in each case.\n             */\n            converse.rostergroups.fetchRosterGroups().then(function () {\n                converse.emit('rosterGroupsFetched');\n                converse.roster.fetchRosterContacts().then(function () {\n                    converse.emit('rosterContactsFetched');\n                    converse.sendInitialPresence();\n                });\n            });\n        };\n\n        this.unregisterPresenceHandler = function () {\n            if (typeof converse.presence_ref !== 'undefined') {\n                converse.connection.deleteHandler(converse.presence_ref);\n                delete converse.presence_ref;\n            }\n        };\n\n        this.registerPresenceHandler = function () {\n            converse.unregisterPresenceHandler();\n            converse.presence_ref = converse.connection.addHandler(\n                function (presence) {\n                    converse.roster.presenceHandler(presence);\n                    return true;\n                }, null, 'presence', null);\n        };\n\n\n        this.sendInitialPresence = function () {\n            if (converse.send_initial_presence) {\n                converse.xmppstatus.sendPresence();\n            }\n        };\n\n        this.onStatusInitialized = function (reconnecting) {\n            /* Continue with session establishment (e.g. fetching chat boxes,\n             * populating the roster etc.) necessary once the connection has\n             * been established.\n             */\n            if (reconnecting) {\n                // No need to recreate the roster, otherwise we lose our\n                // cached data. However we still emit an event, to give\n                // event handlers a chance to register views for the\n                // roster and its groups, before we start populating.\n                converse.emit('rosterReadyAfterReconnection');\n            } else {\n                converse.registerIntervalHandler();\n                converse.initRoster();\n            }\n            // First set up chat boxes, before populating the roster, so that\n            // the controlbox is properly set up and ready for the rosterview.\n            converse.chatboxes.onConnected();\n            converse.populateRoster();\n            converse.registerPresenceHandler();\n            converse.giveFeedback(__('Contacts'));\n            if (reconnecting) {\n                converse.xmppstatus.sendPresence();\n            } else {\n                init_deferred.resolve();\n                converse.emit('initialized');\n            }\n        };\n\n        this.setUserJid = function () {\n            converse.jid = converse.connection.jid;\n            converse.bare_jid = Strophe.getBareJidFromJid(converse.connection.jid);\n            converse.resource = Strophe.getResourceFromJid(converse.connection.jid);\n            converse.domain = Strophe.getDomainFromJid(converse.connection.jid);\n        };\n\n        this.onConnected = function (reconnecting) {\n            /* Called as soon as a new connection has been established, either\n             * by logging in or by attaching to an existing BOSH session.\n             */\n            // Solves problem of returned PubSub BOSH response not received\n            // by browser.\n            converse.connection.flush();\n\n            converse.setUserJid();\n            converse.enableCarbons();\n\n            // If there's no xmppstatus obj, then we were never connected to\n            // begin with, so we set reconnecting to false.\n            reconnecting = _.isUndefined(converse.xmppstatus) ? false : reconnecting;\n\n            if (reconnecting) {\n                converse.onStatusInitialized(true);\n                converse.emit('reconnected');\n            } else {\n                // There might be some open chat boxes. We don't\n                // know whether these boxes are of the same account or not, so we\n                // close them now.\n                converse.chatboxviews.closeAllChatBoxes();\n                converse.features = new converse.Features();\n                converse.initStatus().done(_.partial(converse.onStatusInitialized, false));\n                converse.emit('connected');\n            }\n        };\n\n        this.RosterContact = Backbone.Model.extend({\n\n            initialize: function (attributes, options) {\n                var jid = attributes.jid;\n                var bare_jid = Strophe.getBareJidFromJid(jid);\n                var resource = Strophe.getResourceFromJid(jid);\n                attributes.jid = bare_jid;\n                this.set(_.extend({\n                    'id': bare_jid,\n                    'jid': bare_jid,\n                    'fullname': bare_jid,\n                    'chat_status': 'offline',\n                    'user_id': Strophe.getNodeFromJid(jid),\n                    'resources': resource ? [resource] : [],\n                    'groups': [],\n                    'image_type': 'image/png',\n                    'image': \"iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gwHCy455JBsggAABkJJREFUeNrtnM1PE1sUwHvvTD8otWLHST/Gimi1CEgr6M6FEWuIBo2pujDVsNDEP8GN/4MbN7oxrlipG2OCgZgYlxAbkRYw1KqkIDRCSkM7nXvvW8x7vjyNeQ9m7p1p3z1LQk/v/Dhz7vkEXL161cHl9wI5Ag6IA+KAOCAOiAPigDggLhwQB2S+iNZ+PcYY/SWEEP2HAAAIoSAIoihCCP+ngDDGtVotGAz29/cfOXJEUZSOjg6n06lp2sbGRqlUWlhYyGazS0tLbrdbEASrzgksyeYJId3d3el0uqenRxRFAAAA4KdfIIRgjD9+/Pj8+fOpqSndslofEIQwHA6Pjo4mEon//qmFhYXHjx8vLi4ihBgDEnp7e9l8E0Jo165dQ0NDd+/eDYVC2/qsJElDQ0OEkKWlpa2tLZamxAhQo9EIBoOjo6MXL17csZLe3l5FUT59+lQul5l5JRaAVFWNRqN37tw5ceKEQVWRSOTw4cOFQuHbt2+iKLYCIISQLMu3b99OJpOmKAwEAgcPHszn8+vr6wzsiG6UQQhxuVyXLl0aGBgwUW0sFstkMl6v90fo1KyAMMYDAwPnzp0zXfPg4GAqlWo0Gk0MiBAiy/L58+edTqf5Aa4onj59OhaLYYybFRCEMBaL0fNxBw4cSCQStN0QRUBut3t4eJjq6U+dOiVJElVPRBFQIBDo6+ujCqirqyscDlONGykC2lYyYSR6pBoQQapHZwAoHo/TuARYAOrs7GQASFEUqn6aIiBJkhgA6ujooFpUo6iaTa7koFwnaoWadLNe81tbWwzoaJrWrICWl5cZAFpbW6OabVAEtLi4yABQsVjUNK0pAWWzWQaAcrlcswKanZ1VVZUqHYRQEwOq1Wpv3ryhCmh6erpcLjdrNl+v1ycnJ+l5UELI27dvv3//3qxxEADgy5cvExMT9Mznw4cPtFtAdAPFarU6Pj5eKpVM17yxsfHy5cvV1VXazXu62gVBKBQKT58+rdVqJqrFGL948eLdu3dU8/g/H4FBUaJYLAqC0NPTY9brMD4+PjY25mDSracOCABACJmZmXE6nUePHjWu8NWrV48ePSKEsGlAs7Agfd5nenq6Wq0mk0kjDzY2NvbkyRMIIbP2PLvhBUEQ8vl8NpuNx+M+n29bzhVjvLKycv/+/YmJCcazQuwA6YzW1tYmJyf1SY+2trZ/rRk1Go1SqfT69esHDx4UCgVmNaa/zZ/9ABUhRFXVYDB48uTJeDweiUQkSfL7/T9MA2NcqVTK5fLy8vL8/PzU1FSxWHS5XJaM4wGr9sUwxqqqer3eUCgkSZJuUBBCfTRvc3OzXC6vrKxUKhWn02nhCJ5lM4oQQo/HgxD6+vXr58+fHf8sDOp+HQDg8XgclorFU676dKLlo6yWRdItIBwQB8QBcUCtfosRQjRNQwhhjPUC4w46WXryBSHU1zgEQWBz99EFhDGu1+t+v//48ePxeFxRlD179ng8nh0Efgiher2+vr6ur3HMzMysrq7uTJVdACGEurq6Ll++nEgkPB7Pj9jPoDHqOxyqqubz+WfPnuVyuV9XPeyeagAAAoHArVu3BgcHab8CuVzu4cOHpVKJUnfA5GweY+xyuc6cOXPv3r1IJMLAR8iyPDw8XK/Xi8Wiqqqmm5KZgBBC7e3tN27cuHbtGuPVpf7+/lAoNDs7W61WzfVKpgHSSzw3b95MpVKW3MfRaDQSiczNzVUqFRMZmQOIEOL1eq9fv3727FlL1t50URRFluX5+flqtWpWEGAOIFEUU6nUlStXLKSjy759+xwOx9zcnKZpphzGHMzhcDiTydgk9r1w4YIp7RPTAAmCkMlk2FeLf/tIEKbTab/fbwtAhJBoNGrutpNx6e7uPnTokC1eMU3T0um0DZPMkZER6wERQnw+n/FFSxpy7Nix3bt3WwwIIcRgIWnHkkwmjecfRgGx7DtuV/r6+iwGhDHev3+/bQF1dnYaH6E2CkiWZdsC2rt3r8WAHA5HW1ubbQGZcjajgOwTH/4qNko1Wlg4IA6IA+KAOKBWBUQIsfNojyliKIoRRfH9+/dut9umf3wzpoUNNQ4BAJubmwz+ic+OxefzWWlBhJD29nbug7iT5sIBcUAcEAfEAXFAHBAHxOVn+QMrmWpuPZx12gAAAABJRU5ErkJggg==\",\n                    'status': ''\n                }, attributes));\n\n                this.on('destroy', function () { this.removeFromRoster(); }.bind(this));\n                this.on('change:chat_status', function (item) {\n                    converse.emit('contactStatusChanged', item.attributes);\n                });\n            },\n\n            subscribe: function (message) {\n                /* Send a presence subscription request to this roster contact\n                 *\n                 * Parameters:\n                 *    (String) message - An optional message to explain the\n                 *      reason for the subscription request.\n                 */\n                this.save('ask', \"subscribe\"); // ask === 'subscribe' Means we have ask to subscribe to them.\n                var pres = $pres({to: this.get('jid'), type: \"subscribe\"});\n                if (message && message !== \"\") {\n                    pres.c(\"status\").t(message).up();\n                }\n                var nick = converse.xmppstatus.get('fullname');\n                if (nick && nick !== \"\") {\n                    pres.c('nick', {'xmlns': Strophe.NS.NICK}).t(nick).up();\n                }\n                converse.connection.send(pres);\n                return this;\n            },\n\n            ackSubscribe: function () {\n                /* Upon receiving the presence stanza of type \"subscribed\",\n                 * the user SHOULD acknowledge receipt of that subscription\n                 * state notification by sending a presence stanza of type\n                 * \"subscribe\" to the contact\n                 */\n                converse.connection.send($pres({\n                    'type': 'subscribe',\n                    'to': this.get('jid')\n                }));\n            },\n\n            ackUnsubscribe: function (jid) {\n                /* Upon receiving the presence stanza of type \"unsubscribed\",\n                 * the user SHOULD acknowledge receipt of that subscription state\n                 * notification by sending a presence stanza of type \"unsubscribe\"\n                 * this step lets the user's server know that it MUST no longer\n                 * send notification of the subscription state change to the user.\n                 *  Parameters:\n                 *    (String) jid - The Jabber ID of the user who is unsubscribing\n                 */\n                converse.connection.send($pres({'type': 'unsubscribe', 'to': this.get('jid')}));\n                this.destroy(); // Will cause removeFromRoster to be called.\n            },\n\n            unauthorize: function (message) {\n                /* Unauthorize this contact's presence subscription\n                 * Parameters:\n                 *   (String) message - Optional message to send to the person being unauthorized\n                 */\n                converse.rejectPresenceSubscription(this.get('jid'), message);\n                return this;\n            },\n\n            authorize: function (message) {\n                /* Authorize presence subscription\n                 * Parameters:\n                 *   (String) message - Optional message to send to the person being authorized\n                 */\n                var pres = $pres({to: this.get('jid'), type: \"subscribed\"});\n                if (message && message !== \"\") {\n                    pres.c(\"status\").t(message);\n                }\n                converse.connection.send(pres);\n                return this;\n            },\n\n            removeResource: function (resource) {\n                var resources = this.get('resources'), idx;\n                if (resource) {\n                    idx = _.indexOf(resources, resource);\n                    if (idx !== -1) {\n                        resources.splice(idx, 1);\n                        this.save({'resources': resources});\n                    }\n                }\n                else {\n                    // if there is no resource (resource is null), it probably\n                    // means that the user is now completely offline. To make sure\n                    // that there isn't any \"ghost\" resources left, we empty the array\n                    this.save({'resources': []});\n                    return 0;\n                }\n                return resources.length;\n            },\n\n            removeFromRoster: function (callback) {\n                /* Instruct the XMPP server to remove this contact from our roster\n                 * Parameters:\n                 *   (Function) callback\n                 */\n                var iq = $iq({type: 'set'})\n                    .c('query', {xmlns: Strophe.NS.ROSTER})\n                    .c('item', {jid: this.get('jid'), subscription: \"remove\"});\n                converse.connection.sendIQ(iq, callback, callback);\n                return this;\n            }\n        });\n\n\n        this.RosterContacts = Backbone.Collection.extend({\n            model: converse.RosterContact,\n\n            comparator: function (contact1, contact2) {\n                var name1, name2;\n                var status1 = contact1.get('chat_status') || 'offline';\n                var status2 = contact2.get('chat_status') || 'offline';\n                if (converse.STATUS_WEIGHTS[status1] === converse.STATUS_WEIGHTS[status2]) {\n                    name1 = contact1.get('fullname').toLowerCase();\n                    name2 = contact2.get('fullname').toLowerCase();\n                    return name1 < name2 ? -1 : (name1 > name2? 1 : 0);\n                } else  {\n                    return converse.STATUS_WEIGHTS[status1] < converse.STATUS_WEIGHTS[status2] ? -1 : 1;\n                }\n            },\n\n            fetchRosterContacts: function () {\n                /* Fetches the roster contacts, first by trying the\n                 * sessionStorage cache, and if that's empty, then by querying\n                 * the XMPP server.\n                 *\n                 * Returns a promise which resolves once the contacts have been\n                 * fetched.\n                 */\n                var deferred = new $.Deferred();\n                this.fetch({\n                    add: true,\n                    success: function (collection) {\n                        if (collection.length === 0) {\n                            /* We don't have any roster contacts stored in sessionStorage,\n                             * so lets fetch the roster from the XMPP server. We pass in\n                             * 'sendPresence' as callback method, because after initially\n                             * fetching the roster we are ready to receive presence\n                             * updates from our contacts.\n                             */\n                            converse.send_initial_presence = true;\n                            converse.roster.fetchFromServer(deferred.resolve);\n                        } else {\n                            converse.emit('cachedRoster', collection);\n                            deferred.resolve();\n                        }\n                    }\n                });\n                return deferred.promise();\n            },\n\n            subscribeToSuggestedItems: function (msg) {\n                $(msg).find('item').each(function (i, items) {\n                    if (this.getAttribute('action') === 'add') {\n                        converse.roster.addAndSubscribe(\n                                this.getAttribute('jid'), null, converse.xmppstatus.get('fullname'));\n                    }\n                });\n                return true;\n            },\n\n            isSelf: function (jid) {\n                return (Strophe.getBareJidFromJid(jid) === Strophe.getBareJidFromJid(converse.connection.jid));\n            },\n\n            addAndSubscribe: function (jid, name, groups, message, attributes) {\n                /* Add a roster contact and then once we have confirmation from\n                 * the XMPP server we subscribe to that contact's presence updates.\n                 *  Parameters:\n                 *    (String) jid - The Jabber ID of the user being added and subscribed to.\n                 *    (String) name - The name of that user\n                 *    (Array of Strings) groups - Any roster groups the user might belong to\n                 *    (String) message - An optional message to explain the\n                 *      reason for the subscription request.\n                 *    (Object) attributes - Any additional attributes to be stored on the user's model.\n                 */\n                this.addContact(jid, name, groups, attributes).done(function (contact) {\n                    if (contact instanceof converse.RosterContact) {\n                        contact.subscribe(message);\n                    }\n                });\n            },\n\n            sendContactAddIQ: function (jid, name, groups, callback, errback) {\n                /*  Send an IQ stanza to the XMPP server to add a new roster contact.\n                 *\n                 *  Parameters:\n                 *    (String) jid - The Jabber ID of the user being added\n                 *    (String) name - The name of that user\n                 *    (Array of Strings) groups - Any roster groups the user might belong to\n                 *    (Function) callback - A function to call once the IQ is returned\n                 *    (Function) errback - A function to call if an error occured\n                 */\n                name = _.isEmpty(name)? jid: name;\n                var iq = $iq({type: 'set'})\n                    .c('query', {xmlns: Strophe.NS.ROSTER})\n                    .c('item', { jid: jid, name: name });\n                _.map(groups, function (group) { iq.c('group').t(group).up(); });\n                converse.connection.sendIQ(iq, callback, errback);\n            },\n\n            addContact: function (jid, name, groups, attributes) {\n                /* Adds a RosterContact instance to converse.roster and\n                 * registers the contact on the XMPP server.\n                 * Returns a promise which is resolved once the XMPP server has\n                 * responded.\n                 *\n                 *  Parameters:\n                 *    (String) jid - The Jabber ID of the user being added and subscribed to.\n                 *    (String) name - The name of that user\n                 *    (Array of Strings) groups - Any roster groups the user might belong to\n                 *    (Object) attributes - Any additional attributes to be stored on the user's model.\n                 */\n                var deferred = new $.Deferred();\n                groups = groups || [];\n                name = _.isEmpty(name)? jid: name;\n                this.sendContactAddIQ(jid, name, groups,\n                    function (iq) {\n                        var contact = this.create(_.extend({\n                            ask: undefined,\n                            fullname: name,\n                            groups: groups,\n                            jid: jid,\n                            requesting: false,\n                            subscription: 'none'\n                        }, attributes), {sort: false});\n                        deferred.resolve(contact);\n                    }.bind(this),\n                    function (err) {\n                        alert(__(\"Sorry, there was an error while trying to add \"+name+\" as a contact.\"));\n                        converse.log(err);\n                        deferred.resolve(err);\n                    }\n                );\n                return deferred.promise();\n            },\n\n            addResource: function (bare_jid, resource) {\n                var item = this.get(bare_jid),\n                    resources;\n                if (item) {\n                    resources = item.get('resources');\n                    if (resources) {\n                        if (_.indexOf(resources, resource) === -1) {\n                            resources.push(resource);\n                            item.set({'resources': resources});\n                        }\n                    } else  {\n                        item.set({'resources': [resource]});\n                    }\n                }\n            },\n\n            subscribeBack: function (bare_jid) {\n                var contact = this.get(bare_jid);\n                if (contact instanceof converse.RosterContact) {\n                    contact.authorize().subscribe();\n                } else {\n                    // Can happen when a subscription is retried or roster was deleted\n                    this.addContact(bare_jid, '', [], { 'subscription': 'from' }).done(function (contact) {\n                        if (contact instanceof converse.RosterContact) {\n                            contact.authorize().subscribe();\n                        }\n                    });\n                }\n            },\n\n            getNumOnlineContacts: function () {\n                var count = 0,\n                    ignored = ['offline', 'unavailable'],\n                    models = this.models,\n                    models_length = models.length,\n                    i;\n                if (converse.show_only_online_users) {\n                    ignored = _.union(ignored, ['dnd', 'xa', 'away']);\n                }\n                for (i=0; i<models_length; i++) {\n                    if (_.indexOf(ignored, models[i].get('chat_status')) === -1) {\n                        count++;\n                    }\n                }\n                return count;\n            },\n\n            onRosterPush: function (iq) {\n                /* Handle roster updates from the XMPP server.\n                 * See: https://xmpp.org/rfcs/rfc6121.html#roster-syntax-actions-push\n                 *\n                 * Parameters:\n                 *    (XMLElement) IQ - The IQ stanza received from the XMPP server.\n                 */\n                var id = iq.getAttribute('id');\n                var from = iq.getAttribute('from');\n                if (from && from !== \"\" && Strophe.getBareJidFromJid(from) !== converse.bare_jid) {\n                    // Receiving client MUST ignore stanza unless it has no from or from = user's bare JID.\n                    // XXX: Some naughty servers apparently send from a full\n                    // JID so we need to explicitly compare bare jids here.\n                    // https://github.com/jcbrand/converse.js/issues/493\n                    converse.connection.send(\n                        $iq({type: 'error', id: id, from: converse.connection.jid})\n                            .c('error', {'type': 'cancel'})\n                            .c('service-unavailable', {'xmlns': Strophe.NS.ROSTER })\n                    );\n                    return true;\n                }\n                converse.connection.send($iq({type: 'result', id: id, from: converse.connection.jid}));\n                $(iq).children('query').find('item').each(function (idx, item) {\n                    this.updateContact(item);\n                }.bind(this));\n\n                converse.emit('rosterPush', iq);\n                return true;\n            },\n\n            fetchFromServer: function (callback) {\n                /* Get the roster from the XMPP server */\n                var iq = $iq({type: 'get', 'id': converse.connection.getUniqueId('roster')})\n                        .c('query', {xmlns: Strophe.NS.ROSTER});\n                return converse.connection.sendIQ(iq, function () {\n                        this.onReceivedFromServer.apply(this, arguments);\n                        callback.apply(this, arguments);\n                    }.bind(this));\n            },\n\n            onReceivedFromServer: function (iq) {\n                /* An IQ stanza containing the roster has been received from\n                 * the XMPP server.\n                 */\n                $(iq).children('query').find('item').each(function (idx, item) {\n                    this.updateContact(item);\n                }.bind(this));\n                converse.emit('roster', iq);\n            },\n\n            updateContact: function (item) {\n                /* Update or create RosterContact models based on items\n                 * received in the IQ from the server.\n                 */\n                var jid = item.getAttribute('jid');\n                if (this.isSelf(jid)) { return; }\n                var groups = [],\n                    contact = this.get(jid),\n                    ask = item.getAttribute(\"ask\"),\n                    subscription = item.getAttribute(\"subscription\");\n                $.map(item.getElementsByTagName('group'), function (group) {\n                    groups.push(Strophe.getText(group));\n                });\n                if (!contact) {\n                    if ((subscription === \"none\" && ask === null) || (subscription === \"remove\")) {\n                        return; // We're lazy when adding contacts.\n                    }\n                    this.create({\n                        ask: ask,\n                        fullname: item.getAttribute(\"name\") || jid,\n                        groups: groups,\n                        jid: jid,\n                        subscription: subscription\n                    }, {sort: false});\n                } else {\n                    if (subscription === \"remove\") {\n                        return contact.destroy(); // will trigger removeFromRoster\n                    }\n                    // We only find out about requesting contacts via the\n                    // presence handler, so if we receive a contact\n                    // here, we know they aren't requesting anymore.\n                    // see docs/DEVELOPER.rst\n                    contact.save({\n                        subscription: subscription,\n                        ask: ask,\n                        requesting: null,\n                        groups: groups\n                    });\n                }\n            },\n\n            createRequestingContact: function (presence) {\n                /* Creates a Requesting Contact.\n                 *\n                 * Note: this method gets completely overridden by converse-vcard.js\n                 */\n                var bare_jid = Strophe.getBareJidFromJid(presence.getAttribute('from'));\n                var nick = $(presence).children('nick[xmlns='+Strophe.NS.NICK+']').text();\n                var user_data = {\n                    jid: bare_jid,\n                    subscription: 'none',\n                    ask: null,\n                    requesting: true,\n                    fullname: nick || bare_jid,\n                };\n                this.create(user_data);\n                converse.emit('contactRequest', user_data);\n            },\n\n            handleIncomingSubscription: function (presence) {\n                var jid = presence.getAttribute('from');\n                var bare_jid = Strophe.getBareJidFromJid(jid);\n                var contact = this.get(bare_jid);\n                if (!converse.allow_contact_requests) {\n                    converse.rejectPresenceSubscription(\n                        jid,\n                        __(\"This client does not allow presence subscriptions\")\n                    );\n                }\n                if (converse.auto_subscribe) {\n                    if ((!contact) || (contact.get('subscription') !== 'to')) {\n                        this.subscribeBack(bare_jid);\n                    } else {\n                        contact.authorize();\n                    }\n                } else {\n                    if (contact) {\n                        if (contact.get('subscription') !== 'none')  {\n                            contact.authorize();\n                        } else if (contact.get('ask') === \"subscribe\") {\n                            contact.authorize();\n                        }\n                    } else if (!contact) {\n                        this.createRequestingContact(presence);\n                    }\n                }\n            },\n\n            presenceHandler: function (presence) {\n                var $presence = $(presence),\n                    presence_type = presence.getAttribute('type');\n                if (presence_type === 'error') { return true; }\n                var jid = presence.getAttribute('from'),\n                    bare_jid = Strophe.getBareJidFromJid(jid),\n                    resource = Strophe.getResourceFromJid(jid),\n                    chat_status = $presence.find('show').text() || 'online',\n                    status_message = $presence.find('status'),\n                    contact = this.get(bare_jid);\n\n                if (this.isSelf(bare_jid)) {\n                    if ((converse.connection.jid !== jid) &&\n                        (presence_type !== 'unavailable') &&\n                        (converse.synchronize_availability === true ||\n                         converse.synchronize_availability === resource)) {\n                        // Another resource has changed its status and\n                        // synchronize_availability option set to update,\n                        // we'll update ours as well.\n                        converse.xmppstatus.save({'status': chat_status});\n                        if (status_message.length) {\n                            converse.xmppstatus.save({\n                                'status_message': status_message.text()\n                            });\n                        }\n                    }\n                    return;\n                } else if (($presence.find('x').attr('xmlns') || '').indexOf(Strophe.NS.MUC) === 0) {\n                    return; // Ignore MUC\n                }\n                if (contact && (status_message.text() !== contact.get('status'))) {\n                    contact.save({'status': status_message.text()});\n                }\n                if (presence_type === 'subscribed' && contact) {\n                    contact.ackSubscribe();\n                } else if (presence_type === 'unsubscribed' && contact) {\n                    contact.ackUnsubscribe();\n                } else if (presence_type === 'unsubscribe') {\n                    return;\n                } else if (presence_type === 'subscribe') {\n                    this.handleIncomingSubscription(presence);\n                } else if (presence_type === 'unavailable' && contact) {\n                    // Only set the user to offline if there aren't any\n                    // other resources still available.\n                    if (contact.removeResource(resource) === 0) {\n                        contact.save({'chat_status': \"offline\"});\n                    }\n                } else if (contact) { // presence_type is undefined\n                    this.addResource(bare_jid, resource);\n                    contact.save({'chat_status': chat_status});\n                }\n            }\n        });\n\n\n        this.RosterGroup = Backbone.Model.extend({\n            initialize: function (attributes, options) {\n                this.set(_.extend({\n                    description: DESC_GROUP_TOGGLE,\n                    state: converse.OPENED\n                }, attributes));\n                // Collection of contacts belonging to this group.\n                this.contacts = new converse.RosterContacts();\n            }\n        });\n\n\n        this.RosterGroups = Backbone.Collection.extend({\n            model: converse.RosterGroup,\n\n            fetchRosterGroups: function () {\n                /* Fetches all the roster groups from sessionStorage.\n                 *\n                 * Returns a promise which resolves once the groups have been\n                 * returned.\n                 */\n                var deferred = new $.Deferred();\n                this.fetch({\n                    silent: true, // We need to first have all groups before\n                                  // we can start positioning them, so we set\n                                  // 'silent' to true.\n                    success: deferred.resolve\n                });\n                return deferred.promise();\n            }\n        });\n\n\n        this.Message = Backbone.Model.extend({\n            defaults: function(){\n                return {\n                    msgid: converse.connection.getUniqueId()\n                };\n            }\n        });\n\n\n        this.Messages = Backbone.Collection.extend({\n            model: converse.Message,\n            comparator: 'time'\n        });\n\n\n        this.ChatBox = Backbone.Model.extend({\n\n            initialize: function () {\n                this.messages = new converse.Messages();\n                this.messages.browserStorage = new Backbone.BrowserStorage[converse.message_storage](\n                    b64_sha1('converse.messages'+this.get('jid')+converse.bare_jid));\n                this.save({\n                    // The chat_state will be set to ACTIVE once the chat box is opened\n                    // and we listen for change:chat_state, so shouldn't set it to ACTIVE here.\n                    'box_id' : b64_sha1(this.get('jid')),\n                    'chat_state': undefined,\n                    'num_unread': this.get('num_unread') || 0,\n                    'time_opened': this.get('time_opened') || moment().valueOf(),\n                    'url': '',\n                    'user_id' : Strophe.getNodeFromJid(this.get('jid'))\n                });\n            },\n\n            getMessageAttributes: function ($message, $delay, original_stanza) {\n                $delay = $delay || $message.find('delay');\n                var type = $message.attr('type'),\n                    body, stamp, time, sender, from;\n\n                if (type === 'error') {\n                    body = $message.find('error').children('text').text();\n                } else {\n                    body = $message.children('body').text();\n                }\n                var delayed = $delay.length > 0,\n                    fullname = this.get('fullname'),\n                    is_groupchat = type === 'groupchat',\n                    chat_state = $message.find(converse.COMPOSING).length && converse.COMPOSING ||\n                        $message.find(converse.PAUSED).length && converse.PAUSED ||\n                        $message.find(converse.INACTIVE).length && converse.INACTIVE ||\n                        $message.find(converse.ACTIVE).length && converse.ACTIVE ||\n                        $message.find(converse.GONE).length && converse.GONE;\n\n                if (is_groupchat) {\n                    from = Strophe.unescapeNode(Strophe.getResourceFromJid($message.attr('from')));\n                } else {\n                    from = Strophe.getBareJidFromJid($message.attr('from'));\n                }\n                if (_.isEmpty(fullname)) {\n                    fullname = from;\n                }\n                if (delayed) {\n                    stamp = $delay.attr('stamp');\n                    time = stamp;\n                } else {\n                    time = moment().format();\n                }\n                if ((is_groupchat && from === this.get('nick')) || (!is_groupchat && from === converse.bare_jid)) {\n                    sender = 'me';\n                } else {\n                    sender = 'them';\n                }\n                return {\n                    'type': type,\n                    'chat_state': chat_state,\n                    'delayed': delayed,\n                    'fullname': fullname,\n                    'message': body || undefined,\n                    'msgid': $message.attr('id'),\n                    'sender': sender,\n                    'time': time\n                };\n            },\n\n            createMessage: function ($message, $delay, original_stanza) {\n                return this.messages.create(this.getMessageAttributes.apply(this, arguments));\n            }\n        });\n\n        this.ChatBoxes = Backbone.Collection.extend({\n            model: converse.ChatBox,\n            comparator: 'time_opened',\n\n            registerMessageHandler: function () {\n                converse.connection.addHandler(this.onMessage.bind(this), null, 'message', 'chat');\n                converse.connection.addHandler(this.onErrorMessage.bind(this), null, 'message', 'error');\n            },\n\n            chatBoxMayBeShown: function (chatbox) {\n                return true;\n            },\n\n            onChatBoxesFetched: function (collection) {\n                /* Show chat boxes upon receiving them from sessionStorage\n                 *\n                 * This method gets overridden entirely in src/converse-controlbox.js\n                 * if the controlbox plugin is active.\n                 */\n                var that = this;\n                collection.each(function (chatbox) {\n                    if (that.chatBoxMayBeShown(chatbox)) {\n                        chatbox.trigger('show');\n                    }\n                });\n                converse.emit('chatBoxesFetched');\n            },\n\n            onConnected: function () {\n                this.browserStorage = new Backbone.BrowserStorage[converse.storage](\n                    b64_sha1('converse.chatboxes-'+converse.bare_jid));\n                this.registerMessageHandler();\n                this.fetch({\n                    add: true,\n                    success: this.onChatBoxesFetched.bind(this)\n                });\n            },\n\n            onErrorMessage: function (message) {\n                /* Handler method for all incoming error message stanzas\n                 */\n                // TODO: we can likely just reuse \"onMessage\" below\n                var $message = $(message),\n                    from_jid =  Strophe.getBareJidFromJid($message.attr('from'));\n                if (from_jid === converse.bare_jid) {\n                    return true;\n                }\n                // Get chat box, but only create a new one when the message has a body.\n                var chatbox = this.getChatBox(from_jid);\n                if (!chatbox) {\n                    return true;\n                }\n                chatbox.createMessage($message, null, message);\n                return true;\n            },\n\n            onMessage: function (message) {\n                /* Handler method for all incoming single-user chat \"message\"\n                 * stanzas.\n                 */\n                var $message = $(message),\n                    contact_jid, $forwarded, $delay, from_bare_jid,\n                    from_resource, is_me, msgid,\n                    chatbox, resource,\n                    from_jid = $message.attr('from'),\n                    to_jid = $message.attr('to'),\n                    to_resource = Strophe.getResourceFromJid(to_jid);\n\n                if (converse.filter_by_resource && (to_resource && to_resource !== converse.resource)) {\n                    converse.log(\n                        'onMessage: Ignoring incoming message intended for a different resource: '+to_jid,\n                        'info'\n                    );\n                    return true;\n                } else if (utils.isHeadlineMessage(message)) {\n                    // XXX: Ideally we wouldn't have to check for headline\n                    // messages, but Prosody sends headline messages with the\n                    // wrong type ('chat'), so we need to filter them out here.\n                    converse.log(\n                        \"onMessage: Ignoring incoming headline message sent with type 'chat' from JID: \"+from_jid,\n                        'info'\n                    );\n                    return true;\n                }\n                $forwarded = $message.find('forwarded');\n                if ($forwarded.length) {\n                    var $forwarded_message = $forwarded.children('message');\n                    if (Strophe.getBareJidFromJid($forwarded_message.attr('from')) !== from_jid) {\n                        // Prevent message forging via carbons\n                        //\n                        // https://xmpp.org/extensions/xep-0280.html#security\n                        return true;\n                    }\n                    $message = $forwarded_message;\n                    $delay = $forwarded.children('delay');\n                    from_jid = $message.attr('from');\n                    to_jid = $message.attr('to');\n                }\n                from_bare_jid = Strophe.getBareJidFromJid(from_jid);\n                from_resource = Strophe.getResourceFromJid(from_jid);\n                is_me = from_bare_jid === converse.bare_jid;\n                msgid = $message.attr('id');\n                if (is_me) {\n                    // I am the sender, so this must be a forwarded message...\n                    contact_jid = Strophe.getBareJidFromJid(to_jid);\n                    resource = Strophe.getResourceFromJid(to_jid);\n                } else {\n                    contact_jid = from_bare_jid;\n                    resource = from_resource;\n                }\n                converse.emit('message', message);\n                // Get chat box, but only create a new one when the message has a body.\n                chatbox = this.getChatBox(contact_jid, $message.find('body').length > 0);\n                if (!chatbox) {\n                    return true;\n                }\n                if (msgid && chatbox.messages.findWhere({msgid: msgid})) {\n                    return true; // We already have this message stored.\n                }\n                chatbox.createMessage($message, $delay, message);\n                return true;\n            },\n\n            getChatBox: function (jid, create, attrs) {\n                /* Returns a chat box or optionally return a newly\n                 * created one if one doesn't exist.\n                 *\n                 * Parameters:\n                 *    (String) jid - The JID of the user whose chat box we want\n                 *    (Boolean) create - Should a new chat box be created if none exists?\n                 */\n                jid = jid.toLowerCase();\n                var bare_jid = Strophe.getBareJidFromJid(jid);\n                var chatbox = this.get(bare_jid);\n                if (!chatbox && create) {\n                    var roster_item = converse.roster.get(bare_jid);\n                    if (roster_item === undefined) {\n                        converse.log('Could not get roster item for JID '+bare_jid, 'error');\n                        return;\n                    }\n                    chatbox = this.create(_.extend({\n                        'id': bare_jid,\n                        'jid': bare_jid,\n                        'fullname': _.isEmpty(roster_item.get('fullname'))? jid: roster_item.get('fullname'),\n                        'image_type': roster_item.get('image_type'),\n                        'image': roster_item.get('image'),\n                        'url': roster_item.get('url')\n                    }, attrs || {}));\n                }\n                return chatbox;\n            }\n        });\n\n        this.ChatBoxViews = Backbone.Overview.extend({\n\n            initialize: function () {\n                this.model.on(\"add\", this.onChatBoxAdded, this);\n                this.model.on(\"destroy\", this.removeChat, this);\n            },\n\n            _ensureElement: function () {\n                /* Override method from backbone.js\n                 * If the #conversejs element doesn't exist, create it.\n                 */\n                if (!this.el) {\n                    var $el = $('#conversejs');\n                    if (!$el.length) {\n                        $el = $('<div id=\"conversejs\">');\n                        $('body').append($el);\n                    }\n                    $el.html('');\n                    this.setElement($el, false);\n                } else {\n                    this.setElement(_.result(this, 'el'), false);\n                }\n            },\n\n            onChatBoxAdded: function (item) {\n                // Views aren't created here, since the core code doesn't\n                // contain any views. Instead, they're created in overrides in\n                // plugins, such as in converse-chatview.js and converse-muc.js\n                return this.get(item.get('id'));\n            },\n\n            removeChat: function (item) {\n                this.remove(item.get('id'));\n            },\n\n            closeAllChatBoxes: function () {\n                /* This method gets overridden in src/converse-controlbox.js if\n                 * the controlbox plugin is active.\n                 */\n                this.each(function (view) { view.close(); });\n                return this;\n            },\n\n            chatBoxMayBeShown: function (chatbox) {\n                return this.model.chatBoxMayBeShown(chatbox);\n            },\n\n            getChatBox: function (attrs, create) {\n                var chatbox  = this.model.get(attrs.jid);\n                if (!chatbox && create) {\n                    chatbox = this.model.create(attrs, {\n                        'error': function (model, response) {\n                            converse.log(response.responseText);\n                        }\n                    });\n                }\n                return chatbox;\n            },\n\n            showChat: function (attrs) {\n                /* Find the chat box and show it (if it may be shown).\n                 * If it doesn't exist, create it.\n                 */\n                var chatbox = this.getChatBox(attrs, true);\n                if (this.chatBoxMayBeShown(chatbox)) {\n                    chatbox.trigger('show', true);\n                }\n                return chatbox;\n            }\n        });\n\n\n        this.XMPPStatus = Backbone.Model.extend({\n            initialize: function () {\n                this.set({\n                    'status' : this.getStatus()\n                });\n                this.on('change', function (item) {\n                    if (_.has(item.changed, 'status')) {\n                        converse.emit('statusChanged', this.get('status'));\n                    }\n                    if (_.has(item.changed, 'status_message')) {\n                        converse.emit('statusMessageChanged', this.get('status_message'));\n                    }\n                }.bind(this));\n            },\n\n            constructPresence: function (type, status_message) {\n                var presence;\n                type = typeof type === 'string' ? type : (this.get('status') || converse.default_state);\n                status_message = typeof status_message === 'string' ? status_message : undefined;\n                // Most of these presence types are actually not explicitly sent,\n                // but I add all of them here for reference and future proofing.\n                if ((type === 'unavailable') ||\n                        (type === 'probe') ||\n                        (type === 'error') ||\n                        (type === 'unsubscribe') ||\n                        (type === 'unsubscribed') ||\n                        (type === 'subscribe') ||\n                        (type === 'subscribed')) {\n                    presence = $pres({'type': type});\n                } else if (type === 'offline') {\n                    presence = $pres({'type': 'unavailable'});\n                } else if (type === 'online') {\n                    presence = $pres();\n                } else {\n                    presence = $pres().c('show').t(type).up();\n                }\n                if (status_message) {\n                    presence.c('status').t(status_message);\n                }\n                return presence;\n            },\n\n            sendPresence: function (type, status_message) {\n                converse.connection.send(this.constructPresence(type, status_message));\n            },\n\n            setStatus: function (value) {\n                this.sendPresence(value);\n                this.save({'status': value});\n            },\n\n            getStatus: function () {\n                return this.get('status') || converse.default_state;\n            },\n\n            setStatusMessage: function (status_message) {\n                this.sendPresence(this.getStatus(), status_message);\n                var prev_status = this.get('status_message');\n                this.save({'status_message': status_message});\n                if (this.xhr_custom_status) {\n                    $.ajax({\n                        url:  this.xhr_custom_status_url,\n                        type: 'POST',\n                        data: {'msg': status_message}\n                    });\n                }\n                if (prev_status === status_message) {\n                    this.trigger(\"update-status-ui\", this);\n                }\n            }\n        });\n\n        this.Session = Backbone.Model; // General session settings to be saved to sessionStorage.\n        this.Feature = Backbone.Model;\n        this.Features = Backbone.Collection.extend({\n            /* Service Discovery\n             * -----------------\n             * This collection stores Feature Models, representing features\n             * provided by available XMPP entities (e.g. servers)\n             * See XEP-0030 for more details: http://xmpp.org/extensions/xep-0030.html\n             * All features are shown here: http://xmpp.org/registrar/disco-features.html\n             */\n            model: converse.Feature,\n            initialize: function () {\n                this.addClientIdentities().addClientFeatures();\n                this.browserStorage = new Backbone.BrowserStorage[converse.storage](\n                    b64_sha1('converse.features'+converse.bare_jid)\n                );\n                this.on('add', this.onFeatureAdded, this);\n                if (this.browserStorage.records.length === 0) {\n                    // browserStorage is empty, so we've likely never queried this\n                    // domain for features yet\n                    converse.connection.disco.info(converse.domain, null, this.onInfo.bind(this));\n                    converse.connection.disco.items(converse.domain, null, this.onItems.bind(this));\n                } else {\n                    this.fetch({add:true});\n                }\n            },\n\n            onFeatureAdded: function (feature) {\n                converse.emit('serviceDiscovered', feature);\n            },\n\n            addClientIdentities: function () {\n                /* See http://xmpp.org/registrar/disco-categories.html\n                 */\n                 converse.connection.disco.addIdentity('client', 'web', 'Converse.js');\n                 return this;\n            },\n\n            addClientFeatures: function () {\n                /* The strophe.disco.js plugin keeps a list of features which\n                 * it will advertise to any #info queries made to it.\n                 *\n                 * See: http://xmpp.org/extensions/xep-0030.html#info\n                 */\n                converse.connection.disco.addFeature(Strophe.NS.BOSH);\n                converse.connection.disco.addFeature(Strophe.NS.CHATSTATES);\n                converse.connection.disco.addFeature(Strophe.NS.DISCO_INFO);\n                converse.connection.disco.addFeature(Strophe.NS.ROSTERX); // Limited support\n                if (converse.message_carbons) {\n                    converse.connection.disco.addFeature(Strophe.NS.CARBONS);\n                }\n                return this;\n            },\n\n            onItems: function (stanza) {\n                $(stanza).find('query item').each(function (idx, item) {\n                    converse.connection.disco.info(\n                        $(item).attr('jid'),\n                        null,\n                        this.onInfo.bind(this));\n                }.bind(this));\n            },\n\n            onInfo: function (stanza) {\n                var $stanza = $(stanza);\n                if (($stanza.find('identity[category=server][type=im]').length === 0) &&\n                    ($stanza.find('identity[category=conference][type=text]').length === 0)) {\n                    // This isn't an IM server component\n                    return;\n                }\n                $stanza.find('feature').each(function (idx, feature) {\n                    var namespace = $(feature).attr('var');\n                    this[namespace] = true;\n                    this.create({\n                        'var': namespace,\n                        'from': $stanza.attr('from')\n                    });\n                }.bind(this));\n            }\n        });\n\n        this.setUpXMLLogging = function () {\n            Strophe.log = function (level, msg) {\n                converse.log(msg, level);\n            };\n            if (this.debug) {\n                this.connection.xmlInput = function (body) { converse.log(body.outerHTML); };\n                this.connection.xmlOutput = function (body) { converse.log(body.outerHTML); };\n            }\n        };\n\n        this.fetchLoginCredentials = function () {\n            var deferred = new $.Deferred();\n            $.ajax({\n                url:  converse.credentials_url,\n                type: 'GET',\n                dataType: \"json\",\n                success: function (response) {\n                    deferred.resolve({\n                        'jid': response.jid,\n                        'password': response.password\n                    });\n                },\n                error: function (response) {\n                    delete converse.connection;\n                    converse.emit('noResumeableSession');\n                    deferred.reject(response);\n                }\n            });\n            return deferred.promise();\n        };\n\n        this.startNewBOSHSession = function () {\n            var that = this;\n            $.ajax({\n                url:  this.prebind_url,\n                type: 'GET',\n                dataType: \"json\",\n                success: function (response) {\n                    that.connection.attach(\n                            response.jid,\n                            response.sid,\n                            response.rid,\n                            that.onConnectStatusChanged\n                    );\n                },\n                error: function (response) {\n                    delete that.connection;\n                    that.emit('noResumeableSession');\n                }\n            });\n        };\n\n        this.attemptPreboundSession = function (reconnecting) {\n            /* Handle session resumption or initialization when prebind is being used.\n             */\n            if (!reconnecting && this.keepalive) {\n                if (!this.jid) {\n                    throw new Error(\"attemptPreboundSession: when using 'keepalive' with 'prebind, \"+\n                                    \"you must supply the JID of the current user.\");\n                }\n                try {\n                    return this.connection.restore(this.jid, this.onConnectStatusChanged);\n                } catch (e) {\n                    this.log(\"Could not restore session for jid: \"+this.jid+\" Error message: \"+e.message);\n                    this.clearSession(); // If there's a roster, we want to clear it (see #555)\n                }\n            }\n\n            // No keepalive, or session resumption has failed.\n            if (!reconnecting && this.jid && this.sid && this.rid) {\n                return this.connection.attach(this.jid, this.sid, this.rid, this.onConnectStatusChanged);\n            } else if (this.prebind_url) {\n                return this.startNewBOSHSession();\n            } else {\n                throw new Error(\"attemptPreboundSession: If you use prebind and not keepalive, \"+\n                    \"then you MUST supply JID, RID and SID values or a prebind_url.\");\n            }\n        };\n\n        this.autoLogin = function (credentials) {\n            if (credentials) {\n                // If passed in, then they come from credentials_url, so we\n                // set them on the converse object.\n                this.jid = credentials.jid;\n                this.password = credentials.password;\n            }\n            if (this.authentication === converse.ANONYMOUS) {\n                if (!this.jid) {\n                    throw new Error(\"Config Error: when using anonymous login \" +\n                        \"you need to provide the server's domain via the 'jid' option. \" +\n                        \"Either when calling converse.initialize, or when calling \" +\n                        \"converse.user.login.\");\n                }\n                this.connection.connect(this.jid.toLowerCase(), null, this.onConnectStatusChanged);\n            } else if (this.authentication === converse.LOGIN) {\n                var password = converse.connection.pass || this.password;\n                if (!password) {\n                    if (this.auto_login && !this.password) {\n                        throw new Error(\"initConnection: If you use auto_login and \"+\n                            \"authentication='login' then you also need to provide a password.\");\n                    }\n                    converse.setDisconnectionCause(Strophe.Status.AUTHFAIL, undefined, true);\n                    converse.disconnect();\n                    return;\n                }\n                var resource = Strophe.getResourceFromJid(this.jid);\n                if (!resource) {\n                    this.jid = this.jid.toLowerCase() + converse.generateResource();\n                } else {\n                    this.jid = Strophe.getBareJidFromJid(this.jid).toLowerCase()+'/'+resource;\n                }\n                this.connection.connect(this.jid, password, this.onConnectStatusChanged);\n            }\n        };\n\n        this.attemptNonPreboundSession = function (credentials, reconnecting) {\n            /* Handle session resumption or initialization when prebind is not being used.\n             *\n             * Two potential options exist and are handled in this method:\n             *  1. keepalive\n             *  2. auto_login\n             */\n            if (this.keepalive && !reconnecting) {\n                try {\n                    return this.connection.restore(this.jid, this.onConnectStatusChanged);\n                } catch (e) {\n                    this.log(\"Could not restore session. Error message: \"+e.message);\n                    this.clearSession(); // If there's a roster, we want to clear it (see #555)\n                }\n            }\n            if (this.auto_login) {\n                if (credentials) {\n                    // When credentials are passed in, they override prebinding\n                    // or credentials fetching via HTTP\n                    this.autoLogin(credentials);\n                } else if (this.credentials_url) {\n                    this.fetchLoginCredentials().done(this.autoLogin.bind(this));\n                } else if (!this.jid) {\n                    throw new Error(\n                        \"initConnection: If you use auto_login, you also need\"+\n                        \"to give either a jid value (and if applicable a \"+\n                        \"password) or you need to pass in a URL from where the \"+\n                        \"username and password can be fetched (via credentials_url).\"\n                    );\n                } else {\n                    // Probably ANONYMOUS login\n                    this.autoLogin();\n                }\n            } else if (reconnecting) {\n                this.autoLogin();\n            }\n        };\n\n        this.logIn = function (credentials, reconnecting) {\n            // We now try to resume or automatically set up a new session.\n            // Otherwise the user will be shown a login form.\n            if (this.authentication === converse.PREBIND) {\n                this.attemptPreboundSession(reconnecting);\n            } else {\n                this.attemptNonPreboundSession(credentials, reconnecting);\n            }\n        };\n\n        this.initConnection = function () {\n            if (this.connection) {\n                return;\n            }\n            if (!this.bosh_service_url && ! this.websocket_url) {\n                throw new Error(\"initConnection: you must supply a value for either the bosh_service_url or websocket_url or both.\");\n            }\n            if (('WebSocket' in window || 'MozWebSocket' in window) && this.websocket_url) {\n                this.connection = new Strophe.Connection(this.websocket_url, this.connection_options);\n            } else if (this.bosh_service_url) {\n                this.connection = new Strophe.Connection(\n                    this.bosh_service_url,\n                    _.extend(this.connection_options, {'keepalive': this.keepalive})\n                );\n            } else {\n                throw new Error(\"initConnection: this browser does not support websockets and bosh_service_url wasn't specified.\");\n            }\n        };\n\n        this._tearDown = function () {\n            /* Remove those views which are only allowed with a valid\n             * connection.\n             */\n            this.unregisterPresenceHandler();\n            if (this.roster) {\n                this.roster.off().reset(); // Removes roster contacts\n            }\n            this.chatboxes.remove(); // Don't call off(), events won't get re-registered upon reconnect.\n            if (this.features) {\n                this.features.reset();\n            }\n            $(window).off('click mousemove keypress focus'+unloadevent, converse.onUserActivity);\n            window.clearInterval(converse.everySecondTrigger);\n            return this;\n        };\n\n        this.initChatBoxes = function () {\n            this.chatboxes = new this.ChatBoxes();\n            this.chatboxviews = new this.ChatBoxViews({model: this.chatboxes});\n        };\n\n        this._initialize = function () {\n            this.initChatBoxes();\n            this.initSession();\n            this.initConnection();\n            this.setUpXMLLogging();\n            this.logIn();\n            return this;\n        };\n\n        // Initialization\n        // --------------\n        // This is the end of the initialize method.\n        if (settings.connection) {\n            this.connection = settings.connection;\n        }\n        var updateSettings = function (settings) {\n            /* Helper method which gets put on the plugin and allows it to\n             * add more user-facing config settings to converse.js.\n             */\n            utils.merge(converse.default_settings, settings);\n            utils.merge(converse, settings);\n            utils.applyUserSettings(converse, settings, converse.user_settings);\n        };\n\n        // If initialize gets called a second time (e.g. during tests), then we\n        // need to re-apply all plugins (for a new converse instance), and we\n        // therefore need to clear this array that prevents plugins from being\n        // initialized twice.\n        // If initialize is called for the first time, then this array is empty\n        // in any case.\n        converse.pluggable.initialized_plugins = [];\n\n        converse.pluggable.initializePlugins({\n            'updateSettings': updateSettings,\n            'converse': converse\n        });\n        converse.emit('pluginsInitialized');\n        converse._initialize();\n        converse.registerGlobalEventHandlers();\n\n        if (!_.isUndefined(converse.connection) &&\n            converse.connection.service === 'jasmine tests') {\n            return converse;\n        } else {\n            return init_deferred.promise();\n        }\n    };\n    return converse;\n}));\n"], "filenames": ["docs/CHANGES.md", "spec/chatbox.js", "src/converse-core.js"], "buggy_code_start_loc": [12, 769, 1450], "buggy_code_end_loc": [12, 844, 1451], "fixing_code_start_loc": [13, 769, 1450], "fixing_code_end_loc": [14, 888, 1458], "type": "CWE-20", "message": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for Converse.js (0.8.0 - 1.0.6, 2.0.0 - 2.0.4).", "other": {"cve": {"id": "CVE-2017-5858", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-09T20:59:00.577", "lastModified": "2017-03-01T02:59:06.043", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for Converse.js (0.8.0 - 1.0.6, 2.0.0 - 2.0.4)."}, {"lang": "es", "value": "Una implementaci\u00f3n incorrecta de \"XEP-0280: Message Carbons\" en m\u00faltiples clientes XMPP permite a un atacante remoto personificar cualquier usuario, incluidos los contactos, en la pantalla de la aplicaci\u00f3n vulnerable. Esto permite varios tipos de ataques de ingenier\u00eda social. Esta CVE es para Converse.js (0.8.0 - 1.0.6, 2.0.0 - 2.0.4)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-346"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "B72CEF80-A5C4-4908-847E-A42A133EB750"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "DE82BC23-CAC5-460C-9BE1-F4A01826ACD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "D74A2AD5-7E0D-4A05-99D2-6CCD9F065D40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "3BB99343-F9CD-453D-B741-75D8E375A64E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "3F0B149D-BB35-47F1-B2EE-A46FA85DFF21"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "DE663F25-9D54-4484-A5FB-F9F39BB0A4DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "1FAD2155-0AEF-4080-908C-F53CA367C7C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "9C9D0125-3D83-4152-9AF6-0E612BAC78B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "428EA3B5-91C3-4671-BAD7-8F8E838B80F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "30784FCD-8079-4A9F-9EEF-28694D55ECE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "B29B31EC-93CD-4468-AD37-563EE88FEF94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "6E3D04A3-C34C-4F3E-A110-7B7AFAAAA7F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "EF40A4B8-CE97-476C-A911-304774E46A4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "BD977F45-D0C0-4E76-A294-5F2A7CFF3A6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "CA079B97-06AE-480E-9A26-08D958560374"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:0.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "363EEFEB-2C3F-475D-AA40-5C1A7C271775"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "1C8D4BC6-2806-4FF1-8CE4-613722BEA340"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "3BC62AB6-3060-4B44-AAB9-CBEBB7505188"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "1FE58D9C-5F96-4B60-9356-B55AD4997CAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "0441FCA3-D517-4B41-B687-EF3454327398"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "886B3A14-6BDC-4CB7-8268-6DF1D872BCC5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "AF33D02B-6C96-4AF4-AD5B-FFBFE757BF31"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "DA1451B0-EE4D-499B-8458-7538F7378EBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "F2D9477A-990E-441B-80DF-DE43A81244D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "FC93F612-E5C1-4B84-8031-38EA8EE4CBB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:2.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "8CC002A9-F935-46BD-ADFD-A4107C70B0FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:2.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "E79F1ABC-116B-49F4-A5A5-7712F866EC63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:conversejs:converse.js:2.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "7D618B06-D4B3-4B49-96E0-DB0D357B656E"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2017/02/09/29", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96183", "source": "cve@mitre.org"}, {"url": "https://github.com/jcbrand/converse.js/commit/42f249cabbbf5c026398e6d3b350f6f9536ea572", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://rt-solutions.de/en/2017/02/CVE-2017-5589_xmpp_carbons/", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://rt-solutions.de/wp-content/uploads/2017/02/CVE-2017-5589_xmpp_carbons.pdf", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jcbrand/converse.js/commit/42f249cabbbf5c026398e6d3b350f6f9536ea572"}}