{"buggy_code": ["#import \"PTYSession.h\"\n#import \"PTYSession+ARC.h\"\n#import \"PTYSession+Private.h\"\n\n#import \"CapturedOutput.h\"\n#import \"CaptureTrigger.h\"\n#import \"Coprocess.h\"\n#import \"CVector.h\"\n#import \"FakeWindow.h\"\n#import \"FileTransferManager.h\"\n#import \"FutureMethods.h\"\n#import \"ITAddressBookMgr.h\"\n#import \"iTerm2SharedARC-Swift.h\"\n#import \"iTerm.h\"\n#import \"iTermAPIHelper.h\"\n#import \"iTermActionsModel.h\"\n#import \"iTermAddTriggerViewController.h\"\n#import \"iTermAdvancedSettingsModel.h\"\n#import \"iTermAnnouncementViewController.h\"\n#import \"iTermApplication.h\"\n#import \"iTermApplicationDelegate.h\"\n#import \"iTermAutomaticProfileSwitcher.h\"\n#import \"iTermBackgroundCommandRunner.h\"\n#import \"iTermBackgroundDrawingHelper.h\"\n#import \"iTermBadgeLabel.h\"\n#import \"iTermBuriedSessions.h\"\n#import \"iTermBuiltInFunctions.h\"\n#import \"iTermCacheableImage.h\"\n#import \"iTermCapturedOutputMark.h\"\n#import \"iTermCarbonHotKeyController.h\"\n#import \"iTermCharacterSource.h\"\n#import \"iTermColorMap.h\"\n#import \"iTermColorPresets.h\"\n#import \"iTermColorSuggester.h\"\n#import \"iTermCommandRunnerPool.h\"\n#import \"iTermComposerManager.h\"\n#import \"iTermCommandHistoryCommandUseMO+Additions.h\"\n#import \"iTermController.h\"\n#import \"iTermCopyModeHandler.h\"\n#import \"iTermCopyModeState.h\"\n#import \"iTermDisclosableView.h\"\n#import \"iTermEchoProbe.h\"\n#import \"iTermExpect.h\"\n#import \"iTermExpressionEvaluator.h\"\n#import \"iTermExpressionParser.h\"\n#import \"iTermFindDriver.h\"\n#import \"iTermFindOnPageHelper.h\"\n#import \"iTermFindPasteboard.h\"\n#import \"iTermGCD.h\"\n#import \"iTermGraphicSource.h\"\n#import \"iTermIntervalTreeObserver.h\"\n#import \"iTermKeyMappings.h\"\n#import \"iTermKeystroke.h\"\n#import \"iTermModifyOtherKeysMapper1.h\"\n#import \"iTermModifyOtherKeysMapper.h\"\n#import \"iTermNaggingController.h\"\n#import \"iTermNotificationController.h\"\n#import \"iTermHapticActuator.h\"\n#import \"iTermHistogram.h\"\n#import \"iTermHotKeyController.h\"\n#import \"iTermInitialDirectory.h\"\n#import \"iTermKeyLabels.h\"\n#import \"iTermLoggingHelper.h\"\n#import \"iTermMalloc.h\"\n#import \"iTermMetalClipView.h\"\n#import \"iTermMultiServerJobManager.h\"\n#import \"iTermObject.h\"\n#import \"iTermOpenDirectory.h\"\n#import \"iTermPreferences.h\"\n#import \"iTermRateLimitedUpdate.h\"\n#import \"iTermScriptConsole.h\"\n#import \"iTermScriptHistory.h\"\n#import \"iTermSharedImageStore.h\"\n#import \"iTermSlownessDetector.h\"\n#import \"iTermSnippetsModel.h\"\n#import \"iTermStandardKeyMapper.h\"\n#import \"iTermStatusBarUnreadCountController.h\"\n#import \"iTermSoundPlayer.h\"\n#import \"iTermRawKeyMapper.h\"\n#import \"iTermTermkeyKeyMapper.h\"\n#import \"iTermMetaFrustrationDetector.h\"\n#import \"iTermMetalGlue.h\"\n#import \"iTermMetalDriver.h\"\n#import \"iTermMouseCursor.h\"\n#import \"iTermNotificationCenter.h\"\n#import \"iTermPasteHelper.h\"\n#import \"iTermPreferences.h\"\n#import \"iTermPrintGuard.h\"\n#import \"iTermProcessCache.h\"\n#import \"iTermProfilePreferences.h\"\n#import \"iTermPromptOnCloseReason.h\"\n#import \"iTermRecentDirectoryMO.h\"\n#import \"iTermRestorableSession.h\"\n#import \"iTermRule.h\"\n#import \"iTermSavePanel.h\"\n#import \"iTermScriptFunctionCall.h\"\n#import \"iTermSecureKeyboardEntryController.h\"\n#import \"iTermSelection.h\"\n#import \"iTermSemanticHistoryController.h\"\n#import \"iTermSessionFactory.h\"\n#import \"iTermSessionHotkeyController.h\"\n#import \"iTermSessionLauncher.h\"\n#import \"iTermSessionNameController.h\"\n#import \"iTermSessionTitleBuiltInFunction.h\"\n#import \"iTermSetFindStringNotification.h\"\n#import \"iTermShellHistoryController.h\"\n#import \"iTermShortcut.h\"\n#import \"iTermShortcutInputView.h\"\n#import \"iTermSlowOperationGateway.h\"\n#import \"iTermStatusBarLayout.h\"\n#import \"iTermStatusBarLayout+tmux.h\"\n#import \"iTermStatusBarViewController.h\"\n#import \"iTermSwiftyString.h\"\n#import \"iTermSwiftyStringGraph.h\"\n#import \"iTermSystemVersion.h\"\n#import \"iTermTextExtractor.h\"\n#import \"iTermTheme.h\"\n#import \"iTermThroughputEstimator.h\"\n#import \"iTermTmuxStatusBarMonitor.h\"\n#import \"iTermTmuxOptionMonitor.h\"\n#import \"iTermUpdateCadenceController.h\"\n#import \"iTermURLMark.h\"\n#import \"iTermURLStore.h\"\n#import \"iTermUserDefaultsObserver.h\"\n#import \"iTermVariableReference.h\"\n#import \"iTermVariableScope.h\"\n#import \"iTermVariableScope+Global.h\"\n#import \"iTermVariableScope+Session.h\"\n#import \"iTermWarning.h\"\n#import \"iTermWebSocketCookieJar.h\"\n#import \"iTermWorkingDirectoryPoller.h\"\n#import \"MovePaneController.h\"\n#import \"MovingAverage.h\"\n#import \"NSAlert+iTerm.h\"\n#import \"NSAppearance+iTerm.h\"\n#import \"NSArray+iTerm.h\"\n#import \"NSColor+iTerm.h\"\n#import \"NSData+iTerm.h\"\n#import \"NSDate+iTerm.h\"\n#import \"NSDictionary+Profile.h\"\n#import \"NSDictionary+iTerm.h\"\n#import \"NSEvent+iTerm.h\"\n#import \"NSFont+iTerm.h\"\n#import \"NSHost+iTerm.h\"\n#import \"NSImage+iTerm.h\"\n#import \"NSObject+iTerm.h\"\n#import \"NSPasteboard+iTerm.h\"\n#import \"NSScreen+iTerm.h\"\n#import \"NSStringITerm.h\"\n#import \"NSThread+iTerm.h\"\n#import \"NSURL+iTerm.h\"\n#import \"NSUserDefaults+iTerm.h\"\n#import \"NSView+iTerm.h\"\n#import \"NSView+RecursiveDescription.h\"\n#import \"NSWindow+PSM.h\"\n#import \"NSWorkspace+iTerm.h\"\n#import \"PasteContext.h\"\n#import \"PasteEvent.h\"\n#import \"PreferencePanel.h\"\n#import \"ProfilePreferencesViewController.h\"\n#import \"ProfilesColorsPreferencesViewController.h\"\n#import \"ProfilesGeneralPreferencesViewController.h\"\n#import \"PSMMinimalTabStyle.h\"\n#import \"PTYNoteViewController.h\"\n#import \"PTYTask.h\"\n#import \"PTYTask+ProcessInfo.h\"\n#import \"PTYTextView.h\"\n#import \"PTYTextView+ARC.h\"\n#import \"PTYWindow.h\"\n#import \"RegexKitLite.h\"\n#import \"SCPFile.h\"\n#import \"SCPPath.h\"\n#import \"SearchResult.h\"\n#import \"SessionView.h\"\n#import \"TaskNotifier.h\"\n#import \"TerminalFile.h\"\n#import \"TriggerController.h\"\n#import \"TmuxController.h\"\n#import \"TmuxControllerRegistry.h\"\n#import \"TmuxGateway.h\"\n#import \"TmuxLayoutParser.h\"\n#import \"TmuxStateParser.h\"\n#import \"TmuxWindowOpener.h\"\n#import \"Trigger.h\"\n#import \"VT100DCSParser.h\"\n#import \"VT100RemoteHost.h\"\n#import \"VT100Screen.h\"\n#import \"VT100ScreenConfiguration.h\"\n#import \"VT100ScreenMark.h\"\n#import \"VT100ScreenMutableState.h\"\n#import \"VT100ScreenMutableState+Resizing.h\"\n#import \"VT100Terminal.h\"\n#import \"VT100Token.h\"\n#import \"WindowArrangements.h\"\n#import \"WindowControllerInterface.h\"\n#import <apr-1/apr_base64.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#import <CoreFoundation/CoreFoundation.h>\n#import <FileProviderService/FileProviderService.h>\n\nstatic const NSInteger kMinimumUnicodeVersion = 8;\nstatic const NSInteger kMaximumUnicodeVersion = 9;\n\nstatic NSString *const PTYSessionDidRepairSavedArrangement = @\"PTYSessionDidRepairSavedArrangement\";\n\nNSString *const PTYSessionCreatedNotification = @\"PTYSessionCreatedNotification\";\nNSString *const PTYSessionTerminatedNotification = @\"PTYSessionTerminatedNotification\";\nNSString *const PTYSessionRevivedNotification = @\"PTYSessionRevivedNotification\";\nNSString *const iTermSessionWillTerminateNotification = @\"iTermSessionDidTerminate\";\nNSString *const PTYSessionDidResizeNotification = @\"PTYSessionDidResizeNotification\";\n\nNSString *const kPTYSessionTmuxFontDidChange = @\"kPTYSessionTmuxFontDidChange\";\nNSString *const kPTYSessionCapturedOutputDidChange = @\"kPTYSessionCapturedOutputDidChange\";\nstatic NSString *const kSuppressAnnoyingBellOffer = @\"NoSyncSuppressAnnyoingBellOffer\";\nstatic NSString *const kSilenceAnnoyingBellAutomatically = @\"NoSyncSilenceAnnoyingBellAutomatically\";\n\nstatic NSString *const kTurnOffMouseReportingOnHostChangeUserDefaultsKey = @\"NoSyncTurnOffMouseReportingOnHostChange\";\nstatic NSString *const kTurnOffFocusReportingOnHostChangeUserDefaultsKey = @\"NoSyncTurnOffFocusReportingOnHostChange\";\n\nstatic NSString *const kTurnOffMouseReportingOnHostChangeAnnouncementIdentifier = @\"TurnOffMouseReportingOnHostChange\";\nstatic NSString *const kTurnOffFocusReportingOnHostChangeAnnouncementIdentifier = @\"TurnOffFocusReportingOnHostChange\";\n\nstatic NSString *const kShellIntegrationOutOfDateAnnouncementIdentifier =\n    @\"kShellIntegrationOutOfDateAnnouncementIdentifier\";\n\nstatic NSString *TERM_ENVNAME = @\"TERM\";\nstatic NSString *COLORFGBG_ENVNAME = @\"COLORFGBG\";\nstatic NSString *PWD_ENVNAME = @\"PWD\";\nstatic NSString *PWD_ENVVALUE = @\"~\";\nstatic NSString *PATH_ENVNAME = @\"PATH\";\n\n// Constants for saved window arrangement keys.\nstatic NSString *const SESSION_ARRANGEMENT_COLUMNS = @\"Columns\";\nstatic NSString *const SESSION_ARRANGEMENT_ROWS = @\"Rows\";\nstatic NSString *const SESSION_ARRANGEMENT_BOOKMARK = @\"Bookmark\";\nstatic NSString *const __attribute__((unused)) SESSION_ARRANGEMENT_BOOKMARK_NAME_DEPRECATED = @\"Bookmark Name\";\nstatic NSString *const SESSION_ARRANGEMENT_WORKING_DIRECTORY = @\"Working Directory\";\nstatic NSString *const SESSION_ARRANGEMENT_CONTENTS = @\"Contents\";\n// Not static because the ARC category uses it.\nNSString *const SESSION_ARRANGEMENT_TMUX_PANE = @\"Tmux Pane\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_HISTORY = @\"Tmux History\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_ALT_HISTORY = @\"Tmux AltHistory\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_STATE = @\"Tmux State\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_TAB_COLOR = @\"Tmux Tab Color\";\nstatic NSString *const SESSION_ARRANGEMENT_IS_TMUX_GATEWAY = @\"Is Tmux Gateway\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_NAME = @\"Tmux Gateway Session Name\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_DCS_ID = @\"Tmux DCS ID\";\nstatic NSString *const SESSION_ARRANGEMENT_CONDUCTOR_DCS_ID = @\"Conductor DCS ID\";\nstatic NSString *const SESSION_ARRANGEMENT_CONDUCTOR_TREE = @\"Conductor Parser Tree\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_ID = @\"Tmux Gateway Session ID\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_FOCUS_REPORTING = @\"Tmux Focus Reporting\";\nstatic NSString *const SESSION_ARRANGEMENT_NAME_CONTROLLER_STATE = @\"Name Controller State\";\nstatic NSString *const __attribute__((unused)) DEPRECATED_SESSION_ARRANGEMENT_DEFAULT_NAME_DEPRECATED = @\"Session Default Name\";  // manually set name\nstatic NSString *const __attribute__((unused)) DEPRECATED_SESSION_ARRANGEMENT_WINDOW_TITLE_DEPRECATED = @\"Session Window Title\";  // server-set window name\nstatic NSString *const __attribute__((unused)) DEPRECATED_SESSION_ARRANGEMENT_NAME_DEPRECATED = @\"Session Name\";  // server-set \"icon\" (tab) name\nstatic NSString *const SESSION_ARRANGEMENT_GUID = @\"Session GUID\";  // A truly unique ID.\nstatic NSString *const SESSION_ARRANGEMENT_LIVE_SESSION = @\"Live Session\";  // If zoomed, this gives the \"live\" session's arrangement.\nstatic NSString *const SESSION_ARRANGEMENT_SUBSTITUTIONS = @\"Substitutions\";  // Dictionary for $$VAR$$ substitutions\nstatic NSString *const SESSION_UNIQUE_ID = @\"Session Unique ID\";  // DEPRECATED. A string used for restoring soft-terminated sessions for arrangements that predate the introduction of the GUID.\nstatic NSString *const SESSION_ARRANGEMENT_SERVER_PID = @\"Server PID\";  // PID for server process for restoration. Only for monoserver.\n// Not static because the ARC category uses it.\nNSString *const SESSION_ARRANGEMENT_SERVER_DICT = @\"Server Dict\";  // NSDictionary. Describes server connection. Only for multiserver.\n// TODO: Make server report the TTY to us since orphans will end up with a nil tty.\nstatic NSString *const SESSION_ARRANGEMENT_TTY = @\"TTY\";  // TTY name. Used when using restoration to connect to a restored server.\nstatic NSString *const SESSION_ARRANGEMENT_VARIABLES = @\"Variables\";  // _variables\n// static NSString *const SESSION_ARRANGEMENT_COMMAND_RANGE_DEPRECATED = @\"Command Range\";  // VT100GridCoordRange\n// Deprecated in favor of SESSION_ARRANGEMENT_SHOULD_EXPECT_PROMPT_MARKS and SESSION_ARRANGEMENT_SHOULD_EXPECT_CURRENT_DIR_UPDATES\nstatic NSString *const SESSION_ARRANGEMENT_SHELL_INTEGRATION_EVER_USED_DEPRECATED = @\"Shell Integration Ever Used\";  // BOOL\n\n// This really belongs in VT100Screen but it's here for historical reasons.\nstatic NSString *const SESSION_ARRANGEMENT_SHOULD_EXPECT_PROMPT_MARKS = @\"Should Expect Prompt Marks\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_SHOULD_EXPECT_CURRENT_DIR_UPDATES = @\"Should Expect Current Dir Updates\";  // BOOL\n\nstatic NSString *const SESSION_ARRANGEMENT_WORKING_DIRECTORY_POLLER_DISABLED = @\"Working Directory Poller Disabled\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_ALERT_ON_NEXT_MARK = @\"Alert on Next Mark\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_COMMANDS = @\"Commands\";  // Array of strings\nstatic NSString *const SESSION_ARRANGEMENT_DIRECTORIES = @\"Directories\";  // Array of strings\nstatic NSString *const SESSION_ARRANGEMENT_HOSTS = @\"Hosts\";  // Array of VT100RemoteHost\nstatic NSString *const SESSION_ARRANGEMENT_CURSOR_GUIDE = @\"Cursor Guide\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_LAST_DIRECTORY = @\"Last Directory\";  // NSString\nstatic NSString *const SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY = @\"Last Local Directory\";  // NSString\nstatic NSString *const SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY_WAS_PUSHED = @\"Last Local Directory Was Pushed\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_LAST_DIRECTORY_IS_UNSUITABLE_FOR_OLD_PWD_DEPRECATED = @\"Last Directory Is Remote\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_SELECTION = @\"Selection\";  // Dictionary for iTermSelection.\nstatic NSString *const SESSION_ARRANGEMENT_APS = @\"Automatic Profile Switching\";  // Dictionary of APS state.\n\nstatic NSString *const SESSION_ARRANGEMENT_PROGRAM = @\"Program\";  // Dictionary. See kProgram constants below.\nstatic NSString *const SESSION_ARRANGEMENT_ENVIRONMENT = @\"Environment\";  // Dictionary of environment vars program was run in\nstatic NSString *const SESSION_ARRANGEMENT_KEYLABELS = @\"Key Labels\";  // Dictionary string -> string\nstatic NSString *const SESSION_ARRANGEMENT_KEYLABELS_STACK = @\"Key Labels Stack\";  // Array of encoded iTermKeyLables dicts\nstatic NSString *const SESSION_ARRANGEMENT_IS_UTF_8 = @\"Is UTF-8\";  // TTY is in utf-8 mode\nstatic NSString *const SESSION_ARRANGEMENT_HOTKEY = @\"Session Hotkey\";  // NSDictionary iTermShortcut dictionaryValue\nstatic NSString *const SESSION_ARRANGEMENT_FONT_OVERRIDES = @\"Font Overrides\";  // Not saved; just used internally when creating a new tmux session.\nstatic NSString *const SESSION_ARRANGEMENT_KEYBOARD_MAP_OVERRIDES = @\"Keyboard Map Overrides\";  // Not saved; just used internally when creating a new tmux session.\nstatic NSString *const SESSION_ARRANGEMENT_SHORT_LIVED_SINGLE_USE = @\"Short Lived Single Use\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_HOSTNAME_TO_SHELL = @\"Hostname to Shell\";  // NSString -> NSString (example: example.com -> fish)\nstatic NSString *const SESSION_ARRANGEMENT_CURSOR_TYPE_OVERRIDE = @\"Cursor Type Override\";  // NSNumber wrapping ITermCursorType\nstatic NSString *const SESSION_ARRANGEMENT_AUTOLOG_FILENAME = @\"AutoLog File Name\";  // NSString. New as of 12/4/19\nstatic NSString *const SESSION_ARRANGEMENT_REUSABLE_COOKIE = @\"Reusable Cookie\";  // NSString.\nstatic NSString *const SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS = @\"Overridden Fields\";  // NSArray<NSString *>\nstatic NSString *const SESSION_ARRANGEMENT_FILTER = @\"Filter\";  // NSString\nstatic NSString *const SESSION_ARRANGEMENT_SSH_STATE = @\"SSH State\";  // NSNumber\nstatic NSString *const SESSION_ARRANGEMENT_CONDUCTOR = @\"Conductor\";  // NSString (json)\nstatic NSString *const SESSION_ARRANGEMENT_PENDING_JUMPS = @\"Pending Jumps\";  // NSArray<NSString *>, optional.\n\n// Keys for dictionary in SESSION_ARRANGEMENT_PROGRAM\nstatic NSString *const kProgramType = @\"Type\";  // Value will be one of the kProgramTypeXxx constants.\nstatic NSString *const kProgramCommand = @\"Command\";  // For kProgramTypeCommand: value is command to run.\nstatic NSString *const kCustomShell = @\"Custom Shell\";\n\n// Values for kProgramType\nstatic NSString *const kProgramTypeShellLauncher = @\"Shell Launcher\";  // Use ShellLauncher --launch_shell\nstatic NSString *const kProgramTypeCommand = @\"Command\";  // Use command in kProgramCommand\nstatic NSString *const kProgramTypeCustomShell = @\"Custom Shell\";\n\nstatic NSString *kTmuxFontChanged = @\"kTmuxFontChanged\";\n\n// Value for SESSION_ARRANGEMENT_TMUX_TAB_COLOR that means \"don't use the\n// default color from the tmux profile; this tab should have no color.\"\nstatic NSString *const iTermTmuxTabColorNone = @\"none\";\n\nstatic NSString *PTYSessionAnnouncementIdentifierTmuxPaused = @\"tmuxPaused\";\n\n// Maps Session GUID to saved contents. Only live between window restoration\n// and the end of startup activities.\nstatic NSMutableDictionary *gRegisteredSessionContents;\n\n// Grace period to avoid failing to write anti-idle code when timer runs just before when the code\n// should be sent.\nstatic const NSTimeInterval kAntiIdleGracePeriod = 0.1;\n\n// Limit for number of entries in self.directories, self.commands, self.hosts.\n// Keeps saved state from exploding like in issue 5029.\nstatic const NSUInteger kMaxDirectories = 100;\nstatic const NSUInteger kMaxCommands = 100;\nstatic const NSUInteger kMaxHosts = 100;\nstatic const CGFloat PTYSessionMaximumMetalViewSize = 16384;\n\nstatic NSString *const kSuppressCaptureOutputRequiresShellIntegrationWarning =\n    @\"NoSyncSuppressCaptureOutputRequiresShellIntegrationWarning\";\nstatic NSString *const kSuppressCaptureOutputToolNotVisibleWarning =\n    @\"NoSyncSuppressCaptureOutputToolNotVisibleWarning\";\n\n// This one cannot be suppressed.\nstatic NSString *const kTwoCoprocessesCanNotRunAtOnceAnnouncementIdentifier =\n    @\"NoSyncTwoCoprocessesCanNotRunAtOnceAnnouncmentIdentifier\";\n\nstatic char iTermEffectiveAppearanceKey;\n\n@interface NSWindow (SessionPrivate)\n- (void)_moveToScreen:(NSScreen *)sender;\n@end\n\ntypedef NS_ENUM(NSUInteger, iTermSSHState) {\n    // Normal state.\n    iTermSSHStateNone,\n\n    // Waiting for conductor just after creating the session with ssh as the command.\n    iTermSSHStateProfile,\n};\n\n@implementation PTYSession {\n    NSString *_termVariable;\n\n    // Has the underlying connection been closed?\n    BOOL _exited;\n\n    // A view that wraps the textview. It is the scrollview's document. This exists to provide a\n    // top margin above the textview.\n    TextViewWrapper *_wrapper;\n\n    // Anti-idle timer that sends a character every so often to the host.\n    NSTimer *_antiIdleTimer;\n\n    // The bookmark the session was originally created with so those settings can be restored if\n    // needed.\n    Profile *_originalProfile;\n\n    // Time since reference date when last keypress was received.\n    NSTimeInterval _lastInput;\n\n    // Time since reference date when the tab label was last updated.\n    NSTimeInterval _lastUpdate;\n\n    // This is used for divorced sessions. It contains the keys in profile\n    // that have been customized. Changes in the original profile will be copied over\n    // to profile except for these keys.\n    NSMutableSet *_overriddenFields;\n\n    // A digital video recorder for this session that implements the instant replay feature. These\n    // are non-null while showing instant replay.\n    DVR *_dvr;\n    DVRDecoder *_dvrDecoder;\n\n    // Set only if this is not a live session (we are showing instant replay). Is a pointer to the\n    // hidden live session while looking at the past.\n    PTYSession *_liveSession;\n\n    // Is the update timer's callback currently running?\n    BOOL _timerRunning;\n\n    // Time session was created\n    NSDate *_creationDate;\n\n    // If not nil, we're aggregating text to append to a pasteboard. The pasteboard will be\n    // updated when this is set to nil.\n    NSString *_pasteboard;\n    NSMutableData *_pbtext;\n\n    // Does the terminal think this session is focused?\n    BOOL _focused;\n\n    FindContext *_tailFindContext;\n    NSTimer *_tailFindTimer;\n    // A one-shot tail find runs even though the find view is invisible. Once it's done searching,\n    // it doesn't restart itself until the user does cmd-g again. See issue 9964.\n    BOOL _performingOneShotTailFind;\n\n    TmuxGateway *_tmuxGateway;\n    BOOL _haveKickedOffTmux;\n    BOOL _tmuxSecureLogging;\n    // The tmux rename-window command is only sent when the name field resigns first responder.\n    // This tracks if a tmux client's name has changed but the tmux server has not been informed yet.\n    BOOL _tmuxTitleOutOfSync;\n    PTYSessionTmuxMode _tmuxMode;\n    BOOL _tmuxWindowClosingByClientRequest;\n    // This is the write end of a pipe for tmux clients. The read end is in TaskNotifier.\n    NSFileHandle *_tmuxClientWritePipe;\n    NSInteger _requestAttentionId;  // Last request-attention identifier\n\n    VT100GridAbsCoordRange _lastOrCurrentlyRunningCommandAbsRange;\n\n    NSTimeInterval _timeOfLastScheduling;\n\n    dispatch_semaphore_t _executionSemaphore;\n\n    // Previous updateDisplay timer's timeout period (not the actual duration,\n    // but the kXXXTimerIntervalSec value).\n    NSTimeInterval _lastTimeout;\n\n    // In order to correctly draw a tiled background image, we must first draw\n    // it into an image the size of the session view, and then blit from it\n    // onto the background of whichever view needs a background. This ensures\n    // the tessellation is consistent.\n    NSImage *_patternedImage;\n\n    // Mouse reporting state\n    VT100GridCoord _lastReportedCoord;\n    NSPoint _lastReportedPoint;\n\n    // Remembers if the mouse down was reported to decide if mouse up should also be reported.\n    BOOL _reportingLeftMouseDown;\n    BOOL _reportingMiddleMouseDown;\n    BOOL _reportingRightMouseDown;\n\n    // Did we get CurrentDir code?\n    BOOL _shouldExpectCurrentDirUpdates;\n\n    // Disable the working directory poller?\n    BOOL _workingDirectoryPollerDisabled;\n\n    // Has the user or an escape code change the cursor guide setting?\n    // If so, then the profile setting will be disregarded.\n    BOOL _cursorGuideSettingHasChanged;\n\n    // Maps announcement identifiers to view controllers.\n    NSMutableDictionary *_announcements;\n\n    // Moving average of time between bell rings\n    MovingAverage *_bellRate;\n    NSTimeInterval _lastBell;\n    NSTimeInterval _ignoreBellUntil;\n    NSTimeInterval _annoyingBellOfferDeclinedAt;\n    BOOL _suppressAllOutput;\n\n    // Session should auto-restart after the pipe breaks.\n    BOOL _shouldRestart;\n\n    // Synthetic sessions are used for \"zoom in\" and DVR, and their closing cannot be undone.\n    BOOL _synthetic;\n\n    // Cached advanced setting\n    NSTimeInterval _idleTime;\n\n    // Current unicode version.\n    NSInteger _unicodeVersion;\n\n    // Touch bar labels for function keys.\n    NSMutableDictionary<NSString *, NSString *> *_keyLabels;\n    NSMutableArray<iTermKeyLabels *> *_keyLabelsStack;\n\n    // The containing window is in the midst of a live resize. The update timer\n    // runs in the common modes runloop in this case. That's not acceptable\n    // for normal use for reasons that Apple leaves up to your imagination (it\n    // doesn't fire while you hold down a key, for example), but it does fire\n    // during live resize (unlike the default runloops).\n    BOOL _inLiveResize;\n\n    id<VT100RemoteHostReading> _currentHost;\n\n    NSMutableDictionary<id, ITMNotificationRequest *> *_keystrokeSubscriptions;\n    NSMutableDictionary<id, ITMNotificationRequest *> *_keyboardFilterSubscriptions;\n    NSMutableDictionary<id, ITMNotificationRequest *> *_updateSubscriptions;\n    NSMutableDictionary<id, ITMNotificationRequest *> *_promptSubscriptions;\n    NSMutableDictionary<id, ITMNotificationRequest *> *_customEscapeSequenceNotifications;\n\n    // Used by auto-hide. We can't auto hide the tmux gateway session until at least one window has been opened.\n    BOOL _hideAfterTmuxWindowOpens;\n\n    BOOL _useAdaptiveFrameRate;\n    NSInteger _adaptiveFrameRateThroughputThreshold;\n\n    uint32_t _autoLogId;\n\n    iTermSessionModeHandler *_modeHandler;\n\n    // Absolute line number where touchbar status changed.\n    long long _statusChangedAbsLine;\n\n    iTermUpdateCadenceController *_cadenceController;\n\n    iTermMetalGlue *_metalGlue NS_AVAILABLE_MAC(10_11);\n\n    int _updateCount;\n    BOOL _metalFrameChangePending;\n    int _nextMetalDisabledToken;\n    NSMutableSet *_metalDisabledTokens;\n    BOOL _metalDeviceChanging;\n\n    iTermVariables *_userVariables;\n    iTermSwiftyString *_badgeSwiftyString;\n    iTermSwiftyString *_autoNameSwiftyString;\n    iTermSwiftyString *_subtitleSwiftyString;\n\n    iTermBackgroundDrawingHelper *_backgroundDrawingHelper;\n    iTermMetaFrustrationDetector *_metaFrustrationDetector;\n\n    iTermTmuxStatusBarMonitor *_tmuxStatusBarMonitor;\n    iTermWorkingDirectoryPoller *_pwdPoller;\n    iTermTmuxOptionMonitor *_tmuxTitleMonitor;\n    iTermTmuxOptionMonitor *_tmuxForegroundJobMonitor;\n    iTermTmuxOptionMonitor *_paneIndexMonitor;\n\n    iTermGraphicSource *_graphicSource;\n    iTermVariableReference *_jobPidRef;\n    iTermCacheableImage *_customIcon;\n    CGContextRef _metalContext;\n    BOOL _errorCreatingMetalContext;\n\n    id<iTermKeyMapper> _keyMapper;\n    iTermKeyMappingMode _keyMappingMode;\n\n    NSString *_badgeFontName;\n    iTermVariableScope *_variablesScope;\n    \n    BOOL _showingVisualIndicatorForEsc;\n\n    iTermPrintGuard *_printGuard;\n    iTermBuiltInFunctions *_methods;\n\n    // When this is true, changing the font size does not cause the window size to change.\n    BOOL _windowAdjustmentDisabled;\n    NSSize _badgeLabelSizeFraction;\n\n    // To debug a problem where a session is divorced but its guid is not in the sessions instance profile model.\n    NSString *_divorceDecree;\n\n    BOOL _cursorTypeOverrideChanged;\n    BOOL _titleDirty;\n    // May be stale, but allows us to update titles fast after an OSC 0/1/2\n    iTermProcessInfo *_lastProcessInfo;\n    iTermLoggingHelper *_logging;\n    iTermNaggingController *_naggingController;\n    BOOL _tmuxTTLHasThresholds;\n    NSTimeInterval _tmuxTTLLowerThreshold;\n    NSTimeInterval _tmuxTTLUpperThreshold;\n    // If nonnil, gives the GUID of the session from the arrangement that created it. Often this\n    // will differ from its real GUID. It only serves to find the session in the arrangement to\n    // make repairs.\n    NSString *_arrangementGUID;\n\n    VT100GridSize _savedGridSize;\n\n    iTermActivityInfo _activityInfo;\n    TriggerController *_triggerWindowController;\n\n    // If positive focus reports will not be sent.\n    NSInteger _disableFocusReporting;\n\n    BOOL _initializationFinished;\n    BOOL _needsJiggle;\n\n    // Have we finished loading the address book and color map initially?\n    BOOL _profileInitialized;\n    iTermUserDefaultsObserver *_disableTransparencyInKeyWindowObserver;\n    VT100MutableScreenConfiguration *_config;\n\n    BOOL _profileDidChange;\n    NSInteger _estimatedThroughput;\n    iTermPasteboardReporter *_pasteboardReporter;\n    iTermConductor *_conductor;\n    iTermSSHState _sshState;\n    // (unique ID, hostname)\n    NSMutableData *_sshWriteQueue;\n    BOOL _jiggleUponAttach;\n\n    // Are we currently enqueuing the bytes to write a focus report?\n    BOOL _reportingFocus;\n\n    AITermControllerObjC *_aiterm;\n    NSMutableArray<NSString *> *_commandQueue;\n    NSMutableArray<iTermSSHReconnectionInfo *> *_pendingJumps;\n\n    // If true the session was just created and an offscreen mark alert would be annoying.\n    BOOL _temporarilySuspendOffscreenMarkAlerts;\n    NSMutableArray<NSData *> *_dataQueue;\n\n    BOOL _promptStateAllowsAutoComposer;\n    NSArray<ScreenCharArray *> *_desiredComposerPrompt;\n\n    iTermLocalFileChecker *_localFileChecker;\n    BOOL _needsComposerColorUpdate;\n    BOOL _textViewShouldTakeFirstResponder;\n}\n\n@synthesize isDivorced = _divorced;\n\n+ (NSMapTable<NSString *, PTYSession *> *)sessionMap {\n    static NSMapTable *map;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        NSPointerFunctionsOptions weakWeak = (NSPointerFunctionsWeakMemory | NSPointerFunctionsObjectPersonality);\n        map = [[NSMapTable alloc] initWithKeyOptions:weakWeak\n                                        valueOptions:weakWeak\n                                            capacity:1];\n    });\n    return map;\n}\n\n+ (void)registerBuiltInFunctions {\n    [iTermSessionTitleBuiltInFunction registerBuiltInFunction];\n}\n\n+ (void)registerSessionInArrangement:(NSDictionary *)arrangement {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        gRegisteredSessionContents = [[NSMutableDictionary alloc] init];\n    });\n    NSString *guid = arrangement[SESSION_ARRANGEMENT_GUID];\n    NSDictionary *contents = arrangement[SESSION_ARRANGEMENT_CONTENTS];\n    if (guid && contents) {\n        DLog(@\"Register arrangement for %@\", arrangement[SESSION_ARRANGEMENT_GUID]);\n        gRegisteredSessionContents[guid] = contents;\n    }\n}\n\n+ (void)removeAllRegisteredSessions {\n    DLog(@\"Remove all registered sessions\");\n    [gRegisteredSessionContents removeAllObjects];\n}\n\n- (instancetype)initWithCoder:(NSCoder *)coder {\n    assert(NO);\n    return [self initSynthetic:NO];\n}\n\n- (instancetype)initSynthetic:(BOOL)synthetic {\n    self = [super init];\n    if (self) {\n        DLog(@\"Begin initialization of new PTYsession %p\", self);\n        _autoLogId = arc4random();\n        _useAdaptiveFrameRate = [iTermAdvancedSettingsModel useAdaptiveFrameRate];\n        _adaptiveFrameRateThroughputThreshold = [iTermAdvancedSettingsModel adaptiveFrameRateThroughputThreshold];\n        _idleTime = [iTermAdvancedSettingsModel idleTimeSeconds];\n\n        // The new session won't have the move-pane overlay, so just exit move pane\n        // mode.\n        [[MovePaneController sharedInstance] exitMovePaneMode];\n        _lastInput = [NSDate timeIntervalSinceReferenceDate];\n        _modeHandler = [[iTermSessionModeHandler alloc] init];\n        _modeHandler.delegate = self;\n\n        _lastOutputIgnoringOutputAfterResizing = _lastInput;\n        _lastUpdate = _lastInput;\n        _pasteHelper = [[iTermPasteHelper alloc] init];\n        _pasteHelper.delegate = self;\n\n        // Allocate screen, shell, and terminal objects\n        _shell = [[PTYTask alloc] init];\n        // Allocate a guid. If we end up restoring from a session during startup this will be replaced.\n        _guid = [[NSString uuid] retain];\n        [[PTYSession sessionMap] setObject:self forKey:_guid];\n\n        _screen = [[VT100Screen alloc] init];\n        NSParameterAssert(_shell != nil && _screen != nil);\n\n        _overriddenFields = [[NSMutableSet alloc] init];\n\n        _variables = [[iTermVariables alloc] initWithContext:iTermVariablesSuggestionContextSession\n                                                       owner:self];\n        // Alias for legacy paths\n        [self.variablesScope setValue:_variables forVariableNamed:@\"session\" weak:YES];\n        _userVariables = [[iTermVariables alloc] initWithContext:iTermVariablesSuggestionContextNone\n                                                           owner:self];\n        [self.variablesScope setValue:_userVariables forVariableNamed:@\"user\"];\n\n        _creationDate = [[NSDate date] retain];\n        NSDateFormatter *dateFormatter = [[[NSDateFormatter alloc] init] autorelease];\n        dateFormatter.dateFormat = @\"yyyyMMdd_HHmmss\";\n        [self.variablesScope setValue:[dateFormatter stringFromDate:_creationDate]\n                     forVariableNamed:iTermVariableKeySessionCreationTimeString];\n        [self.variablesScope setValue:[@(_autoLogId) stringValue] forVariableNamed:iTermVariableKeySessionAutoLogID];\n        [self.variablesScope setValue:_guid forVariableNamed:iTermVariableKeySessionID];\n        [self.variablesScope setValue:@\"\" forVariableNamed:iTermVariableKeySessionSelection];\n        [self.variablesScope setValue:@0 forVariableNamed:iTermVariableKeySessionSelectionLength];\n        [self.variablesScope setValue:@NO forVariableNamed:iTermVariableKeySessionShowingAlternateScreen];\n        [self.variablesScope setValue:NSHomeDirectory() forVariableNamed:iTermVariableKeySessionHomeDirectory];\n        [self.variablesScope setValue:@0 forVariableNamed:iTermVariableKeySSHIntegrationLevel];\n        self.variablesScope.shell = [self bestGuessAtUserShell];\n        self.variablesScope.uname = [self bestGuessAtUName];\n\n        _variables.primaryKey = iTermVariableKeySessionID;\n        _jobPidRef = [[iTermVariableReference alloc] initWithPath:iTermVariableKeySessionJobPid\n                                                           vendor:self.variablesScope];\n        __weak __typeof(self) weakSelf = self;\n        _jobPidRef.onChangeBlock = ^{\n            [weakSelf jobPidDidChange];\n        };\n\n        [_autoNameSwiftyString invalidate];\n        [_autoNameSwiftyString autorelease];\n        _autoNameSwiftyString = [[iTermSwiftyString alloc] initWithScope:self.variablesScope\n                                                              sourcePath:iTermVariableKeySessionAutoNameFormat\n                                                         destinationPath:iTermVariableKeySessionAutoName];\n        _autoNameSwiftyString.observer = ^NSString *(NSString * _Nonnull newValue, NSError *error) {\n            if ([weakSelf checkForCyclesInSwiftyStrings]) {\n                weakSelf.variablesScope.autoNameFormat = @\"[Cycle detected]\";\n            }\n            return newValue;\n        };\n\n        _tmuxSecureLogging = NO;\n        _tailFindContext = [[FindContext alloc] init];\n        _lastOrCurrentlyRunningCommandAbsRange = VT100GridAbsCoordRangeMake(-1, -1, -1, -1);\n        _activityCounter = [@0 retain];\n        _announcements = [[NSMutableDictionary alloc] init];\n        _commands = [[NSMutableArray alloc] init];\n        _directories = [[NSMutableArray alloc] init];\n        _hosts = [[NSMutableArray alloc] init];\n        _hostnameToShell = [[NSMutableDictionary alloc] init];\n        _automaticProfileSwitcher = [[iTermAutomaticProfileSwitcher alloc] initWithDelegate:self];\n        _cadenceController = [[iTermUpdateCadenceController alloc] init];\n        _cadenceController.delegate = self;\n\n        _keystrokeSubscriptions = [[NSMutableDictionary alloc] init];\n        _keyboardFilterSubscriptions = [[NSMutableDictionary alloc] init];\n        _updateSubscriptions = [[NSMutableDictionary alloc] init];\n        _promptSubscriptions = [[NSMutableDictionary alloc] init];\n        _customEscapeSequenceNotifications = [[NSMutableDictionary alloc] init];\n        _metalDisabledTokens = [[NSMutableSet alloc] init];\n        _statusChangedAbsLine = -1;\n        _nameController = [[iTermSessionNameController alloc] init];\n        _nameController.delegate = self;\n        _metalGlue = [[iTermMetalGlue alloc] init];\n        _metalGlue.delegate = self;\n        _metalGlue.screen = _screen;\n        _metaFrustrationDetector = [[iTermMetaFrustrationDetector alloc] init];\n        _metaFrustrationDetector.delegate = self;\n        _pwdPoller = [[iTermWorkingDirectoryPoller alloc] init];\n        _pwdPoller.delegate = self;\n        _graphicSource = [[iTermGraphicSource alloc] init];\n        _commandQueue = [[NSMutableArray alloc] init];\n        _alertOnMarksinOffscreenSessions = [iTermPreferences boolForKey:kPreferenceKeyAlertOnMarksInOffscreenSessions];\n        _pendingPublishRequests = [[NSMutableArray alloc] init];\n\n        // This is a placeholder. When the profile is set it will get updated.\n        iTermStandardKeyMapper *standardKeyMapper = [[iTermStandardKeyMapper alloc] init];\n        standardKeyMapper.delegate = self;\n        _keyMapper = standardKeyMapper;\n        _disableTransparencyInKeyWindowObserver = [[iTermUserDefaultsObserver alloc] init];\n        [_disableTransparencyInKeyWindowObserver observeKey:kPreferenceKeyDisableTransparencyForKeyWindow block:^{\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [weakSelf useTransparencyDidChange];\n            });\n        }];\n        _expect = [[iTermExpect alloc] initDry:YES];\n        _sshState = iTermSSHStateNone;\n        [iTermCPUUtilization instanceForSessionID:_guid];\n\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(coprocessChanged)\n                                                     name:kCoprocessStatusChangeNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(sessionContentsChanged:)\n                                                     name:@\"iTermTabContentsChanged\"\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(synchronizeTmuxFonts:)\n                                                     name:kTmuxFontChanged\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(terminalFileShouldStop:)\n                                                     name:kTerminalFileShouldStopNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(profileSessionNameDidEndEditing:)\n                                                     name:kProfileSessionNameDidEndEditing\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(sessionHotkeyDidChange:)\n                                                     name:kProfileSessionHotkeyDidChange\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(apiServerUnsubscribe:)\n                                                     name:iTermRemoveAPIServerSubscriptionsNotification\n                                                   object:nil];\n        // Detach before windows get closed. That's why we have to use the\n        // iTermApplicationWillTerminate notification instead of\n        // NSApplicationWillTerminate, since this gets run before the windows\n        // are released.\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(applicationWillTerminate:)\n                                                     name:iTermApplicationWillTerminate\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(savedArrangementWasRepaired:)\n                                                     name:PTYSessionDidRepairSavedArrangement\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(windowWillStartLiveResize:)\n                                                     name:NSWindowWillStartLiveResizeNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(windowDidEndLiveResize:)\n                                                     name:NSWindowDidEndLiveResizeNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(apiDidStop:)\n                                                     name:iTermAPIHelperDidStopNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(tmuxWillKillWindow:)\n                                                     name:iTermTmuxControllerWillKillWindow\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(applicationDidResignActive:)\n                                                     name:NSApplicationDidResignActiveNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(refreshTerminal:)\n                                                     name:kRefreshTerminalNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(metalClipViewWillScroll:)\n                                                     name:iTermMetalClipViewWillScroll\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(alertOnMarksinOffscreenSessionsDidChange:)\n                                                     name:iTermDidToggleAlertOnMarksInOffscreenSessionsNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(windowDidMiniaturize:)\n                                                     name:@\"iTermWindowWillMiniaturize\"\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(autoComposerDidChange:)\n                                                     name:iTermAutoComposerDidChangeNotification\n                                                   object:nil];\n        [[[NSWorkspace sharedWorkspace] notificationCenter] addObserver:self\n                                                               selector:@selector(activeSpaceDidChange:)\n                                                                   name:NSWorkspaceActiveSpaceDidChangeNotification\n                                                                 object:nil];\n        [[NSUserDefaults standardUserDefaults] it_addObserverForKey:kPreferenceKeyTabStyle\n                                                              block:^(id _Nonnull newValue) {\n                                                                  [weakSelf themeDidChange];\n                                                              }];\n        [NSApp addObserver:self\n                forKeyPath:@\"effectiveAppearance\"\n                   options:NSKeyValueObservingOptionNew\n                   context:&iTermEffectiveAppearanceKey];\n\n        [[iTermFindPasteboard sharedInstance] addObserver:self block:^(id sender, NSString * _Nonnull newValue) {\n            if (!weakSelf.view.window.isKeyWindow) {\n                return;\n            }\n            if (![iTermAdvancedSettingsModel synchronizeQueryWithFindPasteboard] && sender != weakSelf) {\n                return;\n            }\n            [weakSelf findPasteboardStringDidChangeTo:newValue];\n        }];\n\n        if (!synthetic) {\n            [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionCreatedNotification object:self];\n        }\n        _profileDidChange = YES;\n        _config = [[VT100MutableScreenConfiguration alloc] init];\n        [self sync];\n        DLog(@\"Done initializing new PTYSession %@\", self);\n    }\n    return self;\n}\n\nITERM_WEAKLY_REFERENCEABLE\n\n- (void)dealloc {\n    [NSApp removeObserver:self forKeyPath:@\"effectiveAppearance\"];\n\n    if (_textview.delegate == self) {\n        _textview.delegate = nil;\n    }\n    [_view release];\n    [_logging stop];\n    if (@available(macOS 10.11, *)) {\n        [_metalGlue release];\n    }\n    [_nameController release];\n    [self stopTailFind];  // This frees the substring in the tail find context, if needed.\n    _shell.delegate = nil;\n    [_pasteboard release];\n    [_pbtext release];\n    [_creationDate release];\n    [_activityCounter release];\n    [_termVariable release];\n    [_colorFgBgVariable release];\n    [_profile release];\n    [_overriddenFields release];\n    _pasteHelper.delegate = nil;\n    [_pasteHelper release];\n    [_backgroundImagePath release];\n    [_backgroundImage release];\n    [_antiIdleTimer invalidate];\n    [_cadenceController release];\n    [_originalProfile release];\n    [_liveSession release];\n    [_tmuxGateway release];\n    [_tmuxController release];\n    [_download stop];\n    [_download endOfData];\n    [_download release];\n    [_upload stop];\n    [_upload endOfData];\n    [_upload release];\n    [_shell release];\n    [_screen release];\n    [_tailFindContext release];\n    [_patternedImage release];\n    [_announcements release];\n    [_variables release];\n    [_userVariables release];\n    [_program release];\n    [_customShell release];\n    [_environment release];\n    [_commands release];\n    [_directories release];\n    [_hosts release];\n    [_bellRate release];\n    [iTermCPUUtilization setInstance:nil forSessionID:_guid];\n    [_guid release];\n    [_lastCommand release];\n    [_substitutions release];\n    [_automaticProfileSwitcher release];\n\n    [_keyLabels release];\n    [_keyLabelsStack release];\n    [_currentHost release];\n    [_hostnameToShell release];\n\n    [_keystrokeSubscriptions release];\n    [_keyboardFilterSubscriptions release];\n    [_updateSubscriptions release];\n    [_promptSubscriptions release];\n    [_customEscapeSequenceNotifications release];\n\n    [_modeHandler release];\n    [_metalDisabledTokens release];\n    [_badgeSwiftyString release];\n    [_subtitleSwiftyString release];\n    [_autoNameSwiftyString release];\n    [_statusBarViewController release];\n    [_backgroundDrawingHelper release];\n    [_metaFrustrationDetector release];\n    [_tmuxStatusBarMonitor setActive:NO];\n    [_tmuxStatusBarMonitor release];\n    [_tmuxTitleMonitor release];\n    [_tmuxForegroundJobMonitor invalidate];\n    [_tmuxForegroundJobMonitor release];\n    [_paneIndexMonitor invalidate];\n    [_paneIndexMonitor release];\n    if (_metalContext) {\n        CGContextRelease(_metalContext);\n    }\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n\n    if (_dvrDecoder) {\n        [_dvr releaseDecoder:_dvrDecoder];\n        [_dvr release];\n    }\n\n    [_cursorGuideColor release];\n    [_lastDirectory release];\n    [_lastLocalDirectory release];\n    [_lastRemoteHost release];\n    [_textview release];  // I'm not sure it's ever nonnil here\n    [_currentMarkOrNotePosition release];\n    [_pwdPoller release];\n    [_graphicSource release];\n    [_jobPidRef release];\n    [_customIcon release];\n    [_keyMapper release];\n    [_badgeFontName release];\n    [_variablesScope release];\n    [_printGuard release];\n    [_methods release];\n    [_divorceDecree release];\n    [_cursorTypeOverride release];\n    [_lastProcessInfo release];\n    _logging.rawLogger = nil;\n    _logging.cookedLogger = nil;\n    [_logging release];\n    [_naggingController release];\n    [_pasteBracketingOopsieExpectation release];\n    if (_cookie) {\n        [[iTermWebSocketCookieJar sharedInstance] removeCookie:_cookie];\n        [_cookie release];\n    }\n    [_composerManager release];\n    [_tmuxClientWritePipe release];\n    [_arrangementGUID release];\n    [_triggerWindowController release];\n    [_filter release];\n    [_asyncFilter cancel];\n    [_asyncFilter release];\n    [_contentSubscribers release];\n    [_foundingArrangement release];\n    [_disableTransparencyInKeyWindowObserver release];\n    [_preferredProxyIcon release];\n    [_savedStateForZoom release];\n    [_config release];\n    [_expect release];\n    [_pasteboardReporter release];\n    [_conductor release];\n    [_sshWriteQueue release];\n    [_lastNonFocusReportingWrite release];\n    [_lastFocusReportDate release];\n    [_aiterm release];\n    [_commandQueue release];\n    [_pendingJumps release];\n    [_dataQueue release];\n    [_pendingPublishRequests release];\n    [_desiredComposerPrompt release];\n    [_localFileChecker release];\n\n    [super dealloc];\n}\n\n- (NSString *)description {\n    NSString *synthetic = _synthetic ? @\" Synthetic\" : @\"\";\n    return [NSString stringWithFormat:@\"<%@: %p %dx%d metal=%@ id=%@%@>\",\n            [self class], self, [_screen width], [_screen height], @(self.useMetal), _guid, synthetic];\n}\n\n- (void)didFinishInitialization {\n    DLog(@\"didFinishInitialization\");\n    [_pwdPoller poll];\n    _initializationFinished = YES;\n    if ([self.variablesScope valueForVariableName:iTermVariableKeySessionUsername] == nil) {\n        [self.variablesScope setValue:NSUserName() forVariableNamed:iTermVariableKeySessionUsername];\n    }\n    if ([self.variablesScope valueForVariableName:iTermVariableKeySessionHostname] == nil) {\n        NSString *const name = [NSHost fullyQualifiedDomainName];\n        if ([self.variablesScope valueForVariableName:iTermVariableKeySessionHostname] == nil) {\n            [self.variablesScope setValue:name forVariableNamed:iTermVariableKeySessionHostname];\n        }\n    }\n    if (_desiredComposerPrompt) {\n        DLog(@\"Delayed reveal of prompt\");\n        NSArray<ScreenCharArray *> *prompt = [_desiredComposerPrompt autorelease];\n        _desiredComposerPrompt = nil;\n        [self screenRevealComposerWithPrompt:prompt];\n    }\n}\n\n- (void)setGuid:(NSString *)guid {\n    if ([NSObject object:guid isEqualToObject:_guid]) {\n        return;\n    }\n    if (_guid) {\n        [[PTYSession sessionMap] removeObjectForKey:_guid];\n    }\n    iTermPublisher<NSNumber *> *previousPublisher = [[[[iTermCPUUtilization instanceForSessionID:_guid] publisher] retain] autorelease];\n    [_guid autorelease];\n    _guid = [guid copy];\n    [[iTermCPUUtilization instanceForSessionID:_guid] setPublisher:previousPublisher];\n    [self sync];\n    [[PTYSession sessionMap] setObject:self forKey:_guid];\n    [self.variablesScope setValue:_guid forVariableNamed:iTermVariableKeySessionID];\n}\n\n- (void)takeStatusBarViewControllerFrom:(PTYSession *)donorSession {\n    [_view takeFindDriverFrom:donorSession.view delegate:self];\n\n    _statusBarViewController.delegate = nil;\n    [_statusBarViewController release];\n\n    _statusBarViewController = donorSession->_statusBarViewController;\n    _statusBarViewController.delegate = self;\n\n    donorSession->_statusBarViewController = nil;\n}\n\n- (void)willRetireSyntheticSession:(PTYSession *)syntheticSession {\n    [self takeStatusBarViewControllerFrom:syntheticSession];\n}\n\n- (void)setLiveSession:(PTYSession *)liveSession {\n    assert(liveSession != self);\n    if (liveSession) {\n        assert(!_liveSession);\n        _synthetic = YES;\n        [self takeStatusBarViewControllerFrom:liveSession];\n    } else {\n        [_liveSession autorelease];\n    }\n    _liveSession = liveSession;\n    [_liveSession retain];\n}\n\n- (void)setDvr:(DVR*)dvr liveSession:(PTYSession*)liveSession {\n    _screen.dvr = nil;\n    _dvr = dvr;\n    [_dvr retain];\n    _dvrDecoder = [dvr getDecoder];\n    long long t = [_dvr lastTimeStamp];\n    if (t) {\n        [_dvrDecoder seek:t];\n        [self setDvrFrame];\n    }\n}\n\n- (void)setNeedsDisplay:(BOOL)needsDisplay {\n    [_wrapper setNeedsDisplay:needsDisplay];\n}\n\n- (id<ExternalSearchResultsController>)externalSearchResultsController {\n    return _textview;\n}\n\n- (void)clearInstantReplay {\n    if (_dvrDecoder) {\n        [_dvr releaseDecoder:_dvrDecoder];\n        _dvrDecoder = nil;\n    }\n    [_screen.dvr clear];\n}\n\n- (void)irAdvance:(int)dir\n{\n    if (!_dvr) {\n        if (dir < 0) {\n            [[_delegate realParentWindow] replaySession:self];\n            PTYSession* irSession = [[_delegate realParentWindow] currentSession];\n            if (irSession != self) {\n                // Failed to enter replay mode (perhaps nothing to replay?)\n                [irSession irAdvance:dir];\n            }\n            return;\n        } else {\n            DLog(@\"Beep: Can't go backward when no dvr\");\n            NSBeep();\n            return;\n        }\n\n    }\n    if (dir > 0) {\n        if (![_dvrDecoder next]) {\n            DLog(@\"Beep: dvr reached end\");\n            NSBeep();\n        }\n    } else {\n        if (![_dvrDecoder prev]) {\n            DLog(@\"Beep: dvr reached start\");\n            NSBeep();\n        }\n    }\n    [self setDvrFrame];\n}\n\n- (long long)irSeekToAtLeast:(long long)timestamp\n{\n    assert(_dvr);\n    if (![_dvrDecoder seek:timestamp]) {\n        return [_dvrDecoder timestamp];\n    }\n    [self setDvrFrame];\n    return [_dvrDecoder timestamp];\n}\n\n- (void)appendLinesInRange:(NSRange)rangeOfLines fromSession:(PTYSession *)source {\n    assert(source != self);\n    _modeHandler.mode = iTermSessionModeDefault;\n\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [source.screen enumerateLinesInRange:rangeOfLines\n                                       block:^(int i,\n                                               ScreenCharArray *sca,\n                                               iTermImmutableMetadata metadata,\n                                               BOOL *stopPtr) {\n            if (i + 1 == NSMaxRange(rangeOfLines)) {\n                screen_char_t continuation = { 0 };\n                continuation.code = EOL_SOFT;\n                [mutableState appendScreenChars:sca.line\n                                         length:sca.length\n                         externalAttributeIndex:iTermImmutableMetadataGetExternalAttributesIndex(metadata)\n                                   continuation:continuation];\n            } else {\n                [mutableState appendScreenChars:sca.line\n                                         length:sca.length\n                         externalAttributeIndex:iTermImmutableMetadataGetExternalAttributesIndex(metadata)\n                                   continuation:sca.continuation];\n            }\n        }];\n    }];\n}\n\n- (void)setCopyMode:(BOOL)copyMode {\n    [_textview removePortholeSelections];\n    _modeHandler.mode = copyMode ? iTermSessionModeCopy : iTermSessionModeDefault;\n}\n\n- (BOOL)copyMode {\n    return _modeHandler.mode == iTermSessionModeCopy;\n}\n\n- (BOOL)sessionModeConsumesEvent:(NSEvent *)event {\n    return [_modeHandler wouldHandleEvent:event];\n}\n\n- (void)coprocessChanged\n{\n    [_textview setNeedsDisplay:YES];\n}\n\n+ (void)drawArrangementPreview:(NSDictionary *)arrangement frame:(NSRect)frame dark:(BOOL)dark {\n    Profile *theBookmark =\n    [[ProfileModel sharedInstance] bookmarkWithGuid:arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_GUID]];\n    if (!theBookmark) {\n        theBookmark = [arrangement objectForKey:SESSION_ARRANGEMENT_BOOKMARK];\n    }\n    NSColor *color = [iTermProfilePreferences colorForKey:KEY_BACKGROUND_COLOR\n                                                     dark:dark\n                                                  profile:theBookmark];\n    [color set];\n    NSRectFill(frame);\n}\n\n- (void)setSizeFromArrangement:(NSDictionary*)arrangement {\n    [self setSize:VT100GridSizeMake([[arrangement objectForKey:SESSION_ARRANGEMENT_COLUMNS] intValue],\n                                    [[arrangement objectForKey:SESSION_ARRANGEMENT_ROWS] intValue])];\n}\n\n+ (NSDictionary *)repairedArrangement:(NSDictionary *)arrangement\n             replacingProfileWithGUID:(NSString *)badGuid\n                          withProfile:(Profile *)goodProfile {\n    if ([arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_GUID] isEqualToString:badGuid]) {\n        NSMutableDictionary *result = [[arrangement mutableCopy] autorelease];\n        result[SESSION_ARRANGEMENT_BOOKMARK] = goodProfile;\n        return result;\n    } else {\n        return arrangement;\n    }\n}\n\n+ (NSDictionary *)repairedArrangement:(NSDictionary *)arrangement\n     replacingOldCWDOfSessionWithGUID:(NSString *)guid\n                           withOldCWD:(NSString *)replacementOldCWD {\n    if ([arrangement[SESSION_ARRANGEMENT_GUID] isEqualToString:guid]) {\n        return [arrangement dictionaryBySettingObject:replacementOldCWD\n                                               forKey:SESSION_ARRANGEMENT_WORKING_DIRECTORY];\n    }\n    return arrangement;\n}\n\n+ (void)finishInitializingArrangementOriginatedSession:(PTYSession *)aSession\n                                           arrangement:(NSDictionary *)arrangement\n                                       arrangementName:(NSString *)arrangementName\n                                      attachedToServer:(BOOL)attachedToServer\n                                              delegate:(id<PTYSessionDelegate>)delegate\n                                    didRestoreContents:(BOOL)didRestoreContents\n                                           needDivorce:(BOOL)needDivorce\n                                            objectType:(iTermObjectType)objectType\n                                           sessionView:(SessionView *)sessionView\n                                   shouldEnterTmuxMode:(BOOL)shouldEnterTmuxMode\n                                                 state:(NSDictionary *)state\n                                     tmuxDCSIdentifier:(NSString *)tmuxDCSIdentifier\n                                        missingProfile:(BOOL)missingProfile {\n    if (needDivorce) {\n        [aSession divorceAddressBookEntryFromPreferences];\n        [aSession sessionProfileDidChange];\n    }\n\n    // This is done after divorce out of paranoia, since it will modify the profile.\n    NSDictionary *shortcutDictionary = arrangement[SESSION_ARRANGEMENT_HOTKEY];\n    if (shortcutDictionary) {\n        [[iTermSessionHotkeyController sharedInstance] setShortcut:[iTermShortcut shortcutWithDictionary:shortcutDictionary]\n                                                        forSession:aSession];\n        [aSession setSessionSpecificProfileValues:@{ KEY_SESSION_HOTKEY: shortcutDictionary }];\n    }\n\n    [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        NSArray *history = [arrangement objectForKey:SESSION_ARRANGEMENT_TMUX_HISTORY];\n        if (history) {\n            [mutableState setHistory:history];\n        }\n        history = [arrangement objectForKey:SESSION_ARRANGEMENT_TMUX_ALT_HISTORY];\n        if (history) {\n            [mutableState setAltScreen:history];\n        }\n    }];\n    [aSession.nameController restoreNameFromStateDictionary:arrangement[SESSION_ARRANGEMENT_NAME_CONTROLLER_STATE]];\n    if (arrangement[SESSION_ARRANGEMENT_VARIABLES]) {\n        NSDictionary *variables = arrangement[SESSION_ARRANGEMENT_VARIABLES];\n        for (id key in variables) {\n            if ([key hasPrefix:@\"iterm2.\"]) {\n                // Legacy states had this\n                continue;\n            }\n            if ([[aSession.variablesScope valueForVariableName:key] isKindOfClass:[iTermVariables class]]) {\n                // Don't replace nonterminals.\n                continue;\n            }\n            if (!attachedToServer && [key isEqualToString:iTermVariableKeySessionTTY]) {\n                // When starting a new session, don't restore the tty. We *do* want to restore it\n                // when attaching to a session restoration server, though. We have a reasonable\n                // believe that it's the same process and therefore the same TTY.\n                continue;\n            }\n            [aSession.variablesScope setValue:variables[key] forVariableNamed:key];\n        }\n        aSession.textview.badgeLabel = aSession.badgeLabel;\n    }\n\n    if (didRestoreContents && attachedToServer) {\n        [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            if (arrangement[SESSION_ARRANGEMENT_SHELL_INTEGRATION_EVER_USED_DEPRECATED]) {\n                // Legacy migration path\n                const BOOL shellIntegrationEverUsed = [arrangement[SESSION_ARRANGEMENT_SHELL_INTEGRATION_EVER_USED_DEPRECATED] boolValue];\n                mutableState.shouldExpectPromptMarks = shellIntegrationEverUsed;\n            } else {\n                mutableState.shouldExpectPromptMarks = [arrangement[SESSION_ARRANGEMENT_SHOULD_EXPECT_PROMPT_MARKS] boolValue];\n                aSession->_shouldExpectCurrentDirUpdates = [arrangement[SESSION_ARRANGEMENT_SHOULD_EXPECT_CURRENT_DIR_UPDATES] boolValue];\n            }\n        }];\n    }\n\n    aSession->_workingDirectoryPollerDisabled = [arrangement[SESSION_ARRANGEMENT_WORKING_DIRECTORY_POLLER_DISABLED] boolValue] || aSession->_shouldExpectCurrentDirUpdates;\n    if (arrangement[SESSION_ARRANGEMENT_COMMANDS]) {\n        [aSession.commands addObjectsFromArray:arrangement[SESSION_ARRANGEMENT_COMMANDS]];\n        [aSession trimCommandsIfNeeded];\n    }\n    if (arrangement[SESSION_ARRANGEMENT_DIRECTORIES]) {\n        [aSession.directories addObjectsFromArray:arrangement[SESSION_ARRANGEMENT_DIRECTORIES]];\n        [aSession trimDirectoriesIfNeeded];\n    }\n    if (arrangement[SESSION_ARRANGEMENT_HOSTS]) {\n        for (NSDictionary *host in arrangement[SESSION_ARRANGEMENT_HOSTS]) {\n            id<VT100RemoteHostReading> remoteHost = [[[VT100RemoteHost alloc] initWithDictionary:host] autorelease];\n            if (remoteHost) {\n                [aSession.hosts addObject:remoteHost];\n                [aSession trimHostsIfNeeded];\n            }\n        }\n    }\n\n    if (arrangement[SESSION_ARRANGEMENT_APS]) {\n        aSession.automaticProfileSwitcher =\n        [[iTermAutomaticProfileSwitcher alloc] initWithDelegate:aSession\n                                                     savedState:arrangement[SESSION_ARRANGEMENT_APS]];\n    }\n    if (didRestoreContents) {\n        aSession->_sshState = [arrangement[SESSION_ARRANGEMENT_SSH_STATE] unsignedIntegerValue];\n    }\n    aSession.cursorTypeOverride = arrangement[SESSION_ARRANGEMENT_CURSOR_TYPE_OVERRIDE];\n    if (didRestoreContents && attachedToServer) {\n        if (arrangement[SESSION_ARRANGEMENT_ALERT_ON_NEXT_MARK]) {\n            aSession->_alertOnNextMark = [arrangement[SESSION_ARRANGEMENT_ALERT_ON_NEXT_MARK] boolValue];\n        }\n        if (arrangement[SESSION_ARRANGEMENT_CURSOR_GUIDE]) {\n            aSession.textview.highlightCursorLine = [arrangement[SESSION_ARRANGEMENT_CURSOR_GUIDE] boolValue];\n        }\n        aSession.lastRemoteHost = aSession.screen.lastRemoteHost;\n        if (arrangement[SESSION_ARRANGEMENT_LAST_DIRECTORY]) {\n            [aSession->_lastDirectory autorelease];\n            aSession->_lastDirectory = [arrangement[SESSION_ARRANGEMENT_LAST_DIRECTORY] copy];\n            const BOOL isRemote = [arrangement[SESSION_ARRANGEMENT_LAST_DIRECTORY_IS_UNSUITABLE_FOR_OLD_PWD_DEPRECATED] boolValue];\n            if (!isRemote) {\n                aSession.lastLocalDirectory = aSession.lastDirectory;\n            }\n        }\n        if (arrangement[SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY]) {\n            aSession.lastLocalDirectory = arrangement[SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY];\n            aSession.lastLocalDirectoryWasPushed = [arrangement[SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY_WAS_PUSHED] boolValue];\n        }\n    }\n\n    if (state) {\n        [aSession setTmuxState:state];\n    }\n    NSDictionary *liveArrangement = arrangement[SESSION_ARRANGEMENT_LIVE_SESSION];\n    if (liveArrangement) {\n        SessionView *liveView = [[[SessionView alloc] initWithFrame:sessionView.frame] autorelease];\n        liveView.driver.dataSource = aSession->_metalGlue;\n        aSession.textview.cursorVisible = NO;\n        [delegate session:aSession setLiveSession:[self sessionFromArrangement:liveArrangement\n                                                                         named:nil\n                                                                        inView:liveView\n                                                                  withDelegate:delegate\n                                                                 forObjectType:objectType\n                                                            partialAttachments:nil]];\n    }\n    if (shouldEnterTmuxMode) {\n        // Restored a tmux gateway session.\n        [aSession startTmuxMode:tmuxDCSIdentifier];\n        [aSession.tmuxController sessionChangedTo:arrangement[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_NAME]\n                                        sessionId:[arrangement[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_ID] intValue]];\n        [aSession kickOffTmux];\n    }\n    if (missingProfile) {\n        NSDictionary *arrangementProfile = arrangement[SESSION_ARRANGEMENT_BOOKMARK];\n        if (arrangementProfile) {\n            [aSession.naggingController arrangementWithName:arrangementName\n                                        missingProfileNamed:arrangementProfile[KEY_NAME]\n                                                       guid:arrangementProfile[KEY_GUID]];\n        }\n    }\n    if (!attachedToServer) {\n        [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                         VT100ScreenMutableState *mutableState,\n                                                         id<VT100ScreenDelegate> delegate) {\n            [terminal resetSendModifiersWithSideEffects:YES];\n        }];\n    }\n    NSString *path = [aSession.screen workingDirectoryOnLine:aSession.screen.numberOfScrollbackLines + aSession.screen.cursorY - 1];\n    [aSession.variablesScope setValue:path forVariableNamed:iTermVariableKeySessionPath];\n\n    [aSession.nameController setNeedsUpdate];\n    [aSession.nameController updateIfNeeded];\n}\n\n- (void)didFinishRestoration {\n    if ([_foundingArrangement[SESSION_ARRANGEMENT_FILTER] length] > 0) {\n        [self.delegate session:self setFilter:_foundingArrangement[SESSION_ARRANGEMENT_FILTER]];\n    }\n}\n\n+ (PTYSession *)sessionFromArrangement:(NSDictionary *)arrangement\n                                 named:(NSString *)arrangementName\n                                inView:(SessionView *)sessionView\n                          withDelegate:(id<PTYSessionDelegate>)delegate\n                         forObjectType:(iTermObjectType)objectType\n                    partialAttachments:(NSDictionary *)partialAttachments {\n    DLog(@\"Restoring session from arrangement\");\n\n    Profile *theBookmark =\n    [[ProfileModel sharedInstance] bookmarkWithGuid:arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_GUID]];\n    BOOL needDivorce = NO;\n    BOOL missingProfile = NO;\n    if (!theBookmark) {\n        NSString *originalGuid = arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_ORIGINAL_GUID];\n        if (![[ProfileModel sharedInstance] bookmarkWithGuid:originalGuid]) {\n            missingProfile = YES;\n        }\n\n        theBookmark = [arrangement objectForKey:SESSION_ARRANGEMENT_BOOKMARK];\n        if (theBookmark) {\n            needDivorce = YES;\n        } else {\n            theBookmark = [[ProfileModel sharedInstance] defaultBookmark];\n        }\n    }\n    PTYSession *aSession = [[[PTYSession alloc] initSynthetic:NO] autorelease];\n    aSession.foundingArrangement = [arrangement dictionaryByRemovingObjectForKey:SESSION_ARRANGEMENT_CONTENTS];\n    aSession.view = sessionView;\n    aSession->_savedGridSize = VT100GridSizeMake(MAX(1, [arrangement[SESSION_ARRANGEMENT_COLUMNS] intValue]),\n                                                 MAX(1, [arrangement[SESSION_ARRANGEMENT_ROWS] intValue]));\n    [sessionView setFindDriverDelegate:aSession];\n    NSMutableSet<NSString *> *keysToPreserveInCaseOfDivorce = [NSMutableSet setWithArray:@[ KEY_GUID, KEY_ORIGINAL_GUID ]];\n\n    {\n        NSDictionary<NSString *, NSString *> *overrides = arrangement[SESSION_ARRANGEMENT_FONT_OVERRIDES];\n        if (overrides) {\n            NSMutableDictionary *temp = [[theBookmark mutableCopy] autorelease];\n            [overrides enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull key, NSString * _Nonnull obj, BOOL * _Nonnull stop) {\n                temp[key] = obj;\n            }];\n            theBookmark = [temp dictionaryByRemovingNullValues];\n        }\n    }\n\n    {\n        NSDictionary *overrides = arrangement[SESSION_ARRANGEMENT_KEYBOARD_MAP_OVERRIDES];\n        if (overrides) {\n            NSMutableDictionary *modifiedProfile = [[theBookmark mutableCopy] autorelease];\n            modifiedProfile[KEY_KEYBOARD_MAP] = overrides;\n            theBookmark = modifiedProfile;\n        }\n    }\n    if ([arrangement objectForKey:SESSION_ARRANGEMENT_TMUX_PANE]) {\n        // This is a tmux arrangement.\n        NSString *colorString = arrangement[SESSION_ARRANGEMENT_TMUX_TAB_COLOR];\n        NSDictionary *tabColorDict = [ITAddressBookMgr encodeColor:[NSColor colorFromHexString:colorString]];\n        const BOOL dark = [NSApp effectiveAppearance].it_isDark;\n        NSString *useTabColorKey = iTermAmendedColorKey(KEY_USE_TAB_COLOR, theBookmark, dark);\n        if (tabColorDict) {\n            // We're restoring a tmux arrangement that specifies a tab color.\n            NSColor *profileTabColorDict = [iTermProfilePreferences objectForColorKey:KEY_TAB_COLOR dark:dark profile:theBookmark];\n            if (![iTermProfilePreferences boolForColorKey:KEY_USE_TAB_COLOR dark:dark profile:theBookmark] ||\n                ![NSObject object:profileTabColorDict isApproximatelyEqualToObject:tabColorDict epsilon:1/255.0]) {\n                // The tmux profile does not specify a tab color or it specifies a different one. Override it and divorce.\n                NSString *tabColorKey = iTermAmendedColorKey(KEY_TAB_COLOR, theBookmark, dark);\n                theBookmark = [theBookmark dictionaryBySettingObject:tabColorDict forKey:tabColorKey];\n                theBookmark = [theBookmark dictionaryBySettingObject:@YES forKey:useTabColorKey];\n                needDivorce = YES;\n                [keysToPreserveInCaseOfDivorce addObjectsFromArray:@[ tabColorKey, useTabColorKey ]];\n            }\n        } else if ([colorString isEqualToString:iTermTmuxTabColorNone] &&\n                   [iTermProfilePreferences boolForColorKey:KEY_USE_TAB_COLOR dark:dark profile:theBookmark]) {\n            // There was no tab color but the tmux profile specifies one. Disable it and divorce.\n            theBookmark = [theBookmark dictionaryBySettingObject:@NO forKey:useTabColorKey];\n            [keysToPreserveInCaseOfDivorce addObjectsFromArray:@[ useTabColorKey ]];\n            needDivorce = YES;\n        }\n    }\n    if (needDivorce) {\n        // Keep it from stepping on an existing session with the same guid. Assign a fresh GUID.\n        // Set the ORIGINAL_GUID to an existing guid from which this profile originated if possible.\n        NSString *originalGuid = nil;\n        NSString *recordedGuid = arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_GUID];\n        NSString *recordedOriginalGuid = arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_ORIGINAL_GUID];\n        if ([[ProfileModel sharedInstance] bookmarkWithGuid:recordedGuid]) {\n            originalGuid = recordedGuid;\n        } else if ([[ProfileModel sharedInstance] bookmarkWithGuid:recordedOriginalGuid]) {\n            originalGuid = recordedOriginalGuid;\n        }\n        if (originalGuid) {\n            theBookmark = [theBookmark dictionaryBySettingObject:originalGuid forKey:KEY_ORIGINAL_GUID];\n        }\n        theBookmark = [theBookmark dictionaryBySettingObject:[ProfileModel freshGuid] forKey:KEY_GUID];\n        if ([NSArray castFrom:arrangement[SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS]]) {\n            DLog(@\"Have overridden fields %@\", arrangement[SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS]);\n            // Use the original profile, but preserve keys that were overridden\n            // at the time the arrangement was saved. Also preserve any keys\n            // that were mutated since the profile was taken from the\n            // arrangement.\n            // This prevents an issue where you save a divorced session in an\n            // arrangement and then modify a non-overridden field in the\n            // underlying profile and that setting doesn't get reflected when\n            // you next restore the arrangement.\n            Profile *underlyingProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:originalGuid];\n            NSArray<NSString *> *overriddenFields = arrangement[SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS];\n\n            if (underlyingProfile) {\n                DLog(@\"Underlying profile %@ exists\", originalGuid);\n                MutableProfile *replacement = [[underlyingProfile mutableCopy] autorelease];\n                [keysToPreserveInCaseOfDivorce unionSet:[NSSet setWithArray:overriddenFields]];\n                for (NSString *key in keysToPreserveInCaseOfDivorce) {\n                    DLog(@\"Preserve %@=%@ from arrangement\", key, theBookmark[key]);\n                    replacement[key] = theBookmark[key];\n                }\n                theBookmark = replacement;\n            }\n        }\n    }\n\n    // set our preferences\n    [aSession setProfile:theBookmark];\n\n    [aSession setScreenSize:[sessionView frame] parent:[delegate realParentWindow]];\n\n    if ([arrangement[SESSION_ARRANGEMENT_TMUX_FOCUS_REPORTING] boolValue]) {\n        // This has to be done after setScreenSize:parent: because it has a side-effect of enabling\n        // the terminal.\n        [aSession.screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            terminal.reportFocus = [iTermAdvancedSettingsModel focusReportingEnabled];\n        }];\n    }\n\n    NSDictionary *state = [arrangement objectForKey:SESSION_ARRANGEMENT_TMUX_STATE];\n    if (state) {\n        // For tmux tabs, get the size from the arrangement instead of the containing view because\n        // it helps things to line up correctly.\n        [aSession setSizeFromArrangement:arrangement];\n    }\n    [aSession setPreferencesFromAddressBookEntry:theBookmark];\n    [aSession loadInitialColorTableAndResetCursorGuide];\n    aSession.delegate = delegate;\n\n    BOOL haveSavedProgramData = YES;\n    if ([arrangement[SESSION_ARRANGEMENT_PROGRAM] isKindOfClass:[NSDictionary class]]) {\n        NSDictionary *dict = arrangement[SESSION_ARRANGEMENT_PROGRAM];\n        if ([dict[kProgramType] isEqualToString:kProgramTypeShellLauncher]) {\n            aSession.program = [ITAddressBookMgr shellLauncherCommandWithCustomShell:nil];\n        } else if ([dict[kProgramType] isEqualToString:kProgramTypeCommand]) {\n            aSession.program = dict[kProgramCommand];\n        } else if ([dict[kProgramType] isEqualToString:kProgramTypeCustomShell]) {\n            aSession.program = [ITAddressBookMgr shellLauncherCommandWithCustomShell:dict[kCustomShell]];\n            aSession.customShell = dict[kCustomShell];\n        } else {\n            haveSavedProgramData = NO;\n        }\n    } else {\n        haveSavedProgramData = NO;\n    }\n    if (arrangement[SESSION_ARRANGEMENT_PENDING_JUMPS]) {\n        aSession->_pendingJumps = [[[NSArray castFrom:arrangement[SESSION_ARRANGEMENT_PENDING_JUMPS]] mapWithBlock:^id _Nullable(id  _Nonnull data) {\n            return [[[iTermSSHReconnectionInfo alloc] initWithData: data] autorelease];\n        }] mutableCopy];\n    }\n\n    if (arrangement[SESSION_ARRANGEMENT_ENVIRONMENT]) {\n        aSession.environment = arrangement[SESSION_ARRANGEMENT_ENVIRONMENT];\n    } else {\n        haveSavedProgramData = NO;\n    }\n\n    if (arrangement[SESSION_ARRANGEMENT_IS_UTF_8]) {\n        aSession.isUTF8 = [arrangement[SESSION_ARRANGEMENT_IS_UTF_8] boolValue];\n    } else {\n        haveSavedProgramData = NO;\n    }\n\n    aSession.shortLivedSingleUse = [arrangement[SESSION_ARRANGEMENT_SHORT_LIVED_SINGLE_USE] boolValue];\n    aSession.hostnameToShell = [[arrangement[SESSION_ARRANGEMENT_HOSTNAME_TO_SHELL] mutableCopy] autorelease];\n    [aSession.variablesScope setValue:[aSession bestGuessAtUserShell] forVariableNamed:iTermVariableKeySSHIntegrationLevel];\n\n    if (arrangement[SESSION_ARRANGEMENT_SUBSTITUTIONS]) {\n        aSession.substitutions = arrangement[SESSION_ARRANGEMENT_SUBSTITUTIONS];\n    } else {\n        haveSavedProgramData = NO;\n    }\n\n    if (arrangement[SESSION_ARRANGEMENT_REUSABLE_COOKIE]) {\n        [[iTermWebSocketCookieJar sharedInstance] addCookie:arrangement[SESSION_ARRANGEMENT_REUSABLE_COOKIE]];\n    }\n    NSNumber *tmuxPaneNumber = [arrangement objectForKey:SESSION_ARRANGEMENT_TMUX_PANE];\n    NSString *tmuxDCSIdentifier = nil;\n    BOOL shouldEnterTmuxMode = NO;\n    NSDictionary *contents = arrangement[SESSION_ARRANGEMENT_CONTENTS];\n    BOOL restoreContents = !tmuxPaneNumber && contents && [iTermAdvancedSettingsModel restoreWindowContents];\n    BOOL attachedToServer = NO;\n    typedef void (^iTermSessionCreationCompletionBlock)(PTYSession *, BOOL ok);\n    void (^runCommandBlock)(iTermSessionCreationCompletionBlock) =\n    ^(iTermSessionCreationCompletionBlock innerCompletion) {\n        innerCompletion(aSession, YES);\n    };\n    if (!tmuxPaneNumber) {\n        DLog(@\"No tmux pane ID during session restoration\");\n        // |contents| will be non-nil when using system window restoration.\n        BOOL runCommand = YES;\n        if (arrangement[SESSION_ARRANGEMENT_LIVE_SESSION]) {\n            runCommand = NO;\n        }\n        if ([iTermAdvancedSettingsModel runJobsInServers]) {\n            DLog(@\"Configured to run jobs in servers\");\n            const BOOL isTmuxGateway = [arrangement[SESSION_ARRANGEMENT_IS_TMUX_GATEWAY] boolValue];\n            if (isTmuxGateway) {\n                DLog(@\"Was a tmux gateway. Start recovery mode in parser.\");\n                // Optimistally enter tmux recovery mode. If we do attach, the parser will be in the\n                // right state before any input arrives for it.\n                // In the event that attaching to the server fails we'll first tmux recovery mode\n                // and set runCommand=YES; later, a new program will run and input will be received\n                //  but the parser is safely out of recovery mode by then.\n                [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n                    [terminal.parser startTmuxRecoveryModeWithID:arrangement[SESSION_ARRANGEMENT_TMUX_DCS_ID]];\n                }];\n            }\n            NSString *conductor = [NSString castFrom:arrangement[SESSION_ARRANGEMENT_CONDUCTOR]];\n            if (conductor) {\n                aSession->_conductor = [iTermConductor newConductorWithJSON:conductor delegate:aSession];\n            }\n            if (aSession->_conductor) {\n                [aSession updateVariablesFromConductor];\n                [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n                    NSData *data = [NSData castFrom:arrangement[SESSION_ARRANGEMENT_CONDUCTOR_TREE]];\n                    NSDictionary *dict = [NSDictionary it_fromKeyValueCodedData:data];\n                    if (dict) {\n                        [terminal.parser startConductorRecoveryModeWithID:arrangement[SESSION_ARRANGEMENT_CONDUCTOR_DCS_ID]\n                                                                     tree:dict];\n                    }\n                }];\n            }\n            // iTerm2 is currently configured to run jobs in servers, but we\n            // have to check if the arrangement was saved with that setting on.\n            BOOL didAttach = NO;\n            if ([NSNumber castFrom:arrangement[SESSION_ARRANGEMENT_SERVER_PID]]) {\n                DLog(@\"Have a server PID in the arrangement\");\n                pid_t serverPid = [arrangement[SESSION_ARRANGEMENT_SERVER_PID] intValue];\n                DLog(@\"Try to attach to pid %d\", (int)serverPid);\n                // serverPid might be -1 if the user turned on session restoration and then quit.\n                if (serverPid != -1 && [aSession tryToAttachToServerWithProcessId:serverPid\n                                                                              tty:arrangement[SESSION_ARRANGEMENT_TTY]]) {\n                    DLog(@\"Success!\");\n                    didAttach = YES;\n                }\n            } else if ([iTermMultiServerJobManager available] &&\n                       [NSDictionary castFrom:arrangement[SESSION_ARRANGEMENT_SERVER_DICT]]) {\n                DLog(@\"Have a server dict in the arrangement\");\n                NSDictionary *serverDict = arrangement[SESSION_ARRANGEMENT_SERVER_DICT];\n                DLog(@\"Try to attach to %@\", serverDict);\n                if (partialAttachments) {\n                    id partial = partialAttachments[serverDict];\n                    if (partial &&\n                        [aSession tryToFinishAttachingToMultiserverWithPartialAttachment:partial] != 0) {\n                        DLog(@\"Finished attaching to multiserver!\");\n                        didAttach = YES;\n                    }\n                } else if ([aSession tryToAttachToMultiserverWithRestorationIdentifier:serverDict]) {\n                    DLog(@\"Attached to multiserver!\");\n                    didAttach = YES;\n                }\n            }\n            if (didAttach) {\n                runCommand = NO;\n                attachedToServer = YES;\n                shouldEnterTmuxMode = ([arrangement[SESSION_ARRANGEMENT_IS_TMUX_GATEWAY] boolValue] &&\n                                       arrangement[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_NAME] != nil &&\n                                       arrangement[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_ID] != nil);\n                tmuxDCSIdentifier = arrangement[SESSION_ARRANGEMENT_TMUX_DCS_ID];\n            } else {\n                if (isTmuxGateway) {\n                    [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n                        [terminal.parser cancelTmuxRecoveryMode];\n                    }];\n                }\n                if (aSession->_conductor) {\n                    [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n                        [terminal.parser cancelConductorRecoveryMode];\n                    }];\n                    aSession->_conductor.delegate = nil;\n                    [aSession->_conductor release];\n                    aSession->_conductor = nil;\n                }\n            }\n\n        }\n\n        // GUID will be set for new saved arrangements since late 2014.\n        // Older versions won't be able to associate saved state with windows from a saved arrangement.\n        if (arrangement[SESSION_ARRANGEMENT_GUID]) {\n            DLog(@\"The session arrangement has a GUID\");\n            NSString *guid = arrangement[SESSION_ARRANGEMENT_GUID];\n            aSession->_arrangementGUID = [guid copy];\n            if (guid && gRegisteredSessionContents[guid]) {\n                DLog(@\"The GUID is registered\");\n                // There was a registered session with this guid. This session was created by\n                // restoring a saved arrangement and there is saved content registered.\n                contents = gRegisteredSessionContents[guid];\n                aSession.guid = guid;\n                DLog(@\"Assign guid %@ to session %@ which will have its contents restored from registered contents\",\n                     guid, aSession);\n            } else if ([[iTermController sharedInstance] startingUp] ||\n                       arrangement[SESSION_ARRANGEMENT_CONTENTS]) {\n                // If startingUp is set, then the session is being restored from the default\n                // arrangement, per user preference.\n                // If contents are present, then system window restoration is bringing back a\n                // session.\n                aSession.guid = guid;\n                DLog(@\"iTerm2 is starting up or has contents. Assign guid %@ to session %@ (session is loaded from saved arrangement. No content registered.)\", guid, aSession);\n            }\n        }\n\n        DLog(@\"Have contents=%@\", @(contents != nil));\n        DLog(@\"Restore window contents=%@\", @([iTermAdvancedSettingsModel restoreWindowContents]));\n        if (restoreContents) {\n            DLog(@\"Loading content from line buffer dictionary\");\n            [aSession setContentsFromLineBufferDictionary:contents\n                                 includeRestorationBanner:runCommand\n                                               reattached:attachedToServer];\n            // NOTE: THE SCREEN SIZE IS NOW OUT OF SYNC WITH THE VIEW SIZE. IT MUST BE FIXED!\n        }\n        if (arrangement[SESSION_ARRANGEMENT_KEYLABELS]) {\n            // restoreKeyLabels wants the cursor position to be set so do it after restoring contents.\n            [aSession restoreKeyLabels:[NSDictionary castFrom:arrangement[SESSION_ARRANGEMENT_KEYLABELS]]\n               updateStatusChangedLine:restoreContents];\n            NSArray *labels = arrangement[SESSION_ARRANGEMENT_KEYLABELS_STACK];\n            if (labels) {\n                [aSession->_keyLabelsStack release];\n                aSession->_keyLabelsStack = [[labels mapWithBlock:^id(id anObject) {\n                    return [[[iTermKeyLabels alloc] initWithDictionary:anObject] autorelease];\n                }] mutableCopy];\n            }\n        }\n\n        if (runCommand) {\n            // This path is NOT taken when attaching to a running server.\n            //\n            // When restoring a window arrangement with contents and a nonempty saved directory, always\n            // use the saved working directory, even if that contravenes the default setting for the\n            // profile.\n            [aSession resetForRelaunch];\n            NSString *oldCWD = arrangement[SESSION_ARRANGEMENT_WORKING_DIRECTORY];\n            DLog(@\"Running command...\");\n\n            NSDictionary *environmentArg = @{};\n            NSString *commandArg = nil;\n            NSNumber *isUTF8Arg = nil;\n            NSDictionary *substitutionsArg = nil;\n            NSString *customShell = nil;\n            if (haveSavedProgramData) {\n                // This is the normal case; the else clause is for legacy saved arrangements.\n                environmentArg = aSession.environment ?: @{};\n                commandArg = aSession.program;\n                if (oldCWD &&\n                    [aSession.program isEqualToString:[ITAddressBookMgr standardLoginCommand]]) {\n                    // Create a login session that drops you in the old directory instead of\n                    // using login -fp \"$USER\". This lets saved arrangements properly restore\n                    // the working directory when the profile specifies the home directory.\n                    commandArg = [ITAddressBookMgr shellLauncherCommandWithCustomShell:aSession.customShell];\n                }\n                isUTF8Arg = @(aSession.isUTF8);\n                substitutionsArg = aSession.substitutions;\n                customShell = aSession.customShell;\n            }\n            runCommandBlock = ^(iTermSessionCreationCompletionBlock completion) {\n                assert(completion);\n                iTermSessionAttachOrLaunchRequest *launchRequest =\n                [iTermSessionAttachOrLaunchRequest launchRequestWithSession:aSession\n                                                                  canPrompt:NO\n                                                                 objectType:objectType\n                                                        hasServerConnection:NO\n                                                           serverConnection:(iTermGeneralServerConnection){}\n                                                                  urlString:nil\n                                                               allowURLSubs:NO\n                                                                environment:environmentArg\n                                                                customShell:customShell\n                                                                     oldCWD:oldCWD\n                                                             forceUseOldCWD:contents != nil && oldCWD.length\n                                                                    command:commandArg\n                                                                     isUTF8:isUTF8Arg\n                                                              substitutions:substitutionsArg\n                                                           windowController:(PseudoTerminal *)aSession.delegate.realParentWindow\n                                                                      ready:nil\n                                                                 completion:completion];\n                launchRequest.fromArrangement = YES;\n                iTermSessionFactory *factory = [[[iTermSessionFactory alloc] init] autorelease];\n                launchRequest.arrangementName = arrangementName;\n                [factory attachOrLaunchWithRequest:launchRequest];\n            };\n        }\n    } else {\n        // Is a tmux pane\n        // NOTE: There used to be code here that used state[@\"title\"] but AFAICT that didn't exist.\n        [aSession setTmuxPane:[tmuxPaneNumber intValue]];\n    }\n\n    if (arrangement[SESSION_ARRANGEMENT_SELECTION]) {\n        [aSession.textview.selection setFromDictionaryValue:arrangement[SESSION_ARRANGEMENT_SELECTION]\n                                                      width:aSession.screen.width\n                                    totalScrollbackOverflow:aSession.screen.totalScrollbackOverflow];\n    }\n    [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState restoreInitialSizeWithDelegate:delegate];\n    }];\n    [aSession updateMarksMinimapRangeOfVisibleLines];\n\n    void (^finish)(PTYSession *, BOOL) = ^(PTYSession *newSession, BOOL ok) {\n        if (!ok) {\n            return;\n        }\n        [self finishInitializingArrangementOriginatedSession:aSession\n                                                 arrangement:arrangement\n                                             arrangementName:arrangementName\n                                            attachedToServer:attachedToServer\n                                                    delegate:delegate\n                                          didRestoreContents:restoreContents\n                                                 needDivorce:needDivorce\n                                                  objectType:objectType\n                                                 sessionView:sessionView\n                                         shouldEnterTmuxMode:shouldEnterTmuxMode\n                                                       state:state\n                                           tmuxDCSIdentifier:tmuxDCSIdentifier\n                                              missingProfile:missingProfile];\n        [aSession didFinishInitialization];\n    };\n    if ([aSession.profile[KEY_AUTOLOG] boolValue]) {\n        [aSession retain];\n        void (^startLogging)(NSString *) = ^(NSString *filename) {\n            if (filename) {\n                const NSUInteger value = [iTermProfilePreferences boolForKey:KEY_LOGGING_STYLE\n                                                                   inProfile:aSession.profile];\n                iTermLoggingStyle loggingStyle = iTermLoggingStyleFromUserDefaultsValue(value);\n                [[aSession loggingHelper] setPath:filename\n                                          enabled:YES\n                                            style:loggingStyle\n                                asciicastMetadata:[aSession asciicastMetadata]\n                                           append:@YES];\n            }\n            [aSession autorelease];\n            runCommandBlock(finish);\n        };\n        if (arrangement[SESSION_ARRANGEMENT_AUTOLOG_FILENAME] && restoreContents) {\n            startLogging(arrangement[SESSION_ARRANGEMENT_AUTOLOG_FILENAME]);\n        } else {\n            [aSession fetchAutoLogFilenameWithCompletion:startLogging];\n        }\n    } else {\n        runCommandBlock(finish);\n    }\n\n    return aSession;\n}\n\n- (iTermAsciicastMetadata *)asciicastMetadata {\n    const BOOL dark = [NSApp effectiveAppearance].it_isDark;\n\n    NSArray<NSColor *> *ansi = [[NSArray sequenceWithRange:NSMakeRange(0, 16)] mapWithBlock:^id _Nonnull(NSNumber * _Nonnull n) {\n        NSString *key = [NSString stringWithFormat:KEYTEMPLATE_ANSI_X_COLOR, n.intValue];\n        return [iTermProfilePreferences colorForKey:key\n                                               dark:dark\n                                            profile:self.profile];\n    }];\n    NSString *term = [iTermProfilePreferences stringForKey:KEY_TERMINAL_TYPE inProfile:self.profile];\n    NSDictionary *environment = @{ @\"TERM\": term ?: @\"xterm\",\n                                   @\"SHELL\": [self userShell] };\n    return [[[iTermAsciicastMetadata alloc] initWithWidth:_screen.width\n                                                   height:_screen.height\n                                                  command:_program ?: @\"\"\n                                                    title:[[self name] stringByTrimmingTrailingWhitespace] ?: @\"\"\n                                              environment:environment\n                                                       fg:[iTermProfilePreferences colorForKey:KEY_FOREGROUND_COLOR\n                                                                                          dark:dark\n                                                                                       profile:self.profile]\n                                                       bg:[iTermProfilePreferences colorForKey:KEY_BACKGROUND_COLOR\n                                                                                          dark:dark\n                                                                                       profile:self.profile]\n                                                     ansi:ansi] autorelease];\n}\n\n- (iTermLoggingHelper *)loggingHelper {\n    if (_logging) {\n        return _logging;\n    }\n    _logging = [[iTermLoggingHelper alloc] initWithRawLogger:_shell\n                                                cookedLogger:self\n                                                 profileGUID:self.profile[KEY_GUID]\n                                                       scope:self.variablesScope];\n    return _logging;\n}\n\n// WARNING: This leaves the screen with the wrong size! Call -restoreInitialSize afterwards.\n- (void)setContentsFromLineBufferDictionary:(NSDictionary *)dict\n                   includeRestorationBanner:(BOOL)includeRestorationBanner\n                                 reattached:(BOOL)reattached {\n    [_screen restoreFromDictionary:dict\n          includeRestorationBanner:includeRestorationBanner\n                        reattached:reattached];\n    [_screen enumeratePortholes:^(id<PortholeMarkReading> immutableMark) {\n        [[PortholeRegistry instance] registerKey:immutableMark.uniqueIdentifier\n                                         forMark:immutableMark];\n        id<Porthole> porthole = [_textview hydratePorthole:immutableMark];\n        if (!porthole) {\n            [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n                [mutableState.mutableIntervalTree removeObject:immutableMark.progenitor];\n            }];\n        } else {\n            [self.textview addPorthole:porthole];\n        }\n    }];\n    id<VT100RemoteHostReading> lastRemoteHost = _screen.lastRemoteHost;\n    if (lastRemoteHost) {\n        NSString *pwd = [_screen workingDirectoryOnLine:_screen.numberOfLines];\n        [self screenCurrentHostDidChange:lastRemoteHost\n                                     pwd:pwd\n                                     ssh:NO];\n    }\n\n    const BOOL enabled = _screen.terminalSoftAlternateScreenMode;\n    const BOOL showing = _screen.showingAlternateScreen;\n    [self screenSoftAlternateScreenModeDidChangeTo:enabled showingAltScreen:showing];\n    // Do this to force the hostname variable to be updated.\n    [self currentHost];\n}\n\n- (void)showOrphanAnnouncement {\n    // Jiggle in case this is an ssh session that needs to be recovered, and also to force a redraw\n    // if possible since there won't be any content. We aren't typically attached yet so set\n    // jiggleUponAttach to force it to happen eventually.\n    [self jiggle];\n    _jiggleUponAttach = YES;\n    [self.naggingController didRestoreOrphan];\n}\n\n// Session specific methods\n- (BOOL)setScreenSize:(NSRect)aRect parent:(id<WindowControllerInterface>)parent {\n    _modeHandler.mode = iTermSessionModeDefault;\n    _screen.delegate = self;\n    if ([iTermAdvancedSettingsModel showLocationsInScrollbar] && [iTermAdvancedSettingsModel showMarksInScrollbar]) {\n        _screen.intervalTreeObserver = self;\n    }\n\n    // Allocate the root per-session view.\n    if (!_view) {\n        self.view = [[[SessionView alloc] initWithFrame:NSMakeRect(0, 0, aRect.size.width, aRect.size.height)] autorelease];\n        self.view.driver.dataSource = _metalGlue;\n        [self initializeMarksMinimap];\n        [_view setFindDriverDelegate:self];\n    }\n\n    _view.scrollview.hasVerticalRuler = [parent scrollbarShouldBeVisible];\n\n    // Allocate a text view\n    NSSize aSize = [_view.scrollview contentSize];\n    _wrapper = [[TextViewWrapper alloc] initWithFrame:NSMakeRect(0, 0, aSize.width, aSize.height)];\n\n    _textview = [[PTYTextView alloc] initWithFrame:NSMakeRect(0,\n                                                              [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins],\n                                                              aSize.width,\n                                                              aSize.height)];\n    _textview.colorMap = _screen.colorMap;\n    _textview.keyboardHandler.keyMapper = _keyMapper;\n    _view.mainResponder = _textview;\n    _view.searchResultsMinimapViewDelegate = _textview.findOnPageHelper;\n    _metalGlue.textView = _textview;\n    [_textview setAutoresizingMask: NSViewWidthSizable | NSViewHeightSizable];\n    [_textview setFontTable:[iTermFontTable fontTableForProfile:_profile]\n          horizontalSpacing:[iTermProfilePreferences doubleForKey:KEY_HORIZONTAL_SPACING inProfile:_profile]\n            verticalSpacing:[iTermProfilePreferences doubleForKey:KEY_VERTICAL_SPACING inProfile:_profile]];\n    [self setTransparency:[[_profile objectForKey:KEY_TRANSPARENCY] floatValue]];\n    [self setTransparencyAffectsOnlyDefaultBackgroundColor:[[_profile objectForKey:KEY_TRANSPARENCY_AFFECTS_ONLY_DEFAULT_BACKGROUND_COLOR] boolValue]];\n\n    [_wrapper addSubview:_textview];\n    [_textview setFrame:NSMakeRect(0, [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins], aSize.width, aSize.height - [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins])];\n\n    // assign terminal and task objects\n    // Pause token execution in case the caller needs to modify terminal state before it starts running.\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        iTermTokenExecutorUnpauser *unpauser = [mutableState pauseTokenExecution];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            DLog(@\"unpause %@\", terminal);\n            [unpauser unpause];\n        });\n        [_screen setTerminalEnabled:YES];\n        [_shell setDelegate:self];\n        [self.variablesScope setValue:_shell.tty forVariableNamed:iTermVariableKeySessionTTY];\n        [self.variablesScope setValue:@(_screen.terminalMouseMode) forVariableNamed:iTermVariableKeySessionMouseReportingMode];\n\n        // initialize the screen\n        // TODO: Shouldn't this take the scrollbar into account?\n        NSSize contentSize = [PTYScrollView contentSizeForFrameSize:aSize\n                                            horizontalScrollerClass:nil\n                                              verticalScrollerClass:parent.scrollbarShouldBeVisible ? [[_view.scrollview verticalScroller] class] : nil\n                                                         borderType:_view.scrollview.borderType\n                                                        controlSize:NSControlSizeRegular\n                                                      scrollerStyle:_view.scrollview.scrollerStyle];\n\n        int width = (contentSize.width - [iTermPreferences intForKey:kPreferenceKeySideMargins]*2) / [_textview charWidth];\n        int height = (contentSize.height - [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins]*2) / [_textview lineHeight];\n        [_screen destructivelySetScreenWidth:width\n                                      height:height\n                                mutableState:mutableState];\n        [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionColumns: @(width),\n                                                        iTermVariableKeySessionRows: @(height) }];\n    }];\n\n    [_textview setDataSource:_screen];\n    [_textview setDelegate:self];\n    // useTransparency may have just changed.\n    [self invalidateBlend];\n    [_view.scrollview setDocumentView:_wrapper];\n    [_wrapper release];\n    [_view.scrollview setDocumentCursor:[iTermMouseCursor mouseCursorOfType:iTermMouseCursorTypeIBeam]];\n    [_view.scrollview setLineScroll:[_textview lineHeight]];\n    [_view.scrollview setPageScroll:2 * [_textview lineHeight]];\n    [_view.scrollview setHasVerticalScroller:[parent scrollbarShouldBeVisible]];\n\n    _antiIdleCode = 0;\n    [_antiIdleTimer invalidate];\n    _antiIdleTimer = nil;\n    _newOutput = NO;\n    [_view updateScrollViewFrame];\n    [self useTransparencyDidChange];\n\n    [self updateMetalDriver];\n\n    return YES;\n}\n\n- (BOOL)tryToAttachToServerWithProcessId:(pid_t)serverPid\n                                     tty:(NSString *)tty {\n    if (![iTermAdvancedSettingsModel runJobsInServers]) {\n        DLog(@\"Failing to attach because run jobs in servers is off\");\n        return NO;\n    }\n    DLog(@\"Try to attach...\");\n    if ([_shell tryToAttachToServerWithProcessId:serverPid tty:tty]) {\n        DLog(@\"Success, attached.\");\n        return YES;\n    } else {\n        DLog(@\"Failed to attach\");\n        return NO;\n    }\n}\n\n- (BOOL)tryToAttachToMultiserverWithRestorationIdentifier:(NSDictionary *)restorationIdentifier {\n    const iTermJobManagerAttachResults results = [_shell tryToAttachToMultiserverWithRestorationIdentifier:restorationIdentifier];\n    if (results & iTermJobManagerAttachResultsRegistered) {\n        DLog(@\"Registered\");\n    } else {\n        DLog(@\"Attached to multiserver. Not registered.\");\n    }\n    if (results & iTermJobManagerAttachResultsAttached) {\n        DLog(@\"Success, attached.\");\n        return YES;\n    } else {\n        DLog(@\"Failed to attach\");\n        return NO;\n    }\n}\n\n// Note: this async code path is taken by orphan adoption.\n- (void)attachToServer:(iTermGeneralServerConnection)serverConnection\n            completion:(void (^)(void))completion {\n    if ([iTermAdvancedSettingsModel runJobsInServers]) {\n        DLog(@\"Attaching to a server...\");\n        [_shell attachToServer:serverConnection completion:^(iTermJobManagerAttachResults results) {\n            if (!(results & iTermJobManagerAttachResultsAttached)) {\n                [self brokenPipe];\n            }\n            [self->_shell.winSizeController setGridSize:_screen.size\n                                               viewSize:_screen.viewSize\n                                            scaleFactor:self.backingScaleFactor];\n            if (_jiggleUponAttach) {\n                [_shell.winSizeController forceJiggle];\n            }\n            completion();\n        }];\n    } else {\n        DLog(@\"Can't attach to a server when runJobsInServers is off.\");\n    }\n}\n\n- (void)didChangeScreen:(CGFloat)scaleFactor {\n    [self->_shell.winSizeController setGridSize:_screen.currentGrid.size\n                                       viewSize:_screen.viewSize\n                                    scaleFactor:scaleFactor];\n}\n\n- (void)setSize:(VT100GridSize)size {\n    ITBetaAssert(size.width > 0, @\"Nonpositive width %d\", size.width);\n    ITBetaAssert(size.height > 0, @\"Nonpositive height %d\", size.height);\n    if (size.width <= 0) {\n        size.width = 1;\n    }\n    if (size.height <= 0) {\n        size.height = 1;\n    }\n    _savedGridSize = size;\n    self.lastResize = [NSDate timeIntervalSinceReferenceDate];\n    DLog(@\"Set session %@ to %@\", self, VT100GridSizeDescription(size));\n    DLog(@\"Before, range of visible lines is %@\", VT100GridRangeDescription(_textview.rangeOfVisibleLines));\n\n    [_screen setSize:size];\n    // Sync so that we'll have an updated model as we go forward so that, for example, tail find\n    // will be sane.\n    [self sync];\n    if (!self.delegate || [self.delegate sessionShouldSendWindowSizeIOCTL:self]) {\n        [_shell.winSizeController setGridSize:size\n                                     viewSize:_screen.viewSize\n                                  scaleFactor:self.backingScaleFactor];\n    }\n    [_textview clearHighlights:NO];\n    [_textview updatePortholeFrames];\n    [[_delegate realParentWindow] invalidateRestorableState];\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf startTailFindIfVisible];\n    });\n    [self updateMetalDriver];\n    [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionColumns: @(_screen.width),\n                                                    iTermVariableKeySessionRows: @(_screen.height) }];\n}\n\n- (void)startTailFindIfVisible {\n    if (!_tailFindTimer &&\n        [_delegate sessionBelongsToVisibleTab]) {\n        [self beginContinuousTailFind];\n    }\n}\n\n- (Profile *)profileForSplit {\n    if ([iTermAdvancedSettingsModel useDivorcedProfileToSplit]) {\n        if (self.isDivorced) {\n            // NOTE: This counts on splitVertically:before:profile:targetSession: rewriting the GUID.\n            return self.profile;\n        }\n    }\n\n    // Get the profile this session was originally created with. But look it up from its GUID because\n    // it might have changed since it was copied into originalProfile when the profile was\n    // first created.\n    Profile *result = nil;\n    Profile *originalProfile = [self originalProfile];\n    if (originalProfile && originalProfile[KEY_GUID]) {\n        result = [[ProfileModel sharedInstance] bookmarkWithGuid:originalProfile[KEY_GUID]];\n    }\n\n    // If that fails, use the current profile.\n    if (!result) {\n        result = self.profile;\n    }\n\n    // I don't think that'll ever fail, but to be safe try using the original profile.\n    if (!result) {\n        result = originalProfile;\n    }\n\n    // I really don't think this'll ever happen, but there's always a default profile to fall back\n    // on.\n    if (!result) {\n        result = [[ProfileModel sharedInstance] defaultBookmark];\n    }\n\n    if (_conductor) {\n        result = [result dictionaryByMergingDictionary:@{\n            KEY_SSH_CONFIG: @{},\n            KEY_CUSTOM_COMMAND: kProfilePreferenceCommandTypeSSHValue,\n            KEY_COMMAND_LINE: _conductor.sshIdentity.commandLine }];\n    }\n    return result;\n}\n\n- (SSHIdentity *)sshIdentity {\n    return _conductor.sshIdentity;\n}\n\n- (NSArray<iTermSSHReconnectionInfo *> *)sshCommandLineSequence {\n    assert(_conductor);\n    NSMutableArray<iTermSSHReconnectionInfo *> *sequence = [NSMutableArray array];\n    iTermConductor *current = _conductor;\n    [sequence insertObject:current.reconnectionInfo atIndex:0];\n    while (current.parent) {\n        current = current.parent;\n        [sequence insertObject:current.reconnectionInfo atIndex:0];\n    }\n    return sequence;\n}\n\n- (void)setSplitSelectionMode:(SplitSelectionMode)mode move:(BOOL)move {\n    // TODO: It would be nice not to have to pass the session into the view. I\n    // can (kind of) live with it because the view just passes it through\n    // without knowing anything about it.\n    [[self view] setSplitSelectionMode:mode move:move session:self];\n}\n\n- (int)overUnder:(int)proposedSize inVerticalDimension:(BOOL)vertically {\n    int result = proposedSize;\n    if (vertically) {\n        if ([_view showTitle]) {\n            result -= [SessionView titleHeight];\n        }\n        if (_view.showBottomStatusBar) {\n            result -= iTermGetStatusBarHeight();\n        }\n        result -= [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins] * 2;\n        int iLineHeight = [_textview lineHeight];\n        if (iLineHeight == 0) {\n            return 0;\n        }\n        result %= iLineHeight;\n        if (result > iLineHeight / 2) {\n            result -= iLineHeight;\n        }\n        return result;\n    } else {\n        result -= [iTermPreferences intForKey:kPreferenceKeySideMargins] * 2;\n        int iCharWidth = [_textview charWidth];\n        if (iCharWidth == 0) {\n            return 0;\n        }\n        result %= iCharWidth;\n        if (result > iCharWidth / 2) {\n            result -= iCharWidth;\n        }\n    }\n    return result;\n}\n\n- (id<ProcessInfoProvider>)processInfoProvider {\n    if (!_conductor.framing) {\n        return [iTermProcessCache sharedInstance];\n    }\n    return _conductor.processInfoProvider;\n}\n\n- (id<SessionProcessInfoProvider>)sessionProcessInfoProvider {\n    if (!_conductor.framing) {\n        return _shell;\n    }\n    return _conductor.processInfoProvider;\n}\n\n- (NSArray<iTermProcessInfo *> *)processInfoForShellAndDescendants {\n    NSMutableArray<iTermProcessInfo *> *result = [NSMutableArray array];\n    if (_conductor) {\n        [result addObjectsFromArray:_conductor.transitiveProcesses];\n    }\n    pid_t thePid = [_shell pid];\n\n    [[iTermProcessCache sharedInstance] updateSynchronously];\n    iTermProcessInfo *info = [[iTermProcessCache sharedInstance] processInfoForPid:thePid];\n    if (!info) {\n        return result;\n    }\n\n    NSInteger levelsToSkip = 0;\n    if ([info.name isEqualToString:@\"login\"]) {\n        levelsToSkip++;\n    }\n\n    NSArray<iTermProcessInfo *> *allInfos = [info descendantsSkippingLevels:levelsToSkip];\n    [result addObjectsFromArray:allInfos];\n    return result;\n}\n\n- (NSArray<iTermTuple<NSString *, NSString *> *> *)childJobNameTuples {\n    NSArray<iTermProcessInfo *> *allInfos = [self processInfoForShellAndDescendants];\n    return [allInfos mapWithBlock:^id(iTermProcessInfo *info) {\n        if (!info.name) {\n            return nil;\n        }\n        return [iTermTuple tupleWithObject:info.name\n                                 andObject:info.argv0 ?: info.name];\n    }];\n}\n\n- (iTermPromptOnCloseReason *)promptOnCloseReason {\n    DLog(@\"entered\");\n    if (_exited) {\n        return [iTermPromptOnCloseReason noReason];\n    }\n    switch ([[_profile objectForKey:KEY_PROMPT_CLOSE] intValue]) {\n        case PROMPT_ALWAYS:\n            DLog(@\"prompt always\");\n            return [iTermPromptOnCloseReason profileAlwaysPrompts:_profile];\n\n        case PROMPT_NEVER:\n            DLog(@\"prompt never\");\n            return [iTermPromptOnCloseReason noReason];\n\n        case PROMPT_EX_JOBS: {\n            DLog(@\"Prompt ex jobs\");\n            if (self.isTmuxClient) {\n                DLog(@\"is tmux client\");\n                return [iTermPromptOnCloseReason tmuxClientsAlwaysPromptBecauseJobsAreNotExposed];\n            }\n            NSMutableArray<NSString *> *blockingJobs = [NSMutableArray array];\n            NSArray *jobsThatDontRequirePrompting = [_profile objectForKey:KEY_JOBS];\n            DLog(@\"jobs that don't require prompting: %@\", jobsThatDontRequirePrompting);\n            for (iTermTuple<NSString *, NSString *> *childNameTuple in [self childJobNameTuples]) {\n                DLog(@\"Check child %@\", childNameTuple);\n                if ([jobsThatDontRequirePrompting indexOfObject:childNameTuple.firstObject] == NSNotFound &&\n                    [jobsThatDontRequirePrompting indexOfObject:childNameTuple.secondObject] == NSNotFound) {\n                    DLog(@\"    not on the ignore list\");\n                    // This job is not in the ignore list.\n                    [blockingJobs addObject:childNameTuple.secondObject.lastPathComponent];\n                }\n            }\n            if (blockingJobs.count > 0) {\n                DLog(@\"Blocked by jobs: %@\", blockingJobs);\n                return [iTermPromptOnCloseReason profile:_profile blockedByJobs:blockingJobs];\n            } else {\n                // All jobs were in the ignore list.\n                return [iTermPromptOnCloseReason noReason];\n            }\n        }\n    }\n\n    // This shouldn't happen\n    return [iTermPromptOnCloseReason profileAlwaysPrompts:_profile];\n}\n\n- (NSSet<NSString *> *)jobsToIgnore {\n    NSArray<NSString *> *builtInJobsToIgnore = @[ @\"login\", @\"iTerm2\", @\"ShellLauncher\" ];\n    return [NSSet setWithArray:[[_profile objectForKey:KEY_JOBS] ?: @[] arrayByAddingObjectsFromArray:builtInJobsToIgnore]];\n}\n\n// A trivial process is one that's always running, like the user's shell. This\n// is used to decide if there should be a \"document edited\" indicator in the\n// window's close button.\n- (BOOL)processIsTrivial:(iTermProcessInfo *)info {\n    NSSet<NSString *> *ignoredNames = [self jobsToIgnore];\n    if ([ignoredNames containsObject:info.name]) {\n        return YES;\n    }\n    if ([info.commandLine hasPrefix:@\"-\"]) {\n        return YES;\n    }\n    if (!self.program) {\n        return NO;\n    }\n    NSString *const programType = [self programType];\n    if ([programType isEqualToString:kProgramTypeShellLauncher] ||\n        [programType isEqualToString:kProgramTypeCustomShell]) {\n        return info.parentProcessID == _shell.pid;\n    } else if ([programType isEqualToString:kProgramTypeCommand]) {\n        return info.processID == _shell.pid;\n    }\n    return NO;\n}\n\n- (BOOL)hasNontrivialJob {\n    DLog(@\"Checking for a nontrivial job...\");\n    pid_t thePid = [_shell pid];\n    iTermProcessInfo *rootInfo = [self.processInfoProvider processInfoForPid:thePid];\n    if (!rootInfo) {\n        return NO;\n    }\n    // ShellLauncher --launch_shell could be a child job temporarily.\n    NSSet<NSString *> *jobToIgnore = [self jobsToIgnore];\n    DLog(@\"Ignoring %@\", jobToIgnore);\n    __block BOOL result = NO;\n    [rootInfo enumerateTree:^(iTermProcessInfo *info, BOOL *stop) {\n        if ([self processIsTrivial:info]) {\n            return;\n        }\n        if ([jobToIgnore containsObject:info.name]) {\n            return;\n        }\n        DLog(@\"Process with name %@ and command line %@ is nontrivial\", info.name, info.commandLine);\n        result = YES;\n        *stop = YES;\n    }];\n    DLog(@\"Result is %@\", @(result));\n    return result;\n}\n\n- (BOOL)shouldSetCtype {\n    return ![iTermAdvancedSettingsModel doNotSetCtype];\n}\n\n- (NSString *)sessionId {\n    return [NSString stringWithFormat:@\"w%dt%dp%lu:%@\",\n            [[_delegate realParentWindow] number],\n            _delegate.tabNumberForItermSessionId,\n            [_delegate sessionPaneNumber:self],\n            self.guid];\n}\n\n- (void)didMoveSession {\n    // TODO: Is it really desirable to update this? It'll get out of sync with the environment variable & autolog filename.\n    [self setTermIDIfPossible];\n}\n\n- (void)didInitializeSessionWithName:(NSString *)name {\n    [self.variablesScope setValue:name forVariableNamed:iTermVariableKeySessionAutoNameFormat];\n}\n\n- (void)profileNameDidChangeTo:(NSString *)name {\n    NSString *autoNameFormat = [self.variablesScope valueForVariableName:iTermVariableKeySessionAutoNameFormat] ?: name;\n    const BOOL isChangeToLocalName = (self.isDivorced &&\n                                      [_overriddenFields containsObject:KEY_NAME]);\n    const BOOL haveAutoNameFormatOverride = ([self.variablesScope valueForVariableName:iTermVariableKeySessionIconName] != nil ||\n                                             [self.variablesScope valueForVariableName:iTermVariableKeySessionTriggerName] != nil);\n    if (isChangeToLocalName || !haveAutoNameFormatOverride) {\n        // Profile name changed, local name not overridden, and no icon/trigger name to take precedence.\n        autoNameFormat = name;\n    }\n\n    NSString *profileName = nil;\n    if (![_overriddenFields containsObject:KEY_NAME]) {\n        profileName = _originalProfile[KEY_NAME];\n    } else {\n        profileName = [[ProfileModel sharedInstance] bookmarkWithGuid:_profile[KEY_ORIGINAL_GUID]][KEY_NAME];\n        if (!profileName) {\n            // Not sure how this would happen\n            profileName = [self.variablesScope valueForVariableName:iTermVariableKeySessionProfileName];\n        }\n    }\n    [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionAutoNameFormat: autoNameFormat ?: [NSNull null],\n                                                    iTermVariableKeySessionProfileName: profileName ?: [NSNull null] }];\n}\n\n- (void)profileDidChangeToProfileWithName:(NSString *)name {\n    [self profileNameDidChangeTo:name];\n}\n\n- (void)computeArgvForCommand:(NSString *)command\n                substitutions:(NSDictionary *)substitutions\n                   completion:(void (^)(NSArray<NSString *> *))completion {\n    NSString *program = [command stringByPerformingSubstitutions:substitutions];\n    NSArray *components = [program componentsInShellCommand];\n    NSArray *arguments;\n    if (components.count > 0) {\n        program = components[0];\n        arguments = [components subarrayWithRange:NSMakeRange(1, components.count - 1)];\n    } else {\n        arguments = @[];\n    }\n    completion([@[ program ] arrayByAddingObjectsFromArray:arguments ]);\n}\n\n- (NSDictionary *)environmentForNewJobFromEnvironment:(NSDictionary *)environment\n                                        substitutions:(NSDictionary *)substitutions {\n    DLog(@\"environmentForNewJobFromEnvironment:%@ substitutions:%@\",\n         environment, substitutions);\n    NSMutableDictionary *env = environment ? [[environment mutableCopy] autorelease] : [NSMutableDictionary dictionary];\n    if (env[TERM_ENVNAME] == nil) {\n        env[TERM_ENVNAME] = _termVariable;\n    }\n    if (env[COLORFGBG_ENVNAME] == nil && _colorFgBgVariable != nil) {\n        env[COLORFGBG_ENVNAME] = _colorFgBgVariable;\n    }\n    if ([iTermAdvancedSettingsModel setCookie]) {\n        self.cookie = [[iTermWebSocketCookieJar sharedInstance] randomStringForCookie];\n        env[@\"ITERM2_COOKIE\"] = self.cookie;\n    }\n\n    if ([iTermAdvancedSettingsModel addUtilitiesToPATH]) {\n        NSString *path = env[PATH_ENVNAME] ?: [NSString stringWithUTF8String:_PATH_DEFPATH];\n        NSArray *pathComponents = [path componentsSeparatedByString:@\":\"] ?: @[];\n        pathComponents = [pathComponents arrayByAddingObject:[iTermPathToSSH() stringByDeletingLastPathComponent]];\n        path = [pathComponents componentsJoinedByString:@\":\"];\n        env[PATH_ENVNAME] = path;\n    }\n\n    DLog(@\"Begin locale logic\");\n    switch ([iTermProfilePreferences unsignedIntegerForKey:KEY_SET_LOCALE_VARS inProfile:_profile]) {\n        case iTermSetLocalVarsModeDoNotSet:\n            break;\n        case iTermSetLocalVarsModeCustom: {\n            NSString *lang = [iTermProfilePreferences stringForKey:KEY_CUSTOM_LOCALE inProfile:_profile];\n            if (lang.length) {\n                env[@\"LANG\"] = lang;\n            }\n            break;\n        }\n        case iTermSetLocalVarsModeSetAutomatically: {\n            DLog(@\"Setting locale vars...\");\n\n            iTermLocaleGuesser *localeGuesser = [[[iTermLocaleGuesser alloc] initWithEncoding:self.encoding] autorelease];\n            NSDictionary *localeVars = [localeGuesser dictionaryWithLANG];\n            DLog(@\"localeVars=%@\", localeVars);\n            if (!localeVars) {\n                // Failed to guess.\n                iTermLocalePrompt *prompt = [[[iTermLocalePrompt alloc] init] autorelease];\n                if (self.originalProfile.profileIsDynamic) {\n                    DLog(@\"Disable remember\");\n                    prompt.allowRemember = NO;\n                }\n                localeVars = [prompt requestLocaleFromUserForProfile:self.originalProfile[KEY_NAME] ?: @\"(Unnamed profile)\"\n                                                            inWindow:self.view.window];\n                DLog(@\"updated localeVars=%@\", localeVars);\n                NSString *lang = localeVars[@\"LANG\"];\n                if (prompt.remember && localeVars != nil && lang != nil) {\n                    DLog(@\"Save\");\n                    // User chose a locale and wants us to keep using it.\n                    [iTermProfilePreferences setObject:lang\n                                                forKey:KEY_CUSTOM_LOCALE\n                                             inProfile:self.originalProfile\n                                                 model:[self profileModel]];\n                    [iTermProfilePreferences setUnsignedInteger:iTermSetLocalVarsModeCustom\n                                                         forKey:KEY_SET_LOCALE_VARS\n                                                      inProfile:self.originalProfile\n                                                          model:self.profileModel];\n                    [[NSNotificationCenter defaultCenter] postNotificationName:kSessionProfileDidChange\n                                                                        object:self.originalProfile[KEY_GUID]];\n                }\n            }\n            if (!localeVars) {\n                DLog(@\"Using LC_CTYPE\");\n                localeVars = [localeGuesser dictionaryWithLC_CTYPE];\n            }\n            if (localeVars) {\n                DLog(@\"Merge %@\", localeVars);\n                [env it_mergeFrom:localeVars];\n            }\n        }\n    }\n    if ([iTermAdvancedSettingsModel shouldSetLCTerminal]) {\n        env[@\"LC_TERMINAL\"] = @\"iTerm2\";\n        env[@\"LC_TERMINAL_VERSION\"] = [[[NSBundle mainBundle] infoDictionary] objectForKey:@\"CFBundleShortVersionString\"];\n    }\n    if (env[PWD_ENVNAME] == nil && _sshState == iTermSSHStateNone) {\n        // Set \"PWD\"\n        env[PWD_ENVNAME] = [PWD_ENVVALUE stringByExpandingTildeInPath];\n        DLog(@\"env[%@] was nil. Set it to home directory: %@\", PWD_ENVNAME, env[PWD_ENVNAME]);\n    }\n\n    // Remove trailing slashes, unless the path is just \"/\"\n    NSString *trimmed = [env[PWD_ENVNAME] stringByTrimmingTrailingCharactersFromCharacterSet:[NSCharacterSet characterSetWithCharactersInString:@\"/\"]];\n    DLog(@\"Trimmed pwd %@ is %@\", env[PWD_ENVNAME], trimmed);\n    if (trimmed.length == 0 && _sshState == iTermSSHStateNone) {\n        trimmed = @\"/\";\n    }\n    DLog(@\"Set env[PWD] to trimmed value %@\", trimmed);\n    env[PWD_ENVNAME] = trimmed;\n\n    NSString *itermId = [self sessionId];\n    env[@\"ITERM_SESSION_ID\"] = itermId;\n    env[@\"TERM_PROGRAM_VERSION\"] = [[[NSBundle mainBundle] infoDictionary] objectForKey:@\"CFBundleShortVersionString\"];\n    env[@\"TERM_SESSION_ID\"] = itermId;\n    env[@\"TERM_PROGRAM\"] = @\"iTerm.app\";\n    env[@\"COLORTERM\"] = @\"truecolor\";\n    if ([iTermAdvancedSettingsModel shouldSetTerminfoDirs]) {\n        env[@\"TERMINFO_DIRS\"] = [@[self.customTerminfoDir, @\"/usr/share/terminfo\"] componentsJoinedByString:@\":\"];\n    }\n    if (_profile[KEY_NAME]) {\n        env[@\"ITERM_PROFILE\"] = [_profile[KEY_NAME] stringByPerformingSubstitutions:substitutions];\n    }\n    return env;\n}\n\n- (NSString *)customTerminfoDir {\n    return [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@\"terminfo\"];\n}\n\n- (void)arrangementWithName:(NSString *)arrangementName hasBadPWD:(NSString *)pwd {\n    if (![[iTermController sharedInstance] arrangementWithName:arrangementName\n                                            hasSessionWithGUID:_arrangementGUID\n                                                           pwd:pwd]) {\n        return;\n    }\n\n    [self.naggingController arrangementWithName:arrangementName\n                                  hasInvalidPWD:pwd\n                             forSessionWithGuid:_arrangementGUID];\n}\n\n- (void)startProgram:(NSString *)command\n                 ssh:(BOOL)ssh\n         environment:(NSDictionary *)environment\n         customShell:(NSString *)customShell\n              isUTF8:(BOOL)isUTF8\n       substitutions:(NSDictionary *)substitutions\n         arrangement:(NSString *)arrangementName\n     fromArrangement:(BOOL)fromArrangement\n          completion:(void (^)(BOOL))completion {\n    DLog(@\"startProgram:%@ ssh:%@ environment:%@ customShell:%@ isUTF8:%@ substitutions:%@ arrangementName:%@ fromArrangement:%@, self=%@\",\n         command,\n         @(ssh),\n         environment,\n         customShell,\n         @(isUTF8),\n         substitutions,\n         arrangementName,\n         @(fromArrangement),\n         self);\n    _temporarilySuspendOffscreenMarkAlerts = fromArrangement;\n    self.program = command;\n    self.customShell = customShell;\n    self.environment = environment ?: @{};\n    self.isUTF8 = isUTF8;\n    self.substitutions = substitutions ?: @{};\n    _sshState = ssh ? iTermSSHStateProfile : iTermSSHStateNone;\n    [self computeArgvForCommand:command substitutions:substitutions completion:^(NSArray<NSString *> *argv) {\n        DLog(@\"argv=%@\", argv);\n        NSDictionary *env = [self environmentForNewJobFromEnvironment:environment ?: @{} substitutions:substitutions];\n        [self fetchAutoLogFilenameWithCompletion:^(NSString * _Nonnull autoLogFilename) {\n            [_logging stop];\n            [_logging autorelease];\n            _logging = nil;\n            [[self loggingHelper] setPath:autoLogFilename\n                                  enabled:autoLogFilename != nil\n                                    style:iTermLoggingStyleFromUserDefaultsValue([iTermProfilePreferences unsignedIntegerForKey:KEY_LOGGING_STYLE\n                                                                                                                      inProfile:self.profile])\n                        asciicastMetadata:[self asciicastMetadata]\n                                   append:nil];\n            if (env[PWD_ENVNAME] && arrangementName && _arrangementGUID) {\n                __weak __typeof(self) weakSelf = self;\n                [[iTermSlowOperationGateway sharedInstance] checkIfDirectoryExists:env[PWD_ENVNAME]\n                                                                        completion:^(BOOL exists) {\n                    if (exists) {\n                        return;\n                    }\n                    [weakSelf arrangementWithName:arrangementName\n                                        hasBadPWD:env[PWD_ENVNAME]];\n                }];\n            }\n            [self injectShellIntegrationWithEnvironment:env\n                                                   args:argv\n                                             completion:^(NSDictionary<NSString *, NSString *> *env,\n                                                          NSArray<NSString *> *argv) {\n                [_shell launchWithPath:argv[0]\n                             arguments:[argv subarrayFromIndex:1]\n                           environment:env\n                           customShell:customShell\n                              gridSize:_screen.size\n                              viewSize:_screen.viewSize\n                      maybeScaleFactor:_textview.window.backingScaleFactor\n                                isUTF8:isUTF8\n                            completion:^{\n                    [self sendInitialText];\n                    if (completion) {\n                        completion(YES);\n                    }\n                }];\n            }];\n        }];\n    }];\n}\n\n- (void)injectShellIntegrationWithEnvironment:(NSDictionary<NSString *, NSString *> *)env\n                                         args:(NSArray<NSString *> *)argv\n                                   completion:(void (^)(NSDictionary<NSString *, NSString *> *,\n                                                        NSArray<NSString *> *))completion {\n    if (![iTermProfilePreferences boolForKey:KEY_LOAD_SHELL_INTEGRATION_AUTOMATICALLY inProfile:self.profile]) {\n        completion(env, argv);\n        return;\n    }\n    ShellIntegrationInjector *injector = [ShellIntegrationInjector instance];\n    NSString *dir = NSBundle.shellIntegrationDirectory;\n    if (!dir) {\n        completion(env, argv);\n        return;\n    }\n    [injector modifyShellEnvironmentWithShellIntegrationDir:dir\n                                                        env:env\n                                                       argv:argv\n                                                 completion:completion];\n}\n\n- (void)setParentScope:(iTermVariableScope *)parentScope {\n    iTermVariableScope *scope = self.variablesScope;\n    assert(parentScope != scope);  // I'm almost sure this is impossible because how could you be your own parent?\n\n    // Remove existing variable (this is just paranoia! it shouldn't do anything)\n    [self.variablesScope setValue:nil forVariableNamed:iTermVariableKeySessionParent];\n\n    // Remove existing frame\n    [scope removeFrameWithName:iTermVariableKeySessionParent];\n    __block iTermVariables *variables = nil;\n    // Find root frame in parent and add it it as a frame to my scope\n    [parentScope.frames enumerateObjectsUsingBlock:^(iTermTuple<NSString *,iTermVariables *> * _Nonnull tuple, NSUInteger idx, BOOL * _Nonnull stop) {\n        if (tuple.firstObject) {\n            return;\n        }\n        variables = tuple.secondObject;\n        [scope addVariables:tuple.secondObject toScopeNamed:iTermVariableKeySessionParent];\n        *stop = YES;\n    }];\n\n    // Find non-root frames (e.g., tab) and add their variables as nonterminals to parentSession (becoming, e.g., parentSession.tab)\n    [parentScope.frames enumerateObjectsUsingBlock:^(iTermTuple<NSString *,iTermVariables *> * _Nonnull tuple, NSUInteger idx, BOOL * _Nonnull stop) {\n        if (!tuple.firstObject) {\n            return;\n        }\n        [variables setValue:tuple.secondObject forVariableNamed:tuple.firstObject];\n    }];\n}\n\n- (void)sendInitialText {\n    NSString *initialText = _profile[KEY_INITIAL_TEXT];\n    if (![initialText length]) {\n        return;\n    }\n    DLog(@\"Evaluate initial text %@\", initialText);\n\n    iTermExpressionEvaluator *evaluator =\n    [[[iTermExpressionEvaluator alloc] initWithStrictInterpolatedString:initialText\n                                                                  scope:self.variablesScope] autorelease];\n    [evaluator evaluateWithTimeout:5 completion:^(iTermExpressionEvaluator * _Nonnull evaluator) {\n        NSString *string = [NSString castFrom:evaluator.value];\n        if (!string) {\n            DLog(@\"Evaluation of %@ returned %@\", initialText, evaluator.value);\n            return;\n        }\n        DLog(@\"Write initial text %@\", string);\n        [self writeTaskNoBroadcast:string];\n        [self writeTaskNoBroadcast:@\"\\n\"];\n    }];\n}\n\n- (void)launchProfileInCurrentTerminal:(Profile *)profile\n                               withURL:(NSString *)url {\n    PseudoTerminal *term = [[iTermController sharedInstance] currentTerminal];\n    [iTermSessionLauncher launchBookmark:profile\n                              inTerminal:term\n                                 withURL:url\n                        hotkeyWindowType:iTermHotkeyWindowTypeNone\n                                 makeKey:NO\n                             canActivate:NO\n                      respectTabbingMode:NO\n                                   index:nil\n                                 command:nil\n                             makeSession:nil\n                          didMakeSession:nil\n                              completion:nil];\n}\n\n- (void)selectPaneLeftInCurrentTerminal {\n    [[[iTermController sharedInstance] currentTerminal] selectPaneLeft:nil];\n}\n\n- (void)selectPaneRightInCurrentTerminal {\n    [[[iTermController sharedInstance] currentTerminal] selectPaneRight:nil];\n}\n\n- (void)selectPaneAboveInCurrentTerminal {\n    [[[iTermController sharedInstance] currentTerminal] selectPaneUp:nil];\n}\n\n- (void)selectPaneBelowInCurrentTerminal {\n    [[[iTermController sharedInstance] currentTerminal] selectPaneDown:nil];\n}\n\n- (void)_maybeWarnAboutShortLivedSessions {\n    if ([iTermApplication.sharedApplication delegate].isAppleScriptTestApp) {\n        // The applescript test driver doesn't care about short-lived sessions.\n        return;\n    }\n    if (self.isSingleUseSession) {\n        return;\n    }\n    if (_tmuxMode == TMUX_CLIENT && (_tmuxController.detached || _tmuxController.detaching)) {\n        return;\n    }\n    if ([[NSDate date] timeIntervalSinceDate:_creationDate] < [iTermAdvancedSettingsModel shortLivedSessionDuration]) {\n        NSString* theName = [_profile objectForKey:KEY_NAME];\n        NSString *guid = _profile[KEY_GUID];\n        if (_originalProfile && [_originalProfile[KEY_GUID] length]) {\n            // Divorced sessions should use the original session's GUID to determine\n            // if a warning is appropriate.\n            guid = _originalProfile[KEY_GUID];\n        }\n        if ([self.profile[KEY_CUSTOM_COMMAND] isEqual:kProfilePreferenceCommandTypeLoginShellValue]) {\n            // Not a custom command. Does the user's shell not exist maybe?\n            NSString *shell = [iTermOpenDirectory userShell];\n            Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:self.profile[KEY_GUID]];\n            if (!self.isDivorced &&\n                shell &&\n                profile != nil &&\n                !profile.profileIsDynamic &&\n                ![[NSFileManager defaultManager] fileExistsAtPath:shell]) {\n                NSString *theKey = [NSString stringWithFormat:@\"ShellDoesNotExist_%@\", guid];\n                NSString *theTitle = [NSString stringWithFormat:\n                                      @\"The shell for this account, \u201c%@\u201d, does not exist. Change the profile to use /bin/zsh instead?\",\n                                      shell];\n                const iTermWarningSelection selection =\n                [iTermWarning showWarningWithTitle:theTitle\n                                           actions:@[ @\"OK\", @\"Cancel\" ]\n                                        identifier:theKey\n                                       silenceable:kiTermWarningTypePermanentlySilenceable\n                                            window:self.view.window];\n                if (selection == kiTermWarningSelection0) {\n                    NSDictionary *change = @{\n                        KEY_CUSTOM_COMMAND: kProfilePreferenceCommandTypeCustomShellValue,\n                        KEY_COMMAND_LINE: @\"/bin/zsh\"\n                    };\n                    [[ProfileModel sharedInstance] setObjectsFromDictionary:change\n                                                                  inProfile:profile];\n                    [[ProfileModel sharedInstance] flush];\n                    [[NSNotificationCenter defaultCenter] postNotificationName:kReloadAllProfiles\n                                                                        object:nil];\n                }\n                return;\n            }\n        }\n        NSString *theKey = [iTermPreferences warningIdentifierForNeverWarnAboutShortLivedSessions:guid];\n        NSString *theTitle = [NSString stringWithFormat:\n                              @\"A session ended very soon after starting. Check that the command \"\n                              @\"in profile \\\"%@\\\" is correct.\",\n                              theName];\n        [iTermWarning showWarningWithTitle:theTitle\n                                   actions:@[ @\"OK\" ]\n                                identifier:theKey\n                               silenceable:kiTermWarningTypePermanentlySilenceable\n                                    window:self.view.window];\n    }\n}\n\n- (iTermRestorableSession *)restorableSession {\n    iTermRestorableSession *restorableSession = [[[iTermRestorableSession alloc] init] autorelease];\n    [_delegate addSession:self toRestorableSession:restorableSession];\n    return restorableSession;\n}\n\n- (void)restartSession {\n    DLog(@\"Restart session %@\", self);\n    assert(self.isRestartable);\n    [_naggingController willRecycleSession];\n    if (_exited) {\n        [self replaceTerminatedShellWithNewInstance];\n    } else {\n        _shouldRestart = YES;\n        // We don't use a regular (SIGHUP) kill here because we must ensure\n        // servers get killed on user-initiated quit. If we just HUP the shell\n        // then the server won't notice until it becomes attached as an orphan\n        // on the next launch. See issue 6369.\n        [_shell killWithMode:iTermJobManagerKillingModeForce];\n    }\n}\n\n// Terminate a replay session but not the live session\n- (void)softTerminate {\n    _liveSession = nil;\n    [self terminate];\n}\n\n- (void)close {\n    [self.delegate sessionClose:self];\n}\n\n// Request that the session close. It may or may not be undoable. Only undoable terminations support\n// \"restart\", which is done by first calling revive and then replaceTerminatedShellWithNewInstance.\n- (void)terminate {\n    DLog(@\"terminate called from %@\", [NSThread callStackSymbols]);\n    if ([[self textview] isFindingCursor]) {\n        [[self textview] endFindCursor];\n    }\n    if (_exited && !_shortLivedSingleUse) {\n        [self _maybeWarnAboutShortLivedSessions];\n    }\n    if (self.tmuxMode == TMUX_CLIENT) {\n        assert([_delegate tmuxWindow] >= 0);\n        [_tmuxController deregisterWindow:[_delegate tmuxWindow]\n                               windowPane:self.tmuxPane\n                                  session:self];\n        // This call to fitLayoutToWindows is necessary to handle the case where\n        // a small window closes and leaves behind a larger (e.g., fullscreen)\n        // window. We want to set the client size to that of the smallest\n        // remaining window.\n        int n = [[_delegate sessions] count];\n        if ([[_delegate sessions] indexOfObjectIdenticalTo:self] != NSNotFound) {\n            n--;\n        }\n        if (n == 0) {\n            // The last session in this tab closed so check if the client has\n            // changed size\n            DLog(@\"Last session in tab closed. Check if the client has changed size\");\n            [_tmuxController fitLayoutToWindows];\n        }\n        _tmuxStatusBarMonitor.active = NO;\n        [_tmuxStatusBarMonitor release];\n        _tmuxStatusBarMonitor = nil;\n\n        [self uninstallTmuxTitleMonitor];\n        [self uninstallTmuxForegroundJobMonitor];\n    } else if (self.tmuxMode == TMUX_GATEWAY) {\n        [_tmuxController detach];\n        [_tmuxGateway release];\n        _tmuxGateway = nil;\n    }\n    BOOL undoable = (![self isTmuxClient] &&\n                     !_shouldRestart &&\n                     !_synthetic &&\n                     ![[iTermController sharedInstance] applicationIsQuitting]);\n    self.tmuxMode = TMUX_NONE;\n    [_tmuxController release];\n    _hideAfterTmuxWindowOpens = NO;\n    _tmuxController = nil;\n    [self.variablesScope setValue:nil forVariableNamed:iTermVariableKeySessionTmuxClientName];\n    [self.variablesScope setValue:nil forVariableNamed:iTermVariableKeySessionTmuxPaneTitle];\n\n    // The source pane may have just exited. Dogs and cats living together!\n    // Mass hysteria!\n    [[MovePaneController sharedInstance] exitMovePaneMode];\n\n    // deregister from the notification center\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n\n    if (_liveSession) {\n        [_liveSession terminate];\n    }\n\n    DLog(@\"  terminate: exited = YES\");\n    [self setExited:YES];\n    [_view retain];  // hardstop and revive will release this.\n    if (undoable) {\n        [self makeTerminationUndoable];\n    } else {\n        [self hardStop];\n    }\n    [[iTermSessionHotkeyController sharedInstance] removeSession:self];\n\n    // final update of display. Do it async to avoid a join from a side effect.\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf updateDisplayBecause:@\"terminate session\"];\n    });\n\n    [[NSNotificationCenter defaultCenter] postNotificationName:iTermSessionWillTerminateNotification\n                                                        object:self];\n    [_delegate removeSession:self];\n\n    _screen.delegate = nil;\n    _screen.intervalTreeObserver = nil;\n\n    _screen.terminalEnabled = NO;\n    if (_view.findDriverDelegate == self) {\n        _view.findDriverDelegate = nil;\n    }\n\n    [_pasteHelper abort];\n\n    [[_delegate realParentWindow] sessionDidTerminate:self];\n\n    _delegate = nil;\n}\n\n- (void)setExited:(BOOL)exited {\n    _exited = exited;\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.exited = exited;\n    }];\n}\n\n- (void)makeTerminationUndoable {\n    _shell.paused = YES;\n    [_textview setDataSource:nil];\n    [_textview setDelegate:nil];\n    [self performSelector:@selector(hardStop)\n               withObject:nil\n               afterDelay:[iTermProfilePreferences intForKey:KEY_UNDO_TIMEOUT\n                                                   inProfile:_profile]];\n    // The analyzer complains that _view is leaked here, but the delayed perform to -hardStop above\n    // releases it. If it is canceled by -revive, then -revive autoreleases the view.\n    [[iTermController sharedInstance] addRestorableSession:[self restorableSession]];\n}\n\n// Not undoable. Kill the process. However, you can replace the terminated shell after this.\n- (void)hardStop {\n    [[iTermController sharedInstance] removeSessionFromRestorableSessions:self];\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [terminal.parser forceUnhookDCS:nil];\n    }];\n    [_view release];  // This balances a retain in -terminate.\n    [[self retain] autorelease];\n    [_shell stop];\n    _shell.delegate = nil;\n    [_textview setDataSource:nil];\n    [_textview setDelegate:nil];\n    [_textview removeFromSuperview];\n    if (_view.searchResultsMinimapViewDelegate == _textview.findOnPageHelper) {\n        _view.searchResultsMinimapViewDelegate = nil;\n    }\n    self.textview = nil;\n    _metalGlue.textView = nil;\n    [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionTerminatedNotification object:self];\n}\n\n- (void)jumpToLocationWhereCurrentStatusChanged {\n    if (_statusChangedAbsLine >= _screen.totalScrollbackOverflow) {\n        int line = _statusChangedAbsLine - _screen.totalScrollbackOverflow;\n        [_textview scrollLineNumberRangeIntoView:VT100GridRangeMake(line, 1)];\n        [_textview highlightMarkOnLine:line hasErrorCode:NO];\n    }\n}\n\n- (void)disinter {\n    _textview.dataSource = _screen;\n    _textview.delegate = self;\n}\n\n- (BOOL)revive {\n    if (_shell.paused) {\n        [NSObject cancelPreviousPerformRequestsWithTarget:self\n                                                 selector:@selector(hardStop)\n                                                   object:nil];\n        if (_shell.hasBrokenPipe) {\n            if (self.isRestartable) {\n                [self queueRestartSessionAnnouncement];\n            }\n        } else {\n            DLog(@\"  revive: exited=NO\");\n            [self setExited:NO];\n        }\n        _textview.dataSource = _screen;\n        _textview.delegate = self;\n        _screen.terminalEnabled = YES;\n        _screen.delegate = self;\n        if ([iTermAdvancedSettingsModel showLocationsInScrollbar] && [iTermAdvancedSettingsModel showMarksInScrollbar]) {\n            _screen.intervalTreeObserver = self;\n        }\n        _shell.paused = NO;\n        [_view setFindDriverDelegate:self];\n\n        NSDictionary *shortcutDictionary = [iTermProfilePreferences objectForKey:KEY_SESSION_HOTKEY inProfile:self.profile];\n        iTermShortcut *shortcut = [iTermShortcut shortcutWithDictionary:shortcutDictionary];\n        [[iTermSessionHotkeyController sharedInstance] setShortcut:shortcut forSession:self];\n\n        [_view autorelease];  // This balances a retain in -terminate prior to calling -makeTerminationUndoable\n        [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionRevivedNotification object:self];\n        return YES;\n    } else {\n        return NO;\n    }\n}\n\n// This does not handle tmux properly. Any writing to tmux should happen in a\n// caller. It does handle broadcasting to other sessions.\n- (void)writeTaskImpl:(NSString *)string\n             encoding:(NSStringEncoding)optionalEncoding\n        forceEncoding:(BOOL)forceEncoding\n         canBroadcast:(BOOL)canBroadcast\n            reporting:(BOOL)reporting {\n    const NSStringEncoding encoding = forceEncoding ? optionalEncoding : _screen.terminalEncoding;\n    if (gDebugLogging) {\n        NSArray *stack = [NSThread callStackSymbols];\n        DLog(@\"writeTaskImpl session=%@ encoding=%@ forceEncoding=%@ canBroadcast=%@ reporting=%@: called from %@\",\n             self, @(encoding), @(forceEncoding), @(canBroadcast), @(reporting), stack);\n        DLog(@\"writeTaskImpl string=%@\", string);\n    }\n    if (string.length == 0) {\n        DLog(@\"String length is 0\");\n        // Abort early so the surrogate hack works.\n        return;\n    }\n    if (canBroadcast && _screen.terminalSendReceiveMode && !self.isTmuxClient && !self.isTmuxGateway) {\n        // Local echo. Only for broadcastable text to avoid printing passwords from the password manager.\n        [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            [mutableState appendStringAtCursor:[string stringByMakingControlCharactersToPrintable]];\n        }];\n    }\n    // check if we want to send this input to all the sessions\n    if (canBroadcast && [[_delegate realParentWindow] broadcastInputToSession:self]) {\n        // Ask the parent window to write to the other tasks.\n        DLog(@\"Passing input to window to broadcast it. Won't send in this call.\");\n        [[_delegate realParentWindow] sendInputToAllSessions:string\n                                                    encoding:optionalEncoding\n                                               forceEncoding:forceEncoding];\n    } else if (!_exited) {\n        // Send to only this session\n        if (canBroadcast) {\n            // It happens that canBroadcast coincides with explicit user input. This is less than\n            // beautiful here, but in that case we want to turn off the bell and scroll to the\n            // bottom.\n            [self setBell:NO];\n            PTYScroller *verticalScroller = [_view.scrollview ptyVerticalScroller];\n            [verticalScroller setUserScroll:NO];\n        }\n        NSData *data = [self dataForInputString:string usingEncoding:encoding];\n        if (_conductor.queueWrites) {\n            if (!_sshWriteQueue) {\n                _sshWriteQueue = [[NSMutableData alloc] init];\n            }\n            [_sshWriteQueue appendData:data];\n            return;\n        }\n        if (_screen.sendingIsBlocked && !reporting) {\n            DLog(@\"Defer write of %@\", [data stringWithEncoding:NSUTF8StringEncoding]);\n            if (!_dataQueue) {\n                _dataQueue = [[NSMutableArray alloc] init];\n            }\n            [_dataQueue addObject:data];\n        } else {\n            DLog(@\"Write immediately: %@\", [data stringWithEncoding:NSUTF8StringEncoding]);\n            [self writeData:data];\n        }\n    }\n}\n\n- (void)writeData:(NSData *)data {\n    const char *bytes = data.bytes;\n    BOOL newline = NO;\n    for (NSUInteger i = 0; i < data.length; i++) {\n        DLog(@\"Write byte 0x%02x (%c)\", (((int)bytes[i]) & 0xff), bytes[i]);\n        if (bytes[i] == '\\r' || bytes[i] == '\\n') {\n            newline = YES;\n        }\n    }\n    if (newline) {\n        _activityInfo.lastNewline = [NSDate it_timeSinceBoot];\n    }\n    if (!_reportingFocus) {\n        self.lastNonFocusReportingWrite = [NSDate date];\n    }\n    [_shell writeTask:data];\n}\n\n// Convert the string to the requested encoding. If the string is a lone surrogate, deal with it by\n// saving the high surrogate and then combining it with a subsequent low surrogate.\n- (NSData *)dataForInputString:(NSString *)string usingEncoding:(NSStringEncoding)encoding {\n    NSData *data = [string dataUsingEncoding:encoding allowLossyConversion:YES];\n    if (data) {\n        _shell.pendingHighSurrogate = 0;\n        return data;\n    }\n    if (string.length != 1) {\n        _shell.pendingHighSurrogate = 0;\n        return nil;\n    }\n\n    const unichar c = [string characterAtIndex:0];\n    if (IsHighSurrogate(c)) {\n        _shell.pendingHighSurrogate = c;\n        DLog(@\"Detected high surrogate 0x%x\", (int)c);\n        return nil;\n    } else if (IsLowSurrogate(c) && _shell.pendingHighSurrogate) {\n        DLog(@\"Detected low surrogate 0x%x with pending high surrogate 0x%x\", (int)c, (int)_shell.pendingHighSurrogate);\n        unichar chars[2] = { _shell.pendingHighSurrogate, c };\n        _shell.pendingHighSurrogate = 0;\n        NSString *composite = [NSString stringWithCharacters:chars length:2];\n        return [composite dataUsingEncoding:encoding allowLossyConversion:YES];\n    }\n\n    _shell.pendingHighSurrogate = 0;\n    return nil;\n}\n\n- (void)writeTaskNoBroadcast:(NSString *)string {\n    [self writeTaskNoBroadcast:string encoding:_screen.terminalEncoding forceEncoding:NO reporting:NO];\n}\n\n- (void)writeTaskNoBroadcast:(NSString *)string\n                    encoding:(NSStringEncoding)encoding\n               forceEncoding:(BOOL)forceEncoding\n                   reporting:(BOOL)reporting {\n    if (_conductor.handlesKeystrokes) {\n        [_conductor sendKeys:[string dataUsingEncoding:encoding]];\n        return;\n    } else if (self.tmuxMode == TMUX_CLIENT) {\n        // tmux doesn't allow us to abuse the encoding, so this can cause the wrong thing to be\n        // sent (e.g., in mouse reporting).\n        [[_tmuxController gateway] sendKeys:string\n                               toWindowPane:self.tmuxPane];\n        return;\n    }\n    [self writeTaskImpl:string encoding:encoding forceEncoding:forceEncoding canBroadcast:NO reporting:reporting];\n}\n\n- (void)performTmuxCommand:(NSString *)command {\n    [self.tmuxController.gateway sendCommand:command\n                              responseTarget:nil\n                            responseSelector:NULL];\n}\n\n- (void)setTmuxController:(TmuxController *)tmuxController {\n    [_tmuxController autorelease];\n    _tmuxController = [tmuxController retain];\n    NSDictionary<NSString *, NSString *> *dict = [tmuxController userVarsForPane:self.tmuxPane];\n    for (NSString *key in dict) {\n        if (![key hasPrefix:@\"user.\"]) {\n            continue;\n        }\n        [self.variablesScope setValue:dict[key] forVariableNamed:key];\n    }\n}\n\n- (void)handleKeypressInTmuxGateway:(NSEvent *)event {\n    const unichar unicode = [event.characters length] > 0 ? [event.characters characterAtIndex:0] : 0;\n    [self handleCharacterPressedInTmuxGateway:unicode];\n}\n\n- (void)handleCharacterPressedInTmuxGateway:(unichar)unicode {\n    if (unicode == 27) {\n        [self tmuxDetach];\n    } else if (unicode == 'L') {\n        _tmuxGateway.tmuxLogging = !_tmuxGateway.tmuxLogging;\n        [self printTmuxMessage:[NSString stringWithFormat:@\"tmux logging %@\", (_tmuxGateway.tmuxLogging ? @\"on\" : @\"off\")]];\n    } else if (unicode == 'C') {\n        NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n        alert.messageText = @\"Enter command to send tmux:\";\n        [alert addButtonWithTitle:@\"OK\"];\n        [alert addButtonWithTitle:@\"Cancel\"];\n        NSTextField *tmuxCommand = [[[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, 200, 24)] autorelease];\n        [tmuxCommand setEditable:YES];\n        [tmuxCommand setSelectable:YES];\n        [alert setAccessoryView:tmuxCommand];\n        [alert layout];\n        [[alert window] makeFirstResponder:tmuxCommand];\n        if ([alert runModal] == NSAlertFirstButtonReturn && [[tmuxCommand stringValue] length]) {\n            [self printTmuxMessage:[NSString stringWithFormat:@\"Run command \\\"%@\\\"\", [tmuxCommand stringValue]]];\n            [_tmuxGateway sendCommand:[tmuxCommand stringValue]\n                       responseTarget:self\n                     responseSelector:@selector(printTmuxCommandOutputToScreen:)];\n        }\n    } else if (unicode == 'X') {\n        [self forceTmuxDetach];\n    }\n}\n\n- (void)forceTmuxDetach {\n    switch (self.tmuxMode) {\n        case TMUX_GATEWAY:\n            [self printTmuxMessage:@\"Exiting tmux mode, but tmux client may still be running.\"];\n            [self tmuxHostDisconnected:[[_tmuxGateway.dcsID copy] autorelease]];\n            return;\n        case TMUX_NONE:\n            return;\n        case TMUX_CLIENT:\n            [self.tmuxGatewaySession forceTmuxDetach];\n            return;\n    }\n}\n\n- (void)writeLatin1EncodedData:(NSData *)data broadcastAllowed:(BOOL)broadcast reporting:(BOOL)reporting {\n    // `data` contains raw bytes we want to pass through. I believe Latin-1 is the only encoding that\n    // won't perform any transformation when converting from data to string. This is needed because\n    // sometimes the user wants to send particular bytes regardless of the encoding (e.g., the\n    // \"send hex codes\" keybinding action, or certain mouse reporting modes that abuse encodings).\n    // This won't work for non-UTF-8 data with tmux.\n    NSString *string = [[[NSString alloc] initWithData:data encoding:NSISOLatin1StringEncoding] autorelease];\n    if (broadcast) {\n        [self writeTask:string encoding:NSISOLatin1StringEncoding forceEncoding:YES reporting:reporting];\n    } else {\n        [self writeTaskNoBroadcast:string encoding:NSISOLatin1StringEncoding forceEncoding:YES reporting:reporting];\n    }\n}\n\n- (void)writeStringWithLatin1Encoding:(NSString *)string {\n    [self writeTask:string encoding:NSISOLatin1StringEncoding forceEncoding:YES reporting:NO];\n}\n\n- (void)writeTask:(NSString *)string {\n    [self writeTask:string encoding:_screen.terminalEncoding forceEncoding:NO reporting:NO];\n}\n\n// If forceEncoding is YES then optionalEncoding will be used regardless of the session's preferred\n// encoding. If it is NO then the preferred encoding is used. This is necessary because this method\n// might send the string off to the window to get broadcast to other sessions which might have\n// different encodings.\n- (void)writeTask:(NSString *)string\n         encoding:(NSStringEncoding)optionalEncoding\n    forceEncoding:(BOOL)forceEncoding\n        reporting:(BOOL)reporting {\n    NSStringEncoding encoding = forceEncoding ? optionalEncoding : _screen.terminalEncoding;\n    if (self.tmuxMode == TMUX_CLIENT || _conductor.handlesKeystrokes) {\n        [self setBell:NO];\n        if ([[_delegate realParentWindow] broadcastInputToSession:self]) {\n            [[_delegate realParentWindow] sendInputToAllSessions:string\n                                                        encoding:optionalEncoding\n                                                   forceEncoding:forceEncoding];\n        } else if (_conductor.handlesKeystrokes) {\n            [_conductor sendKeys:[string dataUsingEncoding:encoding]];\n        } else {\n            assert(self.tmuxMode == TMUX_CLIENT);\n            [[_tmuxController gateway] sendKeys:string\n                                   toWindowPane:self.tmuxPane];\n        }\n        PTYScroller* ptys = (PTYScroller*)[_view.scrollview verticalScroller];\n        [ptys setUserScroll:NO];\n        return;\n    } else if (self.tmuxMode == TMUX_GATEWAY) {\n        // Use keypresses for tmux gateway commands for development and debugging.\n        for (int i = 0; i < string.length; i++) {\n            unichar unicode = [string characterAtIndex:i];\n            [self handleCharacterPressedInTmuxGateway:unicode];\n        }\n        return;\n    }\n    self.currentMarkOrNotePosition = nil;\n    [self writeTaskImpl:string encoding:encoding forceEncoding:forceEncoding canBroadcast:YES reporting:reporting];\n}\n\n// This is run in PTYTask's thread. It parses the input here and then queues an async task to run\n// in the main thread to execute the parsed tokens.\n- (void)threadedReadTask:(char *)buffer length:(int)length {\n    [_screen threadedReadTask:buffer length:length];\n}\n\n- (BOOL)haveResizedRecently {\n    const NSTimeInterval kGracePeriodAfterResize = 0.25;\n    return [NSDate timeIntervalSinceReferenceDate] < _lastResize + kGracePeriodAfterResize;\n}\n\n- (void)setAllTriggersEnabled:(BOOL)enabled {\n    NSArray<NSDictionary *> *triggers = self.profile[KEY_TRIGGERS];\n    triggers = [triggers mapWithBlock:^id(NSDictionary *dict) {\n        return [dict dictionaryBySettingObject:@(!enabled) forKey:kTriggerDisabledKey];\n    }];\n    if (!triggers) {\n        return;\n    }\n    [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS: triggers }];\n}\n\n- (BOOL)anyTriggerCanBeEnabled {\n    NSArray<NSDictionary *> *triggers = self.profile[KEY_TRIGGERS];\n    return [triggers anyWithBlock:^BOOL(NSDictionary *dict) {\n        return [dict[kTriggerDisabledKey] boolValue];\n    }];\n}\n\n- (BOOL)anyTriggerCanBeDisabled {\n    NSArray<NSDictionary *> *triggers = self.profile[KEY_TRIGGERS];\n    return [triggers anyWithBlock:^BOOL(NSDictionary *dict) {\n        return ![dict[kTriggerDisabledKey] boolValue];\n    }];\n}\n\n- (NSArray<iTermTuple<NSString *, NSNumber *> *> *)triggerTuples {\n    NSArray<NSDictionary *> *triggers = self.profile[KEY_TRIGGERS];\n    return [triggers mapWithBlock:^id(NSDictionary *dict) {\n        return [iTermTuple tupleWithObject:dict[kTriggerRegexKey]\n                                 andObject:@(![dict[kTriggerDisabledKey] boolValue])];\n    }];\n}\n\n- (void)toggleTriggerEnabledAtIndex:(NSInteger)index {\n    NSMutableArray<NSDictionary *> *mutableTriggers = [[self.profile[KEY_TRIGGERS] mutableCopy] autorelease];\n    NSDictionary *triggerDict = mutableTriggers[index];\n    const BOOL disabled = [triggerDict[kTriggerDisabledKey] boolValue];\n    mutableTriggers[index] = [triggerDict dictionaryBySettingObject:@(!disabled) forKey:kTriggerDisabledKey];\n    [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS: mutableTriggers }];\n}\n\n- (void)appendBrokenPipeMessage:(NSString *)unpaddedMessage {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        NSString *const message = [NSString stringWithFormat:@\" %@ \", unpaddedMessage];\n        if (mutableState.cursorX != 1) {\n            [mutableState appendCarriageReturnLineFeed];\n        }\n        screen_char_t savedFgColor = [terminal foregroundColorCode];\n        screen_char_t savedBgColor = [terminal backgroundColorCode];\n        // This color matches the color used in BrokenPipeDivider.png.\n        [terminal setForeground24BitColor:[NSColor colorWithCalibratedRed:70.0/255.0\n                                                                    green:83.0/255.0\n                                                                     blue:246.0/255.0\n                                                                    alpha:1]];\n        [terminal setBackgroundColor:ALTSEM_DEFAULT\n                  alternateSemantics:YES];\n        int width = (mutableState.width - message.length) / 2;\n        if (width > 0) {\n            [mutableState appendNativeImageAtCursorWithName:@\"BrokenPipeDivider\"\n                                                      width:width];\n        }\n        [mutableState appendStringAtCursor:message];\n        if (width > 0) {\n            [mutableState appendNativeImageAtCursorWithName:@\"BrokenPipeDivider\"\n                                                      width:(mutableState.width - mutableState.cursorX + 1)];\n        }\n        [mutableState appendCarriageReturnLineFeed];\n        [terminal setForegroundColor:savedFgColor.foregroundColor\n                  alternateSemantics:savedFgColor.foregroundColorMode == ColorModeAlternate];\n        [terminal setBackgroundColor:savedBgColor.backgroundColor\n                  alternateSemantics:savedBgColor.backgroundColorMode == ColorModeAlternate];\n    }];\n}\n\n// This is called in the main thread when coprocesses write to a tmux client.\n- (void)tmuxClientWrite:(NSData *)data {\n    if (!self.isTmuxClient) {\n        return;\n    }\n    NSString *string = [[[NSString alloc] initWithData:data encoding:self.encoding] autorelease];\n    [self writeTask:string];\n}\n\n- (void)threadedTaskBrokenPipe {\n    DLog(@\"threaded task broken pipe\");\n    // Put the call to brokenPipe in the same queue as the token executor to avoid a race.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self brokenPipe];\n    });\n}\n\n- (void)taskDidChangePaused:(PTYTask *)task paused:(BOOL)paused {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.taskPaused = paused;\n    }];\n}\n\n- (void)taskMuteCoprocessDidChange:(PTYTask *)task hasMuteCoprocess:(BOOL)hasMuteCoprocess {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.hasMuteCoprocess = hasMuteCoprocess;\n    }];\n}\n\n- (void)taskDiedImmediately {\n    // Let initial creation finish, then report the broken pipe. This happens if the file descriptor\n    // server dies immediately.\n    [self performSelector:@selector(brokenPipe) withObject:nil afterDelay:0];\n}\n\n- (void)taskDidChangeTTY:(PTYTask *)task {\n    [self.variablesScope setValue:task.tty forVariableNamed:iTermVariableKeySessionTTY];\n}\n\n// Main thread\n- (void)taskDidRegister:(PTYTask *)task {\n    [self updateTTYSize];\n}\n\n- (void)tmuxDidDisconnect {\n    DLog(@\"tmuxDidDisconnect\");\n    if (_exited) {\n        return;\n    }\n    [self setExited:YES];\n    [self cleanUpAfterBrokenPipe];\n    [self appendBrokenPipeMessage:@\"tmux detached\"];\n    switch (self.endAction) {\n        case iTermSessionEndActionClose:\n            if ([_delegate sessionShouldAutoClose:self]) {\n                [_delegate softCloseSession:self];\n                return;\n            }\n            break;\n\n        case iTermSessionEndActionRestart:\n        case iTermSessionEndActionDefault:\n            if (_tmuxWindowClosingByClientRequest ||\n                [self.naggingController tmuxWindowsShouldCloseAfterDetach]) {\n                [_delegate softCloseSession:self];\n                return;\n            }\n            break;\n    }\n\n    [self updateDisplayBecause:@\"session ended\"];\n}\n\n- (void)cleanUpAfterBrokenPipe {\n    [self setExited:YES];\n    [_logging stop];\n    [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionTerminatedNotification object:self];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kCurrentSessionDidChange object:nil];\n    [_delegate updateLabelAttributes];\n}\n\n// Called when the file descriptor closes. If -terminate was already called this does nothing.\n// Otherwise, you can call replaceTerminatedShellWithNewInstance after this to restart the session.\n- (void)brokenPipe {\n    DLog(@\"  brokenPipe %@ task=%@\\n%@\", self, self.shell, [NSThread callStackSymbols]);\n    if (_exited) {\n        DLog(@\"  brokenPipe: Already exited\");\n        return;\n    }\n    // Ensure we don't leak the monoserver unix domain socket file descriptor.\n    [_shell killWithMode:iTermJobManagerKillingModeBrokenPipe];\n    if ([self shouldPostUserNotification] &&\n        [iTermProfilePreferences boolForKey:KEY_SEND_SESSION_ENDED_ALERT inProfile:self.profile]) {\n        [[iTermNotificationController sharedInstance] notify:@\"Session Ended\"\n                                             withDescription:[NSString stringWithFormat:@\"Session \\\"%@\\\" in tab #%d just terminated.\",\n                                                              [[self name] removingHTMLFromTabTitleIfNeeded],\n                                                              [_delegate tabNumber]]];\n    }\n\n    DLog(@\"  brokenPipe: set exited = YES\");\n    [self cleanUpAfterBrokenPipe];\n\n    if (_shouldRestart) {\n        _modeHandler.mode = iTermSessionModeDefault;\n        [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                 VT100ScreenMutableState *mutableState,\n                                                 id<VT100ScreenDelegate> delegate) {\n            [terminal resetByUserRequest:NO];\n            [self appendBrokenPipeMessage:@\"Session Restarted\"];\n            [self replaceTerminatedShellWithNewInstance];\n        }];\n        return;\n    }\n\n    if (_shortLivedSingleUse) {\n        [[iTermBuriedSessions sharedInstance] restoreSession:self];\n        [self appendBrokenPipeMessage:@\"Finished\"];\n        // restart is not respected here because it doesn't make sense and would make for an awful bug.\n        if (self.endAction == iTermSessionEndActionClose) {\n            [_delegate closeSession:self];\n        }\n        return;\n    }\n    if (self.tmuxMode == TMUX_GATEWAY) {\n        [self forceTmuxDetach];\n    }\n    [self appendBrokenPipeMessage:@\"Session Ended\"];\n    switch (self.endAction) {\n        case iTermSessionEndActionClose:\n            if ([_delegate sessionShouldAutoClose:self]) {\n                [_delegate closeSession:self];\n                return;\n            }\n            break;\n\n        case iTermSessionEndActionRestart:\n            if ([self isRestartable]) {\n                [self performSelector:@selector(maybeReplaceTerminatedShellWithNewInstance) withObject:nil afterDelay:1];\n                return;\n            }\n            break;\n\n        case iTermSessionEndActionDefault:\n            break;\n    }\n\n    // Offer to restart the session by rerunning its program.\n    if ([self isRestartable]) {\n        [self queueRestartSessionAnnouncement];\n    }\n    [self updateDisplayBecause:@\"session ended\"];\n}\n\n- (void)queueRestartSessionAnnouncement {\n    if ([iTermAdvancedSettingsModel suppressRestartAnnouncement]) {\n        return;\n    }\n    if (_shortLivedSingleUse) {\n        return;\n    }\n    [self.naggingController brokenPipe];\n}\n\n- (BOOL)isRestartable {\n    return _program != nil;\n}\n\n- (void)maybeReplaceTerminatedShellWithNewInstance {\n    // The check for screen.terminalEnabled is because after -terminate is called, it is no longer safe\n    // to replace the terminated shell with a new instance unless you first do -revive. When\n    // the terminal is disabled you can't write text to the screen.\n    // In other words: broken pipe -> close window -> timer calls this: nothing should happen\n    //                 broken pipe -> close window -> undo close -> timer calls this: work normally\n    if (_screen.terminalEnabled && self.isRestartable && _exited) {\n        [self replaceTerminatedShellWithNewInstance];\n    }\n}\n\n// NOTE: Not safe to call this after -terminate, unless you first call -revive. It *is* safe\n// to call this after -brokenPipe, provided -terminate wasn't already called.\n- (void)replaceTerminatedShellWithNewInstance {\n    assert(self.isRestartable);\n    assert(_exited);\n    _shouldRestart = NO;\n    DLog(@\"  replaceTerminatedShellWithNewInstance: exited <- NO\");\n    [self setExited:NO];\n    [_shell autorelease];\n    _shell = nil;\n    [_logging stop];\n\n    self.guid = [NSString uuid];\n    _shell = [[PTYTask alloc] init];\n    [_shell setDelegate:self];\n    [_shell.winSizeController setGridSize:_screen.size\n                                 viewSize:_screen.viewSize\n                              scaleFactor:self.backingScaleFactor];\n    [self resetForRelaunch];\n    __weak __typeof(self) weakSelf = self;\n    [self startProgram:_program\n                   ssh:_sshState == iTermSSHStateProfile\n           environment:_environment\n           customShell:_customShell\n                isUTF8:_isUTF8\n         substitutions:_substitutions\n           arrangement:nil\n       fromArrangement:NO\n            completion:^(BOOL ok) {\n        [weakSelf.delegate sessionDidRestart:self];\n    }];\n    [_naggingController willRecycleSession];\n    DLog(@\"  replaceTerminatedShellWithNewInstance: return with terminalEnabled=%@\", @(_screen.terminalEnabled));\n}\n\n- (void)lockScroll {\n    PTYScroller *scroller = [PTYScroller castFrom:self.view.scrollview.verticalScroller];\n    scroller.userScroll = YES;\n}\n\n- (NSSize)idealScrollViewSizeWithStyle:(NSScrollerStyle)scrollerStyle {\n    NSSize innerSize = NSMakeSize([_screen width] * [_textview charWidth] + [iTermPreferences intForKey:kPreferenceKeySideMargins] * 2,\n                                  [_screen height] * [_textview lineHeight] + [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins] * 2);\n    BOOL hasScrollbar = [[_delegate realParentWindow] scrollbarShouldBeVisible];\n    NSSize outerSize =\n    [PTYScrollView frameSizeForContentSize:innerSize\n                   horizontalScrollerClass:nil\n                     verticalScrollerClass:hasScrollbar ? [PTYScroller class] : nil\n                                borderType:NSNoBorder\n                               controlSize:NSControlSizeRegular\n                             scrollerStyle:scrollerStyle];\n    return outerSize;\n}\n\n- (BOOL)setScrollBarVisible:(BOOL)visible style:(NSScrollerStyle)style {\n    BOOL changed = NO;\n    if (self.view.scrollview.hasVerticalScroller != visible) {\n        changed = YES;\n    }\n    [[self.view scrollview] setHasVerticalScroller:visible];\n\n    if (self.view.scrollview.scrollerStyle != style) {\n        changed = YES;\n    }\n    [[self.view scrollview] setScrollerStyle:style];\n    [[self textview] updateScrollerForBackgroundColor];\n\n    if (changed) {\n        [self.view updateLayout];\n    }\n\n    return changed;\n}\n\n- (iTermKeyBindingAction *)_keyBindingActionForEvent:(NSEvent *)event {\n    // Check if we have a custom key mapping for this event\n    iTermKeyBindingAction *action =\n    [iTermKeyMappings actionForKeystroke:[iTermKeystroke withEvent:event]\n                             keyMappings:[[self profile] objectForKey:KEY_KEYBOARD_MAP]];\n    return action;\n}\n\n- (BOOL)hasTextSendingKeyMappingForEvent:(NSEvent *)event {\n    iTermKeyBindingAction *action = [self _keyBindingActionForEvent:event];\n    if (action.keyAction == KEY_ACTION_IGNORE) {\n        return YES;\n    }\n    return [action sendsText];\n}\n\n+ (BOOL)_recursiveSelectMenuWithSelector:(SEL)selector inMenu:(NSMenu *)menu {\n    for (NSMenuItem* item in [menu itemArray]) {\n        if (![item isEnabled] || [item isHidden]) {\n            continue;\n        }\n        if ([item hasSubmenu]) {\n            if ([PTYSession _recursiveSelectMenuWithSelector:selector inMenu:[item submenu]]) {\n                return YES;\n            }\n        } else if ([item action] == selector) {\n            [NSApp sendAction:[item action]\n                           to:[item target]\n                         from:item];\n            return YES;\n        }\n    }\n    return NO;\n}\n\n+ (BOOL)_recursiveSelectMenuItemWithTitle:(NSString*)title identifier:(NSString *)identifier inMenu:(NSMenu*)menu {\n    [menu update];\n\n    if (menu == [NSApp windowsMenu] &&\n        [[NSApp keyWindow] respondsToSelector:@selector(_moveToScreen:)] &&\n        [NSScreen it_stringLooksLikeUniqueKey:identifier]) {\n        NSScreen *screen = [NSScreen it_screenWithUniqueKey:identifier];\n        if (screen) {\n            [NSApp sendAction:@selector(_moveToScreen:) to:nil from:screen];\n            return YES;\n        }\n    }\n\n    for (NSMenuItem* item in [menu itemArray]) {\n        if (![item isEnabled] || [item isHidden]) {\n            continue;\n        }\n        if ([item hasSubmenu]) {\n            if ([PTYSession _recursiveSelectMenuItemWithTitle:title identifier:identifier inMenu:[item submenu]]) {\n                return YES;\n            }\n        }\n        if ([ITAddressBookMgr shortcutIdentifier:identifier title:title matchesItem:item]) {\n            if (item.hasSubmenu) {\n                return YES;\n            }\n            [NSApp sendAction:[item action]\n                           to:[item target]\n                         from:item];\n            return YES;\n        }\n    }\n    return NO;\n}\n\n+ (BOOL)handleShortcutWithoutTerminal:(NSEvent *)event {\n    // Check if we have a custom key mapping for this event\n    iTermKeyBindingAction *action = [iTermKeyMappings actionForKeystroke:[iTermKeystroke withEvent:event]\n                                                             keyMappings:[iTermKeyMappings globalKeyMap]];\n    if (!action) {\n        return NO;\n    }\n    return [PTYSession performKeyBindingAction:action event:event];\n}\n\n+ (void)selectMenuItemWithSelector:(SEL)theSelector {\n    if (![self _recursiveSelectMenuWithSelector:theSelector inMenu:[NSApp mainMenu]]) {\n        DLog(@\"Beep: failed to find menu item with selector %@\", NSStringFromSelector(theSelector));\n        NSBeep();\n    }\n}\n\n+ (void)selectMenuItem:(NSString*)theName {\n    NSArray *parts = [theName componentsSeparatedByString:@\"\\n\"];\n    NSString *title = parts.firstObject;\n    NSString *identifier = nil;\n    if (parts.count > 1) {\n        identifier = parts[1];\n    }\n    if (![self _recursiveSelectMenuItemWithTitle:title identifier:identifier inMenu:[NSApp mainMenu]]) {\n        DLog(@\"Beep: failed to find menu item with title %@ and identifier %@\", title, identifier);\n        NSBeep();\n    }\n}\n\n- (BOOL)willHandleEvent:(NSEvent *) theEvent\n{\n    return NO;\n}\n\n- (void)handleEvent:(NSEvent *)theEvent\n{\n}\n\n- (void)insertNewline:(id)sender {\n    [self insertText:@\"\\n\"];\n}\n\n- (void)insertTab:(id)sender {\n    [self insertText:@\"\\t\"];\n}\n\n- (void)moveUp:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyArrowUp:0] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)moveDown:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyArrowDown:0] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)moveLeft:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyArrowLeft:0] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)moveRight:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyArrowRight:0] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)pageUp:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyPageUp:0] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)pageDown:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyPageDown:0] broadcastAllowed:YES reporting:NO];\n}\n\n+ (NSString*)pasteboardString {\n    return [NSString stringFromPasteboard];\n}\n\n- (void)insertText:(NSString *)string {\n    if (_exited) {\n        return;\n    }\n\n    // Note: there used to be a weird special case where 0xa5 got converted to\n    // backslash. I think it was based on a misunderstanding of how encodings\n    // work and it should've been removed like 10 years ago.\n    if (string != nil) {\n        if (gDebugLogging) {\n            DebugLog([NSString stringWithFormat:@\"writeTask:%@\", string]);\n        }\n        [self writeTask:string];\n    }\n}\n\n- (NSData *)dataByRemovingControlCodes:(NSData *)data {\n    NSMutableData *output = [NSMutableData dataWithCapacity:[data length]];\n    const unsigned char *p = data.bytes;\n    int start = 0;\n    int i = 0;\n    for (i = 0; i < data.length; i++) {\n        if (p[i] < ' ' && p[i] != '\\n' && p[i] != '\\r' && p[i] != '\\t' && p[i] != 12) {\n            if (i > start) {\n                [output appendBytes:p + start length:i - start];\n            }\n            start = i + 1;\n        }\n    }\n    if (i > start) {\n        [output appendBytes:p + start length:i - start];\n    }\n    return output;\n}\n\n- (void)pasteString:(NSString *)aString {\n    [self pasteString:aString flags:0];\n}\n\n- (void)pasteStringWithoutBracketing:(NSString *)theString {\n    [self pasteString:theString flags:kPTYSessionPasteBracketingDisabled];\n}\n\n- (void)deleteBackward:(id)sender {\n    unsigned char p = 0x08; // Ctrl+H\n\n    [self writeLatin1EncodedData:[NSData dataWithBytes:&p length:1] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)deleteForward:(id)sender {\n    unsigned char p = 0x7F; // DEL\n\n    [self writeLatin1EncodedData:[NSData dataWithBytes:&p length:1] broadcastAllowed:YES reporting:NO];\n}\n\n- (PTYScroller *)textViewVerticalScroller {\n    return (PTYScroller *)[_view.scrollview verticalScroller];\n}\n\n- (BOOL)textViewHasCoprocess {\n    return [_shell hasCoprocess];\n}\n\n- (void)textViewStopCoprocess {\n    [_shell stopCoprocess];\n}\n\n- (BOOL)shouldPostUserNotification {\n    if (!_screen.postUserNotifications) {\n        return NO;\n    }\n    if (_shortLivedSingleUse) {\n        return NO;\n    }\n    if (![_delegate sessionBelongsToVisibleTab]) {\n        return YES;\n    }\n    BOOL windowIsObscured =\n    ([[iTermController sharedInstance] terminalIsObscured:_delegate.realParentWindow]);\n    return (windowIsObscured);\n}\n\n- (BOOL)hasSelection {\n    return [_textview.selection hasSelection];\n}\n\n- (void)openSelection {\n    long long absLineNumber;\n    NSArray *subSelections = _textview.selection.allSubSelections;\n    if ([subSelections count]) {\n        iTermSubSelection *firstSub = subSelections[0];\n        absLineNumber = firstSub.absRange.coordRange.start.y;\n    } else {\n        absLineNumber = _textview.selection.liveRange.coordRange.start.y;\n    }\n    const long long overflow = _screen.totalScrollbackOverflow;\n    if (absLineNumber < overflow || absLineNumber - overflow > INT_MAX) {\n        return;\n    }\n    const int lineNumber = absLineNumber - overflow;\n\n    // TODO: Figure out if this is a remote host and download/open if that's the case.\n    NSString *workingDirectory = [_screen workingDirectoryOnLine:lineNumber];\n    NSString *selection = [_textview selectedText];\n    if (!selection.length) {\n        DLog(@\"Beep: no selection\");\n        NSBeep();\n        return;\n    }\n\n    [self open:selection workingDirectory:workingDirectory];\n}\n\n- (void)open:(NSString *)selection workingDirectory:(NSString *)workingDirectory {\n    iTermSemanticHistoryController *semanticHistoryController = _textview.semanticHistoryController;\n\n    // NOTE: The synchronous API is used here because this is a user-initiated action. We don't want\n    // things to change out from under us. It's ok to block the UI while waiting for disk access\n    // to complete.\n    NSString *rawFilename =\n    [semanticHistoryController pathOfExistingFileFoundWithPrefix:selection\n                                                          suffix:@\"\"\n                                                workingDirectory:workingDirectory\n                                            charsTakenFromPrefix:nil\n                                            charsTakenFromSuffix:nil\n                                                  trimWhitespace:YES];\n    if (rawFilename &&\n        ![[rawFilename stringByReplacingOccurrencesOfString:@\"//\" withString:@\"/\"] isEqualToString:@\"/\"]) {\n        NSString *lineNumber = nil;\n        NSString *columnNumber = nil;\n        NSString *cleanedup = [semanticHistoryController cleanedUpPathFromPath:rawFilename\n                                                                        suffix:nil\n                                                              workingDirectory:workingDirectory\n                                                           extractedLineNumber:&lineNumber\n                                                                  columnNumber:&columnNumber];\n        __weak __typeof(self) weakSelf = self;\n        [_textview openSemanticHistoryPath:cleanedup\n                             orRawFilename:rawFilename\n                                  fragment:nil\n                          workingDirectory:workingDirectory\n                                lineNumber:lineNumber\n                              columnNumber:columnNumber\n                                    prefix:selection\n                                    suffix:@\"\"\n                                completion:^(BOOL ok) {\n            if (!ok) {\n                [weakSelf tryOpenStringAsURL:selection];\n            }\n        }];\n        return;\n    }\n\n    [self tryOpenStringAsURL:selection];\n}\n\n- (void)textViewOpen:(NSString *)string\n    workingDirectory:(NSString *)folder\n          remoteHost:(id<VT100RemoteHostReading>)remoteHost {\n    // TODO: Open files on remote hosts when using ssh integration\n    if (remoteHost.isLocalhost) {\n        [self open:string workingDirectory:folder];\n    } else {\n        [self tryOpenStringAsURL:string];\n    }\n}\n\n- (void)tryOpenStringAsURL:(NSString *)selection {\n    // Try to open it as a URL.\n    NSURL *url =\n    [NSURL URLWithUserSuppliedString:[selection stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];\n    if (url) {\n        [[NSWorkspace sharedWorkspace] openURL:url];\n        return;\n    }\n\n    DLog(@\"Beep: bad url %@\", selection);\n    NSBeep();\n}\n\n- (void)setBell:(BOOL)flag {\n    if (flag != _bell) {\n        _bell = flag;\n        [_delegate setBell:flag];\n        if (_bell) {\n            if ([_textview keyIsARepeat] == NO &&\n                [self shouldPostUserNotification] &&\n                [iTermProfilePreferences boolForKey:KEY_SEND_BELL_ALERT inProfile:self.profile]) {\n                [[iTermNotificationController sharedInstance] notify:@\"Bell\"\n                                                     withDescription:[NSString stringWithFormat:@\"Session %@ #%d just rang a bell!\",\n                                                                      [[self name] removingHTMLFromTabTitleIfNeeded],\n                                                                      [_delegate tabNumber]]\n                                                         windowIndex:[self screenWindowIndex]\n                                                            tabIndex:[self screenTabIndex]\n                                                           viewIndex:[self screenViewIndex]];\n            }\n        }\n    }\n}\n\n- (NSString *)ansiColorsMatchingForeground:(NSDictionary *)fg\n                             andBackground:(NSDictionary *)bg\n                                inBookmark:(Profile *)aDict\n{\n    NSColor *fgColor;\n    NSColor *bgColor;\n    fgColor = [ITAddressBookMgr decodeColor:fg];\n    bgColor = [ITAddressBookMgr decodeColor:bg];\n\n    int bgNum = -1;\n    int fgNum = -1;\n    for(int i = 0; i < 16; ++i) {\n        NSString* key = [self amendedColorKey:[NSString stringWithFormat:KEYTEMPLATE_ANSI_X_COLOR, i]];\n        if ([fgColor isEqual:[ITAddressBookMgr decodeColor:[aDict objectForKey:key]]]) {\n            fgNum = i;\n        }\n        if ([bgColor isEqual:[ITAddressBookMgr decodeColor:[aDict objectForKey:key]]]) {\n            bgNum = i;\n        }\n    }\n\n    if (bgNum < 0 || fgNum < 0) {\n        if ([iTermAdvancedSettingsModel useColorfgbgFallback]) {\n            if ([fgColor brightnessComponent] > [bgColor brightnessComponent]) {\n                return @\"15;0\";\n            } else {\n                return @\"0;15\";\n            }\n        }\n        return nil;\n    }\n\n    return ([[NSString alloc] initWithFormat:@\"%d;%d\", fgNum, bgNum]);\n}\n\n- (void)loadInitialColorTableAndResetCursorGuide {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState loadInitialColorTable];\n    }];\n    [self resetCursorGuide];\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf markProfileInitialized];\n    });\n}\n\n- (void)resetCursorGuide {\n    _textview.highlightCursorLine = [iTermProfilePreferences boolForColorKey:KEY_USE_CURSOR_GUIDE\n                                                                        dark:[NSApp effectiveAppearance].it_isDark\n                                                                     profile:_profile];\n}\n\n- (void)markProfileInitialized {\n    DLog(@\"Mark profile initialized %@\", self);\n    _profileInitialized = YES;\n}\n\n- (NSColor *)tabColorInProfile:(NSDictionary *)profile {\n    const BOOL dark = _screen.colorMap.darkMode;\n    if ([iTermProfilePreferences boolForColorKey:KEY_USE_TAB_COLOR dark:dark profile:profile]) {\n        return [iTermProfilePreferences colorForKey:KEY_TAB_COLOR dark:dark profile:profile];\n    }\n    return nil;\n}\n\n- (void)setColorsFromPresetNamed:(NSString *)presetName {\n    iTermColorPreset *settings = [iTermColorPresets presetWithName:presetName];\n    if (!settings) {\n        return;\n    }\n    const BOOL presetUsesModes = settings[KEY_FOREGROUND_COLOR COLORS_LIGHT_MODE_SUFFIX] != nil;\n    for (NSString *colorName in [ProfileModel colorKeysWithModes:presetUsesModes]) {\n        iTermColorDictionary *colorDict = [settings iterm_presetColorWithName:colorName];\n        if (colorDict) {\n            [self setSessionSpecificProfileValues:@{ colorName: colorDict }];\n        }\n    }\n    [self setSessionSpecificProfileValues:@{ KEY_USE_SEPARATE_COLORS_FOR_LIGHT_AND_DARK_MODE: @(presetUsesModes) }];\n}\n\n- (void)sharedProfileDidChange\n{\n    NSDictionary *updatedProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:_originalProfile[KEY_GUID]];\n    if (!updatedProfile) {\n        return;\n    }\n    if (!self.isDivorced) {\n        [self setPreferencesFromAddressBookEntry:updatedProfile];\n        [self setProfile:updatedProfile];\n        return;\n    }\n\n    // Copy non-overridden fields over.\n    NSMutableDictionary *temp = [NSMutableDictionary dictionaryWithDictionary:_profile];\n    NSMutableArray *noLongerOverriddenFields = [NSMutableArray array];\n    NSMutableSet *keys = [NSMutableSet setWithArray:[updatedProfile allKeys]];\n    [keys addObjectsFromArray:[_profile allKeys]];\n    for (NSString *key in keys) {\n        NSObject *originalValue = updatedProfile[key];\n        NSObject *currentValue = _profile[key];\n        if ([_overriddenFields containsObject:key]) {\n            if ([originalValue isEqual:currentValue]) {\n                [noLongerOverriddenFields addObject:key];\n            }\n        } else {\n            if (!originalValue) {\n                DLog(@\"Unset %@ in session because it was removed from shared profile\", key);\n                [temp removeObjectForKey:key];\n            } else {\n                if (![originalValue isEqual:temp[key]]) {\n                    DLog(@\"Update session for key %@ from %@ -> %@\", key, temp[key], originalValue);\n                }\n                temp[key] = originalValue;\n            }\n        }\n    }\n\n    // For fields that are no longer overridden because the shared profile took on the same value\n    // as the sessions profile, remove those keys from overriddenFields.\n    for (NSString *key in noLongerOverriddenFields) {\n        DLog(@\"%p: %@ is no longer overridden because shared profile now matches session profile value of %@\",\n             self, key, temp[key]);\n        [_overriddenFields removeObject:key];\n    }\n    DLog(@\"After shared profile change overridden keys are: %@\", _overriddenFields);\n\n    // Update saved state.\n    [[ProfileModel sessionsInstance] setBookmark:temp withGuid:temp[KEY_GUID]];\n    [self setPreferencesFromAddressBookEntry:temp];\n    [self setProfile:temp];\n}\n\n- (void)sessionProfileDidChange {\n    if (!self.isDivorced) {\n        return;\n    }\n    NSDictionary *updatedProfile =\n    [[ProfileModel sessionsInstance] bookmarkWithGuid:_profile[KEY_GUID]];\n    if (!updatedProfile) {\n        // Can happen when replaying a recorded session.\n        return;\n    }\n\n    NSMutableSet *keys = [NSMutableSet setWithArray:[updatedProfile allKeys]];\n    [keys addObjectsFromArray:[_profile allKeys]];\n    for (NSString *aKey in keys) {\n        NSObject *sharedValue = _originalProfile[aKey];\n        NSObject *newSessionValue = updatedProfile[aKey];\n        BOOL isEqual = [newSessionValue isEqual:sharedValue];\n        BOOL isOverridden = [_overriddenFields containsObject:aKey];\n        if (!isEqual && !isOverridden) {\n            DLog(@\"%p: %@ is now overridden because %@ != %@\", self, aKey, newSessionValue, sharedValue);\n            [_overriddenFields addObject:aKey];\n        } else if (isEqual && isOverridden) {\n            DLog(@\"%p: %@ is no longer overridden because %@ == %@\", self, aKey, newSessionValue, sharedValue);\n            [_overriddenFields removeObject:aKey];\n        }\n    }\n    DLog(@\"After session profile change overridden keys are: %@\", _overriddenFields);\n    [self setPreferencesFromAddressBookEntry:updatedProfile];\n    [self setProfile:updatedProfile];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kSessionProfileDidChange\n                                                        object:_profile[KEY_GUID]];\n}\n\n- (BOOL)reloadProfile {\n    DLog(@\"Reload profile for %@\", self);\n    BOOL didChange = NO;\n    NSDictionary *sharedProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:_originalProfile[KEY_GUID]];\n    if (sharedProfile && ![sharedProfile isEqual:_originalProfile]) {\n        DLog(@\"Shared profile changed\");\n        [self sharedProfileDidChange];\n        didChange = YES;\n        [_originalProfile autorelease];\n        _originalProfile = [sharedProfile copy];\n    }\n\n    if (self.isDivorced) {\n        NSDictionary *sessionProfile = [[ProfileModel sessionsInstance] bookmarkWithGuid:_profile[KEY_GUID]];\n        if (![sessionProfile isEqual:_profile]) {\n            DLog(@\"Session profile changed\");\n            [self sessionProfileDidChange];\n            didChange = YES;\n        }\n    }\n\n    [self profileNameDidChangeTo:self.profile[KEY_NAME]];\n    return didChange;\n}\n\n- (void)loadColorsFromProfile:(Profile *)aDict {\n    const BOOL dark = (self.view.effectiveAppearance ?: [NSApp effectiveAppearance]).it_isDark;\n    NSDictionary<NSNumber *, NSString *> *keyMap = [self colorTableForProfile:aDict darkMode:dark];\n\n    NSMutableDictionary<NSNumber *, id> *colorTable =\n    [[[keyMap mapValuesWithBlock:^id(NSNumber *colorKey, NSString *profileKey) {\n        if ([profileKey isKindOfClass:[NSString class]]) {\n            return [iTermProfilePreferences colorForKey:profileKey\n                                                   dark:dark\n                                                profile:aDict] ?: [NSNull null];\n        } else {\n            return [NSNull null];\n        }\n    }] mutableCopy] autorelease];\n    [self load16ANSIColorsFromProfile:aDict darkMode:dark into:colorTable];\n    const BOOL didUseSelectedTextColor = [iTermProfilePreferences boolForKey:iTermAmendedColorKey(KEY_USE_SELECTED_TEXT_COLOR, self.profile, dark) inProfile:self.profile];\n    const BOOL willUseSelectedTextColor = [iTermProfilePreferences boolForKey:iTermAmendedColorKey(KEY_USE_SELECTED_TEXT_COLOR, aDict, dark) inProfile:aDict];\n\n    [_screen setColorsFromDictionary:colorTable];\n\n    if (didUseSelectedTextColor != willUseSelectedTextColor) {\n        [_textview updatePortholeColorsWithUseSelectedTextColor:willUseSelectedTextColor];\n    }\n    self.cursorGuideColor = [[iTermProfilePreferences objectForKey:iTermAmendedColorKey(KEY_CURSOR_GUIDE_COLOR, aDict, dark)\n                                                         inProfile:aDict] colorValueForKey:iTermAmendedColorKey(KEY_CURSOR_GUIDE_COLOR, aDict, dark)];\n    if (!_cursorGuideSettingHasChanged) {\n        _textview.highlightCursorLine = [iTermProfilePreferences boolForKey:iTermAmendedColorKey(KEY_USE_CURSOR_GUIDE, aDict, dark)\n                                                                  inProfile:aDict];\n    }\n\n    [self setSmartCursorColor:[iTermProfilePreferences boolForKey:iTermAmendedColorKey(KEY_SMART_CURSOR_COLOR, aDict, dark)\n                                                        inProfile:aDict]];\n\n    DLog(@\"set min contrast to %f using key %@\", [iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, aDict, dark)\n                                                                            inProfile:aDict], iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, aDict, dark));\n    [self setMinimumContrast:[iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, aDict, dark)\n                                                        inProfile:aDict]];\n}\n\n- (NSDictionary<NSNumber *, NSString *> *)colorTableForProfile:(Profile *)profile darkMode:(BOOL)dark {\n    NSString *(^k)(NSString *) = ^NSString *(NSString *baseKey) {\n        return iTermAmendedColorKey(baseKey, profile, dark);\n    };\n    const BOOL useUnderline = [iTermProfilePreferences boolForKey:k(KEY_USE_UNDERLINE_COLOR) inProfile:profile];\n    NSDictionary *keyMap = @{ @(kColorMapForeground): k(KEY_FOREGROUND_COLOR),\n                              @(kColorMapBackground): k(KEY_BACKGROUND_COLOR),\n                              @(kColorMapSelection): k(KEY_SELECTION_COLOR),\n                              @(kColorMapSelectedText): k(KEY_SELECTED_TEXT_COLOR),\n                              @(kColorMapBold): k(KEY_BOLD_COLOR),\n                              @(kColorMapLink): k(KEY_LINK_COLOR),\n                              @(kColorMapCursor): k(KEY_CURSOR_COLOR),\n                              @(kColorMapCursorText): k(KEY_CURSOR_TEXT_COLOR),\n                              @(kColorMapUnderline): (useUnderline ? k(KEY_UNDERLINE_COLOR) : [NSNull null])\n    };\n    return keyMap;\n}\n\n// Restore a color to the value in `profile`.\n- (NSDictionary<NSNumber *, id> *)resetColorWithKey:(int)colorKey\n                                        fromProfile:(Profile *)profile\n                                         profileKey:(NSString *)profileKey\n                                               dark:(BOOL)dark {\n    DLog(@\"resetColorWithKey:%d fromProfile:%@\", colorKey, profile[KEY_GUID]);\n    if (!profile) {\n        DLog(@\"No original profile\");\n        return @{};\n    }\n\n    NSColor *color = [iTermProfilePreferences colorForKey:profileKey\n                                                     dark:dark\n                                                  profile:profile];\n    if (!color) {\n        return @{};\n    }\n    if (profileKey) {\n        [self setSessionSpecificProfileValues:@{ profileKey: [color dictionaryValue] }];\n        return @{};\n    }\n    return @{ @(colorKey): color };\n}\n\n- (void)load16ANSIColorsFromProfile:(Profile *)aDict darkMode:(BOOL)dark into:(NSMutableDictionary<NSNumber *, id> *)dict {\n    for (int i = 0; i < 16; i++) {\n        [self loadANSIColor:i fromProfile:aDict darkMode:dark to:dict];\n    }\n}\n\n- (void)loadANSIColor:(int)i fromProfile:(Profile *)aDict darkMode:(BOOL)dark to:(NSMutableDictionary<NSNumber *, id> *)dict {\n    NSString *baseKey = [NSString stringWithFormat:KEYTEMPLATE_ANSI_X_COLOR, i];\n    NSString *profileKey = iTermAmendedColorKey(baseKey, aDict, dark);\n    NSColor *theColor = [ITAddressBookMgr decodeColor:aDict[profileKey]];\n    dict[@(kColorMap8bitBase + i)] = theColor ?: [NSNull null];\n}\n\n- (void)setPreferencesFromAddressBookEntry:(NSDictionary *)aePrefs {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [self reallySetPreferencesFromAddressBookEntry:aePrefs terminal:terminal];\n    }];\n}\n\n- (void)reallySetPreferencesFromAddressBookEntry:(NSDictionary *)aePrefs\n                                        terminal:(VT100Terminal *)terminal {\n    NSDictionary *aDict = aePrefs;\n\n    if (aDict == nil) {\n        DLog(@\"nil dict, use default\");\n        aDict = [[ProfileModel sharedInstance] defaultBookmark];\n    }\n    if (aDict == nil) {\n        DLog(@\"uh oh! no default dict!\");\n        return;\n    }\n    DLog(@\"%@: set prefs to address book entry:\\n%@\", self, aDict);\n\n    if ([self isTmuxClient] && ![_profile[KEY_NAME] isEqualToString:aePrefs[KEY_NAME]]) {\n        _tmuxTitleOutOfSync = YES;\n    }\n\n    [self loadColorsFromProfile:aDict];\n\n    // background image\n    [self setBackgroundImagePath:aDict[KEY_BACKGROUND_IMAGE_LOCATION]];\n    [self setBackgroundImageMode:[iTermProfilePreferences unsignedIntegerForKey:KEY_BACKGROUND_IMAGE_MODE\n                                                                      inProfile:aDict]];\n\n    // Color scheme\n    // ansiColorsMatchingForeground:andBackground:inBookmark does an equality comparison, so\n    // iTermProfilePreferences is not used here.\n    [self setColorFgBgVariable:[self ansiColorsMatchingForeground:aDict[[self amendedColorKey:KEY_FOREGROUND_COLOR]]\n                                                    andBackground:aDict[[self amendedColorKey:KEY_BACKGROUND_COLOR]]\n                                                       inBookmark:aDict]];\n\n    // transparency\n    [self setTransparency:[iTermProfilePreferences floatForKey:KEY_TRANSPARENCY inProfile:aDict]];\n    [self setTransparencyAffectsOnlyDefaultBackgroundColor:[iTermProfilePreferences floatForKey:KEY_TRANSPARENCY_AFFECTS_ONLY_DEFAULT_BACKGROUND_COLOR inProfile:aDict]];\n\n    // bold\n    [self setUseBoldFont:[iTermProfilePreferences boolForKey:KEY_USE_BOLD_FONT\n                                                   inProfile:aDict]];\n    self.thinStrokes = [iTermProfilePreferences intForKey:KEY_THIN_STROKES inProfile:aDict];\n\n    self.asciiLigatures = [iTermProfilePreferences boolForKey:KEY_ASCII_LIGATURES inProfile:aDict];\n    self.nonAsciiLigatures = [iTermProfilePreferences boolForKey:KEY_NON_ASCII_LIGATURES inProfile:aDict];\n\n    [_textview setUseBoldColor:[iTermProfilePreferences boolForColorKey:KEY_USE_BOLD_COLOR\n                                                                   dark:_screen.colorMap.darkMode\n                                                                profile:aDict]\n                      brighten:[iTermProfilePreferences boolForColorKey:KEY_BRIGHTEN_BOLD_TEXT\n                                                                   dark:_screen.colorMap.darkMode\n                                                                profile:aDict]];\n\n    // Italic - this default has changed from NO to YES as of 1/30/15\n    [self setUseItalicFont:[iTermProfilePreferences boolForKey:KEY_USE_ITALIC_FONT inProfile:aDict]];\n\n    // Set up the rest of the preferences\n    [_screen setAudibleBell:![iTermProfilePreferences boolForKey:KEY_SILENCE_BELL inProfile:aDict]];\n    [_screen setShowBellIndicator:[iTermProfilePreferences boolForKey:KEY_VISUAL_BELL inProfile:aDict]];\n    [_screen setFlashBell:[iTermProfilePreferences boolForKey:KEY_FLASHING_BELL inProfile:aDict]];\n    [_screen setPostUserNotifications:[iTermProfilePreferences boolForKey:KEY_BOOKMARK_USER_NOTIFICATIONS inProfile:aDict]];\n    [_textview setBlinkAllowed:[iTermProfilePreferences boolForKey:KEY_BLINK_ALLOWED inProfile:aDict]];\n    [_screen setCursorBlinks:[iTermProfilePreferences boolForKey:KEY_BLINKING_CURSOR inProfile:aDict]];\n    [_textview setCursorShadow:[iTermProfilePreferences boolForKey:KEY_CURSOR_SHADOW inProfile:aDict]];\n    [_textview setBlinkingCursor:[iTermProfilePreferences boolForKey:KEY_BLINKING_CURSOR inProfile:aDict]];\n    [_textview setCursorType:_cursorTypeOverride ? _cursorTypeOverride.integerValue : [iTermProfilePreferences intForKey:KEY_CURSOR_TYPE inProfile:aDict]];\n\n    PTYTab* currentTab = [[_delegate parentWindow] currentTab];\n    if (currentTab == nil || [_delegate sessionBelongsToVisibleTab]) {\n        [_delegate recheckBlur];\n    }\n\n    [_textview setSmartSelectionRules:aDict[KEY_SMART_SELECTION_RULES]];\n    [_textview setSemanticHistoryPrefs:aDict[KEY_SEMANTIC_HISTORY]];\n    [_textview setUseNonAsciiFont:[iTermProfilePreferences boolForKey:KEY_USE_NONASCII_FONT\n                                                            inProfile:aDict]];\n    [_textview setAntiAlias:[iTermProfilePreferences boolForKey:KEY_ASCII_ANTI_ALIASED\n                                                      inProfile:aDict]\n                   nonAscii:[iTermProfilePreferences boolForKey:KEY_NONASCII_ANTI_ALIASED\n                                                      inProfile:aDict]];\n    [_textview setUseNativePowerlineGlyphs:[iTermProfilePreferences boolForKey:KEY_POWERLINE inProfile:aDict]];\n    [self setEncoding:[iTermProfilePreferences unsignedIntegerForKey:KEY_CHARACTER_ENCODING inProfile:aDict]\n             terminal:terminal];\n    [self setTermVariable:[iTermProfilePreferences stringForKey:KEY_TERMINAL_TYPE inProfile:aDict]\n                 terminal:terminal];\n    [terminal setAnswerBackString:[iTermProfilePreferences stringForKey:KEY_ANSWERBACK_STRING inProfile:aDict]];\n    [self setAntiIdleCode:[iTermProfilePreferences intForKey:KEY_IDLE_CODE inProfile:aDict]];\n    [self setAntiIdlePeriod:[iTermProfilePreferences doubleForKey:KEY_IDLE_PERIOD inProfile:aDict]];\n    [self setAntiIdle:[iTermProfilePreferences boolForKey:KEY_SEND_CODE_WHEN_IDLE inProfile:aDict]];\n    self.endAction = [iTermProfilePreferences unsignedIntegerForKey:KEY_SESSION_END_ACTION inProfile:aDict];\n    [self setTreatAmbiguousWidthAsDoubleWidth:[iTermProfilePreferences boolForKey:KEY_AMBIGUOUS_DOUBLE_WIDTH\n                                                                        inProfile:aDict]];\n    [self setXtermMouseReporting:[iTermProfilePreferences boolForKey:KEY_XTERM_MOUSE_REPORTING\n                                                           inProfile:aDict]];\n    [self setXtermMouseReportingAllowMouseWheel:[iTermProfilePreferences boolForKey:KEY_XTERM_MOUSE_REPORTING_ALLOW_MOUSE_WHEEL\n                                                                          inProfile:aDict]];\n    [self setXtermMouseReportingAllowClicksAndDrags:[iTermProfilePreferences boolForKey:KEY_XTERM_MOUSE_REPORTING_ALLOW_CLICKS_AND_DRAGS\n                                                                              inProfile:aDict]];\n    [self setUnicodeVersion:[iTermProfilePreferences integerForKey:KEY_UNICODE_VERSION\n                                                         inProfile:aDict]];\n    [terminal setDisableSmcupRmcup:[iTermProfilePreferences boolForKey:KEY_DISABLE_SMCUP_RMCUP\n                                                             inProfile:aDict]];\n    [_screen setAllowTitleReporting:[iTermProfilePreferences boolForKey:KEY_ALLOW_TITLE_REPORTING\n                                                              inProfile:aDict]];\n    const BOOL didAllowPasteBracketing = _screen.terminalAllowPasteBracketing;\n    [terminal setAllowPasteBracketing:[iTermProfilePreferences boolForKey:KEY_ALLOW_PASTE_BRACKETING\n                                                                inProfile:aDict]];\n    if (didAllowPasteBracketing && !_screen.terminalAllowPasteBracketing) {\n        // If the user flips the setting off, disable bracketed paste.\n        terminal.bracketedPasteMode = NO;\n    }\n    [terminal setAllowKeypadMode:[iTermProfilePreferences boolForKey:KEY_APPLICATION_KEYPAD_ALLOWED\n                                                           inProfile:aDict]];\n    if ([iTermProfilePreferences boolForKey:KEY_SHOW_STATUS_BAR inProfile:aDict]) {\n        NSDictionary *layout = [iTermProfilePreferences objectForKey:KEY_STATUS_BAR_LAYOUT inProfile:aDict];\n        NSDictionary *existing = _statusBarViewController.layout.dictionaryValue;\n        if (![NSObject object:existing isEqualToObject:layout]) {\n            iTermStatusBarLayout *newLayout = [[[iTermStatusBarLayout alloc] initWithDictionary:layout\n                                                                                          scope:self.variablesScope] autorelease];\n            if (![NSObject object:existing isEqualToObject:newLayout.dictionaryValue]) {\n                [_statusBarViewController release];\n                if (newLayout) {\n                    _statusBarViewController =\n                    [[iTermStatusBarViewController alloc] initWithLayout:newLayout\n                                                                   scope:self.variablesScope];\n                    _statusBarViewController.delegate = self;\n                } else {\n                    _statusBarViewController.delegate = nil;\n                    _statusBarViewController = nil;\n                }\n                [self invalidateStatusBar];\n            }\n        }\n    } else {\n        if (_statusBarViewController && _asyncFilter) {\n            [self stopFiltering];\n        }\n        [_statusBarViewController release];\n        _statusBarViewController = nil;\n        [self invalidateStatusBar];\n    }\n    _tmuxStatusBarMonitor.active = [iTermProfilePreferences boolForKey:KEY_SHOW_STATUS_BAR inProfile:aDict];\n    [_badgeFontName release];\n    _badgeFontName = [[iTermProfilePreferences stringForKey:KEY_BADGE_FONT inProfile:aDict] copy];\n\n    self.badgeFormat = [iTermProfilePreferences stringForKey:KEY_BADGE_FORMAT inProfile:aDict];\n    _badgeLabelSizeFraction = NSMakeSize([iTermProfilePreferences floatForKey:KEY_BADGE_MAX_WIDTH inProfile:aDict],\n                                         [iTermProfilePreferences floatForKey:KEY_BADGE_MAX_HEIGHT inProfile:aDict]);\n\n    self.subtitleFormat = [iTermProfilePreferences stringForKey:KEY_SUBTITLE inProfile:aDict];\n\n    // forces the badge to update\n    _textview.badgeLabel = @\"\";\n    [self updateBadgeLabel];\n    [self setFontTable:[iTermFontTable fontTableForProfile:aDict]\n     horizontalSpacing:[iTermProfilePreferences floatForKey:KEY_HORIZONTAL_SPACING inProfile:aDict]\n       verticalSpacing:[iTermProfilePreferences floatForKey:KEY_VERTICAL_SPACING inProfile:aDict]];\n\n    NSDictionary *shortcutDictionary = [iTermProfilePreferences objectForKey:KEY_SESSION_HOTKEY inProfile:aDict];\n    iTermShortcut *shortcut = [iTermShortcut shortcutWithDictionary:shortcutDictionary];\n    [[iTermSessionHotkeyController sharedInstance] setShortcut:shortcut\n                                                    forSession:self];\n    [[_delegate realParentWindow] invalidateRestorableState];\n\n    const int modifyOtherKeysTerminalSetting = _screen.terminalSendModifiers[4].intValue;\n    if (modifyOtherKeysTerminalSetting == -1) {\n        const BOOL profileWantsTickit = [iTermProfilePreferences boolForKey:KEY_USE_LIBTICKIT_PROTOCOL\n                                                                  inProfile:aDict];\n        self.keyMappingMode = profileWantsTickit ? iTermKeyMappingModeCSIu : iTermKeyMappingModeStandard;\n    }\n\n    if (self.isTmuxClient) {\n        NSDictionary *tabColorDict = [iTermProfilePreferences objectForColorKey:KEY_TAB_COLOR dark:_screen.colorMap.darkMode profile:aDict];\n        if (![iTermProfilePreferences boolForColorKey:KEY_USE_TAB_COLOR dark:_screen.colorMap.darkMode profile:aDict]) {\n            tabColorDict = nil;\n        }\n        NSColor *tabColor = [ITAddressBookMgr decodeColor:tabColorDict];\n        [self.tmuxController setTabColorString:tabColor ? [tabColor hexString] : iTermTmuxTabColorNone\n                                 forWindowPane:self.tmuxPane];\n    }\n    [self.delegate sessionDidChangeGraphic:self\n                                shouldShow:[self shouldShowTabGraphicForProfile:aDict]\n                                     image:[self tabGraphicForProfile:aDict]];\n    [self.delegate sessionUpdateMetalAllowed];\n    [self profileNameDidChangeTo:self.profile[KEY_NAME]];\n}\n\n- (void)setCursorTypeOverride:(NSNumber *)cursorTypeOverride {\n    [_cursorTypeOverride autorelease];\n    _cursorTypeOverride = [cursorTypeOverride retain];\n    _cursorTypeOverrideChanged = YES;\n    [self.textview setCursorType:self.cursorType];\n}\n\n- (ITermCursorType)cursorType {\n    if (_cursorTypeOverride) {\n        return _cursorTypeOverride.integerValue;\n    }\n    return [iTermProfilePreferences intForKey:KEY_CURSOR_TYPE inProfile:_profile];\n}\n\n- (void)invalidateStatusBar {\n    [_view invalidateStatusBar];\n    [_delegate sessionDidInvalidateStatusBar:self];\n}\n\n- (void)setSubtitleFormat:(NSString *)subtitleFormat {\n    if ([subtitleFormat isEqualToString:_subtitleSwiftyString.swiftyString]) {\n        return;\n    }\n    __weak __typeof(self) weakSelf = self;\n    if (!_subtitleSwiftyString) {\n        // Create it with an initially empty string because the delegate will\n        // ask for our subtitle value and it won't be right before\n        // _subtitleSwiftyString is assigned to.\n        _subtitleSwiftyString = [[iTermSwiftyString alloc] initWithString:@\"\"\n                                                                    scope:self.variablesScope\n                                                                 observer:^NSString *(NSString * _Nonnull newValue,\n                                                                                      NSError *error) {\n            if (error) {\n                return [NSString stringWithFormat:@\"\ud83d\udc1e %@\", error.localizedDescription];\n            }\n            __typeof(self) strongSelf = weakSelf;\n            if (strongSelf) {\n                [strongSelf.delegate sessionSubtitleDidChange:strongSelf];\n            }\n            return newValue;\n        }];\n    }\n    _subtitleSwiftyString.swiftyString = subtitleFormat;\n}\n\n- (void)setBadgeFormat:(NSString *)badgeFormat {\n    if ([badgeFormat isEqualToString:_badgeSwiftyString.swiftyString]) {\n        return;\n    }\n    __weak __typeof(self) weakSelf = self;\n    [_badgeSwiftyString invalidate];\n    [_badgeSwiftyString autorelease];\n    _badgeSwiftyString = [[iTermSwiftyString alloc] initWithString:badgeFormat\n                                                             scope:self.variablesScope\n                                                          observer:^NSString *(NSString * _Nonnull newValue, NSError *error) {\n        if (error) {\n            return [NSString stringWithFormat:@\"\ud83d\udc1e %@\", error.localizedDescription];\n        }\n        [weakSelf updateBadgeLabel:newValue];\n        return newValue;\n    }];\n}\n\n- (void)setKeyMappingMode:(iTermKeyMappingMode)mode {\n    _keyMappingMode = mode;\n    [self updateKeyMapper];\n}\n\n- (void)updateKeyMapper {\n    Class mapperClass = [iTermStandardKeyMapper class];\n\n    switch (_keyMappingMode) {\n        case iTermKeyMappingModeStandard:\n            mapperClass = [iTermStandardKeyMapper class];\n            break;\n        case iTermKeyMappingModeCSIu:\n            mapperClass = [iTermTermkeyKeyMapper class];\n            break;\n        case iTermKeyMappingModeRaw:\n            mapperClass = [iTermRawKeyMapper class];\n            break;\n        case iTermKeyMappingModeModifyOtherKeys1:\n            mapperClass = [iTermModifyOtherKeysMapper1 class];\n            break;\n        case iTermKeyMappingModeModifyOtherKeys2:\n            mapperClass = [iTermModifyOtherKeysMapper2 class];\n            break;\n    }\n\n    if (![_keyMapper isKindOfClass:mapperClass]) {\n        [_keyMapper release];\n        _keyMapper = nil;\n\n        id<iTermKeyMapper> keyMapper = [[mapperClass alloc] init];\n        if ([keyMapper respondsToSelector:@selector(setDelegate:)]) {\n            [keyMapper setDelegate:self];\n        }\n        _keyMapper = keyMapper;\n        _textview.keyboardHandler.keyMapper = _keyMapper;\n    }\n    iTermTermkeyKeyMapper *termkey = [iTermTermkeyKeyMapper castFrom:_keyMapper];\n    termkey.flags = _screen.terminalKeyReportingFlags;\n}\n\n- (NSString *)badgeFormat {\n    return _badgeSwiftyString.swiftyString;\n}\n\n- (NSString *)subtitle {\n    return [_subtitleSwiftyString.evaluatedString stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\" \"];\n}\n\n- (BOOL)doesSwiftyString:(iTermSwiftyString *)swiftyString\n          referencePaths:(NSArray<NSString *> *)paths {\n    for (iTermVariableReference *ref in swiftyString.refs) {\n        for (NSString *path in paths) {\n            if ([self.variablesScope variableNamed:path isReferencedBy:ref]) {\n                return YES;\n            }\n        }\n    }\n    return NO;\n}\n\n- (BOOL)checkForCyclesInSwiftyStrings {\n    iTermSwiftyStringGraph *graph = [[[iTermSwiftyStringGraph alloc] init] autorelease];\n    [graph addSwiftyString:_autoNameSwiftyString\n            withFormatPath:iTermVariableKeySessionAutoNameFormat\n            evaluationPath:iTermVariableKeySessionAutoName\n                     scope:self.variablesScope];\n    if (_badgeSwiftyString) {\n        [graph addSwiftyString:_badgeSwiftyString\n                withFormatPath:nil\n                evaluationPath:iTermVariableKeySessionBadge\n                         scope:self.variablesScope];\n    }\n    [self.delegate sessionAddSwiftyStringsToGraph:graph];\n    [graph addEdgeFromPath:iTermVariableKeySessionAutoNameFormat\n                    toPath:iTermVariableKeySessionName\n                     scope:self.variablesScope];\n    return graph.containsCycle;\n}\n\n- (void)updateBadgeLabel {\n    if ([self checkForCyclesInSwiftyStrings]) {\n        [self setBadgeFormat:@\"[Cycle detected]\"];\n        return;\n    }\n    [self updateBadgeLabel:[self badgeLabel]];\n}\n\n- (void)updateBadgeLabel:(NSString *)newValue {\n    _textview.badgeLabel = newValue;\n    [self.variablesScope setValue:newValue forVariableNamed:iTermVariableKeySessionBadge];\n}\n\n- (NSString *)badgeLabel {\n    return _badgeSwiftyString.evaluatedString;\n}\n\n- (BOOL)isAtShellPrompt {\n    return _screen.commandRange.start.x >= 0;\n}\n\n// You're processing if data was read off the socket in the last \"idleTimeSeconds\".\n- (BOOL)isProcessing {\n    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];\n    return (now - _lastOutputIgnoringOutputAfterResizing) < _idleTime;\n}\n\n// You're idle if it's been one second since isProcessing was true.\n- (BOOL)isIdle {\n    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];\n    return (now - _lastOutputIgnoringOutputAfterResizing) > (_idleTime + 1);\n}\n\n- (void)setDelegate:(id<PTYSessionDelegate>)delegate {\n    if ([self isTmuxClient]) {\n        [_tmuxController deregisterWindow:[_delegate tmuxWindow]\n                               windowPane:self.tmuxPane\n                                  session:self];\n    }\n    BOOL needsTermID = (_delegate == nil);\n    _delegate = delegate;\n    if ([self isTmuxClient]) {\n        [_tmuxController registerSession:self\n                                withPane:self.tmuxPane\n                                inWindow:[_delegate tmuxWindow]];\n    }\n    DLog(@\"Fit layout to window on session delegate change\");\n    [_tmuxController fitLayoutToWindows];\n    [self useTransparencyDidChange];\n    [self.variablesScope setValue:[delegate sessionTabVariables]\n                 forVariableNamed:iTermVariableKeySessionTab\n                             weak:YES];\n    if (needsTermID) {\n        [self setTermIDIfPossible];\n    }\n    // useTransparency may have just changed.\n    [self invalidateBlend];\n}\n\n- (NSString *)name {\n    return [self.variablesScope valueForVariableName:iTermVariableKeySessionName] ?: [self.variablesScope valueForVariableName:iTermVariableKeySessionProfileName] ?: @\"Untitled\";\n}\n\n- (void)setIconName:(NSString *)theName {\n    DLog(@\"Assign to autoNameFormat <- %@\", theName);\n    [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionAutoNameFormat: theName ?: [NSNull null],\n                                                    iTermVariableKeySessionIconName: theName ?: [NSNull null] }];\n    [_tmuxTitleMonitor updateOnce];\n    [self.tmuxForegroundJobMonitor updateOnce];\n    _titleDirty = YES;\n}\n\n- (void)setWindowTitle:(NSString *)title {\n    [self.variablesScope setValue:title forVariableNamed:iTermVariableKeySessionWindowName];\n    _titleDirty = YES;\n    [_tmuxTitleMonitor updateOnce];\n    [self.tmuxForegroundJobMonitor updateOnce];\n}\n\n- (BOOL)shouldShowTabGraphic {\n    return [self shouldShowTabGraphicForProfile:self.profile];\n}\n\n- (BOOL)shouldShowTabGraphicForProfile:(Profile *)profile {\n    const iTermProfileIcon icon = [iTermProfilePreferences unsignedIntegerForKey:KEY_ICON inProfile:profile];\n    return icon != iTermProfileIconNone;\n}\n\n- (NSImage *)tabGraphic {\n    return [self tabGraphicForProfile:self.profile];\n}\n\n- (NSImage *)tabGraphicForProfile:(Profile *)profile {\n    const iTermProfileIcon icon = [iTermProfilePreferences unsignedIntegerForKey:KEY_ICON inProfile:profile];\n    switch (icon) {\n        case iTermProfileIconNone:\n            return nil;\n\n        case iTermProfileIconAutomatic:\n            if (self.isTmuxClient) {\n                [_graphicSource updateImageForJobName:self.tmuxForegroundJobMonitor.lastValue\n                                              enabled:[self shouldShowTabGraphicForProfile:profile]];\n            } else {\n                [_graphicSource updateImageForProcessID:[self.variablesScope.effectiveRootPid intValue]\n                                                enabled:[self shouldShowTabGraphicForProfile:profile]\n                                    processInfoProvider:self.processInfoProvider];\n            }\n            return _graphicSource.image;\n\n        case iTermProfileIconCustom:\n            return [self customIconImageForProfile:profile];\n    }\n\n    DLog(@\"Unexpected icon setting %@\", @(icon));\n    return nil;\n}\n\n- (NSImage *)customIconImage {\n    return [self customIconImageForProfile:self.profile];\n}\n\n- (NSImage *)customIconImageForProfile:(Profile *)profile {\n    if (!_customIcon) {\n        _customIcon = [[iTermCacheableImage alloc] init];\n    }\n    NSString *path = [iTermProfilePreferences stringForKey:KEY_ICON_PATH inProfile:profile];\n    BOOL flipped = YES;\n    if (@available(macOS 10.15, *)) {\n        flipped = NO;\n    }\n    return [_customIcon imageAtPath:path ofSize:NSMakeSize(16, 16) flipped:flipped];\n}\n\n- (NSString *)windowTitle {\n    return _nameController.presentationWindowTitle;\n}\n\n- (void)pushWindowTitle {\n    [_nameController pushWindowTitle];\n}\n\n- (void)popWindowTitle {\n    NSString *title = [_nameController popWindowTitle];\n    [self setWindowTitle:title];\n}\n\n- (void)pushIconTitle {\n    [_nameController pushIconTitle];\n}\n\n- (void)popIconTitle {\n    NSString *theName = [_nameController popIconTitle];\n    [self setIconName:theName ?: [iTermProfilePreferences stringForKey:KEY_NAME inProfile:self.profile]];\n}\n\n- (void)userInitiatedReset {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [terminal resetByUserRequest:YES];\n    }];\n    [self updateDisplayBecause:@\"reset terminal\"];\n}\n\n- (void)resetForRelaunch {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        [terminal resetForRelaunch];\n    }];\n}\n\n- (void)setTermVariable:(NSString *)termVariable terminal:(VT100Terminal *)terminal {\n    if (self.isTmuxClient) {\n        return;\n    }\n    [_termVariable autorelease];\n    _termVariable = [termVariable copy];\n    [terminal setTermType:_termVariable];\n}\n\n- (void)setView:(SessionView *)newView {\n    if (_view.searchResultsMinimapViewDelegate == _textview.findOnPageHelper) {\n        _view.searchResultsMinimapViewDelegate = nil;\n    }\n    [_view autorelease];\n    _view = [newView retain];\n    newView.delegate = self;\n    newView.searchResultsMinimapViewDelegate = _textview.findOnPageHelper;\n    newView.driver.dataSource = _metalGlue;\n    [newView updateTitleFrame];\n    [_view setFindDriverDelegate:self];\n    [self updateViewBackgroundImage];\n}\n\n- (NSStringEncoding)encoding {\n    return _screen.terminalEncoding;\n}\n\n- (void)setEncoding:(NSStringEncoding)encoding terminal:(VT100Terminal *)terminal {\n    [terminal setEncoding:encoding];\n}\n\n- (NSString *)tty {\n    return [_shell tty];\n}\n\n- (void)setBackgroundImageMode:(iTermBackgroundImageMode)mode {\n    _backgroundImageMode = mode;\n    [_backgroundDrawingHelper invalidate];\n    [self setBackgroundImagePath:_backgroundImagePath];\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        self.view.imageMode = mode;\n    }\n}\n\n- (void)setBackgroundImagePath:(NSString *)imageFilePath {\n    DLog(@\"setBackgroundImagePath:%@\", imageFilePath);\n    if ([imageFilePath length]) {\n        if ([imageFilePath isAbsolutePath] == NO) {\n            NSBundle *myBundle = [NSBundle bundleForClass:[self class]];\n            imageFilePath = [myBundle pathForResource:imageFilePath ofType:@\"\"];\n            DLog(@\"Not an absolute path. Use bundle-relative path of %@\", imageFilePath);\n        }\n        if ([imageFilePath isEqualToString:_backgroundImagePath]) {\n            DLog(@\"New image path equals existing path, so do nothing.\");\n            return;\n        }\n        [_backgroundImagePath autorelease];\n        _backgroundImagePath = [imageFilePath copy];\n        self.backgroundImage = [[iTermSharedImageStore sharedInstance] imageWithContentsOfFile:_backgroundImagePath];\n    } else {\n        DLog(@\"Clearing abackground image\");\n        self.backgroundImage = nil;\n        [_backgroundImagePath release];\n        _backgroundImagePath = nil;\n    }\n\n    [_patternedImage release];\n    _patternedImage = nil;\n\n    [_textview setNeedsDisplay:YES];\n}\n\n- (CGFloat)effectiveBlend {\n    if (!self.effectiveBackgroundImage) {\n        return 0;\n    }\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return self.desiredBlend;\n    } else {\n        if (self.backgroundImage) {\n            return self.desiredBlend;\n        }\n        // I don't have a background image so inherit the blend setting of the active session.\n        return [self.delegate sessionBlend];\n    }\n}\n\n- (CGFloat)desiredBlend {\n    return [iTermProfilePreferences floatForKey:KEY_BLEND inProfile:self.profile];\n}\n\n- (iTermImageWrapper *)effectiveBackgroundImage {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return _backgroundImage;\n    } else {\n        return [self.delegate sessionBackgroundImage];\n    }\n}\n\n- (iTermBackgroundImageMode)effectiveBackgroundImageMode {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return _backgroundImageMode;\n    } else {\n        return [self.delegate sessionBackgroundImageMode];\n    }\n}\n\n- (BOOL)shouldDrawBackgroundImageManually {\n    return !iTermTextIsMonochrome() || [NSView iterm_takingSnapshot];\n}\n\n- (void)updateViewBackgroundImage {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        DLog(@\"Update per-pane background image\");\n        self.view.image = _backgroundImage;\n        [self.view setImageMode:_backgroundImageMode];\n        [self.view setTerminalBackgroundColor:[self processedBackgroundColor]];\n        return;\n    }\n    self.view.image = nil;\n    [self.view setTerminalBackgroundColor:[self processedBackgroundColor]];\n    [self invalidateBlend];\n    [self.delegate session:self\n        setBackgroundImage:_backgroundImage\n                      mode:_backgroundImageMode\n           backgroundColor:[self processedBackgroundColor]];\n}\n\n- (void)setBackgroundImage:(iTermImageWrapper *)backgroundImage {\n    DLog(@\"setBackgroundImage:%@\", backgroundImage);\n    [_backgroundImage autorelease];\n    _backgroundImage = [backgroundImage retain];\n    [self updateViewBackgroundImage];\n}\n\n- (void)setSmartCursorColor:(BOOL)value {\n    [[self textview] setUseSmartCursorColor:value];\n}\n\n- (void)setMinimumContrast:(float)value {\n    [[self textview] setMinimumContrast:value];\n}\n\n- (BOOL)viewShouldWantLayer {\n    return NO;\n}\n\n- (void)useTransparencyDidChange {\n    // The view does not like getting replaced during the spin of the runloop during which it is created.\n    if (_view.window && _delegate.realParentWindow && _textview) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (_view.window && _delegate.realParentWindow && _textview) {\n                [_delegate sessionTransparencyDidChange];\n                [self invalidateBlend];\n            }\n        });\n    }\n}\n\n- (float)transparency\n{\n    return [_textview transparency];\n}\n\n- (void)setTransparency:(float)transparency {\n    // Limit transparency because fully transparent windows can't be clicked on.\n    if (transparency > 0.9) {\n        transparency = 0.9;\n    }\n    [_textview setTransparency:transparency];\n    [self useTransparencyDidChange];\n    [self invalidateBlend];\n}\n\n- (void)invalidateBlend {\n    [_textview setNeedsDisplay:YES];\n    [self.view setNeedsDisplay:YES];\n    [self.view setTransparencyAlpha:_textview.transparencyAlpha\n                              blend:self.effectiveBlend];\n}\n\n- (void)setTransparencyAffectsOnlyDefaultBackgroundColor:(BOOL)value {\n    [_textview setTransparencyAffectsOnlyDefaultBackgroundColor:value];\n}\n\n- (BOOL)antiIdle {\n    return _antiIdleTimer ? YES : NO;\n}\n\n- (void)setAntiIdle:(BOOL)set {\n    [_antiIdleTimer invalidate];\n    _antiIdleTimer = nil;\n\n    _antiIdlePeriod = MAX(_antiIdlePeriod, kMinimumAntiIdlePeriod);\n\n    if (set) {\n        _antiIdleTimer = [NSTimer scheduledTimerWithTimeInterval:_antiIdlePeriod\n                                                          target:self.weakSelf\n                                                        selector:@selector(doAntiIdle)\n                                                        userInfo:nil\n                                                         repeats:YES];\n    }\n}\n\n- (BOOL)useBoldFont {\n    return [_textview useBoldFont];\n}\n\n- (void)setUseBoldFont:(BOOL)boldFlag\n{\n    [_textview setUseBoldFont:boldFlag];\n}\n\n- (iTermThinStrokesSetting)thinStrokes {\n    return _textview.thinStrokes;\n}\n\n- (void)setThinStrokes:(iTermThinStrokesSetting)thinStrokes {\n    _textview.thinStrokes = thinStrokes;\n}\n\n- (void)setAsciiLigatures:(BOOL)asciiLigatures {\n    _textview.asciiLigatures = asciiLigatures;\n}\n\n- (BOOL)asciiLigatures {\n    return _textview.asciiLigatures;\n}\n\n- (void)setNonAsciiLigatures:(BOOL)nonAsciiLigatures {\n    _textview.nonAsciiLigatures = nonAsciiLigatures;\n}\n\n- (BOOL)nonAsciiLigatures {\n    return _textview.nonAsciiLigatures;\n}\n\n- (BOOL)useItalicFont\n{\n    return [_textview useItalicFont];\n}\n\n- (void)setUseItalicFont:(BOOL)italicFlag\n{\n    [_textview setUseItalicFont:italicFlag];\n}\n\n- (void)setTreatAmbiguousWidthAsDoubleWidth:(BOOL)set {\n    _treatAmbiguousWidthAsDoubleWidth = set;\n    _tmuxController.ambiguousIsDoubleWidth = set;\n}\n\n- (void)setUnicodeVersion:(NSInteger)version {\n    _unicodeVersion = version;\n    _tmuxController.unicodeVersion = version;\n    [[NSNotificationCenter defaultCenter] postNotificationName:iTermUnicodeVersionDidChangeNotification\n                                                        object:nil];\n}\n\n- (void)setXtermMouseReporting:(BOOL)set\n{\n    _xtermMouseReporting = set;\n    [_textview updateCursor:[NSApp currentEvent]];\n}\n\n- (BOOL)logging {\n    return _logging.enabled;\n}\n\n- (void)logStart {\n    __weak __typeof(self) weakSelf = self;\n    [iTermSavePanel asyncShowWithOptions:kSavePanelOptionAppendOrReplace | kSavePanelOptionLogPlainTextAccessory\n                              identifier:@\"StartSessionLog\"\n                        initialDirectory:NSHomeDirectory()\n                         defaultFilename:@\"\"\n                        allowedFileTypes:nil\n                                  window:self.delegate.realParentWindow.window\n                              completion:^(iTermSavePanel *panel) {\n        NSString *path = panel.path;\n        if (path) {\n            BOOL shouldAppend = (panel.replaceOrAppend == kSavePanelReplaceOrAppendSelectionAppend);\n            [weakSelf startLoggingAt:path append:shouldAppend style:panel.loggingStyle];\n        }\n    }];\n}\n\n- (void)startLoggingAt:(NSString *)path append:(BOOL)shouldAppend style:(iTermLoggingStyle)style {\n    [[self loggingHelper] setPath:path\n                          enabled:YES\n                            style:style\n                asciicastMetadata:[self asciicastMetadata]\n                           append:@(shouldAppend)];\n}\n\n- (void)logStop {\n    [_logging stop];\n}\n\n- (void)clearBuffer {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState clearBufferWithoutTriggersSavingPrompt:YES];\n        if (self.isTmuxClient) {\n            [_tmuxController clearHistoryForWindowPane:self.tmuxPane];\n        }\n        if ([iTermAdvancedSettingsModel jiggleTTYSizeOnClearBuffer]) {\n            [self jiggle];\n        }\n        _view.scrollview.ptyVerticalScroller.userScroll = NO;\n    }];\n}\n\n- (void)jiggle {\n    DLog(@\"%@\", [NSThread callStackSymbols]);\n    [self.shell.winSizeController jiggle];\n}\n\n- (void)clearScrollbackBuffer {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState clearScrollbackBuffer];\n    }];\n    if (self.isTmuxClient) {\n        [_tmuxController clearHistoryForWindowPane:self.tmuxPane];\n    }\n}\n\n- (BOOL)shouldSendEscPrefixForModifier:(unsigned int)modmask {\n    if ([self optionKey] == OPT_ESC) {\n        if ((modmask == NSEventModifierFlagOption) ||\n            (modmask & NSLeftAlternateKeyMask) == NSLeftAlternateKeyMask) {\n            return YES;\n        }\n    }\n    if ([self rightOptionKey] == OPT_ESC) {\n        if ((modmask & NSRightAlternateKeyMask) == NSRightAlternateKeyMask) {\n            return YES;\n        }\n    }\n    return NO;\n}\n\n- (void)setScrollViewDocumentView {\n    const BOOL shouldUpdateLayout = (_view.scrollview.documentView == nil && _wrapper != nil);\n    [_view.scrollview setDocumentView:_wrapper];\n    NSRect rect = {\n        .origin = NSZeroPoint,\n        .size = _view.scrollview.contentSize\n    };\n    _wrapper.frame = rect;\n    [_textview refresh];\n    if (shouldUpdateLayout) {\n        DLog(@\"Document view went from nil to %@ so update layout\", _wrapper);\n        [_view updateLayout];\n    }\n}\n\n- (void)setProfile:(Profile *)newProfile {\n    assert(newProfile);\n    DLog(@\"Set profile to one with guid %@\\n%@\", newProfile[KEY_GUID], [NSThread callStackSymbols]);\n\n    NSMutableDictionary *mutableProfile = [[newProfile mutableCopy] autorelease];\n    // This is the most practical way to migrate the bopy of a\n    // profile that's stored in a saved window arrangement. It doesn't get\n    // saved back into the arrangement, unfortunately.\n    [ProfileModel migratePromptOnCloseInMutableBookmark:mutableProfile];\n\n    NSString *originalGuid = newProfile[KEY_ORIGINAL_GUID];\n    if (originalGuid) {\n        // This code path is taken when changing an existing session's profile.\n        // See bug 2632.\n        // It is also taken when you \"new tab with same profile\" and that profile is divorced.\n        Profile *possibleOriginalProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:originalGuid];\n        if (possibleOriginalProfile) {\n            [_originalProfile autorelease];\n            _originalProfile = [possibleOriginalProfile copy];\n        }\n    }\n    if (!_originalProfile) {\n        // This is normally taken when a new session is being created.\n        _originalProfile = [NSDictionary dictionaryWithDictionary:mutableProfile];\n        [_originalProfile retain];\n    }\n\n    [_profile release];\n    _profile = [mutableProfile retain];\n    [self profileNameDidChangeTo:self.profile[KEY_NAME]];\n    [self invalidateBlend];\n    [[_delegate realParentWindow] invalidateRestorableState];\n    [[_delegate realParentWindow] updateTabColors];\n    [_delegate sessionDidUpdatePreferencesFromProfile:self];\n    [_nameController setNeedsUpdate];\n    _profileDidChange = YES;\n    [self sync];\n}\n\n- (NSString *)programType {\n    if ([self.program isEqualToString:[ITAddressBookMgr shellLauncherCommandWithCustomShell:self.customShell]]) {\n        if (self.customShell.length) {\n            return kProgramTypeCustomShell;\n        }\n        return kProgramTypeShellLauncher;\n    }\n    return kProgramTypeCommand;\n}\n\n- (BOOL)encodeArrangementWithContents:(BOOL)includeContents\n                              encoder:(id<iTermEncoderAdapter>)result {\n    return [self encodeArrangementWithContents:includeContents\n                                       encoder:result\n                            replacementProfile:nil\n                                   saveProgram:YES\n                                  pendingJumps:nil];\n}\n\n- (BOOL)encodeArrangementWithContents:(BOOL)includeContents\n                              encoder:(id<iTermEncoderAdapter>)result\n                   replacementProfile:(Profile *)replacementProfile\n                          saveProgram:(BOOL)saveProgram\n                         pendingJumps:(NSArray<iTermSSHReconnectionInfo *> *)pendingJumps {\n    DLog(@\"Construct arrangement for session %@ with includeContents=%@\", self, @(includeContents));\n    if (_filter.length && _liveSession != nil) {\n        DLog(@\"Encode live session because this one is filtered.\");\n        const BOOL ok = [_liveSession encodeArrangementWithContents:includeContents encoder:result];\n        if (ok) {\n            result[SESSION_ARRANGEMENT_FILTER] = _filter;\n        }\n        return ok;\n    }\n    result[SESSION_ARRANGEMENT_COLUMNS] = @(_screen.width);\n    result[SESSION_ARRANGEMENT_ROWS] = @(_screen.height);\n    result[SESSION_ARRANGEMENT_BOOKMARK] = replacementProfile ?: _profile;\n\n    if (_substitutions) {\n        result[SESSION_ARRANGEMENT_SUBSTITUTIONS] = _substitutions;\n    }\n\n    if (saveProgram) {\n        NSString *const programType = [self programType];\n        if ([programType isEqualToString:kProgramTypeCustomShell]) {\n            // The shell launcher command could change from run to run (e.g., if you move iTerm2).\n            // I don't want to use a magic string, so setting program to an empty dict.\n            assert(self.customShell.length);\n            NSDictionary *dict = @{ kProgramType: kProgramTypeCustomShell };\n            dict = [dict dictionaryBySettingObject:self.customShell forKey:kCustomShell];\n            result[SESSION_ARRANGEMENT_PROGRAM] = dict;\n        } else if ([programType isEqualToString:kProgramTypeShellLauncher]) {\n            NSDictionary *dict = @{ kProgramType: kProgramTypeShellLauncher };\n            result[SESSION_ARRANGEMENT_PROGRAM] = dict;\n        } else if ([programType isEqualToString:kProgramTypeCommand] &&\n                   self.program) {\n            result[SESSION_ARRANGEMENT_PROGRAM] = @{ kProgramType: kProgramTypeCommand,\n                                                     kProgramCommand: self.program };\n        }\n    }\n    if (pendingJumps) {\n        result[SESSION_ARRANGEMENT_PENDING_JUMPS] = [pendingJumps mapWithBlock:^id _Nullable(iTermSSHReconnectionInfo * _Nonnull info) {\n            return [info serialized];\n        }];\n    }\n    result[SESSION_ARRANGEMENT_KEYLABELS] = _keyLabels ?: @{};\n    result[SESSION_ARRANGEMENT_KEYLABELS_STACK] = [_keyLabelsStack mapWithBlock:^id(iTermKeyLabels *anObject) {\n        return anObject.dictionaryValue;\n    }];\n    result[SESSION_ARRANGEMENT_ENVIRONMENT] = self.environment ?: @{};\n    result[SESSION_ARRANGEMENT_IS_UTF_8] = @(self.isUTF8);\n    result[SESSION_ARRANGEMENT_SHORT_LIVED_SINGLE_USE] = @(self.shortLivedSingleUse);\n    if (self.hostnameToShell) {\n        result[SESSION_ARRANGEMENT_HOSTNAME_TO_SHELL] = [[self.hostnameToShell copy] autorelease];\n    }\n\n    NSDictionary *shortcutDictionary = [[[iTermSessionHotkeyController sharedInstance] shortcutForSession:self] dictionaryValue];\n    if (shortcutDictionary) {\n        result[SESSION_ARRANGEMENT_HOTKEY] = shortcutDictionary;\n    }\n\n    result[SESSION_ARRANGEMENT_NAME_CONTROLLER_STATE] = [_nameController stateDictionary];\n    if (includeContents) {\n        __block int numberOfLinesDropped = 0;\n        [result encodeDictionaryWithKey:SESSION_ARRANGEMENT_CONTENTS\n                             generation:iTermGenerationAlwaysEncode\n                                  block:^BOOL(id<iTermEncoderAdapter>  _Nonnull encoder) {\n            return [_screen encodeContents:encoder linesDropped:&numberOfLinesDropped];\n        }];\n        result[SESSION_ARRANGEMENT_VARIABLES] = _variables.encodableDictionaryValue;\n        result[SESSION_ARRANGEMENT_ALERT_ON_NEXT_MARK] = @(_alertOnNextMark);\n        result[SESSION_ARRANGEMENT_CURSOR_GUIDE] = @(_textview.highlightCursorLine);\n        result[SESSION_ARRANGEMENT_CURSOR_TYPE_OVERRIDE] = self.cursorTypeOverride;\n        if (self.lastDirectory) {\n            DLog(@\"Saving arrangement for %@ with lastDirectory of %@\", self, self.lastDirectory);\n            result[SESSION_ARRANGEMENT_LAST_DIRECTORY] = self.lastDirectory;\n        }\n        if (self.lastLocalDirectory) {\n            result[SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY] = self.lastLocalDirectory;\n            result[SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY_WAS_PUSHED] = @(self.lastLocalDirectoryWasPushed);\n        }\n        result[SESSION_ARRANGEMENT_SELECTION] =\n        [self.textview.selection dictionaryValueWithYOffset:-numberOfLinesDropped\n                                    totalScrollbackOverflow:_screen.totalScrollbackOverflow];\n        result[SESSION_ARRANGEMENT_APS] = [_automaticProfileSwitcher savedState];\n        result[SESSION_ARRANGEMENT_SSH_STATE] = @(_sshState);\n        if (_conductor) {\n            NSString *json = _conductor.jsonValue;\n            if (json) {\n                result[SESSION_ARRANGEMENT_CONDUCTOR] = json;\n            }\n        }\n    } else {\n        if (_conductor &&\n            [self.profile[KEY_CUSTOM_COMMAND] isEqualTo:kProfilePreferenceCommandTypeSSHValue]) {\n            result[SESSION_ARRANGEMENT_PENDING_JUMPS] = [self.sshCommandLineSequence mapWithBlock:^id _Nullable(iTermSSHReconnectionInfo * _Nonnull anObject) {\n                return anObject.serialized;\n            }];\n        }\n    }\n    result[SESSION_ARRANGEMENT_GUID] = _guid;\n    if (_liveSession && includeContents && !_dvr) {\n        [result encodeDictionaryWithKey:SESSION_ARRANGEMENT_LIVE_SESSION\n                             generation:iTermGenerationAlwaysEncode\n                                  block:^BOOL(id<iTermEncoderAdapter>  _Nonnull encoder) {\n            return [_liveSession encodeArrangementWithContents:includeContents\n                                                       encoder:encoder];\n        }];\n    }\n    DLog(@\"self.isTmuxClient=%@\", @(self.isTmuxClient));\n    if (includeContents && !self.isTmuxClient) {\n        DLog(@\"Can include restoration info. runJobsInServers=%@ isSessionRestorationPossible=%@\",\n             @([iTermAdvancedSettingsModel runJobsInServers]),\n             @(_shell.isSessionRestorationPossible));\n        // These values are used for restoring sessions after a crash. It's only saved when contents\n        // are included since saved window arrangements have no business knowing the process id.\n        if ([iTermAdvancedSettingsModel runJobsInServers] && _shell.isSessionRestorationPossible) {\n            NSObject *restorationIdentifier = _shell.sessionRestorationIdentifier;\n            DLog(@\"Can save restoration id. restorationIdentifier=%@\", restorationIdentifier);\n            if ([restorationIdentifier isKindOfClass:[NSNumber class]]) {\n                result[SESSION_ARRANGEMENT_SERVER_PID] = restorationIdentifier;\n            } else if ([restorationIdentifier isKindOfClass:[NSDictionary class]]) {\n                result[SESSION_ARRANGEMENT_SERVER_DICT] = restorationIdentifier;\n            }\n            if (self.tty) {\n                result[SESSION_ARRANGEMENT_TTY] = self.tty;\n            }\n        }\n    }\n    if (_logging.enabled) {\n        result[SESSION_ARRANGEMENT_AUTOLOG_FILENAME] = _logging.path;\n    }\n    if (_cookie) {\n        result[SESSION_ARRANGEMENT_REUSABLE_COOKIE] = _cookie;\n    }\n    if (_overriddenFields.count > 0) {\n        if (replacementProfile) {\n            NSMutableSet<NSString *> *combinedOverriddenFields = [[_overriddenFields mutableCopy] autorelease];\n            for (NSString *key in [[NSSet setWithArray:[_profile allKeys]] setByAddingObjectsFromSet:[NSSet setWithArray:[replacementProfile allKeys]]]) {\n                id mine = _profile[key];\n                id theirs = replacementProfile[key];\n                if (![NSObject object:mine isEqualToObject:theirs]) {\n                    [combinedOverriddenFields addObject:key];\n                }\n            }\n            result[SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS] = combinedOverriddenFields;\n            DLog(@\"Combined overridden fields are: %@\", combinedOverriddenFields);\n        } else {\n            result[SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS] = _overriddenFields.allObjects;\n        }\n    }\n    if (self.tmuxMode == TMUX_GATEWAY && self.tmuxController.sessionName) {\n        result[SESSION_ARRANGEMENT_IS_TMUX_GATEWAY] = @YES;\n        result[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_ID] = @(self.tmuxController.sessionId);\n        result[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_NAME] = self.tmuxController.sessionName;\n        NSString *dcsID = [[self.tmuxController.gateway.dcsID copy] autorelease];\n        if (dcsID) {\n            result[SESSION_ARRANGEMENT_TMUX_DCS_ID] = dcsID;\n        }\n    }\n    if ( _conductor) {\n        result[SESSION_ARRANGEMENT_CONDUCTOR_DCS_ID] = _conductor.dcsID;\n        result[SESSION_ARRANGEMENT_CONDUCTOR_TREE] = _conductor.tree.it_keyValueCodedData;\n    }\n\n    result[SESSION_ARRANGEMENT_SHOULD_EXPECT_PROMPT_MARKS] = @(_screen.shouldExpectPromptMarks);\n    result[SESSION_ARRANGEMENT_SHOULD_EXPECT_CURRENT_DIR_UPDATES] = @(_shouldExpectCurrentDirUpdates);\n    result[SESSION_ARRANGEMENT_WORKING_DIRECTORY_POLLER_DISABLED] = @(_workingDirectoryPollerDisabled);\n    result[SESSION_ARRANGEMENT_COMMANDS] = _commands;\n    result[SESSION_ARRANGEMENT_DIRECTORIES] = _directories;\n    // If this is slow, it could be encoded more efficiently by using encodeArrayWithKey:...\n    // but that would require coming up with a good unique identifier.\n    result[SESSION_ARRANGEMENT_HOSTS] = [_hosts mapWithBlock:^id(id anObject) {\n        return [(id<VT100RemoteHostReading>)anObject dictionaryValue];\n    }];\n\n    NSString *pwd = [self currentLocalWorkingDirectory];\n    result[SESSION_ARRANGEMENT_WORKING_DIRECTORY] = pwd ? pwd : @\"\";\n    return YES;\n}\n\n+ (NSDictionary *)arrangementFromTmuxParsedLayout:(NSDictionary *)parseNode\n                                         bookmark:(Profile *)bookmark\n                                   tmuxController:(TmuxController *)tmuxController\n                                           window:(int)window {\n    NSMutableDictionary* result = [NSMutableDictionary dictionaryWithCapacity:3];\n    [result setObject:[parseNode objectForKey:kLayoutDictWidthKey] forKey:SESSION_ARRANGEMENT_COLUMNS];\n    [result setObject:[parseNode objectForKey:kLayoutDictHeightKey] forKey:SESSION_ARRANGEMENT_ROWS];\n    [result setObject:bookmark forKey:SESSION_ARRANGEMENT_BOOKMARK];\n    [result setObject:@\"\" forKey:SESSION_ARRANGEMENT_WORKING_DIRECTORY];\n    [result setObject:[parseNode objectForKey:kLayoutDictWindowPaneKey] forKey:SESSION_ARRANGEMENT_TMUX_PANE];\n    result[SESSION_ARRANGEMENT_TMUX_FOCUS_REPORTING] = parseNode[kLayoutDictFocusReportingKey] ?: @NO;\n    NSDictionary *hotkey = parseNode[kLayoutDictHotkeyKey];\n    if (hotkey) {\n        [result setObject:hotkey forKey:SESSION_ARRANGEMENT_HOTKEY];\n    }\n    NSObject *value = [parseNode objectForKey:kLayoutDictHistoryKey];\n    if (value) {\n        [result setObject:value forKey:SESSION_ARRANGEMENT_TMUX_HISTORY];\n    }\n    value = [parseNode objectForKey:kLayoutDictAltHistoryKey];\n    if (value) {\n        [result setObject:value forKey:SESSION_ARRANGEMENT_TMUX_ALT_HISTORY];\n    }\n    value = [parseNode objectForKey:kLayoutDictStateKey];\n    if (value) {\n        [result setObject:value forKey:SESSION_ARRANGEMENT_TMUX_STATE];\n    }\n    value = parseNode[kLayoutDictTabColorKey];\n    if (value) {\n        result[SESSION_ARRANGEMENT_TMUX_TAB_COLOR] = value;\n    }\n    NSDictionary *fontOverrides = [tmuxController fontOverridesForWindow:window];\n    if (fontOverrides) {\n        result[SESSION_ARRANGEMENT_FONT_OVERRIDES] = fontOverrides;\n    }\n    NSDictionary *keyboardMapOverrides = tmuxController.sharedKeyMappingOverrides;\n    if (keyboardMapOverrides) {\n        result[SESSION_ARRANGEMENT_KEYBOARD_MAP_OVERRIDES] = [[keyboardMapOverrides copy] autorelease];\n    }\n    return result;\n}\n\n+ (NSString *)guidInArrangement:(NSDictionary *)arrangement {\n    NSString *guid = arrangement[SESSION_ARRANGEMENT_GUID];\n    if (guid) {\n        return guid;\n    } else {\n        return arrangement[SESSION_UNIQUE_ID];\n    }\n}\n\n+ (NSString *)initialWorkingDirectoryFromArrangement:(NSDictionary *)arrangement {\n    return arrangement[SESSION_ARRANGEMENT_WORKING_DIRECTORY];\n}\n\n- (BOOL)shouldUpdateTitles:(NSTimeInterval)now {\n    // Update window info for the active tab.\n    if (!self.jobName) {\n        return YES;\n    }\n    if ([self.processInfoProvider processIsDirty:_shell.pid]) {\n        DLog(@\"Update title immediately because process %@ is dirty\", @(_shell.pid));\n        return YES;\n    }\n\n    static const NSTimeInterval dirtyTitlePeriod = 0.02;\n    static const NSTimeInterval pollingTitlePeriod = 0.7;\n    const NSTimeInterval elapsedTime = now - _lastUpdate;\n    const NSTimeInterval deadline = _titleDirty ? dirtyTitlePeriod : pollingTitlePeriod;\n    if (elapsedTime >= deadline) {\n        return YES;\n    }\n\n    return NO;\n}\n\n- (void)maybeUpdateTitles {\n    const NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];\n    if ([self shouldUpdateTitles:now]) {\n        [self updateTitles];\n        _lastUpdate = now;\n        _titleDirty = NO;\n    }\n}\n\n- (void)updateDisplayBecause:(NSString *)reason {\n    DLog(@\"updateDisplayBecause:%@ %@\", reason, _cadenceController);\n    _updateCount++;\n    if (_useMetal && _updateCount % 10 == 0) {\n        iTermPreciseTimerSaveLog([NSString stringWithFormat:@\"%@: updateDisplay interval\", _view.driver.identifier],\n                                 _cadenceController.histogram.stringValue);\n    }\n    _timerRunning = YES;\n\n    // This syncs with the mutation thread.\n    DLog(@\"Session %@ calling refresh\", self);\n    const BOOL somethingIsBlinking = [_textview refresh];\n\n    // Set attributes of tab to indicate idle, processing, etc.\n    if (![self isTmuxGateway]) {\n        [_delegate updateLabelAttributes];\n    }\n\n    if ([_delegate sessionIsActiveInTab:self]) {\n        [self maybeUpdateTitles];\n    } else {\n        [self setCurrentForegroundJobProcessInfo:[self.sessionProcessInfoProvider cachedProcessInfoIfAvailable]];\n        [self.view setTitle:_nameController.presentationSessionTitle];\n    }\n\n    const BOOL transientTitle = _delegate.realParentWindow.isShowingTransientTitle;\n    const BOOL animationPlaying = _textview.getAndResetDrawingAnimatedImageFlag;\n\n    // Even if \"active\" isn't changing we need the side effect of setActive: that updates the\n    // cadence since we might have just become idle.\n    self.active = (somethingIsBlinking || transientTitle || animationPlaying);\n\n    if (_tailFindTimer && _view.findViewIsHidden && !_performingOneShotTailFind) {\n        [self stopTailFind];\n    }\n\n    const BOOL passwordInput = _shell.passwordInput || _conductor.atPasswordPrompt;\n    DLog(@\"passwordInput=%@\", @(passwordInput));\n    if (passwordInput != _passwordInput) {\n        _passwordInput = passwordInput;\n        [[iTermSecureKeyboardEntryController sharedInstance] update];\n        if (passwordInput) {\n            [self didBeginPasswordInput];\n        }\n    }\n    _timerRunning = NO;\n}\n\n- (BOOL)shouldShowPasswordManagerAutomatically {\n    return [iTermProfilePreferences boolForKey:KEY_OPEN_PASSWORD_MANAGER_AUTOMATICALLY\n                                     inProfile:self.profile];\n}\n\n- (void)didBeginPasswordInput {\n    if ([self shouldShowPasswordManagerAutomatically]) {\n        iTermApplicationDelegate *itad = [iTermApplication.sharedApplication delegate];\n        [itad openPasswordManagerToAccountName:nil inSession:self];\n\n    }\n}\n\n// Update the tab, session view, and window title.\n- (void)updateTitles {\n    DLog(@\"updateTitles\");\n    iTermProcessInfo *processInfo = [self.sessionProcessInfoProvider cachedProcessInfoIfAvailable];\n    iTermProcessInfo *effectiveProcessInfo = processInfo;\n    if (!processInfo && _titleDirty) {\n        // It's an emergency. Use whatever is lying around.\n        DLog(@\"Performing emergency title update\");\n        effectiveProcessInfo = _lastProcessInfo;\n    }\n    if (effectiveProcessInfo) {\n        [_lastProcessInfo autorelease];\n        _lastProcessInfo = [effectiveProcessInfo retain];\n        [self updateTitleWithProcessInfo:effectiveProcessInfo];\n\n        if (processInfo) {\n            return;\n        }\n    }\n    __weak __typeof(self) weakSelf = self;\n    [self.sessionProcessInfoProvider fetchProcessInfoForCurrentJobWithCompletion:^(iTermProcessInfo *processInfo) {\n        [weakSelf updateTitleWithProcessInfo:processInfo];\n    }];\n}\n\n- (void)updateTitleWithProcessInfo:(iTermProcessInfo *)processInfo {\n    DLog(@\"%@ Job for pid %@ is %@, pid=%@\", self, @(_shell.pid), processInfo.name, @(processInfo.processID));\n    [self setCurrentForegroundJobProcessInfo:processInfo];\n\n    if ([_delegate sessionBelongsToVisibleTab]) {\n        // Revert to the permanent tab title.\n        DLog(@\"Session asking to set window title. Parent window is %@\", [_delegate parentWindow]);\n        [[_delegate parentWindow] setWindowTitle];\n    }\n}\n\n- (NSString *)jobName {\n    return [self.variablesScope valueForVariableName:iTermVariableKeySessionJob];\n}\n\n- (void)setCurrentForegroundJobProcessInfo:(iTermProcessInfo *)processInfo {\n    DLog(@\"%p set job name to %@\", self, processInfo.name);\n    NSString *name = processInfo.name;\n    NSString *processTitle = processInfo.argv0 ?: name;\n\n    // This is a gross hack but I haven't found a nicer way to do it yet. When exec fails (or takes\n    // enough time that we happen to poll it before exec finishes) then the job name is\n    // \"iTermServer\" as inherited from the parent. This avoids showing it in the UI.\n    if ([name isEqualToString:@\"iTermServer\"] && ![[self.program lastPathComponent] isEqualToString:name]) {\n        name = self.program.lastPathComponent;\n        processTitle = name;\n    }\n    [self.variablesScope setValue:name forVariableNamed:iTermVariableKeySessionJob];\n    [self.variablesScope setValue:processTitle forVariableNamed:iTermVariableKeySessionProcessTitle];\n    [self.variablesScope setValue:processInfo.commandLine forVariableNamed:iTermVariableKeySessionCommandLine];\n    [self.variablesScope setValue:@(processInfo.processID) forVariableNamed:iTermVariableKeySessionJobPid];\n\n    NSNumber *effectiveShellPID = _shell.tmuxClientProcessID ?: @(_shell.pid);\n    if (!_exited) {\n        if (effectiveShellPID.intValue > 0) {\n            [self.variablesScope setValue:effectiveShellPID\n                         forVariableNamed:iTermVariableKeySessionChildPid];\n        }\n        id oldValue = [self.variablesScope valueForVariableName:iTermVariableKeySessionEffectiveSessionRootPid];\n        if (_conductor.framing) {\n            [self.variablesScope setValue:_conductor.framedPID\n                         forVariableNamed:iTermVariableKeySessionEffectiveSessionRootPid];\n        } else if (effectiveShellPID.intValue > 0) {\n            [self.variablesScope setValue:effectiveShellPID\n                         forVariableNamed:iTermVariableKeySessionEffectiveSessionRootPid];\n        }\n        id newValue = [self.variablesScope valueForVariableName:iTermVariableKeySessionEffectiveSessionRootPid];\n        const BOOL changed = ![NSObject object:oldValue isEqualToObject:newValue];\n        if (changed) {\n            [self.delegate sessionProcessInfoProviderDidChange:self];\n        }\n    }\n    // Avoid join from side-effect.\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf tryAutoProfileSwitchWithHostname:weakSelf.variablesScope.hostname\n                                          username:weakSelf.variablesScope.username\n                                              path:weakSelf.variablesScope.path\n                                               job:processInfo.name];\n    });\n}\n\n- (void)refresh {\n    DLog(@\"Session %@ calling refresh\", self);\n    if ([_textview refresh]) {\n        self.active = YES;\n    }\n}\n\n- (void)setActive:(BOOL)active {\n    DLog(@\"setActive:%@ timerRunning=%@ updateTimer.isValue=%@ lastTimeout=%f session=%@\",\n         @(active), @(_timerRunning), @(_cadenceController.updateTimerIsValid), _lastTimeout, self);\n    _active = active;\n    _activityInfo.lastActivity = [NSDate it_timeSinceBoot];\n    [_cadenceController changeCadenceIfNeeded];\n}\n\n- (void)doAntiIdle {\n    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];\n\n    if (![self isTmuxGateway] && now >= _lastInput + _antiIdlePeriod - kAntiIdleGracePeriod) {\n        // This feature is hopeless for tmux gateways. Issue 5231.\n        [self writeLatin1EncodedData:[NSData dataWithBytes:&_antiIdleCode length:1] broadcastAllowed:NO reporting:NO];\n        _lastInput = now;\n    }\n}\n\n- (BOOL)canInstantReplayPrev\n{\n    if (_dvrDecoder) {\n        return [_dvrDecoder timestamp] != [_dvr firstTimeStamp];\n    } else {\n        return YES;\n    }\n}\n\n- (BOOL)canInstantReplayNext\n{\n    if (_dvrDecoder) {\n        return YES;\n    } else {\n        return NO;\n    }\n}\n\n- (int)rows\n{\n    return [_screen height];\n}\n\n- (int)columns\n{\n    return [_screen width];\n}\n\n- (NSFont *)fontWithRelativeSize:(int)dir from:(NSFont*)font {\n    return [font it_fontByAddingToPointSize:dir];\n}\n\n- (void)setFontTable:(iTermFontTable *)newFontTable\n   horizontalSpacing:(CGFloat)horizontalSpacing\n     verticalSpacing:(CGFloat)verticalSpacing {\n    DLog(@\"setFontTable:%@ horizontalSpacing:%@ verticalSpacing:%@\",\n         newFontTable, @(horizontalSpacing), @(verticalSpacing));\n    NSWindow *window = [[_delegate realParentWindow] window];\n    DLog(@\"Before:\\n%@\", [window.contentView iterm_recursiveDescription]);\n    DLog(@\"Window frame: %@\", window);\n    if ([_textview.fontTable isEqual:newFontTable] &&\n        [_textview horizontalSpacing] == horizontalSpacing &&\n        [_textview verticalSpacing] == verticalSpacing) {\n        // There's an unfortunate problem that this is a band-aid over.\n        // If you change some attribute of a profile that causes sessions to reload their profiles\n        // with the kReloadAllProfiles notification, then each profile will call this in turn,\n        // and it may be a no-op for all of them. If each calls -[PseudoTerminal fitWindowToTab:_delegate]\n        // and different tabs come up with slightly different ideal sizes (e.g., because they\n        // have different split pane layouts) then the window may shrink by a few pixels for each\n        // session.\n        return;\n    }\n    DLog(@\"Line height was %f\", [_textview lineHeight]);\n    [_textview setFontTable:newFontTable\n          horizontalSpacing:horizontalSpacing\n            verticalSpacing:verticalSpacing];\n    DLog(@\"Line height is now %f\", [_textview lineHeight]);\n    [_delegate sessionDidChangeFontSize:self adjustWindow:!_windowAdjustmentDisabled];\n    [_composerManager updateFont];\n    DLog(@\"After:\\n%@\", [window.contentView iterm_recursiveDescription]);\n    DLog(@\"Window frame: %@\", window);\n\n    [_view updateTrackingAreas];\n}\n\n- (BOOL)shouldShowAutoComposer {\n    if (![iTermPreferences boolForKey:kPreferenceAutoComposer]) {\n        DLog(@\"wantAutoComposer: Disabled by setting\");\n        return NO;\n    }\n    return _promptStateAllowsAutoComposer;\n}\n\n- (void)dismissComposerIfEmpty {\n    DLog(@\"dismissComposerIfEmpty called on %@\", [NSThread currentThread]);\n    if (self.composerManager.isEmpty) {\n        DLog(@\"dismissComposerifEmpty calling dismissAnimated\");\n        [self.composerManager dismissAnimated:NO];\n    }\n    DLog(@\"dismissComposerIfEmpty returning\");\n}\n\n- (void)autoComposerDidChange:(NSNotification *)notification {\n    [self sync];\n}\n\nstatic NSString *const PTYSessionComposerPrefixUserDataKeyPrompt = @\"prompt\";\nstatic NSString *const PTYSessionComposerPrefixUserDataKeyDetectedByTrigger = @\"detected by trigger\";\n\n- (NSMutableAttributedString *)kernedAttributedStringForScreenChars:(NSArray<ScreenCharArray *> *)promptText {\n    NSMutableAttributedString *prompt = [self attributedStringForScreenChars:promptText];\n    const CGFloat kern = [NSMutableAttributedString kernForString:@\"W\"\n                                                      toHaveWidth:_textview.charWidth\n                                                         withFont:_textview.fontTable.asciiFont.font];\n    [prompt addAttributes:@{ NSKernAttributeName: @(kern) }\n                    range:NSMakeRange(0, prompt.length)];\n    return prompt;\n}\n\n- (void)revealAutoComposerWithPrompt:(NSArray<ScreenCharArray *> *)promptText {\n    assert(_initializationFinished);\n    DLog(@\"Reveal auto composer. isAutoComposer <- YES\");\n    self.composerManager.isAutoComposer = YES;\n    NSMutableAttributedString *prompt = [self kernedAttributedStringForScreenChars:promptText];\n    [self.composerManager reveal];\n    NSDictionary *userData = nil;\n    DLog(@\"revealing auto composer\");\n    if (_screen.lastPromptMark.promptText) {\n        DLog(@\"Set prefix to %@\", prompt.string);\n        userData = @{\n            PTYSessionComposerPrefixUserDataKeyPrompt: [[_screen.lastPromptMark.promptText copy] autorelease],\n            PTYSessionComposerPrefixUserDataKeyDetectedByTrigger: @(_screen.lastPromptMark.promptDetectedByTrigger)\n        };\n    }\n    [self.composerManager setPrefix:prompt\n                           userData:userData];\n}\n\n- (NSMutableAttributedString *)attributedStringForScreenChars:(NSArray<ScreenCharArray *> *)promptText {\n    if (!_textview) {\n        return nil;\n    }\n    NSDictionary *defaultAttributes = [_textview attributeProviderUsingProcessedColors:YES]((screen_char_t){}, nil);\n    NSAttributedString *space = [NSAttributedString attributedStringWithString:@\" \"\n                                                                      attributes:defaultAttributes];\n\n    NSAttributedString *newline = [NSAttributedString attributedStringWithString:@\"\\n\"\n                                                                      attributes:defaultAttributes];\n\n    NSMutableAttributedString *result = [[[NSMutableAttributedString alloc] init] autorelease];\n    NSAttributedString *body = [[promptText mapWithBlock:^id _Nullable(ScreenCharArray *sca) {\n        return [sca attributedStringValueWithAttributeProvider:[_textview attributeProviderUsingProcessedColors:YES]];\n    }] attributedComponentsJoinedByAttributedString:newline];\n    [result appendAttributedString:body];\n    [result trimTrailingWhitespace];\n    [result appendAttributedString:space];\n    return result;\n}\n\n- (void)terminalFileShouldStop:(NSNotification *)notification {\n    if ([notification object] == _download) {\n        [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                 VT100ScreenMutableState *mutableState,\n                                                 id<VT100ScreenDelegate> delegate) {\n            [terminal stopReceivingFile];\n            [_download endOfData];\n            self.download = nil;\n        }];\n    } else if ([notification object] == _upload) {\n        [_pasteHelper abort];\n        [_upload endOfData];\n        self.upload = nil;\n        char controlC[1] = { VT100CC_ETX };\n        NSData *data = [NSData dataWithBytes:controlC length:sizeof(controlC)];\n        [self writeLatin1EncodedData:data broadcastAllowed:NO reporting:NO];\n    }\n}\n\n- (void)profileSessionNameDidEndEditing:(NSNotification *)notification {\n    NSString *theGuid = [notification object];\n    if (_tmuxTitleOutOfSync &&\n        [self isTmuxClient] &&\n        [theGuid isEqualToString:_profile[KEY_GUID]]) {\n        Profile *profile = [[ProfileModel sessionsInstance] bookmarkWithGuid:theGuid];\n        if (_tmuxController.canRenamePane) {\n            [_tmuxController renamePane:self.tmuxPane toTitle:profile[KEY_NAME]];\n            [_tmuxTitleMonitor updateOnce];\n        } else {\n            // Legacy code path for pre tmux 2.6\n            [_tmuxController renameWindowWithId:_delegate.tmuxWindow\n                                inSessionNumber:nil\n                                         toName:profile[KEY_NAME]];\n        }\n        _tmuxTitleOutOfSync = NO;\n    }\n}\n\n- (void)sessionHotkeyDidChange:(NSNotification *)notification {\n    NSString *theGuid = [notification object];\n    if ([self isTmuxClient] &&\n        [theGuid isEqualToString:_profile[KEY_GUID]]) {\n        Profile *profile = [[ProfileModel sessionsInstance] bookmarkWithGuid:theGuid];\n        NSDictionary *dict = [iTermProfilePreferences objectForKey:KEY_SESSION_HOTKEY inProfile:profile];\n        [_tmuxController setHotkeyForWindowPane:self.tmuxPane to:dict];\n    }\n}\n\n- (void)apiDidStop:(NSNotification *)notification {\n    [_promptSubscriptions removeAllObjects];\n    [_keystrokeSubscriptions removeAllObjects];\n    [_keyboardFilterSubscriptions removeAllObjects];\n    [_updateSubscriptions removeAllObjects];\n    [_customEscapeSequenceNotifications removeAllObjects];\n}\n\n- (void)apiServerUnsubscribe:(NSNotification *)notification {\n    [_promptSubscriptions removeObjectForKey:notification.object];\n    [_keystrokeSubscriptions removeObjectForKey:notification.object];\n    [_keyboardFilterSubscriptions removeObjectForKey:notification.object];\n    [_updateSubscriptions removeObjectForKey:notification.object];\n    [_customEscapeSequenceNotifications removeObjectForKey:notification.object];\n}\n\n- (void)applicationWillTerminate:(NSNotification *)notification {\n    // See comment where we observe this notification for why this is done.\n    [self tmuxDetach];\n}\n\n- (void)applicationDidResignActive:(NSNotification *)notification {\n    DLog(@\"%@\", self);\n    // Avoid posting a notification after switching to another app for output received just\n    // before the switch. This is tricky! self.newOutput can't be reset unconditionally because\n    // doing so breaks idle notifications when new output eventually stops being received.\n    // If you have new output and you haven't already posted a new-output notification then\n    // you can be confident that an idle notification is not forthcoming and then you can\n    // safely reset newOutput.\n    if (self.newOutput && [self.delegate sessionIsInSelectedTab:self] && !self.havePostedNewOutputNotification) {\n        DLog(@\"self.newOutput = NO\");\n        self.newOutput = NO;\n    }\n}\n\n- (void)refreshTerminal:(NSNotification *)notification {\n    [self sync];\n}\n\n- (void)metalClipViewWillScroll:(NSNotification *)notification {\n    if (_useMetal && notification.object == _textview.enclosingScrollView.contentView) {\n        [_textview shiftTrackingChildWindows];\n    }\n}\n\n- (void)alertOnMarksinOffscreenSessionsDidChange:(NSNotification *)notification {\n    DLog(@\"alertOnMarksinOffscreenSessionsDidChange for %@\", self);\n    _alertOnMarksinOffscreenSessions = [iTermPreferences boolForKey:kPreferenceKeyAlertOnMarksInOffscreenSessions];\n    [self sync];\n}\n\n- (void)windowDidMiniaturize:(NSNotification *)notification {\n    DLog(@\"windowDidMiniaturize for %@\", self);\n    if (_alertOnMarksinOffscreenSessions) {\n        [self sync];\n    }\n}\n\n- (void)activeSpaceDidChange:(NSNotification *)notification {\n    DLog(@\"activeSpaceDidChange for %@\", self);\n    if (_alertOnMarksinOffscreenSessions) {\n        [self sync];\n    }\n}\n\n- (void)savedArrangementWasRepaired:(NSNotification *)notification {\n    if ([notification.object isEqual:_naggingController.missingSavedArrangementProfileGUID]) {\n        Profile *newProfile = notification.userInfo[@\"new profile\"];\n        [self setIsDivorced:NO withDecree:@\"Saved arrangement was repaired. Set divorced to NO.\"];\n        DLog(@\"saved arrangement repaired, remove all overridden fields\");\n        [_overriddenFields removeAllObjects];\n        [_originalProfile release];\n        _originalProfile = nil;\n        self.profile = newProfile;\n        [self setPreferencesFromAddressBookEntry:newProfile];\n        [_naggingController didRepairSavedArrangement];\n    }\n}\n\n- (void)windowWillStartLiveResize:(NSNotification *)notification {\n    if ([iTermAdvancedSettingsModel trackingRunloopForLiveResize]) {\n        if (notification.object == self.textview.window) {\n            _inLiveResize = YES;\n            [_cadenceController willStartLiveResize];\n        }\n    }\n}\n\n- (void)windowDidEndLiveResize:(NSNotification *)notification {\n    if ([iTermAdvancedSettingsModel trackingRunloopForLiveResize]) {\n        if (notification.object == self.textview.window) {\n            _inLiveResize = NO;\n            [_cadenceController liveResizeDidEnd];\n        }\n    }\n}\n\n- (void)synchronizeTmuxFonts:(NSNotification *)notification {\n    if (!_exited && [self isTmuxClient]) {\n        NSArray *args = [notification object];\n        iTermFontTable *fontTable = args[0];\n        NSNumber *hSpacing = args[1];\n        NSNumber *vSpacing = args[2];\n        TmuxController *controller = args[3];\n        NSNumber *tmuxWindow = args[4];\n        if (controller == _tmuxController &&\n            (!controller.variableWindowSize || tmuxWindow.intValue == self.delegate.tmuxWindow)) {\n            [_textview setFontTable:fontTable\n                  horizontalSpacing:[hSpacing doubleValue]\n                    verticalSpacing:[vSpacing doubleValue]];\n        }\n    }\n}\n\n- (void)notifyTmuxFontChange\n{\n    static BOOL fontChangeNotificationInProgress;\n    if (!fontChangeNotificationInProgress) {\n        fontChangeNotificationInProgress = YES;\n        [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxFontChanged\n                                                            object:@[ _textview.fontTable,\n                                                                      @(_textview.horizontalSpacing),\n                                                                      @(_textview.verticalSpacing),\n                                                                      _tmuxController ?: [NSNull null],\n                                                                      @(self.delegate.tmuxWindow)]];\n        fontChangeNotificationInProgress = NO;\n        [_delegate setTmuxFontTable:_textview.fontTable\n                      hSpacing:_textview.horizontalSpacing\n                      vSpacing:_textview.verticalSpacing];\n        [[NSNotificationCenter defaultCenter] postNotificationName:kPTYSessionTmuxFontDidChange\n                                                            object:self];\n    }\n}\n\n- (void)changeFontSizeDirection:(int)dir {\n    DLog(@\"changeFontSizeDirection:%d\", dir);\n    CGFloat hs;\n    CGFloat vs;\n    iTermFontTable *newFontTable;\n    NSString *fontConfig;\n    if (dir) {\n        // Grow or shrink\n        DLog(@\"grow/shrink\");\n        newFontTable = [_textview.fontTable fontTableGrownBy:dir];\n        hs = [_textview horizontalSpacing];\n        vs = [_textview verticalSpacing];\n        fontConfig = newFontTable.configString;\n    } else {\n        // Restore original font size.\n        NSDictionary *abEntry = [self originalProfile];\n        NSString* fontDesc = [abEntry objectForKey:KEY_NORMAL_FONT];\n        fontConfig = abEntry[KEY_FONT_CONFIG];\n        newFontTable = [[iTermFontTable alloc] initWithDefaultFont:[PTYFontInfo fontInfoWithFont:[ITAddressBookMgr fontWithDesc:fontDesc]]\n                                                      nonAsciiFont:[PTYFontInfo fontInfoWithFont:[ITAddressBookMgr fontWithDesc:abEntry[KEY_NON_ASCII_FONT]]]\n                                                      configString:fontConfig];\n        hs = [iTermProfilePreferences doubleForKey:KEY_HORIZONTAL_SPACING inProfile:abEntry];\n        vs = [iTermProfilePreferences doubleForKey:KEY_VERTICAL_SPACING inProfile:abEntry];\n    }\n    [self setFontTable:newFontTable horizontalSpacing:hs verticalSpacing:vs];\n\n    if (dir || self.isDivorced) {\n        // Move this bookmark into the sessions model.\n        NSString* guid = [self divorceAddressBookEntryFromPreferences];\n\n        // Set the font in the bookmark dictionary\n        [self setSessionSpecificProfileValues:@{\n                              KEY_NORMAL_FONT: [newFontTable.asciiFont.font stringValue],\n                           KEY_NON_ASCII_FONT: [newFontTable.defaultNonASCIIFont.font stringValue] ?: [NSNull null],\n                              KEY_FONT_CONFIG: fontConfig ?: [NSNull null]\n        }];\n\n        // Update the model's copy of the bookmark.\n        [[ProfileModel sessionsInstance] setBookmark:[self profile] withGuid:guid];\n\n        // Update an existing one-bookmark prefs dialog, if open.\n        if ([[[PreferencePanel sessionsInstance] windowIfLoaded] isVisible]) {\n            [[PreferencePanel sessionsInstance] underlyingProfileDidChange];\n        }\n    }\n}\n\n- (BOOL)profileValuesDifferFromCurrentProfile:(NSDictionary *)newValues {\n    for (NSString *key in newValues) {\n        if ([key isEqualToString:KEY_GUID] || [key isEqualToString:KEY_ORIGINAL_GUID]) {\n            continue;\n        }\n        NSObject *value = newValues[key];\n        if (![NSObject object:_profile[key] isEqualToObject:value]) {\n            return YES;\n        }\n    }\n    return NO;\n}\n\n// Missing values are replaced with their defaults. If everything matches excluding deprecated keys\n// then the profiles are equivalent.\n- (BOOL)profile:(Profile *)profile1 isEffectivelyEqualToProfile:(Profile *)profile2 {\n    for (NSString *key in [iTermProfilePreferences nonDeprecatedKeys]) {\n        id value1 = [iTermProfilePreferences objectForKey:key inProfile:profile1];\n        id value2 = [iTermProfilePreferences objectForKey:key inProfile:profile2];\n\n        if ([NSObject object:value1 isEqualToObject:value2]) {\n            continue;\n        }\n        return NO;\n    }\n    return YES;\n}\n\n- (NSString *)amendedColorKey:(NSString *)baseKey {\n    return iTermAmendedColorKey(baseKey, self.profile, self.view.effectiveAppearance.it_isDark);\n}\n\n- (void)setSessionSpecificProfileValues:(NSDictionary *)newValues {\n    DLog(@\"%@: setSessionSpecificProfilevalues:%@\", self, newValues);\n    if (![self profileValuesDifferFromCurrentProfile:newValues]) {\n        DLog(@\"No changes to be made\");\n        return;\n    }\n\n    // Consider the possibility that newValues exactly matches an existing shared profile or is\n    // a modified copy of a shared profile.\n    NSString *const newGuid = newValues[KEY_GUID];\n    if (newGuid) {\n        Profile *const existingProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:newGuid];\n        if (existingProfile) {\n            DLog(@\"Switching to existing profile\");\n            // Switch to the existing profile. This will remarry if possible.\n            [self setProfile:existingProfile preservingName:NO adjustWindow:YES];\n\n            // Are we done?\n            if ([self profile:existingProfile isEffectivelyEqualToProfile:newValues]) {\n                DLog(@\"Effectively equivalent to existing profile\");\n                // Since you switched to a shared profile that is an exact match, we're done.\n                return;\n            }\n\n            // No. Divorce and modify. This takes care of making everything right, such as setting\n            // the original profile guid.\n            DLog(@\"Divorce and modify\");\n        }\n    }\n\n    // Normal case: divorce and update a subset of properties.\n    if (!self.isDivorced) {\n        [self divorceAddressBookEntryFromPreferences];\n    }\n\n    // Build a copy of the current dictionary, replacing values with those provided in newValues.\n    NSMutableDictionary* temp = [NSMutableDictionary dictionaryWithDictionary:_profile];\n    for (NSString *key in newValues) {\n        if ([key isEqualToString:KEY_GUID] || [key isEqualToString:KEY_ORIGINAL_GUID]) {\n            continue;\n        }\n        NSObject *value = newValues[key];\n        if ([value isKindOfClass:[NSNull class]]) {\n            [temp removeObjectForKey:key];\n        } else {\n            temp[key] = value;\n        }\n    }\n    if ([self profile:temp isEffectivelyEqualToProfile:_profile]) {\n        DLog(@\"Not doing anything because temp is equal to _profile\");\n        // This was a no-op, so there's no need to get a divorce. Happens most\n        // commonly when setting tab color after a split.\n        return;\n    }\n    DLog(@\"Set bookmark and reload profile\");\n    [[ProfileModel sessionsInstance] setBookmark:temp withGuid:temp[KEY_GUID]];\n\n    // Update this session's copy of the bookmark\n    [self reloadProfile];\n}\n\n- (void)remarry {\n    [self setIsDivorced:NO withDecree:[NSString stringWithFormat:@\"Remarry\"]];\n}\n\n// TBH I'm not 100% sure this is correct. Don't use it for anything critical until this whole mess\n// has been burned to the ground and rebuilt.\n- (NSString *)guidOfUnderlyingProfile {\n    if (!self.isDivorced) {\n        return self.profile[KEY_GUID];\n    }\n\n    NSString *guid = _originalProfile[KEY_GUID];\n    if (guid && [[ProfileModel sharedInstance] bookmarkWithGuid:guid]) {\n        return guid;\n    }\n\n    return nil;\n}\n\n- (BOOL)isDivorced {\n    return _divorced;\n}\n\n- (void)inheritDivorceFrom:(PTYSession *)parent decree:(NSString *)decree {\n    assert(parent);\n    [self setIsDivorced:YES withDecree:decree];\n    [_overriddenFields removeAllObjects];\n    [_overriddenFields addObjectsFromArray:parent->_overriddenFields.allObjects];\n    DLog(@\"%@: Set overridden fields from %@: %@\", self, parent, _overriddenFields);\n}\n\n- (void)setIsDivorced:(BOOL)isDivorced withDecree:(NSString *)decree {\n    _divorced = isDivorced;\n    NSString *guid = self.profile[KEY_GUID];\n    if (guid) {\n        [[ProfileModel sessionsInstance] addGuidToDebug:guid];\n    }\n    [self setDivorceDecree:[NSString stringWithFormat:@\"isDivorced=%@ Decree=%@ guid=%@ Stack:\\n%@\", @(isDivorced), decree, guid, [NSThread callStackSymbols]]];\n}\n\n- (void)setDivorceDecree:(NSString *)decree {\n    [_divorceDecree autorelease];\n    _divorceDecree = [decree copy];\n}\n\n#define DIVORCE_LOG(args...) do { \\\nDLog(args); \\\n[logs addObject:[NSString stringWithFormat:args]]; \\\n} while (0)\n\n- (NSString *)divorceAddressBookEntryFromPreferences {\n    Profile *bookmark = [self profile];\n    NSString *guid = [bookmark objectForKey:KEY_GUID];\n    if (self.isDivorced) {\n        ITAssertWithMessage([[ProfileModel sessionsInstance] bookmarkWithGuid:guid] != nil,\n                            @\"I am divorced with guid %@ but the sessions instance has no such guid. Log:\\n%@\\n\\nModel log:\\n%@\\nEnd.\",\n                            guid,\n                            _divorceDecree,\n                            [[[[ProfileModel sessionsInstance] debugHistoryForGuid:guid] componentsJoinedByString:@\"\\n\"] it_compressedString]);\n        return guid;\n    }\n    [self setIsDivorced:YES withDecree:@\"PLACEHOLDER DECREE\"];\n    NSMutableArray<NSString *> *logs = [NSMutableArray array];\n    DIVORCE_LOG(@\"Remove profile with guid %@ from sessions instance\", guid);\n    [[ProfileModel sessionsInstance] removeProfileWithGuid:guid];\n    DIVORCE_LOG(@\"Set profile %@ divorced, add to sessions instance\", bookmark[KEY_GUID]);\n    [[ProfileModel sessionsInstance] addBookmark:[[bookmark copy] autorelease]];\n\n    NSString *existingOriginalGuid = bookmark[KEY_ORIGINAL_GUID];\n    if (!existingOriginalGuid ||\n        ![[ProfileModel sharedInstance] bookmarkWithGuid:existingOriginalGuid] ||\n        ![existingOriginalGuid isEqualToString:_originalProfile[KEY_GUID]]) {\n        // The bookmark doesn't already have a valid original GUID.\n        bookmark = [[ProfileModel sessionsInstance] setObject:guid\n                                                       forKey:KEY_ORIGINAL_GUID\n                                                   inBookmark:bookmark];\n    }\n\n    // Allocate a new guid for this bookmark.\n    guid = [ProfileModel freshGuid];\n    DIVORCE_LOG(@\"Allocating a new guid for this profile. The new guid is %@\", guid);\n    [[ProfileModel sessionsInstance] addGuidToDebug:guid];\n    [[ProfileModel sessionsInstance] setObject:guid\n                                        forKey:KEY_GUID\n                                    inBookmark:bookmark];\n    [_overriddenFields removeAllObjects];\n    [_overriddenFields addObjectsFromArray:@[ KEY_GUID, KEY_ORIGINAL_GUID] ];\n    [self setProfile:[[ProfileModel sessionsInstance] bookmarkWithGuid:guid]];\n    [logs addObject:@\"Stack trace:\"];\n    [logs addObject:[[NSThread callStackSymbols] componentsJoinedByString:@\"\\n\"]];\n    [self setDivorceDecree:[logs componentsJoinedByString:@\"\\n\"]];\n    DLog(@\"%p: divorce. overridden fields are now %@\", self, _overriddenFields);\n    return guid;\n}\n\n- (void)refreshOverriddenFields {\n    [self sessionProfileDidChange];\n}\n\n// Jump to the saved scroll position\n- (void)jumpToSavedScrollPosition {\n    id<VT100ScreenMarkReading> mark = [_screen lastMark];\n    Interval *interval = mark.entry.interval;\n    if (!interval) {\n        DLog(@\"Beep: Can't jump to bad interval\");\n        NSBeep();\n        return;\n    }\n    VT100GridRange range = [_screen lineNumberRangeOfInterval:interval];\n    long long offset = range.location;\n    if (offset < 0) {\n        DLog(@\"Beep: Can't jump to negative offset\");\n        NSBeep();  // This really shouldn't ever happen\n    } else {\n        self.currentMarkOrNotePosition = mark.entry.interval;\n        offset += [_screen totalScrollbackOverflow];\n        [_textview scrollToAbsoluteOffset:offset height:[_screen height]];\n        [_textview highlightMarkOnLine:VT100GridRangeMax(range) hasErrorCode:NO];\n    }\n}\n\n- (void)setCurrentMarkOrNotePosition:(Interval *)currentMarkOrNotePosition {\n    [_currentMarkOrNotePosition autorelease];\n    _currentMarkOrNotePosition = [currentMarkOrNotePosition retain];\n    ITBetaAssert(currentMarkOrNotePosition.limit >= 0, @\"Negative limit in current mark or note %@\", currentMarkOrNotePosition);\n}\n\n- (BOOL)hasSavedScrollPosition\n{\n    return [_screen lastMark] != nil;\n}\n\n- (void)findPasteboardStringDidChangeTo:(NSString *)string {\n    if ([_view.findDriver.findString isEqualToString:string]) {\n        return;\n    }\n    if (!_view.findDriver.shouldSearchAutomatically) {\n        return;\n    }\n    [_view.findDriver highlightWithoutSelectingSearchResultsForQuery:string];\n}\n\n- (void)findWithSelection {\n    if ([_textview selectedText]) {\n        [_view.findDriver setFindStringUnconditionally:_textview.selectedText];\n    }\n}\n\n- (void)showFindPanel {\n    [_view showFindUI];\n}\n\n- (void)showFilter {\n    [_view showFilter];\n}\n\n- (iTermComposerManager *)composerManager {\n    if (!_composerManager) {\n        _composerManager = [[iTermComposerManager alloc] init];\n        _composerManager.delegate = self;\n    }\n    return _composerManager;\n}\n\n- (void)compose {\n    if (self.currentCommand.length > 0) {\n        [self setComposerString:self.currentCommand];\n    }\n    [self.composerManager toggle];\n}\n\n- (void)setComposerString:(NSString *)string {\n    [self sendHexCode:[iTermAdvancedSettingsModel composerClearSequence]];\n    [self.composerManager setCommand:string];\n}\n\n- (BOOL)closeComposer {\n    if (_composerManager.isAutoComposer) {\n        // We don't want cmd-W to close the auto composer because it'll just open back up immediately.\n        return NO;\n    }\n    return [_composerManager dismiss];\n}\n\n// Note that the caller is responsible for respecting swapFindNextPrevious\n- (void)searchNext {\n    [_view createFindDriverIfNeeded];\n    [_view.findDriver searchNext];\n    [self beginOneShotTailFind];\n}\n\n// Note that the caller is responsible for respecting swapFindNextPrevious\n- (void)searchPrevious {\n    [_view createFindDriverIfNeeded];\n    [_view.findDriver searchPrevious];\n    [self beginOneShotTailFind];\n}\n\n- (void)resetFindCursor {\n    [_textview resetFindCursor];\n}\n\n- (BOOL)findInProgress {\n    return [_textview findInProgress];\n}\n\n- (BOOL)continueFind:(double *)progress range:(NSRange *)rangePtr {\n    return [_textview continueFind:progress range:rangePtr];\n}\n\n- (BOOL)growSelectionLeft {\n    return [_textview growSelectionLeft];\n}\n\n- (void)growSelectionRight {\n    [_textview growSelectionRight];\n}\n\n- (NSString *)selectedText {\n    return [_textview selectedText];\n}\n\n- (BOOL)canSearch {\n    return _textview != nil && _delegate && [_delegate realParentWindow];\n}\n\n- (void)findString:(NSString *)aString\n  forwardDirection:(BOOL)direction\n              mode:(iTermFindMode)mode\n        withOffset:(int)offset\nscrollToFirstResult:(BOOL)scrollToFirstResult {\n    DLog(@\"self=%@ aString=%@\", self, aString);\n    [_textview findString:aString\n         forwardDirection:direction\n                     mode:mode\n               withOffset:offset\n      scrollToFirstResult:scrollToFirstResult];\n}\n\n- (NSString *)unpaddedSelectedText {\n    return [_textview selectedText];\n}\n\n- (void)copySelection {\n    return [_textview copySelectionAccordingToUserPreferences];\n}\n\n- (void)takeFocus {\n    [[[_delegate realParentWindow] window] makeFirstResponder:_textview];\n}\n\n- (void)findViewControllerMakeDocumentFirstResponder {\n    [self takeFocus];\n}\n\n- (void)findViewControllerClearSearch {\n    DLog(@\"begin\");\n    [_textview clearHighlights:YES];\n}\n\n- (void)findViewControllerVisibilityDidChange:(id<iTermFindViewController>)sender {\n    [_delegate sessionUpdateMetalAllowed];\n    if (sender.driver.isVisible) {\n        return;\n    }\n    if (_view.findViewHasKeyboardFocus) {\n        [_view findViewDidHide];\n    }\n}\n\n- (void)setFilter:(NSString *)filter {\n    _modeHandler.mode = iTermSessionModeDefault;\n    DLog(@\"setFilter:%@\", filter);\n    if ([filter isEqualToString:_filter]) {\n        return;\n    }\n    VT100Screen *source = nil;\n    if ([_asyncFilter canRefineWithQuery:filter]) {\n        source = self.screen;\n    } else {\n        source = self.liveSession.screen;\n    }\n    [_asyncFilter cancel];\n    [self.liveSession removeContentSubscriber:_asyncFilter];\n    const BOOL replacingFilter = (_filter != nil);\n    assert(self.liveSession);\n\n    [_filter autorelease];\n    _filter = [filter copy];\n\n    iTermAsyncFilter *refining = [[_asyncFilter retain] autorelease];\n    [_asyncFilter release];\n\n    DLog(@\"Append lines from %@\", self.liveSession);\n    __weak __typeof(self) weakSelf = self;\n    _asyncFilter = [source newAsyncFilterWithDestination:self\n                                                   query:filter\n                                                refining:refining\n                                                progress:^(double progress) {\n        [weakSelf setFilterProgress:progress];\n    }];\n    [self.liveSession addContentSubscriber:_asyncFilter];\n    if (replacingFilter) {\n        DLog(@\"Clear buffer because there is a pre-existing filter\");\n        [self.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            [mutableState clearBufferWithoutTriggersSavingPrompt:NO];\n        }];\n    }\n    [_asyncFilter start];\n}\n\n- (void)setFilterProgress:(double)progress {\n    _view.findDriver.filterProgress = progress;\n    _statusBarViewController.filterViewController.filterProgress = progress;\n}\n\n- (void)findDriverFilterVisibilityDidChange:(BOOL)visible {\n    if (!visible) {\n        [_asyncFilter cancel];\n        [self.liveSession removeContentSubscriber:_asyncFilter];\n        [_asyncFilter autorelease];\n        _asyncFilter = nil;\n        PTYSession *liveSession = [[self.liveSession retain] autorelease];\n        [self.delegate session:self setFilter:nil];\n        [liveSession.view.findDriver close];\n    }\n}\n\n- (void)findDriverSetFilter:(NSString *)filter withSideEffects:(BOOL)withSideEffects{\n    if (withSideEffects) {\n        [self.delegate session:self setFilter:filter];\n    }\n}\n\n- (void)findViewControllerDidCeaseToBeMandatory:(id<iTermFindViewController>)sender {\n    [_view findViewDidHide];\n}\n\n- (void)findDriverInvalidateFrame {\n    [_view findDriverInvalidateFrame];\n}\n\n- (NSImage *)snapshot {\n    DLog(@\"Session %@ calling refresh\", self);\n    [_textview refresh];\n    return [_view snapshot];\n}\n\n- (NSImage *)snapshotCenteredOn:(VT100GridAbsCoord)coord size:(NSSize)size {\n    if (_screen.totalScrollbackOverflow > coord.y) {\n        return nil;\n    }\n    VT100GridCoord relativeCoord = VT100GridCoordMake(coord.x,\n                                                      coord.y - _screen.totalScrollbackOverflow);\n    NSPoint centerPoint = [_textview pointForCoord:relativeCoord];\n    NSRect rect = NSMakeRect(MIN(MAX(0, centerPoint.x - size.width / 2), NSWidth(_textview.bounds)),\n                             MIN(MAX(0, centerPoint.y - size.height / 2), NSHeight(_textview.bounds)),\n                             MIN(NSWidth(_textview.bounds), size.width),\n                             MIN(NSHeight(_textview.bounds), size.height));\n    CGFloat overage = NSMaxX(rect) - NSWidth(_textview.bounds);\n    if (overage > 0) {\n        rect.origin.x -= overage;\n    }\n\n    overage = NSMaxY(rect) - NSHeight(_textview.bounds);\n    if (overage > 0) {\n        rect.origin.y -= overage;\n    }\n\n    return [_textview snapshotOfRect:rect];\n}\n\n- (NSInteger)findDriverNumberOfSearchResults {\n    return _textview.findOnPageHelper.numberOfSearchResults;\n}\n\n- (NSInteger)findDriverCurrentIndex {\n    return _textview.findOnPageHelper.currentIndex;\n}\n\n#pragma mark - Metal Support\n\n#pragma mark iTermMetalGlueDelegate\n\n- (iTermImageWrapper *)metalGlueBackgroundImage {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return _backgroundImage;\n    } else {\n        return [self.delegate sessionBackgroundImage];\n    }\n}\n\n- (iTermBackgroundImageMode)metalGlueBackgroundImageMode {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return _backgroundImageMode;\n    } else {\n        return [self.delegate sessionBackgroundImageMode];\n    }\n}\n\n- (CGFloat)metalGlueBackgroundImageBlend {\n    return [self effectiveBlend];\n}\n\n- (void)metalGlueDidDrawFrameAndNeedsRedraw:(BOOL)redrawAsap NS_AVAILABLE_MAC(10_11) {\n    if (_view.useMetal) {\n        if (redrawAsap) {\n            [_textview setNeedsDisplay:YES];\n        }\n    }\n}\n\n- (CGContextRef)metalGlueContext {\n    return _metalContext;\n}\n\n+ (CGColorSpaceRef)metalColorSpace {\n    static dispatch_once_t onceToken;\n    static CGColorSpaceRef colorSpace;\n    dispatch_once(&onceToken, ^{\n        colorSpace = CGColorSpaceCreateDeviceRGB();\n        ITAssertWithMessage(colorSpace, @\"Colorspace is %@\", colorSpace);\n    });\n    return colorSpace;\n}\n\n+ (CGContextRef)onePixelContext {\n    static CGContextRef context;\n    if (context == NULL) {\n        context = CGBitmapContextCreate(NULL,\n                                        1,\n                                        1,\n                                        8,\n                                        1 * 4,\n                                        [self metalColorSpace],\n                                        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);\n    }\n    return context;\n}\n\n- (void)setMetalContextSize:(CGSize)size {\n    DLog(@\"%@\", self);\n    if (!self.textview.window) {\n        DLog(@\"No window\");\n        CGContextRelease(_metalContext);\n        _metalContext = NULL;\n        return;\n    }\n\n    const CGFloat scale = self.textview.window.backingScaleFactor;\n    const int radius = (iTermTextureMapMaxCharacterParts / 2) * 2 + 1;\n    CGSize scaledSize = CGSizeMake(size.width * scale * radius, size.height * scale * radius);\n    if (_metalContext) {\n        if (CGSizeEqualToSize(scaledSize, CGSizeMake(CGBitmapContextGetWidth(_metalContext),\n                                                     CGBitmapContextGetHeight(_metalContext)))) {\n            DLog(@\"No size change\");\n            return;\n        }\n        CGContextRelease(_metalContext);\n        _metalContext = NULL;\n    }\n    DLog(@\"allocate new metal context of size %@\", NSStringFromSize(scaledSize));\n    _metalContext = CGBitmapContextCreate(NULL,\n                                          scaledSize.width,\n                                          scaledSize.height,\n                                          8,\n                                          scaledSize.width * 4,  // bytes per row\n                                          [PTYSession metalColorSpace],\n                                          kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);\n}\n\n- (BOOL)metalAllowed {\n    return [self metalAllowed:nil];\n}\n\n- (BOOL)usingIntegratedGPU {\n    if (_view.metalView.device != nil) {\n        const BOOL result = _view.metalView.device.isLowPower;\n        DLog(@\"usingIntegratedGPU=%@\", @(result));\n        return result;\n    }\n    for (PseudoTerminal *term in [[iTermController sharedInstance] terminals]) {\n        for (PTYSession *session in term.allSessions) {\n            if (session.view.metalView.device != nil) {\n                const BOOL result = session.view.metalView.device.isLowPower;\n                DLog(@\"Found another session %p with a metal device, usingIntegratedGPU=%@\", session, @(result));\n                return result;\n            }\n        }\n    }\n\n    DLog(@\"Check if the system has an integrated GPU\");\n    static BOOL haveIntegrated;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        NSArray<id<MTLDevice>> *devices = MTLCopyAllDevices();\n        haveIntegrated = NO;\n        for (id<MTLDevice> device in devices) {\n            if (device.isLowPower) {\n                haveIntegrated = YES;\n                break;\n            }\n        }\n        CFRelease(devices);\n    });\n    DLog(@\"No sessions using GPU. Return %@.\", @(haveIntegrated));\n    return haveIntegrated;\n}\n\n- (BOOL)metalAllowed:(out iTermMetalUnavailableReason *)reason {\n    static dispatch_once_t onceToken;\n    static BOOL machineSupportsMetal;\n    dispatch_once(&onceToken, ^{\n        NSArray<id<MTLDevice>> *devices = MTLCopyAllDevices();\n        machineSupportsMetal = devices.count > 0;\n        [devices release];\n    });\n    if (@available(macOS 12.0, *)) {\n        if ([iTermPreferences boolForKey:kPreferenceKeyDisableInLowPowerMode] &&\n            [[NSProcessInfo processInfo] isLowPowerModeEnabled]) {\n            if (reason) {\n                *reason = iTermMetalUnavailableReasonLowerPowerMode;\n            }\n            return NO;\n        }\n    }\n    if (!machineSupportsMetal) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonNoGPU;\n        }\n        return NO;\n    }\n    if (![iTermPreferences boolForKey:kPreferenceKeyUseMetal]) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonDisabled;\n        }\n        return NO;\n    }\n    if (!self.view.window) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonSessionHasNoWindow;\n        }\n        return NO;\n    }\n    if ([PTYSession onePixelContext] == nil) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonContextAllocationFailure;\n        }\n        return NO;\n    }\n    if ([self ligaturesEnabledInEitherFont]) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonLigatures;\n        }\n        return NO;\n    }\n    if (_metalDeviceChanging) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonInitializing;\n        }\n        return NO;\n    }\n    if (![self metalViewSizeIsLegal]) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonInvalidSize;\n        }\n        return NO;\n    }\n    if (!_textview) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonSessionInitializing;\n        }\n        return NO;\n    }\n    if (_textview.drawingHelper.showDropTargets) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonDropTargetsVisible;\n        }\n        return NO;\n    }\n    // Use window occlusion because of issue 9174 but only for integrated GPUs because of issue 9044.\n    if ([self usingIntegratedGPU] &&\n        [_delegate.realParentWindow.ptyWindow approximateFractionOccluded] > 0.5) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonWindowObscured;\n        }\n        return NO;\n    }\n    if ([PTYNoteViewController anyNoteVisible] || _textview.contentNavigationShortcuts.count > 0) {\n        // When metal is enabled the note's superview (PTYTextView) has alphaValue=0 so it will not be visible.\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonAnnotations;\n        }\n        return NO;\n    }\n    if (_textview.hasPortholes) {\n        // When metal is enabled the note's superview (PTYTextView) has alphaValue=0 so it will not be visible.\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonPortholes;\n        }\n        return NO;\n    }\n    if (_textview.transparencyAlpha < 1) {\n        BOOL transparencyAllowed = NO;\n#if ENABLE_TRANSPARENT_METAL_WINDOWS\n        if (iTermTextIsMonochrome()) {\n            transparencyAllowed = YES;\n        }\n#endif\n        if (!transparencyAllowed && _textview.transparencyAlpha < 1) {\n            if (reason) {\n                *reason = iTermMetalUnavailableReasonTransparency;\n            }\n            return NO;\n        }\n    }\n    return YES;\n}\n\n- (BOOL)canProduceMetalFramecap {\n    return _useMetal && _view.metalView.alphaValue == 1 && _wrapper.useMetal && _textview.suppressDrawing;\n}\n\n- (BOOL)metalViewSizeIsLegal NS_AVAILABLE_MAC(10_11) {\n    NSSize size = _view.frame.size;\n    // See \"Maximum 2D texture width and height\" in \"Implementation Limits\". Pick the smallest value\n    // among the \"Mac\" columns.\n    // https://developer.apple.com/metal/Metal-Feature-Set-Tables.pdf\n    const CGFloat maxScale = 2;\n    return size.width > 0 && size.width < (PTYSessionMaximumMetalViewSize / maxScale) && size.height > 0 && size.height < (PTYSessionMaximumMetalViewSize / maxScale);\n}\n\n- (BOOL)idleForMetal {\n    return (!_cadenceController.isActive &&\n            !_view.verticalScroller.userScroll &&\n            !self.overrideGlobalDisableMetalWhenIdleSetting &&\n            !_view.driver.captureDebugInfoForNextFrame);\n}\n\n- (BOOL)ligaturesEnabledInEitherFont {\n    iTermTextDrawingHelper *helper = _textview.drawingHelper;\n    [helper updateCachedMetrics];\n    if (helper.asciiLigatures && helper.asciiLigaturesAvailable) {\n        return YES;\n    }\n    if ([iTermProfilePreferences boolForKey:KEY_USE_NONASCII_FONT inProfile:self.profile] &&\n        [iTermProfilePreferences boolForKey:KEY_NON_ASCII_LIGATURES inProfile:self.profile]) {\n        return YES;\n    }\n    return NO;\n}\n\n- (BOOL)willEnableMetal {\n    DLog(@\"%@\", self);\n    [self updateMetalDriver];\n    return _metalContext != nil;\n}\n\n- (void)setUseMetal:(BOOL)useMetal {\n    if (useMetal == _useMetal) {\n        return;\n    }\n    DLog(@\"setUseMetal:%@ %@\", @(useMetal), self);\n    _useMetal = useMetal;\n    // The metalview's alpha will initially be 0. Once it has drawn a frame we'll swap what is visible.\n    [self setUseMetal:useMetal dataSource:_metalGlue];\n    if (useMetal) {\n        [self updateMetalDriver];\n        // wrapper.useMetal becomes YES after the first frame is done drawing\n    } else {\n        _wrapper.useMetal = NO;\n        [_metalDisabledTokens removeAllObjects];\n        if (_metalContext) {\n            // If metal is re-enabled later, it must not use the same context.\n            // It's possible that a metal driver thread has survived this point\n            // and will continue to use the context.\n            CGContextRelease(_metalContext);\n            _metalContext = NULL;\n        }\n    }\n    [_textview setNeedsDisplay:YES];\n    [_cadenceController changeCadenceIfNeeded];\n\n    if (useMetal) {\n        [self renderTwoMetalFramesAndShowMetalView];\n    } else {\n        _view.metalView.enableSetNeedsDisplay = NO;\n    }\n}\n\n- (void)renderTwoMetalFramesAndShowMetalView NS_AVAILABLE_MAC(10_11) {\n    // The first frame will be slow to draw. The second frame will be very\n    // recent to minimize jitter. For reasons I haven't understood yet it seems\n    // the first frame is sometimes transparent. I haven't seen that issue with\n    // the second frame yet.\n    [self renderMetalFramesAndShowMetalView:2];\n}\n\n- (void)renderMetalFramesAndShowMetalView:(NSInteger)count {\n    if (_useMetal) {\n        DLog(@\"Begin async draw %@ for %@\", @(count), self);\n        [_view.driver drawAsynchronouslyInView:_view.metalView completion:^(BOOL ok) {\n            if (!_useMetal || _exited) {\n                DLog(@\"Finished async draw but metal off/exited for %@\", self);\n                return;\n            }\n\n            if (!ok) {\n                DLog(@\"Finished async draw NOT OK for %@\", self);\n                // Wait 10ms to avoid burning CPU if it failed because it's slow to draw the first frame.\n                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.01 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n                    [self renderMetalFramesAndShowMetalView:count];\n                });\n                return;\n            }\n\n            if (count <= 1) {\n                DLog(@\"Finished async draw ok for %@\", self);\n                [self showMetalViewImmediately];\n            } else {\n                [self renderMetalFramesAndShowMetalView:count - 1];\n            }\n        }];\n    }\n}\n\n- (void)showMetalViewImmediately {\n    if (!_useMetal) {\n        DLog(@\"Declining to show metal view immediately in %@ because useMetal is NO\", self);\n        return;\n    }\n    if (_view.metalView.bounds.size.width == 0 || _view.metalView.bounds.size.height == 0) {\n        DLog(@\"Declining to show metal view immediately in %@ because the view's size is %@\", self, NSStringFromSize(_view.metalView.bounds.size));\n        return;\n    }\n    if (_textview == nil) {\n        DLog(@\"Declining to show metal view immediately in %@ because the textview is nil\", self);\n        return;\n    }\n    if (_textview.dataSource == nil) {\n        DLog(@\"Declining to show metal view immediately in %@ because the textview's datasource is nil\", self);\n        return;\n    }\n    if (_screen.width == 0 || _screen.height == 0) {\n        DLog(@\"Declining to show metal view immediately in %@ because the screen's size is %@x%@. Screen is %@\",\n             self, _textview.dataSource, @(_screen.width), @(_screen.height));\n        return;\n    }\n    [self reallyShowMetalViewImmediately];\n}\n\n- (void)reallyShowMetalViewImmediately {\n    DLog(@\"reallyShowMetalViewImmediately\");\n    [_view setNeedsDisplay:YES];\n    [self showMetalAndStopDrawingTextView];\n    _view.metalView.enableSetNeedsDisplay = YES;\n}\n\n- (void)showMetalAndStopDrawingTextView NS_AVAILABLE_MAC(10_11) {\n    // If the text view had been visible, hide it. Hiding it before the\n    // first frame is drawn causes a flash of gray.\n    DLog(@\"showMetalAndStopDrawingTextView\");\n    _wrapper.useMetal = YES;\n    _textview.suppressDrawing = YES;\n    [_view setSuppressLegacyDrawing:YES];\n    if (PTYScrollView.shouldDismember) {\n        _view.scrollview.alphaValue = 0;\n    } else {\n        _view.scrollview.contentView.alphaValue = 0;\n    }\n    [self setMetalViewAlphaValue:1];\n}\n\n- (void)setMetalViewAlphaValue:(CGFloat)alphaValue {\n    _view.metalView.alphaValue = alphaValue;\n    [_view didChangeMetalViewAlpha];\n    [self.delegate sessionDidChangeMetalViewAlphaValue:self to:alphaValue];\n}\n\n- (void)setUseMetal:(BOOL)useMetal dataSource:(id<iTermMetalDriverDataSource>)dataSource NS_AVAILABLE_MAC(10_11) {\n    [_view setUseMetal:useMetal dataSource:dataSource];\n    if (!useMetal) {\n        _textview.suppressDrawing = NO;\n        [_view setSuppressLegacyDrawing:NO];\n        if (PTYScrollView.shouldDismember) {\n            _view.scrollview.alphaValue = 1;\n        } else {\n            _view.scrollview.contentView.alphaValue = 1;\n        }\n    }\n}\n\n- (void)updateMetalDriver NS_AVAILABLE_MAC(10_11) {\n    DLog(@\"%@\", self);\n    const CGSize cellSize = CGSizeMake(_textview.charWidth, _textview.lineHeight);\n    CGSize glyphSize;\n    const CGFloat scale = _view.window.backingScaleFactor ?: 1;\n    NSRect rect = [iTermCharacterSource boundingRectForCharactersInRange:NSMakeRange(32, 127-32)\n                                                               fontTable:_textview.fontTable\n                                                                   scale:scale\n                                                             useBoldFont:_textview.useBoldFont\n                                                           useItalicFont:_textview.useItalicFont\n                                                        usesNonAsciiFont:_textview.useNonAsciiFont\n                                                                 context:[PTYSession onePixelContext]];\n    CGSize asciiOffset = CGSizeZero;\n    if (rect.origin.y < 0) {\n        // Iosevka Light is the only font I've found that needs this.\n        // It rides *very* low in its box. The lineheight that PTYFontInfo calculates is actually too small\n        // to contain the glyphs (it uses a weird algorithm that was discovered \"organically\").\n        // There are gobs of empty pixels at the top, so we shift all its ASCII glyphs a bit so they'll\n        // fit. Non-ASCII characters may take multiple parts and so can properly extend beyond their\n        // cell, so we only need to think about ASCII. In other words, this hack shifts the character up\n        // *in the texture* to make better use of space without using a larger glyph size.\n        //\n        // In a monochrome world, this is still necessary because even though glyph size and cell\n        // size are no longer required to be the same, part of the glyph will be drawn outside its\n        // bounds and get clipped in the texture.\n        asciiOffset.height = -floor(rect.origin.y * scale);\n    }\n    if (iTermTextIsMonochrome() && rect.origin.x < 0) {\n        // AnonymousPro has a similar problem (issue 8185), e.g. with \"W\".\n        // There is a subtle difference, though! The monochrome code path assumes that glyphs are\n        // left-aligned in their glyphSize-sized chunk of the texture. Setting the asciiOffset here\n        // causes them to all be rendered a few pixels to the right so that this assumption will be\n        // true. The quad is then shifted left by a corresponding amount when rendering so it ends\n        // up drawn in the right place.\n        //\n        // When doing subpixel antialiasing, this is not an issue because it deals with multipart\n        // ASCII glyphs differently. It splits them into pieces and draws them as separate instances.\n        //\n        // Changing the assumption that glyphs are left-aligned would be very complex, and I can't\n        // afford to add more risk right now. This is less than beautiful, but it's quite safe.\n        asciiOffset.width = -floor(rect.origin.x * scale);\n    }\n    if (iTermTextIsMonochrome()) {\n        // Mojave can use a glyph size larger than cell size because compositing is trivial without subpixel AA.\n        glyphSize.width = round(0.49 + MAX(cellSize.width, NSMaxX(rect)));\n        glyphSize.height = round(0.49 + MAX(cellSize.height, NSMaxY(rect)));\n    } else {\n        glyphSize = cellSize;\n    }\n    [self setMetalContextSize:glyphSize];\n    if (!_metalContext) {\n        DLog(@\"%p Failed to allocate metal context. Disable metal and try again in 1 second.\", self);\n        if (_errorCreatingMetalContext) {\n            DLog(@\"Already have a retry queued.\");\n            return;\n        }\n        _errorCreatingMetalContext = YES;\n        [self.delegate sessionUpdateMetalAllowed];\n        if (!_useMetal) {\n            DLog(@\"Failed to create context for %@ but metal is not allowed\", self);\n            return;\n        }\n        DLog(@\"Failed to create context for %@. schedule retry\", self);\n        __weak __typeof(self) weakSelf = self;\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)),\n                       dispatch_get_main_queue(), ^{\n            [weakSelf retryMetalAfterContextAllocationFailure];\n        });\n        return;\n    }\n    [_view.driver setCellSize:cellSize\n       cellSizeWithoutSpacing:CGSizeMake(_textview.charWidthWithoutSpacing, _textview.charHeightWithoutSpacing)\n                    glyphSize:glyphSize\n                     gridSize:_screen.currentGrid.size\n                  asciiOffset:asciiOffset\n                        scale:_view.window.screen.backingScaleFactor\n                      context:_metalContext\n         legacyScrollbarWidth:self.legacyScrollbarWidth];\n}\n\n- (CGFloat)legacyScrollbarWidth {\n    if (_view.scrollview.scrollerStyle != NSScrollerStyleLegacy) {\n        return 0;\n    }\n    return NSWidth(_view.scrollview.bounds) - NSWidth(_view.scrollview.contentView.bounds);\n}\n\n- (void)retryMetalAfterContextAllocationFailure {\n    DLog(@\"%p It's been one second since trying to allocate a metal context failed. Try again.\", self);\n    if (!_errorCreatingMetalContext) {\n        DLog(@\"Oddly, errorCreatingMetalContext is NO\");\n        return;\n    }\n    DLog(@\"%p reset error state\", self);\n    _errorCreatingMetalContext = NO;\n    [self updateMetalDriver];\n    if (_metalContext) {\n        DLog(@\"A metal context was allocated. Try to turn metal on for this tab.\");\n        [self.delegate sessionUpdateMetalAllowed];\n    } else {\n        DLog(@\"Failed to allocate context again. A retry should have been scheduled.\");\n    }\n}\n\n#pragma mark - Password Management\n\n- (BOOL)canOpenPasswordManager {\n    [self sync];\n    return !_screen.echoProbeIsActive;\n}\n\n- (void)enterPassword:(NSString *)password {\n    [self incrementDisableFocusReporting:1];\n    [_screen beginEchoProbeWithBackspace:[self backspaceData] password:password delegate:self];\n}\n\n- (NSImage *)dragImage\n{\n    NSImage *image = [self snapshot];\n    // Dial the alpha down to 50%\n    NSImage *dragImage = [[[NSImage alloc] initWithSize:[image size]] autorelease];\n    [dragImage lockFocus];\n    [image drawAtPoint:NSZeroPoint\n              fromRect:NSZeroRect\n             operation:NSCompositingOperationSourceOver\n              fraction:0.5];\n    [dragImage unlockFocus];\n    return dragImage;\n}\n\n- (void)setPasteboard:(NSString *)pbName {\n    if (pbName) {\n        [_pasteboard autorelease];\n        _pasteboard = [pbName copy];\n        [_pbtext release];\n        _pbtext = [[NSMutableData alloc] init];\n    } else {\n        NSPasteboard *pboard = [NSPasteboard pasteboardWithName:_pasteboard];\n        [pboard declareTypes:@[ NSPasteboardTypeString ] owner:self];\n        [pboard setData:_pbtext forType:NSPasteboardTypeString];\n\n        [_pasteboard release];\n        _pasteboard = nil;\n        [_pbtext release];\n        _pbtext = nil;\n\n        // In case it was the find pasteboard that changed\n        [[iTermFindPasteboard sharedInstance] updateObservers:self];\n    }\n}\n\n- (void)stopCoprocess\n{\n    [_shell stopCoprocess];\n}\n\n- (BOOL)hasCoprocess\n{\n    return [_shell hasCoprocess];\n}\n\n- (void)launchCoprocessWithCommand:(NSString *)command mute:(BOOL)mute {\n    DLog(@\"Launch coprocess with command %@. Mute=%@\", command, @(mute));\n    Coprocess *coprocess = [Coprocess launchedCoprocessWithCommand:command\n                                                       environment:[self environmentForNewJobFromEnvironment:self.environment\n                                                                                               substitutions:self.substitutions]];\n    coprocess.delegate = self.weakSelf;\n    coprocess.mute = mute;\n    [_shell setCoprocess:coprocess];\n    [_textview setNeedsDisplay:YES];\n}\n\n- (void)launchSilentCoprocessWithCommand:(NSString *)command\n{\n    [self launchCoprocessWithCommand:command mute:YES];\n}\n\n- (void)performBlockWithoutFocusReporting:(void (^NS_NOESCAPE)(void))block {\n    [self incrementDisableFocusReporting:1];\n    block();\n    [self incrementDisableFocusReporting:-1];\n}\n\n- (void)incrementDisableFocusReporting:(NSInteger)delta {\n    DLog(@\"delta=%@ count %@->%@\\n%@\", @(delta), @(_disableFocusReporting), @(_disableFocusReporting + delta), self);\n    _disableFocusReporting += delta;\n    if (_disableFocusReporting == 0) {\n        [self setFocused:[self textViewOrComposerIsFirstResponder]];\n    }\n}\n\n- (void)setFocused:(BOOL)focused {\n    DLog(@\"setFocused:%@ self=%@\", @(focused), self);\n    if (_disableFocusReporting) {\n        DLog(@\"Focus reporting disabled\");\n        return;\n    }\n    if ([self.delegate sessionPasswordManagerWindowIsOpen]) {\n        DLog(@\"Password manager window is open\");\n        return;\n    }\n    if (focused == _focused) {\n        DLog(@\"No change\");\n        return;\n    }\n    if (_alertOnMarksinOffscreenSessions && [self.delegate hasMaximizedPane]) {\n        DLog(@\"Sync because _alertOnMarksinOffscreenSessions and maximized\");\n        [self sync];\n    }\n    if (self.isTmuxGateway) {\n        DLog(@\"Is tmux gateway\");\n        return;\n    }\n    _focused = focused;\n    if (_screen.terminalReportFocus) {\n        DLog(@\"Will report focus\");\n        _reportingFocus = YES;\n        self.lastFocusReportDate = [NSDate date];\n        // This is not considered reporting because it's not in response to a remote request.\n        [self writeLatin1EncodedData:[_screen.terminalOutput reportFocusGained:focused] broadcastAllowed:NO reporting:NO];\n        _reportingFocus = NO;\n    }\n    if (focused && [self isTmuxClient]) {\n        DLog(@\"Tell tmux about focus change\");\n        [_tmuxController selectPane:self.tmuxPane];\n        [self.delegate sessionDidReportSelectedTmuxPane:self];\n    }\n}\n\n- (BOOL)wantsContentChangedNotification\n{\n    // We want a content change notification if it's worth doing a tail find.\n    // That means the find window is open, we're not already doing a tail find,\n    // and a search was performed in the find window (vs select+cmd-e+cmd-f).\n    return (!_tailFindTimer &&\n            !_view.findViewIsHidden &&\n            [_textview findContext].substring != nil);\n}\n\n- (void)hideSession {\n    [self bury];\n}\n\n- (NSString *)preferredTmuxClientName {\n    id<VT100RemoteHostReading> remoteHost = [self currentHost];\n    if (remoteHost) {\n        return [NSString stringWithFormat:@\"%@@%@\", remoteHost.username, remoteHost.hostname];\n    } else {\n        NSString *name = [_nameController.presentationSessionTitle stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];\n        if (name.length) {\n            return name;\n        }\n        return @\"tmux\";\n    }\n}\n\n- (void)setTmuxMode:(PTYSessionTmuxMode)tmuxMode {\n    @synchronized ([TmuxGateway class]) {\n        _tmuxMode = tmuxMode;\n    }\n    if (tmuxMode == TMUX_GATEWAY) {\n        [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            mutableState.isTmuxGateway = (tmuxMode == TMUX_GATEWAY);\n        }];\n    } else if (tmuxMode == TMUX_NONE) {\n        // We got here through a paused side-effect so we cvan't join.\n        [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            mutableState.isTmuxGateway = NO;\n        }];\n    } else if (tmuxMode == TMUX_CLIENT) {\n        [self setUpTmuxPipe];\n    }\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self reallySetTmuxMode:tmuxMode];\n    });\n}\n\n- (void)reallySetTmuxMode:(PTYSessionTmuxMode)tmuxMode {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        NSString *name;\n        switch (tmuxMode) {\n            case TMUX_NONE:\n                name = nil;\n                terminal.tmuxMode = NO;\n                break;\n            case TMUX_GATEWAY:\n                name = @\"gateway\";\n                terminal.tmuxMode = NO;\n                break;\n            case TMUX_CLIENT:\n                name = @\"client\";\n                terminal.tmuxMode = YES;\n                terminal.termType = _tmuxController.defaultTerminal ?: @\"screen\";\n                [self loadTmuxProcessID];\n                [self installTmuxStatusBarMonitor];\n                [self installTmuxTitleMonitor];\n                [self installTmuxForegroundJobMonitor];\n                [self installOtherTmuxMonitors];\n                [self replaceWorkingDirectoryPollerWithTmuxWorkingDirectoryPoller];\n                break;\n        }\n        [self.variablesScope setValue:name forVariableNamed:iTermVariableKeySessionTmuxRole];\n    }];\n}\n\n- (void)setUpTmuxPipe {\n    assert(!_tmuxClientWritePipe);\n    int fds[2];\n    if (pipe(fds) < 0) {\n        NSString *message = [NSString stringWithFormat:@\"Failed to create pipe: %s\", strerror(errno)];\n        DLog(@\"%@\", message);\n        [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            [mutableState appendStringAtCursor:message];\n        }];\n        _tmuxClientWritePipe = nil;\n        return;\n    }\n    {\n        // Make the TaskNotifier file descriptor nonblocking.\n        const int fd = fds[0];\n        const int flags = fcntl(fd, F_GETFL);\n        fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n    }\n    {\n        // Make the write pipe blocking so it can provide backpressure.\n        const int fd = fds[1];\n        const int flags = fcntl(fd, F_GETFL);\n        fcntl(fd, F_SETFL, flags & (~O_NONBLOCK));\n    }\n\n    _shell.readOnlyFileDescriptor = fds[0];\n    [_tmuxClientWritePipe release];\n    _tmuxClientWritePipe = [[NSFileHandle alloc] initWithFileDescriptor:fds[1]\n                                                         closeOnDealloc:YES];\n}\n\n- (void)loadTmuxProcessID {\n    if (!_tmuxController.serverIsLocal) {\n        return;\n    }\n    NSString *command = [NSString stringWithFormat:@\"display-message -t '%%%@' -p '#{pane_pid}'\", @(self.tmuxPane)];\n    DLog(@\"Request pane PID with command %@\", command);\n    [_tmuxController.gateway sendCommand:command\n                          responseTarget:self\n                        responseSelector:@selector(didFetchTmuxPid:)\n                          responseObject:nil\n                                   flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)didFetchTmuxPid:(NSString *)pidString {\n    if (pidString && self.tmuxMode == TMUX_CLIENT && _tmuxController.serverIsLocal) {\n        NSNumber *pid = @([pidString integerValue]);\n        if (pid.intValue > 0) {\n            _shell.tmuxClientProcessID = pid;\n            [self updateTitles];\n        }\n    }\n}\n\n- (void)replaceWorkingDirectoryPollerWithTmuxWorkingDirectoryPoller {\n    DLog(@\"replaceWorkingDirectoryPollerWithTmuxWorkingDirectoryPoller\");\n    _pwdPoller.delegate = nil;\n    [_pwdPoller release];\n\n    _pwdPoller = [[iTermWorkingDirectoryPoller alloc] initWithTmuxGateway:_tmuxController.gateway\n                                                                    scope:self.variablesScope\n                                                               windowPane:self.tmuxPane];\n    _pwdPoller.delegate = self;\n    [_pwdPoller poll];\n}\n\n- (void)installTmuxStatusBarMonitor {\n    assert(!_tmuxStatusBarMonitor);\n\n    if (_tmuxController.gateway.minimumServerVersion.doubleValue >= 2.9) {\n        // Just use the built-in status bar for older versions of tmux because they don't support ${T:xxx} or ${E:xxx}\n        _tmuxStatusBarMonitor = [[iTermTmuxStatusBarMonitor alloc] initWithGateway:_tmuxController.gateway\n                                                                             scope:self.variablesScope];\n        _tmuxStatusBarMonitor.active = [iTermProfilePreferences boolForKey:KEY_SHOW_STATUS_BAR inProfile:self.profile];\n        if ([iTermPreferences boolForKey:kPreferenceKeyUseTmuxStatusBar] ||\n            [iTermStatusBarLayout shouldOverrideLayout:self.profile[KEY_STATUS_BAR_LAYOUT]]) {\n            [self setSessionSpecificProfileValues:@{ KEY_STATUS_BAR_LAYOUT: [[iTermStatusBarLayout tmuxLayoutWithController:_tmuxController\n                                                                                                                      scope:nil\n                                                                                                                     window:self.delegate.tmuxWindow] dictionaryValue] }];\n        }\n    }\n}\n\n- (void)installTmuxForegroundJobMonitor {\n    if (_tmuxForegroundJobMonitor) {\n        return;\n    }\n    if (![self shouldShowTabGraphic]) {\n        return;\n    }\n    __weak __typeof(self) weakSelf = self;\n    _tmuxForegroundJobMonitor = [[iTermTmuxOptionMonitor alloc] initWithGateway:_tmuxController.gateway\n                                                                          scope:self.variablesScope\n                                                           fallbackVariableName:nil\n                                                                         format:@\"#{pane_current_command}\"\n                                                                         target:[NSString stringWithFormat:@\"%%%@\", @(self.tmuxPane)]\n                                                                   variableName:iTermVariableKeySessionJob\n                                                                          block:^(NSString * _Nonnull command) {\n        [weakSelf setCurrentForegroundJobNameForTmux:command];\n    }];\n    if ([iTermAdvancedSettingsModel pollForTmuxForegroundJob]) {\n        [_tmuxForegroundJobMonitor startTimerIfSubscriptionsUnsupported];\n    }\n    [_tmuxForegroundJobMonitor updateOnce];\n}\n\n- (void)setCurrentForegroundJobNameForTmux:(NSString *)command {\n    if ([_graphicSource updateImageForJobName:command enabled:[self shouldShowTabGraphic]]) {\n        [self.delegate sessionDidChangeGraphic:self shouldShow:self.shouldShowTabGraphic image:self.tabGraphic];\n    }\n    [self.delegate sessionJobDidChange:self];\n}\n\n- (void)tmuxWindowTitleDidChange {\n    [self.tmuxForegroundJobMonitor updateOnce];\n}\n\n- (void)uninstallTmuxForegroundJobMonitor {\n    if (!_tmuxForegroundJobMonitor) {\n        return;\n    }\n    [_tmuxForegroundJobMonitor invalidate];\n    [_tmuxForegroundJobMonitor release];\n    _tmuxForegroundJobMonitor = nil;\n}\n\n- (iTermTmuxOptionMonitor *)tmuxForegroundJobMonitor {\n    if (!self.isTmuxClient || !_tmuxController) {\n        return nil;\n    }\n    if (_tmuxForegroundJobMonitor) {\n        return _tmuxForegroundJobMonitor;\n    }\n    if (![self shouldShowTabGraphic]) {\n        return nil;\n    }\n    [self installTmuxForegroundJobMonitor];\n    return _tmuxForegroundJobMonitor;\n}\n\n- (void)installOtherTmuxMonitors {\n    if (![_tmuxController.gateway supportsSubscriptions]) {\n        return;\n    }\n    if (_paneIndexMonitor) {\n        return;\n    }\n    _paneIndexMonitor = [[iTermTmuxOptionMonitor alloc] initWithGateway:_tmuxController.gateway\n                                                                  scope:self.variablesScope\n                                                   fallbackVariableName:nil\n                                                                 format:@\"#{pane_index}\"\n                                                                 target:[NSString stringWithFormat:@\"%%%@\", @(self.tmuxPane)]\n                                                           variableName:iTermVariableKeySessionTmuxWindowPaneIndex\n                                                                  block:nil];\n    [_paneIndexMonitor updateOnce];\n}\n\n// NOTE: Despite the name, this doesn't continuously monitor because that is\n// too expensive. Instead, we manually poll at times when a change is likely.\n- (void)installTmuxTitleMonitor {\n    if (_tmuxTitleMonitor) {\n        return;\n    }\n    __weak __typeof(self) weakSelf = self;\n    _tmuxTitleMonitor = [[iTermTmuxOptionMonitor alloc] initWithGateway:_tmuxController.gateway\n                                                                  scope:self.variablesScope\n                                                   fallbackVariableName:nil\n                                                                 format:@\"#{pane_title}\"\n                                                                 target:[NSString stringWithFormat:@\"%%%@\", @(self.tmuxPane)]\n                                                           variableName:iTermVariableKeySessionTmuxPaneTitle\n                                                                  block:^(NSString * _Nonnull title) {\n        [weakSelf setTitleFromTmuxTitleMonitor:title];\n    }];\n    [_tmuxTitleMonitor updateOnce];\n}\n\n- (void)setTitleFromTmuxTitleMonitor:(NSString *)title {\n    if (title) {\n        [self setSessionSpecificProfileValues:@{ KEY_TMUX_PANE_TITLE: title ?: @\"\"}];\n        [self.delegate sessionDidUpdatePaneTitle:self];\n    }\n}\n\n- (void)uninstallTmuxTitleMonitor {\n    if (!_tmuxTitleMonitor) {\n        return;\n    }\n    [_tmuxTitleMonitor invalidate];\n    [_tmuxTitleMonitor release];\n    _tmuxTitleMonitor = nil;\n}\n\n- (PTYSessionTmuxMode)tmuxMode {\n    @synchronized ([TmuxGateway class]) {\n        return _tmuxMode;\n    }\n}\n\n- (void)startTmuxMode:(NSString *)dcsID {\n    if (self.tmuxMode != TMUX_NONE) {\n        return;\n    }\n    NSString *preferredTmuxClientName = [self preferredTmuxClientName];\n    self.tmuxMode = TMUX_GATEWAY;\n    _tmuxGateway = [[TmuxGateway alloc] initWithDelegate:self dcsID:dcsID];\n    ProfileModel *model;\n    Profile *profile;\n    if ([iTermPreferences useTmuxProfile]) {\n        model = [ProfileModel sharedInstance];\n        profile = [[ProfileModel sharedInstance] tmuxProfile];\n    } else {\n        if (self.isDivorced) {\n            model = [ProfileModel sessionsInstance];\n        } else {\n            model = [ProfileModel sharedInstance];\n        }\n        profile = self.profile;\n    }\n    _haveKickedOffTmux = NO;\n    _tmuxController = [[TmuxController alloc] initWithGateway:_tmuxGateway\n                                                   clientName:preferredTmuxClientName\n                                                      profile:profile\n                                                 profileModel:model];\n\n    [self.variablesScope setValue:_tmuxController.clientName forVariableNamed:iTermVariableKeySessionTmuxClientName];\n    _tmuxController.ambiguousIsDoubleWidth = _treatAmbiguousWidthAsDoubleWidth;\n    _tmuxController.unicodeVersion = _unicodeVersion;\n\n    // We intentionally don't send anything to tmux yet. We wait to get a\n    // begin-end pair from it to make sure everything is cool (we have a legit\n    // session) and then we start going.\n\n    // This is to fix issue 4429, where we used to send a command immediately\n    // and tmux would terminate immediately and we would spam the user's\n    // command line.\n    //\n    // Tmux always prints something when you first attach. It's a notification, a response, or an\n    // error. The options I've considered are:\n    //\n    // tmux -CC with or without an existing session prints this unsolicited:\n    //    %begin time 1 0\n    //    %end time 1 0\n    //    %window-add @id\n\n    // tmux -CC attach with no existing session prints this unsolicited;\n    // %begin time 1 0\n    // no sessions\n    // %error time\n\n    // tmux -CC attach with an existing session prints this unsolicited:\n    // %begin time 1 0\n    // %end time 1 0\n\n    // One of tmuxInitialCommandDidCompleteSuccessfully: or\n    // tmuxInitialCommandDidFailWithError: will be called on the first %end or\n    // %error, respectively.\n    [self printTmuxMessage:@\"** tmux mode started **\"];\n    [self printTmuxMessage:@\"\"];\n    [self printTmuxMessage:@\"Command Menu\"];\n    [self printTmuxMessage:@\"----------------------------\"];\n    [self printTmuxMessage:@\"esc    Detach cleanly.\"];\n    [self printTmuxMessage:@\"  X    Force-quit tmux mode.\"];\n    [self printTmuxMessage:@\"  L    Toggle logging.\"];\n    [self printTmuxMessage:@\"  C    Run tmux command.\"];\n\n    if ([iTermPreferences boolForKey:kPreferenceKeyAutoHideTmuxClientSession]) {\n        _tmuxController.initialWindowHint = self.view.window.frame;\n        _hideAfterTmuxWindowOpens = YES;\n    }\n}\n\n- (BOOL)isTmuxClient {\n    return self.tmuxMode == TMUX_CLIENT;\n}\n\n- (BOOL)isTmuxGateway {\n    return self.tmuxMode == TMUX_GATEWAY;\n}\n\n- (void)tmuxDetach {\n    if (self.tmuxMode != TMUX_GATEWAY) {\n        return;\n    }\n    [self printTmuxMessage:@\"Detaching...\"];\n    [_tmuxGateway detach];\n}\n\n- (void)setTmuxPane:(int)windowPane {\n    [self.variablesScope setValue:@(windowPane) forVariableNamed:iTermVariableKeySessionTmuxWindowPane];\n    self.tmuxMode = TMUX_CLIENT;\n    [_shell registerTmuxTask];\n}\n\n- (int)tmuxPane {\n    return [[self.variablesScope valueForVariableName:iTermVariableKeySessionTmuxWindowPane] intValue];\n}\n\n- (PTYSession *)tmuxGatewaySession {\n    if (self.isTmuxGateway) {\n        return self;\n    }\n    if (!self.isTmuxClient) {\n        return nil;\n    }\n    return (PTYSession *)self.tmuxController.gateway.delegate;\n}\n\n- (void)toggleTmuxZoom {\n    [_tmuxController toggleZoomForPane:self.tmuxPane];\n}\n\n- (void)resizeFromArrangement:(NSDictionary *)arrangement {\n    [self setSize:VT100GridSizeMake([[arrangement objectForKey:SESSION_ARRANGEMENT_COLUMNS] intValue],\n                                    [[arrangement objectForKey:SESSION_ARRANGEMENT_ROWS] intValue])];\n}\n\n- (BOOL)isCompatibleWith:(PTYSession *)otherSession\n{\n    if (self.tmuxMode != TMUX_CLIENT && otherSession.tmuxMode != TMUX_CLIENT) {\n        // Non-clients are always compatible\n        return YES;\n    } else if (self.tmuxMode == TMUX_CLIENT && otherSession.tmuxMode == TMUX_CLIENT) {\n        // Clients are compatible with other clients from the same controller.\n        return (_tmuxController == otherSession.tmuxController);\n    } else {\n        // Clients are never compatible with non-clients.\n        return NO;\n    }\n}\n\n- (VT100GridCoordRange)smartSelectionRangeAt:(VT100GridCoord)coord {\n    if (coord.x < 0 || coord.y < 0 || coord.x >= _screen.width || coord.y >= _screen.height) {\n        return VT100GridCoordRangeMake(0, 0, 0, 0);\n    }\n    VT100GridWindowedRange range;\n    [_textview smartSelectAtX:coord.x\n                            y:coord.y + [_screen numberOfScrollbackLines]\n                           to:&range\n             ignoringNewlines:NO\n               actionRequired:NO\n              respectDividers:NO];\n    return [_textview rangeByTrimmingNullsFromRange:range.coordRange trimSpaces:YES];\n}\n\n- (void)addNoteAtCursor {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        PTYAnnotation *note = [[[PTYAnnotation alloc] init] autorelease];\n        VT100GridCoordRange rangeAtCursor =\n        [self smartSelectionRangeAt:VT100GridCoordMake(_screen.cursorX - 1,\n                                                       _screen.cursorY - 1)];\n        VT100GridCoordRange rangeBeforeCursor =\n        [self smartSelectionRangeAt:VT100GridCoordMake(_screen.cursorX - 2,\n                                                       _screen.cursorY - 1)];\n        VT100GridCoordRange rangeAfterCursor =\n        [self smartSelectionRangeAt:VT100GridCoordMake(_screen.cursorX,\n                                                       _screen.cursorY - 1)];\n        if (VT100GridCoordRangeLength(rangeAtCursor, _screen.width) > 0) {\n            [_screen addNote:note inRange:rangeAtCursor focus:YES];\n        } else if (VT100GridCoordRangeLength(rangeAfterCursor, _screen.width) > 0) {\n            [_screen addNote:note inRange:rangeAfterCursor focus:YES];\n        } else if (VT100GridCoordRangeLength(rangeBeforeCursor, _screen.width) > 0) {\n            [_screen addNote:note inRange:rangeBeforeCursor focus:YES];\n        } else {\n            int y = _screen.cursorY - 1 + [_screen numberOfScrollbackLines];\n            [_screen addNote:note\n                     inRange:VT100GridCoordRangeMake(0, y, _screen.width, y)\n                       focus:YES];\n        }\n    }];\n}\n\n- (void)textViewToggleAnnotations {\n    VT100GridCoordRange range =\n    VT100GridCoordRangeMake(0,\n                            0,\n                            _screen.width,\n                            _screen.height + [_screen numberOfScrollbackLines]);\n    NSArray<id<PTYAnnotationReading>> *annotations = [_screen annotationsInRange:range];\n    BOOL anyNoteIsVisible = NO;\n    for (id<PTYAnnotationReading> annotation in annotations) {\n        PTYNoteViewController *note = (PTYNoteViewController *)annotation.delegate;\n        if (!note.view.isHidden) {\n            anyNoteIsVisible = YES;\n            break;\n        }\n    }\n    for (id<PTYAnnotationReading> annotation in annotations) {\n        PTYNoteViewController *note = (PTYNoteViewController *)annotation.delegate;\n        [note setNoteHidden:anyNoteIsVisible];\n    }\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (void)textViewDidAddOrRemovePorthole {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (NSString *)textViewCurrentSSHSessionName {\n    if (!_conductor) {\n        return nil;\n    }\n    return _conductor.sshIdentity.description;\n}\n\n- (void)textViewDisconnectSSH {\n    if (!_conductor.framing) {\n        NSString *title = [NSString stringWithFormat:@\"Advanced SSH features are unavailable because Python %@ or later was not found on %@\", [iTermConductor minimumPythonVersionForFramer], _conductor.sshIdentity.hostname ?: @\"remote host\"];\n        [iTermWarning showWarningWithTitle:title\n                                   actions:@[ @\"OK\" ]\n                                 accessory:nil\n                                identifier:nil\n                               silenceable:kiTermWarningTypePersistent\n                                   heading:@\"Can\u2019t Disconnect\"\n                                    window:self.view.window];\n        return;\n    }\n    [_conductor quit];\n}\n\n\n- (void)highlightMarkOrNote:(id<IntervalTreeImmutableObject>)obj {\n    if ([obj isKindOfClass:[iTermMark class]]) {\n        BOOL hasErrorCode = NO;\n        if ([obj isKindOfClass:[VT100ScreenMark class]]) {\n            id<VT100ScreenMarkReading> mark = (id<VT100ScreenMarkReading>)obj;\n            hasErrorCode = mark.code != 0;\n        }\n        [_textview highlightMarkOnLine:VT100GridRangeMax([_screen lineNumberRangeOfInterval:obj.entry.interval])\n                          hasErrorCode:hasErrorCode];\n    } else {\n        id<PTYAnnotationReading> annotation = [PTYAnnotation castFrom:obj];\n        if (annotation) {\n            id<PTYAnnotationDelegate> note = annotation.delegate;\n            [note setNoteHidden:NO];\n            [note highlight];\n        }\n    }\n}\n\n- (void)nextMark {\n    if ([_modeHandler nextMark]) {\n        return;\n    }\n    [self nextMarkOrNote:NO];\n}\n\n- (void)nextAnnotation {\n    [self nextMarkOrNote:YES];\n}\n\n- (void)previousMark {\n    if ([_modeHandler previousMark]) {\n        return;\n    }\n    [self previousMarkOrNote:NO];\n}\n\n- (void)previousAnnotation {\n    [self previousMarkOrNote:YES];\n}\n\n- (void)previousMarkOrNote:(BOOL)annotationsOnly {\n    NSArray *objects = nil;\n    if (self.currentMarkOrNotePosition == nil) {\n        if (annotationsOnly) {\n            objects = [_screen lastAnnotations];\n        } else {\n            objects = [_screen lastMarks];\n        }\n    } else {\n        if (annotationsOnly) {\n            objects = [_screen annotationsBefore:self.currentMarkOrNotePosition];\n        } else {\n            objects = [_screen marksBefore:self.currentMarkOrNotePosition];\n        }\n        if (!objects.count) {\n            if (annotationsOnly) {\n                objects = [_screen lastAnnotations];\n            } else {\n                objects = [_screen lastMarks];\n            }\n            if (objects.count) {\n                [_textview beginFlash:kiTermIndicatorWrapToBottom];\n            }\n        }\n    }\n    if (objects.count) {\n        id<IntervalTreeObject> obj = objects[0];\n        self.currentMarkOrNotePosition = obj.entry.interval;\n        VT100GridRange range = [_screen lineNumberRangeOfInterval:self.currentMarkOrNotePosition];\n        [_textview scrollLineNumberRangeIntoView:range];\n        for (obj in objects) {\n            [self highlightMarkOrNote:obj];\n        }\n    }\n}\n\n- (BOOL)markIsNavigable:(id<iTermMark>)mark {\n    return ([mark isKindOfClass:[VT100ScreenMark class]] ||\n            [mark isKindOfClass:[PTYAnnotation class]]);\n}\n\n- (void)nextMarkOrNote:(BOOL)annotationsOnly {\n    NSArray<id<IntervalTreeImmutableObject>> *objects = nil;\n    if (self.currentMarkOrNotePosition == nil) {\n        if (annotationsOnly) {\n            objects = [_screen firstAnnotations];\n        } else {\n            objects = [_screen firstMarks];\n        }\n    } else {\n        if (annotationsOnly) {\n            objects = [_screen annotationsAfter:self.currentMarkOrNotePosition];\n        } else {\n            objects = [_screen marksAfter:self.currentMarkOrNotePosition];\n        }\n        if (!objects.count) {\n            if (annotationsOnly) {\n                objects = [_screen firstAnnotations];\n            } else {\n                objects = [_screen firstMarks];\n            }\n            if (objects.count) {\n                [_textview beginFlash:kiTermIndicatorWrapToTop];\n            }\n        }\n    }\n    if (objects.count) {\n        id<IntervalTreeImmutableObject> obj = objects[0];\n        self.currentMarkOrNotePosition = obj.entry.interval;\n        VT100GridRange range = [_screen lineNumberRangeOfInterval:self.currentMarkOrNotePosition];\n        [_textview scrollLineNumberRangeIntoView:range];\n        for (obj in objects) {\n            [self highlightMarkOrNote:obj];\n        }\n    }\n}\n\n- (void)scrollToMark:(id<iTermMark>)mark {\n    if ([_screen containsMark:mark]) {\n        VT100GridRange range = [_screen lineNumberRangeOfInterval:mark.entry.interval];\n        [_textview scrollLineNumberRangeIntoView:range];\n        [self highlightMarkOrNote:mark];\n    }\n}\n\n- (void)scrollToMarkWithGUID:(NSString *)guid {\n    id<VT100ScreenMarkReading> mark = [_screen namedMarkWithGUID:guid];\n    if (mark) {\n        [self scrollToMark:mark];\n    }\n}\n\n- (void)setCurrentHost:(id<VT100RemoteHostReading>)remoteHost {\n    [_currentHost autorelease];\n    _currentHost = [remoteHost retain];\n    [self.variablesScope setValue:remoteHost.hostname forVariableNamed:iTermVariableKeySessionHostname];\n    [self.variablesScope setValue:remoteHost.username forVariableNamed:iTermVariableKeySessionUsername];\n    [_delegate sessionCurrentHostDidChange:self];\n}\n\n- (id<VT100RemoteHostReading>)currentHost {\n    if (!_currentHost) {\n        // This is used when a session gets restored since _currentHost doesn't get persisted (and\n        // perhaps other edge cases I haven't found--it used to be done every time before the\n        // _currentHost ivar existed).\n        _currentHost = [[_screen remoteHostOnLine:[_screen numberOfLines]] retain];\n        if (_currentHost) {\n            [self.variablesScope setValue:_currentHost.hostname forVariableNamed:iTermVariableKeySessionHostname];\n            [self.variablesScope setValue:_currentHost.username forVariableNamed:iTermVariableKeySessionUsername];\n        }\n    }\n    return _currentHost;\n}\n\n#pragma mark tmux gateway delegate methods\n// TODO (also, capture and throw away keyboard input)\n\n- (NSString *)tmuxOwningSessionGUID {\n    return self.guid;\n}\n\n- (void)tmuxDidOpenInitialWindows {\n    if (_hideAfterTmuxWindowOpens) {\n        _hideAfterTmuxWindowOpens = NO;\n        [self hideSession];\n\n        static NSString *const kAutoBurialKey = @\"NoSyncAutoBurialReveal\";\n        if (![[NSUserDefaults standardUserDefaults] boolForKey:kAutoBurialKey]) {\n            [[iTermNotificationController sharedInstance] notify:@\"Session Buried\"\n                                                 withDescription:@\"It can be restored by detaching from tmux, or from the Sessions > Buried Sessions menu.\"];\n            [[NSUserDefaults standardUserDefaults] setBool:YES forKey:kAutoBurialKey];\n        }\n    }\n}\n\n- (BOOL)tmuxUpdateLayoutForWindow:(int)windowId\n                           layout:(NSString *)layout\n                    visibleLayout:(NSString *)visibleLayout\n                           zoomed:(NSNumber *)zoomed\n                             only:(BOOL)only {\n    DLog(@\"tmuxUpdateLayoutForWindow:%@ layout:%@ zoomed:%@ only:%@\",\n         @(windowId), layout, zoomed, @(only));\n    PTYTab *tab = [_tmuxController window:windowId];\n    if (!tab) {\n        DLog(@\"* NO TAB, DO NOTHING\");\n        return NO;\n    }\n    const BOOL result = [_tmuxController setLayoutInTab:tab\n                                               toLayout:layout\n                                          visibleLayout:visibleLayout\n                                                 zoomed:zoomed];\n    if (result && only) {\n        [_tmuxController adjustWindowSizeIfNeededForTabs:@[ tab ]];\n    }\n    return result;\n}\n\n- (void)tmuxWindowAddedWithId:(int)windowId {\n    if (![_tmuxController window:windowId]) {\n        [_tmuxController openWindowWithId:windowId\n                              intentional:NO\n                                  profile:[_tmuxController profileForWindow:self.delegate.tmuxWindow]];\n    }\n    [_tmuxController windowsChanged];\n}\n\n- (void)tmuxWindowClosedWithId:(int)windowId\n{\n    PTYTab *tab = [_tmuxController window:windowId];\n    if (tab) {\n        [[tab realParentWindow] removeTab:tab];\n    }\n    [_tmuxController windowsChanged];\n}\n\n- (void)tmuxWindowRenamedWithId:(int)windowId to:(NSString *)newName {\n    PTYSession *representativeSession = [[_tmuxController sessionsInWindow:windowId] firstObject];\n    [representativeSession.delegate sessionDidChangeTmuxWindowNameTo:newName];\n    [_tmuxController windowWasRenamedWithId:windowId to:newName];\n}\n\n- (void)tmuxInitialCommandDidCompleteSuccessfully {\n    // This kicks off a chain reaction that leads to windows being opened.\n    if (!_haveKickedOffTmux) {\n        // In tmux 1.9+ this happens before `tmuxSessionsChanged`.\n        [self kickOffTmux];\n    }\n}\n\n// When guessVersion finishes, if you have called openWindowsInitial, then windows will actually get\n// opened. Initial window opening is always blocked on establishing the server version.\n- (void)kickOffTmux {\n    _haveKickedOffTmux = YES;\n    [_tmuxController ping];\n    [_tmuxController validateOptions];\n    [_tmuxController checkForUTF8];\n    [_tmuxController loadDefaultTerminal];\n    [_tmuxController loadKeyBindings];\n    [_tmuxController exitCopyMode];\n    [_tmuxController guessVersion];  // NOTE: This kicks off more stuff that depends on knowing the version number.\n}\n\n- (void)tmuxInitialCommandDidFailWithError:(NSString *)error {\n    // Let the user know what went wrong. Do it async because this runs as a side-effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self printTmuxMessage:[NSString stringWithFormat:@\"tmux failed with error: \u201c%@\u201d\", error]];\n    });\n}\n\n- (void)tmuxPrintLine:(NSString *)line {\n    DLog(@\"%@\", line);\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState appendStringAtCursor:line];\n        [mutableState appendCarriageReturnLineFeed];\n    }];\n}\n\n- (void)tmuxGatewayDidTimeOut {\n    NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n    alert.messageText = @\"Force Detach?\";\n    alert.informativeText = @\"Tmux is not responding. Would you like to force detach?\";\n    [alert addButtonWithTitle:@\"Detach\"];\n    [alert addButtonWithTitle:@\"Cancel\"];\n    NSWindow *window = self.view.window;\n    NSInteger button;\n    if (window) {\n        button = [alert runSheetModalForWindow:window];\n    } else {\n        button = [alert runModal];\n    }\n    if (button == NSAlertFirstButtonReturn) {\n        [_tmuxGateway forceDetach];\n    }\n}\n\n- (void)tmuxActiveWindowPaneDidChangeInWindow:(int)windowID toWindowPane:(int)paneID {\n    [_tmuxController activeWindowPaneDidChangeInWindow:windowID toWindowPane:paneID];\n}\n\n- (void)tmuxSessionWindowDidChangeTo:(int)windowID {\n    [_tmuxController activeWindowDidChangeTo:windowID];\n}\n\n- (BOOL)tmuxGatewayShouldForceDetach {\n    NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n    alert.messageText = @\"Force Detach?\";\n    alert.informativeText = @\"A previous detach request has not yet been honored. Force detach?\";\n    [alert addButtonWithTitle:@\"OK\"];\n    [alert addButtonWithTitle:@\"Cancel\"];\n    NSWindow *window = self.view.window;\n    NSInteger button;\n    if (window) {\n        button = [alert runSheetModalForWindow:window];\n    } else {\n        button = [alert runModal];\n    }\n    return button == NSAlertFirstButtonReturn;\n}\n\n- (NSWindowController<iTermWindowController> *)tmuxGatewayWindow {\n    return _delegate.realParentWindow;\n}\n\n- (void)tmuxHostDisconnected:(NSString *)dcsID {\n    _hideAfterTmuxWindowOpens = NO;\n\n    if ([iTermPreferences boolForKey:kPreferenceKeyAutoHideTmuxClientSession] &&\n        [[[iTermBuriedSessions sharedInstance] buriedSessions] containsObject:self]) {\n        // Do this before detaching because it may be the only tab in a hotkey window. If all the\n        // tabs close the window is destroyed and it breaks the reference from iTermProfileHotkey.\n        // See issue 7384.\n        [[iTermBuriedSessions sharedInstance] restoreSession:self];\n    }\n\n    [_tmuxController detach];\n    // Autorelease the gateway because it called this function so we can't free\n    // it immediately.\n    [_tmuxGateway autorelease];\n    _tmuxGateway = nil;\n    [_tmuxController release];\n    _tmuxController = nil;\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState appendStringAtCursor:@\"Detached\"];\n        [mutableState appendCarriageReturnLineFeed];\n        [terminal.parser forceUnhookDCS:dcsID];\n    }];\n    self.tmuxMode = TMUX_NONE;\n    [self.variablesScope setValue:nil forVariableNamed:iTermVariableKeySessionTmuxClientName];\n    [self.variablesScope setValue:nil forVariableNamed:iTermVariableKeySessionTmuxPaneTitle];\n}\n\n- (void)tmuxCannotSendCharactersInSupplementaryPlanes:(NSString *)string windowPane:(int)windowPane {\n    PTYSession *session = [_tmuxController sessionForWindowPane:windowPane];\n    [session.naggingController tmuxSupplementaryPlaneErrorForCharacter:string];\n}\n\n- (void)tmuxSetSecureLogging:(BOOL)secureLogging {\n    _tmuxSecureLogging = secureLogging;\n}\n\n- (void)tmuxWriteString:(NSString *)string {\n    if (_exited) {\n        return;\n    }\n    if (_tmuxSecureLogging) {\n        DLog(@\"Write to tmux.\");\n    } else {\n        DLog(@\"Write to tmux: \\\"%@\\\"\", string);\n    }\n    if (_tmuxGateway.tmuxLogging) {\n        [self printTmuxMessage:[@\"> \" stringByAppendingString:string]];\n    }\n    if (_conductor && !_exited) {\n        // Running tmux inside an ssh client takes this path\n        [_conductor sendKeys:[string dataUsingEncoding:NSUTF8StringEncoding]];\n    } else {\n        [self writeTaskImpl:string encoding:NSUTF8StringEncoding forceEncoding:YES canBroadcast:NO reporting:NO];\n    }\n}\n\n+ (dispatch_queue_t)tmuxQueue {\n    static dispatch_queue_t tmuxQueue;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        tmuxQueue = dispatch_queue_create(\"com.iterm2.tmuxReadTask\", 0);\n    });\n    return tmuxQueue;\n}\n\n// This is called on the main thread when %output is parsed.\n- (void)tmuxReadTask:(NSData *)data windowPane:(int)wp latency:(NSNumber *)latency {\n    if (latency) {\n        [_tmuxController setCurrentLatency:latency.doubleValue forPane:wp];\n    }\n    [[_tmuxController sessionForWindowPane:wp] handleTmuxData:data];\n}\n\n- (void)handleTmuxData:(NSData *)data {\n    if (_exited) {\n        return;\n    }\n    if (_logging.style == iTermLoggingStyleRaw) {\n        [_logging logData:data];\n    }\n\n    // Send the bytes from %output in to the write end of a pipe. The data will come out\n    // iTermTmuxJobManager.fd, which TaskRegister selects on. The purpose of this pipe is to\n    // let tmux provide backpressure to the pty. In the old days, this would call -threadedReadTask:\n    // on the tmux queue. threadedReadTask: is meant to be called on the TaskNotifier queue and it\n    // will block if there are too many tokens outstanding. That is an effective mechanism to\n    // provide backpressure. By dispatching onto the tmuxQueue, infinite data could be buffered by\n    // GCD, breaking the backpressure mechanism. It is unfortunate that all tmux data must make\n    // two passes through TaskNotifier (once as `%output blah blah` and a second time as `blah blah`)\n    // but the alternative is unbounded latency. We still do the write on tmuxQueue because we\n    // don't want to block the main queue. GCD can still buffer here, but it's OK because\n    // TaskNotifier has a chance to get its queue blocked when it reads the data. That limits the\n    // rate that this can write, since it can only write after a %output is read.\n    __weak NSFileHandle *handle = _tmuxClientWritePipe;\n    dispatch_async([[self class] tmuxQueue], ^{\n        @try {\n            [handle writeData:data];\n        } @catch (NSException *exception) {\n            DLog(@\"%@ while writing to tmux pipe\", exception);\n        }\n    });\n}\n\n- (void)tmuxSessionPasteDidChange:(NSString *)pasteBufferName {\n    if ([iTermPreferences boolForKey:kPreferenceKeyTmuxSyncClipboard]) {\n        [_tmuxController copyBufferToLocalPasteboard:pasteBufferName];\n    } else {\n        [[[[iTermController sharedInstance] currentTerminal] currentSession] askToMirrorTmuxPasteBuffer];\n    }\n}\n\n- (void)askToMirrorTmuxPasteBuffer {\n    [_naggingController tmuxDidUpdatePasteBuffer];\n\n\n\n}\n\n- (void)tmuxWindowPaneDidPause:(int)wp notification:(BOOL)notification {\n    PTYSession *session = [_tmuxController sessionForWindowPane:wp];\n    [session setTmuxPaused:YES allowAutomaticUnpause:notification];\n}\n\n- (void)setTmuxPaused:(BOOL)paused allowAutomaticUnpause:(BOOL)allowAutomaticUnpause {\n    if (_tmuxPaused == paused) {\n        return;\n    }\n    _tmuxPaused = paused;\n    if (paused) {\n        _tmuxTTLHasThresholds = NO;\n        [self.tmuxController didPausePane:self.tmuxPane];\n        if (allowAutomaticUnpause && [iTermPreferences boolForKey:kPreferenceKeyTmuxUnpauseAutomatically]) {\n            __weak __typeof(self) weakSelf = self;\n            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n                [weakSelf setTmuxPaused:NO allowAutomaticUnpause:YES];\n            });\n            return;\n        }\n        [self showTmuxPausedAnnouncement:allowAutomaticUnpause];\n    } else {\n        [self unpauseTmux];\n    }\n}\n\n- (void)showTmuxPausedAnnouncement:(BOOL)notification {\n    NSString *title;\n    if (notification) {\n        title = @\"tmux paused this session because too much output was buffered.\";\n    } else {\n        title = @\"Session paused.\";\n    }\n\n    [self dismissAnnouncementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n    __weak __typeof(self) weakSelf = self;\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:title\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"_Unpause\", @\"_Settings\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case 0:\n                [weakSelf setTmuxPaused:NO allowAutomaticUnpause:YES];\n                break;\n            case 1:\n                [[PreferencePanel sharedInstance] openToPreferenceWithKey:kPreferenceKeyTmuxPauseModeAgeLimit];\n                [weakSelf showTmuxPausedAnnouncement:notification];\n                break;\n        }\n    }];\n    [self dismissAnnouncementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n    [self removeAnnouncementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n    [self queueAnnouncement:announcement identifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n}\n\n- (void)setTmuxHistory:(NSArray<NSData *> *)history\n            altHistory:(NSArray<NSData *> *)altHistory\n                 state:(NSDictionary *)state {\n    __weak __typeof(self) weakSelf = self;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [weakSelf reallySetTmuxHistory:history\n                            altHistory:altHistory\n                                 state:state\n                              terminal:terminal\n                          mutableState:mutableState];\n    }];\n}\n\n- (void)reallySetTmuxHistory:(NSArray<NSData *> *)history\n                  altHistory:(NSArray<NSData *> *)altHistory\n                       state:(NSDictionary *)state\n                    terminal:(VT100Terminal *)terminal\n                mutableState:(VT100ScreenMutableState *)mutableState {\n    [terminal resetForTmuxUnpause];\n    [self clearScrollbackBuffer];\n    [mutableState setHistory:history];\n    [mutableState setAltScreen:altHistory];\n    [self setTmuxState:state];\n    _view.scrollview.ptyVerticalScroller.userScroll = NO;\n}\n\n- (void)toggleTmuxPausePane {\n    if (_tmuxPaused) {\n        [self setTmuxPaused:NO allowAutomaticUnpause:YES];\n    } else {\n        [_tmuxController pausePanes:@[ @(self.tmuxPane) ]];\n    }\n}\n\n- (void)setTmuxState:(NSDictionary *)state {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        mutableState.tmuxState = state;\n    }];\n}\n\n- (void)unpauseTmux {\n    [self dismissAnnouncementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n    [self unzoomIfPossible];\n    [_tmuxController unpausePanes:@[ @(self.tmuxPane) ]];\n}\n\n- (void)pauseTmux {\n    [_tmuxController pausePanes:@[ @(self.tmuxPane) ]];\n}\n\n- (void)tmuxSessionChanged:(NSString *)sessionName sessionId:(int)sessionId {\n    [_tmuxController sessionChangedTo:sessionName sessionId:sessionId];\n    if (!_haveKickedOffTmux) {\n        // Tell the tmux controller we want to open initial windows after version guessing finishes.\n        [_tmuxController openWindowsInitial];\n        // In tmux 1.8, this happens before `tmuxInitialCommandDidCompleteSuccessfully`.\n        [self kickOffTmux];\n    }\n}\n\n- (void)tmuxSessionsChanged {\n    [_tmuxController sessionsChanged];\n}\n\n- (void)tmuxWindowsDidChange\n{\n    [_tmuxController windowsChanged];\n}\n\n- (void)tmuxSession:(int)sessionId renamed:(NSString *)newName\n{\n    [_tmuxController session:sessionId renamedTo:newName];\n}\n\n- (VT100GridSize)tmuxClientSize {\n    if (!_delegate) {\n        DLog(@\"No delegate so use saved grid size %@\", VT100GridSizeDescription(_savedGridSize));\n        return _savedGridSize;\n    }\n    DLog(@\"Get size from delegate %@, controller tmuxController %@, window %@\", _delegate,\n         _tmuxController, @(self.delegate.tmuxWindow));\n    return [_delegate sessionTmuxSizeWithProfile:[_tmuxController profileForWindow:self.delegate.tmuxWindow]];\n}\n\n- (NSInteger)tmuxNumberOfLinesOfScrollbackHistory {\n    Profile *profile = [_tmuxController profileForWindow:self.delegate.tmuxWindow];\n    if ([iTermPreferences useTmuxProfile]) {\n        profile = [[ProfileModel sharedInstance] tmuxProfile];\n    }\n    if ([profile[KEY_UNLIMITED_SCROLLBACK] boolValue]) {\n        // 10M is close enough to infinity to be indistinguishable.\n        return 10 * 1000 * 1000;\n    } else {\n        return [profile[KEY_SCROLLBACK_LINES] integerValue];\n    }\n}\n\n- (void)tmuxDoubleAttachForSessionGUID:(NSString *)sessionGUID {\n    NSArray<NSString *> *actions = @[ @\"OK\", @\"Reveal\", @\"Force Detach Other\" ];\n    TmuxController *controller = [[TmuxControllerRegistry sharedInstance] tmuxControllerWithSessionGUID:sessionGUID];\n    if (!controller) {\n        actions = @[ @\"OK\" ];\n    }\n    const iTermWarningSelection selection =\n    [iTermWarning showWarningWithTitle:@\"This instance of iTerm2 is already attached to this session\"\n                               actions:actions\n                             accessory:nil\n                            identifier:@\"AlreadyAttachedToTmuxSession\"\n                           silenceable:kiTermWarningTypePersistent\n                               heading:@\"Cannot Attach\"\n                                window:self.view.window];\n    switch (selection) {\n        case kiTermWarningSelection0:\n            return;\n        case kiTermWarningSelection1:\n            break;\n        case kiTermWarningSelection2:\n            [controller.gateway forceDetach];\n            return;\n        default:\n            assert(NO);\n    }\n\n    PTYSession *aSession =\n    [[controller.clientSessions sortedArrayUsingComparator:^NSComparisonResult(PTYSession *s1, PTYSession *s2) {\n        return [s1.guid compare:s2.guid];\n    }] firstObject];\n\n    if (!aSession) {\n        aSession = [PTYSession castFrom:controller.gateway.delegate];\n    }\n    if (!aSession) {\n        iTermApplicationDelegate *delegate = [iTermApplication.sharedApplication delegate];\n        [delegate openDashboard:nil];\n        return;\n    }\n    [aSession reveal];\n}\n\n- (void)tmuxWillKillWindow:(NSNotification *)notification {\n    if ([self.delegate tmuxWindow] == [notification.object intValue]) {\n        _tmuxWindowClosingByClientRequest = YES;\n    }\n}\n\n#pragma mark PTYTextViewDelegate\n\n- (BOOL)isPasting {\n    return _pasteHelper.isPasting;\n}\n\n- (void)queueKeyDown:(NSEvent *)event {\n    [_pasteHelper enqueueEvent:event];\n}\n\n- (BOOL)event:(NSEvent *)event matchesPattern:(ITMKeystrokePattern *)pattern {\n    if (event.type != NSEventTypeKeyDown) {\n        return NO;\n    }\n    NSMutableArray *actualModifiers = [NSMutableArray array];\n    if (event.it_modifierFlags & NSEventModifierFlagControl) {\n        [actualModifiers addObject:@(ITMModifiers_Control)];\n    }\n    if (event.it_modifierFlags & NSEventModifierFlagOption) {\n        [actualModifiers addObject:@(ITMModifiers_Option)];\n    }\n    if (event.it_modifierFlags & NSEventModifierFlagCommand) {\n        [actualModifiers addObject:@(ITMModifiers_Command)];\n    }\n    if (event.it_modifierFlags & NSEventModifierFlagShift) {\n        [actualModifiers addObject:@(ITMModifiers_Shift)];\n    }\n    if (event.it_modifierFlags & NSEventModifierFlagFunction) {\n        [actualModifiers addObject:@(ITMModifiers_Function)];\n    }\n    if (event.it_modifierFlags & NSEventModifierFlagNumericPad) {\n        [actualModifiers addObject:@(ITMModifiers_Numpad)];\n    }\n    for (NSInteger i = 0; i < pattern.requiredModifiersArray_Count; i++) {\n        ITMModifiers modifier = [pattern.requiredModifiersArray valueAtIndex:i];\n        if (![actualModifiers containsObject:@(modifier)]) {\n            return NO;\n        }\n    }\n    for (NSInteger i = 0; i < pattern.forbiddenModifiersArray_Count; i++) {\n        ITMModifiers modifier = [pattern.forbiddenModifiersArray valueAtIndex:i];\n        if ([actualModifiers containsObject:@(modifier)]) {\n            return NO;\n        }\n    }\n\n    // All necessary conditions are satisifed. Now find one that is sufficient.\n    for (NSInteger i = 0; i < pattern.keycodesArray_Count; i++) {\n        if (event.keyCode == [pattern.keycodesArray valueAtIndex:i]) {\n            return YES;\n        }\n    }\n    for (NSString *characters in pattern.charactersArray) {\n        if ([event.characters isEqualToString:characters]) {\n            return YES;\n        }\n    }\n    for (NSString *charactersIgnoringModifiers in pattern.charactersIgnoringModifiersArray) {\n        if ([event.charactersIgnoringModifiers isEqualToString:charactersIgnoringModifiers]) {\n            return YES;\n        }\n    }\n    return NO;\n}\n\n- (BOOL)keystrokeIsFilteredByMonitor:(NSEvent *)event {\n    for (NSString *identifier in _keyboardFilterSubscriptions) {\n        ITMNotificationRequest *request = _keyboardFilterSubscriptions[identifier];\n        for (ITMKeystrokePattern *pattern in request.keystrokeFilterRequest.patternsToIgnoreArray) {\n            if ([self event:event matchesPattern:pattern]) {\n                return YES;\n            }\n        }\n        // Prior to 1.17, the filter monitor used keystrokeMonitorRequest instead of keystrokeFilterRequest.\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n        for (ITMKeystrokePattern *pattern in request.keystrokeMonitorRequest.patternsToIgnoreArray) {\n#pragma clang diagnostic pop\n            if ([self event:event matchesPattern:pattern]) {\n                return YES;\n            }\n        }\n    }\n    return NO;\n}\n\n- (VT100SyncResult)textViewWillRefresh {\n    return [self syncCheckingTriggers:VT100ScreenTriggerCheckTypePartialLines\n                        resetOverflow:YES];\n}\n\n- (VT100ScreenState *)screenSwitchToSharedState {\n    return [_screen switchToSharedState];\n}\n\n- (void)screenRestoreState:(VT100ScreenState *)state {\n    [_screen restoreState:state];\n    _textview.colorMap = state.colorMap;\n}\n\n- (VT100MutableScreenConfiguration *)screenConfiguration {\n    [self updateConfigurationFields];\n    return _config;\n}\n\n- (void)screenSync:(VT100ScreenMutableState *)mutableState {\n    const VT100SyncResult result = [self syncCheckingTriggers:VT100ScreenTriggerCheckTypeNone\n                                                resetOverflow:NO\n                                                 mutableState:mutableState];\n    if (result.namedMarksChanged) {\n        [[[[iTermNamedMarksDidChangeNotification alloc] initWithSessionGuid:self.guid] autorelease] post];\n    }\n}\n\n- (void)screenSyncExpect:(VT100ScreenMutableState *)mutableState {\n    const BOOL expectWasDirty = _expect.dirty;\n    [_expect resetDirty];\n    if (expectWasDirty) {\n        [mutableState updateExpectFrom:_expect];\n    }\n}\n\n- (void)sync {\n    DLog(@\"sync\\n%@\", [NSThread callStackSymbols]);\n    [self syncCheckingTriggers:VT100ScreenTriggerCheckTypeNone\n                 resetOverflow:NO];\n}\n\n- (void)syncCheckingTriggers:(VT100ScreenTriggerCheckType)checkTriggers {\n    DLog(@\"syncCheckingTriggers:%@\", @(checkTriggers));\n    [self syncCheckingTriggers:checkTriggers resetOverflow:NO];\n}\n\n// Only main-thread-initiated syncs take this route.\n- (VT100SyncResult)syncCheckingTriggers:(VT100ScreenTriggerCheckType)checkTriggers\n                          resetOverflow:(BOOL)resetOverflow {\n    DLog(@\"syncCheckingTriggers:%@ resetOverflow:%@ %@\", @(checkTriggers), @(resetOverflow), self);\n    __block VT100SyncResult result = { 0 };\n    [_screen performLightweightBlockWithJoinedThreads:^(VT100ScreenMutableState *mutableState) {\n        DLog(@\"lightweight block running for %@\", self);\n        result = [self syncCheckingTriggers:checkTriggers\n                              resetOverflow:resetOverflow\n                               mutableState:mutableState];\n    }];\n    if (result.namedMarksChanged) {\n        [[[[iTermNamedMarksDidChangeNotification alloc] initWithSessionGuid:self.guid] autorelease] post];\n    }\n    return result;\n}\n\n// This is a funnel that all syncs go through.\n- (VT100SyncResult)syncCheckingTriggers:(VT100ScreenTriggerCheckType)checkTriggers\n                          resetOverflow:(BOOL)resetOverflow\n                           mutableState:(VT100ScreenMutableState *)mutableState {\n    DLog(@\"syncCheckingTriggers:%@ resetOverflow:%@ mutableState:%@ self:%@\",\n         @(checkTriggers), @(resetOverflow), mutableState, self);\n    [self updateConfigurationFields];\n    const BOOL expectWasDirty = _expect.dirty;\n    [_expect resetDirty];\n    const VT100SyncResult syncResult = [_screen synchronizeWithConfig:_config\n                                                               expect:expectWasDirty ? _expect : nil\n                                                        checkTriggers:checkTriggers\n                                                        resetOverflow:resetOverflow\n                                                         mutableState:mutableState];\n    _textview.colorMap = _screen.colorMap;\n    DLog(@\"END syncCheckingTriggers\");\n    return syncResult;\n}\n\n- (void)enableOffscreenMarkAlertsIfNeeded {\n    DLog(@\"enableOffscreenMarkAlertsIfNeeded %@\", self);\n    if (_temporarilySuspendOffscreenMarkAlerts) {\n        DLog(@\"_temporarilySuspendOffscreenMarkAlerts = NO for %@\", self);\n        _temporarilySuspendOffscreenMarkAlerts = NO;\n        [self sync];\n    }\n}\n\n- (BOOL)textViewShouldAcceptKeyDownEvent:(NSEvent *)event {\n    [self enableOffscreenMarkAlertsIfNeeded];\n    const BOOL accept = [self shouldAcceptKeyDownEvent:event];\n    if (accept) {\n        [_cadenceController didHandleKeystroke];\n    }\n    return accept;\n}\n\n- (BOOL)shouldReportOrFilterKeystrokesForAPI {\n    if (self.isTmuxClient && _tmuxPaused) {\n        // This ignores the monitor filter and subscriptions because it might be the only way to\n        // unpause.\n        return NO;\n    }\n    return YES;\n}\n\n- (void)textViewDidReceiveFlagsChangedEvent:(NSEvent *)event {\n    if ([self shouldReportOrFilterKeystrokesForAPI]) {\n        [self sendKeystrokeNotificationForEvent:event advanced:YES];\n    }\n    // Change of cmd modifier means we need mouseMoved events to highlight/unhighlight URLs.\n    [self.view updateTrackingAreas];\n}\n\n- (BOOL)shouldAcceptKeyDownEvent:(NSEvent *)event {\n    const BOOL accept = ![self keystrokeIsFilteredByMonitor:event];\n\n    if (accept) {\n        if (_textview.selection.hasSelection &&\n            !_textview.selection.live &&\n            [_modeHandler.copyModeHandler shouldAutoEnterWithEvent:event]) {\n            // Avoid handling the event twice (which is the cleverness)\n            [_modeHandler enterCopyModeWithoutCleverness];\n            [_modeHandler.copyModeHandler handleAutoEnteringEvent:event];\n            return NO;\n        }\n        if (_modeHandler.mode != iTermSessionModeDefault) {\n            [_modeHandler handleEvent:event];\n            return NO;\n        }\n        if (event.keyCode == kVK_Return) {\n            [_screen userDidPressReturn];\n        }\n\n        if ((event.it_modifierFlags & NSEventModifierFlagControl) && [event.charactersIgnoringModifiers isEqualToString:@\"c\"]) {\n            if (_screen.terminalReceivingFile) {\n                // Offer to abort download if you press ^c while downloading an inline file\n                [self.naggingController askAboutAbortingDownload];\n            } else if (self.upload) {\n                [self.naggingController askAboutAbortingUpload];\n            }\n        }\n        _lastInput = [NSDate timeIntervalSinceReferenceDate];\n        [_pwdPoller userDidPressKey];\n        if ([_view.currentAnnouncement handleKeyDown:event]) {\n            return NO;\n        }\n    }\n    if (![self shouldReportOrFilterKeystrokesForAPI]) {\n        [self setTmuxPaused:NO allowAutomaticUnpause:YES];\n        return NO;\n    }\n    if (_keystrokeSubscriptions.count && ![event it_eventGetsSpecialHandlingForAPINotifications]) {\n        [self sendKeystrokeNotificationForEvent:event advanced:NO];\n    }\n\n    if (accept) {\n        [_metaFrustrationDetector didSendKeyEvent:event];\n    }\n    if ([self eventAbortsPasteWaitingForPrompt:event]) {\n        [_pasteHelper abort];\n        return NO;\n    }\n\n    return accept;\n}\n\n- (NSArray<NSNumber *> *)apiModifiersForModifierFlags:(NSEventModifierFlags)flags {\n    NSMutableArray<NSNumber *> *mods = [NSMutableArray array];\n    if (flags & NSEventModifierFlagControl) {\n        [mods addObject:@(ITMModifiers_Control)];\n    }\n    if (flags & NSEventModifierFlagOption) {\n        [mods addObject:@(ITMModifiers_Option)];\n    }\n    if (flags & NSEventModifierFlagCommand) {\n        [mods addObject:@(ITMModifiers_Command)];\n    }\n    if (flags & NSEventModifierFlagShift) {\n        [mods addObject:@(ITMModifiers_Shift)];\n    }\n    if (flags & NSEventModifierFlagNumericPad) {\n        [mods addObject:@(ITMModifiers_Numpad)];\n    }\n    if (flags & NSEventModifierFlagFunction) {\n        [mods addObject:@(ITMModifiers_Function)];\n    }\n    return mods;\n}\n\n- (void)sendKeystrokeNotificationForEvent:(NSEvent *)event\n                                 advanced:(BOOL)advanced {\n    ITMKeystrokeNotification *keystrokeNotification = [[[ITMKeystrokeNotification alloc] init] autorelease];\n    if (!advanced || event.type != NSEventTypeFlagsChanged) {\n        keystrokeNotification.characters = event.characters;\n        keystrokeNotification.charactersIgnoringModifiers = event.charactersIgnoringModifiers;\n    }\n    for (NSNumber *number in [self apiModifiersForModifierFlags:event.it_modifierFlags]) {\n        [keystrokeNotification.modifiersArray addValue:number.intValue];\n    }\n    switch (event.type) {\n        case NSEventTypeKeyDown:\n            keystrokeNotification.action = ITMKeystrokeNotification_Action_KeyDown;\n            break;\n        case NSEventTypeKeyUp:\n            keystrokeNotification.action = ITMKeystrokeNotification_Action_KeyUp;\n            break;\n        case NSEventTypeFlagsChanged:\n            keystrokeNotification.action = ITMKeystrokeNotification_Action_FlagsChanged;\n            break;\n        default:\n            break;\n    }\n    keystrokeNotification.keyCode = event.keyCode;\n    keystrokeNotification.session = self.guid;\n    ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n    notification.keystrokeNotification = keystrokeNotification;\n\n    [_keystrokeSubscriptions enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n        if (advanced && !obj.keystrokeMonitorRequest.advanced) {\n            return;\n        }\n        [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                             toConnectionKey:key];\n    }];\n}\n\n- (BOOL)eventAbortsPasteWaitingForPrompt:(NSEvent *)event {\n    if (!_pasteHelper.isWaitingForPrompt) {\n        return NO;\n    }\n    if (event.keyCode == kVK_Escape) {\n        return YES;\n    }\n    const NSEventModifierFlags mask = (NSEventModifierFlagOption |\n                                       NSEventModifierFlagShift |\n                                       NSEventModifierFlagCommand |\n                                       NSEventModifierFlagControl);\n    if ((event.modifierFlags & mask) == NSEventModifierFlagControl &&\n        [event.characters isEqualToString:[NSString stringWithLongCharacter:3]]) {\n        // ^C\n        return YES;\n    }\n    return NO;\n}\n\n+ (void)reportFunctionCallError:(NSError *)error forInvocation:(NSString *)invocation origin:(NSString *)origin window:(NSWindow *)window {\n    NSString *message = [NSString stringWithFormat:@\"Error running \u201c%@\u201d:\\n%@\",\n                         invocation, error.localizedDescription];\n    NSString *traceback = error.localizedFailureReason;\n    NSArray *actions = @[ @\"OK\" ];\n    if (traceback) {\n        actions = [actions arrayByAddingObject:@\"Reveal in Script Console\"];\n    }\n    NSString *connectionKey = error.userInfo[iTermAPIHelperFunctionCallErrorUserInfoKeyConnection];\n    iTermScriptHistoryEntry *entry = [[iTermScriptHistory sharedInstance] entryWithIdentifier:connectionKey];\n    [entry addOutput:[NSString stringWithFormat:@\"An error occurred while running the function invocation \u201c%@\u201d:\\n%@\\n\\nTraceback:\\n%@\",\n                      invocation,\n                      error.localizedDescription,\n                      traceback]\n          completion:^{}];\n    iTermWarningSelection selection = [iTermWarning showWarningWithTitle:message\n                                                                 actions:actions\n                                                               accessory:nil\n                                                              identifier:@\"NoSyncFunctionCallError\"\n                                                             silenceable:kiTermWarningTypeTemporarilySilenceable\n                                                                 heading:[NSString stringWithFormat:@\"%@ Function Call Failed\", origin]\n                                                                  window:window];\n    if (selection == kiTermWarningSelection1) {\n        [[iTermScriptConsole sharedInstance] revealTailOfHistoryEntry:entry];\n    }\n}\n\n- (void)invokeFunctionCall:(NSString *)invocation\n                     scope:(iTermVariableScope *)scope\n                    origin:(NSString *)origin {\n    [iTermScriptFunctionCall callFunction:invocation\n                                  timeout:[[NSDate distantFuture] timeIntervalSinceNow]\n                                    scope:scope\n                               retainSelf:YES\n                               completion:^(id value, NSError *error, NSSet<NSString *> *missing) {\n        if (error) {\n            [PTYSession reportFunctionCallError:error\n                                  forInvocation:invocation\n                                         origin:origin\n                                         window:self.view.window];\n        }\n    }];\n}\n\n- (void)applyAction:(iTermAction *)action {\n    [self.textview.window makeFirstResponder:self.textview];\n    [self performKeyBindingAction:[iTermKeyBindingAction withAction:action.action\n                                                          parameter:action.parameter\n                                                           escaping:action.escaping\n                                                          applyMode:action.applyMode]\n                            event:nil];\n}\n\n// This is limited to the actions that don't need any existing session\n+ (BOOL)performKeyBindingAction:(iTermKeyBindingAction *)action event:(NSEvent *)event {\n    if (!action) {\n        return NO;\n    }\n    NSArray<PTYSession *> *sessions = [PTYSession sessionsForActionApplyMode:action.applyMode focused:nil];\n    if (action.applyMode != iTermActionApplyModeCurrentSession && sessions.count > 0) {\n        for (PTYSession *session in sessions) {\n            [session reallyPerformKeyBindingAction:action event:event];\n        }\n        return YES;\n    }\n\n    switch (action.keyAction) {\n        case KEY_ACTION_INVALID:\n            // No action\n            return NO;\n\n        case KEY_ACTION_IGNORE:\n            return YES;\n\n        case KEY_ACTION_MOVE_TAB_LEFT:\n        case KEY_ACTION_MOVE_TAB_RIGHT:\n        case KEY_ACTION_NEXT_MRU_TAB:\n        case KEY_ACTION_PREVIOUS_MRU_TAB:\n        case KEY_ACTION_NEXT_PANE:\n        case KEY_ACTION_PREVIOUS_PANE:\n        case KEY_ACTION_NEXT_SESSION:\n        case KEY_ACTION_NEXT_WINDOW:\n        case KEY_ACTION_PREVIOUS_SESSION:\n        case KEY_ACTION_PREVIOUS_WINDOW:\n        case KEY_ACTION_SCROLL_END:\n        case KEY_ACTION_SCROLL_HOME:\n        case KEY_ACTION_SCROLL_LINE_DOWN:\n        case KEY_ACTION_SCROLL_LINE_UP:\n        case KEY_ACTION_SCROLL_PAGE_DOWN:\n        case KEY_ACTION_SCROLL_PAGE_UP:\n        case KEY_ACTION_ESCAPE_SEQUENCE:\n        case KEY_ACTION_HEX_CODE:\n        case KEY_ACTION_TEXT:\n        case KEY_ACTION_VIM_TEXT:\n        case KEY_ACTION_RUN_COPROCESS:\n        case KEY_ACTION_SEND_C_H_BACKSPACE:\n        case KEY_ACTION_SEND_C_QM_BACKSPACE:\n        case KEY_ACTION_IR_FORWARD:\n        case KEY_ACTION_IR_BACKWARD:\n        case KEY_ACTION_SELECT_PANE_LEFT:\n        case KEY_ACTION_SELECT_PANE_RIGHT:\n        case KEY_ACTION_SELECT_PANE_ABOVE:\n        case KEY_ACTION_SELECT_PANE_BELOW:\n        case KEY_ACTION_DO_NOT_REMAP_MODIFIERS:\n        case KEY_ACTION_REMAP_LOCALLY:\n        case KEY_ACTION_TOGGLE_FULLSCREEN:\n        case KEY_ACTION_SPLIT_HORIZONTALLY_WITH_PROFILE:\n        case KEY_ACTION_SPLIT_VERTICALLY_WITH_PROFILE:\n        case KEY_ACTION_SET_PROFILE:\n        case KEY_ACTION_LOAD_COLOR_PRESET:\n        case KEY_ACTION_FIND_REGEX:\n        case KEY_FIND_AGAIN_DOWN:\n        case KEY_FIND_AGAIN_UP:\n        case KEY_ACTION_PASTE_SPECIAL_FROM_SELECTION:\n        case KEY_ACTION_PASTE_SPECIAL:\n        case KEY_ACTION_TOGGLE_HOTKEY_WINDOW_PINNING:\n        case KEY_ACTION_MOVE_END_OF_SELECTION_LEFT:\n        case KEY_ACTION_MOVE_END_OF_SELECTION_RIGHT:\n        case KEY_ACTION_MOVE_START_OF_SELECTION_LEFT:\n        case KEY_ACTION_MOVE_START_OF_SELECTION_RIGHT:\n        case KEY_ACTION_DECREASE_HEIGHT:\n        case KEY_ACTION_INCREASE_HEIGHT:\n        case KEY_ACTION_DECREASE_WIDTH:\n        case KEY_ACTION_INCREASE_WIDTH:\n        case KEY_ACTION_SWAP_PANE_LEFT:\n        case KEY_ACTION_SWAP_PANE_RIGHT:\n        case KEY_ACTION_SWAP_PANE_ABOVE:\n        case KEY_ACTION_SWAP_PANE_BELOW:\n        case KEY_ACTION_TOGGLE_MOUSE_REPORTING:\n        case KEY_ACTION_DUPLICATE_TAB:\n        case KEY_ACTION_MOVE_TO_SPLIT_PANE:\n        case KEY_ACTION_SEND_SNIPPET:\n        case KEY_ACTION_COMPOSE:\n        case KEY_ACTION_SEND_TMUX_COMMAND:\n        case KEY_ACTION_SWAP_WITH_NEXT_PANE:\n        case KEY_ACTION_SWAP_WITH_PREVIOUS_PANE:\n        case KEY_ACTION_ALERT_ON_NEXT_MARK:\n            return NO;\n\n        case KEY_ACTION_COPY_OR_SEND:\n            return [[NSApp mainMenu] performActionForItemWithSelector:@selector(copy:)];\n\n        case KEY_ACTION_PASTE_OR_SEND:\n            return [[NSApp mainMenu] performActionForItemWithSelector:@selector(paste:)];\n\n        case KEY_ACTION_INVOKE_SCRIPT_FUNCTION:\n            [iTermScriptFunctionCall callFunction:action.parameter\n                                          timeout:[[NSDate distantFuture] timeIntervalSinceNow]\n                                            scope:[iTermVariableScope globalsScope]\n                                       retainSelf:YES\n                                       completion:^(id value, NSError *error, NSSet<NSString *> *missing) {\n                if (error) {\n                    [PTYSession reportFunctionCallError:error\n                                          forInvocation:action.parameter\n                                                 origin:@\"Key Binding\"\n                                                 window:nil];\n                }\n            }];\n            return YES;\n\n        case KEY_ACTION_SELECT_MENU_ITEM:\n            [PTYSession selectMenuItem:action.parameter];\n            return YES;\n        case KEY_ACTION_NEW_TAB_WITH_PROFILE:\n        case KEY_ACTION_NEW_WINDOW_WITH_PROFILE: {\n            Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:action.parameter];\n            [iTermSessionLauncher launchBookmark:profile\n                                      inTerminal:nil\n                              respectTabbingMode:NO\n                                      completion:nil];\n            return YES;\n        }\n        case KEY_ACTION_UNDO:\n            [PTYSession selectMenuItemWithSelector:@selector(undo:)];\n            return YES;\n\n        case KEY_ACTION_SEQUENCE: {\n            NSArray<iTermKeyBindingAction *> *subactions = [action.parameter keyBindingActionsFromSequenceParameter];\n            for (iTermKeyBindingAction *subaction in subactions) {\n                [self performKeyBindingAction:subaction event:event];\n            }\n            return YES;\n        }\n    }\n    assert(false);\n    return NO;\n}\n\n+ (NSArray<PTYSession *> *)sessionsForActionApplyMode:(iTermActionApplyMode)mode focused:(PTYSession *)focused {\n    switch (mode) {\n        case iTermActionApplyModeCurrentSession:\n            return focused ? @[ focused ] : @[];\n        case iTermActionApplyModeAllSessions:\n            return [[iTermController sharedInstance] allSessions];\n        case iTermActionApplyModeUnfocusedSessions:\n            return [[[iTermController sharedInstance] allSessions] arrayByRemovingObject:focused];\n        case iTermActionApplyModeAllInWindow:\n            return [focused.delegate.realParentWindow allSessions] ?: @[];\n        case iTermActionApplyModeAllInTab:\n            return [focused.delegate sessions] ?: @[];\n        case iTermActionApplyModeBroadcasting:\n            if (!focused) {\n                return @[];\n            }\n            if (focused.delegate.realParentWindow.broadcastMode == BROADCAST_OFF) {\n                return @[ focused ];\n            }\n            return focused.delegate.realParentWindow.broadcastSessions ?: @[ focused ];\n    }\n    return @[];\n}\n\n- (void)performKeyBindingAction:(iTermKeyBindingAction *)action event:(NSEvent *)event {\n    if (!action) {\n        return;\n    }\n    for (PTYSession *session in [PTYSession sessionsForActionApplyMode:action.applyMode focused:self]) {\n        [session reallyPerformKeyBindingAction:action event:event];\n    }\n}\n\n- (void)reallyPerformKeyBindingAction:(iTermKeyBindingAction *)action event:(NSEvent *)event {\n    BOOL isTmuxGateway = (!_exited && self.tmuxMode == TMUX_GATEWAY);\n    id<iTermWindowController> windowController = self.delegate.realParentWindow ?: [[iTermController sharedInstance] currentTerminal];\n\n    switch (action.keyAction) {\n        case KEY_ACTION_MOVE_TAB_LEFT:\n            [[_delegate realParentWindow] moveTabLeft:nil];\n            break;\n        case KEY_ACTION_MOVE_TAB_RIGHT:\n            [[_delegate realParentWindow] moveTabRight:nil];\n            break;\n        case KEY_ACTION_NEXT_MRU_TAB:\n            [[[_delegate realParentWindow] tabView] cycleKeyDownWithModifiers:[event it_modifierFlags]\n                                                                     forwards:YES];\n            break;\n        case KEY_ACTION_PREVIOUS_MRU_TAB:\n            [[[_delegate realParentWindow] tabView] cycleKeyDownWithModifiers:[event it_modifierFlags]\n                                                                     forwards:NO];\n            break;\n        case KEY_ACTION_NEXT_PANE:\n            [_delegate nextSession];\n            break;\n        case KEY_ACTION_PREVIOUS_PANE:\n            [_delegate previousSession];\n            break;\n        case KEY_ACTION_NEXT_SESSION:\n            [[_delegate realParentWindow] nextTab:nil];\n            break;\n        case KEY_ACTION_NEXT_WINDOW:\n            [[iTermController sharedInstance] nextTerminal];\n            break;\n        case KEY_ACTION_PREVIOUS_SESSION:\n            [[_delegate realParentWindow] previousTab:nil];\n            break;\n        case KEY_ACTION_PREVIOUS_WINDOW:\n            [[iTermController sharedInstance] previousTerminal];\n            break;\n        case KEY_ACTION_SCROLL_END:\n            [_textview scrollEnd];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_SCROLL_HOME:\n            [_textview scrollHome];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_SCROLL_LINE_DOWN:\n            [_textview scrollLineDown:self];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_SCROLL_LINE_UP:\n            [_textview scrollLineUp:self];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_SCROLL_PAGE_DOWN:\n            [_textview scrollPageDown:self];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_SCROLL_PAGE_UP:\n            [_textview scrollPageUp:self];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_ESCAPE_SEQUENCE:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self sendEscapeSequence:action.parameter];\n            break;\n        case KEY_ACTION_HEX_CODE:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self sendHexCode:action.parameter];\n            break;\n        case KEY_ACTION_TEXT:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self sendText:action.parameter escaping:action.escaping];\n            break;\n        case KEY_ACTION_VIM_TEXT:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self sendText:action.parameter escaping:action.vimEscaping];\n            break;\n        case KEY_ACTION_SEND_SNIPPET:\n            if (_exited || isTmuxGateway) {\n                return;\n            } else {\n                DLog(@\"Look up snippet with param %@\", action.parameter);\n                iTermSnippet *snippet = [[iTermSnippetsModel sharedInstance] snippetWithActionKey:action.parameter];\n                if (snippet) {\n                    [self sendText:snippet.value escaping:snippet.escaping];\n                }\n            }\n            break;\n        case KEY_ACTION_COMPOSE:\n            if (_exited || isTmuxGateway) {\n                return;\n            } else {\n                DLog(@\"Open composer with%@\", action.parameter);\n                [self.composerManager showWithCommand:action.parameter];\n            }\n            break;\n        case KEY_ACTION_SEND_TMUX_COMMAND:\n            if (_exited || isTmuxGateway || !self.isTmuxClient) {\n                return;\n            }\n            [self performTmuxCommand:action.parameter];\n            break;\n        case KEY_ACTION_RUN_COPROCESS:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self launchCoprocessWithCommand:action.parameter];\n            break;\n        case KEY_ACTION_SELECT_MENU_ITEM:\n            [PTYSession selectMenuItem:action.parameter];\n            break;\n\n        case KEY_ACTION_SEND_C_H_BACKSPACE:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self writeStringWithLatin1Encoding:@\"\\010\"];\n            break;\n        case KEY_ACTION_SEND_C_QM_BACKSPACE:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self writeStringWithLatin1Encoding:@\"\\177\"]; // decimal 127\n            break;\n        case KEY_ACTION_IGNORE:\n            break;\n        case KEY_ACTION_IR_FORWARD:\n            break;\n        case KEY_ACTION_IR_BACKWARD:\n            if (isTmuxGateway) {\n                return;\n            }\n            [[iTermController sharedInstance] irAdvance:-1];\n            break;\n        case KEY_ACTION_SELECT_PANE_LEFT:\n            [windowController selectPaneLeft:nil];\n            break;\n        case KEY_ACTION_SELECT_PANE_RIGHT:\n            [windowController selectPaneRight:nil];\n            break;\n        case KEY_ACTION_SELECT_PANE_ABOVE:\n            [windowController selectPaneUp:nil];\n            break;\n        case KEY_ACTION_SELECT_PANE_BELOW:\n            [windowController selectPaneDown:nil];\n            break;\n        case KEY_ACTION_DO_NOT_REMAP_MODIFIERS:\n        case KEY_ACTION_REMAP_LOCALLY:\n            break;\n        case KEY_ACTION_TOGGLE_FULLSCREEN:\n            [windowController toggleFullScreenMode:nil];\n            break;\n        case KEY_ACTION_NEW_WINDOW_WITH_PROFILE:\n            [[_delegate realParentWindow] newWindowWithBookmarkGuid:action.parameter];\n            break;\n        case KEY_ACTION_NEW_TAB_WITH_PROFILE:\n            [[_delegate realParentWindow] newTabWithBookmarkGuid:action.parameter];\n            break;\n        case KEY_ACTION_SPLIT_HORIZONTALLY_WITH_PROFILE: {\n            Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:action.parameter];\n            if (!profile) {\n                break;\n            }\n            [[_delegate realParentWindow] asyncSplitVertically:NO\n                                                        before:NO\n                                                       profile:profile\n                                                 targetSession:[[_delegate realParentWindow] currentSession]\n                                                    completion:nil\n                                                         ready:nil];\n            break;\n        }\n        case KEY_ACTION_SPLIT_VERTICALLY_WITH_PROFILE: {\n            Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:action.parameter];\n            if (!profile) {\n                break;\n            }\n            [[_delegate realParentWindow] asyncSplitVertically:YES\n                                                        before:NO\n                                                       profile:profile\n                                                 targetSession:[[_delegate realParentWindow] currentSession]\n                                                    completion:nil\n                                                         ready:nil];\n            break;\n        }\n        case KEY_ACTION_SET_PROFILE: {\n            Profile *newProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:action.parameter];\n            if (newProfile) {\n                [self setProfile:newProfile preservingName:YES];\n            }\n            break;\n        }\n        case KEY_ACTION_LOAD_COLOR_PRESET: {\n            // Divorce & update self\n            [self setColorsFromPresetNamed:action.parameter];\n\n            // Try to update the backing profile if possible, which may undivorce you. The original\n            // profile may not exist so this could do nothing.\n            ProfileModel *model = [ProfileModel sharedInstance];\n            Profile *profile;\n            if (self.isDivorced) {\n                profile = [[ProfileModel sharedInstance] bookmarkWithGuid:_profile[KEY_ORIGINAL_GUID]];\n            } else {\n                profile = self.profile;\n            }\n            if (profile) {\n                [model addColorPresetNamed:action.parameter toProfile:profile];\n            }\n            break;\n        }\n\n        case KEY_ACTION_FIND_REGEX: {\n            [_view createFindDriverIfNeeded];\n            [_view.findDriver closeViewAndDoTemporarySearchForString:action.parameter\n                                                                mode:iTermFindModeCaseSensitiveRegex\n                                                            progress:nil];\n            break;\n        }\n        case KEY_FIND_AGAIN_DOWN:\n            // The UI exposes this as \"find down\" so it doesn't respect swapFindNextPrevious\n            [self searchNext];\n            break;\n\n        case KEY_FIND_AGAIN_UP:\n            // The UI exposes this as \"find up\" so it doesn't respect swapFindNextPrevious\n            [self searchPrevious];\n            break;\n\n        case KEY_ACTION_PASTE_SPECIAL_FROM_SELECTION: {\n            NSString *string = [[iTermController sharedInstance] lastSelectionPromise].wait.maybeFirst;\n            if (string.length) {\n                [_pasteHelper pasteString:string\n                             stringConfig:action.parameter];\n            }\n            break;\n        }\n\n        case KEY_ACTION_PASTE_SPECIAL: {\n            NSString *string = [NSString stringFromPasteboard];\n            if (string.length) {\n                [_pasteHelper pasteString:string\n                             stringConfig:action.parameter];\n            }\n            break;\n        }\n\n        case KEY_ACTION_TOGGLE_HOTKEY_WINDOW_PINNING: {\n            DLog(@\"Toggle pinning\");\n            BOOL autoHid = [iTermProfilePreferences boolForKey:KEY_HOTKEY_AUTOHIDE inProfile:self.profile];\n            DLog(@\"Getting profile with guid %@ from originalProfile %p\", self.originalProfile[KEY_GUID], self.originalProfile);\n            Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:self.originalProfile[KEY_GUID]];\n            if (profile) {\n                DLog(@\"Found a profile\");\n                [iTermProfilePreferences setBool:!autoHid forKey:KEY_HOTKEY_AUTOHIDE inProfile:profile model:[ProfileModel sharedInstance]];\n            }\n            break;\n        }\n        case KEY_ACTION_UNDO:\n            [PTYSession selectMenuItemWithSelector:@selector(undo:)];\n            break;\n\n        case KEY_ACTION_MOVE_END_OF_SELECTION_LEFT:\n            [_textview moveSelectionEndpoint:kPTYTextViewSelectionEndpointEnd\n                                 inDirection:kPTYTextViewSelectionExtensionDirectionLeft\n                                          by:[action.parameter integerValue]];\n            break;\n        case KEY_ACTION_MOVE_END_OF_SELECTION_RIGHT:\n            [_textview moveSelectionEndpoint:kPTYTextViewSelectionEndpointEnd\n                                 inDirection:kPTYTextViewSelectionExtensionDirectionRight\n                                          by:[action.parameter integerValue]];\n            break;\n        case KEY_ACTION_MOVE_START_OF_SELECTION_LEFT:\n            [_textview moveSelectionEndpoint:kPTYTextViewSelectionEndpointStart\n                                 inDirection:kPTYTextViewSelectionExtensionDirectionLeft\n                                          by:[action.parameter integerValue]];\n            break;\n        case KEY_ACTION_MOVE_START_OF_SELECTION_RIGHT:\n            [_textview moveSelectionEndpoint:kPTYTextViewSelectionEndpointStart\n                                 inDirection:kPTYTextViewSelectionExtensionDirectionRight\n                                          by:[action.parameter integerValue]];\n            break;\n\n        case KEY_ACTION_DECREASE_HEIGHT:\n            [windowController decreaseHeightOfSession:self];\n            break;\n        case KEY_ACTION_INCREASE_HEIGHT:\n            [windowController increaseHeightOfSession:self];\n            break;\n\n        case KEY_ACTION_DECREASE_WIDTH:\n            [windowController decreaseWidthOfSession:self];\n            break;\n        case KEY_ACTION_INCREASE_WIDTH:\n            [windowController increaseWidthOfSession:self];\n            break;\n\n        case KEY_ACTION_SWAP_PANE_LEFT:\n            [windowController swapPaneLeft];\n            break;\n        case KEY_ACTION_SWAP_PANE_RIGHT:\n            [windowController swapPaneRight];\n            break;\n        case KEY_ACTION_SWAP_PANE_ABOVE:\n            [windowController swapPaneUp];\n            break;\n        case KEY_ACTION_SWAP_PANE_BELOW:\n            [windowController swapPaneDown];\n            break;\n        case KEY_ACTION_TOGGLE_MOUSE_REPORTING:\n            [self setXtermMouseReporting:![self xtermMouseReporting]];\n            break;\n        case KEY_ACTION_INVOKE_SCRIPT_FUNCTION:\n            [self invokeFunctionCall:action.parameter\n                               scope:self.variablesScope\n                              origin:@\"Key Binding\"];\n            break;\n        case KEY_ACTION_DUPLICATE_TAB:\n            [self.delegate sessionDuplicateTab];\n            break;\n        case KEY_ACTION_MOVE_TO_SPLIT_PANE:\n            [self textViewMovePane];\n            break;\n\n        case KEY_ACTION_SEQUENCE: {\n            PTYSession *session = self;\n            for (iTermKeyBindingAction *subaction in [action.parameter keyBindingActionsFromSequenceParameter]) {\n                [session performKeyBindingAction:subaction event:event];\n                session = [[[iTermController sharedInstance] currentTerminal] currentSession] ?: self;\n            }\n        case KEY_ACTION_SWAP_WITH_NEXT_PANE:\n            [self.delegate sessionSwapWithSessionInDirection:1];\n            break;\n        case KEY_ACTION_SWAP_WITH_PREVIOUS_PANE:\n            [self.delegate sessionSwapWithSessionInDirection:-1];\n            break;\n        case KEY_ACTION_COPY_OR_SEND:\n            if ([self hasSelection]) {\n                [_textview copy:nil];\n                break;\n            }\n            [self regularKeyDown:[NSApp currentEvent]];\n            break;\n        }\n        case KEY_ACTION_PASTE_OR_SEND:\n            if ([[PTYSession pasteboardString] length]) {\n                [_textview paste:[[NSApp mainMenu] itemWithSelector:@selector(paste:) tag:0]];\n                break;\n            }\n            [self regularKeyDown:[NSApp currentEvent]];\n            break;\n\n        case KEY_ACTION_ALERT_ON_NEXT_MARK:\n            self.alertOnNextMark = YES;\n            break;\n\n        default:\n            XLog(@\"Unknown key action %@\", action);\n            break;\n    }\n}\n\n#pragma mark - Key Handling\n\n- (BOOL)eventNeedsMitigation:(NSEvent *)event {\n    if (event.keyCode != kVK_Escape) {\n        return NO;\n    }\n    // Credit to https://github.com/niw/HapticKey for the magic number.\n    const int64_t keyboardType = CGEventGetIntegerValueField(event.CGEvent, kCGKeyboardEventKeyboardType);\n    static const int64_t touchbarKeyboardType = 198;\n    if (keyboardType != touchbarKeyboardType) {\n        return NO;\n    }\n    if (event.isARepeat) {\n        return NO;\n    }\n\n    return YES;\n}\n\n- (void)actuateHapticFeedbackForEvent:(NSEvent *)event {\n    if (![iTermPreferences boolForKey:kPreferenceKeyEnableHapticFeedbackForEsc]) {\n        return;\n    }\n    if (event.type == NSEventTypeKeyDown) {\n        [[iTermHapticActuator sharedActuator] actuateTouchDownFeedback];\n        return;\n    }\n    if (event.type == NSEventTypeKeyUp && event.keyCode == kVK_Escape) {\n        [[iTermHapticActuator sharedActuator] actuateTouchUpFeedback];\n        return;\n    }\n}\n\n- (void)playSoundForEvent:(NSEvent *)event {\n    if (![iTermPreferences boolForKey:kPreferenceKeyEnableSoundForEsc]) {\n        return;\n    }\n    if (event.type == NSEventTypeKeyDown) {\n        [[iTermSoundPlayer keyClick] play];\n    }\n}\n\n- (void)showVisualIndicatorForEvent:(NSEvent *)event {\n    if (_showingVisualIndicatorForEsc) {\n        return;\n    }\n    if (![iTermPreferences boolForKey:kPreferenceKeyVisualIndicatorForEsc]) {\n        return;\n    }\n    _showingVisualIndicatorForEsc = YES;\n\n    NSNumber *savedCursorTypeOverride = _cursorTypeOverride;\n\n    ITermCursorType temporaryType;\n    if (self.cursorType == CURSOR_BOX) {\n        temporaryType = CURSOR_UNDERLINE;\n    } else {\n        temporaryType = CURSOR_BOX;\n    }\n\n    self.cursorTypeOverride = @(temporaryType);\n    [_textview setCursorNeedsDisplay];\n    _cursorTypeOverrideChanged = NO;\n\n    [self retain];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 / 15.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        if (!self->_cursorTypeOverrideChanged) {\n            self.cursorTypeOverride = savedCursorTypeOverride;\n        }\n        self->_showingVisualIndicatorForEsc = NO;\n        [self release];\n    });\n}\n\n- (void)mitigateTouchBarStupidityForEvent:(NSEvent *)event {\n    if (![self eventNeedsMitigation:event]) {\n        return;\n    }\n    [self actuateHapticFeedbackForEvent:event];\n    [self playSoundForEvent:event];\n    [self showVisualIndicatorForEvent:event];\n}\n\n- (void)textViewSelectionDidChangeToTruncatedString:(NSString *)maybeSelection {\n    // Assign a maximum of maximumBytesToProvideToPythonAPI characters to the \"selection\"\n    // iTerm Variable\n    //\n    // The \"selectionLength\" iTerm variable contains the full length of the original\n    // selection; not the restricted length assigned to the \"selection\" iTerm Variable\n    DLog(@\"textViewSelectionDidChangeToTruncatedString: %@\", maybeSelection);\n\n    NSString *selection = maybeSelection ?: @\"\";\n    const int maxLength = [iTermAdvancedSettingsModel maximumBytesToProvideToPythonAPI];\n    [self.variablesScope setValue:[selection substringToIndex:MIN(maxLength, selection.length)] forVariableNamed:iTermVariableKeySessionSelection];\n    [self.variablesScope setValue:@(selection.length) forVariableNamed:iTermVariableKeySessionSelectionLength];\n}\n\n// Handle bookmark- and global-scope keybindings. If there is no keybinding then\n// pass the keystroke as input.\n- (void)keyDown:(NSEvent *)event {\n    [self mitigateTouchBarStupidityForEvent:event];\n\n    if (event.charactersIgnoringModifiers.length == 0) {\n        return;\n    }\n    if (event.type == NSEventTypeKeyDown) {\n        [self logKeystroke:event];\n        [self resumeOutputIfNeeded];\n\n        if ([self trySpecialKeyHandlersForEvent:event]) {\n            return;\n        }\n    }\n    [self regularKeyDown:event];\n}\n\n- (void)regularKeyDown:(NSEvent *)event {\n    DLog(@\"PTYSession keyDown not short-circuted by special handler\");\n    const NSEventModifierFlags mask = (NSEventModifierFlagCommand | NSEventModifierFlagOption | NSEventModifierFlagShift | NSEventModifierFlagControl);\n\n    if (!_screen.terminalSoftAlternateScreenMode &&\n        (event.modifierFlags & mask) == 0 &&\n        [iTermProfilePreferences boolForKey:KEY_MOVEMENT_KEYS_SCROLL_OUTSIDE_INTERACTIVE_APPS inProfile:self.profile]) {\n        switch (event.keyCode) {\n            case kVK_PageUp:\n                [_textview scrollPageUp:nil];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n                return;\n\n            case kVK_PageDown:\n                [_textview scrollPageDown:nil];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n                return;\n\n            case kVK_Home:\n                [_textview scrollHome];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n                return;\n\n            case kVK_End:\n                [_textview scrollEnd];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n                return;\n\n            case kVK_UpArrow:\n                if (!_exited) {\n                    break;\n                }\n                [_textview scrollLineUp:nil];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n                break;\n\n            case kVK_DownArrow:\n                if (!_exited) {\n                    break;\n                }\n                [_textview scrollLineDown:nil];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n\n            default:\n                break;\n        }\n    }\n\n    if (_exited) {\n        DLog(@\"Terminal already dead\");\n        return;\n    }\n\n    NSData *const dataToSend = [_keyMapper keyMapperDataForPostCocoaEvent:event];\n    DLog(@\"dataToSend=%@\", dataToSend);\n    if (dataToSend) {\n        [self writeLatin1EncodedData:dataToSend broadcastAllowed:YES reporting:NO];\n    }\n}\n\n- (void)keyUp:(NSEvent *)event {\n    if ([self shouldReportOrFilterKeystrokesForAPI]) {\n        [self sendKeystrokeNotificationForEvent:event advanced:YES];\n    }\n    if (_screen.terminalReportKeyUp) {\n        NSData *const dataToSend = [_keyMapper keyMapperDataForKeyUp:event];\n        if (dataToSend) {\n            [self writeLatin1EncodedData:dataToSend broadcastAllowed:YES reporting:NO];\n        }\n    }\n}\n- (void)logKeystroke:(NSEvent *)event {\n    const unichar unicode = event.characters.length > 0 ? [event.characters characterAtIndex:0] : 0;\n    DLog(@\"event:%@ (%llx+%x)[%@][%@]:%x(%c) <%lu>\",\n         event, (unsigned long long)event.it_modifierFlags, event.keyCode, event.characters,\n         event.charactersIgnoringModifiers, unicode, unicode,\n         (event.it_modifierFlags & NSEventModifierFlagNumericPad));\n}\n\n- (BOOL)trySpecialKeyHandlersForEvent:(NSEvent *)event {\n    if ([self maybeHandleZoomedKeyEvent:event]) {\n        return YES;\n    }\n    if ([self maybeHandleInstantReplayKeyEvent:event]) {\n        return YES;\n    }\n    if ([self maybeHandleKeyBindingActionForKeyEvent:event]) {\n        return YES;\n    }\n    if ([self maybeHandleTmuxGatewayKeyEvent:event]) {\n        return YES;\n    }\n    if ([self textViewIsZoomedIn]) {\n        DLog(@\"Swallow keyboard input while zoomed.\");\n        return YES;\n    }\n    return NO;\n}\n\n- (BOOL)maybeHandleTmuxGatewayKeyEvent:(NSEvent *)event {\n    // Key is not bound to an action.\n    if (_exited) {\n        return NO;\n    }\n    if (self.tmuxMode != TMUX_GATEWAY) {\n        return NO;\n    }\n\n    [self handleKeypressInTmuxGateway:event];\n    DLog(@\"Special handler: TMUX GATEWAY\");\n    return YES;\n}\n\n- (BOOL)maybeHandleZoomedKeyEvent:(NSEvent *)event {\n    if (![self textViewIsZoomedIn]) {\n        return NO;\n    }\n\n    const unichar character = event.characters.length > 0 ? [event.characters characterAtIndex:0] : 0;\n    const NSEventModifierFlags mask = (NSEventModifierFlagCommand |\n                                       NSEventModifierFlagControl |\n                                       NSEventModifierFlagOption |\n                                       NSEventModifierFlagShift);\n    if ((event.modifierFlags & mask) != 0) {\n        // Let it go to the key binding handler.\n        return NO;\n    }\n\n    if (character != 27) {\n        // Didn't press esc\n        return NO;\n    }\n\n    // Escape exits zoom (pops out one level, since you can zoom repeatedly)\n    // The zoomOut: IBAction doesn't get performed by shortcut, I guess because Esc is not a\n    // valid shortcut. So we do it here.\n    DLog(@\"Special handler: ZOOM OUT - unmodified esc\");\n    return [self unzoomIfPossible];\n}\n\n- (BOOL)unzoomIfPossible {\n    if (![self textViewIsZoomedIn]) {\n        return NO;\n    }\n\n    if (self.filter.length) {\n        DLog(@\"stopFiltering\");\n        [self stopFiltering];\n    } else {\n        DLog(@\"Unzooming\");\n        [[_delegate realParentWindow] replaceSyntheticActiveSessionWithLiveSessionIfNeeded];\n    }\n    return YES;\n}\n\n- (PTYSessionZoomState *)stateToSaveForZoom {\n    if (self.filter) {\n        return nil;\n    }\n    const long long lineNumber = [_textview firstVisibleAbsoluteLineNumber];\n    NSString *query = nil;\n    if (_view.findDriver.findString.length) {\n        query = _view.findDriver.findString;\n    }\n    return [[[PTYSessionZoomState alloc] initWithFirstVisibleAbsoluteLineNumber:lineNumber\n                                                                    searchQuery:query] autorelease];\n}\n\n- (void)restoreStateForZoom:(PTYSessionZoomState *)state {\n    if (!state) {\n        return;\n    }\n    [_textview scrollToAbsoluteOffset:state.firstVisibleAbsoluteLineNumber\n                               height:_screen.height];\n    if (state.searchQuery.length) {\n        [_view.findDriver setFindStringUnconditionally:state.searchQuery];\n    }\n}\n\n- (BOOL)maybeHandleInstantReplayKeyEvent:(NSEvent *)event {\n    if (![[_delegate realParentWindow] inInstantReplay]) {\n        return NO;\n    }\n\n    [self handleKeypressInInstantReplay:event];\n    DLog(@\"Special handler: INSTANT REPLAY\");\n    return YES;\n}\n\n- (BOOL)maybeHandleKeyBindingActionForKeyEvent:(NSEvent *)event {\n    // Check if we have a custom key mapping for this event\n    iTermKeystroke *keystroke = [iTermKeystroke withEvent:event];\n    iTermKeyBindingAction *action = [iTermKeyMappings actionForKeystroke:keystroke\n                                                             keyMappings:self.profile[KEY_KEYBOARD_MAP]];\n\n    if (!action) {\n        return NO;\n    }\n    DLog(@\"PTYSession keyDown action=%@\", action);\n    // A special action was bound to this key combination.\n    [self performKeyBindingAction:action event:event];\n\n    DLog(@\"Special handler: KEY BINDING ACTION\");\n    return YES;\n}\n\n- (void)handleKeypressInInstantReplay:(NSEvent *)event {\n    DLog(@\"PTYSession keyDown in IR\");\n\n    // Special key handling in IR mode, and keys never get sent to the live\n    // session, even though it might be displayed.\n    const unichar character = event.characters.length > 0 ? [event.characters characterAtIndex:0] : 0;\n    const unichar characterIgnoringModifiers = [event.charactersIgnoringModifiers length] > 0 ? [event.charactersIgnoringModifiers characterAtIndex:0] : 0;\n    const NSEventModifierFlags modifiers = event.it_modifierFlags;\n\n    if (character == 27) {\n        // Escape exits IR\n        [[_delegate realParentWindow] closeInstantReplay:self orTerminateSession:YES];\n        return;\n    } else if (characterIgnoringModifiers == NSLeftArrowFunctionKey) {\n        // Left arrow moves to prev frame\n        int n = 1;\n        if (modifiers & NSEventModifierFlagShift) {\n            n = 15;\n        }\n        for (int i = 0; i < n; i++) {\n            [[_delegate realParentWindow] irPrev:self];\n        }\n    } else if (characterIgnoringModifiers == NSRightArrowFunctionKey) {\n        // Right arrow moves to next frame\n        int n = 1;\n        if (modifiers & NSEventModifierFlagShift) {\n            n = 15;\n        }\n        for (int i = 0; i < n; i++) {\n            [[_delegate realParentWindow] irNext:self];\n        }\n    } else {\n        DLog(@\"Beep: Unrecongized keystroke in IR\");\n        NSBeep();\n    }\n}\n\n\n- (NSData *)backspaceData {\n    iTermKeyBindingAction *action = [iTermKeyMappings actionForKeystroke:[iTermKeystroke backspace]\n                                                             keyMappings:[[self profile] objectForKey:KEY_KEYBOARD_MAP]];\n    if (!action) {\n        const char del = 0x7f;\n        return [NSData dataWithBytes:&del length:1];\n    }\n    switch (action.keyAction) {\n        case KEY_ACTION_HEX_CODE:\n            return [self dataForHexCodes:action.parameter];\n\n        case KEY_ACTION_TEXT:\n            return [action.parameter dataUsingEncoding:self.encoding];\n\n        case KEY_ACTION_VIM_TEXT:\n            return [[action.parameter stringByExpandingVimSpecialCharacters] dataUsingEncoding:self.encoding];\n\n        case KEY_ACTION_ESCAPE_SEQUENCE:\n            return [[@\"\\e\" stringByAppendingString:action.parameter] dataUsingEncoding:self.encoding];\n\n        case KEY_ACTION_SEND_C_H_BACKSPACE:\n            return [@\"\\010\" dataUsingEncoding:self.encoding];\n\n        case KEY_ACTION_SEND_C_QM_BACKSPACE:\n            return [@\"\\177\" dataUsingEncoding:self.encoding];\n\n        default:\n            break;\n    }\n\n    return nil;\n}\n\n- (BOOL)hasActionableKeyMappingForEvent:(NSEvent *)event {\n    if (_textview.selection.hasSelection && !_textview.selection.live) {\n        if ([_modeHandler shouldAutoEnterWithEvent:event]) {\n            return NO;\n        }\n    }\n    return [[self _keyBindingActionForEvent:event] isActionable];\n}\n\n- (BOOL)shouldRespectTerminalMetaSendsEscape {\n    if (![iTermAdvancedSettingsModel supportDecsetMetaSendsEscape]) {\n        return NO;\n    }\n    if ([[[self profile] objectForKey:KEY_OPTION_KEY_SENDS] intValue] == OPT_ESC) {\n        return NO;\n    }\n    if ([[[self profile] objectForKey:KEY_RIGHT_OPTION_KEY_SENDS] intValue] == OPT_ESC) {\n        return NO;\n    }\n    return YES;\n}\n\n- (iTermOptionKeyBehavior)optionKey {\n    if ([self shouldRespectTerminalMetaSendsEscape] &&\n        _screen.terminalMetaSendsEscape &&\n        [iTermProfilePreferences boolForKey:KEY_LEFT_OPTION_KEY_CHANGEABLE inProfile:self.profile]) {\n        return OPT_ESC;\n    }\n    return [[[self profile] objectForKey:KEY_OPTION_KEY_SENDS] intValue];\n}\n\n- (iTermOptionKeyBehavior)rightOptionKey {\n    if ([self shouldRespectTerminalMetaSendsEscape] &&\n        _screen.terminalMetaSendsEscape &&\n        [iTermProfilePreferences boolForKey:KEY_RIGHT_OPTION_KEY_CHANGEABLE inProfile:self.profile]) {\n        return OPT_ESC;\n    }\n    NSNumber *rightOptPref = [[self profile] objectForKey:KEY_RIGHT_OPTION_KEY_SENDS];\n    if (rightOptPref == nil) {\n        return [self optionKey];\n    }\n    return [rightOptPref intValue];\n}\n\n- (BOOL)applicationKeypadAllowed\n{\n    return [[[self profile] objectForKey:KEY_APPLICATION_KEYPAD_ALLOWED] boolValue];\n}\n\n// Contextual menu\n- (void)menuForEvent:(NSEvent *)theEvent menu:(NSMenu *)theMenu\n{\n    // Ask the parent if it has anything to add\n    if ([_delegate realParentWindow] &&\n        [[_delegate realParentWindow] respondsToSelector:@selector(menuForEvent:menu:)]) {\n        [[_delegate realParentWindow] menuForEvent:theEvent menu:theMenu];\n    }\n}\n\n// All pastes except \"Advanced\" go through this method.\n- (void)pasteString:(NSString *)theString flags:(PTYSessionPasteFlags)flags {\n    if (!theString.length) {\n        return;\n    }\n    DLog(@\"pasteString:flags: length=%@ flags=%@\", @([theString length]), @(flags));\n    iTermTabTransformTags tabTransform = kTabTransformNone;\n    int spacesPerTab = -1;\n    if (flags & kPTYSessionPasteWithShellEscapedTabs) {\n        tabTransform = kTabTransformEscapeWithCtrlV;\n    } else if (!_screen.terminalBracketedPasteMode) {\n        spacesPerTab = [_pasteHelper numberOfSpacesToConvertTabsTo:theString];\n        if (spacesPerTab >= 0) {\n            tabTransform = kTabTransformConvertToSpaces;\n        } else if (spacesPerTab == kNumberOfSpacesPerTabOpenAdvancedPaste) {\n            [_pasteHelper showAdvancedPasteWithFlags:flags];\n            return;\n        } else if (spacesPerTab == kNumberOfSpacesPerTabCancel) {\n            return;\n        }\n    }\n\n    DLog(@\"Calling pasteString:flags: on helper...\");\n    [_pasteHelper pasteString:theString\n                       slowly:!!(flags & kPTYSessionPasteSlowly)\n             escapeShellChars:!!(flags & kPTYSessionPasteEscapingSpecialCharacters)\n                     isUpload:NO\n              allowBracketing:!(flags & kPTYSessionPasteBracketingDisabled)\n                 tabTransform:tabTransform\n                 spacesPerTab:spacesPerTab];\n}\n\n// Pastes the current string in the clipboard. Uses the sender's tag to get flags.\n- (void)paste:(id)sender {\n    DLog(@\"PTYSession paste:\");\n\n    if ([self haveAutoComposer]) {\n        _textViewShouldTakeFirstResponder = NO;\n        [self makeComposerFirstResponderIfAllowed];\n        [_composerManager paste:sender];\n        return;\n    }\n    // If this class is used in a non-iTerm2 app (as a library), we might not\n    // be called from a menu item so just use no flags in this case.\n    [self pasteString:[PTYSession pasteboardString] flags:[sender isKindOfClass:NSMenuItem.class] ? [sender tag] : 0];\n}\n\n// Show advanced paste window.\n- (IBAction)pasteOptions:(id)sender {\n    [_pasteHelper showPasteOptionsInWindow:_delegate.realParentWindow.window\n                         bracketingEnabled:_screen.terminalBracketedPasteMode];\n}\n\n- (void)textViewFontDidChange\n{\n    if ([self isTmuxClient]) {\n        [self notifyTmuxFontChange];\n    }\n    [_view updateScrollViewFrame];\n    [self updateMetalDriver];\n    [_view.driver expireNonASCIIGlyphs];\n}\n\n- (BOOL)textViewHasBackgroundImage {\n    return self.effectiveBackgroundImage != nil;\n}\n\n// Lots of different views need to draw the background image.\n// - Obviously, PTYTextView uses it for the area where text appears.\n// - SessionView will draw it for an area below the scroll view when the cell size doesn't evenly\n// divide its size.\n// - TextViewWrapper will draw it for a few pixels above the scrollview in the VMARGIN.\n// This combines drawing into these different views in a consistent way.\n// It also draws the dotted border when there is a maximized pane.\n//\n// view: the view whose -drawRect is currently running and is being drawn into.\n// rect: the rectangle in the coordinate system of |view|.\n// blendDefaultBackground: If set, the default background color will be blended over the background\n// image. If there is no image and this flag is set then the background color is drawn instead. This\n// way SessionView and TextViewWrapper don't have to worry about whether a background image is\n// present.\n//\n// The only reason this still exists is because when subpixel antialiasing is enabled we can't\n// draw text on a clear background over a background image. The background image needs to be drawn\n// to the same view and then the text can be properly composited over it.\n- (BOOL)textViewDrawBackgroundImageInView:(NSView *)view\n                                 viewRect:(NSRect)dirtyRect\n                   blendDefaultBackground:(BOOL)blendDefaultBackground\n                            virtualOffset:(CGFloat)virtualOffset NS_DEPRECATED_MAC(10_0, 10_16) {\n    if (!self.shouldDrawBackgroundImageManually) {\n        return NO;\n    }\n    if (!_backgroundDrawingHelper) {\n        _backgroundDrawingHelper = [[iTermBackgroundDrawingHelper alloc] init];\n        _backgroundDrawingHelper.delegate = self;\n    }\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        NSRect contentRect = self.view.contentRect;\n        if (contentRect.size.width == 0 ||\n            contentRect.size.height == 0) {\n            return NO;\n        }\n        [_backgroundDrawingHelper drawBackgroundImageInView:view\n                                                  container:self.view\n                                                  dirtyRect:dirtyRect\n                                     visibleRectInContainer:NSMakeRect(0, 0, contentRect.size.width, contentRect.size.height)\n                                     blendDefaultBackground:blendDefaultBackground\n                                                       flip:NO\n                                              virtualOffset:virtualOffset];\n    } else {\n        NSView *container = [self.delegate sessionContainerView:self];\n        NSRect clippedDirtyRect = NSIntersectionRect(dirtyRect, view.enclosingScrollView.documentVisibleRect);;\n        NSRect windowVisibleRect = [self.view insetRect:container.bounds\n                                                flipped:YES\n                                 includeBottomStatusBar:![iTermPreferences boolForKey:kPreferenceKeySeparateStatusBarsPerPane]];\n        [_backgroundDrawingHelper drawBackgroundImageInView:view\n                                                  container:container\n                                                  dirtyRect:clippedDirtyRect\n                                     visibleRectInContainer:windowVisibleRect\n                                     blendDefaultBackground:blendDefaultBackground\n                                                       flip:YES\n                                              virtualOffset:virtualOffset];\n    }\n    return YES;\n}\n\n- (CGRect)textViewRelativeFrame {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return CGRectMake(0, 0, 1, 1);\n    }\n    NSRect viewRect;\n    NSRect containerBounds;\n    NSView *container = self.view.window.contentView;\n    viewRect = [self.view.metalView.superview convertRect:self.view.metalView.frame\n                                                   toView:container];\n    containerBounds = container.bounds;\n    // Flip it\n    viewRect.origin.y = containerBounds.size.height - viewRect.origin.y - viewRect.size.height;\n    return CGRectMake(viewRect.origin.x / containerBounds.size.width,\n                      viewRect.origin.y / containerBounds.size.height,\n                      viewRect.size.width / containerBounds.size.width,\n                      viewRect.size.height / containerBounds.size.height);\n}\n\n- (CGRect)textViewContainerRect {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return self.view.frame;\n    }\n    NSView *container = [self.delegate sessionContainerView:self];\n    return [self.view insetRect:container.bounds\n                        flipped:YES\n         includeBottomStatusBar:![iTermPreferences boolForKey:kPreferenceKeySeparateStatusBarsPerPane]];\n}\n\n// This includes the portion of the metal view that is obscured by the status bar or per-pane title bar.\n- (NSEdgeInsets)textViewExtraMargins {\n    NSEdgeInsets margins = self.view.extraMargins;\n    // This is here because of tmux panes. They cause some extra bottom\n    // margins, and the regular -extraMargins code only includes stuff like\n    // the status bar on the bottom. The top margin it produces is still\n    // useful, so we keep that.\n    margins.bottom = _view.scrollview.frame.origin.y;\n    return margins;\n}\n\n- (iTermImageWrapper *)textViewBackgroundImage {\n    return _backgroundImage;\n}\n\n- (NSColor *)processedBackgroundColor {\n    NSColor *unprocessedColor = [_screen.colorMap colorForKey:kColorMapBackground];\n    return [_screen.colorMap processedBackgroundColorForBackgroundColor:unprocessedColor];\n}\n\n- (void)textViewPostTabContentsChangedNotification\n{\n    [[NSNotificationCenter defaultCenter] postNotificationName:@\"iTermTabContentsChanged\"\n                                                        object:self\n                                                      userInfo:nil];\n}\n\n- (void)textViewInvalidateRestorableState {\n    if ([iTermAdvancedSettingsModel restoreWindowContents]) {\n        [_delegate.realParentWindow invalidateRestorableState];\n    }\n}\n\n- (void)textViewDidFindDirtyRects {\n    if (_updateSubscriptions.count) {\n        ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n        notification.screenUpdateNotification = [[[ITMScreenUpdateNotification alloc] init] autorelease];\n        notification.screenUpdateNotification.session = self.guid;\n        [_updateSubscriptions enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n            [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                                 toConnectionKey:key];\n        }];\n    }\n\n    // Remove the tail-find timer so that a new tail find can begin. This is necessary so that\n    // shouldSEndContentsChangedNotification will return YES.\n    [_tailFindTimer invalidate];\n    _tailFindTimer = nil;\n}\n\n- (void)textViewBeginDrag\n{\n    [[MovePaneController sharedInstance] beginDrag:self];\n}\n\n- (void)textViewMovePane {\n    [[MovePaneController sharedInstance] movePane:self];\n}\n\n- (void)textViewSwapPane {\n    [[MovePaneController sharedInstance] swapPane:self];\n}\n\n- (NSStringEncoding)textViewEncoding {\n    return [self encoding];\n}\n\n// This uses the local directory because it is the last desperate gasp of URL action file finding.\n- (void)textViewGetCurrentWorkingDirectoryWithCompletion:(void (^)(NSString *workingDirectory))completion {\n    [self asyncCurrentLocalWorkingDirectory:completion];\n}\n\n// NOTE: This will not fetch the current directory if it's not already known to avoid blocking\n// the main thread. Don't use this unless you have to be synchronous.\n// Use asyncGetCurrentLocatioNWithCompletion instead.\n- (NSURL *)textViewCurrentLocation {\n    id<VT100RemoteHostReading>host = [self currentHost];\n    NSString *path = _lastDirectory;\n    NSURLComponents *components = [[[NSURLComponents alloc] init] autorelease];\n    components.host = host.hostname;\n    components.user = host.username;\n    components.path = path;\n    components.scheme = @\"file\";\n    return [components URL];\n}\n\n- (void)asyncGetCurrentLocationWithCompletion:(void (^)(NSURL *url))completion {\n    // NOTE: Use local directory here because this becomes the proxy icon, and it's basically\n    // useless when given a remote directory.\n    __weak __typeof(self) weakSelf = self;\n    [self asyncCurrentLocalWorkingDirectory:^(NSString *pwd) {\n        DLog(@\"Finished with %@ for %@\", pwd, weakSelf);\n        completion([weakSelf urlForHost:weakSelf.currentHost path:pwd]);\n    }];\n}\n\n- (void)updateLocalDirectoryWithCompletion:(void (^)(NSString *pwd))completion {\n    DLog(@\"Update local directory of %@\", self);\n    __weak __typeof(self) weakSelf = self;\n    [_shell getWorkingDirectoryWithCompletion:^(NSString *pwd) {\n        [[[weakSelf retain] autorelease] didGetWorkingDirectory:pwd completion:completion];\n    }];\n}\n\n- (void)didGetWorkingDirectory:(NSString *)pwd completion:(void (^)(NSString *pwd))completion {\n    // Don't call setLastDirectory:remote:pushed: because we don't want to update the\n    // path variable if the session is ssh'ed somewhere.\n    DLog(@\"getWorkingDirectoryWithCompletion for %@ finished with %@\", self, pwd);\n    if (self.lastLocalDirectoryWasPushed && self.lastLocalDirectory != nil) {\n        DLog(@\"Looks like there was a race because there is now a last local directory of %@. Use it.\",\n             self.lastLocalDirectory);\n        completion(self.lastLocalDirectory);\n        return;\n    }\n    self.lastLocalDirectory = pwd;\n    self.lastLocalDirectoryWasPushed = NO;\n    completion(pwd);\n}\n\n- (NSURL *)urlForHost:(id<VT100RemoteHostReading>)host path:(NSString *)path {\n    NSURLComponents *components = [[[NSURLComponents alloc] init] autorelease];\n    components.host = host.hostname;\n    components.user = host.username;\n    components.path = path;\n    components.scheme = @\"file\";\n    return [components URL];\n}\n\n- (BOOL)textViewShouldPlaceCursorAt:(VT100GridCoord)coord verticalOk:(BOOL *)verticalOk {\n    if (coord.y < _screen.numberOfLines - _screen.height ||\n        coord.x < 0 ||\n        coord.x >= _screen.width ||\n        coord.y >= _screen.numberOfLines) {\n        // Click must be in the live area and not in a margin.\n        return NO;\n    }\n    if (_screen.commandRange.start.x < 0) {\n        if (_screen.terminalSoftAlternateScreenMode) {\n            // In an interactive app. No restrictions.\n            *verticalOk = YES;\n            return YES;\n        } else {\n            // Possibly at a command prompt without shell integration or in some other command line\n            // app that may be using readline. No vertical movement.\n            *verticalOk = NO;\n            return YES;\n        }\n    } else {\n        // At the command prompt. Ok to move to any char within current command, but no up or down\n        // arrows please.\n        NSComparisonResult order = VT100GridCoordOrder(VT100GridCoordRangeMin(_screen.commandRange),\n                                                       coord);\n        *verticalOk = NO;\n        return (order != NSOrderedDescending);\n    }\n}\n\n- (BOOL)textViewShouldDrawFilledInCursor {\n    // If the auto-command history popup is open for this session, the filled-in cursor should be\n    // drawn even though the textview isn't in the key window.\n    return [self textViewIsActiveSession] && [[_delegate realParentWindow] autoCommandHistoryIsOpenForSession:self];\n}\n\n- (void)textViewWillNeedUpdateForBlink {\n    self.active = YES;\n}\n\n- (void)textViewSplitVertically:(BOOL)vertically withProfileGuid:(NSString *)guid\n{\n    Profile *profile;\n    if (guid) {\n        profile = [[ProfileModel sharedInstance] bookmarkWithGuid:guid];\n    } else {\n        profile = [self profileForSplit];\n    }\n    [[_delegate realParentWindow] asyncSplitVertically:vertically\n                                                before:NO\n                                               profile:profile\n                                         targetSession:self\n                                            completion:nil\n                                                 ready:nil];\n}\n\n- (void)textViewSelectNextTab\n{\n    [[_delegate realParentWindow] nextTab:nil];\n}\n\n- (void)textViewSelectPreviousTab\n{\n    [[_delegate realParentWindow] previousTab:nil];\n}\n\n- (void)textViewSelectNextWindow {\n    [[iTermController sharedInstance] nextTerminal];\n}\n\n- (void)textViewSelectPreviousWindow {\n    [[iTermController sharedInstance] previousTerminal];\n}\n\n- (void)textViewSelectNextPane\n{\n    [_delegate nextSession];\n}\n\n- (void)textViewSelectPreviousPane\n{\n    [_delegate previousSession];\n}\n\n- (void)textViewSelectMenuItemWithIdentifier:(NSString *)identifier title:(NSString *)title {\n    [PTYSession _recursiveSelectMenuItemWithTitle:title identifier:identifier inMenu:[NSApp mainMenu]];\n}\n\n- (void)textViewPasteSpecialWithStringConfiguration:(NSString *)configuration\n                                      fromSelection:(BOOL)fromSelection {\n    NSString *string = fromSelection ? [[iTermController sharedInstance] lastSelectionPromise].wait.maybeFirst : [NSString stringFromPasteboard];\n    [_pasteHelper pasteString:string\n                 stringConfig:configuration];\n}\n\n- (void)textViewInvokeScriptFunction:(NSString *)function {\n    [self invokeFunctionCall:function scope:self.variablesScope origin:@\"Pointer action\"];\n}\n\n- (void)textViewEditSession {\n    [[_delegate realParentWindow] editSession:self makeKey:YES];\n}\n\n- (void)textViewToggleBroadcastingInput\n{\n    [[_delegate realParentWindow] toggleBroadcastingInputToSession:self];\n}\n\n- (void)textViewCloseWithConfirmation {\n    [[_delegate realParentWindow] closeSessionWithConfirmation:self];\n}\n\n- (void)textViewRestartWithConfirmation {\n    [[_delegate realParentWindow] restartSessionWithConfirmation:self];\n}\n\n- (void)textViewPasteFromSessionWithMostRecentSelection:(PTYSessionPasteFlags)flags {\n    NSString *string = [[iTermController sharedInstance] lastSelectionPromise].wait.maybeFirst;\n    if (string) {\n        [self pasteString:string flags:flags];\n    }\n}\n\n- (BOOL)textViewWindowUsesTransparency {\n    return [[_delegate realParentWindow] useTransparency];\n}\n\n- (BOOL)textViewAmbiguousWidthCharsAreDoubleWidth\n{\n    return [self treatAmbiguousWidthAsDoubleWidth];\n}\n\n- (void)textViewCreateWindowWithProfileGuid:(NSString *)guid\n{\n    [[_delegate realParentWindow] newWindowWithBookmarkGuid:guid];\n}\n\n- (void)textViewCreateTabWithProfileGuid:(NSString *)guid\n{\n    [[_delegate realParentWindow] newTabWithBookmarkGuid:guid];\n}\n\n// Called when a key is pressed.\n- (BOOL)textViewDelegateHandlesAllKeystrokes\n{\n    [self resumeOutputIfNeeded];\n    return [[_delegate realParentWindow] inInstantReplay];\n}\n\n- (BOOL)textViewIsActiveSession {\n    return [_delegate sessionIsActiveInTab:self];\n}\n\n- (BOOL)textViewSessionIsBroadcastingInput\n{\n    return [[_delegate realParentWindow] broadcastInputToSession:self];\n}\n\n- (BOOL)textViewIsMaximized {\n    return [_delegate hasMaximizedPane];\n}\n\n- (BOOL)textViewTabHasMaximizedPanel\n{\n    return [_delegate hasMaximizedPane];\n}\n\n- (void)textViewDidBecomeFirstResponder {\n    [_delegate setActiveSession:self];\n    [_view setNeedsDisplay:YES];\n    [_view.findDriver owningViewDidBecomeFirstResponder];\n    [self makeComposerFirstResponderIfAllowed];\n}\n\n- (void)makeComposerFirstResponderIfAllowed {\n    if (!self.copyMode && self.haveAutoComposer && !_textViewShouldTakeFirstResponder) {\n        [_composerManager makeDropDownComposerFirstResponder];\n    }\n}\n\n- (void)textViewDidResignFirstResponder {\n    [_view setNeedsDisplay:YES];\n    self.copyMode = false;\n}\n\n- (void)setReportingMouseDownForEventType:(NSEventType)eventType {\n    switch (eventType) {\n        case NSEventTypeLeftMouseDown:\n            _reportingLeftMouseDown = YES;\n            return;\n        case NSEventTypeRightMouseDown:\n            _reportingRightMouseDown = YES;\n            return;\n        case NSEventTypeOtherMouseDown:\n            _reportingMiddleMouseDown = YES;\n            return;\n\n        case NSEventTypeLeftMouseUp:\n            _reportingLeftMouseDown = NO;\n            return;\n        case NSEventTypeRightMouseUp:\n            _reportingRightMouseDown = NO;\n            return;\n        case NSEventTypeOtherMouseUp:\n            _reportingMiddleMouseDown = NO;\n            return;\n\n        default:\n            assert(NO);\n    }\n}\n\n- (BOOL)reportingMouseDownForEventType:(NSEventType)eventType {\n    switch (eventType) {\n        case NSEventTypeLeftMouseDown:\n        case NSEventTypeLeftMouseUp:\n        case NSEventTypeLeftMouseDragged:\n            DLog(@\"_reportingLeftMouseDown=%@\", @(_reportingLeftMouseDown));\n            return _reportingLeftMouseDown;\n\n        case NSEventTypeRightMouseDown:\n        case NSEventTypeRightMouseUp:\n        case NSEventTypeRightMouseDragged:\n            DLog(@\"_reportingRightMouseDown=%@\", @(_reportingRightMouseDown));\n            return _reportingRightMouseDown;\n\n        case NSEventTypeOtherMouseDown:\n        case NSEventTypeOtherMouseUp:\n        case NSEventTypeOtherMouseDragged:\n            DLog(@\"_reportingMiddleMouseDown=%@\", @(_reportingMiddleMouseDown));\n            return _reportingMiddleMouseDown;\n\n        default:\n            assert(NO);\n    }\n}\n\n- (BOOL)textViewAnyMouseReportingModeIsEnabled {\n    return _screen.terminalMouseMode != MOUSE_REPORTING_NONE;\n}\n\n- (BOOL)textViewSmartSelectionActionsShouldUseInterpolatedStrings {\n    return [iTermProfilePreferences boolForKey:KEY_SMART_SELECTION_ACTIONS_USE_INTERPOLATED_STRINGS\n                                     inProfile:self.profile];\n}\n\n- (BOOL)textViewReportMouseEvent:(NSEventType)eventType\n                       modifiers:(NSUInteger)modifiers\n                          button:(MouseButtonNumber)button\n                      coordinate:(VT100GridCoord)coord\n                           point:(NSPoint)point\n                           delta:(CGSize)delta\n        allowDragBeforeMouseDown:(BOOL)allowDragBeforeMouseDown\n                        testOnly:(BOOL)testOnly {\n    DLog(@\"Report event type %lu, modifiers=%lu, button=%d, coord=%@ testOnly=%@ terminalMouseMode=%@ allowDragBeforeMouseDown%@\",\n         (unsigned long)eventType, (unsigned long)modifiers, button,\n         VT100GridCoordDescription(coord), @(testOnly), @(_screen.terminalMouseMode),\n         @(allowDragBeforeMouseDown));\n    // Ignore unknown buttons.\n    if (button == MOUSE_BUTTON_UNKNOWN) {\n        return NO;\n    }\n\n    switch (eventType) {\n        case NSEventTypeLeftMouseDown:\n        case NSEventTypeRightMouseDown:\n        case NSEventTypeOtherMouseDown:\n            switch (_screen.terminalMouseMode) {\n                case MOUSE_REPORTING_NORMAL:\n                case MOUSE_REPORTING_BUTTON_MOTION:\n                case MOUSE_REPORTING_ALL_MOTION:\n                    DLog(@\"normal/button/all - can report\");\n                    if (!testOnly) {\n                        [self setReportingMouseDownForEventType:eventType];\n                        _lastReportedCoord = coord;\n                        _lastReportedPoint = point;\n                        DLog(@\"_lastReportedCoord <- %@, _lastReportedPoint <- %@\",\n                             VT100GridCoordDescription(_lastReportedCoord),\n                             NSStringFromPoint(point));\n                        [self writeLatin1EncodedData:[_screen.terminalOutput mousePress:button\n                                                                          withModifiers:modifiers\n                                                                                     at:coord\n                                                                                  point:point]\n                                    broadcastAllowed:NO\n                                           reporting:NO];\n                    }\n                    return YES;\n\n                case MOUSE_REPORTING_NONE:\n                case MOUSE_REPORTING_HIGHLIGHT:\n                    DLog(@\"non/highlight - can't report\");\n                    break;\n            }\n            break;\n\n        case NSEventTypeLeftMouseUp:\n        case NSEventTypeRightMouseUp:\n        case NSEventTypeOtherMouseUp:\n            if (testOnly) {\n                switch (_screen.terminalMouseMode) {\n                    case MOUSE_REPORTING_NORMAL:\n                    case MOUSE_REPORTING_BUTTON_MOTION:\n                    case MOUSE_REPORTING_ALL_MOTION:\n                        DLog(@\"normal/button/all - can report\");\n                        return YES;\n\n                    case MOUSE_REPORTING_NONE:\n                    case MOUSE_REPORTING_HIGHLIGHT:\n                        DLog(@\"none/highlight - can't report\");\n                        break;\n                }\n                return NO;\n            }\n            if ([self reportingMouseDownForEventType:eventType]) {\n                [self setReportingMouseDownForEventType:eventType];\n                _lastReportedCoord = VT100GridCoordMake(-1, -1);\n                _lastReportedPoint = NSMakePoint(-1, -1);\n                DLog(@\"_lastReportedCoord <- %@, _lastReportedPoint <- %@\",\n                     VT100GridCoordDescription(_lastReportedCoord),\n                     NSStringFromPoint(point));\n\n                switch (_screen.terminalMouseMode) {\n                    case MOUSE_REPORTING_NORMAL:\n                    case MOUSE_REPORTING_BUTTON_MOTION:\n                    case MOUSE_REPORTING_ALL_MOTION:\n                        DLog(@\"normal/button/all - can report\");\n                        _lastReportedCoord = coord;\n                        _lastReportedPoint = point;\n                        DLog(@\"_lastReportedCoord <- %@, _lastReportedPoint <- %@\",\n                             VT100GridCoordDescription(_lastReportedCoord),\n                             NSStringFromPoint(point));\n                        [self writeLatin1EncodedData:[_screen.terminalOutput mouseRelease:button\n                                                                            withModifiers:modifiers\n                                                                                       at:coord\n                                                                                    point:point]\n                                    broadcastAllowed:NO\n                                           reporting:NO];\n                        return YES;\n\n                    case MOUSE_REPORTING_NONE:\n                    case MOUSE_REPORTING_HIGHLIGHT:\n                        DLog(@\"none/highlight - can't report\");\n                        break;\n                }\n            }\n            break;\n\n\n        case NSEventTypeMouseMoved:\n            if (_screen.terminalMouseMode != MOUSE_REPORTING_ALL_MOTION) {\n                DLog(@\"not reporting all motion\");\n                return NO;\n            }\n            DLog(@\"can report\");\n            if (testOnly) {\n                return YES;\n            }\n            if ([_screen.terminalOutput shouldReportMouseMotionAtCoord:coord\n                                                             lastCoord:_lastReportedCoord\n                                                                 point:point\n                                                             lastPoint:_lastReportedPoint]) {\n                _lastReportedCoord = coord;\n                _lastReportedPoint = point;\n                DLog(@\"_lastReportedCoord <- %@, _lastReportedPoint <- %@\",\n                     VT100GridCoordDescription(_lastReportedCoord),\n                     NSStringFromPoint(point));\n                [self writeLatin1EncodedData:[_screen.terminalOutput mouseMotion:MOUSE_BUTTON_NONE\n                                                                   withModifiers:modifiers\n                                                                              at:coord\n                                                                           point:point]\n                            broadcastAllowed:NO\n                                   reporting:NO];\n                return YES;\n            }\n            break;\n\n        case NSEventTypeLeftMouseDragged:\n        case NSEventTypeRightMouseDragged:\n        case NSEventTypeOtherMouseDragged:\n            if (testOnly) {\n                switch (_screen.terminalMouseMode) {\n                    case MOUSE_REPORTING_BUTTON_MOTION:\n                    case MOUSE_REPORTING_ALL_MOTION:\n                    case MOUSE_REPORTING_NORMAL:\n                        DLog(@\"button/all/normal - can report\");\n                        return YES;\n\n                    case MOUSE_REPORTING_NONE:\n                    case MOUSE_REPORTING_HIGHLIGHT:\n                        DLog(@\"none/highlight - can't report\");\n                        break;\n                }\n                return NO;\n            }\n            if (([self reportingMouseDownForEventType:eventType] || allowDragBeforeMouseDown) &&\n                [_screen.terminalOutput shouldReportMouseMotionAtCoord:coord\n                                                             lastCoord:_lastReportedCoord\n                                                                 point:point\n                                                             lastPoint:_lastReportedPoint]) {\n                _lastReportedCoord = coord;\n                _lastReportedPoint = point;\n                DLog(@\"_lastReportedCoord <- %@, _lastReportedPoint <- %@\",\n                     VT100GridCoordDescription(_lastReportedCoord),\n                     NSStringFromPoint(point));\n                switch (_screen.terminalMouseMode) {\n                    case MOUSE_REPORTING_BUTTON_MOTION:\n                    case MOUSE_REPORTING_ALL_MOTION:\n                        DLog(@\"motion/all-motion - will report drag\");\n                        [self writeLatin1EncodedData:[_screen.terminalOutput mouseMotion:button\n                                                                           withModifiers:modifiers\n                                                                                      at:coord\n                                                                                   point:point]\n                                    broadcastAllowed:NO\n                                           reporting:NO];\n                        // Fall through\n                    case MOUSE_REPORTING_NORMAL:\n                        DLog(@\"normal - do not report drag\");\n                        // Don't do selection when mouse reporting during a drag, even if the drag\n                        // is not reported (the clicks are).\n                        return YES;\n\n                    case MOUSE_REPORTING_NONE:\n                    case MOUSE_REPORTING_HIGHLIGHT:\n                        DLog(@\"none/highlight - do not report drag\");\n                        break;\n                }\n            }\n            break;\n\n        case NSEventTypeScrollWheel:\n            switch (_screen.terminalMouseMode) {\n                case MOUSE_REPORTING_NORMAL:\n                case MOUSE_REPORTING_BUTTON_MOTION:\n                case MOUSE_REPORTING_ALL_MOTION:\n                    DLog(@\"normal/button/all - can report. delta=%@\", NSStringFromSize(delta));\n                    if (testOnly) {\n                        return delta.height != 0;\n                    }\n                    const CGFloat chosenDelta = (fabs(delta.width) > fabs(delta.height)) ? delta.width : delta.height;\n                    int steps;\n                    if ([iTermAdvancedSettingsModel proportionalScrollWheelReporting]) {\n                        // Cap number of reported scroll events at 32 to prevent runaway redraws.\n                        // This is a mostly theoretical concern and the number can grow if it\n                        // doesn't seem to be a problem.\n                        DLog(@\"Cap at 32\");\n                        steps = MIN(32, fabs(chosenDelta));\n                    } else {\n                        steps = 1;\n                    }\n                    if (steps == 1 && [iTermAdvancedSettingsModel doubleReportScrollWheel]) {\n                        // This works around what I believe is a bug in tmux or a bug in\n                        // how users use tmux. See the thread on tmux-users with subject\n                        // \"Mouse wheel events and server_client_assume_paste--the perfect storm of bugs?\".\n                        DLog(@\"Double reporting\");\n                        steps = 2;\n                    }\n                    DLog(@\"steps=%d\", steps);\n                    for (int i = 0; i < steps; i++) {\n                        [self writeLatin1EncodedData:[_screen.terminalOutput mousePress:button\n                                                                          withModifiers:modifiers\n                                                                                     at:coord\n                                                                                  point:point]\n                                    broadcastAllowed:NO\n                                           reporting:NO];\n                    }\n                    return YES;\n\n                case MOUSE_REPORTING_NONE:\n                case MOUSE_REPORTING_HIGHLIGHT:\n                    DLog(@\"none/highlight - can't report\");\n                    break;\n            }\n            break;\n\n        default:\n            assert(NO);\n            break;\n    }\n    return NO;\n}\n\n- (VT100GridAbsCoordRange)textViewRangeOfLastCommandOutput {\n    DLog(@\"Fetching range of last command output...\");\n    if (![[iTermShellHistoryController sharedInstance] commandHistoryHasEverBeenUsed]) {\n        DLog(@\"Command history has never been used.\");\n        [iTermShellHistoryController showInformationalMessage];\n        return VT100GridAbsCoordRangeMake(-1, -1, -1, -1);\n    } else {\n        iTermTextExtractor *extractor = [iTermTextExtractor textExtractorWithDataSource:_screen];\n        long long absCursorY = _screen.cursorY - 1 + _screen.numberOfScrollbackLines + _screen.totalScrollbackOverflow;\n\n        if (self.isAtShellPrompt ||\n            _screen.startOfRunningCommandOutput.x == -1 ||\n            (absCursorY == _screen.startOfRunningCommandOutput.y && _screen.cursorX == 1)) {\n            DLog(@\"Returning cached range.\");\n            return [extractor rangeByTrimmingWhitespaceFromRange:_screen.lastCommandOutputRange\n                                                         leading:NO\n                                                        trailing:iTermTextExtractorTrimTrailingWhitespaceOneLine];\n        } else {\n            DLog(@\"Returning range of current command.\");\n            VT100GridAbsCoordRange range = VT100GridAbsCoordRangeMake(_screen.startOfRunningCommandOutput.x,\n                                                                      _screen.startOfRunningCommandOutput.y,\n                                                                      _screen.cursorX - 1,\n                                                                      absCursorY);\n            return [extractor rangeByTrimmingWhitespaceFromRange:range\n                                                         leading:NO\n                                                        trailing:iTermTextExtractorTrimTrailingWhitespaceOneLine];\n        }\n    }\n}\n\n- (VT100GridAbsCoordRange)textViewRangeOfCurrentCommand {\n    DLog(@\"Fetching range of current command\");\n    if (![[iTermShellHistoryController sharedInstance] commandHistoryHasEverBeenUsed]) {\n        DLog(@\"Command history has never been used.\");\n        [iTermShellHistoryController showInformationalMessage];\n        return VT100GridAbsCoordRangeMake(-1, -1, -1, -1);\n    } else {\n        VT100GridAbsCoordRange range;\n        iTermTextExtractorTrimTrailingWhitespace trailing;\n        if (self.isAtShellPrompt) {\n            range = VT100GridAbsCoordRangeFromCoordRange(_screen.extendedCommandRange,\n                                                         _screen.totalScrollbackOverflow);\n            trailing = iTermTextExtractorTrimTrailingWhitespaceAll;\n        } else {\n            range = _lastOrCurrentlyRunningCommandAbsRange;\n            trailing = iTermTextExtractorTrimTrailingWhitespaceOneLine;\n        }\n        iTermTextExtractor *extractor = [iTermTextExtractor textExtractorWithDataSource:_screen];\n        return [extractor rangeByTrimmingWhitespaceFromRange:range leading:YES trailing:trailing];\n    }\n}\n\n- (BOOL)textViewCanSelectOutputOfLastCommand {\n    // Return YES if command history has never been used so we can show the informational message.\n    return (![[iTermShellHistoryController sharedInstance] commandHistoryHasEverBeenUsed] ||\n            _screen.lastCommandOutputRange.start.x >= 0);\n\n}\n\n- (BOOL)textViewCanSelectCurrentCommand {\n    // Return YES if command history has never been used so we can show the informational message.\n    return (![[iTermShellHistoryController sharedInstance] commandHistoryHasEverBeenUsed] ||\n            self.isAtShellPrompt ||\n            (_lastOrCurrentlyRunningCommandAbsRange.start.x >= 0 &&\n             // It cannot select when the currently running command is lost due to scrollback overflow.\n             _lastOrCurrentlyRunningCommandAbsRange.start.y >= _screen.totalScrollbackOverflow));\n}\n\n- (iTermUnicodeNormalization)textViewUnicodeNormalizationForm {\n    return _screen.config.normalization;\n}\n\n- (NSColor *)textViewCursorGuideColor {\n    return _cursorGuideColor;\n}\n\n- (NSColor *)textViewBadgeColor {\n    return [iTermProfilePreferences colorForKey:KEY_BADGE_COLOR dark:_screen.colorMap.darkMode profile:_profile];\n}\n\n// Returns a dictionary with only string values by converting non-strings.\n- (NSDictionary *)textViewVariables {\n    return _variables.stringValuedDictionary;\n}\n\n- (iTermVariableScope<iTermSessionScope> *)variablesScope {\n    if (_variablesScope == nil) {\n        _variablesScope = [iTermVariableScope newSessionScopeWithVariables:self.variables];\n    }\n    return _variablesScope;\n}\n\n- (iTermVariableScope *)genericScope {\n    return self.variablesScope;\n}\n\n- (BOOL)textViewSuppressingAllOutput {\n    return _suppressAllOutput;\n}\n\n- (BOOL)textViewIsZoomedIn {\n    return _liveSession && !_dvr && !_filter;\n}\n\n- (BOOL)textViewIsFiltered {\n    return _liveSession && _filter;\n}\n\n- (BOOL)textViewShouldShowMarkIndicators {\n    return [iTermProfilePreferences boolForKey:KEY_SHOW_MARK_INDICATORS inProfile:_profile];\n}\n\n- (void)textViewThinksUserIsTryingToSendArrowKeysWithScrollWheel:(BOOL)isTrying {\n    [self.naggingController tryingToSendArrowKeysWithScrollWheel:isTrying];\n}\n\n// Grow or shrink the height of the frame if the number of lines in the data\n// source + IME has changed.\n- (BOOL)textViewResizeFrameIfNeeded {\n    // Check if the frame size needs to grow or shrink.\n    NSRect frame = [_textview frame];\n    const CGFloat desiredHeight = _textview.desiredHeight;\n    if (fabs(desiredHeight - NSHeight(frame)) >= 0.5) {\n        // Update the wrapper's size, which in turn updates textview's size.\n        frame.size.height = desiredHeight + [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins];  // The wrapper is always larger by VMARGIN.\n        _wrapper.frame = [self safeFrameForWrapperViewFrame:frame];\n\n        NSAccessibilityPostNotification(_textview,\n                                        NSAccessibilityRowCountChangedNotification);\n        return YES;\n    }\n    return NO;\n}\n\n- (NSInteger)textViewUnicodeVersion {\n    return _unicodeVersion;\n}\n\n- (void)textViewDidRefresh {\n    if (_textview.window.firstResponder != _textview) {\n        return;\n    }\n    iTermTextExtractor *textExtractor = [[[iTermTextExtractor alloc] initWithDataSource:_screen] autorelease];\n    NSString *word = [textExtractor fastWordAt:VT100GridCoordMake(_screen.cursorX - 1, _screen.cursorY + _screen.numberOfScrollbackLines - 1)];\n    [[_delegate realParentWindow] currentSessionWordAtCursorDidBecome:word];\n}\n\n- (void)textViewBackgroundColorDidChangeFrom:(NSColor *)before to:(NSColor *)after {\n    DLog(@\"%@\", [NSThread callStackSymbols]);\n    [self backgroundColorDidChangeJigglingIfNeeded:before.isDark != after.isDark];\n    [self updateAutoComposerSeparatorVisibility];\n    // Can't call this synchronously because we could get here from a side effect and\n    // viewDidChangeEffectiveAppearance can cause performBlockWithJoinedThreads to be called.\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf updateAppearanceForMinimalTheme];\n    });\n}\n\n- (void)themeDidChange {\n    [self updateAppearanceForMinimalTheme];\n}\n\n- (void)updateAppearanceForMinimalTheme {\n    const BOOL minimal = [iTermPreferences intForKey:kPreferenceKeyTabStyle] == TAB_STYLE_MINIMAL;\n    if (minimal) {\n        _view.appearance = [_screen.colorMap colorForKey:kColorMapBackground].isDark ? [NSAppearance appearanceNamed:NSAppearanceNameDarkAqua] : [NSAppearance appearanceNamed:NSAppearanceNameAqua];\n    } else {\n        _view.appearance = nil;\n    }\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(id)object\n                        change:(NSDictionary *)change\n                       context:(void *)context {\n    if (context == &iTermEffectiveAppearanceKey) {\n        DLog(@\"System appearance changed to %@\", [NSApp effectiveAppearance]);\n        const BOOL minimal = [iTermPreferences intForKey:kPreferenceKeyTabStyle] == TAB_STYLE_MINIMAL;\n        if (minimal && _screen.colorMap.useSeparateColorsForLightAndDarkMode) {\n            DLog(@\"Manually update view appearance\");\n            // The view's appearance determines which colors should be used. In minimal, we manually\n            // manage the appearance so that window chrome matches up with the background color. To\n            // break that dependency cycle, we manually update the appearance for minimal when the\n            // system theme changes.\n            self.view.appearance = [self colorMapShouldBeInDarkMode] ? [NSAppearance appearanceNamed:NSAppearanceNameDarkAqua] : [NSAppearance appearanceNamed:NSAppearanceNameAqua];\n        }\n    } else {\n        [super observeValueForKeyPath:keyPath\n                             ofObject:object\n                               change:change\n                              context:context];\n    }\n}\n\n- (BOOL)colorMapShouldBeInDarkMode {\n    const BOOL minimal = [iTermPreferences intForKey:kPreferenceKeyTabStyle] == TAB_STYLE_MINIMAL;\n    if (minimal) {\n        NSColor *backgroundColor = [iTermProfilePreferences colorForKey:KEY_BACKGROUND_COLOR\n                                                              dark:[NSApp effectiveAppearance].it_isDark\n                                                           profile:self.profile];\n        DLog(@\"dark=%@\", @(backgroundColor.isDark));\n        return backgroundColor.isDark;\n    }\n    DLog(@\"Not minimal so fall back to view (%@)/app (%@) appearance\", self.view.effectiveAppearance, [NSApp effectiveAppearance]);\n    return (self.view.effectiveAppearance ?: [NSApp effectiveAppearance]).it_isDark;\n}\n\n\n- (void)textViewTransparencyDidChange {\n    [self backgroundColorDidChangeJigglingIfNeeded:NO];\n}\n\n- (void)backgroundColorDidChangeJigglingIfNeeded:(BOOL)canJiggle {\n    [_delegate sessionBackgroundColorDidChange:self];\n    [_delegate sessionUpdateMetalAllowed];\n    [_statusBarViewController updateColors];\n    [_wrapper setNeedsDisplay:YES];\n    [self.view setNeedsDisplay:YES];\n    if (canJiggle && _profileInitialized) {\n        // See issue 9855.\n        self.needsJiggle = YES;\n    }\n}\n- (void)textViewForegroundColorDidChangeFrom:(NSColor *)before to:(NSColor *)after {\n    DLog(@\"%@\", [NSThread callStackSymbols]);\n    if (_profileInitialized && before.isDark != after.isDark) {\n        self.needsJiggle = YES;\n    }\n    [_composerManager updateFont];\n}\n\n- (void)textViewCursorColorDidChangeFrom:(NSColor *)before to:(NSColor *)after {\n    [_composerManager updateFont];\n}\n\n- (void)setNeedsJiggle:(BOOL)needsJiggle {\n    DLog(@\"setNeedsJiggle:%@\", @(needsJiggle));\n    if (!_initializationFinished) {\n        DLog(@\"Uninitialized\");\n        return;\n    }\n    if (_needsJiggle == needsJiggle) {\n        DLog(@\"Unchanged\");\n        return;\n    }\n    DLog(@\"%@\", [NSThread callStackSymbols]);\n    _needsJiggle = needsJiggle;\n    if (!needsJiggle) {\n        return;\n    }\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self jiggleIfNeeded];\n    });\n}\n\n- (void)jiggleIfNeeded {\n    DLog(@\"jiggleIfNeeded\");\n    if (!_needsJiggle) {\n        return;\n    }\n    _needsJiggle = NO;\n    [self jiggle];\n}\n\n- (void)textViewProcessedBackgroundColorDidChange {\n    [self updateViewBackgroundImage];\n}\n\n- (void)textViewBurySession {\n    [self bury];\n}\n\n- (NSRect)boundingFrameForWindowedRange:(VT100GridWindowedRange)range {\n    const NSRect visibleRect = _textview.enclosingScrollView.documentVisibleRect;\n    const VT100GridRect gridRect = VT100GridWindowedRangeBoundingRect(range);\n    const NSRect topLeft = [_textview rectForCoord:VT100GridRectTopLeft(gridRect)];\n    const NSRect topRight = [_textview rectForCoord:VT100GridRectTopRight(gridRect)];\n    const NSRect bottomLeft = [_textview rectForCoord:VT100GridRectBottomLeft(gridRect)];\n    const NSRect bottomRight = [_textview rectForCoord:VT100GridRectBottomRight(gridRect)];\n    const NSRect anchorRect = NSUnionRect(NSUnionRect(NSUnionRect(topLeft, topRight), bottomLeft), bottomRight);\n    const NSRect visibleAnchorRect = NSIntersectionRect(anchorRect, visibleRect);\n    return [_view convertRect:visibleAnchorRect fromView:_textview];\n}\n\n- (BOOL)textViewShowHoverURL:(NSString *)url anchor:(VT100GridWindowedRange)anchor {\n    return [_view setHoverURL:url\n                  anchorFrame:url ? [self boundingFrameForWindowedRange:anchor] : NSZeroRect];\n}\n\n- (BOOL)textViewCopyMode {\n    return _modeHandler.mode == iTermSessionModeCopy;\n}\n\n- (BOOL)textViewCopyModeSelecting {\n    return _modeHandler.copyModeHandler.state.selecting;\n}\n\n- (VT100GridCoord)textViewCopyModeCursorCoord {\n    return _modeHandler.copyModeHandler.state.coord;\n}\n\n- (BOOL)textViewPasswordInput {\n    return _passwordInput;\n}\n\n- (void)textViewDidSelectPasswordPrompt {\n    iTermApplicationDelegate *delegate = [iTermApplication.sharedApplication delegate];\n    [delegate openPasswordManagerToAccountName:nil\n                                     inSession:self];\n}\n\n- (void)textViewDidSelectRangeForFindOnPage:(VT100GridCoordRange)range {\n    if (_modeHandler.mode == iTermSessionModeCopy) {\n        _modeHandler.copyModeHandler.state.coord = range.start;\n        _modeHandler.copyModeHandler.state.start = range.end;\n        [self.textview setNeedsDisplay:YES];\n    }\n}\n\n- (void)textViewNeedsDisplayInRect:(NSRect)rect {\n    DLog(@\"text view needs display\");\n    NSRect visibleRect = NSIntersectionRect(rect, _textview.enclosingScrollView.documentVisibleRect);\n    [_view setMetalViewNeedsDisplayInTextViewRect:visibleRect];\n}\n\n- (BOOL)textViewShouldDrawRect {\n    // In issue 8843 we see that sometimes the background color can get out of sync. I can't\n    // figure it out. This patches the problem until I can collect more info.\n    [_view setTerminalBackgroundColor:[self processedBackgroundColor]];\n    return !_textview.suppressDrawing;\n}\n\n- (void)textViewDidHighlightMark {\n    if (self.useMetal) {\n        [_textview setNeedsDisplay:YES];\n    }\n}\n\n- (NSEdgeInsets)textViewEdgeInsets {\n    NSEdgeInsets insets;\n    const NSRect innerFrame = _view.scrollview.frame;\n    NSSize containerSize;\n    containerSize = _view.frame.size;\n\n    insets.bottom = NSMinY(innerFrame);\n    insets.top = containerSize.height - NSMaxY(innerFrame);\n    insets.left = NSMinX(innerFrame);\n    insets.right = containerSize.width - NSMaxX(innerFrame);\n\n    return insets;\n}\n\n- (BOOL)textViewInInteractiveApplication {\n    return _screen.terminalSoftAlternateScreenMode;\n}\n\n// NOTE: Make sure to update both the context menu and the main menu when modifying these.\n- (BOOL)textViewTerminalStateForMenuItem:(NSMenuItem *)menuItem {\n    switch (menuItem.tag) {\n        case 1:\n            return _screen.showingAlternateScreen;\n\n        case 2:\n            return _screen.terminalReportFocus;\n\n        case 3:\n            return _screen.terminalMouseMode != MOUSE_REPORTING_NONE;\n\n        case 4:\n            return _screen.terminalBracketedPasteMode;\n\n        case 5:\n            return _screen.terminalCursorMode;\n\n        case 6:\n            return _screen.terminalKeypadMode;\n\n        case 7:\n            return _keyMappingMode == iTermKeyMappingModeStandard;\n\n        case 8:\n            return _keyMappingMode == iTermKeyMappingModeModifyOtherKeys1;\n\n        case 9:\n            return _keyMappingMode == iTermKeyMappingModeModifyOtherKeys2;\n\n        case 10:\n            return _keyMappingMode == iTermKeyMappingModeCSIu;\n\n        case 11:\n            return _keyMappingMode == iTermKeyMappingModeRaw;\n    }\n\n    return NO;\n}\n\n- (void)textViewToggleTerminalStateForMenuItem:(NSMenuItem *)menuItem {\n    _modeHandler.mode = iTermSessionModeDefault;\n    const NSInteger tag = menuItem.tag;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        switch (tag) {\n            case 1:\n                [terminal toggleAlternateScreen];\n                break;\n\n            case 2:\n                terminal.reportFocus = !terminal.reportFocus;\n                break;\n\n            case 3:\n                if (terminal.mouseMode == MOUSE_REPORTING_NONE) {\n                    terminal.mouseMode = terminal.previousMouseMode;\n                } else {\n                    terminal.mouseMode = MOUSE_REPORTING_NONE;\n                }\n                [terminal.delegate terminalMouseModeDidChangeTo:terminal.mouseMode];\n                break;\n\n            case 4:\n                terminal.bracketedPasteMode = !terminal.bracketedPasteMode;\n                break;\n\n            case 5:\n                terminal.cursorMode = !terminal.cursorMode;\n                break;\n\n            case 6:\n                [terminal forceSetKeypadMode:!terminal.keypadMode];\n                break;\n\n            case 7:\n                terminal.sendModifiers[4] = @-1;\n                self.keyMappingMode = iTermKeyMappingModeStandard;\n                break;\n\n            case 8:\n                terminal.sendModifiers[4] = @1;\n                self.keyMappingMode = iTermKeyMappingModeModifyOtherKeys1;\n                break;\n\n            case 9:\n                terminal.sendModifiers[4] = @2;\n                self.keyMappingMode = iTermKeyMappingModeModifyOtherKeys2;\n                break;\n\n            case 10:\n                terminal.sendModifiers[4] = @-1;\n                self.keyMappingMode = iTermKeyMappingModeCSIu;\n                break;\n\n            case 11:\n                terminal.sendModifiers[4] = @-1;\n                self.keyMappingMode = iTermKeyMappingModeRaw;\n                break;\n        }\n    }];\n}\n\n- (void)textViewResetTerminal {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        [terminal gentleReset];\n    }];\n}\n\n- (CGFloat)textViewBadgeTopMargin {\n    return [iTermProfilePreferences floatForKey:KEY_BADGE_TOP_MARGIN inProfile:self.profile];\n}\n\n- (CGFloat)textViewBadgeRightMargin {\n    return [iTermProfilePreferences floatForKey:KEY_BADGE_RIGHT_MARGIN inProfile:self.profile];\n}\n\n- (iTermVariableScope *)textViewVariablesScope {\n    return self.variablesScope;\n}\n\n- (BOOL)textViewTerminalBackgroundColorDeterminesWindowDecorationColor {\n    return self.view.window.ptyWindow.it_terminalWindowUseMinimalStyle;\n}\n\n- (void)textViewDidUpdateDropTargetVisibility {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (iTermExpect *)textViewExpect {\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf sync];\n    });\n    return _expect;\n}\n\n- (void)textViewDidDetectMouseReportingFrustration {\n    [self.naggingController didDetectMouseReportingFrustration];\n}\n\n- (BOOL)textViewCanBury {\n    return !_synthetic;\n}\n\n- (void)textViewFindOnPageLocationsDidChange {\n    [_view.searchResultsMinimap invalidate];\n    [_view.marksMinimap invalidate];\n}\n\n- (void)textViewFindOnPageSelectedResultDidChange {\n    [_view.findDriver.viewController countDidChange];\n}\n\n- (CGFloat)textViewBlend {\n    return [self effectiveBlend];\n}\n\n- (id<iTermSwipeHandler>)textViewSwipeHandler {\n    return [self.delegate sessionSwipeHandler];\n}\n\n- (void)textViewAddContextMenuItems:(NSMenu *)menu {\n    if (!self.isTmuxClient) {\n        return;\n    }\n    if (!_tmuxController.gateway.pauseModeEnabled) {\n        return;\n    }\n    [menu addItem:[NSMenuItem separatorItem]];\n    if (_tmuxPaused) {\n        NSMenuItem *item = [menu addItemWithTitle:@\"Unpause tmux Pane\" action:@selector(toggleTmuxPaused) keyEquivalent:@\"\"];\n        item.target = self;\n    } else {\n        NSMenuItem *item = [menu addItemWithTitle:@\"Pause tmux Pane\" action:@selector(toggleTmuxPaused) keyEquivalent:@\"\"];\n        item.target = self;\n    }\n}\n\n- (NSString *)textViewShell {\n    return self.userShell;\n}\n\n- (void)textViewContextMenuInvocation:(NSString *)invocation\n                      failedWithError:(NSError *)error\n                          forMenuItem:(NSString *)title {\n    [PTYSession reportFunctionCallError:error\n                          forInvocation:invocation\n                                 origin:[NSString stringWithFormat:@\"Menu Item \u201c%@\u201d\", title]\n                                 window:self.view.window];\n}\n\n- (void)textViewEditTriggers {\n    [self openTriggersViewController];\n}\n\n- (void)openTriggersViewController {\n    [_triggerWindowController autorelease];\n    _triggerWindowController = [[TriggerController alloc] init];\n    _triggerWindowController.guid = self.profile[KEY_GUID];\n    _triggerWindowController.delegate = self;\n    [_triggerWindowController windowWillOpen];\n    __weak __typeof(self) weakSelf = self;\n    [self.view.window beginSheet:_triggerWindowController.window completionHandler:^(NSModalResponse returnCode) {\n        [weakSelf closeTriggerWindowController];\n    }];\n}\n\n- (void)textViewToggleEnableTriggersInInteractiveApps {\n    const BOOL value = [iTermProfilePreferences boolForKey:KEY_ENABLE_TRIGGERS_IN_INTERACTIVE_APPS inProfile:self.profile];\n    [self setSessionSpecificProfileValues:@{ KEY_ENABLE_TRIGGERS_IN_INTERACTIVE_APPS: @(!value) }];\n}\n\n- (BOOL)textViewTriggersAreEnabledInInteractiveApps {\n    return [iTermProfilePreferences boolForKey:KEY_ENABLE_TRIGGERS_IN_INTERACTIVE_APPS inProfile:self.profile];\n}\n\n- (iTermTimestampsMode)textviewTimestampsMode {\n    return (iTermTimestampsMode)[iTermProfilePreferences unsignedIntegerForKey:KEY_SHOW_TIMESTAMPS inProfile:self.profile];\n}\n\n- (void)textviewToggleTimestampsMode {\n    iTermTimestampsMode mode = iTermTimestampsModeOff;\n    switch ([self textviewTimestampsMode]) {\n        case iTermTimestampsModeOff:\n            mode = iTermTimestampsModeOn;\n            break;\n        case iTermTimestampsModeOn:\n        case iTermTimestampsModeHover:\n            mode = iTermTimestampsModeOff;\n            break;\n    }\n    [self setSessionSpecificProfileValues:@{ KEY_SHOW_TIMESTAMPS: @(mode) }];\n    [_textview setNeedsDisplay:YES];\n}\n\n- (void)textViewSetClickCoord:(VT100GridAbsCoord)coord\n                       button:(NSInteger)button\n                        count:(NSInteger)count\n                    modifiers:(NSEventModifierFlags)modifiers\n                  sideEffects:(iTermClickSideEffects)sideEffects\n                        state:(iTermMouseState)state {\n    self.variablesScope.mouseInfo = @[ @(coord.x), @(coord.y), @(button), @(count), [self apiModifiersForModifierFlags:modifiers], @(sideEffects), @(state) ];\n}\n\n- (void)closeTriggerWindowController {\n    [_triggerWindowController close];\n}\n\n- (void)textViewAddTrigger:(NSString *)text {\n    [self openAddTriggerViewControllerWithText:text];\n}\n\n- (void)openAddTriggerViewControllerWithText:(NSString *)text {\n    __weak __typeof(self) weakSelf = self;\n    iTermColorSuggester *cs =\n    [[[iTermColorSuggester alloc] initWithDefaultTextColor:[_screen.colorMap colorForKey:kColorMapForeground]\n                                    defaultBackgroundColor:[_screen.colorMap colorForKey:kColorMapBackground]\n                                         minimumDifference:0.25\n                                                      seed:[text hash]] autorelease];\n    [iTermAddTriggerViewController addTriggerForText:text\n                                              window:self.view.window\n                                 interpolatedStrings:[self.profile[KEY_TRIGGERS_USE_INTERPOLATED_STRINGS] boolValue]\n                                    defaultTextColor:cs.suggestedTextColor\n                              defaultBackgroundColor:cs.suggestedBackgroundColor\n                                          completion:^(NSDictionary * _Nonnull dict, BOOL updateProfile) {\n        if (!dict) {\n            return;\n        }\n        [weakSelf addTriggerDictionary:dict updateProfile:updateProfile];\n    }];\n}\n\n- (void)textViewShowFindIndicator:(VT100GridCoordRange)range {\n    DLog(@\"begin %@\", VT100GridCoordRangeDescription(range));\n    VT100GridCoordRange visibleRange = range;\n    VT100GridRange visibleLines = _textview.rangeOfVisibleLines;\n    if (visibleRange.start.y > VT100GridRangeMax(visibleLines) ||\n        visibleRange.end.y < visibleLines.location) {\n        return;\n    }\n    if (visibleRange.start.y < visibleLines.location) {\n        visibleRange.start.y = visibleLines.location;\n        visibleRange.start.x = 0;\n    }\n    if (visibleRange.end.y > VT100GridRangeMax(visibleLines)) {\n        visibleRange.end.y = VT100GridRangeMax(visibleLines);\n        visibleRange.end.x = _screen.width;\n    }\n    int minX = visibleRange.start.x;\n    int maxX = visibleRange.end.x;\n    if (visibleRange.start.y != visibleRange.end.y) {\n        minX = 0;\n        maxX = _screen.width;\n    }\n    const int hmargin = [iTermPreferences intForKey:kPreferenceKeySideMargins];\n    const int vmargin = [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins];\n    const int rows = visibleRange.end.y - visibleRange.start.y + 1;\n    const VT100GridSize gridSize = VT100GridSizeMake(maxX - minX, rows);\n    const CGFloat cellWidth = [_textview charWidth];\n    const CGFloat cellHeight = [_textview lineHeight];\n    const NSSize padding = iTermTextClipDrawing.padding;\n    const NSSize imageSize = NSMakeSize(_screen.width * cellWidth + padding.width * 2,\n                                        gridSize.height * cellHeight + padding.height * 2);\n    NSImage *image = [NSImage flippedImageOfSize:imageSize drawBlock:^{\n        [NSGraphicsContext.currentContext saveGraphicsState];\n        NSAffineTransform *transform = [NSAffineTransform transform];\n        [transform translateXBy:padding.width yBy:padding.height];\n        [transform concat];\n        [iTermTextClipDrawing drawClipWithDrawingHelper:_textview.drawingHelper\n                                        numHistoryLines:_screen.numberOfScrollbackLines\n                                                  range:visibleRange];\n        [NSGraphicsContext.currentContext restoreGraphicsState];\n    }];\n    const NSRect subrect = NSMakeRect(hmargin + minX * cellWidth,\n                                      0,\n                                      (maxX - minX) * cellWidth + padding.width * 2,\n                                      rows * cellHeight + padding.height * 2);\n    NSImage *cropped = [image it_subimageWithRect:subrect];\n    // The rect in legacyView that matches `subrect`.\n    NSRect sourceRect =\n    NSMakeRect(subrect.origin.x - padding.width,\n               (visibleRange.start.y - visibleLines.location) * _textview.lineHeight + vmargin - padding.height,\n               cropped.size.width,\n               cropped.size.height);\n\n    const NSEdgeInsets shadowInsets = NSEdgeInsetsMake(12, 12, 12, 12);\n    NSImage *shadowed = [NSImage flippedImageOfSize:NSMakeSize(subrect.size.width + shadowInsets.left + shadowInsets.right,\n                                                               subrect.size.height + shadowInsets.top + shadowInsets.bottom)\n                                          drawBlock:^{\n        NSShadow *shadow = [[[NSShadow alloc] init] autorelease];\n\n        shadow.shadowOffset = NSMakeSize(0, 0);\n        shadow.shadowBlurRadius = 4;\n        shadow.shadowColor = [NSColor colorWithWhite:0 alpha:0.4];\n        [shadow set];\n\n        [cropped drawInRect:NSMakeRect(shadowInsets.left,\n                                       shadowInsets.top,\n                                       cropped.size.width,\n                                       cropped.size.height)];\n\n        // Draw again with a smaller shadow to act as an outline.\n        shadow = [[[NSShadow alloc] init] autorelease];\n\n        shadow.shadowOffset = NSMakeSize(0, 0);\n        shadow.shadowBlurRadius = 1;\n        shadow.shadowColor = [NSColor colorWithWhite:0 alpha:0.6];\n        [shadow set];\n\n        [cropped drawInRect:NSMakeRect(shadowInsets.left,\n                                       shadowInsets.top,\n                                       cropped.size.width,\n                                       cropped.size.height)];\n    }];\n    sourceRect.origin.x -= shadowInsets.left;\n    sourceRect.origin.y -= shadowInsets.top;\n    sourceRect.size.width += shadowInsets.left + shadowInsets.right;\n    sourceRect.size.height += shadowInsets.top + shadowInsets.bottom;\n    FindIndicatorWindow *window =\n    [FindIndicatorWindow showWithImage:shadowed\n                                  view:_view.legacyView\n                                  rect:sourceRect\n                      firstVisibleLine:visibleLines.location + _screen.totalScrollbackOverflow];\n    if (window) {\n        [_textview trackChildWindow:window];\n    }\n}\n\n- (BOOL)textViewCanWriteToTTY {\n    return !_exited;\n}\n\n- (void)addTriggerDictionary:(NSDictionary *)dict updateProfile:(BOOL)updateProfile {\n    if (!updateProfile || !self.isDivorced || [_overriddenFields containsObject:KEY_TRIGGERS]) {\n        NSMutableArray<NSDictionary *> *triggers = [[self.profile[KEY_TRIGGERS] ?: @[] mutableCopy] autorelease];\n        [triggers addObject:dict];\n        [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS: triggers }];\n    }\n\n    if (!updateProfile) {\n        return;\n    }\n    NSString *guid;\n    if (self.isDivorced) {\n        guid = self.profile[KEY_ORIGINAL_GUID];\n    } else {\n        guid = self.profile[KEY_GUID];\n    }\n    MutableProfile *profile = [[[[ProfileModel sharedInstance] bookmarkWithGuid:guid] mutableCopy] autorelease];\n    if (!profile) {\n        return;\n    }\n    profile[KEY_TRIGGERS] = [profile[KEY_TRIGGERS] ?: @[] arrayByAddingObject:dict];\n    [[ProfileModel sharedInstance] setBookmark:profile withGuid:profile[KEY_GUID]];\n}\n\n- (void)textViewApplyAction:(iTermAction *)action {\n    [self applyAction:action];\n}\n\n- (void)textViewhandleSpecialKeyDown:(NSEvent *)event {\n    if (_keystrokeSubscriptions.count) {\n        [self sendKeystrokeNotificationForEvent:event advanced:NO];\n    }\n}\n\n- (NSString *)userShell {\n    return [ITAddressBookMgr customShellForProfile:self.profile] ?: [iTermOpenDirectory userShell] ?: @\"/bin/bash\";\n}\n\n- (void)toggleTmuxPaused {\n    if (_tmuxPaused) {\n        [self setTmuxPaused:NO allowAutomaticUnpause:NO];\n    } else {\n        [self.tmuxController pausePanes:@[ @(self.tmuxPane) ]];\n    }\n}\n\n- (void)bury {\n    DLog(@\"Bury %@\", self);\n    if (_synthetic) {\n        DLog(@\"Attempt to bury while synthetic\");\n        return;\n    }\n    if (self.isTmuxClient) {\n        DLog(@\"Is tmux\");\n        if (!self.delegate) {\n            return;\n        }\n        [_tmuxController hideWindow:self.delegate.tmuxWindow];\n        return;\n    }\n    [_textview setDataSource:nil];\n    [_textview setDelegate:nil];\n    [[iTermBuriedSessions sharedInstance] addBuriedSession:self];\n    [_delegate sessionRemoveSession:self];\n\n    _delegate = nil;\n}\n\n- (void)sendEscapeSequence:(NSString *)text\n{\n    if (_exited) {\n        return;\n    }\n    if ([text length] > 0) {\n        NSString *aString = [NSString stringWithFormat:@\"\\e%@\", text];\n        [self writeTask:aString];\n    }\n}\n\n- (NSData *)dataForHexCodes:(NSString *)codes {\n    NSMutableData *data = [NSMutableData data];\n    NSArray* components = [codes componentsSeparatedByString:@\" \"];\n    for (NSString* part in components) {\n        const char* utf8 = [part UTF8String];\n        char* endPtr;\n        unsigned char c = strtol(utf8, &endPtr, 16);\n        if (endPtr != utf8) {\n            [data appendData:[NSData dataWithBytes:&c length:sizeof(c)]];\n        }\n    }\n    return data;\n}\n\n- (void)sendHexCode:(NSString *)codes {\n    if (_exited) {\n        return;\n    }\n    if ([codes length]) {\n        [self writeLatin1EncodedData:[self dataForHexCodes:codes]\n                    broadcastAllowed:YES\n                           reporting:NO];\n    }\n}\n\n- (void)openAdvancedPasteWithText:(NSString *)text escaping:(iTermSendTextEscaping)escaping {\n    NSString *escaped = [self escapedText:text mode:escaping];\n    NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];\n    [pasteboard declareTypes:@[ NSPasteboardTypeString ] owner:self];\n    [pasteboard setString:escaped forType:NSPasteboardTypeString];\n    [_pasteHelper showAdvancedPasteWithFlags:0];\n}\n\n- (void)openComposerWithString:(NSString *)text escaping:(iTermSendTextEscaping)escaping {\n    NSString *escaped = [self escapedText:text mode:escaping];\n    [self.composerManager showOrAppendToDropdownWithString:escaped];\n}\n\n- (void)sendText:(NSString *)text escaping:(iTermSendTextEscaping)escaping {\n    DLog(@\"sendText:%@ escaping:%@\",\n         text,\n         @(escaping));\n    if (_exited) {\n        DLog(@\"Already exited\");\n        return;\n    }\n    if (![text isKindOfClass:[NSString class]]) {\n        DLog(@\"Not a string: %@\", text);\n    }\n    if ([text length] == 0) {\n        return;\n    }\n    [self writeTask:[self escapedText:text mode:escaping]];\n}\n\n- (NSString *)escapedText:(NSString *)text mode:(iTermSendTextEscaping)escaping {\n    NSString *temp = text;\n    switch (escaping) {\n        case iTermSendTextEscapingNone:\n            return text;\n        case iTermSendTextEscapingCommon:\n            return [temp stringByReplacingCommonlyEscapedCharactersWithControls];\n        case iTermSendTextEscapingCompatibility:\n            temp = [temp stringByReplacingEscapedChar:'n' withString:@\"\\n\"];\n            temp = [temp stringByReplacingEscapedChar:'e' withString:@\"\\e\"];\n            temp = [temp stringByReplacingEscapedChar:'a' withString:@\"\\a\"];\n            temp = [temp stringByReplacingEscapedChar:'t' withString:@\"\\t\"];\n            return temp;\n        case iTermSendTextEscapingVimAndCompatibility:\n            temp = [temp stringByExpandingVimSpecialCharacters];\n            temp = [temp stringByReplacingEscapedChar:'n' withString:@\"\\n\"];\n            temp = [temp stringByReplacingEscapedChar:'e' withString:@\"\\e\"];\n            temp = [temp stringByReplacingEscapedChar:'a' withString:@\"\\a\"];\n            temp = [temp stringByReplacingEscapedChar:'t' withString:@\"\\t\"];\n            return temp;\n        case iTermSendTextEscapingVim:\n            return [temp stringByExpandingVimSpecialCharacters];\n    }\n    assert(NO);\n    return @\"\";\n}\n\n- (void)sendTextSlowly:(NSString *)text {\n    PasteEvent *event = [_pasteHelper pasteEventWithString:text\n                                                    slowly:NO\n                                          escapeShellChars:NO\n                                                  isUpload:NO\n                                           allowBracketing:YES\n                                              tabTransform:NO\n                                              spacesPerTab:0\n                                                  progress:^(NSInteger progress) {}];\n    event.defaultChunkSize = 80;\n    event.defaultDelay = 0.02;\n    event.chunkKey = @\"\";\n    event.delayKey = @\"\";\n    event.flags = kPasteFlagsDisableWarnings;\n    [_pasteHelper tryToPasteEvent:event];\n}\n\n- (void)launchCoprocessWithCommand:(NSString *)command\n{\n    [self launchCoprocessWithCommand:command mute:NO];\n}\n\n- (void)uploadFiles:(NSArray *)localFilenames toPath:(SCPPath *)destinationPath\n{\n    SCPFile *previous = nil;\n    for (NSString *file in localFilenames) {\n        SCPPath *path = [[[SCPPath alloc] init] autorelease];\n        path.hostname = destinationPath.hostname;\n        path.username = destinationPath.username;\n        NSString *filename = [file lastPathComponent];\n        path.path = [destinationPath.path stringByAppendingPathComponent:filename];\n\n        if (@available(macOS 11, *)) {\n            if ([_conductor canTransferFilesTo:path]) {\n                [_conductor uploadFile:file to:path];\n                break;\n            }\n        }\n        SCPFile *scpFile = [[[SCPFile alloc] init] autorelease];\n        scpFile.path = path;\n        scpFile.localPath = file;\n\n        if (previous) {\n            previous.successor = scpFile;\n        }\n        previous = scpFile;\n        [scpFile upload];\n    }\n}\n\n- (void)startDownloadOverSCP:(SCPPath *)path\n{\n    if (@available(macOS 11, *)) {\n        if ([_conductor canTransferFilesTo:path]) {\n            [_conductor download:path];\n            return;\n        }\n    }\n    SCPFile *file = [[[SCPFile alloc] init] autorelease];\n    file.path = path;\n    [file download];\n}\n\n- (void)setDvrFrame {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        const screen_char_t *s = (const screen_char_t *)[_dvrDecoder decodedFrame];\n        const int len = [_dvrDecoder screenCharArrayLength];\n        DVRFrameInfo info = [_dvrDecoder info];\n        if (info.width != mutableState.width || info.height != mutableState.height) {\n            if (![_liveSession isTmuxClient]) {\n                [[_delegate realParentWindow] sessionInitiatedResize:self\n                                                               width:info.width\n                                                              height:info.height];\n            }\n        }\n        NSData *data = [NSData dataWithBytes:s length:len];\n        NSMutableArray<NSArray *> *metadataArrays = [NSMutableArray mapIntegersFrom:0 to:info.height block:^id(NSInteger i) {\n            NSData *data = [_dvrDecoder metadataForLine:i];\n            return iTermMetadataArrayFromData(data) ?: @[];\n        }];\n\n        if (_dvrDecoder.migrateFromVersion > 0) {\n            const int lineCount = (info.width + 1);\n            NSMutableData *replacement = [NSMutableData data];\n            for (int y = 0; y < info.height; y++) {\n                NSData *legacyData = [NSData dataWithBytes:s + lineCount * y\n                                                    length:lineCount * sizeof(legacy_screen_char_t)];\n                NSData *modernData;\n                switch (_dvrDecoder.migrateFromVersion) {\n                    case 1: {\n                        iTermMetadata temp = { 0 };\n                        iTermMetadataInitFromArray(&temp, metadataArrays[y]);\n                        iTermMetadataAutorelease(temp);\n                        iTermExternalAttributeIndex *originalIndex = iTermMetadataGetExternalAttributesIndex(temp);\n                        iTermExternalAttributeIndex *eaIndex = originalIndex;\n                        modernData = [legacyData migrateV1ToV3:&eaIndex];\n                        if (!originalIndex && eaIndex) {\n                            iTermMetadataSetExternalAttributes(&temp, eaIndex);\n                            metadataArrays[y] = iTermMetadataEncodeToArray(temp);\n                        }\n                        break;\n                    }\n                    case 2:\n                        modernData = [legacyData migrateV2ToV3];\n                        break;\n                    case 3:\n                        modernData = legacyData;\n                        break;\n                    default:\n                        DLog(@\"Unexpected source version %@\", @(_dvrDecoder.migrateFromVersion));\n                        modernData = legacyData;\n                        break;\n                }\n                [replacement appendData:modernData];\n            }\n            data = replacement;\n        }\n        [mutableState setFromFrame:(screen_char_t *)data.bytes\n                               len:data.length\n                          metadata:metadataArrays\n                              info:info];\n        [[_delegate realParentWindow] clearTransientTitle];\n        [[_delegate realParentWindow] setWindowTitle];\n    }];\n}\n\n- (void)continueTailFind {\n    NSMutableArray<SearchResult *> *results = [NSMutableArray array];\n    BOOL more;\n    VT100GridAbsCoordRange rangeSearched = VT100GridAbsCoordRangeMake(-1, -1, -1, -1);\n    NSRange ignore;\n    more = [_screen continueFindAllResults:results\n                                  rangeOut:&ignore\n                                 inContext:_tailFindContext\n                             rangeSearched:&rangeSearched];\n    DLog(@\"Continue tail find found %@ results, more=%@\", @(results.count), @(more));\n    if (VT100GridAbsCoordRangeIsValid(rangeSearched)) {\n        [_textview removeSearchResultsInRange:rangeSearched];\n    }\n    for (SearchResult *r in results) {\n        [_textview addSearchResult:r];\n    }\n    if ([results count]) {\n        [_textview setNeedsDisplay:YES];\n    }\n    if (more) {\n        DLog(@\"Schedule continueTailFind in .01 sec\");\n        _tailFindTimer = [NSTimer scheduledTimerWithTimeInterval:0.01\n                                                          target:self\n                                                        selector:@selector(continueTailFind)\n                                                        userInfo:nil\n                                                         repeats:NO];\n    } else {\n        DLog(@\"tailfind is all done\");\n        // Update the saved position to just before the screen.\n        [_screen storeLastPositionInLineBufferAsFindContextSavedPosition];\n        _tailFindTimer = nil;\n        _performingOneShotTailFind = NO;\n    }\n}\n\n- (void)beginContinuousTailFind {\n    DLog(@\"beginContinuousTailFind\");\n    _performingOneShotTailFind = NO;\n    [self beginTailFindImpl];\n}\n\n- (void)beginOneShotTailFind {\n    DLog(@\"beginOneShotTailFind\");\n    if (_tailFindTimer || _performingOneShotTailFind) {\n        return;\n    }\n    _performingOneShotTailFind = YES;\n    if (![self beginTailFindImpl]) {\n        _performingOneShotTailFind = NO;\n    }\n}\n\n- (BOOL)beginTailFindImpl {\n    DLog(@\"beginTailFindImpl\");\n    FindContext *findContext = [_textview findContext];\n    if (!findContext.substring) {\n        return NO;\n    }\n    DLog(@\"Begin tail find\");\n    [_screen setFindString:findContext.substring\n          forwardDirection:YES\n                      mode:findContext.mode\n               startingAtX:0\n               startingAtY:0\n                withOffset:0\n                 inContext:_tailFindContext\n           multipleResults:YES];\n\n    // Set the starting position to the block & offset that the backward search\n    // began at. Do a forward search from that location.\n    [_screen restoreSavedPositionToFindContext:_tailFindContext];\n    [self continueTailFind];\n    return YES;\n}\n\n- (void)sessionContentsChanged:(NSNotification *)notification {\n    if (!_tailFindTimer &&\n        [notification object] == self &&\n        [_delegate sessionBelongsToVisibleTab]) {\n        DLog(@\"Session contents changed. Begin tail find.\");\n        __weak __typeof(self) weakSelf = self;\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [weakSelf startTailFindIfVisible];\n        });\n    }\n}\n\n- (void)stopTailFind\n{\n    if (_tailFindTimer) {\n        _tailFindContext.substring = nil;\n        _tailFindContext.results = nil;\n        [_tailFindTimer invalidate];\n        _tailFindTimer = nil;\n    }\n}\n\n- (void)printTmuxMessage:(NSString *)message {\n    DLog(@\"%@\", message);\n    if (_exited) {\n        return;\n    }\n    // Use mutateAsync because you get here from a side-effect.\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal,\n                                    VT100ScreenMutableState *mutableState,\n                                    id<VT100ScreenDelegate> delegate) {\n        screen_char_t savedFgColor = [terminal foregroundColorCode];\n        screen_char_t savedBgColor = [terminal backgroundColorCode];\n        [terminal setForegroundColor:ALTSEM_DEFAULT\n                  alternateSemantics:YES];\n        [terminal setBackgroundColor:ALTSEM_DEFAULT\n                  alternateSemantics:YES];\n        [mutableState appendStringAtCursor:message];\n        [mutableState appendCarriageReturnLineFeed];\n        [terminal setForegroundColor:savedFgColor.foregroundColor\n                  alternateSemantics:savedFgColor.foregroundColorMode == ColorModeAlternate];\n        [terminal setBackgroundColor:savedBgColor.backgroundColor\n                  alternateSemantics:savedBgColor.backgroundColorMode == ColorModeAlternate];\n    }];\n}\n\n- (void)printTmuxCommandOutputToScreen:(NSString *)response\n{\n    for (NSString *aLine in [response componentsSeparatedByString:@\"\\n\"]) {\n        aLine = [aLine stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"];\n        [self printTmuxMessage:aLine];\n    }\n}\n\n#pragma mark - VT100ScreenDelegate\n\n- (void)screenScheduleRedrawSoon {\n    self.active = YES;\n}\n\n- (void)screenResetTailFind {\n    _screen.savedFindContextAbsPos = 0;\n}\n\n- (void)screenNeedsRedraw {\n    [self refresh];\n    [_textview updateSubviewFrames];\n}\n\n- (void)screenUpdateDisplay:(BOOL)redraw {\n    [self updateDisplayBecause:[NSString stringWithFormat:@\"screen requested update redraw=%@\", @(redraw)]];\n    if (redraw) {\n        [_textview setNeedsDisplay:YES];\n    }\n}\n\n- (void)screenRefreshFindOnPageView {\n    [_view.findDriver.viewController countDidChange];\n}\n\n- (void)screenSizeDidChangeWithNewTopLineAt:(int)newTop {\n    if ([(PTYScroller*)([_view.scrollview verticalScroller]) userScroll] && newTop >= 0) {\n        const VT100GridRange range = VT100GridRangeMake(newTop,\n                                                        _textview.rangeOfVisibleLines.length);\n        [_textview scrollLineNumberRangeIntoView:range];\n    } else {\n        [_textview scrollEnd];\n    }\n\n    [_textview updateNoteViewFrames];\n    [_textview updatePortholeFrames];\n    [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionColumns: @(_screen.width),\n                                                    iTermVariableKeySessionRows: @(_screen.height) }];\n    [_textview setBadgeLabel:[self badgeLabel]];\n}\n\n- (void)screenDidReset {\n    _cursorGuideSettingHasChanged = NO;\n    _textview.highlightCursorLine = [iTermProfilePreferences boolForColorKey:KEY_USE_CURSOR_GUIDE\n                                                                        dark:_screen.colorMap.darkMode\n                                                                     profile:_profile];\n    self.cursorTypeOverride = nil;\n    [_textview setNeedsDisplay:YES];\n    [self restoreColorsFromProfile];\n    _screen.trackCursorLineMovement = NO;\n}\n\n- (void)restoreColorsFromProfile {\n    NSMutableDictionary<NSString *, id> *change = [NSMutableDictionary dictionary];\n    for (NSString *key in [[_screen.colorMap colormapKeyToProfileKeyDictionary] allValues]) {\n        if (![_overriddenFields containsObject:key]) {\n            continue;\n        }\n        id profileValue = self.originalProfile[key] ?: [NSNull null];\n        change[key] = profileValue;\n    }\n    if (change.count == 0) {\n        return;\n    }\n    [self setSessionSpecificProfileValues:change];\n}\n\n// If plainText is false then it's a control code.\n- (void)screenDidAppendStringToCurrentLine:(NSString * _Nonnull)string\n                               isPlainText:(BOOL)plainText\n                                foreground:(screen_char_t)fg\n                                background:(screen_char_t)bg {\n    if (plainText) {\n        [self logCooked:[string dataUsingEncoding:_screen.terminalEncoding]\n             foreground:fg\n             background:bg];\n    }\n}\n\n- (void)logCooked:(NSData *)data\n       foreground:(screen_char_t)fg\n       background:(screen_char_t)bg {\n    if (!_logging.enabled) {\n        return;\n    }\n    if (self.isTmuxGateway) {\n        return;\n    }\n    switch (_logging.style) {\n        case iTermLoggingStyleRaw:\n        case iTermLoggingStyleAsciicast:\n            break;\n        case iTermLoggingStylePlainText:\n            [_logging logData:data];\n            break;\n        case iTermLoggingStyleHTML:\n            [_logging logData:[data htmlDataWithForeground:fg\n                                                background:bg\n                                                  colorMap:_screen.colorMap\n                                        useCustomBoldColor:_textview.useCustomBoldColor\n                                              brightenBold:_textview.brightenBold]];\n            break;\n    }\n}\n\n- (void)screenDidAppendAsciiDataToCurrentLine:(NSData *)asciiData\n                                   foreground:(screen_char_t)fg\n                                   background:(screen_char_t)bg {\n    if (_logging.enabled) {\n        [self logCooked:asciiData\n             foreground:fg\n             background:bg];\n    }\n}\n\n- (void)screenRevealComposerWithPrompt:(NSArray<ScreenCharArray *> *)prompt {\n    _promptStateAllowsAutoComposer = YES;\n    if ([iTermPreferences boolForKey:kPreferenceAutoComposer]) {\n        if (_initializationFinished) {\n            if (![self haveAutoComposer]) {\n                [_composerManager reset];\n                [self revealAutoComposerWithPrompt:prompt];\n            }\n        } else {\n            _desiredComposerPrompt = [prompt copy];\n        }\n    }\n}\n\n- (void)screenDismissComposer {\n    _promptStateAllowsAutoComposer = NO;\n    if (_initializationFinished) {\n        [self.composerManager dismissAnimated:NO];\n    } else {\n        [_desiredComposerPrompt release];\n        _desiredComposerPrompt = nil;\n    }\n    [_textview setNeedsDisplay:YES];\n}\n\n- (void)screenAppendStringToComposer:(NSString *)string {\n    if (self.haveAutoComposer) {\n        DLog(@\"Append to composer: %@\", string);\n        [_composerManager insertText:string];\n        _composerManager.haveShellProvidedText = YES;\n    }\n}\n\n- (void)screenSetCursorType:(ITermCursorType)newType {\n    ITermCursorType type = newType;\n    if (type == CURSOR_DEFAULT) {\n        self.cursorTypeOverride = nil;\n    } else {\n        self.cursorTypeOverride = [@(type) retain];\n    }\n}\n\n- (void)screenSetCursorBlinking:(BOOL)blink {\n    if (![iTermProfilePreferences boolForKey:KEY_ALLOW_CHANGE_CURSOR_BLINK inProfile:self.profile]) {\n        return;\n    }\n    // This doesn't update the profile because we want reset to be able to restore it to the\n    // profile's value. It does mean the session profile won't reflect that the cursor is blinking.\n    self.textview.blinkingCursor = blink;\n}\n\n- (BOOL)screenCursorIsBlinking {\n    return self.textview.blinkingCursor;\n}\n\n- (void)screenResetCursorTypeAndBlink {\n    self.cursorTypeOverride = nil;\n    self.textview.blinkingCursor = [iTermProfilePreferences boolForKey:KEY_BLINKING_CURSOR inProfile:self.profile];\n}\n\n- (void)screenGetCursorType:(ITermCursorType *)cursorTypeOut\n                   blinking:(BOOL *)blinking {\n    *cursorTypeOut = self.cursorType;\n    *blinking = self.textview.blinkingCursor;\n}\n\n- (BOOL)screenShouldInitiateWindowResize {\n    return ![[[self profile] objectForKey:KEY_DISABLE_WINDOW_RESIZING] boolValue];\n}\n\n- (void)screenResizeToWidth:(int)width height:(int)height {\n    [_delegate sessionInitiatedResize:self width:width height:height];\n}\n\n- (void)screenSetSize:(VT100GridSize)proposedSize {\n    if (![self screenShouldInitiateWindowResize]) {\n        return;\n    }\n    if ([[_delegate parentWindow] anyFullScreen]) {\n        return;\n    }\n    int rows = proposedSize.width;\n    const VT100GridSize windowSize = [self windowSizeInCells];\n    if (rows == -1) {\n        rows = _screen.height;\n    } else if (rows == 0) {\n        rows = windowSize.height;\n    }\n\n    int columns = proposedSize.height;\n    if (columns == -1) {\n        columns = _screen.width;\n    } else if (columns == 0) {\n        columns = windowSize.width;\n    }\n    [_delegate sessionInitiatedResize:self width:columns height:rows];\n}\n\n- (VT100GridSize)windowSizeInCells {\n    VT100GridSize result;\n    const NSRect screenFrame = [self screenWindowScreenFrame];\n    const NSRect windowFrame = [self screenWindowFrame];\n    const NSSize cellSize = [self screenCellSize];\n    {\n        const CGFloat roomToGrow = screenFrame.size.height - windowFrame.size.height;\n        result.height = round(_screen.height + roomToGrow / cellSize.height);\n    }\n    {\n        const CGFloat roomToGrow = screenFrame.size.width - windowFrame.size.width;\n        result.width = round(_screen.width + roomToGrow / cellSize.width);\n    }\n    return result;\n}\n\n- (void)screenSetPointSize:(NSSize)proposedSize {\n    if (![self screenShouldInitiateWindowResize]) {\n        return;\n    }\n    if ([self screenWindowIsFullscreen]) {\n        return;\n    }\n    // TODO: Only allow this if there is a single session in the tab.\n    const NSRect frame = [self screenWindowFrame];\n    const NSRect screenFrame = [self screenWindowScreenFrame];\n    CGFloat width = proposedSize.width;\n    if (width < 0) {\n        width = frame.size.width;\n    } else if (width == 0) {\n        width = screenFrame.size.width;\n    }\n\n    CGFloat height = proposedSize.height;\n    if (height < 0) {\n        height = frame.size.height;\n    } else if (height == 0) {\n        height = screenFrame.size.height;\n    }\n    [[_delegate realParentWindow] setFrameSize:NSMakeSize(width, height)];\n}\n\n- (void)screenPrintStringIfAllowed:(NSString *)string\n                        completion:(void (^)(void))completion {\n    // Dispatch because this may show an alert and you can't have a runloop in a side effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self reallyTryToPrintString:string];\n        completion();\n    });\n}\n\n- (void)reallyTryToPrintString:(NSString *)string {\n    if (![self shouldBeginPrinting:YES]) {\n        return;\n    }\n    if (string.length > 0) {\n        [[self textview] printContent:string];\n    }\n}\n\n- (BOOL)shouldBeginPrinting:(BOOL)willPrint {\n    if (!_printGuard) {\n        _printGuard = [[iTermPrintGuard alloc] init];\n    }\n    return [_printGuard shouldPrintWithProfile:self.profile\n                                      inWindow:self.view.window\n                                     willPrint:willPrint];\n}\n\n- (void)screenSetWindowTitle:(NSString *)title {\n    // The window name doesn't normally serve as an interpolated string, but just to be extra safe\n    // break up \\(.\n    title = [title stringByReplacingOccurrencesOfString:@\"\\\\(\" withString:@\"\\\\\\u200B(\"];\n    [self setWindowTitle:title];\n    [self.delegate sessionDidSetWindowTitle:title];\n}\n\n- (NSString *)screenWindowTitle {\n    return [self windowTitle];\n}\n\n- (NSString *)screenIconTitle {\n    return [self.variablesScope valueForVariableName:iTermVariableKeySessionIconName] ?: [self.variablesScope valueForVariableName:iTermVariableKeySessionName];\n}\n\n- (void)screenSetIconName:(NSString *)theName {\n    DLog(@\"screenSetIconName:%@\", theName);\n    // Put a zero-width space in between \\ and ( to avoid interpolated strings coming from the server.\n    theName = [theName stringByReplacingOccurrencesOfString:@\"\\\\(\" withString:@\"\\\\\\u200B(\"];\n    [self setIconName:theName];\n    [self enableSessionNameTitleComponentIfPossible];\n}\n\n- (void)screenSetSubtitle:(NSString *)subtitle {\n    DLog(@\"screenSetSubtitle:%@\", subtitle);\n    // Put a zero-width space in between \\ and ( to avoid interpolated strings coming from the server.\n    NSString *safeSubtitle = [subtitle stringByReplacingOccurrencesOfString:@\"\\\\(\" withString:@\"\\\\\\u200B(\"];\n    [self setSessionSpecificProfileValues:@{ KEY_SUBTITLE: safeSubtitle }];\n}\n\n- (void)enableSessionNameTitleComponentIfPossible {\n    // Turn on the session name component so the icon/trigger name will be visible.\n    iTermTitleComponents components = [iTermProfilePreferences unsignedIntegerForKey:KEY_TITLE_COMPONENTS\n                                                                           inProfile:self.profile];\n    if (components & iTermTitleComponentsCustom) {\n        return;\n    }\n    if (components & (iTermTitleComponentsSessionName | iTermTitleComponentsProfileAndSessionName)) {\n        return;\n    }\n    components |= iTermTitleComponentsSessionName;\n    [self setSessionSpecificProfileValues:@{ KEY_TITLE_COMPONENTS: @(components) }];\n\n}\n\n- (BOOL)screenWindowIsFullscreen {\n    return [[_delegate parentWindow] anyFullScreen];\n}\n\n- (void)screenMoveWindowTopLeftPointTo:(NSPoint)point {\n    NSRect screenFrame = [self screenWindowScreenFrame];\n    point.x += screenFrame.origin.x;\n    point.y = screenFrame.origin.y + screenFrame.size.height - point.y;\n    [[_delegate parentWindow] windowSetFrameTopLeftPoint:point];\n}\n\n- (NSRect)screenWindowScreenFrame {\n    return [[[_delegate parentWindow] windowScreen] visibleFrame];\n}\n\n- (NSRect)windowFrame {\n    NSRect frame = [self screenWindowFrame];\n    NSRect screenFrame = [self screenWindowScreenFrame];\n    return NSMakeRect(frame.origin.x - screenFrame.origin.x,\n                      (screenFrame.origin.y + screenFrame.size.height) - (frame.origin.y + frame.size.height),\n                      frame.size.width,\n                      frame.size.height);\n}\n\n- (VT100GridSize)theoreticalGridSize {\n    //  TODO: WTF do we do with panes here?\n    VT100GridSize result;\n    NSRect screenFrame = [self screenWindowScreenFrame];\n    NSRect windowFrame = [self screenWindowFrame];\n    NSSize cellSize = [self screenCellSize];\n    {\n        const CGFloat roomToGrow = screenFrame.size.height - windowFrame.size.height;\n        result.height = _screen.height + roomToGrow / cellSize.height;\n    }\n    {\n        const CGFloat roomToGrow = screenFrame.size.width - windowFrame.size.width;\n        result.width = _screen.width + roomToGrow / cellSize.width;\n    }\n    return result;\n}\n\n// If flag is set, miniaturize; otherwise, deminiaturize.\n- (void)screenMiniaturizeWindow:(BOOL)flag {\n    if (flag) {\n        [[_delegate parentWindow] windowPerformMiniaturize:nil];\n    } else {\n        [[_delegate parentWindow] windowDeminiaturize:nil];\n    }\n}\n\n// If flag is set, bring to front; if not, move to back.\n- (void)screenRaise:(BOOL)flag {\n    if (flag) {\n        [[_delegate parentWindow] windowOrderFront:nil];\n    } else {\n        [[_delegate parentWindow] windowOrderBack:nil];\n    }\n}\n\n// Sets current session proxy icon.\n- (void)screenSetPreferredProxyIcon:(NSString *)value {\n    NSURL *url = nil;\n    if (value) {\n        url = [NSURL URLWithString:value];\n    }\n    self.preferredProxyIcon = url;\n    [_delegate sessionProxyIconDidChange:self];\n}\n\n- (BOOL)screenWindowIsMiniaturized {\n    return [[_delegate parentWindow] windowIsMiniaturized];\n}\n\n- (void)screenSendReportData:(NSData *)data {\n    if (_shell == nil) {\n        return;\n    }\n    if (self.tmuxMode == TMUX_GATEWAY) {\n        // Prevent joining threads when writing the tmux message. Also, this doesn't make sense to do.\n        return;\n    }\n    [self writeLatin1EncodedData:data broadcastAllowed:NO reporting:YES];\n}\n\n- (void)screenDidSendAllPendingReports {\n    for (NSData *data in _dataQueue) {\n        DLog(@\"Send deferred write of %@\", [data stringWithEncoding:NSUTF8StringEncoding]);\n        [self writeData:data];\n    }\n    [_dataQueue removeAllObjects];\n}\n\n- (NSRect)screenWindowFrame {\n    return [[_delegate parentWindow] windowFrame];\n}\n\n- (NSSize)screenSize {\n    return [[[[[_delegate parentWindow] currentSession] view] scrollview] documentVisibleRect].size;\n}\n\n// If the flag is set, push the window title; otherwise push the icon title.\n- (void)screenPushCurrentTitleForWindow:(BOOL)flag {\n    if (flag) {\n        [self pushWindowTitle];\n    } else {\n        [self pushIconTitle];\n    }\n}\n\n// If the flag is set, pop the window title; otherwise pop the icon title.\n- (void)screenPopCurrentTitleForWindow:(BOOL)flag {\n    if (flag) {\n        [self popWindowTitle];\n    } else {\n        [self popIconTitle];\n    }\n}\n\n- (NSString *)screenName {\n    return [self name];\n}\n\n- (int)screenNumber {\n    return [_delegate tabNumber];\n}\n\n- (int)screenWindowIndex {\n    return [[iTermController sharedInstance] indexOfTerminal:(PseudoTerminal *)[_delegate realParentWindow]];\n}\n\n- (int)screenTabIndex {\n    return [_delegate number];\n}\n\n- (int)screenViewIndex {\n    return [[self view] viewId];\n}\n\n- (void)screenStartTmuxModeWithDCSIdentifier:(NSString *)dcsID {\n    [self startTmuxMode:dcsID];\n}\n\n- (void)screenHandleTmuxInput:(VT100Token *)token {\n    [_tmuxGateway executeToken:token];\n}\n\n- (BOOL)screenShouldTreatAmbiguousCharsAsDoubleWidth {\n    return [self treatAmbiguousWidthAsDoubleWidth];\n}\n\n- (void)screenPrintVisibleAreaIfAllowed {\n    if (![self shouldBeginPrinting:YES]) {\n        return;\n    }\n    // Cause mutableState to be copied to state so we print what the app thinks it's printing.\n    [_textview refresh];\n    [_textview print:nil];\n}\n\n- (BOOL)screenShouldSendContentsChangedNotification {\n    return [self wantsContentChangedNotification];\n}\n\n- (void)screenRemoveSelection {\n    [_textview deselect];\n}\n\n- (iTermSelection *)screenSelection {\n    return _textview.selection;\n}\n\n- (NSSize)screenCellSize {\n    return NSMakeSize([_textview charWidth], [_textview lineHeight]);\n}\n\n- (void)screenDidClearScrollbackBuffer {\n    [_delegate sessionDidClearScrollbackBuffer:self];\n}\n\n- (void)screenClearHighlights {\n    [_textview clearHighlights:NO];\n}\n\n- (void)screenMouseModeDidChange {\n    [_textview updateCursor:nil];\n    [self.view updateTrackingAreas];\n    [self.variablesScope setValue:@(_screen.terminalMouseMode)\n                 forVariableNamed:iTermVariableKeySessionMouseReportingMode];\n}\n\n- (void)screenFlashImage:(NSString *)identifier {\n    [_textview beginFlash:identifier];\n}\n\n- (void)incrementBadge {\n    [[_delegate realParentWindow] incrementBadge];\n}\n\n- (void)screenGetWorkingDirectoryWithCompletion:(void (^)(NSString *))completion {\n    DLog(@\"screenGetWorkingDirectoryWithCompletion\");\n    [_pwdPoller addOneTimeCompletion:completion];\n    [_pwdPoller poll];\n}\n\n- (void)screenSetCursorVisible:(BOOL)visible {\n    [_textview setCursorVisible:visible];\n}\n\n- (void)screenCursorDidMoveToLine:(int)line {\n    if (_textview.cursorVisible) {\n        [_textview setNeedsDisplayOnLine:line];\n    }\n}\n\n- (void)screenSetHighlightCursorLine:(BOOL)highlight {\n    [self internalSetHighlightCursorLine:highlight];\n}\n\n- (void)screenClearCapturedOutput {\n    [[NSNotificationCenter defaultCenter] postNotificationName:kPTYSessionCapturedOutputDidChange\n                                                        object:nil];\n}\n\n- (void)setHighlightCursorLine:(BOOL)highlight {\n    [self internalSetHighlightCursorLine:highlight];\n    _screen.trackCursorLineMovement = highlight;\n}\n\n- (void)internalSetHighlightCursorLine:(BOOL)highlight {\n    _cursorGuideSettingHasChanged = YES;\n    _textview.highlightCursorLine = highlight;\n    [_textview setNeedsDisplay:YES];\n}\n\n- (BOOL)highlightCursorLine {\n    return _textview.highlightCursorLine;\n}\n\n- (BOOL)screenHasView {\n    return _textview != nil;\n}\n\n- (void)revealIfTabSelected {\n    if (![self.delegate sessionIsInSelectedTab:self]) {\n        return;\n    }\n    [_delegate setActiveSession:self];\n    [self.delegate sessionDisableFocusFollowsMouseAtCurrentLocation];\n}\n\n- (void)reveal {\n    DLog(@\"Reveal session %@\", self);\n    if ([[[iTermBuriedSessions sharedInstance] buriedSessions] containsObject:self]) {\n        DLog(@\"disinter\");\n        [[iTermBuriedSessions sharedInstance] restoreSession:self];\n    }\n    NSWindowController<iTermWindowController> *terminal = [_delegate realParentWindow];\n    iTermController *controller = [iTermController sharedInstance];\n    BOOL okToActivateApp = YES;\n    if ([terminal isHotKeyWindow]) {\n        DLog(@\"Showing hotkey window\");\n        iTermProfileHotKey *hotKey = [[iTermHotKeyController sharedInstance] profileHotKeyForWindowController:(PseudoTerminal *)terminal];\n        [[iTermHotKeyController sharedInstance] showWindowForProfileHotKey:hotKey url:nil];\n        okToActivateApp = (hotKey.hotkeyWindowType != iTermHotkeyWindowTypeFloatingPanel);\n    } else {\n        DLog(@\"Making window current\");\n        [controller setCurrentTerminal:(PseudoTerminal *)terminal];\n        DLog(@\"Making window key and ordering front\");\n        [[terminal window] makeKeyAndOrderFront:self];\n        DLog(@\"Selecting tab from delegate %@\", _delegate);\n        [_delegate sessionSelectContainingTab];\n    }\n    if (okToActivateApp) {\n        DLog(@\"Activate the app\");\n        [[NSApplication sharedApplication] activateIgnoringOtherApps:YES];\n    }\n\n    DLog(@\"Make this session active in delegate %@\", _delegate);\n    [_delegate setActiveSessionPreservingMaximization:self];\n}\n\n- (void)makeActive {\n    [self.delegate sessionActivate:self];\n}\n\n- (void)screenDidAddMark:(id<iTermMark>)newMark alert:(BOOL)alert completion:(void (^)(void))completion {\n    if ([self markIsNavigable:newMark]) {\n        // currentMarkOrNotePosition is used for navigating next/previous\n        self.currentMarkOrNotePosition = newMark.entry.interval;\n    }\n    if (_commandQueue.count) {\n        NSString *command = [[[_commandQueue firstObject] retain] autorelease];\n        [_commandQueue removeObjectAtIndex:0];\n        [self sendCommand:command];\n    }\n    BOOL shouldAlert = alert;\n    if (!alert &&\n        [iTermPreferences boolForKey:kPreferenceKeyAlertOnMarksInOffscreenSessions] &&\n        !_temporarilySuspendOffscreenMarkAlerts) {\n        shouldAlert = ![self.delegate sessionIsInSelectedTab:self];\n    }\n    if (!shouldAlert) {\n        DLog(@\"Will enable offscreen mark alerts for %@\", self);\n        __weak __typeof(self) weakSelf = self;\n        dispatch_async(dispatch_get_main_queue(), ^{\n            DLog(@\"Actually enable offscreen mark alerts for %@\", weakSelf);\n            [weakSelf enableOffscreenMarkAlertsIfNeeded];\n        });\n        completion();\n        return;\n    }\n    DLog(@\"Alert for %@\", self);\n    self.alertOnNextMark = NO;\n    NSString *action = [iTermApplication.sharedApplication delegate].markAlertAction;\n    if ([action isEqualToString:kMarkAlertActionPostNotification]) {\n        [[iTermNotificationController sharedInstance] notify:@\"Mark Set\"\n                                             withDescription:[NSString stringWithFormat:@\"Session %@ #%d had a mark set.\",\n                                                              [[self name] removingHTMLFromTabTitleIfNeeded],\n                                                              [_delegate tabNumber]]\n                                                 windowIndex:[self screenWindowIndex]\n                                                    tabIndex:[self screenTabIndex]\n                                                   viewIndex:[self screenViewIndex]\n                                                      sticky:YES];\n        completion();\n        return;\n    }\n    // Dispatch so that we don't get a runloop in a side-effect, which can do weird re-entrant things.\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf showMarkSetAlert];\n        completion();\n    });\n}\n\n- (void)showMarkSetAlert {\n    NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n    alert.messageText = @\"Alert\";\n    alert.informativeText = [NSString stringWithFormat:@\"Mark set in session \u201c%@.\u201d\", [self name]];\n    [alert addButtonWithTitle:@\"Reveal\"];\n    [alert addButtonWithTitle:@\"OK\"];\n    if ([alert runModal] == NSAlertFirstButtonReturn) {\n        [self reveal];\n    }\n}\n\n- (void)screenPromptDidStartAtLine:(int)line {\n    [_pasteHelper unblock];\n}\n\n- (void)screenPromptDidEndWithMark:(id<VT100ScreenMarkReading>)mark {\n    _composerManager.haveShellProvidedText = NO;\n    [_promptSubscriptions enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n        if (obj.argumentsOneOfCase == ITMNotificationRequest_Arguments_OneOfCase_GPBUnsetOneOfCase ||\n            [obj.promptMonitorRequest.modesArray it_contains:ITMPromptMonitorMode_Prompt]) {\n            ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n            notification.promptNotification = [[[ITMPromptNotification alloc] init] autorelease];\n            notification.promptNotification.session = self.guid;\n            notification.promptNotification.prompt.placeholder = @\"\";\n            notification.promptNotification.prompt.prompt = [self getPromptResponseForMark:mark];\n            if (mark) {\n                notification.promptNotification.uniquePromptId = mark.guid;\n            }\n            [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                                 toConnectionKey:key];\n        }\n    }];\n    __weak __typeof(self) weakSelf = self;\n    // Can't just do it here because it may trigger a resize and this runs as a side-effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf updateAutoComposerFrame];\n    });\n}\n\n- (void)updateAutoComposerFrame {\n    if (_composerManager.dropDownComposerViewIsVisible && _composerManager.isAutoComposer) {\n        [_composerManager updateFrame];\n    }\n}\n\n// Save the current scroll position\n- (void)screenSaveScrollPosition {\n    [self saveScrollPositionWithName:nil];\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [_textview refresh];  // Handle scrollback overflow so we have the most recent scroll position\n        id<iTermMark> mark = [mutableState addMarkStartingAtAbsoluteLine:[_textview absoluteScrollPosition]\n                                                                 oneLine:NO\n                                                                 ofClass:[VT100ScreenMark class]];\n        self.currentMarkOrNotePosition = mark.doppelganger.entry.interval;\n    }];\n}\n\n- (void)saveScrollPositionWithName:(NSString *)name {\n    DLog(@\"saveScrollPositionWithName:%@\", name);\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [_textview refresh];  // Handle scrollback overflow so we have the most recent scroll position\n        id<iTermMark> mark = [mutableState addMarkStartingAtAbsoluteLine:[_textview absoluteScrollPosition]\n                                                                 oneLine:NO\n                                                                 ofClass:[VT100ScreenMark class]\n                                                                modifier:^(id<iTermMark> mark) {\n            VT100ScreenMark *screenMark = [VT100ScreenMark castFrom:mark];\n            screenMark.name = name;\n        }];\n        self.currentMarkOrNotePosition = mark.doppelganger.entry.interval;\n    }];\n}\n\n- (void)renameMark:(id<VT100ScreenMarkReading>)mark to:(NSString *)newName {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        VT100ScreenMark *screenMark = (VT100ScreenMark *)[mark progenitor];\n        if (!screenMark.entry.interval || !screenMark.name) {\n            return;\n        }\n        const VT100GridAbsCoordRange range = [mutableState absCoordRangeForInterval:screenMark.entry.interval];\n        [mutableState removeNamedMark:screenMark];\n        [mutableState addMarkStartingAtAbsoluteLine:range.start.y\n                                            oneLine:NO\n                                            ofClass:[VT100ScreenMark class]\n                                           modifier:^(id<iTermMark> mark) {\n            VT100ScreenMark *screenMark = [VT100ScreenMark castFrom:mark];\n            screenMark.name = newName;\n        }];\n    }];\n}\n- (void)screenStealFocus {\n    // Dispatch because you can't have a runloop in a side-effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self maybeStealFocus];\n    });\n}\n\n- (void)maybeStealFocus {\n    NSString *const identifier = @\"NoSyncAllowDenyStealFocus\";\n    const iTermWarningSelection selection =\n    [iTermWarning showWarningWithTitle:@\"A control sequence attempted to activate a session. Allow it?\"\n                               actions:@[ @\"Allow\", @\"Deny\" ]\n                             accessory:nil\n                            identifier:identifier\n                           silenceable:kiTermWarningTypePermanentlySilenceable\n                               heading:@\"Permission Required\"\n                                window:nil];\n    if (selection == kiTermWarningSelection0) {\n        [self reveal];\n    }\n}\n\n- (void)screenSetProfileToProfileNamed:(NSString *)value {\n    if (![self.naggingController terminalCanChangeProfile]) {\n        return;\n    }\n    Profile *newProfile;\n    if ([value length]) {\n        newProfile = [[ProfileModel sharedInstance] bookmarkWithName:value];\n    } else {\n        newProfile = [[ProfileModel sharedInstance] defaultBookmark];\n    }\n    if (newProfile) {\n        [self setProfile:newProfile preservingName:YES];\n    }\n}\n\n- (void)setProfile:(NSDictionary *)newProfile\n    preservingName:(BOOL)preservingName {\n    [self setProfile:newProfile preservingName:preservingName adjustWindow:YES];\n}\n\n- (void)setProfile:(NSDictionary *)newProfile\n    preservingName:(BOOL)preserveName\n      adjustWindow:(BOOL)adjustWindow {\n    DLog(@\"Set profile to\\n%@\", newProfile);\n    // Force triggers to be checked. We may be switching to a profile without triggers\n    // and we don't want them to run on the lines of text above _triggerLine later on\n    // when switching to a profile that does have triggers. See issue 7832.\n    [self syncCheckingTriggers:VT100ScreenTriggerCheckTypeFullLines];\n\n    NSString *theName = [[self profile] objectForKey:KEY_NAME];\n    NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithDictionary:newProfile];\n    if (preserveName) {\n        [dict setObject:theName forKey:KEY_NAME];\n    }\n\n    _windowAdjustmentDisabled = !adjustWindow;\n    [self setProfile:dict];\n    [self setPreferencesFromAddressBookEntry:dict];\n    _windowAdjustmentDisabled = NO;\n    [_originalProfile autorelease];\n    _originalProfile = [newProfile copy];\n    [self remarry];\n    if (preserveName) {\n        [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionProfileName: newProfile[KEY_NAME] ?: [NSNull null] }];\n        return;\n    }\n    [self profileDidChangeToProfileWithName:newProfile[KEY_NAME]];\n    DLog(@\"Done setting profile of %@\", self);\n}\n\n- (void)screenSetPasteboard:(NSString *)value {\n    if ([iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal]) {\n        if ([value isEqualToString:@\"ruler\"]) {\n            [self setPasteboard:NSPasteboardNameGeneral];\n        } else if ([value isEqualToString:@\"find\"]) {\n            [self setPasteboard:NSPasteboardNameFind];\n        } else if ([value isEqualToString:@\"font\"]) {\n            [self setPasteboard:NSPasteboardNameFont];\n        } else {\n            [self setPasteboard:NSPasteboardNameGeneral];\n        }\n    } else {\n        XLog(@\"Clipboard access denied for CopyToClipboard\");\n    }\n}\n\n- (void)screenDidAddNote:(id<PTYAnnotationReading>)note\n                   focus:(BOOL)focus\n                 visible:(BOOL)visible {\n    [_textview addViewForNote:note focus:focus visible:visible];\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (void)screenDidAddPorthole:(id<Porthole>)porthole {\n    [_textview addPorthole:porthole];\n}\n\n// Stop pasting (despite the name)\n- (void)screenCopyBufferToPasteboard {\n    if ([iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal]) {\n        [self setPasteboard:nil];\n    } else {\n        [_pasteboard release];\n        _pasteboard = nil;\n        [_pbtext release];\n        _pbtext = nil;\n    }\n}\n\n- (void)screenAppendDataToPasteboard:(NSData *)data {\n    if (_pasteboard == nil) {\n        return;\n    }\n    // Don't allow more than 100MB to be added to the pasteboard queue in case someone\n    // forgets to send the EndCopy command.\n    const int kMaxPasteboardBytes = 100 * 1024 * 1024;\n    if ([_pbtext length] + data.length > kMaxPasteboardBytes) {\n        [self setPasteboard:nil];\n    }\n\n    [_pbtext appendData:data];\n}\n\n- (void)screenWillReceiveFileNamed:(NSString *)filename ofSize:(NSInteger)size preconfirmed:(BOOL)preconfirmed {\n    [self.download stop];\n    [self.download endOfData];\n    self.download = [[[TerminalFileDownload alloc] initWithName:filename size:size] autorelease];\n    self.download.preconfirmed = preconfirmed;\n    [self.download download];\n}\n\n- (void)screenDidFinishReceivingFile {\n    [_naggingController didFinishDownload];\n    [self.download endOfData];\n    self.download = nil;\n}\n\n- (void)screenDidFinishReceivingInlineFile {\n    [_naggingController didFinishDownload];\n}\n\n- (void)screenDidReceiveBase64FileData:(NSString * _Nonnull)data\n                               confirm:(void (^ NS_NOESCAPE)(NSString *name,\n                                                             NSInteger lengthBefore,\n                                                             NSInteger lengthAfter))confirm {\n    const NSInteger lengthBefore = self.download.length;\n    if (self.download && ![self.download appendData:data]) {\n        iTermAnnouncementViewController *announcement =\n        [iTermAnnouncementViewController announcementWithTitle:@\"A file transfer was aborted for exceeding its declared size.\"\n                                                         style:kiTermAnnouncementViewStyleWarning\n                                                   withActions:@[ ]\n                                                    completion:^(int selection) {}];\n        [self queueAnnouncement:announcement identifier:@\"FileTransferAbortedOversize\"];\n\n        [self.download stop];\n        [self.download endOfData];\n        self.download = nil;\n        return;\n    }\n    if (!self.download.preconfirmed) {\n        const NSInteger lengthAfter = self.download.length;\n        confirm(self.download.shortName, lengthBefore, lengthAfter);\n    }\n}\n\n- (void)screenFileReceiptEndedUnexpectedly {\n    [self.download stop];\n    [self.download endOfData];\n    self.download = nil;\n}\n\n- (void)screenRequestUpload:(NSString *)args completion:(void (^)(void))completion {\n    // Dispatch out of fear that NSOpenPanel might do something funky with ruloops even though it doesn't seem to currently.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        NSArray<NSString *> *parts = [args componentsSeparatedByString:@\";\"];\n        NSDictionary<NSString *, NSString *> *dict = [parts keyValuePairsWithBlock:^iTermTuple *(NSString *object) {\n            return [object keyValuePair];\n        }];\n        [self requestUploadWithFormat:dict[@\"format\"] version:dict[@\"version\"]];\n        completion();\n    });\n}\n\n- (void)requestUploadWithFormat:(NSString *)format version:(NSString *)version {\n    if (format && ![format isEqualToString:@\"tgz\"]) {\n        NSString *identifier = @\"UploadInUnsupportedFormatRequested\";\n        if (![self announcementWithIdentifier:identifier]) {\n            iTermAnnouncementViewController *announcement =\n            [iTermAnnouncementViewController announcementWithTitle:@\"An upload with an unsupported archive format was requested. You may need a newer version of iTerm2.\"\n                                                             style:kiTermAnnouncementViewStyleWarning\n                                                       withActions:@[]\n                                                        completion:^(int selection) {}];\n            [self queueAnnouncement:announcement identifier:identifier];\n        }\n        return;\n    }\n    NSOpenPanel *panel = [NSOpenPanel openPanel];\n    panel.canChooseDirectories = YES;\n    panel.canChooseFiles = YES;\n    panel.allowsMultipleSelection = YES;\n\n    [NSApp activateIgnoringOtherApps:YES];\n    [panel beginSheetModalForWindow:_textview.window completionHandler:^(NSInteger result) {\n        if (result == NSModalResponseOK) {\n            [self writeTaskNoBroadcast:@\"ok\\n\" encoding:NSISOLatin1StringEncoding forceEncoding:YES reporting:NO];\n            NSFileManager *fileManager = [NSFileManager defaultManager];\n            // Get the directories for all the URLs. If a URL was a file, convert it to the containing directory, otherwise leave it alone.\n            __block BOOL anyFiles = NO;\n            NSArray<NSURL *> *directories = [panel.URLs mapWithBlock:^id(NSURL *anObject) {\n                BOOL isDirectory = NO;\n                if ([fileManager fileExistsAtPath:anObject.path isDirectory:&isDirectory]) {\n                    if (isDirectory) {\n                        return anObject;\n                    } else {\n                        anyFiles = YES;\n                        return [NSURL fileURLWithPath:[anObject.path stringByDeletingLastPathComponent]];\n                    }\n                } else {\n                    XLog(@\"Could not find %@\", anObject.path);\n                    return nil;\n                }\n            }];\n            NSString *base = [directories lowestCommonAncestorOfURLs].path;\n            if (!anyFiles && directories.count == 1) {\n                base = [base stringByDeletingLastPathComponent];\n            }\n            NSArray *baseComponents = [base pathComponents];\n            NSArray<NSString *> *relativePaths = [panel.URLs mapWithBlock:^id(NSURL *anObject) {\n                NSString *path = anObject.path;\n                NSArray<NSString *> *pathComponents = [path pathComponents];\n                NSArray<NSString *> *relativePathComponents = [pathComponents subarrayWithRange:NSMakeRange(baseComponents.count, pathComponents.count - baseComponents.count)];\n                NSString *relativePath = [relativePathComponents componentsJoinedByString:@\"/\"];\n                // Start every path with \"./\" to deal with filenames beginning with -.\n                return [@\".\" stringByAppendingPathComponent:relativePath];\n            }];\n            NSError *error = nil;\n            BOOL includeExtendedAttrs = YES;\n            if (version) {\n                NSString *versionString = [version stringByBase64DecodingStringWithEncoding:NSUTF8StringEncoding];\n                if ([versionString containsString:@\"tar (GNU tar)\"]) {\n                    includeExtendedAttrs = NO;\n                }\n            }\n            NSData *data = [NSData dataWithTGZContainingFiles:relativePaths\n                                               relativeToPath:base\n                                         includeExtendedAttrs:includeExtendedAttrs\n                                                        error:&error];\n            if (!data && error) {\n                NSString *message = error.userInfo[@\"errorMessage\"];\n                if (message) {\n                    NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n                    alert.messageText = @\"Error Preparing Upload\";\n                    alert.informativeText = [NSString stringWithFormat:@\"tar failed with this message: %@\", message];\n                    [alert runModal];\n                    return;\n                }\n            }\n            NSString *base64String = [data base64EncodedStringWithOptions:(NSDataBase64Encoding76CharacterLineLength |\n                                                                           NSDataBase64EncodingEndLineWithCarriageReturn)];\n            base64String = [base64String stringByAppendingString:@\"\\n\\n\"];\n            NSString *label;\n            if (relativePaths.count == 1) {\n                label = relativePaths.firstObject.lastPathComponent;\n            } else {\n                label = [NSString stringWithFormat:@\"%@ plus %ld more\", relativePaths.firstObject.lastPathComponent, relativePaths.count - 1];\n            }\n            const NSUInteger size = base64String.length;\n            self.upload = [[[TerminalFileUpload alloc] initWithName:label size:size] autorelease];\n            [self.upload upload];\n            [_pasteHelper pasteString:base64String\n                               slowly:NO\n                     escapeShellChars:NO\n                             isUpload:YES\n                      allowBracketing:YES\n                         tabTransform:kTabTransformNone\n                         spacesPerTab:0\n                             progress:^(NSInteger progress) {\n                DLog(@\"upload progress %@/%@\", @(progress), @(size));\n                [self.upload didUploadBytes:progress];\n                if (progress == size) {\n                    DLog(@\"Finished\");\n                    self.upload = nil;\n                }\n            }];\n        } else {\n            [self writeTaskNoBroadcast:@\"abort\\n\" encoding:NSISOLatin1StringEncoding forceEncoding:YES reporting:NO];\n        }\n    }];\n}\n\n- (void)setAlertOnNextMark:(BOOL)alertOnNextMark {\n    _alertOnNextMark = alertOnNextMark;\n    [_textview setNeedsDisplay:YES];\n    [self sync];\n}\n\n- (void)screenRequestAttention:(VT100AttentionRequestType)request {\n    switch (request) {\n        case VT100AttentionRequestTypeFireworks:\n            [_textview showFireworks];\n            break;\n        case VT100AttentionRequestTypeStopBouncingDockIcon:\n            [NSApp cancelUserAttentionRequest:_requestAttentionId];\n            break;\n        case VT100AttentionRequestTypeStartBouncingDockIcon:\n            _requestAttentionId =\n            [NSApp requestUserAttention:NSCriticalRequest];\n            break;\n        case VT100AttentionRequestTypeBounceOnceDockIcon:\n            [NSApp requestUserAttention:NSInformationalRequest];\n            break;\n        case VT100AttentionRequestTypeFlash:\n            [_textview.indicatorsHelper beginFlashingFullScreen];\n            break;\n    }\n}\n\n- (void)screenDidTryToUseDECRQCRA {\n    NSString *const userDefaultsKey = @\"NoSyncDisableDECRQCRA\";\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    NSNumber *obj = [NSNumber castFrom:[ud objectForKey:userDefaultsKey]];\n    if (obj) {\n        return;\n    }\n\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:@\"An app tried to read screen contents with DECRQCRA. Enable this feature?\"\n                                                     style:kiTermAnnouncementViewStyleQuestion\n                                               withActions:@[ @\"Yes\", @\"No\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case -2:  // Dismiss programmatically\n                break;\n\n            case -1: // Closed\n                break;\n\n            case 0: // Enable\n                [iTermAdvancedSettingsModel setNoSyncDisableDECRQCRA:NO];\n                break;\n\n            case 1: // Disable\n                [iTermAdvancedSettingsModel setNoSyncDisableDECRQCRA:YES];\n                break;\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:userDefaultsKey];\n}\n\n- (void)screenDisinterSession {\n    [[iTermBuriedSessions sharedInstance] restoreSession:self];\n}\n\n- (void)screenSetBackgroundImageFile:(NSString *)originalFilename {\n    NSString *const filename = [[originalFilename stringByBase64DecodingStringWithEncoding:NSUTF8StringEncoding] stringByTrimmingTrailingCharactersFromCharacterSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];\n    if (filename.length && ![[NSFileManager defaultManager] fileExistsAtPath:filename]) {\n        DLog(@\"file %@ does not exist\", filename);\n        return;\n    }\n    [self.naggingController setBackgroundImageToFileWithName:filename];\n}\n\n- (void)screenSetBadgeFormat:(NSString *)base64Format {\n    NSString *theFormat = [base64Format stringByBase64DecodingStringWithEncoding:self.encoding];\n    iTermParsedExpression *parsedExpression = [iTermExpressionParser parsedExpressionWithInterpolatedString:theFormat scope:self.variablesScope];\n    if ([parsedExpression containsAnyFunctionCall]) {\n        XLog(@\"Rejected control-sequence provided badge format containing function calls: %@\", theFormat);\n        [self showSimpleWarningAnnouncment:@\"The application attempted to set the badge to a value that would invoke a function call. For security reasons, this is not allowed and the badge was not updated.\"\n                                identifier:@\"UnsaveBadgeFormatRejected\"];\n        return;\n    }\n    if (theFormat) {\n        [self setSessionSpecificProfileValues:@{ KEY_BADGE_FORMAT: theFormat }];\n        _textview.badgeLabel = [self badgeLabel];\n    } else {\n        XLog(@\"Badge is not properly base64 encoded: %@\", base64Format);\n    }\n}\n\n- (void)screenSetUserVar:(NSString *)kvpString {\n    iTermTuple<NSString *, NSString *> *kvp = [kvpString keyValuePair];\n    if (kvp) {\n        if ([kvp.firstObject rangeOfString:@\".\"].location != NSNotFound) {\n            DLog(@\"key contains a ., which is not allowed. kvpString=%@\", kvpString);\n            return;\n        }\n        NSString *key = [NSString stringWithFormat:@\"user.%@\", kvp.firstObject];\n        NSString *value = [kvp.secondObject stringByBase64DecodingStringWithEncoding:NSUTF8StringEncoding];\n        [self.variablesScope setValue:value\n                     forVariableNamed:key];\n        if (self.isTmuxClient) {\n            [self.tmuxController setUserVariableWithKey:key\n                                                  value:value\n                                                   pane:self.tmuxPane];\n        }\n    } else {\n        if ([kvpString rangeOfString:@\".\"].location != NSNotFound) {\n            DLog(@\"key contains a ., which is not allowed. key=%@\", kvpString);\n            return;\n        }\n        NSString *key = [NSString stringWithFormat:@\"user.%@\", kvpString];\n        [self.variablesScope setValue:nil forVariableNamed:[NSString stringWithFormat:@\"user.%@\", kvpString]];\n        if (self.isTmuxClient) {\n            [self.tmuxController setUserVariableWithKey:key\n                                                  value:nil\n                                                   pane:self.tmuxPane];\n        }\n    }\n}\n\n- (void)setVariableNamed:(NSString *)name toValue:(id)newValue {\n    [self.variablesScope setValue:newValue forVariableNamed:name];\n}\n\n- (void)injectData:(NSData *)data {\n    [self.screen injectData:data];\n}\n\n// indexes will be in [0,255].\n// 0-7 are ansi colors,\n// 8-15 are ansi bright colors,\n// 16-255 are 256 color-mode colors.\n// If empty, reset all.\n- (NSDictionary<NSNumber *, id> *)screenResetColorWithColorMapKey:(int)key\n                                                       profileKey:(NSString *)profileKey\n                                                             dark:(BOOL)dark {\n    DLog(@\"key=%d profileKey=%@ dark=%d\", key, profileKey, dark);\n    return [self resetColorWithKey:key\n                       fromProfile:_originalProfile\n                        profileKey:profileKey\n                              dark:dark];\n}\n\n- (BOOL)screenSetColor:(NSColor *)color profileKey:(NSString *)profileKey {\n    if (!color) {\n        return NO;\n    }\n\n    if (profileKey) {\n        [self setSessionSpecificProfileValues:@{ profileKey: [color dictionaryValue] }];\n        return NO;\n    }\n    return YES;\n}\n\n- (void)screenSelectColorPresetNamed:(NSString *)name {\n    [self setColorsFromPresetNamed:name];\n}\n\n- (void)screenSetCurrentTabColor:(NSColor *)color {\n    [self setTabColor:color];\n    id<WindowControllerInterface> term = [_delegate parentWindow];\n    [term updateTabColors];\n}\n\n- (NSColor *)tabColor {\n    return [self tabColorInProfile:_profile];\n}\n\n- (void)setTabColor:(NSColor *)color {\n    NSDictionary *dict;\n    if (color) {\n        dict = @{ [self amendedColorKey:KEY_USE_TAB_COLOR]: @YES,\n                  [self amendedColorKey:KEY_TAB_COLOR]: [ITAddressBookMgr encodeColor:color] };\n    } else {\n        dict = @{ [self amendedColorKey:KEY_USE_TAB_COLOR]: @NO };\n    }\n\n    [self setSessionSpecificProfileValues:dict];\n}\n\n- (void)screenSetTabColorRedComponentTo:(CGFloat)color {\n    NSColor *curColor = [self tabColor] ?: [NSColor it_colorInDefaultColorSpaceWithRed:0 green:0 blue:0 alpha:0];\n    [self setTabColor:[curColor it_colorWithRed:color\n                                          green:curColor.greenComponent\n                                           blue:curColor.blueComponent\n                                          alpha:1]];\n    [[_delegate parentWindow] updateTabColors];\n}\n\n- (void)screenSetTabColorGreenComponentTo:(CGFloat)color {\n    NSColor *curColor = [self tabColor] ?: [NSColor it_colorInDefaultColorSpaceWithRed:0 green:0 blue:0 alpha:0];\n    [self setTabColor:[curColor it_colorWithRed:curColor.redComponent\n                                          green:color\n                                           blue:curColor.blueComponent\n                                          alpha:1]];\n    [[_delegate parentWindow] updateTabColors];\n}\n\n- (void)screenSetTabColorBlueComponentTo:(CGFloat)color {\n    NSColor *curColor = [self tabColor] ?: [NSColor it_colorInDefaultColorSpaceWithRed:0 green:0 blue:0 alpha:0];\n    [self setTabColor:[curColor it_colorWithRed:curColor.redComponent\n                                          green:curColor.greenComponent\n                                           blue:color\n                                          alpha:1]];\n    [[_delegate parentWindow] updateTabColors];\n}\n\n- (void)screenCurrentHostDidChange:(id<VT100RemoteHostReading>)host\n                               pwd:(NSString *)workingDirectory\n                               ssh:(BOOL)ssh {\n    DLog(@\"Current host did change to %@, pwd=%@, ssh=%@. %@\", host, workingDirectory, @(ssh), self);\n    NSString *previousHostName = _currentHost.hostname;\n\n    NSNull *null = [NSNull null];\n    NSDictionary *variablesUpdate = @{ iTermVariableKeySessionHostname: host.hostname ?: null,\n                                       iTermVariableKeySessionUsername: host.username ?: null };\n    [self.variablesScope setValuesFromDictionary:variablesUpdate];\n\n    [_textview setBadgeLabel:[self badgeLabel]];\n    [self dismissAnnouncementWithIdentifier:kShellIntegrationOutOfDateAnnouncementIdentifier];\n\n    [[_delegate realParentWindow] sessionHostDidChange:self to:host];\n\n    [self tryAutoProfileSwitchWithHostname:host.hostname\n                                  username:host.username\n                                      path:workingDirectory\n                                       job:self.variablesScope.jobName];\n\n    // Ignore changes to username; only update on hostname changes. See issue 8030.\n    if (previousHostName && ![previousHostName isEqualToString:host.hostname] && !ssh) {\n        [self maybeResetTerminalStateOnHostChange:host];\n    }\n    self.currentHost = host;\n    [self updateVariablesFromConductor];\n}\n\n- (BOOL)shellIsFishForHost:(id<VT100RemoteHostReading>)host {\n    NSString *name = host.usernameAndHostname;\n    if (!name) {\n        return NO;\n    }\n    return [self.hostnameToShell[name] isEqualToString:@\"fish\"];\n}\n\n- (void)maybeResetTerminalStateOnHostChange:(id<VT100RemoteHostReading>)newRemoteHost {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        if (_xtermMouseReporting && terminal.mouseMode != MOUSE_REPORTING_NONE) {\n            NSNumber *number = [[NSUserDefaults standardUserDefaults] objectForKey:kTurnOffMouseReportingOnHostChangeUserDefaultsKey];\n            if ([number boolValue]) {\n                terminal.mouseMode = MOUSE_REPORTING_NONE;\n            } else if (!number) {\n                [self offerToTurnOffMouseReportingOnHostChange];\n            }\n        }\n        if (terminal.reportFocus) {\n            NSNumber *number = [[NSUserDefaults standardUserDefaults] objectForKey:kTurnOffFocusReportingOnHostChangeUserDefaultsKey];\n            if ([number boolValue]) {\n                terminal.reportFocus = NO;\n            } else if (!number) {\n                [self offerToTurnOffFocusReporting];\n            }\n        }\n        if (terminal.bracketedPasteMode && ![self shellIsFishForHost:newRemoteHost]) {\n            [self maybeTurnOffPasteBracketing];\n        }\n    }];\n}\n\n- (NSArray<iTermCommandHistoryCommandUseMO *> *)commandUses {\n    return [[iTermShellHistoryController sharedInstance] commandUsesForHost:self.currentHost];\n}\n\n- (iTermQuickLookController *)quickLookController {\n    return _textview.quickLookController;\n}\n\n- (void)showSimpleWarningAnnouncment:(NSString *)message\n                          identifier:(NSString *)identifier {\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:message\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"OK\" ]\n                                                completion:^(int selection) {}];\n    [self queueAnnouncement:announcement identifier:identifier];\n}\n\n- (void)offerToTurnOffMouseReportingOnHostChange {\n    if ([self hasAnnouncementWithIdentifier:kTurnOffMouseReportingOnHostChangeAnnouncementIdentifier]) {\n        return;\n    }\n    NSString *title =\n    @\"Looks like mouse reporting was left on when an ssh session ended unexpectedly or an app misbehaved. Turn it off?\";\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:title\n                                                     style:kiTermAnnouncementViewStyleQuestion\n                                               withActions:@[ @\"_Yes\", @\"Always\", @\"Never\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case -2:  // Dismiss programmatically\n                break;\n\n            case -1: // No\n                break;\n\n            case 0: // Yes\n                [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                         VT100ScreenMutableState *mutableState,\n                                                         id<VT100ScreenDelegate> delegate) {\n                    terminal.mouseMode = MOUSE_REPORTING_NONE;\n                }];\n                break;\n\n            case 1: // Always\n                [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                        forKey:kTurnOffMouseReportingOnHostChangeUserDefaultsKey];\n                [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                         VT100ScreenMutableState *mutableState,\n                                                         id<VT100ScreenDelegate> delegate) {\n                    terminal.mouseMode = MOUSE_REPORTING_NONE;\n                }];\n                break;\n\n            case 2: // Never\n                [[NSUserDefaults standardUserDefaults] setBool:NO\n                                                        forKey:kTurnOffMouseReportingOnHostChangeUserDefaultsKey];\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:kTurnOffMouseReportingOnHostChangeAnnouncementIdentifier];\n}\n\n- (void)offerToTurnOffFocusReporting {\n    NSString *title =\n    @\"Looks like focus reporting was left on when an ssh session ended unexpectedly or an app misbehaved. Turn it off?\";\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:title\n                                                     style:kiTermAnnouncementViewStyleQuestion\n                                               withActions:@[ @\"_Yes\", @\"Always\", @\"Never\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case -2:  // Dismiss programmatically\n                break;\n\n            case -1: // No\n                break;\n\n            case 0: // Yes\n                [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                         VT100ScreenMutableState *mutableState,\n                                                         id<VT100ScreenDelegate> delegate) {\n                    terminal.reportFocus = NO;\n                }];\n                break;\n\n            case 1: // Always\n                [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                        forKey:kTurnOffFocusReportingOnHostChangeUserDefaultsKey];\n                [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                         VT100ScreenMutableState *mutableState,\n                                                         id<VT100ScreenDelegate> delegate) {\n                    terminal.reportFocus = NO;\n                }];\n                break;\n\n            case 2: // Never\n                [[NSUserDefaults standardUserDefaults] setBool:NO\n                                                        forKey:kTurnOffFocusReportingOnHostChangeUserDefaultsKey];\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:kTurnOffFocusReportingOnHostChangeAnnouncementIdentifier];\n}\n\n- (void)offerToTurnOffBracketedPasteOnHostChange {\n    [self.naggingController offerToTurnOffBracketedPasteOnHostChange];\n}\n\n- (void)tryAutoProfileSwitchWithHostname:(NSString *)hostname\n                                username:(NSString *)username\n                                    path:(NSString *)path\n                                     job:(NSString *)job {\n    if ([iTermProfilePreferences boolForKey:KEY_PREVENT_APS inProfile:self.profile]) {\n        return;\n    }\n    [_automaticProfileSwitcher setHostname:hostname username:username path:path job:job];\n}\n\n// This is called when we get a high-confidence working directory (e.g., CurrentDir=).\n- (void)screenCurrentDirectoryDidChangeTo:(NSString *)newPath\n                               remoteHost:(id<VT100RemoteHostReading> _Nullable)remoteHost {\n    DLog(@\"%@\\n%@\", newPath, [NSThread callStackSymbols]);\n    [self didUpdateCurrentDirectory:newPath];\n    [self.variablesScope setValue:newPath forVariableNamed:iTermVariableKeySessionPath];\n\n    [self tryAutoProfileSwitchWithHostname:remoteHost.hostname\n                                  username:remoteHost.username\n                                      path:newPath\n                                       job:self.variablesScope.jobName];\n    [self.variablesScope setValue:newPath forVariableNamed:iTermVariableKeySessionPath];\n    [_pwdPoller invalidateOutstandingRequests];\n    _workingDirectoryPollerDisabled = YES;\n}\n\n- (void)screenDidReceiveCustomEscapeSequenceWithParameters:(NSDictionary<NSString *, NSString *> *)parameters\n                                                   payload:(NSString *)payload {\n    ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n    notification.customEscapeSequenceNotification = [[[ITMCustomEscapeSequenceNotification alloc] init] autorelease];\n    notification.customEscapeSequenceNotification.session = self.guid;\n    notification.customEscapeSequenceNotification.senderIdentity = parameters[@\"id\"];\n    notification.customEscapeSequenceNotification.payload = payload;\n    [_customEscapeSequenceNotifications enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n        [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                             toConnectionKey:key];\n    }];\n}\n\n- (iTermNaggingController *)naggingController {\n    if (!_naggingController) {\n        _naggingController = [[iTermNaggingController alloc] init];\n        _naggingController.delegate = self;\n    }\n    return _naggingController;\n}\n\n- (void)screenReportVariableNamed:(NSString *)name {\n    if (self.isTmuxClient) {\n        return;\n    }\n    NSString *value = nil;\n    if ([self.naggingController permissionToReportVariableNamed:name]) {\n        value = [self stringValueOfVariable:name];\n    }\n    NSData *data = [_screen.terminalOutput reportVariableNamed:name\n                                                         value:value];\n    [self screenSendReportData:data];\n}\n\n- (void)screenReportCapabilities {\n    if (self.isTmuxClient) {\n        return;\n    }\n    const BOOL clipboardAccessAllowed = [iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal];\n    VT100Capabilities capabilities =\n    VT100OutputMakeCapabilities(YES,                                // compatibility24Bit\n                                YES,                                // full24Bit\n                                clipboardAccessAllowed,             // clipboardWritable\n                                YES,                                // decslrm\n                                YES,                                // mouse\n                                YES,                                // DECSCUSR14\n                                YES,                                // DECSCUSR56\n                                YES,                                // DECSCUSR0\n                                YES,                                // unicode\n                                _treatAmbiguousWidthAsDoubleWidth,  // ambiguousWide\n                                _unicodeVersion,                    // unicodeVersion\n                                YES,                                // titleStacks\n                                YES,                                // titleSetting\n                                YES,                                // bracketedPaste\n                                YES,                                // focusReporting\n                                YES,                                // strikethrough\n                                NO,                                 // overline\n                                YES,                                // sync\n                                YES,                                // hyperlinks\n                                YES,                                // notifications\n                                YES,                                // sixel\n                                YES);                               // file\n    NSData *data = [_screen.terminalOutput reportCapabilities:capabilities];\n    [self screenSendReportData:data];\n}\n\n- (VT100GridRange)screenRangeOfVisibleLines {\n    return [_textview rangeOfVisibleLines];\n}\n\n#pragma mark - FinalTerm\n\n- (NSString *)commandInRange:(VT100GridCoordRange)range {\n    return [_screen commandInRange:range];\n}\n\n- (NSString *)currentCommand {\n    if (_screen.commandRange.start.x < 0) {\n        return nil;\n    } else {\n        return [_screen commandInRange:_screen.commandRange];\n    }\n}\n\n- (BOOL)eligibleForAutoCommandHistory {\n    if (!_textview.cursorVisible) {\n        return NO;\n    }\n    VT100GridCoord coord = _screen.commandRange.end;\n    coord.y -= _screen.numberOfScrollbackLines;\n    if (!VT100GridCoordEquals(_screen.currentGrid.cursor, coord)) {\n        return NO;\n    }\n\n    const screen_char_t c = [_screen.currentGrid characterAt:coord];\n    return c.code == 0;\n}\n\n- (NSArray *)autocompleteSuggestionsForCurrentCommand {\n    DLog(@\"begin\");\n    NSString *command;\n    if (_screen.commandRange.start.x < 0) {\n        DLog(@\"no command range\");\n        return nil;\n    }\n    command = [_screen commandInRange:_screen.commandRange];\n    id<VT100RemoteHostReading> host = [_screen remoteHostOnLine:[_screen numberOfLines]];\n    DLog(@\"command=%@ host=%@\", command, host);\n\n    NSString *trimmedCommand =\n    [command stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];\n    return [[iTermShellHistoryController sharedInstance] commandHistoryEntriesWithPrefix:trimmedCommand\n                                                                                  onHost:host];\n}\n\n- (void)screenCommandDidChangeTo:(NSString *)command\n                        atPrompt:(BOOL)atPrompt\n                      hadCommand:(BOOL)hadCommand\n                     haveCommand:(BOOL)haveCommand {\n    DLog(@\"FinalTerm: command=%@ atPropt=%@ hadCommand=%@ haveCommand=%@\",\n         command, @(atPrompt), @(hadCommand), @(haveCommand));\n    if (!haveCommand && hadCommand) {\n        DLog(@\"ACH Hide because don't have a command, but just had one\");\n        [[_delegate realParentWindow] hideAutoCommandHistoryForSession:self];\n        return;\n    }\n    if (!hadCommand && atPrompt) {\n        DLog(@\"ACH Show because I have a range but didn't have a command\");\n        [[_delegate realParentWindow] showAutoCommandHistoryForSession:self];\n    }\n    if ([[_delegate realParentWindow] wantsCommandHistoryUpdatesFromSession:self]) {\n        DLog(@\"ACH Update command to %@\", command);\n        if (haveCommand && self.eligibleForAutoCommandHistory) {\n            [[_delegate realParentWindow] updateAutoCommandHistoryForPrefix:command\n                                                                  inSession:self\n                                                                popIfNeeded:NO];\n        }\n    }\n}\n\n- (void)screenDidExecuteCommand:(NSString *)command\n                          range:(VT100GridCoordRange)range\n                         onHost:(id<VT100RemoteHostReading>)host\n                    inDirectory:(NSString *)directory\n                           mark:(id<VT100ScreenMarkReading>)mark {\n    NSString *trimmedCommand =\n    [command stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];\n    if (trimmedCommand.length) {\n        [[iTermShellHistoryController sharedInstance] addCommand:trimmedCommand\n                                                          onHost:host\n                                                     inDirectory:directory\n                                                        withMark:mark];\n        [_commands addObject:trimmedCommand];\n        [self trimCommandsIfNeeded];\n    }\n    self.lastCommand = command;\n    [self.variablesScope setValue:command forVariableNamed:iTermVariableKeySessionLastCommand];\n\n    // `_screen.commandRange` is from the beginning of command, to the cursor, not necessarily the end of the command.\n    // `range` here includes the entire command and a new line.\n    _lastOrCurrentlyRunningCommandAbsRange = VT100GridAbsCoordRangeFromCoordRange(range, _screen.totalScrollbackOverflow);\n    DLog(@\"Hide ACH because command ended\");\n    [[_delegate realParentWindow] hideAutoCommandHistoryForSession:self];\n    [_promptSubscriptions enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n        if ([obj.promptMonitorRequest.modesArray it_contains:ITMPromptMonitorMode_CommandStart]) {\n            ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n            notification.promptNotification = [[[ITMPromptNotification alloc] init] autorelease];\n            notification.promptNotification.session = self.guid;\n            notification.promptNotification.commandStart.command = command;\n            if (mark) {\n                notification.promptNotification.uniquePromptId = mark.guid;\n            }\n            [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                                 toConnectionKey:key];\n        }\n    }];\n\n    [_composerManager reset];\n}\n\n- (void)screenCommandDidExitWithCode:(int)code mark:(id<VT100ScreenMarkReading>)maybeMark {\n    [_promptSubscriptions enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n        if ([obj.promptMonitorRequest.modesArray it_contains:ITMPromptMonitorMode_CommandEnd]) {\n            ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n            notification.promptNotification = [[[ITMPromptNotification alloc] init] autorelease];\n            notification.promptNotification.session = self.guid;\n            notification.promptNotification.commandEnd.status = code;\n            if (maybeMark) {\n                notification.promptNotification.uniquePromptId = maybeMark.guid;\n            }\n            [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                                 toConnectionKey:key];\n        }\n    }];\n}\n\n- (void)updateConfigurationFields {\n    BOOL dirty = NO;\n    if (![NSObject object:_config.sessionGuid isEqualToObject:_guid]) {\n        _config.sessionGuid = _guid;\n        dirty = YES;\n    }\n\n    const BOOL treatAmbiguousCharsAsDoubleWidth = [self treatAmbiguousWidthAsDoubleWidth];\n    if (_config.treatAmbiguousCharsAsDoubleWidth != treatAmbiguousCharsAsDoubleWidth) {\n        _config.treatAmbiguousCharsAsDoubleWidth = treatAmbiguousCharsAsDoubleWidth;\n        dirty = YES;\n    }\n\n    if (_config.unicodeVersion != _unicodeVersion) {\n        _config.unicodeVersion = _unicodeVersion;\n        dirty = YES;\n    }\n    if (_config.isTmuxClient != self.isTmuxClient) {\n        _config.isTmuxClient = self.isTmuxClient;\n        dirty = YES;\n    }\n    const BOOL printingAllowed = [self shouldBeginPrinting:NO];\n    if (printingAllowed != _config.printingAllowed) {\n        _config.printingAllowed = printingAllowed;\n        dirty = YES;\n    }\n    const BOOL clipboardAccessAllowed = [iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal];\n    if (clipboardAccessAllowed != _config.clipboardAccessAllowed) {\n        _config.clipboardAccessAllowed = clipboardAccessAllowed;\n        dirty = YES;\n    }\n    const BOOL miniaturized = [[_delegate parentWindow] windowIsMiniaturized];\n    if (miniaturized != _config.miniaturized) {\n        _config.miniaturized = miniaturized;\n        dirty = YES;\n    }\n    const NSRect windowFrame = [self windowFrame];\n    if (!NSEqualRects(windowFrame, _config.windowFrame)) {\n        _config.windowFrame = windowFrame;\n        dirty = YES;\n    }\n    const VT100GridSize theoreticalGridSize = [self theoreticalGridSize];\n    if (!VT100GridSizeEquals(theoreticalGridSize, _config.theoreticalGridSize)) {\n        _config.theoreticalGridSize = theoreticalGridSize;\n        dirty = YES;\n    }\n    NSString *iconTitle = [self screenIconTitle];\n    if (![NSObject object:iconTitle isEqualToObject:_config.iconTitle]) {\n        _config.iconTitle = iconTitle;\n        dirty = YES;\n    }\n    NSString *windowTitle = [self screenWindowTitle];\n    if (![NSObject object:windowTitle isEqualToObject:_config.windowTitle]) {\n        _config.windowTitle = windowTitle;\n        dirty = YES;\n    }\n    const BOOL clearScrollbackAllowed = [self clearScrollbackAllowed];\n    if (clearScrollbackAllowed != _config.clearScrollbackAllowed) {\n        _config.clearScrollbackAllowed = clearScrollbackAllowed;\n        dirty = YES;\n    }\n    const NSSize cellSize = NSMakeSize([_textview charWidth], [_textview lineHeight]);\n    if (!NSEqualSizes(cellSize, _config.cellSize)) {\n        _config.cellSize = cellSize;\n        dirty = YES;\n    }\n    const CGFloat backingScaleFactor = _view.window.screen.backingScaleFactor;\n    if (backingScaleFactor != _config.backingScaleFactor) {\n        _config.backingScaleFactor = backingScaleFactor;\n        dirty = YES;\n    }\n    if (!_config.maximumTheoreticalImageDimension) {\n        _config.maximumTheoreticalImageDimension = PTYSessionMaximumMetalViewSize;\n        dirty = YES;\n    }\n    const BOOL dimOnlyText = [iTermPreferences boolForKey:kPreferenceKeyDimOnlyText];\n    if (_config.dimOnlyText != dimOnlyText) {\n        _config.dimOnlyText = dimOnlyText;\n        dirty = YES;\n    }\n    const BOOL darkMode = (self.view.effectiveAppearance ?: [NSApp effectiveAppearance]).it_isDark;\n    if (_config.darkMode != darkMode) {\n        _config.darkMode = darkMode;\n        dirty = YES;\n    }\n    const BOOL loggingEnabled = _logging.enabled;\n    if (_config.loggingEnabled != loggingEnabled) {\n        _config.loggingEnabled = loggingEnabled;\n        dirty = YES;\n    }\n    NSDictionary *stringForKeypressConfig = [self stringForKeypressConfig];\n    if (![_config.stringForKeypressConfig isEqual:stringForKeypressConfig]) {\n        _config.stringForKeypressConfig = stringForKeypressConfig;\n        _config.stringForKeypress = [self stringForKeypress];\n        dirty = YES;\n    }\n    const BOOL compoundAlertOnNextMark = [self shouldAlert];\n    if (compoundAlertOnNextMark != _config.alertOnNextMark) {\n        _config.alertOnNextMark = compoundAlertOnNextMark;\n        dirty = YES;\n    }\n    const double dimmingAmount = _view.adjustedDimmingAmount;\n    if (_config.dimmingAmount != dimmingAmount) {\n        _config.dimmingAmount = dimmingAmount;\n        dirty = YES;\n    }\n\n    const BOOL publishing = (self.contentSubscribers.count > 0);\n    if (_config.publishing != publishing) {\n        _config.publishing = publishing;\n        dirty = YES;\n    }\n    if (_profileDidChange) {\n        _config.shouldPlacePromptAtFirstColumn = [iTermProfilePreferences boolForKey:KEY_PLACE_PROMPT_AT_FIRST_COLUMN\n                                                                           inProfile:_profile];\n        _config.enableTriggersInInteractiveApps = [iTermProfilePreferences boolForKey:KEY_ENABLE_TRIGGERS_IN_INTERACTIVE_APPS\n                                                                            inProfile:self.profile];\n        _config.triggerParametersUseInterpolatedStrings = [iTermProfilePreferences boolForKey:KEY_TRIGGERS_USE_INTERPOLATED_STRINGS\n                                                                                    inProfile:self.profile];\n        _config.triggerProfileDicts = [iTermProfilePreferences objectForKey:KEY_TRIGGERS inProfile:self.profile];\n        _config.useSeparateColorsForLightAndDarkMode = [iTermProfilePreferences boolForKey:KEY_USE_SEPARATE_COLORS_FOR_LIGHT_AND_DARK_MODE\n                                                                                 inProfile:self.profile];\n        DLog(@\"Set min contrast in config to %f using key %@\",\n             [iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, self.profile, darkMode)\n                                        inProfile:self.profile],\n             iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, self.profile, darkMode));\n        _config.minimumContrast = [iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, self.profile, darkMode)\n                                                             inProfile:self.profile];\n        _config.faintTextAlpha = [iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_FAINT_TEXT_ALPHA, self.profile, darkMode)\n                                                            inProfile:self.profile];\n        _config.mutingAmount = [iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_CURSOR_BOOST, self.profile, darkMode)\n                                                          inProfile:self.profile];\n        _config.normalization = [iTermProfilePreferences integerForKey:KEY_UNICODE_NORMALIZATION\n                                                             inProfile:self.profile];\n        _config.appendToScrollbackWithStatusBar = [iTermProfilePreferences boolForKey:KEY_SCROLLBACK_WITH_STATUS_BAR\n                                                                            inProfile:self.profile];\n        _config.saveToScrollbackInAlternateScreen = [iTermProfilePreferences boolForKey:KEY_SCROLLBACK_IN_ALTERNATE_SCREEN\n                                                                              inProfile:self.profile];\n        _config.unlimitedScrollback = [iTermProfilePreferences boolForKey:KEY_UNLIMITED_SCROLLBACK\n                                                                inProfile:_profile];\n        _config.reduceFlicker = [iTermProfilePreferences boolForKey:KEY_REDUCE_FLICKER inProfile:self.profile];\n        _config.maxScrollbackLines = [iTermProfilePreferences intForKey:KEY_SCROLLBACK_LINES\n                                                              inProfile:self.profile];\n        _config.profileName = [self profileName];\n        _config.terminalCanChangeBlink = [iTermProfilePreferences boolForKey:KEY_ALLOW_CHANGE_CURSOR_BLINK inProfile:self.profile];\n\n        dirty = YES;\n        _profileDidChange = NO;\n    }\n\n    NSNumber *desiredComposerRows = nil;\n    if ([iTermPreferences boolForKey:kPreferenceAutoComposer] && _promptStateAllowsAutoComposer) {\n        const int desiredRows = MAX(1, _composerManager.desiredHeight / _textview.lineHeight);\n        desiredComposerRows = @(desiredRows);\n    }\n    if (![NSObject object:desiredComposerRows isEqualToObject:_config.desiredComposerRows]) {\n        _config.desiredComposerRows = desiredComposerRows;\n        dirty = YES;\n    }\n    const BOOL useLineStyleMarks = [iTermPreferences boolForKey:kPreferenceAutoComposer];\n    if (useLineStyleMarks != _config.useLineStyleMarks) {\n        _config.useLineStyleMarks = useLineStyleMarks;\n        dirty = YES;\n    }\n\n    const BOOL autoComposerEnabled = [iTermPreferences boolForKey:kPreferenceAutoComposer];\n    if (_config.autoComposerEnabled != autoComposerEnabled) {\n        _config.autoComposerEnabled = autoComposerEnabled;\n        dirty = YES;\n    }\n\n    if (dirty) {\n        _config.isDirty = dirty;\n    }\n}\n\n- (BOOL)shouldAlert {\n    if (self.alertOnNextMark) {\n        DLog(@\"self.alertOnNextMark -> YES\");\n        return YES;\n    }\n    if (!_alertOnMarksinOffscreenSessions) {\n        DLog(@\"!_alertOnMarksinOffscreenSessions -> NO\");\n        return NO;\n    }\n    if (_temporarilySuspendOffscreenMarkAlerts) {\n        DLog(@\"_temporarilySuspendOffscreenMarkAlerts -> NO\");\n        return NO;\n    }\n    if ([self.delegate hasMaximizedPane] && ![self.delegate sessionIsActiveInTab:self]) {\n        DLog(@\"hasMaximizedPane && !sessionIsActiveInTab -> YES\");\n        return YES;\n    }\n    if (!self.view.window.isVisible ||\n        self.view.window.isMiniaturized ||\n        ![self.view.window isOnActiveSpace] ||\n        ![self.delegate sessionIsInSelectedTab:self]) {\n        DLog(@\"offscreen -> YES\");\n        return YES;\n    }\n    DLog(@\"Otherwise -> NO\");\n    return NO;\n}\n\n// As long as this is constant, stringForKeypress will return the same value.\n- (NSDictionary *)stringForKeypressConfig {\n    return _textview.keyboardHandler.dictionaryValue ?: @{};\n}\n\n- (NSDictionary *)stringForKeypress {\n    id (^stringForKeypress)(unsigned short, NSEventModifierFlags, NSString *, NSString *) =\n    ^id(unsigned short keyCode,\n        NSEventModifierFlags flags,\n        NSString *characters,\n        NSString *charactersIgnoringModifiers) {\n        return [self stringForKeyCode:keyCode\n                                flags:flags\n                           characters:characters\n          charactersIgnoringModifiers:charactersIgnoringModifiers] ?: [NSNull null];\n    };\n    NSString *(^c)(UTF32Char c) = ^NSString *(UTF32Char c) {\n        return [NSString stringWithLongCharacter:c];\n    };\n    return @{\n        @(kDcsTermcapTerminfoRequestKey_kb):  stringForKeypress(kVK_Delete, 0, @\"\\x7f\", @\"\\x7f\"),\n        @(kDcsTermcapTerminfoRequestKey_kD):  stringForKeypress(kVK_ForwardDelete, NSEventModifierFlagFunction, c(NSDeleteFunctionKey), c(NSDeleteFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kd):  stringForKeypress(kVK_DownArrow, NSEventModifierFlagFunction, c(NSDownArrowFunctionKey), c(NSDownArrowFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_at_7):  stringForKeypress(kVK_End, NSEventModifierFlagFunction, c(NSEndFunctionKey), c(NSEndFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_at_8):  stringForKeypress(kVK_Return, NSEventModifierFlagFunction, @\"\\r\", @\"\\r\"),\n        @(kDcsTermcapTerminfoRequestKey_k1):  stringForKeypress(kVK_F1, NSEventModifierFlagFunction, c(NSF1FunctionKey), c(NSF1FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k2):  stringForKeypress(kVK_F2, NSEventModifierFlagFunction, c(NSF2FunctionKey), c(NSF2FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k3):  stringForKeypress(kVK_F3, NSEventModifierFlagFunction, c(NSF3FunctionKey), c(NSF3FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k4):  stringForKeypress(kVK_F4, NSEventModifierFlagFunction, c(NSF4FunctionKey), c(NSF4FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k5):  stringForKeypress(kVK_F5, NSEventModifierFlagFunction, c(NSF5FunctionKey), c(NSF5FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k6):  stringForKeypress(kVK_F6, NSEventModifierFlagFunction, c(NSF6FunctionKey), c(NSF6FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k7):  stringForKeypress(kVK_F7, NSEventModifierFlagFunction, c(NSF7FunctionKey), c(NSF7FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k8):  stringForKeypress(kVK_F8, NSEventModifierFlagFunction, c(NSF8FunctionKey), c(NSF8FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k9):  stringForKeypress(kVK_F9, NSEventModifierFlagFunction, c(NSF9FunctionKey), c(NSF9FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k_semi):  stringForKeypress(kVK_F10, NSEventModifierFlagFunction, c(NSF10FunctionKey), c(NSF10FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F1):  stringForKeypress(kVK_F11, NSEventModifierFlagFunction, c(NSF11FunctionKey), c(NSF11FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F2):  stringForKeypress(kVK_F12, NSEventModifierFlagFunction, c(NSF12FunctionKey), c(NSF12FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F3):  stringForKeypress(kVK_F13, NSEventModifierFlagFunction, c(NSF13FunctionKey), c(NSF13FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F4):  stringForKeypress(kVK_F14, NSEventModifierFlagFunction, c(NSF14FunctionKey), c(NSF14FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F5):  stringForKeypress(kVK_F15, NSEventModifierFlagFunction, c(NSF15FunctionKey), c(NSF15FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F6):  stringForKeypress(kVK_F16, NSEventModifierFlagFunction, c(NSF16FunctionKey), c(NSF16FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F7):  stringForKeypress(kVK_F17, NSEventModifierFlagFunction, c(NSF17FunctionKey), c(NSF17FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F8):  stringForKeypress(kVK_F18, NSEventModifierFlagFunction, c(NSF18FunctionKey), c(NSF18FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F9):  stringForKeypress(kVK_F19, NSEventModifierFlagFunction, c(NSF19FunctionKey), c(NSF19FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kh):  stringForKeypress(kVK_Home, NSEventModifierFlagFunction, c(NSHomeFunctionKey), c(NSHomeFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kl):  stringForKeypress(kVK_LeftArrow, NSEventModifierFlagFunction, c(NSLeftArrowFunctionKey), c(NSLeftArrowFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kN):  stringForKeypress(kVK_PageDown, NSEventModifierFlagFunction, c(NSPageDownFunctionKey), c(NSPageDownFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kP):  stringForKeypress(kVK_PageUp, NSEventModifierFlagFunction, c(NSPageUpFunctionKey), c(NSPageUpFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kr):  stringForKeypress(kVK_RightArrow, NSEventModifierFlagFunction, c(NSRightArrowFunctionKey), c(NSRightArrowFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_star_4):  stringForKeypress(kVK_ForwardDelete,NSEventModifierFlagFunction |  NSEventModifierFlagShift, c(NSDeleteFunctionKey), c(NSDeleteFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_star_7):  stringForKeypress(kVK_End, NSEventModifierFlagFunction | NSEventModifierFlagShift, c(NSEndFunctionKey), c(NSEndFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_pound_2):  stringForKeypress(kVK_Home, NSEventModifierFlagFunction | NSEventModifierFlagShift, c(NSHomeFunctionKey), c(NSHomeFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_pound_4):  stringForKeypress(kVK_LeftArrow, NSEventModifierFlagFunction | NSEventModifierFlagNumericPad | NSEventModifierFlagShift, c(NSLeftArrowFunctionKey), c(NSLeftArrowFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_pct_i):  stringForKeypress(kVK_RightArrow, NSEventModifierFlagFunction | NSEventModifierFlagNumericPad | NSEventModifierFlagShift, c(NSRightArrowFunctionKey), c(NSRightArrowFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_ku):  stringForKeypress(kVK_UpArrow, NSEventModifierFlagFunction, c(NSUpArrowFunctionKey), c(NSUpArrowFunctionKey)),\n    };\n}\n\n- (BOOL)shouldPostTerminalGeneratedAlert {\n    return [iTermProfilePreferences boolForKey:KEY_SEND_TERMINAL_GENERATED_ALERT\n                                     inProfile:_profile];\n}\n\n- (void)setSuppressAllOutput:(BOOL)suppressAllOutput {\n    _suppressAllOutput = suppressAllOutput;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.suppressAllOutput = suppressAllOutput;\n    }];\n}\n\n- (void)resumeOutputIfNeeded {\n    if (_suppressAllOutput) {\n        // If all output was being suppressed and you hit a key, stop it but ignore bells for a few\n        // seconds until we can process any that are in the pipeline.\n        self.suppressAllOutput = NO;\n        _ignoreBellUntil = [NSDate timeIntervalSinceReferenceDate] + 5;\n    }\n}\n\n// Called when a bell is to be run. Applies rate limiting and kicks off the bell indicators\n// (notifications, flashing lights, sounds) per user preference.\n- (void)screenActivateBellAudibly:(BOOL)audibleBell\n                          visibly:(BOOL)flashBell\n                    showIndicator:(BOOL)showBellIndicator\n                            quell:(BOOL)quell {\n    if ([self shouldIgnoreBellWhichIsAudible:audibleBell\n                                     visible:flashBell]) {\n        return;\n    }\n    if (quell) {\n        DLog(@\"Quell bell\");\n    } else {\n        if (audibleBell) {\n            DLog(@\"Beep: ring audible bell\");\n            NSBeep();\n        }\n        if (showBellIndicator) {\n            [self setBell:YES];\n        }\n        if (flashBell) {\n            [self screenFlashImage:kiTermIndicatorBell];\n        }\n    }\n    [[_delegate realParentWindow] incrementBadge];\n}\n\n- (BOOL)shouldIgnoreBellWhichIsAudible:(BOOL)audible visible:(BOOL)visible {\n    self.variablesScope.bellCount = @(self.variablesScope.bellCount.integerValue + 1);\n    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];\n    if (now < _ignoreBellUntil) {\n        return YES;\n    }\n\n    // Only sample every X seconds.\n    static const NSTimeInterval kMaximumTimeBetweenSamples = 0.01;\n    if (now < _lastBell + kMaximumTimeBetweenSamples) {\n        return NO;\n    }\n    _lastBell = now;\n\n    // If the bell rings more often than once every X seconds, you will eventually get an offer to\n    // silence it.\n    static const NSTimeInterval kThresholdForBellMovingAverageToInferAnnoyance = 0.02;\n\n    // Initial value that will require a reasonable amount of bell-ringing to overcome. This value\n    // was chosen so that one bell per second will cause the moving average's value to fall below 4\n    // after 3 seconds.\n    const NSTimeInterval kMaxDuration = 20;\n\n    if (!_bellRate) {\n        _bellRate = [[MovingAverage alloc] init];\n        _bellRate.alpha = 0.95;\n    }\n    // Keep a moving average of the time between bells\n    static const NSTimeInterval kTimeBeforeReset = 1;\n    if (_bellRate.timerStarted && _bellRate.timeSinceTimerStarted > kTimeBeforeReset) {\n        _bellRate.value = kMaxDuration * _bellRate.alpha;\n    } else {\n        [_bellRate addValue:MIN(kMaxDuration, [_bellRate timeSinceTimerStarted])];\n    }\n    DLog(@\"Bell. dt=%@ rate=%@\", @(_bellRate.timeSinceTimerStarted), @(_bellRate.value));\n    [_bellRate startTimer];\n    // If you decline the offer to silence the bell, we'll stop asking for this many seconds.\n    static const NSTimeInterval kTimeToWaitAfterDecline = 10;\n    NSString *const identifier = @\"Annoying Bell Announcement Identifier\";\n    iTermAnnouncementViewController *existingAnnouncement = _announcements[identifier];\n    if (existingAnnouncement) {\n        // Reset the auto-dismiss time each time the bell rings.\n        existingAnnouncement.timeout = 10;\n    }\n    if ([_bellRate value] < kThresholdForBellMovingAverageToInferAnnoyance &&\n        [[NSUserDefaults standardUserDefaults] boolForKey:kSilenceAnnoyingBellAutomatically]) {\n        // Silence automatically\n        _ignoreBellUntil = now + 60;\n        return YES;\n    }\n\n    if ([_bellRate value] < kThresholdForBellMovingAverageToInferAnnoyance &&\n        !existingAnnouncement &&\n        (now - _annoyingBellOfferDeclinedAt > kTimeToWaitAfterDecline) &&\n        ![[NSUserDefaults standardUserDefaults] boolForKey:kSuppressAnnoyingBellOffer]) {\n        iTermAnnouncementViewController *announcement = nil;\n        if (audible) {\n            DLog(@\"Want to show a bell announcement. The bell is audible.\");\n            announcement =\n            [iTermAnnouncementViewController announcementWithTitle:@\"The bell is ringing a lot. Silence it?\"\n                                                             style:kiTermAnnouncementViewStyleQuestion\n                                                       withActions:@[ @\"_Silence Bell Temporarily\",\n                                                                      @\"Suppress _All Output\",\n                                                                      @\"Don't Offer Again\",\n                                                                      @\"Silence Automatically\" ]\n                                                        completion:^(int selection) {\n                // Release the moving average so the count will restart after the announcement goes away.\n                [_bellRate release];\n                _bellRate = nil;\n                switch (selection) {\n                    case -2:  // Dismiss programmatically\n                        DLog(@\"Dismiss programmatically\");\n                        break;\n\n                    case -1: // No\n                        DLog(@\"Dismiss temporarily\");\n                        _annoyingBellOfferDeclinedAt = [NSDate timeIntervalSinceReferenceDate];\n                        break;\n\n                    case 0: // Suppress bell temporarily\n                        DLog(@\"Suppress bell temporarily\");\n                        _ignoreBellUntil = now + 60;\n                        break;\n\n                    case 1: // Suppress all output\n                        DLog(@\"Suppress all output\");\n                        self.suppressAllOutput = YES;\n                        break;\n\n                    case 2: // Never offer again\n                        DLog(@\"Never offer again\");\n                        [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                                forKey:kSuppressAnnoyingBellOffer];\n                        break;\n\n                    case 3:  // Silence automatically\n                        DLog(@\"Silence automatically\");\n                        [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                                forKey:kSilenceAnnoyingBellAutomatically];\n                        break;\n                }\n            }];\n        } else if (visible) {\n            DLog(@\"Want to show a bell announcement. The bell is visible but inaudible.\");\n            // Neither audible nor visible.\n            announcement =\n            [iTermAnnouncementViewController announcementWithTitle:@\"The bell is ringing a lot. Want to suppress all output until things calm down?\"\n                                                             style:kiTermAnnouncementViewStyleQuestion\n                                                       withActions:@[ @\"Suppress _All Output\",\n                                                                      @\"Don't Offer Again\" ]\n                                                        completion:^(int selection) {\n                // Release the moving average so the count will restart after the announcement goes away.\n                [_bellRate release];\n                _bellRate = nil;\n                switch (selection) {\n                    case -2:  // Dismiss programmatically\n                        DLog(@\"Dismiss programmatically\");\n                        break;\n\n                    case -1: // No\n                        DLog(@\"Dismiss temporarily\");\n                        _annoyingBellOfferDeclinedAt = [NSDate timeIntervalSinceReferenceDate];\n                        break;\n\n                    case 0: // Suppress all output\n                        DLog(@\"Suppress all output\");\n                        self.suppressAllOutput = YES;\n                        break;\n\n                    case 1: // Never offer again\n                        DLog(@\"Don't offer again\");\n                        [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                                forKey:kSuppressAnnoyingBellOffer];\n                        break;\n                }\n            }];\n        }\n\n        if (announcement) {\n            // Set the auto-dismiss timeout.\n            announcement.timeout = 10;\n            [self queueAnnouncement:announcement identifier:identifier];\n        }\n    }\n    if ([self wasFocusReportedVeryRecently] && ![self haveWrittenAnythingBesidesFocusReportVeryRecently]) {\n        [self offerToTurnOffFocusReporting];\n        return NO;\n    }\n    return NO;\n}\n\nstatic const NSTimeInterval PTYSessionFocusReportBellSquelchTimeIntervalThreshold = 0.1;\n\n- (BOOL)wasFocusReportedVeryRecently {\n    NSDate *date = self.lastFocusReportDate;\n    if (!date) {\n        return NO;\n    }\n    return -[date timeIntervalSinceNow] < PTYSessionFocusReportBellSquelchTimeIntervalThreshold;\n}\n\n- (BOOL)haveWrittenAnythingBesidesFocusReportVeryRecently {\n    return -[self.lastNonFocusReportingWrite timeIntervalSinceNow] < PTYSessionFocusReportBellSquelchTimeIntervalThreshold;\n}\n\n- (NSString *)profileName {\n    NSString *guid = _profile[KEY_ORIGINAL_GUID] ?: _profile[KEY_GUID];\n    Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:guid];\n    if (profile) {\n        return profile[KEY_NAME];\n    }\n    return _profile[KEY_NAME];\n}\n\n- (void)trimHostsIfNeeded {\n    if (_hosts.count > kMaxHosts) {\n        [_hosts removeObjectsInRange:NSMakeRange(0, _hosts.count - kMaxHosts)];\n    }\n}\n\n- (void)trimCommandsIfNeeded {\n    if (_commands.count > kMaxCommands) {\n        [_commands removeObjectsInRange:NSMakeRange(0, _commands.count - kMaxCommands)];\n    }\n}\n\n- (void)trimDirectoriesIfNeeded {\n    if (_directories.count > kMaxDirectories) {\n        [_directories removeObjectsInRange:NSMakeRange(0, _directories.count - kMaxDirectories)];\n    }\n}\n\n- (void)setLastDirectory:(NSString *)lastDirectory remote:(BOOL)directoryIsRemote pushed:(BOOL)pushed {\n    DLog(@\"setLastDirectory:%@ remote:%@ pushed:%@\\n%@\", lastDirectory, @(directoryIsRemote), @(pushed), [NSThread callStackSymbols]);\n    if (pushed && lastDirectory) {\n        [_directories addObject:lastDirectory];\n        [self trimDirectoriesIfNeeded];\n    }\n    self.lastDirectory = lastDirectory;\n    if (!directoryIsRemote) {\n        if (pushed || !self.lastLocalDirectoryWasPushed) {\n            self.lastLocalDirectory = lastDirectory;\n            self.lastLocalDirectoryWasPushed = pushed;\n        }\n    }\n    if (lastDirectory) {\n        DLog(@\"Set path to %@\", lastDirectory);\n        self.variablesScope.path = lastDirectory;\n    }\n    // Update the proxy icon\n    [_delegate sessionCurrentDirectoryDidChange:self];\n}\n\n- (void)setLastLocalDirectory:(NSString *)lastLocalDirectory {\n    DLog(@\"lastLocalDirectory goes %@ -> %@ for %@\\n%@\", _lastLocalDirectory, lastLocalDirectory, self, [NSThread callStackSymbols]);\n    [_lastLocalDirectory autorelease];\n    _lastLocalDirectory = [lastLocalDirectory copy];\n    if (lastLocalDirectory) {\n        _localFileChecker.workingDirectory = lastLocalDirectory;\n    }\n}\n\n- (void)setLastLocalDirectoryWasPushed:(BOOL)lastLocalDirectoryWasPushed {\n    DLog(@\"lastLocalDirectoryWasPushed goes %@ -> %@ for %@\\n%@\", @(_lastLocalDirectoryWasPushed),\n         @(lastLocalDirectoryWasPushed), self, [NSThread callStackSymbols]);\n    _lastLocalDirectoryWasPushed = lastLocalDirectoryWasPushed;\n}\n\n- (void)asyncInitialDirectoryForNewSessionBasedOnCurrentDirectory:(void (^)(NSString *pwd))completion {\n    if (_conductor != nil && self.lastDirectory.length > 0) {\n        completion(self.lastDirectory);\n        return;\n    }\n    NSString *envPwd = self.environment[@\"PWD\"];\n    DLog(@\"asyncInitialDirectoryForNewSessionBasedOnCurrentDirectory environment[pwd]=%@\", envPwd);\n    [self asyncCurrentLocalWorkingDirectory:^(NSString *pwd) {\n        DLog(@\"asyncCurrentLocalWorkingDirectory finished with %@\", pwd);\n        if (!pwd) {\n            completion(envPwd);\n            return;\n        }\n        completion(pwd);\n    }];\n}\n\n- (void)asyncCurrentLocalWorkingDirectory:(void (^)(NSString *pwd))completion {\n    DLog(@\"Current local working directory requestd for %@\", self);\n    if (_lastLocalDirectory) {\n        DLog(@\"Using cached value %@\", _lastLocalDirectory);\n        completion(_lastLocalDirectory);\n        return;\n    }\n    DLog(@\"No cached value\");\n    __weak __typeof(self) weakSelf = self;\n    [self updateLocalDirectoryWithCompletion:^(NSString *pwd) {\n        DLog(@\"updateLocalDirectory for %@ finished with %@\", weakSelf, pwd);\n        completion(weakSelf.lastLocalDirectory);\n    }];\n}\n\n// POTENTIALLY SLOW - AVOID CALLING!\n- (NSString *)currentLocalWorkingDirectory {\n    DLog(@\"Warning! Slow currentLocalWorkingDirectory called\");\n    if (self.lastLocalDirectory != nil) {\n        // If a shell integration-provided working directory is available, prefer to use it because\n        // it has unresolved symlinks. The path provided by -getWorkingDirectory has expanded symlinks\n        // and isn't what the user expects to see. This was raised in issue 3383. My first fix was\n        // to expand symlinks on _lastDirectory and use it if it matches what the kernel reports.\n        // That was a bad idea because expanding symlinks is slow on network file systems (Issue 4901).\n        // Instead, we'll use _lastDirectory if we believe it's on localhost.\n        // Furthermore, getWorkingDirectory is slow and blocking and it would be better never to call\n        // it.\n        DLog(@\"Using last directory from shell integration: %@\", _lastDirectory);\n        return self.lastLocalDirectory;\n    }\n    DLog(@\"Last directory is unsuitable or nil\");\n    // Ask the kernel what the child's process's working directory is.\n    self.lastLocalDirectory = [_shell getWorkingDirectory];\n    self.lastLocalDirectoryWasPushed = NO;\n    return self.lastLocalDirectory;\n}\n\n- (void)setLastRemoteHost:(id<VT100RemoteHostReading>)lastRemoteHost {\n    if (lastRemoteHost) {\n        [_hosts addObject:lastRemoteHost];\n        [self trimHostsIfNeeded];\n    }\n    [_lastRemoteHost autorelease];\n    _lastRemoteHost = [lastRemoteHost retain];\n}\n\n- (void)screenLogWorkingDirectoryOnAbsoluteLine:(long long)absLine\n                                     remoteHost:(id<VT100RemoteHostReading>)remoteHost\n                                  withDirectory:(NSString *)directory\n                                       pushType:(VT100ScreenWorkingDirectoryPushType)pushType\n                                       accepted:(BOOL)accepted {\n    DLog(@\"screenLogWorkingDirectoryOnscreenLogWorkingDirectoryOnAbsoluteLine:%@ remoteHost:%@ withDirectory:%@ pushType:%@ accepted:%@\",\n         @(absLine), remoteHost, directory, @(pushType), @(accepted));\n\n    DLog(@\"Accepted=%@\", @(accepted));\n\n    const BOOL pushed = (pushType != VT100ScreenWorkingDirectoryPushTypePull);\n    if (pushed && accepted) {\n        // If we're currently polling for a working directory, do not create a\n        // mark for the result when the poll completes because this mark is\n        // from a higher-quality data source.\n        DLog(@\"Invalidate outstanding PWD poller requests.\");\n        [_pwdPoller invalidateOutstandingRequests];\n    }\n\n    // Update shell integration DB.\n    DLog(@\"remoteHost is %@, is local is %@\", remoteHost, @(!remoteHost.isLocalhost));\n    if (pushed) {\n        BOOL isSame = ([directory isEqualToString:_lastDirectory] &&\n                       [remoteHost isEqualToRemoteHost:_lastRemoteHost]);\n        [[iTermShellHistoryController sharedInstance] recordUseOfPath:directory\n                                                               onHost:remoteHost\n                                                             isChange:!isSame];\n    }\n    if (accepted) {\n        // This has been a big ugly hairball for a long time. Because of the\n        // working directory poller I think it's safe to simplify it now. Before,\n        // we'd track whether the update was trustworthy and likely to happen\n        // again. These days, it should always be regular so that is not\n        // interesting. Instead, we just want to make sure we know if the directory\n        // is local or remote because we want to ignore local directories when we\n        // know the user is ssh'ed somewhere.\n        const BOOL directoryIsRemote = (pushType == VT100ScreenWorkingDirectoryPushTypeStrongPush) && remoteHost && !remoteHost.isLocalhost;\n\n        // Update lastDirectory, lastLocalDirectory (maybe), proxy icon, \"path\" variable.\n        [self setLastDirectory:directory remote:directoryIsRemote pushed:pushed];\n        if (pushed) {\n            self.lastRemoteHost = remoteHost;\n        }\n    }\n}\n\n- (BOOL)screenAllowTitleSetting {\n    NSNumber *n = _profile[KEY_ALLOW_TITLE_SETTING];\n    if (!n) {\n        return YES;\n    } else {\n        return [n boolValue];\n    }\n}\n\n- (void)didUpdateCurrentDirectory:(NSString *)newPath {\n    _shouldExpectCurrentDirUpdates = YES;\n    _conductor.currentDirectory = newPath;\n}\n\n- (NSString *)shellIntegrationUpgradeUserDefaultsKeyForHost:(id<VT100RemoteHostReading>)host {\n    return [NSString stringWithFormat:@\"SuppressShellIntegrationUpgradeAnnouncementForHost_%@@%@\",\n            host.username, host.hostname];\n}\n\n- (void)tryToRunShellIntegrationInstallerWithPromptCheck:(BOOL)promptCheck {\n    if (_exited) {\n        return;\n    }\n    NSString *currentCommand = [self currentCommand];\n    if (!promptCheck || currentCommand != nil) {\n        [_textview installShellIntegration:nil];\n    } else {\n        iTermWarningSelection selection =\n        [iTermWarning showWarningWithTitle:@\"It looks like you're not at a command prompt.\"\n                                   actions:@[ @\"Run Installer Anyway\", @\"Cancel\" ]\n                                identifier:nil\n                               silenceable:kiTermWarningTypePersistent\n                                    window:self.view.window];\n        switch (selection) {\n            case kiTermWarningSelection0:\n                [_textview installShellIntegration:nil];\n                break;\n\n            default:\n                break;\n        }\n    }\n}\n\n- (void)screenDidDetectShell:(NSString *)shell {\n    NSString *name = self.currentHost.usernameAndHostname;\n    if (name && shell) {\n        self.hostnameToShell[name] = shell;\n    }\n    if (shell) {\n        [self.variablesScope setValue:shell forVariableNamed:iTermVariableKeyShell];\n    }\n}\n\n- (NSString *)bestGuessAtUserShell {\n    return [[self.variablesScope valueForVariableName:iTermVariableKeyShell] lastPathComponent] ?: [[iTermOpenDirectory userShell] lastPathComponent] ?: @\"zsh\";\n}\n\n- (NSString *)bestGuessAtUName {\n    NSString *name = self.currentHost.usernameAndHostname;\n    NSString *unameString = nil;\n    if (name) {\n        unameString = _conductor.uname;\n    }\n    if (!unameString) {\n        struct utsname utsname = { 0 };\n        if (uname(&utsname)) {\n            return @\"Darwin\";\n        }\n        unameString = [NSString stringWithFormat:@\"%s %s %s %s %s\",\n                       utsname.sysname,\n                       utsname.nodename,\n                       utsname.release,\n                       utsname.version,\n                       utsname.machine];\n    }\n    return unameString;\n}\n\n- (void)screenSuggestShellIntegrationUpgrade {\n    id<VT100RemoteHostReading> currentRemoteHost = [self currentHost];\n\n    NSString *theKey = [self shellIntegrationUpgradeUserDefaultsKeyForHost:currentRemoteHost];\n    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];\n    if ([userDefaults boolForKey:theKey]) {\n        return;\n    }\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:@\"This account\u2019s Shell Integration scripts are out of date.\"\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"Upgrade\", @\"Silence Warning\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case -2:  // Dismiss programmatically\n                break;\n\n            case -1: // No\n                break;\n\n            case 0: // Yes\n                [self tryToRunShellIntegrationInstallerWithPromptCheck:YES];\n                break;\n\n            case 1: // Never for this account\n                [userDefaults setBool:YES forKey:theKey];\n                break;\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:kShellIntegrationOutOfDateAnnouncementIdentifier];\n}\n\n- (BOOL)screenShouldReduceFlicker {\n    return [iTermProfilePreferences boolForKey:KEY_REDUCE_FLICKER inProfile:self.profile];\n}\n\n- (NSInteger)screenUnicodeVersion {\n    return _unicodeVersion;\n}\n\n- (void)screenSetUnicodeVersion:(NSInteger)unicodeVersion {\n    if (unicodeVersion == 0) {\n        // Set to default value\n        unicodeVersion = [[iTermProfilePreferences defaultObjectForKey:KEY_UNICODE_VERSION] integerValue];\n    }\n    if (unicodeVersion >= kMinimumUnicodeVersion &&\n        unicodeVersion <= kMaximumUnicodeVersion &&\n        unicodeVersion != [iTermProfilePreferences integerForKey:KEY_UNICODE_VERSION inProfile:self.profile]) {\n        [self setSessionSpecificProfileValues:@{ KEY_UNICODE_VERSION: @(unicodeVersion) }];\n    }\n}\n\n- (void)updateStatusChangedLine {\n    _statusChangedAbsLine = _screen.cursorY - 1 + _screen.numberOfScrollbackLines + _screen.totalScrollbackOverflow;\n}\n\n- (void)restoreKeyLabels:(NSDictionary *)labels updateStatusChangedLine:(BOOL)updateStatusChangedLine {\n    if (labels.count == 0) {\n        return;\n    }\n    if (!_keyLabels) {\n        _keyLabels = [[NSMutableDictionary alloc] init];\n    }\n    [labels enumerateKeysAndObjectsUsingBlock:^(NSString *_Nonnull name, NSString *_Nonnull value, BOOL * _Nonnull stop) {\n        if (value.length == 0) {\n            return;\n        }\n        _keyLabels[name] = [[value copy] autorelease];\n        if ([name isEqualToString:@\"status\"] && updateStatusChangedLine) {\n            [self updateStatusChangedLine];\n        }\n    }];\n}\n\n- (void)screenSetLabel:(NSString *)label forKey:(NSString *)keyName {\n    if (!_keyLabels) {\n        _keyLabels = [[NSMutableDictionary alloc] init];\n    }\n    const BOOL changed = ![_keyLabels[keyName] isEqualToString:label];\n    if (label.length == 0) {\n        [_keyLabels removeObjectForKey:keyName];\n    } else {\n        _keyLabels[keyName] = [[label copy] autorelease];\n    }\n    if ([keyName isEqualToString:@\"status\"] && changed) {\n        [self updateStatusChangedLine];\n    }\n    [_delegate sessionKeyLabelsDidChange:self];\n}\n\n- (void)screenPushKeyLabels:(NSString *)value {\n    if (!_keyLabels) {\n        return;\n    }\n    if (!_keyLabelsStack) {\n        _keyLabelsStack = [[NSMutableArray alloc] init];\n    }\n    iTermKeyLabels *labels = [[[iTermKeyLabels alloc] init] autorelease];\n    labels.name = value;\n    labels.map = [_keyLabels.mutableCopy autorelease];\n    [_keyLabelsStack addObject:labels];\n\n    if (![value hasPrefix:@\".\"]) {\n        [_keyLabels removeAllObjects];\n    }\n    [_delegate sessionKeyLabelsDidChange:self];\n}\n\n- (iTermKeyLabels *)popKeyLabels {\n    iTermKeyLabels *labels = [[_keyLabelsStack.lastObject retain] autorelease];\n    [_keyLabelsStack removeLastObject];\n    return labels;\n}\n\n- (void)screenPopKeyLabels:(NSString *)value {\n    [_keyLabels release];\n    _keyLabels = nil;\n    iTermKeyLabels *labels = [self popKeyLabels];\n    while (labels && value.length > 0 && ![labels.name isEqualToString:value]) {\n        labels = [self popKeyLabels];\n    }\n    _keyLabels = [labels.map mutableCopy];\n    [_delegate sessionKeyLabelsDidChange:self];\n}\n\n- (void)screenSendModifiersDidChange {\n    const BOOL allowed = [iTermProfilePreferences boolForKey:KEY_ALLOW_MODIFY_OTHER_KEYS\n                                                   inProfile:self.profile];\n    if (!allowed) {\n        return;\n    }\n    const int modifyOtherKeysMode = _screen.terminalSendModifiers[4].intValue;\n    if (modifyOtherKeysMode == 1) {\n        self.keyMappingMode = iTermKeyMappingModeModifyOtherKeys1;\n    } else if (modifyOtherKeysMode == 2) {\n        self.keyMappingMode = iTermKeyMappingModeModifyOtherKeys2;\n    } else {\n        self.keyMappingMode = iTermKeyMappingModeStandard;\n    }\n}\n\n- (void)screenKeyReportingFlagsDidChange {\n    if (_screen.terminalKeyReportingFlags & VT100TerminalKeyReportingFlagsDisambiguateEscape) {\n        self.keyMappingMode = iTermKeyMappingModeCSIu;\n    } else {\n        self.keyMappingMode = iTermKeyMappingModeStandard;\n    }\n}\n\n- (void)screenTerminalAttemptedPasteboardAccess {\n    [self.textview didCopyToPasteboardWithControlSequence];\n    if ([iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal]) {\n        return;\n    }\n    if ([iTermAdvancedSettingsModel noSyncSuppressClipboardAccessDeniedWarning]) {\n        return;\n    }\n    NSString *identifier = @\"ClipboardAccessDenied\";\n    if ([self hasAnnouncementWithIdentifier:identifier]) {\n        return;\n    }\n    NSString *notice = @\"The terminal attempted to access the clipboard but it was denied. Enable clipboard access in \u201cPrefs > General > Selection > Applications in terminal may access clipboard\u201d.\";\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:notice\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"_Open Prefs\", @\"Don't Show This Again\" ]\n                                                completion:^(int selection) {\n        if (selection == 0) {\n            [[PreferencePanel sharedInstance] openToPreferenceWithKey:kPreferenceKeyAllowClipboardAccessFromTerminal];\n        } else if (selection == 1) {\n            [iTermAdvancedSettingsModel setNoSyncSuppressClipboardAccessDeniedWarning:YES];\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:identifier];\n}\n\n- (NSString *)stringValueOfVariable:(NSString *)name {\n    if (!name) {\n        return nil;\n    }\n    id value = [self.variablesScope valueForVariableName:name];\n    if ([NSString castFrom:value]) {\n        return value;\n    } else if ([value respondsToSelector:@selector(stringValue)]) {\n        return [value stringValue];\n    } else {\n        return nil;\n    }\n}\n\n- (void)screenReportFocusWillChangeTo:(BOOL)reportFocus {\n    [self dismissAnnouncementWithIdentifier:kTurnOffFocusReportingOnHostChangeAnnouncementIdentifier];\n}\n\n- (void)screenReportPasteBracketingWillChangeTo:(BOOL)bracket {\n    [self dismissAnnouncementWithIdentifier:kTurnOffBracketedPasteOnHostChangeAnnouncementIdentifier];\n}\n\n- (void)screenDidReceiveLineFeed {\n    [self publishNewline];\n    [_pwdPoller didReceiveLineFeed];\n    if (_logging.enabled && !self.isTmuxGateway) {\n        switch (_logging.style) {\n            case iTermLoggingStyleRaw:\n            case iTermLoggingStyleAsciicast:\n                break;\n            case iTermLoggingStyleHTML:\n                [_logging logNewline:[@\"<br/>\\n\" dataUsingEncoding:_screen.terminalEncoding]];\n                break;\n            case iTermLoggingStylePlainText:\n                [_logging logNewline:nil];\n                break;\n        }\n    }\n}\n\n- (void)screenSoftAlternateScreenModeDidChangeTo:(BOOL)enabled\n                                showingAltScreen:(BOOL)showing {\n    [self.processInfoProvider setNeedsUpdate:YES];\n    [self.tmuxForegroundJobMonitor updateOnce];\n    [self.variablesScope setValue:@(showing)\n                 forVariableNamed:iTermVariableKeySessionShowingAlternateScreen];\n}\n\n- (void)screenReportKeyUpDidChange:(BOOL)reportKeyUp {\n    if (reportKeyUp) {\n        self.keyMappingMode = iTermKeyMappingModeRaw;\n    } else {\n        self.keyMappingMode = iTermKeyMappingModeStandard;\n    }\n}\n\n#pragma mark - Announcements\n\n- (BOOL)hasAnnouncementWithIdentifier:(NSString *)identifier {\n    return _announcements[identifier] != nil;\n}\n\n- (void)dismissAnnouncementWithIdentifier:(NSString *)identifier {\n    iTermAnnouncementViewController *announcement = _announcements[identifier];\n    [announcement dismiss];\n}\n\n- (void)queueAnnouncement:(iTermAnnouncementViewController *)announcement\n               identifier:(NSString *)identifier {\n    DLog(@\"Enqueue announcement with identifier %@\", identifier);\n    [self dismissAnnouncementWithIdentifier:identifier];\n\n    _announcements[identifier] = announcement;\n\n    void (^originalCompletion)(int) = [announcement.completion copy];\n    NSString *identifierCopy = [identifier copy];\n    __weak __typeof(self) weakSelf = self;\n    announcement.completion = ^(int selection) {\n        originalCompletion(selection);\n        if (selection == -2) {\n            [weakSelf removeAnnouncementWithIdentifier:identifierCopy];\n            [identifierCopy release];\n            [originalCompletion release];\n        }\n    };\n    [_view addAnnouncement:announcement];\n}\n\n- (void)removeAnnouncementWithIdentifier:(NSString *)identifier {\n    [_announcements removeObjectForKey:identifier];\n}\n\n- (iTermAnnouncementViewController *)announcementWithIdentifier:(NSString *)identifier {\n    return _announcements[identifier];\n}\n\n#pragma mark - PopupDelegate\n\n- (BOOL)popupShouldTakePrefixFromScreen {\n    return _textview.window.firstResponder == _textview;\n}\n\n// If the cursor is preceded by whitespace the last word will be empty. Words go in reverse order.\n- (NSArray<NSString *> *)popupWordsBeforeInsertionPoint:(int)count {\n    id<iTermPopupWindowHosting> host = [self popupHost];\n    return [host wordsBeforeInsertionPoint:count] ?: @[@\"\"];\n}\n\n- (void)popupIsSearching:(BOOL)searching {\n    _textview.showSearchingCursor = searching;\n    [_textview setNeedsDisplayInRect:_textview.cursorFrame];\n}\n\n- (void)popupWillClose:(iTermPopupWindowController *)popup {\n    [[_delegate realParentWindow] popupWillClose:popup];\n}\n\n- (NSRect)popupScreenVisibleFrame {\n    return [[[[_delegate realParentWindow] window] screen] visibleFrame];\n}\n\n- (BOOL)popupWindowIsInFloatingHotkeyWindow {\n    return _delegate.realParentWindow.isFloatingHotKeyWindow;\n}\n\n- (BOOL)screenConfirmDownloadNamed:(NSString *)name canExceedSize:(NSInteger)limit {\n    NSString *identifier = @\"NoSyncAllowBigDownload\";\n    const iTermWarningSelection selection =\n    [iTermWarning showWarningWithTitle:[NSString stringWithFormat:@\"The download \u201c%@\u201d is larger than %@. Continue?\", name, [NSString it_formatBytes:limit]]\n                               actions:@[ @\"Allow\", @\"Deny\" ]\n                             accessory:nil\n                            identifier:identifier\n                           silenceable:kiTermWarningTypePermanentlySilenceable\n                               heading:@\"Allow Large File Download?\"\n                                window:_view.window];\n    return selection == kiTermWarningSelection0;\n}\n\n- (BOOL)screenConfirmDownloadAllowed:(NSString *)name\n                                size:(NSInteger)size\n                       displayInline:(BOOL)displayInline\n                         promptIfBig:(BOOL *)promptIfBig {\n    NSString *identifier = @\"NoSyncSuppressDownloadConfirmation\";\n    *promptIfBig = YES;\n    const BOOL wasSilenced = [iTermWarning identifierIsSilenced:identifier];\n    NSString *title;\n    NSString *heading;\n    if (displayInline) {\n        title = [NSString stringWithFormat:@\"The terminal has initiated display of a file named \u201c%@\u201d of size %@. Allow it?\",\n                 name, [NSString it_formatBytes:size]];\n        heading = @\"Allow Terminal-Initiated Display?\";\n    } else {\n        title = [NSString stringWithFormat:@\"The terminal has initiated transfer of a file named \u201c%@\u201d of size %@. Download it?\",\n                 name, [NSString it_formatBytes:size]];\n        heading = @\"Allow Terminal-Initiated Download?\";\n    }\n    const iTermWarningSelection selection =\n    [iTermWarning showWarningWithTitle:title\n                               actions:@[ @\"Yes\", @\"No\" ]\n                             accessory:nil\n                            identifier:identifier\n                           silenceable:kiTermWarningTypePermanentlySilenceable\n                               heading:heading\n                                window:_view.window];\n    const BOOL allow = (selection == kiTermWarningSelection0);\n    DLog(@\"allow=%@\", @(allow));\n    if (allow && wasSilenced) {\n        if (size > VT100ScreenBigFileDownloadThreshold) {\n            *promptIfBig = NO;\n            return [self screenConfirmDownloadNamed:name canExceedSize:VT100ScreenBigFileDownloadThreshold];\n        }\n    }\n    return allow;\n}\n\n- (BOOL)clearScrollbackAllowed {\n    if (self.naggingController.shouldAskAboutClearingScrollbackHistory) {\n        return NO;\n    }\n    const BOOL *boolPtr = iTermAdvancedSettingsModel.preventEscapeSequenceFromClearingHistory;\n    if (!boolPtr) {\n        return NO;\n    }\n    return !*boolPtr;\n}\n\n- (void)screenAskAboutClearingScrollback {\n    if (self.naggingController.shouldAskAboutClearingScrollbackHistory) {\n        [self.naggingController askAboutClearingScrollbackHistory];\n    }\n}\n\n- (void)screenDidResize {\n    DLog(@\"screenDidResize\");\n    [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionDidResizeNotification\n                                                        object:self];\n    [self.delegate sessionDidResize:self];\n}\n\n- (void)screenDidAppendImageData:(NSData *)data {\n    if (!_logging.enabled) {\n        return;\n    }\n    if (self.isTmuxGateway) {\n        return;\n    }\n    switch (_logging.style) {\n        case iTermLoggingStyleRaw:\n        case iTermLoggingStylePlainText:\n        case iTermLoggingStyleAsciicast:\n            break;\n        case iTermLoggingStyleHTML:\n            [_logging logData:[data inlineHTMLData]];\n            break;\n    }\n}\n\n- (void)screenAppendScreenCharArray:(ScreenCharArray *)sca\n                           metadata:(iTermImmutableMetadata)metadata {\n    [self publishScreenCharArray:sca metadata:metadata];\n}\n\n- (NSString *)screenStringForKeypressWithCode:(unsigned short)keycode\n                                        flags:(NSEventModifierFlags)flags\n                                   characters:(NSString *)characters\n                  charactersIgnoringModifiers:(NSString *)charactersIgnoringModifiers {\n    return [self stringForKeyCode:keycode flags:flags characters:characters charactersIgnoringModifiers:charactersIgnoringModifiers];\n}\n\n- (NSString *)stringForKeyCode:(unsigned short)keycode\n                         flags:(NSEventModifierFlags)flags\n                    characters:(NSString *)characters\n   charactersIgnoringModifiers:(NSString *)charactersIgnoringModifiers {\n    NSEvent *event = [NSEvent keyEventWithType:NSEventTypeKeyDown\n                                      location:NSZeroPoint\n                                 modifierFlags:flags\n                                     timestamp:0\n                                  windowNumber:self.view.window.windowNumber\n                                       context:nil\n                                    characters:characters\n                   charactersIgnoringModifiers:charactersIgnoringModifiers\n                                     isARepeat:NO\n                                       keyCode:keycode];\n    return [_textview.keyboardHandler stringForEventWithoutSideEffects:event\n                                                              encoding:_screen.terminalEncoding ?: NSUTF8StringEncoding];\n}\n\n- (void)screenApplicationKeypadModeDidChange:(BOOL)mode {\n    self.variablesScope.applicationKeypad = mode;\n}\n\n- (void)screenRestoreColorsFromSlot:(VT100SavedColorsSlot *)slot {\n    const BOOL dark = _screen.colorMap.darkMode;\n    NSMutableDictionary *dict = [[@{ iTermAmendedColorKey(KEY_FOREGROUND_COLOR, _profile, dark): slot.text.dictionaryValue,\n                                     iTermAmendedColorKey(KEY_BACKGROUND_COLOR, _profile, dark): slot.background.dictionaryValue,\n                                     iTermAmendedColorKey(KEY_SELECTED_TEXT_COLOR, _profile, dark): slot.selectionText.dictionaryValue,\n                                     iTermAmendedColorKey(KEY_SELECTION_COLOR, _profile, dark): slot.selectionBackground.dictionaryValue } mutableCopy] autorelease];\n    for (int i = 0; i < MIN(kColorMapNumberOf8BitColors, slot.indexedColors.count); i++) {\n        if (i < 16) {\n            NSString *baseKey = [NSString stringWithFormat:KEYTEMPLATE_ANSI_X_COLOR, i];\n            NSString *profileKey = iTermAmendedColorKey(baseKey, _profile, dark);\n            dict[profileKey] = [slot.indexedColors[i] dictionaryValue];\n        }\n    }\n    [self setSessionSpecificProfileValues:dict];\n}\n\n- (void)screenCopyStringToPasteboard:(NSString *)string {\n    [self screenTerminalAttemptedPasteboardAccess];\n    // check the configuration\n    if (![iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal]) {\n        return;\n    }\n\n    // set the result to paste board.\n    NSPasteboard *thePasteboard = [NSPasteboard generalPasteboard];\n    [thePasteboard clearContents];\n    [thePasteboard declareTypes:@[ NSPasteboardTypeString ] owner:nil];\n    [thePasteboard setString:string forType:NSPasteboardTypeString];\n}\n\n- (void)screenReportPasteboard:(NSString *)pasteboard completion:(void (^)(void))completion {\n    if (!_pasteboardReporter) {\n        _pasteboardReporter = [[iTermPasteboardReporter alloc] init];\n        _pasteboardReporter.delegate = self;\n    }\n    [_pasteboardReporter handleRequestWithPasteboard:pasteboard completion:completion];\n}\n\n- (void)screenOfferToDisableTriggersInInteractiveApps {\n    [self.naggingController offerToDisableTriggersInInteractiveApps];\n}\n\n- (void)screenDidUpdateReturnCodeForMark:(id<VT100ScreenMarkReading>)mark\n                              remoteHost:(id<VT100RemoteHostReading>)remoteHost {\n    [[iTermShellHistoryController sharedInstance] setStatusOfCommandAtMark:mark\n                                                                    onHost:remoteHost\n                                                                        to:mark.code];\n    [self screenNeedsRedraw];\n}\n\n- (void)screenPostUserNotification:(NSString * _Nonnull)message rich:(BOOL)rich {\n    if (![self shouldPostTerminalGeneratedAlert]) {\n        DLog(@\"Declining to allow terminal to post user notification %@\", message);\n        return;\n    }\n    DLog(@\"Terminal posting user notification %@\", message);\n    [self incrementBadge];\n\n    iTermNotificationController* controller = [iTermNotificationController sharedInstance];\n\n    if (rich) {\n        NSDictionary<NSString *, NSString *> *dict = [[message it_keyValuePairsSeparatedBy:@\";\"] mapValuesWithBlock:^id(NSString *key, NSString *encoded) {\n            return [encoded stringByBase64DecodingStringWithEncoding:NSUTF8StringEncoding];\n        }];\n        NSString *description = dict[@\"message\"] ?: @\"\";\n        NSString *title = dict[@\"title\"];\n        NSString *subtitle = dict[@\"subtitle\"];\n        NSString *image = [dict[@\"image\"] stringByTrimmingTrailingCharactersFromCharacterSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];\n\n        [controller notifyRich:title\n                  withSubtitle:subtitle\n               withDescription:description\n                     withImage:image\n                   windowIndex:[self screenWindowIndex]\n                      tabIndex:[self screenTabIndex]\n                     viewIndex:[self screenViewIndex]];\n    } else {\n        NSString *description = [NSString stringWithFormat:@\"Session %@ #%d: %@\",\n                                 [[self name] removingHTMLFromTabTitleIfNeeded],\n                                 [_delegate tabNumber],\n                                 message];\n        [controller notify:@\"Alert\"\n           withDescription:description\n               windowIndex:[self screenWindowIndex]\n                  tabIndex:[self screenTabIndex]\n                 viewIndex:[self screenViewIndex]];\n    }\n}\n\n- (void)screenUpdateCommandUseWithGuid:(NSString *)screenmarkGuid\n                                onHost:(id<VT100RemoteHostReading>)lastRemoteHost\n                         toReferToMark:(id<VT100ScreenMarkReading>)screenMark {\n    iTermCommandHistoryCommandUseMO *commandUse =\n    [[iTermShellHistoryController sharedInstance] commandUseWithMarkGuid:screenMark.guid\n                                                                  onHost:lastRemoteHost];\n    commandUse.mark = screenMark;\n}\n\n- (void)screenExecutorDidUpdate:(VT100ScreenTokenExecutorUpdate *)update {\n    _estimatedThroughput = update.estimatedThroughput;\n    DLog(@\"estimated throughput: %@\", @(_estimatedThroughput));\n\n    if (update.numberOfBytesExecuted > 0) {\n        DLog(@\"Session %@ (%@) is processing\", self, _nameController.presentationSessionTitle);\n        if (![self haveResizedRecently]) {\n            _lastOutputIgnoringOutputAfterResizing = [NSDate timeIntervalSinceReferenceDate];\n        }\n        _newOutput = YES;\n\n        // Make sure the screen gets redrawn soonish\n        self.active = YES;\n\n        if (self.shell.pid > 0 || [[[self variablesScope] valueForVariableName:@\"jobName\"] length] > 0) {\n            [self.processInfoProvider setNeedsUpdate:YES];\n        }\n    }\n\n    [_cadenceController didHandleInputWithThroughput:_estimatedThroughput];\n}\n\n- (void)screenConvertAbsoluteRange:(VT100GridAbsCoordRange)range\n              toTextDocumentOfType:(NSString *)type\n                          filename:(NSString *)filename\n                         forceWide:(BOOL)forceWide {\n    [_textview renderRange:range type:type filename:filename forceWide:forceWide];\n}\n\n- (void)screenDidHookSSHConductorWithToken:(NSString *)token\n                                  uniqueID:(NSString *)uniqueID\n                                  boolArgs:(NSString *)boolArgs\n                                   sshargs:(NSString *)sshargs\n                                     dcsID:(NSString * _Nonnull)dcsID\n                                savedState:(NSDictionary *)savedState {\n    BOOL localOrigin = NO;\n    if ([[iTermSecretServer instance] check:token]) {\n        localOrigin = YES;\n    }\n\n    NSString *directory = nil;\n    if (_sshState == iTermSSHStateProfile && !_conductor) {\n        // Currently launching the session that has ssh instead of login shell.\n        directory = self.environment[@\"PWD\"];\n    }\n    if (_pendingJumps.count) {\n        directory = _pendingJumps[0].initialDirectory;\n        [_pendingJumps removeObjectAtIndex:0];\n    }\n    iTermConductor *previousConductor = [_conductor autorelease];\n    NSDictionary *dict = [NSDictionary castFrom:[iTermProfilePreferences objectForKey:KEY_SSH_CONFIG inProfile:self.profile]];\n    const BOOL shouldInjectShellIntegration = [iTermProfilePreferences boolForKey:KEY_LOAD_SHELL_INTEGRATION_AUTOMATICALLY inProfile:self.profile];\n    iTermSSHConfiguration *config = [[[iTermSSHConfiguration alloc] initWithDictionary:dict] autorelease];\n    _conductor = [[iTermConductor alloc] init:sshargs\n                                     boolArgs:boolArgs\n                                        dcsID:dcsID\n                               clientUniqueID:uniqueID\n                                   varsToSend:localOrigin ? [self.screen exfiltratedEnvironmentVariables:config.environmentVariablesToCopy] : @{}\n                                   clientVars:[self.screen exfiltratedEnvironmentVariables:nil] ?: @{}\n                             initialDirectory:directory\n                 shouldInjectShellIntegration:shouldInjectShellIntegration\n                                       parent:previousConductor];\n    _conductor.terminalConfiguration = savedState;\n    if (localOrigin) {\n        for (iTermTuple<NSString *, NSString *> *tuple in config.filesToCopy) {\n            [_conductor addPath:tuple.firstObject destination:tuple.secondObject];\n        }\n    }\n    _sshState = iTermSSHStateNone;\n    _conductor.delegate = self;\n    NSArray<iTermSSHReconnectionInfo *> *jumps = _pendingJumps;\n    if (!previousConductor && jumps.count) {\n        [_conductor startJumpingTo:jumps];\n    } else if (previousConductor.subsequentJumps.count) {\n        [_conductor startJumpingTo:previousConductor.subsequentJumps];\n        [previousConductor childDidBeginJumping];\n    } else {\n        [_conductor start];\n    }\n    [self updateVariablesFromConductor];\n}\n\n- (void)screenDidReadSSHConductorLine:(NSString *)string depth:(int)depth {\n    [_conductor handleLine:string depth:depth];\n}\n\n- (void)screenDidUnhookSSHConductor {\n    [_conductor handleUnhook];\n    [self writeData:_sshWriteQueue];\n    [_sshWriteQueue release];\n    _sshWriteQueue = nil;\n}\n\n- (void)unhookSSHConductor {\n    DLog(@\"Unhook %@\", _conductor);\n    [self conductorWillDie];\n    NSDictionary *config = _conductor.terminalConfiguration;\n    if (config) {\n        [_screen restoreSavedState:config];\n    }\n    _conductor.delegate = nil;\n    [_conductor autorelease];\n    _conductor = [_conductor.parent retain];\n    _conductor.delegate = self;\n    [self updateVariablesFromConductor];\n}\n\n- (void)screenDidBeginSSHConductorCommandWithIdentifier:(NSString *)identifier\n                                                  depth:(int)depth {\n    [_conductor handleCommandBeginWithIdentifier:identifier depth:depth];\n}\n\n- (void)screenDidEndSSHConductorCommandWithIdentifier:(NSString *)identifier\n                                                 type:(NSString *)type\n                                               status:(uint8_t)status\n                                                depth:(int)depth {\n    [_conductor handleCommandEndWithIdentifier:identifier\n                                          type:type\n                                        status:status\n                                         depth:depth];\n}\n\n- (void)screenHandleSSHSideChannelOutput:(NSString *)string\n                                     pid:(int32_t)pid\n                                 channel:(uint8_t)channel\n                                   depth:(int)depth {\n    [_conductor handleSideChannelOutput:string pid:pid channel:channel depth:depth];\n}\n\n- (void)screenDidTerminateSSHProcess:(int)pid code:(int)code depth:(int)depth {\n    [_conductor handleTerminatePID:pid withCode:code depth:depth];\n}\n\n- (NSInteger)screenEndSSH:(NSString *)uniqueID {\n    DLog(@\"%@\", uniqueID);\n    if (![_conductor ancestryContainsClientUniqueID:uniqueID]) {\n        DLog(@\"Ancestry does not contain this unique ID\");\n        return 0;\n    }\n    BOOL found = NO;\n    NSInteger count = 0;\n    while (_conductor != nil && !found) {\n        found = [_conductor.clientUniqueID isEqual:uniqueID];\n        count += 1;\n        [self unhookSSHConductor];\n    }\n    // it2ssh waits for a newline before exiting. This is in case ssh dies while iTerm2 is sending\n    // conductor.sh.\n    [self writeTaskNoBroadcast:@\"\\n\"];\n    return count;\n}\n\n- (void)screenBeginSSHIntegrationWithToken:(NSString *)token\n                                  uniqueID:(NSString *)uniqueID\n                                 encodedBA:(NSString *)encodedBA\n                                   sshArgs:(NSString *)sshArgs {\n    NSURL *path = [[NSBundle bundleForClass:[PTYSession class]] URLForResource:@\"conductor\" withExtension:@\"sh\"];\n    NSString *conductorSH = [NSString stringWithContentsOfURL:path encoding:NSUTF8StringEncoding error:nil];\n    // Ensure it doesn't contain empty lines.\n    conductorSH = [conductorSH stringByReplacingOccurrencesOfString:@\"\\n\\n\" withString:@\"\\n \\n\"];\n\n    [self writeTaskNoBroadcast:conductorSH];\n    [self writeTaskNoBroadcast:[NSString stringWithFormat:@\"main %@ %@ %@ %@\\n\",\n                                [token base64EncodedWithEncoding:NSUTF8StringEncoding],\n                                [uniqueID base64EncodedWithEncoding:NSUTF8StringEncoding],\n                                [encodedBA base64EncodedWithEncoding:NSUTF8StringEncoding],\n                                [sshArgs base64EncodedWithEncoding:NSUTF8StringEncoding]]];\n    [self writeTaskNoBroadcast:@\"EOF\\n\"];\n}\n\n- (NSString *)screenSSHLocation {\n    return _conductor.sshIdentity.compactDescription;\n}\n\n- (void)screenBeginFramerRecovery:(int)parentDepth {\n    if (parentDepth < 0) {\n        while (_conductor) {\n            [self unhookSSHConductor];\n        }\n    }\n    iTermConductor *previousConductor = [_conductor autorelease];\n    _conductor = [[iTermConductor alloc] init:@\"\"\n                                     boolArgs:@\"\"\n                                        dcsID:@\"\"\n                               clientUniqueID:@\"\"\n                                   varsToSend:@{}\n                                   clientVars:@{}\n                             initialDirectory:nil\n                 shouldInjectShellIntegration:NO\n                                       parent:previousConductor];\n    [self updateVariablesFromConductor];\n    _conductor.delegate = self;\n    [_conductor startRecovery];\n}\n\n- (iTermConductorRecovery *)screenHandleFramerRecoveryString:(NSString * _Nonnull)string {\n    iTermConductorRecovery *recovery = [_conductor handleRecoveryLine:string];\n    if (!recovery) {\n        return nil;\n    }\n    _conductor.delegate = nil;\n    [_conductor autorelease];\n    _conductor = [[iTermConductor alloc] initWithRecovery:recovery];\n    _conductor.delegate = self;\n    [self updateVariablesFromConductor];\n    return recovery;\n}\n\n// This is the final step of recovery. We need to reset the internal state of the conductors since\n// some tokens may have been dropped during recovery.\n- (void)screenDidResynchronizeSSH {\n    [_conductor didResynchronize];\n}\n\n- (void)screenFramerRecoveryDidFinish {\n    [_conductor recoveryDidFinish];\n}\n\n- (void)screenEnsureDefaultMode {\n    [self resetMode];\n}\n\n- (void)resetMode {\n    _modeHandler.mode = iTermSessionModeDefault;\n}\n\n- (void)screenOpenURL:(NSURL *)url completion:(void (^)(void))completion {\n    DLog(@\"url=%@\", url);\n    [self.naggingController openURL:url];\n    completion();\n}\n\n- (void)enclosingTabWillBeDeselected {\n    DLog(@\"enclosingTabWillBeDeselected %@\", self);\n    if (_alertOnMarksinOffscreenSessions) {\n        [self sync];\n    }\n}\n\n- (void)enclosingTabDidBecomeSelected {\n    DLog(@\"enclosingTabDidBecomeSelected %@\", self);\n    if (_alertOnMarksinOffscreenSessions) {\n        [self sync];\n    }\n}\n\n- (BOOL)popupWindowShouldAvoidChangingWindowOrderOnClose {\n    return [iTermPreferences boolForKey:kPreferenceKeyFocusFollowsMouse] && ![self.delegate sessionBelongsToHotkeyWindow:self];\n}\n\n- (VT100Screen *)popupVT100Screen {\n    return _screen;\n}\n\n- (id<iTermPopupWindowPresenter>)popupPresenter {\n    return self;\n}\n\n- (void)popupInsertText:(NSString *)string {\n    id<iTermPopupWindowHosting> host = [self popupHost];\n    if (host) {\n        [host popupWindowHostingInsertText:string];\n        return;\n    }\n    if (_composerManager.dropDownComposerViewIsVisible) {\n        [_composerManager insertText:string];\n        return;\n    }\n    [self insertText:string];\n}\n\n- (void)popupPreview:(NSString *)text {\n    id<iTermPopupWindowHosting> host = [self popupHost];\n    if (host) {\n        [host popupWindowHostSetPreview:[[text firstNonEmptyLine] truncatedToLength:_screen.width ellipsis:@\"\u2026\"]];\n        return;\n    }\n}\n\n- (void)popupKeyDown:(NSEvent *)event {\n    [_textview keyDown:event];\n}\n\n- (BOOL)composerCommandHistoryIsOpen {\n    if (!_composerManager.dropDownComposerViewIsVisible) {\n        return NO;\n    }\n    return [[_delegate realParentWindow] commandHistoryIsOpenForSession:self];\n}\n\n- (BOOL)popupHandleSelector:(SEL)selector\n                     string:(NSString *)string\n               currentValue:(NSString *)currentValue {\n    if ([self composerCommandHistoryIsOpen]) {\n        if (selector == @selector(deleteBackward:)) {\n            [[_delegate realParentWindow] closeCommandHistory];\n            [_composerManager deleteLastCharacter];\n            return YES;\n        }\n        return NO;\n    }\n    if (![[_delegate realParentWindow] autoCommandHistoryIsOpenForSession:self]) {\n        return NO;\n    }\n    if (selector == @selector(cancel:)) {\n        [[_delegate realParentWindow] hideAutoCommandHistoryForSession:self];\n        return YES;\n    }\n    if (selector == @selector(insertNewline:)) {\n        if ([currentValue isEqualToString:[self currentCommand]]) {\n            // Send the enter key on.\n            [self insertText:@\"\\n\"];\n            return YES;\n        } else {\n            return NO;  // select the row\n        }\n    }\n    if (selector == @selector(deleteBackward:)) {\n        [_textview keyDown:[NSEvent keyEventWithType:NSEventTypeKeyDown\n                                            location:NSZeroPoint\n                                       modifierFlags:[NSEvent modifierFlags]\n                                           timestamp:0\n                                        windowNumber:_textview.window.windowNumber\n                                             context:nil\n                                          characters:@\"\\x7f\"\n                         charactersIgnoringModifiers:@\"\\x7f\"\n                                           isARepeat:NO\n                                             keyCode:51]];  // 51 is the keycode for delete; not in any header file :(\n        return YES;\n    }\n    if (selector == @selector(insertText:) || selector == @selector(insertTab:)) {\n        [self insertText:string];\n        return YES;\n    }\n    return NO;\n}\n\n#pragma mark - iTermPasteHelperDelegate\n\n- (void)pasteHelperWriteString:(NSString *)string {\n    [self writeTask:string];\n    if (_pasteHelper.pasteContext.bytesWritten == 0 &&\n        (_pasteHelper.pasteContext.pasteEvent.flags & kPasteFlagsBracket) &&\n        _screen.terminalBracketedPasteMode) {\n        [self watchForPasteBracketingOopsieWithPrefix:[_pasteHelper.pasteContext.pasteEvent.originalString it_substringToIndex:4]];\n    }\n}\n\n- (void)pasteHelperKeyDown:(NSEvent *)event {\n    [_textview keyDown:event];\n}\n\n- (BOOL)pasteHelperShouldBracket {\n    return _screen.terminalBracketedPasteMode;\n}\n\n- (NSStringEncoding)pasteHelperEncoding {\n    return _screen.terminalEncoding;\n}\n\n- (NSView *)pasteHelperViewForIndicator {\n    return _view;\n}\n\n- (iTermStatusBarViewController *)pasteHelperStatusBarViewController {\n    return _statusBarViewController;\n}\n\n- (BOOL)pasteHelperShouldWaitForPrompt {\n    if (!_screen.shouldExpectPromptMarks) {\n        return NO;\n    }\n\n    return self.currentCommand == nil;\n}\n\n- (BOOL)pasteHelperIsAtShellPrompt {\n    return [self currentCommand] != nil;\n}\n\n- (BOOL)pasteHelperCanWaitForPrompt {\n    return _screen.shouldExpectPromptMarks;\n}\n\n- (void)pasteHelperPasteViewVisibilityDidChange {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (iTermVariableScope *)pasteHelperScope {\n    return self.variablesScope;\n}\n\n#pragma mark - iTermAutomaticProfileSwitcherDelegate\n\n- (NSString *)automaticProfileSwitcherSessionName {\n    return [NSString stringWithFormat:@\"%@ \u2014 %@\", [_nameController presentationSessionTitle], self.tty];\n}\n\n- (iTermSavedProfile *)automaticProfileSwitcherCurrentSavedProfile {\n    iTermSavedProfile *savedProfile = [[[iTermSavedProfile alloc] init] autorelease];\n    savedProfile.profile = _profile;\n    savedProfile.originalProfile = _originalProfile;\n    savedProfile.isDivorced = self.isDivorced;\n    savedProfile.overriddenFields = [[_overriddenFields mutableCopy] autorelease];\n    return savedProfile;\n}\n\n- (NSDictionary *)automaticProfileSwitcherCurrentProfile {\n    return _originalProfile;\n}\n\n- (void)automaticProfileSwitcherLoadProfile:(iTermSavedProfile *)savedProfile {\n    Profile *underlyingProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:savedProfile.originalProfile[KEY_GUID]];\n    Profile *replacementProfile = underlyingProfile ?: savedProfile.originalProfile;\n    [self setProfile:replacementProfile preservingName:NO adjustWindow:NO];\n    if (savedProfile.isDivorced) {\n        NSMutableDictionary *overrides = [NSMutableDictionary dictionary];\n        for (NSString *key in savedProfile.overriddenFields) {\n            if ([key isEqualToString:KEY_GUID] || [key isEqualToString:KEY_ORIGINAL_GUID]) {\n                continue;\n            }\n            overrides[key] = savedProfile.profile[key];\n        }\n        [self setSessionSpecificProfileValues:overrides];\n    }\n    if ([iTermAdvancedSettingsModel showAutomaticProfileSwitchingBanner]) {\n        [_view showUnobtrusiveMessage:[NSString stringWithFormat:@\"Switched to profile \u201c%@\u201d.\", underlyingProfile[KEY_NAME]]];\n    }\n}\n\n- (NSArray<NSDictionary *> *)automaticProfileSwitcherAllProfiles {\n    return [[ProfileModel sharedInstance] bookmarks];\n}\n\n#pragma mark - iTermSessionViewDelegate\n\n- (NSRect)sessionViewFrameForLegacyView {\n    const CGFloat bottomMarginHeight = [_textview excess];\n    return NSMakeRect(0,\n                      bottomMarginHeight,\n                      NSWidth(_textview.bounds),\n                      _textview.lineHeight * _screen.height);\n}\n\n- (CGFloat)sessionViewBottomMarginHeight {\n    return [_textview excess];\n}\n- (CGFloat)sessionViewTransparencyAlpha {\n    return _textview.transparencyAlpha;\n}\n\n- (void)sessionViewMouseEntered:(NSEvent *)event {\n    [_textview mouseEntered:event];\n    [_textview setNeedsDisplay:YES];\n    [_textview updateCursor:event];\n}\n\n- (void)sessionViewMouseExited:(NSEvent *)event {\n    [_textview mouseExited:event];\n    [_textview setNeedsDisplay:YES];\n    [_textview updateCursor:event];\n}\n\n- (void)sessionViewMouseMoved:(NSEvent *)event {\n    [_textview mouseMoved:event];\n}\n\n- (void)sessionViewRightMouseDown:(NSEvent *)event {\n    [_textview rightMouseDown:event];\n}\n\n- (BOOL)sessionViewShouldForwardMouseDownToSuper:(NSEvent *)event {\n    return [_textview mouseDownImpl:event];\n}\n\n- (void)sessionViewDimmingAmountDidChange:(CGFloat)newDimmingAmount {\n    [self sync];\n}\n\n- (BOOL)sessionViewIsVisible {\n    return YES;\n}\n\n- (void)sessionViewDraggingExited:(id<NSDraggingInfo>)sender {\n    [self.delegate sessionDraggingExited:self];\n    [_textview setNeedsDisplay:YES];\n}\n\n- (NSDragOperation)sessionViewDraggingEntered:(id<NSDraggingInfo>)sender {\n    [self.delegate sessionDraggingEntered:self];\n\n    PTYSession *movingSession = [[MovePaneController sharedInstance] session];\n    if (![_delegate session:self shouldAllowDrag:sender]) {\n        return NSDragOperationNone;\n    }\n\n    if (!([[[sender draggingPasteboard] types] indexOfObject:@\"com.iterm2.psm.controlitem\"] != NSNotFound)) {\n        if ([[MovePaneController sharedInstance] isMovingSession:self]) {\n            // Moving me onto myself\n            return NSDragOperationMove;\n        } else if (![movingSession isCompatibleWith:self]) {\n            // We must both be non-tmux or belong to the same session.\n            return NSDragOperationNone;\n        }\n    }\n\n    [self.view createSplitSelectionView];\n    return NSDragOperationMove;\n}\n\n- (BOOL)sessionViewShouldSplitSelectionAfterDragUpdate:(id<NSDraggingInfo>)sender {\n    if ([[[sender draggingPasteboard] types] indexOfObject:iTermMovePaneDragType] != NSNotFound &&\n        [[MovePaneController sharedInstance] isMovingSession:self]) {\n        return NO;\n    }\n    return YES;\n}\n\n- (BOOL)sessionViewPerformDragOperation:(id<NSDraggingInfo>)sender {\n    return [_delegate session:self performDragOperation:sender];\n}\n\n- (NSString *)sessionViewTitle {\n    return _nameController.presentationSessionTitle;\n}\n\n- (NSSize)sessionViewCellSize {\n    return NSMakeSize([_textview charWidth], [_textview lineHeight]);\n}\n\n- (VT100GridSize)sessionViewGridSize {\n    return VT100GridSizeMake(_screen.width, _screen.height);\n}\n\n- (NSColor *)sessionViewBackgroundColor {\n    return [_screen.colorMap colorForKey:kColorMapBackground];\n}\n\n- (BOOL)textViewOrComposerIsFirstResponder {\n    return ((_textview.window.firstResponder == _textview ||\n             [_composerManager dropDownComposerIsFirstResponder]) &&\n            [NSApp isActive] &&\n            _textview.window.isKeyWindow);\n}\n\n- (void)textViewShowFindPanel {\n    const BOOL findPanelWasOpen = self.view.findDriver.viewController.searchIsVisible;\n    [self showFindPanel];\n    if (!findPanelWasOpen) {\n        [self.view.findDriver setFilterHidden:YES];\n    }\n    [[iTermFindPasteboard sharedInstance] updateObservers:nil];\n}\n\n- (void)textViewEnterShortcutNavigationMode {\n    _modeHandler.mode = iTermSessionModeShortcutNavigation;\n}\n\n- (void)textViewExitShortcutNavigationMode {\n    if (_modeHandler.mode == iTermSessionModeShortcutNavigation) {\n        _modeHandler.mode = iTermSessionModeDefault;\n    }\n}\n\n- (void)textViewWillHandleMouseDown:(NSEvent *)event {\n    if (_modeHandler.mode == iTermSessionModeShortcutNavigation) {\n        _modeHandler.mode = iTermSessionModeDefault;\n    }\n}\n\n- (BOOL)textViewPasteFiles:(NSArray<NSString *> *)filenames {\n    NSString *swifty = [iTermAdvancedSettingsModel fileDropCoprocess];\n    if (swifty.length == 0) {\n        return NO;\n    }\n    iTermVariableScope *scope = [[[self variablesScope] copy] autorelease];\n    iTermVariables *frame = [[[iTermVariables alloc] initWithContext:iTermVariablesSuggestionContextNone owner:self] autorelease];\n    [scope addVariables:frame toScopeNamed:nil];\n    NSString *joinedFilenames = [filenames componentsJoinedByString:@\" \"];\n    [scope setValue:joinedFilenames forVariableNamed:@\"filenames\"];\n\n    iTermExpressionEvaluator *eval = [[[iTermExpressionEvaluator alloc] initWithInterpolatedString:swifty\n                                                                                             scope:scope] autorelease];\n    __weak __typeof(self) weakSelf = self;\n    [eval evaluateWithTimeout:5 completion:^(iTermExpressionEvaluator * _Nonnull evaluator) {\n        if (![NSString castFrom:evaluator.value]) {\n            return;\n        }\n        [weakSelf runCoprocessWithCompletion:^(id output, NSError *error){}\n                                 commandLine:evaluator.value\n                                        mute:@YES];\n    }];\n    return YES;\n}\n\n- (NSString *)textViewNaturalLanguageQuery {\n    return [self naturalLanguageQuery];\n}\n\n- (NSString *)naturalLanguageQuery {\n    NSString *query = nil;\n    if (_textview.selection.hasSelection) {\n        query = _textview.selectedText;\n    } else {\n        query = self.currentCommand;\n    }\n    if (query.length == 0) {\n        return nil;\n    }\n    if (query.length >= [iTermAdvancedSettingsModel aiMaxTokens] / 8) {\n        return nil;\n    }\n    return query;\n}\n\n- (void)textViewPerformNaturalLanguageQuery {\n    NSString *query = [self naturalLanguageQuery];\n    if (!query) {\n        NSBeep();\n        return;\n    }\n    [_aiterm release];\n    __weak __typeof(self) weakSelf = self;\n    _aiterm = [[AITermControllerObjC alloc] initWithQuery:query\n                                                    scope:self.variablesScope\n                                                 inWindow:self.view.window\n                                               completion:^(NSArray<NSString *> * _Nullable choices, NSString * _Nullable error) {\n        [weakSelf handleAIChoices:choices error:error];\n    }];\n}\n\n- (void)textViewUpdateTrackingAreas {\n    [self.view updateTrackingAreas];\n}\n\n- (BOOL)textViewShouldShowOffscreenCommandLine {\n    if (_screen.height < 5) {\n        return NO;\n    }\n    if (_modeHandler.mode == iTermSessionModeCopy) {\n        return NO;\n    }\n    return [iTermProfilePreferences boolForKey:KEY_SHOW_OFFSCREEN_COMMANDLINE inProfile:self.profile];\n}\n\n- (BOOL)textViewShouldUseSelectedTextColor {\n    const BOOL dark = self.view.effectiveAppearance.it_isDark;\n    NSString *key = iTermAmendedColorKey(KEY_USE_SELECTED_TEXT_COLOR, self.profile, dark);\n    return [iTermProfilePreferences boolForKey:key inProfile:self.profile];\n}\n\n- (void)handleAIChoices:(NSArray<NSString *> *)choices error:(NSString *)error {\n    if (error) {\n        [iTermWarning showWarningWithTitle:[NSString stringWithFormat:@\"There was a problem with the AI query: %@\", error]\n                                   actions:@[ @\"OK\" ]\n                                 accessory:nil\n                                identifier:nil\n                               silenceable:kiTermWarningTypePersistent\n                                   heading:@\"AI Error\"\n                                    window:self.view.window];\n        return;\n    }\n    if (choices.count == 0) {\n        return;\n    }\n    [self setComposerString:choices[0]];\n    [self.composerManager toggle];\n}\n\n- (BOOL)sessionViewTerminalIsFirstResponder {\n    return [self textViewOrComposerIsFirstResponder];\n}\n\n- (BOOL)sessionViewShouldDimOnlyText {\n    return [iTermPreferences boolForKey:kPreferenceKeyDimOnlyText];\n}\n\n- (NSColor *)sessionViewTabColor {\n    return self.tabColor;\n}\n\n- (NSMenu *)sessionViewContextMenu {\n    return [_textview titleBarMenu];\n}\n\n- (void)sessionViewConfirmAndClose {\n    [[_delegate realParentWindow] closeSessionWithConfirmation:self];\n}\n\n- (void)sessionViewBeginDrag {\n    if (![[MovePaneController sharedInstance] session]) {\n        [[MovePaneController sharedInstance] beginDrag:self];\n    }\n}\n\n- (CGFloat)sessionViewDesiredHeightOfDocumentView {\n    return _textview.desiredHeight + [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins];\n}\n\n- (BOOL)sessionViewShouldUpdateSubviewsFramesAutomatically {\n    [_composerManager layout];\n    \n    // We won't automatically layout the session view's descendents for tmux\n    // tabs. Instead the change gets reported to the tmux server and it will\n    // send us a new layout.\n    if (self.isTmuxClient) {\n        // This makes dragging a split pane in a tmux tab look way better.\n        return ![_delegate sessionBelongsToTmuxTabWhoseSplitsAreBeingDragged];\n    } else {\n        return YES;\n    }\n}\n\n- (NSSize)sessionViewScrollViewWillResize:(NSSize)proposedSize {\n    if ([self isTmuxClient] && ![_delegate sessionBelongsToTmuxTabWhoseSplitsAreBeingDragged]) {\n        NSSize idealSize = [self idealScrollViewSizeWithStyle:_view.scrollview.scrollerStyle];\n        NSSize maximumSize = NSMakeSize(idealSize.width + _textview.charWidth - 1,\n                                        idealSize.height + _textview.lineHeight - 1);\n        DLog(@\"is a tmux client, so tweaking the proposed size. idealSize=%@ maximumSize=%@\",\n             NSStringFromSize(idealSize), NSStringFromSize(maximumSize));\n        return NSMakeSize(MIN(proposedSize.width, maximumSize.width),\n                          MIN(proposedSize.height, maximumSize.height));\n    } else {\n        return proposedSize;\n    }\n}\n\n- (CGFloat)backingScaleFactor {\n    return self.delegate.realParentWindow.window.backingScaleFactor ?: self.view.window.backingScaleFactor;\n}\n\n// Ensure the wrapper is at least as tall as its enclosing scroll view. Mostly this goes unnoticed\n// except in Monterey betas (see issue 9799) but it's the right thing to do regardless.\n- (NSRect)safeFrameForWrapperViewFrame:(NSRect)proposed {\n    const CGFloat minimumHeight = _view.scrollview.contentSize.height;\n    if (NSHeight(proposed) >= minimumHeight) {\n        return proposed;\n    }\n    NSRect frame = proposed;\n    frame.size.height = minimumHeight;\n    DLog(@\"Convert proposed wrapper frame %@ to %@\", NSStringFromRect(proposed), NSStringFromRect(frame));\n    return frame;\n}\n\n- (void)sessionViewScrollViewDidResize {\n    DLog(@\"sessionViewScrollViewDidResize to %@\", NSStringFromRect(_view.scrollview.frame));\n    [self updateTTYSize];\n    _wrapper.frame = [self safeFrameForWrapperViewFrame:_wrapper.frame];\n}\n\n- (BOOL)updateTTYSize {\n    DLog(@\"%@\\n%@\", self, [NSThread callStackSymbols]);\n    return [_shell.winSizeController setGridSize:_screen.size\n                                        viewSize:_screen.viewSize\n                                     scaleFactor:self.backingScaleFactor];\n}\n\n- (iTermStatusBarViewController *)sessionViewStatusBarViewController {\n    return _statusBarViewController;\n}\n\n- (void)textViewOpenComposer:(NSString *)string {\n    [self setComposerString:string];\n    [self.composerManager toggle];\n}\n\n- (BOOL)textViewIsAutoComposerOpen {\n    return [_composerManager dropDownComposerViewIsVisible] && _composerManager.isAutoComposer && !_composerManager.temporarilyHidden;\n}\n\n- (VT100GridRange)textViewLinesToSuppressDrawing {\n    if ([_composerManager dropDownComposerViewIsVisible] && _composerManager.isAutoComposer && !_composerManager.temporarilyHidden) {\n        const NSRect rect = _composerManager.dropDownFrame;\n        const NSRect textViewRect = [_textview convertRect:rect fromView:_view];\n        const VT100GridCoord topLeft = [_textview coordForPoint:textViewRect.origin allowRightMarginOverflow:NO];\n        const VT100GridCoord bottomRight = [_textview coordForPoint:NSMakePoint(NSMaxX(textViewRect) - 1,\n                                                                                NSMaxY(textViewRect) - 1)\n                                           allowRightMarginOverflow:NO];\n        return VT100GridRangeMake(topLeft.y, bottomRight.y - topLeft.y + 1);\n    }\n    return VT100GridRangeMake(0, 0);\n}\n\n- (NSRect)textViewCursorFrameInScreenCoords {\n    const int cx = [self.screen cursorX] - 1;\n    const int cy = [self.screen cursorY];\n    const CGFloat charWidth = [self.textview charWidth];\n    const CGFloat lineHeight = [self.textview lineHeight];\n    NSPoint p = NSMakePoint([iTermPreferences doubleForKey:kPreferenceKeySideMargins] + cx * charWidth,\n                            ([self.screen numberOfLines] - [self.screen height] + cy) * lineHeight);\n    const NSPoint origin = [self.textview.window pointToScreenCoords:[self.textview convertPoint:p toView:nil]];\n    return NSMakeRect(origin.x,\n                      origin.y,\n                      charWidth,\n                      lineHeight);\n}\n\n- (void)textViewDidReceiveSingleClick {\n    _textViewShouldTakeFirstResponder = YES;\n    [_textview.window makeFirstResponder:_textview];\n}\n\n#pragma mark - iTermHotkeyNavigableSession\n\n- (void)sessionHotkeyDidNavigateToSession:(iTermShortcut *)shortcut {\n    [self reveal];\n}\n\n- (BOOL)sessionHotkeyIsAlreadyFirstResponder {\n    return ([NSApp isActive] &&\n            [NSApp keyWindow] == self.textview.window &&\n            self.textview.window.firstResponder == self.textview);\n}\n\n- (BOOL)sessionHotkeyIsAlreadyActiveInNonkeyWindow {\n    if ([NSApp isActive] &&\n        [NSApp keyWindow] == self.textview.window) {\n        return NO;\n    }\n    return [self.delegate sessionIsActiveInSelectedTab:self];\n}\n\n- (void)sessionViewDoubleClickOnTitleBar {\n    [self.delegate sessionDoubleClickOnTitleBar:self];\n}\n\n- (void)sessionViewBecomeFirstResponder {\n    [self.textview.window makeFirstResponder:self.textview];\n}\n\n- (void)sessionViewDidChangeWindow {\n    [self invalidateBlend];\n    [self updateMetalDriver];\n    if (!_shell.ttySizeInitialized) {\n        if ([self updateTTYSize]) {\n            _shell.ttySizeInitialized = YES;\n        }\n    }\n}\n\n- (void)sessionViewAnnouncementDidChange:(SessionView *)sessionView {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (id)temporarilyDisableMetal NS_AVAILABLE_MAC(10_11) {\n    assert(_useMetal);\n    _wrapper.useMetal = NO;\n    _textview.suppressDrawing = NO;\n    [_view setSuppressLegacyDrawing:NO];\n    if (PTYScrollView.shouldDismember) {\n        _view.scrollview.alphaValue = 1;\n    } else {\n        _view.scrollview.contentView.alphaValue = 1;\n    }\n    [self setMetalViewAlphaValue:0];\n    id token = @(_nextMetalDisabledToken++);\n    [_metalDisabledTokens addObject:token];\n    DLog(@\"temporarilyDisableMetal return new token=%@ %@\", token, self);\n    return token;\n}\n\n- (void)drawFrameAndRemoveTemporarilyDisablementOfMetalForToken:(id)token NS_AVAILABLE_MAC(10_11) {\n    DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal %@\", token);\n    if (!_useMetal) {\n        DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal returning early because useMetal is off\");\n        return;\n    }\n    if ([_metalDisabledTokens containsObject:token]) {\n        DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Found token %@\", token);\n        if (_metalDisabledTokens.count > 1) {\n            [_metalDisabledTokens removeObject:token];\n            DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: There are still other tokens remaining: %@\", _metalDisabledTokens);\n            return;\n        }\n    } else {\n        DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Bogus token %@\", token);\n        return;\n    }\n\n    DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal beginning async draw\");\n    [_view.driver drawAsynchronouslyInView:_view.metalView completion:^(BOOL ok) {\n        DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal drawAsynchronouslyInView finished wtih ok=%@\", @(ok));\n        if (![_metalDisabledTokens containsObject:token]) {\n            DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Token %@ is gone, not proceeding.\", token);\n            return;\n        }\n        if (!_view.window) {\n            DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Returning because the view has no window\");\n            return;\n        }\n        if (!_useMetal) {\n            DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Returning because useMetal is off\");\n            return;\n        }\n        if (!ok) {\n            DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Schedule drawFrameAndRemoveTemporarilyDisablementOfMetal to run after a spin of the mainloop\");\n            if (!_delegate) {\n                [self setUseMetal:NO];\n                return;\n            }\n            dispatch_async(dispatch_get_main_queue(), ^{\n                if (![_metalDisabledTokens containsObject:token]) {\n                    DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: [after a spin of the runloop] Token %@ is gone, not proceeding.\", token);\n                    return;\n                }\n                [self drawFrameAndRemoveTemporarilyDisablementOfMetalForToken:token];\n            });\n            return;\n        }\n\n        assert([_metalDisabledTokens containsObject:token]);\n        [_metalDisabledTokens removeObject:token];\n        DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Remove temporarily disablement. Tokens are now %@\", _metalDisabledTokens);\n        if (_metalDisabledTokens.count == 0 && _useMetal) {\n            [self reallyShowMetalViewImmediately];\n        }\n    }];\n}\n\n\n- (void)sessionViewNeedsMetalFrameUpdate {\n    DLog(@\"sessionViewNeedsMetalFrameUpdate %@\", self);\n    if (_metalFrameChangePending) {\n        DLog(@\"sessionViewNeedsMetalFrameUpdate frame change pending, return\");\n        return;\n    }\n\n    _metalFrameChangePending = YES;\n    id token = [self temporarilyDisableMetal];\n    [self.textview setNeedsDisplay:YES];\n    dispatch_async(dispatch_get_main_queue(), ^{\n        DLog(@\"sessionViewNeedsMetalFrameUpdate %@ in dispatch_async\", self);\n        _metalFrameChangePending = NO;\n        [_view reallyUpdateMetalViewFrame];\n        DLog(@\"sessionViewNeedsMetalFrameUpdate will draw farme and remove disablement\");\n        [self drawFrameAndRemoveTemporarilyDisablementOfMetalForToken:token];\n    });\n}\n\n- (void)sessionViewRecreateMetalView {\n    if (_metalDeviceChanging) {\n        return;\n    }\n    DLog(@\"sessionViewRecreateMetalView metalDeviceChanging<-YES\");\n    _metalDeviceChanging = YES;\n    [self.textview setNeedsDisplay:YES];\n    [_delegate sessionUpdateMetalAllowed];\n    dispatch_async(dispatch_get_main_queue(), ^{\n        _metalDeviceChanging = NO;\n        DLog(@\"sessionViewRecreateMetalView metalDeviceChanging<-NO\");\n        [_delegate sessionUpdateMetalAllowed];\n    });\n}\n\n- (void)sessionViewUserScrollDidChange:(BOOL)userScroll {\n    [self.delegate sessionUpdateMetalAllowed];\n    [self updateAutoComposerSeparatorVisibility];\n}\n\n- (void)sessionViewDidChangeHoverURLVisible:(BOOL)visible {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (iTermVariableScope *)sessionViewScope {\n    return self.variablesScope;\n}\n\n- (BOOL)sessionViewUseSeparateStatusBarsPerPane {\n    if (![iTermPreferences boolForKey:kPreferenceKeySeparateStatusBarsPerPane]) {\n        return NO;\n    }\n    if (self.isTmuxClient) {\n        return NO;\n    }\n    return YES;\n}\n\n- (void)sessionViewDidChangeEffectiveAppearance {\n    [self sync];\n    if ([iTermProfilePreferences boolForKey:KEY_USE_SEPARATE_COLORS_FOR_LIGHT_AND_DARK_MODE inProfile:self.profile]) {\n        [self loadColorsFromProfile:self.profile];\n    }\n}\n\n- (BOOL)sessionViewCaresAboutMouseMovement {\n    return [_textview wantsMouseMovementEvents];\n}\n\n- (NSRect)sessionViewOffscreenCommandLineFrameForView:(NSView *)view {\n    return [_textview offscreenCommandLineFrameForView:view];\n}\n\n- (void)sessionViewUpdateComposerFrame {\n    [[self composerManager] layout];\n}\n#pragma mark - iTermCoprocessDelegate\n\n- (void)coprocess:(Coprocess *)coprocess didTerminateWithErrorOutput:(NSString *)errors {\n    if ([Coprocess shouldIgnoreErrorsFromCommand:coprocess.command]) {\n        return;\n    }\n    NSString *command = [[coprocess.command copy] autorelease];\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:[NSString stringWithFormat:@\"Coprocess \u201c%@\u201d terminated with output on stderr.\", coprocess.command]\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"_View Errors\", @\"Ignore Errors from This Command\" ]\n                                                completion:^(int selection) {\n                                                    if (selection == 0) {\n                                                        NSString *filename = [[NSWorkspace sharedWorkspace] temporaryFileNameWithPrefix:@\"coprocess-stderr.\" suffix:@\".txt\"];\n                                                        [errors writeToFile:filename atomically:NO encoding:NSUTF8StringEncoding error:nil];\n                                                        [[NSWorkspace sharedWorkspace] openFile:filename];\n                                                    } else if (selection == 1) {\n                                                        [Coprocess setSilentlyIgnoreErrors:YES fromCommand:command];\n                                                    }\n                                                }];\n    [self queueAnnouncement:announcement identifier:[[NSUUID UUID] UUIDString]];\n}\n\n#pragma mark - iTermUpdateCadenceController\n\n- (void)updateCadenceControllerUpdateDisplay:(iTermUpdateCadenceController *)controller {\n    [self updateDisplayBecause:nil];\n}\n\n- (iTermUpdateCadenceState)updateCadenceControllerState {\n    iTermUpdateCadenceState state;\n    state.active = _active;\n    state.idle = self.isIdle;\n    state.visible = [_delegate sessionBelongsToVisibleTab] && !self.view.window.isMiniaturized;\n\n    if (self.useMetal) {\n        if ([iTermPreferences maximizeMetalThroughput] &&\n            !_screen.terminalSoftAlternateScreenMode) {\n            state.useAdaptiveFrameRate = YES;\n        } else {\n            state.useAdaptiveFrameRate = NO;\n        }\n    } else {\n        if ([iTermAdvancedSettingsModel disableAdaptiveFrameRateInInteractiveApps] &&\n            _screen.terminalSoftAlternateScreenMode) {\n            state.useAdaptiveFrameRate = NO;\n        } else {\n            state.useAdaptiveFrameRate = _useAdaptiveFrameRate;\n        }\n    }\n    state.adaptiveFrameRateThroughputThreshold = _adaptiveFrameRateThroughputThreshold;\n    state.slowFrameRate = self.useMetal ? [iTermAdvancedSettingsModel metalSlowFrameRate] : [iTermAdvancedSettingsModel slowFrameRate];\n    state.liveResizing = _inLiveResize;\n    state.proMotion = [NSProcessInfo it_hasARMProcessor] && [_textview.window.screen it_supportsHighFrameRates];\n    state.estimatedThroughput = _estimatedThroughput;\n    return state;\n}\n\n- (void)cadenceControllerActiveStateDidChange:(BOOL)active {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (BOOL)updateCadenceControllerWindowHasSheet {\n    return self.view.window.sheets.count > 0;\n}\n\n#pragma mark - API\n\n- (void)addContentSubscriber:(id<iTermContentSubscriber>)contentSubscriber {\n    if (!_contentSubscribers) {\n        _contentSubscribers = [[NSMutableArray alloc] init];\n    }\n    [_contentSubscribers addObject:contentSubscriber];\n    [self sync];\n}\n\n- (void)removeContentSubscriber:(id<iTermContentSubscriber>)contentSubscriber {\n    [_contentSubscribers removeObject:contentSubscriber];\n    [self sync];\n}\n\n- (NSString *)stringForLine:(const screen_char_t *)screenChars\n                     length:(int)length\n                  cppsArray:(NSMutableArray<ITMCodePointsPerCell *> *)cppsArray {\n    unichar *characters = iTermMalloc(sizeof(unichar) * length * kMaxParts + 1);\n    ITMCodePointsPerCell *cpps = [[[ITMCodePointsPerCell alloc] init] autorelease];\n    cpps.numCodePoints = 1;\n    cpps.repeats = 0;\n    int o = 0;\n    for (int i = 0; i < length; ++i) {\n        int numCodePoints;\n\n        unichar c = screenChars[i].code;\n        if (!screenChars[i].complexChar && c >= ITERM2_PRIVATE_BEGIN && c <= ITERM2_PRIVATE_END) {\n            numCodePoints = 0;\n        } else if (screenChars[i].image) {\n            numCodePoints = 0;\n        } else {\n            const int len = ExpandScreenChar(&screenChars[i], characters + o);\n            o += len;\n            numCodePoints = len;\n        }\n\n        if (numCodePoints != cpps.numCodePoints && cpps.repeats > 0) {\n            [cppsArray addObject:cpps];\n            cpps = [[[ITMCodePointsPerCell alloc] init] autorelease];\n            cpps.repeats = 0;\n        }\n        cpps.numCodePoints = numCodePoints;\n        cpps.repeats = cpps.repeats + 1;\n    }\n    if (cpps.repeats > 0) {\n        [cppsArray addObject:cpps];\n    }\n    NSString *string = [[[NSString alloc] initWithCharacters:characters length:o] autorelease];\n    free(characters);\n    return string;\n}\n\n- (VT100GridAbsWindowedRange)absoluteWindowedCoordRangeFromLineRange:(ITMLineRange *)lineRange {\n    if (lineRange.hasWindowedCoordRange) {\n        return VT100GridAbsWindowedRangeMake(VT100GridAbsCoordRangeMake(lineRange.windowedCoordRange.coordRange.start.x,\n                                                                        lineRange.windowedCoordRange.coordRange.start.y,\n                                                                        lineRange.windowedCoordRange.coordRange.end.x,\n                                                                        lineRange.windowedCoordRange.coordRange.end.y),\n                                             lineRange.windowedCoordRange.columns.location,\n                                             lineRange.windowedCoordRange.columns.length);\n    }\n    int n = 0;\n    if (lineRange.hasScreenContentsOnly) {\n        n++;\n    }\n    if (lineRange.hasTrailingLines) {\n        n++;\n    }\n    if (n != 1) {\n        return VT100GridAbsWindowedRangeMake(VT100GridAbsCoordRangeMake(-1, -1, -1, -1), -1, -1);\n    }\n\n    NSRange range;\n    if (lineRange.hasScreenContentsOnly) {\n        range.location = [_screen numberOfScrollbackLines] + _screen.totalScrollbackOverflow;\n        range.length = _screen.height;\n    } else if (lineRange.hasTrailingLines) {\n        // Requests are capped at 1M lines to avoid doing too much work.\n        int64_t length = MIN(1000000, MIN(lineRange.trailingLines, _screen.numberOfLines));\n        range.location = _screen.numberOfLines + _screen.totalScrollbackOverflow - length;\n        range.length = length;\n    } else {\n        range = NSMakeRange(NSNotFound, 0);\n    }\n    return VT100GridAbsWindowedRangeMake(VT100GridAbsCoordRangeMake(0, range.location, 0, NSMaxRange(range)), 0, 0);\n}\n\n- (ITMGetBufferResponse *)handleGetBufferRequest:(ITMGetBufferRequest *)request {\n    ITMGetBufferResponse *response = [[[ITMGetBufferResponse alloc] init] autorelease];\n\n    const VT100GridAbsWindowedRange windowedRange = [self absoluteWindowedCoordRangeFromLineRange:request.lineRange];\n    if (windowedRange.coordRange.start.x < 0) {\n        response.status = ITMGetBufferResponse_Status_InvalidLineRange;\n        return nil;\n    }\n\n    const VT100GridWindowedRange range = VT100GridWindowedRangeFromVT100GridAbsWindowedRange(windowedRange, _screen.totalScrollbackOverflow);\n    iTermTextExtractor *extractor = [iTermTextExtractor textExtractorWithDataSource:_screen];\n    __block int firstIndex = -1;\n    __block int lastIndex = -1;\n    __block const screen_char_t *line = nil;\n    BOOL (^handleEol)(unichar, int, int) = ^BOOL(unichar code, int numPreceedingNulls, int linenumber) {\n        ITMLineContents *lineContents = [[[ITMLineContents alloc] init] autorelease];\n        lineContents.text = [self stringForLine:line + firstIndex\n                                         length:lastIndex - firstIndex\n                                      cppsArray:lineContents.codePointsPerCellArray];\n        switch (code) {\n            case EOL_HARD:\n                lineContents.continuation = ITMLineContents_Continuation_ContinuationHardEol;\n                break;\n\n            case EOL_SOFT:\n            case EOL_DWC:\n                lineContents.continuation = ITMLineContents_Continuation_ContinuationSoftEol;\n                break;\n        }\n        [response.contentsArray addObject:lineContents];\n        firstIndex = lastIndex = -1;\n        line = nil;\n        return NO;\n    };\n    [extractor enumerateCharsInRange:range\n                           charBlock:^BOOL(const screen_char_t *currentLine, screen_char_t theChar, iTermExternalAttribute *ea, VT100GridCoord coord) {\n                               line = currentLine;\n                               if (firstIndex < 0) {\n                                   firstIndex = coord.x;\n                               }\n                               lastIndex = coord.x + 1;\n                               line = currentLine;\n                               return NO;\n                           }\n                            eolBlock:^BOOL(unichar code, int numPreceedingNulls, int line) {\n                                return handleEol(code, numPreceedingNulls, line);\n                            }];\n    if (line) {\n        handleEol(EOL_SOFT, 0, 0);\n    }\n    response.cursor = [[[ITMCoord alloc] init] autorelease];\n    response.cursor.x = _screen.currentGrid.cursor.x;\n    response.cursor.y = _screen.currentGrid.cursor.y + _screen.numberOfScrollbackLines + _screen.totalScrollbackOverflow;\n\n    response.status = ITMGetBufferResponse_Status_Ok;\n    response.windowedCoordRange.coordRange.start.x = windowedRange.coordRange.start.x;\n    response.windowedCoordRange.coordRange.start.y = windowedRange.coordRange.start.y;\n    response.windowedCoordRange.coordRange.end.x = windowedRange.coordRange.end.x;\n    response.windowedCoordRange.coordRange.end.y = windowedRange.coordRange.end.y;\n    response.windowedCoordRange.columns.location = windowedRange.columnWindow.location;\n    response.windowedCoordRange.columns.length = windowedRange.columnWindow.length;\n\n    return response;\n}\n\n- (void)handleListPromptsRequest:(ITMListPromptsRequest *)request completion:(void (^)(ITMListPromptsResponse *))completion {\n    ITMListPromptsResponse *response = [[[ITMListPromptsResponse alloc] init] autorelease];\n    [_screen enumeratePromptsFrom:request.hasFirstUniqueId ? request.firstUniqueId : nil\n                               to:request.hasLastUniqueId ? request.lastUniqueId : nil\n                            block:^(id<VT100ScreenMarkReading> mark) {\n        [response.uniquePromptIdArray addObject:mark.guid];\n    }];\n    completion(response);\n}\n\n- (void)handleGetPromptRequest:(ITMGetPromptRequest *)request completion:(void (^)(ITMGetPromptResponse *response))completion {\n    id<VT100ScreenMarkReading> mark;\n    if (request.hasUniquePromptId) {\n        mark = [_screen promptMarkWithGUID:request.uniquePromptId];\n    } else {\n        mark = [_screen lastPromptMark];\n    }\n    ITMGetPromptResponse *response = [self getPromptResponseForMark:mark];\n    completion(response);\n}\n\n- (ITMGetPromptResponse *)getPromptResponseForMark:(id<VT100ScreenMarkReading>)mark {\n    ITMGetPromptResponse *response = [[[ITMGetPromptResponse alloc] init] autorelease];\n    if (!mark) {\n        response.status = ITMGetPromptResponse_Status_PromptUnavailable;\n        return response;\n    }\n\n    if (mark.promptRange.start.x >= 0) {\n        response.promptRange = [[[ITMCoordRange alloc] init] autorelease];\n        response.promptRange.start.x = mark.promptRange.start.x;\n        response.promptRange.start.y = mark.promptRange.start.y;\n        response.promptRange.end.x = mark.promptRange.end.x;\n        response.promptRange.end.y = mark.promptRange.end.y;\n    }\n    if (mark.commandRange.start.x >= 0) {\n        response.commandRange = [[[ITMCoordRange alloc] init] autorelease];\n        response.commandRange.start.x = mark.commandRange.start.x;\n        response.commandRange.start.y = mark.commandRange.start.y;\n        response.commandRange.end.x = mark.commandRange.end.x;\n        response.commandRange.end.y = mark.commandRange.end.y;\n    }\n    if (mark.outputStart.x >= 0) {\n        response.outputRange = [[[ITMCoordRange alloc] init] autorelease];\n        response.outputRange.start.x = mark.outputStart.x;\n        response.outputRange.start.y = mark.outputStart.y;\n        response.outputRange.end.x = _screen.currentGrid.cursor.x;\n        response.outputRange.end.y = _screen.currentGrid.cursor.y + _screen.numberOfScrollbackLines + _screen.totalScrollbackOverflow;\n    }\n\n    response.command = mark.command ?: self.currentCommand;\n    response.status = ITMGetPromptResponse_Status_Ok;\n    response.workingDirectory = [_screen workingDirectoryOnLine:mark.promptRange.end.y] ?: self.lastDirectory;\n    if (mark.hasCode) {\n        response.promptState = ITMGetPromptResponse_State_Finished;\n        response.exitStatus = mark.code;\n    } else if (mark.outputStart.x >= 0) {\n        response.promptState = ITMGetPromptResponse_State_Running;\n    } else {\n        response.promptState = ITMGetPromptResponse_State_Editing;\n    }\n    response.uniquePromptId = mark.guid;\n    return response;\n}\n\n- (ITMSetProfilePropertyResponse_Status)handleSetProfilePropertyForAssignments:(NSArray<iTermTuple<NSString *, id> *> *)tuples\n                                                            scriptHistoryEntry:(iTermScriptHistoryEntry *)scriptHistoryEntry {\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    for (iTermTuple<NSString *, id> *tuple in tuples) {\n        NSString *key = tuple.firstObject;\n        id value = tuple.secondObject;\n        if (![iTermProfilePreferences valueIsLegal:value forKey:key]) {\n            XLog(@\"Value %@ is not legal for key %@\", value, key);\n            [scriptHistoryEntry addOutput:[NSString stringWithFormat:@\"Value %@ is not legal type for key %@\\n\", value, key]\n                               completion:^{}];\n            return ITMSetProfilePropertyResponse_Status_RequestMalformed;\n        }\n        dict[key] = value;\n    }\n\n    [self setSessionSpecificProfileValues:dict];\n    return ITMSetProfilePropertyResponse_Status_Ok;\n}\n\n- (ITMGetProfilePropertyResponse *)handleGetProfilePropertyForKeys:(NSArray<NSString *> *)keys {\n    ITMGetProfilePropertyResponse *response = [[[ITMGetProfilePropertyResponse alloc] init] autorelease];\n    if (!keys.count) {\n        return [self handleGetProfilePropertyForKeys:[iTermProfilePreferences allKeys]];\n    }\n\n    for (NSString *key in keys) {\n        id value = [iTermProfilePreferences objectForKey:key inProfile:self.profile];\n        if (value) {\n            NSString *jsonString = [iTermProfilePreferences jsonEncodedValueForKey:key inProfile:self.profile];\n            if (jsonString) {\n                ITMProfileProperty *property = [[[ITMProfileProperty alloc] init] autorelease];\n                property.key = key;\n                property.jsonValue = jsonString;\n                [response.propertiesArray addObject:property];\n            }\n        }\n    }\n    response.status = ITMGetProfilePropertyResponse_Status_Ok;\n    return response;\n}\n\n#pragma mark - iTermSessionNameControllerDelegate\n\n- (NSString *)sessionNameControllerUniqueIdentifier {\n    iTermTitleComponents components = [iTermProfilePreferences unsignedIntegerForKey:KEY_TITLE_COMPONENTS inProfile:_profile];\n    if (components != iTermTitleComponentsCustom) {\n        return iTermSessionNameControllerSystemTitleUniqueIdentifier;\n    }\n    \n    iTermTuple<NSString *, NSString *> *tuple = [iTermTuple fromPlistValue:[iTermProfilePreferences stringForKey:KEY_TITLE_FUNC inProfile:_profile]];\n    if (tuple.firstObject && tuple.secondObject) {\n        return tuple.secondObject;\n    } else {\n        return nil;\n    }\n}\n\n- (void)sessionNameControllerNameWillChangeTo:(NSString *)newName {\n    [self.variablesScope setValue:newName forVariableNamed:iTermVariableKeySessionName];\n}\n\n- (void)sessionNameControllerPresentationNameDidChangeTo:(NSString *)presentationName {\n    [_delegate nameOfSession:self didChangeTo:presentationName];\n    [self.view setTitle:presentationName];\n\n    // get the session submenu to be rebuilt\n    if ([[iTermController sharedInstance] currentTerminal] == [_delegate parentWindow]) {\n        [[NSNotificationCenter defaultCenter] postNotificationName:@\"iTermNameOfSessionDidChange\"\n                                                            object:[_delegate parentWindow]\n                                                          userInfo:nil];\n    }\n    [self.variablesScope setValue:presentationName forVariableNamed:iTermVariableKeySessionPresentationName];\n    [_textview setBadgeLabel:[self badgeLabel]];\n}\n\n- (void)sessionNameControllerDidChangeWindowTitle {\n    if ([_delegate sessionBelongsToVisibleTab]) {\n        [[_delegate parentWindow] setWindowTitle];\n    }\n}\n\n- (iTermSessionFormattingDescriptor *)sessionNameControllerFormattingDescriptor {\n    iTermSessionFormattingDescriptor *descriptor = [[[iTermSessionFormattingDescriptor alloc] init] autorelease];\n    descriptor.isTmuxGateway = self.isTmuxGateway;\n    descriptor.tmuxClientName = _tmuxController.clientName;\n    descriptor.haveTmuxController = (self.tmuxController != nil);\n    descriptor.tmuxWindowName = [_delegate tmuxWindowName];\n    return descriptor;\n}\n\n- (iTermVariableScope *)sessionNameControllerScope {\n    return self.variablesScope;\n}\n\n#pragma mark - Variable Change Handlers\n\n- (void)jobPidDidChange {\n    // Avoid requesting an update before we know the name because doing so delays updating it when\n    // we finally get the name since it's rate-limited.\n    if (self.shell.pid > 0 || [[[self variablesScope] valueForVariableName:@\"jobName\"] length] > 0) {\n        [self.processInfoProvider setNeedsUpdate:YES];\n    }\n    if ([_graphicSource updateImageForProcessID:self.shell.pid enabled:[self shouldShowTabGraphic] processInfoProvider:self.processInfoProvider]) {\n        [self.delegate sessionDidChangeGraphic:self shouldShow:self.shouldShowTabGraphic image:self.tabGraphic];\n    }\n    [self.delegate sessionJobDidChange:self];\n}\n\n#pragma mark - iTermEchoProbeDelegate\n\n- (void)echoProbe:(iTermEchoProbe *)echoProbe writeString:(NSString *)string {\n    if (self.tmuxMode == TMUX_GATEWAY) {\n        return;\n    }\n    [self writeTaskNoBroadcast:string];\n}\n\n- (void)echoProbe:(iTermEchoProbe *)echoProbe writeData:(NSData *)data {\n    if (self.tmuxMode == TMUX_GATEWAY) {\n        return;\n    }\n    [self writeLatin1EncodedData:data broadcastAllowed:NO reporting:NO];\n}\n\n- (void)echoProbeDidFail:(iTermEchoProbe *)echoProbe {\n    // Not allowed to use a runloop in a side-effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self sendPasswordAfterGettingPermission];\n    });\n}\n\n- (void)sendPasswordAfterGettingPermission {\n    BOOL ok = ([iTermWarning showWarningWithTitle:@\"Are you really at a password prompt? It looks \"\n                @\"like what you're typing is echoed to the screen.\"\n                                          actions:@[ @\"Cancel\", @\"Enter Password\" ]\n                                       identifier:nil\n                                      silenceable:kiTermWarningTypePersistent\n                                           window:self.view.window] == kiTermWarningSelection1);\n    if (ok) {\n        [_screen sendPasswordInEchoProbe];\n    } else {\n        [self incrementDisableFocusReporting:-1];\n        [_screen resetEchoProbe];\n    }\n}\n\n- (void)echoProbeDidSucceed:(iTermEchoProbe *)echoProbe {\n    [self incrementDisableFocusReporting:-1];\n}\n\n- (BOOL)echoProbeShouldSendPassword:(iTermEchoProbe *)echoProbe {\n    return YES;\n}\n\n- (void)echoProbeDelegateWillChange:(iTermEchoProbe *)echoProbe {\n}\n\n#pragma mark - iTermBackgroundDrawingHelperDelegate\n\n- (SessionView *)backgroundDrawingHelperView {\n    return _view;\n}\n\n- (iTermImageWrapper *)backgroundDrawingHelperImage {\n    return [self effectiveBackgroundImage];\n}\n\n- (BOOL)backgroundDrawingHelperUseTransparency {\n    return _textview.useTransparency;\n}\n\n- (CGFloat)backgroundDrawingHelperTransparency {\n    return _textview.transparency;\n}\n\n- (iTermBackgroundImageMode)backgroundDrawingHelperBackgroundImageMode {\n    return [self effectiveBackgroundImageMode];\n}\n\n- (NSColor *)backgroundDrawingHelperDefaultBackgroundColor {\n    return [self processedBackgroundColor];\n}\n\n- (CGFloat)backgroundDrawingHelperBlending {\n    return self.effectiveBlend;\n}\n\n#pragma mark - iTermStatusBarViewControllerDelegate\n\n- (NSColor *)textColorForStatusBar {\n    return [[iTermTheme sharedInstance] statusBarTextColorForEffectiveAppearance:_view.effectiveAppearance\n                                                                        colorMap:_screen.colorMap\n                                                                        tabStyle:[self.view.window.ptyWindow it_tabStyle]\n                                                                   mainAndActive:(self.view.window.isMainWindow && NSApp.isActive)];\n}\n\n- (BOOL)statusBarHasDarkBackground {\n    if (self.view.window.ptyWindow.it_terminalWindowUseMinimalStyle) {\n        NSColor *color = self.view.window.ptyWindow.it_terminalWindowDecorationControlColor;\n        return [color isDark];\n    }\n    // This is called early in the appearance change process and subviews of the contentview aren't\n    // up to date yet.\n    return self.view.window.contentView.effectiveAppearance.it_isDark;\n}\n\n- (BOOL)statusBarRevealComposer {\n    [self.composerManager revealMinimal];\n    return NO;\n}\n\n- (NSColor *)statusBarDefaultTextColor {\n    return [self textColorForStatusBar];\n}\n\n- (NSColor *)statusBarSeparatorColor {\n    if (self.view.window.ptyWindow.it_terminalWindowUseMinimalStyle) {\n        return nil;\n    }\n    NSColor *color = _statusBarViewController.layout.advancedConfiguration.separatorColor;\n    if (color) {\n        return color;\n    }\n\n    const CGFloat alpha = 0.25;\n    NSAppearance *appearance = nil;\n    switch ((iTermPreferencesTabStyle)[iTermPreferences intForKey:kPreferenceKeyTabStyle]) {\n        case TAB_STYLE_DARK:\n        case TAB_STYLE_DARK_HIGH_CONTRAST:\n            appearance = [NSAppearance appearanceNamed:NSAppearanceNameDarkAqua];\n            break;\n        case TAB_STYLE_LIGHT:\n        case TAB_STYLE_LIGHT_HIGH_CONTRAST:\n            appearance = [NSAppearance appearanceNamed:NSAppearanceNameAqua];\n            break;\n        case TAB_STYLE_AUTOMATIC:\n        case TAB_STYLE_COMPACT:\n        case TAB_STYLE_MINIMAL:  // shouldn't happen\n            appearance = [NSApp effectiveAppearance];\n            break;\n    }\n    return [[[self textColorForStatusBar] it_colorWithAppearance:appearance] colorWithAlphaComponent:alpha];\n}\n\n- (NSColor *)statusBarBackgroundColor {\n    return _statusBarViewController.layout.advancedConfiguration.backgroundColor;\n}\n\n- (void)updateStatusBarStyle {\n    [_statusBarViewController updateColors];\n    [self invalidateStatusBar];\n}\n\n- (NSFont *)statusBarTerminalFont {\n    return _textview.fontTable.asciiFont.font;\n}\n\n- (NSColor *)statusBarTerminalBackgroundColor {\n    return [self processedBackgroundColor];\n}\n\n- (id<ProcessInfoProvider>)statusBarProcessInfoProvider {\n    return self.processInfoProvider;\n}\n\n- (void)statusBarWriteString:(NSString *)string {\n    [self writeTask:string];\n}\n\n- (void)statusBarDidUpdate {\n    [_view updateFindDriver];\n}\n\n- (void)statusBarOpenPreferencesToComponent:(nullable id<iTermStatusBarComponent>)component {\n    PreferencePanel *panel;\n    NSString *guid;\n    if (self.isDivorced && ([_overriddenFields containsObject:KEY_STATUS_BAR_LAYOUT] ||\n                            [_overriddenFields containsObject:KEY_SHOW_STATUS_BAR])) {\n        panel = [PreferencePanel sessionsInstance];\n        guid = _profile[KEY_GUID];\n    } else {\n        panel = [PreferencePanel sharedInstance];\n        guid = _originalProfile[KEY_GUID];\n    }\n    [panel openToProfileWithGuid:guid\n  andEditComponentWithIdentifier:component.statusBarComponentIdentifier\n                            tmux:self.isTmuxClient\n                           scope:self.variablesScope];\n    [panel.window makeKeyAndOrderFront:nil];\n}\n\n- (void)statusBarDisable {\n    if (self.isDivorced) {\n        [self setSessionSpecificProfileValues:@{ KEY_SHOW_STATUS_BAR: @NO }];\n    } else {\n        [iTermProfilePreferences setBool:NO\n                                  forKey:KEY_SHOW_STATUS_BAR\n                               inProfile:self.profile\n                                   model:[ProfileModel sharedInstance]];\n    }\n    [[NSNotificationCenter defaultCenter] postNotificationName:kSessionProfileDidChange\n                                                        object:_profile[KEY_GUID]];\n}\n\n- (BOOL)statusBarCanDragWindow {\n    const BOOL inTitleBar = self.view.statusBarIsInPaneTitleBar;\n    if (inTitleBar) {\n        return [self.delegate sessionShouldDragWindowByPaneTitleBar:self];\n    }\n    return YES;\n}\n\n- (iTermActivityInfo)statusBarActivityInfo {\n    return _activityInfo;\n}\n\n- (void)statusBarSetFilter:(NSString *)query {\n    PTYSession *synthetic = [self.delegate sessionSyntheticSessionFor:self];\n    if (synthetic) {\n        [synthetic statusBarSetFilter:query];\n        return;\n    }\n    if (query) {\n        [self.delegate session:self setFilter:query];\n    } else {\n        [self stopFiltering];\n    }\n}\n\n// Called on the synthetic session.\n- (void)stopFiltering {\n    [self setFilterProgress:0];\n    [self.liveSession removeContentSubscriber:_asyncFilter];\n    [_asyncFilter cancel];\n    [_asyncFilter autorelease];\n    _asyncFilter = nil;\n    if ([_statusBarViewController.temporaryRightComponent isKindOfClass:[iTermStatusBarFilterComponent class]]) {\n        _statusBarViewController.temporaryRightComponent = nil;\n    }\n    [self.delegate session:self setFilter:nil];\n    [_textview.window makeFirstResponder:_textview];\n}\n\n- (ProfileModel *)profileModel {\n    if (self.isDivorced && [_overriddenFields containsObject:KEY_STATUS_BAR_LAYOUT]) {\n        return [ProfileModel sessionsInstance];\n    } else {\n        return [ProfileModel sharedInstance];\n    }\n}\n\n- (void)statusBarSetLayout:(nonnull iTermStatusBarLayout *)layout {\n    [iTermProfilePreferences setObject:[layout dictionaryValue]\n                                forKey:KEY_STATUS_BAR_LAYOUT\n                             inProfile:self.originalProfile\n                                 model:[self profileModel]];\n}\n\n- (void)statusBarPerformAction:(iTermAction *)action {\n    [self applyAction:action];\n}\n\n- (void)statusBarEditActions {\n    [self.delegate sessionEditActions];\n}\n\n- (void)statusBarEditSnippets {\n    [self.delegate sessionEditSnippets];\n}\n\n- (void)statusBarResignFirstResponder {\n    [_textview.window makeFirstResponder:_textview];\n}\n\n- (void)statusBarReportScriptingError:(NSError *)error\n                        forInvocation:(NSString *)invocation\n                               origin:(NSString *)origin {\n    [PTYSession reportFunctionCallError:error\n                          forInvocation:invocation\n                                 origin:origin\n                                 window:self.delegate.realParentWindow.window];\n}\n\n- (id<iTermTriggersDataSource>)statusBarTriggersDataSource {\n    return self;\n}\n\n#pragma mark - iTermTriggersDataSource\n\n- (NSInteger)numberOfTriggers {\n    return _config.triggerProfileDicts.count;\n}\n\n- (NSArray<NSString *> *)triggerNames {\n    return [_config.triggerProfileDicts mapWithBlock:^id(NSDictionary *dict) {\n        Trigger *trigger = [Trigger triggerFromDict:dict];\n        return [NSString stringWithFormat:@\"%@ \u2014 %@\", [[[trigger class] title] stringByRemovingSuffix:@\"\u2026\"], trigger.regex];\n    }];\n}\n\n- (NSIndexSet *)enabledTriggerIndexes {\n    return [_config.triggerProfileDicts it_indexSetWithObjectsPassingTest:^BOOL(NSDictionary *triggerDict) {\n        return ![triggerDict[kTriggerDisabledKey] boolValue];\n    }];\n}\n\n- (void)addTrigger {\n    [self openAddTriggerViewControllerWithText:_textview.selectedText ?: @\"\"];\n}\n\n- (void)editTriggers {\n    [self openTriggersViewController];\n}\n\n- (void)toggleTriggerAtIndex:(NSInteger)index {\n    [self toggleTriggerEnabledAtIndex:index];\n}\n\n#pragma mark - iTermMetaFrustrationDetectorDelegate\n\n- (void)metaFrustrationDetectorDidDetectFrustrationForLeftOption {\n    [self maybeOfferToSetOptionAsEscForLeft:YES];\n}\n\n- (void)metaFrustrationDetectorDidDetectFrustrationForRightOption {\n    [self maybeOfferToSetOptionAsEscForLeft:NO];\n}\n\n- (void)maybeOfferToSetOptionAsEscForLeft:(BOOL)left {\n    if (self.isDivorced) {\n        // This gets gnarly. Let's be conservative.\n        return;\n    }\n    NSString *neverPromptUserDefaultsKey = @\"NoSyncNeverPromptToChangeOption\";\n    if ([[NSUserDefaults standardUserDefaults] boolForKey:neverPromptUserDefaultsKey]) {\n        // User said never to ask.\n        return;\n    }\n\n    NSString *leftOrRight;\n    NSString *profileKey;\n    if (left) {\n        leftOrRight = @\"left\";\n        profileKey = KEY_OPTION_KEY_SENDS;\n    } else {\n        leftOrRight = @\"right\";\n        profileKey = KEY_RIGHT_OPTION_KEY_SENDS;\n    }\n\n    if ([iTermProfilePreferences integerForKey:profileKey inProfile:self.profile] != OPT_NORMAL) {\n        // There's already a non-default setting.\n        return;\n    }\n\n    NSArray<NSString *> *actions;\n    NSInteger thisProfile = 0;\n    NSInteger allProfiles = -1;\n    if ([[[ProfileModel sharedInstance] bookmarks] count] == 1) {\n        actions = @[ @\"Yes\", @\"Stop Asking\" ];\n    } else {\n        actions = @[ @\"Change This Profile\", @\"Change All Profiles\", @\"Stop Asking\" ];\n        allProfiles = 1;\n    }\n\n    Profile *profileToChange = [[ProfileModel sharedInstance] bookmarkWithGuid:self.profile[KEY_GUID]];\n    if (!profileToChange) {\n        return;\n    }\n\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:[NSString stringWithFormat:@\"You seem frustrated. Would you like the %@ option key to send esc+keystroke?\", leftOrRight]\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:actions\n                                                completion:^(int selection) {\n                                                    if (selection < 0) {\n                                                        // Programmatic dismissal or clicked the x button.\n                                                        return;\n                                                    }\n                                                    if (selection == thisProfile) {\n                                                        [iTermProfilePreferences setInt:OPT_ESC forKey:profileKey inProfile:profileToChange model:[ProfileModel sharedInstance]];\n                                                    } else if (selection == allProfiles) {\n                                                        for (Profile *profile in [[[[ProfileModel sharedInstance] bookmarks] copy] autorelease]) {\n                                                            [iTermProfilePreferences setInt:OPT_ESC forKey:profileKey inProfile:profile model:[ProfileModel sharedInstance]];\n                                                        }\n                                                    } else {\n                                                        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:neverPromptUserDefaultsKey];\n                                                    }\n                                                }];\n    static NSString *const identifier = @\"OfferToChangeOptionKeyToSendESC\";\n    [self queueAnnouncement:announcement identifier:identifier];\n}\n\n#pragma mark - iTermWorkingDirectoryPollerDelegate\n\n- (BOOL)useLocalDirectoryPollerResult {\n    if (_workingDirectoryPollerDisabled) {\n        DLog(@\"Working directory poller disabled\");\n        return NO;\n    }\n    if (_shouldExpectCurrentDirUpdates && ![iTermAdvancedSettingsModel disablePotentiallyInsecureEscapeSequences]) {\n        DLog(@\"Should not poll for working directory: shell integration used\");\n        return NO;\n    }\n    if (_screen.terminalSoftAlternateScreenMode) {\n        DLog(@\"Should not poll for working directory: soft alternate screen mode\");\n    }\n    DLog(@\"Should poll for working directory.\");\n    return YES;\n}\n\n- (BOOL)workingDirectoryPollerShouldPoll {\n    return YES;\n}\n\n- (pid_t)workingDirectoryPollerProcessID {\n    return _shell.pid;;\n}\n\n- (void)workingDirectoryPollerDidFindWorkingDirectory:(NSString *)pwd invalidated:(BOOL)invalidated {\n    DLog(@\"workingDirectoryPollerDidFindWorkingDirectory:%@ invalidated:%@ self=%@\", pwd, @(invalidated), self);\n    if (invalidated && _lastLocalDirectoryWasPushed && _lastLocalDirectory != nil) {\n        DLog(@\"Ignore local directory poller's invalidated result when we have a pushed last local directory. _lastLocalDirectory=%@ _lastLocalDirectoryWasPushed=%@\",\n             _lastLocalDirectory, @(_lastLocalDirectoryWasPushed));\n        return;\n    }\n    if (invalidated || ![self useLocalDirectoryPollerResult]) {\n        DLog(@\"Not creating a mark. invalidated=%@\", @(invalidated));\n        if (self.lastLocalDirectory != nil && self.lastLocalDirectoryWasPushed) {\n            DLog(@\"Last local directory (%@) was pushed, not changing it.\", self.lastLocalDirectory);\n            return;\n        }\n        DLog(@\"Since last local driectory was not pushed, update it.\");\n        // This is definitely a local directory. It may have been invalidated because we got a push\n        // for a remote directory, but it's still useful to know the local directory for the purposes\n        // of session restoration.\n        self.lastLocalDirectory = pwd;\n        self.lastLocalDirectoryWasPushed = NO;\n\n        // Do not call setLastDirectory:remote:pushed: because there's no sense updating the path\n        // variable for an invalidated update when we might have a better remote working directory.\n        //\n        // Update the proxy icon since it only cares about the local directory.\n        [_delegate sessionCurrentDirectoryDidChange:self];\n        return;\n    }\n\n    if (!pwd) {\n        DLog(@\"nil result. Don't create a mark\");\n        return;\n    }\n\n    // Updates the mark\n    DLog(@\"Will create a mark\");\n    const long absLine = _screen.lineNumberOfCursor + _screen.totalScrollbackOverflow;\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState setWorkingDirectory:pwd\n                                onAbsLine:absLine\n                                   pushed:NO\n                                    token:[[mutableState.setWorkingDirectoryOrderEnforcer newToken] autorelease]];\n    }];\n\n}\n\n#pragma mark - iTermStandardKeyMapperDelegate\n\n- (void)standardKeyMapperWillMapKey:(iTermStandardKeyMapper *)standardKeyMapper {\n    // Don't use terminalEncoding because it may not be initialized yet.\n    iTermStandardKeyMapperConfiguration *configuration = [[[iTermStandardKeyMapperConfiguration alloc] init] autorelease];\n\n    configuration.outputFactory = _screen.terminalOutput;\n    configuration.encoding = [iTermProfilePreferences unsignedIntegerForKey:KEY_CHARACTER_ENCODING inProfile:self.profile];\n    configuration.leftOptionKey = self.optionKey;\n    configuration.rightOptionKey = self.rightOptionKey;\n    configuration.screenlike = self.isTmuxClient;\n    standardKeyMapper.configuration = configuration;\n}\n\n#pragma mark - iTermTermkeyKeyMapperDelegate\n\n- (void)termkeyKeyMapperWillMapKey:(iTermTermkeyKeyMapper *)termkeyKeyMaper {\n    // Don't use terminalEncoding because it may not be initialized yet.\n    iTermTermkeyKeyMapperConfiguration configuration = {\n        .encoding = [iTermProfilePreferences unsignedIntegerForKey:KEY_CHARACTER_ENCODING inProfile:self.profile],\n        .leftOptionKey = self.optionKey,\n        .rightOptionKey = self.rightOptionKey,\n        .applicationCursorMode = _screen.terminalOutput.cursorMode,\n        .applicationKeypadMode = _screen.terminalOutput.keypadMode\n    };\n    termkeyKeyMaper.configuration = configuration;\n}\n\n#pragma mark - iTermBadgeLabelDelegate\n\n- (NSFont *)badgeLabelFontOfSize:(CGFloat)pointSize {\n    NSFontManager *fontManager = [NSFontManager sharedFontManager];\n    NSFont *font = [NSFont fontWithName:_badgeFontName size:pointSize];\n    if (!font) {\n        font = [NSFont fontWithName:@\"Helvetica\" size:pointSize];\n    }\n    if ([iTermAdvancedSettingsModel badgeFontIsBold]) {\n        font = [fontManager convertFont:font\n                            toHaveTrait:NSBoldFontMask];\n    }\n    return font;\n}\n\n- (NSSize)badgeLabelSizeFraction {\n    return _badgeLabelSizeFraction;\n}\n\n#pragma mark - iTermShortcutNavigationModeHandlerDelegate\n\n- (void (^)(void))shortcutNavigationActionForKeyEquivalent:(NSString *)characters {\n    return [[_textview contentNavigationShortcuts] objectPassingTest:^BOOL(iTermContentNavigationShortcut *shortcut, NSUInteger index, BOOL *stop) {\n        if (shortcut.view.terminating) {\n            return NO;\n        }\n        return [shortcut.keyEquivalent caseInsensitiveCompare:characters] == NSOrderedSame;\n    }].action;\n}\n\n- (void)shortcutNavigationDidComplete {\n    [_textview removeContentNavigationShortcuts];\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.shortcutNavigationMode = NO;\n    }];\n}\n\n- (void)shortcutNavigationDidBegin {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.shortcutNavigationMode = YES;\n    }];\n}\n\n#pragma mark - iTermCopyModeHandlerDelegate\n\n- (void)copyModeHandlerDidChangeEnabledState:(iTermCopyModeHandler *)handler NOT_COPY_FAMILY {\n    [_textview setNeedsDisplay:YES];\n    const BOOL enabled = handler.enabled;\n    if (enabled) {\n        [_textview.window makeFirstResponder:_textview];\n    } else {\n        if (self.haveAutoComposer) {\n            [_composerManager makeDropDownComposerFirstResponder];\n        }\n\n        if (_textview.selection.live) {\n            [_textview.selection endLiveSelection];\n        }\n        [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            [mutableState scheduleTokenExecution];\n        }];\n    }\n    [_composerManager setTemporarilyHidden:handler.enabled];\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.copyMode = enabled;\n    }];\n}\n\n- (iTermCopyModeState *)copyModeHandlerCreateState:(iTermCopyModeHandler *)handler NOT_COPY_FAMILY {\n    iTermCopyModeState *state = [[[iTermCopyModeState alloc] init] autorelease];\n    state.coord = VT100GridCoordMake(_screen.cursorX - 1,\n                                     _screen.cursorY - 1 + _screen.numberOfScrollbackLines);\n    state.numberOfLines = _screen.numberOfLines;\n    state.textView = _textview;\n\n    if (_textview.selection.allSubSelections.count == 1) {\n        iTermSubSelection *sub = _textview.selection.allSubSelections.firstObject;\n        VT100GridAbsCoordRangeTryMakeRelative(sub.absRange.coordRange,\n                                              _screen.totalScrollbackOverflow,\n                                              ^(VT100GridCoordRange range) {\n            [_textview.window makeFirstResponder:_textview];\n            state.selecting = YES;\n            state.start = range.start;\n            state.coord = range.end;\n        });\n    }\n    [_textview scrollLineNumberRangeIntoView:VT100GridRangeMake(state.coord.y, 1)];\n    return state;\n}\n\n- (void)copyModeHandler:(iTermCopyModeHandler *)handler redrawLine:(int)line NOT_COPY_FAMILY {\n    [self.textview setNeedsDisplayOnLine:line];\n}\n\n- (void)copyModeHandlerShowFindPanel:(iTermCopyModeHandler *)handler {\n    [self showFindPanel];\n}\n\n- (void)copyModeHandler:(iTermCopyModeHandler *)handler revealLine:(int)line NOT_COPY_FAMILY {\n    [_textview scrollLineNumberRangeIntoView:VT100GridRangeMake(line, 1)];\n}\n\n- (void)copyModeHandlerCopySelection:(iTermCopyModeHandler *)handler NOT_COPY_FAMILY {\n    [_textview copySelectionAccordingToUserPreferences];\n}\n\n#pragma mark - iTermObject\n\n- (iTermBuiltInFunctions *)objectMethodRegistry {\n    if (!_methods) {\n        _methods = [[iTermBuiltInFunctions alloc] init];\n        iTermBuiltInMethod *method;\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"set_name\"\n                                            defaultValues:@{}\n                                                    types:@{ @\"name\": [NSString class] }\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(setNameWithCompletion:name:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"run_tmux_command\"\n                                            defaultValues:@{}\n                                                    types:@{ @\"command\": [NSString class] }\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(sendTmuxCommandWithCompletion:command:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"set_status_bar_component_unread_count\"\n                                            defaultValues:@{}\n                                                    types:@{ @\"identifier\": [NSString class],\n                                                             @\"count\": [NSNumber class] }\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(setStatusBarComponentUnreadCountWithCompletion:identifier:count:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"stop_coprocess\"\n                                            defaultValues:@{}\n                                                    types:@{}\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(stopCoprocessWithCompletion:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"get_coprocess\"\n                                            defaultValues:@{}\n                                                    types:@{}\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(getCoprocessWithCompletion:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"run_coprocess\"\n                                            defaultValues:@{}\n                                                    types:@{ @\"commandLine\": [NSString class],\n                                                             @\"mute\": [NSNumber class] }\n                                        optionalArguments:[NSSet setWithArray:@[ @\"mute\" ]]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(runCoprocessWithCompletion:commandLine:mute:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"add_annotation\"\n                                            defaultValues:@{}\n                                                    types:@{ @\"startX\": [NSNumber class],\n                                                             @\"startY\": [NSNumber class],\n                                                             @\"endX\": [NSNumber class],\n                                                             @\"endY\": [NSNumber class],\n                                                             @\"text\": [NSString class] }\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(addAnnotationWithCompletion:startX:startY:endX:endY:text:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n    }\n    return _methods;\n}\n\n- (void)stopCoprocessWithCompletion:(void (^)(id, NSError *))completion {\n    if (![self hasCoprocess]) {\n        completion(@NO, nil);\n        return;\n    }\n    [self stopCoprocess];\n    completion(@YES, nil);\n}\n\n- (void)getCoprocessWithCompletion:(void (^)(id, NSError *))completion {\n    completion(_shell.coprocess.command, nil);\n}\n\n- (void)runCoprocessWithCompletion:(void (^)(id, NSError *))completion\n                       commandLine:(NSString *)command\n                            mute:(NSNumber *)muteNumber {\n    const BOOL mute = muteNumber ? muteNumber.boolValue : NO;\n    if (self.hasCoprocess) {\n        completion(@NO, nil);\n        return;\n    }\n    [self launchCoprocessWithCommand:command mute:mute];\n    completion(@YES, nil);\n}\n\n- (void)addAnnotationWithCompletion:(void (^)(id, NSError *))completion\n                             startX:(NSNumber *)startXNumber\n                             startY:(NSNumber *)startYNumber\n                               endX:(NSNumber *)endXNumber\n                               endY:(NSNumber *)endYNumber\n                               text:(NSString *)text {\n    const VT100GridAbsCoordRange range = VT100GridAbsCoordRangeMake(startXNumber.intValue,\n                                                                    startYNumber.longLongValue,\n                                                                    endXNumber.intValue,\n                                                                    endYNumber.longLongValue);\n    const long long maxY = _screen.totalScrollbackOverflow + _screen.numberOfLines;\n    if (startYNumber.integerValue > endYNumber.integerValue ||\n        startYNumber.integerValue < 0 ||\n        startYNumber.integerValue > maxY ||\n        endYNumber.integerValue < 0 ||\n        endYNumber.integerValue > maxY ||\n        (startYNumber.integerValue == endYNumber.integerValue && startXNumber.integerValue > endXNumber.integerValue)) {\n        NSError *error = [NSError errorWithDomain:@\"com.iterm2.add-annotation-command\"\n                                             code:0\n                                         userInfo:@{ NSLocalizedDescriptionKey: @\"Invalid range\" }];\n        completion(nil, error);\n        return;\n    }\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        [mutableState addNoteWithText:text inAbsoluteRange:range];\n    }];\n    completion(nil, nil);\n}\n\n- (void)setStatusBarComponentUnreadCountWithCompletion:(void (^)(id, NSError *))completion\n                                            identifier:(NSString *)identifier\n                                                 count:(NSNumber *)count {\n    [[iTermStatusBarUnreadCountController sharedInstance] setUnreadCountForComponentWithIdentifier:identifier\n                                                                                             count:count.integerValue\n                                                                                         sessionID:self.guid];\n    completion(nil, nil);\n}\n\n- (void)sendTmuxCommandWithCompletion:(void (^)(id, NSError *))completion\n                              command:(NSString *)command {\n    if (self.tmuxMode == TMUX_NONE || _tmuxController == nil) {\n        NSError *error = [NSError errorWithDomain:@\"com.iterm2.tmux-command\"\n                                             code:0\n                                         userInfo:@{ NSLocalizedDescriptionKey: @\"Not a tmux integration session\" }];\n        completion(nil, error);\n    }\n\n    [_tmuxController.gateway sendCommand:command\n                          responseTarget:self\n                        responseSelector:@selector(sendTmuxCommandMethodDidComplete:completion:)\n                          responseObject:completion\n                                   flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)sendTmuxCommandMethodDidComplete:(NSString *)result\n                              completion:(void (^)(id, NSError *))completion {\n    if (result) {\n        completion(result, nil);\n        return;\n    }\n\n    // Tmux responded with an error.\n    NSError *error = [NSError errorWithDomain:@\"com.iterm2.tmux-command\"\n                                         code:1\n                                     userInfo:@{ NSLocalizedDescriptionKey: @\"tmux error\" }];\n    completion(nil, error);\n}\n\n- (void)setNameWithCompletion:(void (^)(id, NSError *))completion\n                         name:(NSString *)name  {\n    [self setSessionSpecificProfileValues:@{ KEY_NAME: name ?: @\"\"}];\n    completion(nil, nil);\n}\n\n- (iTermVariableScope *)objectScope {\n    return self.variablesScope;\n}\n\n#pragma mark - iTermSubscribable\n\n- (NSString *)subscribableIdentifier {\n    return self.guid;\n}\n\n- (ITMNotificationResponse *)handleAPINotificationRequest:(ITMNotificationRequest *)request\n                                            connectionKey:(NSString *)connectionKey {\n    ITMNotificationResponse *response = [[[ITMNotificationResponse alloc] init] autorelease];\n    if (!request.hasSubscribe) {\n        response.status = ITMNotificationResponse_Status_RequestMalformed;\n        return response;\n    }\n\n    NSMutableDictionary<id, ITMNotificationRequest *> *subscriptions = nil;\n    switch (request.notificationType) {\n        case ITMNotificationType_NotifyOnPrompt:\n            subscriptions = _promptSubscriptions;\n            break;\n        case ITMNotificationType_NotifyOnKeystroke:\n            subscriptions = _keystrokeSubscriptions;\n            break;\n        case ITMNotificationType_KeystrokeFilter:\n            subscriptions = _keyboardFilterSubscriptions;\n            break;\n        case ITMNotificationType_NotifyOnScreenUpdate:\n            subscriptions = _updateSubscriptions;\n            break;\n        case ITMNotificationType_NotifyOnCustomEscapeSequence:\n            subscriptions = _customEscapeSequenceNotifications;\n            break;\n\n        case ITMNotificationType_NotifyOnVariableChange:  // Gets special handling before this method is called\n        case ITMNotificationType_NotifyOnNewSession:\n        case ITMNotificationType_NotifyOnTerminateSession:\n        case ITMNotificationType_NotifyOnLayoutChange:\n        case ITMNotificationType_NotifyOnFocusChange:\n        case ITMNotificationType_NotifyOnServerOriginatedRpc:\n        case ITMNotificationType_NotifyOnBroadcastChange:\n        case ITMNotificationType_NotifyOnProfileChange:\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n        case ITMNotificationType_NotifyOnLocationChange:\n#pragma clang diagnostic pop\n            // We won't get called for this\n            assert(NO);\n            break;\n    }\n    if (!subscriptions) {\n        response.status = ITMNotificationResponse_Status_RequestMalformed;\n        return response;\n    }\n    if (request.subscribe) {\n        if (subscriptions[connectionKey]) {\n            response.status = ITMNotificationResponse_Status_AlreadySubscribed;\n            return response;\n        }\n        subscriptions[connectionKey] = request;\n    } else {\n        if (!subscriptions[connectionKey]) {\n            response.status = ITMNotificationResponse_Status_NotSubscribed;\n            return response;\n        }\n        [subscriptions removeObjectForKey:connectionKey];\n    }\n\n    response.status = ITMNotificationResponse_Status_Ok;\n    return response;\n}\n\n#pragma mark - iTermLogging\n\n- (void)loggingHelperStart:(iTermLoggingHelper *)loggingHelper {\n    if (loggingHelper.style != iTermLoggingStyleHTML) {\n        return;\n    }\n\n    [loggingHelper logWithoutTimestamp:[NSData styleSheetWithFontFamily:self.textview.fontTable.asciiFont.font.familyName\n                                                               fontSize:self.textview.fontTable.asciiFont.font.pointSize\n                                                        backgroundColor:[_screen.colorMap colorForKey:kColorMapBackground]\n                                                              textColor:[_screen.colorMap colorForKey:kColorMapForeground]]];\n}\n\n- (void)loggingHelperStop:(iTermLoggingHelper *)loggingHelper {\n}\n\n- (NSString *)loggingHelperTimestamp:(iTermLoggingHelper *)loggingHelper {\n    if (![iTermAdvancedSettingsModel logTimestampsWithPlainText]) {\n        return nil;\n    }\n    switch (loggingHelper.style) {\n        case iTermLoggingStyleRaw:\n        case iTermLoggingStyleAsciicast:\n            return nil;\n\n        case iTermLoggingStylePlainText: {\n            static NSDateFormatter *dateFormatter;\n            static dispatch_once_t onceToken;\n            dispatch_once(&onceToken, ^{\n                dateFormatter = [[NSDateFormatter alloc] init];\n                dateFormatter.dateFormat = [NSDateFormatter dateFormatFromTemplate:@\"yyyy-MM-dd hh.mm.ss.SSS\"\n                                                                           options:0\n                                                                            locale:[NSLocale currentLocale]];\n            });\n            return [NSString stringWithFormat:@\"[%@] \", [dateFormatter stringFromDate:[NSDate date]]];\n        }\n\n        case iTermLoggingStyleHTML: {\n            // This is done during encoding.\n            return nil;\n        }\n    }\n}\n\n\n#pragma mark - iTermNaggingControllerDelegate\n\n- (BOOL)naggingControllerCanShowMessageWithIdentifier:(NSString *)identifier {\n    return ![self hasAnnouncementWithIdentifier:identifier];\n}\n\n- (void)naggingControllerShowMessage:(NSString *)message\n                          isQuestion:(BOOL)isQuestion\n                           important:(BOOL)important\n                          identifier:(NSString *)identifier\n                             options:(NSArray<NSString *> *)options\n                          completion:(void (^)(int))completion {\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:message\n                                                     style:isQuestion ? kiTermAnnouncementViewStyleQuestion : kiTermAnnouncementViewStyleWarning\n                                               withActions:options\n                                                completion:^(int selection) {\n        completion(selection);\n    }];\n    if (!important) {\n        announcement.dismissOnKeyDown = YES;\n    }\n    [self queueAnnouncement:announcement identifier:identifier];\n}\n\n- (void)naggingControllerRepairSavedArrangement:(NSString *)savedArrangementName\n                            missingProfileNamed:(NSString *)missingProfileName\n                                           guid:(NSString *)guid {\n    Profile *similarlyNamedProfile = [[ProfileModel sharedInstance] bookmarkWithName:missingProfileName];\n    [[iTermController sharedInstance] repairSavedArrangementNamed:savedArrangementName\n                                             replacingMissingGUID:guid\n                                                         withGUID:similarlyNamedProfile[KEY_GUID]];\n    [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionDidRepairSavedArrangement\n                                                        object:guid\n                                                      userInfo:@{ @\"new profile\": similarlyNamedProfile }];\n}\n\n- (void)naggingControllerRemoveMessageWithIdentifier:(NSString *)identifier {\n    [self dismissAnnouncementWithIdentifier:identifier];\n    [self removeAnnouncementWithIdentifier:identifier];\n}\n\n- (void)naggingControllerRestart {\n    [self replaceTerminatedShellWithNewInstance];\n}\n\n- (void)naggingControllerAbortDownload {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        [terminal stopReceivingFile];\n    }];\n}\n\n- (void)naggingControllerAbortUpload {\n    if (!self.upload) {\n        return;\n    }\n    [_pasteHelper abort];\n    [self.upload endOfData];\n    self.upload = nil;\n}\n\n- (void)naggingControllerSetBackgroundImageToFileWithName:(NSString *)filename {\n    [self setSessionSpecificProfileValues:@{ KEY_BACKGROUND_IMAGE_LOCATION: filename.length ? filename : [NSNull null] }];\n}\n\n- (void)naggingControllerDisableMouseReportingPermanently:(BOOL)permanently {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        if (permanently) {\n            if (self.isDivorced) {\n                [self setSessionSpecificProfileValues:@{ KEY_XTERM_MOUSE_REPORTING: @NO}];\n            } else {\n                [iTermProfilePreferences setBool:NO\n                                          forKey:KEY_XTERM_MOUSE_REPORTING\n                                       inProfile:self.profile\n                                           model:[ProfileModel sharedInstance]];\n                [[NSNotificationCenter defaultCenter] postNotificationName:kSessionProfileDidChange\n                                                                    object:self.profile[KEY_GUID]];\n            }\n        }\n        [terminal setMouseMode:MOUSE_REPORTING_NONE];\n    }];\n}\n\n- (void)naggingControllerDisableBracketedPasteMode {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        terminal.bracketedPasteMode = NO;\n    }];\n}\n\n- (void)naggingControllerCloseSession {\n    [_delegate closeSession:self];\n}\n\n- (void)naggingControllerRepairInitialWorkingDirectoryOfSessionWithGUID:(NSString *)guid\n                                                  inArrangementWithName:(NSString *)arrangementName {\n    NSOpenPanel* panel = [NSOpenPanel openPanel];\n    panel.canChooseFiles = NO;\n    panel.canChooseDirectories = YES;\n    panel.allowsMultipleSelection = NO;\n\n    if ([panel runModal] != NSModalResponseOK) {\n        return;\n    }\n    if (!panel.directoryURL.path) {\n        return;\n    }\n    [[iTermController sharedInstance] repairSavedArrangementNamed:arrangementName\n                        replaceInitialDirectoryForSessionWithGUID:guid\n                                                             with:panel.directoryURL.path];\n}\n\n- (void)naggingControllerDisableTriggersInInteractiveApps {\n    NSDictionary *update = @{ KEY_ENABLE_TRIGGERS_IN_INTERACTIVE_APPS: @NO };\n    if (self.isDivorced) {\n        [self setSessionSpecificProfileValues:update];\n        [[iTermNotificationController sharedInstance] notify:@\"Session Updated\"\n                                             withDescription:@\"Triggers disabled in interactive apps. You can change this in Edit Session > Advanced.\"];\n        return;\n    }\n\n    [iTermProfilePreferences setObjectsFromDictionary:update inProfile:self.profile model:[ProfileModel sharedInstance]];\n    [[iTermNotificationController sharedInstance] notify:@\"Profile Updated\"\n                                         withDescription:@\"Triggers disabled in interactive apps. You can change this in Prefs > Profiles > Advanced.\"];\n}\n\n#pragma mark - iTermComposerManagerDelegate\n\n- (iTermStatusBarViewController *)composerManagerStatusBarViewController:(iTermComposerManager *)composerManager {\n    return _statusBarViewController;\n}\n\n- (iTermVariableScope *)composerManagerScope:(iTermComposerManager *)composerManager {\n    return self.variablesScope;\n}\n\n- (NSView *)composerManagerContainerView:(iTermComposerManager *)composerManager {\n    return _view;\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager minimalFrameDidChangeTo:(NSRect)newFrame {\n    [_textview setNeedsDisplay:YES];\n    DLog(@\"Composer frame changed to %@\", NSStringFromRect(newFrame));\n}\n\n- (NSRect)composerManager:(iTermComposerManager *)composerManager\n    frameForDesiredHeight:(CGFloat)desiredHeight\n            previousFrame:(NSRect)previousFrame {\n    NSRect newFrame = previousFrame;\n    newFrame.origin.y = _view.frame.size.height;\n\n    newFrame.origin.y += newFrame.size.height;\n    const CGFloat maxWidth = _view.bounds.size.width - newFrame.origin.x * 2;\n    const CGFloat vmargin = [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins];\n    const NSSize paneSize = self.view.frame.size;\n    CGFloat y = 0;\n    CGFloat width = 0;\n    CGFloat height = 0;\n\n    if (composerManager.isAutoComposer) {\n        // Place at bottom, but leave excess space below it so it abuts the terminal view.\n        width = maxWidth;\n        int lineAbove = _screen.currentGrid.cursor.y + 1;\n        id<VT100ScreenMarkReading> mark = _screen.lastPromptMark;\n        if (mark.promptRange.start.y >= 0) {\n            lineAbove = mark.promptRange.start.y - _screen.totalScrollbackOverflow - _screen.numberOfScrollbackLines;\n            lineAbove = MAX(1, lineAbove);\n        }\n        const int actualLinesAboveComposer = MAX(1, _screen.height - lineAbove);\n        const CGFloat lineHeight = _textview.lineHeight;\n        const int desiredLines = ceil(desiredHeight / lineHeight);\n        const int linesOfHeight = MIN(actualLinesAboveComposer, desiredLines);\n        const int gridOffsetInRows = _screen.height - linesOfHeight;\n        const CGFloat titleBarHeight = (_view.showTitle ? SessionView.titleHeight : 0);\n        height = (linesOfHeight + 0.5) * lineHeight;\n        const CGFloat gridOffsetInPoints = gridOffsetInRows * lineHeight;\n        const CGFloat top = vmargin + titleBarHeight + gridOffsetInPoints;\n        y = MAX(0, paneSize.height - top - height);\n\n        DLog(@\"width=%@ actualLinesFree=%@ gridOffsetInRows=%@ lineHeight=%@ titleBarHeight=%@ height=%@ gridOffsetInPoints=%@ top=%@ y=%@\",\n             @(width), @(actualLinesAboveComposer), @(gridOffsetInRows), @(lineHeight), @(titleBarHeight), @(height), @(gridOffsetInPoints), @(top), @(y));\n    } else {\n        // Place at top. Includes decoration so a minimum width must be enforced.\n\n        y = paneSize.height - desiredHeight;\n        width = MAX(217, maxWidth);\n        height = desiredHeight;\n    }\n    newFrame = NSMakeRect(newFrame.origin.x,\n                          y,\n                          width,\n                          height);\n    return newFrame;\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager desiredHeightDidChange:(CGFloat)desiredHeight {\n    DLog(@\"Desired height changed to %@\", @(desiredHeight));\n    [self sync];\n}\n\n- (BOOL)haveAutoComposer {\n    return _composerManager.dropDownComposerViewIsVisible && _composerManager.isAutoComposer;\n}\n\n- (void)screenWillSynchronize {\n}\n\n- (void)screenDidSynchronize {\n    [self updateAutoComposerFrame];\n}\n\n- (CGFloat)composerManagerLineHeight:(iTermComposerManager *)composerManager {\n    return _textview.lineHeight;\n}\n\n- (void)composerManagerClear:(iTermComposerManager *)composerManager {\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState clearForComposer];\n    }];\n}\n\n- (void)composerManagerOpenHistory:(iTermComposerManager *)composerManager\n                            prefix:(nonnull NSString *)prefix\n                         forSearch:(BOOL)forSearch {\n    [[_delegate realParentWindow] openCommandHistoryWithPrefix:prefix sortChronologically:!forSearch];\n}\n\n- (void)composerManagerDidRemoveTemporaryStatusBarComponent:(iTermComposerManager *)composerManager {\n    [_pasteHelper temporaryRightStatusBarComponentDidBecomeAvailable];\n    [_textview.window makeFirstResponder:_textview];\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager enqueueCommand:(NSString *)command {\n    if (self.currentCommand != nil && self.currentCommand.length == 0) {\n        // At shell prompt\n        [self sendCommand:command];\n        return;\n    }\n    // Send when next mark is received.\n    [_commandQueue addObject:[command copy]];\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager sendCommand:(NSString *)command {\n    [self sendCommand:command];\n}\n\n- (id<iTermSyntaxHighlighting>)composerManager:(iTermComposerManager *)composerManager\n          syntaxHighlighterForAttributedString:(NSMutableAttributedString *)attributedString {\n    return [[[iTermSyntaxHighlighter alloc] init:attributedString\n                                        colorMap:_screen.colorMap\n                                        fontTable:_textview.fontTable\n                                     fileChecker:[self fileChecker]] autorelease];\n}\n\n- (void)composerManagerDidBecomeFirstResponder:(iTermComposerManager *)composerManager {\n    _textViewShouldTakeFirstResponder = NO;\n}\n\n- (BOOL)composerManagerShouldFetchSuggestions:(iTermComposerManager *)composerManager\n                                      forHost:(id<VT100RemoteHostReading>)remoteHost\n                               tmuxController:(TmuxController *)tmuxController {\n    if (remoteHost.isRemoteHost) {\n        // Don't try to complete filenames if not on localhost unless we can ask the conductor.\n        if (@available(macOS 11, *)) {\n            return [_conductor framing];\n        } else {\n            return NO;\n        }\n    }\n    if (tmuxController) {\n        // I haven't implemented this on tmux because it's probably gonna be slow and knowing the\n        // working directory is rare.\n        return NO;\n    }\n    return YES;\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager\n       fetchSuggestions:(iTermSuggestionRequest *)request {\n    if (@available(macOS 11, *)) {\n        if ([_conductor framing]) {\n            [_conductor fetchSuggestions:request];\n        }\n    }\n    [[iTermSlowOperationGateway sharedInstance] findCompletionsWithPrefix:request.prefix\n                                                            inDirectories:request.directories\n                                                                      pwd:request.workingDirectory\n                                                                 maxCount:1\n                                                               executable:request.executable\n                                                               completion:^(NSArray<NSString *> * _Nonnull completions) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            request.completion(completions);\n        });\n    }];\n}\n\n- (iTermFileChecker *)fileChecker {\n    if (@available(macOS 11, *)) {\n        if (_conductor.canCheckFiles) {\n            return _conductor.fileChecker;\n        }\n    }\n    if (!_localFileChecker) {\n        _localFileChecker = [[iTermLocalFileChecker alloc] init];\n        if (self.lastLocalDirectory) {\n            _localFileChecker.workingDirectory = self.lastLocalDirectory;\n        }\n    }\n    return _localFileChecker;\n}\n\n- (void)sendCommand:(NSString *)command {\n    if (_screen.commandRange.start.x < 0) {\n        id<VT100RemoteHostReading> host = [self currentHost] ?: [VT100RemoteHost localhost];\n        [[iTermShellHistoryController sharedInstance] addCommand:command\n                                                          onHost:host\n                                                     inDirectory:[_screen workingDirectoryOnLine:_screen.commandRange.start.y]\n                                                        withMark:nil];\n    }\n    __weak __typeof(self) weakSelf = self;\n    if ([self haveAutoComposer]) {\n        if (_composerManager.haveShellProvidedText) {\n            // Send ^U first to erase what's already there.\n            // TODO: This may wreak havoc if the shell decides to redraw itself.\n            command = [[NSString stringWithLongCharacter:'U' - '@'] stringByAppendingString:command];\n        }\n        const BOOL detectedByTrigger = [_composerManager.prefixUserData[PTYSessionComposerPrefixUserDataKeyDetectedByTrigger] boolValue];\n        [_composerManager setPrefix:nil userData:nil];\n        [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            DLog(@\"willSendCommand:%@\", command);\n            [mutableState composerWillSendCommand];\n            if (detectedByTrigger) {\n                [mutableState didSendCommand];\n            }\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [weakSelf reallySendCommand:command];\n            });\n        }];\n        DLog(@\"Dismiss composer and request redraw\");\n        [_composerManager dismissAnimated:NO];\n        [_textview setNeedsDisplay:YES];\n        return;\n    }\n    [self reallySendCommand:command];\n}\n\n- (void)reallySendCommand:(NSString *)command {\n    DLog(@\"reallySendCommand: %@\", command);\n    [self writeTask:command];\n    [_screen userDidPressReturn];\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager\n    sendToAdvancedPaste:(NSString *)command {\n    [self openAdvancedPasteWithText:command escaping:iTermSendTextEscapingNone];\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager\n            sendControl:(NSString *)control {\n    [self writeTask:control];\n}\n\n- (BOOL)composerManager:(iTermComposerManager *)composerManager wantsKeyEquivalent:(NSEvent *)event {\n    const NSEventModifierFlags mask = (NSEventModifierFlagOption |\n                                       NSEventModifierFlagCommand |\n                                       NSEventModifierFlagShift |\n                                       NSEventModifierFlagControl);\n    const NSEventModifierFlags cmdShift = (NSEventModifierFlagCommand | NSEventModifierFlagShift);\n    if ((event.modifierFlags & mask) == cmdShift) {\n        // Shortcut for mark navigation.\n        if (event.keyCode == kVK_UpArrow) {\n            [[self.delegate realParentWindow] previousMark:nil];\n            return YES;\n        } else if (event.keyCode == kVK_DownArrow) {\n            [[self.delegate realParentWindow] nextMark:nil];\n            return YES;\n        }\n    }\n    return NO;\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager performFindPanelAction:(id)sender {\n    [_textview performFindPanelAction:sender];\n}\n\n- (void)composerManagerWillDismissMinimalView:(iTermComposerManager *)composerManager {\n    [_textview.window makeFirstResponder:_textview];\n    _composerManager.isSeparatorVisible = NO;\n}\n\n- (void)composerManagerDidDisplayMinimalView:(iTermComposerManager *)composerManager {\n    [self updateAutoComposerSeparatorVisibility];\n}\n\n- (void)updateAutoComposerSeparatorVisibility {\n    _composerManager.isSeparatorVisible = [self shouldShowAutoComposerSeparator];\n    _composerManager.separatorColor = [iTermTextDrawingHelper colorForLineStyleMark:iTermMarkIndicatorTypeSuccess\n                                                                    backgroundColor:[_screen.colorMap colorForKey:kColorMapBackground]];\n}\n\n- (BOOL)shouldShowAutoComposerSeparator {\n    return self.haveAutoComposer;\n}\n\n- (void)composerManagerDidDismissMinimalView:(iTermComposerManager *)composerManager {\n    _view.composerHeight = 0;\n    [_localFileChecker reset];\n    if (@available(macOS 11, *)) {\n        [_conductor.fileChecker reset];\n    }\n}\n\n- (NSAppearance *)composerManagerAppearance:(iTermComposerManager *)composerManager {\n    NSColor *color = [_screen.colorMap colorForKey:kColorMapBackground];\n    if ([color isDark]) {\n        return [NSAppearance appearanceNamed:NSAppearanceNameDarkAqua];\n    }\n    return [NSAppearance appearanceNamed:NSAppearanceNameAqua];\n}\n\n- (id<VT100RemoteHostReading>)composerManagerRemoteHost:(iTermComposerManager *)composerManager {\n    return [self currentHost];\n}\n\n- (NSString * _Nullable)composerManagerWorkingDirectory:(iTermComposerManager *)composerManager {\n    return [self.variablesScope path];\n}\n\n- (NSString *)composerManagerShell:(iTermComposerManager *)composerManager {\n    return [self bestGuessAtUserShell];\n}\n\n- (NSString *)composerManagerUName:(iTermComposerManager *)composerManager {\n    return [self bestGuessAtUName];\n}\n\n- (TmuxController *)composerManagerTmuxController:(iTermComposerManager *)composerManager {\n    if (!self.isTmuxClient) {\n        return nil;\n    }\n    return self.tmuxController;\n}\n\n- (NSFont *)composerManagerFont:(iTermComposerManager *)composerManager {\n    return self.textview.fontTable.asciiFont.font;\n}\n\n- (NSColor *)composerManagerTextColor:(iTermComposerManager *)composerManager {\n    return [self.textview.colorMap colorForKey:kColorMapForeground];\n}\n\n- (NSColor *)composerManagerCursorColor:(iTermComposerManager *)composerManager {\n    return [self.textview.colorMap colorForKey:kColorMapCursor];\n}\n\n#pragma mark - iTermIntervalTreeObserver\n\n- (void)intervalTreeDidReset {\n    [iTermGCD assertMainQueueSafe];\n    if (![iTermAdvancedSettingsModel showLocationsInScrollbar]) {\n        return;\n    }\n    if (![iTermAdvancedSettingsModel showMarksInScrollbar]) {\n        return;\n    }\n    [self initializeMarksMinimap];\n}\n\n- (void)initializeMarksMinimap {\n    [_view.marksMinimap removeAllObjects];\n    const NSInteger count = (NSInteger)iTermIntervalTreeObjectTypeUnknown;\n    NSMutableDictionary<NSNumber *, NSMutableIndexSet *> *sets = [NSMutableDictionary dictionary];\n    [_screen enumerateObservableMarks:^(iTermIntervalTreeObjectType type, NSInteger line) {\n        NSMutableIndexSet *set = sets[@(type)];\n        if (!set) {\n            set = [NSMutableIndexSet indexSet];\n            sets[@(type)] = set;\n        }\n        [set addIndex:line];\n    }];\n    for (NSInteger i = 0; i < count; i++) {\n        [_view.marksMinimap setLines:sets[@(i)] ?: [NSMutableIndexSet indexSet]\n                             forType:i];\n    }\n}\n\n- (BOOL)minimapsTrackObjectsOfType:(iTermIntervalTreeObjectType)type {\n    switch (type) {\n        case iTermIntervalTreeObjectTypeSuccessMark:\n        case iTermIntervalTreeObjectTypeOtherMark:\n        case iTermIntervalTreeObjectTypeErrorMark:\n        case iTermIntervalTreeObjectTypeManualMark:\n        case iTermIntervalTreeObjectTypeAnnotation:\n        case iTermIntervalTreeObjectTypeUnknown:\n            return YES;\n        case iTermIntervalTreeObjectTypePorthole:\n            return NO;\n    }\n}\n- (void)intervalTreeDidAddObjectOfType:(iTermIntervalTreeObjectType)type\n                                onLine:(NSInteger)line {\n    [self addMarkToMinimapOfType:type onLine:line];\n}\n\n- (void)addMarkToMinimapOfType:(iTermIntervalTreeObjectType)type\n                                onLine:(NSInteger)line {\n    DLog(@\"Add at %@\", @(line));\n    [iTermGCD assertMainQueueSafe];\n    if (![iTermAdvancedSettingsModel showLocationsInScrollbar]) {\n        return;\n    }\n    if (![iTermAdvancedSettingsModel showMarksInScrollbar]) {\n        return;\n    }\n    if ([self minimapsTrackObjectsOfType:type]) {\n        [_view.marksMinimap addObjectOfType:type onLine:line];\n    }\n}\n\n- (void)intervalTreeDidHideObject:(id<IntervalTreeImmutableObject>)object\n                           ofType:(iTermIntervalTreeObjectType)type\n                           onLine:(NSInteger)line {\n    DLog(@\"Hide %@\", object);\n    PortholeMark *portholeMark = [PortholeMark castFrom:object];\n    if (portholeMark) {\n        id<Porthole> porthole = [[PortholeRegistry instance] objectForKeyedSubscript:portholeMark.uniqueIdentifier];\n        if (porthole) {\n            [_textview hidePorthole:porthole];\n        }\n    }\n    [self removeMarkFromMinimapOfType:type onLine:line];\n}\n\n- (void)intervalTreeDidUnhideObject:(id<IntervalTreeImmutableObject>)object\n                             ofType:(iTermIntervalTreeObjectType)type\n                             onLine:(NSInteger)line {\n    DLog(@\"Unhide %@\", object);\n    PortholeMark *portholeMark = [PortholeMark castFrom:object];\n    if (portholeMark) {\n        id<Porthole> porthole = [[PortholeRegistry instance] objectForKeyedSubscript:portholeMark.uniqueIdentifier];\n        if (porthole) {\n            [_textview unhidePorthole:porthole];\n        }\n    }\n    [self addMarkToMinimapOfType:type onLine:line];\n}\n\n- (void)intervalTreeDidRemoveObjectOfType:(iTermIntervalTreeObjectType)type\n                                   onLine:(NSInteger)line {\n    DLog(@\"Remove at %@\", @(line));\n    if (type == iTermIntervalTreeObjectTypePorthole) {\n        [_textview setNeedsPrunePortholes:YES];\n    }\n    [self removeMarkFromMinimapOfType:type onLine:line];\n}\n\n- (void)removeMarkFromMinimapOfType:(iTermIntervalTreeObjectType)type\n                             onLine:(NSInteger)line {\n    if (![iTermAdvancedSettingsModel showLocationsInScrollbar]) {\n        return;\n    }\n    if (![iTermAdvancedSettingsModel showMarksInScrollbar]) {\n        return;\n    }\n    if ([self minimapsTrackObjectsOfType:type]) {\n        [_view.marksMinimap removeObjectOfType:type fromLine:line];\n    }\n}\n\n- (void)intervalTreeVisibleRangeDidChange {\n     [iTermGCD assertMainQueueSafe];\n    [self updateMarksMinimapRangeOfVisibleLines];\n}\n\n- (void)intervalTreeDidMoveObjects:(NSArray<id<IntervalTreeImmutableObject>> *)objects {\n    [self.textview updatePortholeFrames];\n}\n\n- (void)updateMarksMinimapRangeOfVisibleLines {\n    if (![iTermAdvancedSettingsModel showLocationsInScrollbar]) {\n        return;\n    }\n    [_view.marksMinimap setFirstVisibleLine:_screen.totalScrollbackOverflow\n                       numberOfVisibleLines:_screen.numberOfLines];\n}\n\n#pragma mark - iTermTmuxControllerSession\n\n- (void)tmuxControllerSessionSetTTL:(NSTimeInterval)ttl redzone:(BOOL)redzone {\n    if (_tmuxPaused) {\n        return;\n    }\n    if (![iTermPreferences boolForKey:kPreferenceKeyTmuxWarnBeforePausing]) {\n        return;\n    }\n    if (_tmuxTTLHasThresholds) {\n        if (ttl > _tmuxTTLLowerThreshold && ttl < _tmuxTTLUpperThreshold) {\n            return;\n        }\n        if (ttl <= _tmuxTTLLowerThreshold) {\n            _tmuxTTLLowerThreshold = ttl - 1;\n            _tmuxTTLUpperThreshold = ttl + 1.5;\n        } else {\n            _tmuxTTLLowerThreshold = ttl - 1.5;\n            _tmuxTTLUpperThreshold = ttl + 1;\n        }\n    } else {\n        _tmuxTTLLowerThreshold = ttl - 1;\n        _tmuxTTLUpperThreshold = ttl + 1;\n        _tmuxTTLHasThresholds = YES;\n    }\n\n    NSTimeInterval rounded = round(ttl);\n    NSInteger safeTTL = 0;\n    if (rounded > NSIntegerMax || rounded != rounded) {\n        safeTTL = NSIntegerMax;\n    } else {\n        safeTTL = MAX(1, rounded);\n    }\n\n    if (!redzone) {\n        [self dismissAnnouncementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n        return;\n    }\n    NSString *title = [NSString stringWithFormat:@\"This session will pause in about %@ second%@ because it is buffering too much data.\", @(safeTTL), safeTTL == 1 ? @\"\" : @\"s\"];\n    iTermAnnouncementViewController *announcement = [self announcementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n    if (announcement) {\n        announcement.title = title;\n        [announcement.view setNeedsDisplay:YES];\n        [_view updateAnnouncementFrame];\n        return;\n    }\n    announcement =\n    [iTermAnnouncementViewController announcementWithTitle:title\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"_Pause Settings\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case 0:\n                [[PreferencePanel sharedInstance] openToPreferenceWithKey:kPreferenceKeyTmuxPauseModeAgeLimit];\n                break;\n        }\n    }];\n    announcement.dismissOnKeyDown = YES;\n    [self queueAnnouncement:announcement identifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n}\n\n#pragma mark - iTermUniquelyIdentifiable\n\n- (NSString *)stringUniqueIdentifier {\n    return self.guid;\n}\n\n#pragma mark - iTermModifyOtherKeysMapperDelegate\n\n- (NSStringEncoding)modifiyOtherKeysDelegateEncoding:(iTermModifyOtherKeysMapper *)sender {\n    DLog(@\"encoding=%@\", @(_screen.terminalEncoding));\n    return _screen.terminalEncoding;\n}\n\n- (void)modifyOtherKeys:(iTermModifyOtherKeysMapper *)sender\ngetOptionKeyBehaviorLeft:(iTermOptionKeyBehavior *)left\n                  right:(iTermOptionKeyBehavior *)right {\n    *left = self.optionKey;\n    *right = self.rightOptionKey;\n    DLog(@\"left=%@ right=%@\", @(*left), @(*right));\n}\n\n- (VT100Output *)modifyOtherKeysOutputFactory:(iTermModifyOtherKeysMapper *)sender {\n    return _screen.terminalOutput;\n}\n\n- (BOOL)modifyOtherKeysTerminalIsScreenlike:(iTermModifyOtherKeysMapper *)sender {\n    DLog(@\"screenlike=%@\", @(self.isTmuxClient));\n    return self.isTmuxClient;\n}\n\n#pragma mark - iTermLegacyViewDelegate\n\n- (void)legacyView:(iTermLegacyView *)legacyView drawRect:(NSRect)dirtyRect {\n    [_textview drawRect:dirtyRect inView:legacyView];\n}\n\n#pragma mark - TriggerDelegate\n\n- (void)triggerChanged:(TriggerController *)triggerController newValue:(NSArray *)value {\n    [[triggerController.window undoManager] registerUndoWithTarget:self\n                                                          selector:@selector(setTriggersValue:)\n                                                            object:self.profile[KEY_TRIGGERS]];\n    [[triggerController.window undoManager] setActionName:@\"Edit Triggers\"];\n    [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS: value }];\n    triggerController.guid = self.profile[KEY_GUID];\n}\n\n- (void)setTriggersValue:(NSArray *)value {\n    [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS: value }];\n    _triggerWindowController.guid = self.profile[KEY_GUID];\n    [_triggerWindowController profileDidChange];\n}\n\n- (void)triggerSetUseInterpolatedStrings:(BOOL)useInterpolatedStrings {\n    [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS_USE_INTERPOLATED_STRINGS: @(useInterpolatedStrings) }];\n    _triggerWindowController.guid = self.profile[KEY_GUID];\n}\n\n- (void)triggersCloseSheet {\n    [self closeTriggerWindowController];\n}\n\n- (void)triggersCopyToProfile {\n    [ProfileModel updateSharedProfileWithGUID:self.profile[KEY_ORIGINAL_GUID]\n                                    newValues:@{ KEY_TRIGGERS: self.profile[KEY_TRIGGERS],\n                                                 KEY_TRIGGERS_USE_INTERPOLATED_STRINGS: self.profile[KEY_TRIGGERS_USE_INTERPOLATED_STRINGS] }];\n}\n\n#pragma mark - iTermFilterDestination\n\n- (void)filterDestinationAppendCharacters:(const screen_char_t *)line\n                                    count:(int)count\n                   externalAttributeIndex:(iTermExternalAttributeIndex *)externalAttributeIndex\n                             continuation:(screen_char_t)continuation {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState appendScreenChars:line\n                                 length:count\n                 externalAttributeIndex:externalAttributeIndex\n                           continuation:continuation];\n    }];\n}\n\n- (void)filterDestinationRemoveLastLine {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState removeLastLine];\n    }];\n}\n\n#pragma mark - iTermImmutableColorMapDelegate\n\n- (void)immutableColorMap:(id<iTermColorMapReading>)colorMap didChangeColorForKey:(iTermColorMapKey)theKey from:(NSColor *)before to:(NSColor *)after {\n    [_textview immutableColorMap:colorMap didChangeColorForKey:theKey from:before to:after];\n    [self setNeedsComposerColorUpdate:YES];\n}\n\n- (void)immutableColorMap:(id<iTermColorMapReading>)colorMap dimmingAmountDidChangeTo:(double)dimmingAmount {\n    [_textview immutableColorMap:colorMap dimmingAmountDidChangeTo:dimmingAmount];\n    [self setNeedsComposerColorUpdate:YES];\n\n}\n- (void)immutableColorMap:(id<iTermColorMapReading>)colorMap mutingAmountDidChangeTo:(double)mutingAmount {\n    [_textview immutableColorMap:colorMap mutingAmountDidChangeTo:mutingAmount];\n    [self setNeedsComposerColorUpdate:YES];\n}\n\n- (void)setNeedsComposerColorUpdate:(BOOL)needed {\n    if (_needsComposerColorUpdate && needed) {\n        return;\n    }\n    _needsComposerColorUpdate = needed;\n    if (needed) {\n        __weak __typeof(self) weakSelf = self;\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [weakSelf updateComposerColors];\n        });\n    }\n}\n\n- (void)updateComposerColors {\n    if (!_textview) {\n        return;\n    }\n    [self setNeedsComposerColorUpdate:NO];\n    if (![self haveAutoComposer]) {\n        return;\n    }\n    NSDictionary *userData = [NSDictionary castFrom:[_composerManager prefixUserData]];\n    if (!userData) {\n        return;\n    }\n    NSArray<ScreenCharArray *> *promptText = [NSArray castFrom:userData[PTYSessionComposerPrefixUserDataKeyPrompt]];\n    if (!promptText) {\n        return;\n    }\n    NSMutableAttributedString *prompt = [self kernedAttributedStringForScreenChars:promptText];\n    [_composerManager setPrefix:prompt userData:[_composerManager prefixUserData]];\n}\n\n// This can be completely async\n- (BOOL)toolbeltIsVisibleWithCapturedOutput {\n    if (!self.delegate.realParentWindow.shouldShowToolbelt) {\n        return NO;\n    }\n    return [iTermToolbeltView shouldShowTool:kCapturedOutputToolName];\n}\n\n- (void)showCapturedOutputTool {\n    if (!self.delegate.realParentWindow.shouldShowToolbelt) {\n        [self.delegate.realParentWindow toggleToolbeltVisibility:nil];\n    }\n    if (![iTermToolbeltView shouldShowTool:kCapturedOutputToolName]) {\n        [iTermToolbeltView toggleShouldShowTool:kCapturedOutputToolName];\n    }\n}\n\n- (void)performActionForCapturedOutput:(CapturedOutput *)capturedOutput {\n    __weak __typeof(self) weakSelf = self;\n    [capturedOutput.promisedCommand onQueue:dispatch_get_main_queue() then:^(NSString * _Nonnull command) {\n        [weakSelf reallyPerformActionForCapturedOutput:capturedOutput command:command];\n    }];\n}\n\n- (void)reallyPerformActionForCapturedOutput:(CapturedOutput *)capturedOutput\n                                     command:(NSString *)command {\n    [self launchCoprocessWithCommand:command\n                          identifier:nil\n                              silent:NO\n                        triggerTitle:@\"Captured Output trigger\"];\n    [self takeFocus];\n}\n\n#pragma mark - iTermTriggerSideEffectExecutor\n\n- (void)triggerSideEffectShowAlertWithMessage:(NSString *)message\n                                    rateLimit:(iTermRateLimitedUpdate *)rateLimit\n                                      disable:(void (^)(void))disable {\n    [iTermGCD assertMainQueueSafe];\n    __weak __typeof(self) weakSelf = self;\n    // Dispatch because it's not safe to start a runloop in a side-effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf reallyShowTriggerAlertWithMessage:message\n                                          rateLimit:rateLimit\n                                            disable:disable];\n    });\n}\n\n- (void)reallyShowTriggerAlertWithMessage:(NSString *)message\n                                rateLimit:(iTermRateLimitedUpdate *)rateLimit\n                                  disable:(void (^)(void))disable {\n    __weak __typeof(self) weakSelf = self;\n    [rateLimit performRateLimitedBlock:^{\n        NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n        alert.messageText = message ?: @\"\";\n        [alert addButtonWithTitle:@\"OK\"];\n        [alert addButtonWithTitle:@\"Show Session\"];\n        [alert addButtonWithTitle:@\"Disable This Alert\"];\n        switch ([alert runModal]) {\n            case NSAlertFirstButtonReturn:\n                break;\n\n            case NSAlertSecondButtonReturn: {\n                [weakSelf reveal];\n                break;\n            }\n\n            case NSAlertThirdButtonReturn:\n                disable();\n                break;\n\n            default:\n                break;\n        }\n    }];\n}\n\n- (void)triggerSideEffectShowCapturedOutputTool {\n    [iTermGCD assertMainQueueSafe];\n    [self showCapturedOutputTool];\n}\n\n- (void)triggerSideEffectShowCapturedOutputToolNotVisibleAnnouncementIfNeeded {\n    [iTermGCD assertMainQueueSafe];\n    if ([self toolbeltIsVisibleWithCapturedOutput]) {\n        return;\n    }\n\n    if ([[NSUserDefaults standardUserDefaults] boolForKey:kSuppressCaptureOutputToolNotVisibleWarning]) {\n        return;\n    }\n\n    if ([self hasAnnouncementWithIdentifier:kSuppressCaptureOutputToolNotVisibleWarning]) {\n        return;\n    }\n    NSString *theTitle = @\"A Capture Output trigger fired, but the Captured Output tool is not visible.\";\n    void (^completion)(int selection) = ^(int selection) {\n        switch (selection) {\n            case -2:\n                break;\n\n            case 0:\n                [self showCapturedOutputTool];\n                break;\n\n            case 1:\n                [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                        forKey:kSuppressCaptureOutputToolNotVisibleWarning];\n                break;\n        }\n    };\n    iTermAnnouncementViewController *announcement =\n        [iTermAnnouncementViewController announcementWithTitle:theTitle\n                                                         style:kiTermAnnouncementViewStyleWarning\n                                                   withActions:@[ @\"Show It\", @\"Silence Warning\" ]\n                                                    completion:completion];\n    announcement.dismissOnKeyDown = YES;\n    [self queueAnnouncement:announcement\n                 identifier:kSuppressCaptureOutputToolNotVisibleWarning];\n}\n\n- (void)triggerSideEffectShowShellIntegrationRequiredAnnouncement {\n    [iTermGCD assertMainQueueSafe];\n    if ([[NSUserDefaults standardUserDefaults] boolForKey:kSuppressCaptureOutputRequiresShellIntegrationWarning]) {\n        return;\n    }\n    NSString *theTitle = @\"A Capture Output trigger fired, but Shell Integration is not installed.\";\n    void (^completion)(int selection) = ^(int selection) {\n        switch (selection) {\n            case -2:\n                break;\n\n            case 0:\n                [self tryToRunShellIntegrationInstallerWithPromptCheck:NO];\n                break;\n\n            case 1:\n                [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                        forKey:kSuppressCaptureOutputRequiresShellIntegrationWarning];\n                break;\n        }\n    };\n    iTermAnnouncementViewController *announcement =\n        [iTermAnnouncementViewController announcementWithTitle:theTitle\n                                                         style:kiTermAnnouncementViewStyleWarning\n                                                   withActions:@[ @\"Install\", @\"Silence Warning\" ]\n                                                    completion:completion];\n    [self queueAnnouncement:announcement\n                 identifier:kTwoCoprocessesCanNotRunAtOnceAnnouncementIdentifier];\n}\n\n- (void)triggerSideEffectDidCaptureOutput {\n    [iTermGCD assertMainQueueSafe];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kPTYSessionCapturedOutputDidChange\n                                                        object:nil];\n\n}\n\n- (void)triggerSideEffectLaunchCoprocessWithCommand:(NSString * _Nonnull)command\n                                         identifier:(NSString * _Nullable)identifier\n                                             silent:(BOOL)silent\n                                       triggerTitle:(NSString * _Nonnull)triggerName {\n    [iTermGCD assertMainQueueSafe];\n    [self launchCoprocessWithCommand:command identifier:identifier silent:silent triggerTitle:triggerName];\n}\n\n- (void)launchCoprocessWithCommand:(NSString * _Nonnull)command\n                        identifier:(NSString * _Nullable)identifier\n                            silent:(BOOL)silent\n                      triggerTitle:(NSString * _Nonnull)triggerName {\n    if (self.hasCoprocess) {\n        if (identifier && [[NSUserDefaults standardUserDefaults] boolForKey:identifier]) {\n            return;\n        }\n        NSString *message = [NSString stringWithFormat:@\"%@: Can't run two coprocesses at once.\", triggerName];\n        NSArray<NSString *> *actions = identifier ? @[ @\"Silence Warning\" ] : @[];\n        iTermAnnouncementViewController *announcement =\n        [iTermAnnouncementViewController announcementWithTitle:message\n                                                         style:kiTermAnnouncementViewStyleWarning\n                                                   withActions:actions\n                                                    completion:^(int selection) {\n            if (!identifier) {\n                return;\n            }\n            switch (selection) {\n                case 0:\n                    [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                            forKey:identifier];\n                    break;\n            }\n        }];\n        [self queueAnnouncement:announcement\n                     identifier:kTwoCoprocessesCanNotRunAtOnceAnnouncementIdentifier];\n    } else if (command) {\n        if (silent) {\n            [self launchSilentCoprocessWithCommand:command];\n        } else {\n            [self launchCoprocessWithCommand:command];\n        }\n    }\n}\n\n- (void)triggerSideEffectPostUserNotificationWithMessage:(NSString * _Nonnull)message {\n    [iTermGCD assertMainQueueSafe];\n    iTermNotificationController *notificationController = [iTermNotificationController sharedInstance];\n    [notificationController notify:message\n                   withDescription:[NSString stringWithFormat:@\"A trigger fired in session \\\"%@\\\" in tab #%d.\",\n                                    [[self name] removingHTMLFromTabTitleIfNeeded],\n                                    self.delegate.tabNumber]\n                       windowIndex:[self screenWindowIndex]\n                          tabIndex:[self screenTabIndex]\n                         viewIndex:[self screenViewIndex]];\n}\n\n// Scroll so that `absLine` is the last visible onscreen.\n- (void)triggerSideEffectStopScrollingAtLine:(long long)absLine {\n    [iTermGCD assertMainQueueSafe];\n    const long long line = absLine - _screen.totalScrollbackOverflow;\n    if (line < 0) {\n        return;\n    }\n    const int height = MAX(1, _screen.height);\n    const int top = MAX(0, line - height + 1);\n    if (_screen.numberOfLines < line) {\n        return;\n    }\n    [_textview scrollLineNumberRangeIntoView:VT100GridRangeMake(top, height)];\n    [[self.view.scrollview ptyVerticalScroller] setUserScroll:YES];\n}\n\n- (void)triggerSideEffectOpenPasswordManagerToAccountName:(NSString * _Nullable)accountName {\n    [iTermGCD assertMainQueueSafe];\n    // Dispatch because you can't have a runloop in a side-effect and the password manager is a bunch of modal UI - why take chances?\n    dispatch_async(dispatch_get_main_queue(), ^{\n        iTermApplicationDelegate *itad = [iTermApplication.sharedApplication delegate];\n        [itad openPasswordManagerToAccountName:accountName\n                                         inSession:self];\n    });\n}\n\n- (void)triggerSideEffectRunBackgroundCommand:(NSString *)command pool:(iTermBackgroundCommandRunnerPool *)pool {\n    [iTermGCD assertMainQueueSafe];\n    iTermBackgroundCommandRunner *runner = [pool requestBackgroundCommandRunnerWithTerminationBlock:nil];\n    runner.command = command;\n    runner.title = @\"Run Command Trigger\";\n    runner.notificationTitle = @\"Run Command Trigger Failed\";\n    runner.shell = self.userShell;\n    [runner run];\n}\n\n- (void)triggerWriteTextWithoutBroadcasting:(NSString * _Nonnull)text {\n    [self writeTaskNoBroadcast:text];\n}\n\n- (iTermVariableScope *)triggerSideEffectVariableScope {\n    [iTermGCD assertMainQueueSafe];\n    return self.variablesScope;\n}\n\n- (void)triggerSideEffectSetTitle:(NSString * _Nonnull)newName {\n    [iTermGCD assertMainQueueSafe];\n    [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionTriggerName: newName,\n                                                    iTermVariableKeySessionAutoNameFormat: newName }];\n    if (newName.length > 0) {\n        [self enableSessionNameTitleComponentIfPossible];\n    }\n}\n\n- (void)triggerSideEffectInvokeFunctionCall:(NSString * _Nonnull)invocation\n                              withVariables:(NSDictionary * _Nonnull)temporaryVariables\n                                   captures:(NSArray<NSString *> * _Nonnull)captureStringArray\n                                    trigger:(Trigger * _Nonnull)trigger {\n    [iTermGCD assertMainQueueSafe];\n    iTermVariableScope *scope =\n    [self.variablesScope variableScopeByAddingBackreferences:captureStringArray\n                                                       owner:trigger];\n    [scope setValuesFromDictionary:temporaryVariables];\n    [self invokeFunctionCall:invocation scope:scope origin:@\"Trigger\"];\n}\n\n- (void)triggerSideEffectSetValue:(id _Nullable)value\n                 forVariableNamed:(NSString * _Nonnull)name {\n    [iTermGCD assertMainQueueSafe];\n    [self.genericScope setValue:value forVariableNamed:name];\n}\n\n- (void)triggerSideEffectCurrentDirectoryDidChange:(NSString *)newPath {\n    [iTermGCD assertMainQueueSafe];\n    [self didUpdateCurrentDirectory:newPath];\n}\n\n#pragma mark - iTermPasteboardReporterDelegate\n\n- (void)pasteboardReporter:(iTermPasteboardReporter *)sender reportPasteboard:(NSString *)pasteboard {\n    NSData *data = [_screen.terminalOutput reportPasteboard:pasteboard\n                                                   contents:[NSString stringFromPasteboard]];\n    [self screenSendReportData:data];\n    [_view showUnobtrusiveMessage:[NSString stringWithFormat:@\"Clipboard contents reported\"]\n                         duration:3];\n}\n\n- (void)pasteboardReporterRequestPermission:(iTermPasteboardReporter *)sender\n                                 completion:(void (^)(BOOL, BOOL))completion {\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:@\"Share clipboard contents with app in terminal?\"\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"Just Once\", @\"Always\", @\"Never\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case 0:\n                completion(YES, NO);\n                break;\n\n            case 1:\n                completion(YES, YES);\n                break;\n\n            case 2:\n                // Never\n                completion(NO, YES);\n                break;\n\n            default:\n                // Cancel\n                completion(NO, NO);\n                break;\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:[[NSUUID UUID] UUIDString]];\n}\n\n#pragma mark - iTermConductorDelegate\n\n- (void)conductorWriteString:(NSString *)string {\n    DLog(@\"Conductor write: %@\", string);\n    [self writeTaskNoBroadcast:string];\n}\n\n- (void)conductorWillDie {\n    DLog(@\"conductorWillDie\");\n    iTermPublisher<NSNumber *> *replacement = _conductor.parent.cpuUtilizationPublisher;\n    if (!replacement) {\n        replacement = [iTermLocalCPUUtilizationPublisher sharedInstance];\n    }\n    [[iTermCPUUtilization instanceForSessionID:_guid] setPublisher:replacement];\n}\n\n- (void)conductorDidUnhook {\n    [self conductorWillDie];\n}\n\n- (void)conductorAbortWithReason:(NSString *)reason {\n    XLog(@\"conductor aborted: %@\", reason);\n    [self conductorWillDie];\n\n    NSString *location = _conductor.parent.sshIdentity.compactDescription;\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState appendStringAtCursor:@\"An error occurred while setting up the SSH environment:\"];\n        [mutableState appendCarriageReturnLineFeed];\n        [mutableState appendStringAtCursor:reason];\n        [mutableState appendCarriageReturnLineFeed];\n        NSString *message = [mutableState sshEndBannerTerminatingCount:1 newLocation:location];\n        [mutableState appendBannerMessage:message];\n    }];\n    [self unhookSSHConductor];\n}\n\n- (void)conductorQuit {\n    DLog(@\"conductorQuit\");\n    [self conductorWillDie];\n    NSString *identity = _conductor.sshIdentity.description;\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState appendBannerMessage:[NSString stringWithFormat:@\"Disconnected from %@\", identity]];\n    }];\n    [self unhookSSHConductor];\n    [_sshWriteQueue setLength:0];\n}\n\n- (void)conductorStateDidChange {\n    DLog(@\"conductorDidExfiltrateState\");\n    [self updateVariablesFromConductor];\n}\n\n- (void)updateVariablesFromConductor {\n    if (!_conductor) {\n        self.variablesScope.homeDirectory = NSHomeDirectory();\n        self.variablesScope.sshIntegrationLevel = 0;\n        self.variablesScope.shell = [self bestGuessAtUserShell];\n        self.variablesScope.uname = [self bestGuessAtUName];\n        return;\n    }\n    const NSInteger level = _conductor.framing ? 2 : 1;\n    self.variablesScope.sshIntegrationLevel = level;\n    switch (level) {\n        case 0: {\n            const BOOL onLocalhost = (self.currentHost == nil || self.currentHost.isLocalhost);\n            if (onLocalhost) {\n                self.variablesScope.homeDirectory = NSHomeDirectory();\n                break;\n            }\n            // SSHed without integration\n            self.variablesScope.homeDirectory = nil;\n            self.variablesScope.shell = nil;\n            self.variablesScope.uname = nil;\n            break;\n        }\n        case 1:\n            // Definitely ssh'ed, but no way to get this info.\n            self.variablesScope.homeDirectory = nil;\n            self.variablesScope.shell = nil;\n            self.variablesScope.uname = nil;\n            break;\n        case 2:\n            self.variablesScope.homeDirectory = _conductor.homeDirectory;\n            self.variablesScope.shell = _conductor.shell;\n            self.variablesScope.uname = _conductor.uname;\n            break;\n    }\n}\n\n@end\n", "//\n//  TmuxController.h\n//  iTerm\n//\n//  Created by George Nachman on 11/27/11.\n//\n\n#import <Cocoa/Cocoa.h>\n#import \"ProfileModel.h\"\n#import \"iTermInitialDirectory.h\"\n#import \"iTermTmuxSessionObject.h\"\n#import \"TmuxGateway.h\"\n#import \"WindowControllerInterface.h\"\n\n@class iTermFontTable;\n@class iTermVariableScope;\n@class PTYSession;\n@class PTYTab;\n@class PseudoTerminal;\n@class EquivalenceClassSet;\n\n// Posted just before sessions change (names, addition, deletion)\nextern NSString *const kTmuxControllerSessionsWillChange;\n// Posted when sessions change (names, addition, deletion)\nextern NSString *const kTmuxControllerSessionsDidChange;\n// Posted after detaching\nextern NSString *const kTmuxControllerDetachedNotification;\n// Posted when a window changes.\nextern NSString *const kTmuxControllerWindowsChangeNotification;\n// Posted when a window changes name\nextern NSString *const kTmuxControllerWindowWasRenamed;\n// Posted when a window opens\nextern NSString *const kTmuxControllerWindowDidOpen;\n// Posted when a window closes\nextern NSString *const kTmuxControllerWindowDidClose;\n// Posted when the attached session changes\nextern NSString *const kTmuxControllerAttachedSessionDidChange;\n// Posted when a session changes name\nextern NSString *const kTmuxControllerSessionWasRenamed;\n// Posted when set-titles option changes. Object is tmux controller.\nextern NSString *const kTmuxControllerDidFetchSetTitlesStringOption;\n// Posted before sending kill-window\nextern NSString *const iTermTmuxControllerWillKillWindow;\n// Posted when one or more windows changes hidden status\nextern NSString *const kTmuxControllerDidChangeHiddenWindows;\n\n@protocol iTermTmuxControllerSession<NSObject>\n- (void)tmuxControllerSessionSetTTL:(NSTimeInterval)ttl redzone:(BOOL)redzone;\n- (void)revealIfTabSelected;\n@end\n\n@interface TmuxController : NSObject\n\n@property(nonatomic, readonly) TmuxGateway *gateway;\n@property(nonatomic, retain) NSMutableDictionary *windowPositions;\n@property(nonatomic, copy) NSString *sessionName;\n@property(nonatomic, copy) NSArray<iTermTmuxSessionObject *> *sessionObjects;\n@property(nonatomic, assign) BOOL ambiguousIsDoubleWidth;\n@property(nonatomic, assign) NSInteger unicodeVersion;\n@property(nonatomic, readonly) NSString *clientName;\n@property(nonatomic, readonly) int sessionId;\n@property(nonatomic, readonly) BOOL hasOutstandingWindowResize;\n@property(nonatomic, readonly, getter=isAttached) BOOL attached;\n@property(nonatomic, readonly) BOOL detaching;\n@property(nonatomic, copy) Profile *sharedProfile;\n@property(nonatomic, readonly) NSDictionary *sharedFontOverrides;\n@property(nonatomic, readonly) NSDictionary *sharedKeyMappingOverrides;\n@property(nonatomic, readonly) NSString *sessionGuid;\n@property(nonatomic, readonly) BOOL variableWindowSize;\n@property(nonatomic, readonly) BOOL shouldSetTitles;\n@property(nonatomic, readonly) BOOL serverIsLocal;\n@property(nonatomic, readonly) NSString *defaultTerminal;\n@property(nonatomic) NSRect initialWindowHint;\n@property(nonatomic, readonly) BOOL detached;\n@property(nonatomic, readonly) NSArray<NSNumber *> *windowPaneIDs;\n\n- (instancetype)initWithGateway:(TmuxGateway *)gateway\n                     clientName:(NSString *)clientName\n                        profile:(Profile *)profile\n                   profileModel:(ProfileModel *)profileModel NS_DESIGNATED_INITIALIZER;\n- (instancetype)init NS_UNAVAILABLE;\n\n- (Profile *)profileForWindow:(int)window;\n- (NSString *)perWindowSettingsForWindowWithGUID:(NSString *)terminalGUID;\n- (NSString *)perTabSettingsForTabWithWindowID:(int)wid;\n- (NSDictionary *)fontOverridesForWindow:(int)window;\n\n- (void)openWindowsInitial;\n\n- (void)openWindowWithId:(int)windowId\n\t\t\t intentional:(BOOL)intentional\n                 profile:(Profile *)profile;\n\n- (void)openWindowWithId:(int)windowId\n\t\t\t  affinities:(NSArray *)affinities\n\t\t\t intentional:(BOOL)intentional\n                 profile:(Profile *)profile;\n\n- (void)hideWindow:(int)windowId;\n\n// Modifies a native tab to match the given server layout.\n// Returns YES if you should call adjustWindowSizeIfNeededForTabs: after all tabs have been updated.\n- (BOOL)setLayoutInTab:(PTYTab *)tab\n              toLayout:(NSString *)layout\n         visibleLayout:(NSString *)visibleLayout\n                zoomed:(NSNumber *)zoomed;\n- (void)adjustWindowSizeIfNeededForTabs:(NSArray<PTYTab *> *)tabs;\n\n- (void)sessionChangedTo:(NSString *)newSessionName sessionId:(int)sessionid;\n- (void)sessionsChanged;\n- (void)session:(int)sessionId renamedTo:(NSString *)newName;\n- (void)windowsChanged;\n- (void)windowWasRenamedWithId:(int)id to:(NSString *)newName;\n\n// Call `block` when a window pane with `wp` is registered. If one is already registered, it will be called asynchronously.\n- (void)whenPaneRegistered:(int)wp call:(void (^)(PTYSession<iTermTmuxControllerSession> *))block;\n\n- (PTYSession<iTermTmuxControllerSession> *)sessionForWindowPane:(int)windowPane;\n- (PTYTab *)window:(int)window;\n- (NSArray<PTYSession<iTermTmuxControllerSession> *> *)sessionsInWindow:(int)window;\n- (void)registerSession:(PTYSession<iTermTmuxControllerSession> *)aSession\n               withPane:(int)windowPane\n               inWindow:(int)window;\n- (void)deregisterWindow:(int)window windowPane:(int)windowPane session:(id)session;\n- (void)changeWindow:(int)window tabTo:(PTYTab *)tab;\n- (NSValue *)positionForWindowWithPanes:(NSArray *)panes windowID:(int)windowID;\n\n// This should be called after the host sends an %exit command.\n- (void)detach;\n- (void)windowDidResize:(NSWindowController<iTermWindowController> *)term;\n- (void)fitLayoutToWindows;\n- (void)validateOptions;\n- (void)ping;\n- (void)enablePauseModeIfPossible;\n- (void)unpausePanes:(NSArray<NSNumber *> *)wps;\n- (void)pausePanes:(NSArray<NSNumber *> *)wps;\n- (void)didPausePane:(int)wp;\n\n// Issue tmux commands to infer bounds on the version.\n- (void)guessVersion;\n- (void)loadTitleFormat;\n\n- (void)setClientSize:(NSSize)size;\n- (void)windowPane:(int)wp\n         resizedBy:(int)amount\n      horizontally:(BOOL)wasHorizontal;\n\n// If completion is nonnull it will be called with the new window pane or -1 on error.\n- (void)splitWindowPane:(int)wp\n             vertically:(BOOL)splitVertically\n                  scope:(iTermVariableScope *)scope\n       initialDirectory:(iTermInitialDirectory *)initialDirectory\n             completion:(void (^)(int wp))completion;\n\n- (void)newWindowInSessionNumber:(NSNumber *)sessionNumber\n                           scope:(iTermVariableScope *)scope\n                initialDirectory:(iTermInitialDirectory *)initialDirectory;\n\n- (void)selectPane:(int)windowPane;\n\n- (PseudoTerminal *)windowWithAffinityForWindowId:(int)wid;\n- (NSSet<NSObject<NSCopying> *> *)savedAffinitiesForWindow:(NSString *)value;\n- (NSSize)sizeOfSmallestWindowAmong:(NSSet<NSString *> *)siblings;\n\n// nil: Open in a new window\n// A string of a non-negative integer (e.g., @\"2\") means to open alongside a tmux window with that ID\n// A string of a negative integer (e.g., @\"-2\") means to open in an iTerm2 window with abs(windowId)==window number.\n// If affinity is given then the newly created tab will be considered \"manually opened\" which is\n// used to determine the tab's eventual location in the tabbar.\n- (void)newWindowWithAffinity:(NSString *)windowIdString\n                         size:(NSSize)size\n             initialDirectory:(iTermInitialDirectory *)initialDirectory\n                        index:(NSNumber *)index\n                        scope:(iTermVariableScope *)scope\n                   completion:(void (^)(int))completion;\n\n- (void)movePane:(int)srcPane\n        intoPane:(int)destPane\n      isVertical:(BOOL)splitVertical\n          before:(BOOL)addBefore;\n- (void)breakOutWindowPane:(int)windowPane toPoint:(NSPoint)screenPoint;\n- (void)breakOutWindowPane:(int)windowPane toTabAside:(NSString *)sibling;\n\n- (void)killWindowPane:(int)windowPane;\n- (void)killWindow:(int)window;\n- (void)unlinkWindowWithId:(int)windowId;\n- (void)requestDetach;\n- (void)renameWindowWithId:(int)windowId\n           inSessionNumber:(NSNumber *)sessionNumber\n                    toName:(NSString *)newName;\n\n// Rename the window and save in tmux server setting.\n- (void)setWindowTitleOverride:(NSString *)title\n                        window:(int)windowId;\n- (BOOL)canRenamePane;\n- (void)renamePane:(int)windowPane toTitle:(NSString *)newTitle;\n- (void)setHotkeyForWindowPane:(int)windowPane to:(NSDictionary *)hotkey;\n- (NSDictionary *)hotkeyForWindowPane:(int)windowPane;\n\n- (void)setTabColorString:(NSString *)colorString forWindowPane:(int)windowPane;\n- (NSString *)tabColorStringForWindowPane:(int)windowPane;\n\n- (void)linkWindowId:(int)windowId\n     inSessionNumber:(int)sessionNumber\n     toSessionNumber:(int)targetSession;\n\n- (void)moveWindowId:(int)windowId\n     inSessionNumber:(int)sessionNumber\n     toSessionNumber:(int)targetSessionNumber;\n\n- (void)renameSessionNumber:(int)sessionNumber\n                         to:(NSString *)newName;\n\n- (void)killSessionNumber:(int)sessionNumber;\n- (void)attachToSessionWithNumber:(int)sessionNumber;\n- (void)addSessionWithName:(NSString *)sessionName;\n// NOTE: If anything goes wrong the selector will not be called.\n- (void)listWindowsInSessionNumber:(int)sessionNumber\n                            target:(id)target\n                          selector:(SEL)selector\n                            object:(id)object;\n\n- (void)listSessions;\n- (void)saveAffinities;\n- (void)saveWindowOrigins;\n- (void)saveHiddenWindows;\n- (void)savePerWindowSettings;\n- (void)savePerTabSettings;\n\n- (void)swapPane:(int)pane1 withPane:(int)pane2;\n- (void)toggleZoomForPane:(int)pane;\n- (void)setPartialWindowIdOrder:(NSArray *)partialOrder;\n- (void)setCurrentWindow:(int)windowId;\n- (void)checkForUTF8;\n- (void)loadDefaultTerminal;\n- (void)loadKeyBindings;\n- (void)exitCopyMode;\n\n- (void)clearHistoryForWindowPane:(int)windowPane;\n\n- (void)setTmuxFontTable:(iTermFontTable *)fontTable\n                hSpacing:(CGFloat)hs\n                vSpacing:(CGFloat)vs\n                  window:(int)window;\n- (BOOL)windowIsHidden:(int)windowId;\n- (void)setLayoutInWindowPane:(int)windowPane toLayoutNamed:(NSString *)name;\n- (void)setLayoutInWindow:(int)window toLayout:(NSString *)layout;\n- (NSArray<PTYSession<iTermTmuxControllerSession> *> *)clientSessions;\n\n- (void)setSize:(NSSize)size window:(int)window;\n\n- (void)setEncodedUserVars:(NSString *)encodedUserVars forPane:(int)paneID;\n- (void)setUserVariableWithKey:(NSString *)key\n                         value:(NSString *)value\n                          pane:(int)paneID;\n- (NSDictionary<NSString *, NSString *> *)userVarsForPane:(int)paneID;\n- (void)activeWindowPaneDidChangeInWindow:(int)windowID toWindowPane:(int)paneID;\n- (void)activeWindowDidChangeTo:(int)windowID;\n- (void)setCurrentLatency:(NSTimeInterval)latency forPane:(int)wp;\n- (void)copyBufferToLocalPasteboard:(NSString *)bufferName;\n- (void)restoreWindowFrame:(PseudoTerminal *)term;\n\n@end\n", "//\n//  TmuxController.m\n//  iTerm\n//\n//  Created by George Nachman on 11/27/11.\n//\n\n#import \"TmuxController.h\"\n#import \"DebugLogging.h\"\n#import \"EquivalenceClassSet.h\"\n#import \"iTerm2SharedARC-Swift.h\"\n#import \"iTermAdvancedSettingsModel.h\"\n#import \"iTermApplicationDelegate.h\"\n#import \"iTermController.h\"\n#import \"iTermInitialDirectory.h\"\n#import \"iTermInitialDirectory+Tmux.h\"\n#import \"iTermKeyMappings.h\"\n#import \"iTermKeystroke.h\"\n#import \"iTermLSOF.h\"\n#import \"iTermNotificationController.h\"\n#import \"iTermPreferenceDidChangeNotification.h\"\n#import \"iTermPreferences.h\"\n#import \"iTermProfilePreferences.h\"\n#import \"iTermShortcut.h\"\n#import \"iTermTmuxBufferSizeMonitor.h\"\n#import \"iTermTuple.h\"\n#import \"NSArray+iTerm.h\"\n#import \"NSData+iTerm.h\"\n#import \"NSFont+iTerm.h\"\n#import \"NSStringITerm.h\"\n#import \"PreferencePanel.h\"\n#import \"PseudoTerminal.h\"\n#import \"PTYSession.h\"\n#import \"PTYTab.h\"\n#import \"PTYTextView.h\"\n#import \"RegexKitLite.h\"\n#import \"TmuxControllerRegistry.h\"\n#import \"TmuxDashboardController.h\"\n#import \"TmuxGateway.h\"\n#import \"TmuxWindowOpener.h\"\n#import \"TSVParser.h\"\n\nNSString *const kTmuxControllerSessionsWillChange = @\"kTmuxControllerSessionsWillChange\";\nNSString *const kTmuxControllerSessionsDidChange = @\"kTmuxControllerSessionsDidChange\";\nNSString *const kTmuxControllerDetachedNotification = @\"kTmuxControllerDetachedNotification\";\nNSString *const kTmuxControllerWindowsChangeNotification = @\"kTmuxControllerWindowsChangeNotification\";\nNSString *const kTmuxControllerWindowWasRenamed = @\"kTmuxControllerWindowWasRenamed\";\nNSString *const kTmuxControllerWindowDidOpen = @\"kTmuxControllerWindowDidOpen\";\nNSString *const kTmuxControllerAttachedSessionDidChange = @\"kTmuxControllerAttachedSessionDidChange\";\nNSString *const kTmuxControllerWindowDidClose = @\"kTmuxControllerWindowDidClose\";\nNSString *const kTmuxControllerSessionWasRenamed = @\"kTmuxControllerSessionWasRenamed\";\nNSString *const kTmuxControllerDidFetchSetTitlesStringOption = @\"kTmuxControllerDidFetchSetTitlesStringOption\";\nNSString *const iTermTmuxControllerWillKillWindow = @\"iTermTmuxControllerWillKillWindow\";\nNSString *const kTmuxControllerDidChangeHiddenWindows = @\"kTmuxControllerDidChangeHiddenWindows\";\n\nstatic NSString *const iTermTmuxControllerEncodingPrefixHotkeys = @\"h_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixTabColors = @\"t_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixAffinities = @\"a_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixBuriedIndexes = @\"b_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixOrigins = @\"o_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixHidden = @\"i_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixUserVars = @\"u_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixPerWindowSettings = @\"w_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixPerTabSettings = @\"T_\";\n\nstatic NSString *const iTermTmuxControllerSplitStateCompletion = @\"completion\";\nstatic NSString *const iTermTmuxControllerSplitStateInitialPanes = @\"initial panes\";\nstatic NSString *const iTermTmuxControllerPhonyAffinity = @\"phony\";\n\n// Unsupported global options:\nstatic NSString *const kAggressiveResize = @\"aggressive-resize\";\n\n@interface TmuxController ()<iTermTmuxBufferSizeMonitorDelegate>\n\n@property(nonatomic, copy) NSString *clientName;\n@property(nonatomic, copy, readwrite) NSString *sessionGuid;\n\n@end\n\n@interface iTermTmuxWindowState : NSObject\n@property (nonatomic, strong) PTYTab *tab;\n@property (nonatomic) NSInteger refcount;\n@property (nonatomic, strong) Profile *profile;\n@property (nonatomic, strong) NSDictionary *fontOverrides;\n@end\n\n@interface iTermTmuxPendingWindow: NSObject\n@property (nonatomic, copy) void (^completion)(int);\n@property (nonatomic, strong) NSNumber *index;  // Tab index. Nullable.\n\n+ (instancetype)trivialInstance;\n+ (instancetype)withIndex:(NSNumber *)index completion:(void (^)(int))completion;\n@end\n\n@implementation iTermTmuxPendingWindow\n\n+ (instancetype)trivialInstance {\n    return [[self alloc] initWithIndex:nil completion:^(int i) { }];\n}\n\n+ (instancetype)withIndex:(NSNumber *)index completion:(void (^)(int))completion {\n    return [[self alloc] initWithIndex:index completion:completion];\n}\n\n- (instancetype)initWithIndex:(NSNumber *)index completion:(void (^)(int))completion {\n    if (!completion) {\n        return [self initWithIndex:index completion:^(int i) { }];\n    }\n    self = [super init];\n    if (self) {\n        assert(index == nil || [NSNumber castFrom:index] != nil);\n        _index = index;\n        _completion = [completion copy];\n    }\n    return self;\n}\n\n@end\n\n@implementation iTermTmuxWindowState\n@end\n\n@implementation TmuxController {\n    TmuxGateway *gateway_;\n    NSMutableDictionary *windowPanes_;  // paneId -> PTYSession *\n    NSMutableDictionary<NSNumber *, iTermTmuxWindowState *> *_windowStates;      // Key is window number\n    NSArray<iTermTmuxSessionObject *> *sessionObjects_;\n    int numOutstandingWindowResizes_;\n    NSMutableDictionary *windowPositions_;\n    NSSize lastSize_;  // last size for windowDidChange:\n    NSString *lastOrigins_;\n    NSString *sessionName_;\n    int sessionId_;\n    NSMutableSet *pendingWindowOpens_;\n    NSString *lastSaveAffinityCommand_;\n    // tmux windows that want to open as tabs in the same physical window\n    // belong to the same equivalence class.\n    EquivalenceClassSet *affinities_;\n    BOOL windowOriginsDirty_;\n    BOOL haveOutstandingSaveWindowOrigins_;\n    NSMutableDictionary *origins_;  // window id -> NSValue(Point) window origin\n    NSMutableSet<NSNumber *> *hiddenWindows_;\n    NSTimer *listSessionsTimer_;  // Used to do a cancelable delayed perform of listSessions.\n    BOOL ambiguousIsDoubleWidth_;\n    NSMutableDictionary<NSNumber *, NSDictionary *> *_hotkeys;\n    NSMutableSet<NSNumber *> *_paneIDs;  // existing pane IDs\n    NSMutableDictionary<NSNumber *, NSString *> *_tabColors;\n\n    // Have we guessed the server version? Don't try to open windows until this is true, because\n    // window opening is version-dependent (to avoid triggering bugs in tmux 1.8).\n    BOOL _versionKnown;\n    BOOL _wantsOpenWindowsInitial;\n\n    // Maps a window id string to a dictionary of window flags defined by TmuxWindowOpener (see the\n    // top of its header file)\n    NSMutableDictionary *_windowOpenerOptions;\n    BOOL _manualOpenRequested;\n    BOOL _allInitialWindowsAdded;\n    BOOL _haveOpenedInitialWindows;\n    ProfileModel *_profileModel;\n    // Maps the window ID of an about to be opened window to a completion block to invoke when it opens.\n    NSMutableDictionary<NSNumber *, iTermTmuxPendingWindow *> *_pendingWindows;\n    BOOL _hasStatusBar;\n    BOOL _focusEvents;\n    int _currentWindowID;  // -1 if undefined\n    // Pane -> (Key -> Value)\n    NSMutableDictionary<NSNumber *, NSMutableDictionary<NSString *, NSString *> *> *_userVars;\n    NSMutableDictionary<NSNumber *, void (^)(PTYSession<iTermTmuxControllerSession> *)> *_when;\n    NSMutableArray *_listWindowsQueue;\n    // If nonnegative, make this pane active after it comes in to being. If negative, invalid.\n    int _paneToActivateWhenCreated;\n    iTermTmuxBufferSizeMonitor *_tmuxBufferMonitor;\n    NSMutableDictionary<NSNumber *, NSValue *> *_windowSizes;  // window -> NSValue cell size\n    BOOL _versionDetected;\n    // terminal guid -> [(tmux window id, tab index), ...]\n    NSMutableDictionary<NSString *, NSMutableArray<iTermTuple<NSNumber *, NSNumber *> *> *> *_buriedWindows;\n    NSString *_lastSaveBuriedIndexesCommand;\n\n    NSString *_lastSavePerWindowSettingsCommand;\n    NSDictionary<NSString *, NSString *> *_perWindowSettings;\n\n    NSString *_lastSavePerTabSettingsCommand;\n    NSDictionary<NSString *, NSString *> *_perTabSettings;\n\n    // When positive do not send select-pane or select-window commands when the selected pane\n    // or window changes. This is to prevent getting into a loop like this:\n    // 1. > select-window -t @2            // iTerm2-initiated\n    // 2. > select-window -t @3            // iTerm2-initiated\n    // 3. < %session-window-changed $1 @2  // Notification for (1)\n    // 4. > select-window -t @2            // In response to (3)\n    // 5. < %session-window-changed $1 @3  // Notification for (2)\n    // 6. > select-window -t @3            // In response to (5)\n    // 7. < %session-window-changed $1 @2  // Notification for (4)\n    // 8. > select-window -t @2            // In response to (7)\n    // 9. < %session-window-changed $1 @3  // Notification for (6)\n    // GOTO 6\n    // If we don't tell tmux to change the active window or pane in response to its notification\n    // we'll eventually catch up to its current state and remain stable.\n    NSInteger _suppressActivityChanges;\n    BOOL _shouldWorkAroundTabBug;\n\n    // Window frames before font size changes. Used to preserve window size in\n    // the face of font sizes by just setting it back to the right size after\n    // font size changes are finished happening.\n    NSMutableDictionary<NSString *, NSValue *> *_savedFrames;\n}\n\n@synthesize gateway = gateway_;\n@synthesize windowPositions = windowPositions_;\n@synthesize sessionName = sessionName_;\n@synthesize sessionObjects = sessionObjects_;\n@synthesize ambiguousIsDoubleWidth = ambiguousIsDoubleWidth_;\n@synthesize sessionId = sessionId_;\n@synthesize detached = detached_;\n\nstatic NSDictionary *iTermTmuxControllerMakeFontOverrides(iTermFontTable *fontTable,\n                                                          CGFloat hs,\n                                                          CGFloat vs) {\n    return @{ KEY_NORMAL_FONT: fontTable.asciiFont.font.stringValue,\n              KEY_NON_ASCII_FONT: fontTable.defaultNonASCIIFont.font.stringValue,\n              KEY_FONT_CONFIG: fontTable.configString ?: [NSNull null],\n              KEY_HORIZONTAL_SPACING: @(hs),\n              KEY_VERTICAL_SPACING: @(vs) };\n}\nstatic NSDictionary *iTermTmuxControllerDefaultFontOverridesFromProfile(Profile *profile) {\n    return iTermTmuxControllerMakeFontOverrides([iTermFontTable fontTableForProfile:profile],\n                                                [iTermProfilePreferences floatForKey:KEY_HORIZONTAL_SPACING inProfile:profile],\n                                                [iTermProfilePreferences floatForKey:KEY_VERTICAL_SPACING inProfile:profile]);\n}\n\n- (instancetype)initWithGateway:(TmuxGateway *)gateway\n                     clientName:(NSString *)clientName\n                        profile:(NSDictionary *)profile\n                   profileModel:(ProfileModel *)profileModel {\n    self = [super init];\n    if (self) {\n        _sharedProfile = [profile copy];\n        _profileModel = profileModel;\n        _sharedFontOverrides = iTermTmuxControllerDefaultFontOverridesFromProfile(profile);\n        _sharedKeyMappingOverrides = [iTermKeyMappings keyMappingsForProfile:profile];\n\n        gateway_ = gateway;\n        _paneIDs = [[NSMutableSet alloc] init];\n        windowPanes_ = [[NSMutableDictionary alloc] init];\n        _windowStates = [[NSMutableDictionary alloc] init];\n        windowPositions_ = [[NSMutableDictionary alloc] init];\n        origins_ = [[NSMutableDictionary alloc] init];\n        pendingWindowOpens_ = [[NSMutableSet alloc] init];\n        hiddenWindows_ = [[NSMutableSet alloc] init];\n        _hotkeys = [[NSMutableDictionary alloc] init];\n        _tabColors = [[NSMutableDictionary alloc] init];\n        self.clientName = [[TmuxControllerRegistry sharedInstance] uniqueClientNameBasedOn:clientName];\n        _windowOpenerOptions = [[NSMutableDictionary alloc] init];\n        _pendingWindows = [[NSMutableDictionary alloc] init];\n        _currentWindowID = -1;\n        _userVars = [[NSMutableDictionary alloc] init];\n        _when = [[NSMutableDictionary alloc] init];\n        [[TmuxControllerRegistry sharedInstance] setController:self forClient:_clientName];\n        _listWindowsQueue = [[NSMutableArray alloc] init];\n        _paneToActivateWhenCreated = -1;\n        _buriedWindows = [[NSMutableDictionary alloc] init];\n        _savedFrames = [[NSMutableDictionary alloc] init];\n        __weak __typeof(self) weakSelf = self;\n        [iTermPreferenceDidChangeNotification subscribe:self\n                                                  block:^(iTermPreferenceDidChangeNotification * _Nonnull notification) {\n            if ([notification.key isEqualToString:kPreferenceKeyTmuxPauseModeAgeLimit]) {\n                [weakSelf enablePauseModeIfPossible];\n            }\n        }];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(textViewWillChangeFont:)\n                                                     name:PTYTextViewWillChangeFontNotification\n                                                   object:nil];\n\n        _windowSizes = [[NSMutableDictionary alloc] init];\n        DLog(@\"Create %@ with gateway=%@\", self, gateway_);\n    }\n    return self;\n}\n\n- (Profile *)profileForWindow:(int)window {\n    if (!_variableWindowSize) {\n        return [self sharedProfile];\n    }\n    Profile *original = _windowStates[@(window)].profile;\n    if (!original) {\n        return [self sharedProfile];\n    }\n    NSMutableDictionary *temp = [original mutableCopy];\n    [temp it_mergeFrom:_windowStates[@(window)].fontOverrides];\n    return temp;\n}\n\n- (NSDictionary *)fontOverridesForWindow:(int)window {\n    if (!_variableWindowSize) {\n        return [self sharedFontOverrides];\n    }\n    return _windowStates[@(window)].fontOverrides ?: self.sharedFontOverrides;\n}\n\n- (NSDictionary *)sharedProfile {\n    Profile *profile = [_profileModel bookmarkWithGuid:_sharedProfile[KEY_GUID]] ?: _sharedProfile;\n    NSMutableDictionary *temp = [profile mutableCopy];\n    [_sharedFontOverrides enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        temp[key] = obj;\n    }];\n    NSMutableDictionary *updatedKeyMappings = [temp[KEY_KEYBOARD_MAP] mutableCopy];\n    [_sharedKeyMappingOverrides enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        updatedKeyMappings[key] = obj;\n    }];\n    temp[KEY_KEYBOARD_MAP] = updatedKeyMappings;\n    return temp;\n}\n\n// Called when listing window finishes. Happens for all new windows/tabs, whether initiated by iTerm2 or not.\n- (void)openWindowWithIndex:(int)windowIndex\n                       name:(NSString *)name\n                       size:(NSSize)size\n                     layout:(NSString *)layout\n              visibleLayout:(NSString *)visibleLayout\n                 affinities:(NSSet *)affinities\n                windowFlags:(NSString *)windowFlags\n                    profile:(Profile *)profile\n                    initial:(BOOL)initial\n                   tabIndex:(NSNumber *)tabIndex {\n    DLog(@\"openWindowWithIndex:%d name:%@ affinities:%@ flags:%@ initial:%@\",\n         windowIndex, name, affinities, windowFlags, @(initial));\n    if (!gateway_) {\n        DLog(@\"Deciding NOT to open window because gateway is nil\");\n        return;\n    }\n    NSNumber *n = [NSNumber numberWithInt:windowIndex];\n    if ([pendingWindowOpens_ containsObject:n]) {\n        return;\n    }\n    NSString *originalTerminalGUID = nil;\n    DLog(@\"Opening window with affinities: %@\", [affinities.allObjects componentsJoinedByString:@\" \"]);\n    DLog(@\"Existing affinities:\");\n    [affinities_ log];\n    for (NSString *a in affinities) {\n        if ([a hasPrefix:@\"pty-\"]) {\n            originalTerminalGUID = a;\n        }\n        [affinities_ setValue:a\n                 equalToValue:[NSString stringWithInt:windowIndex]];\n    }\n    [pendingWindowOpens_ addObject:n];\n    TmuxWindowOpener *windowOpener = [TmuxWindowOpener windowOpener];\n    windowOpener.ambiguousIsDoubleWidth = ambiguousIsDoubleWidth_;\n    windowOpener.unicodeVersion = self.unicodeVersion;\n    windowOpener.windowIndex = windowIndex;\n    windowOpener.name = name;\n    windowOpener.size = size;\n    windowOpener.layout = layout;\n    windowOpener.visibleLayout = visibleLayout;\n    windowOpener.maxHistory =\n        MAX([[gateway_ delegate] tmuxClientSize].height,\n            [[gateway_ delegate] tmuxNumberOfLinesOfScrollbackHistory]);\n    windowOpener.controller = self;\n    windowOpener.gateway = gateway_;\n    windowOpener.target = self;\n    windowOpener.selector = @selector(windowDidOpen:);\n    windowOpener.windowOptions = _windowOpenerOptions;\n    windowOpener.zoomed = windowFlags ? @([windowFlags containsString:@\"Z\"]) : nil;\n    windowOpener.manuallyOpened = _manualOpenRequested;\n    windowOpener.allInitialWindowsAdded = _allInitialWindowsAdded;\n    windowOpener.tabColors = _tabColors;\n    windowOpener.focusReporting = _focusEvents && [iTermAdvancedSettingsModel focusReportingEnabled];\n    windowOpener.profile = profile;\n    windowOpener.initial = initial;\n    windowOpener.anonymous = (_pendingWindows[@(windowIndex)] == nil);\n    windowOpener.completion = _pendingWindows[@(windowIndex)].completion;\n    windowOpener.minimumServerVersion = self.gateway.minimumServerVersion;\n    windowOpener.tabIndex = tabIndex ?: _pendingWindows[@(windowIndex)].index;\n    windowOpener.windowGUID = [self windowGUIDInAffinities:affinities];\n    windowOpener.perWindowSettings = _perWindowSettings;\n    windowOpener.perTabSettings = _perTabSettings;\n    windowOpener.shouldWorkAroundTabBug = _shouldWorkAroundTabBug;\n    DLog(@\"windowGUID=%@ perWindowSettings=%@ perTabSettings=%@\",\n         windowOpener.windowGUID, windowOpener.perWindowSettings, windowOpener.perTabSettings);\n    if (originalTerminalGUID) {\n        __weak __typeof(self) weakSelf = self;\n        windowOpener.newWindowBlock = ^(NSString *terminalGUID) {\n            [weakSelf replaceOldTerminalGUID:originalTerminalGUID with:terminalGUID];\n        };\n    }\n    [_pendingWindows removeObjectForKey:@(windowIndex)];\n    _manualOpenRequested = NO;\n    if (![windowOpener openWindows:YES]) {\n        [pendingWindowOpens_ removeObject:n];\n    }\n}\n\n- (NSString *)windowGUIDInAffinities:(NSSet<NSString *> *)affinities {\n    return [affinities.allObjects objectPassingTest:^BOOL(NSString *string, NSUInteger index, BOOL *stop) {\n        return [string hasPrefix:@\"pty-\"];\n    }];\n}\n\n// When we attach we get affinities with terminal GUIDs that may no longer exist. The GUIDs get\n// rewritten after creating the window for the first tab. For restored sessions it just works\n// because 2nd through Nth tabs can find their comrades through their affinity with its window ID.\n// For buried sessions, we must rewrite the terminal GUID since it has no affinity with other tabs\n// by window ID.\n- (void)replaceOldTerminalGUID:(NSString *)oldGUID with:(NSString *)newGUID {\n    DLog(@\"rename %@ to %@\", oldGUID, newGUID);\n    if (_buriedWindows[oldGUID] == nil) {\n        DLog(@\"no buried windows for that old guid\");\n        return;\n    }\n    if (_buriedWindows[newGUID] != nil) {\n        DLog(@\"already have buried windows for the new guid (wtf?)\");\n        return;\n    }\n    _buriedWindows[newGUID] = _buriedWindows[oldGUID];\n    [_buriedWindows removeObjectForKey:oldGUID];\n}\n\n- (BOOL)setLayoutInTab:(PTYTab *)tab\n              toLayout:(NSString *)layout\n         visibleLayout:(NSString *)visibleLayout\n                zoomed:(NSNumber *)zoomed {\n    DLog(@\"setLayoutInTab:%@ toLayout:%@ zoomed:%@\", tab, layout, zoomed);\n    TmuxWindowOpener *windowOpener = [TmuxWindowOpener windowOpener];\n    windowOpener.ambiguousIsDoubleWidth = ambiguousIsDoubleWidth_;\n    windowOpener.unicodeVersion = self.unicodeVersion;\n    windowOpener.layout = layout;\n    windowOpener.visibleLayout = visibleLayout;\n    windowOpener.maxHistory =\n        MAX([[gateway_ delegate] tmuxClientSize].height,\n            [[gateway_ delegate] tmuxNumberOfLinesOfScrollbackHistory]);\n    windowOpener.controller = self;\n    windowOpener.gateway = gateway_;\n    windowOpener.windowIndex = [tab tmuxWindow];\n    windowOpener.target = self;\n    windowOpener.selector = @selector(windowDidOpen:);\n    windowOpener.windowOptions = _windowOpenerOptions;\n    windowOpener.zoomed = zoomed;\n    windowOpener.tabColors = _tabColors;\n    windowOpener.focusReporting = _focusEvents && [iTermAdvancedSettingsModel focusReportingEnabled];\n    windowOpener.profile = [self profileForWindow:tab.tmuxWindow];\n    windowOpener.minimumServerVersion = self.gateway.minimumServerVersion;\n    windowOpener.shouldWorkAroundTabBug = _shouldWorkAroundTabBug;\n    return [windowOpener updateLayoutInTab:tab];\n}\n\n- (void)adjustWindowSizeIfNeededForTabs:(NSArray<PTYTab *> *)tabs {\n    DLog(@\"adjustWindowSizeIfNeededForTabs starting\");\n    if (![tabs anyWithBlock:^BOOL(PTYTab *tab) { return [tab updatedTmuxLayoutRequiresAdjustment]; }]) {\n        DLog(@\"adjustWindowSizeIfNeededForTabs: Layouts fit\");\n        return;\n    }\n    DLog(@\"layout is too large among at least one of: %@\", tabs);\n    // The tab's root splitter is larger than the window's tabview.\n    const BOOL outstandingResize =\n    [tabs anyWithBlock:^BOOL(PTYTab *tab) {\n        return [[[tab realParentWindow] uniqueTmuxControllers] anyWithBlock:^BOOL(TmuxController *controller) {\n            return [controller hasOutstandingWindowResize];\n        }];\n    }];\n    if (outstandingResize) {\n        DLog(@\"adjustWindowSizeIfNeededForTabs: One of the tabs has a tmux controller with an outstanding window resize. Don't update layouts.\");\n        return;\n    }\n    // If there are no outstanding window resizes then setTmuxLayout:tmuxController:\n    // has called fitWindowToTabs:, and it's still too big, so shrink\n    // the layout.\n\n    DLog(@\"adjustWindowSizeIfNeededForTabs: Tab's root splitter is oversize. Fit layout to windows\");\n    [self fitLayoutToWindows];\n}\n\n- (void)sessionChangedTo:(NSString *)newSessionName sessionId:(int)sessionid {\n    self.sessionGuid = nil;\n    self.sessionName = newSessionName;\n    sessionId_ = sessionid;\n    _paneToActivateWhenCreated = -1;\n    _detaching = YES;\n    [self closeAllPanes];\n    _detaching = NO;\n    [self openWindowsInitial];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerAttachedSessionDidChange\n                                                        object:nil];\n}\n\n- (void)sessionsChanged {\n    if (detached_) {\n        // Shouldn't happen, but better safe than sorry.\n        return;\n    }\n    // Wait a few seconds. We always get a sessions-changed notification when the last window in\n    // a session closes. To avoid spamming the command line with list-sessions, we wait a bit to see\n    // if there is an exit notification coming down the pipe.\n    const CGFloat kListSessionsDelay = 1.5;\n    [listSessionsTimer_ invalidate];\n    listSessionsTimer_ = [NSTimer scheduledTimerWithTimeInterval:kListSessionsDelay\n                                                          target:self\n                                                        selector:@selector(listSessions)\n                                                        userInfo:nil\n                                                         repeats:NO];\n}\n\n- (void)session:(int)sessionId renamedTo:(NSString *)newName {\n    if (sessionId == sessionId_) {\n        self.sessionName = newName;\n    }\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerSessionWasRenamed\n                                                        object:@[ @(sessionId), newName ?: @\"\", self ]];\n}\n\n- (void)windowWasRenamedWithId:(int)wid to:(NSString *)newName {\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerWindowWasRenamed\n                                                        object:@[ @(wid), newName ?: @\"\", self ]];\n}\n\n- (void)windowsChanged\n{\n    [[NSNotificationCenter defaultCenter]  postNotificationName:kTmuxControllerWindowsChangeNotification\n                                                         object:self];\n}\n\n- (NSArray *)listWindowFields {\n    NSArray<NSString *> *basic = @[@\"session_name\", @\"window_id\",\n                                   @\"window_name\", @\"window_width\", @\"window_height\",\n                                   @\"window_layout\", @\"window_flags\", @\"window_active\"];\n    if (![self versionAtLeastDecimalNumberWithString:@\"2.2\"]) {\n        return basic;\n    }\n    return [basic arrayByAddingObject:@\"window_visible_layout\"];\n}\n\n- (NSSet<NSObject<NSCopying> *> *)savedAffinitiesForWindow:(NSString *)value {\n    return [affinities_ valuesEqualTo:value];\n}\n\n- (void)initialListWindowsResponse:(NSString *)response {\n    DLog(@\"initialListWindowsResponse called\");\n    TSVDocument *doc = [response tsvDocumentWithFields:[self listWindowFields] workAroundTabBug:_shouldWorkAroundTabBug];\n    if (!doc) {\n        DLog(@\"Failed to parse %@\", response);\n        [gateway_ abortWithErrorMessage:[NSString stringWithFormat:@\"Bad response for initial list windows request: %@\", response]];\n        return;\n    }\n    NSMutableArray<NSArray *> *windowsToOpen = [NSMutableArray array];\n    BOOL haveHidden = NO;\n    NSNumber *newWindowAffinity = nil;\n    const iTermOpenTmuxWindowsMode openWindowsMode = [iTermPreferences intForKey:kPreferenceKeyOpenTmuxWindowsIn];\n    const BOOL newWindowsInTabs = openWindowsMode == kOpenTmuxWindowsAsNativeTabsInNewWindow;\n    DLog(@\"Iterating records...\");\n    for (NSArray *record in doc.records) {\n        DLog(@\"Consider record %@\", record);\n        const int wid = [self windowIdFromString:[doc valueInRecord:record forField:@\"window_id\"]];\n        if (hiddenWindows_ && [hiddenWindows_ containsObject:[NSNumber numberWithInt:wid]]) {\n            DLog(@\"Don't open window %d because it was saved hidden.\", wid);\n            haveHidden = YES;\n            // Let the user know something is up.\n            continue;\n        }\n        DLog(@\"Will open %d as it was not saved hidden\", wid);\n        NSNumber *n = [NSNumber numberWithInt:wid];\n        if (![affinities_ valuesEqualTo:[n stringValue]] && newWindowsInTabs) {\n            // Create an equivalence class of all unrecognied windows to each other.\n            if (!newWindowAffinity) {\n                DLog(@\"Create new affinity class for %@\", n);\n                newWindowAffinity = n;\n            } else {\n                DLog(@\"Add window id %@ to existing affinity class %@\", n, [newWindowAffinity stringValue]);\n                [affinities_ setValue:[n stringValue]\n                         equalToValue:[newWindowAffinity stringValue]];\n            }\n        }\n        [windowsToOpen addObject:record];\n    }\n    BOOL tooMany = NO;\n    if (windowsToOpen.count > [iTermPreferences intForKey:kPreferenceKeyTmuxDashboardLimit]) {\n        DLog(@\"There are too many windows to open so just show the dashboard\");\n        tooMany = YES;\n        // Save that these windows are hidden so the UI will be consistent next time you attach.\n        NSArray<NSNumber *> *wids = [windowsToOpen mapWithBlock:^NSNumber *(NSArray *record) {\n            const int wid = [self windowIdFromString:[doc valueInRecord:record forField:@\"window_id\"]];\n            return @(wid);\n        }];\n        [self hideWindows:wids andCloseTabs:NO];\n        [windowsToOpen removeAllObjects];\n    }\n    [[TmuxDashboardController sharedInstance] didAttachWithHiddenWindows:haveHidden tooManyWindows:tooMany];\n    if (tooMany) {\n        [[iTermNotificationController sharedInstance] notify:@\"Too many tmux windows!\" withDescription:@\"Use the tmux dashboard to select which to open.\"];\n    } else if (haveHidden) {\n        [[iTermNotificationController sharedInstance] notify:@\"Some tmux windows were hidden.\" withDescription:@\"Use the tmux dashboard to select which to open.\"];\n    }\n    for (NSArray *record in windowsToOpen) {\n        DLog(@\"Open window %@\", record);\n        int wid = [self windowIdFromString:[doc valueInRecord:record forField:@\"window_id\"]];\n        [self openWindowWithIndex:wid\n                             name:[[doc valueInRecord:record forField:@\"window_name\"] it_unescapedTmuxWindowName]\n                             size:NSMakeSize([[doc valueInRecord:record forField:@\"window_width\"] intValue],\n                                             [[doc valueInRecord:record forField:@\"window_height\"] intValue])\n                           layout:[doc valueInRecord:record forField:@\"window_layout\"]\n                    visibleLayout:[doc valueInRecord:record forField:@\"window_visible_layout\"]\n                       affinities:[self savedAffinitiesForWindow:[NSString stringWithInt:wid]]\n                      windowFlags:[doc valueInRecord:record forField:@\"window_flags\"]\n                          profile:[self sharedProfile]\n                          initial:YES\n                         tabIndex:nil];\n    }\n    if (windowsToOpen.count == 0) {\n        DLog(@\"Did not open any windows so turn on accept notifications in tmux gateway\");\n        gateway_.acceptNotifications = YES;\n        [self sendInitialWindowsOpenedNotificationIfNeeded];\n    }\n    _allInitialWindowsAdded = YES;\n}\n\n- (void)openWindowsInitial {\n    _allInitialWindowsAdded = NO;\n    DLog(@\"openWindowsInitial\\n%@\", [NSThread callStackSymbols]);\n    if (!_versionKnown) {\n        DLog(@\"Don't know version yet\");\n        _wantsOpenWindowsInitial = YES;\n        return;\n    }\n    NSString *command = [NSString stringWithFormat:@\"show -v -q -t $%d @iterm2_size\", sessionId_];\n    [gateway_ sendCommand:command\n           responseTarget:self\n         responseSelector:@selector(handleShowSize:)];\n}\n\n- (void)handleShowSize:(NSString *)response {\n    DLog(@\"handleShowSize: %@\", response);\n    NSScanner *scanner = [NSScanner scannerWithString:response ?: @\"\"];\n    int width = 0;\n    int height = 0;\n    BOOL ok = ([scanner scanInt:&width] &&\n               [scanner scanString:@\",\" intoString:nil] &&\n               [scanner scanInt:&height]);\n    if (ok) {\n        [self openWindowsOfSize:VT100GridSizeMake(width, height)];\n    } else {\n        [self openWindowsOfSize:[[gateway_ delegate] tmuxClientSize]];\n    }\n}\n\n- (void)openWindowsOfSize:(VT100GridSize)size {\n    DLog(@\"openWindowsOfSize: %@\", VT100GridSizeDescription(size));\n\n    // There's a (hopefully) minor race condition here. When we initially connect to\n    // a session we get its @iterm2_id. If one doesn't exist, it is assigned. This\n    // lets us know if a single instance of iTerm2 is trying to attach to the same\n    // session twice. A really evil user could attach twice to the same session\n    // simultaneously, and we'd get the value twice, see it's empty twice, and set\n    // it twice, causing chaos. Or two separate instances of iTerm2 attaching\n    // simultaneously could also hit this race. The consequence of this race\n    // condition is easily recovered from by reattaching.\n    [_windowSizes removeAllObjects];\n    NSString *getSessionGuidCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @iterm2_id\",\n                                       sessionId_];\n    size.height = [self adjustHeightForStatusBar:size.height];\n    if (size.width < 2) {\n        size.width = 2;\n    }\n    if (size.height < 2) {\n        size.height = 2;\n    }\n    // NOTE: setSizeCommand only set when variable window sizes are not in use.\n    NSString *setSizeCommand = [NSString stringWithFormat:@\"refresh-client -C %d,%d\",\n                                size.width, size.height];\n    NSString *listWindowsCommand = [NSString stringWithFormat:@\"list-windows -F %@\", [self listWindowsDetailedFormat]];\n    NSString *listSessionsCommand = @\"list-sessions -F \\\"#{session_id} #{session_name}\\\"\";\n    NSString *getAffinitiesCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @affinities\", sessionId_];\n    NSString *getPerWindowSettingsCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @per_window_settings\", sessionId_];\n    NSString *getPerTabSettingsCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @per_tab_settings\", sessionId_];\n    NSString *getBuriedIndexesCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @buried_indexes\", sessionId_];\n    NSString *getOriginsCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @origins\", sessionId_];\n    NSString *getHotkeysCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @hotkeys\", sessionId_];\n    NSString *getTabColorsCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @tab_colors\", sessionId_];\n    NSString *getHiddenWindowsCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @hidden\", sessionId_];\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:getSessionGuidCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getSessionGuidResponse:)\n                                           responseObject:nil\n                                                    flags:0],\n\t\t\t   [gateway_ dictionaryForCommand:setSizeCommand\n                               responseTarget:nil\n                             responseSelector:nil\n                               responseObject:nil\n                                        flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getHiddenWindowsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getHiddenWindowsResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getBuriedIndexesCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getBuriedIndexesResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getAffinitiesCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getAffinitiesResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getPerWindowSettingsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getPerWindowSettingsResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getPerTabSettingsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getPerTabSettingsResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getOriginsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getOriginsResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getHotkeysCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getHotkeysResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getTabColorsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getTabColorsResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:listSessionsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(listSessionsResponse:)\n                                           responseObject:nil\n                                                    flags:0],\n                           [gateway_ dictionaryForCommand:listWindowsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(initialListWindowsResponse:)\n                                           responseObject:nil\n                                                    flags:0] ];\n    [gateway_ sendCommandList:[commands filteredArrayUsingBlock:^BOOL(id anObject) {\n        return ![anObject isKindOfClass:[NSNull class]];\n    }]];\n}\n\n// Returns the mutable set of session GUIDs we're attached to.\n- (NSMutableSet *)attachedSessionGuids {\n    static NSMutableSet *gAttachedSessionGuids;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        gAttachedSessionGuids = [[NSMutableSet alloc] init];\n    });\n    return gAttachedSessionGuids;\n}\n\n// Sets the current controller's session guid and updates the global set of attached session GUIDs.\n// If guid is nil then it is removed from the global set.\n- (void)setSessionGuid:(NSString *)guid {\n    if (guid) {\n        [self.attachedSessionGuids addObject:guid];\n    } else if (_sessionGuid) {\n        [self.attachedSessionGuids removeObject:_sessionGuid];\n    }\n    _sessionGuid = [guid copy];\n}\n\n// This is where the race condition described in openWindowsInitial occurs.\n- (void)getSessionGuidResponse:(NSString *)sessionGuid {\n    if (!sessionGuid.length) {\n        NSString *guid = [NSString uuid];\n        NSString *command = [NSString stringWithFormat:@\"set -t $%d @iterm2_id \\\"%@\\\"\",\n                             sessionId_, guid];\n        [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n        self.sessionGuid = guid;\n        return;\n    }\n    if ([self.attachedSessionGuids containsObject:sessionGuid]) {\n        [self.gateway doubleAttachDetectedForSessionGUID:sessionGuid];\n        if ([self.attachedSessionGuids containsObject:sessionGuid]) {\n            // Delegate did not choose to force disconnect other, so we say goodbye.\n            TmuxGateway *gateway = gateway_;\n            [self detach];\n            [gateway forceDetach];\n            return;\n        }\n    }\n    // This is the only one.\n    self.sessionGuid = sessionGuid;\n}\n\n- (NSNumber *)_keyForWindowPane:(int)windowPane\n{\n    return [NSNumber numberWithInt:windowPane];\n}\n\n- (PTYSession<iTermTmuxControllerSession> *)sessionForWindowPane:(int)windowPane\n{\n    return [windowPanes_ objectForKey:[self _keyForWindowPane:windowPane]];\n}\n\n- (void)registerSession:(PTYSession<iTermTmuxControllerSession> *)aSession\n               withPane:(int)windowPane\n               inWindow:(int)window {\n    PTYTab *tab = [aSession.delegate.realParentWindow tabForSession:aSession];\n    ITCriticalError(tab != nil, @\"nil tab for session %@ with delegate %@ with realparentwindow %@\",\n                    aSession, aSession.delegate, aSession.delegate.realParentWindow);\n    if (tab) {\n        [self retainWindow:window withTab:tab];\n        [windowPanes_ setObject:aSession forKey:[self _keyForWindowPane:windowPane]];\n        void (^call)(PTYSession<iTermTmuxControllerSession> *) = _when[@(windowPane)];\n        if (call) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                call(aSession);\n            });\n            [_when removeObjectForKey:@(windowPane)];\n        }\n        if (_paneToActivateWhenCreated == windowPane) {\n            [aSession revealIfTabSelected];\n            _paneToActivateWhenCreated = -1;\n        }\n    }\n}\n\n- (void)deregisterWindow:(int)window windowPane:(int)windowPane session:(id)session\n{\n    id key = [self _keyForWindowPane:windowPane];\n    if (windowPanes_[key] == session) {\n        [self releaseWindow:window];\n        [windowPanes_ removeObjectForKey:key];\n        [_when removeObjectForKey:@(windowPane)];\n    }\n}\n\n- (void)whenPaneRegistered:(int)wp call:(void (^)(PTYSession<iTermTmuxControllerSession> *))block {\n    PTYSession<iTermTmuxControllerSession> *already = [self sessionForWindowPane:wp];\n    if (already) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            block(already);\n        });\n        return;\n    }\n\n    _when[@(wp)] = [block copy];\n}\n\n- (PTYTab *)window:(int)window {\n    return _windowStates[@(window)].tab;\n}\n\n- (NSArray<PTYSession<iTermTmuxControllerSession> *> *)sessionsInWindow:(int)window {\n    return [[self window:window] sessions];\n}\n\n- (BOOL)isAttached\n{\n    return !detached_;\n}\n\n- (void)requestDetach {\n    if (self.gateway.detachSent) {\n        if ([self.gateway.delegate tmuxGatewayShouldForceDetach]) {\n            [self.gateway forceDetach];\n        }\n    } else {\n        [self.gateway detach];\n    }\n}\n\n- (void)detach {\n    DLog(@\"%@: detach\", self);\n    self.sessionGuid = nil;\n    [listSessionsTimer_ invalidate];\n    listSessionsTimer_ = nil;\n    detached_ = YES;\n    [self closeAllPanes];\n    gateway_ = nil;\n    [_when enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, void (^ _Nonnull obj)(PTYSession<iTermTmuxControllerSession> *), BOOL * _Nonnull stop) {\n        obj(nil);\n    }];\n    [_when removeAllObjects];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerDetachedNotification\n                                                        object:self];\n    [[TmuxControllerRegistry sharedInstance] setController:nil\n                                                 forClient:self.clientName];\n}\n\n- (void)windowDidResize:(NSWindowController<iTermWindowController> *)term {\n    if (term.closing) {\n        return;\n    }\n    if (_variableWindowSize) {\n        [self variableSizeWindowDidResize:term];\n        return;\n    }\n    NSSize size = [term tmuxCompatibleSize];\n    DLog(@\"The tmux-compatible size of the window is %@\", NSStringFromSize(size));\n    if (size.width <= 0 || size.height <= 0) {\n        // After the last session closes a size of 0 is reported.\n        return;\n    }\n    DLog(@\"The last known size of tmux windows is %@\", NSStringFromSize(lastSize_));\n    if (NSEqualSizes(size, lastSize_)) {\n        return;\n    }\n\n    DLog(@\"Looks like the window resize is legit. Change client size to %@\", NSStringFromSize(size));\n    [self setClientSize:size];\n}\n\n- (void)variableSizeWindowDidResize:(NSWindowController<iTermWindowController> *)term {\n    DLog(@\"Window %@ did resize. Updating tmux tabs\", term);\n    [self setWindowSizes:[term.tabs mapWithBlock:^iTermTuple<NSString *, NSValue *> *(PTYTab *tab) {\n        if (!tab.tmuxTab || tab.tmuxController != self) {\n            return nil;\n        }\n        return [iTermTuple tupleWithObject:[NSString stringWithInt:tab.tmuxWindow]\n                                 andObject:[NSValue valueWithSize:tab.tmuxSize]];\n    }]];\n}\n\n- (NSSize)sizeOfSmallestWindowAmong:(NSSet<NSString *> *)siblings {\n    NSSize minSize = NSMakeSize(INFINITY, INFINITY);\n    for (NSString *windowKey in siblings) {\n        if ([windowKey hasPrefix:@\"pty\"]) {\n            continue;\n        }\n        PTYTab *tab = [self window:windowKey.intValue];\n        NSSize size = [tab tmuxSize];\n        if (size.width > 0 && size.height > 0) {\n            minSize.width = MIN(minSize.width, size.width);\n            DLog(@\"Ignore tab %@ with size of 0\", tab);\n            minSize.height = MIN(minSize.height, size.height);\n        }\n    }\n    return minSize;\n}\n\n- (void)fitLayoutToWindows {\n    if (!_windowStates.count) {\n        return;\n    }\n    if (_variableWindowSize) {\n        [self fitLayoutToVariableSizeWindows];\n        return;\n    }\n    NSSize minSize = NSMakeSize(INFINITY, INFINITY);\n    for (NSNumber *windowKey in _windowStates) {\n        PTYTab *tab = _windowStates[windowKey].tab;\n        NSSize size = [tab tmuxSize];\n        minSize.width = MIN(minSize.width, size.width);\n        minSize.height = MIN(minSize.height, size.height);\n    }\n    if (minSize.width <= 0 || minSize.height <= 0) {\n        // After the last session closes a size of 0 is reported. Apparently unplugging a monitor\n        // leads to a negative value here. That's inferred from crash report 1468853197.309853926.txt\n        // (at the time of that crash, this tested only for zero values so it passed through and\n        // asserted anyway).\n        return;\n    }\n    if (NSEqualSizes(minSize, lastSize_)) {\n        return;\n    }\n    DLog(@\"fitLayoutToWindows setting client size to %@\", NSStringFromSize(minSize));\n    [self setClientSize:minSize];\n}\n\n- (void)fitLayoutToVariableSizeWindows {\n    [self setWindowSizes:[_windowStates.allKeys mapWithBlock:^iTermTuple<NSString *, NSValue *> *(NSNumber *windowNumber) {\n        iTermTmuxWindowState *state = _windowStates[windowNumber];\n        PTYTab *tab = state.tab;\n        return [iTermTuple tupleWithObject:[NSString stringWithInt:windowNumber.intValue]\n                                 andObject:[NSValue valueWithSize:tab.tmuxSize]];\n    }]];\n}\n\n- (void)setSize:(NSSize)size window:(int)window {\n    if (!_variableWindowSize) {\n        [self setClientSize:size];\n        return;\n    }\n    [gateway_ sendCommandList:[self commandListToSetSize:size ofWindow:window]];\n}\n\n- (NSArray<NSDictionary *> *)commandListToSetSize:(NSSize)size ofWindow:(int)window {\n    NSSet *siblings = [affinities_ valuesEqualTo:[@(window) stringValue]];\n    if (!siblings.count) {\n        return [self commandListToSetSize:size ofWindows:@[ [NSString stringWithInt:window] ]];\n    } else {\n        return [self commandListToSetSize:size ofWindows:siblings.allObjects];\n    }\n}\n\n- (void)setWindowSizes:(NSArray<iTermTuple<NSString *, NSValue *> *> *)windowSizes {\n    [gateway_ sendCommandList:[self commandListToSetWindowSizes:windowSizes]];\n}\n\n- (NSArray<NSDictionary *> *)commandListToSetWindowSizes:(NSArray<iTermTuple<NSString *, NSValue *> *> *)windowSizes {\n    return [windowSizes mapWithBlock:^NSDictionary *(iTermTuple<NSString *,NSValue *> *tuple) {\n        NSString *window = tuple.firstObject;\n        NSSize size = tuple.secondObject.sizeValue;\n        if ([window hasPrefix:@\"pty\"] || [window hasSuffix:@\"_ph\"]) {\n            return nil;\n        }\n        // 10000 comes from WINDOW_MAXIMUM in tmux.h\n        if (size.width < 1 || size.height < 1 || size.width >= 10000 || size.height >= 10000) {\n            return nil;\n        }\n        DLog(@\"Set client size to %@\", NSStringFromSize(size));\n        NSValue *sizeValue = [NSValue valueWithSize:size];\n        if ([_windowSizes[@(window.intValue)] isEqual:sizeValue]) {\n            DLog(@\"It's already that size. Do nothing.\");\n            return nil;\n        }\n        _windowSizes[@(window.intValue)] = sizeValue;\n        NSString *command;\n        if ([self refreshClientSupportsWindowArgument]) {\n            command = [NSString stringWithFormat:@\"refresh-client -C @%d:%dx%d\", window.intValue, (int)size.width, (int)size.height];\n        } else {\n            command = [NSString stringWithFormat:@\"resize-window -x %@ -y %@ -t @%d\", @((int)size.width), @((int)size.height), window.intValue];\n        }\n        NSDictionary *dict = [gateway_ dictionaryForCommand:command\n                                             responseTarget:self\n                                           responseSelector:@selector(handleResizeWindowResponse:)\n                                             responseObject:nil\n                                                      flags:kTmuxGatewayCommandShouldTolerateErrors];\n        return dict;\n    }];\n}\n\n- (BOOL)refreshClientSupportsWindowArgument {\n    // https://github.com/tmux/tmux/issues/2594\n    return [self versionAtLeastDecimalNumberWithString:@\"3.4\"];\n}\n\n- (NSArray<NSDictionary *> *)commandListToSetSize:(NSSize)size ofWindows:(NSArray<NSString *> *)windows {\n    return [self commandListToSetWindowSizes:[windows mapWithBlock:^iTermTuple<NSString *, NSValue *> *(NSString *window) {\n        return [iTermTuple tupleWithObject:window andObject:[NSValue valueWithSize:size]];\n    }]];\n}\n\n- (void)handleResizeWindowResponse:(NSString *)response {\n}\n\n- (int)adjustHeightForStatusBar:(int)height {\n    // See here for the bug fix: https://github.com/tmux/tmux/pull/1731\n    NSArray *buggyVersions = @[ [NSDecimalNumber decimalNumberWithString:@\"2.9\"],\n                                [NSDecimalNumber decimalNumberWithString:@\"2.91\"] ];\n    if (_hasStatusBar && [buggyVersions containsObject:gateway_.minimumServerVersion]) {\n        return height + 1;\n    }\n    return height;\n}\n\n- (void)setClientSize:(NSSize)size {\n    DLog(@\"TmuxController setClientSize: Set client size to %@ from\\n%@\", NSStringFromSize(size), [NSThread callStackSymbols]);\n    DLog(@\"%@\", [NSThread callStackSymbols]);\n    assert(size.width > 0 && size.height > 0);\n    lastSize_ = size;\n    NSString *listStr = [self commandToListWindows];\n    NSString *setSizeCommand = [NSString stringWithFormat:@\"set -t $%d @iterm2_size %d,%d\",\n                                sessionId_, (int)size.width, (int)size.height];\n    const int height = [self adjustHeightForStatusBar:(int)size.height];\n    ITBetaAssert(height > 0, @\"Invalid size\");\n    [_windowSizes removeAllObjects];\n    NSArray *commands = [NSArray arrayWithObjects:\n                         [gateway_ dictionaryForCommand:setSizeCommand\n                                         responseTarget:nil\n                                       responseSelector:nil\n                                         responseObject:nil\n                                                  flags:0],\n                         [gateway_ dictionaryForCommand:[NSString stringWithFormat:@\"refresh-client -C %d,%d\",\n                                                         (int)size.width, height]\n                                         responseTarget:nil\n                                       responseSelector:nil\n                                         responseObject:nil\n                                                  flags:kTmuxGatewayCommandShouldTolerateErrors],\n                         [gateway_ dictionaryForCommand:listStr\n                                         responseTarget:self\n                                       responseSelector:@selector(listWindowsResponse:)\n                                         responseObject:nil\n                                                  flags:0],\n                         nil];\n    ++numOutstandingWindowResizes_;\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)ping {\n    // This command requires tmux 3.2, but if it fails that's OK too.\n    [gateway_ sendCommand:@\"refresh-client -fpause-after=0,wait-exit\"\n           responseTarget:self\n         responseSelector:@selector(handlePingResponse:)\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)handlePingResponse:(NSString *)ignore {\n}\n\n- (void)enablePauseModeIfPossible {\n    DLog(@\"enablePauseModeIfPossible min=%@ max=%@\", gateway_.minimumServerVersion, gateway_.maximumServerVersion);\n    if (gateway_.minimumServerVersion &&\n        [gateway_.minimumServerVersion compare:[NSDecimalNumber decimalNumberWithString:@\"3.2\"]] == NSOrderedAscending) {\n        DLog(@\"min < 3.2\");\n        return;\n    }\n    if (!gateway_.minimumServerVersion) {\n        DLog(@\"have no min version\");\n        return;\n    }\n    NSUInteger catchUpTime = [iTermPreferences unsignedIntegerForKey:kPreferenceKeyTmuxPauseModeAgeLimit];\n    gateway_.pauseModeEnabled = YES;\n    const NSInteger age = MAX(1, round(catchUpTime));\n    DLog(@\"Enable pause-after=%@\", @(age));\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"refresh-client -fpause-after=%@\", @(age)]\n           responseTarget:nil\n         responseSelector:nil];\n    _tmuxBufferMonitor = [[iTermTmuxBufferSizeMonitor alloc] initWithController:self\n                                                                       pauseAge:age];\n    _tmuxBufferMonitor.delegate = self;\n}\n\n- (void)didPausePane:(int)wp {\n    [_tmuxBufferMonitor resetPane:wp];\n}\n\n- (void)unpausePanes:(NSArray<NSNumber *> *)wps {\n    if (!gateway_.pauseModeEnabled) {\n        return;\n    }\n    TmuxWindowOpener *windowOpener = [TmuxWindowOpener windowOpener];\n    windowOpener.ambiguousIsDoubleWidth = ambiguousIsDoubleWidth_;\n    windowOpener.unicodeVersion = self.unicodeVersion;\n    windowOpener.maxHistory =\n        MAX([[gateway_ delegate] tmuxClientSize].height,\n            [[gateway_ delegate] tmuxNumberOfLinesOfScrollbackHistory]);\n    windowOpener.controller = self;\n    windowOpener.gateway = gateway_;\n    windowOpener.target = self;\n    windowOpener.selector = @selector(panesDidUnpause:);\n    windowOpener.shouldWorkAroundTabBug = _shouldWorkAroundTabBug;\n\n    windowOpener.minimumServerVersion = self.gateway.minimumServerVersion;\n    [windowOpener unpauseWindowPanes:wps];\n}\n\n- (void)panesDidUnpause:(TmuxWindowOpener *)opener {\n    for (NSNumber *wp in opener.unpausingWindowPanes) {\n        PTYSession<iTermTmuxControllerSession> *session = [self sessionForWindowPane:wp.intValue];\n        [session setTmuxHistory:[opener historyLinesForWindowPane:wp.intValue alternateScreen:NO]\n                     altHistory:[opener historyLinesForWindowPane:wp.intValue alternateScreen:YES]\n                          state:[opener stateForWindowPane:wp.intValue]];\n    }\n}\n\n- (void)pausePanes:(NSArray<NSNumber *> *)wps {\n    if (!gateway_.pauseModeEnabled) {\n        return;\n    }\n    NSString *adjustments = [[wps mapWithBlock:^id(NSNumber *anObject) {\n        return [NSString stringWithFormat:@\"%%%@:pause\", anObject];\n    }] componentsJoinedByString:@\" \"];\n    NSString *command = [NSString stringWithFormat:@\"refresh-client -A '%@'\", adjustments];\n    [self.gateway sendCommand:command responseTarget:self responseSelector:@selector(didPause:panes:) responseObject:wps flags:0];\n}\n\n- (void)didPause:(NSString *)result panes:(NSArray<NSNumber *> *)wps {\n    for (NSNumber *wp in wps) {\n        [self.gateway.delegate tmuxWindowPaneDidPause:wp.intValue\n                                         notification:NO];\n    }\n}\n\n// Make sure that current tmux options are compatible with iTerm.\n- (void)validateOptions\n{\n    for (NSString *option in [self unsupportedGlobalOptions]) {\n        [gateway_ sendCommand:[NSString stringWithFormat:@\"show-window-options -g %@\", option]\n               responseTarget:self\n             responseSelector:@selector(showWindowOptionsResponse:)];\n    }\n    [gateway_ sendCommand:@\"show-option -g -v status\"\n           responseTarget:self\n         responseSelector:@selector(handleStatusResponse:)];\n    [gateway_ sendCommand:@\"show-option -q -g -v focus-events\"\n           responseTarget:self\n         responseSelector:@selector(handleFocusEventsResponse:)];\n}\n\n- (void)handleStatusResponse:(NSString *)string {\n    _hasStatusBar = [string isEqualToString:@\"on\"];\n}\n\n- (void)handleFocusEventsResponse:(NSString *)string {\n    _focusEvents = [string isEqualToString:@\"on\"];\n}\n\n- (void)checkForUTF8 {\n    // Issue 5359\n    [gateway_ sendCommand:@\"list-sessions -F \\\"\\t\\\"\"\n           responseTarget:self\n         responseSelector:@selector(checkForUTF8Response:)\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)clearHistoryForWindowPane:(int)windowPane {\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"clear-history -t \\\"%%%d\\\"\", windowPane]\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)loadServerPID {\n    if (gateway_.minimumServerVersion.doubleValue < 2.1) {\n        return;\n    }\n    [gateway_ sendCommand:@\"display-message -p \\\"#{pid}\\\"\"\n           responseTarget:self\n         responseSelector:@selector(didLoadServerPID:)];\n}\n\n- (void)didLoadServerPID:(NSString *)pidString {\n    pid_t pid = [pidString integerValue];\n    if (pid > 0) {\n        NSString *name = [iTermLSOF nameOfProcessWithPid:pid isForeground:NULL];\n        _serverIsLocal = [name isEqualToString:@\"tmux\"];\n    }\n}\n\n- (void)loadDefaultTerminal {\n    NSString *command = @\"show-options -v -s default-terminal\";\n    [self.gateway sendCommand:command\n               responseTarget:self\n             responseSelector:@selector(didFetchDefaultTerminal:)\n               responseObject:nil\n                        flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)didFetchDefaultTerminal:(NSString *)defaultTerminal {\n    if (defaultTerminal.length > 0)  {\n        _defaultTerminal = [defaultTerminal copy];\n    }\n}\n\n- (void)loadTitleFormat {\n    NSDecimalNumber *v2_9 = [NSDecimalNumber decimalNumberWithString:@\"2.9\"];\n    if ([gateway_.minimumServerVersion compare:v2_9] == NSOrderedAscending) {\n        DLog(@\"tmux not new enough to use set-titles\");\n        return;\n    }\n\n    [gateway_ sendCommandList:@[ [gateway_ dictionaryForCommand:@\"show-options -v -g set-titles\"\n                                                 responseTarget:self\n                                               responseSelector:@selector(handleShowSetTitles:)\n                                                 responseObject:nil\n                                                          flags:0] ]];\n}\n\n- (void)loadKeyBindings {\n    [gateway_ sendCommand:@\"list-keys\" responseTarget:self responseSelector:@selector(handleListKeys:)];\n}\n\n// If there's an error in tmux.conf then tmux will put you in copy mode initially and that breaks\n// handling keyboard input. This is harmless in the normal case.\n// https://github.com/tmux/tmux/issues/3193\n- (void)exitCopyMode {\n    [gateway_ sendCommand:@\"copy-mode -q\"\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n// This is a little brittle because it depends on parsing bind-keys commands\n// which could change in the future. It'd be nice for list-keys to have\n// structured output.\n- (void)handleListKeys:(NSString *)response {\n    NSArray<NSString *> *lines = [response componentsSeparatedByString:@\"\\n\"];\n    NSArray<NSDictionary *> *dicts = [lines mapWithBlock:^id (NSString * _Nonnull line) {\n        NSArray<NSString *> *args = [line componentsSeparatedByRegex:@\"  *\"];\n        NSInteger skip = 0;\n        NSString *key = nil;\n        NSString *command = nil;\n        NSString *flag = nil;\n        NSMutableDictionary<NSString *, id> *flags = [NSMutableDictionary dictionary];\n        for (NSInteger i = 1; i < args.count; i++) {\n            if (skip > 0) {\n                NSArray<NSString *> *flagArgs = flags[flag];\n                flags[flag] = [flagArgs arrayByAddingObject:args[i]];\n                skip -= 1;\n                continue;\n            }\n            flag = nil;\n            if ([args[i] hasPrefix:@\"-\"] && args[i].length > 1) {\n                flag = [args[i] substringFromIndex:1];\n                if ([args[i] isEqualToString:@\"-N\"]) {\n                    skip = 1;\n                } else if ([args[i] isEqualToString:@\"-T\"]) {\n                    skip = 1;\n                } else {\n                    skip = 0;\n                }\n                if (skip == 0) {\n                    flags[flag] = [NSNull null];\n                } else {\n                    flags[flag] = @[];\n                }\n                // Skip flag and any arguments.\n                continue;\n            }\n            if (key == nil) {\n                key = args[i];\n                continue;\n            }\n            command = [[args subarrayFromIndex:i] componentsJoinedByString:@\" \"];\n            break;\n        }\n        if (!key || !command || !flags) {\n            DLog(@\"Bad line: %@\", line);\n            return nil;\n        }\n        return @{ @\"key\": key,\n                  @\"command\": command,\n                  @\"flags\": flags };\n    }];\n    NSArray<NSString *> *forbiddenCommands = @[\n        @\"bind-key\",\n        @\"choose-buffer\",\n        @\"choose-client\",\n        @\"choose-tree\",\n        @\"clear-history\",\n        @\"clock-mode\",\n        @\"command-prompt\",\n        @\"confirm-before\",\n        @\"copy-mode\",\n        @\"customize-mode\",\n        @\"display-menu\",\n        @\"display-message\",\n        @\"display-panes\",\n        @\"display-popup\",\n        @\"find-window\",\n        @\"list-buffers\",\n        @\"list-clients\",\n        @\"list-commands\",\n        @\"list-keys\",\n        @\"list-panes\",\n        @\"list-sessions\",\n        @\"list-windows\",\n        @\"show-buffer\",\n        @\"show-messages\",\n        @\"unbind-key\",\n    ];\n    dicts = [dicts filteredArrayUsingBlock:^BOOL(NSDictionary *dict) {\n        NSString *command = [[dict[@\"command\"] componentsSeparatedByString:@\" \"] firstObject];\n        return [dict[@\"flags\"][@\"T\"] isEqual:@[@\"prefix\"]] && ![forbiddenCommands containsObject:command];\n    }];\n    NSMutableDictionary *fakeProfile = [@{ KEY_KEYBOARD_MAP: _sharedKeyMappingOverrides } mutableCopy];\n\n    for (NSDictionary *dict in dicts) {\n        iTermKeystroke *keystroke = [iTermKeystroke withTmuxKey:dict[@\"key\"]];\n        if (!keystroke) {\n            DLog(@\"Couldn't make keystroke for %@\", dict);\n            continue;\n        }\n\n        iTermKeyBindingAction *action = [iTermKeyBindingAction withAction:KEY_ACTION_SEND_TMUX_COMMAND\n                                                                parameter:dict[@\"command\"]\n                                                                 escaping:iTermSendTextEscapingNone\n                                                                applyMode:iTermActionApplyModeCurrentSession];\n        NSString *dictKey = [keystroke keyInBindingDictionary:fakeProfile[KEY_KEYBOARD_MAP]];\n        NSInteger index = NSNotFound;\n        if (dictKey) {\n            index = [[iTermKeyMappings sortedKeystrokesForProfile:fakeProfile] indexOfObject:keystroke];\n        }\n        [iTermKeyMappings setMappingAtIndex:index\n                               forKeystroke:keystroke\n                                     action:action\n                                  createNew:index == NSNotFound\n                                  inProfile:fakeProfile];\n    }\n\n    _sharedKeyMappingOverrides = fakeProfile[KEY_KEYBOARD_MAP];\n}\n\n- (void)handleShowSetTitles:(NSString *)result {\n    _shouldSetTitles = [result isEqualToString:@\"on\"];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerDidFetchSetTitlesStringOption\n                                                        object:self];\n}\n\n- (void)guessVersion {\n    // Run commands that will fail in successively older versions.\n    // show-window-options pane-border-format will succeed in 2.3 and later (presumably. 2.3 isn't out yet)\n    // the socket_path format was added in 2.2.\n    // the session_activity format was added in 2.1\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:@\"display-message -p \\\"#{version}\\\"\"\n                                           responseTarget:self\n                                         responseSelector:@selector(handleDisplayMessageVersion:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n\n                           [gateway_ dictionaryForCommand:@\"show-window-options pane-border-format\"\n                                           responseTarget:self\n                                         responseSelector:@selector(guessVersion23Response:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:@\"list-windows -F \\\"#{socket_path}\\\"\"\n                                           responseTarget:self\n                                         responseSelector:@selector(guessVersion22Response:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:@\"list-windows -F \\\"#{pid}\\\"\"\n                                           responseTarget:self\n                                         responseSelector:@selector(guessVersion21Response:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:@\"show-options -g message-style\"  // message-style added in 1.9\n                                           responseTarget:self\n                                         responseSelector:@selector(guessVersion18Response:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors]\n                           ];\n    for (NSDictionary *command in commands) {\n        [gateway_ sendCommandList:@[ command ]];\n    }\n}\n\n- (void)decreaseMaximumServerVersionTo:(NSString *)string {\n    NSDecimalNumber *number = [NSDecimalNumber decimalNumberWithString:string];\n    if (!gateway_.maximumServerVersion ||\n        [gateway_.maximumServerVersion compare:number] == NSOrderedDescending) {\n        gateway_.maximumServerVersion = number;\n        DLog(@\"Decreasing maximum server version to %@\", number);\n    }\n}\n\n- (void)increaseMinimumServerVersionTo:(NSString *)string {\n    NSDecimalNumber *number = [NSDecimalNumber decimalNumberWithString:string];\n    if (!gateway_.minimumServerVersion ||\n        [gateway_.minimumServerVersion compare:number] == NSOrderedAscending) {\n        gateway_.minimumServerVersion = number;\n        DLog(@\"Increasing minimum server version to %@\", number);\n    }\n}\n\n- (void)checkForUTF8Response:(NSString *)response {\n    if ([response containsString:@\"_\"]) {\n        [gateway_ abortWithErrorMessage:@\"tmux is not in UTF-8 mode. Please pass the -u command line argument to tmux or change your LANG environment variable to end with \u201c.UTF-8\u201d.\"\n                                  title:@\"UTF-8 Mode Not Detected\"];\n    }\n}\n\n- (void)handleDisplayMessageVersion:(NSString *)response {\n    DLog(@\"handleDisplayMessageVersion: %@\", response);\n    if ([response isEqualToString:@\"openbsd-7.1\"]) {\n        [self handleDisplayMessageVersion:@\"3.4\"];\n        return;\n    }\n    if ([response isEqualToString:@\"openbsd-6.8\"]) {\n        [self handleDisplayMessageVersion:@\"3.2\"];\n        return;\n    }\n    if ([response isEqualToString:@\"openbsd-6.7\"]) {\n        [self handleDisplayMessageVersion:@\"3.0\"];\n        return;\n    }\n    NSString *openbsdPrefix = @\"openbsd-\";\n    if ([response hasPrefix:openbsdPrefix]) {\n        NSString *suffix = [response substringFromIndex:openbsdPrefix.length];\n        NSDecimalNumber *number = [NSDecimalNumber decimalNumberWithString:suffix];\n        if (number) {\n            if ([number compare:[NSDecimalNumber decimalNumberWithString:@\"7.1\"]] != NSOrderedAscending) {\n                // version >= 7.1\n                [self handleDisplayMessageVersion:@\"3.4\"];\n            }\n            // version < 7.1\n            [self handleDisplayMessageVersion:@\"3.2\"];\n        } else {\n            // This should never happen (decimalNumberWithString returns a nonnil value)\n            [self handleDisplayMessageVersion:@\"3.2\"];\n        }\n        return;\n    }\n    // openbsd-6.6 and earlier are never reported; you just get an empty string.\n    if (response.length == 0) {\n        // The \"version\" format was first added in 2.4\n        [self decreaseMaximumServerVersionTo:@\"2.3\"];\n        return;\n    }\n\n    if ([response isEqualToString:@\"next-3.4\"]) {\n        // Work around a bug where tmux sends \\t instead of tab in list-windows response.\n        _shouldWorkAroundTabBug = YES;\n    }\n\n    NSString *nextPrefix = @\"next-\";\n    if ([response hasPrefix:nextPrefix]) {\n        [self handleDisplayMessageVersion:[response substringFromIndex:nextPrefix.length]];\n        return;\n    }\n    if ([response hasSuffix:@\"-rc\"]) {\n        response = [response stringByDroppingLastCharacters:3];\n    }\n    // In case we get back something that's not a number, or a totally unreasonable number, just ignore this.\n    DLog(@\"response=%@\", response);\n    NSDecimalNumber *number = [NSDecimalNumber decimalNumberWithString:response];\n    DLog(@\"number=%@\", number);\n    if (number.doubleValue != number.doubleValue ||\n        number.doubleValue < 2.4 || number.doubleValue > 10) {\n        DLog(@\"nan or out of bounds, do nothing.\");\n        return;\n    }\n    \n    // Sadly tmux version numbers look like 2.9 or 2.9a instead of a proper decimal number.\n    NSRange range = [response rangeOfCharacterFromSet:[NSCharacterSet lowercaseLetterCharacterSet]];\n    DLog(@\"Use range %@\", NSStringFromRange(range));\n    if (range.location == NSNotFound) {\n        DLog(@\"Normal case: increase min version to %@\", response);\n        [self increaseMinimumServerVersionTo:response];\n    } else {\n        // Convert 2.9a to 2.91\n        // According to this issue it should be safe to do this:\n        // https://github.com/tmux/tmux/issues/1712\n        unichar c = [response characterAtIndex:range.location];\n        NSInteger bug = c - 'a' + 1;\n        NSString *prefix = [response substringToIndex:range.location];\n        NSString *version = [NSString stringWithFormat:@\"%@%@\", prefix, @(bug)];\n        DLog(@\"dot-release. Increase min version to %@\", version);\n        [self increaseMinimumServerVersionTo:version];\n    }\n\n    if (gateway_.minimumServerVersion.doubleValue >= 2.9 && [iTermAdvancedSettingsModel tmuxVariableWindowSizesSupported]) {\n        _variableWindowSize = YES;\n    }\n\n    _versionDetected = YES;\n    [self didGuessVersion];\n}\n\n- (void)guessVersion23Response:(NSString *)response {\n    if (_versionDetected) {\n        DLog(@\"Version already detected.\");\n        return;\n    }\n    DLog(@\"guessVersion23Response\");\n    if (response == nil) {\n        [self decreaseMaximumServerVersionTo:@\"2.2\"];\n    } else {\n        [self increaseMinimumServerVersionTo:@\"2.3\"];\n    }\n}\n\n- (void)guessVersion22Response:(NSString *)response {\n    if (_versionDetected) {\n        DLog(@\"Version already detected.\");\n        return;\n    }\n    DLog(@\"guessVersion22Response\");\n    const NSInteger index = [response rangeOfCharacterFromSet:[[NSCharacterSet whitespaceAndNewlineCharacterSet] invertedSet]].location;\n    if (index == NSNotFound) {\n        [self decreaseMaximumServerVersionTo:@\"2.1\"];\n    } else {\n        [self increaseMinimumServerVersionTo:@\"2.2\"];\n    }\n}\n\n- (void)guessVersion21Response:(NSString *)response {\n    if (_versionDetected) {\n        DLog(@\"Version already detected.\");\n        return;\n    }\n    DLog(@\"guessVersion21Response\");\n    if (response.length == 0) {\n        [self decreaseMaximumServerVersionTo:@\"2.0\"];\n    } else {\n        [self increaseMinimumServerVersionTo:@\"2.1\"];\n    }\n}\n\n- (void)guessVersion18Response:(NSString *)response {\n    if (_versionDetected) {\n        DLog(@\"Version already detected.\");\n        return;\n    }\n    DLog(@\"guessVersion18Response\");\n    if (response != nil) {\n        [self increaseMinimumServerVersionTo:@\"1.9\"];\n    } else {\n        [self decreaseMaximumServerVersionTo:@\"1.8\"];\n    }\n\n    // This is the oldest version supported. By the time you get here you know the version.\n    [self didGuessVersion];\n}\n\n// Actions to perform after the version number is known.\n- (void)didGuessVersion {\n    DLog(@\"didGuessVersion\");\n    [self enablePauseModeIfPossible];\n    [self loadServerPID];\n    [self loadTitleFormat];\n    _versionKnown = YES;\n    if (_wantsOpenWindowsInitial) {\n        _wantsOpenWindowsInitial = NO;\n        [self openWindowsInitial];\n    }\n}\n\n- (BOOL)versionAtLeastDecimalNumberWithString:(NSString *)string {\n    return [gateway_ versionAtLeastDecimalNumberWithString:string];\n}\n\n- (BOOL)recyclingSupported {\n    return [self versionAtLeastDecimalNumberWithString:@\"1.9\"];\n}\n\n// Show an error and terminate the connection because tmux has an unsupported option turned on.\n- (void)optionValidationFailedForOption:(NSString *)option\n{\n    NSString *message = [NSString stringWithFormat:\n                            @\"The \\\"%@\\\" option is turned on in tmux. \"\n                             \"It is not compatible with the iTerm2-tmux integration. \"\n                             \"Please disable it and try again.\",\n                             option];\n    [gateway_ abortWithErrorMessage:message\n                              title:@\"Unsupported tmux option\"];\n}\n\n- (NSArray *)unsupportedGlobalOptions\n{\n    // The aggressive-resize option is not supported because it relies on the\n    // concept of a current window in tmux, which doesn't exist in the\n    // integration mode.\n    return [NSArray arrayWithObjects:kAggressiveResize, nil];\n}\n\n// Parse the output of show-window-options sent in -validateOptions, possibly\n// showing an error and terminating the connection.\n- (void)showWindowOptionsResponse:(NSString *)response {\n    NSArray *unsupportedGlobalOptions = [self unsupportedGlobalOptions];\n    NSArray *lines = [response componentsSeparatedByString:@\"\\n\"];\n    for (NSString *line in lines) {\n        NSArray *fields = [line componentsSeparatedByString:@\" \"];\n        if ([fields count] == 2) {\n            NSString *option = [fields objectAtIndex:0];\n            NSString *value = [fields objectAtIndex:1];\n\n            for (NSString *unsupportedOption in unsupportedGlobalOptions) {\n                if ([option isEqualToString:unsupportedOption]) {\n                    if ([value isEqualToString:@\"on\"]) {\n                        [self optionValidationFailedForOption:unsupportedOption];\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}\n\n- (BOOL)hasOutstandingWindowResize\n{\n    return numOutstandingWindowResizes_ > 0;\n}\n\n- (void)windowPane:(int)wp\n         resizedBy:(int)amount\n      horizontally:(BOOL)wasHorizontal\n{\n    NSString *dir;\n    if (wasHorizontal) {\n        if (amount > 0) {\n            dir = @\"R\";\n        } else {\n            dir = @\"L\";\n        }\n    } else {\n        if (amount > 0) {\n            dir = @\"D\";\n        } else {\n            dir = @\"U\";\n        }\n    }\n    NSString *resizeStr = [NSString stringWithFormat:@\"resize-pane -%@ -t \\\"%%%d\\\" %d\",\n                           dir, wp, abs(amount)];\n    NSString *listStr = [self commandToListWindows];\n    NSArray *commands = [NSArray arrayWithObjects:\n                         [gateway_ dictionaryForCommand:resizeStr\n                                         responseTarget:nil\n                                       responseSelector:nil\n                                         responseObject:nil\n                                                  flags:0],\n                         [gateway_ dictionaryForCommand:listStr\n                                         responseTarget:self\n                                       responseSelector:@selector(listWindowsResponse:)\n                                         responseObject:nil\n                                                  flags:0],\n                         nil];\n    ++numOutstandingWindowResizes_;\n    [gateway_ sendCommandList:commands];\n}\n\n// The splitVertically parameter uses the iTerm2 conventions.\n- (void)splitWindowPane:(int)wp\n             vertically:(BOOL)splitVertically\n                  scope:(iTermVariableScope *)scope\n       initialDirectory:(iTermInitialDirectory *)initialDirectory\n             completion:(void (^)(int wp))completion {\n    // No need for a callback. We should get a layout-changed message and act on it.\n    __weak __typeof(self) weakSelf = self;\n    [initialDirectory tmuxSplitWindowCommand:wp\n                                  vertically:splitVertically\n                          recyclingSupported:self.recyclingSupported\n                                       scope:scope\n                                  completion:\n     ^(NSString *command) {\n        __strong __typeof(self) strongSelf = weakSelf;\n        if (!strongSelf) {\n            return;\n        }\n        TmuxGateway *gateway = strongSelf->gateway_;\n        if (!completion) {\n            [gateway sendCommand:command responseTarget:nil responseSelector:nil];\n            return;\n        }\n\n        // Get the list of panes, then split, then get the list of panes again.\n        // This seems to be the only way to get the pane ID of the new pane.\n        NSString *listPanesCommand = [NSString stringWithFormat:@\"list-panes -t %%%d -F '#{pane_id}'\", wp];\n        NSMutableDictionary *state = [NSMutableDictionary dictionary];\n        state[iTermTmuxControllerSplitStateCompletion] = [completion copy];\n        NSDictionary *initialListPanes = [gateway dictionaryForCommand:listPanesCommand\n                                                        responseTarget:self\n                                                      responseSelector:@selector(recordPanes:state:)\n                                                        responseObject:state\n                                                                 flags:0];\n        NSDictionary *split = [gateway dictionaryForCommand:command\n                                             responseTarget:nil\n                                           responseSelector:nil\n                                             responseObject:nil\n                                                      flags:kTmuxGatewayCommandShouldTolerateErrors];\n        NSDictionary *followupListPanes = [gateway dictionaryForCommand:listPanesCommand\n                                                         responseTarget:self\n                                                       responseSelector:@selector(didSplit:state:)\n                                                         responseObject:state\n                                                                  flags:kTmuxGatewayCommandShouldTolerateErrors];\n        [gateway sendCommandList:@[ initialListPanes, split, followupListPanes ]];\n     }];\n}\n\n// Save pane list before splitting.\n- (void)recordPanes:(NSString *)list state:(NSMutableDictionary *)state {\n    state[iTermTmuxControllerSplitStateInitialPanes] = [NSSet setWithArray:[list componentsSeparatedByString:@\"\\n\"]];\n}\n\n// Compute new window pane after splitting and run callback if any.\n- (void)didSplit:(NSString *)list state:(NSMutableDictionary *)state {\n    NSSet<NSString *> *after = [NSSet setWithArray:[list componentsSeparatedByString:@\"\\n\"]];\n    NSSet<NSString *> *before = state[iTermTmuxControllerSplitStateInitialPanes] ?: [NSSet set];\n    NSMutableSet<NSString *> *additions = [after mutableCopy];\n    [additions minusSet:before];\n    void (^completion)(int) = state[iTermTmuxControllerSplitStateCompletion];\n    if (additions.count == 0) {\n        completion(-1);\n        return;\n    }\n    if (additions.count > 1) {\n        DLog(@\"Multiple additions found! Picking one at random.\");\n    }\n    NSString *string = [additions anyObject];\n    if (![string hasPrefix:@\"%\"]) {\n        completion(-1);\n        return;\n    }\n    string = [string substringFromIndex:1];\n    completion([string intValue]);\n}\n\n- (void)selectPane:(int)windowPane {\n    if (_suppressActivityChanges) {\n        DLog(@\"Not sending select-pane -t %%%d because activity changes are suppressed\", windowPane);\n        return;\n    }\n    NSDecimalNumber *version2_9 = [NSDecimalNumber decimalNumberWithString:@\"2.9\"];\n\n    if ([gateway_.minimumServerVersion isEqual:version2_9]) {\n        // I presume this will be fixed in whatever verson follows 2.9, so use an isEqual:. I need to remember to revisit this after the bug is fixed!\n        return;\n    }\n\n    NSString *command = [NSString stringWithFormat:@\"select-pane -t \\\"%%%d\\\"\", windowPane];\n    [gateway_ sendCommand:command\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)newWindowInSessionNumber:(NSNumber *)sessionNumber\n                           scope:(iTermVariableScope *)scope\n                initialDirectory:(iTermInitialDirectory *)initialDirectory {\n    __weak __typeof(self) weakSelf = self;\n    [initialDirectory tmuxNewWindowCommandInSessionNumber:sessionNumber\n                                       recyclingSupported:self.recyclingSupported\n                                                    scope:scope\n                                               completion:\n     ^(NSString *command) {\n        [weakSelf didCreateWindowWithCommand:command];\n    }];\n}\n\n- (void)didCreateWindowWithCommand:(NSString *)command {\n    NSMutableArray *commands = [NSMutableArray array];\n    if (_variableWindowSize) {\n        Profile *profile = self.sharedProfile;\n        NSSize size = NSMakeSize(MIN(iTermMaxInitialSessionSize,\n                                     [profile[KEY_COLUMNS] intValue] ?: 80),\n                                 MIN(iTermMaxInitialSessionSize,\n                                     [profile[KEY_ROWS] intValue] ?: 25));\n        ITBetaAssert((int)size.width > 0, @\"Invalid size\");\n        const int height = [self adjustHeightForStatusBar:size.height];\n        ITBetaAssert(height > 0, @\"Invalid size\");\n        [_windowSizes removeAllObjects];\n        NSString *setSizeCommand = [NSString stringWithFormat:@\"refresh-client -C %d,%d\",\n                                    (int)size.width, height];\n        [commands addObject:[gateway_ dictionaryForCommand:setSizeCommand\n                                            responseTarget:nil\n                                          responseSelector:nil\n                                            responseObject:nil\n                                                     flags:kTmuxGatewayCommandShouldTolerateErrors]];\n    }\n    [commands addObject:[gateway_ dictionaryForCommand:command\n                                        responseTarget:nil\n                                      responseSelector:nil\n                                        responseObject:nil\n                                                 flags:0]];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)newWindowWithAffinity:(NSString *)windowIdString\n                         size:(NSSize)size\n             initialDirectory:(iTermInitialDirectory *)initialDirectory\n                        index:(NSNumber *)index\n                        scope:(iTermVariableScope *)scope\n                   completion:(void (^)(int))completion {\n    _manualOpenRequested = (windowIdString != nil);\n    BOOL variableWindowSize = _variableWindowSize;\n    __weak __typeof(self) weakSelf = self;\n    [initialDirectory tmuxNewWindowCommandRecyclingSupported:self.recyclingSupported\n                                                       scope:scope\n                                                  completion:\n     ^(NSString *command) {\n        [weakSelf didCreateWindowWithAffinity:windowIdString\n                                      command:command\n                           variableWindowSize:variableWindowSize\n                                         size:size\n                                        index:index\n                                   completion:completion];\n    }];\n}\n\n- (void)didCreateWindowWithAffinity:(NSString *)windowIdString\n                            command:(NSString *)command\n                 variableWindowSize:(BOOL)variableWindowSize\n                               size:(NSSize)size\n                              index:(NSNumber *)index\n                         completion:(void (^)(int))completion {\n    if (detached_) {\n        return;\n    }\n    NSMutableArray *commands = [NSMutableArray array];\n    if (variableWindowSize) {\n        ITBetaAssert((int)size.width > 0, @\"Invalid size\");\n        const int height = [self adjustHeightForStatusBar:size.height];\n        ITBetaAssert(height > 0, @\"Invalid size\");\n        [_windowSizes removeAllObjects];\n        NSString *setSizeCommand = [NSString stringWithFormat:@\"refresh-client -C %d,%d\",\n                                    (int)size.width, height];\n        [commands addObject:[gateway_ dictionaryForCommand:setSizeCommand\n                                            responseTarget:nil\n                                          responseSelector:nil\n                                            responseObject:nil\n                                                     flags:kTmuxGatewayCommandShouldTolerateErrors]];\n    }\n    [commands addObject:[gateway_ dictionaryForCommand:command\n                                        responseTarget:self\n                                      responseSelector:@selector(newWindowWithAffinityCreated:affinityWindowAndCompletion:)\n                                        responseObject:[iTermTriple tripleWithObject:windowIdString\n                                                                           andObject:[completion copy]\n                                                                              object:index]\n                                                 flags:0]];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)movePane:(int)srcPane\n        intoPane:(int)destPane\n      isVertical:(BOOL)splitVertical\n          before:(BOOL)addBefore\n{\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"move-pane -s \\\"%%%d\\\" -t \\\"%%%d\\\" %@%@\",\n                           srcPane, destPane, splitVertical ? @\"-h\" : @\"-v\",\n                           addBefore ? @\" -b\" : @\"\"]\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)killWindowPane:(int)windowPane\n{\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"kill-pane -t \\\"%%%d\\\"\", windowPane]\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandOfferToDetachIfLaggyDuplicate | kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)unlinkWindowWithId:(int)windowId {\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"unlink-window -k -t @%d\", windowId]\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (NSString *)stringByEscapingBackslashesAndRemovingNewlines:(NSString *)name {\n    return [[name stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\" \"] stringByReplacingOccurrencesOfString:@\"\\\\\" withString:@\"\\\\\\\\\"];\n}\n\n- (void)setWindowTitleOverride:(NSString *)title\n                        window:(int)windowId {\n    [self renameWindowWithId:windowId inSessionNumber:nil toName:title];\n    [self savePerTabSettings];\n}\n\n- (void)renameWindowWithId:(int)windowId\n           inSessionNumber:(NSNumber *)sessionNumber\n                    toName:(NSString *)newName {\n    NSString *theCommand;\n    if (sessionNumber) {\n        theCommand = [NSString stringWithFormat:@\"rename-window -t \\\"$%d:@%d\\\" \\\"%@\\\"\",\n                      sessionNumber.intValue,\n                      windowId,\n                      [self stringByEscapingBackslashesAndRemovingNewlines:newName]];\n    } else {\n        theCommand = [NSString stringWithFormat:@\"rename-window -t @%d \\\"%@\\\"\", windowId, [self stringByEscapingBackslashesAndRemovingNewlines:newName]];\n    }\n    [gateway_ sendCommand:theCommand\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (BOOL)canRenamePane {\n    NSDecimalNumber *version2_6 = [NSDecimalNumber decimalNumberWithString:@\"2.6\"];\n    if ([gateway_.minimumServerVersion compare:version2_6] == NSOrderedAscending) {\n        return NO;\n    }\n    return YES;\n}\n\n- (void)renamePane:(int)windowPane toTitle:(NSString *)newTitle {\n    if (![self canRenamePane]) {\n        return;\n    }\n    NSString *theCommand = [NSString stringWithFormat:@\"select-pane -t %%%d -T \\\"%@\\\"\",\n                            windowPane, [self stringByEscapingBackslashesAndRemovingNewlines:newTitle]];\n    [gateway_ sendCommand:theCommand\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)setHotkeyForWindowPane:(int)windowPane to:(NSDictionary *)dict {\n    _hotkeys[@(windowPane)] = dict;\n\n    // First get a list of existing panes so we can avoid setting hotkeys for any nonexistent panes. Keeps the string from getting too long.\n    NSString *getPaneIDsCommand = [NSString stringWithFormat:@\"list-panes -s -t $%d -F \\\"#{pane_id}\\\"\", sessionId_];\n    [gateway_ sendCommand:getPaneIDsCommand\n           responseTarget:self\n         responseSelector:@selector(getPaneIDsResponseAndSetHotkeys:)\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)setTabColorString:(NSString *)colorString forWindowPane:(int)windowPane {\n    if ([_tabColors[@(windowPane)] isEqualToString:colorString]) {\n        return;\n    }\n    _tabColors[@(windowPane)] = colorString;\n\n    // First get a list of existing panes so we can avoid setting tab colors for any nonexistent panes. Keeps the string from getting too long.\n    NSString *getPaneIDsCommand = [NSString stringWithFormat:@\"list-panes -s -t $%d -F \\\"#{pane_id}\\\"\", sessionId_];\n    [gateway_ sendCommand:getPaneIDsCommand\n           responseTarget:self\n         responseSelector:@selector(getPaneIDsResponseAndSetTabColors:)\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n\n- (void)getPaneIDsResponseAndSetHotkeys:(NSString *)response {\n    [_paneIDs removeAllObjects];\n    for (NSString *pane in [response componentsSeparatedByString:@\"\\n\"]) {\n        if (pane.length) {\n            [_paneIDs addObject:@([[pane substringFromIndex:1] intValue])];\n        }\n    }\n    [self sendCommandToSetHotkeys];\n}\n\n- (void)getPaneIDsResponseAndSetTabColors:(NSString *)response {\n    [_paneIDs removeAllObjects];\n    for (NSString *pane in [response componentsSeparatedByString:@\"\\n\"]) {\n        if (pane.length) {\n            [_paneIDs addObject:@([[pane substringFromIndex:1] intValue])];\n        }\n    }\n    [self sendCommandToSetTabColors];\n}\n\n- (NSString *)encodedString:(NSString *)string prefix:(NSString *)prefix {\n    return [prefix stringByAppendingString:[[string dataUsingEncoding:NSUTF8StringEncoding] it_hexEncoded]];\n}\n\n- (NSString *)decodedString:(NSString *)string optionalPrefix:(NSString *)prefix {\n    if (![string hasPrefix:prefix]) {\n        return string;\n    }\n    return [[NSString alloc] initWithData:[[string substringFromIndex:prefix.length] dataFromHexValues]\n                                 encoding:NSUTF8StringEncoding];\n}\n\n- (void)sendCommandToSetHotkeys {\n    NSString *hexEncoded = [self encodedString:[self.hotkeysString stringByEscapingQuotes]\n                                        prefix:iTermTmuxControllerEncodingPrefixHotkeys];\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @hotkeys \\\"%@\\\"\",\n                         sessionId_, hexEncoded];\n    [gateway_ sendCommand:command\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)sendCommandToSetTabColors {\n\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @tab_colors \\\"%@\\\"\",\n                         sessionId_, [self encodedString:[self.tabColorsString stringByEscapingQuotes]\n                                                  prefix:iTermTmuxControllerEncodingPrefixTabColors]];\n    [gateway_ sendCommand:command\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (NSDictionary *)hotkeyForWindowPane:(int)windowPane {\n    return _hotkeys[@(windowPane)];\n}\n\n- (NSString *)tabColorStringForWindowPane:(int)windowPane {\n    return _tabColors[@(windowPane)];\n}\n\n- (void)killWindow:(int)window {\n    [[NSNotificationCenter defaultCenter] postNotificationName:iTermTmuxControllerWillKillWindow object:@(window)];\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"kill-window -t @%d\", window]\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandOfferToDetachIfLaggyDuplicate | kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (NSString *)breakPaneWindowPaneFlag {\n    NSDecimalNumber *version2_1 = [NSDecimalNumber decimalNumberWithString:@\"2.1\"];\n\n    if ([gateway_.maximumServerVersion compare:version2_1] == NSOrderedAscending) {\n        // 2.0 and earlier versions take -t for the window pane\n        return @\"-t\";\n    }\n    if ([gateway_.minimumServerVersion compare:version2_1] != NSOrderedAscending) {\n        // 2.1+ takes -s for the window pane\n        return @\"-s\";\n    }\n\n    // You shouldn't get here.\n    return @\"-s\";\n}\n\n- (void)breakOutWindowPane:(int)windowPane toPoint:(NSPoint)screenPoint\n{\n    [windowPositions_ setObject:[NSValue valueWithPoint:screenPoint]\n                         forKey:[NSNumber numberWithInt:windowPane]];\n    [self breakOutWindowPane:windowPane toTabAside:iTermTmuxControllerPhonyAffinity];\n}\n\n- (void)breakOutWindowPane:(int)windowPane toTabAside:(NSString *)sibling\n{\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"break-pane -P -F \\\"#{window_id}\\\" %@ \\\"%%%d\\\"\",\n                           [self breakPaneWindowPaneFlag], windowPane]\n           responseTarget:self\n         responseSelector:@selector(windowPaneBrokeOutWithWindowId:setAffinityTo:)\n           responseObject:sibling\n                    flags:0];\n}\n\n- (void)windowPaneBrokeOutWithWindowId:(NSString *)windowId\n                         setAffinityTo:(NSString *)windowGuid\n{\n    if ([windowId hasPrefix:@\"@\"]) {\n        windowId = [windowId substringFromIndex:1];\n        if ([windowGuid isEqualToString:iTermTmuxControllerPhonyAffinity]) {\n            _pendingWindows[@(windowId.intValue)] = [iTermTmuxPendingWindow trivialInstance];\n        } else {\n            [affinities_ setValue:windowGuid equalToValue:windowId];\n        }\n    }\n}\n\n- (BOOL)windowIsHidden:(int)windowId {\n    return [hiddenWindows_ containsObject:@(windowId)];\n}\n\n- (void)hideWindow:(int)windowId {\n    [self hideWindows:@[ @(windowId) ] andCloseTabs:YES];\n}\n\n- (NSString *)terminalGUIDForWindowID:(int)wid {\n    for (PseudoTerminal *term in [[iTermController sharedInstance] terminals]) {\n        for (PTYTab *tab in term.tabs) {\n            if (tab.isTmuxTab && tab.tmuxController == self && tab.tmuxWindow == wid) {\n                return term.terminalGuid;\n            }\n        }\n    }\n    return nil;\n}\n\n- (void)setWindowID:(int)wid buriedFromTerminalGUID:(NSString *)terminalGUID tabIndex:(int)tabIndex {\n    DLog(@\"set %@ = %@\", @(wid), terminalGUID);\n    NSMutableArray<iTermTuple<NSNumber *, NSNumber *> *> *wids = _buriedWindows[terminalGUID];\n    if (!wids) {\n        wids = [NSMutableArray array];\n        _buriedWindows[terminalGUID] = wids;\n    }\n    if (![wids objectPassingTest:^BOOL(iTermTuple<NSNumber *,NSNumber *> *element, NSUInteger index, BOOL *stop) {\n        return [element.firstObject isEqual:@(wid)];\n    }]) {\n        [wids addObject:[iTermTuple tupleWithObject:@(wid) andObject:@(tabIndex)]];\n    }\n}\n\n- (int)tabIndexOfWindowID:(int)wid {\n    for (PseudoTerminal *term in [[iTermController sharedInstance] terminals]) {\n        int i = 0;\n        for (PTYTab *tab in term.tabs) {\n            if (tab.isTmuxTab && tab.tmuxController == self && tab.tmuxWindow == wid) {\n                return i;\n            }\n            i += 1;\n        }\n    }\n    return -1;\n}\n\n- (void)hideWindows:(NSArray<NSNumber *> *)windowIDs andCloseTabs:(BOOL)closeTabs {\n    DLog(@\"hideWindow: Add these window IDs to hidden: %@\", windowIDs);\n    if (closeTabs) {\n        DLog(@\"burying window IDs %@\", [[windowIDs mapWithBlock:^id(NSNumber *anObject) {\n            return [anObject description];\n        }] componentsJoinedByString:@\", \"]);\n        // Update _buriedWindows\n        [windowIDs enumerateObjectsUsingBlock:^(NSNumber * _Nonnull wid, NSUInteger idx, BOOL * _Nonnull stop) {\n            NSString *terminalGUID = [self terminalGUIDForWindowID:wid.intValue];\n            if (!terminalGUID) {\n                return;\n            }\n            [self setWindowID:wid.intValue buriedFromTerminalGUID:terminalGUID tabIndex:[self tabIndexOfWindowID:wid.intValue]];\n        }];\n    }\n    [hiddenWindows_ addObjectsFromArray:windowIDs];\n    [self saveHiddenWindows];\n    if (closeTabs) {\n        for (NSNumber *widNumber in windowIDs) {\n            const int windowId = widNumber.intValue;\n            PTYTab *theTab = [self window:windowId];\n            if (theTab) {\n                [[theTab realParentWindow] closeTab:theTab soft:YES];\n            }\n        }\n    }\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerDidChangeHiddenWindows object:self];\n}\n\n- (void)openWindowWithId:(int)windowId\n              affinities:(NSArray *)affinities\n             intentional:(BOOL)intentional\n                 profile:(Profile *)profile {\n    if (intentional) {\n        DLog(@\"open intentional: Remove this window ID from hidden: %d\", windowId);\n        if (!_pendingWindows[@(windowId)]) {\n            // This indicates that the window's opening is originated by the app (it is not\n            // \"anonymous\"), as opposed to running `tmux new-window` at the command line.\n            DLog(@\"Force intentional\");\n            _pendingWindows[@(windowId)] = [iTermTmuxPendingWindow trivialInstance];\n        }\n        [hiddenWindows_ removeObject:[NSNumber numberWithInt:windowId]];\n        [self saveHiddenWindows];\n        [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerDidChangeHiddenWindows object:self];\n    }\n    __block NSNumber *tabIndex = _pendingWindows[@(windowId)].index;\n    [_buriedWindows enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull terminalGUID, NSMutableArray<iTermTuple<NSNumber *, NSNumber *> *> * _Nonnull tuples, BOOL * _Nonnull stop) {\n        const NSInteger i = [tuples indexOfObjectPassingTest:^BOOL(iTermTuple<NSNumber *,NSNumber *> * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n            return [obj.firstObject isEqual:@(windowId)];\n        }];\n        if (i != NSNotFound) {\n            tabIndex = tuples[i].secondObject;\n            [tuples removeObjectAtIndex:i];\n            DLog(@\"Add affinities for terminal %@: %@\", terminalGUID, [[tuples mapWithBlock:^id(iTermTuple *anObject) {\n                return anObject.description;\n            }] componentsJoinedByString:@\", \"]);\n            [affinities_ setValue:[@(windowId) stringValue] equalToValue:terminalGUID];\n        }\n    }];\n    // Get the window's basic info to prep the creation of a TmuxWindowOpener.\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"display -p -F %@ -t @%d\",\n                           [self listWindowsDetailedFormat], windowId]\n           responseTarget:self\n         responseSelector:@selector(listedWindowsToOpenOne:forWindowIdAndAffinities:)\n           responseObject:@[ @(windowId), affinities, profile, tabIndex ?: @-1 ]\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)openWindowWithId:(int)windowId\n             intentional:(BOOL)intentional\n                 profile:(Profile *)profile {\n    [self openWindowWithId:windowId\n                affinities:@[]\n               intentional:intentional\n                   profile:profile];\n}\n\n- (void)linkWindowId:(int)windowId\n     inSessionNumber:(int)sessionNumber\n     toSessionNumber:(int)targetSessionNumber {\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"link-window -s \\\"$%d:@%d\\\" -t \\\"$%d:+\\\"\",\n                           sessionNumber, windowId, targetSessionNumber]\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)moveWindowId:(int)windowId\n     inSessionNumber:(int)sessionNumber\n     toSessionNumber:(int)targetSessionNumber {\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"move-window -s \\\"$%d:@%d\\\" -t \\\"$%d:+\\\"\",\n                           sessionNumber, windowId, targetSessionNumber]\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n// Find a position for any key in panes and remove all entries with keys in panes.\n// windowPositions_ is used for setting the origin of a pane after moving it into a window, which\n// is rarely done. This falls back to the recorded window origin if one is present.\n- (NSValue *)positionForWindowWithPanes:(NSArray *)panes\n                               windowID:(int)windowID {\n    NSValue *pos = nil;\n    for (NSNumber *n in panes) {\n        pos = [windowPositions_ objectForKey:n];\n        if (pos) {\n            break;\n        }\n    }\n    [windowPositions_ removeObjectsForKeys:panes];\n    if ([iTermAdvancedSettingsModel disableTmuxWindowPositionRestoration]) {\n        return nil;\n    }\n    return pos ?: origins_[@(windowID)];\n}\n\n- (void)renameSessionNumber:(int)sessionNumber\n                         to:(NSString *)newName {\n    NSString *renameCommand = [NSString stringWithFormat:@\"rename-session -t \\\"$%d\\\" \\\"%@\\\"\",\n                               sessionNumber,\n                               [newName stringByEscapingQuotes]];\n    [gateway_ sendCommand:renameCommand responseTarget:nil responseSelector:nil];\n}\n\n- (void)killSessionNumber:(int)sessionNumber {\n    NSString *killCommand = [NSString stringWithFormat:@\"kill-session -t \\\"$%d\\\"\", sessionNumber];\n    [gateway_ sendCommand:killCommand\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandOfferToDetachIfLaggyDuplicate | kTmuxGatewayCommandShouldTolerateErrors];\n    [self listSessions];\n}\n\n- (void)addSessionWithName:(NSString *)sessionName\n{\n    NSString *attachCommand = [NSString stringWithFormat:@\"new-session -s \\\"%@\\\"\",\n                               [sessionName stringByEscapingQuotes]];\n    [gateway_ sendCommand:attachCommand\n           responseTarget:nil\n         responseSelector:nil];\n    [self listSessions];\n}\n\n- (void)attachToSessionWithNumber:(int)sessionNumber {\n    NSString *attachCommand = [NSString stringWithFormat:@\"attach-session -t \\\"$%d\\\"\", sessionNumber];\n    [gateway_ sendCommand:attachCommand\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)listWindowsInSessionNumber:(int)sessionNumber\n                            target:(id)target\n                          selector:(SEL)selector\n                            object:(id)object {\n    if (detached_ || !object) {\n        // This can happen if you're not attached to a session.\n        return;\n    }\n    NSString *listWindowsCommand = [NSString stringWithFormat:@\"list-windows -F %@ -t \\\"$%d\\\"\",\n                                    [self listWindowsDetailedFormat], sessionNumber];\n    NSArray *userInfo = @[listWindowsCommand,\n                          object,\n                          target,\n                          NSStringFromSelector(selector) ];\n    if ([_listWindowsQueue containsObject:userInfo]) {\n        // Already have this queued up.\n        return;\n    }\n    // Wait a few seconds. We always get a windows-close notification when the last window in\n    // a window closes. To avoid spamming the command line with list-windows, we wait a bit to see\n    // if there is an exit notification coming down the pipe.\n    const CGFloat kListWindowsDelay = 1.5;\n    [NSTimer scheduledTimerWithTimeInterval:kListWindowsDelay\n                                     target:self\n                                   selector:@selector(listWindowsTimerFired:)\n                                   userInfo:userInfo\n                                    repeats:NO];\n}\n\n- (void)listWindowsTimerFired:(NSTimer *)timer {\n    if (detached_) {\n        return;\n    }\n    NSArray *array = [timer userInfo];\n    NSString *command = array[0];\n    id object = array[1];\n    id target = array[2];\n    NSString *selector = array[3];\n\n    [_listWindowsQueue removeObject:timer.userInfo];\n\n    [gateway_ sendCommand:command\n           responseTarget:self\n         responseSelector:@selector(didListWindows:userData:)\n           responseObject:@[object, selector, target]\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];  // Tolerates errors because the session may have been detached by the time we get the notification or the timer fires.\n}\n\n- (void)saveHiddenWindows\n{\n    NSString *hidden = [[hiddenWindows_ allObjects] componentsJoinedByString:@\",\"];\n    DLog(@\"Save hidden windows: %@\", hidden);\n    NSString *command = [NSString stringWithFormat:\n                         @\"set -t $%d @hidden \\\"%@\\\"\",\n                         sessionId_,\n                         [self encodedString:hidden\n                                      prefix:iTermTmuxControllerEncodingPrefixHidden]];\n    [gateway_ sendCommand:command\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)saveWindowOrigins\n{\n    if (haveOutstandingSaveWindowOrigins_) {\n        windowOriginsDirty_ = YES;\n        return;\n    }\n    windowOriginsDirty_ = NO;\n    if (pendingWindowOpens_.count) {\n        return;\n    }\n    [self saveAffinities];  // Make sure the equivalence classes are up to date.\n    NSMutableArray *maps = [NSMutableArray array];\n    for (NSSet *c in [affinities_ classes]) {\n        // temp will hold an array of tmux window IDs as strings, excluding\n        // placeholders and pty guids.\n        NSMutableArray *temp = [NSMutableArray array];\n        PTYTab *tab = nil;\n        for (NSString *wid in c) {\n            if (![wid hasPrefix:@\"pty-\"] && ![wid hasSuffix:@\"_ph\"]) {\n                if (!tab) {\n                    tab = [self window:[wid intValue]];\n                }\n                [temp addObject:wid];\n            }\n        }\n        NSString *windowIds = [temp componentsJoinedByString:@\",\"];\n        if (tab) {\n            NSWindowController<iTermWindowController> * term = [tab realParentWindow];\n            NSPoint origin = [[term window] frame].origin;\n            [maps addObject:[NSString stringWithFormat:@\"%@:%d,%d\", windowIds,\n                (int)origin.x, (int)origin.y]];\n        }\n    }\n    NSString *enc = [maps componentsJoinedByString:@\" \"];\n    DLog(@\"Save window origins to %@ called from %@\", enc, [NSThread callStackSymbols]);\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @origins \\\"%@\\\"\",\n                         sessionId_,\n                         [self encodedString:[enc stringByEscapingQuotes]\n                                      prefix:iTermTmuxControllerEncodingPrefixOrigins]];\n    if (!lastOrigins_ || ![command isEqualToString:lastOrigins_]) {\n        lastOrigins_ = [command copy];\n        haveOutstandingSaveWindowOrigins_ = YES;\n        [gateway_ sendCommand:command\n               responseTarget:self\n             responseSelector:@selector(saveWindowOriginsResponse:)];\n    }\n    [self getOriginsResponse:[self encodedString:[enc stringByEscapingQuotes]\n                                          prefix:iTermTmuxControllerEncodingPrefixOrigins]];\n}\n\n- (void)saveWindowOriginsResponse:(NSString *)response\n{\n    haveOutstandingSaveWindowOrigins_ = NO;\n    if (windowOriginsDirty_) {\n        [self saveWindowOrigins];\n    }\n}\n\n- (NSString *)windowOptionsForTerminal:(PseudoTerminal *)term {\n    if (term.anyFullScreen) {\n        return [NSString stringWithFormat:@\"%@=%@\",\n                kTmuxWindowOpenerWindowOptionStyle, kTmuxWindowOpenerWindowOptionStyleValueFullScreen];\n    } else {\n        return @\"\";\n    }\n}\n\n- (void)saveAffinities {\n    if (pendingWindowOpens_.count) {\n        return;\n    }\n    [self savePerWindowSettings];\n    [self savePerTabSettings];\n    iTermController *cont = [iTermController sharedInstance];\n    NSArray *terminals = [cont terminals];\n    NSMutableArray *affinities = [NSMutableArray array];\n    for (PseudoTerminal *term in terminals) {\n        NSMutableArray *siblings = [NSMutableArray array];\n        for (PTYTab *aTab in [term tabs]) {\n            if ([aTab isTmuxTab] && [aTab tmuxController] == self) {\n                NSString *n = [NSString stringWithFormat:@\"%d\", (int) [aTab tmuxWindow]];\n                [siblings addObject:n];\n            }\n        }\n        for (iTermTuple<NSNumber *, NSNumber *> *tuple in _buriedWindows[term.terminalGuid]) {\n            DLog(@\"add %@ as affinity sibling of %@\", tuple, term.terminalGuid);\n            [siblings addObject:[tuple.firstObject stringValue]];\n        }\n        if ([term terminalGuid]) {\n            [siblings addObject:[term terminalGuid]];\n        }\n        if (siblings.count > 0) {\n            NSString *value = [NSString stringWithFormat:@\"%@;%@\",\n                               [siblings componentsJoinedByString:@\",\"],\n                               [self windowOptionsForTerminal:term]];\n            [affinities addObject:value];\n        }\n    }\n    // Update affinities if any have changed.\n    NSString *arg = [affinities componentsJoinedByString:@\" \"];\n    DLog(@\"Save affinities: %@\", arg);\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @affinities \\\"%@\\\"\",\n                         sessionId_, [self encodedString:[arg stringByEscapingQuotes]\n                                                  prefix:iTermTmuxControllerEncodingPrefixAffinities]];\n    if ([command isEqualToString:lastSaveAffinityCommand_]) {\n        return;\n    }\n    [self setAffinitiesFromString:arg];\n    lastSaveAffinityCommand_ = command;\n    [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n\n    [self saveBuriedIndexes];\n}\n\n- (void)saveBuriedIndexes {\n    NSString *arg = [[_buriedWindows.allKeys mapWithBlock:^id(NSString *terminalGUID) {\n        NSString *rhs = [[_buriedWindows[terminalGUID] mapWithBlock:^id(iTermTuple<NSNumber *,NSNumber *> *tuple) {\n            return [NSString stringWithFormat:@\"%@=%@\", tuple.firstObject, tuple.secondObject];\n        }] componentsJoinedByString:@\",\"];\n        return [NSString stringWithFormat:@\"%@:%@\", terminalGUID, rhs];\n    }] componentsJoinedByString:@\" \"];\n    DLog(@\"save buried indexes: %@\", arg);\n\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @buried_indexes \\\"%@\\\"\",\n                         sessionId_, [self encodedString:[arg stringByEscapingQuotes]\n                                                  prefix:iTermTmuxControllerEncodingPrefixBuriedIndexes]];\n    if ([command isEqualToString:_lastSaveBuriedIndexesCommand]) {\n        return;\n    }\n    _lastSaveBuriedIndexesCommand = command;\n    [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n}\n\n- (void)savePerTabSettings {\n    NSMutableArray<NSString *> *settings = [NSMutableArray array];\n    iTermController *cont = [iTermController sharedInstance];\n    NSArray *terminals = [cont terminals];\n    for (PseudoTerminal *term in terminals) {\n        for (PTYTab *tab in term.tabs) {\n            if (!tab.isTmuxTab) {\n                continue;\n            }\n            NSString *setting = [tab tmuxPerTabSetting];\n            if (setting) {\n                [settings addObject:[NSString stringWithFormat:@\"%d:%@\", tab.tmuxWindow, setting]];\n            }\n        }\n    }\n    NSString *arg = [settings componentsJoinedByString:@\";\"];\n    DLog(@\"Save per-tab settings: %@\", arg);\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @per_tab_settings \\\"%@\\\"\",\n                         sessionId_,\n                         [self encodedString:arg prefix:iTermTmuxControllerEncodingPrefixPerTabSettings]];\n    if ([command isEqualToString:_lastSavePerTabSettingsCommand]) {\n        return;\n    }\n    _lastSavePerTabSettingsCommand = command;\n    [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n}\n\n- (void)getPerTabSettingsResponse:(NSString *)result {\n    [self setPerTabSettingsFromString:[self decodedString:result optionalPrefix:iTermTmuxControllerEncodingPrefixPerTabSettings]];\n}\n\n- (void)savePerWindowSettings {\n    NSMutableArray<NSString *> *settings = [NSMutableArray array];\n    iTermController *cont = [iTermController sharedInstance];\n    NSArray *terminals = [cont terminals];\n    for (PseudoTerminal *term in terminals) {\n        NSString *setting = [term tmuxPerWindowSetting];\n        if (setting) {\n            [settings addObject:[NSString stringWithFormat:@\"%@:%@\", term.terminalGuid, setting]];\n        }\n    }\n    NSString *arg = [settings componentsJoinedByString:@\";\"];\n    DLog(@\"Save per-window settings: %@\", arg);\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @per_window_settings \\\"%@\\\"\",\n                         sessionId_,\n                         [self encodedString:arg prefix:iTermTmuxControllerEncodingPrefixPerWindowSettings]];\n    if ([command isEqualToString:_lastSavePerWindowSettingsCommand]) {\n        return;\n    }\n    _lastSavePerWindowSettingsCommand = command;\n    [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n}\n\n- (void)getPerWindowSettingsResponse:(NSString *)result {\n    [self setPerWindowSettingsFromString:[self decodedString:result optionalPrefix:iTermTmuxControllerEncodingPrefixPerWindowSettings]];\n}\n\n- (PseudoTerminal *)terminalWithGuid:(NSString *)guid\n{\n    for (PseudoTerminal *term in [[iTermController sharedInstance] terminals]) {\n        if ([[term terminalGuid] isEqualToString:guid]) {\n            return term;\n        }\n    }\n    return nil;\n}\n\n- (PseudoTerminal *)windowWithAffinityForWindowId:(int)wid {\n    for (NSString *n in [self savedAffinitiesForWindow:[NSString stringWithInt:wid]]) {\n        if ([n hasPrefix:@\"pty-\"]) {\n            PseudoTerminal *term = [self terminalWithGuid:n];\n            if (term) {\n                return term;\n            }\n        } else if ([n hasPrefix:@\"-\"]) {\n            // Attach to window without a tmux tab; the window number is\n            // -(n+1). It may not exist, which means to open a new window.\n            int value = -[n intValue];\n            value -= 1;  // Correct for -1 based index.\n            return [[iTermController sharedInstance] terminalWithNumber:value];\n        } else if (![n hasSuffix:@\"_ph\"]) {\n            PTYTab *tab = [self window:[n intValue]];\n            if (tab) {\n                return [[iTermController sharedInstance] terminalWithTab:tab];\n            }\n        }\n    }\n    return nil;\n}\n\n- (void)changeWindow:(int)window tabTo:(PTYTab *)tab {\n    _windowStates[@(window)].tab = tab;\n}\n\n- (void)listSessions\n{\n    [listSessionsTimer_ invalidate];\n    listSessionsTimer_ = nil;\n    NSString *listSessionsCommand = @\"list-sessions -F \\\"#{session_id} #{session_name}\\\"\";\n    [gateway_ sendCommand:listSessionsCommand\n           responseTarget:self\n         responseSelector:@selector(listSessionsResponse:)];\n}\n\n- (NSString *)listWindowsDetailedFormat {\n    NSArray<NSString *> *parts = @[\n        @\"#{session_name}\",\n        @\"#{window_id}\",\n        @\"#{window_name}\",\n        @\"#{window_width}\",\n        @\"#{window_height}\",\n        @\"#{window_layout}\",\n        @\"#{window_flags}\",\n        @\"#{?window_active,1,0}\"\n    ];\n    if ([self versionAtLeastDecimalNumberWithString:@\"2.2\"]) {\n        parts = [parts arrayByAddingObject:@\"#{window_visible_layout}\"];\n    }\n    return [NSString stringWithFormat:@\"\\\"%@\\\"\", [parts componentsJoinedByString:@\"\\t\"]];\n}\n\n- (NSString *)commandToListWindows {\n    if ([self versionAtLeastDecimalNumberWithString:@\"2.2\"]) {\n        return @\"list-windows -F \\\"#{window_id} #{window_layout} #{window_flags} #{window_visible_layout}\\\"\";\n    } else {\n        return @\"list-windows -F \\\"#{window_id} #{window_layout} #{window_flags}\\\"\";\n    }\n}\n\n- (NSString *)commandToListWindowsForSession:(int)session {\n    return [[self commandToListWindows] stringByAppendingFormat:@\" -t \\\"$%d\\\"\", sessionId_];\n}\n\n- (void)swapPane:(int)pane1 withPane:(int)pane2 {\n    NSString *swapPaneCommand = [NSString stringWithFormat:@\"swap-pane -s \\\"%%%d\\\" -t \\\"%%%d\\\"\",\n                                 pane1, pane2];\n\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:swapPaneCommand\n                                           responseTarget:nil\n                                         responseSelector:NULL\n                                           responseObject:nil\n                                                    flags:0],\n                           [gateway_ dictionaryForCommand:[self commandToListWindows]\n                                           responseTarget:self\n                                         responseSelector:@selector(parseListWindowsResponseAndUpdateLayouts:)\n                                           responseObject:nil\n                                                    flags:0] ];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)toggleZoomForPane:(int)pane {\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:[NSString stringWithFormat:@\"resize-pane -Z -t \\\"%%%d\\\"\", pane]\n                                           responseTarget:nil\n                                         responseSelector:NULL\n                                           responseObject:nil\n                                                    flags:0],\n                           [gateway_ dictionaryForCommand:[self commandToListWindows]\n                                           responseTarget:self\n                                         responseSelector:@selector(parseListWindowsResponseAndUpdateLayouts:)\n                                           responseObject:nil\n                                                    flags:0] ];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)setTmuxFontTable:(iTermFontTable *)fontTable\n                hSpacing:(CGFloat)hs\n                vSpacing:(CGFloat)vs\n                  window:(int)window {\n    NSDictionary *dict = iTermTmuxControllerMakeFontOverrides(fontTable, hs, vs);\n    if (_variableWindowSize) {\n        _windowStates[@(window)].fontOverrides = dict;\n        return;\n    }\n    _sharedFontOverrides = dict;\n}\n\n- (void)setLayoutInWindow:(int)window toLayout:(NSString *)layout {\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:[NSString stringWithFormat:@\"select-layout -t @%@ %@\",\n                                                           @(window), layout]\n                                           responseTarget:self\n                                         responseSelector:@selector(didSetLayout:)\n                                           responseObject:nil\n                                                    flags:0],\n                           [gateway_ dictionaryForCommand:[self commandToListWindowsForSession:sessionId_]\n                                           responseTarget:self\n                                         responseSelector:@selector(didListWindowsSubsequentToSettingLayout:)\n                                           responseObject:nil\n                                                    flags:0] ];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)setLayoutInWindowPane:(int)windowPane toLayoutNamed:(NSString *)name {\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:[NSString stringWithFormat:@\"select-layout -t %%%@ %@\", @(windowPane), name]\n                                           responseTarget:self\n                                         responseSelector:@selector(didSetLayout:)\n                                           responseObject:nil\n                                                    flags:0],\n                           [gateway_ dictionaryForCommand:[self commandToListWindowsForSession:sessionId_]\n                                           responseTarget:self\n                                         responseSelector:@selector(didListWindowsSubsequentToSettingLayout:)\n                                           responseObject:nil\n                                                    flags:0] ];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)didSetLayout:(NSString *)response {\n}\n\n- (void)didListWindowsSubsequentToSettingLayout:(NSString *)response {\n    [self parseListWindowsResponseAndUpdateLayouts:response];\n}\n\n- (NSArray<PTYSession<iTermTmuxControllerSession> *> *)clientSessions {\n    return windowPanes_.allValues;\n}\n\n- (NSArray<NSNumber *> *)windowPaneIDs {\n    return windowPanes_.allKeys;\n}\n\n- (void)activeWindowPaneDidChangeInWindow:(int)windowID toWindowPane:(int)paneID {\n    PTYSession *session = [self sessionForWindowPane:paneID];\n    if (session) {\n        [self suppressActivityChanges:^{\n            [session makeActive];\n        }];\n        return;\n    }\n    // This must be a newly created session.\n    _paneToActivateWhenCreated = paneID;\n}\n\n- (BOOL)shouldMakeWindowKeyOnActiveWindowChange {\n    PseudoTerminal *term = [[iTermController sharedInstance] currentTerminal];\n    if (!term) {\n        return NO;\n    }\n    if (!term.window.isVisible) {\n        return NO;\n    }\n    return term.currentSession.isTmuxClient && term.currentSession.tmuxController == self;\n}\n\n- (void)activeWindowDidChangeTo:(int)windowID {\n    [self suppressActivityChanges:^{\n        const BOOL shouldMakeKeyAndOrderFront = [self shouldMakeWindowKeyOnActiveWindowChange];\n        PTYTab *tab = [self window:windowID];\n        [tab makeActive];\n        if (shouldMakeKeyAndOrderFront) {\n            [tab.realParentWindow.window makeKeyAndOrderFront:nil];\n        }\n    }];\n}\n\n- (void)suppressActivityChanges:(void (^ NS_NOESCAPE)(void))block {\n    _suppressActivityChanges++;\n    block();\n    _suppressActivityChanges--;\n}\n\n#pragma mark - Private\n\n- (void)getOriginsResponse:(NSString *)encodedResult {\n    NSString *result = [self decodedString:encodedResult\n                            optionalPrefix:iTermTmuxControllerEncodingPrefixOrigins];\n    [origins_ removeAllObjects];\n    if ([result length] > 0) {\n        NSArray *windows = [result componentsSeparatedByString:@\" \"];\n        for (NSString *wstr in windows) {\n            NSArray *tuple = [wstr componentsSeparatedByString:@\":\"];\n            if (tuple.count != 2) {\n                continue;\n            }\n            NSString *windowsStr = [tuple objectAtIndex:0];\n            NSString *coords = [tuple objectAtIndex:1];\n            NSArray *windowIds = [windowsStr componentsSeparatedByString:@\",\"];\n            NSArray *xy = [coords componentsSeparatedByString:@\",\"];\n            if (xy.count != 2) {\n                continue;\n            }\n            NSPoint origin = NSMakePoint([[xy objectAtIndex:0] intValue],\n                                         [[xy objectAtIndex:1] intValue]);\n            for (NSString *wid in windowIds) {\n                [origins_ setObject:[NSValue valueWithPoint:origin]\n                             forKey:[NSNumber numberWithInt:[wid intValue]]];\n            }\n        }\n    }\n}\n\n- (NSString *)shortStringForHotkeyDictionary:(NSDictionary *)dict paneID:(int)wp {\n    return [NSString stringWithFormat:@\"%d=%@\", wp, [iTermShortcut shortStringForDictionary:dict]];\n}\n\n- (NSString *)hotkeysString {\n    NSMutableArray *parts = [NSMutableArray array];\n    [_hotkeys enumerateKeysAndObjectsUsingBlock:^(NSNumber *  _Nonnull key, NSDictionary *_Nonnull obj, BOOL * _Nonnull stop) {\n        if ([_paneIDs containsObject:key]) {\n            [parts addObject:[self shortStringForHotkeyDictionary:obj paneID:key.intValue]];\n        }\n    }];\n\n    return [parts componentsJoinedByString:@\" \"];\n}\n\n- (NSString *)tabColorsString {\n    NSMutableArray *parts = [NSMutableArray array];\n    [_tabColors enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSString * _Nonnull obj, BOOL * _Nonnull stop) {\n        if ([_paneIDs containsObject:key]) {\n            [parts addObject:[NSString stringWithFormat:@\"%@=%@\", key, obj]];\n        }\n    }];\n\n    return [parts componentsJoinedByString:@\" \"];\n}\n\n- (void)getHotkeysResponse:(NSString *)encodedResult {\n    NSString *result = [self decodedString:encodedResult optionalPrefix:iTermTmuxControllerEncodingPrefixHotkeys];\n    [_hotkeys removeAllObjects];\n    if (result.length > 0) {\n        [_hotkeys removeAllObjects];\n        NSArray *parts = [result componentsSeparatedByString:@\" \"];\n        for (NSString *part in parts) {\n            NSInteger equals = [part rangeOfString:@\"=\"].location;\n            if (equals != NSNotFound && equals + 1 < part.length) {\n                NSString *wp = [part substringToIndex:equals];\n                NSString *shortString = [part substringFromIndex:equals + 1];\n                NSDictionary *dict = [iTermShortcut dictionaryForShortString:shortString];\n                if (dict) {\n                    _hotkeys[@(wp.intValue)] = dict;\n                }\n            }\n        }\n    }\n}\n\n- (void)getTabColorsResponse:(NSString *)encodedResult {\n    NSString *result = [self decodedString:encodedResult\n                            optionalPrefix:iTermTmuxControllerEncodingPrefixTabColors];\n    [_tabColors removeAllObjects];\n    if (result.length > 0) {\n        [_tabColors removeAllObjects];\n        NSArray *parts = [result componentsSeparatedByString:@\" \"];\n        for (NSString *part in parts) {\n            NSInteger equals = [part rangeOfString:@\"=\"].location;\n            if (equals != NSNotFound && equals + 1 < part.length) {\n                NSString *wp = [part substringToIndex:equals];\n                NSString *colorString = [part substringFromIndex:equals + 1];\n                if (colorString && wp.length) {\n                    _tabColors[@(wp.intValue)] = colorString;\n                }\n            }\n        }\n    }\n}\n\n- (int)windowIdFromString:(NSString *)s\n{\n    if (s.length < 2 || [s characterAtIndex:0] != '@') {\n        return -1;\n    }\n    return [[s substringFromIndex:1] intValue];\n}\n\n- (void)didListWindows:(NSString *)response userData:(NSArray *)userData\n{\n    if (!response) {\n        // In case of error.\n        response = @\"\";\n    }\n    TSVDocument *doc = [response tsvDocumentWithFields:[self listWindowFields]\n                                      workAroundTabBug:_shouldWorkAroundTabBug];\n    id object = userData[0];\n    SEL selector = NSSelectorFromString(userData[1]);\n    id target = userData[2];\n    [target it_performNonObjectReturningSelector:selector withObject:doc withObject:object];\n}\n\n- (void)getHiddenWindowsResponse:(NSString *)encodedResponse {\n    NSString *response = [self decodedString:encodedResponse\n                              optionalPrefix:iTermTmuxControllerEncodingPrefixHidden];\n    [hiddenWindows_ removeAllObjects];\n    if ([response length] > 0) {\n        NSArray *windowIds = [response componentsSeparatedByString:@\",\"];\n        DLog(@\"getHiddenWindowsResponse: Add these window IDs to hidden: %@\", windowIds);\n        for (NSString *wid in windowIds) {\n            [hiddenWindows_ addObject:[NSNumber numberWithInt:[wid intValue]]];\n        }\n    }\n    DLog(@\"Got hidden windows from server. they are: %@\", hiddenWindows_);\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerDidChangeHiddenWindows object:self];\n}\n\n- (void)getAffinitiesResponse:(NSString *)result {\n    [self setAffinitiesFromString:[self decodedString:result optionalPrefix:iTermTmuxControllerEncodingPrefixAffinities]];\n}\n\n- (void)getBuriedIndexesResponse:(NSString *)result {\n    if (!result) {\n        return;\n    }\n    NSString *decoded = [self decodedString:result optionalPrefix:iTermTmuxControllerEncodingPrefixBuriedIndexes];\n    if (!decoded.length) {\n        return;\n    }\n    NSArray<NSString *> *parts = [decoded componentsSeparatedByString:@\" \"];\n    [_buriedWindows removeAllObjects];\n    // guid:wid=index,wid=index,wid=index guid:wid=index,...\n    [parts enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        NSArray<NSString *> *subparts = [obj componentsSeparatedByString:@\":\"];\n        if (subparts.count < 2) {\n            return;\n        }\n        NSString *terminalGUID = subparts[0];\n        NSString *encodedPairs = subparts[1];\n        NSArray<NSString *> *pairStrings = [encodedPairs componentsSeparatedByString:@\",\"];\n        NSArray<iTermTuple<NSNumber *, NSNumber *> *> *tuples = [pairStrings mapWithBlock:^id(NSString *string) {\n            iTermTuple<NSString *, NSString *> *sstuple = [string keyValuePair];\n            if (!sstuple) {\n                return nil;\n            }\n            if (!sstuple.firstObject.isNumeric || !sstuple.secondObject.isNumeric) {\n                return nil;\n            }\n            return [iTermTuple tupleWithObject:@([sstuple.firstObject intValue])\n                                     andObject:@([sstuple.secondObject intValue])];\n        }];\n        _buriedWindows[terminalGUID] = [tuples mutableCopy];\n    }];\n}\n\n- (NSArray *)componentsOfAffinities:(NSString *)affinities {\n    NSRange semicolonRange = [affinities rangeOfString:@\";\"];\n    if (semicolonRange.location != NSNotFound) {\n        NSString *siblings = [affinities substringToIndex:semicolonRange.location];\n        NSString *windowOptions = [affinities substringFromIndex:NSMaxRange(semicolonRange)];\n        return @[ siblings, windowOptions ];\n    } else {\n        return @[ affinities, @\"\" ];\n    }\n}\n\n// Takes key1=value1,key2=value2 and returns @{ key1: value1, key2: value2 }\n- (NSDictionary *)windowOptionsFromString:(NSString *)kvpString {\n    NSMutableDictionary *flags = [NSMutableDictionary dictionary];\n    NSArray *kvps = [kvpString componentsSeparatedByString:@\",\"];\n    for (NSString *flagString in kvps) {\n        NSRange equalsRange = [flagString rangeOfString:@\"=\"];\n        if (equalsRange.location != NSNotFound) {\n            NSString *key = [flagString substringToIndex:equalsRange.location];\n            NSString *value = [flagString substringFromIndex:NSMaxRange(equalsRange)];\n            flags[key] = value;\n        }\n    }\n    return flags;\n}\n\n- (void)setPerTabSettingsFromString:(NSString *)result {\n    DLog(@\"Set per-tab settings from string: %@\", result);\n\n    _perTabSettings = nil;\n    NSMutableDictionary<NSString *, NSString *> *settings = [NSMutableDictionary dictionary];\n    NSArray<NSString *> *parts = [result componentsSeparatedByString:@\";\"];\n    for (NSString *part in parts) {\n        iTermTuple<NSString *, NSString *> *kvp = [part it_stringBySplittingOnFirstSubstring:@\":\"];\n        if (!kvp) {\n            DLog(@\"Bad part %@\", part);\n            continue;\n        }\n        settings[kvp.firstObject] = kvp.secondObject;\n    }\n    _perTabSettings = [settings copy];\n}\n\n- (NSString *)perTabSettingsForTabWithWindowID:(int)wid {\n    NSString *widStr = [@(wid) stringValue];\n    return _perTabSettings[widStr];\n}\n\n- (void)setPerWindowSettingsFromString:(NSString *)result {\n    DLog(@\"Set per-window settings from string: %@\", result);\n\n    _perWindowSettings = nil;\n    NSMutableDictionary<NSString *, NSString *> *settings = [NSMutableDictionary dictionary];\n    NSArray<NSString *> *parts = [result componentsSeparatedByString:@\";\"];\n    for (NSString *part in parts) {\n        iTermTuple<NSString *, NSString *> *kvp = [part it_stringBySplittingOnFirstSubstring:@\":\"];\n        if (!kvp) {\n            DLog(@\"Bad part %@\", part);\n            continue;\n        }\n        settings[kvp.firstObject] = kvp.secondObject;\n    }\n    _perWindowSettings = [settings copy];\n}\n\n- (NSString *)perWindowSettingsForWindowWithGUID:(NSString *)terminalGUID {\n    return _perWindowSettings[terminalGUID];\n}\n\n- (void)setAffinitiesFromString:(NSString *)result {\n    // Replace the existing equivalence classes with those defined by the\n    // affinity response.\n    // For example \"1,2,3 4,5,6\" has two equivalence classes.\n    // 1=2=3 and 4=5=6.\n    DLog(@\"Set affinities from string: %@\", result);\n    NSArray *affinities = [result componentsSeparatedByString:@\" \"];\n    affinities_ = [[EquivalenceClassSet alloc] init];\n\n    if (![result length]) {\n        return;\n    }\n\n    for (NSString *theString in affinities) {\n        NSArray *components = [self componentsOfAffinities:theString];\n        NSString *affset = components[0];\n        NSString *windowOptionsString = components[1];\n\n        NSArray<NSString *> *siblings = [affset componentsSeparatedByString:@\",\"];\n        DLog(@\"Siblings are: %@\", [siblings componentsJoinedByString:@\" \"]);\n        NSString *exemplar = [siblings lastObject];\n        if (siblings.count == 1) {\n            // This is a wee hack. If a tmux Window is in a native window with one tab\n            // then create an equivalence class containing only (wid, wid+\"_ph\"). ph=placeholder\n            // The equivalence class's existence signals not to apply the default mode for\n            // unrecognized windows.\n            exemplar = [exemplar stringByAppendingString:@\"_ph\"];\n            DLog(@\"Use placeholder exemplar\");\n        } else {\n            DLog(@\"Use arbitrary sibling as exemplar\");\n        }\n        NSDictionary *flags = [self windowOptionsFromString:windowOptionsString];\n        for (NSString *widString in siblings) {\n            if (![widString isEqualToString:exemplar]) {\n                DLog(@\"Set wid %@ equal to examplar %@\", widString, exemplar);\n                [affinities_ setValue:widString\n                         equalToValue:exemplar];\n                _windowOpenerOptions[widString] = flags;\n            }\n            if (widString.isNumeric && [hiddenWindows_ containsObject:@(widString.intValue)]) {\n                NSString *terminalGUID = [[siblings filteredArrayUsingBlock:^BOOL(NSString *candidate) {\n                    return !candidate.isNumeric && ![candidate hasSuffix:@\"_ph\"];\n                }] firstObject];\n                if (terminalGUID) {\n                    [self setWindowID:widString.intValue buriedFromTerminalGUID:terminalGUID tabIndex:-1];\n                }\n            }\n        }\n    }\n}\n\n- (void)listSessionsResponse:(NSString *)result\n{\n    DLog(@\"%@ got list-session response:\\n%@\", self, result);\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerSessionsWillChange\n                                                        object:nil];\n    self.sessionObjects = [[result componentsSeparatedByRegex:@\"\\n\"] mapWithBlock:^iTermTmuxSessionObject *(NSString *line) {\n        const NSInteger space = [line rangeOfString:@\" \"].location;\n        if (space == NSNotFound) {\n            return nil;\n        }\n        NSString *sessionID = [line substringToIndex:space];\n        NSString *sessionName = [line substringFromIndex:space + 1];\n        if (![sessionID hasPrefix:@\"$\"]) {\n            return nil;\n        }\n        NSScanner *scanner = [NSScanner scannerWithString:[sessionID substringFromIndex:1]];\n        int sessionNumber = -1;\n        if (![scanner scanInt:&sessionNumber] || sessionNumber < 0) {\n            return nil;\n        }\n        iTermTmuxSessionObject *obj = [[iTermTmuxSessionObject alloc] init];\n        obj.name = sessionName;\n        obj.number = sessionNumber;\n        return obj;\n    }];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerSessionsDidChange\n                                                        object:self];\n}\n\n- (void)listedWindowsToOpenOne:(NSString *)response\n      forWindowIdAndAffinities:(NSArray *)values {\n    if (response == nil) {\n        DLog(@\"Listing windows failed. Maybe the window died before we could get to it?\");\n        return;\n    }\n    NSNumber *windowId = values[0];\n    NSSet *affinities = values[1];\n    Profile *profile = values[2];\n    NSNumber *tabIndex = values[3];\n    if (tabIndex.intValue < 0) {\n        tabIndex = nil;\n    }\n    TSVDocument *doc = [response tsvDocumentWithFields:[self listWindowFields]\n                                      workAroundTabBug:_shouldWorkAroundTabBug];\n    if (!doc) {\n        [gateway_ abortWithErrorMessage:[NSString stringWithFormat:@\"Bad response for list windows request: %@\",\n                                         response]];\n        return;\n    }\n    for (NSArray *record in doc.records) {\n        NSString *recordWindowId = [doc valueInRecord:record forField:@\"window_id\"];\n        if ([self windowIdFromString:recordWindowId] == [windowId intValue]) {\n            [self openWindowWithIndex:[self windowIdFromString:[doc valueInRecord:record forField:@\"window_id\"]]\n                                 name:[[doc valueInRecord:record forField:@\"window_name\"] it_unescapedTmuxWindowName]\n                                 size:NSMakeSize([[doc valueInRecord:record forField:@\"window_width\"] intValue],\n                                                 [[doc valueInRecord:record forField:@\"window_height\"] intValue])\n                               layout:[doc valueInRecord:record forField:@\"window_layout\"]\n                        visibleLayout:[doc valueInRecord:record forField:@\"window_visible_layout\"]\n                           affinities:affinities\n                          windowFlags:[doc valueInRecord:record forField:@\"window_flags\"]\n                              profile:profile\n                              initial:NO\n                             tabIndex:tabIndex];\n        }\n    }\n}\n\n// When an iTerm2 window is resized, a control -s client-size w,h\n// command is sent. It responds with new layouts for all the windows in the\n// client's session. Update the layouts for the affected tabs.\n- (void)listWindowsResponse:(NSString *)response\n{\n    --numOutstandingWindowResizes_;\n    if (numOutstandingWindowResizes_ > 0) {\n        return;\n    }\n\n    [self parseListWindowsResponseAndUpdateLayouts:response];\n}\n\n- (void)parseListWindowsResponseAndUpdateLayouts:(NSString *)response {\n    NSArray *layoutStrings = [response componentsSeparatedByString:@\"\\n\"];\n    BOOL windowMightNeedAdjustment = NO;\n    NSMutableArray<PTYTab *> *tabs = [NSMutableArray array];\n    DLog(@\"Begin handling list-windows response\\n%@\", response);\n    for (NSString *layoutString in layoutStrings) {\n        // Capture groups are:\n        // <entire match> <window number> [<layout> [<visible layout]]\n        NSArray *components = [layoutString captureComponentsMatchedByRegex:@\"^@([0-9]+) ([^ ]+)(?: ([^ ]+)(?: ([^ ]+))?)?\"];\n        if ([components count] < 3) {\n            DLog(@\"Bogus layout string: \\\"%@\\\"\", layoutString);\n        } else {\n            int window = [[components objectAtIndex:1] intValue];\n            NSString *layout = [components objectAtIndex:2];\n            NSString *visibleLayout = components.count > 4 ? components[4] : nil;\n            PTYTab *tab = [self window:window];\n            if (tab) {\n                [tabs addObject:tab];\n                NSNumber *zoomed = components.count > 3 ? @([components[3] containsString:@\"Z\"]) : nil;\n                const BOOL adjust =\n                [[gateway_ delegate] tmuxUpdateLayoutForWindow:window\n                                                        layout:layout\n                                                 visibleLayout:visibleLayout\n                                                        zoomed:zoomed\n                                                          only:NO];\n                if (adjust) {\n                    windowMightNeedAdjustment = YES;\n                }\n            }\n        }\n    }\n    DLog(@\"End handling list-windows response\");\n    if (windowMightNeedAdjustment) {\n        [self adjustWindowSizeIfNeededForTabs:tabs];\n    }\n}\n\n- (void)retainWindow:(int)window withTab:(PTYTab *)tab {\n    assert(tab);\n    NSNumber *k = [NSNumber numberWithInt:window];\n    iTermTmuxWindowState *state = _windowStates[k];\n    BOOL notify = NO;\n    if (state) {\n        state.refcount = state.refcount + 1;\n    } else {\n        state = [[iTermTmuxWindowState alloc] init];\n        state.tab = tab;\n        state.refcount = 1;\n        state.profile = tab.sessions.firstObject.profile;\n        _windowStates[k] = state;\n        notify = YES;\n    }\n    if (notify) {\n        [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerWindowDidOpen\n                                                            object:@[ k, self ]];\n    }\n}\n\n- (void)releaseWindow:(int)window {\n    NSNumber *k = [NSNumber numberWithInt:window];\n    iTermTmuxWindowState *state = _windowStates[k];\n    state.refcount = state.refcount - 1;\n    if (!state.refcount) {\n        [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerWindowDidClose\n                                                            object:@[ k, self ]];\n        [_windowStates removeObjectForKey:k];\n    }\n}\n\n// Called only for iTerm2-initiated new windows/tabs.\n- (void)newWindowWithAffinityCreated:(NSString *)responseStr\n         affinityWindowAndCompletion:(iTermTriple *)tuple {  // Value passed in to -newWindowWithAffinity:, may be nil\n    if ([responseStr hasPrefix:@\"@\"]) {\n        int intWindowId = [[responseStr substringFromIndex:1] intValue];\n        NSString  *windowId = [NSString stringWithInt:intWindowId];\n        void (^completion)(int) = tuple.secondObject;\n        _pendingWindows[@(intWindowId)] = [iTermTmuxPendingWindow withIndex:tuple.thirdObject\n                                                                 completion:completion];\n        NSString *affinityWindow = tuple.firstObject;\n        if (affinityWindow) {\n            [affinities_ setValue:windowId\n                     equalToValue:affinityWindow];\n        } else {\n            [affinities_ removeValue:windowId];\n        }\n    } else {\n        DLog(@\"Response to new-window doesn't look like a window id: \\\"%@\\\"\", responseStr);\n    }\n}\n\n- (void)closeAllPanes {\n    // Close all sessions. Iterate over a copy of windowPanes_ because the loop\n    // body modifies it by closing sessions.\n    for (NSString *key in [windowPanes_ copy]) {\n        PTYSession<iTermTmuxControllerSession> *session = [windowPanes_ objectForKey:key];\n        [session tmuxDidDisconnect];\n    }\n\n    // Clean up all state to avoid trying to reuse it.\n    [windowPanes_ removeAllObjects];\n}\n\n- (void)windowDidOpen:(TmuxWindowOpener *)windowOpener {\n    NSNumber *windowIndex = @(windowOpener.windowIndex);\n    DLog(@\"TmuxController windowDidOpen for index %@ with error count %@\", windowIndex, @(windowOpener.errorCount));\n    [pendingWindowOpens_ removeObject:windowIndex];\n    if (windowOpener.errorCount != 0) {\n        [affinities_ removeValue:[@(windowOpener.windowIndex) stringValue]];\n        [[iTermNotificationController sharedInstance] notify:@\"Error opening tmux tab\"\n                                             withDescription:@\"A tmux pane terminated immediately after creation\"];\n        return;\n    }\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerWindowDidOpen\n                                                        object:nil];\n    PTYTab *tab = [self window:[windowIndex intValue]];\n    NSWindowController<iTermWindowController> * term = [tab realParentWindow];\n    NSValue *p = [origins_ objectForKey:windowIndex];\n    if (term && ![term anyFullScreen] && term.tabs.count == 1) {\n        if (p) {\n            [[term window] setFrameOrigin:[p pointValue]];\n        } else if (!NSEqualRects(NSZeroRect, _initialWindowHint)) {\n            [[term window] setFrameOrigin:_initialWindowHint.origin];\n        }\n    }\n    _initialWindowHint = NSZeroRect;\n    [self saveAffinities];\n    if (pendingWindowOpens_.count == 0) {\n        [self sendInitialWindowsOpenedNotificationIfNeeded];\n    }\n}\n\n- (void)sendInitialWindowsOpenedNotificationIfNeeded {\n    if (!_haveOpenedInitialWindows) {\n        [gateway_.delegate tmuxDidOpenInitialWindows];\n        _haveOpenedInitialWindows = YES;\n    }\n}\n\n- (void)setPartialWindowIdOrder:(NSArray *)partialOrder {\n    [gateway_ sendCommand:@\"list-windows -F \\\"#{window_id}\\\"\"\n           responseTarget:self\n         responseSelector:@selector(responseForListWindows:toSetPartialOrder:)\n           responseObject:partialOrder\n                    flags:0];\n}\n\n- (void)responseForListWindows:(NSString *)response toSetPartialOrder:(NSArray *)partialOrder {\n    NSArray *ids = [response componentsSeparatedByString:@\"\\n\"];\n    NSMutableArray *currentOrder = [NSMutableArray array];\n    for (NSString *windowId in ids) {\n        if ([windowId hasPrefix:@\"@\"]) {\n            int i = [[windowId substringFromIndex:1] intValue];\n            NSNumber *n = @(i);\n            if ([partialOrder containsObject:n]) {\n                [currentOrder addObject:n];\n            }\n        }\n    }\n\n    NSMutableArray *desiredOrder = [NSMutableArray array];\n    for (NSNumber *n in partialOrder) {\n        if ([currentOrder containsObject:n]) {\n            [desiredOrder addObject:n];\n        }\n    }\n\n    // We have two lists, desiredOrder and currentOrder, that contain the same objects but\n    // in (possibly) a different order. For each out-of-place value, swap it with a later value,\n    // placing the later value in its correct location.\n    NSMutableArray *commands = [NSMutableArray array];\n    for (int i = 0; i < currentOrder.count; i++) {\n        if ([currentOrder[i] intValue] != [desiredOrder[i] intValue]) {\n            NSInteger swapIndex = [currentOrder indexOfObject:desiredOrder[i]];\n            assert(swapIndex != NSNotFound);\n\n            NSString *command = [NSString stringWithFormat:@\"swap-window -s @%@ -t @%@\",\n                                    currentOrder[i], currentOrder[swapIndex]];\n            NSDictionary *dict = [gateway_ dictionaryForCommand:command\n                                                 responseTarget:self\n                                               responseSelector:@selector(didSwapWindows:)\n                                                 responseObject:nil\n                                                          flags:0];\n            [commands addObject:dict];\n            NSNumber *temp = currentOrder[i];\n            currentOrder[i] = currentOrder[swapIndex];\n            currentOrder[swapIndex] = temp;\n        }\n    }\n\n    [gateway_ sendCommandList:commands];\n    if (_currentWindowID >= 0) {\n        [self setCurrentWindow:_currentWindowID];\n    }\n}\n\n- (void)didSwapWindows:(NSString *)response {\n}\n\n- (void)setCurrentWindow:(int)windowId {\n    _currentWindowID = windowId;\n    if (_suppressActivityChanges) {\n        DLog(@\"Not sending select-window -t %%%d because activity changes are suppressed\", windowId);\n        return;\n    }\n    NSString *command = [NSString stringWithFormat:@\"select-window -t @%d\", windowId];\n    [gateway_ sendCommand:command\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (NSString *)userVarsString:(int)paneID {\n    NSDictionary<NSString *, NSString *> *dict = _userVars[@(paneID)];\n    return [[dict.allKeys mapWithBlock:^id(NSString *key) {\n        NSString *value = dict[key];\n        NSInteger index = [value rangeOfString:@\"\\0\"].location;\n        if (index != NSNotFound) {\n            value = [value substringToIndex:index];\n        }\n        return [NSString stringWithFormat:@\"%@=%@\", key, value];\n    }] componentsJoinedByString:@\"\\0\"];\n}\n\n- (void)setEncodedUserVars:(NSString *)encodedUserVars forPane:(int)paneID {\n    NSString *decoded = [self decodedString:encodedUserVars\n                             optionalPrefix:iTermTmuxControllerEncodingPrefixUserVars] ?: @\"\";\n    NSArray<NSString *> *kvps = [decoded componentsSeparatedByString:@\"\\0\"];\n    NSMutableDictionary<NSString *, NSString *> *dict = [self mutableUserVarsForPane:paneID];\n    [dict removeAllObjects];\n    for (NSString *kvp in kvps) {\n        NSInteger index = [kvp rangeOfString:@\"=\"].location;\n        if (index == NSNotFound) {\n            continue;\n        }\n        NSString *key = [kvp substringToIndex:index];\n        NSString *value = [kvp substringFromIndex:index + 1];\n        dict[key] = value;\n    }\n}\n\n- (NSDictionary<NSString *, NSString *> *)userVarsForPane:(int)paneID {\n    return _userVars[@(paneID)] ?: @{};\n}\n\n- (NSMutableDictionary<NSString *, NSString *> *)mutableUserVarsForPane:(int)paneID {\n    NSMutableDictionary<NSString *, NSString *> *dict = _userVars[@(paneID)];\n    if (dict) {\n        return dict;\n    }\n    dict = [NSMutableDictionary dictionary];\n    _userVars[@(paneID)] = dict;\n    return dict;\n}\n\n- (void)setUserVariableWithKey:(NSString *)key\n                         value:(NSString *)value\n                          pane:(int)paneID {\n    if (![self versionAtLeastDecimalNumberWithString:@\"3.1\"]) {\n        return;\n    }\n    NSMutableDictionary<NSString *, NSString *> *dict = [self mutableUserVarsForPane:paneID];\n    if (!value) {\n        if (!dict[key]) {\n            return;\n        }\n        [dict removeObjectForKey:key];\n    } else {\n        if ([dict[key] isEqualToString:value]) {\n            return;\n        }\n        dict[key] = value;\n    }\n    NSString *command = [NSString stringWithFormat:@\"set -p -t %%%d @uservars \\\"%@\\\"\",\n                         paneID,\n                         [self encodedString:[self userVarsString:paneID]\n                                      prefix:iTermTmuxControllerEncodingPrefixUserVars]];\n    [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n}\n\n- (void)setCurrentLatency:(NSTimeInterval)latency forPane:(int)wp {\n    [_tmuxBufferMonitor setCurrentLatency:latency forPane:wp];\n}\n\n- (void)copyBufferToLocalPasteboard:(NSString *)bufferName {\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"show-buffer -b %@\", bufferName]\n           responseTarget:self\n         responseSelector:@selector(handleShowBuffer:)];\n}\n\n- (void)handleShowBuffer:(NSString *)content {\n    if ([content length]) {\n        NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];\n        [pasteboard clearContents];\n        [pasteboard declareTypes:@[ NSPasteboardTypeString ] owner:nil];\n        [pasteboard setString:content forType:NSPasteboardTypeString];\n    }\n}\n#pragma mark - iTermTmuxBufferSizeMonitorDelegate\n\n- (void)tmuxBufferSizeMonitor:(iTermTmuxBufferSizeMonitor *)sender\n                   updatePane:(int)wp\n                          ttl:(NSTimeInterval)ttl\n                      redzone:(BOOL)redzone {\n    PTYSession<iTermTmuxControllerSession> *session = [self sessionForWindowPane:wp];\n    if (!session) {\n        return;\n    }\n    [session tmuxControllerSessionSetTTL:ttl redzone:redzone];\n}\n\n#pragma mark - Notifications\n\n- (void)textViewWillChangeFont:(NSNotification *)notification {\n    if ([iTermPreferences boolForKey:kPreferenceKeyAdjustWindowForFontSizeChange]) {\n        return;\n    }\n    if (_savedFrames.count) {\n        return;\n    }\n    NSArray *terminals = [[iTermController sharedInstance] terminals];\n    for (PseudoTerminal *term in terminals) {\n        if ([self windowControllerHasTmuxTabOfMine:term]) {\n            _savedFrames[term.terminalGuid] = [NSValue valueWithRect:term.window.frame];\n        }\n    }\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self->_savedFrames removeAllObjects];\n    });\n}\n\n- (BOOL)windowControllerHasTmuxTabOfMine:(PseudoTerminal *)term {\n    return [term.tabs anyWithBlock:^BOOL(PTYTab *tab) {\n        return tab.isTmuxTab && tab.tmuxController == self;\n    }];\n}\n\n- (void)restoreWindowFrame:(PseudoTerminal *)term {\n    if ([iTermPreferences boolForKey:kPreferenceKeyAdjustWindowForFontSizeChange]) {\n        return;\n    }\n    NSRect savedFrame;\n    if ([self getSavedFrameForWindowController:term frame:&savedFrame]) {\n        [term.window setFrame:savedFrame display:YES];\n    }\n}\n\n- (BOOL)getSavedFrameForWindowController:(PseudoTerminal *)term frame:(NSRect *)framePtr {\n    NSValue *value = _savedFrames[term.terminalGuid];\n    if (!value) {\n        return NO;\n    }\n    *framePtr = value.rectValue;\n    return YES;\n}\n\n@end\n"], "fixing_code": ["#import \"PTYSession.h\"\n#import \"PTYSession+ARC.h\"\n#import \"PTYSession+Private.h\"\n\n#import \"CapturedOutput.h\"\n#import \"CaptureTrigger.h\"\n#import \"Coprocess.h\"\n#import \"CVector.h\"\n#import \"FakeWindow.h\"\n#import \"FileTransferManager.h\"\n#import \"FutureMethods.h\"\n#import \"ITAddressBookMgr.h\"\n#import \"iTerm2SharedARC-Swift.h\"\n#import \"iTerm.h\"\n#import \"iTermAPIHelper.h\"\n#import \"iTermActionsModel.h\"\n#import \"iTermAddTriggerViewController.h\"\n#import \"iTermAdvancedSettingsModel.h\"\n#import \"iTermAnnouncementViewController.h\"\n#import \"iTermApplication.h\"\n#import \"iTermApplicationDelegate.h\"\n#import \"iTermAutomaticProfileSwitcher.h\"\n#import \"iTermBackgroundCommandRunner.h\"\n#import \"iTermBackgroundDrawingHelper.h\"\n#import \"iTermBadgeLabel.h\"\n#import \"iTermBuriedSessions.h\"\n#import \"iTermBuiltInFunctions.h\"\n#import \"iTermCacheableImage.h\"\n#import \"iTermCapturedOutputMark.h\"\n#import \"iTermCarbonHotKeyController.h\"\n#import \"iTermCharacterSource.h\"\n#import \"iTermColorMap.h\"\n#import \"iTermColorPresets.h\"\n#import \"iTermColorSuggester.h\"\n#import \"iTermCommandRunnerPool.h\"\n#import \"iTermComposerManager.h\"\n#import \"iTermCommandHistoryCommandUseMO+Additions.h\"\n#import \"iTermController.h\"\n#import \"iTermCopyModeHandler.h\"\n#import \"iTermCopyModeState.h\"\n#import \"iTermDisclosableView.h\"\n#import \"iTermEchoProbe.h\"\n#import \"iTermExpect.h\"\n#import \"iTermExpressionEvaluator.h\"\n#import \"iTermExpressionParser.h\"\n#import \"iTermFindDriver.h\"\n#import \"iTermFindOnPageHelper.h\"\n#import \"iTermFindPasteboard.h\"\n#import \"iTermGCD.h\"\n#import \"iTermGraphicSource.h\"\n#import \"iTermIntervalTreeObserver.h\"\n#import \"iTermKeyMappings.h\"\n#import \"iTermKeystroke.h\"\n#import \"iTermModifyOtherKeysMapper1.h\"\n#import \"iTermModifyOtherKeysMapper.h\"\n#import \"iTermNaggingController.h\"\n#import \"iTermNotificationController.h\"\n#import \"iTermHapticActuator.h\"\n#import \"iTermHistogram.h\"\n#import \"iTermHotKeyController.h\"\n#import \"iTermInitialDirectory.h\"\n#import \"iTermKeyLabels.h\"\n#import \"iTermLoggingHelper.h\"\n#import \"iTermMalloc.h\"\n#import \"iTermMetalClipView.h\"\n#import \"iTermMultiServerJobManager.h\"\n#import \"iTermObject.h\"\n#import \"iTermOpenDirectory.h\"\n#import \"iTermPreferences.h\"\n#import \"iTermRateLimitedUpdate.h\"\n#import \"iTermScriptConsole.h\"\n#import \"iTermScriptHistory.h\"\n#import \"iTermSharedImageStore.h\"\n#import \"iTermSlownessDetector.h\"\n#import \"iTermSnippetsModel.h\"\n#import \"iTermStandardKeyMapper.h\"\n#import \"iTermStatusBarUnreadCountController.h\"\n#import \"iTermSoundPlayer.h\"\n#import \"iTermRawKeyMapper.h\"\n#import \"iTermTermkeyKeyMapper.h\"\n#import \"iTermMetaFrustrationDetector.h\"\n#import \"iTermMetalGlue.h\"\n#import \"iTermMetalDriver.h\"\n#import \"iTermMouseCursor.h\"\n#import \"iTermNotificationCenter.h\"\n#import \"iTermPasteHelper.h\"\n#import \"iTermPreferences.h\"\n#import \"iTermPrintGuard.h\"\n#import \"iTermProcessCache.h\"\n#import \"iTermProfilePreferences.h\"\n#import \"iTermPromptOnCloseReason.h\"\n#import \"iTermRecentDirectoryMO.h\"\n#import \"iTermRestorableSession.h\"\n#import \"iTermRule.h\"\n#import \"iTermSavePanel.h\"\n#import \"iTermScriptFunctionCall.h\"\n#import \"iTermSecureKeyboardEntryController.h\"\n#import \"iTermSelection.h\"\n#import \"iTermSemanticHistoryController.h\"\n#import \"iTermSessionFactory.h\"\n#import \"iTermSessionHotkeyController.h\"\n#import \"iTermSessionLauncher.h\"\n#import \"iTermSessionNameController.h\"\n#import \"iTermSessionTitleBuiltInFunction.h\"\n#import \"iTermSetFindStringNotification.h\"\n#import \"iTermShellHistoryController.h\"\n#import \"iTermShortcut.h\"\n#import \"iTermShortcutInputView.h\"\n#import \"iTermSlowOperationGateway.h\"\n#import \"iTermStatusBarLayout.h\"\n#import \"iTermStatusBarLayout+tmux.h\"\n#import \"iTermStatusBarViewController.h\"\n#import \"iTermSwiftyString.h\"\n#import \"iTermSwiftyStringGraph.h\"\n#import \"iTermSystemVersion.h\"\n#import \"iTermTextExtractor.h\"\n#import \"iTermTheme.h\"\n#import \"iTermThroughputEstimator.h\"\n#import \"iTermTmuxStatusBarMonitor.h\"\n#import \"iTermTmuxOptionMonitor.h\"\n#import \"iTermUpdateCadenceController.h\"\n#import \"iTermURLMark.h\"\n#import \"iTermURLStore.h\"\n#import \"iTermUserDefaultsObserver.h\"\n#import \"iTermVariableReference.h\"\n#import \"iTermVariableScope.h\"\n#import \"iTermVariableScope+Global.h\"\n#import \"iTermVariableScope+Session.h\"\n#import \"iTermWarning.h\"\n#import \"iTermWebSocketCookieJar.h\"\n#import \"iTermWorkingDirectoryPoller.h\"\n#import \"MovePaneController.h\"\n#import \"MovingAverage.h\"\n#import \"NSAlert+iTerm.h\"\n#import \"NSAppearance+iTerm.h\"\n#import \"NSArray+iTerm.h\"\n#import \"NSColor+iTerm.h\"\n#import \"NSData+iTerm.h\"\n#import \"NSDate+iTerm.h\"\n#import \"NSDictionary+Profile.h\"\n#import \"NSDictionary+iTerm.h\"\n#import \"NSEvent+iTerm.h\"\n#import \"NSFont+iTerm.h\"\n#import \"NSHost+iTerm.h\"\n#import \"NSImage+iTerm.h\"\n#import \"NSObject+iTerm.h\"\n#import \"NSPasteboard+iTerm.h\"\n#import \"NSScreen+iTerm.h\"\n#import \"NSStringITerm.h\"\n#import \"NSThread+iTerm.h\"\n#import \"NSURL+iTerm.h\"\n#import \"NSUserDefaults+iTerm.h\"\n#import \"NSView+iTerm.h\"\n#import \"NSView+RecursiveDescription.h\"\n#import \"NSWindow+PSM.h\"\n#import \"NSWorkspace+iTerm.h\"\n#import \"PasteContext.h\"\n#import \"PasteEvent.h\"\n#import \"PreferencePanel.h\"\n#import \"ProfilePreferencesViewController.h\"\n#import \"ProfilesColorsPreferencesViewController.h\"\n#import \"ProfilesGeneralPreferencesViewController.h\"\n#import \"PSMMinimalTabStyle.h\"\n#import \"PTYNoteViewController.h\"\n#import \"PTYTask.h\"\n#import \"PTYTask+ProcessInfo.h\"\n#import \"PTYTextView.h\"\n#import \"PTYTextView+ARC.h\"\n#import \"PTYWindow.h\"\n#import \"RegexKitLite.h\"\n#import \"SCPFile.h\"\n#import \"SCPPath.h\"\n#import \"SearchResult.h\"\n#import \"SessionView.h\"\n#import \"TaskNotifier.h\"\n#import \"TerminalFile.h\"\n#import \"TriggerController.h\"\n#import \"TmuxController.h\"\n#import \"TmuxControllerRegistry.h\"\n#import \"TmuxGateway.h\"\n#import \"TmuxLayoutParser.h\"\n#import \"TmuxStateParser.h\"\n#import \"TmuxWindowOpener.h\"\n#import \"Trigger.h\"\n#import \"VT100DCSParser.h\"\n#import \"VT100RemoteHost.h\"\n#import \"VT100Screen.h\"\n#import \"VT100ScreenConfiguration.h\"\n#import \"VT100ScreenMark.h\"\n#import \"VT100ScreenMutableState.h\"\n#import \"VT100ScreenMutableState+Resizing.h\"\n#import \"VT100Terminal.h\"\n#import \"VT100Token.h\"\n#import \"WindowArrangements.h\"\n#import \"WindowControllerInterface.h\"\n#import <apr-1/apr_base64.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#import <CoreFoundation/CoreFoundation.h>\n#import <FileProviderService/FileProviderService.h>\n\nstatic const NSInteger kMinimumUnicodeVersion = 8;\nstatic const NSInteger kMaximumUnicodeVersion = 9;\n\nstatic NSString *const PTYSessionDidRepairSavedArrangement = @\"PTYSessionDidRepairSavedArrangement\";\n\nNSString *const PTYSessionCreatedNotification = @\"PTYSessionCreatedNotification\";\nNSString *const PTYSessionTerminatedNotification = @\"PTYSessionTerminatedNotification\";\nNSString *const PTYSessionRevivedNotification = @\"PTYSessionRevivedNotification\";\nNSString *const iTermSessionWillTerminateNotification = @\"iTermSessionDidTerminate\";\nNSString *const PTYSessionDidResizeNotification = @\"PTYSessionDidResizeNotification\";\n\nNSString *const kPTYSessionTmuxFontDidChange = @\"kPTYSessionTmuxFontDidChange\";\nNSString *const kPTYSessionCapturedOutputDidChange = @\"kPTYSessionCapturedOutputDidChange\";\nstatic NSString *const kSuppressAnnoyingBellOffer = @\"NoSyncSuppressAnnyoingBellOffer\";\nstatic NSString *const kSilenceAnnoyingBellAutomatically = @\"NoSyncSilenceAnnoyingBellAutomatically\";\n\nstatic NSString *const kTurnOffMouseReportingOnHostChangeUserDefaultsKey = @\"NoSyncTurnOffMouseReportingOnHostChange\";\nstatic NSString *const kTurnOffFocusReportingOnHostChangeUserDefaultsKey = @\"NoSyncTurnOffFocusReportingOnHostChange\";\n\nstatic NSString *const kTurnOffMouseReportingOnHostChangeAnnouncementIdentifier = @\"TurnOffMouseReportingOnHostChange\";\nstatic NSString *const kTurnOffFocusReportingOnHostChangeAnnouncementIdentifier = @\"TurnOffFocusReportingOnHostChange\";\n\nstatic NSString *const kShellIntegrationOutOfDateAnnouncementIdentifier =\n    @\"kShellIntegrationOutOfDateAnnouncementIdentifier\";\n\nstatic NSString *TERM_ENVNAME = @\"TERM\";\nstatic NSString *COLORFGBG_ENVNAME = @\"COLORFGBG\";\nstatic NSString *PWD_ENVNAME = @\"PWD\";\nstatic NSString *PWD_ENVVALUE = @\"~\";\nstatic NSString *PATH_ENVNAME = @\"PATH\";\n\n// Constants for saved window arrangement keys.\nstatic NSString *const SESSION_ARRANGEMENT_COLUMNS = @\"Columns\";\nstatic NSString *const SESSION_ARRANGEMENT_ROWS = @\"Rows\";\nstatic NSString *const SESSION_ARRANGEMENT_BOOKMARK = @\"Bookmark\";\nstatic NSString *const __attribute__((unused)) SESSION_ARRANGEMENT_BOOKMARK_NAME_DEPRECATED = @\"Bookmark Name\";\nstatic NSString *const SESSION_ARRANGEMENT_WORKING_DIRECTORY = @\"Working Directory\";\nstatic NSString *const SESSION_ARRANGEMENT_CONTENTS = @\"Contents\";\n// Not static because the ARC category uses it.\nNSString *const SESSION_ARRANGEMENT_TMUX_PANE = @\"Tmux Pane\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_HISTORY = @\"Tmux History\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_ALT_HISTORY = @\"Tmux AltHistory\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_STATE = @\"Tmux State\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_TAB_COLOR = @\"Tmux Tab Color\";\nstatic NSString *const SESSION_ARRANGEMENT_IS_TMUX_GATEWAY = @\"Is Tmux Gateway\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_NAME = @\"Tmux Gateway Session Name\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_DCS_ID = @\"Tmux DCS ID\";\nstatic NSString *const SESSION_ARRANGEMENT_CONDUCTOR_DCS_ID = @\"Conductor DCS ID\";\nstatic NSString *const SESSION_ARRANGEMENT_CONDUCTOR_TREE = @\"Conductor Parser Tree\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_ID = @\"Tmux Gateway Session ID\";\nstatic NSString *const SESSION_ARRANGEMENT_TMUX_FOCUS_REPORTING = @\"Tmux Focus Reporting\";\nstatic NSString *const SESSION_ARRANGEMENT_NAME_CONTROLLER_STATE = @\"Name Controller State\";\nstatic NSString *const __attribute__((unused)) DEPRECATED_SESSION_ARRANGEMENT_DEFAULT_NAME_DEPRECATED = @\"Session Default Name\";  // manually set name\nstatic NSString *const __attribute__((unused)) DEPRECATED_SESSION_ARRANGEMENT_WINDOW_TITLE_DEPRECATED = @\"Session Window Title\";  // server-set window name\nstatic NSString *const __attribute__((unused)) DEPRECATED_SESSION_ARRANGEMENT_NAME_DEPRECATED = @\"Session Name\";  // server-set \"icon\" (tab) name\nstatic NSString *const SESSION_ARRANGEMENT_GUID = @\"Session GUID\";  // A truly unique ID.\nstatic NSString *const SESSION_ARRANGEMENT_LIVE_SESSION = @\"Live Session\";  // If zoomed, this gives the \"live\" session's arrangement.\nstatic NSString *const SESSION_ARRANGEMENT_SUBSTITUTIONS = @\"Substitutions\";  // Dictionary for $$VAR$$ substitutions\nstatic NSString *const SESSION_UNIQUE_ID = @\"Session Unique ID\";  // DEPRECATED. A string used for restoring soft-terminated sessions for arrangements that predate the introduction of the GUID.\nstatic NSString *const SESSION_ARRANGEMENT_SERVER_PID = @\"Server PID\";  // PID for server process for restoration. Only for monoserver.\n// Not static because the ARC category uses it.\nNSString *const SESSION_ARRANGEMENT_SERVER_DICT = @\"Server Dict\";  // NSDictionary. Describes server connection. Only for multiserver.\n// TODO: Make server report the TTY to us since orphans will end up with a nil tty.\nstatic NSString *const SESSION_ARRANGEMENT_TTY = @\"TTY\";  // TTY name. Used when using restoration to connect to a restored server.\nstatic NSString *const SESSION_ARRANGEMENT_VARIABLES = @\"Variables\";  // _variables\n// static NSString *const SESSION_ARRANGEMENT_COMMAND_RANGE_DEPRECATED = @\"Command Range\";  // VT100GridCoordRange\n// Deprecated in favor of SESSION_ARRANGEMENT_SHOULD_EXPECT_PROMPT_MARKS and SESSION_ARRANGEMENT_SHOULD_EXPECT_CURRENT_DIR_UPDATES\nstatic NSString *const SESSION_ARRANGEMENT_SHELL_INTEGRATION_EVER_USED_DEPRECATED = @\"Shell Integration Ever Used\";  // BOOL\n\n// This really belongs in VT100Screen but it's here for historical reasons.\nstatic NSString *const SESSION_ARRANGEMENT_SHOULD_EXPECT_PROMPT_MARKS = @\"Should Expect Prompt Marks\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_SHOULD_EXPECT_CURRENT_DIR_UPDATES = @\"Should Expect Current Dir Updates\";  // BOOL\n\nstatic NSString *const SESSION_ARRANGEMENT_WORKING_DIRECTORY_POLLER_DISABLED = @\"Working Directory Poller Disabled\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_ALERT_ON_NEXT_MARK = @\"Alert on Next Mark\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_COMMANDS = @\"Commands\";  // Array of strings\nstatic NSString *const SESSION_ARRANGEMENT_DIRECTORIES = @\"Directories\";  // Array of strings\nstatic NSString *const SESSION_ARRANGEMENT_HOSTS = @\"Hosts\";  // Array of VT100RemoteHost\nstatic NSString *const SESSION_ARRANGEMENT_CURSOR_GUIDE = @\"Cursor Guide\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_LAST_DIRECTORY = @\"Last Directory\";  // NSString\nstatic NSString *const SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY = @\"Last Local Directory\";  // NSString\nstatic NSString *const SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY_WAS_PUSHED = @\"Last Local Directory Was Pushed\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_LAST_DIRECTORY_IS_UNSUITABLE_FOR_OLD_PWD_DEPRECATED = @\"Last Directory Is Remote\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_SELECTION = @\"Selection\";  // Dictionary for iTermSelection.\nstatic NSString *const SESSION_ARRANGEMENT_APS = @\"Automatic Profile Switching\";  // Dictionary of APS state.\n\nstatic NSString *const SESSION_ARRANGEMENT_PROGRAM = @\"Program\";  // Dictionary. See kProgram constants below.\nstatic NSString *const SESSION_ARRANGEMENT_ENVIRONMENT = @\"Environment\";  // Dictionary of environment vars program was run in\nstatic NSString *const SESSION_ARRANGEMENT_KEYLABELS = @\"Key Labels\";  // Dictionary string -> string\nstatic NSString *const SESSION_ARRANGEMENT_KEYLABELS_STACK = @\"Key Labels Stack\";  // Array of encoded iTermKeyLables dicts\nstatic NSString *const SESSION_ARRANGEMENT_IS_UTF_8 = @\"Is UTF-8\";  // TTY is in utf-8 mode\nstatic NSString *const SESSION_ARRANGEMENT_HOTKEY = @\"Session Hotkey\";  // NSDictionary iTermShortcut dictionaryValue\nstatic NSString *const SESSION_ARRANGEMENT_FONT_OVERRIDES = @\"Font Overrides\";  // Not saved; just used internally when creating a new tmux session.\nstatic NSString *const SESSION_ARRANGEMENT_KEYBOARD_MAP_OVERRIDES = @\"Keyboard Map Overrides\";  // Not saved; just used internally when creating a new tmux session.\nstatic NSString *const SESSION_ARRANGEMENT_SHORT_LIVED_SINGLE_USE = @\"Short Lived Single Use\";  // BOOL\nstatic NSString *const SESSION_ARRANGEMENT_HOSTNAME_TO_SHELL = @\"Hostname to Shell\";  // NSString -> NSString (example: example.com -> fish)\nstatic NSString *const SESSION_ARRANGEMENT_CURSOR_TYPE_OVERRIDE = @\"Cursor Type Override\";  // NSNumber wrapping ITermCursorType\nstatic NSString *const SESSION_ARRANGEMENT_AUTOLOG_FILENAME = @\"AutoLog File Name\";  // NSString. New as of 12/4/19\nstatic NSString *const SESSION_ARRANGEMENT_REUSABLE_COOKIE = @\"Reusable Cookie\";  // NSString.\nstatic NSString *const SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS = @\"Overridden Fields\";  // NSArray<NSString *>\nstatic NSString *const SESSION_ARRANGEMENT_FILTER = @\"Filter\";  // NSString\nstatic NSString *const SESSION_ARRANGEMENT_SSH_STATE = @\"SSH State\";  // NSNumber\nstatic NSString *const SESSION_ARRANGEMENT_CONDUCTOR = @\"Conductor\";  // NSString (json)\nstatic NSString *const SESSION_ARRANGEMENT_PENDING_JUMPS = @\"Pending Jumps\";  // NSArray<NSString *>, optional.\n\n// Keys for dictionary in SESSION_ARRANGEMENT_PROGRAM\nstatic NSString *const kProgramType = @\"Type\";  // Value will be one of the kProgramTypeXxx constants.\nstatic NSString *const kProgramCommand = @\"Command\";  // For kProgramTypeCommand: value is command to run.\nstatic NSString *const kCustomShell = @\"Custom Shell\";\n\n// Values for kProgramType\nstatic NSString *const kProgramTypeShellLauncher = @\"Shell Launcher\";  // Use ShellLauncher --launch_shell\nstatic NSString *const kProgramTypeCommand = @\"Command\";  // Use command in kProgramCommand\nstatic NSString *const kProgramTypeCustomShell = @\"Custom Shell\";\n\nstatic NSString *kTmuxFontChanged = @\"kTmuxFontChanged\";\n\n// Value for SESSION_ARRANGEMENT_TMUX_TAB_COLOR that means \"don't use the\n// default color from the tmux profile; this tab should have no color.\"\nstatic NSString *const iTermTmuxTabColorNone = @\"none\";\n\nstatic NSString *PTYSessionAnnouncementIdentifierTmuxPaused = @\"tmuxPaused\";\n\n// Maps Session GUID to saved contents. Only live between window restoration\n// and the end of startup activities.\nstatic NSMutableDictionary *gRegisteredSessionContents;\n\n// Grace period to avoid failing to write anti-idle code when timer runs just before when the code\n// should be sent.\nstatic const NSTimeInterval kAntiIdleGracePeriod = 0.1;\n\n// Limit for number of entries in self.directories, self.commands, self.hosts.\n// Keeps saved state from exploding like in issue 5029.\nstatic const NSUInteger kMaxDirectories = 100;\nstatic const NSUInteger kMaxCommands = 100;\nstatic const NSUInteger kMaxHosts = 100;\nstatic const CGFloat PTYSessionMaximumMetalViewSize = 16384;\n\nstatic NSString *const kSuppressCaptureOutputRequiresShellIntegrationWarning =\n    @\"NoSyncSuppressCaptureOutputRequiresShellIntegrationWarning\";\nstatic NSString *const kSuppressCaptureOutputToolNotVisibleWarning =\n    @\"NoSyncSuppressCaptureOutputToolNotVisibleWarning\";\n\n// This one cannot be suppressed.\nstatic NSString *const kTwoCoprocessesCanNotRunAtOnceAnnouncementIdentifier =\n    @\"NoSyncTwoCoprocessesCanNotRunAtOnceAnnouncmentIdentifier\";\n\nstatic char iTermEffectiveAppearanceKey;\n\n@interface NSWindow (SessionPrivate)\n- (void)_moveToScreen:(NSScreen *)sender;\n@end\n\ntypedef NS_ENUM(NSUInteger, iTermSSHState) {\n    // Normal state.\n    iTermSSHStateNone,\n\n    // Waiting for conductor just after creating the session with ssh as the command.\n    iTermSSHStateProfile,\n};\n\n@implementation PTYSession {\n    NSString *_termVariable;\n\n    // Has the underlying connection been closed?\n    BOOL _exited;\n\n    // A view that wraps the textview. It is the scrollview's document. This exists to provide a\n    // top margin above the textview.\n    TextViewWrapper *_wrapper;\n\n    // Anti-idle timer that sends a character every so often to the host.\n    NSTimer *_antiIdleTimer;\n\n    // The bookmark the session was originally created with so those settings can be restored if\n    // needed.\n    Profile *_originalProfile;\n\n    // Time since reference date when last keypress was received.\n    NSTimeInterval _lastInput;\n\n    // Time since reference date when the tab label was last updated.\n    NSTimeInterval _lastUpdate;\n\n    // This is used for divorced sessions. It contains the keys in profile\n    // that have been customized. Changes in the original profile will be copied over\n    // to profile except for these keys.\n    NSMutableSet *_overriddenFields;\n\n    // A digital video recorder for this session that implements the instant replay feature. These\n    // are non-null while showing instant replay.\n    DVR *_dvr;\n    DVRDecoder *_dvrDecoder;\n\n    // Set only if this is not a live session (we are showing instant replay). Is a pointer to the\n    // hidden live session while looking at the past.\n    PTYSession *_liveSession;\n\n    // Is the update timer's callback currently running?\n    BOOL _timerRunning;\n\n    // Time session was created\n    NSDate *_creationDate;\n\n    // If not nil, we're aggregating text to append to a pasteboard. The pasteboard will be\n    // updated when this is set to nil.\n    NSString *_pasteboard;\n    NSMutableData *_pbtext;\n\n    // Does the terminal think this session is focused?\n    BOOL _focused;\n\n    FindContext *_tailFindContext;\n    NSTimer *_tailFindTimer;\n    // A one-shot tail find runs even though the find view is invisible. Once it's done searching,\n    // it doesn't restart itself until the user does cmd-g again. See issue 9964.\n    BOOL _performingOneShotTailFind;\n\n    TmuxGateway *_tmuxGateway;\n    BOOL _haveKickedOffTmux;\n    BOOL _tmuxSecureLogging;\n    // The tmux rename-window command is only sent when the name field resigns first responder.\n    // This tracks if a tmux client's name has changed but the tmux server has not been informed yet.\n    BOOL _tmuxTitleOutOfSync;\n    PTYSessionTmuxMode _tmuxMode;\n    BOOL _tmuxWindowClosingByClientRequest;\n    // This is the write end of a pipe for tmux clients. The read end is in TaskNotifier.\n    NSFileHandle *_tmuxClientWritePipe;\n    NSInteger _requestAttentionId;  // Last request-attention identifier\n\n    VT100GridAbsCoordRange _lastOrCurrentlyRunningCommandAbsRange;\n\n    NSTimeInterval _timeOfLastScheduling;\n\n    dispatch_semaphore_t _executionSemaphore;\n\n    // Previous updateDisplay timer's timeout period (not the actual duration,\n    // but the kXXXTimerIntervalSec value).\n    NSTimeInterval _lastTimeout;\n\n    // In order to correctly draw a tiled background image, we must first draw\n    // it into an image the size of the session view, and then blit from it\n    // onto the background of whichever view needs a background. This ensures\n    // the tessellation is consistent.\n    NSImage *_patternedImage;\n\n    // Mouse reporting state\n    VT100GridCoord _lastReportedCoord;\n    NSPoint _lastReportedPoint;\n\n    // Remembers if the mouse down was reported to decide if mouse up should also be reported.\n    BOOL _reportingLeftMouseDown;\n    BOOL _reportingMiddleMouseDown;\n    BOOL _reportingRightMouseDown;\n\n    // Did we get CurrentDir code?\n    BOOL _shouldExpectCurrentDirUpdates;\n\n    // Disable the working directory poller?\n    BOOL _workingDirectoryPollerDisabled;\n\n    // Has the user or an escape code change the cursor guide setting?\n    // If so, then the profile setting will be disregarded.\n    BOOL _cursorGuideSettingHasChanged;\n\n    // Maps announcement identifiers to view controllers.\n    NSMutableDictionary *_announcements;\n\n    // Moving average of time between bell rings\n    MovingAverage *_bellRate;\n    NSTimeInterval _lastBell;\n    NSTimeInterval _ignoreBellUntil;\n    NSTimeInterval _annoyingBellOfferDeclinedAt;\n    BOOL _suppressAllOutput;\n\n    // Session should auto-restart after the pipe breaks.\n    BOOL _shouldRestart;\n\n    // Synthetic sessions are used for \"zoom in\" and DVR, and their closing cannot be undone.\n    BOOL _synthetic;\n\n    // Cached advanced setting\n    NSTimeInterval _idleTime;\n\n    // Current unicode version.\n    NSInteger _unicodeVersion;\n\n    // Touch bar labels for function keys.\n    NSMutableDictionary<NSString *, NSString *> *_keyLabels;\n    NSMutableArray<iTermKeyLabels *> *_keyLabelsStack;\n\n    // The containing window is in the midst of a live resize. The update timer\n    // runs in the common modes runloop in this case. That's not acceptable\n    // for normal use for reasons that Apple leaves up to your imagination (it\n    // doesn't fire while you hold down a key, for example), but it does fire\n    // during live resize (unlike the default runloops).\n    BOOL _inLiveResize;\n\n    id<VT100RemoteHostReading> _currentHost;\n\n    NSMutableDictionary<id, ITMNotificationRequest *> *_keystrokeSubscriptions;\n    NSMutableDictionary<id, ITMNotificationRequest *> *_keyboardFilterSubscriptions;\n    NSMutableDictionary<id, ITMNotificationRequest *> *_updateSubscriptions;\n    NSMutableDictionary<id, ITMNotificationRequest *> *_promptSubscriptions;\n    NSMutableDictionary<id, ITMNotificationRequest *> *_customEscapeSequenceNotifications;\n\n    // Used by auto-hide. We can't auto hide the tmux gateway session until at least one window has been opened.\n    BOOL _hideAfterTmuxWindowOpens;\n\n    BOOL _useAdaptiveFrameRate;\n    NSInteger _adaptiveFrameRateThroughputThreshold;\n\n    uint32_t _autoLogId;\n\n    iTermSessionModeHandler *_modeHandler;\n\n    // Absolute line number where touchbar status changed.\n    long long _statusChangedAbsLine;\n\n    iTermUpdateCadenceController *_cadenceController;\n\n    iTermMetalGlue *_metalGlue NS_AVAILABLE_MAC(10_11);\n\n    int _updateCount;\n    BOOL _metalFrameChangePending;\n    int _nextMetalDisabledToken;\n    NSMutableSet *_metalDisabledTokens;\n    BOOL _metalDeviceChanging;\n\n    iTermVariables *_userVariables;\n    iTermSwiftyString *_badgeSwiftyString;\n    iTermSwiftyString *_autoNameSwiftyString;\n    iTermSwiftyString *_subtitleSwiftyString;\n\n    iTermBackgroundDrawingHelper *_backgroundDrawingHelper;\n    iTermMetaFrustrationDetector *_metaFrustrationDetector;\n\n    iTermTmuxStatusBarMonitor *_tmuxStatusBarMonitor;\n    iTermWorkingDirectoryPoller *_pwdPoller;\n    iTermTmuxOptionMonitor *_tmuxTitleMonitor;\n    iTermTmuxOptionMonitor *_tmuxForegroundJobMonitor;\n    iTermTmuxOptionMonitor *_paneIndexMonitor;\n\n    iTermGraphicSource *_graphicSource;\n    iTermVariableReference *_jobPidRef;\n    iTermCacheableImage *_customIcon;\n    CGContextRef _metalContext;\n    BOOL _errorCreatingMetalContext;\n\n    id<iTermKeyMapper> _keyMapper;\n    iTermKeyMappingMode _keyMappingMode;\n\n    NSString *_badgeFontName;\n    iTermVariableScope *_variablesScope;\n    \n    BOOL _showingVisualIndicatorForEsc;\n\n    iTermPrintGuard *_printGuard;\n    iTermBuiltInFunctions *_methods;\n\n    // When this is true, changing the font size does not cause the window size to change.\n    BOOL _windowAdjustmentDisabled;\n    NSSize _badgeLabelSizeFraction;\n\n    // To debug a problem where a session is divorced but its guid is not in the sessions instance profile model.\n    NSString *_divorceDecree;\n\n    BOOL _cursorTypeOverrideChanged;\n    BOOL _titleDirty;\n    // May be stale, but allows us to update titles fast after an OSC 0/1/2\n    iTermProcessInfo *_lastProcessInfo;\n    iTermLoggingHelper *_logging;\n    iTermNaggingController *_naggingController;\n    BOOL _tmuxTTLHasThresholds;\n    NSTimeInterval _tmuxTTLLowerThreshold;\n    NSTimeInterval _tmuxTTLUpperThreshold;\n    // If nonnil, gives the GUID of the session from the arrangement that created it. Often this\n    // will differ from its real GUID. It only serves to find the session in the arrangement to\n    // make repairs.\n    NSString *_arrangementGUID;\n\n    VT100GridSize _savedGridSize;\n\n    iTermActivityInfo _activityInfo;\n    TriggerController *_triggerWindowController;\n\n    // If positive focus reports will not be sent.\n    NSInteger _disableFocusReporting;\n\n    BOOL _initializationFinished;\n    BOOL _needsJiggle;\n\n    // Have we finished loading the address book and color map initially?\n    BOOL _profileInitialized;\n    iTermUserDefaultsObserver *_disableTransparencyInKeyWindowObserver;\n    VT100MutableScreenConfiguration *_config;\n\n    BOOL _profileDidChange;\n    NSInteger _estimatedThroughput;\n    iTermPasteboardReporter *_pasteboardReporter;\n    iTermConductor *_conductor;\n    iTermSSHState _sshState;\n    // (unique ID, hostname)\n    NSMutableData *_sshWriteQueue;\n    BOOL _jiggleUponAttach;\n\n    // Are we currently enqueuing the bytes to write a focus report?\n    BOOL _reportingFocus;\n\n    AITermControllerObjC *_aiterm;\n    NSMutableArray<NSString *> *_commandQueue;\n    NSMutableArray<iTermSSHReconnectionInfo *> *_pendingJumps;\n\n    // If true the session was just created and an offscreen mark alert would be annoying.\n    BOOL _temporarilySuspendOffscreenMarkAlerts;\n    NSMutableArray<NSData *> *_dataQueue;\n\n    BOOL _promptStateAllowsAutoComposer;\n    NSArray<ScreenCharArray *> *_desiredComposerPrompt;\n\n    iTermLocalFileChecker *_localFileChecker;\n    BOOL _needsComposerColorUpdate;\n    BOOL _textViewShouldTakeFirstResponder;\n}\n\n@synthesize isDivorced = _divorced;\n\n+ (NSMapTable<NSString *, PTYSession *> *)sessionMap {\n    static NSMapTable *map;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        NSPointerFunctionsOptions weakWeak = (NSPointerFunctionsWeakMemory | NSPointerFunctionsObjectPersonality);\n        map = [[NSMapTable alloc] initWithKeyOptions:weakWeak\n                                        valueOptions:weakWeak\n                                            capacity:1];\n    });\n    return map;\n}\n\n+ (void)registerBuiltInFunctions {\n    [iTermSessionTitleBuiltInFunction registerBuiltInFunction];\n}\n\n+ (void)registerSessionInArrangement:(NSDictionary *)arrangement {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        gRegisteredSessionContents = [[NSMutableDictionary alloc] init];\n    });\n    NSString *guid = arrangement[SESSION_ARRANGEMENT_GUID];\n    NSDictionary *contents = arrangement[SESSION_ARRANGEMENT_CONTENTS];\n    if (guid && contents) {\n        DLog(@\"Register arrangement for %@\", arrangement[SESSION_ARRANGEMENT_GUID]);\n        gRegisteredSessionContents[guid] = contents;\n    }\n}\n\n+ (void)removeAllRegisteredSessions {\n    DLog(@\"Remove all registered sessions\");\n    [gRegisteredSessionContents removeAllObjects];\n}\n\n- (instancetype)initWithCoder:(NSCoder *)coder {\n    assert(NO);\n    return [self initSynthetic:NO];\n}\n\n- (instancetype)initSynthetic:(BOOL)synthetic {\n    self = [super init];\n    if (self) {\n        DLog(@\"Begin initialization of new PTYsession %p\", self);\n        _autoLogId = arc4random();\n        _useAdaptiveFrameRate = [iTermAdvancedSettingsModel useAdaptiveFrameRate];\n        _adaptiveFrameRateThroughputThreshold = [iTermAdvancedSettingsModel adaptiveFrameRateThroughputThreshold];\n        _idleTime = [iTermAdvancedSettingsModel idleTimeSeconds];\n\n        // The new session won't have the move-pane overlay, so just exit move pane\n        // mode.\n        [[MovePaneController sharedInstance] exitMovePaneMode];\n        _lastInput = [NSDate timeIntervalSinceReferenceDate];\n        _modeHandler = [[iTermSessionModeHandler alloc] init];\n        _modeHandler.delegate = self;\n\n        _lastOutputIgnoringOutputAfterResizing = _lastInput;\n        _lastUpdate = _lastInput;\n        _pasteHelper = [[iTermPasteHelper alloc] init];\n        _pasteHelper.delegate = self;\n\n        // Allocate screen, shell, and terminal objects\n        _shell = [[PTYTask alloc] init];\n        // Allocate a guid. If we end up restoring from a session during startup this will be replaced.\n        _guid = [[NSString uuid] retain];\n        [[PTYSession sessionMap] setObject:self forKey:_guid];\n\n        _screen = [[VT100Screen alloc] init];\n        NSParameterAssert(_shell != nil && _screen != nil);\n\n        _overriddenFields = [[NSMutableSet alloc] init];\n\n        _variables = [[iTermVariables alloc] initWithContext:iTermVariablesSuggestionContextSession\n                                                       owner:self];\n        // Alias for legacy paths\n        [self.variablesScope setValue:_variables forVariableNamed:@\"session\" weak:YES];\n        _userVariables = [[iTermVariables alloc] initWithContext:iTermVariablesSuggestionContextNone\n                                                           owner:self];\n        [self.variablesScope setValue:_userVariables forVariableNamed:@\"user\"];\n\n        _creationDate = [[NSDate date] retain];\n        NSDateFormatter *dateFormatter = [[[NSDateFormatter alloc] init] autorelease];\n        dateFormatter.dateFormat = @\"yyyyMMdd_HHmmss\";\n        [self.variablesScope setValue:[dateFormatter stringFromDate:_creationDate]\n                     forVariableNamed:iTermVariableKeySessionCreationTimeString];\n        [self.variablesScope setValue:[@(_autoLogId) stringValue] forVariableNamed:iTermVariableKeySessionAutoLogID];\n        [self.variablesScope setValue:_guid forVariableNamed:iTermVariableKeySessionID];\n        [self.variablesScope setValue:@\"\" forVariableNamed:iTermVariableKeySessionSelection];\n        [self.variablesScope setValue:@0 forVariableNamed:iTermVariableKeySessionSelectionLength];\n        [self.variablesScope setValue:@NO forVariableNamed:iTermVariableKeySessionShowingAlternateScreen];\n        [self.variablesScope setValue:NSHomeDirectory() forVariableNamed:iTermVariableKeySessionHomeDirectory];\n        [self.variablesScope setValue:@0 forVariableNamed:iTermVariableKeySSHIntegrationLevel];\n        self.variablesScope.shell = [self bestGuessAtUserShell];\n        self.variablesScope.uname = [self bestGuessAtUName];\n\n        _variables.primaryKey = iTermVariableKeySessionID;\n        _jobPidRef = [[iTermVariableReference alloc] initWithPath:iTermVariableKeySessionJobPid\n                                                           vendor:self.variablesScope];\n        __weak __typeof(self) weakSelf = self;\n        _jobPidRef.onChangeBlock = ^{\n            [weakSelf jobPidDidChange];\n        };\n\n        [_autoNameSwiftyString invalidate];\n        [_autoNameSwiftyString autorelease];\n        _autoNameSwiftyString = [[iTermSwiftyString alloc] initWithScope:self.variablesScope\n                                                              sourcePath:iTermVariableKeySessionAutoNameFormat\n                                                         destinationPath:iTermVariableKeySessionAutoName];\n        _autoNameSwiftyString.observer = ^NSString *(NSString * _Nonnull newValue, NSError *error) {\n            if ([weakSelf checkForCyclesInSwiftyStrings]) {\n                weakSelf.variablesScope.autoNameFormat = @\"[Cycle detected]\";\n            }\n            return newValue;\n        };\n\n        _tmuxSecureLogging = NO;\n        _tailFindContext = [[FindContext alloc] init];\n        _lastOrCurrentlyRunningCommandAbsRange = VT100GridAbsCoordRangeMake(-1, -1, -1, -1);\n        _activityCounter = [@0 retain];\n        _announcements = [[NSMutableDictionary alloc] init];\n        _commands = [[NSMutableArray alloc] init];\n        _directories = [[NSMutableArray alloc] init];\n        _hosts = [[NSMutableArray alloc] init];\n        _hostnameToShell = [[NSMutableDictionary alloc] init];\n        _automaticProfileSwitcher = [[iTermAutomaticProfileSwitcher alloc] initWithDelegate:self];\n        _cadenceController = [[iTermUpdateCadenceController alloc] init];\n        _cadenceController.delegate = self;\n\n        _keystrokeSubscriptions = [[NSMutableDictionary alloc] init];\n        _keyboardFilterSubscriptions = [[NSMutableDictionary alloc] init];\n        _updateSubscriptions = [[NSMutableDictionary alloc] init];\n        _promptSubscriptions = [[NSMutableDictionary alloc] init];\n        _customEscapeSequenceNotifications = [[NSMutableDictionary alloc] init];\n        _metalDisabledTokens = [[NSMutableSet alloc] init];\n        _statusChangedAbsLine = -1;\n        _nameController = [[iTermSessionNameController alloc] init];\n        _nameController.delegate = self;\n        _metalGlue = [[iTermMetalGlue alloc] init];\n        _metalGlue.delegate = self;\n        _metalGlue.screen = _screen;\n        _metaFrustrationDetector = [[iTermMetaFrustrationDetector alloc] init];\n        _metaFrustrationDetector.delegate = self;\n        _pwdPoller = [[iTermWorkingDirectoryPoller alloc] init];\n        _pwdPoller.delegate = self;\n        _graphicSource = [[iTermGraphicSource alloc] init];\n        _commandQueue = [[NSMutableArray alloc] init];\n        _alertOnMarksinOffscreenSessions = [iTermPreferences boolForKey:kPreferenceKeyAlertOnMarksInOffscreenSessions];\n        _pendingPublishRequests = [[NSMutableArray alloc] init];\n\n        // This is a placeholder. When the profile is set it will get updated.\n        iTermStandardKeyMapper *standardKeyMapper = [[iTermStandardKeyMapper alloc] init];\n        standardKeyMapper.delegate = self;\n        _keyMapper = standardKeyMapper;\n        _disableTransparencyInKeyWindowObserver = [[iTermUserDefaultsObserver alloc] init];\n        [_disableTransparencyInKeyWindowObserver observeKey:kPreferenceKeyDisableTransparencyForKeyWindow block:^{\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [weakSelf useTransparencyDidChange];\n            });\n        }];\n        _expect = [[iTermExpect alloc] initDry:YES];\n        _sshState = iTermSSHStateNone;\n        [iTermCPUUtilization instanceForSessionID:_guid];\n\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(coprocessChanged)\n                                                     name:kCoprocessStatusChangeNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(sessionContentsChanged:)\n                                                     name:@\"iTermTabContentsChanged\"\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(synchronizeTmuxFonts:)\n                                                     name:kTmuxFontChanged\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(terminalFileShouldStop:)\n                                                     name:kTerminalFileShouldStopNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(profileSessionNameDidEndEditing:)\n                                                     name:kProfileSessionNameDidEndEditing\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(sessionHotkeyDidChange:)\n                                                     name:kProfileSessionHotkeyDidChange\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(apiServerUnsubscribe:)\n                                                     name:iTermRemoveAPIServerSubscriptionsNotification\n                                                   object:nil];\n        // Detach before windows get closed. That's why we have to use the\n        // iTermApplicationWillTerminate notification instead of\n        // NSApplicationWillTerminate, since this gets run before the windows\n        // are released.\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(applicationWillTerminate:)\n                                                     name:iTermApplicationWillTerminate\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(savedArrangementWasRepaired:)\n                                                     name:PTYSessionDidRepairSavedArrangement\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(windowWillStartLiveResize:)\n                                                     name:NSWindowWillStartLiveResizeNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(windowDidEndLiveResize:)\n                                                     name:NSWindowDidEndLiveResizeNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(apiDidStop:)\n                                                     name:iTermAPIHelperDidStopNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(tmuxWillKillWindow:)\n                                                     name:iTermTmuxControllerWillKillWindow\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(applicationDidResignActive:)\n                                                     name:NSApplicationDidResignActiveNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(refreshTerminal:)\n                                                     name:kRefreshTerminalNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(metalClipViewWillScroll:)\n                                                     name:iTermMetalClipViewWillScroll\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(alertOnMarksinOffscreenSessionsDidChange:)\n                                                     name:iTermDidToggleAlertOnMarksInOffscreenSessionsNotification\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(windowDidMiniaturize:)\n                                                     name:@\"iTermWindowWillMiniaturize\"\n                                                   object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(autoComposerDidChange:)\n                                                     name:iTermAutoComposerDidChangeNotification\n                                                   object:nil];\n        [[[NSWorkspace sharedWorkspace] notificationCenter] addObserver:self\n                                                               selector:@selector(activeSpaceDidChange:)\n                                                                   name:NSWorkspaceActiveSpaceDidChangeNotification\n                                                                 object:nil];\n        [[NSUserDefaults standardUserDefaults] it_addObserverForKey:kPreferenceKeyTabStyle\n                                                              block:^(id _Nonnull newValue) {\n                                                                  [weakSelf themeDidChange];\n                                                              }];\n        [NSApp addObserver:self\n                forKeyPath:@\"effectiveAppearance\"\n                   options:NSKeyValueObservingOptionNew\n                   context:&iTermEffectiveAppearanceKey];\n\n        [[iTermFindPasteboard sharedInstance] addObserver:self block:^(id sender, NSString * _Nonnull newValue) {\n            if (!weakSelf.view.window.isKeyWindow) {\n                return;\n            }\n            if (![iTermAdvancedSettingsModel synchronizeQueryWithFindPasteboard] && sender != weakSelf) {\n                return;\n            }\n            [weakSelf findPasteboardStringDidChangeTo:newValue];\n        }];\n\n        if (!synthetic) {\n            [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionCreatedNotification object:self];\n        }\n        _profileDidChange = YES;\n        _config = [[VT100MutableScreenConfiguration alloc] init];\n        [self sync];\n        DLog(@\"Done initializing new PTYSession %@\", self);\n    }\n    return self;\n}\n\nITERM_WEAKLY_REFERENCEABLE\n\n- (void)dealloc {\n    [NSApp removeObserver:self forKeyPath:@\"effectiveAppearance\"];\n\n    if (_textview.delegate == self) {\n        _textview.delegate = nil;\n    }\n    [_view release];\n    [_logging stop];\n    if (@available(macOS 10.11, *)) {\n        [_metalGlue release];\n    }\n    [_nameController release];\n    [self stopTailFind];  // This frees the substring in the tail find context, if needed.\n    _shell.delegate = nil;\n    [_pasteboard release];\n    [_pbtext release];\n    [_creationDate release];\n    [_activityCounter release];\n    [_termVariable release];\n    [_colorFgBgVariable release];\n    [_profile release];\n    [_overriddenFields release];\n    _pasteHelper.delegate = nil;\n    [_pasteHelper release];\n    [_backgroundImagePath release];\n    [_backgroundImage release];\n    [_antiIdleTimer invalidate];\n    [_cadenceController release];\n    [_originalProfile release];\n    [_liveSession release];\n    [_tmuxGateway release];\n    [_tmuxController release];\n    [_download stop];\n    [_download endOfData];\n    [_download release];\n    [_upload stop];\n    [_upload endOfData];\n    [_upload release];\n    [_shell release];\n    [_screen release];\n    [_tailFindContext release];\n    [_patternedImage release];\n    [_announcements release];\n    [_variables release];\n    [_userVariables release];\n    [_program release];\n    [_customShell release];\n    [_environment release];\n    [_commands release];\n    [_directories release];\n    [_hosts release];\n    [_bellRate release];\n    [iTermCPUUtilization setInstance:nil forSessionID:_guid];\n    [_guid release];\n    [_lastCommand release];\n    [_substitutions release];\n    [_automaticProfileSwitcher release];\n\n    [_keyLabels release];\n    [_keyLabelsStack release];\n    [_currentHost release];\n    [_hostnameToShell release];\n\n    [_keystrokeSubscriptions release];\n    [_keyboardFilterSubscriptions release];\n    [_updateSubscriptions release];\n    [_promptSubscriptions release];\n    [_customEscapeSequenceNotifications release];\n\n    [_modeHandler release];\n    [_metalDisabledTokens release];\n    [_badgeSwiftyString release];\n    [_subtitleSwiftyString release];\n    [_autoNameSwiftyString release];\n    [_statusBarViewController release];\n    [_backgroundDrawingHelper release];\n    [_metaFrustrationDetector release];\n    [_tmuxStatusBarMonitor setActive:NO];\n    [_tmuxStatusBarMonitor release];\n    [_tmuxTitleMonitor release];\n    [_tmuxForegroundJobMonitor invalidate];\n    [_tmuxForegroundJobMonitor release];\n    [_paneIndexMonitor invalidate];\n    [_paneIndexMonitor release];\n    if (_metalContext) {\n        CGContextRelease(_metalContext);\n    }\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n\n    if (_dvrDecoder) {\n        [_dvr releaseDecoder:_dvrDecoder];\n        [_dvr release];\n    }\n\n    [_cursorGuideColor release];\n    [_lastDirectory release];\n    [_lastLocalDirectory release];\n    [_lastRemoteHost release];\n    [_textview release];  // I'm not sure it's ever nonnil here\n    [_currentMarkOrNotePosition release];\n    [_pwdPoller release];\n    [_graphicSource release];\n    [_jobPidRef release];\n    [_customIcon release];\n    [_keyMapper release];\n    [_badgeFontName release];\n    [_variablesScope release];\n    [_printGuard release];\n    [_methods release];\n    [_divorceDecree release];\n    [_cursorTypeOverride release];\n    [_lastProcessInfo release];\n    _logging.rawLogger = nil;\n    _logging.cookedLogger = nil;\n    [_logging release];\n    [_naggingController release];\n    [_pasteBracketingOopsieExpectation release];\n    if (_cookie) {\n        [[iTermWebSocketCookieJar sharedInstance] removeCookie:_cookie];\n        [_cookie release];\n    }\n    [_composerManager release];\n    [_tmuxClientWritePipe release];\n    [_arrangementGUID release];\n    [_triggerWindowController release];\n    [_filter release];\n    [_asyncFilter cancel];\n    [_asyncFilter release];\n    [_contentSubscribers release];\n    [_foundingArrangement release];\n    [_disableTransparencyInKeyWindowObserver release];\n    [_preferredProxyIcon release];\n    [_savedStateForZoom release];\n    [_config release];\n    [_expect release];\n    [_pasteboardReporter release];\n    [_conductor release];\n    [_sshWriteQueue release];\n    [_lastNonFocusReportingWrite release];\n    [_lastFocusReportDate release];\n    [_aiterm release];\n    [_commandQueue release];\n    [_pendingJumps release];\n    [_dataQueue release];\n    [_pendingPublishRequests release];\n    [_desiredComposerPrompt release];\n    [_localFileChecker release];\n\n    [super dealloc];\n}\n\n- (NSString *)description {\n    NSString *synthetic = _synthetic ? @\" Synthetic\" : @\"\";\n    return [NSString stringWithFormat:@\"<%@: %p %dx%d metal=%@ id=%@%@>\",\n            [self class], self, [_screen width], [_screen height], @(self.useMetal), _guid, synthetic];\n}\n\n- (void)didFinishInitialization {\n    DLog(@\"didFinishInitialization\");\n    [_pwdPoller poll];\n    _initializationFinished = YES;\n    if ([self.variablesScope valueForVariableName:iTermVariableKeySessionUsername] == nil) {\n        [self.variablesScope setValue:NSUserName() forVariableNamed:iTermVariableKeySessionUsername];\n    }\n    if ([self.variablesScope valueForVariableName:iTermVariableKeySessionHostname] == nil) {\n        NSString *const name = [NSHost fullyQualifiedDomainName];\n        if ([self.variablesScope valueForVariableName:iTermVariableKeySessionHostname] == nil) {\n            [self.variablesScope setValue:name forVariableNamed:iTermVariableKeySessionHostname];\n        }\n    }\n    if (_desiredComposerPrompt) {\n        DLog(@\"Delayed reveal of prompt\");\n        NSArray<ScreenCharArray *> *prompt = [_desiredComposerPrompt autorelease];\n        _desiredComposerPrompt = nil;\n        [self screenRevealComposerWithPrompt:prompt];\n    }\n}\n\n- (void)setGuid:(NSString *)guid {\n    if ([NSObject object:guid isEqualToObject:_guid]) {\n        return;\n    }\n    if (_guid) {\n        [[PTYSession sessionMap] removeObjectForKey:_guid];\n    }\n    iTermPublisher<NSNumber *> *previousPublisher = [[[[iTermCPUUtilization instanceForSessionID:_guid] publisher] retain] autorelease];\n    [_guid autorelease];\n    _guid = [guid copy];\n    [[iTermCPUUtilization instanceForSessionID:_guid] setPublisher:previousPublisher];\n    [self sync];\n    [[PTYSession sessionMap] setObject:self forKey:_guid];\n    [self.variablesScope setValue:_guid forVariableNamed:iTermVariableKeySessionID];\n}\n\n- (void)takeStatusBarViewControllerFrom:(PTYSession *)donorSession {\n    [_view takeFindDriverFrom:donorSession.view delegate:self];\n\n    _statusBarViewController.delegate = nil;\n    [_statusBarViewController release];\n\n    _statusBarViewController = donorSession->_statusBarViewController;\n    _statusBarViewController.delegate = self;\n\n    donorSession->_statusBarViewController = nil;\n}\n\n- (void)willRetireSyntheticSession:(PTYSession *)syntheticSession {\n    [self takeStatusBarViewControllerFrom:syntheticSession];\n}\n\n- (void)setLiveSession:(PTYSession *)liveSession {\n    assert(liveSession != self);\n    if (liveSession) {\n        assert(!_liveSession);\n        _synthetic = YES;\n        [self takeStatusBarViewControllerFrom:liveSession];\n    } else {\n        [_liveSession autorelease];\n    }\n    _liveSession = liveSession;\n    [_liveSession retain];\n}\n\n- (void)setDvr:(DVR*)dvr liveSession:(PTYSession*)liveSession {\n    _screen.dvr = nil;\n    _dvr = dvr;\n    [_dvr retain];\n    _dvrDecoder = [dvr getDecoder];\n    long long t = [_dvr lastTimeStamp];\n    if (t) {\n        [_dvrDecoder seek:t];\n        [self setDvrFrame];\n    }\n}\n\n- (void)setNeedsDisplay:(BOOL)needsDisplay {\n    [_wrapper setNeedsDisplay:needsDisplay];\n}\n\n- (id<ExternalSearchResultsController>)externalSearchResultsController {\n    return _textview;\n}\n\n- (void)clearInstantReplay {\n    if (_dvrDecoder) {\n        [_dvr releaseDecoder:_dvrDecoder];\n        _dvrDecoder = nil;\n    }\n    [_screen.dvr clear];\n}\n\n- (void)irAdvance:(int)dir\n{\n    if (!_dvr) {\n        if (dir < 0) {\n            [[_delegate realParentWindow] replaySession:self];\n            PTYSession* irSession = [[_delegate realParentWindow] currentSession];\n            if (irSession != self) {\n                // Failed to enter replay mode (perhaps nothing to replay?)\n                [irSession irAdvance:dir];\n            }\n            return;\n        } else {\n            DLog(@\"Beep: Can't go backward when no dvr\");\n            NSBeep();\n            return;\n        }\n\n    }\n    if (dir > 0) {\n        if (![_dvrDecoder next]) {\n            DLog(@\"Beep: dvr reached end\");\n            NSBeep();\n        }\n    } else {\n        if (![_dvrDecoder prev]) {\n            DLog(@\"Beep: dvr reached start\");\n            NSBeep();\n        }\n    }\n    [self setDvrFrame];\n}\n\n- (long long)irSeekToAtLeast:(long long)timestamp\n{\n    assert(_dvr);\n    if (![_dvrDecoder seek:timestamp]) {\n        return [_dvrDecoder timestamp];\n    }\n    [self setDvrFrame];\n    return [_dvrDecoder timestamp];\n}\n\n- (void)appendLinesInRange:(NSRange)rangeOfLines fromSession:(PTYSession *)source {\n    assert(source != self);\n    _modeHandler.mode = iTermSessionModeDefault;\n\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [source.screen enumerateLinesInRange:rangeOfLines\n                                       block:^(int i,\n                                               ScreenCharArray *sca,\n                                               iTermImmutableMetadata metadata,\n                                               BOOL *stopPtr) {\n            if (i + 1 == NSMaxRange(rangeOfLines)) {\n                screen_char_t continuation = { 0 };\n                continuation.code = EOL_SOFT;\n                [mutableState appendScreenChars:sca.line\n                                         length:sca.length\n                         externalAttributeIndex:iTermImmutableMetadataGetExternalAttributesIndex(metadata)\n                                   continuation:continuation];\n            } else {\n                [mutableState appendScreenChars:sca.line\n                                         length:sca.length\n                         externalAttributeIndex:iTermImmutableMetadataGetExternalAttributesIndex(metadata)\n                                   continuation:sca.continuation];\n            }\n        }];\n    }];\n}\n\n- (void)setCopyMode:(BOOL)copyMode {\n    [_textview removePortholeSelections];\n    _modeHandler.mode = copyMode ? iTermSessionModeCopy : iTermSessionModeDefault;\n}\n\n- (BOOL)copyMode {\n    return _modeHandler.mode == iTermSessionModeCopy;\n}\n\n- (BOOL)sessionModeConsumesEvent:(NSEvent *)event {\n    return [_modeHandler wouldHandleEvent:event];\n}\n\n- (void)coprocessChanged\n{\n    [_textview setNeedsDisplay:YES];\n}\n\n+ (void)drawArrangementPreview:(NSDictionary *)arrangement frame:(NSRect)frame dark:(BOOL)dark {\n    Profile *theBookmark =\n    [[ProfileModel sharedInstance] bookmarkWithGuid:arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_GUID]];\n    if (!theBookmark) {\n        theBookmark = [arrangement objectForKey:SESSION_ARRANGEMENT_BOOKMARK];\n    }\n    NSColor *color = [iTermProfilePreferences colorForKey:KEY_BACKGROUND_COLOR\n                                                     dark:dark\n                                                  profile:theBookmark];\n    [color set];\n    NSRectFill(frame);\n}\n\n- (void)setSizeFromArrangement:(NSDictionary*)arrangement {\n    [self setSize:VT100GridSizeMake([[arrangement objectForKey:SESSION_ARRANGEMENT_COLUMNS] intValue],\n                                    [[arrangement objectForKey:SESSION_ARRANGEMENT_ROWS] intValue])];\n}\n\n+ (NSDictionary *)repairedArrangement:(NSDictionary *)arrangement\n             replacingProfileWithGUID:(NSString *)badGuid\n                          withProfile:(Profile *)goodProfile {\n    if ([arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_GUID] isEqualToString:badGuid]) {\n        NSMutableDictionary *result = [[arrangement mutableCopy] autorelease];\n        result[SESSION_ARRANGEMENT_BOOKMARK] = goodProfile;\n        return result;\n    } else {\n        return arrangement;\n    }\n}\n\n+ (NSDictionary *)repairedArrangement:(NSDictionary *)arrangement\n     replacingOldCWDOfSessionWithGUID:(NSString *)guid\n                           withOldCWD:(NSString *)replacementOldCWD {\n    if ([arrangement[SESSION_ARRANGEMENT_GUID] isEqualToString:guid]) {\n        return [arrangement dictionaryBySettingObject:replacementOldCWD\n                                               forKey:SESSION_ARRANGEMENT_WORKING_DIRECTORY];\n    }\n    return arrangement;\n}\n\n+ (void)finishInitializingArrangementOriginatedSession:(PTYSession *)aSession\n                                           arrangement:(NSDictionary *)arrangement\n                                       arrangementName:(NSString *)arrangementName\n                                      attachedToServer:(BOOL)attachedToServer\n                                              delegate:(id<PTYSessionDelegate>)delegate\n                                    didRestoreContents:(BOOL)didRestoreContents\n                                           needDivorce:(BOOL)needDivorce\n                                            objectType:(iTermObjectType)objectType\n                                           sessionView:(SessionView *)sessionView\n                                   shouldEnterTmuxMode:(BOOL)shouldEnterTmuxMode\n                                                 state:(NSDictionary *)state\n                                     tmuxDCSIdentifier:(NSString *)tmuxDCSIdentifier\n                                        missingProfile:(BOOL)missingProfile {\n    if (needDivorce) {\n        [aSession divorceAddressBookEntryFromPreferences];\n        [aSession sessionProfileDidChange];\n    }\n\n    // This is done after divorce out of paranoia, since it will modify the profile.\n    NSDictionary *shortcutDictionary = arrangement[SESSION_ARRANGEMENT_HOTKEY];\n    if (shortcutDictionary) {\n        [[iTermSessionHotkeyController sharedInstance] setShortcut:[iTermShortcut shortcutWithDictionary:shortcutDictionary]\n                                                        forSession:aSession];\n        [aSession setSessionSpecificProfileValues:@{ KEY_SESSION_HOTKEY: shortcutDictionary }];\n    }\n\n    [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        NSArray *history = [arrangement objectForKey:SESSION_ARRANGEMENT_TMUX_HISTORY];\n        if (history) {\n            [mutableState setHistory:history];\n        }\n        history = [arrangement objectForKey:SESSION_ARRANGEMENT_TMUX_ALT_HISTORY];\n        if (history) {\n            [mutableState setAltScreen:history];\n        }\n    }];\n    [aSession.nameController restoreNameFromStateDictionary:arrangement[SESSION_ARRANGEMENT_NAME_CONTROLLER_STATE]];\n    if (arrangement[SESSION_ARRANGEMENT_VARIABLES]) {\n        NSDictionary *variables = arrangement[SESSION_ARRANGEMENT_VARIABLES];\n        for (id key in variables) {\n            if ([key hasPrefix:@\"iterm2.\"]) {\n                // Legacy states had this\n                continue;\n            }\n            if ([[aSession.variablesScope valueForVariableName:key] isKindOfClass:[iTermVariables class]]) {\n                // Don't replace nonterminals.\n                continue;\n            }\n            if (!attachedToServer && [key isEqualToString:iTermVariableKeySessionTTY]) {\n                // When starting a new session, don't restore the tty. We *do* want to restore it\n                // when attaching to a session restoration server, though. We have a reasonable\n                // believe that it's the same process and therefore the same TTY.\n                continue;\n            }\n            [aSession.variablesScope setValue:variables[key] forVariableNamed:key];\n        }\n        aSession.textview.badgeLabel = aSession.badgeLabel;\n    }\n\n    if (didRestoreContents && attachedToServer) {\n        [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            if (arrangement[SESSION_ARRANGEMENT_SHELL_INTEGRATION_EVER_USED_DEPRECATED]) {\n                // Legacy migration path\n                const BOOL shellIntegrationEverUsed = [arrangement[SESSION_ARRANGEMENT_SHELL_INTEGRATION_EVER_USED_DEPRECATED] boolValue];\n                mutableState.shouldExpectPromptMarks = shellIntegrationEverUsed;\n            } else {\n                mutableState.shouldExpectPromptMarks = [arrangement[SESSION_ARRANGEMENT_SHOULD_EXPECT_PROMPT_MARKS] boolValue];\n                aSession->_shouldExpectCurrentDirUpdates = [arrangement[SESSION_ARRANGEMENT_SHOULD_EXPECT_CURRENT_DIR_UPDATES] boolValue];\n            }\n        }];\n    }\n\n    aSession->_workingDirectoryPollerDisabled = [arrangement[SESSION_ARRANGEMENT_WORKING_DIRECTORY_POLLER_DISABLED] boolValue] || aSession->_shouldExpectCurrentDirUpdates;\n    if (arrangement[SESSION_ARRANGEMENT_COMMANDS]) {\n        [aSession.commands addObjectsFromArray:arrangement[SESSION_ARRANGEMENT_COMMANDS]];\n        [aSession trimCommandsIfNeeded];\n    }\n    if (arrangement[SESSION_ARRANGEMENT_DIRECTORIES]) {\n        [aSession.directories addObjectsFromArray:arrangement[SESSION_ARRANGEMENT_DIRECTORIES]];\n        [aSession trimDirectoriesIfNeeded];\n    }\n    if (arrangement[SESSION_ARRANGEMENT_HOSTS]) {\n        for (NSDictionary *host in arrangement[SESSION_ARRANGEMENT_HOSTS]) {\n            id<VT100RemoteHostReading> remoteHost = [[[VT100RemoteHost alloc] initWithDictionary:host] autorelease];\n            if (remoteHost) {\n                [aSession.hosts addObject:remoteHost];\n                [aSession trimHostsIfNeeded];\n            }\n        }\n    }\n\n    if (arrangement[SESSION_ARRANGEMENT_APS]) {\n        aSession.automaticProfileSwitcher =\n        [[iTermAutomaticProfileSwitcher alloc] initWithDelegate:aSession\n                                                     savedState:arrangement[SESSION_ARRANGEMENT_APS]];\n    }\n    if (didRestoreContents) {\n        aSession->_sshState = [arrangement[SESSION_ARRANGEMENT_SSH_STATE] unsignedIntegerValue];\n    }\n    aSession.cursorTypeOverride = arrangement[SESSION_ARRANGEMENT_CURSOR_TYPE_OVERRIDE];\n    if (didRestoreContents && attachedToServer) {\n        if (arrangement[SESSION_ARRANGEMENT_ALERT_ON_NEXT_MARK]) {\n            aSession->_alertOnNextMark = [arrangement[SESSION_ARRANGEMENT_ALERT_ON_NEXT_MARK] boolValue];\n        }\n        if (arrangement[SESSION_ARRANGEMENT_CURSOR_GUIDE]) {\n            aSession.textview.highlightCursorLine = [arrangement[SESSION_ARRANGEMENT_CURSOR_GUIDE] boolValue];\n        }\n        aSession.lastRemoteHost = aSession.screen.lastRemoteHost;\n        if (arrangement[SESSION_ARRANGEMENT_LAST_DIRECTORY]) {\n            [aSession->_lastDirectory autorelease];\n            aSession->_lastDirectory = [arrangement[SESSION_ARRANGEMENT_LAST_DIRECTORY] copy];\n            const BOOL isRemote = [arrangement[SESSION_ARRANGEMENT_LAST_DIRECTORY_IS_UNSUITABLE_FOR_OLD_PWD_DEPRECATED] boolValue];\n            if (!isRemote) {\n                aSession.lastLocalDirectory = aSession.lastDirectory;\n            }\n        }\n        if (arrangement[SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY]) {\n            aSession.lastLocalDirectory = arrangement[SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY];\n            aSession.lastLocalDirectoryWasPushed = [arrangement[SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY_WAS_PUSHED] boolValue];\n        }\n    }\n\n    if (state) {\n        [aSession setTmuxState:state];\n    }\n    NSDictionary *liveArrangement = arrangement[SESSION_ARRANGEMENT_LIVE_SESSION];\n    if (liveArrangement) {\n        SessionView *liveView = [[[SessionView alloc] initWithFrame:sessionView.frame] autorelease];\n        liveView.driver.dataSource = aSession->_metalGlue;\n        aSession.textview.cursorVisible = NO;\n        [delegate session:aSession setLiveSession:[self sessionFromArrangement:liveArrangement\n                                                                         named:nil\n                                                                        inView:liveView\n                                                                  withDelegate:delegate\n                                                                 forObjectType:objectType\n                                                            partialAttachments:nil]];\n    }\n    if (shouldEnterTmuxMode) {\n        // Restored a tmux gateway session.\n        [aSession startTmuxMode:tmuxDCSIdentifier];\n        [aSession.tmuxController sessionChangedTo:arrangement[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_NAME]\n                                        sessionId:[arrangement[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_ID] intValue]];\n        [aSession kickOffTmux];\n    }\n    if (missingProfile) {\n        NSDictionary *arrangementProfile = arrangement[SESSION_ARRANGEMENT_BOOKMARK];\n        if (arrangementProfile) {\n            [aSession.naggingController arrangementWithName:arrangementName\n                                        missingProfileNamed:arrangementProfile[KEY_NAME]\n                                                       guid:arrangementProfile[KEY_GUID]];\n        }\n    }\n    if (!attachedToServer) {\n        [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                         VT100ScreenMutableState *mutableState,\n                                                         id<VT100ScreenDelegate> delegate) {\n            [terminal resetSendModifiersWithSideEffects:YES];\n        }];\n    }\n    NSString *path = [aSession.screen workingDirectoryOnLine:aSession.screen.numberOfScrollbackLines + aSession.screen.cursorY - 1];\n    [aSession.variablesScope setValue:path forVariableNamed:iTermVariableKeySessionPath];\n\n    [aSession.nameController setNeedsUpdate];\n    [aSession.nameController updateIfNeeded];\n}\n\n- (void)didFinishRestoration {\n    if ([_foundingArrangement[SESSION_ARRANGEMENT_FILTER] length] > 0) {\n        [self.delegate session:self setFilter:_foundingArrangement[SESSION_ARRANGEMENT_FILTER]];\n    }\n}\n\n+ (PTYSession *)sessionFromArrangement:(NSDictionary *)arrangement\n                                 named:(NSString *)arrangementName\n                                inView:(SessionView *)sessionView\n                          withDelegate:(id<PTYSessionDelegate>)delegate\n                         forObjectType:(iTermObjectType)objectType\n                    partialAttachments:(NSDictionary *)partialAttachments {\n    DLog(@\"Restoring session from arrangement\");\n\n    Profile *theBookmark =\n    [[ProfileModel sharedInstance] bookmarkWithGuid:arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_GUID]];\n    BOOL needDivorce = NO;\n    BOOL missingProfile = NO;\n    if (!theBookmark) {\n        NSString *originalGuid = arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_ORIGINAL_GUID];\n        if (![[ProfileModel sharedInstance] bookmarkWithGuid:originalGuid]) {\n            missingProfile = YES;\n        }\n\n        theBookmark = [arrangement objectForKey:SESSION_ARRANGEMENT_BOOKMARK];\n        if (theBookmark) {\n            needDivorce = YES;\n        } else {\n            theBookmark = [[ProfileModel sharedInstance] defaultBookmark];\n        }\n    }\n    PTYSession *aSession = [[[PTYSession alloc] initSynthetic:NO] autorelease];\n    aSession.foundingArrangement = [arrangement dictionaryByRemovingObjectForKey:SESSION_ARRANGEMENT_CONTENTS];\n    aSession.view = sessionView;\n    aSession->_savedGridSize = VT100GridSizeMake(MAX(1, [arrangement[SESSION_ARRANGEMENT_COLUMNS] intValue]),\n                                                 MAX(1, [arrangement[SESSION_ARRANGEMENT_ROWS] intValue]));\n    [sessionView setFindDriverDelegate:aSession];\n    NSMutableSet<NSString *> *keysToPreserveInCaseOfDivorce = [NSMutableSet setWithArray:@[ KEY_GUID, KEY_ORIGINAL_GUID ]];\n\n    {\n        NSDictionary<NSString *, NSString *> *overrides = arrangement[SESSION_ARRANGEMENT_FONT_OVERRIDES];\n        if (overrides) {\n            NSMutableDictionary *temp = [[theBookmark mutableCopy] autorelease];\n            [overrides enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull key, NSString * _Nonnull obj, BOOL * _Nonnull stop) {\n                temp[key] = obj;\n            }];\n            theBookmark = [temp dictionaryByRemovingNullValues];\n        }\n    }\n\n    {\n        NSDictionary *overrides = arrangement[SESSION_ARRANGEMENT_KEYBOARD_MAP_OVERRIDES];\n        if (overrides) {\n            NSMutableDictionary *modifiedProfile = [[theBookmark mutableCopy] autorelease];\n            modifiedProfile[KEY_KEYBOARD_MAP] = overrides;\n            theBookmark = modifiedProfile;\n        }\n    }\n    if ([arrangement objectForKey:SESSION_ARRANGEMENT_TMUX_PANE]) {\n        // This is a tmux arrangement.\n        NSString *colorString = arrangement[SESSION_ARRANGEMENT_TMUX_TAB_COLOR];\n        NSDictionary *tabColorDict = [ITAddressBookMgr encodeColor:[NSColor colorFromHexString:colorString]];\n        const BOOL dark = [NSApp effectiveAppearance].it_isDark;\n        NSString *useTabColorKey = iTermAmendedColorKey(KEY_USE_TAB_COLOR, theBookmark, dark);\n        if (tabColorDict) {\n            // We're restoring a tmux arrangement that specifies a tab color.\n            NSColor *profileTabColorDict = [iTermProfilePreferences objectForColorKey:KEY_TAB_COLOR dark:dark profile:theBookmark];\n            if (![iTermProfilePreferences boolForColorKey:KEY_USE_TAB_COLOR dark:dark profile:theBookmark] ||\n                ![NSObject object:profileTabColorDict isApproximatelyEqualToObject:tabColorDict epsilon:1/255.0]) {\n                // The tmux profile does not specify a tab color or it specifies a different one. Override it and divorce.\n                NSString *tabColorKey = iTermAmendedColorKey(KEY_TAB_COLOR, theBookmark, dark);\n                theBookmark = [theBookmark dictionaryBySettingObject:tabColorDict forKey:tabColorKey];\n                theBookmark = [theBookmark dictionaryBySettingObject:@YES forKey:useTabColorKey];\n                needDivorce = YES;\n                [keysToPreserveInCaseOfDivorce addObjectsFromArray:@[ tabColorKey, useTabColorKey ]];\n            }\n        } else if ([colorString isEqualToString:iTermTmuxTabColorNone] &&\n                   [iTermProfilePreferences boolForColorKey:KEY_USE_TAB_COLOR dark:dark profile:theBookmark]) {\n            // There was no tab color but the tmux profile specifies one. Disable it and divorce.\n            theBookmark = [theBookmark dictionaryBySettingObject:@NO forKey:useTabColorKey];\n            [keysToPreserveInCaseOfDivorce addObjectsFromArray:@[ useTabColorKey ]];\n            needDivorce = YES;\n        }\n    }\n    if (needDivorce) {\n        // Keep it from stepping on an existing session with the same guid. Assign a fresh GUID.\n        // Set the ORIGINAL_GUID to an existing guid from which this profile originated if possible.\n        NSString *originalGuid = nil;\n        NSString *recordedGuid = arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_GUID];\n        NSString *recordedOriginalGuid = arrangement[SESSION_ARRANGEMENT_BOOKMARK][KEY_ORIGINAL_GUID];\n        if ([[ProfileModel sharedInstance] bookmarkWithGuid:recordedGuid]) {\n            originalGuid = recordedGuid;\n        } else if ([[ProfileModel sharedInstance] bookmarkWithGuid:recordedOriginalGuid]) {\n            originalGuid = recordedOriginalGuid;\n        }\n        if (originalGuid) {\n            theBookmark = [theBookmark dictionaryBySettingObject:originalGuid forKey:KEY_ORIGINAL_GUID];\n        }\n        theBookmark = [theBookmark dictionaryBySettingObject:[ProfileModel freshGuid] forKey:KEY_GUID];\n        if ([NSArray castFrom:arrangement[SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS]]) {\n            DLog(@\"Have overridden fields %@\", arrangement[SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS]);\n            // Use the original profile, but preserve keys that were overridden\n            // at the time the arrangement was saved. Also preserve any keys\n            // that were mutated since the profile was taken from the\n            // arrangement.\n            // This prevents an issue where you save a divorced session in an\n            // arrangement and then modify a non-overridden field in the\n            // underlying profile and that setting doesn't get reflected when\n            // you next restore the arrangement.\n            Profile *underlyingProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:originalGuid];\n            NSArray<NSString *> *overriddenFields = arrangement[SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS];\n\n            if (underlyingProfile) {\n                DLog(@\"Underlying profile %@ exists\", originalGuid);\n                MutableProfile *replacement = [[underlyingProfile mutableCopy] autorelease];\n                [keysToPreserveInCaseOfDivorce unionSet:[NSSet setWithArray:overriddenFields]];\n                for (NSString *key in keysToPreserveInCaseOfDivorce) {\n                    DLog(@\"Preserve %@=%@ from arrangement\", key, theBookmark[key]);\n                    replacement[key] = theBookmark[key];\n                }\n                theBookmark = replacement;\n            }\n        }\n    }\n\n    // set our preferences\n    [aSession setProfile:theBookmark];\n\n    [aSession setScreenSize:[sessionView frame] parent:[delegate realParentWindow]];\n\n    if ([arrangement[SESSION_ARRANGEMENT_TMUX_FOCUS_REPORTING] boolValue]) {\n        // This has to be done after setScreenSize:parent: because it has a side-effect of enabling\n        // the terminal.\n        [aSession.screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            terminal.reportFocus = [iTermAdvancedSettingsModel focusReportingEnabled];\n        }];\n    }\n\n    NSDictionary *state = [arrangement objectForKey:SESSION_ARRANGEMENT_TMUX_STATE];\n    if (state) {\n        // For tmux tabs, get the size from the arrangement instead of the containing view because\n        // it helps things to line up correctly.\n        [aSession setSizeFromArrangement:arrangement];\n    }\n    [aSession setPreferencesFromAddressBookEntry:theBookmark];\n    [aSession loadInitialColorTableAndResetCursorGuide];\n    aSession.delegate = delegate;\n\n    BOOL haveSavedProgramData = YES;\n    if ([arrangement[SESSION_ARRANGEMENT_PROGRAM] isKindOfClass:[NSDictionary class]]) {\n        NSDictionary *dict = arrangement[SESSION_ARRANGEMENT_PROGRAM];\n        if ([dict[kProgramType] isEqualToString:kProgramTypeShellLauncher]) {\n            aSession.program = [ITAddressBookMgr shellLauncherCommandWithCustomShell:nil];\n        } else if ([dict[kProgramType] isEqualToString:kProgramTypeCommand]) {\n            aSession.program = dict[kProgramCommand];\n        } else if ([dict[kProgramType] isEqualToString:kProgramTypeCustomShell]) {\n            aSession.program = [ITAddressBookMgr shellLauncherCommandWithCustomShell:dict[kCustomShell]];\n            aSession.customShell = dict[kCustomShell];\n        } else {\n            haveSavedProgramData = NO;\n        }\n    } else {\n        haveSavedProgramData = NO;\n    }\n    if (arrangement[SESSION_ARRANGEMENT_PENDING_JUMPS]) {\n        aSession->_pendingJumps = [[[NSArray castFrom:arrangement[SESSION_ARRANGEMENT_PENDING_JUMPS]] mapWithBlock:^id _Nullable(id  _Nonnull data) {\n            return [[[iTermSSHReconnectionInfo alloc] initWithData: data] autorelease];\n        }] mutableCopy];\n    }\n\n    if (arrangement[SESSION_ARRANGEMENT_ENVIRONMENT]) {\n        aSession.environment = arrangement[SESSION_ARRANGEMENT_ENVIRONMENT];\n    } else {\n        haveSavedProgramData = NO;\n    }\n\n    if (arrangement[SESSION_ARRANGEMENT_IS_UTF_8]) {\n        aSession.isUTF8 = [arrangement[SESSION_ARRANGEMENT_IS_UTF_8] boolValue];\n    } else {\n        haveSavedProgramData = NO;\n    }\n\n    aSession.shortLivedSingleUse = [arrangement[SESSION_ARRANGEMENT_SHORT_LIVED_SINGLE_USE] boolValue];\n    aSession.hostnameToShell = [[arrangement[SESSION_ARRANGEMENT_HOSTNAME_TO_SHELL] mutableCopy] autorelease];\n    [aSession.variablesScope setValue:[aSession bestGuessAtUserShell] forVariableNamed:iTermVariableKeySSHIntegrationLevel];\n\n    if (arrangement[SESSION_ARRANGEMENT_SUBSTITUTIONS]) {\n        aSession.substitutions = arrangement[SESSION_ARRANGEMENT_SUBSTITUTIONS];\n    } else {\n        haveSavedProgramData = NO;\n    }\n\n    if (arrangement[SESSION_ARRANGEMENT_REUSABLE_COOKIE]) {\n        [[iTermWebSocketCookieJar sharedInstance] addCookie:arrangement[SESSION_ARRANGEMENT_REUSABLE_COOKIE]];\n    }\n    NSNumber *tmuxPaneNumber = [arrangement objectForKey:SESSION_ARRANGEMENT_TMUX_PANE];\n    NSString *tmuxDCSIdentifier = nil;\n    BOOL shouldEnterTmuxMode = NO;\n    NSDictionary *contents = arrangement[SESSION_ARRANGEMENT_CONTENTS];\n    BOOL restoreContents = !tmuxPaneNumber && contents && [iTermAdvancedSettingsModel restoreWindowContents];\n    BOOL attachedToServer = NO;\n    typedef void (^iTermSessionCreationCompletionBlock)(PTYSession *, BOOL ok);\n    void (^runCommandBlock)(iTermSessionCreationCompletionBlock) =\n    ^(iTermSessionCreationCompletionBlock innerCompletion) {\n        innerCompletion(aSession, YES);\n    };\n    if (!tmuxPaneNumber) {\n        DLog(@\"No tmux pane ID during session restoration\");\n        // |contents| will be non-nil when using system window restoration.\n        BOOL runCommand = YES;\n        if (arrangement[SESSION_ARRANGEMENT_LIVE_SESSION]) {\n            runCommand = NO;\n        }\n        if ([iTermAdvancedSettingsModel runJobsInServers]) {\n            DLog(@\"Configured to run jobs in servers\");\n            const BOOL isTmuxGateway = [arrangement[SESSION_ARRANGEMENT_IS_TMUX_GATEWAY] boolValue];\n            if (isTmuxGateway) {\n                DLog(@\"Was a tmux gateway. Start recovery mode in parser.\");\n                // Optimistally enter tmux recovery mode. If we do attach, the parser will be in the\n                // right state before any input arrives for it.\n                // In the event that attaching to the server fails we'll first tmux recovery mode\n                // and set runCommand=YES; later, a new program will run and input will be received\n                //  but the parser is safely out of recovery mode by then.\n                [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n                    [terminal.parser startTmuxRecoveryModeWithID:arrangement[SESSION_ARRANGEMENT_TMUX_DCS_ID]];\n                }];\n            }\n            NSString *conductor = [NSString castFrom:arrangement[SESSION_ARRANGEMENT_CONDUCTOR]];\n            if (conductor) {\n                aSession->_conductor = [iTermConductor newConductorWithJSON:conductor delegate:aSession];\n            }\n            if (aSession->_conductor) {\n                [aSession updateVariablesFromConductor];\n                [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n                    NSData *data = [NSData castFrom:arrangement[SESSION_ARRANGEMENT_CONDUCTOR_TREE]];\n                    NSDictionary *dict = [NSDictionary it_fromKeyValueCodedData:data];\n                    if (dict) {\n                        [terminal.parser startConductorRecoveryModeWithID:arrangement[SESSION_ARRANGEMENT_CONDUCTOR_DCS_ID]\n                                                                     tree:dict];\n                    }\n                }];\n            }\n            // iTerm2 is currently configured to run jobs in servers, but we\n            // have to check if the arrangement was saved with that setting on.\n            BOOL didAttach = NO;\n            if ([NSNumber castFrom:arrangement[SESSION_ARRANGEMENT_SERVER_PID]]) {\n                DLog(@\"Have a server PID in the arrangement\");\n                pid_t serverPid = [arrangement[SESSION_ARRANGEMENT_SERVER_PID] intValue];\n                DLog(@\"Try to attach to pid %d\", (int)serverPid);\n                // serverPid might be -1 if the user turned on session restoration and then quit.\n                if (serverPid != -1 && [aSession tryToAttachToServerWithProcessId:serverPid\n                                                                              tty:arrangement[SESSION_ARRANGEMENT_TTY]]) {\n                    DLog(@\"Success!\");\n                    didAttach = YES;\n                }\n            } else if ([iTermMultiServerJobManager available] &&\n                       [NSDictionary castFrom:arrangement[SESSION_ARRANGEMENT_SERVER_DICT]]) {\n                DLog(@\"Have a server dict in the arrangement\");\n                NSDictionary *serverDict = arrangement[SESSION_ARRANGEMENT_SERVER_DICT];\n                DLog(@\"Try to attach to %@\", serverDict);\n                if (partialAttachments) {\n                    id partial = partialAttachments[serverDict];\n                    if (partial &&\n                        [aSession tryToFinishAttachingToMultiserverWithPartialAttachment:partial] != 0) {\n                        DLog(@\"Finished attaching to multiserver!\");\n                        didAttach = YES;\n                    }\n                } else if ([aSession tryToAttachToMultiserverWithRestorationIdentifier:serverDict]) {\n                    DLog(@\"Attached to multiserver!\");\n                    didAttach = YES;\n                }\n            }\n            if (didAttach) {\n                runCommand = NO;\n                attachedToServer = YES;\n                shouldEnterTmuxMode = ([arrangement[SESSION_ARRANGEMENT_IS_TMUX_GATEWAY] boolValue] &&\n                                       arrangement[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_NAME] != nil &&\n                                       arrangement[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_ID] != nil);\n                tmuxDCSIdentifier = arrangement[SESSION_ARRANGEMENT_TMUX_DCS_ID];\n            } else {\n                if (isTmuxGateway) {\n                    [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n                        [terminal.parser cancelTmuxRecoveryMode];\n                    }];\n                }\n                if (aSession->_conductor) {\n                    [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n                        [terminal.parser cancelConductorRecoveryMode];\n                    }];\n                    aSession->_conductor.delegate = nil;\n                    [aSession->_conductor release];\n                    aSession->_conductor = nil;\n                }\n            }\n\n        }\n\n        // GUID will be set for new saved arrangements since late 2014.\n        // Older versions won't be able to associate saved state with windows from a saved arrangement.\n        if (arrangement[SESSION_ARRANGEMENT_GUID]) {\n            DLog(@\"The session arrangement has a GUID\");\n            NSString *guid = arrangement[SESSION_ARRANGEMENT_GUID];\n            aSession->_arrangementGUID = [guid copy];\n            if (guid && gRegisteredSessionContents[guid]) {\n                DLog(@\"The GUID is registered\");\n                // There was a registered session with this guid. This session was created by\n                // restoring a saved arrangement and there is saved content registered.\n                contents = gRegisteredSessionContents[guid];\n                aSession.guid = guid;\n                DLog(@\"Assign guid %@ to session %@ which will have its contents restored from registered contents\",\n                     guid, aSession);\n            } else if ([[iTermController sharedInstance] startingUp] ||\n                       arrangement[SESSION_ARRANGEMENT_CONTENTS]) {\n                // If startingUp is set, then the session is being restored from the default\n                // arrangement, per user preference.\n                // If contents are present, then system window restoration is bringing back a\n                // session.\n                aSession.guid = guid;\n                DLog(@\"iTerm2 is starting up or has contents. Assign guid %@ to session %@ (session is loaded from saved arrangement. No content registered.)\", guid, aSession);\n            }\n        }\n\n        DLog(@\"Have contents=%@\", @(contents != nil));\n        DLog(@\"Restore window contents=%@\", @([iTermAdvancedSettingsModel restoreWindowContents]));\n        if (restoreContents) {\n            DLog(@\"Loading content from line buffer dictionary\");\n            [aSession setContentsFromLineBufferDictionary:contents\n                                 includeRestorationBanner:runCommand\n                                               reattached:attachedToServer];\n            // NOTE: THE SCREEN SIZE IS NOW OUT OF SYNC WITH THE VIEW SIZE. IT MUST BE FIXED!\n        }\n        if (arrangement[SESSION_ARRANGEMENT_KEYLABELS]) {\n            // restoreKeyLabels wants the cursor position to be set so do it after restoring contents.\n            [aSession restoreKeyLabels:[NSDictionary castFrom:arrangement[SESSION_ARRANGEMENT_KEYLABELS]]\n               updateStatusChangedLine:restoreContents];\n            NSArray *labels = arrangement[SESSION_ARRANGEMENT_KEYLABELS_STACK];\n            if (labels) {\n                [aSession->_keyLabelsStack release];\n                aSession->_keyLabelsStack = [[labels mapWithBlock:^id(id anObject) {\n                    return [[[iTermKeyLabels alloc] initWithDictionary:anObject] autorelease];\n                }] mutableCopy];\n            }\n        }\n\n        if (runCommand) {\n            // This path is NOT taken when attaching to a running server.\n            //\n            // When restoring a window arrangement with contents and a nonempty saved directory, always\n            // use the saved working directory, even if that contravenes the default setting for the\n            // profile.\n            [aSession resetForRelaunch];\n            NSString *oldCWD = arrangement[SESSION_ARRANGEMENT_WORKING_DIRECTORY];\n            DLog(@\"Running command...\");\n\n            NSDictionary *environmentArg = @{};\n            NSString *commandArg = nil;\n            NSNumber *isUTF8Arg = nil;\n            NSDictionary *substitutionsArg = nil;\n            NSString *customShell = nil;\n            if (haveSavedProgramData) {\n                // This is the normal case; the else clause is for legacy saved arrangements.\n                environmentArg = aSession.environment ?: @{};\n                commandArg = aSession.program;\n                if (oldCWD &&\n                    [aSession.program isEqualToString:[ITAddressBookMgr standardLoginCommand]]) {\n                    // Create a login session that drops you in the old directory instead of\n                    // using login -fp \"$USER\". This lets saved arrangements properly restore\n                    // the working directory when the profile specifies the home directory.\n                    commandArg = [ITAddressBookMgr shellLauncherCommandWithCustomShell:aSession.customShell];\n                }\n                isUTF8Arg = @(aSession.isUTF8);\n                substitutionsArg = aSession.substitutions;\n                customShell = aSession.customShell;\n            }\n            runCommandBlock = ^(iTermSessionCreationCompletionBlock completion) {\n                assert(completion);\n                iTermSessionAttachOrLaunchRequest *launchRequest =\n                [iTermSessionAttachOrLaunchRequest launchRequestWithSession:aSession\n                                                                  canPrompt:NO\n                                                                 objectType:objectType\n                                                        hasServerConnection:NO\n                                                           serverConnection:(iTermGeneralServerConnection){}\n                                                                  urlString:nil\n                                                               allowURLSubs:NO\n                                                                environment:environmentArg\n                                                                customShell:customShell\n                                                                     oldCWD:oldCWD\n                                                             forceUseOldCWD:contents != nil && oldCWD.length\n                                                                    command:commandArg\n                                                                     isUTF8:isUTF8Arg\n                                                              substitutions:substitutionsArg\n                                                           windowController:(PseudoTerminal *)aSession.delegate.realParentWindow\n                                                                      ready:nil\n                                                                 completion:completion];\n                launchRequest.fromArrangement = YES;\n                iTermSessionFactory *factory = [[[iTermSessionFactory alloc] init] autorelease];\n                launchRequest.arrangementName = arrangementName;\n                [factory attachOrLaunchWithRequest:launchRequest];\n            };\n        }\n    } else {\n        // Is a tmux pane\n        // NOTE: There used to be code here that used state[@\"title\"] but AFAICT that didn't exist.\n        [aSession setTmuxPane:[tmuxPaneNumber intValue]];\n    }\n\n    if (arrangement[SESSION_ARRANGEMENT_SELECTION]) {\n        [aSession.textview.selection setFromDictionaryValue:arrangement[SESSION_ARRANGEMENT_SELECTION]\n                                                      width:aSession.screen.width\n                                    totalScrollbackOverflow:aSession.screen.totalScrollbackOverflow];\n    }\n    [aSession.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState restoreInitialSizeWithDelegate:delegate];\n    }];\n    [aSession updateMarksMinimapRangeOfVisibleLines];\n\n    void (^finish)(PTYSession *, BOOL) = ^(PTYSession *newSession, BOOL ok) {\n        if (!ok) {\n            return;\n        }\n        [self finishInitializingArrangementOriginatedSession:aSession\n                                                 arrangement:arrangement\n                                             arrangementName:arrangementName\n                                            attachedToServer:attachedToServer\n                                                    delegate:delegate\n                                          didRestoreContents:restoreContents\n                                                 needDivorce:needDivorce\n                                                  objectType:objectType\n                                                 sessionView:sessionView\n                                         shouldEnterTmuxMode:shouldEnterTmuxMode\n                                                       state:state\n                                           tmuxDCSIdentifier:tmuxDCSIdentifier\n                                              missingProfile:missingProfile];\n        [aSession didFinishInitialization];\n    };\n    if ([aSession.profile[KEY_AUTOLOG] boolValue]) {\n        [aSession retain];\n        void (^startLogging)(NSString *) = ^(NSString *filename) {\n            if (filename) {\n                const NSUInteger value = [iTermProfilePreferences boolForKey:KEY_LOGGING_STYLE\n                                                                   inProfile:aSession.profile];\n                iTermLoggingStyle loggingStyle = iTermLoggingStyleFromUserDefaultsValue(value);\n                [[aSession loggingHelper] setPath:filename\n                                          enabled:YES\n                                            style:loggingStyle\n                                asciicastMetadata:[aSession asciicastMetadata]\n                                           append:@YES];\n            }\n            [aSession autorelease];\n            runCommandBlock(finish);\n        };\n        if (arrangement[SESSION_ARRANGEMENT_AUTOLOG_FILENAME] && restoreContents) {\n            startLogging(arrangement[SESSION_ARRANGEMENT_AUTOLOG_FILENAME]);\n        } else {\n            [aSession fetchAutoLogFilenameWithCompletion:startLogging];\n        }\n    } else {\n        runCommandBlock(finish);\n    }\n\n    return aSession;\n}\n\n- (iTermAsciicastMetadata *)asciicastMetadata {\n    const BOOL dark = [NSApp effectiveAppearance].it_isDark;\n\n    NSArray<NSColor *> *ansi = [[NSArray sequenceWithRange:NSMakeRange(0, 16)] mapWithBlock:^id _Nonnull(NSNumber * _Nonnull n) {\n        NSString *key = [NSString stringWithFormat:KEYTEMPLATE_ANSI_X_COLOR, n.intValue];\n        return [iTermProfilePreferences colorForKey:key\n                                               dark:dark\n                                            profile:self.profile];\n    }];\n    NSString *term = [iTermProfilePreferences stringForKey:KEY_TERMINAL_TYPE inProfile:self.profile];\n    NSDictionary *environment = @{ @\"TERM\": term ?: @\"xterm\",\n                                   @\"SHELL\": [self userShell] };\n    return [[[iTermAsciicastMetadata alloc] initWithWidth:_screen.width\n                                                   height:_screen.height\n                                                  command:_program ?: @\"\"\n                                                    title:[[self name] stringByTrimmingTrailingWhitespace] ?: @\"\"\n                                              environment:environment\n                                                       fg:[iTermProfilePreferences colorForKey:KEY_FOREGROUND_COLOR\n                                                                                          dark:dark\n                                                                                       profile:self.profile]\n                                                       bg:[iTermProfilePreferences colorForKey:KEY_BACKGROUND_COLOR\n                                                                                          dark:dark\n                                                                                       profile:self.profile]\n                                                     ansi:ansi] autorelease];\n}\n\n- (iTermLoggingHelper *)loggingHelper {\n    if (_logging) {\n        return _logging;\n    }\n    _logging = [[iTermLoggingHelper alloc] initWithRawLogger:_shell\n                                                cookedLogger:self\n                                                 profileGUID:self.profile[KEY_GUID]\n                                                       scope:self.variablesScope];\n    return _logging;\n}\n\n// WARNING: This leaves the screen with the wrong size! Call -restoreInitialSize afterwards.\n- (void)setContentsFromLineBufferDictionary:(NSDictionary *)dict\n                   includeRestorationBanner:(BOOL)includeRestorationBanner\n                                 reattached:(BOOL)reattached {\n    [_screen restoreFromDictionary:dict\n          includeRestorationBanner:includeRestorationBanner\n                        reattached:reattached];\n    [_screen enumeratePortholes:^(id<PortholeMarkReading> immutableMark) {\n        [[PortholeRegistry instance] registerKey:immutableMark.uniqueIdentifier\n                                         forMark:immutableMark];\n        id<Porthole> porthole = [_textview hydratePorthole:immutableMark];\n        if (!porthole) {\n            [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n                [mutableState.mutableIntervalTree removeObject:immutableMark.progenitor];\n            }];\n        } else {\n            [self.textview addPorthole:porthole];\n        }\n    }];\n    id<VT100RemoteHostReading> lastRemoteHost = _screen.lastRemoteHost;\n    if (lastRemoteHost) {\n        NSString *pwd = [_screen workingDirectoryOnLine:_screen.numberOfLines];\n        [self screenCurrentHostDidChange:lastRemoteHost\n                                     pwd:pwd\n                                     ssh:NO];\n    }\n\n    const BOOL enabled = _screen.terminalSoftAlternateScreenMode;\n    const BOOL showing = _screen.showingAlternateScreen;\n    [self screenSoftAlternateScreenModeDidChangeTo:enabled showingAltScreen:showing];\n    // Do this to force the hostname variable to be updated.\n    [self currentHost];\n}\n\n- (void)showOrphanAnnouncement {\n    // Jiggle in case this is an ssh session that needs to be recovered, and also to force a redraw\n    // if possible since there won't be any content. We aren't typically attached yet so set\n    // jiggleUponAttach to force it to happen eventually.\n    [self jiggle];\n    _jiggleUponAttach = YES;\n    [self.naggingController didRestoreOrphan];\n}\n\n// Session specific methods\n- (BOOL)setScreenSize:(NSRect)aRect parent:(id<WindowControllerInterface>)parent {\n    _modeHandler.mode = iTermSessionModeDefault;\n    _screen.delegate = self;\n    if ([iTermAdvancedSettingsModel showLocationsInScrollbar] && [iTermAdvancedSettingsModel showMarksInScrollbar]) {\n        _screen.intervalTreeObserver = self;\n    }\n\n    // Allocate the root per-session view.\n    if (!_view) {\n        self.view = [[[SessionView alloc] initWithFrame:NSMakeRect(0, 0, aRect.size.width, aRect.size.height)] autorelease];\n        self.view.driver.dataSource = _metalGlue;\n        [self initializeMarksMinimap];\n        [_view setFindDriverDelegate:self];\n    }\n\n    _view.scrollview.hasVerticalRuler = [parent scrollbarShouldBeVisible];\n\n    // Allocate a text view\n    NSSize aSize = [_view.scrollview contentSize];\n    _wrapper = [[TextViewWrapper alloc] initWithFrame:NSMakeRect(0, 0, aSize.width, aSize.height)];\n\n    _textview = [[PTYTextView alloc] initWithFrame:NSMakeRect(0,\n                                                              [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins],\n                                                              aSize.width,\n                                                              aSize.height)];\n    _textview.colorMap = _screen.colorMap;\n    _textview.keyboardHandler.keyMapper = _keyMapper;\n    _view.mainResponder = _textview;\n    _view.searchResultsMinimapViewDelegate = _textview.findOnPageHelper;\n    _metalGlue.textView = _textview;\n    [_textview setAutoresizingMask: NSViewWidthSizable | NSViewHeightSizable];\n    [_textview setFontTable:[iTermFontTable fontTableForProfile:_profile]\n          horizontalSpacing:[iTermProfilePreferences doubleForKey:KEY_HORIZONTAL_SPACING inProfile:_profile]\n            verticalSpacing:[iTermProfilePreferences doubleForKey:KEY_VERTICAL_SPACING inProfile:_profile]];\n    [self setTransparency:[[_profile objectForKey:KEY_TRANSPARENCY] floatValue]];\n    [self setTransparencyAffectsOnlyDefaultBackgroundColor:[[_profile objectForKey:KEY_TRANSPARENCY_AFFECTS_ONLY_DEFAULT_BACKGROUND_COLOR] boolValue]];\n\n    [_wrapper addSubview:_textview];\n    [_textview setFrame:NSMakeRect(0, [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins], aSize.width, aSize.height - [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins])];\n\n    // assign terminal and task objects\n    // Pause token execution in case the caller needs to modify terminal state before it starts running.\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        iTermTokenExecutorUnpauser *unpauser = [mutableState pauseTokenExecution];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            DLog(@\"unpause %@\", terminal);\n            [unpauser unpause];\n        });\n        [_screen setTerminalEnabled:YES];\n        [_shell setDelegate:self];\n        [self.variablesScope setValue:_shell.tty forVariableNamed:iTermVariableKeySessionTTY];\n        [self.variablesScope setValue:@(_screen.terminalMouseMode) forVariableNamed:iTermVariableKeySessionMouseReportingMode];\n\n        // initialize the screen\n        // TODO: Shouldn't this take the scrollbar into account?\n        NSSize contentSize = [PTYScrollView contentSizeForFrameSize:aSize\n                                            horizontalScrollerClass:nil\n                                              verticalScrollerClass:parent.scrollbarShouldBeVisible ? [[_view.scrollview verticalScroller] class] : nil\n                                                         borderType:_view.scrollview.borderType\n                                                        controlSize:NSControlSizeRegular\n                                                      scrollerStyle:_view.scrollview.scrollerStyle];\n\n        int width = (contentSize.width - [iTermPreferences intForKey:kPreferenceKeySideMargins]*2) / [_textview charWidth];\n        int height = (contentSize.height - [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins]*2) / [_textview lineHeight];\n        [_screen destructivelySetScreenWidth:width\n                                      height:height\n                                mutableState:mutableState];\n        [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionColumns: @(width),\n                                                        iTermVariableKeySessionRows: @(height) }];\n    }];\n\n    [_textview setDataSource:_screen];\n    [_textview setDelegate:self];\n    // useTransparency may have just changed.\n    [self invalidateBlend];\n    [_view.scrollview setDocumentView:_wrapper];\n    [_wrapper release];\n    [_view.scrollview setDocumentCursor:[iTermMouseCursor mouseCursorOfType:iTermMouseCursorTypeIBeam]];\n    [_view.scrollview setLineScroll:[_textview lineHeight]];\n    [_view.scrollview setPageScroll:2 * [_textview lineHeight]];\n    [_view.scrollview setHasVerticalScroller:[parent scrollbarShouldBeVisible]];\n\n    _antiIdleCode = 0;\n    [_antiIdleTimer invalidate];\n    _antiIdleTimer = nil;\n    _newOutput = NO;\n    [_view updateScrollViewFrame];\n    [self useTransparencyDidChange];\n\n    [self updateMetalDriver];\n\n    return YES;\n}\n\n- (BOOL)tryToAttachToServerWithProcessId:(pid_t)serverPid\n                                     tty:(NSString *)tty {\n    if (![iTermAdvancedSettingsModel runJobsInServers]) {\n        DLog(@\"Failing to attach because run jobs in servers is off\");\n        return NO;\n    }\n    DLog(@\"Try to attach...\");\n    if ([_shell tryToAttachToServerWithProcessId:serverPid tty:tty]) {\n        DLog(@\"Success, attached.\");\n        return YES;\n    } else {\n        DLog(@\"Failed to attach\");\n        return NO;\n    }\n}\n\n- (BOOL)tryToAttachToMultiserverWithRestorationIdentifier:(NSDictionary *)restorationIdentifier {\n    const iTermJobManagerAttachResults results = [_shell tryToAttachToMultiserverWithRestorationIdentifier:restorationIdentifier];\n    if (results & iTermJobManagerAttachResultsRegistered) {\n        DLog(@\"Registered\");\n    } else {\n        DLog(@\"Attached to multiserver. Not registered.\");\n    }\n    if (results & iTermJobManagerAttachResultsAttached) {\n        DLog(@\"Success, attached.\");\n        return YES;\n    } else {\n        DLog(@\"Failed to attach\");\n        return NO;\n    }\n}\n\n// Note: this async code path is taken by orphan adoption.\n- (void)attachToServer:(iTermGeneralServerConnection)serverConnection\n            completion:(void (^)(void))completion {\n    if ([iTermAdvancedSettingsModel runJobsInServers]) {\n        DLog(@\"Attaching to a server...\");\n        [_shell attachToServer:serverConnection completion:^(iTermJobManagerAttachResults results) {\n            if (!(results & iTermJobManagerAttachResultsAttached)) {\n                [self brokenPipe];\n            }\n            [self->_shell.winSizeController setGridSize:_screen.size\n                                               viewSize:_screen.viewSize\n                                            scaleFactor:self.backingScaleFactor];\n            if (_jiggleUponAttach) {\n                [_shell.winSizeController forceJiggle];\n            }\n            completion();\n        }];\n    } else {\n        DLog(@\"Can't attach to a server when runJobsInServers is off.\");\n    }\n}\n\n- (void)didChangeScreen:(CGFloat)scaleFactor {\n    [self->_shell.winSizeController setGridSize:_screen.currentGrid.size\n                                       viewSize:_screen.viewSize\n                                    scaleFactor:scaleFactor];\n}\n\n- (void)setSize:(VT100GridSize)size {\n    ITBetaAssert(size.width > 0, @\"Nonpositive width %d\", size.width);\n    ITBetaAssert(size.height > 0, @\"Nonpositive height %d\", size.height);\n    if (size.width <= 0) {\n        size.width = 1;\n    }\n    if (size.height <= 0) {\n        size.height = 1;\n    }\n    _savedGridSize = size;\n    self.lastResize = [NSDate timeIntervalSinceReferenceDate];\n    DLog(@\"Set session %@ to %@\", self, VT100GridSizeDescription(size));\n    DLog(@\"Before, range of visible lines is %@\", VT100GridRangeDescription(_textview.rangeOfVisibleLines));\n\n    [_screen setSize:size];\n    // Sync so that we'll have an updated model as we go forward so that, for example, tail find\n    // will be sane.\n    [self sync];\n    if (!self.delegate || [self.delegate sessionShouldSendWindowSizeIOCTL:self]) {\n        [_shell.winSizeController setGridSize:size\n                                     viewSize:_screen.viewSize\n                                  scaleFactor:self.backingScaleFactor];\n    }\n    [_textview clearHighlights:NO];\n    [_textview updatePortholeFrames];\n    [[_delegate realParentWindow] invalidateRestorableState];\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf startTailFindIfVisible];\n    });\n    [self updateMetalDriver];\n    [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionColumns: @(_screen.width),\n                                                    iTermVariableKeySessionRows: @(_screen.height) }];\n}\n\n- (void)startTailFindIfVisible {\n    if (!_tailFindTimer &&\n        [_delegate sessionBelongsToVisibleTab]) {\n        [self beginContinuousTailFind];\n    }\n}\n\n- (Profile *)profileForSplit {\n    if ([iTermAdvancedSettingsModel useDivorcedProfileToSplit]) {\n        if (self.isDivorced) {\n            // NOTE: This counts on splitVertically:before:profile:targetSession: rewriting the GUID.\n            return self.profile;\n        }\n    }\n\n    // Get the profile this session was originally created with. But look it up from its GUID because\n    // it might have changed since it was copied into originalProfile when the profile was\n    // first created.\n    Profile *result = nil;\n    Profile *originalProfile = [self originalProfile];\n    if (originalProfile && originalProfile[KEY_GUID]) {\n        result = [[ProfileModel sharedInstance] bookmarkWithGuid:originalProfile[KEY_GUID]];\n    }\n\n    // If that fails, use the current profile.\n    if (!result) {\n        result = self.profile;\n    }\n\n    // I don't think that'll ever fail, but to be safe try using the original profile.\n    if (!result) {\n        result = originalProfile;\n    }\n\n    // I really don't think this'll ever happen, but there's always a default profile to fall back\n    // on.\n    if (!result) {\n        result = [[ProfileModel sharedInstance] defaultBookmark];\n    }\n\n    if (_conductor) {\n        result = [result dictionaryByMergingDictionary:@{\n            KEY_SSH_CONFIG: @{},\n            KEY_CUSTOM_COMMAND: kProfilePreferenceCommandTypeSSHValue,\n            KEY_COMMAND_LINE: _conductor.sshIdentity.commandLine }];\n    }\n    return result;\n}\n\n- (SSHIdentity *)sshIdentity {\n    return _conductor.sshIdentity;\n}\n\n- (NSArray<iTermSSHReconnectionInfo *> *)sshCommandLineSequence {\n    assert(_conductor);\n    NSMutableArray<iTermSSHReconnectionInfo *> *sequence = [NSMutableArray array];\n    iTermConductor *current = _conductor;\n    [sequence insertObject:current.reconnectionInfo atIndex:0];\n    while (current.parent) {\n        current = current.parent;\n        [sequence insertObject:current.reconnectionInfo atIndex:0];\n    }\n    return sequence;\n}\n\n- (void)setSplitSelectionMode:(SplitSelectionMode)mode move:(BOOL)move {\n    // TODO: It would be nice not to have to pass the session into the view. I\n    // can (kind of) live with it because the view just passes it through\n    // without knowing anything about it.\n    [[self view] setSplitSelectionMode:mode move:move session:self];\n}\n\n- (int)overUnder:(int)proposedSize inVerticalDimension:(BOOL)vertically {\n    int result = proposedSize;\n    if (vertically) {\n        if ([_view showTitle]) {\n            result -= [SessionView titleHeight];\n        }\n        if (_view.showBottomStatusBar) {\n            result -= iTermGetStatusBarHeight();\n        }\n        result -= [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins] * 2;\n        int iLineHeight = [_textview lineHeight];\n        if (iLineHeight == 0) {\n            return 0;\n        }\n        result %= iLineHeight;\n        if (result > iLineHeight / 2) {\n            result -= iLineHeight;\n        }\n        return result;\n    } else {\n        result -= [iTermPreferences intForKey:kPreferenceKeySideMargins] * 2;\n        int iCharWidth = [_textview charWidth];\n        if (iCharWidth == 0) {\n            return 0;\n        }\n        result %= iCharWidth;\n        if (result > iCharWidth / 2) {\n            result -= iCharWidth;\n        }\n    }\n    return result;\n}\n\n- (id<ProcessInfoProvider>)processInfoProvider {\n    if (!_conductor.framing) {\n        return [iTermProcessCache sharedInstance];\n    }\n    return _conductor.processInfoProvider;\n}\n\n- (id<SessionProcessInfoProvider>)sessionProcessInfoProvider {\n    if (!_conductor.framing) {\n        return _shell;\n    }\n    return _conductor.processInfoProvider;\n}\n\n- (NSArray<iTermProcessInfo *> *)processInfoForShellAndDescendants {\n    NSMutableArray<iTermProcessInfo *> *result = [NSMutableArray array];\n    if (_conductor) {\n        [result addObjectsFromArray:_conductor.transitiveProcesses];\n    }\n    pid_t thePid = [_shell pid];\n\n    [[iTermProcessCache sharedInstance] updateSynchronously];\n    iTermProcessInfo *info = [[iTermProcessCache sharedInstance] processInfoForPid:thePid];\n    if (!info) {\n        return result;\n    }\n\n    NSInteger levelsToSkip = 0;\n    if ([info.name isEqualToString:@\"login\"]) {\n        levelsToSkip++;\n    }\n\n    NSArray<iTermProcessInfo *> *allInfos = [info descendantsSkippingLevels:levelsToSkip];\n    [result addObjectsFromArray:allInfos];\n    return result;\n}\n\n- (NSArray<iTermTuple<NSString *, NSString *> *> *)childJobNameTuples {\n    NSArray<iTermProcessInfo *> *allInfos = [self processInfoForShellAndDescendants];\n    return [allInfos mapWithBlock:^id(iTermProcessInfo *info) {\n        if (!info.name) {\n            return nil;\n        }\n        return [iTermTuple tupleWithObject:info.name\n                                 andObject:info.argv0 ?: info.name];\n    }];\n}\n\n- (iTermPromptOnCloseReason *)promptOnCloseReason {\n    DLog(@\"entered\");\n    if (_exited) {\n        return [iTermPromptOnCloseReason noReason];\n    }\n    switch ([[_profile objectForKey:KEY_PROMPT_CLOSE] intValue]) {\n        case PROMPT_ALWAYS:\n            DLog(@\"prompt always\");\n            return [iTermPromptOnCloseReason profileAlwaysPrompts:_profile];\n\n        case PROMPT_NEVER:\n            DLog(@\"prompt never\");\n            return [iTermPromptOnCloseReason noReason];\n\n        case PROMPT_EX_JOBS: {\n            DLog(@\"Prompt ex jobs\");\n            if (self.isTmuxClient) {\n                DLog(@\"is tmux client\");\n                return [iTermPromptOnCloseReason tmuxClientsAlwaysPromptBecauseJobsAreNotExposed];\n            }\n            NSMutableArray<NSString *> *blockingJobs = [NSMutableArray array];\n            NSArray *jobsThatDontRequirePrompting = [_profile objectForKey:KEY_JOBS];\n            DLog(@\"jobs that don't require prompting: %@\", jobsThatDontRequirePrompting);\n            for (iTermTuple<NSString *, NSString *> *childNameTuple in [self childJobNameTuples]) {\n                DLog(@\"Check child %@\", childNameTuple);\n                if ([jobsThatDontRequirePrompting indexOfObject:childNameTuple.firstObject] == NSNotFound &&\n                    [jobsThatDontRequirePrompting indexOfObject:childNameTuple.secondObject] == NSNotFound) {\n                    DLog(@\"    not on the ignore list\");\n                    // This job is not in the ignore list.\n                    [blockingJobs addObject:childNameTuple.secondObject.lastPathComponent];\n                }\n            }\n            if (blockingJobs.count > 0) {\n                DLog(@\"Blocked by jobs: %@\", blockingJobs);\n                return [iTermPromptOnCloseReason profile:_profile blockedByJobs:blockingJobs];\n            } else {\n                // All jobs were in the ignore list.\n                return [iTermPromptOnCloseReason noReason];\n            }\n        }\n    }\n\n    // This shouldn't happen\n    return [iTermPromptOnCloseReason profileAlwaysPrompts:_profile];\n}\n\n- (NSSet<NSString *> *)jobsToIgnore {\n    NSArray<NSString *> *builtInJobsToIgnore = @[ @\"login\", @\"iTerm2\", @\"ShellLauncher\" ];\n    return [NSSet setWithArray:[[_profile objectForKey:KEY_JOBS] ?: @[] arrayByAddingObjectsFromArray:builtInJobsToIgnore]];\n}\n\n// A trivial process is one that's always running, like the user's shell. This\n// is used to decide if there should be a \"document edited\" indicator in the\n// window's close button.\n- (BOOL)processIsTrivial:(iTermProcessInfo *)info {\n    NSSet<NSString *> *ignoredNames = [self jobsToIgnore];\n    if ([ignoredNames containsObject:info.name]) {\n        return YES;\n    }\n    if ([info.commandLine hasPrefix:@\"-\"]) {\n        return YES;\n    }\n    if (!self.program) {\n        return NO;\n    }\n    NSString *const programType = [self programType];\n    if ([programType isEqualToString:kProgramTypeShellLauncher] ||\n        [programType isEqualToString:kProgramTypeCustomShell]) {\n        return info.parentProcessID == _shell.pid;\n    } else if ([programType isEqualToString:kProgramTypeCommand]) {\n        return info.processID == _shell.pid;\n    }\n    return NO;\n}\n\n- (BOOL)hasNontrivialJob {\n    DLog(@\"Checking for a nontrivial job...\");\n    pid_t thePid = [_shell pid];\n    iTermProcessInfo *rootInfo = [self.processInfoProvider processInfoForPid:thePid];\n    if (!rootInfo) {\n        return NO;\n    }\n    // ShellLauncher --launch_shell could be a child job temporarily.\n    NSSet<NSString *> *jobToIgnore = [self jobsToIgnore];\n    DLog(@\"Ignoring %@\", jobToIgnore);\n    __block BOOL result = NO;\n    [rootInfo enumerateTree:^(iTermProcessInfo *info, BOOL *stop) {\n        if ([self processIsTrivial:info]) {\n            return;\n        }\n        if ([jobToIgnore containsObject:info.name]) {\n            return;\n        }\n        DLog(@\"Process with name %@ and command line %@ is nontrivial\", info.name, info.commandLine);\n        result = YES;\n        *stop = YES;\n    }];\n    DLog(@\"Result is %@\", @(result));\n    return result;\n}\n\n- (BOOL)shouldSetCtype {\n    return ![iTermAdvancedSettingsModel doNotSetCtype];\n}\n\n- (NSString *)sessionId {\n    return [NSString stringWithFormat:@\"w%dt%dp%lu:%@\",\n            [[_delegate realParentWindow] number],\n            _delegate.tabNumberForItermSessionId,\n            [_delegate sessionPaneNumber:self],\n            self.guid];\n}\n\n- (void)didMoveSession {\n    // TODO: Is it really desirable to update this? It'll get out of sync with the environment variable & autolog filename.\n    [self setTermIDIfPossible];\n}\n\n- (void)didInitializeSessionWithName:(NSString *)name {\n    [self.variablesScope setValue:name forVariableNamed:iTermVariableKeySessionAutoNameFormat];\n}\n\n- (void)profileNameDidChangeTo:(NSString *)name {\n    NSString *autoNameFormat = [self.variablesScope valueForVariableName:iTermVariableKeySessionAutoNameFormat] ?: name;\n    const BOOL isChangeToLocalName = (self.isDivorced &&\n                                      [_overriddenFields containsObject:KEY_NAME]);\n    const BOOL haveAutoNameFormatOverride = ([self.variablesScope valueForVariableName:iTermVariableKeySessionIconName] != nil ||\n                                             [self.variablesScope valueForVariableName:iTermVariableKeySessionTriggerName] != nil);\n    if (isChangeToLocalName || !haveAutoNameFormatOverride) {\n        // Profile name changed, local name not overridden, and no icon/trigger name to take precedence.\n        autoNameFormat = name;\n    }\n\n    NSString *profileName = nil;\n    if (![_overriddenFields containsObject:KEY_NAME]) {\n        profileName = _originalProfile[KEY_NAME];\n    } else {\n        profileName = [[ProfileModel sharedInstance] bookmarkWithGuid:_profile[KEY_ORIGINAL_GUID]][KEY_NAME];\n        if (!profileName) {\n            // Not sure how this would happen\n            profileName = [self.variablesScope valueForVariableName:iTermVariableKeySessionProfileName];\n        }\n    }\n    [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionAutoNameFormat: autoNameFormat ?: [NSNull null],\n                                                    iTermVariableKeySessionProfileName: profileName ?: [NSNull null] }];\n}\n\n- (void)profileDidChangeToProfileWithName:(NSString *)name {\n    [self profileNameDidChangeTo:name];\n}\n\n- (void)computeArgvForCommand:(NSString *)command\n                substitutions:(NSDictionary *)substitutions\n                   completion:(void (^)(NSArray<NSString *> *))completion {\n    NSString *program = [command stringByPerformingSubstitutions:substitutions];\n    NSArray *components = [program componentsInShellCommand];\n    NSArray *arguments;\n    if (components.count > 0) {\n        program = components[0];\n        arguments = [components subarrayWithRange:NSMakeRange(1, components.count - 1)];\n    } else {\n        arguments = @[];\n    }\n    completion([@[ program ] arrayByAddingObjectsFromArray:arguments ]);\n}\n\n- (NSDictionary *)environmentForNewJobFromEnvironment:(NSDictionary *)environment\n                                        substitutions:(NSDictionary *)substitutions {\n    DLog(@\"environmentForNewJobFromEnvironment:%@ substitutions:%@\",\n         environment, substitutions);\n    NSMutableDictionary *env = environment ? [[environment mutableCopy] autorelease] : [NSMutableDictionary dictionary];\n    if (env[TERM_ENVNAME] == nil) {\n        env[TERM_ENVNAME] = _termVariable;\n    }\n    if (env[COLORFGBG_ENVNAME] == nil && _colorFgBgVariable != nil) {\n        env[COLORFGBG_ENVNAME] = _colorFgBgVariable;\n    }\n    if ([iTermAdvancedSettingsModel setCookie]) {\n        self.cookie = [[iTermWebSocketCookieJar sharedInstance] randomStringForCookie];\n        env[@\"ITERM2_COOKIE\"] = self.cookie;\n    }\n\n    if ([iTermAdvancedSettingsModel addUtilitiesToPATH]) {\n        NSString *path = env[PATH_ENVNAME] ?: [NSString stringWithUTF8String:_PATH_DEFPATH];\n        NSArray *pathComponents = [path componentsSeparatedByString:@\":\"] ?: @[];\n        pathComponents = [pathComponents arrayByAddingObject:[iTermPathToSSH() stringByDeletingLastPathComponent]];\n        path = [pathComponents componentsJoinedByString:@\":\"];\n        env[PATH_ENVNAME] = path;\n    }\n\n    DLog(@\"Begin locale logic\");\n    switch ([iTermProfilePreferences unsignedIntegerForKey:KEY_SET_LOCALE_VARS inProfile:_profile]) {\n        case iTermSetLocalVarsModeDoNotSet:\n            break;\n        case iTermSetLocalVarsModeCustom: {\n            NSString *lang = [iTermProfilePreferences stringForKey:KEY_CUSTOM_LOCALE inProfile:_profile];\n            if (lang.length) {\n                env[@\"LANG\"] = lang;\n            }\n            break;\n        }\n        case iTermSetLocalVarsModeSetAutomatically: {\n            DLog(@\"Setting locale vars...\");\n\n            iTermLocaleGuesser *localeGuesser = [[[iTermLocaleGuesser alloc] initWithEncoding:self.encoding] autorelease];\n            NSDictionary *localeVars = [localeGuesser dictionaryWithLANG];\n            DLog(@\"localeVars=%@\", localeVars);\n            if (!localeVars) {\n                // Failed to guess.\n                iTermLocalePrompt *prompt = [[[iTermLocalePrompt alloc] init] autorelease];\n                if (self.originalProfile.profileIsDynamic) {\n                    DLog(@\"Disable remember\");\n                    prompt.allowRemember = NO;\n                }\n                localeVars = [prompt requestLocaleFromUserForProfile:self.originalProfile[KEY_NAME] ?: @\"(Unnamed profile)\"\n                                                            inWindow:self.view.window];\n                DLog(@\"updated localeVars=%@\", localeVars);\n                NSString *lang = localeVars[@\"LANG\"];\n                if (prompt.remember && localeVars != nil && lang != nil) {\n                    DLog(@\"Save\");\n                    // User chose a locale and wants us to keep using it.\n                    [iTermProfilePreferences setObject:lang\n                                                forKey:KEY_CUSTOM_LOCALE\n                                             inProfile:self.originalProfile\n                                                 model:[self profileModel]];\n                    [iTermProfilePreferences setUnsignedInteger:iTermSetLocalVarsModeCustom\n                                                         forKey:KEY_SET_LOCALE_VARS\n                                                      inProfile:self.originalProfile\n                                                          model:self.profileModel];\n                    [[NSNotificationCenter defaultCenter] postNotificationName:kSessionProfileDidChange\n                                                                        object:self.originalProfile[KEY_GUID]];\n                }\n            }\n            if (!localeVars) {\n                DLog(@\"Using LC_CTYPE\");\n                localeVars = [localeGuesser dictionaryWithLC_CTYPE];\n            }\n            if (localeVars) {\n                DLog(@\"Merge %@\", localeVars);\n                [env it_mergeFrom:localeVars];\n            }\n        }\n    }\n    if ([iTermAdvancedSettingsModel shouldSetLCTerminal]) {\n        env[@\"LC_TERMINAL\"] = @\"iTerm2\";\n        env[@\"LC_TERMINAL_VERSION\"] = [[[NSBundle mainBundle] infoDictionary] objectForKey:@\"CFBundleShortVersionString\"];\n    }\n    if (env[PWD_ENVNAME] == nil && _sshState == iTermSSHStateNone) {\n        // Set \"PWD\"\n        env[PWD_ENVNAME] = [PWD_ENVVALUE stringByExpandingTildeInPath];\n        DLog(@\"env[%@] was nil. Set it to home directory: %@\", PWD_ENVNAME, env[PWD_ENVNAME]);\n    }\n\n    // Remove trailing slashes, unless the path is just \"/\"\n    NSString *trimmed = [env[PWD_ENVNAME] stringByTrimmingTrailingCharactersFromCharacterSet:[NSCharacterSet characterSetWithCharactersInString:@\"/\"]];\n    DLog(@\"Trimmed pwd %@ is %@\", env[PWD_ENVNAME], trimmed);\n    if (trimmed.length == 0 && _sshState == iTermSSHStateNone) {\n        trimmed = @\"/\";\n    }\n    DLog(@\"Set env[PWD] to trimmed value %@\", trimmed);\n    env[PWD_ENVNAME] = trimmed;\n\n    NSString *itermId = [self sessionId];\n    env[@\"ITERM_SESSION_ID\"] = itermId;\n    env[@\"TERM_PROGRAM_VERSION\"] = [[[NSBundle mainBundle] infoDictionary] objectForKey:@\"CFBundleShortVersionString\"];\n    env[@\"TERM_SESSION_ID\"] = itermId;\n    env[@\"TERM_PROGRAM\"] = @\"iTerm.app\";\n    env[@\"COLORTERM\"] = @\"truecolor\";\n    if ([iTermAdvancedSettingsModel shouldSetTerminfoDirs]) {\n        env[@\"TERMINFO_DIRS\"] = [@[self.customTerminfoDir, @\"/usr/share/terminfo\"] componentsJoinedByString:@\":\"];\n    }\n    if (_profile[KEY_NAME]) {\n        env[@\"ITERM_PROFILE\"] = [_profile[KEY_NAME] stringByPerformingSubstitutions:substitutions];\n    }\n    return env;\n}\n\n- (NSString *)customTerminfoDir {\n    return [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@\"terminfo\"];\n}\n\n- (void)arrangementWithName:(NSString *)arrangementName hasBadPWD:(NSString *)pwd {\n    if (![[iTermController sharedInstance] arrangementWithName:arrangementName\n                                            hasSessionWithGUID:_arrangementGUID\n                                                           pwd:pwd]) {\n        return;\n    }\n\n    [self.naggingController arrangementWithName:arrangementName\n                                  hasInvalidPWD:pwd\n                             forSessionWithGuid:_arrangementGUID];\n}\n\n- (void)startProgram:(NSString *)command\n                 ssh:(BOOL)ssh\n         environment:(NSDictionary *)environment\n         customShell:(NSString *)customShell\n              isUTF8:(BOOL)isUTF8\n       substitutions:(NSDictionary *)substitutions\n         arrangement:(NSString *)arrangementName\n     fromArrangement:(BOOL)fromArrangement\n          completion:(void (^)(BOOL))completion {\n    DLog(@\"startProgram:%@ ssh:%@ environment:%@ customShell:%@ isUTF8:%@ substitutions:%@ arrangementName:%@ fromArrangement:%@, self=%@\",\n         command,\n         @(ssh),\n         environment,\n         customShell,\n         @(isUTF8),\n         substitutions,\n         arrangementName,\n         @(fromArrangement),\n         self);\n    _temporarilySuspendOffscreenMarkAlerts = fromArrangement;\n    self.program = command;\n    self.customShell = customShell;\n    self.environment = environment ?: @{};\n    self.isUTF8 = isUTF8;\n    self.substitutions = substitutions ?: @{};\n    _sshState = ssh ? iTermSSHStateProfile : iTermSSHStateNone;\n    [self computeArgvForCommand:command substitutions:substitutions completion:^(NSArray<NSString *> *argv) {\n        DLog(@\"argv=%@\", argv);\n        NSDictionary *env = [self environmentForNewJobFromEnvironment:environment ?: @{} substitutions:substitutions];\n        [self fetchAutoLogFilenameWithCompletion:^(NSString * _Nonnull autoLogFilename) {\n            [_logging stop];\n            [_logging autorelease];\n            _logging = nil;\n            [[self loggingHelper] setPath:autoLogFilename\n                                  enabled:autoLogFilename != nil\n                                    style:iTermLoggingStyleFromUserDefaultsValue([iTermProfilePreferences unsignedIntegerForKey:KEY_LOGGING_STYLE\n                                                                                                                      inProfile:self.profile])\n                        asciicastMetadata:[self asciicastMetadata]\n                                   append:nil];\n            if (env[PWD_ENVNAME] && arrangementName && _arrangementGUID) {\n                __weak __typeof(self) weakSelf = self;\n                [[iTermSlowOperationGateway sharedInstance] checkIfDirectoryExists:env[PWD_ENVNAME]\n                                                                        completion:^(BOOL exists) {\n                    if (exists) {\n                        return;\n                    }\n                    [weakSelf arrangementWithName:arrangementName\n                                        hasBadPWD:env[PWD_ENVNAME]];\n                }];\n            }\n            [self injectShellIntegrationWithEnvironment:env\n                                                   args:argv\n                                             completion:^(NSDictionary<NSString *, NSString *> *env,\n                                                          NSArray<NSString *> *argv) {\n                [_shell launchWithPath:argv[0]\n                             arguments:[argv subarrayFromIndex:1]\n                           environment:env\n                           customShell:customShell\n                              gridSize:_screen.size\n                              viewSize:_screen.viewSize\n                      maybeScaleFactor:_textview.window.backingScaleFactor\n                                isUTF8:isUTF8\n                            completion:^{\n                    [self sendInitialText];\n                    if (completion) {\n                        completion(YES);\n                    }\n                }];\n            }];\n        }];\n    }];\n}\n\n- (void)injectShellIntegrationWithEnvironment:(NSDictionary<NSString *, NSString *> *)env\n                                         args:(NSArray<NSString *> *)argv\n                                   completion:(void (^)(NSDictionary<NSString *, NSString *> *,\n                                                        NSArray<NSString *> *))completion {\n    if (![iTermProfilePreferences boolForKey:KEY_LOAD_SHELL_INTEGRATION_AUTOMATICALLY inProfile:self.profile]) {\n        completion(env, argv);\n        return;\n    }\n    ShellIntegrationInjector *injector = [ShellIntegrationInjector instance];\n    NSString *dir = NSBundle.shellIntegrationDirectory;\n    if (!dir) {\n        completion(env, argv);\n        return;\n    }\n    [injector modifyShellEnvironmentWithShellIntegrationDir:dir\n                                                        env:env\n                                                       argv:argv\n                                                 completion:completion];\n}\n\n- (void)setParentScope:(iTermVariableScope *)parentScope {\n    iTermVariableScope *scope = self.variablesScope;\n    assert(parentScope != scope);  // I'm almost sure this is impossible because how could you be your own parent?\n\n    // Remove existing variable (this is just paranoia! it shouldn't do anything)\n    [self.variablesScope setValue:nil forVariableNamed:iTermVariableKeySessionParent];\n\n    // Remove existing frame\n    [scope removeFrameWithName:iTermVariableKeySessionParent];\n    __block iTermVariables *variables = nil;\n    // Find root frame in parent and add it it as a frame to my scope\n    [parentScope.frames enumerateObjectsUsingBlock:^(iTermTuple<NSString *,iTermVariables *> * _Nonnull tuple, NSUInteger idx, BOOL * _Nonnull stop) {\n        if (tuple.firstObject) {\n            return;\n        }\n        variables = tuple.secondObject;\n        [scope addVariables:tuple.secondObject toScopeNamed:iTermVariableKeySessionParent];\n        *stop = YES;\n    }];\n\n    // Find non-root frames (e.g., tab) and add their variables as nonterminals to parentSession (becoming, e.g., parentSession.tab)\n    [parentScope.frames enumerateObjectsUsingBlock:^(iTermTuple<NSString *,iTermVariables *> * _Nonnull tuple, NSUInteger idx, BOOL * _Nonnull stop) {\n        if (!tuple.firstObject) {\n            return;\n        }\n        [variables setValue:tuple.secondObject forVariableNamed:tuple.firstObject];\n    }];\n}\n\n- (void)sendInitialText {\n    NSString *initialText = _profile[KEY_INITIAL_TEXT];\n    if (![initialText length]) {\n        return;\n    }\n    DLog(@\"Evaluate initial text %@\", initialText);\n\n    iTermExpressionEvaluator *evaluator =\n    [[[iTermExpressionEvaluator alloc] initWithStrictInterpolatedString:initialText\n                                                                  scope:self.variablesScope] autorelease];\n    [evaluator evaluateWithTimeout:5 completion:^(iTermExpressionEvaluator * _Nonnull evaluator) {\n        NSString *string = [NSString castFrom:evaluator.value];\n        if (!string) {\n            DLog(@\"Evaluation of %@ returned %@\", initialText, evaluator.value);\n            return;\n        }\n        DLog(@\"Write initial text %@\", string);\n        [self writeTaskNoBroadcast:string];\n        [self writeTaskNoBroadcast:@\"\\n\"];\n    }];\n}\n\n- (void)launchProfileInCurrentTerminal:(Profile *)profile\n                               withURL:(NSString *)url {\n    PseudoTerminal *term = [[iTermController sharedInstance] currentTerminal];\n    [iTermSessionLauncher launchBookmark:profile\n                              inTerminal:term\n                                 withURL:url\n                        hotkeyWindowType:iTermHotkeyWindowTypeNone\n                                 makeKey:NO\n                             canActivate:NO\n                      respectTabbingMode:NO\n                                   index:nil\n                                 command:nil\n                             makeSession:nil\n                          didMakeSession:nil\n                              completion:nil];\n}\n\n- (void)selectPaneLeftInCurrentTerminal {\n    [[[iTermController sharedInstance] currentTerminal] selectPaneLeft:nil];\n}\n\n- (void)selectPaneRightInCurrentTerminal {\n    [[[iTermController sharedInstance] currentTerminal] selectPaneRight:nil];\n}\n\n- (void)selectPaneAboveInCurrentTerminal {\n    [[[iTermController sharedInstance] currentTerminal] selectPaneUp:nil];\n}\n\n- (void)selectPaneBelowInCurrentTerminal {\n    [[[iTermController sharedInstance] currentTerminal] selectPaneDown:nil];\n}\n\n- (void)_maybeWarnAboutShortLivedSessions {\n    if ([iTermApplication.sharedApplication delegate].isAppleScriptTestApp) {\n        // The applescript test driver doesn't care about short-lived sessions.\n        return;\n    }\n    if (self.isSingleUseSession) {\n        return;\n    }\n    if (_tmuxMode == TMUX_CLIENT && (_tmuxController.detached || _tmuxController.detaching)) {\n        return;\n    }\n    if ([[NSDate date] timeIntervalSinceDate:_creationDate] < [iTermAdvancedSettingsModel shortLivedSessionDuration]) {\n        NSString* theName = [_profile objectForKey:KEY_NAME];\n        NSString *guid = _profile[KEY_GUID];\n        if (_originalProfile && [_originalProfile[KEY_GUID] length]) {\n            // Divorced sessions should use the original session's GUID to determine\n            // if a warning is appropriate.\n            guid = _originalProfile[KEY_GUID];\n        }\n        if ([self.profile[KEY_CUSTOM_COMMAND] isEqual:kProfilePreferenceCommandTypeLoginShellValue]) {\n            // Not a custom command. Does the user's shell not exist maybe?\n            NSString *shell = [iTermOpenDirectory userShell];\n            Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:self.profile[KEY_GUID]];\n            if (!self.isDivorced &&\n                shell &&\n                profile != nil &&\n                !profile.profileIsDynamic &&\n                ![[NSFileManager defaultManager] fileExistsAtPath:shell]) {\n                NSString *theKey = [NSString stringWithFormat:@\"ShellDoesNotExist_%@\", guid];\n                NSString *theTitle = [NSString stringWithFormat:\n                                      @\"The shell for this account, \u201c%@\u201d, does not exist. Change the profile to use /bin/zsh instead?\",\n                                      shell];\n                const iTermWarningSelection selection =\n                [iTermWarning showWarningWithTitle:theTitle\n                                           actions:@[ @\"OK\", @\"Cancel\" ]\n                                        identifier:theKey\n                                       silenceable:kiTermWarningTypePermanentlySilenceable\n                                            window:self.view.window];\n                if (selection == kiTermWarningSelection0) {\n                    NSDictionary *change = @{\n                        KEY_CUSTOM_COMMAND: kProfilePreferenceCommandTypeCustomShellValue,\n                        KEY_COMMAND_LINE: @\"/bin/zsh\"\n                    };\n                    [[ProfileModel sharedInstance] setObjectsFromDictionary:change\n                                                                  inProfile:profile];\n                    [[ProfileModel sharedInstance] flush];\n                    [[NSNotificationCenter defaultCenter] postNotificationName:kReloadAllProfiles\n                                                                        object:nil];\n                }\n                return;\n            }\n        }\n        NSString *theKey = [iTermPreferences warningIdentifierForNeverWarnAboutShortLivedSessions:guid];\n        NSString *theTitle = [NSString stringWithFormat:\n                              @\"A session ended very soon after starting. Check that the command \"\n                              @\"in profile \\\"%@\\\" is correct.\",\n                              theName];\n        [iTermWarning showWarningWithTitle:theTitle\n                                   actions:@[ @\"OK\" ]\n                                identifier:theKey\n                               silenceable:kiTermWarningTypePermanentlySilenceable\n                                    window:self.view.window];\n    }\n}\n\n- (iTermRestorableSession *)restorableSession {\n    iTermRestorableSession *restorableSession = [[[iTermRestorableSession alloc] init] autorelease];\n    [_delegate addSession:self toRestorableSession:restorableSession];\n    return restorableSession;\n}\n\n- (void)restartSession {\n    DLog(@\"Restart session %@\", self);\n    assert(self.isRestartable);\n    [_naggingController willRecycleSession];\n    if (_exited) {\n        [self replaceTerminatedShellWithNewInstance];\n    } else {\n        _shouldRestart = YES;\n        // We don't use a regular (SIGHUP) kill here because we must ensure\n        // servers get killed on user-initiated quit. If we just HUP the shell\n        // then the server won't notice until it becomes attached as an orphan\n        // on the next launch. See issue 6369.\n        [_shell killWithMode:iTermJobManagerKillingModeForce];\n    }\n}\n\n// Terminate a replay session but not the live session\n- (void)softTerminate {\n    _liveSession = nil;\n    [self terminate];\n}\n\n- (void)close {\n    [self.delegate sessionClose:self];\n}\n\n// Request that the session close. It may or may not be undoable. Only undoable terminations support\n// \"restart\", which is done by first calling revive and then replaceTerminatedShellWithNewInstance.\n- (void)terminate {\n    DLog(@\"terminate called from %@\", [NSThread callStackSymbols]);\n    if ([[self textview] isFindingCursor]) {\n        [[self textview] endFindCursor];\n    }\n    if (_exited && !_shortLivedSingleUse) {\n        [self _maybeWarnAboutShortLivedSessions];\n    }\n    if (self.tmuxMode == TMUX_CLIENT) {\n        assert([_delegate tmuxWindow] >= 0);\n        [_tmuxController deregisterWindow:[_delegate tmuxWindow]\n                               windowPane:self.tmuxPane\n                                  session:self];\n        // This call to fitLayoutToWindows is necessary to handle the case where\n        // a small window closes and leaves behind a larger (e.g., fullscreen)\n        // window. We want to set the client size to that of the smallest\n        // remaining window.\n        int n = [[_delegate sessions] count];\n        if ([[_delegate sessions] indexOfObjectIdenticalTo:self] != NSNotFound) {\n            n--;\n        }\n        if (n == 0) {\n            // The last session in this tab closed so check if the client has\n            // changed size\n            DLog(@\"Last session in tab closed. Check if the client has changed size\");\n            [_tmuxController fitLayoutToWindows];\n        }\n        _tmuxStatusBarMonitor.active = NO;\n        [_tmuxStatusBarMonitor release];\n        _tmuxStatusBarMonitor = nil;\n\n        [self uninstallTmuxTitleMonitor];\n        [self uninstallTmuxForegroundJobMonitor];\n    } else if (self.tmuxMode == TMUX_GATEWAY) {\n        [_tmuxController detach];\n        [_tmuxGateway release];\n        _tmuxGateway = nil;\n    }\n    BOOL undoable = (![self isTmuxClient] &&\n                     !_shouldRestart &&\n                     !_synthetic &&\n                     ![[iTermController sharedInstance] applicationIsQuitting]);\n    self.tmuxMode = TMUX_NONE;\n    [_tmuxController release];\n    _hideAfterTmuxWindowOpens = NO;\n    _tmuxController = nil;\n    [self.variablesScope setValue:nil forVariableNamed:iTermVariableKeySessionTmuxClientName];\n    [self.variablesScope setValue:nil forVariableNamed:iTermVariableKeySessionTmuxPaneTitle];\n\n    // The source pane may have just exited. Dogs and cats living together!\n    // Mass hysteria!\n    [[MovePaneController sharedInstance] exitMovePaneMode];\n\n    // deregister from the notification center\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n\n    if (_liveSession) {\n        [_liveSession terminate];\n    }\n\n    DLog(@\"  terminate: exited = YES\");\n    [self setExited:YES];\n    [_view retain];  // hardstop and revive will release this.\n    if (undoable) {\n        [self makeTerminationUndoable];\n    } else {\n        [self hardStop];\n    }\n    [[iTermSessionHotkeyController sharedInstance] removeSession:self];\n\n    // final update of display. Do it async to avoid a join from a side effect.\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf updateDisplayBecause:@\"terminate session\"];\n    });\n\n    [[NSNotificationCenter defaultCenter] postNotificationName:iTermSessionWillTerminateNotification\n                                                        object:self];\n    [_delegate removeSession:self];\n\n    _screen.delegate = nil;\n    _screen.intervalTreeObserver = nil;\n\n    _screen.terminalEnabled = NO;\n    if (_view.findDriverDelegate == self) {\n        _view.findDriverDelegate = nil;\n    }\n\n    [_pasteHelper abort];\n\n    [[_delegate realParentWindow] sessionDidTerminate:self];\n\n    _delegate = nil;\n}\n\n- (void)setExited:(BOOL)exited {\n    _exited = exited;\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.exited = exited;\n    }];\n}\n\n- (void)makeTerminationUndoable {\n    _shell.paused = YES;\n    [_textview setDataSource:nil];\n    [_textview setDelegate:nil];\n    [self performSelector:@selector(hardStop)\n               withObject:nil\n               afterDelay:[iTermProfilePreferences intForKey:KEY_UNDO_TIMEOUT\n                                                   inProfile:_profile]];\n    // The analyzer complains that _view is leaked here, but the delayed perform to -hardStop above\n    // releases it. If it is canceled by -revive, then -revive autoreleases the view.\n    [[iTermController sharedInstance] addRestorableSession:[self restorableSession]];\n}\n\n// Not undoable. Kill the process. However, you can replace the terminated shell after this.\n- (void)hardStop {\n    [[iTermController sharedInstance] removeSessionFromRestorableSessions:self];\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [terminal.parser forceUnhookDCS:nil];\n    }];\n    [_view release];  // This balances a retain in -terminate.\n    [[self retain] autorelease];\n    [_shell stop];\n    _shell.delegate = nil;\n    [_textview setDataSource:nil];\n    [_textview setDelegate:nil];\n    [_textview removeFromSuperview];\n    if (_view.searchResultsMinimapViewDelegate == _textview.findOnPageHelper) {\n        _view.searchResultsMinimapViewDelegate = nil;\n    }\n    self.textview = nil;\n    _metalGlue.textView = nil;\n    [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionTerminatedNotification object:self];\n}\n\n- (void)jumpToLocationWhereCurrentStatusChanged {\n    if (_statusChangedAbsLine >= _screen.totalScrollbackOverflow) {\n        int line = _statusChangedAbsLine - _screen.totalScrollbackOverflow;\n        [_textview scrollLineNumberRangeIntoView:VT100GridRangeMake(line, 1)];\n        [_textview highlightMarkOnLine:line hasErrorCode:NO];\n    }\n}\n\n- (void)disinter {\n    _textview.dataSource = _screen;\n    _textview.delegate = self;\n}\n\n- (BOOL)revive {\n    if (_shell.paused) {\n        [NSObject cancelPreviousPerformRequestsWithTarget:self\n                                                 selector:@selector(hardStop)\n                                                   object:nil];\n        if (_shell.hasBrokenPipe) {\n            if (self.isRestartable) {\n                [self queueRestartSessionAnnouncement];\n            }\n        } else {\n            DLog(@\"  revive: exited=NO\");\n            [self setExited:NO];\n        }\n        _textview.dataSource = _screen;\n        _textview.delegate = self;\n        _screen.terminalEnabled = YES;\n        _screen.delegate = self;\n        if ([iTermAdvancedSettingsModel showLocationsInScrollbar] && [iTermAdvancedSettingsModel showMarksInScrollbar]) {\n            _screen.intervalTreeObserver = self;\n        }\n        _shell.paused = NO;\n        [_view setFindDriverDelegate:self];\n\n        NSDictionary *shortcutDictionary = [iTermProfilePreferences objectForKey:KEY_SESSION_HOTKEY inProfile:self.profile];\n        iTermShortcut *shortcut = [iTermShortcut shortcutWithDictionary:shortcutDictionary];\n        [[iTermSessionHotkeyController sharedInstance] setShortcut:shortcut forSession:self];\n\n        [_view autorelease];  // This balances a retain in -terminate prior to calling -makeTerminationUndoable\n        [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionRevivedNotification object:self];\n        return YES;\n    } else {\n        return NO;\n    }\n}\n\n// This does not handle tmux properly. Any writing to tmux should happen in a\n// caller. It does handle broadcasting to other sessions.\n- (void)writeTaskImpl:(NSString *)string\n             encoding:(NSStringEncoding)optionalEncoding\n        forceEncoding:(BOOL)forceEncoding\n         canBroadcast:(BOOL)canBroadcast\n            reporting:(BOOL)reporting {\n    const NSStringEncoding encoding = forceEncoding ? optionalEncoding : _screen.terminalEncoding;\n    if (gDebugLogging) {\n        NSArray *stack = [NSThread callStackSymbols];\n        DLog(@\"writeTaskImpl session=%@ encoding=%@ forceEncoding=%@ canBroadcast=%@ reporting=%@: called from %@\",\n             self, @(encoding), @(forceEncoding), @(canBroadcast), @(reporting), stack);\n        DLog(@\"writeTaskImpl string=%@\", string);\n    }\n    if (string.length == 0) {\n        DLog(@\"String length is 0\");\n        // Abort early so the surrogate hack works.\n        return;\n    }\n    if (canBroadcast && _screen.terminalSendReceiveMode && !self.isTmuxClient && !self.isTmuxGateway) {\n        // Local echo. Only for broadcastable text to avoid printing passwords from the password manager.\n        [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            [mutableState appendStringAtCursor:[string stringByMakingControlCharactersToPrintable]];\n        }];\n    }\n    // check if we want to send this input to all the sessions\n    if (canBroadcast && [[_delegate realParentWindow] broadcastInputToSession:self]) {\n        // Ask the parent window to write to the other tasks.\n        DLog(@\"Passing input to window to broadcast it. Won't send in this call.\");\n        [[_delegate realParentWindow] sendInputToAllSessions:string\n                                                    encoding:optionalEncoding\n                                               forceEncoding:forceEncoding];\n    } else if (!_exited) {\n        // Send to only this session\n        if (canBroadcast) {\n            // It happens that canBroadcast coincides with explicit user input. This is less than\n            // beautiful here, but in that case we want to turn off the bell and scroll to the\n            // bottom.\n            [self setBell:NO];\n            PTYScroller *verticalScroller = [_view.scrollview ptyVerticalScroller];\n            [verticalScroller setUserScroll:NO];\n        }\n        NSData *data = [self dataForInputString:string usingEncoding:encoding];\n        if (_conductor.queueWrites) {\n            if (!_sshWriteQueue) {\n                _sshWriteQueue = [[NSMutableData alloc] init];\n            }\n            [_sshWriteQueue appendData:data];\n            return;\n        }\n        if (_screen.sendingIsBlocked && !reporting) {\n            DLog(@\"Defer write of %@\", [data stringWithEncoding:NSUTF8StringEncoding]);\n            if (!_dataQueue) {\n                _dataQueue = [[NSMutableArray alloc] init];\n            }\n            [_dataQueue addObject:data];\n        } else {\n            DLog(@\"Write immediately: %@\", [data stringWithEncoding:NSUTF8StringEncoding]);\n            [self writeData:data];\n        }\n    }\n}\n\n- (void)writeData:(NSData *)data {\n    const char *bytes = data.bytes;\n    BOOL newline = NO;\n    for (NSUInteger i = 0; i < data.length; i++) {\n        DLog(@\"Write byte 0x%02x (%c)\", (((int)bytes[i]) & 0xff), bytes[i]);\n        if (bytes[i] == '\\r' || bytes[i] == '\\n') {\n            newline = YES;\n        }\n    }\n    if (newline) {\n        _activityInfo.lastNewline = [NSDate it_timeSinceBoot];\n    }\n    if (!_reportingFocus) {\n        self.lastNonFocusReportingWrite = [NSDate date];\n    }\n    [_shell writeTask:data];\n}\n\n// Convert the string to the requested encoding. If the string is a lone surrogate, deal with it by\n// saving the high surrogate and then combining it with a subsequent low surrogate.\n- (NSData *)dataForInputString:(NSString *)string usingEncoding:(NSStringEncoding)encoding {\n    NSData *data = [string dataUsingEncoding:encoding allowLossyConversion:YES];\n    if (data) {\n        _shell.pendingHighSurrogate = 0;\n        return data;\n    }\n    if (string.length != 1) {\n        _shell.pendingHighSurrogate = 0;\n        return nil;\n    }\n\n    const unichar c = [string characterAtIndex:0];\n    if (IsHighSurrogate(c)) {\n        _shell.pendingHighSurrogate = c;\n        DLog(@\"Detected high surrogate 0x%x\", (int)c);\n        return nil;\n    } else if (IsLowSurrogate(c) && _shell.pendingHighSurrogate) {\n        DLog(@\"Detected low surrogate 0x%x with pending high surrogate 0x%x\", (int)c, (int)_shell.pendingHighSurrogate);\n        unichar chars[2] = { _shell.pendingHighSurrogate, c };\n        _shell.pendingHighSurrogate = 0;\n        NSString *composite = [NSString stringWithCharacters:chars length:2];\n        return [composite dataUsingEncoding:encoding allowLossyConversion:YES];\n    }\n\n    _shell.pendingHighSurrogate = 0;\n    return nil;\n}\n\n- (void)writeTaskNoBroadcast:(NSString *)string {\n    [self writeTaskNoBroadcast:string encoding:_screen.terminalEncoding forceEncoding:NO reporting:NO];\n}\n\n- (void)writeTaskNoBroadcast:(NSString *)string\n                    encoding:(NSStringEncoding)encoding\n               forceEncoding:(BOOL)forceEncoding\n                   reporting:(BOOL)reporting {\n    if (_conductor.handlesKeystrokes) {\n        [_conductor sendKeys:[string dataUsingEncoding:encoding]];\n        return;\n    } else if (self.tmuxMode == TMUX_CLIENT) {\n        // tmux doesn't allow us to abuse the encoding, so this can cause the wrong thing to be\n        // sent (e.g., in mouse reporting).\n        [[_tmuxController gateway] sendKeys:string\n                               toWindowPane:self.tmuxPane];\n        return;\n    }\n    [self writeTaskImpl:string encoding:encoding forceEncoding:forceEncoding canBroadcast:NO reporting:reporting];\n}\n\n- (void)performTmuxCommand:(NSString *)command {\n    [self.tmuxController.gateway sendCommand:command\n                              responseTarget:nil\n                            responseSelector:NULL];\n}\n\n- (void)setTmuxController:(TmuxController *)tmuxController {\n    [_tmuxController autorelease];\n    _tmuxController = [tmuxController retain];\n    NSDictionary<NSString *, NSString *> *dict = [tmuxController userVarsForPane:self.tmuxPane];\n    for (NSString *key in dict) {\n        if (![key hasPrefix:@\"user.\"]) {\n            continue;\n        }\n        [self.variablesScope setValue:dict[key] forVariableNamed:key];\n    }\n}\n\n- (void)handleKeypressInTmuxGateway:(NSEvent *)event {\n    const unichar unicode = [event.characters length] > 0 ? [event.characters characterAtIndex:0] : 0;\n    [self handleCharacterPressedInTmuxGateway:unicode];\n}\n\n- (void)handleCharacterPressedInTmuxGateway:(unichar)unicode {\n    if (unicode == 27) {\n        [self tmuxDetach];\n    } else if (unicode == 'L') {\n        _tmuxGateway.tmuxLogging = !_tmuxGateway.tmuxLogging;\n        [self printTmuxMessage:[NSString stringWithFormat:@\"tmux logging %@\", (_tmuxGateway.tmuxLogging ? @\"on\" : @\"off\")]];\n    } else if (unicode == 'C') {\n        NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n        alert.messageText = @\"Enter command to send tmux:\";\n        [alert addButtonWithTitle:@\"OK\"];\n        [alert addButtonWithTitle:@\"Cancel\"];\n        NSTextField *tmuxCommand = [[[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, 200, 24)] autorelease];\n        [tmuxCommand setEditable:YES];\n        [tmuxCommand setSelectable:YES];\n        [alert setAccessoryView:tmuxCommand];\n        [alert layout];\n        [[alert window] makeFirstResponder:tmuxCommand];\n        if ([alert runModal] == NSAlertFirstButtonReturn && [[tmuxCommand stringValue] length]) {\n            [self printTmuxMessage:[NSString stringWithFormat:@\"Run command \\\"%@\\\"\", [tmuxCommand stringValue]]];\n            [_tmuxGateway sendCommand:[tmuxCommand stringValue]\n                       responseTarget:self\n                     responseSelector:@selector(printTmuxCommandOutputToScreen:)];\n        }\n    } else if (unicode == 'X') {\n        [self forceTmuxDetach];\n    }\n}\n\n- (void)forceTmuxDetach {\n    switch (self.tmuxMode) {\n        case TMUX_GATEWAY:\n            [self printTmuxMessage:@\"Exiting tmux mode, but tmux client may still be running.\"];\n            [self tmuxHostDisconnected:[[_tmuxGateway.dcsID copy] autorelease]];\n            return;\n        case TMUX_NONE:\n            return;\n        case TMUX_CLIENT:\n            [self.tmuxGatewaySession forceTmuxDetach];\n            return;\n    }\n}\n\n- (void)writeLatin1EncodedData:(NSData *)data broadcastAllowed:(BOOL)broadcast reporting:(BOOL)reporting {\n    // `data` contains raw bytes we want to pass through. I believe Latin-1 is the only encoding that\n    // won't perform any transformation when converting from data to string. This is needed because\n    // sometimes the user wants to send particular bytes regardless of the encoding (e.g., the\n    // \"send hex codes\" keybinding action, or certain mouse reporting modes that abuse encodings).\n    // This won't work for non-UTF-8 data with tmux.\n    NSString *string = [[[NSString alloc] initWithData:data encoding:NSISOLatin1StringEncoding] autorelease];\n    if (broadcast) {\n        [self writeTask:string encoding:NSISOLatin1StringEncoding forceEncoding:YES reporting:reporting];\n    } else {\n        [self writeTaskNoBroadcast:string encoding:NSISOLatin1StringEncoding forceEncoding:YES reporting:reporting];\n    }\n}\n\n- (void)writeStringWithLatin1Encoding:(NSString *)string {\n    [self writeTask:string encoding:NSISOLatin1StringEncoding forceEncoding:YES reporting:NO];\n}\n\n- (void)writeTask:(NSString *)string {\n    [self writeTask:string encoding:_screen.terminalEncoding forceEncoding:NO reporting:NO];\n}\n\n// If forceEncoding is YES then optionalEncoding will be used regardless of the session's preferred\n// encoding. If it is NO then the preferred encoding is used. This is necessary because this method\n// might send the string off to the window to get broadcast to other sessions which might have\n// different encodings.\n- (void)writeTask:(NSString *)string\n         encoding:(NSStringEncoding)optionalEncoding\n    forceEncoding:(BOOL)forceEncoding\n        reporting:(BOOL)reporting {\n    NSStringEncoding encoding = forceEncoding ? optionalEncoding : _screen.terminalEncoding;\n    if (self.tmuxMode == TMUX_CLIENT || _conductor.handlesKeystrokes) {\n        [self setBell:NO];\n        if ([[_delegate realParentWindow] broadcastInputToSession:self]) {\n            [[_delegate realParentWindow] sendInputToAllSessions:string\n                                                        encoding:optionalEncoding\n                                                   forceEncoding:forceEncoding];\n        } else if (_conductor.handlesKeystrokes) {\n            [_conductor sendKeys:[string dataUsingEncoding:encoding]];\n        } else {\n            assert(self.tmuxMode == TMUX_CLIENT);\n            [[_tmuxController gateway] sendKeys:string\n                                   toWindowPane:self.tmuxPane];\n        }\n        PTYScroller* ptys = (PTYScroller*)[_view.scrollview verticalScroller];\n        [ptys setUserScroll:NO];\n        return;\n    } else if (self.tmuxMode == TMUX_GATEWAY) {\n        // Use keypresses for tmux gateway commands for development and debugging.\n        for (int i = 0; i < string.length; i++) {\n            unichar unicode = [string characterAtIndex:i];\n            [self handleCharacterPressedInTmuxGateway:unicode];\n        }\n        return;\n    }\n    self.currentMarkOrNotePosition = nil;\n    [self writeTaskImpl:string encoding:encoding forceEncoding:forceEncoding canBroadcast:YES reporting:reporting];\n}\n\n// This is run in PTYTask's thread. It parses the input here and then queues an async task to run\n// in the main thread to execute the parsed tokens.\n- (void)threadedReadTask:(char *)buffer length:(int)length {\n    [_screen threadedReadTask:buffer length:length];\n}\n\n- (BOOL)haveResizedRecently {\n    const NSTimeInterval kGracePeriodAfterResize = 0.25;\n    return [NSDate timeIntervalSinceReferenceDate] < _lastResize + kGracePeriodAfterResize;\n}\n\n- (void)setAllTriggersEnabled:(BOOL)enabled {\n    NSArray<NSDictionary *> *triggers = self.profile[KEY_TRIGGERS];\n    triggers = [triggers mapWithBlock:^id(NSDictionary *dict) {\n        return [dict dictionaryBySettingObject:@(!enabled) forKey:kTriggerDisabledKey];\n    }];\n    if (!triggers) {\n        return;\n    }\n    [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS: triggers }];\n}\n\n- (BOOL)anyTriggerCanBeEnabled {\n    NSArray<NSDictionary *> *triggers = self.profile[KEY_TRIGGERS];\n    return [triggers anyWithBlock:^BOOL(NSDictionary *dict) {\n        return [dict[kTriggerDisabledKey] boolValue];\n    }];\n}\n\n- (BOOL)anyTriggerCanBeDisabled {\n    NSArray<NSDictionary *> *triggers = self.profile[KEY_TRIGGERS];\n    return [triggers anyWithBlock:^BOOL(NSDictionary *dict) {\n        return ![dict[kTriggerDisabledKey] boolValue];\n    }];\n}\n\n- (NSArray<iTermTuple<NSString *, NSNumber *> *> *)triggerTuples {\n    NSArray<NSDictionary *> *triggers = self.profile[KEY_TRIGGERS];\n    return [triggers mapWithBlock:^id(NSDictionary *dict) {\n        return [iTermTuple tupleWithObject:dict[kTriggerRegexKey]\n                                 andObject:@(![dict[kTriggerDisabledKey] boolValue])];\n    }];\n}\n\n- (void)toggleTriggerEnabledAtIndex:(NSInteger)index {\n    NSMutableArray<NSDictionary *> *mutableTriggers = [[self.profile[KEY_TRIGGERS] mutableCopy] autorelease];\n    NSDictionary *triggerDict = mutableTriggers[index];\n    const BOOL disabled = [triggerDict[kTriggerDisabledKey] boolValue];\n    mutableTriggers[index] = [triggerDict dictionaryBySettingObject:@(!disabled) forKey:kTriggerDisabledKey];\n    [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS: mutableTriggers }];\n}\n\n- (void)appendBrokenPipeMessage:(NSString *)unpaddedMessage {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        NSString *const message = [NSString stringWithFormat:@\" %@ \", unpaddedMessage];\n        if (mutableState.cursorX != 1) {\n            [mutableState appendCarriageReturnLineFeed];\n        }\n        screen_char_t savedFgColor = [terminal foregroundColorCode];\n        screen_char_t savedBgColor = [terminal backgroundColorCode];\n        // This color matches the color used in BrokenPipeDivider.png.\n        [terminal setForeground24BitColor:[NSColor colorWithCalibratedRed:70.0/255.0\n                                                                    green:83.0/255.0\n                                                                     blue:246.0/255.0\n                                                                    alpha:1]];\n        [terminal setBackgroundColor:ALTSEM_DEFAULT\n                  alternateSemantics:YES];\n        int width = (mutableState.width - message.length) / 2;\n        if (width > 0) {\n            [mutableState appendNativeImageAtCursorWithName:@\"BrokenPipeDivider\"\n                                                      width:width];\n        }\n        [mutableState appendStringAtCursor:message];\n        if (width > 0) {\n            [mutableState appendNativeImageAtCursorWithName:@\"BrokenPipeDivider\"\n                                                      width:(mutableState.width - mutableState.cursorX + 1)];\n        }\n        [mutableState appendCarriageReturnLineFeed];\n        [terminal setForegroundColor:savedFgColor.foregroundColor\n                  alternateSemantics:savedFgColor.foregroundColorMode == ColorModeAlternate];\n        [terminal setBackgroundColor:savedBgColor.backgroundColor\n                  alternateSemantics:savedBgColor.backgroundColorMode == ColorModeAlternate];\n    }];\n}\n\n// This is called in the main thread when coprocesses write to a tmux client.\n- (void)tmuxClientWrite:(NSData *)data {\n    if (!self.isTmuxClient) {\n        return;\n    }\n    NSString *string = [[[NSString alloc] initWithData:data encoding:self.encoding] autorelease];\n    [self writeTask:string];\n}\n\n- (void)threadedTaskBrokenPipe {\n    DLog(@\"threaded task broken pipe\");\n    // Put the call to brokenPipe in the same queue as the token executor to avoid a race.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self brokenPipe];\n    });\n}\n\n- (void)taskDidChangePaused:(PTYTask *)task paused:(BOOL)paused {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.taskPaused = paused;\n    }];\n}\n\n- (void)taskMuteCoprocessDidChange:(PTYTask *)task hasMuteCoprocess:(BOOL)hasMuteCoprocess {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.hasMuteCoprocess = hasMuteCoprocess;\n    }];\n}\n\n- (void)taskDiedImmediately {\n    // Let initial creation finish, then report the broken pipe. This happens if the file descriptor\n    // server dies immediately.\n    [self performSelector:@selector(brokenPipe) withObject:nil afterDelay:0];\n}\n\n- (void)taskDidChangeTTY:(PTYTask *)task {\n    [self.variablesScope setValue:task.tty forVariableNamed:iTermVariableKeySessionTTY];\n}\n\n// Main thread\n- (void)taskDidRegister:(PTYTask *)task {\n    [self updateTTYSize];\n}\n\n- (void)tmuxDidDisconnect {\n    DLog(@\"tmuxDidDisconnect\");\n    if (_exited) {\n        return;\n    }\n    [self setExited:YES];\n    [self cleanUpAfterBrokenPipe];\n    [self appendBrokenPipeMessage:@\"tmux detached\"];\n    switch (self.endAction) {\n        case iTermSessionEndActionClose:\n            if ([_delegate sessionShouldAutoClose:self]) {\n                [_delegate softCloseSession:self];\n                return;\n            }\n            break;\n\n        case iTermSessionEndActionRestart:\n        case iTermSessionEndActionDefault:\n            if (_tmuxWindowClosingByClientRequest ||\n                [self.naggingController tmuxWindowsShouldCloseAfterDetach]) {\n                [_delegate softCloseSession:self];\n                return;\n            }\n            break;\n    }\n\n    [self updateDisplayBecause:@\"session ended\"];\n}\n\n- (void)cleanUpAfterBrokenPipe {\n    [self setExited:YES];\n    [_logging stop];\n    [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionTerminatedNotification object:self];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kCurrentSessionDidChange object:nil];\n    [_delegate updateLabelAttributes];\n}\n\n// Called when the file descriptor closes. If -terminate was already called this does nothing.\n// Otherwise, you can call replaceTerminatedShellWithNewInstance after this to restart the session.\n- (void)brokenPipe {\n    DLog(@\"  brokenPipe %@ task=%@\\n%@\", self, self.shell, [NSThread callStackSymbols]);\n    if (_exited) {\n        DLog(@\"  brokenPipe: Already exited\");\n        return;\n    }\n    // Ensure we don't leak the monoserver unix domain socket file descriptor.\n    [_shell killWithMode:iTermJobManagerKillingModeBrokenPipe];\n    if ([self shouldPostUserNotification] &&\n        [iTermProfilePreferences boolForKey:KEY_SEND_SESSION_ENDED_ALERT inProfile:self.profile]) {\n        [[iTermNotificationController sharedInstance] notify:@\"Session Ended\"\n                                             withDescription:[NSString stringWithFormat:@\"Session \\\"%@\\\" in tab #%d just terminated.\",\n                                                              [[self name] removingHTMLFromTabTitleIfNeeded],\n                                                              [_delegate tabNumber]]];\n    }\n\n    DLog(@\"  brokenPipe: set exited = YES\");\n    [self cleanUpAfterBrokenPipe];\n\n    if (_shouldRestart) {\n        _modeHandler.mode = iTermSessionModeDefault;\n        [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                 VT100ScreenMutableState *mutableState,\n                                                 id<VT100ScreenDelegate> delegate) {\n            [terminal resetByUserRequest:NO];\n            [self appendBrokenPipeMessage:@\"Session Restarted\"];\n            [self replaceTerminatedShellWithNewInstance];\n        }];\n        return;\n    }\n\n    if (_shortLivedSingleUse) {\n        [[iTermBuriedSessions sharedInstance] restoreSession:self];\n        [self appendBrokenPipeMessage:@\"Finished\"];\n        // restart is not respected here because it doesn't make sense and would make for an awful bug.\n        if (self.endAction == iTermSessionEndActionClose) {\n            [_delegate closeSession:self];\n        }\n        return;\n    }\n    if (self.tmuxMode == TMUX_GATEWAY) {\n        [self forceTmuxDetach];\n    }\n    [self appendBrokenPipeMessage:@\"Session Ended\"];\n    switch (self.endAction) {\n        case iTermSessionEndActionClose:\n            if ([_delegate sessionShouldAutoClose:self]) {\n                [_delegate closeSession:self];\n                return;\n            }\n            break;\n\n        case iTermSessionEndActionRestart:\n            if ([self isRestartable]) {\n                [self performSelector:@selector(maybeReplaceTerminatedShellWithNewInstance) withObject:nil afterDelay:1];\n                return;\n            }\n            break;\n\n        case iTermSessionEndActionDefault:\n            break;\n    }\n\n    // Offer to restart the session by rerunning its program.\n    if ([self isRestartable]) {\n        [self queueRestartSessionAnnouncement];\n    }\n    [self updateDisplayBecause:@\"session ended\"];\n}\n\n- (void)queueRestartSessionAnnouncement {\n    if ([iTermAdvancedSettingsModel suppressRestartAnnouncement]) {\n        return;\n    }\n    if (_shortLivedSingleUse) {\n        return;\n    }\n    [self.naggingController brokenPipe];\n}\n\n- (BOOL)isRestartable {\n    return _program != nil;\n}\n\n- (void)maybeReplaceTerminatedShellWithNewInstance {\n    // The check for screen.terminalEnabled is because after -terminate is called, it is no longer safe\n    // to replace the terminated shell with a new instance unless you first do -revive. When\n    // the terminal is disabled you can't write text to the screen.\n    // In other words: broken pipe -> close window -> timer calls this: nothing should happen\n    //                 broken pipe -> close window -> undo close -> timer calls this: work normally\n    if (_screen.terminalEnabled && self.isRestartable && _exited) {\n        [self replaceTerminatedShellWithNewInstance];\n    }\n}\n\n// NOTE: Not safe to call this after -terminate, unless you first call -revive. It *is* safe\n// to call this after -brokenPipe, provided -terminate wasn't already called.\n- (void)replaceTerminatedShellWithNewInstance {\n    assert(self.isRestartable);\n    assert(_exited);\n    _shouldRestart = NO;\n    DLog(@\"  replaceTerminatedShellWithNewInstance: exited <- NO\");\n    [self setExited:NO];\n    [_shell autorelease];\n    _shell = nil;\n    [_logging stop];\n\n    self.guid = [NSString uuid];\n    _shell = [[PTYTask alloc] init];\n    [_shell setDelegate:self];\n    [_shell.winSizeController setGridSize:_screen.size\n                                 viewSize:_screen.viewSize\n                              scaleFactor:self.backingScaleFactor];\n    [self resetForRelaunch];\n    __weak __typeof(self) weakSelf = self;\n    [self startProgram:_program\n                   ssh:_sshState == iTermSSHStateProfile\n           environment:_environment\n           customShell:_customShell\n                isUTF8:_isUTF8\n         substitutions:_substitutions\n           arrangement:nil\n       fromArrangement:NO\n            completion:^(BOOL ok) {\n        [weakSelf.delegate sessionDidRestart:self];\n    }];\n    [_naggingController willRecycleSession];\n    DLog(@\"  replaceTerminatedShellWithNewInstance: return with terminalEnabled=%@\", @(_screen.terminalEnabled));\n}\n\n- (void)lockScroll {\n    PTYScroller *scroller = [PTYScroller castFrom:self.view.scrollview.verticalScroller];\n    scroller.userScroll = YES;\n}\n\n- (NSSize)idealScrollViewSizeWithStyle:(NSScrollerStyle)scrollerStyle {\n    NSSize innerSize = NSMakeSize([_screen width] * [_textview charWidth] + [iTermPreferences intForKey:kPreferenceKeySideMargins] * 2,\n                                  [_screen height] * [_textview lineHeight] + [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins] * 2);\n    BOOL hasScrollbar = [[_delegate realParentWindow] scrollbarShouldBeVisible];\n    NSSize outerSize =\n    [PTYScrollView frameSizeForContentSize:innerSize\n                   horizontalScrollerClass:nil\n                     verticalScrollerClass:hasScrollbar ? [PTYScroller class] : nil\n                                borderType:NSNoBorder\n                               controlSize:NSControlSizeRegular\n                             scrollerStyle:scrollerStyle];\n    return outerSize;\n}\n\n- (BOOL)setScrollBarVisible:(BOOL)visible style:(NSScrollerStyle)style {\n    BOOL changed = NO;\n    if (self.view.scrollview.hasVerticalScroller != visible) {\n        changed = YES;\n    }\n    [[self.view scrollview] setHasVerticalScroller:visible];\n\n    if (self.view.scrollview.scrollerStyle != style) {\n        changed = YES;\n    }\n    [[self.view scrollview] setScrollerStyle:style];\n    [[self textview] updateScrollerForBackgroundColor];\n\n    if (changed) {\n        [self.view updateLayout];\n    }\n\n    return changed;\n}\n\n- (iTermKeyBindingAction *)_keyBindingActionForEvent:(NSEvent *)event {\n    // Check if we have a custom key mapping for this event\n    iTermKeyBindingAction *action =\n    [iTermKeyMappings actionForKeystroke:[iTermKeystroke withEvent:event]\n                             keyMappings:[[self profile] objectForKey:KEY_KEYBOARD_MAP]];\n    return action;\n}\n\n- (BOOL)hasTextSendingKeyMappingForEvent:(NSEvent *)event {\n    iTermKeyBindingAction *action = [self _keyBindingActionForEvent:event];\n    if (action.keyAction == KEY_ACTION_IGNORE) {\n        return YES;\n    }\n    return [action sendsText];\n}\n\n+ (BOOL)_recursiveSelectMenuWithSelector:(SEL)selector inMenu:(NSMenu *)menu {\n    for (NSMenuItem* item in [menu itemArray]) {\n        if (![item isEnabled] || [item isHidden]) {\n            continue;\n        }\n        if ([item hasSubmenu]) {\n            if ([PTYSession _recursiveSelectMenuWithSelector:selector inMenu:[item submenu]]) {\n                return YES;\n            }\n        } else if ([item action] == selector) {\n            [NSApp sendAction:[item action]\n                           to:[item target]\n                         from:item];\n            return YES;\n        }\n    }\n    return NO;\n}\n\n+ (BOOL)_recursiveSelectMenuItemWithTitle:(NSString*)title identifier:(NSString *)identifier inMenu:(NSMenu*)menu {\n    [menu update];\n\n    if (menu == [NSApp windowsMenu] &&\n        [[NSApp keyWindow] respondsToSelector:@selector(_moveToScreen:)] &&\n        [NSScreen it_stringLooksLikeUniqueKey:identifier]) {\n        NSScreen *screen = [NSScreen it_screenWithUniqueKey:identifier];\n        if (screen) {\n            [NSApp sendAction:@selector(_moveToScreen:) to:nil from:screen];\n            return YES;\n        }\n    }\n\n    for (NSMenuItem* item in [menu itemArray]) {\n        if (![item isEnabled] || [item isHidden]) {\n            continue;\n        }\n        if ([item hasSubmenu]) {\n            if ([PTYSession _recursiveSelectMenuItemWithTitle:title identifier:identifier inMenu:[item submenu]]) {\n                return YES;\n            }\n        }\n        if ([ITAddressBookMgr shortcutIdentifier:identifier title:title matchesItem:item]) {\n            if (item.hasSubmenu) {\n                return YES;\n            }\n            [NSApp sendAction:[item action]\n                           to:[item target]\n                         from:item];\n            return YES;\n        }\n    }\n    return NO;\n}\n\n+ (BOOL)handleShortcutWithoutTerminal:(NSEvent *)event {\n    // Check if we have a custom key mapping for this event\n    iTermKeyBindingAction *action = [iTermKeyMappings actionForKeystroke:[iTermKeystroke withEvent:event]\n                                                             keyMappings:[iTermKeyMappings globalKeyMap]];\n    if (!action) {\n        return NO;\n    }\n    return [PTYSession performKeyBindingAction:action event:event];\n}\n\n+ (void)selectMenuItemWithSelector:(SEL)theSelector {\n    if (![self _recursiveSelectMenuWithSelector:theSelector inMenu:[NSApp mainMenu]]) {\n        DLog(@\"Beep: failed to find menu item with selector %@\", NSStringFromSelector(theSelector));\n        NSBeep();\n    }\n}\n\n+ (void)selectMenuItem:(NSString*)theName {\n    NSArray *parts = [theName componentsSeparatedByString:@\"\\n\"];\n    NSString *title = parts.firstObject;\n    NSString *identifier = nil;\n    if (parts.count > 1) {\n        identifier = parts[1];\n    }\n    if (![self _recursiveSelectMenuItemWithTitle:title identifier:identifier inMenu:[NSApp mainMenu]]) {\n        DLog(@\"Beep: failed to find menu item with title %@ and identifier %@\", title, identifier);\n        NSBeep();\n    }\n}\n\n- (BOOL)willHandleEvent:(NSEvent *) theEvent\n{\n    return NO;\n}\n\n- (void)handleEvent:(NSEvent *)theEvent\n{\n}\n\n- (void)insertNewline:(id)sender {\n    [self insertText:@\"\\n\"];\n}\n\n- (void)insertTab:(id)sender {\n    [self insertText:@\"\\t\"];\n}\n\n- (void)moveUp:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyArrowUp:0] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)moveDown:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyArrowDown:0] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)moveLeft:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyArrowLeft:0] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)moveRight:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyArrowRight:0] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)pageUp:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyPageUp:0] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)pageDown:(id)sender {\n    [self writeLatin1EncodedData:[_screen.terminalOutput keyPageDown:0] broadcastAllowed:YES reporting:NO];\n}\n\n+ (NSString*)pasteboardString {\n    return [NSString stringFromPasteboard];\n}\n\n- (void)insertText:(NSString *)string {\n    if (_exited) {\n        return;\n    }\n\n    // Note: there used to be a weird special case where 0xa5 got converted to\n    // backslash. I think it was based on a misunderstanding of how encodings\n    // work and it should've been removed like 10 years ago.\n    if (string != nil) {\n        if (gDebugLogging) {\n            DebugLog([NSString stringWithFormat:@\"writeTask:%@\", string]);\n        }\n        [self writeTask:string];\n    }\n}\n\n- (NSData *)dataByRemovingControlCodes:(NSData *)data {\n    NSMutableData *output = [NSMutableData dataWithCapacity:[data length]];\n    const unsigned char *p = data.bytes;\n    int start = 0;\n    int i = 0;\n    for (i = 0; i < data.length; i++) {\n        if (p[i] < ' ' && p[i] != '\\n' && p[i] != '\\r' && p[i] != '\\t' && p[i] != 12) {\n            if (i > start) {\n                [output appendBytes:p + start length:i - start];\n            }\n            start = i + 1;\n        }\n    }\n    if (i > start) {\n        [output appendBytes:p + start length:i - start];\n    }\n    return output;\n}\n\n- (void)pasteString:(NSString *)aString {\n    [self pasteString:aString flags:0];\n}\n\n- (void)pasteStringWithoutBracketing:(NSString *)theString {\n    [self pasteString:theString flags:kPTYSessionPasteBracketingDisabled];\n}\n\n- (void)deleteBackward:(id)sender {\n    unsigned char p = 0x08; // Ctrl+H\n\n    [self writeLatin1EncodedData:[NSData dataWithBytes:&p length:1] broadcastAllowed:YES reporting:NO];\n}\n\n- (void)deleteForward:(id)sender {\n    unsigned char p = 0x7F; // DEL\n\n    [self writeLatin1EncodedData:[NSData dataWithBytes:&p length:1] broadcastAllowed:YES reporting:NO];\n}\n\n- (PTYScroller *)textViewVerticalScroller {\n    return (PTYScroller *)[_view.scrollview verticalScroller];\n}\n\n- (BOOL)textViewHasCoprocess {\n    return [_shell hasCoprocess];\n}\n\n- (void)textViewStopCoprocess {\n    [_shell stopCoprocess];\n}\n\n- (BOOL)shouldPostUserNotification {\n    if (!_screen.postUserNotifications) {\n        return NO;\n    }\n    if (_shortLivedSingleUse) {\n        return NO;\n    }\n    if (![_delegate sessionBelongsToVisibleTab]) {\n        return YES;\n    }\n    BOOL windowIsObscured =\n    ([[iTermController sharedInstance] terminalIsObscured:_delegate.realParentWindow]);\n    return (windowIsObscured);\n}\n\n- (BOOL)hasSelection {\n    return [_textview.selection hasSelection];\n}\n\n- (void)openSelection {\n    long long absLineNumber;\n    NSArray *subSelections = _textview.selection.allSubSelections;\n    if ([subSelections count]) {\n        iTermSubSelection *firstSub = subSelections[0];\n        absLineNumber = firstSub.absRange.coordRange.start.y;\n    } else {\n        absLineNumber = _textview.selection.liveRange.coordRange.start.y;\n    }\n    const long long overflow = _screen.totalScrollbackOverflow;\n    if (absLineNumber < overflow || absLineNumber - overflow > INT_MAX) {\n        return;\n    }\n    const int lineNumber = absLineNumber - overflow;\n\n    // TODO: Figure out if this is a remote host and download/open if that's the case.\n    NSString *workingDirectory = [_screen workingDirectoryOnLine:lineNumber];\n    NSString *selection = [_textview selectedText];\n    if (!selection.length) {\n        DLog(@\"Beep: no selection\");\n        NSBeep();\n        return;\n    }\n\n    [self open:selection workingDirectory:workingDirectory];\n}\n\n- (void)open:(NSString *)selection workingDirectory:(NSString *)workingDirectory {\n    iTermSemanticHistoryController *semanticHistoryController = _textview.semanticHistoryController;\n\n    // NOTE: The synchronous API is used here because this is a user-initiated action. We don't want\n    // things to change out from under us. It's ok to block the UI while waiting for disk access\n    // to complete.\n    NSString *rawFilename =\n    [semanticHistoryController pathOfExistingFileFoundWithPrefix:selection\n                                                          suffix:@\"\"\n                                                workingDirectory:workingDirectory\n                                            charsTakenFromPrefix:nil\n                                            charsTakenFromSuffix:nil\n                                                  trimWhitespace:YES];\n    if (rawFilename &&\n        ![[rawFilename stringByReplacingOccurrencesOfString:@\"//\" withString:@\"/\"] isEqualToString:@\"/\"]) {\n        NSString *lineNumber = nil;\n        NSString *columnNumber = nil;\n        NSString *cleanedup = [semanticHistoryController cleanedUpPathFromPath:rawFilename\n                                                                        suffix:nil\n                                                              workingDirectory:workingDirectory\n                                                           extractedLineNumber:&lineNumber\n                                                                  columnNumber:&columnNumber];\n        __weak __typeof(self) weakSelf = self;\n        [_textview openSemanticHistoryPath:cleanedup\n                             orRawFilename:rawFilename\n                                  fragment:nil\n                          workingDirectory:workingDirectory\n                                lineNumber:lineNumber\n                              columnNumber:columnNumber\n                                    prefix:selection\n                                    suffix:@\"\"\n                                completion:^(BOOL ok) {\n            if (!ok) {\n                [weakSelf tryOpenStringAsURL:selection];\n            }\n        }];\n        return;\n    }\n\n    [self tryOpenStringAsURL:selection];\n}\n\n- (void)textViewOpen:(NSString *)string\n    workingDirectory:(NSString *)folder\n          remoteHost:(id<VT100RemoteHostReading>)remoteHost {\n    // TODO: Open files on remote hosts when using ssh integration\n    if (remoteHost.isLocalhost) {\n        [self open:string workingDirectory:folder];\n    } else {\n        [self tryOpenStringAsURL:string];\n    }\n}\n\n- (void)tryOpenStringAsURL:(NSString *)selection {\n    // Try to open it as a URL.\n    NSURL *url =\n    [NSURL URLWithUserSuppliedString:[selection stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];\n    if (url) {\n        [[NSWorkspace sharedWorkspace] openURL:url];\n        return;\n    }\n\n    DLog(@\"Beep: bad url %@\", selection);\n    NSBeep();\n}\n\n- (void)setBell:(BOOL)flag {\n    if (flag != _bell) {\n        _bell = flag;\n        [_delegate setBell:flag];\n        if (_bell) {\n            if ([_textview keyIsARepeat] == NO &&\n                [self shouldPostUserNotification] &&\n                [iTermProfilePreferences boolForKey:KEY_SEND_BELL_ALERT inProfile:self.profile]) {\n                [[iTermNotificationController sharedInstance] notify:@\"Bell\"\n                                                     withDescription:[NSString stringWithFormat:@\"Session %@ #%d just rang a bell!\",\n                                                                      [[self name] removingHTMLFromTabTitleIfNeeded],\n                                                                      [_delegate tabNumber]]\n                                                         windowIndex:[self screenWindowIndex]\n                                                            tabIndex:[self screenTabIndex]\n                                                           viewIndex:[self screenViewIndex]];\n            }\n        }\n    }\n}\n\n- (NSString *)ansiColorsMatchingForeground:(NSDictionary *)fg\n                             andBackground:(NSDictionary *)bg\n                                inBookmark:(Profile *)aDict\n{\n    NSColor *fgColor;\n    NSColor *bgColor;\n    fgColor = [ITAddressBookMgr decodeColor:fg];\n    bgColor = [ITAddressBookMgr decodeColor:bg];\n\n    int bgNum = -1;\n    int fgNum = -1;\n    for(int i = 0; i < 16; ++i) {\n        NSString* key = [self amendedColorKey:[NSString stringWithFormat:KEYTEMPLATE_ANSI_X_COLOR, i]];\n        if ([fgColor isEqual:[ITAddressBookMgr decodeColor:[aDict objectForKey:key]]]) {\n            fgNum = i;\n        }\n        if ([bgColor isEqual:[ITAddressBookMgr decodeColor:[aDict objectForKey:key]]]) {\n            bgNum = i;\n        }\n    }\n\n    if (bgNum < 0 || fgNum < 0) {\n        if ([iTermAdvancedSettingsModel useColorfgbgFallback]) {\n            if ([fgColor brightnessComponent] > [bgColor brightnessComponent]) {\n                return @\"15;0\";\n            } else {\n                return @\"0;15\";\n            }\n        }\n        return nil;\n    }\n\n    return ([[NSString alloc] initWithFormat:@\"%d;%d\", fgNum, bgNum]);\n}\n\n- (void)loadInitialColorTableAndResetCursorGuide {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState loadInitialColorTable];\n    }];\n    [self resetCursorGuide];\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf markProfileInitialized];\n    });\n}\n\n- (void)resetCursorGuide {\n    _textview.highlightCursorLine = [iTermProfilePreferences boolForColorKey:KEY_USE_CURSOR_GUIDE\n                                                                        dark:[NSApp effectiveAppearance].it_isDark\n                                                                     profile:_profile];\n}\n\n- (void)markProfileInitialized {\n    DLog(@\"Mark profile initialized %@\", self);\n    _profileInitialized = YES;\n}\n\n- (NSColor *)tabColorInProfile:(NSDictionary *)profile {\n    const BOOL dark = _screen.colorMap.darkMode;\n    if ([iTermProfilePreferences boolForColorKey:KEY_USE_TAB_COLOR dark:dark profile:profile]) {\n        return [iTermProfilePreferences colorForKey:KEY_TAB_COLOR dark:dark profile:profile];\n    }\n    return nil;\n}\n\n- (void)setColorsFromPresetNamed:(NSString *)presetName {\n    iTermColorPreset *settings = [iTermColorPresets presetWithName:presetName];\n    if (!settings) {\n        return;\n    }\n    const BOOL presetUsesModes = settings[KEY_FOREGROUND_COLOR COLORS_LIGHT_MODE_SUFFIX] != nil;\n    for (NSString *colorName in [ProfileModel colorKeysWithModes:presetUsesModes]) {\n        iTermColorDictionary *colorDict = [settings iterm_presetColorWithName:colorName];\n        if (colorDict) {\n            [self setSessionSpecificProfileValues:@{ colorName: colorDict }];\n        }\n    }\n    [self setSessionSpecificProfileValues:@{ KEY_USE_SEPARATE_COLORS_FOR_LIGHT_AND_DARK_MODE: @(presetUsesModes) }];\n}\n\n- (void)sharedProfileDidChange\n{\n    NSDictionary *updatedProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:_originalProfile[KEY_GUID]];\n    if (!updatedProfile) {\n        return;\n    }\n    if (!self.isDivorced) {\n        [self setPreferencesFromAddressBookEntry:updatedProfile];\n        [self setProfile:updatedProfile];\n        return;\n    }\n\n    // Copy non-overridden fields over.\n    NSMutableDictionary *temp = [NSMutableDictionary dictionaryWithDictionary:_profile];\n    NSMutableArray *noLongerOverriddenFields = [NSMutableArray array];\n    NSMutableSet *keys = [NSMutableSet setWithArray:[updatedProfile allKeys]];\n    [keys addObjectsFromArray:[_profile allKeys]];\n    for (NSString *key in keys) {\n        NSObject *originalValue = updatedProfile[key];\n        NSObject *currentValue = _profile[key];\n        if ([_overriddenFields containsObject:key]) {\n            if ([originalValue isEqual:currentValue]) {\n                [noLongerOverriddenFields addObject:key];\n            }\n        } else {\n            if (!originalValue) {\n                DLog(@\"Unset %@ in session because it was removed from shared profile\", key);\n                [temp removeObjectForKey:key];\n            } else {\n                if (![originalValue isEqual:temp[key]]) {\n                    DLog(@\"Update session for key %@ from %@ -> %@\", key, temp[key], originalValue);\n                }\n                temp[key] = originalValue;\n            }\n        }\n    }\n\n    // For fields that are no longer overridden because the shared profile took on the same value\n    // as the sessions profile, remove those keys from overriddenFields.\n    for (NSString *key in noLongerOverriddenFields) {\n        DLog(@\"%p: %@ is no longer overridden because shared profile now matches session profile value of %@\",\n             self, key, temp[key]);\n        [_overriddenFields removeObject:key];\n    }\n    DLog(@\"After shared profile change overridden keys are: %@\", _overriddenFields);\n\n    // Update saved state.\n    [[ProfileModel sessionsInstance] setBookmark:temp withGuid:temp[KEY_GUID]];\n    [self setPreferencesFromAddressBookEntry:temp];\n    [self setProfile:temp];\n}\n\n- (void)sessionProfileDidChange {\n    if (!self.isDivorced) {\n        return;\n    }\n    NSDictionary *updatedProfile =\n    [[ProfileModel sessionsInstance] bookmarkWithGuid:_profile[KEY_GUID]];\n    if (!updatedProfile) {\n        // Can happen when replaying a recorded session.\n        return;\n    }\n\n    NSMutableSet *keys = [NSMutableSet setWithArray:[updatedProfile allKeys]];\n    [keys addObjectsFromArray:[_profile allKeys]];\n    for (NSString *aKey in keys) {\n        NSObject *sharedValue = _originalProfile[aKey];\n        NSObject *newSessionValue = updatedProfile[aKey];\n        BOOL isEqual = [newSessionValue isEqual:sharedValue];\n        BOOL isOverridden = [_overriddenFields containsObject:aKey];\n        if (!isEqual && !isOverridden) {\n            DLog(@\"%p: %@ is now overridden because %@ != %@\", self, aKey, newSessionValue, sharedValue);\n            [_overriddenFields addObject:aKey];\n        } else if (isEqual && isOverridden) {\n            DLog(@\"%p: %@ is no longer overridden because %@ == %@\", self, aKey, newSessionValue, sharedValue);\n            [_overriddenFields removeObject:aKey];\n        }\n    }\n    DLog(@\"After session profile change overridden keys are: %@\", _overriddenFields);\n    [self setPreferencesFromAddressBookEntry:updatedProfile];\n    [self setProfile:updatedProfile];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kSessionProfileDidChange\n                                                        object:_profile[KEY_GUID]];\n}\n\n- (BOOL)reloadProfile {\n    DLog(@\"Reload profile for %@\", self);\n    BOOL didChange = NO;\n    NSDictionary *sharedProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:_originalProfile[KEY_GUID]];\n    if (sharedProfile && ![sharedProfile isEqual:_originalProfile]) {\n        DLog(@\"Shared profile changed\");\n        [self sharedProfileDidChange];\n        didChange = YES;\n        [_originalProfile autorelease];\n        _originalProfile = [sharedProfile copy];\n    }\n\n    if (self.isDivorced) {\n        NSDictionary *sessionProfile = [[ProfileModel sessionsInstance] bookmarkWithGuid:_profile[KEY_GUID]];\n        if (![sessionProfile isEqual:_profile]) {\n            DLog(@\"Session profile changed\");\n            [self sessionProfileDidChange];\n            didChange = YES;\n        }\n    }\n\n    [self profileNameDidChangeTo:self.profile[KEY_NAME]];\n    return didChange;\n}\n\n- (void)loadColorsFromProfile:(Profile *)aDict {\n    const BOOL dark = (self.view.effectiveAppearance ?: [NSApp effectiveAppearance]).it_isDark;\n    NSDictionary<NSNumber *, NSString *> *keyMap = [self colorTableForProfile:aDict darkMode:dark];\n\n    NSMutableDictionary<NSNumber *, id> *colorTable =\n    [[[keyMap mapValuesWithBlock:^id(NSNumber *colorKey, NSString *profileKey) {\n        if ([profileKey isKindOfClass:[NSString class]]) {\n            return [iTermProfilePreferences colorForKey:profileKey\n                                                   dark:dark\n                                                profile:aDict] ?: [NSNull null];\n        } else {\n            return [NSNull null];\n        }\n    }] mutableCopy] autorelease];\n    [self load16ANSIColorsFromProfile:aDict darkMode:dark into:colorTable];\n    const BOOL didUseSelectedTextColor = [iTermProfilePreferences boolForKey:iTermAmendedColorKey(KEY_USE_SELECTED_TEXT_COLOR, self.profile, dark) inProfile:self.profile];\n    const BOOL willUseSelectedTextColor = [iTermProfilePreferences boolForKey:iTermAmendedColorKey(KEY_USE_SELECTED_TEXT_COLOR, aDict, dark) inProfile:aDict];\n\n    [_screen setColorsFromDictionary:colorTable];\n\n    if (didUseSelectedTextColor != willUseSelectedTextColor) {\n        [_textview updatePortholeColorsWithUseSelectedTextColor:willUseSelectedTextColor];\n    }\n    self.cursorGuideColor = [[iTermProfilePreferences objectForKey:iTermAmendedColorKey(KEY_CURSOR_GUIDE_COLOR, aDict, dark)\n                                                         inProfile:aDict] colorValueForKey:iTermAmendedColorKey(KEY_CURSOR_GUIDE_COLOR, aDict, dark)];\n    if (!_cursorGuideSettingHasChanged) {\n        _textview.highlightCursorLine = [iTermProfilePreferences boolForKey:iTermAmendedColorKey(KEY_USE_CURSOR_GUIDE, aDict, dark)\n                                                                  inProfile:aDict];\n    }\n\n    [self setSmartCursorColor:[iTermProfilePreferences boolForKey:iTermAmendedColorKey(KEY_SMART_CURSOR_COLOR, aDict, dark)\n                                                        inProfile:aDict]];\n\n    DLog(@\"set min contrast to %f using key %@\", [iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, aDict, dark)\n                                                                            inProfile:aDict], iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, aDict, dark));\n    [self setMinimumContrast:[iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, aDict, dark)\n                                                        inProfile:aDict]];\n}\n\n- (NSDictionary<NSNumber *, NSString *> *)colorTableForProfile:(Profile *)profile darkMode:(BOOL)dark {\n    NSString *(^k)(NSString *) = ^NSString *(NSString *baseKey) {\n        return iTermAmendedColorKey(baseKey, profile, dark);\n    };\n    const BOOL useUnderline = [iTermProfilePreferences boolForKey:k(KEY_USE_UNDERLINE_COLOR) inProfile:profile];\n    NSDictionary *keyMap = @{ @(kColorMapForeground): k(KEY_FOREGROUND_COLOR),\n                              @(kColorMapBackground): k(KEY_BACKGROUND_COLOR),\n                              @(kColorMapSelection): k(KEY_SELECTION_COLOR),\n                              @(kColorMapSelectedText): k(KEY_SELECTED_TEXT_COLOR),\n                              @(kColorMapBold): k(KEY_BOLD_COLOR),\n                              @(kColorMapLink): k(KEY_LINK_COLOR),\n                              @(kColorMapCursor): k(KEY_CURSOR_COLOR),\n                              @(kColorMapCursorText): k(KEY_CURSOR_TEXT_COLOR),\n                              @(kColorMapUnderline): (useUnderline ? k(KEY_UNDERLINE_COLOR) : [NSNull null])\n    };\n    return keyMap;\n}\n\n// Restore a color to the value in `profile`.\n- (NSDictionary<NSNumber *, id> *)resetColorWithKey:(int)colorKey\n                                        fromProfile:(Profile *)profile\n                                         profileKey:(NSString *)profileKey\n                                               dark:(BOOL)dark {\n    DLog(@\"resetColorWithKey:%d fromProfile:%@\", colorKey, profile[KEY_GUID]);\n    if (!profile) {\n        DLog(@\"No original profile\");\n        return @{};\n    }\n\n    NSColor *color = [iTermProfilePreferences colorForKey:profileKey\n                                                     dark:dark\n                                                  profile:profile];\n    if (!color) {\n        return @{};\n    }\n    if (profileKey) {\n        [self setSessionSpecificProfileValues:@{ profileKey: [color dictionaryValue] }];\n        return @{};\n    }\n    return @{ @(colorKey): color };\n}\n\n- (void)load16ANSIColorsFromProfile:(Profile *)aDict darkMode:(BOOL)dark into:(NSMutableDictionary<NSNumber *, id> *)dict {\n    for (int i = 0; i < 16; i++) {\n        [self loadANSIColor:i fromProfile:aDict darkMode:dark to:dict];\n    }\n}\n\n- (void)loadANSIColor:(int)i fromProfile:(Profile *)aDict darkMode:(BOOL)dark to:(NSMutableDictionary<NSNumber *, id> *)dict {\n    NSString *baseKey = [NSString stringWithFormat:KEYTEMPLATE_ANSI_X_COLOR, i];\n    NSString *profileKey = iTermAmendedColorKey(baseKey, aDict, dark);\n    NSColor *theColor = [ITAddressBookMgr decodeColor:aDict[profileKey]];\n    dict[@(kColorMap8bitBase + i)] = theColor ?: [NSNull null];\n}\n\n- (void)setPreferencesFromAddressBookEntry:(NSDictionary *)aePrefs {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [self reallySetPreferencesFromAddressBookEntry:aePrefs terminal:terminal];\n    }];\n}\n\n- (void)reallySetPreferencesFromAddressBookEntry:(NSDictionary *)aePrefs\n                                        terminal:(VT100Terminal *)terminal {\n    NSDictionary *aDict = aePrefs;\n\n    if (aDict == nil) {\n        DLog(@\"nil dict, use default\");\n        aDict = [[ProfileModel sharedInstance] defaultBookmark];\n    }\n    if (aDict == nil) {\n        DLog(@\"uh oh! no default dict!\");\n        return;\n    }\n    DLog(@\"%@: set prefs to address book entry:\\n%@\", self, aDict);\n\n    if ([self isTmuxClient] && ![_profile[KEY_NAME] isEqualToString:aePrefs[KEY_NAME]]) {\n        _tmuxTitleOutOfSync = YES;\n    }\n\n    [self loadColorsFromProfile:aDict];\n\n    // background image\n    [self setBackgroundImagePath:aDict[KEY_BACKGROUND_IMAGE_LOCATION]];\n    [self setBackgroundImageMode:[iTermProfilePreferences unsignedIntegerForKey:KEY_BACKGROUND_IMAGE_MODE\n                                                                      inProfile:aDict]];\n\n    // Color scheme\n    // ansiColorsMatchingForeground:andBackground:inBookmark does an equality comparison, so\n    // iTermProfilePreferences is not used here.\n    [self setColorFgBgVariable:[self ansiColorsMatchingForeground:aDict[[self amendedColorKey:KEY_FOREGROUND_COLOR]]\n                                                    andBackground:aDict[[self amendedColorKey:KEY_BACKGROUND_COLOR]]\n                                                       inBookmark:aDict]];\n\n    // transparency\n    [self setTransparency:[iTermProfilePreferences floatForKey:KEY_TRANSPARENCY inProfile:aDict]];\n    [self setTransparencyAffectsOnlyDefaultBackgroundColor:[iTermProfilePreferences floatForKey:KEY_TRANSPARENCY_AFFECTS_ONLY_DEFAULT_BACKGROUND_COLOR inProfile:aDict]];\n\n    // bold\n    [self setUseBoldFont:[iTermProfilePreferences boolForKey:KEY_USE_BOLD_FONT\n                                                   inProfile:aDict]];\n    self.thinStrokes = [iTermProfilePreferences intForKey:KEY_THIN_STROKES inProfile:aDict];\n\n    self.asciiLigatures = [iTermProfilePreferences boolForKey:KEY_ASCII_LIGATURES inProfile:aDict];\n    self.nonAsciiLigatures = [iTermProfilePreferences boolForKey:KEY_NON_ASCII_LIGATURES inProfile:aDict];\n\n    [_textview setUseBoldColor:[iTermProfilePreferences boolForColorKey:KEY_USE_BOLD_COLOR\n                                                                   dark:_screen.colorMap.darkMode\n                                                                profile:aDict]\n                      brighten:[iTermProfilePreferences boolForColorKey:KEY_BRIGHTEN_BOLD_TEXT\n                                                                   dark:_screen.colorMap.darkMode\n                                                                profile:aDict]];\n\n    // Italic - this default has changed from NO to YES as of 1/30/15\n    [self setUseItalicFont:[iTermProfilePreferences boolForKey:KEY_USE_ITALIC_FONT inProfile:aDict]];\n\n    // Set up the rest of the preferences\n    [_screen setAudibleBell:![iTermProfilePreferences boolForKey:KEY_SILENCE_BELL inProfile:aDict]];\n    [_screen setShowBellIndicator:[iTermProfilePreferences boolForKey:KEY_VISUAL_BELL inProfile:aDict]];\n    [_screen setFlashBell:[iTermProfilePreferences boolForKey:KEY_FLASHING_BELL inProfile:aDict]];\n    [_screen setPostUserNotifications:[iTermProfilePreferences boolForKey:KEY_BOOKMARK_USER_NOTIFICATIONS inProfile:aDict]];\n    [_textview setBlinkAllowed:[iTermProfilePreferences boolForKey:KEY_BLINK_ALLOWED inProfile:aDict]];\n    [_screen setCursorBlinks:[iTermProfilePreferences boolForKey:KEY_BLINKING_CURSOR inProfile:aDict]];\n    [_textview setCursorShadow:[iTermProfilePreferences boolForKey:KEY_CURSOR_SHADOW inProfile:aDict]];\n    [_textview setBlinkingCursor:[iTermProfilePreferences boolForKey:KEY_BLINKING_CURSOR inProfile:aDict]];\n    [_textview setCursorType:_cursorTypeOverride ? _cursorTypeOverride.integerValue : [iTermProfilePreferences intForKey:KEY_CURSOR_TYPE inProfile:aDict]];\n\n    PTYTab* currentTab = [[_delegate parentWindow] currentTab];\n    if (currentTab == nil || [_delegate sessionBelongsToVisibleTab]) {\n        [_delegate recheckBlur];\n    }\n\n    [_textview setSmartSelectionRules:aDict[KEY_SMART_SELECTION_RULES]];\n    [_textview setSemanticHistoryPrefs:aDict[KEY_SEMANTIC_HISTORY]];\n    [_textview setUseNonAsciiFont:[iTermProfilePreferences boolForKey:KEY_USE_NONASCII_FONT\n                                                            inProfile:aDict]];\n    [_textview setAntiAlias:[iTermProfilePreferences boolForKey:KEY_ASCII_ANTI_ALIASED\n                                                      inProfile:aDict]\n                   nonAscii:[iTermProfilePreferences boolForKey:KEY_NONASCII_ANTI_ALIASED\n                                                      inProfile:aDict]];\n    [_textview setUseNativePowerlineGlyphs:[iTermProfilePreferences boolForKey:KEY_POWERLINE inProfile:aDict]];\n    [self setEncoding:[iTermProfilePreferences unsignedIntegerForKey:KEY_CHARACTER_ENCODING inProfile:aDict]\n             terminal:terminal];\n    [self setTermVariable:[iTermProfilePreferences stringForKey:KEY_TERMINAL_TYPE inProfile:aDict]\n                 terminal:terminal];\n    [terminal setAnswerBackString:[iTermProfilePreferences stringForKey:KEY_ANSWERBACK_STRING inProfile:aDict]];\n    [self setAntiIdleCode:[iTermProfilePreferences intForKey:KEY_IDLE_CODE inProfile:aDict]];\n    [self setAntiIdlePeriod:[iTermProfilePreferences doubleForKey:KEY_IDLE_PERIOD inProfile:aDict]];\n    [self setAntiIdle:[iTermProfilePreferences boolForKey:KEY_SEND_CODE_WHEN_IDLE inProfile:aDict]];\n    self.endAction = [iTermProfilePreferences unsignedIntegerForKey:KEY_SESSION_END_ACTION inProfile:aDict];\n    [self setTreatAmbiguousWidthAsDoubleWidth:[iTermProfilePreferences boolForKey:KEY_AMBIGUOUS_DOUBLE_WIDTH\n                                                                        inProfile:aDict]];\n    [self setXtermMouseReporting:[iTermProfilePreferences boolForKey:KEY_XTERM_MOUSE_REPORTING\n                                                           inProfile:aDict]];\n    [self setXtermMouseReportingAllowMouseWheel:[iTermProfilePreferences boolForKey:KEY_XTERM_MOUSE_REPORTING_ALLOW_MOUSE_WHEEL\n                                                                          inProfile:aDict]];\n    [self setXtermMouseReportingAllowClicksAndDrags:[iTermProfilePreferences boolForKey:KEY_XTERM_MOUSE_REPORTING_ALLOW_CLICKS_AND_DRAGS\n                                                                              inProfile:aDict]];\n    [self setUnicodeVersion:[iTermProfilePreferences integerForKey:KEY_UNICODE_VERSION\n                                                         inProfile:aDict]];\n    [terminal setDisableSmcupRmcup:[iTermProfilePreferences boolForKey:KEY_DISABLE_SMCUP_RMCUP\n                                                             inProfile:aDict]];\n    [_screen setAllowTitleReporting:[iTermProfilePreferences boolForKey:KEY_ALLOW_TITLE_REPORTING\n                                                              inProfile:aDict]];\n    const BOOL didAllowPasteBracketing = _screen.terminalAllowPasteBracketing;\n    [terminal setAllowPasteBracketing:[iTermProfilePreferences boolForKey:KEY_ALLOW_PASTE_BRACKETING\n                                                                inProfile:aDict]];\n    if (didAllowPasteBracketing && !_screen.terminalAllowPasteBracketing) {\n        // If the user flips the setting off, disable bracketed paste.\n        terminal.bracketedPasteMode = NO;\n    }\n    [terminal setAllowKeypadMode:[iTermProfilePreferences boolForKey:KEY_APPLICATION_KEYPAD_ALLOWED\n                                                           inProfile:aDict]];\n    if ([iTermProfilePreferences boolForKey:KEY_SHOW_STATUS_BAR inProfile:aDict]) {\n        NSDictionary *layout = [iTermProfilePreferences objectForKey:KEY_STATUS_BAR_LAYOUT inProfile:aDict];\n        NSDictionary *existing = _statusBarViewController.layout.dictionaryValue;\n        if (![NSObject object:existing isEqualToObject:layout]) {\n            iTermStatusBarLayout *newLayout = [[[iTermStatusBarLayout alloc] initWithDictionary:layout\n                                                                                          scope:self.variablesScope] autorelease];\n            if (![NSObject object:existing isEqualToObject:newLayout.dictionaryValue]) {\n                [_statusBarViewController release];\n                if (newLayout) {\n                    _statusBarViewController =\n                    [[iTermStatusBarViewController alloc] initWithLayout:newLayout\n                                                                   scope:self.variablesScope];\n                    _statusBarViewController.delegate = self;\n                } else {\n                    _statusBarViewController.delegate = nil;\n                    _statusBarViewController = nil;\n                }\n                [self invalidateStatusBar];\n            }\n        }\n    } else {\n        if (_statusBarViewController && _asyncFilter) {\n            [self stopFiltering];\n        }\n        [_statusBarViewController release];\n        _statusBarViewController = nil;\n        [self invalidateStatusBar];\n    }\n    _tmuxStatusBarMonitor.active = [iTermProfilePreferences boolForKey:KEY_SHOW_STATUS_BAR inProfile:aDict];\n    [_badgeFontName release];\n    _badgeFontName = [[iTermProfilePreferences stringForKey:KEY_BADGE_FONT inProfile:aDict] copy];\n\n    self.badgeFormat = [iTermProfilePreferences stringForKey:KEY_BADGE_FORMAT inProfile:aDict];\n    _badgeLabelSizeFraction = NSMakeSize([iTermProfilePreferences floatForKey:KEY_BADGE_MAX_WIDTH inProfile:aDict],\n                                         [iTermProfilePreferences floatForKey:KEY_BADGE_MAX_HEIGHT inProfile:aDict]);\n\n    self.subtitleFormat = [iTermProfilePreferences stringForKey:KEY_SUBTITLE inProfile:aDict];\n\n    // forces the badge to update\n    _textview.badgeLabel = @\"\";\n    [self updateBadgeLabel];\n    [self setFontTable:[iTermFontTable fontTableForProfile:aDict]\n     horizontalSpacing:[iTermProfilePreferences floatForKey:KEY_HORIZONTAL_SPACING inProfile:aDict]\n       verticalSpacing:[iTermProfilePreferences floatForKey:KEY_VERTICAL_SPACING inProfile:aDict]];\n\n    NSDictionary *shortcutDictionary = [iTermProfilePreferences objectForKey:KEY_SESSION_HOTKEY inProfile:aDict];\n    iTermShortcut *shortcut = [iTermShortcut shortcutWithDictionary:shortcutDictionary];\n    [[iTermSessionHotkeyController sharedInstance] setShortcut:shortcut\n                                                    forSession:self];\n    [[_delegate realParentWindow] invalidateRestorableState];\n\n    const int modifyOtherKeysTerminalSetting = _screen.terminalSendModifiers[4].intValue;\n    if (modifyOtherKeysTerminalSetting == -1) {\n        const BOOL profileWantsTickit = [iTermProfilePreferences boolForKey:KEY_USE_LIBTICKIT_PROTOCOL\n                                                                  inProfile:aDict];\n        self.keyMappingMode = profileWantsTickit ? iTermKeyMappingModeCSIu : iTermKeyMappingModeStandard;\n    }\n\n    if (self.isTmuxClient) {\n        NSDictionary *tabColorDict = [iTermProfilePreferences objectForColorKey:KEY_TAB_COLOR dark:_screen.colorMap.darkMode profile:aDict];\n        if (![iTermProfilePreferences boolForColorKey:KEY_USE_TAB_COLOR dark:_screen.colorMap.darkMode profile:aDict]) {\n            tabColorDict = nil;\n        }\n        NSColor *tabColor = [ITAddressBookMgr decodeColor:tabColorDict];\n        [self.tmuxController setTabColorString:tabColor ? [tabColor hexString] : iTermTmuxTabColorNone\n                                 forWindowPane:self.tmuxPane];\n    }\n    [self.delegate sessionDidChangeGraphic:self\n                                shouldShow:[self shouldShowTabGraphicForProfile:aDict]\n                                     image:[self tabGraphicForProfile:aDict]];\n    [self.delegate sessionUpdateMetalAllowed];\n    [self profileNameDidChangeTo:self.profile[KEY_NAME]];\n}\n\n- (void)setCursorTypeOverride:(NSNumber *)cursorTypeOverride {\n    [_cursorTypeOverride autorelease];\n    _cursorTypeOverride = [cursorTypeOverride retain];\n    _cursorTypeOverrideChanged = YES;\n    [self.textview setCursorType:self.cursorType];\n}\n\n- (ITermCursorType)cursorType {\n    if (_cursorTypeOverride) {\n        return _cursorTypeOverride.integerValue;\n    }\n    return [iTermProfilePreferences intForKey:KEY_CURSOR_TYPE inProfile:_profile];\n}\n\n- (void)invalidateStatusBar {\n    [_view invalidateStatusBar];\n    [_delegate sessionDidInvalidateStatusBar:self];\n}\n\n- (void)setSubtitleFormat:(NSString *)subtitleFormat {\n    if ([subtitleFormat isEqualToString:_subtitleSwiftyString.swiftyString]) {\n        return;\n    }\n    __weak __typeof(self) weakSelf = self;\n    if (!_subtitleSwiftyString) {\n        // Create it with an initially empty string because the delegate will\n        // ask for our subtitle value and it won't be right before\n        // _subtitleSwiftyString is assigned to.\n        _subtitleSwiftyString = [[iTermSwiftyString alloc] initWithString:@\"\"\n                                                                    scope:self.variablesScope\n                                                                 observer:^NSString *(NSString * _Nonnull newValue,\n                                                                                      NSError *error) {\n            if (error) {\n                return [NSString stringWithFormat:@\"\ud83d\udc1e %@\", error.localizedDescription];\n            }\n            __typeof(self) strongSelf = weakSelf;\n            if (strongSelf) {\n                [strongSelf.delegate sessionSubtitleDidChange:strongSelf];\n            }\n            return newValue;\n        }];\n    }\n    _subtitleSwiftyString.swiftyString = subtitleFormat;\n}\n\n- (void)setBadgeFormat:(NSString *)badgeFormat {\n    if ([badgeFormat isEqualToString:_badgeSwiftyString.swiftyString]) {\n        return;\n    }\n    __weak __typeof(self) weakSelf = self;\n    [_badgeSwiftyString invalidate];\n    [_badgeSwiftyString autorelease];\n    _badgeSwiftyString = [[iTermSwiftyString alloc] initWithString:badgeFormat\n                                                             scope:self.variablesScope\n                                                          observer:^NSString *(NSString * _Nonnull newValue, NSError *error) {\n        if (error) {\n            return [NSString stringWithFormat:@\"\ud83d\udc1e %@\", error.localizedDescription];\n        }\n        [weakSelf updateBadgeLabel:newValue];\n        return newValue;\n    }];\n}\n\n- (void)setKeyMappingMode:(iTermKeyMappingMode)mode {\n    _keyMappingMode = mode;\n    [self updateKeyMapper];\n}\n\n- (void)updateKeyMapper {\n    Class mapperClass = [iTermStandardKeyMapper class];\n\n    switch (_keyMappingMode) {\n        case iTermKeyMappingModeStandard:\n            mapperClass = [iTermStandardKeyMapper class];\n            break;\n        case iTermKeyMappingModeCSIu:\n            mapperClass = [iTermTermkeyKeyMapper class];\n            break;\n        case iTermKeyMappingModeRaw:\n            mapperClass = [iTermRawKeyMapper class];\n            break;\n        case iTermKeyMappingModeModifyOtherKeys1:\n            mapperClass = [iTermModifyOtherKeysMapper1 class];\n            break;\n        case iTermKeyMappingModeModifyOtherKeys2:\n            mapperClass = [iTermModifyOtherKeysMapper2 class];\n            break;\n    }\n\n    if (![_keyMapper isKindOfClass:mapperClass]) {\n        [_keyMapper release];\n        _keyMapper = nil;\n\n        id<iTermKeyMapper> keyMapper = [[mapperClass alloc] init];\n        if ([keyMapper respondsToSelector:@selector(setDelegate:)]) {\n            [keyMapper setDelegate:self];\n        }\n        _keyMapper = keyMapper;\n        _textview.keyboardHandler.keyMapper = _keyMapper;\n    }\n    iTermTermkeyKeyMapper *termkey = [iTermTermkeyKeyMapper castFrom:_keyMapper];\n    termkey.flags = _screen.terminalKeyReportingFlags;\n}\n\n- (NSString *)badgeFormat {\n    return _badgeSwiftyString.swiftyString;\n}\n\n- (NSString *)subtitle {\n    return [_subtitleSwiftyString.evaluatedString stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\" \"];\n}\n\n- (BOOL)doesSwiftyString:(iTermSwiftyString *)swiftyString\n          referencePaths:(NSArray<NSString *> *)paths {\n    for (iTermVariableReference *ref in swiftyString.refs) {\n        for (NSString *path in paths) {\n            if ([self.variablesScope variableNamed:path isReferencedBy:ref]) {\n                return YES;\n            }\n        }\n    }\n    return NO;\n}\n\n- (BOOL)checkForCyclesInSwiftyStrings {\n    iTermSwiftyStringGraph *graph = [[[iTermSwiftyStringGraph alloc] init] autorelease];\n    [graph addSwiftyString:_autoNameSwiftyString\n            withFormatPath:iTermVariableKeySessionAutoNameFormat\n            evaluationPath:iTermVariableKeySessionAutoName\n                     scope:self.variablesScope];\n    if (_badgeSwiftyString) {\n        [graph addSwiftyString:_badgeSwiftyString\n                withFormatPath:nil\n                evaluationPath:iTermVariableKeySessionBadge\n                         scope:self.variablesScope];\n    }\n    [self.delegate sessionAddSwiftyStringsToGraph:graph];\n    [graph addEdgeFromPath:iTermVariableKeySessionAutoNameFormat\n                    toPath:iTermVariableKeySessionName\n                     scope:self.variablesScope];\n    return graph.containsCycle;\n}\n\n- (void)updateBadgeLabel {\n    if ([self checkForCyclesInSwiftyStrings]) {\n        [self setBadgeFormat:@\"[Cycle detected]\"];\n        return;\n    }\n    [self updateBadgeLabel:[self badgeLabel]];\n}\n\n- (void)updateBadgeLabel:(NSString *)newValue {\n    _textview.badgeLabel = newValue;\n    [self.variablesScope setValue:newValue forVariableNamed:iTermVariableKeySessionBadge];\n}\n\n- (NSString *)badgeLabel {\n    return _badgeSwiftyString.evaluatedString;\n}\n\n- (BOOL)isAtShellPrompt {\n    return _screen.commandRange.start.x >= 0;\n}\n\n// You're processing if data was read off the socket in the last \"idleTimeSeconds\".\n- (BOOL)isProcessing {\n    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];\n    return (now - _lastOutputIgnoringOutputAfterResizing) < _idleTime;\n}\n\n// You're idle if it's been one second since isProcessing was true.\n- (BOOL)isIdle {\n    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];\n    return (now - _lastOutputIgnoringOutputAfterResizing) > (_idleTime + 1);\n}\n\n- (void)setDelegate:(id<PTYSessionDelegate>)delegate {\n    if ([self isTmuxClient]) {\n        [_tmuxController deregisterWindow:[_delegate tmuxWindow]\n                               windowPane:self.tmuxPane\n                                  session:self];\n    }\n    BOOL needsTermID = (_delegate == nil);\n    _delegate = delegate;\n    if ([self isTmuxClient]) {\n        [_tmuxController registerSession:self\n                                withPane:self.tmuxPane\n                                inWindow:[_delegate tmuxWindow]];\n    }\n    DLog(@\"Fit layout to window on session delegate change\");\n    [_tmuxController fitLayoutToWindows];\n    [self useTransparencyDidChange];\n    [self.variablesScope setValue:[delegate sessionTabVariables]\n                 forVariableNamed:iTermVariableKeySessionTab\n                             weak:YES];\n    if (needsTermID) {\n        [self setTermIDIfPossible];\n    }\n    // useTransparency may have just changed.\n    [self invalidateBlend];\n}\n\n- (NSString *)name {\n    return [self.variablesScope valueForVariableName:iTermVariableKeySessionName] ?: [self.variablesScope valueForVariableName:iTermVariableKeySessionProfileName] ?: @\"Untitled\";\n}\n\n- (void)setIconName:(NSString *)theName {\n    DLog(@\"Assign to autoNameFormat <- %@\", theName);\n    [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionAutoNameFormat: theName ?: [NSNull null],\n                                                    iTermVariableKeySessionIconName: theName ?: [NSNull null] }];\n    [_tmuxTitleMonitor updateOnce];\n    [self.tmuxForegroundJobMonitor updateOnce];\n    _titleDirty = YES;\n}\n\n- (void)setWindowTitle:(NSString *)title {\n    [self.variablesScope setValue:title forVariableNamed:iTermVariableKeySessionWindowName];\n    _titleDirty = YES;\n    [_tmuxTitleMonitor updateOnce];\n    [self.tmuxForegroundJobMonitor updateOnce];\n}\n\n- (BOOL)shouldShowTabGraphic {\n    return [self shouldShowTabGraphicForProfile:self.profile];\n}\n\n- (BOOL)shouldShowTabGraphicForProfile:(Profile *)profile {\n    const iTermProfileIcon icon = [iTermProfilePreferences unsignedIntegerForKey:KEY_ICON inProfile:profile];\n    return icon != iTermProfileIconNone;\n}\n\n- (NSImage *)tabGraphic {\n    return [self tabGraphicForProfile:self.profile];\n}\n\n- (NSImage *)tabGraphicForProfile:(Profile *)profile {\n    const iTermProfileIcon icon = [iTermProfilePreferences unsignedIntegerForKey:KEY_ICON inProfile:profile];\n    switch (icon) {\n        case iTermProfileIconNone:\n            return nil;\n\n        case iTermProfileIconAutomatic:\n            if (self.isTmuxClient) {\n                [_graphicSource updateImageForJobName:self.tmuxForegroundJobMonitor.lastValue\n                                              enabled:[self shouldShowTabGraphicForProfile:profile]];\n            } else {\n                [_graphicSource updateImageForProcessID:[self.variablesScope.effectiveRootPid intValue]\n                                                enabled:[self shouldShowTabGraphicForProfile:profile]\n                                    processInfoProvider:self.processInfoProvider];\n            }\n            return _graphicSource.image;\n\n        case iTermProfileIconCustom:\n            return [self customIconImageForProfile:profile];\n    }\n\n    DLog(@\"Unexpected icon setting %@\", @(icon));\n    return nil;\n}\n\n- (NSImage *)customIconImage {\n    return [self customIconImageForProfile:self.profile];\n}\n\n- (NSImage *)customIconImageForProfile:(Profile *)profile {\n    if (!_customIcon) {\n        _customIcon = [[iTermCacheableImage alloc] init];\n    }\n    NSString *path = [iTermProfilePreferences stringForKey:KEY_ICON_PATH inProfile:profile];\n    BOOL flipped = YES;\n    if (@available(macOS 10.15, *)) {\n        flipped = NO;\n    }\n    return [_customIcon imageAtPath:path ofSize:NSMakeSize(16, 16) flipped:flipped];\n}\n\n- (NSString *)windowTitle {\n    return _nameController.presentationWindowTitle;\n}\n\n- (void)pushWindowTitle {\n    [_nameController pushWindowTitle];\n}\n\n- (void)popWindowTitle {\n    NSString *title = [_nameController popWindowTitle];\n    [self setWindowTitle:title];\n}\n\n- (void)pushIconTitle {\n    [_nameController pushIconTitle];\n}\n\n- (void)popIconTitle {\n    NSString *theName = [_nameController popIconTitle];\n    [self setIconName:theName ?: [iTermProfilePreferences stringForKey:KEY_NAME inProfile:self.profile]];\n}\n\n- (void)userInitiatedReset {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [terminal resetByUserRequest:YES];\n    }];\n    [self updateDisplayBecause:@\"reset terminal\"];\n}\n\n- (void)resetForRelaunch {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        [terminal resetForRelaunch];\n    }];\n}\n\n- (void)setTermVariable:(NSString *)termVariable terminal:(VT100Terminal *)terminal {\n    if (self.isTmuxClient) {\n        return;\n    }\n    [_termVariable autorelease];\n    _termVariable = [termVariable copy];\n    [terminal setTermType:_termVariable];\n}\n\n- (void)setView:(SessionView *)newView {\n    if (_view.searchResultsMinimapViewDelegate == _textview.findOnPageHelper) {\n        _view.searchResultsMinimapViewDelegate = nil;\n    }\n    [_view autorelease];\n    _view = [newView retain];\n    newView.delegate = self;\n    newView.searchResultsMinimapViewDelegate = _textview.findOnPageHelper;\n    newView.driver.dataSource = _metalGlue;\n    [newView updateTitleFrame];\n    [_view setFindDriverDelegate:self];\n    [self updateViewBackgroundImage];\n}\n\n- (NSStringEncoding)encoding {\n    return _screen.terminalEncoding;\n}\n\n- (void)setEncoding:(NSStringEncoding)encoding terminal:(VT100Terminal *)terminal {\n    [terminal setEncoding:encoding];\n}\n\n- (NSString *)tty {\n    return [_shell tty];\n}\n\n- (void)setBackgroundImageMode:(iTermBackgroundImageMode)mode {\n    _backgroundImageMode = mode;\n    [_backgroundDrawingHelper invalidate];\n    [self setBackgroundImagePath:_backgroundImagePath];\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        self.view.imageMode = mode;\n    }\n}\n\n- (void)setBackgroundImagePath:(NSString *)imageFilePath {\n    DLog(@\"setBackgroundImagePath:%@\", imageFilePath);\n    if ([imageFilePath length]) {\n        if ([imageFilePath isAbsolutePath] == NO) {\n            NSBundle *myBundle = [NSBundle bundleForClass:[self class]];\n            imageFilePath = [myBundle pathForResource:imageFilePath ofType:@\"\"];\n            DLog(@\"Not an absolute path. Use bundle-relative path of %@\", imageFilePath);\n        }\n        if ([imageFilePath isEqualToString:_backgroundImagePath]) {\n            DLog(@\"New image path equals existing path, so do nothing.\");\n            return;\n        }\n        [_backgroundImagePath autorelease];\n        _backgroundImagePath = [imageFilePath copy];\n        self.backgroundImage = [[iTermSharedImageStore sharedInstance] imageWithContentsOfFile:_backgroundImagePath];\n    } else {\n        DLog(@\"Clearing abackground image\");\n        self.backgroundImage = nil;\n        [_backgroundImagePath release];\n        _backgroundImagePath = nil;\n    }\n\n    [_patternedImage release];\n    _patternedImage = nil;\n\n    [_textview setNeedsDisplay:YES];\n}\n\n- (CGFloat)effectiveBlend {\n    if (!self.effectiveBackgroundImage) {\n        return 0;\n    }\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return self.desiredBlend;\n    } else {\n        if (self.backgroundImage) {\n            return self.desiredBlend;\n        }\n        // I don't have a background image so inherit the blend setting of the active session.\n        return [self.delegate sessionBlend];\n    }\n}\n\n- (CGFloat)desiredBlend {\n    return [iTermProfilePreferences floatForKey:KEY_BLEND inProfile:self.profile];\n}\n\n- (iTermImageWrapper *)effectiveBackgroundImage {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return _backgroundImage;\n    } else {\n        return [self.delegate sessionBackgroundImage];\n    }\n}\n\n- (iTermBackgroundImageMode)effectiveBackgroundImageMode {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return _backgroundImageMode;\n    } else {\n        return [self.delegate sessionBackgroundImageMode];\n    }\n}\n\n- (BOOL)shouldDrawBackgroundImageManually {\n    return !iTermTextIsMonochrome() || [NSView iterm_takingSnapshot];\n}\n\n- (void)updateViewBackgroundImage {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        DLog(@\"Update per-pane background image\");\n        self.view.image = _backgroundImage;\n        [self.view setImageMode:_backgroundImageMode];\n        [self.view setTerminalBackgroundColor:[self processedBackgroundColor]];\n        return;\n    }\n    self.view.image = nil;\n    [self.view setTerminalBackgroundColor:[self processedBackgroundColor]];\n    [self invalidateBlend];\n    [self.delegate session:self\n        setBackgroundImage:_backgroundImage\n                      mode:_backgroundImageMode\n           backgroundColor:[self processedBackgroundColor]];\n}\n\n- (void)setBackgroundImage:(iTermImageWrapper *)backgroundImage {\n    DLog(@\"setBackgroundImage:%@\", backgroundImage);\n    [_backgroundImage autorelease];\n    _backgroundImage = [backgroundImage retain];\n    [self updateViewBackgroundImage];\n}\n\n- (void)setSmartCursorColor:(BOOL)value {\n    [[self textview] setUseSmartCursorColor:value];\n}\n\n- (void)setMinimumContrast:(float)value {\n    [[self textview] setMinimumContrast:value];\n}\n\n- (BOOL)viewShouldWantLayer {\n    return NO;\n}\n\n- (void)useTransparencyDidChange {\n    // The view does not like getting replaced during the spin of the runloop during which it is created.\n    if (_view.window && _delegate.realParentWindow && _textview) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (_view.window && _delegate.realParentWindow && _textview) {\n                [_delegate sessionTransparencyDidChange];\n                [self invalidateBlend];\n            }\n        });\n    }\n}\n\n- (float)transparency\n{\n    return [_textview transparency];\n}\n\n- (void)setTransparency:(float)transparency {\n    // Limit transparency because fully transparent windows can't be clicked on.\n    if (transparency > 0.9) {\n        transparency = 0.9;\n    }\n    [_textview setTransparency:transparency];\n    [self useTransparencyDidChange];\n    [self invalidateBlend];\n}\n\n- (void)invalidateBlend {\n    [_textview setNeedsDisplay:YES];\n    [self.view setNeedsDisplay:YES];\n    [self.view setTransparencyAlpha:_textview.transparencyAlpha\n                              blend:self.effectiveBlend];\n}\n\n- (void)setTransparencyAffectsOnlyDefaultBackgroundColor:(BOOL)value {\n    [_textview setTransparencyAffectsOnlyDefaultBackgroundColor:value];\n}\n\n- (BOOL)antiIdle {\n    return _antiIdleTimer ? YES : NO;\n}\n\n- (void)setAntiIdle:(BOOL)set {\n    [_antiIdleTimer invalidate];\n    _antiIdleTimer = nil;\n\n    _antiIdlePeriod = MAX(_antiIdlePeriod, kMinimumAntiIdlePeriod);\n\n    if (set) {\n        _antiIdleTimer = [NSTimer scheduledTimerWithTimeInterval:_antiIdlePeriod\n                                                          target:self.weakSelf\n                                                        selector:@selector(doAntiIdle)\n                                                        userInfo:nil\n                                                         repeats:YES];\n    }\n}\n\n- (BOOL)useBoldFont {\n    return [_textview useBoldFont];\n}\n\n- (void)setUseBoldFont:(BOOL)boldFlag\n{\n    [_textview setUseBoldFont:boldFlag];\n}\n\n- (iTermThinStrokesSetting)thinStrokes {\n    return _textview.thinStrokes;\n}\n\n- (void)setThinStrokes:(iTermThinStrokesSetting)thinStrokes {\n    _textview.thinStrokes = thinStrokes;\n}\n\n- (void)setAsciiLigatures:(BOOL)asciiLigatures {\n    _textview.asciiLigatures = asciiLigatures;\n}\n\n- (BOOL)asciiLigatures {\n    return _textview.asciiLigatures;\n}\n\n- (void)setNonAsciiLigatures:(BOOL)nonAsciiLigatures {\n    _textview.nonAsciiLigatures = nonAsciiLigatures;\n}\n\n- (BOOL)nonAsciiLigatures {\n    return _textview.nonAsciiLigatures;\n}\n\n- (BOOL)useItalicFont\n{\n    return [_textview useItalicFont];\n}\n\n- (void)setUseItalicFont:(BOOL)italicFlag\n{\n    [_textview setUseItalicFont:italicFlag];\n}\n\n- (void)setTreatAmbiguousWidthAsDoubleWidth:(BOOL)set {\n    _treatAmbiguousWidthAsDoubleWidth = set;\n    _tmuxController.ambiguousIsDoubleWidth = set;\n}\n\n- (void)setUnicodeVersion:(NSInteger)version {\n    _unicodeVersion = version;\n    _tmuxController.unicodeVersion = version;\n    [[NSNotificationCenter defaultCenter] postNotificationName:iTermUnicodeVersionDidChangeNotification\n                                                        object:nil];\n}\n\n- (void)setXtermMouseReporting:(BOOL)set\n{\n    _xtermMouseReporting = set;\n    [_textview updateCursor:[NSApp currentEvent]];\n}\n\n- (BOOL)logging {\n    return _logging.enabled;\n}\n\n- (void)logStart {\n    __weak __typeof(self) weakSelf = self;\n    [iTermSavePanel asyncShowWithOptions:kSavePanelOptionAppendOrReplace | kSavePanelOptionLogPlainTextAccessory\n                              identifier:@\"StartSessionLog\"\n                        initialDirectory:NSHomeDirectory()\n                         defaultFilename:@\"\"\n                        allowedFileTypes:nil\n                                  window:self.delegate.realParentWindow.window\n                              completion:^(iTermSavePanel *panel) {\n        NSString *path = panel.path;\n        if (path) {\n            BOOL shouldAppend = (panel.replaceOrAppend == kSavePanelReplaceOrAppendSelectionAppend);\n            [weakSelf startLoggingAt:path append:shouldAppend style:panel.loggingStyle];\n        }\n    }];\n}\n\n- (void)startLoggingAt:(NSString *)path append:(BOOL)shouldAppend style:(iTermLoggingStyle)style {\n    [[self loggingHelper] setPath:path\n                          enabled:YES\n                            style:style\n                asciicastMetadata:[self asciicastMetadata]\n                           append:@(shouldAppend)];\n}\n\n- (void)logStop {\n    [_logging stop];\n}\n\n- (void)clearBuffer {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState clearBufferWithoutTriggersSavingPrompt:YES];\n        if (self.isTmuxClient) {\n            [_tmuxController clearHistoryForWindowPane:self.tmuxPane];\n        }\n        if ([iTermAdvancedSettingsModel jiggleTTYSizeOnClearBuffer]) {\n            [self jiggle];\n        }\n        _view.scrollview.ptyVerticalScroller.userScroll = NO;\n    }];\n}\n\n- (void)jiggle {\n    DLog(@\"%@\", [NSThread callStackSymbols]);\n    [self.shell.winSizeController jiggle];\n}\n\n- (void)clearScrollbackBuffer {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState clearScrollbackBuffer];\n    }];\n    if (self.isTmuxClient) {\n        [_tmuxController clearHistoryForWindowPane:self.tmuxPane];\n    }\n}\n\n- (BOOL)shouldSendEscPrefixForModifier:(unsigned int)modmask {\n    if ([self optionKey] == OPT_ESC) {\n        if ((modmask == NSEventModifierFlagOption) ||\n            (modmask & NSLeftAlternateKeyMask) == NSLeftAlternateKeyMask) {\n            return YES;\n        }\n    }\n    if ([self rightOptionKey] == OPT_ESC) {\n        if ((modmask & NSRightAlternateKeyMask) == NSRightAlternateKeyMask) {\n            return YES;\n        }\n    }\n    return NO;\n}\n\n- (void)setScrollViewDocumentView {\n    const BOOL shouldUpdateLayout = (_view.scrollview.documentView == nil && _wrapper != nil);\n    [_view.scrollview setDocumentView:_wrapper];\n    NSRect rect = {\n        .origin = NSZeroPoint,\n        .size = _view.scrollview.contentSize\n    };\n    _wrapper.frame = rect;\n    [_textview refresh];\n    if (shouldUpdateLayout) {\n        DLog(@\"Document view went from nil to %@ so update layout\", _wrapper);\n        [_view updateLayout];\n    }\n}\n\n- (void)setProfile:(Profile *)newProfile {\n    assert(newProfile);\n    DLog(@\"Set profile to one with guid %@\\n%@\", newProfile[KEY_GUID], [NSThread callStackSymbols]);\n\n    NSMutableDictionary *mutableProfile = [[newProfile mutableCopy] autorelease];\n    // This is the most practical way to migrate the bopy of a\n    // profile that's stored in a saved window arrangement. It doesn't get\n    // saved back into the arrangement, unfortunately.\n    [ProfileModel migratePromptOnCloseInMutableBookmark:mutableProfile];\n\n    NSString *originalGuid = newProfile[KEY_ORIGINAL_GUID];\n    if (originalGuid) {\n        // This code path is taken when changing an existing session's profile.\n        // See bug 2632.\n        // It is also taken when you \"new tab with same profile\" and that profile is divorced.\n        Profile *possibleOriginalProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:originalGuid];\n        if (possibleOriginalProfile) {\n            [_originalProfile autorelease];\n            _originalProfile = [possibleOriginalProfile copy];\n        }\n    }\n    if (!_originalProfile) {\n        // This is normally taken when a new session is being created.\n        _originalProfile = [NSDictionary dictionaryWithDictionary:mutableProfile];\n        [_originalProfile retain];\n    }\n\n    [_profile release];\n    _profile = [mutableProfile retain];\n    [self profileNameDidChangeTo:self.profile[KEY_NAME]];\n    [self invalidateBlend];\n    [[_delegate realParentWindow] invalidateRestorableState];\n    [[_delegate realParentWindow] updateTabColors];\n    [_delegate sessionDidUpdatePreferencesFromProfile:self];\n    [_nameController setNeedsUpdate];\n    _profileDidChange = YES;\n    [self sync];\n}\n\n- (NSString *)programType {\n    if ([self.program isEqualToString:[ITAddressBookMgr shellLauncherCommandWithCustomShell:self.customShell]]) {\n        if (self.customShell.length) {\n            return kProgramTypeCustomShell;\n        }\n        return kProgramTypeShellLauncher;\n    }\n    return kProgramTypeCommand;\n}\n\n- (BOOL)encodeArrangementWithContents:(BOOL)includeContents\n                              encoder:(id<iTermEncoderAdapter>)result {\n    return [self encodeArrangementWithContents:includeContents\n                                       encoder:result\n                            replacementProfile:nil\n                                   saveProgram:YES\n                                  pendingJumps:nil];\n}\n\n- (BOOL)encodeArrangementWithContents:(BOOL)includeContents\n                              encoder:(id<iTermEncoderAdapter>)result\n                   replacementProfile:(Profile *)replacementProfile\n                          saveProgram:(BOOL)saveProgram\n                         pendingJumps:(NSArray<iTermSSHReconnectionInfo *> *)pendingJumps {\n    DLog(@\"Construct arrangement for session %@ with includeContents=%@\", self, @(includeContents));\n    if (_filter.length && _liveSession != nil) {\n        DLog(@\"Encode live session because this one is filtered.\");\n        const BOOL ok = [_liveSession encodeArrangementWithContents:includeContents encoder:result];\n        if (ok) {\n            result[SESSION_ARRANGEMENT_FILTER] = _filter;\n        }\n        return ok;\n    }\n    result[SESSION_ARRANGEMENT_COLUMNS] = @(_screen.width);\n    result[SESSION_ARRANGEMENT_ROWS] = @(_screen.height);\n    result[SESSION_ARRANGEMENT_BOOKMARK] = replacementProfile ?: _profile;\n\n    if (_substitutions) {\n        result[SESSION_ARRANGEMENT_SUBSTITUTIONS] = _substitutions;\n    }\n\n    if (saveProgram) {\n        NSString *const programType = [self programType];\n        if ([programType isEqualToString:kProgramTypeCustomShell]) {\n            // The shell launcher command could change from run to run (e.g., if you move iTerm2).\n            // I don't want to use a magic string, so setting program to an empty dict.\n            assert(self.customShell.length);\n            NSDictionary *dict = @{ kProgramType: kProgramTypeCustomShell };\n            dict = [dict dictionaryBySettingObject:self.customShell forKey:kCustomShell];\n            result[SESSION_ARRANGEMENT_PROGRAM] = dict;\n        } else if ([programType isEqualToString:kProgramTypeShellLauncher]) {\n            NSDictionary *dict = @{ kProgramType: kProgramTypeShellLauncher };\n            result[SESSION_ARRANGEMENT_PROGRAM] = dict;\n        } else if ([programType isEqualToString:kProgramTypeCommand] &&\n                   self.program) {\n            result[SESSION_ARRANGEMENT_PROGRAM] = @{ kProgramType: kProgramTypeCommand,\n                                                     kProgramCommand: self.program };\n        }\n    }\n    if (pendingJumps) {\n        result[SESSION_ARRANGEMENT_PENDING_JUMPS] = [pendingJumps mapWithBlock:^id _Nullable(iTermSSHReconnectionInfo * _Nonnull info) {\n            return [info serialized];\n        }];\n    }\n    result[SESSION_ARRANGEMENT_KEYLABELS] = _keyLabels ?: @{};\n    result[SESSION_ARRANGEMENT_KEYLABELS_STACK] = [_keyLabelsStack mapWithBlock:^id(iTermKeyLabels *anObject) {\n        return anObject.dictionaryValue;\n    }];\n    result[SESSION_ARRANGEMENT_ENVIRONMENT] = self.environment ?: @{};\n    result[SESSION_ARRANGEMENT_IS_UTF_8] = @(self.isUTF8);\n    result[SESSION_ARRANGEMENT_SHORT_LIVED_SINGLE_USE] = @(self.shortLivedSingleUse);\n    if (self.hostnameToShell) {\n        result[SESSION_ARRANGEMENT_HOSTNAME_TO_SHELL] = [[self.hostnameToShell copy] autorelease];\n    }\n\n    NSDictionary *shortcutDictionary = [[[iTermSessionHotkeyController sharedInstance] shortcutForSession:self] dictionaryValue];\n    if (shortcutDictionary) {\n        result[SESSION_ARRANGEMENT_HOTKEY] = shortcutDictionary;\n    }\n\n    result[SESSION_ARRANGEMENT_NAME_CONTROLLER_STATE] = [_nameController stateDictionary];\n    if (includeContents) {\n        __block int numberOfLinesDropped = 0;\n        [result encodeDictionaryWithKey:SESSION_ARRANGEMENT_CONTENTS\n                             generation:iTermGenerationAlwaysEncode\n                                  block:^BOOL(id<iTermEncoderAdapter>  _Nonnull encoder) {\n            return [_screen encodeContents:encoder linesDropped:&numberOfLinesDropped];\n        }];\n        result[SESSION_ARRANGEMENT_VARIABLES] = _variables.encodableDictionaryValue;\n        result[SESSION_ARRANGEMENT_ALERT_ON_NEXT_MARK] = @(_alertOnNextMark);\n        result[SESSION_ARRANGEMENT_CURSOR_GUIDE] = @(_textview.highlightCursorLine);\n        result[SESSION_ARRANGEMENT_CURSOR_TYPE_OVERRIDE] = self.cursorTypeOverride;\n        if (self.lastDirectory) {\n            DLog(@\"Saving arrangement for %@ with lastDirectory of %@\", self, self.lastDirectory);\n            result[SESSION_ARRANGEMENT_LAST_DIRECTORY] = self.lastDirectory;\n        }\n        if (self.lastLocalDirectory) {\n            result[SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY] = self.lastLocalDirectory;\n            result[SESSION_ARRANGEMENT_LAST_LOCAL_DIRECTORY_WAS_PUSHED] = @(self.lastLocalDirectoryWasPushed);\n        }\n        result[SESSION_ARRANGEMENT_SELECTION] =\n        [self.textview.selection dictionaryValueWithYOffset:-numberOfLinesDropped\n                                    totalScrollbackOverflow:_screen.totalScrollbackOverflow];\n        result[SESSION_ARRANGEMENT_APS] = [_automaticProfileSwitcher savedState];\n        result[SESSION_ARRANGEMENT_SSH_STATE] = @(_sshState);\n        if (_conductor) {\n            NSString *json = _conductor.jsonValue;\n            if (json) {\n                result[SESSION_ARRANGEMENT_CONDUCTOR] = json;\n            }\n        }\n    } else {\n        if (_conductor &&\n            [self.profile[KEY_CUSTOM_COMMAND] isEqualTo:kProfilePreferenceCommandTypeSSHValue]) {\n            result[SESSION_ARRANGEMENT_PENDING_JUMPS] = [self.sshCommandLineSequence mapWithBlock:^id _Nullable(iTermSSHReconnectionInfo * _Nonnull anObject) {\n                return anObject.serialized;\n            }];\n        }\n    }\n    result[SESSION_ARRANGEMENT_GUID] = _guid;\n    if (_liveSession && includeContents && !_dvr) {\n        [result encodeDictionaryWithKey:SESSION_ARRANGEMENT_LIVE_SESSION\n                             generation:iTermGenerationAlwaysEncode\n                                  block:^BOOL(id<iTermEncoderAdapter>  _Nonnull encoder) {\n            return [_liveSession encodeArrangementWithContents:includeContents\n                                                       encoder:encoder];\n        }];\n    }\n    DLog(@\"self.isTmuxClient=%@\", @(self.isTmuxClient));\n    if (includeContents && !self.isTmuxClient) {\n        DLog(@\"Can include restoration info. runJobsInServers=%@ isSessionRestorationPossible=%@\",\n             @([iTermAdvancedSettingsModel runJobsInServers]),\n             @(_shell.isSessionRestorationPossible));\n        // These values are used for restoring sessions after a crash. It's only saved when contents\n        // are included since saved window arrangements have no business knowing the process id.\n        if ([iTermAdvancedSettingsModel runJobsInServers] && _shell.isSessionRestorationPossible) {\n            NSObject *restorationIdentifier = _shell.sessionRestorationIdentifier;\n            DLog(@\"Can save restoration id. restorationIdentifier=%@\", restorationIdentifier);\n            if ([restorationIdentifier isKindOfClass:[NSNumber class]]) {\n                result[SESSION_ARRANGEMENT_SERVER_PID] = restorationIdentifier;\n            } else if ([restorationIdentifier isKindOfClass:[NSDictionary class]]) {\n                result[SESSION_ARRANGEMENT_SERVER_DICT] = restorationIdentifier;\n            }\n            if (self.tty) {\n                result[SESSION_ARRANGEMENT_TTY] = self.tty;\n            }\n        }\n    }\n    if (_logging.enabled) {\n        result[SESSION_ARRANGEMENT_AUTOLOG_FILENAME] = _logging.path;\n    }\n    if (_cookie) {\n        result[SESSION_ARRANGEMENT_REUSABLE_COOKIE] = _cookie;\n    }\n    if (_overriddenFields.count > 0) {\n        if (replacementProfile) {\n            NSMutableSet<NSString *> *combinedOverriddenFields = [[_overriddenFields mutableCopy] autorelease];\n            for (NSString *key in [[NSSet setWithArray:[_profile allKeys]] setByAddingObjectsFromSet:[NSSet setWithArray:[replacementProfile allKeys]]]) {\n                id mine = _profile[key];\n                id theirs = replacementProfile[key];\n                if (![NSObject object:mine isEqualToObject:theirs]) {\n                    [combinedOverriddenFields addObject:key];\n                }\n            }\n            result[SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS] = combinedOverriddenFields;\n            DLog(@\"Combined overridden fields are: %@\", combinedOverriddenFields);\n        } else {\n            result[SESSION_ARRANGEMENT_OVERRIDDEN_FIELDS] = _overriddenFields.allObjects;\n        }\n    }\n    if (self.tmuxMode == TMUX_GATEWAY && self.tmuxController.sessionName) {\n        result[SESSION_ARRANGEMENT_IS_TMUX_GATEWAY] = @YES;\n        result[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_ID] = @(self.tmuxController.sessionId);\n        result[SESSION_ARRANGEMENT_TMUX_GATEWAY_SESSION_NAME] = self.tmuxController.sessionName;\n        NSString *dcsID = [[self.tmuxController.gateway.dcsID copy] autorelease];\n        if (dcsID) {\n            result[SESSION_ARRANGEMENT_TMUX_DCS_ID] = dcsID;\n        }\n    }\n    if ( _conductor) {\n        result[SESSION_ARRANGEMENT_CONDUCTOR_DCS_ID] = _conductor.dcsID;\n        result[SESSION_ARRANGEMENT_CONDUCTOR_TREE] = _conductor.tree.it_keyValueCodedData;\n    }\n\n    result[SESSION_ARRANGEMENT_SHOULD_EXPECT_PROMPT_MARKS] = @(_screen.shouldExpectPromptMarks);\n    result[SESSION_ARRANGEMENT_SHOULD_EXPECT_CURRENT_DIR_UPDATES] = @(_shouldExpectCurrentDirUpdates);\n    result[SESSION_ARRANGEMENT_WORKING_DIRECTORY_POLLER_DISABLED] = @(_workingDirectoryPollerDisabled);\n    result[SESSION_ARRANGEMENT_COMMANDS] = _commands;\n    result[SESSION_ARRANGEMENT_DIRECTORIES] = _directories;\n    // If this is slow, it could be encoded more efficiently by using encodeArrayWithKey:...\n    // but that would require coming up with a good unique identifier.\n    result[SESSION_ARRANGEMENT_HOSTS] = [_hosts mapWithBlock:^id(id anObject) {\n        return [(id<VT100RemoteHostReading>)anObject dictionaryValue];\n    }];\n\n    NSString *pwd = [self currentLocalWorkingDirectory];\n    result[SESSION_ARRANGEMENT_WORKING_DIRECTORY] = pwd ? pwd : @\"\";\n    return YES;\n}\n\n+ (NSDictionary *)arrangementFromTmuxParsedLayout:(NSDictionary *)parseNode\n                                         bookmark:(Profile *)bookmark\n                                   tmuxController:(TmuxController *)tmuxController\n                                           window:(int)window {\n    NSMutableDictionary* result = [NSMutableDictionary dictionaryWithCapacity:3];\n    [result setObject:[parseNode objectForKey:kLayoutDictWidthKey] forKey:SESSION_ARRANGEMENT_COLUMNS];\n    [result setObject:[parseNode objectForKey:kLayoutDictHeightKey] forKey:SESSION_ARRANGEMENT_ROWS];\n    [result setObject:bookmark forKey:SESSION_ARRANGEMENT_BOOKMARK];\n    [result setObject:@\"\" forKey:SESSION_ARRANGEMENT_WORKING_DIRECTORY];\n    [result setObject:[parseNode objectForKey:kLayoutDictWindowPaneKey] forKey:SESSION_ARRANGEMENT_TMUX_PANE];\n    result[SESSION_ARRANGEMENT_TMUX_FOCUS_REPORTING] = parseNode[kLayoutDictFocusReportingKey] ?: @NO;\n    NSDictionary *hotkey = parseNode[kLayoutDictHotkeyKey];\n    if (hotkey) {\n        [result setObject:hotkey forKey:SESSION_ARRANGEMENT_HOTKEY];\n    }\n    NSObject *value = [parseNode objectForKey:kLayoutDictHistoryKey];\n    if (value) {\n        [result setObject:value forKey:SESSION_ARRANGEMENT_TMUX_HISTORY];\n    }\n    value = [parseNode objectForKey:kLayoutDictAltHistoryKey];\n    if (value) {\n        [result setObject:value forKey:SESSION_ARRANGEMENT_TMUX_ALT_HISTORY];\n    }\n    value = [parseNode objectForKey:kLayoutDictStateKey];\n    if (value) {\n        [result setObject:value forKey:SESSION_ARRANGEMENT_TMUX_STATE];\n    }\n    value = parseNode[kLayoutDictTabColorKey];\n    if (value) {\n        result[SESSION_ARRANGEMENT_TMUX_TAB_COLOR] = value;\n    }\n    NSDictionary *fontOverrides = [tmuxController fontOverridesForWindow:window];\n    if (fontOverrides) {\n        result[SESSION_ARRANGEMENT_FONT_OVERRIDES] = fontOverrides;\n    }\n    NSDictionary *keyboardMapOverrides = tmuxController.sharedKeyMappingOverrides;\n    if (keyboardMapOverrides) {\n        result[SESSION_ARRANGEMENT_KEYBOARD_MAP_OVERRIDES] = [[keyboardMapOverrides copy] autorelease];\n    }\n    return result;\n}\n\n+ (NSString *)guidInArrangement:(NSDictionary *)arrangement {\n    NSString *guid = arrangement[SESSION_ARRANGEMENT_GUID];\n    if (guid) {\n        return guid;\n    } else {\n        return arrangement[SESSION_UNIQUE_ID];\n    }\n}\n\n+ (NSString *)initialWorkingDirectoryFromArrangement:(NSDictionary *)arrangement {\n    return arrangement[SESSION_ARRANGEMENT_WORKING_DIRECTORY];\n}\n\n- (BOOL)shouldUpdateTitles:(NSTimeInterval)now {\n    // Update window info for the active tab.\n    if (!self.jobName) {\n        return YES;\n    }\n    if ([self.processInfoProvider processIsDirty:_shell.pid]) {\n        DLog(@\"Update title immediately because process %@ is dirty\", @(_shell.pid));\n        return YES;\n    }\n\n    static const NSTimeInterval dirtyTitlePeriod = 0.02;\n    static const NSTimeInterval pollingTitlePeriod = 0.7;\n    const NSTimeInterval elapsedTime = now - _lastUpdate;\n    const NSTimeInterval deadline = _titleDirty ? dirtyTitlePeriod : pollingTitlePeriod;\n    if (elapsedTime >= deadline) {\n        return YES;\n    }\n\n    return NO;\n}\n\n- (void)maybeUpdateTitles {\n    const NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];\n    if ([self shouldUpdateTitles:now]) {\n        [self updateTitles];\n        _lastUpdate = now;\n        _titleDirty = NO;\n    }\n}\n\n- (void)updateDisplayBecause:(NSString *)reason {\n    DLog(@\"updateDisplayBecause:%@ %@\", reason, _cadenceController);\n    _updateCount++;\n    if (_useMetal && _updateCount % 10 == 0) {\n        iTermPreciseTimerSaveLog([NSString stringWithFormat:@\"%@: updateDisplay interval\", _view.driver.identifier],\n                                 _cadenceController.histogram.stringValue);\n    }\n    _timerRunning = YES;\n\n    // This syncs with the mutation thread.\n    DLog(@\"Session %@ calling refresh\", self);\n    const BOOL somethingIsBlinking = [_textview refresh];\n\n    // Set attributes of tab to indicate idle, processing, etc.\n    if (![self isTmuxGateway]) {\n        [_delegate updateLabelAttributes];\n    }\n\n    if ([_delegate sessionIsActiveInTab:self]) {\n        [self maybeUpdateTitles];\n    } else {\n        [self setCurrentForegroundJobProcessInfo:[self.sessionProcessInfoProvider cachedProcessInfoIfAvailable]];\n        [self.view setTitle:_nameController.presentationSessionTitle];\n    }\n\n    const BOOL transientTitle = _delegate.realParentWindow.isShowingTransientTitle;\n    const BOOL animationPlaying = _textview.getAndResetDrawingAnimatedImageFlag;\n\n    // Even if \"active\" isn't changing we need the side effect of setActive: that updates the\n    // cadence since we might have just become idle.\n    self.active = (somethingIsBlinking || transientTitle || animationPlaying);\n\n    if (_tailFindTimer && _view.findViewIsHidden && !_performingOneShotTailFind) {\n        [self stopTailFind];\n    }\n\n    const BOOL passwordInput = _shell.passwordInput || _conductor.atPasswordPrompt;\n    DLog(@\"passwordInput=%@\", @(passwordInput));\n    if (passwordInput != _passwordInput) {\n        _passwordInput = passwordInput;\n        [[iTermSecureKeyboardEntryController sharedInstance] update];\n        if (passwordInput) {\n            [self didBeginPasswordInput];\n        }\n    }\n    _timerRunning = NO;\n}\n\n- (BOOL)shouldShowPasswordManagerAutomatically {\n    return [iTermProfilePreferences boolForKey:KEY_OPEN_PASSWORD_MANAGER_AUTOMATICALLY\n                                     inProfile:self.profile];\n}\n\n- (void)didBeginPasswordInput {\n    if ([self shouldShowPasswordManagerAutomatically]) {\n        iTermApplicationDelegate *itad = [iTermApplication.sharedApplication delegate];\n        [itad openPasswordManagerToAccountName:nil inSession:self];\n\n    }\n}\n\n// Update the tab, session view, and window title.\n- (void)updateTitles {\n    DLog(@\"updateTitles\");\n    iTermProcessInfo *processInfo = [self.sessionProcessInfoProvider cachedProcessInfoIfAvailable];\n    iTermProcessInfo *effectiveProcessInfo = processInfo;\n    if (!processInfo && _titleDirty) {\n        // It's an emergency. Use whatever is lying around.\n        DLog(@\"Performing emergency title update\");\n        effectiveProcessInfo = _lastProcessInfo;\n    }\n    if (effectiveProcessInfo) {\n        [_lastProcessInfo autorelease];\n        _lastProcessInfo = [effectiveProcessInfo retain];\n        [self updateTitleWithProcessInfo:effectiveProcessInfo];\n\n        if (processInfo) {\n            return;\n        }\n    }\n    __weak __typeof(self) weakSelf = self;\n    [self.sessionProcessInfoProvider fetchProcessInfoForCurrentJobWithCompletion:^(iTermProcessInfo *processInfo) {\n        [weakSelf updateTitleWithProcessInfo:processInfo];\n    }];\n}\n\n- (void)updateTitleWithProcessInfo:(iTermProcessInfo *)processInfo {\n    DLog(@\"%@ Job for pid %@ is %@, pid=%@\", self, @(_shell.pid), processInfo.name, @(processInfo.processID));\n    [self setCurrentForegroundJobProcessInfo:processInfo];\n\n    if ([_delegate sessionBelongsToVisibleTab]) {\n        // Revert to the permanent tab title.\n        DLog(@\"Session asking to set window title. Parent window is %@\", [_delegate parentWindow]);\n        [[_delegate parentWindow] setWindowTitle];\n    }\n}\n\n- (NSString *)jobName {\n    return [self.variablesScope valueForVariableName:iTermVariableKeySessionJob];\n}\n\n- (void)setCurrentForegroundJobProcessInfo:(iTermProcessInfo *)processInfo {\n    DLog(@\"%p set job name to %@\", self, processInfo.name);\n    NSString *name = processInfo.name;\n    NSString *processTitle = processInfo.argv0 ?: name;\n\n    // This is a gross hack but I haven't found a nicer way to do it yet. When exec fails (or takes\n    // enough time that we happen to poll it before exec finishes) then the job name is\n    // \"iTermServer\" as inherited from the parent. This avoids showing it in the UI.\n    if ([name isEqualToString:@\"iTermServer\"] && ![[self.program lastPathComponent] isEqualToString:name]) {\n        name = self.program.lastPathComponent;\n        processTitle = name;\n    }\n    [self.variablesScope setValue:name forVariableNamed:iTermVariableKeySessionJob];\n    [self.variablesScope setValue:processTitle forVariableNamed:iTermVariableKeySessionProcessTitle];\n    [self.variablesScope setValue:processInfo.commandLine forVariableNamed:iTermVariableKeySessionCommandLine];\n    [self.variablesScope setValue:@(processInfo.processID) forVariableNamed:iTermVariableKeySessionJobPid];\n\n    NSNumber *effectiveShellPID = _shell.tmuxClientProcessID ?: @(_shell.pid);\n    if (!_exited) {\n        if (effectiveShellPID.intValue > 0) {\n            [self.variablesScope setValue:effectiveShellPID\n                         forVariableNamed:iTermVariableKeySessionChildPid];\n        }\n        id oldValue = [self.variablesScope valueForVariableName:iTermVariableKeySessionEffectiveSessionRootPid];\n        if (_conductor.framing) {\n            [self.variablesScope setValue:_conductor.framedPID\n                         forVariableNamed:iTermVariableKeySessionEffectiveSessionRootPid];\n        } else if (effectiveShellPID.intValue > 0) {\n            [self.variablesScope setValue:effectiveShellPID\n                         forVariableNamed:iTermVariableKeySessionEffectiveSessionRootPid];\n        }\n        id newValue = [self.variablesScope valueForVariableName:iTermVariableKeySessionEffectiveSessionRootPid];\n        const BOOL changed = ![NSObject object:oldValue isEqualToObject:newValue];\n        if (changed) {\n            [self.delegate sessionProcessInfoProviderDidChange:self];\n        }\n    }\n    // Avoid join from side-effect.\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf tryAutoProfileSwitchWithHostname:weakSelf.variablesScope.hostname\n                                          username:weakSelf.variablesScope.username\n                                              path:weakSelf.variablesScope.path\n                                               job:processInfo.name];\n    });\n}\n\n- (void)refresh {\n    DLog(@\"Session %@ calling refresh\", self);\n    if ([_textview refresh]) {\n        self.active = YES;\n    }\n}\n\n- (void)setActive:(BOOL)active {\n    DLog(@\"setActive:%@ timerRunning=%@ updateTimer.isValue=%@ lastTimeout=%f session=%@\",\n         @(active), @(_timerRunning), @(_cadenceController.updateTimerIsValid), _lastTimeout, self);\n    _active = active;\n    _activityInfo.lastActivity = [NSDate it_timeSinceBoot];\n    [_cadenceController changeCadenceIfNeeded];\n}\n\n- (void)doAntiIdle {\n    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];\n\n    if (![self isTmuxGateway] && now >= _lastInput + _antiIdlePeriod - kAntiIdleGracePeriod) {\n        // This feature is hopeless for tmux gateways. Issue 5231.\n        [self writeLatin1EncodedData:[NSData dataWithBytes:&_antiIdleCode length:1] broadcastAllowed:NO reporting:NO];\n        _lastInput = now;\n    }\n}\n\n- (BOOL)canInstantReplayPrev\n{\n    if (_dvrDecoder) {\n        return [_dvrDecoder timestamp] != [_dvr firstTimeStamp];\n    } else {\n        return YES;\n    }\n}\n\n- (BOOL)canInstantReplayNext\n{\n    if (_dvrDecoder) {\n        return YES;\n    } else {\n        return NO;\n    }\n}\n\n- (int)rows\n{\n    return [_screen height];\n}\n\n- (int)columns\n{\n    return [_screen width];\n}\n\n- (NSFont *)fontWithRelativeSize:(int)dir from:(NSFont*)font {\n    return [font it_fontByAddingToPointSize:dir];\n}\n\n- (void)setFontTable:(iTermFontTable *)newFontTable\n   horizontalSpacing:(CGFloat)horizontalSpacing\n     verticalSpacing:(CGFloat)verticalSpacing {\n    DLog(@\"setFontTable:%@ horizontalSpacing:%@ verticalSpacing:%@\",\n         newFontTable, @(horizontalSpacing), @(verticalSpacing));\n    NSWindow *window = [[_delegate realParentWindow] window];\n    DLog(@\"Before:\\n%@\", [window.contentView iterm_recursiveDescription]);\n    DLog(@\"Window frame: %@\", window);\n    if ([_textview.fontTable isEqual:newFontTable] &&\n        [_textview horizontalSpacing] == horizontalSpacing &&\n        [_textview verticalSpacing] == verticalSpacing) {\n        // There's an unfortunate problem that this is a band-aid over.\n        // If you change some attribute of a profile that causes sessions to reload their profiles\n        // with the kReloadAllProfiles notification, then each profile will call this in turn,\n        // and it may be a no-op for all of them. If each calls -[PseudoTerminal fitWindowToTab:_delegate]\n        // and different tabs come up with slightly different ideal sizes (e.g., because they\n        // have different split pane layouts) then the window may shrink by a few pixels for each\n        // session.\n        return;\n    }\n    DLog(@\"Line height was %f\", [_textview lineHeight]);\n    [_textview setFontTable:newFontTable\n          horizontalSpacing:horizontalSpacing\n            verticalSpacing:verticalSpacing];\n    DLog(@\"Line height is now %f\", [_textview lineHeight]);\n    [_delegate sessionDidChangeFontSize:self adjustWindow:!_windowAdjustmentDisabled];\n    [_composerManager updateFont];\n    DLog(@\"After:\\n%@\", [window.contentView iterm_recursiveDescription]);\n    DLog(@\"Window frame: %@\", window);\n\n    [_view updateTrackingAreas];\n}\n\n- (BOOL)shouldShowAutoComposer {\n    if (![iTermPreferences boolForKey:kPreferenceAutoComposer]) {\n        DLog(@\"wantAutoComposer: Disabled by setting\");\n        return NO;\n    }\n    return _promptStateAllowsAutoComposer;\n}\n\n- (void)dismissComposerIfEmpty {\n    DLog(@\"dismissComposerIfEmpty called on %@\", [NSThread currentThread]);\n    if (self.composerManager.isEmpty) {\n        DLog(@\"dismissComposerifEmpty calling dismissAnimated\");\n        [self.composerManager dismissAnimated:NO];\n    }\n    DLog(@\"dismissComposerIfEmpty returning\");\n}\n\n- (void)autoComposerDidChange:(NSNotification *)notification {\n    [self sync];\n}\n\nstatic NSString *const PTYSessionComposerPrefixUserDataKeyPrompt = @\"prompt\";\nstatic NSString *const PTYSessionComposerPrefixUserDataKeyDetectedByTrigger = @\"detected by trigger\";\n\n- (NSMutableAttributedString *)kernedAttributedStringForScreenChars:(NSArray<ScreenCharArray *> *)promptText {\n    NSMutableAttributedString *prompt = [self attributedStringForScreenChars:promptText];\n    const CGFloat kern = [NSMutableAttributedString kernForString:@\"W\"\n                                                      toHaveWidth:_textview.charWidth\n                                                         withFont:_textview.fontTable.asciiFont.font];\n    [prompt addAttributes:@{ NSKernAttributeName: @(kern) }\n                    range:NSMakeRange(0, prompt.length)];\n    return prompt;\n}\n\n- (void)revealAutoComposerWithPrompt:(NSArray<ScreenCharArray *> *)promptText {\n    assert(_initializationFinished);\n    DLog(@\"Reveal auto composer. isAutoComposer <- YES\");\n    self.composerManager.isAutoComposer = YES;\n    NSMutableAttributedString *prompt = [self kernedAttributedStringForScreenChars:promptText];\n    [self.composerManager reveal];\n    NSDictionary *userData = nil;\n    DLog(@\"revealing auto composer\");\n    if (_screen.lastPromptMark.promptText) {\n        DLog(@\"Set prefix to %@\", prompt.string);\n        userData = @{\n            PTYSessionComposerPrefixUserDataKeyPrompt: [[_screen.lastPromptMark.promptText copy] autorelease],\n            PTYSessionComposerPrefixUserDataKeyDetectedByTrigger: @(_screen.lastPromptMark.promptDetectedByTrigger)\n        };\n    }\n    [self.composerManager setPrefix:prompt\n                           userData:userData];\n}\n\n- (NSMutableAttributedString *)attributedStringForScreenChars:(NSArray<ScreenCharArray *> *)promptText {\n    if (!_textview) {\n        return nil;\n    }\n    NSDictionary *defaultAttributes = [_textview attributeProviderUsingProcessedColors:YES]((screen_char_t){}, nil);\n    NSAttributedString *space = [NSAttributedString attributedStringWithString:@\" \"\n                                                                      attributes:defaultAttributes];\n\n    NSAttributedString *newline = [NSAttributedString attributedStringWithString:@\"\\n\"\n                                                                      attributes:defaultAttributes];\n\n    NSMutableAttributedString *result = [[[NSMutableAttributedString alloc] init] autorelease];\n    NSAttributedString *body = [[promptText mapWithBlock:^id _Nullable(ScreenCharArray *sca) {\n        return [sca attributedStringValueWithAttributeProvider:[_textview attributeProviderUsingProcessedColors:YES]];\n    }] attributedComponentsJoinedByAttributedString:newline];\n    [result appendAttributedString:body];\n    [result trimTrailingWhitespace];\n    [result appendAttributedString:space];\n    return result;\n}\n\n- (void)terminalFileShouldStop:(NSNotification *)notification {\n    if ([notification object] == _download) {\n        [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                 VT100ScreenMutableState *mutableState,\n                                                 id<VT100ScreenDelegate> delegate) {\n            [terminal stopReceivingFile];\n            [_download endOfData];\n            self.download = nil;\n        }];\n    } else if ([notification object] == _upload) {\n        [_pasteHelper abort];\n        [_upload endOfData];\n        self.upload = nil;\n        char controlC[1] = { VT100CC_ETX };\n        NSData *data = [NSData dataWithBytes:controlC length:sizeof(controlC)];\n        [self writeLatin1EncodedData:data broadcastAllowed:NO reporting:NO];\n    }\n}\n\n- (void)profileSessionNameDidEndEditing:(NSNotification *)notification {\n    NSString *theGuid = [notification object];\n    if (_tmuxTitleOutOfSync &&\n        [self isTmuxClient] &&\n        [theGuid isEqualToString:_profile[KEY_GUID]]) {\n        Profile *profile = [[ProfileModel sessionsInstance] bookmarkWithGuid:theGuid];\n        if (_tmuxController.canRenamePane) {\n            [_tmuxController renamePane:self.tmuxPane toTitle:profile[KEY_NAME]];\n            [_tmuxTitleMonitor updateOnce];\n        } else {\n            // Legacy code path for pre tmux 2.6\n            [_tmuxController renameWindowWithId:_delegate.tmuxWindow\n                                inSessionNumber:nil\n                                         toName:profile[KEY_NAME]];\n        }\n        _tmuxTitleOutOfSync = NO;\n    }\n}\n\n- (void)sessionHotkeyDidChange:(NSNotification *)notification {\n    NSString *theGuid = [notification object];\n    if ([self isTmuxClient] &&\n        [theGuid isEqualToString:_profile[KEY_GUID]]) {\n        Profile *profile = [[ProfileModel sessionsInstance] bookmarkWithGuid:theGuid];\n        NSDictionary *dict = [iTermProfilePreferences objectForKey:KEY_SESSION_HOTKEY inProfile:profile];\n        [_tmuxController setHotkeyForWindowPane:self.tmuxPane to:dict];\n    }\n}\n\n- (void)apiDidStop:(NSNotification *)notification {\n    [_promptSubscriptions removeAllObjects];\n    [_keystrokeSubscriptions removeAllObjects];\n    [_keyboardFilterSubscriptions removeAllObjects];\n    [_updateSubscriptions removeAllObjects];\n    [_customEscapeSequenceNotifications removeAllObjects];\n}\n\n- (void)apiServerUnsubscribe:(NSNotification *)notification {\n    [_promptSubscriptions removeObjectForKey:notification.object];\n    [_keystrokeSubscriptions removeObjectForKey:notification.object];\n    [_keyboardFilterSubscriptions removeObjectForKey:notification.object];\n    [_updateSubscriptions removeObjectForKey:notification.object];\n    [_customEscapeSequenceNotifications removeObjectForKey:notification.object];\n}\n\n- (void)applicationWillTerminate:(NSNotification *)notification {\n    // See comment where we observe this notification for why this is done.\n    [self tmuxDetach];\n}\n\n- (void)applicationDidResignActive:(NSNotification *)notification {\n    DLog(@\"%@\", self);\n    // Avoid posting a notification after switching to another app for output received just\n    // before the switch. This is tricky! self.newOutput can't be reset unconditionally because\n    // doing so breaks idle notifications when new output eventually stops being received.\n    // If you have new output and you haven't already posted a new-output notification then\n    // you can be confident that an idle notification is not forthcoming and then you can\n    // safely reset newOutput.\n    if (self.newOutput && [self.delegate sessionIsInSelectedTab:self] && !self.havePostedNewOutputNotification) {\n        DLog(@\"self.newOutput = NO\");\n        self.newOutput = NO;\n    }\n}\n\n- (void)refreshTerminal:(NSNotification *)notification {\n    [self sync];\n}\n\n- (void)metalClipViewWillScroll:(NSNotification *)notification {\n    if (_useMetal && notification.object == _textview.enclosingScrollView.contentView) {\n        [_textview shiftTrackingChildWindows];\n    }\n}\n\n- (void)alertOnMarksinOffscreenSessionsDidChange:(NSNotification *)notification {\n    DLog(@\"alertOnMarksinOffscreenSessionsDidChange for %@\", self);\n    _alertOnMarksinOffscreenSessions = [iTermPreferences boolForKey:kPreferenceKeyAlertOnMarksInOffscreenSessions];\n    [self sync];\n}\n\n- (void)windowDidMiniaturize:(NSNotification *)notification {\n    DLog(@\"windowDidMiniaturize for %@\", self);\n    if (_alertOnMarksinOffscreenSessions) {\n        [self sync];\n    }\n}\n\n- (void)activeSpaceDidChange:(NSNotification *)notification {\n    DLog(@\"activeSpaceDidChange for %@\", self);\n    if (_alertOnMarksinOffscreenSessions) {\n        [self sync];\n    }\n}\n\n- (void)savedArrangementWasRepaired:(NSNotification *)notification {\n    if ([notification.object isEqual:_naggingController.missingSavedArrangementProfileGUID]) {\n        Profile *newProfile = notification.userInfo[@\"new profile\"];\n        [self setIsDivorced:NO withDecree:@\"Saved arrangement was repaired. Set divorced to NO.\"];\n        DLog(@\"saved arrangement repaired, remove all overridden fields\");\n        [_overriddenFields removeAllObjects];\n        [_originalProfile release];\n        _originalProfile = nil;\n        self.profile = newProfile;\n        [self setPreferencesFromAddressBookEntry:newProfile];\n        [_naggingController didRepairSavedArrangement];\n    }\n}\n\n- (void)windowWillStartLiveResize:(NSNotification *)notification {\n    if ([iTermAdvancedSettingsModel trackingRunloopForLiveResize]) {\n        if (notification.object == self.textview.window) {\n            _inLiveResize = YES;\n            [_cadenceController willStartLiveResize];\n        }\n    }\n}\n\n- (void)windowDidEndLiveResize:(NSNotification *)notification {\n    if ([iTermAdvancedSettingsModel trackingRunloopForLiveResize]) {\n        if (notification.object == self.textview.window) {\n            _inLiveResize = NO;\n            [_cadenceController liveResizeDidEnd];\n        }\n    }\n}\n\n- (void)synchronizeTmuxFonts:(NSNotification *)notification {\n    if (!_exited && [self isTmuxClient]) {\n        NSArray *args = [notification object];\n        iTermFontTable *fontTable = args[0];\n        NSNumber *hSpacing = args[1];\n        NSNumber *vSpacing = args[2];\n        TmuxController *controller = args[3];\n        NSNumber *tmuxWindow = args[4];\n        if (controller == _tmuxController &&\n            (!controller.variableWindowSize || tmuxWindow.intValue == self.delegate.tmuxWindow)) {\n            [_textview setFontTable:fontTable\n                  horizontalSpacing:[hSpacing doubleValue]\n                    verticalSpacing:[vSpacing doubleValue]];\n        }\n    }\n}\n\n- (void)notifyTmuxFontChange\n{\n    static BOOL fontChangeNotificationInProgress;\n    if (!fontChangeNotificationInProgress) {\n        fontChangeNotificationInProgress = YES;\n        [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxFontChanged\n                                                            object:@[ _textview.fontTable,\n                                                                      @(_textview.horizontalSpacing),\n                                                                      @(_textview.verticalSpacing),\n                                                                      _tmuxController ?: [NSNull null],\n                                                                      @(self.delegate.tmuxWindow)]];\n        fontChangeNotificationInProgress = NO;\n        [_delegate setTmuxFontTable:_textview.fontTable\n                      hSpacing:_textview.horizontalSpacing\n                      vSpacing:_textview.verticalSpacing];\n        [[NSNotificationCenter defaultCenter] postNotificationName:kPTYSessionTmuxFontDidChange\n                                                            object:self];\n    }\n}\n\n- (void)changeFontSizeDirection:(int)dir {\n    DLog(@\"changeFontSizeDirection:%d\", dir);\n    CGFloat hs;\n    CGFloat vs;\n    iTermFontTable *newFontTable;\n    NSString *fontConfig;\n    if (dir) {\n        // Grow or shrink\n        DLog(@\"grow/shrink\");\n        newFontTable = [_textview.fontTable fontTableGrownBy:dir];\n        hs = [_textview horizontalSpacing];\n        vs = [_textview verticalSpacing];\n        fontConfig = newFontTable.configString;\n    } else {\n        // Restore original font size.\n        NSDictionary *abEntry = [self originalProfile];\n        NSString* fontDesc = [abEntry objectForKey:KEY_NORMAL_FONT];\n        fontConfig = abEntry[KEY_FONT_CONFIG];\n        newFontTable = [[iTermFontTable alloc] initWithDefaultFont:[PTYFontInfo fontInfoWithFont:[ITAddressBookMgr fontWithDesc:fontDesc]]\n                                                      nonAsciiFont:[PTYFontInfo fontInfoWithFont:[ITAddressBookMgr fontWithDesc:abEntry[KEY_NON_ASCII_FONT]]]\n                                                      configString:fontConfig];\n        hs = [iTermProfilePreferences doubleForKey:KEY_HORIZONTAL_SPACING inProfile:abEntry];\n        vs = [iTermProfilePreferences doubleForKey:KEY_VERTICAL_SPACING inProfile:abEntry];\n    }\n    [self setFontTable:newFontTable horizontalSpacing:hs verticalSpacing:vs];\n\n    if (dir || self.isDivorced) {\n        // Move this bookmark into the sessions model.\n        NSString* guid = [self divorceAddressBookEntryFromPreferences];\n\n        // Set the font in the bookmark dictionary\n        [self setSessionSpecificProfileValues:@{\n                              KEY_NORMAL_FONT: [newFontTable.asciiFont.font stringValue],\n                           KEY_NON_ASCII_FONT: [newFontTable.defaultNonASCIIFont.font stringValue] ?: [NSNull null],\n                              KEY_FONT_CONFIG: fontConfig ?: [NSNull null]\n        }];\n\n        // Update the model's copy of the bookmark.\n        [[ProfileModel sessionsInstance] setBookmark:[self profile] withGuid:guid];\n\n        // Update an existing one-bookmark prefs dialog, if open.\n        if ([[[PreferencePanel sessionsInstance] windowIfLoaded] isVisible]) {\n            [[PreferencePanel sessionsInstance] underlyingProfileDidChange];\n        }\n    }\n}\n\n- (BOOL)profileValuesDifferFromCurrentProfile:(NSDictionary *)newValues {\n    for (NSString *key in newValues) {\n        if ([key isEqualToString:KEY_GUID] || [key isEqualToString:KEY_ORIGINAL_GUID]) {\n            continue;\n        }\n        NSObject *value = newValues[key];\n        if (![NSObject object:_profile[key] isEqualToObject:value]) {\n            return YES;\n        }\n    }\n    return NO;\n}\n\n// Missing values are replaced with their defaults. If everything matches excluding deprecated keys\n// then the profiles are equivalent.\n- (BOOL)profile:(Profile *)profile1 isEffectivelyEqualToProfile:(Profile *)profile2 {\n    for (NSString *key in [iTermProfilePreferences nonDeprecatedKeys]) {\n        id value1 = [iTermProfilePreferences objectForKey:key inProfile:profile1];\n        id value2 = [iTermProfilePreferences objectForKey:key inProfile:profile2];\n\n        if ([NSObject object:value1 isEqualToObject:value2]) {\n            continue;\n        }\n        return NO;\n    }\n    return YES;\n}\n\n- (NSString *)amendedColorKey:(NSString *)baseKey {\n    return iTermAmendedColorKey(baseKey, self.profile, self.view.effectiveAppearance.it_isDark);\n}\n\n- (void)setSessionSpecificProfileValues:(NSDictionary *)newValues {\n    DLog(@\"%@: setSessionSpecificProfilevalues:%@\", self, newValues);\n    if (![self profileValuesDifferFromCurrentProfile:newValues]) {\n        DLog(@\"No changes to be made\");\n        return;\n    }\n\n    // Consider the possibility that newValues exactly matches an existing shared profile or is\n    // a modified copy of a shared profile.\n    NSString *const newGuid = newValues[KEY_GUID];\n    if (newGuid) {\n        Profile *const existingProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:newGuid];\n        if (existingProfile) {\n            DLog(@\"Switching to existing profile\");\n            // Switch to the existing profile. This will remarry if possible.\n            [self setProfile:existingProfile preservingName:NO adjustWindow:YES];\n\n            // Are we done?\n            if ([self profile:existingProfile isEffectivelyEqualToProfile:newValues]) {\n                DLog(@\"Effectively equivalent to existing profile\");\n                // Since you switched to a shared profile that is an exact match, we're done.\n                return;\n            }\n\n            // No. Divorce and modify. This takes care of making everything right, such as setting\n            // the original profile guid.\n            DLog(@\"Divorce and modify\");\n        }\n    }\n\n    // Normal case: divorce and update a subset of properties.\n    if (!self.isDivorced) {\n        [self divorceAddressBookEntryFromPreferences];\n    }\n\n    // Build a copy of the current dictionary, replacing values with those provided in newValues.\n    NSMutableDictionary* temp = [NSMutableDictionary dictionaryWithDictionary:_profile];\n    for (NSString *key in newValues) {\n        if ([key isEqualToString:KEY_GUID] || [key isEqualToString:KEY_ORIGINAL_GUID]) {\n            continue;\n        }\n        NSObject *value = newValues[key];\n        if ([value isKindOfClass:[NSNull class]]) {\n            [temp removeObjectForKey:key];\n        } else {\n            temp[key] = value;\n        }\n    }\n    if ([self profile:temp isEffectivelyEqualToProfile:_profile]) {\n        DLog(@\"Not doing anything because temp is equal to _profile\");\n        // This was a no-op, so there's no need to get a divorce. Happens most\n        // commonly when setting tab color after a split.\n        return;\n    }\n    DLog(@\"Set bookmark and reload profile\");\n    [[ProfileModel sessionsInstance] setBookmark:temp withGuid:temp[KEY_GUID]];\n\n    // Update this session's copy of the bookmark\n    [self reloadProfile];\n}\n\n- (void)remarry {\n    [self setIsDivorced:NO withDecree:[NSString stringWithFormat:@\"Remarry\"]];\n}\n\n// TBH I'm not 100% sure this is correct. Don't use it for anything critical until this whole mess\n// has been burned to the ground and rebuilt.\n- (NSString *)guidOfUnderlyingProfile {\n    if (!self.isDivorced) {\n        return self.profile[KEY_GUID];\n    }\n\n    NSString *guid = _originalProfile[KEY_GUID];\n    if (guid && [[ProfileModel sharedInstance] bookmarkWithGuid:guid]) {\n        return guid;\n    }\n\n    return nil;\n}\n\n- (BOOL)isDivorced {\n    return _divorced;\n}\n\n- (void)inheritDivorceFrom:(PTYSession *)parent decree:(NSString *)decree {\n    assert(parent);\n    [self setIsDivorced:YES withDecree:decree];\n    [_overriddenFields removeAllObjects];\n    [_overriddenFields addObjectsFromArray:parent->_overriddenFields.allObjects];\n    DLog(@\"%@: Set overridden fields from %@: %@\", self, parent, _overriddenFields);\n}\n\n- (void)setIsDivorced:(BOOL)isDivorced withDecree:(NSString *)decree {\n    _divorced = isDivorced;\n    NSString *guid = self.profile[KEY_GUID];\n    if (guid) {\n        [[ProfileModel sessionsInstance] addGuidToDebug:guid];\n    }\n    [self setDivorceDecree:[NSString stringWithFormat:@\"isDivorced=%@ Decree=%@ guid=%@ Stack:\\n%@\", @(isDivorced), decree, guid, [NSThread callStackSymbols]]];\n}\n\n- (void)setDivorceDecree:(NSString *)decree {\n    [_divorceDecree autorelease];\n    _divorceDecree = [decree copy];\n}\n\n#define DIVORCE_LOG(args...) do { \\\nDLog(args); \\\n[logs addObject:[NSString stringWithFormat:args]]; \\\n} while (0)\n\n- (NSString *)divorceAddressBookEntryFromPreferences {\n    Profile *bookmark = [self profile];\n    NSString *guid = [bookmark objectForKey:KEY_GUID];\n    if (self.isDivorced) {\n        ITAssertWithMessage([[ProfileModel sessionsInstance] bookmarkWithGuid:guid] != nil,\n                            @\"I am divorced with guid %@ but the sessions instance has no such guid. Log:\\n%@\\n\\nModel log:\\n%@\\nEnd.\",\n                            guid,\n                            _divorceDecree,\n                            [[[[ProfileModel sessionsInstance] debugHistoryForGuid:guid] componentsJoinedByString:@\"\\n\"] it_compressedString]);\n        return guid;\n    }\n    [self setIsDivorced:YES withDecree:@\"PLACEHOLDER DECREE\"];\n    NSMutableArray<NSString *> *logs = [NSMutableArray array];\n    DIVORCE_LOG(@\"Remove profile with guid %@ from sessions instance\", guid);\n    [[ProfileModel sessionsInstance] removeProfileWithGuid:guid];\n    DIVORCE_LOG(@\"Set profile %@ divorced, add to sessions instance\", bookmark[KEY_GUID]);\n    [[ProfileModel sessionsInstance] addBookmark:[[bookmark copy] autorelease]];\n\n    NSString *existingOriginalGuid = bookmark[KEY_ORIGINAL_GUID];\n    if (!existingOriginalGuid ||\n        ![[ProfileModel sharedInstance] bookmarkWithGuid:existingOriginalGuid] ||\n        ![existingOriginalGuid isEqualToString:_originalProfile[KEY_GUID]]) {\n        // The bookmark doesn't already have a valid original GUID.\n        bookmark = [[ProfileModel sessionsInstance] setObject:guid\n                                                       forKey:KEY_ORIGINAL_GUID\n                                                   inBookmark:bookmark];\n    }\n\n    // Allocate a new guid for this bookmark.\n    guid = [ProfileModel freshGuid];\n    DIVORCE_LOG(@\"Allocating a new guid for this profile. The new guid is %@\", guid);\n    [[ProfileModel sessionsInstance] addGuidToDebug:guid];\n    [[ProfileModel sessionsInstance] setObject:guid\n                                        forKey:KEY_GUID\n                                    inBookmark:bookmark];\n    [_overriddenFields removeAllObjects];\n    [_overriddenFields addObjectsFromArray:@[ KEY_GUID, KEY_ORIGINAL_GUID] ];\n    [self setProfile:[[ProfileModel sessionsInstance] bookmarkWithGuid:guid]];\n    [logs addObject:@\"Stack trace:\"];\n    [logs addObject:[[NSThread callStackSymbols] componentsJoinedByString:@\"\\n\"]];\n    [self setDivorceDecree:[logs componentsJoinedByString:@\"\\n\"]];\n    DLog(@\"%p: divorce. overridden fields are now %@\", self, _overriddenFields);\n    return guid;\n}\n\n- (void)refreshOverriddenFields {\n    [self sessionProfileDidChange];\n}\n\n// Jump to the saved scroll position\n- (void)jumpToSavedScrollPosition {\n    id<VT100ScreenMarkReading> mark = [_screen lastMark];\n    Interval *interval = mark.entry.interval;\n    if (!interval) {\n        DLog(@\"Beep: Can't jump to bad interval\");\n        NSBeep();\n        return;\n    }\n    VT100GridRange range = [_screen lineNumberRangeOfInterval:interval];\n    long long offset = range.location;\n    if (offset < 0) {\n        DLog(@\"Beep: Can't jump to negative offset\");\n        NSBeep();  // This really shouldn't ever happen\n    } else {\n        self.currentMarkOrNotePosition = mark.entry.interval;\n        offset += [_screen totalScrollbackOverflow];\n        [_textview scrollToAbsoluteOffset:offset height:[_screen height]];\n        [_textview highlightMarkOnLine:VT100GridRangeMax(range) hasErrorCode:NO];\n    }\n}\n\n- (void)setCurrentMarkOrNotePosition:(Interval *)currentMarkOrNotePosition {\n    [_currentMarkOrNotePosition autorelease];\n    _currentMarkOrNotePosition = [currentMarkOrNotePosition retain];\n    ITBetaAssert(currentMarkOrNotePosition.limit >= 0, @\"Negative limit in current mark or note %@\", currentMarkOrNotePosition);\n}\n\n- (BOOL)hasSavedScrollPosition\n{\n    return [_screen lastMark] != nil;\n}\n\n- (void)findPasteboardStringDidChangeTo:(NSString *)string {\n    if ([_view.findDriver.findString isEqualToString:string]) {\n        return;\n    }\n    if (!_view.findDriver.shouldSearchAutomatically) {\n        return;\n    }\n    [_view.findDriver highlightWithoutSelectingSearchResultsForQuery:string];\n}\n\n- (void)findWithSelection {\n    if ([_textview selectedText]) {\n        [_view.findDriver setFindStringUnconditionally:_textview.selectedText];\n    }\n}\n\n- (void)showFindPanel {\n    [_view showFindUI];\n}\n\n- (void)showFilter {\n    [_view showFilter];\n}\n\n- (iTermComposerManager *)composerManager {\n    if (!_composerManager) {\n        _composerManager = [[iTermComposerManager alloc] init];\n        _composerManager.delegate = self;\n    }\n    return _composerManager;\n}\n\n- (void)compose {\n    if (self.currentCommand.length > 0) {\n        [self setComposerString:self.currentCommand];\n    }\n    [self.composerManager toggle];\n}\n\n- (void)setComposerString:(NSString *)string {\n    [self sendHexCode:[iTermAdvancedSettingsModel composerClearSequence]];\n    [self.composerManager setCommand:string];\n}\n\n- (BOOL)closeComposer {\n    if (_composerManager.isAutoComposer) {\n        // We don't want cmd-W to close the auto composer because it'll just open back up immediately.\n        return NO;\n    }\n    return [_composerManager dismiss];\n}\n\n// Note that the caller is responsible for respecting swapFindNextPrevious\n- (void)searchNext {\n    [_view createFindDriverIfNeeded];\n    [_view.findDriver searchNext];\n    [self beginOneShotTailFind];\n}\n\n// Note that the caller is responsible for respecting swapFindNextPrevious\n- (void)searchPrevious {\n    [_view createFindDriverIfNeeded];\n    [_view.findDriver searchPrevious];\n    [self beginOneShotTailFind];\n}\n\n- (void)resetFindCursor {\n    [_textview resetFindCursor];\n}\n\n- (BOOL)findInProgress {\n    return [_textview findInProgress];\n}\n\n- (BOOL)continueFind:(double *)progress range:(NSRange *)rangePtr {\n    return [_textview continueFind:progress range:rangePtr];\n}\n\n- (BOOL)growSelectionLeft {\n    return [_textview growSelectionLeft];\n}\n\n- (void)growSelectionRight {\n    [_textview growSelectionRight];\n}\n\n- (NSString *)selectedText {\n    return [_textview selectedText];\n}\n\n- (BOOL)canSearch {\n    return _textview != nil && _delegate && [_delegate realParentWindow];\n}\n\n- (void)findString:(NSString *)aString\n  forwardDirection:(BOOL)direction\n              mode:(iTermFindMode)mode\n        withOffset:(int)offset\nscrollToFirstResult:(BOOL)scrollToFirstResult {\n    DLog(@\"self=%@ aString=%@\", self, aString);\n    [_textview findString:aString\n         forwardDirection:direction\n                     mode:mode\n               withOffset:offset\n      scrollToFirstResult:scrollToFirstResult];\n}\n\n- (NSString *)unpaddedSelectedText {\n    return [_textview selectedText];\n}\n\n- (void)copySelection {\n    return [_textview copySelectionAccordingToUserPreferences];\n}\n\n- (void)takeFocus {\n    [[[_delegate realParentWindow] window] makeFirstResponder:_textview];\n}\n\n- (void)findViewControllerMakeDocumentFirstResponder {\n    [self takeFocus];\n}\n\n- (void)findViewControllerClearSearch {\n    DLog(@\"begin\");\n    [_textview clearHighlights:YES];\n}\n\n- (void)findViewControllerVisibilityDidChange:(id<iTermFindViewController>)sender {\n    [_delegate sessionUpdateMetalAllowed];\n    if (sender.driver.isVisible) {\n        return;\n    }\n    if (_view.findViewHasKeyboardFocus) {\n        [_view findViewDidHide];\n    }\n}\n\n- (void)setFilter:(NSString *)filter {\n    _modeHandler.mode = iTermSessionModeDefault;\n    DLog(@\"setFilter:%@\", filter);\n    if ([filter isEqualToString:_filter]) {\n        return;\n    }\n    VT100Screen *source = nil;\n    if ([_asyncFilter canRefineWithQuery:filter]) {\n        source = self.screen;\n    } else {\n        source = self.liveSession.screen;\n    }\n    [_asyncFilter cancel];\n    [self.liveSession removeContentSubscriber:_asyncFilter];\n    const BOOL replacingFilter = (_filter != nil);\n    assert(self.liveSession);\n\n    [_filter autorelease];\n    _filter = [filter copy];\n\n    iTermAsyncFilter *refining = [[_asyncFilter retain] autorelease];\n    [_asyncFilter release];\n\n    DLog(@\"Append lines from %@\", self.liveSession);\n    __weak __typeof(self) weakSelf = self;\n    _asyncFilter = [source newAsyncFilterWithDestination:self\n                                                   query:filter\n                                                refining:refining\n                                                progress:^(double progress) {\n        [weakSelf setFilterProgress:progress];\n    }];\n    [self.liveSession addContentSubscriber:_asyncFilter];\n    if (replacingFilter) {\n        DLog(@\"Clear buffer because there is a pre-existing filter\");\n        [self.screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            [mutableState clearBufferWithoutTriggersSavingPrompt:NO];\n        }];\n    }\n    [_asyncFilter start];\n}\n\n- (void)setFilterProgress:(double)progress {\n    _view.findDriver.filterProgress = progress;\n    _statusBarViewController.filterViewController.filterProgress = progress;\n}\n\n- (void)findDriverFilterVisibilityDidChange:(BOOL)visible {\n    if (!visible) {\n        [_asyncFilter cancel];\n        [self.liveSession removeContentSubscriber:_asyncFilter];\n        [_asyncFilter autorelease];\n        _asyncFilter = nil;\n        PTYSession *liveSession = [[self.liveSession retain] autorelease];\n        [self.delegate session:self setFilter:nil];\n        [liveSession.view.findDriver close];\n    }\n}\n\n- (void)findDriverSetFilter:(NSString *)filter withSideEffects:(BOOL)withSideEffects{\n    if (withSideEffects) {\n        [self.delegate session:self setFilter:filter];\n    }\n}\n\n- (void)findViewControllerDidCeaseToBeMandatory:(id<iTermFindViewController>)sender {\n    [_view findViewDidHide];\n}\n\n- (void)findDriverInvalidateFrame {\n    [_view findDriverInvalidateFrame];\n}\n\n- (NSImage *)snapshot {\n    DLog(@\"Session %@ calling refresh\", self);\n    [_textview refresh];\n    return [_view snapshot];\n}\n\n- (NSImage *)snapshotCenteredOn:(VT100GridAbsCoord)coord size:(NSSize)size {\n    if (_screen.totalScrollbackOverflow > coord.y) {\n        return nil;\n    }\n    VT100GridCoord relativeCoord = VT100GridCoordMake(coord.x,\n                                                      coord.y - _screen.totalScrollbackOverflow);\n    NSPoint centerPoint = [_textview pointForCoord:relativeCoord];\n    NSRect rect = NSMakeRect(MIN(MAX(0, centerPoint.x - size.width / 2), NSWidth(_textview.bounds)),\n                             MIN(MAX(0, centerPoint.y - size.height / 2), NSHeight(_textview.bounds)),\n                             MIN(NSWidth(_textview.bounds), size.width),\n                             MIN(NSHeight(_textview.bounds), size.height));\n    CGFloat overage = NSMaxX(rect) - NSWidth(_textview.bounds);\n    if (overage > 0) {\n        rect.origin.x -= overage;\n    }\n\n    overage = NSMaxY(rect) - NSHeight(_textview.bounds);\n    if (overage > 0) {\n        rect.origin.y -= overage;\n    }\n\n    return [_textview snapshotOfRect:rect];\n}\n\n- (NSInteger)findDriverNumberOfSearchResults {\n    return _textview.findOnPageHelper.numberOfSearchResults;\n}\n\n- (NSInteger)findDriverCurrentIndex {\n    return _textview.findOnPageHelper.currentIndex;\n}\n\n#pragma mark - Metal Support\n\n#pragma mark iTermMetalGlueDelegate\n\n- (iTermImageWrapper *)metalGlueBackgroundImage {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return _backgroundImage;\n    } else {\n        return [self.delegate sessionBackgroundImage];\n    }\n}\n\n- (iTermBackgroundImageMode)metalGlueBackgroundImageMode {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return _backgroundImageMode;\n    } else {\n        return [self.delegate sessionBackgroundImageMode];\n    }\n}\n\n- (CGFloat)metalGlueBackgroundImageBlend {\n    return [self effectiveBlend];\n}\n\n- (void)metalGlueDidDrawFrameAndNeedsRedraw:(BOOL)redrawAsap NS_AVAILABLE_MAC(10_11) {\n    if (_view.useMetal) {\n        if (redrawAsap) {\n            [_textview setNeedsDisplay:YES];\n        }\n    }\n}\n\n- (CGContextRef)metalGlueContext {\n    return _metalContext;\n}\n\n+ (CGColorSpaceRef)metalColorSpace {\n    static dispatch_once_t onceToken;\n    static CGColorSpaceRef colorSpace;\n    dispatch_once(&onceToken, ^{\n        colorSpace = CGColorSpaceCreateDeviceRGB();\n        ITAssertWithMessage(colorSpace, @\"Colorspace is %@\", colorSpace);\n    });\n    return colorSpace;\n}\n\n+ (CGContextRef)onePixelContext {\n    static CGContextRef context;\n    if (context == NULL) {\n        context = CGBitmapContextCreate(NULL,\n                                        1,\n                                        1,\n                                        8,\n                                        1 * 4,\n                                        [self metalColorSpace],\n                                        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);\n    }\n    return context;\n}\n\n- (void)setMetalContextSize:(CGSize)size {\n    DLog(@\"%@\", self);\n    if (!self.textview.window) {\n        DLog(@\"No window\");\n        CGContextRelease(_metalContext);\n        _metalContext = NULL;\n        return;\n    }\n\n    const CGFloat scale = self.textview.window.backingScaleFactor;\n    const int radius = (iTermTextureMapMaxCharacterParts / 2) * 2 + 1;\n    CGSize scaledSize = CGSizeMake(size.width * scale * radius, size.height * scale * radius);\n    if (_metalContext) {\n        if (CGSizeEqualToSize(scaledSize, CGSizeMake(CGBitmapContextGetWidth(_metalContext),\n                                                     CGBitmapContextGetHeight(_metalContext)))) {\n            DLog(@\"No size change\");\n            return;\n        }\n        CGContextRelease(_metalContext);\n        _metalContext = NULL;\n    }\n    DLog(@\"allocate new metal context of size %@\", NSStringFromSize(scaledSize));\n    _metalContext = CGBitmapContextCreate(NULL,\n                                          scaledSize.width,\n                                          scaledSize.height,\n                                          8,\n                                          scaledSize.width * 4,  // bytes per row\n                                          [PTYSession metalColorSpace],\n                                          kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);\n}\n\n- (BOOL)metalAllowed {\n    return [self metalAllowed:nil];\n}\n\n- (BOOL)usingIntegratedGPU {\n    if (_view.metalView.device != nil) {\n        const BOOL result = _view.metalView.device.isLowPower;\n        DLog(@\"usingIntegratedGPU=%@\", @(result));\n        return result;\n    }\n    for (PseudoTerminal *term in [[iTermController sharedInstance] terminals]) {\n        for (PTYSession *session in term.allSessions) {\n            if (session.view.metalView.device != nil) {\n                const BOOL result = session.view.metalView.device.isLowPower;\n                DLog(@\"Found another session %p with a metal device, usingIntegratedGPU=%@\", session, @(result));\n                return result;\n            }\n        }\n    }\n\n    DLog(@\"Check if the system has an integrated GPU\");\n    static BOOL haveIntegrated;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        NSArray<id<MTLDevice>> *devices = MTLCopyAllDevices();\n        haveIntegrated = NO;\n        for (id<MTLDevice> device in devices) {\n            if (device.isLowPower) {\n                haveIntegrated = YES;\n                break;\n            }\n        }\n        CFRelease(devices);\n    });\n    DLog(@\"No sessions using GPU. Return %@.\", @(haveIntegrated));\n    return haveIntegrated;\n}\n\n- (BOOL)metalAllowed:(out iTermMetalUnavailableReason *)reason {\n    static dispatch_once_t onceToken;\n    static BOOL machineSupportsMetal;\n    dispatch_once(&onceToken, ^{\n        NSArray<id<MTLDevice>> *devices = MTLCopyAllDevices();\n        machineSupportsMetal = devices.count > 0;\n        [devices release];\n    });\n    if (@available(macOS 12.0, *)) {\n        if ([iTermPreferences boolForKey:kPreferenceKeyDisableInLowPowerMode] &&\n            [[NSProcessInfo processInfo] isLowPowerModeEnabled]) {\n            if (reason) {\n                *reason = iTermMetalUnavailableReasonLowerPowerMode;\n            }\n            return NO;\n        }\n    }\n    if (!machineSupportsMetal) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonNoGPU;\n        }\n        return NO;\n    }\n    if (![iTermPreferences boolForKey:kPreferenceKeyUseMetal]) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonDisabled;\n        }\n        return NO;\n    }\n    if (!self.view.window) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonSessionHasNoWindow;\n        }\n        return NO;\n    }\n    if ([PTYSession onePixelContext] == nil) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonContextAllocationFailure;\n        }\n        return NO;\n    }\n    if ([self ligaturesEnabledInEitherFont]) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonLigatures;\n        }\n        return NO;\n    }\n    if (_metalDeviceChanging) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonInitializing;\n        }\n        return NO;\n    }\n    if (![self metalViewSizeIsLegal]) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonInvalidSize;\n        }\n        return NO;\n    }\n    if (!_textview) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonSessionInitializing;\n        }\n        return NO;\n    }\n    if (_textview.drawingHelper.showDropTargets) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonDropTargetsVisible;\n        }\n        return NO;\n    }\n    // Use window occlusion because of issue 9174 but only for integrated GPUs because of issue 9044.\n    if ([self usingIntegratedGPU] &&\n        [_delegate.realParentWindow.ptyWindow approximateFractionOccluded] > 0.5) {\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonWindowObscured;\n        }\n        return NO;\n    }\n    if ([PTYNoteViewController anyNoteVisible] || _textview.contentNavigationShortcuts.count > 0) {\n        // When metal is enabled the note's superview (PTYTextView) has alphaValue=0 so it will not be visible.\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonAnnotations;\n        }\n        return NO;\n    }\n    if (_textview.hasPortholes) {\n        // When metal is enabled the note's superview (PTYTextView) has alphaValue=0 so it will not be visible.\n        if (reason) {\n            *reason = iTermMetalUnavailableReasonPortholes;\n        }\n        return NO;\n    }\n    if (_textview.transparencyAlpha < 1) {\n        BOOL transparencyAllowed = NO;\n#if ENABLE_TRANSPARENT_METAL_WINDOWS\n        if (iTermTextIsMonochrome()) {\n            transparencyAllowed = YES;\n        }\n#endif\n        if (!transparencyAllowed && _textview.transparencyAlpha < 1) {\n            if (reason) {\n                *reason = iTermMetalUnavailableReasonTransparency;\n            }\n            return NO;\n        }\n    }\n    return YES;\n}\n\n- (BOOL)canProduceMetalFramecap {\n    return _useMetal && _view.metalView.alphaValue == 1 && _wrapper.useMetal && _textview.suppressDrawing;\n}\n\n- (BOOL)metalViewSizeIsLegal NS_AVAILABLE_MAC(10_11) {\n    NSSize size = _view.frame.size;\n    // See \"Maximum 2D texture width and height\" in \"Implementation Limits\". Pick the smallest value\n    // among the \"Mac\" columns.\n    // https://developer.apple.com/metal/Metal-Feature-Set-Tables.pdf\n    const CGFloat maxScale = 2;\n    return size.width > 0 && size.width < (PTYSessionMaximumMetalViewSize / maxScale) && size.height > 0 && size.height < (PTYSessionMaximumMetalViewSize / maxScale);\n}\n\n- (BOOL)idleForMetal {\n    return (!_cadenceController.isActive &&\n            !_view.verticalScroller.userScroll &&\n            !self.overrideGlobalDisableMetalWhenIdleSetting &&\n            !_view.driver.captureDebugInfoForNextFrame);\n}\n\n- (BOOL)ligaturesEnabledInEitherFont {\n    iTermTextDrawingHelper *helper = _textview.drawingHelper;\n    [helper updateCachedMetrics];\n    if (helper.asciiLigatures && helper.asciiLigaturesAvailable) {\n        return YES;\n    }\n    if ([iTermProfilePreferences boolForKey:KEY_USE_NONASCII_FONT inProfile:self.profile] &&\n        [iTermProfilePreferences boolForKey:KEY_NON_ASCII_LIGATURES inProfile:self.profile]) {\n        return YES;\n    }\n    return NO;\n}\n\n- (BOOL)willEnableMetal {\n    DLog(@\"%@\", self);\n    [self updateMetalDriver];\n    return _metalContext != nil;\n}\n\n- (void)setUseMetal:(BOOL)useMetal {\n    if (useMetal == _useMetal) {\n        return;\n    }\n    DLog(@\"setUseMetal:%@ %@\", @(useMetal), self);\n    _useMetal = useMetal;\n    // The metalview's alpha will initially be 0. Once it has drawn a frame we'll swap what is visible.\n    [self setUseMetal:useMetal dataSource:_metalGlue];\n    if (useMetal) {\n        [self updateMetalDriver];\n        // wrapper.useMetal becomes YES after the first frame is done drawing\n    } else {\n        _wrapper.useMetal = NO;\n        [_metalDisabledTokens removeAllObjects];\n        if (_metalContext) {\n            // If metal is re-enabled later, it must not use the same context.\n            // It's possible that a metal driver thread has survived this point\n            // and will continue to use the context.\n            CGContextRelease(_metalContext);\n            _metalContext = NULL;\n        }\n    }\n    [_textview setNeedsDisplay:YES];\n    [_cadenceController changeCadenceIfNeeded];\n\n    if (useMetal) {\n        [self renderTwoMetalFramesAndShowMetalView];\n    } else {\n        _view.metalView.enableSetNeedsDisplay = NO;\n    }\n}\n\n- (void)renderTwoMetalFramesAndShowMetalView NS_AVAILABLE_MAC(10_11) {\n    // The first frame will be slow to draw. The second frame will be very\n    // recent to minimize jitter. For reasons I haven't understood yet it seems\n    // the first frame is sometimes transparent. I haven't seen that issue with\n    // the second frame yet.\n    [self renderMetalFramesAndShowMetalView:2];\n}\n\n- (void)renderMetalFramesAndShowMetalView:(NSInteger)count {\n    if (_useMetal) {\n        DLog(@\"Begin async draw %@ for %@\", @(count), self);\n        [_view.driver drawAsynchronouslyInView:_view.metalView completion:^(BOOL ok) {\n            if (!_useMetal || _exited) {\n                DLog(@\"Finished async draw but metal off/exited for %@\", self);\n                return;\n            }\n\n            if (!ok) {\n                DLog(@\"Finished async draw NOT OK for %@\", self);\n                // Wait 10ms to avoid burning CPU if it failed because it's slow to draw the first frame.\n                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.01 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n                    [self renderMetalFramesAndShowMetalView:count];\n                });\n                return;\n            }\n\n            if (count <= 1) {\n                DLog(@\"Finished async draw ok for %@\", self);\n                [self showMetalViewImmediately];\n            } else {\n                [self renderMetalFramesAndShowMetalView:count - 1];\n            }\n        }];\n    }\n}\n\n- (void)showMetalViewImmediately {\n    if (!_useMetal) {\n        DLog(@\"Declining to show metal view immediately in %@ because useMetal is NO\", self);\n        return;\n    }\n    if (_view.metalView.bounds.size.width == 0 || _view.metalView.bounds.size.height == 0) {\n        DLog(@\"Declining to show metal view immediately in %@ because the view's size is %@\", self, NSStringFromSize(_view.metalView.bounds.size));\n        return;\n    }\n    if (_textview == nil) {\n        DLog(@\"Declining to show metal view immediately in %@ because the textview is nil\", self);\n        return;\n    }\n    if (_textview.dataSource == nil) {\n        DLog(@\"Declining to show metal view immediately in %@ because the textview's datasource is nil\", self);\n        return;\n    }\n    if (_screen.width == 0 || _screen.height == 0) {\n        DLog(@\"Declining to show metal view immediately in %@ because the screen's size is %@x%@. Screen is %@\",\n             self, _textview.dataSource, @(_screen.width), @(_screen.height));\n        return;\n    }\n    [self reallyShowMetalViewImmediately];\n}\n\n- (void)reallyShowMetalViewImmediately {\n    DLog(@\"reallyShowMetalViewImmediately\");\n    [_view setNeedsDisplay:YES];\n    [self showMetalAndStopDrawingTextView];\n    _view.metalView.enableSetNeedsDisplay = YES;\n}\n\n- (void)showMetalAndStopDrawingTextView NS_AVAILABLE_MAC(10_11) {\n    // If the text view had been visible, hide it. Hiding it before the\n    // first frame is drawn causes a flash of gray.\n    DLog(@\"showMetalAndStopDrawingTextView\");\n    _wrapper.useMetal = YES;\n    _textview.suppressDrawing = YES;\n    [_view setSuppressLegacyDrawing:YES];\n    if (PTYScrollView.shouldDismember) {\n        _view.scrollview.alphaValue = 0;\n    } else {\n        _view.scrollview.contentView.alphaValue = 0;\n    }\n    [self setMetalViewAlphaValue:1];\n}\n\n- (void)setMetalViewAlphaValue:(CGFloat)alphaValue {\n    _view.metalView.alphaValue = alphaValue;\n    [_view didChangeMetalViewAlpha];\n    [self.delegate sessionDidChangeMetalViewAlphaValue:self to:alphaValue];\n}\n\n- (void)setUseMetal:(BOOL)useMetal dataSource:(id<iTermMetalDriverDataSource>)dataSource NS_AVAILABLE_MAC(10_11) {\n    [_view setUseMetal:useMetal dataSource:dataSource];\n    if (!useMetal) {\n        _textview.suppressDrawing = NO;\n        [_view setSuppressLegacyDrawing:NO];\n        if (PTYScrollView.shouldDismember) {\n            _view.scrollview.alphaValue = 1;\n        } else {\n            _view.scrollview.contentView.alphaValue = 1;\n        }\n    }\n}\n\n- (void)updateMetalDriver NS_AVAILABLE_MAC(10_11) {\n    DLog(@\"%@\", self);\n    const CGSize cellSize = CGSizeMake(_textview.charWidth, _textview.lineHeight);\n    CGSize glyphSize;\n    const CGFloat scale = _view.window.backingScaleFactor ?: 1;\n    NSRect rect = [iTermCharacterSource boundingRectForCharactersInRange:NSMakeRange(32, 127-32)\n                                                               fontTable:_textview.fontTable\n                                                                   scale:scale\n                                                             useBoldFont:_textview.useBoldFont\n                                                           useItalicFont:_textview.useItalicFont\n                                                        usesNonAsciiFont:_textview.useNonAsciiFont\n                                                                 context:[PTYSession onePixelContext]];\n    CGSize asciiOffset = CGSizeZero;\n    if (rect.origin.y < 0) {\n        // Iosevka Light is the only font I've found that needs this.\n        // It rides *very* low in its box. The lineheight that PTYFontInfo calculates is actually too small\n        // to contain the glyphs (it uses a weird algorithm that was discovered \"organically\").\n        // There are gobs of empty pixels at the top, so we shift all its ASCII glyphs a bit so they'll\n        // fit. Non-ASCII characters may take multiple parts and so can properly extend beyond their\n        // cell, so we only need to think about ASCII. In other words, this hack shifts the character up\n        // *in the texture* to make better use of space without using a larger glyph size.\n        //\n        // In a monochrome world, this is still necessary because even though glyph size and cell\n        // size are no longer required to be the same, part of the glyph will be drawn outside its\n        // bounds and get clipped in the texture.\n        asciiOffset.height = -floor(rect.origin.y * scale);\n    }\n    if (iTermTextIsMonochrome() && rect.origin.x < 0) {\n        // AnonymousPro has a similar problem (issue 8185), e.g. with \"W\".\n        // There is a subtle difference, though! The monochrome code path assumes that glyphs are\n        // left-aligned in their glyphSize-sized chunk of the texture. Setting the asciiOffset here\n        // causes them to all be rendered a few pixels to the right so that this assumption will be\n        // true. The quad is then shifted left by a corresponding amount when rendering so it ends\n        // up drawn in the right place.\n        //\n        // When doing subpixel antialiasing, this is not an issue because it deals with multipart\n        // ASCII glyphs differently. It splits them into pieces and draws them as separate instances.\n        //\n        // Changing the assumption that glyphs are left-aligned would be very complex, and I can't\n        // afford to add more risk right now. This is less than beautiful, but it's quite safe.\n        asciiOffset.width = -floor(rect.origin.x * scale);\n    }\n    if (iTermTextIsMonochrome()) {\n        // Mojave can use a glyph size larger than cell size because compositing is trivial without subpixel AA.\n        glyphSize.width = round(0.49 + MAX(cellSize.width, NSMaxX(rect)));\n        glyphSize.height = round(0.49 + MAX(cellSize.height, NSMaxY(rect)));\n    } else {\n        glyphSize = cellSize;\n    }\n    [self setMetalContextSize:glyphSize];\n    if (!_metalContext) {\n        DLog(@\"%p Failed to allocate metal context. Disable metal and try again in 1 second.\", self);\n        if (_errorCreatingMetalContext) {\n            DLog(@\"Already have a retry queued.\");\n            return;\n        }\n        _errorCreatingMetalContext = YES;\n        [self.delegate sessionUpdateMetalAllowed];\n        if (!_useMetal) {\n            DLog(@\"Failed to create context for %@ but metal is not allowed\", self);\n            return;\n        }\n        DLog(@\"Failed to create context for %@. schedule retry\", self);\n        __weak __typeof(self) weakSelf = self;\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)),\n                       dispatch_get_main_queue(), ^{\n            [weakSelf retryMetalAfterContextAllocationFailure];\n        });\n        return;\n    }\n    [_view.driver setCellSize:cellSize\n       cellSizeWithoutSpacing:CGSizeMake(_textview.charWidthWithoutSpacing, _textview.charHeightWithoutSpacing)\n                    glyphSize:glyphSize\n                     gridSize:_screen.currentGrid.size\n                  asciiOffset:asciiOffset\n                        scale:_view.window.screen.backingScaleFactor\n                      context:_metalContext\n         legacyScrollbarWidth:self.legacyScrollbarWidth];\n}\n\n- (CGFloat)legacyScrollbarWidth {\n    if (_view.scrollview.scrollerStyle != NSScrollerStyleLegacy) {\n        return 0;\n    }\n    return NSWidth(_view.scrollview.bounds) - NSWidth(_view.scrollview.contentView.bounds);\n}\n\n- (void)retryMetalAfterContextAllocationFailure {\n    DLog(@\"%p It's been one second since trying to allocate a metal context failed. Try again.\", self);\n    if (!_errorCreatingMetalContext) {\n        DLog(@\"Oddly, errorCreatingMetalContext is NO\");\n        return;\n    }\n    DLog(@\"%p reset error state\", self);\n    _errorCreatingMetalContext = NO;\n    [self updateMetalDriver];\n    if (_metalContext) {\n        DLog(@\"A metal context was allocated. Try to turn metal on for this tab.\");\n        [self.delegate sessionUpdateMetalAllowed];\n    } else {\n        DLog(@\"Failed to allocate context again. A retry should have been scheduled.\");\n    }\n}\n\n#pragma mark - Password Management\n\n- (BOOL)canOpenPasswordManager {\n    [self sync];\n    return !_screen.echoProbeIsActive;\n}\n\n- (void)enterPassword:(NSString *)password {\n    [self incrementDisableFocusReporting:1];\n    [_screen beginEchoProbeWithBackspace:[self backspaceData] password:password delegate:self];\n}\n\n- (NSImage *)dragImage\n{\n    NSImage *image = [self snapshot];\n    // Dial the alpha down to 50%\n    NSImage *dragImage = [[[NSImage alloc] initWithSize:[image size]] autorelease];\n    [dragImage lockFocus];\n    [image drawAtPoint:NSZeroPoint\n              fromRect:NSZeroRect\n             operation:NSCompositingOperationSourceOver\n              fraction:0.5];\n    [dragImage unlockFocus];\n    return dragImage;\n}\n\n- (void)setPasteboard:(NSString *)pbName {\n    if (pbName) {\n        [_pasteboard autorelease];\n        _pasteboard = [pbName copy];\n        [_pbtext release];\n        _pbtext = [[NSMutableData alloc] init];\n    } else {\n        NSPasteboard *pboard = [NSPasteboard pasteboardWithName:_pasteboard];\n        [pboard declareTypes:@[ NSPasteboardTypeString ] owner:self];\n        [pboard setData:_pbtext forType:NSPasteboardTypeString];\n\n        [_pasteboard release];\n        _pasteboard = nil;\n        [_pbtext release];\n        _pbtext = nil;\n\n        // In case it was the find pasteboard that changed\n        [[iTermFindPasteboard sharedInstance] updateObservers:self];\n    }\n}\n\n- (void)stopCoprocess\n{\n    [_shell stopCoprocess];\n}\n\n- (BOOL)hasCoprocess\n{\n    return [_shell hasCoprocess];\n}\n\n- (void)launchCoprocessWithCommand:(NSString *)command mute:(BOOL)mute {\n    DLog(@\"Launch coprocess with command %@. Mute=%@\", command, @(mute));\n    Coprocess *coprocess = [Coprocess launchedCoprocessWithCommand:command\n                                                       environment:[self environmentForNewJobFromEnvironment:self.environment\n                                                                                               substitutions:self.substitutions]];\n    coprocess.delegate = self.weakSelf;\n    coprocess.mute = mute;\n    [_shell setCoprocess:coprocess];\n    [_textview setNeedsDisplay:YES];\n}\n\n- (void)launchSilentCoprocessWithCommand:(NSString *)command\n{\n    [self launchCoprocessWithCommand:command mute:YES];\n}\n\n- (void)performBlockWithoutFocusReporting:(void (^NS_NOESCAPE)(void))block {\n    [self incrementDisableFocusReporting:1];\n    block();\n    [self incrementDisableFocusReporting:-1];\n}\n\n- (void)incrementDisableFocusReporting:(NSInteger)delta {\n    DLog(@\"delta=%@ count %@->%@\\n%@\", @(delta), @(_disableFocusReporting), @(_disableFocusReporting + delta), self);\n    _disableFocusReporting += delta;\n    if (_disableFocusReporting == 0) {\n        [self setFocused:[self textViewOrComposerIsFirstResponder]];\n    }\n}\n\n- (void)setFocused:(BOOL)focused {\n    DLog(@\"setFocused:%@ self=%@\", @(focused), self);\n    if (_disableFocusReporting) {\n        DLog(@\"Focus reporting disabled\");\n        return;\n    }\n    if ([self.delegate sessionPasswordManagerWindowIsOpen]) {\n        DLog(@\"Password manager window is open\");\n        return;\n    }\n    if (focused == _focused) {\n        DLog(@\"No change\");\n        return;\n    }\n    if (_alertOnMarksinOffscreenSessions && [self.delegate hasMaximizedPane]) {\n        DLog(@\"Sync because _alertOnMarksinOffscreenSessions and maximized\");\n        [self sync];\n    }\n    if (self.isTmuxGateway) {\n        DLog(@\"Is tmux gateway\");\n        return;\n    }\n    _focused = focused;\n    if (_screen.terminalReportFocus) {\n        DLog(@\"Will report focus\");\n        _reportingFocus = YES;\n        self.lastFocusReportDate = [NSDate date];\n        // This is not considered reporting because it's not in response to a remote request.\n        [self writeLatin1EncodedData:[_screen.terminalOutput reportFocusGained:focused] broadcastAllowed:NO reporting:NO];\n        _reportingFocus = NO;\n    }\n    if (focused && [self isTmuxClient]) {\n        DLog(@\"Tell tmux about focus change\");\n        [_tmuxController selectPane:self.tmuxPane];\n        [self.delegate sessionDidReportSelectedTmuxPane:self];\n    }\n}\n\n- (BOOL)wantsContentChangedNotification\n{\n    // We want a content change notification if it's worth doing a tail find.\n    // That means the find window is open, we're not already doing a tail find,\n    // and a search was performed in the find window (vs select+cmd-e+cmd-f).\n    return (!_tailFindTimer &&\n            !_view.findViewIsHidden &&\n            [_textview findContext].substring != nil);\n}\n\n- (void)hideSession {\n    [self bury];\n}\n\n- (NSString *)preferredTmuxClientName {\n    id<VT100RemoteHostReading> remoteHost = [self currentHost];\n    if (remoteHost) {\n        return [NSString stringWithFormat:@\"%@@%@\", remoteHost.username, remoteHost.hostname];\n    } else {\n        NSString *name = [_nameController.presentationSessionTitle stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];\n        if (name.length) {\n            return name;\n        }\n        return @\"tmux\";\n    }\n}\n\n- (void)setTmuxMode:(PTYSessionTmuxMode)tmuxMode {\n    @synchronized ([TmuxGateway class]) {\n        _tmuxMode = tmuxMode;\n    }\n    if (tmuxMode == TMUX_GATEWAY) {\n        [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            mutableState.isTmuxGateway = (tmuxMode == TMUX_GATEWAY);\n        }];\n    } else if (tmuxMode == TMUX_NONE) {\n        // We got here through a paused side-effect so we cvan't join.\n        [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            mutableState.isTmuxGateway = NO;\n        }];\n    } else if (tmuxMode == TMUX_CLIENT) {\n        [self setUpTmuxPipe];\n    }\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self reallySetTmuxMode:tmuxMode];\n    });\n}\n\n- (void)reallySetTmuxMode:(PTYSessionTmuxMode)tmuxMode {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        NSString *name;\n        switch (tmuxMode) {\n            case TMUX_NONE:\n                name = nil;\n                terminal.tmuxMode = NO;\n                break;\n            case TMUX_GATEWAY:\n                name = @\"gateway\";\n                terminal.tmuxMode = NO;\n                break;\n            case TMUX_CLIENT:\n                name = @\"client\";\n                terminal.tmuxMode = YES;\n                terminal.termType = _tmuxController.defaultTerminal ?: @\"screen\";\n                [self loadTmuxProcessID];\n                [self installTmuxStatusBarMonitor];\n                [self installTmuxTitleMonitor];\n                [self installTmuxForegroundJobMonitor];\n                [self installOtherTmuxMonitors];\n                [self replaceWorkingDirectoryPollerWithTmuxWorkingDirectoryPoller];\n                break;\n        }\n        [self.variablesScope setValue:name forVariableNamed:iTermVariableKeySessionTmuxRole];\n    }];\n}\n\n- (void)setUpTmuxPipe {\n    assert(!_tmuxClientWritePipe);\n    int fds[2];\n    if (pipe(fds) < 0) {\n        NSString *message = [NSString stringWithFormat:@\"Failed to create pipe: %s\", strerror(errno)];\n        DLog(@\"%@\", message);\n        [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            [mutableState appendStringAtCursor:message];\n        }];\n        _tmuxClientWritePipe = nil;\n        return;\n    }\n    {\n        // Make the TaskNotifier file descriptor nonblocking.\n        const int fd = fds[0];\n        const int flags = fcntl(fd, F_GETFL);\n        fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n    }\n    {\n        // Make the write pipe blocking so it can provide backpressure.\n        const int fd = fds[1];\n        const int flags = fcntl(fd, F_GETFL);\n        fcntl(fd, F_SETFL, flags & (~O_NONBLOCK));\n    }\n\n    _shell.readOnlyFileDescriptor = fds[0];\n    [_tmuxClientWritePipe release];\n    _tmuxClientWritePipe = [[NSFileHandle alloc] initWithFileDescriptor:fds[1]\n                                                         closeOnDealloc:YES];\n}\n\n- (void)loadTmuxProcessID {\n    if (!_tmuxController.serverIsLocal) {\n        return;\n    }\n    NSString *command = [NSString stringWithFormat:@\"display-message -t '%%%@' -p '#{pane_pid}'\", @(self.tmuxPane)];\n    DLog(@\"Request pane PID with command %@\", command);\n    [_tmuxController.gateway sendCommand:command\n                          responseTarget:self\n                        responseSelector:@selector(didFetchTmuxPid:)\n                          responseObject:nil\n                                   flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)didFetchTmuxPid:(NSString *)pidString {\n    if (pidString && self.tmuxMode == TMUX_CLIENT && _tmuxController.serverIsLocal) {\n        NSNumber *pid = @([pidString integerValue]);\n        if (pid.intValue > 0) {\n            _shell.tmuxClientProcessID = pid;\n            [self updateTitles];\n        }\n    }\n}\n\n- (void)replaceWorkingDirectoryPollerWithTmuxWorkingDirectoryPoller {\n    DLog(@\"replaceWorkingDirectoryPollerWithTmuxWorkingDirectoryPoller\");\n    _pwdPoller.delegate = nil;\n    [_pwdPoller release];\n\n    _pwdPoller = [[iTermWorkingDirectoryPoller alloc] initWithTmuxGateway:_tmuxController.gateway\n                                                                    scope:self.variablesScope\n                                                               windowPane:self.tmuxPane];\n    _pwdPoller.delegate = self;\n    [_pwdPoller poll];\n}\n\n- (void)installTmuxStatusBarMonitor {\n    assert(!_tmuxStatusBarMonitor);\n\n    if (_tmuxController.gateway.minimumServerVersion.doubleValue >= 2.9) {\n        // Just use the built-in status bar for older versions of tmux because they don't support ${T:xxx} or ${E:xxx}\n        _tmuxStatusBarMonitor = [[iTermTmuxStatusBarMonitor alloc] initWithGateway:_tmuxController.gateway\n                                                                             scope:self.variablesScope];\n        _tmuxStatusBarMonitor.active = [iTermProfilePreferences boolForKey:KEY_SHOW_STATUS_BAR inProfile:self.profile];\n        if ([iTermPreferences boolForKey:kPreferenceKeyUseTmuxStatusBar] ||\n            [iTermStatusBarLayout shouldOverrideLayout:self.profile[KEY_STATUS_BAR_LAYOUT]]) {\n            [self setSessionSpecificProfileValues:@{ KEY_STATUS_BAR_LAYOUT: [[iTermStatusBarLayout tmuxLayoutWithController:_tmuxController\n                                                                                                                      scope:nil\n                                                                                                                     window:self.delegate.tmuxWindow] dictionaryValue] }];\n        }\n    }\n}\n\n- (void)installTmuxForegroundJobMonitor {\n    if (_tmuxForegroundJobMonitor) {\n        return;\n    }\n    if (![self shouldShowTabGraphic]) {\n        return;\n    }\n    __weak __typeof(self) weakSelf = self;\n    _tmuxForegroundJobMonitor = [[iTermTmuxOptionMonitor alloc] initWithGateway:_tmuxController.gateway\n                                                                          scope:self.variablesScope\n                                                           fallbackVariableName:nil\n                                                                         format:@\"#{pane_current_command}\"\n                                                                         target:[NSString stringWithFormat:@\"%%%@\", @(self.tmuxPane)]\n                                                                   variableName:iTermVariableKeySessionJob\n                                                                          block:^(NSString * _Nonnull command) {\n        [weakSelf setCurrentForegroundJobNameForTmux:command];\n    }];\n    if ([iTermAdvancedSettingsModel pollForTmuxForegroundJob]) {\n        [_tmuxForegroundJobMonitor startTimerIfSubscriptionsUnsupported];\n    }\n    [_tmuxForegroundJobMonitor updateOnce];\n}\n\n- (void)setCurrentForegroundJobNameForTmux:(NSString *)command {\n    if ([_graphicSource updateImageForJobName:command enabled:[self shouldShowTabGraphic]]) {\n        [self.delegate sessionDidChangeGraphic:self shouldShow:self.shouldShowTabGraphic image:self.tabGraphic];\n    }\n    [self.delegate sessionJobDidChange:self];\n}\n\n- (void)tmuxWindowTitleDidChange {\n    [self.tmuxForegroundJobMonitor updateOnce];\n}\n\n- (void)uninstallTmuxForegroundJobMonitor {\n    if (!_tmuxForegroundJobMonitor) {\n        return;\n    }\n    [_tmuxForegroundJobMonitor invalidate];\n    [_tmuxForegroundJobMonitor release];\n    _tmuxForegroundJobMonitor = nil;\n}\n\n- (iTermTmuxOptionMonitor *)tmuxForegroundJobMonitor {\n    if (!self.isTmuxClient || !_tmuxController) {\n        return nil;\n    }\n    if (_tmuxForegroundJobMonitor) {\n        return _tmuxForegroundJobMonitor;\n    }\n    if (![self shouldShowTabGraphic]) {\n        return nil;\n    }\n    [self installTmuxForegroundJobMonitor];\n    return _tmuxForegroundJobMonitor;\n}\n\n- (void)installOtherTmuxMonitors {\n    if (![_tmuxController.gateway supportsSubscriptions]) {\n        return;\n    }\n    if (_paneIndexMonitor) {\n        return;\n    }\n    _paneIndexMonitor = [[iTermTmuxOptionMonitor alloc] initWithGateway:_tmuxController.gateway\n                                                                  scope:self.variablesScope\n                                                   fallbackVariableName:nil\n                                                                 format:@\"#{pane_index}\"\n                                                                 target:[NSString stringWithFormat:@\"%%%@\", @(self.tmuxPane)]\n                                                           variableName:iTermVariableKeySessionTmuxWindowPaneIndex\n                                                                  block:nil];\n    [_paneIndexMonitor updateOnce];\n}\n\n// NOTE: Despite the name, this doesn't continuously monitor because that is\n// too expensive. Instead, we manually poll at times when a change is likely.\n- (void)installTmuxTitleMonitor {\n    if (_tmuxTitleMonitor) {\n        return;\n    }\n    __weak __typeof(self) weakSelf = self;\n    _tmuxTitleMonitor = [[iTermTmuxOptionMonitor alloc] initWithGateway:_tmuxController.gateway\n                                                                  scope:self.variablesScope\n                                                   fallbackVariableName:nil\n                                                                 format:@\"#{pane_title}\"\n                                                                 target:[NSString stringWithFormat:@\"%%%@\", @(self.tmuxPane)]\n                                                           variableName:iTermVariableKeySessionTmuxPaneTitle\n                                                                  block:^(NSString * _Nonnull title) {\n        [weakSelf setTitleFromTmuxTitleMonitor:title];\n    }];\n    [_tmuxTitleMonitor updateOnce];\n}\n\n- (void)setTitleFromTmuxTitleMonitor:(NSString *)title {\n    if (title) {\n        [self setSessionSpecificProfileValues:@{ KEY_TMUX_PANE_TITLE: title ?: @\"\"}];\n        [self.delegate sessionDidUpdatePaneTitle:self];\n    }\n}\n\n- (void)uninstallTmuxTitleMonitor {\n    if (!_tmuxTitleMonitor) {\n        return;\n    }\n    [_tmuxTitleMonitor invalidate];\n    [_tmuxTitleMonitor release];\n    _tmuxTitleMonitor = nil;\n}\n\n- (PTYSessionTmuxMode)tmuxMode {\n    @synchronized ([TmuxGateway class]) {\n        return _tmuxMode;\n    }\n}\n\n- (void)startTmuxMode:(NSString *)dcsID {\n    if (self.tmuxMode != TMUX_NONE) {\n        return;\n    }\n    NSString *preferredTmuxClientName = [self preferredTmuxClientName];\n    self.tmuxMode = TMUX_GATEWAY;\n    _tmuxGateway = [[TmuxGateway alloc] initWithDelegate:self dcsID:dcsID];\n    ProfileModel *model;\n    Profile *profile;\n    if ([iTermPreferences useTmuxProfile]) {\n        model = [ProfileModel sharedInstance];\n        profile = [[ProfileModel sharedInstance] tmuxProfile];\n    } else {\n        if (self.isDivorced) {\n            model = [ProfileModel sessionsInstance];\n        } else {\n            model = [ProfileModel sharedInstance];\n        }\n        profile = self.profile;\n    }\n    _haveKickedOffTmux = NO;\n    _tmuxController = [[TmuxController alloc] initWithGateway:_tmuxGateway\n                                                   clientName:preferredTmuxClientName\n                                                      profile:profile\n                                                 profileModel:model];\n\n    [self.variablesScope setValue:_tmuxController.clientName forVariableNamed:iTermVariableKeySessionTmuxClientName];\n    _tmuxController.ambiguousIsDoubleWidth = _treatAmbiguousWidthAsDoubleWidth;\n    _tmuxController.unicodeVersion = _unicodeVersion;\n\n    // We intentionally don't send anything to tmux yet. We wait to get a\n    // begin-end pair from it to make sure everything is cool (we have a legit\n    // session) and then we start going.\n\n    // This is to fix issue 4429, where we used to send a command immediately\n    // and tmux would terminate immediately and we would spam the user's\n    // command line.\n    //\n    // Tmux always prints something when you first attach. It's a notification, a response, or an\n    // error. The options I've considered are:\n    //\n    // tmux -CC with or without an existing session prints this unsolicited:\n    //    %begin time 1 0\n    //    %end time 1 0\n    //    %window-add @id\n\n    // tmux -CC attach with no existing session prints this unsolicited;\n    // %begin time 1 0\n    // no sessions\n    // %error time\n\n    // tmux -CC attach with an existing session prints this unsolicited:\n    // %begin time 1 0\n    // %end time 1 0\n\n    // One of tmuxInitialCommandDidCompleteSuccessfully: or\n    // tmuxInitialCommandDidFailWithError: will be called on the first %end or\n    // %error, respectively.\n    [self printTmuxMessage:@\"** tmux mode started **\"];\n    [self printTmuxMessage:@\"\"];\n    [self printTmuxMessage:@\"Command Menu\"];\n    [self printTmuxMessage:@\"----------------------------\"];\n    [self printTmuxMessage:@\"esc    Detach cleanly.\"];\n    [self printTmuxMessage:@\"  X    Force-quit tmux mode.\"];\n    [self printTmuxMessage:@\"  L    Toggle logging.\"];\n    [self printTmuxMessage:@\"  C    Run tmux command.\"];\n\n    if ([iTermPreferences boolForKey:kPreferenceKeyAutoHideTmuxClientSession]) {\n        _tmuxController.initialWindowHint = self.view.window.frame;\n        _hideAfterTmuxWindowOpens = YES;\n    }\n}\n\n- (BOOL)isTmuxClient {\n    return self.tmuxMode == TMUX_CLIENT;\n}\n\n- (BOOL)isTmuxGateway {\n    return self.tmuxMode == TMUX_GATEWAY;\n}\n\n- (void)tmuxDetach {\n    if (self.tmuxMode != TMUX_GATEWAY) {\n        return;\n    }\n    [self printTmuxMessage:@\"Detaching...\"];\n    [_tmuxGateway detach];\n}\n\n- (void)setTmuxPane:(int)windowPane {\n    [self.variablesScope setValue:@(windowPane) forVariableNamed:iTermVariableKeySessionTmuxWindowPane];\n    self.tmuxMode = TMUX_CLIENT;\n    [_shell registerTmuxTask];\n}\n\n- (int)tmuxPane {\n    return [[self.variablesScope valueForVariableName:iTermVariableKeySessionTmuxWindowPane] intValue];\n}\n\n- (PTYSession *)tmuxGatewaySession {\n    if (self.isTmuxGateway) {\n        return self;\n    }\n    if (!self.isTmuxClient) {\n        return nil;\n    }\n    return (PTYSession *)self.tmuxController.gateway.delegate;\n}\n\n- (void)toggleTmuxZoom {\n    [_tmuxController toggleZoomForPane:self.tmuxPane];\n}\n\n- (void)resizeFromArrangement:(NSDictionary *)arrangement {\n    [self setSize:VT100GridSizeMake([[arrangement objectForKey:SESSION_ARRANGEMENT_COLUMNS] intValue],\n                                    [[arrangement objectForKey:SESSION_ARRANGEMENT_ROWS] intValue])];\n}\n\n- (BOOL)isCompatibleWith:(PTYSession *)otherSession\n{\n    if (self.tmuxMode != TMUX_CLIENT && otherSession.tmuxMode != TMUX_CLIENT) {\n        // Non-clients are always compatible\n        return YES;\n    } else if (self.tmuxMode == TMUX_CLIENT && otherSession.tmuxMode == TMUX_CLIENT) {\n        // Clients are compatible with other clients from the same controller.\n        return (_tmuxController == otherSession.tmuxController);\n    } else {\n        // Clients are never compatible with non-clients.\n        return NO;\n    }\n}\n\n- (VT100GridCoordRange)smartSelectionRangeAt:(VT100GridCoord)coord {\n    if (coord.x < 0 || coord.y < 0 || coord.x >= _screen.width || coord.y >= _screen.height) {\n        return VT100GridCoordRangeMake(0, 0, 0, 0);\n    }\n    VT100GridWindowedRange range;\n    [_textview smartSelectAtX:coord.x\n                            y:coord.y + [_screen numberOfScrollbackLines]\n                           to:&range\n             ignoringNewlines:NO\n               actionRequired:NO\n              respectDividers:NO];\n    return [_textview rangeByTrimmingNullsFromRange:range.coordRange trimSpaces:YES];\n}\n\n- (void)addNoteAtCursor {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        PTYAnnotation *note = [[[PTYAnnotation alloc] init] autorelease];\n        VT100GridCoordRange rangeAtCursor =\n        [self smartSelectionRangeAt:VT100GridCoordMake(_screen.cursorX - 1,\n                                                       _screen.cursorY - 1)];\n        VT100GridCoordRange rangeBeforeCursor =\n        [self smartSelectionRangeAt:VT100GridCoordMake(_screen.cursorX - 2,\n                                                       _screen.cursorY - 1)];\n        VT100GridCoordRange rangeAfterCursor =\n        [self smartSelectionRangeAt:VT100GridCoordMake(_screen.cursorX,\n                                                       _screen.cursorY - 1)];\n        if (VT100GridCoordRangeLength(rangeAtCursor, _screen.width) > 0) {\n            [_screen addNote:note inRange:rangeAtCursor focus:YES];\n        } else if (VT100GridCoordRangeLength(rangeAfterCursor, _screen.width) > 0) {\n            [_screen addNote:note inRange:rangeAfterCursor focus:YES];\n        } else if (VT100GridCoordRangeLength(rangeBeforeCursor, _screen.width) > 0) {\n            [_screen addNote:note inRange:rangeBeforeCursor focus:YES];\n        } else {\n            int y = _screen.cursorY - 1 + [_screen numberOfScrollbackLines];\n            [_screen addNote:note\n                     inRange:VT100GridCoordRangeMake(0, y, _screen.width, y)\n                       focus:YES];\n        }\n    }];\n}\n\n- (void)textViewToggleAnnotations {\n    VT100GridCoordRange range =\n    VT100GridCoordRangeMake(0,\n                            0,\n                            _screen.width,\n                            _screen.height + [_screen numberOfScrollbackLines]);\n    NSArray<id<PTYAnnotationReading>> *annotations = [_screen annotationsInRange:range];\n    BOOL anyNoteIsVisible = NO;\n    for (id<PTYAnnotationReading> annotation in annotations) {\n        PTYNoteViewController *note = (PTYNoteViewController *)annotation.delegate;\n        if (!note.view.isHidden) {\n            anyNoteIsVisible = YES;\n            break;\n        }\n    }\n    for (id<PTYAnnotationReading> annotation in annotations) {\n        PTYNoteViewController *note = (PTYNoteViewController *)annotation.delegate;\n        [note setNoteHidden:anyNoteIsVisible];\n    }\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (void)textViewDidAddOrRemovePorthole {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (NSString *)textViewCurrentSSHSessionName {\n    if (!_conductor) {\n        return nil;\n    }\n    return _conductor.sshIdentity.description;\n}\n\n- (void)textViewDisconnectSSH {\n    if (!_conductor.framing) {\n        NSString *title = [NSString stringWithFormat:@\"Advanced SSH features are unavailable because Python %@ or later was not found on %@\", [iTermConductor minimumPythonVersionForFramer], _conductor.sshIdentity.hostname ?: @\"remote host\"];\n        [iTermWarning showWarningWithTitle:title\n                                   actions:@[ @\"OK\" ]\n                                 accessory:nil\n                                identifier:nil\n                               silenceable:kiTermWarningTypePersistent\n                                   heading:@\"Can\u2019t Disconnect\"\n                                    window:self.view.window];\n        return;\n    }\n    [_conductor quit];\n}\n\n\n- (void)highlightMarkOrNote:(id<IntervalTreeImmutableObject>)obj {\n    if ([obj isKindOfClass:[iTermMark class]]) {\n        BOOL hasErrorCode = NO;\n        if ([obj isKindOfClass:[VT100ScreenMark class]]) {\n            id<VT100ScreenMarkReading> mark = (id<VT100ScreenMarkReading>)obj;\n            hasErrorCode = mark.code != 0;\n        }\n        [_textview highlightMarkOnLine:VT100GridRangeMax([_screen lineNumberRangeOfInterval:obj.entry.interval])\n                          hasErrorCode:hasErrorCode];\n    } else {\n        id<PTYAnnotationReading> annotation = [PTYAnnotation castFrom:obj];\n        if (annotation) {\n            id<PTYAnnotationDelegate> note = annotation.delegate;\n            [note setNoteHidden:NO];\n            [note highlight];\n        }\n    }\n}\n\n- (void)nextMark {\n    if ([_modeHandler nextMark]) {\n        return;\n    }\n    [self nextMarkOrNote:NO];\n}\n\n- (void)nextAnnotation {\n    [self nextMarkOrNote:YES];\n}\n\n- (void)previousMark {\n    if ([_modeHandler previousMark]) {\n        return;\n    }\n    [self previousMarkOrNote:NO];\n}\n\n- (void)previousAnnotation {\n    [self previousMarkOrNote:YES];\n}\n\n- (void)previousMarkOrNote:(BOOL)annotationsOnly {\n    NSArray *objects = nil;\n    if (self.currentMarkOrNotePosition == nil) {\n        if (annotationsOnly) {\n            objects = [_screen lastAnnotations];\n        } else {\n            objects = [_screen lastMarks];\n        }\n    } else {\n        if (annotationsOnly) {\n            objects = [_screen annotationsBefore:self.currentMarkOrNotePosition];\n        } else {\n            objects = [_screen marksBefore:self.currentMarkOrNotePosition];\n        }\n        if (!objects.count) {\n            if (annotationsOnly) {\n                objects = [_screen lastAnnotations];\n            } else {\n                objects = [_screen lastMarks];\n            }\n            if (objects.count) {\n                [_textview beginFlash:kiTermIndicatorWrapToBottom];\n            }\n        }\n    }\n    if (objects.count) {\n        id<IntervalTreeObject> obj = objects[0];\n        self.currentMarkOrNotePosition = obj.entry.interval;\n        VT100GridRange range = [_screen lineNumberRangeOfInterval:self.currentMarkOrNotePosition];\n        [_textview scrollLineNumberRangeIntoView:range];\n        for (obj in objects) {\n            [self highlightMarkOrNote:obj];\n        }\n    }\n}\n\n- (BOOL)markIsNavigable:(id<iTermMark>)mark {\n    return ([mark isKindOfClass:[VT100ScreenMark class]] ||\n            [mark isKindOfClass:[PTYAnnotation class]]);\n}\n\n- (void)nextMarkOrNote:(BOOL)annotationsOnly {\n    NSArray<id<IntervalTreeImmutableObject>> *objects = nil;\n    if (self.currentMarkOrNotePosition == nil) {\n        if (annotationsOnly) {\n            objects = [_screen firstAnnotations];\n        } else {\n            objects = [_screen firstMarks];\n        }\n    } else {\n        if (annotationsOnly) {\n            objects = [_screen annotationsAfter:self.currentMarkOrNotePosition];\n        } else {\n            objects = [_screen marksAfter:self.currentMarkOrNotePosition];\n        }\n        if (!objects.count) {\n            if (annotationsOnly) {\n                objects = [_screen firstAnnotations];\n            } else {\n                objects = [_screen firstMarks];\n            }\n            if (objects.count) {\n                [_textview beginFlash:kiTermIndicatorWrapToTop];\n            }\n        }\n    }\n    if (objects.count) {\n        id<IntervalTreeImmutableObject> obj = objects[0];\n        self.currentMarkOrNotePosition = obj.entry.interval;\n        VT100GridRange range = [_screen lineNumberRangeOfInterval:self.currentMarkOrNotePosition];\n        [_textview scrollLineNumberRangeIntoView:range];\n        for (obj in objects) {\n            [self highlightMarkOrNote:obj];\n        }\n    }\n}\n\n- (void)scrollToMark:(id<iTermMark>)mark {\n    if ([_screen containsMark:mark]) {\n        VT100GridRange range = [_screen lineNumberRangeOfInterval:mark.entry.interval];\n        [_textview scrollLineNumberRangeIntoView:range];\n        [self highlightMarkOrNote:mark];\n    }\n}\n\n- (void)scrollToMarkWithGUID:(NSString *)guid {\n    id<VT100ScreenMarkReading> mark = [_screen namedMarkWithGUID:guid];\n    if (mark) {\n        [self scrollToMark:mark];\n    }\n}\n\n- (void)setCurrentHost:(id<VT100RemoteHostReading>)remoteHost {\n    [_currentHost autorelease];\n    _currentHost = [remoteHost retain];\n    [self.variablesScope setValue:remoteHost.hostname forVariableNamed:iTermVariableKeySessionHostname];\n    [self.variablesScope setValue:remoteHost.username forVariableNamed:iTermVariableKeySessionUsername];\n    [_delegate sessionCurrentHostDidChange:self];\n}\n\n- (id<VT100RemoteHostReading>)currentHost {\n    if (!_currentHost) {\n        // This is used when a session gets restored since _currentHost doesn't get persisted (and\n        // perhaps other edge cases I haven't found--it used to be done every time before the\n        // _currentHost ivar existed).\n        _currentHost = [[_screen remoteHostOnLine:[_screen numberOfLines]] retain];\n        if (_currentHost) {\n            [self.variablesScope setValue:_currentHost.hostname forVariableNamed:iTermVariableKeySessionHostname];\n            [self.variablesScope setValue:_currentHost.username forVariableNamed:iTermVariableKeySessionUsername];\n        }\n    }\n    return _currentHost;\n}\n\n#pragma mark tmux gateway delegate methods\n// TODO (also, capture and throw away keyboard input)\n\n- (NSString *)tmuxOwningSessionGUID {\n    return self.guid;\n}\n\n- (void)tmuxDidOpenInitialWindows {\n    if (_hideAfterTmuxWindowOpens) {\n        _hideAfterTmuxWindowOpens = NO;\n        [self hideSession];\n\n        static NSString *const kAutoBurialKey = @\"NoSyncAutoBurialReveal\";\n        if (![[NSUserDefaults standardUserDefaults] boolForKey:kAutoBurialKey]) {\n            [[iTermNotificationController sharedInstance] notify:@\"Session Buried\"\n                                                 withDescription:@\"It can be restored by detaching from tmux, or from the Sessions > Buried Sessions menu.\"];\n            [[NSUserDefaults standardUserDefaults] setBool:YES forKey:kAutoBurialKey];\n        }\n    }\n}\n\n- (BOOL)tmuxUpdateLayoutForWindow:(int)windowId\n                           layout:(NSString *)layout\n                    visibleLayout:(NSString *)visibleLayout\n                           zoomed:(NSNumber *)zoomed\n                             only:(BOOL)only {\n    DLog(@\"tmuxUpdateLayoutForWindow:%@ layout:%@ zoomed:%@ only:%@\",\n         @(windowId), layout, zoomed, @(only));\n    PTYTab *tab = [_tmuxController window:windowId];\n    if (!tab) {\n        DLog(@\"* NO TAB, DO NOTHING\");\n        return NO;\n    }\n    const BOOL result = [_tmuxController setLayoutInTab:tab\n                                               toLayout:layout\n                                          visibleLayout:visibleLayout\n                                                 zoomed:zoomed];\n    if (result && only) {\n        [_tmuxController adjustWindowSizeIfNeededForTabs:@[ tab ]];\n    }\n    return result;\n}\n\n- (void)tmuxWindowAddedWithId:(int)windowId {\n    if (![_tmuxController window:windowId]) {\n        [_tmuxController openWindowWithId:windowId\n                              intentional:NO\n                                  profile:[_tmuxController profileForWindow:self.delegate.tmuxWindow]];\n    }\n    [_tmuxController windowsChanged];\n}\n\n- (void)tmuxWindowClosedWithId:(int)windowId\n{\n    PTYTab *tab = [_tmuxController window:windowId];\n    if (tab) {\n        [[tab realParentWindow] removeTab:tab];\n    }\n    [_tmuxController windowsChanged];\n}\n\n- (void)tmuxWindowRenamedWithId:(int)windowId to:(NSString *)newName {\n    PTYSession *representativeSession = [[_tmuxController sessionsInWindow:windowId] firstObject];\n    [representativeSession.delegate sessionDidChangeTmuxWindowNameTo:newName];\n    [_tmuxController windowWasRenamedWithId:windowId to:newName];\n}\n\n- (void)tmuxInitialCommandDidCompleteSuccessfully {\n    // This kicks off a chain reaction that leads to windows being opened.\n    if (!_haveKickedOffTmux) {\n        // In tmux 1.9+ this happens before `tmuxSessionsChanged`.\n        [self kickOffTmux];\n    }\n}\n\n// When guessVersion finishes, if you have called openWindowsInitial, then windows will actually get\n// opened. Initial window opening is always blocked on establishing the server version.\n- (void)kickOffTmux {\n    _haveKickedOffTmux = YES;\n    [_tmuxController sendControlC];\n    [_tmuxController ping];\n    [_tmuxController validateOptions];\n    [_tmuxController checkForUTF8];\n    [_tmuxController loadDefaultTerminal];\n    [_tmuxController loadKeyBindings];\n    [_tmuxController exitCopyMode];\n    [_tmuxController guessVersion];  // NOTE: This kicks off more stuff that depends on knowing the version number.\n}\n\n- (void)tmuxInitialCommandDidFailWithError:(NSString *)error {\n    // Let the user know what went wrong. Do it async because this runs as a side-effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self printTmuxMessage:[NSString stringWithFormat:@\"tmux failed with error: \u201c%@\u201d\", error]];\n    });\n}\n\n- (void)tmuxPrintLine:(NSString *)line {\n    DLog(@\"%@\", line);\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState appendStringAtCursor:line];\n        [mutableState appendCarriageReturnLineFeed];\n    }];\n}\n\n- (void)tmuxGatewayDidTimeOut {\n    NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n    alert.messageText = @\"Force Detach?\";\n    alert.informativeText = @\"Tmux is not responding. Would you like to force detach?\";\n    [alert addButtonWithTitle:@\"Detach\"];\n    [alert addButtonWithTitle:@\"Cancel\"];\n    NSWindow *window = self.view.window;\n    NSInteger button;\n    if (window) {\n        button = [alert runSheetModalForWindow:window];\n    } else {\n        button = [alert runModal];\n    }\n    if (button == NSAlertFirstButtonReturn) {\n        [_tmuxGateway forceDetach];\n    }\n}\n\n- (void)tmuxActiveWindowPaneDidChangeInWindow:(int)windowID toWindowPane:(int)paneID {\n    [_tmuxController activeWindowPaneDidChangeInWindow:windowID toWindowPane:paneID];\n}\n\n- (void)tmuxSessionWindowDidChangeTo:(int)windowID {\n    [_tmuxController activeWindowDidChangeTo:windowID];\n}\n\n- (BOOL)tmuxGatewayShouldForceDetach {\n    NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n    alert.messageText = @\"Force Detach?\";\n    alert.informativeText = @\"A previous detach request has not yet been honored. Force detach?\";\n    [alert addButtonWithTitle:@\"OK\"];\n    [alert addButtonWithTitle:@\"Cancel\"];\n    NSWindow *window = self.view.window;\n    NSInteger button;\n    if (window) {\n        button = [alert runSheetModalForWindow:window];\n    } else {\n        button = [alert runModal];\n    }\n    return button == NSAlertFirstButtonReturn;\n}\n\n- (NSWindowController<iTermWindowController> *)tmuxGatewayWindow {\n    return _delegate.realParentWindow;\n}\n\n- (void)tmuxHostDisconnected:(NSString *)dcsID {\n    _hideAfterTmuxWindowOpens = NO;\n\n    if ([iTermPreferences boolForKey:kPreferenceKeyAutoHideTmuxClientSession] &&\n        [[[iTermBuriedSessions sharedInstance] buriedSessions] containsObject:self]) {\n        // Do this before detaching because it may be the only tab in a hotkey window. If all the\n        // tabs close the window is destroyed and it breaks the reference from iTermProfileHotkey.\n        // See issue 7384.\n        [[iTermBuriedSessions sharedInstance] restoreSession:self];\n    }\n\n    [_tmuxController detach];\n    // Autorelease the gateway because it called this function so we can't free\n    // it immediately.\n    [_tmuxGateway autorelease];\n    _tmuxGateway = nil;\n    [_tmuxController release];\n    _tmuxController = nil;\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState appendStringAtCursor:@\"Detached\"];\n        [mutableState appendCarriageReturnLineFeed];\n        [terminal.parser forceUnhookDCS:dcsID];\n    }];\n    self.tmuxMode = TMUX_NONE;\n    [self.variablesScope setValue:nil forVariableNamed:iTermVariableKeySessionTmuxClientName];\n    [self.variablesScope setValue:nil forVariableNamed:iTermVariableKeySessionTmuxPaneTitle];\n}\n\n- (void)tmuxCannotSendCharactersInSupplementaryPlanes:(NSString *)string windowPane:(int)windowPane {\n    PTYSession *session = [_tmuxController sessionForWindowPane:windowPane];\n    [session.naggingController tmuxSupplementaryPlaneErrorForCharacter:string];\n}\n\n- (void)tmuxSetSecureLogging:(BOOL)secureLogging {\n    _tmuxSecureLogging = secureLogging;\n}\n\n- (void)tmuxWriteString:(NSString *)string {\n    if (_exited) {\n        return;\n    }\n    if (_tmuxSecureLogging) {\n        DLog(@\"Write to tmux.\");\n    } else {\n        DLog(@\"Write to tmux: \\\"%@\\\"\", string);\n    }\n    if (_tmuxGateway.tmuxLogging) {\n        [self printTmuxMessage:[@\"> \" stringByAppendingString:string]];\n    }\n    if (_conductor && !_exited) {\n        // Running tmux inside an ssh client takes this path\n        [_conductor sendKeys:[string dataUsingEncoding:NSUTF8StringEncoding]];\n    } else {\n        [self writeTaskImpl:string encoding:NSUTF8StringEncoding forceEncoding:YES canBroadcast:NO reporting:NO];\n    }\n}\n\n+ (dispatch_queue_t)tmuxQueue {\n    static dispatch_queue_t tmuxQueue;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        tmuxQueue = dispatch_queue_create(\"com.iterm2.tmuxReadTask\", 0);\n    });\n    return tmuxQueue;\n}\n\n// This is called on the main thread when %output is parsed.\n- (void)tmuxReadTask:(NSData *)data windowPane:(int)wp latency:(NSNumber *)latency {\n    if (latency) {\n        [_tmuxController setCurrentLatency:latency.doubleValue forPane:wp];\n    }\n    [[_tmuxController sessionForWindowPane:wp] handleTmuxData:data];\n}\n\n- (void)handleTmuxData:(NSData *)data {\n    if (_exited) {\n        return;\n    }\n    if (_logging.style == iTermLoggingStyleRaw) {\n        [_logging logData:data];\n    }\n\n    // Send the bytes from %output in to the write end of a pipe. The data will come out\n    // iTermTmuxJobManager.fd, which TaskRegister selects on. The purpose of this pipe is to\n    // let tmux provide backpressure to the pty. In the old days, this would call -threadedReadTask:\n    // on the tmux queue. threadedReadTask: is meant to be called on the TaskNotifier queue and it\n    // will block if there are too many tokens outstanding. That is an effective mechanism to\n    // provide backpressure. By dispatching onto the tmuxQueue, infinite data could be buffered by\n    // GCD, breaking the backpressure mechanism. It is unfortunate that all tmux data must make\n    // two passes through TaskNotifier (once as `%output blah blah` and a second time as `blah blah`)\n    // but the alternative is unbounded latency. We still do the write on tmuxQueue because we\n    // don't want to block the main queue. GCD can still buffer here, but it's OK because\n    // TaskNotifier has a chance to get its queue blocked when it reads the data. That limits the\n    // rate that this can write, since it can only write after a %output is read.\n    __weak NSFileHandle *handle = _tmuxClientWritePipe;\n    dispatch_async([[self class] tmuxQueue], ^{\n        @try {\n            [handle writeData:data];\n        } @catch (NSException *exception) {\n            DLog(@\"%@ while writing to tmux pipe\", exception);\n        }\n    });\n}\n\n- (void)tmuxSessionPasteDidChange:(NSString *)pasteBufferName {\n    if ([iTermPreferences boolForKey:kPreferenceKeyTmuxSyncClipboard]) {\n        [_tmuxController copyBufferToLocalPasteboard:pasteBufferName];\n    } else {\n        [[[[iTermController sharedInstance] currentTerminal] currentSession] askToMirrorTmuxPasteBuffer];\n    }\n}\n\n- (void)askToMirrorTmuxPasteBuffer {\n    [_naggingController tmuxDidUpdatePasteBuffer];\n\n\n\n}\n\n- (void)tmuxWindowPaneDidPause:(int)wp notification:(BOOL)notification {\n    PTYSession *session = [_tmuxController sessionForWindowPane:wp];\n    [session setTmuxPaused:YES allowAutomaticUnpause:notification];\n}\n\n- (void)setTmuxPaused:(BOOL)paused allowAutomaticUnpause:(BOOL)allowAutomaticUnpause {\n    if (_tmuxPaused == paused) {\n        return;\n    }\n    _tmuxPaused = paused;\n    if (paused) {\n        _tmuxTTLHasThresholds = NO;\n        [self.tmuxController didPausePane:self.tmuxPane];\n        if (allowAutomaticUnpause && [iTermPreferences boolForKey:kPreferenceKeyTmuxUnpauseAutomatically]) {\n            __weak __typeof(self) weakSelf = self;\n            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n                [weakSelf setTmuxPaused:NO allowAutomaticUnpause:YES];\n            });\n            return;\n        }\n        [self showTmuxPausedAnnouncement:allowAutomaticUnpause];\n    } else {\n        [self unpauseTmux];\n    }\n}\n\n- (void)showTmuxPausedAnnouncement:(BOOL)notification {\n    NSString *title;\n    if (notification) {\n        title = @\"tmux paused this session because too much output was buffered.\";\n    } else {\n        title = @\"Session paused.\";\n    }\n\n    [self dismissAnnouncementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n    __weak __typeof(self) weakSelf = self;\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:title\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"_Unpause\", @\"_Settings\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case 0:\n                [weakSelf setTmuxPaused:NO allowAutomaticUnpause:YES];\n                break;\n            case 1:\n                [[PreferencePanel sharedInstance] openToPreferenceWithKey:kPreferenceKeyTmuxPauseModeAgeLimit];\n                [weakSelf showTmuxPausedAnnouncement:notification];\n                break;\n        }\n    }];\n    [self dismissAnnouncementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n    [self removeAnnouncementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n    [self queueAnnouncement:announcement identifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n}\n\n- (void)setTmuxHistory:(NSArray<NSData *> *)history\n            altHistory:(NSArray<NSData *> *)altHistory\n                 state:(NSDictionary *)state {\n    __weak __typeof(self) weakSelf = self;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [weakSelf reallySetTmuxHistory:history\n                            altHistory:altHistory\n                                 state:state\n                              terminal:terminal\n                          mutableState:mutableState];\n    }];\n}\n\n- (void)reallySetTmuxHistory:(NSArray<NSData *> *)history\n                  altHistory:(NSArray<NSData *> *)altHistory\n                       state:(NSDictionary *)state\n                    terminal:(VT100Terminal *)terminal\n                mutableState:(VT100ScreenMutableState *)mutableState {\n    [terminal resetForTmuxUnpause];\n    [self clearScrollbackBuffer];\n    [mutableState setHistory:history];\n    [mutableState setAltScreen:altHistory];\n    [self setTmuxState:state];\n    _view.scrollview.ptyVerticalScroller.userScroll = NO;\n}\n\n- (void)toggleTmuxPausePane {\n    if (_tmuxPaused) {\n        [self setTmuxPaused:NO allowAutomaticUnpause:YES];\n    } else {\n        [_tmuxController pausePanes:@[ @(self.tmuxPane) ]];\n    }\n}\n\n- (void)setTmuxState:(NSDictionary *)state {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        mutableState.tmuxState = state;\n    }];\n}\n\n- (void)unpauseTmux {\n    [self dismissAnnouncementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n    [self unzoomIfPossible];\n    [_tmuxController unpausePanes:@[ @(self.tmuxPane) ]];\n}\n\n- (void)pauseTmux {\n    [_tmuxController pausePanes:@[ @(self.tmuxPane) ]];\n}\n\n- (void)tmuxSessionChanged:(NSString *)sessionName sessionId:(int)sessionId {\n    [_tmuxController sessionChangedTo:sessionName sessionId:sessionId];\n    if (!_haveKickedOffTmux) {\n        // Tell the tmux controller we want to open initial windows after version guessing finishes.\n        [_tmuxController openWindowsInitial];\n        // In tmux 1.8, this happens before `tmuxInitialCommandDidCompleteSuccessfully`.\n        [self kickOffTmux];\n    }\n}\n\n- (void)tmuxSessionsChanged {\n    [_tmuxController sessionsChanged];\n}\n\n- (void)tmuxWindowsDidChange\n{\n    [_tmuxController windowsChanged];\n}\n\n- (void)tmuxSession:(int)sessionId renamed:(NSString *)newName\n{\n    [_tmuxController session:sessionId renamedTo:newName];\n}\n\n- (VT100GridSize)tmuxClientSize {\n    if (!_delegate) {\n        DLog(@\"No delegate so use saved grid size %@\", VT100GridSizeDescription(_savedGridSize));\n        return _savedGridSize;\n    }\n    DLog(@\"Get size from delegate %@, controller tmuxController %@, window %@\", _delegate,\n         _tmuxController, @(self.delegate.tmuxWindow));\n    return [_delegate sessionTmuxSizeWithProfile:[_tmuxController profileForWindow:self.delegate.tmuxWindow]];\n}\n\n- (NSInteger)tmuxNumberOfLinesOfScrollbackHistory {\n    Profile *profile = [_tmuxController profileForWindow:self.delegate.tmuxWindow];\n    if ([iTermPreferences useTmuxProfile]) {\n        profile = [[ProfileModel sharedInstance] tmuxProfile];\n    }\n    if ([profile[KEY_UNLIMITED_SCROLLBACK] boolValue]) {\n        // 10M is close enough to infinity to be indistinguishable.\n        return 10 * 1000 * 1000;\n    } else {\n        return [profile[KEY_SCROLLBACK_LINES] integerValue];\n    }\n}\n\n- (void)tmuxDoubleAttachForSessionGUID:(NSString *)sessionGUID {\n    NSArray<NSString *> *actions = @[ @\"OK\", @\"Reveal\", @\"Force Detach Other\" ];\n    TmuxController *controller = [[TmuxControllerRegistry sharedInstance] tmuxControllerWithSessionGUID:sessionGUID];\n    if (!controller) {\n        actions = @[ @\"OK\" ];\n    }\n    const iTermWarningSelection selection =\n    [iTermWarning showWarningWithTitle:@\"This instance of iTerm2 is already attached to this session\"\n                               actions:actions\n                             accessory:nil\n                            identifier:@\"AlreadyAttachedToTmuxSession\"\n                           silenceable:kiTermWarningTypePersistent\n                               heading:@\"Cannot Attach\"\n                                window:self.view.window];\n    switch (selection) {\n        case kiTermWarningSelection0:\n            return;\n        case kiTermWarningSelection1:\n            break;\n        case kiTermWarningSelection2:\n            [controller.gateway forceDetach];\n            return;\n        default:\n            assert(NO);\n    }\n\n    PTYSession *aSession =\n    [[controller.clientSessions sortedArrayUsingComparator:^NSComparisonResult(PTYSession *s1, PTYSession *s2) {\n        return [s1.guid compare:s2.guid];\n    }] firstObject];\n\n    if (!aSession) {\n        aSession = [PTYSession castFrom:controller.gateway.delegate];\n    }\n    if (!aSession) {\n        iTermApplicationDelegate *delegate = [iTermApplication.sharedApplication delegate];\n        [delegate openDashboard:nil];\n        return;\n    }\n    [aSession reveal];\n}\n\n- (void)tmuxWillKillWindow:(NSNotification *)notification {\n    if ([self.delegate tmuxWindow] == [notification.object intValue]) {\n        _tmuxWindowClosingByClientRequest = YES;\n    }\n}\n\n#pragma mark PTYTextViewDelegate\n\n- (BOOL)isPasting {\n    return _pasteHelper.isPasting;\n}\n\n- (void)queueKeyDown:(NSEvent *)event {\n    [_pasteHelper enqueueEvent:event];\n}\n\n- (BOOL)event:(NSEvent *)event matchesPattern:(ITMKeystrokePattern *)pattern {\n    if (event.type != NSEventTypeKeyDown) {\n        return NO;\n    }\n    NSMutableArray *actualModifiers = [NSMutableArray array];\n    if (event.it_modifierFlags & NSEventModifierFlagControl) {\n        [actualModifiers addObject:@(ITMModifiers_Control)];\n    }\n    if (event.it_modifierFlags & NSEventModifierFlagOption) {\n        [actualModifiers addObject:@(ITMModifiers_Option)];\n    }\n    if (event.it_modifierFlags & NSEventModifierFlagCommand) {\n        [actualModifiers addObject:@(ITMModifiers_Command)];\n    }\n    if (event.it_modifierFlags & NSEventModifierFlagShift) {\n        [actualModifiers addObject:@(ITMModifiers_Shift)];\n    }\n    if (event.it_modifierFlags & NSEventModifierFlagFunction) {\n        [actualModifiers addObject:@(ITMModifiers_Function)];\n    }\n    if (event.it_modifierFlags & NSEventModifierFlagNumericPad) {\n        [actualModifiers addObject:@(ITMModifiers_Numpad)];\n    }\n    for (NSInteger i = 0; i < pattern.requiredModifiersArray_Count; i++) {\n        ITMModifiers modifier = [pattern.requiredModifiersArray valueAtIndex:i];\n        if (![actualModifiers containsObject:@(modifier)]) {\n            return NO;\n        }\n    }\n    for (NSInteger i = 0; i < pattern.forbiddenModifiersArray_Count; i++) {\n        ITMModifiers modifier = [pattern.forbiddenModifiersArray valueAtIndex:i];\n        if ([actualModifiers containsObject:@(modifier)]) {\n            return NO;\n        }\n    }\n\n    // All necessary conditions are satisifed. Now find one that is sufficient.\n    for (NSInteger i = 0; i < pattern.keycodesArray_Count; i++) {\n        if (event.keyCode == [pattern.keycodesArray valueAtIndex:i]) {\n            return YES;\n        }\n    }\n    for (NSString *characters in pattern.charactersArray) {\n        if ([event.characters isEqualToString:characters]) {\n            return YES;\n        }\n    }\n    for (NSString *charactersIgnoringModifiers in pattern.charactersIgnoringModifiersArray) {\n        if ([event.charactersIgnoringModifiers isEqualToString:charactersIgnoringModifiers]) {\n            return YES;\n        }\n    }\n    return NO;\n}\n\n- (BOOL)keystrokeIsFilteredByMonitor:(NSEvent *)event {\n    for (NSString *identifier in _keyboardFilterSubscriptions) {\n        ITMNotificationRequest *request = _keyboardFilterSubscriptions[identifier];\n        for (ITMKeystrokePattern *pattern in request.keystrokeFilterRequest.patternsToIgnoreArray) {\n            if ([self event:event matchesPattern:pattern]) {\n                return YES;\n            }\n        }\n        // Prior to 1.17, the filter monitor used keystrokeMonitorRequest instead of keystrokeFilterRequest.\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n        for (ITMKeystrokePattern *pattern in request.keystrokeMonitorRequest.patternsToIgnoreArray) {\n#pragma clang diagnostic pop\n            if ([self event:event matchesPattern:pattern]) {\n                return YES;\n            }\n        }\n    }\n    return NO;\n}\n\n- (VT100SyncResult)textViewWillRefresh {\n    return [self syncCheckingTriggers:VT100ScreenTriggerCheckTypePartialLines\n                        resetOverflow:YES];\n}\n\n- (VT100ScreenState *)screenSwitchToSharedState {\n    return [_screen switchToSharedState];\n}\n\n- (void)screenRestoreState:(VT100ScreenState *)state {\n    [_screen restoreState:state];\n    _textview.colorMap = state.colorMap;\n}\n\n- (VT100MutableScreenConfiguration *)screenConfiguration {\n    [self updateConfigurationFields];\n    return _config;\n}\n\n- (void)screenSync:(VT100ScreenMutableState *)mutableState {\n    const VT100SyncResult result = [self syncCheckingTriggers:VT100ScreenTriggerCheckTypeNone\n                                                resetOverflow:NO\n                                                 mutableState:mutableState];\n    if (result.namedMarksChanged) {\n        [[[[iTermNamedMarksDidChangeNotification alloc] initWithSessionGuid:self.guid] autorelease] post];\n    }\n}\n\n- (void)screenSyncExpect:(VT100ScreenMutableState *)mutableState {\n    const BOOL expectWasDirty = _expect.dirty;\n    [_expect resetDirty];\n    if (expectWasDirty) {\n        [mutableState updateExpectFrom:_expect];\n    }\n}\n\n- (void)sync {\n    DLog(@\"sync\\n%@\", [NSThread callStackSymbols]);\n    [self syncCheckingTriggers:VT100ScreenTriggerCheckTypeNone\n                 resetOverflow:NO];\n}\n\n- (void)syncCheckingTriggers:(VT100ScreenTriggerCheckType)checkTriggers {\n    DLog(@\"syncCheckingTriggers:%@\", @(checkTriggers));\n    [self syncCheckingTriggers:checkTriggers resetOverflow:NO];\n}\n\n// Only main-thread-initiated syncs take this route.\n- (VT100SyncResult)syncCheckingTriggers:(VT100ScreenTriggerCheckType)checkTriggers\n                          resetOverflow:(BOOL)resetOverflow {\n    DLog(@\"syncCheckingTriggers:%@ resetOverflow:%@ %@\", @(checkTriggers), @(resetOverflow), self);\n    __block VT100SyncResult result = { 0 };\n    [_screen performLightweightBlockWithJoinedThreads:^(VT100ScreenMutableState *mutableState) {\n        DLog(@\"lightweight block running for %@\", self);\n        result = [self syncCheckingTriggers:checkTriggers\n                              resetOverflow:resetOverflow\n                               mutableState:mutableState];\n    }];\n    if (result.namedMarksChanged) {\n        [[[[iTermNamedMarksDidChangeNotification alloc] initWithSessionGuid:self.guid] autorelease] post];\n    }\n    return result;\n}\n\n// This is a funnel that all syncs go through.\n- (VT100SyncResult)syncCheckingTriggers:(VT100ScreenTriggerCheckType)checkTriggers\n                          resetOverflow:(BOOL)resetOverflow\n                           mutableState:(VT100ScreenMutableState *)mutableState {\n    DLog(@\"syncCheckingTriggers:%@ resetOverflow:%@ mutableState:%@ self:%@\",\n         @(checkTriggers), @(resetOverflow), mutableState, self);\n    [self updateConfigurationFields];\n    const BOOL expectWasDirty = _expect.dirty;\n    [_expect resetDirty];\n    const VT100SyncResult syncResult = [_screen synchronizeWithConfig:_config\n                                                               expect:expectWasDirty ? _expect : nil\n                                                        checkTriggers:checkTriggers\n                                                        resetOverflow:resetOverflow\n                                                         mutableState:mutableState];\n    _textview.colorMap = _screen.colorMap;\n    DLog(@\"END syncCheckingTriggers\");\n    return syncResult;\n}\n\n- (void)enableOffscreenMarkAlertsIfNeeded {\n    DLog(@\"enableOffscreenMarkAlertsIfNeeded %@\", self);\n    if (_temporarilySuspendOffscreenMarkAlerts) {\n        DLog(@\"_temporarilySuspendOffscreenMarkAlerts = NO for %@\", self);\n        _temporarilySuspendOffscreenMarkAlerts = NO;\n        [self sync];\n    }\n}\n\n- (BOOL)textViewShouldAcceptKeyDownEvent:(NSEvent *)event {\n    [self enableOffscreenMarkAlertsIfNeeded];\n    const BOOL accept = [self shouldAcceptKeyDownEvent:event];\n    if (accept) {\n        [_cadenceController didHandleKeystroke];\n    }\n    return accept;\n}\n\n- (BOOL)shouldReportOrFilterKeystrokesForAPI {\n    if (self.isTmuxClient && _tmuxPaused) {\n        // This ignores the monitor filter and subscriptions because it might be the only way to\n        // unpause.\n        return NO;\n    }\n    return YES;\n}\n\n- (void)textViewDidReceiveFlagsChangedEvent:(NSEvent *)event {\n    if ([self shouldReportOrFilterKeystrokesForAPI]) {\n        [self sendKeystrokeNotificationForEvent:event advanced:YES];\n    }\n    // Change of cmd modifier means we need mouseMoved events to highlight/unhighlight URLs.\n    [self.view updateTrackingAreas];\n}\n\n- (BOOL)shouldAcceptKeyDownEvent:(NSEvent *)event {\n    const BOOL accept = ![self keystrokeIsFilteredByMonitor:event];\n\n    if (accept) {\n        if (_textview.selection.hasSelection &&\n            !_textview.selection.live &&\n            [_modeHandler.copyModeHandler shouldAutoEnterWithEvent:event]) {\n            // Avoid handling the event twice (which is the cleverness)\n            [_modeHandler enterCopyModeWithoutCleverness];\n            [_modeHandler.copyModeHandler handleAutoEnteringEvent:event];\n            return NO;\n        }\n        if (_modeHandler.mode != iTermSessionModeDefault) {\n            [_modeHandler handleEvent:event];\n            return NO;\n        }\n        if (event.keyCode == kVK_Return) {\n            [_screen userDidPressReturn];\n        }\n\n        if ((event.it_modifierFlags & NSEventModifierFlagControl) && [event.charactersIgnoringModifiers isEqualToString:@\"c\"]) {\n            if (_screen.terminalReceivingFile) {\n                // Offer to abort download if you press ^c while downloading an inline file\n                [self.naggingController askAboutAbortingDownload];\n            } else if (self.upload) {\n                [self.naggingController askAboutAbortingUpload];\n            }\n        }\n        _lastInput = [NSDate timeIntervalSinceReferenceDate];\n        [_pwdPoller userDidPressKey];\n        if ([_view.currentAnnouncement handleKeyDown:event]) {\n            return NO;\n        }\n    }\n    if (![self shouldReportOrFilterKeystrokesForAPI]) {\n        [self setTmuxPaused:NO allowAutomaticUnpause:YES];\n        return NO;\n    }\n    if (_keystrokeSubscriptions.count && ![event it_eventGetsSpecialHandlingForAPINotifications]) {\n        [self sendKeystrokeNotificationForEvent:event advanced:NO];\n    }\n\n    if (accept) {\n        [_metaFrustrationDetector didSendKeyEvent:event];\n    }\n    if ([self eventAbortsPasteWaitingForPrompt:event]) {\n        [_pasteHelper abort];\n        return NO;\n    }\n\n    return accept;\n}\n\n- (NSArray<NSNumber *> *)apiModifiersForModifierFlags:(NSEventModifierFlags)flags {\n    NSMutableArray<NSNumber *> *mods = [NSMutableArray array];\n    if (flags & NSEventModifierFlagControl) {\n        [mods addObject:@(ITMModifiers_Control)];\n    }\n    if (flags & NSEventModifierFlagOption) {\n        [mods addObject:@(ITMModifiers_Option)];\n    }\n    if (flags & NSEventModifierFlagCommand) {\n        [mods addObject:@(ITMModifiers_Command)];\n    }\n    if (flags & NSEventModifierFlagShift) {\n        [mods addObject:@(ITMModifiers_Shift)];\n    }\n    if (flags & NSEventModifierFlagNumericPad) {\n        [mods addObject:@(ITMModifiers_Numpad)];\n    }\n    if (flags & NSEventModifierFlagFunction) {\n        [mods addObject:@(ITMModifiers_Function)];\n    }\n    return mods;\n}\n\n- (void)sendKeystrokeNotificationForEvent:(NSEvent *)event\n                                 advanced:(BOOL)advanced {\n    ITMKeystrokeNotification *keystrokeNotification = [[[ITMKeystrokeNotification alloc] init] autorelease];\n    if (!advanced || event.type != NSEventTypeFlagsChanged) {\n        keystrokeNotification.characters = event.characters;\n        keystrokeNotification.charactersIgnoringModifiers = event.charactersIgnoringModifiers;\n    }\n    for (NSNumber *number in [self apiModifiersForModifierFlags:event.it_modifierFlags]) {\n        [keystrokeNotification.modifiersArray addValue:number.intValue];\n    }\n    switch (event.type) {\n        case NSEventTypeKeyDown:\n            keystrokeNotification.action = ITMKeystrokeNotification_Action_KeyDown;\n            break;\n        case NSEventTypeKeyUp:\n            keystrokeNotification.action = ITMKeystrokeNotification_Action_KeyUp;\n            break;\n        case NSEventTypeFlagsChanged:\n            keystrokeNotification.action = ITMKeystrokeNotification_Action_FlagsChanged;\n            break;\n        default:\n            break;\n    }\n    keystrokeNotification.keyCode = event.keyCode;\n    keystrokeNotification.session = self.guid;\n    ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n    notification.keystrokeNotification = keystrokeNotification;\n\n    [_keystrokeSubscriptions enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n        if (advanced && !obj.keystrokeMonitorRequest.advanced) {\n            return;\n        }\n        [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                             toConnectionKey:key];\n    }];\n}\n\n- (BOOL)eventAbortsPasteWaitingForPrompt:(NSEvent *)event {\n    if (!_pasteHelper.isWaitingForPrompt) {\n        return NO;\n    }\n    if (event.keyCode == kVK_Escape) {\n        return YES;\n    }\n    const NSEventModifierFlags mask = (NSEventModifierFlagOption |\n                                       NSEventModifierFlagShift |\n                                       NSEventModifierFlagCommand |\n                                       NSEventModifierFlagControl);\n    if ((event.modifierFlags & mask) == NSEventModifierFlagControl &&\n        [event.characters isEqualToString:[NSString stringWithLongCharacter:3]]) {\n        // ^C\n        return YES;\n    }\n    return NO;\n}\n\n+ (void)reportFunctionCallError:(NSError *)error forInvocation:(NSString *)invocation origin:(NSString *)origin window:(NSWindow *)window {\n    NSString *message = [NSString stringWithFormat:@\"Error running \u201c%@\u201d:\\n%@\",\n                         invocation, error.localizedDescription];\n    NSString *traceback = error.localizedFailureReason;\n    NSArray *actions = @[ @\"OK\" ];\n    if (traceback) {\n        actions = [actions arrayByAddingObject:@\"Reveal in Script Console\"];\n    }\n    NSString *connectionKey = error.userInfo[iTermAPIHelperFunctionCallErrorUserInfoKeyConnection];\n    iTermScriptHistoryEntry *entry = [[iTermScriptHistory sharedInstance] entryWithIdentifier:connectionKey];\n    [entry addOutput:[NSString stringWithFormat:@\"An error occurred while running the function invocation \u201c%@\u201d:\\n%@\\n\\nTraceback:\\n%@\",\n                      invocation,\n                      error.localizedDescription,\n                      traceback]\n          completion:^{}];\n    iTermWarningSelection selection = [iTermWarning showWarningWithTitle:message\n                                                                 actions:actions\n                                                               accessory:nil\n                                                              identifier:@\"NoSyncFunctionCallError\"\n                                                             silenceable:kiTermWarningTypeTemporarilySilenceable\n                                                                 heading:[NSString stringWithFormat:@\"%@ Function Call Failed\", origin]\n                                                                  window:window];\n    if (selection == kiTermWarningSelection1) {\n        [[iTermScriptConsole sharedInstance] revealTailOfHistoryEntry:entry];\n    }\n}\n\n- (void)invokeFunctionCall:(NSString *)invocation\n                     scope:(iTermVariableScope *)scope\n                    origin:(NSString *)origin {\n    [iTermScriptFunctionCall callFunction:invocation\n                                  timeout:[[NSDate distantFuture] timeIntervalSinceNow]\n                                    scope:scope\n                               retainSelf:YES\n                               completion:^(id value, NSError *error, NSSet<NSString *> *missing) {\n        if (error) {\n            [PTYSession reportFunctionCallError:error\n                                  forInvocation:invocation\n                                         origin:origin\n                                         window:self.view.window];\n        }\n    }];\n}\n\n- (void)applyAction:(iTermAction *)action {\n    [self.textview.window makeFirstResponder:self.textview];\n    [self performKeyBindingAction:[iTermKeyBindingAction withAction:action.action\n                                                          parameter:action.parameter\n                                                           escaping:action.escaping\n                                                          applyMode:action.applyMode]\n                            event:nil];\n}\n\n// This is limited to the actions that don't need any existing session\n+ (BOOL)performKeyBindingAction:(iTermKeyBindingAction *)action event:(NSEvent *)event {\n    if (!action) {\n        return NO;\n    }\n    NSArray<PTYSession *> *sessions = [PTYSession sessionsForActionApplyMode:action.applyMode focused:nil];\n    if (action.applyMode != iTermActionApplyModeCurrentSession && sessions.count > 0) {\n        for (PTYSession *session in sessions) {\n            [session reallyPerformKeyBindingAction:action event:event];\n        }\n        return YES;\n    }\n\n    switch (action.keyAction) {\n        case KEY_ACTION_INVALID:\n            // No action\n            return NO;\n\n        case KEY_ACTION_IGNORE:\n            return YES;\n\n        case KEY_ACTION_MOVE_TAB_LEFT:\n        case KEY_ACTION_MOVE_TAB_RIGHT:\n        case KEY_ACTION_NEXT_MRU_TAB:\n        case KEY_ACTION_PREVIOUS_MRU_TAB:\n        case KEY_ACTION_NEXT_PANE:\n        case KEY_ACTION_PREVIOUS_PANE:\n        case KEY_ACTION_NEXT_SESSION:\n        case KEY_ACTION_NEXT_WINDOW:\n        case KEY_ACTION_PREVIOUS_SESSION:\n        case KEY_ACTION_PREVIOUS_WINDOW:\n        case KEY_ACTION_SCROLL_END:\n        case KEY_ACTION_SCROLL_HOME:\n        case KEY_ACTION_SCROLL_LINE_DOWN:\n        case KEY_ACTION_SCROLL_LINE_UP:\n        case KEY_ACTION_SCROLL_PAGE_DOWN:\n        case KEY_ACTION_SCROLL_PAGE_UP:\n        case KEY_ACTION_ESCAPE_SEQUENCE:\n        case KEY_ACTION_HEX_CODE:\n        case KEY_ACTION_TEXT:\n        case KEY_ACTION_VIM_TEXT:\n        case KEY_ACTION_RUN_COPROCESS:\n        case KEY_ACTION_SEND_C_H_BACKSPACE:\n        case KEY_ACTION_SEND_C_QM_BACKSPACE:\n        case KEY_ACTION_IR_FORWARD:\n        case KEY_ACTION_IR_BACKWARD:\n        case KEY_ACTION_SELECT_PANE_LEFT:\n        case KEY_ACTION_SELECT_PANE_RIGHT:\n        case KEY_ACTION_SELECT_PANE_ABOVE:\n        case KEY_ACTION_SELECT_PANE_BELOW:\n        case KEY_ACTION_DO_NOT_REMAP_MODIFIERS:\n        case KEY_ACTION_REMAP_LOCALLY:\n        case KEY_ACTION_TOGGLE_FULLSCREEN:\n        case KEY_ACTION_SPLIT_HORIZONTALLY_WITH_PROFILE:\n        case KEY_ACTION_SPLIT_VERTICALLY_WITH_PROFILE:\n        case KEY_ACTION_SET_PROFILE:\n        case KEY_ACTION_LOAD_COLOR_PRESET:\n        case KEY_ACTION_FIND_REGEX:\n        case KEY_FIND_AGAIN_DOWN:\n        case KEY_FIND_AGAIN_UP:\n        case KEY_ACTION_PASTE_SPECIAL_FROM_SELECTION:\n        case KEY_ACTION_PASTE_SPECIAL:\n        case KEY_ACTION_TOGGLE_HOTKEY_WINDOW_PINNING:\n        case KEY_ACTION_MOVE_END_OF_SELECTION_LEFT:\n        case KEY_ACTION_MOVE_END_OF_SELECTION_RIGHT:\n        case KEY_ACTION_MOVE_START_OF_SELECTION_LEFT:\n        case KEY_ACTION_MOVE_START_OF_SELECTION_RIGHT:\n        case KEY_ACTION_DECREASE_HEIGHT:\n        case KEY_ACTION_INCREASE_HEIGHT:\n        case KEY_ACTION_DECREASE_WIDTH:\n        case KEY_ACTION_INCREASE_WIDTH:\n        case KEY_ACTION_SWAP_PANE_LEFT:\n        case KEY_ACTION_SWAP_PANE_RIGHT:\n        case KEY_ACTION_SWAP_PANE_ABOVE:\n        case KEY_ACTION_SWAP_PANE_BELOW:\n        case KEY_ACTION_TOGGLE_MOUSE_REPORTING:\n        case KEY_ACTION_DUPLICATE_TAB:\n        case KEY_ACTION_MOVE_TO_SPLIT_PANE:\n        case KEY_ACTION_SEND_SNIPPET:\n        case KEY_ACTION_COMPOSE:\n        case KEY_ACTION_SEND_TMUX_COMMAND:\n        case KEY_ACTION_SWAP_WITH_NEXT_PANE:\n        case KEY_ACTION_SWAP_WITH_PREVIOUS_PANE:\n        case KEY_ACTION_ALERT_ON_NEXT_MARK:\n            return NO;\n\n        case KEY_ACTION_COPY_OR_SEND:\n            return [[NSApp mainMenu] performActionForItemWithSelector:@selector(copy:)];\n\n        case KEY_ACTION_PASTE_OR_SEND:\n            return [[NSApp mainMenu] performActionForItemWithSelector:@selector(paste:)];\n\n        case KEY_ACTION_INVOKE_SCRIPT_FUNCTION:\n            [iTermScriptFunctionCall callFunction:action.parameter\n                                          timeout:[[NSDate distantFuture] timeIntervalSinceNow]\n                                            scope:[iTermVariableScope globalsScope]\n                                       retainSelf:YES\n                                       completion:^(id value, NSError *error, NSSet<NSString *> *missing) {\n                if (error) {\n                    [PTYSession reportFunctionCallError:error\n                                          forInvocation:action.parameter\n                                                 origin:@\"Key Binding\"\n                                                 window:nil];\n                }\n            }];\n            return YES;\n\n        case KEY_ACTION_SELECT_MENU_ITEM:\n            [PTYSession selectMenuItem:action.parameter];\n            return YES;\n        case KEY_ACTION_NEW_TAB_WITH_PROFILE:\n        case KEY_ACTION_NEW_WINDOW_WITH_PROFILE: {\n            Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:action.parameter];\n            [iTermSessionLauncher launchBookmark:profile\n                                      inTerminal:nil\n                              respectTabbingMode:NO\n                                      completion:nil];\n            return YES;\n        }\n        case KEY_ACTION_UNDO:\n            [PTYSession selectMenuItemWithSelector:@selector(undo:)];\n            return YES;\n\n        case KEY_ACTION_SEQUENCE: {\n            NSArray<iTermKeyBindingAction *> *subactions = [action.parameter keyBindingActionsFromSequenceParameter];\n            for (iTermKeyBindingAction *subaction in subactions) {\n                [self performKeyBindingAction:subaction event:event];\n            }\n            return YES;\n        }\n    }\n    assert(false);\n    return NO;\n}\n\n+ (NSArray<PTYSession *> *)sessionsForActionApplyMode:(iTermActionApplyMode)mode focused:(PTYSession *)focused {\n    switch (mode) {\n        case iTermActionApplyModeCurrentSession:\n            return focused ? @[ focused ] : @[];\n        case iTermActionApplyModeAllSessions:\n            return [[iTermController sharedInstance] allSessions];\n        case iTermActionApplyModeUnfocusedSessions:\n            return [[[iTermController sharedInstance] allSessions] arrayByRemovingObject:focused];\n        case iTermActionApplyModeAllInWindow:\n            return [focused.delegate.realParentWindow allSessions] ?: @[];\n        case iTermActionApplyModeAllInTab:\n            return [focused.delegate sessions] ?: @[];\n        case iTermActionApplyModeBroadcasting:\n            if (!focused) {\n                return @[];\n            }\n            if (focused.delegate.realParentWindow.broadcastMode == BROADCAST_OFF) {\n                return @[ focused ];\n            }\n            return focused.delegate.realParentWindow.broadcastSessions ?: @[ focused ];\n    }\n    return @[];\n}\n\n- (void)performKeyBindingAction:(iTermKeyBindingAction *)action event:(NSEvent *)event {\n    if (!action) {\n        return;\n    }\n    for (PTYSession *session in [PTYSession sessionsForActionApplyMode:action.applyMode focused:self]) {\n        [session reallyPerformKeyBindingAction:action event:event];\n    }\n}\n\n- (void)reallyPerformKeyBindingAction:(iTermKeyBindingAction *)action event:(NSEvent *)event {\n    BOOL isTmuxGateway = (!_exited && self.tmuxMode == TMUX_GATEWAY);\n    id<iTermWindowController> windowController = self.delegate.realParentWindow ?: [[iTermController sharedInstance] currentTerminal];\n\n    switch (action.keyAction) {\n        case KEY_ACTION_MOVE_TAB_LEFT:\n            [[_delegate realParentWindow] moveTabLeft:nil];\n            break;\n        case KEY_ACTION_MOVE_TAB_RIGHT:\n            [[_delegate realParentWindow] moveTabRight:nil];\n            break;\n        case KEY_ACTION_NEXT_MRU_TAB:\n            [[[_delegate realParentWindow] tabView] cycleKeyDownWithModifiers:[event it_modifierFlags]\n                                                                     forwards:YES];\n            break;\n        case KEY_ACTION_PREVIOUS_MRU_TAB:\n            [[[_delegate realParentWindow] tabView] cycleKeyDownWithModifiers:[event it_modifierFlags]\n                                                                     forwards:NO];\n            break;\n        case KEY_ACTION_NEXT_PANE:\n            [_delegate nextSession];\n            break;\n        case KEY_ACTION_PREVIOUS_PANE:\n            [_delegate previousSession];\n            break;\n        case KEY_ACTION_NEXT_SESSION:\n            [[_delegate realParentWindow] nextTab:nil];\n            break;\n        case KEY_ACTION_NEXT_WINDOW:\n            [[iTermController sharedInstance] nextTerminal];\n            break;\n        case KEY_ACTION_PREVIOUS_SESSION:\n            [[_delegate realParentWindow] previousTab:nil];\n            break;\n        case KEY_ACTION_PREVIOUS_WINDOW:\n            [[iTermController sharedInstance] previousTerminal];\n            break;\n        case KEY_ACTION_SCROLL_END:\n            [_textview scrollEnd];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_SCROLL_HOME:\n            [_textview scrollHome];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_SCROLL_LINE_DOWN:\n            [_textview scrollLineDown:self];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_SCROLL_LINE_UP:\n            [_textview scrollLineUp:self];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_SCROLL_PAGE_DOWN:\n            [_textview scrollPageDown:self];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_SCROLL_PAGE_UP:\n            [_textview scrollPageUp:self];\n            [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n            break;\n        case KEY_ACTION_ESCAPE_SEQUENCE:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self sendEscapeSequence:action.parameter];\n            break;\n        case KEY_ACTION_HEX_CODE:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self sendHexCode:action.parameter];\n            break;\n        case KEY_ACTION_TEXT:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self sendText:action.parameter escaping:action.escaping];\n            break;\n        case KEY_ACTION_VIM_TEXT:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self sendText:action.parameter escaping:action.vimEscaping];\n            break;\n        case KEY_ACTION_SEND_SNIPPET:\n            if (_exited || isTmuxGateway) {\n                return;\n            } else {\n                DLog(@\"Look up snippet with param %@\", action.parameter);\n                iTermSnippet *snippet = [[iTermSnippetsModel sharedInstance] snippetWithActionKey:action.parameter];\n                if (snippet) {\n                    [self sendText:snippet.value escaping:snippet.escaping];\n                }\n            }\n            break;\n        case KEY_ACTION_COMPOSE:\n            if (_exited || isTmuxGateway) {\n                return;\n            } else {\n                DLog(@\"Open composer with%@\", action.parameter);\n                [self.composerManager showWithCommand:action.parameter];\n            }\n            break;\n        case KEY_ACTION_SEND_TMUX_COMMAND:\n            if (_exited || isTmuxGateway || !self.isTmuxClient) {\n                return;\n            }\n            [self performTmuxCommand:action.parameter];\n            break;\n        case KEY_ACTION_RUN_COPROCESS:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self launchCoprocessWithCommand:action.parameter];\n            break;\n        case KEY_ACTION_SELECT_MENU_ITEM:\n            [PTYSession selectMenuItem:action.parameter];\n            break;\n\n        case KEY_ACTION_SEND_C_H_BACKSPACE:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self writeStringWithLatin1Encoding:@\"\\010\"];\n            break;\n        case KEY_ACTION_SEND_C_QM_BACKSPACE:\n            if (_exited || isTmuxGateway) {\n                return;\n            }\n            [self writeStringWithLatin1Encoding:@\"\\177\"]; // decimal 127\n            break;\n        case KEY_ACTION_IGNORE:\n            break;\n        case KEY_ACTION_IR_FORWARD:\n            break;\n        case KEY_ACTION_IR_BACKWARD:\n            if (isTmuxGateway) {\n                return;\n            }\n            [[iTermController sharedInstance] irAdvance:-1];\n            break;\n        case KEY_ACTION_SELECT_PANE_LEFT:\n            [windowController selectPaneLeft:nil];\n            break;\n        case KEY_ACTION_SELECT_PANE_RIGHT:\n            [windowController selectPaneRight:nil];\n            break;\n        case KEY_ACTION_SELECT_PANE_ABOVE:\n            [windowController selectPaneUp:nil];\n            break;\n        case KEY_ACTION_SELECT_PANE_BELOW:\n            [windowController selectPaneDown:nil];\n            break;\n        case KEY_ACTION_DO_NOT_REMAP_MODIFIERS:\n        case KEY_ACTION_REMAP_LOCALLY:\n            break;\n        case KEY_ACTION_TOGGLE_FULLSCREEN:\n            [windowController toggleFullScreenMode:nil];\n            break;\n        case KEY_ACTION_NEW_WINDOW_WITH_PROFILE:\n            [[_delegate realParentWindow] newWindowWithBookmarkGuid:action.parameter];\n            break;\n        case KEY_ACTION_NEW_TAB_WITH_PROFILE:\n            [[_delegate realParentWindow] newTabWithBookmarkGuid:action.parameter];\n            break;\n        case KEY_ACTION_SPLIT_HORIZONTALLY_WITH_PROFILE: {\n            Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:action.parameter];\n            if (!profile) {\n                break;\n            }\n            [[_delegate realParentWindow] asyncSplitVertically:NO\n                                                        before:NO\n                                                       profile:profile\n                                                 targetSession:[[_delegate realParentWindow] currentSession]\n                                                    completion:nil\n                                                         ready:nil];\n            break;\n        }\n        case KEY_ACTION_SPLIT_VERTICALLY_WITH_PROFILE: {\n            Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:action.parameter];\n            if (!profile) {\n                break;\n            }\n            [[_delegate realParentWindow] asyncSplitVertically:YES\n                                                        before:NO\n                                                       profile:profile\n                                                 targetSession:[[_delegate realParentWindow] currentSession]\n                                                    completion:nil\n                                                         ready:nil];\n            break;\n        }\n        case KEY_ACTION_SET_PROFILE: {\n            Profile *newProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:action.parameter];\n            if (newProfile) {\n                [self setProfile:newProfile preservingName:YES];\n            }\n            break;\n        }\n        case KEY_ACTION_LOAD_COLOR_PRESET: {\n            // Divorce & update self\n            [self setColorsFromPresetNamed:action.parameter];\n\n            // Try to update the backing profile if possible, which may undivorce you. The original\n            // profile may not exist so this could do nothing.\n            ProfileModel *model = [ProfileModel sharedInstance];\n            Profile *profile;\n            if (self.isDivorced) {\n                profile = [[ProfileModel sharedInstance] bookmarkWithGuid:_profile[KEY_ORIGINAL_GUID]];\n            } else {\n                profile = self.profile;\n            }\n            if (profile) {\n                [model addColorPresetNamed:action.parameter toProfile:profile];\n            }\n            break;\n        }\n\n        case KEY_ACTION_FIND_REGEX: {\n            [_view createFindDriverIfNeeded];\n            [_view.findDriver closeViewAndDoTemporarySearchForString:action.parameter\n                                                                mode:iTermFindModeCaseSensitiveRegex\n                                                            progress:nil];\n            break;\n        }\n        case KEY_FIND_AGAIN_DOWN:\n            // The UI exposes this as \"find down\" so it doesn't respect swapFindNextPrevious\n            [self searchNext];\n            break;\n\n        case KEY_FIND_AGAIN_UP:\n            // The UI exposes this as \"find up\" so it doesn't respect swapFindNextPrevious\n            [self searchPrevious];\n            break;\n\n        case KEY_ACTION_PASTE_SPECIAL_FROM_SELECTION: {\n            NSString *string = [[iTermController sharedInstance] lastSelectionPromise].wait.maybeFirst;\n            if (string.length) {\n                [_pasteHelper pasteString:string\n                             stringConfig:action.parameter];\n            }\n            break;\n        }\n\n        case KEY_ACTION_PASTE_SPECIAL: {\n            NSString *string = [NSString stringFromPasteboard];\n            if (string.length) {\n                [_pasteHelper pasteString:string\n                             stringConfig:action.parameter];\n            }\n            break;\n        }\n\n        case KEY_ACTION_TOGGLE_HOTKEY_WINDOW_PINNING: {\n            DLog(@\"Toggle pinning\");\n            BOOL autoHid = [iTermProfilePreferences boolForKey:KEY_HOTKEY_AUTOHIDE inProfile:self.profile];\n            DLog(@\"Getting profile with guid %@ from originalProfile %p\", self.originalProfile[KEY_GUID], self.originalProfile);\n            Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:self.originalProfile[KEY_GUID]];\n            if (profile) {\n                DLog(@\"Found a profile\");\n                [iTermProfilePreferences setBool:!autoHid forKey:KEY_HOTKEY_AUTOHIDE inProfile:profile model:[ProfileModel sharedInstance]];\n            }\n            break;\n        }\n        case KEY_ACTION_UNDO:\n            [PTYSession selectMenuItemWithSelector:@selector(undo:)];\n            break;\n\n        case KEY_ACTION_MOVE_END_OF_SELECTION_LEFT:\n            [_textview moveSelectionEndpoint:kPTYTextViewSelectionEndpointEnd\n                                 inDirection:kPTYTextViewSelectionExtensionDirectionLeft\n                                          by:[action.parameter integerValue]];\n            break;\n        case KEY_ACTION_MOVE_END_OF_SELECTION_RIGHT:\n            [_textview moveSelectionEndpoint:kPTYTextViewSelectionEndpointEnd\n                                 inDirection:kPTYTextViewSelectionExtensionDirectionRight\n                                          by:[action.parameter integerValue]];\n            break;\n        case KEY_ACTION_MOVE_START_OF_SELECTION_LEFT:\n            [_textview moveSelectionEndpoint:kPTYTextViewSelectionEndpointStart\n                                 inDirection:kPTYTextViewSelectionExtensionDirectionLeft\n                                          by:[action.parameter integerValue]];\n            break;\n        case KEY_ACTION_MOVE_START_OF_SELECTION_RIGHT:\n            [_textview moveSelectionEndpoint:kPTYTextViewSelectionEndpointStart\n                                 inDirection:kPTYTextViewSelectionExtensionDirectionRight\n                                          by:[action.parameter integerValue]];\n            break;\n\n        case KEY_ACTION_DECREASE_HEIGHT:\n            [windowController decreaseHeightOfSession:self];\n            break;\n        case KEY_ACTION_INCREASE_HEIGHT:\n            [windowController increaseHeightOfSession:self];\n            break;\n\n        case KEY_ACTION_DECREASE_WIDTH:\n            [windowController decreaseWidthOfSession:self];\n            break;\n        case KEY_ACTION_INCREASE_WIDTH:\n            [windowController increaseWidthOfSession:self];\n            break;\n\n        case KEY_ACTION_SWAP_PANE_LEFT:\n            [windowController swapPaneLeft];\n            break;\n        case KEY_ACTION_SWAP_PANE_RIGHT:\n            [windowController swapPaneRight];\n            break;\n        case KEY_ACTION_SWAP_PANE_ABOVE:\n            [windowController swapPaneUp];\n            break;\n        case KEY_ACTION_SWAP_PANE_BELOW:\n            [windowController swapPaneDown];\n            break;\n        case KEY_ACTION_TOGGLE_MOUSE_REPORTING:\n            [self setXtermMouseReporting:![self xtermMouseReporting]];\n            break;\n        case KEY_ACTION_INVOKE_SCRIPT_FUNCTION:\n            [self invokeFunctionCall:action.parameter\n                               scope:self.variablesScope\n                              origin:@\"Key Binding\"];\n            break;\n        case KEY_ACTION_DUPLICATE_TAB:\n            [self.delegate sessionDuplicateTab];\n            break;\n        case KEY_ACTION_MOVE_TO_SPLIT_PANE:\n            [self textViewMovePane];\n            break;\n\n        case KEY_ACTION_SEQUENCE: {\n            PTYSession *session = self;\n            for (iTermKeyBindingAction *subaction in [action.parameter keyBindingActionsFromSequenceParameter]) {\n                [session performKeyBindingAction:subaction event:event];\n                session = [[[iTermController sharedInstance] currentTerminal] currentSession] ?: self;\n            }\n        case KEY_ACTION_SWAP_WITH_NEXT_PANE:\n            [self.delegate sessionSwapWithSessionInDirection:1];\n            break;\n        case KEY_ACTION_SWAP_WITH_PREVIOUS_PANE:\n            [self.delegate sessionSwapWithSessionInDirection:-1];\n            break;\n        case KEY_ACTION_COPY_OR_SEND:\n            if ([self hasSelection]) {\n                [_textview copy:nil];\n                break;\n            }\n            [self regularKeyDown:[NSApp currentEvent]];\n            break;\n        }\n        case KEY_ACTION_PASTE_OR_SEND:\n            if ([[PTYSession pasteboardString] length]) {\n                [_textview paste:[[NSApp mainMenu] itemWithSelector:@selector(paste:) tag:0]];\n                break;\n            }\n            [self regularKeyDown:[NSApp currentEvent]];\n            break;\n\n        case KEY_ACTION_ALERT_ON_NEXT_MARK:\n            self.alertOnNextMark = YES;\n            break;\n\n        default:\n            XLog(@\"Unknown key action %@\", action);\n            break;\n    }\n}\n\n#pragma mark - Key Handling\n\n- (BOOL)eventNeedsMitigation:(NSEvent *)event {\n    if (event.keyCode != kVK_Escape) {\n        return NO;\n    }\n    // Credit to https://github.com/niw/HapticKey for the magic number.\n    const int64_t keyboardType = CGEventGetIntegerValueField(event.CGEvent, kCGKeyboardEventKeyboardType);\n    static const int64_t touchbarKeyboardType = 198;\n    if (keyboardType != touchbarKeyboardType) {\n        return NO;\n    }\n    if (event.isARepeat) {\n        return NO;\n    }\n\n    return YES;\n}\n\n- (void)actuateHapticFeedbackForEvent:(NSEvent *)event {\n    if (![iTermPreferences boolForKey:kPreferenceKeyEnableHapticFeedbackForEsc]) {\n        return;\n    }\n    if (event.type == NSEventTypeKeyDown) {\n        [[iTermHapticActuator sharedActuator] actuateTouchDownFeedback];\n        return;\n    }\n    if (event.type == NSEventTypeKeyUp && event.keyCode == kVK_Escape) {\n        [[iTermHapticActuator sharedActuator] actuateTouchUpFeedback];\n        return;\n    }\n}\n\n- (void)playSoundForEvent:(NSEvent *)event {\n    if (![iTermPreferences boolForKey:kPreferenceKeyEnableSoundForEsc]) {\n        return;\n    }\n    if (event.type == NSEventTypeKeyDown) {\n        [[iTermSoundPlayer keyClick] play];\n    }\n}\n\n- (void)showVisualIndicatorForEvent:(NSEvent *)event {\n    if (_showingVisualIndicatorForEsc) {\n        return;\n    }\n    if (![iTermPreferences boolForKey:kPreferenceKeyVisualIndicatorForEsc]) {\n        return;\n    }\n    _showingVisualIndicatorForEsc = YES;\n\n    NSNumber *savedCursorTypeOverride = _cursorTypeOverride;\n\n    ITermCursorType temporaryType;\n    if (self.cursorType == CURSOR_BOX) {\n        temporaryType = CURSOR_UNDERLINE;\n    } else {\n        temporaryType = CURSOR_BOX;\n    }\n\n    self.cursorTypeOverride = @(temporaryType);\n    [_textview setCursorNeedsDisplay];\n    _cursorTypeOverrideChanged = NO;\n\n    [self retain];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 / 15.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        if (!self->_cursorTypeOverrideChanged) {\n            self.cursorTypeOverride = savedCursorTypeOverride;\n        }\n        self->_showingVisualIndicatorForEsc = NO;\n        [self release];\n    });\n}\n\n- (void)mitigateTouchBarStupidityForEvent:(NSEvent *)event {\n    if (![self eventNeedsMitigation:event]) {\n        return;\n    }\n    [self actuateHapticFeedbackForEvent:event];\n    [self playSoundForEvent:event];\n    [self showVisualIndicatorForEvent:event];\n}\n\n- (void)textViewSelectionDidChangeToTruncatedString:(NSString *)maybeSelection {\n    // Assign a maximum of maximumBytesToProvideToPythonAPI characters to the \"selection\"\n    // iTerm Variable\n    //\n    // The \"selectionLength\" iTerm variable contains the full length of the original\n    // selection; not the restricted length assigned to the \"selection\" iTerm Variable\n    DLog(@\"textViewSelectionDidChangeToTruncatedString: %@\", maybeSelection);\n\n    NSString *selection = maybeSelection ?: @\"\";\n    const int maxLength = [iTermAdvancedSettingsModel maximumBytesToProvideToPythonAPI];\n    [self.variablesScope setValue:[selection substringToIndex:MIN(maxLength, selection.length)] forVariableNamed:iTermVariableKeySessionSelection];\n    [self.variablesScope setValue:@(selection.length) forVariableNamed:iTermVariableKeySessionSelectionLength];\n}\n\n// Handle bookmark- and global-scope keybindings. If there is no keybinding then\n// pass the keystroke as input.\n- (void)keyDown:(NSEvent *)event {\n    [self mitigateTouchBarStupidityForEvent:event];\n\n    if (event.charactersIgnoringModifiers.length == 0) {\n        return;\n    }\n    if (event.type == NSEventTypeKeyDown) {\n        [self logKeystroke:event];\n        [self resumeOutputIfNeeded];\n\n        if ([self trySpecialKeyHandlersForEvent:event]) {\n            return;\n        }\n    }\n    [self regularKeyDown:event];\n}\n\n- (void)regularKeyDown:(NSEvent *)event {\n    DLog(@\"PTYSession keyDown not short-circuted by special handler\");\n    const NSEventModifierFlags mask = (NSEventModifierFlagCommand | NSEventModifierFlagOption | NSEventModifierFlagShift | NSEventModifierFlagControl);\n\n    if (!_screen.terminalSoftAlternateScreenMode &&\n        (event.modifierFlags & mask) == 0 &&\n        [iTermProfilePreferences boolForKey:KEY_MOVEMENT_KEYS_SCROLL_OUTSIDE_INTERACTIVE_APPS inProfile:self.profile]) {\n        switch (event.keyCode) {\n            case kVK_PageUp:\n                [_textview scrollPageUp:nil];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n                return;\n\n            case kVK_PageDown:\n                [_textview scrollPageDown:nil];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n                return;\n\n            case kVK_Home:\n                [_textview scrollHome];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n                return;\n\n            case kVK_End:\n                [_textview scrollEnd];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n                return;\n\n            case kVK_UpArrow:\n                if (!_exited) {\n                    break;\n                }\n                [_textview scrollLineUp:nil];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n                break;\n\n            case kVK_DownArrow:\n                if (!_exited) {\n                    break;\n                }\n                [_textview scrollLineDown:nil];\n                [(PTYScrollView *)[_textview enclosingScrollView] detectUserScroll];\n\n            default:\n                break;\n        }\n    }\n\n    if (_exited) {\n        DLog(@\"Terminal already dead\");\n        return;\n    }\n\n    NSData *const dataToSend = [_keyMapper keyMapperDataForPostCocoaEvent:event];\n    DLog(@\"dataToSend=%@\", dataToSend);\n    if (dataToSend) {\n        [self writeLatin1EncodedData:dataToSend broadcastAllowed:YES reporting:NO];\n    }\n}\n\n- (void)keyUp:(NSEvent *)event {\n    if ([self shouldReportOrFilterKeystrokesForAPI]) {\n        [self sendKeystrokeNotificationForEvent:event advanced:YES];\n    }\n    if (_screen.terminalReportKeyUp) {\n        NSData *const dataToSend = [_keyMapper keyMapperDataForKeyUp:event];\n        if (dataToSend) {\n            [self writeLatin1EncodedData:dataToSend broadcastAllowed:YES reporting:NO];\n        }\n    }\n}\n- (void)logKeystroke:(NSEvent *)event {\n    const unichar unicode = event.characters.length > 0 ? [event.characters characterAtIndex:0] : 0;\n    DLog(@\"event:%@ (%llx+%x)[%@][%@]:%x(%c) <%lu>\",\n         event, (unsigned long long)event.it_modifierFlags, event.keyCode, event.characters,\n         event.charactersIgnoringModifiers, unicode, unicode,\n         (event.it_modifierFlags & NSEventModifierFlagNumericPad));\n}\n\n- (BOOL)trySpecialKeyHandlersForEvent:(NSEvent *)event {\n    if ([self maybeHandleZoomedKeyEvent:event]) {\n        return YES;\n    }\n    if ([self maybeHandleInstantReplayKeyEvent:event]) {\n        return YES;\n    }\n    if ([self maybeHandleKeyBindingActionForKeyEvent:event]) {\n        return YES;\n    }\n    if ([self maybeHandleTmuxGatewayKeyEvent:event]) {\n        return YES;\n    }\n    if ([self textViewIsZoomedIn]) {\n        DLog(@\"Swallow keyboard input while zoomed.\");\n        return YES;\n    }\n    return NO;\n}\n\n- (BOOL)maybeHandleTmuxGatewayKeyEvent:(NSEvent *)event {\n    // Key is not bound to an action.\n    if (_exited) {\n        return NO;\n    }\n    if (self.tmuxMode != TMUX_GATEWAY) {\n        return NO;\n    }\n\n    [self handleKeypressInTmuxGateway:event];\n    DLog(@\"Special handler: TMUX GATEWAY\");\n    return YES;\n}\n\n- (BOOL)maybeHandleZoomedKeyEvent:(NSEvent *)event {\n    if (![self textViewIsZoomedIn]) {\n        return NO;\n    }\n\n    const unichar character = event.characters.length > 0 ? [event.characters characterAtIndex:0] : 0;\n    const NSEventModifierFlags mask = (NSEventModifierFlagCommand |\n                                       NSEventModifierFlagControl |\n                                       NSEventModifierFlagOption |\n                                       NSEventModifierFlagShift);\n    if ((event.modifierFlags & mask) != 0) {\n        // Let it go to the key binding handler.\n        return NO;\n    }\n\n    if (character != 27) {\n        // Didn't press esc\n        return NO;\n    }\n\n    // Escape exits zoom (pops out one level, since you can zoom repeatedly)\n    // The zoomOut: IBAction doesn't get performed by shortcut, I guess because Esc is not a\n    // valid shortcut. So we do it here.\n    DLog(@\"Special handler: ZOOM OUT - unmodified esc\");\n    return [self unzoomIfPossible];\n}\n\n- (BOOL)unzoomIfPossible {\n    if (![self textViewIsZoomedIn]) {\n        return NO;\n    }\n\n    if (self.filter.length) {\n        DLog(@\"stopFiltering\");\n        [self stopFiltering];\n    } else {\n        DLog(@\"Unzooming\");\n        [[_delegate realParentWindow] replaceSyntheticActiveSessionWithLiveSessionIfNeeded];\n    }\n    return YES;\n}\n\n- (PTYSessionZoomState *)stateToSaveForZoom {\n    if (self.filter) {\n        return nil;\n    }\n    const long long lineNumber = [_textview firstVisibleAbsoluteLineNumber];\n    NSString *query = nil;\n    if (_view.findDriver.findString.length) {\n        query = _view.findDriver.findString;\n    }\n    return [[[PTYSessionZoomState alloc] initWithFirstVisibleAbsoluteLineNumber:lineNumber\n                                                                    searchQuery:query] autorelease];\n}\n\n- (void)restoreStateForZoom:(PTYSessionZoomState *)state {\n    if (!state) {\n        return;\n    }\n    [_textview scrollToAbsoluteOffset:state.firstVisibleAbsoluteLineNumber\n                               height:_screen.height];\n    if (state.searchQuery.length) {\n        [_view.findDriver setFindStringUnconditionally:state.searchQuery];\n    }\n}\n\n- (BOOL)maybeHandleInstantReplayKeyEvent:(NSEvent *)event {\n    if (![[_delegate realParentWindow] inInstantReplay]) {\n        return NO;\n    }\n\n    [self handleKeypressInInstantReplay:event];\n    DLog(@\"Special handler: INSTANT REPLAY\");\n    return YES;\n}\n\n- (BOOL)maybeHandleKeyBindingActionForKeyEvent:(NSEvent *)event {\n    // Check if we have a custom key mapping for this event\n    iTermKeystroke *keystroke = [iTermKeystroke withEvent:event];\n    iTermKeyBindingAction *action = [iTermKeyMappings actionForKeystroke:keystroke\n                                                             keyMappings:self.profile[KEY_KEYBOARD_MAP]];\n\n    if (!action) {\n        return NO;\n    }\n    DLog(@\"PTYSession keyDown action=%@\", action);\n    // A special action was bound to this key combination.\n    [self performKeyBindingAction:action event:event];\n\n    DLog(@\"Special handler: KEY BINDING ACTION\");\n    return YES;\n}\n\n- (void)handleKeypressInInstantReplay:(NSEvent *)event {\n    DLog(@\"PTYSession keyDown in IR\");\n\n    // Special key handling in IR mode, and keys never get sent to the live\n    // session, even though it might be displayed.\n    const unichar character = event.characters.length > 0 ? [event.characters characterAtIndex:0] : 0;\n    const unichar characterIgnoringModifiers = [event.charactersIgnoringModifiers length] > 0 ? [event.charactersIgnoringModifiers characterAtIndex:0] : 0;\n    const NSEventModifierFlags modifiers = event.it_modifierFlags;\n\n    if (character == 27) {\n        // Escape exits IR\n        [[_delegate realParentWindow] closeInstantReplay:self orTerminateSession:YES];\n        return;\n    } else if (characterIgnoringModifiers == NSLeftArrowFunctionKey) {\n        // Left arrow moves to prev frame\n        int n = 1;\n        if (modifiers & NSEventModifierFlagShift) {\n            n = 15;\n        }\n        for (int i = 0; i < n; i++) {\n            [[_delegate realParentWindow] irPrev:self];\n        }\n    } else if (characterIgnoringModifiers == NSRightArrowFunctionKey) {\n        // Right arrow moves to next frame\n        int n = 1;\n        if (modifiers & NSEventModifierFlagShift) {\n            n = 15;\n        }\n        for (int i = 0; i < n; i++) {\n            [[_delegate realParentWindow] irNext:self];\n        }\n    } else {\n        DLog(@\"Beep: Unrecongized keystroke in IR\");\n        NSBeep();\n    }\n}\n\n\n- (NSData *)backspaceData {\n    iTermKeyBindingAction *action = [iTermKeyMappings actionForKeystroke:[iTermKeystroke backspace]\n                                                             keyMappings:[[self profile] objectForKey:KEY_KEYBOARD_MAP]];\n    if (!action) {\n        const char del = 0x7f;\n        return [NSData dataWithBytes:&del length:1];\n    }\n    switch (action.keyAction) {\n        case KEY_ACTION_HEX_CODE:\n            return [self dataForHexCodes:action.parameter];\n\n        case KEY_ACTION_TEXT:\n            return [action.parameter dataUsingEncoding:self.encoding];\n\n        case KEY_ACTION_VIM_TEXT:\n            return [[action.parameter stringByExpandingVimSpecialCharacters] dataUsingEncoding:self.encoding];\n\n        case KEY_ACTION_ESCAPE_SEQUENCE:\n            return [[@\"\\e\" stringByAppendingString:action.parameter] dataUsingEncoding:self.encoding];\n\n        case KEY_ACTION_SEND_C_H_BACKSPACE:\n            return [@\"\\010\" dataUsingEncoding:self.encoding];\n\n        case KEY_ACTION_SEND_C_QM_BACKSPACE:\n            return [@\"\\177\" dataUsingEncoding:self.encoding];\n\n        default:\n            break;\n    }\n\n    return nil;\n}\n\n- (BOOL)hasActionableKeyMappingForEvent:(NSEvent *)event {\n    if (_textview.selection.hasSelection && !_textview.selection.live) {\n        if ([_modeHandler shouldAutoEnterWithEvent:event]) {\n            return NO;\n        }\n    }\n    return [[self _keyBindingActionForEvent:event] isActionable];\n}\n\n- (BOOL)shouldRespectTerminalMetaSendsEscape {\n    if (![iTermAdvancedSettingsModel supportDecsetMetaSendsEscape]) {\n        return NO;\n    }\n    if ([[[self profile] objectForKey:KEY_OPTION_KEY_SENDS] intValue] == OPT_ESC) {\n        return NO;\n    }\n    if ([[[self profile] objectForKey:KEY_RIGHT_OPTION_KEY_SENDS] intValue] == OPT_ESC) {\n        return NO;\n    }\n    return YES;\n}\n\n- (iTermOptionKeyBehavior)optionKey {\n    if ([self shouldRespectTerminalMetaSendsEscape] &&\n        _screen.terminalMetaSendsEscape &&\n        [iTermProfilePreferences boolForKey:KEY_LEFT_OPTION_KEY_CHANGEABLE inProfile:self.profile]) {\n        return OPT_ESC;\n    }\n    return [[[self profile] objectForKey:KEY_OPTION_KEY_SENDS] intValue];\n}\n\n- (iTermOptionKeyBehavior)rightOptionKey {\n    if ([self shouldRespectTerminalMetaSendsEscape] &&\n        _screen.terminalMetaSendsEscape &&\n        [iTermProfilePreferences boolForKey:KEY_RIGHT_OPTION_KEY_CHANGEABLE inProfile:self.profile]) {\n        return OPT_ESC;\n    }\n    NSNumber *rightOptPref = [[self profile] objectForKey:KEY_RIGHT_OPTION_KEY_SENDS];\n    if (rightOptPref == nil) {\n        return [self optionKey];\n    }\n    return [rightOptPref intValue];\n}\n\n- (BOOL)applicationKeypadAllowed\n{\n    return [[[self profile] objectForKey:KEY_APPLICATION_KEYPAD_ALLOWED] boolValue];\n}\n\n// Contextual menu\n- (void)menuForEvent:(NSEvent *)theEvent menu:(NSMenu *)theMenu\n{\n    // Ask the parent if it has anything to add\n    if ([_delegate realParentWindow] &&\n        [[_delegate realParentWindow] respondsToSelector:@selector(menuForEvent:menu:)]) {\n        [[_delegate realParentWindow] menuForEvent:theEvent menu:theMenu];\n    }\n}\n\n// All pastes except \"Advanced\" go through this method.\n- (void)pasteString:(NSString *)theString flags:(PTYSessionPasteFlags)flags {\n    if (!theString.length) {\n        return;\n    }\n    DLog(@\"pasteString:flags: length=%@ flags=%@\", @([theString length]), @(flags));\n    iTermTabTransformTags tabTransform = kTabTransformNone;\n    int spacesPerTab = -1;\n    if (flags & kPTYSessionPasteWithShellEscapedTabs) {\n        tabTransform = kTabTransformEscapeWithCtrlV;\n    } else if (!_screen.terminalBracketedPasteMode) {\n        spacesPerTab = [_pasteHelper numberOfSpacesToConvertTabsTo:theString];\n        if (spacesPerTab >= 0) {\n            tabTransform = kTabTransformConvertToSpaces;\n        } else if (spacesPerTab == kNumberOfSpacesPerTabOpenAdvancedPaste) {\n            [_pasteHelper showAdvancedPasteWithFlags:flags];\n            return;\n        } else if (spacesPerTab == kNumberOfSpacesPerTabCancel) {\n            return;\n        }\n    }\n\n    DLog(@\"Calling pasteString:flags: on helper...\");\n    [_pasteHelper pasteString:theString\n                       slowly:!!(flags & kPTYSessionPasteSlowly)\n             escapeShellChars:!!(flags & kPTYSessionPasteEscapingSpecialCharacters)\n                     isUpload:NO\n              allowBracketing:!(flags & kPTYSessionPasteBracketingDisabled)\n                 tabTransform:tabTransform\n                 spacesPerTab:spacesPerTab];\n}\n\n// Pastes the current string in the clipboard. Uses the sender's tag to get flags.\n- (void)paste:(id)sender {\n    DLog(@\"PTYSession paste:\");\n\n    if ([self haveAutoComposer]) {\n        _textViewShouldTakeFirstResponder = NO;\n        [self makeComposerFirstResponderIfAllowed];\n        [_composerManager paste:sender];\n        return;\n    }\n    // If this class is used in a non-iTerm2 app (as a library), we might not\n    // be called from a menu item so just use no flags in this case.\n    [self pasteString:[PTYSession pasteboardString] flags:[sender isKindOfClass:NSMenuItem.class] ? [sender tag] : 0];\n}\n\n// Show advanced paste window.\n- (IBAction)pasteOptions:(id)sender {\n    [_pasteHelper showPasteOptionsInWindow:_delegate.realParentWindow.window\n                         bracketingEnabled:_screen.terminalBracketedPasteMode];\n}\n\n- (void)textViewFontDidChange\n{\n    if ([self isTmuxClient]) {\n        [self notifyTmuxFontChange];\n    }\n    [_view updateScrollViewFrame];\n    [self updateMetalDriver];\n    [_view.driver expireNonASCIIGlyphs];\n}\n\n- (BOOL)textViewHasBackgroundImage {\n    return self.effectiveBackgroundImage != nil;\n}\n\n// Lots of different views need to draw the background image.\n// - Obviously, PTYTextView uses it for the area where text appears.\n// - SessionView will draw it for an area below the scroll view when the cell size doesn't evenly\n// divide its size.\n// - TextViewWrapper will draw it for a few pixels above the scrollview in the VMARGIN.\n// This combines drawing into these different views in a consistent way.\n// It also draws the dotted border when there is a maximized pane.\n//\n// view: the view whose -drawRect is currently running and is being drawn into.\n// rect: the rectangle in the coordinate system of |view|.\n// blendDefaultBackground: If set, the default background color will be blended over the background\n// image. If there is no image and this flag is set then the background color is drawn instead. This\n// way SessionView and TextViewWrapper don't have to worry about whether a background image is\n// present.\n//\n// The only reason this still exists is because when subpixel antialiasing is enabled we can't\n// draw text on a clear background over a background image. The background image needs to be drawn\n// to the same view and then the text can be properly composited over it.\n- (BOOL)textViewDrawBackgroundImageInView:(NSView *)view\n                                 viewRect:(NSRect)dirtyRect\n                   blendDefaultBackground:(BOOL)blendDefaultBackground\n                            virtualOffset:(CGFloat)virtualOffset NS_DEPRECATED_MAC(10_0, 10_16) {\n    if (!self.shouldDrawBackgroundImageManually) {\n        return NO;\n    }\n    if (!_backgroundDrawingHelper) {\n        _backgroundDrawingHelper = [[iTermBackgroundDrawingHelper alloc] init];\n        _backgroundDrawingHelper.delegate = self;\n    }\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        NSRect contentRect = self.view.contentRect;\n        if (contentRect.size.width == 0 ||\n            contentRect.size.height == 0) {\n            return NO;\n        }\n        [_backgroundDrawingHelper drawBackgroundImageInView:view\n                                                  container:self.view\n                                                  dirtyRect:dirtyRect\n                                     visibleRectInContainer:NSMakeRect(0, 0, contentRect.size.width, contentRect.size.height)\n                                     blendDefaultBackground:blendDefaultBackground\n                                                       flip:NO\n                                              virtualOffset:virtualOffset];\n    } else {\n        NSView *container = [self.delegate sessionContainerView:self];\n        NSRect clippedDirtyRect = NSIntersectionRect(dirtyRect, view.enclosingScrollView.documentVisibleRect);;\n        NSRect windowVisibleRect = [self.view insetRect:container.bounds\n                                                flipped:YES\n                                 includeBottomStatusBar:![iTermPreferences boolForKey:kPreferenceKeySeparateStatusBarsPerPane]];\n        [_backgroundDrawingHelper drawBackgroundImageInView:view\n                                                  container:container\n                                                  dirtyRect:clippedDirtyRect\n                                     visibleRectInContainer:windowVisibleRect\n                                     blendDefaultBackground:blendDefaultBackground\n                                                       flip:YES\n                                              virtualOffset:virtualOffset];\n    }\n    return YES;\n}\n\n- (CGRect)textViewRelativeFrame {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return CGRectMake(0, 0, 1, 1);\n    }\n    NSRect viewRect;\n    NSRect containerBounds;\n    NSView *container = self.view.window.contentView;\n    viewRect = [self.view.metalView.superview convertRect:self.view.metalView.frame\n                                                   toView:container];\n    containerBounds = container.bounds;\n    // Flip it\n    viewRect.origin.y = containerBounds.size.height - viewRect.origin.y - viewRect.size.height;\n    return CGRectMake(viewRect.origin.x / containerBounds.size.width,\n                      viewRect.origin.y / containerBounds.size.height,\n                      viewRect.size.width / containerBounds.size.width,\n                      viewRect.size.height / containerBounds.size.height);\n}\n\n- (CGRect)textViewContainerRect {\n    if ([iTermPreferences boolForKey:kPreferenceKeyPerPaneBackgroundImage]) {\n        return self.view.frame;\n    }\n    NSView *container = [self.delegate sessionContainerView:self];\n    return [self.view insetRect:container.bounds\n                        flipped:YES\n         includeBottomStatusBar:![iTermPreferences boolForKey:kPreferenceKeySeparateStatusBarsPerPane]];\n}\n\n// This includes the portion of the metal view that is obscured by the status bar or per-pane title bar.\n- (NSEdgeInsets)textViewExtraMargins {\n    NSEdgeInsets margins = self.view.extraMargins;\n    // This is here because of tmux panes. They cause some extra bottom\n    // margins, and the regular -extraMargins code only includes stuff like\n    // the status bar on the bottom. The top margin it produces is still\n    // useful, so we keep that.\n    margins.bottom = _view.scrollview.frame.origin.y;\n    return margins;\n}\n\n- (iTermImageWrapper *)textViewBackgroundImage {\n    return _backgroundImage;\n}\n\n- (NSColor *)processedBackgroundColor {\n    NSColor *unprocessedColor = [_screen.colorMap colorForKey:kColorMapBackground];\n    return [_screen.colorMap processedBackgroundColorForBackgroundColor:unprocessedColor];\n}\n\n- (void)textViewPostTabContentsChangedNotification\n{\n    [[NSNotificationCenter defaultCenter] postNotificationName:@\"iTermTabContentsChanged\"\n                                                        object:self\n                                                      userInfo:nil];\n}\n\n- (void)textViewInvalidateRestorableState {\n    if ([iTermAdvancedSettingsModel restoreWindowContents]) {\n        [_delegate.realParentWindow invalidateRestorableState];\n    }\n}\n\n- (void)textViewDidFindDirtyRects {\n    if (_updateSubscriptions.count) {\n        ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n        notification.screenUpdateNotification = [[[ITMScreenUpdateNotification alloc] init] autorelease];\n        notification.screenUpdateNotification.session = self.guid;\n        [_updateSubscriptions enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n            [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                                 toConnectionKey:key];\n        }];\n    }\n\n    // Remove the tail-find timer so that a new tail find can begin. This is necessary so that\n    // shouldSEndContentsChangedNotification will return YES.\n    [_tailFindTimer invalidate];\n    _tailFindTimer = nil;\n}\n\n- (void)textViewBeginDrag\n{\n    [[MovePaneController sharedInstance] beginDrag:self];\n}\n\n- (void)textViewMovePane {\n    [[MovePaneController sharedInstance] movePane:self];\n}\n\n- (void)textViewSwapPane {\n    [[MovePaneController sharedInstance] swapPane:self];\n}\n\n- (NSStringEncoding)textViewEncoding {\n    return [self encoding];\n}\n\n// This uses the local directory because it is the last desperate gasp of URL action file finding.\n- (void)textViewGetCurrentWorkingDirectoryWithCompletion:(void (^)(NSString *workingDirectory))completion {\n    [self asyncCurrentLocalWorkingDirectory:completion];\n}\n\n// NOTE: This will not fetch the current directory if it's not already known to avoid blocking\n// the main thread. Don't use this unless you have to be synchronous.\n// Use asyncGetCurrentLocatioNWithCompletion instead.\n- (NSURL *)textViewCurrentLocation {\n    id<VT100RemoteHostReading>host = [self currentHost];\n    NSString *path = _lastDirectory;\n    NSURLComponents *components = [[[NSURLComponents alloc] init] autorelease];\n    components.host = host.hostname;\n    components.user = host.username;\n    components.path = path;\n    components.scheme = @\"file\";\n    return [components URL];\n}\n\n- (void)asyncGetCurrentLocationWithCompletion:(void (^)(NSURL *url))completion {\n    // NOTE: Use local directory here because this becomes the proxy icon, and it's basically\n    // useless when given a remote directory.\n    __weak __typeof(self) weakSelf = self;\n    [self asyncCurrentLocalWorkingDirectory:^(NSString *pwd) {\n        DLog(@\"Finished with %@ for %@\", pwd, weakSelf);\n        completion([weakSelf urlForHost:weakSelf.currentHost path:pwd]);\n    }];\n}\n\n- (void)updateLocalDirectoryWithCompletion:(void (^)(NSString *pwd))completion {\n    DLog(@\"Update local directory of %@\", self);\n    __weak __typeof(self) weakSelf = self;\n    [_shell getWorkingDirectoryWithCompletion:^(NSString *pwd) {\n        [[[weakSelf retain] autorelease] didGetWorkingDirectory:pwd completion:completion];\n    }];\n}\n\n- (void)didGetWorkingDirectory:(NSString *)pwd completion:(void (^)(NSString *pwd))completion {\n    // Don't call setLastDirectory:remote:pushed: because we don't want to update the\n    // path variable if the session is ssh'ed somewhere.\n    DLog(@\"getWorkingDirectoryWithCompletion for %@ finished with %@\", self, pwd);\n    if (self.lastLocalDirectoryWasPushed && self.lastLocalDirectory != nil) {\n        DLog(@\"Looks like there was a race because there is now a last local directory of %@. Use it.\",\n             self.lastLocalDirectory);\n        completion(self.lastLocalDirectory);\n        return;\n    }\n    self.lastLocalDirectory = pwd;\n    self.lastLocalDirectoryWasPushed = NO;\n    completion(pwd);\n}\n\n- (NSURL *)urlForHost:(id<VT100RemoteHostReading>)host path:(NSString *)path {\n    NSURLComponents *components = [[[NSURLComponents alloc] init] autorelease];\n    components.host = host.hostname;\n    components.user = host.username;\n    components.path = path;\n    components.scheme = @\"file\";\n    return [components URL];\n}\n\n- (BOOL)textViewShouldPlaceCursorAt:(VT100GridCoord)coord verticalOk:(BOOL *)verticalOk {\n    if (coord.y < _screen.numberOfLines - _screen.height ||\n        coord.x < 0 ||\n        coord.x >= _screen.width ||\n        coord.y >= _screen.numberOfLines) {\n        // Click must be in the live area and not in a margin.\n        return NO;\n    }\n    if (_screen.commandRange.start.x < 0) {\n        if (_screen.terminalSoftAlternateScreenMode) {\n            // In an interactive app. No restrictions.\n            *verticalOk = YES;\n            return YES;\n        } else {\n            // Possibly at a command prompt without shell integration or in some other command line\n            // app that may be using readline. No vertical movement.\n            *verticalOk = NO;\n            return YES;\n        }\n    } else {\n        // At the command prompt. Ok to move to any char within current command, but no up or down\n        // arrows please.\n        NSComparisonResult order = VT100GridCoordOrder(VT100GridCoordRangeMin(_screen.commandRange),\n                                                       coord);\n        *verticalOk = NO;\n        return (order != NSOrderedDescending);\n    }\n}\n\n- (BOOL)textViewShouldDrawFilledInCursor {\n    // If the auto-command history popup is open for this session, the filled-in cursor should be\n    // drawn even though the textview isn't in the key window.\n    return [self textViewIsActiveSession] && [[_delegate realParentWindow] autoCommandHistoryIsOpenForSession:self];\n}\n\n- (void)textViewWillNeedUpdateForBlink {\n    self.active = YES;\n}\n\n- (void)textViewSplitVertically:(BOOL)vertically withProfileGuid:(NSString *)guid\n{\n    Profile *profile;\n    if (guid) {\n        profile = [[ProfileModel sharedInstance] bookmarkWithGuid:guid];\n    } else {\n        profile = [self profileForSplit];\n    }\n    [[_delegate realParentWindow] asyncSplitVertically:vertically\n                                                before:NO\n                                               profile:profile\n                                         targetSession:self\n                                            completion:nil\n                                                 ready:nil];\n}\n\n- (void)textViewSelectNextTab\n{\n    [[_delegate realParentWindow] nextTab:nil];\n}\n\n- (void)textViewSelectPreviousTab\n{\n    [[_delegate realParentWindow] previousTab:nil];\n}\n\n- (void)textViewSelectNextWindow {\n    [[iTermController sharedInstance] nextTerminal];\n}\n\n- (void)textViewSelectPreviousWindow {\n    [[iTermController sharedInstance] previousTerminal];\n}\n\n- (void)textViewSelectNextPane\n{\n    [_delegate nextSession];\n}\n\n- (void)textViewSelectPreviousPane\n{\n    [_delegate previousSession];\n}\n\n- (void)textViewSelectMenuItemWithIdentifier:(NSString *)identifier title:(NSString *)title {\n    [PTYSession _recursiveSelectMenuItemWithTitle:title identifier:identifier inMenu:[NSApp mainMenu]];\n}\n\n- (void)textViewPasteSpecialWithStringConfiguration:(NSString *)configuration\n                                      fromSelection:(BOOL)fromSelection {\n    NSString *string = fromSelection ? [[iTermController sharedInstance] lastSelectionPromise].wait.maybeFirst : [NSString stringFromPasteboard];\n    [_pasteHelper pasteString:string\n                 stringConfig:configuration];\n}\n\n- (void)textViewInvokeScriptFunction:(NSString *)function {\n    [self invokeFunctionCall:function scope:self.variablesScope origin:@\"Pointer action\"];\n}\n\n- (void)textViewEditSession {\n    [[_delegate realParentWindow] editSession:self makeKey:YES];\n}\n\n- (void)textViewToggleBroadcastingInput\n{\n    [[_delegate realParentWindow] toggleBroadcastingInputToSession:self];\n}\n\n- (void)textViewCloseWithConfirmation {\n    [[_delegate realParentWindow] closeSessionWithConfirmation:self];\n}\n\n- (void)textViewRestartWithConfirmation {\n    [[_delegate realParentWindow] restartSessionWithConfirmation:self];\n}\n\n- (void)textViewPasteFromSessionWithMostRecentSelection:(PTYSessionPasteFlags)flags {\n    NSString *string = [[iTermController sharedInstance] lastSelectionPromise].wait.maybeFirst;\n    if (string) {\n        [self pasteString:string flags:flags];\n    }\n}\n\n- (BOOL)textViewWindowUsesTransparency {\n    return [[_delegate realParentWindow] useTransparency];\n}\n\n- (BOOL)textViewAmbiguousWidthCharsAreDoubleWidth\n{\n    return [self treatAmbiguousWidthAsDoubleWidth];\n}\n\n- (void)textViewCreateWindowWithProfileGuid:(NSString *)guid\n{\n    [[_delegate realParentWindow] newWindowWithBookmarkGuid:guid];\n}\n\n- (void)textViewCreateTabWithProfileGuid:(NSString *)guid\n{\n    [[_delegate realParentWindow] newTabWithBookmarkGuid:guid];\n}\n\n// Called when a key is pressed.\n- (BOOL)textViewDelegateHandlesAllKeystrokes\n{\n    [self resumeOutputIfNeeded];\n    return [[_delegate realParentWindow] inInstantReplay];\n}\n\n- (BOOL)textViewIsActiveSession {\n    return [_delegate sessionIsActiveInTab:self];\n}\n\n- (BOOL)textViewSessionIsBroadcastingInput\n{\n    return [[_delegate realParentWindow] broadcastInputToSession:self];\n}\n\n- (BOOL)textViewIsMaximized {\n    return [_delegate hasMaximizedPane];\n}\n\n- (BOOL)textViewTabHasMaximizedPanel\n{\n    return [_delegate hasMaximizedPane];\n}\n\n- (void)textViewDidBecomeFirstResponder {\n    [_delegate setActiveSession:self];\n    [_view setNeedsDisplay:YES];\n    [_view.findDriver owningViewDidBecomeFirstResponder];\n    [self makeComposerFirstResponderIfAllowed];\n}\n\n- (void)makeComposerFirstResponderIfAllowed {\n    if (!self.copyMode && self.haveAutoComposer && !_textViewShouldTakeFirstResponder) {\n        [_composerManager makeDropDownComposerFirstResponder];\n    }\n}\n\n- (void)textViewDidResignFirstResponder {\n    [_view setNeedsDisplay:YES];\n    self.copyMode = false;\n}\n\n- (void)setReportingMouseDownForEventType:(NSEventType)eventType {\n    switch (eventType) {\n        case NSEventTypeLeftMouseDown:\n            _reportingLeftMouseDown = YES;\n            return;\n        case NSEventTypeRightMouseDown:\n            _reportingRightMouseDown = YES;\n            return;\n        case NSEventTypeOtherMouseDown:\n            _reportingMiddleMouseDown = YES;\n            return;\n\n        case NSEventTypeLeftMouseUp:\n            _reportingLeftMouseDown = NO;\n            return;\n        case NSEventTypeRightMouseUp:\n            _reportingRightMouseDown = NO;\n            return;\n        case NSEventTypeOtherMouseUp:\n            _reportingMiddleMouseDown = NO;\n            return;\n\n        default:\n            assert(NO);\n    }\n}\n\n- (BOOL)reportingMouseDownForEventType:(NSEventType)eventType {\n    switch (eventType) {\n        case NSEventTypeLeftMouseDown:\n        case NSEventTypeLeftMouseUp:\n        case NSEventTypeLeftMouseDragged:\n            DLog(@\"_reportingLeftMouseDown=%@\", @(_reportingLeftMouseDown));\n            return _reportingLeftMouseDown;\n\n        case NSEventTypeRightMouseDown:\n        case NSEventTypeRightMouseUp:\n        case NSEventTypeRightMouseDragged:\n            DLog(@\"_reportingRightMouseDown=%@\", @(_reportingRightMouseDown));\n            return _reportingRightMouseDown;\n\n        case NSEventTypeOtherMouseDown:\n        case NSEventTypeOtherMouseUp:\n        case NSEventTypeOtherMouseDragged:\n            DLog(@\"_reportingMiddleMouseDown=%@\", @(_reportingMiddleMouseDown));\n            return _reportingMiddleMouseDown;\n\n        default:\n            assert(NO);\n    }\n}\n\n- (BOOL)textViewAnyMouseReportingModeIsEnabled {\n    return _screen.terminalMouseMode != MOUSE_REPORTING_NONE;\n}\n\n- (BOOL)textViewSmartSelectionActionsShouldUseInterpolatedStrings {\n    return [iTermProfilePreferences boolForKey:KEY_SMART_SELECTION_ACTIONS_USE_INTERPOLATED_STRINGS\n                                     inProfile:self.profile];\n}\n\n- (BOOL)textViewReportMouseEvent:(NSEventType)eventType\n                       modifiers:(NSUInteger)modifiers\n                          button:(MouseButtonNumber)button\n                      coordinate:(VT100GridCoord)coord\n                           point:(NSPoint)point\n                           delta:(CGSize)delta\n        allowDragBeforeMouseDown:(BOOL)allowDragBeforeMouseDown\n                        testOnly:(BOOL)testOnly {\n    DLog(@\"Report event type %lu, modifiers=%lu, button=%d, coord=%@ testOnly=%@ terminalMouseMode=%@ allowDragBeforeMouseDown%@\",\n         (unsigned long)eventType, (unsigned long)modifiers, button,\n         VT100GridCoordDescription(coord), @(testOnly), @(_screen.terminalMouseMode),\n         @(allowDragBeforeMouseDown));\n    // Ignore unknown buttons.\n    if (button == MOUSE_BUTTON_UNKNOWN) {\n        return NO;\n    }\n\n    switch (eventType) {\n        case NSEventTypeLeftMouseDown:\n        case NSEventTypeRightMouseDown:\n        case NSEventTypeOtherMouseDown:\n            switch (_screen.terminalMouseMode) {\n                case MOUSE_REPORTING_NORMAL:\n                case MOUSE_REPORTING_BUTTON_MOTION:\n                case MOUSE_REPORTING_ALL_MOTION:\n                    DLog(@\"normal/button/all - can report\");\n                    if (!testOnly) {\n                        [self setReportingMouseDownForEventType:eventType];\n                        _lastReportedCoord = coord;\n                        _lastReportedPoint = point;\n                        DLog(@\"_lastReportedCoord <- %@, _lastReportedPoint <- %@\",\n                             VT100GridCoordDescription(_lastReportedCoord),\n                             NSStringFromPoint(point));\n                        [self writeLatin1EncodedData:[_screen.terminalOutput mousePress:button\n                                                                          withModifiers:modifiers\n                                                                                     at:coord\n                                                                                  point:point]\n                                    broadcastAllowed:NO\n                                           reporting:NO];\n                    }\n                    return YES;\n\n                case MOUSE_REPORTING_NONE:\n                case MOUSE_REPORTING_HIGHLIGHT:\n                    DLog(@\"non/highlight - can't report\");\n                    break;\n            }\n            break;\n\n        case NSEventTypeLeftMouseUp:\n        case NSEventTypeRightMouseUp:\n        case NSEventTypeOtherMouseUp:\n            if (testOnly) {\n                switch (_screen.terminalMouseMode) {\n                    case MOUSE_REPORTING_NORMAL:\n                    case MOUSE_REPORTING_BUTTON_MOTION:\n                    case MOUSE_REPORTING_ALL_MOTION:\n                        DLog(@\"normal/button/all - can report\");\n                        return YES;\n\n                    case MOUSE_REPORTING_NONE:\n                    case MOUSE_REPORTING_HIGHLIGHT:\n                        DLog(@\"none/highlight - can't report\");\n                        break;\n                }\n                return NO;\n            }\n            if ([self reportingMouseDownForEventType:eventType]) {\n                [self setReportingMouseDownForEventType:eventType];\n                _lastReportedCoord = VT100GridCoordMake(-1, -1);\n                _lastReportedPoint = NSMakePoint(-1, -1);\n                DLog(@\"_lastReportedCoord <- %@, _lastReportedPoint <- %@\",\n                     VT100GridCoordDescription(_lastReportedCoord),\n                     NSStringFromPoint(point));\n\n                switch (_screen.terminalMouseMode) {\n                    case MOUSE_REPORTING_NORMAL:\n                    case MOUSE_REPORTING_BUTTON_MOTION:\n                    case MOUSE_REPORTING_ALL_MOTION:\n                        DLog(@\"normal/button/all - can report\");\n                        _lastReportedCoord = coord;\n                        _lastReportedPoint = point;\n                        DLog(@\"_lastReportedCoord <- %@, _lastReportedPoint <- %@\",\n                             VT100GridCoordDescription(_lastReportedCoord),\n                             NSStringFromPoint(point));\n                        [self writeLatin1EncodedData:[_screen.terminalOutput mouseRelease:button\n                                                                            withModifiers:modifiers\n                                                                                       at:coord\n                                                                                    point:point]\n                                    broadcastAllowed:NO\n                                           reporting:NO];\n                        return YES;\n\n                    case MOUSE_REPORTING_NONE:\n                    case MOUSE_REPORTING_HIGHLIGHT:\n                        DLog(@\"none/highlight - can't report\");\n                        break;\n                }\n            }\n            break;\n\n\n        case NSEventTypeMouseMoved:\n            if (_screen.terminalMouseMode != MOUSE_REPORTING_ALL_MOTION) {\n                DLog(@\"not reporting all motion\");\n                return NO;\n            }\n            DLog(@\"can report\");\n            if (testOnly) {\n                return YES;\n            }\n            if ([_screen.terminalOutput shouldReportMouseMotionAtCoord:coord\n                                                             lastCoord:_lastReportedCoord\n                                                                 point:point\n                                                             lastPoint:_lastReportedPoint]) {\n                _lastReportedCoord = coord;\n                _lastReportedPoint = point;\n                DLog(@\"_lastReportedCoord <- %@, _lastReportedPoint <- %@\",\n                     VT100GridCoordDescription(_lastReportedCoord),\n                     NSStringFromPoint(point));\n                [self writeLatin1EncodedData:[_screen.terminalOutput mouseMotion:MOUSE_BUTTON_NONE\n                                                                   withModifiers:modifiers\n                                                                              at:coord\n                                                                           point:point]\n                            broadcastAllowed:NO\n                                   reporting:NO];\n                return YES;\n            }\n            break;\n\n        case NSEventTypeLeftMouseDragged:\n        case NSEventTypeRightMouseDragged:\n        case NSEventTypeOtherMouseDragged:\n            if (testOnly) {\n                switch (_screen.terminalMouseMode) {\n                    case MOUSE_REPORTING_BUTTON_MOTION:\n                    case MOUSE_REPORTING_ALL_MOTION:\n                    case MOUSE_REPORTING_NORMAL:\n                        DLog(@\"button/all/normal - can report\");\n                        return YES;\n\n                    case MOUSE_REPORTING_NONE:\n                    case MOUSE_REPORTING_HIGHLIGHT:\n                        DLog(@\"none/highlight - can't report\");\n                        break;\n                }\n                return NO;\n            }\n            if (([self reportingMouseDownForEventType:eventType] || allowDragBeforeMouseDown) &&\n                [_screen.terminalOutput shouldReportMouseMotionAtCoord:coord\n                                                             lastCoord:_lastReportedCoord\n                                                                 point:point\n                                                             lastPoint:_lastReportedPoint]) {\n                _lastReportedCoord = coord;\n                _lastReportedPoint = point;\n                DLog(@\"_lastReportedCoord <- %@, _lastReportedPoint <- %@\",\n                     VT100GridCoordDescription(_lastReportedCoord),\n                     NSStringFromPoint(point));\n                switch (_screen.terminalMouseMode) {\n                    case MOUSE_REPORTING_BUTTON_MOTION:\n                    case MOUSE_REPORTING_ALL_MOTION:\n                        DLog(@\"motion/all-motion - will report drag\");\n                        [self writeLatin1EncodedData:[_screen.terminalOutput mouseMotion:button\n                                                                           withModifiers:modifiers\n                                                                                      at:coord\n                                                                                   point:point]\n                                    broadcastAllowed:NO\n                                           reporting:NO];\n                        // Fall through\n                    case MOUSE_REPORTING_NORMAL:\n                        DLog(@\"normal - do not report drag\");\n                        // Don't do selection when mouse reporting during a drag, even if the drag\n                        // is not reported (the clicks are).\n                        return YES;\n\n                    case MOUSE_REPORTING_NONE:\n                    case MOUSE_REPORTING_HIGHLIGHT:\n                        DLog(@\"none/highlight - do not report drag\");\n                        break;\n                }\n            }\n            break;\n\n        case NSEventTypeScrollWheel:\n            switch (_screen.terminalMouseMode) {\n                case MOUSE_REPORTING_NORMAL:\n                case MOUSE_REPORTING_BUTTON_MOTION:\n                case MOUSE_REPORTING_ALL_MOTION:\n                    DLog(@\"normal/button/all - can report. delta=%@\", NSStringFromSize(delta));\n                    if (testOnly) {\n                        return delta.height != 0;\n                    }\n                    const CGFloat chosenDelta = (fabs(delta.width) > fabs(delta.height)) ? delta.width : delta.height;\n                    int steps;\n                    if ([iTermAdvancedSettingsModel proportionalScrollWheelReporting]) {\n                        // Cap number of reported scroll events at 32 to prevent runaway redraws.\n                        // This is a mostly theoretical concern and the number can grow if it\n                        // doesn't seem to be a problem.\n                        DLog(@\"Cap at 32\");\n                        steps = MIN(32, fabs(chosenDelta));\n                    } else {\n                        steps = 1;\n                    }\n                    if (steps == 1 && [iTermAdvancedSettingsModel doubleReportScrollWheel]) {\n                        // This works around what I believe is a bug in tmux or a bug in\n                        // how users use tmux. See the thread on tmux-users with subject\n                        // \"Mouse wheel events and server_client_assume_paste--the perfect storm of bugs?\".\n                        DLog(@\"Double reporting\");\n                        steps = 2;\n                    }\n                    DLog(@\"steps=%d\", steps);\n                    for (int i = 0; i < steps; i++) {\n                        [self writeLatin1EncodedData:[_screen.terminalOutput mousePress:button\n                                                                          withModifiers:modifiers\n                                                                                     at:coord\n                                                                                  point:point]\n                                    broadcastAllowed:NO\n                                           reporting:NO];\n                    }\n                    return YES;\n\n                case MOUSE_REPORTING_NONE:\n                case MOUSE_REPORTING_HIGHLIGHT:\n                    DLog(@\"none/highlight - can't report\");\n                    break;\n            }\n            break;\n\n        default:\n            assert(NO);\n            break;\n    }\n    return NO;\n}\n\n- (VT100GridAbsCoordRange)textViewRangeOfLastCommandOutput {\n    DLog(@\"Fetching range of last command output...\");\n    if (![[iTermShellHistoryController sharedInstance] commandHistoryHasEverBeenUsed]) {\n        DLog(@\"Command history has never been used.\");\n        [iTermShellHistoryController showInformationalMessage];\n        return VT100GridAbsCoordRangeMake(-1, -1, -1, -1);\n    } else {\n        iTermTextExtractor *extractor = [iTermTextExtractor textExtractorWithDataSource:_screen];\n        long long absCursorY = _screen.cursorY - 1 + _screen.numberOfScrollbackLines + _screen.totalScrollbackOverflow;\n\n        if (self.isAtShellPrompt ||\n            _screen.startOfRunningCommandOutput.x == -1 ||\n            (absCursorY == _screen.startOfRunningCommandOutput.y && _screen.cursorX == 1)) {\n            DLog(@\"Returning cached range.\");\n            return [extractor rangeByTrimmingWhitespaceFromRange:_screen.lastCommandOutputRange\n                                                         leading:NO\n                                                        trailing:iTermTextExtractorTrimTrailingWhitespaceOneLine];\n        } else {\n            DLog(@\"Returning range of current command.\");\n            VT100GridAbsCoordRange range = VT100GridAbsCoordRangeMake(_screen.startOfRunningCommandOutput.x,\n                                                                      _screen.startOfRunningCommandOutput.y,\n                                                                      _screen.cursorX - 1,\n                                                                      absCursorY);\n            return [extractor rangeByTrimmingWhitespaceFromRange:range\n                                                         leading:NO\n                                                        trailing:iTermTextExtractorTrimTrailingWhitespaceOneLine];\n        }\n    }\n}\n\n- (VT100GridAbsCoordRange)textViewRangeOfCurrentCommand {\n    DLog(@\"Fetching range of current command\");\n    if (![[iTermShellHistoryController sharedInstance] commandHistoryHasEverBeenUsed]) {\n        DLog(@\"Command history has never been used.\");\n        [iTermShellHistoryController showInformationalMessage];\n        return VT100GridAbsCoordRangeMake(-1, -1, -1, -1);\n    } else {\n        VT100GridAbsCoordRange range;\n        iTermTextExtractorTrimTrailingWhitespace trailing;\n        if (self.isAtShellPrompt) {\n            range = VT100GridAbsCoordRangeFromCoordRange(_screen.extendedCommandRange,\n                                                         _screen.totalScrollbackOverflow);\n            trailing = iTermTextExtractorTrimTrailingWhitespaceAll;\n        } else {\n            range = _lastOrCurrentlyRunningCommandAbsRange;\n            trailing = iTermTextExtractorTrimTrailingWhitespaceOneLine;\n        }\n        iTermTextExtractor *extractor = [iTermTextExtractor textExtractorWithDataSource:_screen];\n        return [extractor rangeByTrimmingWhitespaceFromRange:range leading:YES trailing:trailing];\n    }\n}\n\n- (BOOL)textViewCanSelectOutputOfLastCommand {\n    // Return YES if command history has never been used so we can show the informational message.\n    return (![[iTermShellHistoryController sharedInstance] commandHistoryHasEverBeenUsed] ||\n            _screen.lastCommandOutputRange.start.x >= 0);\n\n}\n\n- (BOOL)textViewCanSelectCurrentCommand {\n    // Return YES if command history has never been used so we can show the informational message.\n    return (![[iTermShellHistoryController sharedInstance] commandHistoryHasEverBeenUsed] ||\n            self.isAtShellPrompt ||\n            (_lastOrCurrentlyRunningCommandAbsRange.start.x >= 0 &&\n             // It cannot select when the currently running command is lost due to scrollback overflow.\n             _lastOrCurrentlyRunningCommandAbsRange.start.y >= _screen.totalScrollbackOverflow));\n}\n\n- (iTermUnicodeNormalization)textViewUnicodeNormalizationForm {\n    return _screen.config.normalization;\n}\n\n- (NSColor *)textViewCursorGuideColor {\n    return _cursorGuideColor;\n}\n\n- (NSColor *)textViewBadgeColor {\n    return [iTermProfilePreferences colorForKey:KEY_BADGE_COLOR dark:_screen.colorMap.darkMode profile:_profile];\n}\n\n// Returns a dictionary with only string values by converting non-strings.\n- (NSDictionary *)textViewVariables {\n    return _variables.stringValuedDictionary;\n}\n\n- (iTermVariableScope<iTermSessionScope> *)variablesScope {\n    if (_variablesScope == nil) {\n        _variablesScope = [iTermVariableScope newSessionScopeWithVariables:self.variables];\n    }\n    return _variablesScope;\n}\n\n- (iTermVariableScope *)genericScope {\n    return self.variablesScope;\n}\n\n- (BOOL)textViewSuppressingAllOutput {\n    return _suppressAllOutput;\n}\n\n- (BOOL)textViewIsZoomedIn {\n    return _liveSession && !_dvr && !_filter;\n}\n\n- (BOOL)textViewIsFiltered {\n    return _liveSession && _filter;\n}\n\n- (BOOL)textViewShouldShowMarkIndicators {\n    return [iTermProfilePreferences boolForKey:KEY_SHOW_MARK_INDICATORS inProfile:_profile];\n}\n\n- (void)textViewThinksUserIsTryingToSendArrowKeysWithScrollWheel:(BOOL)isTrying {\n    [self.naggingController tryingToSendArrowKeysWithScrollWheel:isTrying];\n}\n\n// Grow or shrink the height of the frame if the number of lines in the data\n// source + IME has changed.\n- (BOOL)textViewResizeFrameIfNeeded {\n    // Check if the frame size needs to grow or shrink.\n    NSRect frame = [_textview frame];\n    const CGFloat desiredHeight = _textview.desiredHeight;\n    if (fabs(desiredHeight - NSHeight(frame)) >= 0.5) {\n        // Update the wrapper's size, which in turn updates textview's size.\n        frame.size.height = desiredHeight + [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins];  // The wrapper is always larger by VMARGIN.\n        _wrapper.frame = [self safeFrameForWrapperViewFrame:frame];\n\n        NSAccessibilityPostNotification(_textview,\n                                        NSAccessibilityRowCountChangedNotification);\n        return YES;\n    }\n    return NO;\n}\n\n- (NSInteger)textViewUnicodeVersion {\n    return _unicodeVersion;\n}\n\n- (void)textViewDidRefresh {\n    if (_textview.window.firstResponder != _textview) {\n        return;\n    }\n    iTermTextExtractor *textExtractor = [[[iTermTextExtractor alloc] initWithDataSource:_screen] autorelease];\n    NSString *word = [textExtractor fastWordAt:VT100GridCoordMake(_screen.cursorX - 1, _screen.cursorY + _screen.numberOfScrollbackLines - 1)];\n    [[_delegate realParentWindow] currentSessionWordAtCursorDidBecome:word];\n}\n\n- (void)textViewBackgroundColorDidChangeFrom:(NSColor *)before to:(NSColor *)after {\n    DLog(@\"%@\", [NSThread callStackSymbols]);\n    [self backgroundColorDidChangeJigglingIfNeeded:before.isDark != after.isDark];\n    [self updateAutoComposerSeparatorVisibility];\n    // Can't call this synchronously because we could get here from a side effect and\n    // viewDidChangeEffectiveAppearance can cause performBlockWithJoinedThreads to be called.\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf updateAppearanceForMinimalTheme];\n    });\n}\n\n- (void)themeDidChange {\n    [self updateAppearanceForMinimalTheme];\n}\n\n- (void)updateAppearanceForMinimalTheme {\n    const BOOL minimal = [iTermPreferences intForKey:kPreferenceKeyTabStyle] == TAB_STYLE_MINIMAL;\n    if (minimal) {\n        _view.appearance = [_screen.colorMap colorForKey:kColorMapBackground].isDark ? [NSAppearance appearanceNamed:NSAppearanceNameDarkAqua] : [NSAppearance appearanceNamed:NSAppearanceNameAqua];\n    } else {\n        _view.appearance = nil;\n    }\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(id)object\n                        change:(NSDictionary *)change\n                       context:(void *)context {\n    if (context == &iTermEffectiveAppearanceKey) {\n        DLog(@\"System appearance changed to %@\", [NSApp effectiveAppearance]);\n        const BOOL minimal = [iTermPreferences intForKey:kPreferenceKeyTabStyle] == TAB_STYLE_MINIMAL;\n        if (minimal && _screen.colorMap.useSeparateColorsForLightAndDarkMode) {\n            DLog(@\"Manually update view appearance\");\n            // The view's appearance determines which colors should be used. In minimal, we manually\n            // manage the appearance so that window chrome matches up with the background color. To\n            // break that dependency cycle, we manually update the appearance for minimal when the\n            // system theme changes.\n            self.view.appearance = [self colorMapShouldBeInDarkMode] ? [NSAppearance appearanceNamed:NSAppearanceNameDarkAqua] : [NSAppearance appearanceNamed:NSAppearanceNameAqua];\n        }\n    } else {\n        [super observeValueForKeyPath:keyPath\n                             ofObject:object\n                               change:change\n                              context:context];\n    }\n}\n\n- (BOOL)colorMapShouldBeInDarkMode {\n    const BOOL minimal = [iTermPreferences intForKey:kPreferenceKeyTabStyle] == TAB_STYLE_MINIMAL;\n    if (minimal) {\n        NSColor *backgroundColor = [iTermProfilePreferences colorForKey:KEY_BACKGROUND_COLOR\n                                                              dark:[NSApp effectiveAppearance].it_isDark\n                                                           profile:self.profile];\n        DLog(@\"dark=%@\", @(backgroundColor.isDark));\n        return backgroundColor.isDark;\n    }\n    DLog(@\"Not minimal so fall back to view (%@)/app (%@) appearance\", self.view.effectiveAppearance, [NSApp effectiveAppearance]);\n    return (self.view.effectiveAppearance ?: [NSApp effectiveAppearance]).it_isDark;\n}\n\n\n- (void)textViewTransparencyDidChange {\n    [self backgroundColorDidChangeJigglingIfNeeded:NO];\n}\n\n- (void)backgroundColorDidChangeJigglingIfNeeded:(BOOL)canJiggle {\n    [_delegate sessionBackgroundColorDidChange:self];\n    [_delegate sessionUpdateMetalAllowed];\n    [_statusBarViewController updateColors];\n    [_wrapper setNeedsDisplay:YES];\n    [self.view setNeedsDisplay:YES];\n    if (canJiggle && _profileInitialized) {\n        // See issue 9855.\n        self.needsJiggle = YES;\n    }\n}\n- (void)textViewForegroundColorDidChangeFrom:(NSColor *)before to:(NSColor *)after {\n    DLog(@\"%@\", [NSThread callStackSymbols]);\n    if (_profileInitialized && before.isDark != after.isDark) {\n        self.needsJiggle = YES;\n    }\n    [_composerManager updateFont];\n}\n\n- (void)textViewCursorColorDidChangeFrom:(NSColor *)before to:(NSColor *)after {\n    [_composerManager updateFont];\n}\n\n- (void)setNeedsJiggle:(BOOL)needsJiggle {\n    DLog(@\"setNeedsJiggle:%@\", @(needsJiggle));\n    if (!_initializationFinished) {\n        DLog(@\"Uninitialized\");\n        return;\n    }\n    if (_needsJiggle == needsJiggle) {\n        DLog(@\"Unchanged\");\n        return;\n    }\n    DLog(@\"%@\", [NSThread callStackSymbols]);\n    _needsJiggle = needsJiggle;\n    if (!needsJiggle) {\n        return;\n    }\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self jiggleIfNeeded];\n    });\n}\n\n- (void)jiggleIfNeeded {\n    DLog(@\"jiggleIfNeeded\");\n    if (!_needsJiggle) {\n        return;\n    }\n    _needsJiggle = NO;\n    [self jiggle];\n}\n\n- (void)textViewProcessedBackgroundColorDidChange {\n    [self updateViewBackgroundImage];\n}\n\n- (void)textViewBurySession {\n    [self bury];\n}\n\n- (NSRect)boundingFrameForWindowedRange:(VT100GridWindowedRange)range {\n    const NSRect visibleRect = _textview.enclosingScrollView.documentVisibleRect;\n    const VT100GridRect gridRect = VT100GridWindowedRangeBoundingRect(range);\n    const NSRect topLeft = [_textview rectForCoord:VT100GridRectTopLeft(gridRect)];\n    const NSRect topRight = [_textview rectForCoord:VT100GridRectTopRight(gridRect)];\n    const NSRect bottomLeft = [_textview rectForCoord:VT100GridRectBottomLeft(gridRect)];\n    const NSRect bottomRight = [_textview rectForCoord:VT100GridRectBottomRight(gridRect)];\n    const NSRect anchorRect = NSUnionRect(NSUnionRect(NSUnionRect(topLeft, topRight), bottomLeft), bottomRight);\n    const NSRect visibleAnchorRect = NSIntersectionRect(anchorRect, visibleRect);\n    return [_view convertRect:visibleAnchorRect fromView:_textview];\n}\n\n- (BOOL)textViewShowHoverURL:(NSString *)url anchor:(VT100GridWindowedRange)anchor {\n    return [_view setHoverURL:url\n                  anchorFrame:url ? [self boundingFrameForWindowedRange:anchor] : NSZeroRect];\n}\n\n- (BOOL)textViewCopyMode {\n    return _modeHandler.mode == iTermSessionModeCopy;\n}\n\n- (BOOL)textViewCopyModeSelecting {\n    return _modeHandler.copyModeHandler.state.selecting;\n}\n\n- (VT100GridCoord)textViewCopyModeCursorCoord {\n    return _modeHandler.copyModeHandler.state.coord;\n}\n\n- (BOOL)textViewPasswordInput {\n    return _passwordInput;\n}\n\n- (void)textViewDidSelectPasswordPrompt {\n    iTermApplicationDelegate *delegate = [iTermApplication.sharedApplication delegate];\n    [delegate openPasswordManagerToAccountName:nil\n                                     inSession:self];\n}\n\n- (void)textViewDidSelectRangeForFindOnPage:(VT100GridCoordRange)range {\n    if (_modeHandler.mode == iTermSessionModeCopy) {\n        _modeHandler.copyModeHandler.state.coord = range.start;\n        _modeHandler.copyModeHandler.state.start = range.end;\n        [self.textview setNeedsDisplay:YES];\n    }\n}\n\n- (void)textViewNeedsDisplayInRect:(NSRect)rect {\n    DLog(@\"text view needs display\");\n    NSRect visibleRect = NSIntersectionRect(rect, _textview.enclosingScrollView.documentVisibleRect);\n    [_view setMetalViewNeedsDisplayInTextViewRect:visibleRect];\n}\n\n- (BOOL)textViewShouldDrawRect {\n    // In issue 8843 we see that sometimes the background color can get out of sync. I can't\n    // figure it out. This patches the problem until I can collect more info.\n    [_view setTerminalBackgroundColor:[self processedBackgroundColor]];\n    return !_textview.suppressDrawing;\n}\n\n- (void)textViewDidHighlightMark {\n    if (self.useMetal) {\n        [_textview setNeedsDisplay:YES];\n    }\n}\n\n- (NSEdgeInsets)textViewEdgeInsets {\n    NSEdgeInsets insets;\n    const NSRect innerFrame = _view.scrollview.frame;\n    NSSize containerSize;\n    containerSize = _view.frame.size;\n\n    insets.bottom = NSMinY(innerFrame);\n    insets.top = containerSize.height - NSMaxY(innerFrame);\n    insets.left = NSMinX(innerFrame);\n    insets.right = containerSize.width - NSMaxX(innerFrame);\n\n    return insets;\n}\n\n- (BOOL)textViewInInteractiveApplication {\n    return _screen.terminalSoftAlternateScreenMode;\n}\n\n// NOTE: Make sure to update both the context menu and the main menu when modifying these.\n- (BOOL)textViewTerminalStateForMenuItem:(NSMenuItem *)menuItem {\n    switch (menuItem.tag) {\n        case 1:\n            return _screen.showingAlternateScreen;\n\n        case 2:\n            return _screen.terminalReportFocus;\n\n        case 3:\n            return _screen.terminalMouseMode != MOUSE_REPORTING_NONE;\n\n        case 4:\n            return _screen.terminalBracketedPasteMode;\n\n        case 5:\n            return _screen.terminalCursorMode;\n\n        case 6:\n            return _screen.terminalKeypadMode;\n\n        case 7:\n            return _keyMappingMode == iTermKeyMappingModeStandard;\n\n        case 8:\n            return _keyMappingMode == iTermKeyMappingModeModifyOtherKeys1;\n\n        case 9:\n            return _keyMappingMode == iTermKeyMappingModeModifyOtherKeys2;\n\n        case 10:\n            return _keyMappingMode == iTermKeyMappingModeCSIu;\n\n        case 11:\n            return _keyMappingMode == iTermKeyMappingModeRaw;\n    }\n\n    return NO;\n}\n\n- (void)textViewToggleTerminalStateForMenuItem:(NSMenuItem *)menuItem {\n    _modeHandler.mode = iTermSessionModeDefault;\n    const NSInteger tag = menuItem.tag;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        switch (tag) {\n            case 1:\n                [terminal toggleAlternateScreen];\n                break;\n\n            case 2:\n                terminal.reportFocus = !terminal.reportFocus;\n                break;\n\n            case 3:\n                if (terminal.mouseMode == MOUSE_REPORTING_NONE) {\n                    terminal.mouseMode = terminal.previousMouseMode;\n                } else {\n                    terminal.mouseMode = MOUSE_REPORTING_NONE;\n                }\n                [terminal.delegate terminalMouseModeDidChangeTo:terminal.mouseMode];\n                break;\n\n            case 4:\n                terminal.bracketedPasteMode = !terminal.bracketedPasteMode;\n                break;\n\n            case 5:\n                terminal.cursorMode = !terminal.cursorMode;\n                break;\n\n            case 6:\n                [terminal forceSetKeypadMode:!terminal.keypadMode];\n                break;\n\n            case 7:\n                terminal.sendModifiers[4] = @-1;\n                self.keyMappingMode = iTermKeyMappingModeStandard;\n                break;\n\n            case 8:\n                terminal.sendModifiers[4] = @1;\n                self.keyMappingMode = iTermKeyMappingModeModifyOtherKeys1;\n                break;\n\n            case 9:\n                terminal.sendModifiers[4] = @2;\n                self.keyMappingMode = iTermKeyMappingModeModifyOtherKeys2;\n                break;\n\n            case 10:\n                terminal.sendModifiers[4] = @-1;\n                self.keyMappingMode = iTermKeyMappingModeCSIu;\n                break;\n\n            case 11:\n                terminal.sendModifiers[4] = @-1;\n                self.keyMappingMode = iTermKeyMappingModeRaw;\n                break;\n        }\n    }];\n}\n\n- (void)textViewResetTerminal {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        [terminal gentleReset];\n    }];\n}\n\n- (CGFloat)textViewBadgeTopMargin {\n    return [iTermProfilePreferences floatForKey:KEY_BADGE_TOP_MARGIN inProfile:self.profile];\n}\n\n- (CGFloat)textViewBadgeRightMargin {\n    return [iTermProfilePreferences floatForKey:KEY_BADGE_RIGHT_MARGIN inProfile:self.profile];\n}\n\n- (iTermVariableScope *)textViewVariablesScope {\n    return self.variablesScope;\n}\n\n- (BOOL)textViewTerminalBackgroundColorDeterminesWindowDecorationColor {\n    return self.view.window.ptyWindow.it_terminalWindowUseMinimalStyle;\n}\n\n- (void)textViewDidUpdateDropTargetVisibility {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (iTermExpect *)textViewExpect {\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf sync];\n    });\n    return _expect;\n}\n\n- (void)textViewDidDetectMouseReportingFrustration {\n    [self.naggingController didDetectMouseReportingFrustration];\n}\n\n- (BOOL)textViewCanBury {\n    return !_synthetic;\n}\n\n- (void)textViewFindOnPageLocationsDidChange {\n    [_view.searchResultsMinimap invalidate];\n    [_view.marksMinimap invalidate];\n}\n\n- (void)textViewFindOnPageSelectedResultDidChange {\n    [_view.findDriver.viewController countDidChange];\n}\n\n- (CGFloat)textViewBlend {\n    return [self effectiveBlend];\n}\n\n- (id<iTermSwipeHandler>)textViewSwipeHandler {\n    return [self.delegate sessionSwipeHandler];\n}\n\n- (void)textViewAddContextMenuItems:(NSMenu *)menu {\n    if (!self.isTmuxClient) {\n        return;\n    }\n    if (!_tmuxController.gateway.pauseModeEnabled) {\n        return;\n    }\n    [menu addItem:[NSMenuItem separatorItem]];\n    if (_tmuxPaused) {\n        NSMenuItem *item = [menu addItemWithTitle:@\"Unpause tmux Pane\" action:@selector(toggleTmuxPaused) keyEquivalent:@\"\"];\n        item.target = self;\n    } else {\n        NSMenuItem *item = [menu addItemWithTitle:@\"Pause tmux Pane\" action:@selector(toggleTmuxPaused) keyEquivalent:@\"\"];\n        item.target = self;\n    }\n}\n\n- (NSString *)textViewShell {\n    return self.userShell;\n}\n\n- (void)textViewContextMenuInvocation:(NSString *)invocation\n                      failedWithError:(NSError *)error\n                          forMenuItem:(NSString *)title {\n    [PTYSession reportFunctionCallError:error\n                          forInvocation:invocation\n                                 origin:[NSString stringWithFormat:@\"Menu Item \u201c%@\u201d\", title]\n                                 window:self.view.window];\n}\n\n- (void)textViewEditTriggers {\n    [self openTriggersViewController];\n}\n\n- (void)openTriggersViewController {\n    [_triggerWindowController autorelease];\n    _triggerWindowController = [[TriggerController alloc] init];\n    _triggerWindowController.guid = self.profile[KEY_GUID];\n    _triggerWindowController.delegate = self;\n    [_triggerWindowController windowWillOpen];\n    __weak __typeof(self) weakSelf = self;\n    [self.view.window beginSheet:_triggerWindowController.window completionHandler:^(NSModalResponse returnCode) {\n        [weakSelf closeTriggerWindowController];\n    }];\n}\n\n- (void)textViewToggleEnableTriggersInInteractiveApps {\n    const BOOL value = [iTermProfilePreferences boolForKey:KEY_ENABLE_TRIGGERS_IN_INTERACTIVE_APPS inProfile:self.profile];\n    [self setSessionSpecificProfileValues:@{ KEY_ENABLE_TRIGGERS_IN_INTERACTIVE_APPS: @(!value) }];\n}\n\n- (BOOL)textViewTriggersAreEnabledInInteractiveApps {\n    return [iTermProfilePreferences boolForKey:KEY_ENABLE_TRIGGERS_IN_INTERACTIVE_APPS inProfile:self.profile];\n}\n\n- (iTermTimestampsMode)textviewTimestampsMode {\n    return (iTermTimestampsMode)[iTermProfilePreferences unsignedIntegerForKey:KEY_SHOW_TIMESTAMPS inProfile:self.profile];\n}\n\n- (void)textviewToggleTimestampsMode {\n    iTermTimestampsMode mode = iTermTimestampsModeOff;\n    switch ([self textviewTimestampsMode]) {\n        case iTermTimestampsModeOff:\n            mode = iTermTimestampsModeOn;\n            break;\n        case iTermTimestampsModeOn:\n        case iTermTimestampsModeHover:\n            mode = iTermTimestampsModeOff;\n            break;\n    }\n    [self setSessionSpecificProfileValues:@{ KEY_SHOW_TIMESTAMPS: @(mode) }];\n    [_textview setNeedsDisplay:YES];\n}\n\n- (void)textViewSetClickCoord:(VT100GridAbsCoord)coord\n                       button:(NSInteger)button\n                        count:(NSInteger)count\n                    modifiers:(NSEventModifierFlags)modifiers\n                  sideEffects:(iTermClickSideEffects)sideEffects\n                        state:(iTermMouseState)state {\n    self.variablesScope.mouseInfo = @[ @(coord.x), @(coord.y), @(button), @(count), [self apiModifiersForModifierFlags:modifiers], @(sideEffects), @(state) ];\n}\n\n- (void)closeTriggerWindowController {\n    [_triggerWindowController close];\n}\n\n- (void)textViewAddTrigger:(NSString *)text {\n    [self openAddTriggerViewControllerWithText:text];\n}\n\n- (void)openAddTriggerViewControllerWithText:(NSString *)text {\n    __weak __typeof(self) weakSelf = self;\n    iTermColorSuggester *cs =\n    [[[iTermColorSuggester alloc] initWithDefaultTextColor:[_screen.colorMap colorForKey:kColorMapForeground]\n                                    defaultBackgroundColor:[_screen.colorMap colorForKey:kColorMapBackground]\n                                         minimumDifference:0.25\n                                                      seed:[text hash]] autorelease];\n    [iTermAddTriggerViewController addTriggerForText:text\n                                              window:self.view.window\n                                 interpolatedStrings:[self.profile[KEY_TRIGGERS_USE_INTERPOLATED_STRINGS] boolValue]\n                                    defaultTextColor:cs.suggestedTextColor\n                              defaultBackgroundColor:cs.suggestedBackgroundColor\n                                          completion:^(NSDictionary * _Nonnull dict, BOOL updateProfile) {\n        if (!dict) {\n            return;\n        }\n        [weakSelf addTriggerDictionary:dict updateProfile:updateProfile];\n    }];\n}\n\n- (void)textViewShowFindIndicator:(VT100GridCoordRange)range {\n    DLog(@\"begin %@\", VT100GridCoordRangeDescription(range));\n    VT100GridCoordRange visibleRange = range;\n    VT100GridRange visibleLines = _textview.rangeOfVisibleLines;\n    if (visibleRange.start.y > VT100GridRangeMax(visibleLines) ||\n        visibleRange.end.y < visibleLines.location) {\n        return;\n    }\n    if (visibleRange.start.y < visibleLines.location) {\n        visibleRange.start.y = visibleLines.location;\n        visibleRange.start.x = 0;\n    }\n    if (visibleRange.end.y > VT100GridRangeMax(visibleLines)) {\n        visibleRange.end.y = VT100GridRangeMax(visibleLines);\n        visibleRange.end.x = _screen.width;\n    }\n    int minX = visibleRange.start.x;\n    int maxX = visibleRange.end.x;\n    if (visibleRange.start.y != visibleRange.end.y) {\n        minX = 0;\n        maxX = _screen.width;\n    }\n    const int hmargin = [iTermPreferences intForKey:kPreferenceKeySideMargins];\n    const int vmargin = [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins];\n    const int rows = visibleRange.end.y - visibleRange.start.y + 1;\n    const VT100GridSize gridSize = VT100GridSizeMake(maxX - minX, rows);\n    const CGFloat cellWidth = [_textview charWidth];\n    const CGFloat cellHeight = [_textview lineHeight];\n    const NSSize padding = iTermTextClipDrawing.padding;\n    const NSSize imageSize = NSMakeSize(_screen.width * cellWidth + padding.width * 2,\n                                        gridSize.height * cellHeight + padding.height * 2);\n    NSImage *image = [NSImage flippedImageOfSize:imageSize drawBlock:^{\n        [NSGraphicsContext.currentContext saveGraphicsState];\n        NSAffineTransform *transform = [NSAffineTransform transform];\n        [transform translateXBy:padding.width yBy:padding.height];\n        [transform concat];\n        [iTermTextClipDrawing drawClipWithDrawingHelper:_textview.drawingHelper\n                                        numHistoryLines:_screen.numberOfScrollbackLines\n                                                  range:visibleRange];\n        [NSGraphicsContext.currentContext restoreGraphicsState];\n    }];\n    const NSRect subrect = NSMakeRect(hmargin + minX * cellWidth,\n                                      0,\n                                      (maxX - minX) * cellWidth + padding.width * 2,\n                                      rows * cellHeight + padding.height * 2);\n    NSImage *cropped = [image it_subimageWithRect:subrect];\n    // The rect in legacyView that matches `subrect`.\n    NSRect sourceRect =\n    NSMakeRect(subrect.origin.x - padding.width,\n               (visibleRange.start.y - visibleLines.location) * _textview.lineHeight + vmargin - padding.height,\n               cropped.size.width,\n               cropped.size.height);\n\n    const NSEdgeInsets shadowInsets = NSEdgeInsetsMake(12, 12, 12, 12);\n    NSImage *shadowed = [NSImage flippedImageOfSize:NSMakeSize(subrect.size.width + shadowInsets.left + shadowInsets.right,\n                                                               subrect.size.height + shadowInsets.top + shadowInsets.bottom)\n                                          drawBlock:^{\n        NSShadow *shadow = [[[NSShadow alloc] init] autorelease];\n\n        shadow.shadowOffset = NSMakeSize(0, 0);\n        shadow.shadowBlurRadius = 4;\n        shadow.shadowColor = [NSColor colorWithWhite:0 alpha:0.4];\n        [shadow set];\n\n        [cropped drawInRect:NSMakeRect(shadowInsets.left,\n                                       shadowInsets.top,\n                                       cropped.size.width,\n                                       cropped.size.height)];\n\n        // Draw again with a smaller shadow to act as an outline.\n        shadow = [[[NSShadow alloc] init] autorelease];\n\n        shadow.shadowOffset = NSMakeSize(0, 0);\n        shadow.shadowBlurRadius = 1;\n        shadow.shadowColor = [NSColor colorWithWhite:0 alpha:0.6];\n        [shadow set];\n\n        [cropped drawInRect:NSMakeRect(shadowInsets.left,\n                                       shadowInsets.top,\n                                       cropped.size.width,\n                                       cropped.size.height)];\n    }];\n    sourceRect.origin.x -= shadowInsets.left;\n    sourceRect.origin.y -= shadowInsets.top;\n    sourceRect.size.width += shadowInsets.left + shadowInsets.right;\n    sourceRect.size.height += shadowInsets.top + shadowInsets.bottom;\n    FindIndicatorWindow *window =\n    [FindIndicatorWindow showWithImage:shadowed\n                                  view:_view.legacyView\n                                  rect:sourceRect\n                      firstVisibleLine:visibleLines.location + _screen.totalScrollbackOverflow];\n    if (window) {\n        [_textview trackChildWindow:window];\n    }\n}\n\n- (BOOL)textViewCanWriteToTTY {\n    return !_exited;\n}\n\n- (void)addTriggerDictionary:(NSDictionary *)dict updateProfile:(BOOL)updateProfile {\n    if (!updateProfile || !self.isDivorced || [_overriddenFields containsObject:KEY_TRIGGERS]) {\n        NSMutableArray<NSDictionary *> *triggers = [[self.profile[KEY_TRIGGERS] ?: @[] mutableCopy] autorelease];\n        [triggers addObject:dict];\n        [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS: triggers }];\n    }\n\n    if (!updateProfile) {\n        return;\n    }\n    NSString *guid;\n    if (self.isDivorced) {\n        guid = self.profile[KEY_ORIGINAL_GUID];\n    } else {\n        guid = self.profile[KEY_GUID];\n    }\n    MutableProfile *profile = [[[[ProfileModel sharedInstance] bookmarkWithGuid:guid] mutableCopy] autorelease];\n    if (!profile) {\n        return;\n    }\n    profile[KEY_TRIGGERS] = [profile[KEY_TRIGGERS] ?: @[] arrayByAddingObject:dict];\n    [[ProfileModel sharedInstance] setBookmark:profile withGuid:profile[KEY_GUID]];\n}\n\n- (void)textViewApplyAction:(iTermAction *)action {\n    [self applyAction:action];\n}\n\n- (void)textViewhandleSpecialKeyDown:(NSEvent *)event {\n    if (_keystrokeSubscriptions.count) {\n        [self sendKeystrokeNotificationForEvent:event advanced:NO];\n    }\n}\n\n- (NSString *)userShell {\n    return [ITAddressBookMgr customShellForProfile:self.profile] ?: [iTermOpenDirectory userShell] ?: @\"/bin/bash\";\n}\n\n- (void)toggleTmuxPaused {\n    if (_tmuxPaused) {\n        [self setTmuxPaused:NO allowAutomaticUnpause:NO];\n    } else {\n        [self.tmuxController pausePanes:@[ @(self.tmuxPane) ]];\n    }\n}\n\n- (void)bury {\n    DLog(@\"Bury %@\", self);\n    if (_synthetic) {\n        DLog(@\"Attempt to bury while synthetic\");\n        return;\n    }\n    if (self.isTmuxClient) {\n        DLog(@\"Is tmux\");\n        if (!self.delegate) {\n            return;\n        }\n        [_tmuxController hideWindow:self.delegate.tmuxWindow];\n        return;\n    }\n    [_textview setDataSource:nil];\n    [_textview setDelegate:nil];\n    [[iTermBuriedSessions sharedInstance] addBuriedSession:self];\n    [_delegate sessionRemoveSession:self];\n\n    _delegate = nil;\n}\n\n- (void)sendEscapeSequence:(NSString *)text\n{\n    if (_exited) {\n        return;\n    }\n    if ([text length] > 0) {\n        NSString *aString = [NSString stringWithFormat:@\"\\e%@\", text];\n        [self writeTask:aString];\n    }\n}\n\n- (NSData *)dataForHexCodes:(NSString *)codes {\n    NSMutableData *data = [NSMutableData data];\n    NSArray* components = [codes componentsSeparatedByString:@\" \"];\n    for (NSString* part in components) {\n        const char* utf8 = [part UTF8String];\n        char* endPtr;\n        unsigned char c = strtol(utf8, &endPtr, 16);\n        if (endPtr != utf8) {\n            [data appendData:[NSData dataWithBytes:&c length:sizeof(c)]];\n        }\n    }\n    return data;\n}\n\n- (void)sendHexCode:(NSString *)codes {\n    if (_exited) {\n        return;\n    }\n    if ([codes length]) {\n        [self writeLatin1EncodedData:[self dataForHexCodes:codes]\n                    broadcastAllowed:YES\n                           reporting:NO];\n    }\n}\n\n- (void)openAdvancedPasteWithText:(NSString *)text escaping:(iTermSendTextEscaping)escaping {\n    NSString *escaped = [self escapedText:text mode:escaping];\n    NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];\n    [pasteboard declareTypes:@[ NSPasteboardTypeString ] owner:self];\n    [pasteboard setString:escaped forType:NSPasteboardTypeString];\n    [_pasteHelper showAdvancedPasteWithFlags:0];\n}\n\n- (void)openComposerWithString:(NSString *)text escaping:(iTermSendTextEscaping)escaping {\n    NSString *escaped = [self escapedText:text mode:escaping];\n    [self.composerManager showOrAppendToDropdownWithString:escaped];\n}\n\n- (void)sendText:(NSString *)text escaping:(iTermSendTextEscaping)escaping {\n    DLog(@\"sendText:%@ escaping:%@\",\n         text,\n         @(escaping));\n    if (_exited) {\n        DLog(@\"Already exited\");\n        return;\n    }\n    if (![text isKindOfClass:[NSString class]]) {\n        DLog(@\"Not a string: %@\", text);\n    }\n    if ([text length] == 0) {\n        return;\n    }\n    [self writeTask:[self escapedText:text mode:escaping]];\n}\n\n- (NSString *)escapedText:(NSString *)text mode:(iTermSendTextEscaping)escaping {\n    NSString *temp = text;\n    switch (escaping) {\n        case iTermSendTextEscapingNone:\n            return text;\n        case iTermSendTextEscapingCommon:\n            return [temp stringByReplacingCommonlyEscapedCharactersWithControls];\n        case iTermSendTextEscapingCompatibility:\n            temp = [temp stringByReplacingEscapedChar:'n' withString:@\"\\n\"];\n            temp = [temp stringByReplacingEscapedChar:'e' withString:@\"\\e\"];\n            temp = [temp stringByReplacingEscapedChar:'a' withString:@\"\\a\"];\n            temp = [temp stringByReplacingEscapedChar:'t' withString:@\"\\t\"];\n            return temp;\n        case iTermSendTextEscapingVimAndCompatibility:\n            temp = [temp stringByExpandingVimSpecialCharacters];\n            temp = [temp stringByReplacingEscapedChar:'n' withString:@\"\\n\"];\n            temp = [temp stringByReplacingEscapedChar:'e' withString:@\"\\e\"];\n            temp = [temp stringByReplacingEscapedChar:'a' withString:@\"\\a\"];\n            temp = [temp stringByReplacingEscapedChar:'t' withString:@\"\\t\"];\n            return temp;\n        case iTermSendTextEscapingVim:\n            return [temp stringByExpandingVimSpecialCharacters];\n    }\n    assert(NO);\n    return @\"\";\n}\n\n- (void)sendTextSlowly:(NSString *)text {\n    PasteEvent *event = [_pasteHelper pasteEventWithString:text\n                                                    slowly:NO\n                                          escapeShellChars:NO\n                                                  isUpload:NO\n                                           allowBracketing:YES\n                                              tabTransform:NO\n                                              spacesPerTab:0\n                                                  progress:^(NSInteger progress) {}];\n    event.defaultChunkSize = 80;\n    event.defaultDelay = 0.02;\n    event.chunkKey = @\"\";\n    event.delayKey = @\"\";\n    event.flags = kPasteFlagsDisableWarnings;\n    [_pasteHelper tryToPasteEvent:event];\n}\n\n- (void)launchCoprocessWithCommand:(NSString *)command\n{\n    [self launchCoprocessWithCommand:command mute:NO];\n}\n\n- (void)uploadFiles:(NSArray *)localFilenames toPath:(SCPPath *)destinationPath\n{\n    SCPFile *previous = nil;\n    for (NSString *file in localFilenames) {\n        SCPPath *path = [[[SCPPath alloc] init] autorelease];\n        path.hostname = destinationPath.hostname;\n        path.username = destinationPath.username;\n        NSString *filename = [file lastPathComponent];\n        path.path = [destinationPath.path stringByAppendingPathComponent:filename];\n\n        if (@available(macOS 11, *)) {\n            if ([_conductor canTransferFilesTo:path]) {\n                [_conductor uploadFile:file to:path];\n                break;\n            }\n        }\n        SCPFile *scpFile = [[[SCPFile alloc] init] autorelease];\n        scpFile.path = path;\n        scpFile.localPath = file;\n\n        if (previous) {\n            previous.successor = scpFile;\n        }\n        previous = scpFile;\n        [scpFile upload];\n    }\n}\n\n- (void)startDownloadOverSCP:(SCPPath *)path\n{\n    if (@available(macOS 11, *)) {\n        if ([_conductor canTransferFilesTo:path]) {\n            [_conductor download:path];\n            return;\n        }\n    }\n    SCPFile *file = [[[SCPFile alloc] init] autorelease];\n    file.path = path;\n    [file download];\n}\n\n- (void)setDvrFrame {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        const screen_char_t *s = (const screen_char_t *)[_dvrDecoder decodedFrame];\n        const int len = [_dvrDecoder screenCharArrayLength];\n        DVRFrameInfo info = [_dvrDecoder info];\n        if (info.width != mutableState.width || info.height != mutableState.height) {\n            if (![_liveSession isTmuxClient]) {\n                [[_delegate realParentWindow] sessionInitiatedResize:self\n                                                               width:info.width\n                                                              height:info.height];\n            }\n        }\n        NSData *data = [NSData dataWithBytes:s length:len];\n        NSMutableArray<NSArray *> *metadataArrays = [NSMutableArray mapIntegersFrom:0 to:info.height block:^id(NSInteger i) {\n            NSData *data = [_dvrDecoder metadataForLine:i];\n            return iTermMetadataArrayFromData(data) ?: @[];\n        }];\n\n        if (_dvrDecoder.migrateFromVersion > 0) {\n            const int lineCount = (info.width + 1);\n            NSMutableData *replacement = [NSMutableData data];\n            for (int y = 0; y < info.height; y++) {\n                NSData *legacyData = [NSData dataWithBytes:s + lineCount * y\n                                                    length:lineCount * sizeof(legacy_screen_char_t)];\n                NSData *modernData;\n                switch (_dvrDecoder.migrateFromVersion) {\n                    case 1: {\n                        iTermMetadata temp = { 0 };\n                        iTermMetadataInitFromArray(&temp, metadataArrays[y]);\n                        iTermMetadataAutorelease(temp);\n                        iTermExternalAttributeIndex *originalIndex = iTermMetadataGetExternalAttributesIndex(temp);\n                        iTermExternalAttributeIndex *eaIndex = originalIndex;\n                        modernData = [legacyData migrateV1ToV3:&eaIndex];\n                        if (!originalIndex && eaIndex) {\n                            iTermMetadataSetExternalAttributes(&temp, eaIndex);\n                            metadataArrays[y] = iTermMetadataEncodeToArray(temp);\n                        }\n                        break;\n                    }\n                    case 2:\n                        modernData = [legacyData migrateV2ToV3];\n                        break;\n                    case 3:\n                        modernData = legacyData;\n                        break;\n                    default:\n                        DLog(@\"Unexpected source version %@\", @(_dvrDecoder.migrateFromVersion));\n                        modernData = legacyData;\n                        break;\n                }\n                [replacement appendData:modernData];\n            }\n            data = replacement;\n        }\n        [mutableState setFromFrame:(screen_char_t *)data.bytes\n                               len:data.length\n                          metadata:metadataArrays\n                              info:info];\n        [[_delegate realParentWindow] clearTransientTitle];\n        [[_delegate realParentWindow] setWindowTitle];\n    }];\n}\n\n- (void)continueTailFind {\n    NSMutableArray<SearchResult *> *results = [NSMutableArray array];\n    BOOL more;\n    VT100GridAbsCoordRange rangeSearched = VT100GridAbsCoordRangeMake(-1, -1, -1, -1);\n    NSRange ignore;\n    more = [_screen continueFindAllResults:results\n                                  rangeOut:&ignore\n                                 inContext:_tailFindContext\n                             rangeSearched:&rangeSearched];\n    DLog(@\"Continue tail find found %@ results, more=%@\", @(results.count), @(more));\n    if (VT100GridAbsCoordRangeIsValid(rangeSearched)) {\n        [_textview removeSearchResultsInRange:rangeSearched];\n    }\n    for (SearchResult *r in results) {\n        [_textview addSearchResult:r];\n    }\n    if ([results count]) {\n        [_textview setNeedsDisplay:YES];\n    }\n    if (more) {\n        DLog(@\"Schedule continueTailFind in .01 sec\");\n        _tailFindTimer = [NSTimer scheduledTimerWithTimeInterval:0.01\n                                                          target:self\n                                                        selector:@selector(continueTailFind)\n                                                        userInfo:nil\n                                                         repeats:NO];\n    } else {\n        DLog(@\"tailfind is all done\");\n        // Update the saved position to just before the screen.\n        [_screen storeLastPositionInLineBufferAsFindContextSavedPosition];\n        _tailFindTimer = nil;\n        _performingOneShotTailFind = NO;\n    }\n}\n\n- (void)beginContinuousTailFind {\n    DLog(@\"beginContinuousTailFind\");\n    _performingOneShotTailFind = NO;\n    [self beginTailFindImpl];\n}\n\n- (void)beginOneShotTailFind {\n    DLog(@\"beginOneShotTailFind\");\n    if (_tailFindTimer || _performingOneShotTailFind) {\n        return;\n    }\n    _performingOneShotTailFind = YES;\n    if (![self beginTailFindImpl]) {\n        _performingOneShotTailFind = NO;\n    }\n}\n\n- (BOOL)beginTailFindImpl {\n    DLog(@\"beginTailFindImpl\");\n    FindContext *findContext = [_textview findContext];\n    if (!findContext.substring) {\n        return NO;\n    }\n    DLog(@\"Begin tail find\");\n    [_screen setFindString:findContext.substring\n          forwardDirection:YES\n                      mode:findContext.mode\n               startingAtX:0\n               startingAtY:0\n                withOffset:0\n                 inContext:_tailFindContext\n           multipleResults:YES];\n\n    // Set the starting position to the block & offset that the backward search\n    // began at. Do a forward search from that location.\n    [_screen restoreSavedPositionToFindContext:_tailFindContext];\n    [self continueTailFind];\n    return YES;\n}\n\n- (void)sessionContentsChanged:(NSNotification *)notification {\n    if (!_tailFindTimer &&\n        [notification object] == self &&\n        [_delegate sessionBelongsToVisibleTab]) {\n        DLog(@\"Session contents changed. Begin tail find.\");\n        __weak __typeof(self) weakSelf = self;\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [weakSelf startTailFindIfVisible];\n        });\n    }\n}\n\n- (void)stopTailFind\n{\n    if (_tailFindTimer) {\n        _tailFindContext.substring = nil;\n        _tailFindContext.results = nil;\n        [_tailFindTimer invalidate];\n        _tailFindTimer = nil;\n    }\n}\n\n- (void)printTmuxMessage:(NSString *)message {\n    DLog(@\"%@\", message);\n    if (_exited) {\n        return;\n    }\n    // Use mutateAsync because you get here from a side-effect.\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal,\n                                    VT100ScreenMutableState *mutableState,\n                                    id<VT100ScreenDelegate> delegate) {\n        screen_char_t savedFgColor = [terminal foregroundColorCode];\n        screen_char_t savedBgColor = [terminal backgroundColorCode];\n        [terminal setForegroundColor:ALTSEM_DEFAULT\n                  alternateSemantics:YES];\n        [terminal setBackgroundColor:ALTSEM_DEFAULT\n                  alternateSemantics:YES];\n        [mutableState appendStringAtCursor:message];\n        [mutableState appendCarriageReturnLineFeed];\n        [terminal setForegroundColor:savedFgColor.foregroundColor\n                  alternateSemantics:savedFgColor.foregroundColorMode == ColorModeAlternate];\n        [terminal setBackgroundColor:savedBgColor.backgroundColor\n                  alternateSemantics:savedBgColor.backgroundColorMode == ColorModeAlternate];\n    }];\n}\n\n- (void)printTmuxCommandOutputToScreen:(NSString *)response\n{\n    for (NSString *aLine in [response componentsSeparatedByString:@\"\\n\"]) {\n        aLine = [aLine stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"];\n        [self printTmuxMessage:aLine];\n    }\n}\n\n#pragma mark - VT100ScreenDelegate\n\n- (void)screenScheduleRedrawSoon {\n    self.active = YES;\n}\n\n- (void)screenResetTailFind {\n    _screen.savedFindContextAbsPos = 0;\n}\n\n- (void)screenNeedsRedraw {\n    [self refresh];\n    [_textview updateSubviewFrames];\n}\n\n- (void)screenUpdateDisplay:(BOOL)redraw {\n    [self updateDisplayBecause:[NSString stringWithFormat:@\"screen requested update redraw=%@\", @(redraw)]];\n    if (redraw) {\n        [_textview setNeedsDisplay:YES];\n    }\n}\n\n- (void)screenRefreshFindOnPageView {\n    [_view.findDriver.viewController countDidChange];\n}\n\n- (void)screenSizeDidChangeWithNewTopLineAt:(int)newTop {\n    if ([(PTYScroller*)([_view.scrollview verticalScroller]) userScroll] && newTop >= 0) {\n        const VT100GridRange range = VT100GridRangeMake(newTop,\n                                                        _textview.rangeOfVisibleLines.length);\n        [_textview scrollLineNumberRangeIntoView:range];\n    } else {\n        [_textview scrollEnd];\n    }\n\n    [_textview updateNoteViewFrames];\n    [_textview updatePortholeFrames];\n    [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionColumns: @(_screen.width),\n                                                    iTermVariableKeySessionRows: @(_screen.height) }];\n    [_textview setBadgeLabel:[self badgeLabel]];\n}\n\n- (void)screenDidReset {\n    _cursorGuideSettingHasChanged = NO;\n    _textview.highlightCursorLine = [iTermProfilePreferences boolForColorKey:KEY_USE_CURSOR_GUIDE\n                                                                        dark:_screen.colorMap.darkMode\n                                                                     profile:_profile];\n    self.cursorTypeOverride = nil;\n    [_textview setNeedsDisplay:YES];\n    [self restoreColorsFromProfile];\n    _screen.trackCursorLineMovement = NO;\n}\n\n- (void)restoreColorsFromProfile {\n    NSMutableDictionary<NSString *, id> *change = [NSMutableDictionary dictionary];\n    for (NSString *key in [[_screen.colorMap colormapKeyToProfileKeyDictionary] allValues]) {\n        if (![_overriddenFields containsObject:key]) {\n            continue;\n        }\n        id profileValue = self.originalProfile[key] ?: [NSNull null];\n        change[key] = profileValue;\n    }\n    if (change.count == 0) {\n        return;\n    }\n    [self setSessionSpecificProfileValues:change];\n}\n\n// If plainText is false then it's a control code.\n- (void)screenDidAppendStringToCurrentLine:(NSString * _Nonnull)string\n                               isPlainText:(BOOL)plainText\n                                foreground:(screen_char_t)fg\n                                background:(screen_char_t)bg {\n    if (plainText) {\n        [self logCooked:[string dataUsingEncoding:_screen.terminalEncoding]\n             foreground:fg\n             background:bg];\n    }\n}\n\n- (void)logCooked:(NSData *)data\n       foreground:(screen_char_t)fg\n       background:(screen_char_t)bg {\n    if (!_logging.enabled) {\n        return;\n    }\n    if (self.isTmuxGateway) {\n        return;\n    }\n    switch (_logging.style) {\n        case iTermLoggingStyleRaw:\n        case iTermLoggingStyleAsciicast:\n            break;\n        case iTermLoggingStylePlainText:\n            [_logging logData:data];\n            break;\n        case iTermLoggingStyleHTML:\n            [_logging logData:[data htmlDataWithForeground:fg\n                                                background:bg\n                                                  colorMap:_screen.colorMap\n                                        useCustomBoldColor:_textview.useCustomBoldColor\n                                              brightenBold:_textview.brightenBold]];\n            break;\n    }\n}\n\n- (void)screenDidAppendAsciiDataToCurrentLine:(NSData *)asciiData\n                                   foreground:(screen_char_t)fg\n                                   background:(screen_char_t)bg {\n    if (_logging.enabled) {\n        [self logCooked:asciiData\n             foreground:fg\n             background:bg];\n    }\n}\n\n- (void)screenRevealComposerWithPrompt:(NSArray<ScreenCharArray *> *)prompt {\n    _promptStateAllowsAutoComposer = YES;\n    if ([iTermPreferences boolForKey:kPreferenceAutoComposer]) {\n        if (_initializationFinished) {\n            if (![self haveAutoComposer]) {\n                [_composerManager reset];\n                [self revealAutoComposerWithPrompt:prompt];\n            }\n        } else {\n            _desiredComposerPrompt = [prompt copy];\n        }\n    }\n}\n\n- (void)screenDismissComposer {\n    _promptStateAllowsAutoComposer = NO;\n    if (_initializationFinished) {\n        [self.composerManager dismissAnimated:NO];\n    } else {\n        [_desiredComposerPrompt release];\n        _desiredComposerPrompt = nil;\n    }\n    [_textview setNeedsDisplay:YES];\n}\n\n- (void)screenAppendStringToComposer:(NSString *)string {\n    if (self.haveAutoComposer) {\n        DLog(@\"Append to composer: %@\", string);\n        [_composerManager insertText:string];\n        _composerManager.haveShellProvidedText = YES;\n    }\n}\n\n- (void)screenSetCursorType:(ITermCursorType)newType {\n    ITermCursorType type = newType;\n    if (type == CURSOR_DEFAULT) {\n        self.cursorTypeOverride = nil;\n    } else {\n        self.cursorTypeOverride = [@(type) retain];\n    }\n}\n\n- (void)screenSetCursorBlinking:(BOOL)blink {\n    if (![iTermProfilePreferences boolForKey:KEY_ALLOW_CHANGE_CURSOR_BLINK inProfile:self.profile]) {\n        return;\n    }\n    // This doesn't update the profile because we want reset to be able to restore it to the\n    // profile's value. It does mean the session profile won't reflect that the cursor is blinking.\n    self.textview.blinkingCursor = blink;\n}\n\n- (BOOL)screenCursorIsBlinking {\n    return self.textview.blinkingCursor;\n}\n\n- (void)screenResetCursorTypeAndBlink {\n    self.cursorTypeOverride = nil;\n    self.textview.blinkingCursor = [iTermProfilePreferences boolForKey:KEY_BLINKING_CURSOR inProfile:self.profile];\n}\n\n- (void)screenGetCursorType:(ITermCursorType *)cursorTypeOut\n                   blinking:(BOOL *)blinking {\n    *cursorTypeOut = self.cursorType;\n    *blinking = self.textview.blinkingCursor;\n}\n\n- (BOOL)screenShouldInitiateWindowResize {\n    return ![[[self profile] objectForKey:KEY_DISABLE_WINDOW_RESIZING] boolValue];\n}\n\n- (void)screenResizeToWidth:(int)width height:(int)height {\n    [_delegate sessionInitiatedResize:self width:width height:height];\n}\n\n- (void)screenSetSize:(VT100GridSize)proposedSize {\n    if (![self screenShouldInitiateWindowResize]) {\n        return;\n    }\n    if ([[_delegate parentWindow] anyFullScreen]) {\n        return;\n    }\n    int rows = proposedSize.width;\n    const VT100GridSize windowSize = [self windowSizeInCells];\n    if (rows == -1) {\n        rows = _screen.height;\n    } else if (rows == 0) {\n        rows = windowSize.height;\n    }\n\n    int columns = proposedSize.height;\n    if (columns == -1) {\n        columns = _screen.width;\n    } else if (columns == 0) {\n        columns = windowSize.width;\n    }\n    [_delegate sessionInitiatedResize:self width:columns height:rows];\n}\n\n- (VT100GridSize)windowSizeInCells {\n    VT100GridSize result;\n    const NSRect screenFrame = [self screenWindowScreenFrame];\n    const NSRect windowFrame = [self screenWindowFrame];\n    const NSSize cellSize = [self screenCellSize];\n    {\n        const CGFloat roomToGrow = screenFrame.size.height - windowFrame.size.height;\n        result.height = round(_screen.height + roomToGrow / cellSize.height);\n    }\n    {\n        const CGFloat roomToGrow = screenFrame.size.width - windowFrame.size.width;\n        result.width = round(_screen.width + roomToGrow / cellSize.width);\n    }\n    return result;\n}\n\n- (void)screenSetPointSize:(NSSize)proposedSize {\n    if (![self screenShouldInitiateWindowResize]) {\n        return;\n    }\n    if ([self screenWindowIsFullscreen]) {\n        return;\n    }\n    // TODO: Only allow this if there is a single session in the tab.\n    const NSRect frame = [self screenWindowFrame];\n    const NSRect screenFrame = [self screenWindowScreenFrame];\n    CGFloat width = proposedSize.width;\n    if (width < 0) {\n        width = frame.size.width;\n    } else if (width == 0) {\n        width = screenFrame.size.width;\n    }\n\n    CGFloat height = proposedSize.height;\n    if (height < 0) {\n        height = frame.size.height;\n    } else if (height == 0) {\n        height = screenFrame.size.height;\n    }\n    [[_delegate realParentWindow] setFrameSize:NSMakeSize(width, height)];\n}\n\n- (void)screenPrintStringIfAllowed:(NSString *)string\n                        completion:(void (^)(void))completion {\n    // Dispatch because this may show an alert and you can't have a runloop in a side effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self reallyTryToPrintString:string];\n        completion();\n    });\n}\n\n- (void)reallyTryToPrintString:(NSString *)string {\n    if (![self shouldBeginPrinting:YES]) {\n        return;\n    }\n    if (string.length > 0) {\n        [[self textview] printContent:string];\n    }\n}\n\n- (BOOL)shouldBeginPrinting:(BOOL)willPrint {\n    if (!_printGuard) {\n        _printGuard = [[iTermPrintGuard alloc] init];\n    }\n    return [_printGuard shouldPrintWithProfile:self.profile\n                                      inWindow:self.view.window\n                                     willPrint:willPrint];\n}\n\n- (void)screenSetWindowTitle:(NSString *)title {\n    // The window name doesn't normally serve as an interpolated string, but just to be extra safe\n    // break up \\(.\n    title = [title stringByReplacingOccurrencesOfString:@\"\\\\(\" withString:@\"\\\\\\u200B(\"];\n    [self setWindowTitle:title];\n    [self.delegate sessionDidSetWindowTitle:title];\n}\n\n- (NSString *)screenWindowTitle {\n    return [self windowTitle];\n}\n\n- (NSString *)screenIconTitle {\n    return [self.variablesScope valueForVariableName:iTermVariableKeySessionIconName] ?: [self.variablesScope valueForVariableName:iTermVariableKeySessionName];\n}\n\n- (void)screenSetIconName:(NSString *)theName {\n    DLog(@\"screenSetIconName:%@\", theName);\n    // Put a zero-width space in between \\ and ( to avoid interpolated strings coming from the server.\n    theName = [theName stringByReplacingOccurrencesOfString:@\"\\\\(\" withString:@\"\\\\\\u200B(\"];\n    [self setIconName:theName];\n    [self enableSessionNameTitleComponentIfPossible];\n}\n\n- (void)screenSetSubtitle:(NSString *)subtitle {\n    DLog(@\"screenSetSubtitle:%@\", subtitle);\n    // Put a zero-width space in between \\ and ( to avoid interpolated strings coming from the server.\n    NSString *safeSubtitle = [subtitle stringByReplacingOccurrencesOfString:@\"\\\\(\" withString:@\"\\\\\\u200B(\"];\n    [self setSessionSpecificProfileValues:@{ KEY_SUBTITLE: safeSubtitle }];\n}\n\n- (void)enableSessionNameTitleComponentIfPossible {\n    // Turn on the session name component so the icon/trigger name will be visible.\n    iTermTitleComponents components = [iTermProfilePreferences unsignedIntegerForKey:KEY_TITLE_COMPONENTS\n                                                                           inProfile:self.profile];\n    if (components & iTermTitleComponentsCustom) {\n        return;\n    }\n    if (components & (iTermTitleComponentsSessionName | iTermTitleComponentsProfileAndSessionName)) {\n        return;\n    }\n    components |= iTermTitleComponentsSessionName;\n    [self setSessionSpecificProfileValues:@{ KEY_TITLE_COMPONENTS: @(components) }];\n\n}\n\n- (BOOL)screenWindowIsFullscreen {\n    return [[_delegate parentWindow] anyFullScreen];\n}\n\n- (void)screenMoveWindowTopLeftPointTo:(NSPoint)point {\n    NSRect screenFrame = [self screenWindowScreenFrame];\n    point.x += screenFrame.origin.x;\n    point.y = screenFrame.origin.y + screenFrame.size.height - point.y;\n    [[_delegate parentWindow] windowSetFrameTopLeftPoint:point];\n}\n\n- (NSRect)screenWindowScreenFrame {\n    return [[[_delegate parentWindow] windowScreen] visibleFrame];\n}\n\n- (NSRect)windowFrame {\n    NSRect frame = [self screenWindowFrame];\n    NSRect screenFrame = [self screenWindowScreenFrame];\n    return NSMakeRect(frame.origin.x - screenFrame.origin.x,\n                      (screenFrame.origin.y + screenFrame.size.height) - (frame.origin.y + frame.size.height),\n                      frame.size.width,\n                      frame.size.height);\n}\n\n- (VT100GridSize)theoreticalGridSize {\n    //  TODO: WTF do we do with panes here?\n    VT100GridSize result;\n    NSRect screenFrame = [self screenWindowScreenFrame];\n    NSRect windowFrame = [self screenWindowFrame];\n    NSSize cellSize = [self screenCellSize];\n    {\n        const CGFloat roomToGrow = screenFrame.size.height - windowFrame.size.height;\n        result.height = _screen.height + roomToGrow / cellSize.height;\n    }\n    {\n        const CGFloat roomToGrow = screenFrame.size.width - windowFrame.size.width;\n        result.width = _screen.width + roomToGrow / cellSize.width;\n    }\n    return result;\n}\n\n// If flag is set, miniaturize; otherwise, deminiaturize.\n- (void)screenMiniaturizeWindow:(BOOL)flag {\n    if (flag) {\n        [[_delegate parentWindow] windowPerformMiniaturize:nil];\n    } else {\n        [[_delegate parentWindow] windowDeminiaturize:nil];\n    }\n}\n\n// If flag is set, bring to front; if not, move to back.\n- (void)screenRaise:(BOOL)flag {\n    if (flag) {\n        [[_delegate parentWindow] windowOrderFront:nil];\n    } else {\n        [[_delegate parentWindow] windowOrderBack:nil];\n    }\n}\n\n// Sets current session proxy icon.\n- (void)screenSetPreferredProxyIcon:(NSString *)value {\n    NSURL *url = nil;\n    if (value) {\n        url = [NSURL URLWithString:value];\n    }\n    self.preferredProxyIcon = url;\n    [_delegate sessionProxyIconDidChange:self];\n}\n\n- (BOOL)screenWindowIsMiniaturized {\n    return [[_delegate parentWindow] windowIsMiniaturized];\n}\n\n- (void)screenSendReportData:(NSData *)data {\n    if (_shell == nil) {\n        return;\n    }\n    if (self.tmuxMode == TMUX_GATEWAY) {\n        // Prevent joining threads when writing the tmux message. Also, this doesn't make sense to do.\n        return;\n    }\n    [self writeLatin1EncodedData:data broadcastAllowed:NO reporting:YES];\n}\n\n- (void)screenDidSendAllPendingReports {\n    for (NSData *data in _dataQueue) {\n        DLog(@\"Send deferred write of %@\", [data stringWithEncoding:NSUTF8StringEncoding]);\n        [self writeData:data];\n    }\n    [_dataQueue removeAllObjects];\n}\n\n- (NSRect)screenWindowFrame {\n    return [[_delegate parentWindow] windowFrame];\n}\n\n- (NSSize)screenSize {\n    return [[[[[_delegate parentWindow] currentSession] view] scrollview] documentVisibleRect].size;\n}\n\n// If the flag is set, push the window title; otherwise push the icon title.\n- (void)screenPushCurrentTitleForWindow:(BOOL)flag {\n    if (flag) {\n        [self pushWindowTitle];\n    } else {\n        [self pushIconTitle];\n    }\n}\n\n// If the flag is set, pop the window title; otherwise pop the icon title.\n- (void)screenPopCurrentTitleForWindow:(BOOL)flag {\n    if (flag) {\n        [self popWindowTitle];\n    } else {\n        [self popIconTitle];\n    }\n}\n\n- (NSString *)screenName {\n    return [self name];\n}\n\n- (int)screenNumber {\n    return [_delegate tabNumber];\n}\n\n- (int)screenWindowIndex {\n    return [[iTermController sharedInstance] indexOfTerminal:(PseudoTerminal *)[_delegate realParentWindow]];\n}\n\n- (int)screenTabIndex {\n    return [_delegate number];\n}\n\n- (int)screenViewIndex {\n    return [[self view] viewId];\n}\n\n- (void)screenStartTmuxModeWithDCSIdentifier:(NSString *)dcsID {\n    [self startTmuxMode:dcsID];\n}\n\n- (void)screenHandleTmuxInput:(VT100Token *)token {\n    [_tmuxGateway executeToken:token];\n}\n\n- (BOOL)screenShouldTreatAmbiguousCharsAsDoubleWidth {\n    return [self treatAmbiguousWidthAsDoubleWidth];\n}\n\n- (void)screenPrintVisibleAreaIfAllowed {\n    if (![self shouldBeginPrinting:YES]) {\n        return;\n    }\n    // Cause mutableState to be copied to state so we print what the app thinks it's printing.\n    [_textview refresh];\n    [_textview print:nil];\n}\n\n- (BOOL)screenShouldSendContentsChangedNotification {\n    return [self wantsContentChangedNotification];\n}\n\n- (void)screenRemoveSelection {\n    [_textview deselect];\n}\n\n- (iTermSelection *)screenSelection {\n    return _textview.selection;\n}\n\n- (NSSize)screenCellSize {\n    return NSMakeSize([_textview charWidth], [_textview lineHeight]);\n}\n\n- (void)screenDidClearScrollbackBuffer {\n    [_delegate sessionDidClearScrollbackBuffer:self];\n}\n\n- (void)screenClearHighlights {\n    [_textview clearHighlights:NO];\n}\n\n- (void)screenMouseModeDidChange {\n    [_textview updateCursor:nil];\n    [self.view updateTrackingAreas];\n    [self.variablesScope setValue:@(_screen.terminalMouseMode)\n                 forVariableNamed:iTermVariableKeySessionMouseReportingMode];\n}\n\n- (void)screenFlashImage:(NSString *)identifier {\n    [_textview beginFlash:identifier];\n}\n\n- (void)incrementBadge {\n    [[_delegate realParentWindow] incrementBadge];\n}\n\n- (void)screenGetWorkingDirectoryWithCompletion:(void (^)(NSString *))completion {\n    DLog(@\"screenGetWorkingDirectoryWithCompletion\");\n    [_pwdPoller addOneTimeCompletion:completion];\n    [_pwdPoller poll];\n}\n\n- (void)screenSetCursorVisible:(BOOL)visible {\n    [_textview setCursorVisible:visible];\n}\n\n- (void)screenCursorDidMoveToLine:(int)line {\n    if (_textview.cursorVisible) {\n        [_textview setNeedsDisplayOnLine:line];\n    }\n}\n\n- (void)screenSetHighlightCursorLine:(BOOL)highlight {\n    [self internalSetHighlightCursorLine:highlight];\n}\n\n- (void)screenClearCapturedOutput {\n    [[NSNotificationCenter defaultCenter] postNotificationName:kPTYSessionCapturedOutputDidChange\n                                                        object:nil];\n}\n\n- (void)setHighlightCursorLine:(BOOL)highlight {\n    [self internalSetHighlightCursorLine:highlight];\n    _screen.trackCursorLineMovement = highlight;\n}\n\n- (void)internalSetHighlightCursorLine:(BOOL)highlight {\n    _cursorGuideSettingHasChanged = YES;\n    _textview.highlightCursorLine = highlight;\n    [_textview setNeedsDisplay:YES];\n}\n\n- (BOOL)highlightCursorLine {\n    return _textview.highlightCursorLine;\n}\n\n- (BOOL)screenHasView {\n    return _textview != nil;\n}\n\n- (void)revealIfTabSelected {\n    if (![self.delegate sessionIsInSelectedTab:self]) {\n        return;\n    }\n    [_delegate setActiveSession:self];\n    [self.delegate sessionDisableFocusFollowsMouseAtCurrentLocation];\n}\n\n- (void)reveal {\n    DLog(@\"Reveal session %@\", self);\n    if ([[[iTermBuriedSessions sharedInstance] buriedSessions] containsObject:self]) {\n        DLog(@\"disinter\");\n        [[iTermBuriedSessions sharedInstance] restoreSession:self];\n    }\n    NSWindowController<iTermWindowController> *terminal = [_delegate realParentWindow];\n    iTermController *controller = [iTermController sharedInstance];\n    BOOL okToActivateApp = YES;\n    if ([terminal isHotKeyWindow]) {\n        DLog(@\"Showing hotkey window\");\n        iTermProfileHotKey *hotKey = [[iTermHotKeyController sharedInstance] profileHotKeyForWindowController:(PseudoTerminal *)terminal];\n        [[iTermHotKeyController sharedInstance] showWindowForProfileHotKey:hotKey url:nil];\n        okToActivateApp = (hotKey.hotkeyWindowType != iTermHotkeyWindowTypeFloatingPanel);\n    } else {\n        DLog(@\"Making window current\");\n        [controller setCurrentTerminal:(PseudoTerminal *)terminal];\n        DLog(@\"Making window key and ordering front\");\n        [[terminal window] makeKeyAndOrderFront:self];\n        DLog(@\"Selecting tab from delegate %@\", _delegate);\n        [_delegate sessionSelectContainingTab];\n    }\n    if (okToActivateApp) {\n        DLog(@\"Activate the app\");\n        [[NSApplication sharedApplication] activateIgnoringOtherApps:YES];\n    }\n\n    DLog(@\"Make this session active in delegate %@\", _delegate);\n    [_delegate setActiveSessionPreservingMaximization:self];\n}\n\n- (void)makeActive {\n    [self.delegate sessionActivate:self];\n}\n\n- (void)screenDidAddMark:(id<iTermMark>)newMark alert:(BOOL)alert completion:(void (^)(void))completion {\n    if ([self markIsNavigable:newMark]) {\n        // currentMarkOrNotePosition is used for navigating next/previous\n        self.currentMarkOrNotePosition = newMark.entry.interval;\n    }\n    if (_commandQueue.count) {\n        NSString *command = [[[_commandQueue firstObject] retain] autorelease];\n        [_commandQueue removeObjectAtIndex:0];\n        [self sendCommand:command];\n    }\n    BOOL shouldAlert = alert;\n    if (!alert &&\n        [iTermPreferences boolForKey:kPreferenceKeyAlertOnMarksInOffscreenSessions] &&\n        !_temporarilySuspendOffscreenMarkAlerts) {\n        shouldAlert = ![self.delegate sessionIsInSelectedTab:self];\n    }\n    if (!shouldAlert) {\n        DLog(@\"Will enable offscreen mark alerts for %@\", self);\n        __weak __typeof(self) weakSelf = self;\n        dispatch_async(dispatch_get_main_queue(), ^{\n            DLog(@\"Actually enable offscreen mark alerts for %@\", weakSelf);\n            [weakSelf enableOffscreenMarkAlertsIfNeeded];\n        });\n        completion();\n        return;\n    }\n    DLog(@\"Alert for %@\", self);\n    self.alertOnNextMark = NO;\n    NSString *action = [iTermApplication.sharedApplication delegate].markAlertAction;\n    if ([action isEqualToString:kMarkAlertActionPostNotification]) {\n        [[iTermNotificationController sharedInstance] notify:@\"Mark Set\"\n                                             withDescription:[NSString stringWithFormat:@\"Session %@ #%d had a mark set.\",\n                                                              [[self name] removingHTMLFromTabTitleIfNeeded],\n                                                              [_delegate tabNumber]]\n                                                 windowIndex:[self screenWindowIndex]\n                                                    tabIndex:[self screenTabIndex]\n                                                   viewIndex:[self screenViewIndex]\n                                                      sticky:YES];\n        completion();\n        return;\n    }\n    // Dispatch so that we don't get a runloop in a side-effect, which can do weird re-entrant things.\n    __weak __typeof(self) weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf showMarkSetAlert];\n        completion();\n    });\n}\n\n- (void)showMarkSetAlert {\n    NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n    alert.messageText = @\"Alert\";\n    alert.informativeText = [NSString stringWithFormat:@\"Mark set in session \u201c%@.\u201d\", [self name]];\n    [alert addButtonWithTitle:@\"Reveal\"];\n    [alert addButtonWithTitle:@\"OK\"];\n    if ([alert runModal] == NSAlertFirstButtonReturn) {\n        [self reveal];\n    }\n}\n\n- (void)screenPromptDidStartAtLine:(int)line {\n    [_pasteHelper unblock];\n}\n\n- (void)screenPromptDidEndWithMark:(id<VT100ScreenMarkReading>)mark {\n    _composerManager.haveShellProvidedText = NO;\n    [_promptSubscriptions enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n        if (obj.argumentsOneOfCase == ITMNotificationRequest_Arguments_OneOfCase_GPBUnsetOneOfCase ||\n            [obj.promptMonitorRequest.modesArray it_contains:ITMPromptMonitorMode_Prompt]) {\n            ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n            notification.promptNotification = [[[ITMPromptNotification alloc] init] autorelease];\n            notification.promptNotification.session = self.guid;\n            notification.promptNotification.prompt.placeholder = @\"\";\n            notification.promptNotification.prompt.prompt = [self getPromptResponseForMark:mark];\n            if (mark) {\n                notification.promptNotification.uniquePromptId = mark.guid;\n            }\n            [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                                 toConnectionKey:key];\n        }\n    }];\n    __weak __typeof(self) weakSelf = self;\n    // Can't just do it here because it may trigger a resize and this runs as a side-effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf updateAutoComposerFrame];\n    });\n}\n\n- (void)updateAutoComposerFrame {\n    if (_composerManager.dropDownComposerViewIsVisible && _composerManager.isAutoComposer) {\n        [_composerManager updateFrame];\n    }\n}\n\n// Save the current scroll position\n- (void)screenSaveScrollPosition {\n    [self saveScrollPositionWithName:nil];\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [_textview refresh];  // Handle scrollback overflow so we have the most recent scroll position\n        id<iTermMark> mark = [mutableState addMarkStartingAtAbsoluteLine:[_textview absoluteScrollPosition]\n                                                                 oneLine:NO\n                                                                 ofClass:[VT100ScreenMark class]];\n        self.currentMarkOrNotePosition = mark.doppelganger.entry.interval;\n    }];\n}\n\n- (void)saveScrollPositionWithName:(NSString *)name {\n    DLog(@\"saveScrollPositionWithName:%@\", name);\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [_textview refresh];  // Handle scrollback overflow so we have the most recent scroll position\n        id<iTermMark> mark = [mutableState addMarkStartingAtAbsoluteLine:[_textview absoluteScrollPosition]\n                                                                 oneLine:NO\n                                                                 ofClass:[VT100ScreenMark class]\n                                                                modifier:^(id<iTermMark> mark) {\n            VT100ScreenMark *screenMark = [VT100ScreenMark castFrom:mark];\n            screenMark.name = name;\n        }];\n        self.currentMarkOrNotePosition = mark.doppelganger.entry.interval;\n    }];\n}\n\n- (void)renameMark:(id<VT100ScreenMarkReading>)mark to:(NSString *)newName {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        VT100ScreenMark *screenMark = (VT100ScreenMark *)[mark progenitor];\n        if (!screenMark.entry.interval || !screenMark.name) {\n            return;\n        }\n        const VT100GridAbsCoordRange range = [mutableState absCoordRangeForInterval:screenMark.entry.interval];\n        [mutableState removeNamedMark:screenMark];\n        [mutableState addMarkStartingAtAbsoluteLine:range.start.y\n                                            oneLine:NO\n                                            ofClass:[VT100ScreenMark class]\n                                           modifier:^(id<iTermMark> mark) {\n            VT100ScreenMark *screenMark = [VT100ScreenMark castFrom:mark];\n            screenMark.name = newName;\n        }];\n    }];\n}\n- (void)screenStealFocus {\n    // Dispatch because you can't have a runloop in a side-effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self maybeStealFocus];\n    });\n}\n\n- (void)maybeStealFocus {\n    NSString *const identifier = @\"NoSyncAllowDenyStealFocus\";\n    const iTermWarningSelection selection =\n    [iTermWarning showWarningWithTitle:@\"A control sequence attempted to activate a session. Allow it?\"\n                               actions:@[ @\"Allow\", @\"Deny\" ]\n                             accessory:nil\n                            identifier:identifier\n                           silenceable:kiTermWarningTypePermanentlySilenceable\n                               heading:@\"Permission Required\"\n                                window:nil];\n    if (selection == kiTermWarningSelection0) {\n        [self reveal];\n    }\n}\n\n- (void)screenSetProfileToProfileNamed:(NSString *)value {\n    if (![self.naggingController terminalCanChangeProfile]) {\n        return;\n    }\n    Profile *newProfile;\n    if ([value length]) {\n        newProfile = [[ProfileModel sharedInstance] bookmarkWithName:value];\n    } else {\n        newProfile = [[ProfileModel sharedInstance] defaultBookmark];\n    }\n    if (newProfile) {\n        [self setProfile:newProfile preservingName:YES];\n    }\n}\n\n- (void)setProfile:(NSDictionary *)newProfile\n    preservingName:(BOOL)preservingName {\n    [self setProfile:newProfile preservingName:preservingName adjustWindow:YES];\n}\n\n- (void)setProfile:(NSDictionary *)newProfile\n    preservingName:(BOOL)preserveName\n      adjustWindow:(BOOL)adjustWindow {\n    DLog(@\"Set profile to\\n%@\", newProfile);\n    // Force triggers to be checked. We may be switching to a profile without triggers\n    // and we don't want them to run on the lines of text above _triggerLine later on\n    // when switching to a profile that does have triggers. See issue 7832.\n    [self syncCheckingTriggers:VT100ScreenTriggerCheckTypeFullLines];\n\n    NSString *theName = [[self profile] objectForKey:KEY_NAME];\n    NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithDictionary:newProfile];\n    if (preserveName) {\n        [dict setObject:theName forKey:KEY_NAME];\n    }\n\n    _windowAdjustmentDisabled = !adjustWindow;\n    [self setProfile:dict];\n    [self setPreferencesFromAddressBookEntry:dict];\n    _windowAdjustmentDisabled = NO;\n    [_originalProfile autorelease];\n    _originalProfile = [newProfile copy];\n    [self remarry];\n    if (preserveName) {\n        [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionProfileName: newProfile[KEY_NAME] ?: [NSNull null] }];\n        return;\n    }\n    [self profileDidChangeToProfileWithName:newProfile[KEY_NAME]];\n    DLog(@\"Done setting profile of %@\", self);\n}\n\n- (void)screenSetPasteboard:(NSString *)value {\n    if ([iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal]) {\n        if ([value isEqualToString:@\"ruler\"]) {\n            [self setPasteboard:NSPasteboardNameGeneral];\n        } else if ([value isEqualToString:@\"find\"]) {\n            [self setPasteboard:NSPasteboardNameFind];\n        } else if ([value isEqualToString:@\"font\"]) {\n            [self setPasteboard:NSPasteboardNameFont];\n        } else {\n            [self setPasteboard:NSPasteboardNameGeneral];\n        }\n    } else {\n        XLog(@\"Clipboard access denied for CopyToClipboard\");\n    }\n}\n\n- (void)screenDidAddNote:(id<PTYAnnotationReading>)note\n                   focus:(BOOL)focus\n                 visible:(BOOL)visible {\n    [_textview addViewForNote:note focus:focus visible:visible];\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (void)screenDidAddPorthole:(id<Porthole>)porthole {\n    [_textview addPorthole:porthole];\n}\n\n// Stop pasting (despite the name)\n- (void)screenCopyBufferToPasteboard {\n    if ([iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal]) {\n        [self setPasteboard:nil];\n    } else {\n        [_pasteboard release];\n        _pasteboard = nil;\n        [_pbtext release];\n        _pbtext = nil;\n    }\n}\n\n- (void)screenAppendDataToPasteboard:(NSData *)data {\n    if (_pasteboard == nil) {\n        return;\n    }\n    // Don't allow more than 100MB to be added to the pasteboard queue in case someone\n    // forgets to send the EndCopy command.\n    const int kMaxPasteboardBytes = 100 * 1024 * 1024;\n    if ([_pbtext length] + data.length > kMaxPasteboardBytes) {\n        [self setPasteboard:nil];\n    }\n\n    [_pbtext appendData:data];\n}\n\n- (void)screenWillReceiveFileNamed:(NSString *)filename ofSize:(NSInteger)size preconfirmed:(BOOL)preconfirmed {\n    [self.download stop];\n    [self.download endOfData];\n    self.download = [[[TerminalFileDownload alloc] initWithName:filename size:size] autorelease];\n    self.download.preconfirmed = preconfirmed;\n    [self.download download];\n}\n\n- (void)screenDidFinishReceivingFile {\n    [_naggingController didFinishDownload];\n    [self.download endOfData];\n    self.download = nil;\n}\n\n- (void)screenDidFinishReceivingInlineFile {\n    [_naggingController didFinishDownload];\n}\n\n- (void)screenDidReceiveBase64FileData:(NSString * _Nonnull)data\n                               confirm:(void (^ NS_NOESCAPE)(NSString *name,\n                                                             NSInteger lengthBefore,\n                                                             NSInteger lengthAfter))confirm {\n    const NSInteger lengthBefore = self.download.length;\n    if (self.download && ![self.download appendData:data]) {\n        iTermAnnouncementViewController *announcement =\n        [iTermAnnouncementViewController announcementWithTitle:@\"A file transfer was aborted for exceeding its declared size.\"\n                                                         style:kiTermAnnouncementViewStyleWarning\n                                                   withActions:@[ ]\n                                                    completion:^(int selection) {}];\n        [self queueAnnouncement:announcement identifier:@\"FileTransferAbortedOversize\"];\n\n        [self.download stop];\n        [self.download endOfData];\n        self.download = nil;\n        return;\n    }\n    if (!self.download.preconfirmed) {\n        const NSInteger lengthAfter = self.download.length;\n        confirm(self.download.shortName, lengthBefore, lengthAfter);\n    }\n}\n\n- (void)screenFileReceiptEndedUnexpectedly {\n    [self.download stop];\n    [self.download endOfData];\n    self.download = nil;\n}\n\n- (void)screenRequestUpload:(NSString *)args completion:(void (^)(void))completion {\n    // Dispatch out of fear that NSOpenPanel might do something funky with ruloops even though it doesn't seem to currently.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        NSArray<NSString *> *parts = [args componentsSeparatedByString:@\";\"];\n        NSDictionary<NSString *, NSString *> *dict = [parts keyValuePairsWithBlock:^iTermTuple *(NSString *object) {\n            return [object keyValuePair];\n        }];\n        [self requestUploadWithFormat:dict[@\"format\"] version:dict[@\"version\"]];\n        completion();\n    });\n}\n\n- (void)requestUploadWithFormat:(NSString *)format version:(NSString *)version {\n    if (format && ![format isEqualToString:@\"tgz\"]) {\n        NSString *identifier = @\"UploadInUnsupportedFormatRequested\";\n        if (![self announcementWithIdentifier:identifier]) {\n            iTermAnnouncementViewController *announcement =\n            [iTermAnnouncementViewController announcementWithTitle:@\"An upload with an unsupported archive format was requested. You may need a newer version of iTerm2.\"\n                                                             style:kiTermAnnouncementViewStyleWarning\n                                                       withActions:@[]\n                                                        completion:^(int selection) {}];\n            [self queueAnnouncement:announcement identifier:identifier];\n        }\n        return;\n    }\n    NSOpenPanel *panel = [NSOpenPanel openPanel];\n    panel.canChooseDirectories = YES;\n    panel.canChooseFiles = YES;\n    panel.allowsMultipleSelection = YES;\n\n    [NSApp activateIgnoringOtherApps:YES];\n    [panel beginSheetModalForWindow:_textview.window completionHandler:^(NSInteger result) {\n        if (result == NSModalResponseOK) {\n            [self writeTaskNoBroadcast:@\"ok\\n\" encoding:NSISOLatin1StringEncoding forceEncoding:YES reporting:NO];\n            NSFileManager *fileManager = [NSFileManager defaultManager];\n            // Get the directories for all the URLs. If a URL was a file, convert it to the containing directory, otherwise leave it alone.\n            __block BOOL anyFiles = NO;\n            NSArray<NSURL *> *directories = [panel.URLs mapWithBlock:^id(NSURL *anObject) {\n                BOOL isDirectory = NO;\n                if ([fileManager fileExistsAtPath:anObject.path isDirectory:&isDirectory]) {\n                    if (isDirectory) {\n                        return anObject;\n                    } else {\n                        anyFiles = YES;\n                        return [NSURL fileURLWithPath:[anObject.path stringByDeletingLastPathComponent]];\n                    }\n                } else {\n                    XLog(@\"Could not find %@\", anObject.path);\n                    return nil;\n                }\n            }];\n            NSString *base = [directories lowestCommonAncestorOfURLs].path;\n            if (!anyFiles && directories.count == 1) {\n                base = [base stringByDeletingLastPathComponent];\n            }\n            NSArray *baseComponents = [base pathComponents];\n            NSArray<NSString *> *relativePaths = [panel.URLs mapWithBlock:^id(NSURL *anObject) {\n                NSString *path = anObject.path;\n                NSArray<NSString *> *pathComponents = [path pathComponents];\n                NSArray<NSString *> *relativePathComponents = [pathComponents subarrayWithRange:NSMakeRange(baseComponents.count, pathComponents.count - baseComponents.count)];\n                NSString *relativePath = [relativePathComponents componentsJoinedByString:@\"/\"];\n                // Start every path with \"./\" to deal with filenames beginning with -.\n                return [@\".\" stringByAppendingPathComponent:relativePath];\n            }];\n            NSError *error = nil;\n            BOOL includeExtendedAttrs = YES;\n            if (version) {\n                NSString *versionString = [version stringByBase64DecodingStringWithEncoding:NSUTF8StringEncoding];\n                if ([versionString containsString:@\"tar (GNU tar)\"]) {\n                    includeExtendedAttrs = NO;\n                }\n            }\n            NSData *data = [NSData dataWithTGZContainingFiles:relativePaths\n                                               relativeToPath:base\n                                         includeExtendedAttrs:includeExtendedAttrs\n                                                        error:&error];\n            if (!data && error) {\n                NSString *message = error.userInfo[@\"errorMessage\"];\n                if (message) {\n                    NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n                    alert.messageText = @\"Error Preparing Upload\";\n                    alert.informativeText = [NSString stringWithFormat:@\"tar failed with this message: %@\", message];\n                    [alert runModal];\n                    return;\n                }\n            }\n            NSString *base64String = [data base64EncodedStringWithOptions:(NSDataBase64Encoding76CharacterLineLength |\n                                                                           NSDataBase64EncodingEndLineWithCarriageReturn)];\n            base64String = [base64String stringByAppendingString:@\"\\n\\n\"];\n            NSString *label;\n            if (relativePaths.count == 1) {\n                label = relativePaths.firstObject.lastPathComponent;\n            } else {\n                label = [NSString stringWithFormat:@\"%@ plus %ld more\", relativePaths.firstObject.lastPathComponent, relativePaths.count - 1];\n            }\n            const NSUInteger size = base64String.length;\n            self.upload = [[[TerminalFileUpload alloc] initWithName:label size:size] autorelease];\n            [self.upload upload];\n            [_pasteHelper pasteString:base64String\n                               slowly:NO\n                     escapeShellChars:NO\n                             isUpload:YES\n                      allowBracketing:YES\n                         tabTransform:kTabTransformNone\n                         spacesPerTab:0\n                             progress:^(NSInteger progress) {\n                DLog(@\"upload progress %@/%@\", @(progress), @(size));\n                [self.upload didUploadBytes:progress];\n                if (progress == size) {\n                    DLog(@\"Finished\");\n                    self.upload = nil;\n                }\n            }];\n        } else {\n            [self writeTaskNoBroadcast:@\"abort\\n\" encoding:NSISOLatin1StringEncoding forceEncoding:YES reporting:NO];\n        }\n    }];\n}\n\n- (void)setAlertOnNextMark:(BOOL)alertOnNextMark {\n    _alertOnNextMark = alertOnNextMark;\n    [_textview setNeedsDisplay:YES];\n    [self sync];\n}\n\n- (void)screenRequestAttention:(VT100AttentionRequestType)request {\n    switch (request) {\n        case VT100AttentionRequestTypeFireworks:\n            [_textview showFireworks];\n            break;\n        case VT100AttentionRequestTypeStopBouncingDockIcon:\n            [NSApp cancelUserAttentionRequest:_requestAttentionId];\n            break;\n        case VT100AttentionRequestTypeStartBouncingDockIcon:\n            _requestAttentionId =\n            [NSApp requestUserAttention:NSCriticalRequest];\n            break;\n        case VT100AttentionRequestTypeBounceOnceDockIcon:\n            [NSApp requestUserAttention:NSInformationalRequest];\n            break;\n        case VT100AttentionRequestTypeFlash:\n            [_textview.indicatorsHelper beginFlashingFullScreen];\n            break;\n    }\n}\n\n- (void)screenDidTryToUseDECRQCRA {\n    NSString *const userDefaultsKey = @\"NoSyncDisableDECRQCRA\";\n    NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];\n    NSNumber *obj = [NSNumber castFrom:[ud objectForKey:userDefaultsKey]];\n    if (obj) {\n        return;\n    }\n\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:@\"An app tried to read screen contents with DECRQCRA. Enable this feature?\"\n                                                     style:kiTermAnnouncementViewStyleQuestion\n                                               withActions:@[ @\"Yes\", @\"No\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case -2:  // Dismiss programmatically\n                break;\n\n            case -1: // Closed\n                break;\n\n            case 0: // Enable\n                [iTermAdvancedSettingsModel setNoSyncDisableDECRQCRA:NO];\n                break;\n\n            case 1: // Disable\n                [iTermAdvancedSettingsModel setNoSyncDisableDECRQCRA:YES];\n                break;\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:userDefaultsKey];\n}\n\n- (void)screenDisinterSession {\n    [[iTermBuriedSessions sharedInstance] restoreSession:self];\n}\n\n- (void)screenSetBackgroundImageFile:(NSString *)originalFilename {\n    NSString *const filename = [[originalFilename stringByBase64DecodingStringWithEncoding:NSUTF8StringEncoding] stringByTrimmingTrailingCharactersFromCharacterSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];\n    if (filename.length && ![[NSFileManager defaultManager] fileExistsAtPath:filename]) {\n        DLog(@\"file %@ does not exist\", filename);\n        return;\n    }\n    [self.naggingController setBackgroundImageToFileWithName:filename];\n}\n\n- (void)screenSetBadgeFormat:(NSString *)base64Format {\n    NSString *theFormat = [base64Format stringByBase64DecodingStringWithEncoding:self.encoding];\n    iTermParsedExpression *parsedExpression = [iTermExpressionParser parsedExpressionWithInterpolatedString:theFormat scope:self.variablesScope];\n    if ([parsedExpression containsAnyFunctionCall]) {\n        XLog(@\"Rejected control-sequence provided badge format containing function calls: %@\", theFormat);\n        [self showSimpleWarningAnnouncment:@\"The application attempted to set the badge to a value that would invoke a function call. For security reasons, this is not allowed and the badge was not updated.\"\n                                identifier:@\"UnsaveBadgeFormatRejected\"];\n        return;\n    }\n    if (theFormat) {\n        [self setSessionSpecificProfileValues:@{ KEY_BADGE_FORMAT: theFormat }];\n        _textview.badgeLabel = [self badgeLabel];\n    } else {\n        XLog(@\"Badge is not properly base64 encoded: %@\", base64Format);\n    }\n}\n\n- (void)screenSetUserVar:(NSString *)kvpString {\n    iTermTuple<NSString *, NSString *> *kvp = [kvpString keyValuePair];\n    if (kvp) {\n        if ([kvp.firstObject rangeOfString:@\".\"].location != NSNotFound) {\n            DLog(@\"key contains a ., which is not allowed. kvpString=%@\", kvpString);\n            return;\n        }\n        NSString *key = [NSString stringWithFormat:@\"user.%@\", kvp.firstObject];\n        NSString *value = [kvp.secondObject stringByBase64DecodingStringWithEncoding:NSUTF8StringEncoding];\n        [self.variablesScope setValue:value\n                     forVariableNamed:key];\n        if (self.isTmuxClient) {\n            [self.tmuxController setUserVariableWithKey:key\n                                                  value:value\n                                                   pane:self.tmuxPane];\n        }\n    } else {\n        if ([kvpString rangeOfString:@\".\"].location != NSNotFound) {\n            DLog(@\"key contains a ., which is not allowed. key=%@\", kvpString);\n            return;\n        }\n        NSString *key = [NSString stringWithFormat:@\"user.%@\", kvpString];\n        [self.variablesScope setValue:nil forVariableNamed:[NSString stringWithFormat:@\"user.%@\", kvpString]];\n        if (self.isTmuxClient) {\n            [self.tmuxController setUserVariableWithKey:key\n                                                  value:nil\n                                                   pane:self.tmuxPane];\n        }\n    }\n}\n\n- (void)setVariableNamed:(NSString *)name toValue:(id)newValue {\n    [self.variablesScope setValue:newValue forVariableNamed:name];\n}\n\n- (void)injectData:(NSData *)data {\n    [self.screen injectData:data];\n}\n\n// indexes will be in [0,255].\n// 0-7 are ansi colors,\n// 8-15 are ansi bright colors,\n// 16-255 are 256 color-mode colors.\n// If empty, reset all.\n- (NSDictionary<NSNumber *, id> *)screenResetColorWithColorMapKey:(int)key\n                                                       profileKey:(NSString *)profileKey\n                                                             dark:(BOOL)dark {\n    DLog(@\"key=%d profileKey=%@ dark=%d\", key, profileKey, dark);\n    return [self resetColorWithKey:key\n                       fromProfile:_originalProfile\n                        profileKey:profileKey\n                              dark:dark];\n}\n\n- (BOOL)screenSetColor:(NSColor *)color profileKey:(NSString *)profileKey {\n    if (!color) {\n        return NO;\n    }\n\n    if (profileKey) {\n        [self setSessionSpecificProfileValues:@{ profileKey: [color dictionaryValue] }];\n        return NO;\n    }\n    return YES;\n}\n\n- (void)screenSelectColorPresetNamed:(NSString *)name {\n    [self setColorsFromPresetNamed:name];\n}\n\n- (void)screenSetCurrentTabColor:(NSColor *)color {\n    [self setTabColor:color];\n    id<WindowControllerInterface> term = [_delegate parentWindow];\n    [term updateTabColors];\n}\n\n- (NSColor *)tabColor {\n    return [self tabColorInProfile:_profile];\n}\n\n- (void)setTabColor:(NSColor *)color {\n    NSDictionary *dict;\n    if (color) {\n        dict = @{ [self amendedColorKey:KEY_USE_TAB_COLOR]: @YES,\n                  [self amendedColorKey:KEY_TAB_COLOR]: [ITAddressBookMgr encodeColor:color] };\n    } else {\n        dict = @{ [self amendedColorKey:KEY_USE_TAB_COLOR]: @NO };\n    }\n\n    [self setSessionSpecificProfileValues:dict];\n}\n\n- (void)screenSetTabColorRedComponentTo:(CGFloat)color {\n    NSColor *curColor = [self tabColor] ?: [NSColor it_colorInDefaultColorSpaceWithRed:0 green:0 blue:0 alpha:0];\n    [self setTabColor:[curColor it_colorWithRed:color\n                                          green:curColor.greenComponent\n                                           blue:curColor.blueComponent\n                                          alpha:1]];\n    [[_delegate parentWindow] updateTabColors];\n}\n\n- (void)screenSetTabColorGreenComponentTo:(CGFloat)color {\n    NSColor *curColor = [self tabColor] ?: [NSColor it_colorInDefaultColorSpaceWithRed:0 green:0 blue:0 alpha:0];\n    [self setTabColor:[curColor it_colorWithRed:curColor.redComponent\n                                          green:color\n                                           blue:curColor.blueComponent\n                                          alpha:1]];\n    [[_delegate parentWindow] updateTabColors];\n}\n\n- (void)screenSetTabColorBlueComponentTo:(CGFloat)color {\n    NSColor *curColor = [self tabColor] ?: [NSColor it_colorInDefaultColorSpaceWithRed:0 green:0 blue:0 alpha:0];\n    [self setTabColor:[curColor it_colorWithRed:curColor.redComponent\n                                          green:curColor.greenComponent\n                                           blue:color\n                                          alpha:1]];\n    [[_delegate parentWindow] updateTabColors];\n}\n\n- (void)screenCurrentHostDidChange:(id<VT100RemoteHostReading>)host\n                               pwd:(NSString *)workingDirectory\n                               ssh:(BOOL)ssh {\n    DLog(@\"Current host did change to %@, pwd=%@, ssh=%@. %@\", host, workingDirectory, @(ssh), self);\n    NSString *previousHostName = _currentHost.hostname;\n\n    NSNull *null = [NSNull null];\n    NSDictionary *variablesUpdate = @{ iTermVariableKeySessionHostname: host.hostname ?: null,\n                                       iTermVariableKeySessionUsername: host.username ?: null };\n    [self.variablesScope setValuesFromDictionary:variablesUpdate];\n\n    [_textview setBadgeLabel:[self badgeLabel]];\n    [self dismissAnnouncementWithIdentifier:kShellIntegrationOutOfDateAnnouncementIdentifier];\n\n    [[_delegate realParentWindow] sessionHostDidChange:self to:host];\n\n    [self tryAutoProfileSwitchWithHostname:host.hostname\n                                  username:host.username\n                                      path:workingDirectory\n                                       job:self.variablesScope.jobName];\n\n    // Ignore changes to username; only update on hostname changes. See issue 8030.\n    if (previousHostName && ![previousHostName isEqualToString:host.hostname] && !ssh) {\n        [self maybeResetTerminalStateOnHostChange:host];\n    }\n    self.currentHost = host;\n    [self updateVariablesFromConductor];\n}\n\n- (BOOL)shellIsFishForHost:(id<VT100RemoteHostReading>)host {\n    NSString *name = host.usernameAndHostname;\n    if (!name) {\n        return NO;\n    }\n    return [self.hostnameToShell[name] isEqualToString:@\"fish\"];\n}\n\n- (void)maybeResetTerminalStateOnHostChange:(id<VT100RemoteHostReading>)newRemoteHost {\n    _modeHandler.mode = iTermSessionModeDefault;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        if (_xtermMouseReporting && terminal.mouseMode != MOUSE_REPORTING_NONE) {\n            NSNumber *number = [[NSUserDefaults standardUserDefaults] objectForKey:kTurnOffMouseReportingOnHostChangeUserDefaultsKey];\n            if ([number boolValue]) {\n                terminal.mouseMode = MOUSE_REPORTING_NONE;\n            } else if (!number) {\n                [self offerToTurnOffMouseReportingOnHostChange];\n            }\n        }\n        if (terminal.reportFocus) {\n            NSNumber *number = [[NSUserDefaults standardUserDefaults] objectForKey:kTurnOffFocusReportingOnHostChangeUserDefaultsKey];\n            if ([number boolValue]) {\n                terminal.reportFocus = NO;\n            } else if (!number) {\n                [self offerToTurnOffFocusReporting];\n            }\n        }\n        if (terminal.bracketedPasteMode && ![self shellIsFishForHost:newRemoteHost]) {\n            [self maybeTurnOffPasteBracketing];\n        }\n    }];\n}\n\n- (NSArray<iTermCommandHistoryCommandUseMO *> *)commandUses {\n    return [[iTermShellHistoryController sharedInstance] commandUsesForHost:self.currentHost];\n}\n\n- (iTermQuickLookController *)quickLookController {\n    return _textview.quickLookController;\n}\n\n- (void)showSimpleWarningAnnouncment:(NSString *)message\n                          identifier:(NSString *)identifier {\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:message\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"OK\" ]\n                                                completion:^(int selection) {}];\n    [self queueAnnouncement:announcement identifier:identifier];\n}\n\n- (void)offerToTurnOffMouseReportingOnHostChange {\n    if ([self hasAnnouncementWithIdentifier:kTurnOffMouseReportingOnHostChangeAnnouncementIdentifier]) {\n        return;\n    }\n    NSString *title =\n    @\"Looks like mouse reporting was left on when an ssh session ended unexpectedly or an app misbehaved. Turn it off?\";\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:title\n                                                     style:kiTermAnnouncementViewStyleQuestion\n                                               withActions:@[ @\"_Yes\", @\"Always\", @\"Never\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case -2:  // Dismiss programmatically\n                break;\n\n            case -1: // No\n                break;\n\n            case 0: // Yes\n                [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                         VT100ScreenMutableState *mutableState,\n                                                         id<VT100ScreenDelegate> delegate) {\n                    terminal.mouseMode = MOUSE_REPORTING_NONE;\n                }];\n                break;\n\n            case 1: // Always\n                [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                        forKey:kTurnOffMouseReportingOnHostChangeUserDefaultsKey];\n                [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                         VT100ScreenMutableState *mutableState,\n                                                         id<VT100ScreenDelegate> delegate) {\n                    terminal.mouseMode = MOUSE_REPORTING_NONE;\n                }];\n                break;\n\n            case 2: // Never\n                [[NSUserDefaults standardUserDefaults] setBool:NO\n                                                        forKey:kTurnOffMouseReportingOnHostChangeUserDefaultsKey];\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:kTurnOffMouseReportingOnHostChangeAnnouncementIdentifier];\n}\n\n- (void)offerToTurnOffFocusReporting {\n    NSString *title =\n    @\"Looks like focus reporting was left on when an ssh session ended unexpectedly or an app misbehaved. Turn it off?\";\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:title\n                                                     style:kiTermAnnouncementViewStyleQuestion\n                                               withActions:@[ @\"_Yes\", @\"Always\", @\"Never\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case -2:  // Dismiss programmatically\n                break;\n\n            case -1: // No\n                break;\n\n            case 0: // Yes\n                [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                         VT100ScreenMutableState *mutableState,\n                                                         id<VT100ScreenDelegate> delegate) {\n                    terminal.reportFocus = NO;\n                }];\n                break;\n\n            case 1: // Always\n                [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                        forKey:kTurnOffFocusReportingOnHostChangeUserDefaultsKey];\n                [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                                         VT100ScreenMutableState *mutableState,\n                                                         id<VT100ScreenDelegate> delegate) {\n                    terminal.reportFocus = NO;\n                }];\n                break;\n\n            case 2: // Never\n                [[NSUserDefaults standardUserDefaults] setBool:NO\n                                                        forKey:kTurnOffFocusReportingOnHostChangeUserDefaultsKey];\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:kTurnOffFocusReportingOnHostChangeAnnouncementIdentifier];\n}\n\n- (void)offerToTurnOffBracketedPasteOnHostChange {\n    [self.naggingController offerToTurnOffBracketedPasteOnHostChange];\n}\n\n- (void)tryAutoProfileSwitchWithHostname:(NSString *)hostname\n                                username:(NSString *)username\n                                    path:(NSString *)path\n                                     job:(NSString *)job {\n    if ([iTermProfilePreferences boolForKey:KEY_PREVENT_APS inProfile:self.profile]) {\n        return;\n    }\n    [_automaticProfileSwitcher setHostname:hostname username:username path:path job:job];\n}\n\n// This is called when we get a high-confidence working directory (e.g., CurrentDir=).\n- (void)screenCurrentDirectoryDidChangeTo:(NSString *)newPath\n                               remoteHost:(id<VT100RemoteHostReading> _Nullable)remoteHost {\n    DLog(@\"%@\\n%@\", newPath, [NSThread callStackSymbols]);\n    [self didUpdateCurrentDirectory:newPath];\n    [self.variablesScope setValue:newPath forVariableNamed:iTermVariableKeySessionPath];\n\n    [self tryAutoProfileSwitchWithHostname:remoteHost.hostname\n                                  username:remoteHost.username\n                                      path:newPath\n                                       job:self.variablesScope.jobName];\n    [self.variablesScope setValue:newPath forVariableNamed:iTermVariableKeySessionPath];\n    [_pwdPoller invalidateOutstandingRequests];\n    _workingDirectoryPollerDisabled = YES;\n}\n\n- (void)screenDidReceiveCustomEscapeSequenceWithParameters:(NSDictionary<NSString *, NSString *> *)parameters\n                                                   payload:(NSString *)payload {\n    ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n    notification.customEscapeSequenceNotification = [[[ITMCustomEscapeSequenceNotification alloc] init] autorelease];\n    notification.customEscapeSequenceNotification.session = self.guid;\n    notification.customEscapeSequenceNotification.senderIdentity = parameters[@\"id\"];\n    notification.customEscapeSequenceNotification.payload = payload;\n    [_customEscapeSequenceNotifications enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n        [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                             toConnectionKey:key];\n    }];\n}\n\n- (iTermNaggingController *)naggingController {\n    if (!_naggingController) {\n        _naggingController = [[iTermNaggingController alloc] init];\n        _naggingController.delegate = self;\n    }\n    return _naggingController;\n}\n\n- (void)screenReportVariableNamed:(NSString *)name {\n    if (self.isTmuxClient) {\n        return;\n    }\n    NSString *value = nil;\n    if ([self.naggingController permissionToReportVariableNamed:name]) {\n        value = [self stringValueOfVariable:name];\n    }\n    NSData *data = [_screen.terminalOutput reportVariableNamed:name\n                                                         value:value];\n    [self screenSendReportData:data];\n}\n\n- (void)screenReportCapabilities {\n    if (self.isTmuxClient) {\n        return;\n    }\n    const BOOL clipboardAccessAllowed = [iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal];\n    VT100Capabilities capabilities =\n    VT100OutputMakeCapabilities(YES,                                // compatibility24Bit\n                                YES,                                // full24Bit\n                                clipboardAccessAllowed,             // clipboardWritable\n                                YES,                                // decslrm\n                                YES,                                // mouse\n                                YES,                                // DECSCUSR14\n                                YES,                                // DECSCUSR56\n                                YES,                                // DECSCUSR0\n                                YES,                                // unicode\n                                _treatAmbiguousWidthAsDoubleWidth,  // ambiguousWide\n                                _unicodeVersion,                    // unicodeVersion\n                                YES,                                // titleStacks\n                                YES,                                // titleSetting\n                                YES,                                // bracketedPaste\n                                YES,                                // focusReporting\n                                YES,                                // strikethrough\n                                NO,                                 // overline\n                                YES,                                // sync\n                                YES,                                // hyperlinks\n                                YES,                                // notifications\n                                YES,                                // sixel\n                                YES);                               // file\n    NSData *data = [_screen.terminalOutput reportCapabilities:capabilities];\n    [self screenSendReportData:data];\n}\n\n- (VT100GridRange)screenRangeOfVisibleLines {\n    return [_textview rangeOfVisibleLines];\n}\n\n#pragma mark - FinalTerm\n\n- (NSString *)commandInRange:(VT100GridCoordRange)range {\n    return [_screen commandInRange:range];\n}\n\n- (NSString *)currentCommand {\n    if (_screen.commandRange.start.x < 0) {\n        return nil;\n    } else {\n        return [_screen commandInRange:_screen.commandRange];\n    }\n}\n\n- (BOOL)eligibleForAutoCommandHistory {\n    if (!_textview.cursorVisible) {\n        return NO;\n    }\n    VT100GridCoord coord = _screen.commandRange.end;\n    coord.y -= _screen.numberOfScrollbackLines;\n    if (!VT100GridCoordEquals(_screen.currentGrid.cursor, coord)) {\n        return NO;\n    }\n\n    const screen_char_t c = [_screen.currentGrid characterAt:coord];\n    return c.code == 0;\n}\n\n- (NSArray *)autocompleteSuggestionsForCurrentCommand {\n    DLog(@\"begin\");\n    NSString *command;\n    if (_screen.commandRange.start.x < 0) {\n        DLog(@\"no command range\");\n        return nil;\n    }\n    command = [_screen commandInRange:_screen.commandRange];\n    id<VT100RemoteHostReading> host = [_screen remoteHostOnLine:[_screen numberOfLines]];\n    DLog(@\"command=%@ host=%@\", command, host);\n\n    NSString *trimmedCommand =\n    [command stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];\n    return [[iTermShellHistoryController sharedInstance] commandHistoryEntriesWithPrefix:trimmedCommand\n                                                                                  onHost:host];\n}\n\n- (void)screenCommandDidChangeTo:(NSString *)command\n                        atPrompt:(BOOL)atPrompt\n                      hadCommand:(BOOL)hadCommand\n                     haveCommand:(BOOL)haveCommand {\n    DLog(@\"FinalTerm: command=%@ atPropt=%@ hadCommand=%@ haveCommand=%@\",\n         command, @(atPrompt), @(hadCommand), @(haveCommand));\n    if (!haveCommand && hadCommand) {\n        DLog(@\"ACH Hide because don't have a command, but just had one\");\n        [[_delegate realParentWindow] hideAutoCommandHistoryForSession:self];\n        return;\n    }\n    if (!hadCommand && atPrompt) {\n        DLog(@\"ACH Show because I have a range but didn't have a command\");\n        [[_delegate realParentWindow] showAutoCommandHistoryForSession:self];\n    }\n    if ([[_delegate realParentWindow] wantsCommandHistoryUpdatesFromSession:self]) {\n        DLog(@\"ACH Update command to %@\", command);\n        if (haveCommand && self.eligibleForAutoCommandHistory) {\n            [[_delegate realParentWindow] updateAutoCommandHistoryForPrefix:command\n                                                                  inSession:self\n                                                                popIfNeeded:NO];\n        }\n    }\n}\n\n- (void)screenDidExecuteCommand:(NSString *)command\n                          range:(VT100GridCoordRange)range\n                         onHost:(id<VT100RemoteHostReading>)host\n                    inDirectory:(NSString *)directory\n                           mark:(id<VT100ScreenMarkReading>)mark {\n    NSString *trimmedCommand =\n    [command stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];\n    if (trimmedCommand.length) {\n        [[iTermShellHistoryController sharedInstance] addCommand:trimmedCommand\n                                                          onHost:host\n                                                     inDirectory:directory\n                                                        withMark:mark];\n        [_commands addObject:trimmedCommand];\n        [self trimCommandsIfNeeded];\n    }\n    self.lastCommand = command;\n    [self.variablesScope setValue:command forVariableNamed:iTermVariableKeySessionLastCommand];\n\n    // `_screen.commandRange` is from the beginning of command, to the cursor, not necessarily the end of the command.\n    // `range` here includes the entire command and a new line.\n    _lastOrCurrentlyRunningCommandAbsRange = VT100GridAbsCoordRangeFromCoordRange(range, _screen.totalScrollbackOverflow);\n    DLog(@\"Hide ACH because command ended\");\n    [[_delegate realParentWindow] hideAutoCommandHistoryForSession:self];\n    [_promptSubscriptions enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n        if ([obj.promptMonitorRequest.modesArray it_contains:ITMPromptMonitorMode_CommandStart]) {\n            ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n            notification.promptNotification = [[[ITMPromptNotification alloc] init] autorelease];\n            notification.promptNotification.session = self.guid;\n            notification.promptNotification.commandStart.command = command;\n            if (mark) {\n                notification.promptNotification.uniquePromptId = mark.guid;\n            }\n            [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                                 toConnectionKey:key];\n        }\n    }];\n\n    [_composerManager reset];\n}\n\n- (void)screenCommandDidExitWithCode:(int)code mark:(id<VT100ScreenMarkReading>)maybeMark {\n    [_promptSubscriptions enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, ITMNotificationRequest * _Nonnull obj, BOOL * _Nonnull stop) {\n        if ([obj.promptMonitorRequest.modesArray it_contains:ITMPromptMonitorMode_CommandEnd]) {\n            ITMNotification *notification = [[[ITMNotification alloc] init] autorelease];\n            notification.promptNotification = [[[ITMPromptNotification alloc] init] autorelease];\n            notification.promptNotification.session = self.guid;\n            notification.promptNotification.commandEnd.status = code;\n            if (maybeMark) {\n                notification.promptNotification.uniquePromptId = maybeMark.guid;\n            }\n            [[iTermAPIHelper sharedInstance] postAPINotification:notification\n                                                 toConnectionKey:key];\n        }\n    }];\n}\n\n- (void)updateConfigurationFields {\n    BOOL dirty = NO;\n    if (![NSObject object:_config.sessionGuid isEqualToObject:_guid]) {\n        _config.sessionGuid = _guid;\n        dirty = YES;\n    }\n\n    const BOOL treatAmbiguousCharsAsDoubleWidth = [self treatAmbiguousWidthAsDoubleWidth];\n    if (_config.treatAmbiguousCharsAsDoubleWidth != treatAmbiguousCharsAsDoubleWidth) {\n        _config.treatAmbiguousCharsAsDoubleWidth = treatAmbiguousCharsAsDoubleWidth;\n        dirty = YES;\n    }\n\n    if (_config.unicodeVersion != _unicodeVersion) {\n        _config.unicodeVersion = _unicodeVersion;\n        dirty = YES;\n    }\n    if (_config.isTmuxClient != self.isTmuxClient) {\n        _config.isTmuxClient = self.isTmuxClient;\n        dirty = YES;\n    }\n    const BOOL printingAllowed = [self shouldBeginPrinting:NO];\n    if (printingAllowed != _config.printingAllowed) {\n        _config.printingAllowed = printingAllowed;\n        dirty = YES;\n    }\n    const BOOL clipboardAccessAllowed = [iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal];\n    if (clipboardAccessAllowed != _config.clipboardAccessAllowed) {\n        _config.clipboardAccessAllowed = clipboardAccessAllowed;\n        dirty = YES;\n    }\n    const BOOL miniaturized = [[_delegate parentWindow] windowIsMiniaturized];\n    if (miniaturized != _config.miniaturized) {\n        _config.miniaturized = miniaturized;\n        dirty = YES;\n    }\n    const NSRect windowFrame = [self windowFrame];\n    if (!NSEqualRects(windowFrame, _config.windowFrame)) {\n        _config.windowFrame = windowFrame;\n        dirty = YES;\n    }\n    const VT100GridSize theoreticalGridSize = [self theoreticalGridSize];\n    if (!VT100GridSizeEquals(theoreticalGridSize, _config.theoreticalGridSize)) {\n        _config.theoreticalGridSize = theoreticalGridSize;\n        dirty = YES;\n    }\n    NSString *iconTitle = [self screenIconTitle];\n    if (![NSObject object:iconTitle isEqualToObject:_config.iconTitle]) {\n        _config.iconTitle = iconTitle;\n        dirty = YES;\n    }\n    NSString *windowTitle = [self screenWindowTitle];\n    if (![NSObject object:windowTitle isEqualToObject:_config.windowTitle]) {\n        _config.windowTitle = windowTitle;\n        dirty = YES;\n    }\n    const BOOL clearScrollbackAllowed = [self clearScrollbackAllowed];\n    if (clearScrollbackAllowed != _config.clearScrollbackAllowed) {\n        _config.clearScrollbackAllowed = clearScrollbackAllowed;\n        dirty = YES;\n    }\n    const NSSize cellSize = NSMakeSize([_textview charWidth], [_textview lineHeight]);\n    if (!NSEqualSizes(cellSize, _config.cellSize)) {\n        _config.cellSize = cellSize;\n        dirty = YES;\n    }\n    const CGFloat backingScaleFactor = _view.window.screen.backingScaleFactor;\n    if (backingScaleFactor != _config.backingScaleFactor) {\n        _config.backingScaleFactor = backingScaleFactor;\n        dirty = YES;\n    }\n    if (!_config.maximumTheoreticalImageDimension) {\n        _config.maximumTheoreticalImageDimension = PTYSessionMaximumMetalViewSize;\n        dirty = YES;\n    }\n    const BOOL dimOnlyText = [iTermPreferences boolForKey:kPreferenceKeyDimOnlyText];\n    if (_config.dimOnlyText != dimOnlyText) {\n        _config.dimOnlyText = dimOnlyText;\n        dirty = YES;\n    }\n    const BOOL darkMode = (self.view.effectiveAppearance ?: [NSApp effectiveAppearance]).it_isDark;\n    if (_config.darkMode != darkMode) {\n        _config.darkMode = darkMode;\n        dirty = YES;\n    }\n    const BOOL loggingEnabled = _logging.enabled;\n    if (_config.loggingEnabled != loggingEnabled) {\n        _config.loggingEnabled = loggingEnabled;\n        dirty = YES;\n    }\n    NSDictionary *stringForKeypressConfig = [self stringForKeypressConfig];\n    if (![_config.stringForKeypressConfig isEqual:stringForKeypressConfig]) {\n        _config.stringForKeypressConfig = stringForKeypressConfig;\n        _config.stringForKeypress = [self stringForKeypress];\n        dirty = YES;\n    }\n    const BOOL compoundAlertOnNextMark = [self shouldAlert];\n    if (compoundAlertOnNextMark != _config.alertOnNextMark) {\n        _config.alertOnNextMark = compoundAlertOnNextMark;\n        dirty = YES;\n    }\n    const double dimmingAmount = _view.adjustedDimmingAmount;\n    if (_config.dimmingAmount != dimmingAmount) {\n        _config.dimmingAmount = dimmingAmount;\n        dirty = YES;\n    }\n\n    const BOOL publishing = (self.contentSubscribers.count > 0);\n    if (_config.publishing != publishing) {\n        _config.publishing = publishing;\n        dirty = YES;\n    }\n    if (_profileDidChange) {\n        _config.shouldPlacePromptAtFirstColumn = [iTermProfilePreferences boolForKey:KEY_PLACE_PROMPT_AT_FIRST_COLUMN\n                                                                           inProfile:_profile];\n        _config.enableTriggersInInteractiveApps = [iTermProfilePreferences boolForKey:KEY_ENABLE_TRIGGERS_IN_INTERACTIVE_APPS\n                                                                            inProfile:self.profile];\n        _config.triggerParametersUseInterpolatedStrings = [iTermProfilePreferences boolForKey:KEY_TRIGGERS_USE_INTERPOLATED_STRINGS\n                                                                                    inProfile:self.profile];\n        _config.triggerProfileDicts = [iTermProfilePreferences objectForKey:KEY_TRIGGERS inProfile:self.profile];\n        _config.useSeparateColorsForLightAndDarkMode = [iTermProfilePreferences boolForKey:KEY_USE_SEPARATE_COLORS_FOR_LIGHT_AND_DARK_MODE\n                                                                                 inProfile:self.profile];\n        DLog(@\"Set min contrast in config to %f using key %@\",\n             [iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, self.profile, darkMode)\n                                        inProfile:self.profile],\n             iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, self.profile, darkMode));\n        _config.minimumContrast = [iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_MINIMUM_CONTRAST, self.profile, darkMode)\n                                                             inProfile:self.profile];\n        _config.faintTextAlpha = [iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_FAINT_TEXT_ALPHA, self.profile, darkMode)\n                                                            inProfile:self.profile];\n        _config.mutingAmount = [iTermProfilePreferences floatForKey:iTermAmendedColorKey(KEY_CURSOR_BOOST, self.profile, darkMode)\n                                                          inProfile:self.profile];\n        _config.normalization = [iTermProfilePreferences integerForKey:KEY_UNICODE_NORMALIZATION\n                                                             inProfile:self.profile];\n        _config.appendToScrollbackWithStatusBar = [iTermProfilePreferences boolForKey:KEY_SCROLLBACK_WITH_STATUS_BAR\n                                                                            inProfile:self.profile];\n        _config.saveToScrollbackInAlternateScreen = [iTermProfilePreferences boolForKey:KEY_SCROLLBACK_IN_ALTERNATE_SCREEN\n                                                                              inProfile:self.profile];\n        _config.unlimitedScrollback = [iTermProfilePreferences boolForKey:KEY_UNLIMITED_SCROLLBACK\n                                                                inProfile:_profile];\n        _config.reduceFlicker = [iTermProfilePreferences boolForKey:KEY_REDUCE_FLICKER inProfile:self.profile];\n        _config.maxScrollbackLines = [iTermProfilePreferences intForKey:KEY_SCROLLBACK_LINES\n                                                              inProfile:self.profile];\n        _config.profileName = [self profileName];\n        _config.terminalCanChangeBlink = [iTermProfilePreferences boolForKey:KEY_ALLOW_CHANGE_CURSOR_BLINK inProfile:self.profile];\n\n        dirty = YES;\n        _profileDidChange = NO;\n    }\n\n    NSNumber *desiredComposerRows = nil;\n    if ([iTermPreferences boolForKey:kPreferenceAutoComposer] && _promptStateAllowsAutoComposer) {\n        const int desiredRows = MAX(1, _composerManager.desiredHeight / _textview.lineHeight);\n        desiredComposerRows = @(desiredRows);\n    }\n    if (![NSObject object:desiredComposerRows isEqualToObject:_config.desiredComposerRows]) {\n        _config.desiredComposerRows = desiredComposerRows;\n        dirty = YES;\n    }\n    const BOOL useLineStyleMarks = [iTermPreferences boolForKey:kPreferenceAutoComposer];\n    if (useLineStyleMarks != _config.useLineStyleMarks) {\n        _config.useLineStyleMarks = useLineStyleMarks;\n        dirty = YES;\n    }\n\n    const BOOL autoComposerEnabled = [iTermPreferences boolForKey:kPreferenceAutoComposer];\n    if (_config.autoComposerEnabled != autoComposerEnabled) {\n        _config.autoComposerEnabled = autoComposerEnabled;\n        dirty = YES;\n    }\n\n    if (dirty) {\n        _config.isDirty = dirty;\n    }\n}\n\n- (BOOL)shouldAlert {\n    if (self.alertOnNextMark) {\n        DLog(@\"self.alertOnNextMark -> YES\");\n        return YES;\n    }\n    if (!_alertOnMarksinOffscreenSessions) {\n        DLog(@\"!_alertOnMarksinOffscreenSessions -> NO\");\n        return NO;\n    }\n    if (_temporarilySuspendOffscreenMarkAlerts) {\n        DLog(@\"_temporarilySuspendOffscreenMarkAlerts -> NO\");\n        return NO;\n    }\n    if ([self.delegate hasMaximizedPane] && ![self.delegate sessionIsActiveInTab:self]) {\n        DLog(@\"hasMaximizedPane && !sessionIsActiveInTab -> YES\");\n        return YES;\n    }\n    if (!self.view.window.isVisible ||\n        self.view.window.isMiniaturized ||\n        ![self.view.window isOnActiveSpace] ||\n        ![self.delegate sessionIsInSelectedTab:self]) {\n        DLog(@\"offscreen -> YES\");\n        return YES;\n    }\n    DLog(@\"Otherwise -> NO\");\n    return NO;\n}\n\n// As long as this is constant, stringForKeypress will return the same value.\n- (NSDictionary *)stringForKeypressConfig {\n    return _textview.keyboardHandler.dictionaryValue ?: @{};\n}\n\n- (NSDictionary *)stringForKeypress {\n    id (^stringForKeypress)(unsigned short, NSEventModifierFlags, NSString *, NSString *) =\n    ^id(unsigned short keyCode,\n        NSEventModifierFlags flags,\n        NSString *characters,\n        NSString *charactersIgnoringModifiers) {\n        return [self stringForKeyCode:keyCode\n                                flags:flags\n                           characters:characters\n          charactersIgnoringModifiers:charactersIgnoringModifiers] ?: [NSNull null];\n    };\n    NSString *(^c)(UTF32Char c) = ^NSString *(UTF32Char c) {\n        return [NSString stringWithLongCharacter:c];\n    };\n    return @{\n        @(kDcsTermcapTerminfoRequestKey_kb):  stringForKeypress(kVK_Delete, 0, @\"\\x7f\", @\"\\x7f\"),\n        @(kDcsTermcapTerminfoRequestKey_kD):  stringForKeypress(kVK_ForwardDelete, NSEventModifierFlagFunction, c(NSDeleteFunctionKey), c(NSDeleteFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kd):  stringForKeypress(kVK_DownArrow, NSEventModifierFlagFunction, c(NSDownArrowFunctionKey), c(NSDownArrowFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_at_7):  stringForKeypress(kVK_End, NSEventModifierFlagFunction, c(NSEndFunctionKey), c(NSEndFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_at_8):  stringForKeypress(kVK_Return, NSEventModifierFlagFunction, @\"\\r\", @\"\\r\"),\n        @(kDcsTermcapTerminfoRequestKey_k1):  stringForKeypress(kVK_F1, NSEventModifierFlagFunction, c(NSF1FunctionKey), c(NSF1FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k2):  stringForKeypress(kVK_F2, NSEventModifierFlagFunction, c(NSF2FunctionKey), c(NSF2FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k3):  stringForKeypress(kVK_F3, NSEventModifierFlagFunction, c(NSF3FunctionKey), c(NSF3FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k4):  stringForKeypress(kVK_F4, NSEventModifierFlagFunction, c(NSF4FunctionKey), c(NSF4FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k5):  stringForKeypress(kVK_F5, NSEventModifierFlagFunction, c(NSF5FunctionKey), c(NSF5FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k6):  stringForKeypress(kVK_F6, NSEventModifierFlagFunction, c(NSF6FunctionKey), c(NSF6FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k7):  stringForKeypress(kVK_F7, NSEventModifierFlagFunction, c(NSF7FunctionKey), c(NSF7FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k8):  stringForKeypress(kVK_F8, NSEventModifierFlagFunction, c(NSF8FunctionKey), c(NSF8FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k9):  stringForKeypress(kVK_F9, NSEventModifierFlagFunction, c(NSF9FunctionKey), c(NSF9FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_k_semi):  stringForKeypress(kVK_F10, NSEventModifierFlagFunction, c(NSF10FunctionKey), c(NSF10FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F1):  stringForKeypress(kVK_F11, NSEventModifierFlagFunction, c(NSF11FunctionKey), c(NSF11FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F2):  stringForKeypress(kVK_F12, NSEventModifierFlagFunction, c(NSF12FunctionKey), c(NSF12FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F3):  stringForKeypress(kVK_F13, NSEventModifierFlagFunction, c(NSF13FunctionKey), c(NSF13FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F4):  stringForKeypress(kVK_F14, NSEventModifierFlagFunction, c(NSF14FunctionKey), c(NSF14FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F5):  stringForKeypress(kVK_F15, NSEventModifierFlagFunction, c(NSF15FunctionKey), c(NSF15FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F6):  stringForKeypress(kVK_F16, NSEventModifierFlagFunction, c(NSF16FunctionKey), c(NSF16FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F7):  stringForKeypress(kVK_F17, NSEventModifierFlagFunction, c(NSF17FunctionKey), c(NSF17FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F8):  stringForKeypress(kVK_F18, NSEventModifierFlagFunction, c(NSF18FunctionKey), c(NSF18FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_F9):  stringForKeypress(kVK_F19, NSEventModifierFlagFunction, c(NSF19FunctionKey), c(NSF19FunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kh):  stringForKeypress(kVK_Home, NSEventModifierFlagFunction, c(NSHomeFunctionKey), c(NSHomeFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kl):  stringForKeypress(kVK_LeftArrow, NSEventModifierFlagFunction, c(NSLeftArrowFunctionKey), c(NSLeftArrowFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kN):  stringForKeypress(kVK_PageDown, NSEventModifierFlagFunction, c(NSPageDownFunctionKey), c(NSPageDownFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kP):  stringForKeypress(kVK_PageUp, NSEventModifierFlagFunction, c(NSPageUpFunctionKey), c(NSPageUpFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_kr):  stringForKeypress(kVK_RightArrow, NSEventModifierFlagFunction, c(NSRightArrowFunctionKey), c(NSRightArrowFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_star_4):  stringForKeypress(kVK_ForwardDelete,NSEventModifierFlagFunction |  NSEventModifierFlagShift, c(NSDeleteFunctionKey), c(NSDeleteFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_star_7):  stringForKeypress(kVK_End, NSEventModifierFlagFunction | NSEventModifierFlagShift, c(NSEndFunctionKey), c(NSEndFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_pound_2):  stringForKeypress(kVK_Home, NSEventModifierFlagFunction | NSEventModifierFlagShift, c(NSHomeFunctionKey), c(NSHomeFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_pound_4):  stringForKeypress(kVK_LeftArrow, NSEventModifierFlagFunction | NSEventModifierFlagNumericPad | NSEventModifierFlagShift, c(NSLeftArrowFunctionKey), c(NSLeftArrowFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_pct_i):  stringForKeypress(kVK_RightArrow, NSEventModifierFlagFunction | NSEventModifierFlagNumericPad | NSEventModifierFlagShift, c(NSRightArrowFunctionKey), c(NSRightArrowFunctionKey)),\n        @(kDcsTermcapTerminfoRequestKey_ku):  stringForKeypress(kVK_UpArrow, NSEventModifierFlagFunction, c(NSUpArrowFunctionKey), c(NSUpArrowFunctionKey)),\n    };\n}\n\n- (BOOL)shouldPostTerminalGeneratedAlert {\n    return [iTermProfilePreferences boolForKey:KEY_SEND_TERMINAL_GENERATED_ALERT\n                                     inProfile:_profile];\n}\n\n- (void)setSuppressAllOutput:(BOOL)suppressAllOutput {\n    _suppressAllOutput = suppressAllOutput;\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.suppressAllOutput = suppressAllOutput;\n    }];\n}\n\n- (void)resumeOutputIfNeeded {\n    if (_suppressAllOutput) {\n        // If all output was being suppressed and you hit a key, stop it but ignore bells for a few\n        // seconds until we can process any that are in the pipeline.\n        self.suppressAllOutput = NO;\n        _ignoreBellUntil = [NSDate timeIntervalSinceReferenceDate] + 5;\n    }\n}\n\n// Called when a bell is to be run. Applies rate limiting and kicks off the bell indicators\n// (notifications, flashing lights, sounds) per user preference.\n- (void)screenActivateBellAudibly:(BOOL)audibleBell\n                          visibly:(BOOL)flashBell\n                    showIndicator:(BOOL)showBellIndicator\n                            quell:(BOOL)quell {\n    if ([self shouldIgnoreBellWhichIsAudible:audibleBell\n                                     visible:flashBell]) {\n        return;\n    }\n    if (quell) {\n        DLog(@\"Quell bell\");\n    } else {\n        if (audibleBell) {\n            DLog(@\"Beep: ring audible bell\");\n            NSBeep();\n        }\n        if (showBellIndicator) {\n            [self setBell:YES];\n        }\n        if (flashBell) {\n            [self screenFlashImage:kiTermIndicatorBell];\n        }\n    }\n    [[_delegate realParentWindow] incrementBadge];\n}\n\n- (BOOL)shouldIgnoreBellWhichIsAudible:(BOOL)audible visible:(BOOL)visible {\n    self.variablesScope.bellCount = @(self.variablesScope.bellCount.integerValue + 1);\n    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];\n    if (now < _ignoreBellUntil) {\n        return YES;\n    }\n\n    // Only sample every X seconds.\n    static const NSTimeInterval kMaximumTimeBetweenSamples = 0.01;\n    if (now < _lastBell + kMaximumTimeBetweenSamples) {\n        return NO;\n    }\n    _lastBell = now;\n\n    // If the bell rings more often than once every X seconds, you will eventually get an offer to\n    // silence it.\n    static const NSTimeInterval kThresholdForBellMovingAverageToInferAnnoyance = 0.02;\n\n    // Initial value that will require a reasonable amount of bell-ringing to overcome. This value\n    // was chosen so that one bell per second will cause the moving average's value to fall below 4\n    // after 3 seconds.\n    const NSTimeInterval kMaxDuration = 20;\n\n    if (!_bellRate) {\n        _bellRate = [[MovingAverage alloc] init];\n        _bellRate.alpha = 0.95;\n    }\n    // Keep a moving average of the time between bells\n    static const NSTimeInterval kTimeBeforeReset = 1;\n    if (_bellRate.timerStarted && _bellRate.timeSinceTimerStarted > kTimeBeforeReset) {\n        _bellRate.value = kMaxDuration * _bellRate.alpha;\n    } else {\n        [_bellRate addValue:MIN(kMaxDuration, [_bellRate timeSinceTimerStarted])];\n    }\n    DLog(@\"Bell. dt=%@ rate=%@\", @(_bellRate.timeSinceTimerStarted), @(_bellRate.value));\n    [_bellRate startTimer];\n    // If you decline the offer to silence the bell, we'll stop asking for this many seconds.\n    static const NSTimeInterval kTimeToWaitAfterDecline = 10;\n    NSString *const identifier = @\"Annoying Bell Announcement Identifier\";\n    iTermAnnouncementViewController *existingAnnouncement = _announcements[identifier];\n    if (existingAnnouncement) {\n        // Reset the auto-dismiss time each time the bell rings.\n        existingAnnouncement.timeout = 10;\n    }\n    if ([_bellRate value] < kThresholdForBellMovingAverageToInferAnnoyance &&\n        [[NSUserDefaults standardUserDefaults] boolForKey:kSilenceAnnoyingBellAutomatically]) {\n        // Silence automatically\n        _ignoreBellUntil = now + 60;\n        return YES;\n    }\n\n    if ([_bellRate value] < kThresholdForBellMovingAverageToInferAnnoyance &&\n        !existingAnnouncement &&\n        (now - _annoyingBellOfferDeclinedAt > kTimeToWaitAfterDecline) &&\n        ![[NSUserDefaults standardUserDefaults] boolForKey:kSuppressAnnoyingBellOffer]) {\n        iTermAnnouncementViewController *announcement = nil;\n        if (audible) {\n            DLog(@\"Want to show a bell announcement. The bell is audible.\");\n            announcement =\n            [iTermAnnouncementViewController announcementWithTitle:@\"The bell is ringing a lot. Silence it?\"\n                                                             style:kiTermAnnouncementViewStyleQuestion\n                                                       withActions:@[ @\"_Silence Bell Temporarily\",\n                                                                      @\"Suppress _All Output\",\n                                                                      @\"Don't Offer Again\",\n                                                                      @\"Silence Automatically\" ]\n                                                        completion:^(int selection) {\n                // Release the moving average so the count will restart after the announcement goes away.\n                [_bellRate release];\n                _bellRate = nil;\n                switch (selection) {\n                    case -2:  // Dismiss programmatically\n                        DLog(@\"Dismiss programmatically\");\n                        break;\n\n                    case -1: // No\n                        DLog(@\"Dismiss temporarily\");\n                        _annoyingBellOfferDeclinedAt = [NSDate timeIntervalSinceReferenceDate];\n                        break;\n\n                    case 0: // Suppress bell temporarily\n                        DLog(@\"Suppress bell temporarily\");\n                        _ignoreBellUntil = now + 60;\n                        break;\n\n                    case 1: // Suppress all output\n                        DLog(@\"Suppress all output\");\n                        self.suppressAllOutput = YES;\n                        break;\n\n                    case 2: // Never offer again\n                        DLog(@\"Never offer again\");\n                        [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                                forKey:kSuppressAnnoyingBellOffer];\n                        break;\n\n                    case 3:  // Silence automatically\n                        DLog(@\"Silence automatically\");\n                        [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                                forKey:kSilenceAnnoyingBellAutomatically];\n                        break;\n                }\n            }];\n        } else if (visible) {\n            DLog(@\"Want to show a bell announcement. The bell is visible but inaudible.\");\n            // Neither audible nor visible.\n            announcement =\n            [iTermAnnouncementViewController announcementWithTitle:@\"The bell is ringing a lot. Want to suppress all output until things calm down?\"\n                                                             style:kiTermAnnouncementViewStyleQuestion\n                                                       withActions:@[ @\"Suppress _All Output\",\n                                                                      @\"Don't Offer Again\" ]\n                                                        completion:^(int selection) {\n                // Release the moving average so the count will restart after the announcement goes away.\n                [_bellRate release];\n                _bellRate = nil;\n                switch (selection) {\n                    case -2:  // Dismiss programmatically\n                        DLog(@\"Dismiss programmatically\");\n                        break;\n\n                    case -1: // No\n                        DLog(@\"Dismiss temporarily\");\n                        _annoyingBellOfferDeclinedAt = [NSDate timeIntervalSinceReferenceDate];\n                        break;\n\n                    case 0: // Suppress all output\n                        DLog(@\"Suppress all output\");\n                        self.suppressAllOutput = YES;\n                        break;\n\n                    case 1: // Never offer again\n                        DLog(@\"Don't offer again\");\n                        [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                                forKey:kSuppressAnnoyingBellOffer];\n                        break;\n                }\n            }];\n        }\n\n        if (announcement) {\n            // Set the auto-dismiss timeout.\n            announcement.timeout = 10;\n            [self queueAnnouncement:announcement identifier:identifier];\n        }\n    }\n    if ([self wasFocusReportedVeryRecently] && ![self haveWrittenAnythingBesidesFocusReportVeryRecently]) {\n        [self offerToTurnOffFocusReporting];\n        return NO;\n    }\n    return NO;\n}\n\nstatic const NSTimeInterval PTYSessionFocusReportBellSquelchTimeIntervalThreshold = 0.1;\n\n- (BOOL)wasFocusReportedVeryRecently {\n    NSDate *date = self.lastFocusReportDate;\n    if (!date) {\n        return NO;\n    }\n    return -[date timeIntervalSinceNow] < PTYSessionFocusReportBellSquelchTimeIntervalThreshold;\n}\n\n- (BOOL)haveWrittenAnythingBesidesFocusReportVeryRecently {\n    return -[self.lastNonFocusReportingWrite timeIntervalSinceNow] < PTYSessionFocusReportBellSquelchTimeIntervalThreshold;\n}\n\n- (NSString *)profileName {\n    NSString *guid = _profile[KEY_ORIGINAL_GUID] ?: _profile[KEY_GUID];\n    Profile *profile = [[ProfileModel sharedInstance] bookmarkWithGuid:guid];\n    if (profile) {\n        return profile[KEY_NAME];\n    }\n    return _profile[KEY_NAME];\n}\n\n- (void)trimHostsIfNeeded {\n    if (_hosts.count > kMaxHosts) {\n        [_hosts removeObjectsInRange:NSMakeRange(0, _hosts.count - kMaxHosts)];\n    }\n}\n\n- (void)trimCommandsIfNeeded {\n    if (_commands.count > kMaxCommands) {\n        [_commands removeObjectsInRange:NSMakeRange(0, _commands.count - kMaxCommands)];\n    }\n}\n\n- (void)trimDirectoriesIfNeeded {\n    if (_directories.count > kMaxDirectories) {\n        [_directories removeObjectsInRange:NSMakeRange(0, _directories.count - kMaxDirectories)];\n    }\n}\n\n- (void)setLastDirectory:(NSString *)lastDirectory remote:(BOOL)directoryIsRemote pushed:(BOOL)pushed {\n    DLog(@\"setLastDirectory:%@ remote:%@ pushed:%@\\n%@\", lastDirectory, @(directoryIsRemote), @(pushed), [NSThread callStackSymbols]);\n    if (pushed && lastDirectory) {\n        [_directories addObject:lastDirectory];\n        [self trimDirectoriesIfNeeded];\n    }\n    self.lastDirectory = lastDirectory;\n    if (!directoryIsRemote) {\n        if (pushed || !self.lastLocalDirectoryWasPushed) {\n            self.lastLocalDirectory = lastDirectory;\n            self.lastLocalDirectoryWasPushed = pushed;\n        }\n    }\n    if (lastDirectory) {\n        DLog(@\"Set path to %@\", lastDirectory);\n        self.variablesScope.path = lastDirectory;\n    }\n    // Update the proxy icon\n    [_delegate sessionCurrentDirectoryDidChange:self];\n}\n\n- (void)setLastLocalDirectory:(NSString *)lastLocalDirectory {\n    DLog(@\"lastLocalDirectory goes %@ -> %@ for %@\\n%@\", _lastLocalDirectory, lastLocalDirectory, self, [NSThread callStackSymbols]);\n    [_lastLocalDirectory autorelease];\n    _lastLocalDirectory = [lastLocalDirectory copy];\n    if (lastLocalDirectory) {\n        _localFileChecker.workingDirectory = lastLocalDirectory;\n    }\n}\n\n- (void)setLastLocalDirectoryWasPushed:(BOOL)lastLocalDirectoryWasPushed {\n    DLog(@\"lastLocalDirectoryWasPushed goes %@ -> %@ for %@\\n%@\", @(_lastLocalDirectoryWasPushed),\n         @(lastLocalDirectoryWasPushed), self, [NSThread callStackSymbols]);\n    _lastLocalDirectoryWasPushed = lastLocalDirectoryWasPushed;\n}\n\n- (void)asyncInitialDirectoryForNewSessionBasedOnCurrentDirectory:(void (^)(NSString *pwd))completion {\n    if (_conductor != nil && self.lastDirectory.length > 0) {\n        completion(self.lastDirectory);\n        return;\n    }\n    NSString *envPwd = self.environment[@\"PWD\"];\n    DLog(@\"asyncInitialDirectoryForNewSessionBasedOnCurrentDirectory environment[pwd]=%@\", envPwd);\n    [self asyncCurrentLocalWorkingDirectory:^(NSString *pwd) {\n        DLog(@\"asyncCurrentLocalWorkingDirectory finished with %@\", pwd);\n        if (!pwd) {\n            completion(envPwd);\n            return;\n        }\n        completion(pwd);\n    }];\n}\n\n- (void)asyncCurrentLocalWorkingDirectory:(void (^)(NSString *pwd))completion {\n    DLog(@\"Current local working directory requestd for %@\", self);\n    if (_lastLocalDirectory) {\n        DLog(@\"Using cached value %@\", _lastLocalDirectory);\n        completion(_lastLocalDirectory);\n        return;\n    }\n    DLog(@\"No cached value\");\n    __weak __typeof(self) weakSelf = self;\n    [self updateLocalDirectoryWithCompletion:^(NSString *pwd) {\n        DLog(@\"updateLocalDirectory for %@ finished with %@\", weakSelf, pwd);\n        completion(weakSelf.lastLocalDirectory);\n    }];\n}\n\n// POTENTIALLY SLOW - AVOID CALLING!\n- (NSString *)currentLocalWorkingDirectory {\n    DLog(@\"Warning! Slow currentLocalWorkingDirectory called\");\n    if (self.lastLocalDirectory != nil) {\n        // If a shell integration-provided working directory is available, prefer to use it because\n        // it has unresolved symlinks. The path provided by -getWorkingDirectory has expanded symlinks\n        // and isn't what the user expects to see. This was raised in issue 3383. My first fix was\n        // to expand symlinks on _lastDirectory and use it if it matches what the kernel reports.\n        // That was a bad idea because expanding symlinks is slow on network file systems (Issue 4901).\n        // Instead, we'll use _lastDirectory if we believe it's on localhost.\n        // Furthermore, getWorkingDirectory is slow and blocking and it would be better never to call\n        // it.\n        DLog(@\"Using last directory from shell integration: %@\", _lastDirectory);\n        return self.lastLocalDirectory;\n    }\n    DLog(@\"Last directory is unsuitable or nil\");\n    // Ask the kernel what the child's process's working directory is.\n    self.lastLocalDirectory = [_shell getWorkingDirectory];\n    self.lastLocalDirectoryWasPushed = NO;\n    return self.lastLocalDirectory;\n}\n\n- (void)setLastRemoteHost:(id<VT100RemoteHostReading>)lastRemoteHost {\n    if (lastRemoteHost) {\n        [_hosts addObject:lastRemoteHost];\n        [self trimHostsIfNeeded];\n    }\n    [_lastRemoteHost autorelease];\n    _lastRemoteHost = [lastRemoteHost retain];\n}\n\n- (void)screenLogWorkingDirectoryOnAbsoluteLine:(long long)absLine\n                                     remoteHost:(id<VT100RemoteHostReading>)remoteHost\n                                  withDirectory:(NSString *)directory\n                                       pushType:(VT100ScreenWorkingDirectoryPushType)pushType\n                                       accepted:(BOOL)accepted {\n    DLog(@\"screenLogWorkingDirectoryOnscreenLogWorkingDirectoryOnAbsoluteLine:%@ remoteHost:%@ withDirectory:%@ pushType:%@ accepted:%@\",\n         @(absLine), remoteHost, directory, @(pushType), @(accepted));\n\n    DLog(@\"Accepted=%@\", @(accepted));\n\n    const BOOL pushed = (pushType != VT100ScreenWorkingDirectoryPushTypePull);\n    if (pushed && accepted) {\n        // If we're currently polling for a working directory, do not create a\n        // mark for the result when the poll completes because this mark is\n        // from a higher-quality data source.\n        DLog(@\"Invalidate outstanding PWD poller requests.\");\n        [_pwdPoller invalidateOutstandingRequests];\n    }\n\n    // Update shell integration DB.\n    DLog(@\"remoteHost is %@, is local is %@\", remoteHost, @(!remoteHost.isLocalhost));\n    if (pushed) {\n        BOOL isSame = ([directory isEqualToString:_lastDirectory] &&\n                       [remoteHost isEqualToRemoteHost:_lastRemoteHost]);\n        [[iTermShellHistoryController sharedInstance] recordUseOfPath:directory\n                                                               onHost:remoteHost\n                                                             isChange:!isSame];\n    }\n    if (accepted) {\n        // This has been a big ugly hairball for a long time. Because of the\n        // working directory poller I think it's safe to simplify it now. Before,\n        // we'd track whether the update was trustworthy and likely to happen\n        // again. These days, it should always be regular so that is not\n        // interesting. Instead, we just want to make sure we know if the directory\n        // is local or remote because we want to ignore local directories when we\n        // know the user is ssh'ed somewhere.\n        const BOOL directoryIsRemote = (pushType == VT100ScreenWorkingDirectoryPushTypeStrongPush) && remoteHost && !remoteHost.isLocalhost;\n\n        // Update lastDirectory, lastLocalDirectory (maybe), proxy icon, \"path\" variable.\n        [self setLastDirectory:directory remote:directoryIsRemote pushed:pushed];\n        if (pushed) {\n            self.lastRemoteHost = remoteHost;\n        }\n    }\n}\n\n- (BOOL)screenAllowTitleSetting {\n    NSNumber *n = _profile[KEY_ALLOW_TITLE_SETTING];\n    if (!n) {\n        return YES;\n    } else {\n        return [n boolValue];\n    }\n}\n\n- (void)didUpdateCurrentDirectory:(NSString *)newPath {\n    _shouldExpectCurrentDirUpdates = YES;\n    _conductor.currentDirectory = newPath;\n}\n\n- (NSString *)shellIntegrationUpgradeUserDefaultsKeyForHost:(id<VT100RemoteHostReading>)host {\n    return [NSString stringWithFormat:@\"SuppressShellIntegrationUpgradeAnnouncementForHost_%@@%@\",\n            host.username, host.hostname];\n}\n\n- (void)tryToRunShellIntegrationInstallerWithPromptCheck:(BOOL)promptCheck {\n    if (_exited) {\n        return;\n    }\n    NSString *currentCommand = [self currentCommand];\n    if (!promptCheck || currentCommand != nil) {\n        [_textview installShellIntegration:nil];\n    } else {\n        iTermWarningSelection selection =\n        [iTermWarning showWarningWithTitle:@\"It looks like you're not at a command prompt.\"\n                                   actions:@[ @\"Run Installer Anyway\", @\"Cancel\" ]\n                                identifier:nil\n                               silenceable:kiTermWarningTypePersistent\n                                    window:self.view.window];\n        switch (selection) {\n            case kiTermWarningSelection0:\n                [_textview installShellIntegration:nil];\n                break;\n\n            default:\n                break;\n        }\n    }\n}\n\n- (void)screenDidDetectShell:(NSString *)shell {\n    NSString *name = self.currentHost.usernameAndHostname;\n    if (name && shell) {\n        self.hostnameToShell[name] = shell;\n    }\n    if (shell) {\n        [self.variablesScope setValue:shell forVariableNamed:iTermVariableKeyShell];\n    }\n}\n\n- (NSString *)bestGuessAtUserShell {\n    return [[self.variablesScope valueForVariableName:iTermVariableKeyShell] lastPathComponent] ?: [[iTermOpenDirectory userShell] lastPathComponent] ?: @\"zsh\";\n}\n\n- (NSString *)bestGuessAtUName {\n    NSString *name = self.currentHost.usernameAndHostname;\n    NSString *unameString = nil;\n    if (name) {\n        unameString = _conductor.uname;\n    }\n    if (!unameString) {\n        struct utsname utsname = { 0 };\n        if (uname(&utsname)) {\n            return @\"Darwin\";\n        }\n        unameString = [NSString stringWithFormat:@\"%s %s %s %s %s\",\n                       utsname.sysname,\n                       utsname.nodename,\n                       utsname.release,\n                       utsname.version,\n                       utsname.machine];\n    }\n    return unameString;\n}\n\n- (void)screenSuggestShellIntegrationUpgrade {\n    id<VT100RemoteHostReading> currentRemoteHost = [self currentHost];\n\n    NSString *theKey = [self shellIntegrationUpgradeUserDefaultsKeyForHost:currentRemoteHost];\n    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];\n    if ([userDefaults boolForKey:theKey]) {\n        return;\n    }\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:@\"This account\u2019s Shell Integration scripts are out of date.\"\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"Upgrade\", @\"Silence Warning\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case -2:  // Dismiss programmatically\n                break;\n\n            case -1: // No\n                break;\n\n            case 0: // Yes\n                [self tryToRunShellIntegrationInstallerWithPromptCheck:YES];\n                break;\n\n            case 1: // Never for this account\n                [userDefaults setBool:YES forKey:theKey];\n                break;\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:kShellIntegrationOutOfDateAnnouncementIdentifier];\n}\n\n- (BOOL)screenShouldReduceFlicker {\n    return [iTermProfilePreferences boolForKey:KEY_REDUCE_FLICKER inProfile:self.profile];\n}\n\n- (NSInteger)screenUnicodeVersion {\n    return _unicodeVersion;\n}\n\n- (void)screenSetUnicodeVersion:(NSInteger)unicodeVersion {\n    if (unicodeVersion == 0) {\n        // Set to default value\n        unicodeVersion = [[iTermProfilePreferences defaultObjectForKey:KEY_UNICODE_VERSION] integerValue];\n    }\n    if (unicodeVersion >= kMinimumUnicodeVersion &&\n        unicodeVersion <= kMaximumUnicodeVersion &&\n        unicodeVersion != [iTermProfilePreferences integerForKey:KEY_UNICODE_VERSION inProfile:self.profile]) {\n        [self setSessionSpecificProfileValues:@{ KEY_UNICODE_VERSION: @(unicodeVersion) }];\n    }\n}\n\n- (void)updateStatusChangedLine {\n    _statusChangedAbsLine = _screen.cursorY - 1 + _screen.numberOfScrollbackLines + _screen.totalScrollbackOverflow;\n}\n\n- (void)restoreKeyLabels:(NSDictionary *)labels updateStatusChangedLine:(BOOL)updateStatusChangedLine {\n    if (labels.count == 0) {\n        return;\n    }\n    if (!_keyLabels) {\n        _keyLabels = [[NSMutableDictionary alloc] init];\n    }\n    [labels enumerateKeysAndObjectsUsingBlock:^(NSString *_Nonnull name, NSString *_Nonnull value, BOOL * _Nonnull stop) {\n        if (value.length == 0) {\n            return;\n        }\n        _keyLabels[name] = [[value copy] autorelease];\n        if ([name isEqualToString:@\"status\"] && updateStatusChangedLine) {\n            [self updateStatusChangedLine];\n        }\n    }];\n}\n\n- (void)screenSetLabel:(NSString *)label forKey:(NSString *)keyName {\n    if (!_keyLabels) {\n        _keyLabels = [[NSMutableDictionary alloc] init];\n    }\n    const BOOL changed = ![_keyLabels[keyName] isEqualToString:label];\n    if (label.length == 0) {\n        [_keyLabels removeObjectForKey:keyName];\n    } else {\n        _keyLabels[keyName] = [[label copy] autorelease];\n    }\n    if ([keyName isEqualToString:@\"status\"] && changed) {\n        [self updateStatusChangedLine];\n    }\n    [_delegate sessionKeyLabelsDidChange:self];\n}\n\n- (void)screenPushKeyLabels:(NSString *)value {\n    if (!_keyLabels) {\n        return;\n    }\n    if (!_keyLabelsStack) {\n        _keyLabelsStack = [[NSMutableArray alloc] init];\n    }\n    iTermKeyLabels *labels = [[[iTermKeyLabels alloc] init] autorelease];\n    labels.name = value;\n    labels.map = [_keyLabels.mutableCopy autorelease];\n    [_keyLabelsStack addObject:labels];\n\n    if (![value hasPrefix:@\".\"]) {\n        [_keyLabels removeAllObjects];\n    }\n    [_delegate sessionKeyLabelsDidChange:self];\n}\n\n- (iTermKeyLabels *)popKeyLabels {\n    iTermKeyLabels *labels = [[_keyLabelsStack.lastObject retain] autorelease];\n    [_keyLabelsStack removeLastObject];\n    return labels;\n}\n\n- (void)screenPopKeyLabels:(NSString *)value {\n    [_keyLabels release];\n    _keyLabels = nil;\n    iTermKeyLabels *labels = [self popKeyLabels];\n    while (labels && value.length > 0 && ![labels.name isEqualToString:value]) {\n        labels = [self popKeyLabels];\n    }\n    _keyLabels = [labels.map mutableCopy];\n    [_delegate sessionKeyLabelsDidChange:self];\n}\n\n- (void)screenSendModifiersDidChange {\n    const BOOL allowed = [iTermProfilePreferences boolForKey:KEY_ALLOW_MODIFY_OTHER_KEYS\n                                                   inProfile:self.profile];\n    if (!allowed) {\n        return;\n    }\n    const int modifyOtherKeysMode = _screen.terminalSendModifiers[4].intValue;\n    if (modifyOtherKeysMode == 1) {\n        self.keyMappingMode = iTermKeyMappingModeModifyOtherKeys1;\n    } else if (modifyOtherKeysMode == 2) {\n        self.keyMappingMode = iTermKeyMappingModeModifyOtherKeys2;\n    } else {\n        self.keyMappingMode = iTermKeyMappingModeStandard;\n    }\n}\n\n- (void)screenKeyReportingFlagsDidChange {\n    if (_screen.terminalKeyReportingFlags & VT100TerminalKeyReportingFlagsDisambiguateEscape) {\n        self.keyMappingMode = iTermKeyMappingModeCSIu;\n    } else {\n        self.keyMappingMode = iTermKeyMappingModeStandard;\n    }\n}\n\n- (void)screenTerminalAttemptedPasteboardAccess {\n    [self.textview didCopyToPasteboardWithControlSequence];\n    if ([iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal]) {\n        return;\n    }\n    if ([iTermAdvancedSettingsModel noSyncSuppressClipboardAccessDeniedWarning]) {\n        return;\n    }\n    NSString *identifier = @\"ClipboardAccessDenied\";\n    if ([self hasAnnouncementWithIdentifier:identifier]) {\n        return;\n    }\n    NSString *notice = @\"The terminal attempted to access the clipboard but it was denied. Enable clipboard access in \u201cPrefs > General > Selection > Applications in terminal may access clipboard\u201d.\";\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:notice\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"_Open Prefs\", @\"Don't Show This Again\" ]\n                                                completion:^(int selection) {\n        if (selection == 0) {\n            [[PreferencePanel sharedInstance] openToPreferenceWithKey:kPreferenceKeyAllowClipboardAccessFromTerminal];\n        } else if (selection == 1) {\n            [iTermAdvancedSettingsModel setNoSyncSuppressClipboardAccessDeniedWarning:YES];\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:identifier];\n}\n\n- (NSString *)stringValueOfVariable:(NSString *)name {\n    if (!name) {\n        return nil;\n    }\n    id value = [self.variablesScope valueForVariableName:name];\n    if ([NSString castFrom:value]) {\n        return value;\n    } else if ([value respondsToSelector:@selector(stringValue)]) {\n        return [value stringValue];\n    } else {\n        return nil;\n    }\n}\n\n- (void)screenReportFocusWillChangeTo:(BOOL)reportFocus {\n    [self dismissAnnouncementWithIdentifier:kTurnOffFocusReportingOnHostChangeAnnouncementIdentifier];\n}\n\n- (void)screenReportPasteBracketingWillChangeTo:(BOOL)bracket {\n    [self dismissAnnouncementWithIdentifier:kTurnOffBracketedPasteOnHostChangeAnnouncementIdentifier];\n}\n\n- (void)screenDidReceiveLineFeed {\n    [self publishNewline];\n    [_pwdPoller didReceiveLineFeed];\n    if (_logging.enabled && !self.isTmuxGateway) {\n        switch (_logging.style) {\n            case iTermLoggingStyleRaw:\n            case iTermLoggingStyleAsciicast:\n                break;\n            case iTermLoggingStyleHTML:\n                [_logging logNewline:[@\"<br/>\\n\" dataUsingEncoding:_screen.terminalEncoding]];\n                break;\n            case iTermLoggingStylePlainText:\n                [_logging logNewline:nil];\n                break;\n        }\n    }\n}\n\n- (void)screenSoftAlternateScreenModeDidChangeTo:(BOOL)enabled\n                                showingAltScreen:(BOOL)showing {\n    [self.processInfoProvider setNeedsUpdate:YES];\n    [self.tmuxForegroundJobMonitor updateOnce];\n    [self.variablesScope setValue:@(showing)\n                 forVariableNamed:iTermVariableKeySessionShowingAlternateScreen];\n}\n\n- (void)screenReportKeyUpDidChange:(BOOL)reportKeyUp {\n    if (reportKeyUp) {\n        self.keyMappingMode = iTermKeyMappingModeRaw;\n    } else {\n        self.keyMappingMode = iTermKeyMappingModeStandard;\n    }\n}\n\n#pragma mark - Announcements\n\n- (BOOL)hasAnnouncementWithIdentifier:(NSString *)identifier {\n    return _announcements[identifier] != nil;\n}\n\n- (void)dismissAnnouncementWithIdentifier:(NSString *)identifier {\n    iTermAnnouncementViewController *announcement = _announcements[identifier];\n    [announcement dismiss];\n}\n\n- (void)queueAnnouncement:(iTermAnnouncementViewController *)announcement\n               identifier:(NSString *)identifier {\n    DLog(@\"Enqueue announcement with identifier %@\", identifier);\n    [self dismissAnnouncementWithIdentifier:identifier];\n\n    _announcements[identifier] = announcement;\n\n    void (^originalCompletion)(int) = [announcement.completion copy];\n    NSString *identifierCopy = [identifier copy];\n    __weak __typeof(self) weakSelf = self;\n    announcement.completion = ^(int selection) {\n        originalCompletion(selection);\n        if (selection == -2) {\n            [weakSelf removeAnnouncementWithIdentifier:identifierCopy];\n            [identifierCopy release];\n            [originalCompletion release];\n        }\n    };\n    [_view addAnnouncement:announcement];\n}\n\n- (void)removeAnnouncementWithIdentifier:(NSString *)identifier {\n    [_announcements removeObjectForKey:identifier];\n}\n\n- (iTermAnnouncementViewController *)announcementWithIdentifier:(NSString *)identifier {\n    return _announcements[identifier];\n}\n\n#pragma mark - PopupDelegate\n\n- (BOOL)popupShouldTakePrefixFromScreen {\n    return _textview.window.firstResponder == _textview;\n}\n\n// If the cursor is preceded by whitespace the last word will be empty. Words go in reverse order.\n- (NSArray<NSString *> *)popupWordsBeforeInsertionPoint:(int)count {\n    id<iTermPopupWindowHosting> host = [self popupHost];\n    return [host wordsBeforeInsertionPoint:count] ?: @[@\"\"];\n}\n\n- (void)popupIsSearching:(BOOL)searching {\n    _textview.showSearchingCursor = searching;\n    [_textview setNeedsDisplayInRect:_textview.cursorFrame];\n}\n\n- (void)popupWillClose:(iTermPopupWindowController *)popup {\n    [[_delegate realParentWindow] popupWillClose:popup];\n}\n\n- (NSRect)popupScreenVisibleFrame {\n    return [[[[_delegate realParentWindow] window] screen] visibleFrame];\n}\n\n- (BOOL)popupWindowIsInFloatingHotkeyWindow {\n    return _delegate.realParentWindow.isFloatingHotKeyWindow;\n}\n\n- (BOOL)screenConfirmDownloadNamed:(NSString *)name canExceedSize:(NSInteger)limit {\n    NSString *identifier = @\"NoSyncAllowBigDownload\";\n    const iTermWarningSelection selection =\n    [iTermWarning showWarningWithTitle:[NSString stringWithFormat:@\"The download \u201c%@\u201d is larger than %@. Continue?\", name, [NSString it_formatBytes:limit]]\n                               actions:@[ @\"Allow\", @\"Deny\" ]\n                             accessory:nil\n                            identifier:identifier\n                           silenceable:kiTermWarningTypePermanentlySilenceable\n                               heading:@\"Allow Large File Download?\"\n                                window:_view.window];\n    return selection == kiTermWarningSelection0;\n}\n\n- (BOOL)screenConfirmDownloadAllowed:(NSString *)name\n                                size:(NSInteger)size\n                       displayInline:(BOOL)displayInline\n                         promptIfBig:(BOOL *)promptIfBig {\n    NSString *identifier = @\"NoSyncSuppressDownloadConfirmation\";\n    *promptIfBig = YES;\n    const BOOL wasSilenced = [iTermWarning identifierIsSilenced:identifier];\n    NSString *title;\n    NSString *heading;\n    if (displayInline) {\n        title = [NSString stringWithFormat:@\"The terminal has initiated display of a file named \u201c%@\u201d of size %@. Allow it?\",\n                 name, [NSString it_formatBytes:size]];\n        heading = @\"Allow Terminal-Initiated Display?\";\n    } else {\n        title = [NSString stringWithFormat:@\"The terminal has initiated transfer of a file named \u201c%@\u201d of size %@. Download it?\",\n                 name, [NSString it_formatBytes:size]];\n        heading = @\"Allow Terminal-Initiated Download?\";\n    }\n    const iTermWarningSelection selection =\n    [iTermWarning showWarningWithTitle:title\n                               actions:@[ @\"Yes\", @\"No\" ]\n                             accessory:nil\n                            identifier:identifier\n                           silenceable:kiTermWarningTypePermanentlySilenceable\n                               heading:heading\n                                window:_view.window];\n    const BOOL allow = (selection == kiTermWarningSelection0);\n    DLog(@\"allow=%@\", @(allow));\n    if (allow && wasSilenced) {\n        if (size > VT100ScreenBigFileDownloadThreshold) {\n            *promptIfBig = NO;\n            return [self screenConfirmDownloadNamed:name canExceedSize:VT100ScreenBigFileDownloadThreshold];\n        }\n    }\n    return allow;\n}\n\n- (BOOL)clearScrollbackAllowed {\n    if (self.naggingController.shouldAskAboutClearingScrollbackHistory) {\n        return NO;\n    }\n    const BOOL *boolPtr = iTermAdvancedSettingsModel.preventEscapeSequenceFromClearingHistory;\n    if (!boolPtr) {\n        return NO;\n    }\n    return !*boolPtr;\n}\n\n- (void)screenAskAboutClearingScrollback {\n    if (self.naggingController.shouldAskAboutClearingScrollbackHistory) {\n        [self.naggingController askAboutClearingScrollbackHistory];\n    }\n}\n\n- (void)screenDidResize {\n    DLog(@\"screenDidResize\");\n    [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionDidResizeNotification\n                                                        object:self];\n    [self.delegate sessionDidResize:self];\n}\n\n- (void)screenDidAppendImageData:(NSData *)data {\n    if (!_logging.enabled) {\n        return;\n    }\n    if (self.isTmuxGateway) {\n        return;\n    }\n    switch (_logging.style) {\n        case iTermLoggingStyleRaw:\n        case iTermLoggingStylePlainText:\n        case iTermLoggingStyleAsciicast:\n            break;\n        case iTermLoggingStyleHTML:\n            [_logging logData:[data inlineHTMLData]];\n            break;\n    }\n}\n\n- (void)screenAppendScreenCharArray:(ScreenCharArray *)sca\n                           metadata:(iTermImmutableMetadata)metadata {\n    [self publishScreenCharArray:sca metadata:metadata];\n}\n\n- (NSString *)screenStringForKeypressWithCode:(unsigned short)keycode\n                                        flags:(NSEventModifierFlags)flags\n                                   characters:(NSString *)characters\n                  charactersIgnoringModifiers:(NSString *)charactersIgnoringModifiers {\n    return [self stringForKeyCode:keycode flags:flags characters:characters charactersIgnoringModifiers:charactersIgnoringModifiers];\n}\n\n- (NSString *)stringForKeyCode:(unsigned short)keycode\n                         flags:(NSEventModifierFlags)flags\n                    characters:(NSString *)characters\n   charactersIgnoringModifiers:(NSString *)charactersIgnoringModifiers {\n    NSEvent *event = [NSEvent keyEventWithType:NSEventTypeKeyDown\n                                      location:NSZeroPoint\n                                 modifierFlags:flags\n                                     timestamp:0\n                                  windowNumber:self.view.window.windowNumber\n                                       context:nil\n                                    characters:characters\n                   charactersIgnoringModifiers:charactersIgnoringModifiers\n                                     isARepeat:NO\n                                       keyCode:keycode];\n    return [_textview.keyboardHandler stringForEventWithoutSideEffects:event\n                                                              encoding:_screen.terminalEncoding ?: NSUTF8StringEncoding];\n}\n\n- (void)screenApplicationKeypadModeDidChange:(BOOL)mode {\n    self.variablesScope.applicationKeypad = mode;\n}\n\n- (void)screenRestoreColorsFromSlot:(VT100SavedColorsSlot *)slot {\n    const BOOL dark = _screen.colorMap.darkMode;\n    NSMutableDictionary *dict = [[@{ iTermAmendedColorKey(KEY_FOREGROUND_COLOR, _profile, dark): slot.text.dictionaryValue,\n                                     iTermAmendedColorKey(KEY_BACKGROUND_COLOR, _profile, dark): slot.background.dictionaryValue,\n                                     iTermAmendedColorKey(KEY_SELECTED_TEXT_COLOR, _profile, dark): slot.selectionText.dictionaryValue,\n                                     iTermAmendedColorKey(KEY_SELECTION_COLOR, _profile, dark): slot.selectionBackground.dictionaryValue } mutableCopy] autorelease];\n    for (int i = 0; i < MIN(kColorMapNumberOf8BitColors, slot.indexedColors.count); i++) {\n        if (i < 16) {\n            NSString *baseKey = [NSString stringWithFormat:KEYTEMPLATE_ANSI_X_COLOR, i];\n            NSString *profileKey = iTermAmendedColorKey(baseKey, _profile, dark);\n            dict[profileKey] = [slot.indexedColors[i] dictionaryValue];\n        }\n    }\n    [self setSessionSpecificProfileValues:dict];\n}\n\n- (void)screenCopyStringToPasteboard:(NSString *)string {\n    [self screenTerminalAttemptedPasteboardAccess];\n    // check the configuration\n    if (![iTermPreferences boolForKey:kPreferenceKeyAllowClipboardAccessFromTerminal]) {\n        return;\n    }\n\n    // set the result to paste board.\n    NSPasteboard *thePasteboard = [NSPasteboard generalPasteboard];\n    [thePasteboard clearContents];\n    [thePasteboard declareTypes:@[ NSPasteboardTypeString ] owner:nil];\n    [thePasteboard setString:string forType:NSPasteboardTypeString];\n}\n\n- (void)screenReportPasteboard:(NSString *)pasteboard completion:(void (^)(void))completion {\n    if (!_pasteboardReporter) {\n        _pasteboardReporter = [[iTermPasteboardReporter alloc] init];\n        _pasteboardReporter.delegate = self;\n    }\n    [_pasteboardReporter handleRequestWithPasteboard:pasteboard completion:completion];\n}\n\n- (void)screenOfferToDisableTriggersInInteractiveApps {\n    [self.naggingController offerToDisableTriggersInInteractiveApps];\n}\n\n- (void)screenDidUpdateReturnCodeForMark:(id<VT100ScreenMarkReading>)mark\n                              remoteHost:(id<VT100RemoteHostReading>)remoteHost {\n    [[iTermShellHistoryController sharedInstance] setStatusOfCommandAtMark:mark\n                                                                    onHost:remoteHost\n                                                                        to:mark.code];\n    [self screenNeedsRedraw];\n}\n\n- (void)screenPostUserNotification:(NSString * _Nonnull)message rich:(BOOL)rich {\n    if (![self shouldPostTerminalGeneratedAlert]) {\n        DLog(@\"Declining to allow terminal to post user notification %@\", message);\n        return;\n    }\n    DLog(@\"Terminal posting user notification %@\", message);\n    [self incrementBadge];\n\n    iTermNotificationController* controller = [iTermNotificationController sharedInstance];\n\n    if (rich) {\n        NSDictionary<NSString *, NSString *> *dict = [[message it_keyValuePairsSeparatedBy:@\";\"] mapValuesWithBlock:^id(NSString *key, NSString *encoded) {\n            return [encoded stringByBase64DecodingStringWithEncoding:NSUTF8StringEncoding];\n        }];\n        NSString *description = dict[@\"message\"] ?: @\"\";\n        NSString *title = dict[@\"title\"];\n        NSString *subtitle = dict[@\"subtitle\"];\n        NSString *image = [dict[@\"image\"] stringByTrimmingTrailingCharactersFromCharacterSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];\n\n        [controller notifyRich:title\n                  withSubtitle:subtitle\n               withDescription:description\n                     withImage:image\n                   windowIndex:[self screenWindowIndex]\n                      tabIndex:[self screenTabIndex]\n                     viewIndex:[self screenViewIndex]];\n    } else {\n        NSString *description = [NSString stringWithFormat:@\"Session %@ #%d: %@\",\n                                 [[self name] removingHTMLFromTabTitleIfNeeded],\n                                 [_delegate tabNumber],\n                                 message];\n        [controller notify:@\"Alert\"\n           withDescription:description\n               windowIndex:[self screenWindowIndex]\n                  tabIndex:[self screenTabIndex]\n                 viewIndex:[self screenViewIndex]];\n    }\n}\n\n- (void)screenUpdateCommandUseWithGuid:(NSString *)screenmarkGuid\n                                onHost:(id<VT100RemoteHostReading>)lastRemoteHost\n                         toReferToMark:(id<VT100ScreenMarkReading>)screenMark {\n    iTermCommandHistoryCommandUseMO *commandUse =\n    [[iTermShellHistoryController sharedInstance] commandUseWithMarkGuid:screenMark.guid\n                                                                  onHost:lastRemoteHost];\n    commandUse.mark = screenMark;\n}\n\n- (void)screenExecutorDidUpdate:(VT100ScreenTokenExecutorUpdate *)update {\n    _estimatedThroughput = update.estimatedThroughput;\n    DLog(@\"estimated throughput: %@\", @(_estimatedThroughput));\n\n    if (update.numberOfBytesExecuted > 0) {\n        DLog(@\"Session %@ (%@) is processing\", self, _nameController.presentationSessionTitle);\n        if (![self haveResizedRecently]) {\n            _lastOutputIgnoringOutputAfterResizing = [NSDate timeIntervalSinceReferenceDate];\n        }\n        _newOutput = YES;\n\n        // Make sure the screen gets redrawn soonish\n        self.active = YES;\n\n        if (self.shell.pid > 0 || [[[self variablesScope] valueForVariableName:@\"jobName\"] length] > 0) {\n            [self.processInfoProvider setNeedsUpdate:YES];\n        }\n    }\n\n    [_cadenceController didHandleInputWithThroughput:_estimatedThroughput];\n}\n\n- (void)screenConvertAbsoluteRange:(VT100GridAbsCoordRange)range\n              toTextDocumentOfType:(NSString *)type\n                          filename:(NSString *)filename\n                         forceWide:(BOOL)forceWide {\n    [_textview renderRange:range type:type filename:filename forceWide:forceWide];\n}\n\n- (void)screenDidHookSSHConductorWithToken:(NSString *)token\n                                  uniqueID:(NSString *)uniqueID\n                                  boolArgs:(NSString *)boolArgs\n                                   sshargs:(NSString *)sshargs\n                                     dcsID:(NSString * _Nonnull)dcsID\n                                savedState:(NSDictionary *)savedState {\n    BOOL localOrigin = NO;\n    if ([[iTermSecretServer instance] check:token]) {\n        localOrigin = YES;\n    }\n\n    NSString *directory = nil;\n    if (_sshState == iTermSSHStateProfile && !_conductor) {\n        // Currently launching the session that has ssh instead of login shell.\n        directory = self.environment[@\"PWD\"];\n    }\n    if (_pendingJumps.count) {\n        directory = _pendingJumps[0].initialDirectory;\n        [_pendingJumps removeObjectAtIndex:0];\n    }\n    iTermConductor *previousConductor = [_conductor autorelease];\n    NSDictionary *dict = [NSDictionary castFrom:[iTermProfilePreferences objectForKey:KEY_SSH_CONFIG inProfile:self.profile]];\n    const BOOL shouldInjectShellIntegration = [iTermProfilePreferences boolForKey:KEY_LOAD_SHELL_INTEGRATION_AUTOMATICALLY inProfile:self.profile];\n    iTermSSHConfiguration *config = [[[iTermSSHConfiguration alloc] initWithDictionary:dict] autorelease];\n    _conductor = [[iTermConductor alloc] init:sshargs\n                                     boolArgs:boolArgs\n                                        dcsID:dcsID\n                               clientUniqueID:uniqueID\n                                   varsToSend:localOrigin ? [self.screen exfiltratedEnvironmentVariables:config.environmentVariablesToCopy] : @{}\n                                   clientVars:[self.screen exfiltratedEnvironmentVariables:nil] ?: @{}\n                             initialDirectory:directory\n                 shouldInjectShellIntegration:shouldInjectShellIntegration\n                                       parent:previousConductor];\n    _conductor.terminalConfiguration = savedState;\n    if (localOrigin) {\n        for (iTermTuple<NSString *, NSString *> *tuple in config.filesToCopy) {\n            [_conductor addPath:tuple.firstObject destination:tuple.secondObject];\n        }\n    }\n    _sshState = iTermSSHStateNone;\n    _conductor.delegate = self;\n    NSArray<iTermSSHReconnectionInfo *> *jumps = _pendingJumps;\n    if (!previousConductor && jumps.count) {\n        [_conductor startJumpingTo:jumps];\n    } else if (previousConductor.subsequentJumps.count) {\n        [_conductor startJumpingTo:previousConductor.subsequentJumps];\n        [previousConductor childDidBeginJumping];\n    } else {\n        [_conductor start];\n    }\n    [self updateVariablesFromConductor];\n}\n\n- (void)screenDidReadSSHConductorLine:(NSString *)string depth:(int)depth {\n    [_conductor handleLine:string depth:depth];\n}\n\n- (void)screenDidUnhookSSHConductor {\n    [_conductor handleUnhook];\n    [self writeData:_sshWriteQueue];\n    [_sshWriteQueue release];\n    _sshWriteQueue = nil;\n}\n\n- (void)unhookSSHConductor {\n    DLog(@\"Unhook %@\", _conductor);\n    [self conductorWillDie];\n    NSDictionary *config = _conductor.terminalConfiguration;\n    if (config) {\n        [_screen restoreSavedState:config];\n    }\n    _conductor.delegate = nil;\n    [_conductor autorelease];\n    _conductor = [_conductor.parent retain];\n    _conductor.delegate = self;\n    [self updateVariablesFromConductor];\n}\n\n- (void)screenDidBeginSSHConductorCommandWithIdentifier:(NSString *)identifier\n                                                  depth:(int)depth {\n    [_conductor handleCommandBeginWithIdentifier:identifier depth:depth];\n}\n\n- (void)screenDidEndSSHConductorCommandWithIdentifier:(NSString *)identifier\n                                                 type:(NSString *)type\n                                               status:(uint8_t)status\n                                                depth:(int)depth {\n    [_conductor handleCommandEndWithIdentifier:identifier\n                                          type:type\n                                        status:status\n                                         depth:depth];\n}\n\n- (void)screenHandleSSHSideChannelOutput:(NSString *)string\n                                     pid:(int32_t)pid\n                                 channel:(uint8_t)channel\n                                   depth:(int)depth {\n    [_conductor handleSideChannelOutput:string pid:pid channel:channel depth:depth];\n}\n\n- (void)screenDidTerminateSSHProcess:(int)pid code:(int)code depth:(int)depth {\n    [_conductor handleTerminatePID:pid withCode:code depth:depth];\n}\n\n- (NSInteger)screenEndSSH:(NSString *)uniqueID {\n    DLog(@\"%@\", uniqueID);\n    if (![_conductor ancestryContainsClientUniqueID:uniqueID]) {\n        DLog(@\"Ancestry does not contain this unique ID\");\n        return 0;\n    }\n    BOOL found = NO;\n    NSInteger count = 0;\n    while (_conductor != nil && !found) {\n        found = [_conductor.clientUniqueID isEqual:uniqueID];\n        count += 1;\n        [self unhookSSHConductor];\n    }\n    // it2ssh waits for a newline before exiting. This is in case ssh dies while iTerm2 is sending\n    // conductor.sh.\n    [self writeTaskNoBroadcast:@\"\\n\"];\n    return count;\n}\n\n- (void)screenBeginSSHIntegrationWithToken:(NSString *)token\n                                  uniqueID:(NSString *)uniqueID\n                                 encodedBA:(NSString *)encodedBA\n                                   sshArgs:(NSString *)sshArgs {\n    NSURL *path = [[NSBundle bundleForClass:[PTYSession class]] URLForResource:@\"conductor\" withExtension:@\"sh\"];\n    NSString *conductorSH = [NSString stringWithContentsOfURL:path encoding:NSUTF8StringEncoding error:nil];\n    // Ensure it doesn't contain empty lines.\n    conductorSH = [conductorSH stringByReplacingOccurrencesOfString:@\"\\n\\n\" withString:@\"\\n \\n\"];\n\n    [self writeTaskNoBroadcast:conductorSH];\n    [self writeTaskNoBroadcast:[NSString stringWithFormat:@\"main %@ %@ %@ %@\\n\",\n                                [token base64EncodedWithEncoding:NSUTF8StringEncoding],\n                                [uniqueID base64EncodedWithEncoding:NSUTF8StringEncoding],\n                                [encodedBA base64EncodedWithEncoding:NSUTF8StringEncoding],\n                                [sshArgs base64EncodedWithEncoding:NSUTF8StringEncoding]]];\n    [self writeTaskNoBroadcast:@\"EOF\\n\"];\n}\n\n- (NSString *)screenSSHLocation {\n    return _conductor.sshIdentity.compactDescription;\n}\n\n- (void)screenBeginFramerRecovery:(int)parentDepth {\n    if (parentDepth < 0) {\n        while (_conductor) {\n            [self unhookSSHConductor];\n        }\n    }\n    iTermConductor *previousConductor = [_conductor autorelease];\n    _conductor = [[iTermConductor alloc] init:@\"\"\n                                     boolArgs:@\"\"\n                                        dcsID:@\"\"\n                               clientUniqueID:@\"\"\n                                   varsToSend:@{}\n                                   clientVars:@{}\n                             initialDirectory:nil\n                 shouldInjectShellIntegration:NO\n                                       parent:previousConductor];\n    [self updateVariablesFromConductor];\n    _conductor.delegate = self;\n    [_conductor startRecovery];\n}\n\n- (iTermConductorRecovery *)screenHandleFramerRecoveryString:(NSString * _Nonnull)string {\n    iTermConductorRecovery *recovery = [_conductor handleRecoveryLine:string];\n    if (!recovery) {\n        return nil;\n    }\n    _conductor.delegate = nil;\n    [_conductor autorelease];\n    _conductor = [[iTermConductor alloc] initWithRecovery:recovery];\n    _conductor.delegate = self;\n    [self updateVariablesFromConductor];\n    return recovery;\n}\n\n// This is the final step of recovery. We need to reset the internal state of the conductors since\n// some tokens may have been dropped during recovery.\n- (void)screenDidResynchronizeSSH {\n    [_conductor didResynchronize];\n}\n\n- (void)screenFramerRecoveryDidFinish {\n    [_conductor recoveryDidFinish];\n}\n\n- (void)screenEnsureDefaultMode {\n    [self resetMode];\n}\n\n- (void)resetMode {\n    _modeHandler.mode = iTermSessionModeDefault;\n}\n\n- (void)screenOpenURL:(NSURL *)url completion:(void (^)(void))completion {\n    DLog(@\"url=%@\", url);\n    [self.naggingController openURL:url];\n    completion();\n}\n\n- (void)enclosingTabWillBeDeselected {\n    DLog(@\"enclosingTabWillBeDeselected %@\", self);\n    if (_alertOnMarksinOffscreenSessions) {\n        [self sync];\n    }\n}\n\n- (void)enclosingTabDidBecomeSelected {\n    DLog(@\"enclosingTabDidBecomeSelected %@\", self);\n    if (_alertOnMarksinOffscreenSessions) {\n        [self sync];\n    }\n}\n\n- (BOOL)popupWindowShouldAvoidChangingWindowOrderOnClose {\n    return [iTermPreferences boolForKey:kPreferenceKeyFocusFollowsMouse] && ![self.delegate sessionBelongsToHotkeyWindow:self];\n}\n\n- (VT100Screen *)popupVT100Screen {\n    return _screen;\n}\n\n- (id<iTermPopupWindowPresenter>)popupPresenter {\n    return self;\n}\n\n- (void)popupInsertText:(NSString *)string {\n    id<iTermPopupWindowHosting> host = [self popupHost];\n    if (host) {\n        [host popupWindowHostingInsertText:string];\n        return;\n    }\n    if (_composerManager.dropDownComposerViewIsVisible) {\n        [_composerManager insertText:string];\n        return;\n    }\n    [self insertText:string];\n}\n\n- (void)popupPreview:(NSString *)text {\n    id<iTermPopupWindowHosting> host = [self popupHost];\n    if (host) {\n        [host popupWindowHostSetPreview:[[text firstNonEmptyLine] truncatedToLength:_screen.width ellipsis:@\"\u2026\"]];\n        return;\n    }\n}\n\n- (void)popupKeyDown:(NSEvent *)event {\n    [_textview keyDown:event];\n}\n\n- (BOOL)composerCommandHistoryIsOpen {\n    if (!_composerManager.dropDownComposerViewIsVisible) {\n        return NO;\n    }\n    return [[_delegate realParentWindow] commandHistoryIsOpenForSession:self];\n}\n\n- (BOOL)popupHandleSelector:(SEL)selector\n                     string:(NSString *)string\n               currentValue:(NSString *)currentValue {\n    if ([self composerCommandHistoryIsOpen]) {\n        if (selector == @selector(deleteBackward:)) {\n            [[_delegate realParentWindow] closeCommandHistory];\n            [_composerManager deleteLastCharacter];\n            return YES;\n        }\n        return NO;\n    }\n    if (![[_delegate realParentWindow] autoCommandHistoryIsOpenForSession:self]) {\n        return NO;\n    }\n    if (selector == @selector(cancel:)) {\n        [[_delegate realParentWindow] hideAutoCommandHistoryForSession:self];\n        return YES;\n    }\n    if (selector == @selector(insertNewline:)) {\n        if ([currentValue isEqualToString:[self currentCommand]]) {\n            // Send the enter key on.\n            [self insertText:@\"\\n\"];\n            return YES;\n        } else {\n            return NO;  // select the row\n        }\n    }\n    if (selector == @selector(deleteBackward:)) {\n        [_textview keyDown:[NSEvent keyEventWithType:NSEventTypeKeyDown\n                                            location:NSZeroPoint\n                                       modifierFlags:[NSEvent modifierFlags]\n                                           timestamp:0\n                                        windowNumber:_textview.window.windowNumber\n                                             context:nil\n                                          characters:@\"\\x7f\"\n                         charactersIgnoringModifiers:@\"\\x7f\"\n                                           isARepeat:NO\n                                             keyCode:51]];  // 51 is the keycode for delete; not in any header file :(\n        return YES;\n    }\n    if (selector == @selector(insertText:) || selector == @selector(insertTab:)) {\n        [self insertText:string];\n        return YES;\n    }\n    return NO;\n}\n\n#pragma mark - iTermPasteHelperDelegate\n\n- (void)pasteHelperWriteString:(NSString *)string {\n    [self writeTask:string];\n    if (_pasteHelper.pasteContext.bytesWritten == 0 &&\n        (_pasteHelper.pasteContext.pasteEvent.flags & kPasteFlagsBracket) &&\n        _screen.terminalBracketedPasteMode) {\n        [self watchForPasteBracketingOopsieWithPrefix:[_pasteHelper.pasteContext.pasteEvent.originalString it_substringToIndex:4]];\n    }\n}\n\n- (void)pasteHelperKeyDown:(NSEvent *)event {\n    [_textview keyDown:event];\n}\n\n- (BOOL)pasteHelperShouldBracket {\n    return _screen.terminalBracketedPasteMode;\n}\n\n- (NSStringEncoding)pasteHelperEncoding {\n    return _screen.terminalEncoding;\n}\n\n- (NSView *)pasteHelperViewForIndicator {\n    return _view;\n}\n\n- (iTermStatusBarViewController *)pasteHelperStatusBarViewController {\n    return _statusBarViewController;\n}\n\n- (BOOL)pasteHelperShouldWaitForPrompt {\n    if (!_screen.shouldExpectPromptMarks) {\n        return NO;\n    }\n\n    return self.currentCommand == nil;\n}\n\n- (BOOL)pasteHelperIsAtShellPrompt {\n    return [self currentCommand] != nil;\n}\n\n- (BOOL)pasteHelperCanWaitForPrompt {\n    return _screen.shouldExpectPromptMarks;\n}\n\n- (void)pasteHelperPasteViewVisibilityDidChange {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (iTermVariableScope *)pasteHelperScope {\n    return self.variablesScope;\n}\n\n#pragma mark - iTermAutomaticProfileSwitcherDelegate\n\n- (NSString *)automaticProfileSwitcherSessionName {\n    return [NSString stringWithFormat:@\"%@ \u2014 %@\", [_nameController presentationSessionTitle], self.tty];\n}\n\n- (iTermSavedProfile *)automaticProfileSwitcherCurrentSavedProfile {\n    iTermSavedProfile *savedProfile = [[[iTermSavedProfile alloc] init] autorelease];\n    savedProfile.profile = _profile;\n    savedProfile.originalProfile = _originalProfile;\n    savedProfile.isDivorced = self.isDivorced;\n    savedProfile.overriddenFields = [[_overriddenFields mutableCopy] autorelease];\n    return savedProfile;\n}\n\n- (NSDictionary *)automaticProfileSwitcherCurrentProfile {\n    return _originalProfile;\n}\n\n- (void)automaticProfileSwitcherLoadProfile:(iTermSavedProfile *)savedProfile {\n    Profile *underlyingProfile = [[ProfileModel sharedInstance] bookmarkWithGuid:savedProfile.originalProfile[KEY_GUID]];\n    Profile *replacementProfile = underlyingProfile ?: savedProfile.originalProfile;\n    [self setProfile:replacementProfile preservingName:NO adjustWindow:NO];\n    if (savedProfile.isDivorced) {\n        NSMutableDictionary *overrides = [NSMutableDictionary dictionary];\n        for (NSString *key in savedProfile.overriddenFields) {\n            if ([key isEqualToString:KEY_GUID] || [key isEqualToString:KEY_ORIGINAL_GUID]) {\n                continue;\n            }\n            overrides[key] = savedProfile.profile[key];\n        }\n        [self setSessionSpecificProfileValues:overrides];\n    }\n    if ([iTermAdvancedSettingsModel showAutomaticProfileSwitchingBanner]) {\n        [_view showUnobtrusiveMessage:[NSString stringWithFormat:@\"Switched to profile \u201c%@\u201d.\", underlyingProfile[KEY_NAME]]];\n    }\n}\n\n- (NSArray<NSDictionary *> *)automaticProfileSwitcherAllProfiles {\n    return [[ProfileModel sharedInstance] bookmarks];\n}\n\n#pragma mark - iTermSessionViewDelegate\n\n- (NSRect)sessionViewFrameForLegacyView {\n    const CGFloat bottomMarginHeight = [_textview excess];\n    return NSMakeRect(0,\n                      bottomMarginHeight,\n                      NSWidth(_textview.bounds),\n                      _textview.lineHeight * _screen.height);\n}\n\n- (CGFloat)sessionViewBottomMarginHeight {\n    return [_textview excess];\n}\n- (CGFloat)sessionViewTransparencyAlpha {\n    return _textview.transparencyAlpha;\n}\n\n- (void)sessionViewMouseEntered:(NSEvent *)event {\n    [_textview mouseEntered:event];\n    [_textview setNeedsDisplay:YES];\n    [_textview updateCursor:event];\n}\n\n- (void)sessionViewMouseExited:(NSEvent *)event {\n    [_textview mouseExited:event];\n    [_textview setNeedsDisplay:YES];\n    [_textview updateCursor:event];\n}\n\n- (void)sessionViewMouseMoved:(NSEvent *)event {\n    [_textview mouseMoved:event];\n}\n\n- (void)sessionViewRightMouseDown:(NSEvent *)event {\n    [_textview rightMouseDown:event];\n}\n\n- (BOOL)sessionViewShouldForwardMouseDownToSuper:(NSEvent *)event {\n    return [_textview mouseDownImpl:event];\n}\n\n- (void)sessionViewDimmingAmountDidChange:(CGFloat)newDimmingAmount {\n    [self sync];\n}\n\n- (BOOL)sessionViewIsVisible {\n    return YES;\n}\n\n- (void)sessionViewDraggingExited:(id<NSDraggingInfo>)sender {\n    [self.delegate sessionDraggingExited:self];\n    [_textview setNeedsDisplay:YES];\n}\n\n- (NSDragOperation)sessionViewDraggingEntered:(id<NSDraggingInfo>)sender {\n    [self.delegate sessionDraggingEntered:self];\n\n    PTYSession *movingSession = [[MovePaneController sharedInstance] session];\n    if (![_delegate session:self shouldAllowDrag:sender]) {\n        return NSDragOperationNone;\n    }\n\n    if (!([[[sender draggingPasteboard] types] indexOfObject:@\"com.iterm2.psm.controlitem\"] != NSNotFound)) {\n        if ([[MovePaneController sharedInstance] isMovingSession:self]) {\n            // Moving me onto myself\n            return NSDragOperationMove;\n        } else if (![movingSession isCompatibleWith:self]) {\n            // We must both be non-tmux or belong to the same session.\n            return NSDragOperationNone;\n        }\n    }\n\n    [self.view createSplitSelectionView];\n    return NSDragOperationMove;\n}\n\n- (BOOL)sessionViewShouldSplitSelectionAfterDragUpdate:(id<NSDraggingInfo>)sender {\n    if ([[[sender draggingPasteboard] types] indexOfObject:iTermMovePaneDragType] != NSNotFound &&\n        [[MovePaneController sharedInstance] isMovingSession:self]) {\n        return NO;\n    }\n    return YES;\n}\n\n- (BOOL)sessionViewPerformDragOperation:(id<NSDraggingInfo>)sender {\n    return [_delegate session:self performDragOperation:sender];\n}\n\n- (NSString *)sessionViewTitle {\n    return _nameController.presentationSessionTitle;\n}\n\n- (NSSize)sessionViewCellSize {\n    return NSMakeSize([_textview charWidth], [_textview lineHeight]);\n}\n\n- (VT100GridSize)sessionViewGridSize {\n    return VT100GridSizeMake(_screen.width, _screen.height);\n}\n\n- (NSColor *)sessionViewBackgroundColor {\n    return [_screen.colorMap colorForKey:kColorMapBackground];\n}\n\n- (BOOL)textViewOrComposerIsFirstResponder {\n    return ((_textview.window.firstResponder == _textview ||\n             [_composerManager dropDownComposerIsFirstResponder]) &&\n            [NSApp isActive] &&\n            _textview.window.isKeyWindow);\n}\n\n- (void)textViewShowFindPanel {\n    const BOOL findPanelWasOpen = self.view.findDriver.viewController.searchIsVisible;\n    [self showFindPanel];\n    if (!findPanelWasOpen) {\n        [self.view.findDriver setFilterHidden:YES];\n    }\n    [[iTermFindPasteboard sharedInstance] updateObservers:nil];\n}\n\n- (void)textViewEnterShortcutNavigationMode {\n    _modeHandler.mode = iTermSessionModeShortcutNavigation;\n}\n\n- (void)textViewExitShortcutNavigationMode {\n    if (_modeHandler.mode == iTermSessionModeShortcutNavigation) {\n        _modeHandler.mode = iTermSessionModeDefault;\n    }\n}\n\n- (void)textViewWillHandleMouseDown:(NSEvent *)event {\n    if (_modeHandler.mode == iTermSessionModeShortcutNavigation) {\n        _modeHandler.mode = iTermSessionModeDefault;\n    }\n}\n\n- (BOOL)textViewPasteFiles:(NSArray<NSString *> *)filenames {\n    NSString *swifty = [iTermAdvancedSettingsModel fileDropCoprocess];\n    if (swifty.length == 0) {\n        return NO;\n    }\n    iTermVariableScope *scope = [[[self variablesScope] copy] autorelease];\n    iTermVariables *frame = [[[iTermVariables alloc] initWithContext:iTermVariablesSuggestionContextNone owner:self] autorelease];\n    [scope addVariables:frame toScopeNamed:nil];\n    NSString *joinedFilenames = [filenames componentsJoinedByString:@\" \"];\n    [scope setValue:joinedFilenames forVariableNamed:@\"filenames\"];\n\n    iTermExpressionEvaluator *eval = [[[iTermExpressionEvaluator alloc] initWithInterpolatedString:swifty\n                                                                                             scope:scope] autorelease];\n    __weak __typeof(self) weakSelf = self;\n    [eval evaluateWithTimeout:5 completion:^(iTermExpressionEvaluator * _Nonnull evaluator) {\n        if (![NSString castFrom:evaluator.value]) {\n            return;\n        }\n        [weakSelf runCoprocessWithCompletion:^(id output, NSError *error){}\n                                 commandLine:evaluator.value\n                                        mute:@YES];\n    }];\n    return YES;\n}\n\n- (NSString *)textViewNaturalLanguageQuery {\n    return [self naturalLanguageQuery];\n}\n\n- (NSString *)naturalLanguageQuery {\n    NSString *query = nil;\n    if (_textview.selection.hasSelection) {\n        query = _textview.selectedText;\n    } else {\n        query = self.currentCommand;\n    }\n    if (query.length == 0) {\n        return nil;\n    }\n    if (query.length >= [iTermAdvancedSettingsModel aiMaxTokens] / 8) {\n        return nil;\n    }\n    return query;\n}\n\n- (void)textViewPerformNaturalLanguageQuery {\n    NSString *query = [self naturalLanguageQuery];\n    if (!query) {\n        NSBeep();\n        return;\n    }\n    [_aiterm release];\n    __weak __typeof(self) weakSelf = self;\n    _aiterm = [[AITermControllerObjC alloc] initWithQuery:query\n                                                    scope:self.variablesScope\n                                                 inWindow:self.view.window\n                                               completion:^(NSArray<NSString *> * _Nullable choices, NSString * _Nullable error) {\n        [weakSelf handleAIChoices:choices error:error];\n    }];\n}\n\n- (void)textViewUpdateTrackingAreas {\n    [self.view updateTrackingAreas];\n}\n\n- (BOOL)textViewShouldShowOffscreenCommandLine {\n    if (_screen.height < 5) {\n        return NO;\n    }\n    if (_modeHandler.mode == iTermSessionModeCopy) {\n        return NO;\n    }\n    return [iTermProfilePreferences boolForKey:KEY_SHOW_OFFSCREEN_COMMANDLINE inProfile:self.profile];\n}\n\n- (BOOL)textViewShouldUseSelectedTextColor {\n    const BOOL dark = self.view.effectiveAppearance.it_isDark;\n    NSString *key = iTermAmendedColorKey(KEY_USE_SELECTED_TEXT_COLOR, self.profile, dark);\n    return [iTermProfilePreferences boolForKey:key inProfile:self.profile];\n}\n\n- (void)handleAIChoices:(NSArray<NSString *> *)choices error:(NSString *)error {\n    if (error) {\n        [iTermWarning showWarningWithTitle:[NSString stringWithFormat:@\"There was a problem with the AI query: %@\", error]\n                                   actions:@[ @\"OK\" ]\n                                 accessory:nil\n                                identifier:nil\n                               silenceable:kiTermWarningTypePersistent\n                                   heading:@\"AI Error\"\n                                    window:self.view.window];\n        return;\n    }\n    if (choices.count == 0) {\n        return;\n    }\n    [self setComposerString:choices[0]];\n    [self.composerManager toggle];\n}\n\n- (BOOL)sessionViewTerminalIsFirstResponder {\n    return [self textViewOrComposerIsFirstResponder];\n}\n\n- (BOOL)sessionViewShouldDimOnlyText {\n    return [iTermPreferences boolForKey:kPreferenceKeyDimOnlyText];\n}\n\n- (NSColor *)sessionViewTabColor {\n    return self.tabColor;\n}\n\n- (NSMenu *)sessionViewContextMenu {\n    return [_textview titleBarMenu];\n}\n\n- (void)sessionViewConfirmAndClose {\n    [[_delegate realParentWindow] closeSessionWithConfirmation:self];\n}\n\n- (void)sessionViewBeginDrag {\n    if (![[MovePaneController sharedInstance] session]) {\n        [[MovePaneController sharedInstance] beginDrag:self];\n    }\n}\n\n- (CGFloat)sessionViewDesiredHeightOfDocumentView {\n    return _textview.desiredHeight + [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins];\n}\n\n- (BOOL)sessionViewShouldUpdateSubviewsFramesAutomatically {\n    [_composerManager layout];\n    \n    // We won't automatically layout the session view's descendents for tmux\n    // tabs. Instead the change gets reported to the tmux server and it will\n    // send us a new layout.\n    if (self.isTmuxClient) {\n        // This makes dragging a split pane in a tmux tab look way better.\n        return ![_delegate sessionBelongsToTmuxTabWhoseSplitsAreBeingDragged];\n    } else {\n        return YES;\n    }\n}\n\n- (NSSize)sessionViewScrollViewWillResize:(NSSize)proposedSize {\n    if ([self isTmuxClient] && ![_delegate sessionBelongsToTmuxTabWhoseSplitsAreBeingDragged]) {\n        NSSize idealSize = [self idealScrollViewSizeWithStyle:_view.scrollview.scrollerStyle];\n        NSSize maximumSize = NSMakeSize(idealSize.width + _textview.charWidth - 1,\n                                        idealSize.height + _textview.lineHeight - 1);\n        DLog(@\"is a tmux client, so tweaking the proposed size. idealSize=%@ maximumSize=%@\",\n             NSStringFromSize(idealSize), NSStringFromSize(maximumSize));\n        return NSMakeSize(MIN(proposedSize.width, maximumSize.width),\n                          MIN(proposedSize.height, maximumSize.height));\n    } else {\n        return proposedSize;\n    }\n}\n\n- (CGFloat)backingScaleFactor {\n    return self.delegate.realParentWindow.window.backingScaleFactor ?: self.view.window.backingScaleFactor;\n}\n\n// Ensure the wrapper is at least as tall as its enclosing scroll view. Mostly this goes unnoticed\n// except in Monterey betas (see issue 9799) but it's the right thing to do regardless.\n- (NSRect)safeFrameForWrapperViewFrame:(NSRect)proposed {\n    const CGFloat minimumHeight = _view.scrollview.contentSize.height;\n    if (NSHeight(proposed) >= minimumHeight) {\n        return proposed;\n    }\n    NSRect frame = proposed;\n    frame.size.height = minimumHeight;\n    DLog(@\"Convert proposed wrapper frame %@ to %@\", NSStringFromRect(proposed), NSStringFromRect(frame));\n    return frame;\n}\n\n- (void)sessionViewScrollViewDidResize {\n    DLog(@\"sessionViewScrollViewDidResize to %@\", NSStringFromRect(_view.scrollview.frame));\n    [self updateTTYSize];\n    _wrapper.frame = [self safeFrameForWrapperViewFrame:_wrapper.frame];\n}\n\n- (BOOL)updateTTYSize {\n    DLog(@\"%@\\n%@\", self, [NSThread callStackSymbols]);\n    return [_shell.winSizeController setGridSize:_screen.size\n                                        viewSize:_screen.viewSize\n                                     scaleFactor:self.backingScaleFactor];\n}\n\n- (iTermStatusBarViewController *)sessionViewStatusBarViewController {\n    return _statusBarViewController;\n}\n\n- (void)textViewOpenComposer:(NSString *)string {\n    [self setComposerString:string];\n    [self.composerManager toggle];\n}\n\n- (BOOL)textViewIsAutoComposerOpen {\n    return [_composerManager dropDownComposerViewIsVisible] && _composerManager.isAutoComposer && !_composerManager.temporarilyHidden;\n}\n\n- (VT100GridRange)textViewLinesToSuppressDrawing {\n    if ([_composerManager dropDownComposerViewIsVisible] && _composerManager.isAutoComposer && !_composerManager.temporarilyHidden) {\n        const NSRect rect = _composerManager.dropDownFrame;\n        const NSRect textViewRect = [_textview convertRect:rect fromView:_view];\n        const VT100GridCoord topLeft = [_textview coordForPoint:textViewRect.origin allowRightMarginOverflow:NO];\n        const VT100GridCoord bottomRight = [_textview coordForPoint:NSMakePoint(NSMaxX(textViewRect) - 1,\n                                                                                NSMaxY(textViewRect) - 1)\n                                           allowRightMarginOverflow:NO];\n        return VT100GridRangeMake(topLeft.y, bottomRight.y - topLeft.y + 1);\n    }\n    return VT100GridRangeMake(0, 0);\n}\n\n- (NSRect)textViewCursorFrameInScreenCoords {\n    const int cx = [self.screen cursorX] - 1;\n    const int cy = [self.screen cursorY];\n    const CGFloat charWidth = [self.textview charWidth];\n    const CGFloat lineHeight = [self.textview lineHeight];\n    NSPoint p = NSMakePoint([iTermPreferences doubleForKey:kPreferenceKeySideMargins] + cx * charWidth,\n                            ([self.screen numberOfLines] - [self.screen height] + cy) * lineHeight);\n    const NSPoint origin = [self.textview.window pointToScreenCoords:[self.textview convertPoint:p toView:nil]];\n    return NSMakeRect(origin.x,\n                      origin.y,\n                      charWidth,\n                      lineHeight);\n}\n\n- (void)textViewDidReceiveSingleClick {\n    _textViewShouldTakeFirstResponder = YES;\n    [_textview.window makeFirstResponder:_textview];\n}\n\n#pragma mark - iTermHotkeyNavigableSession\n\n- (void)sessionHotkeyDidNavigateToSession:(iTermShortcut *)shortcut {\n    [self reveal];\n}\n\n- (BOOL)sessionHotkeyIsAlreadyFirstResponder {\n    return ([NSApp isActive] &&\n            [NSApp keyWindow] == self.textview.window &&\n            self.textview.window.firstResponder == self.textview);\n}\n\n- (BOOL)sessionHotkeyIsAlreadyActiveInNonkeyWindow {\n    if ([NSApp isActive] &&\n        [NSApp keyWindow] == self.textview.window) {\n        return NO;\n    }\n    return [self.delegate sessionIsActiveInSelectedTab:self];\n}\n\n- (void)sessionViewDoubleClickOnTitleBar {\n    [self.delegate sessionDoubleClickOnTitleBar:self];\n}\n\n- (void)sessionViewBecomeFirstResponder {\n    [self.textview.window makeFirstResponder:self.textview];\n}\n\n- (void)sessionViewDidChangeWindow {\n    [self invalidateBlend];\n    [self updateMetalDriver];\n    if (!_shell.ttySizeInitialized) {\n        if ([self updateTTYSize]) {\n            _shell.ttySizeInitialized = YES;\n        }\n    }\n}\n\n- (void)sessionViewAnnouncementDidChange:(SessionView *)sessionView {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (id)temporarilyDisableMetal NS_AVAILABLE_MAC(10_11) {\n    assert(_useMetal);\n    _wrapper.useMetal = NO;\n    _textview.suppressDrawing = NO;\n    [_view setSuppressLegacyDrawing:NO];\n    if (PTYScrollView.shouldDismember) {\n        _view.scrollview.alphaValue = 1;\n    } else {\n        _view.scrollview.contentView.alphaValue = 1;\n    }\n    [self setMetalViewAlphaValue:0];\n    id token = @(_nextMetalDisabledToken++);\n    [_metalDisabledTokens addObject:token];\n    DLog(@\"temporarilyDisableMetal return new token=%@ %@\", token, self);\n    return token;\n}\n\n- (void)drawFrameAndRemoveTemporarilyDisablementOfMetalForToken:(id)token NS_AVAILABLE_MAC(10_11) {\n    DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal %@\", token);\n    if (!_useMetal) {\n        DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal returning early because useMetal is off\");\n        return;\n    }\n    if ([_metalDisabledTokens containsObject:token]) {\n        DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Found token %@\", token);\n        if (_metalDisabledTokens.count > 1) {\n            [_metalDisabledTokens removeObject:token];\n            DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: There are still other tokens remaining: %@\", _metalDisabledTokens);\n            return;\n        }\n    } else {\n        DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Bogus token %@\", token);\n        return;\n    }\n\n    DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal beginning async draw\");\n    [_view.driver drawAsynchronouslyInView:_view.metalView completion:^(BOOL ok) {\n        DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal drawAsynchronouslyInView finished wtih ok=%@\", @(ok));\n        if (![_metalDisabledTokens containsObject:token]) {\n            DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Token %@ is gone, not proceeding.\", token);\n            return;\n        }\n        if (!_view.window) {\n            DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Returning because the view has no window\");\n            return;\n        }\n        if (!_useMetal) {\n            DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Returning because useMetal is off\");\n            return;\n        }\n        if (!ok) {\n            DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Schedule drawFrameAndRemoveTemporarilyDisablementOfMetal to run after a spin of the mainloop\");\n            if (!_delegate) {\n                [self setUseMetal:NO];\n                return;\n            }\n            dispatch_async(dispatch_get_main_queue(), ^{\n                if (![_metalDisabledTokens containsObject:token]) {\n                    DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: [after a spin of the runloop] Token %@ is gone, not proceeding.\", token);\n                    return;\n                }\n                [self drawFrameAndRemoveTemporarilyDisablementOfMetalForToken:token];\n            });\n            return;\n        }\n\n        assert([_metalDisabledTokens containsObject:token]);\n        [_metalDisabledTokens removeObject:token];\n        DLog(@\"drawFrameAndRemoveTemporarilyDisablementOfMetal: Remove temporarily disablement. Tokens are now %@\", _metalDisabledTokens);\n        if (_metalDisabledTokens.count == 0 && _useMetal) {\n            [self reallyShowMetalViewImmediately];\n        }\n    }];\n}\n\n\n- (void)sessionViewNeedsMetalFrameUpdate {\n    DLog(@\"sessionViewNeedsMetalFrameUpdate %@\", self);\n    if (_metalFrameChangePending) {\n        DLog(@\"sessionViewNeedsMetalFrameUpdate frame change pending, return\");\n        return;\n    }\n\n    _metalFrameChangePending = YES;\n    id token = [self temporarilyDisableMetal];\n    [self.textview setNeedsDisplay:YES];\n    dispatch_async(dispatch_get_main_queue(), ^{\n        DLog(@\"sessionViewNeedsMetalFrameUpdate %@ in dispatch_async\", self);\n        _metalFrameChangePending = NO;\n        [_view reallyUpdateMetalViewFrame];\n        DLog(@\"sessionViewNeedsMetalFrameUpdate will draw farme and remove disablement\");\n        [self drawFrameAndRemoveTemporarilyDisablementOfMetalForToken:token];\n    });\n}\n\n- (void)sessionViewRecreateMetalView {\n    if (_metalDeviceChanging) {\n        return;\n    }\n    DLog(@\"sessionViewRecreateMetalView metalDeviceChanging<-YES\");\n    _metalDeviceChanging = YES;\n    [self.textview setNeedsDisplay:YES];\n    [_delegate sessionUpdateMetalAllowed];\n    dispatch_async(dispatch_get_main_queue(), ^{\n        _metalDeviceChanging = NO;\n        DLog(@\"sessionViewRecreateMetalView metalDeviceChanging<-NO\");\n        [_delegate sessionUpdateMetalAllowed];\n    });\n}\n\n- (void)sessionViewUserScrollDidChange:(BOOL)userScroll {\n    [self.delegate sessionUpdateMetalAllowed];\n    [self updateAutoComposerSeparatorVisibility];\n}\n\n- (void)sessionViewDidChangeHoverURLVisible:(BOOL)visible {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (iTermVariableScope *)sessionViewScope {\n    return self.variablesScope;\n}\n\n- (BOOL)sessionViewUseSeparateStatusBarsPerPane {\n    if (![iTermPreferences boolForKey:kPreferenceKeySeparateStatusBarsPerPane]) {\n        return NO;\n    }\n    if (self.isTmuxClient) {\n        return NO;\n    }\n    return YES;\n}\n\n- (void)sessionViewDidChangeEffectiveAppearance {\n    [self sync];\n    if ([iTermProfilePreferences boolForKey:KEY_USE_SEPARATE_COLORS_FOR_LIGHT_AND_DARK_MODE inProfile:self.profile]) {\n        [self loadColorsFromProfile:self.profile];\n    }\n}\n\n- (BOOL)sessionViewCaresAboutMouseMovement {\n    return [_textview wantsMouseMovementEvents];\n}\n\n- (NSRect)sessionViewOffscreenCommandLineFrameForView:(NSView *)view {\n    return [_textview offscreenCommandLineFrameForView:view];\n}\n\n- (void)sessionViewUpdateComposerFrame {\n    [[self composerManager] layout];\n}\n#pragma mark - iTermCoprocessDelegate\n\n- (void)coprocess:(Coprocess *)coprocess didTerminateWithErrorOutput:(NSString *)errors {\n    if ([Coprocess shouldIgnoreErrorsFromCommand:coprocess.command]) {\n        return;\n    }\n    NSString *command = [[coprocess.command copy] autorelease];\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:[NSString stringWithFormat:@\"Coprocess \u201c%@\u201d terminated with output on stderr.\", coprocess.command]\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"_View Errors\", @\"Ignore Errors from This Command\" ]\n                                                completion:^(int selection) {\n                                                    if (selection == 0) {\n                                                        NSString *filename = [[NSWorkspace sharedWorkspace] temporaryFileNameWithPrefix:@\"coprocess-stderr.\" suffix:@\".txt\"];\n                                                        [errors writeToFile:filename atomically:NO encoding:NSUTF8StringEncoding error:nil];\n                                                        [[NSWorkspace sharedWorkspace] openFile:filename];\n                                                    } else if (selection == 1) {\n                                                        [Coprocess setSilentlyIgnoreErrors:YES fromCommand:command];\n                                                    }\n                                                }];\n    [self queueAnnouncement:announcement identifier:[[NSUUID UUID] UUIDString]];\n}\n\n#pragma mark - iTermUpdateCadenceController\n\n- (void)updateCadenceControllerUpdateDisplay:(iTermUpdateCadenceController *)controller {\n    [self updateDisplayBecause:nil];\n}\n\n- (iTermUpdateCadenceState)updateCadenceControllerState {\n    iTermUpdateCadenceState state;\n    state.active = _active;\n    state.idle = self.isIdle;\n    state.visible = [_delegate sessionBelongsToVisibleTab] && !self.view.window.isMiniaturized;\n\n    if (self.useMetal) {\n        if ([iTermPreferences maximizeMetalThroughput] &&\n            !_screen.terminalSoftAlternateScreenMode) {\n            state.useAdaptiveFrameRate = YES;\n        } else {\n            state.useAdaptiveFrameRate = NO;\n        }\n    } else {\n        if ([iTermAdvancedSettingsModel disableAdaptiveFrameRateInInteractiveApps] &&\n            _screen.terminalSoftAlternateScreenMode) {\n            state.useAdaptiveFrameRate = NO;\n        } else {\n            state.useAdaptiveFrameRate = _useAdaptiveFrameRate;\n        }\n    }\n    state.adaptiveFrameRateThroughputThreshold = _adaptiveFrameRateThroughputThreshold;\n    state.slowFrameRate = self.useMetal ? [iTermAdvancedSettingsModel metalSlowFrameRate] : [iTermAdvancedSettingsModel slowFrameRate];\n    state.liveResizing = _inLiveResize;\n    state.proMotion = [NSProcessInfo it_hasARMProcessor] && [_textview.window.screen it_supportsHighFrameRates];\n    state.estimatedThroughput = _estimatedThroughput;\n    return state;\n}\n\n- (void)cadenceControllerActiveStateDidChange:(BOOL)active {\n    [self.delegate sessionUpdateMetalAllowed];\n}\n\n- (BOOL)updateCadenceControllerWindowHasSheet {\n    return self.view.window.sheets.count > 0;\n}\n\n#pragma mark - API\n\n- (void)addContentSubscriber:(id<iTermContentSubscriber>)contentSubscriber {\n    if (!_contentSubscribers) {\n        _contentSubscribers = [[NSMutableArray alloc] init];\n    }\n    [_contentSubscribers addObject:contentSubscriber];\n    [self sync];\n}\n\n- (void)removeContentSubscriber:(id<iTermContentSubscriber>)contentSubscriber {\n    [_contentSubscribers removeObject:contentSubscriber];\n    [self sync];\n}\n\n- (NSString *)stringForLine:(const screen_char_t *)screenChars\n                     length:(int)length\n                  cppsArray:(NSMutableArray<ITMCodePointsPerCell *> *)cppsArray {\n    unichar *characters = iTermMalloc(sizeof(unichar) * length * kMaxParts + 1);\n    ITMCodePointsPerCell *cpps = [[[ITMCodePointsPerCell alloc] init] autorelease];\n    cpps.numCodePoints = 1;\n    cpps.repeats = 0;\n    int o = 0;\n    for (int i = 0; i < length; ++i) {\n        int numCodePoints;\n\n        unichar c = screenChars[i].code;\n        if (!screenChars[i].complexChar && c >= ITERM2_PRIVATE_BEGIN && c <= ITERM2_PRIVATE_END) {\n            numCodePoints = 0;\n        } else if (screenChars[i].image) {\n            numCodePoints = 0;\n        } else {\n            const int len = ExpandScreenChar(&screenChars[i], characters + o);\n            o += len;\n            numCodePoints = len;\n        }\n\n        if (numCodePoints != cpps.numCodePoints && cpps.repeats > 0) {\n            [cppsArray addObject:cpps];\n            cpps = [[[ITMCodePointsPerCell alloc] init] autorelease];\n            cpps.repeats = 0;\n        }\n        cpps.numCodePoints = numCodePoints;\n        cpps.repeats = cpps.repeats + 1;\n    }\n    if (cpps.repeats > 0) {\n        [cppsArray addObject:cpps];\n    }\n    NSString *string = [[[NSString alloc] initWithCharacters:characters length:o] autorelease];\n    free(characters);\n    return string;\n}\n\n- (VT100GridAbsWindowedRange)absoluteWindowedCoordRangeFromLineRange:(ITMLineRange *)lineRange {\n    if (lineRange.hasWindowedCoordRange) {\n        return VT100GridAbsWindowedRangeMake(VT100GridAbsCoordRangeMake(lineRange.windowedCoordRange.coordRange.start.x,\n                                                                        lineRange.windowedCoordRange.coordRange.start.y,\n                                                                        lineRange.windowedCoordRange.coordRange.end.x,\n                                                                        lineRange.windowedCoordRange.coordRange.end.y),\n                                             lineRange.windowedCoordRange.columns.location,\n                                             lineRange.windowedCoordRange.columns.length);\n    }\n    int n = 0;\n    if (lineRange.hasScreenContentsOnly) {\n        n++;\n    }\n    if (lineRange.hasTrailingLines) {\n        n++;\n    }\n    if (n != 1) {\n        return VT100GridAbsWindowedRangeMake(VT100GridAbsCoordRangeMake(-1, -1, -1, -1), -1, -1);\n    }\n\n    NSRange range;\n    if (lineRange.hasScreenContentsOnly) {\n        range.location = [_screen numberOfScrollbackLines] + _screen.totalScrollbackOverflow;\n        range.length = _screen.height;\n    } else if (lineRange.hasTrailingLines) {\n        // Requests are capped at 1M lines to avoid doing too much work.\n        int64_t length = MIN(1000000, MIN(lineRange.trailingLines, _screen.numberOfLines));\n        range.location = _screen.numberOfLines + _screen.totalScrollbackOverflow - length;\n        range.length = length;\n    } else {\n        range = NSMakeRange(NSNotFound, 0);\n    }\n    return VT100GridAbsWindowedRangeMake(VT100GridAbsCoordRangeMake(0, range.location, 0, NSMaxRange(range)), 0, 0);\n}\n\n- (ITMGetBufferResponse *)handleGetBufferRequest:(ITMGetBufferRequest *)request {\n    ITMGetBufferResponse *response = [[[ITMGetBufferResponse alloc] init] autorelease];\n\n    const VT100GridAbsWindowedRange windowedRange = [self absoluteWindowedCoordRangeFromLineRange:request.lineRange];\n    if (windowedRange.coordRange.start.x < 0) {\n        response.status = ITMGetBufferResponse_Status_InvalidLineRange;\n        return nil;\n    }\n\n    const VT100GridWindowedRange range = VT100GridWindowedRangeFromVT100GridAbsWindowedRange(windowedRange, _screen.totalScrollbackOverflow);\n    iTermTextExtractor *extractor = [iTermTextExtractor textExtractorWithDataSource:_screen];\n    __block int firstIndex = -1;\n    __block int lastIndex = -1;\n    __block const screen_char_t *line = nil;\n    BOOL (^handleEol)(unichar, int, int) = ^BOOL(unichar code, int numPreceedingNulls, int linenumber) {\n        ITMLineContents *lineContents = [[[ITMLineContents alloc] init] autorelease];\n        lineContents.text = [self stringForLine:line + firstIndex\n                                         length:lastIndex - firstIndex\n                                      cppsArray:lineContents.codePointsPerCellArray];\n        switch (code) {\n            case EOL_HARD:\n                lineContents.continuation = ITMLineContents_Continuation_ContinuationHardEol;\n                break;\n\n            case EOL_SOFT:\n            case EOL_DWC:\n                lineContents.continuation = ITMLineContents_Continuation_ContinuationSoftEol;\n                break;\n        }\n        [response.contentsArray addObject:lineContents];\n        firstIndex = lastIndex = -1;\n        line = nil;\n        return NO;\n    };\n    [extractor enumerateCharsInRange:range\n                           charBlock:^BOOL(const screen_char_t *currentLine, screen_char_t theChar, iTermExternalAttribute *ea, VT100GridCoord coord) {\n                               line = currentLine;\n                               if (firstIndex < 0) {\n                                   firstIndex = coord.x;\n                               }\n                               lastIndex = coord.x + 1;\n                               line = currentLine;\n                               return NO;\n                           }\n                            eolBlock:^BOOL(unichar code, int numPreceedingNulls, int line) {\n                                return handleEol(code, numPreceedingNulls, line);\n                            }];\n    if (line) {\n        handleEol(EOL_SOFT, 0, 0);\n    }\n    response.cursor = [[[ITMCoord alloc] init] autorelease];\n    response.cursor.x = _screen.currentGrid.cursor.x;\n    response.cursor.y = _screen.currentGrid.cursor.y + _screen.numberOfScrollbackLines + _screen.totalScrollbackOverflow;\n\n    response.status = ITMGetBufferResponse_Status_Ok;\n    response.windowedCoordRange.coordRange.start.x = windowedRange.coordRange.start.x;\n    response.windowedCoordRange.coordRange.start.y = windowedRange.coordRange.start.y;\n    response.windowedCoordRange.coordRange.end.x = windowedRange.coordRange.end.x;\n    response.windowedCoordRange.coordRange.end.y = windowedRange.coordRange.end.y;\n    response.windowedCoordRange.columns.location = windowedRange.columnWindow.location;\n    response.windowedCoordRange.columns.length = windowedRange.columnWindow.length;\n\n    return response;\n}\n\n- (void)handleListPromptsRequest:(ITMListPromptsRequest *)request completion:(void (^)(ITMListPromptsResponse *))completion {\n    ITMListPromptsResponse *response = [[[ITMListPromptsResponse alloc] init] autorelease];\n    [_screen enumeratePromptsFrom:request.hasFirstUniqueId ? request.firstUniqueId : nil\n                               to:request.hasLastUniqueId ? request.lastUniqueId : nil\n                            block:^(id<VT100ScreenMarkReading> mark) {\n        [response.uniquePromptIdArray addObject:mark.guid];\n    }];\n    completion(response);\n}\n\n- (void)handleGetPromptRequest:(ITMGetPromptRequest *)request completion:(void (^)(ITMGetPromptResponse *response))completion {\n    id<VT100ScreenMarkReading> mark;\n    if (request.hasUniquePromptId) {\n        mark = [_screen promptMarkWithGUID:request.uniquePromptId];\n    } else {\n        mark = [_screen lastPromptMark];\n    }\n    ITMGetPromptResponse *response = [self getPromptResponseForMark:mark];\n    completion(response);\n}\n\n- (ITMGetPromptResponse *)getPromptResponseForMark:(id<VT100ScreenMarkReading>)mark {\n    ITMGetPromptResponse *response = [[[ITMGetPromptResponse alloc] init] autorelease];\n    if (!mark) {\n        response.status = ITMGetPromptResponse_Status_PromptUnavailable;\n        return response;\n    }\n\n    if (mark.promptRange.start.x >= 0) {\n        response.promptRange = [[[ITMCoordRange alloc] init] autorelease];\n        response.promptRange.start.x = mark.promptRange.start.x;\n        response.promptRange.start.y = mark.promptRange.start.y;\n        response.promptRange.end.x = mark.promptRange.end.x;\n        response.promptRange.end.y = mark.promptRange.end.y;\n    }\n    if (mark.commandRange.start.x >= 0) {\n        response.commandRange = [[[ITMCoordRange alloc] init] autorelease];\n        response.commandRange.start.x = mark.commandRange.start.x;\n        response.commandRange.start.y = mark.commandRange.start.y;\n        response.commandRange.end.x = mark.commandRange.end.x;\n        response.commandRange.end.y = mark.commandRange.end.y;\n    }\n    if (mark.outputStart.x >= 0) {\n        response.outputRange = [[[ITMCoordRange alloc] init] autorelease];\n        response.outputRange.start.x = mark.outputStart.x;\n        response.outputRange.start.y = mark.outputStart.y;\n        response.outputRange.end.x = _screen.currentGrid.cursor.x;\n        response.outputRange.end.y = _screen.currentGrid.cursor.y + _screen.numberOfScrollbackLines + _screen.totalScrollbackOverflow;\n    }\n\n    response.command = mark.command ?: self.currentCommand;\n    response.status = ITMGetPromptResponse_Status_Ok;\n    response.workingDirectory = [_screen workingDirectoryOnLine:mark.promptRange.end.y] ?: self.lastDirectory;\n    if (mark.hasCode) {\n        response.promptState = ITMGetPromptResponse_State_Finished;\n        response.exitStatus = mark.code;\n    } else if (mark.outputStart.x >= 0) {\n        response.promptState = ITMGetPromptResponse_State_Running;\n    } else {\n        response.promptState = ITMGetPromptResponse_State_Editing;\n    }\n    response.uniquePromptId = mark.guid;\n    return response;\n}\n\n- (ITMSetProfilePropertyResponse_Status)handleSetProfilePropertyForAssignments:(NSArray<iTermTuple<NSString *, id> *> *)tuples\n                                                            scriptHistoryEntry:(iTermScriptHistoryEntry *)scriptHistoryEntry {\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    for (iTermTuple<NSString *, id> *tuple in tuples) {\n        NSString *key = tuple.firstObject;\n        id value = tuple.secondObject;\n        if (![iTermProfilePreferences valueIsLegal:value forKey:key]) {\n            XLog(@\"Value %@ is not legal for key %@\", value, key);\n            [scriptHistoryEntry addOutput:[NSString stringWithFormat:@\"Value %@ is not legal type for key %@\\n\", value, key]\n                               completion:^{}];\n            return ITMSetProfilePropertyResponse_Status_RequestMalformed;\n        }\n        dict[key] = value;\n    }\n\n    [self setSessionSpecificProfileValues:dict];\n    return ITMSetProfilePropertyResponse_Status_Ok;\n}\n\n- (ITMGetProfilePropertyResponse *)handleGetProfilePropertyForKeys:(NSArray<NSString *> *)keys {\n    ITMGetProfilePropertyResponse *response = [[[ITMGetProfilePropertyResponse alloc] init] autorelease];\n    if (!keys.count) {\n        return [self handleGetProfilePropertyForKeys:[iTermProfilePreferences allKeys]];\n    }\n\n    for (NSString *key in keys) {\n        id value = [iTermProfilePreferences objectForKey:key inProfile:self.profile];\n        if (value) {\n            NSString *jsonString = [iTermProfilePreferences jsonEncodedValueForKey:key inProfile:self.profile];\n            if (jsonString) {\n                ITMProfileProperty *property = [[[ITMProfileProperty alloc] init] autorelease];\n                property.key = key;\n                property.jsonValue = jsonString;\n                [response.propertiesArray addObject:property];\n            }\n        }\n    }\n    response.status = ITMGetProfilePropertyResponse_Status_Ok;\n    return response;\n}\n\n#pragma mark - iTermSessionNameControllerDelegate\n\n- (NSString *)sessionNameControllerUniqueIdentifier {\n    iTermTitleComponents components = [iTermProfilePreferences unsignedIntegerForKey:KEY_TITLE_COMPONENTS inProfile:_profile];\n    if (components != iTermTitleComponentsCustom) {\n        return iTermSessionNameControllerSystemTitleUniqueIdentifier;\n    }\n    \n    iTermTuple<NSString *, NSString *> *tuple = [iTermTuple fromPlistValue:[iTermProfilePreferences stringForKey:KEY_TITLE_FUNC inProfile:_profile]];\n    if (tuple.firstObject && tuple.secondObject) {\n        return tuple.secondObject;\n    } else {\n        return nil;\n    }\n}\n\n- (void)sessionNameControllerNameWillChangeTo:(NSString *)newName {\n    [self.variablesScope setValue:newName forVariableNamed:iTermVariableKeySessionName];\n}\n\n- (void)sessionNameControllerPresentationNameDidChangeTo:(NSString *)presentationName {\n    [_delegate nameOfSession:self didChangeTo:presentationName];\n    [self.view setTitle:presentationName];\n\n    // get the session submenu to be rebuilt\n    if ([[iTermController sharedInstance] currentTerminal] == [_delegate parentWindow]) {\n        [[NSNotificationCenter defaultCenter] postNotificationName:@\"iTermNameOfSessionDidChange\"\n                                                            object:[_delegate parentWindow]\n                                                          userInfo:nil];\n    }\n    [self.variablesScope setValue:presentationName forVariableNamed:iTermVariableKeySessionPresentationName];\n    [_textview setBadgeLabel:[self badgeLabel]];\n}\n\n- (void)sessionNameControllerDidChangeWindowTitle {\n    if ([_delegate sessionBelongsToVisibleTab]) {\n        [[_delegate parentWindow] setWindowTitle];\n    }\n}\n\n- (iTermSessionFormattingDescriptor *)sessionNameControllerFormattingDescriptor {\n    iTermSessionFormattingDescriptor *descriptor = [[[iTermSessionFormattingDescriptor alloc] init] autorelease];\n    descriptor.isTmuxGateway = self.isTmuxGateway;\n    descriptor.tmuxClientName = _tmuxController.clientName;\n    descriptor.haveTmuxController = (self.tmuxController != nil);\n    descriptor.tmuxWindowName = [_delegate tmuxWindowName];\n    return descriptor;\n}\n\n- (iTermVariableScope *)sessionNameControllerScope {\n    return self.variablesScope;\n}\n\n#pragma mark - Variable Change Handlers\n\n- (void)jobPidDidChange {\n    // Avoid requesting an update before we know the name because doing so delays updating it when\n    // we finally get the name since it's rate-limited.\n    if (self.shell.pid > 0 || [[[self variablesScope] valueForVariableName:@\"jobName\"] length] > 0) {\n        [self.processInfoProvider setNeedsUpdate:YES];\n    }\n    if ([_graphicSource updateImageForProcessID:self.shell.pid enabled:[self shouldShowTabGraphic] processInfoProvider:self.processInfoProvider]) {\n        [self.delegate sessionDidChangeGraphic:self shouldShow:self.shouldShowTabGraphic image:self.tabGraphic];\n    }\n    [self.delegate sessionJobDidChange:self];\n}\n\n#pragma mark - iTermEchoProbeDelegate\n\n- (void)echoProbe:(iTermEchoProbe *)echoProbe writeString:(NSString *)string {\n    if (self.tmuxMode == TMUX_GATEWAY) {\n        return;\n    }\n    [self writeTaskNoBroadcast:string];\n}\n\n- (void)echoProbe:(iTermEchoProbe *)echoProbe writeData:(NSData *)data {\n    if (self.tmuxMode == TMUX_GATEWAY) {\n        return;\n    }\n    [self writeLatin1EncodedData:data broadcastAllowed:NO reporting:NO];\n}\n\n- (void)echoProbeDidFail:(iTermEchoProbe *)echoProbe {\n    // Not allowed to use a runloop in a side-effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self sendPasswordAfterGettingPermission];\n    });\n}\n\n- (void)sendPasswordAfterGettingPermission {\n    BOOL ok = ([iTermWarning showWarningWithTitle:@\"Are you really at a password prompt? It looks \"\n                @\"like what you're typing is echoed to the screen.\"\n                                          actions:@[ @\"Cancel\", @\"Enter Password\" ]\n                                       identifier:nil\n                                      silenceable:kiTermWarningTypePersistent\n                                           window:self.view.window] == kiTermWarningSelection1);\n    if (ok) {\n        [_screen sendPasswordInEchoProbe];\n    } else {\n        [self incrementDisableFocusReporting:-1];\n        [_screen resetEchoProbe];\n    }\n}\n\n- (void)echoProbeDidSucceed:(iTermEchoProbe *)echoProbe {\n    [self incrementDisableFocusReporting:-1];\n}\n\n- (BOOL)echoProbeShouldSendPassword:(iTermEchoProbe *)echoProbe {\n    return YES;\n}\n\n- (void)echoProbeDelegateWillChange:(iTermEchoProbe *)echoProbe {\n}\n\n#pragma mark - iTermBackgroundDrawingHelperDelegate\n\n- (SessionView *)backgroundDrawingHelperView {\n    return _view;\n}\n\n- (iTermImageWrapper *)backgroundDrawingHelperImage {\n    return [self effectiveBackgroundImage];\n}\n\n- (BOOL)backgroundDrawingHelperUseTransparency {\n    return _textview.useTransparency;\n}\n\n- (CGFloat)backgroundDrawingHelperTransparency {\n    return _textview.transparency;\n}\n\n- (iTermBackgroundImageMode)backgroundDrawingHelperBackgroundImageMode {\n    return [self effectiveBackgroundImageMode];\n}\n\n- (NSColor *)backgroundDrawingHelperDefaultBackgroundColor {\n    return [self processedBackgroundColor];\n}\n\n- (CGFloat)backgroundDrawingHelperBlending {\n    return self.effectiveBlend;\n}\n\n#pragma mark - iTermStatusBarViewControllerDelegate\n\n- (NSColor *)textColorForStatusBar {\n    return [[iTermTheme sharedInstance] statusBarTextColorForEffectiveAppearance:_view.effectiveAppearance\n                                                                        colorMap:_screen.colorMap\n                                                                        tabStyle:[self.view.window.ptyWindow it_tabStyle]\n                                                                   mainAndActive:(self.view.window.isMainWindow && NSApp.isActive)];\n}\n\n- (BOOL)statusBarHasDarkBackground {\n    if (self.view.window.ptyWindow.it_terminalWindowUseMinimalStyle) {\n        NSColor *color = self.view.window.ptyWindow.it_terminalWindowDecorationControlColor;\n        return [color isDark];\n    }\n    // This is called early in the appearance change process and subviews of the contentview aren't\n    // up to date yet.\n    return self.view.window.contentView.effectiveAppearance.it_isDark;\n}\n\n- (BOOL)statusBarRevealComposer {\n    [self.composerManager revealMinimal];\n    return NO;\n}\n\n- (NSColor *)statusBarDefaultTextColor {\n    return [self textColorForStatusBar];\n}\n\n- (NSColor *)statusBarSeparatorColor {\n    if (self.view.window.ptyWindow.it_terminalWindowUseMinimalStyle) {\n        return nil;\n    }\n    NSColor *color = _statusBarViewController.layout.advancedConfiguration.separatorColor;\n    if (color) {\n        return color;\n    }\n\n    const CGFloat alpha = 0.25;\n    NSAppearance *appearance = nil;\n    switch ((iTermPreferencesTabStyle)[iTermPreferences intForKey:kPreferenceKeyTabStyle]) {\n        case TAB_STYLE_DARK:\n        case TAB_STYLE_DARK_HIGH_CONTRAST:\n            appearance = [NSAppearance appearanceNamed:NSAppearanceNameDarkAqua];\n            break;\n        case TAB_STYLE_LIGHT:\n        case TAB_STYLE_LIGHT_HIGH_CONTRAST:\n            appearance = [NSAppearance appearanceNamed:NSAppearanceNameAqua];\n            break;\n        case TAB_STYLE_AUTOMATIC:\n        case TAB_STYLE_COMPACT:\n        case TAB_STYLE_MINIMAL:  // shouldn't happen\n            appearance = [NSApp effectiveAppearance];\n            break;\n    }\n    return [[[self textColorForStatusBar] it_colorWithAppearance:appearance] colorWithAlphaComponent:alpha];\n}\n\n- (NSColor *)statusBarBackgroundColor {\n    return _statusBarViewController.layout.advancedConfiguration.backgroundColor;\n}\n\n- (void)updateStatusBarStyle {\n    [_statusBarViewController updateColors];\n    [self invalidateStatusBar];\n}\n\n- (NSFont *)statusBarTerminalFont {\n    return _textview.fontTable.asciiFont.font;\n}\n\n- (NSColor *)statusBarTerminalBackgroundColor {\n    return [self processedBackgroundColor];\n}\n\n- (id<ProcessInfoProvider>)statusBarProcessInfoProvider {\n    return self.processInfoProvider;\n}\n\n- (void)statusBarWriteString:(NSString *)string {\n    [self writeTask:string];\n}\n\n- (void)statusBarDidUpdate {\n    [_view updateFindDriver];\n}\n\n- (void)statusBarOpenPreferencesToComponent:(nullable id<iTermStatusBarComponent>)component {\n    PreferencePanel *panel;\n    NSString *guid;\n    if (self.isDivorced && ([_overriddenFields containsObject:KEY_STATUS_BAR_LAYOUT] ||\n                            [_overriddenFields containsObject:KEY_SHOW_STATUS_BAR])) {\n        panel = [PreferencePanel sessionsInstance];\n        guid = _profile[KEY_GUID];\n    } else {\n        panel = [PreferencePanel sharedInstance];\n        guid = _originalProfile[KEY_GUID];\n    }\n    [panel openToProfileWithGuid:guid\n  andEditComponentWithIdentifier:component.statusBarComponentIdentifier\n                            tmux:self.isTmuxClient\n                           scope:self.variablesScope];\n    [panel.window makeKeyAndOrderFront:nil];\n}\n\n- (void)statusBarDisable {\n    if (self.isDivorced) {\n        [self setSessionSpecificProfileValues:@{ KEY_SHOW_STATUS_BAR: @NO }];\n    } else {\n        [iTermProfilePreferences setBool:NO\n                                  forKey:KEY_SHOW_STATUS_BAR\n                               inProfile:self.profile\n                                   model:[ProfileModel sharedInstance]];\n    }\n    [[NSNotificationCenter defaultCenter] postNotificationName:kSessionProfileDidChange\n                                                        object:_profile[KEY_GUID]];\n}\n\n- (BOOL)statusBarCanDragWindow {\n    const BOOL inTitleBar = self.view.statusBarIsInPaneTitleBar;\n    if (inTitleBar) {\n        return [self.delegate sessionShouldDragWindowByPaneTitleBar:self];\n    }\n    return YES;\n}\n\n- (iTermActivityInfo)statusBarActivityInfo {\n    return _activityInfo;\n}\n\n- (void)statusBarSetFilter:(NSString *)query {\n    PTYSession *synthetic = [self.delegate sessionSyntheticSessionFor:self];\n    if (synthetic) {\n        [synthetic statusBarSetFilter:query];\n        return;\n    }\n    if (query) {\n        [self.delegate session:self setFilter:query];\n    } else {\n        [self stopFiltering];\n    }\n}\n\n// Called on the synthetic session.\n- (void)stopFiltering {\n    [self setFilterProgress:0];\n    [self.liveSession removeContentSubscriber:_asyncFilter];\n    [_asyncFilter cancel];\n    [_asyncFilter autorelease];\n    _asyncFilter = nil;\n    if ([_statusBarViewController.temporaryRightComponent isKindOfClass:[iTermStatusBarFilterComponent class]]) {\n        _statusBarViewController.temporaryRightComponent = nil;\n    }\n    [self.delegate session:self setFilter:nil];\n    [_textview.window makeFirstResponder:_textview];\n}\n\n- (ProfileModel *)profileModel {\n    if (self.isDivorced && [_overriddenFields containsObject:KEY_STATUS_BAR_LAYOUT]) {\n        return [ProfileModel sessionsInstance];\n    } else {\n        return [ProfileModel sharedInstance];\n    }\n}\n\n- (void)statusBarSetLayout:(nonnull iTermStatusBarLayout *)layout {\n    [iTermProfilePreferences setObject:[layout dictionaryValue]\n                                forKey:KEY_STATUS_BAR_LAYOUT\n                             inProfile:self.originalProfile\n                                 model:[self profileModel]];\n}\n\n- (void)statusBarPerformAction:(iTermAction *)action {\n    [self applyAction:action];\n}\n\n- (void)statusBarEditActions {\n    [self.delegate sessionEditActions];\n}\n\n- (void)statusBarEditSnippets {\n    [self.delegate sessionEditSnippets];\n}\n\n- (void)statusBarResignFirstResponder {\n    [_textview.window makeFirstResponder:_textview];\n}\n\n- (void)statusBarReportScriptingError:(NSError *)error\n                        forInvocation:(NSString *)invocation\n                               origin:(NSString *)origin {\n    [PTYSession reportFunctionCallError:error\n                          forInvocation:invocation\n                                 origin:origin\n                                 window:self.delegate.realParentWindow.window];\n}\n\n- (id<iTermTriggersDataSource>)statusBarTriggersDataSource {\n    return self;\n}\n\n#pragma mark - iTermTriggersDataSource\n\n- (NSInteger)numberOfTriggers {\n    return _config.triggerProfileDicts.count;\n}\n\n- (NSArray<NSString *> *)triggerNames {\n    return [_config.triggerProfileDicts mapWithBlock:^id(NSDictionary *dict) {\n        Trigger *trigger = [Trigger triggerFromDict:dict];\n        return [NSString stringWithFormat:@\"%@ \u2014 %@\", [[[trigger class] title] stringByRemovingSuffix:@\"\u2026\"], trigger.regex];\n    }];\n}\n\n- (NSIndexSet *)enabledTriggerIndexes {\n    return [_config.triggerProfileDicts it_indexSetWithObjectsPassingTest:^BOOL(NSDictionary *triggerDict) {\n        return ![triggerDict[kTriggerDisabledKey] boolValue];\n    }];\n}\n\n- (void)addTrigger {\n    [self openAddTriggerViewControllerWithText:_textview.selectedText ?: @\"\"];\n}\n\n- (void)editTriggers {\n    [self openTriggersViewController];\n}\n\n- (void)toggleTriggerAtIndex:(NSInteger)index {\n    [self toggleTriggerEnabledAtIndex:index];\n}\n\n#pragma mark - iTermMetaFrustrationDetectorDelegate\n\n- (void)metaFrustrationDetectorDidDetectFrustrationForLeftOption {\n    [self maybeOfferToSetOptionAsEscForLeft:YES];\n}\n\n- (void)metaFrustrationDetectorDidDetectFrustrationForRightOption {\n    [self maybeOfferToSetOptionAsEscForLeft:NO];\n}\n\n- (void)maybeOfferToSetOptionAsEscForLeft:(BOOL)left {\n    if (self.isDivorced) {\n        // This gets gnarly. Let's be conservative.\n        return;\n    }\n    NSString *neverPromptUserDefaultsKey = @\"NoSyncNeverPromptToChangeOption\";\n    if ([[NSUserDefaults standardUserDefaults] boolForKey:neverPromptUserDefaultsKey]) {\n        // User said never to ask.\n        return;\n    }\n\n    NSString *leftOrRight;\n    NSString *profileKey;\n    if (left) {\n        leftOrRight = @\"left\";\n        profileKey = KEY_OPTION_KEY_SENDS;\n    } else {\n        leftOrRight = @\"right\";\n        profileKey = KEY_RIGHT_OPTION_KEY_SENDS;\n    }\n\n    if ([iTermProfilePreferences integerForKey:profileKey inProfile:self.profile] != OPT_NORMAL) {\n        // There's already a non-default setting.\n        return;\n    }\n\n    NSArray<NSString *> *actions;\n    NSInteger thisProfile = 0;\n    NSInteger allProfiles = -1;\n    if ([[[ProfileModel sharedInstance] bookmarks] count] == 1) {\n        actions = @[ @\"Yes\", @\"Stop Asking\" ];\n    } else {\n        actions = @[ @\"Change This Profile\", @\"Change All Profiles\", @\"Stop Asking\" ];\n        allProfiles = 1;\n    }\n\n    Profile *profileToChange = [[ProfileModel sharedInstance] bookmarkWithGuid:self.profile[KEY_GUID]];\n    if (!profileToChange) {\n        return;\n    }\n\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:[NSString stringWithFormat:@\"You seem frustrated. Would you like the %@ option key to send esc+keystroke?\", leftOrRight]\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:actions\n                                                completion:^(int selection) {\n                                                    if (selection < 0) {\n                                                        // Programmatic dismissal or clicked the x button.\n                                                        return;\n                                                    }\n                                                    if (selection == thisProfile) {\n                                                        [iTermProfilePreferences setInt:OPT_ESC forKey:profileKey inProfile:profileToChange model:[ProfileModel sharedInstance]];\n                                                    } else if (selection == allProfiles) {\n                                                        for (Profile *profile in [[[[ProfileModel sharedInstance] bookmarks] copy] autorelease]) {\n                                                            [iTermProfilePreferences setInt:OPT_ESC forKey:profileKey inProfile:profile model:[ProfileModel sharedInstance]];\n                                                        }\n                                                    } else {\n                                                        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:neverPromptUserDefaultsKey];\n                                                    }\n                                                }];\n    static NSString *const identifier = @\"OfferToChangeOptionKeyToSendESC\";\n    [self queueAnnouncement:announcement identifier:identifier];\n}\n\n#pragma mark - iTermWorkingDirectoryPollerDelegate\n\n- (BOOL)useLocalDirectoryPollerResult {\n    if (_workingDirectoryPollerDisabled) {\n        DLog(@\"Working directory poller disabled\");\n        return NO;\n    }\n    if (_shouldExpectCurrentDirUpdates && ![iTermAdvancedSettingsModel disablePotentiallyInsecureEscapeSequences]) {\n        DLog(@\"Should not poll for working directory: shell integration used\");\n        return NO;\n    }\n    if (_screen.terminalSoftAlternateScreenMode) {\n        DLog(@\"Should not poll for working directory: soft alternate screen mode\");\n    }\n    DLog(@\"Should poll for working directory.\");\n    return YES;\n}\n\n- (BOOL)workingDirectoryPollerShouldPoll {\n    return YES;\n}\n\n- (pid_t)workingDirectoryPollerProcessID {\n    return _shell.pid;;\n}\n\n- (void)workingDirectoryPollerDidFindWorkingDirectory:(NSString *)pwd invalidated:(BOOL)invalidated {\n    DLog(@\"workingDirectoryPollerDidFindWorkingDirectory:%@ invalidated:%@ self=%@\", pwd, @(invalidated), self);\n    if (invalidated && _lastLocalDirectoryWasPushed && _lastLocalDirectory != nil) {\n        DLog(@\"Ignore local directory poller's invalidated result when we have a pushed last local directory. _lastLocalDirectory=%@ _lastLocalDirectoryWasPushed=%@\",\n             _lastLocalDirectory, @(_lastLocalDirectoryWasPushed));\n        return;\n    }\n    if (invalidated || ![self useLocalDirectoryPollerResult]) {\n        DLog(@\"Not creating a mark. invalidated=%@\", @(invalidated));\n        if (self.lastLocalDirectory != nil && self.lastLocalDirectoryWasPushed) {\n            DLog(@\"Last local directory (%@) was pushed, not changing it.\", self.lastLocalDirectory);\n            return;\n        }\n        DLog(@\"Since last local driectory was not pushed, update it.\");\n        // This is definitely a local directory. It may have been invalidated because we got a push\n        // for a remote directory, but it's still useful to know the local directory for the purposes\n        // of session restoration.\n        self.lastLocalDirectory = pwd;\n        self.lastLocalDirectoryWasPushed = NO;\n\n        // Do not call setLastDirectory:remote:pushed: because there's no sense updating the path\n        // variable for an invalidated update when we might have a better remote working directory.\n        //\n        // Update the proxy icon since it only cares about the local directory.\n        [_delegate sessionCurrentDirectoryDidChange:self];\n        return;\n    }\n\n    if (!pwd) {\n        DLog(@\"nil result. Don't create a mark\");\n        return;\n    }\n\n    // Updates the mark\n    DLog(@\"Will create a mark\");\n    const long absLine = _screen.lineNumberOfCursor + _screen.totalScrollbackOverflow;\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState setWorkingDirectory:pwd\n                                onAbsLine:absLine\n                                   pushed:NO\n                                    token:[[mutableState.setWorkingDirectoryOrderEnforcer newToken] autorelease]];\n    }];\n\n}\n\n#pragma mark - iTermStandardKeyMapperDelegate\n\n- (void)standardKeyMapperWillMapKey:(iTermStandardKeyMapper *)standardKeyMapper {\n    // Don't use terminalEncoding because it may not be initialized yet.\n    iTermStandardKeyMapperConfiguration *configuration = [[[iTermStandardKeyMapperConfiguration alloc] init] autorelease];\n\n    configuration.outputFactory = _screen.terminalOutput;\n    configuration.encoding = [iTermProfilePreferences unsignedIntegerForKey:KEY_CHARACTER_ENCODING inProfile:self.profile];\n    configuration.leftOptionKey = self.optionKey;\n    configuration.rightOptionKey = self.rightOptionKey;\n    configuration.screenlike = self.isTmuxClient;\n    standardKeyMapper.configuration = configuration;\n}\n\n#pragma mark - iTermTermkeyKeyMapperDelegate\n\n- (void)termkeyKeyMapperWillMapKey:(iTermTermkeyKeyMapper *)termkeyKeyMaper {\n    // Don't use terminalEncoding because it may not be initialized yet.\n    iTermTermkeyKeyMapperConfiguration configuration = {\n        .encoding = [iTermProfilePreferences unsignedIntegerForKey:KEY_CHARACTER_ENCODING inProfile:self.profile],\n        .leftOptionKey = self.optionKey,\n        .rightOptionKey = self.rightOptionKey,\n        .applicationCursorMode = _screen.terminalOutput.cursorMode,\n        .applicationKeypadMode = _screen.terminalOutput.keypadMode\n    };\n    termkeyKeyMaper.configuration = configuration;\n}\n\n#pragma mark - iTermBadgeLabelDelegate\n\n- (NSFont *)badgeLabelFontOfSize:(CGFloat)pointSize {\n    NSFontManager *fontManager = [NSFontManager sharedFontManager];\n    NSFont *font = [NSFont fontWithName:_badgeFontName size:pointSize];\n    if (!font) {\n        font = [NSFont fontWithName:@\"Helvetica\" size:pointSize];\n    }\n    if ([iTermAdvancedSettingsModel badgeFontIsBold]) {\n        font = [fontManager convertFont:font\n                            toHaveTrait:NSBoldFontMask];\n    }\n    return font;\n}\n\n- (NSSize)badgeLabelSizeFraction {\n    return _badgeLabelSizeFraction;\n}\n\n#pragma mark - iTermShortcutNavigationModeHandlerDelegate\n\n- (void (^)(void))shortcutNavigationActionForKeyEquivalent:(NSString *)characters {\n    return [[_textview contentNavigationShortcuts] objectPassingTest:^BOOL(iTermContentNavigationShortcut *shortcut, NSUInteger index, BOOL *stop) {\n        if (shortcut.view.terminating) {\n            return NO;\n        }\n        return [shortcut.keyEquivalent caseInsensitiveCompare:characters] == NSOrderedSame;\n    }].action;\n}\n\n- (void)shortcutNavigationDidComplete {\n    [_textview removeContentNavigationShortcuts];\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.shortcutNavigationMode = NO;\n    }];\n}\n\n- (void)shortcutNavigationDidBegin {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.shortcutNavigationMode = YES;\n    }];\n}\n\n#pragma mark - iTermCopyModeHandlerDelegate\n\n- (void)copyModeHandlerDidChangeEnabledState:(iTermCopyModeHandler *)handler NOT_COPY_FAMILY {\n    [_textview setNeedsDisplay:YES];\n    const BOOL enabled = handler.enabled;\n    if (enabled) {\n        [_textview.window makeFirstResponder:_textview];\n    } else {\n        if (self.haveAutoComposer) {\n            [_composerManager makeDropDownComposerFirstResponder];\n        }\n\n        if (_textview.selection.live) {\n            [_textview.selection endLiveSelection];\n        }\n        [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            [mutableState scheduleTokenExecution];\n        }];\n    }\n    [_composerManager setTemporarilyHidden:handler.enabled];\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        mutableState.copyMode = enabled;\n    }];\n}\n\n- (iTermCopyModeState *)copyModeHandlerCreateState:(iTermCopyModeHandler *)handler NOT_COPY_FAMILY {\n    iTermCopyModeState *state = [[[iTermCopyModeState alloc] init] autorelease];\n    state.coord = VT100GridCoordMake(_screen.cursorX - 1,\n                                     _screen.cursorY - 1 + _screen.numberOfScrollbackLines);\n    state.numberOfLines = _screen.numberOfLines;\n    state.textView = _textview;\n\n    if (_textview.selection.allSubSelections.count == 1) {\n        iTermSubSelection *sub = _textview.selection.allSubSelections.firstObject;\n        VT100GridAbsCoordRangeTryMakeRelative(sub.absRange.coordRange,\n                                              _screen.totalScrollbackOverflow,\n                                              ^(VT100GridCoordRange range) {\n            [_textview.window makeFirstResponder:_textview];\n            state.selecting = YES;\n            state.start = range.start;\n            state.coord = range.end;\n        });\n    }\n    [_textview scrollLineNumberRangeIntoView:VT100GridRangeMake(state.coord.y, 1)];\n    return state;\n}\n\n- (void)copyModeHandler:(iTermCopyModeHandler *)handler redrawLine:(int)line NOT_COPY_FAMILY {\n    [self.textview setNeedsDisplayOnLine:line];\n}\n\n- (void)copyModeHandlerShowFindPanel:(iTermCopyModeHandler *)handler {\n    [self showFindPanel];\n}\n\n- (void)copyModeHandler:(iTermCopyModeHandler *)handler revealLine:(int)line NOT_COPY_FAMILY {\n    [_textview scrollLineNumberRangeIntoView:VT100GridRangeMake(line, 1)];\n}\n\n- (void)copyModeHandlerCopySelection:(iTermCopyModeHandler *)handler NOT_COPY_FAMILY {\n    [_textview copySelectionAccordingToUserPreferences];\n}\n\n#pragma mark - iTermObject\n\n- (iTermBuiltInFunctions *)objectMethodRegistry {\n    if (!_methods) {\n        _methods = [[iTermBuiltInFunctions alloc] init];\n        iTermBuiltInMethod *method;\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"set_name\"\n                                            defaultValues:@{}\n                                                    types:@{ @\"name\": [NSString class] }\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(setNameWithCompletion:name:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"run_tmux_command\"\n                                            defaultValues:@{}\n                                                    types:@{ @\"command\": [NSString class] }\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(sendTmuxCommandWithCompletion:command:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"set_status_bar_component_unread_count\"\n                                            defaultValues:@{}\n                                                    types:@{ @\"identifier\": [NSString class],\n                                                             @\"count\": [NSNumber class] }\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(setStatusBarComponentUnreadCountWithCompletion:identifier:count:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"stop_coprocess\"\n                                            defaultValues:@{}\n                                                    types:@{}\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(stopCoprocessWithCompletion:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"get_coprocess\"\n                                            defaultValues:@{}\n                                                    types:@{}\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(getCoprocessWithCompletion:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"run_coprocess\"\n                                            defaultValues:@{}\n                                                    types:@{ @\"commandLine\": [NSString class],\n                                                             @\"mute\": [NSNumber class] }\n                                        optionalArguments:[NSSet setWithArray:@[ @\"mute\" ]]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(runCoprocessWithCompletion:commandLine:mute:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n\n        method = [[iTermBuiltInMethod alloc] initWithName:@\"add_annotation\"\n                                            defaultValues:@{}\n                                                    types:@{ @\"startX\": [NSNumber class],\n                                                             @\"startY\": [NSNumber class],\n                                                             @\"endX\": [NSNumber class],\n                                                             @\"endY\": [NSNumber class],\n                                                             @\"text\": [NSString class] }\n                                        optionalArguments:[NSSet set]\n                                                  context:iTermVariablesSuggestionContextSession\n                                                   target:self\n                                                   action:@selector(addAnnotationWithCompletion:startX:startY:endX:endY:text:)];\n        [_methods registerFunction:method namespace:@\"iterm2\"];\n    }\n    return _methods;\n}\n\n- (void)stopCoprocessWithCompletion:(void (^)(id, NSError *))completion {\n    if (![self hasCoprocess]) {\n        completion(@NO, nil);\n        return;\n    }\n    [self stopCoprocess];\n    completion(@YES, nil);\n}\n\n- (void)getCoprocessWithCompletion:(void (^)(id, NSError *))completion {\n    completion(_shell.coprocess.command, nil);\n}\n\n- (void)runCoprocessWithCompletion:(void (^)(id, NSError *))completion\n                       commandLine:(NSString *)command\n                            mute:(NSNumber *)muteNumber {\n    const BOOL mute = muteNumber ? muteNumber.boolValue : NO;\n    if (self.hasCoprocess) {\n        completion(@NO, nil);\n        return;\n    }\n    [self launchCoprocessWithCommand:command mute:mute];\n    completion(@YES, nil);\n}\n\n- (void)addAnnotationWithCompletion:(void (^)(id, NSError *))completion\n                             startX:(NSNumber *)startXNumber\n                             startY:(NSNumber *)startYNumber\n                               endX:(NSNumber *)endXNumber\n                               endY:(NSNumber *)endYNumber\n                               text:(NSString *)text {\n    const VT100GridAbsCoordRange range = VT100GridAbsCoordRangeMake(startXNumber.intValue,\n                                                                    startYNumber.longLongValue,\n                                                                    endXNumber.intValue,\n                                                                    endYNumber.longLongValue);\n    const long long maxY = _screen.totalScrollbackOverflow + _screen.numberOfLines;\n    if (startYNumber.integerValue > endYNumber.integerValue ||\n        startYNumber.integerValue < 0 ||\n        startYNumber.integerValue > maxY ||\n        endYNumber.integerValue < 0 ||\n        endYNumber.integerValue > maxY ||\n        (startYNumber.integerValue == endYNumber.integerValue && startXNumber.integerValue > endXNumber.integerValue)) {\n        NSError *error = [NSError errorWithDomain:@\"com.iterm2.add-annotation-command\"\n                                             code:0\n                                         userInfo:@{ NSLocalizedDescriptionKey: @\"Invalid range\" }];\n        completion(nil, error);\n        return;\n    }\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        [mutableState addNoteWithText:text inAbsoluteRange:range];\n    }];\n    completion(nil, nil);\n}\n\n- (void)setStatusBarComponentUnreadCountWithCompletion:(void (^)(id, NSError *))completion\n                                            identifier:(NSString *)identifier\n                                                 count:(NSNumber *)count {\n    [[iTermStatusBarUnreadCountController sharedInstance] setUnreadCountForComponentWithIdentifier:identifier\n                                                                                             count:count.integerValue\n                                                                                         sessionID:self.guid];\n    completion(nil, nil);\n}\n\n- (void)sendTmuxCommandWithCompletion:(void (^)(id, NSError *))completion\n                              command:(NSString *)command {\n    if (self.tmuxMode == TMUX_NONE || _tmuxController == nil) {\n        NSError *error = [NSError errorWithDomain:@\"com.iterm2.tmux-command\"\n                                             code:0\n                                         userInfo:@{ NSLocalizedDescriptionKey: @\"Not a tmux integration session\" }];\n        completion(nil, error);\n    }\n\n    [_tmuxController.gateway sendCommand:command\n                          responseTarget:self\n                        responseSelector:@selector(sendTmuxCommandMethodDidComplete:completion:)\n                          responseObject:completion\n                                   flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)sendTmuxCommandMethodDidComplete:(NSString *)result\n                              completion:(void (^)(id, NSError *))completion {\n    if (result) {\n        completion(result, nil);\n        return;\n    }\n\n    // Tmux responded with an error.\n    NSError *error = [NSError errorWithDomain:@\"com.iterm2.tmux-command\"\n                                         code:1\n                                     userInfo:@{ NSLocalizedDescriptionKey: @\"tmux error\" }];\n    completion(nil, error);\n}\n\n- (void)setNameWithCompletion:(void (^)(id, NSError *))completion\n                         name:(NSString *)name  {\n    [self setSessionSpecificProfileValues:@{ KEY_NAME: name ?: @\"\"}];\n    completion(nil, nil);\n}\n\n- (iTermVariableScope *)objectScope {\n    return self.variablesScope;\n}\n\n#pragma mark - iTermSubscribable\n\n- (NSString *)subscribableIdentifier {\n    return self.guid;\n}\n\n- (ITMNotificationResponse *)handleAPINotificationRequest:(ITMNotificationRequest *)request\n                                            connectionKey:(NSString *)connectionKey {\n    ITMNotificationResponse *response = [[[ITMNotificationResponse alloc] init] autorelease];\n    if (!request.hasSubscribe) {\n        response.status = ITMNotificationResponse_Status_RequestMalformed;\n        return response;\n    }\n\n    NSMutableDictionary<id, ITMNotificationRequest *> *subscriptions = nil;\n    switch (request.notificationType) {\n        case ITMNotificationType_NotifyOnPrompt:\n            subscriptions = _promptSubscriptions;\n            break;\n        case ITMNotificationType_NotifyOnKeystroke:\n            subscriptions = _keystrokeSubscriptions;\n            break;\n        case ITMNotificationType_KeystrokeFilter:\n            subscriptions = _keyboardFilterSubscriptions;\n            break;\n        case ITMNotificationType_NotifyOnScreenUpdate:\n            subscriptions = _updateSubscriptions;\n            break;\n        case ITMNotificationType_NotifyOnCustomEscapeSequence:\n            subscriptions = _customEscapeSequenceNotifications;\n            break;\n\n        case ITMNotificationType_NotifyOnVariableChange:  // Gets special handling before this method is called\n        case ITMNotificationType_NotifyOnNewSession:\n        case ITMNotificationType_NotifyOnTerminateSession:\n        case ITMNotificationType_NotifyOnLayoutChange:\n        case ITMNotificationType_NotifyOnFocusChange:\n        case ITMNotificationType_NotifyOnServerOriginatedRpc:\n        case ITMNotificationType_NotifyOnBroadcastChange:\n        case ITMNotificationType_NotifyOnProfileChange:\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n        case ITMNotificationType_NotifyOnLocationChange:\n#pragma clang diagnostic pop\n            // We won't get called for this\n            assert(NO);\n            break;\n    }\n    if (!subscriptions) {\n        response.status = ITMNotificationResponse_Status_RequestMalformed;\n        return response;\n    }\n    if (request.subscribe) {\n        if (subscriptions[connectionKey]) {\n            response.status = ITMNotificationResponse_Status_AlreadySubscribed;\n            return response;\n        }\n        subscriptions[connectionKey] = request;\n    } else {\n        if (!subscriptions[connectionKey]) {\n            response.status = ITMNotificationResponse_Status_NotSubscribed;\n            return response;\n        }\n        [subscriptions removeObjectForKey:connectionKey];\n    }\n\n    response.status = ITMNotificationResponse_Status_Ok;\n    return response;\n}\n\n#pragma mark - iTermLogging\n\n- (void)loggingHelperStart:(iTermLoggingHelper *)loggingHelper {\n    if (loggingHelper.style != iTermLoggingStyleHTML) {\n        return;\n    }\n\n    [loggingHelper logWithoutTimestamp:[NSData styleSheetWithFontFamily:self.textview.fontTable.asciiFont.font.familyName\n                                                               fontSize:self.textview.fontTable.asciiFont.font.pointSize\n                                                        backgroundColor:[_screen.colorMap colorForKey:kColorMapBackground]\n                                                              textColor:[_screen.colorMap colorForKey:kColorMapForeground]]];\n}\n\n- (void)loggingHelperStop:(iTermLoggingHelper *)loggingHelper {\n}\n\n- (NSString *)loggingHelperTimestamp:(iTermLoggingHelper *)loggingHelper {\n    if (![iTermAdvancedSettingsModel logTimestampsWithPlainText]) {\n        return nil;\n    }\n    switch (loggingHelper.style) {\n        case iTermLoggingStyleRaw:\n        case iTermLoggingStyleAsciicast:\n            return nil;\n\n        case iTermLoggingStylePlainText: {\n            static NSDateFormatter *dateFormatter;\n            static dispatch_once_t onceToken;\n            dispatch_once(&onceToken, ^{\n                dateFormatter = [[NSDateFormatter alloc] init];\n                dateFormatter.dateFormat = [NSDateFormatter dateFormatFromTemplate:@\"yyyy-MM-dd hh.mm.ss.SSS\"\n                                                                           options:0\n                                                                            locale:[NSLocale currentLocale]];\n            });\n            return [NSString stringWithFormat:@\"[%@] \", [dateFormatter stringFromDate:[NSDate date]]];\n        }\n\n        case iTermLoggingStyleHTML: {\n            // This is done during encoding.\n            return nil;\n        }\n    }\n}\n\n\n#pragma mark - iTermNaggingControllerDelegate\n\n- (BOOL)naggingControllerCanShowMessageWithIdentifier:(NSString *)identifier {\n    return ![self hasAnnouncementWithIdentifier:identifier];\n}\n\n- (void)naggingControllerShowMessage:(NSString *)message\n                          isQuestion:(BOOL)isQuestion\n                           important:(BOOL)important\n                          identifier:(NSString *)identifier\n                             options:(NSArray<NSString *> *)options\n                          completion:(void (^)(int))completion {\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:message\n                                                     style:isQuestion ? kiTermAnnouncementViewStyleQuestion : kiTermAnnouncementViewStyleWarning\n                                               withActions:options\n                                                completion:^(int selection) {\n        completion(selection);\n    }];\n    if (!important) {\n        announcement.dismissOnKeyDown = YES;\n    }\n    [self queueAnnouncement:announcement identifier:identifier];\n}\n\n- (void)naggingControllerRepairSavedArrangement:(NSString *)savedArrangementName\n                            missingProfileNamed:(NSString *)missingProfileName\n                                           guid:(NSString *)guid {\n    Profile *similarlyNamedProfile = [[ProfileModel sharedInstance] bookmarkWithName:missingProfileName];\n    [[iTermController sharedInstance] repairSavedArrangementNamed:savedArrangementName\n                                             replacingMissingGUID:guid\n                                                         withGUID:similarlyNamedProfile[KEY_GUID]];\n    [[NSNotificationCenter defaultCenter] postNotificationName:PTYSessionDidRepairSavedArrangement\n                                                        object:guid\n                                                      userInfo:@{ @\"new profile\": similarlyNamedProfile }];\n}\n\n- (void)naggingControllerRemoveMessageWithIdentifier:(NSString *)identifier {\n    [self dismissAnnouncementWithIdentifier:identifier];\n    [self removeAnnouncementWithIdentifier:identifier];\n}\n\n- (void)naggingControllerRestart {\n    [self replaceTerminatedShellWithNewInstance];\n}\n\n- (void)naggingControllerAbortDownload {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        [terminal stopReceivingFile];\n    }];\n}\n\n- (void)naggingControllerAbortUpload {\n    if (!self.upload) {\n        return;\n    }\n    [_pasteHelper abort];\n    [self.upload endOfData];\n    self.upload = nil;\n}\n\n- (void)naggingControllerSetBackgroundImageToFileWithName:(NSString *)filename {\n    [self setSessionSpecificProfileValues:@{ KEY_BACKGROUND_IMAGE_LOCATION: filename.length ? filename : [NSNull null] }];\n}\n\n- (void)naggingControllerDisableMouseReportingPermanently:(BOOL)permanently {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        if (permanently) {\n            if (self.isDivorced) {\n                [self setSessionSpecificProfileValues:@{ KEY_XTERM_MOUSE_REPORTING: @NO}];\n            } else {\n                [iTermProfilePreferences setBool:NO\n                                          forKey:KEY_XTERM_MOUSE_REPORTING\n                                       inProfile:self.profile\n                                           model:[ProfileModel sharedInstance]];\n                [[NSNotificationCenter defaultCenter] postNotificationName:kSessionProfileDidChange\n                                                                    object:self.profile[KEY_GUID]];\n            }\n        }\n        [terminal setMouseMode:MOUSE_REPORTING_NONE];\n    }];\n}\n\n- (void)naggingControllerDisableBracketedPasteMode {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal,\n                                             VT100ScreenMutableState *mutableState,\n                                             id<VT100ScreenDelegate> delegate) {\n        terminal.bracketedPasteMode = NO;\n    }];\n}\n\n- (void)naggingControllerCloseSession {\n    [_delegate closeSession:self];\n}\n\n- (void)naggingControllerRepairInitialWorkingDirectoryOfSessionWithGUID:(NSString *)guid\n                                                  inArrangementWithName:(NSString *)arrangementName {\n    NSOpenPanel* panel = [NSOpenPanel openPanel];\n    panel.canChooseFiles = NO;\n    panel.canChooseDirectories = YES;\n    panel.allowsMultipleSelection = NO;\n\n    if ([panel runModal] != NSModalResponseOK) {\n        return;\n    }\n    if (!panel.directoryURL.path) {\n        return;\n    }\n    [[iTermController sharedInstance] repairSavedArrangementNamed:arrangementName\n                        replaceInitialDirectoryForSessionWithGUID:guid\n                                                             with:panel.directoryURL.path];\n}\n\n- (void)naggingControllerDisableTriggersInInteractiveApps {\n    NSDictionary *update = @{ KEY_ENABLE_TRIGGERS_IN_INTERACTIVE_APPS: @NO };\n    if (self.isDivorced) {\n        [self setSessionSpecificProfileValues:update];\n        [[iTermNotificationController sharedInstance] notify:@\"Session Updated\"\n                                             withDescription:@\"Triggers disabled in interactive apps. You can change this in Edit Session > Advanced.\"];\n        return;\n    }\n\n    [iTermProfilePreferences setObjectsFromDictionary:update inProfile:self.profile model:[ProfileModel sharedInstance]];\n    [[iTermNotificationController sharedInstance] notify:@\"Profile Updated\"\n                                         withDescription:@\"Triggers disabled in interactive apps. You can change this in Prefs > Profiles > Advanced.\"];\n}\n\n#pragma mark - iTermComposerManagerDelegate\n\n- (iTermStatusBarViewController *)composerManagerStatusBarViewController:(iTermComposerManager *)composerManager {\n    return _statusBarViewController;\n}\n\n- (iTermVariableScope *)composerManagerScope:(iTermComposerManager *)composerManager {\n    return self.variablesScope;\n}\n\n- (NSView *)composerManagerContainerView:(iTermComposerManager *)composerManager {\n    return _view;\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager minimalFrameDidChangeTo:(NSRect)newFrame {\n    [_textview setNeedsDisplay:YES];\n    DLog(@\"Composer frame changed to %@\", NSStringFromRect(newFrame));\n}\n\n- (NSRect)composerManager:(iTermComposerManager *)composerManager\n    frameForDesiredHeight:(CGFloat)desiredHeight\n            previousFrame:(NSRect)previousFrame {\n    NSRect newFrame = previousFrame;\n    newFrame.origin.y = _view.frame.size.height;\n\n    newFrame.origin.y += newFrame.size.height;\n    const CGFloat maxWidth = _view.bounds.size.width - newFrame.origin.x * 2;\n    const CGFloat vmargin = [iTermPreferences intForKey:kPreferenceKeyTopBottomMargins];\n    const NSSize paneSize = self.view.frame.size;\n    CGFloat y = 0;\n    CGFloat width = 0;\n    CGFloat height = 0;\n\n    if (composerManager.isAutoComposer) {\n        // Place at bottom, but leave excess space below it so it abuts the terminal view.\n        width = maxWidth;\n        int lineAbove = _screen.currentGrid.cursor.y + 1;\n        id<VT100ScreenMarkReading> mark = _screen.lastPromptMark;\n        if (mark.promptRange.start.y >= 0) {\n            lineAbove = mark.promptRange.start.y - _screen.totalScrollbackOverflow - _screen.numberOfScrollbackLines;\n            lineAbove = MAX(1, lineAbove);\n        }\n        const int actualLinesAboveComposer = MAX(1, _screen.height - lineAbove);\n        const CGFloat lineHeight = _textview.lineHeight;\n        const int desiredLines = ceil(desiredHeight / lineHeight);\n        const int linesOfHeight = MIN(actualLinesAboveComposer, desiredLines);\n        const int gridOffsetInRows = _screen.height - linesOfHeight;\n        const CGFloat titleBarHeight = (_view.showTitle ? SessionView.titleHeight : 0);\n        height = (linesOfHeight + 0.5) * lineHeight;\n        const CGFloat gridOffsetInPoints = gridOffsetInRows * lineHeight;\n        const CGFloat top = vmargin + titleBarHeight + gridOffsetInPoints;\n        y = MAX(0, paneSize.height - top - height);\n\n        DLog(@\"width=%@ actualLinesFree=%@ gridOffsetInRows=%@ lineHeight=%@ titleBarHeight=%@ height=%@ gridOffsetInPoints=%@ top=%@ y=%@\",\n             @(width), @(actualLinesAboveComposer), @(gridOffsetInRows), @(lineHeight), @(titleBarHeight), @(height), @(gridOffsetInPoints), @(top), @(y));\n    } else {\n        // Place at top. Includes decoration so a minimum width must be enforced.\n\n        y = paneSize.height - desiredHeight;\n        width = MAX(217, maxWidth);\n        height = desiredHeight;\n    }\n    newFrame = NSMakeRect(newFrame.origin.x,\n                          y,\n                          width,\n                          height);\n    return newFrame;\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager desiredHeightDidChange:(CGFloat)desiredHeight {\n    DLog(@\"Desired height changed to %@\", @(desiredHeight));\n    [self sync];\n}\n\n- (BOOL)haveAutoComposer {\n    return _composerManager.dropDownComposerViewIsVisible && _composerManager.isAutoComposer;\n}\n\n- (void)screenWillSynchronize {\n}\n\n- (void)screenDidSynchronize {\n    [self updateAutoComposerFrame];\n}\n\n- (CGFloat)composerManagerLineHeight:(iTermComposerManager *)composerManager {\n    return _textview.lineHeight;\n}\n\n- (void)composerManagerClear:(iTermComposerManager *)composerManager {\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState clearForComposer];\n    }];\n}\n\n- (void)composerManagerOpenHistory:(iTermComposerManager *)composerManager\n                            prefix:(nonnull NSString *)prefix\n                         forSearch:(BOOL)forSearch {\n    [[_delegate realParentWindow] openCommandHistoryWithPrefix:prefix sortChronologically:!forSearch];\n}\n\n- (void)composerManagerDidRemoveTemporaryStatusBarComponent:(iTermComposerManager *)composerManager {\n    [_pasteHelper temporaryRightStatusBarComponentDidBecomeAvailable];\n    [_textview.window makeFirstResponder:_textview];\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager enqueueCommand:(NSString *)command {\n    if (self.currentCommand != nil && self.currentCommand.length == 0) {\n        // At shell prompt\n        [self sendCommand:command];\n        return;\n    }\n    // Send when next mark is received.\n    [_commandQueue addObject:[command copy]];\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager sendCommand:(NSString *)command {\n    [self sendCommand:command];\n}\n\n- (id<iTermSyntaxHighlighting>)composerManager:(iTermComposerManager *)composerManager\n          syntaxHighlighterForAttributedString:(NSMutableAttributedString *)attributedString {\n    return [[[iTermSyntaxHighlighter alloc] init:attributedString\n                                        colorMap:_screen.colorMap\n                                        fontTable:_textview.fontTable\n                                     fileChecker:[self fileChecker]] autorelease];\n}\n\n- (void)composerManagerDidBecomeFirstResponder:(iTermComposerManager *)composerManager {\n    _textViewShouldTakeFirstResponder = NO;\n}\n\n- (BOOL)composerManagerShouldFetchSuggestions:(iTermComposerManager *)composerManager\n                                      forHost:(id<VT100RemoteHostReading>)remoteHost\n                               tmuxController:(TmuxController *)tmuxController {\n    if (remoteHost.isRemoteHost) {\n        // Don't try to complete filenames if not on localhost unless we can ask the conductor.\n        if (@available(macOS 11, *)) {\n            return [_conductor framing];\n        } else {\n            return NO;\n        }\n    }\n    if (tmuxController) {\n        // I haven't implemented this on tmux because it's probably gonna be slow and knowing the\n        // working directory is rare.\n        return NO;\n    }\n    return YES;\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager\n       fetchSuggestions:(iTermSuggestionRequest *)request {\n    if (@available(macOS 11, *)) {\n        if ([_conductor framing]) {\n            [_conductor fetchSuggestions:request];\n        }\n    }\n    [[iTermSlowOperationGateway sharedInstance] findCompletionsWithPrefix:request.prefix\n                                                            inDirectories:request.directories\n                                                                      pwd:request.workingDirectory\n                                                                 maxCount:1\n                                                               executable:request.executable\n                                                               completion:^(NSArray<NSString *> * _Nonnull completions) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            request.completion(completions);\n        });\n    }];\n}\n\n- (iTermFileChecker *)fileChecker {\n    if (@available(macOS 11, *)) {\n        if (_conductor.canCheckFiles) {\n            return _conductor.fileChecker;\n        }\n    }\n    if (!_localFileChecker) {\n        _localFileChecker = [[iTermLocalFileChecker alloc] init];\n        if (self.lastLocalDirectory) {\n            _localFileChecker.workingDirectory = self.lastLocalDirectory;\n        }\n    }\n    return _localFileChecker;\n}\n\n- (void)sendCommand:(NSString *)command {\n    if (_screen.commandRange.start.x < 0) {\n        id<VT100RemoteHostReading> host = [self currentHost] ?: [VT100RemoteHost localhost];\n        [[iTermShellHistoryController sharedInstance] addCommand:command\n                                                          onHost:host\n                                                     inDirectory:[_screen workingDirectoryOnLine:_screen.commandRange.start.y]\n                                                        withMark:nil];\n    }\n    __weak __typeof(self) weakSelf = self;\n    if ([self haveAutoComposer]) {\n        if (_composerManager.haveShellProvidedText) {\n            // Send ^U first to erase what's already there.\n            // TODO: This may wreak havoc if the shell decides to redraw itself.\n            command = [[NSString stringWithLongCharacter:'U' - '@'] stringByAppendingString:command];\n        }\n        const BOOL detectedByTrigger = [_composerManager.prefixUserData[PTYSessionComposerPrefixUserDataKeyDetectedByTrigger] boolValue];\n        [_composerManager setPrefix:nil userData:nil];\n        [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n            DLog(@\"willSendCommand:%@\", command);\n            [mutableState composerWillSendCommand];\n            if (detectedByTrigger) {\n                [mutableState didSendCommand];\n            }\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [weakSelf reallySendCommand:command];\n            });\n        }];\n        DLog(@\"Dismiss composer and request redraw\");\n        [_composerManager dismissAnimated:NO];\n        [_textview setNeedsDisplay:YES];\n        return;\n    }\n    [self reallySendCommand:command];\n}\n\n- (void)reallySendCommand:(NSString *)command {\n    DLog(@\"reallySendCommand: %@\", command);\n    [self writeTask:command];\n    [_screen userDidPressReturn];\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager\n    sendToAdvancedPaste:(NSString *)command {\n    [self openAdvancedPasteWithText:command escaping:iTermSendTextEscapingNone];\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager\n            sendControl:(NSString *)control {\n    [self writeTask:control];\n}\n\n- (BOOL)composerManager:(iTermComposerManager *)composerManager wantsKeyEquivalent:(NSEvent *)event {\n    const NSEventModifierFlags mask = (NSEventModifierFlagOption |\n                                       NSEventModifierFlagCommand |\n                                       NSEventModifierFlagShift |\n                                       NSEventModifierFlagControl);\n    const NSEventModifierFlags cmdShift = (NSEventModifierFlagCommand | NSEventModifierFlagShift);\n    if ((event.modifierFlags & mask) == cmdShift) {\n        // Shortcut for mark navigation.\n        if (event.keyCode == kVK_UpArrow) {\n            [[self.delegate realParentWindow] previousMark:nil];\n            return YES;\n        } else if (event.keyCode == kVK_DownArrow) {\n            [[self.delegate realParentWindow] nextMark:nil];\n            return YES;\n        }\n    }\n    return NO;\n}\n\n- (void)composerManager:(iTermComposerManager *)composerManager performFindPanelAction:(id)sender {\n    [_textview performFindPanelAction:sender];\n}\n\n- (void)composerManagerWillDismissMinimalView:(iTermComposerManager *)composerManager {\n    [_textview.window makeFirstResponder:_textview];\n    _composerManager.isSeparatorVisible = NO;\n}\n\n- (void)composerManagerDidDisplayMinimalView:(iTermComposerManager *)composerManager {\n    [self updateAutoComposerSeparatorVisibility];\n}\n\n- (void)updateAutoComposerSeparatorVisibility {\n    _composerManager.isSeparatorVisible = [self shouldShowAutoComposerSeparator];\n    _composerManager.separatorColor = [iTermTextDrawingHelper colorForLineStyleMark:iTermMarkIndicatorTypeSuccess\n                                                                    backgroundColor:[_screen.colorMap colorForKey:kColorMapBackground]];\n}\n\n- (BOOL)shouldShowAutoComposerSeparator {\n    return self.haveAutoComposer;\n}\n\n- (void)composerManagerDidDismissMinimalView:(iTermComposerManager *)composerManager {\n    _view.composerHeight = 0;\n    [_localFileChecker reset];\n    if (@available(macOS 11, *)) {\n        [_conductor.fileChecker reset];\n    }\n}\n\n- (NSAppearance *)composerManagerAppearance:(iTermComposerManager *)composerManager {\n    NSColor *color = [_screen.colorMap colorForKey:kColorMapBackground];\n    if ([color isDark]) {\n        return [NSAppearance appearanceNamed:NSAppearanceNameDarkAqua];\n    }\n    return [NSAppearance appearanceNamed:NSAppearanceNameAqua];\n}\n\n- (id<VT100RemoteHostReading>)composerManagerRemoteHost:(iTermComposerManager *)composerManager {\n    return [self currentHost];\n}\n\n- (NSString * _Nullable)composerManagerWorkingDirectory:(iTermComposerManager *)composerManager {\n    return [self.variablesScope path];\n}\n\n- (NSString *)composerManagerShell:(iTermComposerManager *)composerManager {\n    return [self bestGuessAtUserShell];\n}\n\n- (NSString *)composerManagerUName:(iTermComposerManager *)composerManager {\n    return [self bestGuessAtUName];\n}\n\n- (TmuxController *)composerManagerTmuxController:(iTermComposerManager *)composerManager {\n    if (!self.isTmuxClient) {\n        return nil;\n    }\n    return self.tmuxController;\n}\n\n- (NSFont *)composerManagerFont:(iTermComposerManager *)composerManager {\n    return self.textview.fontTable.asciiFont.font;\n}\n\n- (NSColor *)composerManagerTextColor:(iTermComposerManager *)composerManager {\n    return [self.textview.colorMap colorForKey:kColorMapForeground];\n}\n\n- (NSColor *)composerManagerCursorColor:(iTermComposerManager *)composerManager {\n    return [self.textview.colorMap colorForKey:kColorMapCursor];\n}\n\n#pragma mark - iTermIntervalTreeObserver\n\n- (void)intervalTreeDidReset {\n    [iTermGCD assertMainQueueSafe];\n    if (![iTermAdvancedSettingsModel showLocationsInScrollbar]) {\n        return;\n    }\n    if (![iTermAdvancedSettingsModel showMarksInScrollbar]) {\n        return;\n    }\n    [self initializeMarksMinimap];\n}\n\n- (void)initializeMarksMinimap {\n    [_view.marksMinimap removeAllObjects];\n    const NSInteger count = (NSInteger)iTermIntervalTreeObjectTypeUnknown;\n    NSMutableDictionary<NSNumber *, NSMutableIndexSet *> *sets = [NSMutableDictionary dictionary];\n    [_screen enumerateObservableMarks:^(iTermIntervalTreeObjectType type, NSInteger line) {\n        NSMutableIndexSet *set = sets[@(type)];\n        if (!set) {\n            set = [NSMutableIndexSet indexSet];\n            sets[@(type)] = set;\n        }\n        [set addIndex:line];\n    }];\n    for (NSInteger i = 0; i < count; i++) {\n        [_view.marksMinimap setLines:sets[@(i)] ?: [NSMutableIndexSet indexSet]\n                             forType:i];\n    }\n}\n\n- (BOOL)minimapsTrackObjectsOfType:(iTermIntervalTreeObjectType)type {\n    switch (type) {\n        case iTermIntervalTreeObjectTypeSuccessMark:\n        case iTermIntervalTreeObjectTypeOtherMark:\n        case iTermIntervalTreeObjectTypeErrorMark:\n        case iTermIntervalTreeObjectTypeManualMark:\n        case iTermIntervalTreeObjectTypeAnnotation:\n        case iTermIntervalTreeObjectTypeUnknown:\n            return YES;\n        case iTermIntervalTreeObjectTypePorthole:\n            return NO;\n    }\n}\n- (void)intervalTreeDidAddObjectOfType:(iTermIntervalTreeObjectType)type\n                                onLine:(NSInteger)line {\n    [self addMarkToMinimapOfType:type onLine:line];\n}\n\n- (void)addMarkToMinimapOfType:(iTermIntervalTreeObjectType)type\n                                onLine:(NSInteger)line {\n    DLog(@\"Add at %@\", @(line));\n    [iTermGCD assertMainQueueSafe];\n    if (![iTermAdvancedSettingsModel showLocationsInScrollbar]) {\n        return;\n    }\n    if (![iTermAdvancedSettingsModel showMarksInScrollbar]) {\n        return;\n    }\n    if ([self minimapsTrackObjectsOfType:type]) {\n        [_view.marksMinimap addObjectOfType:type onLine:line];\n    }\n}\n\n- (void)intervalTreeDidHideObject:(id<IntervalTreeImmutableObject>)object\n                           ofType:(iTermIntervalTreeObjectType)type\n                           onLine:(NSInteger)line {\n    DLog(@\"Hide %@\", object);\n    PortholeMark *portholeMark = [PortholeMark castFrom:object];\n    if (portholeMark) {\n        id<Porthole> porthole = [[PortholeRegistry instance] objectForKeyedSubscript:portholeMark.uniqueIdentifier];\n        if (porthole) {\n            [_textview hidePorthole:porthole];\n        }\n    }\n    [self removeMarkFromMinimapOfType:type onLine:line];\n}\n\n- (void)intervalTreeDidUnhideObject:(id<IntervalTreeImmutableObject>)object\n                             ofType:(iTermIntervalTreeObjectType)type\n                             onLine:(NSInteger)line {\n    DLog(@\"Unhide %@\", object);\n    PortholeMark *portholeMark = [PortholeMark castFrom:object];\n    if (portholeMark) {\n        id<Porthole> porthole = [[PortholeRegistry instance] objectForKeyedSubscript:portholeMark.uniqueIdentifier];\n        if (porthole) {\n            [_textview unhidePorthole:porthole];\n        }\n    }\n    [self addMarkToMinimapOfType:type onLine:line];\n}\n\n- (void)intervalTreeDidRemoveObjectOfType:(iTermIntervalTreeObjectType)type\n                                   onLine:(NSInteger)line {\n    DLog(@\"Remove at %@\", @(line));\n    if (type == iTermIntervalTreeObjectTypePorthole) {\n        [_textview setNeedsPrunePortholes:YES];\n    }\n    [self removeMarkFromMinimapOfType:type onLine:line];\n}\n\n- (void)removeMarkFromMinimapOfType:(iTermIntervalTreeObjectType)type\n                             onLine:(NSInteger)line {\n    if (![iTermAdvancedSettingsModel showLocationsInScrollbar]) {\n        return;\n    }\n    if (![iTermAdvancedSettingsModel showMarksInScrollbar]) {\n        return;\n    }\n    if ([self minimapsTrackObjectsOfType:type]) {\n        [_view.marksMinimap removeObjectOfType:type fromLine:line];\n    }\n}\n\n- (void)intervalTreeVisibleRangeDidChange {\n     [iTermGCD assertMainQueueSafe];\n    [self updateMarksMinimapRangeOfVisibleLines];\n}\n\n- (void)intervalTreeDidMoveObjects:(NSArray<id<IntervalTreeImmutableObject>> *)objects {\n    [self.textview updatePortholeFrames];\n}\n\n- (void)updateMarksMinimapRangeOfVisibleLines {\n    if (![iTermAdvancedSettingsModel showLocationsInScrollbar]) {\n        return;\n    }\n    [_view.marksMinimap setFirstVisibleLine:_screen.totalScrollbackOverflow\n                       numberOfVisibleLines:_screen.numberOfLines];\n}\n\n#pragma mark - iTermTmuxControllerSession\n\n- (void)tmuxControllerSessionSetTTL:(NSTimeInterval)ttl redzone:(BOOL)redzone {\n    if (_tmuxPaused) {\n        return;\n    }\n    if (![iTermPreferences boolForKey:kPreferenceKeyTmuxWarnBeforePausing]) {\n        return;\n    }\n    if (_tmuxTTLHasThresholds) {\n        if (ttl > _tmuxTTLLowerThreshold && ttl < _tmuxTTLUpperThreshold) {\n            return;\n        }\n        if (ttl <= _tmuxTTLLowerThreshold) {\n            _tmuxTTLLowerThreshold = ttl - 1;\n            _tmuxTTLUpperThreshold = ttl + 1.5;\n        } else {\n            _tmuxTTLLowerThreshold = ttl - 1.5;\n            _tmuxTTLUpperThreshold = ttl + 1;\n        }\n    } else {\n        _tmuxTTLLowerThreshold = ttl - 1;\n        _tmuxTTLUpperThreshold = ttl + 1;\n        _tmuxTTLHasThresholds = YES;\n    }\n\n    NSTimeInterval rounded = round(ttl);\n    NSInteger safeTTL = 0;\n    if (rounded > NSIntegerMax || rounded != rounded) {\n        safeTTL = NSIntegerMax;\n    } else {\n        safeTTL = MAX(1, rounded);\n    }\n\n    if (!redzone) {\n        [self dismissAnnouncementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n        return;\n    }\n    NSString *title = [NSString stringWithFormat:@\"This session will pause in about %@ second%@ because it is buffering too much data.\", @(safeTTL), safeTTL == 1 ? @\"\" : @\"s\"];\n    iTermAnnouncementViewController *announcement = [self announcementWithIdentifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n    if (announcement) {\n        announcement.title = title;\n        [announcement.view setNeedsDisplay:YES];\n        [_view updateAnnouncementFrame];\n        return;\n    }\n    announcement =\n    [iTermAnnouncementViewController announcementWithTitle:title\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"_Pause Settings\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case 0:\n                [[PreferencePanel sharedInstance] openToPreferenceWithKey:kPreferenceKeyTmuxPauseModeAgeLimit];\n                break;\n        }\n    }];\n    announcement.dismissOnKeyDown = YES;\n    [self queueAnnouncement:announcement identifier:PTYSessionAnnouncementIdentifierTmuxPaused];\n}\n\n#pragma mark - iTermUniquelyIdentifiable\n\n- (NSString *)stringUniqueIdentifier {\n    return self.guid;\n}\n\n#pragma mark - iTermModifyOtherKeysMapperDelegate\n\n- (NSStringEncoding)modifiyOtherKeysDelegateEncoding:(iTermModifyOtherKeysMapper *)sender {\n    DLog(@\"encoding=%@\", @(_screen.terminalEncoding));\n    return _screen.terminalEncoding;\n}\n\n- (void)modifyOtherKeys:(iTermModifyOtherKeysMapper *)sender\ngetOptionKeyBehaviorLeft:(iTermOptionKeyBehavior *)left\n                  right:(iTermOptionKeyBehavior *)right {\n    *left = self.optionKey;\n    *right = self.rightOptionKey;\n    DLog(@\"left=%@ right=%@\", @(*left), @(*right));\n}\n\n- (VT100Output *)modifyOtherKeysOutputFactory:(iTermModifyOtherKeysMapper *)sender {\n    return _screen.terminalOutput;\n}\n\n- (BOOL)modifyOtherKeysTerminalIsScreenlike:(iTermModifyOtherKeysMapper *)sender {\n    DLog(@\"screenlike=%@\", @(self.isTmuxClient));\n    return self.isTmuxClient;\n}\n\n#pragma mark - iTermLegacyViewDelegate\n\n- (void)legacyView:(iTermLegacyView *)legacyView drawRect:(NSRect)dirtyRect {\n    [_textview drawRect:dirtyRect inView:legacyView];\n}\n\n#pragma mark - TriggerDelegate\n\n- (void)triggerChanged:(TriggerController *)triggerController newValue:(NSArray *)value {\n    [[triggerController.window undoManager] registerUndoWithTarget:self\n                                                          selector:@selector(setTriggersValue:)\n                                                            object:self.profile[KEY_TRIGGERS]];\n    [[triggerController.window undoManager] setActionName:@\"Edit Triggers\"];\n    [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS: value }];\n    triggerController.guid = self.profile[KEY_GUID];\n}\n\n- (void)setTriggersValue:(NSArray *)value {\n    [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS: value }];\n    _triggerWindowController.guid = self.profile[KEY_GUID];\n    [_triggerWindowController profileDidChange];\n}\n\n- (void)triggerSetUseInterpolatedStrings:(BOOL)useInterpolatedStrings {\n    [self setSessionSpecificProfileValues:@{ KEY_TRIGGERS_USE_INTERPOLATED_STRINGS: @(useInterpolatedStrings) }];\n    _triggerWindowController.guid = self.profile[KEY_GUID];\n}\n\n- (void)triggersCloseSheet {\n    [self closeTriggerWindowController];\n}\n\n- (void)triggersCopyToProfile {\n    [ProfileModel updateSharedProfileWithGUID:self.profile[KEY_ORIGINAL_GUID]\n                                    newValues:@{ KEY_TRIGGERS: self.profile[KEY_TRIGGERS],\n                                                 KEY_TRIGGERS_USE_INTERPOLATED_STRINGS: self.profile[KEY_TRIGGERS_USE_INTERPOLATED_STRINGS] }];\n}\n\n#pragma mark - iTermFilterDestination\n\n- (void)filterDestinationAppendCharacters:(const screen_char_t *)line\n                                    count:(int)count\n                   externalAttributeIndex:(iTermExternalAttributeIndex *)externalAttributeIndex\n                             continuation:(screen_char_t)continuation {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState appendScreenChars:line\n                                 length:count\n                 externalAttributeIndex:externalAttributeIndex\n                           continuation:continuation];\n    }];\n}\n\n- (void)filterDestinationRemoveLastLine {\n    [_screen performBlockWithJoinedThreads:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState removeLastLine];\n    }];\n}\n\n#pragma mark - iTermImmutableColorMapDelegate\n\n- (void)immutableColorMap:(id<iTermColorMapReading>)colorMap didChangeColorForKey:(iTermColorMapKey)theKey from:(NSColor *)before to:(NSColor *)after {\n    [_textview immutableColorMap:colorMap didChangeColorForKey:theKey from:before to:after];\n    [self setNeedsComposerColorUpdate:YES];\n}\n\n- (void)immutableColorMap:(id<iTermColorMapReading>)colorMap dimmingAmountDidChangeTo:(double)dimmingAmount {\n    [_textview immutableColorMap:colorMap dimmingAmountDidChangeTo:dimmingAmount];\n    [self setNeedsComposerColorUpdate:YES];\n\n}\n- (void)immutableColorMap:(id<iTermColorMapReading>)colorMap mutingAmountDidChangeTo:(double)mutingAmount {\n    [_textview immutableColorMap:colorMap mutingAmountDidChangeTo:mutingAmount];\n    [self setNeedsComposerColorUpdate:YES];\n}\n\n- (void)setNeedsComposerColorUpdate:(BOOL)needed {\n    if (_needsComposerColorUpdate && needed) {\n        return;\n    }\n    _needsComposerColorUpdate = needed;\n    if (needed) {\n        __weak __typeof(self) weakSelf = self;\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [weakSelf updateComposerColors];\n        });\n    }\n}\n\n- (void)updateComposerColors {\n    if (!_textview) {\n        return;\n    }\n    [self setNeedsComposerColorUpdate:NO];\n    if (![self haveAutoComposer]) {\n        return;\n    }\n    NSDictionary *userData = [NSDictionary castFrom:[_composerManager prefixUserData]];\n    if (!userData) {\n        return;\n    }\n    NSArray<ScreenCharArray *> *promptText = [NSArray castFrom:userData[PTYSessionComposerPrefixUserDataKeyPrompt]];\n    if (!promptText) {\n        return;\n    }\n    NSMutableAttributedString *prompt = [self kernedAttributedStringForScreenChars:promptText];\n    [_composerManager setPrefix:prompt userData:[_composerManager prefixUserData]];\n}\n\n// This can be completely async\n- (BOOL)toolbeltIsVisibleWithCapturedOutput {\n    if (!self.delegate.realParentWindow.shouldShowToolbelt) {\n        return NO;\n    }\n    return [iTermToolbeltView shouldShowTool:kCapturedOutputToolName];\n}\n\n- (void)showCapturedOutputTool {\n    if (!self.delegate.realParentWindow.shouldShowToolbelt) {\n        [self.delegate.realParentWindow toggleToolbeltVisibility:nil];\n    }\n    if (![iTermToolbeltView shouldShowTool:kCapturedOutputToolName]) {\n        [iTermToolbeltView toggleShouldShowTool:kCapturedOutputToolName];\n    }\n}\n\n- (void)performActionForCapturedOutput:(CapturedOutput *)capturedOutput {\n    __weak __typeof(self) weakSelf = self;\n    [capturedOutput.promisedCommand onQueue:dispatch_get_main_queue() then:^(NSString * _Nonnull command) {\n        [weakSelf reallyPerformActionForCapturedOutput:capturedOutput command:command];\n    }];\n}\n\n- (void)reallyPerformActionForCapturedOutput:(CapturedOutput *)capturedOutput\n                                     command:(NSString *)command {\n    [self launchCoprocessWithCommand:command\n                          identifier:nil\n                              silent:NO\n                        triggerTitle:@\"Captured Output trigger\"];\n    [self takeFocus];\n}\n\n#pragma mark - iTermTriggerSideEffectExecutor\n\n- (void)triggerSideEffectShowAlertWithMessage:(NSString *)message\n                                    rateLimit:(iTermRateLimitedUpdate *)rateLimit\n                                      disable:(void (^)(void))disable {\n    [iTermGCD assertMainQueueSafe];\n    __weak __typeof(self) weakSelf = self;\n    // Dispatch because it's not safe to start a runloop in a side-effect.\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [weakSelf reallyShowTriggerAlertWithMessage:message\n                                          rateLimit:rateLimit\n                                            disable:disable];\n    });\n}\n\n- (void)reallyShowTriggerAlertWithMessage:(NSString *)message\n                                rateLimit:(iTermRateLimitedUpdate *)rateLimit\n                                  disable:(void (^)(void))disable {\n    __weak __typeof(self) weakSelf = self;\n    [rateLimit performRateLimitedBlock:^{\n        NSAlert *alert = [[[NSAlert alloc] init] autorelease];\n        alert.messageText = message ?: @\"\";\n        [alert addButtonWithTitle:@\"OK\"];\n        [alert addButtonWithTitle:@\"Show Session\"];\n        [alert addButtonWithTitle:@\"Disable This Alert\"];\n        switch ([alert runModal]) {\n            case NSAlertFirstButtonReturn:\n                break;\n\n            case NSAlertSecondButtonReturn: {\n                [weakSelf reveal];\n                break;\n            }\n\n            case NSAlertThirdButtonReturn:\n                disable();\n                break;\n\n            default:\n                break;\n        }\n    }];\n}\n\n- (void)triggerSideEffectShowCapturedOutputTool {\n    [iTermGCD assertMainQueueSafe];\n    [self showCapturedOutputTool];\n}\n\n- (void)triggerSideEffectShowCapturedOutputToolNotVisibleAnnouncementIfNeeded {\n    [iTermGCD assertMainQueueSafe];\n    if ([self toolbeltIsVisibleWithCapturedOutput]) {\n        return;\n    }\n\n    if ([[NSUserDefaults standardUserDefaults] boolForKey:kSuppressCaptureOutputToolNotVisibleWarning]) {\n        return;\n    }\n\n    if ([self hasAnnouncementWithIdentifier:kSuppressCaptureOutputToolNotVisibleWarning]) {\n        return;\n    }\n    NSString *theTitle = @\"A Capture Output trigger fired, but the Captured Output tool is not visible.\";\n    void (^completion)(int selection) = ^(int selection) {\n        switch (selection) {\n            case -2:\n                break;\n\n            case 0:\n                [self showCapturedOutputTool];\n                break;\n\n            case 1:\n                [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                        forKey:kSuppressCaptureOutputToolNotVisibleWarning];\n                break;\n        }\n    };\n    iTermAnnouncementViewController *announcement =\n        [iTermAnnouncementViewController announcementWithTitle:theTitle\n                                                         style:kiTermAnnouncementViewStyleWarning\n                                                   withActions:@[ @\"Show It\", @\"Silence Warning\" ]\n                                                    completion:completion];\n    announcement.dismissOnKeyDown = YES;\n    [self queueAnnouncement:announcement\n                 identifier:kSuppressCaptureOutputToolNotVisibleWarning];\n}\n\n- (void)triggerSideEffectShowShellIntegrationRequiredAnnouncement {\n    [iTermGCD assertMainQueueSafe];\n    if ([[NSUserDefaults standardUserDefaults] boolForKey:kSuppressCaptureOutputRequiresShellIntegrationWarning]) {\n        return;\n    }\n    NSString *theTitle = @\"A Capture Output trigger fired, but Shell Integration is not installed.\";\n    void (^completion)(int selection) = ^(int selection) {\n        switch (selection) {\n            case -2:\n                break;\n\n            case 0:\n                [self tryToRunShellIntegrationInstallerWithPromptCheck:NO];\n                break;\n\n            case 1:\n                [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                        forKey:kSuppressCaptureOutputRequiresShellIntegrationWarning];\n                break;\n        }\n    };\n    iTermAnnouncementViewController *announcement =\n        [iTermAnnouncementViewController announcementWithTitle:theTitle\n                                                         style:kiTermAnnouncementViewStyleWarning\n                                                   withActions:@[ @\"Install\", @\"Silence Warning\" ]\n                                                    completion:completion];\n    [self queueAnnouncement:announcement\n                 identifier:kTwoCoprocessesCanNotRunAtOnceAnnouncementIdentifier];\n}\n\n- (void)triggerSideEffectDidCaptureOutput {\n    [iTermGCD assertMainQueueSafe];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kPTYSessionCapturedOutputDidChange\n                                                        object:nil];\n\n}\n\n- (void)triggerSideEffectLaunchCoprocessWithCommand:(NSString * _Nonnull)command\n                                         identifier:(NSString * _Nullable)identifier\n                                             silent:(BOOL)silent\n                                       triggerTitle:(NSString * _Nonnull)triggerName {\n    [iTermGCD assertMainQueueSafe];\n    [self launchCoprocessWithCommand:command identifier:identifier silent:silent triggerTitle:triggerName];\n}\n\n- (void)launchCoprocessWithCommand:(NSString * _Nonnull)command\n                        identifier:(NSString * _Nullable)identifier\n                            silent:(BOOL)silent\n                      triggerTitle:(NSString * _Nonnull)triggerName {\n    if (self.hasCoprocess) {\n        if (identifier && [[NSUserDefaults standardUserDefaults] boolForKey:identifier]) {\n            return;\n        }\n        NSString *message = [NSString stringWithFormat:@\"%@: Can't run two coprocesses at once.\", triggerName];\n        NSArray<NSString *> *actions = identifier ? @[ @\"Silence Warning\" ] : @[];\n        iTermAnnouncementViewController *announcement =\n        [iTermAnnouncementViewController announcementWithTitle:message\n                                                         style:kiTermAnnouncementViewStyleWarning\n                                                   withActions:actions\n                                                    completion:^(int selection) {\n            if (!identifier) {\n                return;\n            }\n            switch (selection) {\n                case 0:\n                    [[NSUserDefaults standardUserDefaults] setBool:YES\n                                                            forKey:identifier];\n                    break;\n            }\n        }];\n        [self queueAnnouncement:announcement\n                     identifier:kTwoCoprocessesCanNotRunAtOnceAnnouncementIdentifier];\n    } else if (command) {\n        if (silent) {\n            [self launchSilentCoprocessWithCommand:command];\n        } else {\n            [self launchCoprocessWithCommand:command];\n        }\n    }\n}\n\n- (void)triggerSideEffectPostUserNotificationWithMessage:(NSString * _Nonnull)message {\n    [iTermGCD assertMainQueueSafe];\n    iTermNotificationController *notificationController = [iTermNotificationController sharedInstance];\n    [notificationController notify:message\n                   withDescription:[NSString stringWithFormat:@\"A trigger fired in session \\\"%@\\\" in tab #%d.\",\n                                    [[self name] removingHTMLFromTabTitleIfNeeded],\n                                    self.delegate.tabNumber]\n                       windowIndex:[self screenWindowIndex]\n                          tabIndex:[self screenTabIndex]\n                         viewIndex:[self screenViewIndex]];\n}\n\n// Scroll so that `absLine` is the last visible onscreen.\n- (void)triggerSideEffectStopScrollingAtLine:(long long)absLine {\n    [iTermGCD assertMainQueueSafe];\n    const long long line = absLine - _screen.totalScrollbackOverflow;\n    if (line < 0) {\n        return;\n    }\n    const int height = MAX(1, _screen.height);\n    const int top = MAX(0, line - height + 1);\n    if (_screen.numberOfLines < line) {\n        return;\n    }\n    [_textview scrollLineNumberRangeIntoView:VT100GridRangeMake(top, height)];\n    [[self.view.scrollview ptyVerticalScroller] setUserScroll:YES];\n}\n\n- (void)triggerSideEffectOpenPasswordManagerToAccountName:(NSString * _Nullable)accountName {\n    [iTermGCD assertMainQueueSafe];\n    // Dispatch because you can't have a runloop in a side-effect and the password manager is a bunch of modal UI - why take chances?\n    dispatch_async(dispatch_get_main_queue(), ^{\n        iTermApplicationDelegate *itad = [iTermApplication.sharedApplication delegate];\n        [itad openPasswordManagerToAccountName:accountName\n                                         inSession:self];\n    });\n}\n\n- (void)triggerSideEffectRunBackgroundCommand:(NSString *)command pool:(iTermBackgroundCommandRunnerPool *)pool {\n    [iTermGCD assertMainQueueSafe];\n    iTermBackgroundCommandRunner *runner = [pool requestBackgroundCommandRunnerWithTerminationBlock:nil];\n    runner.command = command;\n    runner.title = @\"Run Command Trigger\";\n    runner.notificationTitle = @\"Run Command Trigger Failed\";\n    runner.shell = self.userShell;\n    [runner run];\n}\n\n- (void)triggerWriteTextWithoutBroadcasting:(NSString * _Nonnull)text {\n    [self writeTaskNoBroadcast:text];\n}\n\n- (iTermVariableScope *)triggerSideEffectVariableScope {\n    [iTermGCD assertMainQueueSafe];\n    return self.variablesScope;\n}\n\n- (void)triggerSideEffectSetTitle:(NSString * _Nonnull)newName {\n    [iTermGCD assertMainQueueSafe];\n    [self.variablesScope setValuesFromDictionary:@{ iTermVariableKeySessionTriggerName: newName,\n                                                    iTermVariableKeySessionAutoNameFormat: newName }];\n    if (newName.length > 0) {\n        [self enableSessionNameTitleComponentIfPossible];\n    }\n}\n\n- (void)triggerSideEffectInvokeFunctionCall:(NSString * _Nonnull)invocation\n                              withVariables:(NSDictionary * _Nonnull)temporaryVariables\n                                   captures:(NSArray<NSString *> * _Nonnull)captureStringArray\n                                    trigger:(Trigger * _Nonnull)trigger {\n    [iTermGCD assertMainQueueSafe];\n    iTermVariableScope *scope =\n    [self.variablesScope variableScopeByAddingBackreferences:captureStringArray\n                                                       owner:trigger];\n    [scope setValuesFromDictionary:temporaryVariables];\n    [self invokeFunctionCall:invocation scope:scope origin:@\"Trigger\"];\n}\n\n- (void)triggerSideEffectSetValue:(id _Nullable)value\n                 forVariableNamed:(NSString * _Nonnull)name {\n    [iTermGCD assertMainQueueSafe];\n    [self.genericScope setValue:value forVariableNamed:name];\n}\n\n- (void)triggerSideEffectCurrentDirectoryDidChange:(NSString *)newPath {\n    [iTermGCD assertMainQueueSafe];\n    [self didUpdateCurrentDirectory:newPath];\n}\n\n#pragma mark - iTermPasteboardReporterDelegate\n\n- (void)pasteboardReporter:(iTermPasteboardReporter *)sender reportPasteboard:(NSString *)pasteboard {\n    NSData *data = [_screen.terminalOutput reportPasteboard:pasteboard\n                                                   contents:[NSString stringFromPasteboard]];\n    [self screenSendReportData:data];\n    [_view showUnobtrusiveMessage:[NSString stringWithFormat:@\"Clipboard contents reported\"]\n                         duration:3];\n}\n\n- (void)pasteboardReporterRequestPermission:(iTermPasteboardReporter *)sender\n                                 completion:(void (^)(BOOL, BOOL))completion {\n    iTermAnnouncementViewController *announcement =\n    [iTermAnnouncementViewController announcementWithTitle:@\"Share clipboard contents with app in terminal?\"\n                                                     style:kiTermAnnouncementViewStyleWarning\n                                               withActions:@[ @\"Just Once\", @\"Always\", @\"Never\" ]\n                                                completion:^(int selection) {\n        switch (selection) {\n            case 0:\n                completion(YES, NO);\n                break;\n\n            case 1:\n                completion(YES, YES);\n                break;\n\n            case 2:\n                // Never\n                completion(NO, YES);\n                break;\n\n            default:\n                // Cancel\n                completion(NO, NO);\n                break;\n        }\n    }];\n    [self queueAnnouncement:announcement identifier:[[NSUUID UUID] UUIDString]];\n}\n\n#pragma mark - iTermConductorDelegate\n\n- (void)conductorWriteString:(NSString *)string {\n    DLog(@\"Conductor write: %@\", string);\n    [self writeTaskNoBroadcast:string];\n}\n\n- (void)conductorWillDie {\n    DLog(@\"conductorWillDie\");\n    iTermPublisher<NSNumber *> *replacement = _conductor.parent.cpuUtilizationPublisher;\n    if (!replacement) {\n        replacement = [iTermLocalCPUUtilizationPublisher sharedInstance];\n    }\n    [[iTermCPUUtilization instanceForSessionID:_guid] setPublisher:replacement];\n}\n\n- (void)conductorDidUnhook {\n    [self conductorWillDie];\n}\n\n- (void)conductorAbortWithReason:(NSString *)reason {\n    XLog(@\"conductor aborted: %@\", reason);\n    [self conductorWillDie];\n\n    NSString *location = _conductor.parent.sshIdentity.compactDescription;\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState appendStringAtCursor:@\"An error occurred while setting up the SSH environment:\"];\n        [mutableState appendCarriageReturnLineFeed];\n        [mutableState appendStringAtCursor:reason];\n        [mutableState appendCarriageReturnLineFeed];\n        NSString *message = [mutableState sshEndBannerTerminatingCount:1 newLocation:location];\n        [mutableState appendBannerMessage:message];\n    }];\n    [self unhookSSHConductor];\n}\n\n- (void)conductorQuit {\n    DLog(@\"conductorQuit\");\n    [self conductorWillDie];\n    NSString *identity = _conductor.sshIdentity.description;\n    [_screen mutateAsynchronously:^(VT100Terminal *terminal, VT100ScreenMutableState *mutableState, id<VT100ScreenDelegate> delegate) {\n        [mutableState appendBannerMessage:[NSString stringWithFormat:@\"Disconnected from %@\", identity]];\n    }];\n    [self unhookSSHConductor];\n    [_sshWriteQueue setLength:0];\n}\n\n- (void)conductorStateDidChange {\n    DLog(@\"conductorDidExfiltrateState\");\n    [self updateVariablesFromConductor];\n}\n\n- (void)updateVariablesFromConductor {\n    if (!_conductor) {\n        self.variablesScope.homeDirectory = NSHomeDirectory();\n        self.variablesScope.sshIntegrationLevel = 0;\n        self.variablesScope.shell = [self bestGuessAtUserShell];\n        self.variablesScope.uname = [self bestGuessAtUName];\n        return;\n    }\n    const NSInteger level = _conductor.framing ? 2 : 1;\n    self.variablesScope.sshIntegrationLevel = level;\n    switch (level) {\n        case 0: {\n            const BOOL onLocalhost = (self.currentHost == nil || self.currentHost.isLocalhost);\n            if (onLocalhost) {\n                self.variablesScope.homeDirectory = NSHomeDirectory();\n                break;\n            }\n            // SSHed without integration\n            self.variablesScope.homeDirectory = nil;\n            self.variablesScope.shell = nil;\n            self.variablesScope.uname = nil;\n            break;\n        }\n        case 1:\n            // Definitely ssh'ed, but no way to get this info.\n            self.variablesScope.homeDirectory = nil;\n            self.variablesScope.shell = nil;\n            self.variablesScope.uname = nil;\n            break;\n        case 2:\n            self.variablesScope.homeDirectory = _conductor.homeDirectory;\n            self.variablesScope.shell = _conductor.shell;\n            self.variablesScope.uname = _conductor.uname;\n            break;\n    }\n}\n\n@end\n", "//\n//  TmuxController.h\n//  iTerm\n//\n//  Created by George Nachman on 11/27/11.\n//\n\n#import <Cocoa/Cocoa.h>\n#import \"ProfileModel.h\"\n#import \"iTermInitialDirectory.h\"\n#import \"iTermTmuxSessionObject.h\"\n#import \"TmuxGateway.h\"\n#import \"WindowControllerInterface.h\"\n\n@class iTermFontTable;\n@class iTermVariableScope;\n@class PTYSession;\n@class PTYTab;\n@class PseudoTerminal;\n@class EquivalenceClassSet;\n\n// Posted just before sessions change (names, addition, deletion)\nextern NSString *const kTmuxControllerSessionsWillChange;\n// Posted when sessions change (names, addition, deletion)\nextern NSString *const kTmuxControllerSessionsDidChange;\n// Posted after detaching\nextern NSString *const kTmuxControllerDetachedNotification;\n// Posted when a window changes.\nextern NSString *const kTmuxControllerWindowsChangeNotification;\n// Posted when a window changes name\nextern NSString *const kTmuxControllerWindowWasRenamed;\n// Posted when a window opens\nextern NSString *const kTmuxControllerWindowDidOpen;\n// Posted when a window closes\nextern NSString *const kTmuxControllerWindowDidClose;\n// Posted when the attached session changes\nextern NSString *const kTmuxControllerAttachedSessionDidChange;\n// Posted when a session changes name\nextern NSString *const kTmuxControllerSessionWasRenamed;\n// Posted when set-titles option changes. Object is tmux controller.\nextern NSString *const kTmuxControllerDidFetchSetTitlesStringOption;\n// Posted before sending kill-window\nextern NSString *const iTermTmuxControllerWillKillWindow;\n// Posted when one or more windows changes hidden status\nextern NSString *const kTmuxControllerDidChangeHiddenWindows;\n\n@protocol iTermTmuxControllerSession<NSObject>\n- (void)tmuxControllerSessionSetTTL:(NSTimeInterval)ttl redzone:(BOOL)redzone;\n- (void)revealIfTabSelected;\n@end\n\n@interface TmuxController : NSObject\n\n@property(nonatomic, readonly) TmuxGateway *gateway;\n@property(nonatomic, retain) NSMutableDictionary *windowPositions;\n@property(nonatomic, copy) NSString *sessionName;\n@property(nonatomic, copy) NSArray<iTermTmuxSessionObject *> *sessionObjects;\n@property(nonatomic, assign) BOOL ambiguousIsDoubleWidth;\n@property(nonatomic, assign) NSInteger unicodeVersion;\n@property(nonatomic, readonly) NSString *clientName;\n@property(nonatomic, readonly) int sessionId;\n@property(nonatomic, readonly) BOOL hasOutstandingWindowResize;\n@property(nonatomic, readonly, getter=isAttached) BOOL attached;\n@property(nonatomic, readonly) BOOL detaching;\n@property(nonatomic, copy) Profile *sharedProfile;\n@property(nonatomic, readonly) NSDictionary *sharedFontOverrides;\n@property(nonatomic, readonly) NSDictionary *sharedKeyMappingOverrides;\n@property(nonatomic, readonly) NSString *sessionGuid;\n@property(nonatomic, readonly) BOOL variableWindowSize;\n@property(nonatomic, readonly) BOOL shouldSetTitles;\n@property(nonatomic, readonly) BOOL serverIsLocal;\n@property(nonatomic, readonly) NSString *defaultTerminal;\n@property(nonatomic) NSRect initialWindowHint;\n@property(nonatomic, readonly) BOOL detached;\n@property(nonatomic, readonly) NSArray<NSNumber *> *windowPaneIDs;\n\n- (instancetype)initWithGateway:(TmuxGateway *)gateway\n                     clientName:(NSString *)clientName\n                        profile:(Profile *)profile\n                   profileModel:(ProfileModel *)profileModel NS_DESIGNATED_INITIALIZER;\n- (instancetype)init NS_UNAVAILABLE;\n\n- (Profile *)profileForWindow:(int)window;\n- (NSString *)perWindowSettingsForWindowWithGUID:(NSString *)terminalGUID;\n- (NSString *)perTabSettingsForTabWithWindowID:(int)wid;\n- (NSDictionary *)fontOverridesForWindow:(int)window;\n\n- (void)openWindowsInitial;\n\n- (void)openWindowWithId:(int)windowId\n\t\t\t intentional:(BOOL)intentional\n                 profile:(Profile *)profile;\n\n- (void)openWindowWithId:(int)windowId\n\t\t\t  affinities:(NSArray *)affinities\n\t\t\t intentional:(BOOL)intentional\n                 profile:(Profile *)profile;\n\n- (void)hideWindow:(int)windowId;\n\n// Modifies a native tab to match the given server layout.\n// Returns YES if you should call adjustWindowSizeIfNeededForTabs: after all tabs have been updated.\n- (BOOL)setLayoutInTab:(PTYTab *)tab\n              toLayout:(NSString *)layout\n         visibleLayout:(NSString *)visibleLayout\n                zoomed:(NSNumber *)zoomed;\n- (void)adjustWindowSizeIfNeededForTabs:(NSArray<PTYTab *> *)tabs;\n\n- (void)sessionChangedTo:(NSString *)newSessionName sessionId:(int)sessionid;\n- (void)sessionsChanged;\n- (void)session:(int)sessionId renamedTo:(NSString *)newName;\n- (void)windowsChanged;\n- (void)windowWasRenamedWithId:(int)id to:(NSString *)newName;\n\n// Call `block` when a window pane with `wp` is registered. If one is already registered, it will be called asynchronously.\n- (void)whenPaneRegistered:(int)wp call:(void (^)(PTYSession<iTermTmuxControllerSession> *))block;\n\n- (PTYSession<iTermTmuxControllerSession> *)sessionForWindowPane:(int)windowPane;\n- (PTYTab *)window:(int)window;\n- (NSArray<PTYSession<iTermTmuxControllerSession> *> *)sessionsInWindow:(int)window;\n- (void)registerSession:(PTYSession<iTermTmuxControllerSession> *)aSession\n               withPane:(int)windowPane\n               inWindow:(int)window;\n- (void)deregisterWindow:(int)window windowPane:(int)windowPane session:(id)session;\n- (void)changeWindow:(int)window tabTo:(PTYTab *)tab;\n- (NSValue *)positionForWindowWithPanes:(NSArray *)panes windowID:(int)windowID;\n\n// This should be called after the host sends an %exit command.\n- (void)detach;\n- (void)windowDidResize:(NSWindowController<iTermWindowController> *)term;\n- (void)fitLayoutToWindows;\n- (void)validateOptions;\n- (void)ping;\n- (void)sendControlC;\n- (void)enablePauseModeIfPossible;\n- (void)unpausePanes:(NSArray<NSNumber *> *)wps;\n- (void)pausePanes:(NSArray<NSNumber *> *)wps;\n- (void)didPausePane:(int)wp;\n\n// Issue tmux commands to infer bounds on the version.\n- (void)guessVersion;\n- (void)loadTitleFormat;\n\n- (void)setClientSize:(NSSize)size;\n- (void)windowPane:(int)wp\n         resizedBy:(int)amount\n      horizontally:(BOOL)wasHorizontal;\n\n// If completion is nonnull it will be called with the new window pane or -1 on error.\n- (void)splitWindowPane:(int)wp\n             vertically:(BOOL)splitVertically\n                  scope:(iTermVariableScope *)scope\n       initialDirectory:(iTermInitialDirectory *)initialDirectory\n             completion:(void (^)(int wp))completion;\n\n- (void)newWindowInSessionNumber:(NSNumber *)sessionNumber\n                           scope:(iTermVariableScope *)scope\n                initialDirectory:(iTermInitialDirectory *)initialDirectory;\n\n- (void)selectPane:(int)windowPane;\n\n- (PseudoTerminal *)windowWithAffinityForWindowId:(int)wid;\n- (NSSet<NSObject<NSCopying> *> *)savedAffinitiesForWindow:(NSString *)value;\n- (NSSize)sizeOfSmallestWindowAmong:(NSSet<NSString *> *)siblings;\n\n// nil: Open in a new window\n// A string of a non-negative integer (e.g., @\"2\") means to open alongside a tmux window with that ID\n// A string of a negative integer (e.g., @\"-2\") means to open in an iTerm2 window with abs(windowId)==window number.\n// If affinity is given then the newly created tab will be considered \"manually opened\" which is\n// used to determine the tab's eventual location in the tabbar.\n- (void)newWindowWithAffinity:(NSString *)windowIdString\n                         size:(NSSize)size\n             initialDirectory:(iTermInitialDirectory *)initialDirectory\n                        index:(NSNumber *)index\n                        scope:(iTermVariableScope *)scope\n                   completion:(void (^)(int))completion;\n\n- (void)movePane:(int)srcPane\n        intoPane:(int)destPane\n      isVertical:(BOOL)splitVertical\n          before:(BOOL)addBefore;\n- (void)breakOutWindowPane:(int)windowPane toPoint:(NSPoint)screenPoint;\n- (void)breakOutWindowPane:(int)windowPane toTabAside:(NSString *)sibling;\n\n- (void)killWindowPane:(int)windowPane;\n- (void)killWindow:(int)window;\n- (void)unlinkWindowWithId:(int)windowId;\n- (void)requestDetach;\n- (void)renameWindowWithId:(int)windowId\n           inSessionNumber:(NSNumber *)sessionNumber\n                    toName:(NSString *)newName;\n\n// Rename the window and save in tmux server setting.\n- (void)setWindowTitleOverride:(NSString *)title\n                        window:(int)windowId;\n- (BOOL)canRenamePane;\n- (void)renamePane:(int)windowPane toTitle:(NSString *)newTitle;\n- (void)setHotkeyForWindowPane:(int)windowPane to:(NSDictionary *)hotkey;\n- (NSDictionary *)hotkeyForWindowPane:(int)windowPane;\n\n- (void)setTabColorString:(NSString *)colorString forWindowPane:(int)windowPane;\n- (NSString *)tabColorStringForWindowPane:(int)windowPane;\n\n- (void)linkWindowId:(int)windowId\n     inSessionNumber:(int)sessionNumber\n     toSessionNumber:(int)targetSession;\n\n- (void)moveWindowId:(int)windowId\n     inSessionNumber:(int)sessionNumber\n     toSessionNumber:(int)targetSessionNumber;\n\n- (void)renameSessionNumber:(int)sessionNumber\n                         to:(NSString *)newName;\n\n- (void)killSessionNumber:(int)sessionNumber;\n- (void)attachToSessionWithNumber:(int)sessionNumber;\n- (void)addSessionWithName:(NSString *)sessionName;\n// NOTE: If anything goes wrong the selector will not be called.\n- (void)listWindowsInSessionNumber:(int)sessionNumber\n                            target:(id)target\n                          selector:(SEL)selector\n                            object:(id)object;\n\n- (void)listSessions;\n- (void)saveAffinities;\n- (void)saveWindowOrigins;\n- (void)saveHiddenWindows;\n- (void)savePerWindowSettings;\n- (void)savePerTabSettings;\n\n- (void)swapPane:(int)pane1 withPane:(int)pane2;\n- (void)toggleZoomForPane:(int)pane;\n- (void)setPartialWindowIdOrder:(NSArray *)partialOrder;\n- (void)setCurrentWindow:(int)windowId;\n- (void)checkForUTF8;\n- (void)loadDefaultTerminal;\n- (void)loadKeyBindings;\n- (void)exitCopyMode;\n\n- (void)clearHistoryForWindowPane:(int)windowPane;\n\n- (void)setTmuxFontTable:(iTermFontTable *)fontTable\n                hSpacing:(CGFloat)hs\n                vSpacing:(CGFloat)vs\n                  window:(int)window;\n- (BOOL)windowIsHidden:(int)windowId;\n- (void)setLayoutInWindowPane:(int)windowPane toLayoutNamed:(NSString *)name;\n- (void)setLayoutInWindow:(int)window toLayout:(NSString *)layout;\n- (NSArray<PTYSession<iTermTmuxControllerSession> *> *)clientSessions;\n\n- (void)setSize:(NSSize)size window:(int)window;\n\n- (void)setEncodedUserVars:(NSString *)encodedUserVars forPane:(int)paneID;\n- (void)setUserVariableWithKey:(NSString *)key\n                         value:(NSString *)value\n                          pane:(int)paneID;\n- (NSDictionary<NSString *, NSString *> *)userVarsForPane:(int)paneID;\n- (void)activeWindowPaneDidChangeInWindow:(int)windowID toWindowPane:(int)paneID;\n- (void)activeWindowDidChangeTo:(int)windowID;\n- (void)setCurrentLatency:(NSTimeInterval)latency forPane:(int)wp;\n- (void)copyBufferToLocalPasteboard:(NSString *)bufferName;\n- (void)restoreWindowFrame:(PseudoTerminal *)term;\n\n@end\n", "//\n//  TmuxController.m\n//  iTerm\n//\n//  Created by George Nachman on 11/27/11.\n//\n\n#import \"TmuxController.h\"\n#import \"DebugLogging.h\"\n#import \"EquivalenceClassSet.h\"\n#import \"iTerm2SharedARC-Swift.h\"\n#import \"iTermAdvancedSettingsModel.h\"\n#import \"iTermApplicationDelegate.h\"\n#import \"iTermController.h\"\n#import \"iTermInitialDirectory.h\"\n#import \"iTermInitialDirectory+Tmux.h\"\n#import \"iTermKeyMappings.h\"\n#import \"iTermKeystroke.h\"\n#import \"iTermLSOF.h\"\n#import \"iTermNotificationController.h\"\n#import \"iTermPreferenceDidChangeNotification.h\"\n#import \"iTermPreferences.h\"\n#import \"iTermProfilePreferences.h\"\n#import \"iTermShortcut.h\"\n#import \"iTermTmuxBufferSizeMonitor.h\"\n#import \"iTermTuple.h\"\n#import \"NSArray+iTerm.h\"\n#import \"NSData+iTerm.h\"\n#import \"NSFont+iTerm.h\"\n#import \"NSStringITerm.h\"\n#import \"PreferencePanel.h\"\n#import \"PseudoTerminal.h\"\n#import \"PTYSession.h\"\n#import \"PTYTab.h\"\n#import \"PTYTextView.h\"\n#import \"RegexKitLite.h\"\n#import \"TmuxControllerRegistry.h\"\n#import \"TmuxDashboardController.h\"\n#import \"TmuxGateway.h\"\n#import \"TmuxWindowOpener.h\"\n#import \"TSVParser.h\"\n\nNSString *const kTmuxControllerSessionsWillChange = @\"kTmuxControllerSessionsWillChange\";\nNSString *const kTmuxControllerSessionsDidChange = @\"kTmuxControllerSessionsDidChange\";\nNSString *const kTmuxControllerDetachedNotification = @\"kTmuxControllerDetachedNotification\";\nNSString *const kTmuxControllerWindowsChangeNotification = @\"kTmuxControllerWindowsChangeNotification\";\nNSString *const kTmuxControllerWindowWasRenamed = @\"kTmuxControllerWindowWasRenamed\";\nNSString *const kTmuxControllerWindowDidOpen = @\"kTmuxControllerWindowDidOpen\";\nNSString *const kTmuxControllerAttachedSessionDidChange = @\"kTmuxControllerAttachedSessionDidChange\";\nNSString *const kTmuxControllerWindowDidClose = @\"kTmuxControllerWindowDidClose\";\nNSString *const kTmuxControllerSessionWasRenamed = @\"kTmuxControllerSessionWasRenamed\";\nNSString *const kTmuxControllerDidFetchSetTitlesStringOption = @\"kTmuxControllerDidFetchSetTitlesStringOption\";\nNSString *const iTermTmuxControllerWillKillWindow = @\"iTermTmuxControllerWillKillWindow\";\nNSString *const kTmuxControllerDidChangeHiddenWindows = @\"kTmuxControllerDidChangeHiddenWindows\";\n\nstatic NSString *const iTermTmuxControllerEncodingPrefixHotkeys = @\"h_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixTabColors = @\"t_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixAffinities = @\"a_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixBuriedIndexes = @\"b_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixOrigins = @\"o_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixHidden = @\"i_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixUserVars = @\"u_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixPerWindowSettings = @\"w_\";\nstatic NSString *const iTermTmuxControllerEncodingPrefixPerTabSettings = @\"T_\";\n\nstatic NSString *const iTermTmuxControllerSplitStateCompletion = @\"completion\";\nstatic NSString *const iTermTmuxControllerSplitStateInitialPanes = @\"initial panes\";\nstatic NSString *const iTermTmuxControllerPhonyAffinity = @\"phony\";\n\n// Unsupported global options:\nstatic NSString *const kAggressiveResize = @\"aggressive-resize\";\n\n@interface TmuxController ()<iTermTmuxBufferSizeMonitorDelegate>\n\n@property(nonatomic, copy) NSString *clientName;\n@property(nonatomic, copy, readwrite) NSString *sessionGuid;\n\n@end\n\n@interface iTermTmuxWindowState : NSObject\n@property (nonatomic, strong) PTYTab *tab;\n@property (nonatomic) NSInteger refcount;\n@property (nonatomic, strong) Profile *profile;\n@property (nonatomic, strong) NSDictionary *fontOverrides;\n@end\n\n@interface iTermTmuxPendingWindow: NSObject\n@property (nonatomic, copy) void (^completion)(int);\n@property (nonatomic, strong) NSNumber *index;  // Tab index. Nullable.\n\n+ (instancetype)trivialInstance;\n+ (instancetype)withIndex:(NSNumber *)index completion:(void (^)(int))completion;\n@end\n\n@implementation iTermTmuxPendingWindow\n\n+ (instancetype)trivialInstance {\n    return [[self alloc] initWithIndex:nil completion:^(int i) { }];\n}\n\n+ (instancetype)withIndex:(NSNumber *)index completion:(void (^)(int))completion {\n    return [[self alloc] initWithIndex:index completion:completion];\n}\n\n- (instancetype)initWithIndex:(NSNumber *)index completion:(void (^)(int))completion {\n    if (!completion) {\n        return [self initWithIndex:index completion:^(int i) { }];\n    }\n    self = [super init];\n    if (self) {\n        assert(index == nil || [NSNumber castFrom:index] != nil);\n        _index = index;\n        _completion = [completion copy];\n    }\n    return self;\n}\n\n@end\n\n@implementation iTermTmuxWindowState\n@end\n\n@implementation TmuxController {\n    TmuxGateway *gateway_;\n    NSMutableDictionary *windowPanes_;  // paneId -> PTYSession *\n    NSMutableDictionary<NSNumber *, iTermTmuxWindowState *> *_windowStates;      // Key is window number\n    NSArray<iTermTmuxSessionObject *> *sessionObjects_;\n    int numOutstandingWindowResizes_;\n    NSMutableDictionary *windowPositions_;\n    NSSize lastSize_;  // last size for windowDidChange:\n    NSString *lastOrigins_;\n    NSString *sessionName_;\n    int sessionId_;\n    NSMutableSet *pendingWindowOpens_;\n    NSString *lastSaveAffinityCommand_;\n    // tmux windows that want to open as tabs in the same physical window\n    // belong to the same equivalence class.\n    EquivalenceClassSet *affinities_;\n    BOOL windowOriginsDirty_;\n    BOOL haveOutstandingSaveWindowOrigins_;\n    NSMutableDictionary *origins_;  // window id -> NSValue(Point) window origin\n    NSMutableSet<NSNumber *> *hiddenWindows_;\n    NSTimer *listSessionsTimer_;  // Used to do a cancelable delayed perform of listSessions.\n    BOOL ambiguousIsDoubleWidth_;\n    NSMutableDictionary<NSNumber *, NSDictionary *> *_hotkeys;\n    NSMutableSet<NSNumber *> *_paneIDs;  // existing pane IDs\n    NSMutableDictionary<NSNumber *, NSString *> *_tabColors;\n\n    // Have we guessed the server version? Don't try to open windows until this is true, because\n    // window opening is version-dependent (to avoid triggering bugs in tmux 1.8).\n    BOOL _versionKnown;\n    BOOL _wantsOpenWindowsInitial;\n\n    // Maps a window id string to a dictionary of window flags defined by TmuxWindowOpener (see the\n    // top of its header file)\n    NSMutableDictionary *_windowOpenerOptions;\n    BOOL _manualOpenRequested;\n    BOOL _allInitialWindowsAdded;\n    BOOL _haveOpenedInitialWindows;\n    ProfileModel *_profileModel;\n    // Maps the window ID of an about to be opened window to a completion block to invoke when it opens.\n    NSMutableDictionary<NSNumber *, iTermTmuxPendingWindow *> *_pendingWindows;\n    BOOL _hasStatusBar;\n    BOOL _focusEvents;\n    int _currentWindowID;  // -1 if undefined\n    // Pane -> (Key -> Value)\n    NSMutableDictionary<NSNumber *, NSMutableDictionary<NSString *, NSString *> *> *_userVars;\n    NSMutableDictionary<NSNumber *, void (^)(PTYSession<iTermTmuxControllerSession> *)> *_when;\n    NSMutableArray *_listWindowsQueue;\n    // If nonnegative, make this pane active after it comes in to being. If negative, invalid.\n    int _paneToActivateWhenCreated;\n    iTermTmuxBufferSizeMonitor *_tmuxBufferMonitor;\n    NSMutableDictionary<NSNumber *, NSValue *> *_windowSizes;  // window -> NSValue cell size\n    BOOL _versionDetected;\n    // terminal guid -> [(tmux window id, tab index), ...]\n    NSMutableDictionary<NSString *, NSMutableArray<iTermTuple<NSNumber *, NSNumber *> *> *> *_buriedWindows;\n    NSString *_lastSaveBuriedIndexesCommand;\n\n    NSString *_lastSavePerWindowSettingsCommand;\n    NSDictionary<NSString *, NSString *> *_perWindowSettings;\n\n    NSString *_lastSavePerTabSettingsCommand;\n    NSDictionary<NSString *, NSString *> *_perTabSettings;\n\n    // When positive do not send select-pane or select-window commands when the selected pane\n    // or window changes. This is to prevent getting into a loop like this:\n    // 1. > select-window -t @2            // iTerm2-initiated\n    // 2. > select-window -t @3            // iTerm2-initiated\n    // 3. < %session-window-changed $1 @2  // Notification for (1)\n    // 4. > select-window -t @2            // In response to (3)\n    // 5. < %session-window-changed $1 @3  // Notification for (2)\n    // 6. > select-window -t @3            // In response to (5)\n    // 7. < %session-window-changed $1 @2  // Notification for (4)\n    // 8. > select-window -t @2            // In response to (7)\n    // 9. < %session-window-changed $1 @3  // Notification for (6)\n    // GOTO 6\n    // If we don't tell tmux to change the active window or pane in response to its notification\n    // we'll eventually catch up to its current state and remain stable.\n    NSInteger _suppressActivityChanges;\n    BOOL _shouldWorkAroundTabBug;\n\n    // Window frames before font size changes. Used to preserve window size in\n    // the face of font sizes by just setting it back to the right size after\n    // font size changes are finished happening.\n    NSMutableDictionary<NSString *, NSValue *> *_savedFrames;\n}\n\n@synthesize gateway = gateway_;\n@synthesize windowPositions = windowPositions_;\n@synthesize sessionName = sessionName_;\n@synthesize sessionObjects = sessionObjects_;\n@synthesize ambiguousIsDoubleWidth = ambiguousIsDoubleWidth_;\n@synthesize sessionId = sessionId_;\n@synthesize detached = detached_;\n\nstatic NSDictionary *iTermTmuxControllerMakeFontOverrides(iTermFontTable *fontTable,\n                                                          CGFloat hs,\n                                                          CGFloat vs) {\n    return @{ KEY_NORMAL_FONT: fontTable.asciiFont.font.stringValue,\n              KEY_NON_ASCII_FONT: fontTable.defaultNonASCIIFont.font.stringValue,\n              KEY_FONT_CONFIG: fontTable.configString ?: [NSNull null],\n              KEY_HORIZONTAL_SPACING: @(hs),\n              KEY_VERTICAL_SPACING: @(vs) };\n}\nstatic NSDictionary *iTermTmuxControllerDefaultFontOverridesFromProfile(Profile *profile) {\n    return iTermTmuxControllerMakeFontOverrides([iTermFontTable fontTableForProfile:profile],\n                                                [iTermProfilePreferences floatForKey:KEY_HORIZONTAL_SPACING inProfile:profile],\n                                                [iTermProfilePreferences floatForKey:KEY_VERTICAL_SPACING inProfile:profile]);\n}\n\n- (instancetype)initWithGateway:(TmuxGateway *)gateway\n                     clientName:(NSString *)clientName\n                        profile:(NSDictionary *)profile\n                   profileModel:(ProfileModel *)profileModel {\n    self = [super init];\n    if (self) {\n        _sharedProfile = [profile copy];\n        _profileModel = profileModel;\n        _sharedFontOverrides = iTermTmuxControllerDefaultFontOverridesFromProfile(profile);\n        _sharedKeyMappingOverrides = [iTermKeyMappings keyMappingsForProfile:profile];\n\n        gateway_ = gateway;\n        _paneIDs = [[NSMutableSet alloc] init];\n        windowPanes_ = [[NSMutableDictionary alloc] init];\n        _windowStates = [[NSMutableDictionary alloc] init];\n        windowPositions_ = [[NSMutableDictionary alloc] init];\n        origins_ = [[NSMutableDictionary alloc] init];\n        pendingWindowOpens_ = [[NSMutableSet alloc] init];\n        hiddenWindows_ = [[NSMutableSet alloc] init];\n        _hotkeys = [[NSMutableDictionary alloc] init];\n        _tabColors = [[NSMutableDictionary alloc] init];\n        self.clientName = [[TmuxControllerRegistry sharedInstance] uniqueClientNameBasedOn:clientName];\n        _windowOpenerOptions = [[NSMutableDictionary alloc] init];\n        _pendingWindows = [[NSMutableDictionary alloc] init];\n        _currentWindowID = -1;\n        _userVars = [[NSMutableDictionary alloc] init];\n        _when = [[NSMutableDictionary alloc] init];\n        [[TmuxControllerRegistry sharedInstance] setController:self forClient:_clientName];\n        _listWindowsQueue = [[NSMutableArray alloc] init];\n        _paneToActivateWhenCreated = -1;\n        _buriedWindows = [[NSMutableDictionary alloc] init];\n        _savedFrames = [[NSMutableDictionary alloc] init];\n        __weak __typeof(self) weakSelf = self;\n        [iTermPreferenceDidChangeNotification subscribe:self\n                                                  block:^(iTermPreferenceDidChangeNotification * _Nonnull notification) {\n            if ([notification.key isEqualToString:kPreferenceKeyTmuxPauseModeAgeLimit]) {\n                [weakSelf enablePauseModeIfPossible];\n            }\n        }];\n        [[NSNotificationCenter defaultCenter] addObserver:self\n                                                 selector:@selector(textViewWillChangeFont:)\n                                                     name:PTYTextViewWillChangeFontNotification\n                                                   object:nil];\n\n        _windowSizes = [[NSMutableDictionary alloc] init];\n        DLog(@\"Create %@ with gateway=%@\", self, gateway_);\n    }\n    return self;\n}\n\n- (Profile *)profileForWindow:(int)window {\n    if (!_variableWindowSize) {\n        return [self sharedProfile];\n    }\n    Profile *original = _windowStates[@(window)].profile;\n    if (!original) {\n        return [self sharedProfile];\n    }\n    NSMutableDictionary *temp = [original mutableCopy];\n    [temp it_mergeFrom:_windowStates[@(window)].fontOverrides];\n    return temp;\n}\n\n- (NSDictionary *)fontOverridesForWindow:(int)window {\n    if (!_variableWindowSize) {\n        return [self sharedFontOverrides];\n    }\n    return _windowStates[@(window)].fontOverrides ?: self.sharedFontOverrides;\n}\n\n- (NSDictionary *)sharedProfile {\n    Profile *profile = [_profileModel bookmarkWithGuid:_sharedProfile[KEY_GUID]] ?: _sharedProfile;\n    NSMutableDictionary *temp = [profile mutableCopy];\n    [_sharedFontOverrides enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        temp[key] = obj;\n    }];\n    NSMutableDictionary *updatedKeyMappings = [temp[KEY_KEYBOARD_MAP] mutableCopy];\n    [_sharedKeyMappingOverrides enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        updatedKeyMappings[key] = obj;\n    }];\n    temp[KEY_KEYBOARD_MAP] = updatedKeyMappings;\n    return temp;\n}\n\n// Called when listing window finishes. Happens for all new windows/tabs, whether initiated by iTerm2 or not.\n- (void)openWindowWithIndex:(int)windowIndex\n                       name:(NSString *)name\n                       size:(NSSize)size\n                     layout:(NSString *)layout\n              visibleLayout:(NSString *)visibleLayout\n                 affinities:(NSSet *)affinities\n                windowFlags:(NSString *)windowFlags\n                    profile:(Profile *)profile\n                    initial:(BOOL)initial\n                   tabIndex:(NSNumber *)tabIndex {\n    DLog(@\"openWindowWithIndex:%d name:%@ affinities:%@ flags:%@ initial:%@\",\n         windowIndex, name, affinities, windowFlags, @(initial));\n    if (!gateway_) {\n        DLog(@\"Deciding NOT to open window because gateway is nil\");\n        return;\n    }\n    NSNumber *n = [NSNumber numberWithInt:windowIndex];\n    if ([pendingWindowOpens_ containsObject:n]) {\n        return;\n    }\n    NSString *originalTerminalGUID = nil;\n    DLog(@\"Opening window with affinities: %@\", [affinities.allObjects componentsJoinedByString:@\" \"]);\n    DLog(@\"Existing affinities:\");\n    [affinities_ log];\n    for (NSString *a in affinities) {\n        if ([a hasPrefix:@\"pty-\"]) {\n            originalTerminalGUID = a;\n        }\n        [affinities_ setValue:a\n                 equalToValue:[NSString stringWithInt:windowIndex]];\n    }\n    [pendingWindowOpens_ addObject:n];\n    TmuxWindowOpener *windowOpener = [TmuxWindowOpener windowOpener];\n    windowOpener.ambiguousIsDoubleWidth = ambiguousIsDoubleWidth_;\n    windowOpener.unicodeVersion = self.unicodeVersion;\n    windowOpener.windowIndex = windowIndex;\n    windowOpener.name = name;\n    windowOpener.size = size;\n    windowOpener.layout = layout;\n    windowOpener.visibleLayout = visibleLayout;\n    windowOpener.maxHistory =\n        MAX([[gateway_ delegate] tmuxClientSize].height,\n            [[gateway_ delegate] tmuxNumberOfLinesOfScrollbackHistory]);\n    windowOpener.controller = self;\n    windowOpener.gateway = gateway_;\n    windowOpener.target = self;\n    windowOpener.selector = @selector(windowDidOpen:);\n    windowOpener.windowOptions = _windowOpenerOptions;\n    windowOpener.zoomed = windowFlags ? @([windowFlags containsString:@\"Z\"]) : nil;\n    windowOpener.manuallyOpened = _manualOpenRequested;\n    windowOpener.allInitialWindowsAdded = _allInitialWindowsAdded;\n    windowOpener.tabColors = _tabColors;\n    windowOpener.focusReporting = _focusEvents && [iTermAdvancedSettingsModel focusReportingEnabled];\n    windowOpener.profile = profile;\n    windowOpener.initial = initial;\n    windowOpener.anonymous = (_pendingWindows[@(windowIndex)] == nil);\n    windowOpener.completion = _pendingWindows[@(windowIndex)].completion;\n    windowOpener.minimumServerVersion = self.gateway.minimumServerVersion;\n    windowOpener.tabIndex = tabIndex ?: _pendingWindows[@(windowIndex)].index;\n    windowOpener.windowGUID = [self windowGUIDInAffinities:affinities];\n    windowOpener.perWindowSettings = _perWindowSettings;\n    windowOpener.perTabSettings = _perTabSettings;\n    windowOpener.shouldWorkAroundTabBug = _shouldWorkAroundTabBug;\n    DLog(@\"windowGUID=%@ perWindowSettings=%@ perTabSettings=%@\",\n         windowOpener.windowGUID, windowOpener.perWindowSettings, windowOpener.perTabSettings);\n    if (originalTerminalGUID) {\n        __weak __typeof(self) weakSelf = self;\n        windowOpener.newWindowBlock = ^(NSString *terminalGUID) {\n            [weakSelf replaceOldTerminalGUID:originalTerminalGUID with:terminalGUID];\n        };\n    }\n    [_pendingWindows removeObjectForKey:@(windowIndex)];\n    _manualOpenRequested = NO;\n    if (![windowOpener openWindows:YES]) {\n        [pendingWindowOpens_ removeObject:n];\n    }\n}\n\n- (NSString *)windowGUIDInAffinities:(NSSet<NSString *> *)affinities {\n    return [affinities.allObjects objectPassingTest:^BOOL(NSString *string, NSUInteger index, BOOL *stop) {\n        return [string hasPrefix:@\"pty-\"];\n    }];\n}\n\n// When we attach we get affinities with terminal GUIDs that may no longer exist. The GUIDs get\n// rewritten after creating the window for the first tab. For restored sessions it just works\n// because 2nd through Nth tabs can find their comrades through their affinity with its window ID.\n// For buried sessions, we must rewrite the terminal GUID since it has no affinity with other tabs\n// by window ID.\n- (void)replaceOldTerminalGUID:(NSString *)oldGUID with:(NSString *)newGUID {\n    DLog(@\"rename %@ to %@\", oldGUID, newGUID);\n    if (_buriedWindows[oldGUID] == nil) {\n        DLog(@\"no buried windows for that old guid\");\n        return;\n    }\n    if (_buriedWindows[newGUID] != nil) {\n        DLog(@\"already have buried windows for the new guid (wtf?)\");\n        return;\n    }\n    _buriedWindows[newGUID] = _buriedWindows[oldGUID];\n    [_buriedWindows removeObjectForKey:oldGUID];\n}\n\n- (BOOL)setLayoutInTab:(PTYTab *)tab\n              toLayout:(NSString *)layout\n         visibleLayout:(NSString *)visibleLayout\n                zoomed:(NSNumber *)zoomed {\n    DLog(@\"setLayoutInTab:%@ toLayout:%@ zoomed:%@\", tab, layout, zoomed);\n    TmuxWindowOpener *windowOpener = [TmuxWindowOpener windowOpener];\n    windowOpener.ambiguousIsDoubleWidth = ambiguousIsDoubleWidth_;\n    windowOpener.unicodeVersion = self.unicodeVersion;\n    windowOpener.layout = layout;\n    windowOpener.visibleLayout = visibleLayout;\n    windowOpener.maxHistory =\n        MAX([[gateway_ delegate] tmuxClientSize].height,\n            [[gateway_ delegate] tmuxNumberOfLinesOfScrollbackHistory]);\n    windowOpener.controller = self;\n    windowOpener.gateway = gateway_;\n    windowOpener.windowIndex = [tab tmuxWindow];\n    windowOpener.target = self;\n    windowOpener.selector = @selector(windowDidOpen:);\n    windowOpener.windowOptions = _windowOpenerOptions;\n    windowOpener.zoomed = zoomed;\n    windowOpener.tabColors = _tabColors;\n    windowOpener.focusReporting = _focusEvents && [iTermAdvancedSettingsModel focusReportingEnabled];\n    windowOpener.profile = [self profileForWindow:tab.tmuxWindow];\n    windowOpener.minimumServerVersion = self.gateway.minimumServerVersion;\n    windowOpener.shouldWorkAroundTabBug = _shouldWorkAroundTabBug;\n    return [windowOpener updateLayoutInTab:tab];\n}\n\n- (void)adjustWindowSizeIfNeededForTabs:(NSArray<PTYTab *> *)tabs {\n    DLog(@\"adjustWindowSizeIfNeededForTabs starting\");\n    if (![tabs anyWithBlock:^BOOL(PTYTab *tab) { return [tab updatedTmuxLayoutRequiresAdjustment]; }]) {\n        DLog(@\"adjustWindowSizeIfNeededForTabs: Layouts fit\");\n        return;\n    }\n    DLog(@\"layout is too large among at least one of: %@\", tabs);\n    // The tab's root splitter is larger than the window's tabview.\n    const BOOL outstandingResize =\n    [tabs anyWithBlock:^BOOL(PTYTab *tab) {\n        return [[[tab realParentWindow] uniqueTmuxControllers] anyWithBlock:^BOOL(TmuxController *controller) {\n            return [controller hasOutstandingWindowResize];\n        }];\n    }];\n    if (outstandingResize) {\n        DLog(@\"adjustWindowSizeIfNeededForTabs: One of the tabs has a tmux controller with an outstanding window resize. Don't update layouts.\");\n        return;\n    }\n    // If there are no outstanding window resizes then setTmuxLayout:tmuxController:\n    // has called fitWindowToTabs:, and it's still too big, so shrink\n    // the layout.\n\n    DLog(@\"adjustWindowSizeIfNeededForTabs: Tab's root splitter is oversize. Fit layout to windows\");\n    [self fitLayoutToWindows];\n}\n\n- (void)sessionChangedTo:(NSString *)newSessionName sessionId:(int)sessionid {\n    self.sessionGuid = nil;\n    self.sessionName = newSessionName;\n    sessionId_ = sessionid;\n    _paneToActivateWhenCreated = -1;\n    _detaching = YES;\n    [self closeAllPanes];\n    _detaching = NO;\n    [self openWindowsInitial];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerAttachedSessionDidChange\n                                                        object:nil];\n}\n\n- (void)sessionsChanged {\n    if (detached_) {\n        // Shouldn't happen, but better safe than sorry.\n        return;\n    }\n    // Wait a few seconds. We always get a sessions-changed notification when the last window in\n    // a session closes. To avoid spamming the command line with list-sessions, we wait a bit to see\n    // if there is an exit notification coming down the pipe.\n    const CGFloat kListSessionsDelay = 1.5;\n    [listSessionsTimer_ invalidate];\n    listSessionsTimer_ = [NSTimer scheduledTimerWithTimeInterval:kListSessionsDelay\n                                                          target:self\n                                                        selector:@selector(listSessions)\n                                                        userInfo:nil\n                                                         repeats:NO];\n}\n\n- (void)session:(int)sessionId renamedTo:(NSString *)newName {\n    if (sessionId == sessionId_) {\n        self.sessionName = newName;\n    }\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerSessionWasRenamed\n                                                        object:@[ @(sessionId), newName ?: @\"\", self ]];\n}\n\n- (void)windowWasRenamedWithId:(int)wid to:(NSString *)newName {\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerWindowWasRenamed\n                                                        object:@[ @(wid), newName ?: @\"\", self ]];\n}\n\n- (void)windowsChanged\n{\n    [[NSNotificationCenter defaultCenter]  postNotificationName:kTmuxControllerWindowsChangeNotification\n                                                         object:self];\n}\n\n- (NSArray *)listWindowFields {\n    NSArray<NSString *> *basic = @[@\"session_name\", @\"window_id\",\n                                   @\"window_name\", @\"window_width\", @\"window_height\",\n                                   @\"window_layout\", @\"window_flags\", @\"window_active\"];\n    if (![self versionAtLeastDecimalNumberWithString:@\"2.2\"]) {\n        return basic;\n    }\n    return [basic arrayByAddingObject:@\"window_visible_layout\"];\n}\n\n- (NSSet<NSObject<NSCopying> *> *)savedAffinitiesForWindow:(NSString *)value {\n    return [affinities_ valuesEqualTo:value];\n}\n\n- (void)initialListWindowsResponse:(NSString *)response {\n    DLog(@\"initialListWindowsResponse called\");\n    TSVDocument *doc = [response tsvDocumentWithFields:[self listWindowFields] workAroundTabBug:_shouldWorkAroundTabBug];\n    if (!doc) {\n        DLog(@\"Failed to parse %@\", response);\n        [gateway_ abortWithErrorMessage:[NSString stringWithFormat:@\"Bad response for initial list windows request: %@\", response]];\n        return;\n    }\n    NSMutableArray<NSArray *> *windowsToOpen = [NSMutableArray array];\n    BOOL haveHidden = NO;\n    NSNumber *newWindowAffinity = nil;\n    const iTermOpenTmuxWindowsMode openWindowsMode = [iTermPreferences intForKey:kPreferenceKeyOpenTmuxWindowsIn];\n    const BOOL newWindowsInTabs = openWindowsMode == kOpenTmuxWindowsAsNativeTabsInNewWindow;\n    DLog(@\"Iterating records...\");\n    for (NSArray *record in doc.records) {\n        DLog(@\"Consider record %@\", record);\n        const int wid = [self windowIdFromString:[doc valueInRecord:record forField:@\"window_id\"]];\n        if (hiddenWindows_ && [hiddenWindows_ containsObject:[NSNumber numberWithInt:wid]]) {\n            DLog(@\"Don't open window %d because it was saved hidden.\", wid);\n            haveHidden = YES;\n            // Let the user know something is up.\n            continue;\n        }\n        DLog(@\"Will open %d as it was not saved hidden\", wid);\n        NSNumber *n = [NSNumber numberWithInt:wid];\n        if (![affinities_ valuesEqualTo:[n stringValue]] && newWindowsInTabs) {\n            // Create an equivalence class of all unrecognied windows to each other.\n            if (!newWindowAffinity) {\n                DLog(@\"Create new affinity class for %@\", n);\n                newWindowAffinity = n;\n            } else {\n                DLog(@\"Add window id %@ to existing affinity class %@\", n, [newWindowAffinity stringValue]);\n                [affinities_ setValue:[n stringValue]\n                         equalToValue:[newWindowAffinity stringValue]];\n            }\n        }\n        [windowsToOpen addObject:record];\n    }\n    BOOL tooMany = NO;\n    if (windowsToOpen.count > [iTermPreferences intForKey:kPreferenceKeyTmuxDashboardLimit]) {\n        DLog(@\"There are too many windows to open so just show the dashboard\");\n        tooMany = YES;\n        // Save that these windows are hidden so the UI will be consistent next time you attach.\n        NSArray<NSNumber *> *wids = [windowsToOpen mapWithBlock:^NSNumber *(NSArray *record) {\n            const int wid = [self windowIdFromString:[doc valueInRecord:record forField:@\"window_id\"]];\n            return @(wid);\n        }];\n        [self hideWindows:wids andCloseTabs:NO];\n        [windowsToOpen removeAllObjects];\n    }\n    [[TmuxDashboardController sharedInstance] didAttachWithHiddenWindows:haveHidden tooManyWindows:tooMany];\n    if (tooMany) {\n        [[iTermNotificationController sharedInstance] notify:@\"Too many tmux windows!\" withDescription:@\"Use the tmux dashboard to select which to open.\"];\n    } else if (haveHidden) {\n        [[iTermNotificationController sharedInstance] notify:@\"Some tmux windows were hidden.\" withDescription:@\"Use the tmux dashboard to select which to open.\"];\n    }\n    for (NSArray *record in windowsToOpen) {\n        DLog(@\"Open window %@\", record);\n        int wid = [self windowIdFromString:[doc valueInRecord:record forField:@\"window_id\"]];\n        [self openWindowWithIndex:wid\n                             name:[[doc valueInRecord:record forField:@\"window_name\"] it_unescapedTmuxWindowName]\n                             size:NSMakeSize([[doc valueInRecord:record forField:@\"window_width\"] intValue],\n                                             [[doc valueInRecord:record forField:@\"window_height\"] intValue])\n                           layout:[doc valueInRecord:record forField:@\"window_layout\"]\n                    visibleLayout:[doc valueInRecord:record forField:@\"window_visible_layout\"]\n                       affinities:[self savedAffinitiesForWindow:[NSString stringWithInt:wid]]\n                      windowFlags:[doc valueInRecord:record forField:@\"window_flags\"]\n                          profile:[self sharedProfile]\n                          initial:YES\n                         tabIndex:nil];\n    }\n    if (windowsToOpen.count == 0) {\n        DLog(@\"Did not open any windows so turn on accept notifications in tmux gateway\");\n        gateway_.acceptNotifications = YES;\n        [self sendInitialWindowsOpenedNotificationIfNeeded];\n    }\n    _allInitialWindowsAdded = YES;\n}\n\n- (void)openWindowsInitial {\n    _allInitialWindowsAdded = NO;\n    DLog(@\"openWindowsInitial\\n%@\", [NSThread callStackSymbols]);\n    if (!_versionKnown) {\n        DLog(@\"Don't know version yet\");\n        _wantsOpenWindowsInitial = YES;\n        return;\n    }\n    NSString *command = [NSString stringWithFormat:@\"show -v -q -t $%d @iterm2_size\", sessionId_];\n    [gateway_ sendCommand:command\n           responseTarget:self\n         responseSelector:@selector(handleShowSize:)];\n}\n\n- (void)handleShowSize:(NSString *)response {\n    DLog(@\"handleShowSize: %@\", response);\n    NSScanner *scanner = [NSScanner scannerWithString:response ?: @\"\"];\n    int width = 0;\n    int height = 0;\n    BOOL ok = ([scanner scanInt:&width] &&\n               [scanner scanString:@\",\" intoString:nil] &&\n               [scanner scanInt:&height]);\n    if (ok) {\n        [self openWindowsOfSize:VT100GridSizeMake(width, height)];\n    } else {\n        [self openWindowsOfSize:[[gateway_ delegate] tmuxClientSize]];\n    }\n}\n\n- (void)openWindowsOfSize:(VT100GridSize)size {\n    DLog(@\"openWindowsOfSize: %@\", VT100GridSizeDescription(size));\n\n    // There's a (hopefully) minor race condition here. When we initially connect to\n    // a session we get its @iterm2_id. If one doesn't exist, it is assigned. This\n    // lets us know if a single instance of iTerm2 is trying to attach to the same\n    // session twice. A really evil user could attach twice to the same session\n    // simultaneously, and we'd get the value twice, see it's empty twice, and set\n    // it twice, causing chaos. Or two separate instances of iTerm2 attaching\n    // simultaneously could also hit this race. The consequence of this race\n    // condition is easily recovered from by reattaching.\n    [_windowSizes removeAllObjects];\n    NSString *getSessionGuidCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @iterm2_id\",\n                                       sessionId_];\n    size.height = [self adjustHeightForStatusBar:size.height];\n    if (size.width < 2) {\n        size.width = 2;\n    }\n    if (size.height < 2) {\n        size.height = 2;\n    }\n    // NOTE: setSizeCommand only set when variable window sizes are not in use.\n    NSString *setSizeCommand = [NSString stringWithFormat:@\"refresh-client -C %d,%d\",\n                                size.width, size.height];\n    NSString *listWindowsCommand = [NSString stringWithFormat:@\"list-windows -F %@\", [self listWindowsDetailedFormat]];\n    NSString *listSessionsCommand = @\"list-sessions -F \\\"#{session_id} #{session_name}\\\"\";\n    NSString *getAffinitiesCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @affinities\", sessionId_];\n    NSString *getPerWindowSettingsCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @per_window_settings\", sessionId_];\n    NSString *getPerTabSettingsCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @per_tab_settings\", sessionId_];\n    NSString *getBuriedIndexesCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @buried_indexes\", sessionId_];\n    NSString *getOriginsCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @origins\", sessionId_];\n    NSString *getHotkeysCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @hotkeys\", sessionId_];\n    NSString *getTabColorsCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @tab_colors\", sessionId_];\n    NSString *getHiddenWindowsCommand = [NSString stringWithFormat:@\"show -v -q -t $%d @hidden\", sessionId_];\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:getSessionGuidCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getSessionGuidResponse:)\n                                           responseObject:nil\n                                                    flags:0],\n\t\t\t   [gateway_ dictionaryForCommand:setSizeCommand\n                               responseTarget:nil\n                             responseSelector:nil\n                               responseObject:nil\n                                        flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getHiddenWindowsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getHiddenWindowsResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getBuriedIndexesCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getBuriedIndexesResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getAffinitiesCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getAffinitiesResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getPerWindowSettingsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getPerWindowSettingsResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getPerTabSettingsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getPerTabSettingsResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getOriginsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getOriginsResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getHotkeysCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getHotkeysResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:getTabColorsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(getTabColorsResponse:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:listSessionsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(listSessionsResponse:)\n                                           responseObject:nil\n                                                    flags:0],\n                           [gateway_ dictionaryForCommand:listWindowsCommand\n                                           responseTarget:self\n                                         responseSelector:@selector(initialListWindowsResponse:)\n                                           responseObject:nil\n                                                    flags:0] ];\n    [gateway_ sendCommandList:[commands filteredArrayUsingBlock:^BOOL(id anObject) {\n        return ![anObject isKindOfClass:[NSNull class]];\n    }]];\n}\n\n// Returns the mutable set of session GUIDs we're attached to.\n- (NSMutableSet *)attachedSessionGuids {\n    static NSMutableSet *gAttachedSessionGuids;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        gAttachedSessionGuids = [[NSMutableSet alloc] init];\n    });\n    return gAttachedSessionGuids;\n}\n\n// Sets the current controller's session guid and updates the global set of attached session GUIDs.\n// If guid is nil then it is removed from the global set.\n- (void)setSessionGuid:(NSString *)guid {\n    if (guid) {\n        [self.attachedSessionGuids addObject:guid];\n    } else if (_sessionGuid) {\n        [self.attachedSessionGuids removeObject:_sessionGuid];\n    }\n    _sessionGuid = [guid copy];\n}\n\n// This is where the race condition described in openWindowsInitial occurs.\n- (void)getSessionGuidResponse:(NSString *)sessionGuid {\n    if (!sessionGuid.length) {\n        NSString *guid = [NSString uuid];\n        NSString *command = [NSString stringWithFormat:@\"set -t $%d @iterm2_id \\\"%@\\\"\",\n                             sessionId_, guid];\n        [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n        self.sessionGuid = guid;\n        return;\n    }\n    if ([self.attachedSessionGuids containsObject:sessionGuid]) {\n        [self.gateway doubleAttachDetectedForSessionGUID:sessionGuid];\n        if ([self.attachedSessionGuids containsObject:sessionGuid]) {\n            // Delegate did not choose to force disconnect other, so we say goodbye.\n            TmuxGateway *gateway = gateway_;\n            [self detach];\n            [gateway forceDetach];\n            return;\n        }\n    }\n    // This is the only one.\n    self.sessionGuid = sessionGuid;\n}\n\n- (NSNumber *)_keyForWindowPane:(int)windowPane\n{\n    return [NSNumber numberWithInt:windowPane];\n}\n\n- (PTYSession<iTermTmuxControllerSession> *)sessionForWindowPane:(int)windowPane\n{\n    return [windowPanes_ objectForKey:[self _keyForWindowPane:windowPane]];\n}\n\n- (void)registerSession:(PTYSession<iTermTmuxControllerSession> *)aSession\n               withPane:(int)windowPane\n               inWindow:(int)window {\n    PTYTab *tab = [aSession.delegate.realParentWindow tabForSession:aSession];\n    ITCriticalError(tab != nil, @\"nil tab for session %@ with delegate %@ with realparentwindow %@\",\n                    aSession, aSession.delegate, aSession.delegate.realParentWindow);\n    if (tab) {\n        [self retainWindow:window withTab:tab];\n        [windowPanes_ setObject:aSession forKey:[self _keyForWindowPane:windowPane]];\n        void (^call)(PTYSession<iTermTmuxControllerSession> *) = _when[@(windowPane)];\n        if (call) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                call(aSession);\n            });\n            [_when removeObjectForKey:@(windowPane)];\n        }\n        if (_paneToActivateWhenCreated == windowPane) {\n            [aSession revealIfTabSelected];\n            _paneToActivateWhenCreated = -1;\n        }\n    }\n}\n\n- (void)deregisterWindow:(int)window windowPane:(int)windowPane session:(id)session\n{\n    id key = [self _keyForWindowPane:windowPane];\n    if (windowPanes_[key] == session) {\n        [self releaseWindow:window];\n        [windowPanes_ removeObjectForKey:key];\n        [_when removeObjectForKey:@(windowPane)];\n    }\n}\n\n- (void)whenPaneRegistered:(int)wp call:(void (^)(PTYSession<iTermTmuxControllerSession> *))block {\n    PTYSession<iTermTmuxControllerSession> *already = [self sessionForWindowPane:wp];\n    if (already) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            block(already);\n        });\n        return;\n    }\n\n    _when[@(wp)] = [block copy];\n}\n\n- (PTYTab *)window:(int)window {\n    return _windowStates[@(window)].tab;\n}\n\n- (NSArray<PTYSession<iTermTmuxControllerSession> *> *)sessionsInWindow:(int)window {\n    return [[self window:window] sessions];\n}\n\n- (BOOL)isAttached\n{\n    return !detached_;\n}\n\n- (void)requestDetach {\n    if (self.gateway.detachSent) {\n        if ([self.gateway.delegate tmuxGatewayShouldForceDetach]) {\n            [self.gateway forceDetach];\n        }\n    } else {\n        [self.gateway detach];\n    }\n}\n\n- (void)detach {\n    DLog(@\"%@: detach\", self);\n    self.sessionGuid = nil;\n    [listSessionsTimer_ invalidate];\n    listSessionsTimer_ = nil;\n    detached_ = YES;\n    [self closeAllPanes];\n    gateway_ = nil;\n    [_when enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, void (^ _Nonnull obj)(PTYSession<iTermTmuxControllerSession> *), BOOL * _Nonnull stop) {\n        obj(nil);\n    }];\n    [_when removeAllObjects];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerDetachedNotification\n                                                        object:self];\n    [[TmuxControllerRegistry sharedInstance] setController:nil\n                                                 forClient:self.clientName];\n}\n\n- (void)windowDidResize:(NSWindowController<iTermWindowController> *)term {\n    if (term.closing) {\n        return;\n    }\n    if (_variableWindowSize) {\n        [self variableSizeWindowDidResize:term];\n        return;\n    }\n    NSSize size = [term tmuxCompatibleSize];\n    DLog(@\"The tmux-compatible size of the window is %@\", NSStringFromSize(size));\n    if (size.width <= 0 || size.height <= 0) {\n        // After the last session closes a size of 0 is reported.\n        return;\n    }\n    DLog(@\"The last known size of tmux windows is %@\", NSStringFromSize(lastSize_));\n    if (NSEqualSizes(size, lastSize_)) {\n        return;\n    }\n\n    DLog(@\"Looks like the window resize is legit. Change client size to %@\", NSStringFromSize(size));\n    [self setClientSize:size];\n}\n\n- (void)variableSizeWindowDidResize:(NSWindowController<iTermWindowController> *)term {\n    DLog(@\"Window %@ did resize. Updating tmux tabs\", term);\n    [self setWindowSizes:[term.tabs mapWithBlock:^iTermTuple<NSString *, NSValue *> *(PTYTab *tab) {\n        if (!tab.tmuxTab || tab.tmuxController != self) {\n            return nil;\n        }\n        return [iTermTuple tupleWithObject:[NSString stringWithInt:tab.tmuxWindow]\n                                 andObject:[NSValue valueWithSize:tab.tmuxSize]];\n    }]];\n}\n\n- (NSSize)sizeOfSmallestWindowAmong:(NSSet<NSString *> *)siblings {\n    NSSize minSize = NSMakeSize(INFINITY, INFINITY);\n    for (NSString *windowKey in siblings) {\n        if ([windowKey hasPrefix:@\"pty\"]) {\n            continue;\n        }\n        PTYTab *tab = [self window:windowKey.intValue];\n        NSSize size = [tab tmuxSize];\n        if (size.width > 0 && size.height > 0) {\n            minSize.width = MIN(minSize.width, size.width);\n            DLog(@\"Ignore tab %@ with size of 0\", tab);\n            minSize.height = MIN(minSize.height, size.height);\n        }\n    }\n    return minSize;\n}\n\n- (void)fitLayoutToWindows {\n    if (!_windowStates.count) {\n        return;\n    }\n    if (_variableWindowSize) {\n        [self fitLayoutToVariableSizeWindows];\n        return;\n    }\n    NSSize minSize = NSMakeSize(INFINITY, INFINITY);\n    for (NSNumber *windowKey in _windowStates) {\n        PTYTab *tab = _windowStates[windowKey].tab;\n        NSSize size = [tab tmuxSize];\n        minSize.width = MIN(minSize.width, size.width);\n        minSize.height = MIN(minSize.height, size.height);\n    }\n    if (minSize.width <= 0 || minSize.height <= 0) {\n        // After the last session closes a size of 0 is reported. Apparently unplugging a monitor\n        // leads to a negative value here. That's inferred from crash report 1468853197.309853926.txt\n        // (at the time of that crash, this tested only for zero values so it passed through and\n        // asserted anyway).\n        return;\n    }\n    if (NSEqualSizes(minSize, lastSize_)) {\n        return;\n    }\n    DLog(@\"fitLayoutToWindows setting client size to %@\", NSStringFromSize(minSize));\n    [self setClientSize:minSize];\n}\n\n- (void)fitLayoutToVariableSizeWindows {\n    [self setWindowSizes:[_windowStates.allKeys mapWithBlock:^iTermTuple<NSString *, NSValue *> *(NSNumber *windowNumber) {\n        iTermTmuxWindowState *state = _windowStates[windowNumber];\n        PTYTab *tab = state.tab;\n        return [iTermTuple tupleWithObject:[NSString stringWithInt:windowNumber.intValue]\n                                 andObject:[NSValue valueWithSize:tab.tmuxSize]];\n    }]];\n}\n\n- (void)setSize:(NSSize)size window:(int)window {\n    if (!_variableWindowSize) {\n        [self setClientSize:size];\n        return;\n    }\n    [gateway_ sendCommandList:[self commandListToSetSize:size ofWindow:window]];\n}\n\n- (NSArray<NSDictionary *> *)commandListToSetSize:(NSSize)size ofWindow:(int)window {\n    NSSet *siblings = [affinities_ valuesEqualTo:[@(window) stringValue]];\n    if (!siblings.count) {\n        return [self commandListToSetSize:size ofWindows:@[ [NSString stringWithInt:window] ]];\n    } else {\n        return [self commandListToSetSize:size ofWindows:siblings.allObjects];\n    }\n}\n\n- (void)setWindowSizes:(NSArray<iTermTuple<NSString *, NSValue *> *> *)windowSizes {\n    [gateway_ sendCommandList:[self commandListToSetWindowSizes:windowSizes]];\n}\n\n- (NSArray<NSDictionary *> *)commandListToSetWindowSizes:(NSArray<iTermTuple<NSString *, NSValue *> *> *)windowSizes {\n    return [windowSizes mapWithBlock:^NSDictionary *(iTermTuple<NSString *,NSValue *> *tuple) {\n        NSString *window = tuple.firstObject;\n        NSSize size = tuple.secondObject.sizeValue;\n        if ([window hasPrefix:@\"pty\"] || [window hasSuffix:@\"_ph\"]) {\n            return nil;\n        }\n        // 10000 comes from WINDOW_MAXIMUM in tmux.h\n        if (size.width < 1 || size.height < 1 || size.width >= 10000 || size.height >= 10000) {\n            return nil;\n        }\n        DLog(@\"Set client size to %@\", NSStringFromSize(size));\n        NSValue *sizeValue = [NSValue valueWithSize:size];\n        if ([_windowSizes[@(window.intValue)] isEqual:sizeValue]) {\n            DLog(@\"It's already that size. Do nothing.\");\n            return nil;\n        }\n        _windowSizes[@(window.intValue)] = sizeValue;\n        NSString *command;\n        if ([self refreshClientSupportsWindowArgument]) {\n            command = [NSString stringWithFormat:@\"refresh-client -C @%d:%dx%d\", window.intValue, (int)size.width, (int)size.height];\n        } else {\n            command = [NSString stringWithFormat:@\"resize-window -x %@ -y %@ -t @%d\", @((int)size.width), @((int)size.height), window.intValue];\n        }\n        NSDictionary *dict = [gateway_ dictionaryForCommand:command\n                                             responseTarget:self\n                                           responseSelector:@selector(handleResizeWindowResponse:)\n                                             responseObject:nil\n                                                      flags:kTmuxGatewayCommandShouldTolerateErrors];\n        return dict;\n    }];\n}\n\n- (BOOL)refreshClientSupportsWindowArgument {\n    // https://github.com/tmux/tmux/issues/2594\n    return [self versionAtLeastDecimalNumberWithString:@\"3.4\"];\n}\n\n- (NSArray<NSDictionary *> *)commandListToSetSize:(NSSize)size ofWindows:(NSArray<NSString *> *)windows {\n    return [self commandListToSetWindowSizes:[windows mapWithBlock:^iTermTuple<NSString *, NSValue *> *(NSString *window) {\n        return [iTermTuple tupleWithObject:window andObject:[NSValue valueWithSize:size]];\n    }]];\n}\n\n- (void)handleResizeWindowResponse:(NSString *)response {\n}\n\n- (int)adjustHeightForStatusBar:(int)height {\n    // See here for the bug fix: https://github.com/tmux/tmux/pull/1731\n    NSArray *buggyVersions = @[ [NSDecimalNumber decimalNumberWithString:@\"2.9\"],\n                                [NSDecimalNumber decimalNumberWithString:@\"2.91\"] ];\n    if (_hasStatusBar && [buggyVersions containsObject:gateway_.minimumServerVersion]) {\n        return height + 1;\n    }\n    return height;\n}\n\n- (void)setClientSize:(NSSize)size {\n    DLog(@\"TmuxController setClientSize: Set client size to %@ from\\n%@\", NSStringFromSize(size), [NSThread callStackSymbols]);\n    DLog(@\"%@\", [NSThread callStackSymbols]);\n    assert(size.width > 0 && size.height > 0);\n    lastSize_ = size;\n    NSString *listStr = [self commandToListWindows];\n    NSString *setSizeCommand = [NSString stringWithFormat:@\"set -t $%d @iterm2_size %d,%d\",\n                                sessionId_, (int)size.width, (int)size.height];\n    const int height = [self adjustHeightForStatusBar:(int)size.height];\n    ITBetaAssert(height > 0, @\"Invalid size\");\n    [_windowSizes removeAllObjects];\n    NSArray *commands = [NSArray arrayWithObjects:\n                         [gateway_ dictionaryForCommand:setSizeCommand\n                                         responseTarget:nil\n                                       responseSelector:nil\n                                         responseObject:nil\n                                                  flags:0],\n                         [gateway_ dictionaryForCommand:[NSString stringWithFormat:@\"refresh-client -C %d,%d\",\n                                                         (int)size.width, height]\n                                         responseTarget:nil\n                                       responseSelector:nil\n                                         responseObject:nil\n                                                  flags:kTmuxGatewayCommandShouldTolerateErrors],\n                         [gateway_ dictionaryForCommand:listStr\n                                         responseTarget:self\n                                       responseSelector:@selector(listWindowsResponse:)\n                                         responseObject:nil\n                                                  flags:0],\n                         nil];\n    ++numOutstandingWindowResizes_;\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)sendControlC {\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"%cphony-command\", 3]\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)ping {\n    // This command requires tmux 3.2, but if it fails that's OK too.\n    [gateway_ sendCommand:@\"refresh-client -fpause-after=0,wait-exit\"\n           responseTarget:self\n         responseSelector:@selector(handlePingResponse:)\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)handlePingResponse:(NSString *)ignore {\n}\n\n- (void)enablePauseModeIfPossible {\n    DLog(@\"enablePauseModeIfPossible min=%@ max=%@\", gateway_.minimumServerVersion, gateway_.maximumServerVersion);\n    if (gateway_.minimumServerVersion &&\n        [gateway_.minimumServerVersion compare:[NSDecimalNumber decimalNumberWithString:@\"3.2\"]] == NSOrderedAscending) {\n        DLog(@\"min < 3.2\");\n        return;\n    }\n    if (!gateway_.minimumServerVersion) {\n        DLog(@\"have no min version\");\n        return;\n    }\n    NSUInteger catchUpTime = [iTermPreferences unsignedIntegerForKey:kPreferenceKeyTmuxPauseModeAgeLimit];\n    gateway_.pauseModeEnabled = YES;\n    const NSInteger age = MAX(1, round(catchUpTime));\n    DLog(@\"Enable pause-after=%@\", @(age));\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"refresh-client -fpause-after=%@\", @(age)]\n           responseTarget:nil\n         responseSelector:nil];\n    _tmuxBufferMonitor = [[iTermTmuxBufferSizeMonitor alloc] initWithController:self\n                                                                       pauseAge:age];\n    _tmuxBufferMonitor.delegate = self;\n}\n\n- (void)didPausePane:(int)wp {\n    [_tmuxBufferMonitor resetPane:wp];\n}\n\n- (void)unpausePanes:(NSArray<NSNumber *> *)wps {\n    if (!gateway_.pauseModeEnabled) {\n        return;\n    }\n    TmuxWindowOpener *windowOpener = [TmuxWindowOpener windowOpener];\n    windowOpener.ambiguousIsDoubleWidth = ambiguousIsDoubleWidth_;\n    windowOpener.unicodeVersion = self.unicodeVersion;\n    windowOpener.maxHistory =\n        MAX([[gateway_ delegate] tmuxClientSize].height,\n            [[gateway_ delegate] tmuxNumberOfLinesOfScrollbackHistory]);\n    windowOpener.controller = self;\n    windowOpener.gateway = gateway_;\n    windowOpener.target = self;\n    windowOpener.selector = @selector(panesDidUnpause:);\n    windowOpener.shouldWorkAroundTabBug = _shouldWorkAroundTabBug;\n\n    windowOpener.minimumServerVersion = self.gateway.minimumServerVersion;\n    [windowOpener unpauseWindowPanes:wps];\n}\n\n- (void)panesDidUnpause:(TmuxWindowOpener *)opener {\n    for (NSNumber *wp in opener.unpausingWindowPanes) {\n        PTYSession<iTermTmuxControllerSession> *session = [self sessionForWindowPane:wp.intValue];\n        [session setTmuxHistory:[opener historyLinesForWindowPane:wp.intValue alternateScreen:NO]\n                     altHistory:[opener historyLinesForWindowPane:wp.intValue alternateScreen:YES]\n                          state:[opener stateForWindowPane:wp.intValue]];\n    }\n}\n\n- (void)pausePanes:(NSArray<NSNumber *> *)wps {\n    if (!gateway_.pauseModeEnabled) {\n        return;\n    }\n    NSString *adjustments = [[wps mapWithBlock:^id(NSNumber *anObject) {\n        return [NSString stringWithFormat:@\"%%%@:pause\", anObject];\n    }] componentsJoinedByString:@\" \"];\n    NSString *command = [NSString stringWithFormat:@\"refresh-client -A '%@'\", adjustments];\n    [self.gateway sendCommand:command responseTarget:self responseSelector:@selector(didPause:panes:) responseObject:wps flags:0];\n}\n\n- (void)didPause:(NSString *)result panes:(NSArray<NSNumber *> *)wps {\n    for (NSNumber *wp in wps) {\n        [self.gateway.delegate tmuxWindowPaneDidPause:wp.intValue\n                                         notification:NO];\n    }\n}\n\n// Make sure that current tmux options are compatible with iTerm.\n- (void)validateOptions\n{\n    for (NSString *option in [self unsupportedGlobalOptions]) {\n        [gateway_ sendCommand:[NSString stringWithFormat:@\"show-window-options -g %@\", option]\n               responseTarget:self\n             responseSelector:@selector(showWindowOptionsResponse:)];\n    }\n    [gateway_ sendCommand:@\"show-option -g -v status\"\n           responseTarget:self\n         responseSelector:@selector(handleStatusResponse:)];\n    [gateway_ sendCommand:@\"show-option -q -g -v focus-events\"\n           responseTarget:self\n         responseSelector:@selector(handleFocusEventsResponse:)];\n}\n\n- (void)handleStatusResponse:(NSString *)string {\n    _hasStatusBar = [string isEqualToString:@\"on\"];\n}\n\n- (void)handleFocusEventsResponse:(NSString *)string {\n    _focusEvents = [string isEqualToString:@\"on\"];\n}\n\n- (void)checkForUTF8 {\n    // Issue 5359\n    [gateway_ sendCommand:@\"list-sessions -F \\\"\\t\\\"\"\n           responseTarget:self\n         responseSelector:@selector(checkForUTF8Response:)\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)clearHistoryForWindowPane:(int)windowPane {\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"clear-history -t \\\"%%%d\\\"\", windowPane]\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)loadServerPID {\n    if (gateway_.minimumServerVersion.doubleValue < 2.1) {\n        return;\n    }\n    [gateway_ sendCommand:@\"display-message -p \\\"#{pid}\\\"\"\n           responseTarget:self\n         responseSelector:@selector(didLoadServerPID:)];\n}\n\n- (void)didLoadServerPID:(NSString *)pidString {\n    pid_t pid = [pidString integerValue];\n    if (pid > 0) {\n        NSString *name = [iTermLSOF nameOfProcessWithPid:pid isForeground:NULL];\n        _serverIsLocal = [name isEqualToString:@\"tmux\"];\n    }\n}\n\n- (void)loadDefaultTerminal {\n    NSString *command = @\"show-options -v -s default-terminal\";\n    [self.gateway sendCommand:command\n               responseTarget:self\n             responseSelector:@selector(didFetchDefaultTerminal:)\n               responseObject:nil\n                        flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)didFetchDefaultTerminal:(NSString *)defaultTerminal {\n    if (defaultTerminal.length > 0)  {\n        _defaultTerminal = [defaultTerminal copy];\n    }\n}\n\n- (void)loadTitleFormat {\n    NSDecimalNumber *v2_9 = [NSDecimalNumber decimalNumberWithString:@\"2.9\"];\n    if ([gateway_.minimumServerVersion compare:v2_9] == NSOrderedAscending) {\n        DLog(@\"tmux not new enough to use set-titles\");\n        return;\n    }\n\n    [gateway_ sendCommandList:@[ [gateway_ dictionaryForCommand:@\"show-options -v -g set-titles\"\n                                                 responseTarget:self\n                                               responseSelector:@selector(handleShowSetTitles:)\n                                                 responseObject:nil\n                                                          flags:0] ]];\n}\n\n- (void)loadKeyBindings {\n    [gateway_ sendCommand:@\"list-keys\" responseTarget:self responseSelector:@selector(handleListKeys:)];\n}\n\n// If there's an error in tmux.conf then tmux will put you in copy mode initially and that breaks\n// handling keyboard input. This is harmless in the normal case.\n// https://github.com/tmux/tmux/issues/3193\n- (void)exitCopyMode {\n    [gateway_ sendCommand:@\"copy-mode -q\"\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n// This is a little brittle because it depends on parsing bind-keys commands\n// which could change in the future. It'd be nice for list-keys to have\n// structured output.\n- (void)handleListKeys:(NSString *)response {\n    NSArray<NSString *> *lines = [response componentsSeparatedByString:@\"\\n\"];\n    NSArray<NSDictionary *> *dicts = [lines mapWithBlock:^id (NSString * _Nonnull line) {\n        NSArray<NSString *> *args = [line componentsSeparatedByRegex:@\"  *\"];\n        NSInteger skip = 0;\n        NSString *key = nil;\n        NSString *command = nil;\n        NSString *flag = nil;\n        NSMutableDictionary<NSString *, id> *flags = [NSMutableDictionary dictionary];\n        for (NSInteger i = 1; i < args.count; i++) {\n            if (skip > 0) {\n                NSArray<NSString *> *flagArgs = flags[flag];\n                flags[flag] = [flagArgs arrayByAddingObject:args[i]];\n                skip -= 1;\n                continue;\n            }\n            flag = nil;\n            if ([args[i] hasPrefix:@\"-\"] && args[i].length > 1) {\n                flag = [args[i] substringFromIndex:1];\n                if ([args[i] isEqualToString:@\"-N\"]) {\n                    skip = 1;\n                } else if ([args[i] isEqualToString:@\"-T\"]) {\n                    skip = 1;\n                } else {\n                    skip = 0;\n                }\n                if (skip == 0) {\n                    flags[flag] = [NSNull null];\n                } else {\n                    flags[flag] = @[];\n                }\n                // Skip flag and any arguments.\n                continue;\n            }\n            if (key == nil) {\n                key = args[i];\n                continue;\n            }\n            command = [[args subarrayFromIndex:i] componentsJoinedByString:@\" \"];\n            break;\n        }\n        if (!key || !command || !flags) {\n            DLog(@\"Bad line: %@\", line);\n            return nil;\n        }\n        return @{ @\"key\": key,\n                  @\"command\": command,\n                  @\"flags\": flags };\n    }];\n    NSArray<NSString *> *forbiddenCommands = @[\n        @\"bind-key\",\n        @\"choose-buffer\",\n        @\"choose-client\",\n        @\"choose-tree\",\n        @\"clear-history\",\n        @\"clock-mode\",\n        @\"command-prompt\",\n        @\"confirm-before\",\n        @\"copy-mode\",\n        @\"customize-mode\",\n        @\"display-menu\",\n        @\"display-message\",\n        @\"display-panes\",\n        @\"display-popup\",\n        @\"find-window\",\n        @\"list-buffers\",\n        @\"list-clients\",\n        @\"list-commands\",\n        @\"list-keys\",\n        @\"list-panes\",\n        @\"list-sessions\",\n        @\"list-windows\",\n        @\"show-buffer\",\n        @\"show-messages\",\n        @\"unbind-key\",\n    ];\n    dicts = [dicts filteredArrayUsingBlock:^BOOL(NSDictionary *dict) {\n        NSString *command = [[dict[@\"command\"] componentsSeparatedByString:@\" \"] firstObject];\n        return [dict[@\"flags\"][@\"T\"] isEqual:@[@\"prefix\"]] && ![forbiddenCommands containsObject:command];\n    }];\n    NSMutableDictionary *fakeProfile = [@{ KEY_KEYBOARD_MAP: _sharedKeyMappingOverrides } mutableCopy];\n\n    for (NSDictionary *dict in dicts) {\n        iTermKeystroke *keystroke = [iTermKeystroke withTmuxKey:dict[@\"key\"]];\n        if (!keystroke) {\n            DLog(@\"Couldn't make keystroke for %@\", dict);\n            continue;\n        }\n\n        iTermKeyBindingAction *action = [iTermKeyBindingAction withAction:KEY_ACTION_SEND_TMUX_COMMAND\n                                                                parameter:dict[@\"command\"]\n                                                                 escaping:iTermSendTextEscapingNone\n                                                                applyMode:iTermActionApplyModeCurrentSession];\n        NSString *dictKey = [keystroke keyInBindingDictionary:fakeProfile[KEY_KEYBOARD_MAP]];\n        NSInteger index = NSNotFound;\n        if (dictKey) {\n            index = [[iTermKeyMappings sortedKeystrokesForProfile:fakeProfile] indexOfObject:keystroke];\n        }\n        [iTermKeyMappings setMappingAtIndex:index\n                               forKeystroke:keystroke\n                                     action:action\n                                  createNew:index == NSNotFound\n                                  inProfile:fakeProfile];\n    }\n\n    _sharedKeyMappingOverrides = fakeProfile[KEY_KEYBOARD_MAP];\n}\n\n- (void)handleShowSetTitles:(NSString *)result {\n    _shouldSetTitles = [result isEqualToString:@\"on\"];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerDidFetchSetTitlesStringOption\n                                                        object:self];\n}\n\n- (void)guessVersion {\n    // Run commands that will fail in successively older versions.\n    // show-window-options pane-border-format will succeed in 2.3 and later (presumably. 2.3 isn't out yet)\n    // the socket_path format was added in 2.2.\n    // the session_activity format was added in 2.1\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:@\"display-message -p \\\"#{version}\\\"\"\n                                           responseTarget:self\n                                         responseSelector:@selector(handleDisplayMessageVersion:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n\n                           [gateway_ dictionaryForCommand:@\"show-window-options pane-border-format\"\n                                           responseTarget:self\n                                         responseSelector:@selector(guessVersion23Response:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:@\"list-windows -F \\\"#{socket_path}\\\"\"\n                                           responseTarget:self\n                                         responseSelector:@selector(guessVersion22Response:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:@\"list-windows -F \\\"#{pid}\\\"\"\n                                           responseTarget:self\n                                         responseSelector:@selector(guessVersion21Response:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors],\n                           [gateway_ dictionaryForCommand:@\"show-options -g message-style\"  // message-style added in 1.9\n                                           responseTarget:self\n                                         responseSelector:@selector(guessVersion18Response:)\n                                           responseObject:nil\n                                                    flags:kTmuxGatewayCommandShouldTolerateErrors]\n                           ];\n    for (NSDictionary *command in commands) {\n        [gateway_ sendCommandList:@[ command ]];\n    }\n}\n\n- (void)decreaseMaximumServerVersionTo:(NSString *)string {\n    NSDecimalNumber *number = [NSDecimalNumber decimalNumberWithString:string];\n    if (!gateway_.maximumServerVersion ||\n        [gateway_.maximumServerVersion compare:number] == NSOrderedDescending) {\n        gateway_.maximumServerVersion = number;\n        DLog(@\"Decreasing maximum server version to %@\", number);\n    }\n}\n\n- (void)increaseMinimumServerVersionTo:(NSString *)string {\n    NSDecimalNumber *number = [NSDecimalNumber decimalNumberWithString:string];\n    if (!gateway_.minimumServerVersion ||\n        [gateway_.minimumServerVersion compare:number] == NSOrderedAscending) {\n        gateway_.minimumServerVersion = number;\n        DLog(@\"Increasing minimum server version to %@\", number);\n    }\n}\n\n- (void)checkForUTF8Response:(NSString *)response {\n    if ([response containsString:@\"_\"]) {\n        [gateway_ abortWithErrorMessage:@\"tmux is not in UTF-8 mode. Please pass the -u command line argument to tmux or change your LANG environment variable to end with \u201c.UTF-8\u201d.\"\n                                  title:@\"UTF-8 Mode Not Detected\"];\n    }\n}\n\n- (void)handleDisplayMessageVersion:(NSString *)response {\n    DLog(@\"handleDisplayMessageVersion: %@\", response);\n    if ([response isEqualToString:@\"openbsd-7.1\"]) {\n        [self handleDisplayMessageVersion:@\"3.4\"];\n        return;\n    }\n    if ([response isEqualToString:@\"openbsd-6.8\"]) {\n        [self handleDisplayMessageVersion:@\"3.2\"];\n        return;\n    }\n    if ([response isEqualToString:@\"openbsd-6.7\"]) {\n        [self handleDisplayMessageVersion:@\"3.0\"];\n        return;\n    }\n    NSString *openbsdPrefix = @\"openbsd-\";\n    if ([response hasPrefix:openbsdPrefix]) {\n        NSString *suffix = [response substringFromIndex:openbsdPrefix.length];\n        NSDecimalNumber *number = [NSDecimalNumber decimalNumberWithString:suffix];\n        if (number) {\n            if ([number compare:[NSDecimalNumber decimalNumberWithString:@\"7.1\"]] != NSOrderedAscending) {\n                // version >= 7.1\n                [self handleDisplayMessageVersion:@\"3.4\"];\n            }\n            // version < 7.1\n            [self handleDisplayMessageVersion:@\"3.2\"];\n        } else {\n            // This should never happen (decimalNumberWithString returns a nonnil value)\n            [self handleDisplayMessageVersion:@\"3.2\"];\n        }\n        return;\n    }\n    // openbsd-6.6 and earlier are never reported; you just get an empty string.\n    if (response.length == 0) {\n        // The \"version\" format was first added in 2.4\n        [self decreaseMaximumServerVersionTo:@\"2.3\"];\n        return;\n    }\n\n    if ([response isEqualToString:@\"next-3.4\"]) {\n        // Work around a bug where tmux sends \\t instead of tab in list-windows response.\n        _shouldWorkAroundTabBug = YES;\n    }\n\n    NSString *nextPrefix = @\"next-\";\n    if ([response hasPrefix:nextPrefix]) {\n        [self handleDisplayMessageVersion:[response substringFromIndex:nextPrefix.length]];\n        return;\n    }\n    if ([response hasSuffix:@\"-rc\"]) {\n        response = [response stringByDroppingLastCharacters:3];\n    }\n    // In case we get back something that's not a number, or a totally unreasonable number, just ignore this.\n    DLog(@\"response=%@\", response);\n    NSDecimalNumber *number = [NSDecimalNumber decimalNumberWithString:response];\n    DLog(@\"number=%@\", number);\n    if (number.doubleValue != number.doubleValue ||\n        number.doubleValue < 2.4 || number.doubleValue > 10) {\n        DLog(@\"nan or out of bounds, do nothing.\");\n        return;\n    }\n    \n    // Sadly tmux version numbers look like 2.9 or 2.9a instead of a proper decimal number.\n    NSRange range = [response rangeOfCharacterFromSet:[NSCharacterSet lowercaseLetterCharacterSet]];\n    DLog(@\"Use range %@\", NSStringFromRange(range));\n    if (range.location == NSNotFound) {\n        DLog(@\"Normal case: increase min version to %@\", response);\n        [self increaseMinimumServerVersionTo:response];\n    } else {\n        // Convert 2.9a to 2.91\n        // According to this issue it should be safe to do this:\n        // https://github.com/tmux/tmux/issues/1712\n        unichar c = [response characterAtIndex:range.location];\n        NSInteger bug = c - 'a' + 1;\n        NSString *prefix = [response substringToIndex:range.location];\n        NSString *version = [NSString stringWithFormat:@\"%@%@\", prefix, @(bug)];\n        DLog(@\"dot-release. Increase min version to %@\", version);\n        [self increaseMinimumServerVersionTo:version];\n    }\n\n    if (gateway_.minimumServerVersion.doubleValue >= 2.9 && [iTermAdvancedSettingsModel tmuxVariableWindowSizesSupported]) {\n        _variableWindowSize = YES;\n    }\n\n    _versionDetected = YES;\n    [self didGuessVersion];\n}\n\n- (void)guessVersion23Response:(NSString *)response {\n    if (_versionDetected) {\n        DLog(@\"Version already detected.\");\n        return;\n    }\n    DLog(@\"guessVersion23Response\");\n    if (response == nil) {\n        [self decreaseMaximumServerVersionTo:@\"2.2\"];\n    } else {\n        [self increaseMinimumServerVersionTo:@\"2.3\"];\n    }\n}\n\n- (void)guessVersion22Response:(NSString *)response {\n    if (_versionDetected) {\n        DLog(@\"Version already detected.\");\n        return;\n    }\n    DLog(@\"guessVersion22Response\");\n    const NSInteger index = [response rangeOfCharacterFromSet:[[NSCharacterSet whitespaceAndNewlineCharacterSet] invertedSet]].location;\n    if (index == NSNotFound) {\n        [self decreaseMaximumServerVersionTo:@\"2.1\"];\n    } else {\n        [self increaseMinimumServerVersionTo:@\"2.2\"];\n    }\n}\n\n- (void)guessVersion21Response:(NSString *)response {\n    if (_versionDetected) {\n        DLog(@\"Version already detected.\");\n        return;\n    }\n    DLog(@\"guessVersion21Response\");\n    if (response.length == 0) {\n        [self decreaseMaximumServerVersionTo:@\"2.0\"];\n    } else {\n        [self increaseMinimumServerVersionTo:@\"2.1\"];\n    }\n}\n\n- (void)guessVersion18Response:(NSString *)response {\n    if (_versionDetected) {\n        DLog(@\"Version already detected.\");\n        return;\n    }\n    DLog(@\"guessVersion18Response\");\n    if (response != nil) {\n        [self increaseMinimumServerVersionTo:@\"1.9\"];\n    } else {\n        [self decreaseMaximumServerVersionTo:@\"1.8\"];\n    }\n\n    // This is the oldest version supported. By the time you get here you know the version.\n    [self didGuessVersion];\n}\n\n// Actions to perform after the version number is known.\n- (void)didGuessVersion {\n    DLog(@\"didGuessVersion\");\n    [self enablePauseModeIfPossible];\n    [self loadServerPID];\n    [self loadTitleFormat];\n    _versionKnown = YES;\n    if (_wantsOpenWindowsInitial) {\n        _wantsOpenWindowsInitial = NO;\n        [self openWindowsInitial];\n    }\n}\n\n- (BOOL)versionAtLeastDecimalNumberWithString:(NSString *)string {\n    return [gateway_ versionAtLeastDecimalNumberWithString:string];\n}\n\n- (BOOL)recyclingSupported {\n    return [self versionAtLeastDecimalNumberWithString:@\"1.9\"];\n}\n\n// Show an error and terminate the connection because tmux has an unsupported option turned on.\n- (void)optionValidationFailedForOption:(NSString *)option\n{\n    NSString *message = [NSString stringWithFormat:\n                            @\"The \\\"%@\\\" option is turned on in tmux. \"\n                             \"It is not compatible with the iTerm2-tmux integration. \"\n                             \"Please disable it and try again.\",\n                             option];\n    [gateway_ abortWithErrorMessage:message\n                              title:@\"Unsupported tmux option\"];\n}\n\n- (NSArray *)unsupportedGlobalOptions\n{\n    // The aggressive-resize option is not supported because it relies on the\n    // concept of a current window in tmux, which doesn't exist in the\n    // integration mode.\n    return [NSArray arrayWithObjects:kAggressiveResize, nil];\n}\n\n// Parse the output of show-window-options sent in -validateOptions, possibly\n// showing an error and terminating the connection.\n- (void)showWindowOptionsResponse:(NSString *)response {\n    NSArray *unsupportedGlobalOptions = [self unsupportedGlobalOptions];\n    NSArray *lines = [response componentsSeparatedByString:@\"\\n\"];\n    for (NSString *line in lines) {\n        NSArray *fields = [line componentsSeparatedByString:@\" \"];\n        if ([fields count] == 2) {\n            NSString *option = [fields objectAtIndex:0];\n            NSString *value = [fields objectAtIndex:1];\n\n            for (NSString *unsupportedOption in unsupportedGlobalOptions) {\n                if ([option isEqualToString:unsupportedOption]) {\n                    if ([value isEqualToString:@\"on\"]) {\n                        [self optionValidationFailedForOption:unsupportedOption];\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}\n\n- (BOOL)hasOutstandingWindowResize\n{\n    return numOutstandingWindowResizes_ > 0;\n}\n\n- (void)windowPane:(int)wp\n         resizedBy:(int)amount\n      horizontally:(BOOL)wasHorizontal\n{\n    NSString *dir;\n    if (wasHorizontal) {\n        if (amount > 0) {\n            dir = @\"R\";\n        } else {\n            dir = @\"L\";\n        }\n    } else {\n        if (amount > 0) {\n            dir = @\"D\";\n        } else {\n            dir = @\"U\";\n        }\n    }\n    NSString *resizeStr = [NSString stringWithFormat:@\"resize-pane -%@ -t \\\"%%%d\\\" %d\",\n                           dir, wp, abs(amount)];\n    NSString *listStr = [self commandToListWindows];\n    NSArray *commands = [NSArray arrayWithObjects:\n                         [gateway_ dictionaryForCommand:resizeStr\n                                         responseTarget:nil\n                                       responseSelector:nil\n                                         responseObject:nil\n                                                  flags:0],\n                         [gateway_ dictionaryForCommand:listStr\n                                         responseTarget:self\n                                       responseSelector:@selector(listWindowsResponse:)\n                                         responseObject:nil\n                                                  flags:0],\n                         nil];\n    ++numOutstandingWindowResizes_;\n    [gateway_ sendCommandList:commands];\n}\n\n// The splitVertically parameter uses the iTerm2 conventions.\n- (void)splitWindowPane:(int)wp\n             vertically:(BOOL)splitVertically\n                  scope:(iTermVariableScope *)scope\n       initialDirectory:(iTermInitialDirectory *)initialDirectory\n             completion:(void (^)(int wp))completion {\n    // No need for a callback. We should get a layout-changed message and act on it.\n    __weak __typeof(self) weakSelf = self;\n    [initialDirectory tmuxSplitWindowCommand:wp\n                                  vertically:splitVertically\n                          recyclingSupported:self.recyclingSupported\n                                       scope:scope\n                                  completion:\n     ^(NSString *command) {\n        __strong __typeof(self) strongSelf = weakSelf;\n        if (!strongSelf) {\n            return;\n        }\n        TmuxGateway *gateway = strongSelf->gateway_;\n        if (!completion) {\n            [gateway sendCommand:command responseTarget:nil responseSelector:nil];\n            return;\n        }\n\n        // Get the list of panes, then split, then get the list of panes again.\n        // This seems to be the only way to get the pane ID of the new pane.\n        NSString *listPanesCommand = [NSString stringWithFormat:@\"list-panes -t %%%d -F '#{pane_id}'\", wp];\n        NSMutableDictionary *state = [NSMutableDictionary dictionary];\n        state[iTermTmuxControllerSplitStateCompletion] = [completion copy];\n        NSDictionary *initialListPanes = [gateway dictionaryForCommand:listPanesCommand\n                                                        responseTarget:self\n                                                      responseSelector:@selector(recordPanes:state:)\n                                                        responseObject:state\n                                                                 flags:0];\n        NSDictionary *split = [gateway dictionaryForCommand:command\n                                             responseTarget:nil\n                                           responseSelector:nil\n                                             responseObject:nil\n                                                      flags:kTmuxGatewayCommandShouldTolerateErrors];\n        NSDictionary *followupListPanes = [gateway dictionaryForCommand:listPanesCommand\n                                                         responseTarget:self\n                                                       responseSelector:@selector(didSplit:state:)\n                                                         responseObject:state\n                                                                  flags:kTmuxGatewayCommandShouldTolerateErrors];\n        [gateway sendCommandList:@[ initialListPanes, split, followupListPanes ]];\n     }];\n}\n\n// Save pane list before splitting.\n- (void)recordPanes:(NSString *)list state:(NSMutableDictionary *)state {\n    state[iTermTmuxControllerSplitStateInitialPanes] = [NSSet setWithArray:[list componentsSeparatedByString:@\"\\n\"]];\n}\n\n// Compute new window pane after splitting and run callback if any.\n- (void)didSplit:(NSString *)list state:(NSMutableDictionary *)state {\n    NSSet<NSString *> *after = [NSSet setWithArray:[list componentsSeparatedByString:@\"\\n\"]];\n    NSSet<NSString *> *before = state[iTermTmuxControllerSplitStateInitialPanes] ?: [NSSet set];\n    NSMutableSet<NSString *> *additions = [after mutableCopy];\n    [additions minusSet:before];\n    void (^completion)(int) = state[iTermTmuxControllerSplitStateCompletion];\n    if (additions.count == 0) {\n        completion(-1);\n        return;\n    }\n    if (additions.count > 1) {\n        DLog(@\"Multiple additions found! Picking one at random.\");\n    }\n    NSString *string = [additions anyObject];\n    if (![string hasPrefix:@\"%\"]) {\n        completion(-1);\n        return;\n    }\n    string = [string substringFromIndex:1];\n    completion([string intValue]);\n}\n\n- (void)selectPane:(int)windowPane {\n    if (_suppressActivityChanges) {\n        DLog(@\"Not sending select-pane -t %%%d because activity changes are suppressed\", windowPane);\n        return;\n    }\n    NSDecimalNumber *version2_9 = [NSDecimalNumber decimalNumberWithString:@\"2.9\"];\n\n    if ([gateway_.minimumServerVersion isEqual:version2_9]) {\n        // I presume this will be fixed in whatever verson follows 2.9, so use an isEqual:. I need to remember to revisit this after the bug is fixed!\n        return;\n    }\n\n    NSString *command = [NSString stringWithFormat:@\"select-pane -t \\\"%%%d\\\"\", windowPane];\n    [gateway_ sendCommand:command\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)newWindowInSessionNumber:(NSNumber *)sessionNumber\n                           scope:(iTermVariableScope *)scope\n                initialDirectory:(iTermInitialDirectory *)initialDirectory {\n    __weak __typeof(self) weakSelf = self;\n    [initialDirectory tmuxNewWindowCommandInSessionNumber:sessionNumber\n                                       recyclingSupported:self.recyclingSupported\n                                                    scope:scope\n                                               completion:\n     ^(NSString *command) {\n        [weakSelf didCreateWindowWithCommand:command];\n    }];\n}\n\n- (void)didCreateWindowWithCommand:(NSString *)command {\n    NSMutableArray *commands = [NSMutableArray array];\n    if (_variableWindowSize) {\n        Profile *profile = self.sharedProfile;\n        NSSize size = NSMakeSize(MIN(iTermMaxInitialSessionSize,\n                                     [profile[KEY_COLUMNS] intValue] ?: 80),\n                                 MIN(iTermMaxInitialSessionSize,\n                                     [profile[KEY_ROWS] intValue] ?: 25));\n        ITBetaAssert((int)size.width > 0, @\"Invalid size\");\n        const int height = [self adjustHeightForStatusBar:size.height];\n        ITBetaAssert(height > 0, @\"Invalid size\");\n        [_windowSizes removeAllObjects];\n        NSString *setSizeCommand = [NSString stringWithFormat:@\"refresh-client -C %d,%d\",\n                                    (int)size.width, height];\n        [commands addObject:[gateway_ dictionaryForCommand:setSizeCommand\n                                            responseTarget:nil\n                                          responseSelector:nil\n                                            responseObject:nil\n                                                     flags:kTmuxGatewayCommandShouldTolerateErrors]];\n    }\n    [commands addObject:[gateway_ dictionaryForCommand:command\n                                        responseTarget:nil\n                                      responseSelector:nil\n                                        responseObject:nil\n                                                 flags:0]];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)newWindowWithAffinity:(NSString *)windowIdString\n                         size:(NSSize)size\n             initialDirectory:(iTermInitialDirectory *)initialDirectory\n                        index:(NSNumber *)index\n                        scope:(iTermVariableScope *)scope\n                   completion:(void (^)(int))completion {\n    _manualOpenRequested = (windowIdString != nil);\n    BOOL variableWindowSize = _variableWindowSize;\n    __weak __typeof(self) weakSelf = self;\n    [initialDirectory tmuxNewWindowCommandRecyclingSupported:self.recyclingSupported\n                                                       scope:scope\n                                                  completion:\n     ^(NSString *command) {\n        [weakSelf didCreateWindowWithAffinity:windowIdString\n                                      command:command\n                           variableWindowSize:variableWindowSize\n                                         size:size\n                                        index:index\n                                   completion:completion];\n    }];\n}\n\n- (void)didCreateWindowWithAffinity:(NSString *)windowIdString\n                            command:(NSString *)command\n                 variableWindowSize:(BOOL)variableWindowSize\n                               size:(NSSize)size\n                              index:(NSNumber *)index\n                         completion:(void (^)(int))completion {\n    if (detached_) {\n        return;\n    }\n    NSMutableArray *commands = [NSMutableArray array];\n    if (variableWindowSize) {\n        ITBetaAssert((int)size.width > 0, @\"Invalid size\");\n        const int height = [self adjustHeightForStatusBar:size.height];\n        ITBetaAssert(height > 0, @\"Invalid size\");\n        [_windowSizes removeAllObjects];\n        NSString *setSizeCommand = [NSString stringWithFormat:@\"refresh-client -C %d,%d\",\n                                    (int)size.width, height];\n        [commands addObject:[gateway_ dictionaryForCommand:setSizeCommand\n                                            responseTarget:nil\n                                          responseSelector:nil\n                                            responseObject:nil\n                                                     flags:kTmuxGatewayCommandShouldTolerateErrors]];\n    }\n    [commands addObject:[gateway_ dictionaryForCommand:command\n                                        responseTarget:self\n                                      responseSelector:@selector(newWindowWithAffinityCreated:affinityWindowAndCompletion:)\n                                        responseObject:[iTermTriple tripleWithObject:windowIdString\n                                                                           andObject:[completion copy]\n                                                                              object:index]\n                                                 flags:0]];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)movePane:(int)srcPane\n        intoPane:(int)destPane\n      isVertical:(BOOL)splitVertical\n          before:(BOOL)addBefore\n{\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"move-pane -s \\\"%%%d\\\" -t \\\"%%%d\\\" %@%@\",\n                           srcPane, destPane, splitVertical ? @\"-h\" : @\"-v\",\n                           addBefore ? @\" -b\" : @\"\"]\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)killWindowPane:(int)windowPane\n{\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"kill-pane -t \\\"%%%d\\\"\", windowPane]\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandOfferToDetachIfLaggyDuplicate | kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)unlinkWindowWithId:(int)windowId {\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"unlink-window -k -t @%d\", windowId]\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (NSString *)stringByEscapingBackslashesAndRemovingNewlines:(NSString *)name {\n    return [[name stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\" \"] stringByReplacingOccurrencesOfString:@\"\\\\\" withString:@\"\\\\\\\\\"];\n}\n\n- (void)setWindowTitleOverride:(NSString *)title\n                        window:(int)windowId {\n    [self renameWindowWithId:windowId inSessionNumber:nil toName:title];\n    [self savePerTabSettings];\n}\n\n- (void)renameWindowWithId:(int)windowId\n           inSessionNumber:(NSNumber *)sessionNumber\n                    toName:(NSString *)newName {\n    NSString *theCommand;\n    if (sessionNumber) {\n        theCommand = [NSString stringWithFormat:@\"rename-window -t \\\"$%d:@%d\\\" \\\"%@\\\"\",\n                      sessionNumber.intValue,\n                      windowId,\n                      [self stringByEscapingBackslashesAndRemovingNewlines:newName]];\n    } else {\n        theCommand = [NSString stringWithFormat:@\"rename-window -t @%d \\\"%@\\\"\", windowId, [self stringByEscapingBackslashesAndRemovingNewlines:newName]];\n    }\n    [gateway_ sendCommand:theCommand\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (BOOL)canRenamePane {\n    NSDecimalNumber *version2_6 = [NSDecimalNumber decimalNumberWithString:@\"2.6\"];\n    if ([gateway_.minimumServerVersion compare:version2_6] == NSOrderedAscending) {\n        return NO;\n    }\n    return YES;\n}\n\n- (void)renamePane:(int)windowPane toTitle:(NSString *)newTitle {\n    if (![self canRenamePane]) {\n        return;\n    }\n    NSString *theCommand = [NSString stringWithFormat:@\"select-pane -t %%%d -T \\\"%@\\\"\",\n                            windowPane, [self stringByEscapingBackslashesAndRemovingNewlines:newTitle]];\n    [gateway_ sendCommand:theCommand\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)setHotkeyForWindowPane:(int)windowPane to:(NSDictionary *)dict {\n    _hotkeys[@(windowPane)] = dict;\n\n    // First get a list of existing panes so we can avoid setting hotkeys for any nonexistent panes. Keeps the string from getting too long.\n    NSString *getPaneIDsCommand = [NSString stringWithFormat:@\"list-panes -s -t $%d -F \\\"#{pane_id}\\\"\", sessionId_];\n    [gateway_ sendCommand:getPaneIDsCommand\n           responseTarget:self\n         responseSelector:@selector(getPaneIDsResponseAndSetHotkeys:)\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)setTabColorString:(NSString *)colorString forWindowPane:(int)windowPane {\n    if ([_tabColors[@(windowPane)] isEqualToString:colorString]) {\n        return;\n    }\n    _tabColors[@(windowPane)] = colorString;\n\n    // First get a list of existing panes so we can avoid setting tab colors for any nonexistent panes. Keeps the string from getting too long.\n    NSString *getPaneIDsCommand = [NSString stringWithFormat:@\"list-panes -s -t $%d -F \\\"#{pane_id}\\\"\", sessionId_];\n    [gateway_ sendCommand:getPaneIDsCommand\n           responseTarget:self\n         responseSelector:@selector(getPaneIDsResponseAndSetTabColors:)\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n\n- (void)getPaneIDsResponseAndSetHotkeys:(NSString *)response {\n    [_paneIDs removeAllObjects];\n    for (NSString *pane in [response componentsSeparatedByString:@\"\\n\"]) {\n        if (pane.length) {\n            [_paneIDs addObject:@([[pane substringFromIndex:1] intValue])];\n        }\n    }\n    [self sendCommandToSetHotkeys];\n}\n\n- (void)getPaneIDsResponseAndSetTabColors:(NSString *)response {\n    [_paneIDs removeAllObjects];\n    for (NSString *pane in [response componentsSeparatedByString:@\"\\n\"]) {\n        if (pane.length) {\n            [_paneIDs addObject:@([[pane substringFromIndex:1] intValue])];\n        }\n    }\n    [self sendCommandToSetTabColors];\n}\n\n- (NSString *)encodedString:(NSString *)string prefix:(NSString *)prefix {\n    return [prefix stringByAppendingString:[[string dataUsingEncoding:NSUTF8StringEncoding] it_hexEncoded]];\n}\n\n- (NSString *)decodedString:(NSString *)string optionalPrefix:(NSString *)prefix {\n    if (![string hasPrefix:prefix]) {\n        return string;\n    }\n    return [[NSString alloc] initWithData:[[string substringFromIndex:prefix.length] dataFromHexValues]\n                                 encoding:NSUTF8StringEncoding];\n}\n\n- (void)sendCommandToSetHotkeys {\n    NSString *hexEncoded = [self encodedString:[self.hotkeysString stringByEscapingQuotes]\n                                        prefix:iTermTmuxControllerEncodingPrefixHotkeys];\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @hotkeys \\\"%@\\\"\",\n                         sessionId_, hexEncoded];\n    [gateway_ sendCommand:command\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)sendCommandToSetTabColors {\n\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @tab_colors \\\"%@\\\"\",\n                         sessionId_, [self encodedString:[self.tabColorsString stringByEscapingQuotes]\n                                                  prefix:iTermTmuxControllerEncodingPrefixTabColors]];\n    [gateway_ sendCommand:command\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (NSDictionary *)hotkeyForWindowPane:(int)windowPane {\n    return _hotkeys[@(windowPane)];\n}\n\n- (NSString *)tabColorStringForWindowPane:(int)windowPane {\n    return _tabColors[@(windowPane)];\n}\n\n- (void)killWindow:(int)window {\n    [[NSNotificationCenter defaultCenter] postNotificationName:iTermTmuxControllerWillKillWindow object:@(window)];\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"kill-window -t @%d\", window]\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandOfferToDetachIfLaggyDuplicate | kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (NSString *)breakPaneWindowPaneFlag {\n    NSDecimalNumber *version2_1 = [NSDecimalNumber decimalNumberWithString:@\"2.1\"];\n\n    if ([gateway_.maximumServerVersion compare:version2_1] == NSOrderedAscending) {\n        // 2.0 and earlier versions take -t for the window pane\n        return @\"-t\";\n    }\n    if ([gateway_.minimumServerVersion compare:version2_1] != NSOrderedAscending) {\n        // 2.1+ takes -s for the window pane\n        return @\"-s\";\n    }\n\n    // You shouldn't get here.\n    return @\"-s\";\n}\n\n- (void)breakOutWindowPane:(int)windowPane toPoint:(NSPoint)screenPoint\n{\n    [windowPositions_ setObject:[NSValue valueWithPoint:screenPoint]\n                         forKey:[NSNumber numberWithInt:windowPane]];\n    [self breakOutWindowPane:windowPane toTabAside:iTermTmuxControllerPhonyAffinity];\n}\n\n- (void)breakOutWindowPane:(int)windowPane toTabAside:(NSString *)sibling\n{\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"break-pane -P -F \\\"#{window_id}\\\" %@ \\\"%%%d\\\"\",\n                           [self breakPaneWindowPaneFlag], windowPane]\n           responseTarget:self\n         responseSelector:@selector(windowPaneBrokeOutWithWindowId:setAffinityTo:)\n           responseObject:sibling\n                    flags:0];\n}\n\n- (void)windowPaneBrokeOutWithWindowId:(NSString *)windowId\n                         setAffinityTo:(NSString *)windowGuid\n{\n    if ([windowId hasPrefix:@\"@\"]) {\n        windowId = [windowId substringFromIndex:1];\n        if ([windowGuid isEqualToString:iTermTmuxControllerPhonyAffinity]) {\n            _pendingWindows[@(windowId.intValue)] = [iTermTmuxPendingWindow trivialInstance];\n        } else {\n            [affinities_ setValue:windowGuid equalToValue:windowId];\n        }\n    }\n}\n\n- (BOOL)windowIsHidden:(int)windowId {\n    return [hiddenWindows_ containsObject:@(windowId)];\n}\n\n- (void)hideWindow:(int)windowId {\n    [self hideWindows:@[ @(windowId) ] andCloseTabs:YES];\n}\n\n- (NSString *)terminalGUIDForWindowID:(int)wid {\n    for (PseudoTerminal *term in [[iTermController sharedInstance] terminals]) {\n        for (PTYTab *tab in term.tabs) {\n            if (tab.isTmuxTab && tab.tmuxController == self && tab.tmuxWindow == wid) {\n                return term.terminalGuid;\n            }\n        }\n    }\n    return nil;\n}\n\n- (void)setWindowID:(int)wid buriedFromTerminalGUID:(NSString *)terminalGUID tabIndex:(int)tabIndex {\n    DLog(@\"set %@ = %@\", @(wid), terminalGUID);\n    NSMutableArray<iTermTuple<NSNumber *, NSNumber *> *> *wids = _buriedWindows[terminalGUID];\n    if (!wids) {\n        wids = [NSMutableArray array];\n        _buriedWindows[terminalGUID] = wids;\n    }\n    if (![wids objectPassingTest:^BOOL(iTermTuple<NSNumber *,NSNumber *> *element, NSUInteger index, BOOL *stop) {\n        return [element.firstObject isEqual:@(wid)];\n    }]) {\n        [wids addObject:[iTermTuple tupleWithObject:@(wid) andObject:@(tabIndex)]];\n    }\n}\n\n- (int)tabIndexOfWindowID:(int)wid {\n    for (PseudoTerminal *term in [[iTermController sharedInstance] terminals]) {\n        int i = 0;\n        for (PTYTab *tab in term.tabs) {\n            if (tab.isTmuxTab && tab.tmuxController == self && tab.tmuxWindow == wid) {\n                return i;\n            }\n            i += 1;\n        }\n    }\n    return -1;\n}\n\n- (void)hideWindows:(NSArray<NSNumber *> *)windowIDs andCloseTabs:(BOOL)closeTabs {\n    DLog(@\"hideWindow: Add these window IDs to hidden: %@\", windowIDs);\n    if (closeTabs) {\n        DLog(@\"burying window IDs %@\", [[windowIDs mapWithBlock:^id(NSNumber *anObject) {\n            return [anObject description];\n        }] componentsJoinedByString:@\", \"]);\n        // Update _buriedWindows\n        [windowIDs enumerateObjectsUsingBlock:^(NSNumber * _Nonnull wid, NSUInteger idx, BOOL * _Nonnull stop) {\n            NSString *terminalGUID = [self terminalGUIDForWindowID:wid.intValue];\n            if (!terminalGUID) {\n                return;\n            }\n            [self setWindowID:wid.intValue buriedFromTerminalGUID:terminalGUID tabIndex:[self tabIndexOfWindowID:wid.intValue]];\n        }];\n    }\n    [hiddenWindows_ addObjectsFromArray:windowIDs];\n    [self saveHiddenWindows];\n    if (closeTabs) {\n        for (NSNumber *widNumber in windowIDs) {\n            const int windowId = widNumber.intValue;\n            PTYTab *theTab = [self window:windowId];\n            if (theTab) {\n                [[theTab realParentWindow] closeTab:theTab soft:YES];\n            }\n        }\n    }\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerDidChangeHiddenWindows object:self];\n}\n\n- (void)openWindowWithId:(int)windowId\n              affinities:(NSArray *)affinities\n             intentional:(BOOL)intentional\n                 profile:(Profile *)profile {\n    if (intentional) {\n        DLog(@\"open intentional: Remove this window ID from hidden: %d\", windowId);\n        if (!_pendingWindows[@(windowId)]) {\n            // This indicates that the window's opening is originated by the app (it is not\n            // \"anonymous\"), as opposed to running `tmux new-window` at the command line.\n            DLog(@\"Force intentional\");\n            _pendingWindows[@(windowId)] = [iTermTmuxPendingWindow trivialInstance];\n        }\n        [hiddenWindows_ removeObject:[NSNumber numberWithInt:windowId]];\n        [self saveHiddenWindows];\n        [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerDidChangeHiddenWindows object:self];\n    }\n    __block NSNumber *tabIndex = _pendingWindows[@(windowId)].index;\n    [_buriedWindows enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull terminalGUID, NSMutableArray<iTermTuple<NSNumber *, NSNumber *> *> * _Nonnull tuples, BOOL * _Nonnull stop) {\n        const NSInteger i = [tuples indexOfObjectPassingTest:^BOOL(iTermTuple<NSNumber *,NSNumber *> * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n            return [obj.firstObject isEqual:@(windowId)];\n        }];\n        if (i != NSNotFound) {\n            tabIndex = tuples[i].secondObject;\n            [tuples removeObjectAtIndex:i];\n            DLog(@\"Add affinities for terminal %@: %@\", terminalGUID, [[tuples mapWithBlock:^id(iTermTuple *anObject) {\n                return anObject.description;\n            }] componentsJoinedByString:@\", \"]);\n            [affinities_ setValue:[@(windowId) stringValue] equalToValue:terminalGUID];\n        }\n    }];\n    // Get the window's basic info to prep the creation of a TmuxWindowOpener.\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"display -p -F %@ -t @%d\",\n                           [self listWindowsDetailedFormat], windowId]\n           responseTarget:self\n         responseSelector:@selector(listedWindowsToOpenOne:forWindowIdAndAffinities:)\n           responseObject:@[ @(windowId), affinities, profile, tabIndex ?: @-1 ]\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)openWindowWithId:(int)windowId\n             intentional:(BOOL)intentional\n                 profile:(Profile *)profile {\n    [self openWindowWithId:windowId\n                affinities:@[]\n               intentional:intentional\n                   profile:profile];\n}\n\n- (void)linkWindowId:(int)windowId\n     inSessionNumber:(int)sessionNumber\n     toSessionNumber:(int)targetSessionNumber {\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"link-window -s \\\"$%d:@%d\\\" -t \\\"$%d:+\\\"\",\n                           sessionNumber, windowId, targetSessionNumber]\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)moveWindowId:(int)windowId\n     inSessionNumber:(int)sessionNumber\n     toSessionNumber:(int)targetSessionNumber {\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"move-window -s \\\"$%d:@%d\\\" -t \\\"$%d:+\\\"\",\n                           sessionNumber, windowId, targetSessionNumber]\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n// Find a position for any key in panes and remove all entries with keys in panes.\n// windowPositions_ is used for setting the origin of a pane after moving it into a window, which\n// is rarely done. This falls back to the recorded window origin if one is present.\n- (NSValue *)positionForWindowWithPanes:(NSArray *)panes\n                               windowID:(int)windowID {\n    NSValue *pos = nil;\n    for (NSNumber *n in panes) {\n        pos = [windowPositions_ objectForKey:n];\n        if (pos) {\n            break;\n        }\n    }\n    [windowPositions_ removeObjectsForKeys:panes];\n    if ([iTermAdvancedSettingsModel disableTmuxWindowPositionRestoration]) {\n        return nil;\n    }\n    return pos ?: origins_[@(windowID)];\n}\n\n- (void)renameSessionNumber:(int)sessionNumber\n                         to:(NSString *)newName {\n    NSString *renameCommand = [NSString stringWithFormat:@\"rename-session -t \\\"$%d\\\" \\\"%@\\\"\",\n                               sessionNumber,\n                               [newName stringByEscapingQuotes]];\n    [gateway_ sendCommand:renameCommand responseTarget:nil responseSelector:nil];\n}\n\n- (void)killSessionNumber:(int)sessionNumber {\n    NSString *killCommand = [NSString stringWithFormat:@\"kill-session -t \\\"$%d\\\"\", sessionNumber];\n    [gateway_ sendCommand:killCommand\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandOfferToDetachIfLaggyDuplicate | kTmuxGatewayCommandShouldTolerateErrors];\n    [self listSessions];\n}\n\n- (void)addSessionWithName:(NSString *)sessionName\n{\n    NSString *attachCommand = [NSString stringWithFormat:@\"new-session -s \\\"%@\\\"\",\n                               [sessionName stringByEscapingQuotes]];\n    [gateway_ sendCommand:attachCommand\n           responseTarget:nil\n         responseSelector:nil];\n    [self listSessions];\n}\n\n- (void)attachToSessionWithNumber:(int)sessionNumber {\n    NSString *attachCommand = [NSString stringWithFormat:@\"attach-session -t \\\"$%d\\\"\", sessionNumber];\n    [gateway_ sendCommand:attachCommand\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (void)listWindowsInSessionNumber:(int)sessionNumber\n                            target:(id)target\n                          selector:(SEL)selector\n                            object:(id)object {\n    if (detached_ || !object) {\n        // This can happen if you're not attached to a session.\n        return;\n    }\n    NSString *listWindowsCommand = [NSString stringWithFormat:@\"list-windows -F %@ -t \\\"$%d\\\"\",\n                                    [self listWindowsDetailedFormat], sessionNumber];\n    NSArray *userInfo = @[listWindowsCommand,\n                          object,\n                          target,\n                          NSStringFromSelector(selector) ];\n    if ([_listWindowsQueue containsObject:userInfo]) {\n        // Already have this queued up.\n        return;\n    }\n    // Wait a few seconds. We always get a windows-close notification when the last window in\n    // a window closes. To avoid spamming the command line with list-windows, we wait a bit to see\n    // if there is an exit notification coming down the pipe.\n    const CGFloat kListWindowsDelay = 1.5;\n    [NSTimer scheduledTimerWithTimeInterval:kListWindowsDelay\n                                     target:self\n                                   selector:@selector(listWindowsTimerFired:)\n                                   userInfo:userInfo\n                                    repeats:NO];\n}\n\n- (void)listWindowsTimerFired:(NSTimer *)timer {\n    if (detached_) {\n        return;\n    }\n    NSArray *array = [timer userInfo];\n    NSString *command = array[0];\n    id object = array[1];\n    id target = array[2];\n    NSString *selector = array[3];\n\n    [_listWindowsQueue removeObject:timer.userInfo];\n\n    [gateway_ sendCommand:command\n           responseTarget:self\n         responseSelector:@selector(didListWindows:userData:)\n           responseObject:@[object, selector, target]\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];  // Tolerates errors because the session may have been detached by the time we get the notification or the timer fires.\n}\n\n- (void)saveHiddenWindows\n{\n    NSString *hidden = [[hiddenWindows_ allObjects] componentsJoinedByString:@\",\"];\n    DLog(@\"Save hidden windows: %@\", hidden);\n    NSString *command = [NSString stringWithFormat:\n                         @\"set -t $%d @hidden \\\"%@\\\"\",\n                         sessionId_,\n                         [self encodedString:hidden\n                                      prefix:iTermTmuxControllerEncodingPrefixHidden]];\n    [gateway_ sendCommand:command\n           responseTarget:nil\n         responseSelector:nil\n           responseObject:nil\n                    flags:kTmuxGatewayCommandShouldTolerateErrors];\n}\n\n- (void)saveWindowOrigins\n{\n    if (haveOutstandingSaveWindowOrigins_) {\n        windowOriginsDirty_ = YES;\n        return;\n    }\n    windowOriginsDirty_ = NO;\n    if (pendingWindowOpens_.count) {\n        return;\n    }\n    [self saveAffinities];  // Make sure the equivalence classes are up to date.\n    NSMutableArray *maps = [NSMutableArray array];\n    for (NSSet *c in [affinities_ classes]) {\n        // temp will hold an array of tmux window IDs as strings, excluding\n        // placeholders and pty guids.\n        NSMutableArray *temp = [NSMutableArray array];\n        PTYTab *tab = nil;\n        for (NSString *wid in c) {\n            if (![wid hasPrefix:@\"pty-\"] && ![wid hasSuffix:@\"_ph\"]) {\n                if (!tab) {\n                    tab = [self window:[wid intValue]];\n                }\n                [temp addObject:wid];\n            }\n        }\n        NSString *windowIds = [temp componentsJoinedByString:@\",\"];\n        if (tab) {\n            NSWindowController<iTermWindowController> * term = [tab realParentWindow];\n            NSPoint origin = [[term window] frame].origin;\n            [maps addObject:[NSString stringWithFormat:@\"%@:%d,%d\", windowIds,\n                (int)origin.x, (int)origin.y]];\n        }\n    }\n    NSString *enc = [maps componentsJoinedByString:@\" \"];\n    DLog(@\"Save window origins to %@ called from %@\", enc, [NSThread callStackSymbols]);\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @origins \\\"%@\\\"\",\n                         sessionId_,\n                         [self encodedString:[enc stringByEscapingQuotes]\n                                      prefix:iTermTmuxControllerEncodingPrefixOrigins]];\n    if (!lastOrigins_ || ![command isEqualToString:lastOrigins_]) {\n        lastOrigins_ = [command copy];\n        haveOutstandingSaveWindowOrigins_ = YES;\n        [gateway_ sendCommand:command\n               responseTarget:self\n             responseSelector:@selector(saveWindowOriginsResponse:)];\n    }\n    [self getOriginsResponse:[self encodedString:[enc stringByEscapingQuotes]\n                                          prefix:iTermTmuxControllerEncodingPrefixOrigins]];\n}\n\n- (void)saveWindowOriginsResponse:(NSString *)response\n{\n    haveOutstandingSaveWindowOrigins_ = NO;\n    if (windowOriginsDirty_) {\n        [self saveWindowOrigins];\n    }\n}\n\n- (NSString *)windowOptionsForTerminal:(PseudoTerminal *)term {\n    if (term.anyFullScreen) {\n        return [NSString stringWithFormat:@\"%@=%@\",\n                kTmuxWindowOpenerWindowOptionStyle, kTmuxWindowOpenerWindowOptionStyleValueFullScreen];\n    } else {\n        return @\"\";\n    }\n}\n\n- (void)saveAffinities {\n    if (pendingWindowOpens_.count) {\n        return;\n    }\n    [self savePerWindowSettings];\n    [self savePerTabSettings];\n    iTermController *cont = [iTermController sharedInstance];\n    NSArray *terminals = [cont terminals];\n    NSMutableArray *affinities = [NSMutableArray array];\n    for (PseudoTerminal *term in terminals) {\n        NSMutableArray *siblings = [NSMutableArray array];\n        for (PTYTab *aTab in [term tabs]) {\n            if ([aTab isTmuxTab] && [aTab tmuxController] == self) {\n                NSString *n = [NSString stringWithFormat:@\"%d\", (int) [aTab tmuxWindow]];\n                [siblings addObject:n];\n            }\n        }\n        for (iTermTuple<NSNumber *, NSNumber *> *tuple in _buriedWindows[term.terminalGuid]) {\n            DLog(@\"add %@ as affinity sibling of %@\", tuple, term.terminalGuid);\n            [siblings addObject:[tuple.firstObject stringValue]];\n        }\n        if ([term terminalGuid]) {\n            [siblings addObject:[term terminalGuid]];\n        }\n        if (siblings.count > 0) {\n            NSString *value = [NSString stringWithFormat:@\"%@;%@\",\n                               [siblings componentsJoinedByString:@\",\"],\n                               [self windowOptionsForTerminal:term]];\n            [affinities addObject:value];\n        }\n    }\n    // Update affinities if any have changed.\n    NSString *arg = [affinities componentsJoinedByString:@\" \"];\n    DLog(@\"Save affinities: %@\", arg);\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @affinities \\\"%@\\\"\",\n                         sessionId_, [self encodedString:[arg stringByEscapingQuotes]\n                                                  prefix:iTermTmuxControllerEncodingPrefixAffinities]];\n    if ([command isEqualToString:lastSaveAffinityCommand_]) {\n        return;\n    }\n    [self setAffinitiesFromString:arg];\n    lastSaveAffinityCommand_ = command;\n    [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n\n    [self saveBuriedIndexes];\n}\n\n- (void)saveBuriedIndexes {\n    NSString *arg = [[_buriedWindows.allKeys mapWithBlock:^id(NSString *terminalGUID) {\n        NSString *rhs = [[_buriedWindows[terminalGUID] mapWithBlock:^id(iTermTuple<NSNumber *,NSNumber *> *tuple) {\n            return [NSString stringWithFormat:@\"%@=%@\", tuple.firstObject, tuple.secondObject];\n        }] componentsJoinedByString:@\",\"];\n        return [NSString stringWithFormat:@\"%@:%@\", terminalGUID, rhs];\n    }] componentsJoinedByString:@\" \"];\n    DLog(@\"save buried indexes: %@\", arg);\n\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @buried_indexes \\\"%@\\\"\",\n                         sessionId_, [self encodedString:[arg stringByEscapingQuotes]\n                                                  prefix:iTermTmuxControllerEncodingPrefixBuriedIndexes]];\n    if ([command isEqualToString:_lastSaveBuriedIndexesCommand]) {\n        return;\n    }\n    _lastSaveBuriedIndexesCommand = command;\n    [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n}\n\n- (void)savePerTabSettings {\n    NSMutableArray<NSString *> *settings = [NSMutableArray array];\n    iTermController *cont = [iTermController sharedInstance];\n    NSArray *terminals = [cont terminals];\n    for (PseudoTerminal *term in terminals) {\n        for (PTYTab *tab in term.tabs) {\n            if (!tab.isTmuxTab) {\n                continue;\n            }\n            NSString *setting = [tab tmuxPerTabSetting];\n            if (setting) {\n                [settings addObject:[NSString stringWithFormat:@\"%d:%@\", tab.tmuxWindow, setting]];\n            }\n        }\n    }\n    NSString *arg = [settings componentsJoinedByString:@\";\"];\n    DLog(@\"Save per-tab settings: %@\", arg);\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @per_tab_settings \\\"%@\\\"\",\n                         sessionId_,\n                         [self encodedString:arg prefix:iTermTmuxControllerEncodingPrefixPerTabSettings]];\n    if ([command isEqualToString:_lastSavePerTabSettingsCommand]) {\n        return;\n    }\n    _lastSavePerTabSettingsCommand = command;\n    [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n}\n\n- (void)getPerTabSettingsResponse:(NSString *)result {\n    [self setPerTabSettingsFromString:[self decodedString:result optionalPrefix:iTermTmuxControllerEncodingPrefixPerTabSettings]];\n}\n\n- (void)savePerWindowSettings {\n    NSMutableArray<NSString *> *settings = [NSMutableArray array];\n    iTermController *cont = [iTermController sharedInstance];\n    NSArray *terminals = [cont terminals];\n    for (PseudoTerminal *term in terminals) {\n        NSString *setting = [term tmuxPerWindowSetting];\n        if (setting) {\n            [settings addObject:[NSString stringWithFormat:@\"%@:%@\", term.terminalGuid, setting]];\n        }\n    }\n    NSString *arg = [settings componentsJoinedByString:@\";\"];\n    DLog(@\"Save per-window settings: %@\", arg);\n    NSString *command = [NSString stringWithFormat:@\"set -t $%d @per_window_settings \\\"%@\\\"\",\n                         sessionId_,\n                         [self encodedString:arg prefix:iTermTmuxControllerEncodingPrefixPerWindowSettings]];\n    if ([command isEqualToString:_lastSavePerWindowSettingsCommand]) {\n        return;\n    }\n    _lastSavePerWindowSettingsCommand = command;\n    [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n}\n\n- (void)getPerWindowSettingsResponse:(NSString *)result {\n    [self setPerWindowSettingsFromString:[self decodedString:result optionalPrefix:iTermTmuxControllerEncodingPrefixPerWindowSettings]];\n}\n\n- (PseudoTerminal *)terminalWithGuid:(NSString *)guid\n{\n    for (PseudoTerminal *term in [[iTermController sharedInstance] terminals]) {\n        if ([[term terminalGuid] isEqualToString:guid]) {\n            return term;\n        }\n    }\n    return nil;\n}\n\n- (PseudoTerminal *)windowWithAffinityForWindowId:(int)wid {\n    for (NSString *n in [self savedAffinitiesForWindow:[NSString stringWithInt:wid]]) {\n        if ([n hasPrefix:@\"pty-\"]) {\n            PseudoTerminal *term = [self terminalWithGuid:n];\n            if (term) {\n                return term;\n            }\n        } else if ([n hasPrefix:@\"-\"]) {\n            // Attach to window without a tmux tab; the window number is\n            // -(n+1). It may not exist, which means to open a new window.\n            int value = -[n intValue];\n            value -= 1;  // Correct for -1 based index.\n            return [[iTermController sharedInstance] terminalWithNumber:value];\n        } else if (![n hasSuffix:@\"_ph\"]) {\n            PTYTab *tab = [self window:[n intValue]];\n            if (tab) {\n                return [[iTermController sharedInstance] terminalWithTab:tab];\n            }\n        }\n    }\n    return nil;\n}\n\n- (void)changeWindow:(int)window tabTo:(PTYTab *)tab {\n    _windowStates[@(window)].tab = tab;\n}\n\n- (void)listSessions\n{\n    [listSessionsTimer_ invalidate];\n    listSessionsTimer_ = nil;\n    NSString *listSessionsCommand = @\"list-sessions -F \\\"#{session_id} #{session_name}\\\"\";\n    [gateway_ sendCommand:listSessionsCommand\n           responseTarget:self\n         responseSelector:@selector(listSessionsResponse:)];\n}\n\n- (NSString *)listWindowsDetailedFormat {\n    NSArray<NSString *> *parts = @[\n        @\"#{session_name}\",\n        @\"#{window_id}\",\n        @\"#{window_name}\",\n        @\"#{window_width}\",\n        @\"#{window_height}\",\n        @\"#{window_layout}\",\n        @\"#{window_flags}\",\n        @\"#{?window_active,1,0}\"\n    ];\n    if ([self versionAtLeastDecimalNumberWithString:@\"2.2\"]) {\n        parts = [parts arrayByAddingObject:@\"#{window_visible_layout}\"];\n    }\n    return [NSString stringWithFormat:@\"\\\"%@\\\"\", [parts componentsJoinedByString:@\"\\t\"]];\n}\n\n- (NSString *)commandToListWindows {\n    if ([self versionAtLeastDecimalNumberWithString:@\"2.2\"]) {\n        return @\"list-windows -F \\\"#{window_id} #{window_layout} #{window_flags} #{window_visible_layout}\\\"\";\n    } else {\n        return @\"list-windows -F \\\"#{window_id} #{window_layout} #{window_flags}\\\"\";\n    }\n}\n\n- (NSString *)commandToListWindowsForSession:(int)session {\n    return [[self commandToListWindows] stringByAppendingFormat:@\" -t \\\"$%d\\\"\", sessionId_];\n}\n\n- (void)swapPane:(int)pane1 withPane:(int)pane2 {\n    NSString *swapPaneCommand = [NSString stringWithFormat:@\"swap-pane -s \\\"%%%d\\\" -t \\\"%%%d\\\"\",\n                                 pane1, pane2];\n\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:swapPaneCommand\n                                           responseTarget:nil\n                                         responseSelector:NULL\n                                           responseObject:nil\n                                                    flags:0],\n                           [gateway_ dictionaryForCommand:[self commandToListWindows]\n                                           responseTarget:self\n                                         responseSelector:@selector(parseListWindowsResponseAndUpdateLayouts:)\n                                           responseObject:nil\n                                                    flags:0] ];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)toggleZoomForPane:(int)pane {\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:[NSString stringWithFormat:@\"resize-pane -Z -t \\\"%%%d\\\"\", pane]\n                                           responseTarget:nil\n                                         responseSelector:NULL\n                                           responseObject:nil\n                                                    flags:0],\n                           [gateway_ dictionaryForCommand:[self commandToListWindows]\n                                           responseTarget:self\n                                         responseSelector:@selector(parseListWindowsResponseAndUpdateLayouts:)\n                                           responseObject:nil\n                                                    flags:0] ];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)setTmuxFontTable:(iTermFontTable *)fontTable\n                hSpacing:(CGFloat)hs\n                vSpacing:(CGFloat)vs\n                  window:(int)window {\n    NSDictionary *dict = iTermTmuxControllerMakeFontOverrides(fontTable, hs, vs);\n    if (_variableWindowSize) {\n        _windowStates[@(window)].fontOverrides = dict;\n        return;\n    }\n    _sharedFontOverrides = dict;\n}\n\n- (void)setLayoutInWindow:(int)window toLayout:(NSString *)layout {\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:[NSString stringWithFormat:@\"select-layout -t @%@ %@\",\n                                                           @(window), layout]\n                                           responseTarget:self\n                                         responseSelector:@selector(didSetLayout:)\n                                           responseObject:nil\n                                                    flags:0],\n                           [gateway_ dictionaryForCommand:[self commandToListWindowsForSession:sessionId_]\n                                           responseTarget:self\n                                         responseSelector:@selector(didListWindowsSubsequentToSettingLayout:)\n                                           responseObject:nil\n                                                    flags:0] ];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)setLayoutInWindowPane:(int)windowPane toLayoutNamed:(NSString *)name {\n    NSArray *commands = @[ [gateway_ dictionaryForCommand:[NSString stringWithFormat:@\"select-layout -t %%%@ %@\", @(windowPane), name]\n                                           responseTarget:self\n                                         responseSelector:@selector(didSetLayout:)\n                                           responseObject:nil\n                                                    flags:0],\n                           [gateway_ dictionaryForCommand:[self commandToListWindowsForSession:sessionId_]\n                                           responseTarget:self\n                                         responseSelector:@selector(didListWindowsSubsequentToSettingLayout:)\n                                           responseObject:nil\n                                                    flags:0] ];\n    [gateway_ sendCommandList:commands];\n}\n\n- (void)didSetLayout:(NSString *)response {\n}\n\n- (void)didListWindowsSubsequentToSettingLayout:(NSString *)response {\n    [self parseListWindowsResponseAndUpdateLayouts:response];\n}\n\n- (NSArray<PTYSession<iTermTmuxControllerSession> *> *)clientSessions {\n    return windowPanes_.allValues;\n}\n\n- (NSArray<NSNumber *> *)windowPaneIDs {\n    return windowPanes_.allKeys;\n}\n\n- (void)activeWindowPaneDidChangeInWindow:(int)windowID toWindowPane:(int)paneID {\n    PTYSession *session = [self sessionForWindowPane:paneID];\n    if (session) {\n        [self suppressActivityChanges:^{\n            [session makeActive];\n        }];\n        return;\n    }\n    // This must be a newly created session.\n    _paneToActivateWhenCreated = paneID;\n}\n\n- (BOOL)shouldMakeWindowKeyOnActiveWindowChange {\n    PseudoTerminal *term = [[iTermController sharedInstance] currentTerminal];\n    if (!term) {\n        return NO;\n    }\n    if (!term.window.isVisible) {\n        return NO;\n    }\n    return term.currentSession.isTmuxClient && term.currentSession.tmuxController == self;\n}\n\n- (void)activeWindowDidChangeTo:(int)windowID {\n    [self suppressActivityChanges:^{\n        const BOOL shouldMakeKeyAndOrderFront = [self shouldMakeWindowKeyOnActiveWindowChange];\n        PTYTab *tab = [self window:windowID];\n        [tab makeActive];\n        if (shouldMakeKeyAndOrderFront) {\n            [tab.realParentWindow.window makeKeyAndOrderFront:nil];\n        }\n    }];\n}\n\n- (void)suppressActivityChanges:(void (^ NS_NOESCAPE)(void))block {\n    _suppressActivityChanges++;\n    block();\n    _suppressActivityChanges--;\n}\n\n#pragma mark - Private\n\n- (void)getOriginsResponse:(NSString *)encodedResult {\n    NSString *result = [self decodedString:encodedResult\n                            optionalPrefix:iTermTmuxControllerEncodingPrefixOrigins];\n    [origins_ removeAllObjects];\n    if ([result length] > 0) {\n        NSArray *windows = [result componentsSeparatedByString:@\" \"];\n        for (NSString *wstr in windows) {\n            NSArray *tuple = [wstr componentsSeparatedByString:@\":\"];\n            if (tuple.count != 2) {\n                continue;\n            }\n            NSString *windowsStr = [tuple objectAtIndex:0];\n            NSString *coords = [tuple objectAtIndex:1];\n            NSArray *windowIds = [windowsStr componentsSeparatedByString:@\",\"];\n            NSArray *xy = [coords componentsSeparatedByString:@\",\"];\n            if (xy.count != 2) {\n                continue;\n            }\n            NSPoint origin = NSMakePoint([[xy objectAtIndex:0] intValue],\n                                         [[xy objectAtIndex:1] intValue]);\n            for (NSString *wid in windowIds) {\n                [origins_ setObject:[NSValue valueWithPoint:origin]\n                             forKey:[NSNumber numberWithInt:[wid intValue]]];\n            }\n        }\n    }\n}\n\n- (NSString *)shortStringForHotkeyDictionary:(NSDictionary *)dict paneID:(int)wp {\n    return [NSString stringWithFormat:@\"%d=%@\", wp, [iTermShortcut shortStringForDictionary:dict]];\n}\n\n- (NSString *)hotkeysString {\n    NSMutableArray *parts = [NSMutableArray array];\n    [_hotkeys enumerateKeysAndObjectsUsingBlock:^(NSNumber *  _Nonnull key, NSDictionary *_Nonnull obj, BOOL * _Nonnull stop) {\n        if ([_paneIDs containsObject:key]) {\n            [parts addObject:[self shortStringForHotkeyDictionary:obj paneID:key.intValue]];\n        }\n    }];\n\n    return [parts componentsJoinedByString:@\" \"];\n}\n\n- (NSString *)tabColorsString {\n    NSMutableArray *parts = [NSMutableArray array];\n    [_tabColors enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSString * _Nonnull obj, BOOL * _Nonnull stop) {\n        if ([_paneIDs containsObject:key]) {\n            [parts addObject:[NSString stringWithFormat:@\"%@=%@\", key, obj]];\n        }\n    }];\n\n    return [parts componentsJoinedByString:@\" \"];\n}\n\n- (void)getHotkeysResponse:(NSString *)encodedResult {\n    NSString *result = [self decodedString:encodedResult optionalPrefix:iTermTmuxControllerEncodingPrefixHotkeys];\n    [_hotkeys removeAllObjects];\n    if (result.length > 0) {\n        [_hotkeys removeAllObjects];\n        NSArray *parts = [result componentsSeparatedByString:@\" \"];\n        for (NSString *part in parts) {\n            NSInteger equals = [part rangeOfString:@\"=\"].location;\n            if (equals != NSNotFound && equals + 1 < part.length) {\n                NSString *wp = [part substringToIndex:equals];\n                NSString *shortString = [part substringFromIndex:equals + 1];\n                NSDictionary *dict = [iTermShortcut dictionaryForShortString:shortString];\n                if (dict) {\n                    _hotkeys[@(wp.intValue)] = dict;\n                }\n            }\n        }\n    }\n}\n\n- (void)getTabColorsResponse:(NSString *)encodedResult {\n    NSString *result = [self decodedString:encodedResult\n                            optionalPrefix:iTermTmuxControllerEncodingPrefixTabColors];\n    [_tabColors removeAllObjects];\n    if (result.length > 0) {\n        [_tabColors removeAllObjects];\n        NSArray *parts = [result componentsSeparatedByString:@\" \"];\n        for (NSString *part in parts) {\n            NSInteger equals = [part rangeOfString:@\"=\"].location;\n            if (equals != NSNotFound && equals + 1 < part.length) {\n                NSString *wp = [part substringToIndex:equals];\n                NSString *colorString = [part substringFromIndex:equals + 1];\n                if (colorString && wp.length) {\n                    _tabColors[@(wp.intValue)] = colorString;\n                }\n            }\n        }\n    }\n}\n\n- (int)windowIdFromString:(NSString *)s\n{\n    if (s.length < 2 || [s characterAtIndex:0] != '@') {\n        return -1;\n    }\n    return [[s substringFromIndex:1] intValue];\n}\n\n- (void)didListWindows:(NSString *)response userData:(NSArray *)userData\n{\n    if (!response) {\n        // In case of error.\n        response = @\"\";\n    }\n    TSVDocument *doc = [response tsvDocumentWithFields:[self listWindowFields]\n                                      workAroundTabBug:_shouldWorkAroundTabBug];\n    id object = userData[0];\n    SEL selector = NSSelectorFromString(userData[1]);\n    id target = userData[2];\n    [target it_performNonObjectReturningSelector:selector withObject:doc withObject:object];\n}\n\n- (void)getHiddenWindowsResponse:(NSString *)encodedResponse {\n    NSString *response = [self decodedString:encodedResponse\n                              optionalPrefix:iTermTmuxControllerEncodingPrefixHidden];\n    [hiddenWindows_ removeAllObjects];\n    if ([response length] > 0) {\n        NSArray *windowIds = [response componentsSeparatedByString:@\",\"];\n        DLog(@\"getHiddenWindowsResponse: Add these window IDs to hidden: %@\", windowIds);\n        for (NSString *wid in windowIds) {\n            [hiddenWindows_ addObject:[NSNumber numberWithInt:[wid intValue]]];\n        }\n    }\n    DLog(@\"Got hidden windows from server. they are: %@\", hiddenWindows_);\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerDidChangeHiddenWindows object:self];\n}\n\n- (void)getAffinitiesResponse:(NSString *)result {\n    [self setAffinitiesFromString:[self decodedString:result optionalPrefix:iTermTmuxControllerEncodingPrefixAffinities]];\n}\n\n- (void)getBuriedIndexesResponse:(NSString *)result {\n    if (!result) {\n        return;\n    }\n    NSString *decoded = [self decodedString:result optionalPrefix:iTermTmuxControllerEncodingPrefixBuriedIndexes];\n    if (!decoded.length) {\n        return;\n    }\n    NSArray<NSString *> *parts = [decoded componentsSeparatedByString:@\" \"];\n    [_buriedWindows removeAllObjects];\n    // guid:wid=index,wid=index,wid=index guid:wid=index,...\n    [parts enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        NSArray<NSString *> *subparts = [obj componentsSeparatedByString:@\":\"];\n        if (subparts.count < 2) {\n            return;\n        }\n        NSString *terminalGUID = subparts[0];\n        NSString *encodedPairs = subparts[1];\n        NSArray<NSString *> *pairStrings = [encodedPairs componentsSeparatedByString:@\",\"];\n        NSArray<iTermTuple<NSNumber *, NSNumber *> *> *tuples = [pairStrings mapWithBlock:^id(NSString *string) {\n            iTermTuple<NSString *, NSString *> *sstuple = [string keyValuePair];\n            if (!sstuple) {\n                return nil;\n            }\n            if (!sstuple.firstObject.isNumeric || !sstuple.secondObject.isNumeric) {\n                return nil;\n            }\n            return [iTermTuple tupleWithObject:@([sstuple.firstObject intValue])\n                                     andObject:@([sstuple.secondObject intValue])];\n        }];\n        _buriedWindows[terminalGUID] = [tuples mutableCopy];\n    }];\n}\n\n- (NSArray *)componentsOfAffinities:(NSString *)affinities {\n    NSRange semicolonRange = [affinities rangeOfString:@\";\"];\n    if (semicolonRange.location != NSNotFound) {\n        NSString *siblings = [affinities substringToIndex:semicolonRange.location];\n        NSString *windowOptions = [affinities substringFromIndex:NSMaxRange(semicolonRange)];\n        return @[ siblings, windowOptions ];\n    } else {\n        return @[ affinities, @\"\" ];\n    }\n}\n\n// Takes key1=value1,key2=value2 and returns @{ key1: value1, key2: value2 }\n- (NSDictionary *)windowOptionsFromString:(NSString *)kvpString {\n    NSMutableDictionary *flags = [NSMutableDictionary dictionary];\n    NSArray *kvps = [kvpString componentsSeparatedByString:@\",\"];\n    for (NSString *flagString in kvps) {\n        NSRange equalsRange = [flagString rangeOfString:@\"=\"];\n        if (equalsRange.location != NSNotFound) {\n            NSString *key = [flagString substringToIndex:equalsRange.location];\n            NSString *value = [flagString substringFromIndex:NSMaxRange(equalsRange)];\n            flags[key] = value;\n        }\n    }\n    return flags;\n}\n\n- (void)setPerTabSettingsFromString:(NSString *)result {\n    DLog(@\"Set per-tab settings from string: %@\", result);\n\n    _perTabSettings = nil;\n    NSMutableDictionary<NSString *, NSString *> *settings = [NSMutableDictionary dictionary];\n    NSArray<NSString *> *parts = [result componentsSeparatedByString:@\";\"];\n    for (NSString *part in parts) {\n        iTermTuple<NSString *, NSString *> *kvp = [part it_stringBySplittingOnFirstSubstring:@\":\"];\n        if (!kvp) {\n            DLog(@\"Bad part %@\", part);\n            continue;\n        }\n        settings[kvp.firstObject] = kvp.secondObject;\n    }\n    _perTabSettings = [settings copy];\n}\n\n- (NSString *)perTabSettingsForTabWithWindowID:(int)wid {\n    NSString *widStr = [@(wid) stringValue];\n    return _perTabSettings[widStr];\n}\n\n- (void)setPerWindowSettingsFromString:(NSString *)result {\n    DLog(@\"Set per-window settings from string: %@\", result);\n\n    _perWindowSettings = nil;\n    NSMutableDictionary<NSString *, NSString *> *settings = [NSMutableDictionary dictionary];\n    NSArray<NSString *> *parts = [result componentsSeparatedByString:@\";\"];\n    for (NSString *part in parts) {\n        iTermTuple<NSString *, NSString *> *kvp = [part it_stringBySplittingOnFirstSubstring:@\":\"];\n        if (!kvp) {\n            DLog(@\"Bad part %@\", part);\n            continue;\n        }\n        settings[kvp.firstObject] = kvp.secondObject;\n    }\n    _perWindowSettings = [settings copy];\n}\n\n- (NSString *)perWindowSettingsForWindowWithGUID:(NSString *)terminalGUID {\n    return _perWindowSettings[terminalGUID];\n}\n\n- (void)setAffinitiesFromString:(NSString *)result {\n    // Replace the existing equivalence classes with those defined by the\n    // affinity response.\n    // For example \"1,2,3 4,5,6\" has two equivalence classes.\n    // 1=2=3 and 4=5=6.\n    DLog(@\"Set affinities from string: %@\", result);\n    NSArray *affinities = [result componentsSeparatedByString:@\" \"];\n    affinities_ = [[EquivalenceClassSet alloc] init];\n\n    if (![result length]) {\n        return;\n    }\n\n    for (NSString *theString in affinities) {\n        NSArray *components = [self componentsOfAffinities:theString];\n        NSString *affset = components[0];\n        NSString *windowOptionsString = components[1];\n\n        NSArray<NSString *> *siblings = [affset componentsSeparatedByString:@\",\"];\n        DLog(@\"Siblings are: %@\", [siblings componentsJoinedByString:@\" \"]);\n        NSString *exemplar = [siblings lastObject];\n        if (siblings.count == 1) {\n            // This is a wee hack. If a tmux Window is in a native window with one tab\n            // then create an equivalence class containing only (wid, wid+\"_ph\"). ph=placeholder\n            // The equivalence class's existence signals not to apply the default mode for\n            // unrecognized windows.\n            exemplar = [exemplar stringByAppendingString:@\"_ph\"];\n            DLog(@\"Use placeholder exemplar\");\n        } else {\n            DLog(@\"Use arbitrary sibling as exemplar\");\n        }\n        NSDictionary *flags = [self windowOptionsFromString:windowOptionsString];\n        for (NSString *widString in siblings) {\n            if (![widString isEqualToString:exemplar]) {\n                DLog(@\"Set wid %@ equal to examplar %@\", widString, exemplar);\n                [affinities_ setValue:widString\n                         equalToValue:exemplar];\n                _windowOpenerOptions[widString] = flags;\n            }\n            if (widString.isNumeric && [hiddenWindows_ containsObject:@(widString.intValue)]) {\n                NSString *terminalGUID = [[siblings filteredArrayUsingBlock:^BOOL(NSString *candidate) {\n                    return !candidate.isNumeric && ![candidate hasSuffix:@\"_ph\"];\n                }] firstObject];\n                if (terminalGUID) {\n                    [self setWindowID:widString.intValue buriedFromTerminalGUID:terminalGUID tabIndex:-1];\n                }\n            }\n        }\n    }\n}\n\n- (void)listSessionsResponse:(NSString *)result\n{\n    DLog(@\"%@ got list-session response:\\n%@\", self, result);\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerSessionsWillChange\n                                                        object:nil];\n    self.sessionObjects = [[result componentsSeparatedByRegex:@\"\\n\"] mapWithBlock:^iTermTmuxSessionObject *(NSString *line) {\n        const NSInteger space = [line rangeOfString:@\" \"].location;\n        if (space == NSNotFound) {\n            return nil;\n        }\n        NSString *sessionID = [line substringToIndex:space];\n        NSString *sessionName = [line substringFromIndex:space + 1];\n        if (![sessionID hasPrefix:@\"$\"]) {\n            return nil;\n        }\n        NSScanner *scanner = [NSScanner scannerWithString:[sessionID substringFromIndex:1]];\n        int sessionNumber = -1;\n        if (![scanner scanInt:&sessionNumber] || sessionNumber < 0) {\n            return nil;\n        }\n        iTermTmuxSessionObject *obj = [[iTermTmuxSessionObject alloc] init];\n        obj.name = sessionName;\n        obj.number = sessionNumber;\n        return obj;\n    }];\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerSessionsDidChange\n                                                        object:self];\n}\n\n- (void)listedWindowsToOpenOne:(NSString *)response\n      forWindowIdAndAffinities:(NSArray *)values {\n    if (response == nil) {\n        DLog(@\"Listing windows failed. Maybe the window died before we could get to it?\");\n        return;\n    }\n    NSNumber *windowId = values[0];\n    NSSet *affinities = values[1];\n    Profile *profile = values[2];\n    NSNumber *tabIndex = values[3];\n    if (tabIndex.intValue < 0) {\n        tabIndex = nil;\n    }\n    TSVDocument *doc = [response tsvDocumentWithFields:[self listWindowFields]\n                                      workAroundTabBug:_shouldWorkAroundTabBug];\n    if (!doc) {\n        [gateway_ abortWithErrorMessage:[NSString stringWithFormat:@\"Bad response for list windows request: %@\",\n                                         response]];\n        return;\n    }\n    for (NSArray *record in doc.records) {\n        NSString *recordWindowId = [doc valueInRecord:record forField:@\"window_id\"];\n        if ([self windowIdFromString:recordWindowId] == [windowId intValue]) {\n            [self openWindowWithIndex:[self windowIdFromString:[doc valueInRecord:record forField:@\"window_id\"]]\n                                 name:[[doc valueInRecord:record forField:@\"window_name\"] it_unescapedTmuxWindowName]\n                                 size:NSMakeSize([[doc valueInRecord:record forField:@\"window_width\"] intValue],\n                                                 [[doc valueInRecord:record forField:@\"window_height\"] intValue])\n                               layout:[doc valueInRecord:record forField:@\"window_layout\"]\n                        visibleLayout:[doc valueInRecord:record forField:@\"window_visible_layout\"]\n                           affinities:affinities\n                          windowFlags:[doc valueInRecord:record forField:@\"window_flags\"]\n                              profile:profile\n                              initial:NO\n                             tabIndex:tabIndex];\n        }\n    }\n}\n\n// When an iTerm2 window is resized, a control -s client-size w,h\n// command is sent. It responds with new layouts for all the windows in the\n// client's session. Update the layouts for the affected tabs.\n- (void)listWindowsResponse:(NSString *)response\n{\n    --numOutstandingWindowResizes_;\n    if (numOutstandingWindowResizes_ > 0) {\n        return;\n    }\n\n    [self parseListWindowsResponseAndUpdateLayouts:response];\n}\n\n- (void)parseListWindowsResponseAndUpdateLayouts:(NSString *)response {\n    NSArray *layoutStrings = [response componentsSeparatedByString:@\"\\n\"];\n    BOOL windowMightNeedAdjustment = NO;\n    NSMutableArray<PTYTab *> *tabs = [NSMutableArray array];\n    DLog(@\"Begin handling list-windows response\\n%@\", response);\n    for (NSString *layoutString in layoutStrings) {\n        // Capture groups are:\n        // <entire match> <window number> [<layout> [<visible layout]]\n        NSArray *components = [layoutString captureComponentsMatchedByRegex:@\"^@([0-9]+) ([^ ]+)(?: ([^ ]+)(?: ([^ ]+))?)?\"];\n        if ([components count] < 3) {\n            DLog(@\"Bogus layout string: \\\"%@\\\"\", layoutString);\n        } else {\n            int window = [[components objectAtIndex:1] intValue];\n            NSString *layout = [components objectAtIndex:2];\n            NSString *visibleLayout = components.count > 4 ? components[4] : nil;\n            PTYTab *tab = [self window:window];\n            if (tab) {\n                [tabs addObject:tab];\n                NSNumber *zoomed = components.count > 3 ? @([components[3] containsString:@\"Z\"]) : nil;\n                const BOOL adjust =\n                [[gateway_ delegate] tmuxUpdateLayoutForWindow:window\n                                                        layout:layout\n                                                 visibleLayout:visibleLayout\n                                                        zoomed:zoomed\n                                                          only:NO];\n                if (adjust) {\n                    windowMightNeedAdjustment = YES;\n                }\n            }\n        }\n    }\n    DLog(@\"End handling list-windows response\");\n    if (windowMightNeedAdjustment) {\n        [self adjustWindowSizeIfNeededForTabs:tabs];\n    }\n}\n\n- (void)retainWindow:(int)window withTab:(PTYTab *)tab {\n    assert(tab);\n    NSNumber *k = [NSNumber numberWithInt:window];\n    iTermTmuxWindowState *state = _windowStates[k];\n    BOOL notify = NO;\n    if (state) {\n        state.refcount = state.refcount + 1;\n    } else {\n        state = [[iTermTmuxWindowState alloc] init];\n        state.tab = tab;\n        state.refcount = 1;\n        state.profile = tab.sessions.firstObject.profile;\n        _windowStates[k] = state;\n        notify = YES;\n    }\n    if (notify) {\n        [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerWindowDidOpen\n                                                            object:@[ k, self ]];\n    }\n}\n\n- (void)releaseWindow:(int)window {\n    NSNumber *k = [NSNumber numberWithInt:window];\n    iTermTmuxWindowState *state = _windowStates[k];\n    state.refcount = state.refcount - 1;\n    if (!state.refcount) {\n        [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerWindowDidClose\n                                                            object:@[ k, self ]];\n        [_windowStates removeObjectForKey:k];\n    }\n}\n\n// Called only for iTerm2-initiated new windows/tabs.\n- (void)newWindowWithAffinityCreated:(NSString *)responseStr\n         affinityWindowAndCompletion:(iTermTriple *)tuple {  // Value passed in to -newWindowWithAffinity:, may be nil\n    if ([responseStr hasPrefix:@\"@\"]) {\n        int intWindowId = [[responseStr substringFromIndex:1] intValue];\n        NSString  *windowId = [NSString stringWithInt:intWindowId];\n        void (^completion)(int) = tuple.secondObject;\n        _pendingWindows[@(intWindowId)] = [iTermTmuxPendingWindow withIndex:tuple.thirdObject\n                                                                 completion:completion];\n        NSString *affinityWindow = tuple.firstObject;\n        if (affinityWindow) {\n            [affinities_ setValue:windowId\n                     equalToValue:affinityWindow];\n        } else {\n            [affinities_ removeValue:windowId];\n        }\n    } else {\n        DLog(@\"Response to new-window doesn't look like a window id: \\\"%@\\\"\", responseStr);\n    }\n}\n\n- (void)closeAllPanes {\n    // Close all sessions. Iterate over a copy of windowPanes_ because the loop\n    // body modifies it by closing sessions.\n    for (NSString *key in [windowPanes_ copy]) {\n        PTYSession<iTermTmuxControllerSession> *session = [windowPanes_ objectForKey:key];\n        [session tmuxDidDisconnect];\n    }\n\n    // Clean up all state to avoid trying to reuse it.\n    [windowPanes_ removeAllObjects];\n}\n\n- (void)windowDidOpen:(TmuxWindowOpener *)windowOpener {\n    NSNumber *windowIndex = @(windowOpener.windowIndex);\n    DLog(@\"TmuxController windowDidOpen for index %@ with error count %@\", windowIndex, @(windowOpener.errorCount));\n    [pendingWindowOpens_ removeObject:windowIndex];\n    if (windowOpener.errorCount != 0) {\n        [affinities_ removeValue:[@(windowOpener.windowIndex) stringValue]];\n        [[iTermNotificationController sharedInstance] notify:@\"Error opening tmux tab\"\n                                             withDescription:@\"A tmux pane terminated immediately after creation\"];\n        return;\n    }\n    [[NSNotificationCenter defaultCenter] postNotificationName:kTmuxControllerWindowDidOpen\n                                                        object:nil];\n    PTYTab *tab = [self window:[windowIndex intValue]];\n    NSWindowController<iTermWindowController> * term = [tab realParentWindow];\n    NSValue *p = [origins_ objectForKey:windowIndex];\n    if (term && ![term anyFullScreen] && term.tabs.count == 1) {\n        if (p) {\n            [[term window] setFrameOrigin:[p pointValue]];\n        } else if (!NSEqualRects(NSZeroRect, _initialWindowHint)) {\n            [[term window] setFrameOrigin:_initialWindowHint.origin];\n        }\n    }\n    _initialWindowHint = NSZeroRect;\n    [self saveAffinities];\n    if (pendingWindowOpens_.count == 0) {\n        [self sendInitialWindowsOpenedNotificationIfNeeded];\n    }\n}\n\n- (void)sendInitialWindowsOpenedNotificationIfNeeded {\n    if (!_haveOpenedInitialWindows) {\n        [gateway_.delegate tmuxDidOpenInitialWindows];\n        _haveOpenedInitialWindows = YES;\n    }\n}\n\n- (void)setPartialWindowIdOrder:(NSArray *)partialOrder {\n    [gateway_ sendCommand:@\"list-windows -F \\\"#{window_id}\\\"\"\n           responseTarget:self\n         responseSelector:@selector(responseForListWindows:toSetPartialOrder:)\n           responseObject:partialOrder\n                    flags:0];\n}\n\n- (void)responseForListWindows:(NSString *)response toSetPartialOrder:(NSArray *)partialOrder {\n    NSArray *ids = [response componentsSeparatedByString:@\"\\n\"];\n    NSMutableArray *currentOrder = [NSMutableArray array];\n    for (NSString *windowId in ids) {\n        if ([windowId hasPrefix:@\"@\"]) {\n            int i = [[windowId substringFromIndex:1] intValue];\n            NSNumber *n = @(i);\n            if ([partialOrder containsObject:n]) {\n                [currentOrder addObject:n];\n            }\n        }\n    }\n\n    NSMutableArray *desiredOrder = [NSMutableArray array];\n    for (NSNumber *n in partialOrder) {\n        if ([currentOrder containsObject:n]) {\n            [desiredOrder addObject:n];\n        }\n    }\n\n    // We have two lists, desiredOrder and currentOrder, that contain the same objects but\n    // in (possibly) a different order. For each out-of-place value, swap it with a later value,\n    // placing the later value in its correct location.\n    NSMutableArray *commands = [NSMutableArray array];\n    for (int i = 0; i < currentOrder.count; i++) {\n        if ([currentOrder[i] intValue] != [desiredOrder[i] intValue]) {\n            NSInteger swapIndex = [currentOrder indexOfObject:desiredOrder[i]];\n            assert(swapIndex != NSNotFound);\n\n            NSString *command = [NSString stringWithFormat:@\"swap-window -s @%@ -t @%@\",\n                                    currentOrder[i], currentOrder[swapIndex]];\n            NSDictionary *dict = [gateway_ dictionaryForCommand:command\n                                                 responseTarget:self\n                                               responseSelector:@selector(didSwapWindows:)\n                                                 responseObject:nil\n                                                          flags:0];\n            [commands addObject:dict];\n            NSNumber *temp = currentOrder[i];\n            currentOrder[i] = currentOrder[swapIndex];\n            currentOrder[swapIndex] = temp;\n        }\n    }\n\n    [gateway_ sendCommandList:commands];\n    if (_currentWindowID >= 0) {\n        [self setCurrentWindow:_currentWindowID];\n    }\n}\n\n- (void)didSwapWindows:(NSString *)response {\n}\n\n- (void)setCurrentWindow:(int)windowId {\n    _currentWindowID = windowId;\n    if (_suppressActivityChanges) {\n        DLog(@\"Not sending select-window -t %%%d because activity changes are suppressed\", windowId);\n        return;\n    }\n    NSString *command = [NSString stringWithFormat:@\"select-window -t @%d\", windowId];\n    [gateway_ sendCommand:command\n           responseTarget:nil\n         responseSelector:nil];\n}\n\n- (NSString *)userVarsString:(int)paneID {\n    NSDictionary<NSString *, NSString *> *dict = _userVars[@(paneID)];\n    return [[dict.allKeys mapWithBlock:^id(NSString *key) {\n        NSString *value = dict[key];\n        NSInteger index = [value rangeOfString:@\"\\0\"].location;\n        if (index != NSNotFound) {\n            value = [value substringToIndex:index];\n        }\n        return [NSString stringWithFormat:@\"%@=%@\", key, value];\n    }] componentsJoinedByString:@\"\\0\"];\n}\n\n- (void)setEncodedUserVars:(NSString *)encodedUserVars forPane:(int)paneID {\n    NSString *decoded = [self decodedString:encodedUserVars\n                             optionalPrefix:iTermTmuxControllerEncodingPrefixUserVars] ?: @\"\";\n    NSArray<NSString *> *kvps = [decoded componentsSeparatedByString:@\"\\0\"];\n    NSMutableDictionary<NSString *, NSString *> *dict = [self mutableUserVarsForPane:paneID];\n    [dict removeAllObjects];\n    for (NSString *kvp in kvps) {\n        NSInteger index = [kvp rangeOfString:@\"=\"].location;\n        if (index == NSNotFound) {\n            continue;\n        }\n        NSString *key = [kvp substringToIndex:index];\n        NSString *value = [kvp substringFromIndex:index + 1];\n        dict[key] = value;\n    }\n}\n\n- (NSDictionary<NSString *, NSString *> *)userVarsForPane:(int)paneID {\n    return _userVars[@(paneID)] ?: @{};\n}\n\n- (NSMutableDictionary<NSString *, NSString *> *)mutableUserVarsForPane:(int)paneID {\n    NSMutableDictionary<NSString *, NSString *> *dict = _userVars[@(paneID)];\n    if (dict) {\n        return dict;\n    }\n    dict = [NSMutableDictionary dictionary];\n    _userVars[@(paneID)] = dict;\n    return dict;\n}\n\n- (void)setUserVariableWithKey:(NSString *)key\n                         value:(NSString *)value\n                          pane:(int)paneID {\n    if (![self versionAtLeastDecimalNumberWithString:@\"3.1\"]) {\n        return;\n    }\n    NSMutableDictionary<NSString *, NSString *> *dict = [self mutableUserVarsForPane:paneID];\n    if (!value) {\n        if (!dict[key]) {\n            return;\n        }\n        [dict removeObjectForKey:key];\n    } else {\n        if ([dict[key] isEqualToString:value]) {\n            return;\n        }\n        dict[key] = value;\n    }\n    NSString *command = [NSString stringWithFormat:@\"set -p -t %%%d @uservars \\\"%@\\\"\",\n                         paneID,\n                         [self encodedString:[self userVarsString:paneID]\n                                      prefix:iTermTmuxControllerEncodingPrefixUserVars]];\n    [gateway_ sendCommand:command responseTarget:nil responseSelector:nil];\n}\n\n- (void)setCurrentLatency:(NSTimeInterval)latency forPane:(int)wp {\n    [_tmuxBufferMonitor setCurrentLatency:latency forPane:wp];\n}\n\n- (void)copyBufferToLocalPasteboard:(NSString *)bufferName {\n    [gateway_ sendCommand:[NSString stringWithFormat:@\"show-buffer -b %@\", bufferName]\n           responseTarget:self\n         responseSelector:@selector(handleShowBuffer:)];\n}\n\n- (void)handleShowBuffer:(NSString *)content {\n    if ([content length]) {\n        NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];\n        [pasteboard clearContents];\n        [pasteboard declareTypes:@[ NSPasteboardTypeString ] owner:nil];\n        [pasteboard setString:content forType:NSPasteboardTypeString];\n    }\n}\n#pragma mark - iTermTmuxBufferSizeMonitorDelegate\n\n- (void)tmuxBufferSizeMonitor:(iTermTmuxBufferSizeMonitor *)sender\n                   updatePane:(int)wp\n                          ttl:(NSTimeInterval)ttl\n                      redzone:(BOOL)redzone {\n    PTYSession<iTermTmuxControllerSession> *session = [self sessionForWindowPane:wp];\n    if (!session) {\n        return;\n    }\n    [session tmuxControllerSessionSetTTL:ttl redzone:redzone];\n}\n\n#pragma mark - Notifications\n\n- (void)textViewWillChangeFont:(NSNotification *)notification {\n    if ([iTermPreferences boolForKey:kPreferenceKeyAdjustWindowForFontSizeChange]) {\n        return;\n    }\n    if (_savedFrames.count) {\n        return;\n    }\n    NSArray *terminals = [[iTermController sharedInstance] terminals];\n    for (PseudoTerminal *term in terminals) {\n        if ([self windowControllerHasTmuxTabOfMine:term]) {\n            _savedFrames[term.terminalGuid] = [NSValue valueWithRect:term.window.frame];\n        }\n    }\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self->_savedFrames removeAllObjects];\n    });\n}\n\n- (BOOL)windowControllerHasTmuxTabOfMine:(PseudoTerminal *)term {\n    return [term.tabs anyWithBlock:^BOOL(PTYTab *tab) {\n        return tab.isTmuxTab && tab.tmuxController == self;\n    }];\n}\n\n- (void)restoreWindowFrame:(PseudoTerminal *)term {\n    if ([iTermPreferences boolForKey:kPreferenceKeyAdjustWindowForFontSizeChange]) {\n        return;\n    }\n    NSRect savedFrame;\n    if ([self getSavedFrameForWindowController:term frame:&savedFrame]) {\n        [term.window setFrame:savedFrame display:YES];\n    }\n}\n\n- (BOOL)getSavedFrameForWindowController:(PseudoTerminal *)term frame:(NSRect *)framePtr {\n    NSValue *value = _savedFrames[term.terminalGuid];\n    if (!value) {\n        return NO;\n    }\n    *framePtr = value.rectValue;\n    return YES;\n}\n\n@end\n"], "filenames": ["sources/PTYSession.m", "sources/TmuxController.h", "sources/TmuxController.m"], "buggy_code_start_loc": [7892, 133, 1083], "buggy_code_end_loc": [7892, 133, 1083], "fixing_code_start_loc": [7893, 134, 1084], "fixing_code_end_loc": [7894, 135, 1092], "type": "CWE-116", "message": "iTerm2 before 3.4.20 allow (potentially remote) code execution because of mishandling of certain escape sequences related to tmux integration.", "other": {"cve": {"id": "CVE-2023-46300", "sourceIdentifier": "cve@mitre.org", "published": "2023-10-22T04:15:09.740", "lastModified": "2023-10-31T17:08:50.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "iTerm2 before 3.4.20 allow (potentially remote) code execution because of mishandling of certain escape sequences related to tmux integration."}, {"lang": "es", "value": "iTerm2 anterior a 3.4.20 permite la ejecuci\u00f3n de c\u00f3digo (potencialmente remota) debido al mal manejo de ciertas secuencias de escape relacionadas con la integraci\u00f3n de tmux."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-116"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:iterm2:iterm2:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.20", "matchCriteriaId": "AE5A8378-60FE-4F69-A7AA-DEE9393C51C8"}]}]}], "references": [{"url": "https://blog.solidsnail.com/posts/2023-08-28-iterm2-rce", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/gnachman/iTerm2/commit/ae8192522661c34d1cbe57f6f9ef2ff0a337c2a5", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/gnachman/iTerm2/commit/b2268b03b5f3d4cd8ca275eaef5d16d0fac20009", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://iterm2.com/news.html", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/gnachman/iTerm2/commit/ae8192522661c34d1cbe57f6f9ef2ff0a337c2a5"}}