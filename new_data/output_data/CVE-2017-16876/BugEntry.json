{"buggy_code": ["# coding: utf-8\n\"\"\"\n    mistune\n    ~~~~~~~\n\n    The fastest markdown parser in pure Python with renderer feature.\n\n    :copyright: (c) 2014 - 2017 by Hsiaoming Yang.\n\"\"\"\n\nimport re\nimport inspect\n\n__version__ = '0.8'\n__author__ = 'Hsiaoming Yang <me@lepture.com>'\n__all__ = [\n    'BlockGrammar', 'BlockLexer',\n    'InlineGrammar', 'InlineLexer',\n    'Renderer', 'Markdown',\n    'markdown', 'escape',\n]\n\n\n_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\=(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\n\n\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\n\n\ndef _keyify(key):\n    return _key_pattern.sub(' ', key.lower())\n\n\ndef escape(text, quote=False, smart_amp=True):\n    \"\"\"Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\n\n    The original cgi.escape will always escape \"&\", but you can control\n    this one for a smart escape amp.\n\n    :param quote: if set to True, \" and ' will be escaped.\n    :param smart_amp: if set to False, & will always be escaped.\n    \"\"\"\n    if smart_amp:\n        text = _escape_pattern.sub('&amp;', text)\n    else:\n        text = text.replace('&', '&amp;')\n    text = text.replace('<', '&lt;')\n    text = text.replace('>', '&gt;')\n    if quote:\n        text = text.replace('\"', '&quot;')\n        text = text.replace(\"'\", '&#39;')\n    return text\n\n\ndef escape_link(url):\n    \"\"\"Remove dangerous URL schemes like javascript: and escape afterwards.\"\"\"\n    lower_url = url.lower().strip('\\x00\\x1a \\n\\r\\t')\n\n    for scheme in _scheme_blacklist:\n        if re.sub(r'[^A-Za-z0-9\\/:]+', '', lower_url).startswith(scheme):\n            return ''\n    return escape(url, quote=True, smart_amp=False)\n\n\ndef preprocessing(text, tab=4):\n    text = _newline_pattern.sub('\\n', text)\n    text = text.expandtabs(tab)\n    text = text.replace('\\u2424', '\\n')\n    pattern = re.compile(r'^ +$', re.M)\n    return pattern.sub('', text)\n\n\nclass BlockGrammar(object):\n    \"\"\"Grammars for block level tokens.\"\"\"\n\n    def_links = re.compile(\n        r'^ *\\[([^^\\]]+)\\]: *'  # [key]:\n        r'<?([^\\s>]+)>?'  # <link> or link\n        r'(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)'\n    )\n    def_footnotes = re.compile(\n        r'^\\[\\^([^\\]]+)\\]: *('\n        r'[^\\n]*(?:\\n+|$)'  # [^key]:\n        r'(?: {1,}[^\\n]*(?:\\n+|$))*'\n        r')'\n    )\n\n    newline = re.compile(r'^\\n+')\n    block_code = re.compile(r'^( {4}[^\\n]+\\n*)+')\n    fences = re.compile(\n        r'^ *(`{3,}|~{3,}) *(\\S+)? *\\n'  # ```lang\n        r'([\\s\\S]+?)\\s*'\n        r'\\1 *(?:\\n+|$)'  # ```\n    )\n    hrule = re.compile(r'^ {0,3}[-*_](?: *[-*_]){2,} *(?:\\n+|$)')\n    heading = re.compile(r'^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)')\n    lheading = re.compile(r'^([^\\n]+)\\n *(=|-)+ *(?:\\n+|$)')\n    block_quote = re.compile(r'^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+')\n    list_block = re.compile(\n        r'^( *)([*+-]|\\d+\\.) [\\s\\S]+?'\n        r'(?:'\n        r'\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))'  # hrule\n        r'|\\n+(?=%s)'  # def links\n        r'|\\n+(?=%s)'  # def footnotes\n        r'|\\n{2,}'\n        r'(?! )'\n        r'(?!\\1(?:[*+-]|\\d+\\.) )\\n*'\n        r'|'\n        r'\\s*$)' % (\n            _pure_pattern(def_links),\n            _pure_pattern(def_footnotes),\n        )\n    )\n    list_item = re.compile(\n        r'^(( *)(?:[*+-]|\\d+\\.) [^\\n]*'\n        r'(?:\\n(?!\\2(?:[*+-]|\\d+\\.) )[^\\n]*)*)',\n        flags=re.M\n    )\n    list_bullet = re.compile(r'^ *(?:[*+-]|\\d+\\.) +')\n    paragraph = re.compile(\n        r'^((?:[^\\n]+\\n?(?!'\n        r'%s|%s|%s|%s|%s|%s|%s|%s|%s'\n        r'))+)\\n*' % (\n            _pure_pattern(fences).replace(r'\\1', r'\\2'),\n            _pure_pattern(list_block).replace(r'\\1', r'\\3'),\n            _pure_pattern(hrule),\n            _pure_pattern(heading),\n            _pure_pattern(lheading),\n            _pure_pattern(block_quote),\n            _pure_pattern(def_links),\n            _pure_pattern(def_footnotes),\n            '<' + _block_tag,\n        )\n    )\n    block_html = re.compile(\n        r'^ *(?:%s|%s|%s) *(?:\\n{2,}|\\s*$)' % (\n            r'<!--[\\s\\S]*?-->',\n            r'<(%s)((?:%s)*?)>([\\s\\S]*?)<\\/\\1>' % (_block_tag, _valid_attr),\n            r'<%s(?:%s)*?\\s*\\/?>' % (_block_tag, _valid_attr),\n        )\n    )\n    table = re.compile(\n        r'^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*'\n    )\n    nptable = re.compile(\n        r'^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*'\n    )\n    text = re.compile(r'^[^\\n]+')\n\n\nclass BlockLexer(object):\n    \"\"\"Block level lexer for block grammars.\"\"\"\n    grammar_class = BlockGrammar\n\n    default_rules = [\n        'newline', 'hrule', 'block_code', 'fences', 'heading',\n        'nptable', 'lheading', 'block_quote',\n        'list_block', 'block_html', 'def_links',\n        'def_footnotes', 'table', 'paragraph', 'text'\n    ]\n\n    list_rules = (\n        'newline', 'block_code', 'fences', 'lheading', 'hrule',\n        'block_quote', 'list_block', 'block_html', 'text',\n    )\n\n    footnote_rules = (\n        'newline', 'block_code', 'fences', 'heading',\n        'nptable', 'lheading', 'hrule', 'block_quote',\n        'list_block', 'block_html', 'table', 'paragraph', 'text'\n    )\n\n    def __init__(self, rules=None, **kwargs):\n        self.tokens = []\n        self.def_links = {}\n        self.def_footnotes = {}\n\n        if not rules:\n            rules = self.grammar_class()\n\n        self.rules = rules\n\n    def __call__(self, text, rules=None):\n        return self.parse(text, rules)\n\n    def parse(self, text, rules=None):\n        text = text.rstrip('\\n')\n\n        if not rules:\n            rules = self.default_rules\n\n        def manipulate(text):\n            for key in rules:\n                rule = getattr(self.rules, key)\n                m = rule.match(text)\n                if not m:\n                    continue\n                getattr(self, 'parse_%s' % key)(m)\n                return m\n            return False  # pragma: no cover\n\n        while text:\n            m = manipulate(text)\n            if m is not False:\n                text = text[len(m.group(0)):]\n                continue\n            if text:  # pragma: no cover\n                raise RuntimeError('Infinite loop at: %s' % text)\n        return self.tokens\n\n    def parse_newline(self, m):\n        length = len(m.group(0))\n        if length > 1:\n            self.tokens.append({'type': 'newline'})\n\n    def parse_block_code(self, m):\n        # clean leading whitespace\n        code = _block_code_leading_pattern.sub('', m.group(0))\n        self.tokens.append({\n            'type': 'code',\n            'lang': None,\n            'text': code,\n        })\n\n    def parse_fences(self, m):\n        self.tokens.append({\n            'type': 'code',\n            'lang': m.group(2),\n            'text': m.group(3),\n        })\n\n    def parse_heading(self, m):\n        self.tokens.append({\n            'type': 'heading',\n            'level': len(m.group(1)),\n            'text': m.group(2),\n        })\n\n    def parse_lheading(self, m):\n        \"\"\"Parse setext heading.\"\"\"\n        self.tokens.append({\n            'type': 'heading',\n            'level': 1 if m.group(2) == '=' else 2,\n            'text': m.group(1),\n        })\n\n    def parse_hrule(self, m):\n        self.tokens.append({'type': 'hrule'})\n\n    def parse_list_block(self, m):\n        bull = m.group(2)\n        self.tokens.append({\n            'type': 'list_start',\n            'ordered': '.' in bull,\n        })\n        cap = m.group(0)\n        self._process_list_item(cap, bull)\n        self.tokens.append({'type': 'list_end'})\n\n    def _process_list_item(self, cap, bull):\n        cap = self.rules.list_item.findall(cap)\n\n        _next = False\n        length = len(cap)\n\n        for i in range(length):\n            item = cap[i][0]\n\n            # remove the bullet\n            space = len(item)\n            item = self.rules.list_bullet.sub('', item)\n\n            # outdent\n            if '\\n ' in item:\n                space = space - len(item)\n                pattern = re.compile(r'^ {1,%d}' % space, flags=re.M)\n                item = pattern.sub('', item)\n\n            # determine whether item is loose or not\n            loose = _next\n            if not loose and re.search(r'\\n\\n(?!\\s*$)', item):\n                loose = True\n\n            rest = len(item)\n            if i != length - 1 and rest:\n                _next = item[rest-1] == '\\n'\n                if not loose:\n                    loose = _next\n\n            if loose:\n                t = 'loose_item_start'\n            else:\n                t = 'list_item_start'\n\n            self.tokens.append({'type': t})\n            # recurse\n            self.parse(item, self.list_rules)\n            self.tokens.append({'type': 'list_item_end'})\n\n    def parse_block_quote(self, m):\n        self.tokens.append({'type': 'block_quote_start'})\n        # clean leading >\n        cap = _block_quote_leading_pattern.sub('', m.group(0))\n        self.parse(cap)\n        self.tokens.append({'type': 'block_quote_end'})\n\n    def parse_def_links(self, m):\n        key = _keyify(m.group(1))\n        self.def_links[key] = {\n            'link': m.group(2),\n            'title': m.group(3),\n        }\n\n    def parse_def_footnotes(self, m):\n        key = _keyify(m.group(1))\n        if key in self.def_footnotes:\n            # footnote is already defined\n            return\n\n        self.def_footnotes[key] = 0\n\n        self.tokens.append({\n            'type': 'footnote_start',\n            'key': key,\n        })\n\n        text = m.group(2)\n\n        if '\\n' in text:\n            lines = text.split('\\n')\n            whitespace = None\n            for line in lines[1:]:\n                space = len(line) - len(line.lstrip())\n                if space and (not whitespace or space < whitespace):\n                    whitespace = space\n            newlines = [lines[0]]\n            for line in lines[1:]:\n                newlines.append(line[whitespace:])\n            text = '\\n'.join(newlines)\n\n        self.parse(text, self.footnote_rules)\n\n        self.tokens.append({\n            'type': 'footnote_end',\n            'key': key,\n        })\n\n    def parse_table(self, m):\n        item = self._process_table(m)\n\n        cells = re.sub(r'(?: *\\| *)?\\n$', '', m.group(3))\n        cells = cells.split('\\n')\n        for i, v in enumerate(cells):\n            v = re.sub(r'^ *\\| *| *\\| *$', '', v)\n            cells[i] = re.split(r' *\\| *', v)\n\n        item['cells'] = cells\n        self.tokens.append(item)\n\n    def parse_nptable(self, m):\n        item = self._process_table(m)\n\n        cells = re.sub(r'\\n$', '', m.group(3))\n        cells = cells.split('\\n')\n        for i, v in enumerate(cells):\n            cells[i] = re.split(r' *\\| *', v)\n\n        item['cells'] = cells\n        self.tokens.append(item)\n\n    def _process_table(self, m):\n        header = re.sub(r'^ *| *\\| *$', '', m.group(1))\n        header = re.split(r' *\\| *', header)\n        align = re.sub(r' *|\\| *$', '', m.group(2))\n        align = re.split(r' *\\| *', align)\n\n        for i, v in enumerate(align):\n            if re.search(r'^ *-+: *$', v):\n                align[i] = 'right'\n            elif re.search(r'^ *:-+: *$', v):\n                align[i] = 'center'\n            elif re.search(r'^ *:-+ *$', v):\n                align[i] = 'left'\n            else:\n                align[i] = None\n\n        item = {\n            'type': 'table',\n            'header': header,\n            'align': align,\n        }\n        return item\n\n    def parse_block_html(self, m):\n        tag = m.group(1)\n        if not tag:\n            text = m.group(0)\n            self.tokens.append({\n                'type': 'close_html',\n                'text': text\n            })\n        else:\n            attr = m.group(2)\n            text = m.group(3)\n            self.tokens.append({\n                'type': 'open_html',\n                'tag': tag,\n                'extra': attr,\n                'text': text\n            })\n\n    def parse_paragraph(self, m):\n        text = m.group(1).rstrip('\\n')\n        self.tokens.append({'type': 'paragraph', 'text': text})\n\n    def parse_text(self, m):\n        text = m.group(0)\n        self.tokens.append({'type': 'text', 'text': text})\n\n\nclass InlineGrammar(object):\n    \"\"\"Grammars for inline level tokens.\"\"\"\n\n    escape = re.compile(r'^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>~|])')  # \\* \\+ \\! ....\n    inline_html = re.compile(\n        r'^(?:%s|%s|%s)' % (\n            r'<!--[\\s\\S]*?-->',\n            r'<(\\w+%s)((?:%s)*?)\\s*>([\\s\\S]*?)<\\/\\1>' % (_valid_end, _valid_attr),\n            r'<\\w+%s(?:%s)*?\\s*\\/?>' % (_valid_end, _valid_attr),\n        )\n    )\n    autolink = re.compile(r'^<([^ >]+(@|:)[^ >]+)>')\n    link = re.compile(\n        r'^!?\\[('\n        r'(?:\\[[^^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*'\n        r')\\]\\('\n        r'''\\s*(<)?([\\s\\S]*?)(?(2)>)(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*'''\n        r'\\)'\n    )\n    reflink = re.compile(\n        r'^!?\\[('\n        r'(?:\\[[^^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*'\n        r')\\]\\s*\\[([^^\\]]*)\\]'\n    )\n    nolink = re.compile(r'^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]')\n    url = re.compile(r'''^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])''')\n    double_emphasis = re.compile(\n        r'^_{2}([\\s\\S]+?)_{2}(?!_)'  # __word__\n        r'|'\n        r'^\\*{2}([\\s\\S]+?)\\*{2}(?!\\*)'  # **word**\n    )\n    emphasis = re.compile(\n        r'^\\b_((?:__|[^_])+?)_\\b'  # _word_\n        r'|'\n        r'^\\*((?:\\*\\*|[^\\*])+?)\\*(?!\\*)'  # *word*\n    )\n    code = re.compile(r'^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)')  # `code`\n    linebreak = re.compile(r'^ {2,}\\n(?!\\s*$)')\n    strikethrough = re.compile(r'^~~(?=\\S)([\\s\\S]*?\\S)~~')  # ~~word~~\n    footnote = re.compile(r'^\\[\\^([^\\]]+)\\]')\n    text = re.compile(r'^[\\s\\S]+?(?=[\\\\<!\\[_*`~]|https?://| {2,}\\n|$)')\n\n    def hard_wrap(self):\n        \"\"\"Grammar for hard wrap linebreak. You don't need to add two\n        spaces at the end of a line.\n        \"\"\"\n        self.linebreak = re.compile(r'^ *\\n(?!\\s*$)')\n        self.text = re.compile(\n            r'^[\\s\\S]+?(?=[\\\\<!\\[_*`~]|https?://| *\\n|$)'\n        )\n\n\nclass InlineLexer(object):\n    \"\"\"Inline level lexer for inline grammars.\"\"\"\n    grammar_class = InlineGrammar\n\n    default_rules = [\n        'escape', 'inline_html', 'autolink', 'url',\n        'footnote', 'link', 'reflink', 'nolink',\n        'double_emphasis', 'emphasis', 'code',\n        'linebreak', 'strikethrough', 'text',\n    ]\n    inline_html_rules = [\n        'escape', 'autolink', 'url', 'link', 'reflink',\n        'nolink', 'double_emphasis', 'emphasis', 'code',\n        'linebreak', 'strikethrough', 'text',\n    ]\n\n    def __init__(self, renderer, rules=None, **kwargs):\n        self.renderer = renderer\n        self.links = {}\n        self.footnotes = {}\n        self.footnote_index = 0\n\n        if not rules:\n            rules = self.grammar_class()\n\n        kwargs.update(self.renderer.options)\n        if kwargs.get('hard_wrap'):\n            rules.hard_wrap()\n\n        self.rules = rules\n\n        self._in_link = False\n        self._in_footnote = False\n        self._parse_inline_html = kwargs.get('parse_inline_html')\n\n    def __call__(self, text, rules=None):\n        return self.output(text, rules)\n\n    def setup(self, links, footnotes):\n        self.footnote_index = 0\n        self.links = links or {}\n        self.footnotes = footnotes or {}\n\n    def output(self, text, rules=None):\n        text = text.rstrip('\\n')\n        if not rules:\n            rules = list(self.default_rules)\n\n        if self._in_footnote and 'footnote' in rules:\n            rules.remove('footnote')\n\n        output = self.renderer.placeholder()\n\n        def manipulate(text):\n            for key in rules:\n                pattern = getattr(self.rules, key)\n                m = pattern.match(text)\n                if not m:\n                    continue\n                self.line_match = m\n                out = getattr(self, 'output_%s' % key)(m)\n                if out is not None:\n                    return m, out\n            return False  # pragma: no cover\n\n        while text:\n            ret = manipulate(text)\n            if ret is not False:\n                m, out = ret\n                output += out\n                text = text[len(m.group(0)):]\n                continue\n            if text:  # pragma: no cover\n                raise RuntimeError('Infinite loop at: %s' % text)\n\n        return output\n\n    def output_escape(self, m):\n        text = m.group(1)\n        return self.renderer.escape(text)\n\n    def output_autolink(self, m):\n        link = m.group(1)\n        if m.group(2) == '@':\n            is_email = True\n        else:\n            is_email = False\n        return self.renderer.autolink(link, is_email)\n\n    def output_url(self, m):\n        link = m.group(1)\n        if self._in_link:\n            return self.renderer.text(link)\n        return self.renderer.autolink(link, False)\n\n    def output_inline_html(self, m):\n        tag = m.group(1)\n        if self._parse_inline_html and tag in _inline_tags:\n            text = m.group(3)\n            if tag == 'a':\n                self._in_link = True\n                text = self.output(text, rules=self.inline_html_rules)\n                self._in_link = False\n            else:\n                text = self.output(text, rules=self.inline_html_rules)\n            extra = m.group(2) or ''\n            html = '<%s%s>%s</%s>' % (tag, extra, text, tag)\n        else:\n            html = m.group(0)\n        return self.renderer.inline_html(html)\n\n    def output_footnote(self, m):\n        key = _keyify(m.group(1))\n        if key not in self.footnotes:\n            return None\n        if self.footnotes[key]:\n            return None\n        self.footnote_index += 1\n        self.footnotes[key] = self.footnote_index\n        return self.renderer.footnote_ref(key, self.footnote_index)\n\n    def output_link(self, m):\n        return self._process_link(m, m.group(3), m.group(4))\n\n    def output_reflink(self, m):\n        key = _keyify(m.group(2) or m.group(1))\n        if key not in self.links:\n            return None\n        ret = self.links[key]\n        return self._process_link(m, ret['link'], ret['title'])\n\n    def output_nolink(self, m):\n        key = _keyify(m.group(1))\n        if key not in self.links:\n            return None\n        ret = self.links[key]\n        return self._process_link(m, ret['link'], ret['title'])\n\n    def _process_link(self, m, link, title=None):\n        line = m.group(0)\n        text = m.group(1)\n        if line[0] == '!':\n            return self.renderer.image(link, title, text)\n\n        self._in_link = True\n        text = self.output(text)\n        self._in_link = False\n        return self.renderer.link(link, title, text)\n\n    def output_double_emphasis(self, m):\n        text = m.group(2) or m.group(1)\n        text = self.output(text)\n        return self.renderer.double_emphasis(text)\n\n    def output_emphasis(self, m):\n        text = m.group(2) or m.group(1)\n        text = self.output(text)\n        return self.renderer.emphasis(text)\n\n    def output_code(self, m):\n        text = m.group(2)\n        return self.renderer.codespan(text)\n\n    def output_linebreak(self, m):\n        return self.renderer.linebreak()\n\n    def output_strikethrough(self, m):\n        text = self.output(m.group(1))\n        return self.renderer.strikethrough(text)\n\n    def output_text(self, m):\n        text = m.group(0)\n        return self.renderer.text(text)\n\n\nclass Renderer(object):\n    \"\"\"The default HTML renderer for rendering Markdown.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.options = kwargs\n\n    def placeholder(self):\n        \"\"\"Returns the default, empty output value for the renderer.\n\n        All renderer methods use the '+=' operator to append to this value.\n        Default is a string so rendering HTML can build up a result string with\n        the rendered Markdown.\n\n        Can be overridden by Renderer subclasses to be types like an empty\n        list, allowing the renderer to create a tree-like structure to\n        represent the document (which can then be reprocessed later into a\n        separate format like docx or pdf).\n        \"\"\"\n        return ''\n\n    def block_code(self, code, lang=None):\n        \"\"\"Rendering block level code. ``pre > code``.\n\n        :param code: text content of the code block.\n        :param lang: language of the given code.\n        \"\"\"\n        code = code.rstrip('\\n')\n        if not lang:\n            code = escape(code, smart_amp=False)\n            return '<pre><code>%s\\n</code></pre>\\n' % code\n        code = escape(code, quote=True, smart_amp=False)\n        return '<pre><code class=\"lang-%s\">%s\\n</code></pre>\\n' % (lang, code)\n\n    def block_quote(self, text):\n        \"\"\"Rendering <blockquote> with the given text.\n\n        :param text: text content of the blockquote.\n        \"\"\"\n        return '<blockquote>%s\\n</blockquote>\\n' % text.rstrip('\\n')\n\n    def block_html(self, html):\n        \"\"\"Rendering block level pure html content.\n\n        :param html: text content of the html snippet.\n        \"\"\"\n        if self.options.get('skip_style') and \\\n           html.lower().startswith('<style'):\n            return ''\n        if self.options.get('escape'):\n            return escape(html)\n        return html\n\n    def header(self, text, level, raw=None):\n        \"\"\"Rendering header/heading tags like ``<h1>`` ``<h2>``.\n\n        :param text: rendered text content for the header.\n        :param level: a number for the header level, for example: 1.\n        :param raw: raw text content of the header.\n        \"\"\"\n        return '<h%d>%s</h%d>\\n' % (level, text, level)\n\n    def hrule(self):\n        \"\"\"Rendering method for ``<hr>`` tag.\"\"\"\n        if self.options.get('use_xhtml'):\n            return '<hr />\\n'\n        return '<hr>\\n'\n\n    def list(self, body, ordered=True):\n        \"\"\"Rendering list tags like ``<ul>`` and ``<ol>``.\n\n        :param body: body contents of the list.\n        :param ordered: whether this list is ordered or not.\n        \"\"\"\n        tag = 'ul'\n        if ordered:\n            tag = 'ol'\n        return '<%s>\\n%s</%s>\\n' % (tag, body, tag)\n\n    def list_item(self, text):\n        \"\"\"Rendering list item snippet. Like ``<li>``.\"\"\"\n        return '<li>%s</li>\\n' % text\n\n    def paragraph(self, text):\n        \"\"\"Rendering paragraph tags. Like ``<p>``.\"\"\"\n        return '<p>%s</p>\\n' % text.strip(' ')\n\n    def table(self, header, body):\n        \"\"\"Rendering table element. Wrap header and body in it.\n\n        :param header: header part of the table.\n        :param body: body part of the table.\n        \"\"\"\n        return (\n            '<table>\\n<thead>%s</thead>\\n'\n            '<tbody>\\n%s</tbody>\\n</table>\\n'\n        ) % (header, body)\n\n    def table_row(self, content):\n        \"\"\"Rendering a table row. Like ``<tr>``.\n\n        :param content: content of current table row.\n        \"\"\"\n        return '<tr>\\n%s</tr>\\n' % content\n\n    def table_cell(self, content, **flags):\n        \"\"\"Rendering a table cell. Like ``<th>`` ``<td>``.\n\n        :param content: content of current table cell.\n        :param header: whether this is header or not.\n        :param align: align of current table cell.\n        \"\"\"\n        if flags['header']:\n            tag = 'th'\n        else:\n            tag = 'td'\n        align = flags['align']\n        if not align:\n            return '<%s>%s</%s>\\n' % (tag, content, tag)\n        return '<%s style=\"text-align:%s\">%s</%s>\\n' % (\n            tag, align, content, tag\n        )\n\n    def double_emphasis(self, text):\n        \"\"\"Rendering **strong** text.\n\n        :param text: text content for emphasis.\n        \"\"\"\n        return '<strong>%s</strong>' % text\n\n    def emphasis(self, text):\n        \"\"\"Rendering *emphasis* text.\n\n        :param text: text content for emphasis.\n        \"\"\"\n        return '<em>%s</em>' % text\n\n    def codespan(self, text):\n        \"\"\"Rendering inline `code` text.\n\n        :param text: text content for inline code.\n        \"\"\"\n        text = escape(text.rstrip(), smart_amp=False)\n        return '<code>%s</code>' % text\n\n    def linebreak(self):\n        \"\"\"Rendering line break like ``<br>``.\"\"\"\n        if self.options.get('use_xhtml'):\n            return '<br />\\n'\n        return '<br>\\n'\n\n    def strikethrough(self, text):\n        \"\"\"Rendering ~~strikethrough~~ text.\n\n        :param text: text content for strikethrough.\n        \"\"\"\n        return '<del>%s</del>' % text\n\n    def text(self, text):\n        \"\"\"Rendering unformatted text.\n\n        :param text: text content.\n        \"\"\"\n        if self.options.get('parse_block_html'):\n            return text\n        return escape(text)\n\n    def escape(self, text):\n        \"\"\"Rendering escape sequence.\n\n        :param text: text content.\n        \"\"\"\n        return escape(text)\n\n    def autolink(self, link, is_email=False):\n        \"\"\"Rendering a given link or email address.\n\n        :param link: link content or email address.\n        :param is_email: whether this is an email or not.\n        \"\"\"\n        text = link = escape_link(link)\n        if is_email:\n            link = 'mailto:%s' % link\n        return '<a href=\"%s\">%s</a>' % (link, text)\n\n    def link(self, link, title, text):\n        \"\"\"Rendering a given link with content and title.\n\n        :param link: href link for ``<a>`` tag.\n        :param title: title content for `title` attribute.\n        :param text: text content for description.\n        \"\"\"\n        link = escape_link(link)\n        if not title:\n            return '<a href=\"%s\">%s</a>' % (link, text)\n        title = escape(title, quote=True)\n        return '<a href=\"%s\" title=\"%s\">%s</a>' % (link, title, text)\n\n    def image(self, src, title, text):\n        \"\"\"Rendering a image with title and text.\n\n        :param src: source link of the image.\n        :param title: title text of the image.\n        :param text: alt text of the image.\n        \"\"\"\n        src = escape_link(src)\n        text = escape(text, quote=True)\n        if title:\n            title = escape(title, quote=True)\n            html = '<img src=\"%s\" alt=\"%s\" title=\"%s\"' % (src, text, title)\n        else:\n            html = '<img src=\"%s\" alt=\"%s\"' % (src, text)\n        if self.options.get('use_xhtml'):\n            return '%s />' % html\n        return '%s>' % html\n\n    def inline_html(self, html):\n        \"\"\"Rendering span level pure html content.\n\n        :param html: text content of the html snippet.\n        \"\"\"\n        if self.options.get('escape'):\n            return escape(html)\n        return html\n\n    def newline(self):\n        \"\"\"Rendering newline element.\"\"\"\n        return ''\n\n    def footnote_ref(self, key, index):\n        \"\"\"Rendering the ref anchor of a footnote.\n\n        :param key: identity key for the footnote.\n        :param index: the index count of current footnote.\n        \"\"\"\n        html = (\n            '<sup class=\"footnote-ref\" id=\"fnref-%s\">'\n            '<a href=\"#fn-%s\">%d</a></sup>'\n        ) % (escape(key), escape(key), index)\n        return html\n\n    def footnote_item(self, key, text):\n        \"\"\"Rendering a footnote item.\n\n        :param key: identity key for the footnote.\n        :param text: text content of the footnote.\n        \"\"\"\n        back = (\n            '<a href=\"#fnref-%s\" class=\"footnote\">&#8617;</a>'\n        ) % escape(key)\n        text = text.rstrip()\n        if text.endswith('</p>'):\n            text = re.sub(r'<\\/p>$', r'%s</p>' % back, text)\n        else:\n            text = '%s<p>%s</p>' % (text, back)\n        html = '<li id=\"fn-%s\">%s</li>\\n' % (escape(key), text)\n        return html\n\n    def footnotes(self, text):\n        \"\"\"Wrapper for all footnotes.\n\n        :param text: contents of all footnotes.\n        \"\"\"\n        html = '<div class=\"footnotes\">\\n%s<ol>%s</ol>\\n</div>\\n'\n        return html % (self.hrule(), text)\n\n\nclass Markdown(object):\n    \"\"\"The Markdown parser.\n\n    :param renderer: An instance of ``Renderer``.\n    :param inline: An inline lexer class or instance.\n    :param block: A block lexer class or instance.\n    \"\"\"\n    def __init__(self, renderer=None, inline=None, block=None, **kwargs):\n        if not renderer:\n            renderer = Renderer(**kwargs)\n        else:\n            kwargs.update(renderer.options)\n\n        self.renderer = renderer\n\n        if inline and inspect.isclass(inline):\n            inline = inline(renderer, **kwargs)\n        if block and inspect.isclass(block):\n            block = block(**kwargs)\n\n        if inline:\n            self.inline = inline\n        else:\n            self.inline = InlineLexer(renderer, **kwargs)\n\n        self.block = block or BlockLexer(BlockGrammar())\n        self.footnotes = []\n        self.tokens = []\n\n        # detect if it should parse text in block html\n        self._parse_block_html = kwargs.get('parse_block_html')\n\n    def __call__(self, text):\n        return self.parse(text)\n\n    def render(self, text):\n        \"\"\"Render the Markdown text.\n\n        :param text: markdown formatted text content.\n        \"\"\"\n        return self.parse(text)\n\n    def parse(self, text):\n        out = self.output(preprocessing(text))\n\n        keys = self.block.def_footnotes\n\n        # reset block\n        self.block.def_links = {}\n        self.block.def_footnotes = {}\n\n        # reset inline\n        self.inline.links = {}\n        self.inline.footnotes = {}\n\n        if not self.footnotes:\n            return out\n\n        footnotes = filter(lambda o: keys.get(o['key']), self.footnotes)\n        self.footnotes = sorted(\n            footnotes, key=lambda o: keys.get(o['key']), reverse=True\n        )\n\n        body = self.renderer.placeholder()\n        while self.footnotes:\n            note = self.footnotes.pop()\n            body += self.renderer.footnote_item(\n                note['key'], note['text']\n            )\n\n        out += self.renderer.footnotes(body)\n        return out\n\n    def pop(self):\n        if not self.tokens:\n            return None\n        self.token = self.tokens.pop()\n        return self.token\n\n    def peek(self):\n        if self.tokens:\n            return self.tokens[-1]\n        return None  # pragma: no cover\n\n    def output(self, text, rules=None):\n        self.tokens = self.block(text, rules)\n        self.tokens.reverse()\n\n        self.inline.setup(self.block.def_links, self.block.def_footnotes)\n\n        out = self.renderer.placeholder()\n        while self.pop():\n            out += self.tok()\n        return out\n\n    def tok(self):\n        t = self.token['type']\n\n        # sepcial cases\n        if t.endswith('_start'):\n            t = t[:-6]\n\n        return getattr(self, 'output_%s' % t)()\n\n    def tok_text(self):\n        text = self.token['text']\n        while self.peek()['type'] == 'text':\n            text += '\\n' + self.pop()['text']\n        return self.inline(text)\n\n    def output_newline(self):\n        return self.renderer.newline()\n\n    def output_hrule(self):\n        return self.renderer.hrule()\n\n    def output_heading(self):\n        return self.renderer.header(\n            self.inline(self.token['text']),\n            self.token['level'],\n            self.token['text'],\n        )\n\n    def output_code(self):\n        return self.renderer.block_code(\n            self.token['text'], self.token['lang']\n        )\n\n    def output_table(self):\n        aligns = self.token['align']\n        aligns_length = len(aligns)\n        cell = self.renderer.placeholder()\n\n        # header part\n        header = self.renderer.placeholder()\n        for i, value in enumerate(self.token['header']):\n            align = aligns[i] if i < aligns_length else None\n            flags = {'header': True, 'align': align}\n            cell += self.renderer.table_cell(self.inline(value), **flags)\n\n        header += self.renderer.table_row(cell)\n\n        # body part\n        body = self.renderer.placeholder()\n        for i, row in enumerate(self.token['cells']):\n            cell = self.renderer.placeholder()\n            for j, value in enumerate(row):\n                align = aligns[j] if j < aligns_length else None\n                flags = {'header': False, 'align': align}\n                cell += self.renderer.table_cell(self.inline(value), **flags)\n            body += self.renderer.table_row(cell)\n\n        return self.renderer.table(header, body)\n\n    def output_block_quote(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'block_quote_end':\n            body += self.tok()\n        return self.renderer.block_quote(body)\n\n    def output_list(self):\n        ordered = self.token['ordered']\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_end':\n            body += self.tok()\n        return self.renderer.list(body, ordered)\n\n    def output_list_item(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_item_end':\n            if self.token['type'] == 'text':\n                body += self.tok_text()\n            else:\n                body += self.tok()\n\n        return self.renderer.list_item(body)\n\n    def output_loose_item(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_item_end':\n            body += self.tok()\n        return self.renderer.list_item(body)\n\n    def output_footnote(self):\n        self.inline._in_footnote = True\n        body = self.renderer.placeholder()\n        key = self.token['key']\n        while self.pop()['type'] != 'footnote_end':\n            body += self.tok()\n        self.footnotes.append({'key': key, 'text': body})\n        self.inline._in_footnote = False\n        return self.renderer.placeholder()\n\n    def output_close_html(self):\n        text = self.token['text']\n        return self.renderer.block_html(text)\n\n    def output_open_html(self):\n        text = self.token['text']\n        tag = self.token['tag']\n        if self._parse_block_html and tag not in _pre_tags:\n            text = self.inline(text, rules=self.inline.inline_html_rules)\n        extra = self.token.get('extra') or ''\n        html = '<%s%s>%s</%s>' % (tag, extra, text, tag)\n        return self.renderer.block_html(html)\n\n    def output_paragraph(self):\n        return self.renderer.paragraph(self.inline(self.token['text']))\n\n    def output_text(self):\n        return self.renderer.paragraph(self.tok_text())\n\n\ndef markdown(text, escape=True, **kwargs):\n    \"\"\"Render markdown formatted text to html.\n\n    :param text: markdown formatted text content.\n    :param escape: if set to False, all html tags will not be escaped.\n    :param use_xhtml: output with xhtml tags.\n    :param hard_wrap: if set to True, it will use the GFM line breaks feature.\n    :param parse_block_html: parse text only in block level html.\n    :param parse_inline_html: parse text only in inline level html.\n    \"\"\"\n    return Markdown(escape=escape, **kwargs)(text)\n"], "fixing_code": ["# coding: utf-8\n\"\"\"\n    mistune\n    ~~~~~~~\n\n    The fastest markdown parser in pure Python with renderer feature.\n\n    :copyright: (c) 2014 - 2017 by Hsiaoming Yang.\n\"\"\"\n\nimport re\nimport inspect\n\n__version__ = '0.8.1'\n__author__ = 'Hsiaoming Yang <me@lepture.com>'\n__all__ = [\n    'BlockGrammar', 'BlockLexer',\n    'InlineGrammar', 'InlineLexer',\n    'Renderer', 'Markdown',\n    'markdown', 'escape',\n]\n\n\n_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\=(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\n\n\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\n\n\ndef _keyify(key):\n    key = escape(key.lower(), quote=True)\n    return _key_pattern.sub(' ', key)\n\n\ndef escape(text, quote=False, smart_amp=True):\n    \"\"\"Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\n\n    The original cgi.escape will always escape \"&\", but you can control\n    this one for a smart escape amp.\n\n    :param quote: if set to True, \" and ' will be escaped.\n    :param smart_amp: if set to False, & will always be escaped.\n    \"\"\"\n    if smart_amp:\n        text = _escape_pattern.sub('&amp;', text)\n    else:\n        text = text.replace('&', '&amp;')\n    text = text.replace('<', '&lt;')\n    text = text.replace('>', '&gt;')\n    if quote:\n        text = text.replace('\"', '&quot;')\n        text = text.replace(\"'\", '&#39;')\n    return text\n\n\ndef escape_link(url):\n    \"\"\"Remove dangerous URL schemes like javascript: and escape afterwards.\"\"\"\n    lower_url = url.lower().strip('\\x00\\x1a \\n\\r\\t')\n\n    for scheme in _scheme_blacklist:\n        if re.sub(r'[^A-Za-z0-9\\/:]+', '', lower_url).startswith(scheme):\n            return ''\n    return escape(url, quote=True, smart_amp=False)\n\n\ndef preprocessing(text, tab=4):\n    text = _newline_pattern.sub('\\n', text)\n    text = text.expandtabs(tab)\n    text = text.replace('\\u2424', '\\n')\n    pattern = re.compile(r'^ +$', re.M)\n    return pattern.sub('', text)\n\n\nclass BlockGrammar(object):\n    \"\"\"Grammars for block level tokens.\"\"\"\n\n    def_links = re.compile(\n        r'^ *\\[([^^\\]]+)\\]: *'  # [key]:\n        r'<?([^\\s>]+)>?'  # <link> or link\n        r'(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)'\n    )\n    def_footnotes = re.compile(\n        r'^\\[\\^([^\\]]+)\\]: *('\n        r'[^\\n]*(?:\\n+|$)'  # [^key]:\n        r'(?: {1,}[^\\n]*(?:\\n+|$))*'\n        r')'\n    )\n\n    newline = re.compile(r'^\\n+')\n    block_code = re.compile(r'^( {4}[^\\n]+\\n*)+')\n    fences = re.compile(\n        r'^ *(`{3,}|~{3,}) *(\\S+)? *\\n'  # ```lang\n        r'([\\s\\S]+?)\\s*'\n        r'\\1 *(?:\\n+|$)'  # ```\n    )\n    hrule = re.compile(r'^ {0,3}[-*_](?: *[-*_]){2,} *(?:\\n+|$)')\n    heading = re.compile(r'^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)')\n    lheading = re.compile(r'^([^\\n]+)\\n *(=|-)+ *(?:\\n+|$)')\n    block_quote = re.compile(r'^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+')\n    list_block = re.compile(\n        r'^( *)([*+-]|\\d+\\.) [\\s\\S]+?'\n        r'(?:'\n        r'\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))'  # hrule\n        r'|\\n+(?=%s)'  # def links\n        r'|\\n+(?=%s)'  # def footnotes\n        r'|\\n{2,}'\n        r'(?! )'\n        r'(?!\\1(?:[*+-]|\\d+\\.) )\\n*'\n        r'|'\n        r'\\s*$)' % (\n            _pure_pattern(def_links),\n            _pure_pattern(def_footnotes),\n        )\n    )\n    list_item = re.compile(\n        r'^(( *)(?:[*+-]|\\d+\\.) [^\\n]*'\n        r'(?:\\n(?!\\2(?:[*+-]|\\d+\\.) )[^\\n]*)*)',\n        flags=re.M\n    )\n    list_bullet = re.compile(r'^ *(?:[*+-]|\\d+\\.) +')\n    paragraph = re.compile(\n        r'^((?:[^\\n]+\\n?(?!'\n        r'%s|%s|%s|%s|%s|%s|%s|%s|%s'\n        r'))+)\\n*' % (\n            _pure_pattern(fences).replace(r'\\1', r'\\2'),\n            _pure_pattern(list_block).replace(r'\\1', r'\\3'),\n            _pure_pattern(hrule),\n            _pure_pattern(heading),\n            _pure_pattern(lheading),\n            _pure_pattern(block_quote),\n            _pure_pattern(def_links),\n            _pure_pattern(def_footnotes),\n            '<' + _block_tag,\n        )\n    )\n    block_html = re.compile(\n        r'^ *(?:%s|%s|%s) *(?:\\n{2,}|\\s*$)' % (\n            r'<!--[\\s\\S]*?-->',\n            r'<(%s)((?:%s)*?)>([\\s\\S]*?)<\\/\\1>' % (_block_tag, _valid_attr),\n            r'<%s(?:%s)*?\\s*\\/?>' % (_block_tag, _valid_attr),\n        )\n    )\n    table = re.compile(\n        r'^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*'\n    )\n    nptable = re.compile(\n        r'^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*'\n    )\n    text = re.compile(r'^[^\\n]+')\n\n\nclass BlockLexer(object):\n    \"\"\"Block level lexer for block grammars.\"\"\"\n    grammar_class = BlockGrammar\n\n    default_rules = [\n        'newline', 'hrule', 'block_code', 'fences', 'heading',\n        'nptable', 'lheading', 'block_quote',\n        'list_block', 'block_html', 'def_links',\n        'def_footnotes', 'table', 'paragraph', 'text'\n    ]\n\n    list_rules = (\n        'newline', 'block_code', 'fences', 'lheading', 'hrule',\n        'block_quote', 'list_block', 'block_html', 'text',\n    )\n\n    footnote_rules = (\n        'newline', 'block_code', 'fences', 'heading',\n        'nptable', 'lheading', 'hrule', 'block_quote',\n        'list_block', 'block_html', 'table', 'paragraph', 'text'\n    )\n\n    def __init__(self, rules=None, **kwargs):\n        self.tokens = []\n        self.def_links = {}\n        self.def_footnotes = {}\n\n        if not rules:\n            rules = self.grammar_class()\n\n        self.rules = rules\n\n    def __call__(self, text, rules=None):\n        return self.parse(text, rules)\n\n    def parse(self, text, rules=None):\n        text = text.rstrip('\\n')\n\n        if not rules:\n            rules = self.default_rules\n\n        def manipulate(text):\n            for key in rules:\n                rule = getattr(self.rules, key)\n                m = rule.match(text)\n                if not m:\n                    continue\n                getattr(self, 'parse_%s' % key)(m)\n                return m\n            return False  # pragma: no cover\n\n        while text:\n            m = manipulate(text)\n            if m is not False:\n                text = text[len(m.group(0)):]\n                continue\n            if text:  # pragma: no cover\n                raise RuntimeError('Infinite loop at: %s' % text)\n        return self.tokens\n\n    def parse_newline(self, m):\n        length = len(m.group(0))\n        if length > 1:\n            self.tokens.append({'type': 'newline'})\n\n    def parse_block_code(self, m):\n        # clean leading whitespace\n        code = _block_code_leading_pattern.sub('', m.group(0))\n        self.tokens.append({\n            'type': 'code',\n            'lang': None,\n            'text': code,\n        })\n\n    def parse_fences(self, m):\n        self.tokens.append({\n            'type': 'code',\n            'lang': m.group(2),\n            'text': m.group(3),\n        })\n\n    def parse_heading(self, m):\n        self.tokens.append({\n            'type': 'heading',\n            'level': len(m.group(1)),\n            'text': m.group(2),\n        })\n\n    def parse_lheading(self, m):\n        \"\"\"Parse setext heading.\"\"\"\n        self.tokens.append({\n            'type': 'heading',\n            'level': 1 if m.group(2) == '=' else 2,\n            'text': m.group(1),\n        })\n\n    def parse_hrule(self, m):\n        self.tokens.append({'type': 'hrule'})\n\n    def parse_list_block(self, m):\n        bull = m.group(2)\n        self.tokens.append({\n            'type': 'list_start',\n            'ordered': '.' in bull,\n        })\n        cap = m.group(0)\n        self._process_list_item(cap, bull)\n        self.tokens.append({'type': 'list_end'})\n\n    def _process_list_item(self, cap, bull):\n        cap = self.rules.list_item.findall(cap)\n\n        _next = False\n        length = len(cap)\n\n        for i in range(length):\n            item = cap[i][0]\n\n            # remove the bullet\n            space = len(item)\n            item = self.rules.list_bullet.sub('', item)\n\n            # outdent\n            if '\\n ' in item:\n                space = space - len(item)\n                pattern = re.compile(r'^ {1,%d}' % space, flags=re.M)\n                item = pattern.sub('', item)\n\n            # determine whether item is loose or not\n            loose = _next\n            if not loose and re.search(r'\\n\\n(?!\\s*$)', item):\n                loose = True\n\n            rest = len(item)\n            if i != length - 1 and rest:\n                _next = item[rest-1] == '\\n'\n                if not loose:\n                    loose = _next\n\n            if loose:\n                t = 'loose_item_start'\n            else:\n                t = 'list_item_start'\n\n            self.tokens.append({'type': t})\n            # recurse\n            self.parse(item, self.list_rules)\n            self.tokens.append({'type': 'list_item_end'})\n\n    def parse_block_quote(self, m):\n        self.tokens.append({'type': 'block_quote_start'})\n        # clean leading >\n        cap = _block_quote_leading_pattern.sub('', m.group(0))\n        self.parse(cap)\n        self.tokens.append({'type': 'block_quote_end'})\n\n    def parse_def_links(self, m):\n        key = _keyify(m.group(1))\n        self.def_links[key] = {\n            'link': m.group(2),\n            'title': m.group(3),\n        }\n\n    def parse_def_footnotes(self, m):\n        key = _keyify(m.group(1))\n        if key in self.def_footnotes:\n            # footnote is already defined\n            return\n\n        self.def_footnotes[key] = 0\n\n        self.tokens.append({\n            'type': 'footnote_start',\n            'key': key,\n        })\n\n        text = m.group(2)\n\n        if '\\n' in text:\n            lines = text.split('\\n')\n            whitespace = None\n            for line in lines[1:]:\n                space = len(line) - len(line.lstrip())\n                if space and (not whitespace or space < whitespace):\n                    whitespace = space\n            newlines = [lines[0]]\n            for line in lines[1:]:\n                newlines.append(line[whitespace:])\n            text = '\\n'.join(newlines)\n\n        self.parse(text, self.footnote_rules)\n\n        self.tokens.append({\n            'type': 'footnote_end',\n            'key': key,\n        })\n\n    def parse_table(self, m):\n        item = self._process_table(m)\n\n        cells = re.sub(r'(?: *\\| *)?\\n$', '', m.group(3))\n        cells = cells.split('\\n')\n        for i, v in enumerate(cells):\n            v = re.sub(r'^ *\\| *| *\\| *$', '', v)\n            cells[i] = re.split(r' *\\| *', v)\n\n        item['cells'] = cells\n        self.tokens.append(item)\n\n    def parse_nptable(self, m):\n        item = self._process_table(m)\n\n        cells = re.sub(r'\\n$', '', m.group(3))\n        cells = cells.split('\\n')\n        for i, v in enumerate(cells):\n            cells[i] = re.split(r' *\\| *', v)\n\n        item['cells'] = cells\n        self.tokens.append(item)\n\n    def _process_table(self, m):\n        header = re.sub(r'^ *| *\\| *$', '', m.group(1))\n        header = re.split(r' *\\| *', header)\n        align = re.sub(r' *|\\| *$', '', m.group(2))\n        align = re.split(r' *\\| *', align)\n\n        for i, v in enumerate(align):\n            if re.search(r'^ *-+: *$', v):\n                align[i] = 'right'\n            elif re.search(r'^ *:-+: *$', v):\n                align[i] = 'center'\n            elif re.search(r'^ *:-+ *$', v):\n                align[i] = 'left'\n            else:\n                align[i] = None\n\n        item = {\n            'type': 'table',\n            'header': header,\n            'align': align,\n        }\n        return item\n\n    def parse_block_html(self, m):\n        tag = m.group(1)\n        if not tag:\n            text = m.group(0)\n            self.tokens.append({\n                'type': 'close_html',\n                'text': text\n            })\n        else:\n            attr = m.group(2)\n            text = m.group(3)\n            self.tokens.append({\n                'type': 'open_html',\n                'tag': tag,\n                'extra': attr,\n                'text': text\n            })\n\n    def parse_paragraph(self, m):\n        text = m.group(1).rstrip('\\n')\n        self.tokens.append({'type': 'paragraph', 'text': text})\n\n    def parse_text(self, m):\n        text = m.group(0)\n        self.tokens.append({'type': 'text', 'text': text})\n\n\nclass InlineGrammar(object):\n    \"\"\"Grammars for inline level tokens.\"\"\"\n\n    escape = re.compile(r'^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>~|])')  # \\* \\+ \\! ....\n    inline_html = re.compile(\n        r'^(?:%s|%s|%s)' % (\n            r'<!--[\\s\\S]*?-->',\n            r'<(\\w+%s)((?:%s)*?)\\s*>([\\s\\S]*?)<\\/\\1>' % (\n                _valid_end, _valid_attr),\n            r'<\\w+%s(?:%s)*?\\s*\\/?>' % (_valid_end, _valid_attr),\n        )\n    )\n    autolink = re.compile(r'^<([^ >]+(@|:)[^ >]+)>')\n    link = re.compile(\n        r'^!?\\[('\n        r'(?:\\[[^^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*'\n        r')\\]\\('\n        r'''\\s*(<)?([\\s\\S]*?)(?(2)>)(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*'''\n        r'\\)'\n    )\n    reflink = re.compile(\n        r'^!?\\[('\n        r'(?:\\[[^^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*'\n        r')\\]\\s*\\[([^^\\]]*)\\]'\n    )\n    nolink = re.compile(r'^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]')\n    url = re.compile(r'''^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])''')\n    double_emphasis = re.compile(\n        r'^_{2}([\\s\\S]+?)_{2}(?!_)'  # __word__\n        r'|'\n        r'^\\*{2}([\\s\\S]+?)\\*{2}(?!\\*)'  # **word**\n    )\n    emphasis = re.compile(\n        r'^\\b_((?:__|[^_])+?)_\\b'  # _word_\n        r'|'\n        r'^\\*((?:\\*\\*|[^\\*])+?)\\*(?!\\*)'  # *word*\n    )\n    code = re.compile(r'^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)')  # `code`\n    linebreak = re.compile(r'^ {2,}\\n(?!\\s*$)')\n    strikethrough = re.compile(r'^~~(?=\\S)([\\s\\S]*?\\S)~~')  # ~~word~~\n    footnote = re.compile(r'^\\[\\^([^\\]]+)\\]')\n    text = re.compile(r'^[\\s\\S]+?(?=[\\\\<!\\[_*`~]|https?://| {2,}\\n|$)')\n\n    def hard_wrap(self):\n        \"\"\"Grammar for hard wrap linebreak. You don't need to add two\n        spaces at the end of a line.\n        \"\"\"\n        self.linebreak = re.compile(r'^ *\\n(?!\\s*$)')\n        self.text = re.compile(\n            r'^[\\s\\S]+?(?=[\\\\<!\\[_*`~]|https?://| *\\n|$)'\n        )\n\n\nclass InlineLexer(object):\n    \"\"\"Inline level lexer for inline grammars.\"\"\"\n    grammar_class = InlineGrammar\n\n    default_rules = [\n        'escape', 'inline_html', 'autolink', 'url',\n        'footnote', 'link', 'reflink', 'nolink',\n        'double_emphasis', 'emphasis', 'code',\n        'linebreak', 'strikethrough', 'text',\n    ]\n    inline_html_rules = [\n        'escape', 'autolink', 'url', 'link', 'reflink',\n        'nolink', 'double_emphasis', 'emphasis', 'code',\n        'linebreak', 'strikethrough', 'text',\n    ]\n\n    def __init__(self, renderer, rules=None, **kwargs):\n        self.renderer = renderer\n        self.links = {}\n        self.footnotes = {}\n        self.footnote_index = 0\n\n        if not rules:\n            rules = self.grammar_class()\n\n        kwargs.update(self.renderer.options)\n        if kwargs.get('hard_wrap'):\n            rules.hard_wrap()\n\n        self.rules = rules\n\n        self._in_link = False\n        self._in_footnote = False\n        self._parse_inline_html = kwargs.get('parse_inline_html')\n\n    def __call__(self, text, rules=None):\n        return self.output(text, rules)\n\n    def setup(self, links, footnotes):\n        self.footnote_index = 0\n        self.links = links or {}\n        self.footnotes = footnotes or {}\n\n    def output(self, text, rules=None):\n        text = text.rstrip('\\n')\n        if not rules:\n            rules = list(self.default_rules)\n\n        if self._in_footnote and 'footnote' in rules:\n            rules.remove('footnote')\n\n        output = self.renderer.placeholder()\n\n        def manipulate(text):\n            for key in rules:\n                pattern = getattr(self.rules, key)\n                m = pattern.match(text)\n                if not m:\n                    continue\n                self.line_match = m\n                out = getattr(self, 'output_%s' % key)(m)\n                if out is not None:\n                    return m, out\n            return False  # pragma: no cover\n\n        while text:\n            ret = manipulate(text)\n            if ret is not False:\n                m, out = ret\n                output += out\n                text = text[len(m.group(0)):]\n                continue\n            if text:  # pragma: no cover\n                raise RuntimeError('Infinite loop at: %s' % text)\n\n        return output\n\n    def output_escape(self, m):\n        text = m.group(1)\n        return self.renderer.escape(text)\n\n    def output_autolink(self, m):\n        link = m.group(1)\n        if m.group(2) == '@':\n            is_email = True\n        else:\n            is_email = False\n        return self.renderer.autolink(link, is_email)\n\n    def output_url(self, m):\n        link = m.group(1)\n        if self._in_link:\n            return self.renderer.text(link)\n        return self.renderer.autolink(link, False)\n\n    def output_inline_html(self, m):\n        tag = m.group(1)\n        if self._parse_inline_html and tag in _inline_tags:\n            text = m.group(3)\n            if tag == 'a':\n                self._in_link = True\n                text = self.output(text, rules=self.inline_html_rules)\n                self._in_link = False\n            else:\n                text = self.output(text, rules=self.inline_html_rules)\n            extra = m.group(2) or ''\n            html = '<%s%s>%s</%s>' % (tag, extra, text, tag)\n        else:\n            html = m.group(0)\n        return self.renderer.inline_html(html)\n\n    def output_footnote(self, m):\n        key = _keyify(m.group(1))\n        if key not in self.footnotes:\n            return None\n        if self.footnotes[key]:\n            return None\n        self.footnote_index += 1\n        self.footnotes[key] = self.footnote_index\n        return self.renderer.footnote_ref(key, self.footnote_index)\n\n    def output_link(self, m):\n        return self._process_link(m, m.group(3), m.group(4))\n\n    def output_reflink(self, m):\n        key = _keyify(m.group(2) or m.group(1))\n        if key not in self.links:\n            return None\n        ret = self.links[key]\n        return self._process_link(m, ret['link'], ret['title'])\n\n    def output_nolink(self, m):\n        key = _keyify(m.group(1))\n        if key not in self.links:\n            return None\n        ret = self.links[key]\n        return self._process_link(m, ret['link'], ret['title'])\n\n    def _process_link(self, m, link, title=None):\n        line = m.group(0)\n        text = m.group(1)\n        if line[0] == '!':\n            return self.renderer.image(link, title, text)\n\n        self._in_link = True\n        text = self.output(text)\n        self._in_link = False\n        return self.renderer.link(link, title, text)\n\n    def output_double_emphasis(self, m):\n        text = m.group(2) or m.group(1)\n        text = self.output(text)\n        return self.renderer.double_emphasis(text)\n\n    def output_emphasis(self, m):\n        text = m.group(2) or m.group(1)\n        text = self.output(text)\n        return self.renderer.emphasis(text)\n\n    def output_code(self, m):\n        text = m.group(2)\n        return self.renderer.codespan(text)\n\n    def output_linebreak(self, m):\n        return self.renderer.linebreak()\n\n    def output_strikethrough(self, m):\n        text = self.output(m.group(1))\n        return self.renderer.strikethrough(text)\n\n    def output_text(self, m):\n        text = m.group(0)\n        return self.renderer.text(text)\n\n\nclass Renderer(object):\n    \"\"\"The default HTML renderer for rendering Markdown.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.options = kwargs\n\n    def placeholder(self):\n        \"\"\"Returns the default, empty output value for the renderer.\n\n        All renderer methods use the '+=' operator to append to this value.\n        Default is a string so rendering HTML can build up a result string with\n        the rendered Markdown.\n\n        Can be overridden by Renderer subclasses to be types like an empty\n        list, allowing the renderer to create a tree-like structure to\n        represent the document (which can then be reprocessed later into a\n        separate format like docx or pdf).\n        \"\"\"\n        return ''\n\n    def block_code(self, code, lang=None):\n        \"\"\"Rendering block level code. ``pre > code``.\n\n        :param code: text content of the code block.\n        :param lang: language of the given code.\n        \"\"\"\n        code = code.rstrip('\\n')\n        if not lang:\n            code = escape(code, smart_amp=False)\n            return '<pre><code>%s\\n</code></pre>\\n' % code\n        code = escape(code, quote=True, smart_amp=False)\n        return '<pre><code class=\"lang-%s\">%s\\n</code></pre>\\n' % (lang, code)\n\n    def block_quote(self, text):\n        \"\"\"Rendering <blockquote> with the given text.\n\n        :param text: text content of the blockquote.\n        \"\"\"\n        return '<blockquote>%s\\n</blockquote>\\n' % text.rstrip('\\n')\n\n    def block_html(self, html):\n        \"\"\"Rendering block level pure html content.\n\n        :param html: text content of the html snippet.\n        \"\"\"\n        if self.options.get('skip_style') and \\\n           html.lower().startswith('<style'):\n            return ''\n        if self.options.get('escape'):\n            return escape(html)\n        return html\n\n    def header(self, text, level, raw=None):\n        \"\"\"Rendering header/heading tags like ``<h1>`` ``<h2>``.\n\n        :param text: rendered text content for the header.\n        :param level: a number for the header level, for example: 1.\n        :param raw: raw text content of the header.\n        \"\"\"\n        return '<h%d>%s</h%d>\\n' % (level, text, level)\n\n    def hrule(self):\n        \"\"\"Rendering method for ``<hr>`` tag.\"\"\"\n        if self.options.get('use_xhtml'):\n            return '<hr />\\n'\n        return '<hr>\\n'\n\n    def list(self, body, ordered=True):\n        \"\"\"Rendering list tags like ``<ul>`` and ``<ol>``.\n\n        :param body: body contents of the list.\n        :param ordered: whether this list is ordered or not.\n        \"\"\"\n        tag = 'ul'\n        if ordered:\n            tag = 'ol'\n        return '<%s>\\n%s</%s>\\n' % (tag, body, tag)\n\n    def list_item(self, text):\n        \"\"\"Rendering list item snippet. Like ``<li>``.\"\"\"\n        return '<li>%s</li>\\n' % text\n\n    def paragraph(self, text):\n        \"\"\"Rendering paragraph tags. Like ``<p>``.\"\"\"\n        return '<p>%s</p>\\n' % text.strip(' ')\n\n    def table(self, header, body):\n        \"\"\"Rendering table element. Wrap header and body in it.\n\n        :param header: header part of the table.\n        :param body: body part of the table.\n        \"\"\"\n        return (\n            '<table>\\n<thead>%s</thead>\\n'\n            '<tbody>\\n%s</tbody>\\n</table>\\n'\n        ) % (header, body)\n\n    def table_row(self, content):\n        \"\"\"Rendering a table row. Like ``<tr>``.\n\n        :param content: content of current table row.\n        \"\"\"\n        return '<tr>\\n%s</tr>\\n' % content\n\n    def table_cell(self, content, **flags):\n        \"\"\"Rendering a table cell. Like ``<th>`` ``<td>``.\n\n        :param content: content of current table cell.\n        :param header: whether this is header or not.\n        :param align: align of current table cell.\n        \"\"\"\n        if flags['header']:\n            tag = 'th'\n        else:\n            tag = 'td'\n        align = flags['align']\n        if not align:\n            return '<%s>%s</%s>\\n' % (tag, content, tag)\n        return '<%s style=\"text-align:%s\">%s</%s>\\n' % (\n            tag, align, content, tag\n        )\n\n    def double_emphasis(self, text):\n        \"\"\"Rendering **strong** text.\n\n        :param text: text content for emphasis.\n        \"\"\"\n        return '<strong>%s</strong>' % text\n\n    def emphasis(self, text):\n        \"\"\"Rendering *emphasis* text.\n\n        :param text: text content for emphasis.\n        \"\"\"\n        return '<em>%s</em>' % text\n\n    def codespan(self, text):\n        \"\"\"Rendering inline `code` text.\n\n        :param text: text content for inline code.\n        \"\"\"\n        text = escape(text.rstrip(), smart_amp=False)\n        return '<code>%s</code>' % text\n\n    def linebreak(self):\n        \"\"\"Rendering line break like ``<br>``.\"\"\"\n        if self.options.get('use_xhtml'):\n            return '<br />\\n'\n        return '<br>\\n'\n\n    def strikethrough(self, text):\n        \"\"\"Rendering ~~strikethrough~~ text.\n\n        :param text: text content for strikethrough.\n        \"\"\"\n        return '<del>%s</del>' % text\n\n    def text(self, text):\n        \"\"\"Rendering unformatted text.\n\n        :param text: text content.\n        \"\"\"\n        if self.options.get('parse_block_html'):\n            return text\n        return escape(text)\n\n    def escape(self, text):\n        \"\"\"Rendering escape sequence.\n\n        :param text: text content.\n        \"\"\"\n        return escape(text)\n\n    def autolink(self, link, is_email=False):\n        \"\"\"Rendering a given link or email address.\n\n        :param link: link content or email address.\n        :param is_email: whether this is an email or not.\n        \"\"\"\n        text = link = escape_link(link)\n        if is_email:\n            link = 'mailto:%s' % link\n        return '<a href=\"%s\">%s</a>' % (link, text)\n\n    def link(self, link, title, text):\n        \"\"\"Rendering a given link with content and title.\n\n        :param link: href link for ``<a>`` tag.\n        :param title: title content for `title` attribute.\n        :param text: text content for description.\n        \"\"\"\n        link = escape_link(link)\n        if not title:\n            return '<a href=\"%s\">%s</a>' % (link, text)\n        title = escape(title, quote=True)\n        return '<a href=\"%s\" title=\"%s\">%s</a>' % (link, title, text)\n\n    def image(self, src, title, text):\n        \"\"\"Rendering a image with title and text.\n\n        :param src: source link of the image.\n        :param title: title text of the image.\n        :param text: alt text of the image.\n        \"\"\"\n        src = escape_link(src)\n        text = escape(text, quote=True)\n        if title:\n            title = escape(title, quote=True)\n            html = '<img src=\"%s\" alt=\"%s\" title=\"%s\"' % (src, text, title)\n        else:\n            html = '<img src=\"%s\" alt=\"%s\"' % (src, text)\n        if self.options.get('use_xhtml'):\n            return '%s />' % html\n        return '%s>' % html\n\n    def inline_html(self, html):\n        \"\"\"Rendering span level pure html content.\n\n        :param html: text content of the html snippet.\n        \"\"\"\n        if self.options.get('escape'):\n            return escape(html)\n        return html\n\n    def newline(self):\n        \"\"\"Rendering newline element.\"\"\"\n        return ''\n\n    def footnote_ref(self, key, index):\n        \"\"\"Rendering the ref anchor of a footnote.\n\n        :param key: identity key for the footnote.\n        :param index: the index count of current footnote.\n        \"\"\"\n        html = (\n            '<sup class=\"footnote-ref\" id=\"fnref-%s\">'\n            '<a href=\"#fn-%s\">%d</a></sup>'\n        ) % (escape(key), escape(key), index)\n        return html\n\n    def footnote_item(self, key, text):\n        \"\"\"Rendering a footnote item.\n\n        :param key: identity key for the footnote.\n        :param text: text content of the footnote.\n        \"\"\"\n        back = (\n            '<a href=\"#fnref-%s\" class=\"footnote\">&#8617;</a>'\n        ) % escape(key)\n        text = text.rstrip()\n        if text.endswith('</p>'):\n            text = re.sub(r'<\\/p>$', r'%s</p>' % back, text)\n        else:\n            text = '%s<p>%s</p>' % (text, back)\n        html = '<li id=\"fn-%s\">%s</li>\\n' % (escape(key), text)\n        return html\n\n    def footnotes(self, text):\n        \"\"\"Wrapper for all footnotes.\n\n        :param text: contents of all footnotes.\n        \"\"\"\n        html = '<div class=\"footnotes\">\\n%s<ol>%s</ol>\\n</div>\\n'\n        return html % (self.hrule(), text)\n\n\nclass Markdown(object):\n    \"\"\"The Markdown parser.\n\n    :param renderer: An instance of ``Renderer``.\n    :param inline: An inline lexer class or instance.\n    :param block: A block lexer class or instance.\n    \"\"\"\n    def __init__(self, renderer=None, inline=None, block=None, **kwargs):\n        if not renderer:\n            renderer = Renderer(**kwargs)\n        else:\n            kwargs.update(renderer.options)\n\n        self.renderer = renderer\n\n        if inline and inspect.isclass(inline):\n            inline = inline(renderer, **kwargs)\n        if block and inspect.isclass(block):\n            block = block(**kwargs)\n\n        if inline:\n            self.inline = inline\n        else:\n            self.inline = InlineLexer(renderer, **kwargs)\n\n        self.block = block or BlockLexer(BlockGrammar())\n        self.footnotes = []\n        self.tokens = []\n\n        # detect if it should parse text in block html\n        self._parse_block_html = kwargs.get('parse_block_html')\n\n    def __call__(self, text):\n        return self.parse(text)\n\n    def render(self, text):\n        \"\"\"Render the Markdown text.\n\n        :param text: markdown formatted text content.\n        \"\"\"\n        return self.parse(text)\n\n    def parse(self, text):\n        out = self.output(preprocessing(text))\n\n        keys = self.block.def_footnotes\n\n        # reset block\n        self.block.def_links = {}\n        self.block.def_footnotes = {}\n\n        # reset inline\n        self.inline.links = {}\n        self.inline.footnotes = {}\n\n        if not self.footnotes:\n            return out\n\n        footnotes = filter(lambda o: keys.get(o['key']), self.footnotes)\n        self.footnotes = sorted(\n            footnotes, key=lambda o: keys.get(o['key']), reverse=True\n        )\n\n        body = self.renderer.placeholder()\n        while self.footnotes:\n            note = self.footnotes.pop()\n            body += self.renderer.footnote_item(\n                note['key'], note['text']\n            )\n\n        out += self.renderer.footnotes(body)\n        return out\n\n    def pop(self):\n        if not self.tokens:\n            return None\n        self.token = self.tokens.pop()\n        return self.token\n\n    def peek(self):\n        if self.tokens:\n            return self.tokens[-1]\n        return None  # pragma: no cover\n\n    def output(self, text, rules=None):\n        self.tokens = self.block(text, rules)\n        self.tokens.reverse()\n\n        self.inline.setup(self.block.def_links, self.block.def_footnotes)\n\n        out = self.renderer.placeholder()\n        while self.pop():\n            out += self.tok()\n        return out\n\n    def tok(self):\n        t = self.token['type']\n\n        # sepcial cases\n        if t.endswith('_start'):\n            t = t[:-6]\n\n        return getattr(self, 'output_%s' % t)()\n\n    def tok_text(self):\n        text = self.token['text']\n        while self.peek()['type'] == 'text':\n            text += '\\n' + self.pop()['text']\n        return self.inline(text)\n\n    def output_newline(self):\n        return self.renderer.newline()\n\n    def output_hrule(self):\n        return self.renderer.hrule()\n\n    def output_heading(self):\n        return self.renderer.header(\n            self.inline(self.token['text']),\n            self.token['level'],\n            self.token['text'],\n        )\n\n    def output_code(self):\n        return self.renderer.block_code(\n            self.token['text'], self.token['lang']\n        )\n\n    def output_table(self):\n        aligns = self.token['align']\n        aligns_length = len(aligns)\n        cell = self.renderer.placeholder()\n\n        # header part\n        header = self.renderer.placeholder()\n        for i, value in enumerate(self.token['header']):\n            align = aligns[i] if i < aligns_length else None\n            flags = {'header': True, 'align': align}\n            cell += self.renderer.table_cell(self.inline(value), **flags)\n\n        header += self.renderer.table_row(cell)\n\n        # body part\n        body = self.renderer.placeholder()\n        for i, row in enumerate(self.token['cells']):\n            cell = self.renderer.placeholder()\n            for j, value in enumerate(row):\n                align = aligns[j] if j < aligns_length else None\n                flags = {'header': False, 'align': align}\n                cell += self.renderer.table_cell(self.inline(value), **flags)\n            body += self.renderer.table_row(cell)\n\n        return self.renderer.table(header, body)\n\n    def output_block_quote(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'block_quote_end':\n            body += self.tok()\n        return self.renderer.block_quote(body)\n\n    def output_list(self):\n        ordered = self.token['ordered']\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_end':\n            body += self.tok()\n        return self.renderer.list(body, ordered)\n\n    def output_list_item(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_item_end':\n            if self.token['type'] == 'text':\n                body += self.tok_text()\n            else:\n                body += self.tok()\n\n        return self.renderer.list_item(body)\n\n    def output_loose_item(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_item_end':\n            body += self.tok()\n        return self.renderer.list_item(body)\n\n    def output_footnote(self):\n        self.inline._in_footnote = True\n        body = self.renderer.placeholder()\n        key = self.token['key']\n        while self.pop()['type'] != 'footnote_end':\n            body += self.tok()\n        self.footnotes.append({'key': key, 'text': body})\n        self.inline._in_footnote = False\n        return self.renderer.placeholder()\n\n    def output_close_html(self):\n        text = self.token['text']\n        return self.renderer.block_html(text)\n\n    def output_open_html(self):\n        text = self.token['text']\n        tag = self.token['tag']\n        if self._parse_block_html and tag not in _pre_tags:\n            text = self.inline(text, rules=self.inline.inline_html_rules)\n        extra = self.token.get('extra') or ''\n        html = '<%s%s>%s</%s>' % (tag, extra, text, tag)\n        return self.renderer.block_html(html)\n\n    def output_paragraph(self):\n        return self.renderer.paragraph(self.inline(self.token['text']))\n\n    def output_text(self):\n        return self.renderer.paragraph(self.tok_text())\n\n\ndef markdown(text, escape=True, **kwargs):\n    \"\"\"Render markdown formatted text to html.\n\n    :param text: markdown formatted text content.\n    :param escape: if set to False, all html tags will not be escaped.\n    :param use_xhtml: output with xhtml tags.\n    :param hard_wrap: if set to True, it will use the GFM line breaks feature.\n    :param parse_block_html: parse text only in block level html.\n    :param parse_inline_html: parse text only in inline level html.\n    \"\"\"\n    return Markdown(escape=escape, **kwargs)(text)\n"], "filenames": ["mistune.py"], "buggy_code_start_loc": [14], "buggy_code_end_loc": [449], "fixing_code_start_loc": [14], "fixing_code_end_loc": [451], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in the _keyify function in mistune.py in Mistune before 0.8.1 allows remote attackers to inject arbitrary web script or HTML by leveraging failure to escape the \"key\" argument.", "other": {"cve": {"id": "CVE-2017-16876", "sourceIdentifier": "cve@mitre.org", "published": "2017-12-29T15:29:00.610", "lastModified": "2018-01-10T17:15:51.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in the _keyify function in mistune.py in Mistune before 0.8.1 allows remote attackers to inject arbitrary web script or HTML by leveraging failure to escape the \"key\" argument."}, {"lang": "es", "value": "Vulnerabilidad de Cross-Site Scripting (XSS) en la funci\u00f3n _keyify en mistune.py en Mistune en versiones anteriores a la 0.8.1 permite que atacantes remotos inyecten scripts web o HTML aprovechando el error a la hora de escapar el argumento \"key\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mistune_project:mistune:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.1", "matchCriteriaId": "F6FBDFBB-71EA-4E0D-B014-CABC98A1FEDC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:26:*:*:*:*:*:*:*", "matchCriteriaId": "6E4D8269-B407-4C24-AAB0-02F885C7D752"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1524596", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/lepture/mistune/blob/master/CHANGES.rst", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/lepture/mistune/commit/5f06d724bc05580e7f203db2d4a4905fc1127f98", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NUR3GMHQBMA3UC4PFMCK6GCLOQC4LQQC/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lepture/mistune/commit/5f06d724bc05580e7f203db2d4a4905fc1127f98"}}