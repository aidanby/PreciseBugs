{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.FileTime;\nimport java.text.DateFormatSymbols;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.Vector;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.annotation.Priority;\nimport javax.inject.Provider;\nimport javax.mail.Message;\nimport javax.mail.Session;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport javax.naming.NamingException;\nimport javax.script.ScriptContext;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.httpclient.Credentials;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.URIException;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.util.URIUtil;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.hibernate.HibernateException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentCreatingEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentDeletingEvent;\nimport org.xwiki.bridge.event.DocumentRolledBackEvent;\nimport org.xwiki.bridge.event.DocumentRollingBackEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatingEvent;\nimport org.xwiki.bridge.event.WikiCopiedEvent;\nimport org.xwiki.bridge.event.WikiDeletedEvent;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.classloader.ClassLoaderManager;\nimport org.xwiki.component.event.ComponentDescriptorAddedEvent;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.manager.NamespacedComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.container.servlet.HttpServletUtils;\nimport org.xwiki.context.Execution;\nimport org.xwiki.edit.EditConfiguration;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.JobException;\nimport org.xwiki.job.JobExecutor;\nimport org.xwiki.job.annotation.Serializable;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.event.status.JobStatus.State;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.mail.MailListener;\nimport org.xwiki.mail.MailSender;\nimport org.xwiki.mail.MailSenderConfiguration;\nimport org.xwiki.mail.MailStatusResultSerializer;\nimport org.xwiki.mail.XWikiAuthenticator;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.PageReferenceResolver;\nimport org.xwiki.model.reference.RegexEntityReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.CancelableEvent;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.refactoring.batch.BatchOperationExecutor;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.MetadataBlockMatcher;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxContent;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.ResourceReference;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceReferenceResolver;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.ResourceTypeResolver;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.skin.Resource;\nimport org.xwiki.skin.Skin;\nimport org.xwiki.skin.SkinManager;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.url.ExtendedURL;\nimport org.xwiki.url.URLConfiguration;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserPropertiesResolver;\nimport org.xwiki.velocity.VelocityContextFactory;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.XWikiVelocityContext;\nimport org.xwiki.velocity.XWikiVelocityException;\nimport org.xwiki.wiki.descriptor.WikiDescriptor;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\nimport org.xwiki.wiki.manager.WikiManager;\nimport org.xwiki.wiki.manager.WikiManagerException;\nimport org.xwiki.xml.XMLUtils;\n\nimport com.xpn.xwiki.api.Api;\nimport com.xpn.xwiki.api.Document;\nimport com.xpn.xwiki.api.User;\nimport com.xpn.xwiki.criteria.api.XWikiCriteriaService;\nimport com.xpn.xwiki.doc.DeletedAttachment;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.MandatoryDocumentInitializer;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiAttachmentArchive;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.internal.WikiInitializerJob;\nimport com.xpn.xwiki.internal.WikiInitializerRequest;\nimport com.xpn.xwiki.internal.XWikiCfgConfigurationSource;\nimport com.xpn.xwiki.internal.XWikiConfigDelegate;\nimport com.xpn.xwiki.internal.XWikiInitializerJob;\nimport com.xpn.xwiki.internal.debug.DebugConfiguration;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializedEvent;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializingEvent;\nimport com.xpn.xwiki.internal.event.UserCreatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserDeletingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserUpdatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyAddedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyDeletedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyUpdatedEvent;\nimport com.xpn.xwiki.internal.mandatory.XWikiPreferencesDocumentInitializer;\nimport com.xpn.xwiki.internal.render.LinkedResourceHelper;\nimport com.xpn.xwiki.internal.render.OldRendering;\nimport com.xpn.xwiki.internal.render.groovy.ParseGroovyFromString;\nimport com.xpn.xwiki.internal.skin.InternalSkinConfiguration;\nimport com.xpn.xwiki.internal.skin.InternalSkinManager;\nimport com.xpn.xwiki.internal.skin.WikiSkin;\nimport com.xpn.xwiki.internal.skin.WikiSkinUtils;\nimport com.xpn.xwiki.internal.store.StoreConfiguration;\nimport com.xpn.xwiki.internal.store.hibernate.HibernateConfiguration;\nimport com.xpn.xwiki.internal.velocity.VelocityEvaluator;\nimport com.xpn.xwiki.job.JobRequestContext;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PasswordClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.plugin.XWikiPluginInterface;\nimport com.xpn.xwiki.plugin.XWikiPluginManager;\nimport com.xpn.xwiki.render.groovy.XWikiPageClassLoader;\nimport com.xpn.xwiki.stats.api.XWikiStatsService;\nimport com.xpn.xwiki.stats.impl.SearchEngineRule;\nimport com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl;\nimport com.xpn.xwiki.store.AttachmentRecycleBinStore;\nimport com.xpn.xwiki.store.AttachmentVersioningStore;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.store.XWikiCacheStoreInterface;\nimport com.xpn.xwiki.store.XWikiHibernateStore;\nimport com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiAuthService;\nimport com.xpn.xwiki.user.api.XWikiGroupService;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiRightServiceImpl;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.util.XWikiStubContextProvider;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiServletRequestStub;\nimport com.xpn.xwiki.web.XWikiURLFactory;\nimport com.xpn.xwiki.web.XWikiURLFactoryService;\nimport com.xpn.xwiki.web.XWikiURLFactoryServiceImpl;\nimport com.xpn.xwiki.web.includeservletasstring.IncludeServletAsString;\n\n@Serializable(false)\npublic class XWiki implements EventListener\n{\n    /** Name of the default wiki. */\n    public static final String DEFAULT_MAIN_WIKI = \"xwiki\";\n\n    /** Name of the default home space. */\n    public static final String DEFAULT_HOME_SPACE = \"Main\";\n\n    /** Name of the default system space. */\n    public static final String SYSTEM_SPACE = \"XWiki\";\n\n    /** Name of the default space homepage. */\n    public static final String DEFAULT_SPACE_HOMEPAGE = \"WebHome\";\n\n    public static final String CKEY_SKIN = InternalSkinManager.CKEY_SKIN;\n\n    public static final String CKEY_BASESKIN = InternalSkinManager.CKEY_PARENTSKIN;\n\n    public static final String DEFAULT_SKIN = InternalSkinConfiguration.DEFAULT_SKIN;\n\n    /**\n     * Query parameters used to control the browser cache version of a resource.\n     */\n    public static final String CACHE_VERSION = \"cache-version\";\n\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);\n\n    /** Frequently used Document reference, the class which holds virtual wiki definitions. */\n    private static final DocumentReference VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE =\n        new DocumentReference(DEFAULT_MAIN_WIKI, SYSTEM_SPACE, \"XWikiServerClass\");\n\n    /** The default encoding, and the internally used encoding when dealing with byte representation of strings. */\n    public static final String DEFAULT_ENCODING = \"UTF-8\";\n\n    /** Represents no value (ie the default value will be used) in xproperties */\n    private static final String NO_VALUE = \"---\";\n\n    /**\n     * List of top level space names that can be used in the fake context document created when accessing a resource\n     * with the 'skin' action.\n     */\n    private static final List<String> SKIN_RESOURCE_SPACE_NAMES = Arrays.asList(\"skins\", \"resources\");\n\n    /** The main document storage. */\n    private XWikiStoreInterface store;\n\n    /** The attachment content storage. */\n    private XWikiAttachmentStoreInterface defaultAttachmentContentStore;\n\n    /** The attachment archive storage. */\n    private AttachmentVersioningStore defaultAttachmentArchiveStore;\n\n    /** Document versioning storage. */\n    private XWikiVersioningStoreInterface versioningStore;\n\n    /** Deleted documents storage. */\n    private XWikiRecycleBinStoreInterface recycleBinStore;\n\n    private AttachmentRecycleBinStore attachmentRecycleBinStore;\n\n    private XWikiPluginManager pluginManager;\n\n    private XWikiAuthService authService;\n\n    private XWikiRightService rightService;\n\n    private XWikiGroupService groupService;\n\n    private XWikiStatsService statsService;\n\n    private XWikiURLFactoryService urlFactoryService;\n\n    private XWikiCriteriaService criteriaService;\n\n    /** Lock object used for the lazy initialization of the authentication service. */\n    private final Object AUTH_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the authorization service. */\n    private final Object RIGHT_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the group management service. */\n    private final Object GROUP_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the statistics service. */\n    private final Object STATS_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the URL Factory service. */\n    private final Object URLFACTORY_SERVICE_LOCK = new Object();\n\n    private MetaClass metaclass;\n\n    private String version;\n\n    private XWikiEngineContext engine_context;\n\n    private String database;\n\n    private String fullNameSQL;\n\n    /**\n     * The list of initialized wikis.\n     */\n    private Map<String, WikiInitializerJob> initializedWikis = new ConcurrentHashMap<>();\n\n    private boolean isReadOnly = false;\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#CFG_ENV_NAME} instead\n     */\n    @Deprecated\n    public static final String CFG_ENV_NAME = XWikiCfgConfigurationSource.CFG_ENV_NAME;\n\n    public static final String MACROS_FILE = \"/templates/macros.txt\";\n\n    /**\n     * File containing XWiki's version, in the format: <version name>.<SVN revision number>.\n     */\n    private static final String VERSION_FILE = \"/WEB-INF/version.properties\";\n\n    /**\n     * Property containing the version value in the {@link #VERSION_FILE} file.\n     */\n    private static final String VERSION_FILE_PROPERTY = \"version\";\n\n    private static XWikiInitializerJob job;\n\n    /** List of configured syntax ids. */\n    private List<String> configuredSyntaxes;\n\n    /** Used to convert a proper Document Reference to string (standard form). */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead.\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    private DocumentReferenceResolver<EntityReference> currentReferenceDocumentReferenceResolver;\n\n    private EntityReferenceResolver<String> currentMixedEntityReferenceResolver;\n\n    private EntityReferenceResolver<String> relativeEntityReferenceResolver;\n\n    private EntityReferenceSerializer<String> localStringEntityReferenceSerializer;\n\n    private ResourceReferenceManager resourceReferenceManager;\n\n    private JobExecutor jobExecutor;\n\n    private InternalSkinManager internalSkinManager;\n\n    private TemplateManager templateManager;\n\n    private RenderingContext renderingContext;\n\n    private VelocityEvaluator velocityEvaluator;\n\n    /**\n     * Whether backlinks are enabled or not (cached for performance).\n     *\n     * @since 3.2M2\n     */\n    private Boolean hasBacklinks;\n\n    private ConfigurationSource xwikicfg;\n\n    private ConfigurationSource wikiConfiguration;\n\n    private UserPropertiesResolver userPropertiesResolver;\n\n    private ConfigurationSource spaceConfiguration;\n\n    private EditConfiguration editConfiguration;\n\n    private URLConfiguration urlConfiguration;\n\n    private StoreConfiguration storeConfiguration;\n\n    private HibernateConfiguration hibernateConfiguration;\n\n    private ObservationManager observationManager;\n\n    private Provider<XWikiContext> xcontextProvider;\n\n    private ContextualLocalizationManager localization;\n\n    private Provider<OldRendering> oldRenderingProvider;\n\n    private ParseGroovyFromString parseGroovyFromString;\n\n    private JobProgressManager progress;\n\n    private Provider<DocumentReference> defaultDocumentReferenceProvider;\n\n    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;\n\n    private PageReferenceResolver<EntityReference> currentgetpageResolver;\n\n    private AttachmentReferenceResolver<EntityReference> currentAttachmentReferenceResolver;\n\n    private WikiSkinUtils wikiSkinUtils;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private VelocityContextFactory velocityContextFactory;\n\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    private AsyncContext asyncContext;\n\n    private ConfigurationSource getConfiguration()\n    {\n        if (this.xwikicfg == null) {\n            this.xwikicfg = Utils.getComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);\n        }\n\n        return this.xwikicfg;\n    }\n\n    private ConfigurationSource getWikiConfiguration()\n    {\n        if (this.wikiConfiguration == null) {\n            this.wikiConfiguration = Utils.getComponent(ConfigurationSource.class, \"wiki\");\n        }\n\n        return this.wikiConfiguration;\n    }\n\n    private ConfigurationSource getSpaceConfiguration()\n    {\n        if (this.spaceConfiguration == null) {\n            this.spaceConfiguration = Utils.getComponent(ConfigurationSource.class, \"space\");\n        }\n\n        return this.spaceConfiguration;\n    }\n\n    private UserPropertiesResolver getAllUserPropertiesResolver()\n    {\n        if (this.userPropertiesResolver == null) {\n            this.userPropertiesResolver = Utils.getComponent(UserPropertiesResolver.class, \"all\");\n        }\n\n        return this.userPropertiesResolver;\n    }\n\n    private EditConfiguration getEditConfiguration()\n    {\n        if (this.editConfiguration == null) {\n            this.editConfiguration = Utils.getComponent(EditConfiguration.class);\n        }\n\n        return this.editConfiguration;\n    }\n\n    private URLConfiguration getURLConfiguration()\n    {\n        if (this.urlConfiguration == null) {\n            this.urlConfiguration = Utils.getComponent(URLConfiguration.class);\n        }\n\n        return this.urlConfiguration;\n    }\n\n    private StoreConfiguration getStoreConfiguration()\n    {\n        if (this.storeConfiguration == null) {\n            this.storeConfiguration = Utils.getComponent(StoreConfiguration.class);\n        }\n\n        return this.storeConfiguration;\n    }\n\n    private HibernateConfiguration getHibernateConfiguration()\n    {\n        if (this.hibernateConfiguration == null) {\n            this.hibernateConfiguration = Utils.getComponent(HibernateConfiguration.class);\n        }\n\n        return this.hibernateConfiguration;\n    }\n\n    private InternalSkinManager getInternalSkinManager()\n    {\n        if (this.internalSkinManager == null) {\n            this.internalSkinManager = Utils.getComponent(InternalSkinManager.class);\n        }\n\n        return this.internalSkinManager;\n    }\n\n    private TemplateManager getTemplateManager()\n    {\n        if (this.templateManager == null) {\n            this.templateManager = Utils.getComponent(TemplateManager.class);\n        }\n\n        return this.templateManager;\n    }\n\n    private RenderingContext getRenderingContext()\n    {\n        if (this.renderingContext == null) {\n            this.renderingContext = Utils.getComponent(RenderingContext.class);\n        }\n\n        return this.renderingContext;\n    }\n\n    private MutableRenderingContext getMutableRenderingContext()\n    {\n        return getRenderingContext() instanceof MutableRenderingContext\n            ? (MutableRenderingContext) getRenderingContext() : null;\n    }\n\n    private VelocityEvaluator getVelocityEvaluator()\n    {\n        if (this.velocityEvaluator == null) {\n            this.velocityEvaluator = Utils.getComponent(VelocityEvaluator.class);\n        }\n\n        return this.velocityEvaluator;\n    }\n\n    private ObservationManager getObservationManager()\n    {\n        if (this.observationManager == null) {\n            this.observationManager = Utils.getComponent(ObservationManager.class);\n        }\n\n        return this.observationManager;\n    }\n\n    private XWikiContext getXWikiContext()\n    {\n        if (this.xcontextProvider == null) {\n            this.xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);\n        }\n\n        return this.xcontextProvider.get();\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private OldRendering getOldRendering()\n    {\n        if (this.oldRenderingProvider == null) {\n            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);\n        }\n\n        return this.oldRenderingProvider.get();\n    }\n\n    private ParseGroovyFromString getParseGroovyFromString()\n    {\n        if (this.parseGroovyFromString == null) {\n            this.parseGroovyFromString = Utils.getComponent(ParseGroovyFromString.class);\n        }\n\n        return this.parseGroovyFromString;\n    }\n\n    private JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    private Provider<DocumentReference> getDefaultDocumentReferenceProvider()\n    {\n        if (this.defaultDocumentReferenceProvider == null) {\n            this.defaultDocumentReferenceProvider = Utils.getComponent(DocumentReference.TYPE_PROVIDER);\n        }\n\n        return this.defaultDocumentReferenceProvider;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentGetDocumentResolver()\n    {\n        if (this.currentgetdocumentResolver == null) {\n            this.currentgetdocumentResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");\n        }\n\n        return this.currentgetdocumentResolver;\n    }\n\n    private PageReferenceResolver<EntityReference> getCurrentGetPageResolver()\n    {\n        if (this.currentgetpageResolver == null) {\n            this.currentgetpageResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE, \"currentgetpage\");\n        }\n\n        return this.currentgetpageResolver;\n    }\n\n    private AttachmentReferenceResolver<EntityReference> getCurrentAttachmentResolver()\n    {\n        if (this.currentAttachmentReferenceResolver == null) {\n            this.currentAttachmentReferenceResolver =\n                Utils.getComponent(AttachmentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentAttachmentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()\n    {\n        if (this.currentReferenceDocumentReferenceResolver == null) {\n            this.currentReferenceDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentReferenceDocumentReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getCurrentMixedEntityReferenceResolver()\n    {\n        if (this.currentMixedEntityReferenceResolver == null) {\n            this.currentMixedEntityReferenceResolver =\n                Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedEntityReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getRelativeEntityReferenceResolver()\n    {\n        if (this.relativeEntityReferenceResolver == null) {\n            this.relativeEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");\n        }\n\n        return this.relativeEntityReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getLocalStringEntityReferenceSerializer()\n    {\n        if (this.localStringEntityReferenceSerializer == null) {\n            this.localStringEntityReferenceSerializer =\n                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n\n        return this.localStringEntityReferenceSerializer;\n    }\n\n    private ResourceReferenceManager getResourceReferenceManager()\n    {\n        if (this.resourceReferenceManager == null) {\n            this.resourceReferenceManager = Utils.getComponent(ResourceReferenceManager.class);\n        }\n\n        return this.resourceReferenceManager;\n    }\n\n    private JobExecutor getJobExecutor()\n    {\n        if (this.jobExecutor == null) {\n            this.jobExecutor = Utils.getComponent(JobExecutor.class);\n        }\n\n        return this.jobExecutor;\n    }\n\n    private DocumentReference getDefaultDocumentReference()\n    {\n        return getDefaultDocumentReferenceProvider().get();\n    }\n\n    private WikiSkinUtils getWikiSkinUtils()\n    {\n        if (this.wikiSkinUtils == null) {\n            this.wikiSkinUtils = Utils.getComponent(WikiSkinUtils.class);\n        }\n\n        return this.wikiSkinUtils;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    private VelocityContextFactory getVelocityContextFactory()\n    {\n        if (this.velocityContextFactory == null) {\n            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);\n        }\n\n        return this.velocityContextFactory;\n    }\n\n    private WikiDescriptorManager getWikiDescriptorManager()\n    {\n        if (this.wikiDescriptorManager == null) {\n            this.wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        }\n\n        return this.wikiDescriptorManager;\n    }\n\n    private AsyncContext getAsyncContext()\n    {\n        if (this.asyncContext == null) {\n            this.asyncContext = Utils.getComponent(AsyncContext.class);\n        }\n\n        return this.asyncContext;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(XWikiContext context) throws XWikiException\n    {\n        return getMainXWiki(true, context);\n    }\n\n    /**\n     * @param wait true if the method should way for {@link XWiki} instance to be initialized\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(boolean wait, XWikiContext context) throws XWikiException\n    {\n        String xwikiname = DEFAULT_MAIN_WIKI;\n\n        context.setMainXWiki(xwikiname);\n\n        XWiki xwiki;\n\n        try {\n            XWikiEngineContext econtext = context.getEngineContext();\n\n            xwiki = (XWiki) econtext.getAttribute(xwikiname);\n            if (xwiki == null) {\n                // Start XWiki initialization\n                synchronized (XWiki.class) {\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                    if (xwiki == null && job == null) {\n                        job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);\n\n                        if (job.getStatus() == null) {\n                            // \"Pre-initialize\" XWikiStubContextProvider so that XWiki initializer can find one\n                            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class)\n                                .initialize(context);\n\n                            job.startAsync();\n                        }\n                    }\n                }\n\n                // Wait until XWiki is initialized\n                if (wait) {\n                    job.join();\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                }\n            }\n\n            context.setWiki(xwiki);\n\n            return xwiki;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                \"Could not initialize main XWiki instance\", e);\n        }\n    }\n\n    public static boolean isInitializing(XWikiContext xcontext)\n    {\n        return Boolean.TRUE.equals(xcontext.getEngineContext().getAttribute(\"xwiki.init\"));\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     *\n     * @param context see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(XWikiContext context) throws XWikiException\n    {\n        return getXWiki(true, context);\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     * <p>\n     * Unless <code>wait</code> is false the method return right away null if XWiki is not yet initialized.\n     *\n     * @param wait wait until XWiki is initialized\n     * @param xcontext see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        XWiki xwiki = getMainXWiki(wait, xcontext);\n\n        if (xwiki == null) {\n            return null;\n        }\n\n        // Extract Entity Resource from URL and put it in the Execution Context\n        EntityResourceReference entityResourceReference = initializeResourceFromURL(xcontext);\n\n        // If not an entity resource reference assume main wiki\n        if (entityResourceReference == null) {\n            return xwiki;\n        }\n\n        // Get the wiki id\n        String wikiId = entityResourceReference.getEntityReference().extractReference(EntityType.WIKI).getName();\n        if (wikiId.equals(xcontext.getMainXWiki())) {\n            // The main wiki was requested.\n            return xwiki;\n        }\n\n        // Check if the wiki exists by checking if a descriptor exists for the wiki id.\n        WikiDescriptorManager wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        WikiDescriptor descriptor;\n        try {\n            descriptor = wikiDescriptorManager.getById(wikiId);\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_STORE_MISC,\n                String.format(\"Failed find wiki descriptor for wiki id [%s]\", wikiId), e);\n        }\n        if (descriptor == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                String.format(\"The wiki [%s] does not exist\", wikiId));\n        }\n\n        // Initialize wiki\n\n        xcontext.setWikiId(wikiId);\n        xcontext.setOriginalWikiId(wikiId);\n\n        if (!xwiki.initializeWiki(wikiId, wait, xcontext)) {\n            // The wiki is still initializing\n            return null;\n        }\n\n        return xwiki;\n    }\n\n    /**\n     * @param wikiId the identifier of the wiki\n     * @return the current {@link WikiInitializerJob} associated to the passed wiki or null if there is none\n     */\n    public Job getWikiInitializerJob(String wikiId)\n    {\n        return this.initializedWikis.get(wikiId);\n    }\n\n    /**\n     * Make sure the wiki is initializing or wait for it.\n     * \n     * @param wikiId the identifier of the wiki to initialize\n     * @param wait true if the method should return only when the wiki is fully initialized\n     * @return true if the wiki is fully initialized\n     * @param xcontext the XWiki context\n     * @throws XWikiException when the initialization failed\n     * @since 8.4RC1\n     */\n    public boolean initializeWiki(String wikiId, boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        Job wikiJob = this.initializedWikis.get(wikiId);\n\n        // Create and start the job if it does not exist\n        if (wikiJob == null) {\n            try {\n                wikiJob = initializeWiki(wikiId, xcontext);\n            } catch (JobException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Could not start [\" + wikiId + \"] wiki initialization\", e);\n            }\n        }\n\n        // Check if the job is done\n        if (wikiJob.getStatus().getState() == State.FINISHED) {\n            return true;\n        }\n\n        // Wait until the job is finished if asked to\n        if (wait) {\n            try {\n                wikiJob.join();\n            } catch (InterruptedException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization was interrupted unexpectedly\", e);\n            }\n\n            if (wikiJob.getStatus().getError() != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization failed\", wikiJob.getStatus().getError());\n            }\n\n            return true;\n        }\n\n        // Still initializing\n        return false;\n    }\n\n    private Job initializeWiki(String wikiId, XWikiContext xcontext) throws JobException\n    {\n        synchronized (this.initializedWikis) {\n            WikiInitializerJob wikiJob = this.initializedWikis.get(wikiId);\n\n            if (wikiJob == null) {\n                WikiInitializerRequest request = new WikiInitializerRequest(wikiId);\n\n                JobRequestContext.set(request, xcontext);\n\n                wikiJob = (WikiInitializerJob) getJobExecutor().execute(WikiInitializerJob.JOBTYPE, request);\n                this.initializedWikis.put(wikiId, wikiJob);\n            }\n\n            return wikiJob;\n        }\n    }\n\n    private static EntityResourceReference initializeResourceFromURL(XWikiContext context) throws XWikiException\n    {\n        // Extract the Entity Resource from the URL\n        // TODO: This code should be put in an ExecutionContextInitializer but we couldn't do yet since this code\n        // requires that the XWiki object be initialized first (the line above). Thus we'll be able to to move it only\n        // after the XWiki init is done also in an ExecutionContextInitializer (and with priorities).\n        @SuppressWarnings(\"deprecation\")\n        EntityResourceReference entityResourceReference;\n        URL url = context.getURL();\n        try {\n            ExtendedURL extendedURL = new ExtendedURL(url, context.getRequest().getContextPath());\n            ResourceTypeResolver<ExtendedURL> typeResolver =\n                Utils.getComponent(new DefaultParameterizedType(null, ResourceTypeResolver.class, ExtendedURL.class));\n            ResourceType type = typeResolver.resolve(extendedURL, Collections.<String, Object>emptyMap());\n            ResourceReferenceResolver<ExtendedURL> resourceResolver = Utils\n                .getComponent(new DefaultParameterizedType(null, ResourceReferenceResolver.class, ExtendedURL.class));\n            ResourceReference reference =\n                resourceResolver.resolve(extendedURL, type, Collections.<String, Object>emptyMap());\n            entityResourceReference =\n                reference instanceof EntityResourceReference ? (EntityResourceReference) reference : null;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION,\n                String.format(\"Failed to extract Entity Resource Reference from URL [%s]\", url), e);\n        }\n        Utils.getComponent(Execution.class).getContext().setProperty(ResourceReferenceManager.RESOURCE_CONTEXT_PROPERTY,\n            entityResourceReference);\n\n        return entityResourceReference;\n    }\n\n    public static URL getRequestURL(XWikiRequest request) throws XWikiException\n    {\n        try {\n            StringBuffer requestURL = request.getRequestURL();\n            String qs = request.getQueryString();\n            if ((qs != null) && (!qs.equals(\"\"))) {\n                return new URL(requestURL.toString() + \"?\" + qs);\n            } else {\n                return new URL(requestURL.toString());\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION,\n                \"Exception while getting URL from request\", e);\n        }\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName)\n    {\n        return callPrivateMethod(obj, methodName, null, null);\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName, Class<?>[] classes, Object[] args)\n    {\n        try {\n            Method method = obj.getClass().getDeclaredMethod(methodName, classes);\n            method.setAccessible(true);\n            return method.invoke(obj, args);\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to call private method [{}]: [{}]\", methodName, e);\n\n            return null;\n        } catch (NoSuchMethodException e) {\n            return null;\n        } catch (InvocationTargetException e) {\n            LOGGER.error(\"Private method [{}] failed: [{}]\", methodName, e);\n\n            return null;\n        }\n    }\n\n    public static HttpClient getHttpClient(int timeout, String userAgent)\n    {\n        HttpClient client = new HttpClient();\n\n        if (timeout != 0) {\n            client.getParams().setSoTimeout(timeout);\n            client.getParams().setParameter(\"http.connection.timeout\", Integer.valueOf(timeout));\n        }\n\n        client.getParams().setParameter(\"http.useragent\", userAgent);\n\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if ((proxyHost != null) && (!proxyHost.equals(\"\"))) {\n            int port = 3128;\n            if ((proxyPort != null) && (!proxyPort.equals(\"\"))) {\n                port = Integer.parseInt(proxyPort);\n            }\n            client.getHostConfiguration().setProxy(proxyHost, port);\n        }\n\n        String proxyUser = System.getProperty(\"http.proxyUser\");\n        if ((proxyUser != null) && (!proxyUser.equals(\"\"))) {\n            String proxyPassword = System.getProperty(\"http.proxyPassword\");\n            Credentials defaultcreds = new UsernamePasswordCredentials(proxyUser, proxyPassword);\n            client.getState().setProxyCredentials(AuthScope.ANY, defaultcreds);\n        }\n\n        return client;\n    }\n\n    /**\n     * Using reflection, read the private value of the passed field name for the passed object.\n     *\n     * @param obj the java object on which to read the private field value\n     * @param fieldName the object member field for which to read the value\n     * @return the private value for the field\n     * @deprecated use {@link FieldUtils#readDeclaredField(Object, String, boolean)} instead\n     */\n    @Deprecated\n    public static Object getPrivateField(Object obj, String fieldName)\n    {\n        try {\n            Field field = obj.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return field.get(obj);\n        } catch (NoSuchFieldException e) {\n            return null;\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to get private field with name [{}]: [{}]\", fieldName, e);\n\n            return null;\n        } finally {\n        }\n    }\n\n    public static String getServerWikiPage(String servername)\n    {\n        return \"XWiki.XWikiServer\" + StringUtils.capitalize(servername);\n    }\n\n    /**\n     * @param content the content of the text area\n     * @param context see {@link XWikiContext}\n     */\n    public static String getTextArea(String content, XWikiContext context)\n    {\n        StringBuilder result = new StringBuilder();\n\n        // Forcing a new line after the <textarea> tag, as\n        // http://www.w3.org/TR/html4/appendix/notes.html#h-B.3.1 causes an empty line at the start\n        // of the document content to be trimmed.\n        result.append(\"<textarea name=\\\"content\\\" id=\\\"content\\\" rows=\\\"25\\\" cols=\\\"80\\\">\\n\");\n        result.append(XMLUtils.escape(content));\n        result.append(\"</textarea>\");\n\n        return result.toString();\n    }\n\n    /**\n     * This provide a way to create an XWiki object without initializing the whole XWiki (including plugins, storage,\n     * etc.).\n     * <p>\n     * Needed for tools or tests which need XWiki because it is used everywhere in the API.\n     */\n    public XWiki()\n    {\n        // Empty voluntarily\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate) throws XWikiException\n    {\n        initXWiki(context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context) throws XWikiException\n    {\n        this(context, null, false);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public void initXWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(null, context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param config the object holding the XWiki configuration read from {@code xwiki.cfg}\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     * @deprecated since 6.1M2, use {@link #initXWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public void initXWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        getProgress().pushLevelProgress(4, this);\n\n        try {\n            getProgress().startStep(this);\n\n            setDatabase(context.getMainXWiki());\n\n            setEngineContext(engineContext);\n            context.setWiki(this);\n\n            // \"Pre-initialize\" XWikiStubContextProvider with a XWikiContext containing a XWiki instance as soon as\n            // possible\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            // Prepare the store\n            if (config != null) {\n                setConfig(config);\n            }\n\n            try {\n                initializeStores();\n            } catch (ComponentLookupException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Failed to initialize stores\", e);\n            }\n\n            setCriteriaService((XWikiCriteriaService) createClassFromConfig(\"xwiki.criteria.class\",\n                \"com.xpn.xwiki.criteria.impl.XWikiCriteriaServiceImpl\", context));\n\n            // \"Pre-initialize\" XWikiStubContextProvider so that rendering engine, plugins or listeners reacting to\n            // potential document changes can use it\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Make sure these classes exists\n            if (noupdate) {\n                getProgress().pushLevelProgress(2, this);\n\n                try {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocuments(context);\n\n                    getProgress().startStep(this);\n\n                    getStatsService(context);\n                } finally {\n                    getProgress().popLevelProgress(this);\n                }\n            }\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Prepare the Plugin Engine\n            preparePlugins(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            String ro = getConfiguration().getProperty(\"xwiki.readonly\", \"no\");\n            this.isReadOnly = (\"yes\".equalsIgnoreCase(ro) || \"true\".equalsIgnoreCase(ro) || \"1\".equalsIgnoreCase(ro));\n\n            // Save the configured syntaxes\n            String syntaxes = getConfiguration().getProperty(\"xwiki.rendering.syntaxes\", \"xwiki/1.0\");\n            this.configuredSyntaxes = Arrays.asList(StringUtils.split(syntaxes, \" ,\"));\n\n            getObservationManager().addListener(this);\n        } finally {\n            getProgress().popLevelProgress(this);\n        }\n    }\n\n    private void initializeStores() throws ComponentLookupException\n    {\n        XWikiStoreInterface mainStore = getStoreConfiguration().getXWikiStore();\n\n        // Check if we need to use the cache store..\n        if (getStoreConfiguration().isStoreCacheEnabled()) {\n            XWikiCacheStoreInterface cachestore =\n                (XWikiCacheStoreInterface) Utils.getComponent(XWikiStoreInterface.class, \"cache\");\n            cachestore.setStore(mainStore);\n            setStore(cachestore);\n        } else {\n            setStore(mainStore);\n        }\n\n        setDefaultAttachmentContentStore(getStoreConfiguration().getXWikiAttachmentStore());\n        setVersioningStore(getStoreConfiguration().getXWikiVersioningStore());\n        setDefaultAttachmentArchiveStore(getStoreConfiguration().getAttachmentVersioningStore());\n        setRecycleBinStore(getStoreConfiguration().getXWikiRecycleBinStore());\n        setAttachmentRecycleBinStore(getStoreConfiguration().getAttachmentRecycleBinStore());\n    }\n\n    /**\n     * Ensure that mandatory classes (ie classes XWiki needs to work properly) exist and create them if they don't\n     * exist.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void initializeMandatoryDocuments(XWikiContext context)\n    {\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            List<MandatoryDocumentInitializer> initializers =\n                Utils.getComponentList(MandatoryDocumentInitializer.class);\n\n            // Sort the initializers based on priority. Lower priority values are first.\n            Collections.sort(initializers, new Comparator<MandatoryDocumentInitializer>()\n            {\n                @Override\n                public int compare(MandatoryDocumentInitializer left, MandatoryDocumentInitializer right)\n                {\n                    Priority leftPriority = left.getClass().getAnnotation(Priority.class);\n                    int leftPriorityValue =\n                        leftPriority != null ? leftPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    Priority rightPriority = right.getClass().getAnnotation(Priority.class);\n                    int rightPriorityValue =\n                        rightPriority != null ? rightPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    // Compare the two.\n                    return leftPriorityValue - rightPriorityValue;\n                }\n            });\n\n            getObservationManager().notify(MandatoryDocumentsInitializingEvent.EVENT, null);\n\n            getProgress().pushLevelProgress(initializers.size(), this);\n\n            try {\n                for (MandatoryDocumentInitializer initializer : initializers) {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocument(initializer, context);\n\n                    getProgress().endStep(this);\n                }\n            } finally {\n                getProgress().popLevelProgress(this);\n            }\n\n            getObservationManager().notify(MandatoryDocumentsInitializedEvent.EVENT, null);\n        }\n    }\n\n    private void initializeMandatoryDocument(String wiki, MandatoryDocumentInitializer initializer,\n        XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            context.setWikiId(wiki);\n\n            initializeMandatoryDocument(initializer, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private void initializeMandatoryDocument(MandatoryDocumentInitializer initializer, XWikiContext context)\n    {\n        try {\n            DocumentReference documentReference =\n                getCurrentReferenceDocumentReferenceResolver().resolve(initializer.getDocumentReference());\n\n            if (documentReference.getWikiReference().getName().equals(context.getWikiId())) {\n                XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n\n                if (initializer.updateDocument(document)) {\n                    saveDocument(document,\n                        localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"), context);\n                }\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to initialize mandatory document [{}]\", initializer.getDocumentReference(), e);\n        }\n    }\n\n    public XWikiStoreInterface getNotCacheStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n        }\n        return store;\n    }\n\n    public XWikiHibernateStore getHibernateStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiHibernateStore) {\n            return (XWikiHibernateStore) store;\n        } else if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n            if (store instanceof XWikiHibernateStore) {\n                return (XWikiHibernateStore) store;\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, XWikiContext context) throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, false, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, force, true, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param force if the update of the databse should be forced\n     * @param initDocuments if mandatory document and plugin should be initialized for passed wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, boolean initDocuments, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        initializeWiki(wikiId, true, context);\n    }\n\n    /**\n     * @return a cached list of all active virtual wikis (i.e. wikis who have been hit by a user request). To get a full\n     *         list of all virtual wikis database names use {@link WikiDescriptorManager#getAllIds()}.\n     * @deprecated\n     */\n    @Deprecated\n    public List<String> getVirtualWikiList()\n    {\n        return new ArrayList<>(this.initializedWikis.keySet());\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     * @return the full list of all wiki names of all defined wikis. The wiki names are computed from the names of\n     *         documents having a {@code XWiki.XWikiServerClass} object attached to them by removing the\n     *         {@code XWiki.XWikiServer} prefix and making it lower case. For example a page named\n     *         {@code XWiki.XWikiServerMyDatabase} would return {@code mydatabase} as the wiki name. This list will also\n     *         contain the main wiki.\n     *         <p>\n     *         Note: the wiki name is commonly also the name of the database where the wiki's data is stored. However,\n     *         if configured accordingly, the database can be diferent from the wiki name, like for example when setting\n     *         a wiki database prefix.\n     * @deprecated since 5.3, use {@link WikiDescriptorManager#getAllIds()} instead\n     */\n    @Deprecated\n    public List<String> getVirtualWikisDatabaseNames(XWikiContext context) throws XWikiException\n    {\n        WikiDescriptorManager descriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n\n        try {\n            return new ArrayList<String>(descriptorManager.getAllIds());\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to get the list of wikis\", e);\n        }\n    }\n\n    /**\n     * @return the cache containing the names of the wikis already initialized.\n     * @since 1.5M2.\n     * @deprecated\n     */\n    @Deprecated\n    public Cache<DocumentReference> getVirtualWikiCache()\n    {\n        return null;\n    }\n\n    /**\n     * Get the reference of the owner for the provider wiki.\n     *\n     * @param wikiName the technical name of the wiki\n     * @param context see {@link XWikiContext}\n     * @return the wiki owner or null if none is set\n     * @throws XWikiException failed to get wiki descriptor document\n     */\n    public String getWikiOwner(String wikiName, XWikiContext context) throws XWikiException\n    {\n        String wikiOwner;\n\n        String currentdatabase = context.getWikiId();\n        try {\n            context.setWikiId(context.getMainXWiki());\n\n            String serverwikipage = getServerWikiPage(wikiName);\n            XWikiDocument doc = getDocument(serverwikipage, context);\n\n            if (doc.isNew()) {\n                if (!context.isMainWiki(wikiName)) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                        \"The wiki \" + wikiName + \" does not exist\");\n                } else {\n                    wikiOwner = null;\n                }\n            } else {\n                wikiOwner = doc.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"owner\");\n                if (wikiOwner.indexOf(':') == -1) {\n                    wikiOwner = context.getMainXWiki() + \":\" + wikiOwner;\n                }\n            }\n        } finally {\n            context.setWikiId(currentdatabase);\n        }\n\n        return wikiOwner;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    protected Object createClassFromConfig(String param, String defClass, XWikiContext context) throws XWikiException\n    {\n        String storeclass = getConfiguration().getProperty(param, defClass);\n        try {\n            Class<?>[] classes = new Class<?>[] { XWikiContext.class };\n            Object[] args = new Object[] { context };\n            Object result = Class.forName(storeclass).getConstructor(classes).newInstance(args);\n            return result;\n        } catch (Exception e) {\n            Throwable ecause = e;\n            if (e instanceof InvocationTargetException) {\n                ecause = ((InvocationTargetException) e).getTargetException();\n            }\n            Object[] args = { param, storeclass };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_CLASSINVOCATIONERROR, \"Cannot load class {1} from param {0}\", ecause,\n                args);\n        }\n    }\n\n    private void preparePlugins(XWikiContext context)\n    {\n        setPluginManager(new XWikiPluginManager(getXWikiPreference(\"plugins\", context), context));\n        String plugins = getConfiguration().getProperty(\"xwiki.plugins\", \"\");\n        if (!plugins.equals(\"\")) {\n            getPluginManager().addPlugins(StringUtils.split(plugins, \" ,\"), context);\n        }\n    }\n\n    /**\n     * @return the XWiki core version as specified in the {@link #VERSION_FILE} file\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getVersion()\n    {\n        if (this.version == null) {\n            try {\n                InputStream is = getResourceAsStream(VERSION_FILE);\n                try {\n                    XWikiConfig properties = new XWikiConfig(is);\n                    this.version = properties.getProperty(VERSION_FILE_PROPERTY);\n                } finally {\n                    IOUtils.closeQuietly(is);\n                }\n            } catch (Exception e) {\n                // Failed to retrieve the version, log a warning and default to \"Unknown\"\n                LOGGER.warn(\"Failed to retrieve XWiki's version from [\" + VERSION_FILE + \"], using the [\"\n                    + VERSION_FILE_PROPERTY + \"] property.\", e);\n                this.version = \"Unknown version\";\n            }\n        }\n        return this.version;\n    }\n\n    public URL getResource(String s) throws MalformedURLException\n    {\n        return getEngineContext().getResource(s);\n    }\n\n    public InputStream getResourceAsStream(String s) throws MalformedURLException\n    {\n        InputStream is = getEngineContext().getResourceAsStream(s);\n        if (is == null) {\n            is = getEngineContext().getResourceAsStream(\"/\" + s);\n        }\n        return is;\n    }\n\n    public String getResourceContent(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toString(is, DEFAULT_ENCODING);\n                }\n            }\n        }\n        // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding\n        return FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);\n    }\n\n    public Date getResourceLastModificationDate(String name)\n    {\n        try {\n            if (getEngineContext() != null) {\n                return Util.getFileLastModificationDate(getEngineContext().getRealPath(name));\n            }\n        } catch (Exception ex) {\n            // Probably a SecurityException or the file is not accessible (inside a war)\n            LOGGER.info(\"Failed to get file modification date: \" + ex.getMessage());\n        }\n        return new Date();\n    }\n\n    public byte[] getResourceContentAsBytes(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toByteArray(is);\n                }\n            } catch (Exception e) {\n            }\n        }\n        return FileUtils.readFileToByteArray(new File(name));\n    }\n\n    public boolean resourceExists(String name)\n    {\n        if (getEngineContext() != null) {\n            try {\n                if (getResource(name) != null) {\n                    return true;\n                }\n            } catch (IOException e) {\n            }\n        }\n        try {\n            File file = new File(name);\n            return file.exists();\n        } catch (Exception e) {\n            // Could be running under -security, which prevents calling file.exists().\n        }\n        return false;\n    }\n\n    public String getRealPath(String path)\n    {\n        return getEngineContext().getRealPath(path);\n    }\n\n    public String ParamAsRealPath(String key)\n    {\n        String param = getConfiguration().getProperty(key);\n        try {\n            return getRealPath(param);\n        } catch (Exception e) {\n            return param;\n        }\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public String ParamAsRealPath(String key, XWikiContext context)\n    {\n        return ParamAsRealPath(key);\n    }\n\n    public String ParamAsRealPathVerified(String param)\n    {\n        String path;\n        File fpath;\n\n        path = getConfiguration().getProperty(param);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        }\n\n        path = getRealPath(path);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        } else {\n        }\n        return null;\n    }\n\n    public XWikiStoreInterface getStore()\n    {\n        return this.store;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentContentStore()} instead\n     */\n    @Deprecated\n    public XWikiAttachmentStoreInterface getAttachmentStore()\n    {\n        return getDefaultAttachmentContentStore();\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public XWikiAttachmentStoreInterface getDefaultAttachmentContentStore()\n    {\n        return this.defaultAttachmentContentStore;\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public AttachmentVersioningStore getDefaultAttachmentArchiveStore()\n    {\n        return this.defaultAttachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentArchiveStore()} instead\n     */\n    @Deprecated\n    public AttachmentVersioningStore getAttachmentVersioningStore()\n    {\n        return getDefaultAttachmentArchiveStore();\n    }\n\n    public XWikiVersioningStoreInterface getVersioningStore()\n    {\n        return this.versioningStore;\n    }\n\n    public XWikiRecycleBinStoreInterface getRecycleBinStore()\n    {\n        return this.recycleBinStore;\n    }\n\n    public AttachmentRecycleBinStore getAttachmentRecycleBinStore()\n    {\n        return this.attachmentRecycleBinStore;\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        XWikiContext context) throws XWikiException\n    {\n        checkSavingDocument(userReference, document, comment, false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        checkSavingDocument(userReference, document, \"\", false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        boolean isMinorEdit, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n\n            if (om != null) {\n                CancelableEvent documentEvent;\n                if (originalDocument.isNew()) {\n                    documentEvent = new UserCreatingDocumentEvent(userReference, document.getDocumentReference());\n                } else {\n                    documentEvent = new UserUpdatingDocumentEvent(userReference, document.getDocumentReference());\n                }\n                om.notify(documentEvent, document, context);\n\n                // If the action has been canceled by the user then don't perform any save and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to save the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private XWikiDocument prepareDocumentForSave(XWikiDocument document, String comment, boolean isMinorEdit,\n        XWikiContext context) throws XWikiException\n    {\n        // Set the store so we can use it for checking the max length.\n        if (document.getStore() == null) {\n            document.setStore(this.getStore());\n        }\n        String fullName = getLocalStringEntityReferenceSerializer().serialize(document.getDocumentReference());\n        // If it's a new doc we check its name length to avoid a nasty SQL error.\n        if (document.isNew() && fullName.length() > document.getLocalReferenceMaxLength()) {\n            java.lang.Object[] args = { fullName, document.getLocalReferenceMaxLength(), fullName.length() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG,\n                \"Cannot create document {0} because its full path is too long: only {1} characters are allowed and \"\n                    + \"current length is {2}.\",\n                null, args);\n        }\n\n        // Setting comment & minor edit before saving\n        document.setComment(StringUtils.defaultString(comment));\n        document.setMinorEdit(isMinorEdit);\n\n        // We need to save the original document since saveXWikiDoc() will reset it and we\n        // need that original document for the notification below.\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        // Make sure to always have an original document for listeners that need to compare with it.\n        // The only case where we have a null original document is supposedly when the document\n        // instance has been crafted and passed #saveDocument without using #getDocument\n        // (which is not a good practice)\n        // Also for document indicated as new make sure the previous document is accurate.\n        if (originalDocument == null || document.isNew()) {\n            XWikiDocument existing = getDocument(document.getDocumentReferenceWithLocale(), context);\n            // Switch the original document only if we actually find an existing document or if there is no original\n            // document in the first place\n            if (originalDocument == null || !existing.isNew()) {\n                originalDocument = existing;\n                document.setOriginalDocument(originalDocument);\n            }\n        }\n\n        return originalDocument;\n    }\n\n    /**\n     * @param doc the document to save\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // If no comment is provided we should use an empty comment\n        saveDocument(doc, \"\", context);\n    }\n\n    /**\n     * @param doc the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, String comment, XWikiContext context) throws XWikiException\n    {\n        saveDocument(doc, comment, false, context);\n    }\n\n    private void beforeSave(XWikiDocument document, XWikiContext context) throws XWikiException\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            CancelableEvent documentEvent;\n            if (document.getOriginalDocument().isNew()) {\n                documentEvent = new DocumentCreatingEvent(document.getDocumentReference());\n            } else {\n                documentEvent = new DocumentUpdatingEvent(document.getDocumentReference());\n            }\n            om.notify(documentEvent, document, context);\n\n            // If the action has been canceled by the user then don't perform any save and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC,\n                    String.format(\"An Event Listener has cancelled the document save for [%s]. Reason: [%s]\",\n                        document.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n    }\n\n    private void afterSave(XWikiDocument document, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            if (document.getOriginalDocument().isNew()) {\n                om.notify(new DocumentCreatedEvent(document.getDocumentReference()), document, context);\n            } else {\n                om.notify(new DocumentUpdatedEvent(document.getDocumentReference()), document, context);\n            }\n        }\n    }\n\n    /**\n     * Save the passed document in the store.\n     * <p>\n     * If document is not new and metadata and content dirty flags are false, the version/history won't be incremented\n     * (only the current state will be updated).\n     * <p>\n     * Since 11.1, if document#isNew() return true, any pre existing document will be backuped in the deleted documents\n     * store automatically and completely replaced.\n     * \n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument document, String comment, boolean isMinorEdit, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            beforeSave(document, context);\n\n            // Delete existing document if we replace with a new one\n            if (document.isNew()) {\n                if (!originalDocument.isNew()) {\n                    // We don't want to notify about this delete since from outside world point of view it's an update\n                    // and not a delete+create\n                    deleteDocument(originalDocument, true, false, context);\n                }\n            } else {\n                // Put attachments to remove in recycle bin\n                if (hasAttachmentRecycleBin(context)) {\n                    for (XWikiAttachmentToRemove attachment : document.getAttachmentsToRemove()) {\n                        if (attachment.isToRecycleBin()) {\n                            // Make sure the attachment will be deleted with its history\n                            attachment.getAttachment().loadArchive(context);\n                            getAttachmentRecycleBinStore().saveToRecycleBin(attachment.getAttachment(),\n                                context.getUser(), new Date(), context, true);\n                        }\n                    }\n                }\n            }\n\n            // Actually save the document.\n            getStore().saveXWikiDoc(document, context);\n\n            // Since the store#saveXWikiDoc resets originalDocument, we need to temporarily put it\n            // back to send notifications.\n            XWikiDocument newOriginal = document.getOriginalDocument();\n\n            try {\n                document.setOriginalDocument(originalDocument);\n\n                // Notify listeners about the document having been created or updated\n\n                // First the legacy notification mechanism\n\n                // Then the new observation module\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                // The old version is made available using doc.getOriginalDocument()\n                afterSave(document, context);\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document save notification for document [\"\n                    + getDefaultEntityReferenceSerializer().serialize(document.getDocumentReference()) + \"]\", ex);\n            } finally {\n                document.setOriginalDocument(newOriginal);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     * <p>\n     * Before 7.2M1 the reference is assumed to be a complete or incomplete document reference.\n     * <p>\n     * Since 7.2M1, the passed reference can be anything. If if a document child, the document reference will be\n     * extracted from it. If it's a document parent it will be completed with the necessary default references (for\n     * example if it's a space reference it will load the space home page).\n     *\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 5.0M1\n     */\n    public XWikiDocument getDocument(EntityReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument document;\n\n        if (reference.getType() == EntityType.PAGE || reference.getType().isAllowedAncestor(EntityType.PAGE)) {\n            document = getDocument(getCurrentGetPageResolver().resolve(reference), context);\n        } else {\n            document = getDocument(getCurrentGetDocumentResolver().resolve(reference), context);\n        }\n\n        return document;\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     *\n     * @param reference the reference of the document to be loaded\n     * @param type the type of the reference\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(String reference, EntityType type, XWikiContext xcontext) throws XWikiException\n    {\n        return getDocument(getRelativeEntityReferenceResolver().resolve(reference, type), xcontext);\n    }\n\n    /**\n     * @param doc the document\n     * @param context see {@link XWikiContext}\n     */\n    public XWikiDocument getDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            try {\n                // Indicate the the async context manipulated documents\n                getAsyncContext().useEntity(doc.getDocumentReferenceWithLocale());\n            } catch (Exception e) {\n                // If the AsyncContext component does not work then we are not in an asynchronous context anyway\n                LOGGER.debug(\"Failed to register the document in the asynchronous context\", e);\n            }\n\n            return getStore().loadXWikiDoc(doc, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * @param reference the reference of the document to load\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @since 9.4RC1\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(DocumentReference, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(DocumentReference reference, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(reference, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(reference);\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param document the reference document\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(XWikiDocument, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(XWikiDocument document, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(document, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(document.getDocumentReference());\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 2.2M1\n     */\n    public XWikiDocument getDocument(DocumentReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(\n            reference.getLocale() != null ? new DocumentReference(reference, (Locale) null) : reference,\n            reference.getLocale());\n\n        doc.setContentDirty(true);\n\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param reference the reference of the page\n     * @param context see {@link XWikiContext}\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(PageReference reference, XWikiContext context) throws XWikiException\n    {\n        DocumentReference documentReference = getCurrentReferenceDocumentReferenceResolver().resolve(reference);\n\n        XWikiDocument document = getDocument(documentReference, context);\n\n        if (document.isNew() && documentReference.getParent().getParent().getType() == EntityType.SPACE) {\n            // Try final page\n            XWikiDocument finalDocument = getDocument(new DocumentReference(documentReference.getParent().getName(),\n                documentReference.getParent().getParent(), documentReference.getParameters()), context);\n\n            if (!finalDocument.isNew()) {\n                document = finalDocument;\n            }\n        }\n\n        return document;\n    }\n\n    /**\n     * Find the document reference corresponding to the entity reference based on what exist in the database (page\n     * reference can means two different documents for example).\n     * \n     * @param reference the reference to resolve\n     * @param context the XWiki context\n     * @return the document reference\n     * @since 10.6RC1\n     */\n    public DocumentReference getDocumentReference(EntityReference reference, XWikiContext context)\n    {\n        DocumentReference documentReference = getCurrentGetDocumentResolver().resolve(reference);\n\n        // If the document has been found or it's top level space, return the reference\n        if (documentReference.getParent().getParent().getType() != EntityType.SPACE\n            || exists(documentReference, context)) {\n            return documentReference;\n        }\n\n        // Try final page\n        DocumentReference finalPageReference = new DocumentReference(documentReference.getParent().getName(),\n            documentReference.getParent().getParent(), documentReference.getParameters());\n\n        return exists(finalPageReference, context) ? finalPageReference : documentReference;\n    }\n\n    /**\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String fullname, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullname, context);\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param spaces the reference of the space as String\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String spaces, String fullname, XWikiContext context) throws XWikiException\n    {\n        int dotPosition = fullname.lastIndexOf('.');\n        if (dotPosition != -1) {\n            String spaceFromFullname = fullname.substring(0, dotPosition);\n            String name = fullname.substring(dotPosition + 1);\n            if (name.equals(\"\")) {\n                name = getDefaultPage(context);\n            }\n            return getDocument(spaceFromFullname + \".\" + name, context);\n        } else {\n            return getDocument(spaces + \".\" + fullname, context);\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String, String)\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String fullname, String locale, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n            doc.setLanguage(locale);\n            return getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String batchId, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getAllDeletedDocuments(batchId, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String, String, String)\n     * @deprecated since 9.4RC1. Use {@link #getDeletedDocument(long, XWikiContext)} instead.\n     */\n    @Deprecated\n    public XWikiDeletedDocument getDeletedDocument(String fullname, String locale, int index, XWikiContext context)\n        throws XWikiException\n    {\n        return getDeletedDocument(index, context);\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument getDeletedDocument(long index, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getDeletedDocument(index, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document. Note that this does not distinguish\n     * between different incarnations of a document name, and it does not require that the document still exists, it\n     * returns all the attachments that at the time of their deletion had a document with the specified name as their\n     * owner.\n     *\n     * @param docName the {@link XWikiDocument#getFullName() name} of the owner document\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document. If no such attachments\n     *         are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(doc, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document and had the specified name. Multiple\n     * versions can be returned since the same file can be uploaded and deleted several times, creating different\n     * instances in the trash. Note that this does not distinguish between different incarnations of a document name,\n     * and it does not require that the document still exists, it returns all the attachments that at the time of their\n     * deletion had a document with the specified name as their owner.\n     *\n     * @param docName the {@link DeletedAttachment#getDocName() name of the document} the attachment belonged to\n     * @param filename the {@link DeletedAttachment#getFilename() name} of the attachment to search for\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document and had the specified\n     *         filename. If no such attachments are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            XWikiAttachment attachment = new XWikiAttachment(doc, filename);\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(attachment, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve a specific attachment from the trash.\n     *\n     * @param id the unique identifier of the entry in the trash\n     * @param context the XWiki context\n     * @return specified attachment from the trash, {@code null} if not found\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public DeletedAttachment getDeletedAttachment(String id, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            return getAttachmentRecycleBinStore().getDeletedAttachment(NumberUtils.toLong(id), context, true);\n        }\n        return null;\n    }\n\n    public MetaClass getMetaclass()\n    {\n        if (this.metaclass == null) {\n            this.metaclass = MetaClass.getMetaClass();\n        }\n        return this.metaclass;\n    }\n\n    public void setMetaclass(MetaClass metaclass)\n    {\n        this.metaclass = metaclass;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public List<String> getClassList(XWikiContext context) throws XWikiException\n    {\n        List<String> result = getStore().getClassList(context);\n        Collections.sort(result);\n        return result;\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, nb, start, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, Object[][] whereParams, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, whereParams, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, Object[][] whereParams, XWikiContext context)\n        throws XWikiException\n    {\n        return getStore().search(sql, nb, start, whereParams, context);\n    }\n\n    /**\n     * @param content the content to parse\n     * @param context see {@link XWikiContext}\n     * @deprecated Since 7.2M1. Use specific rendering/parsing options for the content type you want to parse/render.\n     */\n    @Deprecated\n    public String parseContent(String content, XWikiContext context)\n    {\n        return getOldRendering().parseContent(content, context);\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     * @deprecated use {@link #evaluateTemplate(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            result = evaluateTemplate(template, context);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while parsing template [{}] from /templates/\", template, e);\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate provided template content using velocity engine.\n     *\n     * @param template the template to evaluate\n     * @param context see {@link XWikiContext}\n     * @return the return of the velocity script\n     * @throws IOException failed to get the template content\n     * @since 2.2.2\n     * @deprecated since 7.0M1, use {@link TemplateManager#render(String)} instead\n     */\n    @Deprecated\n    public String evaluateTemplate(String template, XWikiContext context) throws IOException\n    {\n        try {\n            return getTemplateManager().render(template);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}]\", template, e);\n\n            Object[] args = { template };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while evaluating velocity template {0}\",\n                e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skinId the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     * @deprecated since 7.0M1, use {@link TemplateManager#renderFromSkin} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, String skinId, XWikiContext context)\n    {\n        MutableRenderingContext mutableRenderingContext = getMutableRenderingContext();\n\n        Syntax currentTargetSyntax = mutableRenderingContext.getTargetSyntax();\n        try {\n            // Force rendering with XHTML 1.0 syntax for retro-compatibility\n            mutableRenderingContext.setTargetSyntax(Syntax.XHTML_1_0);\n\n            Skin skin = getInternalSkinManager().getSkin(skinId);\n            return getTemplateManager().renderFromSkin(template, skin);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}] skin [{}]\", template, skinId, e);\n\n            Object[] args = { template, skinId };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION,\n                \"Error while evaluating velocity template [{0}] from skin [{1}]\", e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        } finally {\n            mutableRenderingContext.setTargetSyntax(currentTargetSyntax);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skin the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, String skin, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, skin, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"] for skin [\" + skin + \"]\", ex);\n            return parseTemplate(template, skin, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"]\", ex);\n            return parseTemplate(template, context);\n        }\n    }\n\n    /**\n     * Designed to include dynamic content, such as Servlets or JSPs, inside Velocity templates; works by creating a\n     * RequestDispatcher, buffering the output, then returning it as a string.\n     */\n    public String invokeServletAndReturnAsString(String url, XWikiContext xwikiContext)\n    {\n\n        HttpServletRequest servletRequest = xwikiContext.getRequest();\n        HttpServletResponse servletResponse = xwikiContext.getResponse();\n\n        try {\n            return IncludeServletAsString.invokeServletAndReturnAsString(url, servletRequest, servletResponse);\n        } catch (Exception e) {\n            LOGGER.warn(\"Exception including url: \" + url, e);\n            return \"Exception including \\\"\" + url + \"\\\", see logs for details.\";\n        }\n\n    }\n\n    /**\n     * @param iconName the standard name of an icon (it's not the name of the file on the filesystem, it's a generic\n     *            name, for example \"success\" for a success icon\n     * @param context see {@link XWikiContext}\n     * @return the URL to the icon resource\n     * @since 2.6M1\n     */\n    public String getIconURL(String iconName, XWikiContext context)\n    {\n        // TODO: Do a better mapping between generic icon name and physical resource name, especially to be independent\n        // of the underlying icon library. Right now we assume it's the Silk icon library.\n        return getSkinFile(\"icons/silk/\" + iconName + \".png\", context);\n    }\n\n    public String getSkinFile(String filename, XWikiContext context)\n    {\n        return getSkinFile(filename, false, context);\n    }\n\n    /**\n     * Build and return a skin file url based on the given parameters.\n     * \n     * @param filename the file name of the skin file wanted\n     * @param forceSkinAction if true force the usage of directory /skins/ in the URL\n     * @param context current context for the request\n     * @return a resource URL for the asked filename\n     */\n    public String getSkinFile(String filename, boolean forceSkinAction, XWikiContext context)\n    {\n        String skinFile = getSkinFile(filename, null, forceSkinAction, context);\n\n        if (skinFile == null) {\n            // Use the default base skin even if the URL could be invalid.\n            XWikiURLFactory urlf = context.getURLFactory();\n            URL url;\n            if (forceSkinAction) {\n                url = urlf.createSkinURL(filename, \"skins\", getDefaultBaseSkin(context), context);\n            } else {\n                url = urlf.createSkinURL(filename, getDefaultBaseSkin(context), context);\n            }\n            skinFile = urlf.getURL(url, context);\n        }\n\n        return skinFile;\n    }\n\n    private String getSkinFileInternal(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        try {\n            if (skinId != null) {\n                // Try only in the specified skin.\n                Skin skin = getInternalSkinManager().getSkin(skinId);\n                if (skin != null) {\n                    Resource<?> resource = skin.getLocalResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                }\n            } else {\n                // Try in the current skin.\n                Skin skin = getInternalSkinManager().getCurrentSkin(true);\n                if (skin != null) {\n                    Resource<?> resource = skin.getResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                } else {\n                    // Try in the current parent skin.\n                    Skin parentSkin = getInternalSkinManager().getCurrentParentSkin(true);\n                    if (parentSkin != null) {\n                        Resource<?> resource = parentSkin.getResource(fileName);\n                        if (resource != null) {\n                            return resource.getURL(forceSkinAction);\n                        }\n                    }\n                }\n            }\n\n            // Look for a resource file.\n            String resourceFilePath = \"/resources/\" + fileName;\n            XWikiURLFactory urlFactory = context.getURLFactory();\n            if (resourceExists(resourceFilePath)) {\n                URL url = urlFactory.createResourceURL(fileName, forceSkinAction, context,\n                    getResourceURLCacheParameters(resourceFilePath));\n                return urlFactory.getURL(url, context);\n            }\n        } catch (Exception e) {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Exception while getting skin file [{}] from skin [{}]\", fileName, skinId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(String resourceFilePath)\n    {\n        try {\n            URL resourceUrl = getResource(resourceFilePath);\n            return getResourceURLCacheParameters(resourceUrl);\n        } catch (MalformedURLException e) {\n            LOGGER.debug(\"Error while getting URL for resource path [{}]\", resourceFilePath, e);\n            return Collections.singletonMap(CACHE_VERSION, getVersion());\n        }\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(URL resourceUrl)\n    {\n        Map<String, Object> parameters = new LinkedHashMap<>();\n\n        if (getURLConfiguration().useResourceLastModificationDate()) {\n            try {\n                Path resourcePath = Paths.get(resourceUrl.toURI());\n                FileTime lastModifiedTime = Files.getLastModifiedTime(resourcePath);\n                parameters.put(CACHE_VERSION, String.valueOf(lastModifiedTime.toMillis()));\n            } catch (Exception e) {\n                LOGGER.debug(\"Error when trying to access properties of resource URL [{}]\", resourceUrl, e);\n                parameters.put(CACHE_VERSION, getVersion());\n            }\n        } else {\n            parameters.put(CACHE_VERSION, getVersion());\n        }\n\n        return parameters;\n    }\n\n    public String getSkinFile(String filename, String skin, XWikiContext context)\n    {\n        return getSkinFile(filename, skin, false, context);\n    }\n\n    public String getSkinFile(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        if (StringUtils.endsWithAny(fileName, \".js\", \".css\")) {\n            String extension = StringUtils.substringAfterLast(fileName, '.');\n            String shortFileName = StringUtils.substringBeforeLast(fileName, \".\");\n            if (StringUtils.endsWith(shortFileName, \".min\")) {\n                shortFileName = StringUtils.substringBeforeLast(shortFileName, \".\");\n            }\n            String fileNameSource = String.format(\"%s.%s\", shortFileName, extension);\n            String fileNameMinified = String.format(\"%s.min.%s\", shortFileName, extension);\n            DebugConfiguration debugConfig = Utils.getComponent(DebugConfiguration.class);\n            String[] fileNames = debugConfig.isMinify() ? new String[] {fileNameMinified, fileNameSource}\n                : new String[] {fileNameSource, fileNameMinified};\n            String skinFile = null;\n            for (String name : fileNames) {\n                skinFile = getSkinFileInternal(name, skinId, forceSkinAction, context);\n                if (skinFile != null) {\n                    break;\n                }\n            }\n            return skinFile;\n        } else {\n            return getSkinFileInternal(fileName, skinId, forceSkinAction, context);\n        }\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} instead\n     */\n    @Deprecated\n    public String getSkin(XWikiContext context)\n    {\n        String skin;\n\n        try {\n            skin = getInternalSkinManager().getCurrentSkinId(true);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while determining current skin\", e);\n            skin = getDefaultBaseSkin(context);\n        }\n\n        return skin;\n    }\n\n    public String getSkinPreference(String prefname, XWikiContext context)\n    {\n        return getSkinPreference(prefname, \"\", context);\n    }\n\n    public String getSkinPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        for (Skin skin = getInternalSkinManager().getCurrentSkin(true); skin != null; skin = skin.getParent()) {\n            if (skin instanceof WikiSkin) {\n                String value = getWikiSkinUtils().getSkinProperty(skin.getId(), prefname);\n\n                // TODO: remove the NO_VALUE test when XWIKI-10853 is fixed\n                if (!StringUtils.isEmpty(value) && !NO_VALUE.equals(value)) {\n                    return value;\n                }\n            }\n        }\n\n        return defaultValue;\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getDefaultParentSkin()} instead\n     */\n    @Deprecated\n    public String getDefaultBaseSkin(XWikiContext context)\n    {\n        return getInternalSkinManager().getDefaultParentSkinId();\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context)\n    {\n        return getBaseSkin(context, false);\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context, boolean fromRenderSkin)\n    {\n        String baseskin = \"\";\n        try {\n            return getInternalSkinManager().getCurrentParentSkinId(false);\n        } catch (Exception e) {\n            baseskin = getDefaultBaseSkin(context);\n\n            LOGGER.debug(\"Exception while determining base skin\", e);\n        }\n\n        return baseskin;\n    }\n\n    /**\n     * @param skin the name of the skin for which to return the base skin. For example : <tt>XWiki.DefaultSkin</tt>\n     * @param context see {@link XWikiContext}\n     * @return if found, the name of the base skin the asked skin inherits from. If not found, returns an empty string.\n     * @since 2.0.2\n     * @since 2.1M1\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} and {@link Skin#getParent()} instead\n     */\n    @Deprecated\n    public String getBaseSkin(String skin, XWikiContext context)\n    {\n        String baseSkin = getInternalSkinManager().getParentSkin(skin);\n\n        return baseSkin != null ? baseSkin : \"\";\n    }\n\n    public String getSpaceCopyright(XWikiContext context)\n    {\n        return getSpacePreference(\"webcopyright\", \"\", context);\n    }\n\n    public String getXWikiPreference(String prefname, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", context);\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     */\n    public String getXWikiPreference(String prefname, String fallbackParam, String defaultValue, XWikiContext context)\n    {\n        String result = getWikiConfiguration().getProperty(prefname, String.class);\n\n        if (StringUtils.isEmpty(result)) {\n            result = getConfiguration().getProperty(fallbackParam, defaultValue);\n        }\n\n        return result != null ? result : \"\";\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param wiki the wiki to get preference from\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     * @since 7.4M1\n     */\n    public String getXWikiPreference(String prefname, String wiki, String fallbackParam, String defaultValue,\n        XWikiContext xcontext)\n    {\n        String currentWiki = xcontext.getWikiId();\n\n        try {\n            xcontext.setWikiId(wiki);\n\n            return getXWikiPreference(prefname, fallbackParam, defaultValue, xcontext);\n        } finally {\n            xcontext.setWikiId(currentWiki);\n        }\n    }\n\n    public String getXWikiPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", defaultValue, context);\n    }\n\n    public String getSpacePreference(String preference, XWikiContext context)\n    {\n        return getSpacePreference(preference, \"\", context);\n    }\n\n    public String getSpacePreference(String preference, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, (SpaceReference) null, defaultValue, context);\n    }\n\n    /**\n     * @deprecated since 7.4M1, use {@link #getSpacePreference(String, SpaceReference, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String getSpacePreference(String preference, String space, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, new SpaceReference(space, context.getWikiReference()), defaultValue,\n            context);\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or empty String if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, XWikiContext context)\n    {\n        return getSpacePreference(preferenceKey, spaceReference, \"\", context);\n    }\n\n    /**\n     * Get the preference key for the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space. If null and there's a current document then the current space\n     *                       is used. If null and there's no current document then fall back to the wiki preferences.\n     * @param defaultValue the value to return if the preference can't be found\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or <code>defaultValue</code> if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, String defaultValue,\n        XWikiContext context)\n    {\n        XWikiDocument currentDocument = context.getDoc();\n\n        try {\n            if (spaceReference != null) {\n                context.setDoc(new XWikiDocument(new DocumentReference(\"WebPreferences\", spaceReference)));\n            } else if (currentDocument != null) {\n                spaceReference = currentDocument.getDocumentReference().getLastSpaceReference();\n            }\n\n            String result = getSpaceConfiguration().getProperty(preferenceKey, String.class);\n\n            if (StringUtils.isEmpty(result)) {\n                if (spaceReference == null) {\n                    result = getXWikiPreference(preferenceKey, defaultValue, context);\n                } else if (spaceReference.getParent() instanceof SpaceReference) {\n                    result = getSpacePreference(preferenceKey, (SpaceReference) spaceReference.getParent(),\n                        defaultValue, context);\n                } else if (spaceReference.getParent() instanceof WikiReference) {\n                    result =\n                        getXWikiPreference(preferenceKey, spaceReference.getParent().getName(), defaultValue, context);\n                }\n            }\n\n            return result != null ? result : defaultValue;\n        } finally {\n            context.setDoc(currentDocument);\n        }\n    }\n\n    public String getUserPreference(String prefname, XWikiContext context)\n    {\n        String result =\n            getAllUserPropertiesResolver().resolve(CurrentUserReference.INSTANCE).getProperty(prefname, String.class);\n\n        return result != null ? result : \"\";\n    }\n\n    public String getUserPreferenceFromCookie(String prefname, XWikiContext context)\n    {\n        Cookie[] cookies = context.getRequest().getCookies();\n        if (cookies == null) {\n            return null;\n        }\n        for (Cookie cookie : cookies) {\n            String name = cookie.getName();\n            if (name.equals(prefname)) {\n                String value = cookie.getValue();\n                if (!value.trim().equals(\"\")) {\n                    return value;\n                } else {\n                    break;\n                }\n            }\n        }\n        return null;\n    }\n\n    public String getUserPreference(String prefname, boolean useCookie, XWikiContext context)\n    {\n        // First we look in the cookies\n        if (useCookie) {\n            String result = Util.normalizeLanguage(getUserPreferenceFromCookie(prefname, context));\n            if (result != null) {\n                return result;\n            }\n        }\n        return getUserPreference(prefname, context);\n    }\n\n    /**\n     * Set the locale in the given context.\n     * <p>\n     * If {@code forceSupported} is true, then the locale will be set only if it is in the {@see availableLocales}. Note\n     * that all the parent locales are checked.\n     *\n     * @param locale the locale to use\n     * @param context the context\n     * @param availableLocales the accepted locales. Used only if {@see forceSupported} is true\n     * @param forceSupported determine if the {@see locale} should be checked against the {@see availableLocales}\n     * @return the locale that has been set or null\n     */\n    private Locale setLocale(Locale locale, XWikiContext context, Set<Locale> availableLocales, boolean forceSupported)\n    {\n        while (locale != null) {\n            if (!forceSupported || availableLocales.contains(locale)) {\n                context.setLocale(locale);\n                break;\n            }\n            locale = LocaleUtils.getParentLocale(locale);\n        }\n\n        return locale;\n    }\n\n    /**\n     * The algorithm to find the locale to use is the following, in this order:\n     *\n     * <ul>\n     *   <li>Try to find the current locale in use from the XWiki contex</li>\n     *   <li>If the wiki is not multilingual use the wiki default locale ({@code default_language} xproperty in\n     *   {@code XWikiPreferences} xobject or English if not found)</li>\n     *   <li>If the wiki is multilingual<ul>\n     *     <li>Try to get the locale passed in the request (looking for a {@code language} query string parameter).\n     *     If the language value is {@code default} use the wiki default locale. If a parameter is found sets a\n     *     {@code language} cookie to remember the language in use.</li>\n     *     <li>Try to get the locale from the {@code language} cookie</li>\n     *     <li>If the default language is preferred ({@code xwiki.language.preferDefault} from {@code xwiki.cfg}\n     *     or {@code preferDefaultLanguage} property from the space preferences ({@code WebPreferences} xobject) or\n     *     wiki preferences ({@code XWikiPreferences} xobject})), and since the user didn't explicitly ask for a\n     *     language already, then use the wiki default locale.</li>\n     *     <li>Try to use the browser's {@code Accept-Language} header sent in HTTP request.<li>\n     *     <li>Fallback to the wiki default locale</li>\n     *   </ul></li>\n     * </ul>\n     *\n     * In addition the {code xwiki.language.forceSupported} configuration property is enabled by default and means that\n     * if at any step above the locale found is not in the list of supported locales, then the locale is not set and\n     * the algorithm moves to the next step.\n     *\n     * @return the locale to use\n     * @since 8.0M1\n     */\n    public Locale getLocalePreference(XWikiContext context)\n    {\n        Locale defaultLocale = this.getDefaultLocale(context);\n        Set<Locale> availableLocales = new HashSet<>(this.getAvailableLocales(context));\n        boolean forceSupported = getConfiguration().getProperty(\"xwiki.language.forceSupported\", \"1\").equals(\"1\");\n\n        // First we try to get the language from the XWiki Context. This is the current language\n        // being used.\n        Locale locale = context.getLocale();\n        if (locale != null) {\n            return locale;\n        }\n\n        // If the wiki is non multilingual then the language is the default language.\n        if (!isMultiLingual(context)) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // As the wiki is multilingual try to find the language to use from the request by looking\n        // for a language parameter. If the language value is \"default\" use the default language\n        // from the XWiki preferences settings. Otherwise set a cookie to remember the language\n        // in use.\n        try {\n            String language = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n            if (language != null) {\n                if (\"default\".equals(language)) {\n                    // forgetting language cookie\n                    Cookie cookie = new Cookie(\"language\", \"\");\n                    cookie.setMaxAge(0);\n                    cookie.setPath(\"/\");\n                    context.getResponse().addCookie(cookie);\n                    context.setLocale(defaultLocale);\n                    return defaultLocale;\n                } else {\n                    locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                    if (LocaleUtils.isAvailableLocale(locale)) {\n                        // setting language cookie\n                        Cookie cookie = new Cookie(\"language\", context.getLocale().toString());\n                        cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                        cookie.setPath(\"/\");\n                        context.getResponse().addCookie(cookie);\n                        return locale;\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // As no language parameter was passed in the request, try to get the language to use from a cookie.\n        try {\n            // First we get the language from the cookie\n            String language = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n            if (StringUtils.isNotEmpty(language)) {\n                locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // If the default language is preferred, and since the user didn't explicitly ask for a\n        // language already, then use the default wiki language.\n        if (getConfiguration().getProperty(\"xwiki.language.preferDefault\", \"0\").equals(\"1\")\n            || getSpacePreference(\"preferDefaultLanguage\", \"0\", context).equals(\"1\")) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // Then from the navigator language setting\n        if (context.getRequest() != null && context.getRequest().getLocales() != null) {\n            for (Locale acceptedLocale : Collections.list(context.getRequest().getLocales())) {\n                locale = setLocale(acceptedLocale, context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n            // If none of the languages requested by the client is acceptable, skip to next\n            // phase (use default language).\n        }\n\n        // Finally, use the default language from the global preferences.\n        context.setLocale(defaultLocale);\n        return defaultLocale;\n    }\n\n    /**\n     * First try to find the current locale in use from the XWiki context. If none is used and if the wiki is not\n     * multilingual use the default locale defined in the XWiki preferences. If the wiki is multilingual try to get the\n     * locale passed in the request. If none was passed try to get it from a cookie. If no locale cookie exists then use\n     * the user default locale and barring that use the browser's \"Accept-Language\" header sent in HTTP request. If none\n     * is defined use the default locale.\n     *\n     * @return the locale to use\n     * @deprecated since 8.0M1, use {@link #getLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getLanguagePreference(XWikiContext context)\n    {\n        return getLocalePreference(context).toString();\n    }\n\n    /**\n     * Construct a list of language codes (ISO 639-1) from the Accept-Languages header. This method filters out some\n     * bugs in different browsers or containers, like returning '*' as a language (Jetty) or using '_' as a\n     * language--country delimiter (some versions of Opera).\n     *\n     * @param request The client request.\n     * @return A list of language codes, in the client preference order; might be empty if the header is not well\n     *         formed.\n     */\n    private List<String> getAcceptedLanguages(XWikiRequest request)\n    {\n        List<String> result = new ArrayList<String>();\n        Enumeration<Locale> e = request.getLocales();\n        while (e.hasMoreElements()) {\n            String language = e.nextElement().getLanguage().toLowerCase();\n            // All language codes should have 2 letters.\n            if (StringUtils.isAlpha(language)) {\n                result.add(language);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @deprecated since 5.1M2 use {@link #getDefaultLocale(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getDefaultLanguage(XWikiContext xcontext)\n    {\n        return getDefaultLocale(xcontext).toString();\n    }\n\n    /**\n     * The default locale in the preferences.\n     *\n     * @param xcontext the XWiki context.\n     * @return the default locale\n     * @since 5.1M2\n     */\n    public Locale getDefaultLocale(XWikiContext xcontext)\n    {\n        // Find out what is the default language from the XWiki preferences settings.\n        String defaultLanguage = xcontext.getWiki().getXWikiPreference(\"default_language\", \"\", xcontext);\n\n        Locale defaultLocale;\n\n        if (StringUtils.isBlank(defaultLanguage)) {\n            defaultLocale = Locale.ENGLISH;\n        } else {\n            try {\n                defaultLocale = LocaleUtils.toLocale(Util.normalizeLanguage(defaultLanguage));\n            } catch (Exception e) {\n                LOGGER.warn(\"Invalid locale [{}] set as default locale in the preferences\", defaultLanguage);\n                defaultLocale = Locale.ENGLISH;\n            }\n        }\n\n        return defaultLocale;\n    }\n\n    /**\n     * Get the available locales according to the preferences.\n     *\n     * @param xcontext the XWiki context\n     * @return all the available locales\n     * @since 5.1M2\n     */\n    public List<Locale> getAvailableLocales(XWikiContext xcontext)\n    {\n        String[] languages = StringUtils.split(xcontext.getWiki().getXWikiPreference(\"languages\", xcontext), \", |\");\n\n        List<Locale> locales = new ArrayList<Locale>(languages.length);\n\n        for (String language : languages) {\n            if (StringUtils.isNotBlank(language)) {\n                try {\n                    locales.add(LocaleUtils.toLocale(language));\n                } catch (Exception e) {\n                    LOGGER.warn(\"Invalid locale [{}] listed as available in the preferences\", language);\n                }\n            }\n        }\n\n        // Add default language in case it's not listed as available (which is wrong but it happen)\n        Locale defaultocale = getDefaultLocale(xcontext);\n        if (!locales.contains(defaultocale)) {\n            locales.add(defaultocale);\n        }\n\n        return locales;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getDocLocalePreferenceNew(XWikiContext context)\n    {\n        String language = getDocLanguagePreferenceNew(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getDocLocalePreferenceNew(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getDocLocalePreferenceNew\n    public String getDocLanguagePreferenceNew(XWikiContext context)\n    {\n        // Get context language\n        String contextLanguage = context.getLanguage();\n        // If the language exists in the context, it was previously set by another call\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            return contextLanguage;\n        }\n\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = context.getWiki().getXWikiPreference(\"default_language\", \"\", context);\n            context.setLanguage(language);\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n        } catch (Exception ex) {\n        }\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if (StringUtils.isNotEmpty(requestLanguage)) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"language\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the cookie\n        if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"language\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getInterfaceLocalePreference(XWikiContext context)\n    {\n        String language = getInterfaceLanguagePreference(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getInterfaceLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getInterfaceLocalePreference\n    public String getInterfaceLanguagePreference(XWikiContext context)\n    {\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\", contextLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = Util.normalizeLanguage(context.getWiki().getXWikiPreference(\"default_language\", \"\", context));\n            context.setInterfaceLocale(LocaleUtils.toLocale(language));\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"interfacelanguage\"));\n        } catch (Exception ex) {\n        }\n\n        // Get context language\n        contextLanguage = context.getInterfaceLanguage();\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = null;\n            userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_interface_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"interfacelanguage\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if ((requestLanguage != null) && (!requestLanguage.equals(\"\"))) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"interfacelanguage\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the context\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            language = contextLanguage;\n        }\n        // Next we get the language from the cookie\n        else if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"interfacelanguage\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getXWikiPreference(preference, context));\n    }\n\n    public long getSpacePreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getSpacePreference(preference, context));\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong((getXWikiPreference(preference, context)), defaultValue);\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, String fallbackParameter, long defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toLong(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public long getSpacePreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public long getUserPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getUserPreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getXWikiPreference(preference, context));\n    }\n\n    public int getSpacePreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getSpacePreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, context), defaultValue);\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, String fallbackParameter, int defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public int getSpacePreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public int getUserPreferenceAsInt(String prefname, XWikiContext context)\n    {\n        return Integer.parseInt(getUserPreference(prefname, context));\n    }\n\n    public void flushCache(XWikiContext context)\n    {\n        // We need to flush the virtual wiki list\n        this.initializedWikis = new ConcurrentHashMap<>();\n\n        // We need to flush the group service cache\n        if (this.groupService != null) {\n            this.groupService.flushCache();\n        }\n\n        // If we use the Cache Store layer.. we need to flush it\n        XWikiStoreInterface store = getStore();\n        if ((store != null) && (store instanceof XWikiCacheStoreInterface)) {\n            ((XWikiCacheStoreInterface) getStore()).flushCache();\n        }\n        // Flush renderers.. Groovy renderer has a cache\n        getOldRendering().flushCache();\n        getParseGroovyFromString().flushCache();\n\n        XWikiPluginManager pmanager = getPluginManager();\n        if (pmanager != null) {\n            pmanager.flushCache(context);\n        }\n\n        // Make sure we call all classes flushCache function\n        try {\n            List<String> classes = getClassList(context);\n            for (int i = 0; i < classes.size(); i++) {\n                String className = classes.get(i);\n                try {\n                    getClass(className, context).flushCache();\n                } catch (Exception e) {\n                }\n            }\n        } catch (Exception e) {\n        }\n\n    }\n\n    public XWikiPluginManager getPluginManager()\n    {\n        return this.pluginManager;\n    }\n\n    public void setPluginManager(XWikiPluginManager pluginManager)\n    {\n        this.pluginManager = pluginManager;\n    }\n\n    public void setStore(XWikiStoreInterface store)\n    {\n        this.store = store;\n    }\n\n    /**\n     * @param attachmentContentStore the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface attachmentContentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentContentStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface)} instead\n     */\n    @Deprecated\n    public void setAttachmentStore(XWikiAttachmentStoreInterface attachmentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentStore;\n    }\n\n    /**\n     * @param attachmentArchiveStore the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentArchiveStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        this.defaultAttachmentArchiveStore = attachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.10RC1, use {@link #setDefaultAttachmentArchiveStore(AttachmentVersioningStore)} instead\n     */\n    @Deprecated\n    public void setAttachmentVersioningStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        setDefaultAttachmentArchiveStore(attachmentArchiveStore);\n    }\n\n    public void setVersioningStore(XWikiVersioningStoreInterface versioningStore)\n    {\n        this.versioningStore = versioningStore;\n    }\n\n    public void setRecycleBinStore(XWikiRecycleBinStoreInterface recycleBinStore)\n    {\n        this.recycleBinStore = recycleBinStore;\n    }\n\n    public void setAttachmentRecycleBinStore(AttachmentRecycleBinStore attachmentRecycleBinStore)\n    {\n        this.attachmentRecycleBinStore = attachmentRecycleBinStore;\n    }\n\n    public void setCriteriaService(XWikiCriteriaService criteriaService)\n    {\n        this.criteriaService = criteriaService;\n    }\n\n    public void setVersion(String version)\n    {\n        this.version = version;\n    }\n\n    /**\n     * Verify if the provided xclass page exists and that it contains all the required configuration properties to make\n     * the tag feature work properly. If some properties are missing they are created and saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @param classReference the reference of the document containing the class\n     * @return the Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     */\n    private BaseClass getMandatoryClass(XWikiContext context, DocumentReference classReference) throws XWikiException\n    {\n        XWikiDocument document = getDocument(classReference, context);\n\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            MandatoryDocumentInitializer initializer =\n                Utils.getComponent(MandatoryDocumentInitializer.class, document.getFullName());\n\n            if (initializer.updateDocument(document)) {\n                saveDocument(document, localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"),\n                    context);\n            }\n        }\n\n        return document.getXClass();\n    }\n\n    /**\n     * Verify if the <code>XWiki.TagClass</code> page exists and that it contains all the required configuration\n     * properties to make the tag feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the TagClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getTagClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"TagClass\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.SheetClass</code> page exists and that it contains all the required configuration\n     * properties to make the sheet feature work properly. If some properties are missing they are created and saved in\n     * the database. SheetClass is used to a page as a sheet. When a page is tagged as a sheet and that page is included\n     * in another page using the include macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0\n     * only - for XWiki Syntax 1.0 automatic inline edition is triggered using #includeForm).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the SheetClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @deprecated since 3.1M2 edit mode class should be used for this purpose, not the sheet class\n     * @see #getEditModeClass(XWikiContext)\n     */\n    @Deprecated\n    public BaseClass getSheetClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"SheetClass\"));\n    }\n\n    /**\n     * Verify if the {@code XWiki.EditModeClass} page exists and that it contains all the required configuration\n     * properties to make the edit mode feature work properly. If some properties are missing they are created and saved\n     * in the database. EditModeClass is used to specify the default edit mode of a page. It can also be used to mark a\n     * page as a sheet. When a page is marked as a sheet and that page is included in another page using the include\n     * macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0 only - for XWiki Syntax 1.0\n     * automatic inline edition is triggered using #includeForm). It replaces and enhances the SheetClass mechanism (see\n     * {@link #getSheetClass(XWikiContext)}).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the EditModeClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @since 3.1M2\n     */\n    public BaseClass getEditModeClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(\n            new LocalDocumentReference(XWikiConstant.EDIT_MODE_CLASS), new WikiReference(context.getWikiId())));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiUsers</code> page exists and that it contains all the required configuration\n     * properties to make the user feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWikiUsers Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getUserClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiUsers\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.GlobalRedirect</code> page exists and that it contains all the required configuration\n     * properties to make the redirection feature work properly. If some properties are missing they are created and\n     * saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the GlobalRedirect Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getRedirectClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"GlobalRedirect\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiPreferences</code> page exists and that it contains all the required configuration\n     * properties to make XWiki work properly. If some properties are missing they are created and saved in the\n     * database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWiki Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getPrefsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, getPreferencesDocumentReference(context));\n    }\n\n    public BaseClass getGroupClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiGroups\"));\n    }\n\n    public BaseClass getRightsClass(String pagename, XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, pagename));\n    }\n\n    public BaseClass getRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiRights\", context);\n    }\n\n    public BaseClass getGlobalRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiGlobalRights\", context);\n    }\n\n    public BaseClass getCommentsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiComments\"));\n    }\n\n    public BaseClass getSkinClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiSkins\"));\n    }\n\n    public int createUser(XWikiContext context) throws XWikiException\n    {\n        return createUser(false, \"edit\", context);\n    }\n\n    public int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            // Get the user document\n            String username = convertUsername(request.getParameter(\"xwikiname\"), context);\n            if (username.indexOf('.') == -1) {\n                username = \"XWiki.\" + username;\n            }\n            XWikiDocument userDocument = getDocument(username, context);\n\n            // Get the stored validation key\n            BaseObject userObject = userDocument.getObject(\"XWiki.XWikiUsers\", 0);\n            String storedKey = userObject.getStringValue(\"validkey\");\n\n            // Get the validation key from the URL\n            String validationKey = request.getParameter(\"validkey\");\n            PropertyInterface validationKeyClass = getClass(\"XWiki.XWikiUsers\", context).get(\"validkey\");\n            if (validationKeyClass instanceof PasswordClass) {\n                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);\n            }\n\n            // Compare the two keys\n            if ((!storedKey.equals(\"\") && (storedKey.equals(validationKey)))) {\n                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());\n                xWikiUser.setDisabled(false, context);\n                xWikiUser.setEmailChecked(true, context);\n                saveDocument(userDocument, context);\n\n                if (withConfirmEmail) {\n                    String email = userObject.getStringValue(\"email\");\n                    String password = userObject.getStringValue(\"password\");\n                    sendValidationEmail(username, password, email, request.getParameter(\"validkey\"),\n                        \"confirmation_email_content\", context);\n                }\n\n                return 0;\n            } else {\n                return -1;\n            }\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,\n                \"Exception while validating user\", e, null);\n        }\n    }\n\n    public int createUser(boolean withValidation, String userRights, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            Map<String, String[]> map = Util.getObject(request, \"register\");\n\n            String content = \"\";\n            Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n            // Read the values from the request.\n            String xwikiname = request.getParameter(\"xwikiname\");\n            String password2 = request.getParameter(\"register2_password\");\n            String password = (map.get(\"password\"))[0];\n            String email = (map.get(\"email\"))[0];\n            String template = request.getParameter(\"template\");\n            String parent = request.getParameter(\"parent\");\n            String validkey = null;\n\n            // Validate the values.\n            if (XWikiRightService.SUPERADMIN_USER.equalsIgnoreCase(xwikiname)) {\n                return -8;\n            }\n            try {\n                if (!context.getUtil().match(getConfiguration().getProperty(\"xwiki.validusername\", \"/^[a-zA-Z0-9_]+$/\"),\n                    xwikiname)) {\n                    return -4;\n                }\n            } catch (RuntimeException ex) {\n                LOGGER.warn(\"Invalid regular expression for xwiki.validusername\", ex);\n                if (!context.getUtil().match(\"/^[a-zA-Z0-9_]+$/\", xwikiname)) {\n                    return -4;\n                }\n            }\n\n            if ((!password.equals(password2))) {\n                // TODO: throw wrong password exception\n                return -2;\n            }\n\n            if ((template != null) && (!template.equals(\"\"))) {\n                XWikiDocument tdoc = getDocument(template, context);\n                if ((!tdoc.isNew())) {\n                    // FIXME: This ignores template objects, attachments, etc.\n                    content = tdoc.getContent();\n                    syntax = tdoc.getSyntax();\n                }\n            }\n\n            if ((parent == null) || (parent.equals(\"\"))) {\n                parent = \"XWiki.XWikiUsers\";\n            }\n\n            // Mark the user as active or waiting email validation.\n            if (withValidation) {\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"0\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"0\" });\n\n                validkey = generateValidationKey(16);\n                map.put(\"validkey\", new String[] { validkey });\n\n            } else {\n                // Mark user active\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"1\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"1\" });\n            }\n\n            // Create the user.\n            int result =\n                createUser(xwikiname, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n                    content, syntax, userRights, context);\n\n            // Send validation mail, if needed.\n            if ((result > 0) && (withValidation)) {\n                // Send the validation email\n                try {\n                    sendValidationEmail(xwikiname, password, email, validkey, \"validation_email_content\", context);\n                } catch (XWikiException e) {\n                    LOGGER.warn(\"User created. Failed to send the mail to the created user.\", e);\n                    return -11;\n                }\n\n            }\n\n            return result;\n        } catch (XWikiException e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw e;\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_CREATE_USER,\n                \"Exception while creating user\", e, null);\n        }\n    }\n\n    /**\n     * Method allows to create an empty user with no password (he won't be able to login) This method is usefull for\n     * authentication like LDAP or App Server trusted\n     *\n     * @param xwikiname\n     * @param userRights\n     * @param context see {@link XWikiContext}\n     * @return true if success\n     * @throws XWikiException\n     */\n    public boolean createEmptyUser(String xwikiname, String userRights, XWikiContext context) throws XWikiException\n    {\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"active\", \"1\");\n        map.put(\"first_name\", xwikiname);\n\n        if (createUser(xwikiname, map, userRights, context) == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void sendConfirmationEmail(String xwikiname, String password, String email, String message,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"message\", message, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String validkey,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"validkey\", validkey, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String addfieldname,\n        String addfieldvalue, String contentfield, XWikiContext context) throws XWikiException\n    {\n        MailSenderConfiguration configuration = Utils.getComponent(MailSenderConfiguration.class);\n\n        String sender;\n        String content;\n        try {\n            sender = configuration.getFromAddress();\n            if (StringUtils.isBlank(sender)) {\n                String server = context.getRequest().getServerName();\n                if (server.matches(\"\\\\[.*\\\\]|(\\\\d{1,3}+\\\\.){3}+\\\\d{1,3}+\")) {\n                    sender = \"noreply@domain.net\";\n                } else {\n                    sender = \"noreply@\" + server;\n                }\n            }\n            content = getXWikiPreference(contentfield, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_GET_VALIDATION_CONFIG,\n                \"Exception while reading the validation email config\", e, null);\n\n        }\n\n        try {\n            VelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n            vcontext.put(addfieldname, addfieldvalue);\n            vcontext.put(\"email\", email);\n            vcontext.put(\"password\", password);\n            vcontext.put(\"sender\", sender);\n            vcontext.put(\"xwikiname\", xwikiname);\n            content = parseContent(content, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_PREPARE_VALIDATION_EMAIL,\n                \"Exception while preparing the validation email\", e, null);\n\n        }\n\n        // Let's now send the message\n        try {\n            Session session =\n                Session.getInstance(configuration.getAllProperties(), new XWikiAuthenticator(configuration));\n            InputStream is = new ByteArrayInputStream(content.getBytes());\n            MimeMessage message = new MimeMessage(session, is);\n            message.setFrom(new InternetAddress(sender));\n            message.setRecipients(Message.RecipientType.TO, email);\n            message.setHeader(\"X-MailType\", \"Account Validation\");\n            MailSender mailSender = Utils.getComponent(MailSender.class);\n            MailListener mailListener = Utils.getComponent(MailListener.class, \"database\");\n            mailSender.sendAsynchronously(Arrays.asList(message), session, mailListener);\n            mailListener.getMailStatusResult().waitTillProcessed(Long.MAX_VALUE);\n            String errorMessage = MailStatusResultSerializer.serializeErrors(mailListener.getMailStatusResult());\n            if (errorMessage != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL,\n                    String.format(\"Error while sending the validation email. %s\", errorMessage));\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL, \"Error while sending the validation email\", e);\n        }\n    }\n\n    public String generateRandomString(int size)\n    {\n        return RandomStringUtils.randomAlphanumeric(size);\n    }\n\n    public String generateValidationKey(int size)\n    {\n        return generateRandomString(size);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, XWikiContext context) throws XWikiException\n    {\n        return createUser(userName, map, \"edit\", context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, String userRights, XWikiContext context)\n        throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        String content = \"\";\n        Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n        return createUser(userName, map,\n            new EntityReference(userClass.getDocumentReference().getName(), EntityType.DOCUMENT), content, syntax,\n            userRights, context);\n    }\n\n    /**\n     * @deprecated since 2.4RC1 use\n     *             {@link #createUser(String, Map, EntityReference, String, Syntax, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String userName, Map<String, ?> map, String parent, String content, String syntaxId,\n        String userRights, XWikiContext context) throws XWikiException\n    {\n        Syntax syntax;\n\n        try {\n            syntax = Syntax.valueOf(syntaxId);\n        } catch (ParseException e) {\n            syntax = getDefaultDocumentSyntaxInternal();\n        }\n\n        return createUser(userName, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n            content, syntax, userRights, context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param parentReference the parent of the user profile\n     * @param content the content of the user profile\n     * @param syntax the syntax of the provided content\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, EntityReference parentReference, String content,\n        Syntax syntax, String userRights, XWikiContext context) throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        try {\n            // TODO: Verify existing user\n            XWikiDocument doc = getDocument(new DocumentReference(context.getWikiId(), \"XWiki\", userName), context);\n\n            if (!doc.isNew()) {\n                // TODO: throws Exception\n                return -3;\n            }\n\n            DocumentReference userClassReference = userClass.getDocumentReference();\n            BaseObject userObject =\n                doc.newXObject(userClassReference.removeParent(userClassReference.getWikiReference()), context);\n            userClass.fromMap(map, userObject);\n\n            doc.setParentReference(parentReference);\n            doc.setContent(content);\n            doc.setSyntax(syntax);\n\n            // Set the user itself as the creator of the document, so that she has the CREATOR right on her user page.\n            doc.setCreatorReference(doc.getDocumentReference());\n\n            // However, we use the context user for the author to see in the history who has really created the user\n            // (it may be an administrator).\n            if (context.getUserReference() != null) {\n                doc.setAuthorReference(context.getUserReference());\n            } else {\n                // Except if the current user is guest (which means the user registered herself)\n                doc.setAuthorReference(doc.getDocumentReference());\n            }\n\n            // The information from the user profile needs to be indexed using the proper locale. If multilingual is\n            // enabled then the user can choose the desired locale (from the list of supported locales) before\n            // registering. An administrator registering users can do the same. Otherwise, if there is only one locale\n            // supported then that langage will be used.\n            doc.setDefaultLocale(context.getLocale());\n\n            protectUserPage(doc.getFullName(), userRights, doc, context);\n\n            saveDocument(doc, localizePlainOrKey(\"core.comment.createdUser\"), context);\n\n            // Now let's add the user to XWiki.XWikiAllGroup\n            setUserDefaultGroup(doc.getFullName(), context);\n\n            return 1;\n        } catch (Exception e) {\n            Object[] args = { \"XWiki.\" + userName };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_CREATE,\n                \"Cannot create user {0}\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated starting with XE 1.8.1 use\n     *             {@link #createUser(String, Map, String, String, String, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String xwikiname, Map<String, ?> map, String parent, String content, String userRights,\n        XWikiContext context) throws XWikiException\n    {\n        return createUser(xwikiname, map, parent, content, Syntax.XWIKI_1_0.toIdString(), userRights, context);\n    }\n\n    public void setUserDefaultGroup(String fullwikiname, XWikiContext context) throws XWikiException\n    {\n        String groupsPreference = isAllGroupImplicit() ? getConfiguration().getProperty(\"xwiki.users.initialGroups\")\n            : getConfiguration().getProperty(\"xwiki.users.initialGroups\", \"XWiki.XWikiAllGroup\");\n\n        if (groupsPreference != null) {\n            String[] groups = groupsPreference.split(\",\");\n            for (String groupName : groups) {\n                if (StringUtils.isNotBlank(groupName)) {\n                    addUserToGroup(fullwikiname, groupName.trim(), context);\n                }\n            }\n        }\n    }\n\n    protected void addUserToGroup(String userName, String groupName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groupDoc = getDocument(groupName, context);\n\n        DocumentReference groupClassReference = getGroupClass(context).getDocumentReference();\n        BaseObject memberObject =\n            groupDoc.newXObject(groupClassReference.removeParent(groupClassReference.getWikiReference()), context);\n\n        memberObject.setStringValue(\"member\", userName);\n\n        this.saveDocument(groupDoc, localizePlainOrKey(\"core.comment.addedUserToGroup\"), context);\n    }\n\n    public void protectUserPage(String userName, String userRights, XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference rightClassReference = getRightsClass(context).getDocumentReference();\n\n        EntityReference relativeRightClassReference =\n            rightClassReference.removeParent(rightClassReference.getWikiReference());\n\n        // Allow users to edit their own profiles\n        BaseObject newuserrightsobject = doc.newXObject(relativeRightClassReference, context);\n        newuserrightsobject.setLargeStringValue(\"users\", userName);\n        newuserrightsobject.setStringValue(\"levels\", userRights);\n        newuserrightsobject.setIntValue(\"allow\", 1);\n    }\n\n    public User getUser(XWikiContext context)\n    {\n        return getUser(context.getUserReference(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link #getUser(DocumentReference, XWikiContext)}.\n     */\n    @Deprecated\n    public User getUser(String username, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(username);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Retrieve a user from its document reference.\n     *\n     * @param userReference the reference of the user.\n     * @param context the current context.\n     * @return the user corresponding to that document reference.\n     * @since 11.8RC1\n     */\n    public User getUser(DocumentReference userReference, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(userReference);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Prepares the localized resources, according to the selected locale. Set context \"msg\" and locale.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void prepareResources(XWikiContext context)\n    {\n        if (context.get(\"msg\") == null) {\n            Locale locale = getLocalePreference(context);\n            context.setLocale(locale);\n            if (context.getResponse() != null) {\n                context.getResponse().setLocale(locale);\n            }\n            XWikiMessageTool msg = new XWikiMessageTool(Utils.getComponent(ContextualLocalizationManager.class));\n            context.put(\"msg\", msg);\n        }\n    }\n\n    public XWikiUser checkAuth(XWikiContext context) throws XWikiException\n    {\n        return getAuthService().checkAuth(context);\n    }\n\n    public boolean checkAccess(String action, XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // Handle the 'skin' action specially so that resources don`t require special (or even 'view') rights.\n        String firstSpaceName = doc.getDocumentReference().getSpaceReferences().get(0).getName();\n        if (action.equals(\"skin\") && SKIN_RESOURCE_SPACE_NAMES.contains(firstSpaceName)) {\n            // We still need to call checkAuth to set the proper user.\n            XWikiUser user = checkAuth(context);\n            if (user != null) {\n                context.setUser(user.getUser());\n            }\n\n            // Always allow.\n            return true;\n        }\n\n        return getRightService().checkAccess(action, doc, context);\n    }\n\n    public String include(String topic, boolean isForm, XWikiContext context) throws XWikiException\n    {\n        String database = null, incdatabase = null;\n        String prefixedTopic, localTopic;\n\n        // Save current documents in script context\n        Document currentAPIdoc = null, currentAPIcdoc = null, currentAPItdoc = null;\n        ScriptContextManager scritContextManager = Utils.getComponent(ScriptContextManager.class);\n        ScriptContext scontext = scritContextManager.getScriptContext();\n        String currentDocName = context.getWikiId() + \":\" + context.getDoc().getFullName();\n        if (scontext != null) {\n            currentAPIdoc = (Document) scontext.getAttribute(\"doc\");\n            currentAPIcdoc = (Document) scontext.getAttribute(\"cdoc\");\n            currentAPItdoc = (Document) scontext.getAttribute(\"tdoc\");\n        }\n\n        try {\n            int i0 = topic.indexOf(':');\n            if (i0 != -1) {\n                incdatabase = topic.substring(0, i0);\n                database = context.getWikiId();\n                context.setWikiId(incdatabase);\n                prefixedTopic = topic;\n                localTopic = topic.substring(i0 + 1);\n            } else {\n                prefixedTopic = context.getWikiId() + \":\" + topic;\n                localTopic = topic;\n            }\n\n            XWikiDocument doc = null;\n            try {\n                LOGGER.debug(\"Including Topic \" + topic);\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                    if (includedDocs == null) {\n                        includedDocs = new HashSet<String>();\n                        context.put(\"included_docs\", includedDocs);\n                    }\n\n                    if (includedDocs.contains(prefixedTopic) || currentDocName.equals(prefixedTopic)) {\n                        LOGGER.warn(\"Error on too many recursive includes for topic \" + topic);\n                        return \"Cannot make recursive include\";\n                    }\n                    includedDocs.add(prefixedTopic);\n                } catch (Exception e) {\n                }\n\n                // Get document to include\n                DocumentReference targetDocumentReference =\n                    getCurrentMixedDocumentReferenceResolver().resolve(localTopic);\n                doc = getDocument(targetDocumentReference, context);\n\n                if (checkAccess(\"view\", doc, context) == false) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED, \"Access to this document is denied: \" + doc);\n                }\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Exception Including Topic \" + topic, e);\n                return \"Topic \" + topic + \" does not exist\";\n            }\n\n            XWikiDocument contentdoc = doc.getTranslatedDocument(context);\n\n            String result;\n            if (isForm) {\n                // We do everything in the context of the including document\n                if (database != null) {\n                    context.setWikiId(database);\n                }\n\n                // Note: the Script macro in the new rendering checks for programming rights for the document in\n                // the xwiki context.\n                result = getRenderedContent(contentdoc, (XWikiDocument) context.get(\"doc\"), context);\n            } else {\n                // We stay in the included document context\n\n                // Since the Script macro checks for programming rights in the current document, we need to\n                // temporarily set the contentdoc as the current doc before rendering it.\n                XWikiDocument originalDoc = null;\n                try {\n                    originalDoc = context.getDoc();\n                    context.put(\"doc\", doc);\n                    result = getRenderedContent(contentdoc, doc, context);\n                } finally {\n                    context.put(\"doc\", originalDoc);\n                }\n            }\n            try {\n                @SuppressWarnings(\"unchecked\")\n                Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                if (includedDocs != null) {\n                    includedDocs.remove(prefixedTopic);\n                }\n            } catch (Exception e) {\n            }\n            return result;\n        } finally {\n            if (database != null) {\n                context.setWikiId(database);\n            }\n\n            if (currentAPIdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"doc\", currentAPIdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPIcdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"cdoc\", currentAPIcdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPItdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"tdoc\", currentAPItdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n        }\n    }\n\n    /**\n     * Render content from the passed included document, setting the correct security doc (sdoc) and including doc\n     * (idoc).\n     *\n     * @since 2.2M2\n     */\n    private String getRenderedContent(XWikiDocument includedDoc, XWikiDocument includingDoc, XWikiContext context)\n        throws XWikiException\n    {\n        String result;\n        XWikiDocument idoc = (XWikiDocument) context.get(\"idoc\");\n        XWikiDocument sdoc = (XWikiDocument) context.get(\"sdoc\");\n\n        context.put(\"idoc\", includingDoc);\n        context.put(\"sdoc\", includedDoc);\n        try {\n            result = includedDoc.getRenderedContent(Utils.getComponent(RenderingContext.class).getTargetSyntax(), false,\n                context);\n        } finally {\n            // Remove including doc or set the previous one\n            if (idoc == null) {\n                context.remove(\"idoc\");\n            } else {\n                context.put(\"idoc\", idoc);\n            }\n\n            // Remove security doc or set the previous one\n            if (sdoc == null) {\n                context.remove(\"sdoc\");\n            } else {\n                context.put(\"sdoc\", sdoc);\n            }\n        }\n\n        return result;\n    }\n\n    public void deleteDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, true, context);\n    }\n\n    public void deleteDocument(XWikiDocument doc, boolean totrash, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, totrash, true, context);\n    }\n\n    private XWikiDocument prepareDocumentDelete(XWikiDocument doc, XWikiContext context)\n    {\n        // The source document is a new empty XWikiDocument to follow\n        // DocumentUpdatedEvent policy: source document in new document and the old version is available using\n        // doc.getOriginalDocument()\n        XWikiDocument blankDoc = new XWikiDocument(doc.getDocumentReference());\n        // Again to follow general event policy, new document author is the user who modified the document\n        // (here the modification is delete)\n        blankDoc.setOriginalDocument(doc.getOriginalDocument());\n        blankDoc.setAuthorReference(context.getUserReference());\n        blankDoc.setContentAuthorReference(context.getUserReference());\n\n        return blankDoc;\n    }\n\n    private XWikiDocument beforeDelete(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument blankDoc = prepareDocumentDelete(doc, context);\n\n        ObservationManager om = getObservationManager();\n\n        // Inform notification mechanisms that a document is about to be deleted\n        // Note that for the moment the event being send is a bridge event, as we are still passing around\n        // an XWikiDocument as source and an XWikiContext as data.\n        if (om != null) {\n            CancelableEvent documentEvent = new DocumentDeletingEvent(doc.getDocumentReference());\n            om.notify(documentEvent, blankDoc, context);\n\n            // If the action has been canceled by the user then don't perform any deletion and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC,\n                    String.format(\"An Event Listener has cancelled the document deletion for [%s]. Reason: [%s]\",\n                        doc.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n\n        return blankDoc;\n    }\n\n    private void afterDelete(XWikiDocument blankDoc, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new DocumentDeletedEvent(blankDoc.getDocumentReference()), blankDoc, context);\n        }\n    }\n\n    private void deleteDocument(XWikiDocument doc, boolean totrash, boolean notify, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = null;\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (notify) {\n                blankDoc = beforeDelete(doc, context);\n            }\n\n            if (hasRecycleBin(context) && totrash) {\n                // Extract any existing batchId from the context.\n                String batchId = Utils.getComponent(BatchOperationExecutor.class).getCurrentBatchId();\n\n                // Save to recycle bin together with any determined batch ID.\n                getRecycleBinStore().saveToRecycleBin(doc, context.getUser(), new Date(), batchId, context, true);\n            }\n\n            getStore().deleteXWikiDoc(doc, context);\n\n            try {\n                // Inform notification mechanisms that a document has been deleted\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                if (notify) {\n                    afterDelete(blankDoc, context);\n                }\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document delete notifications for document [{}]\",\n                    doc.getDocumentReference(), ex);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Check if the user is allowed to delete the document.\n     * \n     * @param userReference the user responsible for the delete\n     * @param document the document to delete\n     * @param context the XWiki context\n     * @throws XWikiException when failing to delete\n     * @since 11.6\n     * @since 10.11.10\n     */\n    public void checkDeletingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = prepareDocumentDelete(document, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (om != null) {\n                CancelableEvent documentEvent =\n                    new UserDeletingDocumentEvent(userReference, document.getDocumentReference());\n                om.notify(documentEvent, blankDoc, context);\n\n                // If the action has been canceled by the user then don't perform any deletion and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to delete the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    public String getDatabase()\n    {\n        return this.database;\n    }\n\n    public void setDatabase(String database)\n    {\n        this.database = database;\n    }\n\n    public void gc()\n    {\n        System.gc();\n    }\n\n    public long freeMemory()\n    {\n        return Runtime.getRuntime().freeMemory();\n    }\n\n    public long totalMemory()\n    {\n        return Runtime.getRuntime().totalMemory();\n    }\n\n    public long maxMemory()\n    {\n        return Runtime.getRuntime().maxMemory();\n    }\n\n    public String[] split(String str, String sep)\n    {\n        return StringUtils.split(str, sep);\n    }\n\n    /**\n     * @deprecated use {@link ExceptionUtils#getStackTrace(Throwable)} instead\n     */\n    @Deprecated\n    public String printStrackTrace(Throwable e)\n    {\n        StringWriter strwriter = new StringWriter();\n        PrintWriter writer = new PrintWriter(strwriter);\n        e.printStackTrace(writer);\n\n        return strwriter.toString();\n    }\n\n    /**\n     * API to rename a document to another document.\n     *\n     * @param sourceDocumentReference the source document to rename.\n     * @param targetDocumentReference the target reference to rename the document to.\n     * @param overwrite if {@code true} the target document reference will be overwritten if it exists\n     *                  (deleted to the recycle bin before the rename). If {@code false} and the target document exist\n     *                  the rename won't be performed.\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *                                  modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *                                 document reference\n     * @return {@code true} if the rename succeeded. {@code false} if there was any issue.\n     * @throws XWikiException if the document cannot be renamed properly.\n     * @since 12.5RC1\n     */\n    @Unstable\n    public boolean renameDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean overwrite, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences, XWikiContext context)\n        throws XWikiException\n    {\n        boolean result = false;\n\n        // if source and destination are same, no need to perform the rename.\n        if (!sourceDocumentReference.equals(targetDocumentReference)) {\n            XWikiDocument sourceDocument = this.getDocument(sourceDocumentReference, context);\n            XWikiDocument targetDocument = this.getDocument(targetDocumentReference, context);\n\n            ConfigurationSource xwikiproperties = Utils.getComponent(ConfigurationSource.class, \"xwikiproperties\");\n            boolean useAtomicRename = xwikiproperties.getProperty(\"refactoring.rename.useAtomicRename\", Boolean.TRUE);\n\n            // Proceed on the rename only if the source document exists and if either the targetDoc does not exist or\n            // the overwritten is accepted.\n            if (!sourceDocument.isNew() && (overwrite || targetDocument.isNew())) {\n                if (!useAtomicRename) {\n                    this.renameByCopyAndDelete(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                } else {\n                    // Ensure that the current context contains the wiki reference of the source document.\n                    WikiReference wikiReference = context.getWikiReference();\n                    context.setWikiReference(sourceDocumentReference.getWikiReference());\n\n                    // Step 1: Simulate creating a document and deleting a document from listeners point of view\n                    // FIXME: currently modifications made by listeners won't be applied\n                    XWikiDocument futureTargetDocument = sourceDocument.cloneRename(targetDocumentReference, context);\n                    futureTargetDocument.setOriginalDocument(new XWikiDocument(targetDocumentReference));\n                    beforeSave(futureTargetDocument, context);\n                    XWikiDocument deletedDocument = beforeDelete(sourceDocument, context);\n\n                    // Step 2: Perform atomic rename in DB\n                    try {\n                        this.getStore().renameXWikiDoc(sourceDocument, targetDocumentReference, context);\n                    } finally {\n                        context.setWikiReference(wikiReference);\n                    }\n\n                    // Step 3: Simulate a created document and a deleted document from listeners point of view\n                    targetDocument = this.getDocument(targetDocumentReference, context);\n                    afterDelete(deletedDocument, context);\n                    afterSave(futureTargetDocument, context);\n\n                    // Step 4: For each child document, update its parent reference.\n                    // Step 5: For each backlink to rename, parse the backlink document and replace the links with\n                    // the new name.\n                    // Step 6: Refactor the relative links contained in the document to make sure they are relative\n                    // to the new document's location.\n                    this.updateLinksForRename(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private void updateLinksForRename(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 2: For each child document, update its parent reference.\n        if (childDocumentReferences != null) {\n            for (DocumentReference childDocumentReference : childDocumentReferences) {\n                XWikiDocument childDocument = getDocument(childDocumentReference, context);\n                String compactReference = getCompactEntityReferenceSerializer().serialize(newDocumentReference);\n                childDocument.setParent(compactReference);\n                String saveMessage = localizePlainOrKey(\"core.comment.renameParent\", compactReference);\n                childDocument.setAuthorReference(context.getUserReference());\n                saveDocument(childDocument, saveMessage, true, context);\n            }\n        }\n\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        for (DocumentReference backlinkDocumentReference : backlinkDocumentReferences) {\n            XWikiDocument backlinkRootDocument = getDocument(backlinkDocumentReference, context);\n\n            // Update default locale instance\n            renameLinks(backlinkRootDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n\n            // Update translations\n            for (Locale locale : backlinkRootDocument.getTranslationLocales(context)) {\n                XWikiDocument backlinkDocument = backlinkRootDocument.getTranslatedDocument(locale, context);\n\n                renameLinks(backlinkDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n            }\n        }\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        if (Utils.getContextComponentManager().hasComponent(BlockRenderer.class, sourceDoc.getSyntax().toIdString())) {\n            // Only support syntax for which a renderer is provided\n\n            LinkedResourceHelper linkedResourceHelper = Utils.getComponent(LinkedResourceHelper.class);\n\n            DocumentReference oldDocumentReference = sourceDoc.getDocumentReference();\n\n            XDOM newDocumentXDOM = newDocument.getXDOM();\n            List<Block> blocks = linkedResourceHelper.getBlocks(newDocumentXDOM);\n\n            // FIXME: Duplicate code. See org.xwiki.refactoring.internal.DefaultLinkRefactoring#updateRelativeLinks in\n            // xwiki-platform-refactoring-default\n            boolean modified = false;\n            for (Block block : blocks) {\n                org.xwiki.rendering.listener.reference.ResourceReference resourceReference =\n                    linkedResourceHelper.getResourceReference(block);\n                if (resourceReference == null) {\n                    // Skip invalid blocks.\n                    continue;\n                }\n\n                org.xwiki.rendering.listener.reference.ResourceType resourceType = resourceReference.getType();\n\n                // TODO: support ATTACHMENT as well.\n                if (!org.xwiki.rendering.listener.reference.ResourceType.DOCUMENT.equals(resourceType) &&\n                    !org.xwiki.rendering.listener.reference.ResourceType.SPACE.equals(resourceType)) {\n                    // We are currently only interested in Document or Space references.\n                    continue;\n                }\n\n                // current link, use the old document's reference to fill in blanks.\n                EntityReference oldLinkReference = getResourceReferenceEntityReferenceResolver()\n                    .resolve(resourceReference, null, oldDocumentReference);\n                // new link, use the new document's reference to fill in blanks.\n                EntityReference newLinkReference = getResourceReferenceEntityReferenceResolver()\n                    .resolve(resourceReference, null, newDocumentReference);\n\n                // If the new and old link references don`t match, then we must update the relative link.\n                if (!newLinkReference.equals(oldLinkReference)) {\n                    modified = true;\n\n                    // Serialize the old (original) link relative to the new document's location, in compact form.\n                    String serializedLinkReference =\n                        getCompactWikiEntityReferenceSerializer().serialize(oldLinkReference, newDocumentReference);\n\n                    // Update the reference in the XDOM.\n                    linkedResourceHelper.setResourceReferenceString(block, serializedLinkReference);\n                }\n            }\n\n            // Set the new content and save document if needed\n            if (modified) {\n                newDocument.setContent(newDocumentXDOM);\n                newDocument.setAuthorReference(context.getUserReference());\n                saveDocument(newDocument, context);\n            }\n        }\n    }\n\n    /**\n     * Perform a rename of document by copying the document and deleting the old one.\n     * This operation must be used only in case of document rename from one wiki to another, since it's not supported\n     * by the atomic store operation.\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *            document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 12.5\n     * @deprecated Old implementation of the rename by copy and delete. Since 12.5 the implementation using\n     * {@link XWikiStoreInterface#renameXWikiDoc(XWikiDocument, DocumentReference, XWikiContext)} should be preferred.\n     */\n    @Deprecated\n    @Unstable\n    public void renameByCopyAndDelete(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 1: Copy the document and all its translations under a new document with the new reference.\n        copyDocument(sourceDoc.getDocumentReference(), newDocumentReference, false, context);\n\n        // Step 2: For each child document, update its parent reference.\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        updateLinksForRename(sourceDoc, newDocumentReference, backlinkDocumentReferences, childDocumentReferences,\n            context);\n\n        // Step 5: Delete the old document\n        deleteDocument(sourceDoc, context);\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 6: The current document needs to point to the renamed document as otherwise it's pointing to an\n        // invalid XWikiDocument object as it's been deleted...\n        sourceDoc.clone(newDocument);\n    }\n\n    /**\n     * Rename links in passed document and save it if needed.\n     */\n    private void renameLinks(XWikiDocument backlinkDocument, DocumentReference oldLink, DocumentReference newLink,\n        XWikiContext context) throws XWikiException\n    {\n        // FIXME: Duplicate code. See org.xwiki.refactoring.internal.DefaultLinkRefactoring#renameLinks in\n        // xwiki-platform-refactoring-default\n        getOldRendering().renameLinks(backlinkDocument, oldLink, newLink, context);\n\n        // Save if content changed\n        if (backlinkDocument.isContentDirty()) {\n            String saveMessage =\n                localizePlainOrKey(\"core.comment.renameLink\", getCompactEntityReferenceSerializer().serialize(newLink));\n            backlinkDocument.setAuthorReference(context.getUserReference());\n            context.getWiki().saveDocument(backlinkDocument, saveMessage, true, context);\n        }\n    }\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private static EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (compact form).\n     */\n    private static EntityReferenceSerializer<String> getCompactEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n    }\n\n    /**\n     * Used to resolve a ResourceReference into a proper Entity Reference using the current document to fill the blanks.\n     */\n    private static EntityReferenceResolver<org.xwiki.rendering.listener.reference.ResourceReference>\n        getResourceReferenceEntityReferenceResolver()\n    {\n        return Utils\n            .getComponent(new DefaultParameterizedType(null, EntityReferenceResolver.class,\n                org.xwiki.rendering.listener.reference.ResourceReference.class));\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, boolean force, boolean resetCreationData, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, force, resetCreationData,\n            context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, force, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, boolean resetCreationData, XWikiContext context)\n        throws XWikiException\n    {\n        String db = context.getWikiId();\n        String sourceWiki = sourceDocumentReference.getWikiReference().getName();\n        String targetWiki = targetDocumentReference.getWikiReference().getName();\n\n        String sourceStringReference = getDefaultEntityReferenceSerializer().serialize(sourceDocumentReference);\n\n        try {\n            context.setWikiId(sourceWiki);\n            XWikiDocument sdoc = getDocument(sourceDocumentReference, context);\n            if (!sdoc.isNew()) {\n                LOGGER.info(\"Copying document [{}] to [{}]\", sourceDocumentReference, targetDocumentReference);\n\n                // Let's switch to the other database to verify if the document already exists\n                context.setWikiId(targetWiki);\n                XWikiDocument previoustdoc = getDocument(targetDocumentReference, context);\n                // There is already an existing document\n                if (!previoustdoc.isNew()) {\n                    if (!force) {\n                        return false;\n                    }\n                }\n\n                // Let's switch back again to the original db\n                context.setWikiId(sourceWiki);\n\n                if (wikilocale == null) {\n                    XWikiDocument tdoc = sdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // We don't want to trigger a new version otherwise the version number will be wrong.\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        context.setWikiId(targetWiki);\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n\n                    // Now we need to copy the translations\n                    context.setWikiId(sourceWiki);\n                    List<String> tlist = sdoc.getTranslationList(context);\n                    for (String clanguage : tlist) {\n                        XWikiDocument stdoc = sdoc.getTranslatedDocument(clanguage, context);\n                        LOGGER.info(\"Copying document [{}], language [{}] to [{}]\", sourceWiki, clanguage,\n                            targetDocumentReference);\n\n                        context.setWikiId(targetWiki);\n                        XWikiDocument ttdoc = tdoc.getTranslatedDocument(clanguage, context);\n\n                        // There is already an existing document\n                        if (ttdoc != tdoc) {\n                            return false;\n                        }\n\n                        // Let's switch back again to the original db\n                        context.setWikiId(sourceWiki);\n\n                        ttdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                        // Make sure to replace the existing document if any\n                        ttdoc.setNew(true);\n\n                        // forget past versions\n                        if (reset) {\n                            ttdoc.setNew(true);\n                            ttdoc.setVersion(\"1.1\");\n                        }\n                        if (resetCreationData) {\n                            Date now = new Date();\n                            ttdoc.setCreationDate(now);\n                            ttdoc.setContentUpdateDate(now);\n                            ttdoc.setDate(now);\n                            ttdoc.setCreatorReference(context.getUserReference());\n                            ttdoc.setAuthorReference(context.getUserReference());\n                        }\n\n                        // we don't want to trigger a new version\n                        // otherwise the version number will be wrong\n                        tdoc.setMetaDataDirty(false);\n                        tdoc.setContentDirty(false);\n\n                        saveDocument(ttdoc, \"Copied from \" + sourceStringReference, context);\n\n                        if (!reset) {\n                            context.setWikiId(sourceWiki);\n                            XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                            context.setWikiId(targetWiki);\n                            txda = txda.clone(tdoc.getId(), context);\n                            getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                        } else {\n                            getVersioningStore().resetRCSArchive(tdoc, true, context);\n                        }\n                    }\n                } else {\n                    // We want only one language in the end\n                    XWikiDocument stdoc = sdoc.getTranslatedDocument(wikilocale, context);\n\n                    XWikiDocument tdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget language\n                    tdoc.setDefaultLanguage(wikilocale);\n                    tdoc.setLanguage(\"\");\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // we don't want to trigger a new version\n                    // otherwise the version number will be wrong\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n                }\n            }\n            return true;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale,\n        XWikiContext context) throws XWikiException\n    {\n        return copySpaceBetweenWikis(space, sourceWiki, targetWiki, locale, false, context);\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale, boolean clean,\n        XWikiContext context) throws XWikiException\n    {\n        String db = context.getWikiId();\n        int nb = 0;\n        // Workaround for XWIKI-3915: Do not use XWikiStoreInterface#searchDocumentNames since currently it has the\n        // side effect of hidding hidden documents and no other workaround exists than directly using\n        // XWikiStoreInterface#search directly\n        String sql = \"select distinct doc.fullName from XWikiDocument as doc\";\n        List<String> parameters = new ArrayList<>();\n        if (space != null) {\n            parameters.add(space);\n            sql += \" where doc.space = ?\" + parameters.size();\n        }\n\n        if (clean) {\n            try {\n                context.setWikiId(targetWiki);\n                List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n                LOGGER.info(\"Deleting [{}] documents from wiki [{}]\", list.size(), targetWiki);\n\n                for (String docname : list) {\n                    XWikiDocument doc = getDocument(docname, context);\n                    deleteDocument(doc, context);\n                }\n            } finally {\n                context.setWikiId(db);\n            }\n        }\n\n        try {\n            context.setWikiId(sourceWiki);\n            List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n            LOGGER.info(\"Copying [{}] documents from wiki [{}] to wiki [{}]\", list.size(), sourceWiki, targetWiki);\n\n            WikiReference sourceWikiReference = new WikiReference(sourceWiki);\n            WikiReference targetWikiReference = new WikiReference(targetWiki);\n            for (String docname : list) {\n                DocumentReference sourceDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n                sourceDocumentReference = sourceDocumentReference\n                    .replaceParent(sourceDocumentReference.getWikiReference(), sourceWikiReference);\n                DocumentReference targetDocumentReference =\n                    sourceDocumentReference.replaceParent(sourceWikiReference, targetWikiReference);\n                copyDocument(sourceDocumentReference, targetDocumentReference, locale, context);\n                nb++;\n            }\n            return nb;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     * <p>\n     * It does not override document already existing in target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, XWikiContext context) throws XWikiException\n    {\n        return copyWiki(sourceWiki, targetWiki, locale, false, context);\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param clean clean the target wiki before copying\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, boolean clean, XWikiContext context)\n        throws XWikiException\n    {\n        int documents = copySpaceBetweenWikis(null, sourceWiki, targetWiki, locale, clean, context);\n\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new WikiCopiedEvent(sourceWiki, targetWiki), sourceWiki, context);\n        }\n\n        return documents;\n    }\n\n    public String getEncoding()\n    {\n        return getConfiguration().getProperty(\"xwiki.encoding\", \"UTF-8\");\n    }\n\n    public URL getServerURL(String wikiId, XWikiContext xcontext) throws MalformedURLException\n    {\n        // In path based the base URL is the same for all wikis\n        if (!xcontext.isMainWiki(wikiId) && isPathBased()) {\n            return getServerURL(xcontext.getMainXWiki(), xcontext);\n        }\n\n        // If main wiki check the main wiki home page configuration\n        if (xcontext.isMainWiki(wikiId)) {\n            String homepage = getConfiguration().getProperty(\"xwiki.home\");\n            if (StringUtils.isNotEmpty(homepage)) {\n                try {\n                    return new URL(homepage);\n                } catch (MalformedURLException e) {\n                    LOGGER.warn(\"Invalid main wiki home page URL [{}] configured: {}\", homepage,\n                        ExceptionUtils.getRootCauseMessage(e));\n                }\n            }\n        }\n\n        if (wikiId != null) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiId);\n                if (wikiDescriptor != null) {\n                    String server = wikiDescriptor.getDefaultAlias();\n                    if (server != null) {\n                        String protocol = getWikiProtocol(wikiDescriptor);\n                        int port = getWikiPort(wikiDescriptor, xcontext);\n\n                        if (protocol == null && port == -1) {\n                            // If request is a \"real\" one keep using the same protocol/port (if asking for the same wiki)\n                            XWikiRequest request = xcontext.getRequest();\n                            if (request != null && wikiDescriptor.getId().equals(xcontext.getOriginalWikiId())\n                                && !isDaemon(request)) {\n                                URL sourceURL = HttpServletUtils.getSourceBaseURL(xcontext.getRequest());\n\n                                protocol = sourceURL.getProtocol();\n                                port = sourceURL.getPort();\n                            } else {\n                                // Default to HTTP\n                                protocol = \"http\";\n                            }\n                        }\n\n                        return new URL(protocol != null ? protocol : (port == 443 ? \"https\" : \"http\"), server, port,\n                            \"\");\n                    }\n                }\n            } catch (WikiManagerException e) {\n                LOGGER.error(\"Failed to get descriptor for wiki [{}]\", wikiId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private boolean isDaemon(XWikiRequest request)\n    {\n        return request.getHttpServletRequest() instanceof XWikiServletRequestStub\n            && ((XWikiServletRequestStub) request.getHttpServletRequest()).isDaemon();\n    }\n\n    private String getWikiProtocol(WikiDescriptor wikiDescriptor)\n    {\n        // Try wiki descriptor\n        Boolean secure = wikiDescriptor.isSecure();\n        if (secure != null) {\n            return wikiDescriptor.isSecure() == Boolean.TRUE ? \"https\" : \"http\";\n        }\n\n        // Try configuration\n        String protocol = getConfiguration().getProperty(\"xwiki.url.protocol\");\n        if (protocol != null) {\n            return protocol;\n        }\n\n        // Try main wiki\n        try {\n            secure = getWikiDescriptorManager().getMainWikiDescriptor().isSecure();\n\n            if (secure != null) {\n                return secure ? \"https\" : \"http\";\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return null;\n    }\n\n    private int getWikiPort(WikiDescriptor wikiDescriptor, XWikiContext context)\n    {\n        // Try wiki descriptor\n        int port = wikiDescriptor.getPort();\n        if (port != -1) {\n            return port;\n        }\n\n        // Try main wiki\n        try {\n            port = getWikiDescriptorManager().getMainWikiDescriptor().getPort();\n\n            if (port != -1) {\n                return port;\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return -1;\n    }\n\n    public String getServletPath(String wikiName, XWikiContext context)\n    {\n        // unless we are in virtual wiki path mode we should return null\n        if (!context.isMainWiki(wikiName) && isPathBased()) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiName);\n                if (wikiDescriptor != null) {\n                    return \"wiki/\" + wikiDescriptor.getDefaultAlias() + \"/\";\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to get URL for provided wiki [\" + wikiName + \"]\", e);\n            }\n        }\n\n        String servletPath = getConfiguration().getProperty(\"xwiki.servletpath\", \"\");\n\n        if (context.getRequest() != null) {\n            if (StringUtils.isEmpty(servletPath)) {\n                String currentServletpath = context.getRequest().getServletPath();\n                if (currentServletpath != null && currentServletpath.startsWith(\"/bin\")) {\n                    servletPath = \"bin/\";\n                } else {\n                    servletPath = getConfiguration().getProperty(\"xwiki.defaultservletpath\", \"bin/\");\n                }\n            }\n        }\n\n        return servletPath;\n    }\n\n    public String getWebAppPath(XWikiContext context)\n    {\n        String contextPath = getConfiguration().getProperty(\"xwiki.webapppath\");\n        if (contextPath == null) {\n            // Try getting the context path by asking the request for it (if a request exists!) and if it doesn't\n            // work try extracting it from the context URL.\n            // TODO: Instead of trying to extract from the URL, save the context path at webapp init (using a\n            // ServlettContextListener for example).\n            XWikiRequest request = context.getRequest();\n            if (request != null) {\n                contextPath = request.getContextPath();\n            }\n            if (contextPath == null) {\n                // Extract the context by getting the first path segment\n                contextPath = StringUtils.substringBefore(StringUtils.stripStart(context.getURL().getPath(), \"/\"), \"/\");\n            }\n        }\n\n        // Remove any leading or trailing slashes\n        contextPath = StringUtils.strip(contextPath, \"/\");\n\n        // TODO We're using URL parts in a wrong way, since contextPath and servletPath are returned with a leading /,\n        // while we need a trailing /. This code ensure we always have CONTEXTNAME + \"/\".\n        return contextPath + \"/\";\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference entityReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // TODO: replace this API with a clean implementation of EntityResourceReferenceSerializer\n\n        // Handle attachment URL\n        if (EntityType.ATTACHMENT.equals(entityReference.getType())) {\n            // Get the full attachment reference\n            AttachmentReference attachmentReference = getCurrentAttachmentResolver().resolve(entityReference);\n            return getAttachmentURL(attachmentReference, action, queryString, context);\n        }\n\n        // For all other types, we return the URL of the default corresponding document.\n        DocumentReference documentReference = getDocumentReference(entityReference, context);\n        return getURL(documentReference, action, queryString, anchor, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public String getURL(EntityReference reference, XWikiContext context)\n    {\n        String action = \"view\";\n        if (reference.getType() == EntityType.ATTACHMENT) {\n            action = \"download\";\n        }\n        return getURL(reference, action, context);\n    }\n\n    /**\n     * @since 2.2.1\n     */\n    public String getURL(DocumentReference documentReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // We need to serialize the space reference because the old createURL() API doesn't accept a DocumentReference.\n        String spaces = getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference());\n\n        // Take into account the specified document locale.\n        Locale documentLocale = documentReference.getLocale();\n        String actualQueryString = queryString;\n        if (documentLocale != null && documentLocale != Locale.ROOT) {\n            String localeQueryString = \"language=\" + documentLocale;\n            if (StringUtils.isEmpty(queryString)) {\n                actualQueryString = localeQueryString;\n            } else {\n                // Note: if the locale is already specified on the given query string then it won't be overwriten\n                // because the first parameter value is taken into account.\n                actualQueryString += '&' + localeQueryString;\n            }\n        }\n\n        URL url = context.getURLFactory().createURL(spaces, documentReference.getName(), action, actualQueryString,\n            anchor, documentReference.getWikiReference().getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #getURL(DocumentReference, String, String, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, String queryString, String anchor, XWikiContext context)\n    {\n        return getURL(getCurrentMixedDocumentReferenceResolver().resolve(fullname), action, queryString, anchor,\n            context);\n    }\n\n    public String getURL(String fullname, String action, String querystring, XWikiContext context)\n    {\n        return getURL(fullname, action, querystring, null, context);\n    }\n\n    /**\n     * @since 2.3M2\n     */\n    public String getURL(DocumentReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @deprecated since 2.3M2 use {@link #getURL(DocumentReference, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, XWikiContext context)\n    {\n        return getURL(fullname, action, null, null, context);\n    }\n\n    public String getExternalURL(String fullname, String action, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, null, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getExternalURL(String fullname, String action, String querystring, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, querystring, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    /**\n     * Get the full URL of the given {@link DocumentReference}. This also includes the server name of the wiki.\n     *\n     * @param documentReference the document that should be resolved\n     * @param action the action of the URL\n     * @param querystring the URL parameters\n     * @param anchor the anchor of the document\n     * @param context the current XWikiContext\n     * @return the full URL of the given reference\n     * @since 9.6RC1\n     */\n    public String getExternalURL(DocumentReference documentReference, String action, String querystring, String anchor,\n        XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(\n            this.getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference()),\n            documentReference.getName(), action, querystring, anchor, documentReference.getWikiReference().getName(),\n            context);\n        return url.toString();\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String action, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), action, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String queryString, XWikiContext context)\n    {\n        return getAttachmentURL(attachmentReference, \"download\", queryString, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentRevisionURL(AttachmentReference attachmentReference, String revision, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentRevisionURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), revision, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getAttachmentURL(String fullname, String filename, XWikiContext context) throws XWikiException\n    {\n        return getAttachmentURL(fullname, filename, null, context);\n    }\n\n    /**\n     * @since 2.5RC1\n     */\n    public String getAttachmentURL(String fullname, String filename, String queryString, XWikiContext context)\n        throws XWikiException\n    {\n        AttachmentReference attachmentReference =\n            new AttachmentReference(filename, getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        return getAttachmentURL(attachmentReference, queryString, context);\n    }\n\n    // Usefull date functions\n\n    public int getTimeDelta(long time)\n    {\n        Date ctime = new Date();\n        return (int) (ctime.getTime() - time);\n    }\n\n    public boolean isMultiLingual(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"multilingual\", \"0\", context));\n    }\n\n    public boolean isLDAP()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.ldap\"));\n    }\n\n    /**\n     * @return true if XWikiAllGroup group should be seen as virtual group containing all users, false to use it as any\n     *         other group\n     * @since 9.3RC1\n     */\n    public boolean isAllGroupImplicit()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.group.allgroupimplicit\"));\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(XWikiContext context) throws XWikiException\n    {\n        return checkActive(context.getUser(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(String user, XWikiContext context) throws XWikiException\n    {\n        XWikiUser xWikiUser = new XWikiUser(user);\n        return xWikiUser.isDisabled(context) ? 0 : 1;\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public DocumentReference getDocumentReference(XWikiRequest request, XWikiContext context)\n    {\n        DocumentReference reference;\n        if (context.getMode() == XWikiContext.MODE_PORTLET) {\n            if (request.getParameter(\"topic\") != null) {\n                reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n            } else {\n                // Point to this wiki's home page\n                reference = getDefaultDocumentReference().setWikiReference(new WikiReference(context.getWikiId()));\n            }\n        } else if (context.getMode() == XWikiContext.MODE_XMLRPC) {\n            reference = new DocumentReference(context.getWikiId(),\n                context.getDoc().getDocumentReference().getLastSpaceReference().getName(),\n                context.getDoc().getDocumentReference().getName());\n        } else {\n            ResourceReference resourceReference = getResourceReferenceManager().getResourceReference();\n            if (resourceReference instanceof EntityResourceReference) {\n                EntityResourceReference entityResource = (EntityResourceReference) resourceReference;\n                String action = entityResource.getAction().getActionName();\n                if ((request.getParameter(\"topic\") != null) && (action.equals(\"edit\") || action.equals(\"inline\"))) {\n                    reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n                } else {\n                    reference = new DocumentReference(\n                        entityResource.getEntityReference().extractReference(EntityType.DOCUMENT));\n                }\n            } else {\n                // TODO: Handle references not pointing to a document...\n                // Big problem we don't have an Entity URL!\n                throw new RuntimeException(\n                    String.format(\"Resource Reference [%s] isn't an Entity Resource Reference!\", resourceReference));\n            }\n        }\n\n        return reference;\n    }\n\n    /**\n     * Helper method, removes a predefined path segment (the context path or the servel path) from the start of the\n     * requested URI and returns the remainder. This method is needed because special characters in the path can be\n     * URL-encoded, depending on whether the request is forwarded through the request dispatcher or not, and also\n     * depending on the client (some browsers encode -, while some don't).\n     *\n     * @param path the path, as taken from the requested URI\n     * @param segment the segment to remove, as reported by the container\n     * @return the path with the specified segment trimmed from its start\n     */\n    public static String stripSegmentFromPath(String path, String segment)\n    {\n        if (!path.startsWith(segment)) {\n            // The context path probably contains special characters that are encoded in the URL\n            try {\n                segment = URIUtil.encodePath(segment);\n            } catch (URIException e) {\n                LOGGER.warn(\"Invalid path: [\" + segment + \"]\");\n            }\n        }\n        if (!path.startsWith(segment)) {\n            // Some clients also encode -, although it's allowed in the path\n            segment = segment.replaceAll(\"-\", \"%2D\");\n        }\n        if (!path.startsWith(segment)) {\n            // Can't find the context path in the URL (shouldn't happen), just skip to the next path segment\n            return path.substring(path.indexOf('/', 1));\n        }\n        return path.substring(segment.length());\n    }\n\n    public boolean prepareDocuments(XWikiRequest request, XWikiContext context, VelocityContext vcontext)\n        throws XWikiException\n    {\n        XWikiDocument doc;\n        context.getWiki().prepareResources(context);\n        DocumentReference reference = getDocumentReference(request, context);\n        if (context.getAction().equals(\"register\")) {\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n        } else {\n            try {\n                doc = getDocument(reference, context);\n            } catch (XWikiException e) {\n                doc = context.getDoc();\n                if (context.getAction().equals(\"delete\")) {\n                    if (doc == null) {\n                        setPhonyDocument(reference, context, vcontext);\n                        doc = context.getDoc();\n                    }\n                    if (!checkAccess(\"admin\", doc, context)) {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // the user is set after the access is checked.\n        boolean hasAccess = checkAccess(context.getAction(), doc, context);\n\n        XWikiUser user;\n        if (context.getUserReference() != null) {\n            user = new XWikiUser(context.getUserReference());\n        } else {\n            user = new XWikiUser(context.getUser());\n        }\n\n        // We need to check rights before we look for translations\n        // Otherwise we don't have the user language\n        if (!hasAccess) {\n            Object[] args = { doc.getFullName(), user.getUser() };\n            setPhonyDocument(reference, context, vcontext);\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access to document {0} has been denied to user {1}\", null, args);\n        // User is disabled: the mail address is marked as checked\n        } else if (user.isDisabled(context) && user.isEmailChecked(context)) {\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if (!((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\"))))) {\n                Object[] args = { user.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_DISABLED,\n                    \"User {0} account is disabled\", null, args);\n            }\n        // User actually needs to activate his mail address.\n        } else if (user.isDisabled(context) && !user.isEmailChecked(context)) {\n            boolean allow = false;\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if ((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\")))) {\n                allow = true;\n            } else {\n                String allowed = getConfiguration().getProperty(\"xwiki.inactiveuser.allowedpages\", \"\");\n                if (context.getAction().equals(\"view\") && !allowed.equals(\"\")) {\n                    String[] allowedList = StringUtils.split(allowed, \" ,\");\n                    for (String element : allowedList) {\n                        if (element.equals(doc.getFullName())) {\n                            allow = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!allow) {\n                Object[] args = { context.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_INACTIVE,\n                    \"User {0} account is inactive\", null, args);\n            }\n        }\n\n        context.put(\"doc\", doc);\n        context.put(\"cdoc\", doc);\n        vcontext.put(\"doc\", doc.newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        XWikiDocument tdoc;\n\n        // If the parameter language exists and is empty, it means we want to force loading the regular document\n        // not a translation. This should be handled later by doing a better separation between locale used in the UI\n        // and for loading the documents.\n        if (\"\".equals(context.getRequest().getParameter(\"language\"))) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(context);\n        }\n\n        try {\n            String rev = (String) context.get(\"rev\");\n            if (StringUtils.isNotEmpty(rev)) {\n                tdoc = getDocument(tdoc, rev, context);\n            }\n        } catch (Exception ex) {\n            // Invalid version, just use the most recent one\n        }\n        context.put(\"tdoc\", tdoc);\n        vcontext.put(\"tdoc\", tdoc.newDocument(context));\n\n        return true;\n    }\n\n    /**\n     * @since 8.3M1\n     */\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument(reference);\n        doc.setElements(XWikiDocument.HAS_ATTACHMENTS | XWikiDocument.HAS_OBJECTS);\n        doc.setStore(getStore());\n        context.put(\"doc\", doc);\n    }\n\n    /**\n     * @since 2.3M1\n     * @deprecated since 8.3M1, use {@link #setPhonyDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(reference, context);\n\n        vcontext.put(\"doc\", context.getDoc().newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        vcontext.put(\"tdoc\", vcontext.get(\"doc\"));\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #setPhonyDocument(DocumentReference, XWikiContext, VelocityContext)}\n     */\n    @Deprecated\n    public void setPhonyDocument(String docName, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName), context, vcontext);\n    }\n\n    public XWikiEngineContext getEngineContext()\n    {\n        return this.engine_context;\n    }\n\n    public void setEngineContext(XWikiEngineContext engine_context)\n    {\n        this.engine_context = engine_context;\n    }\n\n    public void setAuthService(XWikiAuthService authService)\n    {\n        this.authService = authService;\n    }\n\n    public void setRightService(XWikiRightService rightService)\n    {\n        this.rightService = rightService;\n    }\n\n    public XWikiGroupService getGroupService(XWikiContext context) throws XWikiException\n    {\n        synchronized (this.GROUP_SERVICE_LOCK) {\n            if (this.groupService == null) {\n                String groupClass = getConfiguration().getProperty(\"xwiki.authentication.groupclass\",\n                    \"com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl\");\n\n                try {\n                    this.groupService = (XWikiGroupService) Class.forName(groupClass).newInstance();\n                } catch (Exception e) {\n                    LOGGER.error(\"Failed to instantiate custom group service class: \" + e.getMessage(), e);\n                    this.groupService = new XWikiGroupServiceImpl();\n                }\n                this.groupService.init(this, context);\n            }\n\n            return this.groupService;\n        }\n    }\n\n    public void setGroupService(XWikiGroupService groupService)\n    {\n        this.groupService = groupService;\n    }\n\n    // added some log statements to make debugging easier - LBlaze 2005.06.02\n    public XWikiAuthService getAuthService()\n    {\n        synchronized (this.AUTH_SERVICE_LOCK) {\n            if (this.authService == null) {\n\n                LOGGER.info(\"Initializing AuthService...\");\n\n                String authClass = getConfiguration().getProperty(\"xwiki.authentication.authclass\");\n                if (StringUtils.isNotEmpty(authClass)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Using custom AuthClass \" + authClass + \".\");\n                    }\n                } else {\n                    if (isLDAP()) {\n                        authClass = \"com.xpn.xwiki.user.impl.LDAP.XWikiLDAPAuthServiceImpl\";\n                    } else {\n                        authClass = \"com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl\";\n                    }\n\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Using default AuthClass \" + authClass + \".\");\n                    }\n                }\n\n                try {\n                    // Get the current ClassLoader\n                    @SuppressWarnings(\"deprecation\")\n                    ClassLoaderManager clManager = Utils.getComponent(ClassLoaderManager.class);\n                    ClassLoader classloader = null;\n                    if (clManager != null) {\n                        classloader = clManager.getURLClassLoader(\"wiki:xwiki\", false);\n                    }\n\n                    // Get the class\n                    if (classloader != null) {\n                        this.authService = (XWikiAuthService) Class.forName(authClass, true, classloader).newInstance();\n                    } else {\n                        this.authService = (XWikiAuthService) Class.forName(authClass).newInstance();\n                    }\n\n                    LOGGER.debug(\"Initialized AuthService using Relfection.\");\n                } catch (Exception e) {\n                    LOGGER.warn(\"Failed to initialize AuthService \" + authClass\n                        + \" using Reflection, trying default implementations using 'new'.\", e);\n\n                    this.authService = new XWikiAuthServiceImpl();\n\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\n                            \"Initialized AuthService \" + this.authService.getClass().getName() + \" using 'new'.\");\n                    }\n                }\n            }\n\n            return this.authService;\n        }\n    }\n\n    private static final String DEFAULT_RIGHT_SERVICE_CLASS =\n        \"org.xwiki.security.authorization.internal.XWikiCachingRightService\";\n\n    public XWikiRightService getRightService()\n    {\n        synchronized (this.RIGHT_SERVICE_LOCK) {\n            if (this.rightService == null) {\n                LOGGER.info(\"Initializing RightService...\");\n\n                String rightsClass = getConfiguration().getProperty(\"xwiki.authentication.rightsclass\");\n                if (rightsClass != null && !rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.warn(\"Using custom Right Service [{}].\", rightsClass);\n                    }\n                } else {\n                    rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Using default Right Service [{}].\", rightsClass);\n                    }\n                }\n\n                try {\n                    this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                    LOGGER.debug(\"Initialized RightService using Reflection.\");\n                } catch (Exception e) {\n                    Exception lastException = e;\n\n                    if (!rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize custom RightService [%s]\"\n                                + \" by Reflection, using default implementation [%s].\",\n                            rightsClass, DEFAULT_RIGHT_SERVICE_CLASS), e);\n                        rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                        try {\n                            this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                            LOGGER.debug(\"Initialized default RightService using Reflection.\");\n                        } catch (Exception e1) {\n                            lastException = e1;\n                        }\n                    }\n\n                    if (this.rightService == null) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize RightService [%s]\"\n                                + \" by Reflection, using OLD implementation [%s] with 'new'.\",\n                            rightsClass, XWikiRightServiceImpl.class.getCanonicalName()), lastException);\n\n                        this.rightService = new XWikiRightServiceImpl();\n\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Initialized old RightService implementation \"\n                                + this.rightService.getClass().getName() + \" using 'new'.\");\n                        }\n                    }\n                }\n            }\n            return this.rightService;\n        }\n    }\n\n    public XWikiStatsService getStatsService(XWikiContext context)\n    {\n        synchronized (this.STATS_SERVICE_LOCK) {\n            if (this.statsService == null) {\n                if (\"1\".equals(getConfiguration().getProperty(\"xwiki.stats\", \"1\"))) {\n                    String storeClass = getConfiguration().getProperty(\"xwiki.stats.class\",\n                        \"com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl\");\n                    try {\n                        this.statsService = (XWikiStatsService) Class.forName(storeClass).newInstance();\n                    } catch (Exception e) {\n                        LOGGER.error(e.getMessage(), e);\n\n                        this.statsService = new XWikiStatsServiceImpl();\n                    }\n\n                    this.statsService.init(context);\n                }\n            }\n\n            return this.statsService;\n        }\n    }\n\n    public XWikiURLFactoryService getURLFactoryService()\n    {\n        if (this.urlFactoryService == null) {\n            synchronized (this.URLFACTORY_SERVICE_LOCK) {\n                if (this.urlFactoryService == null) {\n                    LOGGER.info(\"Initializing URLFactory Service...\");\n\n                    XWikiURLFactoryService factoryService = null;\n\n                    String urlFactoryServiceClass = getConfiguration().getProperty(\"xwiki.urlfactory.serviceclass\");\n                    if (urlFactoryServiceClass != null) {\n                        try {\n                            if (LOGGER.isDebugEnabled()) {\n                                LOGGER.debug(\"Using custom URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                            }\n                            factoryService = (XWikiURLFactoryService) Class.forName(urlFactoryServiceClass)\n                                .getConstructor(new Class<?>[] { XWiki.class }).newInstance(new Object[] { this });\n                        } catch (Exception e) {\n                            factoryService = null;\n                            LOGGER.warn(\"Failed to initialize URLFactory Service [\" + urlFactoryServiceClass + \"]\", e);\n                        }\n                    }\n                    if (factoryService == null) {\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Using default URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                        }\n                        factoryService = new XWikiURLFactoryServiceImpl(this);\n                    }\n\n                    // Set the urlFactoryService object in one assignment to prevent threading\n                    // issues when checking for\n                    // null above.\n                    this.urlFactoryService = factoryService;\n                }\n            }\n        }\n\n        return this.urlFactoryService;\n    }\n\n    public XWikiCriteriaService getCriteriaService(XWikiContext context)\n    {\n        return this.criteriaService;\n    }\n\n    public ZipOutputStream getZipOutputStream(XWikiContext context) throws IOException\n    {\n        return new ZipOutputStream(context.getResponse().getOutputStream());\n    }\n\n    private Map<String, SearchEngineRule> getSearchEngineRules(XWikiContext context)\n    {\n        // We currently hardcode the rules\n        // We will put them in the preferences soon\n        Map<String, SearchEngineRule> map = new HashMap<String, SearchEngineRule>();\n        map.put(\"Google\", new SearchEngineRule(\"google.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"MSN\", new SearchEngineRule(\"search.msn.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Yahoo\", new SearchEngineRule(\"search.yahoo.\", \"s/(^|.*&)p=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Voila\", new SearchEngineRule(\"voila.fr\", \"s/(^|.*&)kw=(.*?)(&.*|$)/$2/\"));\n\n        return map;\n    }\n\n    public String getRefererText(String referer, XWikiContext context)\n    {\n        try {\n            URL url = new URL(referer);\n            Map<String, SearchEngineRule> searchengines = getSearchEngineRules(context);\n            if (searchengines != null) {\n                for (SearchEngineRule senginerule : searchengines.values()) {\n                    String host = url.getHost();\n                    int i1 = host.indexOf(senginerule.getHost());\n                    if (i1 != -1) {\n                        String query = context.getUtil().substitute(senginerule.getRegEx(), url.getQuery());\n                        if ((query != null) && (!query.equals(\"\"))) {\n                            // We return the query text instead of the full referer\n                            return host.substring(i1) + \":\" + query;\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        String result = referer.substring(referer.indexOf(\"://\") + 3);\n        if (result.endsWith(\"/\")) {\n            return result.substring(0, result.length() - 1);\n        } else {\n            return result;\n        }\n    }\n\n    public boolean isMySQL()\n    {\n        if (getHibernateStore() == null) {\n            return false;\n        }\n\n        Object dialect = getHibernateStore().getConfiguration().getProperties().get(\"dialect\");\n        return \"org.hibernate.dialect.MySQLDialect\".equals(dialect)\n            || \"net.sf.hibernate.dialect.MySQLDialect\".equals(dialect);\n    }\n\n    public String getFullNameSQL()\n    {\n        return getFullNameSQL(true);\n    }\n\n    public String getFullNameSQL(boolean newFullName)\n    {\n        if (newFullName) {\n            return \"doc.fullName\";\n        }\n\n        if (this.fullNameSQL == null) {\n            if (isMySQL()) {\n                this.fullNameSQL = \"CONCAT(doc.space,'.',doc.name)\";\n            } else {\n                this.fullNameSQL = \"doc.space||'.'||doc.name\";\n            }\n        }\n\n        return this.fullNameSQL;\n    }\n\n    public String getUserName(String user, XWikiContext context)\n    {\n        return getUserName(user, null, true, context);\n    }\n\n    public String getUserName(String user, String format, XWikiContext context)\n    {\n        return getUserName(user, format, true, context);\n    }\n\n    /**\n     * @return a formatted and pretty printed user name for displaying\n     */\n    public String getUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (StringUtils.isBlank(user)) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        DocumentReference userReference = getCurrentMixedDocumentReferenceResolver().resolve(user);\n\n        return getUserName(userReference, format, link, true, context);\n    }\n\n    /**\n     * Generate a display user name and return it.\n     *\n     * @param userReference\n     * @param format a Velocity scnippet used to format the user name\n     * @param link true if a full html link snippet should be returned\n     * @param escapeXML true if the returned name should be escaped (forced true if {@code link} is true)\n     * @param context see {@link XWikiContext}\n     * @return the display user name or a html snippet with the link to the passed user\n     * @since 6.4RC1\n     */\n    public String getUserName(DocumentReference userReference, String format, boolean link, boolean escapeXML,\n        XWikiContext context)\n    {\n        if (userReference == null) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        XWikiDocument userdoc = null;\n        try {\n            userdoc = getDocument(userReference, context);\n            if (userdoc == null) {\n                return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n            }\n\n            BaseObject userobj = userdoc.getObject(\"XWiki.XWikiUsers\");\n            if (userobj == null) {\n                return escapeXML ? XMLUtils.escape(userdoc.getDocumentReference().getName())\n                    : userdoc.getDocumentReference().getName();\n            }\n\n            String text;\n\n            if (format == null) {\n                text = userobj.getStringValue(\"first_name\");\n                String lastName = userobj.getStringValue(\"last_name\");\n                if (!text.isEmpty() && !lastName.isEmpty()) {\n                    text += ' ';\n                }\n                text += userobj.getStringValue(\"last_name\");\n                if (StringUtils.isBlank(text)) {\n                    text = userdoc.getDocumentReference().getName();\n                }\n            } else {\n                VelocityContext vcontext;\n                try {\n                    vcontext = getVelocityContextFactory().createContext();\n                } catch (XWikiVelocityException e) {\n                    LOGGER.error(\"Failed to create standard VelocityContext\", e);\n\n                    vcontext = new XWikiVelocityContext();\n                }\n\n                for (String propname : userobj.getPropertyList()) {\n                    vcontext.put(propname, userobj.getStringValue(propname));\n                }\n                text = evaluateVelocity(format,\n                    \"<username formatting code in \" + context.getDoc().getDocumentReference() + \">\", vcontext);\n            }\n\n            if (escapeXML || link) {\n                text = XMLUtils.escape(text.trim());\n            }\n\n            if (link) {\n                text = \"<span class=\\\"wikilink\\\"><a href=\\\"\" + userdoc.getURL(\"view\", context) + \"\\\">\" + text\n                    + \"</a></span>\";\n            }\n            return text;\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to display the user name of [{}]. Root cause is [{}]. Falling back on the user id.\",\n                userReference, ExceptionUtils.getRootCauseMessage(e));\n\n            return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param namespace the namespace under which to evaluate it (used for isolation)\n     * @param vcontext the Velocity context to use when evaluating. If {@code null}, then a new context will be created,\n     *            initialized and used.\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String namespace, VelocityContext vcontext)\n    {\n        try {\n            return getVelocityEvaluator().evaluateVelocity(content, namespace, vcontext);\n        } catch (XWikiException xe) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", namespace, content,\n                xe.getCause());\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param name the namespace under which to evaluate it (used for isolation)\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String name)\n    {\n        try {\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext velocityContext = velocityManager.getVelocityContext();\n            return evaluateVelocity(content, name, velocityContext);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", name, content, e);\n            Object[] args = { name };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while parsing velocity page {0}\", e,\n                args);\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * Generate and return an unescaped user display name.\n     *\n     * @param userReference the user reference\n     * @param context see {@link XWikiContext}\n     * @return the unescaped display user name\n     * @since 6.4RC1\n     */\n    public String getPlainUserName(DocumentReference userReference, XWikiContext context)\n    {\n        return getUserName(userReference, null, false, false, context);\n    }\n\n    public boolean hasCentralizedAuthentication(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"authentication_centralized\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.centralized\", \"0\"));\n    }\n\n    public String getLocalUserName(String user, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, null, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), null, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, link, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, link, context);\n        }\n    }\n\n    public String formatDate(Date date, String format, XWikiContext context)\n    {\n        if (date == null) {\n            return \"\";\n        }\n        String xformat = format;\n        String defaultFormat = \"yyyy/MM/dd HH:mm\";\n\n        if (format == null) {\n            xformat = getXWikiPreference(\"dateformat\", defaultFormat, context);\n        }\n\n        try {\n            DateFormatSymbols formatSymbols = null;\n            try {\n                String language = getLanguagePreference(context);\n                formatSymbols = new DateFormatSymbols(new Locale(language));\n            } catch (Exception e2) {\n                String language = getXWikiPreference(\"default_language\", context);\n                if ((language != null) && (!language.equals(\"\"))) {\n                    formatSymbols = new DateFormatSymbols(new Locale(language));\n                }\n            }\n\n            SimpleDateFormat sdf;\n            if (formatSymbols != null) {\n                sdf = new SimpleDateFormat(xformat, formatSymbols);\n            } else {\n                sdf = new SimpleDateFormat(xformat);\n            }\n\n            try {\n                sdf.setTimeZone(TimeZone.getTimeZone(getUserTimeZone(context)));\n            } catch (Exception e) {\n            }\n\n            return sdf.format(date);\n        } catch (Exception e) {\n            LOGGER.info(\"Failed to format date [\" + date + \"] with pattern [\" + xformat + \"]: \" + e.getMessage());\n            if (format == null) {\n                if (xformat.equals(defaultFormat)) {\n                    return date.toString();\n                } else {\n                    return formatDate(date, defaultFormat, context);\n                }\n            } else {\n                return formatDate(date, null, context);\n            }\n        }\n    }\n\n    /*\n     * Allow to read user setting providing the user timezone All dates will be expressed with this timezone\n     */\n    public String getUserTimeZone(XWikiContext context)\n    {\n        String tz = getUserPreference(\"timezone\", context);\n        // We perform this verification ourselves since TimeZone#getTimeZone(String) with an invalid parameter returns\n        // GMT and not the system default.\n        if (!ArrayUtils.contains(TimeZone.getAvailableIDs(), tz)) {\n            String defaultTz = TimeZone.getDefault().getID();\n            return getConfiguration().getProperty(\"xwiki.timezone\", defaultTz);\n        } else {\n            return tz;\n        }\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #exists(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public boolean exists(String fullname, XWikiContext context)\n    {\n        return exists(getCurrentMixedDocumentReferenceResolver().resolve(fullname), context);\n    }\n\n    public boolean exists(DocumentReference documentReference, XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            XWikiDocument doc = new XWikiDocument(documentReference, documentReference.getLocale());\n\n            context.setWikiId(documentReference.getWikiReference().getName());\n\n            return getStore().exists(doc, context);\n        } catch (XWikiException e) {\n            return false;\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    public String getAdType(XWikiContext context)\n    {\n        String adtype = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adtype = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adtype\");\n        }\n\n        if (adtype.equals(\"\")) {\n            adtype = getConfiguration().getProperty(\"xwiki.ad.type\", \"\");\n        }\n\n        return adtype;\n    }\n\n    public String getAdClientId(XWikiContext context)\n    {\n        final String defaultadclientid = \"pub-2778691407285481\";\n        String adclientid = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adclientid = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adclientid\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = getConfiguration().getProperty(\"xwiki.ad.clientid\", \"\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = defaultadclientid;\n        }\n\n        return adclientid;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public XWikiPluginInterface getPlugin(String name, XWikiContext context)\n    {\n        XWikiPluginManager plugins = getPluginManager();\n        Vector<String> pluginlist = plugins.getPlugins();\n        for (String pluginname : pluginlist) {\n            if (pluginname.equals(name)) {\n                return plugins.getPlugin(pluginname);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public Api getPluginApi(String name, XWikiContext context)\n    {\n        XWikiPluginInterface plugin = getPlugin(name, context);\n        if (plugin != null) {\n            return plugin.getPluginApi(plugin, context);\n        }\n\n        return null;\n    }\n\n    public int getHttpTimeout(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.timeout\", 60000);\n    }\n\n    public String getHttpUserAgent(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.useragent\", \"XWikiBot/1.0\");\n    }\n\n    public String getURLContent(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, int timeout, String userAgent) throws IOException\n    {\n        String content;\n        HttpClient client = getHttpClient(timeout, userAgent);\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            client.executeMethod(get);\n            content = get.getResponseBodyAsString();\n        } finally {\n            // Release any connection resources used by the method\n            get.releaseConnection();\n        }\n\n        return content;\n    }\n\n    public String getURLContent(String surl, String username, String password, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBodyAsString();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContentAsBytes(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, int timeout, String userAgent) throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, XWikiContext context)\n        throws IOException\n    {\n        return getURLContentAsBytes(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    /**\n     * API to list all spaces in the current wiki.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @return a list of string representing all non-hidden spaces (ie spaces that have non-hidden pages) for the\n     *         current wiki\n     * @throws XWikiException if something went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaces(XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaces\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    /**\n     * API to list all non-hidden documents in a space.\n     *\n     * @param spaceReference the local reference of the space for which to return all non-hidden documents\n     * @return the list of document names (in the format {@code Space.Page}) for non-hidden documents in the specified\n     *         space\n     * @throws XWikiException if the loading went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaceDocsName(String spaceReference, XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaceDocsName\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\"))\n                .bindValue(\"space\", spaceReference).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public List<String> getIncludedMacros(String defaultSpace, String content, XWikiContext context)\n    {\n        List<String> list;\n\n        try {\n            String pattern = \"#includeMacros[ ]*\\\\([ ]*([\\\"'])(.*?)\\\\1[ ]*\\\\)\";\n            list = context.getUtil().getUniqueMatches(content, pattern, 2);\n            for (int i = 0; i < list.size(); i++) {\n                String name = list.get(i);\n                if (name.indexOf('.') == -1) {\n                    list.set(i, defaultSpace + \".\" + name);\n                }\n            }\n        } catch (Exception e) {\n            // This should never happen\n            LOGGER.error(\"Failed to extract #includeMacros targets from provided content [\" + content + \"]\", e);\n\n            list = Collections.emptyList();\n        }\n\n        return list;\n    }\n\n    /**\n     * accessor for the isReadOnly instance var.\n     *\n     * @see #isReadOnly\n     */\n    public boolean isReadOnly()\n    {\n        return this.isReadOnly;\n    }\n\n    public void setReadOnly(boolean readOnly)\n    {\n        this.isReadOnly = readOnly;\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteAllDocuments(doc, true, context);\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, boolean toTrash, XWikiContext context) throws XWikiException\n    {\n        // Wrap the work as a batch operation.\n        BatchOperationExecutor batchOperationExecutor = Utils.getComponent(BatchOperationExecutor.class);\n        batchOperationExecutor.execute(() -> {\n            // Delete all translation documents\n            for (Locale locale : doc.getTranslationLocales(context)) {\n                XWikiDocument tdoc = doc.getTranslatedDocument(locale, context);\n                deleteDocument(tdoc, toTrash, context);\n            }\n\n            // Delete the default document\n            deleteDocument(doc, toTrash, context);\n        });\n    }\n\n    public void refreshLinks(XWikiContext context) throws XWikiException\n    {\n        try {\n            // refreshes all Links of each doc of the wiki\n            @SuppressWarnings(\"deprecation\")\n            List<String> docs = getStore().getQueryManager().getNamedQuery(\"getAllDocuments\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n            for (int i = 0; i < docs.size(); i++) {\n                XWikiDocument myDoc = this.getDocument(docs.get(i), context);\n                myDoc.getStore().saveLinks(myDoc, context, true);\n            }\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public boolean hasBacklinks(XWikiContext context)\n    {\n        if (this.hasBacklinks == null) {\n            this.hasBacklinks = \"1\".equals(getXWikiPreference(\"backlinks\", \"xwiki.backlinks\", \"0\", context));\n        }\n        return this.hasBacklinks;\n    }\n\n    public boolean hasTags(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"tags\", \"xwiki.tags\", \"0\", context));\n    }\n\n    public boolean hasCustomMappings()\n    {\n        return getHibernateConfiguration().hasCustomMappings();\n    }\n\n    public boolean hasDynamicCustomMappings()\n    {\n        return getHibernateConfiguration().hasDynamicCustomMappings();\n    }\n\n    public String getDefaultSpace(XWikiContext context)\n    {\n        String defaultSpace = getXWikiPreference(\"defaultweb\", \"\", context);\n        if (StringUtils.isEmpty(defaultSpace)) {\n            return getConfiguration().getProperty(\"xwiki.defaultweb\", DEFAULT_HOME_SPACE);\n        }\n        return defaultSpace;\n    }\n\n    public boolean showViewAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"showviewaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        } else if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.showviewaction\", \"1\"));\n    }\n\n    public boolean useDefaultAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"usedefaultaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.usedefaultaction\", \"0\"));\n    }\n\n    public String getDefaultPage(XWikiContext context)\n    {\n        String defaultPage = getXWikiPreference(\"defaultpage\", \"\", context);\n        if (StringUtils.isEmpty(defaultPage)) {\n            return getConfiguration().getProperty(\"xwiki.defaultpage\", DEFAULT_SPACE_HOMEPAGE);\n        }\n        return defaultPage;\n    }\n\n    public boolean hasEditComment(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment\", \"0\"));\n    }\n\n    public boolean isEditCommentFieldHidden(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_hidden\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.hidden\", \"0\"));\n    }\n\n    public boolean isEditCommentSuggested(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_suggested\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.suggested\", \"0\"));\n    }\n\n    public boolean isEditCommentMandatory(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_mandatory\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.mandatory\", \"0\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasMinorEdit()\n     */\n    public boolean hasMinorEdit(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"minoredit\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.minoredit\", \"1\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasRecycleBin()\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isRecycleBinEnabled();\n    }\n\n    /**\n     * Indicates whether deleted attachments are stored in a recycle bin or not. This can be configured using the key\n     * <var>storage.attachment.recyclebin</var>.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasAttachmentRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentRecycleBinEnabled();\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public BaseClass getXClass(DocumentReference documentReference, XWikiContext context) throws XWikiException\n    {\n        // Used to avoid recursive loading of documents if there are recursives usage of classes\n        BaseClass bclass = context.getBaseClass(documentReference);\n        if (bclass != null) {\n            return bclass;\n        }\n\n        return getDocument(documentReference, context).getXClass();\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #getXClass(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public BaseClass getClass(String fullName, XWikiContext context) throws XWikiException\n    {\n        DocumentReference reference = null;\n        if (StringUtils.isNotEmpty(fullName)) {\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        }\n        return getXClass(reference, context);\n    }\n\n    public String getEditorPreference(XWikiContext context)\n    {\n        String defaultSyntaxContentEditor = getEditConfiguration().getDefaultEditor(SyntaxContent.class);\n\n        return defaultSyntaxContentEditor == null ? \"\" : defaultSyntaxContentEditor.toLowerCase();\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String. Note that Groovy scripts\n     * compilation is cached.\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, XWikiContext xcontext) throws XWikiException\n    {\n        return getParseGroovyFromString().parseGroovyFromString(script, xcontext);\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String, using a classloader including all\n     * JAR files located in the passed page as attachments. Note that Groovy scripts compilation is cached\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, String jarWikiPage, XWikiContext xcontext) throws XWikiException\n    {\n        XWikiPageClassLoader pcl = new XWikiPageClassLoader(jarWikiPage, xcontext);\n        Object prevParentClassLoader = xcontext.get(\"parentclassloader\");\n        try {\n            xcontext.put(\"parentclassloader\", pcl);\n\n            return parseGroovyFromString(script, xcontext);\n        } finally {\n            if (prevParentClassLoader == null) {\n                xcontext.remove(\"parentclassloader\");\n            } else {\n                xcontext.put(\"parentclassloader\", prevParentClassLoader);\n            }\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, String jarWikiPage, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), jarWikiPage, context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public String getMacroList(XWikiContext context)\n    {\n        String macrosmapping = \"\";\n        XWiki xwiki = context.getWiki();\n\n        try {\n            macrosmapping = getResourceContent(MACROS_FILE);\n        } catch (IOException e) {\n        }\n\n        macrosmapping += \"\\r\\n\" + xwiki.getXWikiPreference(\"macros_mapping\", \"\", context);\n\n        return macrosmapping;\n    }\n\n    // This functions adds an object from an new object creation form\n    public BaseObject getObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        Map<String, String[]> map = Util.getObject(context.getRequest(), className);\n        BaseClass bclass = context.getWiki().getClass(className, context);\n        BaseObject newobject = (BaseObject) bclass.fromMap(map, context);\n\n        return newobject;\n    }\n\n    public String getConvertingUserNameType(XWikiContext context)\n    {\n        if (StringUtils.isNotBlank(context.getWiki().getXWikiPreference(\"convertmail\", context))) {\n            return context.getWiki().getXWikiPreference(\"convertmail\", \"0\", context);\n        }\n\n        return getConfiguration().getProperty(\"xwiki.authentication.convertemail\", \"0\");\n    }\n\n    public String convertUsername(String username, XWikiContext context)\n    {\n        if (username == null) {\n            return null;\n        }\n\n        if (getConvertingUserNameType(context).equals(\"1\") && (username.indexOf('@') != -1)) {\n            String id = \"\" + username.hashCode();\n            id = id.replace(\"-\", \"\");\n            if (username.length() > 1) {\n                int i1 = username.indexOf('@');\n                id = \"\" + username.charAt(0) + username.substring(i1 + 1, i1 + 2)\n                    + username.charAt(username.length() - 1) + id;\n            }\n\n            return id;\n        } else if (getConvertingUserNameType(context).equals(\"2\")) {\n            return username.replaceAll(\"[\\\\.\\\\@]\", \"_\");\n        } else {\n            return username;\n        }\n    }\n\n    public boolean hasSectionEdit(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.section.edit\", 0) == 1;\n    }\n\n    /**\n     * @return The maximum section depth for which section editing is available. This can be customized through the\n     *         {@code xwiki.section.depth} configuration property. Defaults to 2 when not defined.\n     */\n    public long getSectionEditingDepth()\n    {\n        return getConfiguration().getProperty(\"xwiki.section.depth\", 2L);\n    }\n\n    public String getWysiwygToolbars(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.wysiwyg.toolbars\", \"\");\n    }\n\n    public String clearName(String name, XWikiContext context)\n    {\n        return clearName(name, true, true, context);\n    }\n\n    public String clearName(String name, boolean stripDots, boolean ascii, XWikiContext context)\n    {\n        String temp = name;\n        temp = temp.replaceAll(\n            \"[\\u00c0\\u00c1\\u00c2\\u00c3\\u00c4\\u00c5\\u0100\\u0102\\u0104\\u01cd\\u01de\\u01e0\\u01fa\\u0200\\u0202\\u0226]\", \"A\");\n        temp = temp.replaceAll(\n            \"[\\u00e0\\u00e1\\u00e2\\u00e3\\u00e4\\u00e5\\u0101\\u0103\\u0105\\u01ce\\u01df\\u01e1\\u01fb\\u0201\\u0203\\u0227]\", \"a\");\n        temp = temp.replaceAll(\"[\\u00c6\\u01e2\\u01fc]\", \"AE\");\n        temp = temp.replaceAll(\"[\\u00e6\\u01e3\\u01fd]\", \"ae\");\n        temp = temp.replaceAll(\"[\\u008c\\u0152]\", \"OE\");\n        temp = temp.replaceAll(\"[\\u009c\\u0153]\", \"oe\");\n        temp = temp.replaceAll(\"[\\u00c7\\u0106\\u0108\\u010a\\u010c]\", \"C\");\n        temp = temp.replaceAll(\"[\\u00e7\\u0107\\u0109\\u010b\\u010d]\", \"c\");\n        temp = temp.replaceAll(\"[\\u00d0\\u010e\\u0110]\", \"D\");\n        temp = temp.replaceAll(\"[\\u00f0\\u010f\\u0111]\", \"d\");\n        temp = temp.replaceAll(\"[\\u00c8\\u00c9\\u00ca\\u00cb\\u0112\\u0114\\u0116\\u0118\\u011a\\u0204\\u0206\\u0228]\", \"E\");\n        temp = temp.replaceAll(\"[\\u00e8\\u00e9\\u00ea\\u00eb\\u0113\\u0115\\u0117\\u0119\\u011b\\u01dd\\u0205\\u0207\\u0229]\", \"e\");\n        temp = temp.replaceAll(\"[\\u011c\\u011e\\u0120\\u0122\\u01e4\\u01e6\\u01f4]\", \"G\");\n        temp = temp.replaceAll(\"[\\u011d\\u011f\\u0121\\u0123\\u01e5\\u01e7\\u01f5]\", \"g\");\n        temp = temp.replaceAll(\"[\\u0124\\u0126\\u021e]\", \"H\");\n        temp = temp.replaceAll(\"[\\u0125\\u0127\\u021f]\", \"h\");\n        temp = temp.replaceAll(\"[\\u00cc\\u00cd\\u00ce\\u00cf\\u0128\\u012a\\u012c\\u012e\\u0130\\u01cf\\u0208\\u020a]\", \"I\");\n        temp = temp.replaceAll(\"[\\u00ec\\u00ed\\u00ee\\u00ef\\u0129\\u012b\\u012d\\u012f\\u0131\\u01d0\\u0209\\u020b]\", \"i\");\n        temp = temp.replaceAll(\"[\\u0132]\", \"IJ\");\n        temp = temp.replaceAll(\"[\\u0133]\", \"ij\");\n        temp = temp.replaceAll(\"[\\u0134]\", \"J\");\n        temp = temp.replaceAll(\"[\\u0135]\", \"j\");\n        temp = temp.replaceAll(\"[\\u0136\\u01e8]\", \"K\");\n        temp = temp.replaceAll(\"[\\u0137\\u0138\\u01e9]\", \"k\");\n        temp = temp.replaceAll(\"[\\u0139\\u013b\\u013d\\u013f\\u0141]\", \"L\");\n        temp = temp.replaceAll(\"[\\u013a\\u013c\\u013e\\u0140\\u0142\\u0234]\", \"l\");\n        temp = temp.replaceAll(\"[\\u00d1\\u0143\\u0145\\u0147\\u014a\\u01f8]\", \"N\");\n        temp = temp.replaceAll(\"[\\u00f1\\u0144\\u0146\\u0148\\u0149\\u014b\\u01f9\\u0235]\", \"n\");\n        temp = temp.replaceAll(\n            \"[\\u00d2\\u00d3\\u00d4\\u00d5\\u00d6\\u00d8\\u014c\\u014e\\u0150\\u01d1\\u01ea\\u01ec\\u01fe\\u020c\\u020e\\u022a\\u022c\"\n                + \"\\u022e\\u0230]\",\n            \"O\");\n        temp = temp.replaceAll(\n            \"[\\u00f2\\u00f3\\u00f4\\u00f5\\u00f6\\u00f8\\u014d\\u014f\\u0151\\u01d2\\u01eb\\u01ed\\u01ff\\u020d\\u020f\\u022b\\u022d\"\n                + \"\\u022f\\u0231]\",\n            \"o\");\n        temp = temp.replaceAll(\"[\\u0156\\u0158\\u0210\\u0212]\", \"R\");\n        temp = temp.replaceAll(\"[\\u0157\\u0159\\u0211\\u0213]\", \"r\");\n        temp = temp.replaceAll(\"[\\u015a\\u015c\\u015e\\u0160\\u0218]\", \"S\");\n        temp = temp.replaceAll(\"[\\u015b\\u015d\\u015f\\u0161\\u0219]\", \"s\");\n        temp = temp.replaceAll(\"[\\u00de\\u0162\\u0164\\u0166\\u021a]\", \"T\");\n        temp = temp.replaceAll(\"[\\u00fe\\u0163\\u0165\\u0167\\u021b\\u0236]\", \"t\");\n        temp = temp.replaceAll(\n            \"[\\u00d9\\u00da\\u00db\\u00dc\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u0214\\u0216]\",\n            \"U\");\n        temp = temp.replaceAll(\n            \"[\\u00f9\\u00fa\\u00fb\\u00fc\\u0169\\u016b\\u016d\\u016f\\u0171\\u0173\\u01d4\\u01d6\\u01d8\\u01da\\u01dc\\u0215\\u0217]\",\n            \"u\");\n        temp = temp.replaceAll(\"[\\u0174]\", \"W\");\n        temp = temp.replaceAll(\"[\\u0175]\", \"w\");\n        temp = temp.replaceAll(\"[\\u00dd\\u0176\\u0178\\u0232]\", \"Y\");\n        temp = temp.replaceAll(\"[\\u00fd\\u00ff\\u0177\\u0233]\", \"y\");\n        temp = temp.replaceAll(\"[\\u0179\\u017b\\u017d]\", \"Z\");\n        temp = temp.replaceAll(\"[\\u017a\\u017c\\u017e]\", \"z\");\n        temp = temp.replaceAll(\"[\\u00df]\", \"SS\");\n        temp = temp.replaceAll(\"[_':,;\\\\\\\\/]\", \" \");\n        name = temp;\n        name = name.replaceAll(\"\\\\s+\", \"\");\n        name = name.replaceAll(\"[\\\\(\\\\)]\", \" \");\n\n        if (stripDots) {\n            name = name.replaceAll(\"[\\\\.]\", \"\");\n        }\n\n        if (ascii) {\n            name = name.replaceAll(\"[^a-zA-Z0-9\\\\-_\\\\.]\", \"\");\n        }\n\n        if (name.length() > 250) {\n            name = name.substring(0, 250);\n        }\n\n        return name;\n\n    }\n\n    public String getUniquePageName(String space, XWikiContext context)\n    {\n        String pageName = generateRandomString(16);\n\n        return getUniquePageName(space, pageName, context);\n    }\n\n    public String getUniquePageName(String space, String name, XWikiContext context)\n    {\n        String pageName = clearName(name, context);\n        if (exists(space + \".\" + pageName, context)) {\n            int i = 0;\n            while (exists(space + \".\" + pageName + \"_\" + i, context)) {\n                i++;\n            }\n\n            return pageName + \"_\" + i;\n        }\n\n        return pageName;\n    }\n\n    public PropertyClass getPropertyClassFromName(String propPath, XWikiContext context)\n    {\n        int i1 = propPath.indexOf('_');\n        if (i1 == -1) {\n            return null;\n        } else {\n            String className = propPath.substring(0, i1);\n            String propName = propPath.substring(i1 + 1);\n            try {\n                return (PropertyClass) getDocument(className, context).getXClass().get(propName);\n            } catch (XWikiException e) {\n                return null;\n            }\n        }\n    }\n\n    public boolean validateDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        return doc.validate(context);\n    }\n\n    public String addTooltip(String html, String message, String params, XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<span class=\\\"tooltip_span\\\" onmouseover=\\\"\");\n        buffer.append(params);\n        buffer.append(\"; return escape('\");\n        buffer.append(message.replaceAll(\"'\", \"\\\\'\"));\n        buffer.append(\"');\\\">\");\n        buffer.append(html);\n        buffer.append(\"</span>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltipJS(XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<script src=\\\"\");\n        buffer.append(getSkinFile(\"ajax/wzToolTip.js\", context));\n        buffer.append(\"\\\"></script>\");\n        // buffer.append(\"<div id=\\\"dhtmltooltip\\\"></div>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltip(String html, String message, XWikiContext context)\n    {\n        return addTooltip(html, message, \"this.WIDTH='300'\", context);\n    }\n\n    public String addMandatory(XWikiContext context)\n    {\n        String star =\n            \"<span class=\\\"mandatoryParenthesis\\\">&nbsp;(</span><span class=\\\"mandatoryDot\\\">&lowast;</span><span class=\\\"mandatoryParenthesis\\\">)&nbsp;</span>\";\n        return context.getWiki().getXWikiPreference(\"mandatory_display\", star, context);\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public boolean hasVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isVersioningEnabled();\n    }\n\n    public boolean hasAttachmentVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentVersioningEnabled();\n    }\n\n    public String getExternalAttachmentURL(String fullName, String filename, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullName, context);\n\n        return doc.getExternalAttachmentURL(filename, \"download\", context);\n    }\n\n    public int getMaxRecursiveSpaceChecks(XWikiContext context)\n    {\n        int max = getXWikiPreferenceAsInt(\"rights_maxrecursivespacechecks\", -1, context);\n        if (max == -1) {\n            return getConfiguration().getProperty(\"xwiki.rights.maxrecursivespacechecks\", 0);\n        } else {\n            return max;\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     */\n    public void restoreFromRecycleBin(final XWikiDocument doc, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        if (deletedDocuments != null && deletedDocuments.length > 0) {\n            long index = deletedDocuments[0].getId();\n            restoreFromRecycleBin(doc, index, comment, context);\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     * @deprecated since 9.4RC1. Use {@link #restoreFromRecycleBin(long, String, XWikiContext)} instead.\n     */\n    @Deprecated\n    public void restoreFromRecycleBin(final XWikiDocument doc, long index, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        restoreFromRecycleBin(index, comment, context);\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 9.4RC1\n     */\n    public void restoreFromRecycleBin(long index, String comment, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument newdoc = getRecycleBinStore().restoreFromRecycleBin(index, context, true);\n        saveDocument(newdoc, comment, context);\n        getRecycleBinStore().deleteFromRecycleBin(index, context, true);\n    }\n\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, XWikiContext context) throws XWikiException\n    {\n        return rollback(tdoc, rev, true, context);\n    }\n\n    private void restoreDeletedAttachment(XWikiAttachment rolledbackAttachment, XWikiContext context)\n        throws XWikiException\n    {\n        // Restore deleted attachments from the trash\n        if (getAttachmentRecycleBinStore() != null) {\n            // There might be multiple versions of the attachment in the trash, search for the right one\n            List<DeletedAttachment> deletedVariants =\n                getAttachmentRecycleBinStore().getAllDeletedAttachments(rolledbackAttachment, context, true);\n\n            DeletedAttachment correctVariant = null;\n            for (DeletedAttachment variant : deletedVariants) { // Reverse chronological order\n                if (variant.getDate().before(rolledbackAttachment.getDate())) {\n                    break;\n                }\n\n                correctVariant = variant;\n            }\n\n            if (correctVariant != null) {\n                XWikiAttachment restoredAttachment = correctVariant.restoreAttachment();\n\n                boolean updateArchive = false;\n\n                if (!restoredAttachment.getVersion().equals(rolledbackAttachment.getVersion())) {\n                    XWikiAttachment restoredAttachmentRevision =\n                        restoredAttachment.getAttachmentRevision(rolledbackAttachment.getVersion(), context);\n\n                    if (restoredAttachmentRevision != null) {\n                        // Update the archive since it won't be done by the store (it's a new attachment)\n                        // TODO: Remove from the archive the versions greater than the rollbacked one instead (they\n                        // would not be lost since they would still be in the recycle bin) ?\n                        rolledbackAttachment.setVersion(restoredAttachment.getVersion());\n                        updateArchive = true;\n\n                        restoredAttachment = restoredAttachmentRevision;\n                    }\n                }\n\n                rolledbackAttachment.apply(restoredAttachment);\n\n                // Restore the deleted archive\n                rolledbackAttachment\n                    .setAttachment_archive((XWikiAttachmentArchive) restoredAttachment.getAttachment_archive().clone());\n                rolledbackAttachment.getAttachment_archive().setAttachment(rolledbackAttachment);\n\n                if (updateArchive) {\n                    rolledbackAttachment.updateContentArchive(context);\n                }\n            } else {\n                // Not found in the trash, set an empty content to avoid errors\n                try {\n                    rolledbackAttachment.setContent(new ByteArrayInputStream(new byte[0]));\n                } catch (IOException e) {\n                    // The content we pass cannot fail\n                }\n            }\n        }\n    }\n\n    /**\n     * @param tdoc the document to rollback\n     * @param rev the revision to rollback to\n     * @param addRevision true if a new revision should be created\n     * @param xcontext the XWiki context\n     * @return the new document\n     * @throws XWikiException when failing to rollback the document\n     * @since 10.7RC1\n     * @since 9.11.8\n     */\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, boolean addRevision, XWikiContext xcontext)\n        throws XWikiException\n    {\n        LOGGER.debug(\"Rolling back [{}] to version [{}]\", tdoc, rev);\n\n        // Clone the document before modifying to avoid concurrency issues\n        XWikiDocument document = tdoc.clone();\n\n        XWikiDocument rolledbackDoc = getDocumentRevisionProvider().getRevision(tdoc, rev);\n\n        // Restore attachments\n        if (\"1\".equals(getConfiguration().getProperty(\"xwiki.store.rollbackattachmentwithdocuments\", \"1\"))) {\n            LOGGER.debug(\"Checking attachments\");\n\n            for (XWikiAttachment rolledbackAttachment : rolledbackDoc.getAttachmentList()) {\n                String filename = rolledbackAttachment.getFilename();\n                XWikiAttachment attachment = document.getAttachment(filename);\n\n                if (attachment == null) {\n                    // The attachment has been deleted, search and restore it\n                    LOGGER.debug(\"Deleted attachment: [{}]\", filename);\n\n                    // Restore content and archive from the recycle bin\n                    restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                } else {\n                    XWikiAttachment attachmentRevision =\n                        attachment.getAttachmentRevision(rolledbackAttachment.getVersion(), xcontext);\n\n                    // We compare the number of milliseconds instead of the date objects directly because Hibernate can\n                    // return java.sql.Timestamp for date fields and the JavaDoc says that Timestamp.equals(Object)\n                    // doesn't return true if the passed value is a java.util.Date object with the same number of\n                    // milliseconds because the nanoseconds component of the passed date is unknown.\n                    if (attachmentRevision == null\n                        || attachmentRevision.getDate().getTime() != rolledbackAttachment.getDate().getTime()) {\n                        // Recreated attachment\n                        LOGGER.debug(\"Recreated attachment: [{}]\", filename);\n\n                        // Mark current attachment for deletion to not loose it\n                        document.removeAttachment(attachment);\n\n                        // Search and restore previously deleted one\n                        // If the attachment trash is not available, don't lose the existing attachment\n                        if (getAttachmentRecycleBinStore() != null) {\n                            // Restore in the right version\n                            restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                        }\n                    } else {\n                        // Restore content and archive from the recycle bin\n                        rolledbackAttachment.apply(attachmentRevision);\n                    }\n                }\n            }\n        }\n\n        document.apply(rolledbackDoc);\n\n        // Prepare the XWikiDocument before save\n        document.setAuthorReference(xcontext.getUserReference());\n        document.setContentAuthorReference(xcontext.getUserReference());\n\n        // Make sure the history is not modified if addRevision is disabled\n        String message;\n        if (!addRevision) {\n            document.setVersion(rev);\n            document.setMetaDataDirty(false);\n            document.setContentDirty(false);\n            message = document.getComment();\n        } else {\n            // Make sure to save a new version even if nothing changed\n            document.setMetaDataDirty(true);\n            message = localizePlainOrKey(\"core.comment.rollback\", rev);\n        }\n\n        ObservationManager om = getObservationManager();\n        if (om != null) {\n            // Notify listeners about the document that is going to be rolled back.\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            om.notify(new DocumentRollingBackEvent(document.getDocumentReference(), rev), document, xcontext);\n        }\n\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        saveDocument(document, message, xcontext);\n\n        // Since XWiki#saveDocument resets the original document, we need to temporarily put it back to send\n        // notifications.\n        XWikiDocument newOriginalDocument = document.getOriginalDocument();\n        document.setOriginalDocument(originalDocument);\n\n        try {\n            if (om != null) {\n                // Notify listeners about the document that was rolled back.\n                // Note that for the moment the event being send is a bridge event, as we are still passing around an\n                // XWikiDocument as source and an XWikiContext as data.\n                om.notify(new DocumentRolledBackEvent(document.getDocumentReference(), rev), document, xcontext);\n            }\n        } finally {\n            document.setOriginalDocument(newOriginalDocument);\n        }\n\n        return document;\n    }\n\n    /**\n     * @return the ids of configured syntaxes for this wiki (e.g. {@code xwiki/2.0}, {@code xwiki/2.1},\n     *         {@code mediawiki/1.0}, etc)\n     * @deprecated since 8.2M1, use the XWiki Rendering Configuration component or the Rendering Script Service one\n     *             instead\n     */\n    @Deprecated\n    public List<String> getConfiguredSyntaxes()\n    {\n        return this.configuredSyntaxes;\n    }\n\n    /**\n     * @return the syntax id of the syntax to use when creating new documents\n     */\n    public String getDefaultDocumentSyntax()\n    {\n        // TODO: Fix this method to return a Syntax object instead of a String\n        return getDefaultDocumentSyntaxInternal().toIdString();\n    }\n\n    /**\n     * @return the syntax to use when creating new documents\n     */\n    private Syntax getDefaultDocumentSyntaxInternal()\n    {\n        return Utils.getComponent(CoreConfiguration.class).getDefaultDocumentSyntax();\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @param defaultSyntaxId the default value to return if no document can be found\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(String defaultSyntaxId, XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            syntaxId = defaultSyntaxId;\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            throw new RuntimeException(\"Cannot get the current syntax since there's no current document set\");\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    private String getCurrentContentSyntaxIdInternal(XWikiContext context)\n    {\n        Syntax syntax = getCurrentContentSyntaxInternal(context);\n\n        return syntax != null ? syntax.toIdString() : null;\n    }\n\n    /**\n     * Get the syntax of the code currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax\n     */\n    private Syntax getCurrentContentSyntaxInternal(XWikiContext context)\n    {\n        Syntax syntax = null;\n\n        // Try to find the current syntax\n        if (getRenderingContext() != null) {\n            Block curentBlock = getRenderingContext().getCurrentBlock();\n\n            if (curentBlock != null) {\n                MetaDataBlock metaDataBlock =\n                    curentBlock.getFirstBlock(new MetadataBlockMatcher(MetaData.SYNTAX), Axes.ANCESTOR_OR_SELF);\n\n                if (metaDataBlock != null) {\n                    return (Syntax) metaDataBlock.getMetaData().getMetaData(MetaData.SYNTAX);\n                }\n            }\n        }\n\n        // Fallback on secure and current document in the context\n        if (context.get(\"sdoc\") != null) {\n            // The content document\n            syntax = ((XWikiDocument) context.get(\"sdoc\")).getSyntax();\n        } else if (context.getDoc() != null) {\n            // The context document\n            syntax = context.getDoc().getSyntax();\n        }\n\n        return syntax;\n    }\n\n    /**\n     * @return true if title handling should be using the compatibility mode or not. When the compatibility mode is\n     *         active, if the document's content first header (level 1 or level 2) matches the document's title the\n     *         first header is stripped.\n     */\n    public boolean isTitleInCompatibilityMode()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.title.compatibility\", \"0\"));\n    }\n\n    @Override\n    public void onEvent(Event event, Object source, Object data)\n    {\n        if (event instanceof WikiDeletedEvent) {\n            // A wiki has been deleted\n            onWikiDeletedEvent((WikiDeletedEvent) event);\n        } else if (event instanceof ComponentDescriptorAddedEvent) {\n            // A new mandatory document initializer has been installed\n            onMandatoryDocumentInitializerAdded((ComponentDescriptorAddedEvent) event, (ComponentManager) source);\n        } else {\n            // Document modifications\n\n            XWikiDocument doc = (XWikiDocument) source;\n\n            if (event instanceof XObjectPropertyEvent) {\n                EntityReference reference = ((XObjectPropertyEvent) event).getReference();\n                String modifiedProperty = reference.getName();\n                if (\"backlinks\".equals(modifiedProperty)) {\n                    this.hasBacklinks = doc.getXObject((ObjectReference) reference.getParent()).getIntValue(\"backlinks\",\n                        getConfiguration().getProperty(\"xwiki.backlinks\", 0)) == 1;\n                }\n            }\n        }\n    }\n\n    private void onWikiDeletedEvent(WikiDeletedEvent event)\n    {\n        this.initializedWikis.remove(event.getWikiId());\n    }\n\n    private void onMandatoryDocumentInitializerAdded(ComponentDescriptorAddedEvent event,\n        ComponentManager componentManager)\n    {\n        String namespace;\n        if (componentManager instanceof NamespacedComponentManager) {\n            namespace = ((NamespacedComponentManager) componentManager).getNamespace();\n        } else {\n            namespace = null;\n        }\n\n        MandatoryDocumentInitializer initializer;\n        try {\n            initializer = componentManager.getInstance(MandatoryDocumentInitializer.class, event.getRoleHint());\n\n            XWikiContext context = getXWikiContext();\n            if (namespace == null) {\n                // Initialize in main wiki\n                initializeMandatoryDocument(context.getMainXWiki(), initializer, context);\n                // Initialize in already initialized sub wikis (will be initialized in others when they are initialized)\n                for (String wiki : this.initializedWikis.keySet()) {\n                    initializeMandatoryDocument(wiki, initializer, context);\n                }\n            } else if (namespace.startsWith(\"wiki:\")) {\n                // Initialize in the wiki where the extension is installed\n                initializeMandatoryDocument(namespace.substring(\"wiki:\".length()), initializer, context);\n            }\n        } catch (ComponentLookupException e) {\n            LOGGER.error(\"Failed to lookup mandatory document initializer\", e);\n        }\n    }\n\n    /**\n     * The reference to match properties \"plugins\" and \"backlinks\" of class XWiki.XWikiPreference on whatever wiki.\n     */\n    private static final RegexEntityReference XWIKIPREFERENCE_PROPERTY_REFERENCE =\n        XWikiPreferencesDocumentInitializer.OBJECT_REFERENCE;\n\n    private static final List<Event> LISTENER_EVENTS =\n        Arrays.<Event>asList(new XObjectPropertyAddedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyDeletedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyUpdatedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE), new WikiDeletedEvent(),\n            new ComponentDescriptorAddedEvent(MandatoryDocumentInitializer.class));\n\n    @Override\n    public List<Event> getEvents()\n    {\n        return LISTENER_EVENTS;\n    }\n\n    @Override\n    public String getName()\n    {\n        return \"xwiki-core\";\n    }\n\n    /**\n     * Return the document reference to the wiki preferences.\n     *\n     * @param context see {@link XWikiContext}\n     * @since 4.3M2\n     */\n    private DocumentReference getPreferencesDocumentReference(XWikiContext context)\n    {\n        String database = context.getWikiId();\n        EntityReference spaceReference;\n        if (database != null) {\n            spaceReference = new EntityReference(SYSTEM_SPACE, EntityType.SPACE, new WikiReference(database));\n        } else {\n            spaceReference = getCurrentMixedEntityReferenceResolver().resolve(SYSTEM_SPACE, EntityType.SPACE);\n        }\n        return new DocumentReference(\"XWikiPreferences\", new SpaceReference(spaceReference));\n    }\n\n    /**\n     * Search attachments by passing HQL where clause values as parameters. You can specify properties of the \"attach\"\n     * (the attachment) or \"doc\" (the document it is attached to)\n     *\n     * @param parametrizedSqlClause The HQL where clause. For example {@code where doc.fullName\n     *        <> ?1 and (attach.author = ?2 or (attach.filename = ?3 and doc.space = ?4))}\n     * @param checkRight if true, only return attachments in documents which the \"current user\" has permission to view.\n     * @param nb The number of rows to return. If 0 then all rows are returned\n     * @param start The number of rows to skip at the beginning.\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return A List of {@link XWikiAttachment} objects.\n     * @throws XWikiException in case of error while performing the query\n     * @see com.xpn.xwiki.store.XWikiStoreInterface#searchDocuments(String, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     * @deprecated since 9.7RC1, use the QueryManager instead along with the \"attachment\" query filter\n     */\n    @Deprecated\n    public List<XWikiAttachment> searchAttachments(String parametrizedSqlClause, boolean checkRight, int nb, int start,\n        List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        // Get the attachment filenames and document fullNames\n        List<java.lang.Object[]> results = this.getStore().search(\n            \"select attach.filename, doc.fullName from XWikiAttachment attach, XWikiDocument doc where doc.id = attach.docId and \"\n                + parametrizedSqlClause,\n            nb, start, parameterValues, context);\n\n        HashMap<String, List<String>> filenamesByDocFullName = new HashMap<>();\n\n        // Put each attachment name with the document name it belongs to\n        for (int i = 0; i < results.size(); i++) {\n            String filename = (String) results.get(i)[0];\n            String docFullName = (String) results.get(i)[1];\n            if (!filenamesByDocFullName.containsKey(docFullName)) {\n                filenamesByDocFullName.put(docFullName, new ArrayList<String>());\n            }\n            filenamesByDocFullName.get(docFullName).add(filename);\n        }\n\n        List<XWikiAttachment> out = new ArrayList<>();\n\n        // Index through the document names, get relivent attachments\n        for (Map.Entry<String, List<String>> entry : filenamesByDocFullName.entrySet()) {\n            String fullName = entry.getKey();\n\n            XWikiDocument doc = getDocument(fullName, context);\n            if (checkRight) {\n                if (!context.getWiki().getRightService().hasAccessLevel(\"view\", context.getUser(), doc.getFullName(),\n                    context)) {\n                    continue;\n                }\n            }\n            List<String> returnedAttachmentNames = entry.getValue();\n            for (XWikiAttachment attach : doc.getAttachmentList()) {\n                if (returnedAttachmentNames.contains(attach.getFilename())) {\n                    out.add(attach);\n                }\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Count attachments returned by a given parameterized query\n     *\n     * @param parametrizedSqlClause Everything which would follow the \"WHERE\" in HQL\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return int number of attachments found.\n     * @throws XWikiException in event of an exception querying the database\n     * @see #searchAttachments(String, boolean, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     */\n    public int countAttachments(String parametrizedSqlClause, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        List l = getStore().search(\"select count(attach) from XWikiAttachment attach, XWikiDocument doc where \"\n            + \"attach.docId=doc.id and \" + parametrizedSqlClause, 0, 0, parameterValues, context);\n        return ((Number) l.get(0)).intValue();\n    }\n\n    // Deprecated\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#getConfigPath()} instead\n     */\n    @Deprecated\n    public static String getConfigPath() throws NamingException\n    {\n        return XWikiCfgConfigurationSource.getConfigPath();\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context) throws XWikiException\n    {\n        this(config, context, null, false);\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(config, context, engine_context, noupdate);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context) throws XWikiException\n    {\n        this(xwikicfgpath, context, null, false);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        try {\n            initXWiki(new XWikiConfig(new FileInputStream(xwikicfgpath)), context, engine_context, noupdate);\n        } catch (FileNotFoundException e) {\n            Object[] args = { xwikicfgpath };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CONFIG, XWikiException.ERROR_XWIKI_CONFIG_FILENOTFOUND,\n                \"Configuration file {0} not found\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(InputStream is, XWikiContext context, XWikiEngineContext engine_context) throws XWikiException\n    {\n        initXWiki(new XWikiConfig(is), context, engine_context, true);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public XWikiConfig getConfig()\n    {\n        return new XWikiConfigDelegate(getConfiguration());\n    }\n\n    /**\n     * @deprecated since 6.1M2\n     */\n    @Deprecated\n    public void setConfig(XWikiConfig config)\n    {\n        ConfigurationSource configuration = getConfiguration();\n\n        if (configuration instanceof XWikiCfgConfigurationSource) {\n            ((XWikiCfgConfigurationSource) configuration).set(config);\n        }\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key)\n    {\n        return Param(key, null);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key, String default_value)\n    {\n        if (getConfiguration() != null) {\n            return getConfiguration().getProperty(key, default_value);\n        }\n\n        return default_value;\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key)\n    {\n        return getConfiguration().getProperty(key, long.class);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key, long default_value)\n    {\n        return getConfiguration().getProperty(key, default_value);\n    }\n\n    /**\n     * @return true if the wiki is in path based mode, fale otherwise\n     * @since 11.9RC1\n     */\n    public boolean isPathBased()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.virtual.usepath\", \"1\"));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.io.ByteArrayInputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.servlet.http.Cookie;\n\nimport org.apache.commons.collections4.IteratorUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentCreatingEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentDeletingEvent;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.query.QueryExecutor;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.wiki.WikiModel;\nimport org.xwiki.test.annotation.AfterComponent;\nimport org.xwiki.test.annotation.AllComponents;\nimport org.xwiki.test.junit5.mockito.InjectComponentManager;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.test.mockito.MockitoComponentManager;\n\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.XWikiCfgConfigurationSource;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.BaseProperty;\nimport com.xpn.xwiki.objects.StringProperty;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiServletRequest;\nimport com.xpn.xwiki.web.XWikiServletRequestStub;\nimport com.xpn.xwiki.web.XWikiServletResponseStub;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.notNull;\nimport static org.mockito.ArgumentMatchers.same;\nimport static org.mockito.Mockito.atLeastOnce;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link com.xpn.xwiki.XWiki}.\n *\n * @version $Id$\n */\n@OldcoreTest(mockXWiki = false)\n@AllComponents\npublic class XWikiTest\n{\n    @InjectMockitoOldcore\n    MockitoOldcore oldcore;\n\n    @MockComponent\n    private XWikiRecycleBinStoreInterface recycleBinStoreInterface;\n\n    private static final String DOCWIKI = \"Wiki\";\n\n    private static final String DOCSPACE = \"MilkyWay\";\n\n    private static final String DOCNAME = \"Fidis\";\n\n    private XWikiDocument document;\n\n    private XWiki xwiki;\n\n    @AfterComponent\n    public void afterComponent() throws Exception\n    {\n        MockitoComponentManager componentManager = this.oldcore.getMocker();\n\n        // Unregister XWikiCfgConfigurationSource so that it's mocked by MockitoOldcore\n        componentManager.unregisterComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);\n\n        // Mock the HQL query executor because we don't need it and it can cause problems\n        componentManager.registerMockComponent(QueryExecutor.class, \"hql\");\n\n        componentManager.unregisterComponent(new DefaultParameterizedType(null, Provider.class, ComponentManager.class)\n            , \"context\");\n        Provider<ComponentManager> componentManagerProvider = componentManager\n            .registerMockComponent(new DefaultParameterizedType(null, Provider.class, ComponentManager.class)\n                , \"context\");\n        when(componentManagerProvider.get()).thenReturn(componentManager);\n        componentManager.registerMockComponent(WikiModel.class);\n    }\n\n    @BeforeEach\n    protected void beforeEach() throws Exception\n    {\n        this.document = new XWikiDocument(new DocumentReference(\"Wiki\", \"MilkyWay\", \"Fidis\"));\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequestStub());\n        this.oldcore.getXWikiContext().setResponse(new XWikiServletResponseStub());\n        this.oldcore.getXWikiContext().setURL(new URL(\"http://localhost:8080/xwiki/bin/view/MilkyWay/Fidis\"));\n\n        this.oldcore.getXWikiContext().setLocale(null);\n\n        this.xwiki = this.oldcore.getSpyXWiki();\n\n        // Ensure that no Velocity Templates are going to be used when executing Velocity since otherwise\n        // the Velocity init would fail (since by default the macros.vm templates wouldn't be found as we're\n        // not providing it in our unit test resources).\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.render.velocity.macrolist\", \"\");\n\n        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());\n\n        this.document.setCreator(\"Condor\");\n        this.document.setAuthor(\"Albatross\");\n\n        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());\n        this.xwiki.setRecycleBinStore(this.recycleBinStoreInterface);\n        this.oldcore.getXWikiContext().put(\"isInRenderingEngine\", true);\n    }\n\n    @Test\n    public void testUserNotAddedByDefaultToXWikiAllGroupWhenThisGroupImplicit() throws Exception\n    {\n        // given\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.authentication.group.allgroupimplicit\", \"1\");\n\n        XWikiGroupServiceImpl xWikiGroupService = new XWikiGroupServiceImpl();\n        xwiki.setGroupService(xWikiGroupService);\n\n        XWiki spyXWiki = Mockito.spy(xwiki);\n\n        // when\n        spyXWiki.setUserDefaultGroup(\"XWiki.user1\", this.oldcore.getXWikiContext());\n\n        // then\n        Mockito.verify(spyXWiki, times(0)).addUserToGroup(anyString(), anyString(), any(XWikiContext.class));\n    }\n\n    @Test\n    public void testUserAddedToXWikiAllGroupWhenItsSpecifiedByConfigurationRegardlessXWikiAllGroupIsImplicit()\n        throws Exception\n    {\n        // given\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.authentication.group.allgroupimplicit\", \"1\");\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.users.initialGroups\", \"XWiki.XWikiAllGroup\");\n\n        XWikiGroupServiceImpl xWikiGroupService = new XWikiGroupServiceImpl();\n        xwiki.setGroupService(xWikiGroupService);\n\n        // when\n        this.xwiki.setUserDefaultGroup(\"XWiki.user1\", this.oldcore.getXWikiContext());\n\n        // then\n        verify(this.xwiki, times(1)).addUserToGroup(\"XWiki.user1\", \"XWiki.XWikiAllGroup\",\n            this.oldcore.getXWikiContext());\n    }\n\n    @Test\n    public void testAuthorAfterDocumentCopy() throws XWikiException\n    {\n        DocumentReference copyReference =\n            new DocumentReference(\"Lyre\", this.document.getDocumentReference().getLastSpaceReference());\n        DocumentReference author = this.document.getAuthorReference();\n        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());\n        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());\n\n        assertEquals(author, copy.getAuthorReference());\n    }\n\n    @Test\n    public void testCreatorAfterDocumentCopy() throws XWikiException\n    {\n        DocumentReference copyReference =\n            new DocumentReference(\"Sirius\", this.document.getDocumentReference().getLastSpaceReference());\n        DocumentReference creator = this.document.getCreatorReference();\n        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());\n        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());\n\n        assertEquals(creator, copy.getCreatorReference());\n    }\n\n    @Test\n    public void testCreationDateAfterDocumentCopy() throws XWikiException, InterruptedException\n    {\n        Date sourceCreationDate = this.document.getCreationDate();\n        Thread.sleep(1000);\n        DocumentReference copyReference = new DocumentReference(this.document.getDocumentReference().getName() + \"Copy\",\n            this.document.getDocumentReference().getLastSpaceReference());\n        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());\n        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());\n\n        assertTrue(copy.getCreationDate().equals(sourceCreationDate));\n    }\n\n    @Test\n    public void testParseTemplateConsidersObjectField() throws XWikiException\n    {\n        DocumentReference skinReference =\n            new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"XWikiSkins\");\n        XWikiDocument skinClass = new XWikiDocument(skinReference);\n        skinClass.getXClass().addTextAreaField(\"template.vm\", \"template\", 80, 20);\n        this.xwiki.saveDocument(skinClass, this.oldcore.getXWikiContext());\n\n        DocumentReference mySkinReference =\n            new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"Skin\");\n        XWikiDocument skinDocument = new XWikiDocument(mySkinReference);\n        BaseObject obj = skinDocument.newXObject(skinReference, this.oldcore.getXWikiContext());\n        obj.setLargeStringValue(\"template.vm\", \"parsing a field\");\n        this.xwiki.saveDocument(skinDocument, this.oldcore.getXWikiContext());\n\n        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");\n        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));\n        assertFalse(this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()).isNew());\n        assertEquals(skinDocument, this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()));\n        assertEquals(\"parsing a field\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * See XWIKI-2096\n     */\n    @Test\n    public void testParseTemplateConsidersAttachment() throws XWikiException\n    {\n        XWikiDocument skin =\n            new XWikiDocument(new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"Skin\"));\n        XWikiAttachment attachment = new XWikiAttachment();\n        skin.getAttachmentList().add(attachment);\n        attachment.setContent(\"parsing an attachment\".getBytes());\n        attachment.setFilename(\"template.vm\");\n        attachment.setDoc(skin);\n        this.xwiki.saveDocument(skin, this.oldcore.getXWikiContext());\n        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");\n\n        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));\n        assertFalse(this.xwiki.getDocument(\"XWiki.Skin\", this.oldcore.getXWikiContext()).isNew());\n        assertEquals(skin, this.xwiki.getDocument(\"XWiki.Skin\", this.oldcore.getXWikiContext()));\n        assertEquals(\"parsing an attachment\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * See XWIKI-2098\n     */\n    @Test\n    public void testParseTemplateConsidersObjectFieldBeforeAttachment() throws Exception\n    {\n        DocumentReference skinReference = new DocumentReference(\"xwiki\", \"XWiki\", \"XWikiSkins\");\n        XWikiDocument skinClass = new XWikiDocument(skinReference);\n        skinClass.getXClass().addTextAreaField(\"template.vm\", \"template\", 80, 20);\n        this.xwiki.saveDocument(skinClass, this.oldcore.getXWikiContext());\n\n        DocumentReference mySkinReference = new DocumentReference(\"xwiki\", \"XWiki\", \"Skin\");\n        XWikiDocument skinDocument = new XWikiDocument(mySkinReference);\n        BaseObject obj = skinDocument.newXObject(skinReference, this.oldcore.getXWikiContext());\n        obj.setLargeStringValue(\"template.vm\", \"parsing a field\");\n        XWikiAttachment attachment = new XWikiAttachment();\n        skinDocument.getAttachmentList().add(attachment);\n        attachment.setContent(new ByteArrayInputStream(\"parsing an attachment\".getBytes()));\n        attachment.setFilename(\"template.vm\");\n        attachment.setDoc(skinDocument);\n        this.xwiki.saveDocument(skinDocument, this.oldcore.getXWikiContext());\n        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");\n        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));\n        assertFalse(this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()).isNew());\n        assertEquals(skinDocument, this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()));\n        assertEquals(\"parsing a field\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testClearNameWithoutStripDotsWithoutAscii()\n    {\n        assertEquals(\"ee{&.txt\",\n            this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", false, false, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testClearNameWithoutStripDotsWithAscii()\n    {\n        assertEquals(\"ee.txt\", this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", false, true, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testClearNameWithStripDotsWithoutAscii()\n    {\n        assertEquals(\"ee{&txt\",\n            this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", true, false, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testClearNameWithStripDotsWithAscii()\n    {\n        assertEquals(\"eetxt\", this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", true, true, this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * We only verify here that the saveDocument API calls the Observation component.\n     */\n    @Test\n    public void testSaveDocumentSendsObservationEvents() throws Exception\n    {\n        EventListener mockListener = mock(EventListener.class);\n        when(mockListener.getName()).thenReturn(\"testlistener\");\n        DocumentReference ref = new DocumentReference(\"xwikitest\", \"Some\", \"Document\");\n        when(mockListener.getEvents())\n            .thenReturn(Arrays.asList(new DocumentCreatedEvent(ref), new DocumentCreatingEvent(ref)));\n\n        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);\n        om.addListener(mockListener);\n\n        verify(mockListener).getEvents();\n\n        XWikiDocument document = new XWikiDocument(ref);\n        document.setContent(\"the content\");\n\n        this.xwiki.saveDocument(document, this.oldcore.getXWikiContext());\n\n        // Ensure that the onEvent method has been called before and after the save\n        verify(mockListener).onEvent(any(DocumentCreatingEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n        verify(mockListener).onEvent(any(DocumentCreatedEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * We only verify here that the renameDocument API calls the Observation component.\n     */\n    @Test\n    public void testRenameDocumentSendsObservationEvents() throws Exception\n    {\n        DocumentReference sourceReference = new DocumentReference(\"xwikitest\", \"Some\", \"Source\");\n        DocumentReference targetReference = new DocumentReference(\"xwikitest\", \"Some\", \"Target\");\n\n        XWikiDocument sourceDocument = new XWikiDocument(sourceReference);\n        sourceDocument.setSyntax(Syntax.PLAIN_1_0);\n        this.xwiki.saveDocument(sourceDocument, this.oldcore.getXWikiContext());\n\n        EventListener mockListener = mock(EventListener.class);\n        when(mockListener.getName()).thenReturn(\"testlistener\");\n        when(mockListener.getEvents()).thenReturn(\n            Arrays.asList(new DocumentCreatedEvent(targetReference), new DocumentCreatingEvent(targetReference),\n                new DocumentDeletingEvent(sourceReference), new DocumentDeletedEvent(sourceReference)));\n\n        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);\n        om.addListener(mockListener);\n\n        verify(mockListener).getEvents();\n\n        this.xwiki.renameDocument(sourceReference, targetReference, false, Collections.emptyList(), null,\n            this.oldcore.getXWikiContext());\n\n        // Ensure that the onEvent method has been called before and after the rename\n        verify(mockListener).onEvent(any(DocumentCreatingEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n        verify(mockListener).onEvent(any(DocumentCreatedEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n        verify(mockListener).onEvent(any(DocumentDeletingEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n        verify(mockListener).onEvent(any(DocumentDeletedEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * We only verify here that the deleteDocument API calls the Observation component.\n     */\n    @Test\n    public void testDeleteDocumentSendsObservationEvents() throws Exception\n    {\n        EventListener mockListener = mock(EventListener.class);\n        when(mockListener.getName()).thenReturn(\"testlistener\");\n        DocumentReference ref = new DocumentReference(\"xwikitest\", \"Another\", \"Document\");\n        when(mockListener.getEvents())\n            .thenReturn(Arrays.asList(new DocumentDeletedEvent(ref), new DocumentDeletingEvent(ref)));\n\n        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);\n        om.addListener(mockListener);\n\n        verify(mockListener).getEvents();\n\n        XWikiDocument document = new XWikiDocument(ref);\n        document.setContent(\"the content\");\n\n        // Not expectation on mock Listener since we're not subscribed to Document save events\n\n        this.xwiki.saveDocument(document, this.oldcore.getXWikiContext());\n\n        this.xwiki.deleteDocument(document, false, this.oldcore.getXWikiContext());\n\n        // Ensure that the onEvent method has been called before and after the save\n        verify(mockListener).onEvent(any(DocumentDeletingEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n        verify(mockListener).onEvent(any(DocumentDeletedEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testLanguageSelection() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public Enumeration getLocales()\n            {\n                ArrayList<Locale> locales = new ArrayList<Locale>();\n                locales.add(new Locale(\"*\"));\n                locales.add(new Locale(\"en\", \"US\"));\n                locales.add(new Locale(\"fr\"));\n                locales.add(new Locale(\"de\"));\n                return IteratorUtils.asEnumeration(locales.iterator());\n            }\n\n            @Override\n            public String getHeader(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return null;\n                }\n                return \"en\";\n            }\n\n            @Override\n            public Cookie getCookie(String cookieName)\n            {\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        assertEquals(\"en\", this.xwiki.getLanguagePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testLanguageSelectionWithSupportedLanguages() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public Enumeration getLocales()\n            {\n                ArrayList<Locale> locales = new ArrayList<Locale>();\n                locales.add(new Locale(\"*\"));\n                locales.add(new Locale(\"fr\", \"FR\"));\n                locales.add(new Locale(\"de\"));\n                return IteratorUtils.asEnumeration(locales.iterator());\n            }\n\n            @Override\n            public String getHeader(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return null;\n                }\n                return \"en\";\n            }\n\n            @Override\n            public Cookie getCookie(String cookieName)\n            {\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languages\", \"en, |fr_FR, |en_US, |fr_CA\");\n\n        assertEquals(\"fr_FR\", this.xwiki.getLanguagePreference(this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * XWIKI-8469: Bad default of 1 in XWiki.isMultilingual instead of 0 (when no XWikiPreferences object exists)\n     */\n    @Test\n    public void testIsMultilingualDefaultFalse() throws Exception\n    {\n        assertFalse(this.xwiki.isMultiLingual(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetCurrentContentSyntaxId()\n    {\n        XWikiDocument doc1 = new XWikiDocument();\n        doc1.setSyntax(Syntax.CREOLE_1_0);\n        XWikiDocument doc2 = new XWikiDocument();\n        doc2.setSyntax(Syntax.PLAIN_1_0);\n\n        assertNull(this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));\n        assertEquals(\"syntaxId\", this.xwiki.getCurrentContentSyntaxId(\"syntaxId\", this.oldcore.getXWikiContext()));\n\n        this.oldcore.getXWikiContext().setDoc(doc1);\n\n        assertEquals(Syntax.CREOLE_1_0.toIdString(),\n            this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));\n\n        this.oldcore.getXWikiContext().put(\"sdoc\", doc2);\n\n        assertEquals(Syntax.PLAIN_1_0.toIdString(),\n            this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * Check that the user validation feature works when the validation key is stored both as plain text and as a hashed\n     * field.\n     *\n     * @throws Exception when any exception occurs inside XWiki\n     */\n    @Test\n    public void testValidationKeyStorage() throws Exception\n    {\n        XWikiContext context = this.oldcore.getXWikiContext();\n        context.setLanguage(\"en\");\n\n        // Prepare the request\n        XWikiRequest request = mock(XWikiRequest.class);\n        when(request.getParameter(\"xwikiname\")).thenReturn(\"TestUser\");\n        when(request.getParameter(\"validkey\")).thenReturn(\"plaintextkey\");\n        context.setRequest(request);\n\n        // Prepare the user profile\n        XWikiDocument testUser =\n            new XWikiDocument(new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"TestUser\"));\n        BaseObject userObject = (BaseObject) this.xwiki.getUserClass(context).newObject(context);\n\n        // Check with a correct plaintext key\n        BaseProperty validationKey = new StringProperty();\n        validationKey.setValue(\"plaintextkey\");\n        userObject.safeput(\"validkey\", validationKey);\n        testUser.addObject(\"XWiki.XWikiUsers\", userObject);\n\n        this.xwiki.saveDocument(testUser, context);\n\n        assertEquals(0, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));\n\n        // Check with an incorrect plaintext key\n        validationKey.setValue(\"wrong key\");\n        this.xwiki.saveDocument(testUser, context);\n\n        assertEquals(-1, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));\n\n        // Check with a correct hashed key\n        validationKey = ((PropertyClass) this.xwiki.getUserClass(context).get(\"validkey\")).fromString(\"plaintextkey\");\n        assertTrue(validationKey.getValue().toString().startsWith(\"hash:\"));\n        userObject.safeput(\"validkey\", validationKey);\n        this.xwiki.saveDocument(testUser, context);\n\n        assertEquals(0, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));\n\n        // Check with an incorrect hashed key\n        validationKey = ((PropertyClass) this.xwiki.getUserClass(context).get(\"validkey\")).fromString(\"wrong key\");\n        assertTrue(validationKey.getValue().toString().startsWith(\"hash:\"));\n        userObject.safeput(\"validkey\", validationKey);\n        this.xwiki.saveDocument(testUser, context);\n\n        assertEquals(-1, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * Tests that XWiki.XWikiPreferences page is not saved each time XWiki is initialized.\n     *\n     * @throws Exception when any exception occurs inside XWiki\n     */\n    @Test\n    public void testGetPrefsClass() throws Exception\n    {\n        when(this.oldcore.getMockStore().getLimitSize(any(), any(), any())).thenReturn(255);\n\n        XWikiDocument prefsDoc = new XWikiDocument(new DocumentReference(\"xwiki\", \"XWiki\", \"XWikiPreferences\"));\n        final Map<DocumentReference, XWikiDocument> documents = new HashMap<DocumentReference, XWikiDocument>();\n        documents.put(prefsDoc.getDocumentReference(), prefsDoc);\n\n        when(this.oldcore.getMockStore().loadXWikiDoc(notNull(), same(this.oldcore.getXWikiContext())))\n            .then(new Answer<XWikiDocument>()\n            {\n\n                @Override\n                public XWikiDocument answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocument document = (XWikiDocument) invocation.getArgument(0);\n                    if (!documents.containsKey(document.getDocumentReference())) {\n                        documents.put(document.getDocumentReference(), document);\n                    } else {\n                        document = documents.get(document.getDocumentReference());\n                    }\n                    return document;\n                }\n            });\n\n        this.xwiki.getPrefsClass(this.oldcore.getXWikiContext());\n        this.xwiki.getPrefsClass(this.oldcore.getXWikiContext());\n\n        verify(this.oldcore.getMockStore(), atLeastOnce()).loadXWikiDoc(notNull(),\n            same(this.oldcore.getXWikiContext()));\n        verify(this.oldcore.getMockStore()).saveXWikiDoc(same(prefsDoc), same(this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * XWIKI-12398: No layout for login page in a closed wiki\n     */\n    @Test\n    public void testSkinResourcesAreAlwaysAllowed() throws XWikiException\n    {\n        // /skin/resources/icons/xwiki/noavatar.png\n        XWikiDocument doc1 = new XWikiDocument(\n            new DocumentReference(\"xwiki\", Arrays.asList(\"resources\", \"icons\", \"xwiki\"), \"noavatar.png\"));\n        // /skin/skins/flamingo/style.css\n        XWikiDocument doc2 =\n            new XWikiDocument(new DocumentReference(\"xwiki\", Arrays.asList(\"skins\", \"flamingo\", \"xwiki\"), \"style.css\"));\n\n        // Verify the results.\n        assertTrue(this.xwiki.checkAccess(\"skin\", doc1, this.oldcore.getXWikiContext()));\n        assertTrue(this.xwiki.checkAccess(\"skin\", doc2, this.oldcore.getXWikiContext()));\n\n        // Make sure it is never called to validate the test's results.\n        verify(this.oldcore.getMockRightService(), never()).checkAccess(any(), any(), any());\n        verify(this.oldcore.getMockAuthService(), times(2)).checkAuth(this.oldcore.getXWikiContext());\n    }\n\n    @Test\n    public void testCheckActiveSuperadmin() throws Exception\n    {\n        int isUserActive =\n            this.xwiki.checkActive(XWikiRightService.SUPERADMIN_USER_FULLNAME, this.oldcore.getXWikiContext());\n\n        assertEquals(1, isUserActive);\n    }\n\n    /**\n     * XWIKI-14300: Superadmin is locked out of subwikis with \"AUTHENTICATION ACTIVE CHECK\" enabled\n     */\n    @Test\n    public void testCheckActivePrefixedSuperadmin() throws Exception\n    {\n        // In a subwiki, the superadmin always logs in as a global user.\n        int isUserActive = this.xwiki.checkActive(\"xwiki:\" + XWikiRightService.SUPERADMIN_USER_FULLNAME,\n            this.oldcore.getXWikiContext());\n\n        assertEquals(1, isUserActive);\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithContext() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null));\n        this.oldcore.getXWikiContext().setLocale(Locale.FRENCH);\n\n        assertEquals(Locale.FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceDefaultNonMultilingual() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null));\n\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithParameterForcingUnset() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public String getParameter(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return \"fr_CA\";\n                }\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // we do not force supported languages\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.language.forceSupported\", \"0\");\n\n        assertEquals(Locale.CANADA_FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithParameter() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public String getParameter(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return \"fr_CA\";\n                }\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // only the default language is supported by default\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithParameterWithSupportedLanguages() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public String getParameter(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return \"fr_CA\";\n                }\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languages\", \"en, |fr_FR, |en_US, |fr_CA\");\n\n        // only the default language is supported by default\n        assertEquals(Locale.CANADA_FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithParameterDefault() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public String getParameter(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return \"default\";\n                }\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithCookieForcingUnset() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Cookie[] getCookies()\n            {\n                return new Cookie[] { new Cookie(\"language\", \"fr_CA\") };\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // we do not force supported languages\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.language.forceSupported\", \"0\");\n\n        assertEquals(Locale.CANADA_FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithCookie() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Cookie[] getCookies()\n            {\n                return new Cookie[] { new Cookie(\"language\", \"fr_CA\") };\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // By default we force only supported languages\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithCookieDefaultNotSet() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Cookie[] getCookies()\n            {\n                return new Cookie[] { new Cookie(\"language\", \"fr_CA\") };\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // By default we force only supported languages\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithCookieDefaultSet() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Cookie[] getCookies()\n            {\n                return new Cookie[] { new Cookie(\"language\", \"fr_CA\") };\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languages\", \"en, |fr_FR, |en_US, |fr_CA\");\n\n        // By default we force only supported languages\n        assertEquals(Locale.CANADA_FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithNavigatorLanguagesForcingUnset() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Enumeration<Locale> getLocales()\n            {\n                ArrayList<Locale> locales = new ArrayList<>();\n                locales.add(new Locale(\"*\"));\n                locales.add(new Locale(\"en\", \"US\"));\n                locales.add(new Locale(\"fr\"));\n                locales.add(new Locale(\"de\"));\n                return IteratorUtils.asEnumeration(locales.iterator());\n            }\n        });\n\n        // we do not force supported languages\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.language.forceSupported\", \"0\");\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        assertEquals(Locale.US, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithNavigatorLanguages() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Enumeration<Locale> getLocales()\n            {\n                ArrayList<Locale> locales = new ArrayList<>();\n                locales.add(new Locale(\"*\"));\n                locales.add(new Locale(\"en\", \"US\"));\n                locales.add(new Locale(\"fr\"));\n                locales.add(new Locale(\"de\"));\n                return IteratorUtils.asEnumeration(locales.iterator());\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // it's forced to \"en\" since it's the only supported language by default\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithNavigatorLanguagesDefaultSet() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Enumeration<Locale> getLocales()\n            {\n                ArrayList<Locale> locales = new ArrayList<>();\n                locales.add(new Locale(\"*\"));\n                locales.add(new Locale(\"en\", \"US\"));\n                locales.add(new Locale(\"fr\"));\n                locales.add(new Locale(\"de\"));\n                return IteratorUtils.asEnumeration(locales.iterator());\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languages\", \"en, |fr_FR, |en_US, |fr_CA\");\n\n        // en_US is the first common language between supported and browser supported.\n        assertEquals(Locale.US, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithNavigatorLanguagesFallback() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null));\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    // test implementation of document rename before atomic rename.\n    @Test\n    public void renameDocumentOldImplementation() throws Exception\n    {\n        // Possible ways to write parents, include documents, or make links:\n        // \"name\" -----means-----> DOCWIKI+\":\"+DOCSPACE+\".\"+input\n        // \"space.name\" -means----> DOCWIKI+\":\"+input\n        // \"database:space.name\" (no change)\n\n        // We don't want to use atomic rename here: we are testing the old implementation.\n        this.oldcore.getConfigurationSource().setProperty(\"refactoring.rename.useAtomicRename\", false);\n\n        this.document.setContent(\"[[doc:pageinsamespace]]\");\n        this.document.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());\n\n        DocumentReference reference1 = new DocumentReference(DOCWIKI, DOCSPACE, \"Page1\");\n        XWikiDocument doc1 = new XWikiDocument(reference1);\n        doc1.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]] [[someName>>doc:\" + DOCSPACE + \".\"\n            + DOCNAME + \"]] [[doc:\" + DOCNAME + \"]]\");\n        doc1.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc1, this.oldcore.getXWikiContext());\n\n        DocumentReference reference2 = new DocumentReference(\"newwikiname\", DOCSPACE, \"Page2\");\n        XWikiDocument doc2 = new XWikiDocument(reference2);\n        doc2.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]]\");\n        doc2.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc2, this.oldcore.getXWikiContext());\n\n        DocumentReference reference3 = new DocumentReference(\"newwikiname\", \"newspace\", \"Page3\");\n        XWikiDocument doc3 = new XWikiDocument(reference3);\n        doc3.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]]\");\n        doc3.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc3, this.oldcore.getXWikiContext());\n\n        // Test to make sure it also drags children along.\n        DocumentReference reference4 = new DocumentReference(DOCWIKI, DOCSPACE, \"Page4\");\n        XWikiDocument doc4 = new XWikiDocument(reference4);\n        doc4.setParent(DOCSPACE + \".\" + DOCNAME);\n        this.xwiki.saveDocument(doc4, this.oldcore.getXWikiContext());\n\n        DocumentReference reference5 = new DocumentReference(\"newwikiname\", \"newspace\", \"Page5\");\n        XWikiDocument doc5 = new XWikiDocument(reference5);\n        doc5.setParent(DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME);\n        this.xwiki.saveDocument(doc5, this.oldcore.getXWikiContext());\n\n        DocumentReference targetReference = new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\");\n        this.xwiki.renameDocument(this.document.getDocumentReference(),\n            targetReference, true,\n            Arrays.asList(reference1, reference2, reference3), Arrays.asList(reference4, reference5),\n            this.oldcore.getXWikiContext());\n\n        // Test links\n        assertEquals(\"[[doc:Wiki:MilkyWay.pageinsamespace]]\",\n            this.xwiki.getDocument(targetReference, this.oldcore.getXWikiContext()).getContent());\n        assertTrue(this.xwiki\n            .getDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME), this.oldcore.getXWikiContext()).isNew());\n        assertEquals(\"[[doc:newwikiname:newspace.newpage]] \" + \"[[someName>>doc:newwikiname:newspace.newpage]] \"\n            + \"[[doc:newwikiname:newspace.newpage]]\",\n            this.xwiki.getDocument(reference1, this.oldcore.getXWikiContext()).getContent());\n        assertEquals(\"[[doc:newspace.newpage]]\",\n            this.xwiki.getDocument(reference2, this.oldcore.getXWikiContext()).getContent());\n        assertEquals(\"[[doc:newpage]]\",\n            this.xwiki.getDocument(reference3, this.oldcore.getXWikiContext()).getContent());\n\n        // Test parents\n        assertEquals(\"newwikiname:newspace.newpage\",\n            this.xwiki.getDocument(reference4, this.oldcore.getXWikiContext()).getParent());\n        assertEquals(new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\"),\n            this.xwiki.getDocument(reference5, this.oldcore.getXWikiContext()).getParentReference());\n    }\n\n    @Test\n    public void atomicRename() throws Exception\n    {\n        doAnswer(invocationOnMock -> {\n            XWikiDocument sourceDoc = invocationOnMock.getArgument(0);\n            DocumentReference targetReference = invocationOnMock.getArgument(1);\n            XWikiContext context = invocationOnMock.getArgument(2);\n            XWikiDocument targetDoc = sourceDoc.cloneRename(targetReference, context);\n            this.xwiki.saveDocument(targetDoc, context);\n            this.xwiki.deleteDocument(sourceDoc, true, context);\n            return null;\n        }).when(this.oldcore.getMockStore()).renameXWikiDoc(any(), any(), any());\n        this.document.setContent(\"[[doc:pageinsamespace]]\");\n        this.document.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());\n\n        DocumentReference reference1 = new DocumentReference(DOCWIKI, DOCSPACE, \"Page1\");\n        XWikiDocument doc1 = new XWikiDocument(reference1);\n        doc1.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]] [[someName>>doc:\" + DOCSPACE + \".\"\n            + DOCNAME + \"]] [[doc:\" + DOCNAME + \"]]\");\n        doc1.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc1, this.oldcore.getXWikiContext());\n\n        DocumentReference reference2 = new DocumentReference(\"newwikiname\", DOCSPACE, \"Page2\");\n        XWikiDocument doc2 = new XWikiDocument(reference2);\n        doc2.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]]\");\n        doc2.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc2, this.oldcore.getXWikiContext());\n\n        DocumentReference reference3 = new DocumentReference(\"newwikiname\", \"newspace\", \"Page3\");\n        XWikiDocument doc3 = new XWikiDocument(reference3);\n        doc3.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]]\");\n        doc3.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc3, this.oldcore.getXWikiContext());\n\n        // Test to make sure it also drags children along.\n        DocumentReference reference4 = new DocumentReference(DOCWIKI, DOCSPACE, \"Page4\");\n        XWikiDocument doc4 = new XWikiDocument(reference4);\n        doc4.setParent(DOCSPACE + \".\" + DOCNAME);\n        this.xwiki.saveDocument(doc4, this.oldcore.getXWikiContext());\n\n        DocumentReference reference5 = new DocumentReference(\"newwikiname\", \"newspace\", \"Page5\");\n        XWikiDocument doc5 = new XWikiDocument(reference5);\n        doc5.setParent(DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME);\n        this.xwiki.saveDocument(doc5, this.oldcore.getXWikiContext());\n\n        DocumentReference targetReference = new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\");\n        this.xwiki.renameDocument(this.document.getDocumentReference(),\n            targetReference, true,\n            Arrays.asList(reference1, reference2, reference3), Arrays.asList(reference4, reference5),\n            this.oldcore.getXWikiContext());\n\n        // Test links\n        assertEquals(\"[[doc:Wiki:MilkyWay.pageinsamespace]]\",\n            this.xwiki.getDocument(targetReference, this.oldcore.getXWikiContext()).getContent());\n        assertTrue(this.xwiki\n            .getDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME), this.oldcore.getXWikiContext()).isNew());\n        assertEquals(\"[[doc:newwikiname:newspace.newpage]] \" + \"[[someName>>doc:newwikiname:newspace.newpage]] \"\n                + \"[[doc:newwikiname:newspace.newpage]]\",\n            this.xwiki.getDocument(reference1, this.oldcore.getXWikiContext()).getContent());\n        assertEquals(\"[[doc:newspace.newpage]]\",\n            this.xwiki.getDocument(reference2, this.oldcore.getXWikiContext()).getContent());\n        assertEquals(\"[[doc:newpage]]\",\n            this.xwiki.getDocument(reference3, this.oldcore.getXWikiContext()).getContent());\n\n        // Test parents\n        assertEquals(\"newwikiname:newspace.newpage\",\n            this.xwiki.getDocument(reference4, this.oldcore.getXWikiContext()).getParent());\n        assertEquals(new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\"),\n            this.xwiki.getDocument(reference5, this.oldcore.getXWikiContext()).getParentReference());\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.FileTime;\nimport java.text.DateFormatSymbols;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.Vector;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.annotation.Priority;\nimport javax.inject.Provider;\nimport javax.mail.Message;\nimport javax.mail.Session;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport javax.naming.NamingException;\nimport javax.script.ScriptContext;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.httpclient.Credentials;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.URIException;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.util.URIUtil;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.hibernate.HibernateException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentCreatingEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentDeletingEvent;\nimport org.xwiki.bridge.event.DocumentRolledBackEvent;\nimport org.xwiki.bridge.event.DocumentRollingBackEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatingEvent;\nimport org.xwiki.bridge.event.WikiCopiedEvent;\nimport org.xwiki.bridge.event.WikiDeletedEvent;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.classloader.ClassLoaderManager;\nimport org.xwiki.component.event.ComponentDescriptorAddedEvent;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.manager.NamespacedComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.container.servlet.HttpServletUtils;\nimport org.xwiki.context.Execution;\nimport org.xwiki.edit.EditConfiguration;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.JobException;\nimport org.xwiki.job.JobExecutor;\nimport org.xwiki.job.annotation.Serializable;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.event.status.JobStatus.State;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.mail.MailListener;\nimport org.xwiki.mail.MailSender;\nimport org.xwiki.mail.MailSenderConfiguration;\nimport org.xwiki.mail.MailStatusResultSerializer;\nimport org.xwiki.mail.XWikiAuthenticator;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.PageReferenceResolver;\nimport org.xwiki.model.reference.RegexEntityReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.CancelableEvent;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.refactoring.batch.BatchOperationExecutor;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.MetadataBlockMatcher;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxContent;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.ResourceReference;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceReferenceResolver;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.ResourceTypeResolver;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.skin.Resource;\nimport org.xwiki.skin.Skin;\nimport org.xwiki.skin.SkinManager;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.url.ExtendedURL;\nimport org.xwiki.url.URLConfiguration;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserPropertiesResolver;\nimport org.xwiki.velocity.VelocityContextFactory;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.XWikiVelocityContext;\nimport org.xwiki.velocity.XWikiVelocityException;\nimport org.xwiki.wiki.descriptor.WikiDescriptor;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\nimport org.xwiki.wiki.manager.WikiManager;\nimport org.xwiki.wiki.manager.WikiManagerException;\nimport org.xwiki.xml.XMLUtils;\n\nimport com.xpn.xwiki.api.Api;\nimport com.xpn.xwiki.api.Document;\nimport com.xpn.xwiki.api.User;\nimport com.xpn.xwiki.criteria.api.XWikiCriteriaService;\nimport com.xpn.xwiki.doc.DeletedAttachment;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.MandatoryDocumentInitializer;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiAttachmentArchive;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.internal.WikiInitializerJob;\nimport com.xpn.xwiki.internal.WikiInitializerRequest;\nimport com.xpn.xwiki.internal.XWikiCfgConfigurationSource;\nimport com.xpn.xwiki.internal.XWikiConfigDelegate;\nimport com.xpn.xwiki.internal.XWikiInitializerJob;\nimport com.xpn.xwiki.internal.debug.DebugConfiguration;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializedEvent;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializingEvent;\nimport com.xpn.xwiki.internal.event.UserCreatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserDeletingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserUpdatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyAddedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyDeletedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyUpdatedEvent;\nimport com.xpn.xwiki.internal.mandatory.XWikiPreferencesDocumentInitializer;\nimport com.xpn.xwiki.internal.render.LinkedResourceHelper;\nimport com.xpn.xwiki.internal.render.OldRendering;\nimport com.xpn.xwiki.internal.render.groovy.ParseGroovyFromString;\nimport com.xpn.xwiki.internal.skin.InternalSkinConfiguration;\nimport com.xpn.xwiki.internal.skin.InternalSkinManager;\nimport com.xpn.xwiki.internal.skin.WikiSkin;\nimport com.xpn.xwiki.internal.skin.WikiSkinUtils;\nimport com.xpn.xwiki.internal.store.StoreConfiguration;\nimport com.xpn.xwiki.internal.store.hibernate.HibernateConfiguration;\nimport com.xpn.xwiki.internal.velocity.VelocityEvaluator;\nimport com.xpn.xwiki.job.JobRequestContext;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PasswordClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.plugin.XWikiPluginInterface;\nimport com.xpn.xwiki.plugin.XWikiPluginManager;\nimport com.xpn.xwiki.render.groovy.XWikiPageClassLoader;\nimport com.xpn.xwiki.stats.api.XWikiStatsService;\nimport com.xpn.xwiki.stats.impl.SearchEngineRule;\nimport com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl;\nimport com.xpn.xwiki.store.AttachmentRecycleBinStore;\nimport com.xpn.xwiki.store.AttachmentVersioningStore;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.store.XWikiCacheStoreInterface;\nimport com.xpn.xwiki.store.XWikiHibernateStore;\nimport com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiAuthService;\nimport com.xpn.xwiki.user.api.XWikiGroupService;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiRightServiceImpl;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.util.XWikiStubContextProvider;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiServletRequestStub;\nimport com.xpn.xwiki.web.XWikiURLFactory;\nimport com.xpn.xwiki.web.XWikiURLFactoryService;\nimport com.xpn.xwiki.web.XWikiURLFactoryServiceImpl;\nimport com.xpn.xwiki.web.includeservletasstring.IncludeServletAsString;\n\n@Serializable(false)\npublic class XWiki implements EventListener\n{\n    /** Name of the default wiki. */\n    public static final String DEFAULT_MAIN_WIKI = \"xwiki\";\n\n    /** Name of the default home space. */\n    public static final String DEFAULT_HOME_SPACE = \"Main\";\n\n    /** Name of the default system space. */\n    public static final String SYSTEM_SPACE = \"XWiki\";\n\n    /** Name of the default space homepage. */\n    public static final String DEFAULT_SPACE_HOMEPAGE = \"WebHome\";\n\n    public static final String CKEY_SKIN = InternalSkinManager.CKEY_SKIN;\n\n    public static final String CKEY_BASESKIN = InternalSkinManager.CKEY_PARENTSKIN;\n\n    public static final String DEFAULT_SKIN = InternalSkinConfiguration.DEFAULT_SKIN;\n\n    /**\n     * Query parameters used to control the browser cache version of a resource.\n     */\n    public static final String CACHE_VERSION = \"cache-version\";\n\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);\n\n    /** Frequently used Document reference, the class which holds virtual wiki definitions. */\n    private static final DocumentReference VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE =\n        new DocumentReference(DEFAULT_MAIN_WIKI, SYSTEM_SPACE, \"XWikiServerClass\");\n\n    /** The default encoding, and the internally used encoding when dealing with byte representation of strings. */\n    public static final String DEFAULT_ENCODING = \"UTF-8\";\n\n    /** Represents no value (ie the default value will be used) in xproperties */\n    private static final String NO_VALUE = \"---\";\n\n    /**\n     * List of top level space names that can be used in the fake context document created when accessing a resource\n     * with the 'skin' action.\n     */\n    private static final List<String> SKIN_RESOURCE_SPACE_NAMES = Arrays.asList(\"skins\", \"resources\");\n\n    /** The main document storage. */\n    private XWikiStoreInterface store;\n\n    /** The attachment content storage. */\n    private XWikiAttachmentStoreInterface defaultAttachmentContentStore;\n\n    /** The attachment archive storage. */\n    private AttachmentVersioningStore defaultAttachmentArchiveStore;\n\n    /** Document versioning storage. */\n    private XWikiVersioningStoreInterface versioningStore;\n\n    /** Deleted documents storage. */\n    private XWikiRecycleBinStoreInterface recycleBinStore;\n\n    private AttachmentRecycleBinStore attachmentRecycleBinStore;\n\n    private XWikiPluginManager pluginManager;\n\n    private XWikiAuthService authService;\n\n    private XWikiRightService rightService;\n\n    private XWikiGroupService groupService;\n\n    private XWikiStatsService statsService;\n\n    private XWikiURLFactoryService urlFactoryService;\n\n    private XWikiCriteriaService criteriaService;\n\n    /** Lock object used for the lazy initialization of the authentication service. */\n    private final Object AUTH_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the authorization service. */\n    private final Object RIGHT_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the group management service. */\n    private final Object GROUP_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the statistics service. */\n    private final Object STATS_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the URL Factory service. */\n    private final Object URLFACTORY_SERVICE_LOCK = new Object();\n\n    private MetaClass metaclass;\n\n    private String version;\n\n    private XWikiEngineContext engine_context;\n\n    private String database;\n\n    private String fullNameSQL;\n\n    /**\n     * The list of initialized wikis.\n     */\n    private Map<String, WikiInitializerJob> initializedWikis = new ConcurrentHashMap<>();\n\n    private boolean isReadOnly = false;\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#CFG_ENV_NAME} instead\n     */\n    @Deprecated\n    public static final String CFG_ENV_NAME = XWikiCfgConfigurationSource.CFG_ENV_NAME;\n\n    public static final String MACROS_FILE = \"/templates/macros.txt\";\n\n    /**\n     * File containing XWiki's version, in the format: <version name>.<SVN revision number>.\n     */\n    private static final String VERSION_FILE = \"/WEB-INF/version.properties\";\n\n    /**\n     * Property containing the version value in the {@link #VERSION_FILE} file.\n     */\n    private static final String VERSION_FILE_PROPERTY = \"version\";\n\n    private static XWikiInitializerJob job;\n\n    /** List of configured syntax ids. */\n    private List<String> configuredSyntaxes;\n\n    /** Used to convert a proper Document Reference to string (standard form). */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead.\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    private DocumentReferenceResolver<EntityReference> currentReferenceDocumentReferenceResolver;\n\n    private EntityReferenceResolver<String> currentMixedEntityReferenceResolver;\n\n    private EntityReferenceResolver<String> relativeEntityReferenceResolver;\n\n    private EntityReferenceSerializer<String> localStringEntityReferenceSerializer;\n\n    private ResourceReferenceManager resourceReferenceManager;\n\n    private JobExecutor jobExecutor;\n\n    private InternalSkinManager internalSkinManager;\n\n    private TemplateManager templateManager;\n\n    private RenderingContext renderingContext;\n\n    private VelocityEvaluator velocityEvaluator;\n\n    /**\n     * Whether backlinks are enabled or not (cached for performance).\n     *\n     * @since 3.2M2\n     */\n    private Boolean hasBacklinks;\n\n    private ConfigurationSource xwikicfg;\n\n    private ConfigurationSource wikiConfiguration;\n\n    private UserPropertiesResolver userPropertiesResolver;\n\n    private ConfigurationSource spaceConfiguration;\n\n    private EditConfiguration editConfiguration;\n\n    private URLConfiguration urlConfiguration;\n\n    private StoreConfiguration storeConfiguration;\n\n    private HibernateConfiguration hibernateConfiguration;\n\n    private ObservationManager observationManager;\n\n    private Provider<XWikiContext> xcontextProvider;\n\n    private ContextualLocalizationManager localization;\n\n    private Provider<OldRendering> oldRenderingProvider;\n\n    private ParseGroovyFromString parseGroovyFromString;\n\n    private JobProgressManager progress;\n\n    private Provider<DocumentReference> defaultDocumentReferenceProvider;\n\n    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;\n\n    private PageReferenceResolver<EntityReference> currentgetpageResolver;\n\n    private AttachmentReferenceResolver<EntityReference> currentAttachmentReferenceResolver;\n\n    private WikiSkinUtils wikiSkinUtils;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private VelocityContextFactory velocityContextFactory;\n\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    private AsyncContext asyncContext;\n\n    private ConfigurationSource getConfiguration()\n    {\n        if (this.xwikicfg == null) {\n            this.xwikicfg = Utils.getComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);\n        }\n\n        return this.xwikicfg;\n    }\n\n    private ConfigurationSource getWikiConfiguration()\n    {\n        if (this.wikiConfiguration == null) {\n            this.wikiConfiguration = Utils.getComponent(ConfigurationSource.class, \"wiki\");\n        }\n\n        return this.wikiConfiguration;\n    }\n\n    private ConfigurationSource getSpaceConfiguration()\n    {\n        if (this.spaceConfiguration == null) {\n            this.spaceConfiguration = Utils.getComponent(ConfigurationSource.class, \"space\");\n        }\n\n        return this.spaceConfiguration;\n    }\n\n    private UserPropertiesResolver getAllUserPropertiesResolver()\n    {\n        if (this.userPropertiesResolver == null) {\n            this.userPropertiesResolver = Utils.getComponent(UserPropertiesResolver.class, \"all\");\n        }\n\n        return this.userPropertiesResolver;\n    }\n\n    private EditConfiguration getEditConfiguration()\n    {\n        if (this.editConfiguration == null) {\n            this.editConfiguration = Utils.getComponent(EditConfiguration.class);\n        }\n\n        return this.editConfiguration;\n    }\n\n    private URLConfiguration getURLConfiguration()\n    {\n        if (this.urlConfiguration == null) {\n            this.urlConfiguration = Utils.getComponent(URLConfiguration.class);\n        }\n\n        return this.urlConfiguration;\n    }\n\n    private StoreConfiguration getStoreConfiguration()\n    {\n        if (this.storeConfiguration == null) {\n            this.storeConfiguration = Utils.getComponent(StoreConfiguration.class);\n        }\n\n        return this.storeConfiguration;\n    }\n\n    private HibernateConfiguration getHibernateConfiguration()\n    {\n        if (this.hibernateConfiguration == null) {\n            this.hibernateConfiguration = Utils.getComponent(HibernateConfiguration.class);\n        }\n\n        return this.hibernateConfiguration;\n    }\n\n    private InternalSkinManager getInternalSkinManager()\n    {\n        if (this.internalSkinManager == null) {\n            this.internalSkinManager = Utils.getComponent(InternalSkinManager.class);\n        }\n\n        return this.internalSkinManager;\n    }\n\n    private TemplateManager getTemplateManager()\n    {\n        if (this.templateManager == null) {\n            this.templateManager = Utils.getComponent(TemplateManager.class);\n        }\n\n        return this.templateManager;\n    }\n\n    private RenderingContext getRenderingContext()\n    {\n        if (this.renderingContext == null) {\n            this.renderingContext = Utils.getComponent(RenderingContext.class);\n        }\n\n        return this.renderingContext;\n    }\n\n    private MutableRenderingContext getMutableRenderingContext()\n    {\n        return getRenderingContext() instanceof MutableRenderingContext\n            ? (MutableRenderingContext) getRenderingContext() : null;\n    }\n\n    private VelocityEvaluator getVelocityEvaluator()\n    {\n        if (this.velocityEvaluator == null) {\n            this.velocityEvaluator = Utils.getComponent(VelocityEvaluator.class);\n        }\n\n        return this.velocityEvaluator;\n    }\n\n    private ObservationManager getObservationManager()\n    {\n        if (this.observationManager == null) {\n            this.observationManager = Utils.getComponent(ObservationManager.class);\n        }\n\n        return this.observationManager;\n    }\n\n    private XWikiContext getXWikiContext()\n    {\n        if (this.xcontextProvider == null) {\n            this.xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);\n        }\n\n        return this.xcontextProvider.get();\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private OldRendering getOldRendering()\n    {\n        if (this.oldRenderingProvider == null) {\n            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);\n        }\n\n        return this.oldRenderingProvider.get();\n    }\n\n    private ParseGroovyFromString getParseGroovyFromString()\n    {\n        if (this.parseGroovyFromString == null) {\n            this.parseGroovyFromString = Utils.getComponent(ParseGroovyFromString.class);\n        }\n\n        return this.parseGroovyFromString;\n    }\n\n    private JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    private Provider<DocumentReference> getDefaultDocumentReferenceProvider()\n    {\n        if (this.defaultDocumentReferenceProvider == null) {\n            this.defaultDocumentReferenceProvider = Utils.getComponent(DocumentReference.TYPE_PROVIDER);\n        }\n\n        return this.defaultDocumentReferenceProvider;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentGetDocumentResolver()\n    {\n        if (this.currentgetdocumentResolver == null) {\n            this.currentgetdocumentResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");\n        }\n\n        return this.currentgetdocumentResolver;\n    }\n\n    private PageReferenceResolver<EntityReference> getCurrentGetPageResolver()\n    {\n        if (this.currentgetpageResolver == null) {\n            this.currentgetpageResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE, \"currentgetpage\");\n        }\n\n        return this.currentgetpageResolver;\n    }\n\n    private AttachmentReferenceResolver<EntityReference> getCurrentAttachmentResolver()\n    {\n        if (this.currentAttachmentReferenceResolver == null) {\n            this.currentAttachmentReferenceResolver =\n                Utils.getComponent(AttachmentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentAttachmentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()\n    {\n        if (this.currentReferenceDocumentReferenceResolver == null) {\n            this.currentReferenceDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentReferenceDocumentReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getCurrentMixedEntityReferenceResolver()\n    {\n        if (this.currentMixedEntityReferenceResolver == null) {\n            this.currentMixedEntityReferenceResolver =\n                Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedEntityReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getRelativeEntityReferenceResolver()\n    {\n        if (this.relativeEntityReferenceResolver == null) {\n            this.relativeEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");\n        }\n\n        return this.relativeEntityReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getLocalStringEntityReferenceSerializer()\n    {\n        if (this.localStringEntityReferenceSerializer == null) {\n            this.localStringEntityReferenceSerializer =\n                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n\n        return this.localStringEntityReferenceSerializer;\n    }\n\n    private ResourceReferenceManager getResourceReferenceManager()\n    {\n        if (this.resourceReferenceManager == null) {\n            this.resourceReferenceManager = Utils.getComponent(ResourceReferenceManager.class);\n        }\n\n        return this.resourceReferenceManager;\n    }\n\n    private JobExecutor getJobExecutor()\n    {\n        if (this.jobExecutor == null) {\n            this.jobExecutor = Utils.getComponent(JobExecutor.class);\n        }\n\n        return this.jobExecutor;\n    }\n\n    private DocumentReference getDefaultDocumentReference()\n    {\n        return getDefaultDocumentReferenceProvider().get();\n    }\n\n    private WikiSkinUtils getWikiSkinUtils()\n    {\n        if (this.wikiSkinUtils == null) {\n            this.wikiSkinUtils = Utils.getComponent(WikiSkinUtils.class);\n        }\n\n        return this.wikiSkinUtils;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    private VelocityContextFactory getVelocityContextFactory()\n    {\n        if (this.velocityContextFactory == null) {\n            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);\n        }\n\n        return this.velocityContextFactory;\n    }\n\n    private WikiDescriptorManager getWikiDescriptorManager()\n    {\n        if (this.wikiDescriptorManager == null) {\n            this.wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        }\n\n        return this.wikiDescriptorManager;\n    }\n\n    private AsyncContext getAsyncContext()\n    {\n        if (this.asyncContext == null) {\n            this.asyncContext = Utils.getComponent(AsyncContext.class);\n        }\n\n        return this.asyncContext;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(XWikiContext context) throws XWikiException\n    {\n        return getMainXWiki(true, context);\n    }\n\n    /**\n     * @param wait true if the method should way for {@link XWiki} instance to be initialized\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(boolean wait, XWikiContext context) throws XWikiException\n    {\n        String xwikiname = DEFAULT_MAIN_WIKI;\n\n        context.setMainXWiki(xwikiname);\n\n        XWiki xwiki;\n\n        try {\n            XWikiEngineContext econtext = context.getEngineContext();\n\n            xwiki = (XWiki) econtext.getAttribute(xwikiname);\n            if (xwiki == null) {\n                // Start XWiki initialization\n                synchronized (XWiki.class) {\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                    if (xwiki == null && job == null) {\n                        job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);\n\n                        if (job.getStatus() == null) {\n                            // \"Pre-initialize\" XWikiStubContextProvider so that XWiki initializer can find one\n                            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class)\n                                .initialize(context);\n\n                            job.startAsync();\n                        }\n                    }\n                }\n\n                // Wait until XWiki is initialized\n                if (wait) {\n                    job.join();\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                }\n            }\n\n            context.setWiki(xwiki);\n\n            return xwiki;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                \"Could not initialize main XWiki instance\", e);\n        }\n    }\n\n    public static boolean isInitializing(XWikiContext xcontext)\n    {\n        return Boolean.TRUE.equals(xcontext.getEngineContext().getAttribute(\"xwiki.init\"));\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     *\n     * @param context see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(XWikiContext context) throws XWikiException\n    {\n        return getXWiki(true, context);\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     * <p>\n     * Unless <code>wait</code> is false the method return right away null if XWiki is not yet initialized.\n     *\n     * @param wait wait until XWiki is initialized\n     * @param xcontext see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        XWiki xwiki = getMainXWiki(wait, xcontext);\n\n        if (xwiki == null) {\n            return null;\n        }\n\n        // Extract Entity Resource from URL and put it in the Execution Context\n        EntityResourceReference entityResourceReference = initializeResourceFromURL(xcontext);\n\n        // If not an entity resource reference assume main wiki\n        if (entityResourceReference == null) {\n            return xwiki;\n        }\n\n        // Get the wiki id\n        String wikiId = entityResourceReference.getEntityReference().extractReference(EntityType.WIKI).getName();\n        if (wikiId.equals(xcontext.getMainXWiki())) {\n            // The main wiki was requested.\n            return xwiki;\n        }\n\n        // Check if the wiki exists by checking if a descriptor exists for the wiki id.\n        WikiDescriptorManager wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        WikiDescriptor descriptor;\n        try {\n            descriptor = wikiDescriptorManager.getById(wikiId);\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_STORE_MISC,\n                String.format(\"Failed find wiki descriptor for wiki id [%s]\", wikiId), e);\n        }\n        if (descriptor == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                String.format(\"The wiki [%s] does not exist\", wikiId));\n        }\n\n        // Initialize wiki\n\n        xcontext.setWikiId(wikiId);\n        xcontext.setOriginalWikiId(wikiId);\n\n        if (!xwiki.initializeWiki(wikiId, wait, xcontext)) {\n            // The wiki is still initializing\n            return null;\n        }\n\n        return xwiki;\n    }\n\n    /**\n     * @param wikiId the identifier of the wiki\n     * @return the current {@link WikiInitializerJob} associated to the passed wiki or null if there is none\n     */\n    public Job getWikiInitializerJob(String wikiId)\n    {\n        return this.initializedWikis.get(wikiId);\n    }\n\n    /**\n     * Make sure the wiki is initializing or wait for it.\n     * \n     * @param wikiId the identifier of the wiki to initialize\n     * @param wait true if the method should return only when the wiki is fully initialized\n     * @return true if the wiki is fully initialized\n     * @param xcontext the XWiki context\n     * @throws XWikiException when the initialization failed\n     * @since 8.4RC1\n     */\n    public boolean initializeWiki(String wikiId, boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        Job wikiJob = this.initializedWikis.get(wikiId);\n\n        // Create and start the job if it does not exist\n        if (wikiJob == null) {\n            try {\n                wikiJob = initializeWiki(wikiId, xcontext);\n            } catch (JobException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Could not start [\" + wikiId + \"] wiki initialization\", e);\n            }\n        }\n\n        // Check if the job is done\n        if (wikiJob.getStatus().getState() == State.FINISHED) {\n            return true;\n        }\n\n        // Wait until the job is finished if asked to\n        if (wait) {\n            try {\n                wikiJob.join();\n            } catch (InterruptedException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization was interrupted unexpectedly\", e);\n            }\n\n            if (wikiJob.getStatus().getError() != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization failed\", wikiJob.getStatus().getError());\n            }\n\n            return true;\n        }\n\n        // Still initializing\n        return false;\n    }\n\n    private Job initializeWiki(String wikiId, XWikiContext xcontext) throws JobException\n    {\n        synchronized (this.initializedWikis) {\n            WikiInitializerJob wikiJob = this.initializedWikis.get(wikiId);\n\n            if (wikiJob == null) {\n                WikiInitializerRequest request = new WikiInitializerRequest(wikiId);\n\n                JobRequestContext.set(request, xcontext);\n\n                wikiJob = (WikiInitializerJob) getJobExecutor().execute(WikiInitializerJob.JOBTYPE, request);\n                this.initializedWikis.put(wikiId, wikiJob);\n            }\n\n            return wikiJob;\n        }\n    }\n\n    private static EntityResourceReference initializeResourceFromURL(XWikiContext context) throws XWikiException\n    {\n        // Extract the Entity Resource from the URL\n        // TODO: This code should be put in an ExecutionContextInitializer but we couldn't do yet since this code\n        // requires that the XWiki object be initialized first (the line above). Thus we'll be able to to move it only\n        // after the XWiki init is done also in an ExecutionContextInitializer (and with priorities).\n        @SuppressWarnings(\"deprecation\")\n        EntityResourceReference entityResourceReference;\n        URL url = context.getURL();\n        try {\n            ExtendedURL extendedURL = new ExtendedURL(url, context.getRequest().getContextPath());\n            ResourceTypeResolver<ExtendedURL> typeResolver =\n                Utils.getComponent(new DefaultParameterizedType(null, ResourceTypeResolver.class, ExtendedURL.class));\n            ResourceType type = typeResolver.resolve(extendedURL, Collections.<String, Object>emptyMap());\n            ResourceReferenceResolver<ExtendedURL> resourceResolver = Utils\n                .getComponent(new DefaultParameterizedType(null, ResourceReferenceResolver.class, ExtendedURL.class));\n            ResourceReference reference =\n                resourceResolver.resolve(extendedURL, type, Collections.<String, Object>emptyMap());\n            entityResourceReference =\n                reference instanceof EntityResourceReference ? (EntityResourceReference) reference : null;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION,\n                String.format(\"Failed to extract Entity Resource Reference from URL [%s]\", url), e);\n        }\n        Utils.getComponent(Execution.class).getContext().setProperty(ResourceReferenceManager.RESOURCE_CONTEXT_PROPERTY,\n            entityResourceReference);\n\n        return entityResourceReference;\n    }\n\n    public static URL getRequestURL(XWikiRequest request) throws XWikiException\n    {\n        try {\n            StringBuffer requestURL = request.getRequestURL();\n            String qs = request.getQueryString();\n            if ((qs != null) && (!qs.equals(\"\"))) {\n                return new URL(requestURL.toString() + \"?\" + qs);\n            } else {\n                return new URL(requestURL.toString());\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION,\n                \"Exception while getting URL from request\", e);\n        }\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName)\n    {\n        return callPrivateMethod(obj, methodName, null, null);\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName, Class<?>[] classes, Object[] args)\n    {\n        try {\n            Method method = obj.getClass().getDeclaredMethod(methodName, classes);\n            method.setAccessible(true);\n            return method.invoke(obj, args);\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to call private method [{}]: [{}]\", methodName, e);\n\n            return null;\n        } catch (NoSuchMethodException e) {\n            return null;\n        } catch (InvocationTargetException e) {\n            LOGGER.error(\"Private method [{}] failed: [{}]\", methodName, e);\n\n            return null;\n        }\n    }\n\n    public static HttpClient getHttpClient(int timeout, String userAgent)\n    {\n        HttpClient client = new HttpClient();\n\n        if (timeout != 0) {\n            client.getParams().setSoTimeout(timeout);\n            client.getParams().setParameter(\"http.connection.timeout\", Integer.valueOf(timeout));\n        }\n\n        client.getParams().setParameter(\"http.useragent\", userAgent);\n\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if ((proxyHost != null) && (!proxyHost.equals(\"\"))) {\n            int port = 3128;\n            if ((proxyPort != null) && (!proxyPort.equals(\"\"))) {\n                port = Integer.parseInt(proxyPort);\n            }\n            client.getHostConfiguration().setProxy(proxyHost, port);\n        }\n\n        String proxyUser = System.getProperty(\"http.proxyUser\");\n        if ((proxyUser != null) && (!proxyUser.equals(\"\"))) {\n            String proxyPassword = System.getProperty(\"http.proxyPassword\");\n            Credentials defaultcreds = new UsernamePasswordCredentials(proxyUser, proxyPassword);\n            client.getState().setProxyCredentials(AuthScope.ANY, defaultcreds);\n        }\n\n        return client;\n    }\n\n    /**\n     * Using reflection, read the private value of the passed field name for the passed object.\n     *\n     * @param obj the java object on which to read the private field value\n     * @param fieldName the object member field for which to read the value\n     * @return the private value for the field\n     * @deprecated use {@link FieldUtils#readDeclaredField(Object, String, boolean)} instead\n     */\n    @Deprecated\n    public static Object getPrivateField(Object obj, String fieldName)\n    {\n        try {\n            Field field = obj.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return field.get(obj);\n        } catch (NoSuchFieldException e) {\n            return null;\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to get private field with name [{}]: [{}]\", fieldName, e);\n\n            return null;\n        } finally {\n        }\n    }\n\n    public static String getServerWikiPage(String servername)\n    {\n        return \"XWiki.XWikiServer\" + StringUtils.capitalize(servername);\n    }\n\n    /**\n     * @param content the content of the text area\n     * @param context see {@link XWikiContext}\n     */\n    public static String getTextArea(String content, XWikiContext context)\n    {\n        StringBuilder result = new StringBuilder();\n\n        // Forcing a new line after the <textarea> tag, as\n        // http://www.w3.org/TR/html4/appendix/notes.html#h-B.3.1 causes an empty line at the start\n        // of the document content to be trimmed.\n        result.append(\"<textarea name=\\\"content\\\" id=\\\"content\\\" rows=\\\"25\\\" cols=\\\"80\\\">\\n\");\n        result.append(XMLUtils.escape(content));\n        result.append(\"</textarea>\");\n\n        return result.toString();\n    }\n\n    /**\n     * This provide a way to create an XWiki object without initializing the whole XWiki (including plugins, storage,\n     * etc.).\n     * <p>\n     * Needed for tools or tests which need XWiki because it is used everywhere in the API.\n     */\n    public XWiki()\n    {\n        // Empty voluntarily\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate) throws XWikiException\n    {\n        initXWiki(context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context) throws XWikiException\n    {\n        this(context, null, false);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public void initXWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(null, context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param config the object holding the XWiki configuration read from {@code xwiki.cfg}\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     * @deprecated since 6.1M2, use {@link #initXWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public void initXWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        getProgress().pushLevelProgress(4, this);\n\n        try {\n            getProgress().startStep(this);\n\n            setDatabase(context.getMainXWiki());\n\n            setEngineContext(engineContext);\n            context.setWiki(this);\n\n            // \"Pre-initialize\" XWikiStubContextProvider with a XWikiContext containing a XWiki instance as soon as\n            // possible\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            // Prepare the store\n            if (config != null) {\n                setConfig(config);\n            }\n\n            try {\n                initializeStores();\n            } catch (ComponentLookupException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Failed to initialize stores\", e);\n            }\n\n            setCriteriaService((XWikiCriteriaService) createClassFromConfig(\"xwiki.criteria.class\",\n                \"com.xpn.xwiki.criteria.impl.XWikiCriteriaServiceImpl\", context));\n\n            // \"Pre-initialize\" XWikiStubContextProvider so that rendering engine, plugins or listeners reacting to\n            // potential document changes can use it\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Make sure these classes exists\n            if (noupdate) {\n                getProgress().pushLevelProgress(2, this);\n\n                try {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocuments(context);\n\n                    getProgress().startStep(this);\n\n                    getStatsService(context);\n                } finally {\n                    getProgress().popLevelProgress(this);\n                }\n            }\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Prepare the Plugin Engine\n            preparePlugins(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            String ro = getConfiguration().getProperty(\"xwiki.readonly\", \"no\");\n            this.isReadOnly = (\"yes\".equalsIgnoreCase(ro) || \"true\".equalsIgnoreCase(ro) || \"1\".equalsIgnoreCase(ro));\n\n            // Save the configured syntaxes\n            String syntaxes = getConfiguration().getProperty(\"xwiki.rendering.syntaxes\", \"xwiki/1.0\");\n            this.configuredSyntaxes = Arrays.asList(StringUtils.split(syntaxes, \" ,\"));\n\n            getObservationManager().addListener(this);\n        } finally {\n            getProgress().popLevelProgress(this);\n        }\n    }\n\n    private void initializeStores() throws ComponentLookupException\n    {\n        XWikiStoreInterface mainStore = getStoreConfiguration().getXWikiStore();\n\n        // Check if we need to use the cache store..\n        if (getStoreConfiguration().isStoreCacheEnabled()) {\n            XWikiCacheStoreInterface cachestore =\n                (XWikiCacheStoreInterface) Utils.getComponent(XWikiStoreInterface.class, \"cache\");\n            cachestore.setStore(mainStore);\n            setStore(cachestore);\n        } else {\n            setStore(mainStore);\n        }\n\n        setDefaultAttachmentContentStore(getStoreConfiguration().getXWikiAttachmentStore());\n        setVersioningStore(getStoreConfiguration().getXWikiVersioningStore());\n        setDefaultAttachmentArchiveStore(getStoreConfiguration().getAttachmentVersioningStore());\n        setRecycleBinStore(getStoreConfiguration().getXWikiRecycleBinStore());\n        setAttachmentRecycleBinStore(getStoreConfiguration().getAttachmentRecycleBinStore());\n    }\n\n    /**\n     * Ensure that mandatory classes (ie classes XWiki needs to work properly) exist and create them if they don't\n     * exist.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void initializeMandatoryDocuments(XWikiContext context)\n    {\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            List<MandatoryDocumentInitializer> initializers =\n                Utils.getComponentList(MandatoryDocumentInitializer.class);\n\n            // Sort the initializers based on priority. Lower priority values are first.\n            Collections.sort(initializers, new Comparator<MandatoryDocumentInitializer>()\n            {\n                @Override\n                public int compare(MandatoryDocumentInitializer left, MandatoryDocumentInitializer right)\n                {\n                    Priority leftPriority = left.getClass().getAnnotation(Priority.class);\n                    int leftPriorityValue =\n                        leftPriority != null ? leftPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    Priority rightPriority = right.getClass().getAnnotation(Priority.class);\n                    int rightPriorityValue =\n                        rightPriority != null ? rightPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    // Compare the two.\n                    return leftPriorityValue - rightPriorityValue;\n                }\n            });\n\n            getObservationManager().notify(MandatoryDocumentsInitializingEvent.EVENT, null);\n\n            getProgress().pushLevelProgress(initializers.size(), this);\n\n            try {\n                for (MandatoryDocumentInitializer initializer : initializers) {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocument(initializer, context);\n\n                    getProgress().endStep(this);\n                }\n            } finally {\n                getProgress().popLevelProgress(this);\n            }\n\n            getObservationManager().notify(MandatoryDocumentsInitializedEvent.EVENT, null);\n        }\n    }\n\n    private void initializeMandatoryDocument(String wiki, MandatoryDocumentInitializer initializer,\n        XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            context.setWikiId(wiki);\n\n            initializeMandatoryDocument(initializer, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private void initializeMandatoryDocument(MandatoryDocumentInitializer initializer, XWikiContext context)\n    {\n        try {\n            DocumentReference documentReference =\n                getCurrentReferenceDocumentReferenceResolver().resolve(initializer.getDocumentReference());\n\n            if (documentReference.getWikiReference().getName().equals(context.getWikiId())) {\n                XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n\n                if (initializer.updateDocument(document)) {\n                    saveDocument(document,\n                        localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"), context);\n                }\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to initialize mandatory document [{}]\", initializer.getDocumentReference(), e);\n        }\n    }\n\n    public XWikiStoreInterface getNotCacheStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n        }\n        return store;\n    }\n\n    public XWikiHibernateStore getHibernateStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiHibernateStore) {\n            return (XWikiHibernateStore) store;\n        } else if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n            if (store instanceof XWikiHibernateStore) {\n                return (XWikiHibernateStore) store;\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, XWikiContext context) throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, false, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, force, true, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param force if the update of the databse should be forced\n     * @param initDocuments if mandatory document and plugin should be initialized for passed wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, boolean initDocuments, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        initializeWiki(wikiId, true, context);\n    }\n\n    /**\n     * @return a cached list of all active virtual wikis (i.e. wikis who have been hit by a user request). To get a full\n     *         list of all virtual wikis database names use {@link WikiDescriptorManager#getAllIds()}.\n     * @deprecated\n     */\n    @Deprecated\n    public List<String> getVirtualWikiList()\n    {\n        return new ArrayList<>(this.initializedWikis.keySet());\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     * @return the full list of all wiki names of all defined wikis. The wiki names are computed from the names of\n     *         documents having a {@code XWiki.XWikiServerClass} object attached to them by removing the\n     *         {@code XWiki.XWikiServer} prefix and making it lower case. For example a page named\n     *         {@code XWiki.XWikiServerMyDatabase} would return {@code mydatabase} as the wiki name. This list will also\n     *         contain the main wiki.\n     *         <p>\n     *         Note: the wiki name is commonly also the name of the database where the wiki's data is stored. However,\n     *         if configured accordingly, the database can be diferent from the wiki name, like for example when setting\n     *         a wiki database prefix.\n     * @deprecated since 5.3, use {@link WikiDescriptorManager#getAllIds()} instead\n     */\n    @Deprecated\n    public List<String> getVirtualWikisDatabaseNames(XWikiContext context) throws XWikiException\n    {\n        WikiDescriptorManager descriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n\n        try {\n            return new ArrayList<String>(descriptorManager.getAllIds());\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to get the list of wikis\", e);\n        }\n    }\n\n    /**\n     * @return the cache containing the names of the wikis already initialized.\n     * @since 1.5M2.\n     * @deprecated\n     */\n    @Deprecated\n    public Cache<DocumentReference> getVirtualWikiCache()\n    {\n        return null;\n    }\n\n    /**\n     * Get the reference of the owner for the provider wiki.\n     *\n     * @param wikiName the technical name of the wiki\n     * @param context see {@link XWikiContext}\n     * @return the wiki owner or null if none is set\n     * @throws XWikiException failed to get wiki descriptor document\n     */\n    public String getWikiOwner(String wikiName, XWikiContext context) throws XWikiException\n    {\n        String wikiOwner;\n\n        String currentdatabase = context.getWikiId();\n        try {\n            context.setWikiId(context.getMainXWiki());\n\n            String serverwikipage = getServerWikiPage(wikiName);\n            XWikiDocument doc = getDocument(serverwikipage, context);\n\n            if (doc.isNew()) {\n                if (!context.isMainWiki(wikiName)) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                        \"The wiki \" + wikiName + \" does not exist\");\n                } else {\n                    wikiOwner = null;\n                }\n            } else {\n                wikiOwner = doc.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"owner\");\n                if (wikiOwner.indexOf(':') == -1) {\n                    wikiOwner = context.getMainXWiki() + \":\" + wikiOwner;\n                }\n            }\n        } finally {\n            context.setWikiId(currentdatabase);\n        }\n\n        return wikiOwner;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    protected Object createClassFromConfig(String param, String defClass, XWikiContext context) throws XWikiException\n    {\n        String storeclass = getConfiguration().getProperty(param, defClass);\n        try {\n            Class<?>[] classes = new Class<?>[] { XWikiContext.class };\n            Object[] args = new Object[] { context };\n            Object result = Class.forName(storeclass).getConstructor(classes).newInstance(args);\n            return result;\n        } catch (Exception e) {\n            Throwable ecause = e;\n            if (e instanceof InvocationTargetException) {\n                ecause = ((InvocationTargetException) e).getTargetException();\n            }\n            Object[] args = { param, storeclass };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_CLASSINVOCATIONERROR, \"Cannot load class {1} from param {0}\", ecause,\n                args);\n        }\n    }\n\n    private void preparePlugins(XWikiContext context)\n    {\n        setPluginManager(new XWikiPluginManager(getXWikiPreference(\"plugins\", context), context));\n        String plugins = getConfiguration().getProperty(\"xwiki.plugins\", \"\");\n        if (!plugins.equals(\"\")) {\n            getPluginManager().addPlugins(StringUtils.split(plugins, \" ,\"), context);\n        }\n    }\n\n    /**\n     * @return the XWiki core version as specified in the {@link #VERSION_FILE} file\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getVersion()\n    {\n        if (this.version == null) {\n            try {\n                InputStream is = getResourceAsStream(VERSION_FILE);\n                try {\n                    XWikiConfig properties = new XWikiConfig(is);\n                    this.version = properties.getProperty(VERSION_FILE_PROPERTY);\n                } finally {\n                    IOUtils.closeQuietly(is);\n                }\n            } catch (Exception e) {\n                // Failed to retrieve the version, log a warning and default to \"Unknown\"\n                LOGGER.warn(\"Failed to retrieve XWiki's version from [\" + VERSION_FILE + \"], using the [\"\n                    + VERSION_FILE_PROPERTY + \"] property.\", e);\n                this.version = \"Unknown version\";\n            }\n        }\n        return this.version;\n    }\n\n    public URL getResource(String s) throws MalformedURLException\n    {\n        return getEngineContext().getResource(s);\n    }\n\n    public InputStream getResourceAsStream(String s) throws MalformedURLException\n    {\n        InputStream is = getEngineContext().getResourceAsStream(s);\n        if (is == null) {\n            is = getEngineContext().getResourceAsStream(\"/\" + s);\n        }\n        return is;\n    }\n\n    public String getResourceContent(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toString(is, DEFAULT_ENCODING);\n                }\n            }\n        }\n        // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding\n        return FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);\n    }\n\n    public Date getResourceLastModificationDate(String name)\n    {\n        try {\n            if (getEngineContext() != null) {\n                return Util.getFileLastModificationDate(getEngineContext().getRealPath(name));\n            }\n        } catch (Exception ex) {\n            // Probably a SecurityException or the file is not accessible (inside a war)\n            LOGGER.info(\"Failed to get file modification date: \" + ex.getMessage());\n        }\n        return new Date();\n    }\n\n    public byte[] getResourceContentAsBytes(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toByteArray(is);\n                }\n            } catch (Exception e) {\n            }\n        }\n        return FileUtils.readFileToByteArray(new File(name));\n    }\n\n    public boolean resourceExists(String name)\n    {\n        if (getEngineContext() != null) {\n            try {\n                if (getResource(name) != null) {\n                    return true;\n                }\n            } catch (IOException e) {\n            }\n        }\n        try {\n            File file = new File(name);\n            return file.exists();\n        } catch (Exception e) {\n            // Could be running under -security, which prevents calling file.exists().\n        }\n        return false;\n    }\n\n    public String getRealPath(String path)\n    {\n        return getEngineContext().getRealPath(path);\n    }\n\n    public String ParamAsRealPath(String key)\n    {\n        String param = getConfiguration().getProperty(key);\n        try {\n            return getRealPath(param);\n        } catch (Exception e) {\n            return param;\n        }\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public String ParamAsRealPath(String key, XWikiContext context)\n    {\n        return ParamAsRealPath(key);\n    }\n\n    public String ParamAsRealPathVerified(String param)\n    {\n        String path;\n        File fpath;\n\n        path = getConfiguration().getProperty(param);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        }\n\n        path = getRealPath(path);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        } else {\n        }\n        return null;\n    }\n\n    public XWikiStoreInterface getStore()\n    {\n        return this.store;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentContentStore()} instead\n     */\n    @Deprecated\n    public XWikiAttachmentStoreInterface getAttachmentStore()\n    {\n        return getDefaultAttachmentContentStore();\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public XWikiAttachmentStoreInterface getDefaultAttachmentContentStore()\n    {\n        return this.defaultAttachmentContentStore;\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public AttachmentVersioningStore getDefaultAttachmentArchiveStore()\n    {\n        return this.defaultAttachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentArchiveStore()} instead\n     */\n    @Deprecated\n    public AttachmentVersioningStore getAttachmentVersioningStore()\n    {\n        return getDefaultAttachmentArchiveStore();\n    }\n\n    public XWikiVersioningStoreInterface getVersioningStore()\n    {\n        return this.versioningStore;\n    }\n\n    public XWikiRecycleBinStoreInterface getRecycleBinStore()\n    {\n        return this.recycleBinStore;\n    }\n\n    public AttachmentRecycleBinStore getAttachmentRecycleBinStore()\n    {\n        return this.attachmentRecycleBinStore;\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        XWikiContext context) throws XWikiException\n    {\n        checkSavingDocument(userReference, document, comment, false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        checkSavingDocument(userReference, document, \"\", false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        boolean isMinorEdit, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n\n            if (om != null) {\n                CancelableEvent documentEvent;\n                if (originalDocument.isNew()) {\n                    documentEvent = new UserCreatingDocumentEvent(userReference, document.getDocumentReference());\n                } else {\n                    documentEvent = new UserUpdatingDocumentEvent(userReference, document.getDocumentReference());\n                }\n                om.notify(documentEvent, document, context);\n\n                // If the action has been canceled by the user then don't perform any save and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to save the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private XWikiDocument prepareDocumentForSave(XWikiDocument document, String comment, boolean isMinorEdit,\n        XWikiContext context) throws XWikiException\n    {\n        // Set the store so we can use it for checking the max length.\n        if (document.getStore() == null) {\n            document.setStore(this.getStore());\n        }\n        String fullName = getLocalStringEntityReferenceSerializer().serialize(document.getDocumentReference());\n        // If it's a new doc we check its name length to avoid a nasty SQL error.\n        if (document.isNew() && fullName.length() > document.getLocalReferenceMaxLength()) {\n            java.lang.Object[] args = { fullName, document.getLocalReferenceMaxLength(), fullName.length() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG,\n                \"Cannot create document {0} because its full path is too long: only {1} characters are allowed and \"\n                    + \"current length is {2}.\",\n                null, args);\n        }\n\n        // Setting comment & minor edit before saving\n        document.setComment(StringUtils.defaultString(comment));\n        document.setMinorEdit(isMinorEdit);\n\n        // We need to save the original document since saveXWikiDoc() will reset it and we\n        // need that original document for the notification below.\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        // Make sure to always have an original document for listeners that need to compare with it.\n        // The only case where we have a null original document is supposedly when the document\n        // instance has been crafted and passed #saveDocument without using #getDocument\n        // (which is not a good practice)\n        // Also for document indicated as new make sure the previous document is accurate.\n        if (originalDocument == null || document.isNew()) {\n            XWikiDocument existing = getDocument(document.getDocumentReferenceWithLocale(), context);\n            // Switch the original document only if we actually find an existing document or if there is no original\n            // document in the first place\n            if (originalDocument == null || !existing.isNew()) {\n                originalDocument = existing;\n                document.setOriginalDocument(originalDocument);\n            }\n        }\n\n        return originalDocument;\n    }\n\n    /**\n     * @param doc the document to save\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // If no comment is provided we should use an empty comment\n        saveDocument(doc, \"\", context);\n    }\n\n    /**\n     * @param doc the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, String comment, XWikiContext context) throws XWikiException\n    {\n        saveDocument(doc, comment, false, context);\n    }\n\n    private void beforeSave(XWikiDocument document, XWikiContext context) throws XWikiException\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            CancelableEvent documentEvent;\n            if (document.getOriginalDocument().isNew()) {\n                documentEvent = new DocumentCreatingEvent(document.getDocumentReference());\n            } else {\n                documentEvent = new DocumentUpdatingEvent(document.getDocumentReference());\n            }\n            om.notify(documentEvent, document, context);\n\n            // If the action has been canceled by the user then don't perform any save and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC,\n                    String.format(\"An Event Listener has cancelled the document save for [%s]. Reason: [%s]\",\n                        document.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n    }\n\n    private void afterSave(XWikiDocument document, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            if (document.getOriginalDocument().isNew()) {\n                om.notify(new DocumentCreatedEvent(document.getDocumentReference()), document, context);\n            } else {\n                om.notify(new DocumentUpdatedEvent(document.getDocumentReference()), document, context);\n            }\n        }\n    }\n\n    /**\n     * Save the passed document in the store.\n     * <p>\n     * If document is not new and metadata and content dirty flags are false, the version/history won't be incremented\n     * (only the current state will be updated).\n     * <p>\n     * Since 11.1, if document#isNew() return true, any pre existing document will be backuped in the deleted documents\n     * store automatically and completely replaced.\n     * \n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument document, String comment, boolean isMinorEdit, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            beforeSave(document, context);\n\n            // Delete existing document if we replace with a new one\n            if (document.isNew()) {\n                if (!originalDocument.isNew()) {\n                    // We don't want to notify about this delete since from outside world point of view it's an update\n                    // and not a delete+create\n                    deleteDocument(originalDocument, true, false, context);\n                }\n            } else {\n                // Put attachments to remove in recycle bin\n                if (hasAttachmentRecycleBin(context)) {\n                    for (XWikiAttachmentToRemove attachment : document.getAttachmentsToRemove()) {\n                        if (attachment.isToRecycleBin()) {\n                            // Make sure the attachment will be deleted with its history\n                            attachment.getAttachment().loadArchive(context);\n                            getAttachmentRecycleBinStore().saveToRecycleBin(attachment.getAttachment(),\n                                context.getUser(), new Date(), context, true);\n                        }\n                    }\n                }\n            }\n\n            // Actually save the document.\n            getStore().saveXWikiDoc(document, context);\n\n            // Since the store#saveXWikiDoc resets originalDocument, we need to temporarily put it\n            // back to send notifications.\n            XWikiDocument newOriginal = document.getOriginalDocument();\n\n            try {\n                document.setOriginalDocument(originalDocument);\n\n                // Notify listeners about the document having been created or updated\n\n                // First the legacy notification mechanism\n\n                // Then the new observation module\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                // The old version is made available using doc.getOriginalDocument()\n                afterSave(document, context);\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document save notification for document [\"\n                    + getDefaultEntityReferenceSerializer().serialize(document.getDocumentReference()) + \"]\", ex);\n            } finally {\n                document.setOriginalDocument(newOriginal);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     * <p>\n     * Before 7.2M1 the reference is assumed to be a complete or incomplete document reference.\n     * <p>\n     * Since 7.2M1, the passed reference can be anything. If if a document child, the document reference will be\n     * extracted from it. If it's a document parent it will be completed with the necessary default references (for\n     * example if it's a space reference it will load the space home page).\n     *\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 5.0M1\n     */\n    public XWikiDocument getDocument(EntityReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument document;\n\n        if (reference.getType() == EntityType.PAGE || reference.getType().isAllowedAncestor(EntityType.PAGE)) {\n            document = getDocument(getCurrentGetPageResolver().resolve(reference), context);\n        } else {\n            document = getDocument(getCurrentGetDocumentResolver().resolve(reference), context);\n        }\n\n        return document;\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     *\n     * @param reference the reference of the document to be loaded\n     * @param type the type of the reference\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(String reference, EntityType type, XWikiContext xcontext) throws XWikiException\n    {\n        return getDocument(getRelativeEntityReferenceResolver().resolve(reference, type), xcontext);\n    }\n\n    /**\n     * @param doc the document\n     * @param context see {@link XWikiContext}\n     */\n    public XWikiDocument getDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            try {\n                // Indicate the the async context manipulated documents\n                getAsyncContext().useEntity(doc.getDocumentReferenceWithLocale());\n            } catch (Exception e) {\n                // If the AsyncContext component does not work then we are not in an asynchronous context anyway\n                LOGGER.debug(\"Failed to register the document in the asynchronous context\", e);\n            }\n\n            return getStore().loadXWikiDoc(doc, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * @param reference the reference of the document to load\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @since 9.4RC1\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(DocumentReference, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(DocumentReference reference, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(reference, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(reference);\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param document the reference document\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(XWikiDocument, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(XWikiDocument document, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(document, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(document.getDocumentReference());\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 2.2M1\n     */\n    public XWikiDocument getDocument(DocumentReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(\n            reference.getLocale() != null ? new DocumentReference(reference, (Locale) null) : reference,\n            reference.getLocale());\n\n        doc.setContentDirty(true);\n\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param reference the reference of the page\n     * @param context see {@link XWikiContext}\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(PageReference reference, XWikiContext context) throws XWikiException\n    {\n        DocumentReference documentReference = getCurrentReferenceDocumentReferenceResolver().resolve(reference);\n\n        XWikiDocument document = getDocument(documentReference, context);\n\n        if (document.isNew() && documentReference.getParent().getParent().getType() == EntityType.SPACE) {\n            // Try final page\n            XWikiDocument finalDocument = getDocument(new DocumentReference(documentReference.getParent().getName(),\n                documentReference.getParent().getParent(), documentReference.getParameters()), context);\n\n            if (!finalDocument.isNew()) {\n                document = finalDocument;\n            }\n        }\n\n        return document;\n    }\n\n    /**\n     * Find the document reference corresponding to the entity reference based on what exist in the database (page\n     * reference can means two different documents for example).\n     * \n     * @param reference the reference to resolve\n     * @param context the XWiki context\n     * @return the document reference\n     * @since 10.6RC1\n     */\n    public DocumentReference getDocumentReference(EntityReference reference, XWikiContext context)\n    {\n        DocumentReference documentReference = getCurrentGetDocumentResolver().resolve(reference);\n\n        // If the document has been found or it's top level space, return the reference\n        if (documentReference.getParent().getParent().getType() != EntityType.SPACE\n            || exists(documentReference, context)) {\n            return documentReference;\n        }\n\n        // Try final page\n        DocumentReference finalPageReference = new DocumentReference(documentReference.getParent().getName(),\n            documentReference.getParent().getParent(), documentReference.getParameters());\n\n        return exists(finalPageReference, context) ? finalPageReference : documentReference;\n    }\n\n    /**\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String fullname, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullname, context);\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param spaces the reference of the space as String\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String spaces, String fullname, XWikiContext context) throws XWikiException\n    {\n        int dotPosition = fullname.lastIndexOf('.');\n        if (dotPosition != -1) {\n            String spaceFromFullname = fullname.substring(0, dotPosition);\n            String name = fullname.substring(dotPosition + 1);\n            if (name.equals(\"\")) {\n                name = getDefaultPage(context);\n            }\n            return getDocument(spaceFromFullname + \".\" + name, context);\n        } else {\n            return getDocument(spaces + \".\" + fullname, context);\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String, String)\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String fullname, String locale, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n            doc.setLanguage(locale);\n            return getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String batchId, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getAllDeletedDocuments(batchId, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String, String, String)\n     * @deprecated since 9.4RC1. Use {@link #getDeletedDocument(long, XWikiContext)} instead.\n     */\n    @Deprecated\n    public XWikiDeletedDocument getDeletedDocument(String fullname, String locale, int index, XWikiContext context)\n        throws XWikiException\n    {\n        return getDeletedDocument(index, context);\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument getDeletedDocument(long index, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getDeletedDocument(index, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document. Note that this does not distinguish\n     * between different incarnations of a document name, and it does not require that the document still exists, it\n     * returns all the attachments that at the time of their deletion had a document with the specified name as their\n     * owner.\n     *\n     * @param docName the {@link XWikiDocument#getFullName() name} of the owner document\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document. If no such attachments\n     *         are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(doc, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document and had the specified name. Multiple\n     * versions can be returned since the same file can be uploaded and deleted several times, creating different\n     * instances in the trash. Note that this does not distinguish between different incarnations of a document name,\n     * and it does not require that the document still exists, it returns all the attachments that at the time of their\n     * deletion had a document with the specified name as their owner.\n     *\n     * @param docName the {@link DeletedAttachment#getDocName() name of the document} the attachment belonged to\n     * @param filename the {@link DeletedAttachment#getFilename() name} of the attachment to search for\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document and had the specified\n     *         filename. If no such attachments are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            XWikiAttachment attachment = new XWikiAttachment(doc, filename);\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(attachment, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve a specific attachment from the trash.\n     *\n     * @param id the unique identifier of the entry in the trash\n     * @param context the XWiki context\n     * @return specified attachment from the trash, {@code null} if not found\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public DeletedAttachment getDeletedAttachment(String id, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            return getAttachmentRecycleBinStore().getDeletedAttachment(NumberUtils.toLong(id), context, true);\n        }\n        return null;\n    }\n\n    public MetaClass getMetaclass()\n    {\n        if (this.metaclass == null) {\n            this.metaclass = MetaClass.getMetaClass();\n        }\n        return this.metaclass;\n    }\n\n    public void setMetaclass(MetaClass metaclass)\n    {\n        this.metaclass = metaclass;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public List<String> getClassList(XWikiContext context) throws XWikiException\n    {\n        List<String> result = getStore().getClassList(context);\n        Collections.sort(result);\n        return result;\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, nb, start, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, Object[][] whereParams, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, whereParams, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, Object[][] whereParams, XWikiContext context)\n        throws XWikiException\n    {\n        return getStore().search(sql, nb, start, whereParams, context);\n    }\n\n    /**\n     * @param content the content to parse\n     * @param context see {@link XWikiContext}\n     * @deprecated Since 7.2M1. Use specific rendering/parsing options for the content type you want to parse/render.\n     */\n    @Deprecated\n    public String parseContent(String content, XWikiContext context)\n    {\n        return getOldRendering().parseContent(content, context);\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     * @deprecated use {@link #evaluateTemplate(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            result = evaluateTemplate(template, context);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while parsing template [{}] from /templates/\", template, e);\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate provided template content using velocity engine.\n     *\n     * @param template the template to evaluate\n     * @param context see {@link XWikiContext}\n     * @return the return of the velocity script\n     * @throws IOException failed to get the template content\n     * @since 2.2.2\n     * @deprecated since 7.0M1, use {@link TemplateManager#render(String)} instead\n     */\n    @Deprecated\n    public String evaluateTemplate(String template, XWikiContext context) throws IOException\n    {\n        try {\n            return getTemplateManager().render(template);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}]\", template, e);\n\n            Object[] args = { template };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while evaluating velocity template {0}\",\n                e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skinId the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     * @deprecated since 7.0M1, use {@link TemplateManager#renderFromSkin} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, String skinId, XWikiContext context)\n    {\n        MutableRenderingContext mutableRenderingContext = getMutableRenderingContext();\n\n        Syntax currentTargetSyntax = mutableRenderingContext.getTargetSyntax();\n        try {\n            // Force rendering with XHTML 1.0 syntax for retro-compatibility\n            mutableRenderingContext.setTargetSyntax(Syntax.XHTML_1_0);\n\n            Skin skin = getInternalSkinManager().getSkin(skinId);\n            return getTemplateManager().renderFromSkin(template, skin);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}] skin [{}]\", template, skinId, e);\n\n            Object[] args = { template, skinId };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION,\n                \"Error while evaluating velocity template [{0}] from skin [{1}]\", e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        } finally {\n            mutableRenderingContext.setTargetSyntax(currentTargetSyntax);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skin the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, String skin, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, skin, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"] for skin [\" + skin + \"]\", ex);\n            return parseTemplate(template, skin, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"]\", ex);\n            return parseTemplate(template, context);\n        }\n    }\n\n    /**\n     * Designed to include dynamic content, such as Servlets or JSPs, inside Velocity templates; works by creating a\n     * RequestDispatcher, buffering the output, then returning it as a string.\n     */\n    public String invokeServletAndReturnAsString(String url, XWikiContext xwikiContext)\n    {\n\n        HttpServletRequest servletRequest = xwikiContext.getRequest();\n        HttpServletResponse servletResponse = xwikiContext.getResponse();\n\n        try {\n            return IncludeServletAsString.invokeServletAndReturnAsString(url, servletRequest, servletResponse);\n        } catch (Exception e) {\n            LOGGER.warn(\"Exception including url: \" + url, e);\n            return \"Exception including \\\"\" + url + \"\\\", see logs for details.\";\n        }\n\n    }\n\n    /**\n     * @param iconName the standard name of an icon (it's not the name of the file on the filesystem, it's a generic\n     *            name, for example \"success\" for a success icon\n     * @param context see {@link XWikiContext}\n     * @return the URL to the icon resource\n     * @since 2.6M1\n     */\n    public String getIconURL(String iconName, XWikiContext context)\n    {\n        // TODO: Do a better mapping between generic icon name and physical resource name, especially to be independent\n        // of the underlying icon library. Right now we assume it's the Silk icon library.\n        return getSkinFile(\"icons/silk/\" + iconName + \".png\", context);\n    }\n\n    public String getSkinFile(String filename, XWikiContext context)\n    {\n        return getSkinFile(filename, false, context);\n    }\n\n    /**\n     * Build and return a skin file url based on the given parameters.\n     * \n     * @param filename the file name of the skin file wanted\n     * @param forceSkinAction if true force the usage of directory /skins/ in the URL\n     * @param context current context for the request\n     * @return a resource URL for the asked filename\n     */\n    public String getSkinFile(String filename, boolean forceSkinAction, XWikiContext context)\n    {\n        String skinFile = getSkinFile(filename, null, forceSkinAction, context);\n\n        if (skinFile == null) {\n            // Use the default base skin even if the URL could be invalid.\n            XWikiURLFactory urlf = context.getURLFactory();\n            URL url;\n            if (forceSkinAction) {\n                url = urlf.createSkinURL(filename, \"skins\", getDefaultBaseSkin(context), context);\n            } else {\n                url = urlf.createSkinURL(filename, getDefaultBaseSkin(context), context);\n            }\n            skinFile = urlf.getURL(url, context);\n        }\n\n        return skinFile;\n    }\n\n    private String getSkinFileInternal(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        try {\n            if (skinId != null) {\n                // Try only in the specified skin.\n                Skin skin = getInternalSkinManager().getSkin(skinId);\n                if (skin != null) {\n                    Resource<?> resource = skin.getLocalResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                }\n            } else {\n                // Try in the current skin.\n                Skin skin = getInternalSkinManager().getCurrentSkin(true);\n                if (skin != null) {\n                    Resource<?> resource = skin.getResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                } else {\n                    // Try in the current parent skin.\n                    Skin parentSkin = getInternalSkinManager().getCurrentParentSkin(true);\n                    if (parentSkin != null) {\n                        Resource<?> resource = parentSkin.getResource(fileName);\n                        if (resource != null) {\n                            return resource.getURL(forceSkinAction);\n                        }\n                    }\n                }\n            }\n\n            // Look for a resource file.\n            String resourceFilePath = \"/resources/\" + fileName;\n            XWikiURLFactory urlFactory = context.getURLFactory();\n            if (resourceExists(resourceFilePath)) {\n                URL url = urlFactory.createResourceURL(fileName, forceSkinAction, context,\n                    getResourceURLCacheParameters(resourceFilePath));\n                return urlFactory.getURL(url, context);\n            }\n        } catch (Exception e) {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Exception while getting skin file [{}] from skin [{}]\", fileName, skinId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(String resourceFilePath)\n    {\n        try {\n            URL resourceUrl = getResource(resourceFilePath);\n            return getResourceURLCacheParameters(resourceUrl);\n        } catch (MalformedURLException e) {\n            LOGGER.debug(\"Error while getting URL for resource path [{}]\", resourceFilePath, e);\n            return Collections.singletonMap(CACHE_VERSION, getVersion());\n        }\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(URL resourceUrl)\n    {\n        Map<String, Object> parameters = new LinkedHashMap<>();\n\n        if (getURLConfiguration().useResourceLastModificationDate()) {\n            try {\n                Path resourcePath = Paths.get(resourceUrl.toURI());\n                FileTime lastModifiedTime = Files.getLastModifiedTime(resourcePath);\n                parameters.put(CACHE_VERSION, String.valueOf(lastModifiedTime.toMillis()));\n            } catch (Exception e) {\n                LOGGER.debug(\"Error when trying to access properties of resource URL [{}]\", resourceUrl, e);\n                parameters.put(CACHE_VERSION, getVersion());\n            }\n        } else {\n            parameters.put(CACHE_VERSION, getVersion());\n        }\n\n        return parameters;\n    }\n\n    public String getSkinFile(String filename, String skin, XWikiContext context)\n    {\n        return getSkinFile(filename, skin, false, context);\n    }\n\n    public String getSkinFile(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        if (StringUtils.endsWithAny(fileName, \".js\", \".css\")) {\n            String extension = StringUtils.substringAfterLast(fileName, '.');\n            String shortFileName = StringUtils.substringBeforeLast(fileName, \".\");\n            if (StringUtils.endsWith(shortFileName, \".min\")) {\n                shortFileName = StringUtils.substringBeforeLast(shortFileName, \".\");\n            }\n            String fileNameSource = String.format(\"%s.%s\", shortFileName, extension);\n            String fileNameMinified = String.format(\"%s.min.%s\", shortFileName, extension);\n            DebugConfiguration debugConfig = Utils.getComponent(DebugConfiguration.class);\n            String[] fileNames = debugConfig.isMinify() ? new String[] {fileNameMinified, fileNameSource}\n                : new String[] {fileNameSource, fileNameMinified};\n            String skinFile = null;\n            for (String name : fileNames) {\n                skinFile = getSkinFileInternal(name, skinId, forceSkinAction, context);\n                if (skinFile != null) {\n                    break;\n                }\n            }\n            return skinFile;\n        } else {\n            return getSkinFileInternal(fileName, skinId, forceSkinAction, context);\n        }\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} instead\n     */\n    @Deprecated\n    public String getSkin(XWikiContext context)\n    {\n        String skin;\n\n        try {\n            skin = getInternalSkinManager().getCurrentSkinId(true);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while determining current skin\", e);\n            skin = getDefaultBaseSkin(context);\n        }\n\n        return skin;\n    }\n\n    public String getSkinPreference(String prefname, XWikiContext context)\n    {\n        return getSkinPreference(prefname, \"\", context);\n    }\n\n    public String getSkinPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        for (Skin skin = getInternalSkinManager().getCurrentSkin(true); skin != null; skin = skin.getParent()) {\n            if (skin instanceof WikiSkin) {\n                String value = getWikiSkinUtils().getSkinProperty(skin.getId(), prefname);\n\n                // TODO: remove the NO_VALUE test when XWIKI-10853 is fixed\n                if (!StringUtils.isEmpty(value) && !NO_VALUE.equals(value)) {\n                    return value;\n                }\n            }\n        }\n\n        return defaultValue;\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getDefaultParentSkin()} instead\n     */\n    @Deprecated\n    public String getDefaultBaseSkin(XWikiContext context)\n    {\n        return getInternalSkinManager().getDefaultParentSkinId();\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context)\n    {\n        return getBaseSkin(context, false);\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context, boolean fromRenderSkin)\n    {\n        String baseskin = \"\";\n        try {\n            return getInternalSkinManager().getCurrentParentSkinId(false);\n        } catch (Exception e) {\n            baseskin = getDefaultBaseSkin(context);\n\n            LOGGER.debug(\"Exception while determining base skin\", e);\n        }\n\n        return baseskin;\n    }\n\n    /**\n     * @param skin the name of the skin for which to return the base skin. For example : <tt>XWiki.DefaultSkin</tt>\n     * @param context see {@link XWikiContext}\n     * @return if found, the name of the base skin the asked skin inherits from. If not found, returns an empty string.\n     * @since 2.0.2\n     * @since 2.1M1\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} and {@link Skin#getParent()} instead\n     */\n    @Deprecated\n    public String getBaseSkin(String skin, XWikiContext context)\n    {\n        String baseSkin = getInternalSkinManager().getParentSkin(skin);\n\n        return baseSkin != null ? baseSkin : \"\";\n    }\n\n    public String getSpaceCopyright(XWikiContext context)\n    {\n        return getSpacePreference(\"webcopyright\", \"\", context);\n    }\n\n    public String getXWikiPreference(String prefname, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", context);\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     */\n    public String getXWikiPreference(String prefname, String fallbackParam, String defaultValue, XWikiContext context)\n    {\n        String result = getWikiConfiguration().getProperty(prefname, String.class);\n\n        if (StringUtils.isEmpty(result)) {\n            result = getConfiguration().getProperty(fallbackParam, defaultValue);\n        }\n\n        return result != null ? result : \"\";\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param wiki the wiki to get preference from\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     * @since 7.4M1\n     */\n    public String getXWikiPreference(String prefname, String wiki, String fallbackParam, String defaultValue,\n        XWikiContext xcontext)\n    {\n        String currentWiki = xcontext.getWikiId();\n\n        try {\n            xcontext.setWikiId(wiki);\n\n            return getXWikiPreference(prefname, fallbackParam, defaultValue, xcontext);\n        } finally {\n            xcontext.setWikiId(currentWiki);\n        }\n    }\n\n    public String getXWikiPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", defaultValue, context);\n    }\n\n    public String getSpacePreference(String preference, XWikiContext context)\n    {\n        return getSpacePreference(preference, \"\", context);\n    }\n\n    public String getSpacePreference(String preference, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, (SpaceReference) null, defaultValue, context);\n    }\n\n    /**\n     * @deprecated since 7.4M1, use {@link #getSpacePreference(String, SpaceReference, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String getSpacePreference(String preference, String space, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, new SpaceReference(space, context.getWikiReference()), defaultValue,\n            context);\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or empty String if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, XWikiContext context)\n    {\n        return getSpacePreference(preferenceKey, spaceReference, \"\", context);\n    }\n\n    /**\n     * Get the preference key for the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space. If null and there's a current document then the current space\n     *                       is used. If null and there's no current document then fall back to the wiki preferences.\n     * @param defaultValue the value to return if the preference can't be found\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or <code>defaultValue</code> if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, String defaultValue,\n        XWikiContext context)\n    {\n        XWikiDocument currentDocument = context.getDoc();\n\n        try {\n            if (spaceReference != null) {\n                context.setDoc(new XWikiDocument(new DocumentReference(\"WebPreferences\", spaceReference)));\n            } else if (currentDocument != null) {\n                spaceReference = currentDocument.getDocumentReference().getLastSpaceReference();\n            }\n\n            String result = getSpaceConfiguration().getProperty(preferenceKey, String.class);\n\n            if (StringUtils.isEmpty(result)) {\n                if (spaceReference == null) {\n                    result = getXWikiPreference(preferenceKey, defaultValue, context);\n                } else if (spaceReference.getParent() instanceof SpaceReference) {\n                    result = getSpacePreference(preferenceKey, (SpaceReference) spaceReference.getParent(),\n                        defaultValue, context);\n                } else if (spaceReference.getParent() instanceof WikiReference) {\n                    result =\n                        getXWikiPreference(preferenceKey, spaceReference.getParent().getName(), defaultValue, context);\n                }\n            }\n\n            return result != null ? result : defaultValue;\n        } finally {\n            context.setDoc(currentDocument);\n        }\n    }\n\n    public String getUserPreference(String prefname, XWikiContext context)\n    {\n        String result =\n            getAllUserPropertiesResolver().resolve(CurrentUserReference.INSTANCE).getProperty(prefname, String.class);\n\n        return result != null ? result : \"\";\n    }\n\n    public String getUserPreferenceFromCookie(String prefname, XWikiContext context)\n    {\n        Cookie[] cookies = context.getRequest().getCookies();\n        if (cookies == null) {\n            return null;\n        }\n        for (Cookie cookie : cookies) {\n            String name = cookie.getName();\n            if (name.equals(prefname)) {\n                String value = cookie.getValue();\n                if (!value.trim().equals(\"\")) {\n                    return value;\n                } else {\n                    break;\n                }\n            }\n        }\n        return null;\n    }\n\n    public String getUserPreference(String prefname, boolean useCookie, XWikiContext context)\n    {\n        // First we look in the cookies\n        if (useCookie) {\n            String result = Util.normalizeLanguage(getUserPreferenceFromCookie(prefname, context));\n            if (result != null) {\n                return result;\n            }\n        }\n        return getUserPreference(prefname, context);\n    }\n\n    /**\n     * Set the locale in the given context.\n     * <p>\n     * If {@code forceSupported} is true, then the locale will be set only if it is in the {@see availableLocales}. Note\n     * that all the parent locales are checked.\n     *\n     * @param locale the locale to use\n     * @param context the context\n     * @param availableLocales the accepted locales. Used only if {@see forceSupported} is true\n     * @param forceSupported determine if the {@see locale} should be checked against the {@see availableLocales}\n     * @return the locale that has been set or null\n     */\n    private Locale setLocale(Locale locale, XWikiContext context, Set<Locale> availableLocales, boolean forceSupported)\n    {\n        while (locale != null) {\n            if (!forceSupported || availableLocales.contains(locale)) {\n                context.setLocale(locale);\n                break;\n            }\n            locale = LocaleUtils.getParentLocale(locale);\n        }\n\n        return locale;\n    }\n\n    /**\n     * The algorithm to find the locale to use is the following, in this order:\n     *\n     * <ul>\n     *   <li>Try to find the current locale in use from the XWiki contex</li>\n     *   <li>If the wiki is not multilingual use the wiki default locale ({@code default_language} xproperty in\n     *   {@code XWikiPreferences} xobject or English if not found)</li>\n     *   <li>If the wiki is multilingual<ul>\n     *     <li>Try to get the locale passed in the request (looking for a {@code language} query string parameter).\n     *     If the language value is {@code default} use the wiki default locale. If a parameter is found sets a\n     *     {@code language} cookie to remember the language in use.</li>\n     *     <li>Try to get the locale from the {@code language} cookie</li>\n     *     <li>If the default language is preferred ({@code xwiki.language.preferDefault} from {@code xwiki.cfg}\n     *     or {@code preferDefaultLanguage} property from the space preferences ({@code WebPreferences} xobject) or\n     *     wiki preferences ({@code XWikiPreferences} xobject})), and since the user didn't explicitly ask for a\n     *     language already, then use the wiki default locale.</li>\n     *     <li>Try to use the browser's {@code Accept-Language} header sent in HTTP request.<li>\n     *     <li>Fallback to the wiki default locale</li>\n     *   </ul></li>\n     * </ul>\n     *\n     * In addition the {code xwiki.language.forceSupported} configuration property is enabled by default and means that\n     * if at any step above the locale found is not in the list of supported locales, then the locale is not set and\n     * the algorithm moves to the next step.\n     *\n     * @return the locale to use\n     * @since 8.0M1\n     */\n    public Locale getLocalePreference(XWikiContext context)\n    {\n        Locale defaultLocale = this.getDefaultLocale(context);\n        Set<Locale> availableLocales = new HashSet<>(this.getAvailableLocales(context));\n        boolean forceSupported = getConfiguration().getProperty(\"xwiki.language.forceSupported\", \"1\").equals(\"1\");\n\n        // First we try to get the language from the XWiki Context. This is the current language\n        // being used.\n        Locale locale = context.getLocale();\n        if (locale != null) {\n            return locale;\n        }\n\n        // If the wiki is non multilingual then the language is the default language.\n        if (!isMultiLingual(context)) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // As the wiki is multilingual try to find the language to use from the request by looking\n        // for a language parameter. If the language value is \"default\" use the default language\n        // from the XWiki preferences settings. Otherwise set a cookie to remember the language\n        // in use.\n        try {\n            String language = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n            if (language != null) {\n                if (\"default\".equals(language)) {\n                    // forgetting language cookie\n                    Cookie cookie = new Cookie(\"language\", \"\");\n                    cookie.setMaxAge(0);\n                    cookie.setPath(\"/\");\n                    context.getResponse().addCookie(cookie);\n                    context.setLocale(defaultLocale);\n                    return defaultLocale;\n                } else {\n                    locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                    if (LocaleUtils.isAvailableLocale(locale)) {\n                        // setting language cookie\n                        Cookie cookie = new Cookie(\"language\", context.getLocale().toString());\n                        cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                        cookie.setPath(\"/\");\n                        context.getResponse().addCookie(cookie);\n                        return locale;\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // As no language parameter was passed in the request, try to get the language to use from a cookie.\n        try {\n            // First we get the language from the cookie\n            String language = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n            if (StringUtils.isNotEmpty(language)) {\n                locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // If the default language is preferred, and since the user didn't explicitly ask for a\n        // language already, then use the default wiki language.\n        if (getConfiguration().getProperty(\"xwiki.language.preferDefault\", \"0\").equals(\"1\")\n            || getSpacePreference(\"preferDefaultLanguage\", \"0\", context).equals(\"1\")) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // Then from the navigator language setting\n        if (context.getRequest() != null && context.getRequest().getLocales() != null) {\n            for (Locale acceptedLocale : Collections.list(context.getRequest().getLocales())) {\n                locale = setLocale(acceptedLocale, context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n            // If none of the languages requested by the client is acceptable, skip to next\n            // phase (use default language).\n        }\n\n        // Finally, use the default language from the global preferences.\n        context.setLocale(defaultLocale);\n        return defaultLocale;\n    }\n\n    /**\n     * First try to find the current locale in use from the XWiki context. If none is used and if the wiki is not\n     * multilingual use the default locale defined in the XWiki preferences. If the wiki is multilingual try to get the\n     * locale passed in the request. If none was passed try to get it from a cookie. If no locale cookie exists then use\n     * the user default locale and barring that use the browser's \"Accept-Language\" header sent in HTTP request. If none\n     * is defined use the default locale.\n     *\n     * @return the locale to use\n     * @deprecated since 8.0M1, use {@link #getLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getLanguagePreference(XWikiContext context)\n    {\n        return getLocalePreference(context).toString();\n    }\n\n    /**\n     * Construct a list of language codes (ISO 639-1) from the Accept-Languages header. This method filters out some\n     * bugs in different browsers or containers, like returning '*' as a language (Jetty) or using '_' as a\n     * language--country delimiter (some versions of Opera).\n     *\n     * @param request The client request.\n     * @return A list of language codes, in the client preference order; might be empty if the header is not well\n     *         formed.\n     */\n    private List<String> getAcceptedLanguages(XWikiRequest request)\n    {\n        List<String> result = new ArrayList<String>();\n        Enumeration<Locale> e = request.getLocales();\n        while (e.hasMoreElements()) {\n            String language = e.nextElement().getLanguage().toLowerCase();\n            // All language codes should have 2 letters.\n            if (StringUtils.isAlpha(language)) {\n                result.add(language);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @deprecated since 5.1M2 use {@link #getDefaultLocale(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getDefaultLanguage(XWikiContext xcontext)\n    {\n        return getDefaultLocale(xcontext).toString();\n    }\n\n    /**\n     * The default locale in the preferences.\n     *\n     * @param xcontext the XWiki context.\n     * @return the default locale\n     * @since 5.1M2\n     */\n    public Locale getDefaultLocale(XWikiContext xcontext)\n    {\n        // Find out what is the default language from the XWiki preferences settings.\n        String defaultLanguage = xcontext.getWiki().getXWikiPreference(\"default_language\", \"\", xcontext);\n\n        Locale defaultLocale;\n\n        if (StringUtils.isBlank(defaultLanguage)) {\n            defaultLocale = Locale.ENGLISH;\n        } else {\n            try {\n                defaultLocale = LocaleUtils.toLocale(Util.normalizeLanguage(defaultLanguage));\n            } catch (Exception e) {\n                LOGGER.warn(\"Invalid locale [{}] set as default locale in the preferences\", defaultLanguage);\n                defaultLocale = Locale.ENGLISH;\n            }\n        }\n\n        return defaultLocale;\n    }\n\n    /**\n     * Get the available locales according to the preferences.\n     *\n     * @param xcontext the XWiki context\n     * @return all the available locales\n     * @since 5.1M2\n     */\n    public List<Locale> getAvailableLocales(XWikiContext xcontext)\n    {\n        String[] languages = StringUtils.split(xcontext.getWiki().getXWikiPreference(\"languages\", xcontext), \", |\");\n\n        List<Locale> locales = new ArrayList<Locale>(languages.length);\n\n        for (String language : languages) {\n            if (StringUtils.isNotBlank(language)) {\n                try {\n                    locales.add(LocaleUtils.toLocale(language));\n                } catch (Exception e) {\n                    LOGGER.warn(\"Invalid locale [{}] listed as available in the preferences\", language);\n                }\n            }\n        }\n\n        // Add default language in case it's not listed as available (which is wrong but it happen)\n        Locale defaultocale = getDefaultLocale(xcontext);\n        if (!locales.contains(defaultocale)) {\n            locales.add(defaultocale);\n        }\n\n        return locales;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getDocLocalePreferenceNew(XWikiContext context)\n    {\n        String language = getDocLanguagePreferenceNew(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getDocLocalePreferenceNew(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getDocLocalePreferenceNew\n    public String getDocLanguagePreferenceNew(XWikiContext context)\n    {\n        // Get context language\n        String contextLanguage = context.getLanguage();\n        // If the language exists in the context, it was previously set by another call\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            return contextLanguage;\n        }\n\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = context.getWiki().getXWikiPreference(\"default_language\", \"\", context);\n            context.setLanguage(language);\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n        } catch (Exception ex) {\n        }\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if (StringUtils.isNotEmpty(requestLanguage)) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"language\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the cookie\n        if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"language\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getInterfaceLocalePreference(XWikiContext context)\n    {\n        String language = getInterfaceLanguagePreference(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getInterfaceLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getInterfaceLocalePreference\n    public String getInterfaceLanguagePreference(XWikiContext context)\n    {\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\", contextLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = Util.normalizeLanguage(context.getWiki().getXWikiPreference(\"default_language\", \"\", context));\n            context.setInterfaceLocale(LocaleUtils.toLocale(language));\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"interfacelanguage\"));\n        } catch (Exception ex) {\n        }\n\n        // Get context language\n        contextLanguage = context.getInterfaceLanguage();\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = null;\n            userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_interface_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"interfacelanguage\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if ((requestLanguage != null) && (!requestLanguage.equals(\"\"))) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"interfacelanguage\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the context\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            language = contextLanguage;\n        }\n        // Next we get the language from the cookie\n        else if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"interfacelanguage\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getXWikiPreference(preference, context));\n    }\n\n    public long getSpacePreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getSpacePreference(preference, context));\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong((getXWikiPreference(preference, context)), defaultValue);\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, String fallbackParameter, long defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toLong(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public long getSpacePreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public long getUserPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getUserPreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getXWikiPreference(preference, context));\n    }\n\n    public int getSpacePreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getSpacePreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, context), defaultValue);\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, String fallbackParameter, int defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public int getSpacePreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public int getUserPreferenceAsInt(String prefname, XWikiContext context)\n    {\n        return Integer.parseInt(getUserPreference(prefname, context));\n    }\n\n    public void flushCache(XWikiContext context)\n    {\n        // We need to flush the virtual wiki list\n        this.initializedWikis = new ConcurrentHashMap<>();\n\n        // We need to flush the group service cache\n        if (this.groupService != null) {\n            this.groupService.flushCache();\n        }\n\n        // If we use the Cache Store layer.. we need to flush it\n        XWikiStoreInterface store = getStore();\n        if ((store != null) && (store instanceof XWikiCacheStoreInterface)) {\n            ((XWikiCacheStoreInterface) getStore()).flushCache();\n        }\n        // Flush renderers.. Groovy renderer has a cache\n        getOldRendering().flushCache();\n        getParseGroovyFromString().flushCache();\n\n        XWikiPluginManager pmanager = getPluginManager();\n        if (pmanager != null) {\n            pmanager.flushCache(context);\n        }\n\n        // Make sure we call all classes flushCache function\n        try {\n            List<String> classes = getClassList(context);\n            for (int i = 0; i < classes.size(); i++) {\n                String className = classes.get(i);\n                try {\n                    getClass(className, context).flushCache();\n                } catch (Exception e) {\n                }\n            }\n        } catch (Exception e) {\n        }\n\n    }\n\n    public XWikiPluginManager getPluginManager()\n    {\n        return this.pluginManager;\n    }\n\n    public void setPluginManager(XWikiPluginManager pluginManager)\n    {\n        this.pluginManager = pluginManager;\n    }\n\n    public void setStore(XWikiStoreInterface store)\n    {\n        this.store = store;\n    }\n\n    /**\n     * @param attachmentContentStore the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface attachmentContentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentContentStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface)} instead\n     */\n    @Deprecated\n    public void setAttachmentStore(XWikiAttachmentStoreInterface attachmentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentStore;\n    }\n\n    /**\n     * @param attachmentArchiveStore the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentArchiveStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        this.defaultAttachmentArchiveStore = attachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.10RC1, use {@link #setDefaultAttachmentArchiveStore(AttachmentVersioningStore)} instead\n     */\n    @Deprecated\n    public void setAttachmentVersioningStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        setDefaultAttachmentArchiveStore(attachmentArchiveStore);\n    }\n\n    public void setVersioningStore(XWikiVersioningStoreInterface versioningStore)\n    {\n        this.versioningStore = versioningStore;\n    }\n\n    public void setRecycleBinStore(XWikiRecycleBinStoreInterface recycleBinStore)\n    {\n        this.recycleBinStore = recycleBinStore;\n    }\n\n    public void setAttachmentRecycleBinStore(AttachmentRecycleBinStore attachmentRecycleBinStore)\n    {\n        this.attachmentRecycleBinStore = attachmentRecycleBinStore;\n    }\n\n    public void setCriteriaService(XWikiCriteriaService criteriaService)\n    {\n        this.criteriaService = criteriaService;\n    }\n\n    public void setVersion(String version)\n    {\n        this.version = version;\n    }\n\n    /**\n     * Verify if the provided xclass page exists and that it contains all the required configuration properties to make\n     * the tag feature work properly. If some properties are missing they are created and saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @param classReference the reference of the document containing the class\n     * @return the Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     */\n    private BaseClass getMandatoryClass(XWikiContext context, DocumentReference classReference) throws XWikiException\n    {\n        XWikiDocument document = getDocument(classReference, context);\n\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            MandatoryDocumentInitializer initializer =\n                Utils.getComponent(MandatoryDocumentInitializer.class, document.getFullName());\n\n            if (initializer.updateDocument(document)) {\n                saveDocument(document, localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"),\n                    context);\n            }\n        }\n\n        return document.getXClass();\n    }\n\n    /**\n     * Verify if the <code>XWiki.TagClass</code> page exists and that it contains all the required configuration\n     * properties to make the tag feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the TagClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getTagClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"TagClass\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.SheetClass</code> page exists and that it contains all the required configuration\n     * properties to make the sheet feature work properly. If some properties are missing they are created and saved in\n     * the database. SheetClass is used to a page as a sheet. When a page is tagged as a sheet and that page is included\n     * in another page using the include macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0\n     * only - for XWiki Syntax 1.0 automatic inline edition is triggered using #includeForm).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the SheetClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @deprecated since 3.1M2 edit mode class should be used for this purpose, not the sheet class\n     * @see #getEditModeClass(XWikiContext)\n     */\n    @Deprecated\n    public BaseClass getSheetClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"SheetClass\"));\n    }\n\n    /**\n     * Verify if the {@code XWiki.EditModeClass} page exists and that it contains all the required configuration\n     * properties to make the edit mode feature work properly. If some properties are missing they are created and saved\n     * in the database. EditModeClass is used to specify the default edit mode of a page. It can also be used to mark a\n     * page as a sheet. When a page is marked as a sheet and that page is included in another page using the include\n     * macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0 only - for XWiki Syntax 1.0\n     * automatic inline edition is triggered using #includeForm). It replaces and enhances the SheetClass mechanism (see\n     * {@link #getSheetClass(XWikiContext)}).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the EditModeClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @since 3.1M2\n     */\n    public BaseClass getEditModeClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(\n            new LocalDocumentReference(XWikiConstant.EDIT_MODE_CLASS), new WikiReference(context.getWikiId())));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiUsers</code> page exists and that it contains all the required configuration\n     * properties to make the user feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWikiUsers Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getUserClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiUsers\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.GlobalRedirect</code> page exists and that it contains all the required configuration\n     * properties to make the redirection feature work properly. If some properties are missing they are created and\n     * saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the GlobalRedirect Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getRedirectClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"GlobalRedirect\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiPreferences</code> page exists and that it contains all the required configuration\n     * properties to make XWiki work properly. If some properties are missing they are created and saved in the\n     * database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWiki Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getPrefsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, getPreferencesDocumentReference(context));\n    }\n\n    public BaseClass getGroupClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiGroups\"));\n    }\n\n    public BaseClass getRightsClass(String pagename, XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, pagename));\n    }\n\n    public BaseClass getRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiRights\", context);\n    }\n\n    public BaseClass getGlobalRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiGlobalRights\", context);\n    }\n\n    public BaseClass getCommentsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiComments\"));\n    }\n\n    public BaseClass getSkinClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiSkins\"));\n    }\n\n    public int createUser(XWikiContext context) throws XWikiException\n    {\n        return createUser(false, \"edit\", context);\n    }\n\n    public int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            // Get the user document\n            String username = convertUsername(request.getParameter(\"xwikiname\"), context);\n            if (username.indexOf('.') == -1) {\n                username = \"XWiki.\" + username;\n            }\n            XWikiDocument userDocument = getDocument(username, context);\n\n            // Get the stored validation key\n            BaseObject userObject = userDocument.getObject(\"XWiki.XWikiUsers\", 0);\n            String storedKey = userObject.getStringValue(\"validkey\");\n\n            // Get the validation key from the URL\n            String validationKey = request.getParameter(\"validkey\");\n            PropertyInterface validationKeyClass = getClass(\"XWiki.XWikiUsers\", context).get(\"validkey\");\n            if (validationKeyClass instanceof PasswordClass) {\n                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);\n            }\n\n            // Compare the two keys\n            if ((!storedKey.equals(\"\") && (storedKey.equals(validationKey)))) {\n                // Ensure to remove the validation key value, so it cannot be used afterwards to enable back\n                // a disabled user.\n                userObject.setStringValue(\"validkey\", \"\");\n                saveDocument(userDocument, context);\n\n                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());\n                xWikiUser.setDisabled(false, context);\n                xWikiUser.setEmailChecked(true, context);\n\n                if (withConfirmEmail) {\n                    String email = userObject.getStringValue(\"email\");\n                    String password = userObject.getStringValue(\"password\");\n                    sendValidationEmail(username, password, email, request.getParameter(\"validkey\"),\n                        \"confirmation_email_content\", context);\n                }\n\n                return 0;\n            } else {\n                return -1;\n            }\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,\n                \"Exception while validating user\", e, null);\n        }\n    }\n\n    public int createUser(boolean withValidation, String userRights, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            Map<String, String[]> map = Util.getObject(request, \"register\");\n\n            String content = \"\";\n            Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n            // Read the values from the request.\n            String xwikiname = request.getParameter(\"xwikiname\");\n            String password2 = request.getParameter(\"register2_password\");\n            String password = (map.get(\"password\"))[0];\n            String email = (map.get(\"email\"))[0];\n            String template = request.getParameter(\"template\");\n            String parent = request.getParameter(\"parent\");\n            String validkey = null;\n\n            // Validate the values.\n            if (XWikiRightService.SUPERADMIN_USER.equalsIgnoreCase(xwikiname)) {\n                return -8;\n            }\n            try {\n                if (!context.getUtil().match(getConfiguration().getProperty(\"xwiki.validusername\", \"/^[a-zA-Z0-9_]+$/\"),\n                    xwikiname)) {\n                    return -4;\n                }\n            } catch (RuntimeException ex) {\n                LOGGER.warn(\"Invalid regular expression for xwiki.validusername\", ex);\n                if (!context.getUtil().match(\"/^[a-zA-Z0-9_]+$/\", xwikiname)) {\n                    return -4;\n                }\n            }\n\n            if ((!password.equals(password2))) {\n                // TODO: throw wrong password exception\n                return -2;\n            }\n\n            if ((template != null) && (!template.equals(\"\"))) {\n                XWikiDocument tdoc = getDocument(template, context);\n                if ((!tdoc.isNew())) {\n                    // FIXME: This ignores template objects, attachments, etc.\n                    content = tdoc.getContent();\n                    syntax = tdoc.getSyntax();\n                }\n            }\n\n            if ((parent == null) || (parent.equals(\"\"))) {\n                parent = \"XWiki.XWikiUsers\";\n            }\n\n            // Mark the user as active or waiting email validation.\n            if (withValidation) {\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"0\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"0\" });\n\n                validkey = generateValidationKey(16);\n                map.put(\"validkey\", new String[] { validkey });\n\n            } else {\n                // Mark user active\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"1\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"1\" });\n            }\n\n            // Create the user.\n            int result =\n                createUser(xwikiname, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n                    content, syntax, userRights, context);\n\n            // Send validation mail, if needed.\n            if ((result > 0) && (withValidation)) {\n                // Send the validation email\n                try {\n                    sendValidationEmail(xwikiname, password, email, validkey, \"validation_email_content\", context);\n                } catch (XWikiException e) {\n                    LOGGER.warn(\"User created. Failed to send the mail to the created user.\", e);\n                    return -11;\n                }\n\n            }\n\n            return result;\n        } catch (XWikiException e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw e;\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_CREATE_USER,\n                \"Exception while creating user\", e, null);\n        }\n    }\n\n    /**\n     * Method allows to create an empty user with no password (he won't be able to login) This method is usefull for\n     * authentication like LDAP or App Server trusted\n     *\n     * @param xwikiname\n     * @param userRights\n     * @param context see {@link XWikiContext}\n     * @return true if success\n     * @throws XWikiException\n     */\n    public boolean createEmptyUser(String xwikiname, String userRights, XWikiContext context) throws XWikiException\n    {\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"active\", \"1\");\n        map.put(\"first_name\", xwikiname);\n\n        if (createUser(xwikiname, map, userRights, context) == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void sendConfirmationEmail(String xwikiname, String password, String email, String message,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"message\", message, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String validkey,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"validkey\", validkey, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String addfieldname,\n        String addfieldvalue, String contentfield, XWikiContext context) throws XWikiException\n    {\n        MailSenderConfiguration configuration = Utils.getComponent(MailSenderConfiguration.class);\n\n        String sender;\n        String content;\n        try {\n            sender = configuration.getFromAddress();\n            if (StringUtils.isBlank(sender)) {\n                String server = context.getRequest().getServerName();\n                if (server.matches(\"\\\\[.*\\\\]|(\\\\d{1,3}+\\\\.){3}+\\\\d{1,3}+\")) {\n                    sender = \"noreply@domain.net\";\n                } else {\n                    sender = \"noreply@\" + server;\n                }\n            }\n            content = getXWikiPreference(contentfield, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_GET_VALIDATION_CONFIG,\n                \"Exception while reading the validation email config\", e, null);\n\n        }\n\n        try {\n            VelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n            vcontext.put(addfieldname, addfieldvalue);\n            vcontext.put(\"email\", email);\n            vcontext.put(\"password\", password);\n            vcontext.put(\"sender\", sender);\n            vcontext.put(\"xwikiname\", xwikiname);\n            content = parseContent(content, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_PREPARE_VALIDATION_EMAIL,\n                \"Exception while preparing the validation email\", e, null);\n\n        }\n\n        // Let's now send the message\n        try {\n            Session session =\n                Session.getInstance(configuration.getAllProperties(), new XWikiAuthenticator(configuration));\n            InputStream is = new ByteArrayInputStream(content.getBytes());\n            MimeMessage message = new MimeMessage(session, is);\n            message.setFrom(new InternetAddress(sender));\n            message.setRecipients(Message.RecipientType.TO, email);\n            message.setHeader(\"X-MailType\", \"Account Validation\");\n            MailSender mailSender = Utils.getComponent(MailSender.class);\n            MailListener mailListener = Utils.getComponent(MailListener.class, \"database\");\n            mailSender.sendAsynchronously(Arrays.asList(message), session, mailListener);\n            mailListener.getMailStatusResult().waitTillProcessed(Long.MAX_VALUE);\n            String errorMessage = MailStatusResultSerializer.serializeErrors(mailListener.getMailStatusResult());\n            if (errorMessage != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL,\n                    String.format(\"Error while sending the validation email. %s\", errorMessage));\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL, \"Error while sending the validation email\", e);\n        }\n    }\n\n    public String generateRandomString(int size)\n    {\n        return RandomStringUtils.randomAlphanumeric(size);\n    }\n\n    public String generateValidationKey(int size)\n    {\n        return generateRandomString(size);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, XWikiContext context) throws XWikiException\n    {\n        return createUser(userName, map, \"edit\", context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, String userRights, XWikiContext context)\n        throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        String content = \"\";\n        Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n        return createUser(userName, map,\n            new EntityReference(userClass.getDocumentReference().getName(), EntityType.DOCUMENT), content, syntax,\n            userRights, context);\n    }\n\n    /**\n     * @deprecated since 2.4RC1 use\n     *             {@link #createUser(String, Map, EntityReference, String, Syntax, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String userName, Map<String, ?> map, String parent, String content, String syntaxId,\n        String userRights, XWikiContext context) throws XWikiException\n    {\n        Syntax syntax;\n\n        try {\n            syntax = Syntax.valueOf(syntaxId);\n        } catch (ParseException e) {\n            syntax = getDefaultDocumentSyntaxInternal();\n        }\n\n        return createUser(userName, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n            content, syntax, userRights, context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param parentReference the parent of the user profile\n     * @param content the content of the user profile\n     * @param syntax the syntax of the provided content\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, EntityReference parentReference, String content,\n        Syntax syntax, String userRights, XWikiContext context) throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        try {\n            // TODO: Verify existing user\n            XWikiDocument doc = getDocument(new DocumentReference(context.getWikiId(), \"XWiki\", userName), context);\n\n            if (!doc.isNew()) {\n                // TODO: throws Exception\n                return -3;\n            }\n\n            DocumentReference userClassReference = userClass.getDocumentReference();\n            BaseObject userObject =\n                doc.newXObject(userClassReference.removeParent(userClassReference.getWikiReference()), context);\n            userClass.fromMap(map, userObject);\n\n            doc.setParentReference(parentReference);\n            doc.setContent(content);\n            doc.setSyntax(syntax);\n\n            // Set the user itself as the creator of the document, so that she has the CREATOR right on her user page.\n            doc.setCreatorReference(doc.getDocumentReference());\n\n            // However, we use the context user for the author to see in the history who has really created the user\n            // (it may be an administrator).\n            if (context.getUserReference() != null) {\n                doc.setAuthorReference(context.getUserReference());\n            } else {\n                // Except if the current user is guest (which means the user registered herself)\n                doc.setAuthorReference(doc.getDocumentReference());\n            }\n\n            // The information from the user profile needs to be indexed using the proper locale. If multilingual is\n            // enabled then the user can choose the desired locale (from the list of supported locales) before\n            // registering. An administrator registering users can do the same. Otherwise, if there is only one locale\n            // supported then that langage will be used.\n            doc.setDefaultLocale(context.getLocale());\n\n            protectUserPage(doc.getFullName(), userRights, doc, context);\n\n            saveDocument(doc, localizePlainOrKey(\"core.comment.createdUser\"), context);\n\n            // Now let's add the user to XWiki.XWikiAllGroup\n            setUserDefaultGroup(doc.getFullName(), context);\n\n            return 1;\n        } catch (Exception e) {\n            Object[] args = { \"XWiki.\" + userName };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_CREATE,\n                \"Cannot create user {0}\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated starting with XE 1.8.1 use\n     *             {@link #createUser(String, Map, String, String, String, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String xwikiname, Map<String, ?> map, String parent, String content, String userRights,\n        XWikiContext context) throws XWikiException\n    {\n        return createUser(xwikiname, map, parent, content, Syntax.XWIKI_1_0.toIdString(), userRights, context);\n    }\n\n    public void setUserDefaultGroup(String fullwikiname, XWikiContext context) throws XWikiException\n    {\n        String groupsPreference = isAllGroupImplicit() ? getConfiguration().getProperty(\"xwiki.users.initialGroups\")\n            : getConfiguration().getProperty(\"xwiki.users.initialGroups\", \"XWiki.XWikiAllGroup\");\n\n        if (groupsPreference != null) {\n            String[] groups = groupsPreference.split(\",\");\n            for (String groupName : groups) {\n                if (StringUtils.isNotBlank(groupName)) {\n                    addUserToGroup(fullwikiname, groupName.trim(), context);\n                }\n            }\n        }\n    }\n\n    protected void addUserToGroup(String userName, String groupName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groupDoc = getDocument(groupName, context);\n\n        DocumentReference groupClassReference = getGroupClass(context).getDocumentReference();\n        BaseObject memberObject =\n            groupDoc.newXObject(groupClassReference.removeParent(groupClassReference.getWikiReference()), context);\n\n        memberObject.setStringValue(\"member\", userName);\n\n        this.saveDocument(groupDoc, localizePlainOrKey(\"core.comment.addedUserToGroup\"), context);\n    }\n\n    public void protectUserPage(String userName, String userRights, XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference rightClassReference = getRightsClass(context).getDocumentReference();\n\n        EntityReference relativeRightClassReference =\n            rightClassReference.removeParent(rightClassReference.getWikiReference());\n\n        // Allow users to edit their own profiles\n        BaseObject newuserrightsobject = doc.newXObject(relativeRightClassReference, context);\n        newuserrightsobject.setLargeStringValue(\"users\", userName);\n        newuserrightsobject.setStringValue(\"levels\", userRights);\n        newuserrightsobject.setIntValue(\"allow\", 1);\n    }\n\n    public User getUser(XWikiContext context)\n    {\n        return getUser(context.getUserReference(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link #getUser(DocumentReference, XWikiContext)}.\n     */\n    @Deprecated\n    public User getUser(String username, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(username);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Retrieve a user from its document reference.\n     *\n     * @param userReference the reference of the user.\n     * @param context the current context.\n     * @return the user corresponding to that document reference.\n     * @since 11.8RC1\n     */\n    public User getUser(DocumentReference userReference, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(userReference);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Prepares the localized resources, according to the selected locale. Set context \"msg\" and locale.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void prepareResources(XWikiContext context)\n    {\n        if (context.get(\"msg\") == null) {\n            Locale locale = getLocalePreference(context);\n            context.setLocale(locale);\n            if (context.getResponse() != null) {\n                context.getResponse().setLocale(locale);\n            }\n            XWikiMessageTool msg = new XWikiMessageTool(Utils.getComponent(ContextualLocalizationManager.class));\n            context.put(\"msg\", msg);\n        }\n    }\n\n    public XWikiUser checkAuth(XWikiContext context) throws XWikiException\n    {\n        return getAuthService().checkAuth(context);\n    }\n\n    public boolean checkAccess(String action, XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // Handle the 'skin' action specially so that resources don`t require special (or even 'view') rights.\n        String firstSpaceName = doc.getDocumentReference().getSpaceReferences().get(0).getName();\n        if (action.equals(\"skin\") && SKIN_RESOURCE_SPACE_NAMES.contains(firstSpaceName)) {\n            // We still need to call checkAuth to set the proper user.\n            XWikiUser user = checkAuth(context);\n            if (user != null) {\n                context.setUser(user.getUser());\n            }\n\n            // Always allow.\n            return true;\n        }\n\n        return getRightService().checkAccess(action, doc, context);\n    }\n\n    public String include(String topic, boolean isForm, XWikiContext context) throws XWikiException\n    {\n        String database = null, incdatabase = null;\n        String prefixedTopic, localTopic;\n\n        // Save current documents in script context\n        Document currentAPIdoc = null, currentAPIcdoc = null, currentAPItdoc = null;\n        ScriptContextManager scritContextManager = Utils.getComponent(ScriptContextManager.class);\n        ScriptContext scontext = scritContextManager.getScriptContext();\n        String currentDocName = context.getWikiId() + \":\" + context.getDoc().getFullName();\n        if (scontext != null) {\n            currentAPIdoc = (Document) scontext.getAttribute(\"doc\");\n            currentAPIcdoc = (Document) scontext.getAttribute(\"cdoc\");\n            currentAPItdoc = (Document) scontext.getAttribute(\"tdoc\");\n        }\n\n        try {\n            int i0 = topic.indexOf(':');\n            if (i0 != -1) {\n                incdatabase = topic.substring(0, i0);\n                database = context.getWikiId();\n                context.setWikiId(incdatabase);\n                prefixedTopic = topic;\n                localTopic = topic.substring(i0 + 1);\n            } else {\n                prefixedTopic = context.getWikiId() + \":\" + topic;\n                localTopic = topic;\n            }\n\n            XWikiDocument doc = null;\n            try {\n                LOGGER.debug(\"Including Topic \" + topic);\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                    if (includedDocs == null) {\n                        includedDocs = new HashSet<String>();\n                        context.put(\"included_docs\", includedDocs);\n                    }\n\n                    if (includedDocs.contains(prefixedTopic) || currentDocName.equals(prefixedTopic)) {\n                        LOGGER.warn(\"Error on too many recursive includes for topic \" + topic);\n                        return \"Cannot make recursive include\";\n                    }\n                    includedDocs.add(prefixedTopic);\n                } catch (Exception e) {\n                }\n\n                // Get document to include\n                DocumentReference targetDocumentReference =\n                    getCurrentMixedDocumentReferenceResolver().resolve(localTopic);\n                doc = getDocument(targetDocumentReference, context);\n\n                if (checkAccess(\"view\", doc, context) == false) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED, \"Access to this document is denied: \" + doc);\n                }\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Exception Including Topic \" + topic, e);\n                return \"Topic \" + topic + \" does not exist\";\n            }\n\n            XWikiDocument contentdoc = doc.getTranslatedDocument(context);\n\n            String result;\n            if (isForm) {\n                // We do everything in the context of the including document\n                if (database != null) {\n                    context.setWikiId(database);\n                }\n\n                // Note: the Script macro in the new rendering checks for programming rights for the document in\n                // the xwiki context.\n                result = getRenderedContent(contentdoc, (XWikiDocument) context.get(\"doc\"), context);\n            } else {\n                // We stay in the included document context\n\n                // Since the Script macro checks for programming rights in the current document, we need to\n                // temporarily set the contentdoc as the current doc before rendering it.\n                XWikiDocument originalDoc = null;\n                try {\n                    originalDoc = context.getDoc();\n                    context.put(\"doc\", doc);\n                    result = getRenderedContent(contentdoc, doc, context);\n                } finally {\n                    context.put(\"doc\", originalDoc);\n                }\n            }\n            try {\n                @SuppressWarnings(\"unchecked\")\n                Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                if (includedDocs != null) {\n                    includedDocs.remove(prefixedTopic);\n                }\n            } catch (Exception e) {\n            }\n            return result;\n        } finally {\n            if (database != null) {\n                context.setWikiId(database);\n            }\n\n            if (currentAPIdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"doc\", currentAPIdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPIcdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"cdoc\", currentAPIcdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPItdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"tdoc\", currentAPItdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n        }\n    }\n\n    /**\n     * Render content from the passed included document, setting the correct security doc (sdoc) and including doc\n     * (idoc).\n     *\n     * @since 2.2M2\n     */\n    private String getRenderedContent(XWikiDocument includedDoc, XWikiDocument includingDoc, XWikiContext context)\n        throws XWikiException\n    {\n        String result;\n        XWikiDocument idoc = (XWikiDocument) context.get(\"idoc\");\n        XWikiDocument sdoc = (XWikiDocument) context.get(\"sdoc\");\n\n        context.put(\"idoc\", includingDoc);\n        context.put(\"sdoc\", includedDoc);\n        try {\n            result = includedDoc.getRenderedContent(Utils.getComponent(RenderingContext.class).getTargetSyntax(), false,\n                context);\n        } finally {\n            // Remove including doc or set the previous one\n            if (idoc == null) {\n                context.remove(\"idoc\");\n            } else {\n                context.put(\"idoc\", idoc);\n            }\n\n            // Remove security doc or set the previous one\n            if (sdoc == null) {\n                context.remove(\"sdoc\");\n            } else {\n                context.put(\"sdoc\", sdoc);\n            }\n        }\n\n        return result;\n    }\n\n    public void deleteDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, true, context);\n    }\n\n    public void deleteDocument(XWikiDocument doc, boolean totrash, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, totrash, true, context);\n    }\n\n    private XWikiDocument prepareDocumentDelete(XWikiDocument doc, XWikiContext context)\n    {\n        // The source document is a new empty XWikiDocument to follow\n        // DocumentUpdatedEvent policy: source document in new document and the old version is available using\n        // doc.getOriginalDocument()\n        XWikiDocument blankDoc = new XWikiDocument(doc.getDocumentReference());\n        // Again to follow general event policy, new document author is the user who modified the document\n        // (here the modification is delete)\n        blankDoc.setOriginalDocument(doc.getOriginalDocument());\n        blankDoc.setAuthorReference(context.getUserReference());\n        blankDoc.setContentAuthorReference(context.getUserReference());\n\n        return blankDoc;\n    }\n\n    private XWikiDocument beforeDelete(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument blankDoc = prepareDocumentDelete(doc, context);\n\n        ObservationManager om = getObservationManager();\n\n        // Inform notification mechanisms that a document is about to be deleted\n        // Note that for the moment the event being send is a bridge event, as we are still passing around\n        // an XWikiDocument as source and an XWikiContext as data.\n        if (om != null) {\n            CancelableEvent documentEvent = new DocumentDeletingEvent(doc.getDocumentReference());\n            om.notify(documentEvent, blankDoc, context);\n\n            // If the action has been canceled by the user then don't perform any deletion and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC,\n                    String.format(\"An Event Listener has cancelled the document deletion for [%s]. Reason: [%s]\",\n                        doc.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n\n        return blankDoc;\n    }\n\n    private void afterDelete(XWikiDocument blankDoc, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new DocumentDeletedEvent(blankDoc.getDocumentReference()), blankDoc, context);\n        }\n    }\n\n    private void deleteDocument(XWikiDocument doc, boolean totrash, boolean notify, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = null;\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (notify) {\n                blankDoc = beforeDelete(doc, context);\n            }\n\n            if (hasRecycleBin(context) && totrash) {\n                // Extract any existing batchId from the context.\n                String batchId = Utils.getComponent(BatchOperationExecutor.class).getCurrentBatchId();\n\n                // Save to recycle bin together with any determined batch ID.\n                getRecycleBinStore().saveToRecycleBin(doc, context.getUser(), new Date(), batchId, context, true);\n            }\n\n            getStore().deleteXWikiDoc(doc, context);\n\n            try {\n                // Inform notification mechanisms that a document has been deleted\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                if (notify) {\n                    afterDelete(blankDoc, context);\n                }\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document delete notifications for document [{}]\",\n                    doc.getDocumentReference(), ex);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Check if the user is allowed to delete the document.\n     * \n     * @param userReference the user responsible for the delete\n     * @param document the document to delete\n     * @param context the XWiki context\n     * @throws XWikiException when failing to delete\n     * @since 11.6\n     * @since 10.11.10\n     */\n    public void checkDeletingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = prepareDocumentDelete(document, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (om != null) {\n                CancelableEvent documentEvent =\n                    new UserDeletingDocumentEvent(userReference, document.getDocumentReference());\n                om.notify(documentEvent, blankDoc, context);\n\n                // If the action has been canceled by the user then don't perform any deletion and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to delete the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    public String getDatabase()\n    {\n        return this.database;\n    }\n\n    public void setDatabase(String database)\n    {\n        this.database = database;\n    }\n\n    public void gc()\n    {\n        System.gc();\n    }\n\n    public long freeMemory()\n    {\n        return Runtime.getRuntime().freeMemory();\n    }\n\n    public long totalMemory()\n    {\n        return Runtime.getRuntime().totalMemory();\n    }\n\n    public long maxMemory()\n    {\n        return Runtime.getRuntime().maxMemory();\n    }\n\n    public String[] split(String str, String sep)\n    {\n        return StringUtils.split(str, sep);\n    }\n\n    /**\n     * @deprecated use {@link ExceptionUtils#getStackTrace(Throwable)} instead\n     */\n    @Deprecated\n    public String printStrackTrace(Throwable e)\n    {\n        StringWriter strwriter = new StringWriter();\n        PrintWriter writer = new PrintWriter(strwriter);\n        e.printStackTrace(writer);\n\n        return strwriter.toString();\n    }\n\n    /**\n     * API to rename a document to another document.\n     *\n     * @param sourceDocumentReference the source document to rename.\n     * @param targetDocumentReference the target reference to rename the document to.\n     * @param overwrite if {@code true} the target document reference will be overwritten if it exists\n     *                  (deleted to the recycle bin before the rename). If {@code false} and the target document exist\n     *                  the rename won't be performed.\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *                                  modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *                                 document reference\n     * @return {@code true} if the rename succeeded. {@code false} if there was any issue.\n     * @throws XWikiException if the document cannot be renamed properly.\n     * @since 12.5RC1\n     */\n    @Unstable\n    public boolean renameDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean overwrite, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences, XWikiContext context)\n        throws XWikiException\n    {\n        boolean result = false;\n\n        // if source and destination are same, no need to perform the rename.\n        if (!sourceDocumentReference.equals(targetDocumentReference)) {\n            XWikiDocument sourceDocument = this.getDocument(sourceDocumentReference, context);\n            XWikiDocument targetDocument = this.getDocument(targetDocumentReference, context);\n\n            ConfigurationSource xwikiproperties = Utils.getComponent(ConfigurationSource.class, \"xwikiproperties\");\n            boolean useAtomicRename = xwikiproperties.getProperty(\"refactoring.rename.useAtomicRename\", Boolean.TRUE);\n\n            // Proceed on the rename only if the source document exists and if either the targetDoc does not exist or\n            // the overwritten is accepted.\n            if (!sourceDocument.isNew() && (overwrite || targetDocument.isNew())) {\n                if (!useAtomicRename) {\n                    this.renameByCopyAndDelete(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                } else {\n                    // Ensure that the current context contains the wiki reference of the source document.\n                    WikiReference wikiReference = context.getWikiReference();\n                    context.setWikiReference(sourceDocumentReference.getWikiReference());\n\n                    // Step 1: Simulate creating a document and deleting a document from listeners point of view\n                    // FIXME: currently modifications made by listeners won't be applied\n                    XWikiDocument futureTargetDocument = sourceDocument.cloneRename(targetDocumentReference, context);\n                    futureTargetDocument.setOriginalDocument(new XWikiDocument(targetDocumentReference));\n                    beforeSave(futureTargetDocument, context);\n                    XWikiDocument deletedDocument = beforeDelete(sourceDocument, context);\n\n                    // Step 2: Perform atomic rename in DB\n                    try {\n                        this.getStore().renameXWikiDoc(sourceDocument, targetDocumentReference, context);\n                    } finally {\n                        context.setWikiReference(wikiReference);\n                    }\n\n                    // Step 3: Simulate a created document and a deleted document from listeners point of view\n                    targetDocument = this.getDocument(targetDocumentReference, context);\n                    afterDelete(deletedDocument, context);\n                    afterSave(futureTargetDocument, context);\n\n                    // Step 4: For each child document, update its parent reference.\n                    // Step 5: For each backlink to rename, parse the backlink document and replace the links with\n                    // the new name.\n                    // Step 6: Refactor the relative links contained in the document to make sure they are relative\n                    // to the new document's location.\n                    this.updateLinksForRename(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private void updateLinksForRename(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 2: For each child document, update its parent reference.\n        if (childDocumentReferences != null) {\n            for (DocumentReference childDocumentReference : childDocumentReferences) {\n                XWikiDocument childDocument = getDocument(childDocumentReference, context);\n                String compactReference = getCompactEntityReferenceSerializer().serialize(newDocumentReference);\n                childDocument.setParent(compactReference);\n                String saveMessage = localizePlainOrKey(\"core.comment.renameParent\", compactReference);\n                childDocument.setAuthorReference(context.getUserReference());\n                saveDocument(childDocument, saveMessage, true, context);\n            }\n        }\n\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        for (DocumentReference backlinkDocumentReference : backlinkDocumentReferences) {\n            XWikiDocument backlinkRootDocument = getDocument(backlinkDocumentReference, context);\n\n            // Update default locale instance\n            renameLinks(backlinkRootDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n\n            // Update translations\n            for (Locale locale : backlinkRootDocument.getTranslationLocales(context)) {\n                XWikiDocument backlinkDocument = backlinkRootDocument.getTranslatedDocument(locale, context);\n\n                renameLinks(backlinkDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n            }\n        }\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        if (Utils.getContextComponentManager().hasComponent(BlockRenderer.class, sourceDoc.getSyntax().toIdString())) {\n            // Only support syntax for which a renderer is provided\n\n            LinkedResourceHelper linkedResourceHelper = Utils.getComponent(LinkedResourceHelper.class);\n\n            DocumentReference oldDocumentReference = sourceDoc.getDocumentReference();\n\n            XDOM newDocumentXDOM = newDocument.getXDOM();\n            List<Block> blocks = linkedResourceHelper.getBlocks(newDocumentXDOM);\n\n            // FIXME: Duplicate code. See org.xwiki.refactoring.internal.DefaultLinkRefactoring#updateRelativeLinks in\n            // xwiki-platform-refactoring-default\n            boolean modified = false;\n            for (Block block : blocks) {\n                org.xwiki.rendering.listener.reference.ResourceReference resourceReference =\n                    linkedResourceHelper.getResourceReference(block);\n                if (resourceReference == null) {\n                    // Skip invalid blocks.\n                    continue;\n                }\n\n                org.xwiki.rendering.listener.reference.ResourceType resourceType = resourceReference.getType();\n\n                // TODO: support ATTACHMENT as well.\n                if (!org.xwiki.rendering.listener.reference.ResourceType.DOCUMENT.equals(resourceType) &&\n                    !org.xwiki.rendering.listener.reference.ResourceType.SPACE.equals(resourceType)) {\n                    // We are currently only interested in Document or Space references.\n                    continue;\n                }\n\n                // current link, use the old document's reference to fill in blanks.\n                EntityReference oldLinkReference = getResourceReferenceEntityReferenceResolver()\n                    .resolve(resourceReference, null, oldDocumentReference);\n                // new link, use the new document's reference to fill in blanks.\n                EntityReference newLinkReference = getResourceReferenceEntityReferenceResolver()\n                    .resolve(resourceReference, null, newDocumentReference);\n\n                // If the new and old link references don`t match, then we must update the relative link.\n                if (!newLinkReference.equals(oldLinkReference)) {\n                    modified = true;\n\n                    // Serialize the old (original) link relative to the new document's location, in compact form.\n                    String serializedLinkReference =\n                        getCompactWikiEntityReferenceSerializer().serialize(oldLinkReference, newDocumentReference);\n\n                    // Update the reference in the XDOM.\n                    linkedResourceHelper.setResourceReferenceString(block, serializedLinkReference);\n                }\n            }\n\n            // Set the new content and save document if needed\n            if (modified) {\n                newDocument.setContent(newDocumentXDOM);\n                newDocument.setAuthorReference(context.getUserReference());\n                saveDocument(newDocument, context);\n            }\n        }\n    }\n\n    /**\n     * Perform a rename of document by copying the document and deleting the old one.\n     * This operation must be used only in case of document rename from one wiki to another, since it's not supported\n     * by the atomic store operation.\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *            document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 12.5\n     * @deprecated Old implementation of the rename by copy and delete. Since 12.5 the implementation using\n     * {@link XWikiStoreInterface#renameXWikiDoc(XWikiDocument, DocumentReference, XWikiContext)} should be preferred.\n     */\n    @Deprecated\n    @Unstable\n    public void renameByCopyAndDelete(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 1: Copy the document and all its translations under a new document with the new reference.\n        copyDocument(sourceDoc.getDocumentReference(), newDocumentReference, false, context);\n\n        // Step 2: For each child document, update its parent reference.\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        updateLinksForRename(sourceDoc, newDocumentReference, backlinkDocumentReferences, childDocumentReferences,\n            context);\n\n        // Step 5: Delete the old document\n        deleteDocument(sourceDoc, context);\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 6: The current document needs to point to the renamed document as otherwise it's pointing to an\n        // invalid XWikiDocument object as it's been deleted...\n        sourceDoc.clone(newDocument);\n    }\n\n    /**\n     * Rename links in passed document and save it if needed.\n     */\n    private void renameLinks(XWikiDocument backlinkDocument, DocumentReference oldLink, DocumentReference newLink,\n        XWikiContext context) throws XWikiException\n    {\n        // FIXME: Duplicate code. See org.xwiki.refactoring.internal.DefaultLinkRefactoring#renameLinks in\n        // xwiki-platform-refactoring-default\n        getOldRendering().renameLinks(backlinkDocument, oldLink, newLink, context);\n\n        // Save if content changed\n        if (backlinkDocument.isContentDirty()) {\n            String saveMessage =\n                localizePlainOrKey(\"core.comment.renameLink\", getCompactEntityReferenceSerializer().serialize(newLink));\n            backlinkDocument.setAuthorReference(context.getUserReference());\n            context.getWiki().saveDocument(backlinkDocument, saveMessage, true, context);\n        }\n    }\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private static EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (compact form).\n     */\n    private static EntityReferenceSerializer<String> getCompactEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n    }\n\n    /**\n     * Used to resolve a ResourceReference into a proper Entity Reference using the current document to fill the blanks.\n     */\n    private static EntityReferenceResolver<org.xwiki.rendering.listener.reference.ResourceReference>\n        getResourceReferenceEntityReferenceResolver()\n    {\n        return Utils\n            .getComponent(new DefaultParameterizedType(null, EntityReferenceResolver.class,\n                org.xwiki.rendering.listener.reference.ResourceReference.class));\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, boolean force, boolean resetCreationData, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, force, resetCreationData,\n            context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, force, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, boolean resetCreationData, XWikiContext context)\n        throws XWikiException\n    {\n        String db = context.getWikiId();\n        String sourceWiki = sourceDocumentReference.getWikiReference().getName();\n        String targetWiki = targetDocumentReference.getWikiReference().getName();\n\n        String sourceStringReference = getDefaultEntityReferenceSerializer().serialize(sourceDocumentReference);\n\n        try {\n            context.setWikiId(sourceWiki);\n            XWikiDocument sdoc = getDocument(sourceDocumentReference, context);\n            if (!sdoc.isNew()) {\n                LOGGER.info(\"Copying document [{}] to [{}]\", sourceDocumentReference, targetDocumentReference);\n\n                // Let's switch to the other database to verify if the document already exists\n                context.setWikiId(targetWiki);\n                XWikiDocument previoustdoc = getDocument(targetDocumentReference, context);\n                // There is already an existing document\n                if (!previoustdoc.isNew()) {\n                    if (!force) {\n                        return false;\n                    }\n                }\n\n                // Let's switch back again to the original db\n                context.setWikiId(sourceWiki);\n\n                if (wikilocale == null) {\n                    XWikiDocument tdoc = sdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // We don't want to trigger a new version otherwise the version number will be wrong.\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        context.setWikiId(targetWiki);\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n\n                    // Now we need to copy the translations\n                    context.setWikiId(sourceWiki);\n                    List<String> tlist = sdoc.getTranslationList(context);\n                    for (String clanguage : tlist) {\n                        XWikiDocument stdoc = sdoc.getTranslatedDocument(clanguage, context);\n                        LOGGER.info(\"Copying document [{}], language [{}] to [{}]\", sourceWiki, clanguage,\n                            targetDocumentReference);\n\n                        context.setWikiId(targetWiki);\n                        XWikiDocument ttdoc = tdoc.getTranslatedDocument(clanguage, context);\n\n                        // There is already an existing document\n                        if (ttdoc != tdoc) {\n                            return false;\n                        }\n\n                        // Let's switch back again to the original db\n                        context.setWikiId(sourceWiki);\n\n                        ttdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                        // Make sure to replace the existing document if any\n                        ttdoc.setNew(true);\n\n                        // forget past versions\n                        if (reset) {\n                            ttdoc.setNew(true);\n                            ttdoc.setVersion(\"1.1\");\n                        }\n                        if (resetCreationData) {\n                            Date now = new Date();\n                            ttdoc.setCreationDate(now);\n                            ttdoc.setContentUpdateDate(now);\n                            ttdoc.setDate(now);\n                            ttdoc.setCreatorReference(context.getUserReference());\n                            ttdoc.setAuthorReference(context.getUserReference());\n                        }\n\n                        // we don't want to trigger a new version\n                        // otherwise the version number will be wrong\n                        tdoc.setMetaDataDirty(false);\n                        tdoc.setContentDirty(false);\n\n                        saveDocument(ttdoc, \"Copied from \" + sourceStringReference, context);\n\n                        if (!reset) {\n                            context.setWikiId(sourceWiki);\n                            XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                            context.setWikiId(targetWiki);\n                            txda = txda.clone(tdoc.getId(), context);\n                            getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                        } else {\n                            getVersioningStore().resetRCSArchive(tdoc, true, context);\n                        }\n                    }\n                } else {\n                    // We want only one language in the end\n                    XWikiDocument stdoc = sdoc.getTranslatedDocument(wikilocale, context);\n\n                    XWikiDocument tdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget language\n                    tdoc.setDefaultLanguage(wikilocale);\n                    tdoc.setLanguage(\"\");\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // we don't want to trigger a new version\n                    // otherwise the version number will be wrong\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n                }\n            }\n            return true;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale,\n        XWikiContext context) throws XWikiException\n    {\n        return copySpaceBetweenWikis(space, sourceWiki, targetWiki, locale, false, context);\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale, boolean clean,\n        XWikiContext context) throws XWikiException\n    {\n        String db = context.getWikiId();\n        int nb = 0;\n        // Workaround for XWIKI-3915: Do not use XWikiStoreInterface#searchDocumentNames since currently it has the\n        // side effect of hidding hidden documents and no other workaround exists than directly using\n        // XWikiStoreInterface#search directly\n        String sql = \"select distinct doc.fullName from XWikiDocument as doc\";\n        List<String> parameters = new ArrayList<>();\n        if (space != null) {\n            parameters.add(space);\n            sql += \" where doc.space = ?\" + parameters.size();\n        }\n\n        if (clean) {\n            try {\n                context.setWikiId(targetWiki);\n                List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n                LOGGER.info(\"Deleting [{}] documents from wiki [{}]\", list.size(), targetWiki);\n\n                for (String docname : list) {\n                    XWikiDocument doc = getDocument(docname, context);\n                    deleteDocument(doc, context);\n                }\n            } finally {\n                context.setWikiId(db);\n            }\n        }\n\n        try {\n            context.setWikiId(sourceWiki);\n            List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n            LOGGER.info(\"Copying [{}] documents from wiki [{}] to wiki [{}]\", list.size(), sourceWiki, targetWiki);\n\n            WikiReference sourceWikiReference = new WikiReference(sourceWiki);\n            WikiReference targetWikiReference = new WikiReference(targetWiki);\n            for (String docname : list) {\n                DocumentReference sourceDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n                sourceDocumentReference = sourceDocumentReference\n                    .replaceParent(sourceDocumentReference.getWikiReference(), sourceWikiReference);\n                DocumentReference targetDocumentReference =\n                    sourceDocumentReference.replaceParent(sourceWikiReference, targetWikiReference);\n                copyDocument(sourceDocumentReference, targetDocumentReference, locale, context);\n                nb++;\n            }\n            return nb;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     * <p>\n     * It does not override document already existing in target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, XWikiContext context) throws XWikiException\n    {\n        return copyWiki(sourceWiki, targetWiki, locale, false, context);\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param clean clean the target wiki before copying\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, boolean clean, XWikiContext context)\n        throws XWikiException\n    {\n        int documents = copySpaceBetweenWikis(null, sourceWiki, targetWiki, locale, clean, context);\n\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new WikiCopiedEvent(sourceWiki, targetWiki), sourceWiki, context);\n        }\n\n        return documents;\n    }\n\n    public String getEncoding()\n    {\n        return getConfiguration().getProperty(\"xwiki.encoding\", \"UTF-8\");\n    }\n\n    public URL getServerURL(String wikiId, XWikiContext xcontext) throws MalformedURLException\n    {\n        // In path based the base URL is the same for all wikis\n        if (!xcontext.isMainWiki(wikiId) && isPathBased()) {\n            return getServerURL(xcontext.getMainXWiki(), xcontext);\n        }\n\n        // If main wiki check the main wiki home page configuration\n        if (xcontext.isMainWiki(wikiId)) {\n            String homepage = getConfiguration().getProperty(\"xwiki.home\");\n            if (StringUtils.isNotEmpty(homepage)) {\n                try {\n                    return new URL(homepage);\n                } catch (MalformedURLException e) {\n                    LOGGER.warn(\"Invalid main wiki home page URL [{}] configured: {}\", homepage,\n                        ExceptionUtils.getRootCauseMessage(e));\n                }\n            }\n        }\n\n        if (wikiId != null) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiId);\n                if (wikiDescriptor != null) {\n                    String server = wikiDescriptor.getDefaultAlias();\n                    if (server != null) {\n                        String protocol = getWikiProtocol(wikiDescriptor);\n                        int port = getWikiPort(wikiDescriptor, xcontext);\n\n                        if (protocol == null && port == -1) {\n                            // If request is a \"real\" one keep using the same protocol/port (if asking for the same wiki)\n                            XWikiRequest request = xcontext.getRequest();\n                            if (request != null && wikiDescriptor.getId().equals(xcontext.getOriginalWikiId())\n                                && !isDaemon(request)) {\n                                URL sourceURL = HttpServletUtils.getSourceBaseURL(xcontext.getRequest());\n\n                                protocol = sourceURL.getProtocol();\n                                port = sourceURL.getPort();\n                            } else {\n                                // Default to HTTP\n                                protocol = \"http\";\n                            }\n                        }\n\n                        return new URL(protocol != null ? protocol : (port == 443 ? \"https\" : \"http\"), server, port,\n                            \"\");\n                    }\n                }\n            } catch (WikiManagerException e) {\n                LOGGER.error(\"Failed to get descriptor for wiki [{}]\", wikiId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private boolean isDaemon(XWikiRequest request)\n    {\n        return request.getHttpServletRequest() instanceof XWikiServletRequestStub\n            && ((XWikiServletRequestStub) request.getHttpServletRequest()).isDaemon();\n    }\n\n    private String getWikiProtocol(WikiDescriptor wikiDescriptor)\n    {\n        // Try wiki descriptor\n        Boolean secure = wikiDescriptor.isSecure();\n        if (secure != null) {\n            return wikiDescriptor.isSecure() == Boolean.TRUE ? \"https\" : \"http\";\n        }\n\n        // Try configuration\n        String protocol = getConfiguration().getProperty(\"xwiki.url.protocol\");\n        if (protocol != null) {\n            return protocol;\n        }\n\n        // Try main wiki\n        try {\n            secure = getWikiDescriptorManager().getMainWikiDescriptor().isSecure();\n\n            if (secure != null) {\n                return secure ? \"https\" : \"http\";\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return null;\n    }\n\n    private int getWikiPort(WikiDescriptor wikiDescriptor, XWikiContext context)\n    {\n        // Try wiki descriptor\n        int port = wikiDescriptor.getPort();\n        if (port != -1) {\n            return port;\n        }\n\n        // Try main wiki\n        try {\n            port = getWikiDescriptorManager().getMainWikiDescriptor().getPort();\n\n            if (port != -1) {\n                return port;\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return -1;\n    }\n\n    public String getServletPath(String wikiName, XWikiContext context)\n    {\n        // unless we are in virtual wiki path mode we should return null\n        if (!context.isMainWiki(wikiName) && isPathBased()) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiName);\n                if (wikiDescriptor != null) {\n                    return \"wiki/\" + wikiDescriptor.getDefaultAlias() + \"/\";\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to get URL for provided wiki [\" + wikiName + \"]\", e);\n            }\n        }\n\n        String servletPath = getConfiguration().getProperty(\"xwiki.servletpath\", \"\");\n\n        if (context.getRequest() != null) {\n            if (StringUtils.isEmpty(servletPath)) {\n                String currentServletpath = context.getRequest().getServletPath();\n                if (currentServletpath != null && currentServletpath.startsWith(\"/bin\")) {\n                    servletPath = \"bin/\";\n                } else {\n                    servletPath = getConfiguration().getProperty(\"xwiki.defaultservletpath\", \"bin/\");\n                }\n            }\n        }\n\n        return servletPath;\n    }\n\n    public String getWebAppPath(XWikiContext context)\n    {\n        String contextPath = getConfiguration().getProperty(\"xwiki.webapppath\");\n        if (contextPath == null) {\n            // Try getting the context path by asking the request for it (if a request exists!) and if it doesn't\n            // work try extracting it from the context URL.\n            // TODO: Instead of trying to extract from the URL, save the context path at webapp init (using a\n            // ServlettContextListener for example).\n            XWikiRequest request = context.getRequest();\n            if (request != null) {\n                contextPath = request.getContextPath();\n            }\n            if (contextPath == null) {\n                // Extract the context by getting the first path segment\n                contextPath = StringUtils.substringBefore(StringUtils.stripStart(context.getURL().getPath(), \"/\"), \"/\");\n            }\n        }\n\n        // Remove any leading or trailing slashes\n        contextPath = StringUtils.strip(contextPath, \"/\");\n\n        // TODO We're using URL parts in a wrong way, since contextPath and servletPath are returned with a leading /,\n        // while we need a trailing /. This code ensure we always have CONTEXTNAME + \"/\".\n        return contextPath + \"/\";\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference entityReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // TODO: replace this API with a clean implementation of EntityResourceReferenceSerializer\n\n        // Handle attachment URL\n        if (EntityType.ATTACHMENT.equals(entityReference.getType())) {\n            // Get the full attachment reference\n            AttachmentReference attachmentReference = getCurrentAttachmentResolver().resolve(entityReference);\n            return getAttachmentURL(attachmentReference, action, queryString, context);\n        }\n\n        // For all other types, we return the URL of the default corresponding document.\n        DocumentReference documentReference = getDocumentReference(entityReference, context);\n        return getURL(documentReference, action, queryString, anchor, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public String getURL(EntityReference reference, XWikiContext context)\n    {\n        String action = \"view\";\n        if (reference.getType() == EntityType.ATTACHMENT) {\n            action = \"download\";\n        }\n        return getURL(reference, action, context);\n    }\n\n    /**\n     * @since 2.2.1\n     */\n    public String getURL(DocumentReference documentReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // We need to serialize the space reference because the old createURL() API doesn't accept a DocumentReference.\n        String spaces = getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference());\n\n        // Take into account the specified document locale.\n        Locale documentLocale = documentReference.getLocale();\n        String actualQueryString = queryString;\n        if (documentLocale != null && documentLocale != Locale.ROOT) {\n            String localeQueryString = \"language=\" + documentLocale;\n            if (StringUtils.isEmpty(queryString)) {\n                actualQueryString = localeQueryString;\n            } else {\n                // Note: if the locale is already specified on the given query string then it won't be overwriten\n                // because the first parameter value is taken into account.\n                actualQueryString += '&' + localeQueryString;\n            }\n        }\n\n        URL url = context.getURLFactory().createURL(spaces, documentReference.getName(), action, actualQueryString,\n            anchor, documentReference.getWikiReference().getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #getURL(DocumentReference, String, String, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, String queryString, String anchor, XWikiContext context)\n    {\n        return getURL(getCurrentMixedDocumentReferenceResolver().resolve(fullname), action, queryString, anchor,\n            context);\n    }\n\n    public String getURL(String fullname, String action, String querystring, XWikiContext context)\n    {\n        return getURL(fullname, action, querystring, null, context);\n    }\n\n    /**\n     * @since 2.3M2\n     */\n    public String getURL(DocumentReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @deprecated since 2.3M2 use {@link #getURL(DocumentReference, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, XWikiContext context)\n    {\n        return getURL(fullname, action, null, null, context);\n    }\n\n    public String getExternalURL(String fullname, String action, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, null, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getExternalURL(String fullname, String action, String querystring, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, querystring, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    /**\n     * Get the full URL of the given {@link DocumentReference}. This also includes the server name of the wiki.\n     *\n     * @param documentReference the document that should be resolved\n     * @param action the action of the URL\n     * @param querystring the URL parameters\n     * @param anchor the anchor of the document\n     * @param context the current XWikiContext\n     * @return the full URL of the given reference\n     * @since 9.6RC1\n     */\n    public String getExternalURL(DocumentReference documentReference, String action, String querystring, String anchor,\n        XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(\n            this.getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference()),\n            documentReference.getName(), action, querystring, anchor, documentReference.getWikiReference().getName(),\n            context);\n        return url.toString();\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String action, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), action, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String queryString, XWikiContext context)\n    {\n        return getAttachmentURL(attachmentReference, \"download\", queryString, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentRevisionURL(AttachmentReference attachmentReference, String revision, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentRevisionURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), revision, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getAttachmentURL(String fullname, String filename, XWikiContext context) throws XWikiException\n    {\n        return getAttachmentURL(fullname, filename, null, context);\n    }\n\n    /**\n     * @since 2.5RC1\n     */\n    public String getAttachmentURL(String fullname, String filename, String queryString, XWikiContext context)\n        throws XWikiException\n    {\n        AttachmentReference attachmentReference =\n            new AttachmentReference(filename, getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        return getAttachmentURL(attachmentReference, queryString, context);\n    }\n\n    // Usefull date functions\n\n    public int getTimeDelta(long time)\n    {\n        Date ctime = new Date();\n        return (int) (ctime.getTime() - time);\n    }\n\n    public boolean isMultiLingual(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"multilingual\", \"0\", context));\n    }\n\n    public boolean isLDAP()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.ldap\"));\n    }\n\n    /**\n     * @return true if XWikiAllGroup group should be seen as virtual group containing all users, false to use it as any\n     *         other group\n     * @since 9.3RC1\n     */\n    public boolean isAllGroupImplicit()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.group.allgroupimplicit\"));\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(XWikiContext context) throws XWikiException\n    {\n        return checkActive(context.getUser(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(String user, XWikiContext context) throws XWikiException\n    {\n        XWikiUser xWikiUser = new XWikiUser(user);\n        return xWikiUser.isDisabled(context) ? 0 : 1;\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public DocumentReference getDocumentReference(XWikiRequest request, XWikiContext context)\n    {\n        DocumentReference reference;\n        if (context.getMode() == XWikiContext.MODE_PORTLET) {\n            if (request.getParameter(\"topic\") != null) {\n                reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n            } else {\n                // Point to this wiki's home page\n                reference = getDefaultDocumentReference().setWikiReference(new WikiReference(context.getWikiId()));\n            }\n        } else if (context.getMode() == XWikiContext.MODE_XMLRPC) {\n            reference = new DocumentReference(context.getWikiId(),\n                context.getDoc().getDocumentReference().getLastSpaceReference().getName(),\n                context.getDoc().getDocumentReference().getName());\n        } else {\n            ResourceReference resourceReference = getResourceReferenceManager().getResourceReference();\n            if (resourceReference instanceof EntityResourceReference) {\n                EntityResourceReference entityResource = (EntityResourceReference) resourceReference;\n                String action = entityResource.getAction().getActionName();\n                if ((request.getParameter(\"topic\") != null) && (action.equals(\"edit\") || action.equals(\"inline\"))) {\n                    reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n                } else {\n                    reference = new DocumentReference(\n                        entityResource.getEntityReference().extractReference(EntityType.DOCUMENT));\n                }\n            } else {\n                // TODO: Handle references not pointing to a document...\n                // Big problem we don't have an Entity URL!\n                throw new RuntimeException(\n                    String.format(\"Resource Reference [%s] isn't an Entity Resource Reference!\", resourceReference));\n            }\n        }\n\n        return reference;\n    }\n\n    /**\n     * Helper method, removes a predefined path segment (the context path or the servel path) from the start of the\n     * requested URI and returns the remainder. This method is needed because special characters in the path can be\n     * URL-encoded, depending on whether the request is forwarded through the request dispatcher or not, and also\n     * depending on the client (some browsers encode -, while some don't).\n     *\n     * @param path the path, as taken from the requested URI\n     * @param segment the segment to remove, as reported by the container\n     * @return the path with the specified segment trimmed from its start\n     */\n    public static String stripSegmentFromPath(String path, String segment)\n    {\n        if (!path.startsWith(segment)) {\n            // The context path probably contains special characters that are encoded in the URL\n            try {\n                segment = URIUtil.encodePath(segment);\n            } catch (URIException e) {\n                LOGGER.warn(\"Invalid path: [\" + segment + \"]\");\n            }\n        }\n        if (!path.startsWith(segment)) {\n            // Some clients also encode -, although it's allowed in the path\n            segment = segment.replaceAll(\"-\", \"%2D\");\n        }\n        if (!path.startsWith(segment)) {\n            // Can't find the context path in the URL (shouldn't happen), just skip to the next path segment\n            return path.substring(path.indexOf('/', 1));\n        }\n        return path.substring(segment.length());\n    }\n\n    public boolean prepareDocuments(XWikiRequest request, XWikiContext context, VelocityContext vcontext)\n        throws XWikiException\n    {\n        XWikiDocument doc;\n        context.getWiki().prepareResources(context);\n        DocumentReference reference = getDocumentReference(request, context);\n        if (context.getAction().equals(\"register\")) {\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n        } else {\n            try {\n                doc = getDocument(reference, context);\n            } catch (XWikiException e) {\n                doc = context.getDoc();\n                if (context.getAction().equals(\"delete\")) {\n                    if (doc == null) {\n                        setPhonyDocument(reference, context, vcontext);\n                        doc = context.getDoc();\n                    }\n                    if (!checkAccess(\"admin\", doc, context)) {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // the user is set after the access is checked.\n        boolean hasAccess = checkAccess(context.getAction(), doc, context);\n\n        XWikiUser user;\n        if (context.getUserReference() != null) {\n            user = new XWikiUser(context.getUserReference());\n        } else {\n            user = new XWikiUser(context.getUser());\n        }\n\n        // We need to check rights before we look for translations\n        // Otherwise we don't have the user language\n        if (!hasAccess) {\n            Object[] args = { doc.getFullName(), user.getUser() };\n            setPhonyDocument(reference, context, vcontext);\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access to document {0} has been denied to user {1}\", null, args);\n        // User is disabled: the mail address is marked as checked\n        } else if (user.isDisabled(context) && user.isEmailChecked(context)) {\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if (!((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\"))))) {\n                Object[] args = { user.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_DISABLED,\n                    \"User {0} account is disabled\", null, args);\n            }\n        // User actually needs to activate his mail address.\n        } else if (user.isDisabled(context) && !user.isEmailChecked(context)) {\n            boolean allow = false;\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if ((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\")))) {\n                allow = true;\n            } else {\n                String allowed = getConfiguration().getProperty(\"xwiki.inactiveuser.allowedpages\", \"\");\n                if (context.getAction().equals(\"view\") && !allowed.equals(\"\")) {\n                    String[] allowedList = StringUtils.split(allowed, \" ,\");\n                    for (String element : allowedList) {\n                        if (element.equals(doc.getFullName())) {\n                            allow = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!allow) {\n                Object[] args = { context.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_INACTIVE,\n                    \"User {0} account is inactive\", null, args);\n            }\n        }\n\n        context.put(\"doc\", doc);\n        context.put(\"cdoc\", doc);\n        vcontext.put(\"doc\", doc.newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        XWikiDocument tdoc;\n\n        // If the parameter language exists and is empty, it means we want to force loading the regular document\n        // not a translation. This should be handled later by doing a better separation between locale used in the UI\n        // and for loading the documents.\n        if (\"\".equals(context.getRequest().getParameter(\"language\"))) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(context);\n        }\n\n        try {\n            String rev = (String) context.get(\"rev\");\n            if (StringUtils.isNotEmpty(rev)) {\n                tdoc = getDocument(tdoc, rev, context);\n            }\n        } catch (Exception ex) {\n            // Invalid version, just use the most recent one\n        }\n        context.put(\"tdoc\", tdoc);\n        vcontext.put(\"tdoc\", tdoc.newDocument(context));\n\n        return true;\n    }\n\n    /**\n     * @since 8.3M1\n     */\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument(reference);\n        doc.setElements(XWikiDocument.HAS_ATTACHMENTS | XWikiDocument.HAS_OBJECTS);\n        doc.setStore(getStore());\n        context.put(\"doc\", doc);\n    }\n\n    /**\n     * @since 2.3M1\n     * @deprecated since 8.3M1, use {@link #setPhonyDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(reference, context);\n\n        vcontext.put(\"doc\", context.getDoc().newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        vcontext.put(\"tdoc\", vcontext.get(\"doc\"));\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #setPhonyDocument(DocumentReference, XWikiContext, VelocityContext)}\n     */\n    @Deprecated\n    public void setPhonyDocument(String docName, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName), context, vcontext);\n    }\n\n    public XWikiEngineContext getEngineContext()\n    {\n        return this.engine_context;\n    }\n\n    public void setEngineContext(XWikiEngineContext engine_context)\n    {\n        this.engine_context = engine_context;\n    }\n\n    public void setAuthService(XWikiAuthService authService)\n    {\n        this.authService = authService;\n    }\n\n    public void setRightService(XWikiRightService rightService)\n    {\n        this.rightService = rightService;\n    }\n\n    public XWikiGroupService getGroupService(XWikiContext context) throws XWikiException\n    {\n        synchronized (this.GROUP_SERVICE_LOCK) {\n            if (this.groupService == null) {\n                String groupClass = getConfiguration().getProperty(\"xwiki.authentication.groupclass\",\n                    \"com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl\");\n\n                try {\n                    this.groupService = (XWikiGroupService) Class.forName(groupClass).newInstance();\n                } catch (Exception e) {\n                    LOGGER.error(\"Failed to instantiate custom group service class: \" + e.getMessage(), e);\n                    this.groupService = new XWikiGroupServiceImpl();\n                }\n                this.groupService.init(this, context);\n            }\n\n            return this.groupService;\n        }\n    }\n\n    public void setGroupService(XWikiGroupService groupService)\n    {\n        this.groupService = groupService;\n    }\n\n    // added some log statements to make debugging easier - LBlaze 2005.06.02\n    public XWikiAuthService getAuthService()\n    {\n        synchronized (this.AUTH_SERVICE_LOCK) {\n            if (this.authService == null) {\n\n                LOGGER.info(\"Initializing AuthService...\");\n\n                String authClass = getConfiguration().getProperty(\"xwiki.authentication.authclass\");\n                if (StringUtils.isNotEmpty(authClass)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Using custom AuthClass \" + authClass + \".\");\n                    }\n                } else {\n                    if (isLDAP()) {\n                        authClass = \"com.xpn.xwiki.user.impl.LDAP.XWikiLDAPAuthServiceImpl\";\n                    } else {\n                        authClass = \"com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl\";\n                    }\n\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Using default AuthClass \" + authClass + \".\");\n                    }\n                }\n\n                try {\n                    // Get the current ClassLoader\n                    @SuppressWarnings(\"deprecation\")\n                    ClassLoaderManager clManager = Utils.getComponent(ClassLoaderManager.class);\n                    ClassLoader classloader = null;\n                    if (clManager != null) {\n                        classloader = clManager.getURLClassLoader(\"wiki:xwiki\", false);\n                    }\n\n                    // Get the class\n                    if (classloader != null) {\n                        this.authService = (XWikiAuthService) Class.forName(authClass, true, classloader).newInstance();\n                    } else {\n                        this.authService = (XWikiAuthService) Class.forName(authClass).newInstance();\n                    }\n\n                    LOGGER.debug(\"Initialized AuthService using Relfection.\");\n                } catch (Exception e) {\n                    LOGGER.warn(\"Failed to initialize AuthService \" + authClass\n                        + \" using Reflection, trying default implementations using 'new'.\", e);\n\n                    this.authService = new XWikiAuthServiceImpl();\n\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\n                            \"Initialized AuthService \" + this.authService.getClass().getName() + \" using 'new'.\");\n                    }\n                }\n            }\n\n            return this.authService;\n        }\n    }\n\n    private static final String DEFAULT_RIGHT_SERVICE_CLASS =\n        \"org.xwiki.security.authorization.internal.XWikiCachingRightService\";\n\n    public XWikiRightService getRightService()\n    {\n        synchronized (this.RIGHT_SERVICE_LOCK) {\n            if (this.rightService == null) {\n                LOGGER.info(\"Initializing RightService...\");\n\n                String rightsClass = getConfiguration().getProperty(\"xwiki.authentication.rightsclass\");\n                if (rightsClass != null && !rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.warn(\"Using custom Right Service [{}].\", rightsClass);\n                    }\n                } else {\n                    rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Using default Right Service [{}].\", rightsClass);\n                    }\n                }\n\n                try {\n                    this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                    LOGGER.debug(\"Initialized RightService using Reflection.\");\n                } catch (Exception e) {\n                    Exception lastException = e;\n\n                    if (!rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize custom RightService [%s]\"\n                                + \" by Reflection, using default implementation [%s].\",\n                            rightsClass, DEFAULT_RIGHT_SERVICE_CLASS), e);\n                        rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                        try {\n                            this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                            LOGGER.debug(\"Initialized default RightService using Reflection.\");\n                        } catch (Exception e1) {\n                            lastException = e1;\n                        }\n                    }\n\n                    if (this.rightService == null) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize RightService [%s]\"\n                                + \" by Reflection, using OLD implementation [%s] with 'new'.\",\n                            rightsClass, XWikiRightServiceImpl.class.getCanonicalName()), lastException);\n\n                        this.rightService = new XWikiRightServiceImpl();\n\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Initialized old RightService implementation \"\n                                + this.rightService.getClass().getName() + \" using 'new'.\");\n                        }\n                    }\n                }\n            }\n            return this.rightService;\n        }\n    }\n\n    public XWikiStatsService getStatsService(XWikiContext context)\n    {\n        synchronized (this.STATS_SERVICE_LOCK) {\n            if (this.statsService == null) {\n                if (\"1\".equals(getConfiguration().getProperty(\"xwiki.stats\", \"1\"))) {\n                    String storeClass = getConfiguration().getProperty(\"xwiki.stats.class\",\n                        \"com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl\");\n                    try {\n                        this.statsService = (XWikiStatsService) Class.forName(storeClass).newInstance();\n                    } catch (Exception e) {\n                        LOGGER.error(e.getMessage(), e);\n\n                        this.statsService = new XWikiStatsServiceImpl();\n                    }\n\n                    this.statsService.init(context);\n                }\n            }\n\n            return this.statsService;\n        }\n    }\n\n    public XWikiURLFactoryService getURLFactoryService()\n    {\n        if (this.urlFactoryService == null) {\n            synchronized (this.URLFACTORY_SERVICE_LOCK) {\n                if (this.urlFactoryService == null) {\n                    LOGGER.info(\"Initializing URLFactory Service...\");\n\n                    XWikiURLFactoryService factoryService = null;\n\n                    String urlFactoryServiceClass = getConfiguration().getProperty(\"xwiki.urlfactory.serviceclass\");\n                    if (urlFactoryServiceClass != null) {\n                        try {\n                            if (LOGGER.isDebugEnabled()) {\n                                LOGGER.debug(\"Using custom URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                            }\n                            factoryService = (XWikiURLFactoryService) Class.forName(urlFactoryServiceClass)\n                                .getConstructor(new Class<?>[] { XWiki.class }).newInstance(new Object[] { this });\n                        } catch (Exception e) {\n                            factoryService = null;\n                            LOGGER.warn(\"Failed to initialize URLFactory Service [\" + urlFactoryServiceClass + \"]\", e);\n                        }\n                    }\n                    if (factoryService == null) {\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Using default URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                        }\n                        factoryService = new XWikiURLFactoryServiceImpl(this);\n                    }\n\n                    // Set the urlFactoryService object in one assignment to prevent threading\n                    // issues when checking for\n                    // null above.\n                    this.urlFactoryService = factoryService;\n                }\n            }\n        }\n\n        return this.urlFactoryService;\n    }\n\n    public XWikiCriteriaService getCriteriaService(XWikiContext context)\n    {\n        return this.criteriaService;\n    }\n\n    public ZipOutputStream getZipOutputStream(XWikiContext context) throws IOException\n    {\n        return new ZipOutputStream(context.getResponse().getOutputStream());\n    }\n\n    private Map<String, SearchEngineRule> getSearchEngineRules(XWikiContext context)\n    {\n        // We currently hardcode the rules\n        // We will put them in the preferences soon\n        Map<String, SearchEngineRule> map = new HashMap<String, SearchEngineRule>();\n        map.put(\"Google\", new SearchEngineRule(\"google.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"MSN\", new SearchEngineRule(\"search.msn.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Yahoo\", new SearchEngineRule(\"search.yahoo.\", \"s/(^|.*&)p=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Voila\", new SearchEngineRule(\"voila.fr\", \"s/(^|.*&)kw=(.*?)(&.*|$)/$2/\"));\n\n        return map;\n    }\n\n    public String getRefererText(String referer, XWikiContext context)\n    {\n        try {\n            URL url = new URL(referer);\n            Map<String, SearchEngineRule> searchengines = getSearchEngineRules(context);\n            if (searchengines != null) {\n                for (SearchEngineRule senginerule : searchengines.values()) {\n                    String host = url.getHost();\n                    int i1 = host.indexOf(senginerule.getHost());\n                    if (i1 != -1) {\n                        String query = context.getUtil().substitute(senginerule.getRegEx(), url.getQuery());\n                        if ((query != null) && (!query.equals(\"\"))) {\n                            // We return the query text instead of the full referer\n                            return host.substring(i1) + \":\" + query;\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        String result = referer.substring(referer.indexOf(\"://\") + 3);\n        if (result.endsWith(\"/\")) {\n            return result.substring(0, result.length() - 1);\n        } else {\n            return result;\n        }\n    }\n\n    public boolean isMySQL()\n    {\n        if (getHibernateStore() == null) {\n            return false;\n        }\n\n        Object dialect = getHibernateStore().getConfiguration().getProperties().get(\"dialect\");\n        return \"org.hibernate.dialect.MySQLDialect\".equals(dialect)\n            || \"net.sf.hibernate.dialect.MySQLDialect\".equals(dialect);\n    }\n\n    public String getFullNameSQL()\n    {\n        return getFullNameSQL(true);\n    }\n\n    public String getFullNameSQL(boolean newFullName)\n    {\n        if (newFullName) {\n            return \"doc.fullName\";\n        }\n\n        if (this.fullNameSQL == null) {\n            if (isMySQL()) {\n                this.fullNameSQL = \"CONCAT(doc.space,'.',doc.name)\";\n            } else {\n                this.fullNameSQL = \"doc.space||'.'||doc.name\";\n            }\n        }\n\n        return this.fullNameSQL;\n    }\n\n    public String getUserName(String user, XWikiContext context)\n    {\n        return getUserName(user, null, true, context);\n    }\n\n    public String getUserName(String user, String format, XWikiContext context)\n    {\n        return getUserName(user, format, true, context);\n    }\n\n    /**\n     * @return a formatted and pretty printed user name for displaying\n     */\n    public String getUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (StringUtils.isBlank(user)) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        DocumentReference userReference = getCurrentMixedDocumentReferenceResolver().resolve(user);\n\n        return getUserName(userReference, format, link, true, context);\n    }\n\n    /**\n     * Generate a display user name and return it.\n     *\n     * @param userReference\n     * @param format a Velocity scnippet used to format the user name\n     * @param link true if a full html link snippet should be returned\n     * @param escapeXML true if the returned name should be escaped (forced true if {@code link} is true)\n     * @param context see {@link XWikiContext}\n     * @return the display user name or a html snippet with the link to the passed user\n     * @since 6.4RC1\n     */\n    public String getUserName(DocumentReference userReference, String format, boolean link, boolean escapeXML,\n        XWikiContext context)\n    {\n        if (userReference == null) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        XWikiDocument userdoc = null;\n        try {\n            userdoc = getDocument(userReference, context);\n            if (userdoc == null) {\n                return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n            }\n\n            BaseObject userobj = userdoc.getObject(\"XWiki.XWikiUsers\");\n            if (userobj == null) {\n                return escapeXML ? XMLUtils.escape(userdoc.getDocumentReference().getName())\n                    : userdoc.getDocumentReference().getName();\n            }\n\n            String text;\n\n            if (format == null) {\n                text = userobj.getStringValue(\"first_name\");\n                String lastName = userobj.getStringValue(\"last_name\");\n                if (!text.isEmpty() && !lastName.isEmpty()) {\n                    text += ' ';\n                }\n                text += userobj.getStringValue(\"last_name\");\n                if (StringUtils.isBlank(text)) {\n                    text = userdoc.getDocumentReference().getName();\n                }\n            } else {\n                VelocityContext vcontext;\n                try {\n                    vcontext = getVelocityContextFactory().createContext();\n                } catch (XWikiVelocityException e) {\n                    LOGGER.error(\"Failed to create standard VelocityContext\", e);\n\n                    vcontext = new XWikiVelocityContext();\n                }\n\n                for (String propname : userobj.getPropertyList()) {\n                    vcontext.put(propname, userobj.getStringValue(propname));\n                }\n                text = evaluateVelocity(format,\n                    \"<username formatting code in \" + context.getDoc().getDocumentReference() + \">\", vcontext);\n            }\n\n            if (escapeXML || link) {\n                text = XMLUtils.escape(text.trim());\n            }\n\n            if (link) {\n                text = \"<span class=\\\"wikilink\\\"><a href=\\\"\" + userdoc.getURL(\"view\", context) + \"\\\">\" + text\n                    + \"</a></span>\";\n            }\n            return text;\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to display the user name of [{}]. Root cause is [{}]. Falling back on the user id.\",\n                userReference, ExceptionUtils.getRootCauseMessage(e));\n\n            return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param namespace the namespace under which to evaluate it (used for isolation)\n     * @param vcontext the Velocity context to use when evaluating. If {@code null}, then a new context will be created,\n     *            initialized and used.\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String namespace, VelocityContext vcontext)\n    {\n        try {\n            return getVelocityEvaluator().evaluateVelocity(content, namespace, vcontext);\n        } catch (XWikiException xe) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", namespace, content,\n                xe.getCause());\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param name the namespace under which to evaluate it (used for isolation)\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String name)\n    {\n        try {\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext velocityContext = velocityManager.getVelocityContext();\n            return evaluateVelocity(content, name, velocityContext);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", name, content, e);\n            Object[] args = { name };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while parsing velocity page {0}\", e,\n                args);\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * Generate and return an unescaped user display name.\n     *\n     * @param userReference the user reference\n     * @param context see {@link XWikiContext}\n     * @return the unescaped display user name\n     * @since 6.4RC1\n     */\n    public String getPlainUserName(DocumentReference userReference, XWikiContext context)\n    {\n        return getUserName(userReference, null, false, false, context);\n    }\n\n    public boolean hasCentralizedAuthentication(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"authentication_centralized\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.centralized\", \"0\"));\n    }\n\n    public String getLocalUserName(String user, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, null, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), null, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, link, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, link, context);\n        }\n    }\n\n    public String formatDate(Date date, String format, XWikiContext context)\n    {\n        if (date == null) {\n            return \"\";\n        }\n        String xformat = format;\n        String defaultFormat = \"yyyy/MM/dd HH:mm\";\n\n        if (format == null) {\n            xformat = getXWikiPreference(\"dateformat\", defaultFormat, context);\n        }\n\n        try {\n            DateFormatSymbols formatSymbols = null;\n            try {\n                String language = getLanguagePreference(context);\n                formatSymbols = new DateFormatSymbols(new Locale(language));\n            } catch (Exception e2) {\n                String language = getXWikiPreference(\"default_language\", context);\n                if ((language != null) && (!language.equals(\"\"))) {\n                    formatSymbols = new DateFormatSymbols(new Locale(language));\n                }\n            }\n\n            SimpleDateFormat sdf;\n            if (formatSymbols != null) {\n                sdf = new SimpleDateFormat(xformat, formatSymbols);\n            } else {\n                sdf = new SimpleDateFormat(xformat);\n            }\n\n            try {\n                sdf.setTimeZone(TimeZone.getTimeZone(getUserTimeZone(context)));\n            } catch (Exception e) {\n            }\n\n            return sdf.format(date);\n        } catch (Exception e) {\n            LOGGER.info(\"Failed to format date [\" + date + \"] with pattern [\" + xformat + \"]: \" + e.getMessage());\n            if (format == null) {\n                if (xformat.equals(defaultFormat)) {\n                    return date.toString();\n                } else {\n                    return formatDate(date, defaultFormat, context);\n                }\n            } else {\n                return formatDate(date, null, context);\n            }\n        }\n    }\n\n    /*\n     * Allow to read user setting providing the user timezone All dates will be expressed with this timezone\n     */\n    public String getUserTimeZone(XWikiContext context)\n    {\n        String tz = getUserPreference(\"timezone\", context);\n        // We perform this verification ourselves since TimeZone#getTimeZone(String) with an invalid parameter returns\n        // GMT and not the system default.\n        if (!ArrayUtils.contains(TimeZone.getAvailableIDs(), tz)) {\n            String defaultTz = TimeZone.getDefault().getID();\n            return getConfiguration().getProperty(\"xwiki.timezone\", defaultTz);\n        } else {\n            return tz;\n        }\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #exists(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public boolean exists(String fullname, XWikiContext context)\n    {\n        return exists(getCurrentMixedDocumentReferenceResolver().resolve(fullname), context);\n    }\n\n    public boolean exists(DocumentReference documentReference, XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            XWikiDocument doc = new XWikiDocument(documentReference, documentReference.getLocale());\n\n            context.setWikiId(documentReference.getWikiReference().getName());\n\n            return getStore().exists(doc, context);\n        } catch (XWikiException e) {\n            return false;\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    public String getAdType(XWikiContext context)\n    {\n        String adtype = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adtype = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adtype\");\n        }\n\n        if (adtype.equals(\"\")) {\n            adtype = getConfiguration().getProperty(\"xwiki.ad.type\", \"\");\n        }\n\n        return adtype;\n    }\n\n    public String getAdClientId(XWikiContext context)\n    {\n        final String defaultadclientid = \"pub-2778691407285481\";\n        String adclientid = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adclientid = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adclientid\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = getConfiguration().getProperty(\"xwiki.ad.clientid\", \"\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = defaultadclientid;\n        }\n\n        return adclientid;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public XWikiPluginInterface getPlugin(String name, XWikiContext context)\n    {\n        XWikiPluginManager plugins = getPluginManager();\n        Vector<String> pluginlist = plugins.getPlugins();\n        for (String pluginname : pluginlist) {\n            if (pluginname.equals(name)) {\n                return plugins.getPlugin(pluginname);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public Api getPluginApi(String name, XWikiContext context)\n    {\n        XWikiPluginInterface plugin = getPlugin(name, context);\n        if (plugin != null) {\n            return plugin.getPluginApi(plugin, context);\n        }\n\n        return null;\n    }\n\n    public int getHttpTimeout(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.timeout\", 60000);\n    }\n\n    public String getHttpUserAgent(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.useragent\", \"XWikiBot/1.0\");\n    }\n\n    public String getURLContent(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, int timeout, String userAgent) throws IOException\n    {\n        String content;\n        HttpClient client = getHttpClient(timeout, userAgent);\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            client.executeMethod(get);\n            content = get.getResponseBodyAsString();\n        } finally {\n            // Release any connection resources used by the method\n            get.releaseConnection();\n        }\n\n        return content;\n    }\n\n    public String getURLContent(String surl, String username, String password, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBodyAsString();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContentAsBytes(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, int timeout, String userAgent) throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, XWikiContext context)\n        throws IOException\n    {\n        return getURLContentAsBytes(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    /**\n     * API to list all spaces in the current wiki.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @return a list of string representing all non-hidden spaces (ie spaces that have non-hidden pages) for the\n     *         current wiki\n     * @throws XWikiException if something went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaces(XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaces\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    /**\n     * API to list all non-hidden documents in a space.\n     *\n     * @param spaceReference the local reference of the space for which to return all non-hidden documents\n     * @return the list of document names (in the format {@code Space.Page}) for non-hidden documents in the specified\n     *         space\n     * @throws XWikiException if the loading went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaceDocsName(String spaceReference, XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaceDocsName\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\"))\n                .bindValue(\"space\", spaceReference).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public List<String> getIncludedMacros(String defaultSpace, String content, XWikiContext context)\n    {\n        List<String> list;\n\n        try {\n            String pattern = \"#includeMacros[ ]*\\\\([ ]*([\\\"'])(.*?)\\\\1[ ]*\\\\)\";\n            list = context.getUtil().getUniqueMatches(content, pattern, 2);\n            for (int i = 0; i < list.size(); i++) {\n                String name = list.get(i);\n                if (name.indexOf('.') == -1) {\n                    list.set(i, defaultSpace + \".\" + name);\n                }\n            }\n        } catch (Exception e) {\n            // This should never happen\n            LOGGER.error(\"Failed to extract #includeMacros targets from provided content [\" + content + \"]\", e);\n\n            list = Collections.emptyList();\n        }\n\n        return list;\n    }\n\n    /**\n     * accessor for the isReadOnly instance var.\n     *\n     * @see #isReadOnly\n     */\n    public boolean isReadOnly()\n    {\n        return this.isReadOnly;\n    }\n\n    public void setReadOnly(boolean readOnly)\n    {\n        this.isReadOnly = readOnly;\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteAllDocuments(doc, true, context);\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, boolean toTrash, XWikiContext context) throws XWikiException\n    {\n        // Wrap the work as a batch operation.\n        BatchOperationExecutor batchOperationExecutor = Utils.getComponent(BatchOperationExecutor.class);\n        batchOperationExecutor.execute(() -> {\n            // Delete all translation documents\n            for (Locale locale : doc.getTranslationLocales(context)) {\n                XWikiDocument tdoc = doc.getTranslatedDocument(locale, context);\n                deleteDocument(tdoc, toTrash, context);\n            }\n\n            // Delete the default document\n            deleteDocument(doc, toTrash, context);\n        });\n    }\n\n    public void refreshLinks(XWikiContext context) throws XWikiException\n    {\n        try {\n            // refreshes all Links of each doc of the wiki\n            @SuppressWarnings(\"deprecation\")\n            List<String> docs = getStore().getQueryManager().getNamedQuery(\"getAllDocuments\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n            for (int i = 0; i < docs.size(); i++) {\n                XWikiDocument myDoc = this.getDocument(docs.get(i), context);\n                myDoc.getStore().saveLinks(myDoc, context, true);\n            }\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public boolean hasBacklinks(XWikiContext context)\n    {\n        if (this.hasBacklinks == null) {\n            this.hasBacklinks = \"1\".equals(getXWikiPreference(\"backlinks\", \"xwiki.backlinks\", \"0\", context));\n        }\n        return this.hasBacklinks;\n    }\n\n    public boolean hasTags(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"tags\", \"xwiki.tags\", \"0\", context));\n    }\n\n    public boolean hasCustomMappings()\n    {\n        return getHibernateConfiguration().hasCustomMappings();\n    }\n\n    public boolean hasDynamicCustomMappings()\n    {\n        return getHibernateConfiguration().hasDynamicCustomMappings();\n    }\n\n    public String getDefaultSpace(XWikiContext context)\n    {\n        String defaultSpace = getXWikiPreference(\"defaultweb\", \"\", context);\n        if (StringUtils.isEmpty(defaultSpace)) {\n            return getConfiguration().getProperty(\"xwiki.defaultweb\", DEFAULT_HOME_SPACE);\n        }\n        return defaultSpace;\n    }\n\n    public boolean showViewAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"showviewaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        } else if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.showviewaction\", \"1\"));\n    }\n\n    public boolean useDefaultAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"usedefaultaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.usedefaultaction\", \"0\"));\n    }\n\n    public String getDefaultPage(XWikiContext context)\n    {\n        String defaultPage = getXWikiPreference(\"defaultpage\", \"\", context);\n        if (StringUtils.isEmpty(defaultPage)) {\n            return getConfiguration().getProperty(\"xwiki.defaultpage\", DEFAULT_SPACE_HOMEPAGE);\n        }\n        return defaultPage;\n    }\n\n    public boolean hasEditComment(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment\", \"0\"));\n    }\n\n    public boolean isEditCommentFieldHidden(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_hidden\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.hidden\", \"0\"));\n    }\n\n    public boolean isEditCommentSuggested(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_suggested\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.suggested\", \"0\"));\n    }\n\n    public boolean isEditCommentMandatory(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_mandatory\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.mandatory\", \"0\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasMinorEdit()\n     */\n    public boolean hasMinorEdit(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"minoredit\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.minoredit\", \"1\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasRecycleBin()\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isRecycleBinEnabled();\n    }\n\n    /**\n     * Indicates whether deleted attachments are stored in a recycle bin or not. This can be configured using the key\n     * <var>storage.attachment.recyclebin</var>.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasAttachmentRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentRecycleBinEnabled();\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public BaseClass getXClass(DocumentReference documentReference, XWikiContext context) throws XWikiException\n    {\n        // Used to avoid recursive loading of documents if there are recursives usage of classes\n        BaseClass bclass = context.getBaseClass(documentReference);\n        if (bclass != null) {\n            return bclass;\n        }\n\n        return getDocument(documentReference, context).getXClass();\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #getXClass(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public BaseClass getClass(String fullName, XWikiContext context) throws XWikiException\n    {\n        DocumentReference reference = null;\n        if (StringUtils.isNotEmpty(fullName)) {\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        }\n        return getXClass(reference, context);\n    }\n\n    public String getEditorPreference(XWikiContext context)\n    {\n        String defaultSyntaxContentEditor = getEditConfiguration().getDefaultEditor(SyntaxContent.class);\n\n        return defaultSyntaxContentEditor == null ? \"\" : defaultSyntaxContentEditor.toLowerCase();\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String. Note that Groovy scripts\n     * compilation is cached.\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, XWikiContext xcontext) throws XWikiException\n    {\n        return getParseGroovyFromString().parseGroovyFromString(script, xcontext);\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String, using a classloader including all\n     * JAR files located in the passed page as attachments. Note that Groovy scripts compilation is cached\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, String jarWikiPage, XWikiContext xcontext) throws XWikiException\n    {\n        XWikiPageClassLoader pcl = new XWikiPageClassLoader(jarWikiPage, xcontext);\n        Object prevParentClassLoader = xcontext.get(\"parentclassloader\");\n        try {\n            xcontext.put(\"parentclassloader\", pcl);\n\n            return parseGroovyFromString(script, xcontext);\n        } finally {\n            if (prevParentClassLoader == null) {\n                xcontext.remove(\"parentclassloader\");\n            } else {\n                xcontext.put(\"parentclassloader\", prevParentClassLoader);\n            }\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, String jarWikiPage, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), jarWikiPage, context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public String getMacroList(XWikiContext context)\n    {\n        String macrosmapping = \"\";\n        XWiki xwiki = context.getWiki();\n\n        try {\n            macrosmapping = getResourceContent(MACROS_FILE);\n        } catch (IOException e) {\n        }\n\n        macrosmapping += \"\\r\\n\" + xwiki.getXWikiPreference(\"macros_mapping\", \"\", context);\n\n        return macrosmapping;\n    }\n\n    // This functions adds an object from an new object creation form\n    public BaseObject getObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        Map<String, String[]> map = Util.getObject(context.getRequest(), className);\n        BaseClass bclass = context.getWiki().getClass(className, context);\n        BaseObject newobject = (BaseObject) bclass.fromMap(map, context);\n\n        return newobject;\n    }\n\n    public String getConvertingUserNameType(XWikiContext context)\n    {\n        if (StringUtils.isNotBlank(context.getWiki().getXWikiPreference(\"convertmail\", context))) {\n            return context.getWiki().getXWikiPreference(\"convertmail\", \"0\", context);\n        }\n\n        return getConfiguration().getProperty(\"xwiki.authentication.convertemail\", \"0\");\n    }\n\n    public String convertUsername(String username, XWikiContext context)\n    {\n        if (username == null) {\n            return null;\n        }\n\n        if (getConvertingUserNameType(context).equals(\"1\") && (username.indexOf('@') != -1)) {\n            String id = \"\" + username.hashCode();\n            id = id.replace(\"-\", \"\");\n            if (username.length() > 1) {\n                int i1 = username.indexOf('@');\n                id = \"\" + username.charAt(0) + username.substring(i1 + 1, i1 + 2)\n                    + username.charAt(username.length() - 1) + id;\n            }\n\n            return id;\n        } else if (getConvertingUserNameType(context).equals(\"2\")) {\n            return username.replaceAll(\"[\\\\.\\\\@]\", \"_\");\n        } else {\n            return username;\n        }\n    }\n\n    public boolean hasSectionEdit(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.section.edit\", 0) == 1;\n    }\n\n    /**\n     * @return The maximum section depth for which section editing is available. This can be customized through the\n     *         {@code xwiki.section.depth} configuration property. Defaults to 2 when not defined.\n     */\n    public long getSectionEditingDepth()\n    {\n        return getConfiguration().getProperty(\"xwiki.section.depth\", 2L);\n    }\n\n    public String getWysiwygToolbars(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.wysiwyg.toolbars\", \"\");\n    }\n\n    public String clearName(String name, XWikiContext context)\n    {\n        return clearName(name, true, true, context);\n    }\n\n    public String clearName(String name, boolean stripDots, boolean ascii, XWikiContext context)\n    {\n        String temp = name;\n        temp = temp.replaceAll(\n            \"[\\u00c0\\u00c1\\u00c2\\u00c3\\u00c4\\u00c5\\u0100\\u0102\\u0104\\u01cd\\u01de\\u01e0\\u01fa\\u0200\\u0202\\u0226]\", \"A\");\n        temp = temp.replaceAll(\n            \"[\\u00e0\\u00e1\\u00e2\\u00e3\\u00e4\\u00e5\\u0101\\u0103\\u0105\\u01ce\\u01df\\u01e1\\u01fb\\u0201\\u0203\\u0227]\", \"a\");\n        temp = temp.replaceAll(\"[\\u00c6\\u01e2\\u01fc]\", \"AE\");\n        temp = temp.replaceAll(\"[\\u00e6\\u01e3\\u01fd]\", \"ae\");\n        temp = temp.replaceAll(\"[\\u008c\\u0152]\", \"OE\");\n        temp = temp.replaceAll(\"[\\u009c\\u0153]\", \"oe\");\n        temp = temp.replaceAll(\"[\\u00c7\\u0106\\u0108\\u010a\\u010c]\", \"C\");\n        temp = temp.replaceAll(\"[\\u00e7\\u0107\\u0109\\u010b\\u010d]\", \"c\");\n        temp = temp.replaceAll(\"[\\u00d0\\u010e\\u0110]\", \"D\");\n        temp = temp.replaceAll(\"[\\u00f0\\u010f\\u0111]\", \"d\");\n        temp = temp.replaceAll(\"[\\u00c8\\u00c9\\u00ca\\u00cb\\u0112\\u0114\\u0116\\u0118\\u011a\\u0204\\u0206\\u0228]\", \"E\");\n        temp = temp.replaceAll(\"[\\u00e8\\u00e9\\u00ea\\u00eb\\u0113\\u0115\\u0117\\u0119\\u011b\\u01dd\\u0205\\u0207\\u0229]\", \"e\");\n        temp = temp.replaceAll(\"[\\u011c\\u011e\\u0120\\u0122\\u01e4\\u01e6\\u01f4]\", \"G\");\n        temp = temp.replaceAll(\"[\\u011d\\u011f\\u0121\\u0123\\u01e5\\u01e7\\u01f5]\", \"g\");\n        temp = temp.replaceAll(\"[\\u0124\\u0126\\u021e]\", \"H\");\n        temp = temp.replaceAll(\"[\\u0125\\u0127\\u021f]\", \"h\");\n        temp = temp.replaceAll(\"[\\u00cc\\u00cd\\u00ce\\u00cf\\u0128\\u012a\\u012c\\u012e\\u0130\\u01cf\\u0208\\u020a]\", \"I\");\n        temp = temp.replaceAll(\"[\\u00ec\\u00ed\\u00ee\\u00ef\\u0129\\u012b\\u012d\\u012f\\u0131\\u01d0\\u0209\\u020b]\", \"i\");\n        temp = temp.replaceAll(\"[\\u0132]\", \"IJ\");\n        temp = temp.replaceAll(\"[\\u0133]\", \"ij\");\n        temp = temp.replaceAll(\"[\\u0134]\", \"J\");\n        temp = temp.replaceAll(\"[\\u0135]\", \"j\");\n        temp = temp.replaceAll(\"[\\u0136\\u01e8]\", \"K\");\n        temp = temp.replaceAll(\"[\\u0137\\u0138\\u01e9]\", \"k\");\n        temp = temp.replaceAll(\"[\\u0139\\u013b\\u013d\\u013f\\u0141]\", \"L\");\n        temp = temp.replaceAll(\"[\\u013a\\u013c\\u013e\\u0140\\u0142\\u0234]\", \"l\");\n        temp = temp.replaceAll(\"[\\u00d1\\u0143\\u0145\\u0147\\u014a\\u01f8]\", \"N\");\n        temp = temp.replaceAll(\"[\\u00f1\\u0144\\u0146\\u0148\\u0149\\u014b\\u01f9\\u0235]\", \"n\");\n        temp = temp.replaceAll(\n            \"[\\u00d2\\u00d3\\u00d4\\u00d5\\u00d6\\u00d8\\u014c\\u014e\\u0150\\u01d1\\u01ea\\u01ec\\u01fe\\u020c\\u020e\\u022a\\u022c\"\n                + \"\\u022e\\u0230]\",\n            \"O\");\n        temp = temp.replaceAll(\n            \"[\\u00f2\\u00f3\\u00f4\\u00f5\\u00f6\\u00f8\\u014d\\u014f\\u0151\\u01d2\\u01eb\\u01ed\\u01ff\\u020d\\u020f\\u022b\\u022d\"\n                + \"\\u022f\\u0231]\",\n            \"o\");\n        temp = temp.replaceAll(\"[\\u0156\\u0158\\u0210\\u0212]\", \"R\");\n        temp = temp.replaceAll(\"[\\u0157\\u0159\\u0211\\u0213]\", \"r\");\n        temp = temp.replaceAll(\"[\\u015a\\u015c\\u015e\\u0160\\u0218]\", \"S\");\n        temp = temp.replaceAll(\"[\\u015b\\u015d\\u015f\\u0161\\u0219]\", \"s\");\n        temp = temp.replaceAll(\"[\\u00de\\u0162\\u0164\\u0166\\u021a]\", \"T\");\n        temp = temp.replaceAll(\"[\\u00fe\\u0163\\u0165\\u0167\\u021b\\u0236]\", \"t\");\n        temp = temp.replaceAll(\n            \"[\\u00d9\\u00da\\u00db\\u00dc\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u0214\\u0216]\",\n            \"U\");\n        temp = temp.replaceAll(\n            \"[\\u00f9\\u00fa\\u00fb\\u00fc\\u0169\\u016b\\u016d\\u016f\\u0171\\u0173\\u01d4\\u01d6\\u01d8\\u01da\\u01dc\\u0215\\u0217]\",\n            \"u\");\n        temp = temp.replaceAll(\"[\\u0174]\", \"W\");\n        temp = temp.replaceAll(\"[\\u0175]\", \"w\");\n        temp = temp.replaceAll(\"[\\u00dd\\u0176\\u0178\\u0232]\", \"Y\");\n        temp = temp.replaceAll(\"[\\u00fd\\u00ff\\u0177\\u0233]\", \"y\");\n        temp = temp.replaceAll(\"[\\u0179\\u017b\\u017d]\", \"Z\");\n        temp = temp.replaceAll(\"[\\u017a\\u017c\\u017e]\", \"z\");\n        temp = temp.replaceAll(\"[\\u00df]\", \"SS\");\n        temp = temp.replaceAll(\"[_':,;\\\\\\\\/]\", \" \");\n        name = temp;\n        name = name.replaceAll(\"\\\\s+\", \"\");\n        name = name.replaceAll(\"[\\\\(\\\\)]\", \" \");\n\n        if (stripDots) {\n            name = name.replaceAll(\"[\\\\.]\", \"\");\n        }\n\n        if (ascii) {\n            name = name.replaceAll(\"[^a-zA-Z0-9\\\\-_\\\\.]\", \"\");\n        }\n\n        if (name.length() > 250) {\n            name = name.substring(0, 250);\n        }\n\n        return name;\n\n    }\n\n    public String getUniquePageName(String space, XWikiContext context)\n    {\n        String pageName = generateRandomString(16);\n\n        return getUniquePageName(space, pageName, context);\n    }\n\n    public String getUniquePageName(String space, String name, XWikiContext context)\n    {\n        String pageName = clearName(name, context);\n        if (exists(space + \".\" + pageName, context)) {\n            int i = 0;\n            while (exists(space + \".\" + pageName + \"_\" + i, context)) {\n                i++;\n            }\n\n            return pageName + \"_\" + i;\n        }\n\n        return pageName;\n    }\n\n    public PropertyClass getPropertyClassFromName(String propPath, XWikiContext context)\n    {\n        int i1 = propPath.indexOf('_');\n        if (i1 == -1) {\n            return null;\n        } else {\n            String className = propPath.substring(0, i1);\n            String propName = propPath.substring(i1 + 1);\n            try {\n                return (PropertyClass) getDocument(className, context).getXClass().get(propName);\n            } catch (XWikiException e) {\n                return null;\n            }\n        }\n    }\n\n    public boolean validateDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        return doc.validate(context);\n    }\n\n    public String addTooltip(String html, String message, String params, XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<span class=\\\"tooltip_span\\\" onmouseover=\\\"\");\n        buffer.append(params);\n        buffer.append(\"; return escape('\");\n        buffer.append(message.replaceAll(\"'\", \"\\\\'\"));\n        buffer.append(\"');\\\">\");\n        buffer.append(html);\n        buffer.append(\"</span>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltipJS(XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<script src=\\\"\");\n        buffer.append(getSkinFile(\"ajax/wzToolTip.js\", context));\n        buffer.append(\"\\\"></script>\");\n        // buffer.append(\"<div id=\\\"dhtmltooltip\\\"></div>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltip(String html, String message, XWikiContext context)\n    {\n        return addTooltip(html, message, \"this.WIDTH='300'\", context);\n    }\n\n    public String addMandatory(XWikiContext context)\n    {\n        String star =\n            \"<span class=\\\"mandatoryParenthesis\\\">&nbsp;(</span><span class=\\\"mandatoryDot\\\">&lowast;</span><span class=\\\"mandatoryParenthesis\\\">)&nbsp;</span>\";\n        return context.getWiki().getXWikiPreference(\"mandatory_display\", star, context);\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public boolean hasVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isVersioningEnabled();\n    }\n\n    public boolean hasAttachmentVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentVersioningEnabled();\n    }\n\n    public String getExternalAttachmentURL(String fullName, String filename, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullName, context);\n\n        return doc.getExternalAttachmentURL(filename, \"download\", context);\n    }\n\n    public int getMaxRecursiveSpaceChecks(XWikiContext context)\n    {\n        int max = getXWikiPreferenceAsInt(\"rights_maxrecursivespacechecks\", -1, context);\n        if (max == -1) {\n            return getConfiguration().getProperty(\"xwiki.rights.maxrecursivespacechecks\", 0);\n        } else {\n            return max;\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     */\n    public void restoreFromRecycleBin(final XWikiDocument doc, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        if (deletedDocuments != null && deletedDocuments.length > 0) {\n            long index = deletedDocuments[0].getId();\n            restoreFromRecycleBin(doc, index, comment, context);\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     * @deprecated since 9.4RC1. Use {@link #restoreFromRecycleBin(long, String, XWikiContext)} instead.\n     */\n    @Deprecated\n    public void restoreFromRecycleBin(final XWikiDocument doc, long index, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        restoreFromRecycleBin(index, comment, context);\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 9.4RC1\n     */\n    public void restoreFromRecycleBin(long index, String comment, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument newdoc = getRecycleBinStore().restoreFromRecycleBin(index, context, true);\n        saveDocument(newdoc, comment, context);\n        getRecycleBinStore().deleteFromRecycleBin(index, context, true);\n    }\n\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, XWikiContext context) throws XWikiException\n    {\n        return rollback(tdoc, rev, true, context);\n    }\n\n    private void restoreDeletedAttachment(XWikiAttachment rolledbackAttachment, XWikiContext context)\n        throws XWikiException\n    {\n        // Restore deleted attachments from the trash\n        if (getAttachmentRecycleBinStore() != null) {\n            // There might be multiple versions of the attachment in the trash, search for the right one\n            List<DeletedAttachment> deletedVariants =\n                getAttachmentRecycleBinStore().getAllDeletedAttachments(rolledbackAttachment, context, true);\n\n            DeletedAttachment correctVariant = null;\n            for (DeletedAttachment variant : deletedVariants) { // Reverse chronological order\n                if (variant.getDate().before(rolledbackAttachment.getDate())) {\n                    break;\n                }\n\n                correctVariant = variant;\n            }\n\n            if (correctVariant != null) {\n                XWikiAttachment restoredAttachment = correctVariant.restoreAttachment();\n\n                boolean updateArchive = false;\n\n                if (!restoredAttachment.getVersion().equals(rolledbackAttachment.getVersion())) {\n                    XWikiAttachment restoredAttachmentRevision =\n                        restoredAttachment.getAttachmentRevision(rolledbackAttachment.getVersion(), context);\n\n                    if (restoredAttachmentRevision != null) {\n                        // Update the archive since it won't be done by the store (it's a new attachment)\n                        // TODO: Remove from the archive the versions greater than the rollbacked one instead (they\n                        // would not be lost since they would still be in the recycle bin) ?\n                        rolledbackAttachment.setVersion(restoredAttachment.getVersion());\n                        updateArchive = true;\n\n                        restoredAttachment = restoredAttachmentRevision;\n                    }\n                }\n\n                rolledbackAttachment.apply(restoredAttachment);\n\n                // Restore the deleted archive\n                rolledbackAttachment\n                    .setAttachment_archive((XWikiAttachmentArchive) restoredAttachment.getAttachment_archive().clone());\n                rolledbackAttachment.getAttachment_archive().setAttachment(rolledbackAttachment);\n\n                if (updateArchive) {\n                    rolledbackAttachment.updateContentArchive(context);\n                }\n            } else {\n                // Not found in the trash, set an empty content to avoid errors\n                try {\n                    rolledbackAttachment.setContent(new ByteArrayInputStream(new byte[0]));\n                } catch (IOException e) {\n                    // The content we pass cannot fail\n                }\n            }\n        }\n    }\n\n    /**\n     * @param tdoc the document to rollback\n     * @param rev the revision to rollback to\n     * @param addRevision true if a new revision should be created\n     * @param xcontext the XWiki context\n     * @return the new document\n     * @throws XWikiException when failing to rollback the document\n     * @since 10.7RC1\n     * @since 9.11.8\n     */\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, boolean addRevision, XWikiContext xcontext)\n        throws XWikiException\n    {\n        LOGGER.debug(\"Rolling back [{}] to version [{}]\", tdoc, rev);\n\n        // Clone the document before modifying to avoid concurrency issues\n        XWikiDocument document = tdoc.clone();\n\n        XWikiDocument rolledbackDoc = getDocumentRevisionProvider().getRevision(tdoc, rev);\n\n        // Restore attachments\n        if (\"1\".equals(getConfiguration().getProperty(\"xwiki.store.rollbackattachmentwithdocuments\", \"1\"))) {\n            LOGGER.debug(\"Checking attachments\");\n\n            for (XWikiAttachment rolledbackAttachment : rolledbackDoc.getAttachmentList()) {\n                String filename = rolledbackAttachment.getFilename();\n                XWikiAttachment attachment = document.getAttachment(filename);\n\n                if (attachment == null) {\n                    // The attachment has been deleted, search and restore it\n                    LOGGER.debug(\"Deleted attachment: [{}]\", filename);\n\n                    // Restore content and archive from the recycle bin\n                    restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                } else {\n                    XWikiAttachment attachmentRevision =\n                        attachment.getAttachmentRevision(rolledbackAttachment.getVersion(), xcontext);\n\n                    // We compare the number of milliseconds instead of the date objects directly because Hibernate can\n                    // return java.sql.Timestamp for date fields and the JavaDoc says that Timestamp.equals(Object)\n                    // doesn't return true if the passed value is a java.util.Date object with the same number of\n                    // milliseconds because the nanoseconds component of the passed date is unknown.\n                    if (attachmentRevision == null\n                        || attachmentRevision.getDate().getTime() != rolledbackAttachment.getDate().getTime()) {\n                        // Recreated attachment\n                        LOGGER.debug(\"Recreated attachment: [{}]\", filename);\n\n                        // Mark current attachment for deletion to not loose it\n                        document.removeAttachment(attachment);\n\n                        // Search and restore previously deleted one\n                        // If the attachment trash is not available, don't lose the existing attachment\n                        if (getAttachmentRecycleBinStore() != null) {\n                            // Restore in the right version\n                            restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                        }\n                    } else {\n                        // Restore content and archive from the recycle bin\n                        rolledbackAttachment.apply(attachmentRevision);\n                    }\n                }\n            }\n        }\n\n        document.apply(rolledbackDoc);\n\n        // Prepare the XWikiDocument before save\n        document.setAuthorReference(xcontext.getUserReference());\n        document.setContentAuthorReference(xcontext.getUserReference());\n\n        // Make sure the history is not modified if addRevision is disabled\n        String message;\n        if (!addRevision) {\n            document.setVersion(rev);\n            document.setMetaDataDirty(false);\n            document.setContentDirty(false);\n            message = document.getComment();\n        } else {\n            // Make sure to save a new version even if nothing changed\n            document.setMetaDataDirty(true);\n            message = localizePlainOrKey(\"core.comment.rollback\", rev);\n        }\n\n        ObservationManager om = getObservationManager();\n        if (om != null) {\n            // Notify listeners about the document that is going to be rolled back.\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            om.notify(new DocumentRollingBackEvent(document.getDocumentReference(), rev), document, xcontext);\n        }\n\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        saveDocument(document, message, xcontext);\n\n        // Since XWiki#saveDocument resets the original document, we need to temporarily put it back to send\n        // notifications.\n        XWikiDocument newOriginalDocument = document.getOriginalDocument();\n        document.setOriginalDocument(originalDocument);\n\n        try {\n            if (om != null) {\n                // Notify listeners about the document that was rolled back.\n                // Note that for the moment the event being send is a bridge event, as we are still passing around an\n                // XWikiDocument as source and an XWikiContext as data.\n                om.notify(new DocumentRolledBackEvent(document.getDocumentReference(), rev), document, xcontext);\n            }\n        } finally {\n            document.setOriginalDocument(newOriginalDocument);\n        }\n\n        return document;\n    }\n\n    /**\n     * @return the ids of configured syntaxes for this wiki (e.g. {@code xwiki/2.0}, {@code xwiki/2.1},\n     *         {@code mediawiki/1.0}, etc)\n     * @deprecated since 8.2M1, use the XWiki Rendering Configuration component or the Rendering Script Service one\n     *             instead\n     */\n    @Deprecated\n    public List<String> getConfiguredSyntaxes()\n    {\n        return this.configuredSyntaxes;\n    }\n\n    /**\n     * @return the syntax id of the syntax to use when creating new documents\n     */\n    public String getDefaultDocumentSyntax()\n    {\n        // TODO: Fix this method to return a Syntax object instead of a String\n        return getDefaultDocumentSyntaxInternal().toIdString();\n    }\n\n    /**\n     * @return the syntax to use when creating new documents\n     */\n    private Syntax getDefaultDocumentSyntaxInternal()\n    {\n        return Utils.getComponent(CoreConfiguration.class).getDefaultDocumentSyntax();\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @param defaultSyntaxId the default value to return if no document can be found\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(String defaultSyntaxId, XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            syntaxId = defaultSyntaxId;\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            throw new RuntimeException(\"Cannot get the current syntax since there's no current document set\");\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    private String getCurrentContentSyntaxIdInternal(XWikiContext context)\n    {\n        Syntax syntax = getCurrentContentSyntaxInternal(context);\n\n        return syntax != null ? syntax.toIdString() : null;\n    }\n\n    /**\n     * Get the syntax of the code currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax\n     */\n    private Syntax getCurrentContentSyntaxInternal(XWikiContext context)\n    {\n        Syntax syntax = null;\n\n        // Try to find the current syntax\n        if (getRenderingContext() != null) {\n            Block curentBlock = getRenderingContext().getCurrentBlock();\n\n            if (curentBlock != null) {\n                MetaDataBlock metaDataBlock =\n                    curentBlock.getFirstBlock(new MetadataBlockMatcher(MetaData.SYNTAX), Axes.ANCESTOR_OR_SELF);\n\n                if (metaDataBlock != null) {\n                    return (Syntax) metaDataBlock.getMetaData().getMetaData(MetaData.SYNTAX);\n                }\n            }\n        }\n\n        // Fallback on secure and current document in the context\n        if (context.get(\"sdoc\") != null) {\n            // The content document\n            syntax = ((XWikiDocument) context.get(\"sdoc\")).getSyntax();\n        } else if (context.getDoc() != null) {\n            // The context document\n            syntax = context.getDoc().getSyntax();\n        }\n\n        return syntax;\n    }\n\n    /**\n     * @return true if title handling should be using the compatibility mode or not. When the compatibility mode is\n     *         active, if the document's content first header (level 1 or level 2) matches the document's title the\n     *         first header is stripped.\n     */\n    public boolean isTitleInCompatibilityMode()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.title.compatibility\", \"0\"));\n    }\n\n    @Override\n    public void onEvent(Event event, Object source, Object data)\n    {\n        if (event instanceof WikiDeletedEvent) {\n            // A wiki has been deleted\n            onWikiDeletedEvent((WikiDeletedEvent) event);\n        } else if (event instanceof ComponentDescriptorAddedEvent) {\n            // A new mandatory document initializer has been installed\n            onMandatoryDocumentInitializerAdded((ComponentDescriptorAddedEvent) event, (ComponentManager) source);\n        } else {\n            // Document modifications\n\n            XWikiDocument doc = (XWikiDocument) source;\n\n            if (event instanceof XObjectPropertyEvent) {\n                EntityReference reference = ((XObjectPropertyEvent) event).getReference();\n                String modifiedProperty = reference.getName();\n                if (\"backlinks\".equals(modifiedProperty)) {\n                    this.hasBacklinks = doc.getXObject((ObjectReference) reference.getParent()).getIntValue(\"backlinks\",\n                        getConfiguration().getProperty(\"xwiki.backlinks\", 0)) == 1;\n                }\n            }\n        }\n    }\n\n    private void onWikiDeletedEvent(WikiDeletedEvent event)\n    {\n        this.initializedWikis.remove(event.getWikiId());\n    }\n\n    private void onMandatoryDocumentInitializerAdded(ComponentDescriptorAddedEvent event,\n        ComponentManager componentManager)\n    {\n        String namespace;\n        if (componentManager instanceof NamespacedComponentManager) {\n            namespace = ((NamespacedComponentManager) componentManager).getNamespace();\n        } else {\n            namespace = null;\n        }\n\n        MandatoryDocumentInitializer initializer;\n        try {\n            initializer = componentManager.getInstance(MandatoryDocumentInitializer.class, event.getRoleHint());\n\n            XWikiContext context = getXWikiContext();\n            if (namespace == null) {\n                // Initialize in main wiki\n                initializeMandatoryDocument(context.getMainXWiki(), initializer, context);\n                // Initialize in already initialized sub wikis (will be initialized in others when they are initialized)\n                for (String wiki : this.initializedWikis.keySet()) {\n                    initializeMandatoryDocument(wiki, initializer, context);\n                }\n            } else if (namespace.startsWith(\"wiki:\")) {\n                // Initialize in the wiki where the extension is installed\n                initializeMandatoryDocument(namespace.substring(\"wiki:\".length()), initializer, context);\n            }\n        } catch (ComponentLookupException e) {\n            LOGGER.error(\"Failed to lookup mandatory document initializer\", e);\n        }\n    }\n\n    /**\n     * The reference to match properties \"plugins\" and \"backlinks\" of class XWiki.XWikiPreference on whatever wiki.\n     */\n    private static final RegexEntityReference XWIKIPREFERENCE_PROPERTY_REFERENCE =\n        XWikiPreferencesDocumentInitializer.OBJECT_REFERENCE;\n\n    private static final List<Event> LISTENER_EVENTS =\n        Arrays.<Event>asList(new XObjectPropertyAddedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyDeletedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyUpdatedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE), new WikiDeletedEvent(),\n            new ComponentDescriptorAddedEvent(MandatoryDocumentInitializer.class));\n\n    @Override\n    public List<Event> getEvents()\n    {\n        return LISTENER_EVENTS;\n    }\n\n    @Override\n    public String getName()\n    {\n        return \"xwiki-core\";\n    }\n\n    /**\n     * Return the document reference to the wiki preferences.\n     *\n     * @param context see {@link XWikiContext}\n     * @since 4.3M2\n     */\n    private DocumentReference getPreferencesDocumentReference(XWikiContext context)\n    {\n        String database = context.getWikiId();\n        EntityReference spaceReference;\n        if (database != null) {\n            spaceReference = new EntityReference(SYSTEM_SPACE, EntityType.SPACE, new WikiReference(database));\n        } else {\n            spaceReference = getCurrentMixedEntityReferenceResolver().resolve(SYSTEM_SPACE, EntityType.SPACE);\n        }\n        return new DocumentReference(\"XWikiPreferences\", new SpaceReference(spaceReference));\n    }\n\n    /**\n     * Search attachments by passing HQL where clause values as parameters. You can specify properties of the \"attach\"\n     * (the attachment) or \"doc\" (the document it is attached to)\n     *\n     * @param parametrizedSqlClause The HQL where clause. For example {@code where doc.fullName\n     *        <> ?1 and (attach.author = ?2 or (attach.filename = ?3 and doc.space = ?4))}\n     * @param checkRight if true, only return attachments in documents which the \"current user\" has permission to view.\n     * @param nb The number of rows to return. If 0 then all rows are returned\n     * @param start The number of rows to skip at the beginning.\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return A List of {@link XWikiAttachment} objects.\n     * @throws XWikiException in case of error while performing the query\n     * @see com.xpn.xwiki.store.XWikiStoreInterface#searchDocuments(String, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     * @deprecated since 9.7RC1, use the QueryManager instead along with the \"attachment\" query filter\n     */\n    @Deprecated\n    public List<XWikiAttachment> searchAttachments(String parametrizedSqlClause, boolean checkRight, int nb, int start,\n        List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        // Get the attachment filenames and document fullNames\n        List<java.lang.Object[]> results = this.getStore().search(\n            \"select attach.filename, doc.fullName from XWikiAttachment attach, XWikiDocument doc where doc.id = attach.docId and \"\n                + parametrizedSqlClause,\n            nb, start, parameterValues, context);\n\n        HashMap<String, List<String>> filenamesByDocFullName = new HashMap<>();\n\n        // Put each attachment name with the document name it belongs to\n        for (int i = 0; i < results.size(); i++) {\n            String filename = (String) results.get(i)[0];\n            String docFullName = (String) results.get(i)[1];\n            if (!filenamesByDocFullName.containsKey(docFullName)) {\n                filenamesByDocFullName.put(docFullName, new ArrayList<String>());\n            }\n            filenamesByDocFullName.get(docFullName).add(filename);\n        }\n\n        List<XWikiAttachment> out = new ArrayList<>();\n\n        // Index through the document names, get relivent attachments\n        for (Map.Entry<String, List<String>> entry : filenamesByDocFullName.entrySet()) {\n            String fullName = entry.getKey();\n\n            XWikiDocument doc = getDocument(fullName, context);\n            if (checkRight) {\n                if (!context.getWiki().getRightService().hasAccessLevel(\"view\", context.getUser(), doc.getFullName(),\n                    context)) {\n                    continue;\n                }\n            }\n            List<String> returnedAttachmentNames = entry.getValue();\n            for (XWikiAttachment attach : doc.getAttachmentList()) {\n                if (returnedAttachmentNames.contains(attach.getFilename())) {\n                    out.add(attach);\n                }\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Count attachments returned by a given parameterized query\n     *\n     * @param parametrizedSqlClause Everything which would follow the \"WHERE\" in HQL\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return int number of attachments found.\n     * @throws XWikiException in event of an exception querying the database\n     * @see #searchAttachments(String, boolean, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     */\n    public int countAttachments(String parametrizedSqlClause, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        List l = getStore().search(\"select count(attach) from XWikiAttachment attach, XWikiDocument doc where \"\n            + \"attach.docId=doc.id and \" + parametrizedSqlClause, 0, 0, parameterValues, context);\n        return ((Number) l.get(0)).intValue();\n    }\n\n    // Deprecated\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#getConfigPath()} instead\n     */\n    @Deprecated\n    public static String getConfigPath() throws NamingException\n    {\n        return XWikiCfgConfigurationSource.getConfigPath();\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context) throws XWikiException\n    {\n        this(config, context, null, false);\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(config, context, engine_context, noupdate);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context) throws XWikiException\n    {\n        this(xwikicfgpath, context, null, false);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        try {\n            initXWiki(new XWikiConfig(new FileInputStream(xwikicfgpath)), context, engine_context, noupdate);\n        } catch (FileNotFoundException e) {\n            Object[] args = { xwikicfgpath };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CONFIG, XWikiException.ERROR_XWIKI_CONFIG_FILENOTFOUND,\n                \"Configuration file {0} not found\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(InputStream is, XWikiContext context, XWikiEngineContext engine_context) throws XWikiException\n    {\n        initXWiki(new XWikiConfig(is), context, engine_context, true);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public XWikiConfig getConfig()\n    {\n        return new XWikiConfigDelegate(getConfiguration());\n    }\n\n    /**\n     * @deprecated since 6.1M2\n     */\n    @Deprecated\n    public void setConfig(XWikiConfig config)\n    {\n        ConfigurationSource configuration = getConfiguration();\n\n        if (configuration instanceof XWikiCfgConfigurationSource) {\n            ((XWikiCfgConfigurationSource) configuration).set(config);\n        }\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key)\n    {\n        return Param(key, null);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key, String default_value)\n    {\n        if (getConfiguration() != null) {\n            return getConfiguration().getProperty(key, default_value);\n        }\n\n        return default_value;\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key)\n    {\n        return getConfiguration().getProperty(key, long.class);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key, long default_value)\n    {\n        return getConfiguration().getProperty(key, default_value);\n    }\n\n    /**\n     * @return true if the wiki is in path based mode, fale otherwise\n     * @since 11.9RC1\n     */\n    public boolean isPathBased()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.virtual.usepath\", \"1\"));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.io.ByteArrayInputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.servlet.http.Cookie;\n\nimport org.apache.commons.collections4.IteratorUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentCreatingEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentDeletingEvent;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.query.QueryExecutor;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.wiki.WikiModel;\nimport org.xwiki.test.annotation.AfterComponent;\nimport org.xwiki.test.annotation.AllComponents;\nimport org.xwiki.test.junit5.mockito.InjectComponentManager;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.test.mockito.MockitoComponentManager;\n\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.XWikiCfgConfigurationSource;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.BaseProperty;\nimport com.xpn.xwiki.objects.StringProperty;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiServletRequest;\nimport com.xpn.xwiki.web.XWikiServletRequestStub;\nimport com.xpn.xwiki.web.XWikiServletResponseStub;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.notNull;\nimport static org.mockito.ArgumentMatchers.same;\nimport static org.mockito.Mockito.atLeastOnce;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link com.xpn.xwiki.XWiki}.\n *\n * @version $Id$\n */\n@OldcoreTest(mockXWiki = false)\n@AllComponents\npublic class XWikiTest\n{\n    @InjectMockitoOldcore\n    MockitoOldcore oldcore;\n\n    @MockComponent\n    private XWikiRecycleBinStoreInterface recycleBinStoreInterface;\n\n    private static final String DOCWIKI = \"Wiki\";\n\n    private static final String DOCSPACE = \"MilkyWay\";\n\n    private static final String DOCNAME = \"Fidis\";\n\n    private XWikiDocument document;\n\n    private XWiki xwiki;\n\n    @AfterComponent\n    public void afterComponent() throws Exception\n    {\n        MockitoComponentManager componentManager = this.oldcore.getMocker();\n\n        // Unregister XWikiCfgConfigurationSource so that it's mocked by MockitoOldcore\n        componentManager.unregisterComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);\n\n        // Mock the HQL query executor because we don't need it and it can cause problems\n        componentManager.registerMockComponent(QueryExecutor.class, \"hql\");\n\n        componentManager.unregisterComponent(new DefaultParameterizedType(null, Provider.class, ComponentManager.class)\n            , \"context\");\n        Provider<ComponentManager> componentManagerProvider = componentManager\n            .registerMockComponent(new DefaultParameterizedType(null, Provider.class, ComponentManager.class)\n                , \"context\");\n        when(componentManagerProvider.get()).thenReturn(componentManager);\n        componentManager.registerMockComponent(WikiModel.class);\n    }\n\n    @BeforeEach\n    protected void beforeEach() throws Exception\n    {\n        this.document = new XWikiDocument(new DocumentReference(\"Wiki\", \"MilkyWay\", \"Fidis\"));\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequestStub());\n        this.oldcore.getXWikiContext().setResponse(new XWikiServletResponseStub());\n        this.oldcore.getXWikiContext().setURL(new URL(\"http://localhost:8080/xwiki/bin/view/MilkyWay/Fidis\"));\n\n        this.oldcore.getXWikiContext().setLocale(null);\n\n        this.xwiki = this.oldcore.getSpyXWiki();\n\n        // Ensure that no Velocity Templates are going to be used when executing Velocity since otherwise\n        // the Velocity init would fail (since by default the macros.vm templates wouldn't be found as we're\n        // not providing it in our unit test resources).\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.render.velocity.macrolist\", \"\");\n\n        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());\n\n        this.document.setCreator(\"Condor\");\n        this.document.setAuthor(\"Albatross\");\n\n        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());\n        this.xwiki.setRecycleBinStore(this.recycleBinStoreInterface);\n        this.oldcore.getXWikiContext().put(\"isInRenderingEngine\", true);\n    }\n\n    @Test\n    public void testUserNotAddedByDefaultToXWikiAllGroupWhenThisGroupImplicit() throws Exception\n    {\n        // given\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.authentication.group.allgroupimplicit\", \"1\");\n\n        XWikiGroupServiceImpl xWikiGroupService = new XWikiGroupServiceImpl();\n        xwiki.setGroupService(xWikiGroupService);\n\n        XWiki spyXWiki = Mockito.spy(xwiki);\n\n        // when\n        spyXWiki.setUserDefaultGroup(\"XWiki.user1\", this.oldcore.getXWikiContext());\n\n        // then\n        Mockito.verify(spyXWiki, times(0)).addUserToGroup(anyString(), anyString(), any(XWikiContext.class));\n    }\n\n    @Test\n    public void testUserAddedToXWikiAllGroupWhenItsSpecifiedByConfigurationRegardlessXWikiAllGroupIsImplicit()\n        throws Exception\n    {\n        // given\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.authentication.group.allgroupimplicit\", \"1\");\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.users.initialGroups\", \"XWiki.XWikiAllGroup\");\n\n        XWikiGroupServiceImpl xWikiGroupService = new XWikiGroupServiceImpl();\n        xwiki.setGroupService(xWikiGroupService);\n\n        // when\n        this.xwiki.setUserDefaultGroup(\"XWiki.user1\", this.oldcore.getXWikiContext());\n\n        // then\n        verify(this.xwiki, times(1)).addUserToGroup(\"XWiki.user1\", \"XWiki.XWikiAllGroup\",\n            this.oldcore.getXWikiContext());\n    }\n\n    @Test\n    public void testAuthorAfterDocumentCopy() throws XWikiException\n    {\n        DocumentReference copyReference =\n            new DocumentReference(\"Lyre\", this.document.getDocumentReference().getLastSpaceReference());\n        DocumentReference author = this.document.getAuthorReference();\n        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());\n        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());\n\n        assertEquals(author, copy.getAuthorReference());\n    }\n\n    @Test\n    public void testCreatorAfterDocumentCopy() throws XWikiException\n    {\n        DocumentReference copyReference =\n            new DocumentReference(\"Sirius\", this.document.getDocumentReference().getLastSpaceReference());\n        DocumentReference creator = this.document.getCreatorReference();\n        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());\n        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());\n\n        assertEquals(creator, copy.getCreatorReference());\n    }\n\n    @Test\n    public void testCreationDateAfterDocumentCopy() throws XWikiException, InterruptedException\n    {\n        Date sourceCreationDate = this.document.getCreationDate();\n        Thread.sleep(1000);\n        DocumentReference copyReference = new DocumentReference(this.document.getDocumentReference().getName() + \"Copy\",\n            this.document.getDocumentReference().getLastSpaceReference());\n        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());\n        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());\n\n        assertTrue(copy.getCreationDate().equals(sourceCreationDate));\n    }\n\n    @Test\n    public void testParseTemplateConsidersObjectField() throws XWikiException\n    {\n        DocumentReference skinReference =\n            new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"XWikiSkins\");\n        XWikiDocument skinClass = new XWikiDocument(skinReference);\n        skinClass.getXClass().addTextAreaField(\"template.vm\", \"template\", 80, 20);\n        this.xwiki.saveDocument(skinClass, this.oldcore.getXWikiContext());\n\n        DocumentReference mySkinReference =\n            new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"Skin\");\n        XWikiDocument skinDocument = new XWikiDocument(mySkinReference);\n        BaseObject obj = skinDocument.newXObject(skinReference, this.oldcore.getXWikiContext());\n        obj.setLargeStringValue(\"template.vm\", \"parsing a field\");\n        this.xwiki.saveDocument(skinDocument, this.oldcore.getXWikiContext());\n\n        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");\n        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));\n        assertFalse(this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()).isNew());\n        assertEquals(skinDocument, this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()));\n        assertEquals(\"parsing a field\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * See XWIKI-2096\n     */\n    @Test\n    public void testParseTemplateConsidersAttachment() throws XWikiException\n    {\n        XWikiDocument skin =\n            new XWikiDocument(new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"Skin\"));\n        XWikiAttachment attachment = new XWikiAttachment();\n        skin.getAttachmentList().add(attachment);\n        attachment.setContent(\"parsing an attachment\".getBytes());\n        attachment.setFilename(\"template.vm\");\n        attachment.setDoc(skin);\n        this.xwiki.saveDocument(skin, this.oldcore.getXWikiContext());\n        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");\n\n        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));\n        assertFalse(this.xwiki.getDocument(\"XWiki.Skin\", this.oldcore.getXWikiContext()).isNew());\n        assertEquals(skin, this.xwiki.getDocument(\"XWiki.Skin\", this.oldcore.getXWikiContext()));\n        assertEquals(\"parsing an attachment\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * See XWIKI-2098\n     */\n    @Test\n    public void testParseTemplateConsidersObjectFieldBeforeAttachment() throws Exception\n    {\n        DocumentReference skinReference = new DocumentReference(\"xwiki\", \"XWiki\", \"XWikiSkins\");\n        XWikiDocument skinClass = new XWikiDocument(skinReference);\n        skinClass.getXClass().addTextAreaField(\"template.vm\", \"template\", 80, 20);\n        this.xwiki.saveDocument(skinClass, this.oldcore.getXWikiContext());\n\n        DocumentReference mySkinReference = new DocumentReference(\"xwiki\", \"XWiki\", \"Skin\");\n        XWikiDocument skinDocument = new XWikiDocument(mySkinReference);\n        BaseObject obj = skinDocument.newXObject(skinReference, this.oldcore.getXWikiContext());\n        obj.setLargeStringValue(\"template.vm\", \"parsing a field\");\n        XWikiAttachment attachment = new XWikiAttachment();\n        skinDocument.getAttachmentList().add(attachment);\n        attachment.setContent(new ByteArrayInputStream(\"parsing an attachment\".getBytes()));\n        attachment.setFilename(\"template.vm\");\n        attachment.setDoc(skinDocument);\n        this.xwiki.saveDocument(skinDocument, this.oldcore.getXWikiContext());\n        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");\n        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));\n        assertFalse(this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()).isNew());\n        assertEquals(skinDocument, this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()));\n        assertEquals(\"parsing a field\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testClearNameWithoutStripDotsWithoutAscii()\n    {\n        assertEquals(\"ee{&.txt\",\n            this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", false, false, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testClearNameWithoutStripDotsWithAscii()\n    {\n        assertEquals(\"ee.txt\", this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", false, true, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testClearNameWithStripDotsWithoutAscii()\n    {\n        assertEquals(\"ee{&txt\",\n            this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", true, false, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testClearNameWithStripDotsWithAscii()\n    {\n        assertEquals(\"eetxt\", this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", true, true, this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * We only verify here that the saveDocument API calls the Observation component.\n     */\n    @Test\n    public void testSaveDocumentSendsObservationEvents() throws Exception\n    {\n        EventListener mockListener = mock(EventListener.class);\n        when(mockListener.getName()).thenReturn(\"testlistener\");\n        DocumentReference ref = new DocumentReference(\"xwikitest\", \"Some\", \"Document\");\n        when(mockListener.getEvents())\n            .thenReturn(Arrays.asList(new DocumentCreatedEvent(ref), new DocumentCreatingEvent(ref)));\n\n        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);\n        om.addListener(mockListener);\n\n        verify(mockListener).getEvents();\n\n        XWikiDocument document = new XWikiDocument(ref);\n        document.setContent(\"the content\");\n\n        this.xwiki.saveDocument(document, this.oldcore.getXWikiContext());\n\n        // Ensure that the onEvent method has been called before and after the save\n        verify(mockListener).onEvent(any(DocumentCreatingEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n        verify(mockListener).onEvent(any(DocumentCreatedEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * We only verify here that the renameDocument API calls the Observation component.\n     */\n    @Test\n    public void testRenameDocumentSendsObservationEvents() throws Exception\n    {\n        DocumentReference sourceReference = new DocumentReference(\"xwikitest\", \"Some\", \"Source\");\n        DocumentReference targetReference = new DocumentReference(\"xwikitest\", \"Some\", \"Target\");\n\n        XWikiDocument sourceDocument = new XWikiDocument(sourceReference);\n        sourceDocument.setSyntax(Syntax.PLAIN_1_0);\n        this.xwiki.saveDocument(sourceDocument, this.oldcore.getXWikiContext());\n\n        EventListener mockListener = mock(EventListener.class);\n        when(mockListener.getName()).thenReturn(\"testlistener\");\n        when(mockListener.getEvents()).thenReturn(\n            Arrays.asList(new DocumentCreatedEvent(targetReference), new DocumentCreatingEvent(targetReference),\n                new DocumentDeletingEvent(sourceReference), new DocumentDeletedEvent(sourceReference)));\n\n        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);\n        om.addListener(mockListener);\n\n        verify(mockListener).getEvents();\n\n        this.xwiki.renameDocument(sourceReference, targetReference, false, Collections.emptyList(), null,\n            this.oldcore.getXWikiContext());\n\n        // Ensure that the onEvent method has been called before and after the rename\n        verify(mockListener).onEvent(any(DocumentCreatingEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n        verify(mockListener).onEvent(any(DocumentCreatedEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n        verify(mockListener).onEvent(any(DocumentDeletingEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n        verify(mockListener).onEvent(any(DocumentDeletedEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * We only verify here that the deleteDocument API calls the Observation component.\n     */\n    @Test\n    public void testDeleteDocumentSendsObservationEvents() throws Exception\n    {\n        EventListener mockListener = mock(EventListener.class);\n        when(mockListener.getName()).thenReturn(\"testlistener\");\n        DocumentReference ref = new DocumentReference(\"xwikitest\", \"Another\", \"Document\");\n        when(mockListener.getEvents())\n            .thenReturn(Arrays.asList(new DocumentDeletedEvent(ref), new DocumentDeletingEvent(ref)));\n\n        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);\n        om.addListener(mockListener);\n\n        verify(mockListener).getEvents();\n\n        XWikiDocument document = new XWikiDocument(ref);\n        document.setContent(\"the content\");\n\n        // Not expectation on mock Listener since we're not subscribed to Document save events\n\n        this.xwiki.saveDocument(document, this.oldcore.getXWikiContext());\n\n        this.xwiki.deleteDocument(document, false, this.oldcore.getXWikiContext());\n\n        // Ensure that the onEvent method has been called before and after the save\n        verify(mockListener).onEvent(any(DocumentDeletingEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n        verify(mockListener).onEvent(any(DocumentDeletedEvent.class), any(XWikiDocument.class),\n            same(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testLanguageSelection() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public Enumeration getLocales()\n            {\n                ArrayList<Locale> locales = new ArrayList<Locale>();\n                locales.add(new Locale(\"*\"));\n                locales.add(new Locale(\"en\", \"US\"));\n                locales.add(new Locale(\"fr\"));\n                locales.add(new Locale(\"de\"));\n                return IteratorUtils.asEnumeration(locales.iterator());\n            }\n\n            @Override\n            public String getHeader(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return null;\n                }\n                return \"en\";\n            }\n\n            @Override\n            public Cookie getCookie(String cookieName)\n            {\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        assertEquals(\"en\", this.xwiki.getLanguagePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testLanguageSelectionWithSupportedLanguages() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public Enumeration getLocales()\n            {\n                ArrayList<Locale> locales = new ArrayList<Locale>();\n                locales.add(new Locale(\"*\"));\n                locales.add(new Locale(\"fr\", \"FR\"));\n                locales.add(new Locale(\"de\"));\n                return IteratorUtils.asEnumeration(locales.iterator());\n            }\n\n            @Override\n            public String getHeader(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return null;\n                }\n                return \"en\";\n            }\n\n            @Override\n            public Cookie getCookie(String cookieName)\n            {\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languages\", \"en, |fr_FR, |en_US, |fr_CA\");\n\n        assertEquals(\"fr_FR\", this.xwiki.getLanguagePreference(this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * XWIKI-8469: Bad default of 1 in XWiki.isMultilingual instead of 0 (when no XWikiPreferences object exists)\n     */\n    @Test\n    public void testIsMultilingualDefaultFalse() throws Exception\n    {\n        assertFalse(this.xwiki.isMultiLingual(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetCurrentContentSyntaxId()\n    {\n        XWikiDocument doc1 = new XWikiDocument();\n        doc1.setSyntax(Syntax.CREOLE_1_0);\n        XWikiDocument doc2 = new XWikiDocument();\n        doc2.setSyntax(Syntax.PLAIN_1_0);\n\n        assertNull(this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));\n        assertEquals(\"syntaxId\", this.xwiki.getCurrentContentSyntaxId(\"syntaxId\", this.oldcore.getXWikiContext()));\n\n        this.oldcore.getXWikiContext().setDoc(doc1);\n\n        assertEquals(Syntax.CREOLE_1_0.toIdString(),\n            this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));\n\n        this.oldcore.getXWikiContext().put(\"sdoc\", doc2);\n\n        assertEquals(Syntax.PLAIN_1_0.toIdString(),\n            this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * Check that the user validation feature works when the validation key is stored both as plain text and as a hashed\n     * field.\n     *\n     * @throws Exception when any exception occurs inside XWiki\n     */\n    @Test\n    public void testValidationKeyStorage() throws Exception\n    {\n        XWikiContext context = this.oldcore.getXWikiContext();\n        context.setLanguage(\"en\");\n\n        // Prepare the request\n        XWikiRequest request = mock(XWikiRequest.class);\n        when(request.getParameter(\"xwikiname\")).thenReturn(\"TestUser\");\n        when(request.getParameter(\"validkey\")).thenReturn(\"plaintextkey\");\n        context.setRequest(request);\n\n        // Prepare the user profile\n        XWikiDocument testUser =\n            new XWikiDocument(new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"TestUser\"));\n        BaseObject userObject = (BaseObject) this.xwiki.getUserClass(context).newObject(context);\n\n        // Check with a correct plaintext key\n        BaseProperty validationKey = new StringProperty();\n        validationKey.setValue(\"plaintextkey\");\n        userObject.safeput(\"validkey\", validationKey);\n        testUser.addObject(\"XWiki.XWikiUsers\", userObject);\n\n        this.xwiki.saveDocument(testUser, context);\n\n        assertEquals(0, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));\n        XWikiDocument reloadedDocument = this.xwiki.getDocument(testUser, context);\n        assertEquals(\"\", reloadedDocument.getObject(\"XWiki.XWikiUsers\").getStringValue(\"validkey\"));\n\n        // Check with an incorrect plaintext key\n        validationKey.setValue(\"wrong key\");\n        this.xwiki.saveDocument(testUser, context);\n\n        assertEquals(-1, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));\n\n        // Check with a correct hashed key\n        validationKey = ((PropertyClass) this.xwiki.getUserClass(context).get(\"validkey\")).fromString(\"plaintextkey\");\n        assertTrue(validationKey.getValue().toString().startsWith(\"hash:\"));\n        userObject.safeput(\"validkey\", validationKey);\n        this.xwiki.saveDocument(testUser, context);\n\n        assertEquals(0, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));\n\n        // Check with an incorrect hashed key\n        validationKey = ((PropertyClass) this.xwiki.getUserClass(context).get(\"validkey\")).fromString(\"wrong key\");\n        assertTrue(validationKey.getValue().toString().startsWith(\"hash:\"));\n        userObject.safeput(\"validkey\", validationKey);\n        this.xwiki.saveDocument(testUser, context);\n\n        assertEquals(-1, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * Tests that XWiki.XWikiPreferences page is not saved each time XWiki is initialized.\n     *\n     * @throws Exception when any exception occurs inside XWiki\n     */\n    @Test\n    public void testGetPrefsClass() throws Exception\n    {\n        when(this.oldcore.getMockStore().getLimitSize(any(), any(), any())).thenReturn(255);\n\n        XWikiDocument prefsDoc = new XWikiDocument(new DocumentReference(\"xwiki\", \"XWiki\", \"XWikiPreferences\"));\n        final Map<DocumentReference, XWikiDocument> documents = new HashMap<DocumentReference, XWikiDocument>();\n        documents.put(prefsDoc.getDocumentReference(), prefsDoc);\n\n        when(this.oldcore.getMockStore().loadXWikiDoc(notNull(), same(this.oldcore.getXWikiContext())))\n            .then(new Answer<XWikiDocument>()\n            {\n\n                @Override\n                public XWikiDocument answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocument document = (XWikiDocument) invocation.getArgument(0);\n                    if (!documents.containsKey(document.getDocumentReference())) {\n                        documents.put(document.getDocumentReference(), document);\n                    } else {\n                        document = documents.get(document.getDocumentReference());\n                    }\n                    return document;\n                }\n            });\n\n        this.xwiki.getPrefsClass(this.oldcore.getXWikiContext());\n        this.xwiki.getPrefsClass(this.oldcore.getXWikiContext());\n\n        verify(this.oldcore.getMockStore(), atLeastOnce()).loadXWikiDoc(notNull(),\n            same(this.oldcore.getXWikiContext()));\n        verify(this.oldcore.getMockStore()).saveXWikiDoc(same(prefsDoc), same(this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * XWIKI-12398: No layout for login page in a closed wiki\n     */\n    @Test\n    public void testSkinResourcesAreAlwaysAllowed() throws XWikiException\n    {\n        // /skin/resources/icons/xwiki/noavatar.png\n        XWikiDocument doc1 = new XWikiDocument(\n            new DocumentReference(\"xwiki\", Arrays.asList(\"resources\", \"icons\", \"xwiki\"), \"noavatar.png\"));\n        // /skin/skins/flamingo/style.css\n        XWikiDocument doc2 =\n            new XWikiDocument(new DocumentReference(\"xwiki\", Arrays.asList(\"skins\", \"flamingo\", \"xwiki\"), \"style.css\"));\n\n        // Verify the results.\n        assertTrue(this.xwiki.checkAccess(\"skin\", doc1, this.oldcore.getXWikiContext()));\n        assertTrue(this.xwiki.checkAccess(\"skin\", doc2, this.oldcore.getXWikiContext()));\n\n        // Make sure it is never called to validate the test's results.\n        verify(this.oldcore.getMockRightService(), never()).checkAccess(any(), any(), any());\n        verify(this.oldcore.getMockAuthService(), times(2)).checkAuth(this.oldcore.getXWikiContext());\n    }\n\n    @Test\n    public void testCheckActiveSuperadmin() throws Exception\n    {\n        int isUserActive =\n            this.xwiki.checkActive(XWikiRightService.SUPERADMIN_USER_FULLNAME, this.oldcore.getXWikiContext());\n\n        assertEquals(1, isUserActive);\n    }\n\n    /**\n     * XWIKI-14300: Superadmin is locked out of subwikis with \"AUTHENTICATION ACTIVE CHECK\" enabled\n     */\n    @Test\n    public void testCheckActivePrefixedSuperadmin() throws Exception\n    {\n        // In a subwiki, the superadmin always logs in as a global user.\n        int isUserActive = this.xwiki.checkActive(\"xwiki:\" + XWikiRightService.SUPERADMIN_USER_FULLNAME,\n            this.oldcore.getXWikiContext());\n\n        assertEquals(1, isUserActive);\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithContext() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null));\n        this.oldcore.getXWikiContext().setLocale(Locale.FRENCH);\n\n        assertEquals(Locale.FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceDefaultNonMultilingual() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null));\n\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithParameterForcingUnset() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public String getParameter(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return \"fr_CA\";\n                }\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // we do not force supported languages\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.language.forceSupported\", \"0\");\n\n        assertEquals(Locale.CANADA_FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithParameter() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public String getParameter(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return \"fr_CA\";\n                }\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // only the default language is supported by default\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithParameterWithSupportedLanguages() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public String getParameter(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return \"fr_CA\";\n                }\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languages\", \"en, |fr_FR, |en_US, |fr_CA\");\n\n        // only the default language is supported by default\n        assertEquals(Locale.CANADA_FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithParameterDefault() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public String getParameter(String s)\n            {\n                if (\"language\".equals(s)) {\n                    return \"default\";\n                }\n                return null;\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithCookieForcingUnset() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Cookie[] getCookies()\n            {\n                return new Cookie[] { new Cookie(\"language\", \"fr_CA\") };\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // we do not force supported languages\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.language.forceSupported\", \"0\");\n\n        assertEquals(Locale.CANADA_FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithCookie() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Cookie[] getCookies()\n            {\n                return new Cookie[] { new Cookie(\"language\", \"fr_CA\") };\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // By default we force only supported languages\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithCookieDefaultNotSet() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Cookie[] getCookies()\n            {\n                return new Cookie[] { new Cookie(\"language\", \"fr_CA\") };\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // By default we force only supported languages\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithCookieDefaultSet() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Cookie[] getCookies()\n            {\n                return new Cookie[] { new Cookie(\"language\", \"fr_CA\") };\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languages\", \"en, |fr_FR, |en_US, |fr_CA\");\n\n        // By default we force only supported languages\n        assertEquals(Locale.CANADA_FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithNavigatorLanguagesForcingUnset() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Enumeration<Locale> getLocales()\n            {\n                ArrayList<Locale> locales = new ArrayList<>();\n                locales.add(new Locale(\"*\"));\n                locales.add(new Locale(\"en\", \"US\"));\n                locales.add(new Locale(\"fr\"));\n                locales.add(new Locale(\"de\"));\n                return IteratorUtils.asEnumeration(locales.iterator());\n            }\n        });\n\n        // we do not force supported languages\n        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.language.forceSupported\", \"0\");\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        assertEquals(Locale.US, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithNavigatorLanguages() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Enumeration<Locale> getLocales()\n            {\n                ArrayList<Locale> locales = new ArrayList<>();\n                locales.add(new Locale(\"*\"));\n                locales.add(new Locale(\"en\", \"US\"));\n                locales.add(new Locale(\"fr\"));\n                locales.add(new Locale(\"de\"));\n                return IteratorUtils.asEnumeration(locales.iterator());\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        // it's forced to \"en\" since it's the only supported language by default\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithNavigatorLanguagesDefaultSet() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)\n        {\n            @Override\n            public Enumeration<Locale> getLocales()\n            {\n                ArrayList<Locale> locales = new ArrayList<>();\n                locales.add(new Locale(\"*\"));\n                locales.add(new Locale(\"en\", \"US\"));\n                locales.add(new Locale(\"fr\"));\n                locales.add(new Locale(\"de\"));\n                return IteratorUtils.asEnumeration(locales.iterator());\n            }\n        });\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languages\", \"en, |fr_FR, |en_US, |fr_CA\");\n\n        // en_US is the first common language between supported and browser supported.\n        assertEquals(Locale.US, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void testGetLocalePreferenceWithNavigatorLanguagesFallback() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null));\n\n        // Set the wiki to multilingual mode.\n        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");\n\n        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));\n    }\n\n    // test implementation of document rename before atomic rename.\n    @Test\n    public void renameDocumentOldImplementation() throws Exception\n    {\n        // Possible ways to write parents, include documents, or make links:\n        // \"name\" -----means-----> DOCWIKI+\":\"+DOCSPACE+\".\"+input\n        // \"space.name\" -means----> DOCWIKI+\":\"+input\n        // \"database:space.name\" (no change)\n\n        // We don't want to use atomic rename here: we are testing the old implementation.\n        this.oldcore.getConfigurationSource().setProperty(\"refactoring.rename.useAtomicRename\", false);\n\n        this.document.setContent(\"[[doc:pageinsamespace]]\");\n        this.document.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());\n\n        DocumentReference reference1 = new DocumentReference(DOCWIKI, DOCSPACE, \"Page1\");\n        XWikiDocument doc1 = new XWikiDocument(reference1);\n        doc1.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]] [[someName>>doc:\" + DOCSPACE + \".\"\n            + DOCNAME + \"]] [[doc:\" + DOCNAME + \"]]\");\n        doc1.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc1, this.oldcore.getXWikiContext());\n\n        DocumentReference reference2 = new DocumentReference(\"newwikiname\", DOCSPACE, \"Page2\");\n        XWikiDocument doc2 = new XWikiDocument(reference2);\n        doc2.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]]\");\n        doc2.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc2, this.oldcore.getXWikiContext());\n\n        DocumentReference reference3 = new DocumentReference(\"newwikiname\", \"newspace\", \"Page3\");\n        XWikiDocument doc3 = new XWikiDocument(reference3);\n        doc3.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]]\");\n        doc3.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc3, this.oldcore.getXWikiContext());\n\n        // Test to make sure it also drags children along.\n        DocumentReference reference4 = new DocumentReference(DOCWIKI, DOCSPACE, \"Page4\");\n        XWikiDocument doc4 = new XWikiDocument(reference4);\n        doc4.setParent(DOCSPACE + \".\" + DOCNAME);\n        this.xwiki.saveDocument(doc4, this.oldcore.getXWikiContext());\n\n        DocumentReference reference5 = new DocumentReference(\"newwikiname\", \"newspace\", \"Page5\");\n        XWikiDocument doc5 = new XWikiDocument(reference5);\n        doc5.setParent(DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME);\n        this.xwiki.saveDocument(doc5, this.oldcore.getXWikiContext());\n\n        DocumentReference targetReference = new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\");\n        this.xwiki.renameDocument(this.document.getDocumentReference(),\n            targetReference, true,\n            Arrays.asList(reference1, reference2, reference3), Arrays.asList(reference4, reference5),\n            this.oldcore.getXWikiContext());\n\n        // Test links\n        assertEquals(\"[[doc:Wiki:MilkyWay.pageinsamespace]]\",\n            this.xwiki.getDocument(targetReference, this.oldcore.getXWikiContext()).getContent());\n        assertTrue(this.xwiki\n            .getDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME), this.oldcore.getXWikiContext()).isNew());\n        assertEquals(\"[[doc:newwikiname:newspace.newpage]] \" + \"[[someName>>doc:newwikiname:newspace.newpage]] \"\n            + \"[[doc:newwikiname:newspace.newpage]]\",\n            this.xwiki.getDocument(reference1, this.oldcore.getXWikiContext()).getContent());\n        assertEquals(\"[[doc:newspace.newpage]]\",\n            this.xwiki.getDocument(reference2, this.oldcore.getXWikiContext()).getContent());\n        assertEquals(\"[[doc:newpage]]\",\n            this.xwiki.getDocument(reference3, this.oldcore.getXWikiContext()).getContent());\n\n        // Test parents\n        assertEquals(\"newwikiname:newspace.newpage\",\n            this.xwiki.getDocument(reference4, this.oldcore.getXWikiContext()).getParent());\n        assertEquals(new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\"),\n            this.xwiki.getDocument(reference5, this.oldcore.getXWikiContext()).getParentReference());\n    }\n\n    @Test\n    public void atomicRename() throws Exception\n    {\n        doAnswer(invocationOnMock -> {\n            XWikiDocument sourceDoc = invocationOnMock.getArgument(0);\n            DocumentReference targetReference = invocationOnMock.getArgument(1);\n            XWikiContext context = invocationOnMock.getArgument(2);\n            XWikiDocument targetDoc = sourceDoc.cloneRename(targetReference, context);\n            this.xwiki.saveDocument(targetDoc, context);\n            this.xwiki.deleteDocument(sourceDoc, true, context);\n            return null;\n        }).when(this.oldcore.getMockStore()).renameXWikiDoc(any(), any(), any());\n        this.document.setContent(\"[[doc:pageinsamespace]]\");\n        this.document.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());\n\n        DocumentReference reference1 = new DocumentReference(DOCWIKI, DOCSPACE, \"Page1\");\n        XWikiDocument doc1 = new XWikiDocument(reference1);\n        doc1.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]] [[someName>>doc:\" + DOCSPACE + \".\"\n            + DOCNAME + \"]] [[doc:\" + DOCNAME + \"]]\");\n        doc1.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc1, this.oldcore.getXWikiContext());\n\n        DocumentReference reference2 = new DocumentReference(\"newwikiname\", DOCSPACE, \"Page2\");\n        XWikiDocument doc2 = new XWikiDocument(reference2);\n        doc2.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]]\");\n        doc2.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc2, this.oldcore.getXWikiContext());\n\n        DocumentReference reference3 = new DocumentReference(\"newwikiname\", \"newspace\", \"Page3\");\n        XWikiDocument doc3 = new XWikiDocument(reference3);\n        doc3.setContent(\"[[doc:\" + DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME + \"]]\");\n        doc3.setSyntax(Syntax.XWIKI_2_1);\n        this.xwiki.saveDocument(doc3, this.oldcore.getXWikiContext());\n\n        // Test to make sure it also drags children along.\n        DocumentReference reference4 = new DocumentReference(DOCWIKI, DOCSPACE, \"Page4\");\n        XWikiDocument doc4 = new XWikiDocument(reference4);\n        doc4.setParent(DOCSPACE + \".\" + DOCNAME);\n        this.xwiki.saveDocument(doc4, this.oldcore.getXWikiContext());\n\n        DocumentReference reference5 = new DocumentReference(\"newwikiname\", \"newspace\", \"Page5\");\n        XWikiDocument doc5 = new XWikiDocument(reference5);\n        doc5.setParent(DOCWIKI + \":\" + DOCSPACE + \".\" + DOCNAME);\n        this.xwiki.saveDocument(doc5, this.oldcore.getXWikiContext());\n\n        DocumentReference targetReference = new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\");\n        this.xwiki.renameDocument(this.document.getDocumentReference(),\n            targetReference, true,\n            Arrays.asList(reference1, reference2, reference3), Arrays.asList(reference4, reference5),\n            this.oldcore.getXWikiContext());\n\n        // Test links\n        assertEquals(\"[[doc:Wiki:MilkyWay.pageinsamespace]]\",\n            this.xwiki.getDocument(targetReference, this.oldcore.getXWikiContext()).getContent());\n        assertTrue(this.xwiki\n            .getDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME), this.oldcore.getXWikiContext()).isNew());\n        assertEquals(\"[[doc:newwikiname:newspace.newpage]] \" + \"[[someName>>doc:newwikiname:newspace.newpage]] \"\n                + \"[[doc:newwikiname:newspace.newpage]]\",\n            this.xwiki.getDocument(reference1, this.oldcore.getXWikiContext()).getContent());\n        assertEquals(\"[[doc:newspace.newpage]]\",\n            this.xwiki.getDocument(reference2, this.oldcore.getXWikiContext()).getContent());\n        assertEquals(\"[[doc:newpage]]\",\n            this.xwiki.getDocument(reference3, this.oldcore.getXWikiContext()).getContent());\n\n        // Test parents\n        assertEquals(\"newwikiname:newspace.newpage\",\n            this.xwiki.getDocument(reference4, this.oldcore.getXWikiContext()).getParent());\n        assertEquals(new DocumentReference(\"newwikiname\", \"newspace\", \"newpage\"),\n            this.xwiki.getDocument(reference5, this.oldcore.getXWikiContext()).getParentReference());\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/XWiki.java", "xwiki-platform-core/xwiki-platform-oldcore/src/test/java/com/xpn/xwiki/XWikiTest.java"], "buggy_code_start_loc": [3859, 582], "buggy_code_end_loc": [3864, 582], "fixing_code_start_loc": [3860, 583], "fixing_code_end_loc": [3867, 585], "type": "CWE-863", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. In versions prior to 11.10.13, 12.6.7, and 12.10.2, a user disabled on a wiki using email verification for registration canouldre-activate themself by using the activation link provided for his registration. The problem has been patched in the following versions of XWiki: 11.10.13, 12.6.7, 12.10.2, 13.0. It is possible to workaround the issue by resetting the `validkey` property of the disabled XWiki users. This can be done by editing the user profile with object editor.", "other": {"cve": {"id": "CVE-2021-32620", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-28T21:15:08.937", "lastModified": "2022-08-05T12:37:38.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. In versions prior to 11.10.13, 12.6.7, and 12.10.2, a user disabled on a wiki using email verification for registration canouldre-activate themself by using the activation link provided for his registration. The problem has been patched in the following versions of XWiki: 11.10.13, 12.6.7, 12.10.2, 13.0. It is possible to workaround the issue by resetting the `validkey` property of the disabled XWiki users. This can be done by editing the user profile with object editor."}, {"lang": "es", "value": "La Plataforma XWiki es una plataforma wiki gen\u00e9rica que ofrece servicios de ejecuci\u00f3n para las aplicaciones construidas sobre ella. En las versiones anteriores a la 11.10.13, 12.6.7 y 12.10.2, un usuario deshabilitado en un wiki que utilizaba la verificaci\u00f3n por correo electr\u00f3nico para el registro pod\u00eda volver a activarse utilizando el enlace de activaci\u00f3n proporcionado para su registro. El problema ha sido parcheado en las siguientes versiones de XWiki: 11.10.13, 12.6.7, 12.10.2, 13.0. Es posible solucionar el problema restableciendo la propiedad `validkey` de los usuarios de XWiki deshabilitados. Esto se puede hacer editando el perfil del usuario con el editor de objetos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.6", "versionEndExcluding": "11.10.13", "matchCriteriaId": "3D0D3D92-E37B-403D-AAF1-822A3BA64956"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.0", "versionEndExcluding": "12.6.7", "matchCriteriaId": "D264B70E-FABB-4ACC-A822-2DF1196E28D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.7", "versionEndExcluding": "12.10.2", "matchCriteriaId": "8C172862-7292-49C9-9C3E-D422D2FEF601"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.10.3", "versionEndExcluding": "13.0", "matchCriteriaId": "09FEA406-C6AA-4449-8253-4A345F37B212"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/f9a677408ffb06f309be46ef9d8df1915d9099a4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-76mp-659p-rw65", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-17942", "source": "security-advisories@github.com", "tags": ["Permissions Required", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/f9a677408ffb06f309be46ef9d8df1915d9099a4"}}