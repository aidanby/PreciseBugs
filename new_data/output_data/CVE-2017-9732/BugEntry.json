{"buggy_code": ["/* $Id: gssstdio.c,v 1.6 2010/04/14 11:26:50 dowdes Exp $ */\n\n/*-\n * Copyright 2009  Morgan Stanley and Co. Incorporated\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject\n * to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\n * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/*-\n * Copyright (c) 2003 Roland C. Dowdeswell.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#include <sys/socket.h>\n\n#include <netinet/in.h>\n\n/* #include <netdb.h> */\n\n#include <errno.h>\n#include <poll.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n\n/* this include must be before krb5/resolve.conf for things to work */\n#include <arpa/nameser.h>\n\nextern char _log_buff[2048];\n\n#include \"gssstdio.h\"\n#include \"knc.h\"\n\n/* The rest of them are internal utility functions */\n\nstatic int\twrite_packet(int, gss_buffer_t);\nstatic ssize_t\ttimed_read(int, void *, size_t, int);\nstatic int\tread_packet(int, gss_buffer_t, int, int);\nstatic int\tgstd_errstring(char **, int);\n\n#define SETUP_GSTD_TOK(x,y,z,w) do {\t\t\t\t\t\\\n\t\t(x) = malloc(sizeof(*(x)));\t\t\t\t\\\n\t\tif (!(x)) {\t\t\t\t\t\t\\\n\t\t\tLOG(LOG_ERR, (\"%s: could not malloc(3), %s\",\t\\\n\t\t\t\t      (w), strerror(errno)));\t\t\\\n\t\t\treturn NULL;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t(x)->gstd_ctx = (y);\t\t\t\t\t\\\n\t\t(x)->gstd_inbuf.length = 0;\t\t\t\t\\\n\t\t(x)->gstd_inbuf.value = NULL;\t\t\t\t\\\n\t\t(x)->gstd_inbufpos = -1;\t\t\t\t\\\n\t\t(x)->gstd_fd  = (z);\t\t\t\t\t\\\n\t} while (0)\n\nstatic char *\ngstd_get_display_name(gss_name_t client)\n{\n\tOM_uint32\tmaj;\n\tOM_uint32\tmin;\n\tgss_buffer_desc\tbuf;\n\tchar\t\t*ret;\n\n\tmaj = gss_display_name(&min, client, &buf, NULL);\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_display_name\");\n\n\tif ((ret = (char *)malloc(buf.length + 1)) == NULL) {\n\t\tLOG(LOG_ERR, (\"unable to malloc\"));\n\t\tgss_release_buffer(&min, &buf);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(ret, buf.value, buf.length);\n\tret[buf.length] = '\\0';\n\n\tgss_release_buffer(&min, &buf);\n\n\treturn ret;\n}\n\nstatic char *\ngstd_get_export_name(gss_name_t client)\n{\n\tOM_uint32\tmaj;\n\tOM_uint32\tmin;\n\tgss_buffer_desc\tbuf;\n\tunsigned char   *bufp;\n\tunsigned char   nibble;\n\tchar\t\t*ret;\n\tsize_t\t  i, k;\n\n\tmaj = gss_export_name(&min, client, &buf);\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_export_name\");\n\n\tif ((ret = (char *)malloc(buf.length * 2 + 1)) == NULL) {\n\t\tLOG(LOG_ERR, (\"unable to malloc\"));\n\t\tgss_release_buffer(&min, &buf);\n\t\treturn NULL;\n\t}\n\n\tfor (bufp = buf.value, i = 0, k = 0; i < buf.length; i++) {\n\t\tnibble = bufp[i] >> 4;\n\t\tret[k++] = \"0123456789ABCDEF\"[nibble];\n\t\tnibble = bufp[i] & 0x0f;\n\t\tret[k++] = \"0123456789ABCDEF\"[nibble];\n\t}\n\n\tret[k] = '\\0';\n\tgss_release_buffer(&min, &buf);\n\n\treturn ret;\n}\n\n#define KNC_KRB5_MECH_OID \"\\052\\206\\110\\206\\367\\022\\001\\002\\002\"\n\nstatic char *\ngstd_get_mech(gss_OID mech_oid)\n{\n#ifdef HAVE_GSS_OID_TO_STR\n\tOM_uint32\tmaj;\n\tOM_uint32\tmin;\n#endif\n\tgss_buffer_desc\tbuf;\n\tunsigned char   *bufp;\n\tunsigned char   nibble;\n\tchar\t\t*ret;\n\tsize_t\t\ti, k;\n\n\tif (mech_oid->length == sizeof(KNC_KRB5_MECH_OID) - 1 &&\n\t    memcmp(mech_oid->elements, KNC_KRB5_MECH_OID,\n\t\t   sizeof(KNC_KRB5_MECH_OID) - 1) == 0) {\n\t\tif ((ret = strdup(\"krb5\")) == NULL) {\n\t\t\tLOG(LOG_ERR, (\"unable to malloc\"));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ret;\n\t}\n\n#ifdef HAVE_GSS_OID_TO_STR\n\tmaj = gss_oid_to_str(&min, mech_oid, &buf);\n\tif (maj != GSS_S_COMPLETE) {\n\t\tLOG(LOG_ERR, (\"unable to display mechanism OID\"));\n\t\treturn NULL;\n\t}\n\tret = strndup(buf.value, buf.length);\n#else\n\tret = strdup(\"\");\n#endif\n\tif (!ret)\n\t\tLOG(LOG_ERR, (\"unable to malloc\"));\n\treturn ret;\n}\n\nvoid *\ngstd_accept(int fd, char **display_creds, char **export_name, char **mech)\n{\n\tgss_name_t\t client;\n\tgss_OID\t\t mech_oid;\n\tstruct gstd_tok *tok;\n\tgss_ctx_id_t\t ctx = GSS_C_NO_CONTEXT;\n\tgss_buffer_desc\t in, out;\n\tOM_uint32\t maj, min;\n\tint\t\t ret;\n\n\t*display_creds = NULL;\n\t*export_name = NULL;\n\tout.length = 0;\n\tin.length = 0;\n\tread_packet(fd, &in, 60000, 1);\nagain:\n\twhile ((ret = read_packet(fd, &in, 60000, 0)) == -2)\n\t\t;\n\n\tif (ret < 1)\n\t\treturn NULL;\n\n\tmaj = gss_accept_sec_context(&min, &ctx, GSS_C_NO_CREDENTIAL,\n\t    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,\n\t    NULL, NULL);\n\n\tif (out.length && write_packet(fd, &out)) {\n\t\tgss_release_buffer(&min, &out);\n\t\treturn NULL;\n\t}\n\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_accept_sec_context\");\n\n\tif (maj & GSS_S_CONTINUE_NEEDED)\n\t\tgoto again;\n\n\t*display_creds = gstd_get_display_name(client);\n\t*export_name = gstd_get_export_name(client);\n\t*mech = gstd_get_mech(mech_oid);\n\n\tgss_release_name(&min, &client);\n\tSETUP_GSTD_TOK(tok, ctx, fd, \"gstd_accept\");\n\treturn tok;\n}\n\n\nvoid *\ngstd_initiate(const char *hostname, const char *service, const char *princ,\n\t      int fd)\n{\n\tstruct gstd_tok\t*tok;\n\tgss_ctx_id_t\tctx = GSS_C_NO_CONTEXT;\n\tgss_buffer_desc\tin, out;\n\tgss_OID\t\ttype;\n\tOM_uint32\tmaj, min;\n\tgss_buffer_desc\tname;\n\tgss_name_t\tserver;\n\tint\t\tret;\n\n\tif (!princ) {\n\t\tif ((name.value = malloc(strlen(service) + strlen(hostname)\n\t\t\t\t\t + 2)) == NULL) {\n\t\t\tLOG(LOG_ERR, (\"unable to malloc service name\"));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tname.length = sprintf((char *)name.value, \"%s@%s\",\n\t\t\t\t      service, hostname);\n\t\tLOG(LOG_DEBUG, (\"going to get tickets for: %s\",\n\t\t    (char *)name.value));\n\t\tfflush(stderr);\n\t\tif (!name.value)\n\t\t\treturn NULL;\n\t\ttype = GSS_C_NT_HOSTBASED_SERVICE;\n\t} else {\n\t\tname.value = (char *) princ;\n\t\tname.length = strlen(princ);\n\t\ttype = (gss_OID) GSS_C_NO_OID;\n\t}\n\n\tmaj = gss_import_name(&min, &name, type, &server);\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_import_name\");\n\n\tin.length = 0;\n\tout.length = 0;\n\nagain:\n\tmaj = gss_init_sec_context(&min, GSS_C_NO_CREDENTIAL, &ctx, server,\n\t    GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0,\n\t    GSS_C_NO_CHANNEL_BINDINGS, &in, NULL, &out, NULL, NULL);\n\n\tif (out.length && write_packet(fd, &out))\n\t\treturn NULL;\n\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_init_sec_context\");\n\n\tif (GSS_ERROR(maj) && ctx != GSS_C_NO_CONTEXT) {\n\t\tgss_delete_sec_context(&min, &ctx, GSS_C_NO_BUFFER);\n\t\treturn NULL;\n\t}\n\n\tif (maj & GSS_S_CONTINUE_NEEDED) {\n\t\tLOG(LOG_DEBUG, (\"continuing gstd_initiate\"));\n\t\twhile ((ret = read_packet(fd, &in, 0, 0)) == -2)\n\t\t\t;\n\n\t\tif (ret < 1) {\n\t\t\tLOG(LOG_ERR, (\"continuation failed\"));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tgoto again;\n\t}\n\n\tLOG(LOG_DEBUG, (\"authenticated\"));\n\tSETUP_GSTD_TOK(tok, ctx, fd, \"gstd_connect\");\n\treturn tok;\n}\n\n#ifdef MIN\n#undef MIN\n#endif\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\nint\ngstd_read(void *the_tok, char *buf, int length)\n{\n\tstruct gstd_tok\t*tok = the_tok;\n\tgss_buffer_desc\tin;\n\tOM_uint32\tmaj, min;\n\tint\t\tbufpos = tok->gstd_inbufpos;\n\tint\t\tret;\n\n\t/*\n\t * If we have no buffered data, read another packet and\n\t * reset the buffer.\n\t */\n\n\tif (bufpos == -1 || bufpos >= tok->gstd_inbuf.length) {\n\t\tif (tok->gstd_inbuf.length > 0)\n\t\t\tgss_release_buffer(&min, &tok->gstd_inbuf);\n\n\t\t/*\n\t\t * If we encounter a protocol botch or if the other side has\n\t\t * closed the connection, we return that fact here\n\t\t */\n\t\tret = read_packet(tok->gstd_fd, &in, 0, 0);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tmaj = gss_unwrap(&min, tok->gstd_ctx, &in, &tok->gstd_inbuf,\n\t\t    NULL, NULL);\n\t\tif (maj != GSS_S_COMPLETE) {\n\t\t\tgstd_error(LOG_ERR, min, \"gss_unwrap\");\n\t\t\treturn -1;\n\t\t}\n\t\tgss_release_buffer(&min, &in);\n\t\tbufpos = 0;\n\t}\n\n\t/*\n\t * Now we know that we have a buffered packet, so return\n\t * as much of it as we can.  We do not need to fill the\n\t * requestor's buffer, because stdio can deal with short\n\t * reads.\n\t */\n\n\tlength = MIN(length, tok->gstd_inbuf.length - bufpos);\n\tmemcpy(buf, tok->gstd_inbuf.value + bufpos, length);\n\ttok->gstd_inbufpos = bufpos + length;\n\tLOG(LOG_DEBUG, (\"read %d bytes\", length));\n\treturn length;\n}\n\n#if 0\nint\ngstd_write(work_t *work)\n{\n\tstruct gstd_tok\t*tok = work->the_tok;\n\tgss_buffer_desc\tin, out;\n\tOM_uint32\tmaj, min;\n\n\t/*\n\t * We clip the length at GSTD_MAXPACKETCONTENTS (+fudge) to make\n\t * the job of the receiver easier.\n\t */\n\n\tif (length <= 0)\t/* hmmm, error eh? */\n\t\treturn -1;\n\n\tif (length > GSTD_MAXPACKETCONTENTS)\n\t\tlength = GSTD_MAXPACKETCONTENTS;\n\n\tin.length = work->network_buffer.len;\n\tin.value  = (void *)work->network_buffer.buffer;\n\n\tmaj = gss_wrap(&min, tok->gstd_ctx, 1, GSS_C_QOP_DEFAULT,\n\t    &in, NULL, &out);\n\tGSTD_GSS_ERROR(maj, min, -1, \"gss_wrap\");\n\n\t/* should I loop on this one? */\n\tif (write_packet(tok->gstd_fd, &out))\n\t\treturn -1;\n\n\tLOG(LOG_DEBUG, (\"wrote %d bytes\", length));\n\treturn length;\n}\n\n#endif\n\nint\ngstd_close(void *the_tok)\n{\n\tstruct gstd_tok\t*tok = the_tok;\n\tOM_uint32\t min;\n\n\tgss_delete_sec_context(&min, &tok->gstd_ctx, GSS_C_NO_BUFFER);\n\tif (tok->gstd_inbuf.length > 0)\n\t\tgss_release_buffer(&min, &tok->gstd_inbuf);\n\tclose(tok->gstd_fd);\n\treturn 0;\n}\n\nstatic ssize_t\ntimed_read(int fd, void *buf, size_t bytes, int timeout)\n{\n\tstruct pollfd\t\tfds[1];\n\tint\t\t\tret;\n\n\tif (timeout > 0) {\n\t\tfds[0].fd = fd;\n\t\tfds[0].events = POLLIN;\n\n\t\tret = poll(fds, 1, timeout);\n\n\t\tif (ret == -1)\n\t\t\treturn -1;\n\n\t\tif (ret != 1) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn read(fd, buf, bytes);\n}\n\n/*\n * Returns:\n *\t-2\tNeed to call again\n *\t-1\tProtocol error\n *\t0\tNormal EOF (non-protocol error, other side is finished and\n *\t\thas simply closed the connection)\n *\t1       Data has been completely received\n */\nstatic int\nread_packet(int fd, gss_buffer_t buf, int timeout, int first)\n{\n\tint\t  ret;\n\n\tstatic uint32_t\t\tlen = 0;\n\tstatic char\t\tlen_buf[4];\n\tstatic int\t\tlen_buf_pos = 0;\n\tstatic char *\t\ttmpbuf = 0;\n\tstatic int\t\ttmpbuf_pos = 0;\n\n\tif (first) {\n\t\tlen_buf_pos = 0;\n\t\treturn -2;\n\t}\n\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret == 0) {\t\t/* EOF */\n\t\t\t/* Failure to read ANY length just means we're done */\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Otherwise, we got EOF mid-length, and that's\n\t\t\t * a protocol error.\n\t\t\t */\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen_buf_pos += ret;\n\t}\n\n\t/* Not done reading the length? */\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\n\t/* We have the complete length */\n\tlen = ntohl(*(uint32_t *)len_buf);\n\n\t/*\n\t * We make sure recvd length is reasonable, allowing for some\n\t * slop in enc overhead, beyond the actual maximum number of\n\t * bytes of decrypted payload.\n\t */\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\treturn -1;\n\t}\n\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\treturn -1;\n\t}\n\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\treturn -1;\n\t}\n\n\ttmpbuf_pos += ret;\n\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\n\treturn -2;\n}\n\nstatic int\nwrite_packet(int fd, gss_buffer_t buf)\n{\n\tuint32_t\tlen;\n\tOM_uint32\tmin_stat;\n\tint\t\tret = 0;\n\n\tlen = htonl(buf->length);\n\tif ((writen(fd, &len, 4) != 4) ||\n\t    (writen(fd, buf->value, buf->length) != buf->length))\n\t\tret = -1;\n\n\tgss_release_buffer (&min_stat, buf);\n\treturn ret;\n}\n\n\n/*\n * The following function writes up to len bytes, returning -1 if it fails\n * to do so for any reason, and len otherwise.  Note, partial writes may\n * have occurred if this function returns -1\n */\nint\nwriten(int fd, const void *buf, ssize_t len) {\n\tint\tnleft;\n\tint\tnwritten;\n\tchar *\tbuffer = (char *)buf;\n\n\tnleft = len;\n\twhile (nleft > 0) {\n\t\tnwritten = write(fd, buffer, len);\n\n\t\tif (nwritten < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\telse {\n\t\t\t\tLOG_ERRNO(LOG_ERR, (\"write failed\"));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tnleft -= nwritten;\n\t\t\tbuffer += nwritten;\n\t\t}\n\t}\n\n\tLOG(LOG_DEBUG, (\"wrote %d bytes\", len));\n\treturn len;\n}\n\n\nstatic int\ngstd_errstring(char **str, int min_stat)\n{\n\tgss_buffer_desc\t status;\n\tOM_uint32\t new_stat;\n\tOM_uint32\t msg_ctx = 0;\n\tOM_uint32\t ret;\n\tint\t\t len = 0;\n\tchar\t\t*tmp;\n\tchar\t\t*statstr;\n\n\t/* XXXrcd this is not correct yet */\n\t/* XXXwps ...and now it is. */\n\n\tif (!str)\n\t\treturn -1;\n\n\t*str = NULL;\n\ttmp = NULL;\n\n\tdo {\n\t\tret = gss_display_status(&new_stat, min_stat,\n\t\t    GSS_C_MECH_CODE, GSS_C_NO_OID, &msg_ctx,\n\t\t    &status);\n\n\t\t/* GSSAPI strings are not NUL terminated */\n\t\tif ((statstr = (char *)malloc(status.length + 1)) == NULL) {\n\t\t\tLOG(LOG_ERR, (\"unable to malloc status string \"\n\t\t\t\t      \"of length %ld\", status.length));\n\t\t\tgss_release_buffer(&new_stat, &status);\n\t\t\tfree(statstr);\n\t\t\tfree(tmp);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmemcpy(statstr, status.value, status.length);\n\t\tstatstr[status.length] = '\\0';\n\n\t\tif (GSS_ERROR(ret)) {\n\t\t\tfree(statstr);\n\t\t\tfree(tmp);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*str) {\n\t\t\tif ((*str = malloc(strlen(*str) + status.length +\n\t\t\t\t\t   3)) == NULL) {\n\t\t\t\tLOG(LOG_ERR, (\"unable to malloc error \"\n\t\t\t\t\t\t\"string\"));\n\t\t\t\tgss_release_buffer(&new_stat, &status);\n\t\t\t\tfree(statstr);\n\t\t\t\tfree(tmp);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlen = sprintf(*str, \"%s, %s\", tmp, statstr);\n\t\t} else {\n\t\t\t*str = malloc(status.length + 1);\n\t\t\tif (!*str) {\n\t\t\t\tLOG(LOG_ERR, (\"unable to malloc error \"\n\t\t\t\t\t\t\"string\"));\n\t\t\t\tgss_release_buffer(&new_stat, &status);\n\t\t\t\tfree(statstr);\n\t\t\t\tfree(tmp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlen = sprintf(*str, \"%s\", (char *)statstr);\n\t\t}\n\n\t\tgss_release_buffer(&new_stat, &status);\n\t\tfree(statstr);\n\t\tfree(tmp);\n\n\t\ttmp = *str;\n\t} while (msg_ctx != 0);\n\n\treturn len;\n}\n\nvoid\ngstd_error(int pri, int min_stat, const char *s)\n{\n\tchar *t1;\n\n\tif (gstd_errstring(&t1, min_stat) < 1)\n\t\tLOG(pri, (\"%s: couldn't form GSSAPI error string\", s));\n\telse {\n\t\tLOG(pri, (\"%s: %s\", s, t1));\n\t\tfree(t1);\n\t}\n}\n\nvoid\ngstd_release_context(void *ctx) {\n\tOM_uint32\tmin;\n\n\tgss_delete_sec_context(&min, (gss_ctx_id_t *)ctx, GSS_C_NO_BUFFER);\n}\n"], "fixing_code": ["/* $Id: gssstdio.c,v 1.6 2010/04/14 11:26:50 dowdes Exp $ */\n\n/*-\n * Copyright 2009  Morgan Stanley and Co. Incorporated\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject\n * to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\n * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/*-\n * Copyright (c) 2003 Roland C. Dowdeswell.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#include <sys/socket.h>\n\n#include <netinet/in.h>\n\n/* #include <netdb.h> */\n\n#include <errno.h>\n#include <poll.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <unistd.h>\n\n/* this include must be before krb5/resolve.conf for things to work */\n#include <arpa/nameser.h>\n\nextern char _log_buff[2048];\n\n#include \"gssstdio.h\"\n#include \"knc.h\"\n\n/* The rest of them are internal utility functions */\n\nstatic int\twrite_packet(int, gss_buffer_t);\nstatic ssize_t\ttimed_read(int, void *, size_t, int);\nstatic int\tread_packet(int, gss_buffer_t, int, int);\nstatic int\tgstd_errstring(char **, int);\n\n#define SETUP_GSTD_TOK(x,y,z,w) do {\t\t\t\t\t\\\n\t\t(x) = malloc(sizeof(*(x)));\t\t\t\t\\\n\t\tif (!(x)) {\t\t\t\t\t\t\\\n\t\t\tLOG(LOG_ERR, (\"%s: could not malloc(3), %s\",\t\\\n\t\t\t\t      (w), strerror(errno)));\t\t\\\n\t\t\treturn NULL;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t(x)->gstd_ctx = (y);\t\t\t\t\t\\\n\t\t(x)->gstd_inbuf.length = 0;\t\t\t\t\\\n\t\t(x)->gstd_inbuf.value = NULL;\t\t\t\t\\\n\t\t(x)->gstd_inbufpos = -1;\t\t\t\t\\\n\t\t(x)->gstd_fd  = (z);\t\t\t\t\t\\\n\t} while (0)\n\nstatic char *\ngstd_get_display_name(gss_name_t client)\n{\n\tOM_uint32\tmaj;\n\tOM_uint32\tmin;\n\tgss_buffer_desc\tbuf;\n\tchar\t\t*ret;\n\n\tmaj = gss_display_name(&min, client, &buf, NULL);\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_display_name\");\n\n\tif ((ret = (char *)malloc(buf.length + 1)) == NULL) {\n\t\tLOG(LOG_ERR, (\"unable to malloc\"));\n\t\tgss_release_buffer(&min, &buf);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(ret, buf.value, buf.length);\n\tret[buf.length] = '\\0';\n\n\tgss_release_buffer(&min, &buf);\n\n\treturn ret;\n}\n\nstatic char *\ngstd_get_export_name(gss_name_t client)\n{\n\tOM_uint32\tmaj;\n\tOM_uint32\tmin;\n\tgss_buffer_desc\tbuf;\n\tunsigned char   *bufp;\n\tunsigned char   nibble;\n\tchar\t\t*ret;\n\tsize_t\t  i, k;\n\n\tmaj = gss_export_name(&min, client, &buf);\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_export_name\");\n\n\tif ((ret = (char *)malloc(buf.length * 2 + 1)) == NULL) {\n\t\tLOG(LOG_ERR, (\"unable to malloc\"));\n\t\tgss_release_buffer(&min, &buf);\n\t\treturn NULL;\n\t}\n\n\tfor (bufp = buf.value, i = 0, k = 0; i < buf.length; i++) {\n\t\tnibble = bufp[i] >> 4;\n\t\tret[k++] = \"0123456789ABCDEF\"[nibble];\n\t\tnibble = bufp[i] & 0x0f;\n\t\tret[k++] = \"0123456789ABCDEF\"[nibble];\n\t}\n\n\tret[k] = '\\0';\n\tgss_release_buffer(&min, &buf);\n\n\treturn ret;\n}\n\n#define KNC_KRB5_MECH_OID \"\\052\\206\\110\\206\\367\\022\\001\\002\\002\"\n\nstatic char *\ngstd_get_mech(gss_OID mech_oid)\n{\n#ifdef HAVE_GSS_OID_TO_STR\n\tOM_uint32\tmaj;\n\tOM_uint32\tmin;\n#endif\n\tgss_buffer_desc\tbuf;\n\tunsigned char   *bufp;\n\tunsigned char   nibble;\n\tchar\t\t*ret;\n\tsize_t\t\ti, k;\n\n\tif (mech_oid->length == sizeof(KNC_KRB5_MECH_OID) - 1 &&\n\t    memcmp(mech_oid->elements, KNC_KRB5_MECH_OID,\n\t\t   sizeof(KNC_KRB5_MECH_OID) - 1) == 0) {\n\t\tif ((ret = strdup(\"krb5\")) == NULL) {\n\t\t\tLOG(LOG_ERR, (\"unable to malloc\"));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ret;\n\t}\n\n#ifdef HAVE_GSS_OID_TO_STR\n\tmaj = gss_oid_to_str(&min, mech_oid, &buf);\n\tif (maj != GSS_S_COMPLETE) {\n\t\tLOG(LOG_ERR, (\"unable to display mechanism OID\"));\n\t\treturn NULL;\n\t}\n\tret = strndup(buf.value, buf.length);\n#else\n\tret = strdup(\"\");\n#endif\n\tif (!ret)\n\t\tLOG(LOG_ERR, (\"unable to malloc\"));\n\treturn ret;\n}\n\nvoid *\ngstd_accept(int fd, char **display_creds, char **export_name, char **mech)\n{\n\tgss_name_t\t client;\n\tgss_OID\t\t mech_oid;\n\tstruct gstd_tok *tok;\n\tgss_ctx_id_t\t ctx = GSS_C_NO_CONTEXT;\n\tgss_buffer_desc\t in, out;\n\tOM_uint32\t maj, min;\n\tint\t\t ret;\n\n\t*display_creds = NULL;\n\t*export_name = NULL;\n\tout.length = 0;\n\tin.length = 0;\n\tread_packet(fd, &in, 60000, 1);\nagain:\n\twhile ((ret = read_packet(fd, &in, 60000, 0)) == -2)\n\t\t;\n\n\tif (ret < 1)\n\t\treturn NULL;\n\n\tmaj = gss_accept_sec_context(&min, &ctx, GSS_C_NO_CREDENTIAL,\n\t    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,\n\t    NULL, NULL);\n\n\tgss_release_buffer(&min, &in);\n\n\tif (out.length && write_packet(fd, &out)) {\n\t\tgss_release_buffer(&min, &out);\n\t\treturn NULL;\n\t}\n\tgss_release_buffer(&min, &out);\n\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_accept_sec_context\");\n\n\tif (maj & GSS_S_CONTINUE_NEEDED)\n\t\tgoto again;\n\n\t*display_creds = gstd_get_display_name(client);\n\t*export_name = gstd_get_export_name(client);\n\t*mech = gstd_get_mech(mech_oid);\n\n\tgss_release_name(&min, &client);\n\tSETUP_GSTD_TOK(tok, ctx, fd, \"gstd_accept\");\n\treturn tok;\n}\n\n\nvoid *\ngstd_initiate(const char *hostname, const char *service, const char *princ,\n\t      int fd)\n{\n\tstruct gstd_tok\t*tok;\n\tgss_ctx_id_t\tctx = GSS_C_NO_CONTEXT;\n\tgss_buffer_desc\tin, out;\n\tgss_OID\t\ttype;\n\tOM_uint32\tmaj, min;\n\tgss_buffer_desc\tname;\n\tgss_name_t\tserver;\n\tint\t\tret;\n\n\tif (!princ) {\n\t\tif ((name.value = malloc(strlen(service) + strlen(hostname)\n\t\t\t\t\t + 2)) == NULL) {\n\t\t\tLOG(LOG_ERR, (\"unable to malloc service name\"));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tname.length = sprintf((char *)name.value, \"%s@%s\",\n\t\t\t\t      service, hostname);\n\t\tLOG(LOG_DEBUG, (\"going to get tickets for: %s\",\n\t\t    (char *)name.value));\n\t\tfflush(stderr);\n\t\tif (!name.value)\n\t\t\treturn NULL;\n\t\ttype = GSS_C_NT_HOSTBASED_SERVICE;\n\t} else {\n\t\tname.value = (char *) princ;\n\t\tname.length = strlen(princ);\n\t\ttype = (gss_OID) GSS_C_NO_OID;\n\t}\n\n\tmaj = gss_import_name(&min, &name, type, &server);\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_import_name\");\n\n\tin.length = 0;\n\tout.length = 0;\n\nagain:\n\tmaj = gss_init_sec_context(&min, GSS_C_NO_CREDENTIAL, &ctx, server,\n\t    GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0,\n\t    GSS_C_NO_CHANNEL_BINDINGS, &in, NULL, &out, NULL, NULL);\n\n\tif (out.length && write_packet(fd, &out))\n\t\treturn NULL;\n\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_init_sec_context\");\n\n\tif (GSS_ERROR(maj) && ctx != GSS_C_NO_CONTEXT) {\n\t\tgss_delete_sec_context(&min, &ctx, GSS_C_NO_BUFFER);\n\t\treturn NULL;\n\t}\n\n\tif (maj & GSS_S_CONTINUE_NEEDED) {\n\t\tLOG(LOG_DEBUG, (\"continuing gstd_initiate\"));\n\t\twhile ((ret = read_packet(fd, &in, 0, 0)) == -2)\n\t\t\t;\n\n\t\tif (ret < 1) {\n\t\t\tLOG(LOG_ERR, (\"continuation failed\"));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tgoto again;\n\t}\n\n\tLOG(LOG_DEBUG, (\"authenticated\"));\n\tSETUP_GSTD_TOK(tok, ctx, fd, \"gstd_connect\");\n\treturn tok;\n}\n\n#ifdef MIN\n#undef MIN\n#endif\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\nint\ngstd_read(void *the_tok, char *buf, int length)\n{\n\tstruct gstd_tok\t*tok = the_tok;\n\tgss_buffer_desc\tin;\n\tOM_uint32\tmaj, min;\n\tint\t\tbufpos = tok->gstd_inbufpos;\n\tint\t\tret;\n\n\t/*\n\t * If we have no buffered data, read another packet and\n\t * reset the buffer.\n\t */\n\n\tif (bufpos == -1 || bufpos >= tok->gstd_inbuf.length) {\n\t\tif (tok->gstd_inbuf.length > 0)\n\t\t\tgss_release_buffer(&min, &tok->gstd_inbuf);\n\n\t\t/*\n\t\t * If we encounter a protocol botch or if the other side has\n\t\t * closed the connection, we return that fact here\n\t\t */\n\t\tret = read_packet(tok->gstd_fd, &in, 0, 0);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tmaj = gss_unwrap(&min, tok->gstd_ctx, &in, &tok->gstd_inbuf,\n\t\t    NULL, NULL);\n\t\tif (maj != GSS_S_COMPLETE) {\n\t\t\tgstd_error(LOG_ERR, min, \"gss_unwrap\");\n\t\t\treturn -1;\n\t\t}\n\t\tgss_release_buffer(&min, &in);\n\t\tbufpos = 0;\n\t}\n\n\t/*\n\t * Now we know that we have a buffered packet, so return\n\t * as much of it as we can.  We do not need to fill the\n\t * requestor's buffer, because stdio can deal with short\n\t * reads.\n\t */\n\n\tlength = MIN(length, tok->gstd_inbuf.length - bufpos);\n\tmemcpy(buf, tok->gstd_inbuf.value + bufpos, length);\n\ttok->gstd_inbufpos = bufpos + length;\n\tLOG(LOG_DEBUG, (\"read %d bytes\", length));\n\treturn length;\n}\n\n#if 0\nint\ngstd_write(work_t *work)\n{\n\tstruct gstd_tok\t*tok = work->the_tok;\n\tgss_buffer_desc\tin, out;\n\tOM_uint32\tmaj, min;\n\n\t/*\n\t * We clip the length at GSTD_MAXPACKETCONTENTS (+fudge) to make\n\t * the job of the receiver easier.\n\t */\n\n\tif (length <= 0)\t/* hmmm, error eh? */\n\t\treturn -1;\n\n\tif (length > GSTD_MAXPACKETCONTENTS)\n\t\tlength = GSTD_MAXPACKETCONTENTS;\n\n\tin.length = work->network_buffer.len;\n\tin.value  = (void *)work->network_buffer.buffer;\n\n\tmaj = gss_wrap(&min, tok->gstd_ctx, 1, GSS_C_QOP_DEFAULT,\n\t    &in, NULL, &out);\n\tGSTD_GSS_ERROR(maj, min, -1, \"gss_wrap\");\n\n\t/* should I loop on this one? */\n\tif (write_packet(tok->gstd_fd, &out))\n\t\treturn -1;\n\n\tLOG(LOG_DEBUG, (\"wrote %d bytes\", length));\n\treturn length;\n}\n\n#endif\n\nint\ngstd_close(void *the_tok)\n{\n\tstruct gstd_tok\t*tok = the_tok;\n\tOM_uint32\t min;\n\n\tgss_delete_sec_context(&min, &tok->gstd_ctx, GSS_C_NO_BUFFER);\n\tif (tok->gstd_inbuf.length > 0)\n\t\tgss_release_buffer(&min, &tok->gstd_inbuf);\n\tclose(tok->gstd_fd);\n\treturn 0;\n}\n\nstatic ssize_t\ntimed_read(int fd, void *buf, size_t bytes, int timeout)\n{\n\tstruct pollfd\t\tfds[1];\n\tint\t\t\tret;\n\n\tif (timeout > 0) {\n\t\tfds[0].fd = fd;\n\t\tfds[0].events = POLLIN;\n\n\t\tret = poll(fds, 1, timeout);\n\n\t\tif (ret == -1)\n\t\t\treturn -1;\n\n\t\tif (ret != 1) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn read(fd, buf, bytes);\n}\n\n/*\n * Returns:\n *\t-2\tNeed to call again\n *\t-1\tProtocol error\n *\t0\tNormal EOF (non-protocol error, other side is finished and\n *\t\thas simply closed the connection)\n *\t1       Data has been completely received\n */\nstatic int\nread_packet(int fd, gss_buffer_t buf, int timeout, int first)\n{\n\tint\t  ret;\n\n\tstatic uint32_t\t\tlen = 0;\n\tstatic char\t\tlen_buf[4];\n\tstatic int\t\tlen_buf_pos = 0;\n\tstatic char *\t\ttmpbuf = 0;\n\tstatic int\t\ttmpbuf_pos = 0;\n\n\tif (first) {\n\t\tlen_buf_pos = 0;\n\t\treturn -2;\n\t}\n\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ret == 0) {\t\t/* EOF */\n\t\t\t/* Failure to read ANY length just means we're done */\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Otherwise, we got EOF mid-length, and that's\n\t\t\t * a protocol error.\n\t\t\t */\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\tgoto bail;\n\t\t}\n\n\t\tlen_buf_pos += ret;\n\t}\n\n\t/* Not done reading the length? */\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\n\t/* We have the complete length */\n\tlen = ntohl(*(uint32_t *)len_buf);\n\n\t/*\n\t * We make sure recvd length is reasonable, allowing for some\n\t * slop in enc overhead, beyond the actual maximum number of\n\t * bytes of decrypted payload.\n\t */\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\tgoto bail;\n\t}\n\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\tgoto bail;\n\t}\n\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\tgoto bail;\n\t}\n\n\ttmpbuf_pos += ret;\n\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\n\treturn -2;\n\nbail:\n\tfree(tmpbuf);\n\ttmpbuf = NULL;\n\n\treturn -1;\n}\n\nstatic int\nwrite_packet(int fd, gss_buffer_t buf)\n{\n\tuint32_t\tlen;\n\tOM_uint32\tmin_stat;\n\tint\t\tret = 0;\n\n\tlen = htonl(buf->length);\n\tif ((writen(fd, &len, 4) != 4) ||\n\t    (writen(fd, buf->value, buf->length) != buf->length))\n\t\tret = -1;\n\n\tgss_release_buffer (&min_stat, buf);\n\treturn ret;\n}\n\n\n/*\n * The following function writes up to len bytes, returning -1 if it fails\n * to do so for any reason, and len otherwise.  Note, partial writes may\n * have occurred if this function returns -1\n */\nint\nwriten(int fd, const void *buf, ssize_t len) {\n\tint\tnleft;\n\tint\tnwritten;\n\tchar *\tbuffer = (char *)buf;\n\n\tnleft = len;\n\twhile (nleft > 0) {\n\t\tnwritten = write(fd, buffer, len);\n\n\t\tif (nwritten < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\telse {\n\t\t\t\tLOG_ERRNO(LOG_ERR, (\"write failed\"));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tnleft -= nwritten;\n\t\t\tbuffer += nwritten;\n\t\t}\n\t}\n\n\tLOG(LOG_DEBUG, (\"wrote %d bytes\", len));\n\treturn len;\n}\n\n\nstatic int\ngstd_errstring(char **str, int min_stat)\n{\n\tgss_buffer_desc\t status;\n\tOM_uint32\t new_stat;\n\tOM_uint32\t msg_ctx = 0;\n\tOM_uint32\t ret;\n\tint\t\t len = 0;\n\tchar\t\t*tmp;\n\tchar\t\t*statstr;\n\n\t/* XXXrcd this is not correct yet */\n\t/* XXXwps ...and now it is. */\n\n\tif (!str)\n\t\treturn -1;\n\n\t*str = NULL;\n\ttmp = NULL;\n\n\tdo {\n\t\tret = gss_display_status(&new_stat, min_stat,\n\t\t    GSS_C_MECH_CODE, GSS_C_NO_OID, &msg_ctx,\n\t\t    &status);\n\n\t\t/* GSSAPI strings are not NUL terminated */\n\t\tif ((statstr = (char *)malloc(status.length + 1)) == NULL) {\n\t\t\tLOG(LOG_ERR, (\"unable to malloc status string \"\n\t\t\t\t      \"of length %ld\", status.length));\n\t\t\tgss_release_buffer(&new_stat, &status);\n\t\t\tfree(statstr);\n\t\t\tfree(tmp);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmemcpy(statstr, status.value, status.length);\n\t\tstatstr[status.length] = '\\0';\n\n\t\tif (GSS_ERROR(ret)) {\n\t\t\tfree(statstr);\n\t\t\tfree(tmp);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*str) {\n\t\t\tif ((*str = malloc(strlen(*str) + status.length +\n\t\t\t\t\t   3)) == NULL) {\n\t\t\t\tLOG(LOG_ERR, (\"unable to malloc error \"\n\t\t\t\t\t\t\"string\"));\n\t\t\t\tgss_release_buffer(&new_stat, &status);\n\t\t\t\tfree(statstr);\n\t\t\t\tfree(tmp);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlen = sprintf(*str, \"%s, %s\", tmp, statstr);\n\t\t} else {\n\t\t\t*str = malloc(status.length + 1);\n\t\t\tif (!*str) {\n\t\t\t\tLOG(LOG_ERR, (\"unable to malloc error \"\n\t\t\t\t\t\t\"string\"));\n\t\t\t\tgss_release_buffer(&new_stat, &status);\n\t\t\t\tfree(statstr);\n\t\t\t\tfree(tmp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlen = sprintf(*str, \"%s\", (char *)statstr);\n\t\t}\n\n\t\tgss_release_buffer(&new_stat, &status);\n\t\tfree(statstr);\n\t\tfree(tmp);\n\n\t\ttmp = *str;\n\t} while (msg_ctx != 0);\n\n\treturn len;\n}\n\nvoid\ngstd_error(int pri, int min_stat, const char *s)\n{\n\tchar *t1;\n\n\tif (gstd_errstring(&t1, min_stat) < 1)\n\t\tLOG(pri, (\"%s: couldn't form GSSAPI error string\", s));\n\telse {\n\t\tLOG(pri, (\"%s: %s\", s, t1));\n\t\tfree(t1);\n\t}\n}\n\nvoid\ngstd_release_context(void *ctx) {\n\tOM_uint32\tmin;\n\n\tgss_delete_sec_context(&min, (gss_ctx_id_t *)ctx, GSS_C_NO_BUFFER);\n}\n"], "filenames": ["bin/gssstdio.c"], "buggy_code_start_loc": [222], "buggy_code_end_loc": [545], "fixing_code_start_loc": [223], "fixing_code_end_loc": [556], "type": "CWE-400", "message": "The read_packet function in knc (Kerberised NetCat) before 1.11-1 is vulnerable to denial of service (memory exhaustion) that can be exploited remotely without authentication, possibly affecting another services running on the targeted host.", "other": {"cve": {"id": "CVE-2017-9732", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-20T23:29:00.237", "lastModified": "2019-01-11T16:24:04.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The read_packet function in knc (Kerberised NetCat) before 1.11-1 is vulnerable to denial of service (memory exhaustion) that can be exploited remotely without authentication, possibly affecting another services running on the targeted host."}, {"lang": "es", "value": "La funci\u00f3n read_packet en knc (Kerberised NetCat) en versiones anteriores a la 1.11-1 es vulnerable a una denegaci\u00f3n de servicio (agotamiento de memoria) que puede explotarse de forma remota sin autenticaci\u00f3n y que podr\u00eda afectar a otros servicios que se ejecutan en el host objetivo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:secure-endpoints:kerberised_netcat:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.11-1", "matchCriteriaId": "FC734909-600C-43A3-AE43-DE7A0BD8A560"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/150534/knc-Kerberized-NetCat-Denial-Of-Service.html", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2018/Nov/65", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/elric1/knc/commit/f237f3e09ecbaf59c897f5046538a7b1a3fa40c1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/irsl/knc-memory-exhaustion/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/elric1/knc/commit/f237f3e09ecbaf59c897f5046538a7b1a3fa40c1"}}