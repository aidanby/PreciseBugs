{"buggy_code": ["/*\n===========================================================================\n\nReturn to Castle Wolfenstein single player GPL Source Code\nCopyright (C) 1999-2010 id Software LLC, a ZeniMax Media company. \n\nThis file is part of the Return to Castle Wolfenstein single player GPL Source Code (\u0093RTCW SP Source Code\u0094).  \n\nRTCW SP Source Code is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nRTCW SP Source Code is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with RTCW SP Source Code.  If not, see <http://www.gnu.org/licenses/>.\n\nIn addition, the RTCW SP Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the RTCW SP Source Code.  If not, please request a copy in writing from id Software at the address below.\n\nIf you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.\n\n===========================================================================\n*/\n\n//===========================================================================\n//\n// Name:\t\t\tai_cast_script.c\n// Function:\t\tWolfenstein AI Character Scripting\n// Programmer:\t\tRidah\n// Tab Size:\t\t4 (real tabs)\n//===========================================================================\n\n#include \"g_local.h\"\n#include \"../qcommon/q_shared.h\"\n#include \"../botlib/botlib.h\"      //bot lib interface\n#include \"../botlib/be_aas.h\"\n#include \"../botlib/be_ea.h\"\n#include \"../botlib/be_ai_gen.h\"\n#include \"../botlib/be_ai_goal.h\"\n#include \"../botlib/be_ai_move.h\"\n#include \"../botlib/botai.h\"          //bot ai interface\n\n#include \"ai_cast.h\"\n\n/*\nScripting that allows the designers to control the behaviour of AI characters\naccording to each different scenario.\n*/\n\n// action functions need to be declared here so they can be accessed in the scriptAction table\nqboolean AICast_ScriptAction_GotoMarker( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_WalkToMarker( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_CrouchToMarker( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_GotoCast( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_WalkToCast( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_CrouchToCast( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Wait( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_AbortIfLoadgame( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_Trigger( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_FollowCast( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_PlaySound( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoAttack( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Attack( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_PlayAnim( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_ClearAnim( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SetAmmo( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SetClip( cast_state_t *cs, char *params );\t\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_SelectWeapon( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_PlayerName( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_GiveArmor( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_SetArmor( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_SuggestWeapon( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_GiveWeapon( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_GiveInventory( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_TakeWeapon( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoRespawn( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_RandomRespawn( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Movetype( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_AlertEntity( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SaveGame( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_FireAtTarget( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_GodMode( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_GlobalAccum( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Accum( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SpawnCast( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_MissionFailed( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_ObjectiveMet( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_ObjectivesNeeded( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NumSecrets( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoAIDamage( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Print( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_FaceTargetAngles( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_ResetScript( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Mount( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Unmount( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SavePersistant( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_ChangeLevel( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_EndGame( cast_state_t *cs, char *params );\t\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_Teleport( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_FoundSecret( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoSight( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Sight( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoAvoid( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Avoid( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Attrib( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_DenyAction( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_LightningDamage( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Headlook( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_BackupScript( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_RestoreScript( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_StateType( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_KnockBack( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Zoom( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Parachute( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Cigarette( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_StartCam( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_StopCam( cast_state_t *cs, char *params );\t\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_StartCamBlack( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_EntityScriptName( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_AIScriptName( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SetHealth( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoTarget( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Cvar( cast_state_t *cs, char *params );\n\nqboolean AICast_ScriptAction_MusicStart( cast_state_t *cs, char *params );\t\t//----(SA)\nqboolean AICast_ScriptAction_MusicPlay( cast_state_t *cs, char *params );\t\t//----(SA)\nqboolean AICast_ScriptAction_MusicStop( cast_state_t *cs, char *params );\t\t//----(SA)\nqboolean AICast_ScriptAction_MusicFade( cast_state_t *cs, char *params );\t\t//----(SA)\nqboolean AICast_ScriptAction_MusicQueue( cast_state_t *cs, char *params );\t\t//----(SA)\n\nqboolean AICast_ScriptAction_ExplicitRouting( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_LockPlayer( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_AnimCondition( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_PushAway( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_CatchFire( cast_state_t *cs, char *params );\n\n// these are the actions that each event can call\ncast_script_stack_action_t scriptActions[] =\n{\n\t{\"gotomarker\",       AICast_ScriptAction_GotoMarker},\n\t{\"runtomarker\",      AICast_ScriptAction_GotoMarker},\n\t{\"walktomarker\", AICast_ScriptAction_WalkToMarker},\n\t{\"crouchtomarker\",   AICast_ScriptAction_CrouchToMarker},\n\t{\"gotocast\",     AICast_ScriptAction_GotoCast},\n\t{\"runtocast\",        AICast_ScriptAction_GotoCast},\n\t{\"walktocast\",       AICast_ScriptAction_WalkToCast},\n\t{\"crouchtocast\", AICast_ScriptAction_CrouchToCast},\n\t{\"followcast\",       AICast_ScriptAction_FollowCast},\n\t{\"playsound\",        AICast_ScriptAction_PlaySound},\n\t{\"playanim\",     AICast_ScriptAction_PlayAnim},\n\t{\"clearanim\",        AICast_ScriptAction_ClearAnim},\n\t{\"wait\",         AICast_ScriptAction_Wait},\n\t{\"abort_if_loadgame\",AICast_ScriptAction_AbortIfLoadgame},\t\t\t//----(SA)\tadded\n\t{\"trigger\",          AICast_ScriptAction_Trigger},\n\t{\"setammo\",          AICast_ScriptAction_SetAmmo},\n\t{\"setclip\",          AICast_ScriptAction_SetClip},\t\t\t\t//----(SA)\tadded\n\t{\"selectweapon\", AICast_ScriptAction_SelectWeapon},\n\t{\"playername\", AICast_ScriptAction_PlayerName},\n\t{\"noattack\",     AICast_ScriptAction_NoAttack},\n\t{\"suggestweapon\",    AICast_ScriptAction_SuggestWeapon},\t\t\t//----(SA)\tadded\n\t{\"attack\",           AICast_ScriptAction_Attack},\n\t{\"givearmor\",        AICast_ScriptAction_GiveArmor},\t\t\t\t//----(SA)\tadded\n\t{\"setarmor\",     AICast_ScriptAction_SetArmor},\t\t\t\t\t//----(SA)\tadded\n\t{\"giveinventory\",    AICast_ScriptAction_GiveInventory},\n\t{\"giveweapon\",       AICast_ScriptAction_GiveWeapon},\n\t{\"takeweapon\",       AICast_ScriptAction_TakeWeapon},\n\t{\"norespawn\",       AICast_ScriptAction_NoRespawn},\n\t{\"randomrespawn\",       AICast_ScriptAction_RandomRespawn},\n\t{\"movetype\",     AICast_ScriptAction_Movetype},\n\t{\"alertentity\",      AICast_ScriptAction_AlertEntity},\n\t{\"savegame\",     AICast_ScriptAction_SaveGame},\n\t{\"fireattarget\", AICast_ScriptAction_FireAtTarget},\n\t{\"godmode\",          AICast_ScriptAction_GodMode},\n\t{\"globalaccum\",      AICast_ScriptAction_GlobalAccum},\n\t{\"accum\",            AICast_ScriptAction_Accum},\n\t{\"spawncast\",        AICast_ScriptAction_SpawnCast},\n\t{\"missionfailed\",    AICast_ScriptAction_MissionFailed},\n\t{\"missionsuccess\",   AICast_ScriptAction_ObjectiveMet},\n\t{\"objectivemet\", AICast_ScriptAction_ObjectiveMet},\t\t\t\t// dupe of missionsuccess so scripts can changeover to a more logical name\n\t{\"objectivesneeded\",AICast_ScriptAction_ObjectivesNeeded},\n\t{\"numsecrets\",AICast_ScriptAction_NumSecrets},\n\t{\"noaidamage\",       AICast_ScriptAction_NoAIDamage},\n\t{\"print\",            AICast_ScriptAction_Print},\n\t{\"facetargetangles\",AICast_ScriptAction_FaceTargetAngles},\n\t{\"resetscript\",      AICast_ScriptAction_ResetScript},\n\t{\"mount\",            AICast_ScriptAction_Mount},\n\t{\"unmount\",          AICast_ScriptAction_Unmount},\n\t{\"savepersistant\",   AICast_ScriptAction_SavePersistant},\n\t{\"changelevel\",      AICast_ScriptAction_ChangeLevel},\n\t{\"endgame\",          AICast_ScriptAction_EndGame},\t\t\t\t//----(SA)\tadded\n\t{\"teleport\",     AICast_ScriptAction_Teleport},\t\t\t\t\t//----(SA)\tadded\n\t{\"foundsecret\",      AICast_ScriptAction_FoundSecret},\n\t{\"nosight\",          AICast_ScriptAction_NoSight},\n\t{\"sight\",            AICast_ScriptAction_Sight},\n\t{\"noavoid\",          AICast_ScriptAction_NoAvoid},\n\t{\"avoid\",            AICast_ScriptAction_Avoid},\n\t{\"attrib\",           AICast_ScriptAction_Attrib},\n\t{\"denyactivate\", AICast_ScriptAction_DenyAction},\n\t{\"lightningdamage\",  AICast_ScriptAction_LightningDamage},\n\t{\"deny\",         AICast_ScriptAction_DenyAction},\n\t{\"headlook\",     AICast_ScriptAction_Headlook},\n\t{\"backupscript\", AICast_ScriptAction_BackupScript},\n\t{\"restorescript\",    AICast_ScriptAction_RestoreScript},\n\t{\"statetype\",        AICast_ScriptAction_StateType},\n\t{\"knockback\",        AICast_ScriptAction_KnockBack},\n\t{\"zoom\",         AICast_ScriptAction_Zoom},\n\t{\"parachute\",        AICast_ScriptAction_Parachute},\n\t{\"cigarette\",        AICast_ScriptAction_Cigarette},\t\t\t\t//----(SA)\tadded\n\t{\"startcam\",     AICast_ScriptAction_StartCam},\n\t{\"startcamblack\",    AICast_ScriptAction_StartCamBlack},\n\t{\"stopcam\",          AICast_ScriptAction_StopCam},\t\t\t\t//----(SA)\tadded\n\t{\"entityscriptname\",AICast_ScriptAction_EntityScriptName},\n\t{\"aiscriptname\", AICast_ScriptAction_AIScriptName},\n\t{\"sethealth\",        AICast_ScriptAction_SetHealth},\n\t{\"notarget\",     AICast_ScriptAction_NoTarget},\n\t{\"cvar\",         AICast_ScriptAction_Cvar},\n\n//----(SA)\tadded some music interface\n\t{\"mu_start\",     AICast_ScriptAction_MusicStart},\t\t\t// (char *new_music, int time)\t// time to fade in\n\t{\"mu_play\",          AICast_ScriptAction_MusicPlay},\t\t// (char *new_music)\n\t{\"mu_stop\",          AICast_ScriptAction_MusicStop},\t\t// (int time)\t// time to fadeout\n\t{\"mu_fade\",          AICast_ScriptAction_MusicFade},\t\t// (float target_volume, int time)\t// time to fade to target\n\t{\"mu_queue\",     AICast_ScriptAction_MusicQueue},\t\t\t// (char *new_music)\t// music that will start when previous fades to 0\n//----(SA)\tend\n\n\t{\"explicit_routing\", AICast_ScriptAction_ExplicitRouting},\n\t{\"lockplayer\",       AICast_ScriptAction_LockPlayer},\n\t{\"anim_condition\",   AICast_ScriptAction_AnimCondition},\n\t{\"pushaway\",     AICast_ScriptAction_PushAway},\n\t{\"catchfire\",        AICast_ScriptAction_CatchFire},\n\n\t{NULL,              0}\n};\n\nqboolean AICast_EventMatch_StringEqual( cast_script_event_t *event, char *eventParm );\nqboolean AICast_EventMatch_IntInRange( cast_script_event_t *event, char *eventParm );\n\n// the list of events that can start an action sequence\n// NOTE!!: only append to this list, DO NOT INSERT!!\ncast_script_event_define_t scriptEvents[] =\n{\n\t{\"spawn\",            0},          // called as each character is spawned into the game\n\t{\"playerstart\",      0},          // called when player hits 'start' button\n\t{\"enemysight\",       AICast_EventMatch_StringEqual}, // enemy has been sighted for the first time (once only)\n\t{\"sight\",            AICast_EventMatch_StringEqual}, // non-enemy has been sighted for the first time (once only)\n\t{\"enemydead\",        AICast_EventMatch_StringEqual}, // our enemy is now dead\n\t{\"trigger\",          AICast_EventMatch_StringEqual}, // something has triggered us (always followed by an identifier)\n\t{\"pain\",         AICast_EventMatch_IntInRange},  // we've been hurt\n\t{\"death\",            AICast_EventMatch_StringEqual},\t// RIP\n\t{\"activate\",     AICast_EventMatch_StringEqual}, // \"param\" has just activated us\n\t{\"enemysightcorpse\",AICast_EventMatch_StringEqual},  // sighted the given enemy as a corpse, for the first time\n\t{\"friendlysightcorpse\", 0},                       // sighted a friendly as a corpse for the first time\n\t{\"avoiddanger\",      AICast_EventMatch_StringEqual}, // we are avoiding something dangerous\n\t{\"blocked\",          AICast_EventMatch_StringEqual}, // blocked by someone else\n\t{\"statechange\",      AICast_EventMatch_StringEqual}, // changing aistates\n\t{\"bulletimpact\", 0},\n\t{\"inspectbodystart\", AICast_EventMatch_StringEqual}, // starting to travel to body for inspection\n\t{\"inspectbodyend\",   AICast_EventMatch_StringEqual}, // reached body for inspection\n\t{\"inspectsoundstart\",    AICast_EventMatch_StringEqual}, // reached sound for inspection\n\t{\"inspectsoundend\",  AICast_EventMatch_StringEqual}, // reached sound for inspection\n\t{\"attacksound\",      AICast_EventMatch_StringEqual}, // play a custom attack sound, and/or deny playing the default sound\n\t{\"fakedeath\",        0},\n\t{\"bulletimpactsound\",    0},\n\t{\"inspectfriendlycombatstart\", 0},\n\t{\"painenemy\",        AICast_EventMatch_StringEqual},\n\t{\"forced_mg42_unmount\",  0},\n\n\t{NULL,              0}\n};\n\n\n/*\n===============\nAICast_EventMatch_StringEqual\n===============\n*/\nqboolean AICast_EventMatch_StringEqual( cast_script_event_t *event, char *eventParm ) {\n\tif ( !event->params || !event->params[0] || ( eventParm && !Q_strcasecmp( event->params, eventParm ) ) ) {\n\t\treturn qtrue;\n\t} else {\n\t\treturn qfalse;\n\t}\n}\n\n/*\n===============\nAICast_EventMatch_IntInRange\n===============\n*/\nqboolean AICast_EventMatch_IntInRange( cast_script_event_t *event, char *eventParm ) {\n\tchar *pString, *token;\n\tint int1, int2, eInt;\n\n\t// get the cast name\n\tpString = eventParm;\n\ttoken = COM_ParseExt( &pString, qfalse );\n\tint1 = atoi( token );\n\ttoken = COM_ParseExt( &pString, qfalse );\n\tint2 = atoi( token );\n\n\teInt = atoi( event->params );\n\n\tif ( eventParm && eInt > int1 && eInt <= int2 ) {\n\t\treturn qtrue;\n\t} else {\n\t\treturn qfalse;\n\t}\n}\n\n/*\n===============\nAICast_EventForString\n===============\n*/\nint AICast_EventForString( char *string ) {\n\tint i;\n\n\tfor ( i = 0; scriptEvents[i].eventStr; i++ )\n\t{\n\t\tif ( !Q_strcasecmp( string, scriptEvents[i].eventStr ) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/*\n===============\nAICast_ActionForString\n===============\n*/\ncast_script_stack_action_t *AICast_ActionForString( cast_state_t *cs, char *string ) {\n\tint i;\n\n\tfor ( i = 0; scriptActions[i].actionString; i++ )\n\t{\n\t\tif ( !Q_strcasecmp( string, scriptActions[i].actionString ) ) {\n\t\t\t// this is now ignored - use the numsecrets function\n\t\t\t/*\n\t\t\tif ( !Q_strcasecmp( string, \"foundsecret\" ) ) {\n\t\t\t\tlevel.numSecrets++;\n\t\t\t\tG_SendMissionStats();\n\t\t\t}\n\t\t\t*/\n\t\t\treturn &scriptActions[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n=============\nAICast_ScriptLoad\n\n  Loads the script for the current level into the buffer\n=============\n*/\nvoid AICast_ScriptLoad( void ) {\n\tchar filename[MAX_QPATH];\n\tvmCvar_t mapname;\n\tfileHandle_t f;\n\tint len;\n\n\tlevel.scriptAI = NULL;\n\n\ttrap_Cvar_VariableStringBuffer( \"ai_scriptName\", filename, sizeof( filename ) );\n\tif ( strlen( filename ) > 0 ) {\n\t\ttrap_Cvar_Register( &mapname, \"ai_scriptName\", \"\", CVAR_ROM );\n\t} else {\n\t\ttrap_Cvar_Register( &mapname, \"mapname\", \"\", CVAR_SERVERINFO | CVAR_ROM );\n\t}\n\tQ_strncpyz( filename, \"maps/\", sizeof( filename ) );\n\tQ_strcat( filename, sizeof( filename ), mapname.string );\n\tif ( g_gametype.integer <= GT_COOP ) {\n\t\tQ_strcat( filename, sizeof( filename ), \".coop.ai\" );\n\t} else {\n\t\tQ_strcat( filename, sizeof( filename ), \".ai\" );\n\t}\n\n\tlen = trap_FS_FOpenFile( filename, &f, FS_READ );\n\n\tG_Printf( \"Loading: %s\\n\", filename );\n\n\tif ( len < 0 ) {\n\t\treturn;\n\t}\n\n\tlevel.scriptAI = G_Alloc( len );\n\ttrap_FS_Read( level.scriptAI, len, f );\n\n\ttrap_FS_FCloseFile( f );\n\n\treturn;\n}\n\n/*\n==============\nAICast_ScriptParse\n\n  Parses the script for the given character\n==============\n*/\n#define MAX_SCRIPT_EVENTS   64\ncast_script_event_t cast_temp_events[MAX_SCRIPT_EVENTS];\nvoid AICast_ScriptParse( cast_state_t *cs ) {\n\tgentity_t   *ent;\n\tchar        *pScript;\n\tchar        *token;\n\tqboolean wantName;\n\tqboolean inScript;\n\tint eventNum;\n\tint numEventItems;\n\tcast_script_event_t *curEvent;\n\tchar params[MAX_QPATH];\n\tcast_script_stack_action_t  *action;\n\tint i;\n\tint bracketLevel;\n\tqboolean buildScript;       //----(SA)\tadded\n\n\tif ( !level.scriptAI ) {\n\t\treturn;\n\t}\n\n\tent = &g_entities[cs->entityNum];\n\tif ( !ent->aiName ) {\n\t\treturn;\n\t}\n\n\tbuildScript = qtrue;\n\n\tpScript = level.scriptAI;\n\twantName = qtrue;\n\tinScript = qfalse;\n\tCOM_BeginParseSession( \"AICast_ScriptParse\" );\n\tbracketLevel = 0;\n\tnumEventItems = 0;\n\n\tmemset( cast_temp_events, 0, sizeof( cast_temp_events ) );\n\n\twhile ( 1 )\n\t{\n\t\ttoken = COM_Parse( &pScript );\n\n\t\tif ( !token[0] ) {\n\t\t\tif ( !wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// end of script\n\t\tif ( token[0] == '}' ) {\n\t\t\tif ( inScript ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' found, but not expected.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t\twantName = qtrue;\n\t\t} else if ( token[0] == '{' )    {\n\t\t\tif ( wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '{' found, NAME expected.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t} else if ( wantName )   {\n\t\t\tif ( !Q_strcasecmp( ent->aiName, token ) ) {\n\t\t\t\tinScript = qtrue;\n\t\t\t\tnumEventItems = 0;\n\t\t\t}\n\t\t\twantName = qfalse;\n\t\t} else if ( inScript )   {\n\t\t\tif ( !Q_strcasecmp( token, \"attributes\" ) ) {\n\t\t\t\t// read in all the attributes\n\t\t\t\tAICast_CheckLevelAttributes( cs, ent, &pScript );\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\teventNum = AICast_EventForString( token );\n\t\t\tif ( eventNum < 0 ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown event: %s.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t}\n\t\t\tif ( numEventItems >= MAX_SCRIPT_EVENTS ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): MAX_SCRIPT_EVENTS reached (%d)\\n\", COM_GetCurrentParseLine(), MAX_SCRIPT_EVENTS );\n\t\t\t}\n\n\t\t\t// if this is a \"friendlysightcorpse\" event, then disable corpse vis sharing\n\t\t\tif ( !Q_stricmp( token, \"friendlysightcorpse\" ) ) {\n\t\t\t\tcs->aiFlags &= ~AIFL_CORPSESIGHTING;\n\t\t\t}\n\n\t\t\tcurEvent = &cast_temp_events[numEventItems];\n\t\t\tcurEvent->eventNum = eventNum;\n\t\t\tmemset( params, 0, sizeof( params ) );\n\n\t\t\t// parse any event params before the start of this event's actions\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '{' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\tif ( eventNum == 13 ) {   // statechange event, check params\n\t\t\t\t\tif ( strlen( token ) > 1 ) {\n\t\t\t\t\t\tif ( BG_IndexForString( token, animStateStr, qtrue ) < 0 ) {\n\t\t\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown state type '%s'.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t}\n\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\t\t\t}\n\n\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\tcurEvent->params = G_Alloc( strlen( params ) + 1 );\n\t\t\t\tQ_strncpyz( curEvent->params, params, strlen( params ) + 1 );\n\t\t\t}\n\n\t\t\t// parse the actions for this event\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\taction = AICast_ActionForString( cs, token );\n\t\t\t\tif ( !action ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown action: %s.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].action = action;\n\n\t\t\t\tmemset( params, 0, sizeof( params ) );\n\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\tfor ( i = 0; token[0]; i++ )\n\t\t\t\t{\n\t\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( i == 0 ) {\n\t\t\t\t\t\t// Special case: playsound's need to be cached on startup to prevent in-game pauses\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"playsound\" ) ) {\n\t\t\t\t\t\t\tG_SoundIndex( token );\n\t\t\t\t\t\t}\n\n//----(SA)\tadded a bit more\n\t\t\t\t\t\tif (    buildScript && (\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_start\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_play\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_queue\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"startcam\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"startcamblack\" ) )\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif ( strlen( token ) ) { // we know there's a [0], but don't know if it's '0'\n\t\t\t\t\t\t\t\ttrap_SendServerCommand( cs->entityNum, va( \"addToBuild %s\\n\", token ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"giveweapon\" ) ) { // register weapon for client pre-loading\n\t\t\t\t\t\t\tgitem_t *weap = BG_FindItem2( token );    // (SA) FIXME: rats, need to fix this for weapon names with spaces: 'mauser rifle'\n//\t\t\t\t\t\t\tif(weap)\n\t\t\t\t\t\t\tRegisterItem( weap );   // don't be nice, just do it.  if it can't find it, you'll bomb out to the error menu\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// need to get this for callvote nextmap\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"changelevel\" ) ) {\n\t\t\t\t\t\t\tQ_strncpyz( level.nextMap, token, sizeof( level.nextMap ) );\n\t\t\t\t\t\t\ttrap_Cvar_Set( \"nextmap\", level.nextMap );\n\t\t\t\t\t\t}\n//----(SA)\tend\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = G_Alloc( strlen( params ) + 1 );\n\t\t\t\t\tQ_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.numItems++;\n\n\t\t\t\tif ( curEvent->stack.numItems >= AICAST_MAX_SCRIPT_STACK_ITEMS ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\\n\", AICAST_MAX_SCRIPT_STACK_ITEMS, COM_GetCurrentParseLine() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnumEventItems++;\n\t\t} else    // skip this character completely\n\t\t{\n\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t} else if ( token[0] == '{' ) {\n\t\t\t\t\tbracketLevel++;\n\t\t\t\t} else if ( token[0] == '}' ) {\n\t\t\t\t\tif ( !--bracketLevel ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// alloc and copy the events into the cast_state_t for this cast\n\tif ( numEventItems > 0 ) {\n\t\tcs->castScriptEvents = G_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n\t\tmemcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );\n\t\tcs->numCastScriptEvents = numEventItems;\n\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t}\n}\n\n/*\n================\nAICast_ScriptChange\n================\n*/\nvoid AICast_ScriptChange( cast_state_t *cs, int newScriptNum ) {\n\tcast_script_status_t scriptStatusBackup;\n\n\tcs->scriptCallIndex++;\n\n\t// backup the current scripting\n\tscriptStatusBackup = cs->castScriptStatus;\n\n\t// set the new script to this cast, and reset script status\n\tcs->castScriptStatus.castScriptStackHead = 0;\n\tcs->castScriptStatus.castScriptStackChangeTime = level.time;\n\tcs->castScriptStatus.castScriptEventIndex = newScriptNum;\n\tcs->castScriptStatus.scriptId = scriptStatusBackup.scriptId + 1;\n\tcs->castScriptStatus.scriptGotoId = -1;\n\tcs->castScriptStatus.scriptGotoEnt = -1;\n\tcs->castScriptStatus.scriptFlags |= SFL_FIRST_CALL;\n\n\t// try and run the script, if it doesn't finish, then abort the current script (discard backup)\n\tif ( AICast_ScriptRun( cs, qtrue ) ) {\n\t\t// completed successfully\n\t\tcs->castScriptStatus.castScriptStackHead = scriptStatusBackup.castScriptStackHead;\n\t\tcs->castScriptStatus.castScriptStackChangeTime = scriptStatusBackup.castScriptStackChangeTime;\n\t\tcs->castScriptStatus.castScriptEventIndex = scriptStatusBackup.castScriptEventIndex;\n\t\tcs->castScriptStatus.scriptId = scriptStatusBackup.scriptId;\n\t\tcs->castScriptStatus.scriptFlags = scriptStatusBackup.scriptFlags;\n\t}\n}\n\n/*\n================\nAICast_ScriptEvent\n\n  An event has occured, for which a script may exist\n================\n*/\nvoid AICast_ScriptEvent( struct cast_state_s *cs, char *eventStr, char *params ) {\n\tint i, eventNum;\n\n\teventNum = -1;\n\n\t// find out which event this is\n\tfor ( i = 0; scriptEvents[i].eventStr; i++ )\n\t{\n\t\tif ( !Q_strcasecmp( eventStr, scriptEvents[i].eventStr ) ) { // match found\n\t\t\teventNum = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( eventNum < 0 ) {\n\t\tif ( g_cheats.integer ) { // dev mode\n\t\t\tG_Printf( \"devmode-> AICast_ScriptEvent(), unknown event: %s\\n\", eventStr );\n\t\t}\n\t}\n\n\t// show debugging info\n\tif (    (   ( aicast_debug.integer == 1 ) ||\n\t\t\t\t(   ( aicast_debug.integer == 2 ) &&\n\t\t\t\t\t( ( strlen( aicast_debugname.string ) < 1 ) || ( g_entities[cs->entityNum].aiName && !strcmp( aicast_debugname.string, g_entities[cs->entityNum].aiName ) ) ) ) ) ) {\n\t\tG_Printf( \"(%s) AIScript event: %s %s \", g_entities[cs->entityNum].aiName, eventStr, params );\n\t}\n\n\tcs->aiFlags &= ~AIFL_DENYACTION;\n\n\t// see if this cast has this event\n\tfor ( i = 0; i < cs->numCastScriptEvents; i++ )\n\t{\n\t\tif ( cs->castScriptEvents[i].eventNum == eventNum ) {\n\t\t\tif (    ( !cs->castScriptEvents[i].params )\n\t\t\t\t\t||  ( !scriptEvents[eventNum].eventMatch || scriptEvents[eventNum].eventMatch( &cs->castScriptEvents[i], params ) ) ) {\n\n\t\t\t\t// show debugging info\n\t\t\t\tif (    (   ( aicast_debug.integer == 1 ) ||\n\t\t\t\t\t\t\t(   ( aicast_debug.integer == 2 ) &&\n\t\t\t\t\t\t\t\t( ( strlen( aicast_debugname.string ) < 1 ) || ( g_entities[cs->entityNum].aiName && !strcmp( aicast_debugname.string, g_entities[cs->entityNum].aiName ) ) ) ) ) ) {\n\t\t\t\t\tG_Printf( \"found, calling script: (%s) %s %s\\n\", g_entities[cs->entityNum].aiName, eventStr, params );\n\t\t\t\t}\n\n\t\t\t\tAICast_ScriptChange( cs, i );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// show debugging info\n\tif (    (   ( aicast_debug.integer == 1 ) ||\n\t\t\t\t(   ( aicast_debug.integer == 2 ) &&\n\t\t\t\t\t( ( strlen( aicast_debugname.string ) < 1 ) || ( g_entities[cs->entityNum].aiName && !strcmp( aicast_debugname.string, g_entities[cs->entityNum].aiName ) ) ) ) ) ) {\n\t\tif ( i == cs->numCastScriptEvents ) {\n\t\t\tG_Printf( \"not found\\n\" );\n\t\t}\n\t}\n\n}\n\n/*\n================\nAICast_ForceScriptEvent\n\n  Definately run this event now, overriding any paised state\n================\n*/\nvoid AICast_ForceScriptEvent( struct cast_state_s *cs, char *eventStr, char *params ) {\n\tint oldPauseTime;\n\n\toldPauseTime = cs->scriptPauseTime;\n\tcs->scriptPauseTime = 0;\n\n\tAICast_ScriptEvent( cs, eventStr, params );\n\n\tcs->scriptPauseTime = oldPauseTime;\n}\n\n/*\n=============\nAICast_ScriptRun\n\n  returns qtrue if the script completed\n=============\n*/\nqboolean AICast_ScriptRun( cast_state_t *cs, qboolean force ) {\n\tcast_script_stack_t *stack;\n\n\tif ( !aicast_scripts.integer ) {\n\t\treturn qtrue;\n\t}\n\n\tif ( cs->castScriptStatus.castScriptEventIndex < 0 ) {\n\t\treturn qtrue;\n\t}\n\n\tif ( !cs->castScriptEvents ) {\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t\treturn qtrue;\n\t}\n\n\t// only allow the PLAYER'S spawn function through if we're NOT still waiting on everything to finish loading in\n\tif ( !cs->entityNum && saveGamePending && Q_stricmp( \"spawn\", scriptEvents[cs->castScriptEvents[cs->castScriptStatus.castScriptEventIndex].eventNum].eventStr ) ) {\n\t\t//char loading[4];\n\t\t//trap_Cvar_VariableStringBuffer( \"savegame_loading\", loading, sizeof(loading) );\n\t\t//if (strlen( loading ) > 0 && atoi(loading) != 0)\t// we're loading a savegame\n\t\treturn qfalse;\n\t}\n\n\tif ( !force && ( cs->scriptPauseTime >= level.time ) ) {\n\t\treturn qtrue;\n\t}\n\n\tstack = &cs->castScriptEvents[cs->castScriptStatus.castScriptEventIndex].stack;\n\n\tif ( !stack->numItems ) {\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t\treturn qtrue;\n\t}\n\n\twhile ( cs->castScriptStatus.castScriptStackHead < stack->numItems )\n\t{\n\t\t//\n\t\t// show debugging info\n\t\tif (    ( cs->castScriptStatus.castScriptStackChangeTime == level.time ) &&\n\t\t\t\t(   ( aicast_debug.integer == 1 ) ||\n\t\t\t\t\t(   ( aicast_debug.integer == 2 ) &&\n\t\t\t\t\t\t( ( strlen( aicast_debugname.string ) < 1 ) || ( g_entities[cs->entityNum].aiName && !strcmp( aicast_debugname.string, g_entities[cs->entityNum].aiName ) ) ) ) ) ) {\n\t\t\tG_Printf( \"(%s) AIScript command: %s %s\\n\", g_entities[cs->entityNum].aiName, stack->items[cs->castScriptStatus.castScriptStackHead].action->actionString, ( stack->items[cs->castScriptStatus.castScriptStackHead].params ? stack->items[cs->castScriptStatus.castScriptStackHead].params : \"\" ) );\n\t\t}\n\t\t//\n\t\tif ( !stack->items[cs->castScriptStatus.castScriptStackHead].action->actionFunc( cs, stack->items[cs->castScriptStatus.castScriptStackHead].params ) ) {\n\t\t\t// check that we are still running the same script that we were when we call the action\n\t\t\tif ( cs->castScriptStatus.castScriptEventIndex >= 0 && stack == &cs->castScriptEvents[cs->castScriptStatus.castScriptEventIndex].stack ) {\n\t\t\t\tcs->castScriptStatus.scriptFlags &= ~SFL_FIRST_CALL;\n\t\t\t}\n\t\t\treturn qfalse;\n\t\t}\n\t\t// move to the next action in the script\n\t\tcs->castScriptStatus.castScriptStackHead++;\n\t\t// record the time that this new item became active\n\t\tcs->castScriptStatus.castScriptStackChangeTime = level.time;\n\t\t// reset misc stuff\n\t\tcs->castScriptStatus.scriptGotoId = -1;\n\t\tcs->castScriptStatus.scriptGotoEnt = -1;\n\t\tcs->castScriptStatus.scriptFlags |= SFL_FIRST_CALL;\n\t}\n\n\tcs->castScriptStatus.castScriptEventIndex = -1;\n\n\treturn qtrue;\n}\n"], "fixing_code": ["/*\n===========================================================================\n\nReturn to Castle Wolfenstein single player GPL Source Code\nCopyright (C) 1999-2010 id Software LLC, a ZeniMax Media company. \n\nThis file is part of the Return to Castle Wolfenstein single player GPL Source Code (\u0093RTCW SP Source Code\u0094).  \n\nRTCW SP Source Code is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nRTCW SP Source Code is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with RTCW SP Source Code.  If not, see <http://www.gnu.org/licenses/>.\n\nIn addition, the RTCW SP Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the RTCW SP Source Code.  If not, please request a copy in writing from id Software at the address below.\n\nIf you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.\n\n===========================================================================\n*/\n\n//===========================================================================\n//\n// Name:\t\t\tai_cast_script.c\n// Function:\t\tWolfenstein AI Character Scripting\n// Programmer:\t\tRidah\n// Tab Size:\t\t4 (real tabs)\n//===========================================================================\n\n#include \"g_local.h\"\n#include \"../qcommon/q_shared.h\"\n#include \"../botlib/botlib.h\"      //bot lib interface\n#include \"../botlib/be_aas.h\"\n#include \"../botlib/be_ea.h\"\n#include \"../botlib/be_ai_gen.h\"\n#include \"../botlib/be_ai_goal.h\"\n#include \"../botlib/be_ai_move.h\"\n#include \"../botlib/botai.h\"          //bot ai interface\n\n#include \"ai_cast.h\"\n\n/*\nScripting that allows the designers to control the behaviour of AI characters\naccording to each different scenario.\n*/\n\n// action functions need to be declared here so they can be accessed in the scriptAction table\nqboolean AICast_ScriptAction_GotoMarker( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_WalkToMarker( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_CrouchToMarker( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_GotoCast( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_WalkToCast( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_CrouchToCast( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Wait( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_AbortIfLoadgame( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_Trigger( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_FollowCast( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_PlaySound( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoAttack( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Attack( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_PlayAnim( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_ClearAnim( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SetAmmo( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SetClip( cast_state_t *cs, char *params );\t\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_SelectWeapon( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_PlayerName( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_GiveArmor( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_SetArmor( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_SuggestWeapon( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_GiveWeapon( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_GiveInventory( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_TakeWeapon( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoRespawn( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_RandomRespawn( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Movetype( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_AlertEntity( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SaveGame( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_FireAtTarget( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_GodMode( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_GlobalAccum( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Accum( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SpawnCast( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_MissionFailed( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_ObjectiveMet( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_ObjectivesNeeded( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NumSecrets( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoAIDamage( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Print( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_FaceTargetAngles( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_ResetScript( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Mount( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Unmount( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SavePersistant( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_ChangeLevel( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_EndGame( cast_state_t *cs, char *params );\t\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_Teleport( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_FoundSecret( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoSight( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Sight( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoAvoid( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Avoid( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Attrib( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_DenyAction( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_LightningDamage( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Headlook( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_BackupScript( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_RestoreScript( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_StateType( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_KnockBack( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Zoom( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Parachute( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Cigarette( cast_state_t *cs, char *params );\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_StartCam( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_StopCam( cast_state_t *cs, char *params );\t\t\t//----(SA)\tadded\nqboolean AICast_ScriptAction_StartCamBlack( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_EntityScriptName( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_AIScriptName( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_SetHealth( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_NoTarget( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_Cvar( cast_state_t *cs, char *params );\n\nqboolean AICast_ScriptAction_MusicStart( cast_state_t *cs, char *params );\t\t//----(SA)\nqboolean AICast_ScriptAction_MusicPlay( cast_state_t *cs, char *params );\t\t//----(SA)\nqboolean AICast_ScriptAction_MusicStop( cast_state_t *cs, char *params );\t\t//----(SA)\nqboolean AICast_ScriptAction_MusicFade( cast_state_t *cs, char *params );\t\t//----(SA)\nqboolean AICast_ScriptAction_MusicQueue( cast_state_t *cs, char *params );\t\t//----(SA)\n\nqboolean AICast_ScriptAction_ExplicitRouting( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_LockPlayer( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_AnimCondition( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_PushAway( cast_state_t *cs, char *params );\nqboolean AICast_ScriptAction_CatchFire( cast_state_t *cs, char *params );\n\n// these are the actions that each event can call\ncast_script_stack_action_t scriptActions[] =\n{\n\t{\"gotomarker\",       AICast_ScriptAction_GotoMarker},\n\t{\"runtomarker\",      AICast_ScriptAction_GotoMarker},\n\t{\"walktomarker\", AICast_ScriptAction_WalkToMarker},\n\t{\"crouchtomarker\",   AICast_ScriptAction_CrouchToMarker},\n\t{\"gotocast\",     AICast_ScriptAction_GotoCast},\n\t{\"runtocast\",        AICast_ScriptAction_GotoCast},\n\t{\"walktocast\",       AICast_ScriptAction_WalkToCast},\n\t{\"crouchtocast\", AICast_ScriptAction_CrouchToCast},\n\t{\"followcast\",       AICast_ScriptAction_FollowCast},\n\t{\"playsound\",        AICast_ScriptAction_PlaySound},\n\t{\"playanim\",     AICast_ScriptAction_PlayAnim},\n\t{\"clearanim\",        AICast_ScriptAction_ClearAnim},\n\t{\"wait\",         AICast_ScriptAction_Wait},\n\t{\"abort_if_loadgame\",AICast_ScriptAction_AbortIfLoadgame},\t\t\t//----(SA)\tadded\n\t{\"trigger\",          AICast_ScriptAction_Trigger},\n\t{\"setammo\",          AICast_ScriptAction_SetAmmo},\n\t{\"setclip\",          AICast_ScriptAction_SetClip},\t\t\t\t//----(SA)\tadded\n\t{\"selectweapon\", AICast_ScriptAction_SelectWeapon},\n\t{\"playername\", AICast_ScriptAction_PlayerName},\n\t{\"noattack\",     AICast_ScriptAction_NoAttack},\n\t{\"suggestweapon\",    AICast_ScriptAction_SuggestWeapon},\t\t\t//----(SA)\tadded\n\t{\"attack\",           AICast_ScriptAction_Attack},\n\t{\"givearmor\",        AICast_ScriptAction_GiveArmor},\t\t\t\t//----(SA)\tadded\n\t{\"setarmor\",     AICast_ScriptAction_SetArmor},\t\t\t\t\t//----(SA)\tadded\n\t{\"giveinventory\",    AICast_ScriptAction_GiveInventory},\n\t{\"giveweapon\",       AICast_ScriptAction_GiveWeapon},\n\t{\"takeweapon\",       AICast_ScriptAction_TakeWeapon},\n\t{\"norespawn\",       AICast_ScriptAction_NoRespawn},\n\t{\"randomrespawn\",       AICast_ScriptAction_RandomRespawn},\n\t{\"movetype\",     AICast_ScriptAction_Movetype},\n\t{\"alertentity\",      AICast_ScriptAction_AlertEntity},\n\t{\"savegame\",     AICast_ScriptAction_SaveGame},\n\t{\"fireattarget\", AICast_ScriptAction_FireAtTarget},\n\t{\"godmode\",          AICast_ScriptAction_GodMode},\n\t{\"globalaccum\",      AICast_ScriptAction_GlobalAccum},\n\t{\"accum\",            AICast_ScriptAction_Accum},\n\t{\"spawncast\",        AICast_ScriptAction_SpawnCast},\n\t{\"missionfailed\",    AICast_ScriptAction_MissionFailed},\n\t{\"missionsuccess\",   AICast_ScriptAction_ObjectiveMet},\n\t{\"objectivemet\", AICast_ScriptAction_ObjectiveMet},\t\t\t\t// dupe of missionsuccess so scripts can changeover to a more logical name\n\t{\"objectivesneeded\",AICast_ScriptAction_ObjectivesNeeded},\n\t{\"numsecrets\",AICast_ScriptAction_NumSecrets},\n\t{\"noaidamage\",       AICast_ScriptAction_NoAIDamage},\n\t{\"print\",            AICast_ScriptAction_Print},\n\t{\"facetargetangles\",AICast_ScriptAction_FaceTargetAngles},\n\t{\"resetscript\",      AICast_ScriptAction_ResetScript},\n\t{\"mount\",            AICast_ScriptAction_Mount},\n\t{\"unmount\",          AICast_ScriptAction_Unmount},\n\t{\"savepersistant\",   AICast_ScriptAction_SavePersistant},\n\t{\"changelevel\",      AICast_ScriptAction_ChangeLevel},\n\t{\"endgame\",          AICast_ScriptAction_EndGame},\t\t\t\t//----(SA)\tadded\n\t{\"teleport\",     AICast_ScriptAction_Teleport},\t\t\t\t\t//----(SA)\tadded\n\t{\"foundsecret\",      AICast_ScriptAction_FoundSecret},\n\t{\"nosight\",          AICast_ScriptAction_NoSight},\n\t{\"sight\",            AICast_ScriptAction_Sight},\n\t{\"noavoid\",          AICast_ScriptAction_NoAvoid},\n\t{\"avoid\",            AICast_ScriptAction_Avoid},\n\t{\"attrib\",           AICast_ScriptAction_Attrib},\n\t{\"denyactivate\", AICast_ScriptAction_DenyAction},\n\t{\"lightningdamage\",  AICast_ScriptAction_LightningDamage},\n\t{\"deny\",         AICast_ScriptAction_DenyAction},\n\t{\"headlook\",     AICast_ScriptAction_Headlook},\n\t{\"backupscript\", AICast_ScriptAction_BackupScript},\n\t{\"restorescript\",    AICast_ScriptAction_RestoreScript},\n\t{\"statetype\",        AICast_ScriptAction_StateType},\n\t{\"knockback\",        AICast_ScriptAction_KnockBack},\n\t{\"zoom\",         AICast_ScriptAction_Zoom},\n\t{\"parachute\",        AICast_ScriptAction_Parachute},\n\t{\"cigarette\",        AICast_ScriptAction_Cigarette},\t\t\t\t//----(SA)\tadded\n\t{\"startcam\",     AICast_ScriptAction_StartCam},\n\t{\"startcamblack\",    AICast_ScriptAction_StartCamBlack},\n\t{\"stopcam\",          AICast_ScriptAction_StopCam},\t\t\t\t//----(SA)\tadded\n\t{\"entityscriptname\",AICast_ScriptAction_EntityScriptName},\n\t{\"aiscriptname\", AICast_ScriptAction_AIScriptName},\n\t{\"sethealth\",        AICast_ScriptAction_SetHealth},\n\t{\"notarget\",     AICast_ScriptAction_NoTarget},\n\t{\"cvar\",         AICast_ScriptAction_Cvar},\n\n//----(SA)\tadded some music interface\n\t{\"mu_start\",     AICast_ScriptAction_MusicStart},\t\t\t// (char *new_music, int time)\t// time to fade in\n\t{\"mu_play\",          AICast_ScriptAction_MusicPlay},\t\t// (char *new_music)\n\t{\"mu_stop\",          AICast_ScriptAction_MusicStop},\t\t// (int time)\t// time to fadeout\n\t{\"mu_fade\",          AICast_ScriptAction_MusicFade},\t\t// (float target_volume, int time)\t// time to fade to target\n\t{\"mu_queue\",     AICast_ScriptAction_MusicQueue},\t\t\t// (char *new_music)\t// music that will start when previous fades to 0\n//----(SA)\tend\n\n\t{\"explicit_routing\", AICast_ScriptAction_ExplicitRouting},\n\t{\"lockplayer\",       AICast_ScriptAction_LockPlayer},\n\t{\"anim_condition\",   AICast_ScriptAction_AnimCondition},\n\t{\"pushaway\",     AICast_ScriptAction_PushAway},\n\t{\"catchfire\",        AICast_ScriptAction_CatchFire},\n\n\t{NULL,              0}\n};\n\nqboolean AICast_EventMatch_StringEqual( cast_script_event_t *event, char *eventParm );\nqboolean AICast_EventMatch_IntInRange( cast_script_event_t *event, char *eventParm );\n\n// the list of events that can start an action sequence\n// NOTE!!: only append to this list, DO NOT INSERT!!\ncast_script_event_define_t scriptEvents[] =\n{\n\t{\"spawn\",            0},          // called as each character is spawned into the game\n\t{\"playerstart\",      0},          // called when player hits 'start' button\n\t{\"enemysight\",       AICast_EventMatch_StringEqual}, // enemy has been sighted for the first time (once only)\n\t{\"sight\",            AICast_EventMatch_StringEqual}, // non-enemy has been sighted for the first time (once only)\n\t{\"enemydead\",        AICast_EventMatch_StringEqual}, // our enemy is now dead\n\t{\"trigger\",          AICast_EventMatch_StringEqual}, // something has triggered us (always followed by an identifier)\n\t{\"pain\",         AICast_EventMatch_IntInRange},  // we've been hurt\n\t{\"death\",            AICast_EventMatch_StringEqual},\t// RIP\n\t{\"activate\",     AICast_EventMatch_StringEqual}, // \"param\" has just activated us\n\t{\"enemysightcorpse\",AICast_EventMatch_StringEqual},  // sighted the given enemy as a corpse, for the first time\n\t{\"friendlysightcorpse\", 0},                       // sighted a friendly as a corpse for the first time\n\t{\"avoiddanger\",      AICast_EventMatch_StringEqual}, // we are avoiding something dangerous\n\t{\"blocked\",          AICast_EventMatch_StringEqual}, // blocked by someone else\n\t{\"statechange\",      AICast_EventMatch_StringEqual}, // changing aistates\n\t{\"bulletimpact\", 0},\n\t{\"inspectbodystart\", AICast_EventMatch_StringEqual}, // starting to travel to body for inspection\n\t{\"inspectbodyend\",   AICast_EventMatch_StringEqual}, // reached body for inspection\n\t{\"inspectsoundstart\",    AICast_EventMatch_StringEqual}, // reached sound for inspection\n\t{\"inspectsoundend\",  AICast_EventMatch_StringEqual}, // reached sound for inspection\n\t{\"attacksound\",      AICast_EventMatch_StringEqual}, // play a custom attack sound, and/or deny playing the default sound\n\t{\"fakedeath\",        0},\n\t{\"bulletimpactsound\",    0},\n\t{\"inspectfriendlycombatstart\", 0},\n\t{\"painenemy\",        AICast_EventMatch_StringEqual},\n\t{\"forced_mg42_unmount\",  0},\n\n\t{NULL,              0}\n};\n\n\n/*\n===============\nAICast_EventMatch_StringEqual\n===============\n*/\nqboolean AICast_EventMatch_StringEqual( cast_script_event_t *event, char *eventParm ) {\n\tif ( !event->params || !event->params[0] || ( eventParm && !Q_strcasecmp( event->params, eventParm ) ) ) {\n\t\treturn qtrue;\n\t} else {\n\t\treturn qfalse;\n\t}\n}\n\n/*\n===============\nAICast_EventMatch_IntInRange\n===============\n*/\nqboolean AICast_EventMatch_IntInRange( cast_script_event_t *event, char *eventParm ) {\n\tchar *pString, *token;\n\tint int1, int2, eInt;\n\n\t// get the cast name\n\tpString = eventParm;\n\ttoken = COM_ParseExt( &pString, qfalse );\n\tint1 = atoi( token );\n\ttoken = COM_ParseExt( &pString, qfalse );\n\tint2 = atoi( token );\n\n\teInt = atoi( event->params );\n\n\tif ( eventParm && eInt > int1 && eInt <= int2 ) {\n\t\treturn qtrue;\n\t} else {\n\t\treturn qfalse;\n\t}\n}\n\n/*\n===============\nAICast_EventForString\n===============\n*/\nint AICast_EventForString( char *string ) {\n\tint i;\n\n\tfor ( i = 0; scriptEvents[i].eventStr; i++ )\n\t{\n\t\tif ( !Q_strcasecmp( string, scriptEvents[i].eventStr ) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/*\n===============\nAICast_ActionForString\n===============\n*/\ncast_script_stack_action_t *AICast_ActionForString( cast_state_t *cs, char *string ) {\n\tint i;\n\n\tfor ( i = 0; scriptActions[i].actionString; i++ )\n\t{\n\t\tif ( !Q_strcasecmp( string, scriptActions[i].actionString ) ) {\n\t\t\t// this is now ignored - use the numsecrets function\n\t\t\t/*\n\t\t\tif ( !Q_strcasecmp( string, \"foundsecret\" ) ) {\n\t\t\t\tlevel.numSecrets++;\n\t\t\t\tG_SendMissionStats();\n\t\t\t}\n\t\t\t*/\n\t\t\treturn &scriptActions[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n=============\nAICast_ScriptLoad\n\n  Loads the script for the current level into the buffer\n=============\n*/\nvoid AICast_ScriptLoad( void ) {\n\tchar filename[MAX_QPATH];\n\tvmCvar_t mapname;\n\tfileHandle_t f;\n\tint len;\n\n\tlevel.scriptAI = NULL;\n\n\ttrap_Cvar_VariableStringBuffer( \"ai_scriptName\", filename, sizeof( filename ) );\n\tif ( strlen( filename ) > 0 ) {\n\t\ttrap_Cvar_Register( &mapname, \"ai_scriptName\", \"\", CVAR_ROM );\n\t} else {\n\t\ttrap_Cvar_Register( &mapname, \"mapname\", \"\", CVAR_SERVERINFO | CVAR_ROM );\n\t}\n\tQ_strncpyz( filename, \"maps/\", sizeof( filename ) );\n\tQ_strcat( filename, sizeof( filename ), mapname.string );\n\tif ( g_gametype.integer <= GT_COOP ) {\n\t\tQ_strcat( filename, sizeof( filename ), \".coop.ai\" );\n\t} else {\n\t\tQ_strcat( filename, sizeof( filename ), \".ai\" );\n\t}\n\n\tlen = trap_FS_FOpenFile( filename, &f, FS_READ );\n\n\tG_Printf( \"Loading: %s\\n\", filename );\n\n\tif ( len < 0 ) {\n\t\treturn;\n\t}\n\n\tlevel.scriptAI = trap_Alloc( len );\n\ttrap_FS_Read( level.scriptAI, len, f );\n\n\ttrap_FS_FCloseFile( f );\n\n\treturn;\n}\n\n/*\n==============\nAICast_ScriptParse\n\n  Parses the script for the given character\n==============\n*/\n#define MAX_SCRIPT_EVENTS   64\ncast_script_event_t cast_temp_events[MAX_SCRIPT_EVENTS];\nvoid AICast_ScriptParse( cast_state_t *cs ) {\n\tgentity_t   *ent;\n\tchar        *pScript;\n\tchar        *token;\n\tqboolean wantName;\n\tqboolean inScript;\n\tint eventNum;\n\tint numEventItems;\n\tcast_script_event_t *curEvent;\n\tchar params[MAX_QPATH];\n\tcast_script_stack_action_t  *action;\n\tint i;\n\tint bracketLevel;\n\tqboolean buildScript;       //----(SA)\tadded\n\n\tif ( !level.scriptAI ) {\n\t\treturn;\n\t}\n\n\tent = &g_entities[cs->entityNum];\n\tif ( !ent->aiName ) {\n\t\treturn;\n\t}\n\n\tbuildScript = qtrue;\n\n\tpScript = level.scriptAI;\n\twantName = qtrue;\n\tinScript = qfalse;\n\tCOM_BeginParseSession( \"AICast_ScriptParse\" );\n\tbracketLevel = 0;\n\tnumEventItems = 0;\n\n\tmemset( cast_temp_events, 0, sizeof( cast_temp_events ) );\n\n\twhile ( 1 )\n\t{\n\t\ttoken = COM_Parse( &pScript );\n\n\t\tif ( !token[0] ) {\n\t\t\tif ( !wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// end of script\n\t\tif ( token[0] == '}' ) {\n\t\t\tif ( inScript ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' found, but not expected.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t\twantName = qtrue;\n\t\t} else if ( token[0] == '{' )    {\n\t\t\tif ( wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '{' found, NAME expected.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t} else if ( wantName )   {\n\t\t\tif ( !Q_strcasecmp( ent->aiName, token ) ) {\n\t\t\t\tinScript = qtrue;\n\t\t\t\tnumEventItems = 0;\n\t\t\t}\n\t\t\twantName = qfalse;\n\t\t} else if ( inScript )   {\n\t\t\tif ( !Q_strcasecmp( token, \"attributes\" ) ) {\n\t\t\t\t// read in all the attributes\n\t\t\t\tAICast_CheckLevelAttributes( cs, ent, &pScript );\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\teventNum = AICast_EventForString( token );\n\t\t\tif ( eventNum < 0 ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown event: %s.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t}\n\t\t\tif ( numEventItems >= MAX_SCRIPT_EVENTS ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): MAX_SCRIPT_EVENTS reached (%d)\\n\", COM_GetCurrentParseLine(), MAX_SCRIPT_EVENTS );\n\t\t\t}\n\n\t\t\t// if this is a \"friendlysightcorpse\" event, then disable corpse vis sharing\n\t\t\tif ( !Q_stricmp( token, \"friendlysightcorpse\" ) ) {\n\t\t\t\tcs->aiFlags &= ~AIFL_CORPSESIGHTING;\n\t\t\t}\n\n\t\t\tcurEvent = &cast_temp_events[numEventItems];\n\t\t\tcurEvent->eventNum = eventNum;\n\t\t\tmemset( params, 0, sizeof( params ) );\n\n\t\t\t// parse any event params before the start of this event's actions\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '{' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\tif ( eventNum == 13 ) {   // statechange event, check params\n\t\t\t\t\tif ( strlen( token ) > 1 ) {\n\t\t\t\t\t\tif ( BG_IndexForString( token, animStateStr, qtrue ) < 0 ) {\n\t\t\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown state type '%s'.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t}\n\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\t\t\t}\n\n\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\tcurEvent->params = trap_Alloc( strlen( params ) + 1 );\n\t\t\t\tQ_strncpyz( curEvent->params, params, strlen( params ) + 1 );\n\t\t\t}\n\n\t\t\t// parse the actions for this event\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\taction = AICast_ActionForString( cs, token );\n\t\t\t\tif ( !action ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown action: %s.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].action = action;\n\n\t\t\t\tmemset( params, 0, sizeof( params ) );\n\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\tfor ( i = 0; token[0]; i++ )\n\t\t\t\t{\n\t\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( i == 0 ) {\n\t\t\t\t\t\t// Special case: playsound's need to be cached on startup to prevent in-game pauses\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"playsound\" ) ) {\n\t\t\t\t\t\t\tG_SoundIndex( token );\n\t\t\t\t\t\t}\n\n//----(SA)\tadded a bit more\n\t\t\t\t\t\tif (    buildScript && (\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_start\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_play\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_queue\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"startcam\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"startcamblack\" ) )\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif ( strlen( token ) ) { // we know there's a [0], but don't know if it's '0'\n\t\t\t\t\t\t\t\ttrap_SendServerCommand( cs->entityNum, va( \"addToBuild %s\\n\", token ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"giveweapon\" ) ) { // register weapon for client pre-loading\n\t\t\t\t\t\t\tgitem_t *weap = BG_FindItem2( token );    // (SA) FIXME: rats, need to fix this for weapon names with spaces: 'mauser rifle'\n//\t\t\t\t\t\t\tif(weap)\n\t\t\t\t\t\t\tRegisterItem( weap );   // don't be nice, just do it.  if it can't find it, you'll bomb out to the error menu\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// need to get this for callvote nextmap\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"changelevel\" ) ) {\n\t\t\t\t\t\t\tQ_strncpyz( level.nextMap, token, sizeof( level.nextMap ) );\n\t\t\t\t\t\t\ttrap_Cvar_Set( \"nextmap\", level.nextMap );\n\t\t\t\t\t\t}\n//----(SA)\tend\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = trap_Alloc( strlen( params ) + 1 );\n\t\t\t\t\tQ_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.numItems++;\n\n\t\t\t\tif ( curEvent->stack.numItems >= AICAST_MAX_SCRIPT_STACK_ITEMS ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\\n\", AICAST_MAX_SCRIPT_STACK_ITEMS, COM_GetCurrentParseLine() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnumEventItems++;\n\t\t} else    // skip this character completely\n\t\t{\n\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t} else if ( token[0] == '{' ) {\n\t\t\t\t\tbracketLevel++;\n\t\t\t\t} else if ( token[0] == '}' ) {\n\t\t\t\t\tif ( !--bracketLevel ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// alloc and copy the events into the cast_state_t for this cast\n\tif ( numEventItems > 0 ) {\n\t\tcs->castScriptEvents = trap_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n\t\tmemcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );\n\t\tcs->numCastScriptEvents = numEventItems;\n\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t}\n}\n\n/*\n================\nAICast_ScriptChange\n================\n*/\nvoid AICast_ScriptChange( cast_state_t *cs, int newScriptNum ) {\n\tcast_script_status_t scriptStatusBackup;\n\n\tcs->scriptCallIndex++;\n\n\t// backup the current scripting\n\tscriptStatusBackup = cs->castScriptStatus;\n\n\t// set the new script to this cast, and reset script status\n\tcs->castScriptStatus.castScriptStackHead = 0;\n\tcs->castScriptStatus.castScriptStackChangeTime = level.time;\n\tcs->castScriptStatus.castScriptEventIndex = newScriptNum;\n\tcs->castScriptStatus.scriptId = scriptStatusBackup.scriptId + 1;\n\tcs->castScriptStatus.scriptGotoId = -1;\n\tcs->castScriptStatus.scriptGotoEnt = -1;\n\tcs->castScriptStatus.scriptFlags |= SFL_FIRST_CALL;\n\n\t// try and run the script, if it doesn't finish, then abort the current script (discard backup)\n\tif ( AICast_ScriptRun( cs, qtrue ) ) {\n\t\t// completed successfully\n\t\tcs->castScriptStatus.castScriptStackHead = scriptStatusBackup.castScriptStackHead;\n\t\tcs->castScriptStatus.castScriptStackChangeTime = scriptStatusBackup.castScriptStackChangeTime;\n\t\tcs->castScriptStatus.castScriptEventIndex = scriptStatusBackup.castScriptEventIndex;\n\t\tcs->castScriptStatus.scriptId = scriptStatusBackup.scriptId;\n\t\tcs->castScriptStatus.scriptFlags = scriptStatusBackup.scriptFlags;\n\t}\n}\n\n/*\n================\nAICast_ScriptEvent\n\n  An event has occured, for which a script may exist\n================\n*/\nvoid AICast_ScriptEvent( struct cast_state_s *cs, char *eventStr, char *params ) {\n\tint i, eventNum;\n\n\teventNum = -1;\n\n\t// find out which event this is\n\tfor ( i = 0; scriptEvents[i].eventStr; i++ )\n\t{\n\t\tif ( !Q_strcasecmp( eventStr, scriptEvents[i].eventStr ) ) { // match found\n\t\t\teventNum = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( eventNum < 0 ) {\n\t\tif ( g_cheats.integer ) { // dev mode\n\t\t\tG_Printf( \"devmode-> AICast_ScriptEvent(), unknown event: %s\\n\", eventStr );\n\t\t}\n\t}\n\n\t// show debugging info\n\tif (    (   ( aicast_debug.integer == 1 ) ||\n\t\t\t\t(   ( aicast_debug.integer == 2 ) &&\n\t\t\t\t\t( ( strlen( aicast_debugname.string ) < 1 ) || ( g_entities[cs->entityNum].aiName && !strcmp( aicast_debugname.string, g_entities[cs->entityNum].aiName ) ) ) ) ) ) {\n\t\tG_Printf( \"(%s) AIScript event: %s %s \", g_entities[cs->entityNum].aiName, eventStr, params );\n\t}\n\n\tcs->aiFlags &= ~AIFL_DENYACTION;\n\n\t// see if this cast has this event\n\tfor ( i = 0; i < cs->numCastScriptEvents; i++ )\n\t{\n\t\tif ( cs->castScriptEvents[i].eventNum == eventNum ) {\n\t\t\tif (    ( !cs->castScriptEvents[i].params )\n\t\t\t\t\t||  ( !scriptEvents[eventNum].eventMatch || scriptEvents[eventNum].eventMatch( &cs->castScriptEvents[i], params ) ) ) {\n\n\t\t\t\t// show debugging info\n\t\t\t\tif (    (   ( aicast_debug.integer == 1 ) ||\n\t\t\t\t\t\t\t(   ( aicast_debug.integer == 2 ) &&\n\t\t\t\t\t\t\t\t( ( strlen( aicast_debugname.string ) < 1 ) || ( g_entities[cs->entityNum].aiName && !strcmp( aicast_debugname.string, g_entities[cs->entityNum].aiName ) ) ) ) ) ) {\n\t\t\t\t\tG_Printf( \"found, calling script: (%s) %s %s\\n\", g_entities[cs->entityNum].aiName, eventStr, params );\n\t\t\t\t}\n\n\t\t\t\tAICast_ScriptChange( cs, i );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// show debugging info\n\tif (    (   ( aicast_debug.integer == 1 ) ||\n\t\t\t\t(   ( aicast_debug.integer == 2 ) &&\n\t\t\t\t\t( ( strlen( aicast_debugname.string ) < 1 ) || ( g_entities[cs->entityNum].aiName && !strcmp( aicast_debugname.string, g_entities[cs->entityNum].aiName ) ) ) ) ) ) {\n\t\tif ( i == cs->numCastScriptEvents ) {\n\t\t\tG_Printf( \"not found\\n\" );\n\t\t}\n\t}\n\n}\n\n/*\n================\nAICast_ForceScriptEvent\n\n  Definately run this event now, overriding any paised state\n================\n*/\nvoid AICast_ForceScriptEvent( struct cast_state_s *cs, char *eventStr, char *params ) {\n\tint oldPauseTime;\n\n\toldPauseTime = cs->scriptPauseTime;\n\tcs->scriptPauseTime = 0;\n\n\tAICast_ScriptEvent( cs, eventStr, params );\n\n\tcs->scriptPauseTime = oldPauseTime;\n}\n\n/*\n=============\nAICast_ScriptRun\n\n  returns qtrue if the script completed\n=============\n*/\nqboolean AICast_ScriptRun( cast_state_t *cs, qboolean force ) {\n\tcast_script_stack_t *stack;\n\n\tif ( !aicast_scripts.integer ) {\n\t\treturn qtrue;\n\t}\n\n\tif ( cs->castScriptStatus.castScriptEventIndex < 0 ) {\n\t\treturn qtrue;\n\t}\n\n\tif ( !cs->castScriptEvents ) {\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t\treturn qtrue;\n\t}\n\n\t// only allow the PLAYER'S spawn function through if we're NOT still waiting on everything to finish loading in\n\tif ( !cs->entityNum && saveGamePending && Q_stricmp( \"spawn\", scriptEvents[cs->castScriptEvents[cs->castScriptStatus.castScriptEventIndex].eventNum].eventStr ) ) {\n\t\t//char loading[4];\n\t\t//trap_Cvar_VariableStringBuffer( \"savegame_loading\", loading, sizeof(loading) );\n\t\t//if (strlen( loading ) > 0 && atoi(loading) != 0)\t// we're loading a savegame\n\t\treturn qfalse;\n\t}\n\n\tif ( !force && ( cs->scriptPauseTime >= level.time ) ) {\n\t\treturn qtrue;\n\t}\n\n\tstack = &cs->castScriptEvents[cs->castScriptStatus.castScriptEventIndex].stack;\n\n\tif ( !stack->numItems ) {\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t\treturn qtrue;\n\t}\n\n\twhile ( cs->castScriptStatus.castScriptStackHead < stack->numItems )\n\t{\n\t\t//\n\t\t// show debugging info\n\t\tif (    ( cs->castScriptStatus.castScriptStackChangeTime == level.time ) &&\n\t\t\t\t(   ( aicast_debug.integer == 1 ) ||\n\t\t\t\t\t(   ( aicast_debug.integer == 2 ) &&\n\t\t\t\t\t\t( ( strlen( aicast_debugname.string ) < 1 ) || ( g_entities[cs->entityNum].aiName && !strcmp( aicast_debugname.string, g_entities[cs->entityNum].aiName ) ) ) ) ) ) {\n\t\t\tG_Printf( \"(%s) AIScript command: %s %s\\n\", g_entities[cs->entityNum].aiName, stack->items[cs->castScriptStatus.castScriptStackHead].action->actionString, ( stack->items[cs->castScriptStatus.castScriptStackHead].params ? stack->items[cs->castScriptStatus.castScriptStackHead].params : \"\" ) );\n\t\t}\n\t\t//\n\t\tif ( !stack->items[cs->castScriptStatus.castScriptStackHead].action->actionFunc( cs, stack->items[cs->castScriptStatus.castScriptStackHead].params ) ) {\n\t\t\t// check that we are still running the same script that we were when we call the action\n\t\t\tif ( cs->castScriptStatus.castScriptEventIndex >= 0 && stack == &cs->castScriptEvents[cs->castScriptStatus.castScriptEventIndex].stack ) {\n\t\t\t\tcs->castScriptStatus.scriptFlags &= ~SFL_FIRST_CALL;\n\t\t\t}\n\t\t\treturn qfalse;\n\t\t}\n\t\t// move to the next action in the script\n\t\tcs->castScriptStatus.castScriptStackHead++;\n\t\t// record the time that this new item became active\n\t\tcs->castScriptStatus.castScriptStackChangeTime = level.time;\n\t\t// reset misc stuff\n\t\tcs->castScriptStatus.scriptGotoId = -1;\n\t\tcs->castScriptStatus.scriptGotoEnt = -1;\n\t\tcs->castScriptStatus.scriptFlags |= SFL_FIRST_CALL;\n\t}\n\n\tcs->castScriptStatus.castScriptEventIndex = -1;\n\n\treturn qtrue;\n}\n"], "filenames": ["code/game/ai_cast_script.c"], "buggy_code_start_loc": [394], "buggy_code_end_loc": [627], "fixing_code_start_loc": [394], "fixing_code_end_loc": [627], "type": "CWE-404", "message": "A vulnerability has been found in rtcwcoop 1.0.2 and classified as problematic. Affected by this vulnerability is the function AICast_ScriptLoad of the file code/game/ai_cast_script.c of the component Team Command Handler. The manipulation leads to denial of service. The name of the patch is f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac. It is recommended to apply a patch to fix this issue. The identifier VDB-221485 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2019-25104", "sourceIdentifier": "cna@vuldb.com", "published": "2023-02-20T18:15:10.387", "lastModified": "2023-03-03T15:27:56.210", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in rtcwcoop 1.0.2 and classified as problematic. Affected by this vulnerability is the function AICast_ScriptLoad of the file code/game/ai_cast_script.c of the component Team Command Handler. The manipulation leads to denial of service. The name of the patch is f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac. It is recommended to apply a patch to fix this issue. The identifier VDB-221485 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.7}, "baseSeverity": "LOW", "exploitabilityScore": 5.1, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rtcwcoop:rtcwcoop:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "81CDB2E1-B68D-444F-955D-910E2FDAE74A"}]}]}], "references": [{"url": "https://github.com/rtcwcoop/rtcwcoop/commit/f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/rtcwcoop/rtcwcoop/pull/45", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch"]}, {"url": "https://vuldb.com/?ctiid.221485", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.221485", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rtcwcoop/rtcwcoop/commit/f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac"}}