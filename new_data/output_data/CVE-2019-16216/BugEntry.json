{"buggy_code": ["from typing import Dict, Optional, Tuple\n\nfrom django.utils.translation import ugettext as _\nfrom django.conf import settings\nfrom django.core.files import File\nfrom django.http import HttpRequest\nfrom django.db.models import Sum\nfrom jinja2 import Markup as mark_safe\nimport unicodedata\n\nfrom zerver.lib.avatar_hash import user_avatar_path\nfrom zerver.lib.exceptions import JsonableError, ErrorCode\n\nfrom boto.s3.bucket import Bucket\nfrom boto.s3.key import Key\nfrom boto.s3.connection import S3Connection\nfrom mimetypes import guess_type, guess_extension\n\nfrom zerver.models import get_user_profile_by_id\nfrom zerver.models import Attachment\nfrom zerver.models import Realm, RealmEmoji, UserProfile, Message\n\nimport urllib\nimport base64\nimport os\nimport re\nfrom PIL import Image, ImageOps, ExifTags\nfrom PIL.Image import DecompressionBombError\nfrom PIL.GifImagePlugin import GifImageFile\nimport io\nimport random\nimport logging\n\nDEFAULT_AVATAR_SIZE = 100\nMEDIUM_AVATAR_SIZE = 500\nDEFAULT_EMOJI_SIZE = 64\n\n# These sizes were selected based on looking at the maximum common\n# sizes in a library of animated custom emoji, balanced against the\n# network cost of very large emoji images.\nMAX_EMOJI_GIF_SIZE = 128\nMAX_EMOJI_GIF_FILE_SIZE_BYTES = 128 * 1024 * 1024  # 128 kb\n\n# Performance Note:\n#\n# For writing files to S3, the file could either be stored in RAM\n# (if it is less than 2.5MiB or so) or an actual temporary file on disk.\n#\n# Because we set FILE_UPLOAD_MAX_MEMORY_SIZE to 0, only the latter case\n# should occur in practice.\n#\n# This is great, because passing the pseudofile object that Django gives\n# you to boto would be a pain.\n\n# To come up with a s3 key we randomly generate a \"directory\". The\n# \"file name\" is the original filename provided by the user run\n# through a sanitization function.\n\nclass RealmUploadQuotaError(JsonableError):\n    code = ErrorCode.REALM_UPLOAD_QUOTA\n\nattachment_url_re = re.compile(r'[/\\-]user[\\-_]uploads[/\\.-].*?(?=[ )]|\\Z)')\n\ndef attachment_url_to_path_id(attachment_url: str) -> str:\n    path_id_raw = re.sub(r'[/\\-]user[\\-_]uploads[/\\.-]', '', attachment_url)\n    # Remove any extra '.' after file extension. These are probably added by the user\n    return re.sub('[.]+$', '', path_id_raw, re.M)\n\ndef sanitize_name(value: str) -> str:\n    \"\"\"\n    Sanitizes a value to be safe to store in a Linux filesystem, in\n    S3, and in a URL.  So unicode is allowed, but not special\n    characters other than \".\", \"-\", and \"_\".\n\n    This implementation is based on django.utils.text.slugify; it is\n    modified by:\n    * adding '.' and '_' to the list of allowed characters.\n    * preserving the case of the value.\n    \"\"\"\n    value = unicodedata.normalize('NFKC', value)\n    value = re.sub(r'[^\\w\\s._-]', '', value, flags=re.U).strip()\n    return mark_safe(re.sub(r'[-\\s]+', '-', value, flags=re.U))\n\ndef random_name(bytes: int=60) -> str:\n    return base64.urlsafe_b64encode(os.urandom(bytes)).decode('utf-8')\n\nclass BadImageError(JsonableError):\n    code = ErrorCode.BAD_IMAGE\n\nname_to_tag_num = dict((name, num) for num, name in ExifTags.TAGS.items())\n\n# https://stackoverflow.com/a/6218425\ndef exif_rotate(image: Image) -> Image:\n    if not hasattr(image, '_getexif'):\n        return image\n    exif_data = image._getexif()\n    if exif_data is None:\n        return image\n\n    exif_dict = dict(exif_data.items())\n    orientation = exif_dict.get(name_to_tag_num['Orientation'])\n\n    if orientation == 3:\n        return image.rotate(180, expand=True)\n    elif orientation == 6:\n        return image.rotate(270, expand=True)\n    elif orientation == 8:\n        return image.rotate(90, expand=True)\n\n    return image\n\ndef resize_avatar(image_data: bytes, size: int=DEFAULT_AVATAR_SIZE) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        im = exif_rotate(im)\n        im = ImageOps.fit(im, (size, size), Image.ANTIALIAS)\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n    out = io.BytesIO()\n    if im.mode == 'CMYK':\n        im = im.convert('RGB')\n    im.save(out, format='png')\n    return out.getvalue()\n\ndef resize_logo(image_data: bytes) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        im = exif_rotate(im)\n        im.thumbnail((8*DEFAULT_AVATAR_SIZE, DEFAULT_AVATAR_SIZE), Image.ANTIALIAS)\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n    out = io.BytesIO()\n    if im.mode == 'CMYK':\n        im = im.convert('RGB')\n    im.save(out, format='png')\n    return out.getvalue()\n\n\ndef resize_gif(im: GifImageFile, size: int=DEFAULT_EMOJI_SIZE) -> bytes:\n    frames = []\n    duration_info = []\n    # If 'loop' info is not set then loop for infinite number of times.\n    loop = im.info.get(\"loop\", 0)\n    for frame_num in range(0, im.n_frames):\n        im.seek(frame_num)\n        new_frame = Image.new(\"RGBA\", im.size)\n        new_frame.paste(im, (0, 0), im.convert(\"RGBA\"))\n        new_frame = ImageOps.fit(new_frame, (size, size), Image.ANTIALIAS)\n        frames.append(new_frame)\n        duration_info.append(im.info['duration'])\n    out = io.BytesIO()\n    frames[0].save(out, save_all=True, optimize=True,\n                   format=\"GIF\", append_images=frames[1:],\n                   duration=duration_info,\n                   loop=loop)\n    return out.getvalue()\n\n\ndef resize_emoji(image_data: bytes, size: int=DEFAULT_EMOJI_SIZE) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        image_format = im.format\n        if image_format == \"GIF\":\n            # There are a number of bugs in Pillow.GifImagePlugin which cause\n            # results in resized gifs being broken. To work around this we\n            # only resize under certain conditions to minimize the chance of\n            # creating ugly gifs.\n            should_resize = any((\n                im.size[0] != im.size[1],                            # not square\n                im.size[0] > MAX_EMOJI_GIF_SIZE,                     # dimensions too large\n                len(image_data) > MAX_EMOJI_GIF_FILE_SIZE_BYTES,     # filesize too large\n            ))\n            return resize_gif(im, size) if should_resize else image_data\n        else:\n            im = exif_rotate(im)\n            im = ImageOps.fit(im, (size, size), Image.ANTIALIAS)\n            out = io.BytesIO()\n            im.save(out, format=image_format)\n            return out.getvalue()\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n\n\n### Common\n\nclass ZulipUploadBackend:\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile,\n                            target_realm: Optional[Realm]=None) -> str:\n        raise NotImplementedError()\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def delete_message_image(self, path_id: str) -> bool:\n        raise NotImplementedError()\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        raise NotImplementedError()\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        raise NotImplementedError()\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        raise NotImplementedError()\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        raise NotImplementedError()\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        raise NotImplementedError()\n\n\n### S3\n\ndef get_bucket(conn: S3Connection, bucket_name: str) -> Bucket:\n    # Calling get_bucket() with validate=True can apparently lead\n    # to expensive S3 bills:\n    #    http://www.appneta.com/blog/s3-list-get-bucket-default/\n    # The benefits of validation aren't completely clear to us, and\n    # we want to save on our bills, so we set the validate flag to False.\n    # (We think setting validate to True would cause us to fail faster\n    #  in situations where buckets don't exist, but that shouldn't be\n    #  an issue for us.)\n    bucket = conn.get_bucket(bucket_name, validate=False)\n    return bucket\n\ndef upload_image_to_s3(\n        bucket_name: str,\n        file_name: str,\n        content_type: Optional[str],\n        user_profile: UserProfile,\n        contents: bytes) -> None:\n\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    bucket = get_bucket(conn, bucket_name)\n    key = Key(bucket)\n    key.key = file_name\n    key.set_metadata(\"user_profile_id\", str(user_profile.id))\n    key.set_metadata(\"realm_id\", str(user_profile.realm_id))\n\n    if content_type is not None:\n        headers = {'Content-Type': content_type}  # type: Optional[Dict[str, str]]\n    else:\n        headers = None\n\n    key.set_contents_from_string(contents, headers=headers)  # type: ignore # https://github.com/python/typeshed/issues/1552\n\ndef currently_used_upload_space(realm: Realm) -> int:\n    used_space = Attachment.objects.filter(realm=realm).aggregate(Sum('size'))['size__sum']\n    if used_space is None:\n        return 0\n    return used_space\n\ndef check_upload_within_quota(realm: Realm, uploaded_file_size: int) -> None:\n    upload_quota = realm.upload_quota_bytes()\n    if upload_quota is None:\n        return\n    used_space = currently_used_upload_space(realm)\n    if (used_space + uploaded_file_size) > upload_quota:\n        raise RealmUploadQuotaError(_(\"Upload would exceed your organization's upload quota.\"))\n\ndef get_file_info(request: HttpRequest, user_file: File) -> Tuple[str, int, Optional[str]]:\n\n    uploaded_file_name = user_file.name\n    assert isinstance(uploaded_file_name, str)\n\n    content_type = request.GET.get('mimetype')\n    if content_type is None:\n        guessed_type = guess_type(uploaded_file_name)[0]\n        if guessed_type is not None:\n            content_type = guessed_type\n    else:\n        extension = guess_extension(content_type)\n        if extension is not None:\n            uploaded_file_name = uploaded_file_name + extension\n\n    uploaded_file_name = urllib.parse.unquote(uploaded_file_name)\n    uploaded_file_size = user_file.size\n\n    return uploaded_file_name, uploaded_file_size, content_type\n\n\ndef get_signed_upload_url(path: str) -> str:\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    return conn.generate_url(15, 'GET', bucket=settings.S3_AUTH_UPLOADS_BUCKET, key=path)\n\ndef get_realm_for_filename(path: str) -> Optional[int]:\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    key = get_bucket(conn, settings.S3_AUTH_UPLOADS_BUCKET).get_key(path)\n    if key is None:\n        # This happens if the key does not exist.\n        return None\n    return get_user_profile_by_id(key.metadata[\"user_profile_id\"]).realm_id\n\nclass S3UploadBackend(ZulipUploadBackend):\n    def delete_file_from_s3(self, path_id: str, bucket_name: str) -> bool:\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n\n        # check if file exists\n        key = bucket.get_key(path_id)\n        if key is not None:\n            bucket.delete_key(key)\n            return True\n\n        file_name = path_id.split(\"/\")[-1]\n        logging.warning(\"%s does not exist. Its entry in the database will be removed.\" % (file_name,))\n        return False\n\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n        bucket_name = settings.S3_AUTH_UPLOADS_BUCKET\n        if target_realm is None:\n            target_realm = user_profile.realm\n        s3_file_name = \"/\".join([\n            str(target_realm.id),\n            random_name(18),\n            sanitize_name(uploaded_file_name)\n        ])\n        url = \"/user_uploads/%s\" % (s3_file_name,)\n\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            content_type,\n            user_profile,\n            file_data\n        )\n\n        create_attachment(uploaded_file_name, s3_file_name, user_profile, uploaded_file_size)\n        return url\n\n    def delete_message_image(self, path_id: str) -> bool:\n        return self.delete_file_from_s3(path_id, settings.S3_AUTH_UPLOADS_BUCKET)\n\n    def write_avatar_images(self, s3_file_name: str, target_user_profile: UserProfile,\n                            image_data: bytes, content_type: Optional[str]) -> None:\n        bucket_name = settings.S3_AVATAR_BUCKET\n\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            target_user_profile,\n            image_data,\n        )\n\n        # custom 500px wide version\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \"-medium.png\",\n            \"image/png\",\n            target_user_profile,\n            resized_medium\n        )\n\n        resized_data = resize_avatar(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            'image/png',\n            target_user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        content_type = guess_type(user_file.name)[0]\n        s3_file_name = user_avatar_path(target_user_profile)\n\n        image_data = user_file.read()\n        self.write_avatar_images(s3_file_name, target_user_profile,\n                                 image_data, content_type)\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        path_id = user_avatar_path(user)\n        bucket_name = settings.S3_AVATAR_BUCKET\n\n        self.delete_file_from_s3(path_id + \".original\", bucket_name)\n        self.delete_file_from_s3(path_id + \"-medium.png\", bucket_name)\n        self.delete_file_from_s3(path_id, bucket_name)\n\n    def get_avatar_key(self, file_name: str) -> Key:\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket_name = settings.S3_AVATAR_BUCKET\n        bucket = get_bucket(conn, bucket_name)\n\n        key = bucket.get_key(file_name)\n        return key\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        s3_source_file_name = user_avatar_path(source_profile)\n        s3_target_file_name = user_avatar_path(target_profile)\n\n        key = self.get_avatar_key(s3_source_file_name + \".original\")\n        image_data = key.get_contents_as_string()  # type: ignore # https://github.com/python/typeshed/issues/1552\n        content_type = key.content_type\n\n        self.write_avatar_images(s3_target_file_name, target_profile, image_data, content_type)  # type: ignore # image_data is `bytes`, boto subs are wrong\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        medium_suffix = \"-medium.png\" if medium else \"\"\n        # ?x=x allows templates to append additional parameters with &s\n        return \"https://%s.s3.amazonaws.com/%s%s?x=x\" % (bucket, hash_key, medium_suffix)\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        content_type = guess_type(icon_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        s3_file_name = os.path.join(str(user_profile.realm.id), 'realm', 'icon')\n\n        image_data = icon_file.read()\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            user_profile,\n            image_data,\n        )\n\n        resized_data = resize_avatar(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".png\",\n            'image/png',\n            user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        # ?x=x allows templates to append additional parameters with &s\n        return \"https://%s.s3.amazonaws.com/%s/realm/icon.png?version=%s\" % (bucket, realm_id, version)\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        content_type = guess_type(logo_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        if night:\n            basename = 'night_logo'\n        else:\n            basename = 'logo'\n        s3_file_name = os.path.join(str(user_profile.realm.id), 'realm', basename)\n\n        image_data = logo_file.read()\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            user_profile,\n            image_data,\n        )\n\n        resized_data = resize_logo(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".png\",\n            'image/png',\n            user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        # ?x=x allows templates to append additional parameters with &s\n        if not night:\n            file_name = 'logo.png'\n        else:\n            file_name = 'night_logo.png'\n        return \"https://%s.s3.amazonaws.com/%s/realm/%s?version=%s\" % (bucket, realm_id, file_name, version)\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(user_profile)\n        s3_file_name = file_path\n\n        bucket_name = settings.S3_AVATAR_BUCKET\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n        key = bucket.get_key(file_path + \".original\")\n        image_data = key.get_contents_as_string()\n\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)  # type: ignore # image_data is `bytes`, boto subs are wrong\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \"-medium.png\",\n            \"image/png\",\n            user_profile,\n            resized_medium\n        )\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:  # nocoverage\n        # TODO: Refactor this to share code with ensure_medium_avatar_image\n        file_path = user_avatar_path(user_profile)\n        # Also TODO: Migrate to user_avatar_path(user_profile) + \".png\".\n        s3_file_name = file_path\n\n        bucket_name = settings.S3_AVATAR_BUCKET\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n        key = bucket.get_key(file_path + \".original\")\n        image_data = key.get_contents_as_string()\n\n        resized_avatar = resize_avatar(image_data)  # type: ignore # image_data is `bytes`, boto subs are wrong\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            \"image/png\",\n            user_profile,\n            resized_avatar\n        )\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str,\n                           user_profile: UserProfile) -> None:\n        content_type = guess_type(emoji_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(\n            realm_id=user_profile.realm_id,\n            emoji_file_name=emoji_file_name\n        )\n\n        image_data = emoji_file.read()\n        resized_image_data = resize_emoji(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            \".\".join((emoji_path, \"original\")),\n            content_type,\n            user_profile,\n            image_data,\n        )\n        upload_image_to_s3(\n            bucket_name,\n            emoji_path,\n            content_type,\n            user_profile,\n            resized_image_data,\n        )\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(realm_id=realm_id,\n                                                        emoji_file_name=emoji_file_name)\n        return \"https://%s.s3.amazonaws.com/%s\" % (bucket, emoji_path)\n\n\n### Local\n\ndef write_local_file(type: str, path: str, file_data: bytes) -> None:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    with open(file_path, 'wb') as f:\n        f.write(file_data)\n\ndef read_local_file(type: str, path: str) -> bytes:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    with open(file_path, 'rb') as f:\n        return f.read()\n\ndef delete_local_file(type: str, path: str) -> bool:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    if os.path.isfile(file_path):\n        # This removes the file but the empty folders still remain.\n        os.remove(file_path)\n        return True\n    file_name = path.split(\"/\")[-1]\n    logging.warning(\"%s does not exist. Its entry in the database will be removed.\" % (file_name,))\n    return False\n\ndef get_local_file_path(path_id: str) -> Optional[str]:\n    local_path = os.path.join(settings.LOCAL_UPLOADS_DIR, 'files', path_id)\n    if os.path.isfile(local_path):\n        return local_path\n    else:\n        return None\n\nclass LocalUploadBackend(ZulipUploadBackend):\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n        # Split into 256 subdirectories to prevent directories from getting too big\n        path = \"/\".join([\n            str(user_profile.realm_id),\n            format(random.randint(0, 255), 'x'),\n            random_name(18),\n            sanitize_name(uploaded_file_name)\n        ])\n\n        write_local_file('files', path, file_data)\n        create_attachment(uploaded_file_name, path, user_profile, uploaded_file_size)\n        return '/user_uploads/' + path\n\n    def delete_message_image(self, path_id: str) -> bool:\n        return delete_local_file('files', path_id)\n\n    def write_avatar_images(self, file_path: str, image_data: bytes) -> None:\n        write_local_file('avatars', file_path + '.original', image_data)\n\n        resized_data = resize_avatar(image_data)\n        write_local_file('avatars', file_path + '.png', resized_data)\n\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        write_local_file('avatars', file_path + '-medium.png', resized_medium)\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(target_user_profile)\n\n        image_data = user_file.read()\n        self.write_avatar_images(file_path, image_data)\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        path_id = user_avatar_path(user)\n\n        delete_local_file(\"avatars\", path_id + \".original\")\n        delete_local_file(\"avatars\", path_id + \".png\")\n        delete_local_file(\"avatars\", path_id + \"-medium.png\")\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        medium_suffix = \"-medium\" if medium else \"\"\n        return \"/user_avatars/%s%s.png?x=x\" % (hash_key, medium_suffix)\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        source_file_path = user_avatar_path(source_profile)\n        target_file_path = user_avatar_path(target_profile)\n\n        image_data = read_local_file('avatars', source_file_path + '.original')\n        self.write_avatar_images(target_file_path, image_data)\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        upload_path = os.path.join('avatars', str(user_profile.realm.id), 'realm')\n\n        image_data = icon_file.read()\n        write_local_file(\n            upload_path,\n            'icon.original',\n            image_data)\n\n        resized_data = resize_avatar(image_data)\n        write_local_file(upload_path, 'icon.png', resized_data)\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        return \"/user_avatars/%s/realm/icon.png?version=%s\" % (realm_id, version)\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        upload_path = os.path.join('avatars', str(user_profile.realm.id), 'realm')\n        if night:\n            original_file = 'night_logo.original'\n            resized_file = 'night_logo.png'\n        else:\n            original_file = 'logo.original'\n            resized_file = 'logo.png'\n        image_data = logo_file.read()\n        write_local_file(\n            upload_path,\n            original_file,\n            image_data)\n\n        resized_data = resize_logo(image_data)\n        write_local_file(upload_path, resized_file, resized_data)\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        if night:\n            file_name = 'night_logo.png'\n        else:\n            file_name = 'logo.png'\n        return \"/user_avatars/%s/realm/%s?version=%s\" % (realm_id, file_name, version)\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(user_profile)\n\n        output_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \"-medium.png\")\n        if os.path.isfile(output_path):\n            return\n\n        image_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".original\")\n        image_data = open(image_path, \"rb\").read()\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        write_local_file('avatars', file_path + '-medium.png', resized_medium)\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:  # nocoverage\n        # TODO: Refactor this to share code with ensure_medium_avatar_image\n        file_path = user_avatar_path(user_profile)\n\n        output_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".png\")\n        if os.path.isfile(output_path):\n            return\n\n        image_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".original\")\n        image_data = open(image_path, \"rb\").read()\n        resized_avatar = resize_avatar(image_data)\n        write_local_file('avatars', file_path + '.png', resized_avatar)\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str,\n                           user_profile: UserProfile) -> None:\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(\n            realm_id= user_profile.realm_id,\n            emoji_file_name=emoji_file_name\n        )\n\n        image_data = emoji_file.read()\n        resized_image_data = resize_emoji(image_data)\n        write_local_file(\n            'avatars',\n            \".\".join((emoji_path, \"original\")),\n            image_data)\n        write_local_file(\n            'avatars',\n            emoji_path,\n            resized_image_data)\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        return os.path.join(\n            \"/user_avatars\",\n            RealmEmoji.PATH_ID_TEMPLATE.format(realm_id=realm_id, emoji_file_name=emoji_file_name))\n\n# Common and wrappers\nif settings.LOCAL_UPLOADS_DIR is not None:\n    upload_backend = LocalUploadBackend()  # type: ZulipUploadBackend\nelse:\n    upload_backend = S3UploadBackend()  # nocoverage\n\ndef delete_message_image(path_id: str) -> bool:\n    return upload_backend.delete_message_image(path_id)\n\ndef upload_avatar_image(user_file: File, acting_user_profile: UserProfile,\n                        target_user_profile: UserProfile) -> None:\n    upload_backend.upload_avatar_image(user_file, acting_user_profile, target_user_profile)\n\ndef delete_avatar_image(user_profile: UserProfile) -> None:\n    upload_backend.delete_avatar_image(user_profile)\n\ndef copy_avatar(source_profile: UserProfile, target_profile: UserProfile) -> None:\n    upload_backend.copy_avatar(source_profile, target_profile)\n\ndef upload_icon_image(user_file: File, user_profile: UserProfile) -> None:\n    upload_backend.upload_realm_icon_image(user_file, user_profile)\n\ndef upload_logo_image(user_file: File, user_profile: UserProfile, night: bool) -> None:\n    upload_backend.upload_realm_logo_image(user_file, user_profile, night)\n\ndef upload_emoji_image(emoji_file: File, emoji_file_name: str, user_profile: UserProfile) -> None:\n    upload_backend.upload_emoji_image(emoji_file, emoji_file_name, user_profile)\n\ndef upload_message_file(uploaded_file_name: str, uploaded_file_size: int,\n                        content_type: Optional[str], file_data: bytes,\n                        user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n    return upload_backend.upload_message_file(uploaded_file_name, uploaded_file_size,\n                                              content_type, file_data, user_profile,\n                                              target_realm=target_realm)\n\ndef claim_attachment(user_profile: UserProfile,\n                     path_id: str,\n                     message: Message,\n                     is_message_realm_public: bool) -> Attachment:\n    attachment = Attachment.objects.get(path_id=path_id)\n    attachment.messages.add(message)\n    attachment.is_realm_public = attachment.is_realm_public or is_message_realm_public\n    attachment.save()\n    return attachment\n\ndef create_attachment(file_name: str, path_id: str, user_profile: UserProfile,\n                      file_size: int) -> bool:\n    attachment = Attachment.objects.create(file_name=file_name, path_id=path_id, owner=user_profile,\n                                           realm=user_profile.realm, size=file_size)\n    from zerver.lib.actions import notify_attachment_update\n    notify_attachment_update(user_profile, 'add', attachment.to_dict())\n    return True\n\ndef upload_message_image_from_request(request: HttpRequest, user_file: File,\n                                      user_profile: UserProfile) -> str:\n    uploaded_file_name, uploaded_file_size, content_type = get_file_info(request, user_file)\n    return upload_message_file(uploaded_file_name, uploaded_file_size,\n                               content_type, user_file.read(), user_profile)\n", "# -*- coding: utf-8 -*-\n\nfrom django.http import HttpRequest, HttpResponse, HttpResponseForbidden, \\\n    HttpResponseNotFound\nfrom django.shortcuts import redirect\nfrom django.utils.translation import ugettext as _\n\nfrom zerver.lib.response import json_success, json_error\nfrom zerver.lib.upload import upload_message_image_from_request, get_local_file_path, \\\n    get_signed_upload_url, check_upload_within_quota\nfrom zerver.models import UserProfile, validate_attachment_request\nfrom django.conf import settings\nfrom sendfile import sendfile\nfrom mimetypes import guess_type\n\ndef serve_s3(request: HttpRequest, url_path: str) -> HttpResponse:\n    uri = get_signed_upload_url(url_path)\n    return redirect(uri)\n\ndef serve_local(request: HttpRequest, path_id: str) -> HttpResponse:\n    local_path = get_local_file_path(path_id)\n    if local_path is None:\n        return HttpResponseNotFound('<p>File not found</p>')\n\n    # Here we determine whether a browser should treat the file like\n    # an attachment (and thus clicking a link to it should download)\n    # or like a link (and thus clicking a link to it should display it\n    # in a browser tab).  This is controlled by the\n    # Content-Disposition header; `django-sendfile` sends the\n    # attachment-style version of that header if and only if the\n    # attachment argument is passed to it.  For attachments,\n    # django-sendfile sets the response['Content-disposition'] like\n    # this: `attachment; filename=\"b'zulip.txt'\"; filename*=UTF-8''zulip.txt`.\n    #\n    # The \"filename\" field (used to name the file when downloaded) is\n    # unreliable because it doesn't have a well-defined encoding; the\n    # newer filename* field takes precedence, since it uses a\n    # consistent format (urlquoted).  For more details on filename*\n    # and filename, see the below docs:\n    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\n    attachment = True\n    file_type = guess_type(local_path)[0]\n    if file_type is not None and (file_type.startswith(\"image/\") or\n                                  file_type == \"application/pdf\"):\n        attachment = False\n\n    return sendfile(request, local_path, attachment=attachment)\n\ndef serve_file_backend(request: HttpRequest, user_profile: UserProfile,\n                       realm_id_str: str, filename: str) -> HttpResponse:\n    path_id = \"%s/%s\" % (realm_id_str, filename)\n    is_authorized = validate_attachment_request(user_profile, path_id)\n\n    if is_authorized is None:\n        return HttpResponseNotFound(_(\"<p>File not found.</p>\"))\n    if not is_authorized:\n        return HttpResponseForbidden(_(\"<p>You are not authorized to view this file.</p>\"))\n    if settings.LOCAL_UPLOADS_DIR is not None:\n        return serve_local(request, path_id)\n\n    return serve_s3(request, path_id)\n\ndef upload_file_backend(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    if len(request.FILES) == 0:\n        return json_error(_(\"You must specify a file to upload\"))\n    if len(request.FILES) != 1:\n        return json_error(_(\"You may only upload one file at a time\"))\n\n    user_file = list(request.FILES.values())[0]\n    file_size = user_file._get_size()\n    if settings.MAX_FILE_UPLOAD_SIZE * 1024 * 1024 < file_size:\n        return json_error(_(\"Uploaded file is larger than the allowed limit of %s MB\") % (\n            settings.MAX_FILE_UPLOAD_SIZE))\n    check_upload_within_quota(user_profile.realm, file_size)\n\n    if not isinstance(user_file.name, str):\n        # It seems that in Python 2 unicode strings containing bytes are\n        # rendered differently than ascii strings containing same bytes.\n        #\n        # Example:\n        # >>> print('\\xd3\\x92')\n        # \u04d2\n        # >>> print(u'\\xd3\\x92')\n        # \u00d3\n        #\n        # This is the cause of the problem as user_file.name variable\n        # is received as a unicode which is converted into unicode\n        # strings containing bytes and is rendered incorrectly.\n        #\n        # Example:\n        # >>> import urllib.parse\n        # >>> name = u'%D0%97%D0%B4%D1%80%D0%B0%D0%B2%D0%B5%D0%B8%CC%86%D1%82%D0%B5.txt'\n        # >>> print(urllib.parse.unquote(name))\n        # \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00b5\u00d0\u00b8\u00cc\u0086\u00d1\u0082\u00d0\u00b5  # This is wrong\n        #\n        # >>> name = '%D0%97%D0%B4%D1%80%D0%B0%D0%B2%D0%B5%D0%B8%CC%86%D1%82%D0%B5.txt'\n        # >>> print(urllib.parse.unquote(name))\n        # \u0417\u0434\u0440\u0430\u0432\u0435\u0438\u0306\u0442\u0435.txt  # This is correct\n        user_file.name = user_file.name.encode('ascii')\n\n    uri = upload_message_image_from_request(request, user_file, user_profile)\n    return json_success({'uri': uri})\n"], "fixing_code": ["from typing import Optional, Tuple\n\nfrom django.utils.translation import ugettext as _\nfrom django.conf import settings\nfrom django.core.files import File\nfrom django.http import HttpRequest\nfrom django.db.models import Sum\nfrom jinja2 import Markup as mark_safe\nimport unicodedata\n\nfrom zerver.lib.avatar_hash import user_avatar_path\nfrom zerver.lib.exceptions import JsonableError, ErrorCode\n\nfrom boto.s3.bucket import Bucket\nfrom boto.s3.key import Key\nfrom boto.s3.connection import S3Connection\nfrom mimetypes import guess_type, guess_extension\n\nfrom zerver.models import get_user_profile_by_id\nfrom zerver.models import Attachment\nfrom zerver.models import Realm, RealmEmoji, UserProfile, Message\n\nimport urllib\nimport base64\nimport os\nimport re\nfrom PIL import Image, ImageOps, ExifTags\nfrom PIL.Image import DecompressionBombError\nfrom PIL.GifImagePlugin import GifImageFile\nimport io\nimport random\nimport logging\n\nDEFAULT_AVATAR_SIZE = 100\nMEDIUM_AVATAR_SIZE = 500\nDEFAULT_EMOJI_SIZE = 64\n\n# These sizes were selected based on looking at the maximum common\n# sizes in a library of animated custom emoji, balanced against the\n# network cost of very large emoji images.\nMAX_EMOJI_GIF_SIZE = 128\nMAX_EMOJI_GIF_FILE_SIZE_BYTES = 128 * 1024 * 1024  # 128 kb\n\nINLINE_MIME_TYPES = [\n    \"application/pdf\",\n    \"image/gif\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/webp\",\n    # To avoid cross-site scripting attacks, DO NOT add types such\n    # as application/xhtml+xml, application/x-shockwave-flash,\n    # image/svg+xml, text/html, or text/xml.\n]\n\n# Performance Note:\n#\n# For writing files to S3, the file could either be stored in RAM\n# (if it is less than 2.5MiB or so) or an actual temporary file on disk.\n#\n# Because we set FILE_UPLOAD_MAX_MEMORY_SIZE to 0, only the latter case\n# should occur in practice.\n#\n# This is great, because passing the pseudofile object that Django gives\n# you to boto would be a pain.\n\n# To come up with a s3 key we randomly generate a \"directory\". The\n# \"file name\" is the original filename provided by the user run\n# through a sanitization function.\n\nclass RealmUploadQuotaError(JsonableError):\n    code = ErrorCode.REALM_UPLOAD_QUOTA\n\nattachment_url_re = re.compile(r'[/\\-]user[\\-_]uploads[/\\.-].*?(?=[ )]|\\Z)')\n\ndef attachment_url_to_path_id(attachment_url: str) -> str:\n    path_id_raw = re.sub(r'[/\\-]user[\\-_]uploads[/\\.-]', '', attachment_url)\n    # Remove any extra '.' after file extension. These are probably added by the user\n    return re.sub('[.]+$', '', path_id_raw, re.M)\n\ndef sanitize_name(value: str) -> str:\n    \"\"\"\n    Sanitizes a value to be safe to store in a Linux filesystem, in\n    S3, and in a URL.  So unicode is allowed, but not special\n    characters other than \".\", \"-\", and \"_\".\n\n    This implementation is based on django.utils.text.slugify; it is\n    modified by:\n    * adding '.' and '_' to the list of allowed characters.\n    * preserving the case of the value.\n    \"\"\"\n    value = unicodedata.normalize('NFKC', value)\n    value = re.sub(r'[^\\w\\s._-]', '', value, flags=re.U).strip()\n    return mark_safe(re.sub(r'[-\\s]+', '-', value, flags=re.U))\n\ndef random_name(bytes: int=60) -> str:\n    return base64.urlsafe_b64encode(os.urandom(bytes)).decode('utf-8')\n\nclass BadImageError(JsonableError):\n    code = ErrorCode.BAD_IMAGE\n\nname_to_tag_num = dict((name, num) for num, name in ExifTags.TAGS.items())\n\n# https://stackoverflow.com/a/6218425\ndef exif_rotate(image: Image) -> Image:\n    if not hasattr(image, '_getexif'):\n        return image\n    exif_data = image._getexif()\n    if exif_data is None:\n        return image\n\n    exif_dict = dict(exif_data.items())\n    orientation = exif_dict.get(name_to_tag_num['Orientation'])\n\n    if orientation == 3:\n        return image.rotate(180, expand=True)\n    elif orientation == 6:\n        return image.rotate(270, expand=True)\n    elif orientation == 8:\n        return image.rotate(90, expand=True)\n\n    return image\n\ndef resize_avatar(image_data: bytes, size: int=DEFAULT_AVATAR_SIZE) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        im = exif_rotate(im)\n        im = ImageOps.fit(im, (size, size), Image.ANTIALIAS)\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n    out = io.BytesIO()\n    if im.mode == 'CMYK':\n        im = im.convert('RGB')\n    im.save(out, format='png')\n    return out.getvalue()\n\ndef resize_logo(image_data: bytes) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        im = exif_rotate(im)\n        im.thumbnail((8*DEFAULT_AVATAR_SIZE, DEFAULT_AVATAR_SIZE), Image.ANTIALIAS)\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n    out = io.BytesIO()\n    if im.mode == 'CMYK':\n        im = im.convert('RGB')\n    im.save(out, format='png')\n    return out.getvalue()\n\n\ndef resize_gif(im: GifImageFile, size: int=DEFAULT_EMOJI_SIZE) -> bytes:\n    frames = []\n    duration_info = []\n    # If 'loop' info is not set then loop for infinite number of times.\n    loop = im.info.get(\"loop\", 0)\n    for frame_num in range(0, im.n_frames):\n        im.seek(frame_num)\n        new_frame = Image.new(\"RGBA\", im.size)\n        new_frame.paste(im, (0, 0), im.convert(\"RGBA\"))\n        new_frame = ImageOps.fit(new_frame, (size, size), Image.ANTIALIAS)\n        frames.append(new_frame)\n        duration_info.append(im.info['duration'])\n    out = io.BytesIO()\n    frames[0].save(out, save_all=True, optimize=True,\n                   format=\"GIF\", append_images=frames[1:],\n                   duration=duration_info,\n                   loop=loop)\n    return out.getvalue()\n\n\ndef resize_emoji(image_data: bytes, size: int=DEFAULT_EMOJI_SIZE) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        image_format = im.format\n        if image_format == \"GIF\":\n            # There are a number of bugs in Pillow.GifImagePlugin which cause\n            # results in resized gifs being broken. To work around this we\n            # only resize under certain conditions to minimize the chance of\n            # creating ugly gifs.\n            should_resize = any((\n                im.size[0] != im.size[1],                            # not square\n                im.size[0] > MAX_EMOJI_GIF_SIZE,                     # dimensions too large\n                len(image_data) > MAX_EMOJI_GIF_FILE_SIZE_BYTES,     # filesize too large\n            ))\n            return resize_gif(im, size) if should_resize else image_data\n        else:\n            im = exif_rotate(im)\n            im = ImageOps.fit(im, (size, size), Image.ANTIALIAS)\n            out = io.BytesIO()\n            im.save(out, format=image_format)\n            return out.getvalue()\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n\n\n### Common\n\nclass ZulipUploadBackend:\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile,\n                            target_realm: Optional[Realm]=None) -> str:\n        raise NotImplementedError()\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def delete_message_image(self, path_id: str) -> bool:\n        raise NotImplementedError()\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        raise NotImplementedError()\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        raise NotImplementedError()\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        raise NotImplementedError()\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        raise NotImplementedError()\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        raise NotImplementedError()\n\n\n### S3\n\ndef get_bucket(conn: S3Connection, bucket_name: str) -> Bucket:\n    # Calling get_bucket() with validate=True can apparently lead\n    # to expensive S3 bills:\n    #    http://www.appneta.com/blog/s3-list-get-bucket-default/\n    # The benefits of validation aren't completely clear to us, and\n    # we want to save on our bills, so we set the validate flag to False.\n    # (We think setting validate to True would cause us to fail faster\n    #  in situations where buckets don't exist, but that shouldn't be\n    #  an issue for us.)\n    bucket = conn.get_bucket(bucket_name, validate=False)\n    return bucket\n\ndef upload_image_to_s3(\n        bucket_name: str,\n        file_name: str,\n        content_type: Optional[str],\n        user_profile: UserProfile,\n        contents: bytes) -> None:\n\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    bucket = get_bucket(conn, bucket_name)\n    key = Key(bucket)\n    key.key = file_name\n    key.set_metadata(\"user_profile_id\", str(user_profile.id))\n    key.set_metadata(\"realm_id\", str(user_profile.realm_id))\n\n    headers = {}\n    if content_type is not None:\n        headers[\"Content-Type\"] = content_type\n    if content_type not in INLINE_MIME_TYPES:\n        headers[\"Content-Disposition\"] = \"attachment\"\n\n    key.set_contents_from_string(contents, headers=headers)  # type: ignore # https://github.com/python/typeshed/issues/1552\n\ndef currently_used_upload_space(realm: Realm) -> int:\n    used_space = Attachment.objects.filter(realm=realm).aggregate(Sum('size'))['size__sum']\n    if used_space is None:\n        return 0\n    return used_space\n\ndef check_upload_within_quota(realm: Realm, uploaded_file_size: int) -> None:\n    upload_quota = realm.upload_quota_bytes()\n    if upload_quota is None:\n        return\n    used_space = currently_used_upload_space(realm)\n    if (used_space + uploaded_file_size) > upload_quota:\n        raise RealmUploadQuotaError(_(\"Upload would exceed your organization's upload quota.\"))\n\ndef get_file_info(request: HttpRequest, user_file: File) -> Tuple[str, int, Optional[str]]:\n\n    uploaded_file_name = user_file.name\n    assert isinstance(uploaded_file_name, str)\n\n    content_type = request.GET.get('mimetype')\n    if content_type is None:\n        guessed_type = guess_type(uploaded_file_name)[0]\n        if guessed_type is not None:\n            content_type = guessed_type\n    else:\n        extension = guess_extension(content_type)\n        if extension is not None:\n            uploaded_file_name = uploaded_file_name + extension\n\n    uploaded_file_name = urllib.parse.unquote(uploaded_file_name)\n    uploaded_file_size = user_file.size\n\n    return uploaded_file_name, uploaded_file_size, content_type\n\n\ndef get_signed_upload_url(path: str) -> str:\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    return conn.generate_url(15, 'GET', bucket=settings.S3_AUTH_UPLOADS_BUCKET, key=path)\n\ndef get_realm_for_filename(path: str) -> Optional[int]:\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    key = get_bucket(conn, settings.S3_AUTH_UPLOADS_BUCKET).get_key(path)\n    if key is None:\n        # This happens if the key does not exist.\n        return None\n    return get_user_profile_by_id(key.metadata[\"user_profile_id\"]).realm_id\n\nclass S3UploadBackend(ZulipUploadBackend):\n    def delete_file_from_s3(self, path_id: str, bucket_name: str) -> bool:\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n\n        # check if file exists\n        key = bucket.get_key(path_id)\n        if key is not None:\n            bucket.delete_key(key)\n            return True\n\n        file_name = path_id.split(\"/\")[-1]\n        logging.warning(\"%s does not exist. Its entry in the database will be removed.\" % (file_name,))\n        return False\n\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n        bucket_name = settings.S3_AUTH_UPLOADS_BUCKET\n        if target_realm is None:\n            target_realm = user_profile.realm\n        s3_file_name = \"/\".join([\n            str(target_realm.id),\n            random_name(18),\n            sanitize_name(uploaded_file_name)\n        ])\n        url = \"/user_uploads/%s\" % (s3_file_name,)\n\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            content_type,\n            user_profile,\n            file_data\n        )\n\n        create_attachment(uploaded_file_name, s3_file_name, user_profile, uploaded_file_size)\n        return url\n\n    def delete_message_image(self, path_id: str) -> bool:\n        return self.delete_file_from_s3(path_id, settings.S3_AUTH_UPLOADS_BUCKET)\n\n    def write_avatar_images(self, s3_file_name: str, target_user_profile: UserProfile,\n                            image_data: bytes, content_type: Optional[str]) -> None:\n        bucket_name = settings.S3_AVATAR_BUCKET\n\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            target_user_profile,\n            image_data,\n        )\n\n        # custom 500px wide version\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \"-medium.png\",\n            \"image/png\",\n            target_user_profile,\n            resized_medium\n        )\n\n        resized_data = resize_avatar(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            'image/png',\n            target_user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        content_type = guess_type(user_file.name)[0]\n        s3_file_name = user_avatar_path(target_user_profile)\n\n        image_data = user_file.read()\n        self.write_avatar_images(s3_file_name, target_user_profile,\n                                 image_data, content_type)\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        path_id = user_avatar_path(user)\n        bucket_name = settings.S3_AVATAR_BUCKET\n\n        self.delete_file_from_s3(path_id + \".original\", bucket_name)\n        self.delete_file_from_s3(path_id + \"-medium.png\", bucket_name)\n        self.delete_file_from_s3(path_id, bucket_name)\n\n    def get_avatar_key(self, file_name: str) -> Key:\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket_name = settings.S3_AVATAR_BUCKET\n        bucket = get_bucket(conn, bucket_name)\n\n        key = bucket.get_key(file_name)\n        return key\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        s3_source_file_name = user_avatar_path(source_profile)\n        s3_target_file_name = user_avatar_path(target_profile)\n\n        key = self.get_avatar_key(s3_source_file_name + \".original\")\n        image_data = key.get_contents_as_string()  # type: ignore # https://github.com/python/typeshed/issues/1552\n        content_type = key.content_type\n\n        self.write_avatar_images(s3_target_file_name, target_profile, image_data, content_type)  # type: ignore # image_data is `bytes`, boto subs are wrong\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        medium_suffix = \"-medium.png\" if medium else \"\"\n        # ?x=x allows templates to append additional parameters with &s\n        return \"https://%s.s3.amazonaws.com/%s%s?x=x\" % (bucket, hash_key, medium_suffix)\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        content_type = guess_type(icon_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        s3_file_name = os.path.join(str(user_profile.realm.id), 'realm', 'icon')\n\n        image_data = icon_file.read()\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            user_profile,\n            image_data,\n        )\n\n        resized_data = resize_avatar(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".png\",\n            'image/png',\n            user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        # ?x=x allows templates to append additional parameters with &s\n        return \"https://%s.s3.amazonaws.com/%s/realm/icon.png?version=%s\" % (bucket, realm_id, version)\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        content_type = guess_type(logo_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        if night:\n            basename = 'night_logo'\n        else:\n            basename = 'logo'\n        s3_file_name = os.path.join(str(user_profile.realm.id), 'realm', basename)\n\n        image_data = logo_file.read()\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            user_profile,\n            image_data,\n        )\n\n        resized_data = resize_logo(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".png\",\n            'image/png',\n            user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        # ?x=x allows templates to append additional parameters with &s\n        if not night:\n            file_name = 'logo.png'\n        else:\n            file_name = 'night_logo.png'\n        return \"https://%s.s3.amazonaws.com/%s/realm/%s?version=%s\" % (bucket, realm_id, file_name, version)\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(user_profile)\n        s3_file_name = file_path\n\n        bucket_name = settings.S3_AVATAR_BUCKET\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n        key = bucket.get_key(file_path + \".original\")\n        image_data = key.get_contents_as_string()\n\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)  # type: ignore # image_data is `bytes`, boto subs are wrong\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \"-medium.png\",\n            \"image/png\",\n            user_profile,\n            resized_medium\n        )\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:  # nocoverage\n        # TODO: Refactor this to share code with ensure_medium_avatar_image\n        file_path = user_avatar_path(user_profile)\n        # Also TODO: Migrate to user_avatar_path(user_profile) + \".png\".\n        s3_file_name = file_path\n\n        bucket_name = settings.S3_AVATAR_BUCKET\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n        key = bucket.get_key(file_path + \".original\")\n        image_data = key.get_contents_as_string()\n\n        resized_avatar = resize_avatar(image_data)  # type: ignore # image_data is `bytes`, boto subs are wrong\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            \"image/png\",\n            user_profile,\n            resized_avatar\n        )\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str,\n                           user_profile: UserProfile) -> None:\n        content_type = guess_type(emoji_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(\n            realm_id=user_profile.realm_id,\n            emoji_file_name=emoji_file_name\n        )\n\n        image_data = emoji_file.read()\n        resized_image_data = resize_emoji(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            \".\".join((emoji_path, \"original\")),\n            content_type,\n            user_profile,\n            image_data,\n        )\n        upload_image_to_s3(\n            bucket_name,\n            emoji_path,\n            content_type,\n            user_profile,\n            resized_image_data,\n        )\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(realm_id=realm_id,\n                                                        emoji_file_name=emoji_file_name)\n        return \"https://%s.s3.amazonaws.com/%s\" % (bucket, emoji_path)\n\n\n### Local\n\ndef write_local_file(type: str, path: str, file_data: bytes) -> None:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    with open(file_path, 'wb') as f:\n        f.write(file_data)\n\ndef read_local_file(type: str, path: str) -> bytes:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    with open(file_path, 'rb') as f:\n        return f.read()\n\ndef delete_local_file(type: str, path: str) -> bool:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    if os.path.isfile(file_path):\n        # This removes the file but the empty folders still remain.\n        os.remove(file_path)\n        return True\n    file_name = path.split(\"/\")[-1]\n    logging.warning(\"%s does not exist. Its entry in the database will be removed.\" % (file_name,))\n    return False\n\ndef get_local_file_path(path_id: str) -> Optional[str]:\n    local_path = os.path.join(settings.LOCAL_UPLOADS_DIR, 'files', path_id)\n    if os.path.isfile(local_path):\n        return local_path\n    else:\n        return None\n\nclass LocalUploadBackend(ZulipUploadBackend):\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n        # Split into 256 subdirectories to prevent directories from getting too big\n        path = \"/\".join([\n            str(user_profile.realm_id),\n            format(random.randint(0, 255), 'x'),\n            random_name(18),\n            sanitize_name(uploaded_file_name)\n        ])\n\n        write_local_file('files', path, file_data)\n        create_attachment(uploaded_file_name, path, user_profile, uploaded_file_size)\n        return '/user_uploads/' + path\n\n    def delete_message_image(self, path_id: str) -> bool:\n        return delete_local_file('files', path_id)\n\n    def write_avatar_images(self, file_path: str, image_data: bytes) -> None:\n        write_local_file('avatars', file_path + '.original', image_data)\n\n        resized_data = resize_avatar(image_data)\n        write_local_file('avatars', file_path + '.png', resized_data)\n\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        write_local_file('avatars', file_path + '-medium.png', resized_medium)\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(target_user_profile)\n\n        image_data = user_file.read()\n        self.write_avatar_images(file_path, image_data)\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        path_id = user_avatar_path(user)\n\n        delete_local_file(\"avatars\", path_id + \".original\")\n        delete_local_file(\"avatars\", path_id + \".png\")\n        delete_local_file(\"avatars\", path_id + \"-medium.png\")\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        medium_suffix = \"-medium\" if medium else \"\"\n        return \"/user_avatars/%s%s.png?x=x\" % (hash_key, medium_suffix)\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        source_file_path = user_avatar_path(source_profile)\n        target_file_path = user_avatar_path(target_profile)\n\n        image_data = read_local_file('avatars', source_file_path + '.original')\n        self.write_avatar_images(target_file_path, image_data)\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        upload_path = os.path.join('avatars', str(user_profile.realm.id), 'realm')\n\n        image_data = icon_file.read()\n        write_local_file(\n            upload_path,\n            'icon.original',\n            image_data)\n\n        resized_data = resize_avatar(image_data)\n        write_local_file(upload_path, 'icon.png', resized_data)\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        return \"/user_avatars/%s/realm/icon.png?version=%s\" % (realm_id, version)\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        upload_path = os.path.join('avatars', str(user_profile.realm.id), 'realm')\n        if night:\n            original_file = 'night_logo.original'\n            resized_file = 'night_logo.png'\n        else:\n            original_file = 'logo.original'\n            resized_file = 'logo.png'\n        image_data = logo_file.read()\n        write_local_file(\n            upload_path,\n            original_file,\n            image_data)\n\n        resized_data = resize_logo(image_data)\n        write_local_file(upload_path, resized_file, resized_data)\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        if night:\n            file_name = 'night_logo.png'\n        else:\n            file_name = 'logo.png'\n        return \"/user_avatars/%s/realm/%s?version=%s\" % (realm_id, file_name, version)\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(user_profile)\n\n        output_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \"-medium.png\")\n        if os.path.isfile(output_path):\n            return\n\n        image_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".original\")\n        image_data = open(image_path, \"rb\").read()\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        write_local_file('avatars', file_path + '-medium.png', resized_medium)\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:  # nocoverage\n        # TODO: Refactor this to share code with ensure_medium_avatar_image\n        file_path = user_avatar_path(user_profile)\n\n        output_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".png\")\n        if os.path.isfile(output_path):\n            return\n\n        image_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".original\")\n        image_data = open(image_path, \"rb\").read()\n        resized_avatar = resize_avatar(image_data)\n        write_local_file('avatars', file_path + '.png', resized_avatar)\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str,\n                           user_profile: UserProfile) -> None:\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(\n            realm_id= user_profile.realm_id,\n            emoji_file_name=emoji_file_name\n        )\n\n        image_data = emoji_file.read()\n        resized_image_data = resize_emoji(image_data)\n        write_local_file(\n            'avatars',\n            \".\".join((emoji_path, \"original\")),\n            image_data)\n        write_local_file(\n            'avatars',\n            emoji_path,\n            resized_image_data)\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        return os.path.join(\n            \"/user_avatars\",\n            RealmEmoji.PATH_ID_TEMPLATE.format(realm_id=realm_id, emoji_file_name=emoji_file_name))\n\n# Common and wrappers\nif settings.LOCAL_UPLOADS_DIR is not None:\n    upload_backend = LocalUploadBackend()  # type: ZulipUploadBackend\nelse:\n    upload_backend = S3UploadBackend()  # nocoverage\n\ndef delete_message_image(path_id: str) -> bool:\n    return upload_backend.delete_message_image(path_id)\n\ndef upload_avatar_image(user_file: File, acting_user_profile: UserProfile,\n                        target_user_profile: UserProfile) -> None:\n    upload_backend.upload_avatar_image(user_file, acting_user_profile, target_user_profile)\n\ndef delete_avatar_image(user_profile: UserProfile) -> None:\n    upload_backend.delete_avatar_image(user_profile)\n\ndef copy_avatar(source_profile: UserProfile, target_profile: UserProfile) -> None:\n    upload_backend.copy_avatar(source_profile, target_profile)\n\ndef upload_icon_image(user_file: File, user_profile: UserProfile) -> None:\n    upload_backend.upload_realm_icon_image(user_file, user_profile)\n\ndef upload_logo_image(user_file: File, user_profile: UserProfile, night: bool) -> None:\n    upload_backend.upload_realm_logo_image(user_file, user_profile, night)\n\ndef upload_emoji_image(emoji_file: File, emoji_file_name: str, user_profile: UserProfile) -> None:\n    upload_backend.upload_emoji_image(emoji_file, emoji_file_name, user_profile)\n\ndef upload_message_file(uploaded_file_name: str, uploaded_file_size: int,\n                        content_type: Optional[str], file_data: bytes,\n                        user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n    return upload_backend.upload_message_file(uploaded_file_name, uploaded_file_size,\n                                              content_type, file_data, user_profile,\n                                              target_realm=target_realm)\n\ndef claim_attachment(user_profile: UserProfile,\n                     path_id: str,\n                     message: Message,\n                     is_message_realm_public: bool) -> Attachment:\n    attachment = Attachment.objects.get(path_id=path_id)\n    attachment.messages.add(message)\n    attachment.is_realm_public = attachment.is_realm_public or is_message_realm_public\n    attachment.save()\n    return attachment\n\ndef create_attachment(file_name: str, path_id: str, user_profile: UserProfile,\n                      file_size: int) -> bool:\n    attachment = Attachment.objects.create(file_name=file_name, path_id=path_id, owner=user_profile,\n                                           realm=user_profile.realm, size=file_size)\n    from zerver.lib.actions import notify_attachment_update\n    notify_attachment_update(user_profile, 'add', attachment.to_dict())\n    return True\n\ndef upload_message_image_from_request(request: HttpRequest, user_file: File,\n                                      user_profile: UserProfile) -> str:\n    uploaded_file_name, uploaded_file_size, content_type = get_file_info(request, user_file)\n    return upload_message_file(uploaded_file_name, uploaded_file_size,\n                               content_type, user_file.read(), user_profile)\n", "# -*- coding: utf-8 -*-\n\nfrom django.http import HttpRequest, HttpResponse, HttpResponseForbidden, \\\n    HttpResponseNotFound\nfrom django.shortcuts import redirect\nfrom django.utils.translation import ugettext as _\n\nfrom zerver.lib.response import json_success, json_error\nfrom zerver.lib.upload import upload_message_image_from_request, get_local_file_path, \\\n    get_signed_upload_url, check_upload_within_quota, INLINE_MIME_TYPES\nfrom zerver.models import UserProfile, validate_attachment_request\nfrom django.conf import settings\nfrom sendfile import sendfile\nfrom mimetypes import guess_type\n\ndef serve_s3(request: HttpRequest, url_path: str) -> HttpResponse:\n    uri = get_signed_upload_url(url_path)\n    return redirect(uri)\n\ndef serve_local(request: HttpRequest, path_id: str) -> HttpResponse:\n    local_path = get_local_file_path(path_id)\n    if local_path is None:\n        return HttpResponseNotFound('<p>File not found</p>')\n\n    # Here we determine whether a browser should treat the file like\n    # an attachment (and thus clicking a link to it should download)\n    # or like a link (and thus clicking a link to it should display it\n    # in a browser tab).  This is controlled by the\n    # Content-Disposition header; `django-sendfile` sends the\n    # attachment-style version of that header if and only if the\n    # attachment argument is passed to it.  For attachments,\n    # django-sendfile sets the response['Content-disposition'] like\n    # this: `attachment; filename=\"b'zulip.txt'\"; filename*=UTF-8''zulip.txt`.\n    #\n    # The \"filename\" field (used to name the file when downloaded) is\n    # unreliable because it doesn't have a well-defined encoding; the\n    # newer filename* field takes precedence, since it uses a\n    # consistent format (urlquoted).  For more details on filename*\n    # and filename, see the below docs:\n    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\n    mimetype, encoding = guess_type(local_path)\n    attachment = mimetype not in INLINE_MIME_TYPES\n\n    return sendfile(request, local_path, attachment=attachment,\n                    mimetype=mimetype, encoding=encoding)\n\ndef serve_file_backend(request: HttpRequest, user_profile: UserProfile,\n                       realm_id_str: str, filename: str) -> HttpResponse:\n    path_id = \"%s/%s\" % (realm_id_str, filename)\n    is_authorized = validate_attachment_request(user_profile, path_id)\n\n    if is_authorized is None:\n        return HttpResponseNotFound(_(\"<p>File not found.</p>\"))\n    if not is_authorized:\n        return HttpResponseForbidden(_(\"<p>You are not authorized to view this file.</p>\"))\n    if settings.LOCAL_UPLOADS_DIR is not None:\n        return serve_local(request, path_id)\n\n    return serve_s3(request, path_id)\n\ndef upload_file_backend(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    if len(request.FILES) == 0:\n        return json_error(_(\"You must specify a file to upload\"))\n    if len(request.FILES) != 1:\n        return json_error(_(\"You may only upload one file at a time\"))\n\n    user_file = list(request.FILES.values())[0]\n    file_size = user_file._get_size()\n    if settings.MAX_FILE_UPLOAD_SIZE * 1024 * 1024 < file_size:\n        return json_error(_(\"Uploaded file is larger than the allowed limit of %s MB\") % (\n            settings.MAX_FILE_UPLOAD_SIZE))\n    check_upload_within_quota(user_profile.realm, file_size)\n\n    if not isinstance(user_file.name, str):\n        # It seems that in Python 2 unicode strings containing bytes are\n        # rendered differently than ascii strings containing same bytes.\n        #\n        # Example:\n        # >>> print('\\xd3\\x92')\n        # \u04d2\n        # >>> print(u'\\xd3\\x92')\n        # \u00d3\n        #\n        # This is the cause of the problem as user_file.name variable\n        # is received as a unicode which is converted into unicode\n        # strings containing bytes and is rendered incorrectly.\n        #\n        # Example:\n        # >>> import urllib.parse\n        # >>> name = u'%D0%97%D0%B4%D1%80%D0%B0%D0%B2%D0%B5%D0%B8%CC%86%D1%82%D0%B5.txt'\n        # >>> print(urllib.parse.unquote(name))\n        # \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00b5\u00d0\u00b8\u00cc\u0086\u00d1\u0082\u00d0\u00b5  # This is wrong\n        #\n        # >>> name = '%D0%97%D0%B4%D1%80%D0%B0%D0%B2%D0%B5%D0%B8%CC%86%D1%82%D0%B5.txt'\n        # >>> print(urllib.parse.unquote(name))\n        # \u0417\u0434\u0440\u0430\u0432\u0435\u0438\u0306\u0442\u0435.txt  # This is correct\n        user_file.name = user_file.name.encode('ascii')\n\n    uri = upload_message_image_from_request(request, user_file, user_profile)\n    return json_success({'uri': uri})\n"], "filenames": ["zerver/lib/upload.py", "zerver/views/upload.py"], "buggy_code_start_loc": [1, 10], "buggy_code_end_loc": [274, 48], "fixing_code_start_loc": [1, 10], "fixing_code_end_loc": [286, 46], "type": "CWE-79", "message": "Zulip server before 2.0.5 incompletely validated the MIME types of uploaded files. A user who is logged into the server could upload files of certain types to mount a stored cross-site scripting attack on other logged-in users. On a Zulip server using the default local uploads backend, the attack is only effective against browsers lacking support for Content-Security-Policy such as Internet Explorer 11. On a Zulip server using the S3 uploads backend, the attack is confined to the origin of the configured S3 uploads hostname and cannot reach the Zulip server itself.", "other": {"cve": {"id": "CVE-2019-16216", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-18T12:15:10.990", "lastModified": "2019-09-18T18:43:07.133", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Zulip server before 2.0.5 incompletely validated the MIME types of uploaded files. A user who is logged into the server could upload files of certain types to mount a stored cross-site scripting attack on other logged-in users. On a Zulip server using the default local uploads backend, the attack is only effective against browsers lacking support for Content-Security-Policy such as Internet Explorer 11. On a Zulip server using the S3 uploads backend, the attack is confined to the origin of the configured S3 uploads hostname and cannot reach the Zulip server itself."}, {"lang": "es", "value": "El servidor Zulip versiones anteriores a 2.0.5, valid\u00f3 de manera incompleta los tipos MIME de archivos cargados. Un usuario que haya iniciado sesi\u00f3n en el servidor podr\u00eda cargar archivos de ciertos tipos para montar un ataque de tipo cross-site scripting almacenado sobre otros usuarios registrados. En un servidor Zulip que usa el backend de carga local predeterminado, el ataque solo es efectivo contra los navegadores que carecen de soporte para Content-Security-Policy como Internet Explorer versi\u00f3n 11. En un servidor Zulip usando el backend de carga S3, el ataque es confinado en el origen del hostname de carga S3 configurado y no puede alcanzar al servidor Zulip en s\u00ed."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.8.0", "versionEndExcluding": "2.0.5", "matchCriteriaId": "99AA5469-A827-4562-9BF6-E7A1928EFF96"}]}]}], "references": [{"url": "https://blog.zulip.org/2019/09/11/zulip-server-2-0-5-security-release/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/zulip/zulip/commit/1195841dfb9aa26b3b0dabc6f05d72e4af25be3e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zulip/zulip/commit/1195841dfb9aa26b3b0dabc6f05d72e4af25be3e"}}