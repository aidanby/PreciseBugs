{"buggy_code": ["#include <string.h>\n#include <napi.h>\n#include <uv.h>\n\n#include \"macros.h\"\n#include \"database.h\"\n#include \"statement.h\"\n\nusing namespace node_sqlite3;\n\nNapi::Object Statement::Init(Napi::Env env, Napi::Object exports) {\n    Napi::HandleScope scope(env);\n\n    Napi::Function t = DefineClass(env, \"Statement\", {\n      InstanceMethod(\"bind\", &Statement::Bind),\n      InstanceMethod(\"get\", &Statement::Get),\n      InstanceMethod(\"run\", &Statement::Run),\n      InstanceMethod(\"all\", &Statement::All),\n      InstanceMethod(\"each\", &Statement::Each),\n      InstanceMethod(\"reset\", &Statement::Reset),\n      InstanceMethod(\"finalize\", &Statement::Finalize_),\n    });\n\n    exports.Set(\"Statement\", t);\n    return exports;\n}\n\n// A Napi InstanceOf for Javascript Objects \"Date\" and \"RegExp\"\nbool OtherInstanceOf(Napi::Object source, const char* object_type) {\n    if (strncmp(object_type, \"Date\", 4) == 0) {\n        return source.InstanceOf(source.Env().Global().Get(\"Date\").As<Function>());\n    } else if (strncmp(object_type, \"RegExp\", 6) == 0) {\n        return source.InstanceOf(source.Env().Global().Get(\"RegExp\").As<Function>());\n    }\n\n    return false;\n}\n\nvoid Statement::Process() {\n    if (finalized && !queue.empty()) {\n        return CleanQueue();\n    }\n\n    while (prepared && !locked && !queue.empty()) {\n        std::unique_ptr<Call> call(queue.front());\n        queue.pop();\n\n        call->callback(call->baton);\n    }\n}\n\nvoid Statement::Schedule(Work_Callback callback, Baton* baton) {\n    if (finalized) {\n        queue.push(new Call(callback, baton));\n        CleanQueue();\n    }\n    else if (!prepared || locked) {\n        queue.push(new Call(callback, baton));\n    }\n    else {\n        callback(baton);\n    }\n}\n\ntemplate <class T> void Statement::Error(T* baton) {\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    // Fail hard on logic errors.\n    assert(stmt->status != 0);\n    EXCEPTION(Napi::String::New(env, stmt->message.c_str()), stmt->status, exception);\n\n    Napi::Function cb = baton->callback.Value();\n\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { exception };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n    else {\n        Napi::Value argv[] = { Napi::String::New(env, \"error\"), exception };\n        EMIT_EVENT(stmt->Value(), 2, argv);\n    }\n}\n\n// { Database db, String sql, Array params, Function callback }\nStatement::Statement(const Napi::CallbackInfo& info) : Napi::ObjectWrap<Statement>(info) {\n    Napi::Env env = info.Env();\n    int length = info.Length();\n\n    if (length <= 0 || !Database::HasInstance(info[0])) {\n        Napi::TypeError::New(env, \"Database object expected\").ThrowAsJavaScriptException();\n        return;\n    }\n    else if (length <= 1 || !info[1].IsString()) {\n        Napi::TypeError::New(env, \"SQL query expected\").ThrowAsJavaScriptException();\n        return;\n    }\n    else if (length > 2 && !info[2].IsUndefined() && !info[2].IsFunction()) {\n        Napi::TypeError::New(env, \"Callback expected\").ThrowAsJavaScriptException();\n        return;\n    }\n\n    Database* db = Napi::ObjectWrap<Database>::Unwrap(info[0].As<Napi::Object>());\n    Napi::String sql = info[1].As<Napi::String>();\n\n    info.This().As<Napi::Object>().DefineProperty(Napi::PropertyDescriptor::Value(\"sql\", sql, napi_default));\n\n    init(db);\n    Statement* stmt = this;\n\n    PrepareBaton* baton = new PrepareBaton(db, info[2].As<Napi::Function>(), stmt);\n    baton->sql = std::string(sql.As<Napi::String>().Utf8Value().c_str());\n    db->Schedule(Work_BeginPrepare, baton);\n}\n\nvoid Statement::Work_BeginPrepare(Database::Baton* baton) {\n    assert(baton->db->open);\n    baton->db->pending++;\n    Napi::Env env = baton->db->Env();\n    int status = napi_create_async_work(\n        env, NULL, Napi::String::New(env, \"sqlite3.Statement.Prepare\"),\n        Work_Prepare, Work_AfterPrepare, baton, &baton->request\n    );\n    assert(status == 0);\n    napi_queue_async_work(env, baton->request);\n}\n\nvoid Statement::Work_Prepare(napi_env e, void* data) {\n    STATEMENT_INIT(PrepareBaton);\n\n    // In case preparing fails, we use a mutex to make sure we get the associated\n    // error message.\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n\n    stmt->status = sqlite3_prepare_v2(\n        baton->db->_handle,\n        baton->sql.c_str(),\n        baton->sql.size(),\n        &stmt->_handle,\n        NULL\n    );\n\n    if (stmt->status != SQLITE_OK) {\n        stmt->message = std::string(sqlite3_errmsg(baton->db->_handle));\n        stmt->_handle = NULL;\n    }\n\n    sqlite3_mutex_leave(mtx);\n}\n\nvoid Statement::Work_AfterPrepare(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<PrepareBaton> baton(static_cast<PrepareBaton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_OK) {\n        Error(baton.get());\n        stmt->Finalize_();\n    }\n    else {\n        stmt->prepared = true;\n        if (!baton->callback.IsEmpty() && baton->callback.Value().IsFunction()) {\n            Napi::Function cb = baton->callback.Value();\n            Napi::Value argv[] = { env.Null() };\n            TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n        }\n    }\n\n    STATEMENT_END();\n}\n\ntemplate <class T> Values::Field*\n                   Statement::BindParameter(const Napi::Value source, T pos) {\n    if (source.IsString()) {\n        std::string val = source.As<Napi::String>().Utf8Value();\n        return new Values::Text(pos, val.length(), val.c_str());\n    }\n    else if (OtherInstanceOf(source.As<Object>(), \"RegExp\")) {\n        std::string val = source.ToString().Utf8Value();\n        return new Values::Text(pos, val.length(), val.c_str());\n    }\n    else if (source.IsNumber()) {\n        if (OtherIsInt(source.As<Napi::Number>())) {\n            return new Values::Integer(pos, source.As<Napi::Number>().Int32Value());\n        } else {\n            return new Values::Float(pos, source.As<Napi::Number>().DoubleValue());\n        }\n    }\n    else if (source.IsBoolean()) {\n        return new Values::Integer(pos, source.As<Napi::Boolean>().Value() ? 1 : 0);\n    }\n    else if (source.IsNull()) {\n        return new Values::Null(pos);\n    }\n    else if (source.IsBuffer()) {\n        Napi::Buffer<char> buffer = source.As<Napi::Buffer<char>>();\n        return new Values::Blob(pos, buffer.Length(), buffer.Data());\n    }\n    else if (OtherInstanceOf(source.As<Object>(), \"Date\")) {\n        return new Values::Float(pos, source.ToNumber().DoubleValue());\n    }\n    else if (source.IsObject()) {\n        std::string val = source.ToString().Utf8Value();\n        return new Values::Text(pos, val.length(), val.c_str());\n    }\n    else {\n        return NULL;\n    }\n}\n\ntemplate <class T> T* Statement::Bind(const Napi::CallbackInfo& info, int start, int last) {\n    Napi::Env env = info.Env();\n    Napi::HandleScope scope(env);\n\n    if (last < 0) last = info.Length();\n    Napi::Function callback;\n    if (last > start && info[last - 1].IsFunction()) {\n        callback = info[last - 1].As<Napi::Function>();\n        last--;\n    }\n\n    T* baton = new T(this, callback);\n\n    if (start < last) {\n        if (info[start].IsArray()) {\n            Napi::Array array = info[start].As<Napi::Array>();\n            int length = array.Length();\n            // Note: bind parameters start with 1.\n            for (int i = 0, pos = 1; i < length; i++, pos++) {\n                baton->parameters.push_back(BindParameter((array).Get(i), pos));\n            }\n        }\n        else if (!info[start].IsObject() || OtherInstanceOf(info[start].As<Object>(), \"RegExp\") || OtherInstanceOf(info[start].As<Object>(), \"Date\") || info[start].IsBuffer()) {\n            // Parameters directly in array.\n            // Note: bind parameters start with 1.\n            for (int i = start, pos = 1; i < last; i++, pos++) {\n                baton->parameters.push_back(BindParameter(info[i], pos));\n            }\n        }\n        else if (info[start].IsObject()) {\n            Napi::Object object = info[start].As<Napi::Object>();\n            Napi::Array array = object.GetPropertyNames();\n            int length = array.Length();\n            for (int i = 0; i < length; i++) {\n                Napi::Value name = (array).Get(i);\n                Napi::Number num = name.ToNumber();\n\n                if (num.Int32Value() == num.DoubleValue()) {\n                    baton->parameters.push_back(\n                        BindParameter((object).Get(name), num.Int32Value()));\n                }\n                else {\n                    baton->parameters.push_back(BindParameter((object).Get(name),\n                        name.As<Napi::String>().Utf8Value().c_str()));\n                }\n            }\n        }\n        else {\n            return NULL;\n        }\n    }\n\n    return baton;\n}\n\nbool Statement::Bind(const Parameters & parameters) {\n    if (parameters.size() == 0) {\n        return true;\n    }\n\n    sqlite3_reset(_handle);\n    sqlite3_clear_bindings(_handle);\n\n    Parameters::const_iterator it = parameters.begin();\n    Parameters::const_iterator end = parameters.end();\n\n    for (; it < end; ++it) {\n        Values::Field* field = *it;\n\n        if (field != NULL) {\n            unsigned int pos;\n            if (field->index > 0) {\n                pos = field->index;\n            }\n            else {\n                pos = sqlite3_bind_parameter_index(_handle, field->name.c_str());\n            }\n\n            switch (field->type) {\n                case SQLITE_INTEGER: {\n                    status = sqlite3_bind_int(_handle, pos,\n                        ((Values::Integer*)field)->value);\n                } break;\n                case SQLITE_FLOAT: {\n                    status = sqlite3_bind_double(_handle, pos,\n                        ((Values::Float*)field)->value);\n                } break;\n                case SQLITE_TEXT: {\n                    status = sqlite3_bind_text(_handle, pos,\n                        ((Values::Text*)field)->value.c_str(),\n                        ((Values::Text*)field)->value.size(), SQLITE_TRANSIENT);\n                } break;\n                case SQLITE_BLOB: {\n                    status = sqlite3_bind_blob(_handle, pos,\n                        ((Values::Blob*)field)->value,\n                        ((Values::Blob*)field)->length, SQLITE_TRANSIENT);\n                } break;\n                case SQLITE_NULL: {\n                    status = sqlite3_bind_null(_handle, pos);\n                } break;\n            }\n\n            if (status != SQLITE_OK) {\n                message = std::string(sqlite3_errmsg(db->_handle));\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nNapi::Value Statement::Bind(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    Baton* baton = stmt->Bind<Baton>(info);\n    if (baton == NULL) {\n        Napi::TypeError::New(env, \"Data type is not supported\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    else {\n        stmt->Schedule(Work_BeginBind, baton);\n        return info.This();\n    }\n}\n\nvoid Statement::Work_BeginBind(Baton* baton) {\n    STATEMENT_BEGIN(Bind);\n}\n\nvoid Statement::Work_Bind(napi_env e, void* data) {\n    STATEMENT_INIT(Baton);\n\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n    stmt->Bind(baton->parameters);\n    sqlite3_mutex_leave(mtx);\n}\n\nvoid Statement::Work_AfterBind(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_OK) {\n        Error(baton.get());\n    }\n    else {\n        // Fire callbacks.\n        Napi::Function cb = baton->callback.Value();\n        if (!cb.IsUndefined() && cb.IsFunction()) {\n            Napi::Value argv[] = { env.Null() };\n            TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n        }\n    }\n\n    STATEMENT_END();\n}\n\n\n\nNapi::Value Statement::Get(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    Baton* baton = stmt->Bind<RowBaton>(info);\n    if (baton == NULL) {\n        Napi::Error::New(env, \"Data type is not supported\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    else {\n        stmt->Schedule(Work_BeginGet, baton);\n        return info.This();\n    }\n}\n\nvoid Statement::Work_BeginGet(Baton* baton) {\n    STATEMENT_BEGIN(Get);\n}\n\nvoid Statement::Work_Get(napi_env e, void* data) {\n    STATEMENT_INIT(RowBaton);\n\n    if (stmt->status != SQLITE_DONE || baton->parameters.size()) {\n        STATEMENT_MUTEX(mtx);\n        sqlite3_mutex_enter(mtx);\n\n        if (stmt->Bind(baton->parameters)) {\n            stmt->status = sqlite3_step(stmt->_handle);\n\n            if (!(stmt->status == SQLITE_ROW || stmt->status == SQLITE_DONE)) {\n                stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));\n            }\n        }\n\n        sqlite3_mutex_leave(mtx);\n\n        if (stmt->status == SQLITE_ROW) {\n            // Acquire one result row before returning.\n            GetRow(&baton->row, stmt->_handle);\n        }\n    }\n}\n\nvoid Statement::Work_AfterGet(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<RowBaton> baton(static_cast<RowBaton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_ROW && stmt->status != SQLITE_DONE) {\n        Error(baton.get());\n    }\n    else {\n        // Fire callbacks.\n        Napi::Function cb = baton->callback.Value();\n        if (!cb.IsUndefined() && cb.IsFunction()) {\n            if (stmt->status == SQLITE_ROW) {\n                // Create the result array from the data we acquired.\n                Napi::Value argv[] = { env.Null(), RowToJS(env, &baton->row) };\n                TRY_CATCH_CALL(stmt->Value(), cb, 2, argv);\n            }\n            else {\n                Napi::Value argv[] = { env.Null() };\n                TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n            }\n        }\n    }\n\n    STATEMENT_END();\n}\n\nNapi::Value Statement::Run(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    Baton* baton = stmt->Bind<RunBaton>(info);\n    if (baton == NULL) {\n        Napi::Error::New(env, \"Data type is not supported\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    else {\n        stmt->Schedule(Work_BeginRun, baton);\n        return info.This();\n    }\n}\n\nvoid Statement::Work_BeginRun(Baton* baton) {\n    STATEMENT_BEGIN(Run);\n}\n\nvoid Statement::Work_Run(napi_env e, void* data) {\n    STATEMENT_INIT(RunBaton);\n\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n\n    // Make sure that we also reset when there are no parameters.\n    if (!baton->parameters.size()) {\n        sqlite3_reset(stmt->_handle);\n    }\n\n    if (stmt->Bind(baton->parameters)) {\n        stmt->status = sqlite3_step(stmt->_handle);\n\n        if (!(stmt->status == SQLITE_ROW || stmt->status == SQLITE_DONE)) {\n            stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));\n        }\n        else {\n            baton->inserted_id = sqlite3_last_insert_rowid(stmt->db->_handle);\n            baton->changes = sqlite3_changes(stmt->db->_handle);\n        }\n    }\n\n    sqlite3_mutex_leave(mtx);\n}\n\nvoid Statement::Work_AfterRun(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<RunBaton> baton(static_cast<RunBaton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_ROW && stmt->status != SQLITE_DONE) {\n        Error(baton.get());\n    }\n    else {\n        // Fire callbacks.\n        Napi::Function cb = baton->callback.Value();\n        if (!cb.IsUndefined() && cb.IsFunction()) {\n            (stmt->Value()).Set(Napi::String::New(env, \"lastID\"), Napi::Number::New(env, baton->inserted_id));\n            (stmt->Value()).Set( Napi::String::New(env, \"changes\"), Napi::Number::New(env, baton->changes));\n\n            Napi::Value argv[] = { env.Null() };\n            TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n        }\n    }\n\n    STATEMENT_END();\n}\n\nNapi::Value Statement::All(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    Baton* baton = stmt->Bind<RowsBaton>(info);\n    if (baton == NULL) {\n        Napi::Error::New(env, \"Data type is not supported\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    else {\n        stmt->Schedule(Work_BeginAll, baton);\n        return info.This();\n    }\n}\n\nvoid Statement::Work_BeginAll(Baton* baton) {\n    STATEMENT_BEGIN(All);\n}\n\nvoid Statement::Work_All(napi_env e, void* data) {\n    STATEMENT_INIT(RowsBaton);\n\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n\n    // Make sure that we also reset when there are no parameters.\n    if (!baton->parameters.size()) {\n        sqlite3_reset(stmt->_handle);\n    }\n\n    if (stmt->Bind(baton->parameters)) {\n        while ((stmt->status = sqlite3_step(stmt->_handle)) == SQLITE_ROW) {\n            Row* row = new Row();\n            GetRow(row, stmt->_handle);\n            baton->rows.push_back(row);\n        }\n\n        if (stmt->status != SQLITE_DONE) {\n            stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));\n        }\n    }\n\n    sqlite3_mutex_leave(mtx);\n}\n\nvoid Statement::Work_AfterAll(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<RowsBaton> baton(static_cast<RowsBaton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_DONE) {\n        Error(baton.get());\n    }\n    else {\n        // Fire callbacks.\n        Napi::Function cb = baton->callback.Value();\n        if (!cb.IsUndefined() && cb.IsFunction()) {\n            if (baton->rows.size()) {\n                // Create the result array from the data we acquired.\n                Napi::Array result(Napi::Array::New(env, baton->rows.size()));\n                Rows::const_iterator it = baton->rows.begin();\n                Rows::const_iterator end = baton->rows.end();\n                for (int i = 0; it < end; ++it, i++) {\n                    std::unique_ptr<Row> row(*it);\n                    (result).Set(i, RowToJS(env,row.get()));\n                }\n\n                Napi::Value argv[] = { env.Null(), result };\n                TRY_CATCH_CALL(stmt->Value(), cb, 2, argv);\n            }\n            else {\n                // There were no result rows.\n                Napi::Value argv[] = {\n                    env.Null(),\n                    Napi::Array::New(env, 0)\n                };\n                TRY_CATCH_CALL(stmt->Value(), cb, 2, argv);\n            }\n        }\n    }\n\n    STATEMENT_END();\n}\n\nNapi::Value Statement::Each(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    int last = info.Length();\n\n    Napi::Function completed;\n    if (last >= 2 && info[last - 1].IsFunction() && info[last - 2].IsFunction()) {\n        completed = info[--last].As<Napi::Function>();\n    }\n\n    EachBaton* baton = stmt->Bind<EachBaton>(info, 0, last);\n    if (baton == NULL) {\n        Napi::Error::New(env, \"Data type is not supported\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    else {\n        baton->completed.Reset(completed, 1);\n        stmt->Schedule(Work_BeginEach, baton);\n        return info.This();\n    }\n}\n\nvoid Statement::Work_BeginEach(Baton* baton) {\n    // Only create the Async object when we're actually going into\n    // the event loop. This prevents dangling events.\n    EachBaton* each_baton = static_cast<EachBaton*>(baton);\n    each_baton->async = new Async(each_baton->stmt, reinterpret_cast<uv_async_cb>(AsyncEach));\n    each_baton->async->item_cb.Reset(each_baton->callback.Value(), 1);\n    each_baton->async->completed_cb.Reset(each_baton->completed.Value(), 1);\n\n    STATEMENT_BEGIN(Each);\n}\n\nvoid Statement::Work_Each(napi_env e, void* data) {\n    STATEMENT_INIT(EachBaton);\n\n    Async* async = baton->async;\n\n    STATEMENT_MUTEX(mtx);\n\n    int retrieved = 0;\n\n    // Make sure that we also reset when there are no parameters.\n    if (!baton->parameters.size()) {\n        sqlite3_reset(stmt->_handle);\n    }\n\n    if (stmt->Bind(baton->parameters)) {\n        while (true) {\n            sqlite3_mutex_enter(mtx);\n            stmt->status = sqlite3_step(stmt->_handle);\n            if (stmt->status == SQLITE_ROW) {\n                sqlite3_mutex_leave(mtx);\n                Row* row = new Row();\n                GetRow(row, stmt->_handle);\n                NODE_SQLITE3_MUTEX_LOCK(&async->mutex)\n                async->data.push_back(row);\n                retrieved++;\n                NODE_SQLITE3_MUTEX_UNLOCK(&async->mutex)\n\n                uv_async_send(&async->watcher);\n            }\n            else {\n                if (stmt->status != SQLITE_DONE) {\n                    stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));\n                }\n                sqlite3_mutex_leave(mtx);\n                break;\n            }\n        }\n    }\n\n    async->completed = true;\n    uv_async_send(&async->watcher);\n}\n\nvoid Statement::CloseCallback(uv_handle_t* handle) {\n    assert(handle != NULL);\n    assert(handle->data != NULL);\n    Async* async = static_cast<Async*>(handle->data);\n    delete async;\n}\n\nvoid Statement::AsyncEach(uv_async_t* handle) {\n    Async* async = static_cast<Async*>(handle->data);\n\n    Napi::Env env = async->stmt->Env();\n    Napi::HandleScope scope(env);\n\n    while (true) {\n        // Get the contents out of the data cache for us to process in the JS callback.\n        Rows rows;\n        NODE_SQLITE3_MUTEX_LOCK(&async->mutex)\n        rows.swap(async->data);\n        NODE_SQLITE3_MUTEX_UNLOCK(&async->mutex)\n\n        if (rows.empty()) {\n            break;\n        }\n\n        Napi::Function cb = async->item_cb.Value();\n        if (!cb.IsUndefined() && cb.IsFunction()) {\n            Napi::Value argv[2];\n            argv[0] = env.Null();\n\n            Rows::const_iterator it = rows.begin();\n            Rows::const_iterator end = rows.end();\n            for (int i = 0; it < end; ++it, i++) {\n                std::unique_ptr<Row> row(*it);\n                argv[1] = RowToJS(env,row.get());\n                async->retrieved++;\n                TRY_CATCH_CALL(async->stmt->Value(), cb, 2, argv);\n            }\n        }\n    }\n\n    Napi::Function cb = async->completed_cb.Value();\n    if (async->completed) {\n        if (!cb.IsEmpty() &&\n                cb.IsFunction()) {\n            Napi::Value argv[] = {\n                env.Null(),\n                Napi::Number::New(env, async->retrieved)\n            };\n            TRY_CATCH_CALL(async->stmt->Value(), cb, 2, argv);\n        }\n        uv_close(reinterpret_cast<uv_handle_t*>(handle), CloseCallback);\n    }\n}\n\nvoid Statement::Work_AfterEach(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<EachBaton> baton(static_cast<EachBaton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_DONE) {\n        Error(baton.get());\n    }\n\n    STATEMENT_END();\n}\n\nNapi::Value Statement::Reset(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    OPTIONAL_ARGUMENT_FUNCTION(0, callback);\n\n    Baton* baton = new Baton(stmt, callback);\n    stmt->Schedule(Work_BeginReset, baton);\n\n    return info.This();\n}\n\nvoid Statement::Work_BeginReset(Baton* baton) {\n    STATEMENT_BEGIN(Reset);\n}\n\nvoid Statement::Work_Reset(napi_env e, void* data) {\n    STATEMENT_INIT(Baton);\n\n    sqlite3_reset(stmt->_handle);\n    stmt->status = SQLITE_OK;\n}\n\nvoid Statement::Work_AfterReset(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    // Fire callbacks.\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { env.Null() };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n\n    STATEMENT_END();\n}\n\nNapi::Value Statement::RowToJS(Napi::Env env, Row* row) {\n    Napi::EscapableHandleScope scope(env);\n\n    Napi::Object result = Napi::Object::New(env);\n\n    Row::const_iterator it = row->begin();\n    Row::const_iterator end = row->end();\n    for (int i = 0; it < end; ++it, i++) {\n        Values::Field* field = *it;\n\n        Napi::Value value;\n\n        switch (field->type) {\n            case SQLITE_INTEGER: {\n                value = Napi::Number::New(env, ((Values::Integer*)field)->value);\n            } break;\n            case SQLITE_FLOAT: {\n                value = Napi::Number::New(env, ((Values::Float*)field)->value);\n            } break;\n            case SQLITE_TEXT: {\n                value = Napi::String::New(env, ((Values::Text*)field)->value.c_str(), ((Values::Text*)field)->value.size());\n            } break;\n            case SQLITE_BLOB: {\n                value = Napi::Buffer<char>::Copy(env, ((Values::Blob*)field)->value, ((Values::Blob*)field)->length);\n            } break;\n            case SQLITE_NULL: {\n                value = env.Null();\n            } break;\n        }\n\n        (result).Set(Napi::String::New(env, field->name.c_str()), value);\n\n        DELETE_FIELD(field);\n    }\n\n    return scope.Escape(result);\n}\n\nvoid Statement::GetRow(Row* row, sqlite3_stmt* stmt) {\n    int rows = sqlite3_column_count(stmt);\n\n    for (int i = 0; i < rows; i++) {\n        int type = sqlite3_column_type(stmt, i);\n        const char* name = sqlite3_column_name(stmt, i);\n        switch (type) {\n            case SQLITE_INTEGER: {\n                row->push_back(new Values::Integer(name, sqlite3_column_int64(stmt, i)));\n            }   break;\n            case SQLITE_FLOAT: {\n                row->push_back(new Values::Float(name, sqlite3_column_double(stmt, i)));\n            }   break;\n            case SQLITE_TEXT: {\n                const char* text = (const char*)sqlite3_column_text(stmt, i);\n                int length = sqlite3_column_bytes(stmt, i);\n                row->push_back(new Values::Text(name, length, text));\n            } break;\n            case SQLITE_BLOB: {\n                const void* blob = sqlite3_column_blob(stmt, i);\n                int length = sqlite3_column_bytes(stmt, i);\n                row->push_back(new Values::Blob(name, length, blob));\n            }   break;\n            case SQLITE_NULL: {\n                row->push_back(new Values::Null(name));\n            }   break;\n            default:\n                assert(false);\n        }\n    }\n}\n\nNapi::Value Statement::Finalize_(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n    OPTIONAL_ARGUMENT_FUNCTION(0, callback);\n\n    Baton* baton = new Baton(stmt, callback);\n    stmt->Schedule(Finalize_, baton);\n\n    return stmt->db->Value();\n}\n\nvoid Statement::Finalize_(Baton* b) {\n    std::unique_ptr<Baton> baton(b);\n    Napi::Env env = baton->stmt->Env();\n    Napi::HandleScope scope(env);\n\n    baton->stmt->Finalize_();\n\n    // Fire callback in case there was one.\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        TRY_CATCH_CALL(baton->stmt->Value(), cb, 0, NULL);\n    }\n}\n\nvoid Statement::Finalize_() {\n    assert(!finalized);\n    finalized = true;\n    CleanQueue();\n    // Finalize returns the status code of the last operation. We already fired\n    // error events in case those failed.\n    sqlite3_finalize(_handle);\n    _handle = NULL;\n    db->Unref();\n}\n\nvoid Statement::CleanQueue() {\n    Napi::Env env = this->Env();\n    Napi::HandleScope scope(env);\n\n    if (prepared && !queue.empty()) {\n        // This statement has already been prepared and is now finalized.\n        // Fire error for all remaining items in the queue.\n        EXCEPTION(Napi::String::New(env, \"Statement is already finalized\"), SQLITE_MISUSE, exception);\n        Napi::Value argv[] = { exception };\n        bool called = false;\n\n        // Clear out the queue so that this object can get GC'ed.\n        while (!queue.empty()) {\n            std::unique_ptr<Call> call(queue.front());\n            queue.pop();\n\n            std::unique_ptr<Baton> baton(call->baton);\n            Napi::Function cb = baton->callback.Value();\n\n            if (prepared && !cb.IsEmpty() &&\n                cb.IsFunction()) {\n                TRY_CATCH_CALL(Value(), cb, 1, argv);\n                called = true;\n            }\n        }\n\n        // When we couldn't call a callback function, emit an error on the\n        // Statement object.\n        if (!called) {\n            Napi::Value info[] = { Napi::String::New(env, \"error\"), exception };\n            EMIT_EVENT(Value(), 2, info);\n        }\n    }\n    else while (!queue.empty()) {\n        // Just delete all items in the queue; we already fired an event when\n        // preparing the statement failed.\n        std::unique_ptr<Call> call(queue.front());\n        queue.pop();\n        // We don't call the actual callback, so we have to make sure that\n        // the baton gets destroyed.\n        delete call->baton;\n    }\n}\n", "var sqlite3 = require('..');\nvar assert = require('assert');\n\ndescribe('data types', function() {\n    var db;\n    before(function(done) {\n        db = new sqlite3.Database(':memory:');\n        db.run(\"CREATE TABLE txt_table (txt TEXT)\");\n        db.run(\"CREATE TABLE int_table (int INTEGER)\");\n        db.run(\"CREATE TABLE flt_table (flt FLOAT)\");\n        db.wait(done);\n    });\n\n    beforeEach(function(done) {\n        db.exec('DELETE FROM txt_table; DELETE FROM int_table; DELETE FROM flt_table;', done);\n    });\n\n    it('should serialize Date()', function(done) {\n        var date = new Date();\n        db.run(\"INSERT INTO int_table VALUES(?)\", date, function (err) {\n            if (err) throw err;\n            db.get(\"SELECT int FROM int_table\", function(err, row) {\n                if (err) throw err;\n                assert.equal(row.int, +date);\n                done();\n            });\n        });\n    });\n\n    it('should serialize RegExp()', function(done) {\n        var regexp = /^f\\noo/;\n        db.run(\"INSERT INTO txt_table VALUES(?)\", regexp, function (err) {\n            if (err) throw err;\n            db.get(\"SELECT txt FROM txt_table\", function(err, row) {\n                if (err) throw err;\n                assert.equal(row.txt, String(regexp));\n                done();\n            });\n        });\n    });\n\n    [\n        4294967296.249,\n        Math.PI,\n        3924729304762836.5,\n        new Date().valueOf(),\n        912667.394828365,\n        2.3948728634826374e+83,\n        9.293476892934982e+300,\n        Infinity,\n        -9.293476892934982e+300,\n        -2.3948728634826374e+83,\n        -Infinity\n    ].forEach(function(flt) {\n        it('should serialize float ' + flt, function(done) {\n            db.run(\"INSERT INTO flt_table VALUES(?)\", flt, function (err) {\n                if (err) throw err;\n                db.get(\"SELECT flt FROM flt_table\", function(err, row) {\n                    if (err) throw err;\n                    assert.equal(row.flt, flt);\n                    done();\n                });\n            });\n        });\n    });\n\n    [\n        4294967299,\n        3924729304762836,\n        new Date().valueOf(),\n        2.3948728634826374e+83,\n        9.293476892934982e+300,\n        Infinity,\n        -9.293476892934982e+300,\n        -2.3948728634826374e+83,\n        -Infinity\n    ].forEach(function(integer) {\n        it('should serialize integer ' + integer, function(done) {\n            db.run(\"INSERT INTO int_table VALUES(?)\", integer, function (err) {\n                if (err) throw err;\n                db.get(\"SELECT int AS integer FROM int_table\", function(err, row) {\n                    if (err) throw err;\n                    assert.equal(row.integer, integer);\n                    done();\n                });\n            });\n        });\n    });\n});\n"], "fixing_code": ["#include <string.h>\n#include <napi.h>\n#include <uv.h>\n\n#include \"macros.h\"\n#include \"database.h\"\n#include \"statement.h\"\n\nusing namespace node_sqlite3;\n\nNapi::Object Statement::Init(Napi::Env env, Napi::Object exports) {\n    Napi::HandleScope scope(env);\n\n    Napi::Function t = DefineClass(env, \"Statement\", {\n      InstanceMethod(\"bind\", &Statement::Bind),\n      InstanceMethod(\"get\", &Statement::Get),\n      InstanceMethod(\"run\", &Statement::Run),\n      InstanceMethod(\"all\", &Statement::All),\n      InstanceMethod(\"each\", &Statement::Each),\n      InstanceMethod(\"reset\", &Statement::Reset),\n      InstanceMethod(\"finalize\", &Statement::Finalize_),\n    });\n\n    exports.Set(\"Statement\", t);\n    return exports;\n}\n\n// A Napi InstanceOf for Javascript Objects \"Date\" and \"RegExp\"\nbool OtherInstanceOf(Napi::Object source, const char* object_type) {\n    if (strncmp(object_type, \"Date\", 4) == 0) {\n        return source.InstanceOf(source.Env().Global().Get(\"Date\").As<Function>());\n    } else if (strncmp(object_type, \"RegExp\", 6) == 0) {\n        return source.InstanceOf(source.Env().Global().Get(\"RegExp\").As<Function>());\n    }\n\n    return false;\n}\n\nvoid Statement::Process() {\n    if (finalized && !queue.empty()) {\n        return CleanQueue();\n    }\n\n    while (prepared && !locked && !queue.empty()) {\n        std::unique_ptr<Call> call(queue.front());\n        queue.pop();\n\n        call->callback(call->baton);\n    }\n}\n\nvoid Statement::Schedule(Work_Callback callback, Baton* baton) {\n    if (finalized) {\n        queue.push(new Call(callback, baton));\n        CleanQueue();\n    }\n    else if (!prepared || locked) {\n        queue.push(new Call(callback, baton));\n    }\n    else {\n        callback(baton);\n    }\n}\n\ntemplate <class T> void Statement::Error(T* baton) {\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    // Fail hard on logic errors.\n    assert(stmt->status != 0);\n    EXCEPTION(Napi::String::New(env, stmt->message.c_str()), stmt->status, exception);\n\n    Napi::Function cb = baton->callback.Value();\n\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { exception };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n    else {\n        Napi::Value argv[] = { Napi::String::New(env, \"error\"), exception };\n        EMIT_EVENT(stmt->Value(), 2, argv);\n    }\n}\n\n// { Database db, String sql, Array params, Function callback }\nStatement::Statement(const Napi::CallbackInfo& info) : Napi::ObjectWrap<Statement>(info) {\n    Napi::Env env = info.Env();\n    int length = info.Length();\n\n    if (length <= 0 || !Database::HasInstance(info[0])) {\n        Napi::TypeError::New(env, \"Database object expected\").ThrowAsJavaScriptException();\n        return;\n    }\n    else if (length <= 1 || !info[1].IsString()) {\n        Napi::TypeError::New(env, \"SQL query expected\").ThrowAsJavaScriptException();\n        return;\n    }\n    else if (length > 2 && !info[2].IsUndefined() && !info[2].IsFunction()) {\n        Napi::TypeError::New(env, \"Callback expected\").ThrowAsJavaScriptException();\n        return;\n    }\n\n    Database* db = Napi::ObjectWrap<Database>::Unwrap(info[0].As<Napi::Object>());\n    Napi::String sql = info[1].As<Napi::String>();\n\n    info.This().As<Napi::Object>().DefineProperty(Napi::PropertyDescriptor::Value(\"sql\", sql, napi_default));\n\n    init(db);\n    Statement* stmt = this;\n\n    PrepareBaton* baton = new PrepareBaton(db, info[2].As<Napi::Function>(), stmt);\n    baton->sql = std::string(sql.As<Napi::String>().Utf8Value().c_str());\n    db->Schedule(Work_BeginPrepare, baton);\n}\n\nvoid Statement::Work_BeginPrepare(Database::Baton* baton) {\n    assert(baton->db->open);\n    baton->db->pending++;\n    Napi::Env env = baton->db->Env();\n    int status = napi_create_async_work(\n        env, NULL, Napi::String::New(env, \"sqlite3.Statement.Prepare\"),\n        Work_Prepare, Work_AfterPrepare, baton, &baton->request\n    );\n    assert(status == 0);\n    napi_queue_async_work(env, baton->request);\n}\n\nvoid Statement::Work_Prepare(napi_env e, void* data) {\n    STATEMENT_INIT(PrepareBaton);\n\n    // In case preparing fails, we use a mutex to make sure we get the associated\n    // error message.\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n\n    stmt->status = sqlite3_prepare_v2(\n        baton->db->_handle,\n        baton->sql.c_str(),\n        baton->sql.size(),\n        &stmt->_handle,\n        NULL\n    );\n\n    if (stmt->status != SQLITE_OK) {\n        stmt->message = std::string(sqlite3_errmsg(baton->db->_handle));\n        stmt->_handle = NULL;\n    }\n\n    sqlite3_mutex_leave(mtx);\n}\n\nvoid Statement::Work_AfterPrepare(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<PrepareBaton> baton(static_cast<PrepareBaton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_OK) {\n        Error(baton.get());\n        stmt->Finalize_();\n    }\n    else {\n        stmt->prepared = true;\n        if (!baton->callback.IsEmpty() && baton->callback.Value().IsFunction()) {\n            Napi::Function cb = baton->callback.Value();\n            Napi::Value argv[] = { env.Null() };\n            TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n        }\n    }\n\n    STATEMENT_END();\n}\n\ntemplate <class T> Values::Field*\n                   Statement::BindParameter(const Napi::Value source, T pos) {\n    if (source.IsString()) {\n        std::string val = source.As<Napi::String>().Utf8Value();\n        return new Values::Text(pos, val.length(), val.c_str());\n    }\n    else if (OtherInstanceOf(source.As<Object>(), \"RegExp\")) {\n        std::string val = source.ToString().Utf8Value();\n        return new Values::Text(pos, val.length(), val.c_str());\n    }\n    else if (source.IsNumber()) {\n        if (OtherIsInt(source.As<Napi::Number>())) {\n            return new Values::Integer(pos, source.As<Napi::Number>().Int32Value());\n        } else {\n            return new Values::Float(pos, source.As<Napi::Number>().DoubleValue());\n        }\n    }\n    else if (source.IsBoolean()) {\n        return new Values::Integer(pos, source.As<Napi::Boolean>().Value() ? 1 : 0);\n    }\n    else if (source.IsNull()) {\n        return new Values::Null(pos);\n    }\n    else if (source.IsBuffer()) {\n        Napi::Buffer<char> buffer = source.As<Napi::Buffer<char>>();\n        return new Values::Blob(pos, buffer.Length(), buffer.Data());\n    }\n    else if (OtherInstanceOf(source.As<Object>(), \"Date\")) {\n        return new Values::Float(pos, source.ToNumber().DoubleValue());\n    }\n    else if (source.IsObject()) {\n        Napi::String napiVal = source.ToString();\n        // Check whether toString returned a value that is not undefined.\n        if(napiVal.Type() == 0) {\n            return NULL;\n        }\n\n        std::string val = napiVal.Utf8Value();\n        return new Values::Text(pos, val.length(), val.c_str());\n    }\n    else {\n        return NULL;\n    }\n}\n\ntemplate <class T> T* Statement::Bind(const Napi::CallbackInfo& info, int start, int last) {\n    Napi::Env env = info.Env();\n    Napi::HandleScope scope(env);\n\n    if (last < 0) last = info.Length();\n    Napi::Function callback;\n    if (last > start && info[last - 1].IsFunction()) {\n        callback = info[last - 1].As<Napi::Function>();\n        last--;\n    }\n\n    T* baton = new T(this, callback);\n\n    if (start < last) {\n        if (info[start].IsArray()) {\n            Napi::Array array = info[start].As<Napi::Array>();\n            int length = array.Length();\n            // Note: bind parameters start with 1.\n            for (int i = 0, pos = 1; i < length; i++, pos++) {\n                baton->parameters.push_back(BindParameter((array).Get(i), pos));\n            }\n        }\n        else if (!info[start].IsObject() || OtherInstanceOf(info[start].As<Object>(), \"RegExp\") || OtherInstanceOf(info[start].As<Object>(), \"Date\") || info[start].IsBuffer()) {\n            // Parameters directly in array.\n            // Note: bind parameters start with 1.\n            for (int i = start, pos = 1; i < last; i++, pos++) {\n                baton->parameters.push_back(BindParameter(info[i], pos));\n            }\n        }\n        else if (info[start].IsObject()) {\n            Napi::Object object = info[start].As<Napi::Object>();\n            Napi::Array array = object.GetPropertyNames();\n            int length = array.Length();\n            for (int i = 0; i < length; i++) {\n                Napi::Value name = (array).Get(i);\n                Napi::Number num = name.ToNumber();\n\n                if (num.Int32Value() == num.DoubleValue()) {\n                    baton->parameters.push_back(\n                        BindParameter((object).Get(name), num.Int32Value()));\n                }\n                else {\n                    baton->parameters.push_back(BindParameter((object).Get(name),\n                        name.As<Napi::String>().Utf8Value().c_str()));\n                }\n            }\n        }\n        else {\n            return NULL;\n        }\n    }\n\n    return baton;\n}\n\nbool Statement::Bind(const Parameters & parameters) {\n    if (parameters.size() == 0) {\n        return true;\n    }\n\n    sqlite3_reset(_handle);\n    sqlite3_clear_bindings(_handle);\n\n    Parameters::const_iterator it = parameters.begin();\n    Parameters::const_iterator end = parameters.end();\n\n    for (; it < end; ++it) {\n        Values::Field* field = *it;\n\n        if (field != NULL) {\n            unsigned int pos;\n            if (field->index > 0) {\n                pos = field->index;\n            }\n            else {\n                pos = sqlite3_bind_parameter_index(_handle, field->name.c_str());\n            }\n\n            switch (field->type) {\n                case SQLITE_INTEGER: {\n                    status = sqlite3_bind_int(_handle, pos,\n                        ((Values::Integer*)field)->value);\n                } break;\n                case SQLITE_FLOAT: {\n                    status = sqlite3_bind_double(_handle, pos,\n                        ((Values::Float*)field)->value);\n                } break;\n                case SQLITE_TEXT: {\n                    status = sqlite3_bind_text(_handle, pos,\n                        ((Values::Text*)field)->value.c_str(),\n                        ((Values::Text*)field)->value.size(), SQLITE_TRANSIENT);\n                } break;\n                case SQLITE_BLOB: {\n                    status = sqlite3_bind_blob(_handle, pos,\n                        ((Values::Blob*)field)->value,\n                        ((Values::Blob*)field)->length, SQLITE_TRANSIENT);\n                } break;\n                case SQLITE_NULL: {\n                    status = sqlite3_bind_null(_handle, pos);\n                } break;\n            }\n\n            if (status != SQLITE_OK) {\n                message = std::string(sqlite3_errmsg(db->_handle));\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nNapi::Value Statement::Bind(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    Baton* baton = stmt->Bind<Baton>(info);\n    if (baton == NULL) {\n        Napi::TypeError::New(env, \"Data type is not supported\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    else {\n        stmt->Schedule(Work_BeginBind, baton);\n        return info.This();\n    }\n}\n\nvoid Statement::Work_BeginBind(Baton* baton) {\n    STATEMENT_BEGIN(Bind);\n}\n\nvoid Statement::Work_Bind(napi_env e, void* data) {\n    STATEMENT_INIT(Baton);\n\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n    stmt->Bind(baton->parameters);\n    sqlite3_mutex_leave(mtx);\n}\n\nvoid Statement::Work_AfterBind(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_OK) {\n        Error(baton.get());\n    }\n    else {\n        // Fire callbacks.\n        Napi::Function cb = baton->callback.Value();\n        if (!cb.IsUndefined() && cb.IsFunction()) {\n            Napi::Value argv[] = { env.Null() };\n            TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n        }\n    }\n\n    STATEMENT_END();\n}\n\n\n\nNapi::Value Statement::Get(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    Baton* baton = stmt->Bind<RowBaton>(info);\n    if (baton == NULL) {\n        Napi::Error::New(env, \"Data type is not supported\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    else {\n        stmt->Schedule(Work_BeginGet, baton);\n        return info.This();\n    }\n}\n\nvoid Statement::Work_BeginGet(Baton* baton) {\n    STATEMENT_BEGIN(Get);\n}\n\nvoid Statement::Work_Get(napi_env e, void* data) {\n    STATEMENT_INIT(RowBaton);\n\n    if (stmt->status != SQLITE_DONE || baton->parameters.size()) {\n        STATEMENT_MUTEX(mtx);\n        sqlite3_mutex_enter(mtx);\n\n        if (stmt->Bind(baton->parameters)) {\n            stmt->status = sqlite3_step(stmt->_handle);\n\n            if (!(stmt->status == SQLITE_ROW || stmt->status == SQLITE_DONE)) {\n                stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));\n            }\n        }\n\n        sqlite3_mutex_leave(mtx);\n\n        if (stmt->status == SQLITE_ROW) {\n            // Acquire one result row before returning.\n            GetRow(&baton->row, stmt->_handle);\n        }\n    }\n}\n\nvoid Statement::Work_AfterGet(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<RowBaton> baton(static_cast<RowBaton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_ROW && stmt->status != SQLITE_DONE) {\n        Error(baton.get());\n    }\n    else {\n        // Fire callbacks.\n        Napi::Function cb = baton->callback.Value();\n        if (!cb.IsUndefined() && cb.IsFunction()) {\n            if (stmt->status == SQLITE_ROW) {\n                // Create the result array from the data we acquired.\n                Napi::Value argv[] = { env.Null(), RowToJS(env, &baton->row) };\n                TRY_CATCH_CALL(stmt->Value(), cb, 2, argv);\n            }\n            else {\n                Napi::Value argv[] = { env.Null() };\n                TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n            }\n        }\n    }\n\n    STATEMENT_END();\n}\n\nNapi::Value Statement::Run(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    Baton* baton = stmt->Bind<RunBaton>(info);\n    if (baton == NULL) {\n        Napi::Error::New(env, \"Data type is not supported\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    else {\n        stmt->Schedule(Work_BeginRun, baton);\n        return info.This();\n    }\n}\n\nvoid Statement::Work_BeginRun(Baton* baton) {\n    STATEMENT_BEGIN(Run);\n}\n\nvoid Statement::Work_Run(napi_env e, void* data) {\n    STATEMENT_INIT(RunBaton);\n\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n\n    // Make sure that we also reset when there are no parameters.\n    if (!baton->parameters.size()) {\n        sqlite3_reset(stmt->_handle);\n    }\n\n    if (stmt->Bind(baton->parameters)) {\n        stmt->status = sqlite3_step(stmt->_handle);\n\n        if (!(stmt->status == SQLITE_ROW || stmt->status == SQLITE_DONE)) {\n            stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));\n        }\n        else {\n            baton->inserted_id = sqlite3_last_insert_rowid(stmt->db->_handle);\n            baton->changes = sqlite3_changes(stmt->db->_handle);\n        }\n    }\n\n    sqlite3_mutex_leave(mtx);\n}\n\nvoid Statement::Work_AfterRun(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<RunBaton> baton(static_cast<RunBaton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_ROW && stmt->status != SQLITE_DONE) {\n        Error(baton.get());\n    }\n    else {\n        // Fire callbacks.\n        Napi::Function cb = baton->callback.Value();\n        if (!cb.IsUndefined() && cb.IsFunction()) {\n            (stmt->Value()).Set(Napi::String::New(env, \"lastID\"), Napi::Number::New(env, baton->inserted_id));\n            (stmt->Value()).Set( Napi::String::New(env, \"changes\"), Napi::Number::New(env, baton->changes));\n\n            Napi::Value argv[] = { env.Null() };\n            TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n        }\n    }\n\n    STATEMENT_END();\n}\n\nNapi::Value Statement::All(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    Baton* baton = stmt->Bind<RowsBaton>(info);\n    if (baton == NULL) {\n        Napi::Error::New(env, \"Data type is not supported\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    else {\n        stmt->Schedule(Work_BeginAll, baton);\n        return info.This();\n    }\n}\n\nvoid Statement::Work_BeginAll(Baton* baton) {\n    STATEMENT_BEGIN(All);\n}\n\nvoid Statement::Work_All(napi_env e, void* data) {\n    STATEMENT_INIT(RowsBaton);\n\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n\n    // Make sure that we also reset when there are no parameters.\n    if (!baton->parameters.size()) {\n        sqlite3_reset(stmt->_handle);\n    }\n\n    if (stmt->Bind(baton->parameters)) {\n        while ((stmt->status = sqlite3_step(stmt->_handle)) == SQLITE_ROW) {\n            Row* row = new Row();\n            GetRow(row, stmt->_handle);\n            baton->rows.push_back(row);\n        }\n\n        if (stmt->status != SQLITE_DONE) {\n            stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));\n        }\n    }\n\n    sqlite3_mutex_leave(mtx);\n}\n\nvoid Statement::Work_AfterAll(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<RowsBaton> baton(static_cast<RowsBaton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_DONE) {\n        Error(baton.get());\n    }\n    else {\n        // Fire callbacks.\n        Napi::Function cb = baton->callback.Value();\n        if (!cb.IsUndefined() && cb.IsFunction()) {\n            if (baton->rows.size()) {\n                // Create the result array from the data we acquired.\n                Napi::Array result(Napi::Array::New(env, baton->rows.size()));\n                Rows::const_iterator it = baton->rows.begin();\n                Rows::const_iterator end = baton->rows.end();\n                for (int i = 0; it < end; ++it, i++) {\n                    std::unique_ptr<Row> row(*it);\n                    (result).Set(i, RowToJS(env,row.get()));\n                }\n\n                Napi::Value argv[] = { env.Null(), result };\n                TRY_CATCH_CALL(stmt->Value(), cb, 2, argv);\n            }\n            else {\n                // There were no result rows.\n                Napi::Value argv[] = {\n                    env.Null(),\n                    Napi::Array::New(env, 0)\n                };\n                TRY_CATCH_CALL(stmt->Value(), cb, 2, argv);\n            }\n        }\n    }\n\n    STATEMENT_END();\n}\n\nNapi::Value Statement::Each(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    int last = info.Length();\n\n    Napi::Function completed;\n    if (last >= 2 && info[last - 1].IsFunction() && info[last - 2].IsFunction()) {\n        completed = info[--last].As<Napi::Function>();\n    }\n\n    EachBaton* baton = stmt->Bind<EachBaton>(info, 0, last);\n    if (baton == NULL) {\n        Napi::Error::New(env, \"Data type is not supported\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    else {\n        baton->completed.Reset(completed, 1);\n        stmt->Schedule(Work_BeginEach, baton);\n        return info.This();\n    }\n}\n\nvoid Statement::Work_BeginEach(Baton* baton) {\n    // Only create the Async object when we're actually going into\n    // the event loop. This prevents dangling events.\n    EachBaton* each_baton = static_cast<EachBaton*>(baton);\n    each_baton->async = new Async(each_baton->stmt, reinterpret_cast<uv_async_cb>(AsyncEach));\n    each_baton->async->item_cb.Reset(each_baton->callback.Value(), 1);\n    each_baton->async->completed_cb.Reset(each_baton->completed.Value(), 1);\n\n    STATEMENT_BEGIN(Each);\n}\n\nvoid Statement::Work_Each(napi_env e, void* data) {\n    STATEMENT_INIT(EachBaton);\n\n    Async* async = baton->async;\n\n    STATEMENT_MUTEX(mtx);\n\n    int retrieved = 0;\n\n    // Make sure that we also reset when there are no parameters.\n    if (!baton->parameters.size()) {\n        sqlite3_reset(stmt->_handle);\n    }\n\n    if (stmt->Bind(baton->parameters)) {\n        while (true) {\n            sqlite3_mutex_enter(mtx);\n            stmt->status = sqlite3_step(stmt->_handle);\n            if (stmt->status == SQLITE_ROW) {\n                sqlite3_mutex_leave(mtx);\n                Row* row = new Row();\n                GetRow(row, stmt->_handle);\n                NODE_SQLITE3_MUTEX_LOCK(&async->mutex)\n                async->data.push_back(row);\n                retrieved++;\n                NODE_SQLITE3_MUTEX_UNLOCK(&async->mutex)\n\n                uv_async_send(&async->watcher);\n            }\n            else {\n                if (stmt->status != SQLITE_DONE) {\n                    stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));\n                }\n                sqlite3_mutex_leave(mtx);\n                break;\n            }\n        }\n    }\n\n    async->completed = true;\n    uv_async_send(&async->watcher);\n}\n\nvoid Statement::CloseCallback(uv_handle_t* handle) {\n    assert(handle != NULL);\n    assert(handle->data != NULL);\n    Async* async = static_cast<Async*>(handle->data);\n    delete async;\n}\n\nvoid Statement::AsyncEach(uv_async_t* handle) {\n    Async* async = static_cast<Async*>(handle->data);\n\n    Napi::Env env = async->stmt->Env();\n    Napi::HandleScope scope(env);\n\n    while (true) {\n        // Get the contents out of the data cache for us to process in the JS callback.\n        Rows rows;\n        NODE_SQLITE3_MUTEX_LOCK(&async->mutex)\n        rows.swap(async->data);\n        NODE_SQLITE3_MUTEX_UNLOCK(&async->mutex)\n\n        if (rows.empty()) {\n            break;\n        }\n\n        Napi::Function cb = async->item_cb.Value();\n        if (!cb.IsUndefined() && cb.IsFunction()) {\n            Napi::Value argv[2];\n            argv[0] = env.Null();\n\n            Rows::const_iterator it = rows.begin();\n            Rows::const_iterator end = rows.end();\n            for (int i = 0; it < end; ++it, i++) {\n                std::unique_ptr<Row> row(*it);\n                argv[1] = RowToJS(env,row.get());\n                async->retrieved++;\n                TRY_CATCH_CALL(async->stmt->Value(), cb, 2, argv);\n            }\n        }\n    }\n\n    Napi::Function cb = async->completed_cb.Value();\n    if (async->completed) {\n        if (!cb.IsEmpty() &&\n                cb.IsFunction()) {\n            Napi::Value argv[] = {\n                env.Null(),\n                Napi::Number::New(env, async->retrieved)\n            };\n            TRY_CATCH_CALL(async->stmt->Value(), cb, 2, argv);\n        }\n        uv_close(reinterpret_cast<uv_handle_t*>(handle), CloseCallback);\n    }\n}\n\nvoid Statement::Work_AfterEach(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<EachBaton> baton(static_cast<EachBaton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    if (stmt->status != SQLITE_DONE) {\n        Error(baton.get());\n    }\n\n    STATEMENT_END();\n}\n\nNapi::Value Statement::Reset(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n\n    OPTIONAL_ARGUMENT_FUNCTION(0, callback);\n\n    Baton* baton = new Baton(stmt, callback);\n    stmt->Schedule(Work_BeginReset, baton);\n\n    return info.This();\n}\n\nvoid Statement::Work_BeginReset(Baton* baton) {\n    STATEMENT_BEGIN(Reset);\n}\n\nvoid Statement::Work_Reset(napi_env e, void* data) {\n    STATEMENT_INIT(Baton);\n\n    sqlite3_reset(stmt->_handle);\n    stmt->status = SQLITE_OK;\n}\n\nvoid Statement::Work_AfterReset(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n\n    // Fire callbacks.\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { env.Null() };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n\n    STATEMENT_END();\n}\n\nNapi::Value Statement::RowToJS(Napi::Env env, Row* row) {\n    Napi::EscapableHandleScope scope(env);\n\n    Napi::Object result = Napi::Object::New(env);\n\n    Row::const_iterator it = row->begin();\n    Row::const_iterator end = row->end();\n    for (int i = 0; it < end; ++it, i++) {\n        Values::Field* field = *it;\n\n        Napi::Value value;\n\n        switch (field->type) {\n            case SQLITE_INTEGER: {\n                value = Napi::Number::New(env, ((Values::Integer*)field)->value);\n            } break;\n            case SQLITE_FLOAT: {\n                value = Napi::Number::New(env, ((Values::Float*)field)->value);\n            } break;\n            case SQLITE_TEXT: {\n                value = Napi::String::New(env, ((Values::Text*)field)->value.c_str(), ((Values::Text*)field)->value.size());\n            } break;\n            case SQLITE_BLOB: {\n                value = Napi::Buffer<char>::Copy(env, ((Values::Blob*)field)->value, ((Values::Blob*)field)->length);\n            } break;\n            case SQLITE_NULL: {\n                value = env.Null();\n            } break;\n        }\n\n        (result).Set(Napi::String::New(env, field->name.c_str()), value);\n\n        DELETE_FIELD(field);\n    }\n\n    return scope.Escape(result);\n}\n\nvoid Statement::GetRow(Row* row, sqlite3_stmt* stmt) {\n    int rows = sqlite3_column_count(stmt);\n\n    for (int i = 0; i < rows; i++) {\n        int type = sqlite3_column_type(stmt, i);\n        const char* name = sqlite3_column_name(stmt, i);\n        switch (type) {\n            case SQLITE_INTEGER: {\n                row->push_back(new Values::Integer(name, sqlite3_column_int64(stmt, i)));\n            }   break;\n            case SQLITE_FLOAT: {\n                row->push_back(new Values::Float(name, sqlite3_column_double(stmt, i)));\n            }   break;\n            case SQLITE_TEXT: {\n                const char* text = (const char*)sqlite3_column_text(stmt, i);\n                int length = sqlite3_column_bytes(stmt, i);\n                row->push_back(new Values::Text(name, length, text));\n            } break;\n            case SQLITE_BLOB: {\n                const void* blob = sqlite3_column_blob(stmt, i);\n                int length = sqlite3_column_bytes(stmt, i);\n                row->push_back(new Values::Blob(name, length, blob));\n            }   break;\n            case SQLITE_NULL: {\n                row->push_back(new Values::Null(name));\n            }   break;\n            default:\n                assert(false);\n        }\n    }\n}\n\nNapi::Value Statement::Finalize_(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    Statement* stmt = this;\n    OPTIONAL_ARGUMENT_FUNCTION(0, callback);\n\n    Baton* baton = new Baton(stmt, callback);\n    stmt->Schedule(Finalize_, baton);\n\n    return stmt->db->Value();\n}\n\nvoid Statement::Finalize_(Baton* b) {\n    std::unique_ptr<Baton> baton(b);\n    Napi::Env env = baton->stmt->Env();\n    Napi::HandleScope scope(env);\n\n    baton->stmt->Finalize_();\n\n    // Fire callback in case there was one.\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        TRY_CATCH_CALL(baton->stmt->Value(), cb, 0, NULL);\n    }\n}\n\nvoid Statement::Finalize_() {\n    assert(!finalized);\n    finalized = true;\n    CleanQueue();\n    // Finalize returns the status code of the last operation. We already fired\n    // error events in case those failed.\n    sqlite3_finalize(_handle);\n    _handle = NULL;\n    db->Unref();\n}\n\nvoid Statement::CleanQueue() {\n    Napi::Env env = this->Env();\n    Napi::HandleScope scope(env);\n\n    if (prepared && !queue.empty()) {\n        // This statement has already been prepared and is now finalized.\n        // Fire error for all remaining items in the queue.\n        EXCEPTION(Napi::String::New(env, \"Statement is already finalized\"), SQLITE_MISUSE, exception);\n        Napi::Value argv[] = { exception };\n        bool called = false;\n\n        // Clear out the queue so that this object can get GC'ed.\n        while (!queue.empty()) {\n            std::unique_ptr<Call> call(queue.front());\n            queue.pop();\n\n            std::unique_ptr<Baton> baton(call->baton);\n            Napi::Function cb = baton->callback.Value();\n\n            if (prepared && !cb.IsEmpty() &&\n                cb.IsFunction()) {\n                TRY_CATCH_CALL(Value(), cb, 1, argv);\n                called = true;\n            }\n        }\n\n        // When we couldn't call a callback function, emit an error on the\n        // Statement object.\n        if (!called) {\n            Napi::Value info[] = { Napi::String::New(env, \"error\"), exception };\n            EMIT_EVENT(Value(), 2, info);\n        }\n    }\n    else while (!queue.empty()) {\n        // Just delete all items in the queue; we already fired an event when\n        // preparing the statement failed.\n        std::unique_ptr<Call> call(queue.front());\n        queue.pop();\n        // We don't call the actual callback, so we have to make sure that\n        // the baton gets destroyed.\n        delete call->baton;\n    }\n}\n", "var sqlite3 = require('..');\nvar assert = require('assert');\n\ndescribe('data types', function() {\n    var db;\n    before(function(done) {\n        db = new sqlite3.Database(':memory:');\n        db.run(\"CREATE TABLE txt_table (txt TEXT)\");\n        db.run(\"CREATE TABLE int_table (int INTEGER)\");\n        db.run(\"CREATE TABLE flt_table (flt FLOAT)\");\n        db.wait(done);\n    });\n\n    beforeEach(function(done) {\n        db.exec('DELETE FROM txt_table; DELETE FROM int_table; DELETE FROM flt_table;', done);\n    });\n\n    it('should serialize Date()', function(done) {\n        var date = new Date();\n        db.run(\"INSERT INTO int_table VALUES(?)\", date, function (err) {\n            if (err) throw err;\n            db.get(\"SELECT int FROM int_table\", function(err, row) {\n                if (err) throw err;\n                assert.equal(row.int, +date);\n                done();\n            });\n        });\n    });\n\n    it('should serialize RegExp()', function(done) {\n        var regexp = /^f\\noo/;\n        db.run(\"INSERT INTO txt_table VALUES(?)\", regexp, function (err) {\n            if (err) throw err;\n            db.get(\"SELECT txt FROM txt_table\", function(err, row) {\n                if (err) throw err;\n                assert.equal(row.txt, String(regexp));\n                done();\n            });\n        });\n    });\n\n    [\n        4294967296.249,\n        Math.PI,\n        3924729304762836.5,\n        new Date().valueOf(),\n        912667.394828365,\n        2.3948728634826374e+83,\n        9.293476892934982e+300,\n        Infinity,\n        -9.293476892934982e+300,\n        -2.3948728634826374e+83,\n        -Infinity\n    ].forEach(function(flt) {\n        it('should serialize float ' + flt, function(done) {\n            db.run(\"INSERT INTO flt_table VALUES(?)\", flt, function (err) {\n                if (err) throw err;\n                db.get(\"SELECT flt FROM flt_table\", function(err, row) {\n                    if (err) throw err;\n                    assert.equal(row.flt, flt);\n                    done();\n                });\n            });\n        });\n    });\n\n    [\n        4294967299,\n        3924729304762836,\n        new Date().valueOf(),\n        2.3948728634826374e+83,\n        9.293476892934982e+300,\n        Infinity,\n        -9.293476892934982e+300,\n        -2.3948728634826374e+83,\n        -Infinity\n    ].forEach(function(integer) {\n        it('should serialize integer ' + integer, function(done) {\n            db.run(\"INSERT INTO int_table VALUES(?)\", integer, function (err) {\n                if (err) throw err;\n                db.get(\"SELECT int AS integer FROM int_table\", function(err, row) {\n                    if (err) throw err;\n                    assert.equal(row.integer, integer);\n                    done();\n                });\n            });\n        });\n    });\n\n    it('should ignore faulty toString', function(done) {\n        const faulty = { toString: 23 };\n        db.run(\"INSERT INTO txt_table VALUES(?)\", faulty, function (err) {\n            assert.notEqual(err, undefined);\n            done();\n        });\n    });\n\n});\n"], "filenames": ["src/statement.cc", "test/other_objects.test.js"], "buggy_code_start_loc": [208, 88], "buggy_code_end_loc": [209, 88], "fixing_code_start_loc": [208, 89], "fixing_code_end_loc": [215, 98], "type": "NVD-CWE-noinfo", "message": "The package sqlite3 before 5.0.3 are vulnerable to Denial of Service (DoS) which will invoke the toString function of the passed parameter. If passed an invalid Function object it will throw and crash the V8 engine.", "other": {"cve": {"id": "CVE-2022-21227", "sourceIdentifier": "report@snyk.io", "published": "2022-05-01T16:15:08.197", "lastModified": "2022-05-11T14:10:40.683", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package sqlite3 before 5.0.3 are vulnerable to Denial of Service (DoS) which will invoke the toString function of the passed parameter. If passed an invalid Function object it will throw and crash the V8 engine."}, {"lang": "es", "value": "El paquete sqlite3 versiones anteriores a 5.0.3, es vulnerable a una Denegaci\u00f3n de Servicio (DoS) que invocar\u00e1 la funci\u00f3n toString del par\u00e1metro pasado. Si es pasado un objeto Function no v\u00e1lido, ser\u00e1 lanzado y bloquear\u00e1 el motor V8"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ghost:sqlite3:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.0.3", "matchCriteriaId": "2C757080-EF7B-4F2A-BB26-C1A3CC4110CD"}]}]}], "references": [{"url": "https://github.com/TryGhost/node-sqlite3/commit/593c9d498be2510d286349134537e3bf89401c4a", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-2805470", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-SQLITE3-2388645", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/TryGhost/node-sqlite3/commit/593c9d498be2510d286349134537e3bf89401c4a"}}