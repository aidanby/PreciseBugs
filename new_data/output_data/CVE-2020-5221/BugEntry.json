{"buggy_code": ["/* Common methods shared between FTP and TFTP engines\n *\n * Copyright (c) 2014-2019  Joachim Nilsson <troglobit@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"uftpd.h\"\n\nint chrooted = 0;\n\n/* Protect against common directory traversal attacks, for details see\n * https://en.wikipedia.org/wiki/Directory_traversal_attack\n *\n * Example:            /srv/ftp/ ../../etc/passwd => /etc/passwd\n *                    .~~~~~~~~ .~~~~~~~~~\n *                   /         /\n * Server dir ------'         /\n * User input ---------------'\n *\n * Forced dir ------> /srv/ftp/etc\n */\nchar *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}\n\nchar *compose_abspath(ctrl_t *ctrl, char *path)\n{\n\tchar *ptr;\n\tchar cwd[sizeof(ctrl->cwd)];\n\n\tif (path && path[0] == '/') {\n\t\tstrlcpy(cwd, ctrl->cwd, sizeof(cwd));\n\t\tmemset(ctrl->cwd, 0, sizeof(ctrl->cwd));\n\t}\n\n\tptr = compose_path(ctrl, path);\n\n\tif (path && path[0] == '/')\n\t\tstrlcpy(ctrl->cwd, cwd, sizeof(ctrl->cwd));\n\n\treturn ptr;\n}\n\nint set_nonblock(int fd)\n{\n\tint flags;\n\n\tflags = fcntl(fd, F_GETFL, 0);\n\tif (!flags)\n\t\t(void)fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n\n\treturn fd;\n}\n\nint open_socket(int port, int type, char *desc)\n{\n\tint sd, err, val = 1;\n\tsocklen_t len = sizeof(struct sockaddr);\n\tstruct sockaddr_in server;\n\n\tsd = socket(AF_INET, type | SOCK_NONBLOCK, 0);\n\tif (sd < 0) {\n\t\tWARN(errno, \"Failed creating %s server socket\", desc);\n\t\treturn -1;\n\t}\n\n\terr = setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));\n\tif (err != 0)\n\t\tWARN(errno, \"Failed setting SO_REUSEADDR on %s socket\", type == SOCK_DGRAM ? \"TFTP\" : \"FTP\");\n\n\tmemset(&server, 0, sizeof(server));\n\tserver.sin_family      = AF_INET;\n\tserver.sin_addr.s_addr = INADDR_ANY;\n\tserver.sin_port        = htons(port);\n\tif (bind(sd, (struct sockaddr *)&server, len) < 0) {\n\t\tif (EACCES != errno) {\n\t\t\tWARN(errno, \"Failed binding to port %d, maybe another %s server is already running\", port, desc);\n\t\t}\n\t\tclose(sd);\n\n\t\treturn -1;\n\t}\n\n\tif (port && type != SOCK_DGRAM) {\n\t\tif (-1 == listen(sd, 20))\n\t\t\tWARN(errno, \"Failed starting %s server\", desc);\n\t}\n\n\tDBG(\"Opened socket for port %d\", port);\n\n\treturn sd;\n}\n\nvoid convert_address(struct sockaddr_storage *ss, char *buf, size_t len)\n{\n\tswitch (ss->ss_family) {\n\tcase AF_INET:\n\t\tinet_ntop(ss->ss_family,\n\t\t\t  &((struct sockaddr_in *)ss)->sin_addr, buf, len);\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tinet_ntop(ss->ss_family,\n\t\t\t  &((struct sockaddr_in6 *)ss)->sin6_addr, buf, len);\n\t\tbreak;\n\t}\n}\n\n/* Inactivity timer, bye bye */\nstatic void inactivity_cb(uev_t *w, void *arg, int events)\n{\n\tuev_ctx_t *ctx = (uev_ctx_t *)arg;\n\n\tINFO(\"Inactivity timer, exiting ...\");\n\tuev_exit(ctx);\n}\n\nctrl_t *new_session(uev_ctx_t *ctx, int sd, int *rc)\n{\n\tctrl_t *ctrl = NULL;\n\tstatic int privs_dropped = 0;\n\n\tif (!inetd) {\n\t\tpid_t pid = fork();\n\n\t\tif (pid) {\n\t\t\tDBG(\"Created new client session as PID %d\", pid);\n\t\t\t*rc = pid;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * Set process group to parent, so uftpd can call\n\t\t * killpg() on all of us when it exits.\n\t\t */\n\t\tsetpgid(0, getppid());\n\t\t/* Create new uEv context for the child. */\n\t\tctx = calloc(1, sizeof(uev_ctx_t));\n\t\tif (!ctx) {\n\t\t\tERR(errno, \"Failed allocating session event context\");\n\t\t\texit(1);\n\t\t}\n\n\t\tuev_init(ctx);\n\t}\n\n\tctrl = calloc(1, sizeof(ctrl_t));\n\tif (!ctrl) {\n\t\tERR(errno, \"Failed allocating session context\");\n\t\tgoto fail;\n\t}\n\n\tctrl->sd = set_nonblock(sd);\n\tctrl->ctx = ctx;\n\tstrlcpy(ctrl->cwd, \"/\", sizeof(ctrl->cwd));\n\n\t/* Chroot to FTP root */\n\tif (!chrooted && geteuid() == 0) {\n\t\tif (chroot(home) || chdir(\"/\")) {\n\t\t\tERR(errno, \"Failed chrooting to FTP root, %s, aborting\", home);\n\t\t\tgoto fail;\n\t\t}\n\t\tchrooted = 1;\n\t} else if (!chrooted) {\n\t\tif (chdir(home)) {\n\t\t\tWARN(errno, \"Failed changing to FTP root, %s, aborting\", home);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* If ftp user exists and we're running as root we can drop privs */\n\tif (!privs_dropped && pw && geteuid() == 0) {\n\t\tint fail1, fail2;\n\n\t\tinitgroups(pw->pw_name, pw->pw_gid);\n\t\tif ((fail1 = setegid(pw->pw_gid)))\n\t\t\tWARN(errno, \"Failed dropping group privileges to gid %d\", pw->pw_gid);\n\t\tif ((fail2 = seteuid(pw->pw_uid)))\n\t\t\tWARN(errno, \"Failed dropping user privileges to uid %d\", pw->pw_uid);\n\n\t\tsetenv(\"HOME\", pw->pw_dir, 1);\n\n\t\tif (!fail1 && !fail2)\n\t\t\tINFO(\"Successfully dropped privilges to %d:%d (uid:gid)\", pw->pw_uid, pw->pw_gid);\n\n\t\t/*\n\t\t * Check we don't have write access to the FTP root,\n\t\t * unless explicitly allowed\n\t\t */\n\t\tif (!do_insecure && !access(home, W_OK)) {\n\t\t\tERR(0, \"FTP root %s writable, possible security violation, aborting session!\", home);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* On failure, we tried at least.  Only warn once. */\n\t\tprivs_dropped = 1;\n\t}\n\n\t/* Session timeout handler */\n\tuev_timer_init(ctrl->ctx, &ctrl->timeout_watcher, inactivity_cb, ctrl->ctx, INACTIVITY_TIMER, 0);\n\n\treturn ctrl;\nfail:\n\tif (ctrl)\n\t\tfree(ctrl);\n\tif (!inetd)\n\t\tfree(ctx);\n\t*rc = -1;\n\n\treturn NULL;\n}\n\nint del_session(ctrl_t *ctrl, int isftp)\n{\n\tDBG(\"%sFTP Client session ended.\", isftp ? \"\": \"T\" );\n\n\tif (!ctrl)\n\t\treturn -1;\n\n\tif (isftp && ctrl->sd > 0) {\n\t\tshutdown(ctrl->sd, SHUT_RDWR);\n\t\tclose(ctrl->sd);\n\t}\n\n\tif (ctrl->data_listen_sd > 0) {\n\t\tshutdown(ctrl->data_listen_sd, SHUT_RDWR);\n\t\tclose(ctrl->data_listen_sd);\n\t}\n\n\tif (ctrl->data_sd > 0) {\n\t\tshutdown(ctrl->data_sd, SHUT_RDWR);\n\t\tclose(ctrl->data_sd);\n\t}\n\n\tif (ctrl->buf)\n\t\tfree(ctrl->buf);\n\n\tif (!inetd && ctrl->ctx)\n\t\tfree(ctrl->ctx);\n\tfree(ctrl);\n\n\treturn 0;\n}\n\n/**\n * Local Variables:\n *  indent-tabs-mode: t\n *  c-file-style: \"linux\"\n * End:\n */\n"], "fixing_code": ["/* Common methods shared between FTP and TFTP engines\n *\n * Copyright (c) 2014-2019  Joachim Nilsson <troglobit@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"uftpd.h\"\n\nint chrooted = 0;\n\n/* Protect against common directory traversal attacks, for details see\n * https://en.wikipedia.org/wiki/Directory_traversal_attack\n *\n * Example:            /srv/ftp/ ../../etc/passwd => /etc/passwd\n *                    .~~~~~~~~ .~~~~~~~~~\n *                   /         /\n * Server dir ------'         /\n * User input ---------------'\n *\n * Forced dir ------> /srv/ftp/etc\n */\nchar *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(rpath, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}\n\nchar *compose_abspath(ctrl_t *ctrl, char *path)\n{\n\tchar *ptr;\n\tchar cwd[sizeof(ctrl->cwd)];\n\n\tif (path && path[0] == '/') {\n\t\tstrlcpy(cwd, ctrl->cwd, sizeof(cwd));\n\t\tmemset(ctrl->cwd, 0, sizeof(ctrl->cwd));\n\t}\n\n\tptr = compose_path(ctrl, path);\n\n\tif (path && path[0] == '/')\n\t\tstrlcpy(ctrl->cwd, cwd, sizeof(ctrl->cwd));\n\n\treturn ptr;\n}\n\nint set_nonblock(int fd)\n{\n\tint flags;\n\n\tflags = fcntl(fd, F_GETFL, 0);\n\tif (!flags)\n\t\t(void)fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n\n\treturn fd;\n}\n\nint open_socket(int port, int type, char *desc)\n{\n\tint sd, err, val = 1;\n\tsocklen_t len = sizeof(struct sockaddr);\n\tstruct sockaddr_in server;\n\n\tsd = socket(AF_INET, type | SOCK_NONBLOCK, 0);\n\tif (sd < 0) {\n\t\tWARN(errno, \"Failed creating %s server socket\", desc);\n\t\treturn -1;\n\t}\n\n\terr = setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));\n\tif (err != 0)\n\t\tWARN(errno, \"Failed setting SO_REUSEADDR on %s socket\", type == SOCK_DGRAM ? \"TFTP\" : \"FTP\");\n\n\tmemset(&server, 0, sizeof(server));\n\tserver.sin_family      = AF_INET;\n\tserver.sin_addr.s_addr = INADDR_ANY;\n\tserver.sin_port        = htons(port);\n\tif (bind(sd, (struct sockaddr *)&server, len) < 0) {\n\t\tif (EACCES != errno) {\n\t\t\tWARN(errno, \"Failed binding to port %d, maybe another %s server is already running\", port, desc);\n\t\t}\n\t\tclose(sd);\n\n\t\treturn -1;\n\t}\n\n\tif (port && type != SOCK_DGRAM) {\n\t\tif (-1 == listen(sd, 20))\n\t\t\tWARN(errno, \"Failed starting %s server\", desc);\n\t}\n\n\tDBG(\"Opened socket for port %d\", port);\n\n\treturn sd;\n}\n\nvoid convert_address(struct sockaddr_storage *ss, char *buf, size_t len)\n{\n\tswitch (ss->ss_family) {\n\tcase AF_INET:\n\t\tinet_ntop(ss->ss_family,\n\t\t\t  &((struct sockaddr_in *)ss)->sin_addr, buf, len);\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tinet_ntop(ss->ss_family,\n\t\t\t  &((struct sockaddr_in6 *)ss)->sin6_addr, buf, len);\n\t\tbreak;\n\t}\n}\n\n/* Inactivity timer, bye bye */\nstatic void inactivity_cb(uev_t *w, void *arg, int events)\n{\n\tuev_ctx_t *ctx = (uev_ctx_t *)arg;\n\n\tINFO(\"Inactivity timer, exiting ...\");\n\tuev_exit(ctx);\n}\n\nctrl_t *new_session(uev_ctx_t *ctx, int sd, int *rc)\n{\n\tctrl_t *ctrl = NULL;\n\tstatic int privs_dropped = 0;\n\n\tif (!inetd) {\n\t\tpid_t pid = fork();\n\n\t\tif (pid) {\n\t\t\tDBG(\"Created new client session as PID %d\", pid);\n\t\t\t*rc = pid;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * Set process group to parent, so uftpd can call\n\t\t * killpg() on all of us when it exits.\n\t\t */\n\t\tsetpgid(0, getppid());\n\t\t/* Create new uEv context for the child. */\n\t\tctx = calloc(1, sizeof(uev_ctx_t));\n\t\tif (!ctx) {\n\t\t\tERR(errno, \"Failed allocating session event context\");\n\t\t\texit(1);\n\t\t}\n\n\t\tuev_init(ctx);\n\t}\n\n\tctrl = calloc(1, sizeof(ctrl_t));\n\tif (!ctrl) {\n\t\tERR(errno, \"Failed allocating session context\");\n\t\tgoto fail;\n\t}\n\n\tctrl->sd = set_nonblock(sd);\n\tctrl->ctx = ctx;\n\tstrlcpy(ctrl->cwd, \"/\", sizeof(ctrl->cwd));\n\n\t/* Chroot to FTP root */\n\tif (!chrooted && geteuid() == 0) {\n\t\tif (chroot(home) || chdir(\"/\")) {\n\t\t\tERR(errno, \"Failed chrooting to FTP root, %s, aborting\", home);\n\t\t\tgoto fail;\n\t\t}\n\t\tchrooted = 1;\n\t} else if (!chrooted) {\n\t\tif (chdir(home)) {\n\t\t\tWARN(errno, \"Failed changing to FTP root, %s, aborting\", home);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* If ftp user exists and we're running as root we can drop privs */\n\tif (!privs_dropped && pw && geteuid() == 0) {\n\t\tint fail1, fail2;\n\n\t\tinitgroups(pw->pw_name, pw->pw_gid);\n\t\tif ((fail1 = setegid(pw->pw_gid)))\n\t\t\tWARN(errno, \"Failed dropping group privileges to gid %d\", pw->pw_gid);\n\t\tif ((fail2 = seteuid(pw->pw_uid)))\n\t\t\tWARN(errno, \"Failed dropping user privileges to uid %d\", pw->pw_uid);\n\n\t\tsetenv(\"HOME\", pw->pw_dir, 1);\n\n\t\tif (!fail1 && !fail2)\n\t\t\tINFO(\"Successfully dropped privilges to %d:%d (uid:gid)\", pw->pw_uid, pw->pw_gid);\n\n\t\t/*\n\t\t * Check we don't have write access to the FTP root,\n\t\t * unless explicitly allowed\n\t\t */\n\t\tif (!do_insecure && !access(home, W_OK)) {\n\t\t\tERR(0, \"FTP root %s writable, possible security violation, aborting session!\", home);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* On failure, we tried at least.  Only warn once. */\n\t\tprivs_dropped = 1;\n\t}\n\n\t/* Session timeout handler */\n\tuev_timer_init(ctrl->ctx, &ctrl->timeout_watcher, inactivity_cb, ctrl->ctx, INACTIVITY_TIMER, 0);\n\n\treturn ctrl;\nfail:\n\tif (ctrl)\n\t\tfree(ctrl);\n\tif (!inetd)\n\t\tfree(ctx);\n\t*rc = -1;\n\n\treturn NULL;\n}\n\nint del_session(ctrl_t *ctrl, int isftp)\n{\n\tDBG(\"%sFTP Client session ended.\", isftp ? \"\": \"T\" );\n\n\tif (!ctrl)\n\t\treturn -1;\n\n\tif (isftp && ctrl->sd > 0) {\n\t\tshutdown(ctrl->sd, SHUT_RDWR);\n\t\tclose(ctrl->sd);\n\t}\n\n\tif (ctrl->data_listen_sd > 0) {\n\t\tshutdown(ctrl->data_listen_sd, SHUT_RDWR);\n\t\tclose(ctrl->data_listen_sd);\n\t}\n\n\tif (ctrl->data_sd > 0) {\n\t\tshutdown(ctrl->data_sd, SHUT_RDWR);\n\t\tclose(ctrl->data_sd);\n\t}\n\n\tif (ctrl->buf)\n\t\tfree(ctrl->buf);\n\n\tif (!inetd && ctrl->ctx)\n\t\tfree(ctrl->ctx);\n\tfree(ctrl);\n\n\treturn 0;\n}\n\n/**\n * Local Variables:\n *  indent-tabs-mode: t\n *  c-file-style: \"linux\"\n * End:\n */\n"], "filenames": ["src/common.c"], "buggy_code_start_loc": [95], "buggy_code_end_loc": [96], "fixing_code_start_loc": [95], "fixing_code_end_loc": [96], "type": "CWE-22", "message": "In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11", "other": {"cve": {"id": "CVE-2020-5221", "sourceIdentifier": "security-advisories@github.com", "published": "2020-01-22T19:15:13.127", "lastModified": "2020-01-30T16:36:16.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11"}, {"lang": "es", "value": "En uftpd versiones anteriores a 2.11, es posible para un usuario no autenticado llevar a cabo un ataque de salto de directorio utilizando m\u00faltiples comandos FTP diferentes y al leer y escribir en ubicaciones arbitrarias en el sistema de archivos debido a la falta de una jaula de chroot bien escrita en la funci\u00f3n compose_abspath(). Esto ha sido corregido en la versi\u00f3n 2.11."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:troglobit:uftpd:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.11", "matchCriteriaId": "91EBCEEE-1F37-42E3-8C48-41BF050C3BE7"}]}]}], "references": [{"url": "https://github.com/troglobit/uftpd/commit/455b47d3756aed162d2d0ef7f40b549f3b5b30fe", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/troglobit/uftpd/security/advisories/GHSA-wmx8-v7mx-6x9h", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/troglobit/uftpd/commit/455b47d3756aed162d2d0ef7f40b549f3b5b30fe"}}