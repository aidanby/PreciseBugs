{"buggy_code": ["<?php\n// +-----------------------------------------------------------------------+\n// | This file is part of Piwigo.                                          |\n// |                                                                       |\n// | For copyright and license information, please view the COPYING.txt    |\n// | file that was distributed with this source code.                      |\n// +-----------------------------------------------------------------------+\n\ndefine('PHPWG_ROOT_PATH','../');\ndefine('IN_ADMIN', true);\n\ninclude_once(PHPWG_ROOT_PATH.'include/common.inc.php');\n\ncheck_status(ACCESS_ADMINISTRATOR);\n\ncheck_input_parameter('start', $_REQUEST, false, PATTERN_ID);\ncheck_input_parameter('length', $_REQUEST, false, PATTERN_ID);\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Easy set variables\n */\n\t\n/* Array of database columns which should be read and sent back to DataTables. Use a space where\n * you want to insert a non-database field (for example a counter or static image)\n */\n$aColumns = array(\n  $conf['user_fields']['id'],\n  $conf['user_fields']['username'],\n  'status',\n  $conf['user_fields']['email'],\n  'recent_period',\n  'level',\n  'registration_date'\n  );\n\n$aColumns = trigger_change('user_list_columns', $aColumns);\n\t\n/* Indexed column (used for fast and accurate table cardinality) */\n$sIndexColumn = 'user_id';\n\t\n/* DB table to use */\n$sTable = USERS_TABLE.' INNER JOIN '.USER_INFOS_TABLE.' AS ui ON '.$conf['user_fields']['id'].' = ui.user_id';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * If you just want to use the basic configuration for DataTables with PHP server-side, there is\n * no need to edit below this line\n */\n\n/* \n * Paging\n */\n$sLimit = \"\";\nif ( isset( $_REQUEST['start'] ) && $_REQUEST['length'] != '-1' )\n{\n  $sLimit = \"LIMIT \".$_REQUEST['start'].\", \".$_REQUEST['length'];\n}\n\t\n\n$sOrder = \"\";\n/*\n * Ordering\n */\nif ( isset( $_REQUEST[\"order\"][0][\"column\"] ) )\n{\n  $sOrder = \"ORDER BY  \";\n  $i = 0;\n  $col = $_REQUEST[\"order\"][0][\"column\"];\n  if ( $_REQUEST['columns'][$col][\"searchable\"] == \"true\" )\n  {\n    $sOrder .= $aColumns[ $col ].' '.$_REQUEST[\"order\"][0][\"dir\"].', ';\n  }\n  $sOrder = substr_replace( $sOrder, \"\", -2 );\n  if ( $sOrder == \"ORDER BY\" )\n  {\n    $sOrder = \"\";\n  }\n}\n\n/* \n * Filtering\n * NOTE this does not match the built-in DataTables filtering which does it\n * word by word on any field. It's possible to do here, but concerned about efficiency\n * on very large tables, and MySQL's regex functionality is very limited\n */\n$sWhere = \"\";\nif ( isSet( $_REQUEST['search'][\"value\"]) && $_REQUEST['search'][\"value\"] != \"\" )\n{\n  $user_ids = null;\n\n  if (preg_match('/group:(\\d+)/', $_REQUEST['search'][\"value\"], $matches))\n  {\n    $group_id = $matches[1];\n\n    $query = '\nSELECT\n    `user_id`\n  FROM '.USER_GROUP_TABLE.'\n  WHERE `group_id` = '.$group_id.'\n';\n    $user_ids = query2array($query, null, 'user_id');\n    $user_ids[] = -1;\n\n    $_REQUEST['search'][\"value\"] = preg_replace('/group:(\\d+)/', '', $_REQUEST['search'][\"value\"]);\n  }\n\n  $sWhere = \"WHERE (\";\n\n  if (is_array($user_ids))\n  {\n    $sWhere.= '`user_id` IN ('.implode(',', $user_ids).') OR ';\n  }\n\n  if ($_REQUEST['search'][\"value\"] != \"\")\n  {\n    for ( $i=0 ; $i<count($aColumns) ; $i++ )\n    {\n      $sWhere .= $aColumns[$i].\" LIKE '%\".pwg_db_real_escape_string( $_REQUEST['search'][\"value\"] ).\"%' OR \";\n    }\n  }\n\n  $sWhere = substr_replace( $sWhere, \"\", -3 );\n  $sWhere .= ')';\n}\n\t\n/* Individual column filtering */\nfor ( $i=0 ; $i<count($aColumns) ; $i++ )\n{\n  if (isset($_REQUEST['columns'][$i][\"searchable\"]) && isset($_REQUEST['columns'][$i]['search']['value'])\n      && $_REQUEST['columns'][$i][\"searchable\"] == \"true\" && $_REQUEST['columns'][$i]['search']['value'] != ''\n    )\n  {\n    if ( $sWhere == \"\" )\n    {\n      $sWhere = \"WHERE \";\n    }\n    else\n    {\n      $sWhere .= \" AND \";\n    }\n    $sWhere .= $aColumns[$i].\" LIKE '%\".pwg_db_real_escape_string($_REQUEST['columns'][$i]['search']['value']).\"%' \";\n  }\n}\n\t\n\t\n/*\n * SQL queries\n * Get data to display\n */\n\nif (isSet($_REQUEST['get_set_uids'])) {\n  $sQuery = \"\n    SELECT SQL_CALC_FOUND_ROWS \".str_replace(\" , \", \" \", implode(\", \", $aColumns)).\"\n    FROM   $sTable\n    $sWhere\n    $sOrder ;\n    \";\n} else {\n  $sQuery = \"\n\t\tSELECT SQL_CALC_FOUND_ROWS \".str_replace(\" , \", \" \", implode(\", \", $aColumns)).\"\n\t\tFROM   $sTable\n\t\t$sWhere\n\t\t$sOrder\n\t\t$sLimit\n  \";\n}\n$rResult = pwg_query($sQuery);\n\t\n/* Data set length after filtering */\n$rResultFilterTotal = pwg_query('SELECT FOUND_ROWS();');\nlist($iFilteredTotal) = pwg_db_fetch_row($rResultFilterTotal);\n\n/* Total data set length */\n$sQuery = \"\n\t\tSELECT COUNT(\".$sIndexColumn.\")\n\t\tFROM   $sTable\n\t\";\n$rResultTotal = pwg_query($sQuery);\n$aResultTotal = pwg_db_fetch_array($rResultTotal);\n$iTotal = $aResultTotal[0];\n\n\n$sEcho = isSet($_REQUEST['sEcho']) ? intval($_REQUEST['sEcho']) : 0;\n/*\n * Output\n */\n\n$output = array(\n  \"sEcho\" => $sEcho,\n  \"iTotalRecords\" => $iTotal,\n  \"iTotalDisplayRecords\" => $iFilteredTotal,\n  \"aaData\" => array(),\n  \"filtered_uids\" => array()\n\t);\n\n$user_ids = array();\n$filtered_uids = array();\n\nif (isSet($_REQUEST['get_set_uids'])) {\n  while ( $aRow = pwg_db_fetch_array( $rResult ) )\n  {\n  $filtered_uids[] = $aRow[ $conf['user_fields']['id'] ];\n  }\n} else {\n  while ( $aRow = pwg_db_fetch_array( $rResult ) )\n  {\n    $user_ids[] = $aRow[ $conf['user_fields']['id'] ];\n\n    $row = array();\n    for ( $i=0 ; $i<count($aColumns) ; $i++ )\n    {\n      if ( $aColumns[$i] == \"status\" )\n      {\n        $row[] = l10n('user_status_'.$aRow[ $aColumns[$i] ]);\n      }\n      else if ( $aColumns[$i] == \"level\" )\n      {\n        $row[] = $aRow[ $aColumns[$i] ] == 0 ? '' : l10n(sprintf('Level %d', $aRow[ $aColumns[$i] ]));\n      }\n      else if ( $aColumns[$i] != ' ' )\n      {\n        /* General output */\n        $colname = $aColumns[$i];\n        foreach ($conf['user_fields'] as $real_name => $alias)\n        {\n          if ($aColumns[$i] == $real_name)\n          {\n            $colname = $alias;\n          }\n        }\n        $row[] = $aRow[$colname];\n      }\n    }\n    $output['aaData'][] = $row;\n  }\n}\n\n$output[\"filtered_uids\"] = $filtered_uids;\n\n// replace \"recent_period\" by the list of groups\nif (count($user_ids) > 0)\n{\n  $groups_of_user = array();\n  \n  $query = '\nSELECT\n    user_id,\n    GROUP_CONCAT(name ORDER BY name SEPARATOR \", \") AS `groups`\n  FROM '.USER_GROUP_TABLE.'\n    JOIN `'.GROUPS_TABLE.'` ON id = group_id\n  WHERE user_id IN ('.implode(',', $user_ids).')\n  GROUP BY user_id\n;';\n  $result = pwg_query($query);\n  while ($row = pwg_db_fetch_assoc($result))\n  {\n    $groups_of_user[ $row['user_id'] ] = $row['groups'];\n  }\n\n  $key_replace = array_search('recent_period', $aColumns);\n  \n  // replacement\n  foreach (array_keys($output['aaData']) as $idx)\n  {\n    $user_id = $output['aaData'][$idx][0];\n    $output['aaData'][$idx][$key_replace] = isset($groups_of_user[$user_id]) ? $groups_of_user[$user_id] : '';\n  }\n}\n\n$output = trigger_change('after_render_user_list', $output);\n\necho json_encode( $output );\n?>"], "fixing_code": ["<?php\n// +-----------------------------------------------------------------------+\n// | This file is part of Piwigo.                                          |\n// |                                                                       |\n// | For copyright and license information, please view the COPYING.txt    |\n// | file that was distributed with this source code.                      |\n// +-----------------------------------------------------------------------+\n\ndefine('PHPWG_ROOT_PATH','../');\ndefine('IN_ADMIN', true);\n\ninclude_once(PHPWG_ROOT_PATH.'include/common.inc.php');\n\ncheck_status(ACCESS_ADMINISTRATOR);\n\ncheck_input_parameter('start', $_REQUEST, false, PATTERN_ID);\ncheck_input_parameter('length', $_REQUEST, false, PATTERN_ID);\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Easy set variables\n */\n\t\n/* Array of database columns which should be read and sent back to DataTables. Use a space where\n * you want to insert a non-database field (for example a counter or static image)\n */\n$aColumns = array(\n  $conf['user_fields']['id'],\n  $conf['user_fields']['username'],\n  'status',\n  $conf['user_fields']['email'],\n  'recent_period',\n  'level',\n  'registration_date'\n  );\n\n$aColumns = trigger_change('user_list_columns', $aColumns);\n\t\n/* Indexed column (used for fast and accurate table cardinality) */\n$sIndexColumn = 'user_id';\n\t\n/* DB table to use */\n$sTable = USERS_TABLE.' INNER JOIN '.USER_INFOS_TABLE.' AS ui ON '.$conf['user_fields']['id'].' = ui.user_id';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * If you just want to use the basic configuration for DataTables with PHP server-side, there is\n * no need to edit below this line\n */\n\n/* \n * Paging\n */\n$sLimit = \"\";\nif ( isset( $_REQUEST['start'] ) && $_REQUEST['length'] != '-1' )\n{\n  $sLimit = \"LIMIT \".$_REQUEST['start'].\", \".$_REQUEST['length'];\n}\n\t\n\n$sOrder = \"\";\n/*\n * Ordering\n */\nif ( isset( $_REQUEST[\"order\"][0][\"column\"] ) )\n{\n  $sOrder = \"ORDER BY  \";\n  $i = 0;\n  $col = $_REQUEST[\"order\"][0][\"column\"];\n  if ( $_REQUEST['columns'][$col][\"searchable\"] == \"true\" and preg_match('/^(asc|desc)$/i', $_REQUEST[\"order\"][0][\"dir\"]))\n  {\n    $sOrder .= $aColumns[ $col ].' '.$_REQUEST[\"order\"][0][\"dir\"].', ';\n  }\n  $sOrder = substr_replace( $sOrder, \"\", -2 );\n  if ( $sOrder == \"ORDER BY\" )\n  {\n    $sOrder = \"\";\n  }\n}\n\n/* \n * Filtering\n * NOTE this does not match the built-in DataTables filtering which does it\n * word by word on any field. It's possible to do here, but concerned about efficiency\n * on very large tables, and MySQL's regex functionality is very limited\n */\n$sWhere = \"\";\nif ( isSet( $_REQUEST['search'][\"value\"]) && $_REQUEST['search'][\"value\"] != \"\" )\n{\n  $user_ids = null;\n\n  if (preg_match('/group:(\\d+)/', $_REQUEST['search'][\"value\"], $matches))\n  {\n    $group_id = $matches[1];\n\n    $query = '\nSELECT\n    `user_id`\n  FROM '.USER_GROUP_TABLE.'\n  WHERE `group_id` = '.$group_id.'\n';\n    $user_ids = query2array($query, null, 'user_id');\n    $user_ids[] = -1;\n\n    $_REQUEST['search'][\"value\"] = preg_replace('/group:(\\d+)/', '', $_REQUEST['search'][\"value\"]);\n  }\n\n  $sWhere = \"WHERE (\";\n\n  if (is_array($user_ids))\n  {\n    $sWhere.= '`user_id` IN ('.implode(',', $user_ids).') OR ';\n  }\n\n  if ($_REQUEST['search'][\"value\"] != \"\")\n  {\n    for ( $i=0 ; $i<count($aColumns) ; $i++ )\n    {\n      $sWhere .= $aColumns[$i].\" LIKE '%\".pwg_db_real_escape_string( $_REQUEST['search'][\"value\"] ).\"%' OR \";\n    }\n  }\n\n  $sWhere = substr_replace( $sWhere, \"\", -3 );\n  $sWhere .= ')';\n}\n\t\n/* Individual column filtering */\nfor ( $i=0 ; $i<count($aColumns) ; $i++ )\n{\n  if (isset($_REQUEST['columns'][$i][\"searchable\"]) && isset($_REQUEST['columns'][$i]['search']['value'])\n      && $_REQUEST['columns'][$i][\"searchable\"] == \"true\" && $_REQUEST['columns'][$i]['search']['value'] != ''\n    )\n  {\n    if ( $sWhere == \"\" )\n    {\n      $sWhere = \"WHERE \";\n    }\n    else\n    {\n      $sWhere .= \" AND \";\n    }\n    $sWhere .= $aColumns[$i].\" LIKE '%\".pwg_db_real_escape_string($_REQUEST['columns'][$i]['search']['value']).\"%' \";\n  }\n}\n\t\n\t\n/*\n * SQL queries\n * Get data to display\n */\n\nif (isSet($_REQUEST['get_set_uids'])) {\n  $sQuery = \"\n    SELECT SQL_CALC_FOUND_ROWS \".str_replace(\" , \", \" \", implode(\", \", $aColumns)).\"\n    FROM   $sTable\n    $sWhere\n    $sOrder ;\n    \";\n} else {\n  $sQuery = \"\n\t\tSELECT SQL_CALC_FOUND_ROWS \".str_replace(\" , \", \" \", implode(\", \", $aColumns)).\"\n\t\tFROM   $sTable\n\t\t$sWhere\n\t\t$sOrder\n\t\t$sLimit\n  \";\n}\n$rResult = pwg_query($sQuery);\n\t\n/* Data set length after filtering */\n$rResultFilterTotal = pwg_query('SELECT FOUND_ROWS();');\nlist($iFilteredTotal) = pwg_db_fetch_row($rResultFilterTotal);\n\n/* Total data set length */\n$sQuery = \"\n\t\tSELECT COUNT(\".$sIndexColumn.\")\n\t\tFROM   $sTable\n\t\";\n$rResultTotal = pwg_query($sQuery);\n$aResultTotal = pwg_db_fetch_array($rResultTotal);\n$iTotal = $aResultTotal[0];\n\n\n$sEcho = isSet($_REQUEST['sEcho']) ? intval($_REQUEST['sEcho']) : 0;\n/*\n * Output\n */\n\n$output = array(\n  \"sEcho\" => $sEcho,\n  \"iTotalRecords\" => $iTotal,\n  \"iTotalDisplayRecords\" => $iFilteredTotal,\n  \"aaData\" => array(),\n  \"filtered_uids\" => array()\n\t);\n\n$user_ids = array();\n$filtered_uids = array();\n\nif (isSet($_REQUEST['get_set_uids'])) {\n  while ( $aRow = pwg_db_fetch_array( $rResult ) )\n  {\n  $filtered_uids[] = $aRow[ $conf['user_fields']['id'] ];\n  }\n} else {\n  while ( $aRow = pwg_db_fetch_array( $rResult ) )\n  {\n    $user_ids[] = $aRow[ $conf['user_fields']['id'] ];\n\n    $row = array();\n    for ( $i=0 ; $i<count($aColumns) ; $i++ )\n    {\n      if ( $aColumns[$i] == \"status\" )\n      {\n        $row[] = l10n('user_status_'.$aRow[ $aColumns[$i] ]);\n      }\n      else if ( $aColumns[$i] == \"level\" )\n      {\n        $row[] = $aRow[ $aColumns[$i] ] == 0 ? '' : l10n(sprintf('Level %d', $aRow[ $aColumns[$i] ]));\n      }\n      else if ( $aColumns[$i] != ' ' )\n      {\n        /* General output */\n        $colname = $aColumns[$i];\n        foreach ($conf['user_fields'] as $real_name => $alias)\n        {\n          if ($aColumns[$i] == $real_name)\n          {\n            $colname = $alias;\n          }\n        }\n        $row[] = $aRow[$colname];\n      }\n    }\n    $output['aaData'][] = $row;\n  }\n}\n\n$output[\"filtered_uids\"] = $filtered_uids;\n\n// replace \"recent_period\" by the list of groups\nif (count($user_ids) > 0)\n{\n  $groups_of_user = array();\n  \n  $query = '\nSELECT\n    user_id,\n    GROUP_CONCAT(name ORDER BY name SEPARATOR \", \") AS `groups`\n  FROM '.USER_GROUP_TABLE.'\n    JOIN `'.GROUPS_TABLE.'` ON id = group_id\n  WHERE user_id IN ('.implode(',', $user_ids).')\n  GROUP BY user_id\n;';\n  $result = pwg_query($query);\n  while ($row = pwg_db_fetch_assoc($result))\n  {\n    $groups_of_user[ $row['user_id'] ] = $row['groups'];\n  }\n\n  $key_replace = array_search('recent_period', $aColumns);\n  \n  // replacement\n  foreach (array_keys($output['aaData']) as $idx)\n  {\n    $user_id = $output['aaData'][$idx][0];\n    $output['aaData'][$idx][$key_replace] = isset($groups_of_user[$user_id]) ? $groups_of_user[$user_id] : '';\n  }\n}\n\n$output = trigger_change('after_render_user_list', $output);\n\necho json_encode( $output );\n?>"], "filenames": ["admin/user_list_backend.php"], "buggy_code_start_loc": [68], "buggy_code_end_loc": [69], "fixing_code_start_loc": [68], "fixing_code_end_loc": [69], "type": "CWE-89", "message": "Piwigo 11.4.0 allows admin/user_list_backend.php order[0][dir] SQL Injection.", "other": {"cve": {"id": "CVE-2021-32615", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-13T23:15:07.337", "lastModified": "2021-05-21T20:06:36.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Piwigo 11.4.0 allows admin/user_list_backend.php order[0][dir] SQL Injection."}, {"lang": "es", "value": "Piwigo versi\u00f3n 11.4.0 permite la inyecci\u00f3n SQL en admin/user_list_backend.php order[0][dir]."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:piwigo:piwigo:11.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "B9E1456D-0916-4CBB-BE90-A5AE7E099A38"}]}]}], "references": [{"url": "https://github.com/Piwigo/Piwigo/commit/2ce1e5952238eba0fe5c5d6537ebdc76cb970b52", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Piwigo/Piwigo/issues/1410", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Piwigo/Piwigo/commit/2ce1e5952238eba0fe5c5d6537ebdc76cb970b52"}}