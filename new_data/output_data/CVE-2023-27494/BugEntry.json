{"buggy_code": ["# Copyright 2018-2021 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport mimetypes\nimport os\nfrom typing import Any, Dict, Optional, Type, Union\nimport threading\nimport inspect\n\nimport tornado.web\n\nimport streamlit.server.routes\nfrom streamlit import type_util\nfrom streamlit import util\nfrom streamlit.errors import StreamlitAPIException\nfrom streamlit.logger import get_logger\nfrom streamlit.proto.ArrowTable_pb2 import ArrowTable as ArrowTableProto\nfrom streamlit.proto.ComponentInstance_pb2 import SpecialArg\nfrom streamlit.proto.Element_pb2 import Element\nfrom streamlit.type_util import to_bytes\nfrom streamlit.widgets import NoValue, register_widget\n\nLOGGER = get_logger(__name__)\n\n\nclass MarshallComponentException(StreamlitAPIException):\n    \"\"\"Class for exceptions generated during custom component marshalling.\"\"\"\n\n    pass\n\n\nclass CustomComponent:\n    \"\"\"A Custom Component declaration.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        path: Optional[str] = None,\n        url: Optional[str] = None,\n    ):\n        if (path is None and url is None) or (path is not None and url is not None):\n            raise StreamlitAPIException(\n                \"Either 'path' or 'url' must be set, but not both.\"\n            )\n\n        self.name = name\n        self.path = path\n        self.url = url\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    @property\n    def abspath(self) -> Optional[str]:\n        \"\"\"The absolute path that the component is served from.\"\"\"\n        if self.path is None:\n            return None\n        return os.path.abspath(self.path)\n\n    def __call__(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"An alias for create_instance.\"\"\"\n        return self.create_instance(*args, default=default, key=key, **kwargs)\n\n    def create_instance(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"Create a new instance of the component.\n\n        Parameters\n        ----------\n        *args\n            Must be empty; all args must be named. (This parameter exists to\n            enforce correct use of the function.)\n        default: any or None\n            The default return value for the component. This is returned when\n            the component's frontend hasn't yet specified a value with\n            `setComponentValue`.\n        key: str or None\n            If not None, this is the user key we use to generate the\n            component's \"widget ID\".\n        **kwargs\n            Keyword args to pass to the component.\n\n        Returns\n        -------\n        any or None\n            The component's widget value.\n\n        \"\"\"\n        if len(args) > 0:\n            raise MarshallComponentException(f\"Argument '{args[0]}' needs a label\")\n\n        try:\n            import pyarrow\n            from streamlit.elements import arrow_table\n        except ImportError:\n            import sys\n\n            if sys.version_info >= (3, 9):\n                raise StreamlitAPIException(\n                    \"\"\"To use Custom Components in Streamlit, you need to install\nPyArrow. Unfortunately, PyArrow does not yet support Python 3.9.\n\nYou can either switch to Python 3.8 with an environment manager like PyEnv, or stay on 3.9 by\n[installing Streamlit with conda](https://discuss.streamlit.io/t/note-installation-issues-with-python-3-9-and-streamlit/6946):\n\n`conda install -c conda-forge streamlit`\n\n\"\"\"\n                )\n            else:\n                raise StreamlitAPIException(\n                    \"\"\"To use Custom Components in Streamlit, you need to install\nPyArrow. To do so locally:\n\n`pip install pyarrow`\n\nAnd if you're using Streamlit Sharing, add \"pyarrow\" to your requirements.txt.\"\"\"\n                )\n\n        # In addition to the custom kwargs passed to the component, we also\n        # send the special 'default' and 'key' params to the component\n        # frontend.\n        all_args = dict(kwargs, **{\"default\": default, \"key\": key})\n\n        json_args = {}\n        special_args = []\n        for arg_name, arg_val in all_args.items():\n            if type_util.is_bytes_like(arg_val):\n                bytes_arg = SpecialArg()\n                bytes_arg.key = arg_name\n                bytes_arg.bytes = to_bytes(arg_val)\n                special_args.append(bytes_arg)\n            elif type_util.is_dataframe_like(arg_val):\n                dataframe_arg = SpecialArg()\n                dataframe_arg.key = arg_name\n                arrow_table.marshall(dataframe_arg.arrow_dataframe.data, arg_val)\n                special_args.append(dataframe_arg)\n            else:\n                json_args[arg_name] = arg_val\n\n        try:\n            serialized_json_args = json.dumps(json_args)\n        except BaseException as e:\n            raise MarshallComponentException(\n                \"Could not convert component args to JSON\", e\n            )\n\n        def marshall_component(element: Element) -> Union[Any, Type[NoValue]]:\n            element.component_instance.component_name = self.name\n            if self.url is not None:\n                element.component_instance.url = self.url\n\n            # Normally, a widget's element_hash (which determines\n            # its identity across multiple runs of an app) is computed\n            # by hashing the entirety of its protobuf. This means that,\n            # if any of the arguments to the widget are changed, Streamlit\n            # considers it a new widget instance and it loses its previous\n            # state.\n            #\n            # However! If a *component* has a `key` argument, then the\n            # component's hash identity is determined by entirely by\n            # `component_name + url + key`. This means that, when `key`\n            # exists, the component will maintain its identity even when its\n            # other arguments change, and the component's iframe won't be\n            # remounted on the frontend.\n            #\n            # So: if `key` is None, we marshall the element's arguments\n            # *before* computing its widget_ui_value (which creates its hash).\n            # If `key` is not None, we marshall the arguments *after*.\n\n            def marshall_element_args():\n                element.component_instance.json_args = serialized_json_args\n                element.component_instance.special_args.extend(special_args)\n\n            if key is None:\n                marshall_element_args()\n\n            widget_value = register_widget(\n                element_type=\"component_instance\",\n                element_proto=element.component_instance,\n                user_key=key,\n                widget_func_name=self.name,\n            )\n\n            if key is not None:\n                marshall_element_args()\n\n            if widget_value is None:\n                widget_value = default\n            elif isinstance(widget_value, ArrowTableProto):\n                widget_value = arrow_table.arrow_proto_to_dataframe(widget_value)\n\n            # widget_value will be either None or whatever the component's most\n            # recent setWidgetValue value is. We coerce None -> NoValue,\n            # because that's what DeltaGenerator._enqueue expects.\n            return widget_value if widget_value is not None else NoValue\n\n        # We currently only support writing to st._main, but this will change\n        # when we settle on an improved API in a post-layout world.\n        element = Element()\n        return_value = marshall_component(element)\n        result = streamlit._main._enqueue(\n            \"component_instance\", element.component_instance, return_value\n        )\n\n        return result\n\n    def __eq__(self, other) -> bool:\n        \"\"\"Equality operator.\"\"\"\n        return (\n            isinstance(other, CustomComponent)\n            and self.name == other.name\n            and self.path == other.path\n            and self.url == other.url\n        )\n\n    def __ne__(self, other) -> bool:\n        \"\"\"Inequality operator.\"\"\"\n        return not self == other\n\n    def __str__(self) -> str:\n        return f\"'{self.name}': {self.path if self.path is not None else self.url}\"\n\n\ndef declare_component(\n    name: str,\n    path: Optional[str] = None,\n    url: Optional[str] = None,\n) -> CustomComponent:\n    \"\"\"Create and register a custom component.\n\n    Parameters\n    ----------\n    name: str\n        A short, descriptive name for the component. Like, \"slider\".\n    path: str or None\n        The path to serve the component's frontend files from. Either\n        `path` or `url` must be specified, but not both.\n    url: str or None\n        The URL that the component is served from. Either `path` or `url`\n        must be specified, but not both.\n\n    Returns\n    -------\n    CustomComponent\n        A CustomComponent that can be called like a function.\n        Calling the component will create a new instance of the component\n        in the Streamlit app.\n\n    \"\"\"\n\n    # Get our stack frame.\n    current_frame = inspect.currentframe()\n    assert current_frame is not None\n\n    # Get the stack frame of our calling function.\n    caller_frame = current_frame.f_back\n    assert caller_frame is not None\n\n    # Get the caller's module name. `__name__` gives us the module's\n    # fully-qualified name, which includes its package.\n    module = inspect.getmodule(caller_frame)\n    assert module is not None\n    module_name = module.__name__\n\n    # If the caller was the main module that was executed (that is, if the\n    # user executed `python my_component.py`), then this name will be\n    # \"__main__\" instead of the actual package name. In this case, we use\n    # the main module's filename, sans `.py` extension, as the component name.\n    if module_name == \"__main__\":\n        file_path = inspect.getfile(caller_frame)\n        filename = os.path.basename(file_path)\n        module_name, _ = os.path.splitext(filename)\n\n    # Build the component name.\n    component_name = f\"{module_name}.{name}\"\n\n    # Create our component object, and register it.\n    component = CustomComponent(name=component_name, path=path, url=url)\n    ComponentRegistry.instance().register_component(component)\n\n    return component\n\n\nclass ComponentRequestHandler(tornado.web.RequestHandler):\n    def initialize(self, registry: \"ComponentRegistry\"):\n        self._registry = registry\n\n    def get(self, path: str) -> None:\n        parts = path.split(\"/\")\n        component_name = parts[0]\n        component_root = self._registry.get_component_path(component_name)\n        if component_root is None:\n            self.write(f\"{path} not found\")\n            self.set_status(404)\n            return\n\n        filename = \"/\".join(parts[1:])\n        abspath = os.path.join(component_root, filename)\n\n        LOGGER.debug(\"ComponentRequestHandler: GET: %s -> %s\", path, abspath)\n\n        try:\n            with open(abspath, \"r\", encoding=\"utf-8\") as file:\n                contents = file.read()\n        except (OSError, UnicodeDecodeError) as e:\n            self.write(f\"{path} read error: {e}\")\n            self.set_status(404)\n            return\n\n        self.write(contents)\n        self.set_header(\"Content-Type\", self.get_content_type(abspath))\n\n        self.set_extra_headers(path)\n\n    def set_extra_headers(self, path) -> None:\n        \"\"\"Disable cache for HTML files.\n\n        Other assets like JS and CSS are suffixed with their hash, so they can\n        be cached indefinitely.\n        \"\"\"\n        is_index_url = len(path) == 0\n\n        if is_index_url or path.endswith(\".html\"):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n        else:\n            self.set_header(\"Cache-Control\", \"public\")\n\n    def set_default_headers(self) -> None:\n        if streamlit.server.routes.allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    def options(self) -> None:\n        \"\"\"/OPTIONS handler for preflight CORS checks.\"\"\"\n        self.set_status(204)\n        self.finish()\n\n    @staticmethod\n    def get_content_type(abspath) -> str:\n        \"\"\"Returns the ``Content-Type`` header to be used for this request.\n        From tornado.web.StaticFileHandler.\n        \"\"\"\n        mime_type, encoding = mimetypes.guess_type(abspath)\n        # per RFC 6713, use the appropriate type for a gzip compressed file\n        if encoding == \"gzip\":\n            return \"application/gzip\"\n        # As of 2015-07-21 there is no bzip2 encoding defined at\n        # http://www.iana.org/assignments/media-types/media-types.xhtml\n        # So for that (and any other encoding), use octet-stream.\n        elif encoding is not None:\n            return \"application/octet-stream\"\n        elif mime_type is not None:\n            return mime_type\n        # if mime_type not detected, use application/octet-stream\n        else:\n            return \"application/octet-stream\"\n\n    @staticmethod\n    def get_url(file_id: str) -> str:\n        \"\"\"Return the URL for a component file with the given ID.\"\"\"\n        return \"components/{}\".format(file_id)\n\n\nclass ComponentRegistry:\n    _instance_lock = threading.Lock()\n    _instance = None  # type: Optional[ComponentRegistry]\n\n    @classmethod\n    def instance(cls) -> \"ComponentRegistry\":\n        \"\"\"Returns the singleton ComponentRegistry\"\"\"\n        # We use a double-checked locking optimization to avoid the overhead\n        # of acquiring the lock in the common case:\n        # https://en.wikipedia.org/wiki/Double-checked_locking\n        if cls._instance is None:\n            with cls._instance_lock:\n                if cls._instance is None:\n                    cls._instance = ComponentRegistry()\n        return cls._instance\n\n    def __init__(self):\n        self._components = {}  # type: Dict[str, CustomComponent]\n        self._lock = threading.Lock()\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    def register_component(self, component: CustomComponent) -> None:\n        \"\"\"Register a CustomComponent.\n\n        Parameters\n        ----------\n        component : CustomComponent\n            The component to register.\n        \"\"\"\n\n        # Validate the component's path\n        abspath = component.abspath\n        if abspath is not None and not os.path.isdir(abspath):\n            raise StreamlitAPIException(f\"No such component directory: '{abspath}'\")\n\n        with self._lock:\n            existing = self._components.get(component.name)\n            self._components[component.name] = component\n\n        if existing is not None and component != existing:\n            LOGGER.warning(\n                \"%s overriding previously-registered %s\",\n                component,\n                existing,\n            )\n\n        LOGGER.debug(\"Registered component %s\", component)\n\n    def get_component_path(self, name: str) -> Optional[str]:\n        \"\"\"Return the filesystem path for the component with the given name.\n\n        If no such component is registered, or if the component exists but is\n        being served from a URL, return None instead.\n        \"\"\"\n        component = self._components.get(name, None)\n        return component.abspath if component is not None else None\n", "# Copyright 2018-2021 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\n\nimport tornado.web\n\nfrom streamlit import config\nfrom streamlit import metrics\nfrom streamlit.logger import get_logger\nfrom streamlit.server.server_util import serialize_forward_msg\nfrom streamlit.media_file_manager import media_file_manager\n\n\nLOGGER = get_logger(__name__)\n\n\ndef allow_cross_origin_requests():\n    \"\"\"True if cross-origin requests are allowed.\n\n    We only allow cross-origin requests when CORS protection has been disabled\n    with server.enableCORS=False or if using the Node server. When using the\n    Node server, we have a dev and prod port, which count as two origins.\n\n    \"\"\"\n    return not config.get_option(\"server.enableCORS\") or config.get_option(\n        \"global.developmentMode\"\n    )\n\n\nclass StaticFileHandler(tornado.web.StaticFileHandler):\n    def set_extra_headers(self, path):\n        \"\"\"Disable cache for HTML files.\n\n        Other assets like JS and CSS are suffixed with their hash, so they can\n        be cached indefinitely.\n        \"\"\"\n        is_index_url = len(path) == 0\n\n        if is_index_url or path.endswith(\".html\"):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n        else:\n            self.set_header(\"Cache-Control\", \"public\")\n\n\nclass AssetsFileHandler(tornado.web.StaticFileHandler):\n    # CORS protection should be disabled as we need access\n    # to this endpoint from the inner iframe.\n    def set_default_headers(self):\n        self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n\nclass AddSlashHandler(tornado.web.RequestHandler):\n    @tornado.web.addslash\n    def get(self):\n        pass\n\n\nclass MediaFileHandler(tornado.web.StaticFileHandler):\n    def set_default_headers(self):\n        if allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    # Overriding StaticFileHandler to use the MediaFileManager\n    #\n    # From the Torndado docs:\n    # To replace all interaction with the filesystem (e.g. to serve\n    # static content from a database), override `get_content`,\n    # `get_content_size`, `get_modified_time`, `get_absolute_path`, and\n    # `validate_absolute_path`.\n    def validate_absolute_path(self, root, absolute_path):\n        try:\n            media_file_manager.get(absolute_path)\n        except KeyError:\n            LOGGER.error(\"MediaFileManager: Missing file %s\" % absolute_path)\n            raise tornado.web.HTTPError(404, \"%s not found\", absolute_path)\n\n        return absolute_path\n\n    def get_content_size(self):\n        media = media_file_manager.get(self.absolute_path)\n        return media.content_size\n\n    def get_modified_time(self):\n        # We do not track last modified time, but this can be improved to\n        # allow caching among files in the MediaFileManager\n        return None\n\n    @classmethod\n    def get_absolute_path(cls, root, path):\n        # All files are stored in memory, so the absolute path is just the\n        # path itself. In the MediaFileHandler, it's just the filename\n        return path\n\n    @classmethod\n    def get_content(cls, abspath, start=None, end=None):\n        LOGGER.debug(\"MediaFileHandler: GET %s\" % abspath)\n\n        try:\n            # abspath is the hash as used `get_absolute_path`\n            media = media_file_manager.get(abspath)\n        except:\n            LOGGER.error(\"MediaFileManager: Missing file %s\" % abspath)\n            return\n\n        LOGGER.debug(\"MediaFileManager: Sending %s file %s\" % (media.mimetype, abspath))\n\n        # If there is no start and end, just return the full content\n        if start is None and end is None:\n            return media.content\n\n        if start is None:\n            start = 0\n        if end is None:\n            end = len(media.content)\n\n        # content is bytes that work just by slicing supplied by start and end\n        return media.content[start:end]\n\n\nclass _SpecialRequestHandler(tornado.web.RequestHandler):\n    \"\"\"Superclass for \"special\" endpoints, like /healthz.\"\"\"\n\n    def set_default_headers(self):\n        self.set_header(\"Cache-Control\", \"no-cache\")\n        if allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    def options(self):\n        \"\"\"/OPTIONS handler for preflight CORS checks.\n\n        When a browser is making a CORS request, it may sometimes first\n        send an OPTIONS request, to check whether the server understands the\n        CORS protocol. This is optional, and doesn't happen for every request\n        or in every browser. If an OPTIONS request does get sent, and is not\n        then handled by the server, the browser will fail the underlying\n        request.\n\n        The proper way to handle this is to send a 204 response (\"no content\")\n        with the CORS headers attached. (These headers are automatically added\n        to every outgoing response, including OPTIONS responses,\n        via set_default_headers().)\n\n        See https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request\n        \"\"\"\n        self.set_status(204)\n        self.finish()\n\n\nclass HealthHandler(_SpecialRequestHandler):\n    def initialize(self, callback):\n        \"\"\"Initialize the handler\n\n        Parameters\n        ----------\n        callback : callable\n            A function that returns True if the server is healthy\n\n        \"\"\"\n        self._callback = callback\n\n    def get(self):\n        if self._callback():\n            self.write(\"ok\")\n            self.set_status(200)\n\n            # Tornado will set the _xsrf cookie automatically for the page on\n            # request for the document. However, if the server is reset and\n            # server.enableXsrfProtection is updated, the browser does not reload the document.\n            # Manually setting the cookie on /healthz since it is pinged when the\n            # browser is disconnected from the server.\n            if config.get_option(\"server.enableXsrfProtection\"):\n                self.set_cookie(\"_xsrf\", self.xsrf_token)\n\n        else:\n            # 503 = SERVICE_UNAVAILABLE\n            self.set_status(503)\n            self.write(\"unavailable\")\n\n\nclass MetricsHandler(_SpecialRequestHandler):\n    def get(self):\n        if config.get_option(\"global.metrics\"):\n            self.add_header(\"Cache-Control\", \"no-cache\")\n            self.set_header(\"Content-Type\", \"text/plain\")\n            self.write(metrics.Client.get_current().generate_latest())\n        else:\n            self.set_status(404)\n            raise tornado.web.Finish()\n\n\nclass DebugHandler(_SpecialRequestHandler):\n    def initialize(self, server):\n        self._server = server\n\n    def get(self):\n        self.add_header(\"Cache-Control\", \"no-cache\")\n        self.write(\n            \"<code><pre>%s</pre><code>\" % json.dumps(self._server.get_debug(), indent=2)\n        )\n\n\nclass MessageCacheHandler(tornado.web.RequestHandler):\n    \"\"\"Returns ForwardMsgs from our MessageCache\"\"\"\n\n    def initialize(self, cache):\n        \"\"\"Initializes the handler.\n\n        Parameters\n        ----------\n        cache : MessageCache\n\n        \"\"\"\n        self._cache = cache\n\n    def set_default_headers(self):\n        if allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    def get(self):\n        msg_hash = self.get_argument(\"hash\", None)\n        if msg_hash is None:\n            # Hash is missing! This is a malformed request.\n            LOGGER.error(\n                \"HTTP request for cached message is \" \"missing the hash attribute.\"\n            )\n            self.set_status(404)\n            raise tornado.web.Finish()\n\n        message = self._cache.get_message(msg_hash)\n        if message is None:\n            # Message not in our cache.\n            LOGGER.error(\n                \"HTTP request for cached message could not be fulfilled. \"\n                \"No such message: %s\" % msg_hash\n            )\n            self.set_status(404)\n            raise tornado.web.Finish()\n\n        LOGGER.debug(\"MessageCache HIT [hash=%s]\" % msg_hash)\n        msg_str = serialize_forward_msg(message)\n        self.set_header(\"Content-Type\", \"application/octet-stream\")\n        self.write(msg_str)\n        self.set_status(200)\n\n    def options(self):\n        \"\"\"/OPTIONS handler for preflight CORS checks.\"\"\"\n        self.set_status(204)\n        self.finish()\n", "# Copyright 2018-2021 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\nimport unittest\nfrom typing import Any\nfrom unittest import mock\n\nimport pandas as pd\nimport pytest\nimport tornado.testing\nimport tornado.web\n\nfrom streamlit import StreamlitAPIException\nfrom streamlit.components.v1.components import ComponentRegistry\nfrom streamlit.components.v1.components import ComponentRequestHandler\nfrom streamlit.components.v1.components import CustomComponent\nfrom streamlit.components.v1.components import declare_component\nimport streamlit.components.v1 as components\nfrom streamlit.elements import arrow_table\nfrom streamlit.errors import DuplicateWidgetID\nfrom streamlit.proto.ComponentInstance_pb2 import SpecialArg\nfrom streamlit.type_util import to_bytes\nfrom tests import testutil\nfrom tests.testutil import DeltaGeneratorTestCase\n\nURL = \"http://not.a.real.url:3001\"\nPATH = \"not/a/real/path\"\n\n\ndef _serialize_dataframe_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    arrow_table.marshall(special_arg.arrow_dataframe.data, value)\n    return special_arg\n\n\ndef _serialize_bytes_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    special_arg.bytes = to_bytes(value)\n    return special_arg\n\n\nclass DeclareComponentTest(unittest.TestCase):\n    \"\"\"Test component declaration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_name(self):\n        \"\"\"Test component name generation\"\"\"\n        # Test a component defined in a module with no package\n        component = components.declare_component(\"foo\", url=URL)\n        self.assertEqual(\"components_test.foo\", component.name)\n\n        # Test a component defined in __init__.py\n        from component_test_data import component as init_component\n\n        self.assertEqual(\n            \"component_test_data.foo\",\n            init_component.name,\n        )\n\n        # Test a component defined in a module within a package\n        from component_test_data.outer_module import component as outer_module_component\n\n        self.assertEqual(\n            \"component_test_data.outer_module.foo\",\n            outer_module_component.name,\n        )\n\n        # Test a component defined in module within a nested package\n        from component_test_data.nested.inner_module import (\n            component as inner_module_component,\n        )\n\n        self.assertEqual(\n            \"component_test_data.nested.inner_module.foo\",\n            inner_module_component.name,\n        )\n\n    def test_only_path(self):\n        \"\"\"Succeed when a path is provided.\"\"\"\n\n        def isdir(path):\n            return path == PATH or path == os.path.abspath(PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            component = components.declare_component(\"test\", path=PATH)\n\n        self.assertEqual(PATH, component.path)\n        self.assertIsNone(component.url)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(component.name),\n            component.abspath,\n        )\n\n    def test_only_url(self):\n        \"\"\"Succeed when a URL is provided.\"\"\"\n        component = components.declare_component(\"test\", url=URL)\n        self.assertEqual(URL, component.url)\n        self.assertIsNone(component.path)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(\"components_test\"),\n            component.abspath,\n        )\n\n    def test_path_and_url(self):\n        \"\"\"Fail if path AND url are provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=PATH, url=URL)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n    def test_no_path_and_no_url(self):\n        \"\"\"Fail if neither path nor url is provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=None, url=None)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n\nclass ComponentRegistryTest(unittest.TestCase):\n    \"\"\"Test component registration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_register_component_with_path(self):\n        \"\"\"Registering a component should associate it with its path.\"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        def isdir(path):\n            return path == test_path\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(\n                CustomComponent(\"test_component\", path=test_path)\n            )\n\n        self.assertEqual(test_path, registry.get_component_path(\"test_component\"))\n\n    def test_register_component_no_path(self):\n        \"\"\"It's not an error to register a component without a path.\"\"\"\n        registry = ComponentRegistry.instance()\n\n        # Return None when the component hasn't been registered\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n        # And also return None when the component doesn't have a path\n        registry.register_component(\n            CustomComponent(\"test_component\", url=\"http://not.a.url\")\n        )\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n    def test_register_invalid_path(self):\n        \"\"\"We raise an exception if a component is registered with a\n        non-existent path.\n        \"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        registry = ComponentRegistry.instance()\n        with self.assertRaises(StreamlitAPIException) as ctx:\n            registry.register_component(CustomComponent(\"test_component\", test_path))\n            self.assertIn(\"No such component directory\", ctx.exception)\n\n    def test_register_duplicate_path(self):\n        \"\"\"It's not an error to re-register a component.\n        (This can happen during development).\n        \"\"\"\n        test_path_1 = \"/a/test/component/directory\"\n        test_path_2 = \"/another/test/component/directory\"\n\n        def isdir(path):\n            return path in (test_path_1, test_path_2)\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            self.assertEqual(test_path_1, registry.get_component_path(\"test_component\"))\n\n            registry.register_component(CustomComponent(\"test_component\", test_path_2))\n            self.assertEqual(test_path_2, registry.get_component_path(\"test_component\"))\n\n\nclass InvokeComponentTest(DeltaGeneratorTestCase):\n    \"\"\"Test invocation of a custom component object.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.test_component = components.declare_component(\"test\", url=URL)\n\n    def test_only_json_args(self):\n        \"\"\"Test that component with only json args is marshalled correctly.\"\"\"\n        self.test_component(foo=\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"foo\": \"bar\", \"key\": None, \"default\": None}, proto.json_args\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_only_df_args(self):\n        \"\"\"Test that component with only dataframe args is marshalled correctly.\"\"\"\n        raw_data = {\n            \"First Name\": [\"Jason\", \"Molly\"],\n            \"Last Name\": [\"Miller\", \"Jacobson\"],\n            \"Age\": [42, 52],\n        }\n        df = pd.DataFrame(raw_data, columns=[\"First Name\", \"Last Name\", \"Age\"])\n        self.test_component(df=df)\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(1, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df\", df), proto.special_args[0])\n\n    def test_only_list_args(self):\n        \"\"\"Test that component with only list args is marshalled correctly.\"\"\"\n        self.test_component(data=[\"foo\", \"bar\", \"baz\"])\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual(\n            {\"data\": [\"foo\", \"bar\", \"baz\"], \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_no_args(self):\n        \"\"\"Test that component with no args is marshalled correctly.\"\"\"\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_bytes_args(self):\n        self.test_component(foo=b\"foo\", bar=b\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(\n            _serialize_bytes_arg(\"foo\", b\"foo\"),\n            proto.special_args[0],\n        )\n        self.assertEqual(\n            _serialize_bytes_arg(\"bar\", b\"bar\"),\n            proto.special_args[1],\n        )\n\n    def test_mixed_args(self):\n        \"\"\"Test marshalling of a component with varied arg types.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        self.test_component(string_arg=\"string\", df_arg=df, bytes_arg=b\"bytes\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"string_arg\": \"string\", \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df_arg\", df), proto.special_args[0])\n        self.assertEqual(\n            _serialize_bytes_arg(\"bytes_arg\", b\"bytes\"), proto.special_args[1]\n        )\n\n    def test_duplicate_key(self):\n        \"\"\"Two components with the same `key` should throw DuplicateWidgetID exception\"\"\"\n        self.test_component(foo=\"bar\", key=\"baz\")\n\n        with self.assertRaises(DuplicateWidgetID):\n            self.test_component(key=\"baz\")\n\n    def test_key_sent_to_frontend(self):\n        \"\"\"We send the 'key' param to the frontend (even if it's None).\"\"\"\n        # Test a string key\n        self.test_component(key=\"baz\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": \"baz\", \"default\": None}, proto.json_args)\n\n        # Test an empty key\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n\n    def test_simple_default(self):\n        \"\"\"Test the 'default' param with a JSON value.\"\"\"\n        return_value = self.test_component(default=\"baz\")\n        self.assertEqual(\"baz\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": \"baz\"}, proto.json_args)\n\n    def test_bytes_default(self):\n        \"\"\"Test the 'default' param with a bytes value.\"\"\"\n        return_value = self.test_component(default=b\"bytes\")\n        self.assertEqual(b\"bytes\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_bytes_arg(\"default\", b\"bytes\"),\n            proto.special_args[0],\n        )\n\n    def test_df_default(self):\n        \"\"\"Test the 'default' param with a DataFrame value.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        return_value = self.test_component(default=df)\n        self.assertTrue(df.equals(return_value), \"df != return_value\")\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_dataframe_arg(\"default\", df),\n            proto.special_args[0],\n        )\n\n    def assertJSONEqual(self, a, b):\n        \"\"\"Asserts that two JSON dicts are equal. If either arg is a string,\n        it will be first converted to a dict with json.loads().\"\"\"\n        # Ensure both objects are dicts.\n        dict_a = a if isinstance(a, dict) else json.loads(a)\n        dict_b = b if isinstance(b, dict) else json.loads(b)\n        self.assertEqual(dict_a, dict_b)\n\n\nclass ComponentRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):\n    \"\"\"Test /component endpoint.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def get_app(self):\n        self.registry = ComponentRegistry()\n        return tornado.web.Application(\n            [\n                (\n                    \"/component/(.*)\",\n                    ComponentRequestHandler,\n                    dict(registry=self.registry.instance()),\n                )\n            ]\n        )\n\n    def _request_component(self, path):\n        return self.fetch(\"/component/%s\" % path, method=\"GET\")\n\n    def test_success_request(self):\n        \"\"\"Test request success when valid parameters are provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.open\",\n            mock.mock_open(read_data=\"Test Content\"),\n        ):\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(b\"Test Content\", response.body)\n\n    def test_invalid_component_request(self):\n        \"\"\"Test request failure when invalid component name is provided.\"\"\"\n\n        response = self._request_component(\"invalid_component\")\n        self.assertEqual(404, response.code)\n        self.assertEqual(b\"invalid_component not found\", response.body)\n\n    def test_invalid_content_request(self):\n        \"\"\"Test request failure when invalid content (file) is provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.side_effect = OSError(\"Invalid content\")\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(404, response.code)\n        self.assertEqual(\n            b\"components_test.test read error: Invalid content\",\n            response.body,\n        )\n\n    def test_invalid_encoding_request(self):\n        \"\"\"Test request failure when invalid encoded file is provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.side_effect = UnicodeDecodeError(\n                \"utf-8\", b\"\", 9, 11, \"unexpected end of data\"\n            )\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(404, response.code)\n        self.assertEqual(\n            b\"components_test.test read error: 'utf-8' codec can't decode bytes in position 9-10: unexpected end of data\",\n            response.body,\n        )\n\n\nclass IFrameTest(testutil.DeltaGeneratorTestCase):\n    def test_iframe(self):\n        \"\"\"Test components.iframe\"\"\"\n        components.iframe(\"http://not.a.url\", width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"http://not.a.url\")\n        self.assertEqual(el.iframe.srcdoc, \"\")\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n\n    def test_html(self):\n        \"\"\"Test components.html\"\"\"\n        html = r\"<html><body>An HTML string!</body></html>\"\n        components.html(html, width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"\")\n        self.assertEqual(el.iframe.srcdoc, html)\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n"], "fixing_code": ["# Copyright 2018-2021 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport mimetypes\nimport os\nfrom typing import Any, Dict, Optional, Type, Union\nimport threading\nimport inspect\n\nimport tornado.web\n\nimport streamlit.server.routes\nfrom streamlit import type_util\nfrom streamlit import util\nfrom streamlit.errors import StreamlitAPIException\nfrom streamlit.logger import get_logger\nfrom streamlit.proto.ArrowTable_pb2 import ArrowTable as ArrowTableProto\nfrom streamlit.proto.ComponentInstance_pb2 import SpecialArg\nfrom streamlit.proto.Element_pb2 import Element\nfrom streamlit.type_util import to_bytes\nfrom streamlit.widgets import NoValue, register_widget\n\nLOGGER = get_logger(__name__)\n\n\nclass MarshallComponentException(StreamlitAPIException):\n    \"\"\"Class for exceptions generated during custom component marshalling.\"\"\"\n\n    pass\n\n\nclass CustomComponent:\n    \"\"\"A Custom Component declaration.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        path: Optional[str] = None,\n        url: Optional[str] = None,\n    ):\n        if (path is None and url is None) or (path is not None and url is not None):\n            raise StreamlitAPIException(\n                \"Either 'path' or 'url' must be set, but not both.\"\n            )\n\n        self.name = name\n        self.path = path\n        self.url = url\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    @property\n    def abspath(self) -> Optional[str]:\n        \"\"\"The absolute path that the component is served from.\"\"\"\n        if self.path is None:\n            return None\n        return os.path.abspath(self.path)\n\n    def __call__(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"An alias for create_instance.\"\"\"\n        return self.create_instance(*args, default=default, key=key, **kwargs)\n\n    def create_instance(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"Create a new instance of the component.\n\n        Parameters\n        ----------\n        *args\n            Must be empty; all args must be named. (This parameter exists to\n            enforce correct use of the function.)\n        default: any or None\n            The default return value for the component. This is returned when\n            the component's frontend hasn't yet specified a value with\n            `setComponentValue`.\n        key: str or None\n            If not None, this is the user key we use to generate the\n            component's \"widget ID\".\n        **kwargs\n            Keyword args to pass to the component.\n\n        Returns\n        -------\n        any or None\n            The component's widget value.\n\n        \"\"\"\n        if len(args) > 0:\n            raise MarshallComponentException(f\"Argument '{args[0]}' needs a label\")\n\n        try:\n            import pyarrow\n            from streamlit.elements import arrow_table\n        except ImportError:\n            import sys\n\n            if sys.version_info >= (3, 9):\n                raise StreamlitAPIException(\n                    \"\"\"To use Custom Components in Streamlit, you need to install\nPyArrow. Unfortunately, PyArrow does not yet support Python 3.9.\n\nYou can either switch to Python 3.8 with an environment manager like PyEnv, or stay on 3.9 by\n[installing Streamlit with conda](https://discuss.streamlit.io/t/note-installation-issues-with-python-3-9-and-streamlit/6946):\n\n`conda install -c conda-forge streamlit`\n\n\"\"\"\n                )\n            else:\n                raise StreamlitAPIException(\n                    \"\"\"To use Custom Components in Streamlit, you need to install\nPyArrow. To do so locally:\n\n`pip install pyarrow`\n\nAnd if you're using Streamlit Sharing, add \"pyarrow\" to your requirements.txt.\"\"\"\n                )\n\n        # In addition to the custom kwargs passed to the component, we also\n        # send the special 'default' and 'key' params to the component\n        # frontend.\n        all_args = dict(kwargs, **{\"default\": default, \"key\": key})\n\n        json_args = {}\n        special_args = []\n        for arg_name, arg_val in all_args.items():\n            if type_util.is_bytes_like(arg_val):\n                bytes_arg = SpecialArg()\n                bytes_arg.key = arg_name\n                bytes_arg.bytes = to_bytes(arg_val)\n                special_args.append(bytes_arg)\n            elif type_util.is_dataframe_like(arg_val):\n                dataframe_arg = SpecialArg()\n                dataframe_arg.key = arg_name\n                arrow_table.marshall(dataframe_arg.arrow_dataframe.data, arg_val)\n                special_args.append(dataframe_arg)\n            else:\n                json_args[arg_name] = arg_val\n\n        try:\n            serialized_json_args = json.dumps(json_args)\n        except BaseException as e:\n            raise MarshallComponentException(\n                \"Could not convert component args to JSON\", e\n            )\n\n        def marshall_component(element: Element) -> Union[Any, Type[NoValue]]:\n            element.component_instance.component_name = self.name\n            if self.url is not None:\n                element.component_instance.url = self.url\n\n            # Normally, a widget's element_hash (which determines\n            # its identity across multiple runs of an app) is computed\n            # by hashing the entirety of its protobuf. This means that,\n            # if any of the arguments to the widget are changed, Streamlit\n            # considers it a new widget instance and it loses its previous\n            # state.\n            #\n            # However! If a *component* has a `key` argument, then the\n            # component's hash identity is determined by entirely by\n            # `component_name + url + key`. This means that, when `key`\n            # exists, the component will maintain its identity even when its\n            # other arguments change, and the component's iframe won't be\n            # remounted on the frontend.\n            #\n            # So: if `key` is None, we marshall the element's arguments\n            # *before* computing its widget_ui_value (which creates its hash).\n            # If `key` is not None, we marshall the arguments *after*.\n\n            def marshall_element_args():\n                element.component_instance.json_args = serialized_json_args\n                element.component_instance.special_args.extend(special_args)\n\n            if key is None:\n                marshall_element_args()\n\n            widget_value = register_widget(\n                element_type=\"component_instance\",\n                element_proto=element.component_instance,\n                user_key=key,\n                widget_func_name=self.name,\n            )\n\n            if key is not None:\n                marshall_element_args()\n\n            if widget_value is None:\n                widget_value = default\n            elif isinstance(widget_value, ArrowTableProto):\n                widget_value = arrow_table.arrow_proto_to_dataframe(widget_value)\n\n            # widget_value will be either None or whatever the component's most\n            # recent setWidgetValue value is. We coerce None -> NoValue,\n            # because that's what DeltaGenerator._enqueue expects.\n            return widget_value if widget_value is not None else NoValue\n\n        # We currently only support writing to st._main, but this will change\n        # when we settle on an improved API in a post-layout world.\n        element = Element()\n        return_value = marshall_component(element)\n        result = streamlit._main._enqueue(\n            \"component_instance\", element.component_instance, return_value\n        )\n\n        return result\n\n    def __eq__(self, other) -> bool:\n        \"\"\"Equality operator.\"\"\"\n        return (\n            isinstance(other, CustomComponent)\n            and self.name == other.name\n            and self.path == other.path\n            and self.url == other.url\n        )\n\n    def __ne__(self, other) -> bool:\n        \"\"\"Inequality operator.\"\"\"\n        return not self == other\n\n    def __str__(self) -> str:\n        return f\"'{self.name}': {self.path if self.path is not None else self.url}\"\n\n\ndef declare_component(\n    name: str,\n    path: Optional[str] = None,\n    url: Optional[str] = None,\n) -> CustomComponent:\n    \"\"\"Create and register a custom component.\n\n    Parameters\n    ----------\n    name: str\n        A short, descriptive name for the component. Like, \"slider\".\n    path: str or None\n        The path to serve the component's frontend files from. Either\n        `path` or `url` must be specified, but not both.\n    url: str or None\n        The URL that the component is served from. Either `path` or `url`\n        must be specified, but not both.\n\n    Returns\n    -------\n    CustomComponent\n        A CustomComponent that can be called like a function.\n        Calling the component will create a new instance of the component\n        in the Streamlit app.\n\n    \"\"\"\n\n    # Get our stack frame.\n    current_frame = inspect.currentframe()\n    assert current_frame is not None\n\n    # Get the stack frame of our calling function.\n    caller_frame = current_frame.f_back\n    assert caller_frame is not None\n\n    # Get the caller's module name. `__name__` gives us the module's\n    # fully-qualified name, which includes its package.\n    module = inspect.getmodule(caller_frame)\n    assert module is not None\n    module_name = module.__name__\n\n    # If the caller was the main module that was executed (that is, if the\n    # user executed `python my_component.py`), then this name will be\n    # \"__main__\" instead of the actual package name. In this case, we use\n    # the main module's filename, sans `.py` extension, as the component name.\n    if module_name == \"__main__\":\n        file_path = inspect.getfile(caller_frame)\n        filename = os.path.basename(file_path)\n        module_name, _ = os.path.splitext(filename)\n\n    # Build the component name.\n    component_name = f\"{module_name}.{name}\"\n\n    # Create our component object, and register it.\n    component = CustomComponent(name=component_name, path=path, url=url)\n    ComponentRegistry.instance().register_component(component)\n\n    return component\n\n\nclass ComponentRequestHandler(tornado.web.RequestHandler):\n    def initialize(self, registry: \"ComponentRegistry\"):\n        self._registry = registry\n\n    def get(self, path: str) -> None:\n        parts = path.split(\"/\")\n        component_name = parts[0]\n        component_root = self._registry.get_component_path(component_name)\n        if component_root is None:\n            self.write(\"not found\")\n            self.set_status(404)\n            return\n\n        filename = \"/\".join(parts[1:])\n        abspath = os.path.join(component_root, filename)\n\n        LOGGER.debug(\"ComponentRequestHandler: GET: %s -> %s\", path, abspath)\n\n        try:\n            with open(abspath, \"r\", encoding=\"utf-8\") as file:\n                contents = file.read()\n        except (OSError, UnicodeDecodeError) as e:\n            LOGGER.error(f\"ComponentRequestHandler: GET {path} read error\", exc_info=e)\n            self.write(\"read error\")\n            self.set_status(404)\n            return\n\n        self.write(contents)\n        self.set_header(\"Content-Type\", self.get_content_type(abspath))\n\n        self.set_extra_headers(path)\n\n    def set_extra_headers(self, path) -> None:\n        \"\"\"Disable cache for HTML files.\n\n        Other assets like JS and CSS are suffixed with their hash, so they can\n        be cached indefinitely.\n        \"\"\"\n        is_index_url = len(path) == 0\n\n        if is_index_url or path.endswith(\".html\"):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n        else:\n            self.set_header(\"Cache-Control\", \"public\")\n\n    def set_default_headers(self) -> None:\n        if streamlit.server.routes.allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    def options(self) -> None:\n        \"\"\"/OPTIONS handler for preflight CORS checks.\"\"\"\n        self.set_status(204)\n        self.finish()\n\n    @staticmethod\n    def get_content_type(abspath) -> str:\n        \"\"\"Returns the ``Content-Type`` header to be used for this request.\n        From tornado.web.StaticFileHandler.\n        \"\"\"\n        mime_type, encoding = mimetypes.guess_type(abspath)\n        # per RFC 6713, use the appropriate type for a gzip compressed file\n        if encoding == \"gzip\":\n            return \"application/gzip\"\n        # As of 2015-07-21 there is no bzip2 encoding defined at\n        # http://www.iana.org/assignments/media-types/media-types.xhtml\n        # So for that (and any other encoding), use octet-stream.\n        elif encoding is not None:\n            return \"application/octet-stream\"\n        elif mime_type is not None:\n            return mime_type\n        # if mime_type not detected, use application/octet-stream\n        else:\n            return \"application/octet-stream\"\n\n    @staticmethod\n    def get_url(file_id: str) -> str:\n        \"\"\"Return the URL for a component file with the given ID.\"\"\"\n        return \"components/{}\".format(file_id)\n\n\nclass ComponentRegistry:\n    _instance_lock = threading.Lock()\n    _instance = None  # type: Optional[ComponentRegistry]\n\n    @classmethod\n    def instance(cls) -> \"ComponentRegistry\":\n        \"\"\"Returns the singleton ComponentRegistry\"\"\"\n        # We use a double-checked locking optimization to avoid the overhead\n        # of acquiring the lock in the common case:\n        # https://en.wikipedia.org/wiki/Double-checked_locking\n        if cls._instance is None:\n            with cls._instance_lock:\n                if cls._instance is None:\n                    cls._instance = ComponentRegistry()\n        return cls._instance\n\n    def __init__(self):\n        self._components = {}  # type: Dict[str, CustomComponent]\n        self._lock = threading.Lock()\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    def register_component(self, component: CustomComponent) -> None:\n        \"\"\"Register a CustomComponent.\n\n        Parameters\n        ----------\n        component : CustomComponent\n            The component to register.\n        \"\"\"\n\n        # Validate the component's path\n        abspath = component.abspath\n        if abspath is not None and not os.path.isdir(abspath):\n            raise StreamlitAPIException(f\"No such component directory: '{abspath}'\")\n\n        with self._lock:\n            existing = self._components.get(component.name)\n            self._components[component.name] = component\n\n        if existing is not None and component != existing:\n            LOGGER.warning(\n                \"%s overriding previously-registered %s\",\n                component,\n                existing,\n            )\n\n        LOGGER.debug(\"Registered component %s\", component)\n\n    def get_component_path(self, name: str) -> Optional[str]:\n        \"\"\"Return the filesystem path for the component with the given name.\n\n        If no such component is registered, or if the component exists but is\n        being served from a URL, return None instead.\n        \"\"\"\n        component = self._components.get(name, None)\n        return component.abspath if component is not None else None\n", "# Copyright 2018-2021 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\n\nimport tornado.web\n\nfrom streamlit import config\nfrom streamlit import metrics\nfrom streamlit.logger import get_logger\nfrom streamlit.server.server_util import serialize_forward_msg\nfrom streamlit.media_file_manager import media_file_manager\n\n\nLOGGER = get_logger(__name__)\n\n\ndef allow_cross_origin_requests():\n    \"\"\"True if cross-origin requests are allowed.\n\n    We only allow cross-origin requests when CORS protection has been disabled\n    with server.enableCORS=False or if using the Node server. When using the\n    Node server, we have a dev and prod port, which count as two origins.\n\n    \"\"\"\n    return not config.get_option(\"server.enableCORS\") or config.get_option(\n        \"global.developmentMode\"\n    )\n\n\nclass StaticFileHandler(tornado.web.StaticFileHandler):\n    def set_extra_headers(self, path):\n        \"\"\"Disable cache for HTML files.\n\n        Other assets like JS and CSS are suffixed with their hash, so they can\n        be cached indefinitely.\n        \"\"\"\n        is_index_url = len(path) == 0\n\n        if is_index_url or path.endswith(\".html\"):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n        else:\n            self.set_header(\"Cache-Control\", \"public\")\n\n\nclass AssetsFileHandler(tornado.web.StaticFileHandler):\n    # CORS protection should be disabled as we need access\n    # to this endpoint from the inner iframe.\n    def set_default_headers(self):\n        self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n\nclass AddSlashHandler(tornado.web.RequestHandler):\n    @tornado.web.addslash\n    def get(self):\n        pass\n\n\nclass MediaFileHandler(tornado.web.StaticFileHandler):\n    def set_default_headers(self):\n        if allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    # Overriding StaticFileHandler to use the MediaFileManager\n    #\n    # From the Torndado docs:\n    # To replace all interaction with the filesystem (e.g. to serve\n    # static content from a database), override `get_content`,\n    # `get_content_size`, `get_modified_time`, `get_absolute_path`, and\n    # `validate_absolute_path`.\n    def validate_absolute_path(self, root, absolute_path):\n        try:\n            media_file_manager.get(absolute_path)\n        except KeyError:\n            LOGGER.error(\"MediaFileManager: Missing file %s\" % absolute_path)\n            raise tornado.web.HTTPError(404, \"not found\")\n\n        return absolute_path\n\n    def get_content_size(self):\n        media = media_file_manager.get(self.absolute_path)\n        return media.content_size\n\n    def get_modified_time(self):\n        # We do not track last modified time, but this can be improved to\n        # allow caching among files in the MediaFileManager\n        return None\n\n    @classmethod\n    def get_absolute_path(cls, root, path):\n        # All files are stored in memory, so the absolute path is just the\n        # path itself. In the MediaFileHandler, it's just the filename\n        return path\n\n    @classmethod\n    def get_content(cls, abspath, start=None, end=None):\n        LOGGER.debug(\"MediaFileHandler: GET %s\" % abspath)\n\n        try:\n            # abspath is the hash as used `get_absolute_path`\n            media = media_file_manager.get(abspath)\n        except:\n            LOGGER.error(\"MediaFileManager: Missing file %s\" % abspath)\n            return\n\n        LOGGER.debug(\"MediaFileManager: Sending %s file %s\" % (media.mimetype, abspath))\n\n        # If there is no start and end, just return the full content\n        if start is None and end is None:\n            return media.content\n\n        if start is None:\n            start = 0\n        if end is None:\n            end = len(media.content)\n\n        # content is bytes that work just by slicing supplied by start and end\n        return media.content[start:end]\n\n\nclass _SpecialRequestHandler(tornado.web.RequestHandler):\n    \"\"\"Superclass for \"special\" endpoints, like /healthz.\"\"\"\n\n    def set_default_headers(self):\n        self.set_header(\"Cache-Control\", \"no-cache\")\n        if allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    def options(self):\n        \"\"\"/OPTIONS handler for preflight CORS checks.\n\n        When a browser is making a CORS request, it may sometimes first\n        send an OPTIONS request, to check whether the server understands the\n        CORS protocol. This is optional, and doesn't happen for every request\n        or in every browser. If an OPTIONS request does get sent, and is not\n        then handled by the server, the browser will fail the underlying\n        request.\n\n        The proper way to handle this is to send a 204 response (\"no content\")\n        with the CORS headers attached. (These headers are automatically added\n        to every outgoing response, including OPTIONS responses,\n        via set_default_headers().)\n\n        See https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request\n        \"\"\"\n        self.set_status(204)\n        self.finish()\n\n\nclass HealthHandler(_SpecialRequestHandler):\n    def initialize(self, callback):\n        \"\"\"Initialize the handler\n\n        Parameters\n        ----------\n        callback : callable\n            A function that returns True if the server is healthy\n\n        \"\"\"\n        self._callback = callback\n\n    def get(self):\n        if self._callback():\n            self.write(\"ok\")\n            self.set_status(200)\n\n            # Tornado will set the _xsrf cookie automatically for the page on\n            # request for the document. However, if the server is reset and\n            # server.enableXsrfProtection is updated, the browser does not reload the document.\n            # Manually setting the cookie on /healthz since it is pinged when the\n            # browser is disconnected from the server.\n            if config.get_option(\"server.enableXsrfProtection\"):\n                self.set_cookie(\"_xsrf\", self.xsrf_token)\n\n        else:\n            # 503 = SERVICE_UNAVAILABLE\n            self.set_status(503)\n            self.write(\"unavailable\")\n\n\nclass MetricsHandler(_SpecialRequestHandler):\n    def get(self):\n        if config.get_option(\"global.metrics\"):\n            self.add_header(\"Cache-Control\", \"no-cache\")\n            self.set_header(\"Content-Type\", \"text/plain\")\n            self.write(metrics.Client.get_current().generate_latest())\n        else:\n            self.set_status(404)\n            raise tornado.web.Finish()\n\n\nclass DebugHandler(_SpecialRequestHandler):\n    def initialize(self, server):\n        self._server = server\n\n    def get(self):\n        self.add_header(\"Cache-Control\", \"no-cache\")\n        self.write(\n            \"<code><pre>%s</pre><code>\" % json.dumps(self._server.get_debug(), indent=2)\n        )\n\n\nclass MessageCacheHandler(tornado.web.RequestHandler):\n    \"\"\"Returns ForwardMsgs from our MessageCache\"\"\"\n\n    def initialize(self, cache):\n        \"\"\"Initializes the handler.\n\n        Parameters\n        ----------\n        cache : MessageCache\n\n        \"\"\"\n        self._cache = cache\n\n    def set_default_headers(self):\n        if allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    def get(self):\n        msg_hash = self.get_argument(\"hash\", None)\n        if msg_hash is None:\n            # Hash is missing! This is a malformed request.\n            LOGGER.error(\n                \"HTTP request for cached message is \" \"missing the hash attribute.\"\n            )\n            self.set_status(404)\n            raise tornado.web.Finish()\n\n        message = self._cache.get_message(msg_hash)\n        if message is None:\n            # Message not in our cache.\n            LOGGER.error(\n                \"HTTP request for cached message could not be fulfilled. \"\n                \"No such message: %s\" % msg_hash\n            )\n            self.set_status(404)\n            raise tornado.web.Finish()\n\n        LOGGER.debug(\"MessageCache HIT [hash=%s]\" % msg_hash)\n        msg_str = serialize_forward_msg(message)\n        self.set_header(\"Content-Type\", \"application/octet-stream\")\n        self.write(msg_str)\n        self.set_status(200)\n\n    def options(self):\n        \"\"\"/OPTIONS handler for preflight CORS checks.\"\"\"\n        self.set_status(204)\n        self.finish()\n", "# Copyright 2018-2021 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\nimport unittest\nfrom typing import Any\nfrom unittest import mock\n\nimport pandas as pd\nimport pytest\nimport tornado.testing\nimport tornado.web\n\nfrom streamlit import StreamlitAPIException\nfrom streamlit.components.v1.components import ComponentRegistry\nfrom streamlit.components.v1.components import ComponentRequestHandler\nfrom streamlit.components.v1.components import CustomComponent\nfrom streamlit.components.v1.components import declare_component\nimport streamlit.components.v1 as components\nfrom streamlit.elements import arrow_table\nfrom streamlit.errors import DuplicateWidgetID\nfrom streamlit.proto.ComponentInstance_pb2 import SpecialArg\nfrom streamlit.type_util import to_bytes\nfrom tests import testutil\nfrom tests.testutil import DeltaGeneratorTestCase\n\nURL = \"http://not.a.real.url:3001\"\nPATH = \"not/a/real/path\"\n\n\ndef _serialize_dataframe_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    arrow_table.marshall(special_arg.arrow_dataframe.data, value)\n    return special_arg\n\n\ndef _serialize_bytes_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    special_arg.bytes = to_bytes(value)\n    return special_arg\n\n\nclass DeclareComponentTest(unittest.TestCase):\n    \"\"\"Test component declaration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_name(self):\n        \"\"\"Test component name generation\"\"\"\n        # Test a component defined in a module with no package\n        component = components.declare_component(\"foo\", url=URL)\n        self.assertEqual(\"components_test.foo\", component.name)\n\n        # Test a component defined in __init__.py\n        from component_test_data import component as init_component\n\n        self.assertEqual(\n            \"component_test_data.foo\",\n            init_component.name,\n        )\n\n        # Test a component defined in a module within a package\n        from component_test_data.outer_module import component as outer_module_component\n\n        self.assertEqual(\n            \"component_test_data.outer_module.foo\",\n            outer_module_component.name,\n        )\n\n        # Test a component defined in module within a nested package\n        from component_test_data.nested.inner_module import (\n            component as inner_module_component,\n        )\n\n        self.assertEqual(\n            \"component_test_data.nested.inner_module.foo\",\n            inner_module_component.name,\n        )\n\n    def test_only_path(self):\n        \"\"\"Succeed when a path is provided.\"\"\"\n\n        def isdir(path):\n            return path == PATH or path == os.path.abspath(PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            component = components.declare_component(\"test\", path=PATH)\n\n        self.assertEqual(PATH, component.path)\n        self.assertIsNone(component.url)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(component.name),\n            component.abspath,\n        )\n\n    def test_only_url(self):\n        \"\"\"Succeed when a URL is provided.\"\"\"\n        component = components.declare_component(\"test\", url=URL)\n        self.assertEqual(URL, component.url)\n        self.assertIsNone(component.path)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(\"components_test\"),\n            component.abspath,\n        )\n\n    def test_path_and_url(self):\n        \"\"\"Fail if path AND url are provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=PATH, url=URL)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n    def test_no_path_and_no_url(self):\n        \"\"\"Fail if neither path nor url is provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=None, url=None)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n\nclass ComponentRegistryTest(unittest.TestCase):\n    \"\"\"Test component registration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_register_component_with_path(self):\n        \"\"\"Registering a component should associate it with its path.\"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        def isdir(path):\n            return path == test_path\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(\n                CustomComponent(\"test_component\", path=test_path)\n            )\n\n        self.assertEqual(test_path, registry.get_component_path(\"test_component\"))\n\n    def test_register_component_no_path(self):\n        \"\"\"It's not an error to register a component without a path.\"\"\"\n        registry = ComponentRegistry.instance()\n\n        # Return None when the component hasn't been registered\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n        # And also return None when the component doesn't have a path\n        registry.register_component(\n            CustomComponent(\"test_component\", url=\"http://not.a.url\")\n        )\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n    def test_register_invalid_path(self):\n        \"\"\"We raise an exception if a component is registered with a\n        non-existent path.\n        \"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        registry = ComponentRegistry.instance()\n        with self.assertRaises(StreamlitAPIException) as ctx:\n            registry.register_component(CustomComponent(\"test_component\", test_path))\n            self.assertIn(\"No such component directory\", ctx.exception)\n\n    def test_register_duplicate_path(self):\n        \"\"\"It's not an error to re-register a component.\n        (This can happen during development).\n        \"\"\"\n        test_path_1 = \"/a/test/component/directory\"\n        test_path_2 = \"/another/test/component/directory\"\n\n        def isdir(path):\n            return path in (test_path_1, test_path_2)\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            self.assertEqual(test_path_1, registry.get_component_path(\"test_component\"))\n\n            registry.register_component(CustomComponent(\"test_component\", test_path_2))\n            self.assertEqual(test_path_2, registry.get_component_path(\"test_component\"))\n\n\nclass InvokeComponentTest(DeltaGeneratorTestCase):\n    \"\"\"Test invocation of a custom component object.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.test_component = components.declare_component(\"test\", url=URL)\n\n    def test_only_json_args(self):\n        \"\"\"Test that component with only json args is marshalled correctly.\"\"\"\n        self.test_component(foo=\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"foo\": \"bar\", \"key\": None, \"default\": None}, proto.json_args\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_only_df_args(self):\n        \"\"\"Test that component with only dataframe args is marshalled correctly.\"\"\"\n        raw_data = {\n            \"First Name\": [\"Jason\", \"Molly\"],\n            \"Last Name\": [\"Miller\", \"Jacobson\"],\n            \"Age\": [42, 52],\n        }\n        df = pd.DataFrame(raw_data, columns=[\"First Name\", \"Last Name\", \"Age\"])\n        self.test_component(df=df)\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(1, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df\", df), proto.special_args[0])\n\n    def test_only_list_args(self):\n        \"\"\"Test that component with only list args is marshalled correctly.\"\"\"\n        self.test_component(data=[\"foo\", \"bar\", \"baz\"])\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual(\n            {\"data\": [\"foo\", \"bar\", \"baz\"], \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_no_args(self):\n        \"\"\"Test that component with no args is marshalled correctly.\"\"\"\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_bytes_args(self):\n        self.test_component(foo=b\"foo\", bar=b\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(\n            _serialize_bytes_arg(\"foo\", b\"foo\"),\n            proto.special_args[0],\n        )\n        self.assertEqual(\n            _serialize_bytes_arg(\"bar\", b\"bar\"),\n            proto.special_args[1],\n        )\n\n    def test_mixed_args(self):\n        \"\"\"Test marshalling of a component with varied arg types.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        self.test_component(string_arg=\"string\", df_arg=df, bytes_arg=b\"bytes\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"string_arg\": \"string\", \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df_arg\", df), proto.special_args[0])\n        self.assertEqual(\n            _serialize_bytes_arg(\"bytes_arg\", b\"bytes\"), proto.special_args[1]\n        )\n\n    def test_duplicate_key(self):\n        \"\"\"Two components with the same `key` should throw DuplicateWidgetID exception\"\"\"\n        self.test_component(foo=\"bar\", key=\"baz\")\n\n        with self.assertRaises(DuplicateWidgetID):\n            self.test_component(key=\"baz\")\n\n    def test_key_sent_to_frontend(self):\n        \"\"\"We send the 'key' param to the frontend (even if it's None).\"\"\"\n        # Test a string key\n        self.test_component(key=\"baz\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": \"baz\", \"default\": None}, proto.json_args)\n\n        # Test an empty key\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n\n    def test_simple_default(self):\n        \"\"\"Test the 'default' param with a JSON value.\"\"\"\n        return_value = self.test_component(default=\"baz\")\n        self.assertEqual(\"baz\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": \"baz\"}, proto.json_args)\n\n    def test_bytes_default(self):\n        \"\"\"Test the 'default' param with a bytes value.\"\"\"\n        return_value = self.test_component(default=b\"bytes\")\n        self.assertEqual(b\"bytes\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_bytes_arg(\"default\", b\"bytes\"),\n            proto.special_args[0],\n        )\n\n    def test_df_default(self):\n        \"\"\"Test the 'default' param with a DataFrame value.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        return_value = self.test_component(default=df)\n        self.assertTrue(df.equals(return_value), \"df != return_value\")\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_dataframe_arg(\"default\", df),\n            proto.special_args[0],\n        )\n\n    def assertJSONEqual(self, a, b):\n        \"\"\"Asserts that two JSON dicts are equal. If either arg is a string,\n        it will be first converted to a dict with json.loads().\"\"\"\n        # Ensure both objects are dicts.\n        dict_a = a if isinstance(a, dict) else json.loads(a)\n        dict_b = b if isinstance(b, dict) else json.loads(b)\n        self.assertEqual(dict_a, dict_b)\n\n\nclass ComponentRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):\n    \"\"\"Test /component endpoint.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def get_app(self):\n        self.registry = ComponentRegistry()\n        return tornado.web.Application(\n            [\n                (\n                    \"/component/(.*)\",\n                    ComponentRequestHandler,\n                    dict(registry=self.registry.instance()),\n                )\n            ]\n        )\n\n    def _request_component(self, path):\n        return self.fetch(\"/component/%s\" % path, method=\"GET\")\n\n    def test_success_request(self):\n        \"\"\"Test request success when valid parameters are provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.open\",\n            mock.mock_open(read_data=\"Test Content\"),\n        ):\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(b\"Test Content\", response.body)\n\n    def test_invalid_component_request(self):\n        \"\"\"Test request failure when invalid component name is provided.\"\"\"\n\n        response = self._request_component(\"invalid_component\")\n        self.assertEqual(404, response.code)\n        self.assertEqual(b\"not found\", response.body)\n\n    def test_invalid_content_request(self):\n        \"\"\"Test request failure when invalid content (file) is provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.side_effect = OSError(\"Invalid content\")\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(404, response.code)\n        self.assertEqual(\n            b\"read error\",\n            response.body,\n        )\n\n    def test_invalid_encoding_request(self):\n        \"\"\"Test request failure when invalid encoded file is provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.side_effect = UnicodeDecodeError(\n                \"utf-8\", b\"\", 9, 11, \"unexpected end of data\"\n            )\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(404, response.code)\n        self.assertEqual(\n            b\"read error\",\n            response.body,\n        )\n\n\nclass IFrameTest(testutil.DeltaGeneratorTestCase):\n    def test_iframe(self):\n        \"\"\"Test components.iframe\"\"\"\n        components.iframe(\"http://not.a.url\", width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"http://not.a.url\")\n        self.assertEqual(el.iframe.srcdoc, \"\")\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n\n    def test_html(self):\n        \"\"\"Test components.html\"\"\"\n        html = r\"<html><body>An HTML string!</body></html>\"\n        components.html(html, width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"\")\n        self.assertEqual(el.iframe.srcdoc, html)\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n"], "filenames": ["lib/streamlit/components/v1/components.py", "lib/streamlit/server/routes.py", "lib/tests/streamlit/components_test.py"], "buggy_code_start_loc": [317, 87, 414], "buggy_code_end_loc": [331, 88, 447], "fixing_code_start_loc": [317, 87, 414], "fixing_code_end_loc": [332, 88, 447], "type": "CWE-79", "message": "Streamlit, software for turning data scripts into web applications, had a cross-site scripting (XSS) vulnerability in versions 0.63.0 through 0.80.0. Users of hosted Streamlit app(s) were vulnerable to a reflected XSS vulnerability. An attacker could craft a malicious URL with Javascript payloads to a Streamlit app. The attacker could then trick the user into visiting the malicious URL and, if successful, the server would render the malicious javascript payload as-is, leading to XSS. Version 0.81.0 contains a patch for this vulnerability.", "other": {"cve": {"id": "CVE-2023-27494", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-16T21:15:13.270", "lastModified": "2023-03-23T18:21:46.700", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Streamlit, software for turning data scripts into web applications, had a cross-site scripting (XSS) vulnerability in versions 0.63.0 through 0.80.0. Users of hosted Streamlit app(s) were vulnerable to a reflected XSS vulnerability. An attacker could craft a malicious URL with Javascript payloads to a Streamlit app. The attacker could then trick the user into visiting the malicious URL and, if successful, the server would render the malicious javascript payload as-is, leading to XSS. Version 0.81.0 contains a patch for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:streamlit:streamlit:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.63.0", "versionEndExcluding": "0.81.0", "matchCriteriaId": "6812252B-AD74-44D5-A5EE-D32005DB5467"}]}]}], "references": [{"url": "https://github.com/streamlit/streamlit/commit/afcf880c60e5d7538936cc2d9721b9e1bc02b075", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/streamlit/streamlit/security/advisories/GHSA-9c6g-qpgj-rvxw", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/streamlit/streamlit/commit/afcf880c60e5d7538936cc2d9721b9e1bc02b075"}}