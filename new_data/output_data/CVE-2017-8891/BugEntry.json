{"buggy_code": ["/* -*-mode:c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/**\nCopyright (c) 2006...2016, Matthias Stirner and HTW Aalen University\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **/\n\n/*\nThis file contains special classes for bitwise\nreading and writing of arrays\n*/\n#include \"../../vp8/util/memory.hh\"\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <algorithm>\n#include <assert.h>\n#include \"bitops.hh\"\n\n#define BUFFER_SIZE 1024 * 1024\n/* -----------------------------------------------\n\tconstructor for abitreader class\n\t----------------------------------------------- */\t\n\nabitreader::abitreader( unsigned char* array, int size )\n{\n    cbyte2 = 0;\n    cbit2 = 0;\n    data2 = array;\n\teof = false;\n\tlbyte = size;\n    buf = 0;\n}\n\n/* -----------------------------------------------\n\tdestructor for abitreader class\n\t----------------------------------------------- */\t\n\nabitreader::~abitreader( void )\n{\n}\n\n\n\n/* -----------------------------------------------\n\tconstructor for abitwriter class\n\t----------------------------------------------- */\t\n\nabitwriter::abitwriter( int size , int max_file_size)\n{\n    size_bound = max_file_size;\n    if (size_bound) {\n        size_bound += 8; // 64 bits of padding on the end\n    }\n    fillbit = 1;\n    adds    = 65536;\n    cbyte2   = 0;\n    cbit2    = 64;\n    buf = 0;\n\n    error = false;\n    fmem  = true;\n    dsize = ( size > 0 ) ? size : adds;\n    data2 = ( unsigned char* ) custom_calloc (dsize);\n    if ( data2 == NULL ) {\n        error = true;\n        custom_exit(ExitCode::MALLOCED_NULL);\n        return;\n    }\n\t// for ( int i = 0; i < dsize; i++ ) data[i] = 0;\n}\n\n/* -----------------------------------------------\n\tdestructor for abitwriter class\n\t----------------------------------------------- */\t\n\nabitwriter::~abitwriter( void )\n{\n\t// free memory if pointer was not given out\n    if ( fmem )\tcustom_free( data2 );\n}\n\n\nvoid aligned_dealloc(unsigned char *data) {\n    if (!data) return;\n    data -= data[-1];\n    custom_free(data);\n}\nunsigned char *aligned_alloc(size_t dsize) {\n    unsigned char*data = (unsigned char*) custom_malloc( dsize + 16);\n    if (data) {\n        size_t rem = (size_t)(data - 0) & 0xf;\n        if (rem) {\n            data += rem;\n            data[-1] = rem;\n        } else {\n            data += 0x10;\n            data[-1] = 0x10;\n        }\n    }\n    return data;\n}\n/* -----------------------------------------------\n\tconstructor for abytewriter class\n\t----------------------------------------------- */\t\n\nabytewriter::abytewriter( int size )\n{\n\tadds  = 65536;\n\tcbyte = 0;\n\t\n\terror = false;\n\tfmem  = true;\n\t\n\tdsize = ( size > 0 ) ? size : adds;\n    data = aligned_alloc(dsize);\n\tif ( data == NULL ) {\n\t\terror = true;\n        custom_exit(ExitCode::MALLOCED_NULL);\n\t\treturn;\n\t}\n}\n\n/* -----------------------------------------------\n\tdestructor for abytewriter class\n\t----------------------------------------------- */\t\n\nabytewriter::~abytewriter( void )\n{\n\t// free data if pointer is not read\n\tif (fmem && data) aligned_dealloc(data);\n}\n\n/* -----------------------------------------------\n\twrites 1 byte to abytewriter\n\t----------------------------------------------- */\t\n\nvoid abytewriter::write( unsigned char byte )\n{\n\t// safety check for error\n\tif ( error ) return;\n\t\n\t// test if pointer beyond flush threshold\n\tif ( cbyte >= ( dsize - 2 ) ) {\n        if (data) {\n            unsigned char * newData = aligned_alloc(dsize *  2);\n            memcpy(newData, data, dsize);\n            dsize *= 2;\n            aligned_dealloc(data);\n            data = newData;\n        }\n\t\tif ( data == NULL ) {\n\t\t\terror = true;\n            custom_exit(ExitCode::MALLOCED_NULL);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t// write data\n\tdata[ cbyte++ ] = byte;\n}\n\n/* -----------------------------------------------\n\twrites n byte to abytewriter\n\t----------------------------------------------- */\n\nvoid abytewriter::write_n( unsigned char* byte, int n )\n{\n\t// safety check for error\n\tif ( error ) return;\n\n\t// make sure that pointer doesn't get beyond flush threshold\n\twhile ( ( cbyte + n ) >= ( dsize - 2 ) ) {\n        unsigned char * newData = aligned_alloc(dsize *  2);\n        memcpy(newData, data, dsize);\n        dsize *= 2;\n        aligned_dealloc(data);\n        data = newData;\n\t\tif ( data == NULL ) {\n            error = true;\n            custom_exit(ExitCode::MALLOCED_NULL);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// copy data from array\n\twhile ( n-- > 0 )\n\t\tdata[ cbyte++ ] = *(byte++);\n}\n\n/* -----------------------------------------------\n\tgets data array from abytewriter\n\t----------------------------------------------- */\n\nunsigned char* abytewriter::getptr_aligned( void )\n{\n\t// forbid freeing memory\n\tfmem = false;\n\treturn data;\n}\n\n/* -----------------------------------------------\n\tpeeks into data array from abytewriter\n\t----------------------------------------------- */\n\t\nunsigned char* abytewriter::peekptr_aligned( void )\n{\n\treturn data;\n}\n\n/* -----------------------------------------------\n\tgets size of data array from abytewriter\n\t----------------------------------------------- */\t\n\nint abytewriter::getpos( void )\n{\n\treturn cbyte;\n}\n\n/* -----------------------------------------------\n\treset without realloc\n\t----------------------------------------------- */\t\n\t\nvoid abytewriter::reset( void )\n{\n\t// set position of current byte\n\tcbyte = 0;\n}\n\n\n/* -----------------------------------------------\n\tconstructor for abytewriter class\n\t----------------------------------------------- */\n\nabytereader::abytereader( unsigned char* array, int size )\n{\n\tcbyte = 0;\n\teof = false;\n\t\n\tdata = array;\n\tlbyte = size;\n\t\n\tif ( ( data == NULL ) || ( lbyte == 0 ) )\n\t\teof = true;\n}\n\n/* -----------------------------------------------\n\tdestructor for abytewriter class\n\t----------------------------------------------- */\n\nabytereader::~abytereader( void )\n{\n}\n\n/* -----------------------------------------------\n\treads 1 byte from abytereader\n\t----------------------------------------------- */\n\nint abytereader::read( unsigned char* byte )\n{\n\tif ( cbyte >= lbyte ) {\n\t\tcbyte = lbyte;\n\t\teof = true;\n\t\treturn 0;\n\t}\n\telse {\n\t\t*byte = data[ cbyte++ ];\n\t\treturn 1;\n\t}\n}\n\n/* -----------------------------------------------\n\treads n bytes from abytereader\n\t----------------------------------------------- */\n\t\nint abytereader::read_n( unsigned char* byte, int n )\n{\n\tint nl = lbyte - cbyte;\n\tint i;\n\t\n\tif ( nl < n ) {\n\t\tfor ( i = 0; i < nl; i++ )\n\t\t\tbyte[ i ] = data[ cbyte + i ];\n\t\tcbyte = lbyte;\n\t\teof = true;\n\t\treturn nl;\n\t}\n\telse {\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tbyte[ i ] = data[ cbyte + i ];\n\t\tcbyte += n;\n\t\treturn n;\n\t}\n}\n\n/* -----------------------------------------------\n\tgo to position in data\n\t----------------------------------------------- */\n\t\nvoid abytereader::seek( int pos )\n{\n\tif ( pos >= lbyte ) {\n\t\tcbyte = lbyte;\n\t\teof = true;\n\t}\n\telse {\n\t\tcbyte = pos;\n\t\teof = false;\n\t}\n}\n\n/* -----------------------------------------------\n\tgets size of current data\n\t----------------------------------------------- */\n\t\nint abytereader::getsize( void )\n{\n\treturn lbyte;\n}\n\n/* -----------------------------------------------\n\tgets current position from abytereader\n\t----------------------------------------------- */\t\n\nint abytereader::getpos( void )\n{\n\treturn cbyte;\n}\n\nbounded_iostream::bounded_iostream(Sirikata::DecoderWriter *w,\n                                   const std::function<void(Sirikata::DecoderWriter*, size_t)> &size_callback,\n                                   const Sirikata::JpegAllocator<uint8_t> &alloc) \n    : parent(w), err(Sirikata::JpegError::nil()) {\n    this->size_callback = size_callback;\n    buffer_position = 0;\n    byte_position = 0;\n    num_bytes_attempted_to_write = 0;\n    set_bound(0);\n}\nvoid bounded_iostream::call_size_callback(size_t size) {\n    size_callback(parent, size);\n}\nbool bounded_iostream::chkerr() {\n    return err != Sirikata::JpegError::nil();\n}\n\nvoid bounded_iostream::set_bound(size_t bound) {\n    flush();\n    if (num_bytes_attempted_to_write > byte_bound) {\n        num_bytes_attempted_to_write = byte_bound;\n    }\n    byte_bound = bound;\n}\nvoid bounded_iostream::flush() {\n    if (buffer_position) {\n        write_no_buffer(buffer, buffer_position);\n        buffer_position = 0;\n    }\n}\nvoid bounded_iostream::close() {\n    flush();\n    parent->Close();\n}\n\nunsigned int bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {\n    //return iostream::write(from,tpsize,dtsize);\n    std::pair<unsigned int, Sirikata::JpegError> retval;\n    if (byte_bound != 0 && byte_position + bytes_to_write > byte_bound) {\n        size_t real_bytes_to_write = byte_bound - byte_position;\n        byte_position += real_bytes_to_write;\n        retval = parent->Write(reinterpret_cast<const unsigned char*>(from), real_bytes_to_write);\n        if (retval.first < real_bytes_to_write) {\n            err = retval.second;\n            return retval.first;\n        }\n        return bytes_to_write; // pretend we wrote it all\n    }\n    size_t total = bytes_to_write;\n    retval = parent->Write(reinterpret_cast<const unsigned char*>(from), total);\n    unsigned int written = retval.first;\n    byte_position += written;\n    if (written < total ) {\n        err = retval.second;\n        return written;\n    }\n    return bytes_to_write;\n}\n\nunsigned int bounded_iostream::getsize() {\n    return byte_position;\n}\n\nbounded_iostream::~bounded_iostream(){\n}\n\nibytestreamcopier::ibytestreamcopier(Sirikata::DecoderReader *p, unsigned int byte_offset,\n                                     unsigned int max_file_size,\n                                     const Sirikata::JpegAllocator<uint8_t> &alloc)\n    : ibytestream(p, byte_offset, alloc), side_channel(alloc) {\n    if (max_file_size) {\n        side_channel.reserve(max_file_size);\n    }\n}\nbool ibytestreamcopier::read_byte(unsigned char *output) {\n    bool retval = ibytestream::read_byte(output);\n    if (retval) {\n        side_channel.push_back(*output);\n    }\n    return retval;\n}\n\nunsigned int ibytestreamcopier::read(unsigned char *output, unsigned int size) {\n    unsigned int retval = ibytestream::read(output, size);\n    if (retval > 0) {\n        side_channel.insert(side_channel.end(), output, output + retval);\n    }\n    return retval;\n}\nibytestream::ibytestream(Sirikata::DecoderReader *p, unsigned int byte_offset,\n                         const Sirikata::JpegAllocator<uint8_t> &alloc) \n    : parent(p) {\n    bytes_read = byte_offset;\n}\n\nunsigned int ibytestream::read(unsigned char*output, unsigned int size) {\n    dev_assert(size);\n    if (size == 1) {\n        return read_byte(output) ? 1 : 0;\n    }\n    int retval = IOUtil::ReadFull(parent, output, size);\n    bytes_read += retval;\n    static_assert(sizeof(last_read) == 2, \"Last read must hold full jpeg huffman\");\n    if (retval >= 2) {\n        memcpy(last_read, output + size - sizeof(last_read), sizeof(last_read));\n    } else if (retval) {\n        last_read[0] = last_read[1];\n        last_read[1] = *output;\n    }\n    return retval;\n}\n\nbool ibytestream::read_byte(unsigned char *output) {\n    unsigned int retval = parent->Read(output, 1).first;\n    if (retval != 0) {\n        last_read[0] = last_read[1];\n        last_read[1] = *output;\n        bytes_read += 1;\n        return true;\n    }\n    return false;\n}\n", "/* -*-mode:c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/**\nCopyright (c) 2006...2016, Matthias Stirner and HTW Aalen University\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **/\n\n\n\n#include <assert.h>\n#include <cstring>\n#define RBITS( c, n )\t\t( c & ( 0xFF >> (8 - n) ) )\n#define LBITS( c, n )\t\t( c >> (8 - n) )\n#define MBITS( c, l, r )\t( RBITS( c,l ) >> r )\n#define RBITS16( c, n )\t\t( c & ( 0xFFFFFFFF >> (16 - n) ) )\n#define LBITS16( c, n )\t\t( c >> (16 - n) )\n#define MBITS16( c, l, r )\t( RBITS16( c,l ) >> r )\n#define RBITS32( c, n )\t\t( c & ( 0xFFFFFFFF >> (32 - n) ) )\n#define LBITS32( c, n )\t\t( c >> (32 - n) )\n#define MBITS32( c, l, r )\t( RBITS32( c,l ) >> r )\n\n#define RBITS64( c, n )\t\t(n == 0 ? 0ULL : ( (c) & ( 0xFFFFFFFFFFFFFFFFULL >> (64 - (n)) ) ))\n#define LBITS64( c, n )\t\t( c >> (64 - n) )\n#define MBITS64( c, l, r )\t(((r) >= 64) ? 0 : ( RBITS64( c,l ) >> (r) ))\n\n#define BITN( c, n )\t\t( (c >> n) & 0x1 )\n#define FDIV2( v, p )\t\t( ( v < 0 ) ? -( (-v) >> p ) : ( v >> p ) )\n\n#define BTST_BUFF\t\t\t1024 * 1024\n\n#include <stdio.h>\n#include <functional>\n#include \"../io/Reader.hh\"\n#include \"../io/ioutil.hh\"\n#include \"../vp8/util/vpx_config.hh\"\n\n/* -----------------------------------------------\n\tclass to write arrays bitwise\n\t----------------------------------------------- */\n\nclass abitwriter\n{\n    unsigned char* data2;\npublic:\n    uint64_t buf;\n    int dsize;\n    int adds;\n    int cbyte2;\n    int cbit2;\n    bool fmem;\n    int size_bound;\npublic:\n    void debug() const;\n\n    \n    abitwriter( int size, int size_bound);\n\t~abitwriter( void );\n    \n    unsigned char* partial_bytewise_flush() {\n        if (__builtin_expect(bound_reached(), 0)) {\n            return data2;\n        }\n        int partial_byte_bits = (64 - cbit2) & 7;\n        uint64_t xbuf = htobe64(buf);\n        uint32_t bytes_to_write = (64 - (cbit2 + partial_byte_bits)) / 8;\n        uint32_t bits_to_write = (bytes_to_write << 3);\n        memcpy(data2 + cbyte2, &xbuf, bytes_to_write);\n        cbyte2 += bytes_to_write;\n        if (bits_to_write > 63) {\n            buf = 0;\n        } else {\n            buf <<= bits_to_write;\n        }\n        cbit2 += bits_to_write;\n        return data2;\n    }\n    void flush_no_pad() {\n        if (__builtin_expect(bound_reached(), 0)) {\n            return;\n        }\n        always_assert(((64 - cbit2) & 7) == 0);\n        buf = htobe64(buf);\n        uint32_t bytes_to_write = (64 - cbit2) / 8;\n        memcpy(data2 + cbyte2, &buf, bytes_to_write);\n        cbyte2 += bytes_to_write;\n        buf = 0;\n        //assert(cbyte +1 == cbyte2 || cbyte == cbyte2 || cbyte == cbyte2 + 1 || cbyte == cbyte2 + 2 || cbyte == cbyte2 + 3);\n        //assert(memcmp(data2, data, cbyte2) == 0);\n        \n        cbit2 = 64;\n    }\n    /* -----------------------------------------------\n     writes n bits to abitwriter\n     ----------------------------------------------- */\n    \n    void write( unsigned int val, int nbits )\n    {\n\n        int nbits2 = nbits;\n        unsigned int val2 = val;\n        dev_assert(nbits <= 64);\n        if ( __builtin_expect(cbyte2 > ( dsize - 16 ), false) ) {\n            if (bound_reached()) {\n                return;\n            }\n            if (adds < 4096 * 1024) {\n                adds <<= 1;\n            }\n            int new_size = dsize + adds;\n            unsigned char * tmp = (unsigned char*)custom_malloc(new_size);\n            if ( tmp == NULL ) {\n                error = true;\n                custom_exit(ExitCode::MALLOCED_NULL);\n                return;\n            }\n            memset(tmp + dsize, 0, adds);\n            memcpy(tmp, data2, dsize);\n            custom_free(data2);\n            data2 = tmp;\n            dsize = new_size;\n        }\n\n        // write data\n        if ( nbits2 >= cbit2 ) {\n\n            buf |= MBITS64(val2, nbits2, (nbits2-cbit2));\n            nbits2 -= cbit2;\n            cbit2 = 0;\n            flush_no_pad();\n        }\n        if ( nbits2 > 0 ) {\n            uint64_t tmp = (RBITS64(val2, nbits2));\n            if (__builtin_expect(cbit2 < nbits2, 0)) {\n                cbit2 = 0;\n            } else {\n                tmp <<= cbit2 - nbits2;\n                buf |= tmp;\n                cbit2 -= nbits2;\n            }\n        }\n\n\n\n    }\n    void pad ( unsigned char fillbit ) {\n        int offset = 1;\n        while ((cbit2 & 7) && cbyte2 < size_bound) {\n            write( (fillbit & offset) ? 1 : 0, 1 );\n            offset <<= 1;\n        }\n        flush_no_pad();\n    }\n    unsigned char* getptr( void ) {\n        // data is padded here\n        pad( fillbit );\n        flush_no_pad();\n        // forbid freeing memory\n        fmem = false;\n        // realloc data\n        return data2;\n    }\n    const unsigned char* peekptr( void ) {\n        flush_no_pad();\n        return data2;\n    }\n    uint8_t get_num_overhang_bits() {\n        return 64 - cbit2;\n    }\n    bool bound_reached() const {\n        return cbyte2 >= size_bound;\n    }\n    uint8_t get_overhang_byte() const {\n        dev_assert(cbit2 > 56);\n        uint64_t retval = buf;\n        retval >>= 56;\n        return (uint8_t) retval;\n    }\n    void reset_from_overhang_byte_and_num_bits(uint8_t overhang_byte,\n                                               uint8_t num_bits) {\n        memset(data2, 0, cbyte2);\n        if (size_bound) {\n            size_bound -=cbyte2;\n        }\n        cbyte2 = 0;\n        buf = 0;\n        buf = overhang_byte;\n        buf <<= 56;\n        cbit2 = 64 - num_bits;\n    }\n    void reset() {\n        dev_assert(no_remainder());\n        reset_crystallized_bytes();\n    }\n    void reset_crystallized_bytes() {\n        memset(data2, 0, cbyte2);\n        if (size_bound) {\n            size_bound -=cbyte2;\n        }\n        cbyte2 = 0;\n    }\n    int getpos( void ) const {\n        return cbyte2;\n    }\n    bool no_remainder() const {\n        return cbit2 == 64 || bound_reached();\n    }\n\tbool error;\t\n\tunsigned char fillbit;\n\t\n};\n\n/* -----------------------------------------------\n\tclass to read arrays bitwise\n\t----------------------------------------------- */\n\nclass abitreader\n{\npublic:\n\tabitreader( unsigned char* array, int size );\n\t~abitreader( void );\n    std::pair<uint8_t, uint8_t> overhang()\n    {\n        uint64_t selected_byte = htobe64(buf);\n        uint8_t rem = (uint8_t)((64 - cbit2) & 7);\n        if (rem != 64) {\n            uint8_t shift_level = (64 - cbit2) - rem;\n            if (shift_level < 64) {\n                selected_byte >>= shift_level;\n            } else {\n                selected_byte = 0;\n            }\n        }\n        uint8_t selected_bits = (uint8_t)selected_byte;\n        selected_bits &= (((1 << rem) - 1) << (8 - rem));\n        return {rem, selected_bits};\n    }\n\tunsigned int read( int nbits ) {\n        if (__builtin_expect(eof || !nbits, 0)) {\n            return 0;\n        }\n        unsigned int bits_read = 0;\n        unsigned int retval2 = 0;\n        if (__builtin_expect(nbits >= cbit2, 0)) {\n            bits_read = cbit2;\n            retval2 = (RBITS64(buf, cbit2) << (nbits - bits_read)) & ((1 << nbits) - 1);\n            int cur_nbits = nbits - bits_read;\n            buf >>= bits_read;\n            cbit2 -= bits_read;\n            if (cbyte2 == lbyte && cbit2 == 0) {\n                eof = true;\n                return retval2;\n            }\n            if (__builtin_expect(lbyte - cbyte2 < (int)sizeof(buf), 0)) {\n                int new_bytes = std::min((int)sizeof(buf), lbyte - cbyte2);\n                memcpy(&buf, &data2[cbyte2], new_bytes);\n                buf = htobe64(buf);\n                buf >>= (sizeof(buf) - new_bytes) * 8;\n                cbyte2 += new_bytes;\n                cbit2 += new_bytes * 8;\n            } else {\n                memcpy(&buf, &data2[cbyte2], sizeof(buf));\n                buf = htobe64(buf);\n                cbyte2 += sizeof(buf);\n                cbit2 += sizeof(buf) * 8;\n            }\n            if (cbyte2 == lbyte && cbit2 == 0) {\n                eof = true;\n            }\n            if (cur_nbits) {\n                if (cur_nbits <= cbit2) {\n                    retval2 |= MBITS64(buf, cbit2, (cbit2-cur_nbits));\n                    cbit2 -= cur_nbits;\n                } else {\n                    retval2 |= buf;\n                    buf = 0;\n                    cbit2 = 0;\n                }\n            }\n        } else {\n            retval2 = MBITS64(buf, cbit2, (cbit2-nbits));\n            cbit2 -= nbits;\n        }\n        return retval2;\n    }\n    bool remainder() {\n        if (cbit2 & 7) {\n            return 8 - (cbit2 &7);\n        } return 0;\n    }\n\tunsigned char unpad( unsigned char fillbit ) {\n        if ((cbit2 & 7) == 0 || eof) return fillbit;\n        else {\n            char last_bit = read( 1 );\n            fillbit = last_bit;\n            int offset = 1;\n            while (cbit2 & 7) {\n                last_bit = read( 1 );\n                fillbit |= (last_bit << offset);\n                ++offset;\n            }\n            while(offset < 7) {\n                fillbit |= (last_bit << offset);\n                ++offset;\n            }\n        }\n        return fillbit;\n    }\n\tint getpos( void ) {\n        return cbyte2 - 7 + ((64 - cbit2) >> 3);\n    }\n    uint64_t debug_peek(void) {\n        uint64_t retval = 0;\n        abitreader tmp(*this);\n        bool had_remainder = false;\n        while (tmp.remainder()) {\n            had_remainder = true;\n            retval = tmp.read(tmp.remainder());\n        }\n        for (int i = 0 ;i < (had_remainder ? 7 : 8);++i) {\n            uint8_t a = tmp.read(8);\n            retval |= a;\n            retval <<= 8;\n        }\n        return retval;\n    }\n    bool eof;\nprivate:\n    unsigned char* data2;\n    int cbyte2;\n    int cbit2;\n    uint64_t buf;\n\tint lbyte;\n};\n\n/* -----------------------------------------------\n\tclass to write arrays bytewise\n\t----------------------------------------------- */\nextern void aligned_dealloc(unsigned char*);\nextern unsigned char * aligned_alloc(size_t);\n\nclass abytewriter\n{\npublic:\n\tabytewriter( int size );\n\t~abytewriter( void );\t\n\tvoid write( unsigned char byte );\n\tvoid write_n( unsigned char* byte, int n );\n\tunsigned char* getptr_aligned( void );\n\tunsigned char* peekptr_aligned( void );\n\tint getpos( void );\n\tvoid reset( void );\n\tbool error;\t\n\t\nprivate:\n\tunsigned char* data;\n\tint dsize;\n\tint adds;\n\tint cbyte;\n\tbool fmem;\n};\n\n\n/* -----------------------------------------------\n\tclass to read arrays bytewise\n\t----------------------------------------------- */\n\nclass abytereader\n{\npublic:\n\tabytereader( unsigned char* array, int size );\n\t~abytereader( void );\t\n\tint read( unsigned char* byte );\n\tint read_n( unsigned char* byte, int n );\n\tvoid seek( int pos );\n\tint getsize( void );\n\tint getpos( void );\n\tbool eof;\t\n\t\nprivate:\n\tunsigned char* data;\n\tint lbyte;\n\tint cbyte;\n};\n\n\n/* -----------------------------------------------\n\tclass for input and output from file or memory\n\t----------------------------------------------- */\n\nclass ibytestream {\n    Sirikata::DecoderReader* parent;\n    unsigned int bytes_read;\npublic:\n\tunsigned char get_last_read() const {\n        return last_read[1];\n    }\n\tunsigned char get_penultimate_read() const {\n        return last_read[0];\n    }\n    ibytestream(Sirikata::DecoderReader *p,\n                unsigned int starting_byte_offset,\n                const Sirikata::JpegAllocator<uint8_t> &alloc);\n    unsigned int getsize() const {\n        return bytes_read;\n    }\n    bool read_byte(unsigned char *output);\n    unsigned int read(unsigned char *output, unsigned int size);\n    // the biggest allowed huffman code (that may get damaged by truncation)\n    unsigned char last_read[2];\n};\nclass ibytestreamcopier : ibytestream{ // since we don't use virtual methods... must reimplement\n    std::vector<uint8_t, Sirikata::JpegAllocator<uint8_t> > side_channel;\npublic:\n    ibytestreamcopier(Sirikata::DecoderReader *p,\n                      unsigned int starting_byte_offset,\n                      unsigned int maximum_file_size,\n                      const Sirikata::JpegAllocator<uint8_t> &alloc);\n    unsigned int getsize() const {\n        return ibytestream::getsize();\n    }\n    unsigned int get_last_read() const {\n        return ibytestream::get_last_read();\n    }\n    unsigned int get_penultimate_read() const {\n        return ibytestream::get_penultimate_read();\n    }\n\n    bool read_byte(unsigned char *output);\n    unsigned int read(unsigned char *output, unsigned int size);\n\n    const std::vector<uint8_t,\n                      Sirikata::JpegAllocator<uint8_t> >&get_read_data() const {\n        return side_channel;\n    }\n    std::vector<uint8_t, Sirikata::JpegAllocator<uint8_t> >&mutate_read_data() {\n        return side_channel;\n    }\n};\n\nclass bounded_iostream\n{\n    enum {\n        buffer_size = 65536\n    };\n    uint8_t buffer[buffer_size];\n    uint32_t buffer_position;\n    Sirikata::DecoderWriter *parent;\n    unsigned int byte_bound;\n    unsigned int byte_position;\n    unsigned int num_bytes_attempted_to_write;\n    Sirikata::JpegError err;\n    std::function<void(Sirikata::DecoderWriter*, size_t)> size_callback;\n    unsigned int write_no_buffer( const void* from, size_t bytes_to_write );\npublic:\n\tbounded_iostream( Sirikata::DecoderWriter * parent,\n                      const std::function<void(Sirikata::DecoderWriter*, size_t)> &size_callback,\n                      const Sirikata::JpegAllocator<uint8_t> &alloc);\n\t~bounded_iostream( void );\n    void call_size_callback(size_t size);\n    bool chkerr();\n    unsigned int getsize();\n    unsigned int bytes_written()const {\n        return std::max(byte_position,\n                        std::min(byte_position + buffer_position, byte_bound));\n    }\n    void set_bound(size_t bound); // bound of zero = fine\n    size_t get_bound() const {\n        return byte_bound;\n    }\n    bool has_reached_bound() const {\n        return byte_bound && byte_position + buffer_position >= byte_bound;\n    }\n    bool has_exceeded_bound() const {\n        return byte_bound && num_bytes_attempted_to_write > byte_bound;\n    }\n    unsigned int write_byte(uint8_t byte) {\n        ++num_bytes_attempted_to_write;\n        dev_assert(buffer_position < buffer_size && \"Full buffer wasn't flushed\");\n        buffer[buffer_position++] = byte;\n        if (__builtin_expect(buffer_position == buffer_size, 0)) {\n            buffer_position = 0;\n            write_no_buffer(buffer, buffer_size);\n        }\n        return 1;\n    }\n    unsigned int write(const void *from, unsigned int nbytes) {\n        num_bytes_attempted_to_write += nbytes;\n        size_t bytes_to_write = nbytes;\n        if (__builtin_expect(nbytes + buffer_position > buffer_size, 0)) {\n            if (buffer_position) {\n                write_no_buffer(buffer, buffer_position);\n                buffer_position = 0;\n            }\n            if (bytes_to_write < 64) {\n                memcpy(buffer + buffer_position, from, bytes_to_write);\n                buffer_position += bytes_to_write;\n            } else {\n                return write_no_buffer(from, bytes_to_write);\n            }\n        } else {\n            memcpy(buffer + buffer_position, from, bytes_to_write);\n            buffer_position += bytes_to_write;\n            if (__builtin_expect(buffer_position == buffer_size, 0)) {\n                 buffer_position = 0;\n                write_no_buffer(buffer, buffer_size);\n            }\n        }\n        return bytes_to_write;\n    }\n    void flush();\n    void close();\n};\n", "#include \"lepton_codec.hh\"\n#include \"uncompressed_components.hh\"\n#include \"../vp8/decoder/decoder.hh\"\n\n\n\ntemplate<class Left, class Middle, class Right, bool force_memory_optimization>\nvoid LeptonCodec::ThreadState::decode_row(Left & left_model,\n                                          Middle& middle_model,\n                                          Right& right_model,\n                                          int curr_y,\n                                          BlockBasedImagePerChannel<force_memory_optimization>& image_data,\n                                          int component_size_in_block) {\n    uint32_t block_width = image_data[(int)middle_model.COLOR]->block_width();\n    if (block_width > 0) {\n        BlockContext context = context_.at((int)middle_model.COLOR);\n        parse_tokens(context,\n                     bool_decoder_,\n                     left_model,\n                     model_); //FIXME\n        int offset = image_data[middle_model.COLOR]->next(context_.at((int)middle_model.COLOR), true, curr_y);\n        if (offset >= component_size_in_block) {\n            return;\n        }\n    }\n    for (unsigned int jpeg_x = 1; jpeg_x + 1 < block_width; jpeg_x++) {\n        BlockContext context = context_.at((int)middle_model.COLOR);\n        parse_tokens(context,\n                     bool_decoder_,\n                     middle_model,\n                     model_); //FIXME\n        int offset = image_data[middle_model.COLOR]->next(context_.at((int)middle_model.COLOR),\n\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t  curr_y);\n        if (offset >= component_size_in_block) {\n            return;\n        }\n    }\n    if (block_width > 1) {\n        BlockContext context = context_.at((int)middle_model.COLOR);\n        parse_tokens(context,\n                     bool_decoder_,\n                     right_model,\n                     model_);\n        image_data[middle_model.COLOR]->next(context_.at((int)middle_model.COLOR), false, curr_y);\n    }\n}\n#ifdef ALLOW_FOUR_COLORS\n#define ProbabilityTablesTuple(left, above, right) \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR0>, \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR1>, \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR2>, \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR3>\n#define EACH_BLOCK_TYPE(left, above, right) ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR0>(BlockType::Y, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right), \\\n                        ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR1>(BlockType::Cb, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right), \\\n                        ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR2>(BlockType::Cr, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right), \\\n                        ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR3>(BlockType::Ck, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right)\n#else\n#define ProbabilityTablesTuple(left, above, right) \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR0>, \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR1>, \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR2>\n#define EACH_BLOCK_TYPE(left, above, right) ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR0>(BlockType::Y, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right), \\\n                        ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR1>(BlockType::Cb, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right), \\\n                        ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR2>(BlockType::Cr, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right)\n#endif\n\n\n\n\nvoid LeptonCodec::ThreadState::decode_row_wrapper(BlockBasedImagePerChannel<true>& image_data,\n                                          Sirikata::Array1d<uint32_t,\n                                                            (uint32_t)ColorChannel::\n                                                            NumBlockTypes> component_size_in_blocks,\n                                          int component,\n                                          int curr_y) {\n    return decode_rowt(image_data, component_size_in_blocks, component, curr_y);\n}\nvoid LeptonCodec::ThreadState::decode_rowf(BlockBasedImagePerChannel<false>& image_data,\n                                          Sirikata::Array1d<uint32_t,\n                                                            (uint32_t)ColorChannel::\n                                                            NumBlockTypes> component_size_in_blocks,\n                                          int component,\n                                          int curr_y) {\n    decode_row_internal(image_data, component_size_in_blocks,component,curr_y);\n}\nvoid LeptonCodec::ThreadState::decode_rowt(BlockBasedImagePerChannel<true>& image_data,\n                                          Sirikata::Array1d<uint32_t,\n                                                            (uint32_t)ColorChannel::\n                                                            NumBlockTypes> component_size_in_blocks,\n                                          int component,\n                                          int curr_y) {\n    decode_row_internal(image_data, component_size_in_blocks,component,curr_y);\n}\ntemplate<bool force_memory_optimization>\nvoid LeptonCodec::ThreadState::decode_row_internal(BlockBasedImagePerChannel<force_memory_optimization>& image_data,\n                                          Sirikata::Array1d<uint32_t,\n                                                            (uint32_t)ColorChannel::\n                                                            NumBlockTypes> component_size_in_blocks,\n                                          int component,\n                                          int curr_y) {\n    using std::tuple;\n    tuple<ProbabilityTablesTuple(false, false, false)> corner(EACH_BLOCK_TYPE(false,false,false));\n    tuple<ProbabilityTablesTuple(true, false, false)> top(EACH_BLOCK_TYPE(true,false,false));\n    tuple<ProbabilityTablesTuple(false, true, true)> midleft(EACH_BLOCK_TYPE(false, true, true));\n    tuple<ProbabilityTablesTuple(true, true, true)> middle(EACH_BLOCK_TYPE(true,true,true));\n    tuple<ProbabilityTablesTuple(true, true, false)> midright(EACH_BLOCK_TYPE(true, true, false));\n    tuple<ProbabilityTablesTuple(false, true, false)> width_one(EACH_BLOCK_TYPE(false, true, false));\n    context_.at(component)\n        = image_data[component]->off_y(curr_y,\n                                       num_nonzeros_.at(component).begin());\n    \n    int block_width = image_data[component]->block_width();\n    if (is_top_row_.at(component)) {\n        is_top_row_.at(component) = false;\n        switch((BlockType)component) {\n          case BlockType::Y:\n            decode_row(std::get<(int)BlockType::Y>(corner),\n                       std::get<(int)BlockType::Y>(top),\n                       std::get<(int)BlockType::Y>(top),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            break;\n          case BlockType::Cb:\n            decode_row(std::get<(int)BlockType::Cb>(corner),\n                       std::get<(int)BlockType::Cb>(top),\n                       std::get<(int)BlockType::Cb>(top),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n          case BlockType::Cr:\n            decode_row(std::get<(int)BlockType::Cr>(corner),\n                       std::get<(int)BlockType::Cr>(top),\n                       std::get<(int)BlockType::Cr>(top),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#ifdef ALLOW_FOUR_COLORS\n          case BlockType::Ck:\n            decode_row(std::get<(int)BlockType::Ck>(corner),\n                       std::get<(int)BlockType::Ck>(top),\n                       std::get<(int)BlockType::Ck>(top),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#endif\n        }\n    } else if (block_width > 1) {\n        dev_assert(curr_y); // just a sanity check that the zeroth row took the first branch\n        switch((BlockType)component) {\n          case BlockType::Y:\n            decode_row(std::get<(int)BlockType::Y>(midleft),\n                       std::get<(int)BlockType::Y>(middle),\n                       std::get<(int)BlockType::Y>(midright),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n          case BlockType::Cb:\n            decode_row(std::get<(int)BlockType::Cb>(midleft),\n                       std::get<(int)BlockType::Cb>(middle),\n                       std::get<(int)BlockType::Cb>(midright),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n          case BlockType::Cr:\n            decode_row(std::get<(int)BlockType::Cr>(midleft),\n                       std::get<(int)BlockType::Cr>(middle),\n                       std::get<(int)BlockType::Cr>(midright),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#ifdef ALLOW_FOUR_COLORS\n          case BlockType::Ck:\n            decode_row(std::get<(int)BlockType::Ck>(midleft),\n                       std::get<(int)BlockType::Ck>(middle),\n                       std::get<(int)BlockType::Ck>(midright),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#endif\n        }\n    } else {\n        dev_assert(curr_y); // just a sanity check that the zeroth row took the first branch\n        dev_assert(block_width == 1);\n        switch((BlockType)component) {\n          case BlockType::Y:\n            decode_row(std::get<(int)BlockType::Y>(width_one),\n                       std::get<(int)BlockType::Y>(width_one),\n                       std::get<(int)BlockType::Y>(width_one),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n          case BlockType::Cb:\n            decode_row(std::get<(int)BlockType::Cb>(width_one),\n                       std::get<(int)BlockType::Cb>(width_one),\n                       std::get<(int)BlockType::Cb>(width_one),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n          case BlockType::Cr:\n            decode_row(std::get<(int)BlockType::Cr>(width_one),\n                       std::get<(int)BlockType::Cr>(width_one),\n                       std::get<(int)BlockType::Cr>(width_one),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#ifdef ALLOW_FOUR_COLORS\n          case BlockType::Ck:\n            decode_row(std::get<(int)BlockType::Ck>(width_one),\n                       std::get<(int)BlockType::Ck>(width_one),\n                       std::get<(int)BlockType::Ck>(width_one),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#endif\n        }\n    }\n}\n\nCodingReturnValue LeptonCodec::ThreadState::vp8_decode_thread(unsigned int thread_id,\n                                                              UncompressedComponents *const colldata) {\n    Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes> component_size_in_blocks;\n    BlockBasedImagePerChannel<false> image_data;\n    for (int i = 0; i < colldata->get_num_components(); ++i) {\n        component_size_in_blocks[i] = colldata->component_size_in_blocks(i);\n        image_data[i] = &colldata->full_component_write((BlockType)i);\n    }\n    Sirikata::Array1d<uint32_t,\n                      (size_t)ColorChannel::NumBlockTypes> max_coded_heights\n        = colldata->get_max_coded_heights();\n    /* deserialize each block in planar order */\n\n    dev_assert(luma_splits_.size() == 2); // not ready to do multiple work items on a thread yet\n    int min_y = luma_splits_[0];\n    int max_y = luma_splits_[1];\n    while(true) {\n        RowSpec cur_row = row_spec_from_index(decode_index_++, image_data, colldata->get_mcu_count_vertical(), max_coded_heights);\n        if (cur_row.done) {\n            break;\n        }\n        if (cur_row.luma_y >= max_y && thread_id + 1 != NUM_THREADS) {\n            break;\n        }\n        if (cur_row.skip) {\n            continue;\n        }\n        if (cur_row.luma_y < min_y) {\n            continue;\n        }\n        decode_rowf(image_data,\n                   component_size_in_blocks,\n                   cur_row.component,\n                   cur_row.curr_y);\n        if (thread_id == 0) {\n            colldata->worker_update_cmp_progress((BlockType)cur_row.component,\n                                                 image_data[cur_row.component]->block_width() );\n        }\n        return CODING_PARTIAL;\n    }\n    return CODING_DONE;\n}\n", "/* -*-mode:c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <tuple>\n\n#include \"bitops.hh\"\n#include \"component_info.hh\"\n#include \"uncompressed_components.hh\"\n#include \"jpgcoder.hh\"\n#include \"vp8_decoder.hh\"\n\n#include \"../io/Reader.hh\"\n#include \"../vp8/decoder/decoder.hh\"\nusing namespace std;\n\nvoid VP8ComponentDecoder::initialize( Sirikata::DecoderReader *input,\n                                      const std::vector<ThreadHandoff>& thread_handoff)\n{\n    str_in = input;\n    mux_reader_.init(input);\n    thread_handoff_ = thread_handoff;\n}\nvoid VP8ComponentDecoder::decode_row(int target_thread_id,\n                                     BlockBasedImagePerChannel<true>& image_data, // FIXME: set image_data to true\n                                     Sirikata::Array1d<uint32_t,\n                                                       (uint32_t)ColorChannel::\n                                                       NumBlockTypes> component_size_in_blocks,\n                                     int component,\n                                     int curr_y) {\n    thread_state_[target_thread_id]->decode_rowt(image_data,\n                                               component_size_in_blocks,\n                                               component,\n                                               curr_y);\n}\n\n\nVP8ComponentDecoder::VP8ComponentDecoder(bool do_threading)\n    : VP8ComponentEncoder(do_threading),\n      mux_reader_(Sirikata::JpegAllocator<uint8_t>(),\n                  8,\n                  0) {\n    virtual_thread_id_ = -1;\n}\n\nVP8ComponentDecoder::~VP8ComponentDecoder() {\n}\n\n\n#ifdef ALLOW_FOUR_COLORS\n#define ProbabilityTablesTuple(left, above, right) \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR0>, \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR1>, \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR2>, \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR3>\n#define EACH_BLOCK_TYPE(left, above, right) BlockType::Y,   \\\n                        BlockType::Cb, \\\n                        BlockType::Cr, \\\n                        BlockType::Ck\n#else\n#define ProbabilityTablesTuple(left, above, right) \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR0>, \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR1>, \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR2>\n#define EACH_BLOCK_TYPE BlockType::Y, \\\n                        BlockType::Cb, \\\n                        BlockType::Cr\n#endif\n\nvoid VP8ComponentDecoder::clear_thread_state(int thread_id, int target_thread_state, BlockBasedImagePerChannel<true>& framebuffer) {\n\n\n    initialize_thread_id(thread_id, target_thread_state, framebuffer);\n    initialize_bool_decoder(thread_id, target_thread_state);\n}\nclass ActualThreadPacketReader : public PacketReader{\n    GenericWorker *worker;\n    VP8ComponentDecoder::SendToActualThread *base;\n    uint8_t stream_id;\n    ResizableByteBufferListNode* last;\npublic:\n    ActualThreadPacketReader(uint8_t stream_id, GenericWorker*worker, VP8ComponentDecoder::SendToActualThread*base) {\n        this->worker = worker;\n        this->stream_id = stream_id;\n        this->base = base;\n    }\n    // returns a buffer with at least sizeof(BD_VALUE) before it\n    virtual ROBuffer getNext() {\n        if (!base->vbuffers[stream_id].empty()) {\n            auto retval = base->vbuffers[stream_id].front();\n            if (!retval->empty()) {\n                base->vbuffers[stream_id].pop();\n            }\n            if (retval->empty()) {\n                isEof = true;\n                return {NULL, NULL};\n            }\n            return {retval->data(), retval->data() + retval->size()};\n        }\n        while(!isEof) {\n            auto dat = worker->batch_recv_data();\n            for (unsigned int i = 0; i < dat.count; ++i) {\n                ResizableByteBufferListNode* lnode = (ResizableByteBufferListNode*) dat.data[i];\n                if (dat.count == 1 && lnode->stream_id == stream_id && lnode && lnode->size()) {\n                    assert(stream_id == lnode->stream_id);\n                    last = lnode;\n                    return {lnode->data(), lnode->data() + lnode->size()};\n                } else {\n                    base->vbuffers[lnode->stream_id].push(lnode);\n                }\n            }\n            if (!base->vbuffers[stream_id].empty()) {\n                return getNext(); // recursive call, 1 deep\n            }\n            if (dat.return_code < 0) {\n                isEof = true; // hmm... should we bail here?\n                always_assert(false);\n            }\n        }\n        return {NULL, NULL};\n    }\n    bool eof()const {\n        return isEof;\n    }\n    virtual void setFree(ROBuffer buffer) {// don't even bother\n        if (last && last->data() == buffer.first) {\n            delete last; // hax\n            last = NULL;\n        }\n    }\n    virtual ~ActualThreadPacketReader(){}\n};\nvoid VP8ComponentDecoder::worker_thread(ThreadState *ts, int thread_id, UncompressedComponents * const colldata,\n                                        int8_t thread_target[Sirikata::MuxReader::MAX_STREAM_ID],\n                                        GenericWorker *worker,\n                                        SendToActualThread *send_to_actual_thread_state) {\n    TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();\n    for (uint8_t i = 0; i < Sirikata::MuxReader::MAX_STREAM_ID; ++i) {\n        if (thread_target[i] == int8_t(thread_id)) {\n            ts->bool_decoder_.init(new ActualThreadPacketReader(i,worker, send_to_actual_thread_state));\n        }\n    }\n    while (ts->vp8_decode_thread(thread_id, colldata) == CODING_PARTIAL) {\n    }\n    TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();\n}\nclass VirtualThreadPacketReader : public PacketReader{\n    VP8ComponentDecoder::SendToVirtualThread*base;\n    uint8_t stream_id;\n    Sirikata::MuxReader*mux_reader_;\n    Sirikata::MuxReader::ResizableByteBuffer * last;\npublic:\n    VirtualThreadPacketReader(uint8_t stream_id, Sirikata::MuxReader * mr, VP8ComponentDecoder::SendToVirtualThread*base) {\n        this->base = base;\n        this->stream_id = stream_id;\n        this->mux_reader_ = mr;\n        last = NULL;\n    }\n    // returns a buffer with at least sizeof(BD_VALUE) before it\n    virtual ROBuffer getNext() {\n        auto retval = base->read(*mux_reader_, stream_id);\n        if (retval->size() == 0) {\n            isEof = true;\n            return {NULL, NULL};\n        }\n        always_assert(!retval->empty()); // we check this earlier\n        return {retval->data(), retval->data() + retval->size()};\n    }\n    bool eof()const {\n        return isEof;\n    }\n    virtual void setFree(ROBuffer buffer) {// don't even bother\n        if (last && last->data() == buffer.first) {\n            delete last; // hax\n            last = NULL;\n        }\n    }\n    virtual ~VirtualThreadPacketReader(){}\n};\n\nvoid VP8ComponentDecoder::initialize_bool_decoder(int thread_id, int target_thread_state) {\n    if (NUM_THREADS > 1 && g_threaded) {\n        thread_state_[target_thread_state]->bool_decoder_.init(new ActualThreadPacketReader(thread_id,\n                                                                                            getWorker(target_thread_state),\n                                                                                            &send_to_actual_thread_state));\n    } else {\n        thread_state_[target_thread_state]->bool_decoder_.init(new VirtualThreadPacketReader(thread_id, &mux_reader_, &mux_splicer));\n    }\n}\n\n    template <bool force_memory_optimized>\nvoid VP8ComponentDecoder::initialize_thread_id(int thread_id, int target_thread_state,\n                                               BlockBasedImagePerChannel<force_memory_optimized>& framebuffer) {\n    if (target_thread_state) {\n        always_assert(spin_workers_);\n    }\n    TimingHarness::timing[thread_id%NUM_THREADS][TimingHarness::TS_STREAM_MULTIPLEX_STARTED] = TimingHarness::get_time_us();\n    //if (thread_id != target_thread_state) {\n        reset_thread_model_state(target_thread_state);\n    //}\n    thread_state_[target_thread_state]->decode_index_ = 0;\n    for (unsigned int i = 0; i < framebuffer.size(); ++i) {\n        if (framebuffer[i] != NULL)  {\n            thread_state_[target_thread_state]->is_top_row_.at(i) = true;\n            thread_state_[target_thread_state]->num_nonzeros_.at(i).resize(framebuffer[i]->block_width() << 1);\n            thread_state_[target_thread_state]->context_.at(i)\n                = framebuffer[i]->begin(thread_state_[target_thread_state]->num_nonzeros_.at(i).begin());\n        }\n    }\n    /* initialize the bool decoder */\n    int index = thread_id;\n    always_assert((size_t)index < streams_.size());\n    \n    thread_state_[target_thread_state]->is_valid_range_ = false;\n    thread_state_[target_thread_state]->luma_splits_.resize(2);\n    if ((size_t)index < thread_handoff_.size()) {\n        thread_state_[target_thread_state]->luma_splits_[0] = thread_handoff_[thread_id].luma_y_start;\n        thread_state_[target_thread_state]->luma_splits_[1] = thread_handoff_[thread_id].luma_y_end;\n    } else {\n        // we have extra threads that are not in use during this decode.\n        // set them to zero sized work (i.e. starting at end and ending at end)\n        // since they don't have any rows to decode\n        thread_state_[target_thread_state]->luma_splits_[0] = thread_handoff_.back().luma_y_end; // <- not a typo\n        thread_state_[target_thread_state]->luma_splits_[1] = thread_handoff_.back().luma_y_end; // both start and end at end\n    }\n    //fprintf(stderr, \"tid: %d   %d -> %d\\n\", thread_id, thread_state_[target_thread_state]->luma_splits_[0],\n    //        thread_state_[target_thread_state]->luma_splits_[1]);\n    TimingHarness::timing[thread_id%NUM_THREADS][TimingHarness::TS_STREAM_MULTIPLEX_FINISHED] = TimingHarness::get_time_us();\n}\nstd::vector<ThreadHandoff> VP8ComponentDecoder::initialize_baseline_decoder(\n    const UncompressedComponents * const colldata,\n    Sirikata::Array1d<BlockBasedImagePerChannel<true>,\n                      MAX_NUM_THREADS>& framebuffer) {\n    mux_splicer.init(spin_workers_);\n    return initialize_decoder_state(colldata, framebuffer);\n}\n\nvoid VP8ComponentDecoder::SendToVirtualThread::set_eof() {\n    using namespace Sirikata;\n    if (!eof) {\n        for (unsigned int thread_id = 0; thread_id < Sirikata::MuxReader::MAX_STREAM_ID; ++thread_id) {\n            for (int i = 0; i < Sirikata::MuxReader::MAX_STREAM_ID; ++i) {\n                if (thread_target[i] == int8_t(thread_id)) {\n                    \n                    auto eof = new ResizableByteBufferListNode;\n                    eof->stream_id = i;\n                    send(eof); // sends an EOF flag (empty buffer)\n                }\n            }\n        }\n    }\n    eof = true;\n}\nVP8ComponentDecoder::SendToVirtualThread::SendToVirtualThread(){\n    eof = false;\n    for (int i = 0; i < Sirikata::MuxReader::MAX_STREAM_ID; ++i) {\n        thread_target[i] = -1;\n    }\n    this->all_workers = NULL;\n}\n\nvoid VP8ComponentDecoder::SendToVirtualThread::init(GenericWorker * all_workers) {\n    this->all_workers = all_workers;\n}\nvoid VP8ComponentDecoder::SendToVirtualThread::send(ResizableByteBufferListNode *data) {\n    always_assert(data);\n    always_assert(data->stream_id < sizeof(vbuffers) / sizeof(vbuffers[0]) &&\n                  \"INVALID SEND STREAM ID\");\n    if (!g_threaded || NUM_THREADS == 1) {\n        /*\n    fprintf(stderr, \"VSending (%d) %d bytes of data : ptr %p\\n\",\n            (int)data->stream_id, (int)data->size(),\n            (void*)data);*/\n        vbuffers[data->stream_id].push(data);\n        return;\n    }\n    auto thread_target_id = thread_target[data->stream_id];\n    /*\n    fprintf(stderr, \"Sending (%d) %d bytes of data : ptr %p to %d\\n\",\n            (int)data->stream_id, (int)data->size(),\n            (void*)data, thread_target_id);\n    */\n    if (thread_target_id >= 0) {\n        int retval = all_workers[thread_target_id].send_more_data(data);\n        always_assert(retval == 0 && \"Communication with thread lost\");\n    }else {\n        always_assert(false && \"Cannot send to thread that wasn't bound\");\n    }\n}\nvoid VP8ComponentDecoder::SendToVirtualThread::drain(Sirikata::MuxReader&reader) {\n    while (!reader.eof) {\n        ResizableByteBufferListNode *data = new ResizableByteBufferListNode;\n        auto ret = reader.nextDataPacket(*data);\n        if (ret.second != Sirikata::JpegError::nil()) {\n            set_eof();\n            break;\n        }\n        data->stream_id = ret.first;\n        always_assert(data->size()); // the protocol can't store empty runs\n        send(data);\n    }\n}\nResizableByteBufferListNode* VP8ComponentDecoder::SendToVirtualThread::read(Sirikata::MuxReader&reader, uint8_t stream_id) {\n    using namespace Sirikata;\n    always_assert(stream_id < sizeof(vbuffers) / sizeof(vbuffers[0]) &&\n                  \"INVALID READ STREAM ID\");\n    if (!vbuffers[stream_id].empty()) {\n        auto retval = vbuffers[stream_id].front();\n        if (retval->size() == 0) {\n            always_assert(eof);\n        } else { // keep this placeholder there\n            vbuffers[stream_id].pop();\n        }\n        return retval;\n    }\n    if (eof) {\n        always_assert(false);\n        return NULL;\n    }\n    while (!eof) {\n        ResizableByteBufferListNode *data = new ResizableByteBufferListNode;\n        auto ret = reader.nextDataPacket(*data);\n        if (ret.second != JpegError::nil()) {\n            set_eof();\n            break;\n        }\n        data->stream_id = ret.first;\n        bool buffer_it = ret.first != stream_id;\n        if (buffer_it) {\n            send(data);\n        } else {\n            return data;\n        }\n    }\n    if (!vbuffers[stream_id].empty()) {\n        auto retval = vbuffers[stream_id].front();\n        if (retval->size() == 0) {\n            always_assert(eof);\n        } else { // keep this placeholder there\n            vbuffers[stream_id].pop();\n        }\n        return retval;\n    }\n    return NULL;\n}\nvoid VP8ComponentDecoder::SendToVirtualThread::read_all(Sirikata::MuxReader&reader) {\n    using namespace Sirikata;\n    while (!eof) {\n        ResizableByteBufferListNode *data = new ResizableByteBufferListNode;\n        auto ret = reader.nextDataPacket(*data);\n        if (ret.second != JpegError::nil()) {\n            set_eof();\n            break;\n        }\n        data->stream_id = ret.first;\n        always_assert(data->size());\n        send(data);\n    }\n}\n\ntemplate <bool force_memory_optimized>\nstd::vector<ThreadHandoff> VP8ComponentDecoder::initialize_decoder_state(const UncompressedComponents * const colldata,\n                                                   Sirikata::Array1d<BlockBasedImagePerChannel<force_memory_optimized>,\n                                                                     MAX_NUM_THREADS>& framebuffer) {\n    if (colldata->get_num_components() > (int)BlockType::Y) {\n        ProbabilityTablesBase::set_quantization_table(BlockType::Y,\n                                                      colldata->get_quantization_tables(BlockType::Y));\n    }\n    if (colldata->get_num_components() > (int)BlockType::Cb) {\n        ProbabilityTablesBase::set_quantization_table(BlockType::Cb,\n                                                      colldata->get_quantization_tables(BlockType::Cb));\n    }\n    if (colldata->get_num_components() > (int)BlockType::Cr) {\n        ProbabilityTablesBase::set_quantization_table(BlockType::Cr,\n                                                      colldata->get_quantization_tables(BlockType::Cr));\n    }\n#ifdef ALLOW_FOUR_COLORS\n    if (colldata->get_num_components() > (int)BlockType::Ck) {\n        ProbabilityTablesBase::set_quantization_table(BlockType::Ck,\n                                                      colldata->get_quantization_tables(BlockType::Ck));\n    }\n#endif\n    if (thread_handoff_.empty()) {\n        /* read and verify \"x\" mark */\n        unsigned char mark {};\n        const bool ok = str_in->Read( &mark, 1 ).second == Sirikata::JpegError::nil();\n        if (!ok) {\n            return std::vector<ThreadHandoff>();\n        }\n        ThreadHandoff th;\n        memset(&th, 0, sizeof(th));\n        th.num_overhang_bits = ThreadHandoff::LEGACY_OVERHANG_BITS; // to make sure we don't use this value\n        th.luma_y_end = colldata->block_height(0);\n        thread_handoff_.insert(thread_handoff_.end(), mark, th);\n\n        std::vector<uint16_t> luma_splits_tmp(mark - 1);\n        IOUtil::ReadFull(str_in, luma_splits_tmp.data(), sizeof(uint16_t) * (mark - 1));\n        int sfv_lcm = colldata->min_vertical_luma_multiple();\n        for (int i = 0; i + 1 < mark; ++i) {\n            thread_handoff_[i].luma_y_end = htole16(luma_splits_tmp[i]);\n            if (thread_handoff_[i].luma_y_end % sfv_lcm) {\n                custom_exit(ExitCode::THREADING_PARTIAL_MCU);\n            }\n        }\n        for (int i = 1; i < mark; ++i) {\n            thread_handoff_[i].luma_y_start = thread_handoff_[i - 1].luma_y_end;\n        }\n    }\n    /* read entire chunk into memory */\n    //initialize_thread_id(0, 0, framebuffer[0]);\n    if (thread_handoff_.size()) {\n        thread_handoff_.back().luma_y_end = colldata->block_height(0);\n    }\n    return thread_handoff_;\n}\nvoid VP8ComponentDecoder::flush() {\n        mux_splicer.drain(mux_reader_);\n}\nCodingReturnValue VP8ComponentDecoder::decode_chunk(UncompressedComponents * const colldata)\n{\n    mux_splicer.init(spin_workers_);\n    /* cmpc is a global variable with the component count */\n\n\n    /* construct 4x4 VP8 blocks to hold 8x8 JPEG blocks */\n    if ( thread_state_[0] == nullptr || thread_state_[0]->context_[0].isNil() ) {\n        /* first call */\n        BlockBasedImagePerChannel<false> framebuffer;\n        framebuffer.memset(0);\n        for (size_t i = 0; i < framebuffer.size() && int( i ) < colldata->get_num_components(); ++i) {\n            framebuffer[i] = &colldata->full_component_write((BlockType)i);\n        }\n        Sirikata::Array1d<BlockBasedImagePerChannel<false>, MAX_NUM_THREADS> all_framebuffers;\n        for (size_t i = 0; i < all_framebuffers.size(); ++i) {\n            all_framebuffers[i] = framebuffer;\n        }\n        size_t num_threads_needed = initialize_decoder_state(colldata,\n                                                             all_framebuffers).size();\n\n\n        for (size_t i = 0;i < num_threads_needed; ++i) {\n            map_logical_thread_to_physical_thread(i, i);\n        }\n        for (size_t i = 0;i < num_threads_needed; ++i) {\n            initialize_thread_id(i, i, framebuffer);\n            if (!do_threading_) {\n                break;\n            }\n        }\n        if (num_threads_needed > NUM_THREADS || num_threads_needed == 0) {\n            return CODING_ERROR;\n        }\n    }\n    if (do_threading_) {\n        for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {\n            unsigned int cur_spin_worker = thread_id;\n            spin_workers_[cur_spin_worker].work\n                = std::bind(worker_thread,\n                            thread_state_[thread_id],\n                            thread_id,\n                            colldata,\n                            mux_splicer.thread_target,\n                            getWorker(cur_spin_worker),\n                            &send_to_actual_thread_state);\n            spin_workers_[cur_spin_worker].activate_work();\n        }\n        flush();\n        for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {\n            unsigned int cur_spin_worker = thread_id;\n            TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_STARTED] = TimingHarness::get_time_us();\n            spin_workers_[cur_spin_worker].main_wait_for_done();\n            TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_FINISHED] = TimingHarness::get_time_us();\n        }\n        // join on all threads\n    } else {\n        if (virtual_thread_id_ != -1) {\n            TimingHarness::timing[0][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();\n            CodingReturnValue ret = thread_state_[0]->vp8_decode_thread(0, colldata);\n            if (ret == CODING_PARTIAL) {\n                return ret;\n            }\n            TimingHarness::timing[0][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();\n        }\n        // wait for \"threads\"\n        virtual_thread_id_ += 1; // first time's a charm\n        for (unsigned int thread_id = virtual_thread_id_; thread_id < NUM_THREADS; ++thread_id, ++virtual_thread_id_) {\n            BlockBasedImagePerChannel<false> framebuffer;\n            framebuffer.memset(0);\n            for (size_t i = 0; i < framebuffer.size() && int( i ) < colldata->get_num_components(); ++i) {\n                framebuffer[i] = &colldata->full_component_write((BlockType)i);\n            }\n\n            initialize_thread_id(thread_id, 0, framebuffer);\n            thread_state_[0]->bool_decoder_.init(new VirtualThreadPacketReader(thread_id, &mux_reader_, &mux_splicer));\n            TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();\n            CodingReturnValue ret;\n            if ((ret = thread_state_[0]->vp8_decode_thread(0, colldata)) == CODING_PARTIAL) {\n                return ret;\n            }\n            TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();\n        }\n    }\n    TimingHarness::timing[0][TimingHarness::TS_JPEG_RECODE_STARTED] = TimingHarness::get_time_us();\n    for (int component = 0; component < colldata->get_num_components(); ++component) {\n        colldata->worker_mark_cmp_finished((BlockType)component);\n    }\n    colldata->worker_update_coefficient_position_progress( 64 );\n    colldata->worker_update_bit_progress( 16 );\n    write_byte_bill(Billing::DELIMITERS, true, mux_reader_.getOverhead());\n    return CODING_DONE;\n}\n", "/*\n *  Copyright (c) 2010 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE banner below\n *  An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the VPX_AUTHORS file in this directory\n */\n/*\nCopyright (c) 2010, Google Inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nNeither the name of Google nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef VPX_DSP_BITREADER_H_\n#define VPX_DSP_BITREADER_H_\n\n#include <stddef.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdint.h>\n#include \"vpx_config.hh\"\n#include \"billing.hh\"\n#include \"../model/numeric.hh\"\n//#include \"vpx_ports/mem.h\"\n//#include \"vpx/vp8dx.h\"\n//#include \"vpx/vpx_integer.h\"\n//#include \"vpx_dsp/prob.h\"\n\n\ntypedef size_t BD_VALUE;\n\n#define BD_VALUE_SIZE ((int)sizeof(BD_VALUE) * CHAR_BIT)\n\n// This is meant to be a large, positive constant that can still be efficiently\n// loaded as an immediate (on platforms like ARM, for example).\n// Even relatively modest values like 100 would work fine.\n#define LOTS_OF_BITS 0x40000000\nstatic std::atomic<uint32_t> test_packet_reader_atomic_test;\ntypedef std::pair<const uint8_t*, const uint8_t*> ROBuffer;\nclass PacketReader{\nprotected:\n    bool isEof;\npublic:\n    PacketReader() {\n        isEof = false;\n    }\n    // returns a buffer with at least sizeof(BD_VALUE) before it\n    virtual ROBuffer getNext() = 0;\n    bool eof()const {\n        return isEof;\n    }\n    virtual void setFree(ROBuffer buffer) = 0;\n    virtual ~PacketReader(){}\n};\nclass TestPacketReader :public PacketReader{\n    const uint8_t*cur;\n    const uint8_t*end;\npublic:\n    TestPacketReader(const uint8_t *start, const uint8_t *ed) {\n        isEof = false;\n        cur = start;\n        end = ed;\n    }\n    ROBuffer getNext(){\n        if (cur == end) {\n            isEof = true;\n            return {NULL, NULL};\n        }\n        if (end - cur > 16) {\n            size_t val = (test_packet_reader_atomic_test += 7)%16 + 1;\n            cur += val;\n            return {cur - val, cur};\n        }\n        const uint8_t *ret = cur;\n        cur = end;\n        return {ret, end};\n    }\n    bool eof()const {\n        return isEof;\n    }\n    void setFree(ROBuffer buffer){}\n};\nclass BiRope {\npublic:\n    ROBuffer rope[2];\n    // if we want partial data from a previous valuex\n    uint8_t backing[sizeof(BD_VALUE)];\n    BiRope() {\n        memset(&backing[0], 0, sizeof(BD_VALUE));\n        for (size_t i= 0; i < sizeof(rope)/sizeof(rope[0]); ++i) {\n            rope[i] = {NULL, NULL};\n        }\n    }\n    void push(ROBuffer data) {\n        if(rope[0].first == NULL) {\n            rope[0] = data;\n        }else {\n            always_assert(rope[1].first == NULL);\n            rope[1] = data;\n        }\n    }\n    size_t size() const {\n        return (rope[0].second-rope[0].first) +\n            (rope[1].second - rope[1].first);\n    }\n    void memcpy_ro(uint8_t *dest, size_t size) const {\n        if ((ptrdiff_t)size < rope[0].second-rope[0].first) {\n            memcpy(dest, rope[0].first, size);\n            return;\n        }\n        size_t del = rope[0].second-rope[0].first;\n        memcpy(dest, rope[0].first, del);\n        dest += del;\n        size -=del;\n        if (size) {\n            always_assert(rope[1].second - rope[1].first >= (ptrdiff_t)size);\n            memcpy(dest, rope[1].first, size);\n        }\n    }\n    void operator += (size_t del) {\n        if ((ptrdiff_t)del < rope[0].second - rope[0].first) {\n            rope[0].first += del;\n            return;\n        }\n        del -= rope[0].second - rope[0].first;\n        rope[0] = rope[1];\n        rope[1] = {NULL, NULL};\n        always_assert((ptrdiff_t)del <= rope[0].second - rope[0].first);\n        rope[0].first += del;\n        if (rope[0].first == rope[0].second) {\n            rope[0] = {NULL, NULL};\n        }\n    }\n    /*\n    void memcpy_pop(uint8_t *dest, size_t size) {\n        if (size < rope[0].second-rope[0].first) {\n            memcpy(dest, rope[0].first, size);\n            rope[0].first += size;\n            return;\n        } else {\n            size_t del = rope[0].second-rope[0].first;\n            memcpy(dest, rope[0].first, del);\n            dest += del;\n            size -= del;\n            rope[0] = rope[1];\n            rope[1] = {NULL, NULL};\n        }\n        if (size) {\n            always_assert(rope[0].second - rope[0].first < size);\n            memcpy(dest, rope[0].first, size);\n            rope[0].first += size;\n            if (rope[0].first == rope[0].second) {\n                rope[0] = {NULL, NULL};\n            }\n        }\n        }*/\n};\ntypedef struct {\n  // Be careful when reordering this struct, it may impact the cache negatively.\n  BD_VALUE value;\n  unsigned int range;\n  int count;\n  BiRope buffer;\n  PacketReader *reader;\n//  vpx_decrypt_cb decrypt_cb;\n//  void *decrypt_state;\n} vpx_reader;\n\nint vpx_reader_init(vpx_reader *r,\n                    PacketReader *reader);\n\nstatic INLINE void vpx_reader_fill(vpx_reader *r) {\n    BD_VALUE value = r->value;\n    int count = r->count;\n    size_t bytes_left = r->buffer.size();\n    size_t bits_left = bytes_left * CHAR_BIT;\n    int shift = BD_VALUE_SIZE - CHAR_BIT - (count + CHAR_BIT);\n    if (bits_left <= BD_VALUE_SIZE && !r->reader->eof()) {\n        // pull some from reader\n        uint8_t local_buffer[sizeof(BD_VALUE)] = {0};\n        r->buffer.memcpy_ro(local_buffer, bytes_left);\n        r->buffer += bytes_left; // clear it out\n        while(true) {\n            auto next = r->reader->getNext();\n            if (next.second - next.first + bytes_left <= sizeof(BD_VALUE)) {\n                memcpy(local_buffer + bytes_left, next.first, next.second - next.first);\n                bytes_left += next.second - next.first;\n            } else {\n                if (bytes_left) {\n                    memcpy(r->buffer.backing, local_buffer, bytes_left);\n                    r->buffer.push({r->buffer.backing, r->buffer.backing + bytes_left});\n                }\n                r->buffer.push(next);\n                break;\n            }\n            if (r->reader->eof()) {\n                always_assert(bytes_left <= sizeof(BD_VALUE)); // otherwise we'd have break'd\n                memcpy(r->buffer.backing, local_buffer, bytes_left);\n                r->buffer.push({r->buffer.backing, r->buffer.backing + bytes_left});\n                break; // setup a simplistic rope that just points to the backing store\n            }\n        }\n        bytes_left = r->buffer.size();\n        bits_left = bytes_left * CHAR_BIT;\n    }\n    if (bits_left > BD_VALUE_SIZE) {\n        const int bits = (shift & 0xfffffff8) + CHAR_BIT;\n        BD_VALUE nv;\n        BD_VALUE big_endian_values;\n        r->buffer.memcpy_ro((uint8_t*)&big_endian_values, sizeof(BD_VALUE));\n        if (sizeof(BD_VALUE) == 8) {\n            big_endian_values = htobe64(big_endian_values);\n        } else {\n            big_endian_values = htobe32(big_endian_values);\n        }\n        nv = big_endian_values >> (BD_VALUE_SIZE - bits);\n        count += bits;\n        r->buffer += (bits >> 3);\n        value = r->value | (nv << (shift & 0x7));\n    } else {\n        const int bits_over = (int)(shift + CHAR_BIT - bits_left);\n        int loop_end = 0;\n        if (bits_over >= 0) {\n            count += LOTS_OF_BITS;\n            loop_end = bits_over;\n        }\n        \n        if (bits_over < 0 || bits_left) {\n            while (shift >= loop_end) {\n                count += CHAR_BIT;\n                uint8_t cur_val = 0;\n                r->buffer.memcpy_ro(&cur_val, 1);\n                r->buffer += 1;\n                value |= ((BD_VALUE)cur_val) << shift;\n                shift -= CHAR_BIT;\n            }\n        }\n    }\n    // NOTE: Variable 'buffer' may not relate to 'r->buffer' after decryption,\n    // so we increase 'r->buffer' by the amount that 'buffer' moved, rather than\n    // assign 'buffer' to 'r->buffer'.\n    r->value = value;\n    r->count = count;\n}\n\n\n  // Check if we have reached the end of the buffer.\n  //\n  // Variable 'count' stores the number of bits in the 'value' buffer, minus\n  // 8. The top byte is part of the algorithm, and the remainder is buffered\n  // to be shifted into it. So if count == 8, the top 16 bits of 'value' are\n  // occupied, 8 for the algorithm and 8 in the buffer.\n  //\n  // When reading a byte from the user's buffer, count is filled with 8 and\n  // one byte is filled into the value buffer. When we reach the end of the\n  // data, count is additionally filled with LOTS_OF_BITS. So when\n  // count == LOTS_OF_BITS - 1, the user's data has been exhausted.\n  //\n  // 1 if we have tried to decode bits after the end of stream was encountered.\n  // 0 No error.\n#define vpx_reader_has_error(r) ((r)->count > BD_VALUE_SIZE && (r)->count < LOTS_OF_BITS)\n\nextern int r_bitcount;\nconstexpr static uint8_t vpx_norm[256] = {\n        0, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\n/*\ninline unsigned int count_leading_zeros_uint8(uint8_t split) {\n    unsigned int shift = 0;\n    if (split < 128) {\n        shift = 1;\n    }\n    if (split < 64) {\n        shift = 2;\n    }\n    if (split < 32) {\n        shift = 3;\n    }\n    if (split < 16) {\n        shift = 4;\n    }\n    if (split < 8) {\n        shift = 5;\n    }\n    if (split < 4) {\n        shift = 6;\n    }\n    if (split == 1) {\n        shift = 7;\n    }\n    return shift;\n}\n    */\n#ifndef _WIN32\n__attribute__((always_inline))\n#endif\ninline uint8_t count_leading_zeros_uint8(uint8_t v) {\n    return vpx_norm[v];\n    dev_assert(v);\n    return __builtin_clz((uint32_t)v) - 24; // slower\n    uint8_t r = 0; // result of log2(v) will go here\n    if (v & 0xf0) {\n        r |= 4;\n        v >>= 4;\n    }\n    if (v & 0xc) {\n        v >>= 2;\n        r |= 2;\n    }\n    if (v & 0x2) {\n        v >>= 1;\n        r |= 1;\n    }\n    return 7 - r;\n}\n\ninline bool vpx_reader_fill_and_read(vpx_reader *r, unsigned int split, Billing bill) {\n    BD_VALUE bigsplit = (BD_VALUE)split << (BD_VALUE_SIZE - CHAR_BIT);\n    vpx_reader_fill(r);\n    BD_VALUE value = r->value;\n    bool bit = (value >= bigsplit);\n    int count = r->count;\n\n\n    unsigned int range;\n\n    if (bit) {\n        range = r->range - split;\n        value = value - bigsplit;\n    } else {\n        range = split;\n    }\n    //unsigned int shift = vpx_norm[range];\n    unsigned int shift = count_leading_zeros_uint8(range);\n    range <<= shift;\n    value <<= shift;\n    count -= shift;\n    write_bit_bill(bill, true, shift);\n    r->value = value;\n    r->count = count;\n    r->range = range;\n\n    return bit;\n}\n#ifndef _WIN32\n__attribute__((always_inline))\n#endif\ninline bool vpx_read(vpx_reader *r, int prob, Billing bill) {\n  unsigned int split = (r->range * prob + (256 - prob)) >> CHAR_BIT;\n  BD_VALUE value = r->value;\n  int count = r->count;\n  BD_VALUE bigsplit = (BD_VALUE)split << (BD_VALUE_SIZE - CHAR_BIT);\n  bool bit = (value >= bigsplit);\n  unsigned int range;\n  if (bit) {\n    range = r->range - split;\n    value = value - bigsplit;\n  } else {\n    range = split;\n  }\n  if (__builtin_expect(r->count < 0, 0)) {\n      bit = vpx_reader_fill_and_read(r, split, bill);\n#ifdef DEBUG_ARICODER\n      fprintf(stderr, \"R %d %d %d\\n\", r_bitcount++, prob, bit);\n#endif\n      return bit;\n  }\n  //unsigned int shift = vpx_norm[range];\n  unsigned int shift = count_leading_zeros_uint8(range);\n  range <<= shift;\n  value <<= shift;\n  count -= shift;\n  write_bit_bill(bill, true, shift);\n  r->value = value;\n  r->count = count;\n  r->range = range;\n#ifdef DEBUG_ARICODER\n  fprintf(stderr, \"R %d %d %d\\n\", r_bitcount++, prob, bit);\n#endif\n\n  return bit;\n}\n\n#endif  // VPX_DSP_BITREADER_H_\n"], "fixing_code": ["/* -*-mode:c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/**\nCopyright (c) 2006...2016, Matthias Stirner and HTW Aalen University\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **/\n\n/*\nThis file contains special classes for bitwise\nreading and writing of arrays\n*/\n#include \"../../vp8/util/memory.hh\"\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <algorithm>\n#include <assert.h>\n#include \"bitops.hh\"\n\n#define BUFFER_SIZE 1024 * 1024\n/* -----------------------------------------------\n\tconstructor for abitreader class\n\t----------------------------------------------- */\t\n\nabitreader::abitreader( unsigned char* array, int size )\n{\n    cbyte2 = 0;\n    cbit2 = 0;\n    data2 = array;\n\teof = false;\n\tlbyte = size;\n    buf = 0;\n}\n\n/* -----------------------------------------------\n\tdestructor for abitreader class\n\t----------------------------------------------- */\t\n\nabitreader::~abitreader( void )\n{\n}\n\n\n\n/* -----------------------------------------------\n\tconstructor for abitwriter class\n\t----------------------------------------------- */\t\n\nabitwriter::abitwriter( int size , int max_file_size)\n{\n    size_bound = max_file_size;\n    if (size_bound) {\n        size_bound += 8; // 64 bits of padding on the end\n    }\n    fillbit = 1;\n    adds    = 65536;\n    cbyte2   = 0;\n    cbit2    = 64;\n    buf = 0;\n\n    error = false;\n    fmem  = true;\n    dsize = ( size > 0 ) ? size : adds;\n    data2 = ( unsigned char* ) custom_calloc (dsize);\n    if ( data2 == NULL ) {\n        error = true;\n        custom_exit(ExitCode::MALLOCED_NULL);\n        return;\n    }\n\t// for ( int i = 0; i < dsize; i++ ) data[i] = 0;\n}\n\n/* -----------------------------------------------\n\tdestructor for abitwriter class\n\t----------------------------------------------- */\t\n\nabitwriter::~abitwriter( void )\n{\n\t// free memory if pointer was not given out\n    if ( fmem )\tcustom_free( data2 );\n}\n\n\nvoid aligned_dealloc(unsigned char *data) {\n    if (!data) return;\n    data -= data[-1];\n    custom_free(data);\n}\nunsigned char *aligned_alloc(size_t dsize) {\n    unsigned char*data = (unsigned char*) custom_malloc( dsize + 16);\n    if (data) {\n        size_t rem = (size_t)(data - 0) & 0xf;\n        if (rem) {\n            data += rem;\n            data[-1] = rem;\n        } else {\n            data += 0x10;\n            data[-1] = 0x10;\n        }\n    }\n    return data;\n}\n/* -----------------------------------------------\n\tconstructor for abytewriter class\n\t----------------------------------------------- */\t\n\nabytewriter::abytewriter( int size )\n{\n\tadds  = 65536;\n\tcbyte = 0;\n\t\n\terror = false;\n\tfmem  = true;\n\t\n\tdsize = ( size > 0 ) ? size : adds;\n    data = aligned_alloc(dsize);\n\tif ( data == NULL ) {\n\t\terror = true;\n        custom_exit(ExitCode::MALLOCED_NULL);\n\t\treturn;\n\t}\n}\n\n/* -----------------------------------------------\n\tdestructor for abytewriter class\n\t----------------------------------------------- */\t\n\nabytewriter::~abytewriter( void )\n{\n\t// free data if pointer is not read\n\tif (fmem && data) aligned_dealloc(data);\n}\n\n/* -----------------------------------------------\n\twrites 1 byte to abytewriter\n\t----------------------------------------------- */\t\n\nvoid abytewriter::write( unsigned char byte )\n{\n\t// safety check for error\n\tif ( error ) return;\n\t\n\t// test if pointer beyond flush threshold\n\tif ( cbyte >= ( dsize - 2 ) ) {\n        if (data) {\n            unsigned char * newData = aligned_alloc(dsize *  2);\n            memcpy(newData, data, dsize);\n            dsize *= 2;\n            aligned_dealloc(data);\n            data = newData;\n        }\n\t\tif ( data == NULL ) {\n\t\t\terror = true;\n            custom_exit(ExitCode::MALLOCED_NULL);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t// write data\n\tdata[ cbyte++ ] = byte;\n}\n\n/* -----------------------------------------------\n\twrites n byte to abytewriter\n\t----------------------------------------------- */\n\nvoid abytewriter::write_n( unsigned char* byte, int n )\n{\n\t// safety check for error\n\tif ( error ) return;\n\n\t// make sure that pointer doesn't get beyond flush threshold\n\twhile ( ( cbyte + n ) >= ( dsize - 2 ) ) {\n        unsigned char * newData = aligned_alloc(dsize *  2);\n        memcpy(newData, data, dsize);\n        dsize *= 2;\n        aligned_dealloc(data);\n        data = newData;\n\t\tif ( data == NULL ) {\n            error = true;\n            custom_exit(ExitCode::MALLOCED_NULL);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// copy data from array\n\twhile ( n-- > 0 )\n\t\tdata[ cbyte++ ] = *(byte++);\n}\n\n/* -----------------------------------------------\n\tgets data array from abytewriter\n\t----------------------------------------------- */\n\nunsigned char* abytewriter::getptr_aligned( void )\n{\n\t// forbid freeing memory\n\tfmem = false;\n\treturn data;\n}\n\n/* -----------------------------------------------\n\tpeeks into data array from abytewriter\n\t----------------------------------------------- */\n\t\nunsigned char* abytewriter::peekptr_aligned( void )\n{\n\treturn data;\n}\n\n/* -----------------------------------------------\n\tgets size of data array from abytewriter\n\t----------------------------------------------- */\t\n\nint abytewriter::getpos( void )\n{\n\treturn cbyte;\n}\n\n/* -----------------------------------------------\n\treset without realloc\n\t----------------------------------------------- */\t\n\t\nvoid abytewriter::reset( void )\n{\n\t// set position of current byte\n\tcbyte = 0;\n}\n\n\n/* -----------------------------------------------\n\tconstructor for abytewriter class\n\t----------------------------------------------- */\n\nabytereader::abytereader( unsigned char* array, int size )\n{\n\tcbyte = 0;\n\teof = false;\n\t\n\tdata = array;\n\tlbyte = size;\n\t\n\tif ( ( data == NULL ) || ( lbyte == 0 ) )\n\t\teof = true;\n}\n\n/* -----------------------------------------------\n\tdestructor for abytewriter class\n\t----------------------------------------------- */\n\nabytereader::~abytereader( void )\n{\n}\n\n/* -----------------------------------------------\n\treads 1 byte from abytereader\n\t----------------------------------------------- */\n\nint abytereader::read( unsigned char* byte )\n{\n\tif ( cbyte >= lbyte ) {\n\t\tcbyte = lbyte;\n\t\teof = true;\n\t\treturn 0;\n\t}\n\telse {\n\t\t*byte = data[ cbyte++ ];\n\t\treturn 1;\n\t}\n}\n\n/* -----------------------------------------------\n\treads n bytes from abytereader\n\t----------------------------------------------- */\n\t\nint abytereader::read_n( unsigned char* byte, int n )\n{\n\tint nl = lbyte - cbyte;\n\tint i;\n\t\n\tif ( nl < n ) {\n\t\tfor ( i = 0; i < nl; i++ )\n\t\t\tbyte[ i ] = data[ cbyte + i ];\n\t\tcbyte = lbyte;\n\t\teof = true;\n\t\treturn nl;\n\t}\n\telse {\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tbyte[ i ] = data[ cbyte + i ];\n\t\tcbyte += n;\n\t\treturn n;\n\t}\n}\n\n/* -----------------------------------------------\n\tgo to position in data\n\t----------------------------------------------- */\n\t\nvoid abytereader::seek( int pos )\n{\n\tif ( pos >= lbyte ) {\n\t\tcbyte = lbyte;\n\t\teof = true;\n\t}\n\telse {\n\t\tcbyte = pos;\n\t\teof = false;\n\t}\n}\n\n/* -----------------------------------------------\n\tgets size of current data\n\t----------------------------------------------- */\n\t\nint abytereader::getsize( void )\n{\n\treturn lbyte;\n}\n\n/* -----------------------------------------------\n\tgets current position from abytereader\n\t----------------------------------------------- */\t\n\nint abytereader::getpos( void )\n{\n\treturn cbyte;\n}\n\nbounded_iostream::bounded_iostream(Sirikata::DecoderWriter *w,\n                                   const std::function<void(Sirikata::DecoderWriter*, size_t)> &size_callback,\n                                   const Sirikata::JpegAllocator<uint8_t> &alloc) \n    : parent(w), err(Sirikata::JpegError::nil()) {\n    this->size_callback = size_callback;\n    buffer_position = 0;\n    byte_position = 0;\n    byte_bound = 0x7FFFFFFF;\n    num_bytes_attempted_to_write = 0;\n    set_bound(0);\n}\nvoid bounded_iostream::call_size_callback(size_t size) {\n    size_callback(parent, size);\n}\nbool bounded_iostream::chkerr() {\n    return err != Sirikata::JpegError::nil();\n}\n\nvoid bounded_iostream::set_bound(size_t bound) {\n    flush();\n    if (num_bytes_attempted_to_write > byte_bound) {\n        num_bytes_attempted_to_write = byte_bound;\n    }\n    byte_bound = bound;\n}\nvoid bounded_iostream::flush() {\n    if (buffer_position) {\n        write_no_buffer(buffer, buffer_position);\n        buffer_position = 0;\n    }\n}\nvoid bounded_iostream::close() {\n    flush();\n    parent->Close();\n}\n\nuint32_t bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {\n    //return iostream::write(from,tpsize,dtsize);\n    std::pair<unsigned int, Sirikata::JpegError> retval;\n    if (byte_bound != 0 && byte_position + bytes_to_write > byte_bound) {\n        size_t real_bytes_to_write = byte_bound - byte_position;\n        byte_position += real_bytes_to_write;\n        retval = parent->Write(reinterpret_cast<const unsigned char*>(from), real_bytes_to_write);\n        if (retval.first < real_bytes_to_write) {\n            err = retval.second;\n            return retval.first;\n        }\n        return bytes_to_write; // pretend we wrote it all\n    }\n    size_t total = bytes_to_write;\n    retval = parent->Write(reinterpret_cast<const unsigned char*>(from), total);\n    unsigned int written = retval.first;\n    byte_position += written;\n    if (written < total ) {\n        err = retval.second;\n        return written;\n    }\n    return bytes_to_write;\n}\n\nunsigned int bounded_iostream::getsize() {\n    return byte_position;\n}\n\nbounded_iostream::~bounded_iostream(){\n}\n\nibytestreamcopier::ibytestreamcopier(Sirikata::DecoderReader *p, unsigned int byte_offset,\n                                     unsigned int max_file_size,\n                                     const Sirikata::JpegAllocator<uint8_t> &alloc)\n    : ibytestream(p, byte_offset, alloc), side_channel(alloc) {\n    if (max_file_size) {\n        side_channel.reserve(max_file_size);\n    }\n}\nbool ibytestreamcopier::read_byte(unsigned char *output) {\n    bool retval = ibytestream::read_byte(output);\n    if (retval) {\n        side_channel.push_back(*output);\n    }\n    return retval;\n}\n\nunsigned int ibytestreamcopier::read(unsigned char *output, unsigned int size) {\n    unsigned int retval = ibytestream::read(output, size);\n    if (retval > 0) {\n        side_channel.insert(side_channel.end(), output, output + retval);\n    }\n    return retval;\n}\nibytestream::ibytestream(Sirikata::DecoderReader *p, unsigned int byte_offset,\n                         const Sirikata::JpegAllocator<uint8_t> &alloc) \n    : parent(p) {\n    bytes_read = byte_offset;\n}\n\nunsigned int ibytestream::read(unsigned char*output, unsigned int size) {\n    dev_assert(size);\n    if (size == 1) {\n        return read_byte(output) ? 1 : 0;\n    }\n    int retval = IOUtil::ReadFull(parent, output, size);\n    bytes_read += retval;\n    static_assert(sizeof(last_read) == 2, \"Last read must hold full jpeg huffman\");\n    if (retval >= 2) {\n        memcpy(last_read, output + size - sizeof(last_read), sizeof(last_read));\n    } else if (retval) {\n        last_read[0] = last_read[1];\n        last_read[1] = *output;\n    }\n    return retval;\n}\n\nbool ibytestream::read_byte(unsigned char *output) {\n    unsigned int retval = parent->Read(output, 1).first;\n    if (retval != 0) {\n        last_read[0] = last_read[1];\n        last_read[1] = *output;\n        bytes_read += 1;\n        return true;\n    }\n    return false;\n}\n", "/* -*-mode:c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/**\nCopyright (c) 2006...2016, Matthias Stirner and HTW Aalen University\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **/\n\n\n\n#include <assert.h>\n#include <cstring>\n#define RBITS( c, n )\t\t( c & ( 0xFF >> (8 - n) ) )\n#define LBITS( c, n )\t\t( c >> (8 - n) )\n#define MBITS( c, l, r )\t( RBITS( c,l ) >> r )\n#define RBITS16( c, n )\t\t( c & ( 0xFFFFFFFF >> (16 - n) ) )\n#define LBITS16( c, n )\t\t( c >> (16 - n) )\n#define MBITS16( c, l, r )\t( RBITS16( c,l ) >> r )\n#define RBITS32( c, n )\t\t( c & ( 0xFFFFFFFF >> (32 - n) ) )\n#define LBITS32( c, n )\t\t( c >> (32 - n) )\n#define MBITS32( c, l, r )\t( RBITS32( c,l ) >> r )\n\n#define RBITS64( c, n )\t\t(n == 0 ? 0ULL : ( (c) & ( 0xFFFFFFFFFFFFFFFFULL >> (64 - (n)) ) ))\n#define LBITS64( c, n )\t\t( c >> (64 - n) )\n#define MBITS64( c, l, r )\t(((r) >= 64) ? 0 : ( RBITS64( c,l ) >> (r) ))\n\n#define BITN( c, n )\t\t( (c >> n) & 0x1 )\n#define FDIV2( v, p )\t\t( ( v < 0 ) ? -( (-v) >> p ) : ( v >> p ) )\n\n#define BTST_BUFF\t\t\t1024 * 1024\n\n#include <stdio.h>\n#include <functional>\n#include \"../io/Reader.hh\"\n#include \"../io/ioutil.hh\"\n#include \"../vp8/util/vpx_config.hh\"\n\n/* -----------------------------------------------\n\tclass to write arrays bitwise\n\t----------------------------------------------- */\n\nclass abitwriter\n{\n    unsigned char* data2;\npublic:\n    uint64_t buf;\n    int dsize;\n    int adds;\n    int cbyte2;\n    int cbit2;\n    bool fmem;\n    int size_bound;\npublic:\n    void debug() const;\n\n    \n    abitwriter( int size, int size_bound);\n\t~abitwriter( void );\n    \n    unsigned char* partial_bytewise_flush() {\n        if (__builtin_expect(bound_reached(), 0)) {\n            return data2;\n        }\n        int partial_byte_bits = (64 - cbit2) & 7;\n        uint64_t xbuf = htobe64(buf);\n        uint32_t bytes_to_write = (64 - (cbit2 + partial_byte_bits)) / 8;\n        uint32_t bits_to_write = (bytes_to_write << 3);\n        memcpy(data2 + cbyte2, &xbuf, bytes_to_write);\n        cbyte2 += bytes_to_write;\n        if (bits_to_write > 63) {\n            buf = 0;\n        } else {\n            buf <<= bits_to_write;\n        }\n        cbit2 += bits_to_write;\n        return data2;\n    }\n    void flush_no_pad() {\n        if (__builtin_expect(bound_reached(), 0)) {\n            return;\n        }\n        always_assert(((64 - cbit2) & 7) == 0);\n        buf = htobe64(buf);\n        uint32_t bytes_to_write = (64 - cbit2) / 8;\n        memcpy(data2 + cbyte2, &buf, bytes_to_write);\n        cbyte2 += bytes_to_write;\n        buf = 0;\n        //assert(cbyte +1 == cbyte2 || cbyte == cbyte2 || cbyte == cbyte2 + 1 || cbyte == cbyte2 + 2 || cbyte == cbyte2 + 3);\n        //assert(memcmp(data2, data, cbyte2) == 0);\n        \n        cbit2 = 64;\n    }\n    /* -----------------------------------------------\n     writes n bits to abitwriter\n     ----------------------------------------------- */\n    \n    void write( unsigned int val, int nbits )\n    {\n\n        int nbits2 = nbits;\n        unsigned int val2 = val;\n        dev_assert(nbits <= 64);\n        if ( __builtin_expect(cbyte2 > ( dsize - 16 ), false) ) {\n            if (bound_reached()) {\n                return;\n            }\n            if (adds < 4096 * 1024) {\n                adds <<= 1;\n            }\n            int new_size = dsize + adds;\n            unsigned char * tmp = (unsigned char*)custom_malloc(new_size);\n            if ( tmp == NULL ) {\n                error = true;\n                custom_exit(ExitCode::MALLOCED_NULL);\n                return;\n            }\n            memset(tmp + dsize, 0, adds);\n            memcpy(tmp, data2, dsize);\n            custom_free(data2);\n            data2 = tmp;\n            dsize = new_size;\n        }\n\n        // write data\n        if ( nbits2 >= cbit2 ) {\n\n            buf |= MBITS64(val2, nbits2, (nbits2-cbit2));\n            nbits2 -= cbit2;\n            cbit2 = 0;\n            flush_no_pad();\n        }\n        if ( nbits2 > 0 ) {\n            uint64_t tmp = (RBITS64(val2, nbits2));\n            if (__builtin_expect(cbit2 < nbits2, 0)) {\n                cbit2 = 0;\n            } else {\n                tmp <<= cbit2 - nbits2;\n                buf |= tmp;\n                cbit2 -= nbits2;\n            }\n        }\n\n\n\n    }\n    void pad ( unsigned char fillbit ) {\n        int offset = 1;\n        while ((cbit2 & 7) && cbyte2 < size_bound) {\n            write( (fillbit & offset) ? 1 : 0, 1 );\n            offset <<= 1;\n        }\n        flush_no_pad();\n    }\n    unsigned char* getptr( void ) {\n        // data is padded here\n        pad( fillbit );\n        flush_no_pad();\n        // forbid freeing memory\n        fmem = false;\n        // realloc data\n        return data2;\n    }\n    const unsigned char* peekptr( void ) {\n        flush_no_pad();\n        return data2;\n    }\n    uint8_t get_num_overhang_bits() {\n        return 64 - cbit2;\n    }\n    bool bound_reached() const {\n        return cbyte2 >= size_bound;\n    }\n    uint8_t get_overhang_byte() const {\n        dev_assert(cbit2 > 56);\n        uint64_t retval = buf;\n        retval >>= 56;\n        return (uint8_t) retval;\n    }\n    void reset_from_overhang_byte_and_num_bits(uint8_t overhang_byte,\n                                               uint8_t num_bits) {\n        memset(data2, 0, cbyte2);\n        if (size_bound) {\n            size_bound -=cbyte2;\n        }\n        cbyte2 = 0;\n        buf = 0;\n        buf = overhang_byte;\n        buf <<= 56;\n        cbit2 = 64 - num_bits;\n    }\n    void reset() {\n        dev_assert(no_remainder());\n        reset_crystallized_bytes();\n    }\n    void reset_crystallized_bytes() {\n        memset(data2, 0, cbyte2);\n        if (size_bound) {\n            size_bound -=cbyte2;\n        }\n        cbyte2 = 0;\n    }\n    int getpos( void ) const {\n        return cbyte2;\n    }\n    bool no_remainder() const {\n        return cbit2 == 64 || bound_reached();\n    }\n\tbool error;\t\n\tunsigned char fillbit;\n\t\n};\n\n/* -----------------------------------------------\n\tclass to read arrays bitwise\n\t----------------------------------------------- */\n\nclass abitreader\n{\npublic:\n\tabitreader( unsigned char* array, int size );\n\t~abitreader( void );\n    std::pair<uint8_t, uint8_t> overhang()\n    {\n        uint64_t selected_byte = htobe64(buf);\n        uint8_t rem = (uint8_t)((64 - cbit2) & 7);\n        if (rem != 64) {\n            uint8_t shift_level = (64 - cbit2) - rem;\n            if (shift_level < 64) {\n                selected_byte >>= shift_level;\n            } else {\n                selected_byte = 0;\n            }\n        }\n        uint8_t selected_bits = (uint8_t)selected_byte;\n        selected_bits &= (((1 << rem) - 1) << (8 - rem));\n        return {rem, selected_bits};\n    }\n\tunsigned int read( int nbits ) {\n        if (__builtin_expect(eof || !nbits, 0)) {\n            return 0;\n        }\n        unsigned int bits_read = 0;\n        unsigned int retval2 = 0;\n        if (__builtin_expect(nbits >= cbit2, 0)) {\n            bits_read = cbit2;\n            retval2 = (RBITS64(buf, cbit2) << (nbits - bits_read)) & ((1 << nbits) - 1);\n            int cur_nbits = nbits - bits_read;\n            buf >>= bits_read;\n            cbit2 -= bits_read;\n            if (cbyte2 == lbyte && cbit2 == 0) {\n                eof = true;\n                return retval2;\n            }\n            if (__builtin_expect(lbyte - cbyte2 < (int)sizeof(buf), 0)) {\n                int new_bytes = std::min((int)sizeof(buf), lbyte - cbyte2);\n                memcpy(&buf, &data2[cbyte2], new_bytes);\n                buf = htobe64(buf);\n                buf >>= (sizeof(buf) - new_bytes) * 8;\n                cbyte2 += new_bytes;\n                cbit2 += new_bytes * 8;\n            } else {\n                memcpy(&buf, &data2[cbyte2], sizeof(buf));\n                buf = htobe64(buf);\n                cbyte2 += sizeof(buf);\n                cbit2 += sizeof(buf) * 8;\n            }\n            if (cbyte2 == lbyte && cbit2 == 0) {\n                eof = true;\n            }\n            if (cur_nbits) {\n                if (cur_nbits <= cbit2) {\n                    retval2 |= MBITS64(buf, cbit2, (cbit2-cur_nbits));\n                    cbit2 -= cur_nbits;\n                } else {\n                    retval2 |= buf;\n                    buf = 0;\n                    cbit2 = 0;\n                }\n            }\n        } else {\n            retval2 = MBITS64(buf, cbit2, (cbit2-nbits));\n            cbit2 -= nbits;\n        }\n        return retval2;\n    }\n    bool remainder() {\n        if (cbit2 & 7) {\n            return 8 - (cbit2 &7);\n        } return 0;\n    }\n\tunsigned char unpad( unsigned char fillbit ) {\n        if ((cbit2 & 7) == 0 || eof) return fillbit;\n        else {\n            char last_bit = read( 1 );\n            fillbit = last_bit;\n            int offset = 1;\n            while (cbit2 & 7) {\n                last_bit = read( 1 );\n                fillbit |= (last_bit << offset);\n                ++offset;\n            }\n            while(offset < 7) {\n                fillbit |= (last_bit << offset);\n                ++offset;\n            }\n        }\n        return fillbit;\n    }\n\tint getpos( void ) {\n        return cbyte2 - 7 + ((64 - cbit2) >> 3);\n    }\n    uint64_t debug_peek(void) {\n        uint64_t retval = 0;\n        abitreader tmp(*this);\n        bool had_remainder = false;\n        while (tmp.remainder()) {\n            had_remainder = true;\n            retval = tmp.read(tmp.remainder());\n        }\n        for (int i = 0 ;i < (had_remainder ? 7 : 8);++i) {\n            uint8_t a = tmp.read(8);\n            retval |= a;\n            retval <<= 8;\n        }\n        return retval;\n    }\n    bool eof;\nprivate:\n    unsigned char* data2;\n    int cbyte2;\n    int cbit2;\n    uint64_t buf;\n\tint lbyte;\n};\n\n/* -----------------------------------------------\n\tclass to write arrays bytewise\n\t----------------------------------------------- */\nextern void aligned_dealloc(unsigned char*);\nextern unsigned char * aligned_alloc(size_t);\n\nclass abytewriter\n{\npublic:\n\tabytewriter( int size );\n\t~abytewriter( void );\t\n\tvoid write( unsigned char byte );\n\tvoid write_n( unsigned char* byte, int n );\n\tunsigned char* getptr_aligned( void );\n\tunsigned char* peekptr_aligned( void );\n\tint getpos( void );\n\tvoid reset( void );\n\tbool error;\t\n\t\nprivate:\n\tunsigned char* data;\n\tint dsize;\n\tint adds;\n\tint cbyte;\n\tbool fmem;\n};\n\n\n/* -----------------------------------------------\n\tclass to read arrays bytewise\n\t----------------------------------------------- */\n\nclass abytereader\n{\npublic:\n\tabytereader( unsigned char* array, int size );\n\t~abytereader( void );\t\n\tint read( unsigned char* byte );\n\tint read_n( unsigned char* byte, int n );\n\tvoid seek( int pos );\n\tint getsize( void );\n\tint getpos( void );\n\tbool eof;\t\n\t\nprivate:\n\tunsigned char* data;\n\tint lbyte;\n\tint cbyte;\n};\n\n\n/* -----------------------------------------------\n\tclass for input and output from file or memory\n\t----------------------------------------------- */\n\nclass ibytestream {\n    Sirikata::DecoderReader* parent;\n    unsigned int bytes_read;\npublic:\n\tunsigned char get_last_read() const {\n        return last_read[1];\n    }\n\tunsigned char get_penultimate_read() const {\n        return last_read[0];\n    }\n    ibytestream(Sirikata::DecoderReader *p,\n                unsigned int starting_byte_offset,\n                const Sirikata::JpegAllocator<uint8_t> &alloc);\n    unsigned int getsize() const {\n        return bytes_read;\n    }\n    bool read_byte(unsigned char *output);\n    unsigned int read(unsigned char *output, unsigned int size);\n    // the biggest allowed huffman code (that may get damaged by truncation)\n    unsigned char last_read[2];\n};\nclass ibytestreamcopier : ibytestream{ // since we don't use virtual methods... must reimplement\n    std::vector<uint8_t, Sirikata::JpegAllocator<uint8_t> > side_channel;\npublic:\n    ibytestreamcopier(Sirikata::DecoderReader *p,\n                      unsigned int starting_byte_offset,\n                      unsigned int maximum_file_size,\n                      const Sirikata::JpegAllocator<uint8_t> &alloc);\n    unsigned int getsize() const {\n        return ibytestream::getsize();\n    }\n    unsigned int get_last_read() const {\n        return ibytestream::get_last_read();\n    }\n    unsigned int get_penultimate_read() const {\n        return ibytestream::get_penultimate_read();\n    }\n\n    bool read_byte(unsigned char *output);\n    unsigned int read(unsigned char *output, unsigned int size);\n\n    const std::vector<uint8_t,\n                      Sirikata::JpegAllocator<uint8_t> >&get_read_data() const {\n        return side_channel;\n    }\n    std::vector<uint8_t, Sirikata::JpegAllocator<uint8_t> >&mutate_read_data() {\n        return side_channel;\n    }\n};\n\nclass bounded_iostream\n{\n    enum {\n        buffer_size = 65536\n    };\n    uint8_t buffer[buffer_size];\n    uint32_t buffer_position;\n    Sirikata::DecoderWriter *parent;\n    uint32_t byte_bound;\n    uint32_t byte_position;\n    uint32_t num_bytes_attempted_to_write;\n    Sirikata::JpegError err;\n    std::function<void(Sirikata::DecoderWriter*, size_t)> size_callback;\n    uint32_t write_no_buffer( const void* from, size_t bytes_to_write );\npublic:\n\tbounded_iostream( Sirikata::DecoderWriter * parent,\n                      const std::function<void(Sirikata::DecoderWriter*, size_t)> &size_callback,\n                      const Sirikata::JpegAllocator<uint8_t> &alloc);\n\t~bounded_iostream( void );\n    void call_size_callback(size_t size);\n    bool chkerr();\n    unsigned int getsize();\n    unsigned int bytes_written()const {\n        return std::max(byte_position,\n                        std::min(byte_position + buffer_position, byte_bound));\n    }\n    void set_bound(size_t bound); // bound of zero = fine\n    size_t get_bound() const {\n        return byte_bound;\n    }\n    bool has_reached_bound() const {\n        return byte_bound && byte_position + buffer_position >= byte_bound;\n    }\n    bool has_exceeded_bound() const {\n        return byte_bound && num_bytes_attempted_to_write > byte_bound;\n    }\n    unsigned int write_byte(uint8_t byte) {\n        ++num_bytes_attempted_to_write;\n        dev_assert(buffer_position < buffer_size && \"Full buffer wasn't flushed\");\n        buffer[buffer_position++] = byte;\n        if (__builtin_expect(buffer_position == buffer_size, 0)) {\n            buffer_position = 0;\n            write_no_buffer(buffer, buffer_size);\n        }\n        return 1;\n    }\n    unsigned int write(const void *from, unsigned int nbytes) {\n        num_bytes_attempted_to_write += nbytes;\n        size_t bytes_to_write = nbytes;\n        if (__builtin_expect(nbytes + buffer_position > buffer_size, 0)) {\n            if (buffer_position) {\n                write_no_buffer(buffer, buffer_position);\n                buffer_position = 0;\n            }\n            if (bytes_to_write < 64) {\n                memcpy(buffer + buffer_position, from, bytes_to_write);\n                buffer_position += bytes_to_write;\n            } else {\n                return write_no_buffer(from, bytes_to_write);\n            }\n        } else {\n            memcpy(buffer + buffer_position, from, bytes_to_write);\n            buffer_position += bytes_to_write;\n            if (__builtin_expect(buffer_position == buffer_size, 0)) {\n                 buffer_position = 0;\n                write_no_buffer(buffer, buffer_size);\n            }\n        }\n        return bytes_to_write;\n    }\n    void flush();\n    void close();\n};\n", "#include \"lepton_codec.hh\"\n#include \"uncompressed_components.hh\"\n#include \"../vp8/decoder/decoder.hh\"\n\n\n\ntemplate<class Left, class Middle, class Right, bool force_memory_optimization>\nvoid LeptonCodec::ThreadState::decode_row(Left & left_model,\n                                          Middle& middle_model,\n                                          Right& right_model,\n                                          int curr_y,\n                                          BlockBasedImagePerChannel<force_memory_optimization>& image_data,\n                                          int component_size_in_block) {\n    uint32_t block_width = image_data[(int)middle_model.COLOR]->block_width();\n    if (block_width > 0) {\n        BlockContext context = context_.at((int)middle_model.COLOR);\n        parse_tokens(context,\n                     bool_decoder_,\n                     left_model,\n                     model_); //FIXME\n        int offset = image_data[middle_model.COLOR]->next(context_.at((int)middle_model.COLOR), true, curr_y);\n        if (offset >= component_size_in_block) {\n            return;\n        }\n    }\n    for (unsigned int jpeg_x = 1; jpeg_x + 1 < block_width; jpeg_x++) {\n        BlockContext context = context_.at((int)middle_model.COLOR);\n        parse_tokens(context,\n                     bool_decoder_,\n                     middle_model,\n                     model_); //FIXME\n        int offset = image_data[middle_model.COLOR]->next(context_.at((int)middle_model.COLOR),\n\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t  curr_y);\n        if (offset >= component_size_in_block) {\n            return;\n        }\n    }\n    if (block_width > 1) {\n        BlockContext context = context_.at((int)middle_model.COLOR);\n        parse_tokens(context,\n                     bool_decoder_,\n                     right_model,\n                     model_);\n        image_data[middle_model.COLOR]->next(context_.at((int)middle_model.COLOR), false, curr_y);\n    }\n}\n#ifdef ALLOW_FOUR_COLORS\n#define ProbabilityTablesTuple(left, above, right) \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR0>, \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR1>, \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR2>, \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR3>\n#define EACH_BLOCK_TYPE(left, above, right) ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR0>(BlockType::Y, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right), \\\n                        ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR1>(BlockType::Cb, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right), \\\n                        ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR2>(BlockType::Cr, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right), \\\n                        ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR3>(BlockType::Ck, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right)\n#else\n#define ProbabilityTablesTuple(left, above, right) \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR0>, \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR1>, \\\n    ProbabilityTables<left && above && right, TEMPLATE_ARG_COLOR2>\n#define EACH_BLOCK_TYPE(left, above, right) ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR0>(BlockType::Y, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right), \\\n                        ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR1>(BlockType::Cb, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right), \\\n                        ProbabilityTables<left&&above&&right, TEMPLATE_ARG_COLOR2>(BlockType::Cr, \\\n                                                                                   left, \\\n                                                                                   above, \\\n                                                                                   right)\n#endif\n\n\n\n\nvoid LeptonCodec::ThreadState::decode_row_wrapper(BlockBasedImagePerChannel<true>& image_data,\n                                          Sirikata::Array1d<uint32_t,\n                                                            (uint32_t)ColorChannel::\n                                                            NumBlockTypes> component_size_in_blocks,\n                                          int component,\n                                          int curr_y) {\n    return decode_rowt(image_data, component_size_in_blocks, component, curr_y);\n}\nvoid LeptonCodec::ThreadState::decode_rowf(BlockBasedImagePerChannel<false>& image_data,\n                                          Sirikata::Array1d<uint32_t,\n                                                            (uint32_t)ColorChannel::\n                                                            NumBlockTypes> component_size_in_blocks,\n                                          int component,\n                                          int curr_y) {\n    decode_row_internal(image_data, component_size_in_blocks,component,curr_y);\n}\nvoid LeptonCodec::ThreadState::decode_rowt(BlockBasedImagePerChannel<true>& image_data,\n                                          Sirikata::Array1d<uint32_t,\n                                                            (uint32_t)ColorChannel::\n                                                            NumBlockTypes> component_size_in_blocks,\n                                          int component,\n                                          int curr_y) {\n    decode_row_internal(image_data, component_size_in_blocks,component,curr_y);\n}\ntemplate<bool force_memory_optimization>\nvoid LeptonCodec::ThreadState::decode_row_internal(BlockBasedImagePerChannel<force_memory_optimization>& image_data,\n                                          Sirikata::Array1d<uint32_t,\n                                                            (uint32_t)ColorChannel::\n                                                            NumBlockTypes> component_size_in_blocks,\n                                          int component,\n                                          int curr_y) {\n    using std::tuple;\n    tuple<ProbabilityTablesTuple(false, false, false)> corner(EACH_BLOCK_TYPE(false,false,false));\n    tuple<ProbabilityTablesTuple(true, false, false)> top(EACH_BLOCK_TYPE(true,false,false));\n    tuple<ProbabilityTablesTuple(false, true, true)> midleft(EACH_BLOCK_TYPE(false, true, true));\n    tuple<ProbabilityTablesTuple(true, true, true)> middle(EACH_BLOCK_TYPE(true,true,true));\n    tuple<ProbabilityTablesTuple(true, true, false)> midright(EACH_BLOCK_TYPE(true, true, false));\n    tuple<ProbabilityTablesTuple(false, true, false)> width_one(EACH_BLOCK_TYPE(false, true, false));\n    context_.at(component)\n        = image_data[component]->off_y(curr_y,\n                                       num_nonzeros_.at(component).begin());\n    \n    int block_width = image_data[component]->block_width();\n    if (is_top_row_.at(component)) {\n        is_top_row_.at(component) = false;\n        switch((BlockType)component) {\n          case BlockType::Y:\n            decode_row(std::get<(int)BlockType::Y>(corner),\n                       std::get<(int)BlockType::Y>(top),\n                       std::get<(int)BlockType::Y>(top),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            break;\n          case BlockType::Cb:\n            decode_row(std::get<(int)BlockType::Cb>(corner),\n                       std::get<(int)BlockType::Cb>(top),\n                       std::get<(int)BlockType::Cb>(top),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n          case BlockType::Cr:\n            decode_row(std::get<(int)BlockType::Cr>(corner),\n                       std::get<(int)BlockType::Cr>(top),\n                       std::get<(int)BlockType::Cr>(top),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#ifdef ALLOW_FOUR_COLORS\n          case BlockType::Ck:\n            decode_row(std::get<(int)BlockType::Ck>(corner),\n                       std::get<(int)BlockType::Ck>(top),\n                       std::get<(int)BlockType::Ck>(top),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#endif\n        }\n    } else if (block_width > 1) {\n        dev_assert(curr_y); // just a sanity check that the zeroth row took the first branch\n        switch((BlockType)component) {\n          case BlockType::Y:\n            decode_row(std::get<(int)BlockType::Y>(midleft),\n                       std::get<(int)BlockType::Y>(middle),\n                       std::get<(int)BlockType::Y>(midright),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n          case BlockType::Cb:\n            decode_row(std::get<(int)BlockType::Cb>(midleft),\n                       std::get<(int)BlockType::Cb>(middle),\n                       std::get<(int)BlockType::Cb>(midright),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n          case BlockType::Cr:\n            decode_row(std::get<(int)BlockType::Cr>(midleft),\n                       std::get<(int)BlockType::Cr>(middle),\n                       std::get<(int)BlockType::Cr>(midright),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#ifdef ALLOW_FOUR_COLORS\n          case BlockType::Ck:\n            decode_row(std::get<(int)BlockType::Ck>(midleft),\n                       std::get<(int)BlockType::Ck>(middle),\n                       std::get<(int)BlockType::Ck>(midright),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#endif\n        }\n    } else {\n        dev_assert(curr_y); // just a sanity check that the zeroth row took the first branch\n        dev_assert(block_width == 1);\n        switch((BlockType)component) {\n          case BlockType::Y:\n            decode_row(std::get<(int)BlockType::Y>(width_one),\n                       std::get<(int)BlockType::Y>(width_one),\n                       std::get<(int)BlockType::Y>(width_one),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n          case BlockType::Cb:\n            decode_row(std::get<(int)BlockType::Cb>(width_one),\n                       std::get<(int)BlockType::Cb>(width_one),\n                       std::get<(int)BlockType::Cb>(width_one),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n          case BlockType::Cr:\n            decode_row(std::get<(int)BlockType::Cr>(width_one),\n                       std::get<(int)BlockType::Cr>(width_one),\n                       std::get<(int)BlockType::Cr>(width_one),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#ifdef ALLOW_FOUR_COLORS\n          case BlockType::Ck:\n            decode_row(std::get<(int)BlockType::Ck>(width_one),\n                       std::get<(int)BlockType::Ck>(width_one),\n                       std::get<(int)BlockType::Ck>(width_one),\n                       curr_y,\n                       image_data,\n                       component_size_in_blocks[component]);\n            \n            break;\n#endif\n        }\n    }\n}\n\nCodingReturnValue LeptonCodec::ThreadState::vp8_decode_thread(unsigned int thread_id,\n                                                              UncompressedComponents *const colldata) {\n    Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes> component_size_in_blocks;\n    BlockBasedImagePerChannel<false> image_data;\n    for (int i = 0; i < colldata->get_num_components(); ++i) {\n        component_size_in_blocks[i] = colldata->component_size_in_blocks(i);\n        image_data[i] = &colldata->full_component_write((BlockType)i);\n    }\n    Sirikata::Array1d<uint32_t,\n                      (size_t)ColorChannel::NumBlockTypes> max_coded_heights\n        = colldata->get_max_coded_heights();\n    /* deserialize each block in planar order */\n\n    dev_assert(luma_splits_.size() == 2); // not ready to do multiple work items on a thread yet\n    always_assert(luma_splits_.size() >= 2);\n    int min_y = luma_splits_[0];\n    int max_y = luma_splits_[1];\n    while(true) {\n        RowSpec cur_row = row_spec_from_index(decode_index_++, image_data, colldata->get_mcu_count_vertical(), max_coded_heights);\n        if (cur_row.done) {\n            break;\n        }\n        if (cur_row.luma_y >= max_y && thread_id + 1 != NUM_THREADS) {\n            break;\n        }\n        if (cur_row.skip) {\n            continue;\n        }\n        if (cur_row.luma_y < min_y) {\n            continue;\n        }\n        decode_rowf(image_data,\n                   component_size_in_blocks,\n                   cur_row.component,\n                   cur_row.curr_y);\n        if (thread_id == 0) {\n            colldata->worker_update_cmp_progress((BlockType)cur_row.component,\n                                                 image_data[cur_row.component]->block_width() );\n        }\n        return CODING_PARTIAL;\n    }\n    return CODING_DONE;\n}\n", "/* -*-mode:c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <tuple>\n\n#include \"bitops.hh\"\n#include \"component_info.hh\"\n#include \"uncompressed_components.hh\"\n#include \"jpgcoder.hh\"\n#include \"vp8_decoder.hh\"\n\n#include \"../io/Reader.hh\"\n#include \"../vp8/decoder/decoder.hh\"\nusing namespace std;\n\nvoid VP8ComponentDecoder::initialize( Sirikata::DecoderReader *input,\n                                      const std::vector<ThreadHandoff>& thread_handoff)\n{\n    str_in = input;\n    mux_reader_.init(input);\n    thread_handoff_ = thread_handoff;\n}\nvoid VP8ComponentDecoder::decode_row(int target_thread_id,\n                                     BlockBasedImagePerChannel<true>& image_data, // FIXME: set image_data to true\n                                     Sirikata::Array1d<uint32_t,\n                                                       (uint32_t)ColorChannel::\n                                                       NumBlockTypes> component_size_in_blocks,\n                                     int component,\n                                     int curr_y) {\n    thread_state_[target_thread_id]->decode_rowt(image_data,\n                                               component_size_in_blocks,\n                                               component,\n                                               curr_y);\n}\n\n\nVP8ComponentDecoder::VP8ComponentDecoder(bool do_threading)\n    : VP8ComponentEncoder(do_threading),\n      mux_reader_(Sirikata::JpegAllocator<uint8_t>(),\n                  8,\n                  0) {\n    virtual_thread_id_ = -1;\n}\n\nVP8ComponentDecoder::~VP8ComponentDecoder() {\n}\n\n\n#ifdef ALLOW_FOUR_COLORS\n#define ProbabilityTablesTuple(left, above, right) \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR0>, \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR1>, \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR2>, \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR3>\n#define EACH_BLOCK_TYPE(left, above, right) BlockType::Y,   \\\n                        BlockType::Cb, \\\n                        BlockType::Cr, \\\n                        BlockType::Ck\n#else\n#define ProbabilityTablesTuple(left, above, right) \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR0>, \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR1>, \\\n    ProbabilityTables<left, above, right, TEMPLATE_ARG_COLOR2>\n#define EACH_BLOCK_TYPE BlockType::Y, \\\n                        BlockType::Cb, \\\n                        BlockType::Cr\n#endif\n\nvoid VP8ComponentDecoder::clear_thread_state(int thread_id, int target_thread_state, BlockBasedImagePerChannel<true>& framebuffer) {\n\n\n    initialize_thread_id(thread_id, target_thread_state, framebuffer);\n    initialize_bool_decoder(thread_id, target_thread_state);\n}\nclass ActualThreadPacketReader : public PacketReader{\n    GenericWorker *worker;\n    VP8ComponentDecoder::SendToActualThread *base;\n    uint8_t stream_id;\n    ResizableByteBufferListNode* last;\npublic:\n    ActualThreadPacketReader(uint8_t stream_id, GenericWorker*worker, VP8ComponentDecoder::SendToActualThread*base) {\n        this->worker = worker;\n        this->stream_id = stream_id;\n        this->base = base;\n    }\n    // returns a buffer with at least sizeof(BD_VALUE) before it\n    virtual ROBuffer getNext() {\n        if (!base->vbuffers[stream_id].empty()) {\n            auto retval = base->vbuffers[stream_id].front();\n            if (!retval->empty()) {\n                base->vbuffers[stream_id].pop();\n            }\n            if (retval->empty()) {\n                isEof = true;\n                return {NULL, NULL};\n            }\n            return {retval->data(), retval->data() + retval->size()};\n        }\n        while(!isEof) {\n            auto dat = worker->batch_recv_data();\n            for (unsigned int i = 0; i < dat.count; ++i) {\n                ResizableByteBufferListNode* lnode = (ResizableByteBufferListNode*) dat.data[i];\n                if (dat.count == 1 && lnode->stream_id == stream_id && lnode && lnode->size()) {\n                    assert(stream_id == lnode->stream_id);\n                    last = lnode;\n                    return {lnode->data(), lnode->data() + lnode->size()};\n                } else {\n                    base->vbuffers[lnode->stream_id].push(lnode);\n                }\n            }\n            if (!base->vbuffers[stream_id].empty()) {\n                return getNext(); // recursive call, 1 deep\n            }\n            if (dat.return_code < 0) {\n                isEof = true; // hmm... should we bail here?\n                always_assert(false);\n            }\n        }\n        return {NULL, NULL};\n    }\n    bool eof()const {\n        return isEof;\n    }\n    virtual void setFree(ROBuffer buffer) {// don't even bother\n        if (last && last->data() == buffer.first) {\n            delete last; // hax\n            last = NULL;\n        }\n    }\n    virtual ~ActualThreadPacketReader(){}\n};\nvoid VP8ComponentDecoder::worker_thread(ThreadState *ts, int thread_id, UncompressedComponents * const colldata,\n                                        int8_t thread_target[Sirikata::MuxReader::MAX_STREAM_ID],\n                                        GenericWorker *worker,\n                                        SendToActualThread *send_to_actual_thread_state) {\n    TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();\n    for (uint8_t i = 0; i < Sirikata::MuxReader::MAX_STREAM_ID; ++i) {\n        if (thread_target[i] == int8_t(thread_id)) {\n            ts->bool_decoder_.init(new ActualThreadPacketReader(i,worker, send_to_actual_thread_state));\n        }\n    }\n    while (ts->vp8_decode_thread(thread_id, colldata) == CODING_PARTIAL) {\n    }\n    TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();\n}\nclass VirtualThreadPacketReader : public PacketReader{\n    VP8ComponentDecoder::SendToVirtualThread*base;\n    uint8_t stream_id;\n    Sirikata::MuxReader*mux_reader_;\n    Sirikata::MuxReader::ResizableByteBuffer * last;\npublic:\n    VirtualThreadPacketReader(uint8_t stream_id, Sirikata::MuxReader * mr, VP8ComponentDecoder::SendToVirtualThread*base) {\n        this->base = base;\n        this->stream_id = stream_id;\n        this->mux_reader_ = mr;\n        last = NULL;\n    }\n    // returns a buffer with at least sizeof(BD_VALUE) before it\n    virtual ROBuffer getNext() {\n        auto retval = base->read(*mux_reader_, stream_id);\n        if (retval->size() == 0) {\n            isEof = true;\n            return {NULL, NULL};\n        }\n        always_assert(!retval->empty()); // we check this earlier\n        return {retval->data(), retval->data() + retval->size()};\n    }\n    bool eof()const {\n        return isEof;\n    }\n    virtual void setFree(ROBuffer buffer) {// don't even bother\n        if (last && last->data() == buffer.first) {\n            delete last; // hax\n            last = NULL;\n        }\n    }\n    virtual ~VirtualThreadPacketReader(){}\n};\n\nvoid VP8ComponentDecoder::initialize_bool_decoder(int thread_id, int target_thread_state) {\n    if (NUM_THREADS > 1 && g_threaded) {\n        thread_state_[target_thread_state]->bool_decoder_.init(new ActualThreadPacketReader(thread_id,\n                                                                                            getWorker(target_thread_state),\n                                                                                            &send_to_actual_thread_state));\n    } else {\n        thread_state_[target_thread_state]->bool_decoder_.init(new VirtualThreadPacketReader(thread_id, &mux_reader_, &mux_splicer));\n    }\n}\n\n    template <bool force_memory_optimized>\nvoid VP8ComponentDecoder::initialize_thread_id(int thread_id, int target_thread_state,\n                                               BlockBasedImagePerChannel<force_memory_optimized>& framebuffer) {\n    if (target_thread_state) {\n        always_assert(spin_workers_);\n    }\n    TimingHarness::timing[thread_id%NUM_THREADS][TimingHarness::TS_STREAM_MULTIPLEX_STARTED] = TimingHarness::get_time_us();\n    //if (thread_id != target_thread_state) {\n        reset_thread_model_state(target_thread_state);\n    //}\n    thread_state_[target_thread_state]->decode_index_ = 0;\n    for (unsigned int i = 0; i < framebuffer.size(); ++i) {\n        if (framebuffer[i] != NULL)  {\n            thread_state_[target_thread_state]->is_top_row_.at(i) = true;\n            thread_state_[target_thread_state]->num_nonzeros_.at(i).resize(framebuffer[i]->block_width() << 1);\n            thread_state_[target_thread_state]->context_.at(i)\n                = framebuffer[i]->begin(thread_state_[target_thread_state]->num_nonzeros_.at(i).begin());\n        }\n    }\n    /* initialize the bool decoder */\n    int index = thread_id;\n    always_assert((size_t)index < streams_.size());\n    \n    thread_state_[target_thread_state]->is_valid_range_ = false;\n    thread_state_[target_thread_state]->luma_splits_.resize(2);\n    if ((size_t)index < thread_handoff_.size()) {\n        thread_state_[target_thread_state]->luma_splits_[0] = thread_handoff_[thread_id].luma_y_start;\n        thread_state_[target_thread_state]->luma_splits_[1] = thread_handoff_[thread_id].luma_y_end;\n    } else {\n        // we have extra threads that are not in use during this decode.\n        // set them to zero sized work (i.e. starting at end and ending at end)\n        // since they don't have any rows to decode\n        thread_state_[target_thread_state]->luma_splits_[0] = thread_handoff_.back().luma_y_end; // <- not a typo\n        thread_state_[target_thread_state]->luma_splits_[1] = thread_handoff_.back().luma_y_end; // both start and end at end\n    }\n    //fprintf(stderr, \"tid: %d   %d -> %d\\n\", thread_id, thread_state_[target_thread_state]->luma_splits_[0],\n    //        thread_state_[target_thread_state]->luma_splits_[1]);\n    TimingHarness::timing[thread_id%NUM_THREADS][TimingHarness::TS_STREAM_MULTIPLEX_FINISHED] = TimingHarness::get_time_us();\n}\nstd::vector<ThreadHandoff> VP8ComponentDecoder::initialize_baseline_decoder(\n    const UncompressedComponents * const colldata,\n    Sirikata::Array1d<BlockBasedImagePerChannel<true>,\n                      MAX_NUM_THREADS>& framebuffer) {\n    mux_splicer.init(spin_workers_);\n    return initialize_decoder_state(colldata, framebuffer);\n}\n\nvoid VP8ComponentDecoder::SendToVirtualThread::set_eof() {\n    using namespace Sirikata;\n    if (!eof) {\n        for (unsigned int thread_id = 0; thread_id < Sirikata::MuxReader::MAX_STREAM_ID; ++thread_id) {\n            for (int i = 0; i < Sirikata::MuxReader::MAX_STREAM_ID; ++i) {\n                if (thread_target[i] == int8_t(thread_id)) {\n                    \n                    auto eof = new ResizableByteBufferListNode;\n                    eof->stream_id = i;\n                    send(eof); // sends an EOF flag (empty buffer)\n                }\n            }\n        }\n    }\n    eof = true;\n}\nVP8ComponentDecoder::SendToVirtualThread::SendToVirtualThread(){\n    eof = false;\n    for (int i = 0; i < Sirikata::MuxReader::MAX_STREAM_ID; ++i) {\n        thread_target[i] = -1;\n    }\n    this->all_workers = NULL;\n}\n\nvoid VP8ComponentDecoder::SendToVirtualThread::init(GenericWorker * all_workers) {\n    this->all_workers = all_workers;\n}\nvoid VP8ComponentDecoder::SendToVirtualThread::send(ResizableByteBufferListNode *data) {\n    always_assert(data);\n    always_assert(data->stream_id < sizeof(vbuffers) / sizeof(vbuffers[0]) &&\n                  \"INVALID SEND STREAM ID\");\n    if (!g_threaded || NUM_THREADS == 1) {\n        /*\n    fprintf(stderr, \"VSending (%d) %d bytes of data : ptr %p\\n\",\n            (int)data->stream_id, (int)data->size(),\n            (void*)data);*/\n        vbuffers[data->stream_id].push(data);\n        return;\n    }\n    auto thread_target_id = thread_target[data->stream_id];\n    /*\n    fprintf(stderr, \"Sending (%d) %d bytes of data : ptr %p to %d\\n\",\n            (int)data->stream_id, (int)data->size(),\n            (void*)data, thread_target_id);\n    */\n    if (thread_target_id >= 0) {\n        int retval = all_workers[thread_target_id].send_more_data(data);\n        always_assert(retval == 0 && \"Communication with thread lost\");\n    }else {\n        always_assert(false && \"Cannot send to thread that wasn't bound\");\n    }\n}\nvoid VP8ComponentDecoder::SendToVirtualThread::drain(Sirikata::MuxReader&reader) {\n    while (!reader.eof) {\n        ResizableByteBufferListNode *data = new ResizableByteBufferListNode;\n        auto ret = reader.nextDataPacket(*data);\n        if (ret.second != Sirikata::JpegError::nil()) {\n            set_eof();\n            break;\n        }\n        data->stream_id = ret.first;\n        always_assert(data->size()); // the protocol can't store empty runs\n        send(data);\n    }\n}\nResizableByteBufferListNode* VP8ComponentDecoder::SendToVirtualThread::read(Sirikata::MuxReader&reader, uint8_t stream_id) {\n    using namespace Sirikata;\n    always_assert(stream_id < sizeof(vbuffers) / sizeof(vbuffers[0]) &&\n                  \"INVALID READ STREAM ID\");\n    if (!vbuffers[stream_id].empty()) {\n        auto retval = vbuffers[stream_id].front();\n        if (retval->size() == 0) {\n            always_assert(eof);\n        } else { // keep this placeholder there\n            vbuffers[stream_id].pop();\n        }\n        return retval;\n    }\n    if (eof) {\n        always_assert(false);\n        return NULL;\n    }\n    while (!eof) {\n        ResizableByteBufferListNode *data = new ResizableByteBufferListNode;\n        auto ret = reader.nextDataPacket(*data);\n        if (ret.second != JpegError::nil()) {\n            set_eof();\n            break;\n        }\n        data->stream_id = ret.first;\n        bool buffer_it = ret.first != stream_id;\n        if (buffer_it) {\n            send(data);\n        } else {\n            return data;\n        }\n    }\n    if (!vbuffers[stream_id].empty()) {\n        auto retval = vbuffers[stream_id].front();\n        if (retval->size() == 0) {\n            always_assert(eof);\n        } else { // keep this placeholder there\n            vbuffers[stream_id].pop();\n        }\n        return retval;\n    }\n    return NULL;\n}\nvoid VP8ComponentDecoder::SendToVirtualThread::read_all(Sirikata::MuxReader&reader) {\n    using namespace Sirikata;\n    while (!eof) {\n        ResizableByteBufferListNode *data = new ResizableByteBufferListNode;\n        auto ret = reader.nextDataPacket(*data);\n        if (ret.second != JpegError::nil()) {\n            set_eof();\n            break;\n        }\n        data->stream_id = ret.first;\n        always_assert(data->size());\n        send(data);\n    }\n}\n\ntemplate <bool force_memory_optimized>\nstd::vector<ThreadHandoff> VP8ComponentDecoder::initialize_decoder_state(const UncompressedComponents * const colldata,\n                                                   Sirikata::Array1d<BlockBasedImagePerChannel<force_memory_optimized>,\n                                                                     MAX_NUM_THREADS>& framebuffer) {\n    if (colldata->get_num_components() > (int)BlockType::Y) {\n        ProbabilityTablesBase::set_quantization_table(BlockType::Y,\n                                                      colldata->get_quantization_tables(BlockType::Y));\n    }\n    if (colldata->get_num_components() > (int)BlockType::Cb) {\n        ProbabilityTablesBase::set_quantization_table(BlockType::Cb,\n                                                      colldata->get_quantization_tables(BlockType::Cb));\n    }\n    if (colldata->get_num_components() > (int)BlockType::Cr) {\n        ProbabilityTablesBase::set_quantization_table(BlockType::Cr,\n                                                      colldata->get_quantization_tables(BlockType::Cr));\n    }\n#ifdef ALLOW_FOUR_COLORS\n    if (colldata->get_num_components() > (int)BlockType::Ck) {\n        ProbabilityTablesBase::set_quantization_table(BlockType::Ck,\n                                                      colldata->get_quantization_tables(BlockType::Ck));\n    }\n#endif\n    if (thread_handoff_.empty()) {\n        /* read and verify \"x\" mark */\n        unsigned char mark {};\n        const bool ok = str_in->Read( &mark, 1 ).second == Sirikata::JpegError::nil();\n        if (!ok) {\n            return std::vector<ThreadHandoff>();\n        }\n        ThreadHandoff th;\n        memset(&th, 0, sizeof(th));\n        th.num_overhang_bits = ThreadHandoff::LEGACY_OVERHANG_BITS; // to make sure we don't use this value\n        th.luma_y_end = colldata->block_height(0);\n        thread_handoff_.insert(thread_handoff_.end(), mark, th);\n\n        std::vector<uint16_t> luma_splits_tmp(mark - 1);\n        IOUtil::ReadFull(str_in, luma_splits_tmp.data(), sizeof(uint16_t) * (mark - 1));\n        int sfv_lcm = colldata->min_vertical_luma_multiple();\n        for (int i = 0; i + 1 < mark; ++i) {\n            thread_handoff_[i].luma_y_end = htole16(luma_splits_tmp[i]);\n            if (thread_handoff_[i].luma_y_end % sfv_lcm) {\n                custom_exit(ExitCode::THREADING_PARTIAL_MCU);\n            }\n        }\n        for (int i = 1; i < mark; ++i) {\n            thread_handoff_[i].luma_y_start = thread_handoff_[i - 1].luma_y_end;\n        }\n    }\n    /* read entire chunk into memory */\n    //initialize_thread_id(0, 0, framebuffer[0]);\n    if (thread_handoff_.size()) {\n        thread_handoff_.back().luma_y_end = colldata->block_height(0);\n    }\n    return thread_handoff_;\n}\nvoid VP8ComponentDecoder::flush() {\n        mux_splicer.drain(mux_reader_);\n}\nnamespace{void nop(){}}\nCodingReturnValue VP8ComponentDecoder::decode_chunk(UncompressedComponents * const colldata)\n{\n    mux_splicer.init(spin_workers_);\n    /* cmpc is a global variable with the component count */\n\n\n    /* construct 4x4 VP8 blocks to hold 8x8 JPEG blocks */\n    if ( thread_state_[0] == nullptr || thread_state_[0]->context_[0].isNil() ) {\n        /* first call */\n        BlockBasedImagePerChannel<false> framebuffer;\n        framebuffer.memset(0);\n        for (size_t i = 0; i < framebuffer.size() && int( i ) < colldata->get_num_components(); ++i) {\n            framebuffer[i] = &colldata->full_component_write((BlockType)i);\n        }\n        Sirikata::Array1d<BlockBasedImagePerChannel<false>, MAX_NUM_THREADS> all_framebuffers;\n        for (size_t i = 0; i < all_framebuffers.size(); ++i) {\n            all_framebuffers[i] = framebuffer;\n        }\n        size_t num_threads_needed = initialize_decoder_state(colldata,\n                                                             all_framebuffers).size();\n\n\n        for (size_t i = 0;i < num_threads_needed; ++i) {\n            map_logical_thread_to_physical_thread(i, i);\n        }\n        for (size_t i = 0;i < num_threads_needed; ++i) {\n            initialize_thread_id(i, i, framebuffer);\n            if (!do_threading_) {\n                break;\n            }\n        }\n        if (num_threads_needed > NUM_THREADS || num_threads_needed == 0) {\n            return CODING_ERROR;\n        }\n    }\n    if (do_threading_) {\n        for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {\n            unsigned int cur_spin_worker = thread_id;\n            if (!thread_state_[thread_id]) {\n                spin_workers_[cur_spin_worker].work\n                    = &nop;\n            } else {\n                spin_workers_[cur_spin_worker].work\n                    = std::bind(worker_thread,\n                                thread_state_[thread_id],\n                                thread_id,\n                                colldata,\n                                mux_splicer.thread_target,\n                                getWorker(cur_spin_worker),\n                                &send_to_actual_thread_state);\n            }\n            spin_workers_[cur_spin_worker].activate_work();\n        }\n        flush();\n        for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {\n            unsigned int cur_spin_worker = thread_id;\n            TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_STARTED] = TimingHarness::get_time_us();\n            spin_workers_[cur_spin_worker].main_wait_for_done();\n            TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_FINISHED] = TimingHarness::get_time_us();\n        }\n        // join on all threads\n    } else {\n        if (virtual_thread_id_ != -1) {\n            TimingHarness::timing[0][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();\n            CodingReturnValue ret = thread_state_[0]->vp8_decode_thread(0, colldata);\n            if (ret == CODING_PARTIAL) {\n                return ret;\n            }\n            TimingHarness::timing[0][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();\n        }\n        // wait for \"threads\"\n        virtual_thread_id_ += 1; // first time's a charm\n        for (unsigned int thread_id = virtual_thread_id_; thread_id < NUM_THREADS; ++thread_id, ++virtual_thread_id_) {\n            BlockBasedImagePerChannel<false> framebuffer;\n            framebuffer.memset(0);\n            for (size_t i = 0; i < framebuffer.size() && int( i ) < colldata->get_num_components(); ++i) {\n                framebuffer[i] = &colldata->full_component_write((BlockType)i);\n            }\n\n            initialize_thread_id(thread_id, 0, framebuffer);\n            thread_state_[0]->bool_decoder_.init(new VirtualThreadPacketReader(thread_id, &mux_reader_, &mux_splicer));\n            TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();\n            CodingReturnValue ret;\n            if ((ret = thread_state_[0]->vp8_decode_thread(0, colldata)) == CODING_PARTIAL) {\n                return ret;\n            }\n            TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();\n        }\n    }\n    TimingHarness::timing[0][TimingHarness::TS_JPEG_RECODE_STARTED] = TimingHarness::get_time_us();\n    for (int component = 0; component < colldata->get_num_components(); ++component) {\n        colldata->worker_mark_cmp_finished((BlockType)component);\n    }\n    colldata->worker_update_coefficient_position_progress( 64 );\n    colldata->worker_update_bit_progress( 16 );\n    write_byte_bill(Billing::DELIMITERS, true, mux_reader_.getOverhead());\n    return CODING_DONE;\n}\n", "/*\n *  Copyright (c) 2010 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE banner below\n *  An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the VPX_AUTHORS file in this directory\n */\n/*\nCopyright (c) 2010, Google Inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nNeither the name of Google nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef VPX_DSP_BITREADER_H_\n#define VPX_DSP_BITREADER_H_\n\n#include <stddef.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdint.h>\n#include \"vpx_config.hh\"\n#include \"billing.hh\"\n#include \"../model/numeric.hh\"\n//#include \"vpx_ports/mem.h\"\n//#include \"vpx/vp8dx.h\"\n//#include \"vpx/vpx_integer.h\"\n//#include \"vpx_dsp/prob.h\"\n\n\ntypedef size_t BD_VALUE;\n\n#define BD_VALUE_SIZE ((int)sizeof(BD_VALUE) * CHAR_BIT)\n\n// This is meant to be a large, positive constant that can still be efficiently\n// loaded as an immediate (on platforms like ARM, for example).\n// Even relatively modest values like 100 would work fine.\n#define LOTS_OF_BITS 0x40000000\nstatic std::atomic<uint32_t> test_packet_reader_atomic_test;\ntypedef std::pair<const uint8_t*, const uint8_t*> ROBuffer;\nclass PacketReader{\nprotected:\n    bool isEof;\npublic:\n    PacketReader() {\n        isEof = false;\n    }\n    // returns a buffer with at least sizeof(BD_VALUE) before it\n    virtual ROBuffer getNext() = 0;\n    bool eof()const {\n        return isEof;\n    }\n    virtual void setFree(ROBuffer buffer) = 0;\n    virtual ~PacketReader(){}\n};\nclass TestPacketReader :public PacketReader{\n    const uint8_t*cur;\n    const uint8_t*end;\npublic:\n    TestPacketReader(const uint8_t *start, const uint8_t *ed) {\n        isEof = false;\n        cur = start;\n        end = ed;\n    }\n    ROBuffer getNext(){\n        if (cur == end) {\n            isEof = true;\n            return {NULL, NULL};\n        }\n        if (end - cur > 16) {\n            size_t val = (test_packet_reader_atomic_test += 7)%16 + 1;\n            cur += val;\n            return {cur - val, cur};\n        }\n        const uint8_t *ret = cur;\n        cur = end;\n        return {ret, end};\n    }\n    bool eof()const {\n        return isEof;\n    }\n    void setFree(ROBuffer buffer){}\n};\nclass BiRope {\npublic:\n    ROBuffer rope[2];\n    // if we want partial data from a previous valuex\n    uint8_t backing[sizeof(BD_VALUE)];\n    BiRope() {\n        memset(&backing[0], 0, sizeof(BD_VALUE));\n        for (size_t i= 0; i < sizeof(rope)/sizeof(rope[0]); ++i) {\n            rope[i] = {NULL, NULL};\n        }\n    }\n    void push(ROBuffer data) {\n        if(rope[0].first == NULL) {\n            rope[0] = data;\n        }else {\n            always_assert(rope[1].first == NULL);\n            rope[1] = data;\n        }\n    }\n    size_t size() const {\n        return (rope[0].second-rope[0].first) +\n            (rope[1].second - rope[1].first);\n    }\n    void memcpy_ro(uint8_t *dest, size_t size) const {\n        if ((ptrdiff_t)size < rope[0].second-rope[0].first) {\n            memcpy(dest, rope[0].first, size);\n            return;\n        }\n        size_t del = rope[0].second-rope[0].first;\n        if (del) {\n            memcpy(dest, rope[0].first, del);\n        }\n        dest += del;\n        size -=del;\n        if (size) {\n            always_assert(rope[1].second - rope[1].first >= (ptrdiff_t)size);\n            memcpy(dest, rope[1].first, size);\n        }\n    }\n    void operator += (size_t del) {\n        if ((ptrdiff_t)del < rope[0].second - rope[0].first) {\n            rope[0].first += del;\n            return;\n        }\n        del -= rope[0].second - rope[0].first;\n        rope[0] = rope[1];\n        rope[1] = {NULL, NULL};\n        always_assert((ptrdiff_t)del <= rope[0].second - rope[0].first);\n        rope[0].first += del;\n        if (rope[0].first == rope[0].second) {\n            rope[0] = {NULL, NULL};\n        }\n    }\n    /*\n    void memcpy_pop(uint8_t *dest, size_t size) {\n        if (size < rope[0].second-rope[0].first) {\n            memcpy(dest, rope[0].first, size);\n            rope[0].first += size;\n            return;\n        } else {\n            size_t del = rope[0].second-rope[0].first;\n            memcpy(dest, rope[0].first, del);\n            dest += del;\n            size -= del;\n            rope[0] = rope[1];\n            rope[1] = {NULL, NULL};\n        }\n        if (size) {\n            always_assert(rope[0].second - rope[0].first < size);\n            memcpy(dest, rope[0].first, size);\n            rope[0].first += size;\n            if (rope[0].first == rope[0].second) {\n                rope[0] = {NULL, NULL};\n            }\n        }\n        }*/\n};\ntypedef struct {\n  // Be careful when reordering this struct, it may impact the cache negatively.\n  BD_VALUE value;\n  unsigned int range;\n  int count;\n  BiRope buffer;\n  PacketReader *reader;\n//  vpx_decrypt_cb decrypt_cb;\n//  void *decrypt_state;\n} vpx_reader;\n\nint vpx_reader_init(vpx_reader *r,\n                    PacketReader *reader);\n\nstatic INLINE void vpx_reader_fill(vpx_reader *r) {\n    BD_VALUE value = r->value;\n    int count = r->count;\n    size_t bytes_left = r->buffer.size();\n    size_t bits_left = bytes_left * CHAR_BIT;\n    int shift = BD_VALUE_SIZE - CHAR_BIT - (count + CHAR_BIT);\n    if (bits_left <= BD_VALUE_SIZE && !r->reader->eof()) {\n        // pull some from reader\n        uint8_t local_buffer[sizeof(BD_VALUE)] = {0};\n        r->buffer.memcpy_ro(local_buffer, bytes_left);\n        r->buffer += bytes_left; // clear it out\n        while(true) {\n            auto next = r->reader->getNext();\n            if (next.second - next.first + bytes_left <= sizeof(BD_VALUE)) {\n                memcpy(local_buffer + bytes_left, next.first, next.second - next.first);\n                bytes_left += next.second - next.first;\n            } else {\n                if (bytes_left) {\n                    memcpy(r->buffer.backing, local_buffer, bytes_left);\n                    r->buffer.push({r->buffer.backing, r->buffer.backing + bytes_left});\n                }\n                r->buffer.push(next);\n                break;\n            }\n            if (r->reader->eof()) {\n                always_assert(bytes_left <= sizeof(BD_VALUE)); // otherwise we'd have break'd\n                memcpy(r->buffer.backing, local_buffer, bytes_left);\n                r->buffer.push({r->buffer.backing, r->buffer.backing + bytes_left});\n                break; // setup a simplistic rope that just points to the backing store\n            }\n        }\n        bytes_left = r->buffer.size();\n        bits_left = bytes_left * CHAR_BIT;\n    }\n    if (bits_left > BD_VALUE_SIZE) {\n        const int bits = (shift & 0xfffffff8) + CHAR_BIT;\n        BD_VALUE nv;\n        BD_VALUE big_endian_values;\n        r->buffer.memcpy_ro((uint8_t*)&big_endian_values, sizeof(BD_VALUE));\n        if (sizeof(BD_VALUE) == 8) {\n            big_endian_values = htobe64(big_endian_values);\n        } else {\n            big_endian_values = htobe32(big_endian_values);\n        }\n        nv = big_endian_values >> (BD_VALUE_SIZE - bits);\n        count += bits;\n        r->buffer += (bits >> 3);\n        value = r->value | (nv << (shift & 0x7));\n    } else {\n        const int bits_over = (int)(shift + CHAR_BIT - bits_left);\n        int loop_end = 0;\n        if (bits_over >= 0) {\n            count += LOTS_OF_BITS;\n            loop_end = bits_over;\n        }\n        \n        if (bits_over < 0 || bits_left) {\n            while (shift >= loop_end) {\n                count += CHAR_BIT;\n                uint8_t cur_val = 0;\n                r->buffer.memcpy_ro(&cur_val, 1);\n                r->buffer += 1;\n                value |= ((BD_VALUE)cur_val) << shift;\n                shift -= CHAR_BIT;\n            }\n        }\n    }\n    // NOTE: Variable 'buffer' may not relate to 'r->buffer' after decryption,\n    // so we increase 'r->buffer' by the amount that 'buffer' moved, rather than\n    // assign 'buffer' to 'r->buffer'.\n    r->value = value;\n    r->count = count;\n}\n\n\n  // Check if we have reached the end of the buffer.\n  //\n  // Variable 'count' stores the number of bits in the 'value' buffer, minus\n  // 8. The top byte is part of the algorithm, and the remainder is buffered\n  // to be shifted into it. So if count == 8, the top 16 bits of 'value' are\n  // occupied, 8 for the algorithm and 8 in the buffer.\n  //\n  // When reading a byte from the user's buffer, count is filled with 8 and\n  // one byte is filled into the value buffer. When we reach the end of the\n  // data, count is additionally filled with LOTS_OF_BITS. So when\n  // count == LOTS_OF_BITS - 1, the user's data has been exhausted.\n  //\n  // 1 if we have tried to decode bits after the end of stream was encountered.\n  // 0 No error.\n#define vpx_reader_has_error(r) ((r)->count > BD_VALUE_SIZE && (r)->count < LOTS_OF_BITS)\n\nextern int r_bitcount;\nconstexpr static uint8_t vpx_norm[256] = {\n        0, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\n/*\ninline unsigned int count_leading_zeros_uint8(uint8_t split) {\n    unsigned int shift = 0;\n    if (split < 128) {\n        shift = 1;\n    }\n    if (split < 64) {\n        shift = 2;\n    }\n    if (split < 32) {\n        shift = 3;\n    }\n    if (split < 16) {\n        shift = 4;\n    }\n    if (split < 8) {\n        shift = 5;\n    }\n    if (split < 4) {\n        shift = 6;\n    }\n    if (split == 1) {\n        shift = 7;\n    }\n    return shift;\n}\n    */\n#ifndef _WIN32\n__attribute__((always_inline))\n#endif\ninline uint8_t count_leading_zeros_uint8(uint8_t v) {\n    return vpx_norm[v];\n    dev_assert(v);\n    return __builtin_clz((uint32_t)v) - 24; // slower\n    uint8_t r = 0; // result of log2(v) will go here\n    if (v & 0xf0) {\n        r |= 4;\n        v >>= 4;\n    }\n    if (v & 0xc) {\n        v >>= 2;\n        r |= 2;\n    }\n    if (v & 0x2) {\n        v >>= 1;\n        r |= 1;\n    }\n    return 7 - r;\n}\n\ninline bool vpx_reader_fill_and_read(vpx_reader *r, unsigned int split, Billing bill) {\n    BD_VALUE bigsplit = (BD_VALUE)split << (BD_VALUE_SIZE - CHAR_BIT);\n    vpx_reader_fill(r);\n    BD_VALUE value = r->value;\n    bool bit = (value >= bigsplit);\n    int count = r->count;\n\n\n    unsigned int range;\n\n    if (bit) {\n        range = r->range - split;\n        value = value - bigsplit;\n    } else {\n        range = split;\n    }\n    //unsigned int shift = vpx_norm[range];\n    unsigned int shift = count_leading_zeros_uint8(range);\n    range <<= shift;\n    value <<= shift;\n    count -= shift;\n    write_bit_bill(bill, true, shift);\n    r->value = value;\n    r->count = count;\n    r->range = range;\n\n    return bit;\n}\n#ifndef _WIN32\n__attribute__((always_inline))\n#endif\ninline bool vpx_read(vpx_reader *r, int prob, Billing bill) {\n  unsigned int split = (r->range * prob + (256 - prob)) >> CHAR_BIT;\n  BD_VALUE value = r->value;\n  int count = r->count;\n  BD_VALUE bigsplit = (BD_VALUE)split << (BD_VALUE_SIZE - CHAR_BIT);\n  bool bit = (value >= bigsplit);\n  unsigned int range;\n  if (bit) {\n    range = r->range - split;\n    value = value - bigsplit;\n  } else {\n    range = split;\n  }\n  if (__builtin_expect(r->count < 0, 0)) {\n      bit = vpx_reader_fill_and_read(r, split, bill);\n#ifdef DEBUG_ARICODER\n      fprintf(stderr, \"R %d %d %d\\n\", r_bitcount++, prob, bit);\n#endif\n      return bit;\n  }\n  //unsigned int shift = vpx_norm[range];\n  unsigned int shift = count_leading_zeros_uint8(range);\n  range <<= shift;\n  value <<= shift;\n  count -= shift;\n  write_bit_bill(bill, true, shift);\n  r->value = value;\n  r->count = count;\n  r->range = range;\n#ifdef DEBUG_ARICODER\n  fprintf(stderr, \"R %d %d %d\\n\", r_bitcount++, prob, bit);\n#endif\n\n  return bit;\n}\n\n#endif  // VPX_DSP_BITREADER_H_\n"], "filenames": ["src/lepton/bitops.cc", "src/lepton/bitops.hh", "src/lepton/lepton_codec.cc", "src/lepton/vp8_decoder.cc", "src/vp8/decoder/boolreader.hh"], "buggy_code_start_loc": [358, 470, 277, 419, 122], "buggy_code_end_loc": [388, 476, 277, 466, 123], "fixing_code_start_loc": [359, 470, 278, 420, 122], "fixing_code_end_loc": [389, 476, 279, 472, 125], "type": "CWE-1187", "message": "Dropbox Lepton 1.2.1 allows DoS (SEGV and application crash) via a malformed lepton file because the code does not ensure setup of a correct number of threads.", "other": {"cve": {"id": "CVE-2017-8891", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-10T16:29:00.227", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dropbox Lepton 1.2.1 allows DoS (SEGV and application crash) via a malformed lepton file because the code does not ensure setup of a correct number of threads."}, {"lang": "es", "value": "Dropbox Lepton 1.2.1 permite DoS (SEGV y parada abrupta de aplicaci\u00f3n) a trav\u00e9s de un archivo lepton malformado porque el c\u00f3digo no asegura la configuraci\u00f3n de un n\u00famero correcto de hilos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1187"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dropbox:lepton:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "6DCDBF54-A4B3-4D67-A014-6ECC38D58621"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2017/05/10/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/dropbox/lepton/commit/82167c144a322cc956da45407f6dce8d4303d346", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/dropbox/lepton/issues/87", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dropbox/lepton/commit/82167c144a322cc956da45407f6dce8d4303d346"}}