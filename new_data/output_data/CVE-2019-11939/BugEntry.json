{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n)\n\nconst BinaryVersionMask uint32 = 0xffff0000\nconst BinaryVersion1 uint32 = 0x80010000\n\ntype BinaryProtocol struct {\n\ttrans         RichTransport\n\torigTransport Transport\n\treader        io.Reader\n\twriter        io.Writer\n\tstrictRead    bool\n\tstrictWrite   bool\n\tbuffer        [64]byte\n}\n\ntype BinaryProtocolFactory struct {\n\tstrictRead  bool\n\tstrictWrite bool\n}\n\nfunc NewBinaryProtocolTransport(t Transport) *BinaryProtocol {\n\treturn NewBinaryProtocol(t, false, true)\n}\n\nfunc NewBinaryProtocol(t Transport, strictRead, strictWrite bool) *BinaryProtocol {\n\tp := &BinaryProtocol{origTransport: t, strictRead: strictRead, strictWrite: strictWrite}\n\tif et, ok := t.(RichTransport); ok {\n\t\tp.trans = et\n\t} else {\n\t\tp.trans = NewRichTransport(t)\n\t}\n\tp.reader = p.trans\n\tp.writer = p.trans\n\treturn p\n}\n\nfunc NewBinaryProtocolFactoryDefault() *BinaryProtocolFactory {\n\treturn NewBinaryProtocolFactory(false, true)\n}\n\nfunc NewBinaryProtocolFactory(strictRead, strictWrite bool) *BinaryProtocolFactory {\n\treturn &BinaryProtocolFactory{strictRead: strictRead, strictWrite: strictWrite}\n}\n\nfunc (p *BinaryProtocolFactory) GetProtocol(t Transport) Protocol {\n\treturn NewBinaryProtocol(t, p.strictRead, p.strictWrite)\n}\n\n/**\n * Writing Methods\n */\n\nfunc (p *BinaryProtocol) WriteMessageBegin(name string, typeId MessageType, seqId int32) error {\n\tif p.strictWrite {\n\t\tversion := uint32(VERSION_1) | uint32(typeId)\n\t\te := p.WriteI32(int32(version))\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\te = p.WriteString(name)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\te = p.WriteI32(seqId)\n\t\treturn e\n\t} else {\n\t\te := p.WriteString(name)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\te = p.WriteByte(byte(typeId))\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\te = p.WriteI32(seqId)\n\t\treturn e\n\t}\n}\n\nfunc (p *BinaryProtocol) WriteMessageEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteStructBegin(name string) error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteStructEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteFieldBegin(name string, typeId Type, id int16) error {\n\te := p.WriteByte(byte(typeId))\n\tif e != nil {\n\t\treturn e\n\t}\n\te = p.WriteI16(id)\n\treturn e\n}\n\nfunc (p *BinaryProtocol) WriteFieldEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteFieldStop() error {\n\te := p.WriteByte(STOP)\n\treturn e\n}\n\nfunc (p *BinaryProtocol) WriteMapBegin(keyType Type, valueType Type, size int) error {\n\te := p.WriteByte(byte(keyType))\n\tif e != nil {\n\t\treturn e\n\t}\n\te = p.WriteByte(byte(valueType))\n\tif e != nil {\n\t\treturn e\n\t}\n\te = p.WriteI32(int32(size))\n\treturn e\n}\n\nfunc (p *BinaryProtocol) WriteMapEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteListBegin(elemType Type, size int) error {\n\te := p.WriteByte(byte(elemType))\n\tif e != nil {\n\t\treturn e\n\t}\n\te = p.WriteI32(int32(size))\n\treturn e\n}\n\nfunc (p *BinaryProtocol) WriteListEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteSetBegin(elemType Type, size int) error {\n\te := p.WriteByte(byte(elemType))\n\tif e != nil {\n\t\treturn e\n\t}\n\te = p.WriteI32(int32(size))\n\treturn e\n}\n\nfunc (p *BinaryProtocol) WriteSetEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteBool(value bool) error {\n\tif value {\n\t\treturn p.WriteByte(1)\n\t}\n\treturn p.WriteByte(0)\n}\n\nfunc (p *BinaryProtocol) WriteByte(value byte) error {\n\te := p.trans.WriteByte(value)\n\treturn NewProtocolException(e)\n}\n\nfunc (p *BinaryProtocol) WriteI16(value int16) error {\n\tv := p.buffer[0:2]\n\tbinary.BigEndian.PutUint16(v, uint16(value))\n\t_, e := p.writer.Write(v)\n\treturn NewProtocolException(e)\n}\n\nfunc (p *BinaryProtocol) WriteI32(value int32) error {\n\tv := p.buffer[0:4]\n\tbinary.BigEndian.PutUint32(v, uint32(value))\n\t_, e := p.writer.Write(v)\n\treturn NewProtocolException(e)\n}\n\nfunc (p *BinaryProtocol) WriteI64(value int64) error {\n\tv := p.buffer[0:8]\n\tbinary.BigEndian.PutUint64(v, uint64(value))\n\t_, err := p.writer.Write(v)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *BinaryProtocol) WriteDouble(value float64) error {\n\treturn p.WriteI64(int64(math.Float64bits(value)))\n}\n\nfunc (p *BinaryProtocol) WriteFloat(value float32) error {\n\treturn p.WriteI32(int32(math.Float32bits(value)))\n}\n\nfunc (p *BinaryProtocol) WriteString(value string) error {\n\te := p.WriteI32(int32(len(value)))\n\tif e != nil {\n\t\treturn e\n\t}\n\t_, err := p.trans.WriteString(value)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *BinaryProtocol) WriteBinary(value []byte) error {\n\te := p.WriteI32(int32(len(value)))\n\tif e != nil {\n\t\treturn e\n\t}\n\t_, err := p.writer.Write(value)\n\treturn NewProtocolException(err)\n}\n\n/**\n * Reading methods\n */\n\nfunc (p *BinaryProtocol) ReadMessageBegin() (name string, typeId MessageType, seqId int32, err error) {\n\tsize, e := p.ReadI32()\n\tif e != nil {\n\t\treturn \"\", typeId, 0, NewProtocolException(e)\n\t}\n\tif size < 0 {\n\t\ttypeId = MessageType(size & 0x0ff)\n\t\tversion := int64(int64(size) & VERSION_MASK)\n\t\tif version != VERSION_1 {\n\t\t\treturn name, typeId, seqId, NewProtocolExceptionWithType(BAD_VERSION, fmt.Errorf(\"Bad version in ReadMessageBegin\"))\n\t\t}\n\t\tname, e = p.ReadString()\n\t\tif e != nil {\n\t\t\treturn name, typeId, seqId, NewProtocolException(e)\n\t\t}\n\t\tseqId, e = p.ReadI32()\n\t\tif e != nil {\n\t\t\treturn name, typeId, seqId, NewProtocolException(e)\n\t\t}\n\t\treturn name, typeId, seqId, nil\n\t}\n\tif p.strictRead {\n\t\treturn name, typeId, seqId, NewProtocolExceptionWithType(BAD_VERSION, fmt.Errorf(\"Missing version in ReadMessageBegin\"))\n\t}\n\tname, e2 := p.readStringBody(size)\n\tif e2 != nil {\n\t\treturn name, typeId, seqId, e2\n\t}\n\tb, e3 := p.ReadByte()\n\tif e3 != nil {\n\t\treturn name, typeId, seqId, e3\n\t}\n\ttypeId = MessageType(b)\n\tseqId, e4 := p.ReadI32()\n\tif e4 != nil {\n\t\treturn name, typeId, seqId, e4\n\t}\n\treturn name, typeId, seqId, nil\n}\n\nfunc (p *BinaryProtocol) ReadMessageEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) ReadStructBegin() (name string, err error) {\n\treturn\n}\n\nfunc (p *BinaryProtocol) ReadStructEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) ReadFieldBegin() (name string, typeId Type, seqId int16, err error) {\n\tt, err := p.ReadByte()\n\ttypeId = Type(t)\n\tif err != nil {\n\t\treturn name, typeId, seqId, err\n\t}\n\tif t != STOP {\n\t\tseqId, err = p.ReadI16()\n\t}\n\treturn name, typeId, seqId, err\n}\n\nfunc (p *BinaryProtocol) ReadFieldEnd() error {\n\treturn nil\n}\n\nvar invalidDataLength = NewProtocolExceptionWithType(INVALID_DATA, errors.New(\"Invalid data length\"))\n\nfunc (p *BinaryProtocol) ReadMapBegin() (kType, vType Type, size int, err error) {\n\tk, e := p.ReadByte()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tkType = Type(k)\n\tv, e := p.ReadByte()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tvType = Type(v)\n\tsize32, e := p.ReadI32()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tif size32 < 0 {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tsize = int(size32)\n\treturn kType, vType, size, nil\n}\n\nfunc (p *BinaryProtocol) ReadMapEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) ReadListBegin() (elemType Type, size int, err error) {\n\tb, e := p.ReadByte()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\telemType = Type(b)\n\tsize32, e := p.ReadI32()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tif size32 < 0 {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tsize = int(size32)\n\n\treturn\n}\n\nfunc (p *BinaryProtocol) ReadListEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) ReadSetBegin() (elemType Type, size int, err error) {\n\tb, e := p.ReadByte()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\telemType = Type(b)\n\tsize32, e := p.ReadI32()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tif size32 < 0 {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tsize = int(size32)\n\treturn elemType, size, nil\n}\n\nfunc (p *BinaryProtocol) ReadSetEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) ReadBool() (bool, error) {\n\tb, e := p.ReadByte()\n\tv := true\n\tif b != 1 {\n\t\tv = false\n\t}\n\treturn v, e\n}\n\nfunc (p *BinaryProtocol) ReadByte() (byte, error) {\n\tv, err := p.trans.ReadByte()\n\treturn byte(v), err\n}\n\nfunc (p *BinaryProtocol) ReadI16() (value int16, err error) {\n\tbuf := p.buffer[0:2]\n\terr = p.readAll(buf)\n\tvalue = int16(binary.BigEndian.Uint16(buf))\n\treturn value, err\n}\n\nfunc (p *BinaryProtocol) ReadI32() (value int32, err error) {\n\tbuf := p.buffer[0:4]\n\terr = p.readAll(buf)\n\tvalue = int32(binary.BigEndian.Uint32(buf))\n\treturn value, err\n}\n\nfunc (p *BinaryProtocol) ReadI64() (value int64, err error) {\n\tbuf := p.buffer[0:8]\n\terr = p.readAll(buf)\n\tvalue = int64(binary.BigEndian.Uint64(buf))\n\treturn value, err\n}\n\nfunc (p *BinaryProtocol) ReadDouble() (value float64, err error) {\n\tbuf := p.buffer[0:8]\n\terr = p.readAll(buf)\n\tvalue = math.Float64frombits(binary.BigEndian.Uint64(buf))\n\treturn value, err\n}\n\nfunc (p *BinaryProtocol) ReadFloat() (value float32, err error) {\n\tbuf := p.buffer[0:4]\n\terr = p.readAll(buf)\n\tvalue = math.Float32frombits(binary.BigEndian.Uint32(buf))\n\treturn value, err\n}\n\nfunc (p *BinaryProtocol) ReadString() (value string, err error) {\n\tsize, e := p.ReadI32()\n\tif e != nil {\n\t\treturn \"\", e\n\t}\n\tif size < 0 {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\n\treturn p.readStringBody(size)\n}\n\nfunc (p *BinaryProtocol) ReadBinary() ([]byte, error) {\n\tsize, e := p.ReadI32()\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\tif size < 0 {\n\t\treturn nil, invalidDataLength\n\t}\n\tif uint64(size) > p.trans.RemainingBytes() {\n\t\treturn nil, invalidDataLength\n\t}\n\n\tisize := int(size)\n\tbuf := make([]byte, isize)\n\t_, err := io.ReadFull(p.trans, buf)\n\treturn buf, NewProtocolException(err)\n}\n\nfunc (p *BinaryProtocol) Flush() (err error) {\n\treturn NewProtocolException(p.trans.Flush())\n}\n\nfunc (p *BinaryProtocol) Skip(fieldType Type) (err error) {\n\treturn SkipDefaultDepth(p, fieldType)\n}\n\nfunc (p *BinaryProtocol) Transport() Transport {\n\treturn p.origTransport\n}\n\nfunc (p *BinaryProtocol) readAll(buf []byte) error {\n\t_, err := io.ReadFull(p.reader, buf)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *BinaryProtocol) readStringBody(size int32) (value string, err error) {\n\tif size < 0 {\n\t\treturn \"\", nil\n\t}\n\tif uint64(size) > p.trans.RemainingBytes() {\n\t\treturn \"\", invalidDataLength\n\t}\n\tvar buf []byte\n\tif int(size) <= len(p.buffer) {\n\t\tbuf = p.buffer[0:size]\n\t} else {\n\t\tbuf = make([]byte, size)\n\t}\n\t_, e := io.ReadFull(p.trans, buf)\n\treturn string(buf), NewProtocolException(e)\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestReadWriteBinaryProtocol(t *testing.T) {\n\tReadWriteProtocolTest(t, NewBinaryProtocolFactoryDefault())\n}\n\nfunc TestSkipUnknownTypeBinaryProtocol(t *testing.T) {\n\tvar m MyTestStruct\n\td := NewDeserializer()\n\tf := NewBinaryProtocolFactoryDefault()\n\td.Protocol = f.GetProtocol(d.Transport)\n\t// skip over a map with invalid key/value type and 1.7B entries\n\tdata := []byte(\"\\n\\x10\\rO\\t6\\x03\\n\\n\\n\\x10\\r\\n\\tslice\\x00\")\n\tstart := time.Now()\n\terr := d.Read(&m, data)\n\tif err == nil {\n\t\tt.Fatalf(\"Parsed invalid message correctly\")\n\t} else if !strings.Contains(err.Error(), \"unknown type\") {\n\t\tt.Fatalf(\"Failed for reason besides unknown type\")\n\t}\n\n\tif time.Now().Sub(start).Seconds() > 5 {\n\t\tt.Fatalf(\"It should not take seconds to parse a small message\")\n\t}\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n)\n\nconst (\n\tCOMPACT_PROTOCOL_ID       = 0x082\n\tCOMPACT_VERSION           = 0x01\n\tCOMPACT_VERSION_BE        = 0x02\n\tCOMPACT_VERSION_MASK      = 0x1f\n\tCOMPACT_TYPE_MASK         = 0x0E0\n\tCOMPACT_TYPE_BITS         = 0x07\n\tCOMPACT_TYPE_SHIFT_AMOUNT = 5\n)\n\ntype compactType byte\n\nconst (\n\tCOMPACT_BOOLEAN_TRUE  = 0x01\n\tCOMPACT_BOOLEAN_FALSE = 0x02\n\tCOMPACT_BYTE          = 0x03\n\tCOMPACT_I16           = 0x04\n\tCOMPACT_I32           = 0x05\n\tCOMPACT_I64           = 0x06\n\tCOMPACT_DOUBLE        = 0x07\n\tCOMPACT_BINARY        = 0x08\n\tCOMPACT_LIST          = 0x09\n\tCOMPACT_SET           = 0x0A\n\tCOMPACT_MAP           = 0x0B\n\tCOMPACT_STRUCT        = 0x0C\n\tCOMPACT_FLOAT         = 0x0D\n)\n\nvar (\n\ttypeToCompactType map[Type]compactType\n)\n\nfunc init() {\n\ttypeToCompactType = map[Type]compactType{\n\t\tSTOP:   STOP,\n\t\tBOOL:   COMPACT_BOOLEAN_TRUE,\n\t\tBYTE:   COMPACT_BYTE,\n\t\tI16:    COMPACT_I16,\n\t\tI32:    COMPACT_I32,\n\t\tI64:    COMPACT_I64,\n\t\tDOUBLE: COMPACT_DOUBLE,\n\t\tFLOAT:  COMPACT_FLOAT,\n\t\tSTRING: COMPACT_BINARY,\n\t\tLIST:   COMPACT_LIST,\n\t\tSET:    COMPACT_SET,\n\t\tMAP:    COMPACT_MAP,\n\t\tSTRUCT: COMPACT_STRUCT,\n\t}\n}\n\ntype CompactProtocolFactory struct{}\n\nfunc NewCompactProtocolFactory() *CompactProtocolFactory {\n\treturn &CompactProtocolFactory{}\n}\n\nfunc (p *CompactProtocolFactory) GetProtocol(trans Transport) Protocol {\n\treturn NewCompactProtocol(trans)\n}\n\ntype CompactProtocol struct {\n\ttrans         RichTransport\n\torigTransport Transport\n\n\t// Used to keep track of the last field for the current and previous structs,\n\t// so we can do the delta stuff.\n\t// writing\n\tlastFieldWritten   []int\n\tlastFieldIDWritten int\n\t// reading\n\tlastFieldRead   []int\n\tlastFieldIDRead int\n\n\t// If we encounter a boolean field begin, save the Field here so it can\n\t// have the value incorporated. This is only used for writes.\n\tbooleanFieldName    string\n\tbooleanFieldID      int16\n\tbooleanFieldPending bool\n\n\t// If we read a field header, and it's a boolean field, save the boolean\n\t// value here so that readBool can use it. This is only used for reads.\n\tboolValue          bool\n\tboolValueIsNotNull bool\n\n\trBuffer [64]byte // reading\n\twBuffer [64]byte // writing\n\n\tversion int\n}\n\n// Create a CompactProtocol given a Transport\nfunc NewCompactProtocol(trans Transport) *CompactProtocol {\n\tp := &CompactProtocol{origTransport: trans, version: COMPACT_VERSION_BE}\n\tif et, ok := trans.(RichTransport); ok {\n\t\tp.trans = et\n\t} else {\n\t\tp.trans = NewRichTransport(trans)\n\t}\n\n\treturn p\n}\n\n//\n// Public Writing methods.\n//\n\n// Write a message header to the wire. Compact Protocol messages contain the\n// protocol version so we can migrate forwards in the future if need be.\nfunc (p *CompactProtocol) WriteMessageBegin(name string, typeId MessageType, seqid int32) error {\n\terr := p.writeByteDirect(COMPACT_PROTOCOL_ID)\n\tif err != nil {\n\t\treturn NewProtocolException(err)\n\t}\n\terr = p.writeByteDirect((byte(p.version) & COMPACT_VERSION_MASK) | ((byte(typeId) << COMPACT_TYPE_SHIFT_AMOUNT) & COMPACT_TYPE_MASK))\n\tif err != nil {\n\t\treturn NewProtocolException(err)\n\t}\n\t_, err = p.writeVarint32(seqid)\n\tif err != nil {\n\t\treturn NewProtocolException(err)\n\t}\n\te := p.WriteString(name)\n\treturn e\n\n}\n\nfunc (p *CompactProtocol) WriteMessageEnd() error { return nil }\n\n// Write a struct begin. This doesn't actually put anything on the wire. We\n// use it as an opportunity to put special placeholder markers on the field\n// stack so we can get the field id deltas correct.\nfunc (p *CompactProtocol) WriteStructBegin(name string) error {\n\tp.lastFieldWritten = append(p.lastFieldWritten, p.lastFieldIDWritten)\n\tp.lastFieldIDWritten = 0\n\treturn nil\n}\n\n// Write a struct end. This doesn't actually put anything on the wire. We use\n// this as an opportunity to pop the last field from the current struct off\n// of the field stack.\nfunc (p *CompactProtocol) WriteStructEnd() error {\n\tp.lastFieldIDWritten = p.lastFieldWritten[len(p.lastFieldWritten)-1]\n\tp.lastFieldWritten = p.lastFieldWritten[:len(p.lastFieldWritten)-1]\n\treturn nil\n}\n\nfunc (p *CompactProtocol) WriteFieldBegin(name string, typeId Type, id int16) error {\n\tif typeId == BOOL {\n\t\t// we want to possibly include the value, so we'll wait.\n\t\tp.booleanFieldName, p.booleanFieldID, p.booleanFieldPending = name, id, true\n\t\treturn nil\n\t}\n\t_, err := p.writeFieldBeginInternal(name, typeId, id, 0xFF)\n\treturn NewProtocolException(err)\n}\n\n// The workhorse of writeFieldBegin. It has the option of doing a\n// 'type override' of the type header. This is used specifically in the\n// boolean field case.\nfunc (p *CompactProtocol) writeFieldBeginInternal(name string, typeId Type, id int16, typeOverride byte) (int, error) {\n\t// short lastFieldWritten = lastFieldWritten_.pop();\n\n\t// if there's a type override, use that.\n\tvar typeToWrite byte\n\tif typeOverride == 0xFF {\n\t\ttypeToWrite = byte(p.getCompactType(typeId))\n\t} else {\n\t\ttypeToWrite = typeOverride\n\t}\n\t// check if we can use delta encoding for the field id\n\tfieldId := int(id)\n\twritten := 0\n\tif fieldId > p.lastFieldIDWritten && fieldId-p.lastFieldIDWritten <= 15 {\n\t\t// write them together\n\t\terr := p.writeByteDirect(byte((fieldId-p.lastFieldIDWritten)<<4) | typeToWrite)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t} else {\n\t\t// write them separate\n\t\terr := p.writeByteDirect(typeToWrite)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\terr = p.WriteI16(id)\n\t\twritten = 1 + 2\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\tp.lastFieldIDWritten = fieldId\n\t// p.lastFieldWritten.Push(field.id);\n\treturn written, nil\n}\n\nfunc (p *CompactProtocol) WriteFieldEnd() error { return nil }\n\nfunc (p *CompactProtocol) WriteFieldStop() error {\n\terr := p.writeByteDirect(STOP)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *CompactProtocol) WriteMapBegin(keyType Type, valueType Type, size int) error {\n\tif size == 0 {\n\t\terr := p.writeByteDirect(0)\n\t\treturn NewProtocolException(err)\n\t}\n\t_, err := p.writeVarint32(int32(size))\n\tif err != nil {\n\t\treturn NewProtocolException(err)\n\t}\n\terr = p.writeByteDirect(byte(p.getCompactType(keyType))<<4 | byte(p.getCompactType(valueType)))\n\treturn NewProtocolException(err)\n}\n\nfunc (p *CompactProtocol) WriteMapEnd() error { return nil }\n\n// Write a list header.\nfunc (p *CompactProtocol) WriteListBegin(elemType Type, size int) error {\n\t_, err := p.writeCollectionBegin(elemType, size)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *CompactProtocol) WriteListEnd() error { return nil }\n\n// Write a set header.\nfunc (p *CompactProtocol) WriteSetBegin(elemType Type, size int) error {\n\t_, err := p.writeCollectionBegin(elemType, size)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *CompactProtocol) WriteSetEnd() error { return nil }\n\nfunc (p *CompactProtocol) WriteBool(value bool) error {\n\tv := byte(COMPACT_BOOLEAN_FALSE)\n\tif value {\n\t\tv = byte(COMPACT_BOOLEAN_TRUE)\n\t}\n\tif p.booleanFieldPending {\n\t\t// we haven't written the field header yet\n\t\t_, err := p.writeFieldBeginInternal(p.booleanFieldName, BOOL, p.booleanFieldID, v)\n\t\tp.booleanFieldPending = false\n\t\treturn NewProtocolException(err)\n\t}\n\t// we're not part of a field, so just write the value.\n\terr := p.writeByteDirect(v)\n\treturn NewProtocolException(err)\n}\n\n// Write a byte. Nothing to see here!\nfunc (p *CompactProtocol) WriteByte(value byte) error {\n\terr := p.writeByteDirect(value)\n\treturn NewProtocolException(err)\n}\n\n// Write an I16 as a zigzag varint.\nfunc (p *CompactProtocol) WriteI16(value int16) error {\n\t_, err := p.writeVarint32(p.int32ToZigzag(int32(value)))\n\treturn NewProtocolException(err)\n}\n\n// Write an i32 as a zigzag varint.\nfunc (p *CompactProtocol) WriteI32(value int32) error {\n\t_, err := p.writeVarint32(p.int32ToZigzag(value))\n\treturn NewProtocolException(err)\n}\n\n// Write an i64 as a zigzag varint.\nfunc (p *CompactProtocol) WriteI64(value int64) error {\n\t_, err := p.writeVarint64(p.int64ToZigzag(value))\n\treturn NewProtocolException(err)\n}\n\n// Write a double to the wire as 8 bytes.\nfunc (p *CompactProtocol) WriteDouble(value float64) error {\n\tbuf := p.wBuffer[0:8]\n\tif p.version == COMPACT_VERSION {\n\t\tbinary.LittleEndian.PutUint64(buf, math.Float64bits(value))\n\t} else {\n\t\tbinary.BigEndian.PutUint64(buf, math.Float64bits(value))\n\t}\n\t_, err := p.trans.Write(buf)\n\treturn NewProtocolException(err)\n}\n\n// Write a float to the wire as 4 bytes.\nfunc (p *CompactProtocol) WriteFloat(value float32) error {\n\tbuf := p.wBuffer[0:4]\n\tbinary.BigEndian.PutUint32(buf, math.Float32bits(value))\n\t_, err := p.trans.Write(buf)\n\treturn NewProtocolException(err)\n}\n\n// Write a string to the wire with a varint size preceding.\nfunc (p *CompactProtocol) WriteString(value string) error {\n\t_, e := p.writeVarint32(int32(len(value)))\n\tif e != nil {\n\t\treturn NewProtocolException(e)\n\t}\n\tif len(value) > 0 {\n\t}\n\t_, e = p.trans.WriteString(value)\n\treturn e\n}\n\n// Write a byte array, using a varint for the size.\nfunc (p *CompactProtocol) WriteBinary(bin []byte) error {\n\t_, e := p.writeVarint32(int32(len(bin)))\n\tif e != nil {\n\t\treturn NewProtocolException(e)\n\t}\n\tif len(bin) > 0 {\n\t\t_, e = p.trans.Write(bin)\n\t\treturn NewProtocolException(e)\n\t}\n\treturn nil\n}\n\n//\n// Reading methods.\n//\n\n// Read a message header.\nfunc (p *CompactProtocol) ReadMessageBegin() (name string, typeId MessageType, seqId int32, err error) {\n\n\tprotocolId, err := p.readByteDirect()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif protocolId != COMPACT_PROTOCOL_ID {\n\t\te := fmt.Errorf(\"Expected protocol id %02x but got %02x\", COMPACT_PROTOCOL_ID, protocolId)\n\t\treturn \"\", typeId, seqId, NewProtocolExceptionWithType(BAD_VERSION, e)\n\t}\n\n\tversionAndType, err := p.readByteDirect()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tversion := versionAndType & COMPACT_VERSION_MASK\n\ttypeId = MessageType((versionAndType >> COMPACT_TYPE_SHIFT_AMOUNT) & COMPACT_TYPE_BITS)\n\tif version == COMPACT_VERSION || version == COMPACT_VERSION_BE {\n\t\tp.version = int(version)\n\t} else {\n\t\te := fmt.Errorf(\"Expected version %02x or %02x but got %02x\", COMPACT_VERSION, COMPACT_VERSION_BE, version)\n\t\terr = NewProtocolExceptionWithType(BAD_VERSION, e)\n\t\treturn\n\t}\n\tseqId, e := p.readVarint32()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tname, err = p.ReadString()\n\treturn\n}\n\nfunc (p *CompactProtocol) ReadMessageEnd() error { return nil }\n\n// Read a struct begin. There's nothing on the wire for this, but it is our\n// opportunity to push a new struct begin marker onto the field stack.\nfunc (p *CompactProtocol) ReadStructBegin() (name string, err error) {\n\tp.lastFieldRead = append(p.lastFieldRead, p.lastFieldIDRead)\n\tp.lastFieldIDRead = 0\n\treturn\n}\n\n// Doesn't actually consume any wire data, just removes the last field for\n// this struct from the field stack.\nfunc (p *CompactProtocol) ReadStructEnd() error {\n\t// consume the last field we read off the wire.\n\tp.lastFieldIDRead = p.lastFieldRead[len(p.lastFieldRead)-1]\n\tp.lastFieldRead = p.lastFieldRead[:len(p.lastFieldRead)-1]\n\treturn nil\n}\n\n// Read a field header off the wire.\nfunc (p *CompactProtocol) ReadFieldBegin() (name string, typeId Type, id int16, err error) {\n\tt, err := p.readByteDirect()\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// if it's a stop, then we can return immediately, as the struct is over.\n\tif (t & 0x0f) == STOP {\n\t\treturn \"\", STOP, 0, nil\n\t}\n\n\t// mask off the 4 MSB of the type header. it could contain a field id delta.\n\tmodifier := int16((t & 0xf0) >> 4)\n\tif modifier == 0 {\n\t\t// not a delta. look ahead for the zigzag varint field id.\n\t\tid, err = p.ReadI16()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t} else {\n\t\t// has a delta. add the delta to the last read field id.\n\t\tid = int16(p.lastFieldIDRead) + modifier\n\t}\n\ttypeId, e := p.getType(compactType(t & 0x0f))\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\n\t// if this happens to be a boolean field, the value is encoded in the type\n\tif p.isBoolType(t) {\n\t\t// save the boolean value in a special instance variable.\n\t\tp.boolValue = (byte(t)&0x0f == COMPACT_BOOLEAN_TRUE)\n\t\tp.boolValueIsNotNull = true\n\t}\n\n\t// push the new field onto the field stack so we can keep the deltas going.\n\tp.lastFieldIDRead = int(id)\n\treturn\n}\n\nfunc (p *CompactProtocol) ReadFieldEnd() error { return nil }\n\n// Read a map header off the wire. If the size is zero, skip reading the key\n// and value type. This means that 0-length maps will yield Maps without the\n// \"correct\" types.\nfunc (p *CompactProtocol) ReadMapBegin() (keyType Type, valueType Type, size int, err error) {\n\tsize32, e := p.readVarint32()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tif size32 < 0 {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tsize = int(size32)\n\n\tkeyAndValueType := byte(STOP)\n\tif size != 0 {\n\t\tkeyAndValueType, err = p.readByteDirect()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tkeyType, _ = p.getType(compactType(keyAndValueType >> 4))\n\tvalueType, _ = p.getType(compactType(keyAndValueType & 0xf))\n\treturn\n}\n\nfunc (p *CompactProtocol) ReadMapEnd() error { return nil }\n\n// Read a list header off the wire. If the list size is 0-14, the size will\n// be packed into the element type header. If it's a longer list, the 4 MSB\n// of the element type header will be 0xF, and a varint will follow with the\n// true size.\nfunc (p *CompactProtocol) ReadListBegin() (elemType Type, size int, err error) {\n\tsize_and_type, err := p.readByteDirect()\n\tif err != nil {\n\t\treturn\n\t}\n\tsize = int((size_and_type >> 4) & 0x0f)\n\tif size == 15 {\n\t\tsize2, e := p.readVarint32()\n\t\tif e != nil {\n\t\t\terr = NewProtocolException(e)\n\t\t\treturn\n\t\t}\n\t\tif size2 < 0 {\n\t\t\terr = invalidDataLength\n\t\t\treturn\n\t\t}\n\t\tsize = int(size2)\n\t}\n\telemType, e := p.getType(compactType(size_and_type))\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\treturn\n}\n\nfunc (p *CompactProtocol) ReadListEnd() error { return nil }\n\n// Read a set header off the wire. If the set size is 0-14, the size will\n// be packed into the element type header. If it's a longer set, the 4 MSB\n// of the element type header will be 0xF, and a varint will follow with the\n// true size.\nfunc (p *CompactProtocol) ReadSetBegin() (elemType Type, size int, err error) {\n\treturn p.ReadListBegin()\n}\n\nfunc (p *CompactProtocol) ReadSetEnd() error { return nil }\n\n// Read a boolean off the wire. If this is a boolean field, the value should\n// already have been read during readFieldBegin, so we'll just consume the\n// pre-stored value. Otherwise, read a byte.\nfunc (p *CompactProtocol) ReadBool() (value bool, err error) {\n\tif p.boolValueIsNotNull {\n\t\tp.boolValueIsNotNull = false\n\t\treturn p.boolValue, nil\n\t}\n\tv, err := p.readByteDirect()\n\treturn v == COMPACT_BOOLEAN_TRUE, err\n}\n\n// Read a single byte off the wire. Nothing interesting here.\nfunc (p *CompactProtocol) ReadByte() (byte, error) {\n\tv, err := p.readByteDirect()\n\tif err != nil {\n\t\treturn 0, NewProtocolException(err)\n\t}\n\treturn v, err\n}\n\n// Read an i16 from the wire as a zigzag varint.\nfunc (p *CompactProtocol) ReadI16() (value int16, err error) {\n\tv, err := p.ReadI32()\n\treturn int16(v), err\n}\n\n// Read an i32 from the wire as a zigzag varint.\nfunc (p *CompactProtocol) ReadI32() (value int32, err error) {\n\tv, e := p.readVarint32()\n\tif e != nil {\n\t\treturn 0, NewProtocolException(e)\n\t}\n\tvalue = p.zigzagToInt32(v)\n\treturn value, nil\n}\n\n// Read an i64 from the wire as a zigzag varint.\nfunc (p *CompactProtocol) ReadI64() (value int64, err error) {\n\tv, e := p.readVarint64()\n\tif e != nil {\n\t\treturn 0, NewProtocolException(e)\n\t}\n\tvalue = p.zigzagToInt64(v)\n\treturn value, nil\n}\n\n// No magic here - just read a double off the wire.\nfunc (p *CompactProtocol) ReadDouble() (value float64, err error) {\n\tlongBits := p.rBuffer[0:8]\n\t_, e := io.ReadFull(p.trans, longBits)\n\tif e != nil {\n\t\treturn 0.0, NewProtocolException(e)\n\t}\n\tif p.version == COMPACT_VERSION {\n\t\treturn math.Float64frombits(binary.LittleEndian.Uint64(longBits)), nil\n\t} else {\n\t\treturn math.Float64frombits(binary.BigEndian.Uint64(longBits)), nil\n\t}\n}\n\n// No magic here - just read a float off the wire.\nfunc (p *CompactProtocol) ReadFloat() (value float32, err error) {\n\tbits := p.rBuffer[0:4]\n\t_, e := io.ReadFull(p.trans, bits)\n\tif e != nil {\n\t\treturn 0.0, NewProtocolException(e)\n\t}\n\treturn math.Float32frombits(binary.BigEndian.Uint32(bits)), nil\n}\n\n// Reads a []byte (via readBinary), and then UTF-8 decodes it.\nfunc (p *CompactProtocol) ReadString() (value string, err error) {\n\tlength, e := p.readVarint32()\n\tif e != nil {\n\t\treturn \"\", NewProtocolException(e)\n\t}\n\tif length < 0 {\n\t\treturn \"\", invalidDataLength\n\t}\n\tif uint64(length) > p.trans.RemainingBytes() {\n\t\treturn \"\", invalidDataLength\n\t}\n\n\tif length == 0 {\n\t\treturn \"\", nil\n\t}\n\tvar buf []byte\n\tif length <= int32(len(p.rBuffer)) {\n\t\tbuf = p.rBuffer[0:length]\n\t} else {\n\t\tbuf = make([]byte, length)\n\t}\n\t_, e = io.ReadFull(p.trans, buf)\n\treturn string(buf), NewProtocolException(e)\n}\n\n// Read a []byte from the wire.\nfunc (p *CompactProtocol) ReadBinary() (value []byte, err error) {\n\tlength, e := p.readVarint32()\n\tif e != nil {\n\t\treturn nil, NewProtocolException(e)\n\t}\n\tif length == 0 {\n\t\treturn []byte{}, nil\n\t}\n\tif length < 0 {\n\t\treturn nil, invalidDataLength\n\t}\n\tif uint64(length) > p.trans.RemainingBytes() {\n\t\treturn nil, invalidDataLength\n\t}\n\n\tbuf := make([]byte, length)\n\t_, e = io.ReadFull(p.trans, buf)\n\treturn buf, NewProtocolException(e)\n}\n\nfunc (p *CompactProtocol) Flush() (err error) {\n\treturn NewProtocolException(p.trans.Flush())\n}\n\nfunc (p *CompactProtocol) Skip(fieldType Type) (err error) {\n\treturn SkipDefaultDepth(p, fieldType)\n}\n\nfunc (p *CompactProtocol) Transport() Transport {\n\treturn p.origTransport\n}\n\n//\n// Internal writing methods\n//\n\n// Abstract method for writing the start of lists and sets. List and sets on\n// the wire differ only by the type indicator.\nfunc (p *CompactProtocol) writeCollectionBegin(elemType Type, size int) (int, error) {\n\tif size <= 14 {\n\t\treturn 1, p.writeByteDirect(byte(int32(size<<4) | int32(p.getCompactType(elemType))))\n\t}\n\terr := p.writeByteDirect(0xf0 | byte(p.getCompactType(elemType)))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tm, err := p.writeVarint32(int32(size))\n\treturn 1 + m, err\n}\n\n// Write an i32 as a varint. Results in 1-5 bytes on the wire.\n// TODO(pomack): make a permanent buffer like writeVarint64?\nfunc (p *CompactProtocol) writeVarint32(n int32) (int, error) {\n\ti32buf := p.wBuffer[0:5]\n\tidx := 0\n\tfor {\n\t\tif (n & ^0x7F) == 0 {\n\t\t\ti32buf[idx] = byte(n)\n\t\t\tidx++\n\t\t\t// p.writeByteDirect(byte(n));\n\t\t\tbreak\n\t\t\t// return;\n\t\t} else {\n\t\t\ti32buf[idx] = byte((n & 0x7F) | 0x80)\n\t\t\tidx++\n\t\t\t// p.writeByteDirect(byte(((n & 0x7F) | 0x80)));\n\t\t\tu := uint32(n)\n\t\t\tn = int32(u >> 7)\n\t\t}\n\t}\n\treturn p.trans.Write(i32buf[0:idx])\n}\n\n// Write an i64 as a varint. Results in 1-10 bytes on the wire.\nfunc (p *CompactProtocol) writeVarint64(n int64) (int, error) {\n\tvarint64out := p.wBuffer[0:10]\n\tidx := 0\n\tfor {\n\t\tif (n & ^0x7F) == 0 {\n\t\t\tvarint64out[idx] = byte(n)\n\t\t\tidx++\n\t\t\tbreak\n\t\t} else {\n\t\t\tvarint64out[idx] = byte((n & 0x7F) | 0x80)\n\t\t\tidx++\n\t\t\tu := uint64(n)\n\t\t\tn = int64(u >> 7)\n\t\t}\n\t}\n\treturn p.trans.Write(varint64out[0:idx])\n}\n\n// Convert l into a zigzag long. This allows negative numbers to be\n// represented compactly as a varint.\nfunc (p *CompactProtocol) int64ToZigzag(l int64) int64 {\n\treturn (l << 1) ^ (l >> 63)\n}\n\n// Convert l into a zigzag long. This allows negative numbers to be\n// represented compactly as a varint.\nfunc (p *CompactProtocol) int32ToZigzag(n int32) int32 {\n\treturn (n << 1) ^ (n >> 31)\n}\n\nfunc (p *CompactProtocol) fixedUint64ToBytes(n uint64, buf []byte) {\n\tbinary.LittleEndian.PutUint64(buf, n)\n}\n\nfunc (p *CompactProtocol) fixedInt64ToBytes(n int64, buf []byte) {\n\tbinary.LittleEndian.PutUint64(buf, uint64(n))\n}\n\n// Writes a byte without any possibility of all that field header nonsense.\n// Used internally by other writing methods that know they need to write a byte.\nfunc (p *CompactProtocol) writeByteDirect(b byte) error {\n\treturn p.trans.WriteByte(b)\n}\n\n// Writes a byte without any possibility of all that field header nonsense.\nfunc (p *CompactProtocol) writeIntAsByteDirect(n int) (int, error) {\n\treturn 1, p.writeByteDirect(byte(n))\n}\n\n//\n// Internal reading methods\n//\n\n// Read an i32 from the wire as a varint. The MSB of each byte is set\n// if there is another byte to follow. This can read up to 5 bytes.\nfunc (p *CompactProtocol) readVarint32() (int32, error) {\n\t// if the wire contains the right stuff, this will just truncate the i64 we\n\t// read and get us the right sign.\n\tv, err := p.readVarint64()\n\treturn int32(v), err\n}\n\n// Read an i64 from the wire as a proper varint. The MSB of each byte is set\n// if there is another byte to follow. This can read up to 10 bytes.\nfunc (p *CompactProtocol) readVarint64() (int64, error) {\n\tshift := uint(0)\n\tresult := int64(0)\n\tfor {\n\t\tb, err := p.readByteDirect()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tresult |= int64(b&0x7f) << shift\n\t\tif (b & 0x80) != 0x80 {\n\t\t\tbreak\n\t\t}\n\t\tshift += 7\n\t}\n\treturn result, nil\n}\n\n// Read a byte, unlike ReadByte that reads Thrift-byte that is i8.\nfunc (p *CompactProtocol) readByteDirect() (byte, error) {\n\treturn p.trans.ReadByte()\n}\n\n//\n// encoding helpers\n//\n\n// Convert from zigzag int to int.\nfunc (p *CompactProtocol) zigzagToInt32(n int32) int32 {\n\tu := uint32(n)\n\treturn int32(u>>1) ^ -(n & 1)\n}\n\n// Convert from zigzag long to long.\nfunc (p *CompactProtocol) zigzagToInt64(n int64) int64 {\n\tu := uint64(n)\n\treturn int64(u>>1) ^ -(n & 1)\n}\n\nfunc (p *CompactProtocol) bytesToInt32(b []byte) int32 {\n\treturn int32(binary.LittleEndian.Uint32(b))\n}\n\nfunc (p *CompactProtocol) bytesToUint32(b []byte) uint32 {\n\treturn binary.LittleEndian.Uint32(b)\n\n}\n\n// Note that it's important that the mask bytes are long literals,\n// otherwise they'll default to ints, and when you shift an int left 56 bits,\n// you just get a messed up int.\nfunc (p *CompactProtocol) bytesToInt64(b []byte) int64 {\n\treturn int64(binary.LittleEndian.Uint64(b))\n}\n\n// Note that it's important that the mask bytes are long literals,\n// otherwise they'll default to ints, and when you shift an int left 56 bits,\n// you just get a messed up int.\nfunc (p *CompactProtocol) bytesToUint64(b []byte) uint64 {\n\treturn binary.LittleEndian.Uint64(b)\n}\n\n//\n// type testing and converting\n//\n\nfunc (p *CompactProtocol) isBoolType(b byte) bool {\n\treturn (b&0x0f) == COMPACT_BOOLEAN_TRUE || (b&0x0f) == COMPACT_BOOLEAN_FALSE\n}\n\n// Given a compactType constant, convert it to its corresponding\n// Type value.\nfunc (p *CompactProtocol) getType(t compactType) (Type, error) {\n\tswitch byte(t) & 0x0f {\n\tcase STOP:\n\t\treturn STOP, nil\n\tcase COMPACT_BOOLEAN_FALSE, COMPACT_BOOLEAN_TRUE:\n\t\treturn BOOL, nil\n\tcase COMPACT_BYTE:\n\t\treturn BYTE, nil\n\tcase COMPACT_I16:\n\t\treturn I16, nil\n\tcase COMPACT_I32:\n\t\treturn I32, nil\n\tcase COMPACT_I64:\n\t\treturn I64, nil\n\tcase COMPACT_DOUBLE:\n\t\treturn DOUBLE, nil\n\tcase COMPACT_FLOAT:\n\t\treturn FLOAT, nil\n\tcase COMPACT_BINARY:\n\t\treturn STRING, nil\n\tcase COMPACT_LIST:\n\t\treturn LIST, nil\n\tcase COMPACT_SET:\n\t\treturn SET, nil\n\tcase COMPACT_MAP:\n\t\treturn MAP, nil\n\tcase COMPACT_STRUCT:\n\t\treturn STRUCT, nil\n\t}\n\treturn STOP, Exception(fmt.Errorf(\"don't know what type: %#x\", t&0x0f))\n}\n\n// Given a Type value, find the appropriate CompactProtocol.Types constant.\nfunc (p *CompactProtocol) getCompactType(t Type) compactType {\n\treturn typeToCompactType[t]\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestReadWriteCompactProtocol(t *testing.T) {\n\tReadWriteProtocolTest(t, NewCompactProtocolFactory())\n\t// CompactProtocol is capable of reading and writing in different goroutines.\n\tReadWriteProtocolParallelTest(t, NewCompactProtocolFactory())\n\ttransports := []Transport{\n\t\tNewMemoryBuffer(),\n\t\tNewStreamTransportRW(bytes.NewBuffer(make([]byte, 0, 16384))),\n\t\tNewFramedTransport(NewMemoryBuffer()),\n\t}\n\tfor _, trans := range transports {\n\t\tp := NewCompactProtocol(trans)\n\t\tReadWriteBool(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteByte(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteI16(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteI32(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteI64(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteDouble(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteFloat(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteString(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteBinary(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteStruct(t, p, trans)\n\t\ttrans.Close()\n\t}\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n)\n\n// Default to using the shared http client. Library users are\n// free to change this global client or specify one through\n// HTTPClientOptions.\nvar DefaultHTTPClient *http.Client = http.DefaultClient\n\ntype HTTPClient struct {\n\tclient             *http.Client\n\tresponse           *http.Response\n\turl                *url.URL\n\trequestBuffer      *bytes.Buffer\n\theader             http.Header\n\tnsecConnectTimeout int64\n\tnsecReadTimeout    int64\n}\n\ntype HTTPClientTransportFactory struct {\n\toptions HTTPClientOptions\n\turl     string\n\tisPost  bool\n}\n\nfunc (p *HTTPClientTransportFactory) GetTransport(trans Transport) Transport {\n\tif trans != nil {\n\t\tt, ok := trans.(*HTTPClient)\n\t\tif ok && t.url != nil {\n\t\t\tif t.requestBuffer != nil {\n\t\t\t\tt2, _ := NewHTTPPostClientWithOptions(t.url.String(), p.options)\n\t\t\t\treturn t2\n\t\t\t}\n\t\t\tt2, _ := NewHTTPClientWithOptions(t.url.String(), p.options)\n\t\t\treturn t2\n\t\t}\n\t}\n\tif p.isPost {\n\t\ts, _ := NewHTTPPostClientWithOptions(p.url, p.options)\n\t\treturn s\n\t}\n\ts, _ := NewHTTPClientWithOptions(p.url, p.options)\n\treturn s\n}\n\ntype HTTPClientOptions struct {\n\t// If nil, DefaultHTTPClient is used\n\tClient *http.Client\n}\n\nfunc NewHTTPClientTransportFactory(url string) *HTTPClientTransportFactory {\n\treturn NewHTTPClientTransportFactoryWithOptions(url, HTTPClientOptions{})\n}\n\nfunc NewHTTPClientTransportFactoryWithOptions(url string, options HTTPClientOptions) *HTTPClientTransportFactory {\n\treturn &HTTPClientTransportFactory{url: url, isPost: false, options: options}\n}\n\nfunc NewHTTPPostClientTransportFactory(url string) *HTTPClientTransportFactory {\n\treturn NewHTTPPostClientTransportFactoryWithOptions(url, HTTPClientOptions{})\n}\n\nfunc NewHTTPPostClientTransportFactoryWithOptions(url string, options HTTPClientOptions) *HTTPClientTransportFactory {\n\treturn &HTTPClientTransportFactory{url: url, isPost: true, options: options}\n}\n\nfunc NewHTTPClientWithOptions(urlstr string, options HTTPClientOptions) (Transport, error) {\n\tparsedURL, err := url.Parse(urlstr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresponse, err := http.Get(urlstr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := options.Client\n\tif client == nil {\n\t\tclient = DefaultHTTPClient\n\t}\n\treturn &HTTPClient{client: client, response: response, url: parsedURL}, nil\n}\n\nfunc NewHTTPClient(urlstr string) (Transport, error) {\n\treturn NewHTTPClientWithOptions(urlstr, HTTPClientOptions{})\n}\n\nfunc NewHTTPPostClientWithOptions(urlstr string, options HTTPClientOptions) (Transport, error) {\n\tparsedURL, err := url.Parse(urlstr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuf := make([]byte, 0, 1024)\n\tclient := options.Client\n\tif client == nil {\n\t\tclient = DefaultHTTPClient\n\t}\n\treturn &HTTPClient{client: client, url: parsedURL, requestBuffer: bytes.NewBuffer(buf), header: http.Header{}}, nil\n}\n\nfunc NewHTTPPostClient(urlstr string) (Transport, error) {\n\treturn NewHTTPPostClientWithOptions(urlstr, HTTPClientOptions{})\n}\n\n// Set the HTTP Header for this specific Thrift Transport\n// It is important that you first assert the Transport as a HTTPClient type\n// like so:\n//\n// httpTrans := trans.(HTTPClient)\n// httpTrans.SetHeader(\"User-Agent\",\"Thrift Client 1.0\")\nfunc (p *HTTPClient) SetHeader(key string, value string) {\n\tp.header.Add(key, value)\n}\n\n// Get the HTTP Header represented by the supplied Header Key for this specific Thrift Transport\n// It is important that you first assert the Transport as a HTTPClient type\n// like so:\n//\n// httpTrans := trans.(HTTPClient)\n// hdrValue := httpTrans.GetHeader(\"User-Agent\")\nfunc (p *HTTPClient) GetHeader(key string) string {\n\treturn p.header.Get(key)\n}\n\n// Deletes the HTTP Header given a Header Key for this specific Thrift Transport\n// It is important that you first assert the Transport as a HTTPClient type\n// like so:\n//\n// httpTrans := trans.(HTTPClient)\n// httpTrans.DelHeader(\"User-Agent\")\nfunc (p *HTTPClient) DelHeader(key string) {\n\tp.header.Del(key)\n}\n\nfunc (p *HTTPClient) Open() error {\n\t// do nothing\n\treturn nil\n}\n\nfunc (p *HTTPClient) IsOpen() bool {\n\treturn p.response != nil || p.requestBuffer != nil\n}\n\nfunc (p *HTTPClient) closeResponse() error {\n\tvar err error\n\tif p.response != nil && p.response.Body != nil {\n\t\t// The docs specify that if keepalive is enabled and the response body is not\n\t\t// read to completion the connection will never be returned to the pool and\n\t\t// reused. Errors are being ignored here because if the connection is invalid\n\t\t// and this fails for some reason, the Close() method will do any remaining\n\t\t// cleanup.\n\t\tio.Copy(ioutil.Discard, p.response.Body)\n\n\t\terr = p.response.Body.Close()\n\t}\n\n\tp.response = nil\n\treturn err\n}\n\nfunc (p *HTTPClient) Close() error {\n\tif p.requestBuffer != nil {\n\t\tp.requestBuffer.Reset()\n\t\tp.requestBuffer = nil\n\t}\n\treturn p.closeResponse()\n}\n\nfunc (p *HTTPClient) Read(buf []byte) (int, error) {\n\tif p.response == nil {\n\t\treturn 0, NewTransportException(NOT_OPEN, \"Response buffer is empty, no request.\")\n\t}\n\tn, err := p.response.Body.Read(buf)\n\tif n > 0 && (err == nil || err == io.EOF) {\n\t\treturn n, nil\n\t}\n\treturn n, NewTransportExceptionFromError(err)\n}\n\nfunc (p *HTTPClient) ReadByte() (c byte, err error) {\n\treturn readByte(p.response.Body)\n}\n\nfunc (p *HTTPClient) Write(buf []byte) (int, error) {\n\tn, err := p.requestBuffer.Write(buf)\n\treturn n, err\n}\n\nfunc (p *HTTPClient) WriteByte(c byte) error {\n\treturn p.requestBuffer.WriteByte(c)\n}\n\nfunc (p *HTTPClient) WriteString(s string) (n int, err error) {\n\treturn p.requestBuffer.WriteString(s)\n}\n\nfunc (p *HTTPClient) Flush() error {\n\t// Close any previous response body to avoid leaking connections.\n\tp.closeResponse()\n\n\treq, err := http.NewRequest(\"POST\", p.url.String(), p.requestBuffer)\n\tif err != nil {\n\t\treturn NewTransportExceptionFromError(err)\n\t}\n\tp.header.Add(\"Content-Type\", \"application/x-thrift\")\n\treq.Header = p.header\n\tresponse, err := p.client.Do(req)\n\tif err != nil {\n\t\treturn NewTransportExceptionFromError(err)\n\t}\n\tif response.StatusCode != http.StatusOK {\n\t\t// Close the response to avoid leaking file descriptors. closeResponse does\n\t\t// more than just call Close(), so temporarily assign it and reuse the logic.\n\t\tp.response = response\n\t\tp.closeResponse()\n\n\t\t// TODO(pomack) log bad response\n\t\treturn NewTransportException(UNKNOWN_TRANSPORT_EXCEPTION, \"HTTP Response code: \"+strconv.Itoa(response.StatusCode))\n\t}\n\tp.response = response\n\treturn nil\n}\n\nfunc (p *HTTPClient) RemainingBytes() (num_bytes uint64) {\n\tlen := p.response.ContentLength\n\tif len >= 0 {\n\t\treturn uint64(len)\n\t}\n\n\treturn UnknownRemaining // the truth is, we just don't know unless framed is used\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nconst PROTOCOL_BINARY_DATA_SIZE = 155\n\ntype fieldData struct {\n\tname  string\n\ttyp   Type\n\tid    int16\n\tvalue interface{}\n}\n\ntype structData struct {\n\tname   string\n\tfields []fieldData\n}\n\nvar (\n\tdata           string // test data for writing\n\tprotocol_bdata []byte // test data for writing; same as data\n\tboolValues     = []bool{false, true, false, false, true}\n\tbyteValues     = []byte{117, 0, 1, 32, 127, 128, 255}\n\tint16Values    = []int16{459, 0, 1, -1, -128, 127, 32767, -32768}\n\tint32Values    = []int32{459, 0, 1, -1, -128, 127, 32767, 2147483647, -2147483535}\n\tint64Values    = []int64{459, 0, 1, -1, -128, 127, 32767, 2147483647, -2147483535, 34359738481, -35184372088719, -9223372036854775808, 9223372036854775807}\n\tdoubleValues   = []float64{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float64(), NEGATIVE_INFINITY.Float64(), NAN.Float64()}\n\tfloatValues    = []float32{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float32(), NEGATIVE_INFINITY.Float32(), NAN.Float32()}\n\tstringValues   = []string{\"\", \"a\", \"st[uf]f\", \"st,u:ff with spaces\", \"stuff\\twith\\nescape\\\\characters'...\\\"lots{of}fun</xml>\"}\n\tstructTestData = structData{\n\t\tname: \"test struct\",\n\t\tfields: []fieldData{\n\t\t\tfieldData{\n\t\t\t\tname:  \"field1\",\n\t\t\t\ttyp:   BOOL,\n\t\t\t\tid:    1,\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t\tfieldData{\n\t\t\t\tname:  \"field2\",\n\t\t\t\ttyp:   STRING,\n\t\t\t\tid:    2,\n\t\t\t\tvalue: \"hi\",\n\t\t\t},\n\t\t},\n\t}\n)\n\n// var floatValues   []float32 = []float32{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float32(), NEGATIVE_INFINITY.Float32(), NAN.Float32()}\n\n// func floatValues() []\nfunc init() {\n\tprotocol_bdata = make([]byte, PROTOCOL_BINARY_DATA_SIZE)\n\tfor i := 0; i < PROTOCOL_BINARY_DATA_SIZE; i++ {\n\t\tprotocol_bdata[i] = byte((i + 'a') % 255)\n\t}\n\tdata = string(protocol_bdata)\n}\n\ntype HTTPEchoServer struct{}\ntype HTTPHeaderEchoServer struct{}\n\nfunc (p *HTTPEchoServer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tbuf, err := ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write(buf)\n\t} else {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(buf)\n\t}\n}\n\nfunc (p *HTTPHeaderEchoServer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tbuf, err := ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write(buf)\n\t} else {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(buf)\n\t}\n}\n\nfunc HTTPClientSetupForTest(t *testing.T) net.Listener {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to setup tcp listener on local port: %s\", err)\n\t\treturn l\n\t}\n\tgo http.Serve(l, &HTTPEchoServer{})\n\treturn l\n}\n\nfunc HTTPClientSetupForHeaderTest(t *testing.T) net.Listener {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to setup tcp listener on local port: %s\", err)\n\t\treturn l\n\t}\n\tgo http.Serve(l, &HTTPHeaderEchoServer{})\n\treturn l\n}\n\nfunc tcpStreamSetupForTest(t *testing.T) (io.Reader, io.Writer) {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\trCh := make(chan io.Reader)\n\tgo func() {\n\t\tdefer close(rCh)\n\t\tfor {\n\t\t\tconn, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"could not accept tcp: %s\", err.Error())\n\t\t\t}\n\t\t\trCh <- conn\n\t\t}\n\t}()\n\n\tvar (\n\t\trConn io.Reader\n\t\twConn io.Writer\n\t)\n\n\twConn, err = net.Dial(l.Addr().Network(), l.Addr().String())\n\tif err != nil {\n\t\tt.Fatalf(\"could not dial tcp: %s\", err.Error())\n\t}\n\tselect {\n\tcase rConn = <-rCh:\n\tcase <-time.After(1 * time.Second):\n\t\tt.Fatalf(\"timed out waiting on a tcp connection\")\n\t}\n\treturn rConn, wConn\n}\n\ntype protocolTest func(t testing.TB, p Protocol, trans Transport)\n\n// ReadWriteProtocolParallelTest tests that a given protocol is safe to read\n// from and write to in different goroutines. This requires both a protocol\n// and a transport are only using shared state contained either within the set\n// of read funcs or within the  set of write funcs.\n// It also should only be used with an underlying Transport that is capable of\n// blocking reads and writes (socket, stream), since other golang Transport\n// implementations require that the data exists to be read when they are called (like bytes.Buffer)\nfunc ReadWriteProtocolParallelTest(t *testing.T, protocolFactory ProtocolFactory) {\n\trConn, wConn := tcpStreamSetupForTest(t)\n\trdr, writer := io.Pipe()\n\ttransports := []TransportFactory{\n\t\tNewStreamTransportFactory(rdr, writer, false),                             // use a pipe\n\t\tNewStreamTransportFactory(rConn, wConn, false),                            // use tcp over network\n\t\tNewFramedTransportFactory(NewStreamTransportFactory(rdr, writer, false)),  // framed over pipe\n\t\tNewFramedTransportFactory(NewStreamTransportFactory(rConn, wConn, false)), // framed over tcp\n\t}\n\tconst iterations = 100\n\n\tdoForAllTransportsParallel := func(read, write protocolTest) {\n\t\tfor _, tf := range transports {\n\t\t\ttrans := tf.GetTransport(nil)\n\t\t\tp := protocolFactory.GetProtocol(trans)\n\t\t\tvar wg sync.WaitGroup\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tfor i := 0; i < iterations; i++ {\n\t\t\t\t\twrite(t, p, trans)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tfor i := 0; i < iterations; i++ {\n\t\t\t\tread(t, p, trans)\n\t\t\t}\n\t\t\twg.Wait()\n\t\t\ttrans.Close()\n\t\t}\n\t}\n\n\tdoForAllTransportsParallel(ReadBool, WriteBool)\n\tdoForAllTransportsParallel(ReadByte, WriteByte)\n\tdoForAllTransportsParallel(ReadI16, WriteI16)\n\tdoForAllTransportsParallel(ReadI32, WriteI32)\n\tdoForAllTransportsParallel(ReadI64, WriteI64)\n\tdoForAllTransportsParallel(ReadDouble, WriteDouble)\n\tdoForAllTransportsParallel(ReadFloat, WriteFloat)\n\tdoForAllTransportsParallel(ReadString, WriteString)\n\tdoForAllTransportsParallel(ReadBinary, WriteBinary)\n\tdoForAllTransportsParallel(ReadStruct, WriteStruct)\n\n\t// perform set of many sequenced sets of reads and writes\n\tdoForAllTransportsParallel(func(t testing.TB, p Protocol, trans Transport) {\n\t\tReadBool(t, p, trans)\n\t\tReadByte(t, p, trans)\n\t\tReadI16(t, p, trans)\n\t\tReadI32(t, p, trans)\n\t\tReadI64(t, p, trans)\n\t\tReadDouble(t, p, trans)\n\t\tReadFloat(t, p, trans)\n\t\tReadString(t, p, trans)\n\t\tReadBinary(t, p, trans)\n\t\tReadStruct(t, p, trans)\n\t}, func(t testing.TB, p Protocol, trans Transport) {\n\t\tWriteBool(t, p, trans)\n\t\tWriteByte(t, p, trans)\n\t\tWriteI16(t, p, trans)\n\t\tWriteI32(t, p, trans)\n\t\tWriteI64(t, p, trans)\n\t\tWriteDouble(t, p, trans)\n\t\tWriteFloat(t, p, trans)\n\t\tWriteString(t, p, trans)\n\t\tWriteBinary(t, p, trans)\n\t\tWriteStruct(t, p, trans)\n\t})\n}\n\nfunc ReadWriteProtocolTest(t *testing.T, protocolFactory ProtocolFactory) {\n\tbuf := bytes.NewBuffer(make([]byte, 0, 1024))\n\tl := HTTPClientSetupForTest(t)\n\tdefer l.Close()\n\ttransports := []TransportFactory{\n\t\tNewMemoryBufferTransportFactory(1024),\n\t\tNewStreamTransportFactory(buf, buf, true),\n\t\tNewFramedTransportFactory(NewMemoryBufferTransportFactory(1024)),\n\t\tNewHTTPPostClientTransportFactory(\"http://\" + l.Addr().String()),\n\t}\n\n\tdoForAllTransports := func(protTest protocolTest) {\n\t\tfor _, tf := range transports {\n\t\t\ttrans := tf.GetTransport(nil)\n\t\t\tp := protocolFactory.GetProtocol(trans)\n\t\t\tprotTest(t, p, trans)\n\t\t\ttrans.Close()\n\t\t}\n\t}\n\n\tdoForAllTransports(ReadWriteBool)\n\tdoForAllTransports(ReadWriteByte)\n\tdoForAllTransports(ReadWriteI16)\n\tdoForAllTransports(ReadWriteI32)\n\tdoForAllTransports(ReadWriteI64)\n\tdoForAllTransports(ReadWriteDouble)\n\tdoForAllTransports(ReadWriteFloat)\n\tdoForAllTransports(ReadWriteString)\n\tdoForAllTransports(ReadWriteBinary)\n\tdoForAllTransports(ReadWriteStruct)\n\n\t// perform set of many sequenced reads and writes\n\tdoForAllTransports(func(t testing.TB, p Protocol, trans Transport) {\n\t\tReadWriteI64(t, p, trans)\n\t\tReadWriteDouble(t, p, trans)\n\t\tReadWriteFloat(t, p, trans)\n\t\tReadWriteBinary(t, p, trans)\n\t\tReadWriteByte(t, p, trans)\n\t\tReadWriteStruct(t, p, trans)\n\t})\n}\n\nfunc ReadBool(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(BOOL)\n\tthelen := len(boolValues)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %v\", \"ReadBool\", p, trans, err, boolValues)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadBool\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadBool\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range boolValues {\n\t\tvalue, err := p.ReadBool()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading bool at index %d: %t\", \"ReadBool\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: index %d %q %q %t != %t\", \"ReadBool\", k, p, trans, v, value)\n\t\t}\n\t}\n\terr = p.ReadListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadBool\", p, trans, err)\n\t}\n}\n\nfunc WriteBool(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(BOOL)\n\tthelen := len(boolValues)\n\terr := p.WriteListBegin(thetype, thelen)\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error writing list begin: %q\", \"WriteBool\", p, trans, err, thetype)\n\t}\n\tfor k, v := range boolValues {\n\t\terr = p.WriteBool(v)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error writing bool in list at index %d: %t\", \"WriteBool\", p, trans, err, k, v)\n\t\t}\n\t}\n\tp.WriteListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error writing list end: %v\", \"WriteBool\", p, trans, err, boolValues)\n\t}\n\terr = p.Flush()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to flush: %q\", \"WriteBool\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteBool(t testing.TB, p Protocol, trans Transport) {\n\tWriteBool(t, p, trans)\n\tReadBool(t, p, trans)\n}\n\nfunc WriteByte(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(BYTE)\n\tthelen := len(byteValues)\n\terr := p.WriteListBegin(thetype, thelen)\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error writing list begin: %q\", \"WriteByte\", p, trans, err, thetype)\n\t}\n\tfor k, v := range byteValues {\n\t\terr = p.WriteByte(v)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error writing byte in list at index %d: %q\", \"WriteByte\", p, trans, err, k, v)\n\t\t}\n\t}\n\terr = p.WriteListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error writing list end: %q\", \"WriteByte\", p, trans, err, byteValues)\n\t}\n\terr = p.Flush()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error flushing list of bytes: %q\", \"WriteByte\", p, trans, err, byteValues)\n\t}\n}\n\nfunc ReadByte(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(BYTE)\n\tthelen := len(byteValues)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %q\", \"ReadByte\", p, trans, err, byteValues)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadByte\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadByte\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range byteValues {\n\t\tvalue, err := p.ReadByte()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading byte at index %d: %q\", \"ReadByte\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %d != %d\", \"ReadByte\", p, trans, v, value)\n\t\t}\n\t}\n\terr = p.ReadListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadByte\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteByte(t testing.TB, p Protocol, trans Transport) {\n\tWriteByte(t, p, trans)\n\tReadByte(t, p, trans)\n}\n\nfunc WriteI16(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I16)\n\tthelen := len(int16Values)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range int16Values {\n\t\tp.WriteI16(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n}\n\nfunc ReadI16(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I16)\n\tthelen := len(int16Values)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %q\", \"ReadI16\", p, trans, err, int16Values)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadI16\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadI16\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range int16Values {\n\t\tvalue, err := p.ReadI16()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading int16 at index %d: %q\", \"ReadI16\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %d != %d\", \"ReadI16\", p, trans, v, value)\n\t\t}\n\t}\n\terr = p.ReadListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadI16\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteI16(t testing.TB, p Protocol, trans Transport) {\n\tWriteI16(t, p, trans)\n\tReadI16(t, p, trans)\n}\n\nfunc WriteI32(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I32)\n\tthelen := len(int32Values)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range int32Values {\n\t\tp.WriteI32(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n}\n\nfunc ReadI32(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I32)\n\tthelen := len(int32Values)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %q\", \"ReadI32\", p, trans, err, int32Values)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadI32\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadI32\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range int32Values {\n\t\tvalue, err := p.ReadI32()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading int32 at index %d: %q\", \"ReadI32\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %d != %d\", \"ReadI32\", p, trans, v, value)\n\t\t}\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadI32\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteI32(t testing.TB, p Protocol, trans Transport) {\n\tWriteI32(t, p, trans)\n\tReadI32(t, p, trans)\n}\n\nfunc WriteI64(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I64)\n\tthelen := len(int64Values)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range int64Values {\n\t\tp.WriteI64(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n}\n\nfunc ReadI64(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I64)\n\tthelen := len(int64Values)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %q\", \"ReadI64\", p, trans, err, int64Values)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadI64\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadI64\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range int64Values {\n\t\tvalue, err := p.ReadI64()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading int64 at index %d: %q\", \"ReadI64\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %q != %q\", \"ReadI64\", p, trans, v, value)\n\t\t}\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadI64\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteI64(t testing.TB, p Protocol, trans Transport) {\n\tWriteI64(t, p, trans)\n\tReadI64(t, p, trans)\n}\n\nfunc WriteDouble(t testing.TB, p Protocol, trans Transport) {\n\tdoubleValues = []float64{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float64(), NEGATIVE_INFINITY.Float64(), NAN.Float64()}\n\tthetype := Type(DOUBLE)\n\tthelen := len(doubleValues)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range doubleValues {\n\t\tp.WriteDouble(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n\n}\n\nfunc ReadDouble(t testing.TB, p Protocol, trans Transport) {\n\tdoubleValues = []float64{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float64(), NEGATIVE_INFINITY.Float64(), NAN.Float64()}\n\tthetype := Type(DOUBLE)\n\tthelen := len(doubleValues)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %v\", \"ReadDouble\", p, trans, err, doubleValues)\n\t}\n\tif thetype != thetype2 {\n\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadDouble\", p, trans, thetype, thetype2)\n\t}\n\tif thelen != thelen2 {\n\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadDouble\", p, trans, thelen, thelen2)\n\t}\n\tfor k, v := range doubleValues {\n\t\tvalue, err := p.ReadDouble()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading double at index %d: %f\", \"ReadDouble\", p, trans, err, k, v)\n\t\t}\n\t\tif math.IsNaN(v) {\n\t\t\tif !math.IsNaN(value) {\n\t\t\t\tt.Fatalf(\"%s: %T %T math.IsNaN(%f) != math.IsNaN(%f)\", \"ReadDouble\", p, trans, v, value)\n\t\t\t}\n\t\t} else if v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %f != %f\", \"ReadDouble\", p, trans, v, value)\n\t\t}\n\t}\n\terr = p.ReadListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadDouble\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteDouble(t testing.TB, p Protocol, trans Transport) {\n\tWriteDouble(t, p, trans)\n\tReadDouble(t, p, trans)\n}\n\nfunc WriteFloat(t testing.TB, p Protocol, trans Transport) {\n\tfloatValues = []float32{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float32(), NEGATIVE_INFINITY.Float32(), NAN.Float32()}\n\n\tthetype := Type(FLOAT)\n\tthelen := len(floatValues)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range floatValues {\n\t\tp.WriteFloat(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n\n}\n\nfunc ReadFloat(t testing.TB, p Protocol, trans Transport) {\n\tfloatValues = []float32{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float32(), NEGATIVE_INFINITY.Float32(), NAN.Float32()}\n\n\tthetype := Type(FLOAT)\n\tthelen := len(floatValues)\n\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %v\", \"ReadFloat\", p, trans, err, floatValues)\n\t}\n\tif thetype != thetype2 {\n\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadFloat\", p, trans, thetype, thetype2)\n\t}\n\tif thelen != thelen2 {\n\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadFloat\", p, trans, thelen, thelen2)\n\t}\n\tfor k, v := range floatValues {\n\t\tvalue, err := p.ReadFloat()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading double at index %d: %f\", \"ReadFloat\", p, trans, err, k, v)\n\t\t}\n\t\tif math.IsNaN(float64(v)) {\n\t\t\tif !math.IsNaN(float64(value)) {\n\t\t\t\tt.Fatalf(\"%s: %T %T math.IsNaN(%f) != math.IsNaN(%f)\", \"ReadFloat\", p, trans, v, value)\n\t\t\t}\n\t\t} else if v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %f != %f\", \"ReadFloat\", p, trans, v, value)\n\t\t}\n\t}\n\terr = p.ReadListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadFloat\", p, trans, err)\n\t}\n\n}\n\nfunc ReadWriteFloat(t testing.TB, p Protocol, trans Transport) {\n\tWriteFloat(t, p, trans)\n\tReadFloat(t, p, trans)\n}\n\nfunc WriteString(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(STRING)\n\tthelen := len(stringValues)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range stringValues {\n\t\tp.WriteString(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n}\n\nfunc ReadString(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(STRING)\n\tthelen := len(stringValues)\n\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %q\", \"ReadString\", p, trans, err, stringValues)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadString\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadString\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range stringValues {\n\t\tvalue, err := p.ReadString()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading string at index %d: %q\", \"ReadString\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %s != %s\", \"ReadString\", p, trans, v, value)\n\t\t}\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadString\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteString(t testing.TB, p Protocol, trans Transport) {\n\tWriteString(t, p, trans)\n\tReadString(t, p, trans)\n}\n\nfunc WriteBinary(t testing.TB, p Protocol, trans Transport) {\n\tv := protocol_bdata\n\tp.WriteBinary(v)\n\tp.Flush()\n}\n\nfunc ReadBinary(t testing.TB, p Protocol, trans Transport) {\n\tv := protocol_bdata\n\tvalue, err := p.ReadBinary()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read binary: %s\", \"ReadBinary\", p, trans, err.Error())\n\t}\n\tif len(v) != len(value) {\n\t\tt.Fatalf(\"%s: %T %T len(v) != len(value)... %d != %d\", \"ReadBinary\", p, trans, len(v), len(value))\n\t} else {\n\t\tfor i := 0; i < len(v); i++ {\n\t\t\tif v[i] != value[i] {\n\t\t\t\tt.Fatalf(\"%s: %T %T %s != %s\", \"ReadBinary\", p, trans, v, value)\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nfunc ReadWriteBinary(t testing.TB, p Protocol, trans Transport) {\n\tWriteBinary(t, p, trans)\n\tReadBinary(t, p, trans)\n}\n\nfunc WriteStruct(t testing.TB, p Protocol, trans Transport) {\n\tv := structTestData\n\tp.WriteStructBegin(v.name)\n\tp.WriteFieldBegin(v.fields[0].name, v.fields[0].typ, v.fields[0].id)\n\terr := p.WriteBool(v.fields[0].value.(bool))\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read bool: %s\", \"WriteStruct\", p, trans, err.Error())\n\t}\n\tp.WriteFieldEnd()\n\tp.WriteFieldBegin(v.fields[1].name, v.fields[1].typ, v.fields[1].id)\n\terr = p.WriteString(v.fields[1].value.(string))\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read string: %s\", \"WriteStruct\", p, trans, err.Error())\n\t}\n\tp.WriteFieldEnd()\n\tp.WriteStructEnd()\n\terr = p.Flush()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to flush: %s\", \"WriteStruct\", p, trans, err.Error())\n\t}\n}\n\nfunc ReadStruct(t testing.TB, p Protocol, trans Transport) {\n\tv := structTestData\n\t_, err := p.ReadStructBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read struct begin: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\t_, typeID, id, err := p.ReadFieldBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read field begin: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\tif v.fields[0].typ != typeID {\n\t\tt.Fatalf(\"%s: %T %T type (%d) != (%d)\", \"ReadStruct\", p, trans, v.fields[0].typ, typeID)\n\t}\n\tif v.fields[0].id != id {\n\t\tt.Fatalf(\"%s: %T %T id (%d) != (%d)\", \"ReadStruct\", p, trans, v.fields[0].id, id)\n\t}\n\n\tval, err := p.ReadBool()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read bool: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\tif v.fields[0].value != val {\n\t\tt.Fatalf(\"%s: %T %T value (%v) != (%v)\", \"ReadStruct\", p, trans, v.fields[0].value, val)\n\t}\n\n\terr = p.ReadFieldEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read field end: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\n\t_, typeID, id, err = p.ReadFieldBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read field begin: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\tif v.fields[1].typ != typeID {\n\t\tt.Fatalf(\"%s: %T %T type (%d) != (%d)\", \"ReadStruct\", p, trans, v.fields[1].typ, typeID)\n\t}\n\tif v.fields[1].id != id {\n\t\tt.Fatalf(\"%s: %T %T id (%d) != (%d)\", \"ReadStruct\", p, trans, v.fields[1].id, id)\n\t}\n\n\tstrVal, err := p.ReadString()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read string: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\tif v.fields[1].value != strVal {\n\t\tt.Fatalf(\"%s: %T value %T (%s) != (%s)\", \"ReadStruct\", p, trans, v.fields[1].value, strVal)\n\t}\n\n\terr = p.ReadFieldEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read field end: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\n\terr = p.ReadStructEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read struct end: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n}\n\nfunc ReadWriteStruct(t testing.TB, p Protocol, trans Transport) {\n\tWriteStruct(t, p, trans)\n\tReadStruct(t, p, trans)\n}\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n)\n\nconst BinaryVersionMask uint32 = 0xffff0000\nconst BinaryVersion1 uint32 = 0x80010000\n\ntype BinaryProtocol struct {\n\ttrans         RichTransport\n\torigTransport Transport\n\treader        io.Reader\n\twriter        io.Writer\n\tstrictRead    bool\n\tstrictWrite   bool\n\tbuffer        [64]byte\n}\n\ntype BinaryProtocolFactory struct {\n\tstrictRead  bool\n\tstrictWrite bool\n}\n\nfunc NewBinaryProtocolTransport(t Transport) *BinaryProtocol {\n\treturn NewBinaryProtocol(t, false, true)\n}\n\nfunc NewBinaryProtocol(t Transport, strictRead, strictWrite bool) *BinaryProtocol {\n\tp := &BinaryProtocol{origTransport: t, strictRead: strictRead, strictWrite: strictWrite}\n\tif et, ok := t.(RichTransport); ok {\n\t\tp.trans = et\n\t} else {\n\t\tp.trans = NewRichTransport(t)\n\t}\n\tp.reader = p.trans\n\tp.writer = p.trans\n\treturn p\n}\n\nfunc NewBinaryProtocolFactoryDefault() *BinaryProtocolFactory {\n\treturn NewBinaryProtocolFactory(false, true)\n}\n\nfunc NewBinaryProtocolFactory(strictRead, strictWrite bool) *BinaryProtocolFactory {\n\treturn &BinaryProtocolFactory{strictRead: strictRead, strictWrite: strictWrite}\n}\n\nfunc (p *BinaryProtocolFactory) GetProtocol(t Transport) Protocol {\n\treturn NewBinaryProtocol(t, p.strictRead, p.strictWrite)\n}\n\n/**\n * Writing Methods\n */\n\nfunc (p *BinaryProtocol) WriteMessageBegin(name string, typeId MessageType, seqId int32) error {\n\tif p.strictWrite {\n\t\tversion := uint32(VERSION_1) | uint32(typeId)\n\t\te := p.WriteI32(int32(version))\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\te = p.WriteString(name)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\te = p.WriteI32(seqId)\n\t\treturn e\n\t} else {\n\t\te := p.WriteString(name)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\te = p.WriteByte(byte(typeId))\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\te = p.WriteI32(seqId)\n\t\treturn e\n\t}\n}\n\nfunc (p *BinaryProtocol) WriteMessageEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteStructBegin(name string) error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteStructEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteFieldBegin(name string, typeId Type, id int16) error {\n\te := p.WriteByte(byte(typeId))\n\tif e != nil {\n\t\treturn e\n\t}\n\te = p.WriteI16(id)\n\treturn e\n}\n\nfunc (p *BinaryProtocol) WriteFieldEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteFieldStop() error {\n\te := p.WriteByte(STOP)\n\treturn e\n}\n\nfunc (p *BinaryProtocol) WriteMapBegin(keyType Type, valueType Type, size int) error {\n\te := p.WriteByte(byte(keyType))\n\tif e != nil {\n\t\treturn e\n\t}\n\te = p.WriteByte(byte(valueType))\n\tif e != nil {\n\t\treturn e\n\t}\n\te = p.WriteI32(int32(size))\n\treturn e\n}\n\nfunc (p *BinaryProtocol) WriteMapEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteListBegin(elemType Type, size int) error {\n\te := p.WriteByte(byte(elemType))\n\tif e != nil {\n\t\treturn e\n\t}\n\te = p.WriteI32(int32(size))\n\treturn e\n}\n\nfunc (p *BinaryProtocol) WriteListEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteSetBegin(elemType Type, size int) error {\n\te := p.WriteByte(byte(elemType))\n\tif e != nil {\n\t\treturn e\n\t}\n\te = p.WriteI32(int32(size))\n\treturn e\n}\n\nfunc (p *BinaryProtocol) WriteSetEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) WriteBool(value bool) error {\n\tif value {\n\t\treturn p.WriteByte(1)\n\t}\n\treturn p.WriteByte(0)\n}\n\nfunc (p *BinaryProtocol) WriteByte(value byte) error {\n\te := p.trans.WriteByte(value)\n\treturn NewProtocolException(e)\n}\n\nfunc (p *BinaryProtocol) WriteI16(value int16) error {\n\tv := p.buffer[0:2]\n\tbinary.BigEndian.PutUint16(v, uint16(value))\n\t_, e := p.writer.Write(v)\n\treturn NewProtocolException(e)\n}\n\nfunc (p *BinaryProtocol) WriteI32(value int32) error {\n\tv := p.buffer[0:4]\n\tbinary.BigEndian.PutUint32(v, uint32(value))\n\t_, e := p.writer.Write(v)\n\treturn NewProtocolException(e)\n}\n\nfunc (p *BinaryProtocol) WriteI64(value int64) error {\n\tv := p.buffer[0:8]\n\tbinary.BigEndian.PutUint64(v, uint64(value))\n\t_, err := p.writer.Write(v)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *BinaryProtocol) WriteDouble(value float64) error {\n\treturn p.WriteI64(int64(math.Float64bits(value)))\n}\n\nfunc (p *BinaryProtocol) WriteFloat(value float32) error {\n\treturn p.WriteI32(int32(math.Float32bits(value)))\n}\n\nfunc (p *BinaryProtocol) WriteString(value string) error {\n\te := p.WriteI32(int32(len(value)))\n\tif e != nil {\n\t\treturn e\n\t}\n\t_, err := p.trans.WriteString(value)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *BinaryProtocol) WriteBinary(value []byte) error {\n\te := p.WriteI32(int32(len(value)))\n\tif e != nil {\n\t\treturn e\n\t}\n\t_, err := p.writer.Write(value)\n\treturn NewProtocolException(err)\n}\n\n/**\n * Reading methods\n */\n\nfunc (p *BinaryProtocol) ReadMessageBegin() (name string, typeId MessageType, seqId int32, err error) {\n\tsize, e := p.ReadI32()\n\tif e != nil {\n\t\treturn \"\", typeId, 0, NewProtocolException(e)\n\t}\n\tif size < 0 {\n\t\ttypeId = MessageType(size & 0x0ff)\n\t\tversion := int64(int64(size) & VERSION_MASK)\n\t\tif version != VERSION_1 {\n\t\t\treturn name, typeId, seqId, NewProtocolExceptionWithType(BAD_VERSION, fmt.Errorf(\"Bad version in ReadMessageBegin\"))\n\t\t}\n\t\tname, e = p.ReadString()\n\t\tif e != nil {\n\t\t\treturn name, typeId, seqId, NewProtocolException(e)\n\t\t}\n\t\tseqId, e = p.ReadI32()\n\t\tif e != nil {\n\t\t\treturn name, typeId, seqId, NewProtocolException(e)\n\t\t}\n\t\treturn name, typeId, seqId, nil\n\t}\n\tif p.strictRead {\n\t\treturn name, typeId, seqId, NewProtocolExceptionWithType(BAD_VERSION, fmt.Errorf(\"Missing version in ReadMessageBegin\"))\n\t}\n\tname, e2 := p.readStringBody(size)\n\tif e2 != nil {\n\t\treturn name, typeId, seqId, e2\n\t}\n\tb, e3 := p.ReadByte()\n\tif e3 != nil {\n\t\treturn name, typeId, seqId, e3\n\t}\n\ttypeId = MessageType(b)\n\tseqId, e4 := p.ReadI32()\n\tif e4 != nil {\n\t\treturn name, typeId, seqId, e4\n\t}\n\treturn name, typeId, seqId, nil\n}\n\nfunc (p *BinaryProtocol) ReadMessageEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) ReadStructBegin() (name string, err error) {\n\treturn\n}\n\nfunc (p *BinaryProtocol) ReadStructEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) ReadFieldBegin() (name string, typeId Type, seqId int16, err error) {\n\tt, err := p.ReadByte()\n\ttypeId = Type(t)\n\tif err != nil {\n\t\treturn name, typeId, seqId, err\n\t}\n\tif t != STOP {\n\t\tseqId, err = p.ReadI16()\n\t}\n\treturn name, typeId, seqId, err\n}\n\nfunc (p *BinaryProtocol) ReadFieldEnd() error {\n\treturn nil\n}\n\nvar invalidDataLength = NewProtocolExceptionWithType(INVALID_DATA, errors.New(\"Invalid data length\"))\n\nfunc (p *BinaryProtocol) ReadMapBegin() (kType, vType Type, size int, err error) {\n\tk, e := p.ReadByte()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tkType = Type(k)\n\tv, e := p.ReadByte()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tvType = Type(v)\n\tsize32, e := p.ReadI32()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tif size32 < 0 {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tif uint64(size32*2) > p.trans.RemainingBytes() || p.trans.RemainingBytes() == UnknownRemaining {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tsize = int(size32)\n\treturn kType, vType, size, nil\n}\n\nfunc (p *BinaryProtocol) ReadMapEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) ReadListBegin() (elemType Type, size int, err error) {\n\tb, e := p.ReadByte()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\telemType = Type(b)\n\tsize32, e := p.ReadI32()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tif size32 < 0 {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tif uint64(size32) > p.trans.RemainingBytes() || p.trans.RemainingBytes() == UnknownRemaining {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tsize = int(size32)\n\n\treturn\n}\n\nfunc (p *BinaryProtocol) ReadListEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) ReadSetBegin() (elemType Type, size int, err error) {\n\tb, e := p.ReadByte()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\telemType = Type(b)\n\tsize32, e := p.ReadI32()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tif size32 < 0 {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tif uint64(size32) > p.trans.RemainingBytes() || p.trans.RemainingBytes() == UnknownRemaining {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tsize = int(size32)\n\treturn elemType, size, nil\n}\n\nfunc (p *BinaryProtocol) ReadSetEnd() error {\n\treturn nil\n}\n\nfunc (p *BinaryProtocol) ReadBool() (bool, error) {\n\tb, e := p.ReadByte()\n\tv := true\n\tif b != 1 {\n\t\tv = false\n\t}\n\treturn v, e\n}\n\nfunc (p *BinaryProtocol) ReadByte() (byte, error) {\n\tv, err := p.trans.ReadByte()\n\treturn byte(v), err\n}\n\nfunc (p *BinaryProtocol) ReadI16() (value int16, err error) {\n\tbuf := p.buffer[0:2]\n\terr = p.readAll(buf)\n\tvalue = int16(binary.BigEndian.Uint16(buf))\n\treturn value, err\n}\n\nfunc (p *BinaryProtocol) ReadI32() (value int32, err error) {\n\tbuf := p.buffer[0:4]\n\terr = p.readAll(buf)\n\tvalue = int32(binary.BigEndian.Uint32(buf))\n\treturn value, err\n}\n\nfunc (p *BinaryProtocol) ReadI64() (value int64, err error) {\n\tbuf := p.buffer[0:8]\n\terr = p.readAll(buf)\n\tvalue = int64(binary.BigEndian.Uint64(buf))\n\treturn value, err\n}\n\nfunc (p *BinaryProtocol) ReadDouble() (value float64, err error) {\n\tbuf := p.buffer[0:8]\n\terr = p.readAll(buf)\n\tvalue = math.Float64frombits(binary.BigEndian.Uint64(buf))\n\treturn value, err\n}\n\nfunc (p *BinaryProtocol) ReadFloat() (value float32, err error) {\n\tbuf := p.buffer[0:4]\n\terr = p.readAll(buf)\n\tvalue = math.Float32frombits(binary.BigEndian.Uint32(buf))\n\treturn value, err\n}\n\nfunc (p *BinaryProtocol) ReadString() (value string, err error) {\n\tsize, e := p.ReadI32()\n\tif e != nil {\n\t\treturn \"\", e\n\t}\n\tif size < 0 {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\n\treturn p.readStringBody(size)\n}\n\nfunc (p *BinaryProtocol) ReadBinary() ([]byte, error) {\n\tsize, e := p.ReadI32()\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\tif size < 0 {\n\t\treturn nil, invalidDataLength\n\t}\n\tif uint64(size) > p.trans.RemainingBytes() || p.trans.RemainingBytes() == UnknownRemaining {\n\t\treturn nil, invalidDataLength\n\t}\n\n\tisize := int(size)\n\tbuf := make([]byte, isize)\n\t_, err := io.ReadFull(p.trans, buf)\n\treturn buf, NewProtocolException(err)\n}\n\nfunc (p *BinaryProtocol) Flush() (err error) {\n\treturn NewProtocolException(p.trans.Flush())\n}\n\nfunc (p *BinaryProtocol) Skip(fieldType Type) (err error) {\n\treturn SkipDefaultDepth(p, fieldType)\n}\n\nfunc (p *BinaryProtocol) Transport() Transport {\n\treturn p.origTransport\n}\n\nfunc (p *BinaryProtocol) readAll(buf []byte) error {\n\t_, err := io.ReadFull(p.reader, buf)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *BinaryProtocol) readStringBody(size int32) (value string, err error) {\n\tif size < 0 {\n\t\treturn \"\", nil\n\t}\n\tif uint64(size) > p.trans.RemainingBytes() || p.trans.RemainingBytes() == UnknownRemaining {\n\t\treturn \"\", invalidDataLength\n\t}\n\tvar buf []byte\n\tif int(size) <= len(p.buffer) {\n\t\tbuf = p.buffer[0:size]\n\t} else {\n\t\tbuf = make([]byte, size)\n\t}\n\t_, e := io.ReadFull(p.trans, buf)\n\treturn string(buf), NewProtocolException(e)\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestReadWriteBinaryProtocol(t *testing.T) {\n\tReadWriteProtocolTest(t, NewBinaryProtocolFactoryDefault())\n}\n\nfunc TestSkipUnknownTypeBinaryProtocol(t *testing.T) {\n\tvar m MyTestStruct\n\td := NewDeserializer()\n\tf := NewBinaryProtocolFactoryDefault()\n\td.Protocol = f.GetProtocol(d.Transport)\n\t// skip over a map with invalid key/value type and ~550M entries\n\tdata := make([]byte, 1100000000)\n\tcopy(data[:], []byte(\"\\n\\x10\\rO\\t6\\x03\\n\\n\\n\\x10\\r\\n\\tsl ce\\x00\"))\n\ttransport, _ := d.Transport.(*MemoryBuffer)\n\ttransport.Buffer = bytes.NewBuffer(data)\n\tstart := time.Now()\n\terr := m.Read(d.Protocol)\n\tif err == nil {\n\t\tt.Fatalf(\"Parsed invalid message correctly\")\n\t} else if !strings.Contains(err.Error(), \"unknown type\") {\n\t\tt.Fatalf(\"Failed for reason besides unknown type\")\n\t}\n\n\tif time.Now().Sub(start).Seconds() > 5 {\n\t\tt.Fatalf(\"It should not take seconds to parse a small message\")\n\t}\n}\n\nfunc TestInitialAllocationMapBinaryProtocol(t *testing.T) {\n\tvar m MyTestStruct\n\td := NewDeserializer()\n\tf := NewBinaryProtocolFactoryDefault()\n\td.Protocol = f.GetProtocol(d.Transport)\n\t// attempts to allocate a map with 1.8B elements for a 20 byte message\n\tdata := []byte(\"\\n\\x10\\rO\\t6\\x03\\n\\n\\n\\x10\\r\\n\\tslice\\x00\")\n\terr := d.Read(&m, data)\n\tif err == nil {\n\t\tt.Fatalf(\"Parsed invalid message correctly\")\n\t} else if !strings.Contains(err.Error(), \"Invalid data length\") {\n\t\tt.Fatalf(\"Failed for reason besides Invalid data length\")\n\t}\n}\n\nfunc TestInitialAllocationListBinaryProtocol(t *testing.T) {\n\tvar m MyTestStruct\n\td := NewDeserializer()\n\tf := NewBinaryProtocolFactoryDefault()\n\td.Protocol = f.GetProtocol(d.Transport)\n\t// attempts to allocate a list with 1.8B elements for a 20 byte message\n\tdata := []byte(\"\\n\\x10\\rO\\t6\\x03\\n\\n\\n\\x10\\x0f\\n\\tslice\\x00\")\n\terr := d.Read(&m, data)\n\tif err == nil {\n\t\tt.Fatalf(\"Parsed invalid message correctly\")\n\t} else if !strings.Contains(err.Error(), \"Invalid data length\") {\n\t\tt.Fatalf(\"Failed for reason besides Invalid data length\")\n\t}\n}\n\nfunc TestInitialAllocationSetBinaryProtocol(t *testing.T) {\n\tvar m MyTestStruct\n\td := NewDeserializer()\n\tf := NewBinaryProtocolFactoryDefault()\n\td.Protocol = f.GetProtocol(d.Transport)\n\t// attempts to allocate a set with 1.8B elements for a 20 byte message\n\tdata := []byte(\"\\n\\x12\\rO\\t6\\x03\\n\\n\\n\\x10\\x0e\\n\\tslice\\x00\")\n\terr := d.Read(&m, data)\n\tif err == nil {\n\t\tt.Fatalf(\"Parsed invalid message correctly\")\n\t} else if !strings.Contains(err.Error(), \"Invalid data length\") {\n\t\tfmt.Printf(\"Got %+v\", err)\n\t\tt.Fatalf(\"Failed for reason besides Invalid data length\")\n\t}\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n)\n\nconst (\n\tCOMPACT_PROTOCOL_ID       = 0x082\n\tCOMPACT_VERSION           = 0x01\n\tCOMPACT_VERSION_BE        = 0x02\n\tCOMPACT_VERSION_MASK      = 0x1f\n\tCOMPACT_TYPE_MASK         = 0x0E0\n\tCOMPACT_TYPE_BITS         = 0x07\n\tCOMPACT_TYPE_SHIFT_AMOUNT = 5\n)\n\ntype compactType byte\n\nconst (\n\tCOMPACT_BOOLEAN_TRUE  = 0x01\n\tCOMPACT_BOOLEAN_FALSE = 0x02\n\tCOMPACT_BYTE          = 0x03\n\tCOMPACT_I16           = 0x04\n\tCOMPACT_I32           = 0x05\n\tCOMPACT_I64           = 0x06\n\tCOMPACT_DOUBLE        = 0x07\n\tCOMPACT_BINARY        = 0x08\n\tCOMPACT_LIST          = 0x09\n\tCOMPACT_SET           = 0x0A\n\tCOMPACT_MAP           = 0x0B\n\tCOMPACT_STRUCT        = 0x0C\n\tCOMPACT_FLOAT         = 0x0D\n)\n\nvar (\n\ttypeToCompactType map[Type]compactType\n)\n\nfunc init() {\n\ttypeToCompactType = map[Type]compactType{\n\t\tSTOP:   STOP,\n\t\tBOOL:   COMPACT_BOOLEAN_TRUE,\n\t\tBYTE:   COMPACT_BYTE,\n\t\tI16:    COMPACT_I16,\n\t\tI32:    COMPACT_I32,\n\t\tI64:    COMPACT_I64,\n\t\tDOUBLE: COMPACT_DOUBLE,\n\t\tFLOAT:  COMPACT_FLOAT,\n\t\tSTRING: COMPACT_BINARY,\n\t\tLIST:   COMPACT_LIST,\n\t\tSET:    COMPACT_SET,\n\t\tMAP:    COMPACT_MAP,\n\t\tSTRUCT: COMPACT_STRUCT,\n\t}\n}\n\ntype CompactProtocolFactory struct{}\n\nfunc NewCompactProtocolFactory() *CompactProtocolFactory {\n\treturn &CompactProtocolFactory{}\n}\n\nfunc (p *CompactProtocolFactory) GetProtocol(trans Transport) Protocol {\n\treturn NewCompactProtocol(trans)\n}\n\ntype CompactProtocol struct {\n\ttrans         RichTransport\n\torigTransport Transport\n\n\t// Used to keep track of the last field for the current and previous structs,\n\t// so we can do the delta stuff.\n\t// writing\n\tlastFieldWritten   []int\n\tlastFieldIDWritten int\n\t// reading\n\tlastFieldRead   []int\n\tlastFieldIDRead int\n\n\t// If we encounter a boolean field begin, save the Field here so it can\n\t// have the value incorporated. This is only used for writes.\n\tbooleanFieldName    string\n\tbooleanFieldID      int16\n\tbooleanFieldPending bool\n\n\t// If we read a field header, and it's a boolean field, save the boolean\n\t// value here so that readBool can use it. This is only used for reads.\n\tboolValue          bool\n\tboolValueIsNotNull bool\n\n\trBuffer [64]byte // reading\n\twBuffer [64]byte // writing\n\n\tversion int\n}\n\n// Create a CompactProtocol given a Transport\nfunc NewCompactProtocol(trans Transport) *CompactProtocol {\n\tp := &CompactProtocol{origTransport: trans, version: COMPACT_VERSION_BE}\n\tif et, ok := trans.(RichTransport); ok {\n\t\tp.trans = et\n\t} else {\n\t\tp.trans = NewRichTransport(trans)\n\t}\n\n\treturn p\n}\n\n//\n// Public Writing methods.\n//\n\n// Write a message header to the wire. Compact Protocol messages contain the\n// protocol version so we can migrate forwards in the future if need be.\nfunc (p *CompactProtocol) WriteMessageBegin(name string, typeId MessageType, seqid int32) error {\n\terr := p.writeByteDirect(COMPACT_PROTOCOL_ID)\n\tif err != nil {\n\t\treturn NewProtocolException(err)\n\t}\n\terr = p.writeByteDirect((byte(p.version) & COMPACT_VERSION_MASK) | ((byte(typeId) << COMPACT_TYPE_SHIFT_AMOUNT) & COMPACT_TYPE_MASK))\n\tif err != nil {\n\t\treturn NewProtocolException(err)\n\t}\n\t_, err = p.writeVarint32(seqid)\n\tif err != nil {\n\t\treturn NewProtocolException(err)\n\t}\n\te := p.WriteString(name)\n\treturn e\n\n}\n\nfunc (p *CompactProtocol) WriteMessageEnd() error { return nil }\n\n// Write a struct begin. This doesn't actually put anything on the wire. We\n// use it as an opportunity to put special placeholder markers on the field\n// stack so we can get the field id deltas correct.\nfunc (p *CompactProtocol) WriteStructBegin(name string) error {\n\tp.lastFieldWritten = append(p.lastFieldWritten, p.lastFieldIDWritten)\n\tp.lastFieldIDWritten = 0\n\treturn nil\n}\n\n// Write a struct end. This doesn't actually put anything on the wire. We use\n// this as an opportunity to pop the last field from the current struct off\n// of the field stack.\nfunc (p *CompactProtocol) WriteStructEnd() error {\n\tp.lastFieldIDWritten = p.lastFieldWritten[len(p.lastFieldWritten)-1]\n\tp.lastFieldWritten = p.lastFieldWritten[:len(p.lastFieldWritten)-1]\n\treturn nil\n}\n\nfunc (p *CompactProtocol) WriteFieldBegin(name string, typeId Type, id int16) error {\n\tif typeId == BOOL {\n\t\t// we want to possibly include the value, so we'll wait.\n\t\tp.booleanFieldName, p.booleanFieldID, p.booleanFieldPending = name, id, true\n\t\treturn nil\n\t}\n\t_, err := p.writeFieldBeginInternal(name, typeId, id, 0xFF)\n\treturn NewProtocolException(err)\n}\n\n// The workhorse of writeFieldBegin. It has the option of doing a\n// 'type override' of the type header. This is used specifically in the\n// boolean field case.\nfunc (p *CompactProtocol) writeFieldBeginInternal(name string, typeId Type, id int16, typeOverride byte) (int, error) {\n\t// short lastFieldWritten = lastFieldWritten_.pop();\n\n\t// if there's a type override, use that.\n\tvar typeToWrite byte\n\tif typeOverride == 0xFF {\n\t\ttypeToWrite = byte(p.getCompactType(typeId))\n\t} else {\n\t\ttypeToWrite = typeOverride\n\t}\n\t// check if we can use delta encoding for the field id\n\tfieldId := int(id)\n\twritten := 0\n\tif fieldId > p.lastFieldIDWritten && fieldId-p.lastFieldIDWritten <= 15 {\n\t\t// write them together\n\t\terr := p.writeByteDirect(byte((fieldId-p.lastFieldIDWritten)<<4) | typeToWrite)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t} else {\n\t\t// write them separate\n\t\terr := p.writeByteDirect(typeToWrite)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\terr = p.WriteI16(id)\n\t\twritten = 1 + 2\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\tp.lastFieldIDWritten = fieldId\n\t// p.lastFieldWritten.Push(field.id);\n\treturn written, nil\n}\n\nfunc (p *CompactProtocol) WriteFieldEnd() error { return nil }\n\nfunc (p *CompactProtocol) WriteFieldStop() error {\n\terr := p.writeByteDirect(STOP)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *CompactProtocol) WriteMapBegin(keyType Type, valueType Type, size int) error {\n\tif size == 0 {\n\t\terr := p.writeByteDirect(0)\n\t\treturn NewProtocolException(err)\n\t}\n\t_, err := p.writeVarint32(int32(size))\n\tif err != nil {\n\t\treturn NewProtocolException(err)\n\t}\n\terr = p.writeByteDirect(byte(p.getCompactType(keyType))<<4 | byte(p.getCompactType(valueType)))\n\treturn NewProtocolException(err)\n}\n\nfunc (p *CompactProtocol) WriteMapEnd() error { return nil }\n\n// Write a list header.\nfunc (p *CompactProtocol) WriteListBegin(elemType Type, size int) error {\n\t_, err := p.writeCollectionBegin(elemType, size)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *CompactProtocol) WriteListEnd() error { return nil }\n\n// Write a set header.\nfunc (p *CompactProtocol) WriteSetBegin(elemType Type, size int) error {\n\t_, err := p.writeCollectionBegin(elemType, size)\n\treturn NewProtocolException(err)\n}\n\nfunc (p *CompactProtocol) WriteSetEnd() error { return nil }\n\nfunc (p *CompactProtocol) WriteBool(value bool) error {\n\tv := byte(COMPACT_BOOLEAN_FALSE)\n\tif value {\n\t\tv = byte(COMPACT_BOOLEAN_TRUE)\n\t}\n\tif p.booleanFieldPending {\n\t\t// we haven't written the field header yet\n\t\t_, err := p.writeFieldBeginInternal(p.booleanFieldName, BOOL, p.booleanFieldID, v)\n\t\tp.booleanFieldPending = false\n\t\treturn NewProtocolException(err)\n\t}\n\t// we're not part of a field, so just write the value.\n\terr := p.writeByteDirect(v)\n\treturn NewProtocolException(err)\n}\n\n// Write a byte. Nothing to see here!\nfunc (p *CompactProtocol) WriteByte(value byte) error {\n\terr := p.writeByteDirect(value)\n\treturn NewProtocolException(err)\n}\n\n// Write an I16 as a zigzag varint.\nfunc (p *CompactProtocol) WriteI16(value int16) error {\n\t_, err := p.writeVarint32(p.int32ToZigzag(int32(value)))\n\treturn NewProtocolException(err)\n}\n\n// Write an i32 as a zigzag varint.\nfunc (p *CompactProtocol) WriteI32(value int32) error {\n\t_, err := p.writeVarint32(p.int32ToZigzag(value))\n\treturn NewProtocolException(err)\n}\n\n// Write an i64 as a zigzag varint.\nfunc (p *CompactProtocol) WriteI64(value int64) error {\n\t_, err := p.writeVarint64(p.int64ToZigzag(value))\n\treturn NewProtocolException(err)\n}\n\n// Write a double to the wire as 8 bytes.\nfunc (p *CompactProtocol) WriteDouble(value float64) error {\n\tbuf := p.wBuffer[0:8]\n\tif p.version == COMPACT_VERSION {\n\t\tbinary.LittleEndian.PutUint64(buf, math.Float64bits(value))\n\t} else {\n\t\tbinary.BigEndian.PutUint64(buf, math.Float64bits(value))\n\t}\n\t_, err := p.trans.Write(buf)\n\treturn NewProtocolException(err)\n}\n\n// Write a float to the wire as 4 bytes.\nfunc (p *CompactProtocol) WriteFloat(value float32) error {\n\tbuf := p.wBuffer[0:4]\n\tbinary.BigEndian.PutUint32(buf, math.Float32bits(value))\n\t_, err := p.trans.Write(buf)\n\treturn NewProtocolException(err)\n}\n\n// Write a string to the wire with a varint size preceding.\nfunc (p *CompactProtocol) WriteString(value string) error {\n\t_, e := p.writeVarint32(int32(len(value)))\n\tif e != nil {\n\t\treturn NewProtocolException(e)\n\t}\n\tif len(value) > 0 {\n\t}\n\t_, e = p.trans.WriteString(value)\n\treturn e\n}\n\n// Write a byte array, using a varint for the size.\nfunc (p *CompactProtocol) WriteBinary(bin []byte) error {\n\t_, e := p.writeVarint32(int32(len(bin)))\n\tif e != nil {\n\t\treturn NewProtocolException(e)\n\t}\n\tif len(bin) > 0 {\n\t\t_, e = p.trans.Write(bin)\n\t\treturn NewProtocolException(e)\n\t}\n\treturn nil\n}\n\n//\n// Reading methods.\n//\n\n// Read a message header.\nfunc (p *CompactProtocol) ReadMessageBegin() (name string, typeId MessageType, seqId int32, err error) {\n\n\tprotocolId, err := p.readByteDirect()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif protocolId != COMPACT_PROTOCOL_ID {\n\t\te := fmt.Errorf(\"Expected protocol id %02x but got %02x\", COMPACT_PROTOCOL_ID, protocolId)\n\t\treturn \"\", typeId, seqId, NewProtocolExceptionWithType(BAD_VERSION, e)\n\t}\n\n\tversionAndType, err := p.readByteDirect()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tversion := versionAndType & COMPACT_VERSION_MASK\n\ttypeId = MessageType((versionAndType >> COMPACT_TYPE_SHIFT_AMOUNT) & COMPACT_TYPE_BITS)\n\tif version == COMPACT_VERSION || version == COMPACT_VERSION_BE {\n\t\tp.version = int(version)\n\t} else {\n\t\te := fmt.Errorf(\"Expected version %02x or %02x but got %02x\", COMPACT_VERSION, COMPACT_VERSION_BE, version)\n\t\terr = NewProtocolExceptionWithType(BAD_VERSION, e)\n\t\treturn\n\t}\n\tseqId, e := p.readVarint32()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tname, err = p.ReadString()\n\treturn\n}\n\nfunc (p *CompactProtocol) ReadMessageEnd() error { return nil }\n\n// Read a struct begin. There's nothing on the wire for this, but it is our\n// opportunity to push a new struct begin marker onto the field stack.\nfunc (p *CompactProtocol) ReadStructBegin() (name string, err error) {\n\tp.lastFieldRead = append(p.lastFieldRead, p.lastFieldIDRead)\n\tp.lastFieldIDRead = 0\n\treturn\n}\n\n// Doesn't actually consume any wire data, just removes the last field for\n// this struct from the field stack.\nfunc (p *CompactProtocol) ReadStructEnd() error {\n\t// consume the last field we read off the wire.\n\tp.lastFieldIDRead = p.lastFieldRead[len(p.lastFieldRead)-1]\n\tp.lastFieldRead = p.lastFieldRead[:len(p.lastFieldRead)-1]\n\treturn nil\n}\n\n// Read a field header off the wire.\nfunc (p *CompactProtocol) ReadFieldBegin() (name string, typeId Type, id int16, err error) {\n\tt, err := p.readByteDirect()\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// if it's a stop, then we can return immediately, as the struct is over.\n\tif (t & 0x0f) == STOP {\n\t\treturn \"\", STOP, 0, nil\n\t}\n\t// mask off the 4 MSB of the type header. it could contain a field id delta.\n\tmodifier := int16((t & 0xf0) >> 4)\n\tif modifier == 0 {\n\t\t// not a delta. look ahead for the zigzag varint field id.\n\t\tid, err = p.ReadI16()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t} else {\n\t\t// has a delta. add the delta to the last read field id.\n\t\tid = int16(p.lastFieldIDRead) + modifier\n\t}\n\ttypeId, e := p.getType(compactType(t & 0x0f))\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\n\t// if this happens to be a boolean field, the value is encoded in the type\n\tif p.isBoolType(t) {\n\t\t// save the boolean value in a special instance variable.\n\t\tp.boolValue = (byte(t)&0x0f == COMPACT_BOOLEAN_TRUE)\n\t\tp.boolValueIsNotNull = true\n\t}\n\n\t// push the new field onto the field stack so we can keep the deltas going.\n\tp.lastFieldIDRead = int(id)\n\treturn\n}\n\nfunc (p *CompactProtocol) ReadFieldEnd() error { return nil }\n\n// Read a map header off the wire. If the size is zero, skip reading the key\n// and value type. This means that 0-length maps will yield Maps without the\n// \"correct\" types.\nfunc (p *CompactProtocol) ReadMapBegin() (keyType Type, valueType Type, size int, err error) {\n\tsize32, e := p.readVarint32()\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\tif size32 < 0 {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tif uint64(size32*2) > p.trans.RemainingBytes() || p.trans.RemainingBytes() == UnknownRemaining {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\tsize = int(size32)\n\n\tkeyAndValueType := byte(STOP)\n\tif size != 0 {\n\t\tkeyAndValueType, err = p.readByteDirect()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tkeyType, _ = p.getType(compactType(keyAndValueType >> 4))\n\tvalueType, _ = p.getType(compactType(keyAndValueType & 0xf))\n\treturn\n}\n\nfunc (p *CompactProtocol) ReadMapEnd() error { return nil }\n\n// Read a list header off the wire. If the list size is 0-14, the size will\n// be packed into the element type header. If it's a longer list, the 4 MSB\n// of the element type header will be 0xF, and a varint will follow with the\n// true size.\nfunc (p *CompactProtocol) ReadListBegin() (elemType Type, size int, err error) {\n\tsize_and_type, err := p.readByteDirect()\n\tif err != nil {\n\t\treturn\n\t}\n\tsize = int((size_and_type >> 4) & 0x0f)\n\tif size == 15 {\n\t\tsize2, e := p.readVarint32()\n\t\tif e != nil {\n\t\t\terr = NewProtocolException(e)\n\t\t\treturn\n\t\t}\n\t\tif size2 < 0 {\n\t\t\terr = invalidDataLength\n\t\t\treturn\n\t\t}\n\t\tsize = int(size2)\n\t}\n\tif uint64(size) > p.trans.RemainingBytes() || p.trans.RemainingBytes() == UnknownRemaining {\n\t\terr = invalidDataLength\n\t\treturn\n\t}\n\n\telemType, e := p.getType(compactType(size_and_type))\n\tif e != nil {\n\t\terr = NewProtocolException(e)\n\t\treturn\n\t}\n\treturn\n}\n\nfunc (p *CompactProtocol) ReadListEnd() error { return nil }\n\n// Read a set header off the wire. If the set size is 0-14, the size will\n// be packed into the element type header. If it's a longer set, the 4 MSB\n// of the element type header will be 0xF, and a varint will follow with the\n// true size.\nfunc (p *CompactProtocol) ReadSetBegin() (elemType Type, size int, err error) {\n\treturn p.ReadListBegin()\n}\n\nfunc (p *CompactProtocol) ReadSetEnd() error { return nil }\n\n// Read a boolean off the wire. If this is a boolean field, the value should\n// already have been read during readFieldBegin, so we'll just consume the\n// pre-stored value. Otherwise, read a byte.\nfunc (p *CompactProtocol) ReadBool() (value bool, err error) {\n\tif p.boolValueIsNotNull {\n\t\tp.boolValueIsNotNull = false\n\t\treturn p.boolValue, nil\n\t}\n\tv, err := p.readByteDirect()\n\treturn v == COMPACT_BOOLEAN_TRUE, err\n}\n\n// Read a single byte off the wire. Nothing interesting here.\nfunc (p *CompactProtocol) ReadByte() (byte, error) {\n\tv, err := p.readByteDirect()\n\tif err != nil {\n\t\treturn 0, NewProtocolException(err)\n\t}\n\treturn v, err\n}\n\n// Read an i16 from the wire as a zigzag varint.\nfunc (p *CompactProtocol) ReadI16() (value int16, err error) {\n\tv, err := p.ReadI32()\n\treturn int16(v), err\n}\n\n// Read an i32 from the wire as a zigzag varint.\nfunc (p *CompactProtocol) ReadI32() (value int32, err error) {\n\tv, e := p.readVarint32()\n\tif e != nil {\n\t\treturn 0, NewProtocolException(e)\n\t}\n\tvalue = p.zigzagToInt32(v)\n\treturn value, nil\n}\n\n// Read an i64 from the wire as a zigzag varint.\nfunc (p *CompactProtocol) ReadI64() (value int64, err error) {\n\tv, e := p.readVarint64()\n\tif e != nil {\n\t\treturn 0, NewProtocolException(e)\n\t}\n\tvalue = p.zigzagToInt64(v)\n\treturn value, nil\n}\n\n// No magic here - just read a double off the wire.\nfunc (p *CompactProtocol) ReadDouble() (value float64, err error) {\n\tlongBits := p.rBuffer[0:8]\n\t_, e := io.ReadFull(p.trans, longBits)\n\tif e != nil {\n\t\treturn 0.0, NewProtocolException(e)\n\t}\n\tif p.version == COMPACT_VERSION {\n\t\treturn math.Float64frombits(binary.LittleEndian.Uint64(longBits)), nil\n\t} else {\n\t\treturn math.Float64frombits(binary.BigEndian.Uint64(longBits)), nil\n\t}\n}\n\n// No magic here - just read a float off the wire.\nfunc (p *CompactProtocol) ReadFloat() (value float32, err error) {\n\tbits := p.rBuffer[0:4]\n\t_, e := io.ReadFull(p.trans, bits)\n\tif e != nil {\n\t\treturn 0.0, NewProtocolException(e)\n\t}\n\treturn math.Float32frombits(binary.BigEndian.Uint32(bits)), nil\n}\n\n// Reads a []byte (via readBinary), and then UTF-8 decodes it.\nfunc (p *CompactProtocol) ReadString() (value string, err error) {\n\tlength, e := p.readVarint32()\n\tif e != nil {\n\t\treturn \"\", NewProtocolException(e)\n\t}\n\tif length < 0 {\n\t\treturn \"\", invalidDataLength\n\t}\n\tif uint64(length) > p.trans.RemainingBytes() || p.trans.RemainingBytes() == UnknownRemaining {\n\t\treturn \"\", invalidDataLength\n\t}\n\n\tif length == 0 {\n\t\treturn \"\", nil\n\t}\n\tvar buf []byte\n\tif length <= int32(len(p.rBuffer)) {\n\t\tbuf = p.rBuffer[0:length]\n\t} else {\n\t\tbuf = make([]byte, length)\n\t}\n\t_, e = io.ReadFull(p.trans, buf)\n\treturn string(buf), NewProtocolException(e)\n}\n\n// Read a []byte from the wire.\nfunc (p *CompactProtocol) ReadBinary() (value []byte, err error) {\n\tlength, e := p.readVarint32()\n\tif e != nil {\n\t\treturn nil, NewProtocolException(e)\n\t}\n\tif length == 0 {\n\t\treturn []byte{}, nil\n\t}\n\tif length < 0 {\n\t\treturn nil, invalidDataLength\n\t}\n\tif uint64(length) > p.trans.RemainingBytes() || p.trans.RemainingBytes() == UnknownRemaining {\n\t\treturn nil, invalidDataLength\n\t}\n\n\tbuf := make([]byte, length)\n\t_, e = io.ReadFull(p.trans, buf)\n\treturn buf, NewProtocolException(e)\n}\n\nfunc (p *CompactProtocol) Flush() (err error) {\n\treturn NewProtocolException(p.trans.Flush())\n}\n\nfunc (p *CompactProtocol) Skip(fieldType Type) (err error) {\n\treturn SkipDefaultDepth(p, fieldType)\n}\n\nfunc (p *CompactProtocol) Transport() Transport {\n\treturn p.origTransport\n}\n\n//\n// Internal writing methods\n//\n\n// Abstract method for writing the start of lists and sets. List and sets on\n// the wire differ only by the type indicator.\nfunc (p *CompactProtocol) writeCollectionBegin(elemType Type, size int) (int, error) {\n\tif size <= 14 {\n\t\treturn 1, p.writeByteDirect(byte(int32(size<<4) | int32(p.getCompactType(elemType))))\n\t}\n\terr := p.writeByteDirect(0xf0 | byte(p.getCompactType(elemType)))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tm, err := p.writeVarint32(int32(size))\n\treturn 1 + m, err\n}\n\n// Write an i32 as a varint. Results in 1-5 bytes on the wire.\n// TODO(pomack): make a permanent buffer like writeVarint64?\nfunc (p *CompactProtocol) writeVarint32(n int32) (int, error) {\n\ti32buf := p.wBuffer[0:5]\n\tidx := 0\n\tfor {\n\t\tif (n & ^0x7F) == 0 {\n\t\t\ti32buf[idx] = byte(n)\n\t\t\tidx++\n\t\t\t// p.writeByteDirect(byte(n));\n\t\t\tbreak\n\t\t\t// return;\n\t\t} else {\n\t\t\ti32buf[idx] = byte((n & 0x7F) | 0x80)\n\t\t\tidx++\n\t\t\t// p.writeByteDirect(byte(((n & 0x7F) | 0x80)));\n\t\t\tu := uint32(n)\n\t\t\tn = int32(u >> 7)\n\t\t}\n\t}\n\treturn p.trans.Write(i32buf[0:idx])\n}\n\n// Write an i64 as a varint. Results in 1-10 bytes on the wire.\nfunc (p *CompactProtocol) writeVarint64(n int64) (int, error) {\n\tvarint64out := p.wBuffer[0:10]\n\tidx := 0\n\tfor {\n\t\tif (n & ^0x7F) == 0 {\n\t\t\tvarint64out[idx] = byte(n)\n\t\t\tidx++\n\t\t\tbreak\n\t\t} else {\n\t\t\tvarint64out[idx] = byte((n & 0x7F) | 0x80)\n\t\t\tidx++\n\t\t\tu := uint64(n)\n\t\t\tn = int64(u >> 7)\n\t\t}\n\t}\n\treturn p.trans.Write(varint64out[0:idx])\n}\n\n// Convert l into a zigzag long. This allows negative numbers to be\n// represented compactly as a varint.\nfunc (p *CompactProtocol) int64ToZigzag(l int64) int64 {\n\treturn (l << 1) ^ (l >> 63)\n}\n\n// Convert l into a zigzag long. This allows negative numbers to be\n// represented compactly as a varint.\nfunc (p *CompactProtocol) int32ToZigzag(n int32) int32 {\n\treturn (n << 1) ^ (n >> 31)\n}\n\nfunc (p *CompactProtocol) fixedUint64ToBytes(n uint64, buf []byte) {\n\tbinary.LittleEndian.PutUint64(buf, n)\n}\n\nfunc (p *CompactProtocol) fixedInt64ToBytes(n int64, buf []byte) {\n\tbinary.LittleEndian.PutUint64(buf, uint64(n))\n}\n\n// Writes a byte without any possibility of all that field header nonsense.\n// Used internally by other writing methods that know they need to write a byte.\nfunc (p *CompactProtocol) writeByteDirect(b byte) error {\n\treturn p.trans.WriteByte(b)\n}\n\n// Writes a byte without any possibility of all that field header nonsense.\nfunc (p *CompactProtocol) writeIntAsByteDirect(n int) (int, error) {\n\treturn 1, p.writeByteDirect(byte(n))\n}\n\n//\n// Internal reading methods\n//\n\n// Read an i32 from the wire as a varint. The MSB of each byte is set\n// if there is another byte to follow. This can read up to 5 bytes.\nfunc (p *CompactProtocol) readVarint32() (int32, error) {\n\t// if the wire contains the right stuff, this will just truncate the i64 we\n\t// read and get us the right sign.\n\tv, err := p.readVarint64()\n\treturn int32(v), err\n}\n\n// Read an i64 from the wire as a proper varint. The MSB of each byte is set\n// if there is another byte to follow. This can read up to 10 bytes.\nfunc (p *CompactProtocol) readVarint64() (int64, error) {\n\tshift := uint(0)\n\tresult := int64(0)\n\tfor {\n\t\tb, err := p.readByteDirect()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tresult |= int64(b&0x7f) << shift\n\t\tif (b & 0x80) != 0x80 {\n\t\t\tbreak\n\t\t}\n\t\tshift += 7\n\t}\n\treturn result, nil\n}\n\n// Read a byte, unlike ReadByte that reads Thrift-byte that is i8.\nfunc (p *CompactProtocol) readByteDirect() (byte, error) {\n\treturn p.trans.ReadByte()\n}\n\n//\n// encoding helpers\n//\n\n// Convert from zigzag int to int.\nfunc (p *CompactProtocol) zigzagToInt32(n int32) int32 {\n\tu := uint32(n)\n\treturn int32(u>>1) ^ -(n & 1)\n}\n\n// Convert from zigzag long to long.\nfunc (p *CompactProtocol) zigzagToInt64(n int64) int64 {\n\tu := uint64(n)\n\treturn int64(u>>1) ^ -(n & 1)\n}\n\nfunc (p *CompactProtocol) bytesToInt32(b []byte) int32 {\n\treturn int32(binary.LittleEndian.Uint32(b))\n}\n\nfunc (p *CompactProtocol) bytesToUint32(b []byte) uint32 {\n\treturn binary.LittleEndian.Uint32(b)\n\n}\n\n// Note that it's important that the mask bytes are long literals,\n// otherwise they'll default to ints, and when you shift an int left 56 bits,\n// you just get a messed up int.\nfunc (p *CompactProtocol) bytesToInt64(b []byte) int64 {\n\treturn int64(binary.LittleEndian.Uint64(b))\n}\n\n// Note that it's important that the mask bytes are long literals,\n// otherwise they'll default to ints, and when you shift an int left 56 bits,\n// you just get a messed up int.\nfunc (p *CompactProtocol) bytesToUint64(b []byte) uint64 {\n\treturn binary.LittleEndian.Uint64(b)\n}\n\n//\n// type testing and converting\n//\n\nfunc (p *CompactProtocol) isBoolType(b byte) bool {\n\treturn (b&0x0f) == COMPACT_BOOLEAN_TRUE || (b&0x0f) == COMPACT_BOOLEAN_FALSE\n}\n\n// Given a compactType constant, convert it to its corresponding\n// Type value.\nfunc (p *CompactProtocol) getType(t compactType) (Type, error) {\n\tswitch byte(t) & 0x0f {\n\tcase STOP:\n\t\treturn STOP, nil\n\tcase COMPACT_BOOLEAN_FALSE, COMPACT_BOOLEAN_TRUE:\n\t\treturn BOOL, nil\n\tcase COMPACT_BYTE:\n\t\treturn BYTE, nil\n\tcase COMPACT_I16:\n\t\treturn I16, nil\n\tcase COMPACT_I32:\n\t\treturn I32, nil\n\tcase COMPACT_I64:\n\t\treturn I64, nil\n\tcase COMPACT_DOUBLE:\n\t\treturn DOUBLE, nil\n\tcase COMPACT_FLOAT:\n\t\treturn FLOAT, nil\n\tcase COMPACT_BINARY:\n\t\treturn STRING, nil\n\tcase COMPACT_LIST:\n\t\treturn LIST, nil\n\tcase COMPACT_SET:\n\t\treturn SET, nil\n\tcase COMPACT_MAP:\n\t\treturn MAP, nil\n\tcase COMPACT_STRUCT:\n\t\treturn STRUCT, nil\n\t}\n\treturn STOP, Exception(fmt.Errorf(\"don't know what type: %#x\", t&0x0f))\n}\n\n// Given a Type value, find the appropriate CompactProtocol.Types constant.\nfunc (p *CompactProtocol) getCompactType(t Type) compactType {\n\treturn typeToCompactType[t]\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestReadWriteCompactProtocol(t *testing.T) {\n\tReadWriteProtocolTest(t, NewCompactProtocolFactory())\n\t// CompactProtocol is capable of reading and writing in different goroutines.\n\tReadWriteProtocolParallelTest(t, NewCompactProtocolFactory())\n\ttransports := []Transport{\n\t\tNewMemoryBuffer(),\n\t\tNewFramedTransport(NewMemoryBuffer()),\n\t}\n\tfor _, trans := range transports {\n\t\tp := NewCompactProtocol(trans)\n\t\tReadWriteBool(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteByte(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteI16(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteI32(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteI64(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteDouble(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteFloat(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteString(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteBinary(t, p, trans)\n\t\tp = NewCompactProtocol(trans)\n\t\tReadWriteStruct(t, p, trans)\n\t\ttrans.Close()\n\t}\n}\n\nfunc TestInitialAllocationMapCompactProtocol(t *testing.T) {\n\tvar m MyTestStruct\n\td := NewDeserializer()\n\tf := NewCompactProtocolFactory()\n\td.Protocol = f.GetProtocol(d.Transport)\n\t// attempts to allocate a map of 930M elements for a 9 byte message\n\tdata := []byte(\"%0\\x88\\x8a\\x97\\xb7\\xc4\\x030\")\n\terr := d.Read(&m, data)\n\tif err == nil {\n\t\tt.Fatalf(\"Parsed invalid message correctly\")\n\t} else if !strings.Contains(err.Error(), \"Invalid data length\") {\n\t\tt.Fatalf(\"Failed for reason besides Invalid data length\")\n\t}\n}\n\nfunc TestInitialAllocationListCompactProtocol(t *testing.T) {\n\tvar m MyTestStruct\n\td := NewDeserializer()\n\tf := NewCompactProtocolFactory()\n\td.Protocol = f.GetProtocol(d.Transport)\n\t// attempts to allocate a list of 950M elements for an 11 byte message\n\tdata := []byte(\"%0\\x98\\xfa\\xb7\\xb7\\xc4\\xc4\\x03\\x01a\")\n\terr := d.Read(&m, data)\n\tif err == nil {\n\t\tt.Fatalf(\"Parsed invalid message correctly\")\n\t} else if !strings.Contains(err.Error(), \"Invalid data length\") {\n\t\tt.Fatalf(\"Failed for reason besides Invalid data length\")\n\t}\n}\n\nfunc TestInitialAllocationSetCompactProtocol(t *testing.T) {\n\tvar m MyTestStruct\n\td := NewDeserializer()\n\tf := NewCompactProtocolFactory()\n\td.Protocol = f.GetProtocol(d.Transport)\n\t// attempts to allocate a list of 950M elements for an 11 byte message\n\tdata := []byte(\"%0\\xa8\\xfa\\x97\\xb7\\xc4\\xc4\\x03\\x01a\")\n\terr := d.Read(&m, data)\n\tif err == nil {\n\t\tt.Fatalf(\"Parsed invalid message correctly\")\n\t} else if !strings.Contains(err.Error(), \"Invalid data length\") {\n\t\tt.Fatalf(\"Failed for reason besides Invalid data length\")\n\t}\n}\n\nfunc TestInitialAllocationMapCompactProtocolLimitedR(t *testing.T) {\n\tvar m MyTestStruct\n\n\t// attempts to allocate a map of 930M elements for a 9 byte message\n\tdata := []byte(\"%0\\x88\\x8a\\x97\\xb7\\xc4\\x030\")\n\tp := NewCompactProtocol(\n\t\tNewStreamTransportLimitedR(bytes.NewBuffer(data), len(data)),\n\t)\n\n\terr := m.Read(p)\n\tif err == nil {\n\t\tt.Fatalf(\"Parsed invalid message correctly\")\n\t} else if !strings.Contains(err.Error(), \"Invalid data length\") {\n\t\tt.Fatalf(\"Failed for reason besides Invalid data length\")\n\t}\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n)\n\n// Default to using the shared http client. Library users are\n// free to change this global client or specify one through\n// HTTPClientOptions.\nvar DefaultHTTPClient *http.Client = http.DefaultClient\n\ntype HTTPClient struct {\n\tclient             *http.Client\n\tresponse           *http.Response\n\turl                *url.URL\n\trequestBuffer      *bytes.Buffer\n\tresponseBuffer     bytes.Buffer\n\theader             http.Header\n\tnsecConnectTimeout int64\n\tnsecReadTimeout    int64\n}\n\ntype HTTPClientTransportFactory struct {\n\toptions HTTPClientOptions\n\turl     string\n\tisPost  bool\n}\n\nfunc (p *HTTPClientTransportFactory) GetTransport(trans Transport) Transport {\n\tif trans != nil {\n\t\tt, ok := trans.(*HTTPClient)\n\t\tif ok && t.url != nil {\n\t\t\tif t.requestBuffer != nil {\n\t\t\t\tt2, _ := NewHTTPPostClientWithOptions(t.url.String(), p.options)\n\t\t\t\treturn t2\n\t\t\t}\n\t\t\tt2, _ := NewHTTPClientWithOptions(t.url.String(), p.options)\n\t\t\treturn t2\n\t\t}\n\t}\n\tif p.isPost {\n\t\ts, _ := NewHTTPPostClientWithOptions(p.url, p.options)\n\t\treturn s\n\t}\n\ts, _ := NewHTTPClientWithOptions(p.url, p.options)\n\treturn s\n}\n\ntype HTTPClientOptions struct {\n\t// If nil, DefaultHTTPClient is used\n\tClient *http.Client\n}\n\nfunc NewHTTPClientTransportFactory(url string) *HTTPClientTransportFactory {\n\treturn NewHTTPClientTransportFactoryWithOptions(url, HTTPClientOptions{})\n}\n\nfunc NewHTTPClientTransportFactoryWithOptions(url string, options HTTPClientOptions) *HTTPClientTransportFactory {\n\treturn &HTTPClientTransportFactory{url: url, isPost: false, options: options}\n}\n\nfunc NewHTTPPostClientTransportFactory(url string) *HTTPClientTransportFactory {\n\treturn NewHTTPPostClientTransportFactoryWithOptions(url, HTTPClientOptions{})\n}\n\nfunc NewHTTPPostClientTransportFactoryWithOptions(url string, options HTTPClientOptions) *HTTPClientTransportFactory {\n\treturn &HTTPClientTransportFactory{url: url, isPost: true, options: options}\n}\n\nfunc NewHTTPClientWithOptions(urlstr string, options HTTPClientOptions) (Transport, error) {\n\tparsedURL, err := url.Parse(urlstr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresponse, err := http.Get(urlstr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := options.Client\n\tif client == nil {\n\t\tclient = DefaultHTTPClient\n\t}\n\treturn &HTTPClient{client: client, response: response, url: parsedURL}, nil\n}\n\nfunc NewHTTPClient(urlstr string) (Transport, error) {\n\treturn NewHTTPClientWithOptions(urlstr, HTTPClientOptions{})\n}\n\nfunc NewHTTPPostClientWithOptions(urlstr string, options HTTPClientOptions) (Transport, error) {\n\tparsedURL, err := url.Parse(urlstr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuf := make([]byte, 0, 1024)\n\tclient := options.Client\n\tif client == nil {\n\t\tclient = DefaultHTTPClient\n\t}\n\treturn &HTTPClient{client: client, url: parsedURL, requestBuffer: bytes.NewBuffer(buf), header: http.Header{}}, nil\n}\n\nfunc NewHTTPPostClient(urlstr string) (Transport, error) {\n\treturn NewHTTPPostClientWithOptions(urlstr, HTTPClientOptions{})\n}\n\n// Set the HTTP Header for this specific Thrift Transport\n// It is important that you first assert the Transport as a HTTPClient type\n// like so:\n//\n// httpTrans := trans.(HTTPClient)\n// httpTrans.SetHeader(\"User-Agent\",\"Thrift Client 1.0\")\nfunc (p *HTTPClient) SetHeader(key string, value string) {\n\tp.header.Add(key, value)\n}\n\n// Get the HTTP Header represented by the supplied Header Key for this specific Thrift Transport\n// It is important that you first assert the Transport as a HTTPClient type\n// like so:\n//\n// httpTrans := trans.(HTTPClient)\n// hdrValue := httpTrans.GetHeader(\"User-Agent\")\nfunc (p *HTTPClient) GetHeader(key string) string {\n\treturn p.header.Get(key)\n}\n\n// Deletes the HTTP Header given a Header Key for this specific Thrift Transport\n// It is important that you first assert the Transport as a HTTPClient type\n// like so:\n//\n// httpTrans := trans.(HTTPClient)\n// httpTrans.DelHeader(\"User-Agent\")\nfunc (p *HTTPClient) DelHeader(key string) {\n\tp.header.Del(key)\n}\n\nfunc (p *HTTPClient) Open() error {\n\t// do nothing\n\treturn nil\n}\n\nfunc (p *HTTPClient) IsOpen() bool {\n\treturn p.response != nil || p.requestBuffer != nil\n}\n\nfunc (p *HTTPClient) closeResponse() error {\n\tp.response = nil\n\tp.responseBuffer.Reset()\n\treturn nil\n}\n\nfunc (p *HTTPClient) Close() error {\n\tif p.requestBuffer != nil {\n\t\tp.requestBuffer.Reset()\n\t\tp.requestBuffer = nil\n\t}\n\treturn p.closeResponse()\n}\n\nfunc (p *HTTPClient) Read(buf []byte) (int, error) {\n\tif p.response == nil {\n\t\treturn 0, NewTransportException(NOT_OPEN, \"Response buffer is empty, no request.\")\n\t}\n\tn, err := p.responseBuffer.Read(buf)\n\tif n > 0 && (err == nil || err == io.EOF) {\n\t\treturn n, nil\n\t}\n\treturn n, NewTransportExceptionFromError(err)\n}\n\nfunc (p *HTTPClient) ReadByte() (c byte, err error) {\n\treturn readByte(&p.responseBuffer)\n}\n\nfunc (p *HTTPClient) Write(buf []byte) (int, error) {\n\tn, err := p.requestBuffer.Write(buf)\n\treturn n, err\n}\n\nfunc (p *HTTPClient) WriteByte(c byte) error {\n\treturn p.requestBuffer.WriteByte(c)\n}\n\nfunc (p *HTTPClient) WriteString(s string) (n int, err error) {\n\treturn p.requestBuffer.WriteString(s)\n}\n\nfunc (p *HTTPClient) Flush() error {\n\t// Close any previous response body to avoid leaking connections.\n\tp.closeResponse()\n\n\treq, err := http.NewRequest(\"POST\", p.url.String(), p.requestBuffer)\n\tif err != nil {\n\t\treturn NewTransportExceptionFromError(err)\n\t}\n\tp.header.Add(\"Content-Type\", \"application/x-thrift\")\n\treq.Header = p.header\n\tresponse, err := p.client.Do(req)\n\tif err != nil {\n\t\treturn NewTransportExceptionFromError(err)\n\t}\n\n\tdefer response.Body.Close()\n\n\tif response.StatusCode != http.StatusOK {\n\t\t// Close the response to avoid leaking file descriptors. closeResponse does\n\t\t// more than just call Close(), so temporarily assign it and reuse the logic.\n\t\tp.response = response\n\t\tp.closeResponse()\n\n\t\t// TODO(pomack) log bad response\n\t\treturn NewTransportException(UNKNOWN_TRANSPORT_EXCEPTION, \"HTTP Response code: \"+strconv.Itoa(response.StatusCode))\n\t}\n\n\t_, err = io.Copy(&p.responseBuffer, response.Body)\n\tif err != nil {\n\t\treturn NewTransportExceptionFromError(err)\n\t}\n\n\tp.response = response\n\treturn nil\n}\n\nfunc (p *HTTPClient) RemainingBytes() (num_bytes uint64) {\n\treturn uint64(p.responseBuffer.Len())\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage thrift\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nconst PROTOCOL_BINARY_DATA_SIZE = 155\n\ntype fieldData struct {\n\tname  string\n\ttyp   Type\n\tid    int16\n\tvalue interface{}\n}\n\ntype structData struct {\n\tname   string\n\tfields []fieldData\n}\n\nvar (\n\tdata           string // test data for writing\n\tprotocol_bdata []byte // test data for writing; same as data\n\tboolValues     = []bool{false, true, false, false, true}\n\tbyteValues     = []byte{117, 0, 1, 32, 127, 128, 255}\n\tint16Values    = []int16{459, 0, 1, -1, -128, 127, 32767, -32768}\n\tint32Values    = []int32{459, 0, 1, -1, -128, 127, 32767, 2147483647, -2147483535}\n\tint64Values    = []int64{459, 0, 1, -1, -128, 127, 32767, 2147483647, -2147483535, 34359738481, -35184372088719, -9223372036854775808, 9223372036854775807}\n\tdoubleValues   = []float64{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float64(), NEGATIVE_INFINITY.Float64(), NAN.Float64()}\n\tfloatValues    = []float32{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float32(), NEGATIVE_INFINITY.Float32(), NAN.Float32()}\n\tstringValues   = []string{\"\", \"a\", \"st[uf]f\", \"st,u:ff with spaces\", \"stuff\\twith\\nescape\\\\characters'...\\\"lots{of}fun</xml>\"}\n\tstructTestData = structData{\n\t\tname: \"test struct\",\n\t\tfields: []fieldData{\n\t\t\tfieldData{\n\t\t\t\tname:  \"field1\",\n\t\t\t\ttyp:   BOOL,\n\t\t\t\tid:    1,\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t\tfieldData{\n\t\t\t\tname:  \"field2\",\n\t\t\t\ttyp:   STRING,\n\t\t\t\tid:    2,\n\t\t\t\tvalue: \"hi\",\n\t\t\t},\n\t\t},\n\t}\n)\n\n// var floatValues   []float32 = []float32{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float32(), NEGATIVE_INFINITY.Float32(), NAN.Float32()}\n\n// func floatValues() []\nfunc init() {\n\tprotocol_bdata = make([]byte, PROTOCOL_BINARY_DATA_SIZE)\n\tfor i := 0; i < PROTOCOL_BINARY_DATA_SIZE; i++ {\n\t\tprotocol_bdata[i] = byte((i + 'a') % 255)\n\t}\n\tdata = string(protocol_bdata)\n}\n\ntype HTTPEchoServer struct{}\ntype HTTPHeaderEchoServer struct{}\n\nfunc (p *HTTPEchoServer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tbuf, err := ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write(buf)\n\t} else {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(buf)\n\t}\n}\n\nfunc (p *HTTPHeaderEchoServer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tbuf, err := ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write(buf)\n\t} else {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(buf)\n\t}\n}\n\nfunc HTTPClientSetupForTest(t *testing.T) net.Listener {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to setup tcp listener on local port: %s\", err)\n\t\treturn l\n\t}\n\tgo http.Serve(l, &HTTPEchoServer{})\n\treturn l\n}\n\nfunc HTTPClientSetupForHeaderTest(t *testing.T) net.Listener {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to setup tcp listener on local port: %s\", err)\n\t\treturn l\n\t}\n\tgo http.Serve(l, &HTTPHeaderEchoServer{})\n\treturn l\n}\n\nfunc tcpStreamSetupForTest(t *testing.T) (io.Reader, io.Writer) {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\trCh := make(chan io.Reader)\n\tgo func() {\n\t\tdefer close(rCh)\n\t\tfor {\n\t\t\tconn, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"could not accept tcp: %s\", err.Error())\n\t\t\t}\n\t\t\trCh <- conn\n\t\t}\n\t}()\n\n\tvar (\n\t\trConn io.Reader\n\t\twConn io.Writer\n\t)\n\n\twConn, err = net.Dial(l.Addr().Network(), l.Addr().String())\n\tif err != nil {\n\t\tt.Fatalf(\"could not dial tcp: %s\", err.Error())\n\t}\n\tselect {\n\tcase rConn = <-rCh:\n\tcase <-time.After(1 * time.Second):\n\t\tt.Fatalf(\"timed out waiting on a tcp connection\")\n\t}\n\treturn rConn, wConn\n}\n\ntype protocolTest func(t testing.TB, p Protocol, trans Transport)\n\n// ReadWriteProtocolParallelTest tests that a given protocol is safe to read\n// from and write to in different goroutines. This requires both a protocol\n// and a transport are only using shared state contained either within the set\n// of read funcs or within the  set of write funcs.\n// It also should only be used with an underlying Transport that is capable of\n// blocking reads and writes (socket, stream), since other golang Transport\n// implementations require that the data exists to be read when they are called (like bytes.Buffer)\nfunc ReadWriteProtocolParallelTest(t *testing.T, protocolFactory ProtocolFactory) {\n\trConn, wConn := tcpStreamSetupForTest(t)\n\trdr, writer := io.Pipe()\n\ttransports := []TransportFactory{\n\t\tNewFramedTransportFactory(NewStreamTransportFactory(rdr, writer, false)),  // framed over pipe\n\t\tNewFramedTransportFactory(NewStreamTransportFactory(rConn, wConn, false)), // framed over tcp\n\t}\n\tconst iterations = 100\n\n\tdoForAllTransportsParallel := func(read, write protocolTest) {\n\t\tfor _, tf := range transports {\n\t\t\ttrans := tf.GetTransport(nil)\n\t\t\tp := protocolFactory.GetProtocol(trans)\n\t\t\tvar wg sync.WaitGroup\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tfor i := 0; i < iterations; i++ {\n\t\t\t\t\twrite(t, p, trans)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tfor i := 0; i < iterations; i++ {\n\t\t\t\tread(t, p, trans)\n\t\t\t}\n\t\t\twg.Wait()\n\t\t\ttrans.Close()\n\t\t}\n\t}\n\n\tdoForAllTransportsParallel(ReadBool, WriteBool)\n\tdoForAllTransportsParallel(ReadByte, WriteByte)\n\tdoForAllTransportsParallel(ReadI16, WriteI16)\n\tdoForAllTransportsParallel(ReadI32, WriteI32)\n\tdoForAllTransportsParallel(ReadI64, WriteI64)\n\tdoForAllTransportsParallel(ReadDouble, WriteDouble)\n\tdoForAllTransportsParallel(ReadFloat, WriteFloat)\n\tdoForAllTransportsParallel(ReadString, WriteString)\n\tdoForAllTransportsParallel(ReadBinary, WriteBinary)\n\tdoForAllTransportsParallel(ReadStruct, WriteStruct)\n\n\t// perform set of many sequenced sets of reads and writes\n\tdoForAllTransportsParallel(func(t testing.TB, p Protocol, trans Transport) {\n\t\tReadBool(t, p, trans)\n\t\tReadByte(t, p, trans)\n\t\tReadI16(t, p, trans)\n\t\tReadI32(t, p, trans)\n\t\tReadI64(t, p, trans)\n\t\tReadDouble(t, p, trans)\n\t\tReadFloat(t, p, trans)\n\t\tReadString(t, p, trans)\n\t\tReadBinary(t, p, trans)\n\t\tReadStruct(t, p, trans)\n\t}, func(t testing.TB, p Protocol, trans Transport) {\n\t\tWriteBool(t, p, trans)\n\t\tWriteByte(t, p, trans)\n\t\tWriteI16(t, p, trans)\n\t\tWriteI32(t, p, trans)\n\t\tWriteI64(t, p, trans)\n\t\tWriteDouble(t, p, trans)\n\t\tWriteFloat(t, p, trans)\n\t\tWriteString(t, p, trans)\n\t\tWriteBinary(t, p, trans)\n\t\tWriteStruct(t, p, trans)\n\t})\n}\n\nfunc ReadWriteProtocolTest(t *testing.T, protocolFactory ProtocolFactory) {\n\tl := HTTPClientSetupForTest(t)\n\tdefer l.Close()\n\ttransports := []TransportFactory{\n\t\tNewMemoryBufferTransportFactory(1024),\n\t\tNewFramedTransportFactory(NewMemoryBufferTransportFactory(1024)),\n\t\tNewHTTPPostClientTransportFactory(\"http://\" + l.Addr().String()),\n\t}\n\n\tdoForAllTransports := func(protTest protocolTest) {\n\t\tfor _, tf := range transports {\n\t\t\ttrans := tf.GetTransport(nil)\n\t\t\tp := protocolFactory.GetProtocol(trans)\n\t\t\tprotTest(t, p, trans)\n\t\t\ttrans.Close()\n\t\t}\n\t}\n\n\tdoForAllTransports(ReadWriteBool)\n\tdoForAllTransports(ReadWriteByte)\n\tdoForAllTransports(ReadWriteI16)\n\tdoForAllTransports(ReadWriteI32)\n\tdoForAllTransports(ReadWriteI64)\n\tdoForAllTransports(ReadWriteDouble)\n\tdoForAllTransports(ReadWriteFloat)\n\tdoForAllTransports(ReadWriteString)\n\tdoForAllTransports(ReadWriteBinary)\n\tdoForAllTransports(ReadWriteStruct)\n\n\t// perform set of many sequenced reads and writes\n\tdoForAllTransports(func(t testing.TB, p Protocol, trans Transport) {\n\t\tReadWriteI64(t, p, trans)\n\t\tReadWriteDouble(t, p, trans)\n\t\tReadWriteFloat(t, p, trans)\n\t\tReadWriteBinary(t, p, trans)\n\t\tReadWriteByte(t, p, trans)\n\t\tReadWriteStruct(t, p, trans)\n\t})\n}\n\nfunc ReadBool(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(BOOL)\n\tthelen := len(boolValues)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %v\", \"ReadBool\", p, trans, err, boolValues)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadBool\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadBool\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range boolValues {\n\t\tvalue, err := p.ReadBool()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading bool at index %d: %t\", \"ReadBool\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: index %d %q %q %t != %t\", \"ReadBool\", k, p, trans, v, value)\n\t\t}\n\t}\n\terr = p.ReadListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadBool\", p, trans, err)\n\t}\n}\n\nfunc WriteBool(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(BOOL)\n\tthelen := len(boolValues)\n\terr := p.WriteListBegin(thetype, thelen)\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error writing list begin: %q\", \"WriteBool\", p, trans, err, thetype)\n\t}\n\tfor k, v := range boolValues {\n\t\terr = p.WriteBool(v)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error writing bool in list at index %d: %t\", \"WriteBool\", p, trans, err, k, v)\n\t\t}\n\t}\n\tp.WriteListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error writing list end: %v\", \"WriteBool\", p, trans, err, boolValues)\n\t}\n\terr = p.Flush()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to flush: %q\", \"WriteBool\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteBool(t testing.TB, p Protocol, trans Transport) {\n\tWriteBool(t, p, trans)\n\tReadBool(t, p, trans)\n}\n\nfunc WriteByte(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(BYTE)\n\tthelen := len(byteValues)\n\terr := p.WriteListBegin(thetype, thelen)\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error writing list begin: %q\", \"WriteByte\", p, trans, err, thetype)\n\t}\n\tfor k, v := range byteValues {\n\t\terr = p.WriteByte(v)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error writing byte in list at index %d: %q\", \"WriteByte\", p, trans, err, k, v)\n\t\t}\n\t}\n\terr = p.WriteListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error writing list end: %q\", \"WriteByte\", p, trans, err, byteValues)\n\t}\n\terr = p.Flush()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error flushing list of bytes: %q\", \"WriteByte\", p, trans, err, byteValues)\n\t}\n}\n\nfunc ReadByte(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(BYTE)\n\tthelen := len(byteValues)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %q\", \"ReadByte\", p, trans, err, byteValues)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadByte\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadByte\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range byteValues {\n\t\tvalue, err := p.ReadByte()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading byte at index %d: %q\", \"ReadByte\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %d != %d\", \"ReadByte\", p, trans, v, value)\n\t\t}\n\t}\n\terr = p.ReadListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadByte\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteByte(t testing.TB, p Protocol, trans Transport) {\n\tWriteByte(t, p, trans)\n\tReadByte(t, p, trans)\n}\n\nfunc WriteI16(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I16)\n\tthelen := len(int16Values)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range int16Values {\n\t\tp.WriteI16(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n}\n\nfunc ReadI16(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I16)\n\tthelen := len(int16Values)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %q\", \"ReadI16\", p, trans, err, int16Values)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadI16\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadI16\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range int16Values {\n\t\tvalue, err := p.ReadI16()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading int16 at index %d: %q\", \"ReadI16\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %d != %d\", \"ReadI16\", p, trans, v, value)\n\t\t}\n\t}\n\terr = p.ReadListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadI16\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteI16(t testing.TB, p Protocol, trans Transport) {\n\tWriteI16(t, p, trans)\n\tReadI16(t, p, trans)\n}\n\nfunc WriteI32(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I32)\n\tthelen := len(int32Values)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range int32Values {\n\t\tp.WriteI32(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n}\n\nfunc ReadI32(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I32)\n\tthelen := len(int32Values)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %q\", \"ReadI32\", p, trans, err, int32Values)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadI32\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadI32\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range int32Values {\n\t\tvalue, err := p.ReadI32()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading int32 at index %d: %q\", \"ReadI32\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %d != %d\", \"ReadI32\", p, trans, v, value)\n\t\t}\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadI32\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteI32(t testing.TB, p Protocol, trans Transport) {\n\tWriteI32(t, p, trans)\n\tReadI32(t, p, trans)\n}\n\nfunc WriteI64(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I64)\n\tthelen := len(int64Values)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range int64Values {\n\t\tp.WriteI64(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n}\n\nfunc ReadI64(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(I64)\n\tthelen := len(int64Values)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %q\", \"ReadI64\", p, trans, err, int64Values)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadI64\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadI64\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range int64Values {\n\t\tvalue, err := p.ReadI64()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading int64 at index %d: %q\", \"ReadI64\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %q != %q\", \"ReadI64\", p, trans, v, value)\n\t\t}\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadI64\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteI64(t testing.TB, p Protocol, trans Transport) {\n\tWriteI64(t, p, trans)\n\tReadI64(t, p, trans)\n}\n\nfunc WriteDouble(t testing.TB, p Protocol, trans Transport) {\n\tdoubleValues = []float64{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float64(), NEGATIVE_INFINITY.Float64(), NAN.Float64()}\n\tthetype := Type(DOUBLE)\n\tthelen := len(doubleValues)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range doubleValues {\n\t\tp.WriteDouble(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n\n}\n\nfunc ReadDouble(t testing.TB, p Protocol, trans Transport) {\n\tdoubleValues = []float64{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float64(), NEGATIVE_INFINITY.Float64(), NAN.Float64()}\n\tthetype := Type(DOUBLE)\n\tthelen := len(doubleValues)\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %v\", \"ReadDouble\", p, trans, err, doubleValues)\n\t}\n\tif thetype != thetype2 {\n\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadDouble\", p, trans, thetype, thetype2)\n\t}\n\tif thelen != thelen2 {\n\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadDouble\", p, trans, thelen, thelen2)\n\t}\n\tfor k, v := range doubleValues {\n\t\tvalue, err := p.ReadDouble()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading double at index %d: %f\", \"ReadDouble\", p, trans, err, k, v)\n\t\t}\n\t\tif math.IsNaN(v) {\n\t\t\tif !math.IsNaN(value) {\n\t\t\t\tt.Fatalf(\"%s: %T %T math.IsNaN(%f) != math.IsNaN(%f)\", \"ReadDouble\", p, trans, v, value)\n\t\t\t}\n\t\t} else if v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %f != %f\", \"ReadDouble\", p, trans, v, value)\n\t\t}\n\t}\n\terr = p.ReadListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadDouble\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteDouble(t testing.TB, p Protocol, trans Transport) {\n\tWriteDouble(t, p, trans)\n\tReadDouble(t, p, trans)\n}\n\nfunc WriteFloat(t testing.TB, p Protocol, trans Transport) {\n\tfloatValues = []float32{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float32(), NEGATIVE_INFINITY.Float32(), NAN.Float32()}\n\n\tthetype := Type(FLOAT)\n\tthelen := len(floatValues)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range floatValues {\n\t\tp.WriteFloat(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n\n}\n\nfunc ReadFloat(t testing.TB, p Protocol, trans Transport) {\n\tfloatValues = []float32{459.3, 0.0, -1.0, 1.0, 0.5, 0.3333, 3.14159, 1.537e-38, 1.673e25, 6.02214179e23, -6.02214179e23, INFINITY.Float32(), NEGATIVE_INFINITY.Float32(), NAN.Float32()}\n\n\tthetype := Type(FLOAT)\n\tthelen := len(floatValues)\n\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %v\", \"ReadFloat\", p, trans, err, floatValues)\n\t}\n\tif thetype != thetype2 {\n\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadFloat\", p, trans, thetype, thetype2)\n\t}\n\tif thelen != thelen2 {\n\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadFloat\", p, trans, thelen, thelen2)\n\t}\n\tfor k, v := range floatValues {\n\t\tvalue, err := p.ReadFloat()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading double at index %d: %f\", \"ReadFloat\", p, trans, err, k, v)\n\t\t}\n\t\tif math.IsNaN(float64(v)) {\n\t\t\tif !math.IsNaN(float64(value)) {\n\t\t\t\tt.Fatalf(\"%s: %T %T math.IsNaN(%f) != math.IsNaN(%f)\", \"ReadFloat\", p, trans, v, value)\n\t\t\t}\n\t\t} else if v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %f != %f\", \"ReadFloat\", p, trans, v, value)\n\t\t}\n\t}\n\terr = p.ReadListEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadFloat\", p, trans, err)\n\t}\n\n}\n\nfunc ReadWriteFloat(t testing.TB, p Protocol, trans Transport) {\n\tWriteFloat(t, p, trans)\n\tReadFloat(t, p, trans)\n}\n\nfunc WriteString(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(STRING)\n\tthelen := len(stringValues)\n\tp.WriteListBegin(thetype, thelen)\n\tfor _, v := range stringValues {\n\t\tp.WriteString(v)\n\t}\n\tp.WriteListEnd()\n\tp.Flush()\n}\n\nfunc ReadString(t testing.TB, p Protocol, trans Transport) {\n\tthetype := Type(STRING)\n\tthelen := len(stringValues)\n\n\tthetype2, thelen2, err := p.ReadListBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T %q Error reading list: %q\", \"ReadString\", p, trans, err, stringValues)\n\t}\n\t_, ok := p.(*SimpleJSONProtocol)\n\tif !ok {\n\t\tif thetype != thetype2 {\n\t\t\tt.Fatalf(\"%s: %T %T type %s != type %s\", \"ReadString\", p, trans, thetype, thetype2)\n\t\t}\n\t\tif thelen != thelen2 {\n\t\t\tt.Fatalf(\"%s: %T %T len %d != len %d\", \"ReadString\", p, trans, thelen, thelen2)\n\t\t}\n\t}\n\tfor k, v := range stringValues {\n\t\tvalue, err := p.ReadString()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %T %T %q Error reading string at index %d: %q\", \"ReadString\", p, trans, err, k, v)\n\t\t}\n\t\tif v != value {\n\t\t\tt.Fatalf(\"%s: %T %T %s != %s\", \"ReadString\", p, trans, v, value)\n\t\t}\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read list end: %q\", \"ReadString\", p, trans, err)\n\t}\n}\n\nfunc ReadWriteString(t testing.TB, p Protocol, trans Transport) {\n\tWriteString(t, p, trans)\n\tReadString(t, p, trans)\n}\n\nfunc WriteBinary(t testing.TB, p Protocol, trans Transport) {\n\tv := protocol_bdata\n\tp.WriteBinary(v)\n\tp.Flush()\n}\n\nfunc ReadBinary(t testing.TB, p Protocol, trans Transport) {\n\tv := protocol_bdata\n\tvalue, err := p.ReadBinary()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read binary: %s\", \"ReadBinary\", p, trans, err.Error())\n\t}\n\tif len(v) != len(value) {\n\t\tt.Fatalf(\"%s: %T %T len(v) != len(value)... %d != %d\", \"ReadBinary\", p, trans, len(v), len(value))\n\t} else {\n\t\tfor i := 0; i < len(v); i++ {\n\t\t\tif v[i] != value[i] {\n\t\t\t\tt.Fatalf(\"%s: %T %T %s != %s\", \"ReadBinary\", p, trans, v, value)\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nfunc ReadWriteBinary(t testing.TB, p Protocol, trans Transport) {\n\tWriteBinary(t, p, trans)\n\tReadBinary(t, p, trans)\n}\n\nfunc WriteStruct(t testing.TB, p Protocol, trans Transport) {\n\tv := structTestData\n\tp.WriteStructBegin(v.name)\n\tp.WriteFieldBegin(v.fields[0].name, v.fields[0].typ, v.fields[0].id)\n\terr := p.WriteBool(v.fields[0].value.(bool))\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read bool: %s\", \"WriteStruct\", p, trans, err.Error())\n\t}\n\tp.WriteFieldEnd()\n\tp.WriteFieldBegin(v.fields[1].name, v.fields[1].typ, v.fields[1].id)\n\terr = p.WriteString(v.fields[1].value.(string))\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read string: %s\", \"WriteStruct\", p, trans, err.Error())\n\t}\n\tp.WriteFieldEnd()\n\tp.WriteStructEnd()\n\terr = p.Flush()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to flush: %s\", \"WriteStruct\", p, trans, err.Error())\n\t}\n}\n\nfunc ReadStruct(t testing.TB, p Protocol, trans Transport) {\n\tv := structTestData\n\t_, err := p.ReadStructBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read struct begin: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\t_, typeID, id, err := p.ReadFieldBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read field begin: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\tif v.fields[0].typ != typeID {\n\t\tt.Fatalf(\"%s: %T %T type (%d) != (%d)\", \"ReadStruct\", p, trans, v.fields[0].typ, typeID)\n\t}\n\tif v.fields[0].id != id {\n\t\tt.Fatalf(\"%s: %T %T id (%d) != (%d)\", \"ReadStruct\", p, trans, v.fields[0].id, id)\n\t}\n\n\tval, err := p.ReadBool()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read bool: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\tif v.fields[0].value != val {\n\t\tt.Fatalf(\"%s: %T %T value (%v) != (%v)\", \"ReadStruct\", p, trans, v.fields[0].value, val)\n\t}\n\n\terr = p.ReadFieldEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read field end: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\n\t_, typeID, id, err = p.ReadFieldBegin()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read field begin: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\tif v.fields[1].typ != typeID {\n\t\tt.Fatalf(\"%s: %T %T type (%d) != (%d)\", \"ReadStruct\", p, trans, v.fields[1].typ, typeID)\n\t}\n\tif v.fields[1].id != id {\n\t\tt.Fatalf(\"%s: %T %T id (%d) != (%d)\", \"ReadStruct\", p, trans, v.fields[1].id, id)\n\t}\n\n\tstrVal, err := p.ReadString()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read string: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\tif v.fields[1].value != strVal {\n\t\tt.Fatalf(\"%s: %T value %T (%s) != (%s)\", \"ReadStruct\", p, trans, v.fields[1].value, strVal)\n\t}\n\n\terr = p.ReadFieldEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read field end: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n\n\terr = p.ReadStructEnd()\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %T %T Unable to read struct end: %s\", \"ReadStruct\", p, trans, err.Error())\n\t}\n}\n\nfunc ReadWriteStruct(t testing.TB, p Protocol, trans Transport) {\n\tWriteStruct(t, p, trans)\n\tReadStruct(t, p, trans)\n}\n"], "filenames": ["thrift/lib/go/thrift/binary_protocol.go", "thrift/lib/go/thrift/binary_protocol_test.go", "thrift/lib/go/thrift/compact_protocol.go", "thrift/lib/go/thrift/compact_protocol_test.go", "thrift/lib/go/thrift/http_client.go", "thrift/lib/go/thrift/protocol_test.go"], "buggy_code_start_loc": [331, 19, 415, 20, 22, 20], "buggy_code_end_loc": [491, 47, 629, 56, 254, 246], "fixing_code_start_loc": [332, 20, 414, 21, 21, 19], "fixing_code_end_loc": [503, 99, 637, 119, 247, 240], "type": "CWE-770", "message": "Golang Facebook Thrift servers would not error upon receiving messages declaring containers of sizes larger than the payload. As a result, malicious clients could send short messages which would result in a large memory allocation, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2020.03.16.00.", "other": {"cve": {"id": "CVE-2019-11939", "sourceIdentifier": "cve-assign@fb.com", "published": "2020-03-18T01:15:11.660", "lastModified": "2020-03-20T17:15:15.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Golang Facebook Thrift servers would not error upon receiving messages declaring containers of sizes larger than the payload. As a result, malicious clients could send short messages which would result in a large memory allocation, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2020.03.16.00."}, {"lang": "es", "value": "Los servidores de Golang Facebook Thrift, no se equivocar\u00edan tras recibir mensajes declarando contenedores de tama\u00f1os m\u00e1s grandes que la carga \u00fatil. Como resultado, unos clientes maliciosos podr\u00edan enviar mensajes cortos que resultar\u00eda en una asignaci\u00f3n de memoria considerable, conllevando potencialmente a una denegaci\u00f3n de servicio. Este problema afecta a Facebook Thrift versiones anteriores a v2020.03.16.00."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:thrift:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020.03.16.00", "matchCriteriaId": "8F515B67-2776-4C97-BBC3-47DEAEC6ACDC"}]}]}], "references": [{"url": "https://github.com/facebook/fbthrift/commit/483ed864d69f307e9e3b9dadec048216100c0757", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2019-11939", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/fbthrift/commit/483ed864d69f307e9e3b9dadec048216100c0757"}}