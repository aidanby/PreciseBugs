{"buggy_code": ["<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Backend\\Authentication;\n\nuse Doctrine\\DBAL\\Platforms\\MySQLPlatform;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\UriInterface;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\nuse Symfony\\Component\\Mime\\Address;\nuse TYPO3\\CMS\\Backend\\Routing\\UriBuilder;\nuse TYPO3\\CMS\\Core\\Context\\Context;\nuse TYPO3\\CMS\\Core\\Crypto\\PasswordHashing\\PasswordHashFactory;\nuse TYPO3\\CMS\\Core\\Crypto\\PasswordHashing\\PasswordHashInterface;\nuse TYPO3\\CMS\\Core\\Crypto\\Random;\nuse TYPO3\\CMS\\Core\\Database\\ConnectionPool;\nuse TYPO3\\CMS\\Core\\Database\\Query\\QueryBuilder;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\DeletedRestriction;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\EndTimeRestriction;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\HiddenRestriction;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\RootLevelRestriction;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\StartTimeRestriction;\nuse TYPO3\\CMS\\Core\\Http\\NormalizedParams;\nuse TYPO3\\CMS\\Core\\Mail\\FluidEmail;\nuse TYPO3\\CMS\\Core\\Mail\\Mailer;\nuse TYPO3\\CMS\\Core\\SysLog\\Action\\Login as SystemLogLoginAction;\nuse TYPO3\\CMS\\Core\\SysLog\\Error as SystemLogErrorClassification;\nuse TYPO3\\CMS\\Core\\SysLog\\Type as SystemLogType;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\n\n/**\n * This class is responsible for\n * - find the right user, sending out a reset email.\n * - create a token for creating the link (not exposed outside of this class)\n * - validate a hashed token\n * - send out an email to initiate the password reset\n * - update a password for a backend user if all parameters match\n *\n * @internal this is a concrete implementation for User/Password login and not part of public TYPO3 Core API.\n */\nclass PasswordReset implements LoggerAwareInterface\n{\n    use LoggerAwareTrait;\n\n    protected const TOKEN_VALID_UNTIL = '+2 hours';\n    protected const MAXIMUM_RESET_ATTEMPTS = 3;\n    protected const MAXIMUM_RESET_ATTEMPTS_SINCE = '-30 minutes';\n\n    /**\n     * Check if there are at least one in the system that contains a non-empty password AND an email address set.\n     */\n    public function isEnabled(): bool\n    {\n        // Option not explicitly enabled\n        if (!($GLOBALS['TYPO3_CONF_VARS']['BE']['passwordReset'] ?? false)) {\n            return false;\n        }\n        $queryBuilder = $this->getPreparedQueryBuilder();\n        $statement = $queryBuilder\n            ->select('uid')\n            ->from('be_users')\n            ->setMaxResults(1)\n            ->executeQuery();\n        return (int)$statement->fetchOne() > 0;\n    }\n\n    /**\n     * Check if a specific backend user can be used to trigger an email reset for (email + password set)\n     *\n     * @param int $userId\n     * @return bool\n     */\n    public function isEnabledForUser(int $userId): bool\n    {\n        $queryBuilder = $this->getPreparedQueryBuilder();\n        $statement = $queryBuilder\n            ->select('uid')\n            ->from('be_users')\n            ->andWhere(\n                $queryBuilder->expr()->eq('uid', $queryBuilder->createNamedParameter($userId, \\PDO::PARAM_INT))\n            )\n            ->setMaxResults(1)\n            ->executeQuery();\n        return $statement->fetchOne() > 0;\n    }\n\n    /**\n     * Determine the right user and send out an email. If multiple users are found with the same email address\n     * an alternative email is sent.\n     *\n     * If no user is found, this is logged to the system (but not to sys_log).\n     *\n     * The method intentionally does not return anything to avoid any information disclosure or exposure.\n     *\n     * @param ServerRequestInterface $request\n     * @param Context $context\n     * @param string $emailAddress\n     */\n    public function initiateReset(ServerRequestInterface $request, Context $context, string $emailAddress): void\n    {\n        if (!GeneralUtility::validEmail($emailAddress)) {\n            return;\n        }\n        if ($this->hasExceededMaximumAttemptsForReset($context, $emailAddress)) {\n            $this->logger->alert('Password reset requested for email {email} but was requested too many times.', ['email' => $emailAddress]);\n            return;\n        }\n        $queryBuilder = $this->getPreparedQueryBuilder();\n        $users = $queryBuilder\n            ->select('uid', 'email', 'username', 'realName', 'lang')\n            ->from('be_users')\n            ->andWhere(\n                $queryBuilder->expr()->eq('email', $queryBuilder->createNamedParameter($emailAddress))\n            )\n            ->executeQuery()\n            ->fetchAllAssociative();\n        if (!is_array($users) || count($users) === 0) {\n            // No user found, do nothing, also no log to sys_log in order avoid log flooding\n            $this->logger->warning('Password reset requested for email but no valid users');\n        } elseif (count($users) > 1) {\n            // More than one user with the same email address found, send out the email that one cannot send out a reset link\n            $this->sendAmbiguousEmail($request, $context, $emailAddress);\n        } else {\n            $user = reset($users);\n            $this->sendResetEmail($request, $context, (array)$user, $emailAddress);\n        }\n    }\n\n    /**\n     * Send out an email to a given email address and note that a reset was triggered but email was used multiple times.\n     * Used when the database returned multiple users.\n     *\n     * @param ServerRequestInterface $request\n     * @param Context $context\n     * @param string $emailAddress\n     */\n    protected function sendAmbiguousEmail(ServerRequestInterface $request, Context $context, string $emailAddress): void\n    {\n        $emailObject = GeneralUtility::makeInstance(FluidEmail::class);\n        $emailObject\n            ->to(new Address($emailAddress))\n            ->setRequest($request)\n            ->assign('email', $emailAddress)\n            ->setTemplate('PasswordReset/AmbiguousResetRequested');\n\n        GeneralUtility::makeInstance(Mailer::class)->send($emailObject);\n        $this->logger->warning('Password reset sent to email address {email} but multiple accounts found', ['email' => $emailAddress]);\n        $this->log(\n            'Sent password reset email to email address %s but with multiple accounts attached.',\n            SystemLogLoginAction::PASSWORD_RESET_REQUEST,\n            SystemLogErrorClassification::WARNING,\n            0,\n            [\n                'email' => $emailAddress,\n            ],\n            NormalizedParams::createFromRequest($request)->getRemoteAddress(),\n            $context\n        );\n    }\n\n    /**\n     * Send out an email to a user that does have an email address added to his account, containing a reset link.\n     *\n     * @param ServerRequestInterface $request\n     * @param Context $context\n     * @param array $user\n     * @param string $emailAddress\n     */\n    protected function sendResetEmail(ServerRequestInterface $request, Context $context, array $user, string $emailAddress): void\n    {\n        $resetLink = $this->generateResetLinkForUser($context, (int)$user['uid'], (string)$user['email']);\n        $emailObject = GeneralUtility::makeInstance(FluidEmail::class);\n        $emailObject\n            ->to(new Address((string)$user['email'], $user['realName']))\n            ->setRequest($request)\n            ->assign('name', $user['realName'])\n            ->assign('email', $user['email'])\n            ->assign('language', $user['lang'] ?: 'default')\n            ->assign('resetLink', $resetLink)\n            ->setTemplate('PasswordReset/ResetRequested');\n\n        GeneralUtility::makeInstance(Mailer::class)->send($emailObject);\n        $this->logger->info('Sent password reset email to email address {email} for user {username}', [\n            'email' => $emailAddress,\n            'username' => $user['username'],\n        ]);\n        $this->log(\n            'Sent password reset email to email address %s',\n            SystemLogLoginAction::PASSWORD_RESET_REQUEST,\n            SystemLogErrorClassification::SECURITY_NOTICE,\n            (int)$user['uid'],\n            [\n                'email' => $user['email'],\n            ],\n            NormalizedParams::createFromRequest($request)->getRemoteAddress(),\n            $context\n        );\n    }\n\n    /**\n     * Creates a token, stores it in the database, and then creates an absolute URL for resetting the password.\n     * This is all in one method so it is not exposed from the outside.\n     *\n     * This function requires:\n     * a) the user is allowed to do a password reset (no check is done anymore)\n     * b) a valid email address.\n     *\n     * @param Context $context\n     * @param int $userId the backend user uid\n     * @param string $emailAddress is part of the hash to ensure that the email address does not get reset.\n     * @return UriInterface\n     */\n    protected function generateResetLinkForUser(Context $context, int $userId, string $emailAddress): UriInterface\n    {\n        $token = GeneralUtility::makeInstance(Random::class)->generateRandomHexString(96);\n        $currentTime = $context->getAspect('date')->getDateTime();\n        $expiresOn = $currentTime->modify(self::TOKEN_VALID_UNTIL);\n        // Create a hash (\"one time password\") out of the token including the timestamp of the expiration date\n        $hash = GeneralUtility::hmac($token . '|' . (string)$expiresOn->getTimestamp() . '|' . $emailAddress . '|' . (string)$userId, 'password-reset');\n\n        // Set the token in the database, which is hashed\n        GeneralUtility::makeInstance(ConnectionPool::class)\n            ->getConnectionForTable('be_users')\n            ->update('be_users', ['password_reset_token' => $this->getHasher()->getHashedPassword($hash)], ['uid' => $userId]);\n\n        return GeneralUtility::makeInstance(UriBuilder::class)->buildUriFromRoute(\n            'password_reset_validate',\n            [\n                // \"token\"\n                't' => $token,\n                // \"expiration date\"\n                'e' => $expiresOn->getTimestamp(),\n                // \"identity\"\n                'i' => hash('sha1', $emailAddress . (string)$userId),\n            ],\n            UriBuilder::ABSOLUTE_URL\n        );\n    }\n\n    /**\n     * Validates all query parameters / GET parameters of the given request against the token.\n     *\n     * @param ServerRequestInterface $request\n     * @return bool\n     */\n    public function isValidResetTokenFromRequest(ServerRequestInterface $request): bool\n    {\n        $user = $this->findValidUserForToken(\n            (string)($request->getQueryParams()['t'] ?? ''),\n            (string)($request->getQueryParams()['i'] ?? ''),\n            (int)($request->getQueryParams()['e'] ?? 0)\n        );\n        return $user !== null;\n    }\n\n    /**\n     * Fetch the user record from the database if the token is valid, and has matched all criteria\n     *\n     * @param string $token\n     * @param string $identity\n     * @param int $expirationTimestamp\n     * @return array|null the BE User database record\n     */\n    protected function findValidUserForToken(string $token, string $identity, int $expirationTimestamp): ?array\n    {\n        $user = null;\n        // Find the token in the database\n        $queryBuilder = $this->getPreparedQueryBuilder();\n\n        $queryBuilder\n            ->select('uid', 'email', 'password_reset_token')\n            ->from('be_users');\n        if ($queryBuilder->getConnection()->getDatabasePlatform() instanceof MySQLPlatform) {\n            $queryBuilder->andWhere(\n                $queryBuilder->expr()->comparison('SHA1(CONCAT(' . $queryBuilder->quoteIdentifier('email') . ', ' . $queryBuilder->quoteIdentifier('uid') . '))', $queryBuilder->expr()::EQ, $queryBuilder->createNamedParameter($identity))\n            );\n            $user = $queryBuilder->executeQuery()->fetchAssociative();\n        } else {\n            // no native SHA1/ CONCAT functionality, has to be done in PHP\n            $stmt = $queryBuilder->executeQuery();\n            while ($row = $stmt->fetchAssociative()) {\n                if (hash_equals(hash('sha1', $row['email'] . (string)$row['uid']), $identity)) {\n                    $user = $row;\n                    break;\n                }\n            }\n        }\n\n        if (!is_array($user) || empty($user)) {\n            return null;\n        }\n\n        // Validate hash by rebuilding the hash from the parameters and the URL and see if this matches against the stored password_reset_token\n        $hash = GeneralUtility::hmac($token . '|' . (string)$expirationTimestamp . '|' . $user['email'] . '|' . (string)$user['uid'], 'password-reset');\n        if (!$this->getHasher()->checkPassword($hash, $user['password_reset_token'] ?? '')) {\n            return null;\n        }\n        return $user;\n    }\n\n    /**\n     * Update the password in the database if the password matches and the token is valid.\n     *\n     * @param ServerRequestInterface $request\n     * @param Context $context current context\n     * @return bool whether the password was reset or not\n     */\n    public function resetPassword(ServerRequestInterface $request, Context $context): bool\n    {\n        $expirationTimestamp = (int)($request->getQueryParams()['e'] ?? '');\n        $identityHash = (string)($request->getQueryParams()['i'] ?? '');\n        $token = (string)($request->getQueryParams()['t'] ?? '');\n        $newPassword = (string)($request->getParsedBody()['password'] ?? '');\n        $newPasswordRepeat = (string)($request->getParsedBody()['passwordrepeat'] ?? '');\n        if (strlen($newPassword) < 8 || $newPassword !== $newPasswordRepeat) {\n            $this->logger->debug('Password reset not possible due to weak password');\n            return false;\n        }\n        $user = $this->findValidUserForToken($token, $identityHash, $expirationTimestamp);\n        if ($user === null) {\n            $this->logger->warning('Password reset not possible. Valid user for token not found.');\n            return false;\n        }\n        $userId = (int)$user['uid'];\n\n        GeneralUtility::makeInstance(ConnectionPool::class)\n            ->getConnectionForTable('be_users')\n            ->update('be_users', ['password_reset_token' => '', 'password' => $this->getHasher()->getHashedPassword($newPassword)], ['uid' => $userId]);\n\n        $this->logger->info('Password reset successful for user {user_id)', ['user_id' => $userId]);\n        $this->log(\n            'Password reset successful for user %s',\n            SystemLogLoginAction::PASSWORD_RESET_ACCOMPLISHED,\n            SystemLogErrorClassification::SECURITY_NOTICE,\n            $userId,\n            [\n                'email' => $user['email'],\n                'user' => $userId,\n            ],\n            NormalizedParams::createFromRequest($request)->getRemoteAddress(),\n            $context\n        );\n        return true;\n    }\n\n    /**\n     * The querybuilder for finding the right user - and adds some restrictions:\n     * - No CLI users\n     * - No Admin users (with option)\n     * - No hidden/deleted users\n     * - Password must be set\n     * - Username must be set\n     * - Email address must be set\n     *\n     * @return QueryBuilder\n     */\n    protected function getPreparedQueryBuilder(): QueryBuilder\n    {\n        $queryBuilder = GeneralUtility::makeInstance(ConnectionPool::class)->getQueryBuilderForTable('be_users');\n        $queryBuilder->getRestrictions()\n            ->removeAll()\n            ->add(GeneralUtility::makeInstance(RootLevelRestriction::class))\n            ->add(GeneralUtility::makeInstance(DeletedRestriction::class))\n            ->add(GeneralUtility::makeInstance(StartTimeRestriction::class))\n            ->add(GeneralUtility::makeInstance(EndTimeRestriction::class))\n            ->add(GeneralUtility::makeInstance(HiddenRestriction::class));\n        $queryBuilder->where(\n            $queryBuilder->expr()->neq('username', $queryBuilder->createNamedParameter('')),\n            $queryBuilder->expr()->neq('username', $queryBuilder->createNamedParameter('_cli_')),\n            $queryBuilder->expr()->neq('password', $queryBuilder->createNamedParameter('')),\n            $queryBuilder->expr()->neq('email', $queryBuilder->createNamedParameter(''))\n        );\n        if (!($GLOBALS['TYPO3_CONF_VARS']['BE']['passwordResetForAdmins'] ?? false)) {\n            $queryBuilder->andWhere(\n                $queryBuilder->expr()->eq('admin', $queryBuilder->createNamedParameter(0, \\PDO::PARAM_INT))\n            );\n        }\n        return $queryBuilder;\n    }\n\n    protected function getHasher(): PasswordHashInterface\n    {\n        return GeneralUtility::makeInstance(PasswordHashFactory::class)->getDefaultHashInstance('BE');\n    }\n\n    /**\n     * Adds an entry to \"sys_log\", also used to track the maximum allowed attempts.\n     *\n     * @param string $message the information / message in english\n     * @param int $action see SystemLogLoginAction\n     * @param int $error see SystemLogErrorClassification\n     * @param int $userId\n     * @param array $data additional information, used for the message\n     * @param string $ipAddress\n     * @param Context $context\n     */\n    protected function log(string $message, int $action, int $error, int $userId, array $data, $ipAddress, Context $context): void\n    {\n        $fields = [\n            'userid' => $userId,\n            'type' => SystemLogType::LOGIN,\n            'channel' => SystemLogType::toChannel(SystemLogType::LOGIN),\n            'level' => SystemLogType::toLevel(SystemLogType::LOGIN),\n            'action' => $action,\n            'error' => $error,\n            'details_nr' => 1,\n            'details' => $message,\n            'log_data' => json_encode($data),\n            'tablename' => 'be_users',\n            'recuid' => $userId,\n            'IP' => (string)$ipAddress,\n            'tstamp' => $context->getAspect('date')->get('timestamp'),\n            'event_pid' => 0,\n            'NEWid' => '',\n            'workspace' => 0,\n        ];\n\n        $connection = GeneralUtility::makeInstance(ConnectionPool::class)->getConnectionForTable('sys_log');\n        $connection->insert(\n            'sys_log',\n            $fields,\n            [\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_STR,\n            ]\n        );\n    }\n\n    /**\n     * Checks if an email reset link has been requested more than 3 times in the last 30mins.\n     * If a password was successfully reset more than three times in 30 minutes, it would still fail.\n     *\n     * @param Context $context\n     * @param string $email\n     * @return bool\n     */\n    protected function hasExceededMaximumAttemptsForReset(Context $context, string $email): bool\n    {\n        $now = $context->getAspect('date')->getDateTime();\n        $numberOfAttempts = $this->getNumberOfInitiatedResetsForEmail($now->modify(self::MAXIMUM_RESET_ATTEMPTS_SINCE), $email);\n        return $numberOfAttempts > self::MAXIMUM_RESET_ATTEMPTS;\n    }\n\n    /**\n     * SQL query to find the amount of initiated resets from a given time.\n     *\n     * @param \\DateTimeInterface $since\n     * @param string $email\n     * @return int\n     */\n    protected function getNumberOfInitiatedResetsForEmail(\\DateTimeInterface $since, string $email): int\n    {\n        $queryBuilder = GeneralUtility::makeInstance(ConnectionPool::class)->getQueryBuilderForTable('sys_log');\n        return (int)$queryBuilder\n            ->count('uid')\n            ->from('sys_log')\n            ->where(\n                $queryBuilder->expr()->eq('type', $queryBuilder->createNamedParameter(SystemLogType::LOGIN)),\n                $queryBuilder->expr()->eq('action', $queryBuilder->createNamedParameter(SystemLogLoginAction::PASSWORD_RESET_REQUEST)),\n                $queryBuilder->expr()->eq('log_data', $queryBuilder->createNamedParameter(json_encode(['email' => $email]))),\n                $queryBuilder->expr()->gte('tstamp', $queryBuilder->createNamedParameter($since->getTimestamp(), \\PDO::PARAM_INT))\n            )\n            ->executeQuery()\n            ->fetchOne();\n    }\n}\n"], "fixing_code": ["<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Backend\\Authentication;\n\nuse Doctrine\\DBAL\\Platforms\\MySQLPlatform;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\UriInterface;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\nuse Symfony\\Component\\Mime\\Address;\nuse TYPO3\\CMS\\Backend\\Routing\\UriBuilder;\nuse TYPO3\\CMS\\Core\\Context\\Context;\nuse TYPO3\\CMS\\Core\\Crypto\\PasswordHashing\\PasswordHashFactory;\nuse TYPO3\\CMS\\Core\\Crypto\\PasswordHashing\\PasswordHashInterface;\nuse TYPO3\\CMS\\Core\\Crypto\\Random;\nuse TYPO3\\CMS\\Core\\Database\\ConnectionPool;\nuse TYPO3\\CMS\\Core\\Database\\Query\\QueryBuilder;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\DeletedRestriction;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\EndTimeRestriction;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\HiddenRestriction;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\RootLevelRestriction;\nuse TYPO3\\CMS\\Core\\Database\\Query\\Restriction\\StartTimeRestriction;\nuse TYPO3\\CMS\\Core\\Http\\NormalizedParams;\nuse TYPO3\\CMS\\Core\\Mail\\FluidEmail;\nuse TYPO3\\CMS\\Core\\Mail\\Mailer;\nuse TYPO3\\CMS\\Core\\SysLog\\Action\\Login as SystemLogLoginAction;\nuse TYPO3\\CMS\\Core\\SysLog\\Error as SystemLogErrorClassification;\nuse TYPO3\\CMS\\Core\\SysLog\\Type as SystemLogType;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\n\n/**\n * This class is responsible for\n * - find the right user, sending out a reset email.\n * - create a token for creating the link (not exposed outside of this class)\n * - validate a hashed token\n * - send out an email to initiate the password reset\n * - update a password for a backend user if all parameters match\n *\n * @internal this is a concrete implementation for User/Password login and not part of public TYPO3 Core API.\n */\nclass PasswordReset implements LoggerAwareInterface\n{\n    use LoggerAwareTrait;\n\n    protected const TOKEN_VALID_UNTIL = '+2 hours';\n    protected const MAXIMUM_RESET_ATTEMPTS = 3;\n    protected const MAXIMUM_RESET_ATTEMPTS_SINCE = '-30 minutes';\n\n    /**\n     * Check if there are at least one in the system that contains a non-empty password AND an email address set.\n     */\n    public function isEnabled(): bool\n    {\n        // Option not explicitly enabled\n        if (!($GLOBALS['TYPO3_CONF_VARS']['BE']['passwordReset'] ?? false)) {\n            return false;\n        }\n        $queryBuilder = $this->getPreparedQueryBuilder();\n        $statement = $queryBuilder\n            ->select('uid')\n            ->from('be_users')\n            ->setMaxResults(1)\n            ->executeQuery();\n        return (int)$statement->fetchOne() > 0;\n    }\n\n    /**\n     * Check if a specific backend user can be used to trigger an email reset for (email + password set)\n     *\n     * @param int $userId\n     * @return bool\n     */\n    public function isEnabledForUser(int $userId): bool\n    {\n        $queryBuilder = $this->getPreparedQueryBuilder();\n        $statement = $queryBuilder\n            ->select('uid')\n            ->from('be_users')\n            ->andWhere(\n                $queryBuilder->expr()->eq('uid', $queryBuilder->createNamedParameter($userId, \\PDO::PARAM_INT))\n            )\n            ->setMaxResults(1)\n            ->executeQuery();\n        return $statement->fetchOne() > 0;\n    }\n\n    /**\n     * Determine the right user and send out an email. If multiple users are found with the same email address\n     * an alternative email is sent.\n     *\n     * If no user is found, this is logged to the system (but not to sys_log).\n     *\n     * The method intentionally does not return anything to avoid any information disclosure or exposure.\n     *\n     * @param ServerRequestInterface $request\n     * @param Context $context\n     * @param string $emailAddress\n     */\n    public function initiateReset(ServerRequestInterface $request, Context $context, string $emailAddress): void\n    {\n        if (!GeneralUtility::validEmail($emailAddress)) {\n            return;\n        }\n        if ($this->hasExceededMaximumAttemptsForReset($context, $emailAddress)) {\n            $this->logger->alert('Password reset requested for email {email} but was requested too many times.', ['email' => $emailAddress]);\n            return;\n        }\n        $queryBuilder = $this->getPreparedQueryBuilder();\n        $users = $queryBuilder\n            ->select('uid', 'email', 'username', 'realName', 'lang')\n            ->from('be_users')\n            ->andWhere(\n                $queryBuilder->expr()->eq('email', $queryBuilder->createNamedParameter($emailAddress))\n            )\n            ->executeQuery()\n            ->fetchAllAssociative();\n        if (!is_array($users) || count($users) === 0) {\n            // No user found, do nothing, also no log to sys_log in order avoid log flooding\n            $this->logger->warning('Password reset requested for email but no valid users');\n        } elseif (count($users) > 1) {\n            // More than one user with the same email address found, send out the email that one cannot send out a reset link\n            $this->sendAmbiguousEmail($request, $context, $emailAddress);\n        } else {\n            $user = reset($users);\n            $this->sendResetEmail($request, $context, (array)$user, $emailAddress);\n        }\n    }\n\n    /**\n     * Send out an email to a given email address and note that a reset was triggered but email was used multiple times.\n     * Used when the database returned multiple users.\n     *\n     * @param ServerRequestInterface $request\n     * @param Context $context\n     * @param string $emailAddress\n     */\n    protected function sendAmbiguousEmail(ServerRequestInterface $request, Context $context, string $emailAddress): void\n    {\n        $emailObject = GeneralUtility::makeInstance(FluidEmail::class);\n        $emailObject\n            ->to(new Address($emailAddress))\n            ->setRequest($request)\n            ->assign('email', $emailAddress)\n            ->setTemplate('PasswordReset/AmbiguousResetRequested');\n\n        GeneralUtility::makeInstance(Mailer::class)->send($emailObject);\n        $this->logger->warning('Password reset sent to email address {email} but multiple accounts found', ['email' => $emailAddress]);\n        $this->log(\n            'Sent password reset email to email address %s but with multiple accounts attached.',\n            SystemLogLoginAction::PASSWORD_RESET_REQUEST,\n            SystemLogErrorClassification::WARNING,\n            0,\n            [\n                'email' => $emailAddress,\n            ],\n            NormalizedParams::createFromRequest($request)->getRemoteAddress(),\n            $context\n        );\n    }\n\n    /**\n     * Send out an email to a user that does have an email address added to his account, containing a reset link.\n     *\n     * @param ServerRequestInterface $request\n     * @param Context $context\n     * @param array $user\n     * @param string $emailAddress\n     */\n    protected function sendResetEmail(ServerRequestInterface $request, Context $context, array $user, string $emailAddress): void\n    {\n        $resetLink = $this->generateResetLinkForUser($context, (int)$user['uid'], (string)$user['email']);\n        $emailObject = GeneralUtility::makeInstance(FluidEmail::class);\n        $emailObject\n            ->to(new Address((string)$user['email'], $user['realName']))\n            ->setRequest($request)\n            ->assign('name', $user['realName'])\n            ->assign('email', $user['email'])\n            ->assign('language', $user['lang'] ?: 'default')\n            ->assign('resetLink', $resetLink)\n            ->setTemplate('PasswordReset/ResetRequested');\n\n        GeneralUtility::makeInstance(Mailer::class)->send($emailObject);\n        $this->logger->info('Sent password reset email to email address {email} for user {username}', [\n            'email' => $emailAddress,\n            'username' => $user['username'],\n        ]);\n        $this->log(\n            'Sent password reset email to email address %s',\n            SystemLogLoginAction::PASSWORD_RESET_REQUEST,\n            SystemLogErrorClassification::SECURITY_NOTICE,\n            (int)$user['uid'],\n            [\n                'email' => $user['email'],\n            ],\n            NormalizedParams::createFromRequest($request)->getRemoteAddress(),\n            $context\n        );\n    }\n\n    /**\n     * Creates a token, stores it in the database, and then creates an absolute URL for resetting the password.\n     * This is all in one method so it is not exposed from the outside.\n     *\n     * This function requires:\n     * a) the user is allowed to do a password reset (no check is done anymore)\n     * b) a valid email address.\n     *\n     * @param Context $context\n     * @param int $userId the backend user uid\n     * @param string $emailAddress is part of the hash to ensure that the email address does not get reset.\n     * @return UriInterface\n     */\n    protected function generateResetLinkForUser(Context $context, int $userId, string $emailAddress): UriInterface\n    {\n        $token = GeneralUtility::makeInstance(Random::class)->generateRandomHexString(96);\n        $currentTime = $context->getAspect('date')->getDateTime();\n        $expiresOn = $currentTime->modify(self::TOKEN_VALID_UNTIL);\n        // Create a hash (\"one time password\") out of the token including the timestamp of the expiration date\n        $hash = GeneralUtility::hmac($token . '|' . (string)$expiresOn->getTimestamp() . '|' . $emailAddress . '|' . (string)$userId, 'password-reset');\n\n        // Set the token in the database, which is hashed\n        GeneralUtility::makeInstance(ConnectionPool::class)\n            ->getConnectionForTable('be_users')\n            ->update('be_users', ['password_reset_token' => $this->getHasher()->getHashedPassword($hash)], ['uid' => $userId]);\n\n        return GeneralUtility::makeInstance(UriBuilder::class)->buildUriFromRoute(\n            'password_reset_validate',\n            [\n                // \"token\"\n                't' => $token,\n                // \"expiration date\"\n                'e' => $expiresOn->getTimestamp(),\n                // \"identity\"\n                'i' => hash('sha1', $emailAddress . (string)$userId),\n            ],\n            UriBuilder::ABSOLUTE_URL\n        );\n    }\n\n    /**\n     * Validates all query parameters / GET parameters of the given request against the token.\n     *\n     * @param ServerRequestInterface $request\n     * @return bool\n     */\n    public function isValidResetTokenFromRequest(ServerRequestInterface $request): bool\n    {\n        $user = $this->findValidUserForToken(\n            (string)($request->getQueryParams()['t'] ?? ''),\n            (string)($request->getQueryParams()['i'] ?? ''),\n            (int)($request->getQueryParams()['e'] ?? 0)\n        );\n        return $user !== null;\n    }\n\n    /**\n     * Fetch the user record from the database if the token is valid, and has matched all criteria\n     *\n     * @param string $token\n     * @param string $identity\n     * @param int $expirationTimestamp\n     * @return array|null the BE User database record\n     */\n    protected function findValidUserForToken(string $token, string $identity, int $expirationTimestamp): ?array\n    {\n        // Early return if token expired\n        if ($expirationTimestamp < time()) {\n            return null;\n        }\n\n        $user = null;\n        // Find the token in the database\n        $queryBuilder = $this->getPreparedQueryBuilder();\n\n        $queryBuilder\n            ->select('uid', 'email', 'password_reset_token')\n            ->from('be_users');\n        if ($queryBuilder->getConnection()->getDatabasePlatform() instanceof MySQLPlatform) {\n            $queryBuilder->andWhere(\n                $queryBuilder->expr()->comparison('SHA1(CONCAT(' . $queryBuilder->quoteIdentifier('email') . ', ' . $queryBuilder->quoteIdentifier('uid') . '))', $queryBuilder->expr()::EQ, $queryBuilder->createNamedParameter($identity))\n            );\n            $user = $queryBuilder->executeQuery()->fetchAssociative();\n        } else {\n            // no native SHA1/ CONCAT functionality, has to be done in PHP\n            $stmt = $queryBuilder->executeQuery();\n            while ($row = $stmt->fetchAssociative()) {\n                if (hash_equals(hash('sha1', $row['email'] . (string)$row['uid']), $identity)) {\n                    $user = $row;\n                    break;\n                }\n            }\n        }\n\n        if (!is_array($user) || empty($user)) {\n            return null;\n        }\n\n        // Validate hash by rebuilding the hash from the parameters and the URL and see if this matches against the stored password_reset_token\n        $hash = GeneralUtility::hmac($token . '|' . (string)$expirationTimestamp . '|' . $user['email'] . '|' . (string)$user['uid'], 'password-reset');\n        if (!$this->getHasher()->checkPassword($hash, $user['password_reset_token'] ?? '')) {\n            return null;\n        }\n        return $user;\n    }\n\n    /**\n     * Update the password in the database if the password matches and the token is valid.\n     *\n     * @param ServerRequestInterface $request\n     * @param Context $context current context\n     * @return bool whether the password was reset or not\n     */\n    public function resetPassword(ServerRequestInterface $request, Context $context): bool\n    {\n        $expirationTimestamp = (int)($request->getQueryParams()['e'] ?? '');\n        $identityHash = (string)($request->getQueryParams()['i'] ?? '');\n        $token = (string)($request->getQueryParams()['t'] ?? '');\n        $newPassword = (string)($request->getParsedBody()['password'] ?? '');\n        $newPasswordRepeat = (string)($request->getParsedBody()['passwordrepeat'] ?? '');\n        if (strlen($newPassword) < 8 || $newPassword !== $newPasswordRepeat) {\n            $this->logger->debug('Password reset not possible due to weak password');\n            return false;\n        }\n        $user = $this->findValidUserForToken($token, $identityHash, $expirationTimestamp);\n        if ($user === null) {\n            $this->logger->warning('Password reset not possible. Valid user for token not found.');\n            return false;\n        }\n        $userId = (int)$user['uid'];\n\n        GeneralUtility::makeInstance(ConnectionPool::class)\n            ->getConnectionForTable('be_users')\n            ->update('be_users', ['password_reset_token' => '', 'password' => $this->getHasher()->getHashedPassword($newPassword)], ['uid' => $userId]);\n\n        $this->logger->info('Password reset successful for user {user_id)', ['user_id' => $userId]);\n        $this->log(\n            'Password reset successful for user %s',\n            SystemLogLoginAction::PASSWORD_RESET_ACCOMPLISHED,\n            SystemLogErrorClassification::SECURITY_NOTICE,\n            $userId,\n            [\n                'email' => $user['email'],\n                'user' => $userId,\n            ],\n            NormalizedParams::createFromRequest($request)->getRemoteAddress(),\n            $context\n        );\n        return true;\n    }\n\n    /**\n     * The querybuilder for finding the right user - and adds some restrictions:\n     * - No CLI users\n     * - No Admin users (with option)\n     * - No hidden/deleted users\n     * - Password must be set\n     * - Username must be set\n     * - Email address must be set\n     *\n     * @return QueryBuilder\n     */\n    protected function getPreparedQueryBuilder(): QueryBuilder\n    {\n        $queryBuilder = GeneralUtility::makeInstance(ConnectionPool::class)->getQueryBuilderForTable('be_users');\n        $queryBuilder->getRestrictions()\n            ->removeAll()\n            ->add(GeneralUtility::makeInstance(RootLevelRestriction::class))\n            ->add(GeneralUtility::makeInstance(DeletedRestriction::class))\n            ->add(GeneralUtility::makeInstance(StartTimeRestriction::class))\n            ->add(GeneralUtility::makeInstance(EndTimeRestriction::class))\n            ->add(GeneralUtility::makeInstance(HiddenRestriction::class));\n        $queryBuilder->where(\n            $queryBuilder->expr()->neq('username', $queryBuilder->createNamedParameter('')),\n            $queryBuilder->expr()->neq('username', $queryBuilder->createNamedParameter('_cli_')),\n            $queryBuilder->expr()->neq('password', $queryBuilder->createNamedParameter('')),\n            $queryBuilder->expr()->neq('email', $queryBuilder->createNamedParameter(''))\n        );\n        if (!($GLOBALS['TYPO3_CONF_VARS']['BE']['passwordResetForAdmins'] ?? false)) {\n            $queryBuilder->andWhere(\n                $queryBuilder->expr()->eq('admin', $queryBuilder->createNamedParameter(0, \\PDO::PARAM_INT))\n            );\n        }\n        return $queryBuilder;\n    }\n\n    protected function getHasher(): PasswordHashInterface\n    {\n        return GeneralUtility::makeInstance(PasswordHashFactory::class)->getDefaultHashInstance('BE');\n    }\n\n    /**\n     * Adds an entry to \"sys_log\", also used to track the maximum allowed attempts.\n     *\n     * @param string $message the information / message in english\n     * @param int $action see SystemLogLoginAction\n     * @param int $error see SystemLogErrorClassification\n     * @param int $userId\n     * @param array $data additional information, used for the message\n     * @param string $ipAddress\n     * @param Context $context\n     */\n    protected function log(string $message, int $action, int $error, int $userId, array $data, $ipAddress, Context $context): void\n    {\n        $fields = [\n            'userid' => $userId,\n            'type' => SystemLogType::LOGIN,\n            'channel' => SystemLogType::toChannel(SystemLogType::LOGIN),\n            'level' => SystemLogType::toLevel(SystemLogType::LOGIN),\n            'action' => $action,\n            'error' => $error,\n            'details_nr' => 1,\n            'details' => $message,\n            'log_data' => json_encode($data),\n            'tablename' => 'be_users',\n            'recuid' => $userId,\n            'IP' => (string)$ipAddress,\n            'tstamp' => $context->getAspect('date')->get('timestamp'),\n            'event_pid' => 0,\n            'NEWid' => '',\n            'workspace' => 0,\n        ];\n\n        $connection = GeneralUtility::makeInstance(ConnectionPool::class)->getConnectionForTable('sys_log');\n        $connection->insert(\n            'sys_log',\n            $fields,\n            [\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_INT,\n                \\PDO::PARAM_STR,\n                \\PDO::PARAM_STR,\n            ]\n        );\n    }\n\n    /**\n     * Checks if an email reset link has been requested more than 3 times in the last 30mins.\n     * If a password was successfully reset more than three times in 30 minutes, it would still fail.\n     *\n     * @param Context $context\n     * @param string $email\n     * @return bool\n     */\n    protected function hasExceededMaximumAttemptsForReset(Context $context, string $email): bool\n    {\n        $now = $context->getAspect('date')->getDateTime();\n        $numberOfAttempts = $this->getNumberOfInitiatedResetsForEmail($now->modify(self::MAXIMUM_RESET_ATTEMPTS_SINCE), $email);\n        return $numberOfAttempts > self::MAXIMUM_RESET_ATTEMPTS;\n    }\n\n    /**\n     * SQL query to find the amount of initiated resets from a given time.\n     *\n     * @param \\DateTimeInterface $since\n     * @param string $email\n     * @return int\n     */\n    protected function getNumberOfInitiatedResetsForEmail(\\DateTimeInterface $since, string $email): int\n    {\n        $queryBuilder = GeneralUtility::makeInstance(ConnectionPool::class)->getQueryBuilderForTable('sys_log');\n        return (int)$queryBuilder\n            ->count('uid')\n            ->from('sys_log')\n            ->where(\n                $queryBuilder->expr()->eq('type', $queryBuilder->createNamedParameter(SystemLogType::LOGIN)),\n                $queryBuilder->expr()->eq('action', $queryBuilder->createNamedParameter(SystemLogLoginAction::PASSWORD_RESET_REQUEST)),\n                $queryBuilder->expr()->eq('log_data', $queryBuilder->createNamedParameter(json_encode(['email' => $email]))),\n                $queryBuilder->expr()->gte('tstamp', $queryBuilder->createNamedParameter($since->getTimestamp(), \\PDO::PARAM_INT))\n            )\n            ->executeQuery()\n            ->fetchOne();\n    }\n}\n"], "filenames": ["typo3/sysext/backend/Classes/Authentication/PasswordReset.php"], "buggy_code_start_loc": [280], "buggy_code_end_loc": [280], "fixing_code_start_loc": [281], "fixing_code_end_loc": [286], "type": "CWE-287", "message": "TYPO3 is an open source PHP based web content management system released under the GNU GPL. It has been discovered that the expiration time of a password reset link for TYPO3 backend users has never been evaluated. As a result, a password reset link could be used to perform a password reset even if the default expiry time of two hours has been exceeded. Update to TYPO3 version 10.4.32 or 11.5.16 that fix the problem. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-36106", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-13T18:15:15.130", "lastModified": "2022-09-16T13:49:59.200", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TYPO3 is an open source PHP based web content management system released under the GNU GPL. It has been discovered that the expiration time of a password reset link for TYPO3 backend users has never been evaluated. As a result, a password reset link could be used to perform a password reset even if the default expiry time of two hours has been exceeded. Update to TYPO3 version 10.4.32 or 11.5.16 that fix the problem. There are no known workarounds for this issue."}, {"lang": "es", "value": "TYPO3 es un sistema de administraci\u00f3n de contenidos web de c\u00f3digo abierto basado en PHP y publicado bajo la licencia GNU GPL. Se ha detectado que nunca ha sido evaluado el tiempo de caducidad de un enlace de restablecimiento de contrase\u00f1a para usuarios del backend de TYPO3. Como resultado, un enlace de restablecimiento de contrase\u00f1a podr\u00eda ser usado para llevar a cabo un restablecimiento de contrase\u00f1a, incluso si el tiempo de caducidad por defecto de dos horas ha sido superado. Actualice a TYPO3 versiones 10.4.32 o 11.5.16 que corrigen el problema. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.0.0", "versionEndIncluding": "10.4.31", "matchCriteriaId": "B428B4CD-4699-4E84-9002-29442DCE5250"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0.0", "versionEndIncluding": "11.5.15", "matchCriteriaId": "CE54B85D-5F45-4346-A2E0-8204831AA225"}]}]}], "references": [{"url": "https://github.com/TYPO3/typo3/commit/56af2bd3a432156c30af9be71c9d6f7ef3a6159a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TYPO3/typo3/security/advisories/GHSA-5959-4x58-r8c2", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://typo3.org/security/advisory/typo3-core-sa-2022-008", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/TYPO3/typo3/commit/56af2bd3a432156c30af9be71c9d6f7ef3a6159a"}}