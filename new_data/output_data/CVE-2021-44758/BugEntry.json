{"buggy_code": ["/*\n * Copyright (c) 1997 - 2006 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * Portions Copyright (c) 2004 PADL Software Pty Ltd.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"spnego_locl.h\"\n\nstatic OM_uint32\nsend_reject (OM_uint32 *minor_status,\n\t     gss_buffer_t output_token)\n{\n    NegotiationToken nt;\n    size_t size;\n\n    nt.element = choice_NegotiationToken_negTokenResp;\n\n    ALLOC(nt.u.negTokenResp.negResult, 1);\n    if (nt.u.negTokenResp.negResult == NULL) {\n\t*minor_status = ENOMEM;\n\treturn GSS_S_FAILURE;\n    }\n    *(nt.u.negTokenResp.negResult)  = reject;\n    nt.u.negTokenResp.supportedMech = NULL;\n    nt.u.negTokenResp.responseToken = NULL;\n    nt.u.negTokenResp.mechListMIC   = NULL;\n\n    ASN1_MALLOC_ENCODE(NegotiationToken,\n\t\t       output_token->value, output_token->length, &nt,\n\t\t       &size, *minor_status);\n    free_NegotiationToken(&nt);\n    if (*minor_status != 0)\n\treturn GSS_S_FAILURE;\n\n    return GSS_S_BAD_MECH;\n}\n\nstatic OM_uint32\nacceptor_approved(gss_name_t target_name, gss_OID mech)\n{\n    gss_cred_id_t cred = GSS_C_NO_CREDENTIAL;\n    gss_OID_set oidset;\n    OM_uint32 junk, ret;\n\n    if (target_name == GSS_C_NO_NAME)\n\treturn GSS_S_COMPLETE;\n\n    gss_create_empty_oid_set(&junk, &oidset);\n    gss_add_oid_set_member(&junk, mech, &oidset);\n\n    ret = gss_acquire_cred(&junk, target_name, GSS_C_INDEFINITE, oidset,\n\t\t\t   GSS_C_ACCEPT, &cred, NULL, NULL);\n    gss_release_oid_set(&junk, &oidset);\n    if (ret != GSS_S_COMPLETE)\n\treturn ret;\n    gss_release_cred(&junk, &cred);\n\n    return GSS_S_COMPLETE;\n}\n\nstatic OM_uint32\nsend_supported_mechs (OM_uint32 *minor_status,\n\t\t      gss_buffer_t output_token)\n{\n    NegotiationTokenWin nt;\n    size_t buf_len = 0;\n    gss_buffer_desc data;\n    OM_uint32 ret;\n\n    memset(&nt, 0, sizeof(nt));\n\n    nt.element = choice_NegotiationTokenWin_negTokenInit;\n    nt.u.negTokenInit.reqFlags = NULL;\n    nt.u.negTokenInit.mechToken = NULL;\n    nt.u.negTokenInit.negHints = NULL;\n\n    ret = _gss_spnego_indicate_mechtypelist(minor_status, GSS_C_NO_NAME,\n\t\t\t\t\t    acceptor_approved, 1, NULL,\n\t\t\t\t\t    &nt.u.negTokenInit.mechTypes, NULL);\n    if (ret != GSS_S_COMPLETE) {\n\treturn ret;\n    }\n\n    ALLOC(nt.u.negTokenInit.negHints, 1);\n    if (nt.u.negTokenInit.negHints == NULL) {\n\t*minor_status = ENOMEM;\n\tfree_NegotiationTokenWin(&nt);\n\treturn GSS_S_FAILURE;\n    }\n\n    ALLOC(nt.u.negTokenInit.negHints->hintName, 1);\n    if (nt.u.negTokenInit.negHints->hintName == NULL) {\n\t*minor_status = ENOMEM;\n\tfree_NegotiationTokenWin(&nt);\n\treturn GSS_S_FAILURE;\n    }\n\n    *nt.u.negTokenInit.negHints->hintName = strdup(\"not_defined_in_RFC4178@please_ignore\");\n    nt.u.negTokenInit.negHints->hintAddress = NULL;\n\n    ASN1_MALLOC_ENCODE(NegotiationTokenWin,\n\t\t       data.value, data.length, &nt, &buf_len, ret);\n    free_NegotiationTokenWin(&nt);\n    if (ret) {\n\t*minor_status = ret;\n\treturn GSS_S_FAILURE;\n    }\n    if (data.length != buf_len) {\n\tabort();\n        UNREACHABLE(return GSS_S_FAILURE);\n    }\n\n    ret = gss_encapsulate_token(&data, GSS_SPNEGO_MECHANISM, output_token);\n\n    free (data.value);\n\n    if (ret != GSS_S_COMPLETE)\n\treturn ret;\n\n    *minor_status = 0;\n\n    return GSS_S_CONTINUE_NEEDED;\n}\n\nstatic OM_uint32\nsend_accept (OM_uint32 *minor_status,\n\t     gssspnego_ctx context_handle,\n\t     gss_buffer_t mech_token,\n\t     int initial_response,\n\t     gss_buffer_t mech_buf,\n\t     gss_buffer_t output_token)\n{\n    NegotiationToken nt;\n    OM_uint32 ret;\n    gss_buffer_desc mech_mic_buf;\n    size_t size;\n\n    memset(&nt, 0, sizeof(nt));\n\n    nt.element = choice_NegotiationToken_negTokenResp;\n\n    ALLOC(nt.u.negTokenResp.negResult, 1);\n    if (nt.u.negTokenResp.negResult == NULL) {\n\t*minor_status = ENOMEM;\n\treturn GSS_S_FAILURE;\n    }\n\n    if (context_handle->open) {\n\tif (mech_token != GSS_C_NO_BUFFER\n\t    && mech_token->length != 0\n\t    && mech_buf != GSS_C_NO_BUFFER)\n\t    *(nt.u.negTokenResp.negResult)  = accept_incomplete;\n\telse\n\t    *(nt.u.negTokenResp.negResult)  = accept_completed;\n    } else {\n\tif (initial_response && context_handle->require_mic)\n\t    *(nt.u.negTokenResp.negResult)  = request_mic;\n\telse\n\t    *(nt.u.negTokenResp.negResult)  = accept_incomplete;\n    }\n\n    if (initial_response) {\n\tALLOC(nt.u.negTokenResp.supportedMech, 1);\n\tif (nt.u.negTokenResp.supportedMech == NULL) {\n\t    free_NegotiationToken(&nt);\n\t    *minor_status = ENOMEM;\n\t    return GSS_S_FAILURE;\n\t}\n\n\tret = der_get_oid(context_handle->preferred_mech_type->elements,\n\t\t\t  context_handle->preferred_mech_type->length,\n\t\t\t  nt.u.negTokenResp.supportedMech,\n\t\t\t  NULL);\n\tif (ret) {\n\t    free_NegotiationToken(&nt);\n\t    *minor_status = ENOMEM;\n\t    return GSS_S_FAILURE;\n\t}\n    } else {\n\tnt.u.negTokenResp.supportedMech = NULL;\n    }\n\n    if (mech_token != GSS_C_NO_BUFFER && mech_token->length != 0) {\n\tALLOC(nt.u.negTokenResp.responseToken, 1);\n\tif (nt.u.negTokenResp.responseToken == NULL) {\n\t    free_NegotiationToken(&nt);\n\t    *minor_status = ENOMEM;\n\t    return GSS_S_FAILURE;\n\t}\n\tnt.u.negTokenResp.responseToken->length = mech_token->length;\n\tnt.u.negTokenResp.responseToken->data   = mech_token->value;\n\tmech_token->length = 0;\n\tmech_token->value  = NULL;\n    } else {\n\tnt.u.negTokenResp.responseToken = NULL;\n    }\n\n    if (mech_buf != GSS_C_NO_BUFFER) {\n\tret = gss_get_mic(minor_status,\n\t\t\t  context_handle->negotiated_ctx_id,\n\t\t\t  0,\n\t\t\t  mech_buf,\n\t\t\t  &mech_mic_buf);\n\tif (ret == GSS_S_COMPLETE) {\n\t    ALLOC(nt.u.negTokenResp.mechListMIC, 1);\n\t    if (nt.u.negTokenResp.mechListMIC == NULL) {\n\t\tgss_release_buffer(minor_status, &mech_mic_buf);\n\t\tfree_NegotiationToken(&nt);\n\t\t*minor_status = ENOMEM;\n\t\treturn GSS_S_FAILURE;\n\t    }\n\t    nt.u.negTokenResp.mechListMIC->length = mech_mic_buf.length;\n\t    nt.u.negTokenResp.mechListMIC->data   = mech_mic_buf.value;\n\t} else if (ret == GSS_S_UNAVAILABLE) {\n\t    nt.u.negTokenResp.mechListMIC = NULL;\n\t} else {\n\t    free_NegotiationToken(&nt);\n\t    return ret;\n\t}\n\n    } else\n\tnt.u.negTokenResp.mechListMIC = NULL;\n\n    ASN1_MALLOC_ENCODE(NegotiationToken,\n\t\t       output_token->value, output_token->length,\n\t\t       &nt, &size, ret);\n    if (ret) {\n\tfree_NegotiationToken(&nt);\n\t*minor_status = ret;\n\treturn GSS_S_FAILURE;\n    }\n\n    /*\n     * The response should not be encapsulated, because\n     * it is a SubsequentContextToken (note though RFC 1964\n     * specifies encapsulation for all _Kerberos_ tokens).\n     */\n\n    if (*(nt.u.negTokenResp.negResult) == accept_completed)\n\tret = GSS_S_COMPLETE;\n    else\n\tret = GSS_S_CONTINUE_NEEDED;\n    free_NegotiationToken(&nt);\n    return ret;\n}\n\n\nstatic OM_uint32\nverify_mechlist_mic\n\t   (OM_uint32 *minor_status,\n\t    gssspnego_ctx context_handle,\n\t    gss_buffer_t mech_buf,\n\t    heim_octet_string *mechListMIC\n\t   )\n{\n    OM_uint32 ret;\n    gss_buffer_desc mic_buf;\n\n    if (context_handle->verified_mic) {\n\t/* This doesn't make sense, we've already verified it? */\n\t*minor_status = 0;\n\treturn GSS_S_DUPLICATE_TOKEN;\n    }\n\n    if (mechListMIC == NULL) {\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    mic_buf.length = mechListMIC->length;\n    mic_buf.value  = mechListMIC->data;\n\n    ret = gss_verify_mic(minor_status,\n\t\t\t context_handle->negotiated_ctx_id,\n\t\t\t mech_buf,\n\t\t\t &mic_buf,\n\t\t\t NULL);\n\n    if (ret != GSS_S_COMPLETE)\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\n    return ret;\n}\n\nstatic OM_uint32\nselect_mech(OM_uint32 *minor_status, MechType *mechType, int verify_p,\n\t    gss_OID *mech_p)\n{\n    char mechbuf[64];\n    size_t mech_len;\n    gss_OID_desc oid;\n    gss_OID oidp;\n    gss_OID_set mechs;\n    size_t i;\n    OM_uint32 ret, junk;\n\n    ret = der_put_oid ((unsigned char *)mechbuf + sizeof(mechbuf) - 1,\n\t\t       sizeof(mechbuf),\n\t\t       mechType,\n\t\t       &mech_len);\n    if (ret) {\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    oid.length   = mech_len;\n    oid.elements = mechbuf + sizeof(mechbuf) - mech_len;\n\n    if (gss_oid_equal(&oid, GSS_SPNEGO_MECHANISM)) {\n\treturn GSS_S_BAD_MECH;\n    }\n\n    *minor_status = 0;\n\n    /* Translate broken MS Kebreros OID */\n    if (gss_oid_equal(&oid, &_gss_spnego_mskrb_mechanism_oid_desc))\n\t    oidp = &_gss_spnego_krb5_mechanism_oid_desc;\n    else\n\t    oidp = &oid;\n\n\n    ret = gss_indicate_mechs(&junk, &mechs);\n    if (ret)\n\t    return (ret);\n\n    for (i = 0; i < mechs->count; i++)\n\t    if (gss_oid_equal(&mechs->elements[i], oidp))\n\t\t    break;\n\n    if (i == mechs->count) {\n\t    gss_release_oid_set(&junk, &mechs);\n\t    return GSS_S_BAD_MECH;\n    }\n    gss_release_oid_set(&junk, &mechs);\n\n    ret = gss_duplicate_oid(minor_status,\n\t\t\t    &oid, /* possibly this should be oidp */\n\t\t\t    mech_p);\n\n    if (verify_p) {\n\tgss_name_t name = GSS_C_NO_NAME;\n\tgss_buffer_desc namebuf;\n\tchar *str = NULL, *host, hostname[MAXHOSTNAMELEN];\n\n\thost = getenv(\"GSSAPI_SPNEGO_NAME\");\n\tif (host == NULL || issuid()) {\n\t    int rv;\n\t    if (gethostname(hostname, sizeof(hostname)) != 0) {\n\t\t*minor_status = errno;\n\t\treturn GSS_S_FAILURE;\n\t    }\n\t    rv = asprintf(&str, \"host@%s\", hostname);\n\t    if (rv < 0 || str == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\treturn GSS_S_FAILURE;\n\t    }\n\t    host = str;\n\t}\n\n\tnamebuf.length = strlen(host);\n\tnamebuf.value = host;\n\n\tret = gss_import_name(minor_status, &namebuf,\n\t\t\t      GSS_C_NT_HOSTBASED_SERVICE, &name);\n\tif (str)\n\t    free(str);\n\tif (ret != GSS_S_COMPLETE)\n\t    return ret;\n\n\tret = acceptor_approved(name, *mech_p);\n\tgss_release_name(&junk, &name);\n    }\n\n    return ret;\n}\n\n\nstatic OM_uint32\nacceptor_complete(OM_uint32 * minor_status,\n\t\t  gssspnego_ctx ctx,\n\t\t  int *get_mic,\n\t\t  gss_buffer_t mech_buf,\n\t\t  gss_buffer_t mech_input_token,\n\t\t  gss_buffer_t mech_output_token,\n\t\t  heim_octet_string *mic,\n\t\t  gss_buffer_t output_token)\n{\n    OM_uint32 ret;\n    int require_mic, verify_mic;\n\n    ret = _gss_spnego_require_mechlist_mic(minor_status, ctx, &require_mic);\n    if (ret)\n\treturn ret;\n\n    ctx->require_mic = require_mic;\n\n    if (mic != NULL)\n\trequire_mic = 1;\n\n    if (ctx->open && require_mic) {\n\tif (mech_input_token == GSS_C_NO_BUFFER) { /* Even/One */\n\t    verify_mic = 1;\n\t    *get_mic = 0;\n\t} else if (mech_output_token != GSS_C_NO_BUFFER &&\n\t\t   mech_output_token->length == 0) { /* Odd */\n\t    *get_mic = verify_mic = 1;\n\t} else { /* Even/One */\n\t    verify_mic = 0;\n\t    *get_mic = 1;\n\t}\n\n\tif (verify_mic || *get_mic) {\n\t    int eret;\n\t    size_t buf_len = 0;\n\n\t    ASN1_MALLOC_ENCODE(MechTypeList,\n\t\t\t       mech_buf->value, mech_buf->length,\n\t\t\t       &ctx->initiator_mech_types, &buf_len, eret);\n\t    if (eret) {\n\t\t*minor_status = eret;\n\t\treturn GSS_S_FAILURE;\n\t    }\n\t    heim_assert(mech_buf->length == buf_len, \"Internal ASN.1 error\");\n\t    UNREACHABLE(return GSS_S_FAILURE);\n\t}\n\n\tif (verify_mic) {\n\t    ret = verify_mechlist_mic(minor_status, ctx, mech_buf, mic);\n\t    if (ret) {\n\t\tif (*get_mic)\n\t\t    send_reject (minor_status, output_token);\n\t\treturn ret;\n\t    }\n\t    ctx->verified_mic = 1;\n\t}\n    } else\n\t*get_mic = 0;\n\n    return GSS_S_COMPLETE;\n}\n\n\nstatic OM_uint32 GSSAPI_CALLCONV\nacceptor_start\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, junk;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenInit *ni;\n    gss_buffer_desc data;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_output_token;\n    gss_buffer_desc mech_buf;\n    gss_OID preferred_mech_type = GSS_C_NO_OID;\n    gssspnego_ctx ctx;\n    int get_mic = 0;\n    int first_ok = 0;\n\n    mech_output_token.value = NULL;\n    mech_output_token.length = 0;\n    mech_buf.value = NULL;\n\n    if (input_token_buffer->length == 0)\n\treturn send_supported_mechs (minor_status, output_token);\n\n    ret = _gss_spnego_alloc_sec_context(minor_status, context_handle);\n    if (ret != GSS_S_COMPLETE)\n\treturn ret;\n\n    ctx = (gssspnego_ctx)*context_handle;\n\n    /*\n     * The GSS-API encapsulation is only present on the initial\n     * context token (negTokenInit).\n     */\n    ret = gss_decapsulate_token (input_token_buffer,\n\t\t\t\t GSS_SPNEGO_MECHANISM,\n\t\t\t\t &data);\n    if (ret)\n\treturn ret;\n\n    ret = decode_NegotiationToken(data.value, data.length, &nt, &nt_len);\n    gss_release_buffer(minor_status, &data);\n    if (ret) {\n\t*minor_status = ret;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    if (nt.element != choice_NegotiationToken_negTokenInit) {\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    ni = &nt.u.negTokenInit;\n\n    if (ni->mechTypes.len < 1) {\n\tfree_NegotiationToken(&nt);\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    HEIMDAL_MUTEX_lock(&ctx->ctx_id_mutex);\n\n    ret = copy_MechTypeList(&ni->mechTypes, &ctx->initiator_mech_types);\n    if (ret) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\tfree_NegotiationToken(&nt);\n\t*minor_status = ret;\n\treturn GSS_S_FAILURE;\n    }\n\n    /*\n     * First we try the opportunistic token if we have support for it,\n     * don't try to verify we have credential for the token,\n     * gss_accept_sec_context() will (hopefully) tell us that.\n     * If that failes,\n     */\n\n    ret = select_mech(minor_status,\n\t\t      &ni->mechTypes.val[0],\n\t\t      0,\n\t\t      &preferred_mech_type);\n\n    if (ret == 0 && ni->mechToken != NULL) {\n\tgss_buffer_desc ibuf;\n\n\tibuf.length = ni->mechToken->length;\n\tibuf.value = ni->mechToken->data;\n\tmech_input_token = &ibuf;\n\n\tif (ctx->mech_src_name != GSS_C_NO_NAME)\n\t    gss_release_name(&junk, &ctx->mech_src_name);\n\n\tret = gss_accept_sec_context(minor_status,\n\t\t\t\t     &ctx->negotiated_ctx_id,\n\t\t\t\t     acceptor_cred_handle,\n\t\t\t\t     mech_input_token,\n\t\t\t\t     input_chan_bindings,\n\t\t\t\t     &ctx->mech_src_name,\n\t\t\t\t     &ctx->negotiated_mech_type,\n\t\t\t\t     &mech_output_token,\n\t\t\t\t     &ctx->mech_flags,\n\t\t\t\t     &ctx->mech_time_rec,\n\t\t\t\t     delegated_cred_handle);\n\n\tif (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\t    ctx->preferred_mech_type = preferred_mech_type;\n\t    if (ret == GSS_S_COMPLETE)\n\t\tctx->open = 1;\n\n\t    ret = acceptor_complete(minor_status,\n\t\t\t\t    ctx,\n\t\t\t\t    &get_mic,\n\t\t\t\t    &mech_buf,\n\t\t\t\t    mech_input_token,\n\t\t\t\t    &mech_output_token,\n\t\t\t\t    ni->mechListMIC,\n\t\t\t\t    output_token);\n\t    if (ret != GSS_S_COMPLETE)\n\t\tgoto out;\n\n\t    first_ok = 1;\n\t} else {\n\t    gss_mg_collect_error(preferred_mech_type, ret, *minor_status);\n\t}\n    }\n\n    /*\n     * If opportunistic token failed, lets try the other mechs.\n     */\n\n    if (!first_ok && ni->mechToken != NULL) {\n\tsize_t j;\n\n\tpreferred_mech_type = GSS_C_NO_OID;\n\n\t/* Call glue layer to find first mech we support */\n\tfor (j = 1; j < ni->mechTypes.len; ++j) {\n\t    ret = select_mech(minor_status,\n\t\t\t      &ni->mechTypes.val[j],\n\t\t\t      1,\n\t\t\t      &preferred_mech_type);\n\t    if (ret == 0)\n\t\tbreak;\n\t}\n\tif (preferred_mech_type == GSS_C_NO_OID) {\n\t    HEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\t    free_NegotiationToken(&nt);\n\t    return ret;\n\t}\n\n\tctx->preferred_mech_type = preferred_mech_type;\n    }\n\n    /*\n     * The initial token always have a response\n     */\n\n    ret = send_accept (minor_status,\n\t\t       ctx,\n\t\t       &mech_output_token,\n\t\t       1,\n\t\t       get_mic ? &mech_buf : NULL,\n\t\t       output_token);\n    if (ret)\n\tgoto out;\n\nout:\n    if (mech_output_token.value != NULL)\n\tgss_release_buffer(&junk, &mech_output_token);\n    if (mech_buf.value != NULL) {\n\tfree(mech_buf.value);\n\tmech_buf.value = NULL;\n    }\n    free_NegotiationToken(&nt);\n\n\n    if (ret == GSS_S_COMPLETE) {\n\tif (src_name != NULL && ctx->mech_src_name != NULL) {\n\t    spnego_name name;\n\n\t    name = calloc(1, sizeof(*name));\n\t    if (name) {\n\t\tname->mech = ctx->mech_src_name;\n\t\tctx->mech_src_name = NULL;\n\t\t*src_name = (gss_name_t)name;\n\t    }\n\t}\n    }\n\n    if (mech_type != NULL)\n\t*mech_type = ctx->negotiated_mech_type;\n    if (ret_flags != NULL)\n\t*ret_flags = ctx->mech_flags;\n    if (time_rec != NULL)\n\t*time_rec = ctx->mech_time_rec;\n\n    if (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n \treturn ret;\n    }\n\n    _gss_spnego_internal_delete_sec_context(&junk, context_handle,\n\t\t\t\t\t    GSS_C_NO_BUFFER);\n\n    return ret;\n}\n\n\nstatic OM_uint32 GSSAPI_CALLCONV\nacceptor_continue\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, ret2, minor;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenResp *na;\n    unsigned int negResult = accept_incomplete;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_t mech_output_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_buf;\n    gssspnego_ctx ctx;\n\n    mech_buf.value = NULL;\n\n    ctx = (gssspnego_ctx)*context_handle;\n\n    /*\n     * The GSS-API encapsulation is only present on the initial\n     * context token (negTokenInit).\n     */\n\n    ret = decode_NegotiationToken(input_token_buffer->value,\n\t\t\t\t  input_token_buffer->length,\n\t\t\t\t  &nt, &nt_len);\n    if (ret) {\n\t*minor_status = ret;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    if (nt.element != choice_NegotiationToken_negTokenResp) {\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    na = &nt.u.negTokenResp;\n\n    if (na->negResult != NULL) {\n\tnegResult = *(na->negResult);\n    }\n\n    HEIMDAL_MUTEX_lock(&ctx->ctx_id_mutex);\n\n    {\n\tgss_buffer_desc ibuf, obuf;\n\tint require_mic, get_mic = 0;\n\tint require_response;\n\theim_octet_string *mic;\n\n\tif (na->responseToken != NULL) {\n\t    ibuf.length = na->responseToken->length;\n\t    ibuf.value = na->responseToken->data;\n\t    mech_input_token = &ibuf;\n\t} else {\n\t    ibuf.value = NULL;\n\t    ibuf.length = 0;\n\t}\n\n\tif (mech_input_token != GSS_C_NO_BUFFER) {\n\n\t    if (ctx->mech_src_name != GSS_C_NO_NAME)\n\t\tgss_release_name(&minor, &ctx->mech_src_name);\n\n\t    ret = gss_accept_sec_context(&minor,\n\t\t\t\t\t &ctx->negotiated_ctx_id,\n\t\t\t\t\t acceptor_cred_handle,\n\t\t\t\t\t mech_input_token,\n\t\t\t\t\t input_chan_bindings,\n\t\t\t\t\t &ctx->mech_src_name,\n\t\t\t\t\t &ctx->negotiated_mech_type,\n\t\t\t\t\t &obuf,\n\t\t\t\t\t &ctx->mech_flags,\n\t\t\t\t\t &ctx->mech_time_rec,\n\t\t\t\t\t delegated_cred_handle);\n\n\t    if (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\t\tmech_output_token = &obuf;\n\t    }\n\t    if (ret != GSS_S_COMPLETE && ret != GSS_S_CONTINUE_NEEDED) {\n\t\tfree_NegotiationToken(&nt);\n\t\tgss_mg_collect_error(ctx->negotiated_mech_type, ret, minor);\n\t\tsend_reject (minor_status, output_token);\n\t\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\t\treturn ret;\n\t    }\n\t    if (ret == GSS_S_COMPLETE)\n\t\tctx->open = 1;\n\t} else\n\t    ret = GSS_S_COMPLETE;\n\n\tret2 = _gss_spnego_require_mechlist_mic(minor_status,\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\t&require_mic);\n\tif (ret2)\n\t    goto out;\n\n\tctx->require_mic = require_mic;\n\n\tmic = na->mechListMIC;\n\tif (mic != NULL)\n\t    require_mic = 1;\n\n\tif (ret == GSS_S_COMPLETE)\n\t    ret = acceptor_complete(minor_status,\n\t\t\t\t    ctx,\n\t\t\t\t    &get_mic,\n\t\t\t\t    &mech_buf,\n\t\t\t\t    mech_input_token,\n\t\t\t\t    mech_output_token,\n\t\t\t\t    na->mechListMIC,\n\t\t\t\t    output_token);\n\n\tif (ctx->mech_flags & GSS_C_DCE_STYLE)\n\t    require_response = (negResult != accept_completed);\n\telse\n\t    require_response = 0;\n\n\t/*\n\t * Check whether we need to send a result: there should be only\n\t * one accept_completed response sent in the entire negotiation\n\t */\n\tif ((mech_output_token != GSS_C_NO_BUFFER &&\n\t     mech_output_token->length != 0)\n\t    || (ctx->open && negResult == accept_incomplete)\n\t    || require_response\n\t    || get_mic) {\n\t    ret2 = send_accept (minor_status,\n\t\t\t\tctx,\n\t\t\t\tmech_output_token,\n\t\t\t\t0,\n\t\t\t\tget_mic ? &mech_buf : NULL,\n\t\t\t\toutput_token);\n\t    if (ret2)\n\t\tgoto out;\n\t}\n\n     out:\n\tif (ret2 != GSS_S_COMPLETE)\n\t    ret = ret2;\n\tif (mech_output_token != NULL)\n\t    gss_release_buffer(&minor, mech_output_token);\n\tif (mech_buf.value != NULL)\n\t    free(mech_buf.value);\n\tfree_NegotiationToken(&nt);\n    }\n\n    if (ret == GSS_S_COMPLETE) {\n\tif (src_name != NULL && ctx->mech_src_name != NULL) {\n\t    spnego_name name;\n\n\t    name = calloc(1, sizeof(*name));\n\t    if (name) {\n\t\tname->mech = ctx->mech_src_name;\n\t\tctx->mech_src_name = NULL;\n\t\t*src_name = (gss_name_t)name;\n\t    }\n\t}\n    }\n\n    if (mech_type != NULL)\n\t*mech_type = ctx->negotiated_mech_type;\n    if (ret_flags != NULL)\n\t*ret_flags = ctx->mech_flags;\n    if (time_rec != NULL)\n\t*time_rec = ctx->mech_time_rec;\n\n    if (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n \treturn ret;\n    }\n\n    _gss_spnego_internal_delete_sec_context(&minor, context_handle,\n\t\t\t\t   GSS_C_NO_BUFFER);\n\n    return ret;\n}\n\nOM_uint32 GSSAPI_CALLCONV\n_gss_spnego_accept_sec_context\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    _gss_accept_sec_context_t *func;\n\n    *minor_status = 0;\n\n    output_token->length = 0;\n    output_token->value  = NULL;\n\n    if (src_name != NULL)\n\t*src_name = GSS_C_NO_NAME;\n    if (mech_type != NULL)\n\t*mech_type = GSS_C_NO_OID;\n    if (ret_flags != NULL)\n\t*ret_flags = 0;\n    if (time_rec != NULL)\n\t*time_rec = 0;\n    if (delegated_cred_handle != NULL)\n\t*delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n\n\n    if (*context_handle == GSS_C_NO_CONTEXT)\n\tfunc = acceptor_start;\n    else\n\tfunc = acceptor_continue;\n\n\n    return (*func)(minor_status, context_handle, acceptor_cred_handle,\n\t\t   input_token_buffer, input_chan_bindings,\n\t\t   src_name, mech_type, output_token, ret_flags,\n\t\t   time_rec, delegated_cred_handle);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1997 - 2006 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * Portions Copyright (c) 2004 PADL Software Pty Ltd.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"spnego_locl.h\"\n\nstatic OM_uint32\nsend_reject (OM_uint32 *minor_status,\n\t     gss_buffer_t output_token)\n{\n    NegotiationToken nt;\n    size_t size;\n\n    nt.element = choice_NegotiationToken_negTokenResp;\n\n    ALLOC(nt.u.negTokenResp.negResult, 1);\n    if (nt.u.negTokenResp.negResult == NULL) {\n\t*minor_status = ENOMEM;\n\treturn GSS_S_FAILURE;\n    }\n    *(nt.u.negTokenResp.negResult)  = reject;\n    nt.u.negTokenResp.supportedMech = NULL;\n    nt.u.negTokenResp.responseToken = NULL;\n    nt.u.negTokenResp.mechListMIC   = NULL;\n\n    ASN1_MALLOC_ENCODE(NegotiationToken,\n\t\t       output_token->value, output_token->length, &nt,\n\t\t       &size, *minor_status);\n    free_NegotiationToken(&nt);\n    if (*minor_status != 0)\n\treturn GSS_S_FAILURE;\n\n    return GSS_S_BAD_MECH;\n}\n\nstatic OM_uint32\nacceptor_approved(gss_name_t target_name, gss_OID mech)\n{\n    gss_cred_id_t cred = GSS_C_NO_CREDENTIAL;\n    gss_OID_set oidset;\n    OM_uint32 junk, ret;\n\n    if (target_name == GSS_C_NO_NAME)\n\treturn GSS_S_COMPLETE;\n\n    gss_create_empty_oid_set(&junk, &oidset);\n    gss_add_oid_set_member(&junk, mech, &oidset);\n\n    ret = gss_acquire_cred(&junk, target_name, GSS_C_INDEFINITE, oidset,\n\t\t\t   GSS_C_ACCEPT, &cred, NULL, NULL);\n    gss_release_oid_set(&junk, &oidset);\n    if (ret != GSS_S_COMPLETE)\n\treturn ret;\n    gss_release_cred(&junk, &cred);\n\n    return GSS_S_COMPLETE;\n}\n\nstatic OM_uint32\nsend_supported_mechs (OM_uint32 *minor_status,\n\t\t      gss_buffer_t output_token)\n{\n    NegotiationTokenWin nt;\n    size_t buf_len = 0;\n    gss_buffer_desc data;\n    OM_uint32 ret;\n\n    memset(&nt, 0, sizeof(nt));\n\n    nt.element = choice_NegotiationTokenWin_negTokenInit;\n    nt.u.negTokenInit.reqFlags = NULL;\n    nt.u.negTokenInit.mechToken = NULL;\n    nt.u.negTokenInit.negHints = NULL;\n\n    ret = _gss_spnego_indicate_mechtypelist(minor_status, GSS_C_NO_NAME,\n\t\t\t\t\t    acceptor_approved, 1, NULL,\n\t\t\t\t\t    &nt.u.negTokenInit.mechTypes, NULL);\n    if (ret != GSS_S_COMPLETE) {\n\treturn ret;\n    }\n\n    ALLOC(nt.u.negTokenInit.negHints, 1);\n    if (nt.u.negTokenInit.negHints == NULL) {\n\t*minor_status = ENOMEM;\n\tfree_NegotiationTokenWin(&nt);\n\treturn GSS_S_FAILURE;\n    }\n\n    ALLOC(nt.u.negTokenInit.negHints->hintName, 1);\n    if (nt.u.negTokenInit.negHints->hintName == NULL) {\n\t*minor_status = ENOMEM;\n\tfree_NegotiationTokenWin(&nt);\n\treturn GSS_S_FAILURE;\n    }\n\n    *nt.u.negTokenInit.negHints->hintName = strdup(\"not_defined_in_RFC4178@please_ignore\");\n    nt.u.negTokenInit.negHints->hintAddress = NULL;\n\n    ASN1_MALLOC_ENCODE(NegotiationTokenWin,\n\t\t       data.value, data.length, &nt, &buf_len, ret);\n    free_NegotiationTokenWin(&nt);\n    if (ret) {\n\t*minor_status = ret;\n\treturn GSS_S_FAILURE;\n    }\n    if (data.length != buf_len) {\n\tabort();\n        UNREACHABLE(return GSS_S_FAILURE);\n    }\n\n    ret = gss_encapsulate_token(&data, GSS_SPNEGO_MECHANISM, output_token);\n\n    free (data.value);\n\n    if (ret != GSS_S_COMPLETE)\n\treturn ret;\n\n    *minor_status = 0;\n\n    return GSS_S_CONTINUE_NEEDED;\n}\n\nstatic OM_uint32\nsend_accept (OM_uint32 *minor_status,\n\t     gssspnego_ctx context_handle,\n\t     gss_buffer_t mech_token,\n\t     int initial_response,\n\t     gss_buffer_t mech_buf,\n\t     gss_buffer_t output_token)\n{\n    NegotiationToken nt;\n    OM_uint32 ret;\n    gss_buffer_desc mech_mic_buf;\n    size_t size;\n\n    memset(&nt, 0, sizeof(nt));\n\n    nt.element = choice_NegotiationToken_negTokenResp;\n\n    ALLOC(nt.u.negTokenResp.negResult, 1);\n    if (nt.u.negTokenResp.negResult == NULL) {\n\t*minor_status = ENOMEM;\n\treturn GSS_S_FAILURE;\n    }\n\n    if (context_handle->open) {\n\tif (mech_token != GSS_C_NO_BUFFER\n\t    && mech_token->length != 0\n\t    && mech_buf != GSS_C_NO_BUFFER)\n\t    *(nt.u.negTokenResp.negResult)  = accept_incomplete;\n\telse\n\t    *(nt.u.negTokenResp.negResult)  = accept_completed;\n    } else {\n\tif (initial_response && context_handle->require_mic)\n\t    *(nt.u.negTokenResp.negResult)  = request_mic;\n\telse\n\t    *(nt.u.negTokenResp.negResult)  = accept_incomplete;\n    }\n\n    if (initial_response) {\n\tALLOC(nt.u.negTokenResp.supportedMech, 1);\n\tif (nt.u.negTokenResp.supportedMech == NULL) {\n\t    free_NegotiationToken(&nt);\n\t    *minor_status = ENOMEM;\n\t    return GSS_S_FAILURE;\n\t}\n\n\tret = der_get_oid(context_handle->preferred_mech_type->elements,\n\t\t\t  context_handle->preferred_mech_type->length,\n\t\t\t  nt.u.negTokenResp.supportedMech,\n\t\t\t  NULL);\n\tif (ret) {\n\t    free_NegotiationToken(&nt);\n\t    *minor_status = ENOMEM;\n\t    return GSS_S_FAILURE;\n\t}\n    } else {\n\tnt.u.negTokenResp.supportedMech = NULL;\n    }\n\n    if (mech_token != GSS_C_NO_BUFFER && mech_token->length != 0) {\n\tALLOC(nt.u.negTokenResp.responseToken, 1);\n\tif (nt.u.negTokenResp.responseToken == NULL) {\n\t    free_NegotiationToken(&nt);\n\t    *minor_status = ENOMEM;\n\t    return GSS_S_FAILURE;\n\t}\n\tnt.u.negTokenResp.responseToken->length = mech_token->length;\n\tnt.u.negTokenResp.responseToken->data   = mech_token->value;\n\tmech_token->length = 0;\n\tmech_token->value  = NULL;\n    } else {\n\tnt.u.negTokenResp.responseToken = NULL;\n    }\n\n    if (mech_buf != GSS_C_NO_BUFFER) {\n\tret = gss_get_mic(minor_status,\n\t\t\t  context_handle->negotiated_ctx_id,\n\t\t\t  0,\n\t\t\t  mech_buf,\n\t\t\t  &mech_mic_buf);\n\tif (ret == GSS_S_COMPLETE) {\n\t    ALLOC(nt.u.negTokenResp.mechListMIC, 1);\n\t    if (nt.u.negTokenResp.mechListMIC == NULL) {\n\t\tgss_release_buffer(minor_status, &mech_mic_buf);\n\t\tfree_NegotiationToken(&nt);\n\t\t*minor_status = ENOMEM;\n\t\treturn GSS_S_FAILURE;\n\t    }\n\t    nt.u.negTokenResp.mechListMIC->length = mech_mic_buf.length;\n\t    nt.u.negTokenResp.mechListMIC->data   = mech_mic_buf.value;\n\t} else if (ret == GSS_S_UNAVAILABLE) {\n\t    nt.u.negTokenResp.mechListMIC = NULL;\n\t} else {\n\t    free_NegotiationToken(&nt);\n\t    return ret;\n\t}\n\n    } else\n\tnt.u.negTokenResp.mechListMIC = NULL;\n\n    ASN1_MALLOC_ENCODE(NegotiationToken,\n\t\t       output_token->value, output_token->length,\n\t\t       &nt, &size, ret);\n    if (ret) {\n\tfree_NegotiationToken(&nt);\n\t*minor_status = ret;\n\treturn GSS_S_FAILURE;\n    }\n\n    /*\n     * The response should not be encapsulated, because\n     * it is a SubsequentContextToken (note though RFC 1964\n     * specifies encapsulation for all _Kerberos_ tokens).\n     */\n\n    if (*(nt.u.negTokenResp.negResult) == accept_completed)\n\tret = GSS_S_COMPLETE;\n    else\n\tret = GSS_S_CONTINUE_NEEDED;\n    free_NegotiationToken(&nt);\n    return ret;\n}\n\n\nstatic OM_uint32\nverify_mechlist_mic\n\t   (OM_uint32 *minor_status,\n\t    gssspnego_ctx context_handle,\n\t    gss_buffer_t mech_buf,\n\t    heim_octet_string *mechListMIC\n\t   )\n{\n    OM_uint32 ret;\n    gss_buffer_desc mic_buf;\n\n    if (context_handle->verified_mic) {\n\t/* This doesn't make sense, we've already verified it? */\n\t*minor_status = 0;\n\treturn GSS_S_DUPLICATE_TOKEN;\n    }\n\n    if (mechListMIC == NULL) {\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    mic_buf.length = mechListMIC->length;\n    mic_buf.value  = mechListMIC->data;\n\n    ret = gss_verify_mic(minor_status,\n\t\t\t context_handle->negotiated_ctx_id,\n\t\t\t mech_buf,\n\t\t\t &mic_buf,\n\t\t\t NULL);\n\n    if (ret != GSS_S_COMPLETE)\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\n    return ret;\n}\n\nstatic OM_uint32\nselect_mech(OM_uint32 *minor_status, MechType *mechType, int verify_p,\n\t    gss_OID *mech_p)\n{\n    char mechbuf[64];\n    size_t mech_len;\n    gss_OID_desc oid;\n    gss_OID oidp;\n    gss_OID_set mechs;\n    size_t i;\n    OM_uint32 ret, junk;\n\n    ret = der_put_oid ((unsigned char *)mechbuf + sizeof(mechbuf) - 1,\n\t\t       sizeof(mechbuf),\n\t\t       mechType,\n\t\t       &mech_len);\n    if (ret) {\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    oid.length   = mech_len;\n    oid.elements = mechbuf + sizeof(mechbuf) - mech_len;\n\n    if (gss_oid_equal(&oid, GSS_SPNEGO_MECHANISM)) {\n\treturn GSS_S_BAD_MECH;\n    }\n\n    *minor_status = 0;\n\n    /* Translate broken MS Kebreros OID */\n    if (gss_oid_equal(&oid, &_gss_spnego_mskrb_mechanism_oid_desc))\n\t    oidp = &_gss_spnego_krb5_mechanism_oid_desc;\n    else\n\t    oidp = &oid;\n\n\n    ret = gss_indicate_mechs(&junk, &mechs);\n    if (ret)\n\t    return (ret);\n\n    for (i = 0; i < mechs->count; i++)\n\t    if (gss_oid_equal(&mechs->elements[i], oidp))\n\t\t    break;\n\n    if (i == mechs->count) {\n\t    gss_release_oid_set(&junk, &mechs);\n\t    return GSS_S_BAD_MECH;\n    }\n    gss_release_oid_set(&junk, &mechs);\n\n    ret = gss_duplicate_oid(minor_status,\n\t\t\t    &oid, /* possibly this should be oidp */\n\t\t\t    mech_p);\n\n    if (verify_p) {\n\tgss_name_t name = GSS_C_NO_NAME;\n\tgss_buffer_desc namebuf;\n\tchar *str = NULL, *host, hostname[MAXHOSTNAMELEN];\n\n\thost = getenv(\"GSSAPI_SPNEGO_NAME\");\n\tif (host == NULL || issuid()) {\n\t    int rv;\n\t    if (gethostname(hostname, sizeof(hostname)) != 0) {\n\t\t*minor_status = errno;\n\t\treturn GSS_S_FAILURE;\n\t    }\n\t    rv = asprintf(&str, \"host@%s\", hostname);\n\t    if (rv < 0 || str == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\treturn GSS_S_FAILURE;\n\t    }\n\t    host = str;\n\t}\n\n\tnamebuf.length = strlen(host);\n\tnamebuf.value = host;\n\n\tret = gss_import_name(minor_status, &namebuf,\n\t\t\t      GSS_C_NT_HOSTBASED_SERVICE, &name);\n\tif (str)\n\t    free(str);\n\tif (ret != GSS_S_COMPLETE)\n\t    return ret;\n\n\tret = acceptor_approved(name, *mech_p);\n\tgss_release_name(&junk, &name);\n    }\n\n    return ret;\n}\n\n\nstatic OM_uint32\nacceptor_complete(OM_uint32 * minor_status,\n\t\t  gssspnego_ctx ctx,\n\t\t  int *get_mic,\n\t\t  gss_buffer_t mech_buf,\n\t\t  gss_buffer_t mech_input_token,\n\t\t  gss_buffer_t mech_output_token,\n\t\t  heim_octet_string *mic,\n\t\t  gss_buffer_t output_token)\n{\n    OM_uint32 ret;\n    int require_mic, verify_mic;\n\n    ret = _gss_spnego_require_mechlist_mic(minor_status, ctx, &require_mic);\n    if (ret)\n\treturn ret;\n\n    ctx->require_mic = require_mic;\n\n    if (mic != NULL)\n\trequire_mic = 1;\n\n    if (ctx->open && require_mic) {\n\tif (mech_input_token == GSS_C_NO_BUFFER) { /* Even/One */\n\t    verify_mic = 1;\n\t    *get_mic = 0;\n\t} else if (mech_output_token != GSS_C_NO_BUFFER &&\n\t\t   mech_output_token->length == 0) { /* Odd */\n\t    *get_mic = verify_mic = 1;\n\t} else { /* Even/One */\n\t    verify_mic = 0;\n\t    *get_mic = 1;\n\t}\n\n\tif (verify_mic || *get_mic) {\n\t    int eret;\n\t    size_t buf_len = 0;\n\n\t    ASN1_MALLOC_ENCODE(MechTypeList,\n\t\t\t       mech_buf->value, mech_buf->length,\n\t\t\t       &ctx->initiator_mech_types, &buf_len, eret);\n\t    if (eret) {\n\t\t*minor_status = eret;\n\t\treturn GSS_S_FAILURE;\n\t    }\n\t    heim_assert(mech_buf->length == buf_len, \"Internal ASN.1 error\");\n\t    UNREACHABLE(return GSS_S_FAILURE);\n\t}\n\n\tif (verify_mic) {\n\t    ret = verify_mechlist_mic(minor_status, ctx, mech_buf, mic);\n\t    if (ret) {\n\t\tif (*get_mic)\n\t\t    send_reject (minor_status, output_token);\n\t\treturn ret;\n\t    }\n\t    ctx->verified_mic = 1;\n\t}\n    } else\n\t*get_mic = 0;\n\n    return GSS_S_COMPLETE;\n}\n\n\nstatic OM_uint32 GSSAPI_CALLCONV\nacceptor_start\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, junk;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenInit *ni;\n    gss_buffer_desc data;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_output_token;\n    gss_buffer_desc mech_buf;\n    gss_OID preferred_mech_type = GSS_C_NO_OID;\n    gssspnego_ctx ctx;\n    int get_mic = 0;\n    int first_ok = 0;\n\n    mech_output_token.value = NULL;\n    mech_output_token.length = 0;\n    mech_buf.value = NULL;\n\n    if (input_token_buffer->length == 0)\n\treturn send_supported_mechs (minor_status, output_token);\n\n    ret = _gss_spnego_alloc_sec_context(minor_status, context_handle);\n    if (ret != GSS_S_COMPLETE)\n\treturn ret;\n\n    ctx = (gssspnego_ctx)*context_handle;\n\n    /*\n     * The GSS-API encapsulation is only present on the initial\n     * context token (negTokenInit).\n     */\n    ret = gss_decapsulate_token (input_token_buffer,\n\t\t\t\t GSS_SPNEGO_MECHANISM,\n\t\t\t\t &data);\n    if (ret)\n\treturn ret;\n\n    ret = decode_NegotiationToken(data.value, data.length, &nt, &nt_len);\n    gss_release_buffer(minor_status, &data);\n    if (ret) {\n\t*minor_status = ret;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    if (nt.element != choice_NegotiationToken_negTokenInit) {\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    ni = &nt.u.negTokenInit;\n\n    if (ni->mechTypes.len < 1) {\n\tfree_NegotiationToken(&nt);\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    HEIMDAL_MUTEX_lock(&ctx->ctx_id_mutex);\n\n    ret = copy_MechTypeList(&ni->mechTypes, &ctx->initiator_mech_types);\n    if (ret) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\tfree_NegotiationToken(&nt);\n\t*minor_status = ret;\n\treturn GSS_S_FAILURE;\n    }\n\n    /*\n     * First we try the opportunistic token if we have support for it,\n     * don't try to verify we have credential for the token,\n     * gss_accept_sec_context() will (hopefully) tell us that.\n     * If that failes,\n     */\n\n    ret = select_mech(minor_status,\n\t\t      &ni->mechTypes.val[0],\n\t\t      0,\n\t\t      &preferred_mech_type);\n\n    if (ret == 0 && ni->mechToken != NULL) {\n\tgss_buffer_desc ibuf;\n\n\tibuf.length = ni->mechToken->length;\n\tibuf.value = ni->mechToken->data;\n\tmech_input_token = &ibuf;\n\n\tif (ctx->mech_src_name != GSS_C_NO_NAME)\n\t    gss_release_name(&junk, &ctx->mech_src_name);\n\n\tret = gss_accept_sec_context(minor_status,\n\t\t\t\t     &ctx->negotiated_ctx_id,\n\t\t\t\t     acceptor_cred_handle,\n\t\t\t\t     mech_input_token,\n\t\t\t\t     input_chan_bindings,\n\t\t\t\t     &ctx->mech_src_name,\n\t\t\t\t     &ctx->negotiated_mech_type,\n\t\t\t\t     &mech_output_token,\n\t\t\t\t     &ctx->mech_flags,\n\t\t\t\t     &ctx->mech_time_rec,\n\t\t\t\t     delegated_cred_handle);\n\n\tif (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\t    ctx->preferred_mech_type = preferred_mech_type;\n\t    if (ret == GSS_S_COMPLETE)\n\t\tctx->open = 1;\n\n\t    ret = acceptor_complete(minor_status,\n\t\t\t\t    ctx,\n\t\t\t\t    &get_mic,\n\t\t\t\t    &mech_buf,\n\t\t\t\t    mech_input_token,\n\t\t\t\t    &mech_output_token,\n\t\t\t\t    ni->mechListMIC,\n\t\t\t\t    output_token);\n\t    if (ret != GSS_S_COMPLETE)\n\t\tgoto out;\n\n\t    first_ok = 1;\n\t} else {\n\t    gss_mg_collect_error(preferred_mech_type, ret, *minor_status);\n\t}\n    }\n\n    /*\n     * If opportunistic token failed, lets try the other mechs.\n     */\n\n    if (!first_ok && ni->mechToken != NULL) {\n\tsize_t j;\n\n\tpreferred_mech_type = GSS_C_NO_OID;\n\n\t/* Call glue layer to find first mech we support */\n\tfor (j = 1; j < ni->mechTypes.len; ++j) {\n\t    ret = select_mech(minor_status,\n\t\t\t      &ni->mechTypes.val[j],\n\t\t\t      1,\n\t\t\t      &preferred_mech_type);\n\t    if (ret == 0)\n\t\tbreak;\n\t}\n    }\n\n    ctx->preferred_mech_type = preferred_mech_type;\n\n    if (preferred_mech_type == GSS_C_NO_OID) {\n        send_reject(minor_status, output_token);\n        HEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n        free_NegotiationToken(&nt);\n        return ret;\n    }\n\n    /*\n     * The initial token always have a response\n     */\n\n    ret = send_accept (minor_status,\n\t\t       ctx,\n\t\t       &mech_output_token,\n\t\t       1,\n\t\t       get_mic ? &mech_buf : NULL,\n\t\t       output_token);\n    if (ret)\n\tgoto out;\n\nout:\n    if (mech_output_token.value != NULL)\n\tgss_release_buffer(&junk, &mech_output_token);\n    if (mech_buf.value != NULL) {\n\tfree(mech_buf.value);\n\tmech_buf.value = NULL;\n    }\n    free_NegotiationToken(&nt);\n\n\n    if (ret == GSS_S_COMPLETE) {\n\tif (src_name != NULL && ctx->mech_src_name != NULL) {\n\t    spnego_name name;\n\n\t    name = calloc(1, sizeof(*name));\n\t    if (name) {\n\t\tname->mech = ctx->mech_src_name;\n\t\tctx->mech_src_name = NULL;\n\t\t*src_name = (gss_name_t)name;\n\t    }\n\t}\n    }\n\n    if (mech_type != NULL)\n\t*mech_type = ctx->negotiated_mech_type;\n    if (ret_flags != NULL)\n\t*ret_flags = ctx->mech_flags;\n    if (time_rec != NULL)\n\t*time_rec = ctx->mech_time_rec;\n\n    if (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n \treturn ret;\n    }\n\n    _gss_spnego_internal_delete_sec_context(&junk, context_handle,\n\t\t\t\t\t    GSS_C_NO_BUFFER);\n\n    return ret;\n}\n\n\nstatic OM_uint32 GSSAPI_CALLCONV\nacceptor_continue\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, ret2, minor;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenResp *na;\n    unsigned int negResult = accept_incomplete;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_t mech_output_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_buf;\n    gssspnego_ctx ctx;\n\n    mech_buf.value = NULL;\n\n    ctx = (gssspnego_ctx)*context_handle;\n\n    /*\n     * The GSS-API encapsulation is only present on the initial\n     * context token (negTokenInit).\n     */\n\n    ret = decode_NegotiationToken(input_token_buffer->value,\n\t\t\t\t  input_token_buffer->length,\n\t\t\t\t  &nt, &nt_len);\n    if (ret) {\n\t*minor_status = ret;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    if (nt.element != choice_NegotiationToken_negTokenResp) {\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    na = &nt.u.negTokenResp;\n\n    if (na->negResult != NULL) {\n\tnegResult = *(na->negResult);\n    }\n\n    HEIMDAL_MUTEX_lock(&ctx->ctx_id_mutex);\n\n    {\n\tgss_buffer_desc ibuf, obuf;\n\tint require_mic, get_mic = 0;\n\tint require_response;\n\theim_octet_string *mic;\n\n\tif (na->responseToken != NULL) {\n\t    ibuf.length = na->responseToken->length;\n\t    ibuf.value = na->responseToken->data;\n\t    mech_input_token = &ibuf;\n\t} else {\n\t    ibuf.value = NULL;\n\t    ibuf.length = 0;\n\t}\n\n\tif (mech_input_token != GSS_C_NO_BUFFER) {\n\n\t    if (ctx->mech_src_name != GSS_C_NO_NAME)\n\t\tgss_release_name(&minor, &ctx->mech_src_name);\n\n\t    ret = gss_accept_sec_context(&minor,\n\t\t\t\t\t &ctx->negotiated_ctx_id,\n\t\t\t\t\t acceptor_cred_handle,\n\t\t\t\t\t mech_input_token,\n\t\t\t\t\t input_chan_bindings,\n\t\t\t\t\t &ctx->mech_src_name,\n\t\t\t\t\t &ctx->negotiated_mech_type,\n\t\t\t\t\t &obuf,\n\t\t\t\t\t &ctx->mech_flags,\n\t\t\t\t\t &ctx->mech_time_rec,\n\t\t\t\t\t delegated_cred_handle);\n\n\t    if (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\t\tmech_output_token = &obuf;\n\t    }\n\t    if (ret != GSS_S_COMPLETE && ret != GSS_S_CONTINUE_NEEDED) {\n\t\tfree_NegotiationToken(&nt);\n\t\tgss_mg_collect_error(ctx->negotiated_mech_type, ret, minor);\n\t\tsend_reject (minor_status, output_token);\n\t\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\t\treturn ret;\n\t    }\n\t    if (ret == GSS_S_COMPLETE)\n\t\tctx->open = 1;\n\t} else\n\t    ret = GSS_S_COMPLETE;\n\n\tret2 = _gss_spnego_require_mechlist_mic(minor_status,\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\t&require_mic);\n\tif (ret2)\n\t    goto out;\n\n\tctx->require_mic = require_mic;\n\n\tmic = na->mechListMIC;\n\tif (mic != NULL)\n\t    require_mic = 1;\n\n\tif (ret == GSS_S_COMPLETE)\n\t    ret = acceptor_complete(minor_status,\n\t\t\t\t    ctx,\n\t\t\t\t    &get_mic,\n\t\t\t\t    &mech_buf,\n\t\t\t\t    mech_input_token,\n\t\t\t\t    mech_output_token,\n\t\t\t\t    na->mechListMIC,\n\t\t\t\t    output_token);\n\n\tif (ctx->mech_flags & GSS_C_DCE_STYLE)\n\t    require_response = (negResult != accept_completed);\n\telse\n\t    require_response = 0;\n\n\t/*\n\t * Check whether we need to send a result: there should be only\n\t * one accept_completed response sent in the entire negotiation\n\t */\n\tif ((mech_output_token != GSS_C_NO_BUFFER &&\n\t     mech_output_token->length != 0)\n\t    || (ctx->open && negResult == accept_incomplete)\n\t    || require_response\n\t    || get_mic) {\n\t    ret2 = send_accept (minor_status,\n\t\t\t\tctx,\n\t\t\t\tmech_output_token,\n\t\t\t\t0,\n\t\t\t\tget_mic ? &mech_buf : NULL,\n\t\t\t\toutput_token);\n\t    if (ret2)\n\t\tgoto out;\n\t}\n\n     out:\n\tif (ret2 != GSS_S_COMPLETE)\n\t    ret = ret2;\n\tif (mech_output_token != NULL)\n\t    gss_release_buffer(&minor, mech_output_token);\n\tif (mech_buf.value != NULL)\n\t    free(mech_buf.value);\n\tfree_NegotiationToken(&nt);\n    }\n\n    if (ret == GSS_S_COMPLETE) {\n\tif (src_name != NULL && ctx->mech_src_name != NULL) {\n\t    spnego_name name;\n\n\t    name = calloc(1, sizeof(*name));\n\t    if (name) {\n\t\tname->mech = ctx->mech_src_name;\n\t\tctx->mech_src_name = NULL;\n\t\t*src_name = (gss_name_t)name;\n\t    }\n\t}\n    }\n\n    if (mech_type != NULL)\n\t*mech_type = ctx->negotiated_mech_type;\n    if (ret_flags != NULL)\n\t*ret_flags = ctx->mech_flags;\n    if (time_rec != NULL)\n\t*time_rec = ctx->mech_time_rec;\n\n    if (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n \treturn ret;\n    }\n\n    _gss_spnego_internal_delete_sec_context(&minor, context_handle,\n\t\t\t\t   GSS_C_NO_BUFFER);\n\n    return ret;\n}\n\nOM_uint32 GSSAPI_CALLCONV\n_gss_spnego_accept_sec_context\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    _gss_accept_sec_context_t *func;\n\n    *minor_status = 0;\n\n    output_token->length = 0;\n    output_token->value  = NULL;\n\n    if (src_name != NULL)\n\t*src_name = GSS_C_NO_NAME;\n    if (mech_type != NULL)\n\t*mech_type = GSS_C_NO_OID;\n    if (ret_flags != NULL)\n\t*ret_flags = 0;\n    if (time_rec != NULL)\n\t*time_rec = 0;\n    if (delegated_cred_handle != NULL)\n\t*delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n\n\n    if (*context_handle == GSS_C_NO_CONTEXT)\n\tfunc = acceptor_start;\n    else\n\tfunc = acceptor_continue;\n\n\n    return (*func)(minor_status, context_handle, acceptor_cred_handle,\n\t\t   input_token_buffer, input_chan_bindings,\n\t\t   src_name, mech_type, output_token, ret_flags,\n\t\t   time_rec, delegated_cred_handle);\n}\n"], "filenames": ["lib/gssapi/spnego/accept_sec_context.c"], "buggy_code_start_loc": [622], "buggy_code_end_loc": [629], "fixing_code_start_loc": [622], "fixing_code_end_loc": [631], "type": "CWE-476", "message": "Heimdal before 7.7.1 allows attackers to cause a NULL pointer dereference in a SPNEGO acceptor via a preferred_mech_type of GSS_C_NO_OID and a nonzero initial_response value to send_accept.", "other": {"cve": {"id": "CVE-2021-44758", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-26T05:15:10.503", "lastModified": "2023-01-05T02:50:59.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heimdal before 7.7.1 allows attackers to cause a NULL pointer dereference in a SPNEGO acceptor via a preferred_mech_type of GSS_C_NO_OID and a nonzero initial_response value to send_accept."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:heimdal_project:heimdal:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.7.1", "matchCriteriaId": "537FE65E-6E3F-4441-8B35-7B48214EA04D"}]}]}], "references": [{"url": "https://github.com/heimdal/heimdal/commit/f9ec7002cdd526ae84fbacbf153162e118f22580", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/heimdal/heimdal/security/advisories/GHSA-69h9-669w-88xv", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/heimdal/heimdal/commit/f9ec7002cdd526ae84fbacbf153162e118f22580"}}