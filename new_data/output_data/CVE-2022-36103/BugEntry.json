{"buggy_code": ["// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage reg\n\nimport (\n\t\"context\"\n\n\t\"github.com/cosi-project/runtime/pkg/resource\"\n\t\"github.com/cosi-project/runtime/pkg/safe\"\n\t\"github.com/cosi-project/runtime/pkg/state\"\n\t\"github.com/siderolabs/crypto/x509\"\n\t\"google.golang.org/grpc\"\n\n\tsecurityapi \"github.com/talos-systems/talos/pkg/machinery/api/security\"\n\t\"github.com/talos-systems/talos/pkg/machinery/resources/secrets\"\n)\n\n// Registrator is the concrete type that implements the factory.Registrator and\n// securityapi.SecurityServiceServer interfaces.\ntype Registrator struct {\n\tsecurityapi.UnimplementedSecurityServiceServer\n\n\tResources state.State\n}\n\n// Register implements the factory.Registrator interface.\n//\n//nolint:interfacer\nfunc (r *Registrator) Register(s *grpc.Server) {\n\tsecurityapi.RegisterSecurityServiceServer(s, r)\n}\n\n// Certificate implements the securityapi.SecurityServer interface.\nfunc (r *Registrator) Certificate(ctx context.Context, in *securityapi.CertificateRequest) (resp *securityapi.CertificateResponse, err error) {\n\tosRoot, err := safe.StateGet[*secrets.OSRoot](ctx, r.Resources, resource.NewMetadata(secrets.NamespaceName, secrets.OSRootType, secrets.OSRootID, resource.VersionUndefined))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// TODO: Verify that the request is coming from the IP addresss declared in\n\t// the CSR.\n\tsigned, err := x509.NewCertificateFromCSRBytes(osRoot.TypedSpec().CA.Crt, osRoot.TypedSpec().CA.Key, in.Csr)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tresp = &securityapi.CertificateResponse{\n\t\tCa:  osRoot.TypedSpec().CA.Crt,\n\t\tCrt: signed.X509CertificatePEM,\n\t}\n\n\treturn resp, nil\n}\n", "// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage reg_test\n\nimport \"testing\"\n\nfunc TestEmpty(t *testing.T) {\n\t// added for accurate coverage estimation\n\t//\n\t// please remove it once any unit-test is added\n\t// for this package\n}\n"], "fixing_code": ["// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage reg\n\nimport (\n\t\"context\"\n\tstdx509 \"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/pem\"\n\t\"log\"\n\n\t\"github.com/cosi-project/runtime/pkg/resource\"\n\t\"github.com/cosi-project/runtime/pkg/safe\"\n\t\"github.com/cosi-project/runtime/pkg/state\"\n\t\"github.com/siderolabs/crypto/x509\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/peer\"\n\t\"google.golang.org/grpc/status\"\n\n\tsecurityapi \"github.com/talos-systems/talos/pkg/machinery/api/security\"\n\t\"github.com/talos-systems/talos/pkg/machinery/resources/secrets\"\n)\n\n// Registrator is the concrete type that implements the factory.Registrator and\n// securityapi.SecurityServiceServer interfaces.\ntype Registrator struct {\n\tsecurityapi.UnimplementedSecurityServiceServer\n\n\tResources state.State\n}\n\n// Register implements the factory.Registrator interface.\n//\n//nolint:interfacer\nfunc (r *Registrator) Register(s *grpc.Server) {\n\tsecurityapi.RegisterSecurityServiceServer(s, r)\n}\n\n// Certificate implements the securityapi.SecurityServer interface.\n//\n// This API is called by Talos worker nodes to request a server certificate for apid running on the node.\n// Control plane nodes generate certificates (client and server) directly from machine config PKI.\nfunc (r *Registrator) Certificate(ctx context.Context, in *securityapi.CertificateRequest) (resp *securityapi.CertificateResponse, err error) {\n\tremotePeer, ok := peer.FromContext(ctx)\n\tif !ok {\n\t\treturn nil, status.Error(codes.PermissionDenied, \"peer not found\")\n\t}\n\n\tosRoot, err := safe.StateGet[*secrets.OSRoot](ctx, r.Resources, resource.NewMetadata(secrets.NamespaceName, secrets.OSRootType, secrets.OSRootID, resource.VersionUndefined))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// decode and validate CSR\n\tcsrPemBlock, _ := pem.Decode(in.Csr)\n\tif csrPemBlock == nil {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"failed to decode CSR\")\n\t}\n\n\trequest, err := stdx509.ParseCertificateRequest(csrPemBlock.Bytes)\n\tif err != nil {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"failed to parse CSR: %s\", err)\n\t}\n\n\tlog.Printf(\"received CSR signing request from %s: subject %s dns names %s addresses %s\", remotePeer.Addr, request.Subject, request.DNSNames, request.IPAddresses)\n\n\t// allow only server auth certificates\n\tx509Opts := []x509.Option{\n\t\tx509.KeyUsage(stdx509.KeyUsageDigitalSignature),\n\t\tx509.ExtKeyUsage([]stdx509.ExtKeyUsage{stdx509.ExtKeyUsageServerAuth}),\n\t}\n\n\t// don't allow any certificates which can be used for client authentication\n\t//\n\t// we don't return an error here, as otherwise workers running old versions of Talos\n\t// will fail to provision client certificate and will never launch apid\n\t//\n\t// instead, the returned certificate will be rejected when being used\n\tif len(request.Subject.Organization) > 0 {\n\t\tlog.Printf(\"removing client auth organization from CSR: %s\", request.Subject.Organization)\n\n\t\tx509Opts = append(x509Opts, x509.OverrideSubject(func(subject *pkix.Name) {\n\t\t\tsubject.Organization = nil\n\t\t}))\n\t}\n\n\t// TODO: Verify that the request is coming from the IP address declared in\n\t// the CSR.\n\tsigned, err := x509.NewCertificateFromCSRBytes(\n\t\tosRoot.TypedSpec().CA.Crt,\n\t\tosRoot.TypedSpec().CA.Key,\n\t\tin.Csr,\n\t\tx509Opts...,\n\t)\n\tif err != nil {\n\t\treturn nil, status.Errorf(codes.Internal, \"failed to sign CSR: %s\", err)\n\t}\n\n\tresp = &securityapi.CertificateResponse{\n\t\tCa:  osRoot.TypedSpec().CA.Crt,\n\t\tCrt: signed.X509CertificatePEM,\n\t}\n\n\treturn resp, nil\n}\n", "// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage reg_test\n\nimport (\n\t\"context\"\n\tstdx509 \"crypto/x509\"\n\t\"net\"\n\t\"net/netip\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cosi-project/runtime/pkg/state\"\n\t\"github.com/cosi-project/runtime/pkg/state/impl/inmem\"\n\t\"github.com/cosi-project/runtime/pkg/state/impl/namespaced\"\n\t\"github.com/siderolabs/crypto/x509\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc/peer\"\n\n\t\"github.com/talos-systems/talos/internal/app/trustd/internal/reg\"\n\t\"github.com/talos-systems/talos/pkg/machinery/api/security\"\n\t\"github.com/talos-systems/talos/pkg/machinery/config/types/v1alpha1/generate\"\n\t\"github.com/talos-systems/talos/pkg/machinery/resources/secrets\"\n\t\"github.com/talos-systems/talos/pkg/machinery/role\"\n)\n\nfunc TestCertificate(t *testing.T) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tresources := state.WrapCore(namespaced.NewState(inmem.Build))\n\n\tca, err := generate.NewTalosCA(time.Now())\n\trequire.NoError(t, err)\n\n\tosRoot := secrets.NewOSRoot(secrets.OSRootID)\n\tosRoot.TypedSpec().CA = &x509.PEMEncodedCertificateAndKey{\n\t\tCrt: ca.CrtPEM,\n\t\tKey: ca.KeyPEM,\n\t}\n\trequire.NoError(t, resources.Create(ctx, osRoot))\n\n\tctx = peer.NewContext(ctx, &peer.Peer{\n\t\tAddr: &net.TCPAddr{\n\t\t\tIP:   netip.MustParseAddr(\"127.0.0.1\").AsSlice(),\n\t\t\tPort: 30000,\n\t\t},\n\t})\n\n\tr := &reg.Registrator{\n\t\tResources: resources,\n\t}\n\n\tfor _, tt := range []struct {\n\t\tname       string\n\t\tcsrSetters []x509.Option\n\t}{\n\t\t{\n\t\t\tname: \"server certificate\",\n\t\t\tcsrSetters: []x509.Option{\n\t\t\t\tx509.IPAddresses([]net.IP{netip.MustParseAddr(\"10.5.0.4\").AsSlice()}),\n\t\t\t\tx509.DNSNames([]string{\"talos-default-worker-1\"}),\n\t\t\t\tx509.CommonName(\"talos-default-worker-1\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"attempt at client certificate\",\n\t\t\tcsrSetters: []x509.Option{\n\t\t\t\tx509.CommonName(\"talos-default-worker-1\"),\n\t\t\t\tx509.Organization(string(role.Impersonator)),\n\t\t\t},\n\t\t},\n\t} {\n\t\ttt := tt\n\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tserverCSR, serverCert, err := x509.NewEd25519CSRAndIdentity(tt.csrSetters...)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tresp, err := r.Certificate(ctx, &security.CertificateRequest{\n\t\t\t\tCsr: serverCSR.X509CertificateRequestPEM,\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, resp.Ca, ca.CrtPEM)\n\n\t\t\tserverCert.Crt = resp.Crt\n\n\t\t\tcert, err := serverCert.GetCert()\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, stdx509.KeyUsageDigitalSignature, cert.KeyUsage)\n\t\t\tassert.Equal(t, []stdx509.ExtKeyUsage{stdx509.ExtKeyUsageServerAuth}, cert.ExtKeyUsage)\n\t\t\tassert.Equal(t, \"talos-default-worker-1\", cert.Subject.CommonName)\n\t\t\tassert.Equal(t, []string(nil), cert.Subject.Organization)\n\t\t})\n\t}\n}\n"], "filenames": ["internal/app/trustd/internal/reg/reg.go", "internal/app/trustd/internal/reg/reg_test.go"], "buggy_code_start_loc": [8, 7], "buggy_code_end_loc": [47, 14], "fixing_code_start_loc": [9, 7], "fixing_code_end_loc": [100, 101], "type": "CWE-732", "message": "Talos Linux is a Linux distribution built for Kubernetes deployments. Talos worker nodes use a join token to get accepted into the Talos cluster. Due to improper validation of the request while signing a worker node CSR (certificate signing request) Talos control plane node might issue Talos API certificate which allows full access to Talos API on a control plane node. Accessing Talos API with full level access on a control plane node might reveal sensitive information which allows full level access to the cluster (Kubernetes and Talos PKI, etc.). Talos API join token is stored in the machine configuration on the worker node. When configured correctly, Kubernetes workloads don't have access to the machine configuration, but due to a misconfiguration workload might access the machine configuration and reveal the join token. This problem has been fixed in Talos 1.2.2. Enabling the Pod Security Standards mitigates the vulnerability by denying hostPath mounts and host networking by default in the baseline policy. Clusters that don't run untrusted workloads are not affected. Clusters with correct Pod Security configurations which don't allow hostPath mounts, and secure access to cloud metadata server (or machine configuration is not supplied via cloud metadata server) are not affected.", "other": {"cve": {"id": "CVE-2022-36103", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-13T17:15:08.320", "lastModified": "2022-09-16T02:36:57.793", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Talos Linux is a Linux distribution built for Kubernetes deployments. Talos worker nodes use a join token to get accepted into the Talos cluster. Due to improper validation of the request while signing a worker node CSR (certificate signing request) Talos control plane node might issue Talos API certificate which allows full access to Talos API on a control plane node. Accessing Talos API with full level access on a control plane node might reveal sensitive information which allows full level access to the cluster (Kubernetes and Talos PKI, etc.). Talos API join token is stored in the machine configuration on the worker node. When configured correctly, Kubernetes workloads don't have access to the machine configuration, but due to a misconfiguration workload might access the machine configuration and reveal the join token. This problem has been fixed in Talos 1.2.2. Enabling the Pod Security Standards mitigates the vulnerability by denying hostPath mounts and host networking by default in the baseline policy. Clusters that don't run untrusted workloads are not affected. Clusters with correct Pod Security configurations which don't allow hostPath mounts, and secure access to cloud metadata server (or machine configuration is not supplied via cloud metadata server) are not affected."}, {"lang": "es", "value": "Talos Linux es una distribuci\u00f3n de Linux construida para los despliegues de Kubernetes. Los nodos trabajadores de Talos usan un token de uni\u00f3n para ser aceptados en el cl\u00faster de Talos. Debido a una comprobaci\u00f3n inapropiada de la petici\u00f3n mientras es firmado un CSR (solicitud de firma de certificado) de un nodo del plano de control de Talos, \u00e9ste podr\u00eda emitir un certificado de la API de Talos que permita el acceso completo a la API de Talos en un nodo del plano de control. El acceso a la API de Talos con acceso de nivel completo en un nodo del plano de control podr\u00eda revelar informaci\u00f3n confidencial que permite el acceso de nivel completo al cl\u00faster (Kubernetes y Talos PKI, etc.). El join token de la API Talos es almacenado en la configuraci\u00f3n de la m\u00e1quina en el nodo trabajador. Cuando es configurado correctamente, las cargas de trabajo de Kubernetes no presentan acceso a la configuraci\u00f3n de la m\u00e1quina, pero debido a una mala configuraci\u00f3n la carga de trabajo podr\u00eda acceder a la configuraci\u00f3n de la m\u00e1quina y revelar el token de uni\u00f3n. Este problema ha sido corregido en Talos versi\u00f3n 1.2.2. La habilitaci\u00f3n de las normas de seguridad de los pods mitiga la vulnerabilidad al denegar por defecto los montajes hostPath y las redes de host en la pol\u00edtica de l\u00ednea de base. Los clusters que no ejecutan cargas de trabajo no confiables no est\u00e1n afectados. Los clusters con configuraciones correctas de Pod Security que no permiten montajes hostPath, y acceso seguro al servidor de metadatos de la nube (o la configuraci\u00f3n de la m\u00e1quina no es suministrada por medio del servidor de metadatos de la nube) no est\u00e1n afectados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siderolabs:talos_linux:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.2", "matchCriteriaId": "9ADDE288-8867-4711-B46C-0D86BC9F2130"}]}]}], "references": [{"url": "https://github.com/siderolabs/talos/commit/9eaf33f3f274e746ca1b442c0a1a0dae0cec088f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/siderolabs/talos/releases/tag/v1.2.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/siderolabs/talos/security/advisories/GHSA-7hgc-php5-77qq", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/siderolabs/talos/commit/9eaf33f3f274e746ca1b442c0a1a0dae0cec088f"}}