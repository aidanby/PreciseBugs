{"buggy_code": ["/* -*- C++ -*-\n * File: libraw_datastream.cpp\n * Copyright 2008-2021 LibRaw LLC (info@libraw.org)\n *\n * LibRaw C++ interface (implementation)\n\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n*/\n\n#ifdef _WIN32\n#ifdef __MINGW32__\n#define _WIN32_WINNT 0x0500\n#include <stdexcept>\n#endif\n#endif\n\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"libraw/libraw_types.h\"\n#include \"libraw/libraw_datastream.h\"\n#include <sys/stat.h>\n#ifdef USE_JASPER\n#include <jasper/jasper.h> /* Decode RED camera movies */\n#else\n#define NO_JASPER\n#endif\n#ifdef USE_JPEG\n#include <jpeglib.h>\n#include <jerror.h>\n#else\n#define NO_JPEG\n#endif\n\n#ifdef USE_JPEG\n\ntypedef struct\n{\n    struct jpeg_source_mgr pub; /* public fields */\n    LibRaw_abstract_datastream *instream;            /* source stream */\n    JOCTET *buffer;             /* start of buffer */\n    boolean start_of_file;      /* have we gotten any data yet? */\n} lr_jpg_source_mgr;\n\ntypedef lr_jpg_source_mgr *lr_jpg_src_ptr;\n\n#define LR_JPEG_INPUT_BUF_SIZE 16384 \n\nstatic void f_init_source(j_decompress_ptr cinfo)\n{\n    lr_jpg_src_ptr src = (lr_jpg_src_ptr)cinfo->src;\n    src->start_of_file = TRUE;\n}\n\n#ifdef ERREXIT\n#undef ERREXIT\n#endif\n\n#define ERREXIT(cinfo, code)                                                   \\\n  ((cinfo)->err->msg_code = (code),                                            \\\n   (*(cinfo)->err->error_exit)((j_common_ptr)(cinfo)))\n\nstatic boolean lr_fill_input_buffer(j_decompress_ptr cinfo)\n{\n    lr_jpg_src_ptr src = (lr_jpg_src_ptr)cinfo->src;\n    size_t nbytes;\n\n    nbytes = src->instream->read((void*)src->buffer, 1, LR_JPEG_INPUT_BUF_SIZE);\n\n    if (nbytes <= 0)\n    {\n        if (src->start_of_file) /* Treat empty input file as fatal error */\n            ERREXIT(cinfo, JERR_INPUT_EMPTY);\n        WARNMS(cinfo, JWRN_JPEG_EOF);\n        /* Insert a fake EOI marker */\n        src->buffer[0] = (JOCTET)0xFF;\n        src->buffer[1] = (JOCTET)JPEG_EOI;\n        nbytes = 2;\n    }\n\n    src->pub.next_input_byte = src->buffer;\n    src->pub.bytes_in_buffer = nbytes;\n    src->start_of_file = FALSE;\n    return TRUE;\n}\n\nstatic void lr_skip_input_data(j_decompress_ptr cinfo, long num_bytes)\n{\n    struct jpeg_source_mgr *src = cinfo->src;\n    if (num_bytes > 0)\n    {\n        while (num_bytes > (long)src->bytes_in_buffer)\n        {\n            num_bytes -= (long)src->bytes_in_buffer;\n            (void)(*src->fill_input_buffer)(cinfo);\n            /* note we assume that fill_input_buffer will never return FALSE,\n             * so suspension need not be handled.\n             */\n        }\n        src->next_input_byte += (size_t)num_bytes;\n        src->bytes_in_buffer -= (size_t)num_bytes;\n    }\n}\n\nstatic void lr_term_source(j_decompress_ptr cinfo) {}\n\nstatic void lr_jpeg_src(j_decompress_ptr cinfo, LibRaw_abstract_datastream *inf)\n{\n    lr_jpg_src_ptr src;\n    if (cinfo->src == NULL)\n    { /* first time for this JPEG object? */\n        cinfo->src = (struct jpeg_source_mgr *)(*cinfo->mem->alloc_small)(\n            (j_common_ptr)cinfo, JPOOL_PERMANENT, sizeof(lr_jpg_source_mgr));\n        src = (lr_jpg_src_ptr)cinfo->src;\n        src->buffer = (JOCTET *)(*cinfo->mem->alloc_small)(\n            (j_common_ptr)cinfo, JPOOL_PERMANENT,\n            LR_JPEG_INPUT_BUF_SIZE * sizeof(JOCTET));\n    }\n    else if (cinfo->src->init_source != f_init_source)\n    {\n        ERREXIT(cinfo, JERR_BUFFER_SIZE);\n    }\n\n    src = (lr_jpg_src_ptr)cinfo->src;\n    src->pub.init_source = f_init_source;\n    src->pub.fill_input_buffer = lr_fill_input_buffer;\n    src->pub.skip_input_data = lr_skip_input_data;\n    src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */\n    src->pub.term_source = lr_term_source;\n    src->instream = inf;\n    src->pub.bytes_in_buffer = 0;    /* forces fill_input_buffer on first read */\n    src->pub.next_input_byte = NULL; /* until buffer loaded */\n}\n#endif\n\nint LibRaw_abstract_datastream::jpeg_src(void *jpegdata)\n{\n#ifdef NO_JPEG\n    return -1;\n#else\n    j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;\n    buffering_off();\n    lr_jpeg_src(cinfo, this);\n    return 0; // OK\n#endif\n}\n\n\n#ifndef LIBRAW_NO_IOSTREAMS_DATASTREAM\n// == LibRaw_file_datastream ==\n\nLibRaw_file_datastream::~LibRaw_file_datastream()\n{\n  if (jas_file)\n    fclose(jas_file);\n}\n\nLibRaw_file_datastream::LibRaw_file_datastream(const char *fname)\n    : filename(fname), _fsize(0)\n#ifdef LIBRAW_WIN32_UNICODEPATHS\n      ,\n      wfilename()\n#endif\n      ,\n      jas_file(NULL)\n{\n  if (filename.size() > 0)\n  {\n#ifndef LIBRAW_WIN32_CALLS\n    struct stat st;\n    if (!stat(filename.c_str(), &st))\n      _fsize = st.st_size;\n#else\n    struct _stati64 st;\n    if (!_stati64(filename.c_str(), &st))\n      _fsize = st.st_size;\n#endif\n#ifdef LIBRAW_USE_AUTOPTR\n    std::auto_ptr<std::filebuf> buf(new std::filebuf());\n#else\n    std::unique_ptr<std::filebuf> buf(new std::filebuf());\n#endif\n    buf->open(filename.c_str(), std::ios_base::in | std::ios_base::binary);\n    if (buf->is_open())\n    {\n#ifdef LIBRAW_USE_AUTOPTR\n      f = buf;\n#else\n      f = std::move(buf);\n#endif\n    }\n  }\n}\n#ifdef LIBRAW_WIN32_UNICODEPATHS\nLibRaw_file_datastream::LibRaw_file_datastream(const wchar_t *fname)\n    : filename(), wfilename(fname), jas_file(NULL), _fsize(0)\n{\n  if (wfilename.size() > 0)\n  {\n    struct _stati64 st;\n    if (!_wstati64(wfilename.c_str(), &st))\n      _fsize = st.st_size;\n#ifdef LIBRAW_USE_AUTOPTR\n    std::auto_ptr<std::filebuf> buf(new std::filebuf());\n#else\n    std::unique_ptr<std::filebuf> buf(new std::filebuf());\n#endif\n    buf->open(wfilename.c_str(), std::ios_base::in | std::ios_base::binary);\n    if (buf->is_open())\n    {\n#ifdef LIBRAW_USE_AUTOPTR\n      f = buf;\n#else\n      f = std::move(buf);\n#endif\n\t}\n  }\n}\nconst wchar_t *LibRaw_file_datastream::wfname()\n{\n  return wfilename.size() > 0 ? wfilename.c_str() : NULL;\n}\n#endif\n\nint LibRaw_file_datastream::valid() { return f.get() ? 1 : 0; }\n\n#define LR_STREAM_CHK()                                                        \\\n  do                                                                           \\\n  {                                                                            \\\n    if (!f.get())                                                              \\\n      throw LIBRAW_EXCEPTION_IO_EOF;                                           \\\n  } while (0)\n\nint LibRaw_file_datastream::read(void *ptr, size_t size, size_t nmemb)\n{\n/* Visual Studio 2008 marks sgetn as insecure, but VS2010 does not. */\n#if defined(WIN32SECURECALLS) && (_MSC_VER < 1600)\n  LR_STREAM_CHK();\n  return int(f->_Sgetn_s(static_cast<char *>(ptr), nmemb * size, nmemb * size) /\n             (size > 0 ? size : 1));\n#else\n  LR_STREAM_CHK();\n  return int(f->sgetn(static_cast<char *>(ptr), std::streamsize(nmemb * size)) /\n             (size > 0 ? size : 1));\n#endif\n}\n\nint LibRaw_file_datastream::eof()\n{\n  LR_STREAM_CHK();\n  return f->sgetc() == EOF;\n}\n\nint LibRaw_file_datastream::seek(INT64 o, int whence)\n{\n  LR_STREAM_CHK();\n  std::ios_base::seekdir dir;\n  switch (whence)\n  {\n  case SEEK_SET:\n    dir = std::ios_base::beg;\n    break;\n  case SEEK_CUR:\n    dir = std::ios_base::cur;\n    break;\n  case SEEK_END:\n    dir = std::ios_base::end;\n    break;\n  default:\n    dir = std::ios_base::beg;\n  }\n  return f->pubseekoff((long)o, dir) < 0;\n}\n\nINT64 LibRaw_file_datastream::tell()\n{\n  LR_STREAM_CHK();\n  return f->pubseekoff(0, std::ios_base::cur);\n}\n\nchar *LibRaw_file_datastream::gets(char *str, int sz)\n{\n  LR_STREAM_CHK();\n  std::istream is(f.get());\n  is.getline(str, sz);\n  if (is.fail())\n    return 0;\n  return str;\n}\n\nint LibRaw_file_datastream::scanf_one(const char *fmt, void *val)\n{\n  LR_STREAM_CHK();\n\n  std::istream is(f.get());\n\n  /* HUGE ASSUMPTION: *fmt is either \"%d\" or \"%f\" */\n  if (strcmp(fmt, \"%d\") == 0)\n  {\n    int d;\n    is >> d;\n    if (is.fail())\n      return EOF;\n    *(static_cast<int *>(val)) = d;\n  }\n  else\n  {\n    float f;\n    is >> f;\n    if (is.fail())\n      return EOF;\n    *(static_cast<float *>(val)) = f;\n  }\n\n  return 1;\n}\n\nconst char *LibRaw_file_datastream::fname()\n{\n  return filename.size() > 0 ? filename.c_str() : NULL;\n}\n\n#undef LR_STREAM_CHK\n\n#ifdef LIBRAW_OLD_VIDEO_SUPPORT\nvoid *LibRaw_file_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n  return NULL;\n#else\n#ifdef LIBRAW_WIN32_UNICODEPATHS\n  if (wfname())\n  {\n    jas_file = _wfopen(wfname(), L\"rb\");\n    return jas_stream_fdopen(fileno(jas_file), \"rb\");\n  }\n  else\n#endif\n  {\n    return jas_stream_fopen(fname(), \"rb\");\n  }\n#endif\n}\n#endif\n#endif\n\n// == LibRaw_buffer_datastream\nLibRaw_buffer_datastream::LibRaw_buffer_datastream(const void *buffer, size_t bsize)\n{\n  buf = (unsigned char *)buffer;\n  streampos = 0;\n  streamsize = bsize;\n}\n\nLibRaw_buffer_datastream::~LibRaw_buffer_datastream() {}\n\nint LibRaw_buffer_datastream::read(void *ptr, size_t sz, size_t nmemb)\n{\n  size_t to_read = sz * nmemb;\n  if (to_read > streamsize - streampos)\n    to_read = streamsize - streampos;\n  if (to_read < 1)\n    return 0;\n  memmove(ptr, buf + streampos, to_read);\n  streampos += to_read;\n  return int((to_read + sz - 1) / (sz > 0 ? sz : 1));\n}\n\nint LibRaw_buffer_datastream::seek(INT64 o, int whence)\n{\n  switch (whence)\n  {\n  case SEEK_SET:\n    if (o < 0)\n      streampos = 0;\n    else if (size_t(o) > streamsize)\n      streampos = streamsize;\n    else\n      streampos = size_t(o);\n    return 0;\n  case SEEK_CUR:\n    if (o < 0)\n    {\n      if (size_t(-o) >= streampos)\n        streampos = 0;\n      else\n        streampos += (size_t)o;\n    }\n    else if (o > 0)\n    {\n      if (o + streampos > streamsize)\n        streampos = streamsize;\n      else\n        streampos += (size_t)o;\n    }\n    return 0;\n  case SEEK_END:\n    if (o > 0)\n      streampos = streamsize;\n    else if (size_t(-o) > streamsize)\n      streampos = 0;\n    else\n      streampos = streamsize + (size_t)o;\n    return 0;\n  default:\n    return 0;\n  }\n}\n\nINT64 LibRaw_buffer_datastream::tell()\n{\n  return INT64(streampos);\n}\n\nchar *LibRaw_buffer_datastream::gets(char *s, int sz)\n{\n  unsigned char *psrc, *pdest, *str;\n  str = (unsigned char *)s;\n  psrc = buf + streampos;\n  pdest = str;\n  if(streampos >= streamsize) return NULL;\n  while ((size_t(psrc - buf) < streamsize) && ((pdest - str) < (sz-1)))\n  {\n    *pdest = *psrc;\n    if (*psrc == '\\n')\n      break;\n    psrc++;\n    pdest++;\n  }\n  if (size_t(psrc - buf) < streamsize)\n    psrc++;\n  if ((pdest - str) < sz-1)\n    *(++pdest) = 0;\n  else\n    s[sz - 1] = 0; // ensure trailing zero\n\n  streampos = psrc - buf;\n  return s;\n}\n\nint LibRaw_buffer_datastream::scanf_one(const char *fmt, void *val)\n{\n  int scanf_res;\n  if (streampos > streamsize)\n    return 0;\n#ifndef WIN32SECURECALLS\n  scanf_res = sscanf((char *)(buf + streampos), fmt, val);\n#else\n  scanf_res = sscanf_s((char *)(buf + streampos), fmt, val);\n#endif\n  if (scanf_res > 0)\n  {\n    int xcnt = 0;\n    while (streampos < streamsize)\n    {\n      streampos++;\n      xcnt++;\n      if (buf[streampos] == 0 || buf[streampos] == ' ' ||\n          buf[streampos] == '\\t' || buf[streampos] == '\\n' || xcnt > 24)\n        break;\n    }\n  }\n  return scanf_res;\n}\n\nint LibRaw_buffer_datastream::eof()\n{\n  return streampos >= streamsize;\n}\nint LibRaw_buffer_datastream::valid() { return buf ? 1 : 0; }\n\n#ifdef LIBRAW_OLD_VIDEO_SUPPORT\nvoid *LibRaw_buffer_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n  return NULL;\n#else\n  return jas_stream_memopen((char *)buf + streampos, streamsize - streampos);\n#endif\n}\n#endif\n\nint LibRaw_buffer_datastream::jpeg_src(void *jpegdata)\n{\n#if defined(NO_JPEG) || !defined(USE_JPEG)\n  return -1;\n#else\n  j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;\n  jpeg_mem_src(cinfo, (unsigned char *)buf + streampos, streamsize - streampos);\n  return 0;\n#endif\n}\n\n// int LibRaw_buffer_datastream\n\n// == LibRaw_bigfile_datastream\nLibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const char *fname)\n    : filename(fname)\n#ifdef LIBRAW_WIN32_UNICODEPATHS\n      ,\n      wfilename()\n#endif\n{\n  if (filename.size() > 0)\n  {\n#ifndef LIBRAW_WIN32_CALLS\n    struct stat st;\n    if (!stat(filename.c_str(), &st))\n      _fsize = st.st_size;\n#else\n    struct _stati64 st;\n    if (!_stati64(filename.c_str(), &st))\n      _fsize = st.st_size;\n#endif\n\n#ifndef WIN32SECURECALLS\n    f = fopen(fname, \"rb\");\n#else\n    if (fopen_s(&f, fname, \"rb\"))\n      f = 0;\n#endif\n  }\n  else\n  {\n    filename = std::string();\n    f = 0;\n  }\n}\n\n#ifdef LIBRAW_WIN32_UNICODEPATHS\nLibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const wchar_t *fname)\n    : filename(), wfilename(fname)\n{\n  if (wfilename.size() > 0)\n  {\n    struct _stati64 st;\n    if (!_wstati64(wfilename.c_str(), &st))\n      _fsize = st.st_size;\n#ifndef WIN32SECURECALLS\n    f = _wfopen(wfilename.c_str(), L\"rb\");\n#else\n    if (_wfopen_s(&f, fname, L\"rb\"))\n      f = 0;\n#endif\n  }\n  else\n  {\n    wfilename = std::wstring();\n    f = 0;\n  }\n}\nconst wchar_t *LibRaw_bigfile_datastream::wfname()\n{\n  return wfilename.size() > 0 ? wfilename.c_str() : NULL;\n}\n#endif\n\nLibRaw_bigfile_datastream::~LibRaw_bigfile_datastream()\n{\n  if (f)\n    fclose(f);\n}\nint LibRaw_bigfile_datastream::valid() { return f ? 1 : 0; }\n\n#define LR_BF_CHK()                                                            \\\n  do                                                                           \\\n  {                                                                            \\\n    if (!f)                                                                    \\\n      throw LIBRAW_EXCEPTION_IO_EOF;                                           \\\n  } while (0)\n\nint LibRaw_bigfile_datastream::read(void *ptr, size_t size, size_t nmemb)\n{\n  LR_BF_CHK();\n  return int(fread(ptr, size, nmemb, f));\n}\n\nint LibRaw_bigfile_datastream::eof()\n{\n  LR_BF_CHK();\n  return feof(f);\n}\n\nint LibRaw_bigfile_datastream::seek(INT64 o, int whence)\n{\n  LR_BF_CHK();\n#if defined(_WIN32)\n#ifdef WIN32SECURECALLS\n  return _fseeki64(f, o, whence);\n#else\n  return fseek(f, (long)o, whence);\n#endif\n#else\n  return fseeko(f, o, whence);\n#endif\n}\n\nINT64 LibRaw_bigfile_datastream::tell()\n{\n  LR_BF_CHK();\n#if defined(_WIN32)\n#ifdef WIN32SECURECALLS\n  return _ftelli64(f);\n#else\n  return ftell(f);\n#endif\n#else\n  return ftello(f);\n#endif\n}\n\nchar *LibRaw_bigfile_datastream::gets(char *str, int sz)\n{\n  LR_BF_CHK();\n  return fgets(str, sz, f);\n}\n\nint LibRaw_bigfile_datastream::scanf_one(const char *fmt, void *val)\n{\n  LR_BF_CHK();\n  return \n#ifndef WIN32SECURECALLS\n                   fscanf(f, fmt, val)\n#else\n                   fscanf_s(f, fmt, val)\n#endif\n      ;\n}\n\nconst char *LibRaw_bigfile_datastream::fname()\n{\n  return filename.size() > 0 ? filename.c_str() : NULL;\n}\n\n#ifdef LIBRAW_OLD_VIDEO_SUPPORT\nvoid *LibRaw_bigfile_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n  return NULL;\n#else\n  return jas_stream_fdopen(fileno(f), \"rb\");\n#endif\n}\n#endif\n\n// == LibRaw_windows_datastream\n#ifdef LIBRAW_WIN32_CALLS\n\nLibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR *sFile)\n    : LibRaw_buffer_datastream(NULL, 0), hMap_(0), pView_(NULL)\n{\n#if defined(WINAPI_FAMILY) && defined(WINAPI_FAMILY_APP) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)\n    HANDLE hFile = CreateFile2(sFile, GENERIC_READ, 0, OPEN_EXISTING, 0);\n#else\n  HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING,\n                            FILE_ATTRIBUTE_NORMAL, 0);\n#endif\n  if (hFile == INVALID_HANDLE_VALUE)\n    throw std::runtime_error(\"failed to open the file\");\n\n  try\n  {\n    Open(hFile);\n  }\n  catch (...)\n  {\n    CloseHandle(hFile);\n    throw;\n  }\n\n  CloseHandle(hFile); // windows will defer the actual closing of this handle\n                      // until the hMap_ is closed\n  reconstruct_base();\n}\n\n// ctor: construct with a file handle - caller is responsible for closing the\n// file handle\nLibRaw_windows_datastream::LibRaw_windows_datastream(HANDLE hFile)\n    : LibRaw_buffer_datastream(NULL, 0), hMap_(0), pView_(NULL)\n{\n  Open(hFile);\n  reconstruct_base();\n}\n\n// dtor: unmap and close the mapping handle\nLibRaw_windows_datastream::~LibRaw_windows_datastream()\n{\n  if (pView_ != NULL)\n    ::UnmapViewOfFile(pView_);\n\n  if (hMap_ != 0)\n    ::CloseHandle(hMap_);\n}\n\nvoid LibRaw_windows_datastream::Open(HANDLE hFile)\n{\n  // create a file mapping handle on the file handle\n  hMap_ = ::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);\n  if (hMap_ == NULL)\n    throw std::runtime_error(\"failed to create file mapping\");\n\n  // now map the whole file base view\n  if (!::GetFileSizeEx(hFile, (PLARGE_INTEGER)&cbView_))\n    throw std::runtime_error(\"failed to get the file size\");\n\n  pView_ = ::MapViewOfFile(hMap_, FILE_MAP_READ, 0, 0, (size_t)cbView_);\n  if (pView_ == NULL)\n    throw std::runtime_error(\"failed to map the file\");\n}\n\n#endif\n\n#if defined (LIBRAW_NO_IOSTREAMS_DATASTREAM)  && defined (LIBRAW_WIN32_CALLS)\n\n/* LibRaw_bigfile_buffered_datastream: copypasted from LibRaw_bigfile_datastream + extra cache on read */\n\n#undef LR_BF_CHK\n#define LR_BF_CHK()                                                    \\\n  do                                                                    \\\n  {                                                                     \\\n     if (fhandle ==0 || fhandle == INVALID_HANDLE_VALUE)                \\\n         throw LIBRAW_EXCEPTION_IO_EOF;                                 \\\n  } while (0)\n\n#define LIBRAW_BUFFER_ALIGN 4096\n\nint LibRaw_bufio_params::bufsize = 16384;\n\nvoid LibRaw_bufio_params::set_bufsize(int bs)\n{\n    if (bs > 0)\n        bufsize = bs;\n}\n\n\nLibRaw_bigfile_buffered_datastream::LibRaw_bigfile_buffered_datastream(const char *fname)\n    : filename(fname), _fsize(0), _fpos(0)\n#ifdef LIBRAW_WIN32_UNICODEPATHS\n    , wfilename()\n#endif\n    , iobuffers(), buffered(1)\n{\n    if (filename.size() > 0)\n    {\n        std::string fn(fname);\n        std::wstring fpath(fn.begin(), fn.end());\n#if defined(WINAPI_FAMILY) && defined(WINAPI_FAMILY_APP) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)\n        if ((fhandle = CreateFile2(fpath.c_str(), GENERIC_READ, 0, OPEN_EXISTING, 0)) != INVALID_HANDLE_VALUE)\n#else\n        if ((fhandle = CreateFileW(fpath.c_str(), GENERIC_READ, FILE_SHARE_READ, 0,\n            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)) != INVALID_HANDLE_VALUE)\n#endif\n        {\n            LARGE_INTEGER fs;\n            if (GetFileSizeEx(fhandle, &fs))\n                _fsize = fs.QuadPart;\n        }\n    }\n    else\n    {\n        filename = std::string();\n        fhandle = INVALID_HANDLE_VALUE;\n    }\n}\n\n#ifdef LIBRAW_WIN32_UNICODEPATHS\nLibRaw_bigfile_buffered_datastream::LibRaw_bigfile_buffered_datastream(const wchar_t *fname)\n    : filename(), _fsize(0), _fpos(0),\n    wfilename(fname), iobuffers(), buffered(1)\n{\n    if (wfilename.size() > 0)\n    {\n#if defined(WINAPI_FAMILY) && defined(WINAPI_FAMILY_APP) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)\n        if ((fhandle = CreateFile2(wfilename.c_str(), GENERIC_READ, 0, OPEN_EXISTING, 0)) != INVALID_HANDLE_VALUE)\n#else\n        if ((fhandle = CreateFileW(wfilename.c_str(), GENERIC_READ, FILE_SHARE_READ, 0,\n            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)) != INVALID_HANDLE_VALUE)\n#endif\n        {\n            if (fhandle > 0)\n            {\n                LARGE_INTEGER fs;\n                if (GetFileSizeEx(fhandle, &fs))\n                    _fsize = fs.QuadPart;\n            }\n        }\n\n    }\n    else\n    {\n        wfilename = std::wstring();\n        fhandle = INVALID_HANDLE_VALUE;\n    }\n}\n\nconst wchar_t *LibRaw_bigfile_buffered_datastream::wfname()\n{\n    return wfilename.size() > 0 ? wfilename.c_str() : NULL;\n}\n#endif\n\nLibRaw_bigfile_buffered_datastream::~LibRaw_bigfile_buffered_datastream()\n{\n    if (fhandle > 0)\n        CloseHandle(fhandle);\n}\nint LibRaw_bigfile_buffered_datastream::valid() {\n    return fhandle > 0 && fhandle != INVALID_HANDLE_VALUE;\n}\n\nconst char *LibRaw_bigfile_buffered_datastream::fname()\n{\n    return filename.size() > 0 ? filename.c_str() : NULL;\n}\n\n#ifdef LIBRAW_OLD_VIDEO_SUPPORT\nvoid *LibRaw_bigfile_buffered_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n    return NULL;\n#else\n    return NULL;\n#endif\n}\n#endif\n\nINT64 LibRaw_bigfile_buffered_datastream::readAt(void *ptr, size_t size, INT64 off)\n{\n    LR_BF_CHK();\n    DWORD NumberOfBytesRead;\n    DWORD nNumberOfBytesToRead = size;\n    struct _OVERLAPPED olap;\n    memset(&olap, 0, sizeof(olap));\n    olap.Offset = off & 0xffffffff;\n    olap.OffsetHigh = off >> 32;\n    if (ReadFile(fhandle, ptr, nNumberOfBytesToRead, &NumberOfBytesRead, &olap))\n        return NumberOfBytesRead;\n    else\n        return 0;\n}\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\n#ifdef _MSC_VER\n#pragma intrinsic(memcpy)\n#endif\n\nint LibRaw_bigfile_buffered_datastream::read(void *data, size_t size, size_t nmemb)\n{\n    if (size < 1 || nmemb < 1)\n        return 0;\n    LR_BF_CHK();\n    INT64 count = size * nmemb;\n    INT64 partbytes = 0;\n    if (!buffered)\n    {\n        INT64 r = readAt(data, count, _fpos);\n        _fpos += r;\n        return r / size;\n    }\n\n    unsigned char *fBuffer = (unsigned char*)iobuffers[0].data();\n    while (count)\n    {\n        INT64 inbuffer = 0;\n        // See if the request is totally inside buffer.\n        if (iobuffers[0].contains(_fpos, inbuffer))\n        {\n            if (inbuffer >= count)\n            {\n                memcpy(data, fBuffer + (unsigned)(_fpos - iobuffers[0]._bstart), count);\n                _fpos += count;\n                return (count + partbytes) / size;\n            }\n            memcpy(data, fBuffer + (_fpos - iobuffers[0]._bstart), inbuffer);\n            partbytes += inbuffer;\n            count -= inbuffer;\n            data = (void *)(((char *)data) + inbuffer);\n            _fpos += inbuffer;\n        }\n        if (count > iobuffers[0].size())\n        {\n        fallback:\n            if (_fpos + count > _fsize)\n                count = MAX(0, _fsize - _fpos);\n            if (count > 0)\n            {\n                INT64 r = readAt(data, count, _fpos);\n                _fpos += r;\n                return (r + partbytes) / size;\n            }\n            else\n                return 0;\n        }\n\n        if (!fillBufferAt(0, _fpos))\n            goto fallback;\n    }\n    return 0;\n}\n\nbool LibRaw_bigfile_buffered_datastream::fillBufferAt(int bi, INT64 off)\n{\n    iobuffers[bi]._bstart = off;\n    if (iobuffers[bi].size() >= LIBRAW_BUFFER_ALIGN * 2)// Align to a file block.\n        iobuffers[bi]._bstart &= (INT64)~((INT64)(LIBRAW_BUFFER_ALIGN - 1));\n\n    iobuffers[bi]._bend = MIN(iobuffers[bi]._bstart + iobuffers[bi].size(), _fsize);\n    if (iobuffers[bi]._bend <= off) // Buffer alignment problem, fallback\n        return false;\n    INT64 rr = readAt(iobuffers[bi].data(), (uint32_t)(iobuffers[bi]._bend - iobuffers[bi]._bstart), iobuffers[bi]._bstart);\n    if (rr > 0)\n    {\n        iobuffers[bi]._bend = iobuffers[bi]._bstart + rr;\n        return true;\n    }\n    return false;\n}\n\n\nint LibRaw_bigfile_buffered_datastream::eof()\n{\n    LR_BF_CHK();\n    return _fpos >= _fsize;\n}\n\nint LibRaw_bigfile_buffered_datastream::seek(INT64 o, int whence)\n{\n    LR_BF_CHK();\n    if (whence == SEEK_SET) _fpos = o;\n    else if (whence == SEEK_END) _fpos = o > 0 ? _fsize : _fsize + o;\n    else if (whence == SEEK_CUR) _fpos += o;\n\n    return 0;\n}\n\nINT64 LibRaw_bigfile_buffered_datastream::tell()\n{\n    LR_BF_CHK();\n    return _fpos;\n}\n\nchar *LibRaw_bigfile_buffered_datastream::gets(char *s, int sz)\n{\n    if (sz < 1)\n        return NULL;\n    else if (sz < 2)\n    {\n        s[0] = 0;\n        return s;\n    }\n\n    LR_BF_CHK();\n    INT64 contains;\n    int bufindex = selectStringBuffer(sz, contains);\n    if (bufindex < 0) return NULL;\n    if (contains >= sz)\n    {\n        unsigned char *buf = iobuffers[bufindex].data() + (_fpos - iobuffers[bufindex]._bstart);\n        int streampos = 0;\n        int streamsize = contains;\n        unsigned char *str = (unsigned char *)s;\n        unsigned char *psrc, *pdest;\n        psrc = buf + streampos;\n        pdest = str;\n\n        while ((size_t(psrc - buf) < streamsize) && ((pdest - str) < sz-1)) // sz-1: to append \\0\n        {\n            *pdest = *psrc;\n            if (*psrc == '\\n')\n                break;\n            psrc++;\n            pdest++;\n        }\n        if (size_t(psrc - buf) < streamsize)\n            psrc++;\n        if ((pdest - str) < sz - 1)\n            *(++pdest) = 0;\n        else\n            s[sz - 1] = 0; // ensure trailing zero\n        streampos = psrc - buf;\n        _fpos += streampos;\n        return s;\n    }\n    return NULL;\n}\n\nint LibRaw_bigfile_buffered_datastream::selectStringBuffer(INT64 len, INT64& contains)\n{\n    if (iobuffers[0].contains(_fpos, contains) && contains >= len)\n        return 0;\n\n    if (iobuffers[1].contains(_fpos, contains) && contains >= len)\n        return 1;\n\n    fillBufferAt(1, _fpos);\n    if (iobuffers[1].contains(_fpos, contains) && contains >= len)\n        return 1;\n    return -1;\n}\n\nint LibRaw_bigfile_buffered_datastream::scanf_one(const char *fmt, void *val)\n{\n    LR_BF_CHK();\n    INT64 contains = 0;\n    int bufindex = selectStringBuffer(24, contains);\n    if (bufindex < 0) return -1;\n    if (contains >= 24)\n    {\n        unsigned char *bstart = iobuffers[bufindex].data() + (_fpos - iobuffers[bufindex]._bstart);\n        int streampos = 0;\n        int streamsize = contains;\n        int\n#ifndef WIN32SECURECALLS\n            scanf_res = sscanf((char *)(bstart), fmt, val);\n#else\n            scanf_res = sscanf_s((char *)(bstart), fmt, val);\n#endif\n        if (scanf_res > 0)\n        {\n            int xcnt = 0;\n            while (streampos < streamsize)\n            {\n                streampos++;\n                xcnt++;\n                if (bstart[streampos] == 0 || bstart[streampos] == ' ' ||\n                    bstart[streampos] == '\\t' || bstart[streampos] == '\\n' || xcnt > 24)\n                    break;\n            }\n            _fpos += streampos;\n            return scanf_res;\n        }\n    }\n    return -1;\n}\n\n#endif\n\n"], "fixing_code": ["/* -*- C++ -*-\n * File: libraw_datastream.cpp\n * Copyright 2008-2021 LibRaw LLC (info@libraw.org)\n *\n * LibRaw C++ interface (implementation)\n\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n*/\n\n#ifdef _WIN32\n#ifdef __MINGW32__\n#define _WIN32_WINNT 0x0500\n#include <stdexcept>\n#endif\n#endif\n\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"libraw/libraw_types.h\"\n#include \"libraw/libraw_datastream.h\"\n#include <sys/stat.h>\n#ifdef USE_JASPER\n#include <jasper/jasper.h> /* Decode RED camera movies */\n#else\n#define NO_JASPER\n#endif\n#ifdef USE_JPEG\n#include <jpeglib.h>\n#include <jerror.h>\n#else\n#define NO_JPEG\n#endif\n\n#ifdef USE_JPEG\n\ntypedef struct\n{\n    struct jpeg_source_mgr pub; /* public fields */\n    LibRaw_abstract_datastream *instream;            /* source stream */\n    JOCTET *buffer;             /* start of buffer */\n    boolean start_of_file;      /* have we gotten any data yet? */\n} lr_jpg_source_mgr;\n\ntypedef lr_jpg_source_mgr *lr_jpg_src_ptr;\n\n#define LR_JPEG_INPUT_BUF_SIZE 16384 \n\nstatic void f_init_source(j_decompress_ptr cinfo)\n{\n    lr_jpg_src_ptr src = (lr_jpg_src_ptr)cinfo->src;\n    src->start_of_file = TRUE;\n}\n\n#ifdef ERREXIT\n#undef ERREXIT\n#endif\n\n#define ERREXIT(cinfo, code)                                                   \\\n  ((cinfo)->err->msg_code = (code),                                            \\\n   (*(cinfo)->err->error_exit)((j_common_ptr)(cinfo)))\n\nstatic boolean lr_fill_input_buffer(j_decompress_ptr cinfo)\n{\n    lr_jpg_src_ptr src = (lr_jpg_src_ptr)cinfo->src;\n    size_t nbytes;\n\n    nbytes = src->instream->read((void*)src->buffer, 1, LR_JPEG_INPUT_BUF_SIZE);\n\n    if (nbytes <= 0)\n    {\n        if (src->start_of_file) /* Treat empty input file as fatal error */\n            ERREXIT(cinfo, JERR_INPUT_EMPTY);\n        WARNMS(cinfo, JWRN_JPEG_EOF);\n        /* Insert a fake EOI marker */\n        src->buffer[0] = (JOCTET)0xFF;\n        src->buffer[1] = (JOCTET)JPEG_EOI;\n        nbytes = 2;\n    }\n\n    src->pub.next_input_byte = src->buffer;\n    src->pub.bytes_in_buffer = nbytes;\n    src->start_of_file = FALSE;\n    return TRUE;\n}\n\nstatic void lr_skip_input_data(j_decompress_ptr cinfo, long num_bytes)\n{\n    struct jpeg_source_mgr *src = cinfo->src;\n    if (num_bytes > 0)\n    {\n        while (num_bytes > (long)src->bytes_in_buffer)\n        {\n            num_bytes -= (long)src->bytes_in_buffer;\n            (void)(*src->fill_input_buffer)(cinfo);\n            /* note we assume that fill_input_buffer will never return FALSE,\n             * so suspension need not be handled.\n             */\n        }\n        src->next_input_byte += (size_t)num_bytes;\n        src->bytes_in_buffer -= (size_t)num_bytes;\n    }\n}\n\nstatic void lr_term_source(j_decompress_ptr cinfo) {}\n\nstatic void lr_jpeg_src(j_decompress_ptr cinfo, LibRaw_abstract_datastream *inf)\n{\n    lr_jpg_src_ptr src;\n    if (cinfo->src == NULL)\n    { /* first time for this JPEG object? */\n        cinfo->src = (struct jpeg_source_mgr *)(*cinfo->mem->alloc_small)(\n            (j_common_ptr)cinfo, JPOOL_PERMANENT, sizeof(lr_jpg_source_mgr));\n        src = (lr_jpg_src_ptr)cinfo->src;\n        src->buffer = (JOCTET *)(*cinfo->mem->alloc_small)(\n            (j_common_ptr)cinfo, JPOOL_PERMANENT,\n            LR_JPEG_INPUT_BUF_SIZE * sizeof(JOCTET));\n    }\n    else if (cinfo->src->init_source != f_init_source)\n    {\n        ERREXIT(cinfo, JERR_BUFFER_SIZE);\n    }\n\n    src = (lr_jpg_src_ptr)cinfo->src;\n    src->pub.init_source = f_init_source;\n    src->pub.fill_input_buffer = lr_fill_input_buffer;\n    src->pub.skip_input_data = lr_skip_input_data;\n    src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */\n    src->pub.term_source = lr_term_source;\n    src->instream = inf;\n    src->pub.bytes_in_buffer = 0;    /* forces fill_input_buffer on first read */\n    src->pub.next_input_byte = NULL; /* until buffer loaded */\n}\n#endif\n\nint LibRaw_abstract_datastream::jpeg_src(void *jpegdata)\n{\n#ifdef NO_JPEG\n    return -1;\n#else\n    j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;\n    buffering_off();\n    lr_jpeg_src(cinfo, this);\n    return 0; // OK\n#endif\n}\n\n\n#ifndef LIBRAW_NO_IOSTREAMS_DATASTREAM\n// == LibRaw_file_datastream ==\n\nLibRaw_file_datastream::~LibRaw_file_datastream()\n{\n  if (jas_file)\n    fclose(jas_file);\n}\n\nLibRaw_file_datastream::LibRaw_file_datastream(const char *fname)\n    : filename(fname), _fsize(0)\n#ifdef LIBRAW_WIN32_UNICODEPATHS\n      ,\n      wfilename()\n#endif\n      ,\n      jas_file(NULL)\n{\n  if (filename.size() > 0)\n  {\n#ifndef LIBRAW_WIN32_CALLS\n    struct stat st;\n    if (!stat(filename.c_str(), &st))\n      _fsize = st.st_size;\n#else\n    struct _stati64 st;\n    if (!_stati64(filename.c_str(), &st))\n      _fsize = st.st_size;\n#endif\n#ifdef LIBRAW_USE_AUTOPTR\n    std::auto_ptr<std::filebuf> buf(new std::filebuf());\n#else\n    std::unique_ptr<std::filebuf> buf(new std::filebuf());\n#endif\n    buf->open(filename.c_str(), std::ios_base::in | std::ios_base::binary);\n    if (buf->is_open())\n    {\n#ifdef LIBRAW_USE_AUTOPTR\n      f = buf;\n#else\n      f = std::move(buf);\n#endif\n    }\n  }\n}\n#ifdef LIBRAW_WIN32_UNICODEPATHS\nLibRaw_file_datastream::LibRaw_file_datastream(const wchar_t *fname)\n    : filename(), wfilename(fname), jas_file(NULL), _fsize(0)\n{\n  if (wfilename.size() > 0)\n  {\n    struct _stati64 st;\n    if (!_wstati64(wfilename.c_str(), &st))\n      _fsize = st.st_size;\n#ifdef LIBRAW_USE_AUTOPTR\n    std::auto_ptr<std::filebuf> buf(new std::filebuf());\n#else\n    std::unique_ptr<std::filebuf> buf(new std::filebuf());\n#endif\n    buf->open(wfilename.c_str(), std::ios_base::in | std::ios_base::binary);\n    if (buf->is_open())\n    {\n#ifdef LIBRAW_USE_AUTOPTR\n      f = buf;\n#else\n      f = std::move(buf);\n#endif\n\t}\n  }\n}\nconst wchar_t *LibRaw_file_datastream::wfname()\n{\n  return wfilename.size() > 0 ? wfilename.c_str() : NULL;\n}\n#endif\n\nint LibRaw_file_datastream::valid() { return f.get() ? 1 : 0; }\n\n#define LR_STREAM_CHK()                                                        \\\n  do                                                                           \\\n  {                                                                            \\\n    if (!f.get())                                                              \\\n      throw LIBRAW_EXCEPTION_IO_EOF;                                           \\\n  } while (0)\n\nint LibRaw_file_datastream::read(void *ptr, size_t size, size_t nmemb)\n{\n/* Visual Studio 2008 marks sgetn as insecure, but VS2010 does not. */\n#if defined(WIN32SECURECALLS) && (_MSC_VER < 1600)\n  LR_STREAM_CHK();\n  return int(f->_Sgetn_s(static_cast<char *>(ptr), nmemb * size, nmemb * size) /\n             (size > 0 ? size : 1));\n#else\n  LR_STREAM_CHK();\n  return int(f->sgetn(static_cast<char *>(ptr), std::streamsize(nmemb * size)) /\n             (size > 0 ? size : 1));\n#endif\n}\n\nint LibRaw_file_datastream::eof()\n{\n  LR_STREAM_CHK();\n  return f->sgetc() == EOF;\n}\n\nint LibRaw_file_datastream::seek(INT64 o, int whence)\n{\n  LR_STREAM_CHK();\n  std::ios_base::seekdir dir;\n  switch (whence)\n  {\n  case SEEK_SET:\n    dir = std::ios_base::beg;\n    break;\n  case SEEK_CUR:\n    dir = std::ios_base::cur;\n    break;\n  case SEEK_END:\n    dir = std::ios_base::end;\n    break;\n  default:\n    dir = std::ios_base::beg;\n  }\n  return f->pubseekoff((long)o, dir) < 0;\n}\n\nINT64 LibRaw_file_datastream::tell()\n{\n  LR_STREAM_CHK();\n  return f->pubseekoff(0, std::ios_base::cur);\n}\n\nchar *LibRaw_file_datastream::gets(char *str, int sz)\n{\n  if(sz<1) return NULL;\n  LR_STREAM_CHK();\n  std::istream is(f.get());\n  is.getline(str, sz);\n  if (is.fail())\n    return 0;\n  return str;\n}\n\nint LibRaw_file_datastream::scanf_one(const char *fmt, void *val)\n{\n  LR_STREAM_CHK();\n\n  std::istream is(f.get());\n\n  /* HUGE ASSUMPTION: *fmt is either \"%d\" or \"%f\" */\n  if (strcmp(fmt, \"%d\") == 0)\n  {\n    int d;\n    is >> d;\n    if (is.fail())\n      return EOF;\n    *(static_cast<int *>(val)) = d;\n  }\n  else\n  {\n    float f;\n    is >> f;\n    if (is.fail())\n      return EOF;\n    *(static_cast<float *>(val)) = f;\n  }\n\n  return 1;\n}\n\nconst char *LibRaw_file_datastream::fname()\n{\n  return filename.size() > 0 ? filename.c_str() : NULL;\n}\n\n#undef LR_STREAM_CHK\n\n#ifdef LIBRAW_OLD_VIDEO_SUPPORT\nvoid *LibRaw_file_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n  return NULL;\n#else\n#ifdef LIBRAW_WIN32_UNICODEPATHS\n  if (wfname())\n  {\n    jas_file = _wfopen(wfname(), L\"rb\");\n    return jas_stream_fdopen(fileno(jas_file), \"rb\");\n  }\n  else\n#endif\n  {\n    return jas_stream_fopen(fname(), \"rb\");\n  }\n#endif\n}\n#endif\n#endif\n\n// == LibRaw_buffer_datastream\nLibRaw_buffer_datastream::LibRaw_buffer_datastream(const void *buffer, size_t bsize)\n{\n  buf = (unsigned char *)buffer;\n  streampos = 0;\n  streamsize = bsize;\n}\n\nLibRaw_buffer_datastream::~LibRaw_buffer_datastream() {}\n\nint LibRaw_buffer_datastream::read(void *ptr, size_t sz, size_t nmemb)\n{\n  size_t to_read = sz * nmemb;\n  if (to_read > streamsize - streampos)\n    to_read = streamsize - streampos;\n  if (to_read < 1)\n    return 0;\n  memmove(ptr, buf + streampos, to_read);\n  streampos += to_read;\n  return int((to_read + sz - 1) / (sz > 0 ? sz : 1));\n}\n\nint LibRaw_buffer_datastream::seek(INT64 o, int whence)\n{\n  switch (whence)\n  {\n  case SEEK_SET:\n    if (o < 0)\n      streampos = 0;\n    else if (size_t(o) > streamsize)\n      streampos = streamsize;\n    else\n      streampos = size_t(o);\n    return 0;\n  case SEEK_CUR:\n    if (o < 0)\n    {\n      if (size_t(-o) >= streampos)\n        streampos = 0;\n      else\n        streampos += (size_t)o;\n    }\n    else if (o > 0)\n    {\n      if (o + streampos > streamsize)\n        streampos = streamsize;\n      else\n        streampos += (size_t)o;\n    }\n    return 0;\n  case SEEK_END:\n    if (o > 0)\n      streampos = streamsize;\n    else if (size_t(-o) > streamsize)\n      streampos = 0;\n    else\n      streampos = streamsize + (size_t)o;\n    return 0;\n  default:\n    return 0;\n  }\n}\n\nINT64 LibRaw_buffer_datastream::tell()\n{\n  return INT64(streampos);\n}\n\nchar *LibRaw_buffer_datastream::gets(char *s, int sz)\n{\n  if(sz<1) return NULL;\n  unsigned char *psrc, *pdest, *str;\n  str = (unsigned char *)s;\n  psrc = buf + streampos;\n  pdest = str;\n  if(streampos >= streamsize) return NULL;\n  while ((size_t(psrc - buf) < streamsize) && ((pdest - str) < (sz-1)))\n  {\n    *pdest = *psrc;\n    if (*psrc == '\\n')\n      break;\n    psrc++;\n    pdest++;\n  }\n  if (size_t(psrc - buf) < streamsize)\n    psrc++;\n  if ((pdest - str) < sz-1)\n    *(++pdest) = 0;\n  else\n    s[sz - 1] = 0; // ensure trailing zero\n\n  streampos = psrc - buf;\n  return s;\n}\n\nint LibRaw_buffer_datastream::scanf_one(const char *fmt, void *val)\n{\n  int scanf_res;\n  if (streampos > streamsize)\n    return 0;\n#ifndef WIN32SECURECALLS\n  scanf_res = sscanf((char *)(buf + streampos), fmt, val);\n#else\n  scanf_res = sscanf_s((char *)(buf + streampos), fmt, val);\n#endif\n  if (scanf_res > 0)\n  {\n    int xcnt = 0;\n    while (streampos < streamsize)\n    {\n      streampos++;\n      xcnt++;\n      if (buf[streampos] == 0 || buf[streampos] == ' ' ||\n          buf[streampos] == '\\t' || buf[streampos] == '\\n' || xcnt > 24)\n        break;\n    }\n  }\n  return scanf_res;\n}\n\nint LibRaw_buffer_datastream::eof()\n{\n  return streampos >= streamsize;\n}\nint LibRaw_buffer_datastream::valid() { return buf ? 1 : 0; }\n\n#ifdef LIBRAW_OLD_VIDEO_SUPPORT\nvoid *LibRaw_buffer_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n  return NULL;\n#else\n  return jas_stream_memopen((char *)buf + streampos, streamsize - streampos);\n#endif\n}\n#endif\n\nint LibRaw_buffer_datastream::jpeg_src(void *jpegdata)\n{\n#if defined(NO_JPEG) || !defined(USE_JPEG)\n  return -1;\n#else\n  j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;\n  jpeg_mem_src(cinfo, (unsigned char *)buf + streampos, streamsize - streampos);\n  return 0;\n#endif\n}\n\n// int LibRaw_buffer_datastream\n\n// == LibRaw_bigfile_datastream\nLibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const char *fname)\n    : filename(fname)\n#ifdef LIBRAW_WIN32_UNICODEPATHS\n      ,\n      wfilename()\n#endif\n{\n  if (filename.size() > 0)\n  {\n#ifndef LIBRAW_WIN32_CALLS\n    struct stat st;\n    if (!stat(filename.c_str(), &st))\n      _fsize = st.st_size;\n#else\n    struct _stati64 st;\n    if (!_stati64(filename.c_str(), &st))\n      _fsize = st.st_size;\n#endif\n\n#ifndef WIN32SECURECALLS\n    f = fopen(fname, \"rb\");\n#else\n    if (fopen_s(&f, fname, \"rb\"))\n      f = 0;\n#endif\n  }\n  else\n  {\n    filename = std::string();\n    f = 0;\n  }\n}\n\n#ifdef LIBRAW_WIN32_UNICODEPATHS\nLibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const wchar_t *fname)\n    : filename(), wfilename(fname)\n{\n  if (wfilename.size() > 0)\n  {\n    struct _stati64 st;\n    if (!_wstati64(wfilename.c_str(), &st))\n      _fsize = st.st_size;\n#ifndef WIN32SECURECALLS\n    f = _wfopen(wfilename.c_str(), L\"rb\");\n#else\n    if (_wfopen_s(&f, fname, L\"rb\"))\n      f = 0;\n#endif\n  }\n  else\n  {\n    wfilename = std::wstring();\n    f = 0;\n  }\n}\nconst wchar_t *LibRaw_bigfile_datastream::wfname()\n{\n  return wfilename.size() > 0 ? wfilename.c_str() : NULL;\n}\n#endif\n\nLibRaw_bigfile_datastream::~LibRaw_bigfile_datastream()\n{\n  if (f)\n    fclose(f);\n}\nint LibRaw_bigfile_datastream::valid() { return f ? 1 : 0; }\n\n#define LR_BF_CHK()                                                            \\\n  do                                                                           \\\n  {                                                                            \\\n    if (!f)                                                                    \\\n      throw LIBRAW_EXCEPTION_IO_EOF;                                           \\\n  } while (0)\n\nint LibRaw_bigfile_datastream::read(void *ptr, size_t size, size_t nmemb)\n{\n  LR_BF_CHK();\n  return int(fread(ptr, size, nmemb, f));\n}\n\nint LibRaw_bigfile_datastream::eof()\n{\n  LR_BF_CHK();\n  return feof(f);\n}\n\nint LibRaw_bigfile_datastream::seek(INT64 o, int whence)\n{\n  LR_BF_CHK();\n#if defined(_WIN32)\n#ifdef WIN32SECURECALLS\n  return _fseeki64(f, o, whence);\n#else\n  return fseek(f, (long)o, whence);\n#endif\n#else\n  return fseeko(f, o, whence);\n#endif\n}\n\nINT64 LibRaw_bigfile_datastream::tell()\n{\n  LR_BF_CHK();\n#if defined(_WIN32)\n#ifdef WIN32SECURECALLS\n  return _ftelli64(f);\n#else\n  return ftell(f);\n#endif\n#else\n  return ftello(f);\n#endif\n}\n\nchar *LibRaw_bigfile_datastream::gets(char *str, int sz)\n{\n  if(sz<1) return NULL;\n  LR_BF_CHK();\n  return fgets(str, sz, f);\n}\n\nint LibRaw_bigfile_datastream::scanf_one(const char *fmt, void *val)\n{\n  LR_BF_CHK();\n  return \n#ifndef WIN32SECURECALLS\n                   fscanf(f, fmt, val)\n#else\n                   fscanf_s(f, fmt, val)\n#endif\n      ;\n}\n\nconst char *LibRaw_bigfile_datastream::fname()\n{\n  return filename.size() > 0 ? filename.c_str() : NULL;\n}\n\n#ifdef LIBRAW_OLD_VIDEO_SUPPORT\nvoid *LibRaw_bigfile_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n  return NULL;\n#else\n  return jas_stream_fdopen(fileno(f), \"rb\");\n#endif\n}\n#endif\n\n// == LibRaw_windows_datastream\n#ifdef LIBRAW_WIN32_CALLS\n\nLibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR *sFile)\n    : LibRaw_buffer_datastream(NULL, 0), hMap_(0), pView_(NULL)\n{\n#if defined(WINAPI_FAMILY) && defined(WINAPI_FAMILY_APP) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)\n    HANDLE hFile = CreateFile2(sFile, GENERIC_READ, 0, OPEN_EXISTING, 0);\n#else\n  HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING,\n                            FILE_ATTRIBUTE_NORMAL, 0);\n#endif\n  if (hFile == INVALID_HANDLE_VALUE)\n    throw std::runtime_error(\"failed to open the file\");\n\n  try\n  {\n    Open(hFile);\n  }\n  catch (...)\n  {\n    CloseHandle(hFile);\n    throw;\n  }\n\n  CloseHandle(hFile); // windows will defer the actual closing of this handle\n                      // until the hMap_ is closed\n  reconstruct_base();\n}\n\n// ctor: construct with a file handle - caller is responsible for closing the\n// file handle\nLibRaw_windows_datastream::LibRaw_windows_datastream(HANDLE hFile)\n    : LibRaw_buffer_datastream(NULL, 0), hMap_(0), pView_(NULL)\n{\n  Open(hFile);\n  reconstruct_base();\n}\n\n// dtor: unmap and close the mapping handle\nLibRaw_windows_datastream::~LibRaw_windows_datastream()\n{\n  if (pView_ != NULL)\n    ::UnmapViewOfFile(pView_);\n\n  if (hMap_ != 0)\n    ::CloseHandle(hMap_);\n}\n\nvoid LibRaw_windows_datastream::Open(HANDLE hFile)\n{\n  // create a file mapping handle on the file handle\n  hMap_ = ::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);\n  if (hMap_ == NULL)\n    throw std::runtime_error(\"failed to create file mapping\");\n\n  // now map the whole file base view\n  if (!::GetFileSizeEx(hFile, (PLARGE_INTEGER)&cbView_))\n    throw std::runtime_error(\"failed to get the file size\");\n\n  pView_ = ::MapViewOfFile(hMap_, FILE_MAP_READ, 0, 0, (size_t)cbView_);\n  if (pView_ == NULL)\n    throw std::runtime_error(\"failed to map the file\");\n}\n\n#endif\n\n#if defined (LIBRAW_NO_IOSTREAMS_DATASTREAM)  && defined (LIBRAW_WIN32_CALLS)\n\n/* LibRaw_bigfile_buffered_datastream: copypasted from LibRaw_bigfile_datastream + extra cache on read */\n\n#undef LR_BF_CHK\n#define LR_BF_CHK()                                                    \\\n  do                                                                    \\\n  {                                                                     \\\n     if (fhandle ==0 || fhandle == INVALID_HANDLE_VALUE)                \\\n         throw LIBRAW_EXCEPTION_IO_EOF;                                 \\\n  } while (0)\n\n#define LIBRAW_BUFFER_ALIGN 4096\n\nint LibRaw_bufio_params::bufsize = 16384;\n\nvoid LibRaw_bufio_params::set_bufsize(int bs)\n{\n    if (bs > 0)\n        bufsize = bs;\n}\n\n\nLibRaw_bigfile_buffered_datastream::LibRaw_bigfile_buffered_datastream(const char *fname)\n    : filename(fname), _fsize(0), _fpos(0)\n#ifdef LIBRAW_WIN32_UNICODEPATHS\n    , wfilename()\n#endif\n    , iobuffers(), buffered(1)\n{\n    if (filename.size() > 0)\n    {\n        std::string fn(fname);\n        std::wstring fpath(fn.begin(), fn.end());\n#if defined(WINAPI_FAMILY) && defined(WINAPI_FAMILY_APP) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)\n        if ((fhandle = CreateFile2(fpath.c_str(), GENERIC_READ, 0, OPEN_EXISTING, 0)) != INVALID_HANDLE_VALUE)\n#else\n        if ((fhandle = CreateFileW(fpath.c_str(), GENERIC_READ, FILE_SHARE_READ, 0,\n            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)) != INVALID_HANDLE_VALUE)\n#endif\n        {\n            LARGE_INTEGER fs;\n            if (GetFileSizeEx(fhandle, &fs))\n                _fsize = fs.QuadPart;\n        }\n    }\n    else\n    {\n        filename = std::string();\n        fhandle = INVALID_HANDLE_VALUE;\n    }\n}\n\n#ifdef LIBRAW_WIN32_UNICODEPATHS\nLibRaw_bigfile_buffered_datastream::LibRaw_bigfile_buffered_datastream(const wchar_t *fname)\n    : filename(), _fsize(0), _fpos(0),\n    wfilename(fname), iobuffers(), buffered(1)\n{\n    if (wfilename.size() > 0)\n    {\n#if defined(WINAPI_FAMILY) && defined(WINAPI_FAMILY_APP) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)\n        if ((fhandle = CreateFile2(wfilename.c_str(), GENERIC_READ, 0, OPEN_EXISTING, 0)) != INVALID_HANDLE_VALUE)\n#else\n        if ((fhandle = CreateFileW(wfilename.c_str(), GENERIC_READ, FILE_SHARE_READ, 0,\n            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)) != INVALID_HANDLE_VALUE)\n#endif\n        {\n            if (fhandle > 0)\n            {\n                LARGE_INTEGER fs;\n                if (GetFileSizeEx(fhandle, &fs))\n                    _fsize = fs.QuadPart;\n            }\n        }\n\n    }\n    else\n    {\n        wfilename = std::wstring();\n        fhandle = INVALID_HANDLE_VALUE;\n    }\n}\n\nconst wchar_t *LibRaw_bigfile_buffered_datastream::wfname()\n{\n    return wfilename.size() > 0 ? wfilename.c_str() : NULL;\n}\n#endif\n\nLibRaw_bigfile_buffered_datastream::~LibRaw_bigfile_buffered_datastream()\n{\n    if (fhandle > 0)\n        CloseHandle(fhandle);\n}\nint LibRaw_bigfile_buffered_datastream::valid() {\n    return fhandle > 0 && fhandle != INVALID_HANDLE_VALUE;\n}\n\nconst char *LibRaw_bigfile_buffered_datastream::fname()\n{\n    return filename.size() > 0 ? filename.c_str() : NULL;\n}\n\n#ifdef LIBRAW_OLD_VIDEO_SUPPORT\nvoid *LibRaw_bigfile_buffered_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n    return NULL;\n#else\n    return NULL;\n#endif\n}\n#endif\n\nINT64 LibRaw_bigfile_buffered_datastream::readAt(void *ptr, size_t size, INT64 off)\n{\n    LR_BF_CHK();\n    DWORD NumberOfBytesRead;\n    DWORD nNumberOfBytesToRead = size;\n    struct _OVERLAPPED olap;\n    memset(&olap, 0, sizeof(olap));\n    olap.Offset = off & 0xffffffff;\n    olap.OffsetHigh = off >> 32;\n    if (ReadFile(fhandle, ptr, nNumberOfBytesToRead, &NumberOfBytesRead, &olap))\n        return NumberOfBytesRead;\n    else\n        return 0;\n}\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\n#ifdef _MSC_VER\n#pragma intrinsic(memcpy)\n#endif\n\nint LibRaw_bigfile_buffered_datastream::read(void *data, size_t size, size_t nmemb)\n{\n    if (size < 1 || nmemb < 1)\n        return 0;\n    LR_BF_CHK();\n    INT64 count = size * nmemb;\n    INT64 partbytes = 0;\n    if (!buffered)\n    {\n        INT64 r = readAt(data, count, _fpos);\n        _fpos += r;\n        return r / size;\n    }\n\n    unsigned char *fBuffer = (unsigned char*)iobuffers[0].data();\n    while (count)\n    {\n        INT64 inbuffer = 0;\n        // See if the request is totally inside buffer.\n        if (iobuffers[0].contains(_fpos, inbuffer))\n        {\n            if (inbuffer >= count)\n            {\n                memcpy(data, fBuffer + (unsigned)(_fpos - iobuffers[0]._bstart), count);\n                _fpos += count;\n                return (count + partbytes) / size;\n            }\n            memcpy(data, fBuffer + (_fpos - iobuffers[0]._bstart), inbuffer);\n            partbytes += inbuffer;\n            count -= inbuffer;\n            data = (void *)(((char *)data) + inbuffer);\n            _fpos += inbuffer;\n        }\n        if (count > iobuffers[0].size())\n        {\n        fallback:\n            if (_fpos + count > _fsize)\n                count = MAX(0, _fsize - _fpos);\n            if (count > 0)\n            {\n                INT64 r = readAt(data, count, _fpos);\n                _fpos += r;\n                return (r + partbytes) / size;\n            }\n            else\n                return 0;\n        }\n\n        if (!fillBufferAt(0, _fpos))\n            goto fallback;\n    }\n    return 0;\n}\n\nbool LibRaw_bigfile_buffered_datastream::fillBufferAt(int bi, INT64 off)\n{\n    iobuffers[bi]._bstart = off;\n    if (iobuffers[bi].size() >= LIBRAW_BUFFER_ALIGN * 2)// Align to a file block.\n        iobuffers[bi]._bstart &= (INT64)~((INT64)(LIBRAW_BUFFER_ALIGN - 1));\n\n    iobuffers[bi]._bend = MIN(iobuffers[bi]._bstart + iobuffers[bi].size(), _fsize);\n    if (iobuffers[bi]._bend <= off) // Buffer alignment problem, fallback\n        return false;\n    INT64 rr = readAt(iobuffers[bi].data(), (uint32_t)(iobuffers[bi]._bend - iobuffers[bi]._bstart), iobuffers[bi]._bstart);\n    if (rr > 0)\n    {\n        iobuffers[bi]._bend = iobuffers[bi]._bstart + rr;\n        return true;\n    }\n    return false;\n}\n\n\nint LibRaw_bigfile_buffered_datastream::eof()\n{\n    LR_BF_CHK();\n    return _fpos >= _fsize;\n}\n\nint LibRaw_bigfile_buffered_datastream::seek(INT64 o, int whence)\n{\n    LR_BF_CHK();\n    if (whence == SEEK_SET) _fpos = o;\n    else if (whence == SEEK_END) _fpos = o > 0 ? _fsize : _fsize + o;\n    else if (whence == SEEK_CUR) _fpos += o;\n\n    return 0;\n}\n\nINT64 LibRaw_bigfile_buffered_datastream::tell()\n{\n    LR_BF_CHK();\n    return _fpos;\n}\n\nchar *LibRaw_bigfile_buffered_datastream::gets(char *s, int sz)\n{\n    if (sz < 1)\n        return NULL;\n    else if (sz < 2)\n    {\n        s[0] = 0;\n        return s;\n    }\n\n    LR_BF_CHK();\n    INT64 contains;\n    int bufindex = selectStringBuffer(sz, contains);\n    if (bufindex < 0) return NULL;\n    if (contains >= sz)\n    {\n        unsigned char *buf = iobuffers[bufindex].data() + (_fpos - iobuffers[bufindex]._bstart);\n        int streampos = 0;\n        int streamsize = contains;\n        unsigned char *str = (unsigned char *)s;\n        unsigned char *psrc, *pdest;\n        psrc = buf + streampos;\n        pdest = str;\n\n        while ((size_t(psrc - buf) < streamsize) && ((pdest - str) < sz-1)) // sz-1: to append \\0\n        {\n            *pdest = *psrc;\n            if (*psrc == '\\n')\n                break;\n            psrc++;\n            pdest++;\n        }\n        if (size_t(psrc - buf) < streamsize)\n            psrc++;\n        if ((pdest - str) < sz - 1)\n            *(++pdest) = 0;\n        else\n            s[sz - 1] = 0; // ensure trailing zero\n        streampos = psrc - buf;\n        _fpos += streampos;\n        return s;\n    }\n    return NULL;\n}\n\nint LibRaw_bigfile_buffered_datastream::selectStringBuffer(INT64 len, INT64& contains)\n{\n    if (iobuffers[0].contains(_fpos, contains) && contains >= len)\n        return 0;\n\n    if (iobuffers[1].contains(_fpos, contains) && contains >= len)\n        return 1;\n\n    fillBufferAt(1, _fpos);\n    if (iobuffers[1].contains(_fpos, contains) && contains >= len)\n        return 1;\n    return -1;\n}\n\nint LibRaw_bigfile_buffered_datastream::scanf_one(const char *fmt, void *val)\n{\n    LR_BF_CHK();\n    INT64 contains = 0;\n    int bufindex = selectStringBuffer(24, contains);\n    if (bufindex < 0) return -1;\n    if (contains >= 24)\n    {\n        unsigned char *bstart = iobuffers[bufindex].data() + (_fpos - iobuffers[bufindex]._bstart);\n        int streampos = 0;\n        int streamsize = contains;\n        int\n#ifndef WIN32SECURECALLS\n            scanf_res = sscanf((char *)(bstart), fmt, val);\n#else\n            scanf_res = sscanf_s((char *)(bstart), fmt, val);\n#endif\n        if (scanf_res > 0)\n        {\n            int xcnt = 0;\n            while (streampos < streamsize)\n            {\n                streampos++;\n                xcnt++;\n                if (bstart[streampos] == 0 || bstart[streampos] == ' ' ||\n                    bstart[streampos] == '\\t' || bstart[streampos] == '\\n' || xcnt > 24)\n                    break;\n            }\n            _fpos += streampos;\n            return scanf_res;\n        }\n    }\n    return -1;\n}\n\n#endif\n\n"], "filenames": ["src/libraw_datastream.cpp"], "buggy_code_start_loc": [289], "buggy_code_end_loc": [620], "fixing_code_start_loc": [290], "fixing_code_end_loc": [624], "type": "CWE-787", "message": "Buffer Overflow vulnerability in LibRaw linux/unix v0.20.0 allows attacker to escalate privileges via the LibRaw_buffer_datastream::gets(char*, int) in /src/libraw/src/libraw_datastream.cpp.", "other": {"cve": {"id": "CVE-2021-32142", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-17T18:15:10.860", "lastModified": "2023-05-28T04:15:10.147", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer Overflow vulnerability in LibRaw linux/unix v0.20.0 allows attacker to escalate privileges via the LibRaw_buffer_datastream::gets(char*, int) in /src/libraw/src/libraw_datastream.cpp."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.0:*:*:*:*:*:*:*", "matchCriteriaId": "3D26C9C4-BD7A-454F-96B3-06D1EFC4A5C2"}]}]}], "references": [{"url": "https://github.com/LibRaw/LibRaw/commit/bc3aaf4223fdb70d52d470dae65c5a7923ea2a49", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/LibRaw/LibRaw/issues/400", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://github.com/gtt1995", "source": "cve@mitre.org", "tags": ["Not Applicable"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00025.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5ICTVDRGBWGIFBTUWJLGX7QM5GWBWUG7/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E7TEZ7CLRNYYQZJ5NJGZXK6YJU46WH2L/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2023/dsa-5412", "source": "cve@mitre.org"}, {"url": "https://www.libraw.org/", "source": "cve@mitre.org", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/LibRaw/LibRaw/commit/bc3aaf4223fdb70d52d470dae65c5a7923ea2a49"}}