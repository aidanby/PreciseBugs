{"buggy_code": ["---\ntitle: \"Webhooks\"\ndescription: \"Webhooks\"\nposition: 1500\ncategory: \"Developer Resources\"\nmenuTitle: \"Webhooks\"\n---\n\n## Overview\n\nSome types of notifications can be triggered by a webhook after a particular event.\n\n- Open a Project, Select a table and Click 'More' > 'Webhooks'.\n\n![Screenshot 2022-02-22 at 11 16 18 AM](https://user-images.githubusercontent.com/86527202/155085373-f9b438ed-98c3-4fb1-9209-1bb52736a35d.png)\n\n- Click 'Create webhook'\n\n![image](https://user-images.githubusercontent.com/35857179/166660074-0a896ec9-9cd8-403e-a713-61c2cefbae28.png)\n\n- Configure the webhook\n\n![image](https://user-images.githubusercontent.com/35857179/166660248-a3c81a34-4334-48c2-846a-65759d761559.png)\n\n\n## Triggers\n\nWebhooks allows user to trigger on certain operations on following database operations\n\n-   AFTER INSERT\n-   AFTER UPDATE\n-   AFTER DELETE\n\nThe triggers will trigger asynchronously without blocking the actual operation.\n\n### Applications/services\n\n| Trigger         | Details                                        |\n| --------------- | ---------------------------------------------- |\n| Email           | Send email to certain email addresses          |\n| Slack           | Notify via Slack channel                       |\n| Microsoft Teams | Notify via Microsoft Teams channel             |\n| Discord         | Notify via Discord channel                     |\n| Mattermost      | Notify via Mattermost channel                  |\n| Twilio          | Send SMS to certain mobile numbers             |\n| Whatsapp Twilio | Send Whatsapp messages to numbers using Twilio |\n| URL             | Invoke an HTTP API                             |\n\n  \n## Accessing Data: Handlebars\n\nThe current row data and other details will be available in the hooks payload so the user can use [handlebar syntax](https://handlebarsjs.com/guide/#simple-expressions) to use data.\n\n> We are using [Handlebars](https://handlebarsjs.com/) library to parse the payload internally.\n\n### Example\n\nFor a table with column names (id, title, created_at, updated_at).  \nFor INSERT/ UPDATE based triggers, use following handlebars to access corresponding **data** fields.\n\n-   {{ **data**.id }}\n-   {{ **data**.title }}\n-   {{ **data**.created_at }}\n-   {{ **data**.updated_at }}  \n  \nNote that, for Update trigger - all the fields in the ROW will be accessible, not just the field updated.\nFor DELETE based triggers, **only** {{ data.id }} is accessible representing ID of the column deleted.\n  \nFor all trigger, following **user** information associated with person trigger can be accessed.\n\n-   {{ **user**.id }} : Unique auto incremented NocoDB system value\n-   {{ **user**.email }} : User E-mail.\n-   {{ **user**.roles }} : User Role amongst [Owner, Creator, Editor, Commenter, Viewer].\n\n### JSON format\n\nUse {{ json data }} {{ json user }} to dump complete data & user information available in JSON format\n\n### Additional references:\n\n[Handlebar Guide](https://handlebarsjs.com/guide/).\n\n# Application Guide\n\n## Discord\n\n### 1. Create WebHook\n\n-   On Discord, open your Server Settings and head into the Integrations tab:\n-   Click the \"Create Webhook\" button to create a new webhook!\n\n![Screenshot 2022-02-22 at 1 21 59 PM](https://user-images.githubusercontent.com/86527202/155087088-8f9fd762-9ff9-41a6-aed4-0f22add77fe6.png)\n\n-   Choose channel to which this webhook will post to.\n-   Copy webhook URL\n\n![Screenshot 2022-02-22 at 1 23 18 PM](https://user-images.githubusercontent.com/86527202/155087126-c2cdd7b2-518a-46a5-82a5-aa90fe51a709.png)\n\n(Sample webhook URL: https://discord.com/api/webhooks/945558283756908644/GNUtiGuzfOky6wZ4ce30XuXc1sbPK3Od7EC-4t6hihh5Fovv6oU9OsdT6mGuoL1QlTzj).  \nDetailed procedure for discord webhook described [here](https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks).\n\n### 2. Install Plugin\n\n-   Open 'App Store' (under Settings), hover over Discord tile. Click 'Install'.\n\n![Screenshot 2022-02-22 at 11 30 36 AM](https://user-images.githubusercontent.com/86527202/155085257-5bdde1d9-d7b5-471d-bf44-3c3920e7b853.png)\n\n-   Provide a name of your choice (not to be confused with Discord Channel name).\n-   Paste Discord Webhook URL copied from Step (1.) above.\n\n![Screenshot 2022-02-22 at 11 31 21 AM](https://user-images.githubusercontent.com/86527202/155085287-f5e45aab-fd33-4138-a7a9-6eddc6dc140b.png)\n\n### 3. Configure \n\n-   Open project and choose a table.\n-   Click 'More' > 'Webhooks'.\n-   Click 'Create webhook'\n-   Configure webhook\n    -   **Title**: Name of your choice to identify this Webhook.\n    -   **Event**: Trigger event. Choose between.\n        -   After Insert: Trigger event for new ROW insertion.\n        -   After Update: Trigger event for existing ROW updation.\n        -   After Delete: Trigger event for ROW deletion\n    -   **On Condition**: [Optional] Enable if you wish to associate additional condition/constraint with the trigger configured above.\n    -   **Notification**: Select 'Discord'.\n    -   **Select Discord Channels**: Select from the drop down list, channel name configured in Step (2). Please click on 'Reload' if drop down list is empty.\n    -   **Body**: Message to be posted over Discord channel, via webhooks on trigger of configured event.\n        -   Body can contain plain text &\n        -   Handlebars {{ }}\n\n\n## Slack\n### 1. Create WebHook\n-   Details to create slack webhook are captured [here](https://api.slack.com/messaging/webhooks)\n\n### 2. Install Plugin\n- Procedure remain same as listed for DISCORD channel configuration above\n\n### 3. Configure Webhook\n- Procedure remain same as listed for DISCORD channel configuration above\n  \n  \n## Microsoft Teams\n### 1. Create WebHook\n\n-   On Teams, open your channel, click on three-dots menu (far right) and select 'Connectors'\n  \n<img width=\"319\" alt=\"154971352-6912d53b-cf71-4edd-a319-1c85be85f0c5\" src=\"https://user-images.githubusercontent.com/86527202/155095745-91abd708-834f-4f0e-a33c-ac362e60af0f.png\">\n\n  \n-   Select incoming webhook & click 'Configure'\n  \n<img width=\"442\" alt=\"154971434-0ced97f7-205a-4e2e-8f88-17092cb7771a\" src=\"https://user-images.githubusercontent.com/86527202/155095741-b23ad6b2-1276-46e3-8ada-0d0a871115bb.png\">\n  \n-   Create webhook, Copy webhook URL\n  \n![154971683-db16be7f-4f07-4447-8f2e-ac50e133bef8](https://user-images.githubusercontent.com/86527202/155095733-c339a914-5d78-408c-8f1e-9cd75a7783e8.png)\n\n\n### 2. Install Plugin\n\n-   Open 'App Store' (under Settings), hover over 'Microsoft Teams' tile. Click 'Install'.\n\n![Screenshot 2022-02-22 at 7 32 52 PM](https://user-images.githubusercontent.com/86527202/155148122-60844b42-7d2a-4c0f-9778-a5bc4f9c0107.png)\n\n\n-   Provide a name of your choice (not to be confused with Teams Channel name).\n-   Paste MS Teams Webhook URL copied from Step (1.) above.\n\n<img width=\"414\" alt=\"154971222-7fe2c25a-d8c6-46b0-ba1e-a05ff1cf6537\" src=\"https://user-images.githubusercontent.com/86527202/155095720-ff1c052c-a4a7-4c10-8f30-d779dac336f3.png\">\n\n### 3. Configure \n\n- Open project and choose a table.\n- Click 'More' > 'Webhooks'.\n- Click 'Create webhook'\n- Configure webhook\n    -   **Title**: Name of your choice to identify this Webhook.\n    -   **Event**: Trigger event. Choose between.\n        -   After Insert: Trigger event for new ROW insertion.\n        -   After Update: Trigger event for existing ROW updation.\n        -   After Delete: Trigger event for ROW deletion\n    -   **On Condition**: [Optional] Enable if you wish to associate additional condition/constraint with the trigger configured above.\n    -   **Notification**: Select 'Microsoft Teams'.\n    -   **Select Teams Channels**: Select from the drop down list, channel name configured in Step (2). Please click on 'Reload' if drop down list is empty.\n    -   **Body**: Message to be posted over Teams channel, via webhooks on trigger of configured event.\n        -   Body can contain plain text &\n        -   Handlebars {{ }}\n", "import autoBind from 'auto-bind';\nimport _ from 'lodash';\n\nimport Model from '../../../../models/Model';\nimport { XKnex } from '../../index';\nimport LinkToAnotherRecordColumn from '../../../../models/LinkToAnotherRecordColumn';\nimport RollupColumn from '../../../../models/RollupColumn';\nimport LookupColumn from '../../../../models/LookupColumn';\nimport DataLoader from 'dataloader';\nimport Column from '../../../../models/Column';\nimport { XcFilter, XcFilterWithAlias } from '../BaseModel';\nimport conditionV2 from './conditionV2';\nimport Filter from '../../../../models/Filter';\nimport sortV2 from './sortV2';\nimport Sort from '../../../../models/Sort';\nimport FormulaColumn from '../../../../models/FormulaColumn';\nimport genRollupSelectv2 from './genRollupSelectv2';\nimport formulaQueryBuilderv2 from './formulav2/formulaQueryBuilderv2';\nimport { QueryBuilder } from 'knex';\nimport View from '../../../../models/View';\nimport {\n  AuditOperationSubTypes,\n  AuditOperationTypes,\n  RelationTypes,\n  SortType,\n  UITypes,\n  ViewTypes\n} from 'nocodb-sdk';\nimport formSubmissionEmailTemplate from '../../../../utils/common/formSubmissionEmailTemplate';\nimport ejs from 'ejs';\nimport Audit from '../../../../models/Audit';\nimport FormView from '../../../../models/FormView';\nimport Hook from '../../../../models/Hook';\nimport NcPluginMgrv2 from '../../../../meta/helpers/NcPluginMgrv2';\nimport {\n  _transformSubmittedFormDataForEmail,\n  invokeWebhook,\n  parseBody\n} from '../../../../meta/helpers/webhookHelpers';\nimport Validator from 'validator';\nimport { customValidators } from './customValidators';\nimport { NcError } from '../../../../meta/helpers/catchError';\nimport { customAlphabet } from 'nanoid';\n\nconst GROUP_COL = '__nc_group_id';\n\nconst nanoidv2 = customAlphabet('1234567890abcdefghijklmnopqrstuvwxyz', 14);\nconst { v4: uuidv4 } = require('uuid');\n\nasync function populatePk(model: Model, insertObj: any) {\n  await model.getColumns();\n  for (const pkCol of model.primaryKeys) {\n    if (!pkCol.meta?.ag || insertObj[pkCol.title]) continue;\n    insertObj[pkCol.title] =\n      pkCol.meta?.ag === 'nc' ? `rc_${nanoidv2()}` : uuidv4();\n  }\n}\n\n/**\n * Base class for models\n *\n * @class\n * @classdesc Base class for models\n */\nclass BaseModelSqlv2 {\n  protected dbDriver: XKnex;\n  protected model: Model;\n  protected viewId: string;\n  private _proto: any;\n  private _columns = {};\n\n  private config: any = {\n    limitDefault: Math.max(+process.env.DB_QUERY_LIMIT_DEFAULT || 25, 1),\n    limitMin: Math.max(+process.env.DB_QUERY_LIMIT_MIN || 1, 1),\n    limitMax: Math.max(+process.env.DB_QUERY_LIMIT_MAX || 1000, 1)\n  };\n\n  constructor({\n    dbDriver,\n    model,\n    viewId\n  }: {\n    [key: string]: any;\n    model: Model;\n  }) {\n    this.dbDriver = dbDriver;\n    this.model = model;\n    this.viewId = viewId;\n    autoBind(this);\n  }\n\n  public async readByPk(id?: any): Promise<any> {\n    const qb = this.dbDriver(this.model.table_name);\n\n    await this.selectObject({ qb });\n\n    qb.where(this.model.primaryKey.column_name, id);\n\n    const data = (await this.extractRawQueryAndExec(qb))?.[0];\n\n    if (data) {\n      const proto = await this.getProto();\n      data.__proto__ = proto;\n    }\n    return data;\n  }\n\n  public async exist(id?: any): Promise<any> {\n    const qb = this.dbDriver(this.model.table_name);\n    await this.selectObject({ qb });\n    const pks = this.model.primaryKeys;\n    if ((id + '').split('___').length != pks.length) {\n      return false;\n    }\n    return !!(await qb.where(_wherePk(pks, id)).first());\n  }\n\n  public async findOne(\n    args: {\n      where?: string;\n      filterArr?: Filter[];\n    } = {}\n  ): Promise<any> {\n    const qb = this.dbDriver(this.model.table_name);\n    await this.selectObject({ qb });\n\n    const aliasColObjMap = await this.model.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args?.where, aliasColObjMap);\n\n    await conditionV2(\n      [\n        new Filter({\n          children: args.filterArr || [],\n          is_group: true,\n          logical_op: 'and'\n        }),\n        new Filter({\n          children: filterObj,\n          is_group: true,\n          logical_op: 'and'\n        }),\n        ...(args.filterArr || [])\n      ],\n      qb,\n      this.dbDriver\n    );\n\n    const data = await qb.first();\n\n    if (data) {\n      const proto = await this.getProto();\n      data.__proto__ = proto;\n    }\n    return data;\n  }\n\n  public async list(\n    args: {\n      where?: string;\n      limit?;\n      offset?;\n      filterArr?: Filter[];\n      sortArr?: Sort[];\n      sort?: string | string[];\n    } = {},\n    ignoreFilterSort = false\n  ): Promise<any> {\n    const { where, ...rest } = this._getListArgs(args as any);\n\n    const qb = this.dbDriver(this.model.table_name);\n    await this.selectObject({ qb });\n\n    const aliasColObjMap = await this.model.getAliasColObjMap();\n\n    let sorts = extractSortsObject(args?.sort, aliasColObjMap);\n\n    const filterObj = extractFilterFromXwhere(args?.where, aliasColObjMap);\n\n    // todo: replace with view id\n    if (!ignoreFilterSort && this.viewId) {\n      await conditionV2(\n        [\n          new Filter({\n            children:\n              (await Filter.rootFilterList({ viewId: this.viewId })) || [],\n            is_group: true\n          }),\n          new Filter({\n            children: args.filterArr || [],\n            is_group: true,\n            logical_op: 'and'\n          }),\n          new Filter({\n            children: filterObj,\n            is_group: true,\n            logical_op: 'and'\n          }),\n          ...(args.filterArr || [])\n        ],\n        qb,\n        this.dbDriver\n      );\n\n      if (!sorts)\n        sorts = args.sortArr?.length\n          ? args.sortArr\n          : await Sort.list({ viewId: this.viewId });\n\n      await sortV2(sorts, qb, this.dbDriver);\n    } else {\n      await conditionV2(\n        [\n          new Filter({\n            children: args.filterArr || [],\n            is_group: true,\n            logical_op: 'and'\n          }),\n          new Filter({\n            children: filterObj,\n            is_group: true,\n            logical_op: 'and'\n          }),\n          ...(args.filterArr || [])\n        ],\n        qb,\n        this.dbDriver\n      );\n\n      if (!sorts) sorts = args.sortArr;\n\n      await sortV2(sorts, qb, this.dbDriver);\n    }\n\n    // sort by primary key if not autogenerated string\n    // if autogenerated string sort by created_at column if present\n    if (this.model.primaryKey && this.model.primaryKey.ai) {\n      qb.orderBy(this.model.primaryKey.column_name);\n    } else if (this.model.columns.find(c => c.column_name === 'created_at')) {\n      qb.orderBy('created_at');\n    }\n\n    if (!ignoreFilterSort) applyPaginate(qb, rest);\n    const proto = await this.getProto();\n\n    const data = await this.extractRawQueryAndExec(qb);\n\n    return data?.map(d => {\n      d.__proto__ = proto;\n      return d;\n    });\n  }\n\n  public async count(\n    args: { where?: string; limit?; filterArr?: Filter[] } = {},\n    ignoreFilterSort = false\n  ): Promise<any> {\n    await this.model.getColumns();\n    const { where } = this._getListArgs(args);\n\n    const qb = this.dbDriver(this.model.table_name);\n\n    // qb.xwhere(where, await this.model.getAliasColMapping());\n    const aliasColObjMap = await this.model.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(where, aliasColObjMap);\n\n    if (!ignoreFilterSort && this.viewId) {\n      await conditionV2(\n        [\n          new Filter({\n            children:\n              (await Filter.rootFilterList({ viewId: this.viewId })) || [],\n            is_group: true\n          }),\n          new Filter({\n            children: args.filterArr || [],\n            is_group: true,\n            logical_op: 'and'\n          }),\n          new Filter({\n            children: filterObj,\n            is_group: true,\n            logical_op: 'and'\n          }),\n          ...(args.filterArr || [])\n        ],\n        qb,\n        this.dbDriver\n      );\n    } else {\n      await conditionV2(\n        [\n          new Filter({\n            children: args.filterArr || [],\n            is_group: true,\n            logical_op: 'and'\n          }),\n          new Filter({\n            children: filterObj,\n            is_group: true,\n            logical_op: 'and'\n          }),\n          ...(args.filterArr || [])\n        ],\n        qb,\n        this.dbDriver\n      );\n    }\n\n    qb.count(this.model.primaryKey?.column_name || '*', {\n      as: 'count'\n    }).first();\n\n    return ((await qb) as any).count;\n  }\n\n  async groupBy(\n    args: {\n      where?: string;\n      column_name: string;\n      limit?;\n      offset?;\n      sort?: string | string[];\n    } = {\n      column_name: ''\n    }\n  ) {\n    const { where, ...rest } = this._getListArgs(args as any);\n\n    const qb = this.dbDriver(this.model.table_name);\n    qb.count(`${this.model.primaryKey?.column_name || '*'} as count`);\n    qb.select(args.column_name);\n\n    const aliasColObjMap = await this.model.getAliasColObjMap();\n\n    const sorts = extractSortsObject(args?.sort, aliasColObjMap);\n\n    const filterObj = extractFilterFromXwhere(args?.where, aliasColObjMap);\n    await conditionV2(\n      [\n        new Filter({\n          children: filterObj,\n          is_group: true,\n          logical_op: 'and'\n        })\n      ],\n      qb,\n      this.dbDriver\n    );\n    qb.groupBy(args.column_name);\n    if (sorts) await sortV2(sorts, qb, this.dbDriver);\n    applyPaginate(qb, rest);\n\n    return await qb;\n  }\n\n  async multipleHmList({ colId, ids }, args?: { limit?; offset? }) {\n    try {\n      // todo: get only required fields\n\n      // const { cn } = this.hasManyRelations.find(({ tn }) => tn === child) || {};\n      const relColumn = (await this.model.getColumns()).find(\n        c => c.id === colId\n      );\n\n      const chilCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getChildColumn();\n      const childTable = await chilCol.getModel();\n      const parentCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getParentColumn();\n      const parentTable = await parentCol.getModel();\n      const childModel = await Model.getBaseModelSQL({\n        model: childTable,\n        dbDriver: this.dbDriver\n      });\n      await parentTable.getColumns();\n\n      const qb = this.dbDriver(childTable.table_name);\n      await childModel.selectObject({ qb });\n\n      const childQb = this.dbDriver.queryBuilder().from(\n        this.dbDriver\n          .unionAll(\n            ids.map(p => {\n              const query = qb\n                .clone()\n                .select(this.dbDriver.raw('? as ??', [p, GROUP_COL]))\n                .whereIn(\n                  chilCol.column_name,\n                  this.dbDriver(parentTable.table_name)\n                    .select(parentCol.column_name)\n                    // .where(parentTable.primaryKey.cn, p)\n                    .where(_wherePk(parentTable.primaryKeys, p))\n                );\n              // todo: sanitize\n              query.limit(args?.limit || 20);\n              query.offset(args?.offset || 0);\n\n              return this.isSqlite ? this.dbDriver.select().from(query) : query;\n            }),\n            !this.isSqlite\n          )\n          .as('list')\n      );\n\n      const children = await this.extractRawQueryAndExec(childQb);\n      const proto = await (\n        await Model.getBaseModelSQL({\n          id: childTable.id,\n          dbDriver: this.dbDriver\n        })\n      ).getProto();\n\n      return _.groupBy(\n        children.map(c => {\n          c.__proto__ = proto;\n          return c;\n        }),\n        GROUP_COL\n      );\n    } catch (e) {\n      console.log(e);\n      throw e;\n    }\n  }\n\n  async multipleHmListCount({ colId, ids }) {\n    try {\n      // const { cn } = this.hasManyRelations.find(({ tn }) => tn === child) || {};\n      const relColumn = (await this.model.getColumns()).find(\n        c => c.id === colId\n      );\n      const chilCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getChildColumn();\n      const childTable = await chilCol.getModel();\n      const parentCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getParentColumn();\n      const parentTable = await parentCol.getModel();\n      await parentTable.getColumns();\n\n      const children = await this.dbDriver.unionAll(\n        ids.map(p => {\n          const query = this.dbDriver(childTable.table_name)\n            .count(`${chilCol?.column_name} as count`)\n            .whereIn(\n              chilCol.column_name,\n              this.dbDriver(parentTable.table_name)\n                .select(parentCol.column_name)\n                // .where(parentTable.primaryKey.cn, p)\n                .where(_wherePk(parentTable.primaryKeys, p))\n            )\n            .first();\n\n          return this.isSqlite ? this.dbDriver.select().from(query) : query;\n        }),\n        !this.isSqlite\n      );\n\n      return children.map(({ count }) => count);\n    } catch (e) {\n      console.log(e);\n      throw e;\n    }\n  }\n\n  async hmList({ colId, id }, args?: { limit?; offset? }) {\n    try {\n      // todo: get only required fields\n\n      const relColumn = (await this.model.getColumns()).find(\n        c => c.id === colId\n      );\n\n      const chilCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getChildColumn();\n      const childTable = await chilCol.getModel();\n      const parentCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getParentColumn();\n      const parentTable = await parentCol.getModel();\n      const childModel = await Model.getBaseModelSQL({\n        model: childTable,\n        dbDriver: this.dbDriver\n      });\n      await parentTable.getColumns();\n\n      const qb = this.dbDriver(childTable.table_name);\n\n      qb.whereIn(\n        chilCol.column_name,\n        this.dbDriver(parentTable.table_name)\n          .select(parentCol.column_name)\n          // .where(parentTable.primaryKey.cn, p)\n          .where(_wherePk(parentTable.primaryKeys, id))\n      );\n      // todo: sanitize\n      qb.limit(args?.limit || 20);\n      qb.offset(args?.offset || 0);\n\n      await childModel.selectObject({ qb });\n\n      const children = await this.extractRawQueryAndExec(qb);\n\n      const proto = await (\n        await Model.getBaseModelSQL({\n          id: childTable.id,\n          dbDriver: this.dbDriver\n        })\n      ).getProto();\n\n      return children.map(c => {\n        c.__proto__ = proto;\n        return c;\n      });\n    } catch (e) {\n      console.log(e);\n      throw e;\n    }\n  }\n\n  async hmListCount({ colId, id }) {\n    try {\n      // const { cn } = this.hasManyRelations.find(({ tn }) => tn === child) || {};\n      const relColumn = (await this.model.getColumns()).find(\n        c => c.id === colId\n      );\n      const chilCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getChildColumn();\n      const childTable = await chilCol.getModel();\n      const parentCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getParentColumn();\n      const parentTable = await parentCol.getModel();\n      await parentTable.getColumns();\n\n      const query = this.dbDriver(childTable.table_name)\n        .count(`${chilCol?.column_name} as count`)\n        .whereIn(\n          chilCol.column_name,\n          this.dbDriver(parentTable.table_name)\n            .select(parentCol.column_name)\n            .where(_wherePk(parentTable.primaryKeys, id))\n        )\n        .first();\n      const { count } = await query;\n      return count;\n      // return _.groupBy(children, cn);\n    } catch (e) {\n      console.log(e);\n      throw e;\n    }\n  }\n\n  public async multipleMmList({ colId, parentIds }, args?: { limit; offset }) {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    // const tn = this.model.tn;\n    // const cn = (await relColOptions.getChildColumn()).title;\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n    const childModel = await Model.getBaseModelSQL({\n      dbDriver: this.dbDriver,\n      model: childTable\n    });\n    const rtn = childTable.table_name;\n    const rtnId = childTable.id;\n\n    const qb = this.dbDriver(rtn).join(vtn, `${vtn}.${vrcn}`, `${rtn}.${rcn}`);\n\n    await childModel.selectObject({ qb });\n    const finalQb = this.dbDriver.unionAll(\n      parentIds.map(id => {\n        const query = qb\n          .clone()\n          .whereIn(\n            `${vtn}.${vcn}`,\n            this.dbDriver(parentTable.table_name)\n              .select(cn)\n              // .where(parentTable.primaryKey.cn, id)\n              .where(_wherePk(parentTable.primaryKeys, id))\n          )\n          .select(this.dbDriver.raw('? as ??', [id, GROUP_COL]));\n\n        // todo: sanitize\n        query.limit(args?.limit || 20);\n        query.offset(args?.offset || 0);\n\n        return this.isSqlite ? this.dbDriver.select().from(query) : query;\n      }),\n      !this.isSqlite\n    );\n\n    const children = await this.extractRawQueryAndExec(finalQb);\n    const proto = await (\n      await Model.getBaseModelSQL({\n        id: rtnId,\n        dbDriver: this.dbDriver\n      })\n    ).getProto();\n    const gs = _.groupBy(\n      children.map(c => {\n        c.__proto__ = proto;\n        return c;\n      }),\n      GROUP_COL\n    );\n    return parentIds.map(id => gs[id] || []);\n  }\n\n  public async mmList({ colId, parentId }, args?: { limit; offset }) {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    // const tn = this.model.tn;\n    // const cn = (await relColOptions.getChildColumn()).title;\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n    const childModel = await Model.getBaseModelSQL({\n      dbDriver: this.dbDriver,\n      model: childTable\n    });\n    const rtn = childTable.table_name;\n    const rtnId = childTable.id;\n\n    const qb = this.dbDriver(rtn)\n      .join(vtn, `${vtn}.${vrcn}`, `${rtn}.${rcn}`)\n      .whereIn(\n        `${vtn}.${vcn}`,\n        this.dbDriver(parentTable.table_name)\n          .select(cn)\n          // .where(parentTable.primaryKey.cn, id)\n          .where(_wherePk(parentTable.primaryKeys, parentId))\n      );\n\n    await childModel.selectObject({ qb });\n    // todo: sanitize\n    qb.limit(args?.limit || 20);\n    qb.offset(args?.offset || 0);\n\n    const children = await this.extractRawQueryAndExec(qb);\n    const proto = await (\n      await Model.getBaseModelSQL({ id: rtnId, dbDriver: this.dbDriver })\n    ).getProto();\n\n    return children.map(c => {\n      c.__proto__ = proto;\n      return c;\n    });\n  }\n\n  public async multipleMmListCount({ colId, parentIds }) {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const rtn = childTable.table_name;\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n\n    const qb = this.dbDriver(rtn)\n      .join(vtn, `${vtn}.${vrcn}`, `${rtn}.${rcn}`)\n      // .select({\n      //   [`${tn}_${vcn}`]: `${vtn}.${vcn}`\n      // })\n      .count(`${vtn}.${vcn}`, { as: 'count' });\n\n    // await childModel.selectObject({ qb });\n    const children = await this.dbDriver.unionAll(\n      parentIds.map(id => {\n        const query = qb\n          .clone()\n          .whereIn(\n            `${vtn}.${vcn}`,\n            this.dbDriver(parentTable.table_name)\n              .select(cn)\n              // .where(parentTable.primaryKey.cn, id)\n              .where(_wherePk(parentTable.primaryKeys, id))\n          )\n          .select(this.dbDriver.raw('? as ??', [id, GROUP_COL]));\n        // this._paginateAndSort(query, { sort, limit, offset }, null, true);\n        return this.isSqlite ? this.dbDriver.select().from(query) : query;\n      }),\n      !this.isSqlite\n    );\n\n    const gs = _.groupBy(children, GROUP_COL);\n    return parentIds.map(id => gs?.[id]?.[0] || []);\n  }\n\n  public async mmListCount({ colId, parentId }) {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const rtn = childTable.table_name;\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n\n    const qb = this.dbDriver(rtn)\n      .join(vtn, `${vtn}.${vrcn}`, `${rtn}.${rcn}`)\n      // .select({\n      //   [`${tn}_${vcn}`]: `${vtn}.${vcn}`\n      // })\n      .count(`${vtn}.${vcn}`, { as: 'count' })\n      .whereIn(\n        `${vtn}.${vcn}`,\n        this.dbDriver(parentTable.table_name)\n          .select(cn)\n          // .where(parentTable.primaryKey.cn, id)\n          .where(_wherePk(parentTable.primaryKeys, parentId))\n      )\n      .first();\n\n    const { count } = await qb;\n\n    return count;\n  }\n\n  // todo: naming & optimizing\n  public async getMmChildrenExcludedListCount(\n    { colId, pid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n    const rtn = childTable.table_name;\n    const qb = this.dbDriver(rtn)\n      .count(`*`, { as: 'count' })\n      .where(qb => {\n        qb.whereNotIn(\n          rcn,\n          this.dbDriver(rtn)\n            .select(`${rtn}.${rcn}`)\n            .join(vtn, `${rtn}.${rcn}`, `${vtn}.${vrcn}`)\n            .whereIn(\n              `${vtn}.${vcn}`,\n              this.dbDriver(parentTable.table_name)\n                .select(cn)\n                // .where(parentTable.primaryKey.cn, pid)\n                .where(_wherePk(parentTable.primaryKeys, pid))\n            )\n        ).orWhereNull(rcn);\n      });\n\n    const aliasColObjMap = await childTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n\n    await conditionV2(filterObj, qb, this.dbDriver);\n    return (await qb.first())?.count;\n  }\n\n  // todo: naming & optimizing\n  public async getMmChildrenExcludedList(\n    { colId, pid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const childModel = await Model.getBaseModelSQL({\n      dbDriver: this.dbDriver,\n      model: childTable\n    });\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n    const rtn = childTable.table_name;\n\n    const qb = this.dbDriver(rtn).where(qb =>\n      qb\n        .whereNotIn(\n          rcn,\n          this.dbDriver(rtn)\n            .select(`${rtn}.${rcn}`)\n            .join(vtn, `${rtn}.${rcn}`, `${vtn}.${vrcn}`)\n            .whereIn(\n              `${vtn}.${vcn}`,\n              this.dbDriver(parentTable.table_name)\n                .select(cn)\n                // .where(parentTable.primaryKey.cn, pid)\n                .where(_wherePk(parentTable.primaryKeys, pid))\n            )\n        )\n        .orWhereNull(rcn)\n    );\n\n    await childModel.selectObject({ qb });\n\n    const aliasColObjMap = await childTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n    await conditionV2(filterObj, qb, this.dbDriver);\n\n    applyPaginate(qb, args);\n\n    const proto = await childModel.getProto();\n\n    return (await qb).map(c => {\n      c.__proto__ = proto;\n      return c;\n    });\n  }\n\n  // todo: naming & optimizing\n  public async getHmChildrenExcludedListCount(\n    { colId, pid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const childTable = await (await relColOptions.getChildColumn()).getModel();\n    const parentTable = await (\n      await relColOptions.getParentColumn()\n    ).getModel();\n    const tn = childTable.table_name;\n    const rtn = parentTable.table_name;\n    await parentTable.getColumns();\n\n    const qb = this.dbDriver(tn)\n      .count(`*`, { as: 'count' })\n      .where(qb => {\n        qb.whereNotIn(\n          cn,\n          this.dbDriver(rtn)\n            .select(rcn)\n            // .where(parentTable.primaryKey.cn, pid)\n            .where(_wherePk(parentTable.primaryKeys, pid))\n        ).orWhereNull(cn);\n      });\n\n    const aliasColObjMap = await childTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n\n    await conditionV2(filterObj, qb, this.dbDriver);\n\n    return (await qb.first())?.count;\n  }\n\n  // todo: naming & optimizing\n  public async getHmChildrenExcludedList(\n    { colId, pid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const childTable = await (await relColOptions.getChildColumn()).getModel();\n    const parentTable = await (\n      await relColOptions.getParentColumn()\n    ).getModel();\n    const childModel = await Model.getBaseModelSQL({\n      dbDriver: this.dbDriver,\n      model: childTable\n    });\n    await parentTable.getColumns();\n\n    const tn = childTable.table_name;\n    const rtn = parentTable.table_name;\n\n    const qb = this.dbDriver(tn).where(qb => {\n      qb.whereNotIn(\n        cn,\n        this.dbDriver(rtn)\n          .select(rcn)\n          // .where(parentTable.primaryKey.cn, pid)\n          .where(_wherePk(parentTable.primaryKeys, pid))\n      ).orWhereNull(cn);\n    });\n\n    await childModel.selectObject({ qb });\n\n    const aliasColObjMap = await childTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n    await conditionV2(filterObj, qb, this.dbDriver);\n\n    applyPaginate(qb, args);\n\n    const proto = await childModel.getProto();\n\n    return (await qb).map(c => {\n      c.__proto__ = proto;\n      return c;\n    });\n  }\n\n  // todo: naming & optimizing\n  public async getBtChildrenExcludedListCount(\n    { colId, cid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const parentTable = await (\n      await relColOptions.getParentColumn()\n    ).getModel();\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getChildColumn()).getModel();\n\n    const rtn = parentTable.table_name;\n    const tn = childTable.table_name;\n    await childTable.getColumns();\n\n    const qb = this.dbDriver(rtn)\n      .where(qb => {\n        qb.whereNotIn(\n          rcn,\n          this.dbDriver(tn)\n            .select(cn)\n            // .where(childTable.primaryKey.cn, cid)\n            .where(_wherePk(childTable.primaryKeys, cid))\n        ).orWhereNull(rcn);\n      })\n      .count(`*`, { as: 'count' });\n\n    const aliasColObjMap = await parentTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n\n    await conditionV2(filterObj, qb, this.dbDriver);\n    return (await qb.first())?.count;\n  }\n\n  // todo: naming & optimizing\n  public async getBtChildrenExcludedList(\n    { colId, cid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const parentTable = await (\n      await relColOptions.getParentColumn()\n    ).getModel();\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getChildColumn()).getModel();\n    const parentModel = await Model.getBaseModelSQL({\n      dbDriver: this.dbDriver,\n      model: parentTable\n    });\n    const rtn = parentTable.table_name;\n    const tn = childTable.table_name;\n    await childTable.getColumns();\n\n    const qb = this.dbDriver(rtn).where(qb => {\n      qb.whereNotIn(\n        rcn,\n        this.dbDriver(tn)\n          .select(cn)\n          // .where(childTable.primaryKey.cn, cid)\n          .where(_wherePk(childTable.primaryKeys, cid))\n          .whereNotNull(cn)\n      ).orWhereNull(rcn);\n    });\n\n    await parentModel.selectObject({ qb });\n\n    const aliasColObjMap = await parentTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n    await conditionV2(filterObj, qb, this.dbDriver);\n\n    applyPaginate(qb, args);\n\n    const proto = await parentModel.getProto();\n\n    return (await qb).map(c => {\n      c.__proto__ = proto;\n      return c;\n    });\n  }\n\n  async getProto() {\n    if (this._proto) {\n      return this._proto;\n    }\n\n    const proto: any = { __columnAliases: {} };\n    const columns = await this.model.getColumns();\n    for (const column of columns) {\n      switch (column.uidt) {\n        case UITypes.Rollup:\n          {\n            // @ts-ignore\n            const colOptions: RollupColumn = await column.getColOptions();\n          }\n          break;\n        case UITypes.Lookup:\n          {\n            // @ts-ignore\n            const colOptions: LookupColumn = await column.getColOptions();\n            proto.__columnAliases[column.title] = {\n              path: [\n                (await Column.get({ colId: colOptions.fk_relation_column_id }))\n                  ?.title,\n                (await Column.get({ colId: colOptions.fk_lookup_column_id }))\n                  ?.title\n              ]\n            };\n          }\n          break;\n        case UITypes.LinkToAnotherRecord:\n          {\n            this._columns[column.title] = column;\n            const colOptions = (await column.getColOptions()) as LinkToAnotherRecordColumn;\n            // const parentColumn = await colOptions.getParentColumn();\n\n            if (colOptions?.type === 'hm') {\n              const listLoader = new DataLoader(async (ids: string[]) => {\n                try {\n                  if (ids.length > 1) {\n                    const data = await this.multipleHmList(\n                      {\n                        colId: column.id,\n                        ids\n                      },\n                      (listLoader as any).args\n                    );\n                    return ids.map((id: string) => (data[id] ? data[id] : []));\n                  } else {\n                    return [\n                      await this.hmList(\n                        {\n                          colId: column.id,\n                          id: ids[0]\n                        },\n                        (listLoader as any).args\n                      )\n                    ];\n                  }\n                } catch (e) {\n                  console.log(e);\n                  return [];\n                }\n              });\n              const self: BaseModelSqlv2 = this;\n\n              proto[column.title] = async function(args): Promise<any> {\n                (listLoader as any).args = args;\n                return listLoader.load(\n                  getCompositePk(self.model.primaryKeys, this)\n                );\n              };\n\n              // defining HasMany count method within GQL Type class\n              // Object.defineProperty(type.prototype, column.alias, {\n              //   async value(): Promise<any> {\n              //     return listLoader.load(this[model.pk.alias]);\n              //   },\n              //   configurable: true\n              // });\n            } else if (colOptions.type === 'mm') {\n              const listLoader = new DataLoader(async (ids: string[]) => {\n                try {\n                  if (ids?.length > 1) {\n                    const data = await this.multipleMmList(\n                      {\n                        parentIds: ids,\n                        colId: column.id\n                      },\n                      (listLoader as any).args\n                    );\n\n                    return data;\n                  } else {\n                    return [\n                      await this.mmList(\n                        {\n                          parentId: ids[0],\n                          colId: column.id\n                        },\n                        (listLoader as any).args\n                      )\n                    ];\n                  }\n                } catch (e) {\n                  console.log(e);\n                  return [];\n                }\n              });\n\n              const self: BaseModelSqlv2 = this;\n              // const childColumn = await colOptions.getChildColumn();\n              proto[column.title] = async function(args): Promise<any> {\n                (listLoader as any).args = args;\n                return await listLoader.load(\n                  getCompositePk(self.model.primaryKeys, this)\n                );\n              };\n            } else if (colOptions.type === 'bt') {\n              // @ts-ignore\n              const colOptions = (await column.getColOptions()) as LinkToAnotherRecordColumn;\n              const pCol = await Column.get({\n                colId: colOptions.fk_parent_column_id\n              });\n              const cCol = await Column.get({\n                colId: colOptions.fk_child_column_id\n              });\n              const readLoader = new DataLoader(async (ids: string[]) => {\n                try {\n                  const data = await (\n                    await Model.getBaseModelSQL({\n                      id: pCol.fk_model_id,\n                      dbDriver: this.dbDriver\n                    })\n                  ).list(\n                    {\n                      // limit: ids.length,\n                      where: `(${pCol.column_name},in,${ids.join(',')})`\n                    },\n                    true\n                  );\n                  const gs = _.groupBy(data, pCol.title);\n                  return ids.map(async (id: string) => gs?.[id]?.[0]);\n                } catch (e) {\n                  console.log(e);\n                  return [];\n                }\n              });\n\n              // defining HasMany count method within GQL Type class\n              proto[column.title] = async function() {\n                if (\n                  this?.[cCol?.title] === null ||\n                  this?.[cCol?.title] === undefined\n                )\n                  return null;\n\n                return await readLoader.load(this?.[cCol?.title]);\n              };\n              // todo : handle mm\n            }\n          }\n          break;\n      }\n    }\n    this._proto = proto;\n    return proto;\n  }\n\n  _getListArgs(args: XcFilterWithAlias): XcFilter {\n    const obj: XcFilter = {};\n    obj.where = args.where || args.w || '';\n    obj.having = args.having || args.h || '';\n    obj.condition = args.condition || args.c || {};\n    obj.conditionGraph = args.conditionGraph || {};\n    obj.limit = Math.max(\n      Math.min(\n        args.limit || args.l || this.config.limitDefault,\n        this.config.limitMax\n      ),\n      this.config.limitMin\n    );\n    obj.offset = Math.max(+(args.offset || args.o) || 0, 0);\n    obj.fields = args.fields || args.f || '*';\n    obj.sort = args.sort || args.s || this.model.primaryKey?.[0]?.tn;\n    return obj;\n  }\n\n  public async selectObject({ qb }: { qb: QueryBuilder }): Promise<void> {\n    const res = {};\n    const columns = await this.model.getColumns();\n    for (const column of columns) {\n      switch (column.uidt) {\n        case 'LinkToAnotherRecord':\n        case 'Lookup':\n          break;\n        case 'Formula':\n          {\n            const formula = await column.getColOptions<FormulaColumn>();\n            if (formula.error) continue;\n            const selectQb = await formulaQueryBuilderv2(\n              formula.formula,\n              null,\n              this.dbDriver,\n              this.model\n              // this.aliasToColumn\n            );\n            // todo:  verify syntax of as ? / ??\n            qb.select(\n              this.dbDriver.raw(`?? as ??`, [\n                selectQb.builder,\n                sanitize(column.title)\n              ])\n            );\n          }\n          break;\n        case 'Rollup':\n          qb.select(\n            (\n              await genRollupSelectv2({\n                // tn: this.title,\n                knex: this.dbDriver,\n                // column,\n                columnOptions: (await column.getColOptions()) as RollupColumn\n              })\n            ).builder.as(sanitize(column.title))\n          );\n          break;\n        default:\n          res[sanitize(column.title || column.column_name)] = sanitize(\n            `${this.model.table_name}.${column.column_name}`\n          );\n          break;\n      }\n    }\n    qb.select(res);\n  }\n\n  async insert(data, trx?, cookie?) {\n    try {\n      await populatePk(this.model, data);\n\n      // todo: filter based on view\n      const insertObj = await this.model.mapAliasToColumn(data, sanitize);\n\n      await this.validate(insertObj);\n\n      if ('beforeInsert' in this) {\n        await this.beforeInsert(insertObj, trx, cookie);\n      }\n\n      // if ('beforeInsert' in this) {\n      //   await this.beforeInsert(insertObj, trx, cookie);\n      // }\n      await this.model.getColumns();\n      let response;\n      // const driver = trx ? trx : this.dbDriver;\n\n      const query = this.dbDriver(this.tnPath).insert(insertObj);\n\n      if (this.isPg || this.isMssql) {\n        query.returning(\n          `${this.model.primaryKey.column_name} as ${this.model.primaryKey.title}`\n        );\n        response = await query;\n      }\n\n      const ai = this.model.columns.find(c => c.ai);\n      if (\n        !response ||\n        (typeof response?.[0] !== 'object' && response?.[0] !== null)\n      ) {\n        let id;\n        if (response?.length) {\n          id = response[0];\n        } else {\n          id = (await query)[0];\n        }\n\n        if (ai) {\n          // response = await this.readByPk(id)\n          response = await this.readByPk(id);\n        } else {\n          response = data;\n        }\n      } else if (ai) {\n        response = await this.readByPk(\n          Array.isArray(response)\n            ? response?.[0]?.[ai.title]\n            : response?.[ai.title]\n        );\n      }\n\n      await this.afterInsert(response, trx, cookie);\n      return Array.isArray(response) ? response[0] : response;\n    } catch (e) {\n      console.log(e);\n      await this.errorInsert(e, data, trx, cookie);\n      throw e;\n    }\n  }\n\n  async delByPk(id, trx?, cookie?) {\n    try {\n      // retrieve data for handling paramas in hook\n      const data = await this.readByPk(id);\n      await this.beforeDelete(id, trx, cookie);\n      const response = await this.dbDriver(this.tnPath)\n        .del()\n        .where(await this._wherePk(id));\n      await this.afterDelete(data, trx, cookie);\n      return response;\n    } catch (e) {\n      console.log(e);\n      await this.errorDelete(e, id, trx, cookie);\n      throw e;\n    }\n  }\n\n  async updateByPk(id, data, trx?, cookie?) {\n    try {\n      const updateObj = await this.model.mapAliasToColumn(data);\n\n      await this.validate(data);\n\n      await this.beforeUpdate(data, trx, cookie);\n\n      // const driver = trx ? trx : this.dbDriver;\n      //\n      // this.validate(data);\n      // await this._run(\n      await this.dbDriver(this.tnPath)\n        .update(updateObj)\n        .where(await this._wherePk(id));\n      // );\n\n      const response = await this.readByPk(id);\n      await this.afterUpdate(response, trx, cookie);\n      return response;\n    } catch (e) {\n      console.log(e);\n      await this.errorUpdate(e, data, trx, cookie);\n      throw e;\n    }\n  }\n\n  async _wherePk(id) {\n    await this.model.getColumns();\n    return _wherePk(this.model.primaryKeys, id);\n  }\n\n  public get tnPath() {\n    const schema = (this.dbDriver as any).searchPath?.();\n    const table =\n      this.isMssql && schema\n        ? this.dbDriver.raw('??.??', [schema, this.model.table_name])\n        : this.model.table_name;\n    return table;\n  }\n\n  get isSqlite() {\n    return this.clientType === 'sqlite3';\n  }\n\n  get isMssql() {\n    return this.clientType === 'mssql';\n  }\n\n  get isPg() {\n    return this.clientType === 'pg';\n  }\n\n  get isMySQL() {\n    return this.clientType === 'mysql2' || this.clientType === 'mysql';\n  }\n\n  get clientType() {\n    return this.dbDriver.clientType();\n  }\n\n  async nestedInsert(data, _trx = null, cookie?) {\n    // const driver = trx ? trx : await this.dbDriver.transaction();\n    try {\n      await populatePk(this.model, data);\n      const insertObj = await this.model.mapAliasToColumn(data);\n\n      let rowId = null;\n      const postInsertOps = [];\n\n      const nestedCols = (await this.model.getColumns()).filter(\n        c => c.uidt === UITypes.LinkToAnotherRecord\n      );\n\n      for (const col of nestedCols) {\n        if (col.title in data) {\n          const colOptions = await col.getColOptions<\n            LinkToAnotherRecordColumn\n          >();\n\n          // parse data if it's JSON string\n          const nestedData =\n            typeof data[col.title] === 'string'\n              ? JSON.parse(data[col.title])\n              : data[col.title];\n\n          switch (colOptions.type) {\n            case RelationTypes.BELONGS_TO:\n              {\n                const parentCol = await colOptions.getChildColumn();\n                insertObj[parentCol.column_name] =\n                  nestedData?.[parentCol.title];\n              }\n              break;\n            case RelationTypes.HAS_MANY:\n              {\n                const childCol = await colOptions.getChildColumn();\n                const childModel = await childCol.getModel();\n                await childModel.getColumns();\n\n                postInsertOps.push(async () => {\n                  await this.dbDriver(childModel.table_name)\n                    .update({\n                      [childCol.column_name]: rowId\n                    })\n                    .whereIn(\n                      childModel.primaryKey.column_name,\n                      nestedData?.map(r => r[childModel.primaryKey.title])\n                    );\n                });\n              }\n              break;\n            case RelationTypes.MANY_TO_MANY: {\n              postInsertOps.push(async () => {\n                const parentModel = await colOptions\n                  .getParentColumn()\n                  .then(c => c.getModel());\n                await parentModel.getColumns();\n                const parentMMCol = await colOptions.getMMParentColumn();\n                const childMMCol = await colOptions.getMMChildColumn();\n                const mmModel = await colOptions.getMMModel();\n\n                const rows = nestedData.map(r => ({\n                  [parentMMCol.column_name]: r[parentModel.primaryKey.title],\n                  [childMMCol.column_name]: rowId\n                }));\n                await this.dbDriver(mmModel.table_name).insert(rows);\n              });\n            }\n          }\n        }\n      }\n\n      await this.validate(insertObj);\n\n      await this.beforeInsert(insertObj, this.dbDriver, cookie);\n\n      let response;\n      const query = this.dbDriver(this.tnPath).insert(insertObj);\n\n      if (this.isPg || this.isMssql) {\n        query.returning(\n          `${this.model.primaryKey.column_name} as ${this.model.primaryKey.title}`\n        );\n        response = await query;\n      }\n\n      const ai = this.model.columns.find(c => c.ai);\n      if (\n        !response ||\n        (typeof response?.[0] !== 'object' && response?.[0] !== null)\n      ) {\n        let id;\n        if (response?.length) {\n          id = response[0];\n        } else {\n          id = (await query)[0];\n        }\n\n        if (ai) {\n          // response = await this.readByPk(id)\n          response = await this.readByPk(id);\n        } else {\n          response = data;\n        }\n      } else if (ai) {\n        response = await this.readByPk(\n          Array.isArray(response)\n            ? response?.[0]?.[ai.title]\n            : response?.[ai.title]\n        );\n      }\n      response = Array.isArray(response) ? response[0] : response;\n      if (response)\n        rowId =\n          response[this.model.primaryKey.title] ||\n          response[this.model.primaryKey.column_name];\n      await Promise.all(postInsertOps.map(f => f()));\n\n      // if (!trx) {\n      //   await driver.commit();\n      // }\n\n      await this.afterInsert(response, this.dbDriver, cookie);\n\n      return response;\n    } catch (e) {\n      console.log(e);\n      // await this.errorInsert(e, data, trx, cookie);\n      // if (!trx) {\n      //   await driver.rollback(e);\n      // }\n      throw e;\n    }\n  }\n\n  async bulkInsert(\n    datas: any[],\n    {\n      chunkSize: _chunkSize = 100\n    }: {\n      chunkSize?: number;\n    } = {}\n  ) {\n    try {\n      const insertDatas = await Promise.all(\n        datas.map(async d => {\n          await populatePk(this.model, d);\n          return this.model.mapAliasToColumn(d);\n        })\n      );\n\n      // await this.beforeInsertb(insertDatas, null);\n\n      for (const data of datas) {\n        await this.validate(data);\n      }\n      // let chunkSize = 50;\n      //\n      // if (this.isSqlite && datas[0]) {\n      //   chunkSize = Math.max(1, Math.floor(999 / Object.keys(datas[0]).length));\n      // }\n\n      // fallbacks to `10` if database client is sqlite\n      // to avoid `too many SQL variables` error\n      // refer : https://www.sqlite.org/limits.html\n      const chunkSize = this.isSqlite ? 10 : _chunkSize;\n\n      const response = await this.dbDriver\n        .batchInsert(this.model.table_name, insertDatas, chunkSize)\n        .returning(this.model.primaryKey?.column_name);\n\n      // await this.afterInsertb(insertDatas, null);\n\n      return response;\n    } catch (e) {\n      // await this.errorInsertb(e, data, null);\n      throw e;\n    }\n  }\n\n  async bulkUpdate(datas: any[]) {\n    let transaction;\n    try {\n      const updateDatas = await Promise.all(\n        datas.map(d => this.model.mapAliasToColumn(d))\n      );\n\n      transaction = await this.dbDriver.transaction();\n\n      // await this.beforeUpdateb(updateDatas, transaction);\n      const res = [];\n      for (const d of updateDatas) {\n        await this.validate(d);\n        const pkValues = await this._extractPksValues(d);\n        if (!pkValues) {\n          // pk not specified - bypass\n          continue;\n        }\n        const wherePk = await this._wherePk(pkValues);\n        const response = await transaction(this.model.table_name)\n          .update(d)\n          .where(wherePk);\n        res.push(response);\n      }\n\n      // await this.afterUpdateb(res, transaction);\n      transaction.commit();\n\n      return res;\n    } catch (e) {\n      if (transaction) transaction.rollback();\n      // console.log(e);\n      // await this.errorUpdateb(e, data, null);\n      throw e;\n    }\n  }\n\n  async bulkUpdateAll(\n    args: { where?: string; filterArr?: Filter[] } = {},\n    data\n  ) {\n    try {\n      const updateData = await this.model.mapAliasToColumn(data);\n      await this.validate(updateData);\n      const pkValues = await this._extractPksValues(updateData);\n      let res = null;\n      if (pkValues) {\n        // pk is specified - by pass\n      } else {\n        await this.model.getColumns();\n        const { where } = this._getListArgs(args);\n        const qb = this.dbDriver(this.model.table_name);\n        const aliasColObjMap = await this.model.getAliasColObjMap();\n        const filterObj = extractFilterFromXwhere(where, aliasColObjMap);\n\n        await conditionV2(\n          [\n            new Filter({\n              children: args.filterArr || [],\n              is_group: true,\n              logical_op: 'and'\n            }),\n            new Filter({\n              children: filterObj,\n              is_group: true,\n              logical_op: 'and'\n            }),\n            ...(args.filterArr || [])\n          ],\n          qb,\n          this.dbDriver\n        );\n        qb.update(updateData);\n        res = ((await qb) as any).count;\n      }\n      return res;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async bulkDelete(ids: any[]) {\n    let transaction;\n    try {\n      transaction = await this.dbDriver.transaction();\n      // await this.beforeDeleteb(ids, transaction);\n\n      const res = [];\n      for (const d of ids) {\n        if (Object.keys(d).length) {\n          const response = await transaction(this.model.table_name)\n            .del()\n            .where(d);\n          res.push(response);\n        }\n      }\n      // await this.afterDeleteb(res, transaction);\n\n      transaction.commit();\n\n      return res;\n    } catch (e) {\n      if (transaction) transaction.rollback();\n      console.log(e);\n      // await this.errorDeleteb(e, ids);\n      throw e;\n    }\n  }\n\n  async bulkDeleteAll(args: { where?: string; filterArr?: Filter[] } = {}) {\n    try {\n      await this.model.getColumns();\n      const { where } = this._getListArgs(args);\n      const qb = this.dbDriver(this.model.table_name);\n      const aliasColObjMap = await this.model.getAliasColObjMap();\n      const filterObj = extractFilterFromXwhere(where, aliasColObjMap);\n\n      await conditionV2(\n        [\n          new Filter({\n            children: args.filterArr || [],\n            is_group: true,\n            logical_op: 'and'\n          }),\n          new Filter({\n            children: filterObj,\n            is_group: true,\n            logical_op: 'and'\n          }),\n          ...(args.filterArr || [])\n        ],\n        qb,\n        this.dbDriver\n      );\n      qb.del();\n      return ((await qb) as any).count;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  /**\n   *  Hooks\n   * */\n\n  public async beforeInsert(data: any, _trx: any, req): Promise<void> {\n    await this.handleHooks('Before.insert', data, req);\n  }\n\n  public async afterInsert(data: any, _trx: any, req): Promise<void> {\n    await this.handleHooks('After.insert', data, req);\n    // if (req?.headers?.['xc-gui']) {\n    const id = this._extractPksValues(data);\n    Audit.insert({\n      fk_model_id: this.model.id,\n      row_id: id,\n      op_type: AuditOperationTypes.DATA,\n      op_sub_type: AuditOperationSubTypes.INSERT,\n      description: `${id} inserted into ${this.model.title}`,\n      // details: JSON.stringify(data),\n      ip: req?.clientIp,\n      user: req?.user?.email\n    });\n    // }\n  }\n\n  public async beforeUpdate(data: any, _trx: any, req): Promise<void> {\n    const ignoreWebhook = req.query?.ignoreWebhook;\n    if (ignoreWebhook) {\n      if (ignoreWebhook != 'true' && ignoreWebhook != 'false') {\n        throw new Error('ignoreWebhook value can be either true or false');\n      }\n    }\n    if (ignoreWebhook === undefined || ignoreWebhook === 'false') {\n      await this.handleHooks('Before.update', data, req);\n    }\n  }\n\n  public async afterUpdate(data: any, _trx: any, req): Promise<void> {\n    const ignoreWebhook = req.query?.ignoreWebhook;\n    if (ignoreWebhook) {\n      if (ignoreWebhook != 'true' && ignoreWebhook != 'false') {\n        throw new Error('ignoreWebhook value can be either true or false');\n      }\n    }\n    if (ignoreWebhook === undefined || ignoreWebhook === 'false') {\n      await this.handleHooks('After.update', data, req);\n    }\n  }\n\n  public async beforeDelete(data: any, _trx: any, req): Promise<void> {\n    await this.handleHooks('Before.delete', data, req);\n  }\n\n  public async afterDelete(data: any, _trx: any, req): Promise<void> {\n    // if (req?.headers?.['xc-gui']) {\n    const id = req?.params?.id;\n    Audit.insert({\n      fk_model_id: this.model.id,\n      row_id: id,\n      op_type: AuditOperationTypes.DATA,\n      op_sub_type: AuditOperationSubTypes.DELETE,\n      description: `${id} deleted from ${this.model.title}`,\n      // details: JSON.stringify(data),\n      ip: req?.clientIp,\n      user: req?.user?.email\n    });\n    // }\n    await this.handleHooks('After.delete', data, req);\n  }\n\n  private async handleHooks(hookName, data, req): Promise<void> {\n    // const data = _data;\n\n    const view = await View.get(this.viewId);\n\n    // handle form view data submission\n    if (hookName === 'After.insert' && view.type === ViewTypes.FORM) {\n      try {\n        const formView = await view.getView<FormView>();\n        const emails = Object.entries(JSON.parse(formView?.email) || {})\n          .filter(a => a[1])\n          .map(a => a[0]);\n        if (emails?.length) {\n          const transformedData = _transformSubmittedFormDataForEmail(\n            data,\n            formView,\n            await this.model.getColumns()\n          );\n          // todo: notification template\n          (await NcPluginMgrv2.emailAdapter())?.mailSend({\n            to: emails.join(','),\n            subject: parseBody('NocoDB Form', req, data, {}),\n            html: ejs.render(formSubmissionEmailTemplate, {\n              data: transformedData,\n              tn: this.model.table_name,\n              _tn: this.model.title\n            })\n          });\n        }\n      } catch (e) {\n        console.log(e);\n      }\n    }\n\n    try {\n      const [event, operation] = hookName.split('.');\n      const hooks = await Hook.list({\n        fk_model_id: this.model.id,\n        event,\n        operation\n      });\n      for (const hook of hooks) {\n        invokeWebhook(hook, this.model, data, req?.user);\n      }\n    } catch (e) {\n      console.log('hooks :: error', hookName, e);\n    }\n  }\n\n  // @ts-ignore\n  protected async errorInsert(e, data, trx, cookie) {}\n\n  // @ts-ignore\n  protected async errorUpdate(e, data, trx, cookie) {}\n\n  // todo: handle composite primary key\n  protected _extractPksValues(data: any) {\n    // data can be still inserted without PK\n    // TODO: return a meaningful value\n    if (!this.model.primaryKey) return 'N/A';\n    return (\n      data[this.model.primaryKey.title] ||\n      data[this.model.primaryKey.column_name]\n    );\n  }\n\n  // @ts-ignore\n  protected async errorDelete(e, id, trx, cookie) {}\n\n  async validate(columns) {\n    await this.model.getColumns();\n    // let cols = Object.keys(this.columns);\n    for (let i = 0; i < this.model.columns.length; ++i) {\n      const column = this.model.columns[i];\n      // skip validation if `validate` is undefined or false\n      if (!column?.meta?.validate) continue;\n\n      const validate = column.getValidators();\n      const cn = column.column_name;\n      if (!validate) continue;\n      const { func, msg } = validate;\n      for (let j = 0; j < func.length; ++j) {\n        const fn =\n          typeof func[j] === 'string'\n            ? customValidators[func[j]]\n              ? customValidators[func[j]]\n              : Validator[func[j]]\n            : func[j];\n        const arg =\n          typeof func[j] === 'string' ? columns[cn] + '' : columns[cn];\n        if (\n          columns[cn] !== null &&\n          columns[cn] !== undefined &&\n          columns[cn] !== '' &&\n          cn in columns &&\n          !(fn.constructor.name === 'AsyncFunction' ? await fn(arg) : fn(arg))\n        ) {\n          NcError.badRequest(\n            msg[j].replace(/\\{VALUE}/g, columns[cn]).replace(/\\{cn}/g, cn)\n          );\n        }\n      }\n    }\n    return true;\n  }\n\n  async addChild({\n    colId,\n    rowId,\n    childId\n  }: {\n    colId: string;\n    rowId: string;\n    childId: string;\n  }) {\n    const columns = await this.model.getColumns();\n    const column = columns.find(c => c.id === colId);\n\n    if (!column || column.uidt !== UITypes.LinkToAnotherRecord)\n      NcError.notFound('Column not found');\n\n    const colOptions = await column.getColOptions<LinkToAnotherRecordColumn>();\n\n    const childColumn = await colOptions.getChildColumn();\n    const parentColumn = await colOptions.getParentColumn();\n    const parentTable = await parentColumn.getModel();\n    const childTable = await childColumn.getModel();\n    await childTable.getColumns();\n    await parentTable.getColumns();\n\n    switch (colOptions.type) {\n      case RelationTypes.MANY_TO_MANY:\n        {\n          const vChildCol = await colOptions.getMMChildColumn();\n          const vParentCol = await colOptions.getMMParentColumn();\n          const vTable = await colOptions.getMMModel();\n\n          await this.dbDriver(vTable.table_name).insert({\n            [vParentCol.column_name]: this.dbDriver(parentTable.table_name)\n              .select(parentColumn.column_name)\n              .where(_wherePk(parentTable.primaryKeys, childId))\n              .first(),\n            [vChildCol.column_name]: this.dbDriver(childTable.table_name)\n              .select(childColumn.column_name)\n              .where(_wherePk(childTable.primaryKeys, rowId))\n              .first()\n          });\n        }\n        break;\n      case RelationTypes.HAS_MANY:\n        {\n          await this.dbDriver(childTable.table_name)\n            .update({\n              [childColumn.column_name]: this.dbDriver.from(\n                this.dbDriver(parentTable.table_name)\n                  .select(parentColumn.column_name)\n                  .where(_wherePk(parentTable.primaryKeys, rowId))\n                  .first()\n                  .as('___cn_alias')\n              )\n            })\n            .where(_wherePk(childTable.primaryKeys, childId));\n        }\n        break;\n      case RelationTypes.BELONGS_TO:\n        {\n          await this.dbDriver(childTable.table_name)\n            .update({\n              [childColumn.column_name]: this.dbDriver.from(\n                this.dbDriver(parentTable.table_name)\n                  .select(parentColumn.column_name)\n                  .where(_wherePk(parentTable.primaryKeys, childId))\n                  .first()\n                  .as('___cn_alias')\n              )\n            })\n            .where(_wherePk(childTable.primaryKeys, rowId));\n        }\n        break;\n    }\n  }\n\n  async removeChild({\n    colId,\n    rowId,\n    childId\n  }: {\n    colId: string;\n    rowId: string;\n    childId: string;\n  }) {\n    const columns = await this.model.getColumns();\n    const column = columns.find(c => c.id === colId);\n\n    if (!column || column.uidt !== UITypes.LinkToAnotherRecord)\n      NcError.notFound('Column not found');\n\n    const colOptions = await column.getColOptions<LinkToAnotherRecordColumn>();\n\n    const childColumn = await colOptions.getChildColumn();\n    const parentColumn = await colOptions.getParentColumn();\n    const parentTable = await parentColumn.getModel();\n    const childTable = await childColumn.getModel();\n    await childTable.getColumns();\n    await parentTable.getColumns();\n\n    switch (colOptions.type) {\n      case RelationTypes.MANY_TO_MANY:\n        {\n          const vChildCol = await colOptions.getMMChildColumn();\n          const vParentCol = await colOptions.getMMParentColumn();\n          const vTable = await colOptions.getMMModel();\n\n          await this.dbDriver(vTable.table_name)\n            .where({\n              [vParentCol.column_name]: this.dbDriver(parentTable.table_name)\n                .select(parentColumn.column_name)\n                .where(_wherePk(parentTable.primaryKeys, childId))\n                .first(),\n              [vChildCol.column_name]: this.dbDriver(childTable.table_name)\n                .select(childColumn.column_name)\n                .where(_wherePk(childTable.primaryKeys, rowId))\n                .first()\n            })\n            .delete();\n        }\n        break;\n      case RelationTypes.HAS_MANY:\n        {\n          await this.dbDriver(childTable.table_name)\n            // .where({\n            //   [childColumn.cn]: this.dbDriver(parentTable.tn)\n            //     .select(parentColumn.cn)\n            //     .where(parentTable.primaryKey.cn, rowId)\n            //     .first()\n            // })\n            .where(_wherePk(childTable.primaryKeys, childId))\n            .update({ [childColumn.column_name]: null });\n        }\n        break;\n      case RelationTypes.BELONGS_TO:\n        {\n          await this.dbDriver(childTable.table_name)\n            // .where({\n            //   [childColumn.cn]: this.dbDriver(parentTable.tn)\n            //     .select(parentColumn.cn)\n            //     .where(parentTable.primaryKey.cn, childId)\n            //     .first()\n            // })\n            .where(_wherePk(childTable.primaryKeys, rowId))\n            .update({ [childColumn.column_name]: null });\n        }\n        break;\n    }\n  }\n\n  private async extractRawQueryAndExec(qb: QueryBuilder) {\n    return this.isPg\n      ? qb\n      : await this.dbDriver.from(\n          this.dbDriver.raw(qb.toString()).wrap('(', ') __nc_alias')\n        );\n  }\n}\n\nfunction extractSortsObject(\n  _sorts: string | string[],\n  aliasColObjMap: { [columnAlias: string]: Column }\n): Sort[] | void {\n  if (!_sorts?.length) return;\n\n  let sorts = _sorts;\n\n  if (!Array.isArray(sorts)) sorts = sorts.split(',');\n\n  return sorts.map(s => {\n    const sort: SortType = { direction: 'asc' };\n    if (s.startsWith('-')) {\n      sort.direction = 'desc';\n      sort.fk_column_id = aliasColObjMap[s.slice(1)]?.id;\n    } else sort.fk_column_id = aliasColObjMap[s]?.id;\n\n    return new Sort(sort);\n  });\n}\n\nfunction extractFilterFromXwhere(\n  str,\n  aliasColObjMap: { [columnAlias: string]: Column }\n) {\n  if (!str) {\n    return [];\n  }\n\n  let nestedArrayConditions = [];\n\n  let openIndex = str.indexOf('((');\n\n  if (openIndex === -1) openIndex = str.indexOf('(~');\n\n  let nextOpenIndex = openIndex;\n  let closingIndex = str.indexOf('))');\n\n  // if it's a simple query simply return array of conditions\n  if (openIndex === -1) {\n    if (str && str != '~not')\n      nestedArrayConditions = str.split(\n        /(?=~(?:or(?:not)?|and(?:not)?|not)\\()/\n      );\n    return extractCondition(nestedArrayConditions || [], aliasColObjMap);\n  }\n\n  // iterate until finding right closing\n  while (\n    (nextOpenIndex = str\n      .substring(0, closingIndex)\n      .indexOf('((', nextOpenIndex + 1)) != -1\n  ) {\n    closingIndex = str.indexOf('))', closingIndex + 1);\n  }\n\n  if (closingIndex === -1)\n    throw new Error(\n      `${str\n        .substring(0, openIndex + 1)\n        .slice(-10)} : Closing bracket not found`\n    );\n\n  // getting operand starting index\n  const operandStartIndex = str.lastIndexOf('~', openIndex);\n  const operator =\n    operandStartIndex != -1\n      ? str.substring(operandStartIndex + 1, openIndex)\n      : '';\n  const lhsOfNestedQuery = str.substring(0, openIndex);\n\n  nestedArrayConditions.push(\n    ...extractFilterFromXwhere(lhsOfNestedQuery, aliasColObjMap),\n    // calling recursively for nested query\n    new Filter({\n      is_group: true,\n      logical_op: operator,\n      children: extractFilterFromXwhere(\n        str.substring(openIndex + 1, closingIndex + 1),\n        aliasColObjMap\n      )\n    }),\n    // RHS of nested query(recursion)\n    ...extractFilterFromXwhere(str.substring(closingIndex + 2), aliasColObjMap)\n  );\n  return nestedArrayConditions;\n}\n\nfunction extractCondition(nestedArrayConditions, aliasColObjMap) {\n  return nestedArrayConditions?.map(str => {\n    // eslint-disable-next-line prefer-const\n    let [logicOp, alias, op, value] =\n      str.match(/(?:~(and|or|not))?\\((.*?),(\\w+),(.*)\\)/)?.slice(1) || [];\n    if (op === 'in') value = value.split(',');\n\n    return new Filter({\n      comparison_op: op,\n      fk_column_id: aliasColObjMap[alias]?.id,\n      logical_op: logicOp,\n      value\n    });\n  });\n}\n\nfunction applyPaginate(\n  query,\n  {\n    limit = 20,\n    offset = 0,\n    ignoreLimit = false\n  }: XcFilter & { ignoreLimit?: boolean }\n) {\n  query.offset(offset);\n  if (!ignoreLimit) query.limit(limit);\n\n  return query;\n}\n\nfunction _wherePk(primaryKeys: Column[], id) {\n  const ids = (id + '').split('___');\n  const where = {};\n  for (let i = 0; i < primaryKeys.length; ++i) {\n    where[primaryKeys[i].column_name] = ids[i];\n  }\n  return where;\n}\n\nfunction getCompositePk(primaryKeys: Column[], row) {\n  return primaryKeys.map(c => row[c.title]).join('___');\n}\n\nexport function sanitize(v) {\n  return v?.replace(/([^\\\\]|^)([?])/g, '$1\\\\$2');\n}\n\nexport { BaseModelSqlv2 };\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n * @author Wing-Kam Wong <wingkwong.code@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n", "import Handlebars from 'handlebars';\nimport Model from '../../models/Model';\nimport NcPluginMgrv2 from './NcPluginMgrv2';\nimport Column from '../../models/Column';\nimport Hook from '../../models/Hook';\nimport Filter from '../../models/Filter';\nimport HookLog from '../../models/HookLog';\nimport { HookLogType } from 'nocodb-sdk';\n\nexport function parseBody(\n  template: string,\n  user: any,\n  data: any,\n  payload: any\n): string {\n  if (!template) {\n    return template;\n  }\n\n  return Handlebars.compile(template, { noEscape: true })({\n    data,\n    user,\n    payload,\n    env: process.env\n  });\n}\n\nexport async function validateCondition(filters: Filter[], data: any) {\n  if (!filters.length) {\n    return true;\n  }\n\n  let isValid = true;\n  for (const _filter of filters) {\n    const filter = _filter instanceof Filter ? _filter : new Filter(_filter);\n    let res;\n    const field = await filter.getColumn().then(c => c.title);\n    let val = data[field];\n    switch (typeof filter.value) {\n      case 'boolean':\n        val = !!data[field];\n        break;\n      case 'number':\n        val = +data[field];\n        break;\n    }\n    switch (filter.comparison_op) {\n      case 'eq':\n        res = val == filter.value;\n        break;\n      case 'neq':\n        res = val != filter.value;\n        break;\n      case 'like':\n        res =\n          data[field]?.toLowerCase()?.indexOf(filter.value?.toLowerCase()) > -1;\n        break;\n      case 'nlike':\n        res =\n          data[field]?.toLowerCase()?.indexOf(filter.value?.toLowerCase()) ===\n          -1;\n        break;\n      case 'empty':\n        res =\n          data[field] === '' ||\n          data[field] === null ||\n          data[field] === undefined;\n        break;\n      case 'notempty':\n        res = !(\n          data[field] === '' ||\n          data[field] === null ||\n          data[field] === undefined\n        );\n        break;\n      case 'null':\n        res = res = data[field] === null;\n        break;\n      case 'notnull':\n        res = data[field] !== null;\n        break;\n      case 'lt':\n        res = +data[field] < +filter.value;\n        break;\n      case 'lte':\n      case 'le':\n        res = +data[field] <= +filter.value;\n        break;\n      case 'gt':\n        res = +data[field] > +filter.value;\n        break;\n      case 'gte':\n      case 'ge':\n        res = +data[field] >= +filter.value;\n        break;\n    }\n\n    switch (filter.logical_op) {\n      case 'or':\n        isValid = isValid || res;\n        break;\n      case 'not':\n        isValid = isValid && !res;\n        break;\n      case 'and':\n      default:\n        isValid = isValid && res;\n        break;\n    }\n  }\n\n  return isValid;\n}\n\nexport async function handleHttpWebHook(apiMeta, user, data) {\n  // try {\n  const req = axiosRequestMake(apiMeta, user, data);\n  await require('axios')(req);\n  // } catch (e) {\n  //   console.log(e);\n  // }\n}\n\nexport function axiosRequestMake(_apiMeta, user, data) {\n  const apiMeta = { ..._apiMeta };\n  if (apiMeta.body) {\n    try {\n      apiMeta.body = JSON.parse(apiMeta.body, (_key, value) => {\n        return typeof value === 'string'\n          ? parseBody(value, user, data, apiMeta)\n          : value;\n      });\n    } catch (e) {\n      apiMeta.body = parseBody(apiMeta.body, user, data, apiMeta);\n    }\n  }\n  if (apiMeta.auth) {\n    try {\n      apiMeta.auth = JSON.parse(apiMeta.auth, (_key, value) => {\n        return typeof value === 'string'\n          ? parseBody(value, user, data, apiMeta)\n          : value;\n      });\n    } catch (e) {\n      apiMeta.auth = parseBody(apiMeta.auth, user, data, apiMeta);\n    }\n  }\n  apiMeta.response = {};\n  const req = {\n    params: apiMeta.parameters\n      ? apiMeta.parameters.reduce((paramsObj, param) => {\n          if (param.name && param.enabled) {\n            paramsObj[param.name] = parseBody(param.value, user, data, apiMeta);\n          }\n          return paramsObj;\n        }, {})\n      : {},\n    url: parseBody(apiMeta.path, user, data, apiMeta),\n    method: apiMeta.method,\n    data: apiMeta.body,\n    headers: apiMeta.headers\n      ? apiMeta.headers.reduce((headersObj, header) => {\n          if (header.name && header.enabled) {\n            headersObj[header.name] = parseBody(\n              header.value,\n              user,\n              data,\n              apiMeta\n            );\n          }\n          return headersObj;\n        }, {})\n      : {},\n    withCredentials: true\n  };\n  return req;\n}\n\nexport async function invokeWebhook(\n  hook: Hook,\n  _model: Model,\n  data,\n  user,\n  testFilters = null,\n  throwErrorOnFailure = false\n) {\n  let hookLog: HookLogType;\n  const startTime = process.hrtime();\n  try {\n    // for (const hook of hooks) {\n    const notification =\n      typeof hook.notification === 'string'\n        ? JSON.parse(hook.notification)\n        : hook.notification;\n\n    if (hook.condition) {\n      if (\n        !(await validateCondition(\n          testFilters || (await hook.getFilters()),\n          data\n        ))\n      ) {\n        return;\n      }\n    }\n\n    switch (notification?.type) {\n      case 'Email':\n        {\n          const res = await (await NcPluginMgrv2.emailAdapter())?.mailSend({\n            to: parseBody(\n              notification?.payload?.to,\n              user,\n              data,\n              notification?.payload\n            ),\n            subject: parseBody(\n              notification?.payload?.subject,\n              user,\n              data,\n              notification?.payload\n            ),\n            html: parseBody(\n              notification?.payload?.body,\n              user,\n              data,\n              notification?.payload\n            )\n          });\n          hookLog = {\n            ...hook,\n            type: notification.type,\n            payload: JSON.stringify(notification?.payload),\n            response: JSON.stringify(res),\n            triggered_by: user?.email\n          };\n        }\n        break;\n      case 'URL':\n        {\n          const res = await handleHttpWebHook(\n            notification?.payload,\n            user,\n            data\n          );\n\n          hookLog = {\n            ...hook,\n            type: notification.type,\n            payload: JSON.stringify(notification?.payload),\n            response: JSON.stringify(res),\n            triggered_by: user?.email\n          };\n        }\n        break;\n      default:\n        {\n          const res = await (\n            await NcPluginMgrv2.webhookNotificationAdapters(notification.type)\n          ).sendMessage(\n            parseBody(\n              notification?.payload?.body,\n              user,\n              data,\n              notification?.payload\n            ),\n            JSON.parse(JSON.stringify(notification?.payload), (_key, value) => {\n              return typeof value === 'string'\n                ? parseBody(value, user, data, notification?.payload)\n                : value;\n            })\n          );\n\n          hookLog = {\n            ...hook,\n            type: notification.type,\n            payload: JSON.stringify(notification?.payload),\n            response: JSON.stringify(res),\n            triggered_by: user?.email\n          };\n        }\n        break;\n    }\n  } catch (e) {\n    console.log(e);\n    hookLog = {\n      ...hook,\n      error_code: e.error_code,\n      error_message: e.message,\n      error: JSON.stringify(e)\n    };\n    if (throwErrorOnFailure) throw e;\n  } finally {\n    if (hookLog) {\n      hookLog.execution_time = parseHrtimeToMilliSeconds(\n        process.hrtime(startTime)\n      );\n      HookLog.insert({ ...hookLog, test_call: !!testFilters });\n    }\n  }\n}\n\nexport function _transformSubmittedFormDataForEmail(\n  data,\n  // @ts-ignore\n  formView,\n  // @ts-ignore\n  columns: Column[]\n) {\n  const transformedData = { ...data };\n\n  for (const col of columns) {\n    if (!formView.query_params?.showFields?.[col.title]) {\n      delete transformedData[col.title];\n      continue;\n    }\n\n    if (col.uidt === 'Attachment') {\n      if (typeof transformedData[col.title] === 'string') {\n        transformedData[col.title] = JSON.parse(transformedData[col.title]);\n      }\n      transformedData[col.title] = (transformedData[col.title] || [])\n        .map(attachment => {\n          if (\n            ['jpeg', 'gif', 'png', 'apng', 'svg', 'bmp', 'ico', 'jpg'].includes(\n              attachment.title.split('.').pop()\n            )\n          ) {\n            return `<a href=\"${attachment.url}\" target=\"_blank\"><img height=\"50px\" src=\"${attachment.url}\"/></a>`;\n          }\n          return `<a href=\"${attachment.url}\" target=\"_blank\">${attachment.title}</a>`;\n        })\n        .join('&nbsp;');\n    } else if (\n      transformedData[col.title] &&\n      typeof transformedData[col.title] === 'object'\n    ) {\n      transformedData[col.title] = JSON.stringify(transformedData[col.title]);\n    }\n  }\n}\n\nfunction parseHrtimeToMilliSeconds(hrtime) {\n  const milliseconds = (hrtime[0] + hrtime[1] / 1e6).toFixed(3);\n  return milliseconds;\n}\n"], "fixing_code": ["---\ntitle: \"Webhooks\"\ndescription: \"Webhooks\"\nposition: 1500\ncategory: \"Developer Resources\"\nmenuTitle: \"Webhooks\"\n---\n\n## Overview\n\nSome types of notifications can be triggered by a webhook after a particular event.\n\n- Open a Project, Select a table and Click 'More' > 'Webhooks'.\n\n![Screenshot 2022-02-22 at 11 16 18 AM](https://user-images.githubusercontent.com/86527202/155085373-f9b438ed-98c3-4fb1-9209-1bb52736a35d.png)\n\n- Click 'Create webhook'\n\n![image](https://user-images.githubusercontent.com/35857179/166660074-0a896ec9-9cd8-403e-a713-61c2cefbae28.png)\n\n- Configure the webhook\n\n![image](https://user-images.githubusercontent.com/35857179/166660248-a3c81a34-4334-48c2-846a-65759d761559.png)\n\n\n## Triggers\n\nWebhooks allows user to trigger on certain operations on following database operations\n\n-   AFTER INSERT\n-   AFTER UPDATE\n-   AFTER DELETE\n\nThe triggers will trigger asynchronously without blocking the actual operation.\n\n### Applications/services\n\n| Trigger         | Details                                        |\n| --------------- | ---------------------------------------------- |\n| Email           | Send email to certain email addresses          |\n| Slack           | Notify via Slack channel                       |\n| Microsoft Teams | Notify via Microsoft Teams channel             |\n| Discord         | Notify via Discord channel                     |\n| Mattermost      | Notify via Mattermost channel                  |\n| Twilio          | Send SMS to certain mobile numbers             |\n| Whatsapp Twilio | Send Whatsapp messages to numbers using Twilio |\n| URL             | Invoke an HTTP API                             |\n\n  \n## Accessing Data: Handlebars\n\nThe current row data and other details will be available in the hooks payload so the user can use [handlebar syntax](https://handlebarsjs.com/guide/#simple-expressions) to use data.\n\n> We are using [Handlebars](https://handlebarsjs.com/) library to parse the payload internally.\n\n### Example\n\nFor a table with column names (id, title, created_at, updated_at).  \nFor INSERT/ UPDATE based triggers, use following handlebars to access corresponding **data** fields.\n\n-   {{ **data**.id }}\n-   {{ **data**.title }}\n-   {{ **data**.created_at }}\n-   {{ **data**.updated_at }}  \n  \nNote that, for Update trigger - all the fields in the ROW will be accessible, not just the field updated.\nFor DELETE based triggers, **only** {{ data.id }} is accessible representing ID of the column deleted.\n  \n### JSON format\n\nUse {{ json data }} to dump complete data & user information available in JSON format\n\n### Additional references:\n\n[Handlebar Guide](https://handlebarsjs.com/guide/).\n\n# Application Guide\n\n## Discord\n\n### 1. Create WebHook\n\n-   On Discord, open your Server Settings and head into the Integrations tab:\n-   Click the \"Create Webhook\" button to create a new webhook!\n\n![Screenshot 2022-02-22 at 1 21 59 PM](https://user-images.githubusercontent.com/86527202/155087088-8f9fd762-9ff9-41a6-aed4-0f22add77fe6.png)\n\n-   Choose channel to which this webhook will post to.\n-   Copy webhook URL\n\n![Screenshot 2022-02-22 at 1 23 18 PM](https://user-images.githubusercontent.com/86527202/155087126-c2cdd7b2-518a-46a5-82a5-aa90fe51a709.png)\n\n(Sample webhook URL: https://discord.com/api/webhooks/945558283756908644/GNUtiGuzfOky6wZ4ce30XuXc1sbPK3Od7EC-4t6hihh5Fovv6oU9OsdT6mGuoL1QlTzj).  \nDetailed procedure for discord webhook described [here](https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks).\n\n### 2. Install Plugin\n\n-   Open 'App Store' (under Settings), hover over Discord tile. Click 'Install'.\n\n![Screenshot 2022-02-22 at 11 30 36 AM](https://user-images.githubusercontent.com/86527202/155085257-5bdde1d9-d7b5-471d-bf44-3c3920e7b853.png)\n\n-   Provide a name of your choice (not to be confused with Discord Channel name).\n-   Paste Discord Webhook URL copied from Step (1.) above.\n\n![Screenshot 2022-02-22 at 11 31 21 AM](https://user-images.githubusercontent.com/86527202/155085287-f5e45aab-fd33-4138-a7a9-6eddc6dc140b.png)\n\n### 3. Configure \n\n-   Open project and choose a table.\n-   Click 'More' > 'Webhooks'.\n-   Click 'Create webhook'\n-   Configure webhook\n    -   **Title**: Name of your choice to identify this Webhook.\n    -   **Event**: Trigger event. Choose between.\n        -   After Insert: Trigger event for new ROW insertion.\n        -   After Update: Trigger event for existing ROW updation.\n        -   After Delete: Trigger event for ROW deletion\n    -   **On Condition**: [Optional] Enable if you wish to associate additional condition/constraint with the trigger configured above.\n    -   **Notification**: Select 'Discord'.\n    -   **Select Discord Channels**: Select from the drop down list, channel name configured in Step (2). Please click on 'Reload' if drop down list is empty.\n    -   **Body**: Message to be posted over Discord channel, via webhooks on trigger of configured event.\n        -   Body can contain plain text &\n        -   Handlebars {{ }}\n\n\n## Slack\n### 1. Create WebHook\n-   Details to create slack webhook are captured [here](https://api.slack.com/messaging/webhooks)\n\n### 2. Install Plugin\n- Procedure remain same as listed for DISCORD channel configuration above\n\n### 3. Configure Webhook\n- Procedure remain same as listed for DISCORD channel configuration above\n  \n  \n## Microsoft Teams\n### 1. Create WebHook\n\n-   On Teams, open your channel, click on three-dots menu (far right) and select 'Connectors'\n  \n<img width=\"319\" alt=\"154971352-6912d53b-cf71-4edd-a319-1c85be85f0c5\" src=\"https://user-images.githubusercontent.com/86527202/155095745-91abd708-834f-4f0e-a33c-ac362e60af0f.png\">\n\n  \n-   Select incoming webhook & click 'Configure'\n  \n<img width=\"442\" alt=\"154971434-0ced97f7-205a-4e2e-8f88-17092cb7771a\" src=\"https://user-images.githubusercontent.com/86527202/155095741-b23ad6b2-1276-46e3-8ada-0d0a871115bb.png\">\n  \n-   Create webhook, Copy webhook URL\n  \n![154971683-db16be7f-4f07-4447-8f2e-ac50e133bef8](https://user-images.githubusercontent.com/86527202/155095733-c339a914-5d78-408c-8f1e-9cd75a7783e8.png)\n\n\n### 2. Install Plugin\n\n-   Open 'App Store' (under Settings), hover over 'Microsoft Teams' tile. Click 'Install'.\n\n![Screenshot 2022-02-22 at 7 32 52 PM](https://user-images.githubusercontent.com/86527202/155148122-60844b42-7d2a-4c0f-9778-a5bc4f9c0107.png)\n\n\n-   Provide a name of your choice (not to be confused with Teams Channel name).\n-   Paste MS Teams Webhook URL copied from Step (1.) above.\n\n<img width=\"414\" alt=\"154971222-7fe2c25a-d8c6-46b0-ba1e-a05ff1cf6537\" src=\"https://user-images.githubusercontent.com/86527202/155095720-ff1c052c-a4a7-4c10-8f30-d779dac336f3.png\">\n\n### 3. Configure \n\n- Open project and choose a table.\n- Click 'More' > 'Webhooks'.\n- Click 'Create webhook'\n- Configure webhook\n    -   **Title**: Name of your choice to identify this Webhook.\n    -   **Event**: Trigger event. Choose between.\n        -   After Insert: Trigger event for new ROW insertion.\n        -   After Update: Trigger event for existing ROW updation.\n        -   After Delete: Trigger event for ROW deletion\n    -   **On Condition**: [Optional] Enable if you wish to associate additional condition/constraint with the trigger configured above.\n    -   **Notification**: Select 'Microsoft Teams'.\n    -   **Select Teams Channels**: Select from the drop down list, channel name configured in Step (2). Please click on 'Reload' if drop down list is empty.\n    -   **Body**: Message to be posted over Teams channel, via webhooks on trigger of configured event.\n        -   Body can contain plain text &\n        -   Handlebars {{ }}\n", "import autoBind from 'auto-bind';\nimport _ from 'lodash';\n\nimport Model from '../../../../models/Model';\nimport { XKnex } from '../../index';\nimport LinkToAnotherRecordColumn from '../../../../models/LinkToAnotherRecordColumn';\nimport RollupColumn from '../../../../models/RollupColumn';\nimport LookupColumn from '../../../../models/LookupColumn';\nimport DataLoader from 'dataloader';\nimport Column from '../../../../models/Column';\nimport { XcFilter, XcFilterWithAlias } from '../BaseModel';\nimport conditionV2 from './conditionV2';\nimport Filter from '../../../../models/Filter';\nimport sortV2 from './sortV2';\nimport Sort from '../../../../models/Sort';\nimport FormulaColumn from '../../../../models/FormulaColumn';\nimport genRollupSelectv2 from './genRollupSelectv2';\nimport formulaQueryBuilderv2 from './formulav2/formulaQueryBuilderv2';\nimport { QueryBuilder } from 'knex';\nimport View from '../../../../models/View';\nimport {\n  AuditOperationSubTypes,\n  AuditOperationTypes,\n  RelationTypes,\n  SortType,\n  UITypes,\n  ViewTypes\n} from 'nocodb-sdk';\nimport formSubmissionEmailTemplate from '../../../../utils/common/formSubmissionEmailTemplate';\nimport ejs from 'ejs';\nimport Audit from '../../../../models/Audit';\nimport FormView from '../../../../models/FormView';\nimport Hook from '../../../../models/Hook';\nimport NcPluginMgrv2 from '../../../../meta/helpers/NcPluginMgrv2';\nimport {\n  _transformSubmittedFormDataForEmail,\n  invokeWebhook\n} from '../../../../meta/helpers/webhookHelpers';\nimport Validator from 'validator';\nimport { customValidators } from './customValidators';\nimport { NcError } from '../../../../meta/helpers/catchError';\nimport { customAlphabet } from 'nanoid';\n\nconst GROUP_COL = '__nc_group_id';\n\nconst nanoidv2 = customAlphabet('1234567890abcdefghijklmnopqrstuvwxyz', 14);\nconst { v4: uuidv4 } = require('uuid');\n\nasync function populatePk(model: Model, insertObj: any) {\n  await model.getColumns();\n  for (const pkCol of model.primaryKeys) {\n    if (!pkCol.meta?.ag || insertObj[pkCol.title]) continue;\n    insertObj[pkCol.title] =\n      pkCol.meta?.ag === 'nc' ? `rc_${nanoidv2()}` : uuidv4();\n  }\n}\n\n/**\n * Base class for models\n *\n * @class\n * @classdesc Base class for models\n */\nclass BaseModelSqlv2 {\n  protected dbDriver: XKnex;\n  protected model: Model;\n  protected viewId: string;\n  private _proto: any;\n  private _columns = {};\n\n  private config: any = {\n    limitDefault: Math.max(+process.env.DB_QUERY_LIMIT_DEFAULT || 25, 1),\n    limitMin: Math.max(+process.env.DB_QUERY_LIMIT_MIN || 1, 1),\n    limitMax: Math.max(+process.env.DB_QUERY_LIMIT_MAX || 1000, 1)\n  };\n\n  constructor({\n    dbDriver,\n    model,\n    viewId\n  }: {\n    [key: string]: any;\n    model: Model;\n  }) {\n    this.dbDriver = dbDriver;\n    this.model = model;\n    this.viewId = viewId;\n    autoBind(this);\n  }\n\n  public async readByPk(id?: any): Promise<any> {\n    const qb = this.dbDriver(this.model.table_name);\n\n    await this.selectObject({ qb });\n\n    qb.where(this.model.primaryKey.column_name, id);\n\n    const data = (await this.extractRawQueryAndExec(qb))?.[0];\n\n    if (data) {\n      const proto = await this.getProto();\n      data.__proto__ = proto;\n    }\n    return data;\n  }\n\n  public async exist(id?: any): Promise<any> {\n    const qb = this.dbDriver(this.model.table_name);\n    await this.selectObject({ qb });\n    const pks = this.model.primaryKeys;\n    if ((id + '').split('___').length != pks.length) {\n      return false;\n    }\n    return !!(await qb.where(_wherePk(pks, id)).first());\n  }\n\n  public async findOne(\n    args: {\n      where?: string;\n      filterArr?: Filter[];\n    } = {}\n  ): Promise<any> {\n    const qb = this.dbDriver(this.model.table_name);\n    await this.selectObject({ qb });\n\n    const aliasColObjMap = await this.model.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args?.where, aliasColObjMap);\n\n    await conditionV2(\n      [\n        new Filter({\n          children: args.filterArr || [],\n          is_group: true,\n          logical_op: 'and'\n        }),\n        new Filter({\n          children: filterObj,\n          is_group: true,\n          logical_op: 'and'\n        }),\n        ...(args.filterArr || [])\n      ],\n      qb,\n      this.dbDriver\n    );\n\n    const data = await qb.first();\n\n    if (data) {\n      const proto = await this.getProto();\n      data.__proto__ = proto;\n    }\n    return data;\n  }\n\n  public async list(\n    args: {\n      where?: string;\n      limit?;\n      offset?;\n      filterArr?: Filter[];\n      sortArr?: Sort[];\n      sort?: string | string[];\n    } = {},\n    ignoreFilterSort = false\n  ): Promise<any> {\n    const { where, ...rest } = this._getListArgs(args as any);\n\n    const qb = this.dbDriver(this.model.table_name);\n    await this.selectObject({ qb });\n\n    const aliasColObjMap = await this.model.getAliasColObjMap();\n\n    let sorts = extractSortsObject(args?.sort, aliasColObjMap);\n\n    const filterObj = extractFilterFromXwhere(args?.where, aliasColObjMap);\n\n    // todo: replace with view id\n    if (!ignoreFilterSort && this.viewId) {\n      await conditionV2(\n        [\n          new Filter({\n            children:\n              (await Filter.rootFilterList({ viewId: this.viewId })) || [],\n            is_group: true\n          }),\n          new Filter({\n            children: args.filterArr || [],\n            is_group: true,\n            logical_op: 'and'\n          }),\n          new Filter({\n            children: filterObj,\n            is_group: true,\n            logical_op: 'and'\n          }),\n          ...(args.filterArr || [])\n        ],\n        qb,\n        this.dbDriver\n      );\n\n      if (!sorts)\n        sorts = args.sortArr?.length\n          ? args.sortArr\n          : await Sort.list({ viewId: this.viewId });\n\n      await sortV2(sorts, qb, this.dbDriver);\n    } else {\n      await conditionV2(\n        [\n          new Filter({\n            children: args.filterArr || [],\n            is_group: true,\n            logical_op: 'and'\n          }),\n          new Filter({\n            children: filterObj,\n            is_group: true,\n            logical_op: 'and'\n          }),\n          ...(args.filterArr || [])\n        ],\n        qb,\n        this.dbDriver\n      );\n\n      if (!sorts) sorts = args.sortArr;\n\n      await sortV2(sorts, qb, this.dbDriver);\n    }\n\n    // sort by primary key if not autogenerated string\n    // if autogenerated string sort by created_at column if present\n    if (this.model.primaryKey && this.model.primaryKey.ai) {\n      qb.orderBy(this.model.primaryKey.column_name);\n    } else if (this.model.columns.find(c => c.column_name === 'created_at')) {\n      qb.orderBy('created_at');\n    }\n\n    if (!ignoreFilterSort) applyPaginate(qb, rest);\n    const proto = await this.getProto();\n\n    const data = await this.extractRawQueryAndExec(qb);\n\n    return data?.map(d => {\n      d.__proto__ = proto;\n      return d;\n    });\n  }\n\n  public async count(\n    args: { where?: string; limit?; filterArr?: Filter[] } = {},\n    ignoreFilterSort = false\n  ): Promise<any> {\n    await this.model.getColumns();\n    const { where } = this._getListArgs(args);\n\n    const qb = this.dbDriver(this.model.table_name);\n\n    // qb.xwhere(where, await this.model.getAliasColMapping());\n    const aliasColObjMap = await this.model.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(where, aliasColObjMap);\n\n    if (!ignoreFilterSort && this.viewId) {\n      await conditionV2(\n        [\n          new Filter({\n            children:\n              (await Filter.rootFilterList({ viewId: this.viewId })) || [],\n            is_group: true\n          }),\n          new Filter({\n            children: args.filterArr || [],\n            is_group: true,\n            logical_op: 'and'\n          }),\n          new Filter({\n            children: filterObj,\n            is_group: true,\n            logical_op: 'and'\n          }),\n          ...(args.filterArr || [])\n        ],\n        qb,\n        this.dbDriver\n      );\n    } else {\n      await conditionV2(\n        [\n          new Filter({\n            children: args.filterArr || [],\n            is_group: true,\n            logical_op: 'and'\n          }),\n          new Filter({\n            children: filterObj,\n            is_group: true,\n            logical_op: 'and'\n          }),\n          ...(args.filterArr || [])\n        ],\n        qb,\n        this.dbDriver\n      );\n    }\n\n    qb.count(this.model.primaryKey?.column_name || '*', {\n      as: 'count'\n    }).first();\n\n    return ((await qb) as any).count;\n  }\n\n  async groupBy(\n    args: {\n      where?: string;\n      column_name: string;\n      limit?;\n      offset?;\n      sort?: string | string[];\n    } = {\n      column_name: ''\n    }\n  ) {\n    const { where, ...rest } = this._getListArgs(args as any);\n\n    const qb = this.dbDriver(this.model.table_name);\n    qb.count(`${this.model.primaryKey?.column_name || '*'} as count`);\n    qb.select(args.column_name);\n\n    const aliasColObjMap = await this.model.getAliasColObjMap();\n\n    const sorts = extractSortsObject(args?.sort, aliasColObjMap);\n\n    const filterObj = extractFilterFromXwhere(args?.where, aliasColObjMap);\n    await conditionV2(\n      [\n        new Filter({\n          children: filterObj,\n          is_group: true,\n          logical_op: 'and'\n        })\n      ],\n      qb,\n      this.dbDriver\n    );\n    qb.groupBy(args.column_name);\n    if (sorts) await sortV2(sorts, qb, this.dbDriver);\n    applyPaginate(qb, rest);\n\n    return await qb;\n  }\n\n  async multipleHmList({ colId, ids }, args?: { limit?; offset? }) {\n    try {\n      // todo: get only required fields\n\n      // const { cn } = this.hasManyRelations.find(({ tn }) => tn === child) || {};\n      const relColumn = (await this.model.getColumns()).find(\n        c => c.id === colId\n      );\n\n      const chilCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getChildColumn();\n      const childTable = await chilCol.getModel();\n      const parentCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getParentColumn();\n      const parentTable = await parentCol.getModel();\n      const childModel = await Model.getBaseModelSQL({\n        model: childTable,\n        dbDriver: this.dbDriver\n      });\n      await parentTable.getColumns();\n\n      const qb = this.dbDriver(childTable.table_name);\n      await childModel.selectObject({ qb });\n\n      const childQb = this.dbDriver.queryBuilder().from(\n        this.dbDriver\n          .unionAll(\n            ids.map(p => {\n              const query = qb\n                .clone()\n                .select(this.dbDriver.raw('? as ??', [p, GROUP_COL]))\n                .whereIn(\n                  chilCol.column_name,\n                  this.dbDriver(parentTable.table_name)\n                    .select(parentCol.column_name)\n                    // .where(parentTable.primaryKey.cn, p)\n                    .where(_wherePk(parentTable.primaryKeys, p))\n                );\n              // todo: sanitize\n              query.limit(args?.limit || 20);\n              query.offset(args?.offset || 0);\n\n              return this.isSqlite ? this.dbDriver.select().from(query) : query;\n            }),\n            !this.isSqlite\n          )\n          .as('list')\n      );\n\n      const children = await this.extractRawQueryAndExec(childQb);\n      const proto = await (\n        await Model.getBaseModelSQL({\n          id: childTable.id,\n          dbDriver: this.dbDriver\n        })\n      ).getProto();\n\n      return _.groupBy(\n        children.map(c => {\n          c.__proto__ = proto;\n          return c;\n        }),\n        GROUP_COL\n      );\n    } catch (e) {\n      console.log(e);\n      throw e;\n    }\n  }\n\n  async multipleHmListCount({ colId, ids }) {\n    try {\n      // const { cn } = this.hasManyRelations.find(({ tn }) => tn === child) || {};\n      const relColumn = (await this.model.getColumns()).find(\n        c => c.id === colId\n      );\n      const chilCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getChildColumn();\n      const childTable = await chilCol.getModel();\n      const parentCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getParentColumn();\n      const parentTable = await parentCol.getModel();\n      await parentTable.getColumns();\n\n      const children = await this.dbDriver.unionAll(\n        ids.map(p => {\n          const query = this.dbDriver(childTable.table_name)\n            .count(`${chilCol?.column_name} as count`)\n            .whereIn(\n              chilCol.column_name,\n              this.dbDriver(parentTable.table_name)\n                .select(parentCol.column_name)\n                // .where(parentTable.primaryKey.cn, p)\n                .where(_wherePk(parentTable.primaryKeys, p))\n            )\n            .first();\n\n          return this.isSqlite ? this.dbDriver.select().from(query) : query;\n        }),\n        !this.isSqlite\n      );\n\n      return children.map(({ count }) => count);\n    } catch (e) {\n      console.log(e);\n      throw e;\n    }\n  }\n\n  async hmList({ colId, id }, args?: { limit?; offset? }) {\n    try {\n      // todo: get only required fields\n\n      const relColumn = (await this.model.getColumns()).find(\n        c => c.id === colId\n      );\n\n      const chilCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getChildColumn();\n      const childTable = await chilCol.getModel();\n      const parentCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getParentColumn();\n      const parentTable = await parentCol.getModel();\n      const childModel = await Model.getBaseModelSQL({\n        model: childTable,\n        dbDriver: this.dbDriver\n      });\n      await parentTable.getColumns();\n\n      const qb = this.dbDriver(childTable.table_name);\n\n      qb.whereIn(\n        chilCol.column_name,\n        this.dbDriver(parentTable.table_name)\n          .select(parentCol.column_name)\n          // .where(parentTable.primaryKey.cn, p)\n          .where(_wherePk(parentTable.primaryKeys, id))\n      );\n      // todo: sanitize\n      qb.limit(args?.limit || 20);\n      qb.offset(args?.offset || 0);\n\n      await childModel.selectObject({ qb });\n\n      const children = await this.extractRawQueryAndExec(qb);\n\n      const proto = await (\n        await Model.getBaseModelSQL({\n          id: childTable.id,\n          dbDriver: this.dbDriver\n        })\n      ).getProto();\n\n      return children.map(c => {\n        c.__proto__ = proto;\n        return c;\n      });\n    } catch (e) {\n      console.log(e);\n      throw e;\n    }\n  }\n\n  async hmListCount({ colId, id }) {\n    try {\n      // const { cn } = this.hasManyRelations.find(({ tn }) => tn === child) || {};\n      const relColumn = (await this.model.getColumns()).find(\n        c => c.id === colId\n      );\n      const chilCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getChildColumn();\n      const childTable = await chilCol.getModel();\n      const parentCol = await ((await relColumn.getColOptions()) as LinkToAnotherRecordColumn).getParentColumn();\n      const parentTable = await parentCol.getModel();\n      await parentTable.getColumns();\n\n      const query = this.dbDriver(childTable.table_name)\n        .count(`${chilCol?.column_name} as count`)\n        .whereIn(\n          chilCol.column_name,\n          this.dbDriver(parentTable.table_name)\n            .select(parentCol.column_name)\n            .where(_wherePk(parentTable.primaryKeys, id))\n        )\n        .first();\n      const { count } = await query;\n      return count;\n      // return _.groupBy(children, cn);\n    } catch (e) {\n      console.log(e);\n      throw e;\n    }\n  }\n\n  public async multipleMmList({ colId, parentIds }, args?: { limit; offset }) {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    // const tn = this.model.tn;\n    // const cn = (await relColOptions.getChildColumn()).title;\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n    const childModel = await Model.getBaseModelSQL({\n      dbDriver: this.dbDriver,\n      model: childTable\n    });\n    const rtn = childTable.table_name;\n    const rtnId = childTable.id;\n\n    const qb = this.dbDriver(rtn).join(vtn, `${vtn}.${vrcn}`, `${rtn}.${rcn}`);\n\n    await childModel.selectObject({ qb });\n    const finalQb = this.dbDriver.unionAll(\n      parentIds.map(id => {\n        const query = qb\n          .clone()\n          .whereIn(\n            `${vtn}.${vcn}`,\n            this.dbDriver(parentTable.table_name)\n              .select(cn)\n              // .where(parentTable.primaryKey.cn, id)\n              .where(_wherePk(parentTable.primaryKeys, id))\n          )\n          .select(this.dbDriver.raw('? as ??', [id, GROUP_COL]));\n\n        // todo: sanitize\n        query.limit(args?.limit || 20);\n        query.offset(args?.offset || 0);\n\n        return this.isSqlite ? this.dbDriver.select().from(query) : query;\n      }),\n      !this.isSqlite\n    );\n\n    const children = await this.extractRawQueryAndExec(finalQb);\n    const proto = await (\n      await Model.getBaseModelSQL({\n        id: rtnId,\n        dbDriver: this.dbDriver\n      })\n    ).getProto();\n    const gs = _.groupBy(\n      children.map(c => {\n        c.__proto__ = proto;\n        return c;\n      }),\n      GROUP_COL\n    );\n    return parentIds.map(id => gs[id] || []);\n  }\n\n  public async mmList({ colId, parentId }, args?: { limit; offset }) {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    // const tn = this.model.tn;\n    // const cn = (await relColOptions.getChildColumn()).title;\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n    const childModel = await Model.getBaseModelSQL({\n      dbDriver: this.dbDriver,\n      model: childTable\n    });\n    const rtn = childTable.table_name;\n    const rtnId = childTable.id;\n\n    const qb = this.dbDriver(rtn)\n      .join(vtn, `${vtn}.${vrcn}`, `${rtn}.${rcn}`)\n      .whereIn(\n        `${vtn}.${vcn}`,\n        this.dbDriver(parentTable.table_name)\n          .select(cn)\n          // .where(parentTable.primaryKey.cn, id)\n          .where(_wherePk(parentTable.primaryKeys, parentId))\n      );\n\n    await childModel.selectObject({ qb });\n    // todo: sanitize\n    qb.limit(args?.limit || 20);\n    qb.offset(args?.offset || 0);\n\n    const children = await this.extractRawQueryAndExec(qb);\n    const proto = await (\n      await Model.getBaseModelSQL({ id: rtnId, dbDriver: this.dbDriver })\n    ).getProto();\n\n    return children.map(c => {\n      c.__proto__ = proto;\n      return c;\n    });\n  }\n\n  public async multipleMmListCount({ colId, parentIds }) {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const rtn = childTable.table_name;\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n\n    const qb = this.dbDriver(rtn)\n      .join(vtn, `${vtn}.${vrcn}`, `${rtn}.${rcn}`)\n      // .select({\n      //   [`${tn}_${vcn}`]: `${vtn}.${vcn}`\n      // })\n      .count(`${vtn}.${vcn}`, { as: 'count' });\n\n    // await childModel.selectObject({ qb });\n    const children = await this.dbDriver.unionAll(\n      parentIds.map(id => {\n        const query = qb\n          .clone()\n          .whereIn(\n            `${vtn}.${vcn}`,\n            this.dbDriver(parentTable.table_name)\n              .select(cn)\n              // .where(parentTable.primaryKey.cn, id)\n              .where(_wherePk(parentTable.primaryKeys, id))\n          )\n          .select(this.dbDriver.raw('? as ??', [id, GROUP_COL]));\n        // this._paginateAndSort(query, { sort, limit, offset }, null, true);\n        return this.isSqlite ? this.dbDriver.select().from(query) : query;\n      }),\n      !this.isSqlite\n    );\n\n    const gs = _.groupBy(children, GROUP_COL);\n    return parentIds.map(id => gs?.[id]?.[0] || []);\n  }\n\n  public async mmListCount({ colId, parentId }) {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const rtn = childTable.table_name;\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n\n    const qb = this.dbDriver(rtn)\n      .join(vtn, `${vtn}.${vrcn}`, `${rtn}.${rcn}`)\n      // .select({\n      //   [`${tn}_${vcn}`]: `${vtn}.${vcn}`\n      // })\n      .count(`${vtn}.${vcn}`, { as: 'count' })\n      .whereIn(\n        `${vtn}.${vcn}`,\n        this.dbDriver(parentTable.table_name)\n          .select(cn)\n          // .where(parentTable.primaryKey.cn, id)\n          .where(_wherePk(parentTable.primaryKeys, parentId))\n      )\n      .first();\n\n    const { count } = await qb;\n\n    return count;\n  }\n\n  // todo: naming & optimizing\n  public async getMmChildrenExcludedListCount(\n    { colId, pid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n    const rtn = childTable.table_name;\n    const qb = this.dbDriver(rtn)\n      .count(`*`, { as: 'count' })\n      .where(qb => {\n        qb.whereNotIn(\n          rcn,\n          this.dbDriver(rtn)\n            .select(`${rtn}.${rcn}`)\n            .join(vtn, `${rtn}.${rcn}`, `${vtn}.${vrcn}`)\n            .whereIn(\n              `${vtn}.${vcn}`,\n              this.dbDriver(parentTable.table_name)\n                .select(cn)\n                // .where(parentTable.primaryKey.cn, pid)\n                .where(_wherePk(parentTable.primaryKeys, pid))\n            )\n        ).orWhereNull(rcn);\n      });\n\n    const aliasColObjMap = await childTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n\n    await conditionV2(filterObj, qb, this.dbDriver);\n    return (await qb.first())?.count;\n  }\n\n  // todo: naming & optimizing\n  public async getMmChildrenExcludedList(\n    { colId, pid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const vtn = (await relColOptions.getMMModel()).table_name;\n    const vcn = (await relColOptions.getMMChildColumn()).column_name;\n    const vrcn = (await relColOptions.getMMParentColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getParentColumn()).getModel();\n    const childModel = await Model.getBaseModelSQL({\n      dbDriver: this.dbDriver,\n      model: childTable\n    });\n    const parentTable = await (await relColOptions.getChildColumn()).getModel();\n    await parentTable.getColumns();\n    const rtn = childTable.table_name;\n\n    const qb = this.dbDriver(rtn).where(qb =>\n      qb\n        .whereNotIn(\n          rcn,\n          this.dbDriver(rtn)\n            .select(`${rtn}.${rcn}`)\n            .join(vtn, `${rtn}.${rcn}`, `${vtn}.${vrcn}`)\n            .whereIn(\n              `${vtn}.${vcn}`,\n              this.dbDriver(parentTable.table_name)\n                .select(cn)\n                // .where(parentTable.primaryKey.cn, pid)\n                .where(_wherePk(parentTable.primaryKeys, pid))\n            )\n        )\n        .orWhereNull(rcn)\n    );\n\n    await childModel.selectObject({ qb });\n\n    const aliasColObjMap = await childTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n    await conditionV2(filterObj, qb, this.dbDriver);\n\n    applyPaginate(qb, args);\n\n    const proto = await childModel.getProto();\n\n    return (await qb).map(c => {\n      c.__proto__ = proto;\n      return c;\n    });\n  }\n\n  // todo: naming & optimizing\n  public async getHmChildrenExcludedListCount(\n    { colId, pid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const childTable = await (await relColOptions.getChildColumn()).getModel();\n    const parentTable = await (\n      await relColOptions.getParentColumn()\n    ).getModel();\n    const tn = childTable.table_name;\n    const rtn = parentTable.table_name;\n    await parentTable.getColumns();\n\n    const qb = this.dbDriver(tn)\n      .count(`*`, { as: 'count' })\n      .where(qb => {\n        qb.whereNotIn(\n          cn,\n          this.dbDriver(rtn)\n            .select(rcn)\n            // .where(parentTable.primaryKey.cn, pid)\n            .where(_wherePk(parentTable.primaryKeys, pid))\n        ).orWhereNull(cn);\n      });\n\n    const aliasColObjMap = await childTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n\n    await conditionV2(filterObj, qb, this.dbDriver);\n\n    return (await qb.first())?.count;\n  }\n\n  // todo: naming & optimizing\n  public async getHmChildrenExcludedList(\n    { colId, pid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const childTable = await (await relColOptions.getChildColumn()).getModel();\n    const parentTable = await (\n      await relColOptions.getParentColumn()\n    ).getModel();\n    const childModel = await Model.getBaseModelSQL({\n      dbDriver: this.dbDriver,\n      model: childTable\n    });\n    await parentTable.getColumns();\n\n    const tn = childTable.table_name;\n    const rtn = parentTable.table_name;\n\n    const qb = this.dbDriver(tn).where(qb => {\n      qb.whereNotIn(\n        cn,\n        this.dbDriver(rtn)\n          .select(rcn)\n          // .where(parentTable.primaryKey.cn, pid)\n          .where(_wherePk(parentTable.primaryKeys, pid))\n      ).orWhereNull(cn);\n    });\n\n    await childModel.selectObject({ qb });\n\n    const aliasColObjMap = await childTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n    await conditionV2(filterObj, qb, this.dbDriver);\n\n    applyPaginate(qb, args);\n\n    const proto = await childModel.getProto();\n\n    return (await qb).map(c => {\n      c.__proto__ = proto;\n      return c;\n    });\n  }\n\n  // todo: naming & optimizing\n  public async getBtChildrenExcludedListCount(\n    { colId, cid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const parentTable = await (\n      await relColOptions.getParentColumn()\n    ).getModel();\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getChildColumn()).getModel();\n\n    const rtn = parentTable.table_name;\n    const tn = childTable.table_name;\n    await childTable.getColumns();\n\n    const qb = this.dbDriver(rtn)\n      .where(qb => {\n        qb.whereNotIn(\n          rcn,\n          this.dbDriver(tn)\n            .select(cn)\n            // .where(childTable.primaryKey.cn, cid)\n            .where(_wherePk(childTable.primaryKeys, cid))\n        ).orWhereNull(rcn);\n      })\n      .count(`*`, { as: 'count' });\n\n    const aliasColObjMap = await parentTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n\n    await conditionV2(filterObj, qb, this.dbDriver);\n    return (await qb.first())?.count;\n  }\n\n  // todo: naming & optimizing\n  public async getBtChildrenExcludedList(\n    { colId, cid = null },\n    args\n  ): Promise<any> {\n    const relColumn = (await this.model.getColumns()).find(c => c.id === colId);\n    const relColOptions = (await relColumn.getColOptions()) as LinkToAnotherRecordColumn;\n\n    const rcn = (await relColOptions.getParentColumn()).column_name;\n    const parentTable = await (\n      await relColOptions.getParentColumn()\n    ).getModel();\n    const cn = (await relColOptions.getChildColumn()).column_name;\n    const childTable = await (await relColOptions.getChildColumn()).getModel();\n    const parentModel = await Model.getBaseModelSQL({\n      dbDriver: this.dbDriver,\n      model: parentTable\n    });\n    const rtn = parentTable.table_name;\n    const tn = childTable.table_name;\n    await childTable.getColumns();\n\n    const qb = this.dbDriver(rtn).where(qb => {\n      qb.whereNotIn(\n        rcn,\n        this.dbDriver(tn)\n          .select(cn)\n          // .where(childTable.primaryKey.cn, cid)\n          .where(_wherePk(childTable.primaryKeys, cid))\n          .whereNotNull(cn)\n      ).orWhereNull(rcn);\n    });\n\n    await parentModel.selectObject({ qb });\n\n    const aliasColObjMap = await parentTable.getAliasColObjMap();\n    const filterObj = extractFilterFromXwhere(args.where, aliasColObjMap);\n    await conditionV2(filterObj, qb, this.dbDriver);\n\n    applyPaginate(qb, args);\n\n    const proto = await parentModel.getProto();\n\n    return (await qb).map(c => {\n      c.__proto__ = proto;\n      return c;\n    });\n  }\n\n  async getProto() {\n    if (this._proto) {\n      return this._proto;\n    }\n\n    const proto: any = { __columnAliases: {} };\n    const columns = await this.model.getColumns();\n    for (const column of columns) {\n      switch (column.uidt) {\n        case UITypes.Rollup:\n          {\n            // @ts-ignore\n            const colOptions: RollupColumn = await column.getColOptions();\n          }\n          break;\n        case UITypes.Lookup:\n          {\n            // @ts-ignore\n            const colOptions: LookupColumn = await column.getColOptions();\n            proto.__columnAliases[column.title] = {\n              path: [\n                (await Column.get({ colId: colOptions.fk_relation_column_id }))\n                  ?.title,\n                (await Column.get({ colId: colOptions.fk_lookup_column_id }))\n                  ?.title\n              ]\n            };\n          }\n          break;\n        case UITypes.LinkToAnotherRecord:\n          {\n            this._columns[column.title] = column;\n            const colOptions = (await column.getColOptions()) as LinkToAnotherRecordColumn;\n            // const parentColumn = await colOptions.getParentColumn();\n\n            if (colOptions?.type === 'hm') {\n              const listLoader = new DataLoader(async (ids: string[]) => {\n                try {\n                  if (ids.length > 1) {\n                    const data = await this.multipleHmList(\n                      {\n                        colId: column.id,\n                        ids\n                      },\n                      (listLoader as any).args\n                    );\n                    return ids.map((id: string) => (data[id] ? data[id] : []));\n                  } else {\n                    return [\n                      await this.hmList(\n                        {\n                          colId: column.id,\n                          id: ids[0]\n                        },\n                        (listLoader as any).args\n                      )\n                    ];\n                  }\n                } catch (e) {\n                  console.log(e);\n                  return [];\n                }\n              });\n              const self: BaseModelSqlv2 = this;\n\n              proto[column.title] = async function(args): Promise<any> {\n                (listLoader as any).args = args;\n                return listLoader.load(\n                  getCompositePk(self.model.primaryKeys, this)\n                );\n              };\n\n              // defining HasMany count method within GQL Type class\n              // Object.defineProperty(type.prototype, column.alias, {\n              //   async value(): Promise<any> {\n              //     return listLoader.load(this[model.pk.alias]);\n              //   },\n              //   configurable: true\n              // });\n            } else if (colOptions.type === 'mm') {\n              const listLoader = new DataLoader(async (ids: string[]) => {\n                try {\n                  if (ids?.length > 1) {\n                    const data = await this.multipleMmList(\n                      {\n                        parentIds: ids,\n                        colId: column.id\n                      },\n                      (listLoader as any).args\n                    );\n\n                    return data;\n                  } else {\n                    return [\n                      await this.mmList(\n                        {\n                          parentId: ids[0],\n                          colId: column.id\n                        },\n                        (listLoader as any).args\n                      )\n                    ];\n                  }\n                } catch (e) {\n                  console.log(e);\n                  return [];\n                }\n              });\n\n              const self: BaseModelSqlv2 = this;\n              // const childColumn = await colOptions.getChildColumn();\n              proto[column.title] = async function(args): Promise<any> {\n                (listLoader as any).args = args;\n                return await listLoader.load(\n                  getCompositePk(self.model.primaryKeys, this)\n                );\n              };\n            } else if (colOptions.type === 'bt') {\n              // @ts-ignore\n              const colOptions = (await column.getColOptions()) as LinkToAnotherRecordColumn;\n              const pCol = await Column.get({\n                colId: colOptions.fk_parent_column_id\n              });\n              const cCol = await Column.get({\n                colId: colOptions.fk_child_column_id\n              });\n              const readLoader = new DataLoader(async (ids: string[]) => {\n                try {\n                  const data = await (\n                    await Model.getBaseModelSQL({\n                      id: pCol.fk_model_id,\n                      dbDriver: this.dbDriver\n                    })\n                  ).list(\n                    {\n                      // limit: ids.length,\n                      where: `(${pCol.column_name},in,${ids.join(',')})`\n                    },\n                    true\n                  );\n                  const gs = _.groupBy(data, pCol.title);\n                  return ids.map(async (id: string) => gs?.[id]?.[0]);\n                } catch (e) {\n                  console.log(e);\n                  return [];\n                }\n              });\n\n              // defining HasMany count method within GQL Type class\n              proto[column.title] = async function() {\n                if (\n                  this?.[cCol?.title] === null ||\n                  this?.[cCol?.title] === undefined\n                )\n                  return null;\n\n                return await readLoader.load(this?.[cCol?.title]);\n              };\n              // todo : handle mm\n            }\n          }\n          break;\n      }\n    }\n    this._proto = proto;\n    return proto;\n  }\n\n  _getListArgs(args: XcFilterWithAlias): XcFilter {\n    const obj: XcFilter = {};\n    obj.where = args.where || args.w || '';\n    obj.having = args.having || args.h || '';\n    obj.condition = args.condition || args.c || {};\n    obj.conditionGraph = args.conditionGraph || {};\n    obj.limit = Math.max(\n      Math.min(\n        args.limit || args.l || this.config.limitDefault,\n        this.config.limitMax\n      ),\n      this.config.limitMin\n    );\n    obj.offset = Math.max(+(args.offset || args.o) || 0, 0);\n    obj.fields = args.fields || args.f || '*';\n    obj.sort = args.sort || args.s || this.model.primaryKey?.[0]?.tn;\n    return obj;\n  }\n\n  public async selectObject({ qb }: { qb: QueryBuilder }): Promise<void> {\n    const res = {};\n    const columns = await this.model.getColumns();\n    for (const column of columns) {\n      switch (column.uidt) {\n        case 'LinkToAnotherRecord':\n        case 'Lookup':\n          break;\n        case 'Formula':\n          {\n            const formula = await column.getColOptions<FormulaColumn>();\n            if (formula.error) continue;\n            const selectQb = await formulaQueryBuilderv2(\n              formula.formula,\n              null,\n              this.dbDriver,\n              this.model\n              // this.aliasToColumn\n            );\n            // todo:  verify syntax of as ? / ??\n            qb.select(\n              this.dbDriver.raw(`?? as ??`, [\n                selectQb.builder,\n                sanitize(column.title)\n              ])\n            );\n          }\n          break;\n        case 'Rollup':\n          qb.select(\n            (\n              await genRollupSelectv2({\n                // tn: this.title,\n                knex: this.dbDriver,\n                // column,\n                columnOptions: (await column.getColOptions()) as RollupColumn\n              })\n            ).builder.as(sanitize(column.title))\n          );\n          break;\n        default:\n          res[sanitize(column.title || column.column_name)] = sanitize(\n            `${this.model.table_name}.${column.column_name}`\n          );\n          break;\n      }\n    }\n    qb.select(res);\n  }\n\n  async insert(data, trx?, cookie?) {\n    try {\n      await populatePk(this.model, data);\n\n      // todo: filter based on view\n      const insertObj = await this.model.mapAliasToColumn(data, sanitize);\n\n      await this.validate(insertObj);\n\n      if ('beforeInsert' in this) {\n        await this.beforeInsert(insertObj, trx, cookie);\n      }\n\n      // if ('beforeInsert' in this) {\n      //   await this.beforeInsert(insertObj, trx, cookie);\n      // }\n      await this.model.getColumns();\n      let response;\n      // const driver = trx ? trx : this.dbDriver;\n\n      const query = this.dbDriver(this.tnPath).insert(insertObj);\n\n      if (this.isPg || this.isMssql) {\n        query.returning(\n          `${this.model.primaryKey.column_name} as ${this.model.primaryKey.title}`\n        );\n        response = await query;\n      }\n\n      const ai = this.model.columns.find(c => c.ai);\n      if (\n        !response ||\n        (typeof response?.[0] !== 'object' && response?.[0] !== null)\n      ) {\n        let id;\n        if (response?.length) {\n          id = response[0];\n        } else {\n          id = (await query)[0];\n        }\n\n        if (ai) {\n          // response = await this.readByPk(id)\n          response = await this.readByPk(id);\n        } else {\n          response = data;\n        }\n      } else if (ai) {\n        response = await this.readByPk(\n          Array.isArray(response)\n            ? response?.[0]?.[ai.title]\n            : response?.[ai.title]\n        );\n      }\n\n      await this.afterInsert(response, trx, cookie);\n      return Array.isArray(response) ? response[0] : response;\n    } catch (e) {\n      console.log(e);\n      await this.errorInsert(e, data, trx, cookie);\n      throw e;\n    }\n  }\n\n  async delByPk(id, trx?, cookie?) {\n    try {\n      // retrieve data for handling paramas in hook\n      const data = await this.readByPk(id);\n      await this.beforeDelete(id, trx, cookie);\n      const response = await this.dbDriver(this.tnPath)\n        .del()\n        .where(await this._wherePk(id));\n      await this.afterDelete(data, trx, cookie);\n      return response;\n    } catch (e) {\n      console.log(e);\n      await this.errorDelete(e, id, trx, cookie);\n      throw e;\n    }\n  }\n\n  async updateByPk(id, data, trx?, cookie?) {\n    try {\n      const updateObj = await this.model.mapAliasToColumn(data);\n\n      await this.validate(data);\n\n      await this.beforeUpdate(data, trx, cookie);\n\n      // const driver = trx ? trx : this.dbDriver;\n      //\n      // this.validate(data);\n      // await this._run(\n      await this.dbDriver(this.tnPath)\n        .update(updateObj)\n        .where(await this._wherePk(id));\n      // );\n\n      const response = await this.readByPk(id);\n      await this.afterUpdate(response, trx, cookie);\n      return response;\n    } catch (e) {\n      console.log(e);\n      await this.errorUpdate(e, data, trx, cookie);\n      throw e;\n    }\n  }\n\n  async _wherePk(id) {\n    await this.model.getColumns();\n    return _wherePk(this.model.primaryKeys, id);\n  }\n\n  public get tnPath() {\n    const schema = (this.dbDriver as any).searchPath?.();\n    const table =\n      this.isMssql && schema\n        ? this.dbDriver.raw('??.??', [schema, this.model.table_name])\n        : this.model.table_name;\n    return table;\n  }\n\n  get isSqlite() {\n    return this.clientType === 'sqlite3';\n  }\n\n  get isMssql() {\n    return this.clientType === 'mssql';\n  }\n\n  get isPg() {\n    return this.clientType === 'pg';\n  }\n\n  get isMySQL() {\n    return this.clientType === 'mysql2' || this.clientType === 'mysql';\n  }\n\n  get clientType() {\n    return this.dbDriver.clientType();\n  }\n\n  async nestedInsert(data, _trx = null, cookie?) {\n    // const driver = trx ? trx : await this.dbDriver.transaction();\n    try {\n      await populatePk(this.model, data);\n      const insertObj = await this.model.mapAliasToColumn(data);\n\n      let rowId = null;\n      const postInsertOps = [];\n\n      const nestedCols = (await this.model.getColumns()).filter(\n        c => c.uidt === UITypes.LinkToAnotherRecord\n      );\n\n      for (const col of nestedCols) {\n        if (col.title in data) {\n          const colOptions = await col.getColOptions<\n            LinkToAnotherRecordColumn\n          >();\n\n          // parse data if it's JSON string\n          const nestedData =\n            typeof data[col.title] === 'string'\n              ? JSON.parse(data[col.title])\n              : data[col.title];\n\n          switch (colOptions.type) {\n            case RelationTypes.BELONGS_TO:\n              {\n                const parentCol = await colOptions.getChildColumn();\n                insertObj[parentCol.column_name] =\n                  nestedData?.[parentCol.title];\n              }\n              break;\n            case RelationTypes.HAS_MANY:\n              {\n                const childCol = await colOptions.getChildColumn();\n                const childModel = await childCol.getModel();\n                await childModel.getColumns();\n\n                postInsertOps.push(async () => {\n                  await this.dbDriver(childModel.table_name)\n                    .update({\n                      [childCol.column_name]: rowId\n                    })\n                    .whereIn(\n                      childModel.primaryKey.column_name,\n                      nestedData?.map(r => r[childModel.primaryKey.title])\n                    );\n                });\n              }\n              break;\n            case RelationTypes.MANY_TO_MANY: {\n              postInsertOps.push(async () => {\n                const parentModel = await colOptions\n                  .getParentColumn()\n                  .then(c => c.getModel());\n                await parentModel.getColumns();\n                const parentMMCol = await colOptions.getMMParentColumn();\n                const childMMCol = await colOptions.getMMChildColumn();\n                const mmModel = await colOptions.getMMModel();\n\n                const rows = nestedData.map(r => ({\n                  [parentMMCol.column_name]: r[parentModel.primaryKey.title],\n                  [childMMCol.column_name]: rowId\n                }));\n                await this.dbDriver(mmModel.table_name).insert(rows);\n              });\n            }\n          }\n        }\n      }\n\n      await this.validate(insertObj);\n\n      await this.beforeInsert(insertObj, this.dbDriver, cookie);\n\n      let response;\n      const query = this.dbDriver(this.tnPath).insert(insertObj);\n\n      if (this.isPg || this.isMssql) {\n        query.returning(\n          `${this.model.primaryKey.column_name} as ${this.model.primaryKey.title}`\n        );\n        response = await query;\n      }\n\n      const ai = this.model.columns.find(c => c.ai);\n      if (\n        !response ||\n        (typeof response?.[0] !== 'object' && response?.[0] !== null)\n      ) {\n        let id;\n        if (response?.length) {\n          id = response[0];\n        } else {\n          id = (await query)[0];\n        }\n\n        if (ai) {\n          // response = await this.readByPk(id)\n          response = await this.readByPk(id);\n        } else {\n          response = data;\n        }\n      } else if (ai) {\n        response = await this.readByPk(\n          Array.isArray(response)\n            ? response?.[0]?.[ai.title]\n            : response?.[ai.title]\n        );\n      }\n      response = Array.isArray(response) ? response[0] : response;\n      if (response)\n        rowId =\n          response[this.model.primaryKey.title] ||\n          response[this.model.primaryKey.column_name];\n      await Promise.all(postInsertOps.map(f => f()));\n\n      // if (!trx) {\n      //   await driver.commit();\n      // }\n\n      await this.afterInsert(response, this.dbDriver, cookie);\n\n      return response;\n    } catch (e) {\n      console.log(e);\n      // await this.errorInsert(e, data, trx, cookie);\n      // if (!trx) {\n      //   await driver.rollback(e);\n      // }\n      throw e;\n    }\n  }\n\n  async bulkInsert(\n    datas: any[],\n    {\n      chunkSize: _chunkSize = 100\n    }: {\n      chunkSize?: number;\n    } = {}\n  ) {\n    try {\n      const insertDatas = await Promise.all(\n        datas.map(async d => {\n          await populatePk(this.model, d);\n          return this.model.mapAliasToColumn(d);\n        })\n      );\n\n      // await this.beforeInsertb(insertDatas, null);\n\n      for (const data of datas) {\n        await this.validate(data);\n      }\n      // let chunkSize = 50;\n      //\n      // if (this.isSqlite && datas[0]) {\n      //   chunkSize = Math.max(1, Math.floor(999 / Object.keys(datas[0]).length));\n      // }\n\n      // fallbacks to `10` if database client is sqlite\n      // to avoid `too many SQL variables` error\n      // refer : https://www.sqlite.org/limits.html\n      const chunkSize = this.isSqlite ? 10 : _chunkSize;\n\n      const response = await this.dbDriver\n        .batchInsert(this.model.table_name, insertDatas, chunkSize)\n        .returning(this.model.primaryKey?.column_name);\n\n      // await this.afterInsertb(insertDatas, null);\n\n      return response;\n    } catch (e) {\n      // await this.errorInsertb(e, data, null);\n      throw e;\n    }\n  }\n\n  async bulkUpdate(datas: any[]) {\n    let transaction;\n    try {\n      const updateDatas = await Promise.all(\n        datas.map(d => this.model.mapAliasToColumn(d))\n      );\n\n      transaction = await this.dbDriver.transaction();\n\n      // await this.beforeUpdateb(updateDatas, transaction);\n      const res = [];\n      for (const d of updateDatas) {\n        await this.validate(d);\n        const pkValues = await this._extractPksValues(d);\n        if (!pkValues) {\n          // pk not specified - bypass\n          continue;\n        }\n        const wherePk = await this._wherePk(pkValues);\n        const response = await transaction(this.model.table_name)\n          .update(d)\n          .where(wherePk);\n        res.push(response);\n      }\n\n      // await this.afterUpdateb(res, transaction);\n      transaction.commit();\n\n      return res;\n    } catch (e) {\n      if (transaction) transaction.rollback();\n      // console.log(e);\n      // await this.errorUpdateb(e, data, null);\n      throw e;\n    }\n  }\n\n  async bulkUpdateAll(\n    args: { where?: string; filterArr?: Filter[] } = {},\n    data\n  ) {\n    try {\n      const updateData = await this.model.mapAliasToColumn(data);\n      await this.validate(updateData);\n      const pkValues = await this._extractPksValues(updateData);\n      let res = null;\n      if (pkValues) {\n        // pk is specified - by pass\n      } else {\n        await this.model.getColumns();\n        const { where } = this._getListArgs(args);\n        const qb = this.dbDriver(this.model.table_name);\n        const aliasColObjMap = await this.model.getAliasColObjMap();\n        const filterObj = extractFilterFromXwhere(where, aliasColObjMap);\n\n        await conditionV2(\n          [\n            new Filter({\n              children: args.filterArr || [],\n              is_group: true,\n              logical_op: 'and'\n            }),\n            new Filter({\n              children: filterObj,\n              is_group: true,\n              logical_op: 'and'\n            }),\n            ...(args.filterArr || [])\n          ],\n          qb,\n          this.dbDriver\n        );\n        qb.update(updateData);\n        res = ((await qb) as any).count;\n      }\n      return res;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async bulkDelete(ids: any[]) {\n    let transaction;\n    try {\n      transaction = await this.dbDriver.transaction();\n      // await this.beforeDeleteb(ids, transaction);\n\n      const res = [];\n      for (const d of ids) {\n        if (Object.keys(d).length) {\n          const response = await transaction(this.model.table_name)\n            .del()\n            .where(d);\n          res.push(response);\n        }\n      }\n      // await this.afterDeleteb(res, transaction);\n\n      transaction.commit();\n\n      return res;\n    } catch (e) {\n      if (transaction) transaction.rollback();\n      console.log(e);\n      // await this.errorDeleteb(e, ids);\n      throw e;\n    }\n  }\n\n  async bulkDeleteAll(args: { where?: string; filterArr?: Filter[] } = {}) {\n    try {\n      await this.model.getColumns();\n      const { where } = this._getListArgs(args);\n      const qb = this.dbDriver(this.model.table_name);\n      const aliasColObjMap = await this.model.getAliasColObjMap();\n      const filterObj = extractFilterFromXwhere(where, aliasColObjMap);\n\n      await conditionV2(\n        [\n          new Filter({\n            children: args.filterArr || [],\n            is_group: true,\n            logical_op: 'and'\n          }),\n          new Filter({\n            children: filterObj,\n            is_group: true,\n            logical_op: 'and'\n          }),\n          ...(args.filterArr || [])\n        ],\n        qb,\n        this.dbDriver\n      );\n      qb.del();\n      return ((await qb) as any).count;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  /**\n   *  Hooks\n   * */\n\n  public async beforeInsert(data: any, _trx: any, req): Promise<void> {\n    await this.handleHooks('Before.insert', data, req);\n  }\n\n  public async afterInsert(data: any, _trx: any, req): Promise<void> {\n    await this.handleHooks('After.insert', data, req);\n    // if (req?.headers?.['xc-gui']) {\n    const id = this._extractPksValues(data);\n    Audit.insert({\n      fk_model_id: this.model.id,\n      row_id: id,\n      op_type: AuditOperationTypes.DATA,\n      op_sub_type: AuditOperationSubTypes.INSERT,\n      description: `${id} inserted into ${this.model.title}`,\n      // details: JSON.stringify(data),\n      ip: req?.clientIp,\n      user: req?.user?.email\n    });\n    // }\n  }\n\n  public async beforeUpdate(data: any, _trx: any, req): Promise<void> {\n    const ignoreWebhook = req.query?.ignoreWebhook;\n    if (ignoreWebhook) {\n      if (ignoreWebhook != 'true' && ignoreWebhook != 'false') {\n        throw new Error('ignoreWebhook value can be either true or false');\n      }\n    }\n    if (ignoreWebhook === undefined || ignoreWebhook === 'false') {\n      await this.handleHooks('Before.update', data, req);\n    }\n  }\n\n  public async afterUpdate(data: any, _trx: any, req): Promise<void> {\n    const ignoreWebhook = req.query?.ignoreWebhook;\n    if (ignoreWebhook) {\n      if (ignoreWebhook != 'true' && ignoreWebhook != 'false') {\n        throw new Error('ignoreWebhook value can be either true or false');\n      }\n    }\n    if (ignoreWebhook === undefined || ignoreWebhook === 'false') {\n      await this.handleHooks('After.update', data, req);\n    }\n  }\n\n  public async beforeDelete(data: any, _trx: any, req): Promise<void> {\n    await this.handleHooks('Before.delete', data, req);\n  }\n\n  public async afterDelete(data: any, _trx: any, req): Promise<void> {\n    // if (req?.headers?.['xc-gui']) {\n    const id = req?.params?.id;\n    Audit.insert({\n      fk_model_id: this.model.id,\n      row_id: id,\n      op_type: AuditOperationTypes.DATA,\n      op_sub_type: AuditOperationSubTypes.DELETE,\n      description: `${id} deleted from ${this.model.title}`,\n      // details: JSON.stringify(data),\n      ip: req?.clientIp,\n      user: req?.user?.email\n    });\n    // }\n    await this.handleHooks('After.delete', data, req);\n  }\n\n  private async handleHooks(hookName, data, req): Promise<void> {\n    // const data = _data;\n\n    const view = await View.get(this.viewId);\n\n    // handle form view data submission\n    if (hookName === 'After.insert' && view.type === ViewTypes.FORM) {\n      try {\n        const formView = await view.getView<FormView>();\n        const emails = Object.entries(JSON.parse(formView?.email) || {})\n          .filter(a => a[1])\n          .map(a => a[0]);\n        if (emails?.length) {\n          const transformedData = _transformSubmittedFormDataForEmail(\n            data,\n            formView,\n            await this.model.getColumns()\n          );\n          // todo: notification template\n          (await NcPluginMgrv2.emailAdapter())?.mailSend({\n            to: emails.join(','),\n            subject: 'NocoDB Form',\n            html: ejs.render(formSubmissionEmailTemplate, {\n              data: transformedData,\n              tn: this.model.table_name,\n              _tn: this.model.title\n            })\n          });\n        }\n      } catch (e) {\n        console.log(e);\n      }\n    }\n\n    try {\n      const [event, operation] = hookName.split('.');\n      const hooks = await Hook.list({\n        fk_model_id: this.model.id,\n        event,\n        operation\n      });\n      for (const hook of hooks) {\n        invokeWebhook(hook, this.model, data, req?.user);\n      }\n    } catch (e) {\n      console.log('hooks :: error', hookName, e);\n    }\n  }\n\n  // @ts-ignore\n  protected async errorInsert(e, data, trx, cookie) {}\n\n  // @ts-ignore\n  protected async errorUpdate(e, data, trx, cookie) {}\n\n  // todo: handle composite primary key\n  protected _extractPksValues(data: any) {\n    // data can be still inserted without PK\n    // TODO: return a meaningful value\n    if (!this.model.primaryKey) return 'N/A';\n    return (\n      data[this.model.primaryKey.title] ||\n      data[this.model.primaryKey.column_name]\n    );\n  }\n\n  // @ts-ignore\n  protected async errorDelete(e, id, trx, cookie) {}\n\n  async validate(columns) {\n    await this.model.getColumns();\n    // let cols = Object.keys(this.columns);\n    for (let i = 0; i < this.model.columns.length; ++i) {\n      const column = this.model.columns[i];\n      // skip validation if `validate` is undefined or false\n      if (!column?.meta?.validate) continue;\n\n      const validate = column.getValidators();\n      const cn = column.column_name;\n      if (!validate) continue;\n      const { func, msg } = validate;\n      for (let j = 0; j < func.length; ++j) {\n        const fn =\n          typeof func[j] === 'string'\n            ? customValidators[func[j]]\n              ? customValidators[func[j]]\n              : Validator[func[j]]\n            : func[j];\n        const arg =\n          typeof func[j] === 'string' ? columns[cn] + '' : columns[cn];\n        if (\n          columns[cn] !== null &&\n          columns[cn] !== undefined &&\n          columns[cn] !== '' &&\n          cn in columns &&\n          !(fn.constructor.name === 'AsyncFunction' ? await fn(arg) : fn(arg))\n        ) {\n          NcError.badRequest(\n            msg[j].replace(/\\{VALUE}/g, columns[cn]).replace(/\\{cn}/g, cn)\n          );\n        }\n      }\n    }\n    return true;\n  }\n\n  async addChild({\n    colId,\n    rowId,\n    childId\n  }: {\n    colId: string;\n    rowId: string;\n    childId: string;\n  }) {\n    const columns = await this.model.getColumns();\n    const column = columns.find(c => c.id === colId);\n\n    if (!column || column.uidt !== UITypes.LinkToAnotherRecord)\n      NcError.notFound('Column not found');\n\n    const colOptions = await column.getColOptions<LinkToAnotherRecordColumn>();\n\n    const childColumn = await colOptions.getChildColumn();\n    const parentColumn = await colOptions.getParentColumn();\n    const parentTable = await parentColumn.getModel();\n    const childTable = await childColumn.getModel();\n    await childTable.getColumns();\n    await parentTable.getColumns();\n\n    switch (colOptions.type) {\n      case RelationTypes.MANY_TO_MANY:\n        {\n          const vChildCol = await colOptions.getMMChildColumn();\n          const vParentCol = await colOptions.getMMParentColumn();\n          const vTable = await colOptions.getMMModel();\n\n          await this.dbDriver(vTable.table_name).insert({\n            [vParentCol.column_name]: this.dbDriver(parentTable.table_name)\n              .select(parentColumn.column_name)\n              .where(_wherePk(parentTable.primaryKeys, childId))\n              .first(),\n            [vChildCol.column_name]: this.dbDriver(childTable.table_name)\n              .select(childColumn.column_name)\n              .where(_wherePk(childTable.primaryKeys, rowId))\n              .first()\n          });\n        }\n        break;\n      case RelationTypes.HAS_MANY:\n        {\n          await this.dbDriver(childTable.table_name)\n            .update({\n              [childColumn.column_name]: this.dbDriver.from(\n                this.dbDriver(parentTable.table_name)\n                  .select(parentColumn.column_name)\n                  .where(_wherePk(parentTable.primaryKeys, rowId))\n                  .first()\n                  .as('___cn_alias')\n              )\n            })\n            .where(_wherePk(childTable.primaryKeys, childId));\n        }\n        break;\n      case RelationTypes.BELONGS_TO:\n        {\n          await this.dbDriver(childTable.table_name)\n            .update({\n              [childColumn.column_name]: this.dbDriver.from(\n                this.dbDriver(parentTable.table_name)\n                  .select(parentColumn.column_name)\n                  .where(_wherePk(parentTable.primaryKeys, childId))\n                  .first()\n                  .as('___cn_alias')\n              )\n            })\n            .where(_wherePk(childTable.primaryKeys, rowId));\n        }\n        break;\n    }\n  }\n\n  async removeChild({\n    colId,\n    rowId,\n    childId\n  }: {\n    colId: string;\n    rowId: string;\n    childId: string;\n  }) {\n    const columns = await this.model.getColumns();\n    const column = columns.find(c => c.id === colId);\n\n    if (!column || column.uidt !== UITypes.LinkToAnotherRecord)\n      NcError.notFound('Column not found');\n\n    const colOptions = await column.getColOptions<LinkToAnotherRecordColumn>();\n\n    const childColumn = await colOptions.getChildColumn();\n    const parentColumn = await colOptions.getParentColumn();\n    const parentTable = await parentColumn.getModel();\n    const childTable = await childColumn.getModel();\n    await childTable.getColumns();\n    await parentTable.getColumns();\n\n    switch (colOptions.type) {\n      case RelationTypes.MANY_TO_MANY:\n        {\n          const vChildCol = await colOptions.getMMChildColumn();\n          const vParentCol = await colOptions.getMMParentColumn();\n          const vTable = await colOptions.getMMModel();\n\n          await this.dbDriver(vTable.table_name)\n            .where({\n              [vParentCol.column_name]: this.dbDriver(parentTable.table_name)\n                .select(parentColumn.column_name)\n                .where(_wherePk(parentTable.primaryKeys, childId))\n                .first(),\n              [vChildCol.column_name]: this.dbDriver(childTable.table_name)\n                .select(childColumn.column_name)\n                .where(_wherePk(childTable.primaryKeys, rowId))\n                .first()\n            })\n            .delete();\n        }\n        break;\n      case RelationTypes.HAS_MANY:\n        {\n          await this.dbDriver(childTable.table_name)\n            // .where({\n            //   [childColumn.cn]: this.dbDriver(parentTable.tn)\n            //     .select(parentColumn.cn)\n            //     .where(parentTable.primaryKey.cn, rowId)\n            //     .first()\n            // })\n            .where(_wherePk(childTable.primaryKeys, childId))\n            .update({ [childColumn.column_name]: null });\n        }\n        break;\n      case RelationTypes.BELONGS_TO:\n        {\n          await this.dbDriver(childTable.table_name)\n            // .where({\n            //   [childColumn.cn]: this.dbDriver(parentTable.tn)\n            //     .select(parentColumn.cn)\n            //     .where(parentTable.primaryKey.cn, childId)\n            //     .first()\n            // })\n            .where(_wherePk(childTable.primaryKeys, rowId))\n            .update({ [childColumn.column_name]: null });\n        }\n        break;\n    }\n  }\n\n  private async extractRawQueryAndExec(qb: QueryBuilder) {\n    return this.isPg\n      ? qb\n      : await this.dbDriver.from(\n          this.dbDriver.raw(qb.toString()).wrap('(', ') __nc_alias')\n        );\n  }\n}\n\nfunction extractSortsObject(\n  _sorts: string | string[],\n  aliasColObjMap: { [columnAlias: string]: Column }\n): Sort[] | void {\n  if (!_sorts?.length) return;\n\n  let sorts = _sorts;\n\n  if (!Array.isArray(sorts)) sorts = sorts.split(',');\n\n  return sorts.map(s => {\n    const sort: SortType = { direction: 'asc' };\n    if (s.startsWith('-')) {\n      sort.direction = 'desc';\n      sort.fk_column_id = aliasColObjMap[s.slice(1)]?.id;\n    } else sort.fk_column_id = aliasColObjMap[s]?.id;\n\n    return new Sort(sort);\n  });\n}\n\nfunction extractFilterFromXwhere(\n  str,\n  aliasColObjMap: { [columnAlias: string]: Column }\n) {\n  if (!str) {\n    return [];\n  }\n\n  let nestedArrayConditions = [];\n\n  let openIndex = str.indexOf('((');\n\n  if (openIndex === -1) openIndex = str.indexOf('(~');\n\n  let nextOpenIndex = openIndex;\n  let closingIndex = str.indexOf('))');\n\n  // if it's a simple query simply return array of conditions\n  if (openIndex === -1) {\n    if (str && str != '~not')\n      nestedArrayConditions = str.split(\n        /(?=~(?:or(?:not)?|and(?:not)?|not)\\()/\n      );\n    return extractCondition(nestedArrayConditions || [], aliasColObjMap);\n  }\n\n  // iterate until finding right closing\n  while (\n    (nextOpenIndex = str\n      .substring(0, closingIndex)\n      .indexOf('((', nextOpenIndex + 1)) != -1\n  ) {\n    closingIndex = str.indexOf('))', closingIndex + 1);\n  }\n\n  if (closingIndex === -1)\n    throw new Error(\n      `${str\n        .substring(0, openIndex + 1)\n        .slice(-10)} : Closing bracket not found`\n    );\n\n  // getting operand starting index\n  const operandStartIndex = str.lastIndexOf('~', openIndex);\n  const operator =\n    operandStartIndex != -1\n      ? str.substring(operandStartIndex + 1, openIndex)\n      : '';\n  const lhsOfNestedQuery = str.substring(0, openIndex);\n\n  nestedArrayConditions.push(\n    ...extractFilterFromXwhere(lhsOfNestedQuery, aliasColObjMap),\n    // calling recursively for nested query\n    new Filter({\n      is_group: true,\n      logical_op: operator,\n      children: extractFilterFromXwhere(\n        str.substring(openIndex + 1, closingIndex + 1),\n        aliasColObjMap\n      )\n    }),\n    // RHS of nested query(recursion)\n    ...extractFilterFromXwhere(str.substring(closingIndex + 2), aliasColObjMap)\n  );\n  return nestedArrayConditions;\n}\n\nfunction extractCondition(nestedArrayConditions, aliasColObjMap) {\n  return nestedArrayConditions?.map(str => {\n    // eslint-disable-next-line prefer-const\n    let [logicOp, alias, op, value] =\n      str.match(/(?:~(and|or|not))?\\((.*?),(\\w+),(.*)\\)/)?.slice(1) || [];\n    if (op === 'in') value = value.split(',');\n\n    return new Filter({\n      comparison_op: op,\n      fk_column_id: aliasColObjMap[alias]?.id,\n      logical_op: logicOp,\n      value\n    });\n  });\n}\n\nfunction applyPaginate(\n  query,\n  {\n    limit = 20,\n    offset = 0,\n    ignoreLimit = false\n  }: XcFilter & { ignoreLimit?: boolean }\n) {\n  query.offset(offset);\n  if (!ignoreLimit) query.limit(limit);\n\n  return query;\n}\n\nfunction _wherePk(primaryKeys: Column[], id) {\n  const ids = (id + '').split('___');\n  const where = {};\n  for (let i = 0; i < primaryKeys.length; ++i) {\n    where[primaryKeys[i].column_name] = ids[i];\n  }\n  return where;\n}\n\nfunction getCompositePk(primaryKeys: Column[], row) {\n  return primaryKeys.map(c => row[c.title]).join('___');\n}\n\nexport function sanitize(v) {\n  return v?.replace(/([^\\\\]|^)([?])/g, '$1\\\\$2');\n}\n\nexport { BaseModelSqlv2 };\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n * @author Wing-Kam Wong <wingkwong.code@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n", "import Handlebars from 'handlebars';\nimport Model from '../../models/Model';\nimport NcPluginMgrv2 from './NcPluginMgrv2';\nimport Column from '../../models/Column';\nimport Hook from '../../models/Hook';\nimport Filter from '../../models/Filter';\nimport HookLog from '../../models/HookLog';\nimport { HookLogType } from 'nocodb-sdk';\n\nexport function parseBody(template: string, data: any): string {\n  if (!template) {\n    return template;\n  }\n\n  return Handlebars.compile(template, { noEscape: true })({\n    data\n  });\n}\n\nexport async function validateCondition(filters: Filter[], data: any) {\n  if (!filters.length) {\n    return true;\n  }\n\n  let isValid = true;\n  for (const _filter of filters) {\n    const filter = _filter instanceof Filter ? _filter : new Filter(_filter);\n    let res;\n    const field = await filter.getColumn().then(c => c.title);\n    let val = data[field];\n    switch (typeof filter.value) {\n      case 'boolean':\n        val = !!data[field];\n        break;\n      case 'number':\n        val = +data[field];\n        break;\n    }\n    switch (filter.comparison_op) {\n      case 'eq':\n        res = val == filter.value;\n        break;\n      case 'neq':\n        res = val != filter.value;\n        break;\n      case 'like':\n        res =\n          data[field]?.toLowerCase()?.indexOf(filter.value?.toLowerCase()) > -1;\n        break;\n      case 'nlike':\n        res =\n          data[field]?.toLowerCase()?.indexOf(filter.value?.toLowerCase()) ===\n          -1;\n        break;\n      case 'empty':\n        res =\n          data[field] === '' ||\n          data[field] === null ||\n          data[field] === undefined;\n        break;\n      case 'notempty':\n        res = !(\n          data[field] === '' ||\n          data[field] === null ||\n          data[field] === undefined\n        );\n        break;\n      case 'null':\n        res = res = data[field] === null;\n        break;\n      case 'notnull':\n        res = data[field] !== null;\n        break;\n      case 'lt':\n        res = +data[field] < +filter.value;\n        break;\n      case 'lte':\n      case 'le':\n        res = +data[field] <= +filter.value;\n        break;\n      case 'gt':\n        res = +data[field] > +filter.value;\n        break;\n      case 'gte':\n      case 'ge':\n        res = +data[field] >= +filter.value;\n        break;\n    }\n\n    switch (filter.logical_op) {\n      case 'or':\n        isValid = isValid || res;\n        break;\n      case 'not':\n        isValid = isValid && !res;\n        break;\n      case 'and':\n      default:\n        isValid = isValid && res;\n        break;\n    }\n  }\n\n  return isValid;\n}\n\nexport async function handleHttpWebHook(apiMeta, user, data) {\n  // try {\n  const req = axiosRequestMake(apiMeta, user, data);\n  await require('axios')(req);\n  // } catch (e) {\n  //   console.log(e);\n  // }\n}\n\nexport function axiosRequestMake(_apiMeta, _user, data) {\n  const apiMeta = { ..._apiMeta };\n  if (apiMeta.body) {\n    try {\n      apiMeta.body = JSON.parse(apiMeta.body, (_key, value) => {\n        return typeof value === 'string' ? parseBody(value, data) : value;\n      });\n    } catch (e) {\n      apiMeta.body = parseBody(apiMeta.body, data);\n    }\n  }\n  if (apiMeta.auth) {\n    try {\n      apiMeta.auth = JSON.parse(apiMeta.auth, (_key, value) => {\n        return typeof value === 'string' ? parseBody(value, data) : value;\n      });\n    } catch (e) {\n      apiMeta.auth = parseBody(apiMeta.auth, data);\n    }\n  }\n  apiMeta.response = {};\n  const req = {\n    params: apiMeta.parameters\n      ? apiMeta.parameters.reduce((paramsObj, param) => {\n          if (param.name && param.enabled) {\n            paramsObj[param.name] = parseBody(param.value, data);\n          }\n          return paramsObj;\n        }, {})\n      : {},\n    url: parseBody(apiMeta.path, data),\n    method: apiMeta.method,\n    data: apiMeta.body,\n    headers: apiMeta.headers\n      ? apiMeta.headers.reduce((headersObj, header) => {\n          if (header.name && header.enabled) {\n            headersObj[header.name] = parseBody(header.value, data);\n          }\n          return headersObj;\n        }, {})\n      : {},\n    withCredentials: true\n  };\n  return req;\n}\n\nexport async function invokeWebhook(\n  hook: Hook,\n  _model: Model,\n  data,\n  user,\n  testFilters = null,\n  throwErrorOnFailure = false\n) {\n  let hookLog: HookLogType;\n  const startTime = process.hrtime();\n  try {\n    // for (const hook of hooks) {\n    const notification =\n      typeof hook.notification === 'string'\n        ? JSON.parse(hook.notification)\n        : hook.notification;\n\n    if (hook.condition) {\n      if (\n        !(await validateCondition(\n          testFilters || (await hook.getFilters()),\n          data\n        ))\n      ) {\n        return;\n      }\n    }\n\n    switch (notification?.type) {\n      case 'Email':\n        {\n          const res = await (await NcPluginMgrv2.emailAdapter())?.mailSend({\n            to: parseBody(notification?.payload?.to, data),\n            subject: parseBody(notification?.payload?.subject, data),\n            html: parseBody(notification?.payload?.body, data)\n          });\n          hookLog = {\n            ...hook,\n            type: notification.type,\n            payload: JSON.stringify(notification?.payload),\n            response: JSON.stringify(res),\n            triggered_by: user?.email\n          };\n        }\n        break;\n      case 'URL':\n        {\n          const res = await handleHttpWebHook(\n            notification?.payload,\n            user,\n            data\n          );\n\n          hookLog = {\n            ...hook,\n            type: notification.type,\n            payload: JSON.stringify(notification?.payload),\n            response: JSON.stringify(res),\n            triggered_by: user?.email\n          };\n        }\n        break;\n      default:\n        {\n          const res = await (\n            await NcPluginMgrv2.webhookNotificationAdapters(notification.type)\n          ).sendMessage(\n            parseBody(notification?.payload?.body, data),\n            JSON.parse(JSON.stringify(notification?.payload), (_key, value) => {\n              return typeof value === 'string' ? parseBody(value, data) : value;\n            })\n          );\n\n          hookLog = {\n            ...hook,\n            type: notification.type,\n            payload: JSON.stringify(notification?.payload),\n            response: JSON.stringify(res),\n            triggered_by: user?.email\n          };\n        }\n        break;\n    }\n  } catch (e) {\n    console.log(e);\n    hookLog = {\n      ...hook,\n      error_code: e.error_code,\n      error_message: e.message,\n      error: JSON.stringify(e)\n    };\n    if (throwErrorOnFailure) throw e;\n  } finally {\n    if (hookLog) {\n      hookLog.execution_time = parseHrtimeToMilliSeconds(\n        process.hrtime(startTime)\n      );\n      HookLog.insert({ ...hookLog, test_call: !!testFilters });\n    }\n  }\n}\n\nexport function _transformSubmittedFormDataForEmail(\n  data,\n  // @ts-ignore\n  formView,\n  // @ts-ignore\n  columns: Column[]\n) {\n  const transformedData = { ...data };\n\n  for (const col of columns) {\n    if (!formView.query_params?.showFields?.[col.title]) {\n      delete transformedData[col.title];\n      continue;\n    }\n\n    if (col.uidt === 'Attachment') {\n      if (typeof transformedData[col.title] === 'string') {\n        transformedData[col.title] = JSON.parse(transformedData[col.title]);\n      }\n      transformedData[col.title] = (transformedData[col.title] || [])\n        .map(attachment => {\n          if (\n            ['jpeg', 'gif', 'png', 'apng', 'svg', 'bmp', 'ico', 'jpg'].includes(\n              attachment.title.split('.').pop()\n            )\n          ) {\n            return `<a href=\"${attachment.url}\" target=\"_blank\"><img height=\"50px\" src=\"${attachment.url}\"/></a>`;\n          }\n          return `<a href=\"${attachment.url}\" target=\"_blank\">${attachment.title}</a>`;\n        })\n        .join('&nbsp;');\n    } else if (\n      transformedData[col.title] &&\n      typeof transformedData[col.title] === 'object'\n    ) {\n      transformedData[col.title] = JSON.stringify(transformedData[col.title]);\n    }\n  }\n}\n\nfunction parseHrtimeToMilliSeconds(hrtime) {\n  const milliseconds = (hrtime[0] + hrtime[1] / 1e6).toFixed(3);\n  return milliseconds;\n}\n"], "filenames": ["packages/noco-docs/content/en/developer-resources/webhooks.md", "packages/nocodb/src/lib/db/sql-data-mapper/lib/sql/BaseModelSqlv2.ts", "packages/nocodb/src/lib/meta/helpers/webhookHelpers.ts"], "buggy_code_start_loc": [69, 37, 10], "buggy_code_end_loc": [78, 1795, 271], "fixing_code_start_loc": [68, 37, 10], "fixing_code_end_loc": [72, 1794, 232], "type": "CWE-269", "message": "Improper Privilege Management in GitHub repository nocodb/nocodb prior to 0.91.7+.", "other": {"cve": {"id": "CVE-2022-2063", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-13T12:15:08.187", "lastModified": "2022-06-22T15:15:56.310", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Privilege Management in GitHub repository nocodb/nocodb prior to 0.91.7+."}, {"lang": "es", "value": "Una Administraci\u00f3n inapropiada de Privilegios en el repositorio de GitHub nocodb/nocodb versiones anteriores a 0.91.7+"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xgenecloud:nocodb:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.91.7", "matchCriteriaId": "1E79120D-C248-4A67-AC09-AECFDFFB240F"}]}]}], "references": [{"url": "https://github.com/nocodb/nocodb/commit/269a19c2ad89a0e8a7596498e3806ff2ec1040c2", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/156f405b-21d6-4384-9bff-17ebfe484e20", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nocodb/nocodb/commit/269a19c2ad89a0e8a7596498e3806ff2ec1040c2"}}