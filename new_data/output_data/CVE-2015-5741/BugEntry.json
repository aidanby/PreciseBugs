{"buggy_code": ["// Copyright 2010 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage http\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype reqTest struct {\n\tRaw     string\n\tReq     *Request\n\tBody    string\n\tTrailer Header\n\tError   string\n}\n\nvar noError = \"\"\nvar noBody = \"\"\nvar noTrailer Header = nil\n\nvar reqTests = []reqTest{\n\t// Baseline test; All Request fields included for template use\n\t{\n\t\t\"GET http://www.techcrunch.com/ HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: www.techcrunch.com\\r\\n\" +\n\t\t\t\"User-Agent: Fake\\r\\n\" +\n\t\t\t\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n\" +\n\t\t\t\"Accept-Language: en-us,en;q=0.5\\r\\n\" +\n\t\t\t\"Accept-Encoding: gzip,deflate\\r\\n\" +\n\t\t\t\"Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\\r\\n\" +\n\t\t\t\"Keep-Alive: 300\\r\\n\" +\n\t\t\t\"Content-Length: 7\\r\\n\" +\n\t\t\t\"Proxy-Connection: keep-alive\\r\\n\\r\\n\" +\n\t\t\t\"abcdef\\n???\",\n\n\t\t&Request{\n\t\t\tMethod: \"GET\",\n\t\t\tURL: &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   \"www.techcrunch.com\",\n\t\t\t\tPath:   \"/\",\n\t\t\t},\n\t\t\tProto:      \"HTTP/1.1\",\n\t\t\tProtoMajor: 1,\n\t\t\tProtoMinor: 1,\n\t\t\tHeader: Header{\n\t\t\t\t\"Accept\":           {\"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\"},\n\t\t\t\t\"Accept-Language\":  {\"en-us,en;q=0.5\"},\n\t\t\t\t\"Accept-Encoding\":  {\"gzip,deflate\"},\n\t\t\t\t\"Accept-Charset\":   {\"ISO-8859-1,utf-8;q=0.7,*;q=0.7\"},\n\t\t\t\t\"Keep-Alive\":       {\"300\"},\n\t\t\t\t\"Proxy-Connection\": {\"keep-alive\"},\n\t\t\t\t\"Content-Length\":   {\"7\"},\n\t\t\t\t\"User-Agent\":       {\"Fake\"},\n\t\t\t},\n\t\t\tClose:         false,\n\t\t\tContentLength: 7,\n\t\t\tHost:          \"www.techcrunch.com\",\n\t\t\tRequestURI:    \"http://www.techcrunch.com/\",\n\t\t},\n\n\t\t\"abcdef\\n\",\n\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// GET request with no body (the normal case)\n\t{\n\t\t\"GET / HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: foo.com\\r\\n\\r\\n\",\n\n\t\t&Request{\n\t\t\tMethod: \"GET\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"/\",\n\t\t\t},\n\t\t\tProto:         \"HTTP/1.1\",\n\t\t\tProtoMajor:    1,\n\t\t\tProtoMinor:    1,\n\t\t\tHeader:        Header{},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tHost:          \"foo.com\",\n\t\t\tRequestURI:    \"/\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// Tests that we don't parse a path that looks like a\n\t// scheme-relative URI as a scheme-relative URI.\n\t{\n\t\t\"GET //user@host/is/actually/a/path/ HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: test\\r\\n\\r\\n\",\n\n\t\t&Request{\n\t\t\tMethod: \"GET\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"//user@host/is/actually/a/path/\",\n\t\t\t},\n\t\t\tProto:         \"HTTP/1.1\",\n\t\t\tProtoMajor:    1,\n\t\t\tProtoMinor:    1,\n\t\t\tHeader:        Header{},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tHost:          \"test\",\n\t\t\tRequestURI:    \"//user@host/is/actually/a/path/\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// Tests a bogus abs_path on the Request-Line (RFC 2616 section 5.1.2)\n\t{\n\t\t\"GET ../../../../etc/passwd HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: test\\r\\n\\r\\n\",\n\t\tnil,\n\t\tnoBody,\n\t\tnoTrailer,\n\t\t\"parse ../../../../etc/passwd: invalid URI for request\",\n\t},\n\n\t// Tests missing URL:\n\t{\n\t\t\"GET  HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: test\\r\\n\\r\\n\",\n\t\tnil,\n\t\tnoBody,\n\t\tnoTrailer,\n\t\t\"parse : empty url\",\n\t},\n\n\t// Tests chunked body with trailer:\n\t{\n\t\t\"POST / HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: foo.com\\r\\n\" +\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n\t\t\t\"3\\r\\nfoo\\r\\n\" +\n\t\t\t\"3\\r\\nbar\\r\\n\" +\n\t\t\t\"0\\r\\n\" +\n\t\t\t\"Trailer-Key: Trailer-Value\\r\\n\" +\n\t\t\t\"\\r\\n\",\n\t\t&Request{\n\t\t\tMethod: \"POST\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"/\",\n\t\t\t},\n\t\t\tTransferEncoding: []string{\"chunked\"},\n\t\t\tProto:            \"HTTP/1.1\",\n\t\t\tProtoMajor:       1,\n\t\t\tProtoMinor:       1,\n\t\t\tHeader:           Header{},\n\t\t\tContentLength:    -1,\n\t\t\tHost:             \"foo.com\",\n\t\t\tRequestURI:       \"/\",\n\t\t},\n\n\t\t\"foobar\",\n\t\tHeader{\n\t\t\t\"Trailer-Key\": {\"Trailer-Value\"},\n\t\t},\n\t\tnoError,\n\t},\n\n\t// CONNECT request with domain name:\n\t{\n\t\t\"CONNECT www.google.com:443 HTTP/1.1\\r\\n\\r\\n\",\n\n\t\t&Request{\n\t\t\tMethod: \"CONNECT\",\n\t\t\tURL: &url.URL{\n\t\t\t\tHost: \"www.google.com:443\",\n\t\t\t},\n\t\t\tProto:         \"HTTP/1.1\",\n\t\t\tProtoMajor:    1,\n\t\t\tProtoMinor:    1,\n\t\t\tHeader:        Header{},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tHost:          \"www.google.com:443\",\n\t\t\tRequestURI:    \"www.google.com:443\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// CONNECT request with IP address:\n\t{\n\t\t\"CONNECT 127.0.0.1:6060 HTTP/1.1\\r\\n\\r\\n\",\n\n\t\t&Request{\n\t\t\tMethod: \"CONNECT\",\n\t\t\tURL: &url.URL{\n\t\t\t\tHost: \"127.0.0.1:6060\",\n\t\t\t},\n\t\t\tProto:         \"HTTP/1.1\",\n\t\t\tProtoMajor:    1,\n\t\t\tProtoMinor:    1,\n\t\t\tHeader:        Header{},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tHost:          \"127.0.0.1:6060\",\n\t\t\tRequestURI:    \"127.0.0.1:6060\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// CONNECT request for RPC:\n\t{\n\t\t\"CONNECT /_goRPC_ HTTP/1.1\\r\\n\\r\\n\",\n\n\t\t&Request{\n\t\t\tMethod: \"CONNECT\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"/_goRPC_\",\n\t\t\t},\n\t\t\tProto:         \"HTTP/1.1\",\n\t\t\tProtoMajor:    1,\n\t\t\tProtoMinor:    1,\n\t\t\tHeader:        Header{},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tHost:          \"\",\n\t\t\tRequestURI:    \"/_goRPC_\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// SSDP Notify request. golang.org/issue/3692\n\t{\n\t\t\"NOTIFY * HTTP/1.1\\r\\nServer: foo\\r\\n\\r\\n\",\n\t\t&Request{\n\t\t\tMethod: \"NOTIFY\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"*\",\n\t\t\t},\n\t\t\tProto:      \"HTTP/1.1\",\n\t\t\tProtoMajor: 1,\n\t\t\tProtoMinor: 1,\n\t\t\tHeader: Header{\n\t\t\t\t\"Server\": []string{\"foo\"},\n\t\t\t},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tRequestURI:    \"*\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// OPTIONS request. Similar to golang.org/issue/3692\n\t{\n\t\t\"OPTIONS * HTTP/1.1\\r\\nServer: foo\\r\\n\\r\\n\",\n\t\t&Request{\n\t\t\tMethod: \"OPTIONS\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"*\",\n\t\t\t},\n\t\t\tProto:      \"HTTP/1.1\",\n\t\t\tProtoMajor: 1,\n\t\t\tProtoMinor: 1,\n\t\t\tHeader: Header{\n\t\t\t\t\"Server\": []string{\"foo\"},\n\t\t\t},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tRequestURI:    \"*\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// Connection: close. golang.org/issue/8261\n\t{\n\t\t\"GET / HTTP/1.1\\r\\nHost: issue8261.com\\r\\nConnection: close\\r\\n\\r\\n\",\n\t\t&Request{\n\t\t\tMethod: \"GET\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"/\",\n\t\t\t},\n\t\t\tHeader: Header{\n\t\t\t\t// This wasn't removed from Go 1.0 to\n\t\t\t\t// Go 1.3, so locking it in that we\n\t\t\t\t// keep this:\n\t\t\t\t\"Connection\": []string{\"close\"},\n\t\t\t},\n\t\t\tHost:       \"issue8261.com\",\n\t\t\tProto:      \"HTTP/1.1\",\n\t\t\tProtoMajor: 1,\n\t\t\tProtoMinor: 1,\n\t\t\tClose:      true,\n\t\t\tRequestURI: \"/\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n}\n\nfunc TestReadRequest(t *testing.T) {\n\tfor i := range reqTests {\n\t\ttt := &reqTests[i]\n\t\treq, err := ReadRequest(bufio.NewReader(strings.NewReader(tt.Raw)))\n\t\tif err != nil {\n\t\t\tif err.Error() != tt.Error {\n\t\t\t\tt.Errorf(\"#%d: error %q, want error %q\", i, err.Error(), tt.Error)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\trbody := req.Body\n\t\treq.Body = nil\n\t\ttestName := fmt.Sprintf(\"Test %d (%q)\", i, tt.Raw)\n\t\tdiff(t, testName, req, tt.Req)\n\t\tvar bout bytes.Buffer\n\t\tif rbody != nil {\n\t\t\t_, err := io.Copy(&bout, rbody)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%s: copying body: %v\", testName, err)\n\t\t\t}\n\t\t\trbody.Close()\n\t\t}\n\t\tbody := bout.String()\n\t\tif body != tt.Body {\n\t\t\tt.Errorf(\"%s: Body = %q want %q\", testName, body, tt.Body)\n\t\t}\n\t\tif !reflect.DeepEqual(tt.Trailer, req.Trailer) {\n\t\t\tt.Errorf(\"%s: Trailers differ.\\n got: %v\\nwant: %v\", testName, req.Trailer, tt.Trailer)\n\t\t}\n\t}\n}\n\nfunc TestReadRequest_BadConnectHost(t *testing.T) {\n\tdata := []byte(\"CONNECT []%20%48%54%54%50%2f%31%2e%31%0a%4d%79%48%65%61%64%65%72%3a%20%31%32%33%0a%0a HTTP/1.0\\n\\n\")\n\tr, err := ReadRequest(bufio.NewReader(bytes.NewReader(data)))\n\tif err == nil {\n\t\tt.Fatal(\"Got unexpected request = %#v\", r)\n\t}\n}\n", "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage http\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http/internal\"\n\t\"net/textproto\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// ErrLineTooLong is returned when reading request or response bodies\n// with malformed chunked encoding.\nvar ErrLineTooLong = internal.ErrLineTooLong\n\ntype errorReader struct {\n\terr error\n}\n\nfunc (r errorReader) Read(p []byte) (n int, err error) {\n\treturn 0, r.err\n}\n\n// transferWriter inspects the fields of a user-supplied Request or Response,\n// sanitizes them without changing the user object and provides methods for\n// writing the respective header, body and trailer in wire format.\ntype transferWriter struct {\n\tMethod           string\n\tBody             io.Reader\n\tBodyCloser       io.Closer\n\tResponseToHEAD   bool\n\tContentLength    int64 // -1 means unknown, 0 means exactly none\n\tClose            bool\n\tTransferEncoding []string\n\tTrailer          Header\n\tIsResponse       bool\n}\n\nfunc newTransferWriter(r interface{}) (t *transferWriter, err error) {\n\tt = &transferWriter{}\n\n\t// Extract relevant fields\n\tatLeastHTTP11 := false\n\tswitch rr := r.(type) {\n\tcase *Request:\n\t\tif rr.ContentLength != 0 && rr.Body == nil {\n\t\t\treturn nil, fmt.Errorf(\"http: Request.ContentLength=%d with nil Body\", rr.ContentLength)\n\t\t}\n\t\tt.Method = rr.Method\n\t\tt.Body = rr.Body\n\t\tt.BodyCloser = rr.Body\n\t\tt.ContentLength = rr.ContentLength\n\t\tt.Close = rr.Close\n\t\tt.TransferEncoding = rr.TransferEncoding\n\t\tt.Trailer = rr.Trailer\n\t\tatLeastHTTP11 = rr.ProtoAtLeast(1, 1)\n\t\tif t.Body != nil && len(t.TransferEncoding) == 0 && atLeastHTTP11 {\n\t\t\tif t.ContentLength == 0 {\n\t\t\t\t// Test to see if it's actually zero or just unset.\n\t\t\t\tvar buf [1]byte\n\t\t\t\tn, rerr := io.ReadFull(t.Body, buf[:])\n\t\t\t\tif rerr != nil && rerr != io.EOF {\n\t\t\t\t\tt.ContentLength = -1\n\t\t\t\t\tt.Body = errorReader{rerr}\n\t\t\t\t} else if n == 1 {\n\t\t\t\t\t// Oh, guess there is data in this Body Reader after all.\n\t\t\t\t\t// The ContentLength field just wasn't set.\n\t\t\t\t\t// Stich the Body back together again, re-attaching our\n\t\t\t\t\t// consumed byte.\n\t\t\t\t\tt.ContentLength = -1\n\t\t\t\t\tt.Body = io.MultiReader(bytes.NewReader(buf[:]), t.Body)\n\t\t\t\t} else {\n\t\t\t\t\t// Body is actually empty.\n\t\t\t\t\tt.Body = nil\n\t\t\t\t\tt.BodyCloser = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\tif t.ContentLength < 0 {\n\t\t\t\tt.TransferEncoding = []string{\"chunked\"}\n\t\t\t}\n\t\t}\n\tcase *Response:\n\t\tt.IsResponse = true\n\t\tif rr.Request != nil {\n\t\t\tt.Method = rr.Request.Method\n\t\t}\n\t\tt.Body = rr.Body\n\t\tt.BodyCloser = rr.Body\n\t\tt.ContentLength = rr.ContentLength\n\t\tt.Close = rr.Close\n\t\tt.TransferEncoding = rr.TransferEncoding\n\t\tt.Trailer = rr.Trailer\n\t\tatLeastHTTP11 = rr.ProtoAtLeast(1, 1)\n\t\tt.ResponseToHEAD = noBodyExpected(t.Method)\n\t}\n\n\t// Sanitize Body,ContentLength,TransferEncoding\n\tif t.ResponseToHEAD {\n\t\tt.Body = nil\n\t\tif chunked(t.TransferEncoding) {\n\t\t\tt.ContentLength = -1\n\t\t}\n\t} else {\n\t\tif !atLeastHTTP11 || t.Body == nil {\n\t\t\tt.TransferEncoding = nil\n\t\t}\n\t\tif chunked(t.TransferEncoding) {\n\t\t\tt.ContentLength = -1\n\t\t} else if t.Body == nil { // no chunking, no body\n\t\t\tt.ContentLength = 0\n\t\t}\n\t}\n\n\t// Sanitize Trailer\n\tif !chunked(t.TransferEncoding) {\n\t\tt.Trailer = nil\n\t}\n\n\treturn t, nil\n}\n\nfunc noBodyExpected(requestMethod string) bool {\n\treturn requestMethod == \"HEAD\"\n}\n\nfunc (t *transferWriter) shouldSendContentLength() bool {\n\tif chunked(t.TransferEncoding) {\n\t\treturn false\n\t}\n\tif t.ContentLength > 0 {\n\t\treturn true\n\t}\n\tif t.ContentLength < 0 {\n\t\treturn false\n\t}\n\t// Many servers expect a Content-Length for these methods\n\tif t.Method == \"POST\" || t.Method == \"PUT\" {\n\t\treturn true\n\t}\n\tif t.ContentLength == 0 && isIdentity(t.TransferEncoding) {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (t *transferWriter) WriteHeader(w io.Writer) error {\n\tif t.Close {\n\t\tif _, err := io.WriteString(w, \"Connection: close\\r\\n\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Write Content-Length and/or Transfer-Encoding whose values are a\n\t// function of the sanitized field triple (Body, ContentLength,\n\t// TransferEncoding)\n\tif t.shouldSendContentLength() {\n\t\tif _, err := io.WriteString(w, \"Content-Length: \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := io.WriteString(w, strconv.FormatInt(t.ContentLength, 10)+\"\\r\\n\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if chunked(t.TransferEncoding) {\n\t\tif _, err := io.WriteString(w, \"Transfer-Encoding: chunked\\r\\n\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Write Trailer header\n\tif t.Trailer != nil {\n\t\tkeys := make([]string, 0, len(t.Trailer))\n\t\tfor k := range t.Trailer {\n\t\t\tk = CanonicalHeaderKey(k)\n\t\t\tswitch k {\n\t\t\tcase \"Transfer-Encoding\", \"Trailer\", \"Content-Length\":\n\t\t\t\treturn &badStringError{\"invalid Trailer key\", k}\n\t\t\t}\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\tif len(keys) > 0 {\n\t\t\tsort.Strings(keys)\n\t\t\t// TODO: could do better allocation-wise here, but trailers are rare,\n\t\t\t// so being lazy for now.\n\t\t\tif _, err := io.WriteString(w, \"Trailer: \"+strings.Join(keys, \",\")+\"\\r\\n\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (t *transferWriter) WriteBody(w io.Writer) error {\n\tvar err error\n\tvar ncopy int64\n\n\t// Write body\n\tif t.Body != nil {\n\t\tif chunked(t.TransferEncoding) {\n\t\t\tif bw, ok := w.(*bufio.Writer); ok && !t.IsResponse {\n\t\t\t\tw = &internal.FlushAfterChunkWriter{bw}\n\t\t\t}\n\t\t\tcw := internal.NewChunkedWriter(w)\n\t\t\t_, err = io.Copy(cw, t.Body)\n\t\t\tif err == nil {\n\t\t\t\terr = cw.Close()\n\t\t\t}\n\t\t} else if t.ContentLength == -1 {\n\t\t\tncopy, err = io.Copy(w, t.Body)\n\t\t} else {\n\t\t\tncopy, err = io.Copy(w, io.LimitReader(t.Body, t.ContentLength))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tvar nextra int64\n\t\t\tnextra, err = io.Copy(ioutil.Discard, t.Body)\n\t\t\tncopy += nextra\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = t.BodyCloser.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif !t.ResponseToHEAD && t.ContentLength != -1 && t.ContentLength != ncopy {\n\t\treturn fmt.Errorf(\"http: ContentLength=%d with Body length %d\",\n\t\t\tt.ContentLength, ncopy)\n\t}\n\n\tif chunked(t.TransferEncoding) {\n\t\t// Write Trailer header\n\t\tif t.Trailer != nil {\n\t\t\tif err := t.Trailer.Write(w); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\t// Last chunk, empty trailer\n\t\t_, err = io.WriteString(w, \"\\r\\n\")\n\t}\n\treturn err\n}\n\ntype transferReader struct {\n\t// Input\n\tHeader        Header\n\tStatusCode    int\n\tRequestMethod string\n\tProtoMajor    int\n\tProtoMinor    int\n\t// Output\n\tBody             io.ReadCloser\n\tContentLength    int64\n\tTransferEncoding []string\n\tClose            bool\n\tTrailer          Header\n}\n\n// bodyAllowedForStatus reports whether a given response status code\n// permits a body.  See RFC2616, section 4.4.\nfunc bodyAllowedForStatus(status int) bool {\n\tswitch {\n\tcase status >= 100 && status <= 199:\n\t\treturn false\n\tcase status == 204:\n\t\treturn false\n\tcase status == 304:\n\t\treturn false\n\t}\n\treturn true\n}\n\nvar (\n\tsuppressedHeaders304    = []string{\"Content-Type\", \"Content-Length\", \"Transfer-Encoding\"}\n\tsuppressedHeadersNoBody = []string{\"Content-Length\", \"Transfer-Encoding\"}\n)\n\nfunc suppressedHeaders(status int) []string {\n\tswitch {\n\tcase status == 304:\n\t\t// RFC 2616 section 10.3.5: \"the response MUST NOT include other entity-headers\"\n\t\treturn suppressedHeaders304\n\tcase !bodyAllowedForStatus(status):\n\t\treturn suppressedHeadersNoBody\n\t}\n\treturn nil\n}\n\n// msg is *Request or *Response.\nfunc readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n\tt := &transferReader{RequestMethod: \"GET\"}\n\n\t// Unify input\n\tisResponse := false\n\tswitch rr := msg.(type) {\n\tcase *Response:\n\t\tt.Header = rr.Header\n\t\tt.StatusCode = rr.StatusCode\n\t\tt.ProtoMajor = rr.ProtoMajor\n\t\tt.ProtoMinor = rr.ProtoMinor\n\t\tt.Close = shouldClose(t.ProtoMajor, t.ProtoMinor, t.Header, true)\n\t\tisResponse = true\n\t\tif rr.Request != nil {\n\t\t\tt.RequestMethod = rr.Request.Method\n\t\t}\n\tcase *Request:\n\t\tt.Header = rr.Header\n\t\tt.ProtoMajor = rr.ProtoMajor\n\t\tt.ProtoMinor = rr.ProtoMinor\n\t\t// Transfer semantics for Requests are exactly like those for\n\t\t// Responses with status code 200, responding to a GET method\n\t\tt.StatusCode = 200\n\t\tt.Close = rr.Close\n\tdefault:\n\t\tpanic(\"unexpected type\")\n\t}\n\n\t// Default to HTTP/1.1\n\tif t.ProtoMajor == 0 && t.ProtoMinor == 0 {\n\t\tt.ProtoMajor, t.ProtoMinor = 1, 1\n\t}\n\n\t// Transfer encoding, content length\n\tt.TransferEncoding, err = fixTransferEncoding(t.RequestMethod, t.Header)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trealLength, err := fixLength(isResponse, t.StatusCode, t.RequestMethod, t.Header, t.TransferEncoding)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif isResponse && t.RequestMethod == \"HEAD\" {\n\t\tif n, err := parseContentLength(t.Header.get(\"Content-Length\")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tt.ContentLength = n\n\t\t}\n\t} else {\n\t\tt.ContentLength = realLength\n\t}\n\n\t// Trailer\n\tt.Trailer, err = fixTrailer(t.Header, t.TransferEncoding)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If there is no Content-Length or chunked Transfer-Encoding on a *Response\n\t// and the status is not 1xx, 204 or 304, then the body is unbounded.\n\t// See RFC2616, section 4.4.\n\tswitch msg.(type) {\n\tcase *Response:\n\t\tif realLength == -1 &&\n\t\t\t!chunked(t.TransferEncoding) &&\n\t\t\tbodyAllowedForStatus(t.StatusCode) {\n\t\t\t// Unbounded body.\n\t\t\tt.Close = true\n\t\t}\n\t}\n\n\t// Prepare body reader.  ContentLength < 0 means chunked encoding\n\t// or close connection when finished, since multipart is not supported yet\n\tswitch {\n\tcase chunked(t.TransferEncoding):\n\t\tif noBodyExpected(t.RequestMethod) {\n\t\t\tt.Body = eofReader\n\t\t} else {\n\t\t\tt.Body = &body{src: internal.NewChunkedReader(r), hdr: msg, r: r, closing: t.Close}\n\t\t}\n\tcase realLength == 0:\n\t\tt.Body = eofReader\n\tcase realLength > 0:\n\t\tt.Body = &body{src: io.LimitReader(r, realLength), closing: t.Close}\n\tdefault:\n\t\t// realLength < 0, i.e. \"Content-Length\" not mentioned in header\n\t\tif t.Close {\n\t\t\t// Close semantics (i.e. HTTP/1.0)\n\t\t\tt.Body = &body{src: r, closing: t.Close}\n\t\t} else {\n\t\t\t// Persistent connection (i.e. HTTP/1.1)\n\t\t\tt.Body = eofReader\n\t\t}\n\t}\n\n\t// Unify output\n\tswitch rr := msg.(type) {\n\tcase *Request:\n\t\trr.Body = t.Body\n\t\trr.ContentLength = t.ContentLength\n\t\trr.TransferEncoding = t.TransferEncoding\n\t\trr.Close = t.Close\n\t\trr.Trailer = t.Trailer\n\tcase *Response:\n\t\trr.Body = t.Body\n\t\trr.ContentLength = t.ContentLength\n\t\trr.TransferEncoding = t.TransferEncoding\n\t\trr.Close = t.Close\n\t\trr.Trailer = t.Trailer\n\t}\n\n\treturn nil\n}\n\n// Checks whether chunked is part of the encodings stack\nfunc chunked(te []string) bool { return len(te) > 0 && te[0] == \"chunked\" }\n\n// Checks whether the encoding is explicitly \"identity\".\nfunc isIdentity(te []string) bool { return len(te) == 1 && te[0] == \"identity\" }\n\n// Sanitize transfer encoding\nfunc fixTransferEncoding(requestMethod string, header Header) ([]string, error) {\n\traw, present := header[\"Transfer-Encoding\"]\n\tif !present {\n\t\treturn nil, nil\n\t}\n\n\tdelete(header, \"Transfer-Encoding\")\n\n\tencodings := strings.Split(raw[0], \",\")\n\tte := make([]string, 0, len(encodings))\n\t// TODO: Even though we only support \"identity\" and \"chunked\"\n\t// encodings, the loop below is designed with foresight. One\n\t// invariant that must be maintained is that, if present,\n\t// chunked encoding must always come first.\n\tfor _, encoding := range encodings {\n\t\tencoding = strings.ToLower(strings.TrimSpace(encoding))\n\t\t// \"identity\" encoding is not recorded\n\t\tif encoding == \"identity\" {\n\t\t\tbreak\n\t\t}\n\t\tif encoding != \"chunked\" {\n\t\t\treturn nil, &badStringError{\"unsupported transfer encoding\", encoding}\n\t\t}\n\t\tte = te[0 : len(te)+1]\n\t\tte[len(te)-1] = encoding\n\t}\n\tif len(te) > 1 {\n\t\treturn nil, &badStringError{\"too many transfer encodings\", strings.Join(te, \",\")}\n\t}\n\tif len(te) > 0 {\n\t\t// Chunked encoding trumps Content-Length. See RFC 2616\n\t\t// Section 4.4. Currently len(te) > 0 implies chunked\n\t\t// encoding.\n\t\tdelete(header, \"Content-Length\")\n\t\treturn te, nil\n\t}\n\n\treturn nil, nil\n}\n\n// Determine the expected body length, using RFC 2616 Section 4.4. This\n// function is not a method, because ultimately it should be shared by\n// ReadResponse and ReadRequest.\nfunc fixLength(isResponse bool, status int, requestMethod string, header Header, te []string) (int64, error) {\n\n\t// Logic based on response type or status\n\tif noBodyExpected(requestMethod) {\n\t\treturn 0, nil\n\t}\n\tif status/100 == 1 {\n\t\treturn 0, nil\n\t}\n\tswitch status {\n\tcase 204, 304:\n\t\treturn 0, nil\n\t}\n\n\t// Logic based on Transfer-Encoding\n\tif chunked(te) {\n\t\treturn -1, nil\n\t}\n\n\t// Logic based on Content-Length\n\tcl := strings.TrimSpace(header.get(\"Content-Length\"))\n\tif cl != \"\" {\n\t\tn, err := parseContentLength(cl)\n\t\tif err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t\treturn n, nil\n\t} else {\n\t\theader.Del(\"Content-Length\")\n\t}\n\n\tif !isResponse && requestMethod == \"GET\" {\n\t\t// RFC 2616 doesn't explicitly permit nor forbid an\n\t\t// entity-body on a GET request so we permit one if\n\t\t// declared, but we default to 0 here (not -1 below)\n\t\t// if there's no mention of a body.\n\t\treturn 0, nil\n\t}\n\n\t// Body-EOF logic based on other methods (like closing, or chunked coding)\n\treturn -1, nil\n}\n\n// Determine whether to hang up after sending a request and body, or\n// receiving a response and body\n// 'header' is the request headers\nfunc shouldClose(major, minor int, header Header, removeCloseHeader bool) bool {\n\tif major < 1 {\n\t\treturn true\n\t} else if major == 1 && minor == 0 {\n\t\tvv := header[\"Connection\"]\n\t\tif headerValuesContainsToken(vv, \"close\") || !headerValuesContainsToken(vv, \"keep-alive\") {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t} else {\n\t\tif headerValuesContainsToken(header[\"Connection\"], \"close\") {\n\t\t\tif removeCloseHeader {\n\t\t\t\theader.Del(\"Connection\")\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Parse the trailer header\nfunc fixTrailer(header Header, te []string) (Header, error) {\n\traw := header.get(\"Trailer\")\n\tif raw == \"\" {\n\t\treturn nil, nil\n\t}\n\n\theader.Del(\"Trailer\")\n\ttrailer := make(Header)\n\tkeys := strings.Split(raw, \",\")\n\tfor _, key := range keys {\n\t\tkey = CanonicalHeaderKey(strings.TrimSpace(key))\n\t\tswitch key {\n\t\tcase \"Transfer-Encoding\", \"Trailer\", \"Content-Length\":\n\t\t\treturn nil, &badStringError{\"bad trailer key\", key}\n\t\t}\n\t\ttrailer[key] = nil\n\t}\n\tif len(trailer) == 0 {\n\t\treturn nil, nil\n\t}\n\tif !chunked(te) {\n\t\t// Trailer and no chunking\n\t\treturn nil, ErrUnexpectedTrailer\n\t}\n\treturn trailer, nil\n}\n\n// body turns a Reader into a ReadCloser.\n// Close ensures that the body has been fully read\n// and then reads the trailer if necessary.\ntype body struct {\n\tsrc          io.Reader\n\thdr          interface{}   // non-nil (Response or Request) value means read trailer\n\tr            *bufio.Reader // underlying wire-format reader for the trailer\n\tclosing      bool          // is the connection to be closed after reading body?\n\tdoEarlyClose bool          // whether Close should stop early\n\n\tmu         sync.Mutex // guards closed, and calls to Read and Close\n\tsawEOF     bool\n\tclosed     bool\n\tearlyClose bool // Close called and we didn't read to the end of src\n}\n\n// ErrBodyReadAfterClose is returned when reading a Request or Response\n// Body after the body has been closed. This typically happens when the body is\n// read after an HTTP Handler calls WriteHeader or Write on its\n// ResponseWriter.\nvar ErrBodyReadAfterClose = errors.New(\"http: invalid Read on closed Body\")\n\nfunc (b *body) Read(p []byte) (n int, err error) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tif b.closed {\n\t\treturn 0, ErrBodyReadAfterClose\n\t}\n\treturn b.readLocked(p)\n}\n\n// Must hold b.mu.\nfunc (b *body) readLocked(p []byte) (n int, err error) {\n\tif b.sawEOF {\n\t\treturn 0, io.EOF\n\t}\n\tn, err = b.src.Read(p)\n\n\tif err == io.EOF {\n\t\tb.sawEOF = true\n\t\t// Chunked case. Read the trailer.\n\t\tif b.hdr != nil {\n\t\t\tif e := b.readTrailer(); e != nil {\n\t\t\t\terr = e\n\t\t\t}\n\t\t\tb.hdr = nil\n\t\t} else {\n\t\t\t// If the server declared the Content-Length, our body is a LimitedReader\n\t\t\t// and we need to check whether this EOF arrived early.\n\t\t\tif lr, ok := b.src.(*io.LimitedReader); ok && lr.N > 0 {\n\t\t\t\terr = io.ErrUnexpectedEOF\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we can return an EOF here along with the read data, do\n\t// so. This is optional per the io.Reader contract, but doing\n\t// so helps the HTTP transport code recycle its connection\n\t// earlier (since it will see this EOF itself), even if the\n\t// client doesn't do future reads or Close.\n\tif err == nil && n > 0 {\n\t\tif lr, ok := b.src.(*io.LimitedReader); ok && lr.N == 0 {\n\t\t\terr = io.EOF\n\t\t\tb.sawEOF = true\n\t\t}\n\t}\n\n\treturn n, err\n}\n\nvar (\n\tsingleCRLF = []byte(\"\\r\\n\")\n\tdoubleCRLF = []byte(\"\\r\\n\\r\\n\")\n)\n\nfunc seeUpcomingDoubleCRLF(r *bufio.Reader) bool {\n\tfor peekSize := 4; ; peekSize++ {\n\t\t// This loop stops when Peek returns an error,\n\t\t// which it does when r's buffer has been filled.\n\t\tbuf, err := r.Peek(peekSize)\n\t\tif bytes.HasSuffix(buf, doubleCRLF) {\n\t\t\treturn true\n\t\t}\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn false\n}\n\nvar errTrailerEOF = errors.New(\"http: unexpected EOF reading trailer\")\n\nfunc (b *body) readTrailer() error {\n\t// The common case, since nobody uses trailers.\n\tbuf, err := b.r.Peek(2)\n\tif bytes.Equal(buf, singleCRLF) {\n\t\tb.r.Discard(2)\n\t\treturn nil\n\t}\n\tif len(buf) < 2 {\n\t\treturn errTrailerEOF\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Make sure there's a header terminator coming up, to prevent\n\t// a DoS with an unbounded size Trailer.  It's not easy to\n\t// slip in a LimitReader here, as textproto.NewReader requires\n\t// a concrete *bufio.Reader.  Also, we can't get all the way\n\t// back up to our conn's LimitedReader that *might* be backing\n\t// this bufio.Reader.  Instead, a hack: we iteratively Peek up\n\t// to the bufio.Reader's max size, looking for a double CRLF.\n\t// This limits the trailer to the underlying buffer size, typically 4kB.\n\tif !seeUpcomingDoubleCRLF(b.r) {\n\t\treturn errors.New(\"http: suspiciously long trailer after chunked body\")\n\t}\n\n\thdr, err := textproto.NewReader(b.r).ReadMIMEHeader()\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn errTrailerEOF\n\t\t}\n\t\treturn err\n\t}\n\tswitch rr := b.hdr.(type) {\n\tcase *Request:\n\t\tmergeSetHeader(&rr.Trailer, Header(hdr))\n\tcase *Response:\n\t\tmergeSetHeader(&rr.Trailer, Header(hdr))\n\t}\n\treturn nil\n}\n\nfunc mergeSetHeader(dst *Header, src Header) {\n\tif *dst == nil {\n\t\t*dst = src\n\t\treturn\n\t}\n\tfor k, vv := range src {\n\t\t(*dst)[k] = vv\n\t}\n}\n\nfunc (b *body) Close() error {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tif b.closed {\n\t\treturn nil\n\t}\n\tvar err error\n\tswitch {\n\tcase b.sawEOF:\n\t\t// Already saw EOF, so no need going to look for it.\n\tcase b.hdr == nil && b.closing:\n\t\t// no trailer and closing the connection next.\n\t\t// no point in reading to EOF.\n\tcase b.doEarlyClose:\n\t\t// Read up to maxPostHandlerReadBytes bytes of the body, looking for\n\t\t// for EOF (and trailers), so we can re-use this connection.\n\t\tif lr, ok := b.src.(*io.LimitedReader); ok && lr.N > maxPostHandlerReadBytes {\n\t\t\t// There was a declared Content-Length, and we have more bytes remaining\n\t\t\t// than our maxPostHandlerReadBytes tolerance. So, give up.\n\t\t\tb.earlyClose = true\n\t\t} else {\n\t\t\tvar n int64\n\t\t\t// Consume the body, or, which will also lead to us reading\n\t\t\t// the trailer headers after the body, if present.\n\t\t\tn, err = io.CopyN(ioutil.Discard, bodyLocked{b}, maxPostHandlerReadBytes)\n\t\t\tif err == io.EOF {\n\t\t\t\terr = nil\n\t\t\t}\n\t\t\tif n == maxPostHandlerReadBytes {\n\t\t\t\tb.earlyClose = true\n\t\t\t}\n\t\t}\n\tdefault:\n\t\t// Fully consume the body, which will also lead to us reading\n\t\t// the trailer headers after the body, if present.\n\t\t_, err = io.Copy(ioutil.Discard, bodyLocked{b})\n\t}\n\tb.closed = true\n\treturn err\n}\n\nfunc (b *body) didEarlyClose() bool {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\treturn b.earlyClose\n}\n\n// bodyLocked is a io.Reader reading from a *body when its mutex is\n// already held.\ntype bodyLocked struct {\n\tb *body\n}\n\nfunc (bl bodyLocked) Read(p []byte) (n int, err error) {\n\tif bl.b.closed {\n\t\treturn 0, ErrBodyReadAfterClose\n\t}\n\treturn bl.b.readLocked(p)\n}\n\n// parseContentLength trims whitespace from s and returns -1 if no value\n// is set, or the value if it's >= 0.\nfunc parseContentLength(cl string) (int64, error) {\n\tcl = strings.TrimSpace(cl)\n\tif cl == \"\" {\n\t\treturn -1, nil\n\t}\n\tn, err := strconv.ParseInt(cl, 10, 64)\n\tif err != nil || n < 0 {\n\t\treturn 0, &badStringError{\"bad Content-Length\", cl}\n\t}\n\treturn n, nil\n\n}\n"], "fixing_code": ["// Copyright 2010 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage http\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype reqTest struct {\n\tRaw     string\n\tReq     *Request\n\tBody    string\n\tTrailer Header\n\tError   string\n}\n\nvar noError = \"\"\nvar noBody = \"\"\nvar noTrailer Header = nil\n\nvar reqTests = []reqTest{\n\t// Baseline test; All Request fields included for template use\n\t{\n\t\t\"GET http://www.techcrunch.com/ HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: www.techcrunch.com\\r\\n\" +\n\t\t\t\"User-Agent: Fake\\r\\n\" +\n\t\t\t\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n\" +\n\t\t\t\"Accept-Language: en-us,en;q=0.5\\r\\n\" +\n\t\t\t\"Accept-Encoding: gzip,deflate\\r\\n\" +\n\t\t\t\"Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\\r\\n\" +\n\t\t\t\"Keep-Alive: 300\\r\\n\" +\n\t\t\t\"Content-Length: 7\\r\\n\" +\n\t\t\t\"Proxy-Connection: keep-alive\\r\\n\\r\\n\" +\n\t\t\t\"abcdef\\n???\",\n\n\t\t&Request{\n\t\t\tMethod: \"GET\",\n\t\t\tURL: &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   \"www.techcrunch.com\",\n\t\t\t\tPath:   \"/\",\n\t\t\t},\n\t\t\tProto:      \"HTTP/1.1\",\n\t\t\tProtoMajor: 1,\n\t\t\tProtoMinor: 1,\n\t\t\tHeader: Header{\n\t\t\t\t\"Accept\":           {\"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\"},\n\t\t\t\t\"Accept-Language\":  {\"en-us,en;q=0.5\"},\n\t\t\t\t\"Accept-Encoding\":  {\"gzip,deflate\"},\n\t\t\t\t\"Accept-Charset\":   {\"ISO-8859-1,utf-8;q=0.7,*;q=0.7\"},\n\t\t\t\t\"Keep-Alive\":       {\"300\"},\n\t\t\t\t\"Proxy-Connection\": {\"keep-alive\"},\n\t\t\t\t\"Content-Length\":   {\"7\"},\n\t\t\t\t\"User-Agent\":       {\"Fake\"},\n\t\t\t},\n\t\t\tClose:         false,\n\t\t\tContentLength: 7,\n\t\t\tHost:          \"www.techcrunch.com\",\n\t\t\tRequestURI:    \"http://www.techcrunch.com/\",\n\t\t},\n\n\t\t\"abcdef\\n\",\n\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// GET request with no body (the normal case)\n\t{\n\t\t\"GET / HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: foo.com\\r\\n\\r\\n\",\n\n\t\t&Request{\n\t\t\tMethod: \"GET\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"/\",\n\t\t\t},\n\t\t\tProto:         \"HTTP/1.1\",\n\t\t\tProtoMajor:    1,\n\t\t\tProtoMinor:    1,\n\t\t\tHeader:        Header{},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tHost:          \"foo.com\",\n\t\t\tRequestURI:    \"/\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// Tests that we don't parse a path that looks like a\n\t// scheme-relative URI as a scheme-relative URI.\n\t{\n\t\t\"GET //user@host/is/actually/a/path/ HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: test\\r\\n\\r\\n\",\n\n\t\t&Request{\n\t\t\tMethod: \"GET\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"//user@host/is/actually/a/path/\",\n\t\t\t},\n\t\t\tProto:         \"HTTP/1.1\",\n\t\t\tProtoMajor:    1,\n\t\t\tProtoMinor:    1,\n\t\t\tHeader:        Header{},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tHost:          \"test\",\n\t\t\tRequestURI:    \"//user@host/is/actually/a/path/\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// Tests a bogus abs_path on the Request-Line (RFC 2616 section 5.1.2)\n\t{\n\t\t\"GET ../../../../etc/passwd HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: test\\r\\n\\r\\n\",\n\t\tnil,\n\t\tnoBody,\n\t\tnoTrailer,\n\t\t\"parse ../../../../etc/passwd: invalid URI for request\",\n\t},\n\n\t// Tests missing URL:\n\t{\n\t\t\"GET  HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: test\\r\\n\\r\\n\",\n\t\tnil,\n\t\tnoBody,\n\t\tnoTrailer,\n\t\t\"parse : empty url\",\n\t},\n\n\t// Tests chunked body with trailer:\n\t{\n\t\t\"POST / HTTP/1.1\\r\\n\" +\n\t\t\t\"Host: foo.com\\r\\n\" +\n\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n\t\t\t\"3\\r\\nfoo\\r\\n\" +\n\t\t\t\"3\\r\\nbar\\r\\n\" +\n\t\t\t\"0\\r\\n\" +\n\t\t\t\"Trailer-Key: Trailer-Value\\r\\n\" +\n\t\t\t\"\\r\\n\",\n\t\t&Request{\n\t\t\tMethod: \"POST\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"/\",\n\t\t\t},\n\t\t\tTransferEncoding: []string{\"chunked\"},\n\t\t\tProto:            \"HTTP/1.1\",\n\t\t\tProtoMajor:       1,\n\t\t\tProtoMinor:       1,\n\t\t\tHeader:           Header{},\n\t\t\tContentLength:    -1,\n\t\t\tHost:             \"foo.com\",\n\t\t\tRequestURI:       \"/\",\n\t\t},\n\n\t\t\"foobar\",\n\t\tHeader{\n\t\t\t\"Trailer-Key\": {\"Trailer-Value\"},\n\t\t},\n\t\tnoError,\n\t},\n\n\t// CONNECT request with domain name:\n\t{\n\t\t\"CONNECT www.google.com:443 HTTP/1.1\\r\\n\\r\\n\",\n\n\t\t&Request{\n\t\t\tMethod: \"CONNECT\",\n\t\t\tURL: &url.URL{\n\t\t\t\tHost: \"www.google.com:443\",\n\t\t\t},\n\t\t\tProto:         \"HTTP/1.1\",\n\t\t\tProtoMajor:    1,\n\t\t\tProtoMinor:    1,\n\t\t\tHeader:        Header{},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tHost:          \"www.google.com:443\",\n\t\t\tRequestURI:    \"www.google.com:443\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// CONNECT request with IP address:\n\t{\n\t\t\"CONNECT 127.0.0.1:6060 HTTP/1.1\\r\\n\\r\\n\",\n\n\t\t&Request{\n\t\t\tMethod: \"CONNECT\",\n\t\t\tURL: &url.URL{\n\t\t\t\tHost: \"127.0.0.1:6060\",\n\t\t\t},\n\t\t\tProto:         \"HTTP/1.1\",\n\t\t\tProtoMajor:    1,\n\t\t\tProtoMinor:    1,\n\t\t\tHeader:        Header{},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tHost:          \"127.0.0.1:6060\",\n\t\t\tRequestURI:    \"127.0.0.1:6060\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// CONNECT request for RPC:\n\t{\n\t\t\"CONNECT /_goRPC_ HTTP/1.1\\r\\n\\r\\n\",\n\n\t\t&Request{\n\t\t\tMethod: \"CONNECT\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"/_goRPC_\",\n\t\t\t},\n\t\t\tProto:         \"HTTP/1.1\",\n\t\t\tProtoMajor:    1,\n\t\t\tProtoMinor:    1,\n\t\t\tHeader:        Header{},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tHost:          \"\",\n\t\t\tRequestURI:    \"/_goRPC_\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// SSDP Notify request. golang.org/issue/3692\n\t{\n\t\t\"NOTIFY * HTTP/1.1\\r\\nServer: foo\\r\\n\\r\\n\",\n\t\t&Request{\n\t\t\tMethod: \"NOTIFY\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"*\",\n\t\t\t},\n\t\t\tProto:      \"HTTP/1.1\",\n\t\t\tProtoMajor: 1,\n\t\t\tProtoMinor: 1,\n\t\t\tHeader: Header{\n\t\t\t\t\"Server\": []string{\"foo\"},\n\t\t\t},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tRequestURI:    \"*\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// OPTIONS request. Similar to golang.org/issue/3692\n\t{\n\t\t\"OPTIONS * HTTP/1.1\\r\\nServer: foo\\r\\n\\r\\n\",\n\t\t&Request{\n\t\t\tMethod: \"OPTIONS\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"*\",\n\t\t\t},\n\t\t\tProto:      \"HTTP/1.1\",\n\t\t\tProtoMajor: 1,\n\t\t\tProtoMinor: 1,\n\t\t\tHeader: Header{\n\t\t\t\t\"Server\": []string{\"foo\"},\n\t\t\t},\n\t\t\tClose:         false,\n\t\t\tContentLength: 0,\n\t\t\tRequestURI:    \"*\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// Connection: close. golang.org/issue/8261\n\t{\n\t\t\"GET / HTTP/1.1\\r\\nHost: issue8261.com\\r\\nConnection: close\\r\\n\\r\\n\",\n\t\t&Request{\n\t\t\tMethod: \"GET\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"/\",\n\t\t\t},\n\t\t\tHeader: Header{\n\t\t\t\t// This wasn't removed from Go 1.0 to\n\t\t\t\t// Go 1.3, so locking it in that we\n\t\t\t\t// keep this:\n\t\t\t\t\"Connection\": []string{\"close\"},\n\t\t\t},\n\t\t\tHost:       \"issue8261.com\",\n\t\t\tProto:      \"HTTP/1.1\",\n\t\t\tProtoMajor: 1,\n\t\t\tProtoMinor: 1,\n\t\t\tClose:      true,\n\t\t\tRequestURI: \"/\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n\n\t// HEAD with Content-Length 0. Make sure this is permitted,\n\t// since I think we used to send it.\n\t{\n\t\t\"HEAD / HTTP/1.1\\r\\nHost: issue8261.com\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\",\n\t\t&Request{\n\t\t\tMethod: \"HEAD\",\n\t\t\tURL: &url.URL{\n\t\t\t\tPath: \"/\",\n\t\t\t},\n\t\t\tHeader: Header{\n\t\t\t\t\"Connection\":     []string{\"close\"},\n\t\t\t\t\"Content-Length\": []string{\"0\"},\n\t\t\t},\n\t\t\tHost:       \"issue8261.com\",\n\t\t\tProto:      \"HTTP/1.1\",\n\t\t\tProtoMajor: 1,\n\t\t\tProtoMinor: 1,\n\t\t\tClose:      true,\n\t\t\tRequestURI: \"/\",\n\t\t},\n\n\t\tnoBody,\n\t\tnoTrailer,\n\t\tnoError,\n\t},\n}\n\nfunc TestReadRequest(t *testing.T) {\n\tfor i := range reqTests {\n\t\ttt := &reqTests[i]\n\t\treq, err := ReadRequest(bufio.NewReader(strings.NewReader(tt.Raw)))\n\t\tif err != nil {\n\t\t\tif err.Error() != tt.Error {\n\t\t\t\tt.Errorf(\"#%d: error %q, want error %q\", i, err.Error(), tt.Error)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\trbody := req.Body\n\t\treq.Body = nil\n\t\ttestName := fmt.Sprintf(\"Test %d (%q)\", i, tt.Raw)\n\t\tdiff(t, testName, req, tt.Req)\n\t\tvar bout bytes.Buffer\n\t\tif rbody != nil {\n\t\t\t_, err := io.Copy(&bout, rbody)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%s: copying body: %v\", testName, err)\n\t\t\t}\n\t\t\trbody.Close()\n\t\t}\n\t\tbody := bout.String()\n\t\tif body != tt.Body {\n\t\t\tt.Errorf(\"%s: Body = %q want %q\", testName, body, tt.Body)\n\t\t}\n\t\tif !reflect.DeepEqual(tt.Trailer, req.Trailer) {\n\t\t\tt.Errorf(\"%s: Trailers differ.\\n got: %v\\nwant: %v\", testName, req.Trailer, tt.Trailer)\n\t\t}\n\t}\n}\n\n// reqBytes treats req as a request (with \\n delimiters) and returns it with \\r\\n delimiters,\n// ending in \\r\\n\\r\\n\nfunc reqBytes(req string) []byte {\n\treturn []byte(strings.Replace(strings.TrimSpace(req), \"\\n\", \"\\r\\n\", -1) + \"\\r\\n\\r\\n\")\n}\n\nvar badRequestTests = []struct {\n\tname string\n\treq  []byte\n}{\n\t{\"bad_connect_host\", reqBytes(\"CONNECT []%20%48%54%54%50%2f%31%2e%31%0a%4d%79%48%65%61%64%65%72%3a%20%31%32%33%0a%0a HTTP/1.0\")},\n\t{\"smuggle_two_contentlen\", reqBytes(`POST / HTTP/1.1\nContent-Length: 3\nContent-Length: 4\n\nabc`)},\n\t{\"smuggle_chunked_and_len\", reqBytes(`POST / HTTP/1.1\nTransfer-Encoding: chunked\nContent-Length: 3\n\nabc`)},\n\t{\"smuggle_content_len_head\", reqBytes(`HEAD / HTTP/1.1\nHost: foo\nContent-Length: 5`)},\n}\n\nfunc TestReadRequest_Bad(t *testing.T) {\n\tfor _, tt := range badRequestTests {\n\t\tgot, err := ReadRequest(bufio.NewReader(bytes.NewReader(tt.req)))\n\t\tif err == nil {\n\t\t\tall, err := ioutil.ReadAll(got.Body)\n\t\t\tt.Errorf(\"%s: got unexpected request = %#v\\n  Body = %q, %v\", tt.name, got, all, err)\n\t\t}\n\t}\n}\n", "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage http\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http/internal\"\n\t\"net/textproto\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// ErrLineTooLong is returned when reading request or response bodies\n// with malformed chunked encoding.\nvar ErrLineTooLong = internal.ErrLineTooLong\n\ntype errorReader struct {\n\terr error\n}\n\nfunc (r errorReader) Read(p []byte) (n int, err error) {\n\treturn 0, r.err\n}\n\n// transferWriter inspects the fields of a user-supplied Request or Response,\n// sanitizes them without changing the user object and provides methods for\n// writing the respective header, body and trailer in wire format.\ntype transferWriter struct {\n\tMethod           string\n\tBody             io.Reader\n\tBodyCloser       io.Closer\n\tResponseToHEAD   bool\n\tContentLength    int64 // -1 means unknown, 0 means exactly none\n\tClose            bool\n\tTransferEncoding []string\n\tTrailer          Header\n\tIsResponse       bool\n}\n\nfunc newTransferWriter(r interface{}) (t *transferWriter, err error) {\n\tt = &transferWriter{}\n\n\t// Extract relevant fields\n\tatLeastHTTP11 := false\n\tswitch rr := r.(type) {\n\tcase *Request:\n\t\tif rr.ContentLength != 0 && rr.Body == nil {\n\t\t\treturn nil, fmt.Errorf(\"http: Request.ContentLength=%d with nil Body\", rr.ContentLength)\n\t\t}\n\t\tt.Method = rr.Method\n\t\tt.Body = rr.Body\n\t\tt.BodyCloser = rr.Body\n\t\tt.ContentLength = rr.ContentLength\n\t\tt.Close = rr.Close\n\t\tt.TransferEncoding = rr.TransferEncoding\n\t\tt.Trailer = rr.Trailer\n\t\tatLeastHTTP11 = rr.ProtoAtLeast(1, 1)\n\t\tif t.Body != nil && len(t.TransferEncoding) == 0 && atLeastHTTP11 {\n\t\t\tif t.ContentLength == 0 {\n\t\t\t\t// Test to see if it's actually zero or just unset.\n\t\t\t\tvar buf [1]byte\n\t\t\t\tn, rerr := io.ReadFull(t.Body, buf[:])\n\t\t\t\tif rerr != nil && rerr != io.EOF {\n\t\t\t\t\tt.ContentLength = -1\n\t\t\t\t\tt.Body = errorReader{rerr}\n\t\t\t\t} else if n == 1 {\n\t\t\t\t\t// Oh, guess there is data in this Body Reader after all.\n\t\t\t\t\t// The ContentLength field just wasn't set.\n\t\t\t\t\t// Stich the Body back together again, re-attaching our\n\t\t\t\t\t// consumed byte.\n\t\t\t\t\tt.ContentLength = -1\n\t\t\t\t\tt.Body = io.MultiReader(bytes.NewReader(buf[:]), t.Body)\n\t\t\t\t} else {\n\t\t\t\t\t// Body is actually empty.\n\t\t\t\t\tt.Body = nil\n\t\t\t\t\tt.BodyCloser = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\tif t.ContentLength < 0 {\n\t\t\t\tt.TransferEncoding = []string{\"chunked\"}\n\t\t\t}\n\t\t}\n\tcase *Response:\n\t\tt.IsResponse = true\n\t\tif rr.Request != nil {\n\t\t\tt.Method = rr.Request.Method\n\t\t}\n\t\tt.Body = rr.Body\n\t\tt.BodyCloser = rr.Body\n\t\tt.ContentLength = rr.ContentLength\n\t\tt.Close = rr.Close\n\t\tt.TransferEncoding = rr.TransferEncoding\n\t\tt.Trailer = rr.Trailer\n\t\tatLeastHTTP11 = rr.ProtoAtLeast(1, 1)\n\t\tt.ResponseToHEAD = noBodyExpected(t.Method)\n\t}\n\n\t// Sanitize Body,ContentLength,TransferEncoding\n\tif t.ResponseToHEAD {\n\t\tt.Body = nil\n\t\tif chunked(t.TransferEncoding) {\n\t\t\tt.ContentLength = -1\n\t\t}\n\t} else {\n\t\tif !atLeastHTTP11 || t.Body == nil {\n\t\t\tt.TransferEncoding = nil\n\t\t}\n\t\tif chunked(t.TransferEncoding) {\n\t\t\tt.ContentLength = -1\n\t\t} else if t.Body == nil { // no chunking, no body\n\t\t\tt.ContentLength = 0\n\t\t}\n\t}\n\n\t// Sanitize Trailer\n\tif !chunked(t.TransferEncoding) {\n\t\tt.Trailer = nil\n\t}\n\n\treturn t, nil\n}\n\nfunc noBodyExpected(requestMethod string) bool {\n\treturn requestMethod == \"HEAD\"\n}\n\nfunc (t *transferWriter) shouldSendContentLength() bool {\n\tif chunked(t.TransferEncoding) {\n\t\treturn false\n\t}\n\tif t.ContentLength > 0 {\n\t\treturn true\n\t}\n\tif t.ContentLength < 0 {\n\t\treturn false\n\t}\n\t// Many servers expect a Content-Length for these methods\n\tif t.Method == \"POST\" || t.Method == \"PUT\" {\n\t\treturn true\n\t}\n\tif t.ContentLength == 0 && isIdentity(t.TransferEncoding) {\n\t\tif t.Method == \"GET\" || t.Method == \"HEAD\" {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (t *transferWriter) WriteHeader(w io.Writer) error {\n\tif t.Close {\n\t\tif _, err := io.WriteString(w, \"Connection: close\\r\\n\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Write Content-Length and/or Transfer-Encoding whose values are a\n\t// function of the sanitized field triple (Body, ContentLength,\n\t// TransferEncoding)\n\tif t.shouldSendContentLength() {\n\t\tif _, err := io.WriteString(w, \"Content-Length: \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := io.WriteString(w, strconv.FormatInt(t.ContentLength, 10)+\"\\r\\n\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if chunked(t.TransferEncoding) {\n\t\tif _, err := io.WriteString(w, \"Transfer-Encoding: chunked\\r\\n\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Write Trailer header\n\tif t.Trailer != nil {\n\t\tkeys := make([]string, 0, len(t.Trailer))\n\t\tfor k := range t.Trailer {\n\t\t\tk = CanonicalHeaderKey(k)\n\t\t\tswitch k {\n\t\t\tcase \"Transfer-Encoding\", \"Trailer\", \"Content-Length\":\n\t\t\t\treturn &badStringError{\"invalid Trailer key\", k}\n\t\t\t}\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\tif len(keys) > 0 {\n\t\t\tsort.Strings(keys)\n\t\t\t// TODO: could do better allocation-wise here, but trailers are rare,\n\t\t\t// so being lazy for now.\n\t\t\tif _, err := io.WriteString(w, \"Trailer: \"+strings.Join(keys, \",\")+\"\\r\\n\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (t *transferWriter) WriteBody(w io.Writer) error {\n\tvar err error\n\tvar ncopy int64\n\n\t// Write body\n\tif t.Body != nil {\n\t\tif chunked(t.TransferEncoding) {\n\t\t\tif bw, ok := w.(*bufio.Writer); ok && !t.IsResponse {\n\t\t\t\tw = &internal.FlushAfterChunkWriter{bw}\n\t\t\t}\n\t\t\tcw := internal.NewChunkedWriter(w)\n\t\t\t_, err = io.Copy(cw, t.Body)\n\t\t\tif err == nil {\n\t\t\t\terr = cw.Close()\n\t\t\t}\n\t\t} else if t.ContentLength == -1 {\n\t\t\tncopy, err = io.Copy(w, t.Body)\n\t\t} else {\n\t\t\tncopy, err = io.Copy(w, io.LimitReader(t.Body, t.ContentLength))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tvar nextra int64\n\t\t\tnextra, err = io.Copy(ioutil.Discard, t.Body)\n\t\t\tncopy += nextra\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = t.BodyCloser.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif !t.ResponseToHEAD && t.ContentLength != -1 && t.ContentLength != ncopy {\n\t\treturn fmt.Errorf(\"http: ContentLength=%d with Body length %d\",\n\t\t\tt.ContentLength, ncopy)\n\t}\n\n\tif chunked(t.TransferEncoding) {\n\t\t// Write Trailer header\n\t\tif t.Trailer != nil {\n\t\t\tif err := t.Trailer.Write(w); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\t// Last chunk, empty trailer\n\t\t_, err = io.WriteString(w, \"\\r\\n\")\n\t}\n\treturn err\n}\n\ntype transferReader struct {\n\t// Input\n\tHeader        Header\n\tStatusCode    int\n\tRequestMethod string\n\tProtoMajor    int\n\tProtoMinor    int\n\t// Output\n\tBody             io.ReadCloser\n\tContentLength    int64\n\tTransferEncoding []string\n\tClose            bool\n\tTrailer          Header\n}\n\n// bodyAllowedForStatus reports whether a given response status code\n// permits a body.  See RFC2616, section 4.4.\nfunc bodyAllowedForStatus(status int) bool {\n\tswitch {\n\tcase status >= 100 && status <= 199:\n\t\treturn false\n\tcase status == 204:\n\t\treturn false\n\tcase status == 304:\n\t\treturn false\n\t}\n\treturn true\n}\n\nvar (\n\tsuppressedHeaders304    = []string{\"Content-Type\", \"Content-Length\", \"Transfer-Encoding\"}\n\tsuppressedHeadersNoBody = []string{\"Content-Length\", \"Transfer-Encoding\"}\n)\n\nfunc suppressedHeaders(status int) []string {\n\tswitch {\n\tcase status == 304:\n\t\t// RFC 2616 section 10.3.5: \"the response MUST NOT include other entity-headers\"\n\t\treturn suppressedHeaders304\n\tcase !bodyAllowedForStatus(status):\n\t\treturn suppressedHeadersNoBody\n\t}\n\treturn nil\n}\n\n// msg is *Request or *Response.\nfunc readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n\tt := &transferReader{RequestMethod: \"GET\"}\n\n\t// Unify input\n\tisResponse := false\n\tswitch rr := msg.(type) {\n\tcase *Response:\n\t\tt.Header = rr.Header\n\t\tt.StatusCode = rr.StatusCode\n\t\tt.ProtoMajor = rr.ProtoMajor\n\t\tt.ProtoMinor = rr.ProtoMinor\n\t\tt.Close = shouldClose(t.ProtoMajor, t.ProtoMinor, t.Header, true)\n\t\tisResponse = true\n\t\tif rr.Request != nil {\n\t\t\tt.RequestMethod = rr.Request.Method\n\t\t}\n\tcase *Request:\n\t\tt.Header = rr.Header\n\t\tt.RequestMethod = rr.Method\n\t\tt.ProtoMajor = rr.ProtoMajor\n\t\tt.ProtoMinor = rr.ProtoMinor\n\t\t// Transfer semantics for Requests are exactly like those for\n\t\t// Responses with status code 200, responding to a GET method\n\t\tt.StatusCode = 200\n\t\tt.Close = rr.Close\n\tdefault:\n\t\tpanic(\"unexpected type\")\n\t}\n\n\t// Default to HTTP/1.1\n\tif t.ProtoMajor == 0 && t.ProtoMinor == 0 {\n\t\tt.ProtoMajor, t.ProtoMinor = 1, 1\n\t}\n\n\t// Transfer encoding, content length\n\tt.TransferEncoding, err = fixTransferEncoding(isResponse, t.RequestMethod, t.Header)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trealLength, err := fixLength(isResponse, t.StatusCode, t.RequestMethod, t.Header, t.TransferEncoding)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif isResponse && t.RequestMethod == \"HEAD\" {\n\t\tif n, err := parseContentLength(t.Header.get(\"Content-Length\")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tt.ContentLength = n\n\t\t}\n\t} else {\n\t\tt.ContentLength = realLength\n\t}\n\n\t// Trailer\n\tt.Trailer, err = fixTrailer(t.Header, t.TransferEncoding)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If there is no Content-Length or chunked Transfer-Encoding on a *Response\n\t// and the status is not 1xx, 204 or 304, then the body is unbounded.\n\t// See RFC2616, section 4.4.\n\tswitch msg.(type) {\n\tcase *Response:\n\t\tif realLength == -1 &&\n\t\t\t!chunked(t.TransferEncoding) &&\n\t\t\tbodyAllowedForStatus(t.StatusCode) {\n\t\t\t// Unbounded body.\n\t\t\tt.Close = true\n\t\t}\n\t}\n\n\t// Prepare body reader.  ContentLength < 0 means chunked encoding\n\t// or close connection when finished, since multipart is not supported yet\n\tswitch {\n\tcase chunked(t.TransferEncoding):\n\t\tif noBodyExpected(t.RequestMethod) {\n\t\t\tt.Body = eofReader\n\t\t} else {\n\t\t\tt.Body = &body{src: internal.NewChunkedReader(r), hdr: msg, r: r, closing: t.Close}\n\t\t}\n\tcase realLength == 0:\n\t\tt.Body = eofReader\n\tcase realLength > 0:\n\t\tt.Body = &body{src: io.LimitReader(r, realLength), closing: t.Close}\n\tdefault:\n\t\t// realLength < 0, i.e. \"Content-Length\" not mentioned in header\n\t\tif t.Close {\n\t\t\t// Close semantics (i.e. HTTP/1.0)\n\t\t\tt.Body = &body{src: r, closing: t.Close}\n\t\t} else {\n\t\t\t// Persistent connection (i.e. HTTP/1.1)\n\t\t\tt.Body = eofReader\n\t\t}\n\t}\n\n\t// Unify output\n\tswitch rr := msg.(type) {\n\tcase *Request:\n\t\trr.Body = t.Body\n\t\trr.ContentLength = t.ContentLength\n\t\trr.TransferEncoding = t.TransferEncoding\n\t\trr.Close = t.Close\n\t\trr.Trailer = t.Trailer\n\tcase *Response:\n\t\trr.Body = t.Body\n\t\trr.ContentLength = t.ContentLength\n\t\trr.TransferEncoding = t.TransferEncoding\n\t\trr.Close = t.Close\n\t\trr.Trailer = t.Trailer\n\t}\n\n\treturn nil\n}\n\n// Checks whether chunked is part of the encodings stack\nfunc chunked(te []string) bool { return len(te) > 0 && te[0] == \"chunked\" }\n\n// Checks whether the encoding is explicitly \"identity\".\nfunc isIdentity(te []string) bool { return len(te) == 1 && te[0] == \"identity\" }\n\n// Sanitize transfer encoding\nfunc fixTransferEncoding(isResponse bool, requestMethod string, header Header) ([]string, error) {\n\traw, present := header[\"Transfer-Encoding\"]\n\tif !present {\n\t\treturn nil, nil\n\t}\n\tisRequest := !isResponse\n\tdelete(header, \"Transfer-Encoding\")\n\n\tencodings := strings.Split(raw[0], \",\")\n\tte := make([]string, 0, len(encodings))\n\t// TODO: Even though we only support \"identity\" and \"chunked\"\n\t// encodings, the loop below is designed with foresight. One\n\t// invariant that must be maintained is that, if present,\n\t// chunked encoding must always come first.\n\tfor _, encoding := range encodings {\n\t\tencoding = strings.ToLower(strings.TrimSpace(encoding))\n\t\t// \"identity\" encoding is not recorded\n\t\tif encoding == \"identity\" {\n\t\t\tbreak\n\t\t}\n\t\tif encoding != \"chunked\" {\n\t\t\treturn nil, &badStringError{\"unsupported transfer encoding\", encoding}\n\t\t}\n\t\tte = te[0 : len(te)+1]\n\t\tte[len(te)-1] = encoding\n\t}\n\tif len(te) > 1 {\n\t\treturn nil, &badStringError{\"too many transfer encodings\", strings.Join(te, \",\")}\n\t}\n\tif len(te) > 0 {\n\t\t// RFC 7230 3.3.2 says \"A sender MUST NOT send a\n\t\t// Content-Length header field in any message that\n\t\t// contains a Transfer-Encoding header field.\"\n\t\tif len(header[\"Content-Length\"]) > 0 {\n\t\t\tif isRequest {\n\t\t\t\treturn nil, errors.New(\"http: invalid Content-Length with Transfer-Encoding\")\n\t\t\t}\n\t\t\tdelete(header, \"Content-Length\")\n\t\t}\n\t\treturn te, nil\n\t}\n\n\treturn nil, nil\n}\n\n// Determine the expected body length, using RFC 2616 Section 4.4. This\n// function is not a method, because ultimately it should be shared by\n// ReadResponse and ReadRequest.\nfunc fixLength(isResponse bool, status int, requestMethod string, header Header, te []string) (int64, error) {\n\tcontentLens := header[\"Content-Length\"]\n\tisRequest := !isResponse\n\t// Logic based on response type or status\n\tif noBodyExpected(requestMethod) {\n\t\t// For HTTP requests, as part of hardening against request\n\t\t// smuggling (RFC 7230), don't allow a Content-Length header for\n\t\t// methods which don't permit bodies. As an exception, allow\n\t\t// exactly one Content-Length header if its value is \"0\".\n\t\tif isRequest && len(contentLens) > 0 && !(len(contentLens) == 1 && contentLens[0] == \"0\") {\n\t\t\treturn 0, fmt.Errorf(\"http: method cannot contain a Content-Length; got %q\", contentLens)\n\t\t}\n\t\treturn 0, nil\n\t}\n\tif status/100 == 1 {\n\t\treturn 0, nil\n\t}\n\tswitch status {\n\tcase 204, 304:\n\t\treturn 0, nil\n\t}\n\n\tif len(contentLens) > 1 {\n\t\t// harden against HTTP request smuggling. See RFC 7230.\n\t\treturn 0, errors.New(\"http: message cannot contain multiple Content-Length headers\")\n\t}\n\n\t// Logic based on Transfer-Encoding\n\tif chunked(te) {\n\t\treturn -1, nil\n\t}\n\n\t// Logic based on Content-Length\n\tvar cl string\n\tif len(contentLens) == 1 {\n\t\tcl = strings.TrimSpace(contentLens[0])\n\t}\n\tif cl != \"\" {\n\t\tn, err := parseContentLength(cl)\n\t\tif err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t\treturn n, nil\n\t} else {\n\t\theader.Del(\"Content-Length\")\n\t}\n\n\tif !isResponse {\n\t\t// RFC 2616 neither explicitly permits nor forbids an\n\t\t// entity-body on a GET request so we permit one if\n\t\t// declared, but we default to 0 here (not -1 below)\n\t\t// if there's no mention of a body.\n\t\t// Likewise, all other request methods are assumed to have\n\t\t// no body if neither Transfer-Encoding chunked nor a\n\t\t// Content-Length are set.\n\t\treturn 0, nil\n\t}\n\n\t// Body-EOF logic based on other methods (like closing, or chunked coding)\n\treturn -1, nil\n}\n\n// Determine whether to hang up after sending a request and body, or\n// receiving a response and body\n// 'header' is the request headers\nfunc shouldClose(major, minor int, header Header, removeCloseHeader bool) bool {\n\tif major < 1 {\n\t\treturn true\n\t} else if major == 1 && minor == 0 {\n\t\tvv := header[\"Connection\"]\n\t\tif headerValuesContainsToken(vv, \"close\") || !headerValuesContainsToken(vv, \"keep-alive\") {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t} else {\n\t\tif headerValuesContainsToken(header[\"Connection\"], \"close\") {\n\t\t\tif removeCloseHeader {\n\t\t\t\theader.Del(\"Connection\")\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Parse the trailer header\nfunc fixTrailer(header Header, te []string) (Header, error) {\n\traw := header.get(\"Trailer\")\n\tif raw == \"\" {\n\t\treturn nil, nil\n\t}\n\n\theader.Del(\"Trailer\")\n\ttrailer := make(Header)\n\tkeys := strings.Split(raw, \",\")\n\tfor _, key := range keys {\n\t\tkey = CanonicalHeaderKey(strings.TrimSpace(key))\n\t\tswitch key {\n\t\tcase \"Transfer-Encoding\", \"Trailer\", \"Content-Length\":\n\t\t\treturn nil, &badStringError{\"bad trailer key\", key}\n\t\t}\n\t\ttrailer[key] = nil\n\t}\n\tif len(trailer) == 0 {\n\t\treturn nil, nil\n\t}\n\tif !chunked(te) {\n\t\t// Trailer and no chunking\n\t\treturn nil, ErrUnexpectedTrailer\n\t}\n\treturn trailer, nil\n}\n\n// body turns a Reader into a ReadCloser.\n// Close ensures that the body has been fully read\n// and then reads the trailer if necessary.\ntype body struct {\n\tsrc          io.Reader\n\thdr          interface{}   // non-nil (Response or Request) value means read trailer\n\tr            *bufio.Reader // underlying wire-format reader for the trailer\n\tclosing      bool          // is the connection to be closed after reading body?\n\tdoEarlyClose bool          // whether Close should stop early\n\n\tmu         sync.Mutex // guards closed, and calls to Read and Close\n\tsawEOF     bool\n\tclosed     bool\n\tearlyClose bool // Close called and we didn't read to the end of src\n}\n\n// ErrBodyReadAfterClose is returned when reading a Request or Response\n// Body after the body has been closed. This typically happens when the body is\n// read after an HTTP Handler calls WriteHeader or Write on its\n// ResponseWriter.\nvar ErrBodyReadAfterClose = errors.New(\"http: invalid Read on closed Body\")\n\nfunc (b *body) Read(p []byte) (n int, err error) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tif b.closed {\n\t\treturn 0, ErrBodyReadAfterClose\n\t}\n\treturn b.readLocked(p)\n}\n\n// Must hold b.mu.\nfunc (b *body) readLocked(p []byte) (n int, err error) {\n\tif b.sawEOF {\n\t\treturn 0, io.EOF\n\t}\n\tn, err = b.src.Read(p)\n\n\tif err == io.EOF {\n\t\tb.sawEOF = true\n\t\t// Chunked case. Read the trailer.\n\t\tif b.hdr != nil {\n\t\t\tif e := b.readTrailer(); e != nil {\n\t\t\t\terr = e\n\t\t\t}\n\t\t\tb.hdr = nil\n\t\t} else {\n\t\t\t// If the server declared the Content-Length, our body is a LimitedReader\n\t\t\t// and we need to check whether this EOF arrived early.\n\t\t\tif lr, ok := b.src.(*io.LimitedReader); ok && lr.N > 0 {\n\t\t\t\terr = io.ErrUnexpectedEOF\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we can return an EOF here along with the read data, do\n\t// so. This is optional per the io.Reader contract, but doing\n\t// so helps the HTTP transport code recycle its connection\n\t// earlier (since it will see this EOF itself), even if the\n\t// client doesn't do future reads or Close.\n\tif err == nil && n > 0 {\n\t\tif lr, ok := b.src.(*io.LimitedReader); ok && lr.N == 0 {\n\t\t\terr = io.EOF\n\t\t\tb.sawEOF = true\n\t\t}\n\t}\n\n\treturn n, err\n}\n\nvar (\n\tsingleCRLF = []byte(\"\\r\\n\")\n\tdoubleCRLF = []byte(\"\\r\\n\\r\\n\")\n)\n\nfunc seeUpcomingDoubleCRLF(r *bufio.Reader) bool {\n\tfor peekSize := 4; ; peekSize++ {\n\t\t// This loop stops when Peek returns an error,\n\t\t// which it does when r's buffer has been filled.\n\t\tbuf, err := r.Peek(peekSize)\n\t\tif bytes.HasSuffix(buf, doubleCRLF) {\n\t\t\treturn true\n\t\t}\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn false\n}\n\nvar errTrailerEOF = errors.New(\"http: unexpected EOF reading trailer\")\n\nfunc (b *body) readTrailer() error {\n\t// The common case, since nobody uses trailers.\n\tbuf, err := b.r.Peek(2)\n\tif bytes.Equal(buf, singleCRLF) {\n\t\tb.r.Discard(2)\n\t\treturn nil\n\t}\n\tif len(buf) < 2 {\n\t\treturn errTrailerEOF\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Make sure there's a header terminator coming up, to prevent\n\t// a DoS with an unbounded size Trailer.  It's not easy to\n\t// slip in a LimitReader here, as textproto.NewReader requires\n\t// a concrete *bufio.Reader.  Also, we can't get all the way\n\t// back up to our conn's LimitedReader that *might* be backing\n\t// this bufio.Reader.  Instead, a hack: we iteratively Peek up\n\t// to the bufio.Reader's max size, looking for a double CRLF.\n\t// This limits the trailer to the underlying buffer size, typically 4kB.\n\tif !seeUpcomingDoubleCRLF(b.r) {\n\t\treturn errors.New(\"http: suspiciously long trailer after chunked body\")\n\t}\n\n\thdr, err := textproto.NewReader(b.r).ReadMIMEHeader()\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn errTrailerEOF\n\t\t}\n\t\treturn err\n\t}\n\tswitch rr := b.hdr.(type) {\n\tcase *Request:\n\t\tmergeSetHeader(&rr.Trailer, Header(hdr))\n\tcase *Response:\n\t\tmergeSetHeader(&rr.Trailer, Header(hdr))\n\t}\n\treturn nil\n}\n\nfunc mergeSetHeader(dst *Header, src Header) {\n\tif *dst == nil {\n\t\t*dst = src\n\t\treturn\n\t}\n\tfor k, vv := range src {\n\t\t(*dst)[k] = vv\n\t}\n}\n\nfunc (b *body) Close() error {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tif b.closed {\n\t\treturn nil\n\t}\n\tvar err error\n\tswitch {\n\tcase b.sawEOF:\n\t\t// Already saw EOF, so no need going to look for it.\n\tcase b.hdr == nil && b.closing:\n\t\t// no trailer and closing the connection next.\n\t\t// no point in reading to EOF.\n\tcase b.doEarlyClose:\n\t\t// Read up to maxPostHandlerReadBytes bytes of the body, looking for\n\t\t// for EOF (and trailers), so we can re-use this connection.\n\t\tif lr, ok := b.src.(*io.LimitedReader); ok && lr.N > maxPostHandlerReadBytes {\n\t\t\t// There was a declared Content-Length, and we have more bytes remaining\n\t\t\t// than our maxPostHandlerReadBytes tolerance. So, give up.\n\t\t\tb.earlyClose = true\n\t\t} else {\n\t\t\tvar n int64\n\t\t\t// Consume the body, or, which will also lead to us reading\n\t\t\t// the trailer headers after the body, if present.\n\t\t\tn, err = io.CopyN(ioutil.Discard, bodyLocked{b}, maxPostHandlerReadBytes)\n\t\t\tif err == io.EOF {\n\t\t\t\terr = nil\n\t\t\t}\n\t\t\tif n == maxPostHandlerReadBytes {\n\t\t\t\tb.earlyClose = true\n\t\t\t}\n\t\t}\n\tdefault:\n\t\t// Fully consume the body, which will also lead to us reading\n\t\t// the trailer headers after the body, if present.\n\t\t_, err = io.Copy(ioutil.Discard, bodyLocked{b})\n\t}\n\tb.closed = true\n\treturn err\n}\n\nfunc (b *body) didEarlyClose() bool {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\treturn b.earlyClose\n}\n\n// bodyLocked is a io.Reader reading from a *body when its mutex is\n// already held.\ntype bodyLocked struct {\n\tb *body\n}\n\nfunc (bl bodyLocked) Read(p []byte) (n int, err error) {\n\tif bl.b.closed {\n\t\treturn 0, ErrBodyReadAfterClose\n\t}\n\treturn bl.b.readLocked(p)\n}\n\n// parseContentLength trims whitespace from s and returns -1 if no value\n// is set, or the value if it's >= 0.\nfunc parseContentLength(cl string) (int64, error) {\n\tcl = strings.TrimSpace(cl)\n\tif cl == \"\" {\n\t\treturn -1, nil\n\t}\n\tn, err := strconv.ParseInt(cl, 10, 64)\n\tif err != nil || n < 0 {\n\t\treturn 0, &badStringError{\"bad Content-Length\", cl}\n\t}\n\treturn n, nil\n\n}\n"], "filenames": ["src/net/http/readrequest_test.go", "src/net/http/transfer.go"], "buggy_code_start_loc": [11, 150], "buggy_code_end_loc": [365, 502], "fixing_code_start_loc": [12, 151], "fixing_code_end_loc": [420, 531], "type": "CWE-444", "message": "The net/http library in net/http/transfer.go in Go before 1.4.3 does not properly parse HTTP headers, which allows remote attackers to conduct HTTP request smuggling attacks via a request that contains Content-Length and Transfer-Encoding header fields.", "other": {"cve": {"id": "CVE-2015-5741", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-08T19:15:10.770", "lastModified": "2021-08-04T17:15:17.903", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The net/http library in net/http/transfer.go in Go before 1.4.3 does not properly parse HTTP headers, which allows remote attackers to conduct HTTP request smuggling attacks via a request that contains Content-Length and Transfer-Encoding header fields."}, {"lang": "es", "value": "La biblioteca net/http en el archivo net/http/transfer.go en Go versiones anteriores a 1.4.3, no analiza apropiadamente los encabezados HTTP, lo que permite a atacantes remotos llevar a cabo ataques de tr\u00e1fico no autorizado de peticiones HTTP por medio de una petici\u00f3n que contiene campos de encabezado Content-Length y Transfer-Encoding ."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:golang:go:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.3", "matchCriteriaId": "9B3D3A67-DE5C-482B-95F5-1C3B06B999B0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "9DAA72A4-AC7D-4544-89D4-5B07961D5A95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:8:*:*:*:*:*:*:*", "matchCriteriaId": "E8B8C725-34CF-4340-BE7B-37E58CF706D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/167997.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/168029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://seclists.org/oss-sec/2015/q3/237", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/oss-sec/2015/q3/292", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/oss-sec/2015/q3/294", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1250352", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/golang/go/commit/300d9a21583e7cf0149a778a0611e76ff7c6680f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/golang/go/commit/300d9a21583e7cf0149a778a0611e76ff7c6680f"}}