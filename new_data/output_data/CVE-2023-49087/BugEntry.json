{"buggy_code": ["<?php\n\ndeclare(strict_types=1);\n\nnamespace SimpleSAML\\XMLSecurity\\XML;\n\nuse DOMElement;\nuse SimpleSAML\\Assert\\Assert;\nuse SimpleSAML\\XML\\DOMDocumentFactory;\nuse SimpleSAML\\XML\\Exception\\TooManyElementsException;\nuse SimpleSAML\\XMLSecurity\\Alg\\Signature\\SignatureAlgorithmFactory;\nuse SimpleSAML\\XMLSecurity\\Alg\\Signature\\SignatureAlgorithmInterface;\nuse SimpleSAML\\XMLSecurity\\Constants as C;\nuse SimpleSAML\\XMLSecurity\\CryptoEncoding\\PEM;\nuse SimpleSAML\\XMLSecurity\\Exception\\InvalidArgumentException;\nuse SimpleSAML\\XMLSecurity\\Exception\\NoSignatureFoundException;\nuse SimpleSAML\\XMLSecurity\\Exception\\ReferenceValidationFailedException;\nuse SimpleSAML\\XMLSecurity\\Exception\\RuntimeException;\nuse SimpleSAML\\XMLSecurity\\Exception\\SignatureVerificationFailedException;\nuse SimpleSAML\\XMLSecurity\\Key\\KeyInterface;\nuse SimpleSAML\\XMLSecurity\\Key;\nuse SimpleSAML\\XMLSecurity\\Utils\\Security;\nuse SimpleSAML\\XMLSecurity\\Utils\\XML;\nuse SimpleSAML\\XMLSecurity\\Utils\\XPath;\nuse SimpleSAML\\XMLSecurity\\XML\\ds\\Reference;\nuse SimpleSAML\\XMLSecurity\\XML\\ds\\Signature;\nuse SimpleSAML\\XMLSecurity\\XML\\ds\\X509Certificate;\nuse SimpleSAML\\XMLSecurity\\XML\\ds\\X509Data;\n\nuse function array_pop;\nuse function base64_decode;\nuse function in_array;\n\n/**\n * Helper trait for processing signed elements.\n *\n * @package simplesamlphp/xml-security\n */\ntrait SignedElementTrait\n{\n    use CanonicalizableElementTrait;\n\n    /**\n     * The signature of this element.\n     *\n     * @var \\SimpleSAML\\XMLSecurity\\XML\\ds\\Signature|null $signature\n     */\n    protected ?Signature $signature = null;\n\n    /**\n     * The key that successfully verifies the signature in this object.\n     *\n     * @var \\SimpleSAML\\XMLSecurity\\Key\\KeyInterface|null\n     */\n    private ?KeyInterface $validatingKey = null;\n\n\n    /**\n     * Get the signature element of this object.\n     *\n     * @return \\SimpleSAML\\XMLSecurity\\XML\\ds\\Signature\n     */\n    public function getSignature(): ?Signature\n    {\n        return $this->signature;\n    }\n\n\n    /**\n     * Initialize a signed element from XML.\n     *\n     * @param \\SimpleSAML\\XMLSecurity\\XML\\ds\\Signature $signature The ds:Signature object\n     */\n    protected function setSignature(Signature $signature): void\n    {\n        $this->signature = $signature;\n    }\n\n\n    /**\n     * Make sure the given Reference points to the original XML given.\n     */\n    private function validateReferenceUri(Reference $reference, DOMElement $xml): void\n    {\n        if (\n            in_array(\n                $this->signature->getSignedInfo()->getCanonicalizationMethod()->getAlgorithm(),\n                [\n                    C::C14N_INCLUSIVE_WITH_COMMENTS,\n                    C::C14N_EXCLUSIVE_WITH_COMMENTS,\n                ],\n            )\n            && !$reference->isXPointer()\n        ) { // canonicalization with comments used, but reference wasn't an xpointer!\n            throw new ReferenceValidationFailedException('Invalid reference for canonicalization algorithm.');\n        }\n\n        $id = $this->getId();\n        $uri = $reference->getURI();\n\n        if (empty($uri) || $uri === '#xpointer(/)') { // same-document reference\n            Assert::true(\n                $xml->isSameNode($xml->ownerDocument->documentElement),\n                'Cannot use document reference when element is not the root of the document.',\n                ReferenceValidationFailedException::class,\n            );\n        } else { // short-name or scheme-based xpointer\n            Assert::notEmpty(\n                $id,\n                'Reference points to an element, but given element does not have an ID.',\n                ReferenceValidationFailedException::class,\n            );\n            Assert::oneOf(\n                $uri,\n                [\n                    '#' . $id,\n                    '#xpointer(id(' . $id . '))',\n                ],\n                'Reference does not point to given element.',\n                ReferenceValidationFailedException::class,\n            );\n        }\n    }\n\n\n    /**\n     * @return \\SimpleSAML\\XMLSecurity\\XML\\SignedElementInterface\n     */\n    private function validateReference(): SignedElementInterface\n    {\n        /** @var \\SimpleSAML\\XMLSecurity\\XML\\ds\\Signature $this->signature */\n        $signedInfo = $this->signature->getSignedInfo();\n        $references = $signedInfo->getReferences();\n        Assert::count(\n            $references,\n            1,\n            'Exactly one reference expected in signature.',\n            TooManyElementsException::class,\n        );\n        $reference = array_pop($references);\n\n        $xml = $this->getOriginalXML();\n        $this->validateReferenceUri($reference, $xml);\n\n        $xp = XPath::getXPath($xml->ownerDocument);\n        $sigNode = XPath::xpQuery($xml, 'child::ds:Signature', $xp);\n        Assert::minCount($sigNode, 1, NoSignatureFoundException::class);\n        Assert::maxCount($sigNode, 1, 'More than one signature found in object.', TooManyElementsException::class);\n        $xml->removeChild($sigNode[0]);\n\n        $data = XML::processTransforms($reference->getTransforms(), $xml);\n        $digest = Security::hash($reference->getDigestMethod()->getAlgorithm(), $data, false);\n\n        if (Security::compareStrings($digest, base64_decode($reference->getDigestValue()->getRawContent())) !== true) {\n            throw new SignatureVerificationFailedException('Failed to verify signature.');\n        }\n\n        $verifiedXml = DOMDocumentFactory::fromString($data);\n        return static::fromXML($verifiedXml->documentElement);\n    }\n\n\n    /**\n     * Verify this element against a public key.\n     *\n     * true is returned on success, false is returned if we don't have any\n     * signature we can verify. An exception is thrown if the signature\n     * validation fails.\n     *\n     * @param \\SimpleSAML\\XMLSecurity\\Alg\\Signature\\SignatureAlgorithmInterface|null $verifier The verifier to use to\n     * verify the signature. If null, attempt to verify it with the KeyInfo information in the signature.\n     *\n     * @return \\SimpleSAML\\XMLSecurity\\XML\\SignedElementInterface The Signed element if it was verified.\n     */\n    private function verifyInternal(SignatureAlgorithmInterface $verifier): SignedElementInterface\n    {\n        /** @var \\SimpleSAML\\XMLSecurity\\XML\\ds\\Signature $this->signature */\n        $signedInfo = $this->signature->getSignedInfo();\n        $c14nAlg = $signedInfo->getCanonicalizationMethod()->getAlgorithm();\n        $c14nSignedInfo = $signedInfo->canonicalize($c14nAlg);\n        $ref = $this->validateReference();\n\n        if (\n            $verifier?->verify(\n                $c14nSignedInfo, // the canonicalized ds:SignedInfo element (plaintext)\n                base64_decode($this->signature->getSignatureValue()->getRawContent()), // the actual signature\n            )\n        ) {\n            /*\n             * validateReference() returns an object of the same class using this trait. This means the validatingKey\n             * property is available, and we can set it on the newly created object because we are in the same class,\n             * even thought the property itself is private.\n             */\n            /** @psalm-suppress NoInterfaceProperties */\n            $ref->validatingKey = $verifier->getKey();\n            return $ref;\n        }\n        throw new SignatureVerificationFailedException('Failed to verify signature.');\n    }\n\n\n    /**\n     * Retrieve certificates that sign this element.\n     *\n     * @return \\SimpleSAML\\XMLSecurity\\Key\\KeyInterface|null The key that successfully verified this signature.\n     */\n    public function getVerifyingKey(): ?KeyInterface\n    {\n        return $this->validatingKey;\n    }\n\n\n    /**\n     * Whether this object is signed or not.\n     *\n     * @return bool\n     */\n    public function isSigned(): bool\n    {\n        return $this->signature !== null;\n    }\n\n\n    /**\n     * Verify the signature in this object.\n     *\n     * If no signature is present, false is returned. If a signature is present,\n     * but cannot be verified, an exception will be thrown.\n     *\n     * @param \\SimpleSAML\\XMLSecurity\\Alg\\Signature\\SignatureAlgorithmInterface|null $verifier The verifier to use to\n     * verify the signature. If null, attempt to verify it with the KeyInfo information in the signature.\n     * @return \\SimpleSAML\\XMLSecurity\\XML\\SignedElementInterface The object processed again from its canonicalised\n     * representation verified by the signature.\n     * @throws \\SimpleSAML\\XMLSecurity\\Exception\\NoSignatureFoundException if the object is not signed.\n     * @throws \\SimpleSAML\\XMLSecurity\\Exception\\InvalidArgumentException if no key is passed and there is no KeyInfo\n     * in the signature.\n     * @throws \\SimpleSAML\\XMLSecurity\\Exception\\RuntimeException if the signature fails to verify.\n     */\n    public function verify(SignatureAlgorithmInterface $verifier = null): SignedElementInterface\n    {\n        if (!$this->isSigned()) {\n            throw new NoSignatureFoundException();\n        }\n\n        $keyInfo = $this->signature?->getKeyInfo();\n        $algId = $this->signature->getSignedInfo()->getSignatureMethod()->getAlgorithm();\n        if ($verifier === null && $keyInfo === null) {\n            throw new InvalidArgumentException('No key or KeyInfo available for signature verification.');\n        }\n\n        if ($verifier !== null) {\n            // verify using given key\n            // TODO: make this part of the condition, so that we support using this verifier to decrypt an encrypted key\n            Assert::eq(\n                $verifier->getAlgorithmId(),\n                $algId,\n                'Algorithm provided in key does not match algorithm used in signature.',\n            );\n\n            return $this->verifyInternal($verifier);\n        }\n\n        $factory = new SignatureAlgorithmFactory();\n        foreach ($keyInfo->getInfo() as $info) {\n            if (!$info instanceof X509Data) {\n                continue;\n            }\n\n            foreach ($info->getData() as $data) {\n                if (!$data instanceof X509Certificate) {\n                    // not supported\n                    continue;\n                }\n\n                // build a valid PEM for the certificate\n                $cert = sprintf(\n                    \"-----BEGIN CERTIFICATE-----\\n%s\\n-----END CERTIFICATE-----\",\n                    $data->getRawContent()\n                );\n\n                $cert = new Key\\X509Certificate(PEM::fromString($cert));\n                $verifier = $factory->getAlgorithm($algId, $cert->getPublicKey());\n\n                try {\n                    return $this->verifyInternal($verifier);\n                } catch (RuntimeException) {\n                    // failed to verify with this certificate, try with other, if any\n                }\n            }\n        }\n        throw new SignatureVerificationFailedException('Failed to verify signature.');\n    }\n\n\n    /**\n     * @return string|null\n     */\n    abstract public function getId(): ?string;\n\n\n    /**\n     * Get the list of algorithms that are blacklisted for any signing operation.\n     *\n     * @return string[]|null An array with all algorithm identifiers that are blacklisted, or null if we want to use the\n     * defaults.\n     */\n    abstract public function getBlacklistedAlgorithms(): ?array;\n}\n"], "fixing_code": ["<?php\n\ndeclare(strict_types=1);\n\nnamespace SimpleSAML\\XMLSecurity\\XML;\n\nuse DOMElement;\nuse SimpleSAML\\Assert\\Assert;\nuse SimpleSAML\\XML\\DOMDocumentFactory;\nuse SimpleSAML\\XML\\Exception\\TooManyElementsException;\nuse SimpleSAML\\XMLSecurity\\Alg\\Signature\\SignatureAlgorithmFactory;\nuse SimpleSAML\\XMLSecurity\\Alg\\Signature\\SignatureAlgorithmInterface;\nuse SimpleSAML\\XMLSecurity\\Constants as C;\nuse SimpleSAML\\XMLSecurity\\CryptoEncoding\\PEM;\nuse SimpleSAML\\XMLSecurity\\Exception\\InvalidArgumentException;\nuse SimpleSAML\\XMLSecurity\\Exception\\NoSignatureFoundException;\nuse SimpleSAML\\XMLSecurity\\Exception\\ReferenceValidationFailedException;\nuse SimpleSAML\\XMLSecurity\\Exception\\RuntimeException;\nuse SimpleSAML\\XMLSecurity\\Exception\\SignatureVerificationFailedException;\nuse SimpleSAML\\XMLSecurity\\Key\\KeyInterface;\nuse SimpleSAML\\XMLSecurity\\Key;\nuse SimpleSAML\\XMLSecurity\\Utils\\Security;\nuse SimpleSAML\\XMLSecurity\\Utils\\XML;\nuse SimpleSAML\\XMLSecurity\\Utils\\XPath;\nuse SimpleSAML\\XMLSecurity\\XML\\ds\\Reference;\nuse SimpleSAML\\XMLSecurity\\XML\\ds\\Signature;\nuse SimpleSAML\\XMLSecurity\\XML\\ds\\SignedInfo;\nuse SimpleSAML\\XMLSecurity\\XML\\ds\\X509Certificate;\nuse SimpleSAML\\XMLSecurity\\XML\\ds\\X509Data;\n\nuse function array_pop;\nuse function base64_decode;\nuse function in_array;\n\n/**\n * Helper trait for processing signed elements.\n *\n * @package simplesamlphp/xml-security\n */\ntrait SignedElementTrait\n{\n    use CanonicalizableElementTrait;\n\n    /**\n     * The signature of this element.\n     *\n     * @var \\SimpleSAML\\XMLSecurity\\XML\\ds\\Signature|null $signature\n     */\n    protected ?Signature $signature = null;\n\n    /**\n     * The key that successfully verifies the signature in this object.\n     *\n     * @var \\SimpleSAML\\XMLSecurity\\Key\\KeyInterface|null\n     */\n    private ?KeyInterface $validatingKey = null;\n\n\n    /**\n     * Get the signature element of this object.\n     *\n     * @return \\SimpleSAML\\XMLSecurity\\XML\\ds\\Signature\n     */\n    public function getSignature(): ?Signature\n    {\n        return $this->signature;\n    }\n\n\n    /**\n     * Initialize a signed element from XML.\n     *\n     * @param \\SimpleSAML\\XMLSecurity\\XML\\ds\\Signature $signature The ds:Signature object\n     */\n    protected function setSignature(Signature $signature): void\n    {\n        $this->signature = $signature;\n    }\n\n\n    /**\n     * Make sure the given Reference points to the original XML given.\n     */\n    private function validateReferenceUri(Reference $reference, DOMElement $xml): void\n    {\n        if (\n            in_array(\n                $this->signature->getSignedInfo()->getCanonicalizationMethod()->getAlgorithm(),\n                [\n                    C::C14N_INCLUSIVE_WITH_COMMENTS,\n                    C::C14N_EXCLUSIVE_WITH_COMMENTS,\n                ],\n            )\n            && !$reference->isXPointer()\n        ) { // canonicalization with comments used, but reference wasn't an xpointer!\n            throw new ReferenceValidationFailedException('Invalid reference for canonicalization algorithm.');\n        }\n\n        $id = $this->getId();\n        $uri = $reference->getURI();\n\n        if (empty($uri) || $uri === '#xpointer(/)') { // same-document reference\n            Assert::true(\n                $xml->isSameNode($xml->ownerDocument->documentElement),\n                'Cannot use document reference when element is not the root of the document.',\n                ReferenceValidationFailedException::class,\n            );\n        } else { // short-name or scheme-based xpointer\n            Assert::notEmpty(\n                $id,\n                'Reference points to an element, but given element does not have an ID.',\n                ReferenceValidationFailedException::class,\n            );\n            Assert::oneOf(\n                $uri,\n                [\n                    '#' . $id,\n                    '#xpointer(id(' . $id . '))',\n                ],\n                'Reference does not point to given element.',\n                ReferenceValidationFailedException::class,\n            );\n        }\n    }\n\n\n    /**\n     * @param \\SimpleSAML\\XMLSecurity\\XML\\ds\\SignedInfo $signedInfo\n     * @return \\SimpleSAML\\XMLSecurity\\XML\\SignedElementInterface\n     */\n    private function validateReference(SignedInfo $signedInfo): SignedElementInterface\n    {\n        $references = $signedInfo->getReferences();\n        Assert::count(\n            $references,\n            1,\n            'Exactly one reference expected in signature.',\n            TooManyElementsException::class,\n        );\n        $reference = array_pop($references);\n\n        $xml = $this->getOriginalXML();\n        $this->validateReferenceUri($reference, $xml);\n\n        $xp = XPath::getXPath($xml->ownerDocument);\n        $sigNode = XPath::xpQuery($xml, 'child::ds:Signature', $xp);\n        Assert::minCount($sigNode, 1, NoSignatureFoundException::class);\n        Assert::maxCount($sigNode, 1, 'More than one signature found in object.', TooManyElementsException::class);\n        $xml->removeChild($sigNode[0]);\n\n        $data = XML::processTransforms($reference->getTransforms(), $xml);\n        $digest = Security::hash($reference->getDigestMethod()->getAlgorithm(), $data, false);\n\n        if (Security::compareStrings($digest, base64_decode($reference->getDigestValue()->getRawContent())) !== true) {\n            throw new SignatureVerificationFailedException('Failed to verify signature.');\n        }\n\n        $verifiedXml = DOMDocumentFactory::fromString($data);\n        return static::fromXML($verifiedXml->documentElement);\n    }\n\n\n    /**\n     * Verify this element against a public key.\n     *\n     * true is returned on success, false is returned if we don't have any\n     * signature we can verify. An exception is thrown if the signature\n     * validation fails.\n     *\n     * @param \\SimpleSAML\\XMLSecurity\\Alg\\Signature\\SignatureAlgorithmInterface|null $verifier The verifier to use to\n     * verify the signature. If null, attempt to verify it with the KeyInfo information in the signature.\n     *\n     * @return \\SimpleSAML\\XMLSecurity\\XML\\SignedElementInterface The Signed element if it was verified.\n     */\n    private function verifyInternal(SignatureAlgorithmInterface $verifier): SignedElementInterface\n    {\n        /** @var \\SimpleSAML\\XMLSecurity\\XML\\ds\\Signature $this->signature */\n        $signedInfo = $this->signature->getSignedInfo();\n        $c14nAlg = $signedInfo->getCanonicalizationMethod()->getAlgorithm();\n\n        // the canonicalized ds:SignedInfo element (plaintext)\n        $c14nSignedInfo = $signedInfo->canonicalize($c14nAlg);\n        $ref = $this->validateReference(\n            SignedInfo::fromXML(DOMDocumentFactory::fromString($c14nSignedInfo)->documentElement),\n        );\n\n        if (\n            $verifier?->verify(\n                $c14nSignedInfo, // the canonicalized ds:SignedInfo element (plaintext)\n                base64_decode($this->signature->getSignatureValue()->getRawContent()), // the actual signature\n            )\n        ) {\n            /*\n             * validateReference() returns an object of the same class using this trait. This means the validatingKey\n             * property is available, and we can set it on the newly created object because we are in the same class,\n             * even thought the property itself is private.\n             */\n            /** @psalm-suppress NoInterfaceProperties */\n            $ref->validatingKey = $verifier->getKey();\n            return $ref;\n        }\n        throw new SignatureVerificationFailedException('Failed to verify signature.');\n    }\n\n\n    /**\n     * Retrieve certificates that sign this element.\n     *\n     * @return \\SimpleSAML\\XMLSecurity\\Key\\KeyInterface|null The key that successfully verified this signature.\n     */\n    public function getVerifyingKey(): ?KeyInterface\n    {\n        return $this->validatingKey;\n    }\n\n\n    /**\n     * Whether this object is signed or not.\n     *\n     * @return bool\n     */\n    public function isSigned(): bool\n    {\n        return $this->signature !== null;\n    }\n\n\n    /**\n     * Verify the signature in this object.\n     *\n     * If no signature is present, false is returned. If a signature is present,\n     * but cannot be verified, an exception will be thrown.\n     *\n     * @param \\SimpleSAML\\XMLSecurity\\Alg\\Signature\\SignatureAlgorithmInterface|null $verifier The verifier to use to\n     * verify the signature. If null, attempt to verify it with the KeyInfo information in the signature.\n     * @return \\SimpleSAML\\XMLSecurity\\XML\\SignedElementInterface The object processed again from its canonicalised\n     * representation verified by the signature.\n     * @throws \\SimpleSAML\\XMLSecurity\\Exception\\NoSignatureFoundException if the object is not signed.\n     * @throws \\SimpleSAML\\XMLSecurity\\Exception\\InvalidArgumentException if no key is passed and there is no KeyInfo\n     * in the signature.\n     * @throws \\SimpleSAML\\XMLSecurity\\Exception\\RuntimeException if the signature fails to verify.\n     */\n    public function verify(SignatureAlgorithmInterface $verifier = null): SignedElementInterface\n    {\n        if (!$this->isSigned()) {\n            throw new NoSignatureFoundException();\n        }\n\n        $keyInfo = $this->signature?->getKeyInfo();\n        $algId = $this->signature->getSignedInfo()->getSignatureMethod()->getAlgorithm();\n        if ($verifier === null && $keyInfo === null) {\n            throw new InvalidArgumentException('No key or KeyInfo available for signature verification.');\n        }\n\n        if ($verifier !== null) {\n            // verify using given key\n            // TODO: make this part of the condition, so that we support using this verifier to decrypt an encrypted key\n            Assert::eq(\n                $verifier->getAlgorithmId(),\n                $algId,\n                'Algorithm provided in key does not match algorithm used in signature.',\n            );\n\n            return $this->verifyInternal($verifier);\n        }\n\n        $factory = new SignatureAlgorithmFactory();\n        foreach ($keyInfo->getInfo() as $info) {\n            if (!$info instanceof X509Data) {\n                continue;\n            }\n\n            foreach ($info->getData() as $data) {\n                if (!$data instanceof X509Certificate) {\n                    // not supported\n                    continue;\n                }\n\n                // build a valid PEM for the certificate\n                $cert = sprintf(\n                    \"-----BEGIN CERTIFICATE-----\\n%s\\n-----END CERTIFICATE-----\",\n                    $data->getRawContent()\n                );\n\n                $cert = new Key\\X509Certificate(PEM::fromString($cert));\n                $verifier = $factory->getAlgorithm($algId, $cert->getPublicKey());\n\n                try {\n                    return $this->verifyInternal($verifier);\n                } catch (RuntimeException) {\n                    // failed to verify with this certificate, try with other, if any\n                }\n            }\n        }\n        throw new SignatureVerificationFailedException('Failed to verify signature.');\n    }\n\n\n    /**\n     * @return string|null\n     */\n    abstract public function getId(): ?string;\n\n\n    /**\n     * Get the list of algorithms that are blacklisted for any signing operation.\n     *\n     * @return string[]|null An array with all algorithm identifiers that are blacklisted, or null if we want to use the\n     * defaults.\n     */\n    abstract public function getBlacklistedAlgorithms(): ?array;\n}\n"], "filenames": ["src/XML/SignedElementTrait.php"], "buggy_code_start_loc": [26], "buggy_code_end_loc": [182], "fixing_code_start_loc": [27], "fixing_code_end_loc": [186], "type": "CWE-345", "message": "xml-security is a library that implements XML signatures and encryption. Validation of an XML signature requires verification that the hash value of the related XML-document matches a specific DigestValue-value, but also that the cryptographic signature on the SignedInfo-tree (the one that contains the DigestValue) verifies and matches a trusted public key. If an attacker somehow (i.e. by exploiting a bug in PHP's canonicalization function) manages to manipulate the canonicalized version's DigestValue, it would be possible to forge the signature. This issue has been patched in version 1.6.12 and 5.0.0-alpha.13.", "other": {"cve": {"id": "CVE-2023-49087", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-30T06:15:47.173", "lastModified": "2023-12-06T17:49:44.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "xml-security is a library that implements XML signatures and encryption. Validation of an XML signature requires verification that the hash value of the related XML-document matches a specific DigestValue-value, but also that the cryptographic signature on the SignedInfo-tree (the one that contains the DigestValue) verifies and matches a trusted public key. If an attacker somehow (i.e. by exploiting a bug in PHP's canonicalization function) manages to manipulate the canonicalized version's DigestValue, it would be possible to forge the signature. This issue has been patched in version 1.6.12 and 5.0.0-alpha.13."}, {"lang": "es", "value": "xml-security es una librer\u00eda que implementa cifrado y firmas XML. La validaci\u00f3n de una firma XML requiere verificar que el valor hash del documento XML relacionado coincida con un valor DigestValue espec\u00edfico, pero tambi\u00e9n que la firma criptogr\u00e1fica en el \u00e1rbol SignedInfo (el que contiene el DigestValue) verifique y coincida con una clave p\u00fablica confiable. Si un atacante de alguna manera (es decir, explotando un error en la funci\u00f3n de canonicalizaci\u00f3n de PHP) logra manipular el DigestValue de la versi\u00f3n canonicalizada, ser\u00eda posible falsificar la firma. Este problema se solucion\u00f3 en las versiones 1.6.12 y 5.0.0-alpha.13."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-345"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:simplesamlphp:saml2:5.0.0:alpha12:*:*:*:*:*:*", "matchCriteriaId": "96D08664-7238-4C52-B40E-F32E304DE2D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:simplesamlphp:xml-security:1.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "3F1375D1-EBBE-4AD5-8271-457C64C948BD"}]}]}], "references": [{"url": "https://github.com/simplesamlphp/xml-security/commit/f509e3083dd7870cce5880c804b5122317287581", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/simplesamlphp/xml-security/security/advisories/GHSA-ww7x-3gxh-qm6r", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/simplesamlphp/xml-security/commit/f509e3083dd7870cce5880c804b5122317287581"}}