{"buggy_code": ["# frozen_string_literal: true\n\nrequire 'csv'\n\nclass InvitesController < ApplicationController\n\n  requires_login only: [:create, :retrieve, :destroy, :destroy_all_expired, :resend_invite, :resend_all_invites, :upload_csv]\n\n  skip_before_action :check_xhr, except: [:perform_accept_invitation]\n  skip_before_action :preload_json, except: [:show]\n  skip_before_action :redirect_to_login_if_required\n\n  before_action :ensure_invites_allowed, only: [:show, :perform_accept_invitation]\n  before_action :ensure_new_registrations_allowed, only: [:show, :perform_accept_invitation]\n  before_action :ensure_not_logged_in, only: :perform_accept_invitation\n\n  def show\n    expires_now\n\n    RateLimiter.new(nil, \"invites-show-#{request.remote_ip}\", 100, 1.minute).performed!\n\n    invite = Invite.find_by(invite_key: params[:id])\n    if invite.present? && invite.redeemable?\n      if current_user\n        added_to_group = false\n\n        if invite.groups.present?\n          invite_by_guardian = Guardian.new(invite.invited_by)\n          new_group_ids = invite.groups.pluck(:id) - current_user.group_users.pluck(:group_id)\n          new_group_ids.each do |id|\n            if group = Group.find_by(id: id)\n              if invite_by_guardian.can_edit_group?(group)\n                group.add(current_user)\n                added_to_group = true\n              end\n            end\n          end\n        end\n\n        create_topic_invite_notifications(invite, current_user)\n\n        if topic = invite.topics.first\n          new_guardian = Guardian.new(current_user)\n          return redirect_to(topic.url) if new_guardian.can_see?(topic)\n        elsif added_to_group\n          return redirect_to(path(\"/\"))\n        end\n\n        return ensure_not_logged_in\n      end\n\n      email = Email.obfuscate(invite.email)\n\n      # Show email if the user already authenticated their email\n      different_external_email = false\n      if session[:authentication]\n        auth_result = Auth::Result.from_session_data(session[:authentication], user: nil)\n        if invite.email == auth_result.email\n          email = invite.email\n        else\n          different_external_email = true\n        end\n      end\n\n      email_verified_by_link = invite.email_token.present? && params[:t] == invite.email_token\n      if email_verified_by_link\n        email = invite.email\n      end\n\n      hidden_email = email != invite.email\n\n      if hidden_email || invite.email.nil?\n        username = \"\"\n      else\n        username = UserNameSuggester.suggest(invite.email)\n      end\n\n      info = {\n        invited_by: UserNameSerializer.new(invite.invited_by, scope: guardian, root: false),\n        email: email,\n        hidden_email: hidden_email,\n        username: username,\n        is_invite_link: invite.is_invite_link?,\n        email_verified_by_link: email_verified_by_link\n      }\n\n      if different_external_email\n        info[:different_external_email] = true\n      end\n\n      if staged_user = User.where(staged: true).with_email(invite.email).first\n        info[:username] = staged_user.username\n        info[:user_fields] = staged_user.user_fields\n      end\n\n      store_preloaded(\"invite_info\", MultiJson.dump(info))\n\n      secure_session[\"invite-key\"] = invite.invite_key\n\n      render layout: 'application'\n    else\n      flash.now[:error] = if invite.blank?\n        I18n.t('invite.not_found', base_url: Discourse.base_url)\n      elsif invite.redeemed?\n        if invite.is_invite_link?\n          I18n.t('invite.not_found_template_link', site_name: SiteSetting.title, base_url: Discourse.base_url)\n        else\n          I18n.t('invite.not_found_template', site_name: SiteSetting.title, base_url: Discourse.base_url)\n        end\n      elsif invite.expired?\n        I18n.t('invite.expired', base_url: Discourse.base_url)\n      end\n\n      render layout: 'no_ember'\n    end\n  rescue RateLimiter::LimitExceeded => e\n    flash.now[:error] = e.description\n    render layout: 'no_ember'\n  end\n\n  def create\n    if params[:topic_id].present?\n      topic = Topic.find_by(id: params[:topic_id])\n      raise Discourse::InvalidParameters.new(:topic_id) if topic.blank?\n      guardian.ensure_can_invite_to!(topic)\n    end\n\n    if params[:group_ids].present? || params[:group_names].present?\n      groups = Group.lookup_groups(group_ids: params[:group_ids], group_names: params[:group_names])\n    end\n\n    guardian.ensure_can_invite_to_forum!(groups)\n\n    begin\n      invite = Invite.generate(current_user,\n        email: params[:email],\n        domain: params[:domain],\n        skip_email: params[:skip_email],\n        invited_by: current_user,\n        custom_message: params[:custom_message],\n        max_redemptions_allowed: params[:max_redemptions_allowed],\n        topic_id: topic&.id,\n        group_ids: groups&.map(&:id),\n        expires_at: params[:expires_at],\n      )\n\n      if invite.present?\n        render_serialized(invite, InviteSerializer, scope: guardian, root: nil, show_emails: params.has_key?(:email), show_warnings: true)\n      else\n        render json: failed_json, status: 422\n      end\n    rescue Invite::UserExists => e\n      render_json_error(e.message)\n    rescue ActiveRecord::RecordInvalid => e\n      render_json_error(e.record.errors.full_messages.first)\n    end\n  end\n\n  def retrieve\n    params.require(:email)\n\n    invite = Invite.find_by(invited_by: current_user, email: params[:email])\n    raise Discourse::InvalidParameters.new(:email) if invite.blank?\n\n    guardian.ensure_can_invite_to_forum!(nil)\n\n    render_serialized(invite, InviteSerializer, scope: guardian, root: nil, show_emails: params.has_key?(:email), show_warnings: true)\n  end\n\n  def update\n    invite = Invite.find_by(invited_by: current_user, id: params[:id])\n    raise Discourse::InvalidParameters.new(:id) if invite.blank?\n\n    if params[:topic_id].present?\n      topic = Topic.find_by(id: params[:topic_id])\n      raise Discourse::InvalidParameters.new(:topic_id) if topic.blank?\n      guardian.ensure_can_invite_to!(topic)\n    end\n\n    if params[:group_ids].present? || params[:group_names].present?\n      groups = Group.lookup_groups(group_ids: params[:group_ids], group_names: params[:group_names])\n    end\n\n    guardian.ensure_can_invite_to_forum!(groups)\n\n    Invite.transaction do\n      if params.has_key?(:topic_id)\n        invite.topic_invites.destroy_all\n        invite.topic_invites.create!(topic_id: topic.id) if topic.present?\n      end\n\n      if params.has_key?(:group_ids) || params.has_key?(:group_names)\n        invite.invited_groups.destroy_all\n        groups.each { |group| invite.invited_groups.find_or_create_by!(group_id: group.id) } if groups.present?\n      end\n\n      if params.has_key?(:email)\n        old_email = invite.email.presence\n        new_email = params[:email].presence\n\n        if new_email\n          if Invite.where.not(id: invite.id).find_by(email: new_email.downcase, invited_by_id: current_user.id)&.redeemable?\n            return render_json_error(I18n.t(\"invite.invite_exists\", email: new_email), status: 409)\n          end\n        end\n\n        if old_email != new_email\n          invite.emailed_status = if new_email && !params[:skip_email]\n            Invite.emailed_status_types[:pending]\n          else\n            Invite.emailed_status_types[:not_required]\n          end\n        end\n\n        invite.domain = nil if invite.email.present?\n      end\n\n      if params.has_key?(:domain)\n        invite.domain = params[:domain]\n\n        if invite.domain.present?\n          invite.email = nil\n          invite.emailed_status = Invite.emailed_status_types[:not_required]\n        end\n      end\n\n      if params[:send_email]\n        if invite.emailed_status != Invite.emailed_status_types[:pending]\n          begin\n            RateLimiter.new(current_user, \"resend-invite-per-hour\", 10, 1.hour).performed!\n          rescue RateLimiter::LimitExceeded\n            return render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n          end\n        end\n\n        invite.emailed_status = Invite.emailed_status_types[:pending]\n      end\n\n      begin\n        invite.update!(params.permit(:email, :custom_message, :max_redemptions_allowed, :expires_at))\n      rescue ActiveRecord::RecordInvalid => e\n        return render_json_error(e.record.errors.full_messages.first)\n      end\n    end\n\n    if invite.emailed_status == Invite.emailed_status_types[:pending]\n      invite.update_column(:emailed_status, Invite.emailed_status_types[:sending])\n      Jobs.enqueue(:invite_email, invite_id: invite.id, invite_to_topic: params[:invite_to_topic])\n    end\n\n    render_serialized(invite, InviteSerializer, scope: guardian, root: nil, show_emails: params.has_key?(:email), show_warnings: true)\n  end\n\n  def destroy\n    params.require(:id)\n\n    invite = Invite.find_by(invited_by_id: current_user.id, id: params[:id])\n    raise Discourse::InvalidParameters.new(:id) if invite.blank?\n\n    invite.trash!(current_user)\n\n    render json: success_json\n  end\n\n  # For DiscourseConnect SSO, all invite acceptance is done\n  # via the SessionController#sso_login route\n  def perform_accept_invitation\n    params.require(:id)\n    params.permit(:email, :username, :name, :password, :timezone, :email_token, user_custom_fields: {})\n\n    invite = Invite.find_by(invite_key: params[:id])\n\n    if invite.present?\n      begin\n        attrs = {\n          username: params[:username],\n          name: params[:name],\n          password: params[:password],\n          user_custom_fields: params[:user_custom_fields],\n          ip_address: request.remote_ip,\n          session: session\n        }\n\n        if invite.is_invite_link?\n          params.require(:email)\n          attrs[:email] = params[:email]\n        else\n          attrs[:email] = invite.email\n          attrs[:email_token] = params[:email_token] if params[:email_token].present?\n        end\n\n        user = invite.redeem(**attrs)\n      rescue ActiveRecord::RecordInvalid, ActiveRecord::RecordNotSaved, Invite::UserExists => e\n        return render json: failed_json.merge(message: e.message), status: 412\n      end\n\n      if user.blank?\n        return render json: failed_json.merge(message: I18n.t('invite.not_found_json')), status: 404\n      end\n\n      log_on_user(user) if user.active?\n      user.update_timezone_if_missing(params[:timezone])\n      post_process_invite(user)\n      create_topic_invite_notifications(invite, user)\n\n      topic = invite.topics.first\n      response = {}\n\n      if user.present?\n        if user.active?\n          if user.guardian.can_see?(topic)\n            response[:redirect_to] = path(topic.relative_url)\n          else\n            response[:redirect_to] = path(\"/\")\n          end\n        else\n          response[:message] = I18n.t('invite.confirm_email')\n          if user.guardian.can_see?(topic)\n            cookies[:destination_url] = path(topic.relative_url)\n          end\n        end\n      end\n\n      render json: success_json.merge(response)\n    else\n      render json: failed_json.merge(message: I18n.t('invite.not_found_json')), status: 404\n    end\n  end\n\n  def destroy_all_expired\n    guardian.ensure_can_destroy_all_invites!(current_user)\n\n    Invite\n      .where(invited_by: current_user)\n      .where('expires_at < ?', Time.zone.now)\n      .find_each { |invite| invite.trash!(current_user) }\n\n    render json: success_json\n  end\n\n  def resend_invite\n    params.require(:email)\n    RateLimiter.new(current_user, \"resend-invite-per-hour\", 10, 1.hour).performed!\n\n    invite = Invite.find_by(invited_by_id: current_user.id, email: params[:email])\n    raise Discourse::InvalidParameters.new(:email) if invite.blank?\n    invite.resend_invite\n    render json: success_json\n  rescue RateLimiter::LimitExceeded\n    render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n  end\n\n  def resend_all_invites\n    guardian.ensure_can_resend_all_invites!(current_user)\n\n    Invite.pending(current_user)\n      .where('invites.email IS NOT NULL')\n      .find_each { |invite| invite.resend_invite }\n\n    render json: success_json\n  end\n\n  def upload_csv\n    guardian.ensure_can_bulk_invite_to_forum!(current_user)\n\n    hijack do\n      begin\n        file = params[:file] || params[:files].first\n\n        csv_header = nil\n        invites = []\n\n        CSV.foreach(file.tempfile, encoding: \"bom|utf-8\") do |row|\n          # Try to extract a CSV header, if it exists\n          if csv_header.nil?\n            if row[0] == 'email'\n              csv_header = row\n              next\n            else\n              csv_header = [\"email\", \"groups\", \"topic_id\"]\n            end\n          end\n\n          if row[0].present?\n            invites.push(csv_header.zip(row).map.to_h.filter { |k, v| v.present? })\n          end\n\n          break if invites.count >= SiteSetting.max_bulk_invites\n        end\n\n        if invites.present?\n          Jobs.enqueue(:bulk_invite, invites: invites, current_user_id: current_user.id)\n\n          if invites.count >= SiteSetting.max_bulk_invites\n            render json: failed_json.merge(errors: [I18n.t(\"bulk_invite.max_rows\", max_bulk_invites: SiteSetting.max_bulk_invites)]), status: 422\n          else\n            render json: success_json\n          end\n        else\n          render json: failed_json.merge(errors: [I18n.t(\"bulk_invite.error\")]), status: 422\n        end\n      end\n    end\n  end\n\n  private\n\n  def ensure_invites_allowed\n    if (!SiteSetting.enable_local_logins && Discourse.enabled_auth_providers.count == 0 && !SiteSetting.enable_discourse_connect)\n      raise Discourse::NotFound\n    end\n  end\n\n  def ensure_new_registrations_allowed\n    unless SiteSetting.allow_new_registrations\n      flash[:error] = I18n.t('login.new_registrations_disabled')\n      render layout: 'no_ember'\n      false\n    end\n  end\n\n  def ensure_not_logged_in\n    if current_user\n      flash[:error] = I18n.t(\"login.already_logged_in\")\n      render layout: 'no_ember'\n      false\n    end\n  end\n\n  def post_process_invite(user)\n    user.enqueue_welcome_message('welcome_invite') if user.send_welcome_message\n\n    Group.refresh_automatic_groups!(:admins, :moderators, :staff) if user.staff?\n\n    if user.has_password?\n      if !user.active\n        email_token = user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:signup])\n        EmailToken.enqueue_signup_email(email_token)\n      end\n    elsif !SiteSetting.enable_discourse_connect && SiteSetting.enable_local_logins\n      Jobs.enqueue(:invite_password_instructions_email, username: user.username)\n    end\n  end\n\n  def create_topic_invite_notifications(invite, user)\n    invite.topics.each do |topic|\n      if user.guardian.can_see?(topic)\n        last_notification = user.notifications\n          .where(notification_type: Notification.types[:invited_to_topic])\n          .where(topic_id: topic.id)\n          .where(post_number: 1)\n          .where('created_at > ?', 1.hour.ago)\n\n        if !last_notification.exists?\n          topic.create_invite_notification!(\n            user,\n            Notification.types[:invited_to_topic],\n            invite.invited_by.username\n          )\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe InvitesController do\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:user) { Fabricate(:user, trust_level: SiteSetting.min_trust_level_to_allow_invite) }\n\n  context '#show' do\n    fab!(:invite) { Fabricate(:invite) }\n\n    it 'shows the accept invite page' do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).not_to include(invite.email)\n      expect(response.body).to_not include(I18n.t('invite.not_found_template', site_name: SiteSetting.title, base_url: Discourse.base_url))\n\n      expect(response.body).to have_tag('div#data-preloaded') do |element|\n        json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n        invite_info = JSON.parse(json['invite_info'])\n        expect(invite_info['username']).to eq('')\n        expect(invite_info['email']).to eq('i*****g@a***********e.ooo')\n      end\n    end\n\n    it 'shows unobfuscated email if email data is present in authentication data' do\n      ActionDispatch::Request.any_instance.stubs(:session).returns(authentication: { email: invite.email })\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(invite.email)\n      expect(response.body).not_to include('i*****g@a***********e.ooo')\n    end\n\n    it 'shows default user fields' do\n      user_field = Fabricate(:user_field)\n      staged_user = Fabricate(:user, staged: true, email: invite.email)\n      staged_user.set_user_field(user_field.id, 'some value')\n      staged_user.save_custom_fields\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n        invite_info = JSON.parse(json['invite_info'])\n        expect(invite_info['username']).to eq(staged_user.username)\n        expect(invite_info['user_fields'][user_field.id.to_s]).to eq('some value')\n      end\n    end\n\n    it 'includes token validity boolean' do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n        invite_info = JSON.parse(json['invite_info'])\n        expect(invite_info['email_verified_by_link']).to eq(false)\n      end\n\n      get \"/invites/#{invite.invite_key}?t=#{invite.email_token}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n        invite_info = JSON.parse(json['invite_info'])\n        expect(invite_info['email_verified_by_link']).to eq(true)\n      end\n    end\n\n    it 'adds logged in users to invite groups' do\n      group = Fabricate(:group)\n      group.add_owner(invite.invited_by)\n      InvitedGroup.create!(group: group, invite: invite)\n\n      sign_in(user)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response).to redirect_to(\"/\")\n      expect(user.reload.groups).to include(group)\n    end\n\n    it 'redirects logged in users to invite topic if they can see it' do\n      topic = Fabricate(:topic)\n      TopicInvite.create!(topic: topic, invite: invite)\n\n      sign_in(user)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response).to redirect_to(topic.url)\n      expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n    end\n\n    it 'adds logged in user to group and redirects them to invite topic' do\n      group = Fabricate(:group)\n      group.add_owner(invite.invited_by)\n      secured_category = Fabricate(:category)\n      secured_category.permissions = { group.name => :full }\n      secured_category.save!\n      topic = Fabricate(:topic, category: secured_category)\n      TopicInvite.create!(invite: invite, topic: topic)\n      InvitedGroup.create!(invite: invite, group: group)\n\n      sign_in(user)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(user.reload.groups).to include(group)\n      expect(response).to redirect_to(topic.url)\n      expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n    end\n\n    it 'fails for logged in users' do\n      sign_in(Fabricate(:user))\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(I18n.t('login.already_logged_in'))\n    end\n\n    it 'fails if invite does not exist' do\n      get '/invites/missing'\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(I18n.t('invite.not_found', base_url: Discourse.base_url))\n    end\n\n    it 'fails if invite expired' do\n      invite.update(expires_at: 1.day.ago)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(I18n.t('invite.expired', base_url: Discourse.base_url))\n    end\n\n    it 'stores the invite key in the secure session if invite exists' do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      invite_key = read_secure_session['invite-key']\n      expect(invite_key).to eq(invite.invite_key)\n    end\n\n    it 'returns error if invite has already been redeemed' do\n      expect(invite.redeem).not_to eq(nil)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(I18n.t('invite.not_found_template', site_name: SiteSetting.title, base_url: Discourse.base_url))\n\n      invite.update!(email: nil) # convert to email invite\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(I18n.t('invite.not_found_template_link', site_name: SiteSetting.title, base_url: Discourse.base_url))\n    end\n  end\n\n  context '#create' do\n    it 'requires to be logged in' do\n      post '/invites.json', params: { email: 'test@example.com' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user)\n      end\n\n      it 'fails if you cannot invite to the forum' do\n        sign_in(Fabricate(:user))\n\n        post '/invites.json', params: { email: 'test@example.com' }\n        expect(response).to be_forbidden\n      end\n    end\n\n    context 'invite to topic' do\n      fab!(:topic) { Fabricate(:topic) }\n\n      it 'works' do\n        sign_in(user)\n\n        post '/invites.json', params: { email: 'test@example.com', topic_id: topic.id }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.first['args'].first['invite_to_topic']).to be_falsey\n      end\n\n      it 'fails when topic_id is invalid' do\n        sign_in(user)\n\n        post '/invites.json', params: { email: 'test@example.com', topic_id: -9999 }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context 'invite to group' do\n      fab!(:group) { Fabricate(:group) }\n\n      it 'works for admins' do\n        sign_in(admin)\n\n        post '/invites.json', params: { email: 'test@example.com', group_ids: [group.id] }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: 'test@example.com').invited_groups.count).to eq(1)\n      end\n\n      it 'works for group owners' do\n        sign_in(user)\n        group.add_owner(user)\n\n        post '/invites.json', params: { email: 'test@example.com', group_ids: [group.id] }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: 'test@example.com').invited_groups.count).to eq(1)\n      end\n\n      it 'works with multiple groups' do\n        sign_in(admin)\n        group2 = Fabricate(:group)\n\n        post '/invites.json', params: { email: 'test@example.com', group_names: \"#{group.name},#{group2.name}\" }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: 'test@example.com').invited_groups.count).to eq(2)\n      end\n\n      it 'fails for group members' do\n        sign_in(user)\n        group.add(user)\n\n        post '/invites.json', params: { email: 'test@example.com', group_ids: [group.id] }\n        expect(response.status).to eq(403)\n      end\n\n      it 'fails for other users' do\n        sign_in(user)\n\n        post '/invites.json', params: { email: 'test@example.com', group_ids: [group.id] }\n        expect(response.status).to eq(403)\n      end\n\n      it 'fails to invite new user to a group-private topic' do\n        sign_in(user)\n        private_category = Fabricate(:private_category, group: group)\n        group_private_topic = Fabricate(:topic, category: private_category)\n\n        post '/invites.json', params: { email: 'test@example.com', topic_id: group_private_topic.id  }\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'email invite' do\n      it 'creates invite once and updates it on successive calls' do\n        sign_in(user)\n\n        post '/invites.json', params: { email: 'test@example.com' }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n\n        invite = Invite.last\n\n        post '/invites.json', params: { email: 'test@example.com' }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['id']).to eq(invite.id)\n      end\n\n      it 'accept skip_email parameter' do\n        sign_in(user)\n\n        post '/invites.json', params: { email: 'test@example.com', skip_email: true }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(0)\n      end\n\n      it 'fails in case of validation failure' do\n        sign_in(admin)\n\n        post '/invites.json', params: { email: 'test@mailinator.com' }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors']).to be_present\n      end\n    end\n\n    context 'link invite' do\n      it 'works' do\n        sign_in(admin)\n\n        post '/invites.json'\n        expect(response.status).to eq(200)\n        expect(Invite.last.email).to eq(nil)\n        expect(Invite.last.invited_by).to eq(admin)\n        expect(Invite.last.max_redemptions_allowed).to eq(1)\n      end\n\n      it 'fails if over invite_link_max_redemptions_limit' do\n        sign_in(admin)\n\n        post '/invites.json', params: { max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit - 1 }\n        expect(response.status).to eq(200)\n\n        post '/invites.json', params: { max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit + 1 }\n        expect(response.status).to eq(422)\n      end\n\n      it 'fails if over invite_link_max_redemptions_limit_users' do\n        sign_in(user)\n\n        post '/invites.json', params: { max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit_users - 1 }\n        expect(response.status).to eq(200)\n\n        post '/invites.json', params: { max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit_users + 1 }\n        expect(response.status).to eq(422)\n      end\n    end\n  end\n\n  context '#retrieve' do\n    it 'requires to be logged in' do\n      get '/invites/retrieve.json', params: { email: 'test@example.com' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user)\n      end\n\n      fab!(:invite) { Fabricate(:invite, invited_by: user, email: 'test@example.com') }\n\n      it 'raises an error when the email is missing' do\n        get '/invites/retrieve.json'\n        expect(response.status).to eq(400)\n      end\n\n      it 'raises an error when the email cannot be found' do\n        get '/invites/retrieve.json', params: { email: 'test2@example.com' }\n        expect(response.status).to eq(400)\n      end\n\n      it 'can retrieve the invite' do\n        get '/invites/retrieve.json', params: { email: 'test@example.com' }\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  context '#update' do\n    fab!(:invite) { Fabricate(:invite, invited_by: admin, email: 'test@example.com') }\n\n    it 'requires to be logged in' do\n      put \"/invites/#{invite.id}\", params: { email: 'test2@example.com' }\n      expect(response.status).to eq(400)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(admin)\n      end\n\n      it 'resends invite email if updating email address' do\n        put \"/invites/#{invite.id}\", params: { email: 'test2@example.com' }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n      end\n\n      it 'does not resend invite email if skip_email if updating email address' do\n        put \"/invites/#{invite.id}\", params: { email: 'test2@example.com', skip_email: true }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(0)\n      end\n\n      it 'does not resend invite email when updating other fields' do\n        put \"/invites/#{invite.id}\", params: { custom_message: 'new message' }\n        expect(response.status).to eq(200)\n        expect(invite.reload.custom_message).to eq('new message')\n        expect(Jobs::InviteEmail.jobs.size).to eq(0)\n      end\n\n      it 'can send invite email' do\n        sign_in(user)\n        RateLimiter.enable\n        RateLimiter.clear_all!\n\n        invite = Fabricate(:invite, invited_by: user, email: 'test@example.com')\n\n        expect { put \"/invites/#{invite.id}\", params: { send_email: true } }\n          .to change { RateLimiter.new(user, 'resend-invite-per-hour', 10, 1.hour).remaining }.by(-1)\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n      end\n\n      it 'cannot create duplicated invites' do\n        Fabricate(:invite, invited_by: admin, email: 'test2@example.com')\n\n        put \"/invites/#{invite.id}.json\", params: { email: 'test2@example.com' }\n        expect(response.status).to eq(409)\n      end\n    end\n  end\n\n  context '#destroy' do\n    it 'requires to be logged in' do\n      delete '/invites.json', params: { email: 'test@example.com' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      fab!(:invite) { Fabricate(:invite, invited_by: user) }\n\n      before { sign_in(user) }\n\n      it 'raises an error when id is missing' do\n        delete '/invites.json'\n        expect(response.status).to eq(400)\n      end\n\n      it 'raises an error when invite does not exist' do\n        delete '/invites.json', params: { id: 848 }\n        expect(response.status).to eq(400)\n      end\n\n      it 'raises an error when invite is not created by user' do\n        another_invite = Fabricate(:invite, email: 'test2@example.com')\n\n        delete '/invites.json', params: { id: another_invite.id }\n        expect(response.status).to eq(400)\n      end\n\n      it 'destroys the invite' do\n        delete '/invites.json', params: { id: invite.id }\n        expect(response.status).to eq(200)\n        expect(invite.reload.trashed?).to be_truthy\n      end\n    end\n  end\n\n  context '#perform_accept_invitation' do\n    context 'with an invalid invite' do\n      it 'redirects to the root' do\n        put '/invites/show/doesntexist.json'\n        expect(response.status).to eq(404)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.not_found_json'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'with a deleted invite' do\n      fab!(:invite) { Fabricate(:invite) }\n\n      before do\n        invite.trash!\n      end\n\n      it 'redirects to the root' do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.not_found_json'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'with an expired invite' do\n      fab!(:invite) { Fabricate(:invite, expires_at: 1.day.ago) }\n\n      it 'response is not successful' do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.not_found_json'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'with an email invite' do\n      let(:topic) { Fabricate(:topic) }\n      let(:invite) { Invite.generate(topic.user, email: 'iceking@adventuretime.ooo', topic: topic) }\n\n      it 'redeems the invite' do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(invite.reload.redeemed?).to be_truthy\n      end\n\n      it 'logs in the user' do\n        events = DiscourseEvent.track_events do\n          put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        end\n\n        expect(events.map { |event| event[:event_name] }).to include(:user_logged_in, :user_first_logged_in)\n        expect(response.status).to eq(200)\n        expect(session[:current_user_id]).to eq(invite.invited_users.first.user_id)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = User.find(invite.invited_users.first.user_id)\n        expect(user.ip_address).to be_present\n        expect(user.registration_ip_address).to be_present\n      end\n\n      it 'redirects to the first topic the user was invited to' do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)\n        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n      end\n\n      it 'sets the timezone of the user in user_options' do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { timezone: 'Australia/Melbourne' }\n        expect(response.status).to eq(200)\n        invite.reload\n        user = User.find(invite.invited_users.first.user_id)\n        expect(user.user_option.timezone).to eq('Australia/Melbourne')\n      end\n\n      it 'does not log in the user if there are validation errors' do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { password: 'password' }\n        expect(response.status).to eq(412)\n      end\n\n      it 'fails when local login is disabled and no external auth is configured' do\n        SiteSetting.enable_local_logins = false\n\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n      end\n\n      context 'with OmniAuth provider' do\n        fab!(:authenticated_email) { 'test@example.com' }\n\n        before do\n          OmniAuth.config.test_mode = true\n\n          OmniAuth.config.mock_auth[:google_oauth2] = OmniAuth::AuthHash.new(\n            provider: 'google_oauth2',\n            uid: '12345',\n            info: OmniAuth::AuthHash::InfoHash.new(\n              email: authenticated_email,\n              name: 'First Last'\n            ),\n            extra: {\n              raw_info: OmniAuth::AuthHash.new(\n                email_verified: true,\n                email: authenticated_email,\n                family_name: 'Last',\n                given_name: 'First',\n                gender: 'male',\n                name: 'First Last',\n              )\n            },\n          )\n\n          Rails.application.env_config['omniauth.auth'] = OmniAuth.config.mock_auth[:google_oauth2]\n          SiteSetting.enable_google_oauth2_logins = true\n\n          get '/auth/google_oauth2/callback.json'\n          expect(response.status).to eq(302)\n        end\n\n        after do\n          Rails.application.env_config['omniauth.auth'] = OmniAuth.config.mock_auth[:google_oauth2] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it 'should associate the invited user with authenticator records' do\n          SiteSetting.auth_overrides_name = true\n          invite.update!(email: authenticated_email)\n\n          expect { put \"/invites/show/#{invite.invite_key}.json\", params: { name: 'somename' } }\n            .to change { User.with_email(authenticated_email).exists? }.to(true)\n          expect(response.status).to eq(200)\n\n          user = User.find_by_email(authenticated_email)\n          expect(user.name).to eq('First Last')\n          expect(user.user_associated_accounts.first.provider_name).to eq('google_oauth2')\n        end\n\n        it 'returns the right response even if local logins has been disabled' do\n          SiteSetting.enable_local_logins = false\n          invite.update!(email: authenticated_email)\n\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n        end\n\n        it 'returns the right response if authenticated email does not match invite email' do\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(412)\n        end\n      end\n\n      context '.post_process_invite' do\n        it 'sends a welcome message if set' do\n          SiteSetting.send_welcome_message = true\n          user.send_welcome_message = true\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n        end\n\n        it 'refreshes automatic groups if staff' do\n          topic.user.grant_admin!\n          invite.update!(moderator: true)\n\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n\n          expect(invite.invited_users.first.user.groups.pluck(:name)).to contain_exactly('moderators', 'staff')\n        end\n\n        context 'without password' do\n          it 'sends password reset email' do\n            put \"/invites/show/#{invite.invite_key}.json\"\n            expect(response.status).to eq(200)\n\n            expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(1)\n            expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n          end\n        end\n\n        context 'with password' do\n          context 'user was invited via email' do\n            before { invite.update_column(:emailed_status, Invite.emailed_status_types[:pending]) }\n\n            it 'does not send an activation email and activates the user' do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\", params: { password: 'verystrongpassword', email_token: invite.email_token }\n              end.to change { UserAuthToken.count }.by(1)\n\n              expect(response.status).to eq(200)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(true)\n              expect(invited_user.email_confirmed?).to eq(true)\n            end\n\n            it 'does not activate user if email token is missing' do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\", params: { password: 'verystrongpassword' }\n              end.to change { UserAuthToken.count }.by(0)\n\n              expect(response.status).to eq(200)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(false)\n              expect(invited_user.email_confirmed?).to eq(false)\n            end\n          end\n\n          context 'user was invited via link' do\n            before { invite.update_column(:emailed_status, Invite.emailed_status_types[:not_required]) }\n\n            it 'sends an activation email and does not activate the user' do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\", params: { password: 'verystrongpassword' }\n              end.not_to change { UserAuthToken.count }\n\n              expect(response.status).to eq(200)\n              expect(response.parsed_body['message']).to eq(I18n.t('invite.confirm_email'))\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(false)\n              expect(invited_user.email_confirmed?).to eq(false)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n              tokens = EmailToken.where(user_id: invited_user.id, confirmed: false, expired: false)\n              expect(tokens.size).to eq(1)\n\n              job_args = Jobs::CriticalUserEmail.jobs.first['args'].first\n              expect(job_args['type']).to eq('signup')\n              expect(job_args['user_id']).to eq(invited_user.id)\n              expect(EmailToken.hash_token(job_args['email_token'])).to eq(tokens.first.token_hash)\n            end\n          end\n        end\n      end\n    end\n\n    context 'with a domain invite' do\n      fab!(:invite) { Fabricate(:invite, email: nil, emailed_status: Invite.emailed_status_types[:not_required], domain: 'example.com') }\n\n      it 'creates an user if email matches domain' do\n        expect { put \"/invites/show/#{invite.invite_key}.json\", params: { email: 'test@example.com', password: 'verystrongpassword' } }\n          .to change { User.count }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.confirm_email'))\n        expect(invite.reload.redemption_count).to eq(1)\n\n        invited_user = User.find_by_email('test@example.com')\n        expect(invited_user).to be_present\n      end\n\n      it 'does not create an user if email does not match domain' do\n        expect { put \"/invites/show/#{invite.invite_key}.json\", params: { email: 'test@example2.com', password: 'verystrongpassword' } }\n          .not_to change { User.count }\n\n        expect(response.status).to eq(412)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.domain_not_allowed'))\n        expect(invite.reload.redemption_count).to eq(0)\n      end\n    end\n\n    context 'with an invite link' do\n      fab!(:invite) { Fabricate(:invite, email: nil, emailed_status: Invite.emailed_status_types[:not_required]) }\n\n      it 'sends an activation email and does not activate the user' do\n        expect { put \"/invites/show/#{invite.invite_key}.json\", params: { email: 'test@example.com', password: 'verystrongpassword' } }\n          .not_to change { UserAuthToken.count }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.confirm_email'))\n        expect(invite.reload.redemption_count).to eq(1)\n\n        invited_user = User.find_by_email('test@example.com')\n        expect(invited_user.active).to eq(false)\n        expect(invited_user.email_confirmed?).to eq(false)\n\n        expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n        tokens = EmailToken.where(user_id: invited_user.id, confirmed: false, expired: false)\n        expect(tokens.size).to eq(1)\n\n        job_args = Jobs::CriticalUserEmail.jobs.first['args'].first\n        expect(job_args['type']).to eq('signup')\n        expect(job_args['user_id']).to eq(invited_user.id)\n        expect(EmailToken.hash_token(job_args['email_token'])).to eq(tokens.first.token_hash)\n      end\n    end\n\n    context 'new registrations are disabled' do\n      fab!(:topic) { Fabricate(:topic) }\n      fab!(:invite) { Invite.generate(topic.user, email: 'test@example.com', topic: topic) }\n\n      before { SiteSetting.allow_new_registrations = false }\n\n      it 'does not redeem the invite' do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(200)\n        expect(invite.reload.invited_users).to be_blank\n        expect(invite.redeemed?).to be_falsey\n        expect(response.body).to include(I18n.t('login.new_registrations_disabled'))\n      end\n    end\n\n    context 'user is already logged in' do\n      fab!(:invite) { Fabricate(:invite, email: 'test@example.com') }\n      fab!(:user) { sign_in(Fabricate(:user)) }\n\n      it 'does not redeem the invite' do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n        expect(response.status).to eq(200)\n        invite.reload\n        expect(invite.invited_users).to be_blank\n        expect(invite.redeemed?).to be_falsey\n        expect(response.body).to include(I18n.t('login.already_logged_in', current_user: user.username))\n      end\n    end\n\n    context 'topic invites' do\n      fab!(:invite) { Fabricate(:invite, email: 'test@example.com') }\n\n      fab!(:secured_category) do\n        secured_category = Fabricate(:category)\n        secured_category.permissions = { staff: :full }\n        secured_category.save!\n        secured_category\n      end\n\n      it 'redirects user to topic if activated' do\n        topic = Fabricate(:topic)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)\n        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n      end\n\n      it 'sets destination_url cookie if user is not activated' do\n        topic = Fabricate(:topic)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(cookies['destination_url']).to eq(topic.relative_url)\n        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n      end\n\n      it 'does not redirect user if they cannot see topic' do\n        topic = Fabricate(:topic, category: secured_category)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.parsed_body['redirect_to']).to eq(\"/\")\n        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(0)\n      end\n    end\n\n    context 'staged user' do\n      fab!(:invite) { Fabricate(:invite) }\n      fab!(:staged_user) { Fabricate(:user, staged: true, email: invite.email) }\n\n      it 'can keep the old username' do\n        old_username = staged_user.username\n\n        put \"/invites/show/#{invite.invite_key}.json\", params: {\n          username: staged_user.username,\n          password: \"Password123456\",\n          email_token: invite.email_token,\n        }\n\n        expect(response.status).to eq(200)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = invite.invited_users.first.user\n        expect(user.username).to eq(old_username)\n      end\n\n      it 'can change the username' do\n        put \"/invites/show/#{invite.invite_key}.json\", params: {\n          username: \"new_username\",\n          password: \"Password123456\",\n          email_token: invite.email_token,\n        }\n\n        expect(response.status).to eq(200)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = invite.invited_users.first.user\n        expect(user.username).to eq(\"new_username\")\n      end\n    end\n  end\n\n  context '#destroy_all_expired' do\n    it 'removes all expired invites sent by a user' do\n      SiteSetting.invite_expiry_days = 1\n\n      user = Fabricate(:admin)\n      invite_1 = Fabricate(:invite, invited_by: user)\n      invite_2 = Fabricate(:invite, invited_by: user)\n      expired_invite = Fabricate(:invite, invited_by: user)\n      expired_invite.update!(expires_at: 2.days.ago)\n\n      sign_in(user)\n      post '/invites/destroy-all-expired'\n\n      expect(response.status).to eq(200)\n      expect(invite_1.reload.deleted_at).to eq(nil)\n      expect(invite_2.reload.deleted_at).to eq(nil)\n      expect(expired_invite.reload.deleted_at).to be_present\n    end\n  end\n\n  context '#resend_invite' do\n    it 'requires to be logged in' do\n      post '/invites/reinvite.json', params: { email: 'first_name@example.com' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      fab!(:user) { sign_in(Fabricate(:user)) }\n      fab!(:invite) { Fabricate(:invite, invited_by: user) }\n      fab!(:another_invite) { Fabricate(:invite, email: 'last_name@example.com') }\n\n      it 'raises an error when the email is missing' do\n        post '/invites/reinvite.json'\n        expect(response.status).to eq(400)\n      end\n\n      it 'raises an error when the email cannot be found' do\n        post '/invites/reinvite.json', params: { email: 'first_name@example.com' }\n        expect(response.status).to eq(400)\n      end\n\n      it 'raises an error when the invite is not yours' do\n        post '/invites/reinvite.json', params: { email: another_invite.email }\n        expect(response.status).to eq(400)\n      end\n\n      it 'resends the invite' do\n        post '/invites/reinvite.json', params: { email: invite.email }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n      end\n    end\n  end\n\n  context '#resend_all_invites' do\n    it 'resends all non-redeemed invites by a user' do\n      SiteSetting.invite_expiry_days = 30\n\n      freeze_time\n\n      user = Fabricate(:admin)\n      new_invite = Fabricate(:invite, invited_by: user)\n      expired_invite = Fabricate(:invite, invited_by: user)\n      expired_invite.update!(expires_at: 2.days.ago)\n      redeemed_invite = Fabricate(:invite, invited_by: user)\n      Fabricate(:invited_user, invite: redeemed_invite, user: Fabricate(:user))\n      redeemed_invite.update!(expires_at: 5.days.ago)\n\n      sign_in(user)\n      post '/invites/reinvite-all'\n\n      expect(response.status).to eq(200)\n      expect(new_invite.reload.expires_at).to eq_time(30.days.from_now)\n      expect(expired_invite.reload.expires_at).to eq_time(2.days.ago)\n      expect(redeemed_invite.reload.expires_at).to eq_time(5.days.ago)\n    end\n  end\n\n  context '#upload_csv' do\n    it 'requires to be logged in' do\n      post '/invites/upload_csv.json'\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:csv_file) { File.new(\"#{Rails.root}/spec/fixtures/csv/discourse.csv\") }\n      let(:file) { Rack::Test::UploadedFile.new(File.open(csv_file)) }\n\n      let(:csv_file_with_headers) { File.new(\"#{Rails.root}/spec/fixtures/csv/discourse_headers.csv\") }\n      let(:file_with_headers) { Rack::Test::UploadedFile.new(File.open(csv_file_with_headers)) }\n      let(:csv_file_with_locales) { File.new(\"#{Rails.root}/spec/fixtures/csv/invites_with_locales.csv\") }\n      let(:file_with_locales) { Rack::Test::UploadedFile.new(File.open(csv_file_with_locales)) }\n\n      it 'fails if you cannot bulk invite to the forum' do\n        sign_in(Fabricate(:user))\n        post '/invites/upload_csv.json', params: { file: file, name: 'discourse.csv' }\n        expect(response.status).to eq(403)\n      end\n\n      it 'allows admin to bulk invite' do\n        sign_in(admin)\n        post '/invites/upload_csv.json', params: { file: file, name: 'discourse.csv' }\n        expect(response.status).to eq(200)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n      end\n\n      it 'allows admin to bulk invite when DiscourseConnect enabled' do\n        SiteSetting.discourse_connect_url = \"https://example.com\"\n        SiteSetting.enable_discourse_connect = true\n\n        sign_in(admin)\n        post '/invites/upload_csv.json', params: { file: file, name: 'discourse.csv' }\n        expect(response.status).to eq(200)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n      end\n\n      it 'sends limited invites at a time' do\n        SiteSetting.max_bulk_invites = 3\n        sign_in(admin)\n        post '/invites/upload_csv.json', params: { file: file, name: 'discourse.csv' }\n\n        expect(response.status).to eq(422)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n        expect(response.parsed_body['errors'][0]).to eq(I18n.t('bulk_invite.max_rows', max_bulk_invites: SiteSetting.max_bulk_invites))\n      end\n\n      it 'can import user fields' do\n        Jobs.run_immediately!\n        user_field = Fabricate(:user_field, name: \"location\")\n        Fabricate(:group, name: 'discourse')\n        Fabricate(:group, name: 'ubuntu')\n\n        sign_in(admin)\n\n        post '/invites/upload_csv.json', params: { file: file_with_headers, name: 'discourse_headers.csv' }\n        expect(response.status).to eq(200)\n\n        user = User.where(staged: true).find_by_email('test@example.com')\n        expect(user.user_fields[user_field.id.to_s]).to eq('usa')\n\n        user2 = User.where(staged: true).find_by_email('test2@example.com')\n        expect(user2.user_fields[user_field.id.to_s]).to eq('europe')\n      end\n\n      it 'can pre-set user locales' do\n        Jobs.run_immediately!\n        sign_in(admin)\n\n        post '/invites/upload_csv.json', params: { file: file_with_locales, name: 'discourse_headers.csv' }\n        expect(response.status).to eq(200)\n\n        user = User.where(staged: true).find_by_email('test@example.com')\n        expect(user.locale).to eq('de')\n\n        user2 = User.where(staged: true).find_by_email('test2@example.com')\n        expect(user2.locale).to eq('pl')\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire 'csv'\n\nclass InvitesController < ApplicationController\n\n  requires_login only: [:create, :retrieve, :destroy, :destroy_all_expired, :resend_invite, :resend_all_invites, :upload_csv]\n\n  skip_before_action :check_xhr, except: [:perform_accept_invitation]\n  skip_before_action :preload_json, except: [:show]\n  skip_before_action :redirect_to_login_if_required\n\n  before_action :ensure_invites_allowed, only: [:show, :perform_accept_invitation]\n  before_action :ensure_new_registrations_allowed, only: [:show, :perform_accept_invitation]\n  before_action :ensure_not_logged_in, only: :perform_accept_invitation\n\n  def show\n    expires_now\n\n    RateLimiter.new(nil, \"invites-show-#{request.remote_ip}\", 100, 1.minute).performed!\n\n    invite = Invite.find_by(invite_key: params[:id])\n    if invite.present? && invite.redeemable?\n      if current_user\n        added_to_group = false\n\n        if invite.groups.present?\n          invite_by_guardian = Guardian.new(invite.invited_by)\n          new_group_ids = invite.groups.pluck(:id) - current_user.group_users.pluck(:group_id)\n          new_group_ids.each do |id|\n            if group = Group.find_by(id: id)\n              if invite_by_guardian.can_edit_group?(group)\n                group.add(current_user)\n                added_to_group = true\n              end\n            end\n          end\n        end\n\n        create_topic_invite_notifications(invite, current_user)\n\n        if topic = invite.topics.first\n          new_guardian = Guardian.new(current_user)\n          return redirect_to(topic.url) if new_guardian.can_see?(topic)\n        elsif added_to_group\n          return redirect_to(path(\"/\"))\n        end\n\n        return ensure_not_logged_in\n      end\n\n      email = Email.obfuscate(invite.email)\n\n      # Show email if the user already authenticated their email\n      different_external_email = false\n      if session[:authentication]\n        auth_result = Auth::Result.from_session_data(session[:authentication], user: nil)\n        if invite.email == auth_result.email\n          email = invite.email\n        else\n          different_external_email = true\n        end\n      end\n\n      email_verified_by_link = invite.email_token.present? && params[:t] == invite.email_token\n      if email_verified_by_link\n        email = invite.email\n      end\n\n      hidden_email = email != invite.email\n\n      if hidden_email || invite.email.nil?\n        username = \"\"\n      else\n        username = UserNameSuggester.suggest(invite.email)\n      end\n\n      info = {\n        invited_by: UserNameSerializer.new(invite.invited_by, scope: guardian, root: false),\n        email: email,\n        hidden_email: hidden_email,\n        username: username,\n        is_invite_link: invite.is_invite_link?,\n        email_verified_by_link: email_verified_by_link\n      }\n\n      if different_external_email\n        info[:different_external_email] = true\n      end\n\n      if staged_user = User.where(staged: true).with_email(invite.email).first\n        info[:username] = staged_user.username\n        info[:user_fields] = staged_user.user_fields\n      end\n\n      store_preloaded(\"invite_info\", MultiJson.dump(info))\n\n      secure_session[\"invite-key\"] = invite.invite_key\n\n      render layout: 'application'\n    else\n      flash.now[:error] = if invite.blank?\n        I18n.t('invite.not_found', base_url: Discourse.base_url)\n      elsif invite.redeemed?\n        if invite.is_invite_link?\n          I18n.t('invite.not_found_template_link', site_name: SiteSetting.title, base_url: Discourse.base_url)\n        else\n          I18n.t('invite.not_found_template', site_name: SiteSetting.title, base_url: Discourse.base_url)\n        end\n      elsif invite.expired?\n        I18n.t('invite.expired', base_url: Discourse.base_url)\n      end\n\n      render layout: 'no_ember'\n    end\n  rescue RateLimiter::LimitExceeded => e\n    flash.now[:error] = e.description\n    render layout: 'no_ember'\n  end\n\n  def create\n    if params[:topic_id].present?\n      topic = Topic.find_by(id: params[:topic_id])\n      raise Discourse::InvalidParameters.new(:topic_id) if topic.blank?\n      guardian.ensure_can_invite_to!(topic)\n    end\n\n    if params[:group_ids].present? || params[:group_names].present?\n      groups = Group.lookup_groups(group_ids: params[:group_ids], group_names: params[:group_names])\n    end\n\n    guardian.ensure_can_invite_to_forum!(groups)\n\n    begin\n      invite = Invite.generate(current_user,\n        email: params[:email],\n        domain: params[:domain],\n        skip_email: params[:skip_email],\n        invited_by: current_user,\n        custom_message: params[:custom_message],\n        max_redemptions_allowed: params[:max_redemptions_allowed],\n        topic_id: topic&.id,\n        group_ids: groups&.map(&:id),\n        expires_at: params[:expires_at],\n      )\n\n      if invite.present?\n        render_serialized(invite, InviteSerializer, scope: guardian, root: nil, show_emails: params.has_key?(:email), show_warnings: true)\n      else\n        render json: failed_json, status: 422\n      end\n    rescue Invite::UserExists => e\n      render_json_error(e.message)\n    rescue ActiveRecord::RecordInvalid => e\n      render_json_error(e.record.errors.full_messages.first)\n    end\n  end\n\n  def retrieve\n    params.require(:email)\n\n    invite = Invite.find_by(invited_by: current_user, email: params[:email])\n    raise Discourse::InvalidParameters.new(:email) if invite.blank?\n\n    guardian.ensure_can_invite_to_forum!(nil)\n\n    render_serialized(invite, InviteSerializer, scope: guardian, root: nil, show_emails: params.has_key?(:email), show_warnings: true)\n  end\n\n  def update\n    invite = Invite.find_by(invited_by: current_user, id: params[:id])\n    raise Discourse::InvalidParameters.new(:id) if invite.blank?\n\n    if params[:topic_id].present?\n      topic = Topic.find_by(id: params[:topic_id])\n      raise Discourse::InvalidParameters.new(:topic_id) if topic.blank?\n      guardian.ensure_can_invite_to!(topic)\n    end\n\n    if params[:group_ids].present? || params[:group_names].present?\n      groups = Group.lookup_groups(group_ids: params[:group_ids], group_names: params[:group_names])\n    end\n\n    guardian.ensure_can_invite_to_forum!(groups)\n\n    Invite.transaction do\n      if params.has_key?(:topic_id)\n        invite.topic_invites.destroy_all\n        invite.topic_invites.create!(topic_id: topic.id) if topic.present?\n      end\n\n      if params.has_key?(:group_ids) || params.has_key?(:group_names)\n        invite.invited_groups.destroy_all\n        groups.each { |group| invite.invited_groups.find_or_create_by!(group_id: group.id) } if groups.present?\n      end\n\n      if params.has_key?(:email)\n        old_email = invite.email.presence\n        new_email = params[:email].presence\n\n        if new_email\n          if Invite.where.not(id: invite.id).find_by(email: new_email.downcase, invited_by_id: current_user.id)&.redeemable?\n            return render_json_error(I18n.t(\"invite.invite_exists\", email: new_email), status: 409)\n          end\n        end\n\n        if old_email != new_email\n          invite.emailed_status = if new_email && !params[:skip_email]\n            Invite.emailed_status_types[:pending]\n          else\n            Invite.emailed_status_types[:not_required]\n          end\n        end\n\n        invite.domain = nil if invite.email.present?\n      end\n\n      if params.has_key?(:domain)\n        invite.domain = params[:domain]\n\n        if invite.domain.present?\n          invite.email = nil\n          invite.emailed_status = Invite.emailed_status_types[:not_required]\n        end\n      end\n\n      if params[:send_email]\n        if invite.emailed_status != Invite.emailed_status_types[:pending]\n          begin\n            RateLimiter.new(current_user, \"resend-invite-per-hour\", 10, 1.hour).performed!\n          rescue RateLimiter::LimitExceeded\n            return render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n          end\n        end\n\n        invite.emailed_status = Invite.emailed_status_types[:pending]\n      end\n\n      begin\n        invite.update!(params.permit(:email, :custom_message, :max_redemptions_allowed, :expires_at))\n      rescue ActiveRecord::RecordInvalid => e\n        return render_json_error(e.record.errors.full_messages.first)\n      end\n    end\n\n    if invite.emailed_status == Invite.emailed_status_types[:pending]\n      invite.update_column(:emailed_status, Invite.emailed_status_types[:sending])\n      Jobs.enqueue(:invite_email, invite_id: invite.id, invite_to_topic: params[:invite_to_topic])\n    end\n\n    render_serialized(invite, InviteSerializer, scope: guardian, root: nil, show_emails: params.has_key?(:email), show_warnings: true)\n  end\n\n  def destroy\n    params.require(:id)\n\n    invite = Invite.find_by(invited_by_id: current_user.id, id: params[:id])\n    raise Discourse::InvalidParameters.new(:id) if invite.blank?\n\n    invite.trash!(current_user)\n\n    render json: success_json\n  end\n\n  # For DiscourseConnect SSO, all invite acceptance is done\n  # via the SessionController#sso_login route\n  def perform_accept_invitation\n    params.require(:id)\n    params.permit(:email, :username, :name, :password, :timezone, :email_token, user_custom_fields: {})\n\n    invite = Invite.find_by(invite_key: params[:id])\n\n    if invite.present?\n      begin\n        attrs = {\n          username: params[:username],\n          name: params[:name],\n          password: params[:password],\n          user_custom_fields: params[:user_custom_fields],\n          ip_address: request.remote_ip,\n          session: session\n        }\n\n        if invite.is_invite_link?\n          params.require(:email)\n          attrs[:email] = params[:email]\n        else\n          attrs[:email] = invite.email\n          attrs[:email_token] = params[:email_token] if params[:email_token].present?\n        end\n\n        user = invite.redeem(**attrs)\n      rescue ActiveRecord::RecordInvalid, ActiveRecord::RecordNotSaved, Invite::UserExists => e\n        return render json: failed_json.merge(message: e.message), status: 412\n      end\n\n      if user.blank?\n        return render json: failed_json.merge(message: I18n.t('invite.not_found_json')), status: 404\n      end\n\n      log_on_user(user) if user.active? && user.guardian.can_access_forum?\n      user.update_timezone_if_missing(params[:timezone])\n      post_process_invite(user)\n      create_topic_invite_notifications(invite, user)\n\n      topic = invite.topics.first\n      response = {}\n\n      if user.present?\n        if user.active? && user.guardian.can_access_forum?\n          if user.guardian.can_see?(topic)\n            response[:redirect_to] = path(topic.relative_url)\n          else\n            response[:redirect_to] = path(\"/\")\n          end\n        else\n          response[:message] = if user.active?\n            I18n.t('activation.approval_required')\n          else\n            I18n.t('invite.confirm_email')\n          end\n\n          if user.guardian.can_see?(topic)\n            cookies[:destination_url] = path(topic.relative_url)\n          end\n        end\n      end\n\n      render json: success_json.merge(response)\n    else\n      render json: failed_json.merge(message: I18n.t('invite.not_found_json')), status: 404\n    end\n  end\n\n  def destroy_all_expired\n    guardian.ensure_can_destroy_all_invites!(current_user)\n\n    Invite\n      .where(invited_by: current_user)\n      .where('expires_at < ?', Time.zone.now)\n      .find_each { |invite| invite.trash!(current_user) }\n\n    render json: success_json\n  end\n\n  def resend_invite\n    params.require(:email)\n    RateLimiter.new(current_user, \"resend-invite-per-hour\", 10, 1.hour).performed!\n\n    invite = Invite.find_by(invited_by_id: current_user.id, email: params[:email])\n    raise Discourse::InvalidParameters.new(:email) if invite.blank?\n    invite.resend_invite\n    render json: success_json\n  rescue RateLimiter::LimitExceeded\n    render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n  end\n\n  def resend_all_invites\n    guardian.ensure_can_resend_all_invites!(current_user)\n\n    Invite.pending(current_user)\n      .where('invites.email IS NOT NULL')\n      .find_each { |invite| invite.resend_invite }\n\n    render json: success_json\n  end\n\n  def upload_csv\n    guardian.ensure_can_bulk_invite_to_forum!(current_user)\n\n    hijack do\n      begin\n        file = params[:file] || params[:files].first\n\n        csv_header = nil\n        invites = []\n\n        CSV.foreach(file.tempfile, encoding: \"bom|utf-8\") do |row|\n          # Try to extract a CSV header, if it exists\n          if csv_header.nil?\n            if row[0] == 'email'\n              csv_header = row\n              next\n            else\n              csv_header = [\"email\", \"groups\", \"topic_id\"]\n            end\n          end\n\n          if row[0].present?\n            invites.push(csv_header.zip(row).map.to_h.filter { |k, v| v.present? })\n          end\n\n          break if invites.count >= SiteSetting.max_bulk_invites\n        end\n\n        if invites.present?\n          Jobs.enqueue(:bulk_invite, invites: invites, current_user_id: current_user.id)\n\n          if invites.count >= SiteSetting.max_bulk_invites\n            render json: failed_json.merge(errors: [I18n.t(\"bulk_invite.max_rows\", max_bulk_invites: SiteSetting.max_bulk_invites)]), status: 422\n          else\n            render json: success_json\n          end\n        else\n          render json: failed_json.merge(errors: [I18n.t(\"bulk_invite.error\")]), status: 422\n        end\n      end\n    end\n  end\n\n  private\n\n  def ensure_invites_allowed\n    if (!SiteSetting.enable_local_logins && Discourse.enabled_auth_providers.count == 0 && !SiteSetting.enable_discourse_connect)\n      raise Discourse::NotFound\n    end\n  end\n\n  def ensure_new_registrations_allowed\n    unless SiteSetting.allow_new_registrations\n      flash[:error] = I18n.t('login.new_registrations_disabled')\n      render layout: 'no_ember'\n      false\n    end\n  end\n\n  def ensure_not_logged_in\n    if current_user\n      flash[:error] = I18n.t(\"login.already_logged_in\")\n      render layout: 'no_ember'\n      false\n    end\n  end\n\n  def post_process_invite(user)\n    user.enqueue_welcome_message('welcome_invite') if user.send_welcome_message\n\n    Group.refresh_automatic_groups!(:admins, :moderators, :staff) if user.staff?\n\n    if user.has_password?\n      if !user.active\n        email_token = user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:signup])\n        EmailToken.enqueue_signup_email(email_token)\n      end\n    elsif !SiteSetting.enable_discourse_connect && SiteSetting.enable_local_logins\n      Jobs.enqueue(:invite_password_instructions_email, username: user.username)\n    end\n  end\n\n  def create_topic_invite_notifications(invite, user)\n    invite.topics.each do |topic|\n      if user.guardian.can_see?(topic)\n        last_notification = user.notifications\n          .where(notification_type: Notification.types[:invited_to_topic])\n          .where(topic_id: topic.id)\n          .where(post_number: 1)\n          .where('created_at > ?', 1.hour.ago)\n\n        if !last_notification.exists?\n          topic.create_invite_notification!(\n            user,\n            Notification.types[:invited_to_topic],\n            invite.invited_by.username\n          )\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe InvitesController do\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:user) { Fabricate(:user, trust_level: SiteSetting.min_trust_level_to_allow_invite) }\n\n  context '#show' do\n    fab!(:invite) { Fabricate(:invite) }\n\n    it 'shows the accept invite page' do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).not_to include(invite.email)\n      expect(response.body).to_not include(I18n.t('invite.not_found_template', site_name: SiteSetting.title, base_url: Discourse.base_url))\n\n      expect(response.body).to have_tag('div#data-preloaded') do |element|\n        json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n        invite_info = JSON.parse(json['invite_info'])\n        expect(invite_info['username']).to eq('')\n        expect(invite_info['email']).to eq('i*****g@a***********e.ooo')\n      end\n    end\n\n    it 'shows unobfuscated email if email data is present in authentication data' do\n      ActionDispatch::Request.any_instance.stubs(:session).returns(authentication: { email: invite.email })\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(invite.email)\n      expect(response.body).not_to include('i*****g@a***********e.ooo')\n    end\n\n    it 'shows default user fields' do\n      user_field = Fabricate(:user_field)\n      staged_user = Fabricate(:user, staged: true, email: invite.email)\n      staged_user.set_user_field(user_field.id, 'some value')\n      staged_user.save_custom_fields\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n        invite_info = JSON.parse(json['invite_info'])\n        expect(invite_info['username']).to eq(staged_user.username)\n        expect(invite_info['user_fields'][user_field.id.to_s]).to eq('some value')\n      end\n    end\n\n    it 'includes token validity boolean' do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n        invite_info = JSON.parse(json['invite_info'])\n        expect(invite_info['email_verified_by_link']).to eq(false)\n      end\n\n      get \"/invites/#{invite.invite_key}?t=#{invite.email_token}\"\n      expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n        json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n        invite_info = JSON.parse(json['invite_info'])\n        expect(invite_info['email_verified_by_link']).to eq(true)\n      end\n    end\n\n    it 'adds logged in users to invite groups' do\n      group = Fabricate(:group)\n      group.add_owner(invite.invited_by)\n      InvitedGroup.create!(group: group, invite: invite)\n\n      sign_in(user)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response).to redirect_to(\"/\")\n      expect(user.reload.groups).to include(group)\n    end\n\n    it 'redirects logged in users to invite topic if they can see it' do\n      topic = Fabricate(:topic)\n      TopicInvite.create!(topic: topic, invite: invite)\n\n      sign_in(user)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response).to redirect_to(topic.url)\n      expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n    end\n\n    it 'adds logged in user to group and redirects them to invite topic' do\n      group = Fabricate(:group)\n      group.add_owner(invite.invited_by)\n      secured_category = Fabricate(:category)\n      secured_category.permissions = { group.name => :full }\n      secured_category.save!\n      topic = Fabricate(:topic, category: secured_category)\n      TopicInvite.create!(invite: invite, topic: topic)\n      InvitedGroup.create!(invite: invite, group: group)\n\n      sign_in(user)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(user.reload.groups).to include(group)\n      expect(response).to redirect_to(topic.url)\n      expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n    end\n\n    it 'fails for logged in users' do\n      sign_in(Fabricate(:user))\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(I18n.t('login.already_logged_in'))\n    end\n\n    it 'fails if invite does not exist' do\n      get '/invites/missing'\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(I18n.t('invite.not_found', base_url: Discourse.base_url))\n    end\n\n    it 'fails if invite expired' do\n      invite.update(expires_at: 1.day.ago)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(I18n.t('invite.expired', base_url: Discourse.base_url))\n    end\n\n    it 'stores the invite key in the secure session if invite exists' do\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      invite_key = read_secure_session['invite-key']\n      expect(invite_key).to eq(invite.invite_key)\n    end\n\n    it 'returns error if invite has already been redeemed' do\n      expect(invite.redeem).not_to eq(nil)\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(I18n.t('invite.not_found_template', site_name: SiteSetting.title, base_url: Discourse.base_url))\n\n      invite.update!(email: nil) # convert to email invite\n\n      get \"/invites/#{invite.invite_key}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not have_tag(:script, with: { src: '/assets/application.js' })\n      expect(response.body).to include(I18n.t('invite.not_found_template_link', site_name: SiteSetting.title, base_url: Discourse.base_url))\n    end\n  end\n\n  context '#create' do\n    it 'requires to be logged in' do\n      post '/invites.json', params: { email: 'test@example.com' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user)\n      end\n\n      it 'fails if you cannot invite to the forum' do\n        sign_in(Fabricate(:user))\n\n        post '/invites.json', params: { email: 'test@example.com' }\n        expect(response).to be_forbidden\n      end\n    end\n\n    context 'invite to topic' do\n      fab!(:topic) { Fabricate(:topic) }\n\n      it 'works' do\n        sign_in(user)\n\n        post '/invites.json', params: { email: 'test@example.com', topic_id: topic.id }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.first['args'].first['invite_to_topic']).to be_falsey\n      end\n\n      it 'fails when topic_id is invalid' do\n        sign_in(user)\n\n        post '/invites.json', params: { email: 'test@example.com', topic_id: -9999 }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context 'invite to group' do\n      fab!(:group) { Fabricate(:group) }\n\n      it 'works for admins' do\n        sign_in(admin)\n\n        post '/invites.json', params: { email: 'test@example.com', group_ids: [group.id] }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: 'test@example.com').invited_groups.count).to eq(1)\n      end\n\n      it 'works for group owners' do\n        sign_in(user)\n        group.add_owner(user)\n\n        post '/invites.json', params: { email: 'test@example.com', group_ids: [group.id] }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: 'test@example.com').invited_groups.count).to eq(1)\n      end\n\n      it 'works with multiple groups' do\n        sign_in(admin)\n        group2 = Fabricate(:group)\n\n        post '/invites.json', params: { email: 'test@example.com', group_names: \"#{group.name},#{group2.name}\" }\n        expect(response.status).to eq(200)\n        expect(Invite.find_by(email: 'test@example.com').invited_groups.count).to eq(2)\n      end\n\n      it 'fails for group members' do\n        sign_in(user)\n        group.add(user)\n\n        post '/invites.json', params: { email: 'test@example.com', group_ids: [group.id] }\n        expect(response.status).to eq(403)\n      end\n\n      it 'fails for other users' do\n        sign_in(user)\n\n        post '/invites.json', params: { email: 'test@example.com', group_ids: [group.id] }\n        expect(response.status).to eq(403)\n      end\n\n      it 'fails to invite new user to a group-private topic' do\n        sign_in(user)\n        private_category = Fabricate(:private_category, group: group)\n        group_private_topic = Fabricate(:topic, category: private_category)\n\n        post '/invites.json', params: { email: 'test@example.com', topic_id: group_private_topic.id  }\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'email invite' do\n      it 'creates invite once and updates it on successive calls' do\n        sign_in(user)\n\n        post '/invites.json', params: { email: 'test@example.com' }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n\n        invite = Invite.last\n\n        post '/invites.json', params: { email: 'test@example.com' }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['id']).to eq(invite.id)\n      end\n\n      it 'accept skip_email parameter' do\n        sign_in(user)\n\n        post '/invites.json', params: { email: 'test@example.com', skip_email: true }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(0)\n      end\n\n      it 'fails in case of validation failure' do\n        sign_in(admin)\n\n        post '/invites.json', params: { email: 'test@mailinator.com' }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors']).to be_present\n      end\n    end\n\n    context 'link invite' do\n      it 'works' do\n        sign_in(admin)\n\n        post '/invites.json'\n        expect(response.status).to eq(200)\n        expect(Invite.last.email).to eq(nil)\n        expect(Invite.last.invited_by).to eq(admin)\n        expect(Invite.last.max_redemptions_allowed).to eq(1)\n      end\n\n      it 'fails if over invite_link_max_redemptions_limit' do\n        sign_in(admin)\n\n        post '/invites.json', params: { max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit - 1 }\n        expect(response.status).to eq(200)\n\n        post '/invites.json', params: { max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit + 1 }\n        expect(response.status).to eq(422)\n      end\n\n      it 'fails if over invite_link_max_redemptions_limit_users' do\n        sign_in(user)\n\n        post '/invites.json', params: { max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit_users - 1 }\n        expect(response.status).to eq(200)\n\n        post '/invites.json', params: { max_redemptions_allowed: SiteSetting.invite_link_max_redemptions_limit_users + 1 }\n        expect(response.status).to eq(422)\n      end\n    end\n  end\n\n  context '#retrieve' do\n    it 'requires to be logged in' do\n      get '/invites/retrieve.json', params: { email: 'test@example.com' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user)\n      end\n\n      fab!(:invite) { Fabricate(:invite, invited_by: user, email: 'test@example.com') }\n\n      it 'raises an error when the email is missing' do\n        get '/invites/retrieve.json'\n        expect(response.status).to eq(400)\n      end\n\n      it 'raises an error when the email cannot be found' do\n        get '/invites/retrieve.json', params: { email: 'test2@example.com' }\n        expect(response.status).to eq(400)\n      end\n\n      it 'can retrieve the invite' do\n        get '/invites/retrieve.json', params: { email: 'test@example.com' }\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  context '#update' do\n    fab!(:invite) { Fabricate(:invite, invited_by: admin, email: 'test@example.com') }\n\n    it 'requires to be logged in' do\n      put \"/invites/#{invite.id}\", params: { email: 'test2@example.com' }\n      expect(response.status).to eq(400)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(admin)\n      end\n\n      it 'resends invite email if updating email address' do\n        put \"/invites/#{invite.id}\", params: { email: 'test2@example.com' }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n      end\n\n      it 'does not resend invite email if skip_email if updating email address' do\n        put \"/invites/#{invite.id}\", params: { email: 'test2@example.com', skip_email: true }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(0)\n      end\n\n      it 'does not resend invite email when updating other fields' do\n        put \"/invites/#{invite.id}\", params: { custom_message: 'new message' }\n        expect(response.status).to eq(200)\n        expect(invite.reload.custom_message).to eq('new message')\n        expect(Jobs::InviteEmail.jobs.size).to eq(0)\n      end\n\n      it 'can send invite email' do\n        sign_in(user)\n        RateLimiter.enable\n        RateLimiter.clear_all!\n\n        invite = Fabricate(:invite, invited_by: user, email: 'test@example.com')\n\n        expect { put \"/invites/#{invite.id}\", params: { send_email: true } }\n          .to change { RateLimiter.new(user, 'resend-invite-per-hour', 10, 1.hour).remaining }.by(-1)\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n      end\n\n      it 'cannot create duplicated invites' do\n        Fabricate(:invite, invited_by: admin, email: 'test2@example.com')\n\n        put \"/invites/#{invite.id}.json\", params: { email: 'test2@example.com' }\n        expect(response.status).to eq(409)\n      end\n    end\n  end\n\n  context '#destroy' do\n    it 'requires to be logged in' do\n      delete '/invites.json', params: { email: 'test@example.com' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      fab!(:invite) { Fabricate(:invite, invited_by: user) }\n\n      before { sign_in(user) }\n\n      it 'raises an error when id is missing' do\n        delete '/invites.json'\n        expect(response.status).to eq(400)\n      end\n\n      it 'raises an error when invite does not exist' do\n        delete '/invites.json', params: { id: 848 }\n        expect(response.status).to eq(400)\n      end\n\n      it 'raises an error when invite is not created by user' do\n        another_invite = Fabricate(:invite, email: 'test2@example.com')\n\n        delete '/invites.json', params: { id: another_invite.id }\n        expect(response.status).to eq(400)\n      end\n\n      it 'destroys the invite' do\n        delete '/invites.json', params: { id: invite.id }\n        expect(response.status).to eq(200)\n        expect(invite.reload.trashed?).to be_truthy\n      end\n    end\n  end\n\n  context '#perform_accept_invitation' do\n    context 'with an invalid invite' do\n      it 'redirects to the root' do\n        put '/invites/show/doesntexist.json'\n        expect(response.status).to eq(404)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.not_found_json'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'with a deleted invite' do\n      fab!(:invite) { Fabricate(:invite) }\n\n      before do\n        invite.trash!\n      end\n\n      it 'redirects to the root' do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.not_found_json'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'with an expired invite' do\n      fab!(:invite) { Fabricate(:invite, expires_at: 1.day.ago) }\n\n      it 'response is not successful' do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.not_found_json'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'with an email invite' do\n      let(:topic) { Fabricate(:topic) }\n      let(:invite) { Invite.generate(topic.user, email: 'iceking@adventuretime.ooo', topic: topic) }\n\n      it 'redeems the invite' do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(invite.reload.redeemed?).to be_truthy\n      end\n\n      it 'logs in the user' do\n        events = DiscourseEvent.track_events do\n          put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        end\n\n        expect(events.map { |event| event[:event_name] }).to include(:user_logged_in, :user_first_logged_in)\n        expect(response.status).to eq(200)\n        expect(session[:current_user_id]).to eq(invite.invited_users.first.user_id)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = User.find(invite.invited_users.first.user_id)\n        expect(user.ip_address).to be_present\n        expect(user.registration_ip_address).to be_present\n      end\n\n      it 'redirects to the first topic the user was invited to' do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)\n        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n      end\n\n      it 'sets the timezone of the user in user_options' do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { timezone: 'Australia/Melbourne' }\n        expect(response.status).to eq(200)\n        invite.reload\n        user = User.find(invite.invited_users.first.user_id)\n        expect(user.user_option.timezone).to eq('Australia/Melbourne')\n      end\n\n      it 'does not log in the user if there are validation errors' do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { password: 'password' }\n        expect(response.status).to eq(412)\n      end\n\n      it 'does not log in the user if they were not approved' do\n        SiteSetting.must_approve_users = true\n\n        put \"/invites/show/#{invite.invite_key}.json\", params: { password: SecureRandom.hex, email_token: invite.email_token }\n\n        expect(session[:current_user_id]).to eq(nil)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t('activation.approval_required'))\n      end\n\n      it 'does not log in the user if they were not activated' do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { password: SecureRandom.hex }\n\n        expect(session[:current_user_id]).to eq(nil)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t('invite.confirm_email'))\n      end\n\n      it 'fails when local login is disabled and no external auth is configured' do\n        SiteSetting.enable_local_logins = false\n\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(404)\n      end\n\n      context 'with OmniAuth provider' do\n        fab!(:authenticated_email) { 'test@example.com' }\n\n        before do\n          OmniAuth.config.test_mode = true\n\n          OmniAuth.config.mock_auth[:google_oauth2] = OmniAuth::AuthHash.new(\n            provider: 'google_oauth2',\n            uid: '12345',\n            info: OmniAuth::AuthHash::InfoHash.new(\n              email: authenticated_email,\n              name: 'First Last'\n            ),\n            extra: {\n              raw_info: OmniAuth::AuthHash.new(\n                email_verified: true,\n                email: authenticated_email,\n                family_name: 'Last',\n                given_name: 'First',\n                gender: 'male',\n                name: 'First Last',\n              )\n            },\n          )\n\n          Rails.application.env_config['omniauth.auth'] = OmniAuth.config.mock_auth[:google_oauth2]\n          SiteSetting.enable_google_oauth2_logins = true\n\n          get '/auth/google_oauth2/callback.json'\n          expect(response.status).to eq(302)\n        end\n\n        after do\n          Rails.application.env_config['omniauth.auth'] = OmniAuth.config.mock_auth[:google_oauth2] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it 'should associate the invited user with authenticator records' do\n          SiteSetting.auth_overrides_name = true\n          invite.update!(email: authenticated_email)\n\n          expect { put \"/invites/show/#{invite.invite_key}.json\", params: { name: 'somename' } }\n            .to change { User.with_email(authenticated_email).exists? }.to(true)\n          expect(response.status).to eq(200)\n\n          user = User.find_by_email(authenticated_email)\n          expect(user.name).to eq('First Last')\n          expect(user.user_associated_accounts.first.provider_name).to eq('google_oauth2')\n        end\n\n        it 'returns the right response even if local logins has been disabled' do\n          SiteSetting.enable_local_logins = false\n          invite.update!(email: authenticated_email)\n\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n        end\n\n        it 'returns the right response if authenticated email does not match invite email' do\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(412)\n        end\n      end\n\n      context '.post_process_invite' do\n        it 'sends a welcome message if set' do\n          SiteSetting.send_welcome_message = true\n          user.send_welcome_message = true\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n        end\n\n        it 'refreshes automatic groups if staff' do\n          topic.user.grant_admin!\n          invite.update!(moderator: true)\n\n          put \"/invites/show/#{invite.invite_key}.json\"\n          expect(response.status).to eq(200)\n\n          expect(invite.invited_users.first.user.groups.pluck(:name)).to contain_exactly('moderators', 'staff')\n        end\n\n        context 'without password' do\n          it 'sends password reset email' do\n            put \"/invites/show/#{invite.invite_key}.json\"\n            expect(response.status).to eq(200)\n\n            expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(1)\n            expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n          end\n        end\n\n        context 'with password' do\n          context 'user was invited via email' do\n            before { invite.update_column(:emailed_status, Invite.emailed_status_types[:pending]) }\n\n            it 'does not send an activation email and activates the user' do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\", params: { password: 'verystrongpassword', email_token: invite.email_token }\n              end.to change { UserAuthToken.count }.by(1)\n\n              expect(response.status).to eq(200)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(true)\n              expect(invited_user.email_confirmed?).to eq(true)\n            end\n\n            it 'does not activate user if email token is missing' do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\", params: { password: 'verystrongpassword' }\n              end.to change { UserAuthToken.count }.by(0)\n\n              expect(response.status).to eq(200)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(false)\n              expect(invited_user.email_confirmed?).to eq(false)\n            end\n          end\n\n          context 'user was invited via link' do\n            before { invite.update_column(:emailed_status, Invite.emailed_status_types[:not_required]) }\n\n            it 'sends an activation email and does not activate the user' do\n              expect do\n                put \"/invites/show/#{invite.invite_key}.json\", params: { password: 'verystrongpassword' }\n              end.not_to change { UserAuthToken.count }\n\n              expect(response.status).to eq(200)\n              expect(response.parsed_body['message']).to eq(I18n.t('invite.confirm_email'))\n\n              invited_user = User.find_by_email(invite.email)\n              expect(invited_user.active).to eq(false)\n              expect(invited_user.email_confirmed?).to eq(false)\n\n              expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n              expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n              tokens = EmailToken.where(user_id: invited_user.id, confirmed: false, expired: false)\n              expect(tokens.size).to eq(1)\n\n              job_args = Jobs::CriticalUserEmail.jobs.first['args'].first\n              expect(job_args['type']).to eq('signup')\n              expect(job_args['user_id']).to eq(invited_user.id)\n              expect(EmailToken.hash_token(job_args['email_token'])).to eq(tokens.first.token_hash)\n            end\n          end\n        end\n      end\n    end\n\n    context 'with a domain invite' do\n      fab!(:invite) { Fabricate(:invite, email: nil, emailed_status: Invite.emailed_status_types[:not_required], domain: 'example.com') }\n\n      it 'creates an user if email matches domain' do\n        expect { put \"/invites/show/#{invite.invite_key}.json\", params: { email: 'test@example.com', password: 'verystrongpassword' } }\n          .to change { User.count }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.confirm_email'))\n        expect(invite.reload.redemption_count).to eq(1)\n\n        invited_user = User.find_by_email('test@example.com')\n        expect(invited_user).to be_present\n      end\n\n      it 'does not create an user if email does not match domain' do\n        expect { put \"/invites/show/#{invite.invite_key}.json\", params: { email: 'test@example2.com', password: 'verystrongpassword' } }\n          .not_to change { User.count }\n\n        expect(response.status).to eq(412)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.domain_not_allowed'))\n        expect(invite.reload.redemption_count).to eq(0)\n      end\n    end\n\n    context 'with an invite link' do\n      fab!(:invite) { Fabricate(:invite, email: nil, emailed_status: Invite.emailed_status_types[:not_required]) }\n\n      it 'sends an activation email and does not activate the user' do\n        expect { put \"/invites/show/#{invite.invite_key}.json\", params: { email: 'test@example.com', password: 'verystrongpassword' } }\n          .not_to change { UserAuthToken.count }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['message']).to eq(I18n.t('invite.confirm_email'))\n        expect(invite.reload.redemption_count).to eq(1)\n\n        invited_user = User.find_by_email('test@example.com')\n        expect(invited_user.active).to eq(false)\n        expect(invited_user.email_confirmed?).to eq(false)\n\n        expect(Jobs::InvitePasswordInstructionsEmail.jobs.size).to eq(0)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n\n        tokens = EmailToken.where(user_id: invited_user.id, confirmed: false, expired: false)\n        expect(tokens.size).to eq(1)\n\n        job_args = Jobs::CriticalUserEmail.jobs.first['args'].first\n        expect(job_args['type']).to eq('signup')\n        expect(job_args['user_id']).to eq(invited_user.id)\n        expect(EmailToken.hash_token(job_args['email_token'])).to eq(tokens.first.token_hash)\n      end\n    end\n\n    context 'new registrations are disabled' do\n      fab!(:topic) { Fabricate(:topic) }\n      fab!(:invite) { Invite.generate(topic.user, email: 'test@example.com', topic: topic) }\n\n      before { SiteSetting.allow_new_registrations = false }\n\n      it 'does not redeem the invite' do\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(response.status).to eq(200)\n        expect(invite.reload.invited_users).to be_blank\n        expect(invite.redeemed?).to be_falsey\n        expect(response.body).to include(I18n.t('login.new_registrations_disabled'))\n      end\n    end\n\n    context 'user is already logged in' do\n      fab!(:invite) { Fabricate(:invite, email: 'test@example.com') }\n      fab!(:user) { sign_in(Fabricate(:user)) }\n\n      it 'does not redeem the invite' do\n        put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n        expect(response.status).to eq(200)\n        invite.reload\n        expect(invite.invited_users).to be_blank\n        expect(invite.redeemed?).to be_falsey\n        expect(response.body).to include(I18n.t('login.already_logged_in', current_user: user.username))\n      end\n    end\n\n    context 'topic invites' do\n      fab!(:invite) { Fabricate(:invite, email: 'test@example.com') }\n\n      fab!(:secured_category) do\n        secured_category = Fabricate(:category)\n        secured_category.permissions = { staff: :full }\n        secured_category.save!\n        secured_category\n      end\n\n      it 'redirects user to topic if activated' do\n        topic = Fabricate(:topic)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)\n        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n      end\n\n      it 'sets destination_url cookie if user is not activated' do\n        topic = Fabricate(:topic)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\"\n        expect(cookies['destination_url']).to eq(topic.relative_url)\n        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n      end\n\n      it 'does not redirect user if they cannot see topic' do\n        topic = Fabricate(:topic, category: secured_category)\n        TopicInvite.create!(invite: invite, topic: topic)\n\n        put \"/invites/show/#{invite.invite_key}.json\", params: { email_token: invite.email_token }\n        expect(response.parsed_body['redirect_to']).to eq(\"/\")\n        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(0)\n      end\n    end\n\n    context 'staged user' do\n      fab!(:invite) { Fabricate(:invite) }\n      fab!(:staged_user) { Fabricate(:user, staged: true, email: invite.email) }\n\n      it 'can keep the old username' do\n        old_username = staged_user.username\n\n        put \"/invites/show/#{invite.invite_key}.json\", params: {\n          username: staged_user.username,\n          password: \"Password123456\",\n          email_token: invite.email_token,\n        }\n\n        expect(response.status).to eq(200)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = invite.invited_users.first.user\n        expect(user.username).to eq(old_username)\n      end\n\n      it 'can change the username' do\n        put \"/invites/show/#{invite.invite_key}.json\", params: {\n          username: \"new_username\",\n          password: \"Password123456\",\n          email_token: invite.email_token,\n        }\n\n        expect(response.status).to eq(200)\n        expect(invite.reload.redeemed?).to be_truthy\n        user = invite.invited_users.first.user\n        expect(user.username).to eq(\"new_username\")\n      end\n    end\n  end\n\n  context '#destroy_all_expired' do\n    it 'removes all expired invites sent by a user' do\n      SiteSetting.invite_expiry_days = 1\n\n      user = Fabricate(:admin)\n      invite_1 = Fabricate(:invite, invited_by: user)\n      invite_2 = Fabricate(:invite, invited_by: user)\n      expired_invite = Fabricate(:invite, invited_by: user)\n      expired_invite.update!(expires_at: 2.days.ago)\n\n      sign_in(user)\n      post '/invites/destroy-all-expired'\n\n      expect(response.status).to eq(200)\n      expect(invite_1.reload.deleted_at).to eq(nil)\n      expect(invite_2.reload.deleted_at).to eq(nil)\n      expect(expired_invite.reload.deleted_at).to be_present\n    end\n  end\n\n  context '#resend_invite' do\n    it 'requires to be logged in' do\n      post '/invites/reinvite.json', params: { email: 'first_name@example.com' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      fab!(:user) { sign_in(Fabricate(:user)) }\n      fab!(:invite) { Fabricate(:invite, invited_by: user) }\n      fab!(:another_invite) { Fabricate(:invite, email: 'last_name@example.com') }\n\n      it 'raises an error when the email is missing' do\n        post '/invites/reinvite.json'\n        expect(response.status).to eq(400)\n      end\n\n      it 'raises an error when the email cannot be found' do\n        post '/invites/reinvite.json', params: { email: 'first_name@example.com' }\n        expect(response.status).to eq(400)\n      end\n\n      it 'raises an error when the invite is not yours' do\n        post '/invites/reinvite.json', params: { email: another_invite.email }\n        expect(response.status).to eq(400)\n      end\n\n      it 'resends the invite' do\n        post '/invites/reinvite.json', params: { email: invite.email }\n        expect(response.status).to eq(200)\n        expect(Jobs::InviteEmail.jobs.size).to eq(1)\n      end\n    end\n  end\n\n  context '#resend_all_invites' do\n    it 'resends all non-redeemed invites by a user' do\n      SiteSetting.invite_expiry_days = 30\n\n      freeze_time\n\n      user = Fabricate(:admin)\n      new_invite = Fabricate(:invite, invited_by: user)\n      expired_invite = Fabricate(:invite, invited_by: user)\n      expired_invite.update!(expires_at: 2.days.ago)\n      redeemed_invite = Fabricate(:invite, invited_by: user)\n      Fabricate(:invited_user, invite: redeemed_invite, user: Fabricate(:user))\n      redeemed_invite.update!(expires_at: 5.days.ago)\n\n      sign_in(user)\n      post '/invites/reinvite-all'\n\n      expect(response.status).to eq(200)\n      expect(new_invite.reload.expires_at).to eq_time(30.days.from_now)\n      expect(expired_invite.reload.expires_at).to eq_time(2.days.ago)\n      expect(redeemed_invite.reload.expires_at).to eq_time(5.days.ago)\n    end\n  end\n\n  context '#upload_csv' do\n    it 'requires to be logged in' do\n      post '/invites/upload_csv.json'\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:csv_file) { File.new(\"#{Rails.root}/spec/fixtures/csv/discourse.csv\") }\n      let(:file) { Rack::Test::UploadedFile.new(File.open(csv_file)) }\n\n      let(:csv_file_with_headers) { File.new(\"#{Rails.root}/spec/fixtures/csv/discourse_headers.csv\") }\n      let(:file_with_headers) { Rack::Test::UploadedFile.new(File.open(csv_file_with_headers)) }\n      let(:csv_file_with_locales) { File.new(\"#{Rails.root}/spec/fixtures/csv/invites_with_locales.csv\") }\n      let(:file_with_locales) { Rack::Test::UploadedFile.new(File.open(csv_file_with_locales)) }\n\n      it 'fails if you cannot bulk invite to the forum' do\n        sign_in(Fabricate(:user))\n        post '/invites/upload_csv.json', params: { file: file, name: 'discourse.csv' }\n        expect(response.status).to eq(403)\n      end\n\n      it 'allows admin to bulk invite' do\n        sign_in(admin)\n        post '/invites/upload_csv.json', params: { file: file, name: 'discourse.csv' }\n        expect(response.status).to eq(200)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n      end\n\n      it 'allows admin to bulk invite when DiscourseConnect enabled' do\n        SiteSetting.discourse_connect_url = \"https://example.com\"\n        SiteSetting.enable_discourse_connect = true\n\n        sign_in(admin)\n        post '/invites/upload_csv.json', params: { file: file, name: 'discourse.csv' }\n        expect(response.status).to eq(200)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n      end\n\n      it 'sends limited invites at a time' do\n        SiteSetting.max_bulk_invites = 3\n        sign_in(admin)\n        post '/invites/upload_csv.json', params: { file: file, name: 'discourse.csv' }\n\n        expect(response.status).to eq(422)\n        expect(Jobs::BulkInvite.jobs.size).to eq(1)\n        expect(response.parsed_body['errors'][0]).to eq(I18n.t('bulk_invite.max_rows', max_bulk_invites: SiteSetting.max_bulk_invites))\n      end\n\n      it 'can import user fields' do\n        Jobs.run_immediately!\n        user_field = Fabricate(:user_field, name: \"location\")\n        Fabricate(:group, name: 'discourse')\n        Fabricate(:group, name: 'ubuntu')\n\n        sign_in(admin)\n\n        post '/invites/upload_csv.json', params: { file: file_with_headers, name: 'discourse_headers.csv' }\n        expect(response.status).to eq(200)\n\n        user = User.where(staged: true).find_by_email('test@example.com')\n        expect(user.user_fields[user_field.id.to_s]).to eq('usa')\n\n        user2 = User.where(staged: true).find_by_email('test2@example.com')\n        expect(user2.user_fields[user_field.id.to_s]).to eq('europe')\n      end\n\n      it 'can pre-set user locales' do\n        Jobs.run_immediately!\n        sign_in(admin)\n\n        post '/invites/upload_csv.json', params: { file: file_with_locales, name: 'discourse_headers.csv' }\n        expect(response.status).to eq(200)\n\n        user = User.where(staged: true).find_by_email('test@example.com')\n        expect(user.locale).to eq('de')\n\n        user2 = User.where(staged: true).find_by_email('test2@example.com')\n        expect(user2.locale).to eq('pl')\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/invites_controller.rb", "spec/requests/invites_controller_spec.rb"], "buggy_code_start_loc": [301, 510], "buggy_code_end_loc": [318, 510], "fixing_code_start_loc": [301, 511], "fixing_code_end_loc": [323, 527], "type": "CWE-863", "message": "Discourse is an open source discussion platform. Versions prior to 2.7.13 in `stable`, 2.8.0.beta11 in `beta`, and 2.8.0.beta11 in `tests-passed` allow some users to log in to a community before they should be able to do so. A user invited via email to a forum with `must_approve_users` enabled is going to be automatically logged in, bypassing the check that does not allow unapproved users to sign in. They will be able to do everything an approved user can do. If they logout, they cannot log back in. This issue is patched in the `stable` version 2.7.13, `beta` version 2.8.0.beta11, and `tests-passed` version 2.8.0.beta11. One may disable invites as a workaround. Administrators can increase `min_trust_level_to_allow_invite` to reduce the attack surface to more trusted users.", "other": {"cve": {"id": "CVE-2022-21684", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-13T21:15:08.747", "lastModified": "2022-01-24T19:11:16.497", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source discussion platform. Versions prior to 2.7.13 in `stable`, 2.8.0.beta11 in `beta`, and 2.8.0.beta11 in `tests-passed` allow some users to log in to a community before they should be able to do so. A user invited via email to a forum with `must_approve_users` enabled is going to be automatically logged in, bypassing the check that does not allow unapproved users to sign in. They will be able to do everything an approved user can do. If they logout, they cannot log back in. This issue is patched in the `stable` version 2.7.13, `beta` version 2.8.0.beta11, and `tests-passed` version 2.8.0.beta11. One may disable invites as a workaround. Administrators can increase `min_trust_level_to_allow_invite` to reduce the attack surface to more trusted users."}, {"lang": "es", "value": "Discourse es una plataforma de debate de c\u00f3digo abierto. Las versiones anteriores a 2.7.13 en \"stable\", a la 2.8.0.beta11 en \"beta\" y a la 2.8.0.beta11 en \"tests-passed\" permiten a algunos usuarios iniciar sesi\u00f3n en una comunidad antes de lo que deber\u00edan. Un usuario invitado por medio de un correo electr\u00f3nico a un foro con \"must_approve_users\" habilitado va a entrar autom\u00e1ticamente, omitiendo la comprobaci\u00f3n que no permite a usuarios no aprobados entrar. Podr\u00e1n hacer todo lo que un usuario aprobado puede hacer. Si cierran la sesi\u00f3n, no podr\u00e1n volver a entrar. Este problema est\u00e1 parcheado en las versiones \"stable\" 2.7.13, \"beta\" 2.8.0.beta11 y \"tests-passed\" 2.8.0.beta11. Pueden deshabilitarse las invitaciones como soluci\u00f3n. Los administradores pueden aumentar \"min_trust_level_to_allow_invite\" para reducir la superficie de ataque a los usuarios de mayor confianza"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.13", "matchCriteriaId": "131D6FC3-2C60-4524-9B4E-F8316312A606"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "9E7F8AC4-35D1-45E5-8A3A-B0205000A5D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "7A24507D-6D4B-4992-BCFE-232AF3BFCC30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "B9AE12FE-0396-4843-8D30-D8C44FAE01DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "F101AEAB-4FB7-4BE3-931B-595702D616C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "F6878B7F-2691-4D3F-8116-CB282FDAAAC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "76EABAB9-BEA4-48D4-ADBA-D00746B29C52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "82A255A2-4658-41AD-A4DE-A7F8D018028D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "E5804585-2EA4-4677-8EC1-5F561D5C7D7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "082A6871-080A-4AA7-AF4A-D664EA46488A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "8A280205-A2DC-4E30-937B-5564C779FD5A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/584c6a2e8bc705072b09a9c4b55126d6f8ed4ad2", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-p63q-jp48-h8xh", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://meta.discourse.org/t/invite-redemption-allowed-user-to-access-forum-before-approval/214328", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/584c6a2e8bc705072b09a9c4b55126d6f8ed4ad2"}}