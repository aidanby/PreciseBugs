{"buggy_code": ["# standard module for determining whether a given hostname or IP has access to\n# the requested resource\n\nrequire 'ipaddr'\nrequire 'puppet/util/logging'\n\nmodule Puppet\n  class AuthStoreError < Puppet::Error; end\n  class AuthorizationError < Puppet::Error; end\n\n  class Network::AuthStore\n    include Puppet::Util::Logging\n\n    # Mark a given pattern as allowed.\n    def allow(pattern)\n      # a simple way to allow anyone at all to connect\n      if pattern == \"*\"\n        @globalallow = true\n      else\n        store(:allow, pattern)\n      end\n\n      nil\n    end\n\n    # Is a given combination of name and ip address allowed?  If either input\n    # is non-nil, then both inputs must be provided.  If neither input\n    # is provided, then the authstore is considered local and defaults to \"true\".\n    def allowed?(name, ip)\n      if name or ip\n        # This is probably unnecessary, and can cause some weirdnesses in\n        # cases where we're operating over localhost but don't have a real\n        # IP defined.\n        raise Puppet::DevError, \"Name and IP must be passed to 'allowed?'\" unless name and ip\n        # else, we're networked and such\n      else\n        # we're local\n        return true\n      end\n\n      # yay insecure overrides\n      return true if globalallow?\n\n      if decl = declarations.find { |d| d.match?(name, ip) }\n        return decl.result\n      end\n\n      info \"defaulting to no access for #{name}\"\n      false\n    end\n\n    # Deny a given pattern.\n    def deny(pattern)\n      store(:deny, pattern)\n    end\n\n    # Is global allow enabled?\n    def globalallow?\n      @globalallow\n    end\n\n    # does this auth store has any rules?\n    def empty?\n      @globalallow.nil? && @declarations.size == 0\n    end\n\n    def initialize\n      @globalallow = nil\n      @declarations = []\n    end\n\n    def to_s\n      \"authstore\"\n    end\n\n    def interpolate(match)\n      Thread.current[:declarations] = @declarations.collect { |ace| ace.interpolate(match) }.sort\n    end\n\n    def reset_interpolation\n      Thread.current[:declarations] = nil\n    end\n\n    private\n\n    # returns our ACEs list, but if we have a modification of it\n    # in our current thread, let's return it\n    # this is used if we want to override the this purely immutable list\n    # by a modified version in a multithread safe way.\n    def declarations\n      Thread.current[:declarations] || @declarations\n    end\n\n    # Store the results of a pattern into our hash.  Basically just\n    # converts the pattern and sticks it into the hash.\n    def store(type, pattern)\n      @declarations << Declaration.new(type, pattern)\n      @declarations.sort!\n\n      nil\n    end\n\n    # A single declaration.  Stores the info for a given declaration,\n    # provides the methods for determining whether a declaration matches,\n    # and handles sorting the declarations appropriately.\n    class Declaration\n      include Puppet::Util\n      include Comparable\n\n      # The type of declaration: either :allow or :deny\n      attr_reader :type\n\n      # The name: :ip or :domain\n      attr_accessor :name\n\n      # The pattern we're matching against.  Can be an IPAddr instance,\n      # or an array of strings, resulting from reversing a hostname\n      # or domain name.\n      attr_reader :pattern\n\n      # The length.  Only used for iprange and domain.\n      attr_accessor :length\n\n      # Sort the declarations most specific first.\n      def <=>(other)\n        compare(exact?, other.exact?) ||\n        compare(ip?, other.ip?)  ||\n        ((length != other.length) &&  (other.length <=> length)) ||\n        compare(deny?, other.deny?) ||\n        ( ip? ? pattern.to_s <=> other.pattern.to_s : pattern <=> other.pattern)\n      end\n\n      def deny?\n        type == :deny\n      end\n\n      def exact?\n        @exact == :exact\n      end\n\n      def initialize(type, pattern)\n        self.type = type\n        self.pattern = pattern\n      end\n\n      # Are we an IP type?\n      def ip?\n        name == :ip\n      end\n\n      # Does this declaration match the name/ip combo?\n      def match?(name, ip)\n        ip? ? pattern.include?(IPAddr.new(ip)) : matchname?(name)\n      end\n\n      # Set the pattern appropriately.  Also sets the name and length.\n      def pattern=(pattern)\n        parse(pattern)\n        @orig = pattern\n      end\n\n      # Mapping a type of statement into a return value.\n      def result\n        type == :allow\n      end\n\n      def to_s\n        \"#{type}: #{pattern}\"\n      end\n\n      # Set the declaration type.  Either :allow or :deny.\n      def type=(type)\n        type = symbolize(type)\n        raise ArgumentError, \"Invalid declaration type #{type}\" unless [:allow, :deny].include?(type)\n        @type = type\n      end\n\n      # interpolate a pattern to replace any\n      # backreferences by the given match\n      # for instance if our pattern is $1.reductivelabs.com\n      # and we're called with a MatchData whose capture 1 is puppet\n      # we'll return a pattern of puppet.reductivelabs.com\n      def interpolate(match)\n        clone = dup\n        if @name == :dynamic\n          clone.pattern = clone.pattern.reverse.collect do |p|\n            p.gsub(/\\$(\\d)/) { |m| match[$1.to_i] }\n          end.join(\".\")\n        end\n        clone\n      end\n\n      private\n\n      # Returns nil if both values are true or both are false, returns\n      # -1 if the first is true, and 1 if the second is true.  Used\n      # in the <=> operator.\n      def compare(me, them)\n        (me and them) ? nil : me ? -1 : them ? 1 : nil\n      end\n\n      # Does the name match our pattern?\n      def matchname?(name)\n        case @name\n          when :domain, :dynamic, :opaque\n            name = munge_name(name)\n            (pattern == name) or (not exact? and pattern.zip(name).all? { |p,n| p == n })\n          when :regex\n            Regexp.new(pattern.slice(1..-2)).match(name)\n        end\n      end\n\n      # Convert the name to a common pattern.\n      def munge_name(name)\n        # LAK:NOTE http://snurl.com/21zf8  [groups_google_com]\n        # Change to name.downcase.split(\".\",-1).reverse for FQDN support\n        name.downcase.split(\".\").reverse\n      end\n\n      # Parse our input pattern and figure out what kind of allowal\n      # statement it is.  The output of this is used for later matching.\n      Octet = '(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])'\n      IPv4 = \"#{Octet}\\.#{Octet}\\.#{Octet}\\.#{Octet}\"\n      IPv6_full    = \"_:_:_:_:_:_:_:_|_:_:_:_:_:_::_?|_:_:_:_:_::((_:)?_)?|_:_:_:_::((_:){0,2}_)?|_:_:_::((_:){0,3}_)?|_:_::((_:){0,4}_)?|_::((_:){0,5}_)?|::((_:){0,6}_)?\"\n      IPv6_partial = \"_:_:_:_:_:_:|_:_:_:_::(_:)?|_:_::(_:){0,2}|_::(_:){0,3}\"\n      # It should be:\n      #     IP = \"#{IPv4}|#{IPv6_full}|(#{IPv6_partial}#{IPv4})\".gsub(/_/,'([0-9a-fA-F]{1,4})').gsub(/\\(/,'(?:')\n      # but ruby's ipaddr lib doesn't support the hybrid format\n      IP = \"#{IPv4}|#{IPv6_full}\".gsub(/_/,'([0-9a-fA-F]{1,4})').gsub(/\\(/,'(?:')\n      def parse(value)\n        @name,@exact,@length,@pattern = *case value\n        when /^(?:#{IP})\\/(\\d+)$/                                   # 12.34.56.78/24, a001:b002::efff/120, c444:1000:2000::9:192.168.0.1/112\n          [:ip,:inexact,$1.to_i,IPAddr.new(value)]\n        when /^(#{IP})$/                                          # 10.20.30.40,\n          [:ip,:exact,nil,IPAddr.new(value)]\n        when /^(#{Octet}\\.){1,3}\\*$/                              # an ip address with a '*' at the end\n          segments = value.split(\".\")[0..-2]\n          bits = 8*segments.length\n          [:ip,:inexact,bits,IPAddr.new((segments+[0,0,0])[0,4].join(\".\") + \"/#{bits}\")]\n        when /^(\\w[-\\w]*\\.)+[-\\w]+$/                              # a full hostname\n          # Change to /^(\\w[-\\w]*\\.)+[-\\w]+\\.?$/ for FQDN support\n          [:domain,:exact,nil,munge_name(value)]\n        when /^\\*(\\.(\\w[-\\w]*)){1,}$/                             # *.domain.com\n          host_sans_star = munge_name(value)[0..-2]\n          [:domain,:inexact,host_sans_star.length,host_sans_star]\n        when /\\$\\d+/                                              # a backreference pattern ala $1.reductivelabs.com or 192.168.0.$1 or $1.$2\n          [:dynamic,:exact,nil,munge_name(value)]\n        when /^\\w[-.@\\w]*$/                                       # ? Just like a host name but allow '@'s and ending '.'s\n          [:opaque,:exact,nil,[value]]\n        when /^\\/.*\\/$/                                           # a regular expression\n          [:regex,:inexact,nil,value]\n        else\n          raise AuthStoreError, \"Invalid pattern #{value}\"\n        end\n      end\n    end\n  end\nend\n\n", "require 'spec_helper'\n\nrequire 'puppet/network/rest_authconfig'\n\nRSpec::Matchers.define :allow do |params|\n\n  match do |auth|\n    begin\n      auth.check_authorization(params[0], params[1], params[2], params[3])\n      true\n    rescue Puppet::Network::AuthorizationError\n      false\n    end\n  end\n\n  failure_message_for_should do |instance|\n    \"expected #{params[3][:node]}/#{params[3][:ip]} to be allowed\"\n  end\n\n  failure_message_for_should_not do |instance|\n    \"expected #{params[3][:node]}/#{params[3][:ip]} to be forbidden\"\n  end\nend\n\ndescribe Puppet::Network::RestAuthConfig do\n  include PuppetSpec::Files\n\n  before(:each) do\n    Puppet[:rest_authconfig] = tmpfile('auth.conf')\n  end\n\n  def add_rule(rule)\n    File.open(Puppet[:rest_authconfig],\"w+\") do |f|\n      f.print \"path /test\\n#{rule}\\n\"\n    end\n    @auth = Puppet::Network::RestAuthConfig.new(Puppet[:rest_authconfig], true)\n  end\n\n  def add_regex_rule(regex, rule)\n    File.open(Puppet[:rest_authconfig],\"w+\") do |f|\n      f.print \"path ~ #{regex}\\n#{rule}\\n\"\n    end\n    @auth = Puppet::Network::RestAuthConfig.new(Puppet[:rest_authconfig], true)\n  end\n\n  def request(args = {})\n    { :ip => '10.1.1.1', :node => 'host.domain.com', :key => 'key', :authenticated => true }.each do |k,v|\n      args[k] ||= v\n    end\n    ['test', :find, args[:key], args]\n  end\n\n  it \"should support IPv4 address\" do\n    add_rule(\"allow 10.1.1.1\")\n\n    @auth.should allow(request)\n  end\n\n  it \"should support CIDR IPv4 address\" do\n    add_rule(\"allow 10.0.0.0/8\")\n\n    @auth.should allow(request)\n  end\n\n  it \"should support wildcard IPv4 address\" do\n    add_rule(\"allow 10.1.1.*\")\n\n    @auth.should allow(request)\n  end\n\n  it \"should support IPv6 address\" do\n    add_rule(\"allow 2001:DB8::8:800:200C:417A\")\n\n    @auth.should allow(request(:ip => '2001:DB8::8:800:200C:417A'))\n  end\n\n  it \"should support hostname\" do\n    add_rule(\"allow host.domain.com\")\n\n    @auth.should allow(request)\n  end\n\n  it \"should support wildcard host\" do\n    add_rule(\"allow *.domain.com\")\n\n    @auth.should allow(request)\n  end\n\n  it \"should support hostname backreferences\" do\n    add_regex_rule('^/test/([^/]+)$', \"allow $1.domain.com\")\n\n    @auth.should allow(request(:key => 'host'))\n  end\n\n  it \"should support opaque strings\" do\n    add_rule(\"allow this-is-opaque@or-not\")\n\n    @auth.should allow(request(:node => 'this-is-opaque@or-not'))\n  end\n\n  it \"should support opaque strings and backreferences\" do\n    add_regex_rule('^/test/([^/]+)$', \"allow $1\")\n\n    @auth.should allow(request(:key => 'this-is-opaque@or-not', :node => 'this-is-opaque@or-not'))\n  end\n\n  it \"should support hostname ending with '.'\" do\n    pending('bug #7589')\n    add_rule(\"allow host.domain.com.\")\n\n    @auth.should allow(request(:node => 'host.domain.com.'))\n  end\n\n  it \"should support hostname ending with '.' and backreferences\" do\n    pending('bug #7589')\n    add_regex_rule('^/test/([^/]+)$',\"allow $1\")\n\n    @auth.should allow(request(:node => 'host.domain.com.'))\n  end\n\n  it \"should support trailing whitespace\" do\n    add_rule('allow host.domain.com    ')\n\n    @auth.should allow(request)\n  end\n\n  it \"should support inlined comments\" do\n    add_rule('allow host.domain.com # will it work?')\n\n    @auth.should allow(request)\n  end\n\n  it \"should deny non-matching host\" do\n    add_rule(\"allow inexistant\")\n\n    @auth.should_not allow(request)\n  end\n\n  it \"should deny denied hosts\" do\n    add_rule(\"deny host.domain.com\")\n\n    @auth.should_not allow(request)\n  end\n\nend\n"], "fixing_code": ["# standard module for determining whether a given hostname or IP has access to\n# the requested resource\n\nrequire 'ipaddr'\nrequire 'puppet/util/logging'\n\nmodule Puppet\n  class AuthStoreError < Puppet::Error; end\n  class AuthorizationError < Puppet::Error; end\n\n  class Network::AuthStore\n    include Puppet::Util::Logging\n\n    # Mark a given pattern as allowed.\n    def allow(pattern)\n      # a simple way to allow anyone at all to connect\n      if pattern == \"*\"\n        @globalallow = true\n      else\n        store(:allow, pattern)\n      end\n\n      nil\n    end\n\n    # Is a given combination of name and ip address allowed?  If either input\n    # is non-nil, then both inputs must be provided.  If neither input\n    # is provided, then the authstore is considered local and defaults to \"true\".\n    def allowed?(name, ip)\n      if name or ip\n        # This is probably unnecessary, and can cause some weirdnesses in\n        # cases where we're operating over localhost but don't have a real\n        # IP defined.\n        raise Puppet::DevError, \"Name and IP must be passed to 'allowed?'\" unless name and ip\n        # else, we're networked and such\n      else\n        # we're local\n        return true\n      end\n\n      # yay insecure overrides\n      return true if globalallow?\n\n      if decl = declarations.find { |d| d.match?(name, ip) }\n        return decl.result\n      end\n\n      info \"defaulting to no access for #{name}\"\n      false\n    end\n\n    # Deny a given pattern.\n    def deny(pattern)\n      store(:deny, pattern)\n    end\n\n    # Is global allow enabled?\n    def globalallow?\n      @globalallow\n    end\n\n    # does this auth store has any rules?\n    def empty?\n      @globalallow.nil? && @declarations.size == 0\n    end\n\n    def initialize\n      @globalallow = nil\n      @declarations = []\n    end\n\n    def to_s\n      \"authstore\"\n    end\n\n    def interpolate(match)\n      Thread.current[:declarations] = @declarations.collect { |ace| ace.interpolate(match) }.sort\n    end\n\n    def reset_interpolation\n      Thread.current[:declarations] = nil\n    end\n\n    private\n\n    # returns our ACEs list, but if we have a modification of it\n    # in our current thread, let's return it\n    # this is used if we want to override the this purely immutable list\n    # by a modified version in a multithread safe way.\n    def declarations\n      Thread.current[:declarations] || @declarations\n    end\n\n    # Store the results of a pattern into our hash.  Basically just\n    # converts the pattern and sticks it into the hash.\n    def store(type, pattern)\n      @declarations << Declaration.new(type, pattern)\n      @declarations.sort!\n\n      nil\n    end\n\n    # A single declaration.  Stores the info for a given declaration,\n    # provides the methods for determining whether a declaration matches,\n    # and handles sorting the declarations appropriately.\n    class Declaration\n      include Puppet::Util\n      include Comparable\n\n      # The type of declaration: either :allow or :deny\n      attr_reader :type\n\n      # The name: :ip or :domain\n      attr_accessor :name\n\n      # The pattern we're matching against.  Can be an IPAddr instance,\n      # or an array of strings, resulting from reversing a hostname\n      # or domain name.\n      attr_reader :pattern\n\n      # The length.  Only used for iprange and domain.\n      attr_accessor :length\n\n      # Sort the declarations most specific first.\n      def <=>(other)\n        compare(exact?, other.exact?) ||\n        compare(ip?, other.ip?)  ||\n        ((length != other.length) &&  (other.length <=> length)) ||\n        compare(deny?, other.deny?) ||\n        ( ip? ? pattern.to_s <=> other.pattern.to_s : pattern <=> other.pattern)\n      end\n\n      def deny?\n        type == :deny\n      end\n\n      def exact?\n        @exact == :exact\n      end\n\n      def initialize(type, pattern)\n        self.type = type\n        self.pattern = pattern\n      end\n\n      # Are we an IP type?\n      def ip?\n        name == :ip\n      end\n\n      # Does this declaration match the name/ip combo?\n      def match?(name, ip)\n        if ip?\n          if pattern.include?(IPAddr.new(ip))\n            Puppet.deprecation_warning \"Authentication based on IP address is deprecated; please use certname-based rules instead\"\n            true\n          else\n            false\n          end\n        else\n          matchname?(name)\n        end\n      end\n\n      # Set the pattern appropriately.  Also sets the name and length.\n      def pattern=(pattern)\n        parse(pattern)\n        @orig = pattern\n      end\n\n      # Mapping a type of statement into a return value.\n      def result\n        type == :allow\n      end\n\n      def to_s\n        \"#{type}: #{pattern}\"\n      end\n\n      # Set the declaration type.  Either :allow or :deny.\n      def type=(type)\n        type = symbolize(type)\n        raise ArgumentError, \"Invalid declaration type #{type}\" unless [:allow, :deny].include?(type)\n        @type = type\n      end\n\n      # interpolate a pattern to replace any\n      # backreferences by the given match\n      # for instance if our pattern is $1.reductivelabs.com\n      # and we're called with a MatchData whose capture 1 is puppet\n      # we'll return a pattern of puppet.reductivelabs.com\n      def interpolate(match)\n        clone = dup\n        if @name == :dynamic\n          clone.pattern = clone.pattern.reverse.collect do |p|\n            p.gsub(/\\$(\\d)/) { |m| match[$1.to_i] }\n          end.join(\".\")\n        end\n        clone\n      end\n\n      private\n\n      # Returns nil if both values are true or both are false, returns\n      # -1 if the first is true, and 1 if the second is true.  Used\n      # in the <=> operator.\n      def compare(me, them)\n        (me and them) ? nil : me ? -1 : them ? 1 : nil\n      end\n\n      # Does the name match our pattern?\n      def matchname?(name)\n        case @name\n          when :domain, :dynamic, :opaque\n            name = munge_name(name)\n            (pattern == name) or (not exact? and pattern.zip(name).all? { |p,n| p == n })\n          when :regex\n            Regexp.new(pattern.slice(1..-2)).match(name)\n        end\n      end\n\n      # Convert the name to a common pattern.\n      def munge_name(name)\n        # Change to name.downcase.split(\".\",-1).reverse for FQDN support\n        name.downcase.split(\".\").reverse\n      end\n\n      # Parse our input pattern and figure out what kind of allowal\n      # statement it is.  The output of this is used for later matching.\n      Octet = '(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])'\n      IPv4 = \"#{Octet}\\.#{Octet}\\.#{Octet}\\.#{Octet}\"\n      IPv6_full    = \"_:_:_:_:_:_:_:_|_:_:_:_:_:_::_?|_:_:_:_:_::((_:)?_)?|_:_:_:_::((_:){0,2}_)?|_:_:_::((_:){0,3}_)?|_:_::((_:){0,4}_)?|_::((_:){0,5}_)?|::((_:){0,6}_)?\"\n      IPv6_partial = \"_:_:_:_:_:_:|_:_:_:_::(_:)?|_:_::(_:){0,2}|_::(_:){0,3}\"\n      # It should be:\n      #     IP = \"#{IPv4}|#{IPv6_full}|(#{IPv6_partial}#{IPv4})\".gsub(/_/,'([0-9a-fA-F]{1,4})').gsub(/\\(/,'(?:')\n      # but ruby's ipaddr lib doesn't support the hybrid format\n      IP = \"#{IPv4}|#{IPv6_full}\".gsub(/_/,'([0-9a-fA-F]{1,4})').gsub(/\\(/,'(?:')\n      def parse(value)\n        @name,@exact,@length,@pattern = *case value\n        when /^(?:#{IP})\\/(\\d+)$/                                   # 12.34.56.78/24, a001:b002::efff/120, c444:1000:2000::9:192.168.0.1/112\n          [:ip,:inexact,$1.to_i,IPAddr.new(value)]\n        when /^(#{IP})$/                                          # 10.20.30.40,\n          [:ip,:exact,nil,IPAddr.new(value)]\n        when /^(#{Octet}\\.){1,3}\\*$/                              # an ip address with a '*' at the end\n          segments = value.split(\".\")[0..-2]\n          bits = 8*segments.length\n          [:ip,:inexact,bits,IPAddr.new((segments+[0,0,0])[0,4].join(\".\") + \"/#{bits}\")]\n        when /^(\\w[-\\w]*\\.)+[-\\w]+$/                              # a full hostname\n          # Change to /^(\\w[-\\w]*\\.)+[-\\w]+\\.?$/ for FQDN support\n          [:domain,:exact,nil,munge_name(value)]\n        when /^\\*(\\.(\\w[-\\w]*)){1,}$/                             # *.domain.com\n          host_sans_star = munge_name(value)[0..-2]\n          [:domain,:inexact,host_sans_star.length,host_sans_star]\n        when /\\$\\d+/                                              # a backreference pattern ala $1.reductivelabs.com or 192.168.0.$1 or $1.$2\n          [:dynamic,:exact,nil,munge_name(value)]\n        when /^\\w[-.@\\w]*$/                                       # ? Just like a host name but allow '@'s and ending '.'s\n          [:opaque,:exact,nil,[value]]\n        when /^\\/.*\\/$/                                           # a regular expression\n          [:regex,:inexact,nil,value]\n        else\n          raise AuthStoreError, \"Invalid pattern #{value}\"\n        end\n      end\n    end\n  end\nend\n\n", "require 'spec_helper'\n\nrequire 'puppet/network/rest_authconfig'\n\nRSpec::Matchers.define :allow do |params|\n\n  match do |auth|\n    begin\n      auth.check_authorization(params[0], params[1], params[2], params[3])\n      true\n    rescue Puppet::Network::AuthorizationError\n      false\n    end\n  end\n\n  failure_message_for_should do |instance|\n    \"expected #{params[3][:node]}/#{params[3][:ip]} to be allowed\"\n  end\n\n  failure_message_for_should_not do |instance|\n    \"expected #{params[3][:node]}/#{params[3][:ip]} to be forbidden\"\n  end\nend\n\ndescribe Puppet::Network::RestAuthConfig do\n  include PuppetSpec::Files\n\n  before(:each) do\n    Puppet[:rest_authconfig] = tmpfile('auth.conf')\n  end\n\n  def add_rule(rule)\n    File.open(Puppet[:rest_authconfig],\"w+\") do |f|\n      f.print \"path /test\\n#{rule}\\n\"\n    end\n    @auth = Puppet::Network::RestAuthConfig.new(Puppet[:rest_authconfig], true)\n  end\n\n  def add_regex_rule(regex, rule)\n    File.open(Puppet[:rest_authconfig],\"w+\") do |f|\n      f.print \"path ~ #{regex}\\n#{rule}\\n\"\n    end\n    @auth = Puppet::Network::RestAuthConfig.new(Puppet[:rest_authconfig], true)\n  end\n\n  def request(args = {})\n    args = {\n      :key => 'key',\n      :node => 'host.domain.com',\n      :ip => '10.1.1.1',\n      :authenticated => true\n    }.merge(args)\n    ['test', :find, args[:key], args]\n  end\n\n  it \"should warn when matching against IP addresses\" do\n    add_rule(\"allow 10.1.1.1\")\n\n    @auth.should allow(request)\n\n    @logs.should be_any {|log| log.level == :warning and log.message =~ /Authentication based on IP address is deprecated/}\n  end\n\n  it \"should not warn when matches against IP addresses fail\" do\n    add_rule(\"allow 10.1.1.2\")\n\n    @auth.should_not allow(request)\n\n    @logs.should_not be_any {|log| log.level == :warning and log.message =~ /Authentication based on IP address is deprecated/}\n  end\n\n  it \"should support IPv4 address\" do\n    add_rule(\"allow 10.1.1.1\")\n\n    @auth.should allow(request)\n  end\n\n  it \"should support CIDR IPv4 address\" do\n    add_rule(\"allow 10.0.0.0/8\")\n\n    @auth.should allow(request)\n  end\n\n  it \"should support wildcard IPv4 address\" do\n    add_rule(\"allow 10.1.1.*\")\n\n    @auth.should allow(request)\n  end\n\n  it \"should support IPv6 address\" do\n    add_rule(\"allow 2001:DB8::8:800:200C:417A\")\n\n    @auth.should allow(request(:ip => '2001:DB8::8:800:200C:417A'))\n  end\n\n  it \"should support hostname\" do\n    add_rule(\"allow host.domain.com\")\n\n    @auth.should allow(request)\n  end\n\n  it \"should support wildcard host\" do\n    add_rule(\"allow *.domain.com\")\n\n    @auth.should allow(request)\n  end\n\n  it \"should support hostname backreferences\" do\n    add_regex_rule('^/test/([^/]+)$', \"allow $1.domain.com\")\n\n    @auth.should allow(request(:key => 'host'))\n  end\n\n  it \"should support opaque strings\" do\n    add_rule(\"allow this-is-opaque@or-not\")\n\n    @auth.should allow(request(:node => 'this-is-opaque@or-not'))\n  end\n\n  it \"should support opaque strings and backreferences\" do\n    add_regex_rule('^/test/([^/]+)$', \"allow $1\")\n\n    @auth.should allow(request(:key => 'this-is-opaque@or-not', :node => 'this-is-opaque@or-not'))\n  end\n\n  it \"should support hostname ending with '.'\" do\n    pending('bug #7589')\n    add_rule(\"allow host.domain.com.\")\n\n    @auth.should allow(request(:node => 'host.domain.com.'))\n  end\n\n  it \"should support hostname ending with '.' and backreferences\" do\n    pending('bug #7589')\n    add_regex_rule('^/test/([^/]+)$',\"allow $1\")\n\n    @auth.should allow(request(:node => 'host.domain.com.'))\n  end\n\n  it \"should support trailing whitespace\" do\n    add_rule('allow host.domain.com    ')\n\n    @auth.should allow(request)\n  end\n\n  it \"should support inlined comments\" do\n    add_rule('allow host.domain.com # will it work?')\n\n    @auth.should allow(request)\n  end\n\n  it \"should deny non-matching host\" do\n    add_rule(\"allow inexistant\")\n\n    @auth.should_not allow(request)\n  end\n\n  it \"should deny denied hosts\" do\n    add_rule(\"deny host.domain.com\")\n\n    @auth.should_not allow(request)\n  end\n\nend\n"], "filenames": ["lib/puppet/network/authstore.rb", "spec/integration/network/rest_authconfig_spec.rb"], "buggy_code_start_loc": [153, 47], "buggy_code_end_loc": [216, 50], "fixing_code_start_loc": [153, 47], "fixing_code_end_loc": [223, 70], "type": "CWE-287", "message": "lib/puppet/network/authstore.rb in Puppet before 2.7.18, and Puppet Enterprise before 2.5.2, supports use of IP addresses in certnames without warning of potential risks, which might allow remote attackers to spoof an agent by acquiring a previously used IP address.", "other": {"cve": {"id": "CVE-2012-3408", "sourceIdentifier": "secalert@redhat.com", "published": "2012-08-06T16:55:05.133", "lastModified": "2022-01-24T16:46:02.250", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lib/puppet/network/authstore.rb in Puppet before 2.7.18, and Puppet Enterprise before 2.5.2, supports use of IP addresses in certnames without warning of potential risks, which might allow remote attackers to spoof an agent by acquiring a previously used IP address."}, {"lang": "es", "value": "lib/puppet/network/authstore.rb en Puppet anterior a v2.7.18, y Puppet Enterprise anterior a v2.5.2, compatible con el uso de direcciones IP en certnames sin previo aviso de los riesgos potenciales, podr\u00edan permitir a atacantes remotos falsificar un agente mediante la adquisici\u00f3n de una direcci\u00f3n IP previamente utilizada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet_enterprise:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.2", "matchCriteriaId": "346F9C04-73F0-4244-9086-C16C981C92D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppetlabs:puppet:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.18", "matchCriteriaId": "05782A68-DC7C-49D0-847A-F64A5C9F7DDB"}]}]}], "references": [{"url": "http://puppetlabs.com/security/cve/cve-2012-3408/", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=839166", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/puppetlabs/puppet/commit/ab9150baa1b738467a33b01df1d90e076253fbbd", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/puppetlabs/puppet/commit/ab9150baa1b738467a33b01df1d90e076253fbbd"}}