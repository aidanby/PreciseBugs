{"buggy_code": ["'use strict';\n\nconst xml2js = require('xml2js');\n\nconst DEFAULT_TYPES = ['*/xml', '+xml'];\n\nmodule.exports = function (bodyParser) {\n  if (bodyParser.xml) {\n    // We already setup the XML parser.\n    // End early.\n    return;\n  }\n\n  function xml(options) {\n    options = options || {};\n\n    options.type = options.type || DEFAULT_TYPES;\n\n    const textParser = bodyParser.text(options);\n    return function xmlParser(req, res, next) {\n      // First, run the body through the text parser.\n      textParser(req, res, function (err) {\n        if (err) {\n          return next(err);\n        }\n        if (typeof req.body !== 'string') {\n          return next();\n        }\n\n        // Then, parse as XML.\n        const xmlParseOptions = {\n          ...options.xmlParseOptions,\n          // Always opt-in to async mode.\n          async: true,\n        };\n        const parser = new xml2js.Parser(xmlParseOptions);\n\n        // In some cases xml2js.Parser parseString() can throw an error after executing the callback.\n\n        parser.parseString(req.body, function (err, xml) {\n          if (err) {\n            err.status = 400;\n            return next(err);\n          }\n\n          req.body = xml || req.body;\n          next();\n        });\n      });\n    };\n  }\n\n  // Finally add the `xml` function to the bodyParser.\n  Object.defineProperty(bodyParser, 'xml', {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      return xml;\n    },\n  });\n};\n", "'use strict';\n\nconst express = require('express'),\n  request = require('supertest'),\n  bodyParser = require('body-parser');\n\n// Add xml parsing to bodyParser.\n// In real-life you'd `require('body-parser-xml')`.\nrequire('./index.js')(bodyParser);\n\ndescribe('XML Body Parser', function () {\n  let app;\n\n  const createServer = function (options) {\n    app = express();\n    app.set('env', 'test');\n    app.use(bodyParser.xml(options));\n    app.post('/', function (req, res) {\n      res.status(200).send({ parsed: req.body });\n    });\n  };\n\n  beforeEach(function () {\n    app = null;\n  });\n\n  it('should parse a body with content-type application/xml', function (done) {\n    createServer();\n\n    request(app)\n      .post('/')\n      .set('Content-Type', 'application/xml')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should parse a body with content-type text/xml', function (done) {\n    createServer();\n\n    request(app)\n      .post('/')\n      .set('Content-Type', 'text/xml')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should parse a body with content-type application/rss+xml', function (done) {\n    createServer();\n\n    request(app)\n      .post('/')\n      .set('Content-Type', 'application/rss+xml')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should accept xmlParseOptions', function (done) {\n    createServer({\n      xmlParseOptions: {\n        normalize: true, // Trim whitespace inside text nodes\n        normalizeTags: true, // Transform tags to lowercase\n        explicitArray: false, // Only put nodes in array if >1\n      },\n    });\n    request(app)\n      .post('/')\n      .set('Content-Type', 'text/xml')\n      .send('<CUSTOMER><name>Bob</name></CUSTOMER>')\n      .expect(200, { parsed: { customer: { name: 'Bob' } } }, done);\n  });\n\n  it('should accept custom ContentType as array', function (done) {\n    createServer({\n      type: ['application/custom-xml-type'],\n    });\n    request(app)\n      .post('/')\n      .set('Content-Type', 'application/custom-xml-type')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should accept custom ContentType as string', function (done) {\n    createServer({\n      type: 'application/custom-xml-type',\n    });\n    request(app)\n      .post('/')\n      .set('Content-Type', 'application/custom-xml-type')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should accept custom ContentType as function', function (done) {\n    createServer({\n      type: function () {\n        return true;\n      },\n    });\n    request(app)\n      .post('/')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should ignore non-XML', function (done) {\n    createServer();\n    request(app)\n      .post('/')\n      .set('Content-Type', 'text/plain')\n      .send('Customer name: Bob')\n      .expect(200, { parsed: {} }, done);\n  });\n\n  it('should reject invalid XML', function (done) {\n    createServer();\n    request(app)\n      .post('/')\n      .set('Content-Type', 'text/xml')\n      .send('<invalid-xml>')\n      .expect(400, done);\n  });\n\n  it('should not throw an exception after the callback is returned', function (done) {\n    // Guards against https://github.com/Leonidas-from-XIV/node-xml2js/issues/400\n    createServer();\n    request(app)\n      .post('/')\n      .set('Content-Type', 'text/xml')\n      .send('x<foo>test</foo><bar>test</bar></data>')\n      .expect(400, done);\n  });\n});\n"], "fixing_code": ["'use strict';\n\nconst xml2js = require('xml2js');\n\nconst DEFAULT_TYPES = ['*/xml', '+xml'];\n\nmodule.exports = function (bodyParser) {\n  if (bodyParser.xml) {\n    // We already setup the XML parser.\n    // End early.\n    return;\n  }\n\n  function xml(options) {\n    options = options || {};\n\n    options.type = options.type || DEFAULT_TYPES;\n\n    const textParser = bodyParser.text(options);\n    return function xmlParser(req, res, next) {\n      // First, run the body through the text parser.\n      textParser(req, res, function (err) {\n        if (err) {\n          return next(err);\n        }\n        if (typeof req.body !== 'string') {\n          return next();\n        }\n\n        // Then, parse as XML.\n        const xmlParseOptions = {\n          ...options.xmlParseOptions,\n          // Always opt-in to async mode.\n          async: true,\n        };\n        const parser = new xml2js.Parser(xmlParseOptions);\n\n        // In some cases xml2js.Parser parseString() can throw an error after executing the callback.\n\n        parser.parseString(req.body, function (err, xml) {\n          if (err) {\n            err.status = 400;\n            return next(err);\n          }\n\n          if (xml) {\n            // Guard against prototype pollution\n            delete xml.__proto__;\n            delete xml.constructor;\n            delete xml.prototype;\n\n            // Set result on the request body\n            req.body = xml;\n          }\n\n          next();\n        });\n      });\n    };\n  }\n\n  // Finally add the `xml` function to the bodyParser.\n  Object.defineProperty(bodyParser, 'xml', {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      return xml;\n    },\n  });\n};\n", "'use strict';\n\nconst express = require('express'),\n  request = require('supertest'),\n  bodyParser = require('body-parser');\n\n// Add xml parsing to bodyParser.\n// In real-life you'd `require('body-parser-xml')`.\nrequire('./index.js')(bodyParser);\n\ndescribe('XML Body Parser', function () {\n  let app;\n\n  const createServer = function (options) {\n    app = express();\n    app.set('env', 'test');\n    app.use(bodyParser.xml(options));\n    app.post('/', function (req, res) {\n      res.status(200).send({ parsed: req.body });\n    });\n  };\n\n  beforeEach(function () {\n    app = null;\n  });\n\n  it('should parse a body with content-type application/xml', function (done) {\n    createServer();\n\n    request(app)\n      .post('/')\n      .set('Content-Type', 'application/xml')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should parse a body with content-type text/xml', function (done) {\n    createServer();\n\n    request(app)\n      .post('/')\n      .set('Content-Type', 'text/xml')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should parse a body with content-type application/rss+xml', function (done) {\n    createServer();\n\n    request(app)\n      .post('/')\n      .set('Content-Type', 'application/rss+xml')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should accept xmlParseOptions', function (done) {\n    createServer({\n      xmlParseOptions: {\n        normalize: true, // Trim whitespace inside text nodes\n        normalizeTags: true, // Transform tags to lowercase\n        explicitArray: false, // Only put nodes in array if >1\n      },\n    });\n    request(app)\n      .post('/')\n      .set('Content-Type', 'text/xml')\n      .send('<CUSTOMER><name>Bob</name></CUSTOMER>')\n      .expect(200, { parsed: { customer: { name: 'Bob' } } }, done);\n  });\n\n  it('should accept custom ContentType as array', function (done) {\n    createServer({\n      type: ['application/custom-xml-type'],\n    });\n    request(app)\n      .post('/')\n      .set('Content-Type', 'application/custom-xml-type')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should accept custom ContentType as string', function (done) {\n    createServer({\n      type: 'application/custom-xml-type',\n    });\n    request(app)\n      .post('/')\n      .set('Content-Type', 'application/custom-xml-type')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should accept custom ContentType as function', function (done) {\n    createServer({\n      type: function () {\n        return true;\n      },\n    });\n    request(app)\n      .post('/')\n      .send('<customer><name>Bob</name></customer>')\n      .expect(200, { parsed: { customer: { name: ['Bob'] } } }, done);\n  });\n\n  it('should ignore non-XML', function (done) {\n    createServer();\n    request(app)\n      .post('/')\n      .set('Content-Type', 'text/plain')\n      .send('Customer name: Bob')\n      .expect(200, { parsed: {} }, done);\n  });\n\n  it('should reject invalid XML', function (done) {\n    createServer();\n    request(app)\n      .post('/')\n      .set('Content-Type', 'text/xml')\n      .send('<invalid-xml>')\n      .expect(400, done);\n  });\n\n  it('should not throw an exception after the callback is returned', function (done) {\n    // Guards against https://github.com/Leonidas-from-XIV/node-xml2js/issues/400\n    createServer();\n    request(app)\n      .post('/')\n      .set('Content-Type', 'text/xml')\n      .send('x<foo>test</foo><bar>test</bar></data>')\n      .expect(400, done);\n  });\n\n  it('should not set/change prototype using __proto__', function (done) {\n    createServer();\n    request(app)\n      .post('/')\n      .set('Content-Type', 'application/xml')\n      .send('<__proto__><name>Bob</name></__proto__>')\n      .expect(200, { parsed: {} }, done);\n  });\n\n  it('should not set/change using prototype', function (done) {\n    createServer();\n    request(app)\n      .post('/')\n      .set('Content-Type', 'application/xml')\n      .send('<prototype><name>Bob</name></prototype>')\n      .expect(200, { parsed: {} }, done);\n  });\n\n  it('should not set/change using constructor', function (done) {\n    createServer();\n    request(app)\n      .post('/')\n      .set('Content-Type', 'application/xml')\n      .send('<constructor><name>Bob</name></constructor>')\n      .expect(200, { parsed: {} }, done);\n  });\n});\n"], "filenames": ["index.js", "test.js"], "buggy_code_start_loc": [46, 132], "buggy_code_end_loc": [47, 132], "fixing_code_start_loc": [46, 133], "fixing_code_end_loc": [56, 160], "type": "CWE-1321", "message": "body-parser-xml is vulnerable to Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')", "other": {"cve": {"id": "CVE-2021-3666", "sourceIdentifier": "security@huntr.dev", "published": "2021-09-13T18:15:25.167", "lastModified": "2022-07-29T16:44:10.010", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "body-parser-xml is vulnerable to Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')"}, {"lang": "es", "value": "body-parser-xml es vulnerable a una Modificaci\u00f3n Inapropiada de los Atributos del Prototipo del Objeto (\"Contaminaci\u00f3n de Prototipo\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xml_body_parser_project:xml_body_parser:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.0.3", "matchCriteriaId": "4C3AC8E2-CF34-489E-9FBF-D3513E174A87"}]}]}], "references": [{"url": "https://github.com/fiznool/body-parser-xml/commit/d46ca622560f7c9a033cd9321c61e92558150d63", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/1-other-fiznool/body-parser-xml", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fiznool/body-parser-xml/commit/d46ca622560f7c9a033cd9321c61e92558150d63"}}