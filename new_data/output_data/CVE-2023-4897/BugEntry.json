{"buggy_code": ["import React, { useState, useEffect } from \"react\";\nimport System from \"../../../../models/system\";\nimport Workspace from \"../../../../models/workspace\";\nimport paths from \"../../../../utils/paths\";\nimport { useParams } from \"react-router-dom\";\nimport Directory from \"./Directory\";\nimport ConfirmationModal from \"./ConfirmationModal\";\nimport { AlertTriangle } from \"react-feather\";\n\nexport default function DocumentSettings({ workspace }) {\n  const { slug } = useParams();\n  const [loading, setLoading] = useState(true);\n  const [saving, setSaving] = useState(false);\n  const [showConfirmation, setShowConfirmation] = useState(false);\n  const [directories, setDirectories] = useState(null);\n  const [originalDocuments, setOriginalDocuments] = useState([]);\n  const [selectedFiles, setSelectFiles] = useState([]);\n  const [hasFiles, setHasFiles] = useState(true);\n  const [canDelete, setCanDelete] = useState(false);\n\n  useEffect(() => {\n    async function fetchKeys() {\n      const localFiles = await System.localFiles();\n      const originalDocs = workspace.documents.map((doc) => doc.docpath) || [];\n      const hasAnyFiles = localFiles.items.some(\n        (folder) => folder?.items?.length > 0\n      );\n\n      const canDelete = await System.getCanDeleteWorkspaces();\n      setCanDelete(canDelete);\n      setDirectories(localFiles);\n      setOriginalDocuments([...originalDocs]);\n      setSelectFiles([...originalDocs]);\n      setHasFiles(hasAnyFiles);\n      setLoading(false);\n    }\n    fetchKeys();\n  }, []);\n\n  const deleteWorkspace = async () => {\n    if (\n      !window.confirm(\n        `You are about to delete your entire ${workspace.name} workspace. This will remove all vector embeddings on your vector database.\\n\\nThe original source files will remain untouched. This action is irreversible.`\n      )\n    )\n      return false;\n    await Workspace.delete(workspace.slug);\n    workspace.slug === slug\n      ? (window.location = paths.home())\n      : window.location.reload();\n  };\n\n  const docChanges = () => {\n    const changes = {\n      adds: [],\n      deletes: [],\n    };\n\n    selectedFiles.map((doc) => {\n      const inOriginal = !!originalDocuments.find((oDoc) => oDoc === doc);\n      if (!inOriginal) {\n        changes.adds.push(doc);\n      }\n    });\n\n    originalDocuments.map((doc) => {\n      const selected = !!selectedFiles.find((oDoc) => oDoc === doc);\n      if (!selected) {\n        changes.deletes.push(doc);\n      }\n    });\n\n    return changes;\n  };\n\n  const confirmChanges = (e) => {\n    e.preventDefault();\n    const changes = docChanges();\n    changes.adds.length > 0 ? setShowConfirmation(true) : updateWorkspace(e);\n  };\n\n  const updateWorkspace = async (e) => {\n    e.preventDefault();\n    setSaving(true);\n    setShowConfirmation(false);\n    const changes = docChanges();\n    await Workspace.modifyEmbeddings(workspace.slug, changes);\n    setSaving(false);\n    window.location.reload();\n  };\n\n  const isSelected = (filepath) => {\n    const isFolder = !filepath.includes(\"/\");\n    return isFolder\n      ? selectedFiles.some((doc) => doc.includes(filepath.split(\"/\")[0]))\n      : selectedFiles.some((doc) => doc.includes(filepath));\n  };\n\n  const toggleSelection = (filepath) => {\n    const isFolder = !filepath.includes(\"/\");\n    const parent = isFolder ? filepath : filepath.split(\"/\")[0];\n\n    if (isSelected(filepath)) {\n      const updatedDocs = isFolder\n        ? selectedFiles.filter((doc) => !doc.includes(parent))\n        : selectedFiles.filter((doc) => !doc.includes(filepath));\n      setSelectFiles([...new Set(updatedDocs)]);\n    } else {\n      var newDocs = [];\n      var parentDirs = directories.items.find((item) => item.name === parent);\n      if (isFolder && parentDirs) {\n        const folderItems = parentDirs.items;\n        newDocs = folderItems.map((item) => parent + \"/\" + item.name);\n      } else {\n        newDocs = [filepath];\n      }\n\n      const combined = [...selectedFiles, ...newDocs];\n      setSelectFiles([...new Set(combined)]);\n    }\n  };\n\n  if (loading) {\n    return (\n      <>\n        <div className=\"p-6 flex h-full w-full max-h-[80vh] overflow-y-scroll\">\n          <div className=\"flex flex-col gap-y-1 w-full\">\n            <p className=\"text-slate-200 dark:text-stone-300 text-center\">\n              loading workspace files\n            </p>\n          </div>\n        </div>\n        <div className=\"flex items-center p-6 space-x-2 border-t border-gray-200 rounded-b dark:border-gray-600\"></div>\n      </>\n    );\n  }\n\n  return (\n    <>\n      {showConfirmation && (\n        <ConfirmationModal\n          directories={directories}\n          hideConfirm={() => setShowConfirmation(false)}\n          additions={docChanges().adds}\n          updateWorkspace={updateWorkspace}\n        />\n      )}\n      <div className=\"p-6 flex h-full w-full max-h-[80vh] overflow-y-scroll\">\n        <div className=\"flex flex-col gap-y-1 w-full\">\n          {!hasFiles && (\n            <div className=\"mb-4 w-full gap-x-2 rounded-lg h-10 border bg-orange-200 border-orange-800 dark:bg-orange-300 text-orange-800 flex  items-center justify-center\">\n              <AlertTriangle className=\"h-6 w-6\" />\n              <p className=\"text-sm\">\n                You don't have any files uploaded. Upload a file via the \"Upload\n                Docs\" tab.\n              </p>\n            </div>\n          )}\n\n          <div className=\"flex flex-col mb-2\">\n            <p className=\"text-gray-800 dark:text-stone-200 text-base \">\n              Select folders to add or remove from workspace.\n            </p>\n            <p className=\"text-gray-800 dark:text-stone-400 text-xs italic\">\n              {selectedFiles.length} documents in workspace selected.\n            </p>\n          </div>\n          <div className=\"w-full h-auto border border-slate-200 dark:border-stone-600 rounded-lg px-4 py-2\">\n            {!!directories && (\n              <Directory\n                files={directories}\n                toggleSelection={toggleSelection}\n                isSelected={isSelected}\n              />\n            )}\n          </div>\n        </div>\n      </div>\n      <div\n        className={`flex items-center ${canDelete ? \"justify-between\" : \"justify-end\"\n          } p-4 md:p-6 space-x-2 border-t border-gray-200 rounded-b dark:border-gray-600`}\n      >\n        <button\n          hidden={!canDelete}\n          onClick={deleteWorkspace}\n          type=\"button\"\n          className=\"border border-transparent text-gray-500 bg-white hover:bg-red-100 rounded-lg whitespace-nowrap text-sm font-medium px-5 py-2.5 hover:text-red-900 focus:z-10 dark:bg-transparent dark:text-gray-300 dark:hover:text-white dark:hover:bg-red-600\"\n        >\n          Delete Workspace\n        </button>\n\n        <div className=\"flex items-center\">\n          <button\n            disabled={saving}\n            onClick={confirmChanges}\n            type=\"submit\"\n            className=\"text-slate-200 bg-black-900 px-4 py-2 rounded-lg hover:bg-gray-900 whitespace-nowrap text-sm\"\n          >\n            {saving ? \"Saving...\" : \"Confirm Changes\"}\n          </button>\n        </div>\n      </div>\n    </>\n  );\n}\n", "process.env.NODE_ENV === \"development\"\n  ? require(\"dotenv\").config({ path: `.env.${process.env.NODE_ENV}` })\n  : require(\"dotenv\").config();\nconst { validateTablePragmas } = require(\"../utils/database\");\nconst { viewLocalFiles } = require(\"../utils/files\");\nconst { exportData, unpackAndOverwriteImport } = require(\"../utils/files/data\");\nconst {\n  checkPythonAppAlive,\n  acceptedFileTypes,\n} = require(\"../utils/files/documentProcessor\");\nconst { purgeDocument } = require(\"../utils/files/purgeDocument\");\nconst { getVectorDbClass } = require(\"../utils/helpers\");\nconst { updateENV, dumpENV } = require(\"../utils/helpers/updateENV\");\nconst {\n  reqBody,\n  makeJWT,\n  userFromSession,\n  multiUserMode,\n} = require(\"../utils/http\");\nconst { setupDataImports, setupLogoUploads } = require(\"../utils/files/multer\");\nconst { v4 } = require(\"uuid\");\nconst { SystemSettings } = require(\"../models/systemSettings\");\nconst { User } = require(\"../models/user\");\nconst { validatedRequest } = require(\"../utils/middleware/validatedRequest\");\nconst { handleImports } = setupDataImports();\nconst { handleLogoUploads } = setupLogoUploads();\nconst path = require(\"path\");\nconst {\n  getDefaultFilename,\n  determineLogoFilepath,\n  fetchLogo,\n  validFilename,\n  renameLogoFile,\n  removeCustomLogo,\n  DARK_LOGO_FILENAME,\n} = require(\"../utils/files/logo\");\nconst { Telemetry } = require(\"../models/telemetry\");\nconst { WelcomeMessages } = require(\"../models/welcomeMessages\");\nconst { ApiKey } = require(\"../models/apiKeys\");\n\nfunction systemEndpoints(app) {\n  if (!app) return;\n\n  app.get(\"/ping\", (_, response) => {\n    response.status(200).json({ online: true });\n  });\n\n  app.get(\"/migrate\", async (_, response) => {\n    await validateTablePragmas(true);\n    response.sendStatus(200);\n  });\n\n  app.get(\"/env-dump\", async (_, response) => {\n    if (process.env.NODE_ENV !== \"production\")\n      return response.sendStatus(200).end();\n    await dumpENV();\n    response.sendStatus(200).end();\n  });\n\n  app.get(\"/setup-complete\", async (_, response) => {\n    try {\n      const results = await SystemSettings.currentSettings();\n      response.status(200).json({ results });\n    } catch (e) {\n      console.log(e.message, e);\n      response.sendStatus(500).end();\n    }\n  });\n\n  app.get(\n    \"/system/check-token\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        if (multiUserMode(response)) {\n          const user = await userFromSession(request, response);\n          if (!user || user.suspended) {\n            response.sendStatus(403).end();\n            return;\n          }\n\n          response.sendStatus(200).end();\n          return;\n        }\n\n        response.sendStatus(200).end();\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.post(\"/request-token\", async (request, response) => {\n    try {\n      if (await SystemSettings.isMultiUserMode()) {\n        const { username, password } = reqBody(request);\n        const existingUser = await User.get(`username = '${username}'`);\n\n        if (!existingUser) {\n          response.status(200).json({\n            user: null,\n            valid: false,\n            token: null,\n            message: \"[001] Invalid login credentials.\",\n          });\n          return;\n        }\n\n        const bcrypt = require(\"bcrypt\");\n        if (!bcrypt.compareSync(password, existingUser.password)) {\n          response.status(200).json({\n            user: null,\n            valid: false,\n            token: null,\n            message: \"[002] Invalid login credentials.\",\n          });\n          return;\n        }\n\n        if (existingUser.suspended) {\n          response.status(200).json({\n            user: null,\n            valid: false,\n            token: null,\n            message: \"[004] Account suspended by admin.\",\n          });\n          return;\n        }\n\n        response.status(200).json({\n          valid: true,\n          user: existingUser,\n          token: makeJWT(\n            { id: existingUser.id, username: existingUser.username },\n            \"30d\"\n          ),\n          message: null,\n        });\n        return;\n      } else {\n        const { password } = reqBody(request);\n        if (password !== process.env.AUTH_TOKEN) {\n          response.status(401).json({\n            valid: false,\n            token: null,\n            message: \"[003] Invalid password provided\",\n          });\n          return;\n        }\n\n        response.status(200).json({\n          valid: true,\n          token: makeJWT({ p: password }, \"30d\"),\n          message: null,\n        });\n      }\n    } catch (e) {\n      console.log(e.message, e);\n      response.sendStatus(500).end();\n    }\n  });\n\n  app.get(\"/system/system-vectors\", [validatedRequest], async (_, response) => {\n    try {\n      const VectorDb = getVectorDbClass();\n      const vectorCount = await VectorDb.totalIndicies();\n      response.status(200).json({ vectorCount });\n    } catch (e) {\n      console.log(e.message, e);\n      response.sendStatus(500).end();\n    }\n  });\n\n  app.delete(\n    \"/system/remove-document\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        const { name, meta } = reqBody(request);\n        await purgeDocument(name, meta);\n        response.sendStatus(200).end();\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.get(\"/system/local-files\", [validatedRequest], async (_, response) => {\n    try {\n      const localFiles = await viewLocalFiles();\n      response.status(200).json({ localFiles });\n    } catch (e) {\n      console.log(e.message, e);\n      response.sendStatus(500).end();\n    }\n  });\n\n  app.get(\n    \"/system/document-processing-status\",\n    [validatedRequest],\n    async (_, response) => {\n      try {\n        const online = await checkPythonAppAlive();\n        response.sendStatus(online ? 200 : 503);\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.get(\n    \"/system/accepted-document-types\",\n    [validatedRequest],\n    async (_, response) => {\n      try {\n        const types = await acceptedFileTypes();\n        if (!types) {\n          response.sendStatus(404).end();\n          return;\n        }\n\n        response.status(200).json({ types });\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.post(\n    \"/system/update-env\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        const body = reqBody(request);\n        const { newValues, error } = updateENV(body);\n        if (process.env.NODE_ENV === \"production\") await dumpENV();\n        response.status(200).json({ newValues, error });\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.post(\n    \"/system/update-password\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        const { usePassword, newPassword } = reqBody(request);\n        const { error } = updateENV({\n          AuthToken: usePassword ? newPassword : \"\",\n          JWTSecret: usePassword ? v4() : \"\",\n        });\n        response.status(200).json({ success: !error, error });\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.post(\n    \"/system/enable-multi-user\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        const { username, password } = reqBody(request);\n        const multiUserModeEnabled = await SystemSettings.isMultiUserMode();\n        if (multiUserModeEnabled) {\n          response.status(200).json({\n            success: false,\n            error: \"Multi-user mode is already enabled.\",\n          });\n          return;\n        }\n\n        const { user, error } = await User.create({\n          username,\n          password,\n          role: \"admin\",\n        });\n        await SystemSettings.updateSettings({\n          multi_user_mode: true,\n          users_can_delete_workspaces: false,\n          limit_user_messages: false,\n          message_limit: 25,\n        });\n        process.env.AUTH_TOKEN = null;\n        process.env.JWT_SECRET = process.env.JWT_SECRET ?? v4(); // Make sure JWT_SECRET is set for JWT issuance.\n        await Telemetry.sendTelemetry(\"enabled_multi_user_mode\");\n        response.status(200).json({ success: !!user, error });\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.get(\"/system/data-export\", [validatedRequest], async (_, response) => {\n    try {\n      const { filename, error } = await exportData();\n      response.status(200).json({ filename, error });\n    } catch (e) {\n      console.log(e.message, e);\n      response.sendStatus(500).end();\n    }\n  });\n\n  app.get(\n    \"/system/data-exports/:filename\",\n    [validatedRequest],\n    (request, response) => {\n      const filePath =\n        __dirname + \"/../storage/exports/\" + request.params.filename;\n      response.download(filePath, request.params.filename, (err) => {\n        if (err) {\n          response.send({\n            error: err,\n            msg: \"Problem downloading the file\",\n          });\n        }\n      });\n    }\n  );\n\n  app.post(\n    \"/system/data-import\",\n    handleImports.single(\"file\"),\n    async function (request, response) {\n      const { originalname } = request.file;\n      const { success, error } = await unpackAndOverwriteImport(originalname);\n      response.status(200).json({ success, error });\n    }\n  );\n\n  app.get(\"/system/logo/:mode?\", async function (request, response) {\n    try {\n      const defaultFilename = getDefaultFilename(request.params.mode);\n      const logoPath = await determineLogoFilepath(defaultFilename);\n      const { buffer, size, mime } = fetchLogo(logoPath);\n      response.writeHead(200, {\n        \"Content-Type\": mime || \"image/png\",\n        \"Content-Disposition\": `attachment; filename=${path.basename(\n          logoPath\n        )}`,\n        \"Content-Length\": size,\n      });\n      response.end(Buffer.from(buffer, \"base64\"));\n      return;\n    } catch (error) {\n      console.error(\"Error processing the logo request:\", error);\n      response.status(500).json({ message: \"Internal server error\" });\n    }\n  });\n\n  app.post(\n    \"/system/upload-logo\",\n    [validatedRequest],\n    handleLogoUploads.single(\"logo\"),\n    async (request, response) => {\n      if (!request.file || !request.file.originalname) {\n        return response.status(400).json({ message: \"No logo file provided.\" });\n      }\n\n      if (!validFilename(request.file.originalname)) {\n        return response.status(400).json({\n          message: \"Invalid file name. Please choose a different file.\",\n        });\n      }\n\n      try {\n        if (\n          response.locals.multiUserMode &&\n          response.locals.user?.role !== \"admin\"\n        ) {\n          return response.sendStatus(401).end();\n        }\n\n        const newFilename = await renameLogoFile(request.file.originalname);\n        const existingLogoFilename = await SystemSettings.currentLogoFilename();\n        await removeCustomLogo(existingLogoFilename);\n\n        const { success, error } = await SystemSettings.updateSettings({\n          logo_filename: newFilename,\n        });\n\n        return response.status(success ? 200 : 500).json({\n          message: success\n            ? \"Logo uploaded successfully.\"\n            : error || \"Failed to update with new logo.\",\n        });\n      } catch (error) {\n        console.error(\"Error processing the logo upload:\", error);\n        response.status(500).json({ message: \"Error uploading the logo.\" });\n      }\n    }\n  );\n\n  app.get(\n    \"/system/remove-logo\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        if (\n          response.locals.multiUserMode &&\n          response.locals.user?.role !== \"admin\"\n        ) {\n          return response.sendStatus(401).end();\n        }\n\n        const currentLogoFilename = await SystemSettings.currentLogoFilename();\n        await removeCustomLogo(currentLogoFilename);\n        const { success, error } = await SystemSettings.updateSettings({\n          logo_filename: DARK_LOGO_FILENAME,\n        });\n\n        return response.status(success ? 200 : 500).json({\n          message: success\n            ? \"Logo removed successfully.\"\n            : error || \"Failed to update with new logo.\",\n        });\n      } catch (error) {\n        console.error(\"Error processing the logo removal:\", error);\n        response.status(500).json({ message: \"Error removing the logo.\" });\n      }\n    }\n  );\n\n  app.get(\n    \"/system/can-delete-workspaces\",\n    [validatedRequest],\n    async function (request, response) {\n      try {\n        if (!response.locals.multiUserMode) {\n          return response.status(200).json({ canDelete: true });\n        }\n\n        if (response.locals.user?.role === \"admin\") {\n          return response.status(200).json({ canDelete: true });\n        }\n\n        const canDelete = await SystemSettings.canDeleteWorkspaces();\n        response.status(200).json({ canDelete });\n      } catch (error) {\n        console.error(\"Error fetching can delete workspaces:\", error);\n        response\n          .status(500)\n          .json({\n            success: false,\n            message: \"Internal server error\",\n            canDelete: false,\n          });\n      }\n    }\n  );\n\n  app.get(\"/system/welcome-messages\", async function (request, response) {\n    try {\n      const welcomeMessages = await WelcomeMessages.getMessages();\n      response.status(200).json({ success: true, welcomeMessages });\n    } catch (error) {\n      console.error(\"Error fetching welcome messages:\", error);\n      response\n        .status(500)\n        .json({ success: false, message: \"Internal server error\" });\n    }\n  });\n\n  app.post(\n    \"/system/set-welcome-messages\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        if (\n          response.locals.multiUserMode &&\n          response.locals.user?.role !== \"admin\"\n        ) {\n          return response.sendStatus(401).end();\n        }\n\n        const { messages = [] } = reqBody(request);\n        if (!Array.isArray(messages)) {\n          return response.status(400).json({\n            success: false,\n            message: \"Invalid message format. Expected an array of messages.\",\n          });\n        }\n\n        await WelcomeMessages.saveAll(messages);\n        return response.status(200).json({\n          success: true,\n          message: \"Welcome messages saved successfully.\",\n        });\n      } catch (error) {\n        console.error(\"Error processing the welcome messages:\", error);\n        response.status(500).json({\n          success: true,\n          message: \"Error saving the welcome messages.\",\n        });\n      }\n    }\n  );\n\n  app.get(\"/system/api-key\", [validatedRequest], async (_, response) => {\n    try {\n      if (response.locals.multiUserMode) {\n        return response.sendStatus(401).end();\n      }\n\n      const apiKey = await ApiKey.get(\"id IS NOT NULL\");\n      return response.status(200).json({\n        apiKey,\n        error: null,\n      });\n    } catch (error) {\n      console.error(error);\n      response.status(500).json({\n        apiKey: null,\n        error: \"Could not find an API Key.\",\n      });\n    }\n  });\n\n  app.post(\n    \"/system/generate-api-key\",\n    [validatedRequest],\n    async (_, response) => {\n      try {\n        if (response.locals.multiUserMode) {\n          return response.sendStatus(401).end();\n        }\n\n        await ApiKey.delete();\n        const { apiKey, error } = await ApiKey.create();\n        return response.status(200).json({\n          apiKey,\n          error,\n        });\n      } catch (error) {\n        console.error(error);\n        response.status(500).json({\n          apiKey: null,\n          error: \"Error generating api key.\",\n        });\n      }\n    }\n  );\n\n  app.delete(\"/system/api-key\", [validatedRequest], async (_, response) => {\n    try {\n      if (response.locals.multiUserMode) {\n        return response.sendStatus(401).end();\n      }\n\n      await ApiKey.delete();\n      return response.status(200).end();\n    } catch (error) {\n      console.error(error);\n      response.status(500).end();\n    }\n  });\n}\n\nmodule.exports = { systemEndpoints };\n"], "fixing_code": ["import React, { useState, useEffect } from \"react\";\nimport System from \"../../../../models/system\";\nimport Workspace from \"../../../../models/workspace\";\nimport paths from \"../../../../utils/paths\";\nimport { useParams } from \"react-router-dom\";\nimport Directory from \"./Directory\";\nimport ConfirmationModal from \"./ConfirmationModal\";\nimport { AlertTriangle } from \"react-feather\";\n\nexport default function DocumentSettings({ workspace }) {\n  const { slug } = useParams();\n  const [loading, setLoading] = useState(true);\n  const [saving, setSaving] = useState(false);\n  const [showConfirmation, setShowConfirmation] = useState(false);\n  const [directories, setDirectories] = useState(null);\n  const [originalDocuments, setOriginalDocuments] = useState([]);\n  const [selectedFiles, setSelectFiles] = useState([]);\n  const [hasFiles, setHasFiles] = useState(true);\n  const [canDelete, setCanDelete] = useState(false);\n\n  useEffect(() => {\n    async function fetchKeys() {\n      const localFiles = await System.localFiles();\n      const originalDocs = workspace.documents.map((doc) => doc.docpath) || [];\n      const hasAnyFiles = localFiles.items.some(\n        (folder) => folder?.items?.length > 0\n      );\n\n      const canDelete = await System.getCanDeleteWorkspaces();\n      setCanDelete(canDelete);\n      setDirectories(localFiles);\n      setOriginalDocuments([...originalDocs]);\n      setSelectFiles([...originalDocs]);\n      setHasFiles(hasAnyFiles);\n      setLoading(false);\n    }\n    fetchKeys();\n  }, []);\n\n  const deleteWorkspace = async () => {\n    if (\n      !window.confirm(\n        `You are about to delete your entire ${workspace.name} workspace. This will remove all vector embeddings on your vector database.\\n\\nThe original source files will remain untouched. This action is irreversible.`\n      )\n    )\n      return false;\n    await Workspace.delete(workspace.slug);\n    workspace.slug === slug\n      ? (window.location = paths.home())\n      : window.location.reload();\n  };\n\n  const docChanges = () => {\n    const changes = {\n      adds: [],\n      deletes: [],\n    };\n\n    selectedFiles.map((doc) => {\n      const inOriginal = !!originalDocuments.find((oDoc) => oDoc === doc);\n      if (!inOriginal) {\n        changes.adds.push(doc);\n      }\n    });\n\n    originalDocuments.map((doc) => {\n      const selected = !!selectedFiles.find((oDoc) => oDoc === doc);\n      if (!selected) {\n        changes.deletes.push(doc);\n      }\n    });\n\n    return changes;\n  };\n\n  const confirmChanges = (e) => {\n    e.preventDefault();\n    const changes = docChanges();\n    changes.adds.length > 0 ? setShowConfirmation(true) : updateWorkspace(e);\n  };\n\n  const updateWorkspace = async (e) => {\n    e.preventDefault();\n    setSaving(true);\n    setShowConfirmation(false);\n    const changes = docChanges();\n    await Workspace.modifyEmbeddings(workspace.slug, changes);\n    setSaving(false);\n    window.location.reload();\n  };\n\n  const isSelected = (filepath) => {\n    const isFolder = !filepath.includes(\"/\");\n    return isFolder\n      ? selectedFiles.some((doc) => doc.includes(filepath.split(\"/\")[0]))\n      : selectedFiles.some((doc) => doc.includes(filepath));\n  };\n\n  const toggleSelection = (filepath) => {\n    const isFolder = !filepath.includes(\"/\");\n    const parent = isFolder ? filepath : filepath.split(\"/\")[0];\n\n    if (isSelected(filepath)) {\n      const updatedDocs = isFolder\n        ? selectedFiles.filter((doc) => !doc.includes(parent))\n        : selectedFiles.filter((doc) => !doc.includes(filepath));\n      setSelectFiles([...new Set(updatedDocs)]);\n    } else {\n      var newDocs = [];\n      var parentDirs = directories.items.find((item) => item.name === parent);\n      if (isFolder && parentDirs) {\n        const folderItems = parentDirs.items;\n        newDocs = folderItems.map((item) => parent + \"/\" + item.name);\n      } else {\n        newDocs = [filepath];\n      }\n\n      const combined = [...selectedFiles, ...newDocs];\n      setSelectFiles([...new Set(combined)]);\n    }\n  };\n\n  if (loading) {\n    return (\n      <>\n        <div className=\"p-6 flex h-full w-full max-h-[80vh] overflow-y-scroll\">\n          <div className=\"flex flex-col gap-y-1 w-full\">\n            <p className=\"text-slate-200 dark:text-stone-300 text-center\">\n              loading workspace files\n            </p>\n          </div>\n        </div>\n        <div className=\"flex items-center p-6 space-x-2 border-t border-gray-200 rounded-b dark:border-gray-600\"></div>\n      </>\n    );\n  }\n\n  return (\n    <>\n      {showConfirmation && (\n        <ConfirmationModal\n          directories={directories}\n          hideConfirm={() => setShowConfirmation(false)}\n          additions={docChanges().adds}\n          updateWorkspace={updateWorkspace}\n        />\n      )}\n      <div className=\"p-6 flex h-full w-full max-h-[80vh] overflow-y-scroll\">\n        <div className=\"flex flex-col gap-y-1 w-full\">\n          {!hasFiles && (\n            <div className=\"mb-4 w-full gap-x-2 rounded-lg h-10 border bg-orange-200 border-orange-800 dark:bg-orange-300 text-orange-800 flex  items-center justify-center\">\n              <AlertTriangle className=\"h-6 w-6\" />\n              <p className=\"text-sm\">\n                You don't have any files uploaded. Upload a file via the \"Upload\n                Docs\" tab.\n              </p>\n            </div>\n          )}\n\n          <div className=\"flex flex-col mb-2\">\n            <p className=\"text-gray-800 dark:text-stone-200 text-base \">\n              Select folders to add or remove from workspace.\n            </p>\n            <p className=\"text-gray-800 dark:text-stone-400 text-xs italic\">\n              {selectedFiles.length} documents in workspace selected.\n            </p>\n          </div>\n          <div className=\"w-full h-auto border border-slate-200 dark:border-stone-600 rounded-lg px-4 py-2\">\n            {!!directories && (\n              <Directory\n                files={directories}\n                toggleSelection={toggleSelection}\n                isSelected={isSelected}\n              />\n            )}\n          </div>\n        </div>\n      </div>\n      <div\n        className={`flex items-center ${\n          canDelete ? \"justify-between\" : \"justify-end\"\n        } p-4 md:p-6 space-x-2 border-t border-gray-200 rounded-b dark:border-gray-600`}\n      >\n        <button\n          hidden={!canDelete}\n          onClick={deleteWorkspace}\n          type=\"button\"\n          className=\"border border-transparent text-gray-500 bg-white hover:bg-red-100 rounded-lg whitespace-nowrap text-sm font-medium px-5 py-2.5 hover:text-red-900 focus:z-10 dark:bg-transparent dark:text-gray-300 dark:hover:text-white dark:hover:bg-red-600\"\n        >\n          Delete Workspace\n        </button>\n\n        <div className=\"flex items-center\">\n          <button\n            disabled={saving}\n            onClick={confirmChanges}\n            type=\"submit\"\n            className=\"text-slate-200 bg-black-900 px-4 py-2 rounded-lg hover:bg-gray-900 whitespace-nowrap text-sm\"\n          >\n            {saving ? \"Saving...\" : \"Confirm Changes\"}\n          </button>\n        </div>\n      </div>\n    </>\n  );\n}\n", "process.env.NODE_ENV === \"development\"\n  ? require(\"dotenv\").config({ path: `.env.${process.env.NODE_ENV}` })\n  : require(\"dotenv\").config();\nconst { validateTablePragmas } = require(\"../utils/database\");\nconst { viewLocalFiles } = require(\"../utils/files\");\nconst { exportData, unpackAndOverwriteImport } = require(\"../utils/files/data\");\nconst {\n  checkPythonAppAlive,\n  acceptedFileTypes,\n} = require(\"../utils/files/documentProcessor\");\nconst { purgeDocument } = require(\"../utils/files/purgeDocument\");\nconst { getVectorDbClass } = require(\"../utils/helpers\");\nconst { updateENV, dumpENV } = require(\"../utils/helpers/updateENV\");\nconst {\n  reqBody,\n  makeJWT,\n  userFromSession,\n  multiUserMode,\n} = require(\"../utils/http\");\nconst { setupDataImports, setupLogoUploads } = require(\"../utils/files/multer\");\nconst { v4 } = require(\"uuid\");\nconst { SystemSettings } = require(\"../models/systemSettings\");\nconst { User } = require(\"../models/user\");\nconst { validatedRequest } = require(\"../utils/middleware/validatedRequest\");\nconst { handleImports } = setupDataImports();\nconst { handleLogoUploads } = setupLogoUploads();\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst {\n  getDefaultFilename,\n  determineLogoFilepath,\n  fetchLogo,\n  validFilename,\n  renameLogoFile,\n  removeCustomLogo,\n  DARK_LOGO_FILENAME,\n} = require(\"../utils/files/logo\");\nconst { Telemetry } = require(\"../models/telemetry\");\nconst { WelcomeMessages } = require(\"../models/welcomeMessages\");\nconst { ApiKey } = require(\"../models/apiKeys\");\n\nfunction systemEndpoints(app) {\n  if (!app) return;\n\n  app.get(\"/ping\", (_, response) => {\n    response.status(200).json({ online: true });\n  });\n\n  app.get(\"/migrate\", async (_, response) => {\n    await validateTablePragmas(true);\n    response.sendStatus(200);\n  });\n\n  app.get(\"/env-dump\", async (_, response) => {\n    if (process.env.NODE_ENV !== \"production\")\n      return response.sendStatus(200).end();\n    await dumpENV();\n    response.sendStatus(200).end();\n  });\n\n  app.get(\"/setup-complete\", async (_, response) => {\n    try {\n      const results = await SystemSettings.currentSettings();\n      response.status(200).json({ results });\n    } catch (e) {\n      console.log(e.message, e);\n      response.sendStatus(500).end();\n    }\n  });\n\n  app.get(\n    \"/system/check-token\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        if (multiUserMode(response)) {\n          const user = await userFromSession(request, response);\n          if (!user || user.suspended) {\n            response.sendStatus(403).end();\n            return;\n          }\n\n          response.sendStatus(200).end();\n          return;\n        }\n\n        response.sendStatus(200).end();\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.post(\"/request-token\", async (request, response) => {\n    try {\n      if (await SystemSettings.isMultiUserMode()) {\n        const { username, password } = reqBody(request);\n        const existingUser = await User.get(`username = '${username}'`);\n\n        if (!existingUser) {\n          response.status(200).json({\n            user: null,\n            valid: false,\n            token: null,\n            message: \"[001] Invalid login credentials.\",\n          });\n          return;\n        }\n\n        const bcrypt = require(\"bcrypt\");\n        if (!bcrypt.compareSync(password, existingUser.password)) {\n          response.status(200).json({\n            user: null,\n            valid: false,\n            token: null,\n            message: \"[002] Invalid login credentials.\",\n          });\n          return;\n        }\n\n        if (existingUser.suspended) {\n          response.status(200).json({\n            user: null,\n            valid: false,\n            token: null,\n            message: \"[004] Account suspended by admin.\",\n          });\n          return;\n        }\n\n        response.status(200).json({\n          valid: true,\n          user: existingUser,\n          token: makeJWT(\n            { id: existingUser.id, username: existingUser.username },\n            \"30d\"\n          ),\n          message: null,\n        });\n        return;\n      } else {\n        const { password } = reqBody(request);\n        if (password !== process.env.AUTH_TOKEN) {\n          response.status(401).json({\n            valid: false,\n            token: null,\n            message: \"[003] Invalid password provided\",\n          });\n          return;\n        }\n\n        response.status(200).json({\n          valid: true,\n          token: makeJWT({ p: password }, \"30d\"),\n          message: null,\n        });\n      }\n    } catch (e) {\n      console.log(e.message, e);\n      response.sendStatus(500).end();\n    }\n  });\n\n  app.get(\"/system/system-vectors\", [validatedRequest], async (_, response) => {\n    try {\n      const VectorDb = getVectorDbClass();\n      const vectorCount = await VectorDb.totalIndicies();\n      response.status(200).json({ vectorCount });\n    } catch (e) {\n      console.log(e.message, e);\n      response.sendStatus(500).end();\n    }\n  });\n\n  app.delete(\n    \"/system/remove-document\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        const { name, meta } = reqBody(request);\n        await purgeDocument(name, meta);\n        response.sendStatus(200).end();\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.get(\"/system/local-files\", [validatedRequest], async (_, response) => {\n    try {\n      const localFiles = await viewLocalFiles();\n      response.status(200).json({ localFiles });\n    } catch (e) {\n      console.log(e.message, e);\n      response.sendStatus(500).end();\n    }\n  });\n\n  app.get(\n    \"/system/document-processing-status\",\n    [validatedRequest],\n    async (_, response) => {\n      try {\n        const online = await checkPythonAppAlive();\n        response.sendStatus(online ? 200 : 503);\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.get(\n    \"/system/accepted-document-types\",\n    [validatedRequest],\n    async (_, response) => {\n      try {\n        const types = await acceptedFileTypes();\n        if (!types) {\n          response.sendStatus(404).end();\n          return;\n        }\n\n        response.status(200).json({ types });\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.post(\n    \"/system/update-env\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        const body = reqBody(request);\n        const { newValues, error } = updateENV(body);\n        if (process.env.NODE_ENV === \"production\") await dumpENV();\n        response.status(200).json({ newValues, error });\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.post(\n    \"/system/update-password\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        const { usePassword, newPassword } = reqBody(request);\n        const { error } = updateENV({\n          AuthToken: usePassword ? newPassword : \"\",\n          JWTSecret: usePassword ? v4() : \"\",\n        });\n        response.status(200).json({ success: !error, error });\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.post(\n    \"/system/enable-multi-user\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        const { username, password } = reqBody(request);\n        const multiUserModeEnabled = await SystemSettings.isMultiUserMode();\n        if (multiUserModeEnabled) {\n          response.status(200).json({\n            success: false,\n            error: \"Multi-user mode is already enabled.\",\n          });\n          return;\n        }\n\n        const { user, error } = await User.create({\n          username,\n          password,\n          role: \"admin\",\n        });\n        await SystemSettings.updateSettings({\n          multi_user_mode: true,\n          users_can_delete_workspaces: false,\n          limit_user_messages: false,\n          message_limit: 25,\n        });\n        process.env.AUTH_TOKEN = null;\n        process.env.JWT_SECRET = process.env.JWT_SECRET ?? v4(); // Make sure JWT_SECRET is set for JWT issuance.\n        await Telemetry.sendTelemetry(\"enabled_multi_user_mode\");\n        response.status(200).json({ success: !!user, error });\n      } catch (e) {\n        console.log(e.message, e);\n        response.sendStatus(500).end();\n      }\n    }\n  );\n\n  app.get(\"/system/data-export\", [validatedRequest], async (_, response) => {\n    try {\n      const { filename, error } = await exportData();\n      response.status(200).json({ filename, error });\n    } catch (e) {\n      console.log(e.message, e);\n      response.sendStatus(500).end();\n    }\n  });\n\n  app.get(\n    \"/system/data-exports/:filename\",\n    [validatedRequest],\n    (request, response) => {\n      const exportLocation = __dirname + \"/../storage/exports/\";\n      const sanitized = path\n        .normalize(request.params.filename)\n        .replace(/^(\\.\\.(\\/|\\\\|$))+/, \"\");\n      const finalDestination = path.join(exportLocation, sanitized);\n\n      if (!fs.existsSync(finalDestination)) {\n        response.status(404).json({\n          error: 404,\n          msg: `File ${request.params.filename} does not exist in exports.`,\n        });\n        return;\n      }\n\n      response.download(finalDestination, request.params.filename, (err) => {\n        if (err) {\n          response.send({\n            error: err,\n            msg: \"Problem downloading the file\",\n          });\n        }\n      });\n    }\n  );\n\n  app.post(\n    \"/system/data-import\",\n    handleImports.single(\"file\"),\n    async function (request, response) {\n      const { originalname } = request.file;\n      const { success, error } = await unpackAndOverwriteImport(originalname);\n      response.status(200).json({ success, error });\n    }\n  );\n\n  app.get(\"/system/logo/:mode?\", async function (request, response) {\n    try {\n      const defaultFilename = getDefaultFilename(request.params.mode);\n      const logoPath = await determineLogoFilepath(defaultFilename);\n      const { buffer, size, mime } = fetchLogo(logoPath);\n      response.writeHead(200, {\n        \"Content-Type\": mime || \"image/png\",\n        \"Content-Disposition\": `attachment; filename=${path.basename(\n          logoPath\n        )}`,\n        \"Content-Length\": size,\n      });\n      response.end(Buffer.from(buffer, \"base64\"));\n      return;\n    } catch (error) {\n      console.error(\"Error processing the logo request:\", error);\n      response.status(500).json({ message: \"Internal server error\" });\n    }\n  });\n\n  app.post(\n    \"/system/upload-logo\",\n    [validatedRequest],\n    handleLogoUploads.single(\"logo\"),\n    async (request, response) => {\n      if (!request.file || !request.file.originalname) {\n        return response.status(400).json({ message: \"No logo file provided.\" });\n      }\n\n      if (!validFilename(request.file.originalname)) {\n        return response.status(400).json({\n          message: \"Invalid file name. Please choose a different file.\",\n        });\n      }\n\n      try {\n        if (\n          response.locals.multiUserMode &&\n          response.locals.user?.role !== \"admin\"\n        ) {\n          return response.sendStatus(401).end();\n        }\n\n        const newFilename = await renameLogoFile(request.file.originalname);\n        const existingLogoFilename = await SystemSettings.currentLogoFilename();\n        await removeCustomLogo(existingLogoFilename);\n\n        const { success, error } = await SystemSettings.updateSettings({\n          logo_filename: newFilename,\n        });\n\n        return response.status(success ? 200 : 500).json({\n          message: success\n            ? \"Logo uploaded successfully.\"\n            : error || \"Failed to update with new logo.\",\n        });\n      } catch (error) {\n        console.error(\"Error processing the logo upload:\", error);\n        response.status(500).json({ message: \"Error uploading the logo.\" });\n      }\n    }\n  );\n\n  app.get(\n    \"/system/remove-logo\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        if (\n          response.locals.multiUserMode &&\n          response.locals.user?.role !== \"admin\"\n        ) {\n          return response.sendStatus(401).end();\n        }\n\n        const currentLogoFilename = await SystemSettings.currentLogoFilename();\n        await removeCustomLogo(currentLogoFilename);\n        const { success, error } = await SystemSettings.updateSettings({\n          logo_filename: DARK_LOGO_FILENAME,\n        });\n\n        return response.status(success ? 200 : 500).json({\n          message: success\n            ? \"Logo removed successfully.\"\n            : error || \"Failed to update with new logo.\",\n        });\n      } catch (error) {\n        console.error(\"Error processing the logo removal:\", error);\n        response.status(500).json({ message: \"Error removing the logo.\" });\n      }\n    }\n  );\n\n  app.get(\n    \"/system/can-delete-workspaces\",\n    [validatedRequest],\n    async function (request, response) {\n      try {\n        if (!response.locals.multiUserMode) {\n          return response.status(200).json({ canDelete: true });\n        }\n\n        if (response.locals.user?.role === \"admin\") {\n          return response.status(200).json({ canDelete: true });\n        }\n\n        const canDelete = await SystemSettings.canDeleteWorkspaces();\n        response.status(200).json({ canDelete });\n      } catch (error) {\n        console.error(\"Error fetching can delete workspaces:\", error);\n        response.status(500).json({\n          success: false,\n          message: \"Internal server error\",\n          canDelete: false,\n        });\n      }\n    }\n  );\n\n  app.get(\"/system/welcome-messages\", async function (request, response) {\n    try {\n      const welcomeMessages = await WelcomeMessages.getMessages();\n      response.status(200).json({ success: true, welcomeMessages });\n    } catch (error) {\n      console.error(\"Error fetching welcome messages:\", error);\n      response\n        .status(500)\n        .json({ success: false, message: \"Internal server error\" });\n    }\n  });\n\n  app.post(\n    \"/system/set-welcome-messages\",\n    [validatedRequest],\n    async (request, response) => {\n      try {\n        if (\n          response.locals.multiUserMode &&\n          response.locals.user?.role !== \"admin\"\n        ) {\n          return response.sendStatus(401).end();\n        }\n\n        const { messages = [] } = reqBody(request);\n        if (!Array.isArray(messages)) {\n          return response.status(400).json({\n            success: false,\n            message: \"Invalid message format. Expected an array of messages.\",\n          });\n        }\n\n        await WelcomeMessages.saveAll(messages);\n        return response.status(200).json({\n          success: true,\n          message: \"Welcome messages saved successfully.\",\n        });\n      } catch (error) {\n        console.error(\"Error processing the welcome messages:\", error);\n        response.status(500).json({\n          success: true,\n          message: \"Error saving the welcome messages.\",\n        });\n      }\n    }\n  );\n\n  app.get(\"/system/api-key\", [validatedRequest], async (_, response) => {\n    try {\n      if (response.locals.multiUserMode) {\n        return response.sendStatus(401).end();\n      }\n\n      const apiKey = await ApiKey.get(\"id IS NOT NULL\");\n      return response.status(200).json({\n        apiKey,\n        error: null,\n      });\n    } catch (error) {\n      console.error(error);\n      response.status(500).json({\n        apiKey: null,\n        error: \"Could not find an API Key.\",\n      });\n    }\n  });\n\n  app.post(\n    \"/system/generate-api-key\",\n    [validatedRequest],\n    async (_, response) => {\n      try {\n        if (response.locals.multiUserMode) {\n          return response.sendStatus(401).end();\n        }\n\n        await ApiKey.delete();\n        const { apiKey, error } = await ApiKey.create();\n        return response.status(200).json({\n          apiKey,\n          error,\n        });\n      } catch (error) {\n        console.error(error);\n        response.status(500).json({\n          apiKey: null,\n          error: \"Error generating api key.\",\n        });\n      }\n    }\n  );\n\n  app.delete(\"/system/api-key\", [validatedRequest], async (_, response) => {\n    try {\n      if (response.locals.multiUserMode) {\n        return response.sendStatus(401).end();\n      }\n\n      await ApiKey.delete();\n      return response.status(200).end();\n    } catch (error) {\n      console.error(error);\n      response.status(500).end();\n    }\n  });\n}\n\nmodule.exports = { systemEndpoints };\n"], "filenames": ["frontend/src/components/Modals/MangeWorkspace/Documents/index.jsx", "server/endpoints/system.js"], "buggy_code_start_loc": [180, 26], "buggy_code_end_loc": [182, 458], "fixing_code_start_loc": [180, 27], "fixing_code_end_loc": [183, 469], "type": "CWE-23", "message": "Relative Path Traversal in GitHub repository mintplex-labs/anything-llm prior to 0.0.1.", "other": {"cve": {"id": "CVE-2023-4897", "sourceIdentifier": "security@huntr.dev", "published": "2023-09-11T21:15:42.870", "lastModified": "2023-09-13T14:41:12.663", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Relative Path Traversal in GitHub repository mintplex-labs/anything-llm prior to 0.0.1."}, {"lang": "es", "value": "Path Traversal Relativo en el repositorio de GitHub mintplex-labs/anything-llm anterior a 0.0.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 5.8}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-23"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mintplexlabs:anythingllm:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.0.1", "matchCriteriaId": "43AD14DE-65DD-44BC-AA11-3F1A4EC531D2"}]}]}], "references": [{"url": "https://github.com/mintplex-labs/anything-llm/commit/3c88aec034934bcbad30c5ef1cab62cbbdb98e64", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/0631af48-84a3-4019-85db-f0f8b12cb0ab", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mintplex-labs/anything-llm/commit/3c88aec034934bcbad30c5ef1cab62cbbdb98e64"}}