{"buggy_code": ["# List of the project authors for copyright purposes. When contributing to the\n# project add your name or your organization's name to this list. See\n# CONTRIBUTING.md for details.\n#\n# For organizations:\n#   Organization <email pattern: *@domain>\n#\n# For individuals:\n#   Name <email address>\n#\n# Please keep each list sorted. If you wish to change your email address please\n# send a pull request.\n\n# Organizations:\nCloudinary Ltd. <*@cloudinary.com>\nGoogle LLC <*@google.com>\n\n# Individuals:\nDirk Lemstra <dirk@lemstra.org>\nJon Sneyers <jon@cloudinary.com>\nPieter Wuille\nMarcin Konicki <ahwayakchih@gmail.com>\nZiemowit Zabawa <ziemek.zabawa@outlook.com>\nPetr Dibl\u00edk\n", "// Copyright (c) the JPEG XL Project Authors. All rights reserved.\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include \"lib/extras/codec_apng.h\"\n\n// Parts of this code are taken from apngdis, which has the following license:\n/* APNG Disassembler 2.8\n *\n * Deconstructs APNG files into individual frames.\n *\n * http://apngdis.sourceforge.net\n *\n * Copyright (c) 2010-2015 Max Stepin\n * maxst at users.sourceforge.net\n *\n * zlib license\n * ------------\n *\n * This software is provided 'as-is', without any express or implied\n * warranty.  In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n *    claim that you wrote the original software. If you use this software\n *    in a product, an acknowledgment in the product documentation would be\n *    appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n *    misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#include <algorithm>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"lib/jxl/base/compiler_specific.h\"\n#include \"lib/jxl/color_encoding_internal.h\"\n#include \"lib/jxl/color_management.h\"\n#include \"lib/jxl/frame_header.h\"\n#include \"lib/jxl/headers.h\"\n#include \"lib/jxl/image.h\"\n#include \"lib/jxl/image_bundle.h\"\n#include \"lib/jxl/luminance.h\"\n#include \"png.h\" /* original (unpatched) libpng is ok */\n\nnamespace jxl {\n\nnamespace {\n\nconstexpr bool isAbc(char c) {\n  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n#define notabc(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))\n\nconstexpr uint32_t kId_IHDR = 0x52444849;\nconstexpr uint32_t kId_acTL = 0x4C546361;\nconstexpr uint32_t kId_fcTL = 0x4C546366;\nconstexpr uint32_t kId_IDAT = 0x54414449;\nconstexpr uint32_t kId_fdAT = 0x54416466;\nconstexpr uint32_t kId_IEND = 0x444E4549;\n\nstruct CHUNK {\n  unsigned char* p;\n  unsigned int size;\n};\n\nstruct APNGFrame {\n  unsigned char *p, **rows;\n  unsigned int w, h, delay_num, delay_den;\n};\n\nstruct Reader {\n  const uint8_t* next;\n  const uint8_t* last;\n  bool Read(void* data, size_t len) {\n    size_t cap = last - next;\n    size_t to_copy = std::min(cap, len);\n    memcpy(data, next, to_copy);\n    next += to_copy;\n    return (len == to_copy);\n  }\n  bool Eof() { return next == last; }\n};\n\nconst unsigned long cMaxPNGSize = 1000000UL;\nconst size_t kMaxPNGChunkSize = 100000000;  // 100 MB\n\nvoid info_fn(png_structp png_ptr, png_infop info_ptr) {\n  png_set_expand(png_ptr);\n  png_set_strip_16(png_ptr);\n  png_set_gray_to_rgb(png_ptr);\n  png_set_palette_to_rgb(png_ptr);\n  png_set_add_alpha(png_ptr, 0xff, PNG_FILLER_AFTER);\n  (void)png_set_interlace_handling(png_ptr);\n  png_read_update_info(png_ptr, info_ptr);\n}\n\nvoid row_fn(png_structp png_ptr, png_bytep new_row, png_uint_32 row_num,\n            int pass) {\n  APNGFrame* frame = (APNGFrame*)png_get_progressive_ptr(png_ptr);\n  png_progressive_combine_row(png_ptr, frame->rows[row_num], new_row);\n}\n\ninline unsigned int read_chunk(Reader* r, CHUNK* pChunk) {\n  unsigned char len[4];\n  pChunk->size = 0;\n  pChunk->p = 0;\n  if (r->Read(&len, 4)) {\n    const auto size = png_get_uint_32(len);\n    // Check first, to avoid overflow.\n    if (size > kMaxPNGChunkSize) {\n      JXL_WARNING(\"APNG chunk size is too big\");\n      return 0;\n    }\n    pChunk->size = size + 12;\n    pChunk->p = new unsigned char[pChunk->size];\n    memcpy(pChunk->p, len, 4);\n    if (r->Read(pChunk->p + 4, pChunk->size - 4)) {\n      return *(unsigned int*)(pChunk->p + 4);\n    }\n  }\n  return 0;\n}\n\nint processing_start(png_structp& png_ptr, png_infop& info_ptr, void* frame_ptr,\n                     bool hasInfo, CHUNK& chunkIHDR,\n                     std::vector<CHUNK>& chunksInfo) {\n  unsigned char header[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n\n  png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n  info_ptr = png_create_info_struct(png_ptr);\n  if (!png_ptr || !info_ptr) return 1;\n\n  if (setjmp(png_jmpbuf(png_ptr))) {\n    png_destroy_read_struct(&png_ptr, &info_ptr, 0);\n    return 1;\n  }\n\n  png_set_crc_action(png_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);\n  png_set_progressive_read_fn(png_ptr, frame_ptr, info_fn, row_fn, NULL);\n\n  png_process_data(png_ptr, info_ptr, header, 8);\n  png_process_data(png_ptr, info_ptr, chunkIHDR.p, chunkIHDR.size);\n\n  if (hasInfo) {\n    for (unsigned int i = 0; i < chunksInfo.size(); i++) {\n      png_process_data(png_ptr, info_ptr, chunksInfo[i].p, chunksInfo[i].size);\n    }\n  }\n  return 0;\n}\n\nint processing_data(png_structp png_ptr, png_infop info_ptr, unsigned char* p,\n                    unsigned int size) {\n  if (!png_ptr || !info_ptr) return 1;\n\n  if (setjmp(png_jmpbuf(png_ptr))) {\n    png_destroy_read_struct(&png_ptr, &info_ptr, 0);\n    return 1;\n  }\n\n  png_process_data(png_ptr, info_ptr, p, size);\n  return 0;\n}\n\nint processing_finish(png_structp png_ptr, png_infop info_ptr) {\n  unsigned char footer[12] = {0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130};\n\n  if (!png_ptr || !info_ptr) return 1;\n\n  if (setjmp(png_jmpbuf(png_ptr))) {\n    png_destroy_read_struct(&png_ptr, &info_ptr, 0);\n    return 1;\n  }\n\n  png_process_data(png_ptr, info_ptr, footer, 12);\n  png_destroy_read_struct(&png_ptr, &info_ptr, 0);\n\n  return 0;\n}\n\n}  // namespace\n\nStatus DecodeImageAPNG(Span<const uint8_t> bytes, ThreadPool* pool,\n                       CodecInOut* io) {\n  Reader r;\n  unsigned int id, i, j, w, h, w0, h0, x0, y0;\n  unsigned int delay_num, delay_den, dop, bop, rowbytes, imagesize;\n  unsigned char sig[8];\n  png_structp png_ptr;\n  png_infop info_ptr;\n  CHUNK chunk;\n  CHUNK chunkIHDR;\n  std::vector<CHUNK> chunksInfo;\n  bool isAnimated = false;\n  bool skipFirst = false;\n  bool hasInfo = false;\n  bool all_dispose_bg = true;\n  APNGFrame frameRaw = {};\n\n  r = {bytes.data(), bytes.data() + bytes.size()};\n  // Not an aPNG => not an error\n  unsigned char png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n  if (r.Read(sig, 8) || memcmp(sig, png_signature, 8) != 0) {\n    return false;\n  }\n  id = read_chunk(&r, &chunkIHDR);\n\n  io->frames.clear();\n  io->dec_pixels = 0;\n  io->metadata.m.SetUintSamples(8);\n  io->metadata.m.SetAlphaBits(8);\n  io->metadata.m.color_encoding =\n      ColorEncoding::SRGB();  // todo: get data from png metadata\n  (void)io->dec_hints.Foreach(\n      [](const std::string& key, const std::string& /*value*/) {\n        JXL_WARNING(\"APNG decoder ignoring %s hint\", key.c_str());\n        return true;\n      });\n\n  bool errorstate = true;\n  if (id == kId_IHDR && chunkIHDR.size == 25) {\n    w0 = w = png_get_uint_32(chunkIHDR.p + 8);\n    h0 = h = png_get_uint_32(chunkIHDR.p + 12);\n\n    if (w > cMaxPNGSize || h > cMaxPNGSize) {\n      return false;\n    }\n\n    x0 = 0;\n    y0 = 0;\n    delay_num = 1;\n    delay_den = 10;\n    dop = 0;\n    bop = 0;\n    rowbytes = w * 4;\n    imagesize = h * rowbytes;\n\n    frameRaw.p = new unsigned char[imagesize];\n    frameRaw.rows = new png_bytep[h * sizeof(png_bytep)];\n    for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p + j * rowbytes;\n\n    if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,\n                          chunkIHDR, chunksInfo)) {\n      bool last_base_was_none = true;\n      while (!r.Eof()) {\n        id = read_chunk(&r, &chunk);\n        if (!id) break;\n        JXL_ASSERT(chunk.p != nullptr);\n\n        if (id == kId_acTL && !hasInfo && !isAnimated) {\n          isAnimated = true;\n          skipFirst = true;\n          io->metadata.m.have_animation = true;\n          io->metadata.m.animation.tps_numerator = 1000;\n        } else if (id == kId_IEND ||\n                   (id == kId_fcTL && (!hasInfo || isAnimated))) {\n          if (hasInfo) {\n            if (!processing_finish(png_ptr, info_ptr)) {\n              ImageBundle bundle(&io->metadata.m);\n              bundle.duration = delay_num * 1000 / delay_den;\n              bundle.origin.x0 = x0;\n              bundle.origin.y0 = y0;\n              // TODO(veluca): this could in principle be implemented.\n              if (last_base_was_none && !all_dispose_bg &&\n                  (x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0)) {\n                return JXL_FAILURE(\n                    \"APNG with dispose-to-0 is not supported for non-full or \"\n                    \"blended frames\");\n              }\n              switch (dop) {\n                case 0:\n                  bundle.use_for_next_frame = true;\n                  last_base_was_none = false;\n                  all_dispose_bg = false;\n                  break;\n                case 2:\n                  bundle.use_for_next_frame = false;\n                  all_dispose_bg = false;\n                  break;\n                default:\n                  bundle.use_for_next_frame = false;\n                  last_base_was_none = true;\n              }\n              bundle.blend = bop != 0;\n              io->dec_pixels += w0 * h0;\n\n              Image3F sub_frame(w0, h0);\n              ImageF sub_frame_alpha(w0, h0);\n              for (size_t y = 0; y < h0; ++y) {\n                float* const JXL_RESTRICT row_r = sub_frame.PlaneRow(0, y);\n                float* const JXL_RESTRICT row_g = sub_frame.PlaneRow(1, y);\n                float* const JXL_RESTRICT row_b = sub_frame.PlaneRow(2, y);\n                float* const JXL_RESTRICT row_alpha = sub_frame_alpha.Row(y);\n                uint8_t* const f = frameRaw.rows[y];\n                for (size_t x = 0; x < w0; ++x) {\n                  if (f[4 * x + 3] == 0) {\n                    row_alpha[x] = 0;\n                    row_r[x] = 0;\n                    row_g[x] = 0;\n                    row_b[x] = 0;\n                    continue;\n                  }\n                  row_r[x] = f[4 * x + 0] * (1.f / 255);\n                  row_g[x] = f[4 * x + 1] * (1.f / 255);\n                  row_b[x] = f[4 * x + 2] * (1.f / 255);\n                  row_alpha[x] = f[4 * x + 3] * (1.f / 255);\n                }\n              }\n              bundle.SetFromImage(std::move(sub_frame), ColorEncoding::SRGB());\n              bundle.SetAlpha(std::move(sub_frame_alpha),\n                              /*alpha_is_premultiplied=*/false);\n              io->frames.push_back(std::move(bundle));\n            } else {\n              delete[] chunk.p;\n              break;\n            }\n          }\n\n          if (id == kId_IEND) {\n            errorstate = false;\n            break;\n          }\n          // At this point the old frame is done. Let's start a new one.\n          w0 = png_get_uint_32(chunk.p + 12);\n          h0 = png_get_uint_32(chunk.p + 16);\n          x0 = png_get_uint_32(chunk.p + 20);\n          y0 = png_get_uint_32(chunk.p + 24);\n          delay_num = png_get_uint_16(chunk.p + 28);\n          delay_den = png_get_uint_16(chunk.p + 30);\n          dop = chunk.p[32];\n          bop = chunk.p[33];\n\n          if (w0 > cMaxPNGSize || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||\n              y0 > cMaxPNGSize || x0 + w0 > w || y0 + h0 > h || dop > 2 ||\n              bop > 1) {\n            delete[] chunk.p;\n            break;\n          }\n\n          if (hasInfo) {\n            memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);\n            if (processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,\n                                 chunkIHDR, chunksInfo)) {\n              delete[] chunk.p;\n              break;\n            }\n          } else\n            skipFirst = false;\n\n          if (io->frames.size() == (skipFirst ? 1 : 0)) {\n            bop = 0;\n            if (dop == 2) dop = 1;\n          }\n        } else if (id == kId_IDAT) {\n          hasInfo = true;\n          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {\n            delete[] chunk.p;\n            break;\n          }\n        } else if (id == kId_fdAT && isAnimated) {\n          png_save_uint_32(chunk.p + 4, chunk.size - 16);\n          memcpy(chunk.p + 8, \"IDAT\", 4);\n          if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {\n            delete[] chunk.p;\n            break;\n          }\n        } else if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||\n                   !isAbc(chunk.p[6]) || !isAbc(chunk.p[7])) {\n          delete[] chunk.p;\n          break;\n        } else if (!hasInfo) {\n          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {\n            delete[] chunk.p;\n            break;\n          }\n          chunksInfo.push_back(chunk);\n          continue;\n        }\n        delete[] chunk.p;\n      }\n    }\n    delete[] frameRaw.rows;\n    delete[] frameRaw.p;\n  }\n\n  for (i = 0; i < chunksInfo.size(); i++) delete[] chunksInfo[i].p;\n\n  chunksInfo.clear();\n  delete[] chunkIHDR.p;\n\n  if (errorstate) return false;\n  SetIntensityTarget(io);\n  return true;\n}\n\n}  // namespace jxl\n"], "fixing_code": ["# List of the project authors for copyright purposes. When contributing to the\n# project add your name or your organization's name to this list. See\n# CONTRIBUTING.md for details.\n#\n# For organizations:\n#   Organization <email pattern: *@domain>\n#\n# For individuals:\n#   Name <email address>\n#\n# Please keep each list sorted. If you wish to change your email address please\n# send a pull request.\n\n# Organizations:\nCloudinary Ltd. <*@cloudinary.com>\nGoogle LLC <*@google.com>\n\n# Individuals:\nAlexander Sago <cagelight@gmail.com>\nDirk Lemstra <dirk@lemstra.org>\nJon Sneyers <jon@cloudinary.com>\nPieter Wuille\nMarcin Konicki <ahwayakchih@gmail.com>\nZiemowit Zabawa <ziemek.zabawa@outlook.com>\nPetr Dibl\u00edk\n", "// Copyright (c) the JPEG XL Project Authors. All rights reserved.\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include \"lib/extras/codec_apng.h\"\n\n// Parts of this code are taken from apngdis, which has the following license:\n/* APNG Disassembler 2.8\n *\n * Deconstructs APNG files into individual frames.\n *\n * http://apngdis.sourceforge.net\n *\n * Copyright (c) 2010-2015 Max Stepin\n * maxst at users.sourceforge.net\n *\n * zlib license\n * ------------\n *\n * This software is provided 'as-is', without any express or implied\n * warranty.  In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n *    claim that you wrote the original software. If you use this software\n *    in a product, an acknowledgment in the product documentation would be\n *    appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n *    misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#include <algorithm>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"lib/jxl/base/compiler_specific.h\"\n#include \"lib/jxl/color_encoding_internal.h\"\n#include \"lib/jxl/color_management.h\"\n#include \"lib/jxl/frame_header.h\"\n#include \"lib/jxl/headers.h\"\n#include \"lib/jxl/image.h\"\n#include \"lib/jxl/image_bundle.h\"\n#include \"lib/jxl/luminance.h\"\n#include \"png.h\" /* original (unpatched) libpng is ok */\n\nnamespace jxl {\n\nnamespace {\n\nconstexpr bool isAbc(char c) {\n  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n#define notabc(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))\n\nconstexpr uint32_t kId_IHDR = 0x52444849;\nconstexpr uint32_t kId_acTL = 0x4C546361;\nconstexpr uint32_t kId_fcTL = 0x4C546366;\nconstexpr uint32_t kId_IDAT = 0x54414449;\nconstexpr uint32_t kId_fdAT = 0x54416466;\nconstexpr uint32_t kId_IEND = 0x444E4549;\n\nstruct CHUNK {\n  unsigned char* p;\n  unsigned int size;\n};\n\nstruct APNGFrame {\n  unsigned char *p, **rows;\n  unsigned int w, h, delay_num, delay_den;\n};\n\nstruct Reader {\n  const uint8_t* next;\n  const uint8_t* last;\n  bool Read(void* data, size_t len) {\n    size_t cap = last - next;\n    size_t to_copy = std::min(cap, len);\n    memcpy(data, next, to_copy);\n    next += to_copy;\n    return (len == to_copy);\n  }\n  bool Eof() { return next == last; }\n};\n\nconst unsigned long cMaxPNGSize = 1000000UL;\nconst size_t kMaxPNGChunkSize = 100000000;  // 100 MB\n\nvoid info_fn(png_structp png_ptr, png_infop info_ptr) {\n  png_set_expand(png_ptr);\n  png_set_strip_16(png_ptr);\n  png_set_gray_to_rgb(png_ptr);\n  png_set_palette_to_rgb(png_ptr);\n  png_set_add_alpha(png_ptr, 0xff, PNG_FILLER_AFTER);\n  (void)png_set_interlace_handling(png_ptr);\n  png_read_update_info(png_ptr, info_ptr);\n}\n\nvoid row_fn(png_structp png_ptr, png_bytep new_row, png_uint_32 row_num,\n            int pass) {\n  APNGFrame* frame = (APNGFrame*)png_get_progressive_ptr(png_ptr);\n  png_progressive_combine_row(png_ptr, frame->rows[row_num], new_row);\n}\n\ninline unsigned int read_chunk(Reader* r, CHUNK* pChunk) {\n  unsigned char len[4];\n  pChunk->size = 0;\n  pChunk->p = 0;\n  if (r->Read(&len, 4)) {\n    const auto size = png_get_uint_32(len);\n    // Check first, to avoid overflow.\n    if (size > kMaxPNGChunkSize) {\n      JXL_WARNING(\"APNG chunk size is too big\");\n      return 0;\n    }\n    pChunk->size = size + 12;\n    pChunk->p = new unsigned char[pChunk->size];\n    memcpy(pChunk->p, len, 4);\n    if (r->Read(pChunk->p + 4, pChunk->size - 4)) {\n      return *(unsigned int*)(pChunk->p + 4);\n    }\n  }\n  return 0;\n}\n\nint processing_start(png_structp& png_ptr, png_infop& info_ptr, void* frame_ptr,\n                     bool hasInfo, CHUNK& chunkIHDR,\n                     std::vector<CHUNK>& chunksInfo) {\n  unsigned char header[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n\n  png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n  info_ptr = png_create_info_struct(png_ptr);\n  if (!png_ptr || !info_ptr) return 1;\n\n  if (setjmp(png_jmpbuf(png_ptr))) {\n    png_destroy_read_struct(&png_ptr, &info_ptr, 0);\n    return 1;\n  }\n\n  png_set_crc_action(png_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);\n  png_set_progressive_read_fn(png_ptr, frame_ptr, info_fn, row_fn, NULL);\n\n  png_process_data(png_ptr, info_ptr, header, 8);\n  png_process_data(png_ptr, info_ptr, chunkIHDR.p, chunkIHDR.size);\n\n  if (hasInfo) {\n    for (unsigned int i = 0; i < chunksInfo.size(); i++) {\n      png_process_data(png_ptr, info_ptr, chunksInfo[i].p, chunksInfo[i].size);\n    }\n  }\n  return 0;\n}\n\nint processing_data(png_structp png_ptr, png_infop info_ptr, unsigned char* p,\n                    unsigned int size) {\n  if (!png_ptr || !info_ptr) return 1;\n\n  if (setjmp(png_jmpbuf(png_ptr))) {\n    png_destroy_read_struct(&png_ptr, &info_ptr, 0);\n    return 1;\n  }\n\n  png_process_data(png_ptr, info_ptr, p, size);\n  return 0;\n}\n\nint processing_finish(png_structp png_ptr, png_infop info_ptr) {\n  unsigned char footer[12] = {0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130};\n\n  if (!png_ptr || !info_ptr) return 1;\n\n  if (setjmp(png_jmpbuf(png_ptr))) {\n    png_destroy_read_struct(&png_ptr, &info_ptr, 0);\n    return 1;\n  }\n\n  png_process_data(png_ptr, info_ptr, footer, 12);\n  png_destroy_read_struct(&png_ptr, &info_ptr, 0);\n\n  return 0;\n}\n\n}  // namespace\n\nStatus DecodeImageAPNG(Span<const uint8_t> bytes, ThreadPool* pool,\n                       CodecInOut* io) {\n  Reader r;\n  unsigned int id, i, j, w, h, w0, h0, x0, y0;\n  unsigned int delay_num, delay_den, dop, bop, rowbytes, imagesize;\n  unsigned char sig[8];\n  png_structp png_ptr;\n  png_infop info_ptr;\n  CHUNK chunk;\n  CHUNK chunkIHDR;\n  std::vector<CHUNK> chunksInfo;\n  bool isAnimated = false;\n  bool skipFirst = false;\n  bool hasInfo = false;\n  bool all_dispose_bg = true;\n  APNGFrame frameRaw = {};\n\n  r = {bytes.data(), bytes.data() + bytes.size()};\n  // Not an aPNG => not an error\n  unsigned char png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n  if (r.Read(sig, 8) || memcmp(sig, png_signature, 8) != 0) {\n    return false;\n  }\n  id = read_chunk(&r, &chunkIHDR);\n\n  io->frames.clear();\n  io->dec_pixels = 0;\n  io->metadata.m.SetUintSamples(8);\n  io->metadata.m.SetAlphaBits(8);\n  io->metadata.m.color_encoding =\n      ColorEncoding::SRGB();  // todo: get data from png metadata\n  (void)io->dec_hints.Foreach(\n      [](const std::string& key, const std::string& /*value*/) {\n        JXL_WARNING(\"APNG decoder ignoring %s hint\", key.c_str());\n        return true;\n      });\n\n  bool errorstate = true;\n  if (id == kId_IHDR && chunkIHDR.size == 25) {\n    w0 = w = png_get_uint_32(chunkIHDR.p + 8);\n    h0 = h = png_get_uint_32(chunkIHDR.p + 12);\n\n    if (w > cMaxPNGSize || h > cMaxPNGSize) {\n      return false;\n    }\n\n    x0 = 0;\n    y0 = 0;\n    delay_num = 1;\n    delay_den = 10;\n    dop = 0;\n    bop = 0;\n    rowbytes = w * 4;\n    imagesize = h * rowbytes;\n\n    frameRaw.p = new unsigned char[imagesize];\n    frameRaw.rows = new png_bytep[h * sizeof(png_bytep)];\n    for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p + j * rowbytes;\n\n    if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,\n                          chunkIHDR, chunksInfo)) {\n      bool last_base_was_none = true;\n      while (!r.Eof()) {\n        id = read_chunk(&r, &chunk);\n        if (!id) break;\n        JXL_ASSERT(chunk.p != nullptr);\n\n        if (id == kId_acTL && !hasInfo && !isAnimated) {\n          isAnimated = true;\n          skipFirst = true;\n          io->metadata.m.have_animation = true;\n          io->metadata.m.animation.tps_numerator = 1000;\n        } else if (id == kId_IEND ||\n                   (id == kId_fcTL && (!hasInfo || isAnimated))) {\n          if (hasInfo) {\n            if (!processing_finish(png_ptr, info_ptr)) {\n              ImageBundle bundle(&io->metadata.m);\n              bundle.duration = delay_num * 1000 / delay_den;\n              bundle.origin.x0 = x0;\n              bundle.origin.y0 = y0;\n              // TODO(veluca): this could in principle be implemented.\n              if (last_base_was_none && !all_dispose_bg &&\n                  (x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0)) {\n                return JXL_FAILURE(\n                    \"APNG with dispose-to-0 is not supported for non-full or \"\n                    \"blended frames\");\n              }\n              switch (dop) {\n                case 0:\n                  bundle.use_for_next_frame = true;\n                  last_base_was_none = false;\n                  all_dispose_bg = false;\n                  break;\n                case 2:\n                  bundle.use_for_next_frame = false;\n                  all_dispose_bg = false;\n                  break;\n                default:\n                  bundle.use_for_next_frame = false;\n                  last_base_was_none = true;\n              }\n              bundle.blend = bop != 0;\n              io->dec_pixels += w0 * h0;\n\n              Image3F sub_frame(w0, h0);\n              ImageF sub_frame_alpha(w0, h0);\n              for (size_t y = 0; y < h0; ++y) {\n                float* const JXL_RESTRICT row_r = sub_frame.PlaneRow(0, y);\n                float* const JXL_RESTRICT row_g = sub_frame.PlaneRow(1, y);\n                float* const JXL_RESTRICT row_b = sub_frame.PlaneRow(2, y);\n                float* const JXL_RESTRICT row_alpha = sub_frame_alpha.Row(y);\n                uint8_t* const f = frameRaw.rows[y];\n                for (size_t x = 0; x < w0; ++x) {\n                  if (f[4 * x + 3] == 0) {\n                    row_alpha[x] = 0;\n                    row_r[x] = 0;\n                    row_g[x] = 0;\n                    row_b[x] = 0;\n                    continue;\n                  }\n                  row_r[x] = f[4 * x + 0] * (1.f / 255);\n                  row_g[x] = f[4 * x + 1] * (1.f / 255);\n                  row_b[x] = f[4 * x + 2] * (1.f / 255);\n                  row_alpha[x] = f[4 * x + 3] * (1.f / 255);\n                }\n              }\n              bundle.SetFromImage(std::move(sub_frame), ColorEncoding::SRGB());\n              bundle.SetAlpha(std::move(sub_frame_alpha),\n                              /*alpha_is_premultiplied=*/false);\n              io->frames.push_back(std::move(bundle));\n            } else {\n              delete[] chunk.p;\n              break;\n            }\n          }\n\n          if (id == kId_IEND) {\n            errorstate = false;\n            break;\n          }\n          // At this point the old frame is done. Let's start a new one.\n          w0 = png_get_uint_32(chunk.p + 12);\n          h0 = png_get_uint_32(chunk.p + 16);\n          x0 = png_get_uint_32(chunk.p + 20);\n          y0 = png_get_uint_32(chunk.p + 24);\n          delay_num = png_get_uint_16(chunk.p + 28);\n          delay_den = png_get_uint_16(chunk.p + 30);\n          dop = chunk.p[32];\n          bop = chunk.p[33];\n\n          if (!delay_den) delay_den = 100;\n\n          if (w0 > cMaxPNGSize || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||\n              y0 > cMaxPNGSize || x0 + w0 > w || y0 + h0 > h || dop > 2 ||\n              bop > 1) {\n            delete[] chunk.p;\n            break;\n          }\n\n          if (hasInfo) {\n            memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);\n            if (processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,\n                                 chunkIHDR, chunksInfo)) {\n              delete[] chunk.p;\n              break;\n            }\n          } else\n            skipFirst = false;\n\n          if (io->frames.size() == (skipFirst ? 1 : 0)) {\n            bop = 0;\n            if (dop == 2) dop = 1;\n          }\n        } else if (id == kId_IDAT) {\n          hasInfo = true;\n          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {\n            delete[] chunk.p;\n            break;\n          }\n        } else if (id == kId_fdAT && isAnimated) {\n          png_save_uint_32(chunk.p + 4, chunk.size - 16);\n          memcpy(chunk.p + 8, \"IDAT\", 4);\n          if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {\n            delete[] chunk.p;\n            break;\n          }\n        } else if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||\n                   !isAbc(chunk.p[6]) || !isAbc(chunk.p[7])) {\n          delete[] chunk.p;\n          break;\n        } else if (!hasInfo) {\n          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {\n            delete[] chunk.p;\n            break;\n          }\n          chunksInfo.push_back(chunk);\n          continue;\n        }\n        delete[] chunk.p;\n      }\n    }\n    delete[] frameRaw.rows;\n    delete[] frameRaw.p;\n  }\n\n  for (i = 0; i < chunksInfo.size(); i++) delete[] chunksInfo[i].p;\n\n  chunksInfo.clear();\n  delete[] chunkIHDR.p;\n\n  if (errorstate) return false;\n  SetIntensityTarget(io);\n  return true;\n}\n\n}  // namespace jxl\n"], "filenames": ["AUTHORS", "lib/extras/codec_apng.cc"], "buggy_code_start_loc": [18, 344], "buggy_code_end_loc": [18, 344], "fixing_code_start_loc": [19, 345], "fixing_code_end_loc": [20, 347], "type": "CWE-369", "message": "libjxl v0.3.7 is affected by a Divide By Zero in issue in lib/extras/codec_apng.cc jxl::DecodeImageAPNG(). When encoding a malicous APNG file using cjxl, an attacker can trigger a denial of service.", "other": {"cve": {"id": "CVE-2021-36692", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-30T21:15:09.413", "lastModified": "2021-09-07T20:23:13.163", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libjxl v0.3.7 is affected by a Divide By Zero in issue in lib/extras/codec_apng.cc jxl::DecodeImageAPNG(). When encoding a malicous APNG file using cjxl, an attacker can trigger a denial of service."}, {"lang": "es", "value": "libjxl versi\u00f3n v0.3.7, est\u00e1 afectada por un problema de Divisi\u00f3n Por Cero en el archivo lib/extras/codec_apng.cc en la funci\u00f3n jxl::DecodeImageAPNG(). Cuando se codifica un archivo APNG malicioso usando cjxl, un atacante puede desencadenar una denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libjxl_project:libjxl:0.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "FB6C4691-52AC-49ED-B60C-E5233EEC5EE0"}]}]}], "references": [{"url": "https://github.com/libjxl/libjxl/commit/7dfa400ded53919d986c5d3d23446a09e0cf481b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libjxl/libjxl/issues/308", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/libjxl/libjxl/pull/313", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libjxl/libjxl/commit/7dfa400ded53919d986c5d3d23446a09e0cf481b"}}