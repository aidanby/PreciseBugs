{"buggy_code": ["<?php\n\n/**\n * Settings handler\n *\n * @since  1.0.0\n */\nclass WDS_Multisite_Aggregate_Options {\n\n\tpublic $to_update = '1';\n\tpublic $to_get = '1';\n\n\tfunction get( $key, $default = false ) {\n\t\tif ( $this->to_get == '1' ) {\n\t\t\t$this->to_get = get_site_option( 'sitewide_tags_blog' );\n\t\t}\n\t\tif ( is_array( $this->to_get ) ) {\n\t\t\tif ( $key == 'all' ) {\n\t\t\t\treturn $this->to_get;\n\t\t\t} elseif ( isset( $this->to_get[ $key ] ) ) {\n\t\t\t\treturn $this->to_get[ $key ];\n\t\t\t}\n\t\t}\n\t\treturn get_site_option( $key, $default );\n\t}\n\n\tfunction update( $key, $value = '', $flush = false ) {\n\t\tif ( $this->to_update == '1' ) {\n\t\t\t// don't save unless something has changed\n\t\t\tif ( $key === true ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t$this->to_update = get_site_option( 'sitewide_tags_blog' );\n\t\t}\n\t\tif ( !$this->to_update ) {\n\t\t\t$this->to_update = array();\n\t\t}\n\t\tif ( $key !== true ) {\n\t\t\t$this->to_update[ $key ] = $value;\n\t\t}\n\t\tif ( $flush || $key === true ) {\n\t\t\treturn update_site_option( 'sitewide_tags_blog', $this->to_update );\n\t\t}\n\t}\n\n\tpublic function hooks() {\n\t\tadd_filter( 'sitewide_tags_allowed_post_types', array( $this, 'pages_filter' ) );\n\t}\n\n\tfunction pages_filter( $post_types ) {\n\t\tif ( $this->get( 'tags_blog_pages' ) ) {\n\t\t\t$post_types = array_merge( $post_types, array( 'page' => true ) );\n\t\t}\n\t\treturn $post_types;\n\t}\n\n\tfunction update_options() {\n\t\tglobal $wpdb, $current_site, $wp_version;\n\n\t\tif ( ! isset( $_POST['tags_blog_enabled'] ) || !$_POST['tags_blog_enabled'] ) {\n\t\t\tif ( isset( $_POST['tags_blog_enabled'] ) && $this->get( 'tags_blog_enabled' ) != $_POST['tags_blog_enabled'] )\n\t\t\t\t$this->update( 'tags_blog_enabled', 0, true );\n\t\t\twp_redirect( add_query_arg( array( 'updated' => '1' ) ) );\n\t\t\texit;\n\t\t}\n\t\t$this->update( 'tags_blog_enabled', 1 );\n\n\t\tif ( ( isset( $_POST['tags_blog'] ) || isset( $_POST['tags_blog_main_blog'] ) ) && isset( $_POST['tags_blog_public'] ) ) {\n\t\t\tif ( isset( $_POST['tags_blog_main_blog'] ) && 1 == $_POST['tags_blog_main_blog'] ) {\n\t\t\t\tif ( $current_site->blog_id )\n\t\t\t\t\t$id = $current_site->blog_id;\n\t\t\t\telse\n\t\t\t\t\t$id = $wpdb->get_var( \"SELECT blog_id FROM {$wpdb->blogs} WHERE domain = '{$current_site->domain}' AND path = '{$current_site->path}'\" );\n\t\t\t\tif ( $id ) {\n\t\t\t\t\t$this->update( 'tags_blog_id', $id );\n\t\t\t\t\t$this->update( 'tags_blog_main_blog', 1 );\n\t\t\t\t} else {\n\t\t\t\t\t$this->update( 'tags_blog_main_blog', 0 );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->update( 'tags_blog_main_blog', 0 );\n\t\t\t\t$aggregate_blog = sanitize_title( $_POST['tags_blog'] );\n\t\t\t\t$this->update( 'tags_blog', $aggregate_blog );\n\t\t\t\tif ( constant( 'VHOST' ) == 'yes' ) {\n\t\t\t\t\t$domain = $aggregate_blog . '.' . $current_site->domain;\n\t\t\t\t\t$path = $current_site->path;\n\t\t\t\t} else {\n\t\t\t\t\t$domain = $current_site->domain;\n\t\t\t\t\t$path = trailingslashit( $current_site->path . $aggregate_blog );\n\t\t\t\t}\n\t\t\t\t$aggregate_blog_id = $wpdb->get_var( \"SELECT blog_id FROM {$wpdb->blogs} WHERE domain = '$domain' AND path = '$path'\" );\n\t\t\t\tif ( $aggregate_blog_id ) {\n\t\t\t\t\t$this->update( 'tags_blog_id', $aggregate_blog_id );\n\t\t\t\t} else {\n\t\t\t\t\t$wpdb->hide_errors();\n\t\t\t\t\t$id = wpmu_create_blog( $domain, $path, __( 'Network Posts', 'wds-multisite-aggregate' ), get_current_user_id() , array( 'public' => $_POST['tags_blog_public'] ), $current_site->id);\n\t\t\t\t\t$this->update( 'tags_blog_id', $id );\n\t\t\t\t\t$wpdb->show_errors();\n\t\t\t\t}\n\t\t\t}\n\t\t\t$aggregate_blog_public = (int) $_POST['tags_blog_public'];\n\t\t\t$this->update( 'tags_blog_public', $aggregate_blog_public );\n\t\t\tupdate_blog_option( $aggregate_blog_id, 'blog_public', $aggregate_blog_public );\n\t\t\tupdate_blog_status( $aggregate_blog_id, 'public', $aggregate_blog_public);\n\t\t}\n\n\t\t$options_as_integers = array(\n\t\t\t'tags_max_posts',\n\t\t);\n\t\tforeach ( $options_as_integers as $option_key ) {\n\t\t\tif ( $set = $this->make_integer_from_request( $option_key ) ) {\n\t\t\t\t$this->update( $option_key, $set );\n\t\t\t}\n\t\t}\n\n\t\t$options_as_integers_maybe_set = array(\n\t\t\t'tags_blog_thumbs',\n\t\t\t'tags_blog_pages',\n\t\t\t'populate_all_blogs',\n\t\t);\n\t\tforeach ( $options_as_integers_maybe_set as $option_key ) {\n\t\t\t$set = $this->make_integer_from_request( $option_key );\n\t\t\tif ( $set != $this->get( $option_key ) ) {\n\t\t\t\t$this->update( $option_key, $set );\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( $set = $this->make_integer_from_request( 'tags_blog_pub_check' ) ) && $set != $this->get( 'tags_blog_pub_check' ) ) {\n\t\t\t$set = $aggregate_blog_public == 0 ? $set : 0;\n\t\t\t$this->update( 'tags_blog_pub_check', $set );\n\t\t}\n\n\t\tif ( isset( $_POST['tags_blog_postmeta'] ) && '' != $_POST['tags_blog_postmeta'] ) {\n\t\t\t$meta_keys = explode( \"\\n\", strip_tags( stripslashes( $_POST['tags_blog_postmeta'] ) ) );\n\t\t\t$this->update( 'tags_blog_postmeta', array_map( 'trim', $meta_keys ) );\n\t\t} else {\n\t\t\t$this->update( 'tags_blog_postmeta', '' );\n\t\t}\n\n\t\t$blogs_to_import = $this->comma_delimited_to_array_from_request( 'blogs_to_import' );\n\t\t$this->update( 'blogs_to_import', $blogs_to_import );\n\n\t\t// force write if changes saved\n\t\t$this->update( true );\n\t\twp_redirect( add_query_arg( array( 'updated' => '1' ) ) );\n\t\texit;\n\t}\n\n\tfunction make_integer_from_request( $key ) {\n\t\treturn isset( $_REQUEST[ $key ] ) ? (int) $_REQUEST[ $key ] : 0;\n\t}\n\n\tfunction comma_delimited_to_array_from_request( $key ) {\n\t\treturn isset( $_REQUEST[ $key ] ) ? $this->comma_delimited_to_array( $_REQUEST[ $key ] ) : array();\n\t}\n\n\tfunction comma_delimited_to_array( $string ) {\n\t\t$array = (array) explode( ',', $string );\n\t\t$array = array_map( 'trim', $array );\n\t\t$array = array_map( array( $this, 'make_int' ), $array );\n\t\t$array = array_filter( $array );\n\t\treturn $array;\n\t}\n\n\n\tfunction make_int( $item ) {\n\t\treturn (int) str_ireplace( ' ', '', $item );\n\t}\n\n}\n", "# WDS Multisite Aggregate #\n**Contributors:** donncha, imwebgefunden, wpmuguru, WebDevStudios, jtsternberg, Mamaduka  \n**Tags:** wordpressmu  \n**Tested up to:** 3.8.1  \n**Stable tag:** 1.0.0  \n**Requires at least:** 3.0  \n\nA central area where all the posts on a WordPress multisite network can be collected.\n\n## Description ##\nCreates a new site where all the most recent posts/pages/etc on a WordPress network may be collected (much like http://wordpress.com/tags/).\n\nFor performance reasons the number of posts is limited to a user configurable amount, and the blog itself can be made indexable by search engines or not.\n\nBased on [WordPress MU Sitewide Tags Pages](https://wordpress.org/plugins/wordpress-mu-sitewide-tags/) plugin by Donncha O Caoimh.\n\nWPCLI is supported:\n`wp multisite_aggregate --help`.\n\n## Install ##\n1. Install in your plugins directory in the usual way and network activate the plugin. There is no need to put it in mu-plugins.\n2. Login as a site administrator and go to Super Admin->Sitewide Tags.\n\t1. Aggregate site defaults to \"Network Posts\" but can be anything. This is the blog where your sitewide posts will live. It will be created if it doesn't exist.\n\t2. Check \"Post to main blog\" to use your main blog as the aggregate blog.\n\t3. \"Max posts\" defaults to 5000. Older posts will be deleted if this threshold is broken.\n\t4. Check \"Include Pages\" to include both posts and pages, handy for making a sitewide search.\n\t5. \"Privacy\" defaults to public, pages can be indexed by search engines.\n\t6. When \"Privacy\" is not public, check \"Non-Public Blogs\" to include blogs not indexed by search engines.\n\t7. Add \"Post Meta\" custom fields to be copied with posts/pages.\n\t8. \"Populate Posts\" allows you to fill in posts from an existing blog.\n\n## Changelog ##\n\n### 1.0.0 ###\n* Forked from 'MU Sitewide Tags' and rewritten with OOP principles, WordPress coding standards, and extensibility in mind.\n\n### 0.4.2 ###\n* duplicate category fix\n* page permalink fix\n* thumbnail size filter\n\n### 0.4.1.1 ###\n* Run populate feature in source blog context.\n* Added resource warning for populate feature.\n* Fixed PHP warnings.\n* Only insert categories for published posts.\n\n### 0.4.1 ###\n* Move SWT admin to its own screen.\n* Added thumbnail support.\n* Added custom taxonomy (including post formats) support.\n* Update admin screens for WordPress 3.1.\n\n### 0.4.0.1 ###\n* Bug fix - only push published content to the tags blog\n\n### 0.4 ###\n* Added option to include pages in tags blog.\n* Added option to include non search engine indexed blogs if tags blog not indexed.\n* Added option for post meta to be copied with post.\n", "=== WDS Multisite Aggregate ===\nContributors: donncha, imwebgefunden, wpmuguru, WebDevStudios, jtsternberg, Mamaduka\nTags: wordpressmu\nTested up to: 3.8.1\nStable tag: 1.0.0\nRequires at least: 3.0\n\nA central area where all the posts on a WordPress MS network can be collected.\n\n== Description ==\nCreates a new site where all the most recent posts/pages/etc on a WordPress network may be collected (much like http://wordpress.com/tags/).\n\nFor performance reasons the number of posts is limited to a user configurable amount, and the blog itself can be made indexable by search engines or not.\n\nBased on and forked from [WordPress MU Sitewide Tags Pages](https://wordpress.org/plugins/wordpress-mu-sitewide-tags/) plugin by Donncha O Caoimh.\n\nWPCLI is supported:\n`wp multisite_aggregate --help`.\n\n== Install ==\n1. Install in your plugins directory in the usual way and network activate the plugin. There is no need to put it in mu-plugins.\n2. Login as a site administrator and go to Super Admin->Sitewide Tags.\n\t1. Aggregate site defaults to \"Network Posts\" but can be anything. This is the blog where your sitewide posts will live. It will be created if it doesn't exist.\n\t2. Check \"Post to main blog\" to use your main blog as the aggregate blog.\n\t3. \"Max posts\" defaults to 5000. Older posts will be deleted if this threshold is broken.\n\t4. Check \"Include Pages\" to include both posts and pages, handy for making a sitewide search.\n\t5. \"Privacy\" defaults to public, pages can be indexed by search engines.\n\t6. When \"Privacy\" is not public, check \"Non-Public Blogs\" to include blogs not indexed by search engines.\n\t7. Add \"Post Meta\" custom fields to be copied with posts/pages.\n\t8. \"Populate Posts\" allows you to fill in posts from an existing blog.\n\n== Changelog ==\n\n= 1.0.0 =\n* Forked from 'MU Sitewide Tags' and rewritten with OOP principles, WordPress coding standards, and extensibility in mind.\n\n= 0.4.2 =\n* duplicate category fix\n* page permalink fix\n* thumbnail size filter\n\n= 0.4.1.1 =\n* Run populate feature in source blog context.\n* Added resource warning for populate feature.\n* Fixed PHP warnings.\n* Only insert categories for published posts.\n\n= 0.4.1 =\n* Move SWT admin to its own screen.\n* Added thumbnail support.\n* Added custom taxonomy (including post formats) support.\n* Update admin screens for WordPress 3.1.\n\n= 0.4.0.1 =\n* Bug fix - only push published content to the tags blog\n\n= 0.4 =\n* Added option to include pages in tags blog.\n* Added option to include non search engine indexed blogs if tags blog not indexed.\n* Added option for post meta to be copied with post.\n", "<?php\n/*\nPlugin Name: WDS Multisite Aggregate\nPlugin URI: https://github.com/WebDevStudios/WDS-Multisite-Aggregate\nDescription: Creates a blog where all the most recent posts on a WordPress network may be found. Based on WordPress MU Sitewide Tags Pages plugin by Donncha O Caoimh. WP-CLI: `wp multisite_aggregate --help`.\nVersion: 1.0.0\nAuthor: WebDevStudios\nAuthor URI: http://webdevstudios.com\n*/\n/*  Copyright 2008 Donncha O Caoimh (http://ocaoimh.ie/)\n    With contributions by Ron Rennick(http://wpmututorials.com/), Thomas Schneider(http://www.im-web-gefunden.de/) and others.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n\n/**\n * Autoloads files with classes when needed\n * @since  1.0.0\n * @param  string $class_name Name of the class being requested\n */\nfunction wds_ma_autoload_classes( $class_name ) {\n\tif ( class_exists( $class_name, false ) ) {\n\t\treturn;\n\t}\n\n\t$file = dirname( __FILE__ ) .'/includes/'. $class_name .'.php';\n\tif ( file_exists( $file ) ) {\n\t\t@include_once( $file );\n\t}\n}\nspl_autoload_register( 'wds_ma_autoload_classes' );\n\n/**\n * Get it started\n *\n * @since  1.0.0\n */\nclass WDS_Multisite_Aggregate {\n\n\tprotected $imported        = array();\n\tprotected $total_imported  = 0;\n\tprotected $doing_save_post = false;\n\tprotected $debug           = false;\n\n\tpublic function __construct() {\n\t\t// Options setter/getter and handles updating options on save\n\t\t$this->options = new WDS_Multisite_Aggregate_Options();\n\t\t$this->options->hooks();\n\t\t// Handles Admin display\n\t\t$this->admin = new WDS_Multisite_Aggregate_Admin( $this->options );\n\t\t$this->admin->hooks();\n\t\t// Handles removing posts from removed blogs\n\t\t$this->remove = new WDS_Multisite_Aggregate_Remove( $this->options );\n\t\t$this->remove->hooks();\n\t\t// Handles frontend modification for aggregate site\n\t\t$this->frontend = new WDS_Multisite_Aggregate_Frontend( $this->options );\n\t\t$this->frontend->hooks();\n\n\t\tif ( isset( $_REQUEST['aggregate_debug'] ) ) {\n\t\t\t$this->debug = new WDS_Multisite_Aggregate_Debug();\n\t\t\t$this->debug->hooks();\n\t\t}\n\t}\n\n\tfunction hooks() {\n\t\tadd_action( 'save_post', array( $this, 'do_post_sync' ), 10, 2 );\n\t\tadd_action( 'wds_multisite_aggregate_post_sync', array( $this, 'save_meta_fields' ), 10, 2 );\n\t\tadd_action( 'wp_update_comment_count', array( $this, 'do_comment_sync' ) );\n\n\t\tadd_action( 'trash_post', array( $this, 'sync_post_delete' ) );\n\t\tadd_action( 'delete_post', array( $this, 'sync_post_delete' ) );\n\n\t\tif ( ! empty( $_GET['action'] ) && 'populate_posts_from_blog' == $_GET['action'] ) {\n\t\t\tdefine( 'WDS_Multisite_Aggregate', true );\n\t\t\tadd_action( 'init', array( $this, 'populate_posts_from_blog' ), 8 );\n\t\t}\n\t\tif ( ! empty( $_GET['page'] ) && 'wds-multisite-aggregate' == $_GET['page'] ) {\n\t\t\tadd_action( 'admin_init', array( $this, 'context_hooks' ) );\n\t\t}\n\n\t}\n\n\tpublic function context_hooks() {\n\t\tif ( isset( $_GET['total_imported'] ) ) {\n\t\t\tadd_action( 'all_admin_notices', array( $this, 'user_notice' ) );\n\t\t}\n\n\t\t$valid_nonce = isset( $_REQUEST['_wpnonce'] ) ? wp_verify_nonce( $_REQUEST['_wpnonce'], 'wds-multisite-aggregate' ) : false;\n\n\t\tif ( ! $valid_nonce ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( isset( $_GET['action'] ) && 'populate_from_blogs' == $_GET['action'] ) {\n\t\t\treturn $this->populate_from_blogs();\n\t\t}\n\n\t\tif ( ! empty( $_POST ) ) {\n\t\t\t$this->options->update_options();\n\t\t}\n\t}\n\n\tfunction populate_from_blogs() {\n\t\tglobal $wpdb;\n\n\t\t$this->total_imported = $this->options->make_integer_from_request( 'total_imported' );\n\t\t$post_count           = $this->options->make_integer_from_request( 'post_count' );\n\n\t\t// Check query string\n\t\t$blogs_to_import      = $this->options->comma_delimited_to_array_from_request( 'blogs_to_import' );\n\t\t// No query string? Check options\n\t\t$blogs_to_import      = ! empty( $blogs_to_import ) ? $blogs_to_import : $this->get_blogs_to_import();\n\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\t\tif ( ! $tags_blog_id || empty( $blogs_to_import ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$blog_to_populate = array_shift( $blogs_to_import );\n\n\t\tif ( $blog_to_populate != $tags_blog_id ) {\n\t\t\t$this->imported = array();\n\n\t\t\t$details = get_blog_details( $blog_to_populate );\n\t\t\t$url = add_query_arg( array(\n\t\t\t\t'post_count' => $post_count,\n\t\t\t\t'action'     => 'populate_posts_from_blog',\n\t\t\t\t'key'        => md5( serialize( $details ) )\n\t\t\t), $details->siteurl );\n\n\t\t\t$post_count  = 0;\n\t\t\t$_post_count = 0;\n\t\t\t$result      = wp_remote_get( $url );\n\t\t\tif ( is_wp_error( $result ) ) {\n\t\t\t\twp_die( $result->get_error_message() );\n\t\t\t}\n\t\t\t$response = wp_remote_retrieve_body( $result );\n\n\t\t\tif ( $response ) {\n\t\t\t\t$json = json_decode( $response );\n\t\t\t\t$data = $json->success ? $json->data : false;\n\t\t\t\tif ( $data ) {\n\t\t\t\t\t$this->total_imported = $this->total_imported + count( $data->posts_imported );\n\t\t\t\t\t$this->imported = (array) $data->posts_imported;\n\t\t\t\t\t$_post_count = (int) $data->posts_done;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $_post_count ) {\n\t\t\t\t$post_count = $_post_count;\n\t\t\t}\n\t\t}\n\n\t\tif ( $post_count || ! empty( $blogs_to_import ) ) {\n\n\t\t\t$url = network_admin_url( 'settings.php' );\n\t\t\t$args = array(\n\t\t\t\t'page'           => 'wds-multisite-aggregate',\n\t\t\t\t'action'         => 'populate_from_blogs',\n\t\t\t\t'post_count'     => $post_count,\n\t\t\t\t'total_imported' => (int) $this->total_imported,\n\t\t\t\t'next_blog'      => true,\n\t\t\t);\n\t\t\tif ( ! empty( $blogs_to_import ) ) {\n\t\t\t\t$args['blogs_to_import'] = implode( ',', $blogs_to_import );\n\t\t\t}\n\t\t\t$url = add_query_arg( $args, wp_nonce_url( $url , 'wds-multisite-aggregate' ) );\n\n\t\t\t$count = $this->strong_red( count( $this->imported ) );\n\t\t\t$finished_blog = $this->strong_red( sprintf( __( 'Blog %d', 'wds-multisite-aggregate' ), (int) $blog_to_populate ), false );\n\t\t\t$next_blog = $this->strong_red( sprintf( __( 'Blog %d', 'wds-multisite-aggregate' ), array_shift( $blogs_to_import ) ), false );\n\n\t\t\t$msg = $this->heading( sprintf( __( 'Imported %s posts from %s', 'wds-multisite-aggregate' ), $count, $finished_blog ) );\n\t\t\t$desc = $this->notice_description( sprintf( __( 'Please wait while posts from %s are imported.', 'wds-multisite-aggregate' ), $next_blog ) );\n\n\t\t\twp_die( $msg . $desc . $this->js_redirect( $url, 1 ) );\n\n\t\t}\n\n\t\t$this->save_user_notice();\n\t\twp_redirect( $this->admin->url() );\n\t\texit;\n\n\t}\n\n\t/**\n\t * run populate function in local blog context because get_permalink does not produce the correct permalinks while switched\n\t */\n\tfunction populate_posts_from_blog() {\n\t\tglobal $wpdb;\n\t\t$valid_key = isset( $_REQUEST['key'] ) ? $_REQUEST['key'] == md5( serialize( get_blog_details( $wpdb->blogid ) ) ) : false;\n\t\tif ( ! $valid_key ) {\n\t\t\treturn $this->error( 'not a valid key.' );\n\t\t}\n\t\t$this->_populate_posts_from_blog( array(\n\t\t\t'post_count' => isset( $_GET['post_count'] ) ? (int) $_GET['post_count'] : 0,\n\t\t) );\n\t}\n\n\t/**\n\t * run populate function in local blog context because get_permalink does not produce the correct permalinks while switched\n\t */\n\tfunction _populate_posts_from_blog( $args = array() ) {\n\t\tglobal $wpdb;\n\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\t\t$tags_blog_enabled = $this->options->get( 'tags_blog_enabled' );\n\n\t\tif ( ! $tags_blog_enabled || ! $tags_blog_id || $tags_blog_id == $wpdb->blogid ) {\n\t\t\treturn $this->error( 'Aggregate blog not enabled OR there is no aggregate blog ID OR the current site IS the aggregate blog.' );\n\t\t}\n\n\t\t$posts_done = 0;\n\t\t$post_count = isset( $args['post_count'] ) ? (int) $args['post_count'] : 0; // post count\n\t\twhile ( $posts_done < 300 ) {\n\t\t\t$args = array(\n\t\t\t\t'fields'         => 'ids',\n\t\t\t\t'offset'         => $post_count + $posts_done,\n\t\t\t\t'posts_per_page' => 50,\n\t\t\t\t'post_status'    => 'publish',\n\t\t\t);\n\t\t\t$posts = get_posts( $args );\n\n\t\t\tif ( empty( $posts ) ) {\n\t\t\t\treturn $this->success( array(\n\t\t\t\t\t'posts_done'     => 0,\n\t\t\t\t\t'posts_imported' => $this->imported,\n\t\t\t\t) );\n\t\t\t}\n\n\t\t\tforeach ( $posts as $post ) {\n\t\t\t\tif ( 1 != $post && 2 != $post ) {\n\t\t\t\t\t$maybe_error = $this->do_post_sync( $post, get_post( $post ) );\n\n\t\t\t\t\tif ( $maybe_error ) {\n\t\t\t\t\t\treturn $this->error( $maybe_error );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$posts_done += 50;\n\t\t}\n\n\t\treturn $this->success( array(\n\t\t\t'posts_done'     => $posts_done,\n\t\t\t'posts_imported' => $this->imported,\n\t\t) );\n\t\texit( $posts_done );\n\t}\n\n\tfunction do_post_sync( $post_id, $post ) {\n\t\t$this->post_id = $post_id;\n\t\t$this->post    = $post;\n\n\t\tif ( $this->doing_save_post ) {\n\t\t\treturn $this->add_post_sync_hook();\n\t\t}\n\n\t\tif ( $error = $this->check_for_site_problems() ) {\n\t\t\treturn $this->error_if_wpcli( $error );\n\t\t}\n\n\t\t// wp_insert_category()\n\t\tinclude_once( ABSPATH . 'wp-admin/includes/admin.php' );\n\n\t\t$allowed_post_types = apply_filters( 'sitewide_tags_allowed_post_types', array( 'post' => true ) );\n\t\tif ( ! isset( $allowed_post_types[ $post->post_type ] ) || ! $allowed_post_types[ $post->post_type ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$post_categories = wp_get_object_terms( $post_id, 'category' );\n\n\t\tif ( $post_categories && ! is_wp_error( $post_categories ) && is_array( $post_categories ) ) {\n\t\t\t$post->post_category = wp_list_pluck( $post_categories, 'term_id' );\n\t\t} else {\n\t\t\t$post->post_category = wp_get_post_categories( $post_id );\n\t\t}\n\n\t\t$post->tags_input = implode( ', ', wp_get_post_tags( $post_id, array( 'fields' => 'names', ) ) );\n\n\t\tglobal $wpdb;\n\t\t$post_blog_id = $wpdb->blogid;\n\t\t$post->guid = \"{$post_blog_id}.{$post_id}\";\n\n\t\t$this->global_meta = array();\n\t\t$meta_keys = apply_filters( 'sitewide_tags_meta_keys', $this->options->get( 'tags_blog_postmeta', array() ) );\n\t\tif ( is_array( $meta_keys ) && ! empty( $meta_keys ) ) {\n\t\t\tforeach ( $meta_keys as $key ) {\n\t\t\t\t$this->global_meta[ $key ] = get_post_meta( $post->ID, $key, true );\n\t\t\t}\n\t\t}\n\t\tunset( $meta_keys );\n\n\t\t$this->global_meta['permalink'] = get_permalink( $post_id );\n\t\t$this->global_meta['blogid'] = $post_blog_id; // org_blog_id\n\n\t\tif ( $this->options->get( 'tags_blog_thumbs' ) && ( $thumb_id = get_post_thumbnail_id( $post->ID ) ) ) {\n\n\t\t\t$thumb_sizes = apply_filters( 'sitewide_tags_thumb_size', array(\n\t\t\t\t'thumbnail' ) );\n\n\t\t\t// back-compat\n\t\t\tif ( is_string( $thumb_sizes ) ) {\n\t\t\t\t$this->global_meta['thumbnail_html'] = wp_get_attachment_image( $thumb_id, $thumb_sizes );\n\t\t\t} else {\n\t\t\t\t// back-compat\n\t\t\t\t$this->global_meta['thumbnail_html'] = wp_get_attachment_image( $thumb_id, 'thumbnail' );\n\t\t\t}\n\n\t\t\t// new hawtness\n\t\t\tforeach ( (array) $thumb_sizes as $thumb_size ) {\n\t\t\t\t$this->global_meta[ \"thumbnail_html_$thumb_size\" ] = wp_get_attachment_image( $thumb_id, $thumb_size );\n\t\t\t}\n\t\t}\n\n\t\t// custom taxonomies\n\t\t$taxonomies = apply_filters( 'sitewide_tags_custom_taxonomies', array() );\n\t\tif ( ! empty( $taxonomies ) && 'publish' == $post->post_status ) {\n\t\t\t$registered_tax = array_diff( get_taxonomies(), array( 'post_tag', 'category', 'link_category', 'nav_menu' ) );\n\t\t\t$custom_tax = array_intersect( $taxonomies, $registered_tax );\n\t\t\t$tax_input = array();\n\t\t\tforeach ( $custom_tax as $tax ) {\n\t\t\t\t$terms = wp_get_object_terms( $post_id, $tax, array( 'fields' => 'names' ) );\n\t\t\t\tif ( empty( $terms ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( is_taxonomy_hierarchical( $tax ) ) {\n\t\t\t\t\t$tax_input[ $tax ] = $terms;\n\t\t\t\t} else {\n\t\t\t\t\t$tax_input[ $tax ] = implode( ',', $terms );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( ! empty( $tax_input ) ) {\n\t\t\t\t$post->tax_input = $tax_input;\n\t\t\t}\n\t\t}\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\n\t\tswitch_to_blog( $tags_blog_id );\n\n\t\t$category_ids = array();\n\t\tif ( is_array( $post_categories ) && ! empty( $post_categories ) && 'publish' == $post->post_status ) {\n\t\t\tforeach ( $post_categories as $t => $category ) {\n\t\t\t\t$term = get_term_by( 'slug', $category->slug, 'category' );\n\t\t\t\t$term = apply_filters( 'sitewide_tags_get_term', $term, $category, $this );\n\t\t\t\tif ( $this->debug ) {\n\t\t\t\t\techo '<xmp>$category_to_migrate: '. print_r( $category, true ) .'</xmp>';\n\t\t\t\t\techo '<xmp>$term_on_aggregate: '. print_r( $term, true ) .'</xmp>';\n\t\t\t\t}\n\t\t\t\tif ( $term && 0 == $term->parent ) {\n\t\t\t\t\t$category_ids[] = $term->term_id;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Here is where we insert the category if necessary\n\t\t\t\t$category_id = wp_insert_category( array(\n\t\t\t\t\t'cat_name'             => $category->name,\n\t\t\t\t\t'category_description' => $category->name,\n\t\t\t\t\t'category_nicename'    => $category->slug,\n\t\t\t\t\t'category_parent'      => '',\n\t\t\t\t), true );\n\n\t\t\t\tif (\n\t\t\t\t\tis_wp_error( $category_id )\n\t\t\t\t\t&& false !== stripos( $category_id->get_error_message(), 'already exists' )\n\t\t\t\t\t&& is_numeric( $category_id->get_error_data() )\n\t\t\t\t) {\n\t\t\t\t\t$category_ids[] = $category_id->get_error_data();\n\t\t\t\t} elseif ( is_numeric( $category_id ) ) {\n\t\t\t\t\t$category_ids[] = $category_id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->debug ) {\n\t\t\twp_die( '<xmp>$category_ids_to_add_to_post: '. print_r( $category_ids, true ) .'</xmp>' );\n\t\t}\n\n\t\t$global_post = $wpdb->get_row( $wpdb->prepare( \"SELECT * FROM {$wpdb->posts} WHERE guid IN (%s,%s)\", $post->guid, esc_url( $post->guid ) ) );\n\t\tif ( 'publish' != $post->post_status && is_object( $global_post ) && isset( $global_post->ID ) ) {\n\t\t\twp_delete_post( $global_post->ID );\n\t\t} else {\n\t\t\tif ( isset( $global_post->ID ) && $global_post->ID != '' ) {\n\t\t\t\t$post->ID = $global_post->ID; // editing an old post\n\n\t\t\t\tforeach ( array_keys( $this->global_meta ) as $key ) {\n\t\t\t\t\tdelete_post_meta( $global_post->ID, $key );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunset( $post->ID ); // new post\n\t\t\t}\n\t\t}\n\t\tif ( 'publish' == $post->post_status ) {\n\t\t\t$post->ping_status = 'closed';\n\t\t\t$post->comment_status = 'closed';\n\n\t\t\t// Use the category IDs in the post\n\t\t\t$post->post_category = $category_ids;\n\t\t\t$this->doing_save_post = true;\n\t\t\tif ( $post_id = wp_insert_post( $post, true ) && ! is_wp_error( $post_id ) ) {\n\t\t\t\t$this->imported[] = $post;\n\t\t\t}\n\t\t}\n\n\t\trestore_current_blog();\n\t}\n\n\tfunction check_for_site_problems() {\n\t\tglobal $wpdb;\n\n\t\tif ( ! $this->options->get( 'tags_blog_enabled' ) ) {\n\t\t\treturn __( 'Multisite Aggregate not enabled.', 'wds-multisite-aggregate' );\n\t\t}\n\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\t\tif ( ! $tags_blog_id || $tags_blog_id == $wpdb->blogid ) {\n\t\t\treturn __( 'No Multisite Aggregate blog ID, or current blog is Multisite Aggregate blog.', 'wds-multisite-aggregate' );\n\t\t}\n\n\t\t$blogs_to_import = $this->get_blogs_to_import();\n\t\tif ( ! in_array( (int) $wpdb->blogid, $blogs_to_import ) ) {\n\t\t\treturn __( 'Blog ID is not saved to the \"Blogs to Aggregate\" setting.', 'wds-multisite-aggregate' );\n\t\t}\n\n\t\t$blog_status = get_blog_status( $wpdb->blogid, 'public' );\n\n\t\tif ( 1 != $blog_status && ( 0 != $blog_status || 1 == $this->options->get( 'tags_blog_public' ) || 0 == $this->options->get( 'tags_blog_pub_check' ) ) ) {\n\t\t\treturn __( \"This blog's status is not set to public\", 'wds-multisite-aggregate' );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic function add_post_sync_hook() {\n\t\tdo_action( 'wds_multisite_aggregate_post_sync', $this->post_id, $this->post );\n\t\t$this->doing_save_post = false;\n\t}\n\n\tpublic function save_meta_fields( $post_id, $post ) {\n\t\t$updated = array();\n\t\tforeach ( $this->global_meta as $key => $value ) {\n\t\t\tif ( $value ) {\n\t\t\t\t$updated[ $key ] = add_post_meta( $post_id, $key, $value );\n\t\t\t}\n\t\t}\n\t\t// return $this->error( compact( 'post_id', 'updated', 'post' ) );\n\t}\n\n\tfunction do_comment_sync( $post_id ) {\n\t\tglobal $wpdb;\n\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\n\t\tif ( ! $tags_blog_id || $tags_blog_id == $wpdb->blogid ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$post_blog_id = $wpdb->blogid;\n\n\t\t$new = (int) $wpdb->get_var( $wpdb->prepare( \"SELECT COUNT(*) FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_approved = '1'\", $post_id ) );\n\n\t\tswitch_to_blog( $tags_blog_id );\n\n\t\t$guid = \"{$post_blog_id}.{$post_id}\";\n\n\t\t$global_post_id = $wpdb->get_var( $wpdb->prepare( \"SELECT ID FROM {$wpdb->posts} WHERE guid IN (%s,%s)\", $guid, esc_url( $guid ) ) );\n\n\t\tif ( null !== $global_post_id ) {\n\t\t\t$wpdb->update( $wpdb->posts, array( 'comment_count' => $new ), array( 'ID' => $global_post_id ) );\n\t\t\tclean_post_cache( $global_post_id );\n\t\t}\n\n\t\trestore_current_blog();\n\t}\n\n\tfunction sync_post_delete( $post_id ) {\n\t\tglobal $wpdb;\n\t\t/*\n\t\t * what should we do if a post will be deleted and the tags blog feature is disabled?\n\t\t * need an check if we have a post on the tags blog and if so - delete this\n\t\t */\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\n\t\tif ( ! $tags_blog_id || $wpdb->blogid == $tags_blog_id ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$post_blog_id = $wpdb->blogid;\n\t\tswitch_to_blog( $tags_blog_id );\n\n\t\t$guid = \"{$post_blog_id}.{$post_id}\";\n\n\t\t$global_post_id = $wpdb->get_var( $wpdb->prepare( \"SELECT ID FROM {$wpdb->posts} WHERE guid IN (%s,%s)\", $guid, esc_url( $guid ) )  );\n\n\t\tif ( null !== $global_post_id ) {\n\t\t\twp_delete_post( $global_post_id );\n\t\t}\n\n\t\trestore_current_blog();\n\t}\n\n\tprotected function get_blogs_to_import() {\n\t\tif ( $this->options->get( 'populate_all_blogs' ) ) {\n\t\t\treturn $wpdb->get_col( \"SELECT blog_id FROM $wpdb->blogs ORDER BY blog_id DESC\" );\n\t\t}\n\t\t// 'all blogs' not checked? check the blogs_to_import option\n\t\treturn $this->options->get( 'blogs_to_import', array() );\n\t}\n\n\tpublic function save_user_notice() {\n\t\tif ( $this->total_imported ) {\n\t\t\t$class = 'updated';\n\n\t\t\t$count = $this->strong_red( (int) $this->total_imported );\n\t\t\t$message = $this->heading( sprintf( __( 'Finished importing and/or updating %s posts! %s', 'wds-multisite-aggregate' ), $count, '&nbsp;'. $this->anchor( $this->get_aggregate_site_url(), __( 'Check them out?', 'wds-multisite-aggregate' ) ) ), 3 );\n\n\t\t} else {\n\t\t\t$class = 'error';\n\t\t\t$message = $this->heading( __( 'There are no posts to be aggregated.', 'wds-multisite-aggregate' ), 3 );\n\t\t}\n\t\tadd_site_option( 'wds_multisite_aggregate_message', compact( 'class', 'message' ) );\n\t}\n\n\tpublic function print_user_notice() {\n\t\tif ( $msg = get_site_option( 'wds_multisite_aggregate_message' ) ) {\n\t\t\tprintf( '<div id=\"message\" class=\"%s\">%s</div>', $msg['class'], $msg['message'] );\n\t\t\tdelete_site_option( 'wds_multisite_aggregate_message' );\n\t\t}\n\t}\n\n\tprotected function js_redirect( $url, $time_in_seconds = .5 ) {\n\t\treturn sprintf( '\n\t\t<script type=\"text/javascript\">\n\t\t\twindow.setTimeout( function() {\n\t\t\t\twindow.location.href = \"%s\";\n\t\t\t}, %d );\n\t\t</script>\n\t\t', $url, $time_in_seconds * 1000 );\n\t}\n\n\tprotected function notice_description( $text, $large = true ) {\n\t\t$style = $large ? 'style=\"font-size: 120%;\"' : '';\n\t\treturn '<p class=\"description\" '. $style .'>'. $text .'</p>';\n\t}\n\n\tprotected function strong_red( $text, $red = true ) {\n\t\t$style = $red ? ' style=\"color:red;\"' : '';\n\t\treturn sprintf( '<strong%s>%s</strong>', $style, $text );\n\t}\n\n\tprotected function anchor( $url, $text ) {\n\t\treturn sprintf( '<a href=\"%s\">%s</a>', esc_url( $url ), $text );\n\t}\n\n\tprotected function heading( $text, $level = 1 ) {\n\t\treturn sprintf( '<h%2$d>%1$s</h%2$d>', $text, absint( $level ) );\n\t}\n\n\tprotected function get_aggregate_site_url() {\n\t\treturn get_site_url( $this->options->get( 'tags_blog_id' ) );\n\t}\n\n\tprotected function error( $data ) {\n\t\tif ( defined( 'WP_CLI' ) && WP_CLI ) {\n\t\t\treturn array( 'success' => false, 'data' => $data );\n\t\t}\n\t\twp_send_json_error( $data );\n\t}\n\n\tprotected function success( $data ) {\n\t\tif ( defined( 'WP_CLI' ) && WP_CLI ) {\n\t\t\treturn array( 'success' => true, 'data' => $data );\n\t\t}\n\t\twp_send_json_success( $data );\n\t}\n\n\tprotected function error_if_wpcli( $data ) {\n\t\tif ( defined( 'WP_CLI' ) && WP_CLI ) {\n\t\t\treturn array( 'success' => false, 'data' => $data );\n\t\t}\n\t}\n\n\t/**\n\t * Magic getter for our object.\n\t *\n\t * @param string $field\n\t *\n\t * @throws Exception Throws an exception if the field is invalid.\n\t *\n\t * @return mixed\n\t */\n\tpublic function __get( $field ) {\n\t\tswitch ( $field ) {\n\t\t\tcase 'options':\n\t\t\tcase 'admin':\n\t\t\tcase 'remove':\n\t\t\tcase 'frontend':\n\t\t\tcase 'debug':\n\t\t\t\treturn $this->{$field};\n\t\t\tdefault:\n\t\t\t\treturn new WP_Error( 'wds_multisite_aggregate', __( 'Inaccessible Parameter', 'wds-multisite-aggregate' ) );\n\t\t}\n\t}\n\n}\n\n$WDS_Multisite_Aggregate = new WDS_Multisite_Aggregate();\n$WDS_Multisite_Aggregate->hooks();\n\nif ( defined( 'WP_CLI' ) && WP_CLI ) {\n\tinclude_once( dirname( __FILE__ ) .'/includes/WDS_Multisite_Aggregate_CLI.php' );\n}\n"], "fixing_code": ["<?php\n\n/**\n * Settings handler\n *\n * @since  1.0.0\n */\nclass WDS_Multisite_Aggregate_Options {\n\n\tpublic $to_update = '1';\n\tpublic $to_get = '1';\n\n\tfunction get( $key, $default = false ) {\n\t\tif ( $this->to_get == '1' ) {\n\t\t\t$this->to_get = get_site_option( 'sitewide_tags_blog' );\n\t\t}\n\t\tif ( is_array( $this->to_get ) ) {\n\t\t\tif ( $key == 'all' ) {\n\t\t\t\treturn $this->to_get;\n\t\t\t} elseif ( isset( $this->to_get[ $key ] ) ) {\n\t\t\t\treturn $this->to_get[ $key ];\n\t\t\t}\n\t\t}\n\t\treturn get_site_option( $key, $default );\n\t}\n\n\tfunction update( $key, $value = '', $flush = false ) {\n\t\tif ( $this->to_update == '1' ) {\n\t\t\t// don't save unless something has changed\n\t\t\tif ( $key === true ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t$this->to_update = get_site_option( 'sitewide_tags_blog' );\n\t\t}\n\t\tif ( !$this->to_update ) {\n\t\t\t$this->to_update = array();\n\t\t}\n\t\tif ( $key !== true ) {\n\t\t\t$this->to_update[ $key ] = $value;\n\t\t}\n\t\tif ( $flush || $key === true ) {\n\t\t\treturn update_site_option( 'sitewide_tags_blog', $this->to_update );\n\t\t}\n\t}\n\n\tpublic function hooks() {\n\t\tadd_filter( 'sitewide_tags_allowed_post_types', array( $this, 'pages_filter' ) );\n\t}\n\n\tfunction pages_filter( $post_types ) {\n\t\tif ( $this->get( 'tags_blog_pages' ) ) {\n\t\t\t$post_types = array_merge( $post_types, array( 'page' => true ) );\n\t\t}\n\t\treturn $post_types;\n\t}\n\n\tfunction update_options() {\n\t\tglobal $wpdb, $current_site, $wp_version;\n\n\t\tif ( ! isset( $_POST['tags_blog_enabled'] ) || !$_POST['tags_blog_enabled'] ) {\n\t\t\tif ( isset( $_POST['tags_blog_enabled'] ) && $this->get( 'tags_blog_enabled' ) != $_POST['tags_blog_enabled'] )\n\t\t\t\t$this->update( 'tags_blog_enabled', 0, true );\n\t\t\twp_redirect( esc_url_raw( add_query_arg( array( 'updated' => '1' ) ) ) );\n\t\t\texit;\n\t\t}\n\t\t$this->update( 'tags_blog_enabled', 1 );\n\n\t\tif ( ( isset( $_POST['tags_blog'] ) || isset( $_POST['tags_blog_main_blog'] ) ) && isset( $_POST['tags_blog_public'] ) ) {\n\t\t\tif ( isset( $_POST['tags_blog_main_blog'] ) && 1 == $_POST['tags_blog_main_blog'] ) {\n\t\t\t\tif ( $current_site->blog_id )\n\t\t\t\t\t$id = $current_site->blog_id;\n\t\t\t\telse\n\t\t\t\t\t$id = $wpdb->get_var( \"SELECT blog_id FROM {$wpdb->blogs} WHERE domain = '{$current_site->domain}' AND path = '{$current_site->path}'\" );\n\t\t\t\tif ( $id ) {\n\t\t\t\t\t$this->update( 'tags_blog_id', $id );\n\t\t\t\t\t$this->update( 'tags_blog_main_blog', 1 );\n\t\t\t\t} else {\n\t\t\t\t\t$this->update( 'tags_blog_main_blog', 0 );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->update( 'tags_blog_main_blog', 0 );\n\t\t\t\t$aggregate_blog = sanitize_title( $_POST['tags_blog'] );\n\t\t\t\t$this->update( 'tags_blog', $aggregate_blog );\n\t\t\t\tif ( constant( 'VHOST' ) == 'yes' ) {\n\t\t\t\t\t$domain = $aggregate_blog . '.' . $current_site->domain;\n\t\t\t\t\t$path = $current_site->path;\n\t\t\t\t} else {\n\t\t\t\t\t$domain = $current_site->domain;\n\t\t\t\t\t$path = trailingslashit( $current_site->path . $aggregate_blog );\n\t\t\t\t}\n\t\t\t\t$aggregate_blog_id = $wpdb->get_var( \"SELECT blog_id FROM {$wpdb->blogs} WHERE domain = '$domain' AND path = '$path'\" );\n\t\t\t\tif ( $aggregate_blog_id ) {\n\t\t\t\t\t$this->update( 'tags_blog_id', $aggregate_blog_id );\n\t\t\t\t} else {\n\t\t\t\t\t$wpdb->hide_errors();\n\t\t\t\t\t$id = wpmu_create_blog( $domain, $path, __( 'Network Posts', 'wds-multisite-aggregate' ), get_current_user_id() , array( 'public' => $_POST['tags_blog_public'] ), $current_site->id);\n\t\t\t\t\t$this->update( 'tags_blog_id', $id );\n\t\t\t\t\t$wpdb->show_errors();\n\t\t\t\t}\n\t\t\t}\n\t\t\t$aggregate_blog_public = (int) $_POST['tags_blog_public'];\n\t\t\t$this->update( 'tags_blog_public', $aggregate_blog_public );\n\t\t\tupdate_blog_option( $aggregate_blog_id, 'blog_public', $aggregate_blog_public );\n\t\t\tupdate_blog_status( $aggregate_blog_id, 'public', $aggregate_blog_public);\n\t\t}\n\n\t\t$options_as_integers = array(\n\t\t\t'tags_max_posts',\n\t\t);\n\t\tforeach ( $options_as_integers as $option_key ) {\n\t\t\tif ( $set = $this->make_integer_from_request( $option_key ) ) {\n\t\t\t\t$this->update( $option_key, $set );\n\t\t\t}\n\t\t}\n\n\t\t$options_as_integers_maybe_set = array(\n\t\t\t'tags_blog_thumbs',\n\t\t\t'tags_blog_pages',\n\t\t\t'populate_all_blogs',\n\t\t);\n\t\tforeach ( $options_as_integers_maybe_set as $option_key ) {\n\t\t\t$set = $this->make_integer_from_request( $option_key );\n\t\t\tif ( $set != $this->get( $option_key ) ) {\n\t\t\t\t$this->update( $option_key, $set );\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( $set = $this->make_integer_from_request( 'tags_blog_pub_check' ) ) && $set != $this->get( 'tags_blog_pub_check' ) ) {\n\t\t\t$set = $aggregate_blog_public == 0 ? $set : 0;\n\t\t\t$this->update( 'tags_blog_pub_check', $set );\n\t\t}\n\n\t\tif ( isset( $_POST['tags_blog_postmeta'] ) && '' != $_POST['tags_blog_postmeta'] ) {\n\t\t\t$meta_keys = explode( \"\\n\", strip_tags( stripslashes( $_POST['tags_blog_postmeta'] ) ) );\n\t\t\t$this->update( 'tags_blog_postmeta', array_map( 'trim', $meta_keys ) );\n\t\t} else {\n\t\t\t$this->update( 'tags_blog_postmeta', '' );\n\t\t}\n\n\t\t$blogs_to_import = $this->comma_delimited_to_array_from_request( 'blogs_to_import' );\n\t\t$this->update( 'blogs_to_import', $blogs_to_import );\n\n\t\t// force write if changes saved\n\t\t$this->update( true );\n\t\twp_redirect( esc_url_raw( add_query_arg( array( 'updated' => '1' ) ) ) );\n\t\texit;\n\t}\n\n\tfunction make_integer_from_request( $key ) {\n\t\treturn isset( $_REQUEST[ $key ] ) ? (int) $_REQUEST[ $key ] : 0;\n\t}\n\n\tfunction comma_delimited_to_array_from_request( $key ) {\n\t\treturn isset( $_REQUEST[ $key ] ) ? $this->comma_delimited_to_array( $_REQUEST[ $key ] ) : array();\n\t}\n\n\tfunction comma_delimited_to_array( $string ) {\n\t\t$array = (array) explode( ',', $string );\n\t\t$array = array_map( 'trim', $array );\n\t\t$array = array_map( array( $this, 'make_int' ), $array );\n\t\t$array = array_filter( $array );\n\t\treturn $array;\n\t}\n\n\n\tfunction make_int( $item ) {\n\t\treturn (int) str_ireplace( ' ', '', $item );\n\t}\n\n}\n", "# WDS Multisite Aggregate #\n**Contributors:** donncha, imwebgefunden, wpmuguru, WebDevStudios, jtsternberg, Mamaduka  \n**Tags:** wordpressmu  \n**Tested up to:** 4.2  \n**Stable tag:** 1.0.1  \n**Requires at least:** 3.0  \n\nA central area where all the posts on a WordPress multisite network can be collected.\n\n## Description ##\nCreates a new site where all the most recent posts/pages/etc on a WordPress network may be collected (much like http://wordpress.com/tags/).\n\nFor performance reasons the number of posts is limited to a user configurable amount, and the blog itself can be made indexable by search engines or not.\n\nBased on [WordPress MU Sitewide Tags Pages](https://wordpress.org/plugins/wordpress-mu-sitewide-tags/) plugin by Donncha O Caoimh.\n\nWPCLI is supported:\n`wp multisite_aggregate --help`.\n\n## Install ##\n1. Install in your plugins directory in the usual way and network activate the plugin. There is no need to put it in mu-plugins.\n2. Login as a site administrator and go to Super Admin->Sitewide Tags.\n\t1. Aggregate site defaults to \"Network Posts\" but can be anything. This is the blog where your sitewide posts will live. It will be created if it doesn't exist.\n\t2. Check \"Post to main blog\" to use your main blog as the aggregate blog.\n\t3. \"Max posts\" defaults to 5000. Older posts will be deleted if this threshold is broken.\n\t4. Check \"Include Pages\" to include both posts and pages, handy for making a sitewide search.\n\t5. \"Privacy\" defaults to public, pages can be indexed by search engines.\n\t6. When \"Privacy\" is not public, check \"Non-Public Blogs\" to include blogs not indexed by search engines.\n\t7. Add \"Post Meta\" custom fields to be copied with posts/pages.\n\t8. \"Populate Posts\" allows you to fill in posts from an existing blog.\n\n## Changelog ##\n\n### 1.0.1 ###\n* Update for xss vulnerability, https://make.wordpress.org/plugins/2015/04/20/fixing-add_query_arg-and-remove_query_arg-usage\n\n### 1.0.0 ###\n* Forked from 'MU Sitewide Tags' and rewritten with OOP principles, WordPress coding standards, and extensibility in mind.\n\n### 0.4.2 ###\n* duplicate category fix\n* page permalink fix\n* thumbnail size filter\n\n### 0.4.1.1 ###\n* Run populate feature in source blog context.\n* Added resource warning for populate feature.\n* Fixed PHP warnings.\n* Only insert categories for published posts.\n\n### 0.4.1 ###\n* Move SWT admin to its own screen.\n* Added thumbnail support.\n* Added custom taxonomy (including post formats) support.\n* Update admin screens for WordPress 3.1.\n\n### 0.4.0.1 ###\n* Bug fix - only push published content to the tags blog\n\n### 0.4 ###\n* Added option to include pages in tags blog.\n* Added option to include non search engine indexed blogs if tags blog not indexed.\n* Added option for post meta to be copied with post.\n", "=== WDS Multisite Aggregate ===\nContributors: donncha, imwebgefunden, wpmuguru, WebDevStudios, jtsternberg, Mamaduka\nTags: wordpressmu\nTested up to: 4.2\nStable tag: 1.0.1\nRequires at least: 3.0\n\nA central area where all the posts on a WordPress MS network can be collected.\n\n== Description ==\nCreates a new site where all the most recent posts/pages/etc on a WordPress network may be collected (much like http://wordpress.com/tags/).\n\nFor performance reasons the number of posts is limited to a user configurable amount, and the blog itself can be made indexable by search engines or not.\n\nBased on and forked from [WordPress MU Sitewide Tags Pages](https://wordpress.org/plugins/wordpress-mu-sitewide-tags/) plugin by Donncha O Caoimh.\n\nWPCLI is supported:\n`wp multisite_aggregate --help`.\n\n== Install ==\n1. Install in your plugins directory in the usual way and network activate the plugin. There is no need to put it in mu-plugins.\n2. Login as a site administrator and go to Super Admin->Sitewide Tags.\n\t1. Aggregate site defaults to \"Network Posts\" but can be anything. This is the blog where your sitewide posts will live. It will be created if it doesn't exist.\n\t2. Check \"Post to main blog\" to use your main blog as the aggregate blog.\n\t3. \"Max posts\" defaults to 5000. Older posts will be deleted if this threshold is broken.\n\t4. Check \"Include Pages\" to include both posts and pages, handy for making a sitewide search.\n\t5. \"Privacy\" defaults to public, pages can be indexed by search engines.\n\t6. When \"Privacy\" is not public, check \"Non-Public Blogs\" to include blogs not indexed by search engines.\n\t7. Add \"Post Meta\" custom fields to be copied with posts/pages.\n\t8. \"Populate Posts\" allows you to fill in posts from an existing blog.\n\n== Changelog ==\n\n= 1.0.1 =\n* Update for xss vulnerability, https://make.wordpress.org/plugins/2015/04/20/fixing-add_query_arg-and-remove_query_arg-usage\n\n= 1.0.0 =\n* Forked from 'MU Sitewide Tags' and rewritten with OOP principles, WordPress coding standards, and extensibility in mind.\n\n= 0.4.2 =\n* duplicate category fix\n* page permalink fix\n* thumbnail size filter\n\n= 0.4.1.1 =\n* Run populate feature in source blog context.\n* Added resource warning for populate feature.\n* Fixed PHP warnings.\n* Only insert categories for published posts.\n\n= 0.4.1 =\n* Move SWT admin to its own screen.\n* Added thumbnail support.\n* Added custom taxonomy (including post formats) support.\n* Update admin screens for WordPress 3.1.\n\n= 0.4.0.1 =\n* Bug fix - only push published content to the tags blog\n\n= 0.4 =\n* Added option to include pages in tags blog.\n* Added option to include non search engine indexed blogs if tags blog not indexed.\n* Added option for post meta to be copied with post.\n\n== Upgrade Notice ==\n\n= 1.0.1 =\n* Update for xss vulnerability, https://make.wordpress.org/plugins/2015/04/20/fixing-add_query_arg-and-remove_query_arg-usage\n\n= 1.0.0 =\n* Forked from 'MU Sitewide Tags' and rewritten with OOP principles, WordPress coding standards, and extensibility in mind.\n\n= 0.4.2 =\n* duplicate category fix\n* page permalink fix\n* thumbnail size filter\n\n= 0.4.1.1 =\n* Run populate feature in source blog context.\n* Added resource warning for populate feature.\n* Fixed PHP warnings.\n* Only insert categories for published posts.\n\n= 0.4.1 =\n* Move SWT admin to its own screen.\n* Added thumbnail support.\n* Added custom taxonomy (including post formats) support.\n* Update admin screens for WordPress 3.1.\n\n= 0.4.0.1 =\n* Bug fix - only push published content to the tags blog\n\n= 0.4 =\n* Added option to include pages in tags blog.\n* Added option to include non search engine indexed blogs if tags blog not indexed.\n* Added option for post meta to be copied with post.\n\n", "<?php\n/*\nPlugin Name: WDS Multisite Aggregate\nPlugin URI: https://github.com/WebDevStudios/WDS-Multisite-Aggregate\nDescription: Creates a blog where all the most recent posts on a WordPress network may be found. Based on WordPress MU Sitewide Tags Pages plugin by Donncha O Caoimh. WP-CLI: `wp multisite_aggregate --help`.\nVersion: 1.0.1\nAuthor: WebDevStudios\nAuthor URI: http://webdevstudios.com\n*/\n/*  Copyright 2008 Donncha O Caoimh (http://ocaoimh.ie/)\n    With contributions by Ron Rennick(http://wpmututorials.com/), Thomas Schneider(http://www.im-web-gefunden.de/) and others.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n\n/**\n * Autoloads files with classes when needed\n * @since  1.0.0\n * @param  string $class_name Name of the class being requested\n */\nfunction wds_ma_autoload_classes( $class_name ) {\n\tif ( class_exists( $class_name, false ) ) {\n\t\treturn;\n\t}\n\n\t$file = dirname( __FILE__ ) .'/includes/'. $class_name .'.php';\n\tif ( file_exists( $file ) ) {\n\t\t@include_once( $file );\n\t}\n}\nspl_autoload_register( 'wds_ma_autoload_classes' );\n\n/**\n * Get it started\n *\n * @since  1.0.0\n */\nclass WDS_Multisite_Aggregate {\n\n\tprotected $imported        = array();\n\tprotected $total_imported  = 0;\n\tprotected $doing_save_post = false;\n\tprotected $debug           = false;\n\n\tpublic function __construct() {\n\t\t// Options setter/getter and handles updating options on save\n\t\t$this->options = new WDS_Multisite_Aggregate_Options();\n\t\t$this->options->hooks();\n\t\t// Handles Admin display\n\t\t$this->admin = new WDS_Multisite_Aggregate_Admin( $this->options );\n\t\t$this->admin->hooks();\n\t\t// Handles removing posts from removed blogs\n\t\t$this->remove = new WDS_Multisite_Aggregate_Remove( $this->options );\n\t\t$this->remove->hooks();\n\t\t// Handles frontend modification for aggregate site\n\t\t$this->frontend = new WDS_Multisite_Aggregate_Frontend( $this->options );\n\t\t$this->frontend->hooks();\n\n\t\tif ( isset( $_REQUEST['aggregate_debug'] ) ) {\n\t\t\t$this->debug = new WDS_Multisite_Aggregate_Debug();\n\t\t\t$this->debug->hooks();\n\t\t}\n\t}\n\n\tfunction hooks() {\n\t\tadd_action( 'save_post', array( $this, 'do_post_sync' ), 10, 2 );\n\t\tadd_action( 'wds_multisite_aggregate_post_sync', array( $this, 'save_meta_fields' ), 10, 2 );\n\t\tadd_action( 'wp_update_comment_count', array( $this, 'do_comment_sync' ) );\n\n\t\tadd_action( 'trash_post', array( $this, 'sync_post_delete' ) );\n\t\tadd_action( 'delete_post', array( $this, 'sync_post_delete' ) );\n\n\t\tif ( ! empty( $_GET['action'] ) && 'populate_posts_from_blog' == $_GET['action'] ) {\n\t\t\tdefine( 'WDS_Multisite_Aggregate', true );\n\t\t\tadd_action( 'init', array( $this, 'populate_posts_from_blog' ), 8 );\n\t\t}\n\t\tif ( ! empty( $_GET['page'] ) && 'wds-multisite-aggregate' == $_GET['page'] ) {\n\t\t\tadd_action( 'admin_init', array( $this, 'context_hooks' ) );\n\t\t}\n\n\t}\n\n\tpublic function context_hooks() {\n\t\tif ( isset( $_GET['total_imported'] ) ) {\n\t\t\tadd_action( 'all_admin_notices', array( $this, 'user_notice' ) );\n\t\t}\n\n\t\t$valid_nonce = isset( $_REQUEST['_wpnonce'] ) ? wp_verify_nonce( $_REQUEST['_wpnonce'], 'wds-multisite-aggregate' ) : false;\n\n\t\tif ( ! $valid_nonce ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( isset( $_GET['action'] ) && 'populate_from_blogs' == $_GET['action'] ) {\n\t\t\treturn $this->populate_from_blogs();\n\t\t}\n\n\t\tif ( ! empty( $_POST ) ) {\n\t\t\t$this->options->update_options();\n\t\t}\n\t}\n\n\tfunction populate_from_blogs() {\n\t\tglobal $wpdb;\n\n\t\t$this->total_imported = $this->options->make_integer_from_request( 'total_imported' );\n\t\t$post_count           = $this->options->make_integer_from_request( 'post_count' );\n\n\t\t// Check query string\n\t\t$blogs_to_import      = $this->options->comma_delimited_to_array_from_request( 'blogs_to_import' );\n\t\t// No query string? Check options\n\t\t$blogs_to_import      = ! empty( $blogs_to_import ) ? $blogs_to_import : $this->get_blogs_to_import();\n\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\t\tif ( ! $tags_blog_id || empty( $blogs_to_import ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$blog_to_populate = array_shift( $blogs_to_import );\n\n\t\tif ( $blog_to_populate != $tags_blog_id ) {\n\t\t\t$this->imported = array();\n\n\t\t\t$details = get_blog_details( $blog_to_populate );\n\t\t\t$url = add_query_arg( array(\n\t\t\t\t'post_count' => $post_count,\n\t\t\t\t'action'     => 'populate_posts_from_blog',\n\t\t\t\t'key'        => md5( serialize( $details ) )\n\t\t\t), $details->siteurl );\n\n\t\t\t$post_count  = 0;\n\t\t\t$_post_count = 0;\n\t\t\t$result      = wp_remote_get( $url );\n\t\t\tif ( is_wp_error( $result ) ) {\n\t\t\t\twp_die( $result->get_error_message() );\n\t\t\t}\n\t\t\t$response = wp_remote_retrieve_body( $result );\n\n\t\t\tif ( $response ) {\n\t\t\t\t$json = json_decode( $response );\n\t\t\t\t$data = $json->success ? $json->data : false;\n\t\t\t\tif ( $data ) {\n\t\t\t\t\t$this->total_imported = $this->total_imported + count( $data->posts_imported );\n\t\t\t\t\t$this->imported = (array) $data->posts_imported;\n\t\t\t\t\t$_post_count = (int) $data->posts_done;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $_post_count ) {\n\t\t\t\t$post_count = $_post_count;\n\t\t\t}\n\t\t}\n\n\t\tif ( $post_count || ! empty( $blogs_to_import ) ) {\n\n\t\t\t$url = network_admin_url( 'settings.php' );\n\t\t\t$args = array(\n\t\t\t\t'page'           => 'wds-multisite-aggregate',\n\t\t\t\t'action'         => 'populate_from_blogs',\n\t\t\t\t'post_count'     => $post_count,\n\t\t\t\t'total_imported' => (int) $this->total_imported,\n\t\t\t\t'next_blog'      => true,\n\t\t\t);\n\t\t\tif ( ! empty( $blogs_to_import ) ) {\n\t\t\t\t$args['blogs_to_import'] = implode( ',', $blogs_to_import );\n\t\t\t}\n\t\t\t$url = add_query_arg( $args, wp_nonce_url( $url , 'wds-multisite-aggregate' ) );\n\n\t\t\t$count = $this->strong_red( count( $this->imported ) );\n\t\t\t$finished_blog = $this->strong_red( sprintf( __( 'Blog %d', 'wds-multisite-aggregate' ), (int) $blog_to_populate ), false );\n\t\t\t$next_blog = $this->strong_red( sprintf( __( 'Blog %d', 'wds-multisite-aggregate' ), array_shift( $blogs_to_import ) ), false );\n\n\t\t\t$msg = $this->heading( sprintf( __( 'Imported %s posts from %s', 'wds-multisite-aggregate' ), $count, $finished_blog ) );\n\t\t\t$desc = $this->notice_description( sprintf( __( 'Please wait while posts from %s are imported.', 'wds-multisite-aggregate' ), $next_blog ) );\n\n\t\t\twp_die( $msg . $desc . $this->js_redirect( $url, 1 ) );\n\n\t\t}\n\n\t\t$this->save_user_notice();\n\t\twp_redirect( $this->admin->url() );\n\t\texit;\n\n\t}\n\n\t/**\n\t * run populate function in local blog context because get_permalink does not produce the correct permalinks while switched\n\t */\n\tfunction populate_posts_from_blog() {\n\t\tglobal $wpdb;\n\t\t$valid_key = isset( $_REQUEST['key'] ) ? $_REQUEST['key'] == md5( serialize( get_blog_details( $wpdb->blogid ) ) ) : false;\n\t\tif ( ! $valid_key ) {\n\t\t\treturn $this->error( 'not a valid key.' );\n\t\t}\n\t\t$this->_populate_posts_from_blog( array(\n\t\t\t'post_count' => isset( $_GET['post_count'] ) ? (int) $_GET['post_count'] : 0,\n\t\t) );\n\t}\n\n\t/**\n\t * run populate function in local blog context because get_permalink does not produce the correct permalinks while switched\n\t */\n\tfunction _populate_posts_from_blog( $args = array() ) {\n\t\tglobal $wpdb;\n\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\t\t$tags_blog_enabled = $this->options->get( 'tags_blog_enabled' );\n\n\t\tif ( ! $tags_blog_enabled || ! $tags_blog_id || $tags_blog_id == $wpdb->blogid ) {\n\t\t\treturn $this->error( 'Aggregate blog not enabled OR there is no aggregate blog ID OR the current site IS the aggregate blog.' );\n\t\t}\n\n\t\t$posts_done = 0;\n\t\t$post_count = isset( $args['post_count'] ) ? (int) $args['post_count'] : 0; // post count\n\t\twhile ( $posts_done < 300 ) {\n\t\t\t$args = array(\n\t\t\t\t'fields'         => 'ids',\n\t\t\t\t'offset'         => $post_count + $posts_done,\n\t\t\t\t'posts_per_page' => 50,\n\t\t\t\t'post_status'    => 'publish',\n\t\t\t);\n\t\t\t$posts = get_posts( $args );\n\n\t\t\tif ( empty( $posts ) ) {\n\t\t\t\treturn $this->success( array(\n\t\t\t\t\t'posts_done'     => 0,\n\t\t\t\t\t'posts_imported' => $this->imported,\n\t\t\t\t) );\n\t\t\t}\n\n\t\t\tforeach ( $posts as $post ) {\n\t\t\t\tif ( 1 != $post && 2 != $post ) {\n\t\t\t\t\t$maybe_error = $this->do_post_sync( $post, get_post( $post ) );\n\n\t\t\t\t\tif ( $maybe_error ) {\n\t\t\t\t\t\treturn $this->error( $maybe_error );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$posts_done += 50;\n\t\t}\n\n\t\treturn $this->success( array(\n\t\t\t'posts_done'     => $posts_done,\n\t\t\t'posts_imported' => $this->imported,\n\t\t) );\n\t\texit( $posts_done );\n\t}\n\n\tfunction do_post_sync( $post_id, $post ) {\n\t\t$this->post_id = $post_id;\n\t\t$this->post    = $post;\n\n\t\tif ( $this->doing_save_post ) {\n\t\t\treturn $this->add_post_sync_hook();\n\t\t}\n\n\t\tif ( $error = $this->check_for_site_problems() ) {\n\t\t\treturn $this->error_if_wpcli( $error );\n\t\t}\n\n\t\t// wp_insert_category()\n\t\tinclude_once( ABSPATH . 'wp-admin/includes/admin.php' );\n\n\t\t$allowed_post_types = apply_filters( 'sitewide_tags_allowed_post_types', array( 'post' => true ) );\n\t\tif ( ! isset( $allowed_post_types[ $post->post_type ] ) || ! $allowed_post_types[ $post->post_type ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$post_categories = wp_get_object_terms( $post_id, 'category' );\n\n\t\tif ( $post_categories && ! is_wp_error( $post_categories ) && is_array( $post_categories ) ) {\n\t\t\t$post->post_category = wp_list_pluck( $post_categories, 'term_id' );\n\t\t} else {\n\t\t\t$post->post_category = wp_get_post_categories( $post_id );\n\t\t}\n\n\t\t$post->tags_input = implode( ', ', wp_get_post_tags( $post_id, array( 'fields' => 'names', ) ) );\n\n\t\tglobal $wpdb;\n\t\t$post_blog_id = $wpdb->blogid;\n\t\t$post->guid = \"{$post_blog_id}.{$post_id}\";\n\n\t\t$this->global_meta = array();\n\t\t$meta_keys = apply_filters( 'sitewide_tags_meta_keys', $this->options->get( 'tags_blog_postmeta', array() ) );\n\t\tif ( is_array( $meta_keys ) && ! empty( $meta_keys ) ) {\n\t\t\tforeach ( $meta_keys as $key ) {\n\t\t\t\t$this->global_meta[ $key ] = get_post_meta( $post->ID, $key, true );\n\t\t\t}\n\t\t}\n\t\tunset( $meta_keys );\n\n\t\t$this->global_meta['permalink'] = get_permalink( $post_id );\n\t\t$this->global_meta['blogid'] = $post_blog_id; // org_blog_id\n\n\t\tif ( $this->options->get( 'tags_blog_thumbs' ) && ( $thumb_id = get_post_thumbnail_id( $post->ID ) ) ) {\n\n\t\t\t$thumb_sizes = apply_filters( 'sitewide_tags_thumb_size', array(\n\t\t\t\t'thumbnail' ) );\n\n\t\t\t// back-compat\n\t\t\tif ( is_string( $thumb_sizes ) ) {\n\t\t\t\t$this->global_meta['thumbnail_html'] = wp_get_attachment_image( $thumb_id, $thumb_sizes );\n\t\t\t} else {\n\t\t\t\t// back-compat\n\t\t\t\t$this->global_meta['thumbnail_html'] = wp_get_attachment_image( $thumb_id, 'thumbnail' );\n\t\t\t}\n\n\t\t\t// new hawtness\n\t\t\tforeach ( (array) $thumb_sizes as $thumb_size ) {\n\t\t\t\t$this->global_meta[ \"thumbnail_html_$thumb_size\" ] = wp_get_attachment_image( $thumb_id, $thumb_size );\n\t\t\t}\n\t\t}\n\n\t\t// custom taxonomies\n\t\t$taxonomies = apply_filters( 'sitewide_tags_custom_taxonomies', array() );\n\t\tif ( ! empty( $taxonomies ) && 'publish' == $post->post_status ) {\n\t\t\t$registered_tax = array_diff( get_taxonomies(), array( 'post_tag', 'category', 'link_category', 'nav_menu' ) );\n\t\t\t$custom_tax = array_intersect( $taxonomies, $registered_tax );\n\t\t\t$tax_input = array();\n\t\t\tforeach ( $custom_tax as $tax ) {\n\t\t\t\t$terms = wp_get_object_terms( $post_id, $tax, array( 'fields' => 'names' ) );\n\t\t\t\tif ( empty( $terms ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( is_taxonomy_hierarchical( $tax ) ) {\n\t\t\t\t\t$tax_input[ $tax ] = $terms;\n\t\t\t\t} else {\n\t\t\t\t\t$tax_input[ $tax ] = implode( ',', $terms );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( ! empty( $tax_input ) ) {\n\t\t\t\t$post->tax_input = $tax_input;\n\t\t\t}\n\t\t}\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\n\t\tswitch_to_blog( $tags_blog_id );\n\n\t\t$category_ids = array();\n\t\tif ( is_array( $post_categories ) && ! empty( $post_categories ) && 'publish' == $post->post_status ) {\n\t\t\tforeach ( $post_categories as $t => $category ) {\n\t\t\t\t$term = get_term_by( 'slug', $category->slug, 'category' );\n\t\t\t\t$term = apply_filters( 'sitewide_tags_get_term', $term, $category, $this );\n\t\t\t\tif ( $this->debug ) {\n\t\t\t\t\techo '<xmp>$category_to_migrate: '. print_r( $category, true ) .'</xmp>';\n\t\t\t\t\techo '<xmp>$term_on_aggregate: '. print_r( $term, true ) .'</xmp>';\n\t\t\t\t}\n\t\t\t\tif ( $term && 0 == $term->parent ) {\n\t\t\t\t\t$category_ids[] = $term->term_id;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Here is where we insert the category if necessary\n\t\t\t\t$category_id = wp_insert_category( array(\n\t\t\t\t\t'cat_name'             => $category->name,\n\t\t\t\t\t'category_description' => $category->name,\n\t\t\t\t\t'category_nicename'    => $category->slug,\n\t\t\t\t\t'category_parent'      => '',\n\t\t\t\t), true );\n\n\t\t\t\tif (\n\t\t\t\t\tis_wp_error( $category_id )\n\t\t\t\t\t&& false !== stripos( $category_id->get_error_message(), 'already exists' )\n\t\t\t\t\t&& is_numeric( $category_id->get_error_data() )\n\t\t\t\t) {\n\t\t\t\t\t$category_ids[] = $category_id->get_error_data();\n\t\t\t\t} elseif ( is_numeric( $category_id ) ) {\n\t\t\t\t\t$category_ids[] = $category_id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->debug ) {\n\t\t\twp_die( '<xmp>$category_ids_to_add_to_post: '. print_r( $category_ids, true ) .'</xmp>' );\n\t\t}\n\n\t\t$global_post = $wpdb->get_row( $wpdb->prepare( \"SELECT * FROM {$wpdb->posts} WHERE guid IN (%s,%s)\", $post->guid, esc_url( $post->guid ) ) );\n\t\tif ( 'publish' != $post->post_status && is_object( $global_post ) && isset( $global_post->ID ) ) {\n\t\t\twp_delete_post( $global_post->ID );\n\t\t} else {\n\t\t\tif ( isset( $global_post->ID ) && $global_post->ID != '' ) {\n\t\t\t\t$post->ID = $global_post->ID; // editing an old post\n\n\t\t\t\tforeach ( array_keys( $this->global_meta ) as $key ) {\n\t\t\t\t\tdelete_post_meta( $global_post->ID, $key );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunset( $post->ID ); // new post\n\t\t\t}\n\t\t}\n\t\tif ( 'publish' == $post->post_status ) {\n\t\t\t$post->ping_status = 'closed';\n\t\t\t$post->comment_status = 'closed';\n\n\t\t\t// Use the category IDs in the post\n\t\t\t$post->post_category = $category_ids;\n\t\t\t$this->doing_save_post = true;\n\t\t\tif ( $post_id = wp_insert_post( $post, true ) && ! is_wp_error( $post_id ) ) {\n\t\t\t\t$this->imported[] = $post;\n\t\t\t}\n\t\t}\n\n\t\trestore_current_blog();\n\t}\n\n\tfunction check_for_site_problems() {\n\t\tglobal $wpdb;\n\n\t\tif ( ! $this->options->get( 'tags_blog_enabled' ) ) {\n\t\t\treturn __( 'Multisite Aggregate not enabled.', 'wds-multisite-aggregate' );\n\t\t}\n\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\t\tif ( ! $tags_blog_id || $tags_blog_id == $wpdb->blogid ) {\n\t\t\treturn __( 'No Multisite Aggregate blog ID, or current blog is Multisite Aggregate blog.', 'wds-multisite-aggregate' );\n\t\t}\n\n\t\t$blogs_to_import = $this->get_blogs_to_import();\n\t\tif ( ! in_array( (int) $wpdb->blogid, $blogs_to_import ) ) {\n\t\t\treturn __( 'Blog ID is not saved to the \"Blogs to Aggregate\" setting.', 'wds-multisite-aggregate' );\n\t\t}\n\n\t\t$blog_status = get_blog_status( $wpdb->blogid, 'public' );\n\n\t\tif ( 1 != $blog_status && ( 0 != $blog_status || 1 == $this->options->get( 'tags_blog_public' ) || 0 == $this->options->get( 'tags_blog_pub_check' ) ) ) {\n\t\t\treturn __( \"This blog's status is not set to public\", 'wds-multisite-aggregate' );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic function add_post_sync_hook() {\n\t\tdo_action( 'wds_multisite_aggregate_post_sync', $this->post_id, $this->post );\n\t\t$this->doing_save_post = false;\n\t}\n\n\tpublic function save_meta_fields( $post_id, $post ) {\n\t\t$updated = array();\n\t\tforeach ( $this->global_meta as $key => $value ) {\n\t\t\tif ( $value ) {\n\t\t\t\t$updated[ $key ] = add_post_meta( $post_id, $key, $value );\n\t\t\t}\n\t\t}\n\t\t// return $this->error( compact( 'post_id', 'updated', 'post' ) );\n\t}\n\n\tfunction do_comment_sync( $post_id ) {\n\t\tglobal $wpdb;\n\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\n\t\tif ( ! $tags_blog_id || $tags_blog_id == $wpdb->blogid ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$post_blog_id = $wpdb->blogid;\n\n\t\t$new = (int) $wpdb->get_var( $wpdb->prepare( \"SELECT COUNT(*) FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_approved = '1'\", $post_id ) );\n\n\t\tswitch_to_blog( $tags_blog_id );\n\n\t\t$guid = \"{$post_blog_id}.{$post_id}\";\n\n\t\t$global_post_id = $wpdb->get_var( $wpdb->prepare( \"SELECT ID FROM {$wpdb->posts} WHERE guid IN (%s,%s)\", $guid, esc_url( $guid ) ) );\n\n\t\tif ( null !== $global_post_id ) {\n\t\t\t$wpdb->update( $wpdb->posts, array( 'comment_count' => $new ), array( 'ID' => $global_post_id ) );\n\t\t\tclean_post_cache( $global_post_id );\n\t\t}\n\n\t\trestore_current_blog();\n\t}\n\n\tfunction sync_post_delete( $post_id ) {\n\t\tglobal $wpdb;\n\t\t/*\n\t\t * what should we do if a post will be deleted and the tags blog feature is disabled?\n\t\t * need an check if we have a post on the tags blog and if so - delete this\n\t\t */\n\t\t$tags_blog_id = $this->options->get( 'tags_blog_id' );\n\n\t\tif ( ! $tags_blog_id || $wpdb->blogid == $tags_blog_id ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$post_blog_id = $wpdb->blogid;\n\t\tswitch_to_blog( $tags_blog_id );\n\n\t\t$guid = \"{$post_blog_id}.{$post_id}\";\n\n\t\t$global_post_id = $wpdb->get_var( $wpdb->prepare( \"SELECT ID FROM {$wpdb->posts} WHERE guid IN (%s,%s)\", $guid, esc_url( $guid ) )  );\n\n\t\tif ( null !== $global_post_id ) {\n\t\t\twp_delete_post( $global_post_id );\n\t\t}\n\n\t\trestore_current_blog();\n\t}\n\n\tprotected function get_blogs_to_import() {\n\t\tif ( $this->options->get( 'populate_all_blogs' ) ) {\n\t\t\treturn $wpdb->get_col( \"SELECT blog_id FROM $wpdb->blogs ORDER BY blog_id DESC\" );\n\t\t}\n\t\t// 'all blogs' not checked? check the blogs_to_import option\n\t\treturn $this->options->get( 'blogs_to_import', array() );\n\t}\n\n\tpublic function save_user_notice() {\n\t\tif ( $this->total_imported ) {\n\t\t\t$class = 'updated';\n\n\t\t\t$count = $this->strong_red( (int) $this->total_imported );\n\t\t\t$message = $this->heading( sprintf( __( 'Finished importing and/or updating %s posts! %s', 'wds-multisite-aggregate' ), $count, '&nbsp;'. $this->anchor( $this->get_aggregate_site_url(), __( 'Check them out?', 'wds-multisite-aggregate' ) ) ), 3 );\n\n\t\t} else {\n\t\t\t$class = 'error';\n\t\t\t$message = $this->heading( __( 'There are no posts to be aggregated.', 'wds-multisite-aggregate' ), 3 );\n\t\t}\n\t\tadd_site_option( 'wds_multisite_aggregate_message', compact( 'class', 'message' ) );\n\t}\n\n\tpublic function print_user_notice() {\n\t\tif ( $msg = get_site_option( 'wds_multisite_aggregate_message' ) ) {\n\t\t\tprintf( '<div id=\"message\" class=\"%s\">%s</div>', $msg['class'], $msg['message'] );\n\t\t\tdelete_site_option( 'wds_multisite_aggregate_message' );\n\t\t}\n\t}\n\n\tprotected function js_redirect( $url, $time_in_seconds = .5 ) {\n\t\treturn sprintf( '\n\t\t<script type=\"text/javascript\">\n\t\t\twindow.setTimeout( function() {\n\t\t\t\twindow.location.href = \"%s\";\n\t\t\t}, %d );\n\t\t</script>\n\t\t', $url, $time_in_seconds * 1000 );\n\t}\n\n\tprotected function notice_description( $text, $large = true ) {\n\t\t$style = $large ? 'style=\"font-size: 120%;\"' : '';\n\t\treturn '<p class=\"description\" '. $style .'>'. $text .'</p>';\n\t}\n\n\tprotected function strong_red( $text, $red = true ) {\n\t\t$style = $red ? ' style=\"color:red;\"' : '';\n\t\treturn sprintf( '<strong%s>%s</strong>', $style, $text );\n\t}\n\n\tprotected function anchor( $url, $text ) {\n\t\treturn sprintf( '<a href=\"%s\">%s</a>', esc_url( $url ), $text );\n\t}\n\n\tprotected function heading( $text, $level = 1 ) {\n\t\treturn sprintf( '<h%2$d>%1$s</h%2$d>', $text, absint( $level ) );\n\t}\n\n\tprotected function get_aggregate_site_url() {\n\t\treturn get_site_url( $this->options->get( 'tags_blog_id' ) );\n\t}\n\n\tprotected function error( $data ) {\n\t\tif ( defined( 'WP_CLI' ) && WP_CLI ) {\n\t\t\treturn array( 'success' => false, 'data' => $data );\n\t\t}\n\t\twp_send_json_error( $data );\n\t}\n\n\tprotected function success( $data ) {\n\t\tif ( defined( 'WP_CLI' ) && WP_CLI ) {\n\t\t\treturn array( 'success' => true, 'data' => $data );\n\t\t}\n\t\twp_send_json_success( $data );\n\t}\n\n\tprotected function error_if_wpcli( $data ) {\n\t\tif ( defined( 'WP_CLI' ) && WP_CLI ) {\n\t\t\treturn array( 'success' => false, 'data' => $data );\n\t\t}\n\t}\n\n\t/**\n\t * Magic getter for our object.\n\t *\n\t * @param string $field\n\t *\n\t * @throws Exception Throws an exception if the field is invalid.\n\t *\n\t * @return mixed\n\t */\n\tpublic function __get( $field ) {\n\t\tswitch ( $field ) {\n\t\t\tcase 'options':\n\t\t\tcase 'admin':\n\t\t\tcase 'remove':\n\t\t\tcase 'frontend':\n\t\t\tcase 'debug':\n\t\t\t\treturn $this->{$field};\n\t\t\tdefault:\n\t\t\t\treturn new WP_Error( 'wds_multisite_aggregate', __( 'Inaccessible Parameter', 'wds-multisite-aggregate' ) );\n\t\t}\n\t}\n\n}\n\n$WDS_Multisite_Aggregate = new WDS_Multisite_Aggregate();\n$WDS_Multisite_Aggregate->hooks();\n\nif ( defined( 'WP_CLI' ) && WP_CLI ) {\n\tinclude_once( dirname( __FILE__ ) .'/includes/WDS_Multisite_Aggregate_CLI.php' );\n}\n"], "filenames": ["includes/WDS_Multisite_Aggregate_Options.php", "readme.md", "readme.txt", "wds-multisite-aggregate.php"], "buggy_code_start_loc": [63, 4, 4, 6], "buggy_code_end_loc": [147, 33, 60, 7], "fixing_code_start_loc": [63, 4, 4, 6], "fixing_code_end_loc": [147, 37, 98, 7], "type": "CWE-79", "message": "A vulnerability, which was classified as problematic, was found in WDS Multisite Aggregate Plugin up to 1.0.0 on WordPress. Affected is the function update_options of the file includes/WDS_Multisite_Aggregate_Options.php. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 1.0.1 is able to address this issue. The name of the patch is 49e0bbcb6ff70e561365d9e0d26426598f63ca12. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-233364.", "other": {"cve": {"id": "CVE-2015-10120", "sourceIdentifier": "cna@vuldb.com", "published": "2023-07-10T16:15:47.297", "lastModified": "2024-02-29T01:16:12.167", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, was found in WDS Multisite Aggregate Plugin up to 1.0.0 on WordPress. Affected is the function update_options of the file includes/WDS_Multisite_Aggregate_Options.php. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 1.0.1 is able to address this issue. The name of the patch is 49e0bbcb6ff70e561365d9e0d26426598f63ca12. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-233364."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webdevstudios:wds_multisite_aggregate:*:*:*:*:*:wordpress:*:*", "versionEndIncluding": "1.0.0", "matchCriteriaId": "DF28E53F-EB5F-4164-9E31-BD5C72D5ECD1"}]}]}], "references": [{"url": "https://github.com/wp-plugins/wds-multisite-aggregate/commit/49e0bbcb6ff70e561365d9e0d26426598f63ca12", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://vuldb.com/?ctiid.233364", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.233364", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wp-plugins/wds-multisite-aggregate/commit/49e0bbcb6ff70e561365d9e0d26426598f63ca12"}}