{"buggy_code": ["/*jslint node:true */\n'use strict';\n\n/**\n * Passport.js config file, heavily inspired by\n * http://scotch.io/tutorials/javascript/easy-node-authentication-setup-and-local\n */\n\nvar LocalStrategy = require('passport-local').Strategy,\n    passwordHash = require('password-hash'),\n    connection = require('./../config/db.js')(10);\n\nmodule.exports = function (passport) {\n\n    // =========================================================================\n    // passport session setup ==================================================\n    // =========================================================================\n    // required for persistent login sessions\n    // passport needs ability to serialize and unserialize users out of session\n\n    // used to serialize the user for the session\n    passport.serializeUser(function (user, done) {\n        done(null, user.id);\n    });\n\n    // used to deserialize the user\n    passport.deserializeUser(function (id, done) {\n        connection.query(\"select * from users where id = \" + id, function (err, rows) {\n            done(err, rows[0]);\n        });\n    });\n\n\n    // =========================================================================\n    // LOCAL SIGNUP ============================================================\n    // =========================================================================\n    // we are using named strategies since we have one for login and one for signup\n    // by default, if there was no name, it would just be called 'local'\n\n    passport.use('local-signup', new LocalStrategy({\n            // by default, local strategy uses username and password, we will override with email\n            usernameField: 'email',\n            passwordField: 'password',\n            passReqToCallback: true // allows us to pass back the entire request to the callback\n        },\n        function (req, email, password, done) {\n            // find a user whose email is the same as the forms email\n            // we are checking to see if the user trying to login already exists\n            connection.query(\"select * from users where email = '\" + email + \"'\", function (err, rows) {\n                if (err) {return done(err);}\n                if (rows.length) {\n                    req.signUpMessage = 'Diese e-Mail ist bei uns bereits registriert';\n                    return done(null, false);\n                } else {\n\n                    // if there is no user with that email\n                    // create the user\n                    var newUserMysql = {};\n                    newUserMysql.title = req.body.title;\n                    newUserMysql.email = email;\n                    newUserMysql.firstName = req.body.firstName;\n                    newUserMysql.lastName = req.body.lastName;\n                    newUserMysql.password = passwordHash.generate(password);\n\n                    connection.query('INSERT INTO users SET ?', [newUserMysql], function (err, rows) {\n                        newUserMysql.id = rows.insertId;\n\n                        return done(null, newUserMysql);\n                    });\n                }\n            });\n        }));\n\n    // =========================================================================\n    // LOCAL LOGIN =============================================================\n    // =========================================================================\n    // we are using named strategies since we have one for login and one for signup\n    // by default, if there was no name, it would just be called 'local'\n\n    passport.use('local-login', new LocalStrategy({\n            // by default, local strategy uses username and password, we will override with email\n            usernameField: 'email',\n            passwordField: 'password',\n            passReqToCallback: true // allows us to pass back the entire request to the callback\n        },\n        function (req, email, password, done) { // callback with email and password from our form\n            connection.query(\"SELECT * FROM `users` WHERE `email` = '\" + email + \"'\", function (err, rows) {\n                if (err) {return done(err);}\n\n                if (!rows.length) {\n                    req.loginMessage='Die eingegebene E-Mail-Adresse oder das Passwort ist falsch.';\n                    return done(null, false);\n                }\n\n                // if the user is found but the password is wrong\n                if (!passwordHash.verify(password, rows[0].password)) {\n                    req.loginMessage = 'Die eingegebene E-Mail-Adresse oder das Passwort ist falsch.';\n                    return done(null, false);\n                }\n\n                // all is well, return successful user\n                return done(null, rows[0]);\n\n            });\n        }));\n};\n"], "fixing_code": ["/*jslint node:true */\n'use strict';\n\n/**\n * Passport.js config file, heavily inspired by\n * http://scotch.io/tutorials/javascript/easy-node-authentication-setup-and-local\n */\n\nvar LocalStrategy = require('passport-local').Strategy,\n    passwordHash = require('password-hash'),\n    connection = require('./../config/db.js')(10);\n\nmodule.exports = function (passport) {\n\n    // =========================================================================\n    // passport session setup ==================================================\n    // =========================================================================\n    // required for persistent login sessions\n    // passport needs ability to serialize and unserialize users out of session\n\n    // used to serialize the user for the session\n    passport.serializeUser(function (user, done) {\n        done(null, user.id);\n    });\n\n    // used to deserialize the user\n    passport.deserializeUser(function (id, done) {\n        connection.query(\"select * from users where id = ?\", [id], function (err, rows) {\n            done(err, rows[0]);\n        });\n    });\n\n\n    // =========================================================================\n    // LOCAL SIGNUP ============================================================\n    // =========================================================================\n    // we are using named strategies since we have one for login and one for signup\n    // by default, if there was no name, it would just be called 'local'\n\n    passport.use('local-signup', new LocalStrategy({\n            // by default, local strategy uses username and password, we will override with email\n            usernameField: 'email',\n            passwordField: 'password',\n            passReqToCallback: true // allows us to pass back the entire request to the callback\n        },\n        function (req, email, password, done) {\n            // find a user whose email is the same as the forms email\n            // we are checking to see if the user trying to login already exists\n            connection.query(\"select * from users where email = ?\" + [email], function (err, rows) {\n                if (err) {return done(err);}\n                if (rows.length) {\n                    req.signUpMessage = 'Diese e-Mail ist bei uns bereits registriert';\n                    return done(null, false);\n                } else {\n\n                    // if there is no user with that email\n                    // create the user\n                    var newUserMysql = {};\n                    newUserMysql.title = req.body.title;\n                    newUserMysql.email = email;\n                    newUserMysql.firstName = req.body.firstName;\n                    newUserMysql.lastName = req.body.lastName;\n                    newUserMysql.password = passwordHash.generate(password);\n\n                    connection.query('INSERT INTO users SET ?', [newUserMysql], function (err, rows) {\n                        newUserMysql.id = rows.insertId;\n\n                        return done(null, newUserMysql);\n                    });\n                }\n            });\n        }));\n\n    // =========================================================================\n    // LOCAL LOGIN =============================================================\n    // =========================================================================\n    // we are using named strategies since we have one for login and one for signup\n    // by default, if there was no name, it would just be called 'local'\n\n    passport.use('local-login', new LocalStrategy({\n            // by default, local strategy uses username and password, we will override with email\n            usernameField: 'email',\n            passwordField: 'password',\n            passReqToCallback: true // allows us to pass back the entire request to the callback\n        },\n        function (req, email, password, done) { // callback with email and password from our form\n            connection.query(\"SELECT * FROM `users` WHERE `email` = ?\", [email], function (err, rows) {\n                if (err) {return done(err);}\n\n                if (!rows.length) {\n                    req.loginMessage='Die eingegebene E-Mail-Adresse oder das Passwort ist falsch.';\n                    return done(null, false);\n                }\n\n                // if the user is found but the password is wrong\n                if (!passwordHash.verify(password, rows[0].password)) {\n                    req.loginMessage = 'Die eingegebene E-Mail-Adresse oder das Passwort ist falsch.';\n                    return done(null, false);\n                }\n\n                // all is well, return successful user\n                return done(null, rows[0]);\n\n            });\n        }));\n};\n"], "filenames": ["app/config/passport.js"], "buggy_code_start_loc": [28], "buggy_code_end_loc": [88], "fixing_code_start_loc": [28], "fixing_code_end_loc": [88], "type": "CWE-89", "message": "A vulnerability was found in DHBW Fallstudie. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the file app/config/passport.js of the component Login. The manipulation of the argument id/email leads to sql injection. The name of the patch is 5c13c6a972ef4c07c5f35b417916e0598af9e123. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216907.", "other": {"cve": {"id": "CVE-2021-4290", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-27T23:15:10.607", "lastModified": "2023-01-06T13:53:16.950", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in DHBW Fallstudie. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the file app/config/passport.js of the component Login. The manipulation of the argument id/email leads to sql injection. The name of the patch is 5c13c6a972ef4c07c5f35b417916e0598af9e123. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216907."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fallstudie_project:fallstudie:-:*:*:*:*:*:*:*", "matchCriteriaId": "E5557890-EAD0-49B4-8464-ADD1C7E9CE36"}]}]}], "references": [{"url": "https://github.com/maboehm/fallstudie/commit/5c13c6a972ef4c07c5f35b417916e0598af9e123", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216907", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216907", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/maboehm/fallstudie/commit/5c13c6a972ef4c07c5f35b417916e0598af9e123"}}