{"buggy_code": ["/*\n *\n *  Bluetooth HCI UART driver\n *\n *  Copyright (C) 2000-2001  Qualcomm Incorporated\n *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>\n *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>\n *\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/poll.h>\n\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/ioctl.h>\n#include <linux/skbuff.h>\n#include <linux/firmware.h>\n#include <linux/serdev.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btintel.h\"\n#include \"btbcm.h\"\n#include \"hci_uart.h\"\n\n#define VERSION \"2.3\"\n\nstatic const struct hci_uart_proto *hup[HCI_UART_MAX_PROTO];\n\nint hci_uart_register_proto(const struct hci_uart_proto *p)\n{\n\tif (p->id >= HCI_UART_MAX_PROTO)\n\t\treturn -EINVAL;\n\n\tif (hup[p->id])\n\t\treturn -EEXIST;\n\n\thup[p->id] = p;\n\n\tBT_INFO(\"HCI UART protocol %s registered\", p->name);\n\n\treturn 0;\n}\n\nint hci_uart_unregister_proto(const struct hci_uart_proto *p)\n{\n\tif (p->id >= HCI_UART_MAX_PROTO)\n\t\treturn -EINVAL;\n\n\tif (!hup[p->id])\n\t\treturn -EINVAL;\n\n\thup[p->id] = NULL;\n\n\treturn 0;\n}\n\nstatic const struct hci_uart_proto *hci_uart_get_proto(unsigned int id)\n{\n\tif (id >= HCI_UART_MAX_PROTO)\n\t\treturn NULL;\n\n\treturn hup[id];\n}\n\nstatic inline void hci_uart_tx_complete(struct hci_uart *hu, int pkt_type)\n{\n\tstruct hci_dev *hdev = hu->hdev;\n\n\t/* Update HCI stat counters */\n\tswitch (pkt_type) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\t}\n}\n\nstatic inline struct sk_buff *hci_uart_dequeue(struct hci_uart *hu)\n{\n\tstruct sk_buff *skb = hu->tx_skb;\n\n\tif (!skb) {\n\t\tpercpu_down_read(&hu->proto_lock);\n\n\t\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\t\tskb = hu->proto->dequeue(hu);\n\n\t\tpercpu_up_read(&hu->proto_lock);\n\t} else {\n\t\thu->tx_skb = NULL;\n\t}\n\n\treturn skb;\n}\n\nint hci_uart_tx_wakeup(struct hci_uart *hu)\n{\n\t/* This may be called in an IRQ context, so we can't sleep. Therefore\n\t * we try to acquire the lock only, and if that fails we assume the\n\t * tty is being closed because that is the only time the write lock is\n\t * acquired. If, however, at some point in the future the write lock\n\t * is also acquired in other situations, then this must be revisited.\n\t */\n\tif (!percpu_down_read_trylock(&hu->proto_lock))\n\t\treturn 0;\n\n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\tgoto no_schedule;\n\n\tif (test_and_set_bit(HCI_UART_SENDING, &hu->tx_state)) {\n\t\tset_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);\n\t\tgoto no_schedule;\n\t}\n\n\tBT_DBG(\"\");\n\n\tschedule_work(&hu->write_work);\n\nno_schedule:\n\tpercpu_up_read(&hu->proto_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hci_uart_tx_wakeup);\n\nstatic void hci_uart_write_work(struct work_struct *work)\n{\n\tstruct hci_uart *hu = container_of(work, struct hci_uart, write_work);\n\tstruct tty_struct *tty = hu->tty;\n\tstruct hci_dev *hdev = hu->hdev;\n\tstruct sk_buff *skb;\n\n\t/* REVISIT: should we cope with bad skbs or ->write() returning\n\t * and error value ?\n\t */\n\nrestart:\n\tclear_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);\n\n\twhile ((skb = hci_uart_dequeue(hu))) {\n\t\tint len;\n\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\t\tlen = tty->ops->write(tty, skb->data, skb->len);\n\t\thdev->stat.byte_tx += len;\n\n\t\tskb_pull(skb, len);\n\t\tif (skb->len) {\n\t\t\thu->tx_skb = skb;\n\t\t\tbreak;\n\t\t}\n\n\t\thci_uart_tx_complete(hu, hci_skb_pkt_type(skb));\n\t\tkfree_skb(skb);\n\t}\n\n\tif (test_bit(HCI_UART_TX_WAKEUP, &hu->tx_state))\n\t\tgoto restart;\n\n\tclear_bit(HCI_UART_SENDING, &hu->tx_state);\n}\n\nvoid hci_uart_init_work(struct work_struct *work)\n{\n\tstruct hci_uart *hu = container_of(work, struct hci_uart, init_ready);\n\tint err;\n\tstruct hci_dev *hdev;\n\n\tif (!test_and_clear_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\n\t\treturn;\n\n\terr = hci_register_dev(hu->hdev);\n\tif (err < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\thu->proto->close(hu);\n\t\thdev = hu->hdev;\n\t\thu->hdev = NULL;\n\t\thci_free_dev(hdev);\n\t\treturn;\n\t}\n\n\tset_bit(HCI_UART_REGISTERED, &hu->flags);\n}\n\nint hci_uart_init_ready(struct hci_uart *hu)\n{\n\tif (!test_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\n\t\treturn -EALREADY;\n\n\tschedule_work(&hu->init_ready);\n\n\treturn 0;\n}\n\n/* ------- Interface to HCI layer ------ */\n/* Reset device */\nstatic int hci_uart_flush(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu  = hci_get_drvdata(hdev);\n\tstruct tty_struct *tty = hu->tty;\n\n\tBT_DBG(\"hdev %p tty %p\", hdev, tty);\n\n\tif (hu->tx_skb) {\n\t\tkfree_skb(hu->tx_skb); hu->tx_skb = NULL;\n\t}\n\n\t/* Flush any pending characters in the driver and discipline. */\n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\n\tpercpu_down_read(&hu->proto_lock);\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\thu->proto->flush(hu);\n\n\tpercpu_up_read(&hu->proto_lock);\n\n\treturn 0;\n}\n\n/* Initialize device */\nstatic int hci_uart_open(struct hci_dev *hdev)\n{\n\tBT_DBG(\"%s %p\", hdev->name, hdev);\n\n\t/* Undo clearing this from hci_uart_close() */\n\thdev->flush = hci_uart_flush;\n\n\treturn 0;\n}\n\n/* Close device */\nstatic int hci_uart_close(struct hci_dev *hdev)\n{\n\tBT_DBG(\"hdev %p\", hdev);\n\n\thci_uart_flush(hdev);\n\thdev->flush = NULL;\n\treturn 0;\n}\n\n/* Send frames from HCI layer */\nstatic int hci_uart_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"%s: type %d len %d\", hdev->name, hci_skb_pkt_type(skb),\n\t       skb->len);\n\n\tpercpu_down_read(&hu->proto_lock);\n\n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags)) {\n\t\tpercpu_up_read(&hu->proto_lock);\n\t\treturn -EUNATCH;\n\t}\n\n\thu->proto->enqueue(hu, skb);\n\tpercpu_up_read(&hu->proto_lock);\n\n\thci_uart_tx_wakeup(hu);\n\n\treturn 0;\n}\n\n/* Flow control or un-flow control the device */\nvoid hci_uart_set_flow_control(struct hci_uart *hu, bool enable)\n{\n\tstruct tty_struct *tty = hu->tty;\n\tstruct ktermios ktermios;\n\tint status;\n\tunsigned int set = 0;\n\tunsigned int clear = 0;\n\n\tif (hu->serdev) {\n\t\tserdev_device_set_flow_control(hu->serdev, !enable);\n\t\tserdev_device_set_rts(hu->serdev, !enable);\n\t\treturn;\n\t}\n\n\tif (enable) {\n\t\t/* Disable hardware flow control */\n\t\tktermios = tty->termios;\n\t\tktermios.c_cflag &= ~CRTSCTS;\n\t\tstatus = tty_set_termios(tty, &ktermios);\n\t\tBT_DBG(\"Disabling hardware flow control: %s\",\n\t\t       status ? \"failed\" : \"success\");\n\n\t\t/* Clear RTS to prevent the device from sending */\n\t\t/* Most UARTs need OUT2 to enable interrupts */\n\t\tstatus = tty->driver->ops->tiocmget(tty);\n\t\tBT_DBG(\"Current tiocm 0x%x\", status);\n\n\t\tset &= ~(TIOCM_OUT2 | TIOCM_RTS);\n\t\tclear = ~set;\n\t\tset &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t       TIOCM_OUT2 | TIOCM_LOOP;\n\t\tclear &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t\t TIOCM_OUT2 | TIOCM_LOOP;\n\t\tstatus = tty->driver->ops->tiocmset(tty, set, clear);\n\t\tBT_DBG(\"Clearing RTS: %s\", status ? \"failed\" : \"success\");\n\t} else {\n\t\t/* Set RTS to allow the device to send again */\n\t\tstatus = tty->driver->ops->tiocmget(tty);\n\t\tBT_DBG(\"Current tiocm 0x%x\", status);\n\n\t\tset |= (TIOCM_OUT2 | TIOCM_RTS);\n\t\tclear = ~set;\n\t\tset &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t       TIOCM_OUT2 | TIOCM_LOOP;\n\t\tclear &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t\t TIOCM_OUT2 | TIOCM_LOOP;\n\t\tstatus = tty->driver->ops->tiocmset(tty, set, clear);\n\t\tBT_DBG(\"Setting RTS: %s\", status ? \"failed\" : \"success\");\n\n\t\t/* Re-enable hardware flow control */\n\t\tktermios = tty->termios;\n\t\tktermios.c_cflag |= CRTSCTS;\n\t\tstatus = tty_set_termios(tty, &ktermios);\n\t\tBT_DBG(\"Enabling hardware flow control: %s\",\n\t\t       status ? \"failed\" : \"success\");\n\t}\n}\n\nvoid hci_uart_set_speeds(struct hci_uart *hu, unsigned int init_speed,\n\t\t\t unsigned int oper_speed)\n{\n\thu->init_speed = init_speed;\n\thu->oper_speed = oper_speed;\n}\n\nvoid hci_uart_set_baudrate(struct hci_uart *hu, unsigned int speed)\n{\n\tstruct tty_struct *tty = hu->tty;\n\tstruct ktermios ktermios;\n\n\tktermios = tty->termios;\n\tktermios.c_cflag &= ~CBAUD;\n\ttty_termios_encode_baud_rate(&ktermios, speed, speed);\n\n\t/* tty_set_termios() return not checked as it is always 0 */\n\ttty_set_termios(tty, &ktermios);\n\n\tBT_DBG(\"%s: New tty speeds: %d/%d\", hu->hdev->name,\n\t       tty->termios.c_ispeed, tty->termios.c_ospeed);\n}\n\nstatic int hci_uart_setup(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct hci_rp_read_local_version *ver;\n\tstruct sk_buff *skb;\n\tunsigned int speed;\n\tint err;\n\n\t/* Init speed if any */\n\tif (hu->init_speed)\n\t\tspeed = hu->init_speed;\n\telse if (hu->proto->init_speed)\n\t\tspeed = hu->proto->init_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (speed)\n\t\thci_uart_set_baudrate(hu, speed);\n\n\t/* Operational speed if any */\n\tif (hu->oper_speed)\n\t\tspeed = hu->oper_speed;\n\telse if (hu->proto->oper_speed)\n\t\tspeed = hu->proto->oper_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (hu->proto->set_baudrate && speed) {\n\t\terr = hu->proto->set_baudrate(hu, speed);\n\t\tif (!err)\n\t\t\thci_uart_set_baudrate(hu, speed);\n\t}\n\n\tif (hu->proto->setup)\n\t\treturn hu->proto->setup(hu);\n\n\tif (!test_bit(HCI_UART_VND_DETECT, &hu->hdev_flags))\n\t\treturn 0;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tBT_ERR(\"%s: Reading local version information failed (%ld)\",\n\t\t       hdev->name, PTR_ERR(skb));\n\t\treturn 0;\n\t}\n\n\tif (skb->len != sizeof(*ver)) {\n\t\tBT_ERR(\"%s: Event length mismatch for version information\",\n\t\t       hdev->name);\n\t\tgoto done;\n\t}\n\n\tver = (struct hci_rp_read_local_version *)skb->data;\n\n\tswitch (le16_to_cpu(ver->manufacturer)) {\n#ifdef CONFIG_BT_HCIUART_INTEL\n\tcase 2:\n\t\thdev->set_bdaddr = btintel_set_bdaddr;\n\t\tbtintel_check_bdaddr(hdev);\n\t\tbreak;\n#endif\n#ifdef CONFIG_BT_HCIUART_BCM\n\tcase 15:\n\t\thdev->set_bdaddr = btbcm_set_bdaddr;\n\t\tbtbcm_check_bdaddr(hdev);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\ndone:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n/* ------ LDISC part ------ */\n/* hci_uart_tty_open\n *\n *     Called when line discipline changed to HCI_UART.\n *\n * Arguments:\n *     tty    pointer to tty info structure\n * Return Value:\n *     0 if success, otherwise error code\n */\nstatic int hci_uart_tty_open(struct tty_struct *tty)\n{\n\tstruct hci_uart *hu;\n\n\tBT_DBG(\"tty %p\", tty);\n\n\t/* Error if the tty has no write op instead of leaving an exploitable\n\t * hole\n\t */\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\thu = kzalloc(sizeof(struct hci_uart), GFP_KERNEL);\n\tif (!hu) {\n\t\tBT_ERR(\"Can't allocate control structure\");\n\t\treturn -ENFILE;\n\t}\n\n\ttty->disc_data = hu;\n\thu->tty = tty;\n\ttty->receive_room = 65536;\n\n\t/* disable alignment support by default */\n\thu->alignment = 1;\n\thu->padding = 0;\n\n\tINIT_WORK(&hu->init_ready, hci_uart_init_work);\n\tINIT_WORK(&hu->write_work, hci_uart_write_work);\n\n\tpercpu_init_rwsem(&hu->proto_lock);\n\n\t/* Flush any pending characters in the driver */\n\ttty_driver_flush_buffer(tty);\n\n\treturn 0;\n}\n\n/* hci_uart_tty_close()\n *\n *    Called when the line discipline is changed to something\n *    else, the tty is closed, or the tty detects a hangup.\n */\nstatic void hci_uart_tty_close(struct tty_struct *tty)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\tstruct hci_dev *hdev;\n\n\tBT_DBG(\"tty %p\", tty);\n\n\t/* Detach from the tty */\n\ttty->disc_data = NULL;\n\n\tif (!hu)\n\t\treturn;\n\n\thdev = hu->hdev;\n\tif (hdev)\n\t\thci_uart_close(hdev);\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags)) {\n\t\tpercpu_down_write(&hu->proto_lock);\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\tpercpu_up_write(&hu->proto_lock);\n\n\t\tcancel_work_sync(&hu->write_work);\n\n\t\tif (hdev) {\n\t\t\tif (test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\t\t\thci_unregister_dev(hdev);\n\t\t\thci_free_dev(hdev);\n\t\t}\n\t\thu->proto->close(hu);\n\t}\n\tclear_bit(HCI_UART_PROTO_SET, &hu->flags);\n\n\tpercpu_free_rwsem(&hu->proto_lock);\n\n\tkfree(hu);\n}\n\n/* hci_uart_tty_wakeup()\n *\n *    Callback for transmit wakeup. Called when low level\n *    device driver can accept more send data.\n *\n * Arguments:        tty    pointer to associated tty instance data\n * Return Value:    None\n */\nstatic void hci_uart_tty_wakeup(struct tty_struct *tty)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\n\tBT_DBG(\"\");\n\n\tif (!hu)\n\t\treturn;\n\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\n\tif (tty != hu->tty)\n\t\treturn;\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\thci_uart_tx_wakeup(hu);\n}\n\n/* hci_uart_tty_receive()\n *\n *     Called by tty low level driver when receive data is\n *     available.\n *\n * Arguments:  tty          pointer to tty isntance data\n *             data         pointer to received data\n *             flags        pointer to flags for data\n *             count        count of received data in bytes\n *\n * Return Value:    None\n */\nstatic void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data,\n\t\t\t\t char *flags, int count)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\n\tif (!hu || tty != hu->tty)\n\t\treturn;\n\n\tpercpu_down_read(&hu->proto_lock);\n\n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags)) {\n\t\tpercpu_up_read(&hu->proto_lock);\n\t\treturn;\n\t}\n\n\t/* It does not need a lock here as it is already protected by a mutex in\n\t * tty caller\n\t */\n\thu->proto->recv(hu, data, count);\n\tpercpu_up_read(&hu->proto_lock);\n\n\tif (hu->hdev)\n\t\thu->hdev->stat.byte_rx += count;\n\n\ttty_unthrottle(tty);\n}\n\nstatic int hci_uart_register_dev(struct hci_uart *hu)\n{\n\tstruct hci_dev *hdev;\n\tint err;\n\n\tBT_DBG(\"\");\n\n\t/* Initialize and register HCI device */\n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tBT_ERR(\"Can't allocate HCI device\");\n\t\treturn -ENOMEM;\n\t}\n\n\thu->hdev = hdev;\n\n\thdev->bus = HCI_UART;\n\thci_set_drvdata(hdev, hu);\n\n\t/* Only when vendor specific setup callback is provided, consider\n\t * the manufacturer information valid. This avoids filling in the\n\t * value for Ericsson when nothing is specified.\n\t */\n\tif (hu->proto->setup)\n\t\thdev->manufacturer = hu->proto->manufacturer;\n\n\thdev->open  = hci_uart_open;\n\thdev->close = hci_uart_close;\n\thdev->flush = hci_uart_flush;\n\thdev->send  = hci_uart_send_frame;\n\thdev->setup = hci_uart_setup;\n\tSET_HCIDEV_DEV(hdev, hu->tty->dev);\n\n\tif (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))\n\t\tset_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);\n\n\tif (test_bit(HCI_UART_EXT_CONFIG, &hu->hdev_flags))\n\t\tset_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks);\n\n\tif (!test_bit(HCI_UART_RESET_ON_INIT, &hu->hdev_flags))\n\t\tset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\n\n\tif (test_bit(HCI_UART_CREATE_AMP, &hu->hdev_flags))\n\t\thdev->dev_type = HCI_AMP;\n\telse\n\t\thdev->dev_type = HCI_PRIMARY;\n\n\t/* Only call open() for the protocol after hdev is fully initialized as\n\t * open() (or a timer/workqueue it starts) may attempt to reference it.\n\t */\n\terr = hu->proto->open(hu);\n\tif (err) {\n\t\thu->hdev = NULL;\n\t\thci_free_dev(hdev);\n\t\treturn err;\n\t}\n\n\tif (test_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\n\t\treturn 0;\n\n\tif (hci_register_dev(hdev) < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\thu->proto->close(hu);\n\t\thu->hdev = NULL;\n\t\thci_free_dev(hdev);\n\t\treturn -ENODEV;\n\t}\n\n\tset_bit(HCI_UART_REGISTERED, &hu->flags);\n\n\treturn 0;\n}\n\nstatic int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\n\thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int hci_uart_set_flags(struct hci_uart *hu, unsigned long flags)\n{\n\tunsigned long valid_flags = BIT(HCI_UART_RAW_DEVICE) |\n\t\t\t\t    BIT(HCI_UART_RESET_ON_INIT) |\n\t\t\t\t    BIT(HCI_UART_CREATE_AMP) |\n\t\t\t\t    BIT(HCI_UART_INIT_PENDING) |\n\t\t\t\t    BIT(HCI_UART_EXT_CONFIG) |\n\t\t\t\t    BIT(HCI_UART_VND_DETECT);\n\n\tif (flags & ~valid_flags)\n\t\treturn -EINVAL;\n\n\thu->hdev_flags = flags;\n\n\treturn 0;\n}\n\n/* hci_uart_tty_ioctl()\n *\n *    Process IOCTL system call for the tty device.\n *\n * Arguments:\n *\n *    tty        pointer to tty instance data\n *    file       pointer to open file object for device\n *    cmd        IOCTL command code\n *    arg        argument for IOCTL call (cmd dependent)\n *\n * Return Value:    Command dependent\n */\nstatic int hci_uart_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\tint err = 0;\n\n\tBT_DBG(\"\");\n\n\t/* Verify the status of the device */\n\tif (!hu)\n\t\treturn -EBADF;\n\n\tswitch (cmd) {\n\tcase HCIUARTSETPROTO:\n\t\tif (!test_and_set_bit(HCI_UART_PROTO_SET, &hu->flags)) {\n\t\t\terr = hci_uart_set_proto(hu, arg);\n\t\t\tif (err)\n\t\t\t\tclear_bit(HCI_UART_PROTO_SET, &hu->flags);\n\t\t} else\n\t\t\terr = -EBUSY;\n\t\tbreak;\n\n\tcase HCIUARTGETPROTO:\n\t\tif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\n\t\t\terr = hu->proto->id;\n\t\telse\n\t\t\terr = -EUNATCH;\n\t\tbreak;\n\n\tcase HCIUARTGETDEVICE:\n\t\tif (test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\t\terr = hu->hdev->id;\n\t\telse\n\t\t\terr = -EUNATCH;\n\t\tbreak;\n\n\tcase HCIUARTSETFLAGS:\n\t\tif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\n\t\t\terr = -EBUSY;\n\t\telse\n\t\t\terr = hci_uart_set_flags(hu, arg);\n\t\tbreak;\n\n\tcase HCIUARTGETFLAGS:\n\t\terr = hu->hdev_flags;\n\t\tbreak;\n\n\tdefault:\n\t\terr = n_tty_ioctl_helper(tty, file, cmd, arg);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/*\n * We don't provide read/write/poll interface for user space.\n */\nstatic ssize_t hci_uart_tty_read(struct tty_struct *tty, struct file *file,\n\t\t\t\t unsigned char __user *buf, size_t nr)\n{\n\treturn 0;\n}\n\nstatic ssize_t hci_uart_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t\t  const unsigned char *data, size_t count)\n{\n\treturn 0;\n}\n\nstatic __poll_t hci_uart_tty_poll(struct tty_struct *tty,\n\t\t\t\t      struct file *filp, poll_table *wait)\n{\n\treturn 0;\n}\n\nstatic int __init hci_uart_init(void)\n{\n\tstatic struct tty_ldisc_ops hci_uart_ldisc;\n\tint err;\n\n\tBT_INFO(\"HCI UART driver ver %s\", VERSION);\n\n\t/* Register the tty discipline */\n\n\tmemset(&hci_uart_ldisc, 0, sizeof(hci_uart_ldisc));\n\thci_uart_ldisc.magic\t\t= TTY_LDISC_MAGIC;\n\thci_uart_ldisc.name\t\t= \"n_hci\";\n\thci_uart_ldisc.open\t\t= hci_uart_tty_open;\n\thci_uart_ldisc.close\t\t= hci_uart_tty_close;\n\thci_uart_ldisc.read\t\t= hci_uart_tty_read;\n\thci_uart_ldisc.write\t\t= hci_uart_tty_write;\n\thci_uart_ldisc.ioctl\t\t= hci_uart_tty_ioctl;\n\thci_uart_ldisc.compat_ioctl\t= hci_uart_tty_ioctl;\n\thci_uart_ldisc.poll\t\t= hci_uart_tty_poll;\n\thci_uart_ldisc.receive_buf\t= hci_uart_tty_receive;\n\thci_uart_ldisc.write_wakeup\t= hci_uart_tty_wakeup;\n\thci_uart_ldisc.owner\t\t= THIS_MODULE;\n\n\terr = tty_register_ldisc(N_HCI, &hci_uart_ldisc);\n\tif (err) {\n\t\tBT_ERR(\"HCI line discipline registration failed. (%d)\", err);\n\t\treturn err;\n\t}\n\n#ifdef CONFIG_BT_HCIUART_H4\n\th4_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCSP\n\tbcsp_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_LL\n\tll_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_ATH3K\n\tath_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_3WIRE\n\th5_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_INTEL\n\tintel_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCM\n\tbcm_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_QCA\n\tqca_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_AG6XX\n\tag6xx_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_MRVL\n\tmrvl_init();\n#endif\n\n\treturn 0;\n}\n\nstatic void __exit hci_uart_exit(void)\n{\n\tint err;\n\n#ifdef CONFIG_BT_HCIUART_H4\n\th4_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCSP\n\tbcsp_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_LL\n\tll_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_ATH3K\n\tath_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_3WIRE\n\th5_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_INTEL\n\tintel_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCM\n\tbcm_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_QCA\n\tqca_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_AG6XX\n\tag6xx_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_MRVL\n\tmrvl_deinit();\n#endif\n\n\t/* Release tty registration of line discipline */\n\terr = tty_unregister_ldisc(N_HCI);\n\tif (err)\n\t\tBT_ERR(\"Can't unregister HCI line discipline (%d)\", err);\n}\n\nmodule_init(hci_uart_init);\nmodule_exit(hci_uart_exit);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth HCI UART driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_HCI);\n"], "fixing_code": ["/*\n *\n *  Bluetooth HCI UART driver\n *\n *  Copyright (C) 2000-2001  Qualcomm Incorporated\n *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>\n *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>\n *\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/poll.h>\n\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/ioctl.h>\n#include <linux/skbuff.h>\n#include <linux/firmware.h>\n#include <linux/serdev.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btintel.h\"\n#include \"btbcm.h\"\n#include \"hci_uart.h\"\n\n#define VERSION \"2.3\"\n\nstatic const struct hci_uart_proto *hup[HCI_UART_MAX_PROTO];\n\nint hci_uart_register_proto(const struct hci_uart_proto *p)\n{\n\tif (p->id >= HCI_UART_MAX_PROTO)\n\t\treturn -EINVAL;\n\n\tif (hup[p->id])\n\t\treturn -EEXIST;\n\n\thup[p->id] = p;\n\n\tBT_INFO(\"HCI UART protocol %s registered\", p->name);\n\n\treturn 0;\n}\n\nint hci_uart_unregister_proto(const struct hci_uart_proto *p)\n{\n\tif (p->id >= HCI_UART_MAX_PROTO)\n\t\treturn -EINVAL;\n\n\tif (!hup[p->id])\n\t\treturn -EINVAL;\n\n\thup[p->id] = NULL;\n\n\treturn 0;\n}\n\nstatic const struct hci_uart_proto *hci_uart_get_proto(unsigned int id)\n{\n\tif (id >= HCI_UART_MAX_PROTO)\n\t\treturn NULL;\n\n\treturn hup[id];\n}\n\nstatic inline void hci_uart_tx_complete(struct hci_uart *hu, int pkt_type)\n{\n\tstruct hci_dev *hdev = hu->hdev;\n\n\t/* Update HCI stat counters */\n\tswitch (pkt_type) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\t}\n}\n\nstatic inline struct sk_buff *hci_uart_dequeue(struct hci_uart *hu)\n{\n\tstruct sk_buff *skb = hu->tx_skb;\n\n\tif (!skb) {\n\t\tpercpu_down_read(&hu->proto_lock);\n\n\t\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\t\tskb = hu->proto->dequeue(hu);\n\n\t\tpercpu_up_read(&hu->proto_lock);\n\t} else {\n\t\thu->tx_skb = NULL;\n\t}\n\n\treturn skb;\n}\n\nint hci_uart_tx_wakeup(struct hci_uart *hu)\n{\n\t/* This may be called in an IRQ context, so we can't sleep. Therefore\n\t * we try to acquire the lock only, and if that fails we assume the\n\t * tty is being closed because that is the only time the write lock is\n\t * acquired. If, however, at some point in the future the write lock\n\t * is also acquired in other situations, then this must be revisited.\n\t */\n\tif (!percpu_down_read_trylock(&hu->proto_lock))\n\t\treturn 0;\n\n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\tgoto no_schedule;\n\n\tif (test_and_set_bit(HCI_UART_SENDING, &hu->tx_state)) {\n\t\tset_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);\n\t\tgoto no_schedule;\n\t}\n\n\tBT_DBG(\"\");\n\n\tschedule_work(&hu->write_work);\n\nno_schedule:\n\tpercpu_up_read(&hu->proto_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hci_uart_tx_wakeup);\n\nstatic void hci_uart_write_work(struct work_struct *work)\n{\n\tstruct hci_uart *hu = container_of(work, struct hci_uart, write_work);\n\tstruct tty_struct *tty = hu->tty;\n\tstruct hci_dev *hdev = hu->hdev;\n\tstruct sk_buff *skb;\n\n\t/* REVISIT: should we cope with bad skbs or ->write() returning\n\t * and error value ?\n\t */\n\nrestart:\n\tclear_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);\n\n\twhile ((skb = hci_uart_dequeue(hu))) {\n\t\tint len;\n\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\t\tlen = tty->ops->write(tty, skb->data, skb->len);\n\t\thdev->stat.byte_tx += len;\n\n\t\tskb_pull(skb, len);\n\t\tif (skb->len) {\n\t\t\thu->tx_skb = skb;\n\t\t\tbreak;\n\t\t}\n\n\t\thci_uart_tx_complete(hu, hci_skb_pkt_type(skb));\n\t\tkfree_skb(skb);\n\t}\n\n\tif (test_bit(HCI_UART_TX_WAKEUP, &hu->tx_state))\n\t\tgoto restart;\n\n\tclear_bit(HCI_UART_SENDING, &hu->tx_state);\n}\n\nvoid hci_uart_init_work(struct work_struct *work)\n{\n\tstruct hci_uart *hu = container_of(work, struct hci_uart, init_ready);\n\tint err;\n\tstruct hci_dev *hdev;\n\n\tif (!test_and_clear_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\n\t\treturn;\n\n\terr = hci_register_dev(hu->hdev);\n\tif (err < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\thu->proto->close(hu);\n\t\thdev = hu->hdev;\n\t\thu->hdev = NULL;\n\t\thci_free_dev(hdev);\n\t\treturn;\n\t}\n\n\tset_bit(HCI_UART_REGISTERED, &hu->flags);\n}\n\nint hci_uart_init_ready(struct hci_uart *hu)\n{\n\tif (!test_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\n\t\treturn -EALREADY;\n\n\tschedule_work(&hu->init_ready);\n\n\treturn 0;\n}\n\n/* ------- Interface to HCI layer ------ */\n/* Reset device */\nstatic int hci_uart_flush(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu  = hci_get_drvdata(hdev);\n\tstruct tty_struct *tty = hu->tty;\n\n\tBT_DBG(\"hdev %p tty %p\", hdev, tty);\n\n\tif (hu->tx_skb) {\n\t\tkfree_skb(hu->tx_skb); hu->tx_skb = NULL;\n\t}\n\n\t/* Flush any pending characters in the driver and discipline. */\n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\n\tpercpu_down_read(&hu->proto_lock);\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\thu->proto->flush(hu);\n\n\tpercpu_up_read(&hu->proto_lock);\n\n\treturn 0;\n}\n\n/* Initialize device */\nstatic int hci_uart_open(struct hci_dev *hdev)\n{\n\tBT_DBG(\"%s %p\", hdev->name, hdev);\n\n\t/* Undo clearing this from hci_uart_close() */\n\thdev->flush = hci_uart_flush;\n\n\treturn 0;\n}\n\n/* Close device */\nstatic int hci_uart_close(struct hci_dev *hdev)\n{\n\tBT_DBG(\"hdev %p\", hdev);\n\n\thci_uart_flush(hdev);\n\thdev->flush = NULL;\n\treturn 0;\n}\n\n/* Send frames from HCI layer */\nstatic int hci_uart_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"%s: type %d len %d\", hdev->name, hci_skb_pkt_type(skb),\n\t       skb->len);\n\n\tpercpu_down_read(&hu->proto_lock);\n\n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags)) {\n\t\tpercpu_up_read(&hu->proto_lock);\n\t\treturn -EUNATCH;\n\t}\n\n\thu->proto->enqueue(hu, skb);\n\tpercpu_up_read(&hu->proto_lock);\n\n\thci_uart_tx_wakeup(hu);\n\n\treturn 0;\n}\n\n/* Flow control or un-flow control the device */\nvoid hci_uart_set_flow_control(struct hci_uart *hu, bool enable)\n{\n\tstruct tty_struct *tty = hu->tty;\n\tstruct ktermios ktermios;\n\tint status;\n\tunsigned int set = 0;\n\tunsigned int clear = 0;\n\n\tif (hu->serdev) {\n\t\tserdev_device_set_flow_control(hu->serdev, !enable);\n\t\tserdev_device_set_rts(hu->serdev, !enable);\n\t\treturn;\n\t}\n\n\tif (enable) {\n\t\t/* Disable hardware flow control */\n\t\tktermios = tty->termios;\n\t\tktermios.c_cflag &= ~CRTSCTS;\n\t\tstatus = tty_set_termios(tty, &ktermios);\n\t\tBT_DBG(\"Disabling hardware flow control: %s\",\n\t\t       status ? \"failed\" : \"success\");\n\n\t\t/* Clear RTS to prevent the device from sending */\n\t\t/* Most UARTs need OUT2 to enable interrupts */\n\t\tstatus = tty->driver->ops->tiocmget(tty);\n\t\tBT_DBG(\"Current tiocm 0x%x\", status);\n\n\t\tset &= ~(TIOCM_OUT2 | TIOCM_RTS);\n\t\tclear = ~set;\n\t\tset &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t       TIOCM_OUT2 | TIOCM_LOOP;\n\t\tclear &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t\t TIOCM_OUT2 | TIOCM_LOOP;\n\t\tstatus = tty->driver->ops->tiocmset(tty, set, clear);\n\t\tBT_DBG(\"Clearing RTS: %s\", status ? \"failed\" : \"success\");\n\t} else {\n\t\t/* Set RTS to allow the device to send again */\n\t\tstatus = tty->driver->ops->tiocmget(tty);\n\t\tBT_DBG(\"Current tiocm 0x%x\", status);\n\n\t\tset |= (TIOCM_OUT2 | TIOCM_RTS);\n\t\tclear = ~set;\n\t\tset &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t       TIOCM_OUT2 | TIOCM_LOOP;\n\t\tclear &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t\t TIOCM_OUT2 | TIOCM_LOOP;\n\t\tstatus = tty->driver->ops->tiocmset(tty, set, clear);\n\t\tBT_DBG(\"Setting RTS: %s\", status ? \"failed\" : \"success\");\n\n\t\t/* Re-enable hardware flow control */\n\t\tktermios = tty->termios;\n\t\tktermios.c_cflag |= CRTSCTS;\n\t\tstatus = tty_set_termios(tty, &ktermios);\n\t\tBT_DBG(\"Enabling hardware flow control: %s\",\n\t\t       status ? \"failed\" : \"success\");\n\t}\n}\n\nvoid hci_uart_set_speeds(struct hci_uart *hu, unsigned int init_speed,\n\t\t\t unsigned int oper_speed)\n{\n\thu->init_speed = init_speed;\n\thu->oper_speed = oper_speed;\n}\n\nvoid hci_uart_set_baudrate(struct hci_uart *hu, unsigned int speed)\n{\n\tstruct tty_struct *tty = hu->tty;\n\tstruct ktermios ktermios;\n\n\tktermios = tty->termios;\n\tktermios.c_cflag &= ~CBAUD;\n\ttty_termios_encode_baud_rate(&ktermios, speed, speed);\n\n\t/* tty_set_termios() return not checked as it is always 0 */\n\ttty_set_termios(tty, &ktermios);\n\n\tBT_DBG(\"%s: New tty speeds: %d/%d\", hu->hdev->name,\n\t       tty->termios.c_ispeed, tty->termios.c_ospeed);\n}\n\nstatic int hci_uart_setup(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct hci_rp_read_local_version *ver;\n\tstruct sk_buff *skb;\n\tunsigned int speed;\n\tint err;\n\n\t/* Init speed if any */\n\tif (hu->init_speed)\n\t\tspeed = hu->init_speed;\n\telse if (hu->proto->init_speed)\n\t\tspeed = hu->proto->init_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (speed)\n\t\thci_uart_set_baudrate(hu, speed);\n\n\t/* Operational speed if any */\n\tif (hu->oper_speed)\n\t\tspeed = hu->oper_speed;\n\telse if (hu->proto->oper_speed)\n\t\tspeed = hu->proto->oper_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (hu->proto->set_baudrate && speed) {\n\t\terr = hu->proto->set_baudrate(hu, speed);\n\t\tif (!err)\n\t\t\thci_uart_set_baudrate(hu, speed);\n\t}\n\n\tif (hu->proto->setup)\n\t\treturn hu->proto->setup(hu);\n\n\tif (!test_bit(HCI_UART_VND_DETECT, &hu->hdev_flags))\n\t\treturn 0;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tBT_ERR(\"%s: Reading local version information failed (%ld)\",\n\t\t       hdev->name, PTR_ERR(skb));\n\t\treturn 0;\n\t}\n\n\tif (skb->len != sizeof(*ver)) {\n\t\tBT_ERR(\"%s: Event length mismatch for version information\",\n\t\t       hdev->name);\n\t\tgoto done;\n\t}\n\n\tver = (struct hci_rp_read_local_version *)skb->data;\n\n\tswitch (le16_to_cpu(ver->manufacturer)) {\n#ifdef CONFIG_BT_HCIUART_INTEL\n\tcase 2:\n\t\thdev->set_bdaddr = btintel_set_bdaddr;\n\t\tbtintel_check_bdaddr(hdev);\n\t\tbreak;\n#endif\n#ifdef CONFIG_BT_HCIUART_BCM\n\tcase 15:\n\t\thdev->set_bdaddr = btbcm_set_bdaddr;\n\t\tbtbcm_check_bdaddr(hdev);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\ndone:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n/* ------ LDISC part ------ */\n/* hci_uart_tty_open\n *\n *     Called when line discipline changed to HCI_UART.\n *\n * Arguments:\n *     tty    pointer to tty info structure\n * Return Value:\n *     0 if success, otherwise error code\n */\nstatic int hci_uart_tty_open(struct tty_struct *tty)\n{\n\tstruct hci_uart *hu;\n\n\tBT_DBG(\"tty %p\", tty);\n\n\t/* Error if the tty has no write op instead of leaving an exploitable\n\t * hole\n\t */\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\thu = kzalloc(sizeof(struct hci_uart), GFP_KERNEL);\n\tif (!hu) {\n\t\tBT_ERR(\"Can't allocate control structure\");\n\t\treturn -ENFILE;\n\t}\n\n\ttty->disc_data = hu;\n\thu->tty = tty;\n\ttty->receive_room = 65536;\n\n\t/* disable alignment support by default */\n\thu->alignment = 1;\n\thu->padding = 0;\n\n\tINIT_WORK(&hu->init_ready, hci_uart_init_work);\n\tINIT_WORK(&hu->write_work, hci_uart_write_work);\n\n\tpercpu_init_rwsem(&hu->proto_lock);\n\n\t/* Flush any pending characters in the driver */\n\ttty_driver_flush_buffer(tty);\n\n\treturn 0;\n}\n\n/* hci_uart_tty_close()\n *\n *    Called when the line discipline is changed to something\n *    else, the tty is closed, or the tty detects a hangup.\n */\nstatic void hci_uart_tty_close(struct tty_struct *tty)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\tstruct hci_dev *hdev;\n\n\tBT_DBG(\"tty %p\", tty);\n\n\t/* Detach from the tty */\n\ttty->disc_data = NULL;\n\n\tif (!hu)\n\t\treturn;\n\n\thdev = hu->hdev;\n\tif (hdev)\n\t\thci_uart_close(hdev);\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags)) {\n\t\tpercpu_down_write(&hu->proto_lock);\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\tpercpu_up_write(&hu->proto_lock);\n\n\t\tcancel_work_sync(&hu->write_work);\n\n\t\tif (hdev) {\n\t\t\tif (test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\t\t\thci_unregister_dev(hdev);\n\t\t\thci_free_dev(hdev);\n\t\t}\n\t\thu->proto->close(hu);\n\t}\n\tclear_bit(HCI_UART_PROTO_SET, &hu->flags);\n\n\tpercpu_free_rwsem(&hu->proto_lock);\n\n\tkfree(hu);\n}\n\n/* hci_uart_tty_wakeup()\n *\n *    Callback for transmit wakeup. Called when low level\n *    device driver can accept more send data.\n *\n * Arguments:        tty    pointer to associated tty instance data\n * Return Value:    None\n */\nstatic void hci_uart_tty_wakeup(struct tty_struct *tty)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\n\tBT_DBG(\"\");\n\n\tif (!hu)\n\t\treturn;\n\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\n\tif (tty != hu->tty)\n\t\treturn;\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\thci_uart_tx_wakeup(hu);\n}\n\n/* hci_uart_tty_receive()\n *\n *     Called by tty low level driver when receive data is\n *     available.\n *\n * Arguments:  tty          pointer to tty isntance data\n *             data         pointer to received data\n *             flags        pointer to flags for data\n *             count        count of received data in bytes\n *\n * Return Value:    None\n */\nstatic void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data,\n\t\t\t\t char *flags, int count)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\n\tif (!hu || tty != hu->tty)\n\t\treturn;\n\n\tpercpu_down_read(&hu->proto_lock);\n\n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags)) {\n\t\tpercpu_up_read(&hu->proto_lock);\n\t\treturn;\n\t}\n\n\t/* It does not need a lock here as it is already protected by a mutex in\n\t * tty caller\n\t */\n\thu->proto->recv(hu, data, count);\n\tpercpu_up_read(&hu->proto_lock);\n\n\tif (hu->hdev)\n\t\thu->hdev->stat.byte_rx += count;\n\n\ttty_unthrottle(tty);\n}\n\nstatic int hci_uart_register_dev(struct hci_uart *hu)\n{\n\tstruct hci_dev *hdev;\n\tint err;\n\n\tBT_DBG(\"\");\n\n\t/* Initialize and register HCI device */\n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tBT_ERR(\"Can't allocate HCI device\");\n\t\treturn -ENOMEM;\n\t}\n\n\thu->hdev = hdev;\n\n\thdev->bus = HCI_UART;\n\thci_set_drvdata(hdev, hu);\n\n\t/* Only when vendor specific setup callback is provided, consider\n\t * the manufacturer information valid. This avoids filling in the\n\t * value for Ericsson when nothing is specified.\n\t */\n\tif (hu->proto->setup)\n\t\thdev->manufacturer = hu->proto->manufacturer;\n\n\thdev->open  = hci_uart_open;\n\thdev->close = hci_uart_close;\n\thdev->flush = hci_uart_flush;\n\thdev->send  = hci_uart_send_frame;\n\thdev->setup = hci_uart_setup;\n\tSET_HCIDEV_DEV(hdev, hu->tty->dev);\n\n\tif (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))\n\t\tset_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);\n\n\tif (test_bit(HCI_UART_EXT_CONFIG, &hu->hdev_flags))\n\t\tset_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks);\n\n\tif (!test_bit(HCI_UART_RESET_ON_INIT, &hu->hdev_flags))\n\t\tset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\n\n\tif (test_bit(HCI_UART_CREATE_AMP, &hu->hdev_flags))\n\t\thdev->dev_type = HCI_AMP;\n\telse\n\t\thdev->dev_type = HCI_PRIMARY;\n\n\t/* Only call open() for the protocol after hdev is fully initialized as\n\t * open() (or a timer/workqueue it starts) may attempt to reference it.\n\t */\n\terr = hu->proto->open(hu);\n\tif (err) {\n\t\thu->hdev = NULL;\n\t\thci_free_dev(hdev);\n\t\treturn err;\n\t}\n\n\tif (test_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\n\t\treturn 0;\n\n\tif (hci_register_dev(hdev) < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\thu->proto->close(hu);\n\t\thu->hdev = NULL;\n\t\thci_free_dev(hdev);\n\t\treturn -ENODEV;\n\t}\n\n\tset_bit(HCI_UART_REGISTERED, &hu->flags);\n\n\treturn 0;\n}\n\nstatic int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\n\thu->proto = p;\n\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\treturn 0;\n}\n\nstatic int hci_uart_set_flags(struct hci_uart *hu, unsigned long flags)\n{\n\tunsigned long valid_flags = BIT(HCI_UART_RAW_DEVICE) |\n\t\t\t\t    BIT(HCI_UART_RESET_ON_INIT) |\n\t\t\t\t    BIT(HCI_UART_CREATE_AMP) |\n\t\t\t\t    BIT(HCI_UART_INIT_PENDING) |\n\t\t\t\t    BIT(HCI_UART_EXT_CONFIG) |\n\t\t\t\t    BIT(HCI_UART_VND_DETECT);\n\n\tif (flags & ~valid_flags)\n\t\treturn -EINVAL;\n\n\thu->hdev_flags = flags;\n\n\treturn 0;\n}\n\n/* hci_uart_tty_ioctl()\n *\n *    Process IOCTL system call for the tty device.\n *\n * Arguments:\n *\n *    tty        pointer to tty instance data\n *    file       pointer to open file object for device\n *    cmd        IOCTL command code\n *    arg        argument for IOCTL call (cmd dependent)\n *\n * Return Value:    Command dependent\n */\nstatic int hci_uart_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\tint err = 0;\n\n\tBT_DBG(\"\");\n\n\t/* Verify the status of the device */\n\tif (!hu)\n\t\treturn -EBADF;\n\n\tswitch (cmd) {\n\tcase HCIUARTSETPROTO:\n\t\tif (!test_and_set_bit(HCI_UART_PROTO_SET, &hu->flags)) {\n\t\t\terr = hci_uart_set_proto(hu, arg);\n\t\t\tif (err)\n\t\t\t\tclear_bit(HCI_UART_PROTO_SET, &hu->flags);\n\t\t} else\n\t\t\terr = -EBUSY;\n\t\tbreak;\n\n\tcase HCIUARTGETPROTO:\n\t\tif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\n\t\t\terr = hu->proto->id;\n\t\telse\n\t\t\terr = -EUNATCH;\n\t\tbreak;\n\n\tcase HCIUARTGETDEVICE:\n\t\tif (test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\t\terr = hu->hdev->id;\n\t\telse\n\t\t\terr = -EUNATCH;\n\t\tbreak;\n\n\tcase HCIUARTSETFLAGS:\n\t\tif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\n\t\t\terr = -EBUSY;\n\t\telse\n\t\t\terr = hci_uart_set_flags(hu, arg);\n\t\tbreak;\n\n\tcase HCIUARTGETFLAGS:\n\t\terr = hu->hdev_flags;\n\t\tbreak;\n\n\tdefault:\n\t\terr = n_tty_ioctl_helper(tty, file, cmd, arg);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/*\n * We don't provide read/write/poll interface for user space.\n */\nstatic ssize_t hci_uart_tty_read(struct tty_struct *tty, struct file *file,\n\t\t\t\t unsigned char __user *buf, size_t nr)\n{\n\treturn 0;\n}\n\nstatic ssize_t hci_uart_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t\t  const unsigned char *data, size_t count)\n{\n\treturn 0;\n}\n\nstatic __poll_t hci_uart_tty_poll(struct tty_struct *tty,\n\t\t\t\t      struct file *filp, poll_table *wait)\n{\n\treturn 0;\n}\n\nstatic int __init hci_uart_init(void)\n{\n\tstatic struct tty_ldisc_ops hci_uart_ldisc;\n\tint err;\n\n\tBT_INFO(\"HCI UART driver ver %s\", VERSION);\n\n\t/* Register the tty discipline */\n\n\tmemset(&hci_uart_ldisc, 0, sizeof(hci_uart_ldisc));\n\thci_uart_ldisc.magic\t\t= TTY_LDISC_MAGIC;\n\thci_uart_ldisc.name\t\t= \"n_hci\";\n\thci_uart_ldisc.open\t\t= hci_uart_tty_open;\n\thci_uart_ldisc.close\t\t= hci_uart_tty_close;\n\thci_uart_ldisc.read\t\t= hci_uart_tty_read;\n\thci_uart_ldisc.write\t\t= hci_uart_tty_write;\n\thci_uart_ldisc.ioctl\t\t= hci_uart_tty_ioctl;\n\thci_uart_ldisc.compat_ioctl\t= hci_uart_tty_ioctl;\n\thci_uart_ldisc.poll\t\t= hci_uart_tty_poll;\n\thci_uart_ldisc.receive_buf\t= hci_uart_tty_receive;\n\thci_uart_ldisc.write_wakeup\t= hci_uart_tty_wakeup;\n\thci_uart_ldisc.owner\t\t= THIS_MODULE;\n\n\terr = tty_register_ldisc(N_HCI, &hci_uart_ldisc);\n\tif (err) {\n\t\tBT_ERR(\"HCI line discipline registration failed. (%d)\", err);\n\t\treturn err;\n\t}\n\n#ifdef CONFIG_BT_HCIUART_H4\n\th4_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCSP\n\tbcsp_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_LL\n\tll_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_ATH3K\n\tath_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_3WIRE\n\th5_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_INTEL\n\tintel_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCM\n\tbcm_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_QCA\n\tqca_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_AG6XX\n\tag6xx_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_MRVL\n\tmrvl_init();\n#endif\n\n\treturn 0;\n}\n\nstatic void __exit hci_uart_exit(void)\n{\n\tint err;\n\n#ifdef CONFIG_BT_HCIUART_H4\n\th4_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCSP\n\tbcsp_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_LL\n\tll_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_ATH3K\n\tath_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_3WIRE\n\th5_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_INTEL\n\tintel_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCM\n\tbcm_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_QCA\n\tqca_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_AG6XX\n\tag6xx_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_MRVL\n\tmrvl_deinit();\n#endif\n\n\t/* Release tty registration of line discipline */\n\terr = tty_unregister_ldisc(N_HCI);\n\tif (err)\n\t\tBT_ERR(\"Can't unregister HCI line discipline (%d)\", err);\n}\n\nmodule_init(hci_uart_init);\nmodule_exit(hci_uart_exit);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth HCI UART driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_HCI);\n"], "filenames": ["drivers/bluetooth/hci_ldisc.c"], "buggy_code_start_loc": [699], "buggy_code_end_loc": [706], "fixing_code_start_loc": [698], "fixing_code_end_loc": [706], "type": "CWE-416", "message": "An issue was discovered in the Linux kernel before 5.0.5. There is a use-after-free issue when hci_uart_register_dev() fails in hci_uart_set_proto() in drivers/bluetooth/hci_ldisc.c.", "other": {"cve": {"id": "CVE-2019-15917", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-04T19:15:11.910", "lastModified": "2020-03-09T14:29:14.123", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.0.5. There is a use-after-free issue when hci_uart_register_dev() fails in hci_uart_set_proto() in drivers/bluetooth/hci_ldisc.c."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux versiones anteriores a 5.0.5. Se presenta un problema de uso de la memoria previamente liberada cuando la funci\u00f3n hci_uart_register_dev() presenta un fallo en funci\u00f3n hci_uart_set_proto() en el archivo drivers/bluetooth/hci_ldisc.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.0.5", "matchCriteriaId": "F505B820-63E3-4406-9EB2-66F655179289"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00064.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00066.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/155890/Slackware-Security-Advisory-Slackware-14.2-kernel-Updates.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.0.5", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/56897b217a1d0a91c9920cb418d6b3fe922f590a", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/09/msg00025.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00001.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2020/Jan/10", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191004-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/56897b217a1d0a91c9920cb418d6b3fe922f590a"}}