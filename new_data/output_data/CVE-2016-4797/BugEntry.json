{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR \n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/* ----------------------------------------------------------------------- */\n\n/* TODO MSD: */\n#ifdef TODO_MSD \nvoid tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t * img) {\n        int tileno, compno, resno, bandno, precno;/*, cblkno;*/\n\n        fprintf(fd, \"image {\\n\");\n        fprintf(fd, \"  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\\n\", \n                img->tw, img->th, tcd->image->x0, tcd->image->x1, tcd->image->y0, tcd->image->y1);\n\n        for (tileno = 0; tileno < img->th * img->tw; tileno++) {\n                opj_tcd_tile_t *tile = &tcd->tcd_image->tiles[tileno];\n                fprintf(fd, \"  tile {\\n\");\n                fprintf(fd, \"    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\\n\",\n                        tile->x0, tile->y0, tile->x1, tile->y1, tile->numcomps);\n                for (compno = 0; compno < tile->numcomps; compno++) {\n                        opj_tcd_tilecomp_t *tilec = &tile->comps[compno];\n                        fprintf(fd, \"    tilec {\\n\");\n                        fprintf(fd,\n                                \"      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\\n\",\n                                tilec->x0, tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);\n                        for (resno = 0; resno < tilec->numresolutions; resno++) {\n                                opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n                                fprintf(fd, \"\\n   res {\\n\");\n                                fprintf(fd,\n                                        \"          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\\n\",\n                                        res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);\n                                for (bandno = 0; bandno < res->numbands; bandno++) {\n                                        opj_tcd_band_t *band = &res->bands[bandno];\n                                        fprintf(fd, \"        band {\\n\");\n                                        fprintf(fd,\n                                                \"          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\\n\",\n                                                band->x0, band->y0, band->x1, band->y1, band->stepsize, band->numbps);\n                                        for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                                opj_tcd_precinct_t *prec = &band->precincts[precno];\n                                                fprintf(fd, \"          prec {\\n\");\n                                                fprintf(fd,\n                                                        \"            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\\n\",\n                                                        prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);\n                                                /*\n                                                for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {\n                                                        opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];\n                                                        fprintf(fd, \"            cblk {\\n\");\n                                                        fprintf(fd,\n                                                                \"              x0=%d, y0=%d, x1=%d, y1=%d\\n\",\n                                                                cblk->x0, cblk->y0, cblk->x1, cblk->y1);\n                                                        fprintf(fd, \"            }\\n\");\n                                                }\n                                                */\n                                                fprintf(fd, \"          }\\n\");\n                                        }\n                                        fprintf(fd, \"        }\\n\");\n                                }\n                                fprintf(fd, \"      }\\n\");\n                        }\n                        fprintf(fd, \"    }\\n\");\n                }\n                fprintf(fd, \"  }\\n\");\n        }\n        fprintf(fd, \"}\\n\");\n}\n#endif\n\n/**\n * Initializes tile coding/decoding\n */\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block, opj_event_mgr_t* manager);\n\n/**\n* Allocates memory for a decoding code block.\n*/\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate (opj_tcd_cblk_dec_t * p_code_block);\n\n/**\n * Deallocates the decoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_dec_deallocate (opj_tcd_precinct_t * p_precinct);\n\n/**\n * Allocates memory for an encoding code block (but not data).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate (opj_tcd_cblk_enc_t * p_code_block);\n\n/**\n * Allocates data for an encoding code block\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data (opj_tcd_cblk_enc_t * p_code_block);\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_enc_deallocate (opj_tcd_precinct_t * p_precinct);\n\n\n/**\nFree the memory allocated for encoding\n@param tcd TCD handle\n*/\nstatic void opj_tcd_free_tile(opj_tcd_t *tcd);\n\n\nstatic OPJ_BOOL opj_tcd_t2_decode ( opj_tcd_t *p_tcd,\n                                    OPJ_BYTE * p_src_data,\n                                    OPJ_UINT32 * p_data_read,\n                                    OPJ_UINT32 p_max_src_size,\n                                    opj_codestream_index_t *p_cstr_index,\n                                    opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_tcd_t1_decode (opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_dwt_decode (opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_mct_decode (opj_tcd_t *p_tcd, opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_decode (opj_tcd_t *p_tcd);\n\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_mct_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_dwt_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_t1_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_t2_encode (     opj_tcd_t *p_tcd,\n                                                                    OPJ_BYTE * p_dest_data,\n                                                                    OPJ_UINT32 * p_data_written,\n                                                                    OPJ_UINT32 p_max_dest_size,\n                                                                    opj_codestream_info_t *p_cstr_info );\n\nstatic OPJ_BOOL opj_tcd_rate_allocate_encode(   opj_tcd_t *p_tcd,\n                                                                                        OPJ_BYTE * p_dest_data,\n                                                                                        OPJ_UINT32 p_max_dest_size,\n                                                                                        opj_codestream_info_t *p_cstr_info );\n\n/* ----------------------------------------------------------------------- */\n\n/**\nCreate a new TCD handle\n*/\nopj_tcd_t* opj_tcd_create(OPJ_BOOL p_is_decoder)\n{\n        opj_tcd_t *l_tcd = 00;\n\n        /* create the tcd structure */\n        l_tcd = (opj_tcd_t*) opj_calloc(1,sizeof(opj_tcd_t));\n        if (!l_tcd) {\n                return 00;\n        }\n\n        l_tcd->m_is_decoder = p_is_decoder ? 1 : 0;\n\n        l_tcd->tcd_image = (opj_tcd_image_t*)opj_calloc(1,sizeof(opj_tcd_image_t));\n        if (!l_tcd->tcd_image) {\n                opj_free(l_tcd);\n                return 00;\n        }\n\n        return l_tcd;\n}\n\n\n/* ----------------------------------------------------------------------- */\n\nvoid opj_tcd_rateallocate_fixed(opj_tcd_t *tcd) {\n        OPJ_UINT32 layno;\n\n        for (layno = 0; layno < tcd->tcp->numlayers; layno++) {\n                opj_tcd_makelayer_fixed(tcd, layno, 1);\n        }\n}\n\n\nvoid opj_tcd_makelayer( opj_tcd_t *tcd,\n                                                OPJ_UINT32 layno,\n                                                OPJ_FLOAT64 thresh,\n                                                OPJ_UINT32 final)\n{\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n        OPJ_UINT32 passno;\n\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n\n        tcd_tile->distolayer[layno] = 0;        /* fixed_quality */\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                                                opj_tcd_layer_t *layer = &cblk->layers[layno];\n                                                OPJ_UINT32 n;\n\n                                                if (layno == 0) {\n                                                        cblk->numpassesinlayers = 0;\n                                                }\n\n                                                n = cblk->numpassesinlayers;\n\n                                                for (passno = cblk->numpassesinlayers; passno < cblk->totalpasses; passno++) {\n                                                        OPJ_UINT32 dr;\n                                                        OPJ_FLOAT64 dd;\n                                                        opj_tcd_pass_t *pass = &cblk->passes[passno];\n\n                                                        if (n == 0) {\n                                                                dr = pass->rate;\n                                                                dd = pass->distortiondec;\n                                                        } else {\n                                                                dr = pass->rate - cblk->passes[n - 1].rate;\n                                                                dd = pass->distortiondec - cblk->passes[n - 1].distortiondec;\n                                                        }\n\n                                                        if (!dr) {\n                                                                if (dd != 0)\n                                                                        n = passno + 1;\n                                                                continue;\n                                                        }\n                                                        if (thresh - (dd / dr) < DBL_EPSILON) /* do not rely on float equality, check with DBL_EPSILON margin */\n                                                                n = passno + 1;\n                                                }\n\n                                                layer->numpasses = n - cblk->numpassesinlayers;\n\n                                                if (!layer->numpasses) {\n                                                        layer->disto = 0;\n                                                        continue;\n                                                }\n\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        layer->len = cblk->passes[n - 1].rate;\n                                                        layer->data = cblk->data;\n                                                        layer->disto = cblk->passes[n - 1].distortiondec;\n                                                } else {\n                                                        layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->disto = cblk->passes[n - 1].distortiondec - cblk->passes[cblk->numpassesinlayers - 1].distortiondec;\n                                                }\n\n                                                tcd_tile->distolayer[layno] += layer->disto;    /* fixed_quality */\n\n                                                if (final)\n                                                        cblk->numpassesinlayers = n;\n                                        }\n                                }\n                        }\n                }\n        }\n}\n\nvoid opj_tcd_makelayer_fixed(opj_tcd_t *tcd, OPJ_UINT32 layno, OPJ_UINT32 final) {\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n        OPJ_INT32 value;                        /*, matrice[tcd_tcp->numlayers][tcd_tile->comps[0].numresolutions][3]; */\n        OPJ_INT32 matrice[10][10][3];\n        OPJ_UINT32 i, j, k;\n\n        opj_cp_t *cp = tcd->cp;\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n        opj_tcp_t *tcd_tcp = tcd->tcp;\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n                for (i = 0; i < tcd_tcp->numlayers; i++) {\n                        for (j = 0; j < tilec->numresolutions; j++) {\n                                for (k = 0; k < 3; k++) {\n                                        matrice[i][j][k] =\n                                                (OPJ_INT32) ((OPJ_FLOAT32)cp->m_specific_param.m_enc.m_matrice[i * tilec->numresolutions * 3 + j * 3 + k]\n                                                * (OPJ_FLOAT32) (tcd->image->comps[compno].prec / 16.0));\n                                }\n                        }\n                }\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                                                opj_tcd_layer_t *layer = &cblk->layers[layno];\n                                                OPJ_UINT32 n;\n                                                OPJ_INT32 imsb = (OPJ_INT32)(tcd->image->comps[compno].prec - cblk->numbps); /* number of bit-plan equal to zero */\n\n                                                /* Correction of the matrix of coefficient to include the IMSB information */\n                                                if (layno == 0) {\n                                                        value = matrice[layno][resno][bandno];\n                                                        if (imsb >= value) {\n                                                                value = 0;\n                                                        } else {\n                                                                value -= imsb;\n                                                        }\n                                                } else {\n                                                        value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];\n                                                        if (imsb >= matrice[layno - 1][resno][bandno]) {\n                                                                value -= (imsb - matrice[layno - 1][resno][bandno]);\n                                                                if (value < 0) {\n                                                                        value = 0;\n                                                                }\n                                                        }\n                                                }\n\n                                                if (layno == 0) {\n                                                        cblk->numpassesinlayers = 0;\n                                                }\n\n                                                n = cblk->numpassesinlayers;\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        if (value != 0) {\n                                                                n = 3 * (OPJ_UINT32)value - 2 + cblk->numpassesinlayers;\n                                                        } else {\n                                                                n = cblk->numpassesinlayers;\n                                                        }\n                                                } else {\n                                                        n = 3 * (OPJ_UINT32)value + cblk->numpassesinlayers;\n                                                }\n\n                                                layer->numpasses = n - cblk->numpassesinlayers;\n\n                                                if (!layer->numpasses)\n                                                        continue;\n\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        layer->len = cblk->passes[n - 1].rate;\n                                                        layer->data = cblk->data;\n                                                } else {\n                                                        layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                }\n\n                                                if (final)\n                                                        cblk->numpassesinlayers = n;\n                                        }\n                                }\n                        }\n                }\n        }\n}\n\nOPJ_BOOL opj_tcd_rateallocate(  opj_tcd_t *tcd,\n                                                                OPJ_BYTE *dest,\n                                                                OPJ_UINT32 * p_data_written,\n                                                                OPJ_UINT32 len,\n                                                                opj_codestream_info_t *cstr_info)\n{\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno, layno;\n        OPJ_UINT32 passno;\n        OPJ_FLOAT64 min, max;\n        OPJ_FLOAT64 cumdisto[100];      /* fixed_quality */\n        const OPJ_FLOAT64 K = 1;                /* 1.1; fixed_quality */\n        OPJ_FLOAT64 maxSE = 0;\n\n        opj_cp_t *cp = tcd->cp;\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n        opj_tcp_t *tcd_tcp = tcd->tcp;\n\n        min = DBL_MAX;\n        max = 0;\n\n        tcd_tile->numpix = 0;           /* fixed_quality */\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n                tilec->numpix = 0;\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n\n                                                for (passno = 0; passno < cblk->totalpasses; passno++) {\n                                                        opj_tcd_pass_t *pass = &cblk->passes[passno];\n                                                        OPJ_INT32 dr;\n                                                        OPJ_FLOAT64 dd, rdslope;\n\n                                                        if (passno == 0) {\n                                                                dr = (OPJ_INT32)pass->rate;\n                                                                dd = pass->distortiondec;\n                                                        } else {\n                                                                dr = (OPJ_INT32)(pass->rate - cblk->passes[passno - 1].rate);\n                                                                dd = pass->distortiondec - cblk->passes[passno - 1].distortiondec;\n                                                        }\n\n                                                        if (dr == 0) {\n                                                                continue;\n                                                        }\n\n                                                        rdslope = dd / dr;\n                                                        if (rdslope < min) {\n                                                                min = rdslope;\n                                                        }\n\n                                                        if (rdslope > max) {\n                                                                max = rdslope;\n                                                        }\n                                                } /* passno */\n\n                                                /* fixed_quality */\n                                                tcd_tile->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                                                tilec->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                                        } /* cbklno */\n                                } /* precno */\n                        } /* bandno */\n                } /* resno */\n\n                maxSE += (((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) - 1.0)\n                        * ((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) -1.0))\n                        * ((OPJ_FLOAT64)(tilec->numpix));\n        } /* compno */\n\n        /* index file */\n        if(cstr_info) {\n                opj_tile_info_t *tile_info = &cstr_info->tile[tcd->tcd_tileno];\n                tile_info->numpix = tcd_tile->numpix;\n                tile_info->distotile = tcd_tile->distotile;\n                tile_info->thresh = (OPJ_FLOAT64 *) opj_malloc(tcd_tcp->numlayers * sizeof(OPJ_FLOAT64));\n                if (!tile_info->thresh) {\n                        /* FIXME event manager error callback */\n                        return OPJ_FALSE;\n                }\n        }\n\n        for (layno = 0; layno < tcd_tcp->numlayers; layno++) {\n                OPJ_FLOAT64 lo = min;\n                OPJ_FLOAT64 hi = max;\n                OPJ_UINT32 maxlen = tcd_tcp->rates[layno] > 0.0f ? opj_uint_min(((OPJ_UINT32) ceil(tcd_tcp->rates[layno])), len) : len;\n                OPJ_FLOAT64 goodthresh = 0;\n                OPJ_FLOAT64 stable_thresh = 0;\n                OPJ_UINT32 i;\n                OPJ_FLOAT64 distotarget;                /* fixed_quality */\n\n                /* fixed_quality */\n                distotarget = tcd_tile->distotile - ((K * maxSE) / pow((OPJ_FLOAT32)10, tcd_tcp->distoratio[layno] / 10));\n\n                /* Don't try to find an optimal threshold but rather take everything not included yet, if\n                  -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)\n                  -q xx,yy,zz,0   (fixed_quality == 1 and distoratio == 0)\n                  ==> possible to have some lossy layers and the last layer for sure lossless */\n                if ( ((cp->m_specific_param.m_enc.m_disto_alloc==1) && (tcd_tcp->rates[layno]>0.0f)) || ((cp->m_specific_param.m_enc.m_fixed_quality==1) && (tcd_tcp->distoratio[layno]>0.0))) {\n                        opj_t2_t*t2 = opj_t2_create(tcd->image, cp);\n                        OPJ_FLOAT64 thresh = 0;\n\n                        if (t2 == 00) {\n                                return OPJ_FALSE;\n                        }\n\n                        for     (i = 0; i < 128; ++i) {\n                                OPJ_FLOAT64 distoachieved = 0;  /* fixed_quality */\n\n                                thresh = (lo + hi) / 2;\n\n                                opj_tcd_makelayer(tcd, layno, thresh, 0);\n\n                                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* fixed_quality */\n                                        if(OPJ_IS_CINEMA(cp->rsiz)){\n                                                if (! opj_t2_encode_packets(t2,tcd->tcd_tileno, tcd_tile, layno + 1, dest, p_data_written, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC)) {\n\n                                                        lo = thresh;\n                                                        continue;\n                                                }\n                                                else {\n                                                        distoachieved = layno == 0 ?\n                                                                        tcd_tile->distolayer[0] : cumdisto[layno - 1] + tcd_tile->distolayer[layno];\n\n                                                        if (distoachieved < distotarget) {\n                                                                hi=thresh;\n                                                                stable_thresh = thresh;\n                                                                continue;\n                                                        }else{\n                                                                lo=thresh;\n                                                        }\n                                                }\n                                        }else{\n                                                distoachieved = (layno == 0) ?\n                                                                tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n\n                                                if (distoachieved < distotarget) {\n                                                        hi = thresh;\n                                                        stable_thresh = thresh;\n                                                        continue;\n                                                }\n                                                lo = thresh;\n                                        }\n                                } else {\n                                        if (! opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,p_data_written, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC))\n                                        {\n                                                /* TODO: what to do with l ??? seek / tell ??? */\n                                                /* opj_event_msg(tcd->cinfo, EVT_INFO, \"rate alloc: len=%d, max=%d\\n\", l, maxlen); */\n                                                lo = thresh;\n                                                continue;\n                                        }\n\n                                        hi = thresh;\n                                        stable_thresh = thresh;\n                                }\n                        }\n\n                        goodthresh = stable_thresh == 0? thresh : stable_thresh;\n\n                        opj_t2_destroy(t2);\n                } else {\n                        goodthresh = min;\n                }\n\n                if(cstr_info) { /* Threshold for Marcela Index */\n                        cstr_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;\n                }\n\n                opj_tcd_makelayer(tcd, layno, goodthresh, 1);\n\n                /* fixed_quality */\n                cumdisto[layno] = (layno == 0) ? tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init( opj_tcd_t *p_tcd,\n                                           opj_image_t * p_image,\n                                           opj_cp_t * p_cp )\n{\n        p_tcd->image = p_image;\n        p_tcd->cp = p_cp;\n\n        p_tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_calloc(1,sizeof(opj_tcd_tile_t));\n        if (! p_tcd->tcd_image->tiles) {\n                return OPJ_FALSE;\n        }\n\n        p_tcd->tcd_image->tiles->comps = (opj_tcd_tilecomp_t *) opj_calloc(p_image->numcomps,sizeof(opj_tcd_tilecomp_t));\n        if (! p_tcd->tcd_image->tiles->comps ) {\n                return OPJ_FALSE;\n        }\n\n        p_tcd->tcd_image->tiles->numcomps = p_image->numcomps;\n        p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;\n\n        return OPJ_TRUE;\n}\n\n/**\nDestroy a previously created TCD handle\n*/\nvoid opj_tcd_destroy(opj_tcd_t *tcd) {\n        if (tcd) {\n                opj_tcd_free_tile(tcd);\n\n                if (tcd->tcd_image) {\n                        opj_free(tcd->tcd_image);\n                        tcd->tcd_image = 00;\n                }\n                opj_free(tcd);\n        }\n}\n\nOPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec)\n{\n\tif ((l_tilec->data == 00) || ((l_tilec->data_size_needed > l_tilec->data_size) && (l_tilec->ownsData == OPJ_FALSE))) {\n\t\tl_tilec->data = (OPJ_INT32 *) opj_aligned_malloc(l_tilec->data_size_needed);\n\t\tif (! l_tilec->data ) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t/*fprintf(stderr, \"tAllocate data of tilec (int): %d x OPJ_UINT32n\",l_data_size);*/\n\t\tl_tilec->data_size = l_tilec->data_size_needed;\n\t\tl_tilec->ownsData = OPJ_TRUE;\n\t}\n\telse if (l_tilec->data_size_needed > l_tilec->data_size) {\n\t\t/* We don't need to keep old data */\n\t\topj_aligned_free(l_tilec->data);\n\t\tl_tilec->data = (OPJ_INT32 *) opj_aligned_malloc(l_tilec->data_size_needed);\n\t\tif (! l_tilec->data ) {\n\t\t\tl_tilec->data_size = 0;\n\t\t\tl_tilec->data_size_needed = 0;\n\t\t\tl_tilec->ownsData = OPJ_FALSE;\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t/*fprintf(stderr, \"tReallocate data of tilec (int): from %d to %d x OPJ_UINT32n\", l_tilec->data_size, l_data_size);*/\n\t\tl_tilec->data_size = l_tilec->data_size_needed;\n\t\tl_tilec->ownsData = OPJ_TRUE;\n\t}\n\treturn OPJ_TRUE;\n}\n\n/* ----------------------------------------------------------------------- */\n\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block, opj_event_mgr_t* manager)\n{\n\tOPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32) = 00;\n\tOPJ_UINT32 compno, resno, bandno, precno, cblkno;\n\topj_tcp_t * l_tcp = 00;\n\topj_cp_t * l_cp = 00;\n\topj_tcd_tile_t * l_tile = 00;\n\topj_tccp_t *l_tccp = 00;\n\topj_tcd_tilecomp_t *l_tilec = 00;\n\topj_image_comp_t * l_image_comp = 00;\n\topj_tcd_resolution_t *l_res = 00;\n\topj_tcd_band_t *l_band = 00;\n\topj_stepsize_t * l_step_size = 00;\n\topj_tcd_precinct_t *l_current_precinct = 00;\n\topj_image_t *l_image = 00;\n\tOPJ_UINT32 p,q;\n\tOPJ_UINT32 l_level_no;\n\tOPJ_UINT32 l_pdx, l_pdy;\n\tOPJ_UINT32 l_gain;\n\tOPJ_INT32 l_x0b, l_y0b;\n\tOPJ_UINT32 l_tx0, l_ty0;\n\t/* extent of precincts , top left, bottom right**/\n\tOPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;\n\t/* number of precinct for a resolution */\n\tOPJ_UINT32 l_nb_precincts;\n\t/* room needed to store l_nb_precinct precinct for a resolution */\n\tOPJ_UINT32 l_nb_precinct_size;\n\t/* number of code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks;\n\t/* room needed to store l_nb_code_blocks code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks_size;\n\t/* size of data for a tile */\n\tOPJ_UINT32 l_data_size;\n\t\n\tl_cp = p_tcd->cp;\n\tl_tcp = &(l_cp->tcps[p_tile_no]);\n\tl_tile = p_tcd->tcd_image->tiles;\n\tl_tccp = l_tcp->tccps;\n\tl_tilec = l_tile->comps;\n\tl_image = p_tcd->image;\n\tl_image_comp = p_tcd->image->comps;\n\t\n\tp = p_tile_no % l_cp->tw;       /* tile coordinates */\n\tq = p_tile_no / l_cp->tw;\n\t/*fprintf(stderr, \"Tile coordinate = %d,%d\\n\", p, q);*/\n\t\n\t/* 4 borders of the tile rescale on the image if necessary */\n\tl_tx0 = l_cp->tx0 + p * l_cp->tdx; /* can't be greater than l_image->x1 so won't overflow */\n\tl_tile->x0 = (OPJ_INT32)opj_uint_max(l_tx0, l_image->x0);\n\tl_tile->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, l_cp->tdx), l_image->x1);\n\tl_ty0 = l_cp->ty0 + q * l_cp->tdy; /* can't be greater than l_image->y1 so won't overflow */\n\tl_tile->y0 = (OPJ_INT32)opj_uint_max(l_ty0, l_image->y0);\n\tl_tile->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, l_cp->tdy), l_image->y1);\n\n\t/* testcase 1888.pdf.asan.35.988 */\n\tif (l_tccp->numresolutions == 0) {\n\t\topj_event_msg(manager, EVT_ERROR, \"tiles require at least one resolution\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t/*fprintf(stderr, \"Tile border = %d,%d,%d,%d\\n\", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);*/\n\t\n\t/*tile->numcomps = image->numcomps; */\n\tfor (compno = 0; compno < l_tile->numcomps; ++compno) {\n\t\t/*fprintf(stderr, \"compno = %d/%d\\n\", compno, l_tile->numcomps);*/\n\t\tl_image_comp->resno_decoded = 0;\n\t\t/* border of each l_tile component (global) */\n\t\tl_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);\n\t\tl_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);\n\t\tl_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);\n\t\tl_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);\n\t\t/*fprintf(stderr, \"\\tTile compo border = %d,%d,%d,%d\\n\", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);*/\n\t\t\n\t\t/* compute l_data_size with overflow check */\n\t\tl_data_size = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);\n\t\tif ((((OPJ_UINT32)-1) / l_data_size) < (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0)) {\n\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);\n\t\t\n\t\tif ((((OPJ_UINT32)-1) / (OPJ_UINT32)sizeof(OPJ_UINT32)) < l_data_size) {\n\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)sizeof(OPJ_UINT32);\n\t\tl_tilec->numresolutions = l_tccp->numresolutions;\n\t\tif (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {\n\t\t\tl_tilec->minimum_num_resolutions = 1;\n\t\t}\n\t\telse {\n\t\t\tl_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;\n\t\t}\n\t\t\n\t\tl_tilec->data_size_needed = l_data_size;\n\t\tif (p_tcd->m_is_decoder && !opj_alloc_tile_component_data(l_tilec)) {\n\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\tl_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(opj_tcd_resolution_t);\n\t\t\n\t\tif (l_tilec->resolutions == 00) {\n\t\t\tl_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);\n\t\t\tif (! l_tilec->resolutions ) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\t/*fprintf(stderr, \"\\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\\n\",l_data_size);*/\n\t\t\tl_tilec->resolutions_size = l_data_size;\n\t\t\tmemset(l_tilec->resolutions,0,l_data_size);\n\t\t}\n\t\telse if (l_data_size > l_tilec->resolutions_size) {\n\t\t\topj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(l_tilec->resolutions, l_data_size);\n\t\t\tif (! new_resolutions) {\n\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile resolutions\\n\");\n\t\t\t\topj_free(l_tilec->resolutions);\n\t\t\t\tl_tilec->resolutions = NULL;\n\t\t\t\tl_tilec->resolutions_size = 0;\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\tl_tilec->resolutions = new_resolutions;\n\t\t\t/*fprintf(stderr, \"\\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\\n\", l_tilec->resolutions_size, l_data_size);*/\n\t\t\tmemset(((OPJ_BYTE*) l_tilec->resolutions)+l_tilec->resolutions_size,0,l_data_size - l_tilec->resolutions_size);\n\t\t\tl_tilec->resolutions_size = l_data_size;\n\t\t}\n\t\t\n\t\tl_level_no = l_tilec->numresolutions;\n\t\tl_res = l_tilec->resolutions;\n\t\tl_step_size = l_tccp->stepsizes;\n\t\tif (l_tccp->qmfbid == 0) {\n\t\t\tl_gain_ptr = &opj_dwt_getgain_real;\n\t\t}\n\t\telse {\n\t\t\tl_gain_ptr  = &opj_dwt_getgain;\n\t\t}\n\t\t/*fprintf(stderr, \"\\tlevel_no=%d\\n\",l_level_no);*/\n\t\t\n\t\tfor (resno = 0; resno < l_tilec->numresolutions; ++resno) {\n\t\t\t/*fprintf(stderr, \"\\t\\tresno = %d/%d\\n\", resno, l_tilec->numresolutions);*/\n\t\t\tOPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;\n\t\t\tOPJ_UINT32 cbgwidthexpn, cbgheightexpn;\n\t\t\tOPJ_UINT32 cblkwidthexpn, cblkheightexpn;\n\t\t\t\n\t\t\t--l_level_no;\n\t\t\t\n\t\t\t/* border for each resolution level (global) */\n\t\t\tl_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n\t\t\tl_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n\t\t\tl_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n\t\t\tl_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\\n\", l_res->x0, l_res->y0, l_res->x1, l_res->y1);*/\n\t\t\t/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tpdx=%d, pdy=%d\\n\", l_pdx, l_pdy);*/\n\t\t\t/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */\n\t\t\tl_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \\n\", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/\n\t\t\t\n\t\t\tl_res->pw = (l_res->x0 == l_res->x1) ? 0 : (OPJ_UINT32)((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);\n\t\t\tl_res->ph = (l_res->y0 == l_res->y1) ? 0 : (OPJ_UINT32)((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tres_pw=%d, res_ph=%d\\n\", l_res->pw, l_res->ph );*/\n\t\t\t\n\t\t\tl_nb_precincts = l_res->pw * l_res->ph;\n\t\t\tl_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\t\t\tif (resno == 0) {\n\t\t\t\ttlcbgxstart = l_tl_prc_x_start;\n\t\t\t\ttlcbgystart = l_tl_prc_y_start;\n\t\t\t\t/*brcbgxend = l_br_prc_x_end;*/\n\t\t\t\t/* brcbgyend = l_br_prc_y_end;*/\n\t\t\t\tcbgwidthexpn = l_pdx;\n\t\t\t\tcbgheightexpn = l_pdy;\n\t\t\t\tl_res->numbands = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);\n\t\t\t\ttlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);\n\t\t\t\t/*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/\n\t\t\t\t/*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/\n\t\t\t\tcbgwidthexpn = l_pdx - 1;\n\t\t\t\tcbgheightexpn = l_pdy - 1;\n\t\t\t\tl_res->numbands = 3;\n\t\t\t}\n\t\t\t\n\t\t\tcblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);\n\t\t\tcblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);\n\t\t\tl_band = l_res->bands;\n\t\t\t\n\t\t\tfor (bandno = 0; bandno < l_res->numbands; ++bandno) {\n\t\t\t\tOPJ_INT32 numbps;\n\t\t\t\t/*fprintf(stderr, \"\\t\\t\\tband_no=%d/%d\\n\", bandno, l_res->numbands );*/\n\t\t\t\t\n\t\t\t\tif (resno == 0) {\n\t\t\t\t\tl_band->bandno = 0 ;\n\t\t\t\t\tl_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl_band->bandno = bandno + 1;\n\t\t\t\t\t/* x0b = 1 if bandno = 1 or 3 */\n\t\t\t\t\tl_x0b = l_band->bandno&1;\n\t\t\t\t\t/* y0b = 1 if bandno = 2 or 3 */\n\t\t\t\t\tl_y0b = (OPJ_INT32)((l_band->bandno)>>1);\n\t\t\t\t\t/* l_band border (global) */\n\t\t\t\t\tl_band->x0 = opj_int64_ceildivpow2(l_tilec->x0 - ((OPJ_INT64)l_x0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->y0 = opj_int64_ceildivpow2(l_tilec->y0 - ((OPJ_INT64)l_y0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->x1 = opj_int64_ceildivpow2(l_tilec->x1 - ((OPJ_INT64)l_x0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->y1 = opj_int64_ceildivpow2(l_tilec->y1 - ((OPJ_INT64)l_y0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/** avoid an if with storing function pointer */\n\t\t\t\tl_gain = (*l_gain_ptr) (l_band->bandno);\n\t\t\t\tnumbps = (OPJ_INT32)(l_image_comp->prec + l_gain);\n\t\t\t\tl_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0, (OPJ_INT32) (numbps - l_step_size->expn)))) * fraction;\n\t\t\t\tl_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits - 1;      /* WHY -1 ? */\n\t\t\t\t\n\t\t\t\tif (!l_band->precincts && (l_nb_precincts > 0U)) {\n\t\t\t\t\tl_band->precincts = (opj_tcd_precinct_t *) opj_malloc( /*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! l_band->precincts) {\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tAllocate precincts of a band (opj_tcd_precinct_t): %d\\n\",l_nb_precinct_size);     */\n\t\t\t\t\tmemset(l_band->precincts,0,l_nb_precinct_size);\n\t\t\t\t\tl_band->precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\telse if (l_band->precincts_data_size < l_nb_precinct_size) {\n\t\t\t\t\t\n\t\t\t\t\topj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(l_band->precincts,/*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! new_precincts) {\n\t\t\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory to handle band precints\\n\");\n\t\t\t\t\t\topj_free(l_band->precincts);\n\t\t\t\t\t\tl_band->precincts = NULL;\n\t\t\t\t\t\tl_band->precincts_data_size = 0;\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tl_band->precincts = new_precincts;\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\\n\",l_band->precincts_data_size, l_nb_precinct_size);*/\n\t\t\t\t\tmemset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size,0,l_nb_precinct_size - l_band->precincts_data_size);\n\t\t\t\t\tl_band->precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tl_current_precinct = l_band->precincts;\n\t\t\t\tfor (precno = 0; precno < l_nb_precincts; ++precno) {\n\t\t\t\t\tOPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;\n\t\t\t\t\tOPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) * (1 << cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) * (1 << cbgheightexpn);\n\t\t\t\t\tOPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);\n\t\t\t\t\t/*fprintf(stderr, \"\\t precno=%d; bandno=%d, resno=%d; compno=%d\\n\", precno, bandno , resno, compno);*/\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \\n\",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);*/\n\t\t\t\t\t\n\t\t\t\t\t/* precinct size (global) */\n\t\t\t\t\t/*fprintf(stderr, \"\\t cbgxstart=%d, l_band->x0 = %d \\n\",cbgxstart, l_band->x0);*/\n\t\t\t\t\t\n\t\t\t\t\tl_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);\n\t\t\t\t\tl_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);\n\t\t\t\t\tl_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);\n\t\t\t\t\tl_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);\n\t\t\t\t\t/*fprintf(stderr, \"\\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\\n\",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);*/\n\t\t\t\t\t\n\t\t\t\t\ttlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcblkxstart =%d\\n\",tlcblkxstart );*/\n\t\t\t\t\ttlcblkystart = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcblkystart =%d\\n\",tlcblkystart );*/\n\t\t\t\t\tbrcblkxend = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t brcblkxend =%d\\n\",brcblkxend );*/\n\t\t\t\t\tbrcblkyend = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t brcblkyend =%d\\n\",brcblkyend );*/\n\t\t\t\t\tl_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >> cblkwidthexpn);\n\t\t\t\t\tl_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >> cblkheightexpn);\n\t\t\t\t\t\n\t\t\t\t\tl_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\t precinct_cw = %d x recinct_ch = %d\\n\",l_current_precinct->cw, l_current_precinct->ch);      */\n\t\t\t\t\tl_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;\n\t\t\t\t\t\n\t\t\t\t\tif (!l_current_precinct->cblks.blocks && (l_nb_code_blocks > 0U)) {\n\t\t\t\t\t\tl_current_precinct->cblks.blocks = opj_malloc(l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! l_current_precinct->cblks.blocks ) {\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\\n\",l_nb_code_blocks_size);*/\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(l_current_precinct->cblks.blocks,0,l_nb_code_blocks_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct->block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\telse if (l_nb_code_blocks_size > l_current_precinct->block_size) {\n\t\t\t\t\t\tvoid *new_blocks = opj_realloc(l_current_precinct->cblks.blocks, l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! new_blocks) {\n\t\t\t\t\t\t\topj_free(l_current_precinct->cblks.blocks);\n\t\t\t\t\t\t\tl_current_precinct->cblks.blocks = NULL;\n\t\t\t\t\t\t\tl_current_precinct->block_size = 0;\n\t\t\t\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for current precinct codeblock element\\n\");\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tl_current_precinct->cblks.blocks = new_blocks;\n\t\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\\n\",l_current_precinct->block_size, l_nb_code_blocks_size);     */\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(((OPJ_BYTE *) l_current_precinct->cblks.blocks) + l_current_precinct->block_size\n\t\t\t\t\t\t\t\t\t ,0\n\t\t\t\t\t\t\t\t\t ,l_nb_code_blocks_size - l_current_precinct->block_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct->block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (! l_current_precinct->incltree) {\n\t\t\t\t\t\tl_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tl_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree, l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->incltree)     {\n\t\t\t\t\t\topj_event_msg(manager, EVT_WARNING, \"No incltree created.\\n\");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->imsbtree) {\n\t\t\t\t\t\tl_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tl_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree, l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->imsbtree) {\n\t\t\t\t\t\topj_event_msg(manager, EVT_WARNING, \"No imsbtree created.\\n\");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\t\t\t\t\t\tOPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isEncoder) {\n\t\t\t\t\t\t\topj_tcd_cblk_enc_t* l_code_block = l_current_precinct->cblks.enc + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n\t\t\t\t\t\t\tl_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n\t\t\t\t\t\t\tl_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n\t\t\t\t\t\t\tl_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topj_tcd_cblk_dec_t* l_code_block = l_current_precinct->cblks.dec + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_dec_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n\t\t\t\t\t\t\tl_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n\t\t\t\t\t\t\tl_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n\t\t\t\t\t\t\tl_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++l_current_precinct;\n\t\t\t\t} /* precno */\n\t\t\t\t++l_band;\n\t\t\t\t++l_step_size;\n\t\t\t} /* bandno */\n\t\t\t++l_res;\n\t\t} /* resno */\n\t\t++l_tccp;\n\t\t++l_tilec;\n\t\t++l_image_comp;\n\t} /* compno */\n\treturn OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init_encode_tile (opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, opj_event_mgr_t* p_manager)\n{\n\treturn opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_TRUE, 1.0F, sizeof(opj_tcd_cblk_enc_t), p_manager);\n}\n\nOPJ_BOOL opj_tcd_init_decode_tile (opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, opj_event_mgr_t* p_manager)\n{\n\treturn opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_FALSE, 0.5F, sizeof(opj_tcd_cblk_dec_t), p_manager);\n}\n\n/**\n * Allocates memory for an encoding code block (but not data memory).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate (opj_tcd_cblk_enc_t * p_code_block)\n{\n\tif (! p_code_block->layers) {\n\t\t/* no memset since data */\n\t\tp_code_block->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));\n\t\tif (! p_code_block->layers) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\tif (! p_code_block->passes) {\n\t\tp_code_block->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));\n\t\tif (! p_code_block->passes) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\treturn OPJ_TRUE;\n}\n\n/**\n * Allocates data memory for an encoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data (opj_tcd_cblk_enc_t * p_code_block)\n{\n\tOPJ_UINT32 l_data_size;\n\t\n\tl_data_size = (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) * (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\t\n\tif (l_data_size > p_code_block->data_size) {\n\t\tif (p_code_block->data) {\n\t\t\topj_free(p_code_block->data - 1); /* again, why -1 */\n\t\t}\n\t\tp_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size+1);\n\t\tif(! p_code_block->data) {\n\t\t\tp_code_block->data_size = 0U;\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tp_code_block->data_size = l_data_size;\n\t\t\n\t\tp_code_block->data[0] = 0;\n\t\tp_code_block->data+=1;   /*why +1 ?*/\n\t}\n\treturn OPJ_TRUE;\n}\n\n/**\n * Allocates memory for a decoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate (opj_tcd_cblk_dec_t * p_code_block)\n{\n        if (! p_code_block->data) {\n\n                p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_J2K_DEFAULT_CBLK_DATA_SIZE);\n                if (! p_code_block->data) {\n                        return OPJ_FALSE;\n                }\n                p_code_block->data_max_size = OPJ_J2K_DEFAULT_CBLK_DATA_SIZE;\n                /*fprintf(stderr, \"Allocate 8192 elements of code_block->data\\n\");*/\n\n                p_code_block->segs = (opj_tcd_seg_t *) opj_calloc(OPJ_J2K_DEFAULT_NB_SEGS,sizeof(opj_tcd_seg_t));\n                if (! p_code_block->segs) {\n                        return OPJ_FALSE;\n                }\n                /*fprintf(stderr, \"Allocate %d elements of code_block->data\\n\", OPJ_J2K_DEFAULT_NB_SEGS * sizeof(opj_tcd_seg_t));*/\n\n                p_code_block->m_current_max_segs = OPJ_J2K_DEFAULT_NB_SEGS;\n                /*fprintf(stderr, \"m_current_max_segs of code_block->data = %d\\n\", p_code_block->m_current_max_segs);*/\n        } else {\n\t\t\t\t\t/* sanitize */\n\t\t\t\t\tOPJ_BYTE* l_data = p_code_block->data;\n\t\t\t\t\tOPJ_UINT32 l_data_max_size = p_code_block->data_max_size;\n\t\t\t\t\topj_tcd_seg_t * l_segs = p_code_block->segs;\n\t\t\t\t\tOPJ_UINT32 l_current_max_segs = p_code_block->m_current_max_segs;\n\n\t\t\t\t\tmemset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t));\n\t\t\t\t\tp_code_block->data = l_data;\n\t\t\t\t\tp_code_block->data_max_size = l_data_max_size;\n\t\t\t\t\tp_code_block->segs = l_segs;\n\t\t\t\t\tp_code_block->m_current_max_segs = l_current_max_segs;\n\t\t\t\t}\n\n        return OPJ_TRUE;\n}\n\nOPJ_UINT32 opj_tcd_get_decoded_tile_size ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tcd_resolution_t * l_res = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n\n        l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n                if(l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                l_res = l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions - 1;\n                l_data_size += l_size_comp * (OPJ_UINT32)((l_res->x1 - l_res->x0) * (l_res->y1 - l_res->y0));\n                ++l_img_comp;\n                ++l_tile_comp;\n        }\n\n        return l_data_size;\n}\n\nOPJ_BOOL opj_tcd_encode_tile(   opj_tcd_t *p_tcd,\n                                                        OPJ_UINT32 p_tile_no,\n                                                        OPJ_BYTE *p_dest,\n                                                        OPJ_UINT32 * p_data_written,\n                                                        OPJ_UINT32 p_max_length,\n                                                        opj_codestream_info_t *p_cstr_info)\n{\n\n        if (p_tcd->cur_tp_num == 0) {\n\n                p_tcd->tcd_tileno = p_tile_no;\n                p_tcd->tcp = &p_tcd->cp->tcps[p_tile_no];\n\n                /* INDEX >> \"Precinct_nb_X et Precinct_nb_Y\" */\n                if(p_cstr_info)  {\n                        OPJ_UINT32 l_num_packs = 0;\n                        OPJ_UINT32 i;\n                        opj_tcd_tilecomp_t *l_tilec_idx = &p_tcd->tcd_image->tiles->comps[0];        /* based on component 0 */\n                        opj_tccp_t *l_tccp = p_tcd->tcp->tccps; /* based on component 0 */\n\n                        for (i = 0; i < l_tilec_idx->numresolutions; i++) {\n                                opj_tcd_resolution_t *l_res_idx = &l_tilec_idx->resolutions[i];\n\n                                p_cstr_info->tile[p_tile_no].pw[i] = (int)l_res_idx->pw;\n                                p_cstr_info->tile[p_tile_no].ph[i] = (int)l_res_idx->ph;\n\n                                l_num_packs += l_res_idx->pw * l_res_idx->ph;\n                                p_cstr_info->tile[p_tile_no].pdx[i] = (int)l_tccp->prcw[i];\n                                p_cstr_info->tile[p_tile_no].pdy[i] = (int)l_tccp->prch[i];\n                        }\n                        p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t*) opj_calloc((size_t)p_cstr_info->numcomps * (size_t)p_cstr_info->numlayers * l_num_packs, sizeof(opj_packet_info_t));\n                        if (!p_cstr_info->tile[p_tile_no].packet) {\n                                /* FIXME event manager error callback */\n                                return OPJ_FALSE;\n                        }\n                }\n                /* << INDEX */\n\n                /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n                /*---------------TILE-------------------*/\n                if (! opj_tcd_dc_level_shift_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n                /* FIXME _ProfStart(PGROUP_MCT); */\n                if (! opj_tcd_mct_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_MCT); */\n\n                /* FIXME _ProfStart(PGROUP_DWT); */\n                if (! opj_tcd_dwt_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME  _ProfStop(PGROUP_DWT); */\n\n                /* FIXME  _ProfStart(PGROUP_T1); */\n                if (! opj_tcd_t1_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_T1); */\n\n                /* FIXME _ProfStart(PGROUP_RATE); */\n                if (! opj_tcd_rate_allocate_encode(p_tcd,p_dest,p_max_length,p_cstr_info)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_RATE); */\n\n        }\n        /*--------------TIER2------------------*/\n\n        /* INDEX */\n        if (p_cstr_info) {\n                p_cstr_info->index_write = 1;\n        }\n        /* FIXME _ProfStart(PGROUP_T2); */\n\n        if (! opj_tcd_t2_encode(p_tcd,p_dest,p_data_written,p_max_length,p_cstr_info)) {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T2); */\n\n        /*---------------CLEAN-------------------*/\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_decode_tile(   opj_tcd_t *p_tcd,\n                                OPJ_BYTE *p_src,\n                                OPJ_UINT32 p_max_length,\n                                OPJ_UINT32 p_tile_no,\n                                opj_codestream_index_t *p_cstr_index,\n                                opj_event_mgr_t *p_manager\n                                )\n{\n        OPJ_UINT32 l_data_read;\n        p_tcd->tcd_tileno = p_tile_no;\n        p_tcd->tcp = &(p_tcd->cp->tcps[p_tile_no]);\n\n#ifdef TODO_MSD /* FIXME */\n        /* INDEX >>  */\n        if(p_cstr_info) {\n                OPJ_UINT32 resno, compno, numprec = 0;\n                for (compno = 0; compno < (OPJ_UINT32) p_cstr_info->numcomps; compno++) {\n                        opj_tcp_t *tcp = &p_tcd->cp->tcps[0];\n                        opj_tccp_t *tccp = &tcp->tccps[compno];\n                        opj_tcd_tilecomp_t *tilec_idx = &p_tcd->tcd_image->tiles->comps[compno];\n                        for (resno = 0; resno < tilec_idx->numresolutions; resno++) {\n                                opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[resno];\n                                p_cstr_info->tile[p_tile_no].pw[resno] = res_idx->pw;\n                                p_cstr_info->tile[p_tile_no].ph[resno] = res_idx->ph;\n                                numprec += res_idx->pw * res_idx->ph;\n                                p_cstr_info->tile[p_tile_no].pdx[resno] = tccp->prcw[resno];\n                                p_cstr_info->tile[p_tile_no].pdy[resno] = tccp->prch[resno];\n                        }\n                }\n                p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t *) opj_malloc(p_cstr_info->numlayers * numprec * sizeof(opj_packet_info_t));\n                p_cstr_info->packno = 0;\n        }\n        /* << INDEX */\n#endif\n\n        /*--------------TIER2------------------*/\n        /* FIXME _ProfStart(PGROUP_T2); */\n        l_data_read = 0;\n        if (! opj_tcd_t2_decode(p_tcd, p_src, &l_data_read, p_max_length, p_cstr_index, p_manager))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T2); */\n\n        /*------------------TIER1-----------------*/\n\n        /* FIXME _ProfStart(PGROUP_T1); */\n        if\n                (! opj_tcd_t1_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T1); */\n\n        /*----------------DWT---------------------*/\n\n        /* FIXME _ProfStart(PGROUP_DWT); */\n        if\n                (! opj_tcd_dwt_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_DWT); */\n\n        /*----------------MCT-------------------*/\n        /* FIXME _ProfStart(PGROUP_MCT); */\n        if\n                (! opj_tcd_mct_decode(p_tcd, p_manager))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_MCT); */\n\n        /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n        if\n                (! opj_tcd_dc_level_shift_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n\n        /*---------------TILE-------------------*/\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_update_tile_data ( opj_tcd_t *p_tcd,\n                                    OPJ_BYTE * p_dest,\n                                    OPJ_UINT32 p_dest_length\n                                    )\n{\n        OPJ_UINT32 i,j,k,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        opj_tcd_resolution_t * l_res;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_UINT32 l_stride, l_width,l_height;\n\n        l_data_size = opj_tcd_get_decoded_tile_size(p_tcd);\n        if (l_data_size > p_dest_length) {\n                return OPJ_FALSE;\n        }\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n                l_res = l_tilec->resolutions + l_img_comp->resno_decoded;\n                l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n                l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n                l_stride = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0) - l_width;\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                switch (l_size_comp)\n                        {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_dest_ptr = (OPJ_CHAR *) p_dest;\n                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_CHAR) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for     (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_CHAR) ((*(l_src_ptr++))&0xff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_dest = (OPJ_BYTE *)l_dest_ptr;\n                                }\n                                break;\n                        case 2:\n                                {\n                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;\n                                        OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_dest;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) ((*(l_src_ptr++))&0xffff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_dest = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_dest;\n                                        OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n                                        for (j=0;j<l_height;++j) {\n                                                for (k=0;k<l_width;++k) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++));\n                                                }\n                                                l_src_ptr += l_stride;\n                                        }\n\n                                        p_dest = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                }\n\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return OPJ_TRUE;\n}\n\n\n\n\nstatic void opj_tcd_free_tile(opj_tcd_t *p_tcd)\n{\n        OPJ_UINT32 compno, resno, bandno, precno;\n        opj_tcd_tile_t *l_tile = 00;\n        opj_tcd_tilecomp_t *l_tile_comp = 00;\n        opj_tcd_resolution_t *l_res = 00;\n        opj_tcd_band_t *l_band = 00;\n        opj_tcd_precinct_t *l_precinct = 00;\n        OPJ_UINT32 l_nb_resolutions, l_nb_precincts;\n        void (* l_tcd_code_block_deallocate) (opj_tcd_precinct_t *) = 00;\n\n        if (! p_tcd) {\n                return;\n        }\n\n        if (! p_tcd->tcd_image) {\n                return;\n        }\n\n        if (p_tcd->m_is_decoder) {\n                l_tcd_code_block_deallocate = opj_tcd_code_block_dec_deallocate;\n        }\n        else {\n                l_tcd_code_block_deallocate = opj_tcd_code_block_enc_deallocate;\n        }\n\n        l_tile = p_tcd->tcd_image->tiles;\n        if (! l_tile) {\n                return;\n        }\n\n        l_tile_comp = l_tile->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                l_res = l_tile_comp->resolutions;\n                if (l_res) {\n\n                        l_nb_resolutions = l_tile_comp->resolutions_size / sizeof(opj_tcd_resolution_t);\n                        for (resno = 0; resno < l_nb_resolutions; ++resno) {\n                                l_band = l_res->bands;\n                                for     (bandno = 0; bandno < 3; ++bandno) {\n                                        l_precinct = l_band->precincts;\n                                        if (l_precinct) {\n\n                                                l_nb_precincts = l_band->precincts_data_size / sizeof(opj_tcd_precinct_t);\n                                                for (precno = 0; precno < l_nb_precincts; ++precno) {\n                                                        opj_tgt_destroy(l_precinct->incltree);\n                                                        l_precinct->incltree = 00;\n                                                        opj_tgt_destroy(l_precinct->imsbtree);\n                                                        l_precinct->imsbtree = 00;\n                                                        (*l_tcd_code_block_deallocate) (l_precinct);\n                                                        ++l_precinct;\n                                                }\n\n                                                opj_free(l_band->precincts);\n                                                l_band->precincts = 00;\n                                        }\n                                        ++l_band;\n                                } /* for (resno */\n                                ++l_res;\n                        }\n\n                        opj_free(l_tile_comp->resolutions);\n                        l_tile_comp->resolutions = 00;\n                }\n\n                if (l_tile_comp->ownsData && l_tile_comp->data) {\n                        opj_aligned_free(l_tile_comp->data);\n                        l_tile_comp->data = 00;\n                        l_tile_comp->ownsData = 0;\n                        l_tile_comp->data_size = 0;\n                        l_tile_comp->data_size_needed = 0;\n                }\n                ++l_tile_comp;\n        }\n\n        opj_free(l_tile->comps);\n        l_tile->comps = 00;\n        opj_free(p_tcd->tcd_image->tiles);\n        p_tcd->tcd_image->tiles = 00;\n}\n\n\nstatic OPJ_BOOL opj_tcd_t2_decode (opj_tcd_t *p_tcd,\n                            OPJ_BYTE * p_src_data,\n                            OPJ_UINT32 * p_data_read,\n                            OPJ_UINT32 p_max_src_size,\n                            opj_codestream_index_t *p_cstr_index,\n                            opj_event_mgr_t *p_manager\n                            )\n{\n        opj_t2_t * l_t2;\n\n        l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n        if (l_t2 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_t2_decode_packets(\n                                        l_t2,\n                                        p_tcd->tcd_tileno,\n                                        p_tcd->tcd_image->tiles,\n                                        p_src_data,\n                                        p_data_read,\n                                        p_max_src_size,\n                                        p_cstr_index,\n                                        p_manager)) {\n                opj_t2_destroy(l_t2);\n                return OPJ_FALSE;\n        }\n\n        opj_t2_destroy(l_t2);\n\n        /*---------------CLEAN-------------------*/\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t1_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_t1_t * l_t1;\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t* l_tile_comp = l_tile->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n\n\n        l_t1 = opj_t1_create(OPJ_FALSE);\n        if (l_t1 == 00) {\n                return OPJ_FALSE;\n        }\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                /* The +3 is headroom required by the vectorized DWT */\n                if (OPJ_FALSE == opj_t1_decode_cblks(l_t1, l_tile_comp, l_tccp)) {\n                        opj_t1_destroy(l_t1);\n                        return OPJ_FALSE;\n                }\n                ++l_tile_comp;\n                ++l_tccp;\n        }\n\n        opj_t1_destroy(l_t1);\n\n        return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_tcd_dwt_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n        opj_image_comp_t * l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                /*\n                if (tcd->cp->reduce != 0) {\n                        tcd->image->comps[compno].resno_decoded =\n                                tile->comps[compno].numresolutions - tcd->cp->reduce - 1;\n                        if (tcd->image->comps[compno].resno_decoded < 0)\n                        {\n                                return false;\n                        }\n                }\n                numres2decode = tcd->image->comps[compno].resno_decoded + 1;\n                if(numres2decode > 0){\n                */\n\n                if (l_tccp->qmfbid == 1) {\n                        if (! opj_dwt_decode(l_tile_comp, l_img_comp->resno_decoded+1)) {\n                                return OPJ_FALSE;\n                        }\n                }\n                else {\n                        if (! opj_dwt_decode_real(l_tile_comp, l_img_comp->resno_decoded+1)) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                ++l_tile_comp;\n                ++l_img_comp;\n                ++l_tccp;\n        }\n\n        return OPJ_TRUE;\n}\nstatic OPJ_BOOL opj_tcd_mct_decode ( opj_tcd_t *p_tcd, opj_event_mgr_t *p_manager)\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n        opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n        OPJ_UINT32 l_samples,i;\n\n        if (! l_tcp->mct) {\n                return OPJ_TRUE;\n        }\n\n        l_samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n\n        if (l_tile->numcomps >= 3 ){\n                /* testcase 1336.pdf.asan.47.376 */\n                if ((l_tile->comps[0].x1 - l_tile->comps[0].x0) * (l_tile->comps[0].y1 - l_tile->comps[0].y0) < (OPJ_INT32)l_samples ||\n                    (l_tile->comps[1].x1 - l_tile->comps[1].x0) * (l_tile->comps[1].y1 - l_tile->comps[1].y0) < (OPJ_INT32)l_samples ||\n                    (l_tile->comps[2].x1 - l_tile->comps[2].x0) * (l_tile->comps[2].y1 - l_tile->comps[2].y0) < (OPJ_INT32)l_samples) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Tiles don't all have the same dimension. Skip the MCT step.\\n\");\n                        return OPJ_FALSE;\n                }\n                else if (l_tcp->mct == 2) {\n                        OPJ_BYTE ** l_data;\n\n                        if (! l_tcp->m_mct_decoding_matrix) {\n                                return OPJ_TRUE;\n                        }\n\n                        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps*sizeof(OPJ_BYTE*));\n                        if (! l_data) {\n                                return OPJ_FALSE;\n                        }\n\n                        for (i=0;i<l_tile->numcomps;++i) {\n                                l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n                                ++l_tile_comp;\n                        }\n\n                        if (! opj_mct_decode_custom(/* MCT data */\n                                                                        (OPJ_BYTE*) l_tcp->m_mct_decoding_matrix,\n                                                                        /* size of components */\n                                                                        l_samples,\n                                                                        /* components */\n                                                                        l_data,\n                                                                        /* nb of components (i.e. size of pData) */\n                                                                        l_tile->numcomps,\n                                                                        /* tells if the data is signed */\n                                                                        p_tcd->image->comps->sgnd)) {\n                                opj_free(l_data);\n                                return OPJ_FALSE;\n                        }\n\n                        opj_free(l_data);\n                }\n                else {\n                        if (l_tcp->tccps->qmfbid == 1) {\n                                opj_mct_decode(     l_tile->comps[0].data,\n                                                        l_tile->comps[1].data,\n                                                        l_tile->comps[2].data,\n                                                        l_samples);\n                        }\n                        else {\n                            opj_mct_decode_real((OPJ_FLOAT32*)l_tile->comps[0].data,\n                                                (OPJ_FLOAT32*)l_tile->comps[1].data,\n                                                (OPJ_FLOAT32*)l_tile->comps[2].data,\n                                                l_samples);\n                        }\n                }\n        }\n        else {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\\n\",l_tile->numcomps);\n        }\n\n        return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tccp_t * l_tccp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_resolution_t* l_res = 00;\n        opj_tcd_tile_t * l_tile;\n        OPJ_UINT32 l_width,l_height,i,j;\n        OPJ_INT32 * l_current_ptr;\n        OPJ_INT32 l_min, l_max;\n        OPJ_UINT32 l_stride;\n\n        l_tile = p_tcd->tcd_image->tiles;\n        l_tile_comp = l_tile->comps;\n        l_tccp = p_tcd->tcp->tccps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;\n                l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n                l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n                l_stride = (OPJ_UINT32)(l_tile_comp->x1 - l_tile_comp->x0) - l_width;\n\n                assert(l_height == 0 || l_width + l_stride <= l_tile_comp->data_size / l_height); /*MUPDF*/\n\n                if (l_img_comp->sgnd) {\n                        l_min = -(1 << (l_img_comp->prec - 1));\n                        l_max = (1 << (l_img_comp->prec - 1)) - 1;\n                }\n                else {\n            l_min = 0;\n                        l_max = (1 << l_img_comp->prec) - 1;\n                }\n\n                l_current_ptr = l_tile_comp->data;\n\n                if (l_tccp->qmfbid == 1) {\n                        for (j=0;j<l_height;++j) {\n                                for (i = 0; i < l_width; ++i) {\n                                        *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift, l_min, l_max);\n                                        ++l_current_ptr;\n                                }\n                                l_current_ptr += l_stride;\n                        }\n                }\n                else {\n                        for (j=0;j<l_height;++j) {\n                                for (i = 0; i < l_width; ++i) {\n                                        OPJ_FLOAT32 l_value = *((OPJ_FLOAT32 *) l_current_ptr);\n                                        *l_current_ptr = opj_int_clamp((OPJ_INT32)opj_lrintf(l_value) + l_tccp->m_dc_level_shift, l_min, l_max); ;\n                                        ++l_current_ptr;\n                                }\n                                l_current_ptr += l_stride;\n                        }\n                }\n\n                ++l_img_comp;\n                ++l_tccp;\n                ++l_tile_comp;\n        }\n\n        return OPJ_TRUE;\n}\n\n\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_dec_deallocate (opj_tcd_precinct_t * p_precinct)\n{\n        OPJ_UINT32 cblkno , l_nb_code_blocks;\n\n        opj_tcd_cblk_dec_t * l_code_block = p_precinct->cblks.dec;\n        if (l_code_block) {\n                /*fprintf(stderr,\"deallocate codeblock:{\\n\");*/\n                /*fprintf(stderr,\"\\t x0=%d, y0=%d, x1=%d, y1=%d\\n\",l_code_block->x0, l_code_block->y0, l_code_block->x1, l_code_block->y1);*/\n                /*fprintf(stderr,\"\\t numbps=%d, numlenbits=%d, len=%d, numnewpasses=%d, real_num_segs=%d, m_current_max_segs=%d\\n \",\n                                l_code_block->numbps, l_code_block->numlenbits, l_code_block->len, l_code_block->numnewpasses, l_code_block->real_num_segs, l_code_block->m_current_max_segs );*/\n\n\n                l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t);\n                /*fprintf(stderr,\"nb_code_blocks =%d\\t}\\n\", l_nb_code_blocks);*/\n\n                for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\n                        if (l_code_block->data) {\n                                opj_free(l_code_block->data);\n                                l_code_block->data = 00;\n                        }\n\n                        if (l_code_block->segs) {\n                                opj_free(l_code_block->segs );\n                                l_code_block->segs = 00;\n                        }\n\n                        ++l_code_block;\n                }\n\n                opj_free(p_precinct->cblks.dec);\n                p_precinct->cblks.dec = 00;\n        }\n}\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_enc_deallocate (opj_tcd_precinct_t * p_precinct)\n{       \n        OPJ_UINT32 cblkno , l_nb_code_blocks;\n\n        opj_tcd_cblk_enc_t * l_code_block = p_precinct->cblks.enc;\n        if (l_code_block) {\n                l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_enc_t);\n                \n                for     (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno)  {\n                        if (l_code_block->data) {\n                                opj_free(l_code_block->data - 1);\n                                l_code_block->data = 00;\n                        }\n\n                        if (l_code_block->layers) {\n                                opj_free(l_code_block->layers );\n                                l_code_block->layers = 00;\n                        }\n\n                        if (l_code_block->passes) {\n                                opj_free(l_code_block->passes );\n                                l_code_block->passes = 00;\n                        }\n                        ++l_code_block;\n                }\n\n                opj_free(p_precinct->cblks.enc);\n                \n                p_precinct->cblks.enc = 00;\n        }\n}\n\nOPJ_UINT32 opj_tcd_get_encoded_tile_size ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 i,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                l_data_size += l_size_comp * (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return l_data_size;\n}\n                \nstatic OPJ_BOOL opj_tcd_dc_level_shift_encode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tccp_t * l_tccp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tile_t * l_tile;\n        OPJ_UINT32 l_nb_elem,i;\n        OPJ_INT32 * l_current_ptr;\n\n        l_tile = p_tcd->tcd_image->tiles;\n        l_tile_comp = l_tile->comps;\n        l_tccp = p_tcd->tcp->tccps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                l_current_ptr = l_tile_comp->data;\n                l_nb_elem = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n\n                if (l_tccp->qmfbid == 1) {\n                        for     (i = 0; i < l_nb_elem; ++i) {\n                                *l_current_ptr -= l_tccp->m_dc_level_shift ;\n                                ++l_current_ptr;\n                        }\n                }\n                else {\n                        for (i = 0; i < l_nb_elem; ++i) {\n                                *l_current_ptr = (*l_current_ptr - l_tccp->m_dc_level_shift) * (1 << 11);\n                                ++l_current_ptr;\n                        }\n                }\n\n                ++l_img_comp;\n                ++l_tccp;\n                ++l_tile_comp;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_mct_encode ( opj_tcd_t *p_tcd )\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        OPJ_UINT32 samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n        OPJ_UINT32 i;\n        OPJ_BYTE ** l_data = 00;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n\n        if(!p_tcd->tcp->mct) {\n                return OPJ_TRUE;\n        }\n\n        if (p_tcd->tcp->mct == 2) {\n                if (! p_tcd->tcp->m_mct_coding_matrix) {\n                        return OPJ_TRUE;\n                }\n\n        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps*sizeof(OPJ_BYTE*));\n                if (! l_data) {\n                        return OPJ_FALSE;\n                }\n\n                for (i=0;i<l_tile->numcomps;++i) {\n                        l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n                        ++l_tile_comp;\n                }\n\n                if (! opj_mct_encode_custom(/* MCT data */\n                                        (OPJ_BYTE*) p_tcd->tcp->m_mct_coding_matrix,\n                                        /* size of components */\n                                        samples,\n                                        /* components */\n                                        l_data,\n                                        /* nb of components (i.e. size of pData) */\n                                        l_tile->numcomps,\n                                        /* tells if the data is signed */\n                                        p_tcd->image->comps->sgnd) )\n                {\n            opj_free(l_data);\n                        return OPJ_FALSE;\n                }\n\n                opj_free(l_data);\n        }\n        else if (l_tcp->tccps->qmfbid == 0) {\n                opj_mct_encode_real(l_tile->comps[0].data, l_tile->comps[1].data, l_tile->comps[2].data, samples);\n        }\n        else {\n                opj_mct_encode(l_tile->comps[0].data, l_tile->comps[1].data, l_tile->comps[2].data, samples);\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_dwt_encode ( opj_tcd_t *p_tcd )\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n        OPJ_UINT32 compno;\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                if (l_tccp->qmfbid == 1) {\n                        if (! opj_dwt_encode(l_tile_comp)) {\n                                return OPJ_FALSE;\n                        }\n                }\n                else if (l_tccp->qmfbid == 0) {\n                        if (! opj_dwt_encode_real(l_tile_comp)) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                ++l_tile_comp;\n                ++l_tccp;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t1_encode ( opj_tcd_t *p_tcd )\n{\n        opj_t1_t * l_t1;\n        const OPJ_FLOAT64 * l_mct_norms;\n        OPJ_UINT32 l_mct_numcomps = 0U;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n\n        l_t1 = opj_t1_create(OPJ_TRUE);\n        if (l_t1 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (l_tcp->mct == 1) {\n                l_mct_numcomps = 3U;\n                /* irreversible encoding */\n                if (l_tcp->tccps->qmfbid == 0) {\n                        l_mct_norms = opj_mct_get_mct_norms_real();\n                }\n                else {\n                        l_mct_norms = opj_mct_get_mct_norms();\n                }\n        }\n        else {\n                l_mct_numcomps = p_tcd->image->numcomps;\n                l_mct_norms = (const OPJ_FLOAT64 *) (l_tcp->mct_norms);\n        }\n\n        if (! opj_t1_encode_cblks(l_t1, p_tcd->tcd_image->tiles , l_tcp, l_mct_norms, l_mct_numcomps)) {\n        opj_t1_destroy(l_t1);\n                return OPJ_FALSE;\n        }\n\n        opj_t1_destroy(l_t1);\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t2_encode (opj_tcd_t *p_tcd,\n                                                OPJ_BYTE * p_dest_data,\n                                                OPJ_UINT32 * p_data_written,\n                                                OPJ_UINT32 p_max_dest_size,\n                                                opj_codestream_info_t *p_cstr_info )\n{\n        opj_t2_t * l_t2;\n\n        l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n        if (l_t2 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_t2_encode_packets(\n                                        l_t2,\n                                        p_tcd->tcd_tileno,\n                                        p_tcd->tcd_image->tiles,\n                                        p_tcd->tcp->numlayers,\n                                        p_dest_data,\n                                        p_data_written,\n                                        p_max_dest_size,\n                                        p_cstr_info,\n                                        p_tcd->tp_num,\n                                        p_tcd->tp_pos,\n                                        p_tcd->cur_pino,\n                                        FINAL_PASS))\n        {\n                opj_t2_destroy(l_t2);\n                return OPJ_FALSE;\n        }\n\n        opj_t2_destroy(l_t2);\n\n        /*---------------CLEAN-------------------*/\n        return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_tcd_rate_allocate_encode(  opj_tcd_t *p_tcd,\n                                                                            OPJ_BYTE * p_dest_data,\n                                                                            OPJ_UINT32 p_max_dest_size,\n                                                                            opj_codestream_info_t *p_cstr_info )\n{\n        opj_cp_t * l_cp = p_tcd->cp;\n        OPJ_UINT32 l_nb_written = 0;\n\n        if (p_cstr_info)  {\n                p_cstr_info->index_write = 0;\n        }\n\n        if (l_cp->m_specific_param.m_enc.m_disto_alloc|| l_cp->m_specific_param.m_enc.m_fixed_quality)  {\n                /* fixed_quality */\n                /* Normal Rate/distortion allocation */\n                if (! opj_tcd_rateallocate(p_tcd, p_dest_data,&l_nb_written, p_max_dest_size, p_cstr_info)) {\n                        return OPJ_FALSE;\n                }\n        }\n        else {\n                /* Fixed layer allocation */\n                opj_tcd_rateallocate_fixed(p_tcd);\n        }\n\n        return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_copy_tile_data (       opj_tcd_t *p_tcd,\n                                                                    OPJ_BYTE * p_src,\n                                                                    OPJ_UINT32 p_src_length )\n{\n        OPJ_UINT32 i,j,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_UINT32 l_nb_elem;\n\n        l_data_size = opj_tcd_get_encoded_tile_size(p_tcd);\n        if (l_data_size != p_src_length) {\n                return OPJ_FALSE;\n        }\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n                l_nb_elem = (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                switch (l_size_comp) {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_src_ptr = (OPJ_CHAR *) p_src;\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++))&0xff;\n                                                }\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                        case 2:\n                                {\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n                                        OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_src;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++))&0xffff;\n                                                }\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_src;\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n                                        for (j=0;j<l_nb_elem;++j) {\n                                                *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                }\n\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return OPJ_TRUE;\n}\n", "# This file list all the input commands of the tests run by the ctest command which \n# are not related to the conformance files.\n#\n# For each line of this file (except line which begin with #) an opj_compress test or a\n# opj_decompress is run and its related tests.\n#   + For encoder related tests = dump, compare dump to base, decode the encoded file with \n#     reference and compare the decoded file with the baseline decoded previously with \n#     ref decoder.\n#   + For decoder related tests = dump, compare dump to base, (TODO: compare outpout decoding \n#     image to base)\n#\n# Line begin with ! should failed (should be used for bad jpeg2000 file which should be \n# gracefully rejected). Please add a short resume about why this file should be rejected.\n#\n# You can use @INPUT_NR_PATH@ and @TEMP_PATH@ cmake variable which refers to OPJ_DATA_ROOT \n# repository. However you can use relative path or absolute path.\n\n# ENCODER TEST SUITE\nopj_compress -i @INPUT_NR_PATH@/Bretagne1.ppm -o @TEMP_PATH@/Bretagne1_0.j2k -r 200,50,10\nopj_compress -i @INPUT_NR_PATH@/Bretagne1.ppm -o @TEMP_PATH@/Bretagne1_1.j2k -q 30,35,40 -n 2\nopj_compress -i @INPUT_NR_PATH@/Bretagne1.ppm -o @TEMP_PATH@/Bretagne1_2.j2k -q 30,35,40 -b 16,16 -c [64,64]\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_0.j2k -c [128,128],[128,128],[128,128] -r 100,20,2 -t 640,480 -b 32,32\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_1.j2k -t 127,127 -p PCRL\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_2.j2k -s 2,2 -SOP\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_3.j2k -EPH -M 38\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_4.j2k -d 150,300 -r 800\nopj_compress -i @INPUT_NR_PATH@/Cevennes1.bmp -o @TEMP_PATH@/Cevennes1.j2k -r 10\nopj_compress -i @INPUT_NR_PATH@/Cevennes2.ppm -o @TEMP_PATH@/Cevennes2.jp2 -r 50\nopj_compress -i @INPUT_NR_PATH@/Rome.bmp -o @TEMP_PATH@/Rome.jp2 -q 30,35,50 -p LRCP -n 3\n# related to issue 5\nopj_compress -i @INPUT_NR_PATH@/random-issue-0005.tif -o @TEMP_PATH@/random-issue-0005.tif.j2k\n# related to issue 62\nopj_compress -i @INPUT_NR_PATH@/tmp-issue-0062.raw -o @TEMP_PATH@/tmp-issue-0062-u.raw.j2k -F 512,512,1,16,u\nopj_compress -i @INPUT_NR_PATH@/tmp-issue-0062.raw -o @TEMP_PATH@/tmp-issue-0062-s.raw.j2k -F 512,512,1,16,s\nopj_compress -i @INPUT_NR_PATH@/X_4_2K_24_185_CBR_WB_000.tif -o @TEMP_PATH@/X_4_2K_24_185_CBR_WB_000_C2K_24.j2k -cinema2K 24\nopj_compress -i @INPUT_NR_PATH@/X_5_2K_24_235_CBR_STEM24_000.tif -o @TEMP_PATH@/X_5_2K_24_235_CBR_STEM24_000_C2K_24.j2k -cinema2K 24\nopj_compress -i @INPUT_NR_PATH@/X_6_2K_24_FULL_CBR_CIRCLE_000.tif -o @TEMP_PATH@/X_6_2K_24_FULL_CBR_CIRCLE_000_C2K_24.j2k -cinema2K 24\nopj_compress -i @INPUT_NR_PATH@/X_4_2K_24_185_CBR_WB_000.tif -o @TEMP_PATH@/X_4_2K_24_185_CBR_WB_000_C2K_48.j2k -cinema2K 48\nopj_compress -i @INPUT_NR_PATH@/X_5_2K_24_235_CBR_STEM24_000.tif -o @TEMP_PATH@/X_5_2K_24_235_CBR_STEM24_000_C2K_48.j2k -cinema2K 48\nopj_compress -i @INPUT_NR_PATH@/X_6_2K_24_FULL_CBR_CIRCLE_000.tif -o @TEMP_PATH@/X_6_2K_24_FULL_CBR_CIRCLE_000_C2K_48.j2k -cinema2K 48\nopj_compress -i @INPUT_NR_PATH@/ElephantDream_4K.tif -o @TEMP_PATH@/ElephantDream_4K_C4K.j2k -cinema4K\n# issue 141\nopj_compress -i @INPUT_NR_PATH@/issue141.rawl -o @TEMP_PATH@/issue141.rawl.j2k   -F 2048,32,1,16,u\nopj_compress -i @INPUT_NR_PATH@/issue141.rawl -o @TEMP_PATH@/issue141-I.rawl.j2k -F 2048,32,1,16,u -I\n# issue 46:\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_5.j2k -c [64,64]\n# issue 316\nopj_compress -i @INPUT_NR_PATH@/issue316.png -o @TEMP_PATH@/issue316.png.jp2\n# issue 416 (cdef for png with alpha) + issue 436 (MCT norm read buffer overflow for num comp > 3 + Issue 215 number of decomp levels\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn6a08.png -o @TEMP_PATH@/basn6a08.png.jp2 -n 6\n# issue 203 BMP Files not handled properly\nopj_compress -i @INPUT_NR_PATH@/issue203-8bpp-width1.bmp -o @TEMP_PATH@/issue203-8bpp-width1.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-rle8.bmp -o @TEMP_PATH@/issue203-rle8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-y8.bmp -o @TEMP_PATH@/issue203-32x32-y8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-33x33-y8.bmp -o @TEMP_PATH@/issue203-33x33-y8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-34x34-y8.bmp -o @TEMP_PATH@/issue203-34x34-y8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-35x35-y8.bmp -o @TEMP_PATH@/issue203-35x35-y8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgr.bmp -o @TEMP_PATH@/issue203-32x32-bgr.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-33x33-bgr.bmp -o @TEMP_PATH@/issue203-33x33-bgr.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-34x34-bgr.bmp -o @TEMP_PATH@/issue203-34x34-bgr.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-35x35-bgr.bmp -o @TEMP_PATH@/issue203-35x35-bgr.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-y-rle8.bmp -o @TEMP_PATH@/issue203-32x32-y-rle8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgr-rle8.bmp -o @TEMP_PATH@/issue203-32x32-bgr-rle8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-y-rle4.bmp -o @TEMP_PATH@/issue203-32x32-y-rle4.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgr-rle4.bmp -o @TEMP_PATH@/issue203-32x32-bgr-rle4.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgra.bmp -o @TEMP_PATH@/issue203-32x32-bgra.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgrx.bmp -o @TEMP_PATH@/issue203-32x32-bgrx.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgr16.bmp -o @TEMP_PATH@/issue203-32x32-bgr16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-33x33-bgr16.bmp -o @TEMP_PATH@/issue203-33x33-bgr16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgra16.bmp -o @TEMP_PATH@/issue203-32x32-bgra16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-33x33-bgra16.bmp -o @TEMP_PATH@/issue203-33x33-bgra16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgrx16.bmp -o @TEMP_PATH@/issue203-32x32-bgrx16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-33x33-bgrx16.bmp -o @TEMP_PATH@/issue203-33x33-bgrx16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-127x64-bgr16.bmp -o @TEMP_PATH@/issue203-127x64-bgr16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-127x64-bgrx.bmp -o @TEMP_PATH@/issue203-127x64-bgrx.bmp.jp2\n\n# issue 322 limited tif support \nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-01.tif -o @TEMP_PATH@/flower-minisblack-01.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-02.tif -o @TEMP_PATH@/flower-minisblack-02.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-04.tif -o @TEMP_PATH@/flower-minisblack-04.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-06.tif -o @TEMP_PATH@/flower-minisblack-06.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-08.tif -o @TEMP_PATH@/flower-minisblack-08.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-10.tif -o @TEMP_PATH@/flower-minisblack-10.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-12.tif -o @TEMP_PATH@/flower-minisblack-12.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-14.tif -o @TEMP_PATH@/flower-minisblack-14.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-16.tif -o @TEMP_PATH@/flower-minisblack-16.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-02.tif -o @TEMP_PATH@/flower-rgb-contig-02.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-04.tif -o @TEMP_PATH@/flower-rgb-contig-04.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-08.tif -o @TEMP_PATH@/flower-rgb-contig-08.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-10.tif -o @TEMP_PATH@/flower-rgb-contig-10.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-12.tif -o @TEMP_PATH@/flower-rgb-contig-12.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-14.tif -o @TEMP_PATH@/flower-rgb-contig-14.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-16.tif -o @TEMP_PATH@/flower-rgb-contig-16.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-02.tif -o @TEMP_PATH@/flower-rgb-planar-02.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-04.tif -o @TEMP_PATH@/flower-rgb-planar-04.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-08.tif -o @TEMP_PATH@/flower-rgb-planar-08.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-10.tif -o @TEMP_PATH@/flower-rgb-planar-10.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-12.tif -o @TEMP_PATH@/flower-rgb-planar-12.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-14.tif -o @TEMP_PATH@/flower-rgb-planar-14.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-16.tif -o @TEMP_PATH@/flower-rgb-planar-16.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/basn6a08.tif -o @TEMP_PATH@/basn6a08.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/basn4a08.tif -o @TEMP_PATH@/basn4a08.tif.jp2\n\n# issue 536 (PNG images are always read as RGB(A) images) + issue 264 (convert.c is unmaintainable)\n# Test all images from pngsuite\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn0g01.png -o @TEMP_PATH@/basn0g01.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn0g02.png -o @TEMP_PATH@/basn0g02.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn0g04.png -o @TEMP_PATH@/basn0g04.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn0g08.png -o @TEMP_PATH@/basn0g08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn0g16.png -o @TEMP_PATH@/basn0g16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn2c08.png -o @TEMP_PATH@/basn2c08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn2c16.png -o @TEMP_PATH@/basn2c16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn3p01.png -o @TEMP_PATH@/basn3p01.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn3p02.png -o @TEMP_PATH@/basn3p02.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn3p04.png -o @TEMP_PATH@/basn3p04.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn3p08.png -o @TEMP_PATH@/basn3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn4a08.png -o @TEMP_PATH@/basn4a08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn4a16.png -o @TEMP_PATH@/basn4a16.png.jp2\n# already done opj_compress -i @INPUT_NR_PATH@/pngsuite/basn6a08.png -o @TEMP_PATH@/basn6a08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn6a16.png -o @TEMP_PATH@/basn6a16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbbn0g01.png -o @TEMP_PATH@/ftbbn0g01.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbbn0g02.png -o @TEMP_PATH@/ftbbn0g02.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbbn0g04.png -o @TEMP_PATH@/ftbbn0g04.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbbn2c16.png -o @TEMP_PATH@/ftbbn2c16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbbn3p08.png -o @TEMP_PATH@/ftbbn3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbgn2c16.png -o @TEMP_PATH@/ftbgn2c16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbgn3p08.png -o @TEMP_PATH@/ftbgn3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbrn2c08.png -o @TEMP_PATH@/ftbrn2c08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbwn0g16.png -o @TEMP_PATH@/ftbwn0g16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbwn3p08.png -o @TEMP_PATH@/ftbwn3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbyn3p08.png -o @TEMP_PATH@/ftbyn3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftp0n0g08.png -o @TEMP_PATH@/ftp0n0g08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftp0n2c08.png -o @TEMP_PATH@/ftp0n2c08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftp0n3p08.png -o @TEMP_PATH@/ftp0n3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftp1n3p08.png -o @TEMP_PATH@/ftp1n3p08.png.jp2\n\n# issue 571 Lossless is not lossless on linux x86\nopj_compress -i @INPUT_NR_PATH@/issue571.tif -o @TEMP_PATH@/issue571.tif.j2k\n\n# issue 729 Allow to read 3/5/7/9/11/13/15 bpp tif files \nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-03.tif -o @TEMP_PATH@/flower-minisblack-03.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-05.tif -o @TEMP_PATH@/flower-minisblack-05.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-07.tif -o @TEMP_PATH@/flower-minisblack-07.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-09.tif -o @TEMP_PATH@/flower-minisblack-09.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-11.tif -o @TEMP_PATH@/flower-minisblack-11.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-13.tif -o @TEMP_PATH@/flower-minisblack-13.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-15.tif -o @TEMP_PATH@/flower-minisblack-15.tif.jp2\n\n\n# DECODER TEST SUITE\nopj_decompress -i  @INPUT_NR_PATH@/Bretagne2.j2k -o @TEMP_PATH@/Bretagne2.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/_00042.j2k -o @TEMP_PATH@/_00042.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/123.j2c -o @TEMP_PATH@/123.j2c.pgx\n# The 4 following tests should failed (kakadu indicates that they are corrupted)\n!opj_decompress -i  @INPUT_NR_PATH@/broken1.jp2 -o @TEMP_PATH@/broken1.jp2.pgx\n!opj_decompress -i  @INPUT_NR_PATH@/broken2.jp2 -o @TEMP_PATH@/broken2.jp2.pgx\n!opj_decompress -i  @INPUT_NR_PATH@/broken3.jp2 -o @TEMP_PATH@/broken3.jp2.pgx\n!opj_decompress -i  @INPUT_NR_PATH@/broken4.jp2 -o @TEMP_PATH@/broken4.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/bug.j2c -o @TEMP_PATH@/bug.j2c.pgx\nopj_decompress -i  @INPUT_NR_PATH@/buxI.j2k -o @TEMP_PATH@/buxI.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/buxR.j2k -o @TEMP_PATH@/buxR.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/Cannotreaddatawithnosizeknown.j2k -o @TEMP_PATH@/Cannotreaddatawithnosizeknown.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/cthead1.j2k -o @TEMP_PATH@/cthead1.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/CT_Phillips_JPEG2K_Decompr_Problem.j2k -o @TEMP_PATH@/CT_Phillips_JPEG2K_Decompr_Problem.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/illegalcolortransform.j2k -o @TEMP_PATH@/illegalcolortransform.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/j2k32.j2k -o @TEMP_PATH@/j2k32.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/kakadu_v4-4_openjpegv2_broken.j2k -o @TEMP_PATH@/kakadu_v4-4_openjpegv2_broken.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/MarkerIsNotCompliant.j2k -o @TEMP_PATH@/MarkerIsNotCompliant.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/Marrin.jp2 -o @TEMP_PATH@/Marrin.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/merged.jp2 -o @TEMP_PATH@/merged.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/movie_00000.j2k -o @TEMP_PATH@/movie_00000.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/movie_00001.j2k -o @TEMP_PATH@/movie_00001.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/movie_00002.j2k -o @TEMP_PATH@/movie_00002.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/orb-blue10-lin-j2k.j2k -o @TEMP_PATH@/orb-blue10-lin-j2k.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/orb-blue10-lin-jp2.jp2 -o @TEMP_PATH@/orb-blue10-lin-jp2.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/orb-blue10-win-j2k.j2k -o @TEMP_PATH@/orb-blue10-win-j2k.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/orb-blue10-win-jp2.jp2 -o @TEMP_PATH@/orb-blue10-win-jp2.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/relax.jp2 -o @TEMP_PATH@/relax.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/test_lossless.j2k -o @TEMP_PATH@/test_lossless.j2k.pgx\n# text_GBR.jp2 file exhibt a error about a tile part with a index > of the number of tile-part in this tile (related to issue 202, 206, 208)\nopj_decompress -i  @INPUT_NR_PATH@/text_GBR.jp2 -o @TEMP_PATH@/text_GBR.jp2.pgx\n# pacs.ge file should throw an error but finally it seems work with v2\nopj_decompress -i  @INPUT_NR_PATH@/pacs.ge.j2k -o @TEMP_PATH@/pacs.ge.j2k.pgx\n# related to issue 135 \nopj_decompress -i  @INPUT_NR_PATH@/kodak_2layers_lrcp.j2c -o @TEMP_PATH@/kodak_2layers_lrcp.j2c.pgx\nopj_decompress -i  @INPUT_NR_PATH@/kodak_2layers_lrcp.j2c -o @TEMP_PATH@/kodak_2layers_lrcp-l2.j2c.pgx -l 2\n# related to issue 104 and 110\nopj_decompress -i  @INPUT_NR_PATH@/issue104_jpxstream.jp2 -o @TEMP_PATH@/issue104_jpxstream.jp2.pgx\n# File not supported by kakadu (Malformed PCLR box) and not supoprter by openjpeg (problem with value of TPSot)\n!opj_decompress -i  @INPUT_NR_PATH@/mem-b2ace68c-1381.jp2 -o @TEMP_PATH@/mem-b2ace68c-1381.jp2.pgx\n# File which produced weird output with kakadu and not supoprter by openjpeg (problem with value of TPSot, issue 202, 206, 208)\nopj_decompress -i  @INPUT_NR_PATH@/mem-b2b86b74-2753.jp2 -o @TEMP_PATH@/mem-b2b86b74-2753.jp2.pgx\n# issue 191 raised by the gdal fuzzer test (should properly failed)\n!opj_decompress -i  @INPUT_NR_PATH@/gdal_fuzzer_unchecked_numresolutions.jp2 -o @TEMP_PATH@/gdal_fuzzer_unchecked_numresolutions.pgx\n# issue 192 raised by the gdal fuzzer test (should nicely failed)\n! opj_decompress -i  @INPUT_NR_PATH@/gdal_fuzzer_assert_in_opj_j2k_read_SQcd_SQcc.patch.jp2 -o @TEMP_PATH@/gdal_fuzzer_assert_in_opj_j2k_read_SQcd_SQcc.patch.pgx\n# issue 193 raised by the gdal fuzzer test (should nicely failed)\n!opj_decompress -i  @INPUT_NR_PATH@/gdal_fuzzer_check_number_of_tiles.jp2 -o @TEMP_PATH@/gdal_fuzzer_check_number_of_tiles.pgx\n# issue 194 raised by the gdal fuzzer test (should nicely failed)\n! opj_decompress -i  @INPUT_NR_PATH@/gdal_fuzzer_check_comp_dx_dy.jp2 -o @TEMP_PATH@/gdal_fuzzer_check_comp_dx_dy.pgx\n# issue 202 \nopj_decompress -i  @INPUT_NR_PATH@/file409752.jp2 -o @TEMP_PATH@/file409752.jp2.pgx\n# issue 188 \nopj_decompress -i  @INPUT_NR_PATH@/issue188_beach_64bitsbox.jp2 -o @TEMP_PATH@/issue188_beach_64bitsbox.jp2.pgx\n# issue 206\nopj_decompress -i  @INPUT_NR_PATH@/issue206_image-000.jp2 -o @TEMP_PATH@/issue206_image-000.jp2.pgx\n# issue 205\nopj_decompress -i  @INPUT_NR_PATH@/issue205.jp2 -o @TEMP_PATH@/issue205.jp2.pgx\n# issue 225 (sumatrapdf)\n!opj_decompress -i @INPUT_NR_PATH@/451.pdf.SIGSEGV.5b5.3723.jp2  -o @TEMP_PATH@/451.pdf.SIGSEGV.5b5.3723.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/1888.pdf.asan.35.988.jp2      -o @TEMP_PATH@/1888.pdf.asan.35.988.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/2539.pdf.SIGFPE.706.1712.jp2  -o @TEMP_PATH@/2539.pdf.SIGFPE.706.1712.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/2236.pdf.SIGSEGV.398.1376.jp2 -o @TEMP_PATH@/2236.pdf.SIGSEGV.398.1376.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/1336.pdf.asan.47.376.jp2      -o @TEMP_PATH@/1336.pdf.asan.47.376.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/1851.pdf.SIGSEGV.ce9.948.jp2  -o @TEMP_PATH@/1851.pdf.SIGSEGV.ce9.948.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/4149.pdf.SIGSEGV.cf7.3501.jp2 -o @TEMP_PATH@/4149.pdf.SIGSEGV.cf7.3501.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/4035.pdf.SIGSEGV.d8b.3375.jp2 -o @TEMP_PATH@/4035.pdf.SIGSEGV.d8b.3375.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/2977.pdf.asan.67.2198.jp2     -o @TEMP_PATH@/2977.pdf.asan.67.2198.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/451.pdf.SIGSEGV.ce9.3723.jp2  -o @TEMP_PATH@/451.pdf.SIGSEGV.ce9.3723.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/3635.pdf.asan.77.2930.jp2     -o @TEMP_PATH@/3635.pdf.asan.77.2930.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/1802.pdf.SIGSEGV.36e.894.jp2  -o @TEMP_PATH@/1802.pdf.SIGSEGV.36e.894.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/451.pdf.SIGSEGV.f4c.3723.jp2  -o @TEMP_PATH@/451.pdf.SIGSEGV.f4c.3723.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/2.pdf.SIGFPE.706.1112.jp2     -o @TEMP_PATH@/2.pdf.SIGFPE.706.1112.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/147af3f1083de4393666b7d99b01b58b_signal_sigsegv_130c531_6155_5136.jp2 -o @TEMP_PATH@/147af3f1083de4393666b7d99b01b58b_signal_sigsegv_130c531_6155_5136.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/4241ac039aba57e6a9c948d519d94216_asan_heap-oob_14650f2_7469_602.jp2 -o @TEMP_PATH@/4241ac039aba57e6a9c948d519d94216_asan_heap-oob_14650f2_7469_602.jp2\n# issue 228 (16bits/lossy)\nopj_decompress -i @INPUT_NR_PATH@/issue228.j2k                  -o @TEMP_PATH@/issue228.j2k.pgx\n# issue 229\n!opj_decompress -i @INPUT_NR_PATH@/27ac957758a35d00d6765a0c86350d9c.SIGFPE.d25.537.jpc -o @TEMP_PATH@27ac957758a35d00d6765a0c86350d9c.SIGFPE.d25.537.jpc.pgx\n!opj_decompress -i @INPUT_NR_PATH@/26ccf3651020967f7778238ef5af08af.SIGFPE.d25.527.jp2 -o @TEMP_PATH@26ccf3651020967f7778238ef5af08af.SIGFPE.d25.527.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/0290cb77c5df21828fa74cf2ab2c84d8.SIGFPE.d25.31.jp2  -o @TEMP_PATH@0290cb77c5df21828fa74cf2ab2c84d8.SIGFPE.d25.31.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/3672da2f1f67bbecad27d7181b4e9d7c.SIGFPE.d25.805.jpc -o @TEMP_PATH@3672da2f1f67bbecad27d7181b4e9d7c.SIGFPE.d25.805.jpc.pgx\n# issue 254 (loss in quality)\nopj_decompress -i @INPUT_NR_PATH@/issue254.jp2                  -o @TEMP_PATH@/issue254.jp2.pgx\n# issue 142\nopj_decompress -i @INPUT_NR_PATH@/issue142.j2k                  -o @TEMP_PATH@/issue142.j2k.pgx\n# issue 134\nopj_decompress -i @INPUT_NR_PATH@/issue134.jp2                  -o @TEMP_PATH@/issue134.jp2.pgx\n# issue 135\nopj_decompress -i @INPUT_NR_PATH@/issue135.j2k                  -o @TEMP_PATH@/issue135.j2k.pgx\n# issue 208\nopj_decompress -i @INPUT_NR_PATH@/issue208.jp2                  -o @TEMP_PATH@/issue208.jp2.pgx\n# issue 211\nopj_decompress -i @INPUT_NR_PATH@/issue211.jp2                  -o @TEMP_PATH@/issue211.jp2.pgx\n# issue 171\nopj_decompress -i @INPUT_NR_PATH@/issue171.jp2                  -o @TEMP_PATH@/issue171.jp2.pgx\n# issue 171\n!opj_decompress -i @INPUT_NR_PATH@/issue165.jp2                  -o @TEMP_PATH@/issue165.jp2.pgx\n#\n!opj_decompress -i @INPUT_NR_PATH@/broken.jpc                    -o @TEMP_PATH@/broken.jpc.pgx\n# issue 226\nopj_decompress -i @INPUT_NR_PATH@/issue226.j2k                   -o @TEMP_PATH@/issue226.j2k.pgx\n# issue 297\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1103421.jp2  -o @TEMP_PATH@/edf_c2_1103421.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1178956.jp2  -o @TEMP_PATH@/edf_c2_1178956.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1000290.jp2  -o @TEMP_PATH@/edf_c2_1000290.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1000691.jp2  -o @TEMP_PATH@/edf_c2_1000691.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_20.jp2       -o @TEMP_PATH@/edf_c2_20.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1377017.jp2  -o @TEMP_PATH@/edf_c2_1377017.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1002767.jp2  -o @TEMP_PATH@/edf_c2_1002767.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_10025.jp2    -o @TEMP_PATH@/edf_c2_10025.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1000234.jp2  -o @TEMP_PATH@/edf_c2_1000234.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_225881.jp2   -o @TEMP_PATH@/edf_c2_225881.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1000671.jp2  -o @TEMP_PATH@/edf_c2_1000671.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1013627.jp2  -o @TEMP_PATH@/edf_c2_1013627.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1015644.jp2  -o @TEMP_PATH@/edf_c2_1015644.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_101463.jp2   -o @TEMP_PATH@/edf_c2_101463.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1674177.jp2  -o @TEMP_PATH@/edf_c2_1674177.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1673169.jp2  -o @TEMP_PATH@/edf_c2_1673169.jp2.pgx\n# issue 296\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.78.2734.0.jp2 -o @TEMP_PATH@/3459.pdf.asan.78.2734.0.jp2.pgx\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.78.2734.1.jp2 -o @TEMP_PATH@/3459.pdf.asan.78.2734.1.jp2.pgx\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.78.2734.2.jp2 -o @TEMP_PATH@/3459.pdf.asan.78.2734.2.jp2.pgx\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.6c.2734.0.jp2 -o @TEMP_PATH@/3459.pdf.asan.6c.2734.0.jp2.pgx\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.6c.2734.1.jp2 -o @TEMP_PATH@/3459.pdf.asan.6c.2734.1.jp2.pgx\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.6c.2734.2.jp2 -o @TEMP_PATH@/3459.pdf.asan.6c.2734.2.jp2.pgx\n# issue 362 (from pdfium fuzz engine)\n# Invalid PPM Marker\n!opj_decompress -i @INPUT_NR_PATH@/issue362-2863.jp2 -o @TEMP_PATH@/issue362-2863.jp2.pgx\n# Invalid ftyp box size\n!opj_decompress -i @INPUT_NR_PATH@/issue362-2866.jp2 -o @TEMP_PATH@/issue362-2866.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/issue362-2894.jp2 -o @TEMP_PATH@/issue362-2894.jp2.pgx\n# issue 363  (from pdfium fuzz engine)\n# Invalid Tile part length\n!opj_decompress -i @INPUT_NR_PATH@/issue363-4723.jp2 -o @TEMP_PATH@/issue363-4723.jp2.pgx\n# Invalid Marker length\n!opj_decompress -i @INPUT_NR_PATH@/issue363-4740.jp2 -o @TEMP_PATH@/issue363-4740.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/issue363-4792.jp2 -o @TEMP_PATH@/issue363-4792.jp2.pgx\n# issue 390  (from pdfium fuzz engine) Invalid segment size\n!opj_decompress -i @INPUT_NR_PATH@/issue390.jp2 -o @TEMP_PATH@/issue390.jp2.pgx\n# issue 391  (from pdfium fuzz engine) Invalid segment size\n!opj_decompress -i @INPUT_NR_PATH@/issue391.jp2 -o @TEMP_PATH@/issue391.jp2.pgx\n# issue 400  (from pdfium fuzz engine) Unknown Scod value in COD marker\n!opj_decompress -i @INPUT_NR_PATH@/issue400.jp2 -o @TEMP_PATH@/issue400.jp2.pgx\n# issue 413  (from pdfium fuzz engine) Unknown progression order in COD marker\n!opj_decompress -i @INPUT_NR_PATH@/issue413.jp2 -o @TEMP_PATH@/issue413.jp2.pgx\n# issue 364 (from pdfium fuzz engine)\n# Inconsistent box length for jp2 box\n!opj_decompress -i @INPUT_NR_PATH@/issue364-38.jp2 -o @TEMP_PATH@/issue364-38.jp2.pgx\n# No ihdr box\n!opj_decompress -i @INPUT_NR_PATH@/issue364-903.jp2 -o @TEMP_PATH@/issue364-903.jp2.pgx\n# issue 393  (from pdfium fuzz engine) Zppm found twice\n!opj_decompress -i @INPUT_NR_PATH@/issue393.jp2 -o @TEMP_PATH@/issue393.jp2.pgx\n# issue 395  (from pdfium fuzz engine) Stream too short\n!opj_decompress -i @INPUT_NR_PATH@/issue395.jp2 -o @TEMP_PATH@/issue395.jp2.pgx\n# issue 397  (from pdfium fuzz engine) Incomplete channel definitions.\n!opj_decompress -i @INPUT_NR_PATH@/issue397.jp2 -o @TEMP_PATH@/issue397.jp2.pgx\n# issue 399  (from pdfium fuzz engine) Incomplete channel definitions.\nopj_decompress -i @INPUT_NR_PATH@/issue399.j2k -o @TEMP_PATH@/issue399.j2k.pgx\n# issue 408  (from pdfium fuzz engine) No COD marker in main j2k header.\n!opj_decompress -i @INPUT_NR_PATH@/issue408.jp2 -o @TEMP_PATH@/issue408.jp2.pgx\n# issue 412 Palette image with cdef fails to decompress.\nopj_decompress -i @INPUT_NR_PATH@/issue412.jp2 -o @TEMP_PATH@/issue412.jp2.pgx\n# issue 428 Palette image with cdef fails to decompress properly.\nopj_decompress -i @INPUT_NR_PATH@/issue412.jp2 -o @TEMP_PATH@/issue428.jp2.pgx -t 0\n# issue 414 Image with per channel alpha (cdef) does not decode properly.\nopj_decompress -i @INPUT_NR_PATH@/issue414.jp2 -o @TEMP_PATH@/issue414.jp2.pgx\n# issue 418 (from pdfium fuzz engine) Tile part length size inconsistent with stream length.\n!opj_decompress -i @INPUT_NR_PATH@/issue418.jp2 -o @TEMP_PATH@/issue418.jp2.pgx\n# issue 420 (from pdfium fuzz engine) Illegal custom precinct exponent.\n!opj_decompress -i @INPUT_NR_PATH@/issue420.jp2 -o @TEMP_PATH@/issue420.jp2.pgx\n# issue 422 (rework of issue 411). ycc with odd width/height\nopj_decompress -i @INPUT_NR_PATH@/issue411-ycc444.jp2 -o @TEMP_PATH@/issue411-ycc444.jp2.pgx\nopj_decompress -i @INPUT_NR_PATH@/issue411-ycc422.jp2 -o @TEMP_PATH@/issue411-ycc422.jp2.pgx\nopj_decompress -i @INPUT_NR_PATH@/issue411-ycc420.jp2 -o @TEMP_PATH@/issue411-ycc420.jp2.pgx\n# issue 429 (from pdfium fuzz engine) 0 entries in PCLR box.\n!opj_decompress -i @INPUT_NR_PATH@/issue429.jp2 -o @TEMP_PATH@/issue429.jp2.pgx\n# issue 432 (from pdfium fuzz engine) Overflow in tcd tilec data size computation.\n!opj_decompress -i @INPUT_NR_PATH@/issue432.jp2 -o @TEMP_PATH@/issue432.jp2.pgx\n# issue 427 image width is 0\n!opj_decompress -i @INPUT_NR_PATH@/issue427-null-image-size.jp2 -o @TEMP_PATH@/issue427-null-image-size.jp2.pgx\n# issue 427 illegal tile offset\n!opj_decompress -i @INPUT_NR_PATH@/issue427-illegal-tile-offset.jp2 -o @TEMP_PATH@/issue427-illegal-tile-offset.jp2.pgx\n# issue 458 component precision upscaling\nopj_decompress -i @INPUT_NR_PATH@/issue458.jp2 -o @TEMP_PATH@/issue458.jp2.pgx\n# issue 476 Multiple COD in MH\n!opj_decompress -i @INPUT_NR_PATH@/issue476.jp2 -o @TEMP_PATH@/issue476.jp2.pgx\n# issue 475 Invalid number of layers\n!opj_decompress -i @INPUT_NR_PATH@/issue475.jp2 -o @TEMP_PATH@/issue475.jp2.pgx\n# issue 495 Overflow op_image_comp_header_updat\nopj_decompress -i @INPUT_NR_PATH@/issue495.jp2 -o @TEMP_PATH@/issue495.jp2.pgx\n\n\n# decode with specific area\n# prec=12; nb_c=1 \nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04.j2k.png -d 0,0,1024,1024\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_1.j2k.png -d 512,640,640,768\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_2.j2k.png -d 896,896,1024,1024\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_3.j2k.png -d 100,500,300,800\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_4.j2k.png -d 260,520,360,600\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_5.j2k.png -d 260,520,360,660\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_6.j2k.png -d 360,520,400,600\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_10.j2k.png -d 0,0,1024,1024 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_11.j2k.png -d 512,640,640,768 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_12.j2k.png -d 896,896,1024,1024 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_13.j2k.png -d 100,500,300,800 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_14.j2k.png -d 260,520,360,600 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_15.j2k.png -d 260,520,360,660 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_16.j2k.png -d 360,520,400,600 -r 2\n\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_17_t63.j2k.png -t 63 \nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_17_t63_r2.j2k.png -t 63 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_18.t12.j2k.png -t 12 \nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_19_t12_r1.j2k.png -t 12 -r 1\n\n# prec=8; nb_c=3 \nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06.j2k.png -d 0,0,12,12\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_1.j2k.png -d 1,8,8,11\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_2.j2k.png -d 9,9,12,12\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_3.j2k.png -d 10,4,12,10\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_4.j2k.png -d 3,3,9,9\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_5.j2k.png -d 4,4,7,7\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_6.j2k.png -d 4,4,5,5\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7.j2k.png -d 0,0,12,12 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_1.j2k.png -d 1,8,8,11 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_2.j2k.png -d 9,9,12,12 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_3.j2k.png -d 10,4,12,10 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_4.j2k.png -d 3,3,9,9 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_5.j2k.png -d 4,4,7,7 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_6.j2k.png -d 4,4,5,5 -r 1\n\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_8_6.j2k.png -d 9,9,12,12 -r 2\n\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_9.j2k.png -t 0\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_9_1.j2k.png -t 5\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_9_2.j2k.png -t 9\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_9_3.j2k.png -t 15\n\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_10.j2k.png -t 0 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_10_1.j2k.png -t 5 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_10_2.j2k.png -t 9 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_10_3.j2k.png -t 15 -r 2\n\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_11.j2k.png -r 4\n\n# prec=4; nb_c=3 ; signd=yes\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04.j2k.png -d 0,0,256,256\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_1.j2k.png -d 128,0,256,128\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_2.j2k.png -d 50,10,120,200\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_3.j2k.png -d 10,150,190,210\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_4.j2k.png -d 100,80,200,150\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_5.j2k.png -d 150,20,200,50\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6.j2k.png -d 0,0,256,256 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6_1.j2k.png -d 128,0,256,128 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6_2.j2k.png -d 50,10,120,200 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6_3.j2k.png -d 10,150,190,210  -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6_4.j2k.png -d 100,80,200,150 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6_5.j2k.png -d 150,20,200,50 -r 2\n\n# prec=8; nb_c=1 ; non standard origin (image offset and tile offset); sample sep: 2x1\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01.j2k.png -d 5,128,127,226\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01_1.j2k.png -d 5,128,122,99\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01_2.j2k.png -d 50,10,120,200\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01_3.j2k.png -d 10,150,190,210\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01_4.j2k.png -d 100,80,200,150\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01_5.j2k.png -d 150,20,200,50\n\n# issue 322 limited tif support\n# GRAYSCALE \nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-1.tif -p 1S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-2.tif -p 2S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-4.tif -p 4S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-6.tif -p 6S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-8.tif -p 8S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-10.tif -p 10S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-12.tif -p 12S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-14.tif -p 14S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-16.tif -p 16S\n# GRAYSCALE ALPHA\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-1.tif -p 1S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-2.tif -p 2S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-4.tif -p 4S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-6.tif -p 6S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-8.tif -p 8S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-10.tif -p 10S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-12.tif -p 12S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-14.tif -p 14S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-16.tif -p 16S\n# RGB\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-1.tif -p 1S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-2.tif -p 2S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-4.tif -p 4S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-6.tif -p 6S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-8.tif -p 8S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-10.tif -p 10S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-12.tif -p 12S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-14.tif -p 14S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-16.tif -p 16S\n# RGBA\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-1.tif -p 1S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-2.tif -p 2S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-4.tif -p 4S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-6.tif -p 6S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-8.tif -p 8S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-10.tif -p 10S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-12.tif -p 12S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-14.tif -p 14S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-16.tif -p 16S\n\n#issue 235 CMAP outside jp2h box. CMAP is buggy\nopj_decompress -i @INPUT_NR_PATH@/issue235.jp2 -o @TEMP_PATH@/issue235.jp2.pgx\n\n# issue 264, add checks for png\n# GRAYSCALE \nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-1.png -p 1S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-2.png -p 2S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-4.png -p 4S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-6.png -p 6S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-8.png -p 8S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-10.png -p 10S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-12.png -p 12S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-14.png -p 14S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-16.png -p 16S\n# GRAYSCALE ALPHA\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-1.png -p 1S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-2.png -p 2S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-4.png -p 4S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-6.png -p 6S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-8.png -p 8S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-10.png -p 10S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-12.png -p 12S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-14.png -p 14S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-16.png -p 16S\n# RGB\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-1.png -p 1S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-2.png -p 2S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-4.png -p 4S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-6.png -p 6S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-8.png -p 8S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-10.png -p 10S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-12.png -p 12S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-14.png -p 14S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-16.png -p 16S\n# RGBA\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-1.png -p 1S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-2.png -p 2S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-4.png -p 4S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-6.png -p 6S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-8.png -p 8S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-10.png -p 10S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-12.png -p 12S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-14.png -p 14S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-16.png -p 16S\n\n# issue 388\n!opj_decompress -i @INPUT_NR_PATH@/v4dwt_interleave_h.gsr105.j2k -o @TEMP_PATH@/v4dwt_interleave_h.gsr105.j2k.pgx\nopj_decompress -i @INPUT_NR_PATH@/dwt_interleave_h.gsr105.jp2 -o @TEMP_PATH@/dwt_interleave_h.gsr105.jp2.pgx\n\n# PR 559 : CMYK tif output\nopj_decompress -i @INPUT_NR_PATH@/issue205.jp2 -o @TEMP_PATH@/issue205-tif.jp2.tif\n\n# issue 236: esYCC colorspace\nopj_decompress -i @INPUT_NR_PATH@/issue236-ESYCC-CDEF.jp2 -o @TEMP_PATH@/issue236-ESYCC-CDEF.jp2.pgx\n\n# issue 326 + PR 559: CIELab colorspace\nopj_decompress -i @INPUT_NR_PATH@/issue559-eci-090-CIELab.jp2 -o @TEMP_PATH@/issue559-eci-090-CIELab.jp2.pgx\nopj_decompress -i @INPUT_NR_PATH@/issue559-eci-091-CIELab.jp2 -o @TEMP_PATH@/issue559-eci-091-CIELab.jp2.pgx\n\n# issue 653 Last box of undefined size byg\nopj_decompress -i @INPUT_NR_PATH@/issue653-zero-unknownbox.jp2 -o @TEMP_PATH@/issue653-zero-unknownbox.jp2.png -p 8S\n\n# issue 729 decompress 3/5/7/9/11/13/15 bits precision to tiff\n# GRAYSCALE \nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-3.tif -p 3S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-5.tif -p 5S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-7.tif -p 7S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-9.tif -p 9S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-11.tif -p 11S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-13.tif -p 13S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-15.tif -p 15S\n# GRAYSCALE ALPHA\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-3.tif -p 3S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-5.tif -p 5S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-7.tif -p 7S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-9.tif -p 9S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-11.tif -p 11S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-13.tif -p 13S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-15.tif -p 15S\n# RGB\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-3.tif -p 3S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-5.tif -p 5S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-7.tif -p 7S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-9.tif -p 9S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-11.tif -p 11S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-13.tif -p 13S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-15.tif -p 15S\n# RGBA\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-3.tif -p 3S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-5.tif -p 5S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-7.tif -p 7S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-9.tif -p 9S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-11.tif -p 11S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-13.tif -p 13S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-15.tif -p 15S\n\n# issue 725\n!opj_decompress -i @INPUT_NR_PATH@/issue725.jp2 -o @TEMP_PATH@/issue725.png\n# issue 726\nopj_decompress -i @INPUT_NR_PATH@/issue726.j2k -o @TEMP_PATH@/issue726.png\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR \n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/* ----------------------------------------------------------------------- */\n\n/* TODO MSD: */\n#ifdef TODO_MSD \nvoid tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t * img) {\n        int tileno, compno, resno, bandno, precno;/*, cblkno;*/\n\n        fprintf(fd, \"image {\\n\");\n        fprintf(fd, \"  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\\n\", \n                img->tw, img->th, tcd->image->x0, tcd->image->x1, tcd->image->y0, tcd->image->y1);\n\n        for (tileno = 0; tileno < img->th * img->tw; tileno++) {\n                opj_tcd_tile_t *tile = &tcd->tcd_image->tiles[tileno];\n                fprintf(fd, \"  tile {\\n\");\n                fprintf(fd, \"    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\\n\",\n                        tile->x0, tile->y0, tile->x1, tile->y1, tile->numcomps);\n                for (compno = 0; compno < tile->numcomps; compno++) {\n                        opj_tcd_tilecomp_t *tilec = &tile->comps[compno];\n                        fprintf(fd, \"    tilec {\\n\");\n                        fprintf(fd,\n                                \"      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\\n\",\n                                tilec->x0, tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);\n                        for (resno = 0; resno < tilec->numresolutions; resno++) {\n                                opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n                                fprintf(fd, \"\\n   res {\\n\");\n                                fprintf(fd,\n                                        \"          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\\n\",\n                                        res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);\n                                for (bandno = 0; bandno < res->numbands; bandno++) {\n                                        opj_tcd_band_t *band = &res->bands[bandno];\n                                        fprintf(fd, \"        band {\\n\");\n                                        fprintf(fd,\n                                                \"          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\\n\",\n                                                band->x0, band->y0, band->x1, band->y1, band->stepsize, band->numbps);\n                                        for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                                opj_tcd_precinct_t *prec = &band->precincts[precno];\n                                                fprintf(fd, \"          prec {\\n\");\n                                                fprintf(fd,\n                                                        \"            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\\n\",\n                                                        prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);\n                                                /*\n                                                for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {\n                                                        opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];\n                                                        fprintf(fd, \"            cblk {\\n\");\n                                                        fprintf(fd,\n                                                                \"              x0=%d, y0=%d, x1=%d, y1=%d\\n\",\n                                                                cblk->x0, cblk->y0, cblk->x1, cblk->y1);\n                                                        fprintf(fd, \"            }\\n\");\n                                                }\n                                                */\n                                                fprintf(fd, \"          }\\n\");\n                                        }\n                                        fprintf(fd, \"        }\\n\");\n                                }\n                                fprintf(fd, \"      }\\n\");\n                        }\n                        fprintf(fd, \"    }\\n\");\n                }\n                fprintf(fd, \"  }\\n\");\n        }\n        fprintf(fd, \"}\\n\");\n}\n#endif\n\n/**\n * Initializes tile coding/decoding\n */\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block, opj_event_mgr_t* manager);\n\n/**\n* Allocates memory for a decoding code block.\n*/\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate (opj_tcd_cblk_dec_t * p_code_block);\n\n/**\n * Deallocates the decoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_dec_deallocate (opj_tcd_precinct_t * p_precinct);\n\n/**\n * Allocates memory for an encoding code block (but not data).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate (opj_tcd_cblk_enc_t * p_code_block);\n\n/**\n * Allocates data for an encoding code block\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data (opj_tcd_cblk_enc_t * p_code_block);\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_enc_deallocate (opj_tcd_precinct_t * p_precinct);\n\n\n/**\nFree the memory allocated for encoding\n@param tcd TCD handle\n*/\nstatic void opj_tcd_free_tile(opj_tcd_t *tcd);\n\n\nstatic OPJ_BOOL opj_tcd_t2_decode ( opj_tcd_t *p_tcd,\n                                    OPJ_BYTE * p_src_data,\n                                    OPJ_UINT32 * p_data_read,\n                                    OPJ_UINT32 p_max_src_size,\n                                    opj_codestream_index_t *p_cstr_index,\n                                    opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_tcd_t1_decode (opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_dwt_decode (opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_mct_decode (opj_tcd_t *p_tcd, opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_decode (opj_tcd_t *p_tcd);\n\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_mct_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_dwt_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_t1_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_t2_encode (     opj_tcd_t *p_tcd,\n                                                                    OPJ_BYTE * p_dest_data,\n                                                                    OPJ_UINT32 * p_data_written,\n                                                                    OPJ_UINT32 p_max_dest_size,\n                                                                    opj_codestream_info_t *p_cstr_info );\n\nstatic OPJ_BOOL opj_tcd_rate_allocate_encode(   opj_tcd_t *p_tcd,\n                                                                                        OPJ_BYTE * p_dest_data,\n                                                                                        OPJ_UINT32 p_max_dest_size,\n                                                                                        opj_codestream_info_t *p_cstr_info );\n\n/* ----------------------------------------------------------------------- */\n\n/**\nCreate a new TCD handle\n*/\nopj_tcd_t* opj_tcd_create(OPJ_BOOL p_is_decoder)\n{\n        opj_tcd_t *l_tcd = 00;\n\n        /* create the tcd structure */\n        l_tcd = (opj_tcd_t*) opj_calloc(1,sizeof(opj_tcd_t));\n        if (!l_tcd) {\n                return 00;\n        }\n\n        l_tcd->m_is_decoder = p_is_decoder ? 1 : 0;\n\n        l_tcd->tcd_image = (opj_tcd_image_t*)opj_calloc(1,sizeof(opj_tcd_image_t));\n        if (!l_tcd->tcd_image) {\n                opj_free(l_tcd);\n                return 00;\n        }\n\n        return l_tcd;\n}\n\n\n/* ----------------------------------------------------------------------- */\n\nvoid opj_tcd_rateallocate_fixed(opj_tcd_t *tcd) {\n        OPJ_UINT32 layno;\n\n        for (layno = 0; layno < tcd->tcp->numlayers; layno++) {\n                opj_tcd_makelayer_fixed(tcd, layno, 1);\n        }\n}\n\n\nvoid opj_tcd_makelayer( opj_tcd_t *tcd,\n                                                OPJ_UINT32 layno,\n                                                OPJ_FLOAT64 thresh,\n                                                OPJ_UINT32 final)\n{\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n        OPJ_UINT32 passno;\n\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n\n        tcd_tile->distolayer[layno] = 0;        /* fixed_quality */\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                                                opj_tcd_layer_t *layer = &cblk->layers[layno];\n                                                OPJ_UINT32 n;\n\n                                                if (layno == 0) {\n                                                        cblk->numpassesinlayers = 0;\n                                                }\n\n                                                n = cblk->numpassesinlayers;\n\n                                                for (passno = cblk->numpassesinlayers; passno < cblk->totalpasses; passno++) {\n                                                        OPJ_UINT32 dr;\n                                                        OPJ_FLOAT64 dd;\n                                                        opj_tcd_pass_t *pass = &cblk->passes[passno];\n\n                                                        if (n == 0) {\n                                                                dr = pass->rate;\n                                                                dd = pass->distortiondec;\n                                                        } else {\n                                                                dr = pass->rate - cblk->passes[n - 1].rate;\n                                                                dd = pass->distortiondec - cblk->passes[n - 1].distortiondec;\n                                                        }\n\n                                                        if (!dr) {\n                                                                if (dd != 0)\n                                                                        n = passno + 1;\n                                                                continue;\n                                                        }\n                                                        if (thresh - (dd / dr) < DBL_EPSILON) /* do not rely on float equality, check with DBL_EPSILON margin */\n                                                                n = passno + 1;\n                                                }\n\n                                                layer->numpasses = n - cblk->numpassesinlayers;\n\n                                                if (!layer->numpasses) {\n                                                        layer->disto = 0;\n                                                        continue;\n                                                }\n\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        layer->len = cblk->passes[n - 1].rate;\n                                                        layer->data = cblk->data;\n                                                        layer->disto = cblk->passes[n - 1].distortiondec;\n                                                } else {\n                                                        layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->disto = cblk->passes[n - 1].distortiondec - cblk->passes[cblk->numpassesinlayers - 1].distortiondec;\n                                                }\n\n                                                tcd_tile->distolayer[layno] += layer->disto;    /* fixed_quality */\n\n                                                if (final)\n                                                        cblk->numpassesinlayers = n;\n                                        }\n                                }\n                        }\n                }\n        }\n}\n\nvoid opj_tcd_makelayer_fixed(opj_tcd_t *tcd, OPJ_UINT32 layno, OPJ_UINT32 final) {\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n        OPJ_INT32 value;                        /*, matrice[tcd_tcp->numlayers][tcd_tile->comps[0].numresolutions][3]; */\n        OPJ_INT32 matrice[10][10][3];\n        OPJ_UINT32 i, j, k;\n\n        opj_cp_t *cp = tcd->cp;\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n        opj_tcp_t *tcd_tcp = tcd->tcp;\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n                for (i = 0; i < tcd_tcp->numlayers; i++) {\n                        for (j = 0; j < tilec->numresolutions; j++) {\n                                for (k = 0; k < 3; k++) {\n                                        matrice[i][j][k] =\n                                                (OPJ_INT32) ((OPJ_FLOAT32)cp->m_specific_param.m_enc.m_matrice[i * tilec->numresolutions * 3 + j * 3 + k]\n                                                * (OPJ_FLOAT32) (tcd->image->comps[compno].prec / 16.0));\n                                }\n                        }\n                }\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                                                opj_tcd_layer_t *layer = &cblk->layers[layno];\n                                                OPJ_UINT32 n;\n                                                OPJ_INT32 imsb = (OPJ_INT32)(tcd->image->comps[compno].prec - cblk->numbps); /* number of bit-plan equal to zero */\n\n                                                /* Correction of the matrix of coefficient to include the IMSB information */\n                                                if (layno == 0) {\n                                                        value = matrice[layno][resno][bandno];\n                                                        if (imsb >= value) {\n                                                                value = 0;\n                                                        } else {\n                                                                value -= imsb;\n                                                        }\n                                                } else {\n                                                        value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];\n                                                        if (imsb >= matrice[layno - 1][resno][bandno]) {\n                                                                value -= (imsb - matrice[layno - 1][resno][bandno]);\n                                                                if (value < 0) {\n                                                                        value = 0;\n                                                                }\n                                                        }\n                                                }\n\n                                                if (layno == 0) {\n                                                        cblk->numpassesinlayers = 0;\n                                                }\n\n                                                n = cblk->numpassesinlayers;\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        if (value != 0) {\n                                                                n = 3 * (OPJ_UINT32)value - 2 + cblk->numpassesinlayers;\n                                                        } else {\n                                                                n = cblk->numpassesinlayers;\n                                                        }\n                                                } else {\n                                                        n = 3 * (OPJ_UINT32)value + cblk->numpassesinlayers;\n                                                }\n\n                                                layer->numpasses = n - cblk->numpassesinlayers;\n\n                                                if (!layer->numpasses)\n                                                        continue;\n\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        layer->len = cblk->passes[n - 1].rate;\n                                                        layer->data = cblk->data;\n                                                } else {\n                                                        layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                }\n\n                                                if (final)\n                                                        cblk->numpassesinlayers = n;\n                                        }\n                                }\n                        }\n                }\n        }\n}\n\nOPJ_BOOL opj_tcd_rateallocate(  opj_tcd_t *tcd,\n                                                                OPJ_BYTE *dest,\n                                                                OPJ_UINT32 * p_data_written,\n                                                                OPJ_UINT32 len,\n                                                                opj_codestream_info_t *cstr_info)\n{\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno, layno;\n        OPJ_UINT32 passno;\n        OPJ_FLOAT64 min, max;\n        OPJ_FLOAT64 cumdisto[100];      /* fixed_quality */\n        const OPJ_FLOAT64 K = 1;                /* 1.1; fixed_quality */\n        OPJ_FLOAT64 maxSE = 0;\n\n        opj_cp_t *cp = tcd->cp;\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n        opj_tcp_t *tcd_tcp = tcd->tcp;\n\n        min = DBL_MAX;\n        max = 0;\n\n        tcd_tile->numpix = 0;           /* fixed_quality */\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n                tilec->numpix = 0;\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n\n                                                for (passno = 0; passno < cblk->totalpasses; passno++) {\n                                                        opj_tcd_pass_t *pass = &cblk->passes[passno];\n                                                        OPJ_INT32 dr;\n                                                        OPJ_FLOAT64 dd, rdslope;\n\n                                                        if (passno == 0) {\n                                                                dr = (OPJ_INT32)pass->rate;\n                                                                dd = pass->distortiondec;\n                                                        } else {\n                                                                dr = (OPJ_INT32)(pass->rate - cblk->passes[passno - 1].rate);\n                                                                dd = pass->distortiondec - cblk->passes[passno - 1].distortiondec;\n                                                        }\n\n                                                        if (dr == 0) {\n                                                                continue;\n                                                        }\n\n                                                        rdslope = dd / dr;\n                                                        if (rdslope < min) {\n                                                                min = rdslope;\n                                                        }\n\n                                                        if (rdslope > max) {\n                                                                max = rdslope;\n                                                        }\n                                                } /* passno */\n\n                                                /* fixed_quality */\n                                                tcd_tile->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                                                tilec->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                                        } /* cbklno */\n                                } /* precno */\n                        } /* bandno */\n                } /* resno */\n\n                maxSE += (((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) - 1.0)\n                        * ((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) -1.0))\n                        * ((OPJ_FLOAT64)(tilec->numpix));\n        } /* compno */\n\n        /* index file */\n        if(cstr_info) {\n                opj_tile_info_t *tile_info = &cstr_info->tile[tcd->tcd_tileno];\n                tile_info->numpix = tcd_tile->numpix;\n                tile_info->distotile = tcd_tile->distotile;\n                tile_info->thresh = (OPJ_FLOAT64 *) opj_malloc(tcd_tcp->numlayers * sizeof(OPJ_FLOAT64));\n                if (!tile_info->thresh) {\n                        /* FIXME event manager error callback */\n                        return OPJ_FALSE;\n                }\n        }\n\n        for (layno = 0; layno < tcd_tcp->numlayers; layno++) {\n                OPJ_FLOAT64 lo = min;\n                OPJ_FLOAT64 hi = max;\n                OPJ_UINT32 maxlen = tcd_tcp->rates[layno] > 0.0f ? opj_uint_min(((OPJ_UINT32) ceil(tcd_tcp->rates[layno])), len) : len;\n                OPJ_FLOAT64 goodthresh = 0;\n                OPJ_FLOAT64 stable_thresh = 0;\n                OPJ_UINT32 i;\n                OPJ_FLOAT64 distotarget;                /* fixed_quality */\n\n                /* fixed_quality */\n                distotarget = tcd_tile->distotile - ((K * maxSE) / pow((OPJ_FLOAT32)10, tcd_tcp->distoratio[layno] / 10));\n\n                /* Don't try to find an optimal threshold but rather take everything not included yet, if\n                  -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)\n                  -q xx,yy,zz,0   (fixed_quality == 1 and distoratio == 0)\n                  ==> possible to have some lossy layers and the last layer for sure lossless */\n                if ( ((cp->m_specific_param.m_enc.m_disto_alloc==1) && (tcd_tcp->rates[layno]>0.0f)) || ((cp->m_specific_param.m_enc.m_fixed_quality==1) && (tcd_tcp->distoratio[layno]>0.0))) {\n                        opj_t2_t*t2 = opj_t2_create(tcd->image, cp);\n                        OPJ_FLOAT64 thresh = 0;\n\n                        if (t2 == 00) {\n                                return OPJ_FALSE;\n                        }\n\n                        for     (i = 0; i < 128; ++i) {\n                                OPJ_FLOAT64 distoachieved = 0;  /* fixed_quality */\n\n                                thresh = (lo + hi) / 2;\n\n                                opj_tcd_makelayer(tcd, layno, thresh, 0);\n\n                                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* fixed_quality */\n                                        if(OPJ_IS_CINEMA(cp->rsiz)){\n                                                if (! opj_t2_encode_packets(t2,tcd->tcd_tileno, tcd_tile, layno + 1, dest, p_data_written, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC)) {\n\n                                                        lo = thresh;\n                                                        continue;\n                                                }\n                                                else {\n                                                        distoachieved = layno == 0 ?\n                                                                        tcd_tile->distolayer[0] : cumdisto[layno - 1] + tcd_tile->distolayer[layno];\n\n                                                        if (distoachieved < distotarget) {\n                                                                hi=thresh;\n                                                                stable_thresh = thresh;\n                                                                continue;\n                                                        }else{\n                                                                lo=thresh;\n                                                        }\n                                                }\n                                        }else{\n                                                distoachieved = (layno == 0) ?\n                                                                tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n\n                                                if (distoachieved < distotarget) {\n                                                        hi = thresh;\n                                                        stable_thresh = thresh;\n                                                        continue;\n                                                }\n                                                lo = thresh;\n                                        }\n                                } else {\n                                        if (! opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,p_data_written, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC))\n                                        {\n                                                /* TODO: what to do with l ??? seek / tell ??? */\n                                                /* opj_event_msg(tcd->cinfo, EVT_INFO, \"rate alloc: len=%d, max=%d\\n\", l, maxlen); */\n                                                lo = thresh;\n                                                continue;\n                                        }\n\n                                        hi = thresh;\n                                        stable_thresh = thresh;\n                                }\n                        }\n\n                        goodthresh = stable_thresh == 0? thresh : stable_thresh;\n\n                        opj_t2_destroy(t2);\n                } else {\n                        goodthresh = min;\n                }\n\n                if(cstr_info) { /* Threshold for Marcela Index */\n                        cstr_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;\n                }\n\n                opj_tcd_makelayer(tcd, layno, goodthresh, 1);\n\n                /* fixed_quality */\n                cumdisto[layno] = (layno == 0) ? tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init( opj_tcd_t *p_tcd,\n                                           opj_image_t * p_image,\n                                           opj_cp_t * p_cp )\n{\n        p_tcd->image = p_image;\n        p_tcd->cp = p_cp;\n\n        p_tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_calloc(1,sizeof(opj_tcd_tile_t));\n        if (! p_tcd->tcd_image->tiles) {\n                return OPJ_FALSE;\n        }\n\n        p_tcd->tcd_image->tiles->comps = (opj_tcd_tilecomp_t *) opj_calloc(p_image->numcomps,sizeof(opj_tcd_tilecomp_t));\n        if (! p_tcd->tcd_image->tiles->comps ) {\n                return OPJ_FALSE;\n        }\n\n        p_tcd->tcd_image->tiles->numcomps = p_image->numcomps;\n        p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;\n\n        return OPJ_TRUE;\n}\n\n/**\nDestroy a previously created TCD handle\n*/\nvoid opj_tcd_destroy(opj_tcd_t *tcd) {\n        if (tcd) {\n                opj_tcd_free_tile(tcd);\n\n                if (tcd->tcd_image) {\n                        opj_free(tcd->tcd_image);\n                        tcd->tcd_image = 00;\n                }\n                opj_free(tcd);\n        }\n}\n\nOPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec)\n{\n\tif ((l_tilec->data == 00) || ((l_tilec->data_size_needed > l_tilec->data_size) && (l_tilec->ownsData == OPJ_FALSE))) {\n\t\tl_tilec->data = (OPJ_INT32 *) opj_aligned_malloc(l_tilec->data_size_needed);\n\t\tif (! l_tilec->data ) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t/*fprintf(stderr, \"tAllocate data of tilec (int): %d x OPJ_UINT32n\",l_data_size);*/\n\t\tl_tilec->data_size = l_tilec->data_size_needed;\n\t\tl_tilec->ownsData = OPJ_TRUE;\n\t}\n\telse if (l_tilec->data_size_needed > l_tilec->data_size) {\n\t\t/* We don't need to keep old data */\n\t\topj_aligned_free(l_tilec->data);\n\t\tl_tilec->data = (OPJ_INT32 *) opj_aligned_malloc(l_tilec->data_size_needed);\n\t\tif (! l_tilec->data ) {\n\t\t\tl_tilec->data_size = 0;\n\t\t\tl_tilec->data_size_needed = 0;\n\t\t\tl_tilec->ownsData = OPJ_FALSE;\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t/*fprintf(stderr, \"tReallocate data of tilec (int): from %d to %d x OPJ_UINT32n\", l_tilec->data_size, l_data_size);*/\n\t\tl_tilec->data_size = l_tilec->data_size_needed;\n\t\tl_tilec->ownsData = OPJ_TRUE;\n\t}\n\treturn OPJ_TRUE;\n}\n\n/* ----------------------------------------------------------------------- */\n\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block, opj_event_mgr_t* manager)\n{\n\tOPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32) = 00;\n\tOPJ_UINT32 compno, resno, bandno, precno, cblkno;\n\topj_tcp_t * l_tcp = 00;\n\topj_cp_t * l_cp = 00;\n\topj_tcd_tile_t * l_tile = 00;\n\topj_tccp_t *l_tccp = 00;\n\topj_tcd_tilecomp_t *l_tilec = 00;\n\topj_image_comp_t * l_image_comp = 00;\n\topj_tcd_resolution_t *l_res = 00;\n\topj_tcd_band_t *l_band = 00;\n\topj_stepsize_t * l_step_size = 00;\n\topj_tcd_precinct_t *l_current_precinct = 00;\n\topj_image_t *l_image = 00;\n\tOPJ_UINT32 p,q;\n\tOPJ_UINT32 l_level_no;\n\tOPJ_UINT32 l_pdx, l_pdy;\n\tOPJ_UINT32 l_gain;\n\tOPJ_INT32 l_x0b, l_y0b;\n\tOPJ_UINT32 l_tx0, l_ty0;\n\t/* extent of precincts , top left, bottom right**/\n\tOPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;\n\t/* number of precinct for a resolution */\n\tOPJ_UINT32 l_nb_precincts;\n\t/* room needed to store l_nb_precinct precinct for a resolution */\n\tOPJ_UINT32 l_nb_precinct_size;\n\t/* number of code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks;\n\t/* room needed to store l_nb_code_blocks code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks_size;\n\t/* size of data for a tile */\n\tOPJ_UINT32 l_data_size;\n\t\n\tl_cp = p_tcd->cp;\n\tl_tcp = &(l_cp->tcps[p_tile_no]);\n\tl_tile = p_tcd->tcd_image->tiles;\n\tl_tccp = l_tcp->tccps;\n\tl_tilec = l_tile->comps;\n\tl_image = p_tcd->image;\n\tl_image_comp = p_tcd->image->comps;\n\t\n\tp = p_tile_no % l_cp->tw;       /* tile coordinates */\n\tq = p_tile_no / l_cp->tw;\n\t/*fprintf(stderr, \"Tile coordinate = %d,%d\\n\", p, q);*/\n\t\n\t/* 4 borders of the tile rescale on the image if necessary */\n\tl_tx0 = l_cp->tx0 + p * l_cp->tdx; /* can't be greater than l_image->x1 so won't overflow */\n\tl_tile->x0 = (OPJ_INT32)opj_uint_max(l_tx0, l_image->x0);\n\tl_tile->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, l_cp->tdx), l_image->x1);\n\tl_ty0 = l_cp->ty0 + q * l_cp->tdy; /* can't be greater than l_image->y1 so won't overflow */\n\tl_tile->y0 = (OPJ_INT32)opj_uint_max(l_ty0, l_image->y0);\n\tl_tile->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, l_cp->tdy), l_image->y1);\n\n\t/* testcase 1888.pdf.asan.35.988 */\n\tif (l_tccp->numresolutions == 0) {\n\t\topj_event_msg(manager, EVT_ERROR, \"tiles require at least one resolution\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t/*fprintf(stderr, \"Tile border = %d,%d,%d,%d\\n\", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);*/\n\t\n\t/*tile->numcomps = image->numcomps; */\n\tfor (compno = 0; compno < l_tile->numcomps; ++compno) {\n\t\t/*fprintf(stderr, \"compno = %d/%d\\n\", compno, l_tile->numcomps);*/\n\t\tl_image_comp->resno_decoded = 0;\n\t\t/* border of each l_tile component (global) */\n\t\tl_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);\n\t\tl_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);\n\t\tl_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);\n\t\tl_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);\n\t\t/*fprintf(stderr, \"\\tTile compo border = %d,%d,%d,%d\\n\", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);*/\n\t\t\n\t\t/* compute l_data_size with overflow check */\n\t\tl_data_size = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);\n\t\t/* issue 733, l_data_size == 0U, probably something wrong should be checked before getting here */\n\t\tif ((l_data_size > 0U) && ((((OPJ_UINT32)-1) / l_data_size) < (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0))) {\n\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);\n\t\t\n\t\tif ((((OPJ_UINT32)-1) / (OPJ_UINT32)sizeof(OPJ_UINT32)) < l_data_size) {\n\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)sizeof(OPJ_UINT32);\n\t\tl_tilec->numresolutions = l_tccp->numresolutions;\n\t\tif (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {\n\t\t\tl_tilec->minimum_num_resolutions = 1;\n\t\t}\n\t\telse {\n\t\t\tl_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;\n\t\t}\n\t\t\n\t\tl_tilec->data_size_needed = l_data_size;\n\t\tif (p_tcd->m_is_decoder && !opj_alloc_tile_component_data(l_tilec)) {\n\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\tl_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(opj_tcd_resolution_t);\n\t\t\n\t\tif (l_tilec->resolutions == 00) {\n\t\t\tl_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);\n\t\t\tif (! l_tilec->resolutions ) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\t/*fprintf(stderr, \"\\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\\n\",l_data_size);*/\n\t\t\tl_tilec->resolutions_size = l_data_size;\n\t\t\tmemset(l_tilec->resolutions,0,l_data_size);\n\t\t}\n\t\telse if (l_data_size > l_tilec->resolutions_size) {\n\t\t\topj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(l_tilec->resolutions, l_data_size);\n\t\t\tif (! new_resolutions) {\n\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile resolutions\\n\");\n\t\t\t\topj_free(l_tilec->resolutions);\n\t\t\t\tl_tilec->resolutions = NULL;\n\t\t\t\tl_tilec->resolutions_size = 0;\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\tl_tilec->resolutions = new_resolutions;\n\t\t\t/*fprintf(stderr, \"\\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\\n\", l_tilec->resolutions_size, l_data_size);*/\n\t\t\tmemset(((OPJ_BYTE*) l_tilec->resolutions)+l_tilec->resolutions_size,0,l_data_size - l_tilec->resolutions_size);\n\t\t\tl_tilec->resolutions_size = l_data_size;\n\t\t}\n\t\t\n\t\tl_level_no = l_tilec->numresolutions;\n\t\tl_res = l_tilec->resolutions;\n\t\tl_step_size = l_tccp->stepsizes;\n\t\tif (l_tccp->qmfbid == 0) {\n\t\t\tl_gain_ptr = &opj_dwt_getgain_real;\n\t\t}\n\t\telse {\n\t\t\tl_gain_ptr  = &opj_dwt_getgain;\n\t\t}\n\t\t/*fprintf(stderr, \"\\tlevel_no=%d\\n\",l_level_no);*/\n\t\t\n\t\tfor (resno = 0; resno < l_tilec->numresolutions; ++resno) {\n\t\t\t/*fprintf(stderr, \"\\t\\tresno = %d/%d\\n\", resno, l_tilec->numresolutions);*/\n\t\t\tOPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;\n\t\t\tOPJ_UINT32 cbgwidthexpn, cbgheightexpn;\n\t\t\tOPJ_UINT32 cblkwidthexpn, cblkheightexpn;\n\t\t\t\n\t\t\t--l_level_no;\n\t\t\t\n\t\t\t/* border for each resolution level (global) */\n\t\t\tl_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n\t\t\tl_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n\t\t\tl_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n\t\t\tl_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\\n\", l_res->x0, l_res->y0, l_res->x1, l_res->y1);*/\n\t\t\t/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tpdx=%d, pdy=%d\\n\", l_pdx, l_pdy);*/\n\t\t\t/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */\n\t\t\tl_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \\n\", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/\n\t\t\t\n\t\t\tl_res->pw = (l_res->x0 == l_res->x1) ? 0 : (OPJ_UINT32)((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);\n\t\t\tl_res->ph = (l_res->y0 == l_res->y1) ? 0 : (OPJ_UINT32)((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tres_pw=%d, res_ph=%d\\n\", l_res->pw, l_res->ph );*/\n\t\t\t\n\t\t\tl_nb_precincts = l_res->pw * l_res->ph;\n\t\t\tl_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\t\t\tif (resno == 0) {\n\t\t\t\ttlcbgxstart = l_tl_prc_x_start;\n\t\t\t\ttlcbgystart = l_tl_prc_y_start;\n\t\t\t\t/*brcbgxend = l_br_prc_x_end;*/\n\t\t\t\t/* brcbgyend = l_br_prc_y_end;*/\n\t\t\t\tcbgwidthexpn = l_pdx;\n\t\t\t\tcbgheightexpn = l_pdy;\n\t\t\t\tl_res->numbands = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);\n\t\t\t\ttlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);\n\t\t\t\t/*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/\n\t\t\t\t/*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/\n\t\t\t\tcbgwidthexpn = l_pdx - 1;\n\t\t\t\tcbgheightexpn = l_pdy - 1;\n\t\t\t\tl_res->numbands = 3;\n\t\t\t}\n\t\t\t\n\t\t\tcblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);\n\t\t\tcblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);\n\t\t\tl_band = l_res->bands;\n\t\t\t\n\t\t\tfor (bandno = 0; bandno < l_res->numbands; ++bandno) {\n\t\t\t\tOPJ_INT32 numbps;\n\t\t\t\t/*fprintf(stderr, \"\\t\\t\\tband_no=%d/%d\\n\", bandno, l_res->numbands );*/\n\t\t\t\t\n\t\t\t\tif (resno == 0) {\n\t\t\t\t\tl_band->bandno = 0 ;\n\t\t\t\t\tl_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl_band->bandno = bandno + 1;\n\t\t\t\t\t/* x0b = 1 if bandno = 1 or 3 */\n\t\t\t\t\tl_x0b = l_band->bandno&1;\n\t\t\t\t\t/* y0b = 1 if bandno = 2 or 3 */\n\t\t\t\t\tl_y0b = (OPJ_INT32)((l_band->bandno)>>1);\n\t\t\t\t\t/* l_band border (global) */\n\t\t\t\t\tl_band->x0 = opj_int64_ceildivpow2(l_tilec->x0 - ((OPJ_INT64)l_x0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->y0 = opj_int64_ceildivpow2(l_tilec->y0 - ((OPJ_INT64)l_y0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->x1 = opj_int64_ceildivpow2(l_tilec->x1 - ((OPJ_INT64)l_x0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->y1 = opj_int64_ceildivpow2(l_tilec->y1 - ((OPJ_INT64)l_y0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/** avoid an if with storing function pointer */\n\t\t\t\tl_gain = (*l_gain_ptr) (l_band->bandno);\n\t\t\t\tnumbps = (OPJ_INT32)(l_image_comp->prec + l_gain);\n\t\t\t\tl_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0, (OPJ_INT32) (numbps - l_step_size->expn)))) * fraction;\n\t\t\t\tl_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits - 1;      /* WHY -1 ? */\n\t\t\t\t\n\t\t\t\tif (!l_band->precincts && (l_nb_precincts > 0U)) {\n\t\t\t\t\tl_band->precincts = (opj_tcd_precinct_t *) opj_malloc( /*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! l_band->precincts) {\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tAllocate precincts of a band (opj_tcd_precinct_t): %d\\n\",l_nb_precinct_size);     */\n\t\t\t\t\tmemset(l_band->precincts,0,l_nb_precinct_size);\n\t\t\t\t\tl_band->precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\telse if (l_band->precincts_data_size < l_nb_precinct_size) {\n\t\t\t\t\t\n\t\t\t\t\topj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(l_band->precincts,/*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! new_precincts) {\n\t\t\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory to handle band precints\\n\");\n\t\t\t\t\t\topj_free(l_band->precincts);\n\t\t\t\t\t\tl_band->precincts = NULL;\n\t\t\t\t\t\tl_band->precincts_data_size = 0;\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tl_band->precincts = new_precincts;\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\\n\",l_band->precincts_data_size, l_nb_precinct_size);*/\n\t\t\t\t\tmemset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size,0,l_nb_precinct_size - l_band->precincts_data_size);\n\t\t\t\t\tl_band->precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tl_current_precinct = l_band->precincts;\n\t\t\t\tfor (precno = 0; precno < l_nb_precincts; ++precno) {\n\t\t\t\t\tOPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;\n\t\t\t\t\tOPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) * (1 << cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) * (1 << cbgheightexpn);\n\t\t\t\t\tOPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);\n\t\t\t\t\t/*fprintf(stderr, \"\\t precno=%d; bandno=%d, resno=%d; compno=%d\\n\", precno, bandno , resno, compno);*/\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \\n\",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);*/\n\t\t\t\t\t\n\t\t\t\t\t/* precinct size (global) */\n\t\t\t\t\t/*fprintf(stderr, \"\\t cbgxstart=%d, l_band->x0 = %d \\n\",cbgxstart, l_band->x0);*/\n\t\t\t\t\t\n\t\t\t\t\tl_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);\n\t\t\t\t\tl_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);\n\t\t\t\t\tl_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);\n\t\t\t\t\tl_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);\n\t\t\t\t\t/*fprintf(stderr, \"\\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\\n\",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);*/\n\t\t\t\t\t\n\t\t\t\t\ttlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcblkxstart =%d\\n\",tlcblkxstart );*/\n\t\t\t\t\ttlcblkystart = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcblkystart =%d\\n\",tlcblkystart );*/\n\t\t\t\t\tbrcblkxend = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t brcblkxend =%d\\n\",brcblkxend );*/\n\t\t\t\t\tbrcblkyend = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t brcblkyend =%d\\n\",brcblkyend );*/\n\t\t\t\t\tl_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >> cblkwidthexpn);\n\t\t\t\t\tl_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >> cblkheightexpn);\n\t\t\t\t\t\n\t\t\t\t\tl_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\t precinct_cw = %d x recinct_ch = %d\\n\",l_current_precinct->cw, l_current_precinct->ch);      */\n\t\t\t\t\tl_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;\n\t\t\t\t\t\n\t\t\t\t\tif (!l_current_precinct->cblks.blocks && (l_nb_code_blocks > 0U)) {\n\t\t\t\t\t\tl_current_precinct->cblks.blocks = opj_malloc(l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! l_current_precinct->cblks.blocks ) {\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\\n\",l_nb_code_blocks_size);*/\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(l_current_precinct->cblks.blocks,0,l_nb_code_blocks_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct->block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\telse if (l_nb_code_blocks_size > l_current_precinct->block_size) {\n\t\t\t\t\t\tvoid *new_blocks = opj_realloc(l_current_precinct->cblks.blocks, l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! new_blocks) {\n\t\t\t\t\t\t\topj_free(l_current_precinct->cblks.blocks);\n\t\t\t\t\t\t\tl_current_precinct->cblks.blocks = NULL;\n\t\t\t\t\t\t\tl_current_precinct->block_size = 0;\n\t\t\t\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for current precinct codeblock element\\n\");\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tl_current_precinct->cblks.blocks = new_blocks;\n\t\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\\n\",l_current_precinct->block_size, l_nb_code_blocks_size);     */\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(((OPJ_BYTE *) l_current_precinct->cblks.blocks) + l_current_precinct->block_size\n\t\t\t\t\t\t\t\t\t ,0\n\t\t\t\t\t\t\t\t\t ,l_nb_code_blocks_size - l_current_precinct->block_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct->block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (! l_current_precinct->incltree) {\n\t\t\t\t\t\tl_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tl_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree, l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->incltree)     {\n\t\t\t\t\t\topj_event_msg(manager, EVT_WARNING, \"No incltree created.\\n\");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->imsbtree) {\n\t\t\t\t\t\tl_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tl_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree, l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->imsbtree) {\n\t\t\t\t\t\topj_event_msg(manager, EVT_WARNING, \"No imsbtree created.\\n\");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\t\t\t\t\t\tOPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isEncoder) {\n\t\t\t\t\t\t\topj_tcd_cblk_enc_t* l_code_block = l_current_precinct->cblks.enc + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n\t\t\t\t\t\t\tl_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n\t\t\t\t\t\t\tl_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n\t\t\t\t\t\t\tl_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topj_tcd_cblk_dec_t* l_code_block = l_current_precinct->cblks.dec + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_dec_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n\t\t\t\t\t\t\tl_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n\t\t\t\t\t\t\tl_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n\t\t\t\t\t\t\tl_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++l_current_precinct;\n\t\t\t\t} /* precno */\n\t\t\t\t++l_band;\n\t\t\t\t++l_step_size;\n\t\t\t} /* bandno */\n\t\t\t++l_res;\n\t\t} /* resno */\n\t\t++l_tccp;\n\t\t++l_tilec;\n\t\t++l_image_comp;\n\t} /* compno */\n\treturn OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init_encode_tile (opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, opj_event_mgr_t* p_manager)\n{\n\treturn opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_TRUE, 1.0F, sizeof(opj_tcd_cblk_enc_t), p_manager);\n}\n\nOPJ_BOOL opj_tcd_init_decode_tile (opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, opj_event_mgr_t* p_manager)\n{\n\treturn opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_FALSE, 0.5F, sizeof(opj_tcd_cblk_dec_t), p_manager);\n}\n\n/**\n * Allocates memory for an encoding code block (but not data memory).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate (opj_tcd_cblk_enc_t * p_code_block)\n{\n\tif (! p_code_block->layers) {\n\t\t/* no memset since data */\n\t\tp_code_block->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));\n\t\tif (! p_code_block->layers) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\tif (! p_code_block->passes) {\n\t\tp_code_block->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));\n\t\tif (! p_code_block->passes) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\treturn OPJ_TRUE;\n}\n\n/**\n * Allocates data memory for an encoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data (opj_tcd_cblk_enc_t * p_code_block)\n{\n\tOPJ_UINT32 l_data_size;\n\t\n\tl_data_size = (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) * (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\t\n\tif (l_data_size > p_code_block->data_size) {\n\t\tif (p_code_block->data) {\n\t\t\topj_free(p_code_block->data - 1); /* again, why -1 */\n\t\t}\n\t\tp_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size+1);\n\t\tif(! p_code_block->data) {\n\t\t\tp_code_block->data_size = 0U;\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tp_code_block->data_size = l_data_size;\n\t\t\n\t\tp_code_block->data[0] = 0;\n\t\tp_code_block->data+=1;   /*why +1 ?*/\n\t}\n\treturn OPJ_TRUE;\n}\n\n/**\n * Allocates memory for a decoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate (opj_tcd_cblk_dec_t * p_code_block)\n{\n        if (! p_code_block->data) {\n\n                p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_J2K_DEFAULT_CBLK_DATA_SIZE);\n                if (! p_code_block->data) {\n                        return OPJ_FALSE;\n                }\n                p_code_block->data_max_size = OPJ_J2K_DEFAULT_CBLK_DATA_SIZE;\n                /*fprintf(stderr, \"Allocate 8192 elements of code_block->data\\n\");*/\n\n                p_code_block->segs = (opj_tcd_seg_t *) opj_calloc(OPJ_J2K_DEFAULT_NB_SEGS,sizeof(opj_tcd_seg_t));\n                if (! p_code_block->segs) {\n                        return OPJ_FALSE;\n                }\n                /*fprintf(stderr, \"Allocate %d elements of code_block->data\\n\", OPJ_J2K_DEFAULT_NB_SEGS * sizeof(opj_tcd_seg_t));*/\n\n                p_code_block->m_current_max_segs = OPJ_J2K_DEFAULT_NB_SEGS;\n                /*fprintf(stderr, \"m_current_max_segs of code_block->data = %d\\n\", p_code_block->m_current_max_segs);*/\n        } else {\n\t\t\t\t\t/* sanitize */\n\t\t\t\t\tOPJ_BYTE* l_data = p_code_block->data;\n\t\t\t\t\tOPJ_UINT32 l_data_max_size = p_code_block->data_max_size;\n\t\t\t\t\topj_tcd_seg_t * l_segs = p_code_block->segs;\n\t\t\t\t\tOPJ_UINT32 l_current_max_segs = p_code_block->m_current_max_segs;\n\n\t\t\t\t\tmemset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t));\n\t\t\t\t\tp_code_block->data = l_data;\n\t\t\t\t\tp_code_block->data_max_size = l_data_max_size;\n\t\t\t\t\tp_code_block->segs = l_segs;\n\t\t\t\t\tp_code_block->m_current_max_segs = l_current_max_segs;\n\t\t\t\t}\n\n        return OPJ_TRUE;\n}\n\nOPJ_UINT32 opj_tcd_get_decoded_tile_size ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tcd_resolution_t * l_res = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n\n        l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n                if(l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                l_res = l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions - 1;\n                l_data_size += l_size_comp * (OPJ_UINT32)((l_res->x1 - l_res->x0) * (l_res->y1 - l_res->y0));\n                ++l_img_comp;\n                ++l_tile_comp;\n        }\n\n        return l_data_size;\n}\n\nOPJ_BOOL opj_tcd_encode_tile(   opj_tcd_t *p_tcd,\n                                                        OPJ_UINT32 p_tile_no,\n                                                        OPJ_BYTE *p_dest,\n                                                        OPJ_UINT32 * p_data_written,\n                                                        OPJ_UINT32 p_max_length,\n                                                        opj_codestream_info_t *p_cstr_info)\n{\n\n        if (p_tcd->cur_tp_num == 0) {\n\n                p_tcd->tcd_tileno = p_tile_no;\n                p_tcd->tcp = &p_tcd->cp->tcps[p_tile_no];\n\n                /* INDEX >> \"Precinct_nb_X et Precinct_nb_Y\" */\n                if(p_cstr_info)  {\n                        OPJ_UINT32 l_num_packs = 0;\n                        OPJ_UINT32 i;\n                        opj_tcd_tilecomp_t *l_tilec_idx = &p_tcd->tcd_image->tiles->comps[0];        /* based on component 0 */\n                        opj_tccp_t *l_tccp = p_tcd->tcp->tccps; /* based on component 0 */\n\n                        for (i = 0; i < l_tilec_idx->numresolutions; i++) {\n                                opj_tcd_resolution_t *l_res_idx = &l_tilec_idx->resolutions[i];\n\n                                p_cstr_info->tile[p_tile_no].pw[i] = (int)l_res_idx->pw;\n                                p_cstr_info->tile[p_tile_no].ph[i] = (int)l_res_idx->ph;\n\n                                l_num_packs += l_res_idx->pw * l_res_idx->ph;\n                                p_cstr_info->tile[p_tile_no].pdx[i] = (int)l_tccp->prcw[i];\n                                p_cstr_info->tile[p_tile_no].pdy[i] = (int)l_tccp->prch[i];\n                        }\n                        p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t*) opj_calloc((size_t)p_cstr_info->numcomps * (size_t)p_cstr_info->numlayers * l_num_packs, sizeof(opj_packet_info_t));\n                        if (!p_cstr_info->tile[p_tile_no].packet) {\n                                /* FIXME event manager error callback */\n                                return OPJ_FALSE;\n                        }\n                }\n                /* << INDEX */\n\n                /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n                /*---------------TILE-------------------*/\n                if (! opj_tcd_dc_level_shift_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n                /* FIXME _ProfStart(PGROUP_MCT); */\n                if (! opj_tcd_mct_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_MCT); */\n\n                /* FIXME _ProfStart(PGROUP_DWT); */\n                if (! opj_tcd_dwt_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME  _ProfStop(PGROUP_DWT); */\n\n                /* FIXME  _ProfStart(PGROUP_T1); */\n                if (! opj_tcd_t1_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_T1); */\n\n                /* FIXME _ProfStart(PGROUP_RATE); */\n                if (! opj_tcd_rate_allocate_encode(p_tcd,p_dest,p_max_length,p_cstr_info)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_RATE); */\n\n        }\n        /*--------------TIER2------------------*/\n\n        /* INDEX */\n        if (p_cstr_info) {\n                p_cstr_info->index_write = 1;\n        }\n        /* FIXME _ProfStart(PGROUP_T2); */\n\n        if (! opj_tcd_t2_encode(p_tcd,p_dest,p_data_written,p_max_length,p_cstr_info)) {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T2); */\n\n        /*---------------CLEAN-------------------*/\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_decode_tile(   opj_tcd_t *p_tcd,\n                                OPJ_BYTE *p_src,\n                                OPJ_UINT32 p_max_length,\n                                OPJ_UINT32 p_tile_no,\n                                opj_codestream_index_t *p_cstr_index,\n                                opj_event_mgr_t *p_manager\n                                )\n{\n        OPJ_UINT32 l_data_read;\n        p_tcd->tcd_tileno = p_tile_no;\n        p_tcd->tcp = &(p_tcd->cp->tcps[p_tile_no]);\n\n#ifdef TODO_MSD /* FIXME */\n        /* INDEX >>  */\n        if(p_cstr_info) {\n                OPJ_UINT32 resno, compno, numprec = 0;\n                for (compno = 0; compno < (OPJ_UINT32) p_cstr_info->numcomps; compno++) {\n                        opj_tcp_t *tcp = &p_tcd->cp->tcps[0];\n                        opj_tccp_t *tccp = &tcp->tccps[compno];\n                        opj_tcd_tilecomp_t *tilec_idx = &p_tcd->tcd_image->tiles->comps[compno];\n                        for (resno = 0; resno < tilec_idx->numresolutions; resno++) {\n                                opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[resno];\n                                p_cstr_info->tile[p_tile_no].pw[resno] = res_idx->pw;\n                                p_cstr_info->tile[p_tile_no].ph[resno] = res_idx->ph;\n                                numprec += res_idx->pw * res_idx->ph;\n                                p_cstr_info->tile[p_tile_no].pdx[resno] = tccp->prcw[resno];\n                                p_cstr_info->tile[p_tile_no].pdy[resno] = tccp->prch[resno];\n                        }\n                }\n                p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t *) opj_malloc(p_cstr_info->numlayers * numprec * sizeof(opj_packet_info_t));\n                p_cstr_info->packno = 0;\n        }\n        /* << INDEX */\n#endif\n\n        /*--------------TIER2------------------*/\n        /* FIXME _ProfStart(PGROUP_T2); */\n        l_data_read = 0;\n        if (! opj_tcd_t2_decode(p_tcd, p_src, &l_data_read, p_max_length, p_cstr_index, p_manager))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T2); */\n\n        /*------------------TIER1-----------------*/\n\n        /* FIXME _ProfStart(PGROUP_T1); */\n        if\n                (! opj_tcd_t1_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T1); */\n\n        /*----------------DWT---------------------*/\n\n        /* FIXME _ProfStart(PGROUP_DWT); */\n        if\n                (! opj_tcd_dwt_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_DWT); */\n\n        /*----------------MCT-------------------*/\n        /* FIXME _ProfStart(PGROUP_MCT); */\n        if\n                (! opj_tcd_mct_decode(p_tcd, p_manager))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_MCT); */\n\n        /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n        if\n                (! opj_tcd_dc_level_shift_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n\n        /*---------------TILE-------------------*/\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_update_tile_data ( opj_tcd_t *p_tcd,\n                                    OPJ_BYTE * p_dest,\n                                    OPJ_UINT32 p_dest_length\n                                    )\n{\n        OPJ_UINT32 i,j,k,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        opj_tcd_resolution_t * l_res;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_UINT32 l_stride, l_width,l_height;\n\n        l_data_size = opj_tcd_get_decoded_tile_size(p_tcd);\n        if (l_data_size > p_dest_length) {\n                return OPJ_FALSE;\n        }\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n                l_res = l_tilec->resolutions + l_img_comp->resno_decoded;\n                l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n                l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n                l_stride = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0) - l_width;\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                switch (l_size_comp)\n                        {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_dest_ptr = (OPJ_CHAR *) p_dest;\n                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_CHAR) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for     (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_CHAR) ((*(l_src_ptr++))&0xff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_dest = (OPJ_BYTE *)l_dest_ptr;\n                                }\n                                break;\n                        case 2:\n                                {\n                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;\n                                        OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_dest;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) ((*(l_src_ptr++))&0xffff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_dest = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_dest;\n                                        OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n                                        for (j=0;j<l_height;++j) {\n                                                for (k=0;k<l_width;++k) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++));\n                                                }\n                                                l_src_ptr += l_stride;\n                                        }\n\n                                        p_dest = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                }\n\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return OPJ_TRUE;\n}\n\n\n\n\nstatic void opj_tcd_free_tile(opj_tcd_t *p_tcd)\n{\n        OPJ_UINT32 compno, resno, bandno, precno;\n        opj_tcd_tile_t *l_tile = 00;\n        opj_tcd_tilecomp_t *l_tile_comp = 00;\n        opj_tcd_resolution_t *l_res = 00;\n        opj_tcd_band_t *l_band = 00;\n        opj_tcd_precinct_t *l_precinct = 00;\n        OPJ_UINT32 l_nb_resolutions, l_nb_precincts;\n        void (* l_tcd_code_block_deallocate) (opj_tcd_precinct_t *) = 00;\n\n        if (! p_tcd) {\n                return;\n        }\n\n        if (! p_tcd->tcd_image) {\n                return;\n        }\n\n        if (p_tcd->m_is_decoder) {\n                l_tcd_code_block_deallocate = opj_tcd_code_block_dec_deallocate;\n        }\n        else {\n                l_tcd_code_block_deallocate = opj_tcd_code_block_enc_deallocate;\n        }\n\n        l_tile = p_tcd->tcd_image->tiles;\n        if (! l_tile) {\n                return;\n        }\n\n        l_tile_comp = l_tile->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                l_res = l_tile_comp->resolutions;\n                if (l_res) {\n\n                        l_nb_resolutions = l_tile_comp->resolutions_size / sizeof(opj_tcd_resolution_t);\n                        for (resno = 0; resno < l_nb_resolutions; ++resno) {\n                                l_band = l_res->bands;\n                                for     (bandno = 0; bandno < 3; ++bandno) {\n                                        l_precinct = l_band->precincts;\n                                        if (l_precinct) {\n\n                                                l_nb_precincts = l_band->precincts_data_size / sizeof(opj_tcd_precinct_t);\n                                                for (precno = 0; precno < l_nb_precincts; ++precno) {\n                                                        opj_tgt_destroy(l_precinct->incltree);\n                                                        l_precinct->incltree = 00;\n                                                        opj_tgt_destroy(l_precinct->imsbtree);\n                                                        l_precinct->imsbtree = 00;\n                                                        (*l_tcd_code_block_deallocate) (l_precinct);\n                                                        ++l_precinct;\n                                                }\n\n                                                opj_free(l_band->precincts);\n                                                l_band->precincts = 00;\n                                        }\n                                        ++l_band;\n                                } /* for (resno */\n                                ++l_res;\n                        }\n\n                        opj_free(l_tile_comp->resolutions);\n                        l_tile_comp->resolutions = 00;\n                }\n\n                if (l_tile_comp->ownsData && l_tile_comp->data) {\n                        opj_aligned_free(l_tile_comp->data);\n                        l_tile_comp->data = 00;\n                        l_tile_comp->ownsData = 0;\n                        l_tile_comp->data_size = 0;\n                        l_tile_comp->data_size_needed = 0;\n                }\n                ++l_tile_comp;\n        }\n\n        opj_free(l_tile->comps);\n        l_tile->comps = 00;\n        opj_free(p_tcd->tcd_image->tiles);\n        p_tcd->tcd_image->tiles = 00;\n}\n\n\nstatic OPJ_BOOL opj_tcd_t2_decode (opj_tcd_t *p_tcd,\n                            OPJ_BYTE * p_src_data,\n                            OPJ_UINT32 * p_data_read,\n                            OPJ_UINT32 p_max_src_size,\n                            opj_codestream_index_t *p_cstr_index,\n                            opj_event_mgr_t *p_manager\n                            )\n{\n        opj_t2_t * l_t2;\n\n        l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n        if (l_t2 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_t2_decode_packets(\n                                        l_t2,\n                                        p_tcd->tcd_tileno,\n                                        p_tcd->tcd_image->tiles,\n                                        p_src_data,\n                                        p_data_read,\n                                        p_max_src_size,\n                                        p_cstr_index,\n                                        p_manager)) {\n                opj_t2_destroy(l_t2);\n                return OPJ_FALSE;\n        }\n\n        opj_t2_destroy(l_t2);\n\n        /*---------------CLEAN-------------------*/\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t1_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_t1_t * l_t1;\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t* l_tile_comp = l_tile->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n\n\n        l_t1 = opj_t1_create(OPJ_FALSE);\n        if (l_t1 == 00) {\n                return OPJ_FALSE;\n        }\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                /* The +3 is headroom required by the vectorized DWT */\n                if (OPJ_FALSE == opj_t1_decode_cblks(l_t1, l_tile_comp, l_tccp)) {\n                        opj_t1_destroy(l_t1);\n                        return OPJ_FALSE;\n                }\n                ++l_tile_comp;\n                ++l_tccp;\n        }\n\n        opj_t1_destroy(l_t1);\n\n        return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_tcd_dwt_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n        opj_image_comp_t * l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                /*\n                if (tcd->cp->reduce != 0) {\n                        tcd->image->comps[compno].resno_decoded =\n                                tile->comps[compno].numresolutions - tcd->cp->reduce - 1;\n                        if (tcd->image->comps[compno].resno_decoded < 0)\n                        {\n                                return false;\n                        }\n                }\n                numres2decode = tcd->image->comps[compno].resno_decoded + 1;\n                if(numres2decode > 0){\n                */\n\n                if (l_tccp->qmfbid == 1) {\n                        if (! opj_dwt_decode(l_tile_comp, l_img_comp->resno_decoded+1)) {\n                                return OPJ_FALSE;\n                        }\n                }\n                else {\n                        if (! opj_dwt_decode_real(l_tile_comp, l_img_comp->resno_decoded+1)) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                ++l_tile_comp;\n                ++l_img_comp;\n                ++l_tccp;\n        }\n\n        return OPJ_TRUE;\n}\nstatic OPJ_BOOL opj_tcd_mct_decode ( opj_tcd_t *p_tcd, opj_event_mgr_t *p_manager)\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n        opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n        OPJ_UINT32 l_samples,i;\n\n        if (! l_tcp->mct) {\n                return OPJ_TRUE;\n        }\n\n        l_samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n\n        if (l_tile->numcomps >= 3 ){\n                /* testcase 1336.pdf.asan.47.376 */\n                if ((l_tile->comps[0].x1 - l_tile->comps[0].x0) * (l_tile->comps[0].y1 - l_tile->comps[0].y0) < (OPJ_INT32)l_samples ||\n                    (l_tile->comps[1].x1 - l_tile->comps[1].x0) * (l_tile->comps[1].y1 - l_tile->comps[1].y0) < (OPJ_INT32)l_samples ||\n                    (l_tile->comps[2].x1 - l_tile->comps[2].x0) * (l_tile->comps[2].y1 - l_tile->comps[2].y0) < (OPJ_INT32)l_samples) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Tiles don't all have the same dimension. Skip the MCT step.\\n\");\n                        return OPJ_FALSE;\n                }\n                else if (l_tcp->mct == 2) {\n                        OPJ_BYTE ** l_data;\n\n                        if (! l_tcp->m_mct_decoding_matrix) {\n                                return OPJ_TRUE;\n                        }\n\n                        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps*sizeof(OPJ_BYTE*));\n                        if (! l_data) {\n                                return OPJ_FALSE;\n                        }\n\n                        for (i=0;i<l_tile->numcomps;++i) {\n                                l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n                                ++l_tile_comp;\n                        }\n\n                        if (! opj_mct_decode_custom(/* MCT data */\n                                                                        (OPJ_BYTE*) l_tcp->m_mct_decoding_matrix,\n                                                                        /* size of components */\n                                                                        l_samples,\n                                                                        /* components */\n                                                                        l_data,\n                                                                        /* nb of components (i.e. size of pData) */\n                                                                        l_tile->numcomps,\n                                                                        /* tells if the data is signed */\n                                                                        p_tcd->image->comps->sgnd)) {\n                                opj_free(l_data);\n                                return OPJ_FALSE;\n                        }\n\n                        opj_free(l_data);\n                }\n                else {\n                        if (l_tcp->tccps->qmfbid == 1) {\n                                opj_mct_decode(     l_tile->comps[0].data,\n                                                        l_tile->comps[1].data,\n                                                        l_tile->comps[2].data,\n                                                        l_samples);\n                        }\n                        else {\n                            opj_mct_decode_real((OPJ_FLOAT32*)l_tile->comps[0].data,\n                                                (OPJ_FLOAT32*)l_tile->comps[1].data,\n                                                (OPJ_FLOAT32*)l_tile->comps[2].data,\n                                                l_samples);\n                        }\n                }\n        }\n        else {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\\n\",l_tile->numcomps);\n        }\n\n        return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tccp_t * l_tccp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_resolution_t* l_res = 00;\n        opj_tcd_tile_t * l_tile;\n        OPJ_UINT32 l_width,l_height,i,j;\n        OPJ_INT32 * l_current_ptr;\n        OPJ_INT32 l_min, l_max;\n        OPJ_UINT32 l_stride;\n\n        l_tile = p_tcd->tcd_image->tiles;\n        l_tile_comp = l_tile->comps;\n        l_tccp = p_tcd->tcp->tccps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;\n                l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n                l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n                l_stride = (OPJ_UINT32)(l_tile_comp->x1 - l_tile_comp->x0) - l_width;\n\n                assert(l_height == 0 || l_width + l_stride <= l_tile_comp->data_size / l_height); /*MUPDF*/\n\n                if (l_img_comp->sgnd) {\n                        l_min = -(1 << (l_img_comp->prec - 1));\n                        l_max = (1 << (l_img_comp->prec - 1)) - 1;\n                }\n                else {\n            l_min = 0;\n                        l_max = (1 << l_img_comp->prec) - 1;\n                }\n\n                l_current_ptr = l_tile_comp->data;\n\n                if (l_tccp->qmfbid == 1) {\n                        for (j=0;j<l_height;++j) {\n                                for (i = 0; i < l_width; ++i) {\n                                        *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift, l_min, l_max);\n                                        ++l_current_ptr;\n                                }\n                                l_current_ptr += l_stride;\n                        }\n                }\n                else {\n                        for (j=0;j<l_height;++j) {\n                                for (i = 0; i < l_width; ++i) {\n                                        OPJ_FLOAT32 l_value = *((OPJ_FLOAT32 *) l_current_ptr);\n                                        *l_current_ptr = opj_int_clamp((OPJ_INT32)opj_lrintf(l_value) + l_tccp->m_dc_level_shift, l_min, l_max); ;\n                                        ++l_current_ptr;\n                                }\n                                l_current_ptr += l_stride;\n                        }\n                }\n\n                ++l_img_comp;\n                ++l_tccp;\n                ++l_tile_comp;\n        }\n\n        return OPJ_TRUE;\n}\n\n\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_dec_deallocate (opj_tcd_precinct_t * p_precinct)\n{\n        OPJ_UINT32 cblkno , l_nb_code_blocks;\n\n        opj_tcd_cblk_dec_t * l_code_block = p_precinct->cblks.dec;\n        if (l_code_block) {\n                /*fprintf(stderr,\"deallocate codeblock:{\\n\");*/\n                /*fprintf(stderr,\"\\t x0=%d, y0=%d, x1=%d, y1=%d\\n\",l_code_block->x0, l_code_block->y0, l_code_block->x1, l_code_block->y1);*/\n                /*fprintf(stderr,\"\\t numbps=%d, numlenbits=%d, len=%d, numnewpasses=%d, real_num_segs=%d, m_current_max_segs=%d\\n \",\n                                l_code_block->numbps, l_code_block->numlenbits, l_code_block->len, l_code_block->numnewpasses, l_code_block->real_num_segs, l_code_block->m_current_max_segs );*/\n\n\n                l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t);\n                /*fprintf(stderr,\"nb_code_blocks =%d\\t}\\n\", l_nb_code_blocks);*/\n\n                for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\n                        if (l_code_block->data) {\n                                opj_free(l_code_block->data);\n                                l_code_block->data = 00;\n                        }\n\n                        if (l_code_block->segs) {\n                                opj_free(l_code_block->segs );\n                                l_code_block->segs = 00;\n                        }\n\n                        ++l_code_block;\n                }\n\n                opj_free(p_precinct->cblks.dec);\n                p_precinct->cblks.dec = 00;\n        }\n}\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_enc_deallocate (opj_tcd_precinct_t * p_precinct)\n{       \n        OPJ_UINT32 cblkno , l_nb_code_blocks;\n\n        opj_tcd_cblk_enc_t * l_code_block = p_precinct->cblks.enc;\n        if (l_code_block) {\n                l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_enc_t);\n                \n                for     (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno)  {\n                        if (l_code_block->data) {\n                                opj_free(l_code_block->data - 1);\n                                l_code_block->data = 00;\n                        }\n\n                        if (l_code_block->layers) {\n                                opj_free(l_code_block->layers );\n                                l_code_block->layers = 00;\n                        }\n\n                        if (l_code_block->passes) {\n                                opj_free(l_code_block->passes );\n                                l_code_block->passes = 00;\n                        }\n                        ++l_code_block;\n                }\n\n                opj_free(p_precinct->cblks.enc);\n                \n                p_precinct->cblks.enc = 00;\n        }\n}\n\nOPJ_UINT32 opj_tcd_get_encoded_tile_size ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 i,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                l_data_size += l_size_comp * (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return l_data_size;\n}\n                \nstatic OPJ_BOOL opj_tcd_dc_level_shift_encode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tccp_t * l_tccp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tile_t * l_tile;\n        OPJ_UINT32 l_nb_elem,i;\n        OPJ_INT32 * l_current_ptr;\n\n        l_tile = p_tcd->tcd_image->tiles;\n        l_tile_comp = l_tile->comps;\n        l_tccp = p_tcd->tcp->tccps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                l_current_ptr = l_tile_comp->data;\n                l_nb_elem = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n\n                if (l_tccp->qmfbid == 1) {\n                        for     (i = 0; i < l_nb_elem; ++i) {\n                                *l_current_ptr -= l_tccp->m_dc_level_shift ;\n                                ++l_current_ptr;\n                        }\n                }\n                else {\n                        for (i = 0; i < l_nb_elem; ++i) {\n                                *l_current_ptr = (*l_current_ptr - l_tccp->m_dc_level_shift) * (1 << 11);\n                                ++l_current_ptr;\n                        }\n                }\n\n                ++l_img_comp;\n                ++l_tccp;\n                ++l_tile_comp;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_mct_encode ( opj_tcd_t *p_tcd )\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        OPJ_UINT32 samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n        OPJ_UINT32 i;\n        OPJ_BYTE ** l_data = 00;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n\n        if(!p_tcd->tcp->mct) {\n                return OPJ_TRUE;\n        }\n\n        if (p_tcd->tcp->mct == 2) {\n                if (! p_tcd->tcp->m_mct_coding_matrix) {\n                        return OPJ_TRUE;\n                }\n\n        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps*sizeof(OPJ_BYTE*));\n                if (! l_data) {\n                        return OPJ_FALSE;\n                }\n\n                for (i=0;i<l_tile->numcomps;++i) {\n                        l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n                        ++l_tile_comp;\n                }\n\n                if (! opj_mct_encode_custom(/* MCT data */\n                                        (OPJ_BYTE*) p_tcd->tcp->m_mct_coding_matrix,\n                                        /* size of components */\n                                        samples,\n                                        /* components */\n                                        l_data,\n                                        /* nb of components (i.e. size of pData) */\n                                        l_tile->numcomps,\n                                        /* tells if the data is signed */\n                                        p_tcd->image->comps->sgnd) )\n                {\n            opj_free(l_data);\n                        return OPJ_FALSE;\n                }\n\n                opj_free(l_data);\n        }\n        else if (l_tcp->tccps->qmfbid == 0) {\n                opj_mct_encode_real(l_tile->comps[0].data, l_tile->comps[1].data, l_tile->comps[2].data, samples);\n        }\n        else {\n                opj_mct_encode(l_tile->comps[0].data, l_tile->comps[1].data, l_tile->comps[2].data, samples);\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_dwt_encode ( opj_tcd_t *p_tcd )\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n        OPJ_UINT32 compno;\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                if (l_tccp->qmfbid == 1) {\n                        if (! opj_dwt_encode(l_tile_comp)) {\n                                return OPJ_FALSE;\n                        }\n                }\n                else if (l_tccp->qmfbid == 0) {\n                        if (! opj_dwt_encode_real(l_tile_comp)) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                ++l_tile_comp;\n                ++l_tccp;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t1_encode ( opj_tcd_t *p_tcd )\n{\n        opj_t1_t * l_t1;\n        const OPJ_FLOAT64 * l_mct_norms;\n        OPJ_UINT32 l_mct_numcomps = 0U;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n\n        l_t1 = opj_t1_create(OPJ_TRUE);\n        if (l_t1 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (l_tcp->mct == 1) {\n                l_mct_numcomps = 3U;\n                /* irreversible encoding */\n                if (l_tcp->tccps->qmfbid == 0) {\n                        l_mct_norms = opj_mct_get_mct_norms_real();\n                }\n                else {\n                        l_mct_norms = opj_mct_get_mct_norms();\n                }\n        }\n        else {\n                l_mct_numcomps = p_tcd->image->numcomps;\n                l_mct_norms = (const OPJ_FLOAT64 *) (l_tcp->mct_norms);\n        }\n\n        if (! opj_t1_encode_cblks(l_t1, p_tcd->tcd_image->tiles , l_tcp, l_mct_norms, l_mct_numcomps)) {\n        opj_t1_destroy(l_t1);\n                return OPJ_FALSE;\n        }\n\n        opj_t1_destroy(l_t1);\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t2_encode (opj_tcd_t *p_tcd,\n                                                OPJ_BYTE * p_dest_data,\n                                                OPJ_UINT32 * p_data_written,\n                                                OPJ_UINT32 p_max_dest_size,\n                                                opj_codestream_info_t *p_cstr_info )\n{\n        opj_t2_t * l_t2;\n\n        l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n        if (l_t2 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_t2_encode_packets(\n                                        l_t2,\n                                        p_tcd->tcd_tileno,\n                                        p_tcd->tcd_image->tiles,\n                                        p_tcd->tcp->numlayers,\n                                        p_dest_data,\n                                        p_data_written,\n                                        p_max_dest_size,\n                                        p_cstr_info,\n                                        p_tcd->tp_num,\n                                        p_tcd->tp_pos,\n                                        p_tcd->cur_pino,\n                                        FINAL_PASS))\n        {\n                opj_t2_destroy(l_t2);\n                return OPJ_FALSE;\n        }\n\n        opj_t2_destroy(l_t2);\n\n        /*---------------CLEAN-------------------*/\n        return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_tcd_rate_allocate_encode(  opj_tcd_t *p_tcd,\n                                                                            OPJ_BYTE * p_dest_data,\n                                                                            OPJ_UINT32 p_max_dest_size,\n                                                                            opj_codestream_info_t *p_cstr_info )\n{\n        opj_cp_t * l_cp = p_tcd->cp;\n        OPJ_UINT32 l_nb_written = 0;\n\n        if (p_cstr_info)  {\n                p_cstr_info->index_write = 0;\n        }\n\n        if (l_cp->m_specific_param.m_enc.m_disto_alloc|| l_cp->m_specific_param.m_enc.m_fixed_quality)  {\n                /* fixed_quality */\n                /* Normal Rate/distortion allocation */\n                if (! opj_tcd_rateallocate(p_tcd, p_dest_data,&l_nb_written, p_max_dest_size, p_cstr_info)) {\n                        return OPJ_FALSE;\n                }\n        }\n        else {\n                /* Fixed layer allocation */\n                opj_tcd_rateallocate_fixed(p_tcd);\n        }\n\n        return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_copy_tile_data (       opj_tcd_t *p_tcd,\n                                                                    OPJ_BYTE * p_src,\n                                                                    OPJ_UINT32 p_src_length )\n{\n        OPJ_UINT32 i,j,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_UINT32 l_nb_elem;\n\n        l_data_size = opj_tcd_get_encoded_tile_size(p_tcd);\n        if (l_data_size != p_src_length) {\n                return OPJ_FALSE;\n        }\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n                l_nb_elem = (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                switch (l_size_comp) {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_src_ptr = (OPJ_CHAR *) p_src;\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++))&0xff;\n                                                }\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                        case 2:\n                                {\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n                                        OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_src;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++))&0xffff;\n                                                }\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_src;\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n                                        for (j=0;j<l_nb_elem;++j) {\n                                                *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                }\n\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return OPJ_TRUE;\n}\n", "# This file list all the input commands of the tests run by the ctest command which \n# are not related to the conformance files.\n#\n# For each line of this file (except line which begin with #) an opj_compress test or a\n# opj_decompress is run and its related tests.\n#   + For encoder related tests = dump, compare dump to base, decode the encoded file with \n#     reference and compare the decoded file with the baseline decoded previously with \n#     ref decoder.\n#   + For decoder related tests = dump, compare dump to base, (TODO: compare outpout decoding \n#     image to base)\n#\n# Line begin with ! should failed (should be used for bad jpeg2000 file which should be \n# gracefully rejected). Please add a short resume about why this file should be rejected.\n#\n# You can use @INPUT_NR_PATH@ and @TEMP_PATH@ cmake variable which refers to OPJ_DATA_ROOT \n# repository. However you can use relative path or absolute path.\n\n# ENCODER TEST SUITE\nopj_compress -i @INPUT_NR_PATH@/Bretagne1.ppm -o @TEMP_PATH@/Bretagne1_0.j2k -r 200,50,10\nopj_compress -i @INPUT_NR_PATH@/Bretagne1.ppm -o @TEMP_PATH@/Bretagne1_1.j2k -q 30,35,40 -n 2\nopj_compress -i @INPUT_NR_PATH@/Bretagne1.ppm -o @TEMP_PATH@/Bretagne1_2.j2k -q 30,35,40 -b 16,16 -c [64,64]\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_0.j2k -c [128,128],[128,128],[128,128] -r 100,20,2 -t 640,480 -b 32,32\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_1.j2k -t 127,127 -p PCRL\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_2.j2k -s 2,2 -SOP\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_3.j2k -EPH -M 38\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_4.j2k -d 150,300 -r 800\nopj_compress -i @INPUT_NR_PATH@/Cevennes1.bmp -o @TEMP_PATH@/Cevennes1.j2k -r 10\nopj_compress -i @INPUT_NR_PATH@/Cevennes2.ppm -o @TEMP_PATH@/Cevennes2.jp2 -r 50\nopj_compress -i @INPUT_NR_PATH@/Rome.bmp -o @TEMP_PATH@/Rome.jp2 -q 30,35,50 -p LRCP -n 3\n# related to issue 5\nopj_compress -i @INPUT_NR_PATH@/random-issue-0005.tif -o @TEMP_PATH@/random-issue-0005.tif.j2k\n# related to issue 62\nopj_compress -i @INPUT_NR_PATH@/tmp-issue-0062.raw -o @TEMP_PATH@/tmp-issue-0062-u.raw.j2k -F 512,512,1,16,u\nopj_compress -i @INPUT_NR_PATH@/tmp-issue-0062.raw -o @TEMP_PATH@/tmp-issue-0062-s.raw.j2k -F 512,512,1,16,s\nopj_compress -i @INPUT_NR_PATH@/X_4_2K_24_185_CBR_WB_000.tif -o @TEMP_PATH@/X_4_2K_24_185_CBR_WB_000_C2K_24.j2k -cinema2K 24\nopj_compress -i @INPUT_NR_PATH@/X_5_2K_24_235_CBR_STEM24_000.tif -o @TEMP_PATH@/X_5_2K_24_235_CBR_STEM24_000_C2K_24.j2k -cinema2K 24\nopj_compress -i @INPUT_NR_PATH@/X_6_2K_24_FULL_CBR_CIRCLE_000.tif -o @TEMP_PATH@/X_6_2K_24_FULL_CBR_CIRCLE_000_C2K_24.j2k -cinema2K 24\nopj_compress -i @INPUT_NR_PATH@/X_4_2K_24_185_CBR_WB_000.tif -o @TEMP_PATH@/X_4_2K_24_185_CBR_WB_000_C2K_48.j2k -cinema2K 48\nopj_compress -i @INPUT_NR_PATH@/X_5_2K_24_235_CBR_STEM24_000.tif -o @TEMP_PATH@/X_5_2K_24_235_CBR_STEM24_000_C2K_48.j2k -cinema2K 48\nopj_compress -i @INPUT_NR_PATH@/X_6_2K_24_FULL_CBR_CIRCLE_000.tif -o @TEMP_PATH@/X_6_2K_24_FULL_CBR_CIRCLE_000_C2K_48.j2k -cinema2K 48\nopj_compress -i @INPUT_NR_PATH@/ElephantDream_4K.tif -o @TEMP_PATH@/ElephantDream_4K_C4K.j2k -cinema4K\n# issue 141\nopj_compress -i @INPUT_NR_PATH@/issue141.rawl -o @TEMP_PATH@/issue141.rawl.j2k   -F 2048,32,1,16,u\nopj_compress -i @INPUT_NR_PATH@/issue141.rawl -o @TEMP_PATH@/issue141-I.rawl.j2k -F 2048,32,1,16,u -I\n# issue 46:\nopj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_5.j2k -c [64,64]\n# issue 316\nopj_compress -i @INPUT_NR_PATH@/issue316.png -o @TEMP_PATH@/issue316.png.jp2\n# issue 416 (cdef for png with alpha) + issue 436 (MCT norm read buffer overflow for num comp > 3 + Issue 215 number of decomp levels\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn6a08.png -o @TEMP_PATH@/basn6a08.png.jp2 -n 6\n# issue 203 BMP Files not handled properly\nopj_compress -i @INPUT_NR_PATH@/issue203-8bpp-width1.bmp -o @TEMP_PATH@/issue203-8bpp-width1.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-rle8.bmp -o @TEMP_PATH@/issue203-rle8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-y8.bmp -o @TEMP_PATH@/issue203-32x32-y8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-33x33-y8.bmp -o @TEMP_PATH@/issue203-33x33-y8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-34x34-y8.bmp -o @TEMP_PATH@/issue203-34x34-y8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-35x35-y8.bmp -o @TEMP_PATH@/issue203-35x35-y8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgr.bmp -o @TEMP_PATH@/issue203-32x32-bgr.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-33x33-bgr.bmp -o @TEMP_PATH@/issue203-33x33-bgr.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-34x34-bgr.bmp -o @TEMP_PATH@/issue203-34x34-bgr.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-35x35-bgr.bmp -o @TEMP_PATH@/issue203-35x35-bgr.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-y-rle8.bmp -o @TEMP_PATH@/issue203-32x32-y-rle8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgr-rle8.bmp -o @TEMP_PATH@/issue203-32x32-bgr-rle8.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-y-rle4.bmp -o @TEMP_PATH@/issue203-32x32-y-rle4.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgr-rle4.bmp -o @TEMP_PATH@/issue203-32x32-bgr-rle4.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgra.bmp -o @TEMP_PATH@/issue203-32x32-bgra.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgrx.bmp -o @TEMP_PATH@/issue203-32x32-bgrx.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgr16.bmp -o @TEMP_PATH@/issue203-32x32-bgr16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-33x33-bgr16.bmp -o @TEMP_PATH@/issue203-33x33-bgr16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgra16.bmp -o @TEMP_PATH@/issue203-32x32-bgra16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-33x33-bgra16.bmp -o @TEMP_PATH@/issue203-33x33-bgra16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-32x32-bgrx16.bmp -o @TEMP_PATH@/issue203-32x32-bgrx16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-33x33-bgrx16.bmp -o @TEMP_PATH@/issue203-33x33-bgrx16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-127x64-bgr16.bmp -o @TEMP_PATH@/issue203-127x64-bgr16.bmp.jp2\nopj_compress -i @INPUT_NR_PATH@/issue203-127x64-bgrx.bmp -o @TEMP_PATH@/issue203-127x64-bgrx.bmp.jp2\n\n# issue 322 limited tif support \nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-01.tif -o @TEMP_PATH@/flower-minisblack-01.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-02.tif -o @TEMP_PATH@/flower-minisblack-02.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-04.tif -o @TEMP_PATH@/flower-minisblack-04.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-06.tif -o @TEMP_PATH@/flower-minisblack-06.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-08.tif -o @TEMP_PATH@/flower-minisblack-08.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-10.tif -o @TEMP_PATH@/flower-minisblack-10.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-12.tif -o @TEMP_PATH@/flower-minisblack-12.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-14.tif -o @TEMP_PATH@/flower-minisblack-14.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-16.tif -o @TEMP_PATH@/flower-minisblack-16.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-02.tif -o @TEMP_PATH@/flower-rgb-contig-02.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-04.tif -o @TEMP_PATH@/flower-rgb-contig-04.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-08.tif -o @TEMP_PATH@/flower-rgb-contig-08.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-10.tif -o @TEMP_PATH@/flower-rgb-contig-10.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-12.tif -o @TEMP_PATH@/flower-rgb-contig-12.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-14.tif -o @TEMP_PATH@/flower-rgb-contig-14.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-contig-16.tif -o @TEMP_PATH@/flower-rgb-contig-16.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-02.tif -o @TEMP_PATH@/flower-rgb-planar-02.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-04.tif -o @TEMP_PATH@/flower-rgb-planar-04.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-08.tif -o @TEMP_PATH@/flower-rgb-planar-08.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-10.tif -o @TEMP_PATH@/flower-rgb-planar-10.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-12.tif -o @TEMP_PATH@/flower-rgb-planar-12.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-14.tif -o @TEMP_PATH@/flower-rgb-planar-14.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-rgb-planar-16.tif -o @TEMP_PATH@/flower-rgb-planar-16.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/basn6a08.tif -o @TEMP_PATH@/basn6a08.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/basn4a08.tif -o @TEMP_PATH@/basn4a08.tif.jp2\n\n# issue 536 (PNG images are always read as RGB(A) images) + issue 264 (convert.c is unmaintainable)\n# Test all images from pngsuite\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn0g01.png -o @TEMP_PATH@/basn0g01.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn0g02.png -o @TEMP_PATH@/basn0g02.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn0g04.png -o @TEMP_PATH@/basn0g04.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn0g08.png -o @TEMP_PATH@/basn0g08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn0g16.png -o @TEMP_PATH@/basn0g16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn2c08.png -o @TEMP_PATH@/basn2c08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn2c16.png -o @TEMP_PATH@/basn2c16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn3p01.png -o @TEMP_PATH@/basn3p01.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn3p02.png -o @TEMP_PATH@/basn3p02.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn3p04.png -o @TEMP_PATH@/basn3p04.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn3p08.png -o @TEMP_PATH@/basn3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn4a08.png -o @TEMP_PATH@/basn4a08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn4a16.png -o @TEMP_PATH@/basn4a16.png.jp2\n# already done opj_compress -i @INPUT_NR_PATH@/pngsuite/basn6a08.png -o @TEMP_PATH@/basn6a08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/basn6a16.png -o @TEMP_PATH@/basn6a16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbbn0g01.png -o @TEMP_PATH@/ftbbn0g01.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbbn0g02.png -o @TEMP_PATH@/ftbbn0g02.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbbn0g04.png -o @TEMP_PATH@/ftbbn0g04.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbbn2c16.png -o @TEMP_PATH@/ftbbn2c16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbbn3p08.png -o @TEMP_PATH@/ftbbn3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbgn2c16.png -o @TEMP_PATH@/ftbgn2c16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbgn3p08.png -o @TEMP_PATH@/ftbgn3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbrn2c08.png -o @TEMP_PATH@/ftbrn2c08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbwn0g16.png -o @TEMP_PATH@/ftbwn0g16.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbwn3p08.png -o @TEMP_PATH@/ftbwn3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftbyn3p08.png -o @TEMP_PATH@/ftbyn3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftp0n0g08.png -o @TEMP_PATH@/ftp0n0g08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftp0n2c08.png -o @TEMP_PATH@/ftp0n2c08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftp0n3p08.png -o @TEMP_PATH@/ftp0n3p08.png.jp2\nopj_compress -i @INPUT_NR_PATH@/pngsuite/ftp1n3p08.png -o @TEMP_PATH@/ftp1n3p08.png.jp2\n\n# issue 571 Lossless is not lossless on linux x86\nopj_compress -i @INPUT_NR_PATH@/issue571.tif -o @TEMP_PATH@/issue571.tif.j2k\n\n# issue 729 Allow to read 3/5/7/9/11/13/15 bpp tif files \nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-03.tif -o @TEMP_PATH@/flower-minisblack-03.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-05.tif -o @TEMP_PATH@/flower-minisblack-05.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-07.tif -o @TEMP_PATH@/flower-minisblack-07.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-09.tif -o @TEMP_PATH@/flower-minisblack-09.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-11.tif -o @TEMP_PATH@/flower-minisblack-11.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-13.tif -o @TEMP_PATH@/flower-minisblack-13.tif.jp2\nopj_compress -i @INPUT_NR_PATH@/flower-minisblack-15.tif -o @TEMP_PATH@/flower-minisblack-15.tif.jp2\n\n\n# DECODER TEST SUITE\nopj_decompress -i  @INPUT_NR_PATH@/Bretagne2.j2k -o @TEMP_PATH@/Bretagne2.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/_00042.j2k -o @TEMP_PATH@/_00042.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/123.j2c -o @TEMP_PATH@/123.j2c.pgx\n# The 4 following tests should failed (kakadu indicates that they are corrupted)\n!opj_decompress -i  @INPUT_NR_PATH@/broken1.jp2 -o @TEMP_PATH@/broken1.jp2.pgx\n!opj_decompress -i  @INPUT_NR_PATH@/broken2.jp2 -o @TEMP_PATH@/broken2.jp2.pgx\n!opj_decompress -i  @INPUT_NR_PATH@/broken3.jp2 -o @TEMP_PATH@/broken3.jp2.pgx\n!opj_decompress -i  @INPUT_NR_PATH@/broken4.jp2 -o @TEMP_PATH@/broken4.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/bug.j2c -o @TEMP_PATH@/bug.j2c.pgx\nopj_decompress -i  @INPUT_NR_PATH@/buxI.j2k -o @TEMP_PATH@/buxI.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/buxR.j2k -o @TEMP_PATH@/buxR.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/Cannotreaddatawithnosizeknown.j2k -o @TEMP_PATH@/Cannotreaddatawithnosizeknown.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/cthead1.j2k -o @TEMP_PATH@/cthead1.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/CT_Phillips_JPEG2K_Decompr_Problem.j2k -o @TEMP_PATH@/CT_Phillips_JPEG2K_Decompr_Problem.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/illegalcolortransform.j2k -o @TEMP_PATH@/illegalcolortransform.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/j2k32.j2k -o @TEMP_PATH@/j2k32.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/kakadu_v4-4_openjpegv2_broken.j2k -o @TEMP_PATH@/kakadu_v4-4_openjpegv2_broken.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/MarkerIsNotCompliant.j2k -o @TEMP_PATH@/MarkerIsNotCompliant.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/Marrin.jp2 -o @TEMP_PATH@/Marrin.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/merged.jp2 -o @TEMP_PATH@/merged.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/movie_00000.j2k -o @TEMP_PATH@/movie_00000.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/movie_00001.j2k -o @TEMP_PATH@/movie_00001.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/movie_00002.j2k -o @TEMP_PATH@/movie_00002.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/orb-blue10-lin-j2k.j2k -o @TEMP_PATH@/orb-blue10-lin-j2k.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/orb-blue10-lin-jp2.jp2 -o @TEMP_PATH@/orb-blue10-lin-jp2.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/orb-blue10-win-j2k.j2k -o @TEMP_PATH@/orb-blue10-win-j2k.j2k.pgx\nopj_decompress -i  @INPUT_NR_PATH@/orb-blue10-win-jp2.jp2 -o @TEMP_PATH@/orb-blue10-win-jp2.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/relax.jp2 -o @TEMP_PATH@/relax.jp2.pgx\nopj_decompress -i  @INPUT_NR_PATH@/test_lossless.j2k -o @TEMP_PATH@/test_lossless.j2k.pgx\n# text_GBR.jp2 file exhibt a error about a tile part with a index > of the number of tile-part in this tile (related to issue 202, 206, 208)\nopj_decompress -i  @INPUT_NR_PATH@/text_GBR.jp2 -o @TEMP_PATH@/text_GBR.jp2.pgx\n# pacs.ge file should throw an error but finally it seems work with v2\nopj_decompress -i  @INPUT_NR_PATH@/pacs.ge.j2k -o @TEMP_PATH@/pacs.ge.j2k.pgx\n# related to issue 135 \nopj_decompress -i  @INPUT_NR_PATH@/kodak_2layers_lrcp.j2c -o @TEMP_PATH@/kodak_2layers_lrcp.j2c.pgx\nopj_decompress -i  @INPUT_NR_PATH@/kodak_2layers_lrcp.j2c -o @TEMP_PATH@/kodak_2layers_lrcp-l2.j2c.pgx -l 2\n# related to issue 104 and 110\nopj_decompress -i  @INPUT_NR_PATH@/issue104_jpxstream.jp2 -o @TEMP_PATH@/issue104_jpxstream.jp2.pgx\n# File not supported by kakadu (Malformed PCLR box) and not supoprter by openjpeg (problem with value of TPSot)\n!opj_decompress -i  @INPUT_NR_PATH@/mem-b2ace68c-1381.jp2 -o @TEMP_PATH@/mem-b2ace68c-1381.jp2.pgx\n# File which produced weird output with kakadu and not supoprter by openjpeg (problem with value of TPSot, issue 202, 206, 208)\nopj_decompress -i  @INPUT_NR_PATH@/mem-b2b86b74-2753.jp2 -o @TEMP_PATH@/mem-b2b86b74-2753.jp2.pgx\n# issue 191 raised by the gdal fuzzer test (should properly failed)\n!opj_decompress -i  @INPUT_NR_PATH@/gdal_fuzzer_unchecked_numresolutions.jp2 -o @TEMP_PATH@/gdal_fuzzer_unchecked_numresolutions.pgx\n# issue 192 raised by the gdal fuzzer test (should nicely failed)\n! opj_decompress -i  @INPUT_NR_PATH@/gdal_fuzzer_assert_in_opj_j2k_read_SQcd_SQcc.patch.jp2 -o @TEMP_PATH@/gdal_fuzzer_assert_in_opj_j2k_read_SQcd_SQcc.patch.pgx\n# issue 193 raised by the gdal fuzzer test (should nicely failed)\n!opj_decompress -i  @INPUT_NR_PATH@/gdal_fuzzer_check_number_of_tiles.jp2 -o @TEMP_PATH@/gdal_fuzzer_check_number_of_tiles.pgx\n# issue 194 raised by the gdal fuzzer test (should nicely failed)\n! opj_decompress -i  @INPUT_NR_PATH@/gdal_fuzzer_check_comp_dx_dy.jp2 -o @TEMP_PATH@/gdal_fuzzer_check_comp_dx_dy.pgx\n# issue 202 \nopj_decompress -i  @INPUT_NR_PATH@/file409752.jp2 -o @TEMP_PATH@/file409752.jp2.pgx\n# issue 188 \nopj_decompress -i  @INPUT_NR_PATH@/issue188_beach_64bitsbox.jp2 -o @TEMP_PATH@/issue188_beach_64bitsbox.jp2.pgx\n# issue 206\nopj_decompress -i  @INPUT_NR_PATH@/issue206_image-000.jp2 -o @TEMP_PATH@/issue206_image-000.jp2.pgx\n# issue 205\nopj_decompress -i  @INPUT_NR_PATH@/issue205.jp2 -o @TEMP_PATH@/issue205.jp2.pgx\n# issue 225 (sumatrapdf)\n!opj_decompress -i @INPUT_NR_PATH@/451.pdf.SIGSEGV.5b5.3723.jp2  -o @TEMP_PATH@/451.pdf.SIGSEGV.5b5.3723.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/1888.pdf.asan.35.988.jp2      -o @TEMP_PATH@/1888.pdf.asan.35.988.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/2539.pdf.SIGFPE.706.1712.jp2  -o @TEMP_PATH@/2539.pdf.SIGFPE.706.1712.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/2236.pdf.SIGSEGV.398.1376.jp2 -o @TEMP_PATH@/2236.pdf.SIGSEGV.398.1376.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/1336.pdf.asan.47.376.jp2      -o @TEMP_PATH@/1336.pdf.asan.47.376.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/1851.pdf.SIGSEGV.ce9.948.jp2  -o @TEMP_PATH@/1851.pdf.SIGSEGV.ce9.948.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/4149.pdf.SIGSEGV.cf7.3501.jp2 -o @TEMP_PATH@/4149.pdf.SIGSEGV.cf7.3501.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/4035.pdf.SIGSEGV.d8b.3375.jp2 -o @TEMP_PATH@/4035.pdf.SIGSEGV.d8b.3375.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/2977.pdf.asan.67.2198.jp2     -o @TEMP_PATH@/2977.pdf.asan.67.2198.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/451.pdf.SIGSEGV.ce9.3723.jp2  -o @TEMP_PATH@/451.pdf.SIGSEGV.ce9.3723.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/3635.pdf.asan.77.2930.jp2     -o @TEMP_PATH@/3635.pdf.asan.77.2930.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/1802.pdf.SIGSEGV.36e.894.jp2  -o @TEMP_PATH@/1802.pdf.SIGSEGV.36e.894.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/451.pdf.SIGSEGV.f4c.3723.jp2  -o @TEMP_PATH@/451.pdf.SIGSEGV.f4c.3723.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/2.pdf.SIGFPE.706.1112.jp2     -o @TEMP_PATH@/2.pdf.SIGFPE.706.1112.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/147af3f1083de4393666b7d99b01b58b_signal_sigsegv_130c531_6155_5136.jp2 -o @TEMP_PATH@/147af3f1083de4393666b7d99b01b58b_signal_sigsegv_130c531_6155_5136.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/4241ac039aba57e6a9c948d519d94216_asan_heap-oob_14650f2_7469_602.jp2 -o @TEMP_PATH@/4241ac039aba57e6a9c948d519d94216_asan_heap-oob_14650f2_7469_602.jp2\n# issue 228 (16bits/lossy)\nopj_decompress -i @INPUT_NR_PATH@/issue228.j2k                  -o @TEMP_PATH@/issue228.j2k.pgx\n# issue 229\n!opj_decompress -i @INPUT_NR_PATH@/27ac957758a35d00d6765a0c86350d9c.SIGFPE.d25.537.jpc -o @TEMP_PATH@27ac957758a35d00d6765a0c86350d9c.SIGFPE.d25.537.jpc.pgx\n!opj_decompress -i @INPUT_NR_PATH@/26ccf3651020967f7778238ef5af08af.SIGFPE.d25.527.jp2 -o @TEMP_PATH@26ccf3651020967f7778238ef5af08af.SIGFPE.d25.527.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/0290cb77c5df21828fa74cf2ab2c84d8.SIGFPE.d25.31.jp2  -o @TEMP_PATH@0290cb77c5df21828fa74cf2ab2c84d8.SIGFPE.d25.31.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/3672da2f1f67bbecad27d7181b4e9d7c.SIGFPE.d25.805.jpc -o @TEMP_PATH@3672da2f1f67bbecad27d7181b4e9d7c.SIGFPE.d25.805.jpc.pgx\n# issue 254 (loss in quality)\nopj_decompress -i @INPUT_NR_PATH@/issue254.jp2                  -o @TEMP_PATH@/issue254.jp2.pgx\n# issue 142\nopj_decompress -i @INPUT_NR_PATH@/issue142.j2k                  -o @TEMP_PATH@/issue142.j2k.pgx\n# issue 134\nopj_decompress -i @INPUT_NR_PATH@/issue134.jp2                  -o @TEMP_PATH@/issue134.jp2.pgx\n# issue 135\nopj_decompress -i @INPUT_NR_PATH@/issue135.j2k                  -o @TEMP_PATH@/issue135.j2k.pgx\n# issue 208\nopj_decompress -i @INPUT_NR_PATH@/issue208.jp2                  -o @TEMP_PATH@/issue208.jp2.pgx\n# issue 211\nopj_decompress -i @INPUT_NR_PATH@/issue211.jp2                  -o @TEMP_PATH@/issue211.jp2.pgx\n# issue 171\nopj_decompress -i @INPUT_NR_PATH@/issue171.jp2                  -o @TEMP_PATH@/issue171.jp2.pgx\n# issue 171\n!opj_decompress -i @INPUT_NR_PATH@/issue165.jp2                  -o @TEMP_PATH@/issue165.jp2.pgx\n#\n!opj_decompress -i @INPUT_NR_PATH@/broken.jpc                    -o @TEMP_PATH@/broken.jpc.pgx\n# issue 226\nopj_decompress -i @INPUT_NR_PATH@/issue226.j2k                   -o @TEMP_PATH@/issue226.j2k.pgx\n# issue 297\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1103421.jp2  -o @TEMP_PATH@/edf_c2_1103421.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1178956.jp2  -o @TEMP_PATH@/edf_c2_1178956.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1000290.jp2  -o @TEMP_PATH@/edf_c2_1000290.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1000691.jp2  -o @TEMP_PATH@/edf_c2_1000691.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_20.jp2       -o @TEMP_PATH@/edf_c2_20.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1377017.jp2  -o @TEMP_PATH@/edf_c2_1377017.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1002767.jp2  -o @TEMP_PATH@/edf_c2_1002767.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_10025.jp2    -o @TEMP_PATH@/edf_c2_10025.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1000234.jp2  -o @TEMP_PATH@/edf_c2_1000234.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_225881.jp2   -o @TEMP_PATH@/edf_c2_225881.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1000671.jp2  -o @TEMP_PATH@/edf_c2_1000671.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1013627.jp2  -o @TEMP_PATH@/edf_c2_1013627.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1015644.jp2  -o @TEMP_PATH@/edf_c2_1015644.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_101463.jp2   -o @TEMP_PATH@/edf_c2_101463.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1674177.jp2  -o @TEMP_PATH@/edf_c2_1674177.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/edf_c2_1673169.jp2  -o @TEMP_PATH@/edf_c2_1673169.jp2.pgx\n# issue 296\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.78.2734.0.jp2 -o @TEMP_PATH@/3459.pdf.asan.78.2734.0.jp2.pgx\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.78.2734.1.jp2 -o @TEMP_PATH@/3459.pdf.asan.78.2734.1.jp2.pgx\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.78.2734.2.jp2 -o @TEMP_PATH@/3459.pdf.asan.78.2734.2.jp2.pgx\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.6c.2734.0.jp2 -o @TEMP_PATH@/3459.pdf.asan.6c.2734.0.jp2.pgx\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.6c.2734.1.jp2 -o @TEMP_PATH@/3459.pdf.asan.6c.2734.1.jp2.pgx\n#!opj_decompress -i @INPUT_NR_PATH@/3459.pdf.asan.6c.2734.2.jp2 -o @TEMP_PATH@/3459.pdf.asan.6c.2734.2.jp2.pgx\n# issue 362 (from pdfium fuzz engine)\n# Invalid PPM Marker\n!opj_decompress -i @INPUT_NR_PATH@/issue362-2863.jp2 -o @TEMP_PATH@/issue362-2863.jp2.pgx\n# Invalid ftyp box size\n!opj_decompress -i @INPUT_NR_PATH@/issue362-2866.jp2 -o @TEMP_PATH@/issue362-2866.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/issue362-2894.jp2 -o @TEMP_PATH@/issue362-2894.jp2.pgx\n# issue 363  (from pdfium fuzz engine)\n# Invalid Tile part length\n!opj_decompress -i @INPUT_NR_PATH@/issue363-4723.jp2 -o @TEMP_PATH@/issue363-4723.jp2.pgx\n# Invalid Marker length\n!opj_decompress -i @INPUT_NR_PATH@/issue363-4740.jp2 -o @TEMP_PATH@/issue363-4740.jp2.pgx\n!opj_decompress -i @INPUT_NR_PATH@/issue363-4792.jp2 -o @TEMP_PATH@/issue363-4792.jp2.pgx\n# issue 390  (from pdfium fuzz engine) Invalid segment size\n!opj_decompress -i @INPUT_NR_PATH@/issue390.jp2 -o @TEMP_PATH@/issue390.jp2.pgx\n# issue 391  (from pdfium fuzz engine) Invalid segment size\n!opj_decompress -i @INPUT_NR_PATH@/issue391.jp2 -o @TEMP_PATH@/issue391.jp2.pgx\n# issue 400  (from pdfium fuzz engine) Unknown Scod value in COD marker\n!opj_decompress -i @INPUT_NR_PATH@/issue400.jp2 -o @TEMP_PATH@/issue400.jp2.pgx\n# issue 413  (from pdfium fuzz engine) Unknown progression order in COD marker\n!opj_decompress -i @INPUT_NR_PATH@/issue413.jp2 -o @TEMP_PATH@/issue413.jp2.pgx\n# issue 364 (from pdfium fuzz engine)\n# Inconsistent box length for jp2 box\n!opj_decompress -i @INPUT_NR_PATH@/issue364-38.jp2 -o @TEMP_PATH@/issue364-38.jp2.pgx\n# No ihdr box\n!opj_decompress -i @INPUT_NR_PATH@/issue364-903.jp2 -o @TEMP_PATH@/issue364-903.jp2.pgx\n# issue 393  (from pdfium fuzz engine) Zppm found twice\n!opj_decompress -i @INPUT_NR_PATH@/issue393.jp2 -o @TEMP_PATH@/issue393.jp2.pgx\n# issue 395  (from pdfium fuzz engine) Stream too short\n!opj_decompress -i @INPUT_NR_PATH@/issue395.jp2 -o @TEMP_PATH@/issue395.jp2.pgx\n# issue 397  (from pdfium fuzz engine) Incomplete channel definitions.\n!opj_decompress -i @INPUT_NR_PATH@/issue397.jp2 -o @TEMP_PATH@/issue397.jp2.pgx\n# issue 399  (from pdfium fuzz engine) Incomplete channel definitions.\nopj_decompress -i @INPUT_NR_PATH@/issue399.j2k -o @TEMP_PATH@/issue399.j2k.pgx\n# issue 408  (from pdfium fuzz engine) No COD marker in main j2k header.\n!opj_decompress -i @INPUT_NR_PATH@/issue408.jp2 -o @TEMP_PATH@/issue408.jp2.pgx\n# issue 412 Palette image with cdef fails to decompress.\nopj_decompress -i @INPUT_NR_PATH@/issue412.jp2 -o @TEMP_PATH@/issue412.jp2.pgx\n# issue 428 Palette image with cdef fails to decompress properly.\nopj_decompress -i @INPUT_NR_PATH@/issue412.jp2 -o @TEMP_PATH@/issue428.jp2.pgx -t 0\n# issue 414 Image with per channel alpha (cdef) does not decode properly.\nopj_decompress -i @INPUT_NR_PATH@/issue414.jp2 -o @TEMP_PATH@/issue414.jp2.pgx\n# issue 418 (from pdfium fuzz engine) Tile part length size inconsistent with stream length.\n!opj_decompress -i @INPUT_NR_PATH@/issue418.jp2 -o @TEMP_PATH@/issue418.jp2.pgx\n# issue 420 (from pdfium fuzz engine) Illegal custom precinct exponent.\n!opj_decompress -i @INPUT_NR_PATH@/issue420.jp2 -o @TEMP_PATH@/issue420.jp2.pgx\n# issue 422 (rework of issue 411). ycc with odd width/height\nopj_decompress -i @INPUT_NR_PATH@/issue411-ycc444.jp2 -o @TEMP_PATH@/issue411-ycc444.jp2.pgx\nopj_decompress -i @INPUT_NR_PATH@/issue411-ycc422.jp2 -o @TEMP_PATH@/issue411-ycc422.jp2.pgx\nopj_decompress -i @INPUT_NR_PATH@/issue411-ycc420.jp2 -o @TEMP_PATH@/issue411-ycc420.jp2.pgx\n# issue 429 (from pdfium fuzz engine) 0 entries in PCLR box.\n!opj_decompress -i @INPUT_NR_PATH@/issue429.jp2 -o @TEMP_PATH@/issue429.jp2.pgx\n# issue 432 (from pdfium fuzz engine) Overflow in tcd tilec data size computation.\n!opj_decompress -i @INPUT_NR_PATH@/issue432.jp2 -o @TEMP_PATH@/issue432.jp2.pgx\n# issue 427 image width is 0\n!opj_decompress -i @INPUT_NR_PATH@/issue427-null-image-size.jp2 -o @TEMP_PATH@/issue427-null-image-size.jp2.pgx\n# issue 427 illegal tile offset\n!opj_decompress -i @INPUT_NR_PATH@/issue427-illegal-tile-offset.jp2 -o @TEMP_PATH@/issue427-illegal-tile-offset.jp2.pgx\n# issue 458 component precision upscaling\nopj_decompress -i @INPUT_NR_PATH@/issue458.jp2 -o @TEMP_PATH@/issue458.jp2.pgx\n# issue 476 Multiple COD in MH\n!opj_decompress -i @INPUT_NR_PATH@/issue476.jp2 -o @TEMP_PATH@/issue476.jp2.pgx\n# issue 475 Invalid number of layers\n!opj_decompress -i @INPUT_NR_PATH@/issue475.jp2 -o @TEMP_PATH@/issue475.jp2.pgx\n# issue 495 Overflow op_image_comp_header_updat\nopj_decompress -i @INPUT_NR_PATH@/issue495.jp2 -o @TEMP_PATH@/issue495.jp2.pgx\n\n\n# decode with specific area\n# prec=12; nb_c=1 \nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04.j2k.png -d 0,0,1024,1024\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_1.j2k.png -d 512,640,640,768\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_2.j2k.png -d 896,896,1024,1024\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_3.j2k.png -d 100,500,300,800\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_4.j2k.png -d 260,520,360,600\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_5.j2k.png -d 260,520,360,660\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_6.j2k.png -d 360,520,400,600\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_10.j2k.png -d 0,0,1024,1024 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_11.j2k.png -d 512,640,640,768 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_12.j2k.png -d 896,896,1024,1024 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_13.j2k.png -d 100,500,300,800 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_14.j2k.png -d 260,520,360,600 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_15.j2k.png -d 260,520,360,660 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_16.j2k.png -d 360,520,400,600 -r 2\n\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_17_t63.j2k.png -t 63 \nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_17_t63_r2.j2k.png -t 63 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_18.t12.j2k.png -t 12 \nopj_decompress -i @INPUT_CONF_PATH@/p1_04.j2k -o @TEMP_PATH@/p1_04_19_t12_r1.j2k.png -t 12 -r 1\n\n# prec=8; nb_c=3 \nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06.j2k.png -d 0,0,12,12\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_1.j2k.png -d 1,8,8,11\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_2.j2k.png -d 9,9,12,12\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_3.j2k.png -d 10,4,12,10\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_4.j2k.png -d 3,3,9,9\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_5.j2k.png -d 4,4,7,7\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_6.j2k.png -d 4,4,5,5\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7.j2k.png -d 0,0,12,12 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_1.j2k.png -d 1,8,8,11 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_2.j2k.png -d 9,9,12,12 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_3.j2k.png -d 10,4,12,10 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_4.j2k.png -d 3,3,9,9 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_5.j2k.png -d 4,4,7,7 -r 1\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_7_6.j2k.png -d 4,4,5,5 -r 1\n\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_8_6.j2k.png -d 9,9,12,12 -r 2\n\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_9.j2k.png -t 0\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_9_1.j2k.png -t 5\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_9_2.j2k.png -t 9\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_9_3.j2k.png -t 15\n\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_10.j2k.png -t 0 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_10_1.j2k.png -t 5 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_10_2.j2k.png -t 9 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_10_3.j2k.png -t 15 -r 2\n\nopj_decompress -i @INPUT_CONF_PATH@/p1_06.j2k -o @TEMP_PATH@/p1_06_11.j2k.png -r 4\n\n# prec=4; nb_c=3 ; signd=yes\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04.j2k.png -d 0,0,256,256\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_1.j2k.png -d 128,0,256,128\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_2.j2k.png -d 50,10,120,200\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_3.j2k.png -d 10,150,190,210\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_4.j2k.png -d 100,80,200,150\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_5.j2k.png -d 150,20,200,50\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6.j2k.png -d 0,0,256,256 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6_1.j2k.png -d 128,0,256,128 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6_2.j2k.png -d 50,10,120,200 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6_3.j2k.png -d 10,150,190,210  -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6_4.j2k.png -d 100,80,200,150 -r 2\nopj_decompress -i @INPUT_CONF_PATH@/p0_04.j2k -o @TEMP_PATH@/p0_04_6_5.j2k.png -d 150,20,200,50 -r 2\n\n# prec=8; nb_c=1 ; non standard origin (image offset and tile offset); sample sep: 2x1\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01.j2k.png -d 5,128,127,226\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01_1.j2k.png -d 5,128,122,99\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01_2.j2k.png -d 50,10,120,200\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01_3.j2k.png -d 10,150,190,210\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01_4.j2k.png -d 100,80,200,150\n#opj_decompress -i @INPUT_CONF_PATH@/p1_01.j2k -o @TEMP_PATH@/p1_01_5.j2k.png -d 150,20,200,50\n\n# issue 322 limited tif support\n# GRAYSCALE \nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-1.tif -p 1S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-2.tif -p 2S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-4.tif -p 4S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-6.tif -p 6S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-8.tif -p 8S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-10.tif -p 10S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-12.tif -p 12S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-14.tif -p 14S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-16.tif -p 16S\n# GRAYSCALE ALPHA\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-1.tif -p 1S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-2.tif -p 2S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-4.tif -p 4S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-6.tif -p 6S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-8.tif -p 8S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-10.tif -p 10S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-12.tif -p 12S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-14.tif -p 14S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-16.tif -p 16S\n# RGB\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-1.tif -p 1S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-2.tif -p 2S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-4.tif -p 4S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-6.tif -p 6S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-8.tif -p 8S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-10.tif -p 10S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-12.tif -p 12S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-14.tif -p 14S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-16.tif -p 16S\n# RGBA\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-1.tif -p 1S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-2.tif -p 2S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-4.tif -p 4S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-6.tif -p 6S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-8.tif -p 8S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-10.tif -p 10S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-12.tif -p 12S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-14.tif -p 14S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-16.tif -p 16S\n\n#issue 235 CMAP outside jp2h box. CMAP is buggy\nopj_decompress -i @INPUT_NR_PATH@/issue235.jp2 -o @TEMP_PATH@/issue235.jp2.pgx\n\n# issue 264, add checks for png\n# GRAYSCALE \nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-1.png -p 1S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-2.png -p 2S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-4.png -p 4S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-6.png -p 6S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-8.png -p 8S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-10.png -p 10S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-12.png -p 12S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-14.png -p 14S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_png-16.png -p 16S\n# GRAYSCALE ALPHA\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-1.png -p 1S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-2.png -p 2S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-4.png -p 4S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-6.png -p 6S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-8.png -p 8S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-10.png -p 10S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-12.png -p 12S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-14.png -p 14S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_png-16.png -p 16S\n# RGB\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-1.png -p 1S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-2.png -p 2S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-4.png -p 4S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-6.png -p 6S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-8.png -p 8S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-10.png -p 10S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-12.png -p 12S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-14.png -p 14S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_png-16.png -p 16S\n# RGBA\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-1.png -p 1S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-2.png -p 2S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-4.png -p 4S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-6.png -p 6S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-8.png -p 8S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-10.png -p 10S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-12.png -p 12S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-14.png -p 14S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_png-16.png -p 16S\n\n# issue 388\n!opj_decompress -i @INPUT_NR_PATH@/v4dwt_interleave_h.gsr105.j2k -o @TEMP_PATH@/v4dwt_interleave_h.gsr105.j2k.pgx\nopj_decompress -i @INPUT_NR_PATH@/dwt_interleave_h.gsr105.jp2 -o @TEMP_PATH@/dwt_interleave_h.gsr105.jp2.pgx\n\n# PR 559 : CMYK tif output\nopj_decompress -i @INPUT_NR_PATH@/issue205.jp2 -o @TEMP_PATH@/issue205-tif.jp2.tif\n\n# issue 236: esYCC colorspace\nopj_decompress -i @INPUT_NR_PATH@/issue236-ESYCC-CDEF.jp2 -o @TEMP_PATH@/issue236-ESYCC-CDEF.jp2.pgx\n\n# issue 326 + PR 559: CIELab colorspace\nopj_decompress -i @INPUT_NR_PATH@/issue559-eci-090-CIELab.jp2 -o @TEMP_PATH@/issue559-eci-090-CIELab.jp2.pgx\nopj_decompress -i @INPUT_NR_PATH@/issue559-eci-091-CIELab.jp2 -o @TEMP_PATH@/issue559-eci-091-CIELab.jp2.pgx\n\n# issue 653 Last box of undefined size byg\nopj_decompress -i @INPUT_NR_PATH@/issue653-zero-unknownbox.jp2 -o @TEMP_PATH@/issue653-zero-unknownbox.jp2.png -p 8S\n\n# issue 729 decompress 3/5/7/9/11/13/15 bits precision to tiff\n# GRAYSCALE \nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-3.tif -p 3S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-5.tif -p 5S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-7.tif -p 7S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-9.tif -p 9S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-11.tif -p 11S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-13.tif -p 13S\nopj_decompress -i @INPUT_CONF_PATH@/a1_mono.j2c -o @TEMP_PATH@/a1_mono_tif-15.tif -p 15S\n# GRAYSCALE ALPHA\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-3.tif -p 3S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-5.tif -p 5S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-7.tif -p 7S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-9.tif -p 9S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-11.tif -p 11S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-13.tif -p 13S\nopj_decompress -i @INPUT_NR_PATH@/basn4a08.jp2 -o @TEMP_PATH@/basn4a08_tif-15.tif -p 15S\n# RGB\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-3.tif -p 3S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-5.tif -p 5S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-7.tif -p 7S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-9.tif -p 9S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-11.tif -p 11S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-13.tif -p 13S\nopj_decompress -i @INPUT_CONF_PATH@/p0_14.j2k -o @TEMP_PATH@/p0_14_tif-15.tif -p 15S\n# RGBA\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-3.tif -p 3S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-5.tif -p 5S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-7.tif -p 7S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-9.tif -p 9S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-11.tif -p 11S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-13.tif -p 13S\nopj_decompress -i @INPUT_NR_PATH@/basn6a08.jp2 -o @TEMP_PATH@/basn6a08_tif-15.tif -p 15S\n\n# issue 725\n!opj_decompress -i @INPUT_NR_PATH@/issue725.jp2 -o @TEMP_PATH@/issue725.png\n# issue 726\nopj_decompress -i @INPUT_NR_PATH@/issue726.j2k -o @TEMP_PATH@/issue726.png\n# issue 733\n!opj_decompress -i @INPUT_NR_PATH@/issue733.jp2 -o @TEMP_PATH@/issue733.png\n"], "filenames": ["src/lib/openjp2/tcd.c", "tests/nonregression/test_suite.ctest.in"], "buggy_code_start_loc": [723, 559], "buggy_code_end_loc": [724, 559], "fixing_code_start_loc": [723, 560], "fixing_code_end_loc": [725, 562], "type": "CWE-369", "message": "Divide-by-zero vulnerability in the opj_tcd_init_tile function in tcd.c in OpenJPEG before 2.1.1 allows remote attackers to cause a denial of service (application crash) via a crafted jp2 file. NOTE: this issue exists because of an incorrect fix for CVE-2014-7947.", "other": {"cve": {"id": "CVE-2016-4797", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-03T16:59:00.293", "lastModified": "2020-09-09T19:57:00.343", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Divide-by-zero vulnerability in the opj_tcd_init_tile function in tcd.c in OpenJPEG before 2.1.1 allows remote attackers to cause a denial of service (application crash) via a crafted jp2 file. NOTE: this issue exists because of an incorrect fix for CVE-2014-7947."}, {"lang": "es", "value": "La vulnerabilidad divide por cero en la funci\u00f3n opj_tcd_init_tile en tcd.c en OpenJPEG en versiones anteriores a 2.1.1 permite a los atacantes remotos causar una denegaci\u00f3n de servicio (ca\u00edda de la aplicaci\u00f3n) a trav\u00e9s de un archivo jp2 elaborado. NOTA: este problema existe debido a una correcci\u00f3n incorrecta de CVE-2014-7947."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.0", "matchCriteriaId": "BA6BA5BE-0BB1-43CD-8F99-1252CA514E6D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:24:*:*:*:*:*:*:*", "matchCriteriaId": "C729D5D1-ED95-443A-9F53-5D7C2FD9B80C"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/05/13/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1335483", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/uclouvain/openjpeg/commit/8f9cc62b3f9a1da9712329ddcedb9750d585505c", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/733", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5FFMOZOF2EI6N2CR23EQ5EATWLQKBMHW/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BJM23YERMEC6LCTWBUH7LZURGSLZDFDH/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DFRD35RIPRCGZA5DKAKHZ62LMP2A5UT7/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HPMDEUIMHTLKMHELDL4F4HZ7X4Y34JEB/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2020.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/uclouvain/openjpeg/commit/8f9cc62b3f9a1da9712329ddcedb9750d585505c"}}