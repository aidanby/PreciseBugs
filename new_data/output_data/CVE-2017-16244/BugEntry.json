{"buggy_code": ["<?php\n\nreturn [\n\n    /*\n    |--------------------------------------------------------------------------\n    | Specifies the default CMS theme.\n    |--------------------------------------------------------------------------\n    |\n    | This parameter value can be overridden by the CMS back-end settings.\n    |\n    */\n\n    'activeTheme' => 'demo',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Bleeding edge updates\n    |--------------------------------------------------------------------------\n    |\n    | If you are developing with October, it is important to have the latest\n    | code base. Set this value to 'true' to tell the platform to download\n    | and use the development copies of core files and plugins.\n    |\n    */\n\n    'edgeUpdates' => false,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Back-end URI prefix\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the URL name used for accessing back-end pages.\n    | For example: backend -> http://localhost/backend\n    |\n    */\n\n    'backendUri' => 'backend',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Back-end force HTTPS security\n    |--------------------------------------------------------------------------\n    |\n    | Use this setting to force a secure protocol when accessing any back-end\n    | pages, including the authentication pages. If set to null, this setting\n    | is enabled when debug mode (app.debug) is disabled.\n    |\n    */\n\n    'backendForceSecure' => null,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Back-end login remember\n    |--------------------------------------------------------------------------\n    |\n    | Define live duration of backend sessions :\n    |\n    | true  - session never expire (cookie expiration in 5 years)\n    |\n    | false - session have a limited time (see session.lifetime)\n    |\n    | null  - The form login display a checkbox that allow user to choose\n    |         wanted behavior\n    |\n    */\n\n    'backendForceRemember' => true,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Back-end timezone\n    |--------------------------------------------------------------------------\n    |\n    | This acts as the default setting for a back-end user's timezone. This can\n    | be changed by the user at any time using the backend preferences. All\n    | dates displayed in the back-end will be converted to this timezone.\n    |\n    */\n\n    'backendTimezone' => 'UTC',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Back-end Skin\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the back-end skin to use.\n    |\n    */\n\n    'backendSkin' => 'Backend\\Skins\\Standard',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Determines which modules to load\n    |--------------------------------------------------------------------------\n    |\n    | Specify which modules should be registered when using the application.\n    |\n    */\n\n    'loadModules' => ['System', 'Backend', 'Cms'],\n\n    /*\n    |--------------------------------------------------------------------------\n    | Prevents application updates\n    |--------------------------------------------------------------------------\n    |\n    | If using composer or git to download updates to the core files, set this\n    | value to 'true' to prevent the update gateway from trying to download\n    | these files again as part of the application update process. Plugins\n    | and themes will still be downloaded.\n    |\n    */\n\n    'disableCoreUpdates' => false,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Specific plugins to disable\n    |--------------------------------------------------------------------------\n    |\n    | Specify plugin codes which will always be disabled in the application.\n    |\n    */\n\n    'disablePlugins' => [],\n\n    /*\n    |--------------------------------------------------------------------------\n    | Determines if the routing caching is enabled.\n    |--------------------------------------------------------------------------\n    |\n    | If the caching is enabled, the page URL map is saved in the cache. If a page\n    | URL was changed on the disk, the old URL value could be still saved in the cache.\n    | To update the cache the back-end Clear Cache feature should be used. It is recommended\n    | to disable the caching during the development, and enable it in the production mode.\n    |\n    */\n\n    'enableRoutesCache' => false,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Time to live for the URL map.\n    |--------------------------------------------------------------------------\n    |\n    | The URL map used in the CMS page routing process. By default\n    | the map is updated every time when a page is saved in the back-end or when the\n    | interval, in minutes, specified with the urlMapCacheTTL parameter expires.\n    |\n    */\n\n    'urlCacheTtl' => 10,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Time to live for parsed CMS objects.\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the number of minutes the CMS object cache lives. After the interval\n    | is expired item are re-cached. Note that items are re-cached automatically when\n    | the corresponding template file is modified.\n    |\n    */\n\n    'parsedPageCacheTTL' => 10,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Determines if the asset caching is enabled.\n    |--------------------------------------------------------------------------\n    |\n    | If the caching is enabled, combined assets are cached. If a asset file\n    | is changed on the disk, the old file contents could be still saved in the cache.\n    | To update the cache the back-end Clear Cache feature should be used. It is recommended\n    | to disable the caching during the development, and enable it in the production mode.\n    |\n    */\n\n    'enableAssetCache' => false,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Determines if the asset minification is enabled.\n    |--------------------------------------------------------------------------\n    |\n    | If the minification is enabled, combined assets are compressed (minified).\n    | It is recommended to disable the minification during development, and\n    | enable it in production mode. If set to null, assets are minified\n    | when debug mode (app.debug) is disabled.\n    |\n    */\n\n    'enableAssetMinify' => null,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Check import timestamps when combining assets\n    |--------------------------------------------------------------------------\n    |\n    | If deep hashing is enabled, the combiner cache will be reset when a change\n    | is detected on imported files, in addition to those referenced directly.\n    | This will cause slower page performance. If set to null, deep hashing\n    | is used when debug mode (app.debug) is enabled.\n    |\n    */\n\n    'enableAssetDeepHashing' => null,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Public plugins path\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the public plugins path relative to the application base URL,\n    | or you can specify a full URL path.\n    |\n    */\n\n    'pluginsPath' => '/plugins',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Public themes path\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the public themes path relative to the application base URL,\n    | or you can specify a full URL path.\n    |\n    */\n\n    'themesPath' => '/themes',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Resource storage\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the configuration for resource storage, such as media and\n    | upload files. These resources are used:\n    |\n    | media   - generated by the media manager.\n    | uploads - generated by attachment model relationships.\n    |\n    | For each resource you can specify:\n    |\n    | disk   - filesystem disk, as specified in filesystems.php config.\n    | folder - a folder prefix for storing all generated files inside.\n    | path   - the public path relative to the application base URL,\n    |          or you can specify a full URL path.\n    */\n\n    'storage' => [\n\n        'uploads' => [\n            'disk'   => 'local',\n            'folder' => 'uploads',\n            'path'   => '/storage/app/uploads',\n        ],\n\n        'media' => [\n            'disk'   => 'local',\n            'folder' => 'media',\n            'path'   => '/storage/app/media',\n        ],\n\n    ],\n\n    /*\n    |--------------------------------------------------------------------------\n    | Convert Line Endings\n    |--------------------------------------------------------------------------\n    |\n    | Determines if October should convert line endings from the windows style\n    | \\r\\n to the unix style \\n.\n    |\n    */\n\n    'convertLineEndings' => false,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Linking policy\n    |--------------------------------------------------------------------------\n    |\n    | Controls how URL links are generated throughout the application.\n    |\n    | detect   - detect hostname and use the current schema\n    | secure   - detect hostname and force HTTPS schema\n    | insecure - detect hostname and force HTTP schema\n    | force    - force hostname and schema using app.url config value\n    |\n    */\n\n    'linkPolicy' => 'detect',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Default permission mask\n    |--------------------------------------------------------------------------\n    |\n    | Specifies a default file and folder permission for newly created objects.\n    |\n    */\n\n    'defaultMask' => ['file' => null, 'folder' => null],\n\n    /*\n    |--------------------------------------------------------------------------\n    | Safe mode\n    |--------------------------------------------------------------------------\n    |\n    | If safe mode is enabled, the PHP code section is disabled in the CMS\n    | for security reasons. If set to null, safe mode is enabled when\n    | debug mode (app.debug) is disabled.\n    |\n    */\n\n    'enableSafeMode' => null,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Cross Site Request Forgery (CSRF) Protection\n    |--------------------------------------------------------------------------\n    |\n    | If the CSRF protection is enabled, all \"postback\" requests are checked\n    | for a valid security token.\n    |\n    */\n\n    'enableCsrfProtection' => false,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Force bytecode invalidation\n    |--------------------------------------------------------------------------\n    |\n    | When using OPcache with opcache.validate_timestamps set to 0 or APC\n    | with apc.stat set to 0 and Twig cache enabled, clearing the template\n    | cache won't update the cache, set to true to get around this.\n    |\n    */\n\n    'forceBytecodeInvalidation' => true,\n\n];\n", "<?php namespace Cms\\Classes;\n\nuse Cms;\nuse Url;\nuse Str;\nuse App;\nuse File;\nuse View;\nuse Lang;\nuse Flash;\nuse Config;\nuse Session;\nuse Request;\nuse Response;\nuse Exception;\nuse BackendAuth;\nuse Twig_Environment;\nuse Twig_Cache_Filesystem;\nuse Cms\\Twig\\Loader as TwigLoader;\nuse Cms\\Twig\\DebugExtension;\nuse Cms\\Twig\\Extension as CmsTwigExtension;\nuse Cms\\Models\\MaintenanceSetting;\nuse System\\Models\\RequestLog;\nuse System\\Helpers\\View as ViewHelper;\nuse System\\Classes\\ErrorHandler;\nuse System\\Classes\\CombineAssets;\nuse System\\Twig\\Extension as SystemTwigExtension;\nuse October\\Rain\\Exception\\AjaxException;\nuse October\\Rain\\Exception\\SystemException;\nuse October\\Rain\\Exception\\ValidationException;\nuse October\\Rain\\Exception\\ApplicationException;\nuse October\\Rain\\Parse\\Bracket as TextParser;\nuse Illuminate\\Http\\RedirectResponse;\n\n/**\n * The CMS controller class.\n * The controller finds and serves requested pages.\n *\n * @package october\\cms\n * @author Alexey Bobkov, Samuel Georges\n */\nclass Controller\n{\n    use \\System\\Traits\\AssetMaker;\n    use \\System\\Traits\\EventEmitter;\n\n    /**\n     * @var \\Cms\\Classes\\Theme A reference to the CMS theme processed by the controller.\n     */\n    protected $theme;\n\n    /**\n     * @var \\Cms\\Classes\\Router A reference to the Router object.\n     */\n    protected $router;\n\n    /**\n     * @var \\Cms\\Twig\\Loader A reference to the Twig template loader.\n     */\n    protected $loader;\n\n    /**\n     * @var \\Cms\\Classes\\Page A reference to the CMS page template being processed.\n     */\n    protected $page;\n\n    /**\n     * @var \\Cms\\Classes\\CodeBase A reference to the CMS page code section object.\n     */\n    protected $pageObj;\n\n    /**\n     * @var \\Cms\\Classes\\Layout A reference to the CMS layout template used by the page.\n     */\n    protected $layout;\n\n    /**\n     * @var \\Cms\\Classes\\CodeBase A reference to the CMS layout code section object.\n     */\n    protected $layoutObj;\n\n    /**\n     * @var \\Twig_Environment Keeps the Twig environment object.\n     */\n    protected $twig;\n\n    /**\n     * @var string Contains the rendered page contents string.\n     */\n    protected $pageContents;\n\n    /**\n     * @var array A list of variables to pass to the page.\n     */\n    public $vars = [];\n\n    /**\n     * @var int Response status code\n     */\n    protected $statusCode = 200;\n\n    /**\n     * @var self Cache of self\n     */\n    protected static $instance = null;\n\n    /**\n     * @var \\Cms\\Classes\\ComponentBase Object of the active component, used internally.\n     */\n    protected $componentContext = null;\n\n    /**\n     * @var array Component partial stack, used internally.\n     */\n    protected $partialStack = [];\n\n    /**\n     * Creates the controller.\n     * @param \\Cms\\Classes\\Theme $theme Specifies the CMS theme.\n     * If the theme is not specified, the current active theme used.\n     */\n    public function __construct($theme = null)\n    {\n        $this->theme = $theme ? $theme : Theme::getActiveTheme();\n        if (!$this->theme) {\n            throw new CmsException(Lang::get('cms::lang.theme.active.not_found'));\n        }\n\n        $this->assetPath = Config::get('cms.themesPath', '/themes').'/'.$this->theme->getDirName();\n        $this->router = new Router($this->theme);\n        $this->partialStack = new PartialStack;\n        $this->initTwigEnvironment();\n\n        self::$instance = $this;\n    }\n\n    /**\n     * Finds and serves the requested page.\n     * If the page cannot be found, returns the page with the URL /404.\n     * If the /404 page doesn't exist, returns the system 404 page.\n     * @param string $url Specifies the requested page URL.\n     * If the parameter is omitted, the current URL used.\n     * @return string Returns the processed page content.\n     */\n    public function run($url = '/')\n    {\n        if ($url === null) {\n            $url = Request::path();\n        }\n\n        if (!strlen($url)) {\n            $url = '/';\n        }\n\n        /*\n         * Hidden page\n         */\n        $page = $this->router->findByUrl($url);\n        if ($page && $page->is_hidden) {\n            if (!BackendAuth::getUser()) {\n                $page = null;\n            }\n        }\n\n        /*\n         * Maintenance mode\n         */\n        if (\n            MaintenanceSetting::isConfigured() &&\n            MaintenanceSetting::get('is_enabled', false) &&\n            !BackendAuth::getUser()\n        ) {\n            if (!Request::ajax()) {\n                $this->setStatusCode(503);\n            }\n\n            $page = Page::loadCached($this->theme, MaintenanceSetting::get('cms_page'));\n        }\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.beforeDisplay', [$url, $page])) {\n            if ($event instanceof Page) {\n                $page = $event;\n            }\n            else {\n                return $event;\n            }\n        }\n\n        /*\n         * If the page was not found, render the 404 page - either provided by the theme or the built-in one.\n         */\n        if (!$page || $url === '404') {\n            if (!Request::ajax()) {\n                $this->setStatusCode(404);\n            }\n\n            // Log the 404 request\n            if (!App::runningUnitTests()) {\n                RequestLog::add();\n            }\n\n            if (!$page = $this->router->findByUrl('/404')) {\n                return Response::make(View::make('cms::404'), $this->statusCode);\n            }\n        }\n\n        /*\n         * Run the page\n         */\n        $result = $this->runPage($page);\n\n        /*\n         * Post-processing\n         */\n        $result = $this->postProcessResult($page, $url, $result);\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.display', [$url, $page, $result])) {\n            return $event;\n        }\n\n        if (!is_string($result)) {\n            return $result;\n        }\n\n        return Response::make($result, $this->statusCode);\n    }\n\n    /**\n     * Renders a page in its entirety, including component initialization.\n     * AJAX will be disabled for this process.\n     * @param string $pageFile Specifies the CMS page file name to run.\n     * @param array  $parameters  Routing parameters.\n     * @param \\Cms\\Classes\\Theme  $theme  Theme object\n     */\n    public static function render($pageFile, $parameters = [], $theme = null)\n    {\n        if (!$theme && (!$theme = Theme::getActiveTheme())) {\n            throw new CmsException(Lang::get('cms::lang.theme.active.not_found'));\n        }\n\n        $controller = new static($theme);\n        $controller->getRouter()->setParameters($parameters);\n\n        if (($page = Page::load($theme, $pageFile)) === null) {\n            throw new CmsException(Lang::get('cms::lang.page.not_found_name', ['name'=>$pageFile]));\n        }\n\n        return $controller->runPage($page, false);\n    }\n\n    /**\n     * Runs a page directly from its object and supplied parameters.\n     * @param \\Cms\\Classes\\Page $page Specifies the CMS page to run.\n     * @return string\n     */\n    public function runPage($page, $useAjax = true)\n    {\n        $this->page = $page;\n\n        /*\n         * If the page doesn't refer any layout, create the fallback layout.\n         * Otherwise load the layout specified in the page.\n         */\n        if (!$page->layout) {\n            $layout = Layout::initFallback($this->theme);\n        }\n        elseif (($layout = Layout::loadCached($this->theme, $page->layout)) === null) {\n            throw new CmsException(Lang::get('cms::lang.layout.not_found_name', ['name'=>$page->layout]));\n        }\n\n        $this->layout = $layout;\n\n        /*\n         * The 'this' variable is reserved for default variables.\n         */\n        $this->vars['this'] = [\n            'page'        => $this->page,\n            'layout'      => $this->layout,\n            'theme'       => $this->theme,\n            'param'       => $this->router->getParameters(),\n            'controller'  => $this,\n            'environment' => App::environment(),\n            'session'     => App::make('session'),\n        ];\n\n        /*\n         * Check for the presence of validation errors in the session.\n         */\n        $this->vars['errors'] = (Config::get('session.driver') && Session::has('errors'))\n            ? Session::get('errors')\n            : new \\Illuminate\\Support\\ViewErrorBag;\n\n        /*\n         * Handle AJAX requests and execute the life cycle functions\n         */\n        $this->initCustomObjects();\n\n        $this->initComponents();\n\n        /*\n         * Give the layout and page an opportunity to participate\n         * after components are initialized and before AJAX is handled.\n         */\n        if ($this->layoutObj) {\n            CmsException::mask($this->layout, 300);\n            $this->layoutObj->onInit();\n            CmsException::unmask();\n        }\n\n        CmsException::mask($this->page, 300);\n        $this->pageObj->onInit();\n        CmsException::unmask();\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.init', [$page])) {\n            return $event;\n        }\n\n        /*\n         * Execute AJAX event\n         */\n        if ($useAjax && $ajaxResponse = $this->execAjaxHandlers()) {\n            return $ajaxResponse;\n        }\n\n        /*\n         * Execute postback handler\n         */\n        if (\n            $useAjax &&\n            ($handler = post('_handler')) &&\n            ($handlerResponse = $this->runAjaxHandler($handler)) &&\n            $handlerResponse !== true\n        ) {\n            return $handlerResponse;\n        }\n\n        /*\n         * Execute page lifecycle\n         */\n        if ($cycleResponse = $this->execPageCycle()) {\n            return $cycleResponse;\n        }\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.beforeRenderPage', [$page])) {\n            $this->pageContents = $event;\n        }\n        else {\n            /*\n             * Render the page\n             */\n            CmsException::mask($this->page, 400);\n            $this->loader->setObject($this->page);\n            $template = $this->twig->loadTemplate($this->page->getFilePath());\n            $this->pageContents = $template->render($this->vars);\n            CmsException::unmask();\n        }\n\n        /*\n         * Render the layout\n         */\n        CmsException::mask($this->layout, 400);\n        $this->loader->setObject($this->layout);\n        $template = $this->twig->loadTemplate($this->layout->getFilePath());\n        $result = $template->render($this->vars);\n        CmsException::unmask();\n\n        return $result;\n    }\n\n    /**\n     * Invokes the current page cycle without rendering the page,\n     * used by AJAX handler that may rely on the logic inside the action.\n     */\n    public function pageCycle()\n    {\n        return $this->execPageCycle();\n    }\n\n    /**\n     * Executes the page life cycle.\n     * Creates an object from the PHP sections of the page and\n     * it's layout, then executes their life cycle functions.\n     */\n    protected function execPageCycle()\n    {\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.start')) {\n            return $event;\n        }\n\n        /*\n         * Run layout functions\n         */\n        if ($this->layoutObj) {\n            CmsException::mask($this->layout, 300);\n            $response = (\n                ($result = $this->layoutObj->onStart()) ||\n                ($result = $this->layout->runComponents()) ||\n                ($result = $this->layoutObj->onBeforePageStart())\n            ) ? $result : null;\n            CmsException::unmask();\n\n            if ($response) {\n                return $response;\n            }\n        }\n\n        /*\n         * Run page functions\n         */\n        CmsException::mask($this->page, 300);\n        $response = (\n            ($result = $this->pageObj->onStart()) ||\n            ($result = $this->page->runComponents()) ||\n            ($result = $this->pageObj->onEnd())\n        ) ? $result : null;\n        CmsException::unmask();\n\n        if ($response) {\n            return $response;\n        }\n\n        /*\n         * Run remaining layout functions\n         */\n        if ($this->layoutObj) {\n            CmsException::mask($this->layout, 300);\n            $response = ($result = $this->layoutObj->onEnd()) ? $result : null;\n            CmsException::unmask();\n        }\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.end')) {\n            return $event;\n        }\n\n        return $response;\n    }\n\n    /**\n     * Post-processes page HTML code before it's sent to the client.\n     * Note for pre-processing see cms.template.processTwigContent event.\n     * @param \\Cms\\Classes\\Page $page Specifies the current CMS page.\n     * @param string $url Specifies the current URL.\n     * @param string $content The page markup to post processs.\n     * @return string Returns the updated result string.\n     */\n    protected function postProcessResult($page, $url, $content)\n    {\n        $content = MediaViewHelper::instance()->processHtml($content);\n\n        $dataHolder = (object) ['content' => $content];\n\n        $this->fireSystemEvent('cms.page.postprocess', [$url, $page, $dataHolder]);\n\n        return $dataHolder->content;\n    }\n\n    //\n    // Initialization\n    //\n\n    /**\n     * Initializes the Twig environment and loader.\n     * Registers the \\Cms\\Twig\\Extension object with Twig.\n     * @return void\n     */\n    protected function initTwigEnvironment()\n    {\n        $this->loader = new TwigLoader;\n\n        $useCache = !Config::get('cms.twigNoCache');\n        $isDebugMode = Config::get('app.debug', false);\n        $forceBytecode = Config::get('cms.forceBytecodeInvalidation', false);\n\n        $options = [\n            'auto_reload' => true,\n            'debug' => $isDebugMode,\n        ];\n\n        if ($useCache) {\n            $options['cache'] = new Twig_Cache_Filesystem(\n                storage_path().'/cms/twig',\n                $forceBytecode ? Twig_Cache_Filesystem::FORCE_BYTECODE_INVALIDATION : 0\n            );\n        }\n\n        $this->twig = new Twig_Environment($this->loader, $options);\n        $this->twig->addExtension(new CmsTwigExtension($this));\n        $this->twig->addExtension(new SystemTwigExtension);\n\n        if ($isDebugMode) {\n            $this->twig->addExtension(new DebugExtension($this));\n        }\n    }\n\n    /**\n     * Initializes the custom layout and page objects.\n     * @return void\n     */\n    protected function initCustomObjects()\n    {\n        $this->layoutObj = null;\n\n        if (!$this->layout->isFallBack()) {\n            CmsException::mask($this->layout, 300);\n            $parser = new CodeParser($this->layout);\n            $this->layoutObj = $parser->source($this->page, $this->layout, $this);\n            CmsException::unmask();\n        }\n\n        CmsException::mask($this->page, 300);\n        $parser = new CodeParser($this->page);\n        $this->pageObj = $parser->source($this->page, $this->layout, $this);\n        CmsException::unmask();\n    }\n\n    /**\n     * Initializes the components for the layout and page.\n     * @return void\n     */\n    protected function initComponents()\n    {\n        if (!$this->layout->isFallBack()) {\n            foreach ($this->layout->settings['components'] as $component => $properties) {\n                list($name, $alias) = strpos($component, ' ')\n                    ? explode(' ', $component)\n                    : [$component, $component];\n\n                $this->addComponent($name, $alias, $properties, true);\n            }\n        }\n\n        foreach ($this->page->settings['components'] as $component => $properties) {\n            list($name, $alias) = strpos($component, ' ')\n                ? explode(' ', $component)\n                : [$component, $component];\n\n            $this->addComponent($name, $alias, $properties);\n        }\n\n        /*\n         * Extensibility\n         */\n        $this->fireSystemEvent('cms.page.initComponents', [$this->page, $this->layout]);\n    }\n\n    //\n    // AJAX\n    //\n\n    /**\n     * Returns the AJAX handler for the current request, if available.\n     * @return string\n     */\n    public function getAjaxHandler()\n    {\n        if (!Request::ajax() || Request::method() != 'POST') {\n            return null;\n        }\n\n        if ($handler = Request::header('X_OCTOBER_REQUEST_HANDLER')) {\n            return trim($handler);\n        }\n\n        return null;\n    }\n\n    /**\n     * Executes the page, layout, component and plugin AJAX handlers.\n     * @return mixed Returns the AJAX Response object or null.\n     */\n    protected function execAjaxHandlers()\n    {\n        if ($handler = $this->getAjaxHandler()) {\n            try {\n                /*\n                 * Validate the handler name\n                 */\n                if (!preg_match('/^(?:\\w+\\:{2})?on[A-Z]{1}[\\w+]*$/', $handler)) {\n                    throw new CmsException(Lang::get('cms::lang.ajax_handler.invalid_name', ['name'=>$handler]));\n                }\n\n                /*\n                 * Validate the handler partial list\n                 */\n                if ($partialList = trim(Request::header('X_OCTOBER_REQUEST_PARTIALS'))) {\n                    $partialList = explode('&', $partialList);\n\n                    foreach ($partialList as $partial) {\n                        if (!preg_match('/^(?:\\w+\\:{2}|@)?[a-z0-9\\_\\-\\.\\/]+$/i', $partial)) {\n                            throw new CmsException(Lang::get('cms::lang.partial.invalid_name', ['name'=>$partial]));\n                        }\n                    }\n                }\n                else {\n                    $partialList = [];\n                }\n\n                $responseContents = [];\n\n                /*\n                 * Execute the handler\n                 */\n                if (!$result = $this->runAjaxHandler($handler)) {\n                    throw new CmsException(Lang::get('cms::lang.ajax_handler.not_found', ['name'=>$handler]));\n                }\n\n                /*\n                 * Render partials and return the response as array that will be converted to JSON automatically.\n                 */\n                foreach ($partialList as $partial) {\n                    $responseContents[$partial] = $this->renderPartial($partial);\n                }\n\n                /*\n                 * If the handler returned a redirect, process the URL and dispose of it so\n                 * framework.js knows to redirect the browser and not the request!\n                 */\n                if ($result instanceof RedirectResponse) {\n                    $responseContents['X_OCTOBER_REDIRECT'] = $result->getTargetUrl();\n                    $result = null;\n                }\n                /*\n                 * No redirect is used, look for any flash messages\n                 */\n                elseif (Request::header('X_OCTOBER_REQUEST_FLASH') && Flash::check()) {\n                    $responseContents['X_OCTOBER_FLASH_MESSAGES'] = Flash::all();\n                }\n\n                /*\n                 * If the handler returned an array, we should add it to output for rendering.\n                 * If it is a string, add it to the array with the key \"result\".\n                 * If an object, pass it to Laravel as a response object.\n                 */\n                if (is_array($result)) {\n                    $responseContents = array_merge($responseContents, $result);\n                }\n                elseif (is_string($result)) {\n                    $responseContents['result'] = $result;\n                }\n                elseif (is_object($result)) {\n                    return $result;\n                }\n\n                return Response::make($responseContents, $this->statusCode);\n            }\n            catch (ValidationException $ex) {\n                /*\n                 * Handle validation errors\n                 */\n                $responseContents['X_OCTOBER_ERROR_FIELDS'] = $ex->getFields();\n                $responseContents['X_OCTOBER_ERROR_MESSAGE'] = $ex->getMessage();\n                throw new AjaxException($responseContents);\n            }\n            catch (Exception $ex) {\n                throw $ex;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Tries to find and run an AJAX handler in the page, layout, components and plugins.\n     * The method stops as soon as the handler is found.\n     * @param string $handler name of the ajax handler\n     * @return boolean Returns true if the handler was found. Returns false otherwise.\n     */\n    protected function runAjaxHandler($handler)\n    {\n        /*\n         * Process Component handler\n         */\n        if (strpos($handler, '::')) {\n\n            list($componentName, $handlerName) = explode('::', $handler);\n            $componentObj = $this->findComponentByName($componentName);\n\n            if ($componentObj && $componentObj->methodExists($handlerName)) {\n                $this->componentContext = $componentObj;\n                $result = $componentObj->runAjaxHandler($handlerName);\n                return ($result) ?: true;\n            }\n        }\n        /*\n         * Process code section handler\n         */\n        else {\n            if (method_exists($this->pageObj, $handler)) {\n                $result = $this->pageObj->$handler();\n                return ($result) ?: true;\n            }\n\n            if (!$this->layout->isFallBack() && method_exists($this->layoutObj, $handler)) {\n                $result = $this->layoutObj->$handler();\n                return ($result) ?: true;\n            }\n\n            /*\n             * Cycle each component to locate a usable handler\n             */\n            if (($componentObj = $this->findComponentByHandler($handler)) !== null) {\n                $this->componentContext = $componentObj;\n                $result = $componentObj->runAjaxHandler($handler);\n                return ($result) ?: true;\n            }\n        }\n\n        /*\n         * Generic handler that does nothing\n         */\n        if ($handler == 'onAjax') {\n            return true;\n        }\n\n        return false;\n    }\n\n    //\n    // Rendering\n    //\n\n    /**\n     * Renders a requested page.\n     * The framework uses this method internally.\n     */\n    public function renderPage()\n    {\n        $contents = $this->pageContents;\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.render', [$contents])) {\n            return $event;\n        }\n\n        return $contents;\n    }\n\n    /**\n     * Renders a requested partial.\n     * The framework uses this method internally.\n     * @param string $name The view to load.\n     * @param array $parameters Parameter variables to pass to the view.\n     * @param bool $throwException Throw an exception if the partial is not found.\n     * @return mixed Partial contents or false if not throwing an exception.\n     */\n    public function renderPartial($name, $parameters = [], $throwException = true)\n    {\n        $vars = $this->vars;\n        $this->vars = array_merge($this->vars, $parameters);\n\n        /*\n         * Alias @ symbol for ::\n         */\n        if (substr($name, 0, 1) == '@') {\n            $name = '::' . substr($name, 1);\n        }\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.beforeRenderPartial', [$name])) {\n            $partial = $event;\n        }\n        /*\n         * Process Component partial\n         */\n        elseif (strpos($name, '::') !== false) {\n\n            list($componentAlias, $partialName) = explode('::', $name);\n\n            /*\n             * Component alias not supplied\n             */\n            if (!strlen($componentAlias)) {\n                if ($this->componentContext !== null) {\n                    $componentObj = $this->componentContext;\n                }\n                elseif (($componentObj = $this->findComponentByPartial($partialName)) === null) {\n                    if ($throwException) {\n                        throw new CmsException(Lang::get('cms::lang.partial.not_found_name', ['name'=>$partialName]));\n                    }\n                    else {\n                        return false;\n                    }\n                }\n            }\n            /*\n             * Component alias is supplied\n             */\n            else {\n                if (($componentObj = $this->findComponentByName($componentAlias)) === null) {\n                    if ($throwException) {\n                        throw new CmsException(Lang::get('cms::lang.component.not_found', ['name'=>$componentAlias]));\n                    }\n                    else {\n                        return false;\n                    }\n                }\n            }\n\n            $partial = null;\n            $this->componentContext = $componentObj;\n\n            /*\n             * Check if the theme has an override\n             */\n            if (strpos($partialName, '/') === false) {\n                $partial = ComponentPartial::loadOverrideCached($this->theme, $componentObj, $partialName);\n            }\n\n            /*\n             * Check the component partial\n             */\n            if ($partial === null) {\n                $partial = ComponentPartial::loadCached($componentObj, $partialName);\n            }\n\n            if ($partial === null) {\n                if ($throwException) {\n                    throw new CmsException(Lang::get('cms::lang.partial.not_found_name', ['name'=>$name]));\n                }\n                else {\n                    return false;\n                }\n            }\n\n            /*\n             * Set context for self access\n             */\n            $this->vars['__SELF__'] = $componentObj;\n        }\n        else {\n            /*\n             * Process theme partial\n             */\n            if (($partial = Partial::loadCached($this->theme, $name)) === null) {\n                if ($throwException) {\n                    throw new CmsException(Lang::get('cms::lang.partial.not_found_name', ['name'=>$name]));\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n\n        /*\n         * Run functions for CMS partials only (Cms\\Classes\\Partial)\n         */\n        if ($partial instanceof Partial) {\n            $this->partialStack->stackPartial();\n\n            $manager = ComponentManager::instance();\n\n            foreach ($partial->settings['components'] as $component => $properties) {\n                // Do not inject the viewBag component to the environment.\n                // Not sure if they're needed there by the requirements,\n                // but there were problems with array-typed properties used by Static Pages\n                // snippets and setComponentPropertiesFromParams(). --ab\n                if ($component == 'viewBag') {\n                    continue;\n                }\n\n                list($name, $alias) = strpos($component, ' ')\n                    ? explode(' ', $component)\n                    : [$component, $component];\n\n                if (!$componentObj = $manager->makeComponent($name, $this->pageObj, $properties)) {\n                    throw new CmsException(Lang::get('cms::lang.component.not_found', ['name'=>$name]));\n                }\n\n                $componentObj->alias = $alias;\n                $parameters[$alias] = $partial->components[$alias] = $componentObj;\n\n                $this->partialStack->addComponent($alias, $componentObj);\n\n                $this->setComponentPropertiesFromParams($componentObj, $parameters);\n                $componentObj->init();\n            }\n\n            CmsException::mask($this->page, 300);\n            $parser = new CodeParser($partial);\n            $partialObj = $parser->source($this->page, $this->layout, $this);\n            CmsException::unmask();\n\n            CmsException::mask($partial, 300);\n            $partialObj->onStart();\n            $partial->runComponents();\n            $partialObj->onEnd();\n            CmsException::unmask();\n        }\n\n        /*\n         * Render the partial\n         */\n        CmsException::mask($partial, 400);\n        $this->loader->setObject($partial);\n        $template = $this->twig->loadTemplate($partial->getFilePath());\n        $partialContent = $template->render(array_merge($this->vars, $parameters));\n        CmsException::unmask();\n\n        if ($partial instanceof Partial) {\n            $this->partialStack->unstackPartial();\n        }\n\n        $this->vars = $vars;\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.renderPartial', [$name, &$partialContent])) {\n            return $event;\n        }\n\n        return $partialContent;\n    }\n\n    /**\n     * Renders a requested content file.\n     * The framework uses this method internally.\n     * @param string $name The content view to load.\n     * @param array $parameters Parameter variables to pass to the view.\n     * @return string\n     */\n    public function renderContent($name, $parameters = [])\n    {\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.beforeRenderContent', [$name])) {\n            $content = $event;\n        }\n        /*\n         * Load content from theme\n         */\n        elseif (($content = Content::loadCached($this->theme, $name)) === null) {\n            throw new CmsException(Lang::get('cms::lang.content.not_found_name', ['name'=>$name]));\n        }\n\n        $fileContent = $content->parsedMarkup;\n\n        /*\n         * Inject global view variables\n         */\n        $globalVars = ViewHelper::getGlobalVars();\n        if (!empty($globalVars)) {\n            $parameters = (array) $parameters + $globalVars;\n        }\n\n        /*\n         * Parse basic template variables\n         */\n        if (!empty($parameters)) {\n            $fileContent = TextParser::parse($fileContent, $parameters);\n        }\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.renderContent', [$name, &$fileContent])) {\n            return $event;\n        }\n\n        return $fileContent;\n    }\n\n    /**\n     * Renders a component's default content, preserves the previous component context.\n     * @param $name\n     * @param array $parameters\n     * @return string Returns the component default contents.\n     */\n    public function renderComponent($name, $parameters = [])\n    {\n        $result = null;\n        $previousContext = $this->componentContext;\n\n        if ($componentObj = $this->findComponentByName($name)) {\n            $componentObj->id = uniqid($name);\n            $componentObj->setProperties(array_merge($componentObj->getProperties(), $parameters));\n            $this->componentContext = $componentObj;\n            $result = $componentObj->onRender();\n        }\n\n        if (!$result) {\n            $result = $this->renderPartial($name.'::default', [], false);\n        }\n\n        $this->componentContext = $previousContext;\n        return $result;\n    }\n\n    //\n    // Setters\n    //\n\n    /**\n     * Sets the status code for the current web response.\n     * @param int $code Status code\n     * @return self\n     */\n    public function setStatusCode($code)\n    {\n        $this->statusCode = (int) $code;\n        return $this;\n    }\n\n    //\n    // Getters\n    //\n\n     /**\n     * Returns the status code for the current web response.\n     * @return int Status code\n     */\n    public function getStatusCode()\n    {\n        return $this->statusCode;\n    }\n\n    /**\n     * Returns an existing instance of the controller.\n     * If the controller doesn't exists, returns null.\n     * @return mixed Returns the controller object or null.\n     */\n    public static function getController()\n    {\n        return self::$instance;\n    }\n\n    /**\n     * Returns the current CMS theme.\n     * @return \\Cms\\Classes\\Theme\n     */\n    public function getTheme()\n    {\n        return $this->theme;\n    }\n\n    /**\n     * Returns the Twig environment.\n     * @return Twig_Environment\n     */\n    public function getTwig()\n    {\n        return $this->twig;\n    }\n\n    /**\n     * Returns the Twig loader.\n     * @return \\Cms\\Twig\\Loader\n     */\n    public function getLoader()\n    {\n        return $this->loader;\n    }\n\n    /**\n     * Returns the routing object.\n     * @return \\Cms\\Classes\\Router\n     */\n    public function getRouter()\n    {\n        return $this->router;\n    }\n\n    /**\n     * Intended to be called from the layout, returns the page code base object.\n     * @return \\Cms\\Classes\\CodeBase\n     */\n    public function getPageObject()\n    {\n        return $this->pageObj;\n    }\n\n    /**\n     * Returns the CMS page object being processed by the controller.\n     * The object is not available on the early stages of the controller\n     * initialization.\n     * @return \\Cms\\Classes\\Page Returns the Page object or null.\n     */\n    public function getPage()\n    {\n        return $this->page;\n    }\n\n    /**\n     * Intended to be called from the page, returns the layout code base object.\n     * @return \\Cms\\Classes\\CodeBase\n     */\n    public function getLayoutObject()\n    {\n        return $this->layoutObj;\n    }\n\n    //\n    // Page helpers\n    //\n\n    /**\n     * Looks up the URL for a supplied page and returns it relative to the website root.\n     *\n     * @param mixed $name Specifies the Cms Page file name.\n     * @param array $parameters Route parameters to consider in the URL.\n     * @param bool $routePersistence By default the existing routing parameters will be included\n     * @return string\n     */\n    public function pageUrl($name, $parameters = [], $routePersistence = true)\n    {\n        if (!$name) {\n            return $this->currentPageUrl($parameters, $routePersistence);\n        }\n\n        /*\n         * Second parameter can act as third\n         */\n        if (is_bool($parameters)) {\n            $routePersistence = $parameters;\n        }\n\n        if (!is_array($parameters)) {\n            $parameters = [];\n        }\n\n        if ($routePersistence) {\n            $parameters = array_merge($this->router->getParameters(), $parameters);\n        }\n\n        if (!$url = $this->router->findByFile($name, $parameters)) {\n            return null;\n        }\n\n        return Cms::url($url);\n    }\n\n    /**\n     * Looks up the current page URL with supplied parameters and route persistence.\n     * @param array $parameters\n     * @param bool $routePersistence\n     * @return null|string\n     */\n    public function currentPageUrl($parameters = [], $routePersistence = true)\n    {\n        if (!$currentFile = $this->page->getFileName()) {\n            return null;\n        }\n\n        return $this->pageUrl($currentFile, $parameters, $routePersistence);\n    }\n\n    /**\n     * Converts supplied URL to a theme URL relative to the website root. If the URL provided is an\n     * array then the files will be combined.\n     * @param mixed $url Specifies the theme-relative URL. If null, the theme path is returned.\n     * @return string\n     */\n    public function themeUrl($url = null)\n    {\n        $themeDir = $this->getTheme()->getDirName();\n\n        if (is_array($url)) {\n            $_url = Url::to(CombineAssets::combine($url, themes_path().'/'.$themeDir));\n        }\n        else {\n            $_url = Config::get('cms.themesPath', '/themes').'/'.$themeDir;\n            if ($url !== null) {\n                $_url .= '/'.$url;\n            }\n            $_url = Url::asset($_url);\n        }\n\n        return $_url;\n    }\n\n    /**\n     * Returns a routing parameter.\n     * @param string $name Routing parameter name.\n     * @param string $default Default to use if none is found.\n     * @return string\n     */\n    public function param($name, $default = null)\n    {\n        return $this->router->getParameter($name, $default);\n    }\n\n    //\n    // Component helpers\n    //\n\n    /**\n     * Adds a component to the page object\n     * @param mixed  $name        Component class name or short name\n     * @param string $alias       Alias to give the component\n     * @param array  $properties  Component properties\n     * @param bool   $addToLayout Add to layout, instead of page\n     * @return ComponentBase Component object\n     */\n    public function addComponent($name, $alias, $properties, $addToLayout = false)\n    {\n        $manager = ComponentManager::instance();\n\n        if ($addToLayout) {\n            if (!$componentObj = $manager->makeComponent($name, $this->layoutObj, $properties)) {\n                throw new CmsException(Lang::get('cms::lang.component.not_found', ['name'=>$name]));\n            }\n\n            $componentObj->alias = $alias;\n            $this->vars[$alias] = $this->layout->components[$alias] = $componentObj;\n        }\n        else {\n            if (!$componentObj = $manager->makeComponent($name, $this->pageObj, $properties)) {\n                throw new CmsException(Lang::get('cms::lang.component.not_found', ['name'=>$name]));\n            }\n\n            $componentObj->alias = $alias;\n            $this->vars[$alias] = $this->page->components[$alias] = $componentObj;\n        }\n\n        $this->setComponentPropertiesFromParams($componentObj);\n        $componentObj->init();\n        return $componentObj;\n    }\n\n    /**\n     * Searches the layout and page components by an alias\n     * @param $name\n     * @return ComponentBase The component object, if found\n     */\n    public function findComponentByName($name)\n    {\n        if (isset($this->page->components[$name])) {\n            return $this->page->components[$name];\n        }\n\n        if (isset($this->layout->components[$name])) {\n            return $this->layout->components[$name];\n        }\n\n        $partialComponent = $this->partialStack->getComponent($name);\n        if ($partialComponent !== null) {\n            return $partialComponent;\n        }\n\n        return null;\n    }\n\n    /**\n     * Searches the layout and page components by an AJAX handler\n     * @param string $handler\n     * @return ComponentBase The component object, if found\n     */\n    public function findComponentByHandler($handler)\n    {\n        foreach ($this->page->components as $component) {\n            if ($component->methodExists($handler)) {\n                return $component;\n            }\n        }\n\n        foreach ($this->layout->components as $component) {\n            if ($component->methodExists($handler)) {\n                return $component;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Searches the layout and page components by a partial file\n     * @param string $partial\n     * @return ComponentBase The component object, if found\n     */\n    public function findComponentByPartial($partial)\n    {\n        foreach ($this->page->components as $component) {\n            if (ComponentPartial::check($component, $partial)) {\n                return $component;\n            }\n        }\n\n        foreach ($this->layout->components as $component) {\n            if (ComponentPartial::check($component, $partial)) {\n                return $component;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Set the component context manually, used by Components when calling renderPartial.\n     * @param ComponentBase $component\n     * @return void\n     */\n    public function setComponentContext(ComponentBase $component = null)\n    {\n        $this->componentContext = $component;\n    }\n\n    /**\n     * Sets component property values from partial parameters.\n     * The property values should be defined as {{ param }}.\n     * @param ComponentBase $component The component object.\n     * @param array $parameters Specifies the partial parameters.\n     */\n    protected function setComponentPropertiesFromParams($component, $parameters = [])\n    {\n        $properties = $component->getProperties();\n        $routerParameters = $this->router->getParameters();\n\n        foreach ($properties as $propertyName => $propertyValue) {\n            if (is_array($propertyValue)) {\n                continue;\n            }\n\n            $matches = [];\n            if (preg_match('/^\\{\\{([^\\}]+)\\}\\}$/', $propertyValue, $matches)) {\n                $paramName = trim($matches[1]);\n\n                if (substr($paramName, 0, 1) == ':') {\n                    $routeParamName = substr($paramName, 1);\n                    $newPropertyValue = array_key_exists($routeParamName, $routerParameters)\n                        ? $routerParameters[$routeParamName]\n                        : null;\n\n                }\n                else {\n                    $newPropertyValue = array_key_exists($paramName, $parameters)\n                        ? $parameters[$paramName]\n                        : null;\n                }\n\n                $component->setProperty($propertyName, $newPropertyValue);\n                $component->setExternalPropertyName($propertyName, $paramName);\n            }\n        }\n    }\n}\n"], "fixing_code": ["<?php\n\nreturn [\n\n    /*\n    |--------------------------------------------------------------------------\n    | Specifies the default CMS theme.\n    |--------------------------------------------------------------------------\n    |\n    | This parameter value can be overridden by the CMS back-end settings.\n    |\n    */\n\n    'activeTheme' => 'demo',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Bleeding edge updates\n    |--------------------------------------------------------------------------\n    |\n    | If you are developing with October, it is important to have the latest\n    | code base. Set this value to 'true' to tell the platform to download\n    | and use the development copies of core files and plugins.\n    |\n    */\n\n    'edgeUpdates' => false,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Back-end URI prefix\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the URL name used for accessing back-end pages.\n    | For example: backend -> http://localhost/backend\n    |\n    */\n\n    'backendUri' => 'backend',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Back-end force HTTPS security\n    |--------------------------------------------------------------------------\n    |\n    | Use this setting to force a secure protocol when accessing any back-end\n    | pages, including the authentication pages. If set to null, this setting\n    | is enabled when debug mode (app.debug) is disabled.\n    |\n    */\n\n    'backendForceSecure' => null,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Back-end login remember\n    |--------------------------------------------------------------------------\n    |\n    | Define live duration of backend sessions :\n    |\n    | true  - session never expire (cookie expiration in 5 years)\n    |\n    | false - session have a limited time (see session.lifetime)\n    |\n    | null  - The form login display a checkbox that allow user to choose\n    |         wanted behavior\n    |\n    */\n\n    'backendForceRemember' => true,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Back-end timezone\n    |--------------------------------------------------------------------------\n    |\n    | This acts as the default setting for a back-end user's timezone. This can\n    | be changed by the user at any time using the backend preferences. All\n    | dates displayed in the back-end will be converted to this timezone.\n    |\n    */\n\n    'backendTimezone' => 'UTC',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Back-end Skin\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the back-end skin to use.\n    |\n    */\n\n    'backendSkin' => 'Backend\\Skins\\Standard',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Determines which modules to load\n    |--------------------------------------------------------------------------\n    |\n    | Specify which modules should be registered when using the application.\n    |\n    */\n\n    'loadModules' => ['System', 'Backend', 'Cms'],\n\n    /*\n    |--------------------------------------------------------------------------\n    | Prevents application updates\n    |--------------------------------------------------------------------------\n    |\n    | If using composer or git to download updates to the core files, set this\n    | value to 'true' to prevent the update gateway from trying to download\n    | these files again as part of the application update process. Plugins\n    | and themes will still be downloaded.\n    |\n    */\n\n    'disableCoreUpdates' => false,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Specific plugins to disable\n    |--------------------------------------------------------------------------\n    |\n    | Specify plugin codes which will always be disabled in the application.\n    |\n    */\n\n    'disablePlugins' => [],\n\n    /*\n    |--------------------------------------------------------------------------\n    | Determines if the routing caching is enabled.\n    |--------------------------------------------------------------------------\n    |\n    | If the caching is enabled, the page URL map is saved in the cache. If a page\n    | URL was changed on the disk, the old URL value could be still saved in the cache.\n    | To update the cache the back-end Clear Cache feature should be used. It is recommended\n    | to disable the caching during the development, and enable it in the production mode.\n    |\n    */\n\n    'enableRoutesCache' => false,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Time to live for the URL map.\n    |--------------------------------------------------------------------------\n    |\n    | The URL map used in the CMS page routing process. By default\n    | the map is updated every time when a page is saved in the back-end or when the\n    | interval, in minutes, specified with the urlMapCacheTTL parameter expires.\n    |\n    */\n\n    'urlCacheTtl' => 10,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Time to live for parsed CMS objects.\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the number of minutes the CMS object cache lives. After the interval\n    | is expired item are re-cached. Note that items are re-cached automatically when\n    | the corresponding template file is modified.\n    |\n    */\n\n    'parsedPageCacheTTL' => 10,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Determines if the asset caching is enabled.\n    |--------------------------------------------------------------------------\n    |\n    | If the caching is enabled, combined assets are cached. If a asset file\n    | is changed on the disk, the old file contents could be still saved in the cache.\n    | To update the cache the back-end Clear Cache feature should be used. It is recommended\n    | to disable the caching during the development, and enable it in the production mode.\n    |\n    */\n\n    'enableAssetCache' => false,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Determines if the asset minification is enabled.\n    |--------------------------------------------------------------------------\n    |\n    | If the minification is enabled, combined assets are compressed (minified).\n    | It is recommended to disable the minification during development, and\n    | enable it in production mode. If set to null, assets are minified\n    | when debug mode (app.debug) is disabled.\n    |\n    */\n\n    'enableAssetMinify' => null,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Check import timestamps when combining assets\n    |--------------------------------------------------------------------------\n    |\n    | If deep hashing is enabled, the combiner cache will be reset when a change\n    | is detected on imported files, in addition to those referenced directly.\n    | This will cause slower page performance. If set to null, deep hashing\n    | is used when debug mode (app.debug) is enabled.\n    |\n    */\n\n    'enableAssetDeepHashing' => null,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Public plugins path\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the public plugins path relative to the application base URL,\n    | or you can specify a full URL path.\n    |\n    */\n\n    'pluginsPath' => '/plugins',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Public themes path\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the public themes path relative to the application base URL,\n    | or you can specify a full URL path.\n    |\n    */\n\n    'themesPath' => '/themes',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Resource storage\n    |--------------------------------------------------------------------------\n    |\n    | Specifies the configuration for resource storage, such as media and\n    | upload files. These resources are used:\n    |\n    | media   - generated by the media manager.\n    | uploads - generated by attachment model relationships.\n    |\n    | For each resource you can specify:\n    |\n    | disk   - filesystem disk, as specified in filesystems.php config.\n    | folder - a folder prefix for storing all generated files inside.\n    | path   - the public path relative to the application base URL,\n    |          or you can specify a full URL path.\n    */\n\n    'storage' => [\n\n        'uploads' => [\n            'disk'   => 'local',\n            'folder' => 'uploads',\n            'path'   => '/storage/app/uploads',\n        ],\n\n        'media' => [\n            'disk'   => 'local',\n            'folder' => 'media',\n            'path'   => '/storage/app/media',\n        ],\n\n    ],\n\n    /*\n    |--------------------------------------------------------------------------\n    | Convert Line Endings\n    |--------------------------------------------------------------------------\n    |\n    | Determines if October should convert line endings from the windows style\n    | \\r\\n to the unix style \\n.\n    |\n    */\n\n    'convertLineEndings' => false,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Linking policy\n    |--------------------------------------------------------------------------\n    |\n    | Controls how URL links are generated throughout the application.\n    |\n    | detect   - detect hostname and use the current schema\n    | secure   - detect hostname and force HTTPS schema\n    | insecure - detect hostname and force HTTP schema\n    | force    - force hostname and schema using app.url config value\n    |\n    */\n\n    'linkPolicy' => 'detect',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Default permission mask\n    |--------------------------------------------------------------------------\n    |\n    | Specifies a default file and folder permission for newly created objects.\n    |\n    */\n\n    'defaultMask' => ['file' => null, 'folder' => null],\n\n    /*\n    |--------------------------------------------------------------------------\n    | Safe mode\n    |--------------------------------------------------------------------------\n    |\n    | If safe mode is enabled, the PHP code section is disabled in the CMS\n    | for security reasons. If set to null, safe mode is enabled when\n    | debug mode (app.debug) is disabled.\n    |\n    */\n\n    'enableSafeMode' => null,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Cross Site Request Forgery (CSRF) Protection\n    |--------------------------------------------------------------------------\n    |\n    | If the CSRF protection is enabled, all \"postback\" requests are checked\n    | for a valid security token.\n    |\n    */\n\n    'enableCsrfProtection' => true,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Force bytecode invalidation\n    |--------------------------------------------------------------------------\n    |\n    | When using OPcache with opcache.validate_timestamps set to 0 or APC\n    | with apc.stat set to 0 and Twig cache enabled, clearing the template\n    | cache won't update the cache, set to true to get around this.\n    |\n    */\n\n    'forceBytecodeInvalidation' => true,\n\n];\n", "<?php namespace Cms\\Classes;\n\nuse Cms;\nuse Url;\nuse Str;\nuse App;\nuse File;\nuse View;\nuse Lang;\nuse Flash;\nuse Config;\nuse Session;\nuse Request;\nuse Response;\nuse Exception;\nuse BackendAuth;\nuse Twig_Environment;\nuse Twig_Cache_Filesystem;\nuse Cms\\Twig\\Loader as TwigLoader;\nuse Cms\\Twig\\DebugExtension;\nuse Cms\\Twig\\Extension as CmsTwigExtension;\nuse Cms\\Models\\MaintenanceSetting;\nuse System\\Models\\RequestLog;\nuse System\\Helpers\\View as ViewHelper;\nuse System\\Classes\\ErrorHandler;\nuse System\\Classes\\CombineAssets;\nuse System\\Twig\\Extension as SystemTwigExtension;\nuse October\\Rain\\Exception\\AjaxException;\nuse October\\Rain\\Exception\\SystemException;\nuse October\\Rain\\Exception\\ValidationException;\nuse October\\Rain\\Exception\\ApplicationException;\nuse October\\Rain\\Parse\\Bracket as TextParser;\nuse Illuminate\\Http\\RedirectResponse;\n\n/**\n * The CMS controller class.\n * The controller finds and serves requested pages.\n *\n * @package october\\cms\n * @author Alexey Bobkov, Samuel Georges\n */\nclass Controller\n{\n    use \\System\\Traits\\AssetMaker;\n    use \\System\\Traits\\EventEmitter;\n\n    /**\n     * @var \\Cms\\Classes\\Theme A reference to the CMS theme processed by the controller.\n     */\n    protected $theme;\n\n    /**\n     * @var \\Cms\\Classes\\Router A reference to the Router object.\n     */\n    protected $router;\n\n    /**\n     * @var \\Cms\\Twig\\Loader A reference to the Twig template loader.\n     */\n    protected $loader;\n\n    /**\n     * @var \\Cms\\Classes\\Page A reference to the CMS page template being processed.\n     */\n    protected $page;\n\n    /**\n     * @var \\Cms\\Classes\\CodeBase A reference to the CMS page code section object.\n     */\n    protected $pageObj;\n\n    /**\n     * @var \\Cms\\Classes\\Layout A reference to the CMS layout template used by the page.\n     */\n    protected $layout;\n\n    /**\n     * @var \\Cms\\Classes\\CodeBase A reference to the CMS layout code section object.\n     */\n    protected $layoutObj;\n\n    /**\n     * @var \\Twig_Environment Keeps the Twig environment object.\n     */\n    protected $twig;\n\n    /**\n     * @var string Contains the rendered page contents string.\n     */\n    protected $pageContents;\n\n    /**\n     * @var array A list of variables to pass to the page.\n     */\n    public $vars = [];\n\n    /**\n     * @var int Response status code\n     */\n    protected $statusCode = 200;\n\n    /**\n     * @var self Cache of self\n     */\n    protected static $instance = null;\n\n    /**\n     * @var \\Cms\\Classes\\ComponentBase Object of the active component, used internally.\n     */\n    protected $componentContext = null;\n\n    /**\n     * @var array Component partial stack, used internally.\n     */\n    protected $partialStack = [];\n\n    /**\n     * Creates the controller.\n     * @param \\Cms\\Classes\\Theme $theme Specifies the CMS theme.\n     * If the theme is not specified, the current active theme used.\n     */\n    public function __construct($theme = null)\n    {\n        $this->theme = $theme ? $theme : Theme::getActiveTheme();\n        if (!$this->theme) {\n            throw new CmsException(Lang::get('cms::lang.theme.active.not_found'));\n        }\n\n        $this->assetPath = Config::get('cms.themesPath', '/themes').'/'.$this->theme->getDirName();\n        $this->router = new Router($this->theme);\n        $this->partialStack = new PartialStack;\n        $this->initTwigEnvironment();\n\n        self::$instance = $this;\n    }\n\n    /**\n     * Finds and serves the requested page.\n     * If the page cannot be found, returns the page with the URL /404.\n     * If the /404 page doesn't exist, returns the system 404 page.\n     * @param string $url Specifies the requested page URL.\n     * If the parameter is omitted, the current URL used.\n     * @return string Returns the processed page content.\n     */\n    public function run($url = '/')\n    {\n        if ($url === null) {\n            $url = Request::path();\n        }\n\n        if (!strlen($url)) {\n            $url = '/';\n        }\n\n        /*\n         * Hidden page\n         */\n        $page = $this->router->findByUrl($url);\n        if ($page && $page->is_hidden) {\n            if (!BackendAuth::getUser()) {\n                $page = null;\n            }\n        }\n\n        /*\n         * Maintenance mode\n         */\n        if (\n            MaintenanceSetting::isConfigured() &&\n            MaintenanceSetting::get('is_enabled', false) &&\n            !BackendAuth::getUser()\n        ) {\n            if (!Request::ajax()) {\n                $this->setStatusCode(503);\n            }\n\n            $page = Page::loadCached($this->theme, MaintenanceSetting::get('cms_page'));\n        }\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.beforeDisplay', [$url, $page])) {\n            if ($event instanceof Page) {\n                $page = $event;\n            }\n            else {\n                return $event;\n            }\n        }\n\n        /*\n         * If the page was not found, render the 404 page - either provided by the theme or the built-in one.\n         */\n        if (!$page || $url === '404') {\n            if (!Request::ajax()) {\n                $this->setStatusCode(404);\n            }\n\n            // Log the 404 request\n            if (!App::runningUnitTests()) {\n                RequestLog::add();\n            }\n\n            if (!$page = $this->router->findByUrl('/404')) {\n                return Response::make(View::make('cms::404'), $this->statusCode);\n            }\n        }\n\n        /*\n         * Run the page\n         */\n        $result = $this->runPage($page);\n\n        /*\n         * Post-processing\n         */\n        $result = $this->postProcessResult($page, $url, $result);\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.display', [$url, $page, $result])) {\n            return $event;\n        }\n\n        if (!is_string($result)) {\n            return $result;\n        }\n\n        return Response::make($result, $this->statusCode);\n    }\n\n    /**\n     * Renders a page in its entirety, including component initialization.\n     * AJAX will be disabled for this process.\n     * @param string $pageFile Specifies the CMS page file name to run.\n     * @param array  $parameters  Routing parameters.\n     * @param \\Cms\\Classes\\Theme  $theme  Theme object\n     */\n    public static function render($pageFile, $parameters = [], $theme = null)\n    {\n        if (!$theme && (!$theme = Theme::getActiveTheme())) {\n            throw new CmsException(Lang::get('cms::lang.theme.active.not_found'));\n        }\n\n        $controller = new static($theme);\n        $controller->getRouter()->setParameters($parameters);\n\n        if (($page = Page::load($theme, $pageFile)) === null) {\n            throw new CmsException(Lang::get('cms::lang.page.not_found_name', ['name'=>$pageFile]));\n        }\n\n        return $controller->runPage($page, false);\n    }\n\n    /**\n     * Runs a page directly from its object and supplied parameters.\n     * @param \\Cms\\Classes\\Page $page Specifies the CMS page to run.\n     * @return string\n     */\n    public function runPage($page, $useAjax = true)\n    {\n        $this->page = $page;\n\n        /*\n         * If the page doesn't refer any layout, create the fallback layout.\n         * Otherwise load the layout specified in the page.\n         */\n        if (!$page->layout) {\n            $layout = Layout::initFallback($this->theme);\n        }\n        elseif (($layout = Layout::loadCached($this->theme, $page->layout)) === null) {\n            throw new CmsException(Lang::get('cms::lang.layout.not_found_name', ['name'=>$page->layout]));\n        }\n\n        $this->layout = $layout;\n\n        /*\n         * The 'this' variable is reserved for default variables.\n         */\n        $this->vars['this'] = [\n            'page'        => $this->page,\n            'layout'      => $this->layout,\n            'theme'       => $this->theme,\n            'param'       => $this->router->getParameters(),\n            'controller'  => $this,\n            'environment' => App::environment(),\n            'session'     => App::make('session'),\n        ];\n\n        /*\n         * Check for the presence of validation errors in the session.\n         */\n        $this->vars['errors'] = (Config::get('session.driver') && Session::has('errors'))\n            ? Session::get('errors')\n            : new \\Illuminate\\Support\\ViewErrorBag;\n\n        /*\n         * Handle AJAX requests and execute the life cycle functions\n         */\n        $this->initCustomObjects();\n\n        $this->initComponents();\n\n        /*\n         * Give the layout and page an opportunity to participate\n         * after components are initialized and before AJAX is handled.\n         */\n        if ($this->layoutObj) {\n            CmsException::mask($this->layout, 300);\n            $this->layoutObj->onInit();\n            CmsException::unmask();\n        }\n\n        CmsException::mask($this->page, 300);\n        $this->pageObj->onInit();\n        CmsException::unmask();\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.init', [$page])) {\n            return $event;\n        }\n\n        /*\n         * Execute AJAX event\n         */\n        if ($useAjax && $ajaxResponse = $this->execAjaxHandlers()) {\n            return $ajaxResponse;\n        }\n\n        /*\n         * Execute postback handler\n         */\n        if (\n            $useAjax &&\n            ($handler = post('_handler')) &&\n            ($this->verifyCsrfToken()) &&\n            ($handlerResponse = $this->runAjaxHandler($handler)) &&\n            $handlerResponse !== true\n        ) {\n            return $handlerResponse;\n        }\n\n        /*\n         * Execute page lifecycle\n         */\n        if ($cycleResponse = $this->execPageCycle()) {\n            return $cycleResponse;\n        }\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.beforeRenderPage', [$page])) {\n            $this->pageContents = $event;\n        }\n        else {\n            /*\n             * Render the page\n             */\n            CmsException::mask($this->page, 400);\n            $this->loader->setObject($this->page);\n            $template = $this->twig->loadTemplate($this->page->getFilePath());\n            $this->pageContents = $template->render($this->vars);\n            CmsException::unmask();\n        }\n\n        /*\n         * Render the layout\n         */\n        CmsException::mask($this->layout, 400);\n        $this->loader->setObject($this->layout);\n        $template = $this->twig->loadTemplate($this->layout->getFilePath());\n        $result = $template->render($this->vars);\n        CmsException::unmask();\n\n        return $result;\n    }\n\n    /**\n     * Invokes the current page cycle without rendering the page,\n     * used by AJAX handler that may rely on the logic inside the action.\n     */\n    public function pageCycle()\n    {\n        return $this->execPageCycle();\n    }\n\n    /**\n     * Executes the page life cycle.\n     * Creates an object from the PHP sections of the page and\n     * it's layout, then executes their life cycle functions.\n     */\n    protected function execPageCycle()\n    {\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.start')) {\n            return $event;\n        }\n\n        /*\n         * Run layout functions\n         */\n        if ($this->layoutObj) {\n            CmsException::mask($this->layout, 300);\n            $response = (\n                ($result = $this->layoutObj->onStart()) ||\n                ($result = $this->layout->runComponents()) ||\n                ($result = $this->layoutObj->onBeforePageStart())\n            ) ? $result : null;\n            CmsException::unmask();\n\n            if ($response) {\n                return $response;\n            }\n        }\n\n        /*\n         * Run page functions\n         */\n        CmsException::mask($this->page, 300);\n        $response = (\n            ($result = $this->pageObj->onStart()) ||\n            ($result = $this->page->runComponents()) ||\n            ($result = $this->pageObj->onEnd())\n        ) ? $result : null;\n        CmsException::unmask();\n\n        if ($response) {\n            return $response;\n        }\n\n        /*\n         * Run remaining layout functions\n         */\n        if ($this->layoutObj) {\n            CmsException::mask($this->layout, 300);\n            $response = ($result = $this->layoutObj->onEnd()) ? $result : null;\n            CmsException::unmask();\n        }\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.end')) {\n            return $event;\n        }\n\n        return $response;\n    }\n\n    /**\n     * Post-processes page HTML code before it's sent to the client.\n     * Note for pre-processing see cms.template.processTwigContent event.\n     * @param \\Cms\\Classes\\Page $page Specifies the current CMS page.\n     * @param string $url Specifies the current URL.\n     * @param string $content The page markup to post processs.\n     * @return string Returns the updated result string.\n     */\n    protected function postProcessResult($page, $url, $content)\n    {\n        $content = MediaViewHelper::instance()->processHtml($content);\n\n        $dataHolder = (object) ['content' => $content];\n\n        $this->fireSystemEvent('cms.page.postprocess', [$url, $page, $dataHolder]);\n\n        return $dataHolder->content;\n    }\n\n    //\n    // Initialization\n    //\n\n    /**\n     * Initializes the Twig environment and loader.\n     * Registers the \\Cms\\Twig\\Extension object with Twig.\n     * @return void\n     */\n    protected function initTwigEnvironment()\n    {\n        $this->loader = new TwigLoader;\n\n        $useCache = !Config::get('cms.twigNoCache');\n        $isDebugMode = Config::get('app.debug', false);\n        $forceBytecode = Config::get('cms.forceBytecodeInvalidation', false);\n\n        $options = [\n            'auto_reload' => true,\n            'debug' => $isDebugMode,\n        ];\n\n        if ($useCache) {\n            $options['cache'] = new Twig_Cache_Filesystem(\n                storage_path().'/cms/twig',\n                $forceBytecode ? Twig_Cache_Filesystem::FORCE_BYTECODE_INVALIDATION : 0\n            );\n        }\n\n        $this->twig = new Twig_Environment($this->loader, $options);\n        $this->twig->addExtension(new CmsTwigExtension($this));\n        $this->twig->addExtension(new SystemTwigExtension);\n\n        if ($isDebugMode) {\n            $this->twig->addExtension(new DebugExtension($this));\n        }\n    }\n\n    /**\n     * Initializes the custom layout and page objects.\n     * @return void\n     */\n    protected function initCustomObjects()\n    {\n        $this->layoutObj = null;\n\n        if (!$this->layout->isFallBack()) {\n            CmsException::mask($this->layout, 300);\n            $parser = new CodeParser($this->layout);\n            $this->layoutObj = $parser->source($this->page, $this->layout, $this);\n            CmsException::unmask();\n        }\n\n        CmsException::mask($this->page, 300);\n        $parser = new CodeParser($this->page);\n        $this->pageObj = $parser->source($this->page, $this->layout, $this);\n        CmsException::unmask();\n    }\n\n    /**\n     * Initializes the components for the layout and page.\n     * @return void\n     */\n    protected function initComponents()\n    {\n        if (!$this->layout->isFallBack()) {\n            foreach ($this->layout->settings['components'] as $component => $properties) {\n                list($name, $alias) = strpos($component, ' ')\n                    ? explode(' ', $component)\n                    : [$component, $component];\n\n                $this->addComponent($name, $alias, $properties, true);\n            }\n        }\n\n        foreach ($this->page->settings['components'] as $component => $properties) {\n            list($name, $alias) = strpos($component, ' ')\n                ? explode(' ', $component)\n                : [$component, $component];\n\n            $this->addComponent($name, $alias, $properties);\n        }\n\n        /*\n         * Extensibility\n         */\n        $this->fireSystemEvent('cms.page.initComponents', [$this->page, $this->layout]);\n    }\n\n    //\n    // AJAX\n    //\n\n    /**\n     * Returns the AJAX handler for the current request, if available.\n     * @return string\n     */\n    public function getAjaxHandler()\n    {\n        if (!Request::ajax() || Request::method() != 'POST') {\n            return null;\n        }\n\n        if ($handler = Request::header('X_OCTOBER_REQUEST_HANDLER')) {\n            return trim($handler);\n        }\n\n        return null;\n    }\n\n    /**\n     * Executes the page, layout, component and plugin AJAX handlers.\n     * @return mixed Returns the AJAX Response object or null.\n     */\n    protected function execAjaxHandlers()\n    {\n        if ($handler = $this->getAjaxHandler()) {\n            try {\n                /*\n                 * Validate the handler name\n                 */\n                if (!preg_match('/^(?:\\w+\\:{2})?on[A-Z]{1}[\\w+]*$/', $handler)) {\n                    throw new CmsException(Lang::get('cms::lang.ajax_handler.invalid_name', ['name'=>$handler]));\n                }\n\n                /*\n                 * Validate the handler partial list\n                 */\n                if ($partialList = trim(Request::header('X_OCTOBER_REQUEST_PARTIALS'))) {\n                    $partialList = explode('&', $partialList);\n\n                    foreach ($partialList as $partial) {\n                        if (!preg_match('/^(?:\\w+\\:{2}|@)?[a-z0-9\\_\\-\\.\\/]+$/i', $partial)) {\n                            throw new CmsException(Lang::get('cms::lang.partial.invalid_name', ['name'=>$partial]));\n                        }\n                    }\n                }\n                else {\n                    $partialList = [];\n                }\n\n                $responseContents = [];\n\n                /*\n                 * Execute the handler\n                 */\n                if (!$result = $this->runAjaxHandler($handler)) {\n                    throw new CmsException(Lang::get('cms::lang.ajax_handler.not_found', ['name'=>$handler]));\n                }\n\n                /*\n                 * Render partials and return the response as array that will be converted to JSON automatically.\n                 */\n                foreach ($partialList as $partial) {\n                    $responseContents[$partial] = $this->renderPartial($partial);\n                }\n\n                /*\n                 * If the handler returned a redirect, process the URL and dispose of it so\n                 * framework.js knows to redirect the browser and not the request!\n                 */\n                if ($result instanceof RedirectResponse) {\n                    $responseContents['X_OCTOBER_REDIRECT'] = $result->getTargetUrl();\n                    $result = null;\n                }\n                /*\n                 * No redirect is used, look for any flash messages\n                 */\n                elseif (Request::header('X_OCTOBER_REQUEST_FLASH') && Flash::check()) {\n                    $responseContents['X_OCTOBER_FLASH_MESSAGES'] = Flash::all();\n                }\n\n                /*\n                 * If the handler returned an array, we should add it to output for rendering.\n                 * If it is a string, add it to the array with the key \"result\".\n                 * If an object, pass it to Laravel as a response object.\n                 */\n                if (is_array($result)) {\n                    $responseContents = array_merge($responseContents, $result);\n                }\n                elseif (is_string($result)) {\n                    $responseContents['result'] = $result;\n                }\n                elseif (is_object($result)) {\n                    return $result;\n                }\n\n                return Response::make($responseContents, $this->statusCode);\n            }\n            catch (ValidationException $ex) {\n                /*\n                 * Handle validation errors\n                 */\n                $responseContents['X_OCTOBER_ERROR_FIELDS'] = $ex->getFields();\n                $responseContents['X_OCTOBER_ERROR_MESSAGE'] = $ex->getMessage();\n                throw new AjaxException($responseContents);\n            }\n            catch (Exception $ex) {\n                throw $ex;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Tries to find and run an AJAX handler in the page, layout, components and plugins.\n     * The method stops as soon as the handler is found.\n     * @param string $handler name of the ajax handler\n     * @return boolean Returns true if the handler was found. Returns false otherwise.\n     */\n    protected function runAjaxHandler($handler)\n    {\n        /*\n         * Process Component handler\n         */\n        if (strpos($handler, '::')) {\n\n            list($componentName, $handlerName) = explode('::', $handler);\n            $componentObj = $this->findComponentByName($componentName);\n\n            if ($componentObj && $componentObj->methodExists($handlerName)) {\n                $this->componentContext = $componentObj;\n                $result = $componentObj->runAjaxHandler($handlerName);\n                return ($result) ?: true;\n            }\n        }\n        /*\n         * Process code section handler\n         */\n        else {\n            if (method_exists($this->pageObj, $handler)) {\n                $result = $this->pageObj->$handler();\n                return ($result) ?: true;\n            }\n\n            if (!$this->layout->isFallBack() && method_exists($this->layoutObj, $handler)) {\n                $result = $this->layoutObj->$handler();\n                return ($result) ?: true;\n            }\n\n            /*\n             * Cycle each component to locate a usable handler\n             */\n            if (($componentObj = $this->findComponentByHandler($handler)) !== null) {\n                $this->componentContext = $componentObj;\n                $result = $componentObj->runAjaxHandler($handler);\n                return ($result) ?: true;\n            }\n        }\n\n        /*\n         * Generic handler that does nothing\n         */\n        if ($handler == 'onAjax') {\n            return true;\n        }\n\n        return false;\n    }\n\n    //\n    // Rendering\n    //\n\n    /**\n     * Renders a requested page.\n     * The framework uses this method internally.\n     */\n    public function renderPage()\n    {\n        $contents = $this->pageContents;\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.render', [$contents])) {\n            return $event;\n        }\n\n        return $contents;\n    }\n\n    /**\n     * Renders a requested partial.\n     * The framework uses this method internally.\n     * @param string $name The view to load.\n     * @param array $parameters Parameter variables to pass to the view.\n     * @param bool $throwException Throw an exception if the partial is not found.\n     * @return mixed Partial contents or false if not throwing an exception.\n     */\n    public function renderPartial($name, $parameters = [], $throwException = true)\n    {\n        $vars = $this->vars;\n        $this->vars = array_merge($this->vars, $parameters);\n\n        /*\n         * Alias @ symbol for ::\n         */\n        if (substr($name, 0, 1) == '@') {\n            $name = '::' . substr($name, 1);\n        }\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.beforeRenderPartial', [$name])) {\n            $partial = $event;\n        }\n        /*\n         * Process Component partial\n         */\n        elseif (strpos($name, '::') !== false) {\n\n            list($componentAlias, $partialName) = explode('::', $name);\n\n            /*\n             * Component alias not supplied\n             */\n            if (!strlen($componentAlias)) {\n                if ($this->componentContext !== null) {\n                    $componentObj = $this->componentContext;\n                }\n                elseif (($componentObj = $this->findComponentByPartial($partialName)) === null) {\n                    if ($throwException) {\n                        throw new CmsException(Lang::get('cms::lang.partial.not_found_name', ['name'=>$partialName]));\n                    }\n                    else {\n                        return false;\n                    }\n                }\n            }\n            /*\n             * Component alias is supplied\n             */\n            else {\n                if (($componentObj = $this->findComponentByName($componentAlias)) === null) {\n                    if ($throwException) {\n                        throw new CmsException(Lang::get('cms::lang.component.not_found', ['name'=>$componentAlias]));\n                    }\n                    else {\n                        return false;\n                    }\n                }\n            }\n\n            $partial = null;\n            $this->componentContext = $componentObj;\n\n            /*\n             * Check if the theme has an override\n             */\n            if (strpos($partialName, '/') === false) {\n                $partial = ComponentPartial::loadOverrideCached($this->theme, $componentObj, $partialName);\n            }\n\n            /*\n             * Check the component partial\n             */\n            if ($partial === null) {\n                $partial = ComponentPartial::loadCached($componentObj, $partialName);\n            }\n\n            if ($partial === null) {\n                if ($throwException) {\n                    throw new CmsException(Lang::get('cms::lang.partial.not_found_name', ['name'=>$name]));\n                }\n                else {\n                    return false;\n                }\n            }\n\n            /*\n             * Set context for self access\n             */\n            $this->vars['__SELF__'] = $componentObj;\n        }\n        else {\n            /*\n             * Process theme partial\n             */\n            if (($partial = Partial::loadCached($this->theme, $name)) === null) {\n                if ($throwException) {\n                    throw new CmsException(Lang::get('cms::lang.partial.not_found_name', ['name'=>$name]));\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n\n        /*\n         * Run functions for CMS partials only (Cms\\Classes\\Partial)\n         */\n        if ($partial instanceof Partial) {\n            $this->partialStack->stackPartial();\n\n            $manager = ComponentManager::instance();\n\n            foreach ($partial->settings['components'] as $component => $properties) {\n                // Do not inject the viewBag component to the environment.\n                // Not sure if they're needed there by the requirements,\n                // but there were problems with array-typed properties used by Static Pages\n                // snippets and setComponentPropertiesFromParams(). --ab\n                if ($component == 'viewBag') {\n                    continue;\n                }\n\n                list($name, $alias) = strpos($component, ' ')\n                    ? explode(' ', $component)\n                    : [$component, $component];\n\n                if (!$componentObj = $manager->makeComponent($name, $this->pageObj, $properties)) {\n                    throw new CmsException(Lang::get('cms::lang.component.not_found', ['name'=>$name]));\n                }\n\n                $componentObj->alias = $alias;\n                $parameters[$alias] = $partial->components[$alias] = $componentObj;\n\n                $this->partialStack->addComponent($alias, $componentObj);\n\n                $this->setComponentPropertiesFromParams($componentObj, $parameters);\n                $componentObj->init();\n            }\n\n            CmsException::mask($this->page, 300);\n            $parser = new CodeParser($partial);\n            $partialObj = $parser->source($this->page, $this->layout, $this);\n            CmsException::unmask();\n\n            CmsException::mask($partial, 300);\n            $partialObj->onStart();\n            $partial->runComponents();\n            $partialObj->onEnd();\n            CmsException::unmask();\n        }\n\n        /*\n         * Render the partial\n         */\n        CmsException::mask($partial, 400);\n        $this->loader->setObject($partial);\n        $template = $this->twig->loadTemplate($partial->getFilePath());\n        $partialContent = $template->render(array_merge($this->vars, $parameters));\n        CmsException::unmask();\n\n        if ($partial instanceof Partial) {\n            $this->partialStack->unstackPartial();\n        }\n\n        $this->vars = $vars;\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.renderPartial', [$name, &$partialContent])) {\n            return $event;\n        }\n\n        return $partialContent;\n    }\n\n    /**\n     * Renders a requested content file.\n     * The framework uses this method internally.\n     * @param string $name The content view to load.\n     * @param array $parameters Parameter variables to pass to the view.\n     * @return string\n     */\n    public function renderContent($name, $parameters = [])\n    {\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.beforeRenderContent', [$name])) {\n            $content = $event;\n        }\n        /*\n         * Load content from theme\n         */\n        elseif (($content = Content::loadCached($this->theme, $name)) === null) {\n            throw new CmsException(Lang::get('cms::lang.content.not_found_name', ['name'=>$name]));\n        }\n\n        $fileContent = $content->parsedMarkup;\n\n        /*\n         * Inject global view variables\n         */\n        $globalVars = ViewHelper::getGlobalVars();\n        if (!empty($globalVars)) {\n            $parameters = (array) $parameters + $globalVars;\n        }\n\n        /*\n         * Parse basic template variables\n         */\n        if (!empty($parameters)) {\n            $fileContent = TextParser::parse($fileContent, $parameters);\n        }\n\n        /*\n         * Extensibility\n         */\n        if ($event = $this->fireSystemEvent('cms.page.renderContent', [$name, &$fileContent])) {\n            return $event;\n        }\n\n        return $fileContent;\n    }\n\n    /**\n     * Renders a component's default content, preserves the previous component context.\n     * @param $name\n     * @param array $parameters\n     * @return string Returns the component default contents.\n     */\n    public function renderComponent($name, $parameters = [])\n    {\n        $result = null;\n        $previousContext = $this->componentContext;\n\n        if ($componentObj = $this->findComponentByName($name)) {\n            $componentObj->id = uniqid($name);\n            $componentObj->setProperties(array_merge($componentObj->getProperties(), $parameters));\n            $this->componentContext = $componentObj;\n            $result = $componentObj->onRender();\n        }\n\n        if (!$result) {\n            $result = $this->renderPartial($name.'::default', [], false);\n        }\n\n        $this->componentContext = $previousContext;\n        return $result;\n    }\n\n    //\n    // Setters\n    //\n\n    /**\n     * Sets the status code for the current web response.\n     * @param int $code Status code\n     * @return self\n     */\n    public function setStatusCode($code)\n    {\n        $this->statusCode = (int) $code;\n        return $this;\n    }\n\n    //\n    // Getters\n    //\n\n     /**\n     * Returns the status code for the current web response.\n     * @return int Status code\n     */\n    public function getStatusCode()\n    {\n        return $this->statusCode;\n    }\n\n    /**\n     * Returns an existing instance of the controller.\n     * If the controller doesn't exists, returns null.\n     * @return mixed Returns the controller object or null.\n     */\n    public static function getController()\n    {\n        return self::$instance;\n    }\n\n    /**\n     * Returns the current CMS theme.\n     * @return \\Cms\\Classes\\Theme\n     */\n    public function getTheme()\n    {\n        return $this->theme;\n    }\n\n    /**\n     * Returns the Twig environment.\n     * @return Twig_Environment\n     */\n    public function getTwig()\n    {\n        return $this->twig;\n    }\n\n    /**\n     * Returns the Twig loader.\n     * @return \\Cms\\Twig\\Loader\n     */\n    public function getLoader()\n    {\n        return $this->loader;\n    }\n\n    /**\n     * Returns the routing object.\n     * @return \\Cms\\Classes\\Router\n     */\n    public function getRouter()\n    {\n        return $this->router;\n    }\n\n    /**\n     * Intended to be called from the layout, returns the page code base object.\n     * @return \\Cms\\Classes\\CodeBase\n     */\n    public function getPageObject()\n    {\n        return $this->pageObj;\n    }\n\n    /**\n     * Returns the CMS page object being processed by the controller.\n     * The object is not available on the early stages of the controller\n     * initialization.\n     * @return \\Cms\\Classes\\Page Returns the Page object or null.\n     */\n    public function getPage()\n    {\n        return $this->page;\n    }\n\n    /**\n     * Intended to be called from the page, returns the layout code base object.\n     * @return \\Cms\\Classes\\CodeBase\n     */\n    public function getLayoutObject()\n    {\n        return $this->layoutObj;\n    }\n\n    //\n    // Page helpers\n    //\n\n    /**\n     * Looks up the URL for a supplied page and returns it relative to the website root.\n     *\n     * @param mixed $name Specifies the Cms Page file name.\n     * @param array $parameters Route parameters to consider in the URL.\n     * @param bool $routePersistence By default the existing routing parameters will be included\n     * @return string\n     */\n    public function pageUrl($name, $parameters = [], $routePersistence = true)\n    {\n        if (!$name) {\n            return $this->currentPageUrl($parameters, $routePersistence);\n        }\n\n        /*\n         * Second parameter can act as third\n         */\n        if (is_bool($parameters)) {\n            $routePersistence = $parameters;\n        }\n\n        if (!is_array($parameters)) {\n            $parameters = [];\n        }\n\n        if ($routePersistence) {\n            $parameters = array_merge($this->router->getParameters(), $parameters);\n        }\n\n        if (!$url = $this->router->findByFile($name, $parameters)) {\n            return null;\n        }\n\n        return Cms::url($url);\n    }\n\n    /**\n     * Looks up the current page URL with supplied parameters and route persistence.\n     * @param array $parameters\n     * @param bool $routePersistence\n     * @return null|string\n     */\n    public function currentPageUrl($parameters = [], $routePersistence = true)\n    {\n        if (!$currentFile = $this->page->getFileName()) {\n            return null;\n        }\n\n        return $this->pageUrl($currentFile, $parameters, $routePersistence);\n    }\n\n    /**\n     * Converts supplied URL to a theme URL relative to the website root. If the URL provided is an\n     * array then the files will be combined.\n     * @param mixed $url Specifies the theme-relative URL. If null, the theme path is returned.\n     * @return string\n     */\n    public function themeUrl($url = null)\n    {\n        $themeDir = $this->getTheme()->getDirName();\n\n        if (is_array($url)) {\n            $_url = Url::to(CombineAssets::combine($url, themes_path().'/'.$themeDir));\n        }\n        else {\n            $_url = Config::get('cms.themesPath', '/themes').'/'.$themeDir;\n            if ($url !== null) {\n                $_url .= '/'.$url;\n            }\n            $_url = Url::asset($_url);\n        }\n\n        return $_url;\n    }\n\n    /**\n     * Returns a routing parameter.\n     * @param string $name Routing parameter name.\n     * @param string $default Default to use if none is found.\n     * @return string\n     */\n    public function param($name, $default = null)\n    {\n        return $this->router->getParameter($name, $default);\n    }\n\n    //\n    // Component helpers\n    //\n\n    /**\n     * Adds a component to the page object\n     * @param mixed  $name        Component class name or short name\n     * @param string $alias       Alias to give the component\n     * @param array  $properties  Component properties\n     * @param bool   $addToLayout Add to layout, instead of page\n     * @return ComponentBase Component object\n     */\n    public function addComponent($name, $alias, $properties, $addToLayout = false)\n    {\n        $manager = ComponentManager::instance();\n\n        if ($addToLayout) {\n            if (!$componentObj = $manager->makeComponent($name, $this->layoutObj, $properties)) {\n                throw new CmsException(Lang::get('cms::lang.component.not_found', ['name'=>$name]));\n            }\n\n            $componentObj->alias = $alias;\n            $this->vars[$alias] = $this->layout->components[$alias] = $componentObj;\n        }\n        else {\n            if (!$componentObj = $manager->makeComponent($name, $this->pageObj, $properties)) {\n                throw new CmsException(Lang::get('cms::lang.component.not_found', ['name'=>$name]));\n            }\n\n            $componentObj->alias = $alias;\n            $this->vars[$alias] = $this->page->components[$alias] = $componentObj;\n        }\n\n        $this->setComponentPropertiesFromParams($componentObj);\n        $componentObj->init();\n        return $componentObj;\n    }\n\n    /**\n     * Searches the layout and page components by an alias\n     * @param $name\n     * @return ComponentBase The component object, if found\n     */\n    public function findComponentByName($name)\n    {\n        if (isset($this->page->components[$name])) {\n            return $this->page->components[$name];\n        }\n\n        if (isset($this->layout->components[$name])) {\n            return $this->layout->components[$name];\n        }\n\n        $partialComponent = $this->partialStack->getComponent($name);\n        if ($partialComponent !== null) {\n            return $partialComponent;\n        }\n\n        return null;\n    }\n\n    /**\n     * Searches the layout and page components by an AJAX handler\n     * @param string $handler\n     * @return ComponentBase The component object, if found\n     */\n    public function findComponentByHandler($handler)\n    {\n        foreach ($this->page->components as $component) {\n            if ($component->methodExists($handler)) {\n                return $component;\n            }\n        }\n\n        foreach ($this->layout->components as $component) {\n            if ($component->methodExists($handler)) {\n                return $component;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Searches the layout and page components by a partial file\n     * @param string $partial\n     * @return ComponentBase The component object, if found\n     */\n    public function findComponentByPartial($partial)\n    {\n        foreach ($this->page->components as $component) {\n            if (ComponentPartial::check($component, $partial)) {\n                return $component;\n            }\n        }\n\n        foreach ($this->layout->components as $component) {\n            if (ComponentPartial::check($component, $partial)) {\n                return $component;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Set the component context manually, used by Components when calling renderPartial.\n     * @param ComponentBase $component\n     * @return void\n     */\n    public function setComponentContext(ComponentBase $component = null)\n    {\n        $this->componentContext = $component;\n    }\n\n    /**\n     * Sets component property values from partial parameters.\n     * The property values should be defined as {{ param }}.\n     * @param ComponentBase $component The component object.\n     * @param array $parameters Specifies the partial parameters.\n     */\n    protected function setComponentPropertiesFromParams($component, $parameters = [])\n    {\n        $properties = $component->getProperties();\n        $routerParameters = $this->router->getParameters();\n\n        foreach ($properties as $propertyName => $propertyValue) {\n            if (is_array($propertyValue)) {\n                continue;\n            }\n\n            $matches = [];\n            if (preg_match('/^\\{\\{([^\\}]+)\\}\\}$/', $propertyValue, $matches)) {\n                $paramName = trim($matches[1]);\n\n                if (substr($paramName, 0, 1) == ':') {\n                    $routeParamName = substr($paramName, 1);\n                    $newPropertyValue = array_key_exists($routeParamName, $routerParameters)\n                        ? $routerParameters[$routeParamName]\n                        : null;\n\n                }\n                else {\n                    $newPropertyValue = array_key_exists($paramName, $parameters)\n                        ? $parameters[$paramName]\n                        : null;\n                }\n\n                $component->setProperty($propertyName, $newPropertyValue);\n                $component->setExternalPropertyName($propertyName, $paramName);\n            }\n        }\n    }\n\n    //\n    // Security\n    //\n\n    /**\n     * Checks the request data / headers for a valid CSRF token.\n     * Returns false if a valid token is not found. Override this\n     * method to disable the check.\n     * @return bool\n     */\n    protected function verifyCsrfToken()\n    {\n        if (!Config::get('cms.enableCsrfProtection')) {\n            return true;\n        }\n\n        if (in_array(Request::method(), ['HEAD', 'GET', 'OPTIONS'])) {\n            return true;\n        }\n\n        $token = Request::input('_token') ?: Request::header('X-CSRF-TOKEN');\n\n        return hash_equals(\n            Session::token(),\n            $token\n        );\n    }\n}\n"], "filenames": ["config/cms.php", "modules/cms/classes/Controller.php"], "buggy_code_start_loc": [335, 339], "buggy_code_end_loc": [336, 1357], "fixing_code_start_loc": [335, 340], "fixing_code_end_loc": [336, 1387], "type": "CWE-352", "message": "Cross-Site Request Forgery exists in OctoberCMS 1.0.426 (aka Build 426) due to improper validation of CSRF tokens for postback handling, allowing an attacker to successfully take over the victim's account. The attack bypasses a protection mechanism involving X-CSRF headers and CSRF tokens via a certain _handler postback variable.", "other": {"cve": {"id": "CVE-2017-16244", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-01T01:29:00.980", "lastModified": "2020-08-03T12:15:48.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-Site Request Forgery exists in OctoberCMS 1.0.426 (aka Build 426) due to improper validation of CSRF tokens for postback handling, allowing an attacker to successfully take over the victim's account. The attack bypasses a protection mechanism involving X-CSRF headers and CSRF tokens via a certain _handler postback variable."}, {"lang": "es", "value": "Existe Cross-Site Request Forgery (CSRF) en OctoberCMS 1.0.426 (tambi\u00e9n conocido como Build 426) debido a la validaci\u00f3n incorrecta de tokens CSRF para la gesti\u00f3n de postback, lo que permite que un atacante consiga controlar la cuenta de la v\u00edctima. El ataque omite un mecanismo de protecci\u00f3n que implica cabeceras X-CSRF y tokens CSRF mediante una determinada variable de postback _handler."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:1.0.426:*:*:*:*:*:*:*", "matchCriteriaId": "07538645-52CC-4A5F-BF22-4B653C34DC6E"}]}]}], "references": [{"url": "https://github.com/octobercms/october/commit/4a6e0e1e0e2c3facebc17e0db38c5b4d4cb05bd0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/43106/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/octobercms/october/commit/4a6e0e1e0e2c3facebc17e0db38c5b4d4cb05bd0"}}