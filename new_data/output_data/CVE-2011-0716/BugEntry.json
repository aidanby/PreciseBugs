{"buggy_code": ["/*\n * Bridge multicast support.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <linux/err.h>\n#include <linux/if_ether.h>\n#include <linux/igmp.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/netdevice.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <net/ip.h>\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n#include <net/ipv6.h>\n#include <net/mld.h>\n#include <net/addrconf.h>\n#include <net/ip6_checksum.h>\n#endif\n\n#include \"br_private.h\"\n\n#define mlock_dereference(X, br) \\\n\trcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic inline int ipv6_is_local_multicast(const struct in6_addr *addr)\n{\n\tif (ipv6_addr_is_multicast(addr) &&\n\t    IPV6_ADDR_MC_SCOPE(addr) <= IPV6_ADDR_SCOPE_LINKLOCAL)\n\t\treturn 1;\n\treturn 0;\n}\n#endif\n\nstatic inline int br_ip_equal(const struct br_ip *a, const struct br_ip *b)\n{\n\tif (a->proto != b->proto)\n\t\treturn 0;\n\tswitch (a->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn a->u.ip4 == b->u.ip4;\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tcase htons(ETH_P_IPV6):\n\t\treturn ipv6_addr_equal(&a->u.ip6, &b->u.ip6);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic inline int __br_ip4_hash(struct net_bridge_mdb_htable *mdb, __be32 ip)\n{\n\treturn jhash_1word(mdb->secret, (__force u32)ip) & (mdb->max - 1);\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic inline int __br_ip6_hash(struct net_bridge_mdb_htable *mdb,\n\t\t\t\tconst struct in6_addr *ip)\n{\n\treturn jhash2((__force u32 *)ip->s6_addr32, 4, mdb->secret) & (mdb->max - 1);\n}\n#endif\n\nstatic inline int br_ip_hash(struct net_bridge_mdb_htable *mdb,\n\t\t\t     struct br_ip *ip)\n{\n\tswitch (ip->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn __br_ip4_hash(mdb, ip->u.ip4);\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tcase htons(ETH_P_IPV6):\n\t\treturn __br_ip6_hash(mdb, &ip->u.ip6);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic struct net_bridge_mdb_entry *__br_mdb_ip_get(\n\tstruct net_bridge_mdb_htable *mdb, struct br_ip *dst, int hash)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *p;\n\n\thlist_for_each_entry_rcu(mp, p, &mdb->mhash[hash], hlist[mdb->ver]) {\n\t\tif (br_ip_equal(&mp->addr, dst))\n\t\t\treturn mp;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct net_bridge_mdb_entry *br_mdb_ip_get(\n\tstruct net_bridge_mdb_htable *mdb, struct br_ip *dst)\n{\n\tif (!mdb)\n\t\treturn NULL;\n\n\treturn __br_mdb_ip_get(mdb, dst, br_ip_hash(mdb, dst));\n}\n\nstatic struct net_bridge_mdb_entry *br_mdb_ip4_get(\n\tstruct net_bridge_mdb_htable *mdb, __be32 dst)\n{\n\tstruct br_ip br_dst;\n\n\tbr_dst.u.ip4 = dst;\n\tbr_dst.proto = htons(ETH_P_IP);\n\n\treturn br_mdb_ip_get(mdb, &br_dst);\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic struct net_bridge_mdb_entry *br_mdb_ip6_get(\n\tstruct net_bridge_mdb_htable *mdb, const struct in6_addr *dst)\n{\n\tstruct br_ip br_dst;\n\n\tipv6_addr_copy(&br_dst.u.ip6, dst);\n\tbr_dst.proto = htons(ETH_P_IPV6);\n\n\treturn br_mdb_ip_get(mdb, &br_dst);\n}\n#endif\n\nstruct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);\n\tstruct br_ip ip;\n\n\tif (br->multicast_disabled)\n\t\treturn NULL;\n\n\tif (BR_INPUT_SKB_CB(skb)->igmp)\n\t\treturn NULL;\n\n\tip.proto = skb->protocol;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tip.u.ip4 = ip_hdr(skb)->daddr;\n\t\tbreak;\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tcase htons(ETH_P_IPV6):\n\t\tipv6_addr_copy(&ip.u.ip6, &ipv6_hdr(skb)->daddr);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn br_mdb_ip_get(mdb, &ip);\n}\n\nstatic void br_mdb_free(struct rcu_head *head)\n{\n\tstruct net_bridge_mdb_htable *mdb =\n\t\tcontainer_of(head, struct net_bridge_mdb_htable, rcu);\n\tstruct net_bridge_mdb_htable *old = mdb->old;\n\n\tmdb->old = NULL;\n\tkfree(old->mhash);\n\tkfree(old);\n}\n\nstatic int br_mdb_copy(struct net_bridge_mdb_htable *new,\n\t\t       struct net_bridge_mdb_htable *old,\n\t\t       int elasticity)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *p;\n\tint maxlen;\n\tint len;\n\tint i;\n\n\tfor (i = 0; i < old->max; i++)\n\t\thlist_for_each_entry(mp, p, &old->mhash[i], hlist[old->ver])\n\t\t\thlist_add_head(&mp->hlist[new->ver],\n\t\t\t\t       &new->mhash[br_ip_hash(new, &mp->addr)]);\n\n\tif (!elasticity)\n\t\treturn 0;\n\n\tmaxlen = 0;\n\tfor (i = 0; i < new->max; i++) {\n\t\tlen = 0;\n\t\thlist_for_each_entry(mp, p, &new->mhash[i], hlist[new->ver])\n\t\t\tlen++;\n\t\tif (len > maxlen)\n\t\t\tmaxlen = len;\n\t}\n\n\treturn maxlen > elasticity ? -EINVAL : 0;\n}\n\nstatic void br_multicast_free_pg(struct rcu_head *head)\n{\n\tstruct net_bridge_port_group *p =\n\t\tcontainer_of(head, struct net_bridge_port_group, rcu);\n\n\tkfree(p);\n}\n\nstatic void br_multicast_free_group(struct rcu_head *head)\n{\n\tstruct net_bridge_mdb_entry *mp =\n\t\tcontainer_of(head, struct net_bridge_mdb_entry, rcu);\n\n\tkfree(mp);\n}\n\nstatic void br_multicast_group_expired(unsigned long data)\n{\n\tstruct net_bridge_mdb_entry *mp = (void *)data;\n\tstruct net_bridge *br = mp->br;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || timer_pending(&mp->timer))\n\t\tgoto out;\n\n\tif (!hlist_unhashed(&mp->mglist))\n\t\thlist_del_init(&mp->mglist);\n\n\tif (mp->ports)\n\t\tgoto out;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\thlist_del_rcu(&mp->hlist[mdb->ver]);\n\tmdb->size--;\n\n\tdel_timer(&mp->query_timer);\n\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tdel_timer(&p->query_timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\n\t\tif (!mp->ports && hlist_unhashed(&mp->mglist) &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\n\t\treturn;\n\t}\n\n\tWARN_ON(1);\n}\n\nstatic void br_multicast_port_group_expired(unsigned long data)\n{\n\tstruct net_bridge_port_group *pg = (void *)data;\n\tstruct net_bridge *br = pg->port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || timer_pending(&pg->timer) ||\n\t    hlist_unhashed(&pg->mglist))\n\t\tgoto out;\n\n\tbr_multicast_del_pg(br, pg);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic int br_mdb_rehash(struct net_bridge_mdb_htable __rcu **mdbp, int max,\n\t\t\t int elasticity)\n{\n\tstruct net_bridge_mdb_htable *old = rcu_dereference_protected(*mdbp, 1);\n\tstruct net_bridge_mdb_htable *mdb;\n\tint err;\n\n\tmdb = kmalloc(sizeof(*mdb), GFP_ATOMIC);\n\tif (!mdb)\n\t\treturn -ENOMEM;\n\n\tmdb->max = max;\n\tmdb->old = old;\n\n\tmdb->mhash = kzalloc(max * sizeof(*mdb->mhash), GFP_ATOMIC);\n\tif (!mdb->mhash) {\n\t\tkfree(mdb);\n\t\treturn -ENOMEM;\n\t}\n\n\tmdb->size = old ? old->size : 0;\n\tmdb->ver = old ? old->ver ^ 1 : 0;\n\n\tif (!old || elasticity)\n\t\tget_random_bytes(&mdb->secret, sizeof(mdb->secret));\n\telse\n\t\tmdb->secret = old->secret;\n\n\tif (!old)\n\t\tgoto out;\n\n\terr = br_mdb_copy(mdb, old, elasticity);\n\tif (err) {\n\t\tkfree(mdb->mhash);\n\t\tkfree(mdb);\n\t\treturn err;\n\t}\n\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\trcu_assign_pointer(*mdbp, mdb);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *br_ip4_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\t    __be32 group)\n{\n\tstruct sk_buff *skb;\n\tstruct igmphdr *ih;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\n\tskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*iph) +\n\t\t\t\t\t\t sizeof(*ih) + 4);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->protocol = htons(ETH_P_IP);\n\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tmemcpy(eth->h_source, br->dev->dev_addr, 6);\n\teth->h_dest[0] = 1;\n\teth->h_dest[1] = 0;\n\teth->h_dest[2] = 0x5e;\n\teth->h_dest[3] = 0;\n\teth->h_dest[4] = 0;\n\teth->h_dest[5] = 1;\n\teth->h_proto = htons(ETH_P_IP);\n\tskb_put(skb, sizeof(*eth));\n\n\tskb_set_network_header(skb, skb->len);\n\tiph = ip_hdr(skb);\n\n\tiph->version = 4;\n\tiph->ihl = 6;\n\tiph->tos = 0xc0;\n\tiph->tot_len = htons(sizeof(*iph) + sizeof(*ih) + 4);\n\tiph->id = 0;\n\tiph->frag_off = htons(IP_DF);\n\tiph->ttl = 1;\n\tiph->protocol = IPPROTO_IGMP;\n\tiph->saddr = 0;\n\tiph->daddr = htonl(INADDR_ALLHOSTS_GROUP);\n\t((u8 *)&iph[1])[0] = IPOPT_RA;\n\t((u8 *)&iph[1])[1] = 4;\n\t((u8 *)&iph[1])[2] = 0;\n\t((u8 *)&iph[1])[3] = 0;\n\tip_send_check(iph);\n\tskb_put(skb, 24);\n\n\tskb_set_transport_header(skb, skb->len);\n\tih = igmp_hdr(skb);\n\tih->type = IGMP_HOST_MEMBERSHIP_QUERY;\n\tih->code = (group ? br->multicast_last_member_interval :\n\t\t\t    br->multicast_query_response_interval) /\n\t\t   (HZ / IGMP_TIMER_SCALE);\n\tih->group = group;\n\tih->csum = 0;\n\tih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));\n\tskb_put(skb, sizeof(*ih));\n\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic struct sk_buff *br_ip6_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\t    struct in6_addr *group)\n{\n\tstruct sk_buff *skb;\n\tstruct ipv6hdr *ip6h;\n\tstruct mld_msg *mldq;\n\tstruct ethhdr *eth;\n\tu8 *hopopt;\n\tunsigned long interval;\n\n\tskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*ip6h) +\n\t\t\t\t\t\t 8 + sizeof(*mldq));\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\t/* Ethernet header */\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tmemcpy(eth->h_source, br->dev->dev_addr, 6);\n\tipv6_eth_mc_map(group, eth->h_dest);\n\teth->h_proto = htons(ETH_P_IPV6);\n\tskb_put(skb, sizeof(*eth));\n\n\t/* IPv6 header + HbH option */\n\tskb_set_network_header(skb, skb->len);\n\tip6h = ipv6_hdr(skb);\n\n\t*(__force __be32 *)ip6h = htonl(0x60000000);\n\tip6h->payload_len = htons(8 + sizeof(*mldq));\n\tip6h->nexthdr = IPPROTO_HOPOPTS;\n\tip6h->hop_limit = 1;\n\tipv6_addr_set(&ip6h->saddr, 0, 0, 0, 0);\n\tipv6_addr_set(&ip6h->daddr, htonl(0xff020000), 0, 0, htonl(1));\n\n\thopopt = (u8 *)(ip6h + 1);\n\thopopt[0] = IPPROTO_ICMPV6;\t\t/* next hdr */\n\thopopt[1] = 0;\t\t\t\t/* length of HbH */\n\thopopt[2] = IPV6_TLV_ROUTERALERT;\t/* Router Alert */\n\thopopt[3] = 2;\t\t\t\t/* Length of RA Option */\n\thopopt[4] = 0;\t\t\t\t/* Type = 0x0000 (MLD) */\n\thopopt[5] = 0;\n\thopopt[6] = IPV6_TLV_PAD0;\t\t/* Pad0 */\n\thopopt[7] = IPV6_TLV_PAD0;\t\t/* Pad0 */\n\n\tskb_put(skb, sizeof(*ip6h) + 8);\n\n\t/* ICMPv6 */\n\tskb_set_transport_header(skb, skb->len);\n\tmldq = (struct mld_msg *) icmp6_hdr(skb);\n\n\tinterval = ipv6_addr_any(group) ? br->multicast_last_member_interval :\n\t\t\t\t\t  br->multicast_query_response_interval;\n\n\tmldq->mld_type = ICMPV6_MGM_QUERY;\n\tmldq->mld_code = 0;\n\tmldq->mld_cksum = 0;\n\tmldq->mld_maxdelay = htons((u16)jiffies_to_msecs(interval));\n\tmldq->mld_reserved = 0;\n\tipv6_addr_copy(&mldq->mld_mca, group);\n\n\t/* checksum */\n\tmldq->mld_cksum = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\n\t\t\t\t\t  sizeof(*mldq), IPPROTO_ICMPV6,\n\t\t\t\t\t  csum_partial(mldq,\n\t\t\t\t\t\t       sizeof(*mldq), 0));\n\tskb_put(skb, sizeof(*mldq));\n\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n#endif\n\nstatic struct sk_buff *br_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\tstruct br_ip *addr)\n{\n\tswitch (addr->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn br_ip4_multicast_alloc_query(br, addr->u.ip4);\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tcase htons(ETH_P_IPV6):\n\t\treturn br_ip6_multicast_alloc_query(br, &addr->u.ip6);\n#endif\n\t}\n\treturn NULL;\n}\n\nstatic void br_multicast_send_group_query(struct net_bridge_mdb_entry *mp)\n{\n\tstruct net_bridge *br = mp->br;\n\tstruct sk_buff *skb;\n\n\tskb = br_multicast_alloc_query(br, &mp->addr);\n\tif (!skb)\n\t\tgoto timer;\n\n\tnetif_rx(skb);\n\ntimer:\n\tif (++mp->queries_sent < br->multicast_last_member_count)\n\t\tmod_timer(&mp->query_timer,\n\t\t\t  jiffies + br->multicast_last_member_interval);\n}\n\nstatic void br_multicast_group_query_expired(unsigned long data)\n{\n\tstruct net_bridge_mdb_entry *mp = (void *)data;\n\tstruct net_bridge *br = mp->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || hlist_unhashed(&mp->mglist) ||\n\t    mp->queries_sent >= br->multicast_last_member_count)\n\t\tgoto out;\n\n\tbr_multicast_send_group_query(mp);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_send_port_group_query(struct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_port *port = pg->port;\n\tstruct net_bridge *br = port->br;\n\tstruct sk_buff *skb;\n\n\tskb = br_multicast_alloc_query(br, &pg->addr);\n\tif (!skb)\n\t\tgoto timer;\n\n\tbr_deliver(port, skb);\n\ntimer:\n\tif (++pg->queries_sent < br->multicast_last_member_count)\n\t\tmod_timer(&pg->query_timer,\n\t\t\t  jiffies + br->multicast_last_member_interval);\n}\n\nstatic void br_multicast_port_group_query_expired(unsigned long data)\n{\n\tstruct net_bridge_port_group *pg = (void *)data;\n\tstruct net_bridge_port *port = pg->port;\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || hlist_unhashed(&pg->mglist) ||\n\t    pg->queries_sent >= br->multicast_last_member_count)\n\t\tgoto out;\n\n\tbr_multicast_send_port_group_query(pg);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic struct net_bridge_mdb_entry *br_multicast_get_group(\n\tstruct net_bridge *br, struct net_bridge_port *port,\n\tstruct br_ip *group, int hash)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *p;\n\tunsigned count = 0;\n\tunsigned max;\n\tint elasticity;\n\tint err;\n\n\tmdb = rcu_dereference_protected(br->mdb, 1);\n\thlist_for_each_entry(mp, p, &mdb->mhash[hash], hlist[mdb->ver]) {\n\t\tcount++;\n\t\tif (unlikely(br_ip_equal(group, &mp->addr)))\n\t\t\treturn mp;\n\t}\n\n\telasticity = 0;\n\tmax = mdb->max;\n\n\tif (unlikely(count > br->hash_elasticity && count)) {\n\t\tif (net_ratelimit())\n\t\t\tbr_info(br, \"Multicast hash table \"\n\t\t\t\t\"chain limit reached: %s\\n\",\n\t\t\t\tport ? port->dev->name : br->dev->name);\n\n\t\telasticity = br->hash_elasticity;\n\t}\n\n\tif (mdb->size >= max) {\n\t\tmax *= 2;\n\t\tif (unlikely(max >= br->hash_max)) {\n\t\t\tbr_warn(br, \"Multicast hash table maximum \"\n\t\t\t\t\"reached, disabling snooping: %s, %d\\n\",\n\t\t\t\tport ? port->dev->name : br->dev->name, max);\n\t\t\terr = -E2BIG;\ndisable:\n\t\t\tbr->multicast_disabled = 1;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (max > mdb->max || elasticity) {\n\t\tif (mdb->old) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tbr_info(br, \"Multicast hash table \"\n\t\t\t\t\t\"on fire: %s\\n\",\n\t\t\t\t\tport ? port->dev->name : br->dev->name);\n\t\t\terr = -EEXIST;\n\t\t\tgoto err;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, max, elasticity);\n\t\tif (err) {\n\t\t\tbr_warn(br, \"Cannot rehash multicast \"\n\t\t\t\t\"hash table, disabling snooping: %s, %d, %d\\n\",\n\t\t\t\tport ? port->dev->name : br->dev->name,\n\t\t\t\tmdb->size, err);\n\t\t\tgoto disable;\n\t\t}\n\n\t\terr = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\treturn NULL;\n\nerr:\n\tmp = ERR_PTR(err);\n\treturn mp;\n}\n\nstatic struct net_bridge_mdb_entry *br_multicast_new_group(\n\tstruct net_bridge *br, struct net_bridge_port *port,\n\tstruct br_ip *group)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tint hash;\n\tint err;\n\n\tmdb = rcu_dereference_protected(br->mdb, 1);\n\tif (!mdb) {\n\t\terr = br_mdb_rehash(&br->mdb, BR_HASH_SIZE, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto rehash;\n\t}\n\n\thash = br_ip_hash(mdb, group);\n\tmp = br_multicast_get_group(br, port, group, hash);\n\tswitch (PTR_ERR(mp)) {\n\tcase 0:\n\t\tbreak;\n\n\tcase -EAGAIN:\nrehash:\n\t\tmdb = rcu_dereference_protected(br->mdb, 1);\n\t\thash = br_ip_hash(mdb, group);\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tmp = kzalloc(sizeof(*mp), GFP_ATOMIC);\n\tif (unlikely(!mp))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmp->br = br;\n\tmp->addr = *group;\n\tsetup_timer(&mp->timer, br_multicast_group_expired,\n\t\t    (unsigned long)mp);\n\tsetup_timer(&mp->query_timer, br_multicast_group_query_expired,\n\t\t    (unsigned long)mp);\n\n\thlist_add_head_rcu(&mp->hlist[mdb->ver], &mdb->mhash[hash]);\n\tmdb->size++;\n\nout:\n\treturn mp;\n}\n\nstatic int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\n\tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\n\trcu_assign_pointer(*pp, p);\n\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\n\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n\nstatic int br_ip4_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      __be32 group)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv4_is_local_multicast(group))\n\t\treturn 0;\n\n\tbr_group.u.ip4 = group;\n\tbr_group.proto = htons(ETH_P_IP);\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic int br_ip6_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      const struct in6_addr *group)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv6_is_local_multicast(group))\n\t\treturn 0;\n\n\tipv6_addr_copy(&br_group.u.ip6, group);\n\tbr_group.proto = htons(ETH_P_IP);\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}\n#endif\n\nstatic void br_multicast_router_expired(unsigned long data)\n{\n\tstruct net_bridge_port *port = (void *)data;\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (port->multicast_router != 1 ||\n\t    timer_pending(&port->multicast_router_timer) ||\n\t    hlist_unhashed(&port->rlist))\n\t\tgoto out;\n\n\thlist_del_init_rcu(&port->rlist);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_local_router_expired(unsigned long data)\n{\n}\n\nstatic void __br_multicast_send_query(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      struct br_ip *ip)\n{\n\tstruct sk_buff *skb;\n\n\tskb = br_multicast_alloc_query(br, ip);\n\tif (!skb)\n\t\treturn;\n\n\tif (port) {\n\t\t__skb_push(skb, sizeof(struct ethhdr));\n\t\tskb->dev = port->dev;\n\t\tNF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,\n\t\t\tdev_queue_xmit);\n\t} else\n\t\tnetif_rx(skb);\n}\n\nstatic void br_multicast_send_query(struct net_bridge *br,\n\t\t\t\t    struct net_bridge_port *port, u32 sent)\n{\n\tunsigned long time;\n\tstruct br_ip br_group;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled ||\n\t    timer_pending(&br->multicast_querier_timer))\n\t\treturn;\n\n\tmemset(&br_group.u, 0, sizeof(br_group.u));\n\n\tbr_group.proto = htons(ETH_P_IP);\n\t__br_multicast_send_query(br, port, &br_group);\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tbr_group.proto = htons(ETH_P_IPV6);\n\t__br_multicast_send_query(br, port, &br_group);\n#endif\n\n\ttime = jiffies;\n\ttime += sent < br->multicast_startup_query_count ?\n\t\tbr->multicast_startup_query_interval :\n\t\tbr->multicast_query_interval;\n\tmod_timer(port ? &port->multicast_query_timer :\n\t\t\t &br->multicast_query_timer, time);\n}\n\nstatic void br_multicast_port_query_expired(unsigned long data)\n{\n\tstruct net_bridge_port *port = (void *)data;\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (port->state == BR_STATE_DISABLED ||\n\t    port->state == BR_STATE_BLOCKING)\n\t\tgoto out;\n\n\tif (port->multicast_startup_queries_sent <\n\t    br->multicast_startup_query_count)\n\t\tport->multicast_startup_queries_sent++;\n\n\tbr_multicast_send_query(port->br, port,\n\t\t\t\tport->multicast_startup_queries_sent);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_add_port(struct net_bridge_port *port)\n{\n\tport->multicast_router = 1;\n\n\tsetup_timer(&port->multicast_router_timer, br_multicast_router_expired,\n\t\t    (unsigned long)port);\n\tsetup_timer(&port->multicast_query_timer,\n\t\t    br_multicast_port_query_expired, (unsigned long)port);\n}\n\nvoid br_multicast_del_port(struct net_bridge_port *port)\n{\n\tdel_timer_sync(&port->multicast_router_timer);\n}\n\nstatic void __br_multicast_enable_port(struct net_bridge_port *port)\n{\n\tport->multicast_startup_queries_sent = 0;\n\n\tif (try_to_del_timer_sync(&port->multicast_query_timer) >= 0 ||\n\t    del_timer(&port->multicast_query_timer))\n\t\tmod_timer(&port->multicast_query_timer, jiffies);\n}\n\nvoid br_multicast_enable_port(struct net_bridge_port *port)\n{\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_disabled || !netif_running(br->dev))\n\t\tgoto out;\n\n\t__br_multicast_enable_port(port);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_disable_port(struct net_bridge_port *port)\n{\n\tstruct net_bridge *br = port->br;\n\tstruct net_bridge_port_group *pg;\n\tstruct hlist_node *p, *n;\n\n\tspin_lock(&br->multicast_lock);\n\thlist_for_each_entry_safe(pg, p, n, &port->mglist, mglist)\n\t\tbr_multicast_del_pg(br, pg);\n\n\tif (!hlist_unhashed(&port->rlist))\n\t\thlist_del_init_rcu(&port->rlist);\n\tdel_timer(&port->multicast_router_timer);\n\tdel_timer(&port->multicast_query_timer);\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic int br_ip4_multicast_igmp3_report(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct igmpv3_report *ih;\n\tstruct igmpv3_grec *grec;\n\tint i;\n\tint len;\n\tint num;\n\tint type;\n\tint err = 0;\n\t__be32 group;\n\n\tif (!pskb_may_pull(skb, sizeof(*ih)))\n\t\treturn -EINVAL;\n\n\tih = igmpv3_report_hdr(skb);\n\tnum = ntohs(ih->ngrec);\n\tlen = sizeof(*ih);\n\n\tfor (i = 0; i < num; i++) {\n\t\tlen += sizeof(*grec);\n\t\tif (!pskb_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\tgrec = (void *)(skb->data + len - sizeof(*grec));\n\t\tgroup = grec->grec_mca;\n\t\ttype = grec->grec_type;\n\n\t\tlen += ntohs(grec->grec_nsrcs) * 4;\n\t\tif (!pskb_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\t/* We treat this as an IGMPv2 report for now. */\n\t\tswitch (type) {\n\t\tcase IGMPV3_MODE_IS_INCLUDE:\n\t\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = br_ip4_multicast_add_group(br, port, group);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic int br_ip6_multicast_mld2_report(struct net_bridge *br,\n\t\t\t\t\tstruct net_bridge_port *port,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct icmp6hdr *icmp6h;\n\tstruct mld2_grec *grec;\n\tint i;\n\tint len;\n\tint num;\n\tint err = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(*icmp6h)))\n\t\treturn -EINVAL;\n\n\ticmp6h = icmp6_hdr(skb);\n\tnum = ntohs(icmp6h->icmp6_dataun.un_data16[1]);\n\tlen = sizeof(*icmp6h);\n\n\tfor (i = 0; i < num; i++) {\n\t\t__be16 *nsrcs, _nsrcs;\n\n\t\tnsrcs = skb_header_pointer(skb,\n\t\t\t\t\t   len + offsetof(struct mld2_grec,\n\t\t\t\t\t\t\t  grec_mca),\n\t\t\t\t\t   sizeof(_nsrcs), &_nsrcs);\n\t\tif (!nsrcs)\n\t\t\treturn -EINVAL;\n\n\t\tif (!pskb_may_pull(skb,\n\t\t\t\t   len + sizeof(*grec) +\n\t\t\t\t   sizeof(struct in6_addr) * (*nsrcs)))\n\t\t\treturn -EINVAL;\n\n\t\tgrec = (struct mld2_grec *)(skb->data + len);\n\t\tlen += sizeof(*grec) + sizeof(struct in6_addr) * (*nsrcs);\n\n\t\t/* We treat these as MLDv1 reports for now. */\n\t\tswitch (grec->grec_type) {\n\t\tcase MLD2_MODE_IS_INCLUDE:\n\t\tcase MLD2_MODE_IS_EXCLUDE:\n\t\tcase MLD2_CHANGE_TO_INCLUDE:\n\t\tcase MLD2_CHANGE_TO_EXCLUDE:\n\t\tcase MLD2_ALLOW_NEW_SOURCES:\n\t\tcase MLD2_BLOCK_OLD_SOURCES:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = br_ip6_multicast_add_group(br, port, &grec->grec_mca);\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n#endif\n\n/*\n * Add port to rotuer_list\n *  list is maintained ordered by pointer value\n *  and locked by br->multicast_lock and RCU\n */\nstatic void br_multicast_add_router(struct net_bridge *br,\n\t\t\t\t    struct net_bridge_port *port)\n{\n\tstruct net_bridge_port *p;\n\tstruct hlist_node *n, *slot = NULL;\n\n\thlist_for_each_entry(p, n, &br->router_list, rlist) {\n\t\tif ((unsigned long) port >= (unsigned long) p)\n\t\t\tbreak;\n\t\tslot = n;\n\t}\n\n\tif (slot)\n\t\thlist_add_after_rcu(slot, &port->rlist);\n\telse\n\t\thlist_add_head_rcu(&port->rlist, &br->router_list);\n}\n\nstatic void br_multicast_mark_router(struct net_bridge *br,\n\t\t\t\t     struct net_bridge_port *port)\n{\n\tunsigned long now = jiffies;\n\n\tif (!port) {\n\t\tif (br->multicast_router == 1)\n\t\t\tmod_timer(&br->multicast_router_timer,\n\t\t\t\t  now + br->multicast_querier_interval);\n\t\treturn;\n\t}\n\n\tif (port->multicast_router != 1)\n\t\treturn;\n\n\tif (!hlist_unhashed(&port->rlist))\n\t\tgoto timer;\n\n\tbr_multicast_add_router(br, port);\n\ntimer:\n\tmod_timer(&port->multicast_router_timer,\n\t\t  now + br->multicast_querier_interval);\n}\n\nstatic void br_multicast_query_received(struct net_bridge *br,\n\t\t\t\t\tstruct net_bridge_port *port,\n\t\t\t\t\tint saddr)\n{\n\tif (saddr)\n\t\tmod_timer(&br->multicast_querier_timer,\n\t\t\t  jiffies + br->multicast_querier_interval);\n\telse if (timer_pending(&br->multicast_querier_timer))\n\t\treturn;\n\n\tbr_multicast_mark_router(br, port);\n}\n\nstatic int br_ip4_multicast_query(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct igmphdr *ih = igmp_hdr(skb);\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct igmpv3_query *ih3;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long max_delay;\n\tunsigned long now = jiffies;\n\t__be32 group;\n\tint err = 0;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tbr_multicast_query_received(br, port, !!iph->saddr);\n\n\tgroup = ih->group;\n\n\tif (skb->len == sizeof(*ih)) {\n\t\tmax_delay = ih->code * (HZ / IGMP_TIMER_SCALE);\n\n\t\tif (!max_delay) {\n\t\t\tmax_delay = 10 * HZ;\n\t\t\tgroup = 0;\n\t\t}\n\t} else {\n\t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tih3 = igmpv3_query_hdr(skb);\n\t\tif (ih3->nsrcs)\n\t\t\tgoto out;\n\n\t\tmax_delay = ih3->code ?\n\t\t\t    IGMPV3_MRC(ih3->code) * (HZ / IGMP_TIMER_SCALE) : 1;\n\t}\n\n\tif (!group)\n\t\tgoto out;\n\n\tmp = br_mdb_ip4_get(mlock_dereference(br->mdb, br), group);\n\tif (!mp)\n\t\tgoto out;\n\n\tmax_delay *= br->multicast_last_member_count;\n\n\tif (!hlist_unhashed(&mp->mglist) &&\n\t    (timer_pending(&mp->timer) ?\n\t     time_after(mp->timer.expires, now + max_delay) :\n\t     try_to_del_timer_sync(&mp->timer) >= 0))\n\t\tmod_timer(&mp->timer, now + max_delay);\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (timer_pending(&p->timer) ?\n\t\t    time_after(p->timer.expires, now + max_delay) :\n\t\t    try_to_del_timer_sync(&p->timer) >= 0)\n\t\t\tmod_timer(&mp->timer, now + max_delay);\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic int br_ip6_multicast_query(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tstruct mld_msg *mld = (struct mld_msg *) icmp6_hdr(skb);\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct mld2_query *mld2q;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long max_delay;\n\tunsigned long now = jiffies;\n\tstruct in6_addr *group = NULL;\n\tint err = 0;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tbr_multicast_query_received(br, port, !ipv6_addr_any(&ip6h->saddr));\n\n\tif (skb->len == sizeof(*mld)) {\n\t\tif (!pskb_may_pull(skb, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *) icmp6_hdr(skb);\n\t\tmax_delay = msecs_to_jiffies(htons(mld->mld_maxdelay));\n\t\tif (max_delay)\n\t\t\tgroup = &mld->mld_mca;\n\t} else if (skb->len >= sizeof(*mld2q)) {\n\t\tif (!pskb_may_pull(skb, sizeof(*mld2q))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld2q = (struct mld2_query *)icmp6_hdr(skb);\n\t\tif (!mld2q->mld2q_nsrcs)\n\t\t\tgroup = &mld2q->mld2q_mca;\n\t\tmax_delay = mld2q->mld2q_mrc ? MLDV2_MRC(mld2q->mld2q_mrc) : 1;\n\t}\n\n\tif (!group)\n\t\tgoto out;\n\n\tmp = br_mdb_ip6_get(mlock_dereference(br->mdb, br), group);\n\tif (!mp)\n\t\tgoto out;\n\n\tmax_delay *= br->multicast_last_member_count;\n\tif (!hlist_unhashed(&mp->mglist) &&\n\t    (timer_pending(&mp->timer) ?\n\t     time_after(mp->timer.expires, now + max_delay) :\n\t     try_to_del_timer_sync(&mp->timer) >= 0))\n\t\tmod_timer(&mp->timer, now + max_delay);\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (timer_pending(&p->timer) ?\n\t\t    time_after(p->timer.expires, now + max_delay) :\n\t\t    try_to_del_timer_sync(&p->timer) >= 0)\n\t\t\tmod_timer(&mp->timer, now + max_delay);\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n#endif\n\nstatic void br_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t     struct net_bridge_port *port,\n\t\t\t\t     struct br_ip *group)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tunsigned long now;\n\tunsigned long time;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED) ||\n\t    timer_pending(&br->multicast_querier_timer))\n\t\tgoto out;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, group);\n\tif (!mp)\n\t\tgoto out;\n\n\tnow = jiffies;\n\ttime = now + br->multicast_last_member_count *\n\t\t     br->multicast_last_member_interval;\n\n\tif (!port) {\n\t\tif (!hlist_unhashed(&mp->mglist) &&\n\t\t    (timer_pending(&mp->timer) ?\n\t\t     time_after(mp->timer.expires, time) :\n\t\t     try_to_del_timer_sync(&mp->timer) >= 0)) {\n\t\t\tmod_timer(&mp->timer, time);\n\n\t\t\tmp->queries_sent = 0;\n\t\t\tmod_timer(&mp->query_timer, now);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tfor (p = mlock_dereference(mp->ports, br);\n\t     p != NULL;\n\t     p = mlock_dereference(p->next, br)) {\n\t\tif (p->port != port)\n\t\t\tcontinue;\n\n\t\tif (!hlist_unhashed(&p->mglist) &&\n\t\t    (timer_pending(&p->timer) ?\n\t\t     time_after(p->timer.expires, time) :\n\t\t     try_to_del_timer_sync(&p->timer) >= 0)) {\n\t\t\tmod_timer(&p->timer, time);\n\n\t\t\tp->queries_sent = 0;\n\t\t\tmod_timer(&p->query_timer, now);\n\t\t}\n\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_ip4_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t __be32 group)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv4_is_local_multicast(group))\n\t\treturn;\n\n\tbr_group.u.ip4 = group;\n\tbr_group.proto = htons(ETH_P_IP);\n\n\tbr_multicast_leave_group(br, port, &br_group);\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic void br_ip6_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t const struct in6_addr *group)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv6_is_local_multicast(group))\n\t\treturn;\n\n\tipv6_addr_copy(&br_group.u.ip6, group);\n\tbr_group.proto = htons(ETH_P_IPV6);\n\n\tbr_multicast_leave_group(br, port, &br_group);\n}\n#endif\n\nstatic int br_multicast_ipv4_rcv(struct net_bridge *br,\n\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct sk_buff *skb2 = skb;\n\tstruct iphdr *iph;\n\tstruct igmphdr *ih;\n\tunsigned len;\n\tunsigned offset;\n\tint err;\n\n\t/* We treat OOM as packet loss for now. */\n\tif (!pskb_may_pull(skb, sizeof(*iph)))\n\t\treturn -EINVAL;\n\n\tiph = ip_hdr(skb);\n\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\treturn -EINVAL;\n\n\tif (!pskb_may_pull(skb, ip_hdrlen(skb)))\n\t\treturn -EINVAL;\n\n\tiph = ip_hdr(skb);\n\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\treturn -EINVAL;\n\n\tif (iph->protocol != IPPROTO_IGMP)\n\t\treturn 0;\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len || len < ip_hdrlen(skb))\n\t\treturn -EINVAL;\n\n\tif (skb->len > len) {\n\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb2)\n\t\t\treturn -ENOMEM;\n\n\t\terr = pskb_trim_rcsum(skb2, len);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\tlen -= ip_hdrlen(skb2);\n\toffset = skb_network_offset(skb2) + ip_hdrlen(skb2);\n\t__skb_pull(skb2, offset);\n\tskb_reset_transport_header(skb2);\n\n\terr = -EINVAL;\n\tif (!pskb_may_pull(skb2, sizeof(*ih)))\n\t\tgoto out;\n\n\tswitch (skb2->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (!csum_fold(skb2->csum))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase CHECKSUM_NONE:\n\t\tskb2->csum = 0;\n\t\tif (skb_checksum_complete(skb2))\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\n\n\tBR_INPUT_SKB_CB(skb)->igmp = 1;\n\tih = igmp_hdr(skb2);\n\n\tswitch (ih->type) {\n\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\t\tBR_INPUT_SKB_CB(skb2)->mrouters_only = 1;\n\t\terr = br_ip4_multicast_add_group(br, port, ih->group);\n\t\tbreak;\n\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\t\terr = br_ip4_multicast_igmp3_report(br, port, skb2);\n\t\tbreak;\n\tcase IGMP_HOST_MEMBERSHIP_QUERY:\n\t\terr = br_ip4_multicast_query(br, port, skb2);\n\t\tbreak;\n\tcase IGMP_HOST_LEAVE_MESSAGE:\n\t\tbr_ip4_multicast_leave_group(br, port, ih->group);\n\t\tbreak;\n\t}\n\nout:\n\t__skb_push(skb2, offset);\nerr_out:\n\tif (skb2 != skb)\n\t\tkfree_skb(skb2);\n\treturn err;\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic int br_multicast_ipv6_rcv(struct net_bridge *br,\n\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct sk_buff *skb2;\n\tstruct ipv6hdr *ip6h;\n\tstruct icmp6hdr *icmp6h;\n\tu8 nexthdr;\n\tunsigned len;\n\tint offset;\n\tint err;\n\n\tif (!pskb_may_pull(skb, sizeof(*ip6h)))\n\t\treturn -EINVAL;\n\n\tip6h = ipv6_hdr(skb);\n\n\t/*\n\t * We're interested in MLD messages only.\n\t *  - Version is 6\n\t *  - MLD has always Router Alert hop-by-hop option\n\t *  - But we do not support jumbrograms.\n\t */\n\tif (ip6h->version != 6 ||\n\t    ip6h->nexthdr != IPPROTO_HOPOPTS ||\n\t    ip6h->payload_len == 0)\n\t\treturn 0;\n\n\tlen = ntohs(ip6h->payload_len);\n\tif (skb->len < len)\n\t\treturn -EINVAL;\n\n\tnexthdr = ip6h->nexthdr;\n\toffset = ipv6_skip_exthdr(skb, sizeof(*ip6h), &nexthdr);\n\n\tif (offset < 0 || nexthdr != IPPROTO_ICMPV6)\n\t\treturn 0;\n\n\t/* Okay, we found ICMPv6 header */\n\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\tif (!pskb_may_pull(skb2, offset + sizeof(struct icmp6hdr)))\n\t\tgoto out;\n\n\tlen -= offset - skb_network_offset(skb2);\n\n\t__skb_pull(skb2, offset);\n\tskb_reset_transport_header(skb2);\n\n\ticmp6h = icmp6_hdr(skb2);\n\n\tswitch (icmp6h->icmp6_type) {\n\tcase ICMPV6_MGM_QUERY:\n\tcase ICMPV6_MGM_REPORT:\n\tcase ICMPV6_MGM_REDUCTION:\n\tcase ICMPV6_MLD2_REPORT:\n\t\tbreak;\n\tdefault:\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* Okay, we found MLD message. Check further. */\n\tif (skb2->len > len) {\n\t\terr = pskb_trim_rcsum(skb2, len);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tswitch (skb2->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (!csum_fold(skb2->csum))\n\t\t\tbreak;\n\t\t/*FALLTHROUGH*/\n\tcase CHECKSUM_NONE:\n\t\tskb2->csum = 0;\n\t\tif (skb_checksum_complete(skb2))\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\n\n\tBR_INPUT_SKB_CB(skb)->igmp = 1;\n\n\tswitch (icmp6h->icmp6_type) {\n\tcase ICMPV6_MGM_REPORT:\n\t    {\n\t\tstruct mld_msg *mld;\n\t\tif (!pskb_may_pull(skb2, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *)skb_transport_header(skb2);\n\t\tBR_INPUT_SKB_CB(skb2)->mrouters_only = 1;\n\t\terr = br_ip6_multicast_add_group(br, port, &mld->mld_mca);\n\t\tbreak;\n\t    }\n\tcase ICMPV6_MLD2_REPORT:\n\t\terr = br_ip6_multicast_mld2_report(br, port, skb2);\n\t\tbreak;\n\tcase ICMPV6_MGM_QUERY:\n\t\terr = br_ip6_multicast_query(br, port, skb2);\n\t\tbreak;\n\tcase ICMPV6_MGM_REDUCTION:\n\t    {\n\t\tstruct mld_msg *mld;\n\t\tif (!pskb_may_pull(skb2, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *)skb_transport_header(skb2);\n\t\tbr_ip6_multicast_leave_group(br, port, &mld->mld_mca);\n\t    }\n\t}\n\nout:\n\tkfree_skb(skb2);\n\treturn err;\n}\n#endif\n\nint br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,\n\t\t     struct sk_buff *skb)\n{\n\tBR_INPUT_SKB_CB(skb)->igmp = 0;\n\tBR_INPUT_SKB_CB(skb)->mrouters_only = 0;\n\n\tif (br->multicast_disabled)\n\t\treturn 0;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\treturn br_multicast_ipv4_rcv(br, port, skb);\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tcase htons(ETH_P_IPV6):\n\t\treturn br_multicast_ipv6_rcv(br, port, skb);\n#endif\n\t}\n\n\treturn 0;\n}\n\nstatic void br_multicast_query_expired(unsigned long data)\n{\n\tstruct net_bridge *br = (void *)data;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_startup_queries_sent <\n\t    br->multicast_startup_query_count)\n\t\tbr->multicast_startup_queries_sent++;\n\n\tbr_multicast_send_query(br, NULL, br->multicast_startup_queries_sent);\n\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_init(struct net_bridge *br)\n{\n\tbr->hash_elasticity = 4;\n\tbr->hash_max = 512;\n\n\tbr->multicast_router = 1;\n\tbr->multicast_last_member_count = 2;\n\tbr->multicast_startup_query_count = 2;\n\n\tbr->multicast_last_member_interval = HZ;\n\tbr->multicast_query_response_interval = 10 * HZ;\n\tbr->multicast_startup_query_interval = 125 * HZ / 4;\n\tbr->multicast_query_interval = 125 * HZ;\n\tbr->multicast_querier_interval = 255 * HZ;\n\tbr->multicast_membership_interval = 260 * HZ;\n\n\tspin_lock_init(&br->multicast_lock);\n\tsetup_timer(&br->multicast_router_timer,\n\t\t    br_multicast_local_router_expired, 0);\n\tsetup_timer(&br->multicast_querier_timer,\n\t\t    br_multicast_local_router_expired, 0);\n\tsetup_timer(&br->multicast_query_timer, br_multicast_query_expired,\n\t\t    (unsigned long)br);\n}\n\nvoid br_multicast_open(struct net_bridge *br)\n{\n\tbr->multicast_startup_queries_sent = 0;\n\n\tif (br->multicast_disabled)\n\t\treturn;\n\n\tmod_timer(&br->multicast_query_timer, jiffies);\n}\n\nvoid br_multicast_stop(struct net_bridge *br)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *p, *n;\n\tu32 ver;\n\tint i;\n\n\tdel_timer_sync(&br->multicast_router_timer);\n\tdel_timer_sync(&br->multicast_querier_timer);\n\tdel_timer_sync(&br->multicast_query_timer);\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (!mdb)\n\t\tgoto out;\n\n\tbr->mdb = NULL;\n\n\tver = mdb->ver;\n\tfor (i = 0; i < mdb->max; i++) {\n\t\thlist_for_each_entry_safe(mp, p, n, &mdb->mhash[i],\n\t\t\t\t\t  hlist[ver]) {\n\t\t\tdel_timer(&mp->timer);\n\t\t\tdel_timer(&mp->query_timer);\n\t\t\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\t\t}\n\t}\n\n\tif (mdb->old) {\n\t\tspin_unlock_bh(&br->multicast_lock);\n\t\trcu_barrier_bh();\n\t\tspin_lock_bh(&br->multicast_lock);\n\t\tWARN_ON(mdb->old);\n\t}\n\n\tmdb->old = mdb;\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\tspin_unlock_bh(&br->multicast_lock);\n}\n\nint br_multicast_set_router(struct net_bridge *br, unsigned long val)\n{\n\tint err = -ENOENT;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 2:\n\t\tdel_timer(&br->multicast_router_timer);\n\t\t/* fall through */\n\tcase 1:\n\t\tbr->multicast_router = val;\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\n\treturn err;\n}\n\nint br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val)\n{\n\tstruct net_bridge *br = p->br;\n\tint err = -ENOENT;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || p->state == BR_STATE_DISABLED)\n\t\tgoto unlock;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tp->multicast_router = val;\n\t\terr = 0;\n\n\t\tif (val < 2 && !hlist_unhashed(&p->rlist))\n\t\t\thlist_del_init_rcu(&p->rlist);\n\n\t\tif (val == 1)\n\t\t\tbreak;\n\n\t\tdel_timer(&p->multicast_router_timer);\n\n\t\tif (val == 0)\n\t\t\tbreak;\n\n\t\tbr_multicast_add_router(br, p);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n\nint br_multicast_toggle(struct net_bridge *br, unsigned long val)\n{\n\tstruct net_bridge_port *port;\n\tint err = 0;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_disabled == !val)\n\t\tgoto unlock;\n\n\tbr->multicast_disabled = !val;\n\tif (br->multicast_disabled)\n\t\tgoto unlock;\n\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (mdb) {\n\t\tif (mdb->old) {\n\t\t\terr = -EEXIST;\nrollback:\n\t\t\tbr->multicast_disabled = !!val;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, mdb->max,\n\t\t\t\t    br->hash_elasticity);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\n\tbr_multicast_open(br);\n\tlist_for_each_entry(port, &br->port_list, list) {\n\t\tif (port->state == BR_STATE_DISABLED ||\n\t\t    port->state == BR_STATE_BLOCKING)\n\t\t\tcontinue;\n\n\t\t__br_multicast_enable_port(port);\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n\nint br_multicast_set_hash_max(struct net_bridge *br, unsigned long val)\n{\n\tint err = -ENOENT;\n\tu32 old;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\terr = -EINVAL;\n\tif (!is_power_of_2(val))\n\t\tgoto unlock;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (mdb && val < mdb->size)\n\t\tgoto unlock;\n\n\terr = 0;\n\n\told = br->hash_max;\n\tbr->hash_max = val;\n\n\tif (mdb) {\n\t\tif (mdb->old) {\n\t\t\terr = -EEXIST;\nrollback:\n\t\t\tbr->hash_max = old;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, br->hash_max,\n\t\t\t\t    br->hash_elasticity);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n"], "fixing_code": ["/*\n * Bridge multicast support.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <linux/err.h>\n#include <linux/if_ether.h>\n#include <linux/igmp.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/netdevice.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <net/ip.h>\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n#include <net/ipv6.h>\n#include <net/mld.h>\n#include <net/addrconf.h>\n#include <net/ip6_checksum.h>\n#endif\n\n#include \"br_private.h\"\n\n#define mlock_dereference(X, br) \\\n\trcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic inline int ipv6_is_local_multicast(const struct in6_addr *addr)\n{\n\tif (ipv6_addr_is_multicast(addr) &&\n\t    IPV6_ADDR_MC_SCOPE(addr) <= IPV6_ADDR_SCOPE_LINKLOCAL)\n\t\treturn 1;\n\treturn 0;\n}\n#endif\n\nstatic inline int br_ip_equal(const struct br_ip *a, const struct br_ip *b)\n{\n\tif (a->proto != b->proto)\n\t\treturn 0;\n\tswitch (a->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn a->u.ip4 == b->u.ip4;\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tcase htons(ETH_P_IPV6):\n\t\treturn ipv6_addr_equal(&a->u.ip6, &b->u.ip6);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic inline int __br_ip4_hash(struct net_bridge_mdb_htable *mdb, __be32 ip)\n{\n\treturn jhash_1word(mdb->secret, (__force u32)ip) & (mdb->max - 1);\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic inline int __br_ip6_hash(struct net_bridge_mdb_htable *mdb,\n\t\t\t\tconst struct in6_addr *ip)\n{\n\treturn jhash2((__force u32 *)ip->s6_addr32, 4, mdb->secret) & (mdb->max - 1);\n}\n#endif\n\nstatic inline int br_ip_hash(struct net_bridge_mdb_htable *mdb,\n\t\t\t     struct br_ip *ip)\n{\n\tswitch (ip->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn __br_ip4_hash(mdb, ip->u.ip4);\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tcase htons(ETH_P_IPV6):\n\t\treturn __br_ip6_hash(mdb, &ip->u.ip6);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic struct net_bridge_mdb_entry *__br_mdb_ip_get(\n\tstruct net_bridge_mdb_htable *mdb, struct br_ip *dst, int hash)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *p;\n\n\thlist_for_each_entry_rcu(mp, p, &mdb->mhash[hash], hlist[mdb->ver]) {\n\t\tif (br_ip_equal(&mp->addr, dst))\n\t\t\treturn mp;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct net_bridge_mdb_entry *br_mdb_ip_get(\n\tstruct net_bridge_mdb_htable *mdb, struct br_ip *dst)\n{\n\tif (!mdb)\n\t\treturn NULL;\n\n\treturn __br_mdb_ip_get(mdb, dst, br_ip_hash(mdb, dst));\n}\n\nstatic struct net_bridge_mdb_entry *br_mdb_ip4_get(\n\tstruct net_bridge_mdb_htable *mdb, __be32 dst)\n{\n\tstruct br_ip br_dst;\n\n\tbr_dst.u.ip4 = dst;\n\tbr_dst.proto = htons(ETH_P_IP);\n\n\treturn br_mdb_ip_get(mdb, &br_dst);\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic struct net_bridge_mdb_entry *br_mdb_ip6_get(\n\tstruct net_bridge_mdb_htable *mdb, const struct in6_addr *dst)\n{\n\tstruct br_ip br_dst;\n\n\tipv6_addr_copy(&br_dst.u.ip6, dst);\n\tbr_dst.proto = htons(ETH_P_IPV6);\n\n\treturn br_mdb_ip_get(mdb, &br_dst);\n}\n#endif\n\nstruct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);\n\tstruct br_ip ip;\n\n\tif (br->multicast_disabled)\n\t\treturn NULL;\n\n\tif (BR_INPUT_SKB_CB(skb)->igmp)\n\t\treturn NULL;\n\n\tip.proto = skb->protocol;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tip.u.ip4 = ip_hdr(skb)->daddr;\n\t\tbreak;\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tcase htons(ETH_P_IPV6):\n\t\tipv6_addr_copy(&ip.u.ip6, &ipv6_hdr(skb)->daddr);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn br_mdb_ip_get(mdb, &ip);\n}\n\nstatic void br_mdb_free(struct rcu_head *head)\n{\n\tstruct net_bridge_mdb_htable *mdb =\n\t\tcontainer_of(head, struct net_bridge_mdb_htable, rcu);\n\tstruct net_bridge_mdb_htable *old = mdb->old;\n\n\tmdb->old = NULL;\n\tkfree(old->mhash);\n\tkfree(old);\n}\n\nstatic int br_mdb_copy(struct net_bridge_mdb_htable *new,\n\t\t       struct net_bridge_mdb_htable *old,\n\t\t       int elasticity)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *p;\n\tint maxlen;\n\tint len;\n\tint i;\n\n\tfor (i = 0; i < old->max; i++)\n\t\thlist_for_each_entry(mp, p, &old->mhash[i], hlist[old->ver])\n\t\t\thlist_add_head(&mp->hlist[new->ver],\n\t\t\t\t       &new->mhash[br_ip_hash(new, &mp->addr)]);\n\n\tif (!elasticity)\n\t\treturn 0;\n\n\tmaxlen = 0;\n\tfor (i = 0; i < new->max; i++) {\n\t\tlen = 0;\n\t\thlist_for_each_entry(mp, p, &new->mhash[i], hlist[new->ver])\n\t\t\tlen++;\n\t\tif (len > maxlen)\n\t\t\tmaxlen = len;\n\t}\n\n\treturn maxlen > elasticity ? -EINVAL : 0;\n}\n\nstatic void br_multicast_free_pg(struct rcu_head *head)\n{\n\tstruct net_bridge_port_group *p =\n\t\tcontainer_of(head, struct net_bridge_port_group, rcu);\n\n\tkfree(p);\n}\n\nstatic void br_multicast_free_group(struct rcu_head *head)\n{\n\tstruct net_bridge_mdb_entry *mp =\n\t\tcontainer_of(head, struct net_bridge_mdb_entry, rcu);\n\n\tkfree(mp);\n}\n\nstatic void br_multicast_group_expired(unsigned long data)\n{\n\tstruct net_bridge_mdb_entry *mp = (void *)data;\n\tstruct net_bridge *br = mp->br;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || timer_pending(&mp->timer))\n\t\tgoto out;\n\n\tif (!hlist_unhashed(&mp->mglist))\n\t\thlist_del_init(&mp->mglist);\n\n\tif (mp->ports)\n\t\tgoto out;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\thlist_del_rcu(&mp->hlist[mdb->ver]);\n\tmdb->size--;\n\n\tdel_timer(&mp->query_timer);\n\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tdel_timer(&p->query_timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\n\t\tif (!mp->ports && hlist_unhashed(&mp->mglist) &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\n\t\treturn;\n\t}\n\n\tWARN_ON(1);\n}\n\nstatic void br_multicast_port_group_expired(unsigned long data)\n{\n\tstruct net_bridge_port_group *pg = (void *)data;\n\tstruct net_bridge *br = pg->port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || timer_pending(&pg->timer) ||\n\t    hlist_unhashed(&pg->mglist))\n\t\tgoto out;\n\n\tbr_multicast_del_pg(br, pg);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic int br_mdb_rehash(struct net_bridge_mdb_htable __rcu **mdbp, int max,\n\t\t\t int elasticity)\n{\n\tstruct net_bridge_mdb_htable *old = rcu_dereference_protected(*mdbp, 1);\n\tstruct net_bridge_mdb_htable *mdb;\n\tint err;\n\n\tmdb = kmalloc(sizeof(*mdb), GFP_ATOMIC);\n\tif (!mdb)\n\t\treturn -ENOMEM;\n\n\tmdb->max = max;\n\tmdb->old = old;\n\n\tmdb->mhash = kzalloc(max * sizeof(*mdb->mhash), GFP_ATOMIC);\n\tif (!mdb->mhash) {\n\t\tkfree(mdb);\n\t\treturn -ENOMEM;\n\t}\n\n\tmdb->size = old ? old->size : 0;\n\tmdb->ver = old ? old->ver ^ 1 : 0;\n\n\tif (!old || elasticity)\n\t\tget_random_bytes(&mdb->secret, sizeof(mdb->secret));\n\telse\n\t\tmdb->secret = old->secret;\n\n\tif (!old)\n\t\tgoto out;\n\n\terr = br_mdb_copy(mdb, old, elasticity);\n\tif (err) {\n\t\tkfree(mdb->mhash);\n\t\tkfree(mdb);\n\t\treturn err;\n\t}\n\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\trcu_assign_pointer(*mdbp, mdb);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *br_ip4_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\t    __be32 group)\n{\n\tstruct sk_buff *skb;\n\tstruct igmphdr *ih;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\n\tskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*iph) +\n\t\t\t\t\t\t sizeof(*ih) + 4);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->protocol = htons(ETH_P_IP);\n\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tmemcpy(eth->h_source, br->dev->dev_addr, 6);\n\teth->h_dest[0] = 1;\n\teth->h_dest[1] = 0;\n\teth->h_dest[2] = 0x5e;\n\teth->h_dest[3] = 0;\n\teth->h_dest[4] = 0;\n\teth->h_dest[5] = 1;\n\teth->h_proto = htons(ETH_P_IP);\n\tskb_put(skb, sizeof(*eth));\n\n\tskb_set_network_header(skb, skb->len);\n\tiph = ip_hdr(skb);\n\n\tiph->version = 4;\n\tiph->ihl = 6;\n\tiph->tos = 0xc0;\n\tiph->tot_len = htons(sizeof(*iph) + sizeof(*ih) + 4);\n\tiph->id = 0;\n\tiph->frag_off = htons(IP_DF);\n\tiph->ttl = 1;\n\tiph->protocol = IPPROTO_IGMP;\n\tiph->saddr = 0;\n\tiph->daddr = htonl(INADDR_ALLHOSTS_GROUP);\n\t((u8 *)&iph[1])[0] = IPOPT_RA;\n\t((u8 *)&iph[1])[1] = 4;\n\t((u8 *)&iph[1])[2] = 0;\n\t((u8 *)&iph[1])[3] = 0;\n\tip_send_check(iph);\n\tskb_put(skb, 24);\n\n\tskb_set_transport_header(skb, skb->len);\n\tih = igmp_hdr(skb);\n\tih->type = IGMP_HOST_MEMBERSHIP_QUERY;\n\tih->code = (group ? br->multicast_last_member_interval :\n\t\t\t    br->multicast_query_response_interval) /\n\t\t   (HZ / IGMP_TIMER_SCALE);\n\tih->group = group;\n\tih->csum = 0;\n\tih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));\n\tskb_put(skb, sizeof(*ih));\n\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic struct sk_buff *br_ip6_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\t    struct in6_addr *group)\n{\n\tstruct sk_buff *skb;\n\tstruct ipv6hdr *ip6h;\n\tstruct mld_msg *mldq;\n\tstruct ethhdr *eth;\n\tu8 *hopopt;\n\tunsigned long interval;\n\n\tskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*ip6h) +\n\t\t\t\t\t\t 8 + sizeof(*mldq));\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\t/* Ethernet header */\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tmemcpy(eth->h_source, br->dev->dev_addr, 6);\n\tipv6_eth_mc_map(group, eth->h_dest);\n\teth->h_proto = htons(ETH_P_IPV6);\n\tskb_put(skb, sizeof(*eth));\n\n\t/* IPv6 header + HbH option */\n\tskb_set_network_header(skb, skb->len);\n\tip6h = ipv6_hdr(skb);\n\n\t*(__force __be32 *)ip6h = htonl(0x60000000);\n\tip6h->payload_len = htons(8 + sizeof(*mldq));\n\tip6h->nexthdr = IPPROTO_HOPOPTS;\n\tip6h->hop_limit = 1;\n\tipv6_addr_set(&ip6h->saddr, 0, 0, 0, 0);\n\tipv6_addr_set(&ip6h->daddr, htonl(0xff020000), 0, 0, htonl(1));\n\n\thopopt = (u8 *)(ip6h + 1);\n\thopopt[0] = IPPROTO_ICMPV6;\t\t/* next hdr */\n\thopopt[1] = 0;\t\t\t\t/* length of HbH */\n\thopopt[2] = IPV6_TLV_ROUTERALERT;\t/* Router Alert */\n\thopopt[3] = 2;\t\t\t\t/* Length of RA Option */\n\thopopt[4] = 0;\t\t\t\t/* Type = 0x0000 (MLD) */\n\thopopt[5] = 0;\n\thopopt[6] = IPV6_TLV_PAD0;\t\t/* Pad0 */\n\thopopt[7] = IPV6_TLV_PAD0;\t\t/* Pad0 */\n\n\tskb_put(skb, sizeof(*ip6h) + 8);\n\n\t/* ICMPv6 */\n\tskb_set_transport_header(skb, skb->len);\n\tmldq = (struct mld_msg *) icmp6_hdr(skb);\n\n\tinterval = ipv6_addr_any(group) ? br->multicast_last_member_interval :\n\t\t\t\t\t  br->multicast_query_response_interval;\n\n\tmldq->mld_type = ICMPV6_MGM_QUERY;\n\tmldq->mld_code = 0;\n\tmldq->mld_cksum = 0;\n\tmldq->mld_maxdelay = htons((u16)jiffies_to_msecs(interval));\n\tmldq->mld_reserved = 0;\n\tipv6_addr_copy(&mldq->mld_mca, group);\n\n\t/* checksum */\n\tmldq->mld_cksum = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\n\t\t\t\t\t  sizeof(*mldq), IPPROTO_ICMPV6,\n\t\t\t\t\t  csum_partial(mldq,\n\t\t\t\t\t\t       sizeof(*mldq), 0));\n\tskb_put(skb, sizeof(*mldq));\n\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n#endif\n\nstatic struct sk_buff *br_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\tstruct br_ip *addr)\n{\n\tswitch (addr->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn br_ip4_multicast_alloc_query(br, addr->u.ip4);\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tcase htons(ETH_P_IPV6):\n\t\treturn br_ip6_multicast_alloc_query(br, &addr->u.ip6);\n#endif\n\t}\n\treturn NULL;\n}\n\nstatic void br_multicast_send_group_query(struct net_bridge_mdb_entry *mp)\n{\n\tstruct net_bridge *br = mp->br;\n\tstruct sk_buff *skb;\n\n\tskb = br_multicast_alloc_query(br, &mp->addr);\n\tif (!skb)\n\t\tgoto timer;\n\n\tnetif_rx(skb);\n\ntimer:\n\tif (++mp->queries_sent < br->multicast_last_member_count)\n\t\tmod_timer(&mp->query_timer,\n\t\t\t  jiffies + br->multicast_last_member_interval);\n}\n\nstatic void br_multicast_group_query_expired(unsigned long data)\n{\n\tstruct net_bridge_mdb_entry *mp = (void *)data;\n\tstruct net_bridge *br = mp->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || hlist_unhashed(&mp->mglist) ||\n\t    mp->queries_sent >= br->multicast_last_member_count)\n\t\tgoto out;\n\n\tbr_multicast_send_group_query(mp);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_send_port_group_query(struct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_port *port = pg->port;\n\tstruct net_bridge *br = port->br;\n\tstruct sk_buff *skb;\n\n\tskb = br_multicast_alloc_query(br, &pg->addr);\n\tif (!skb)\n\t\tgoto timer;\n\n\tbr_deliver(port, skb);\n\ntimer:\n\tif (++pg->queries_sent < br->multicast_last_member_count)\n\t\tmod_timer(&pg->query_timer,\n\t\t\t  jiffies + br->multicast_last_member_interval);\n}\n\nstatic void br_multicast_port_group_query_expired(unsigned long data)\n{\n\tstruct net_bridge_port_group *pg = (void *)data;\n\tstruct net_bridge_port *port = pg->port;\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || hlist_unhashed(&pg->mglist) ||\n\t    pg->queries_sent >= br->multicast_last_member_count)\n\t\tgoto out;\n\n\tbr_multicast_send_port_group_query(pg);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic struct net_bridge_mdb_entry *br_multicast_get_group(\n\tstruct net_bridge *br, struct net_bridge_port *port,\n\tstruct br_ip *group, int hash)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *p;\n\tunsigned count = 0;\n\tunsigned max;\n\tint elasticity;\n\tint err;\n\n\tmdb = rcu_dereference_protected(br->mdb, 1);\n\thlist_for_each_entry(mp, p, &mdb->mhash[hash], hlist[mdb->ver]) {\n\t\tcount++;\n\t\tif (unlikely(br_ip_equal(group, &mp->addr)))\n\t\t\treturn mp;\n\t}\n\n\telasticity = 0;\n\tmax = mdb->max;\n\n\tif (unlikely(count > br->hash_elasticity && count)) {\n\t\tif (net_ratelimit())\n\t\t\tbr_info(br, \"Multicast hash table \"\n\t\t\t\t\"chain limit reached: %s\\n\",\n\t\t\t\tport ? port->dev->name : br->dev->name);\n\n\t\telasticity = br->hash_elasticity;\n\t}\n\n\tif (mdb->size >= max) {\n\t\tmax *= 2;\n\t\tif (unlikely(max >= br->hash_max)) {\n\t\t\tbr_warn(br, \"Multicast hash table maximum \"\n\t\t\t\t\"reached, disabling snooping: %s, %d\\n\",\n\t\t\t\tport ? port->dev->name : br->dev->name, max);\n\t\t\terr = -E2BIG;\ndisable:\n\t\t\tbr->multicast_disabled = 1;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (max > mdb->max || elasticity) {\n\t\tif (mdb->old) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tbr_info(br, \"Multicast hash table \"\n\t\t\t\t\t\"on fire: %s\\n\",\n\t\t\t\t\tport ? port->dev->name : br->dev->name);\n\t\t\terr = -EEXIST;\n\t\t\tgoto err;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, max, elasticity);\n\t\tif (err) {\n\t\t\tbr_warn(br, \"Cannot rehash multicast \"\n\t\t\t\t\"hash table, disabling snooping: %s, %d, %d\\n\",\n\t\t\t\tport ? port->dev->name : br->dev->name,\n\t\t\t\tmdb->size, err);\n\t\t\tgoto disable;\n\t\t}\n\n\t\terr = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\treturn NULL;\n\nerr:\n\tmp = ERR_PTR(err);\n\treturn mp;\n}\n\nstatic struct net_bridge_mdb_entry *br_multicast_new_group(\n\tstruct net_bridge *br, struct net_bridge_port *port,\n\tstruct br_ip *group)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tint hash;\n\tint err;\n\n\tmdb = rcu_dereference_protected(br->mdb, 1);\n\tif (!mdb) {\n\t\terr = br_mdb_rehash(&br->mdb, BR_HASH_SIZE, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto rehash;\n\t}\n\n\thash = br_ip_hash(mdb, group);\n\tmp = br_multicast_get_group(br, port, group, hash);\n\tswitch (PTR_ERR(mp)) {\n\tcase 0:\n\t\tbreak;\n\n\tcase -EAGAIN:\nrehash:\n\t\tmdb = rcu_dereference_protected(br->mdb, 1);\n\t\thash = br_ip_hash(mdb, group);\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tmp = kzalloc(sizeof(*mp), GFP_ATOMIC);\n\tif (unlikely(!mp))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmp->br = br;\n\tmp->addr = *group;\n\tsetup_timer(&mp->timer, br_multicast_group_expired,\n\t\t    (unsigned long)mp);\n\tsetup_timer(&mp->query_timer, br_multicast_group_query_expired,\n\t\t    (unsigned long)mp);\n\n\thlist_add_head_rcu(&mp->hlist[mdb->ver], &mdb->mhash[hash]);\n\tmdb->size++;\n\nout:\n\treturn mp;\n}\n\nstatic int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\n\tif (!port) {\n\t\tif (hlist_unhashed(&mp->mglist))\n\t\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\n\trcu_assign_pointer(*pp, p);\n\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\n\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n\nstatic int br_ip4_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      __be32 group)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv4_is_local_multicast(group))\n\t\treturn 0;\n\n\tbr_group.u.ip4 = group;\n\tbr_group.proto = htons(ETH_P_IP);\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic int br_ip6_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      const struct in6_addr *group)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv6_is_local_multicast(group))\n\t\treturn 0;\n\n\tipv6_addr_copy(&br_group.u.ip6, group);\n\tbr_group.proto = htons(ETH_P_IP);\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}\n#endif\n\nstatic void br_multicast_router_expired(unsigned long data)\n{\n\tstruct net_bridge_port *port = (void *)data;\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (port->multicast_router != 1 ||\n\t    timer_pending(&port->multicast_router_timer) ||\n\t    hlist_unhashed(&port->rlist))\n\t\tgoto out;\n\n\thlist_del_init_rcu(&port->rlist);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_local_router_expired(unsigned long data)\n{\n}\n\nstatic void __br_multicast_send_query(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      struct br_ip *ip)\n{\n\tstruct sk_buff *skb;\n\n\tskb = br_multicast_alloc_query(br, ip);\n\tif (!skb)\n\t\treturn;\n\n\tif (port) {\n\t\t__skb_push(skb, sizeof(struct ethhdr));\n\t\tskb->dev = port->dev;\n\t\tNF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,\n\t\t\tdev_queue_xmit);\n\t} else\n\t\tnetif_rx(skb);\n}\n\nstatic void br_multicast_send_query(struct net_bridge *br,\n\t\t\t\t    struct net_bridge_port *port, u32 sent)\n{\n\tunsigned long time;\n\tstruct br_ip br_group;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled ||\n\t    timer_pending(&br->multicast_querier_timer))\n\t\treturn;\n\n\tmemset(&br_group.u, 0, sizeof(br_group.u));\n\n\tbr_group.proto = htons(ETH_P_IP);\n\t__br_multicast_send_query(br, port, &br_group);\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tbr_group.proto = htons(ETH_P_IPV6);\n\t__br_multicast_send_query(br, port, &br_group);\n#endif\n\n\ttime = jiffies;\n\ttime += sent < br->multicast_startup_query_count ?\n\t\tbr->multicast_startup_query_interval :\n\t\tbr->multicast_query_interval;\n\tmod_timer(port ? &port->multicast_query_timer :\n\t\t\t &br->multicast_query_timer, time);\n}\n\nstatic void br_multicast_port_query_expired(unsigned long data)\n{\n\tstruct net_bridge_port *port = (void *)data;\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (port->state == BR_STATE_DISABLED ||\n\t    port->state == BR_STATE_BLOCKING)\n\t\tgoto out;\n\n\tif (port->multicast_startup_queries_sent <\n\t    br->multicast_startup_query_count)\n\t\tport->multicast_startup_queries_sent++;\n\n\tbr_multicast_send_query(port->br, port,\n\t\t\t\tport->multicast_startup_queries_sent);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_add_port(struct net_bridge_port *port)\n{\n\tport->multicast_router = 1;\n\n\tsetup_timer(&port->multicast_router_timer, br_multicast_router_expired,\n\t\t    (unsigned long)port);\n\tsetup_timer(&port->multicast_query_timer,\n\t\t    br_multicast_port_query_expired, (unsigned long)port);\n}\n\nvoid br_multicast_del_port(struct net_bridge_port *port)\n{\n\tdel_timer_sync(&port->multicast_router_timer);\n}\n\nstatic void __br_multicast_enable_port(struct net_bridge_port *port)\n{\n\tport->multicast_startup_queries_sent = 0;\n\n\tif (try_to_del_timer_sync(&port->multicast_query_timer) >= 0 ||\n\t    del_timer(&port->multicast_query_timer))\n\t\tmod_timer(&port->multicast_query_timer, jiffies);\n}\n\nvoid br_multicast_enable_port(struct net_bridge_port *port)\n{\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_disabled || !netif_running(br->dev))\n\t\tgoto out;\n\n\t__br_multicast_enable_port(port);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_disable_port(struct net_bridge_port *port)\n{\n\tstruct net_bridge *br = port->br;\n\tstruct net_bridge_port_group *pg;\n\tstruct hlist_node *p, *n;\n\n\tspin_lock(&br->multicast_lock);\n\thlist_for_each_entry_safe(pg, p, n, &port->mglist, mglist)\n\t\tbr_multicast_del_pg(br, pg);\n\n\tif (!hlist_unhashed(&port->rlist))\n\t\thlist_del_init_rcu(&port->rlist);\n\tdel_timer(&port->multicast_router_timer);\n\tdel_timer(&port->multicast_query_timer);\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic int br_ip4_multicast_igmp3_report(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct igmpv3_report *ih;\n\tstruct igmpv3_grec *grec;\n\tint i;\n\tint len;\n\tint num;\n\tint type;\n\tint err = 0;\n\t__be32 group;\n\n\tif (!pskb_may_pull(skb, sizeof(*ih)))\n\t\treturn -EINVAL;\n\n\tih = igmpv3_report_hdr(skb);\n\tnum = ntohs(ih->ngrec);\n\tlen = sizeof(*ih);\n\n\tfor (i = 0; i < num; i++) {\n\t\tlen += sizeof(*grec);\n\t\tif (!pskb_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\tgrec = (void *)(skb->data + len - sizeof(*grec));\n\t\tgroup = grec->grec_mca;\n\t\ttype = grec->grec_type;\n\n\t\tlen += ntohs(grec->grec_nsrcs) * 4;\n\t\tif (!pskb_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\t/* We treat this as an IGMPv2 report for now. */\n\t\tswitch (type) {\n\t\tcase IGMPV3_MODE_IS_INCLUDE:\n\t\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = br_ip4_multicast_add_group(br, port, group);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic int br_ip6_multicast_mld2_report(struct net_bridge *br,\n\t\t\t\t\tstruct net_bridge_port *port,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct icmp6hdr *icmp6h;\n\tstruct mld2_grec *grec;\n\tint i;\n\tint len;\n\tint num;\n\tint err = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(*icmp6h)))\n\t\treturn -EINVAL;\n\n\ticmp6h = icmp6_hdr(skb);\n\tnum = ntohs(icmp6h->icmp6_dataun.un_data16[1]);\n\tlen = sizeof(*icmp6h);\n\n\tfor (i = 0; i < num; i++) {\n\t\t__be16 *nsrcs, _nsrcs;\n\n\t\tnsrcs = skb_header_pointer(skb,\n\t\t\t\t\t   len + offsetof(struct mld2_grec,\n\t\t\t\t\t\t\t  grec_mca),\n\t\t\t\t\t   sizeof(_nsrcs), &_nsrcs);\n\t\tif (!nsrcs)\n\t\t\treturn -EINVAL;\n\n\t\tif (!pskb_may_pull(skb,\n\t\t\t\t   len + sizeof(*grec) +\n\t\t\t\t   sizeof(struct in6_addr) * (*nsrcs)))\n\t\t\treturn -EINVAL;\n\n\t\tgrec = (struct mld2_grec *)(skb->data + len);\n\t\tlen += sizeof(*grec) + sizeof(struct in6_addr) * (*nsrcs);\n\n\t\t/* We treat these as MLDv1 reports for now. */\n\t\tswitch (grec->grec_type) {\n\t\tcase MLD2_MODE_IS_INCLUDE:\n\t\tcase MLD2_MODE_IS_EXCLUDE:\n\t\tcase MLD2_CHANGE_TO_INCLUDE:\n\t\tcase MLD2_CHANGE_TO_EXCLUDE:\n\t\tcase MLD2_ALLOW_NEW_SOURCES:\n\t\tcase MLD2_BLOCK_OLD_SOURCES:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = br_ip6_multicast_add_group(br, port, &grec->grec_mca);\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n#endif\n\n/*\n * Add port to rotuer_list\n *  list is maintained ordered by pointer value\n *  and locked by br->multicast_lock and RCU\n */\nstatic void br_multicast_add_router(struct net_bridge *br,\n\t\t\t\t    struct net_bridge_port *port)\n{\n\tstruct net_bridge_port *p;\n\tstruct hlist_node *n, *slot = NULL;\n\n\thlist_for_each_entry(p, n, &br->router_list, rlist) {\n\t\tif ((unsigned long) port >= (unsigned long) p)\n\t\t\tbreak;\n\t\tslot = n;\n\t}\n\n\tif (slot)\n\t\thlist_add_after_rcu(slot, &port->rlist);\n\telse\n\t\thlist_add_head_rcu(&port->rlist, &br->router_list);\n}\n\nstatic void br_multicast_mark_router(struct net_bridge *br,\n\t\t\t\t     struct net_bridge_port *port)\n{\n\tunsigned long now = jiffies;\n\n\tif (!port) {\n\t\tif (br->multicast_router == 1)\n\t\t\tmod_timer(&br->multicast_router_timer,\n\t\t\t\t  now + br->multicast_querier_interval);\n\t\treturn;\n\t}\n\n\tif (port->multicast_router != 1)\n\t\treturn;\n\n\tif (!hlist_unhashed(&port->rlist))\n\t\tgoto timer;\n\n\tbr_multicast_add_router(br, port);\n\ntimer:\n\tmod_timer(&port->multicast_router_timer,\n\t\t  now + br->multicast_querier_interval);\n}\n\nstatic void br_multicast_query_received(struct net_bridge *br,\n\t\t\t\t\tstruct net_bridge_port *port,\n\t\t\t\t\tint saddr)\n{\n\tif (saddr)\n\t\tmod_timer(&br->multicast_querier_timer,\n\t\t\t  jiffies + br->multicast_querier_interval);\n\telse if (timer_pending(&br->multicast_querier_timer))\n\t\treturn;\n\n\tbr_multicast_mark_router(br, port);\n}\n\nstatic int br_ip4_multicast_query(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct igmphdr *ih = igmp_hdr(skb);\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct igmpv3_query *ih3;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long max_delay;\n\tunsigned long now = jiffies;\n\t__be32 group;\n\tint err = 0;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tbr_multicast_query_received(br, port, !!iph->saddr);\n\n\tgroup = ih->group;\n\n\tif (skb->len == sizeof(*ih)) {\n\t\tmax_delay = ih->code * (HZ / IGMP_TIMER_SCALE);\n\n\t\tif (!max_delay) {\n\t\t\tmax_delay = 10 * HZ;\n\t\t\tgroup = 0;\n\t\t}\n\t} else {\n\t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tih3 = igmpv3_query_hdr(skb);\n\t\tif (ih3->nsrcs)\n\t\t\tgoto out;\n\n\t\tmax_delay = ih3->code ?\n\t\t\t    IGMPV3_MRC(ih3->code) * (HZ / IGMP_TIMER_SCALE) : 1;\n\t}\n\n\tif (!group)\n\t\tgoto out;\n\n\tmp = br_mdb_ip4_get(mlock_dereference(br->mdb, br), group);\n\tif (!mp)\n\t\tgoto out;\n\n\tmax_delay *= br->multicast_last_member_count;\n\n\tif (!hlist_unhashed(&mp->mglist) &&\n\t    (timer_pending(&mp->timer) ?\n\t     time_after(mp->timer.expires, now + max_delay) :\n\t     try_to_del_timer_sync(&mp->timer) >= 0))\n\t\tmod_timer(&mp->timer, now + max_delay);\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (timer_pending(&p->timer) ?\n\t\t    time_after(p->timer.expires, now + max_delay) :\n\t\t    try_to_del_timer_sync(&p->timer) >= 0)\n\t\t\tmod_timer(&mp->timer, now + max_delay);\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic int br_ip6_multicast_query(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tstruct mld_msg *mld = (struct mld_msg *) icmp6_hdr(skb);\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct mld2_query *mld2q;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long max_delay;\n\tunsigned long now = jiffies;\n\tstruct in6_addr *group = NULL;\n\tint err = 0;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tbr_multicast_query_received(br, port, !ipv6_addr_any(&ip6h->saddr));\n\n\tif (skb->len == sizeof(*mld)) {\n\t\tif (!pskb_may_pull(skb, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *) icmp6_hdr(skb);\n\t\tmax_delay = msecs_to_jiffies(htons(mld->mld_maxdelay));\n\t\tif (max_delay)\n\t\t\tgroup = &mld->mld_mca;\n\t} else if (skb->len >= sizeof(*mld2q)) {\n\t\tif (!pskb_may_pull(skb, sizeof(*mld2q))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld2q = (struct mld2_query *)icmp6_hdr(skb);\n\t\tif (!mld2q->mld2q_nsrcs)\n\t\t\tgroup = &mld2q->mld2q_mca;\n\t\tmax_delay = mld2q->mld2q_mrc ? MLDV2_MRC(mld2q->mld2q_mrc) : 1;\n\t}\n\n\tif (!group)\n\t\tgoto out;\n\n\tmp = br_mdb_ip6_get(mlock_dereference(br->mdb, br), group);\n\tif (!mp)\n\t\tgoto out;\n\n\tmax_delay *= br->multicast_last_member_count;\n\tif (!hlist_unhashed(&mp->mglist) &&\n\t    (timer_pending(&mp->timer) ?\n\t     time_after(mp->timer.expires, now + max_delay) :\n\t     try_to_del_timer_sync(&mp->timer) >= 0))\n\t\tmod_timer(&mp->timer, now + max_delay);\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (timer_pending(&p->timer) ?\n\t\t    time_after(p->timer.expires, now + max_delay) :\n\t\t    try_to_del_timer_sync(&p->timer) >= 0)\n\t\t\tmod_timer(&mp->timer, now + max_delay);\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n#endif\n\nstatic void br_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t     struct net_bridge_port *port,\n\t\t\t\t     struct br_ip *group)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tunsigned long now;\n\tunsigned long time;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED) ||\n\t    timer_pending(&br->multicast_querier_timer))\n\t\tgoto out;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, group);\n\tif (!mp)\n\t\tgoto out;\n\n\tnow = jiffies;\n\ttime = now + br->multicast_last_member_count *\n\t\t     br->multicast_last_member_interval;\n\n\tif (!port) {\n\t\tif (!hlist_unhashed(&mp->mglist) &&\n\t\t    (timer_pending(&mp->timer) ?\n\t\t     time_after(mp->timer.expires, time) :\n\t\t     try_to_del_timer_sync(&mp->timer) >= 0)) {\n\t\t\tmod_timer(&mp->timer, time);\n\n\t\t\tmp->queries_sent = 0;\n\t\t\tmod_timer(&mp->query_timer, now);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tfor (p = mlock_dereference(mp->ports, br);\n\t     p != NULL;\n\t     p = mlock_dereference(p->next, br)) {\n\t\tif (p->port != port)\n\t\t\tcontinue;\n\n\t\tif (!hlist_unhashed(&p->mglist) &&\n\t\t    (timer_pending(&p->timer) ?\n\t\t     time_after(p->timer.expires, time) :\n\t\t     try_to_del_timer_sync(&p->timer) >= 0)) {\n\t\t\tmod_timer(&p->timer, time);\n\n\t\t\tp->queries_sent = 0;\n\t\t\tmod_timer(&p->query_timer, now);\n\t\t}\n\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_ip4_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t __be32 group)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv4_is_local_multicast(group))\n\t\treturn;\n\n\tbr_group.u.ip4 = group;\n\tbr_group.proto = htons(ETH_P_IP);\n\n\tbr_multicast_leave_group(br, port, &br_group);\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic void br_ip6_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t const struct in6_addr *group)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv6_is_local_multicast(group))\n\t\treturn;\n\n\tipv6_addr_copy(&br_group.u.ip6, group);\n\tbr_group.proto = htons(ETH_P_IPV6);\n\n\tbr_multicast_leave_group(br, port, &br_group);\n}\n#endif\n\nstatic int br_multicast_ipv4_rcv(struct net_bridge *br,\n\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct sk_buff *skb2 = skb;\n\tstruct iphdr *iph;\n\tstruct igmphdr *ih;\n\tunsigned len;\n\tunsigned offset;\n\tint err;\n\n\t/* We treat OOM as packet loss for now. */\n\tif (!pskb_may_pull(skb, sizeof(*iph)))\n\t\treturn -EINVAL;\n\n\tiph = ip_hdr(skb);\n\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\treturn -EINVAL;\n\n\tif (!pskb_may_pull(skb, ip_hdrlen(skb)))\n\t\treturn -EINVAL;\n\n\tiph = ip_hdr(skb);\n\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\treturn -EINVAL;\n\n\tif (iph->protocol != IPPROTO_IGMP)\n\t\treturn 0;\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len || len < ip_hdrlen(skb))\n\t\treturn -EINVAL;\n\n\tif (skb->len > len) {\n\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb2)\n\t\t\treturn -ENOMEM;\n\n\t\terr = pskb_trim_rcsum(skb2, len);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\tlen -= ip_hdrlen(skb2);\n\toffset = skb_network_offset(skb2) + ip_hdrlen(skb2);\n\t__skb_pull(skb2, offset);\n\tskb_reset_transport_header(skb2);\n\n\terr = -EINVAL;\n\tif (!pskb_may_pull(skb2, sizeof(*ih)))\n\t\tgoto out;\n\n\tswitch (skb2->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (!csum_fold(skb2->csum))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase CHECKSUM_NONE:\n\t\tskb2->csum = 0;\n\t\tif (skb_checksum_complete(skb2))\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\n\n\tBR_INPUT_SKB_CB(skb)->igmp = 1;\n\tih = igmp_hdr(skb2);\n\n\tswitch (ih->type) {\n\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\t\tBR_INPUT_SKB_CB(skb2)->mrouters_only = 1;\n\t\terr = br_ip4_multicast_add_group(br, port, ih->group);\n\t\tbreak;\n\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\t\terr = br_ip4_multicast_igmp3_report(br, port, skb2);\n\t\tbreak;\n\tcase IGMP_HOST_MEMBERSHIP_QUERY:\n\t\terr = br_ip4_multicast_query(br, port, skb2);\n\t\tbreak;\n\tcase IGMP_HOST_LEAVE_MESSAGE:\n\t\tbr_ip4_multicast_leave_group(br, port, ih->group);\n\t\tbreak;\n\t}\n\nout:\n\t__skb_push(skb2, offset);\nerr_out:\n\tif (skb2 != skb)\n\t\tkfree_skb(skb2);\n\treturn err;\n}\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\nstatic int br_multicast_ipv6_rcv(struct net_bridge *br,\n\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct sk_buff *skb2;\n\tstruct ipv6hdr *ip6h;\n\tstruct icmp6hdr *icmp6h;\n\tu8 nexthdr;\n\tunsigned len;\n\tint offset;\n\tint err;\n\n\tif (!pskb_may_pull(skb, sizeof(*ip6h)))\n\t\treturn -EINVAL;\n\n\tip6h = ipv6_hdr(skb);\n\n\t/*\n\t * We're interested in MLD messages only.\n\t *  - Version is 6\n\t *  - MLD has always Router Alert hop-by-hop option\n\t *  - But we do not support jumbrograms.\n\t */\n\tif (ip6h->version != 6 ||\n\t    ip6h->nexthdr != IPPROTO_HOPOPTS ||\n\t    ip6h->payload_len == 0)\n\t\treturn 0;\n\n\tlen = ntohs(ip6h->payload_len);\n\tif (skb->len < len)\n\t\treturn -EINVAL;\n\n\tnexthdr = ip6h->nexthdr;\n\toffset = ipv6_skip_exthdr(skb, sizeof(*ip6h), &nexthdr);\n\n\tif (offset < 0 || nexthdr != IPPROTO_ICMPV6)\n\t\treturn 0;\n\n\t/* Okay, we found ICMPv6 header */\n\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\tif (!pskb_may_pull(skb2, offset + sizeof(struct icmp6hdr)))\n\t\tgoto out;\n\n\tlen -= offset - skb_network_offset(skb2);\n\n\t__skb_pull(skb2, offset);\n\tskb_reset_transport_header(skb2);\n\n\ticmp6h = icmp6_hdr(skb2);\n\n\tswitch (icmp6h->icmp6_type) {\n\tcase ICMPV6_MGM_QUERY:\n\tcase ICMPV6_MGM_REPORT:\n\tcase ICMPV6_MGM_REDUCTION:\n\tcase ICMPV6_MLD2_REPORT:\n\t\tbreak;\n\tdefault:\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* Okay, we found MLD message. Check further. */\n\tif (skb2->len > len) {\n\t\terr = pskb_trim_rcsum(skb2, len);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tswitch (skb2->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (!csum_fold(skb2->csum))\n\t\t\tbreak;\n\t\t/*FALLTHROUGH*/\n\tcase CHECKSUM_NONE:\n\t\tskb2->csum = 0;\n\t\tif (skb_checksum_complete(skb2))\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\n\n\tBR_INPUT_SKB_CB(skb)->igmp = 1;\n\n\tswitch (icmp6h->icmp6_type) {\n\tcase ICMPV6_MGM_REPORT:\n\t    {\n\t\tstruct mld_msg *mld;\n\t\tif (!pskb_may_pull(skb2, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *)skb_transport_header(skb2);\n\t\tBR_INPUT_SKB_CB(skb2)->mrouters_only = 1;\n\t\terr = br_ip6_multicast_add_group(br, port, &mld->mld_mca);\n\t\tbreak;\n\t    }\n\tcase ICMPV6_MLD2_REPORT:\n\t\terr = br_ip6_multicast_mld2_report(br, port, skb2);\n\t\tbreak;\n\tcase ICMPV6_MGM_QUERY:\n\t\terr = br_ip6_multicast_query(br, port, skb2);\n\t\tbreak;\n\tcase ICMPV6_MGM_REDUCTION:\n\t    {\n\t\tstruct mld_msg *mld;\n\t\tif (!pskb_may_pull(skb2, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *)skb_transport_header(skb2);\n\t\tbr_ip6_multicast_leave_group(br, port, &mld->mld_mca);\n\t    }\n\t}\n\nout:\n\tkfree_skb(skb2);\n\treturn err;\n}\n#endif\n\nint br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,\n\t\t     struct sk_buff *skb)\n{\n\tBR_INPUT_SKB_CB(skb)->igmp = 0;\n\tBR_INPUT_SKB_CB(skb)->mrouters_only = 0;\n\n\tif (br->multicast_disabled)\n\t\treturn 0;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\treturn br_multicast_ipv4_rcv(br, port, skb);\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tcase htons(ETH_P_IPV6):\n\t\treturn br_multicast_ipv6_rcv(br, port, skb);\n#endif\n\t}\n\n\treturn 0;\n}\n\nstatic void br_multicast_query_expired(unsigned long data)\n{\n\tstruct net_bridge *br = (void *)data;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_startup_queries_sent <\n\t    br->multicast_startup_query_count)\n\t\tbr->multicast_startup_queries_sent++;\n\n\tbr_multicast_send_query(br, NULL, br->multicast_startup_queries_sent);\n\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_init(struct net_bridge *br)\n{\n\tbr->hash_elasticity = 4;\n\tbr->hash_max = 512;\n\n\tbr->multicast_router = 1;\n\tbr->multicast_last_member_count = 2;\n\tbr->multicast_startup_query_count = 2;\n\n\tbr->multicast_last_member_interval = HZ;\n\tbr->multicast_query_response_interval = 10 * HZ;\n\tbr->multicast_startup_query_interval = 125 * HZ / 4;\n\tbr->multicast_query_interval = 125 * HZ;\n\tbr->multicast_querier_interval = 255 * HZ;\n\tbr->multicast_membership_interval = 260 * HZ;\n\n\tspin_lock_init(&br->multicast_lock);\n\tsetup_timer(&br->multicast_router_timer,\n\t\t    br_multicast_local_router_expired, 0);\n\tsetup_timer(&br->multicast_querier_timer,\n\t\t    br_multicast_local_router_expired, 0);\n\tsetup_timer(&br->multicast_query_timer, br_multicast_query_expired,\n\t\t    (unsigned long)br);\n}\n\nvoid br_multicast_open(struct net_bridge *br)\n{\n\tbr->multicast_startup_queries_sent = 0;\n\n\tif (br->multicast_disabled)\n\t\treturn;\n\n\tmod_timer(&br->multicast_query_timer, jiffies);\n}\n\nvoid br_multicast_stop(struct net_bridge *br)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *p, *n;\n\tu32 ver;\n\tint i;\n\n\tdel_timer_sync(&br->multicast_router_timer);\n\tdel_timer_sync(&br->multicast_querier_timer);\n\tdel_timer_sync(&br->multicast_query_timer);\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (!mdb)\n\t\tgoto out;\n\n\tbr->mdb = NULL;\n\n\tver = mdb->ver;\n\tfor (i = 0; i < mdb->max; i++) {\n\t\thlist_for_each_entry_safe(mp, p, n, &mdb->mhash[i],\n\t\t\t\t\t  hlist[ver]) {\n\t\t\tdel_timer(&mp->timer);\n\t\t\tdel_timer(&mp->query_timer);\n\t\t\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\t\t}\n\t}\n\n\tif (mdb->old) {\n\t\tspin_unlock_bh(&br->multicast_lock);\n\t\trcu_barrier_bh();\n\t\tspin_lock_bh(&br->multicast_lock);\n\t\tWARN_ON(mdb->old);\n\t}\n\n\tmdb->old = mdb;\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\tspin_unlock_bh(&br->multicast_lock);\n}\n\nint br_multicast_set_router(struct net_bridge *br, unsigned long val)\n{\n\tint err = -ENOENT;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 2:\n\t\tdel_timer(&br->multicast_router_timer);\n\t\t/* fall through */\n\tcase 1:\n\t\tbr->multicast_router = val;\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\n\treturn err;\n}\n\nint br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val)\n{\n\tstruct net_bridge *br = p->br;\n\tint err = -ENOENT;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || p->state == BR_STATE_DISABLED)\n\t\tgoto unlock;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tp->multicast_router = val;\n\t\terr = 0;\n\n\t\tif (val < 2 && !hlist_unhashed(&p->rlist))\n\t\t\thlist_del_init_rcu(&p->rlist);\n\n\t\tif (val == 1)\n\t\t\tbreak;\n\n\t\tdel_timer(&p->multicast_router_timer);\n\n\t\tif (val == 0)\n\t\t\tbreak;\n\n\t\tbr_multicast_add_router(br, p);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n\nint br_multicast_toggle(struct net_bridge *br, unsigned long val)\n{\n\tstruct net_bridge_port *port;\n\tint err = 0;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_disabled == !val)\n\t\tgoto unlock;\n\n\tbr->multicast_disabled = !val;\n\tif (br->multicast_disabled)\n\t\tgoto unlock;\n\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (mdb) {\n\t\tif (mdb->old) {\n\t\t\terr = -EEXIST;\nrollback:\n\t\t\tbr->multicast_disabled = !!val;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, mdb->max,\n\t\t\t\t    br->hash_elasticity);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\n\tbr_multicast_open(br);\n\tlist_for_each_entry(port, &br->port_list, list) {\n\t\tif (port->state == BR_STATE_DISABLED ||\n\t\t    port->state == BR_STATE_BLOCKING)\n\t\t\tcontinue;\n\n\t\t__br_multicast_enable_port(port);\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n\nint br_multicast_set_hash_max(struct net_bridge *br, unsigned long val)\n{\n\tint err = -ENOENT;\n\tu32 old;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\terr = -EINVAL;\n\tif (!is_power_of_2(val))\n\t\tgoto unlock;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (mdb && val < mdb->size)\n\t\tgoto unlock;\n\n\terr = 0;\n\n\told = br->hash_max;\n\tbr->hash_max = val;\n\n\tif (mdb) {\n\t\tif (mdb->old) {\n\t\t\terr = -EEXIST;\nrollback:\n\t\t\tbr->hash_max = old;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, br->hash_max,\n\t\t\t\t    br->hash_elasticity);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n"], "filenames": ["net/bridge/br_multicast.c"], "buggy_code_start_loc": [722], "buggy_code_end_loc": [723], "fixing_code_start_loc": [722], "fixing_code_end_loc": [724], "type": "CWE-399", "message": "The br_multicast_add_group function in net/bridge/br_multicast.c in the Linux kernel before 2.6.38, when a certain Ethernet bridge configuration is used, allows local users to cause a denial of service (memory corruption and system crash) by sending IGMP packets to a local interface.", "other": {"cve": {"id": "CVE-2011-0716", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:01.847", "lastModified": "2023-02-13T01:18:30.800", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The br_multicast_add_group function in net/bridge/br_multicast.c in the Linux kernel before 2.6.38, when a certain Ethernet bridge configuration is used, allows local users to cause a denial of service (memory corruption and system crash) by sending IGMP packets to a local interface."}, {"lang": "es", "value": "La funci\u00f3n de br_multicast_add_group en net/bridge/br_multicast.c en versiones del kernel de Linux anteriores a v2.6.38, cuando se usa una determinada configuraci\u00f3n de bridge Ethernet, permite a usuarios locales provocar una denegaci\u00f3n de servicio (corrupci\u00f3n de la memoria y ca\u00edda del sistema) mediante el env\u00edo de paquetes IGMP a una interfaz local."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.37.6", "matchCriteriaId": "084AC06C-2438-4BD5-A28D-8D24DE515135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.37:*:*:*:*:*:*:*", "matchCriteriaId": "18CBFC41-E9A9-456C-8A61-8DB2E6CE2E98"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.37:rc1:*:*:*:*:*:*", "matchCriteriaId": "2EA6C6E6-CAD5-4D43-AD96-66D5ACBB91CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.37:rc2:*:*:*:*:*:*", "matchCriteriaId": "71905CF7-7C7B-43AC-970D-D3187A807903"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.37:rc3:*:*:*:*:*:*", "matchCriteriaId": "201421C9-E054-4FEB-A37A-8C314F242FBC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.37:rc4:*:*:*:*:*:*", "matchCriteriaId": "F157225D-C62C-465D-A758-DE6A6C48C397"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.37:rc5:*:*:*:*:*:*", "matchCriteriaId": "77BB49A9-39D0-49C4-A241-D1537590F508"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.37.1:*:*:*:*:*:*:*", "matchCriteriaId": "CF9A28CB-B307-4D0B-AC45-73964F766B09"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.37.2:*:*:*:*:*:*:*", "matchCriteriaId": "51838021-099C-4135-94E6-EC0276BAB750"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.37.3:*:*:*:*:*:*:*", "matchCriteriaId": "E0F4EBC4-1C6D-428C-9F23-8508EBBD3588"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.37.4:*:*:*:*:*:*:*", "matchCriteriaId": "B86233BC-2B7D-44EB-8253-458E89046B17"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.37.5:*:*:*:*:*:*:*", "matchCriteriaId": "110BB215-C869-4BEB-962D-81A1F9F896B6"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.38", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=6b0d6a9b4296fa16a28d10d416db7a770fc03287", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/02/17/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=678169", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/6b0d6a9b4296fa16a28d10d416db7a770fc03287", "source": "secalert@redhat.com", "tags": ["Patch", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6b0d6a9b4296fa16a28d10d416db7a770fc03287"}}