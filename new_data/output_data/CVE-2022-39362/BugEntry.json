{"buggy_code": ["import _ from \"underscore\";\nimport querystring from \"querystring\";\nimport { LocationDescriptorObject } from \"history\";\n\nimport * as MetabaseAnalytics from \"metabase/lib/analytics\";\nimport { deserializeCardFromUrl, loadCard } from \"metabase/lib/card\";\nimport { normalize } from \"metabase/lib/query/normalize\";\nimport * as Urls from \"metabase/lib/urls\";\n\nimport { cardIsEquivalent } from \"metabase/meta/Card\";\n\nimport { setErrorPage } from \"metabase/redux/app\";\nimport { getMetadata } from \"metabase/selectors/metadata\";\nimport { getUser } from \"metabase/selectors/user\";\n\nimport Snippets from \"metabase/entities/snippets\";\nimport { fetchAlertsForQuestion } from \"metabase/alert/alert\";\n\nimport Question from \"metabase-lib/lib/Question\";\nimport NativeQuery from \"metabase-lib/lib/queries/NativeQuery\";\nimport StructuredQuery from \"metabase-lib/lib/queries/StructuredQuery\";\n\nimport {\n  Dispatch,\n  GetState,\n  QueryBuilderUIControls,\n} from \"metabase-types/store\";\n\nimport { Card, SavedCard } from \"metabase-types/types/Card\";\n\nimport { getQueryBuilderModeFromLocation } from \"../../typed-utils\";\nimport { redirectToNewQuestionFlow, updateUrl } from \"../navigation\";\nimport { cancelQuery, runQuestionQuery } from \"../querying\";\n\nimport { loadMetadataForCard, resetQB } from \"./core\";\nimport {\n  handleDashboardParameters,\n  getParameterValuesForQuestion,\n} from \"./parameterUtils\";\n\ntype BlankQueryOptions = {\n  db?: string;\n  table?: string;\n  segment?: string;\n  metric?: string;\n};\n\ntype QueryParams = BlankQueryOptions & {\n  slug?: string;\n  objectId?: string;\n};\n\ntype UIControls = Partial<QueryBuilderUIControls>;\n\nconst ARCHIVED_ERROR = {\n  data: {\n    error_code: \"archived\",\n  },\n  context: \"query-builder\",\n};\n\nconst NOT_FOUND_ERROR = {\n  data: {\n    error_code: \"not-found\",\n  },\n  context: \"query-builder\",\n};\n\nfunction getCardForBlankQuestion({\n  db,\n  table,\n  segment,\n  metric,\n}: BlankQueryOptions) {\n  const databaseId = db ? parseInt(db) : undefined;\n  const tableId = table ? parseInt(table) : undefined;\n\n  let question = Question.create({ databaseId, tableId });\n\n  if (databaseId && tableId) {\n    if (segment) {\n      question = (question.query() as StructuredQuery)\n        .filter([\"segment\", parseInt(segment)])\n        .question();\n    }\n    if (metric) {\n      question = (question.query() as StructuredQuery)\n        .aggregate([\"metric\", parseInt(metric)])\n        .question();\n    }\n  }\n\n  return question.card();\n}\n\nfunction deserializeCard(serializedCard: string) {\n  const card = deserializeCardFromUrl(serializedCard);\n  if (card.dataset_query.database != null) {\n    // Ensure older MBQL is supported\n    card.dataset_query = normalize(card.dataset_query);\n  }\n  return card;\n}\n\nasync function fetchAndPrepareSavedQuestionCards(cardId: number) {\n  const card = await loadCard(cardId);\n  const originalCard = { ...card };\n\n  // for showing the \"started from\" lineage correctly when adding filters/breakouts and when going back and forth\n  // in browser history, the original_card_id has to be set for the current card (simply the id of card itself for now)\n  card.original_card_id = card.id;\n\n  return { card, originalCard };\n}\n\nasync function fetchAndPrepareAdHocQuestionCards(deserializedCard: Card) {\n  if (!deserializedCard.original_card_id) {\n    return {\n      card: deserializedCard,\n      originalCard: null,\n    };\n  }\n\n  const originalCard = await loadCard(deserializedCard.original_card_id);\n\n  if (cardIsEquivalent(deserializedCard, originalCard)) {\n    return {\n      card: { ...originalCard },\n      originalCard: originalCard,\n    };\n  }\n\n  return {\n    card: deserializedCard,\n    originalCard,\n  };\n}\n\ntype ResolveCardsResult = {\n  card: Card;\n  originalCard?: Card;\n};\n\nasync function resolveCards({\n  cardId,\n  deserializedCard,\n  options,\n}: {\n  cardId?: number;\n  deserializedCard?: Card;\n  options: BlankQueryOptions;\n}): Promise<ResolveCardsResult> {\n  if (!cardId && !deserializedCard) {\n    return {\n      card: getCardForBlankQuestion(options),\n    };\n  }\n  return cardId\n    ? fetchAndPrepareSavedQuestionCards(cardId)\n    : fetchAndPrepareAdHocQuestionCards(deserializedCard as Card);\n}\n\nfunction parseHash(hash?: string) {\n  let options: BlankQueryOptions = {};\n  let serializedCard;\n\n  // hash can contain either query params starting with ? or a base64 serialized card\n  if (hash) {\n    const cleanHash = hash.replace(/^#/, \"\");\n    if (cleanHash.charAt(0) === \"?\") {\n      options = querystring.parse(cleanHash.substring(1));\n    } else {\n      serializedCard = cleanHash;\n    }\n  }\n\n  return { options, serializedCard };\n}\n\nfunction isSavedCard(card: Card): card is SavedCard {\n  return !!(card as SavedCard).id;\n}\n\nexport const INITIALIZE_QB = \"metabase/qb/INITIALIZE_QB\";\n\nasync function handleQBInit(\n  dispatch: Dispatch,\n  getState: GetState,\n  {\n    location,\n    params,\n  }: { location: LocationDescriptorObject; params: QueryParams },\n) {\n  dispatch(resetQB());\n  dispatch(cancelQuery());\n\n  const queryParams = location.query;\n  const cardId = Urls.extractEntityId(params.slug);\n  const uiControls: UIControls = getQueryBuilderModeFromLocation(location);\n  const { options, serializedCard } = parseHash(location.hash);\n  const hasCard = cardId || serializedCard;\n\n  if (\n    !hasCard &&\n    !options.db &&\n    !options.table &&\n    !options.segment &&\n    !options.metric\n  ) {\n    dispatch(redirectToNewQuestionFlow());\n    return;\n  }\n\n  const deserializedCard = serializedCard\n    ? deserializeCard(serializedCard)\n    : null;\n\n  const { card, originalCard } = await resolveCards({\n    cardId,\n    deserializedCard,\n    options,\n  });\n\n  if (isSavedCard(card) && card.archived) {\n    dispatch(setErrorPage(ARCHIVED_ERROR));\n    return;\n  }\n\n  if (\n    isSavedCard(card) &&\n    !card?.dataset &&\n    location.pathname?.startsWith(\"/model\")\n  ) {\n    dispatch(setErrorPage(NOT_FOUND_ERROR));\n    return;\n  }\n\n  if (hasCard) {\n    await handleDashboardParameters(card, {\n      deserializedCard,\n      originalCard,\n      dispatch,\n      getState,\n    });\n  } else {\n    if (options.metric) {\n      uiControls.isShowingSummarySidebar = true;\n    }\n  }\n\n  MetabaseAnalytics.trackStructEvent(\n    \"QueryBuilder\",\n    hasCard ? \"Query Loaded\" : \"Query Started\",\n    card.dataset_query.type,\n  );\n\n  if (isSavedCard(card)) {\n    dispatch(fetchAlertsForQuestion(card.id));\n  }\n\n  await dispatch(loadMetadataForCard(card));\n  const metadata = getMetadata(getState());\n\n  let question = new Question(card, metadata);\n  if (question.isSaved()) {\n    // Don't set viz automatically for saved questions\n    question = question.lockDisplay();\n\n    const currentUser = getUser(getState());\n    if (currentUser.is_qbnewb) {\n      uiControls.isShowingNewbModal = true;\n      MetabaseAnalytics.trackStructEvent(\"QueryBuilder\", \"Show Newb Modal\");\n    }\n  }\n\n  if (question && question.isNative()) {\n    const query = question.query() as NativeQuery;\n    if (query.hasSnippets() && !query.readOnly()) {\n      await dispatch(Snippets.actions.fetchList());\n      const snippets = Snippets.selectors.getList(getState());\n      question = question.setQuery(\n        query.updateQueryTextWithNewSnippetNames(snippets),\n      );\n    }\n  }\n\n  const finalCard = question.card();\n\n  const parameterValues = getParameterValuesForQuestion({\n    card: finalCard,\n    queryParams,\n    metadata,\n  });\n\n  const objectId = params?.objectId || queryParams?.objectId;\n\n  dispatch({\n    type: INITIALIZE_QB,\n    payload: {\n      card: finalCard,\n      originalCard,\n      uiControls,\n      parameterValues,\n      objectId,\n    },\n  });\n\n  if (uiControls.queryBuilderMode !== \"notebook\") {\n    if (question.canRun()) {\n      // Timeout to allow Parameters widget to set parameterValues\n      setTimeout(\n        () => dispatch(runQuestionQuery({ shouldUpdateUrl: false })),\n        0,\n      );\n    }\n    dispatch(\n      updateUrl(finalCard, {\n        replaceState: true,\n        preserveParameters: hasCard,\n        objectId,\n      }),\n    );\n  }\n}\n\nexport const initializeQB =\n  (location: LocationDescriptorObject, params: QueryParams) =>\n  async (dispatch: Dispatch, getState: GetState) => {\n    try {\n      await handleQBInit(dispatch, getState, { location, params });\n    } catch (error) {\n      console.warn(\"initializeQB failed because of an error:\", error);\n      dispatch(setErrorPage(error));\n    }\n  };\n", "import { LocationDescriptorObject } from \"history\";\nimport _ from \"underscore\";\nimport xhrMock from \"xhr-mock\";\n\nimport * as CardLib from \"metabase/lib/card\";\nimport * as Urls from \"metabase/lib/urls\";\n\nimport * as alert from \"metabase/alert/alert\";\nimport Databases from \"metabase/entities/databases\";\nimport Snippets from \"metabase/entities/snippets\";\nimport { setErrorPage } from \"metabase/redux/app\";\n\nimport Question from \"metabase-lib/lib/Question\";\nimport NativeQuery from \"metabase-lib/lib/queries/NativeQuery\";\nimport StructuredQuery from \"metabase-lib/lib/queries/StructuredQuery\";\nimport {\n  getAdHocQuestion,\n  getSavedStructuredQuestion,\n  getSavedNativeQuestion,\n  getUnsavedNativeQuestion,\n  getStructuredModel,\n  getNativeModel,\n} from \"metabase-lib/mocks\";\n\nimport { User } from \"metabase-types/api\";\nimport { createMockUser } from \"metabase-types/api/mocks\";\nimport { Card, NativeDatasetQuery } from \"metabase-types/types/Card\";\nimport { TemplateTag } from \"metabase-types/types/Query\";\nimport { createMockState } from \"metabase-types/store/mocks\";\n\nimport {\n  SAMPLE_DATABASE,\n  ORDERS,\n  state as entitiesState,\n  metadata,\n} from \"__support__/sample_database_fixture\";\n\nimport * as navigation from \"../navigation\";\nimport * as querying from \"../querying\";\n\nimport * as core from \"./core\";\nimport { initializeQB } from \"./initializeQB\";\n\ntype BaseSetupOpts = {\n  user?: User;\n  location: LocationDescriptorObject;\n  params: Record<string, unknown>;\n};\n\nasync function baseSetup({ user, location, params }: BaseSetupOpts) {\n  jest.useFakeTimers();\n\n  const dispatch = jest.fn().mockReturnValue({ mock: \"mock\" });\n\n  const state = {\n    ...createMockState(),\n    ...entitiesState,\n  };\n  if (user) {\n    state.currentUser = user;\n  }\n  const getState = () => state;\n\n  await initializeQB(location, params)(dispatch, getState);\n  jest.runAllTimers();\n\n  const actions = dispatch.mock.calls.find(\n    call => call[0]?.type === \"metabase/qb/INITIALIZE_QB\",\n  );\n  const hasDispatchedInitAction = Array.isArray(actions);\n  const result = hasDispatchedInitAction ? actions[0].payload : null;\n\n  return { dispatch, state, result };\n}\n\nfunction getLocationForQuestion(\n  question: Question,\n  extra: LocationDescriptorObject = {},\n): LocationDescriptorObject {\n  const card = question.card();\n  const isSaved = question.isSaved();\n  return {\n    pathname: isSaved ? Urls.question(card) : Urls.serializedQuestion(card),\n    hash: !isSaved ? CardLib.serializeCardForUrl(card) : \"\",\n    query: {},\n    ...extra,\n  };\n}\n\nfunction getQueryParamsForQuestion(\n  question: Question,\n  extra: Record<string, unknown> = {},\n): Record<string, unknown> {\n  if (!question.isSaved()) {\n    return extra;\n  }\n  const id = question.id();\n  const name = question.displayName();\n  return {\n    slug: `${id}-${name}`,\n    ...extra,\n  };\n}\n\ntype SetupOpts = Omit<BaseSetupOpts, \"location\" | \"params\"> & {\n  question: Question;\n  location?: LocationDescriptorObject;\n  params?: Record<string, unknown>;\n};\n\nasync function setup({\n  question,\n  location = getLocationForQuestion(question),\n  params = getQueryParamsForQuestion(question),\n  ...opts\n}: SetupOpts) {\n  const card = question.card();\n\n  if (\"id\" in card) {\n    xhrMock.get(`/api/card/${card.id}`, {\n      body: JSON.stringify(card),\n    });\n  }\n\n  return baseSetup({ location, params, ...opts });\n}\n\nconst SNIPPET: TemplateTag = {\n  id: \"id\",\n  \"snippet-id\": 1,\n  \"display-name\": \"foo\",\n  name: \"foo\",\n  \"snippet-name\": \"foo\",\n  type: \"snippet\",\n};\n\nconst NATIVE_QUESTION_WITH_SNIPPET: NativeDatasetQuery = {\n  type: \"native\",\n  database: 1,\n  native: {\n    query: \"select * from orders {{ foo }}\",\n    \"template-tags\": {\n      foo: SNIPPET,\n    },\n  },\n};\n\ndescribe(\"QB Actions > initializeQB\", () => {\n  beforeAll(() => {\n    console.warn = jest.fn();\n  });\n\n  beforeEach(() => {\n    xhrMock.setup();\n  });\n\n  afterEach(() => {\n    xhrMock.teardown();\n    jest.restoreAllMocks();\n  });\n\n  const TEST_CASE = {\n    SAVED_STRUCTURED_QUESTION: {\n      question: getSavedStructuredQuestion(),\n      questionType: \"saved structured question\",\n    },\n    UNSAVED_STRUCTURED_QUESTION: {\n      question: getAdHocQuestion(),\n      questionType: \"ad-hoc structured question\",\n    },\n\n    SAVED_NATIVE_QUESTION: {\n      question: getSavedNativeQuestion(),\n      questionType: \"saved native question\",\n    },\n    UNSAVED_NATIVE_QUESTION: {\n      question: getUnsavedNativeQuestion(),\n      questionType: \"unsaved native question\",\n    },\n\n    STRUCTURED_MODEL: {\n      question: getStructuredModel(),\n      questionType: \"structured model\",\n    },\n    NATIVE_MODEL: {\n      question: getNativeModel(),\n      questionType: \"native model\",\n    },\n  };\n\n  const ALL_TEST_CASES = Object.values(TEST_CASE);\n\n  const SAVED_QUESTION_TEST_CASES = [\n    TEST_CASE.SAVED_STRUCTURED_QUESTION,\n    TEST_CASE.SAVED_NATIVE_QUESTION,\n  ];\n\n  const UNSAVED_QUESTION_TEST_CASES = [\n    TEST_CASE.UNSAVED_STRUCTURED_QUESTION,\n    TEST_CASE.UNSAVED_NATIVE_QUESTION,\n  ];\n\n  const MODEL_TEST_CASES = [TEST_CASE.STRUCTURED_MODEL, TEST_CASE.NATIVE_MODEL];\n\n  const NATIVE_SNIPPETS_TEST_CASES = [\n    {\n      question: getSavedNativeQuestion({\n        dataset_query: NATIVE_QUESTION_WITH_SNIPPET,\n      }),\n      questionType: \"saved native question with snippets\",\n    },\n    {\n      question: getUnsavedNativeQuestion({\n        dataset_query: NATIVE_QUESTION_WITH_SNIPPET,\n      }),\n      questionType: \"unsaved native question with snippets\",\n    },\n  ];\n\n  describe(\"common\", () => {\n    ALL_TEST_CASES.forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      describe(questionType, () => {\n        it(\"resets QB state before doing anything\", async () => {\n          const resetQBSpy = jest.spyOn(core, \"resetQB\");\n          await setup({ question });\n          expect(resetQBSpy).toHaveBeenCalledTimes(1);\n        });\n\n        it(\"cancels running query before doing anything\", async () => {\n          const cancelQuerySpy = jest.spyOn(querying, \"cancelQuery\");\n          await setup({ question });\n          expect(cancelQuerySpy).toHaveBeenCalledTimes(1);\n        });\n\n        it(\"fetches question metadata\", async () => {\n          const loadMetadataForCardSpy = jest.spyOn(\n            core,\n            \"loadMetadataForCard\",\n          );\n\n          await setup({ question });\n\n          expect(loadMetadataForCardSpy).toHaveBeenCalledTimes(1);\n          expect(loadMetadataForCardSpy).toHaveBeenCalledWith(\n            expect.objectContaining(question.card()),\n          );\n        });\n\n        it(\"runs question query in view mode\", async () => {\n          const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n          await setup({ question });\n          expect(runQuestionQuerySpy).toHaveBeenCalledTimes(1);\n        });\n\n        it(\"does not run non-runnable question queries\", async () => {\n          const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n          jest.spyOn(Question.prototype, \"canRun\").mockReturnValue(false);\n\n          await setup({ question });\n\n          expect(runQuestionQuerySpy).not.toHaveBeenCalled();\n        });\n\n        it(\"does not run question query in notebook mode\", async () => {\n          const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/notebook`,\n          });\n\n          await setup({ question, location });\n\n          expect(runQuestionQuerySpy).not.toHaveBeenCalled();\n        });\n\n        it(\"passes object ID from params correctly\", async () => {\n          const params = getQueryParamsForQuestion(question, { objectId: 123 });\n          const { result } = await setup({ question, params });\n          expect(result.objectId).toBe(123);\n        });\n\n        it(\"passes object ID from location query params correctly\", async () => {\n          const location = getLocationForQuestion(question, {\n            query: { objectId: 123 },\n          });\n          const { result } = await setup({ question, location });\n          expect(result.objectId).toBe(123);\n        });\n\n        it(\"sets original card id on the card\", async () => {\n          const { result } = await setup({ question });\n          expect(result.card.original_card_id).toBe(question.id());\n        });\n\n        it(\"sets QB mode correctly\", async () => {\n          const { result } = await setup({ question });\n          expect(result.uiControls.queryBuilderMode).toBe(\"view\");\n        });\n\n        it(\"sets QB mode to notebook if opening /notebook route\", async () => {\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/notebook`,\n          });\n\n          const { result } = await setup({ question, location });\n\n          expect(result.uiControls.queryBuilderMode).toBe(\"notebook\");\n        });\n      });\n    });\n  });\n\n  describe(\"saved questions and models\", () => {\n    [...SAVED_QUESTION_TEST_CASES, ...MODEL_TEST_CASES].forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      describe(questionType, () => {\n        it(\"locks question display\", async () => {\n          const { result } = await setup({\n            question: question.setDisplayIsLocked(false),\n          });\n          expect(result.card.displayIsLocked).toBe(true);\n        });\n\n        it(\"fetches alerts\", async () => {\n          const fetchAlertsForQuestionSpy = jest.spyOn(\n            alert,\n            \"fetchAlertsForQuestion\",\n          );\n\n          await setup({ question });\n\n          expect(fetchAlertsForQuestionSpy).toHaveBeenCalledWith(question.id());\n        });\n\n        it(\"passes object ID from params correctly\", async () => {\n          const params = getQueryParamsForQuestion(question, { objectId: 123 });\n          const { result } = await setup({ question, params });\n          expect(result.objectId).toBe(123);\n        });\n\n        it(\"passes object ID from location query params correctly\", async () => {\n          const location = getLocationForQuestion(question, {\n            query: { objectId: 123 },\n          });\n          const { result } = await setup({ question, location });\n          expect(result.objectId).toBe(123);\n        });\n\n        describe(\"newb modal\", () => {\n          it(\"shows modal if user has not yet seen it\", async () => {\n            const { result } = await setup({\n              question,\n              user: createMockUser({ is_qbnewb: true }),\n            });\n            expect(result.uiControls.isShowingNewbModal).toBe(true);\n          });\n\n          it(\"does not show modal if user has seen it\", async () => {\n            const { result } = await setup({\n              question,\n              user: createMockUser({ is_qbnewb: false }),\n            });\n            expect(result.uiControls.isShowingNewbModal).toBeFalsy();\n          });\n        });\n\n        it(\"throws error for archived card\", async () => {\n          const { dispatch } = await setup({\n            question: question.setCard({\n              ...question.card(),\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              archived: true,\n            }),\n          });\n\n          expect(dispatch).toHaveBeenCalledWith(\n            setErrorPage(\n              expect.objectContaining({ data: { error_code: \"archived\" } }),\n            ),\n          );\n        });\n      });\n    });\n  });\n\n  describe(\"saved questions\", () => {\n    SAVED_QUESTION_TEST_CASES.forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      describe(questionType, () => {\n        it(\"throws not found error when opening question with /model URL\", async () => {\n          const { dispatch } = await setup({\n            question,\n            location: { pathname: `/model/${question.id()}` },\n          });\n\n          expect(dispatch).toHaveBeenCalledWith(\n            setErrorPage(\n              expect.objectContaining({ data: { error_code: \"not-found\" } }),\n            ),\n          );\n        });\n      });\n    });\n  });\n\n  describe(\"unsaved questions\", () => {\n    UNSAVED_QUESTION_TEST_CASES.forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      const ORIGINAL_CARD_ID = 321;\n\n      function getOriginalQuestion(card?: Partial<Card>) {\n        return question.setCard({\n          ...question.card(),\n          ...card,\n          id: ORIGINAL_CARD_ID,\n        });\n      }\n\n      function setupWithOriginalQuestion({\n        originalQuestion,\n        question,\n        ...opts\n      }: SetupOpts & { originalQuestion: Question }) {\n        const q = question.setCard({\n          ...question.card(),\n          original_card_id: ORIGINAL_CARD_ID,\n        });\n\n        xhrMock.get(`/api/card/${originalQuestion.id()}`, {\n          body: JSON.stringify(originalQuestion.card()),\n        });\n\n        return setup({ question: q, ...opts });\n      }\n\n      describe(questionType, () => {\n        it(\"loads original card\", async () => {\n          const originalQuestion = getOriginalQuestion({ display: \"line\" });\n\n          const { result } = await setupWithOriginalQuestion({\n            question,\n            originalQuestion,\n          });\n\n          expect(result.card.original_card_id).toBe(ORIGINAL_CARD_ID);\n          expect(result.originalCard).toEqual(originalQuestion.card());\n        });\n\n        it(\"replaces card with original card if they're equal\", async () => {\n          const originalQuestion = getOriginalQuestion();\n\n          const { result } = await setupWithOriginalQuestion({\n            question,\n            originalQuestion,\n          });\n\n          expect(result.card.original_card_id).toBeUndefined();\n          expect(result.originalCard).toEqual(originalQuestion.card());\n          expect(result.card).toEqual(originalQuestion.lockDisplay().card());\n        });\n\n        it(\"does not lock question display\", async () => {\n          const { result } = await setup({ question });\n          expect(result.card.displayIsLocked).toBeFalsy();\n        });\n\n        it(\"does not try to fetch alerts\", async () => {\n          const fetchAlertsForQuestionSpy = jest.spyOn(\n            alert,\n            \"fetchAlertsForQuestion\",\n          );\n\n          await setup({ question });\n\n          expect(fetchAlertsForQuestionSpy).not.toHaveBeenCalled();\n        });\n\n        it(\"does not show qbnewb modal\", async () => {\n          const { result } = await setup({\n            question,\n            user: createMockUser({ is_qbnewb: true }),\n          });\n          expect(result.uiControls.isShowingNewbModal).toBeFalsy();\n        });\n\n        it(\"handles error if couldn't deserialize card hash\", async () => {\n          const error = new Error(\"failed to deserialize card\");\n          jest\n            .spyOn(CardLib, \"deserializeCardFromUrl\")\n            .mockImplementation(() => {\n              throw error;\n            });\n\n          const { dispatch } = await setup({ question });\n\n          expect(dispatch).toHaveBeenCalledWith(setErrorPage(error));\n        });\n      });\n    });\n  });\n\n  describe(\"models\", () => {\n    MODEL_TEST_CASES.forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      describe(questionType, () => {\n        it(\"runs question query on /query route\", async () => {\n          const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/query`,\n          });\n\n          await setup({ question, location });\n\n          expect(runQuestionQuerySpy).toHaveBeenCalledTimes(1);\n        });\n        it(\"runs question query on /metadata route\", async () => {\n          const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/metadata`,\n          });\n\n          await setup({ question, location });\n\n          expect(runQuestionQuerySpy).toHaveBeenCalledTimes(1);\n        });\n\n        it(\"sets UI state correctly for /query route\", async () => {\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/query`,\n          });\n\n          const { result } = await setup({ question, location });\n\n          expect(result.uiControls.queryBuilderMode).toBe(\"dataset\");\n          expect(result.uiControls.datasetEditorTab).toBe(\"query\");\n        });\n\n        it(\"sets UI state correctly for /metadata route\", async () => {\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/metadata`,\n          });\n\n          const { result } = await setup({ question, location });\n\n          expect(result.uiControls.queryBuilderMode).toBe(\"dataset\");\n          expect(result.uiControls.datasetEditorTab).toBe(\"metadata\");\n        });\n      });\n    });\n  });\n\n  describe(\"native questions with snippets\", () => {\n    NATIVE_SNIPPETS_TEST_CASES.forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      type SnippetsSetupOpts = Omit<SetupOpts, \"question\"> & {\n        hasLoadedDatabase?: boolean;\n        hasDatabaseWritePermission?: boolean;\n        snippet?: unknown;\n      };\n\n      function setupSnippets({\n        hasLoadedDatabase = true,\n        hasDatabaseWritePermission = true,\n        snippet,\n        ...opts\n      }: SnippetsSetupOpts) {\n        const clone = question.clone();\n\n        jest\n          .spyOn(NativeQuery.prototype, \"readOnly\")\n          .mockReturnValue(!hasDatabaseWritePermission);\n        jest\n          .spyOn(NativeQuery.prototype, \"isEditable\")\n          .mockReturnValue(hasDatabaseWritePermission);\n\n        Snippets.actions.fetchList = jest.fn();\n        Snippets.selectors.getList = jest\n          .fn()\n          .mockReturnValue(snippet ? [snippet] : []);\n\n        return setup({ question: clone, ...opts });\n      }\n\n      describe(questionType, () => {\n        it(\"loads snippets if have DB write permissions\", async () => {\n          await setupSnippets({ hasDatabaseWritePermission: true });\n          expect(Snippets.actions.fetchList).toHaveBeenCalledTimes(1);\n        });\n\n        it(\"does not load snippets if missing DB write permissions\", async () => {\n          Databases.selectors.getObject = jest.fn().mockReturnValue({\n            native_permissions: \"none\",\n          });\n          Snippets.actions.fetchList = jest.fn();\n          Snippets.selectors.getList = jest.fn().mockReturnValue([SNIPPET]);\n\n          await setupSnippets({ hasDatabaseWritePermission: false });\n\n          expect(Snippets.actions.fetchList).not.toHaveBeenCalled();\n        });\n\n        it(\"replaces snippet names with fresh ones from the backend\", async () => {\n          const { result } = await setupSnippets({\n            snippet: {\n              id: SNIPPET[\"snippet-id\"],\n              name: \"bar\",\n            },\n          });\n          const formattedQuestion = new Question(result.card, metadata);\n          const query = formattedQuestion.query() as NativeQuery;\n\n          expect(query.queryText().toLowerCase()).toBe(\n            \"select * from orders {{snippet: bar}}\",\n          );\n        });\n      });\n    });\n  });\n\n  describe(\"blank question\", () => {\n    type BlankSetupOpts = Omit<BaseSetupOpts, \"location\" | \"params\"> & {\n      db?: number;\n      table?: number;\n      segment?: number;\n      metric?: number;\n    };\n\n    function setupBlank({\n      db,\n      table,\n      segment,\n      metric,\n      ...opts\n    }: BlankSetupOpts = {}) {\n      const hashParams = [\n        db ? `db=${db}` : \"\",\n        table ? `table=${table}` : \"\",\n        segment ? `segment=${segment}` : \"\",\n        metric ? `metric=${metric}` : \"\",\n      ].filter(Boolean);\n\n      let hash = hashParams.join(\"&\");\n      if (hash) {\n        hash = \"#?\" + hash;\n      }\n\n      const location: LocationDescriptorObject = {\n        pathname: \"/question\",\n        hash,\n      };\n\n      const params = {\n        db: db ? String(db) : undefined,\n        table: table ? String(table) : undefined,\n        segment: segment ? String(segment) : undefined,\n        metric: metric ? String(metric) : undefined,\n      };\n\n      return baseSetup({ location, params, ...opts });\n    }\n\n    async function setupOrdersTable(\n      opts: Omit<BlankSetupOpts, \"db\" | \"table\"> = {},\n    ) {\n      const { result, ...rest } = await setupBlank({\n        db: SAMPLE_DATABASE?.id,\n        table: ORDERS.id,\n        ...opts,\n      });\n\n      const question = new Question(result.card, metadata);\n      const query = question.query() as StructuredQuery;\n\n      return {\n        question,\n        query,\n        result,\n        ...rest,\n      };\n    }\n\n    it(\"redirects to new question flow if missing any options\", async () => {\n      const redirectSpy = jest.spyOn(navigation, \"redirectToNewQuestionFlow\");\n      await setupBlank();\n      expect(redirectSpy).toHaveBeenCalledTimes(1);\n    });\n\n    it(\"constructs a card based on provided 'db' param\", async () => {\n      const expectedCard = Question.create({\n        databaseId: SAMPLE_DATABASE?.id,\n      }).card();\n\n      const { result } = await setupBlank({ db: SAMPLE_DATABASE?.id });\n      const question = new Question(result.card, metadata);\n      const query = question.query() as StructuredQuery;\n\n      expect(result.card).toEqual(expectedCard);\n      expect(query.sourceTableId()).toBe(null);\n      expect(result.originalCard).toBeUndefined();\n    });\n\n    it(\"constructs a card based on provided 'db' and 'table' params\", async () => {\n      const expectedCard = ORDERS.question().card();\n\n      const { result } = await setupOrdersTable();\n\n      expect(result.card).toEqual(expectedCard);\n      expect(result.originalCard).toBeUndefined();\n    });\n\n    it(\"applies 'segment' param correctly\", async () => {\n      const SEGMENT_ID = 777;\n\n      const { query } = await setupOrdersTable({ segment: SEGMENT_ID });\n      const [filter] = query.filters();\n\n      expect(filter.raw()).toEqual([\"segment\", SEGMENT_ID]);\n    });\n\n    it(\"opens summarization sidebar if metric is applied\", async () => {\n      const METRIC_ID = 777;\n      const { result } = await setupOrdersTable({ metric: METRIC_ID });\n      expect(result.uiControls.isShowingSummarySidebar).toBe(true);\n    });\n\n    it(\"applies 'metric' param correctly\", async () => {\n      const METRIC_ID = 777;\n\n      const { query } = await setupOrdersTable({ metric: METRIC_ID });\n      const [aggregation] = query.aggregations();\n\n      expect(aggregation.raw()).toEqual([\"metric\", METRIC_ID]);\n    });\n\n    it(\"opens summarization sidebar if metric is applied\", async () => {\n      const METRIC_ID = 777;\n      const { result } = await setupOrdersTable({ metric: METRIC_ID });\n      expect(result.uiControls.isShowingSummarySidebar).toBe(true);\n    });\n\n    it(\"applies both 'metric' and 'segment' params\", async () => {\n      const SEGMENT_ID = 111;\n      const METRIC_ID = 222;\n\n      const { query } = await setupOrdersTable({\n        segment: SEGMENT_ID,\n        metric: METRIC_ID,\n      });\n      const [filter] = query.filters();\n      const [aggregation] = query.aggregations();\n\n      expect(filter.raw()).toEqual([\"segment\", SEGMENT_ID]);\n      expect(aggregation.raw()).toEqual([\"metric\", METRIC_ID]);\n    });\n\n    it(\"fetches question metadata\", async () => {\n      const loadMetadataForCardSpy = jest.spyOn(core, \"loadMetadataForCard\");\n\n      const { question } = await setupOrdersTable();\n\n      expect(loadMetadataForCardSpy).toHaveBeenCalledTimes(1);\n      expect(loadMetadataForCardSpy).toHaveBeenCalledWith(\n        expect.objectContaining(question.card()),\n      );\n    });\n\n    it(\"runs question query\", async () => {\n      const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n      await setupOrdersTable();\n      expect(runQuestionQuerySpy).toHaveBeenCalledTimes(1);\n    });\n\n    it(\"does not lock question display\", async () => {\n      const { result } = await setupOrdersTable();\n      expect(result.card.displayIsLocked).toBeFalsy();\n    });\n\n    it(\"does not try to fetch alerts\", async () => {\n      const fetchAlertsForQuestionSpy = jest.spyOn(\n        alert,\n        \"fetchAlertsForQuestion\",\n      );\n\n      await setupOrdersTable();\n\n      expect(fetchAlertsForQuestionSpy).not.toHaveBeenCalled();\n    });\n\n    it(\"does not show qbnewb modal\", async () => {\n      const { result } = await setupOrdersTable({\n        user: createMockUser({ is_qbnewb: true }),\n      });\n      expect(result.uiControls.isShowingNewbModal).toBeFalsy();\n    });\n  });\n});\n", "import { SAMPLE_DB_ID, SAMPLE_DB_TABLES } from \"__support__/e2e/cypress_data\";\n\nconst {\n  STATIC_ORDERS_ID,\n  STATIC_PRODUCTS_ID,\n  STATIC_PEOPLE_ID,\n  STATIC_REVIEWS_ID,\n} = SAMPLE_DB_TABLES;\n\nexport function adhocQuestionHash(question) {\n  if (question.display) {\n    // without \"locking\" the display, the QB will run its picking logic and override the setting\n    question = Object.assign({}, question, { displayIsLocked: true });\n  }\n  return btoa(unescape(encodeURIComponent(JSON.stringify(question))));\n}\n\n/**\n * This is the query generated by clicking \"New\" and then choosing the (gui) \"Question\".\n */\nexport function startNewQuestion() {\n  const newQuestionQuery = {\n    creationType: \"custom_question\",\n    dataset_query: {\n      database: null,\n      query: {\n        \"source-table\": null,\n      },\n      type: \"query\",\n    },\n    visualization_settings: {},\n  };\n\n  const hash = adhocQuestionHash(newQuestionQuery);\n\n  cy.visit(\"/question/notebook#\" + hash);\n}\n/**\n * Visit any valid query in an ad-hoc manner.\n *\n * @param {object} question\n * @param {{callback: function, mode: (undefined|\"notebook\")}} config\n */\nexport function visitQuestionAdhoc(question, { callback, mode } = {}) {\n  const questionMode = mode === \"notebook\" ? \"/notebook\" : \"\";\n\n  const [url, alias] = getInterceptDetails(question, mode);\n\n  cy.intercept(url).as(alias);\n\n  cy.visit(`/question${questionMode}#` + adhocQuestionHash(question));\n\n  cy.wait(\"@\" + alias).then(xhr => {\n    callback && callback(xhr);\n  });\n}\n\n/**\n * Open a table as an ad-hoc query in a simple or a notebook mode, and optionally limit the number of results.\n *\n * @param {{database:number, table: number, mode: (undefined|\"notebook\"), limit: number, callback: function}} config\n */\nexport function openTable({\n  database = SAMPLE_DB_ID,\n  table,\n  mode = null,\n  limit,\n  callback,\n} = {}) {\n  visitQuestionAdhoc(\n    {\n      dataset_query: {\n        database,\n        query: {\n          \"source-table\": table,\n          limit,\n        },\n        type: \"query\",\n      },\n    },\n    { mode, callback },\n  );\n}\n\nexport function openProductsTable({ mode, limit, callback } = {}) {\n  return openTable({ table: STATIC_PRODUCTS_ID, mode, limit, callback });\n}\n\nexport function openOrdersTable({ mode, limit, callback } = {}) {\n  return openTable({ table: STATIC_ORDERS_ID, mode, limit, callback });\n}\n\nexport function openPeopleTable({ mode, limit, callback } = {}) {\n  return openTable({ table: STATIC_PEOPLE_ID, mode, limit, callback });\n}\n\nexport function openReviewsTable({ mode, limit, callback } = {}) {\n  return openTable({ table: STATIC_REVIEWS_ID, mode, limit, callback });\n}\n\nfunction getInterceptDetails(question, mode) {\n  // When visiting notebook mode directly, we don't render any results to the page.\n  // Therefore, there is no `dataset` to wait for.\n  // But we need to make sure the schema for our database is loaded before we can proceed.\n  if (mode === \"notebook\") {\n    return [`/api/database/${SAMPLE_DB_ID}/schema/PUBLIC`, \"publicSchema\"];\n  }\n\n  const {\n    display,\n    dataset_query: { type },\n  } = question;\n\n  // native queries should use the normal dataset endpoint even when set to pivot\n  const isPivotEndpoint = display === \"pivot\" && type === \"query\";\n\n  const url = isPivotEndpoint ? \"/api/dataset/pivot\" : \"/api/dataset\";\n  const alias = isPivotEndpoint ? \"pivotDataset\" : \"dataset\";\n\n  return [url, alias];\n}\n", "// Find a text field by label text, type it in, then blur the field.\n// Commonly used in our Admin section as we auto-save settings.\nexport function typeAndBlurUsingLabel(label, value) {\n  cy.findByLabelText(label).clear().type(value).blur();\n}\n\nexport function visitAlias(alias) {\n  cy.get(alias).then(url => {\n    cy.visit(url);\n  });\n}\n\n/**\n * Open native (SQL) editor and alias it.\n *\n * @param {object} options\n * @param {string} [options.databaseName] - If there is more than one database, select the desired one by its name.\n * @param {string} [options.alias=\"editor\"] - The alias that can be used later in the test as `cy.get(\"@\" + alias)`.\n * @example\n * openNativeEditor().type(\"SELECT 123\");\n * @example\n * openNativeEditor({ databaseName: \"QA Postgres12\" }).type(\"SELECT 123\");\n */\nexport function openNativeEditor({\n  databaseName,\n  alias = \"editor\",\n  fromCurrentPage,\n} = {}) {\n  if (!fromCurrentPage) {\n    cy.visit(\"/\");\n  }\n  cy.findByText(\"New\").click();\n  cy.findByText(\"SQL query\").click();\n\n  databaseName && cy.findByText(databaseName).click();\n\n  return cy.get(\".ace_content\").as(alias).should(\"be.visible\");\n}\n\n/**\n * Executes native query and waits for the results to load.\n * Makes sure that the question is not \"dirty\" after the query successfully ran.\n * @param {string} [xhrAlias =\"dataset\"]\n */\nexport function runNativeQuery(xhrAlias = \"dataset\") {\n  cy.get(\".NativeQueryEditor .Icon-play\").click();\n  cy.wait(\"@\" + xhrAlias);\n  cy.icon(\"play\").should(\"not.exist\");\n}\n\n/**\n * Intercepts a request and returns resolve function that allows\n * the request to continue\n *\n * @param {string} method - Request method (\"GET\", \"POST\", etc)\n * @param {string} path - Request URL to intercept\n * @example\n * const req = interceptPromise(\"GET\", \"/dashboard/1\");\n * // ... do something before request is allowed to go through ...\n * req.resolve();\n */\nexport function interceptPromise(method, path) {\n  const state = {};\n  const promise = new Promise(resolve => {\n    state.resolve = resolve;\n  });\n  cy.intercept(method, path, req => {\n    return promise.then(() => {\n      req.continue();\n    });\n  });\n  return state;\n}\n\n/**\n * Executes and waits for all Cypress commands sequentially.\n * Helps to avoid excessive nesting and verbosity\n *\n * @param {Array.<Cypress.Chainable<any>>} commands - Cypress commands\n * @example\n * cypressWaitAll([\n *   cy.createQuestionAndAddToDashboard(firstQuery, 1),\n *   cy.createQuestionAndAddToDashboard(secondQuery, 1),\n * ]).then(() => {\n *   cy.visit(`/dashboard/1`);\n * });\n */\nconst cypressWaitAllRecursive = (results, currentCommand, commands) => {\n  return currentCommand.then(result => {\n    results.push(result);\n\n    const [nextCommand, ...rest] = Array.from(commands);\n\n    if (nextCommand == null) {\n      return results;\n    }\n\n    return cypressWaitAllRecursive(results, nextCommand, rest);\n  });\n};\n\nexport const cypressWaitAll = function (commands) {\n  const results = [];\n\n  return cypressWaitAllRecursive(\n    results,\n    cy.wrap(null, { log: false }),\n    commands,\n  );\n};\n\n/**\n * Visit a question and wait for its query to load.\n *\n * @param {number} id\n */\nexport function visitQuestion(id) {\n  // In case we use this function multiple times in a test, make sure aliases are unique for each question\n  const alias = \"cardQuery\" + id;\n\n  // We need to use the wildcard becase endpoint for pivot tables has the following format: `/api/card/pivot/${id}/query`\n  cy.intercept(\"POST\", `/api/card/**/${id}/query`).as(alias);\n\n  cy.visit(`/question/${id}`);\n\n  cy.wait(\"@\" + alias);\n}\n\n/**\n * Visit a dashboard and wait for the related queries to load.\n *\n * @param {number} dashboard_id\n */\nexport function visitDashboard(dashboard_id) {\n  // Some users will not have permissions for this request\n  cy.request({\n    method: \"GET\",\n    url: `/api/dashboard/${dashboard_id}`,\n    // That's why we have to ignore failures\n    failOnStatusCode: false,\n  }).then(({ status, body: { ordered_cards } }) => {\n    const dashboardAlias = \"getDashboard\" + dashboard_id;\n\n    cy.intercept(\"GET\", `/api/dashboard/${dashboard_id}`).as(dashboardAlias);\n\n    const canViewDashboard = hasAccess(status);\n    const validQuestions = dashboardHasQuestions(ordered_cards);\n\n    if (canViewDashboard && validQuestions) {\n      // If dashboard has valid questions (GUI or native),\n      // we need to alias each request and wait for their reponses\n      const aliases = validQuestions.map(\n        ({ id, card_id, card: { display } }) => {\n          const baseUrl =\n            display === \"pivot\"\n              ? `/api/dashboard/pivot/${dashboard_id}`\n              : `/api/dashboard/${dashboard_id}`;\n\n          const interceptUrl = `${baseUrl}/dashcard/${id}/card/${card_id}/query`;\n\n          const alias = \"dashcardQuery\" + id;\n\n          cy.intercept(\"POST\", interceptUrl).as(alias);\n\n          return `@${alias}`;\n        },\n      );\n\n      cy.visit(`/dashboard/${dashboard_id}`);\n\n      cy.wait(aliases);\n    } else {\n      // For a dashboard:\n      //  - without questions (can be empty or markdown only) or\n      //  - the one which user doesn't have access to\n      // the last request will always be `GET /api/dashboard/:dashboard_id`\n      cy.visit(`/dashboard/${dashboard_id}`);\n\n      cy.wait(`@${dashboardAlias}`);\n    }\n  });\n}\n\nfunction hasAccess(statusCode) {\n  return statusCode !== 403;\n}\n\nfunction dashboardHasQuestions(cards) {\n  if (Array.isArray(cards) && cards.length > 0) {\n    const questions = cards\n      // Filter out markdown cards\n      .filter(({ card_id }) => {\n        return card_id !== null;\n      })\n      // Filter out cards which the current user is not allowed to see\n      .filter(({ card }) => {\n        return card.dataset_query !== undefined;\n      });\n\n    const isPopulated = questions.length > 0;\n\n    return isPopulated && questions;\n  } else {\n    return false;\n  }\n}\n\nexport function interceptIfNotPreviouslyDefined({ method, url, alias } = {}) {\n  const aliases = Object.keys(cy.state(\"aliases\"));\n\n  const isAlreadyDefined = aliases.find(a => a === alias);\n\n  if (!isAlreadyDefined) {\n    cy.intercept(method, url).as(alias);\n  }\n}\n", "import {\n  restore,\n  popover,\n  modal,\n  openNativeEditor,\n  visitQuestionAdhoc,\n  summarize,\n  sidebar,\n  filter,\n  filterField,\n} from \"__support__/e2e/helpers\";\n\nimport { SAMPLE_DB_ID } from \"__support__/e2e/cypress_data\";\n\ndescribe(\"scenarios > question > native\", () => {\n  beforeEach(() => {\n    cy.intercept(\"POST\", \"api/dataset\").as(\"dataset\");\n    cy.intercept(\"POST\", \"api/card\").as(\"card\");\n    restore();\n    cy.signInAsNormalUser();\n  });\n\n  it(\"lets you create and run a SQL question\", () => {\n    openNativeEditor().type(\"select count(*) from orders\");\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains(\"18,760\");\n  });\n\n  it(\"displays an error\", () => {\n    openNativeEditor().type(\"select * from not_a_table\");\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains('Table \"NOT_A_TABLE\" not found');\n  });\n\n  it(\"displays an error when running selected text\", () => {\n    openNativeEditor().type(\n      \"select * from orders\" +\n        \"{leftarrow}\".repeat(3) + // move left three\n        \"{shift}{leftarrow}\".repeat(19), // highlight back to the front\n    );\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains('Table \"ORD\" not found');\n  });\n\n  it(\"should show referenced cards in the template tag sidebar\", () => {\n    openNativeEditor()\n      // start typing a question referenced\n      .type(\"select * from {{#}}\", {\n        parseSpecialCharSequences: false,\n      });\n\n    cy.contains(\"Question #\u2026\")\n      .parent()\n      .parent()\n      .contains(\"Pick a question or a model\")\n      .click({ force: true });\n\n    // selecting a question should update the query\n    popover().contains(\"Orders\").click();\n\n    cy.contains(\"select * from {{#1}}\");\n\n    // run query and see that a value from the results appears\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains(\"37.65\");\n\n    // update the text of the query to reference question 2\n    // :visible is needed because there is an unused .ace_content present in the DOM\n    cy.get(\".ace_content:visible\").type(\"{leftarrow}{leftarrow}{backspace}2\");\n\n    // sidebar should show updated question title and name\n    cy.contains(\"Question #2\").parent().parent().contains(\"Orders, Count\");\n\n    // run query again and see new result\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains(\"18,760\");\n  });\n\n  it(\"should handle template tags\", () => {\n    openNativeEditor().type(\"select * from PRODUCTS where RATING > {{Stars}}\", {\n      parseSpecialCharSequences: false,\n    });\n    cy.get(\"input[placeholder*='Stars']\").type(\"3\");\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.wait(\"@dataset\");\n    cy.contains(\"Showing 168 rows\");\n  });\n\n  it(\"should modify parameters accordingly when tags are modified\", () => {\n    openNativeEditor().type(\"select * from PRODUCTS where CATEGORY = {{cat}}\", {\n      parseSpecialCharSequences: false,\n    });\n    cy.findByTestId(\"sidebar-right\")\n      .findByText(\"Required?\")\n      .parent()\n      .find(\"input\")\n      .click();\n    cy.get(\"input[placeholder*='Enter a default value']\").type(\"Gizmo\");\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.wait(\"@dataset\");\n\n    cy.contains(\"Save\").click();\n\n    modal().within(() => {\n      cy.findByLabelText(\"Name\").type(\"Products on Category\");\n      cy.findByText(\"Save\").click();\n\n      cy.wait(\"@card\").should(xhr => {\n        const requestBody = xhr.request?.body;\n        expect(requestBody?.parameters?.length).to.equal(1);\n        const parameter = requestBody.parameters[0];\n        expect(parameter.default).to.equal(\"Gizmo\");\n      });\n    });\n\n    cy.findByText(\"Not now\").click();\n  });\n\n  it(\"can save a question with no rows\", () => {\n    openNativeEditor().type(\"select * from people where false\");\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains(\"No results!\");\n    cy.icon(\"contract\").click();\n    cy.contains(\"Save\").click();\n\n    modal().within(() => {\n      cy.findByLabelText(\"Name\").type(\"empty question\");\n      cy.findByText(\"Save\").click();\n    });\n\n    // confirm that the question saved and url updated\n    cy.location(\"pathname\").should(\"match\", /\\/question\\/\\d+/);\n  });\n\n  it(`shouldn't remove rows containing NULL when using \"Is not\" or \"Does not contain\" filter (metabase#13332)`, () => {\n    const FILTERS = [\"Is not\", \"Does not contain\"];\n\n    const questionDetails = {\n      name: \"13332\",\n      native: {\n        query: `SELECT null AS \"V\", 1 as \"N\" UNION ALL SELECT 'This has a value' AS \"V\", 2 as \"N\"`,\n        \"template-tags\": {},\n      },\n    };\n\n    cy.createNativeQuestion(questionDetails).then(({ body: { id } }) => {\n      visitQuestionAdhoc({\n        dataset_query: {\n          database: SAMPLE_DB_ID,\n          query: {\n            \"source-table\": `card__${id}`,\n          },\n          type: \"query\",\n        },\n      });\n    });\n\n    cy.findByText(\"This has a value\");\n\n    FILTERS.forEach(operator => {\n      cy.log(\"Apply a filter\");\n      filter();\n      filterField(\"V\", {\n        operator,\n        value: \"This has a value\",\n      });\n\n      cy.findByTestId(\"apply-filters\").click();\n\n      cy.log(\n        `**Mid-point assertion for \"${operator}\" filter| FAILING in v0.36.6**`,\n      );\n      cy.findByText(`V ${operator.toLowerCase()} This has a value`);\n      cy.findByText(\"No results!\").should(\"not.exist\");\n\n      cy.log(\n        \"**Final assertion: Count of rows with 'null' value should be 1**\",\n      );\n      // \"Count\" is pre-selected option for \"Summarize\"\n      summarize();\n      cy.findByText(\"Done\").click();\n      cy.get(\".ScalarValue\").contains(\"1\");\n\n      cy.findByTestId(\"qb-filters-panel\").within(() => {\n        cy.icon(\"close\").click();\n      });\n      summarize();\n      sidebar().within(() => {\n        cy.icon(\"close\").click();\n      });\n      cy.findByText(\"Done\").click();\n    });\n  });\n\n  it(\"should be able to add new columns after hiding some (metabase#15393)\", () => {\n    openNativeEditor().type(\"select 1 as visible, 2 as hidden\");\n    cy.get(\".NativeQueryEditor .Icon-play\").as(\"runQuery\").click();\n    cy.findByText(\"Settings\").click();\n    cy.findByTestId(\"sidebar-left\")\n      .as(\"sidebar\")\n      .contains(/hidden/i)\n      .siblings(\".Icon-close\")\n      .click();\n    cy.get(\"@editor\").type(\"{movetoend}, 3 as added\");\n    cy.get(\"@runQuery\").click();\n    cy.get(\"@sidebar\").contains(/added/i);\n  });\n\n  it(\"should recognize template tags and save them as parameters\", () => {\n    openNativeEditor().type(\n      \"select * from PRODUCTS where CATEGORY={{cat}} and RATING >= {{stars}}\",\n      {\n        parseSpecialCharSequences: false,\n      },\n    );\n    cy.get(\"input[placeholder*='Cat']\").type(\"Gizmo\");\n    cy.get(\"input[placeholder*='Stars']\").type(\"3\");\n\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.wait(\"@dataset\");\n\n    cy.contains(\"Save\").click();\n\n    modal().within(() => {\n      cy.findByLabelText(\"Name\").type(\"SQL Products\");\n      cy.findByText(\"Save\").click();\n\n      // parameters[] should reflect the template tags\n      cy.wait(\"@card\").should(xhr => {\n        const requestBody = xhr.request?.body;\n        expect(requestBody?.parameters?.length).to.equal(2);\n      });\n    });\n    cy.findByText(\"Not now\").click();\n\n    // Now load the question again and parameters[] should still be there\n    cy.intercept(\"GET\", \"/api/card/4\").as(\"cardQuestion\");\n    cy.visit(\"/question/4?cat=Gizmo&stars=3\");\n    cy.wait(\"@cardQuestion\").should(xhr => {\n      const responseBody = xhr.response?.body;\n      expect(responseBody?.parameters?.length).to.equal(2);\n    });\n  });\n\n  it(\"should link correctly from the variables sidebar (metabase#16212)\", () => {\n    cy.createNativeQuestion({\n      name: \"test-question\",\n      native: { query: 'select 1 as \"a\", 2 as \"b\"' },\n    }).then(({ body: { id: questionId } }) => {\n      openNativeEditor().type(`{{#${questionId}}}`, {\n        parseSpecialCharSequences: false,\n      });\n      cy.get(\".NativeQueryEditor .Icon-play\").click();\n      cy.get(\".Visualization\").within(() => {\n        cy.findByText(\"a\");\n        cy.findByText(\"b\");\n        cy.findByText(\"1\");\n        cy.findByText(\"2\");\n      });\n      cy.findByRole(\"link\", { name: `Question #${questionId}` })\n        .should(\"have.attr\", \"href\")\n        .and(\"eq\", `/question/${questionId}-test-question`);\n    });\n  });\n});\n", "import { restore, visitQuestion } from \"__support__/e2e/helpers\";\n\ndescribe(\"scenarios > permissions\", () => {\n  beforeEach(restore);\n\n  const PATHS = [\n    \"/dashboard/1\",\n    \"/question/1\",\n    \"/collection/1\",\n    \"/admin\",\n    // this url is a native query pointing at the sample db\n    \"/question#eyJkYXRhc2V0X3F1ZXJ5Ijp7InR5cGUiOiJuYXRpdmUiLCJuYXRpdmUiOnsicXVlcnkiOiJzZWxlY3QgMSIsInRlbXBsYXRlLXRhZ3MiOnt9fSwiZGF0YWJhc2UiOjF9LCJkaXNwbGF5IjoidGFibGUiLCJ2aXN1YWxpemF0aW9uX3NldHRpbmdzIjp7fX0=\",\n  ];\n\n  for (const path of PATHS) {\n    it(`should display the permissions screen on ${path}`, () => {\n      cy.signIn(\"none\");\n      cy.visit(path);\n      cy.icon(\"key\");\n      cy.contains(\"Sorry, you don\u2019t have permission to see that.\");\n    });\n  }\n\n  // There's no pulse in the fixture data, so we stub out the api call to\n  // replace the 404 with a 403.\n  it(\"should display the permissions screen for pulses\", () => {\n    cy.signIn(\"none\");\n    cy.server();\n    cy.route({ url: /\\/api\\/pulse\\/1/, status: 403, response: {} });\n    cy.visit(\"/pulse/1\");\n    cy.icon(\"key\");\n    cy.contains(\"Sorry, you don\u2019t have permission to see that.\");\n  });\n\n  it(\"should let a user with no data permissions view questions\", () => {\n    cy.signIn(\"nodata\");\n    visitQuestion(1);\n    cy.contains(\"February 11, 2019, 9:40 PM\"); // check that the data loads\n  });\n});\n", "import {\n  restore,\n  withDatabase,\n  adhocQuestionHash,\n} from \"__support__/e2e/helpers\";\n\nconst PG_DB_ID = 2;\n\nconst questionDetails = {\n  dataset_query: {\n    type: \"native\",\n    database: PG_DB_ID,\n    native: {\n      query: \"SELECT pg_sleep(10)\",\n    },\n  },\n};\n\ndescribe(\"issue 11727\", () => {\n  beforeEach(() => {\n    restore(\"postgres-12\");\n    cy.signInAsAdmin();\n    cy.intercept(\"GET\", \"/api/database\").as(\"getDatabases\");\n  });\n\n  it(\"should cancel the native query via the keyboard shortcut (metabase#11727)\", () => {\n    withDatabase(PG_DB_ID, () => {\n      cy.visit(`/question#` + adhocQuestionHash(questionDetails));\n      cy.wait(\"@getDatabases\");\n\n      cy.findByText(\"Doing science...\").should(\"be.visible\");\n      cy.get(\"body\").type(\"{cmd}{enter}\");\n      cy.findByText(\"Here's where your results will appear\").should(\n        \"be.visible\",\n      );\n    });\n  });\n});\n"], "fixing_code": ["import _ from \"underscore\";\nimport querystring from \"querystring\";\nimport { LocationDescriptorObject } from \"history\";\n\nimport * as MetabaseAnalytics from \"metabase/lib/analytics\";\nimport { deserializeCardFromUrl, loadCard } from \"metabase/lib/card\";\nimport { normalize } from \"metabase/lib/query/normalize\";\nimport * as Urls from \"metabase/lib/urls\";\n\nimport { cardIsEquivalent } from \"metabase/meta/Card\";\n\nimport { setErrorPage } from \"metabase/redux/app\";\nimport { getMetadata } from \"metabase/selectors/metadata\";\nimport { getUser } from \"metabase/selectors/user\";\n\nimport Snippets from \"metabase/entities/snippets\";\nimport { fetchAlertsForQuestion } from \"metabase/alert/alert\";\n\nimport Question from \"metabase-lib/lib/Question\";\nimport NativeQuery from \"metabase-lib/lib/queries/NativeQuery\";\nimport StructuredQuery from \"metabase-lib/lib/queries/StructuredQuery\";\n\nimport {\n  Dispatch,\n  GetState,\n  QueryBuilderUIControls,\n} from \"metabase-types/store\";\n\nimport { Card, SavedCard } from \"metabase-types/types/Card\";\n\nimport { getQueryBuilderModeFromLocation } from \"../../typed-utils\";\nimport { redirectToNewQuestionFlow, updateUrl } from \"../navigation\";\nimport { cancelQuery, runQuestionQuery } from \"../querying\";\n\nimport { loadMetadataForCard, resetQB } from \"./core\";\nimport {\n  handleDashboardParameters,\n  getParameterValuesForQuestion,\n} from \"./parameterUtils\";\n\ntype BlankQueryOptions = {\n  db?: string;\n  table?: string;\n  segment?: string;\n  metric?: string;\n};\n\ntype QueryParams = BlankQueryOptions & {\n  slug?: string;\n  objectId?: string;\n};\n\ntype UIControls = Partial<QueryBuilderUIControls>;\n\nconst ARCHIVED_ERROR = {\n  data: {\n    error_code: \"archived\",\n  },\n  context: \"query-builder\",\n};\n\nconst NOT_FOUND_ERROR = {\n  data: {\n    error_code: \"not-found\",\n  },\n  context: \"query-builder\",\n};\n\nfunction getCardForBlankQuestion({\n  db,\n  table,\n  segment,\n  metric,\n}: BlankQueryOptions) {\n  const databaseId = db ? parseInt(db) : undefined;\n  const tableId = table ? parseInt(table) : undefined;\n\n  let question = Question.create({ databaseId, tableId });\n\n  if (databaseId && tableId) {\n    if (segment) {\n      question = (question.query() as StructuredQuery)\n        .filter([\"segment\", parseInt(segment)])\n        .question();\n    }\n    if (metric) {\n      question = (question.query() as StructuredQuery)\n        .aggregate([\"metric\", parseInt(metric)])\n        .question();\n    }\n  }\n\n  return question.card();\n}\n\nfunction deserializeCard(serializedCard: string) {\n  const card = deserializeCardFromUrl(serializedCard);\n  if (card.dataset_query.database != null) {\n    // Ensure older MBQL is supported\n    card.dataset_query = normalize(card.dataset_query);\n  }\n  return card;\n}\n\nasync function fetchAndPrepareSavedQuestionCards(cardId: number) {\n  const card = await loadCard(cardId);\n  const originalCard = { ...card };\n\n  // for showing the \"started from\" lineage correctly when adding filters/breakouts and when going back and forth\n  // in browser history, the original_card_id has to be set for the current card (simply the id of card itself for now)\n  card.original_card_id = card.id;\n\n  return { card, originalCard };\n}\n\nasync function fetchAndPrepareAdHocQuestionCards(deserializedCard: Card) {\n  if (!deserializedCard.original_card_id) {\n    return {\n      card: deserializedCard,\n      originalCard: null,\n    };\n  }\n\n  const originalCard = await loadCard(deserializedCard.original_card_id);\n\n  if (cardIsEquivalent(deserializedCard, originalCard)) {\n    return {\n      card: { ...originalCard },\n      originalCard: originalCard,\n    };\n  }\n\n  return {\n    card: deserializedCard,\n    originalCard,\n  };\n}\n\ntype ResolveCardsResult = {\n  card: Card;\n  originalCard?: Card;\n};\n\nasync function resolveCards({\n  cardId,\n  deserializedCard,\n  options,\n}: {\n  cardId?: number;\n  deserializedCard?: Card;\n  options: BlankQueryOptions;\n}): Promise<ResolveCardsResult> {\n  if (!cardId && !deserializedCard) {\n    return {\n      card: getCardForBlankQuestion(options),\n    };\n  }\n  return cardId\n    ? fetchAndPrepareSavedQuestionCards(cardId)\n    : fetchAndPrepareAdHocQuestionCards(deserializedCard as Card);\n}\n\nfunction parseHash(hash?: string) {\n  let options: BlankQueryOptions = {};\n  let serializedCard;\n\n  // hash can contain either query params starting with ? or a base64 serialized card\n  if (hash) {\n    const cleanHash = hash.replace(/^#/, \"\");\n    if (cleanHash.charAt(0) === \"?\") {\n      options = querystring.parse(cleanHash.substring(1));\n    } else {\n      serializedCard = cleanHash;\n    }\n  }\n\n  return { options, serializedCard };\n}\n\nfunction isSavedCard(card: Card): card is SavedCard {\n  return !!(card as SavedCard).id;\n}\n\nexport const INITIALIZE_QB = \"metabase/qb/INITIALIZE_QB\";\n\nasync function handleQBInit(\n  dispatch: Dispatch,\n  getState: GetState,\n  {\n    location,\n    params,\n  }: { location: LocationDescriptorObject; params: QueryParams },\n) {\n  dispatch(resetQB());\n  dispatch(cancelQuery());\n\n  const queryParams = location.query;\n  const cardId = Urls.extractEntityId(params.slug);\n  const uiControls: UIControls = getQueryBuilderModeFromLocation(location);\n  const { options, serializedCard } = parseHash(location.hash);\n  const hasCard = cardId || serializedCard;\n\n  if (\n    !hasCard &&\n    !options.db &&\n    !options.table &&\n    !options.segment &&\n    !options.metric\n  ) {\n    dispatch(redirectToNewQuestionFlow());\n    return;\n  }\n\n  const deserializedCard = serializedCard\n    ? deserializeCard(serializedCard)\n    : null;\n\n  const { card, originalCard } = await resolveCards({\n    cardId,\n    deserializedCard,\n    options,\n  });\n\n  if (isSavedCard(card) && card.archived) {\n    dispatch(setErrorPage(ARCHIVED_ERROR));\n    return;\n  }\n\n  if (\n    isSavedCard(card) &&\n    !card?.dataset &&\n    location.pathname?.startsWith(\"/model\")\n  ) {\n    dispatch(setErrorPage(NOT_FOUND_ERROR));\n    return;\n  }\n\n  if (hasCard) {\n    await handleDashboardParameters(card, {\n      deserializedCard,\n      originalCard,\n      dispatch,\n      getState,\n    });\n  } else {\n    if (options.metric) {\n      uiControls.isShowingSummarySidebar = true;\n    }\n  }\n\n  MetabaseAnalytics.trackStructEvent(\n    \"QueryBuilder\",\n    hasCard ? \"Query Loaded\" : \"Query Started\",\n    card.dataset_query.type,\n  );\n\n  if (isSavedCard(card)) {\n    dispatch(fetchAlertsForQuestion(card.id));\n  }\n\n  await dispatch(loadMetadataForCard(card));\n  const metadata = getMetadata(getState());\n\n  let question = new Question(card, metadata);\n  if (question.isSaved()) {\n    // Don't set viz automatically for saved questions\n    question = question.lockDisplay();\n\n    const currentUser = getUser(getState());\n    if (currentUser.is_qbnewb) {\n      uiControls.isShowingNewbModal = true;\n      MetabaseAnalytics.trackStructEvent(\"QueryBuilder\", \"Show Newb Modal\");\n    }\n  }\n\n  if (question && question.isNative()) {\n    const query = question.query() as NativeQuery;\n    if (query.hasSnippets() && !query.readOnly()) {\n      await dispatch(Snippets.actions.fetchList());\n      const snippets = Snippets.selectors.getList(getState());\n      question = question.setQuery(\n        query.updateQueryTextWithNewSnippetNames(snippets),\n      );\n    }\n  }\n\n  const finalCard = question.card();\n\n  const parameterValues = getParameterValuesForQuestion({\n    card: finalCard,\n    queryParams,\n    metadata,\n  });\n\n  const objectId = params?.objectId || queryParams?.objectId;\n\n  dispatch({\n    type: INITIALIZE_QB,\n    payload: {\n      card: finalCard,\n      originalCard,\n      uiControls,\n      parameterValues,\n      objectId,\n    },\n  });\n\n  if (uiControls.queryBuilderMode !== \"notebook\") {\n    if (question.canRun() && (question.isSaved() || question.isStructured())) {\n      // Timeout to allow Parameters widget to set parameterValues\n      setTimeout(\n        () => dispatch(runQuestionQuery({ shouldUpdateUrl: false })),\n        0,\n      );\n    }\n    dispatch(\n      updateUrl(finalCard, {\n        replaceState: true,\n        preserveParameters: hasCard,\n        objectId,\n      }),\n    );\n  }\n}\n\nexport const initializeQB =\n  (location: LocationDescriptorObject, params: QueryParams) =>\n  async (dispatch: Dispatch, getState: GetState) => {\n    try {\n      await handleQBInit(dispatch, getState, { location, params });\n    } catch (error) {\n      console.warn(\"initializeQB failed because of an error:\", error);\n      dispatch(setErrorPage(error));\n    }\n  };\n", "import { LocationDescriptorObject } from \"history\";\nimport xhrMock from \"xhr-mock\";\n\nimport * as CardLib from \"metabase/lib/card\";\nimport * as Urls from \"metabase/lib/urls\";\n\nimport * as alert from \"metabase/alert/alert\";\nimport Databases from \"metabase/entities/databases\";\nimport Snippets from \"metabase/entities/snippets\";\nimport { setErrorPage } from \"metabase/redux/app\";\n\nimport Question from \"metabase-lib/lib/Question\";\nimport NativeQuery from \"metabase-lib/lib/queries/NativeQuery\";\nimport StructuredQuery from \"metabase-lib/lib/queries/StructuredQuery\";\nimport {\n  getAdHocQuestion,\n  getSavedStructuredQuestion,\n  getSavedNativeQuestion,\n  getUnsavedNativeQuestion,\n  getStructuredModel,\n  getNativeModel,\n} from \"metabase-lib/mocks\";\n\nimport { User } from \"metabase-types/api\";\nimport { createMockUser } from \"metabase-types/api/mocks\";\nimport { Card, NativeDatasetQuery } from \"metabase-types/types/Card\";\nimport { TemplateTag } from \"metabase-types/types/Query\";\nimport { createMockState } from \"metabase-types/store/mocks\";\n\nimport {\n  SAMPLE_DATABASE,\n  ORDERS,\n  state as entitiesState,\n  metadata,\n} from \"__support__/sample_database_fixture\";\n\nimport * as navigation from \"../navigation\";\nimport * as querying from \"../querying\";\n\nimport * as core from \"./core\";\nimport { initializeQB } from \"./initializeQB\";\n\ntype BaseSetupOpts = {\n  user?: User;\n  location: LocationDescriptorObject;\n  params: Record<string, unknown>;\n};\n\nasync function baseSetup({ user, location, params }: BaseSetupOpts) {\n  jest.useFakeTimers();\n\n  const dispatch = jest.fn().mockReturnValue({ mock: \"mock\" });\n\n  const state = {\n    ...createMockState(),\n    ...entitiesState,\n  };\n  if (user) {\n    state.currentUser = user;\n  }\n  const getState = () => state;\n\n  await initializeQB(location, params)(dispatch, getState);\n  jest.runAllTimers();\n\n  const actions = dispatch.mock.calls.find(\n    call => call[0]?.type === \"metabase/qb/INITIALIZE_QB\",\n  );\n  const hasDispatchedInitAction = Array.isArray(actions);\n  const result = hasDispatchedInitAction ? actions[0].payload : null;\n\n  return { dispatch, state, result };\n}\n\nfunction getLocationForQuestion(\n  question: Question,\n  extra: LocationDescriptorObject = {},\n): LocationDescriptorObject {\n  const card = question.card();\n  const isSaved = question.isSaved();\n  return {\n    pathname: isSaved ? Urls.question(card) : Urls.serializedQuestion(card),\n    hash: !isSaved ? CardLib.serializeCardForUrl(card) : \"\",\n    query: {},\n    ...extra,\n  };\n}\n\nfunction getQueryParamsForQuestion(\n  question: Question,\n  extra: Record<string, unknown> = {},\n): Record<string, unknown> {\n  if (!question.isSaved()) {\n    return extra;\n  }\n  const id = question.id();\n  const name = question.displayName();\n  return {\n    slug: `${id}-${name}`,\n    ...extra,\n  };\n}\n\ntype SetupOpts = Omit<BaseSetupOpts, \"location\" | \"params\"> & {\n  question: Question;\n  location?: LocationDescriptorObject;\n  params?: Record<string, unknown>;\n};\n\nasync function setup({\n  question,\n  location = getLocationForQuestion(question),\n  params = getQueryParamsForQuestion(question),\n  ...opts\n}: SetupOpts) {\n  const card = question.card();\n\n  if (\"id\" in card) {\n    xhrMock.get(`/api/card/${card.id}`, {\n      body: JSON.stringify(card),\n    });\n  }\n\n  return baseSetup({ location, params, ...opts });\n}\n\nconst SNIPPET: TemplateTag = {\n  id: \"id\",\n  \"snippet-id\": 1,\n  \"display-name\": \"foo\",\n  name: \"foo\",\n  \"snippet-name\": \"foo\",\n  type: \"snippet\",\n};\n\nconst NATIVE_QUESTION_WITH_SNIPPET: NativeDatasetQuery = {\n  type: \"native\",\n  database: 1,\n  native: {\n    query: \"select * from orders {{ foo }}\",\n    \"template-tags\": {\n      foo: SNIPPET,\n    },\n  },\n};\n\ndescribe(\"QB Actions > initializeQB\", () => {\n  beforeAll(() => {\n    console.warn = jest.fn();\n  });\n\n  beforeEach(() => {\n    xhrMock.setup();\n  });\n\n  afterEach(() => {\n    xhrMock.teardown();\n    jest.restoreAllMocks();\n  });\n\n  const TEST_CASE = {\n    SAVED_STRUCTURED_QUESTION: {\n      question: getSavedStructuredQuestion(),\n      questionType: \"saved structured question\",\n    },\n    UNSAVED_STRUCTURED_QUESTION: {\n      question: getAdHocQuestion(),\n      questionType: \"ad-hoc structured question\",\n    },\n\n    SAVED_NATIVE_QUESTION: {\n      question: getSavedNativeQuestion(),\n      questionType: \"saved native question\",\n    },\n    UNSAVED_NATIVE_QUESTION: {\n      question: getUnsavedNativeQuestion(),\n      questionType: \"unsaved native question\",\n    },\n\n    STRUCTURED_MODEL: {\n      question: getStructuredModel(),\n      questionType: \"structured model\",\n    },\n    NATIVE_MODEL: {\n      question: getNativeModel(),\n      questionType: \"native model\",\n    },\n  };\n\n  const ALL_TEST_CASES = Object.values(TEST_CASE);\n\n  const SAVED_QUESTION_TEST_CASES = [\n    TEST_CASE.SAVED_STRUCTURED_QUESTION,\n    TEST_CASE.SAVED_NATIVE_QUESTION,\n  ];\n\n  const UNSAVED_QUESTION_TEST_CASES = [\n    TEST_CASE.UNSAVED_STRUCTURED_QUESTION,\n    TEST_CASE.UNSAVED_NATIVE_QUESTION,\n  ];\n\n  const MODEL_TEST_CASES = [TEST_CASE.STRUCTURED_MODEL, TEST_CASE.NATIVE_MODEL];\n\n  const NATIVE_SNIPPETS_TEST_CASES = [\n    {\n      question: getSavedNativeQuestion({\n        dataset_query: NATIVE_QUESTION_WITH_SNIPPET,\n      }),\n      questionType: \"saved native question with snippets\",\n    },\n    {\n      question: getUnsavedNativeQuestion({\n        dataset_query: NATIVE_QUESTION_WITH_SNIPPET,\n      }),\n      questionType: \"unsaved native question with snippets\",\n    },\n  ];\n\n  describe(\"common\", () => {\n    ALL_TEST_CASES.forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      describe(questionType, () => {\n        it(\"resets QB state before doing anything\", async () => {\n          const resetQBSpy = jest.spyOn(core, \"resetQB\");\n          await setup({ question });\n          expect(resetQBSpy).toHaveBeenCalledTimes(1);\n        });\n\n        it(\"cancels running query before doing anything\", async () => {\n          const cancelQuerySpy = jest.spyOn(querying, \"cancelQuery\");\n          await setup({ question });\n          expect(cancelQuerySpy).toHaveBeenCalledTimes(1);\n        });\n\n        it(\"fetches question metadata\", async () => {\n          const loadMetadataForCardSpy = jest.spyOn(\n            core,\n            \"loadMetadataForCard\",\n          );\n\n          await setup({ question });\n\n          expect(loadMetadataForCardSpy).toHaveBeenCalledTimes(1);\n          expect(loadMetadataForCardSpy).toHaveBeenCalledWith(\n            expect.objectContaining(question.card()),\n          );\n        });\n\n        it(\"does not run non-runnable question queries\", async () => {\n          const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n          jest.spyOn(Question.prototype, \"canRun\").mockReturnValue(false);\n\n          await setup({ question });\n\n          expect(runQuestionQuerySpy).not.toHaveBeenCalled();\n        });\n\n        it(\"does not run question query in notebook mode\", async () => {\n          const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/notebook`,\n          });\n\n          await setup({ question, location });\n\n          expect(runQuestionQuerySpy).not.toHaveBeenCalled();\n        });\n\n        it(\"passes object ID from params correctly\", async () => {\n          const params = getQueryParamsForQuestion(question, { objectId: 123 });\n          const { result } = await setup({ question, params });\n          expect(result.objectId).toBe(123);\n        });\n\n        it(\"passes object ID from location query params correctly\", async () => {\n          const location = getLocationForQuestion(question, {\n            query: { objectId: 123 },\n          });\n          const { result } = await setup({ question, location });\n          expect(result.objectId).toBe(123);\n        });\n\n        it(\"sets original card id on the card\", async () => {\n          const { result } = await setup({ question });\n          expect(result.card.original_card_id).toBe(question.id());\n        });\n\n        it(\"sets QB mode correctly\", async () => {\n          const { result } = await setup({ question });\n          expect(result.uiControls.queryBuilderMode).toBe(\"view\");\n        });\n\n        it(\"sets QB mode to notebook if opening /notebook route\", async () => {\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/notebook`,\n          });\n\n          const { result } = await setup({ question, location });\n\n          expect(result.uiControls.queryBuilderMode).toBe(\"notebook\");\n        });\n      });\n    });\n  });\n\n  describe(\"saved questions and models\", () => {\n    [...SAVED_QUESTION_TEST_CASES, ...MODEL_TEST_CASES].forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      describe(questionType, () => {\n        it(\"locks question display\", async () => {\n          const { result } = await setup({\n            question: question.setDisplayIsLocked(false),\n          });\n          expect(result.card.displayIsLocked).toBe(true);\n        });\n\n        it(\"fetches alerts\", async () => {\n          const fetchAlertsForQuestionSpy = jest.spyOn(\n            alert,\n            \"fetchAlertsForQuestion\",\n          );\n\n          await setup({ question });\n\n          expect(fetchAlertsForQuestionSpy).toHaveBeenCalledWith(question.id());\n        });\n\n        it(\"passes object ID from params correctly\", async () => {\n          const params = getQueryParamsForQuestion(question, { objectId: 123 });\n          const { result } = await setup({ question, params });\n          expect(result.objectId).toBe(123);\n        });\n\n        it(\"passes object ID from location query params correctly\", async () => {\n          const location = getLocationForQuestion(question, {\n            query: { objectId: 123 },\n          });\n          const { result } = await setup({ question, location });\n          expect(result.objectId).toBe(123);\n        });\n\n        describe(\"newb modal\", () => {\n          it(\"shows modal if user has not yet seen it\", async () => {\n            const { result } = await setup({\n              question,\n              user: createMockUser({ is_qbnewb: true }),\n            });\n            expect(result.uiControls.isShowingNewbModal).toBe(true);\n          });\n\n          it(\"does not show modal if user has seen it\", async () => {\n            const { result } = await setup({\n              question,\n              user: createMockUser({ is_qbnewb: false }),\n            });\n            expect(result.uiControls.isShowingNewbModal).toBeFalsy();\n          });\n        });\n\n        it(\"throws error for archived card\", async () => {\n          const { dispatch } = await setup({\n            question: question.setCard({\n              ...question.card(),\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              archived: true,\n            }),\n          });\n\n          expect(dispatch).toHaveBeenCalledWith(\n            setErrorPage(\n              expect.objectContaining({ data: { error_code: \"archived\" } }),\n            ),\n          );\n        });\n      });\n    });\n  });\n\n  describe(\"saved questions\", () => {\n    SAVED_QUESTION_TEST_CASES.forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      describe(questionType, () => {\n        it(\"throws not found error when opening question with /model URL\", async () => {\n          const { dispatch } = await setup({\n            question,\n            location: { pathname: `/model/${question.id()}` },\n          });\n\n          expect(dispatch).toHaveBeenCalledWith(\n            setErrorPage(\n              expect.objectContaining({ data: { error_code: \"not-found\" } }),\n            ),\n          );\n        });\n\n        it(\"runs question query in view mode\", async () => {\n          const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n          await setup({ question });\n          expect(runQuestionQuerySpy).toHaveBeenCalledTimes(1);\n        });\n      });\n    });\n  });\n\n  describe(\"unsaved questions\", () => {\n    UNSAVED_QUESTION_TEST_CASES.forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      const ORIGINAL_CARD_ID = 321;\n\n      function getOriginalQuestion(card?: Partial<Card>) {\n        return question.setCard({\n          ...question.card(),\n          ...card,\n          id: ORIGINAL_CARD_ID,\n        });\n      }\n\n      function setupWithOriginalQuestion({\n        originalQuestion,\n        question,\n        ...opts\n      }: SetupOpts & { originalQuestion: Question }) {\n        const q = question.setCard({\n          ...question.card(),\n          original_card_id: ORIGINAL_CARD_ID,\n        });\n\n        xhrMock.get(`/api/card/${originalQuestion.id()}`, {\n          body: JSON.stringify(originalQuestion.card()),\n        });\n\n        return setup({ question: q, ...opts });\n      }\n\n      describe(questionType, () => {\n        it(\"loads original card\", async () => {\n          const originalQuestion = getOriginalQuestion({ display: \"line\" });\n\n          const { result } = await setupWithOriginalQuestion({\n            question,\n            originalQuestion,\n          });\n\n          expect(result.card.original_card_id).toBe(ORIGINAL_CARD_ID);\n          expect(result.originalCard).toEqual(originalQuestion.card());\n        });\n\n        it(\"replaces card with original card if they're equal\", async () => {\n          const originalQuestion = getOriginalQuestion();\n\n          const { result } = await setupWithOriginalQuestion({\n            question,\n            originalQuestion,\n          });\n\n          expect(result.card.original_card_id).toBeUndefined();\n          expect(result.originalCard).toEqual(originalQuestion.card());\n          expect(result.card).toEqual(originalQuestion.lockDisplay().card());\n        });\n\n        it(\"does not lock question display\", async () => {\n          const { result } = await setup({ question });\n          expect(result.card.displayIsLocked).toBeFalsy();\n        });\n\n        it(\"does not try to fetch alerts\", async () => {\n          const fetchAlertsForQuestionSpy = jest.spyOn(\n            alert,\n            \"fetchAlertsForQuestion\",\n          );\n\n          await setup({ question });\n\n          expect(fetchAlertsForQuestionSpy).not.toHaveBeenCalled();\n        });\n\n        it(\"does not show qbnewb modal\", async () => {\n          const { result } = await setup({\n            question,\n            user: createMockUser({ is_qbnewb: true }),\n          });\n          expect(result.uiControls.isShowingNewbModal).toBeFalsy();\n        });\n\n        it(\"handles error if couldn't deserialize card hash\", async () => {\n          const error = new Error(\"failed to deserialize card\");\n          jest\n            .spyOn(CardLib, \"deserializeCardFromUrl\")\n            .mockImplementation(() => {\n              throw error;\n            });\n\n          const { dispatch } = await setup({ question });\n\n          expect(dispatch).toHaveBeenCalledWith(setErrorPage(error));\n        });\n      });\n    });\n  });\n\n  describe(\"unsaved structured questions\", () => {\n    const { question } = TEST_CASE.SAVED_STRUCTURED_QUESTION;\n\n    it(\"runs question query in view mode\", async () => {\n      const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n      await setup({ question });\n      expect(runQuestionQuerySpy).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe(\"unsaved native questions\", () => {\n    const { question } = TEST_CASE.UNSAVED_NATIVE_QUESTION;\n\n    it(\"doesn't run an ad-hoc native question in view mode automatically\", async () => {\n      const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n      await setup({ question });\n      expect(runQuestionQuerySpy).not.toHaveBeenCalled();\n    });\n  });\n\n  describe(\"models\", () => {\n    MODEL_TEST_CASES.forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      describe(questionType, () => {\n        it(\"runs question query on /query route\", async () => {\n          const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/query`,\n          });\n\n          await setup({ question, location });\n\n          expect(runQuestionQuerySpy).toHaveBeenCalledTimes(1);\n        });\n        it(\"runs question query on /metadata route\", async () => {\n          const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/metadata`,\n          });\n\n          await setup({ question, location });\n\n          expect(runQuestionQuerySpy).toHaveBeenCalledTimes(1);\n        });\n\n        it(\"sets UI state correctly for /query route\", async () => {\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/query`,\n          });\n\n          const { result } = await setup({ question, location });\n\n          expect(result.uiControls.queryBuilderMode).toBe(\"dataset\");\n          expect(result.uiControls.datasetEditorTab).toBe(\"query\");\n        });\n\n        it(\"sets UI state correctly for /metadata route\", async () => {\n          const baseUrl = Urls.question(question.card());\n          const location = getLocationForQuestion(question, {\n            pathname: `${baseUrl}/metadata`,\n          });\n\n          const { result } = await setup({ question, location });\n\n          expect(result.uiControls.queryBuilderMode).toBe(\"dataset\");\n          expect(result.uiControls.datasetEditorTab).toBe(\"metadata\");\n        });\n      });\n    });\n  });\n\n  describe(\"native questions with snippets\", () => {\n    NATIVE_SNIPPETS_TEST_CASES.forEach(testCase => {\n      const { question, questionType } = testCase;\n\n      type SnippetsSetupOpts = Omit<SetupOpts, \"question\"> & {\n        hasLoadedDatabase?: boolean;\n        hasDatabaseWritePermission?: boolean;\n        snippet?: unknown;\n      };\n\n      function setupSnippets({\n        hasLoadedDatabase = true,\n        hasDatabaseWritePermission = true,\n        snippet,\n        ...opts\n      }: SnippetsSetupOpts) {\n        const clone = question.clone();\n\n        jest\n          .spyOn(NativeQuery.prototype, \"readOnly\")\n          .mockReturnValue(!hasDatabaseWritePermission);\n        jest\n          .spyOn(NativeQuery.prototype, \"isEditable\")\n          .mockReturnValue(hasDatabaseWritePermission);\n\n        Snippets.actions.fetchList = jest.fn();\n        Snippets.selectors.getList = jest\n          .fn()\n          .mockReturnValue(snippet ? [snippet] : []);\n\n        return setup({ question: clone, ...opts });\n      }\n\n      describe(questionType, () => {\n        it(\"loads snippets if have DB write permissions\", async () => {\n          await setupSnippets({ hasDatabaseWritePermission: true });\n          expect(Snippets.actions.fetchList).toHaveBeenCalledTimes(1);\n        });\n\n        it(\"does not load snippets if missing DB write permissions\", async () => {\n          Databases.selectors.getObject = jest.fn().mockReturnValue({\n            native_permissions: \"none\",\n          });\n          Snippets.actions.fetchList = jest.fn();\n          Snippets.selectors.getList = jest.fn().mockReturnValue([SNIPPET]);\n\n          await setupSnippets({ hasDatabaseWritePermission: false });\n\n          expect(Snippets.actions.fetchList).not.toHaveBeenCalled();\n        });\n\n        it(\"replaces snippet names with fresh ones from the backend\", async () => {\n          const { result } = await setupSnippets({\n            snippet: {\n              id: SNIPPET[\"snippet-id\"],\n              name: \"bar\",\n            },\n          });\n          const formattedQuestion = new Question(result.card, metadata);\n          const query = formattedQuestion.query() as NativeQuery;\n\n          expect(query.queryText().toLowerCase()).toBe(\n            \"select * from orders {{snippet: bar}}\",\n          );\n        });\n      });\n    });\n  });\n\n  describe(\"blank question\", () => {\n    type BlankSetupOpts = Omit<BaseSetupOpts, \"location\" | \"params\"> & {\n      db?: number;\n      table?: number;\n      segment?: number;\n      metric?: number;\n    };\n\n    function setupBlank({\n      db,\n      table,\n      segment,\n      metric,\n      ...opts\n    }: BlankSetupOpts = {}) {\n      const hashParams = [\n        db ? `db=${db}` : \"\",\n        table ? `table=${table}` : \"\",\n        segment ? `segment=${segment}` : \"\",\n        metric ? `metric=${metric}` : \"\",\n      ].filter(Boolean);\n\n      let hash = hashParams.join(\"&\");\n      if (hash) {\n        hash = \"#?\" + hash;\n      }\n\n      const location: LocationDescriptorObject = {\n        pathname: \"/question\",\n        hash,\n      };\n\n      const params = {\n        db: db ? String(db) : undefined,\n        table: table ? String(table) : undefined,\n        segment: segment ? String(segment) : undefined,\n        metric: metric ? String(metric) : undefined,\n      };\n\n      return baseSetup({ location, params, ...opts });\n    }\n\n    async function setupOrdersTable(\n      opts: Omit<BlankSetupOpts, \"db\" | \"table\"> = {},\n    ) {\n      const { result, ...rest } = await setupBlank({\n        db: SAMPLE_DATABASE?.id,\n        table: ORDERS.id,\n        ...opts,\n      });\n\n      const question = new Question(result.card, metadata);\n      const query = question.query() as StructuredQuery;\n\n      return {\n        question,\n        query,\n        result,\n        ...rest,\n      };\n    }\n\n    it(\"redirects to new question flow if missing any options\", async () => {\n      const redirectSpy = jest.spyOn(navigation, \"redirectToNewQuestionFlow\");\n      await setupBlank();\n      expect(redirectSpy).toHaveBeenCalledTimes(1);\n    });\n\n    it(\"constructs a card based on provided 'db' param\", async () => {\n      const expectedCard = Question.create({\n        databaseId: SAMPLE_DATABASE?.id,\n      }).card();\n\n      const { result } = await setupBlank({ db: SAMPLE_DATABASE?.id });\n      const question = new Question(result.card, metadata);\n      const query = question.query() as StructuredQuery;\n\n      expect(result.card).toEqual(expectedCard);\n      expect(query.sourceTableId()).toBe(null);\n      expect(result.originalCard).toBeUndefined();\n    });\n\n    it(\"constructs a card based on provided 'db' and 'table' params\", async () => {\n      const expectedCard = ORDERS.question().card();\n\n      const { result } = await setupOrdersTable();\n\n      expect(result.card).toEqual(expectedCard);\n      expect(result.originalCard).toBeUndefined();\n    });\n\n    it(\"applies 'segment' param correctly\", async () => {\n      const SEGMENT_ID = 777;\n\n      const { query } = await setupOrdersTable({ segment: SEGMENT_ID });\n      const [filter] = query.filters();\n\n      expect(filter.raw()).toEqual([\"segment\", SEGMENT_ID]);\n    });\n\n    it(\"opens summarization sidebar if metric is applied\", async () => {\n      const METRIC_ID = 777;\n      const { result } = await setupOrdersTable({ metric: METRIC_ID });\n      expect(result.uiControls.isShowingSummarySidebar).toBe(true);\n    });\n\n    it(\"applies 'metric' param correctly\", async () => {\n      const METRIC_ID = 777;\n\n      const { query } = await setupOrdersTable({ metric: METRIC_ID });\n      const [aggregation] = query.aggregations();\n\n      expect(aggregation.raw()).toEqual([\"metric\", METRIC_ID]);\n    });\n\n    it(\"opens summarization sidebar if metric is applied\", async () => {\n      const METRIC_ID = 777;\n      const { result } = await setupOrdersTable({ metric: METRIC_ID });\n      expect(result.uiControls.isShowingSummarySidebar).toBe(true);\n    });\n\n    it(\"applies both 'metric' and 'segment' params\", async () => {\n      const SEGMENT_ID = 111;\n      const METRIC_ID = 222;\n\n      const { query } = await setupOrdersTable({\n        segment: SEGMENT_ID,\n        metric: METRIC_ID,\n      });\n      const [filter] = query.filters();\n      const [aggregation] = query.aggregations();\n\n      expect(filter.raw()).toEqual([\"segment\", SEGMENT_ID]);\n      expect(aggregation.raw()).toEqual([\"metric\", METRIC_ID]);\n    });\n\n    it(\"fetches question metadata\", async () => {\n      const loadMetadataForCardSpy = jest.spyOn(core, \"loadMetadataForCard\");\n\n      const { question } = await setupOrdersTable();\n\n      expect(loadMetadataForCardSpy).toHaveBeenCalledTimes(1);\n      expect(loadMetadataForCardSpy).toHaveBeenCalledWith(\n        expect.objectContaining(question.card()),\n      );\n    });\n\n    it(\"runs question query\", async () => {\n      const runQuestionQuerySpy = jest.spyOn(querying, \"runQuestionQuery\");\n      await setupOrdersTable();\n      expect(runQuestionQuerySpy).toHaveBeenCalledTimes(1);\n    });\n\n    it(\"does not lock question display\", async () => {\n      const { result } = await setupOrdersTable();\n      expect(result.card.displayIsLocked).toBeFalsy();\n    });\n\n    it(\"does not try to fetch alerts\", async () => {\n      const fetchAlertsForQuestionSpy = jest.spyOn(\n        alert,\n        \"fetchAlertsForQuestion\",\n      );\n\n      await setupOrdersTable();\n\n      expect(fetchAlertsForQuestionSpy).not.toHaveBeenCalled();\n    });\n\n    it(\"does not show qbnewb modal\", async () => {\n      const { result } = await setupOrdersTable({\n        user: createMockUser({ is_qbnewb: true }),\n      });\n      expect(result.uiControls.isShowingNewbModal).toBeFalsy();\n    });\n  });\n});\n", "import { SAMPLE_DB_ID, SAMPLE_DB_TABLES } from \"__support__/e2e/cypress_data\";\nimport { runNativeQuery } from \"__support__/e2e/helpers/e2e-misc-helpers\";\n\nconst {\n  STATIC_ORDERS_ID,\n  STATIC_PRODUCTS_ID,\n  STATIC_PEOPLE_ID,\n  STATIC_REVIEWS_ID,\n} = SAMPLE_DB_TABLES;\n\nexport function adhocQuestionHash(question) {\n  if (question.display) {\n    // without \"locking\" the display, the QB will run its picking logic and override the setting\n    question = Object.assign({}, question, { displayIsLocked: true });\n  }\n  return btoa(unescape(encodeURIComponent(JSON.stringify(question))));\n}\n\n/**\n * This is the query generated by clicking \"New\" and then choosing the (gui) \"Question\".\n */\nexport function startNewQuestion() {\n  const newQuestionQuery = {\n    creationType: \"custom_question\",\n    dataset_query: {\n      database: null,\n      query: {\n        \"source-table\": null,\n      },\n      type: \"query\",\n    },\n    visualization_settings: {},\n  };\n\n  const hash = adhocQuestionHash(newQuestionQuery);\n\n  cy.visit(\"/question/notebook#\" + hash);\n}\n/**\n * Visit any valid query in an ad-hoc manner.\n *\n * @param {object} question\n * @param {{callback: function, mode: (undefined|\"notebook\")}} config\n */\nexport function visitQuestionAdhoc(\n  question,\n  { callback, mode, autorun = true } = {},\n) {\n  const questionMode = mode === \"notebook\" ? \"/notebook\" : \"\";\n\n  const [url, alias] = getInterceptDetails(question, mode, autorun);\n\n  cy.intercept(url).as(alias);\n\n  cy.visit(`/question${questionMode}#` + adhocQuestionHash(question));\n\n  runQueryIfNeeded(question, autorun);\n\n  cy.wait(\"@\" + alias).then(xhr => callback && callback(xhr));\n}\n\n/**\n * Open a table as an ad-hoc query in a simple or a notebook mode, and optionally limit the number of results.\n *\n * @param {{database:number, table: number, mode: (undefined|\"notebook\"), limit: number, callback: function}} config\n */\nexport function openTable({\n  database = SAMPLE_DB_ID,\n  table,\n  mode = null,\n  limit,\n  callback,\n} = {}) {\n  visitQuestionAdhoc(\n    {\n      dataset_query: {\n        database,\n        query: {\n          \"source-table\": table,\n          limit,\n        },\n        type: \"query\",\n      },\n    },\n    { mode, callback },\n  );\n}\n\nexport function openProductsTable({ mode, limit, callback } = {}) {\n  return openTable({ table: STATIC_PRODUCTS_ID, mode, limit, callback });\n}\n\nexport function openOrdersTable({ mode, limit, callback } = {}) {\n  return openTable({ table: STATIC_ORDERS_ID, mode, limit, callback });\n}\n\nexport function openPeopleTable({ mode, limit, callback } = {}) {\n  return openTable({ table: STATIC_PEOPLE_ID, mode, limit, callback });\n}\n\nexport function openReviewsTable({ mode, limit, callback } = {}) {\n  return openTable({ table: STATIC_REVIEWS_ID, mode, limit, callback });\n}\n\nfunction getInterceptDetails(question, mode, autorun) {\n  const {\n    display,\n    dataset_query: { type },\n  } = question;\n\n  // When visiting notebook mode directly, we don't render any results to the page.\n  // Therefore, there is no `dataset` to wait for.\n  // But we need to make sure the schema for our database is loaded before we can proceed.\n  if (mode === \"notebook\") {\n    return [`/api/database/${SAMPLE_DB_ID}/schema/PUBLIC`, \"publicSchema\"];\n  }\n\n  // Ad-hoc native queries are not autorun by default.\n  // Therefore, there is no `dataset` to wait for.\n  // We need to make sure data for the native query builder has loaded before we can proceed.\n  if (type === \"native\" && !autorun) {\n    return [\"/api/native-query-snippet\", \"snippets\"];\n  }\n\n  // native queries should use the normal dataset endpoint even when set to pivot\n  const isPivotEndpoint = display === \"pivot\" && type === \"query\";\n\n  const url = isPivotEndpoint ? \"/api/dataset/pivot\" : \"/api/dataset\";\n  const alias = isPivotEndpoint ? \"pivotDataset\" : \"dataset\";\n\n  return [url, alias];\n}\n\nfunction runQueryIfNeeded(question, autorun) {\n  const {\n    dataset_query: { type },\n  } = question;\n\n  if (type === \"native\" && autorun) {\n    runNativeQuery({ wait: false });\n  }\n}\n", "// Find a text field by label text, type it in, then blur the field.\n// Commonly used in our Admin section as we auto-save settings.\nexport function typeAndBlurUsingLabel(label, value) {\n  cy.findByLabelText(label).clear().type(value).blur();\n}\n\nexport function visitAlias(alias) {\n  cy.get(alias).then(url => {\n    cy.visit(url);\n  });\n}\n\n/**\n * Open native (SQL) editor and alias it.\n *\n * @param {object} options\n * @param {string} [options.databaseName] - If there is more than one database, select the desired one by its name.\n * @param {string} [options.alias=\"editor\"] - The alias that can be used later in the test as `cy.get(\"@\" + alias)`.\n * @example\n * openNativeEditor().type(\"SELECT 123\");\n * @example\n * openNativeEditor({ databaseName: \"QA Postgres12\" }).type(\"SELECT 123\");\n */\nexport function openNativeEditor({\n  databaseName,\n  alias = \"editor\",\n  fromCurrentPage,\n} = {}) {\n  if (!fromCurrentPage) {\n    cy.visit(\"/\");\n  }\n  cy.findByText(\"New\").click();\n  cy.findByText(\"SQL query\").click();\n\n  databaseName && cy.findByText(databaseName).click();\n\n  return cy.get(\".ace_content\").as(alias).should(\"be.visible\");\n}\n\n/**\n * Executes native query and waits for the results to load.\n * Makes sure that the question is not \"dirty\" after the query successfully ran.\n */\nexport function runNativeQuery({ wait = true } = {}) {\n  cy.intercept(\"POST\", \"api/dataset\").as(\"dataset\");\n  cy.get(\".NativeQueryEditor .Icon-play\").click();\n\n  if (wait) {\n    cy.wait(\"@dataset\");\n  }\n\n  cy.icon(\"play\").should(\"not.exist\");\n}\n\n/**\n * Intercepts a request and returns resolve function that allows\n * the request to continue\n *\n * @param {string} method - Request method (\"GET\", \"POST\", etc)\n * @param {string} path - Request URL to intercept\n * @example\n * const req = interceptPromise(\"GET\", \"/dashboard/1\");\n * // ... do something before request is allowed to go through ...\n * req.resolve();\n */\nexport function interceptPromise(method, path) {\n  const state = {};\n  const promise = new Promise(resolve => {\n    state.resolve = resolve;\n  });\n  cy.intercept(method, path, req => {\n    return promise.then(() => {\n      req.continue();\n    });\n  });\n  return state;\n}\n\n/**\n * Executes and waits for all Cypress commands sequentially.\n * Helps to avoid excessive nesting and verbosity\n *\n * @param {Array.<Cypress.Chainable<any>>} commands - Cypress commands\n * @example\n * cypressWaitAll([\n *   cy.createQuestionAndAddToDashboard(firstQuery, 1),\n *   cy.createQuestionAndAddToDashboard(secondQuery, 1),\n * ]).then(() => {\n *   cy.visit(`/dashboard/1`);\n * });\n */\nconst cypressWaitAllRecursive = (results, currentCommand, commands) => {\n  return currentCommand.then(result => {\n    results.push(result);\n\n    const [nextCommand, ...rest] = Array.from(commands);\n\n    if (nextCommand == null) {\n      return results;\n    }\n\n    return cypressWaitAllRecursive(results, nextCommand, rest);\n  });\n};\n\nexport const cypressWaitAll = function (commands) {\n  const results = [];\n\n  return cypressWaitAllRecursive(\n    results,\n    cy.wrap(null, { log: false }),\n    commands,\n  );\n};\n\n/**\n * Visit a question and wait for its query to load.\n *\n * @param {number} id\n */\nexport function visitQuestion(id) {\n  // In case we use this function multiple times in a test, make sure aliases are unique for each question\n  const alias = \"cardQuery\" + id;\n\n  // We need to use the wildcard becase endpoint for pivot tables has the following format: `/api/card/pivot/${id}/query`\n  cy.intercept(\"POST\", `/api/card/**/${id}/query`).as(alias);\n\n  cy.visit(`/question/${id}`);\n\n  cy.wait(\"@\" + alias);\n}\n\n/**\n * Visit a dashboard and wait for the related queries to load.\n *\n * @param {number} dashboard_id\n */\nexport function visitDashboard(dashboard_id) {\n  // Some users will not have permissions for this request\n  cy.request({\n    method: \"GET\",\n    url: `/api/dashboard/${dashboard_id}`,\n    // That's why we have to ignore failures\n    failOnStatusCode: false,\n  }).then(({ status, body: { ordered_cards } }) => {\n    const dashboardAlias = \"getDashboard\" + dashboard_id;\n\n    cy.intercept(\"GET\", `/api/dashboard/${dashboard_id}`).as(dashboardAlias);\n\n    const canViewDashboard = hasAccess(status);\n    const validQuestions = dashboardHasQuestions(ordered_cards);\n\n    if (canViewDashboard && validQuestions) {\n      // If dashboard has valid questions (GUI or native),\n      // we need to alias each request and wait for their reponses\n      const aliases = validQuestions.map(\n        ({ id, card_id, card: { display } }) => {\n          const baseUrl =\n            display === \"pivot\"\n              ? `/api/dashboard/pivot/${dashboard_id}`\n              : `/api/dashboard/${dashboard_id}`;\n\n          const interceptUrl = `${baseUrl}/dashcard/${id}/card/${card_id}/query`;\n\n          const alias = \"dashcardQuery\" + id;\n\n          cy.intercept(\"POST\", interceptUrl).as(alias);\n\n          return `@${alias}`;\n        },\n      );\n\n      cy.visit(`/dashboard/${dashboard_id}`);\n\n      cy.wait(aliases);\n    } else {\n      // For a dashboard:\n      //  - without questions (can be empty or markdown only) or\n      //  - the one which user doesn't have access to\n      // the last request will always be `GET /api/dashboard/:dashboard_id`\n      cy.visit(`/dashboard/${dashboard_id}`);\n\n      cy.wait(`@${dashboardAlias}`);\n    }\n  });\n}\n\nfunction hasAccess(statusCode) {\n  return statusCode !== 403;\n}\n\nfunction dashboardHasQuestions(cards) {\n  if (Array.isArray(cards) && cards.length > 0) {\n    const questions = cards\n      // Filter out markdown cards\n      .filter(({ card_id }) => {\n        return card_id !== null;\n      })\n      // Filter out cards which the current user is not allowed to see\n      .filter(({ card }) => {\n        return card.dataset_query !== undefined;\n      });\n\n    const isPopulated = questions.length > 0;\n\n    return isPopulated && questions;\n  } else {\n    return false;\n  }\n}\n\nexport function interceptIfNotPreviouslyDefined({ method, url, alias } = {}) {\n  const aliases = Object.keys(cy.state(\"aliases\"));\n\n  const isAlreadyDefined = aliases.find(a => a === alias);\n\n  if (!isAlreadyDefined) {\n    cy.intercept(method, url).as(alias);\n  }\n}\n", "import {\n  restore,\n  popover,\n  modal,\n  openNativeEditor,\n  visitQuestionAdhoc,\n  summarize,\n  sidebar,\n  filter,\n  filterField,\n} from \"__support__/e2e/helpers\";\n\nimport { SAMPLE_DB_ID } from \"__support__/e2e/cypress_data\";\n\ndescribe(\"scenarios > question > native\", () => {\n  beforeEach(() => {\n    cy.intercept(\"POST\", \"api/dataset\").as(\"dataset\");\n    cy.intercept(\"POST\", \"api/card\").as(\"card\");\n    restore();\n    cy.signInAsNormalUser();\n  });\n\n  it(\"lets you create and run a SQL question\", () => {\n    openNativeEditor().type(\"select count(*) from orders\");\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains(\"18,760\");\n  });\n\n  it(\"displays an error\", () => {\n    openNativeEditor().type(\"select * from not_a_table\");\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains('Table \"NOT_A_TABLE\" not found');\n  });\n\n  it(\"displays an error when running selected text\", () => {\n    openNativeEditor().type(\n      \"select * from orders\" +\n        \"{leftarrow}\".repeat(3) + // move left three\n        \"{shift}{leftarrow}\".repeat(19), // highlight back to the front\n    );\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains('Table \"ORD\" not found');\n  });\n\n  it(\"should show referenced cards in the template tag sidebar\", () => {\n    openNativeEditor()\n      // start typing a question referenced\n      .type(\"select * from {{#}}\", {\n        parseSpecialCharSequences: false,\n      });\n\n    cy.contains(\"Question #\u2026\")\n      .parent()\n      .parent()\n      .contains(\"Pick a question or a model\")\n      .click({ force: true });\n\n    // selecting a question should update the query\n    popover().contains(\"Orders\").click();\n\n    cy.contains(\"select * from {{#1}}\");\n\n    // run query and see that a value from the results appears\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains(\"37.65\");\n\n    // update the text of the query to reference question 2\n    // :visible is needed because there is an unused .ace_content present in the DOM\n    cy.get(\".ace_content:visible\").type(\"{leftarrow}{leftarrow}{backspace}2\");\n\n    // sidebar should show updated question title and name\n    cy.contains(\"Question #2\").parent().parent().contains(\"Orders, Count\");\n\n    // run query again and see new result\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains(\"18,760\");\n  });\n\n  it(\"should handle template tags\", () => {\n    openNativeEditor().type(\"select * from PRODUCTS where RATING > {{Stars}}\", {\n      parseSpecialCharSequences: false,\n    });\n    cy.get(\"input[placeholder*='Stars']\").type(\"3\");\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.wait(\"@dataset\");\n    cy.contains(\"Showing 168 rows\");\n  });\n\n  it(\"should modify parameters accordingly when tags are modified\", () => {\n    openNativeEditor().type(\"select * from PRODUCTS where CATEGORY = {{cat}}\", {\n      parseSpecialCharSequences: false,\n    });\n    cy.findByTestId(\"sidebar-right\")\n      .findByText(\"Required?\")\n      .parent()\n      .find(\"input\")\n      .click();\n    cy.get(\"input[placeholder*='Enter a default value']\").type(\"Gizmo\");\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.wait(\"@dataset\");\n\n    cy.contains(\"Save\").click();\n\n    modal().within(() => {\n      cy.findByLabelText(\"Name\").type(\"Products on Category\");\n      cy.findByText(\"Save\").click();\n\n      cy.wait(\"@card\").should(xhr => {\n        const requestBody = xhr.request?.body;\n        expect(requestBody?.parameters?.length).to.equal(1);\n        const parameter = requestBody.parameters[0];\n        expect(parameter.default).to.equal(\"Gizmo\");\n      });\n    });\n\n    cy.findByText(\"Not now\").click();\n  });\n\n  it(\"can save a question with no rows\", () => {\n    openNativeEditor().type(\"select * from people where false\");\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.contains(\"No results!\");\n    cy.icon(\"contract\").click();\n    cy.contains(\"Save\").click();\n\n    modal().within(() => {\n      cy.findByLabelText(\"Name\").type(\"empty question\");\n      cy.findByText(\"Save\").click();\n    });\n\n    // confirm that the question saved and url updated\n    cy.location(\"pathname\").should(\"match\", /\\/question\\/\\d+/);\n  });\n\n  it(`shouldn't remove rows containing NULL when using \"Is not\" or \"Does not contain\" filter (metabase#13332)`, () => {\n    const FILTERS = [\"Is not\", \"Does not contain\"];\n\n    const questionDetails = {\n      name: \"13332\",\n      native: {\n        query: `SELECT null AS \"V\", 1 as \"N\" UNION ALL SELECT 'This has a value' AS \"V\", 2 as \"N\"`,\n        \"template-tags\": {},\n      },\n    };\n\n    cy.createNativeQuestion(questionDetails).then(({ body: { id } }) => {\n      visitQuestionAdhoc({\n        dataset_query: {\n          database: SAMPLE_DB_ID,\n          query: {\n            \"source-table\": `card__${id}`,\n          },\n          type: \"query\",\n        },\n      });\n    });\n\n    cy.findByText(\"This has a value\");\n\n    FILTERS.forEach(operator => {\n      cy.log(\"Apply a filter\");\n      filter();\n      filterField(\"V\", {\n        operator,\n        value: \"This has a value\",\n      });\n\n      cy.findByTestId(\"apply-filters\").click();\n\n      cy.log(\n        `**Mid-point assertion for \"${operator}\" filter| FAILING in v0.36.6**`,\n      );\n      cy.findByText(`V ${operator.toLowerCase()} This has a value`);\n      cy.findByText(\"No results!\").should(\"not.exist\");\n\n      cy.log(\n        \"**Final assertion: Count of rows with 'null' value should be 1**\",\n      );\n      // \"Count\" is pre-selected option for \"Summarize\"\n      summarize();\n      cy.findByText(\"Done\").click();\n      cy.get(\".ScalarValue\").contains(\"1\");\n\n      cy.findByTestId(\"qb-filters-panel\").within(() => {\n        cy.icon(\"close\").click();\n      });\n      summarize();\n      sidebar().within(() => {\n        cy.icon(\"close\").click();\n      });\n      cy.findByText(\"Done\").click();\n    });\n  });\n\n  it(\"should be able to add new columns after hiding some (metabase#15393)\", () => {\n    openNativeEditor().type(\"select 1 as visible, 2 as hidden\");\n    cy.get(\".NativeQueryEditor .Icon-play\").as(\"runQuery\").click();\n    cy.findByText(\"Settings\").click();\n    cy.findByTestId(\"sidebar-left\")\n      .as(\"sidebar\")\n      .contains(/hidden/i)\n      .siblings(\".Icon-close\")\n      .click();\n    cy.get(\"@editor\").type(\"{movetoend}, 3 as added\");\n    cy.get(\"@runQuery\").click();\n    cy.get(\"@sidebar\").contains(/added/i);\n  });\n\n  it(\"should recognize template tags and save them as parameters\", () => {\n    openNativeEditor().type(\n      \"select * from PRODUCTS where CATEGORY={{cat}} and RATING >= {{stars}}\",\n      {\n        parseSpecialCharSequences: false,\n      },\n    );\n    cy.get(\"input[placeholder*='Cat']\").type(\"Gizmo\");\n    cy.get(\"input[placeholder*='Stars']\").type(\"3\");\n\n    cy.get(\".NativeQueryEditor .Icon-play\").click();\n    cy.wait(\"@dataset\");\n\n    cy.contains(\"Save\").click();\n\n    modal().within(() => {\n      cy.findByLabelText(\"Name\").type(\"SQL Products\");\n      cy.findByText(\"Save\").click();\n\n      // parameters[] should reflect the template tags\n      cy.wait(\"@card\").should(xhr => {\n        const requestBody = xhr.request?.body;\n        expect(requestBody?.parameters?.length).to.equal(2);\n      });\n    });\n    cy.findByText(\"Not now\").click();\n\n    // Now load the question again and parameters[] should still be there\n    cy.intercept(\"GET\", \"/api/card/4\").as(\"cardQuestion\");\n    cy.visit(\"/question/4?cat=Gizmo&stars=3\");\n    cy.wait(\"@cardQuestion\").should(xhr => {\n      const responseBody = xhr.response?.body;\n      expect(responseBody?.parameters?.length).to.equal(2);\n    });\n  });\n\n  it(\"should link correctly from the variables sidebar (metabase#16212)\", () => {\n    cy.createNativeQuestion({\n      name: \"test-question\",\n      native: { query: 'select 1 as \"a\", 2 as \"b\"' },\n    }).then(({ body: { id: questionId } }) => {\n      openNativeEditor().type(`{{#${questionId}}}`, {\n        parseSpecialCharSequences: false,\n      });\n      cy.get(\".NativeQueryEditor .Icon-play\").click();\n      cy.get(\".Visualization\").within(() => {\n        cy.findByText(\"a\");\n        cy.findByText(\"b\");\n        cy.findByText(\"1\");\n        cy.findByText(\"2\");\n      });\n      cy.findByRole(\"link\", { name: `Question #${questionId}` })\n        .should(\"have.attr\", \"href\")\n        .and(\"eq\", `/question/${questionId}-test-question`);\n    });\n  });\n\n  it(\"should not autorun ad-hoc native queries by default\", () => {\n    visitQuestionAdhoc(\n      {\n        display: \"scalar\",\n        dataset_query: {\n          type: \"native\",\n          native: {\n            query: \"SELECT 1\",\n          },\n          database: SAMPLE_DB_ID,\n        },\n      },\n      { autorun: false },\n    );\n\n    cy.findByText(\"Here's where your results will appear\").should(\"be.visible\");\n  });\n});\n", "import {\n  restore,\n  visitQuestion,\n  visitQuestionAdhoc,\n} from \"__support__/e2e/helpers\";\nimport { SAMPLE_DB_ID } from \"__support__/e2e/cypress_data\";\n\ndescribe(\"scenarios > permissions\", () => {\n  beforeEach(restore);\n\n  const PATHS = [\"/dashboard/1\", \"/question/1\", \"/collection/1\", \"/admin\"];\n\n  for (const path of PATHS) {\n    it(`should display the permissions screen on ${path}`, () => {\n      cy.signIn(\"none\");\n      cy.visit(path);\n      checkUnauthorized();\n    });\n  }\n\n  it(\"should not allow to run adhoc native questions without permissions\", () => {\n    cy.signIn(\"none\");\n\n    visitQuestionAdhoc(\n      {\n        display: \"scalar\",\n        dataset_query: {\n          type: \"native\",\n          native: {\n            query: \"SELECT 1\",\n          },\n          database: SAMPLE_DB_ID,\n        },\n      },\n      { autorun: false },\n    );\n\n    cy.findAllByRole(\"button\", { name: \"refresh icon\" }).should(\"be.disabled\");\n  });\n\n  // There's no pulse in the fixture data, so we stub out the api call to\n  // replace the 404 with a 403.\n  it(\"should display the permissions screen for pulses\", () => {\n    cy.signIn(\"none\");\n    cy.server();\n    cy.route({ url: /\\/api\\/pulse\\/1/, status: 403, response: {} });\n    cy.visit(\"/pulse/1\");\n    checkUnauthorized();\n  });\n\n  it(\"should let a user with no data permissions view questions\", () => {\n    cy.signIn(\"nodata\");\n    visitQuestion(1);\n    cy.contains(\"February 11, 2019, 9:40 PM\"); // check that the data loads\n  });\n});\n\nconst checkUnauthorized = () => {\n  cy.icon(\"key\").should(\"be.visible\");\n  cy.findByText(\"Sorry, you don\u2019t have permission to see that.\").should(\n    \"be.visible\",\n  );\n};\n", "import {\n  restore,\n  withDatabase,\n  adhocQuestionHash,\n  runNativeQuery,\n} from \"__support__/e2e/helpers\";\n\nconst PG_DB_ID = 2;\n\nconst questionDetails = {\n  dataset_query: {\n    type: \"native\",\n    database: PG_DB_ID,\n    native: {\n      query: \"SELECT pg_sleep(10)\",\n    },\n  },\n};\n\ndescribe(\"issue 11727\", () => {\n  beforeEach(() => {\n    restore(\"postgres-12\");\n    cy.signInAsAdmin();\n    cy.intercept(\"GET\", \"/api/database\").as(\"getDatabases\");\n  });\n\n  it(\"should cancel the native query via the keyboard shortcut (metabase#11727)\", () => {\n    withDatabase(PG_DB_ID, () => {\n      cy.visit(`/question#` + adhocQuestionHash(questionDetails));\n      cy.wait(\"@getDatabases\");\n\n      runNativeQuery({ wait: false });\n      cy.findByText(\"Doing science...\").should(\"be.visible\");\n      cy.get(\"body\").type(\"{cmd}{enter}\");\n      cy.findByText(\"Here's where your results will appear\").should(\n        \"be.visible\",\n      );\n    });\n  });\n});\n"], "filenames": ["frontend/src/metabase/query_builder/actions/core/initializeQB.ts", "frontend/src/metabase/query_builder/actions/core/initializeQB.unit.spec.ts", "frontend/test/__support__/e2e/helpers/e2e-ad-hoc-question-helpers.js", "frontend/test/__support__/e2e/helpers/e2e-misc-helpers.js", "frontend/test/metabase/scenarios/native/native.cy.spec.js", "frontend/test/metabase/scenarios/permissions/permissions-baseline.cy.spec.js", "frontend/test/metabase/scenarios/visualizations/reproductions/11727-cancel-native-query-shortcut.cy.spec.js"], "buggy_code_start_loc": [309, 2, 1, 43, 264, 1, 4], "buggy_code_end_loc": [310, 505, 121, 48, 264, 40, 30], "fixing_code_start_loc": [309, 1, 2, 43, 265, 1, 5], "fixing_code_end_loc": [310, 525, 143, 52, 283, 64, 33], "type": "NVD-CWE-Other", "message": "Metabase is data visualization software. Prior to versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9, unsaved SQL queries are auto-executed, which could pose a possible attack vector. This issue is patched in versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9. Metabase no longer automatically executes ad-hoc native queries. Now the native editor shows the query and gives the user the option to manually run the query if they want.", "other": {"cve": {"id": "CVE-2022-39362", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-26T19:15:15.800", "lastModified": "2022-10-28T16:45:35.620", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Metabase is data visualization software. Prior to versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9, unsaved SQL queries are auto-executed, which could pose a possible attack vector. This issue is patched in versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9. Metabase no longer automatically executes ad-hoc native queries. Now the native editor shows the query and gives the user the option to manually run the query if they want."}, {"lang": "es", "value": "Metabase es un software de visualizaci\u00f3n de datos. En versiones anteriores a 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9 y 1.41.9, eran auto ejecutadas las consultas SQL no guardadas, lo que pod\u00eda suponer un posible vector de ataque. Este problema ha sido corregido en versiones 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9 y 1.41.9. Metabase ya no ejecuta autom\u00e1ticamente las consultas nativas ad hoc. Ahora el editor nativo muestra la consulta y da al usuario la opci\u00f3n de ejecutarla manualmente si lo desea"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-356"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.41.0", "versionEndExcluding": "0.41.9", "matchCriteriaId": "BCD50540-E323-41CE-9D9C-EDA8CB718E42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.42.0", "versionEndExcluding": "0.42.6", "matchCriteriaId": "EF01C7BF-CB4C-4990-9082-587CFD555225"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.43.0", "versionEndExcluding": "0.43.7", "matchCriteriaId": "8858058E-C597-4752-8625-9B279DC65A48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.44.0", "versionEndExcluding": "0.44.5", "matchCriteriaId": "6A94F7EA-BC18-4013-9A93-7962226FDD98"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.41.0", "versionEndExcluding": "1.41.9", "matchCriteriaId": "804B84E1-5D1A-4251-9829-65F5FD927D99"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.42.0", "versionEndExcluding": "1.42.6", "matchCriteriaId": "73310924-8CD4-4696-89B9-EED3390375A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.43.0", "versionEndExcluding": "1.43.7", "matchCriteriaId": "A86AA0C8-2C4F-4DDD-8371-6B43611E2479"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.44.0", "versionEndExcluding": "1.44.5", "matchCriteriaId": "EF7A60F6-5062-4094-91A5-71445F9B7BC1"}]}]}], "references": [{"url": "https://github.com/metabase/metabase/commit/b7c6bb905a9187347cfc9035443b514713027a5c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/metabase/metabase/security/advisories/GHSA-93wj-fgjg-r238", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/metabase/metabase/commit/b7c6bb905a9187347cfc9035443b514713027a5c"}}