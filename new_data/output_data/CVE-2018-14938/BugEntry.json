{"buggy_code": ["/**********************************************************************\n * Log:\n * 2006-03-12: Parts originally authored by Doug Madory as wifi_parser.c\n * 2013-03-15: Substantially modified by Simson Garfinkel for inclusion into tcpflow\n * 2013-11-18: reworked static calls to be entirely calls to a class. Changed TimeVal pointer to an instance variable that includes the full packet header.\n **********************************************************************/\n\n//*do 11-18\n\n#include \"config.h\"\t\t// pull in HAVE_ defines\n\n#define __STDC_FORMAT_MACROS \n\n#include <stdint.h>\n#include <inttypes.h>\n\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <stdarg.h>\n#include <errno.h>\n\n#ifdef HAVE_NET_ETHERNET_H\n#include <net/ethernet.h>\n#endif\n\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#pragma GCC diagnostic ignored \"-Wcast-align\"\n\n#include \"wifipcap.h\"\n\n#include \"cpack.h\"\n#include \"extract.h\"\n#include \"oui.h\"\n#include \"ethertype.h\"\n#include \"icmp.h\"\n#include \"ipproto.h\"\n\n/* wifipcap uses a MAC class which is somewhat lame, but works */\n\nMAC MAC::broadcast(0xffffffffffffULL);\nMAC MAC::null((uint64_t)0);\nint WifiPacket::debug=0;\nint MAC::print_fmt(MAC::PRINT_FMT_COLON);\n\nstd::ostream& operator<<(std::ostream& out, const MAC& mac) {\n    const char *fmt = MAC::print_fmt == MAC::PRINT_FMT_COLON ? \n\t\"%02x:%02x:%02x:%02x:%02x:%02x\" :\n\t\"%02x%02x%02x%02x%02x%02x\";\n    char buf[24];\n    sprintf(buf, fmt, \n\t    (int)((mac.val>>40)&0xff),\n\t    (int)((mac.val>>32)&0xff),\n\t    (int)((mac.val>>24)&0xff),\n\t    (int)((mac.val>>16)&0xff),\n\t    (int)((mac.val>>8)&0xff),\n\t    (int)((mac.val)&0xff)\n        );\n    out << buf;\n    return out;\n}\n\nstd::ostream& operator<<(std::ostream& out, const struct in_addr& ip) {\n    out << inet_ntoa(ip);\n    return out;\n}\n\nstruct tok {\n    int v;\t\t\t/* value */\n    const char *s;\t\t/* string */\n};\n\n#if 0\nstatic const struct tok ethertype_values[] = { \n    { ETHERTYPE_IP,\t\t\"IPv4\" },\n    { ETHERTYPE_MPLS,\t\t\"MPLS unicast\" },\n    { ETHERTYPE_MPLS_MULTI,\t\"MPLS multicast\" },\n    { ETHERTYPE_IPV6,\t\t\"IPv6\" },\n    { ETHERTYPE_8021Q,\t\t\"802.1Q\" },\n    { ETHERTYPE_VMAN,\t\t\"VMAN\" },\n    { ETHERTYPE_PUP,            \"PUP\" },\n    { ETHERTYPE_ARP,            \"ARP\"},\n    { ETHERTYPE_REVARP,         \"Reverse ARP\"},\n    { ETHERTYPE_NS,             \"NS\" },\n    { ETHERTYPE_SPRITE,         \"Sprite\" },\n    { ETHERTYPE_TRAIL,          \"Trail\" },\n    { ETHERTYPE_MOPDL,          \"MOP DL\" },\n    { ETHERTYPE_MOPRC,          \"MOP RC\" },\n    { ETHERTYPE_DN,             \"DN\" },\n    { ETHERTYPE_LAT,            \"LAT\" },\n    { ETHERTYPE_SCA,            \"SCA\" },\n    { ETHERTYPE_LANBRIDGE,      \"Lanbridge\" },\n    { ETHERTYPE_DECDNS,         \"DEC DNS\" },\n    { ETHERTYPE_DECDTS,         \"DEC DTS\" },\n    { ETHERTYPE_VEXP,           \"VEXP\" },\n    { ETHERTYPE_VPROD,          \"VPROD\" },\n    { ETHERTYPE_ATALK,          \"Appletalk\" },\n    { ETHERTYPE_AARP,           \"Appletalk ARP\" },\n    { ETHERTYPE_IPX,            \"IPX\" },\n    { ETHERTYPE_PPP,            \"PPP\" },\n    { ETHERTYPE_SLOW,           \"Slow Protocols\" },\n    { ETHERTYPE_PPPOED,         \"PPPoE D\" },\n    { ETHERTYPE_PPPOES,         \"PPPoE S\" },\n    { ETHERTYPE_EAPOL,          \"EAPOL\" },\n    { ETHERTYPE_JUMBO,          \"Jumbo\" },\n    { ETHERTYPE_LOOPBACK,       \"Loopback\" },\n    { ETHERTYPE_ISO,            \"OSI\" },\n    { ETHERTYPE_GRE_ISO,        \"GRE-OSI\" },\n    { 0, NULL}\n};\n#endif\n\n/*max length of an IEEE 802.11 packet*/\n#ifndef MAX_LEN_80211\n#define MAX_LEN_80211 3000\n#endif\n\n/* from ethereal packet-prism.c */\n#define pletohs(p)  ((u_int16_t)\t\t\t\t\t\\\n\t\t     ((u_int16_t)*((const u_int8_t *)(p)+1)<<8|\t\t\\\n\t\t      (u_int16_t)*((const u_int8_t *)(p)+0)<<0))\n#define pntohl(p)   ((u_int32_t)*((const u_int8_t *)(p)+0)<<24|\t\\\n\t\t     (u_int32_t)*((const u_int8_t *)(p)+1)<<16|\t\\\n\t\t     (u_int32_t)*((const u_int8_t *)(p)+2)<<8|\t\\\n\t\t     (u_int32_t)*((const u_int8_t *)(p)+3)<<0)\n#define COOK_FRAGMENT_NUMBER(x) ((x) & 0x000F)\n#define COOK_SEQUENCE_NUMBER(x) (((x) & 0xFFF0) >> 4)\n/* end ethereal code */\n\n/* Sequence number gap */\n#define SEQ_GAP(current, last)(0xfff & (current - last))\n\n/* In the following three arrays, even though the QoS subtypes are listed, in the rest of the program\n * the QoS subtypes are treated as \"OTHER_TYPES\". The file \"ieee802_11.h\" currently doesn't account for\n * the existence of QoS subtypes. The QoS subtypes might need to be accomodated there in the future.\n */\n#if 0\nstatic const char * mgmt_subtype_text[] = {\n    \"AssocReq\",\n    \"AssocResp\",\n    \"ReAssocReq\",\n    \"ReAssocResp\",\n    \"ProbeReq\",\n    \"ProbeResp\",\n    \"\",\n    \"\",\n    \"Beacon\",\n    \"ATIM\",\n    \"Disassoc\",\n    \"Auth\",\n    \"DeAuth\",\n    \"Action\", /*QoS mgmt_subtype*/\n    \"\",\n    \"\"\n};\n\nstatic const char * ctrl_subtype_text[] = {\n    \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n    \"BlockAckReq\", /*QoS ctrl_subtype*/\n    \"BlockAck\",    /*QoS ctrl_subtype*/\n    \"PS-Poll\",\n    \"RTS\",\n    \"CTS\",\n    \"ACK\",\n    \"CF-End\",\n    \"CF-End+CF-Ack\"\n};\n\nstatic const char * data_subtype_text[] = {\n    \"Data\",\n    \"Data+CF-Ack\",\n    \"Data+CF-Poll\",\n    \"Data+CF-Ack+CF-Poll\",\n    \"Null(no_data)\",\n    \"CF-Ack(no_data)\",\n    \"CF-Poll(no_data)\",\n    \"CF-Ack+CF-Poll(no_data)\",\n    \"QoS_Data\", /*QoS data_subtypes from here on*/\n    \"QoS_Data+CF-Ack\",\n    \"QoS_Data+CF-Poll\",\n    \"QoS_Data+CF-Ack+CF-Poll\",\n    \"QoS_Null(no_data)\",\n    \"\",\n    \"QoS_CF-Poll(no_data)\",\n    \"QoS_CF-Ack+CF-Poll(no_data)\"\n};\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n// crc32 implementation needed for wifi checksum\n\n/* crc32.c\n * CRC-32 routine\n *\n * $Id: crc32.cpp,v 1.1 2007/02/14 00:05:50 jpang Exp $\n *\n * Ethereal - Network traffic analyzer\n * By Gerald Combs <gerald@ethereal.com>\n * Copyright 1998 Gerald Combs\n *\n * Copied from README.developer\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n * Credits:\n *\n * Table from Solomon Peachy\n * Routine from Chris Waters\n */\n\n/*\n * Table for the AUTODIN/HDLC/802.x CRC.\n *\n * Polynomial is\n *\n *  x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^8 + x^7 +\n *      x^5 + x^4 + x^2 + x + 1\n */\nstatic const uint32_t crc32_ccitt_table[256] = {\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n    0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n    0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n    0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n    0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n    0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n    0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n    0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n    0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n    0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n    0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n    0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n    0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n    0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n    0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n    0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n    0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n    0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n    0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n    0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n    0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n    0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n    0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n    0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n    0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n    0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n    0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n    0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n    0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n    0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n    0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n    0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n    0x2d02ef8d\n};\n\n#define CRC32_CCITT_SEED    0xFFFFFFFF\n\nstatic uint32_t crc32_ccitt_seed(const uint8_t *buf, size_t len, uint32_t seed);\n\nstatic uint32_t crc32_ccitt(const uint8_t *buf, size_t len)\n{\n    return ( crc32_ccitt_seed(buf, len, CRC32_CCITT_SEED) );\n}\n\nstatic uint32_t crc32_ccitt_seed(const uint8_t *buf, size_t len, uint32_t seed)\n{\n    uint32_t crc32 = seed;\n\n    for (unsigned int i = 0; i < len; i++){\n        crc32 = crc32_ccitt_table[(crc32 ^ buf[i]) & 0xff] ^ (crc32 >> 8);\n    }\n\n    return ( ~crc32 );\n}\n\n/*\n * IEEE 802.x version (Ethernet and 802.11, at least) - byte-swap\n * the result of \"crc32()\".\n *\n * XXX - does this mean we should fetch the Ethernet and 802.11\n * Frame Checksum (FCS) with \"tvb_get_letohl()\" rather than \"tvb_get_ntohl()\",\n * or is fetching it big-endian and byte-swapping the CRC done\n * to cope with 802.x sending stuff out in reverse bit order?\n */\nstatic uint32_t crc32_802(const unsigned char *buf, size_t len)\n{\n    uint32_t c_crc;\n\n    c_crc = crc32_ccitt(buf, len);\n\n    /* Byte reverse. */\n    c_crc = ((unsigned char)(c_crc>>0)<<24) |\n        ((unsigned char)(c_crc>>8)<<16) |\n        ((unsigned char)(c_crc>>16)<<8) |\n        ((unsigned char)(c_crc>>24)<<0);\n\n    return ( c_crc );\n}\n///////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////\n\n/* Translate Ethernet address, as seen in struct ether_header, to type MAC. */\n/* Extract header length. */\nstatic size_t extract_header_length(u_int16_t fc)\n{\n    switch (FC_TYPE(fc)) {\n    case T_MGMT:\n\treturn MGMT_HDRLEN;\n    case T_CTRL:\n\tswitch (FC_SUBTYPE(fc)) {\n\tcase CTRL_PS_POLL:\n\t    return CTRL_PS_POLL_HDRLEN;\n\tcase CTRL_RTS:\n\t    return CTRL_RTS_HDRLEN;\n\tcase CTRL_CTS:\n\t    return CTRL_CTS_HDRLEN;\n\tcase CTRL_ACK:\n\t    return CTRL_ACK_HDRLEN;\n\tcase CTRL_CF_END:\n\t    return CTRL_END_HDRLEN;\n\tcase CTRL_END_ACK:\n\t    return CTRL_END_ACK_HDRLEN;\n\tdefault:\n\t    return 0;\n\t}\n    case T_DATA:\n\treturn (FC_TO_DS(fc) && FC_FROM_DS(fc)) ? 30 : 24;\n    default:\n\treturn 0;\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////\n\n#pragma GCC diagnostic ignored \"-Wcast-align\"\nvoid WifiPacket::handle_llc(const mac_hdr_t &mac,const u_char *ptr, size_t len,u_int16_t fc)\n{\n    if (len < 7) {\n\t// truncated header!\n\tcbs->HandleLLC(*this,NULL, ptr, len);\n\treturn;\n    }\n\n    // http://www.wildpackets.com/resources/compendium/wireless_lan/wlan_packets\n\n    llc_hdr_t hdr;\n    hdr.dsap   = EXTRACT_LE_8BITS(ptr); // Destination Service Access point\n    hdr.ssap   = EXTRACT_LE_8BITS(ptr + 1); // Source Service Access Point\n    hdr.control= EXTRACT_LE_8BITS(ptr + 2); // ignored by most protocols\n    hdr.oui    = EXTRACT_24BITS(ptr + 3);\n    hdr.type   = EXTRACT_16BITS(ptr + 6);\n\n\n    /* \"When both the DSAP and SSAP are set to 0xAA, the type is\n     * interpreted as a protocol not defined by IEEE and the LSAP is\n     * referred to as SubNetwork Access Protocol (SNAP).  In SNAP, the\n     * 5 bytes that follow the DSAP, SSAP, and control byte are called\n     * the Protocol Discriminator.\"\n     */\n\n    if(hdr.dsap==0xAA && hdr.ssap==0xAA){\n        cbs->HandleLLC(*this,&hdr,ptr+8,len-8);\n        return;\n    }\n\n    if (hdr.oui == OUI_ENCAP_ETHER || hdr.oui == OUI_CISCO_90) {\n        cbs->HandleLLC(*this,&hdr, ptr+8, len-8);\n        return;\n    }\n        \n    cbs->HandleLLCUnknown(*this,ptr, len);\n}\n\nvoid WifiPacket::handle_wep(const u_char *ptr, size_t len)\n{\n    // Jeff: XXX handle TKIP/CCMP ? how can we demultiplex different\n    // protection protocols?\n\n    struct wep_hdr_t hdr;\n    u_int32_t iv;\n\n    if (len < IEEE802_11_IV_LEN + IEEE802_11_KID_LEN) {\n\t// truncated!\n\tcbs->HandleWEP(*this,NULL, ptr, len);\n\treturn;\n    }\n    iv = EXTRACT_LE_32BITS(ptr);\n    hdr.iv = IV_IV(iv);\n    hdr.pad = IV_PAD(iv);\n    hdr.keyid = IV_KEYID(iv);\n    cbs->HandleWEP(*this,&hdr, ptr, len);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstatic const char *auth_alg_text[]={\"Open System\",\"Shared Key\",\"EAP\"};\n#define NUM_AUTH_ALGS\t(sizeof auth_alg_text / sizeof auth_alg_text[0])\n\nstatic const char *status_text[] = {\n    \"Succesful\",  /*  0  */\n    \"Unspecified failure\",  /*  1  */\n    \"Reserved\",\t  /*  2  */\n    \"Reserved\",\t  /*  3  */\n    \"Reserved\",\t  /*  4  */\n    \"Reserved\",\t  /*  5  */\n    \"Reserved\",\t  /*  6  */\n    \"Reserved\",\t  /*  7  */\n    \"Reserved\",\t  /*  8  */\n    \"Reserved\",\t  /*  9  */\n    \"Cannot Support all requested capabilities in the Capability Information field\",\t  /*  10  */\n    \"Reassociation denied due to inability to confirm that association exists\",\t  /*  11  */\n    \"Association denied due to reason outside the scope of the standard\",\t  /*  12  */\n    \"Responding station does not support the specified authentication algorithm \",\t  /*  13  */\n    \"Received an Authentication frame with authentication transaction \" \\\n    \"sequence number out of expected sequence\",\t  /*  14  */\n    \"Authentication rejected because of challenge failure\",\t  /*  15 */\n    \"Authentication rejected due to timeout waiting for next frame in sequence\",\t  /*  16 */\n    \"Association denied because AP is unable to handle additional associated stations\",\t  /*  17 */\n    \"Association denied due to requesting station not supporting all of the \" \\\n    \"data rates in BSSBasicRateSet parameter\",\t  /*  18 */\n};\n#define NUM_STATUSES\t(sizeof status_text / sizeof status_text[0])\n\nstatic const char *reason_text[] = {\n    \"Reserved\", /* 0 */\n    \"Unspecified reason\", /* 1 */\n    \"Previous authentication no longer valid\",  /* 2 */\n    \"Deauthenticated because sending station is leaving (or has left) IBSS or ESS\", /* 3 */\n    \"Disassociated due to inactivity\", /* 4 */\n    \"Disassociated because AP is unable to handle all currently associated stations\", /* 5 */\n    \"Class 2 frame received from nonauthenticated station\", /* 6 */\n    \"Class 3 frame received from nonassociated station\", /* 7 */\n    \"Disassociated because sending station is leaving (or has left) BSS\", /* 8 */\n    \"Station requesting (re)association is not authenticated with responding station\", /* 9 */\n};\n#define NUM_REASONS\t(sizeof reason_text / sizeof reason_text[0])\n\nconst char *Wifipcap::WifiUtil::MgmtAuthAlg2Txt(uint v) {\n    return v < NUM_AUTH_ALGS ? auth_alg_text[v] : \"Unknown\";\n}\nconst char *Wifipcap::WifiUtil::MgmtStatusCode2Txt(uint v) {\n    return v < NUM_STATUSES ? status_text[v] : \"Reserved\";\n}\nconst char *Wifipcap::WifiUtil::MgmtReasonCode2Txt(uint v) {\n    return v < NUM_REASONS ? reason_text[v] : \"Reserved\";\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n// Jeff: HACK -- tcpdump uses a global variable to check truncation\n#define TTEST2(_p, _l) ((const u_char *)&(_p) - p + (_l) <= (ssize_t)len) \n\nvoid WifiPacket::parse_elements(struct mgmt_body_t *pbody, const u_char *p, int offset, size_t len)\n{\n    /*\n     * We haven't seen any elements yet.\n     */\n    pbody->challenge_status = NOT_PRESENT;\n    pbody->ssid_status = NOT_PRESENT;\n    pbody->rates_status = NOT_PRESENT;\n    pbody->ds_status = NOT_PRESENT;\n    pbody->cf_status = NOT_PRESENT;\n    pbody->tim_status = NOT_PRESENT;\n\n    for (;;) {\n        if (!TTEST2(*(p + offset), 1))\n            return;\n        switch (*(p + offset)) {\n        case E_SSID:\n            /* Present, possibly truncated */\n            pbody->ssid_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 2))\n                return;\n            memcpy(&pbody->ssid, p + offset, 2);\n            offset += 2;\n            if (pbody->ssid.length != 0) {\n                if (pbody->ssid.length >\n                    sizeof(pbody->ssid.ssid) - 1)\n                    return;\n                if (!TTEST2(*(p + offset), pbody->ssid.length))\n                    return;\n                memcpy(&pbody->ssid.ssid, p + offset,\n                       pbody->ssid.length);\n                offset += pbody->ssid.length;\n            }\n            pbody->ssid.ssid[pbody->ssid.length] = '\\0';\n            /* Present and not truncated */\n            pbody->ssid_status = PRESENT;\n            break;\n        case E_CHALLENGE:\n            /* Present, possibly truncated */\n            pbody->challenge_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 2))\n                return;\n            memcpy(&pbody->challenge, p + offset, 2);\n            offset += 2;\n            if (pbody->challenge.length != 0) {\n                if (pbody->challenge.length >\n                    sizeof(pbody->challenge.text) - 1)\n                    return;\n                if (!TTEST2(*(p + offset), pbody->challenge.length))\n                    return;\n                memcpy(&pbody->challenge.text, p + offset,\n                       pbody->challenge.length);\n                offset += pbody->challenge.length;\n            }\n            pbody->challenge.text[pbody->challenge.length] = '\\0';\n            /* Present and not truncated */\n            pbody->challenge_status = PRESENT;\n            break;\n        case E_RATES:\n            /* Present, possibly truncated */\n            pbody->rates_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 2))\n                return;\n            memcpy(&(pbody->rates), p + offset, 2);\n            offset += 2;\n            if (pbody->rates.length != 0) {\n                if (pbody->rates.length > sizeof pbody->rates.rate)\n                    return;\n                if (!TTEST2(*(p + offset), pbody->rates.length))\n                    return;\n                memcpy(&pbody->rates.rate, p + offset,\n                       pbody->rates.length);\n                offset += pbody->rates.length;\n            }\n            /* Present and not truncated */\n            pbody->rates_status = PRESENT;\n            break;\n        case E_DS:\n            /* Present, possibly truncated */\n            pbody->ds_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 3))\n                return;\n            memcpy(&pbody->ds, p + offset, 3);\n            offset += 3;\n            /* Present and not truncated */\n            pbody->ds_status = PRESENT;\n            break;\n        case E_CF:\n            /* Present, possibly truncated */\n            pbody->cf_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 8))\n                return;\n            memcpy(&pbody->cf, p + offset, 8);\n            offset += 8;\n            /* Present and not truncated */\n            pbody->cf_status = PRESENT;\n            break;\n        case E_TIM:\n            /* Present, possibly truncated */\n            pbody->tim_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 2))\n                return;\n            memcpy(&pbody->tim, p + offset, 2);\n            offset += 2;\n            if (!TTEST2(*(p + offset), 3))\n                return;\n            memcpy(&pbody->tim.count, p + offset, 3);\n            offset += 3;\n\n            if (pbody->tim.length <= 3)\n                break;\n            if (pbody->rates.length > sizeof pbody->tim.bitmap)\n                return;\n            if (!TTEST2(*(p + offset), pbody->tim.length - 3))\n                return;\n            memcpy(pbody->tim.bitmap, p + (pbody->tim.length - 3),\n                   (pbody->tim.length - 3));\n            offset += pbody->tim.length - 3;\n            /* Present and not truncated */\n            pbody->tim_status = PRESENT;\n            break;\n        default:\n#ifdef DEBUG_WIFI\n            printf(\"(1) unhandled element_id (%d)  \", *(p + offset) );\n#endif\n            if (!TTEST2(*(p + offset), 2))\n                return;\n            if (!TTEST2(*(p + offset + 2), *(p + offset + 1)))\n                return;\n            offset += *(p + offset + 1) + 2;\n            break;\n        }\n    }\n}\n\n/*********************************************************************************\n * Print Handle functions for the management frame types\n *********************************************************************************/\n\nint\nWifiPacket::handle_beacon( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_TSTAMP_LEN + IEEE802_11_BCNINT_LEN +\n                IEEE802_11_CAPINFO_LEN))\n        return 0;\n    memcpy(&pbody.timestamp, p, IEEE802_11_TSTAMP_LEN);\n    offset += IEEE802_11_TSTAMP_LEN;\n    pbody.beacon_interval = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_BCNINT_LEN;\n    pbody.capability_info = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_CAPINFO_LEN;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      PRINT_SSID(pbody);\n      PRINT_RATES(pbody);\n      printf(\" %s\",\n      CAPABILITY_ESS(pbody.capability_info) ? \"ESS\" : \"IBSS\");\n      PRINT_DS_CHANNEL(pbody);\n    */\n    cbs->Handle80211MgmtBeacon(*this, pmh, &pbody);\n    return 1;\n}\n\nint WifiPacket::handle_assoc_request( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_CAPINFO_LEN + IEEE802_11_LISTENINT_LEN))\n        return 0;\n    pbody.capability_info = EXTRACT_LE_16BITS(p);\n    offset += IEEE802_11_CAPINFO_LEN;\n    pbody.listen_interval = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_LISTENINT_LEN;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      PRINT_SSID(pbody);\n      PRINT_RATES(pbody);\n    */\n    cbs->Handle80211MgmtAssocRequest(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint WifiPacket::handle_assoc_response( const struct mgmt_header_t *pmh, const u_char *p, size_t len, bool reassoc)\n{\n    struct mgmt_body_t pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_CAPINFO_LEN + IEEE802_11_STATUS_LEN +\n                IEEE802_11_AID_LEN))\n        return 0;\n    pbody.capability_info = EXTRACT_LE_16BITS(p);\n    offset += IEEE802_11_CAPINFO_LEN;\n    pbody.status_code = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_STATUS_LEN;\n    pbody.aid = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_AID_LEN;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      printf(\" AID(%x) :%s: %s\", ((u_int16_t)(pbody.aid << 2 )) >> 2 ,\n      CAPABILITY_PRIVACY(pbody.capability_info) ? \" PRIVACY \" : \"\",\n      (pbody.status_code < NUM_STATUSES\n      ? status_text[pbody.status_code]\n      : \"n/a\"));\n    */\n    if (!reassoc)\n        cbs->Handle80211MgmtAssocResponse(*this, pmh, &pbody);\n    else\n        cbs->Handle80211MgmtReassocResponse(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_reassoc_request( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_CAPINFO_LEN + IEEE802_11_LISTENINT_LEN +\n                IEEE802_11_AP_LEN))\n        return 0;\n    pbody.capability_info = EXTRACT_LE_16BITS(p);\n    offset += IEEE802_11_CAPINFO_LEN;\n    pbody.listen_interval = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_LISTENINT_LEN;\n    memcpy(&pbody.ap, p+offset, IEEE802_11_AP_LEN);\n    offset += IEEE802_11_AP_LEN;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      PRINT_SSID(pbody);\n      printf(\" AP : %s\", etheraddr_string( pbody.ap ));\n    */\n    cbs->Handle80211MgmtReassocRequest(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_reassoc_response( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    /* Same as a Association Reponse */\n    return handle_assoc_response(pmh, p, len, true);\n}\n\nint\nWifiPacket::handle_probe_request( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t  pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      PRINT_SSID(pbody);\n      PRINT_RATES(pbody);\n    */\n    cbs->Handle80211MgmtProbeRequest(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_probe_response( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t  pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_TSTAMP_LEN + IEEE802_11_BCNINT_LEN +\n                IEEE802_11_CAPINFO_LEN))\n        return 0;\n\n    memcpy(&pbody.timestamp, p, IEEE802_11_TSTAMP_LEN);\n    offset += IEEE802_11_TSTAMP_LEN;\n    pbody.beacon_interval = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_BCNINT_LEN;\n    pbody.capability_info = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_CAPINFO_LEN;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      PRINT_SSID(pbody);\n      PRINT_RATES(pbody);\n      PRINT_DS_CHANNEL(pbody);\n    */\n    cbs->Handle80211MgmtProbeResponse(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_atim( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    /* the frame body for ATIM is null. */\n\n    cbs->Handle80211MgmtATIM(*this, pmh);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_disassoc( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t  pbody;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_REASON_LEN))\n        return 0;\n    pbody.reason_code = EXTRACT_LE_16BITS(p);\n\n    /*\n      printf(\": %s\",\n      (pbody.reason_code < NUM_REASONS)\n      ? reason_text[pbody.reason_code]\n      : \"Reserved\" );\n    */\n    cbs->Handle80211MgmtDisassoc(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_auth( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t  pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, 6))\n        return 0;\n    pbody.auth_alg = EXTRACT_LE_16BITS(p);\n    offset += 2;\n    pbody.auth_trans_seq_num = EXTRACT_LE_16BITS(p + offset);\n    offset += 2;\n    pbody.status_code = EXTRACT_LE_16BITS(p + offset);\n    offset += 2;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      if ((pbody.auth_alg == 1) &&\n      ((pbody.auth_trans_seq_num == 2) ||\n      (pbody.auth_trans_seq_num == 3))) {\n      printf(\" (%s)-%x [Challenge Text] %s\",\n      (pbody.auth_alg < NUM_AUTH_ALGS)\n      ? auth_alg_text[pbody.auth_alg]\n      : \"Reserved\",\n      pbody.auth_trans_seq_num,\n      ((pbody.auth_trans_seq_num % 2)\n      ? ((pbody.status_code < NUM_STATUSES)\n      ? status_text[pbody.status_code]\n      : \"n/a\") : \"\"));\n      return 1;\n      }\n      printf(\" (%s)-%x: %s\",\n      (pbody.auth_alg < NUM_AUTH_ALGS)\n      ? auth_alg_text[pbody.auth_alg]\n      : \"Reserved\",\n      pbody.auth_trans_seq_num,\n      (pbody.auth_trans_seq_num % 2)\n      ? ((pbody.status_code < NUM_STATUSES)\n      ? status_text[pbody.status_code]\n      : \"n/a\")\n      : \"\");\n    */\n    cbs->Handle80211MgmtAuth(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_deauth( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t  pbody;\n    int offset = 0;\n    //const char *reason = NULL;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_REASON_LEN))\n        return 0;\n    pbody.reason_code = EXTRACT_LE_16BITS(p);\n    offset += IEEE802_11_REASON_LEN;\n\n    /*\n      reason = (pbody.reason_code < NUM_REASONS)\n      ? reason_text[pbody.reason_code]\n      : \"Reserved\";\n\n      if (eflag) {\n      printf(\": %s\", reason);\n      } else {\n      printf(\" (%s): %s\", etheraddr_string(pmh->sa), reason);\n      }\n    */\n    cbs->Handle80211MgmtDeauth(*this, pmh, &pbody);\n\n    return 1;\n}\n\n\n/*********************************************************************************\n * Print Body funcs\n *********************************************************************************/\n\n\n/** Decode a management request.\n * @return 0 - failure, non-zero success\n *\n * NOTE \u2014 this function and all that it calls should be handled as methods in WifipcapCallbacks\n */\n \nint\nWifiPacket::decode_mgmt_body(u_int16_t fc, struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    if(debug) std::cerr << \"decode_mgmt_body FC_SUBTYPE(fc)=\"<<(int)FC_SUBTYPE(fc)<<\" \";\n    switch (FC_SUBTYPE(fc)) {\n    case ST_ASSOC_REQUEST:\n        return handle_assoc_request(pmh, p, len);\n    case ST_ASSOC_RESPONSE:\n        return handle_assoc_response(pmh, p, len);\n    case ST_REASSOC_REQUEST:\n        return handle_reassoc_request(pmh, p, len);\n    case ST_REASSOC_RESPONSE:\n        return handle_reassoc_response(pmh, p, len);\n    case ST_PROBE_REQUEST:\n        return handle_probe_request(pmh, p, len);\n    case ST_PROBE_RESPONSE:\n        return handle_probe_response(pmh, p, len);\n    case ST_BEACON:\n        return handle_beacon(pmh, p, len);\n    case ST_ATIM:\n        return handle_atim(pmh, p, len);\n    case ST_DISASSOC:\n        return handle_disassoc(pmh, p, len);\n    case ST_AUTH:\n        if (len < 3) {\n            return 0;\n        }\n        if ((p[0] == 0 ) && (p[1] == 0) && (p[2] == 0)) {\n            //printf(\"Authentication (Shared-Key)-3 \");\n            cbs->Handle80211MgmtAuthSharedKey(*this, pmh, p, len);\n            return 0;\n        }\n        return handle_auth(pmh, p, len);\n    case ST_DEAUTH:\n        return handle_deauth(pmh, p, len);\n        break;\n    default:\n        return 0;\n    }\n}\n\nint WifiPacket::decode_mgmt_frame(const u_char * ptr, size_t len, u_int16_t fc, u_int8_t hdrlen)\n{\n    mgmt_header_t hdr;\n    u_int16_t seq_ctl;\n\n    hdr.da    = MAC::ether2MAC(ptr + 4);\n    hdr.sa    = MAC::ether2MAC(ptr + 10);\n    hdr.bssid = MAC::ether2MAC(ptr + 16);\n\n    hdr.duration = EXTRACT_LE_16BITS(ptr+2);\n\n    seq_ctl   = pletohs(ptr + 22);\n\n    hdr.seq   = COOK_SEQUENCE_NUMBER(seq_ctl);\n    hdr.frag  = COOK_FRAGMENT_NUMBER(seq_ctl);\n\n    cbs->Handle80211(*this, fc, hdr.sa, hdr.da, MAC::null, MAC::null, ptr, len);\n\n    int ret = decode_mgmt_body(fc, &hdr, ptr+MGMT_HDRLEN, len-MGMT_HDRLEN);\n\n    if (ret==0) {\n\tcbs->Handle80211Unknown(*this, fc, ptr, len);\n\treturn 0;\n    }\n\n    return 0;\n}\n\nint WifiPacket::decode_data_frame(const u_char * ptr, size_t len, u_int16_t fc)\n{\n    mac_hdr_t hdr;\n    hdr.fc       = fc;\n    hdr.duration = EXTRACT_LE_16BITS(ptr+2);\n    hdr.seq_ctl  = pletohs(ptr + 22);\n    hdr.seq      = COOK_SEQUENCE_NUMBER(hdr.seq_ctl);\n    hdr.frag     = COOK_FRAGMENT_NUMBER(hdr.seq_ctl);\n\n    if(FC_TYPE(fc)==2 && FC_SUBTYPE(fc)==8){ // quality of service?\n        hdr.qos = 1;\n    }\n        \n    size_t hdrlen=0;\n\n    const MAC address1 = MAC::ether2MAC(ptr+4);\n    const MAC address2 = MAC::ether2MAC(ptr+10);\n    const MAC address3 = MAC::ether2MAC(ptr+16);\n    \n    /* call the 80211 callback data callback */\n\n    if (FC_TO_DS(fc)==0 && FC_FROM_DS(fc)==0) {\t/* ad hoc IBSS */\n\thdr.da = address1;\n\thdr.sa = address2;\n\thdr.bssid = address3;\n\thdrlen = DATA_HDRLEN;\n        if(hdr.qos) hdrlen+=2;\n        cbs->Handle80211( *this, fc, hdr.sa, hdr.da, hdr.ra, hdr.ta, ptr, len);\n\tcbs->Handle80211DataIBSS( *this, hdr, ptr+hdrlen, len-hdrlen);\n    } else if (FC_TO_DS(fc)==0 && FC_FROM_DS(fc)) { /* from AP to STA */\n        hdr.da = address1;\n        hdr.bssid = address2;\n        hdr.sa = address3;\n\thdrlen = DATA_HDRLEN;\n        if(hdr.qos) hdrlen+=2;\n        cbs->Handle80211( *this, fc, hdr.sa, hdr.da, hdr.ra, hdr.ta, ptr, len);\n\tcbs->Handle80211DataFromAP( *this, hdr, ptr+hdrlen, len-hdrlen);\n    } else if (FC_TO_DS(fc) && FC_FROM_DS(fc)==0) {\t/* frame from STA to AP */\n        hdr.bssid = address1;\n        hdr.sa = address2;\n        hdr.da = address3;\n\thdrlen = DATA_HDRLEN;\n        if(hdr.qos) hdrlen+=2;\n        cbs->Handle80211( *this, fc, hdr.sa, hdr.da, hdr.ra, hdr.ta, ptr, len);\n\tcbs->Handle80211DataToAP( *this, hdr, ptr+hdrlen, len-hdrlen);\n    } else if (FC_TO_DS(fc) && FC_FROM_DS(fc)) {\t/* WDS */\n        const MAC address4 = MAC::ether2MAC(ptr+18);\n        hdr.ra = address1;\n        hdr.ta = address2;\n        hdr.da = address3;\n        hdr.sa = address4;\n        hdrlen = DATA_WDS_HDRLEN;\n        if(hdr.qos) hdrlen+=2;\n        cbs->Handle80211( *this, fc, hdr.sa, hdr.da, hdr.ra, hdr.ta, ptr, len);\n\tcbs->Handle80211DataWDS( *this, hdr, ptr+hdrlen, len-hdrlen);\n    }\n\n    /* Handle either the WEP or the link layer. This handles the data itself */\n    if (FC_WEP(fc)) {\n        handle_wep(ptr+hdrlen, len-hdrlen-4 ); \n    } else {\n        handle_llc(hdr, ptr+hdrlen, len-hdrlen-4, fc); \n    }\n    return 0;\n}\n\nint WifiPacket::decode_ctrl_frame(const u_char * ptr, size_t len, u_int16_t fc)\n{\n    u_int16_t du = EXTRACT_LE_16BITS(ptr+2);        //duration\n\n    switch (FC_SUBTYPE(fc)) {\n    case CTRL_PS_POLL: {\n\tctrl_ps_poll_t hdr;\n\thdr.fc = fc;\n\thdr.aid = du;\n\thdr.bssid =  MAC::ether2MAC(ptr+4);\n\thdr.ta =  MAC::ether2MAC(ptr+10);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, MAC::null, hdr.ta, ptr, len);\n\tcbs->Handle80211CtrlPSPoll( *this, &hdr);\n\tbreak;\n    }\n    case CTRL_RTS: {\n\tctrl_rts_t hdr;\n\thdr.fc = fc;\n\thdr.duration = du;\n\thdr.ra =  MAC::ether2MAC(ptr+4);\n\thdr.ta =  MAC::ether2MAC(ptr+10);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, hdr.ra, hdr.ta, ptr, len);\n\tcbs->Handle80211CtrlRTS( *this, &hdr);\n\tbreak;\n    }\n    case CTRL_CTS: {\n\tctrl_cts_t hdr;\n\thdr.fc = fc;\n\thdr.duration = du;\n\thdr.ra =  MAC::ether2MAC(ptr+4);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, hdr.ra, MAC::null, ptr, len);\n\tcbs->Handle80211CtrlCTS( *this, &hdr);\n\tbreak;\n    }\n    case CTRL_ACK: {\n\tctrl_ack_t hdr;\n\thdr.fc = fc;\n\thdr.duration = du;\n\thdr.ra =  MAC::ether2MAC(ptr+4);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, hdr.ra, MAC::null, ptr, len);\n\tcbs->Handle80211CtrlAck( *this, &hdr);\n\tbreak;\n    }\n    case CTRL_CF_END: {\n\tctrl_end_t hdr;\n\thdr.fc = fc;\n\thdr.duration = du;\n\thdr.ra =  MAC::ether2MAC(ptr+4);\n\thdr.bssid =  MAC::ether2MAC(ptr+10);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, hdr.ra, MAC::null, ptr, len);\n\tcbs->Handle80211CtrlCFEnd( *this, &hdr);\n\tbreak;\n    }\n    case CTRL_END_ACK: {\t\n\tctrl_end_ack_t hdr;\n\thdr.fc = fc;\n\thdr.duration = du;\n\thdr.ra =  MAC::ether2MAC(ptr+4);\n\thdr.bssid =  MAC::ether2MAC(ptr+10);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, hdr.ra, MAC::null, ptr, len);\n\tcbs->Handle80211CtrlEndAck( *this, &hdr);\n\tbreak;\n    }\n    default: {\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, MAC::null, MAC::null, ptr, len);\n\tcbs->Handle80211Unknown( *this, fc, ptr, len);\n\treturn -1;\n\t//add the case statements for QoS control frames once ieee802_11.h is updated\n    }\n    }\n    return 0;\n}\n\n#ifndef roundup2\n#define\troundup2(x, y)\t(((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */\n#endif\n\nvoid WifiPacket::handle_80211(const u_char * pkt, size_t len /* , int pad */)  \n{\n    if (debug) std::cerr << \"handle_80211(len= \" << len << \" \";\n    if (len < 2) {\n\tcbs->Handle80211( *this, 0, MAC::null, MAC::null, MAC::null, MAC::null, pkt, len);\n\tcbs->Handle80211Unknown( *this, -1, pkt, len);\n\treturn;\n    }\n\n    u_int16_t fc  = EXTRACT_LE_16BITS(pkt);       //frame control\n    size_t hdrlen = extract_header_length(fc);\n    /*\n      if (pad) {\n      hdrlen = roundup2(hdrlen, 4);\n      }\n    */\n\n    if (debug) std::cerr << \"FC_TYPE(fc)= \" << FC_TYPE(fc) << \" \";\n\n    if (len < IEEE802_11_FC_LEN || len < hdrlen) {\n\tcbs->Handle80211Unknown( *this, fc, pkt, len);\n\treturn;\n    }\n\n    /* Always calculate the frame checksum, but only process the packets if the FCS or if we are ignoring it */\n    if (len >= hdrlen + 4) {\n        // assume fcs is last 4 bytes (?)\n        u_int32_t fcs_sent = EXTRACT_32BITS(pkt+len-4);\n        u_int32_t fcs = crc32_802(pkt, len-4);\n        \n        /*\n          if (fcs != fcs_sent) {\n          cerr << \"bad fcs: \";\n          fprintf (stderr, \"%08x != %08x\\n\", fcs_sent, fcs); \n          }\n        */\n\t\n        fcs_ok = (fcs == fcs_sent);\n    }\n    if (cbs->Check80211FCS(*this) && fcs_ok==false){\n        cbs->Handle80211Unknown(*this,fc,pkt,len);\n        return;\n    }\n\n\n    // fill in current_frame: type, sn\n    switch (FC_TYPE(fc)) {\n    case T_MGMT:\n\tif(decode_mgmt_frame(pkt, len, fc, hdrlen)<0)\n\t    return;\n\tbreak;\n    case T_DATA:\n\tif(decode_data_frame(pkt, len, fc)<0)\n\t    return;\n\tbreak;\n    case T_CTRL:\n\tif(decode_ctrl_frame(pkt, len, fc)<0)\n\t    return;\n\tbreak;\n    default:\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, MAC::null, MAC::null, pkt, len);\n\tcbs->Handle80211Unknown( *this, fc, pkt, len);\n\treturn;\n    }\n}\n\nint WifiPacket::print_radiotap_field(struct cpack_state *s, u_int32_t bit, int *pad, radiotap_hdr *hdr)\n{\n    union {\n        int8_t\t\ti8;\n        u_int8_t\tu8;\n        int16_t\t\ti16;\n        u_int16_t\tu16;\n        u_int32_t\tu32;\n        u_int64_t\tu64;\n    } u, u2, u3;\n    int rc;\n\n    switch (bit) {\n    case IEEE80211_RADIOTAP_FLAGS:\n        rc = cpack_uint8(s, &u.u8);\n        if (u.u8 & IEEE80211_RADIOTAP_F_DATAPAD)\n            *pad = 1;\n        break;\n    case IEEE80211_RADIOTAP_RATE:\n    case IEEE80211_RADIOTAP_DB_ANTSIGNAL:\n    case IEEE80211_RADIOTAP_DB_ANTNOISE:\n    case IEEE80211_RADIOTAP_ANTENNA:\n        rc = cpack_uint8(s, &u.u8);\n        break;\n    case IEEE80211_RADIOTAP_DBM_ANTSIGNAL:\n    case IEEE80211_RADIOTAP_DBM_ANTNOISE:\n        rc = cpack_int8(s, &u.i8);\n        break;\n    case IEEE80211_RADIOTAP_CHANNEL:\n        rc = cpack_uint16(s, &u.u16);\n        if (rc != 0)\n            break;\n        rc = cpack_uint16(s, &u2.u16);\n        break;\n    case IEEE80211_RADIOTAP_FHSS:\n    case IEEE80211_RADIOTAP_LOCK_QUALITY:\n    case IEEE80211_RADIOTAP_TX_ATTENUATION:\n        rc = cpack_uint16(s, &u.u16);\n        break;\n    case IEEE80211_RADIOTAP_DB_TX_ATTENUATION:\n        rc = cpack_uint8(s, &u.u8);\n        break;\n    case IEEE80211_RADIOTAP_DBM_TX_POWER:\n        rc = cpack_int8(s, &u.i8);\n        break;\n    case IEEE80211_RADIOTAP_TSFT:\n        rc = cpack_uint64(s, &u.u64);\n        break;\n    case IEEE80211_RADIOTAP_RX_FLAGS:\n        rc = cpack_uint16(s, &u.u16);\n        break;\n    case IEEE80211_RADIOTAP_TX_FLAGS:\n        rc = cpack_uint16(s, &u.u16);\n        break;\n    case IEEE80211_RADIOTAP_RTS_RETRIES:\n        rc = cpack_uint8(s, &u.u8);\n        break;\n    case IEEE80211_RADIOTAP_DATA_RETRIES:\n        rc = cpack_uint8(s, &u.u8);\n        break;\n        // simson add follows:\n    case IEEE80211_RADIOTAP_XCHANNEL:\n        rc = cpack_uint8(s, &u.u8);      // simson guess\n        break;\n    case IEEE80211_RADIOTAP_MCS:\n        rc = cpack_uint8(s, &u.u8) || cpack_uint8(s, &u2.u8) || cpack_uint8(s, &u3.u8);      // simson guess\n        break;\n        // simson end\n    default:\n        /* this bit indicates a field whose\n         * size we do not know, so we cannot\n         * proceed.\n         */\n        //printf(\"[0x%08x] \", bit);\n        fprintf(stderr, \"wifipcap: unknown radiotap bit: %d (%d)\\n\", bit,IEEE80211_RADIOTAP_XCHANNEL);\n        return  -1 ;\n    }\n\n    if (rc != 0) {\n        //printf(\"[|802.11]\");\n        fprintf(stderr, \"wifipcap: truncated radiotap header for bit: %d\\n\", bit);\n        return  rc ;\n    }\n\n    switch (bit) {\n    case IEEE80211_RADIOTAP_CHANNEL:\n        //printf(\"%u MHz \", u.u16);\n        if (u2.u16 != 0)\n            //printf(\"(0x%04x) \", u2.u16);\n            hdr->has_channel = true;\n        hdr->channel = u2.u16;\n        break;\n    case IEEE80211_RADIOTAP_FHSS:\n        //printf(\"fhset %d fhpat %d \", u.u16 & 0xff, (u.u16 >> 8) & 0xff);\n        hdr->has_fhss = true;\n        hdr->fhss_fhset = u.u16 & 0xff;\n        hdr->fhss_fhpat = (u.u16 >> 8) & 0xff;\n        break;\n    case IEEE80211_RADIOTAP_RATE:\n        //PRINT_RATE(\"\", u.u8, \" Mb/s \");\n        hdr->has_rate = true;\n        hdr->rate = u.u8;\n        break;\n    case IEEE80211_RADIOTAP_DBM_ANTSIGNAL:\n        //printf(\"%ddB signal \", u.i8);\n        hdr->has_signal_dbm = true;\n        hdr->signal_dbm = u.i8;\n        break;\n    case IEEE80211_RADIOTAP_DBM_ANTNOISE:\n        //printf(\"%ddB noise \", u.i8);\n        hdr->has_noise_dbm = true;\n        hdr->noise_dbm = u.i8;\n        break;\n    case IEEE80211_RADIOTAP_DB_ANTSIGNAL:\n        //printf(\"%ddB signal \", u.u8);\n        hdr->has_signal_db = true;\n        hdr->signal_db = u.u8;\n        break;\n    case IEEE80211_RADIOTAP_DB_ANTNOISE:\n        //printf(\"%ddB noise \", u.u8);\n        hdr->has_noise_db = true;\n        hdr->noise_db = u.u8;\n        break;\n    case IEEE80211_RADIOTAP_LOCK_QUALITY:\n        //printf(\"%u sq \", u.u16);\n        hdr->has_quality = true;\n        hdr->quality = u.u16;\n        break;\n    case IEEE80211_RADIOTAP_TX_ATTENUATION:\n        //printf(\"%d tx power \", -(int)u.u16);\n        hdr->has_txattenuation = true;\n        hdr->txattenuation = -(int)u.u16;\n        break;\n    case IEEE80211_RADIOTAP_DB_TX_ATTENUATION:\n        //printf(\"%ddB tx power \", -(int)u.u8);\n        hdr->has_txattenuation_db = true;\n        hdr->txattenuation_db = -(int)u.u8;\n        break;\n    case IEEE80211_RADIOTAP_DBM_TX_POWER:\n        //printf(\"%ddBm tx power \", u.i8);\n        hdr->has_txpower_dbm = true;\n        hdr->txpower_dbm = u.i8;\n        break;\n    case IEEE80211_RADIOTAP_FLAGS:\n        hdr->has_flags = true;\n        if (u.u8 & IEEE80211_RADIOTAP_F_CFP)\n            //printf(\"cfp \");\n            hdr->flags_cfp = true;\n        if (u.u8 & IEEE80211_RADIOTAP_F_SHORTPRE)\n            //printf(\"short preamble \");\n            hdr->flags_short_preamble = true;\n        if (u.u8 & IEEE80211_RADIOTAP_F_WEP)\n            //printf(\"wep \");\n            hdr->flags_wep = true;\n        if (u.u8 & IEEE80211_RADIOTAP_F_FRAG)\n            //printf(\"fragmented \");\n            hdr->flags_fragmented = true;\n        if (u.u8 & IEEE80211_RADIOTAP_F_BADFCS)\n            //printf(\"bad-fcs \");\n            hdr->flags_badfcs = true;\n        break;\n    case IEEE80211_RADIOTAP_ANTENNA:\n        //printf(\"antenna %d \", u.u8);\n        hdr->has_antenna = true;\n        hdr->antenna = u.u8;\n        break;\n    case IEEE80211_RADIOTAP_TSFT:\n        //printf(\"%\" PRIu64 \"us tsft \", u.u64);\n        hdr->has_tsft = true;\n        hdr->tsft = u.u64;\n        break;\n    case IEEE80211_RADIOTAP_RX_FLAGS:\n        hdr->has_rxflags = true;\n        hdr->rxflags = u.u16;\n        break;\n    case IEEE80211_RADIOTAP_TX_FLAGS:\n        hdr->has_txflags = true;\n        hdr->txflags = u.u16;\n        break;\n    case IEEE80211_RADIOTAP_RTS_RETRIES:\n        hdr->has_rts_retries = true;\n        hdr->rts_retries = u.u8;\n        break;\n    case IEEE80211_RADIOTAP_DATA_RETRIES:\n        hdr->has_data_retries = true;\n        hdr->data_retries = u.u8;\n        break;\n    }\n    return  0 ;\n}\n\n\n\nvoid WifiPacket::handle_radiotap(const u_char *p,size_t caplen)\n{\n#define\tBITNO_32(x) (((x) >> 16) ? 16 + BITNO_16((x) >> 16) : BITNO_16((x)))\n#define\tBITNO_16(x) (((x) >> 8) ? 8 + BITNO_8((x) >> 8) : BITNO_8((x)))\n#define\tBITNO_8(x) (((x) >> 4) ? 4 + BITNO_4((x) >> 4) : BITNO_4((x)))\n#define\tBITNO_4(x) (((x) >> 2) ? 2 + BITNO_2((x) >> 2) : BITNO_2((x)))\n#define\tBITNO_2(x) (((x) & 2) ? 1 : 0)\n#define\tBIT(n)\t(1 << n)\n#define\tIS_EXTENDED(__p) (EXTRACT_LE_32BITS(__p) & BIT(IEEE80211_RADIOTAP_EXT)) != 0\n\n    // If caplen is too small, just give it a try and carry on.\n    if (caplen < sizeof(struct ieee80211_radiotap_header)) {\n        cbs->HandleRadiotap( *this, NULL, p, caplen);\n        return;\n    }\n\n    struct ieee80211_radiotap_header *hdr = (struct ieee80211_radiotap_header *)p;\n\n    size_t len = EXTRACT_LE_16BITS(&hdr->it_len); // length of radiotap header\n\n    if (caplen < len) {\n        //printf(\"[|802.11]\");\n        cbs->HandleRadiotap( *this, NULL, p, caplen);\n        return;// caplen;\n    }\n    uint32_t *last_presentp=0;\n    for (last_presentp = &hdr->it_present;\n         IS_EXTENDED(last_presentp) && (u_char*)(last_presentp + 1) <= p + len;\n         last_presentp++){\n    }\n\n    /* are there more bitmap extensions than bytes in header? */\n    if (IS_EXTENDED(last_presentp)) {\n        //printf(\"[|802.11]\");\n        cbs->HandleRadiotap( *this, NULL, p, caplen);\n        return;// caplen;\n    }\n\n    const u_char *iter = (u_char*)(last_presentp + 1);\n    struct cpack_state cpacker;\n    if (cpack_init(&cpacker, (u_int8_t*)iter, len - (iter - p)) != 0) {\n        /* XXX */\n        //printf(\"[|802.11]\");\n        cbs->HandleRadiotap( *this, NULL, p, caplen);\n        return;// caplen;\n    }\n\n    radiotap_hdr ohdr;\n    memset(&ohdr, 0, sizeof(ohdr));\n\t\n    /* Assume no Atheros padding between 802.11 header and body */\n    int pad = 0;\n    uint32_t *presentp;\n    int bit0=0;\n    for (bit0 = 0, presentp = &hdr->it_present; presentp <= last_presentp;\n         presentp++, bit0 += 32) {\n\n        u_int32_t present, next_present;\n        for (present = EXTRACT_LE_32BITS(presentp); present;\n             present = next_present) {\n            /* clear the least significant bit that is set */\n            next_present = present & (present - 1);\n\n            /* extract the least significant bit that is set */\n            enum ieee80211_radiotap_type bit = (enum ieee80211_radiotap_type)\n                (bit0 + BITNO_32(present ^ next_present));\n\n            /* print the next radiotap field */\n            int r = print_radiotap_field(&cpacker, bit, &pad, &ohdr);\n\n            /* If we got an error, break both loops */\n            if(r!=0) goto done;\n        }\n    }\ndone:;\n    cbs->HandleRadiotap( *this, &ohdr, p, caplen);\n    //return len + ieee802_11_print(p + len, length - len, caplen - len, pad);\n#undef BITNO_32\n#undef BITNO_16\n#undef BITNO_8\n#undef BITNO_4\n#undef BITNO_2\n#undef BIT\n    handle_80211(p+len, caplen-len);\n}\n\nvoid WifiPacket::handle_prism(const u_char *pc, size_t len)\n{\n    prism2_pkthdr hdr;\n\n    /* get the fields */\n    hdr.host_time \t= EXTRACT_LE_32BITS(pc+32);\n    hdr.mac_time \t= EXTRACT_LE_32BITS(pc+44);\n    hdr.channel \t= EXTRACT_LE_32BITS(pc+56);\n    hdr.rssi \t\t= EXTRACT_LE_32BITS(pc+68);\n    hdr.sq \t\t= EXTRACT_LE_32BITS(pc+80);\n    hdr.signal  \t= EXTRACT_LE_32BITS(pc+92);\n    hdr.noise   \t= EXTRACT_LE_32BITS(pc+104);\n    hdr.rate\t\t= EXTRACT_LE_32BITS(pc+116)/2;\n    hdr.istx\t\t= EXTRACT_LE_32BITS(pc+128);\n    cbs->HandlePrism( *this, &hdr, pc + 144, len - 144);\n    handle_80211(pc+144,len-144);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n///\n/// handle_*:\n/// handle each of the packet types\n///\n\nvoid WifiPacket::handle_ether(const u_char *ptr, size_t len)\n{\n#if 0\n    ether_hdr_t hdr;\n\n    hdr.da = MAC::ether2MAC(ptr);\n    hdr.sa = MAC::ether2MAC(ptr+6);\n    hdr.type = EXTRACT_16BITS(ptr + 12);\n\n    ptr += 14;\n    len -= 14;\n\n    cbs->HandleEthernet(*this, &hdr, ptr, len);\n\n    switch (hdr.type) {\n    case ETHERTYPE_IP:\n\thandle_ip(ptr, len);\n\treturn;\n    case ETHERTYPE_IPV6:\n\thandle_ip6(ptr, len);\n\treturn;\n    case ETHERTYPE_ARP:\n\thandle_arp( ptr, len);\n\treturn;\n    default:\n\tcbs->HandleL2Unknown(*this, hdr.type, ptr, len);\n\treturn;\n    }\n#endif\n}\n\n///////////////////////////////////////////////////////////////////////////////\n/* These are all static functions */\n#if 0\nvoid Wifipcap::dl_prism(const PcapUserData &data, const struct pcap_pkthdr *header, const u_char * packet)\n{\n    WifipcapCallbacks *cbs = data.cbs;\n\n    if(header->caplen < 144) return;    // prism header\n\n    cbs->PacketBegin( packet, header->caplen, header->len);\n    handle_prism(cbs,packet+144,header->caplen-144);\n    cbs->PacketEnd();\n}\n\nvoid Wifipcap::dl_prism(u_char *user, const struct pcap_pkthdr *header, const u_char * packet)\n{\n    PcapUserData *data = reinterpret_cast<PcapUserData *>(user);\n    Wifipcap::dl_prism(*data,header,packet);\n}\n#endif\n\n#if 0\nvoid Wifipcap::dl_ieee802_11_radio(const PcapUserData &data, const struct pcap_pkthdr *header,\n                                   const u_char * packet)\n{\n\n    data.cbs->PacketBegin( packet, header->caplen, header->len);\n    handle_radiotap(packet, header->caplen);\n    data.cbs->PacketEnd();\n}\n#endif\n\nvoid Wifipcap::dl_ieee802_11_radio(const u_char *user, const struct pcap_pkthdr *header, const u_char * packet)\n{\n    const PcapUserData *data = reinterpret_cast<const PcapUserData *>(user);\n    WifiPacket pkt(data->cbs,data->header_type,header,packet);\n\n    data->cbs->PacketBegin(pkt,packet,header->caplen,header->len);\n    pkt.handle_radiotap(packet,header->caplen);\n    data->cbs->PacketEnd(pkt);\n\n    //Wifipcap::dl_ieee802_11_radio(*data,header,packet);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n/* None of these are used in tcpflow */\n\nbool Wifipcap::InitNext()\n{\n    if (morefiles.size() < 1){\n\treturn false;\n    }\n    if (descr) {\n        pcap_close(descr);\n    }\n    Init(morefiles.front(), false);\n    morefiles.pop_front();\n    return true;\n}\n\nvoid Wifipcap::Init(const char *name, bool live) {\n    if (verbose){\n        std::cerr << \"wifipcap: initializing '\" << name << \"'\" << std::endl;\n    }\n\n    if (!live) {\n#ifdef _WIN32\n\tstd::cerr << \"Trace replay is unsupported in windows.\" << std::endl;\n\texit(1);\n#else\n\t// mini hack: handle gziped files since all our traces are in\n\t// this format\n\tint slen = strlen(name);\n\n\tbool gzip = !strcmp(name+slen-3, \".gz\");\n\tbool bzip = !strcmp(name+slen-4, \".bz2\");\n\t\n\tchar cmd[256];\n\tchar errbuf[256];\n\tif (gzip) \n\t    sprintf(cmd, \"zcat %s\", name);\n\telse if (bzip)\n\t    sprintf(cmd, \"bzcat %s\", name);\n\telse\n\t    // using cat here instead of pcap_open or fopen is intentional\n\t    // neither of these may be able to handle large files (>2GB files)\n\t    // but cat uses the linux routines to allow it to\n\t    sprintf(cmd, \"cat %s\", name);\n\n\tFILE *pipe = popen(cmd, \"r\");\n\tif (pipe == NULL) {\n\t    printf(\"popen(): %s\\n\", strerror(errno));\n\t    exit(1);\n\t}\n\tdescr = pcap_fopen_offline(pipe, errbuf);\n\n        if(descr == NULL) {\n            printf(\"pcap_open_offline(): %s\\n\", errbuf);\n            exit(1);\n        }\n#endif\n    } else {\n\tchar errbuf[256];\n\tdescr = pcap_open_live(name,BUFSIZ,1,-1,errbuf);\n        if(descr == NULL) {\n            printf(\"pcap_open_live(): %s\\n\", errbuf);\n            exit(1);\n        }\n    }\n\n    datalink = pcap_datalink(descr);\n    if (datalink != DLT_PRISM_HEADER && datalink != DLT_IEEE802_11_RADIO && datalink != DLT_IEEE802_11) {\n\tif (datalink == DLT_EN10MB) {\n\t    printf(\"warning: ethernet datalink type: %s\\n\",\n\t\t   pcap_datalink_val_to_name(datalink));\n\t} else {\n\t    printf(\"warning: unrecognized datalink type: %s\\n\",\n\t\t   pcap_datalink_val_to_name(datalink));\n\t}\n    }\n}\n\n\n\n\n/* object-oriented version of pcap callback. Called with the callbacks object,\n * the DLT type, the header and the packet.\n * This is the main packet processor.\n * It records some stats and then dispatches to the appropriate callback.\n */\nvoid Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,\n                             const struct pcap_pkthdr *header, const u_char * packet) \n{\n    /* Record start time if we don't have it */\n    if (startTime == TIME_NONE) {\n\tstartTime = header->ts;\n\tlastPrintTime = header->ts;\n    }\n    /* Print stats if necessary */\n    if (header->ts.tv_sec > lastPrintTime.tv_sec + Wifipcap::PRINT_TIME_INTERVAL) {\n\tif (verbose) {\n\t    int hours = (header->ts.tv_sec - startTime.tv_sec)/3600;\n\t    int days  = hours/24;\n\t    int left  = hours%24;\n\t    fprintf(stderr, \"wifipcap: %2d days %2d hours, %10\" PRId64 \" pkts\\n\", \n\t\t    days, left, packetsProcessed);\n\t}\n\tlastPrintTime = header->ts;\n    }\n    packetsProcessed++;\n\n    /* Create the packet object and call the appropriate callbacks */\n    WifiPacket pkt(cbs,header_type,header,packet);\n\n    /* Notify callback */\n    cbs->PacketBegin(pkt, packet, header->caplen, header->len);\n    //int frameLen = header->caplen;\n    switch(header_type) {\n    case DLT_PRISM_HEADER:\n        pkt.handle_prism(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11_RADIO:\n        pkt.handle_radiotap(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11:\n        pkt.handle_80211(packet,header->caplen);\n        break;\n    case DLT_EN10MB:\n        pkt.handle_ether(packet,header->caplen);\n        break;\n    default:\n#if 0\n\t// try handling it as default IP assuming framing is ethernet \n\t// (this is for testing)\n        pkt.handle_ip(packet,header->caplen);\n#endif\n        break;\n    }\n    cbs->PacketEnd(pkt);\n}\n\n\n/* The raw callback from pcap; jump back into the object-oriented domain */\n/* note: u_char *user may not be const according to spec */\nvoid Wifipcap::handle_packet_callback(u_char *user, const struct pcap_pkthdr *header, const u_char * packet)\n{\n    Wifipcap::PcapUserData *data = reinterpret_cast<Wifipcap::PcapUserData *>(user);\n    data->wcap->handle_packet(data->cbs,data->header_type,header,packet);\n}\n    \n\nconst char *Wifipcap::SetFilter(const char *filter)\n{\n    struct bpf_program fp;\n#ifdef PCAP_NETMASK_UNKNOWN\n    bpf_u_int32 netp=PCAP_NETMASK_UNKNOWN;\n#else\n    bpf_u_int32 netp=0;\n#endif\n\n\n    if(pcap_compile(descr,&fp,(char *)filter,0,netp) == -1) { \n\treturn \"Error calling pcap_compile\"; \n    }\n    \n    if(pcap_setfilter(descr,&fp) == -1) { \n\treturn \"Error setting filter\"; \n    }\n\n    return NULL;\n}\n\n\nvoid Wifipcap::Run(WifipcapCallbacks *cbs, int maxpkts)\n{\n    /* NOTE: This needs to be fixed so that the correct handle_packet is called  */\n\n    packetsProcessed = 0;\n    \n    do {\n\tPcapUserData data(this,cbs,DLT_IEEE802_11_RADIO);\n\tpcap_loop(descr, maxpkts > 0 ? maxpkts - packetsProcessed : 0,\n\t\t  Wifipcap::handle_packet_callback, reinterpret_cast<u_char *>(&data));\n    } while ( InitNext() );\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n\n"], "fixing_code": ["/**********************************************************************\n * Log:\n * 2006-03-12: Parts originally authored by Doug Madory as wifi_parser.c\n * 2013-03-15: Substantially modified by Simson Garfinkel for inclusion into tcpflow\n * 2013-11-18: reworked static calls to be entirely calls to a class. Changed TimeVal pointer to an instance variable that includes the full packet header.\n **********************************************************************/\n\n//*do 11-18\n\n#include \"config.h\"\t\t// pull in HAVE_ defines\n\n#define __STDC_FORMAT_MACROS \n\n#include <stdint.h>\n#include <inttypes.h>\n\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <stdarg.h>\n#include <errno.h>\n\n#ifdef HAVE_NET_ETHERNET_H\n#include <net/ethernet.h>\n#endif\n\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#pragma GCC diagnostic ignored \"-Wcast-align\"\n\n#include \"wifipcap.h\"\n\n#include \"cpack.h\"\n#include \"extract.h\"\n#include \"oui.h\"\n#include \"ethertype.h\"\n#include \"icmp.h\"\n#include \"ipproto.h\"\n\n/* wifipcap uses a MAC class which is somewhat lame, but works */\n\nMAC MAC::broadcast(0xffffffffffffULL);\nMAC MAC::null((uint64_t)0);\nint WifiPacket::debug=0;\nint MAC::print_fmt(MAC::PRINT_FMT_COLON);\n\nstd::ostream& operator<<(std::ostream& out, const MAC& mac) {\n    const char *fmt = MAC::print_fmt == MAC::PRINT_FMT_COLON ? \n\t\"%02x:%02x:%02x:%02x:%02x:%02x\" :\n\t\"%02x%02x%02x%02x%02x%02x\";\n    char buf[24];\n    sprintf(buf, fmt, \n\t    (int)((mac.val>>40)&0xff),\n\t    (int)((mac.val>>32)&0xff),\n\t    (int)((mac.val>>24)&0xff),\n\t    (int)((mac.val>>16)&0xff),\n\t    (int)((mac.val>>8)&0xff),\n\t    (int)((mac.val)&0xff)\n        );\n    out << buf;\n    return out;\n}\n\nstd::ostream& operator<<(std::ostream& out, const struct in_addr& ip) {\n    out << inet_ntoa(ip);\n    return out;\n}\n\nstruct tok {\n    int v;\t\t\t/* value */\n    const char *s;\t\t/* string */\n};\n\n#if 0\nstatic const struct tok ethertype_values[] = { \n    { ETHERTYPE_IP,\t\t\"IPv4\" },\n    { ETHERTYPE_MPLS,\t\t\"MPLS unicast\" },\n    { ETHERTYPE_MPLS_MULTI,\t\"MPLS multicast\" },\n    { ETHERTYPE_IPV6,\t\t\"IPv6\" },\n    { ETHERTYPE_8021Q,\t\t\"802.1Q\" },\n    { ETHERTYPE_VMAN,\t\t\"VMAN\" },\n    { ETHERTYPE_PUP,            \"PUP\" },\n    { ETHERTYPE_ARP,            \"ARP\"},\n    { ETHERTYPE_REVARP,         \"Reverse ARP\"},\n    { ETHERTYPE_NS,             \"NS\" },\n    { ETHERTYPE_SPRITE,         \"Sprite\" },\n    { ETHERTYPE_TRAIL,          \"Trail\" },\n    { ETHERTYPE_MOPDL,          \"MOP DL\" },\n    { ETHERTYPE_MOPRC,          \"MOP RC\" },\n    { ETHERTYPE_DN,             \"DN\" },\n    { ETHERTYPE_LAT,            \"LAT\" },\n    { ETHERTYPE_SCA,            \"SCA\" },\n    { ETHERTYPE_LANBRIDGE,      \"Lanbridge\" },\n    { ETHERTYPE_DECDNS,         \"DEC DNS\" },\n    { ETHERTYPE_DECDTS,         \"DEC DTS\" },\n    { ETHERTYPE_VEXP,           \"VEXP\" },\n    { ETHERTYPE_VPROD,          \"VPROD\" },\n    { ETHERTYPE_ATALK,          \"Appletalk\" },\n    { ETHERTYPE_AARP,           \"Appletalk ARP\" },\n    { ETHERTYPE_IPX,            \"IPX\" },\n    { ETHERTYPE_PPP,            \"PPP\" },\n    { ETHERTYPE_SLOW,           \"Slow Protocols\" },\n    { ETHERTYPE_PPPOED,         \"PPPoE D\" },\n    { ETHERTYPE_PPPOES,         \"PPPoE S\" },\n    { ETHERTYPE_EAPOL,          \"EAPOL\" },\n    { ETHERTYPE_JUMBO,          \"Jumbo\" },\n    { ETHERTYPE_LOOPBACK,       \"Loopback\" },\n    { ETHERTYPE_ISO,            \"OSI\" },\n    { ETHERTYPE_GRE_ISO,        \"GRE-OSI\" },\n    { 0, NULL}\n};\n#endif\n\n/*max length of an IEEE 802.11 packet*/\n#ifndef MAX_LEN_80211\n#define MAX_LEN_80211 3000\n#endif\n\n/* from ethereal packet-prism.c */\n#define pletohs(p)  ((u_int16_t)\t\t\t\t\t\\\n\t\t     ((u_int16_t)*((const u_int8_t *)(p)+1)<<8|\t\t\\\n\t\t      (u_int16_t)*((const u_int8_t *)(p)+0)<<0))\n#define pntohl(p)   ((u_int32_t)*((const u_int8_t *)(p)+0)<<24|\t\\\n\t\t     (u_int32_t)*((const u_int8_t *)(p)+1)<<16|\t\\\n\t\t     (u_int32_t)*((const u_int8_t *)(p)+2)<<8|\t\\\n\t\t     (u_int32_t)*((const u_int8_t *)(p)+3)<<0)\n#define COOK_FRAGMENT_NUMBER(x) ((x) & 0x000F)\n#define COOK_SEQUENCE_NUMBER(x) (((x) & 0xFFF0) >> 4)\n/* end ethereal code */\n\n/* Sequence number gap */\n#define SEQ_GAP(current, last)(0xfff & (current - last))\n\n/* In the following three arrays, even though the QoS subtypes are listed, in the rest of the program\n * the QoS subtypes are treated as \"OTHER_TYPES\". The file \"ieee802_11.h\" currently doesn't account for\n * the existence of QoS subtypes. The QoS subtypes might need to be accomodated there in the future.\n */\n#if 0\nstatic const char * mgmt_subtype_text[] = {\n    \"AssocReq\",\n    \"AssocResp\",\n    \"ReAssocReq\",\n    \"ReAssocResp\",\n    \"ProbeReq\",\n    \"ProbeResp\",\n    \"\",\n    \"\",\n    \"Beacon\",\n    \"ATIM\",\n    \"Disassoc\",\n    \"Auth\",\n    \"DeAuth\",\n    \"Action\", /*QoS mgmt_subtype*/\n    \"\",\n    \"\"\n};\n\nstatic const char * ctrl_subtype_text[] = {\n    \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n    \"BlockAckReq\", /*QoS ctrl_subtype*/\n    \"BlockAck\",    /*QoS ctrl_subtype*/\n    \"PS-Poll\",\n    \"RTS\",\n    \"CTS\",\n    \"ACK\",\n    \"CF-End\",\n    \"CF-End+CF-Ack\"\n};\n\nstatic const char * data_subtype_text[] = {\n    \"Data\",\n    \"Data+CF-Ack\",\n    \"Data+CF-Poll\",\n    \"Data+CF-Ack+CF-Poll\",\n    \"Null(no_data)\",\n    \"CF-Ack(no_data)\",\n    \"CF-Poll(no_data)\",\n    \"CF-Ack+CF-Poll(no_data)\",\n    \"QoS_Data\", /*QoS data_subtypes from here on*/\n    \"QoS_Data+CF-Ack\",\n    \"QoS_Data+CF-Poll\",\n    \"QoS_Data+CF-Ack+CF-Poll\",\n    \"QoS_Null(no_data)\",\n    \"\",\n    \"QoS_CF-Poll(no_data)\",\n    \"QoS_CF-Ack+CF-Poll(no_data)\"\n};\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n// crc32 implementation needed for wifi checksum\n\n/* crc32.c\n * CRC-32 routine\n *\n * $Id: crc32.cpp,v 1.1 2007/02/14 00:05:50 jpang Exp $\n *\n * Ethereal - Network traffic analyzer\n * By Gerald Combs <gerald@ethereal.com>\n * Copyright 1998 Gerald Combs\n *\n * Copied from README.developer\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n * Credits:\n *\n * Table from Solomon Peachy\n * Routine from Chris Waters\n */\n\n/*\n * Table for the AUTODIN/HDLC/802.x CRC.\n *\n * Polynomial is\n *\n *  x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^8 + x^7 +\n *      x^5 + x^4 + x^2 + x + 1\n */\nstatic const uint32_t crc32_ccitt_table[256] = {\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n    0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n    0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n    0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n    0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n    0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n    0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n    0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n    0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n    0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n    0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n    0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n    0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n    0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n    0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n    0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n    0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n    0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n    0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n    0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n    0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n    0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n    0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n    0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n    0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n    0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n    0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n    0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n    0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n    0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n    0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n    0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n    0x2d02ef8d\n};\n\n#define CRC32_CCITT_SEED    0xFFFFFFFF\n\nstatic uint32_t crc32_ccitt_seed(const uint8_t *buf, size_t len, uint32_t seed);\n\nstatic uint32_t crc32_ccitt(const uint8_t *buf, size_t len)\n{\n    return ( crc32_ccitt_seed(buf, len, CRC32_CCITT_SEED) );\n}\n\nstatic uint32_t crc32_ccitt_seed(const uint8_t *buf, size_t len, uint32_t seed)\n{\n    uint32_t crc32 = seed;\n\n    for (unsigned int i = 0; i < len; i++){\n        crc32 = crc32_ccitt_table[(crc32 ^ buf[i]) & 0xff] ^ (crc32 >> 8);\n    }\n\n    return ( ~crc32 );\n}\n\n/*\n * IEEE 802.x version (Ethernet and 802.11, at least) - byte-swap\n * the result of \"crc32()\".\n *\n * XXX - does this mean we should fetch the Ethernet and 802.11\n * Frame Checksum (FCS) with \"tvb_get_letohl()\" rather than \"tvb_get_ntohl()\",\n * or is fetching it big-endian and byte-swapping the CRC done\n * to cope with 802.x sending stuff out in reverse bit order?\n */\nstatic uint32_t crc32_802(const unsigned char *buf, size_t len)\n{\n    uint32_t c_crc;\n\n    c_crc = crc32_ccitt(buf, len);\n\n    /* Byte reverse. */\n    c_crc = ((unsigned char)(c_crc>>0)<<24) |\n        ((unsigned char)(c_crc>>8)<<16) |\n        ((unsigned char)(c_crc>>16)<<8) |\n        ((unsigned char)(c_crc>>24)<<0);\n\n    return ( c_crc );\n}\n///////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////\n\n/* Translate Ethernet address, as seen in struct ether_header, to type MAC. */\n/* Extract header length. */\nstatic size_t extract_header_length(u_int16_t fc)\n{\n    switch (FC_TYPE(fc)) {\n    case T_MGMT:\n\treturn MGMT_HDRLEN;\n    case T_CTRL:\n\tswitch (FC_SUBTYPE(fc)) {\n\tcase CTRL_PS_POLL:\n\t    return CTRL_PS_POLL_HDRLEN;\n\tcase CTRL_RTS:\n\t    return CTRL_RTS_HDRLEN;\n\tcase CTRL_CTS:\n\t    return CTRL_CTS_HDRLEN;\n\tcase CTRL_ACK:\n\t    return CTRL_ACK_HDRLEN;\n\tcase CTRL_CF_END:\n\t    return CTRL_END_HDRLEN;\n\tcase CTRL_END_ACK:\n\t    return CTRL_END_ACK_HDRLEN;\n\tdefault:\n\t    return 0;\n\t}\n    case T_DATA:\n\treturn (FC_TO_DS(fc) && FC_FROM_DS(fc)) ? 30 : 24;\n    default:\n\treturn 0;\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////\n\n#pragma GCC diagnostic ignored \"-Wcast-align\"\nvoid WifiPacket::handle_llc(const mac_hdr_t &mac,const u_char *ptr, size_t len,u_int16_t fc)\n{\n    if (len < 7) {\n\t// truncated header!\n\tcbs->HandleLLC(*this,NULL, ptr, len);\n\treturn;\n    }\n\n    // http://www.wildpackets.com/resources/compendium/wireless_lan/wlan_packets\n\n    llc_hdr_t hdr;\n    hdr.dsap   = EXTRACT_LE_8BITS(ptr); // Destination Service Access point\n    hdr.ssap   = EXTRACT_LE_8BITS(ptr + 1); // Source Service Access Point\n    hdr.control= EXTRACT_LE_8BITS(ptr + 2); // ignored by most protocols\n    hdr.oui    = EXTRACT_24BITS(ptr + 3);\n    hdr.type   = EXTRACT_16BITS(ptr + 6);\n\n\n    /* \"When both the DSAP and SSAP are set to 0xAA, the type is\n     * interpreted as a protocol not defined by IEEE and the LSAP is\n     * referred to as SubNetwork Access Protocol (SNAP).  In SNAP, the\n     * 5 bytes that follow the DSAP, SSAP, and control byte are called\n     * the Protocol Discriminator.\"\n     */\n\n    if(hdr.dsap==0xAA && hdr.ssap==0xAA){\n        cbs->HandleLLC(*this,&hdr,ptr+8,len-8);\n        return;\n    }\n\n    if (hdr.oui == OUI_ENCAP_ETHER || hdr.oui == OUI_CISCO_90) {\n        cbs->HandleLLC(*this,&hdr, ptr+8, len-8);\n        return;\n    }\n        \n    cbs->HandleLLCUnknown(*this,ptr, len);\n}\n\nvoid WifiPacket::handle_wep(const u_char *ptr, size_t len)\n{\n    // Jeff: XXX handle TKIP/CCMP ? how can we demultiplex different\n    // protection protocols?\n\n    struct wep_hdr_t hdr;\n    u_int32_t iv;\n\n    if (len < IEEE802_11_IV_LEN + IEEE802_11_KID_LEN) {\n\t// truncated!\n\tcbs->HandleWEP(*this,NULL, ptr, len);\n\treturn;\n    }\n    iv = EXTRACT_LE_32BITS(ptr);\n    hdr.iv = IV_IV(iv);\n    hdr.pad = IV_PAD(iv);\n    hdr.keyid = IV_KEYID(iv);\n    cbs->HandleWEP(*this,&hdr, ptr, len);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstatic const char *auth_alg_text[]={\"Open System\",\"Shared Key\",\"EAP\"};\n#define NUM_AUTH_ALGS\t(sizeof auth_alg_text / sizeof auth_alg_text[0])\n\nstatic const char *status_text[] = {\n    \"Succesful\",  /*  0  */\n    \"Unspecified failure\",  /*  1  */\n    \"Reserved\",\t  /*  2  */\n    \"Reserved\",\t  /*  3  */\n    \"Reserved\",\t  /*  4  */\n    \"Reserved\",\t  /*  5  */\n    \"Reserved\",\t  /*  6  */\n    \"Reserved\",\t  /*  7  */\n    \"Reserved\",\t  /*  8  */\n    \"Reserved\",\t  /*  9  */\n    \"Cannot Support all requested capabilities in the Capability Information field\",\t  /*  10  */\n    \"Reassociation denied due to inability to confirm that association exists\",\t  /*  11  */\n    \"Association denied due to reason outside the scope of the standard\",\t  /*  12  */\n    \"Responding station does not support the specified authentication algorithm \",\t  /*  13  */\n    \"Received an Authentication frame with authentication transaction \" \\\n    \"sequence number out of expected sequence\",\t  /*  14  */\n    \"Authentication rejected because of challenge failure\",\t  /*  15 */\n    \"Authentication rejected due to timeout waiting for next frame in sequence\",\t  /*  16 */\n    \"Association denied because AP is unable to handle additional associated stations\",\t  /*  17 */\n    \"Association denied due to requesting station not supporting all of the \" \\\n    \"data rates in BSSBasicRateSet parameter\",\t  /*  18 */\n};\n#define NUM_STATUSES\t(sizeof status_text / sizeof status_text[0])\n\nstatic const char *reason_text[] = {\n    \"Reserved\", /* 0 */\n    \"Unspecified reason\", /* 1 */\n    \"Previous authentication no longer valid\",  /* 2 */\n    \"Deauthenticated because sending station is leaving (or has left) IBSS or ESS\", /* 3 */\n    \"Disassociated due to inactivity\", /* 4 */\n    \"Disassociated because AP is unable to handle all currently associated stations\", /* 5 */\n    \"Class 2 frame received from nonauthenticated station\", /* 6 */\n    \"Class 3 frame received from nonassociated station\", /* 7 */\n    \"Disassociated because sending station is leaving (or has left) BSS\", /* 8 */\n    \"Station requesting (re)association is not authenticated with responding station\", /* 9 */\n};\n#define NUM_REASONS\t(sizeof reason_text / sizeof reason_text[0])\n\nconst char *Wifipcap::WifiUtil::MgmtAuthAlg2Txt(uint v) {\n    return v < NUM_AUTH_ALGS ? auth_alg_text[v] : \"Unknown\";\n}\nconst char *Wifipcap::WifiUtil::MgmtStatusCode2Txt(uint v) {\n    return v < NUM_STATUSES ? status_text[v] : \"Reserved\";\n}\nconst char *Wifipcap::WifiUtil::MgmtReasonCode2Txt(uint v) {\n    return v < NUM_REASONS ? reason_text[v] : \"Reserved\";\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n// Jeff: HACK -- tcpdump uses a global variable to check truncation\n#define TTEST2(_p, _l) ((const u_char *)&(_p) - p + (_l) <= (ssize_t)len) \n\nvoid WifiPacket::parse_elements(struct mgmt_body_t *pbody, const u_char *p, int offset, size_t len)\n{\n    /*\n     * We haven't seen any elements yet.\n     */\n    pbody->challenge_status = NOT_PRESENT;\n    pbody->ssid_status = NOT_PRESENT;\n    pbody->rates_status = NOT_PRESENT;\n    pbody->ds_status = NOT_PRESENT;\n    pbody->cf_status = NOT_PRESENT;\n    pbody->tim_status = NOT_PRESENT;\n\n    for (;;) {\n        if (!TTEST2(*(p + offset), 1))\n            return;\n        switch (*(p + offset)) {\n        case E_SSID:\n            /* Present, possibly truncated */\n            pbody->ssid_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 2))\n                return;\n            memcpy(&pbody->ssid, p + offset, 2);\n            offset += 2;\n            if (pbody->ssid.length != 0) {\n                if (pbody->ssid.length >\n                    sizeof(pbody->ssid.ssid) - 1)\n                    return;\n                if (!TTEST2(*(p + offset), pbody->ssid.length))\n                    return;\n                memcpy(&pbody->ssid.ssid, p + offset,\n                       pbody->ssid.length);\n                offset += pbody->ssid.length;\n            }\n            pbody->ssid.ssid[pbody->ssid.length] = '\\0';\n            /* Present and not truncated */\n            pbody->ssid_status = PRESENT;\n            break;\n        case E_CHALLENGE:\n            /* Present, possibly truncated */\n            pbody->challenge_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 2))\n                return;\n            memcpy(&pbody->challenge, p + offset, 2);\n            offset += 2;\n            if (pbody->challenge.length != 0) {\n                if (pbody->challenge.length >\n                    sizeof(pbody->challenge.text) - 1)\n                    return;\n                if (!TTEST2(*(p + offset), pbody->challenge.length))\n                    return;\n                memcpy(&pbody->challenge.text, p + offset,\n                       pbody->challenge.length);\n                offset += pbody->challenge.length;\n            }\n            pbody->challenge.text[pbody->challenge.length] = '\\0';\n            /* Present and not truncated */\n            pbody->challenge_status = PRESENT;\n            break;\n        case E_RATES:\n            /* Present, possibly truncated */\n            pbody->rates_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 2))\n                return;\n            memcpy(&(pbody->rates), p + offset, 2);\n            offset += 2;\n            if (pbody->rates.length != 0) {\n                if (pbody->rates.length > sizeof pbody->rates.rate)\n                    return;\n                if (!TTEST2(*(p + offset), pbody->rates.length))\n                    return;\n                memcpy(&pbody->rates.rate, p + offset,\n                       pbody->rates.length);\n                offset += pbody->rates.length;\n            }\n            /* Present and not truncated */\n            pbody->rates_status = PRESENT;\n            break;\n        case E_DS:\n            /* Present, possibly truncated */\n            pbody->ds_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 3))\n                return;\n            memcpy(&pbody->ds, p + offset, 3);\n            offset += 3;\n            /* Present and not truncated */\n            pbody->ds_status = PRESENT;\n            break;\n        case E_CF:\n            /* Present, possibly truncated */\n            pbody->cf_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 8))\n                return;\n            memcpy(&pbody->cf, p + offset, 8);\n            offset += 8;\n            /* Present and not truncated */\n            pbody->cf_status = PRESENT;\n            break;\n        case E_TIM:\n            /* Present, possibly truncated */\n            pbody->tim_status = TRUNCATED;\n            if (!TTEST2(*(p + offset), 2))\n                return;\n            memcpy(&pbody->tim, p + offset, 2);\n            offset += 2;\n            if (!TTEST2(*(p + offset), 3))\n                return;\n            memcpy(&pbody->tim.count, p + offset, 3);\n            offset += 3;\n\n            if (pbody->tim.length <= 3)\n                break;\n            if (pbody->rates.length > sizeof pbody->tim.bitmap)\n                return;\n            if (!TTEST2(*(p + offset), pbody->tim.length - 3))\n                return;\n            memcpy(pbody->tim.bitmap, p + (pbody->tim.length - 3),\n                   (pbody->tim.length - 3));\n            offset += pbody->tim.length - 3;\n            /* Present and not truncated */\n            pbody->tim_status = PRESENT;\n            break;\n        default:\n#ifdef DEBUG_WIFI\n            printf(\"(1) unhandled element_id (%d)  \", *(p + offset) );\n#endif\n            if (!TTEST2(*(p + offset), 2))\n                return;\n            if (!TTEST2(*(p + offset + 2), *(p + offset + 1)))\n                return;\n            offset += *(p + offset + 1) + 2;\n            break;\n        }\n    }\n}\n\n/*********************************************************************************\n * Print Handle functions for the management frame types\n *********************************************************************************/\n\nint\nWifiPacket::handle_beacon( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_TSTAMP_LEN + IEEE802_11_BCNINT_LEN +\n                IEEE802_11_CAPINFO_LEN))\n        return 0;\n    memcpy(&pbody.timestamp, p, IEEE802_11_TSTAMP_LEN);\n    offset += IEEE802_11_TSTAMP_LEN;\n    pbody.beacon_interval = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_BCNINT_LEN;\n    pbody.capability_info = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_CAPINFO_LEN;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      PRINT_SSID(pbody);\n      PRINT_RATES(pbody);\n      printf(\" %s\",\n      CAPABILITY_ESS(pbody.capability_info) ? \"ESS\" : \"IBSS\");\n      PRINT_DS_CHANNEL(pbody);\n    */\n    cbs->Handle80211MgmtBeacon(*this, pmh, &pbody);\n    return 1;\n}\n\nint WifiPacket::handle_assoc_request( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_CAPINFO_LEN + IEEE802_11_LISTENINT_LEN))\n        return 0;\n    pbody.capability_info = EXTRACT_LE_16BITS(p);\n    offset += IEEE802_11_CAPINFO_LEN;\n    pbody.listen_interval = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_LISTENINT_LEN;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      PRINT_SSID(pbody);\n      PRINT_RATES(pbody);\n    */\n    cbs->Handle80211MgmtAssocRequest(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint WifiPacket::handle_assoc_response( const struct mgmt_header_t *pmh, const u_char *p, size_t len, bool reassoc)\n{\n    struct mgmt_body_t pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_CAPINFO_LEN + IEEE802_11_STATUS_LEN +\n                IEEE802_11_AID_LEN))\n        return 0;\n    pbody.capability_info = EXTRACT_LE_16BITS(p);\n    offset += IEEE802_11_CAPINFO_LEN;\n    pbody.status_code = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_STATUS_LEN;\n    pbody.aid = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_AID_LEN;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      printf(\" AID(%x) :%s: %s\", ((u_int16_t)(pbody.aid << 2 )) >> 2 ,\n      CAPABILITY_PRIVACY(pbody.capability_info) ? \" PRIVACY \" : \"\",\n      (pbody.status_code < NUM_STATUSES\n      ? status_text[pbody.status_code]\n      : \"n/a\"));\n    */\n    if (!reassoc)\n        cbs->Handle80211MgmtAssocResponse(*this, pmh, &pbody);\n    else\n        cbs->Handle80211MgmtReassocResponse(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_reassoc_request( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_CAPINFO_LEN + IEEE802_11_LISTENINT_LEN +\n                IEEE802_11_AP_LEN))\n        return 0;\n    pbody.capability_info = EXTRACT_LE_16BITS(p);\n    offset += IEEE802_11_CAPINFO_LEN;\n    pbody.listen_interval = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_LISTENINT_LEN;\n    memcpy(&pbody.ap, p+offset, IEEE802_11_AP_LEN);\n    offset += IEEE802_11_AP_LEN;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      PRINT_SSID(pbody);\n      printf(\" AP : %s\", etheraddr_string( pbody.ap ));\n    */\n    cbs->Handle80211MgmtReassocRequest(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_reassoc_response( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    /* Same as a Association Reponse */\n    return handle_assoc_response(pmh, p, len, true);\n}\n\nint\nWifiPacket::handle_probe_request( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t  pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      PRINT_SSID(pbody);\n      PRINT_RATES(pbody);\n    */\n    cbs->Handle80211MgmtProbeRequest(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_probe_response( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t  pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_TSTAMP_LEN + IEEE802_11_BCNINT_LEN +\n                IEEE802_11_CAPINFO_LEN))\n        return 0;\n\n    memcpy(&pbody.timestamp, p, IEEE802_11_TSTAMP_LEN);\n    offset += IEEE802_11_TSTAMP_LEN;\n    pbody.beacon_interval = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_BCNINT_LEN;\n    pbody.capability_info = EXTRACT_LE_16BITS(p+offset);\n    offset += IEEE802_11_CAPINFO_LEN;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      PRINT_SSID(pbody);\n      PRINT_RATES(pbody);\n      PRINT_DS_CHANNEL(pbody);\n    */\n    cbs->Handle80211MgmtProbeResponse(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_atim( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    /* the frame body for ATIM is null. */\n\n    cbs->Handle80211MgmtATIM(*this, pmh);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_disassoc( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t  pbody;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_REASON_LEN))\n        return 0;\n    pbody.reason_code = EXTRACT_LE_16BITS(p);\n\n    /*\n      printf(\": %s\",\n      (pbody.reason_code < NUM_REASONS)\n      ? reason_text[pbody.reason_code]\n      : \"Reserved\" );\n    */\n    cbs->Handle80211MgmtDisassoc(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_auth( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t  pbody;\n    int offset = 0;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, 6))\n        return 0;\n    pbody.auth_alg = EXTRACT_LE_16BITS(p);\n    offset += 2;\n    pbody.auth_trans_seq_num = EXTRACT_LE_16BITS(p + offset);\n    offset += 2;\n    pbody.status_code = EXTRACT_LE_16BITS(p + offset);\n    offset += 2;\n\n    parse_elements(&pbody, p, offset, len);\n\n    /*\n      if ((pbody.auth_alg == 1) &&\n      ((pbody.auth_trans_seq_num == 2) ||\n      (pbody.auth_trans_seq_num == 3))) {\n      printf(\" (%s)-%x [Challenge Text] %s\",\n      (pbody.auth_alg < NUM_AUTH_ALGS)\n      ? auth_alg_text[pbody.auth_alg]\n      : \"Reserved\",\n      pbody.auth_trans_seq_num,\n      ((pbody.auth_trans_seq_num % 2)\n      ? ((pbody.status_code < NUM_STATUSES)\n      ? status_text[pbody.status_code]\n      : \"n/a\") : \"\"));\n      return 1;\n      }\n      printf(\" (%s)-%x: %s\",\n      (pbody.auth_alg < NUM_AUTH_ALGS)\n      ? auth_alg_text[pbody.auth_alg]\n      : \"Reserved\",\n      pbody.auth_trans_seq_num,\n      (pbody.auth_trans_seq_num % 2)\n      ? ((pbody.status_code < NUM_STATUSES)\n      ? status_text[pbody.status_code]\n      : \"n/a\")\n      : \"\");\n    */\n    cbs->Handle80211MgmtAuth(*this, pmh, &pbody);\n\n    return 1;\n}\n\nint\nWifiPacket::handle_deauth( const struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    struct mgmt_body_t  pbody;\n    int offset = 0;\n    //const char *reason = NULL;\n\n    memset(&pbody, 0, sizeof(pbody));\n\n    if (!TTEST2(*p, IEEE802_11_REASON_LEN))\n        return 0;\n    pbody.reason_code = EXTRACT_LE_16BITS(p);\n    offset += IEEE802_11_REASON_LEN;\n\n    /*\n      reason = (pbody.reason_code < NUM_REASONS)\n      ? reason_text[pbody.reason_code]\n      : \"Reserved\";\n\n      if (eflag) {\n      printf(\": %s\", reason);\n      } else {\n      printf(\" (%s): %s\", etheraddr_string(pmh->sa), reason);\n      }\n    */\n    cbs->Handle80211MgmtDeauth(*this, pmh, &pbody);\n\n    return 1;\n}\n\n\n/*********************************************************************************\n * Print Body funcs\n *********************************************************************************/\n\n\n/** Decode a management request.\n * @return 0 - failure, non-zero success\n *\n * NOTE \u2014 this function and all that it calls should be handled as methods in WifipcapCallbacks\n */\n \nint\nWifiPacket::decode_mgmt_body(u_int16_t fc, struct mgmt_header_t *pmh, const u_char *p, size_t len)\n{\n    if(debug) std::cerr << \"decode_mgmt_body FC_SUBTYPE(fc)=\"<<(int)FC_SUBTYPE(fc)<<\" \";\n    switch (FC_SUBTYPE(fc)) {\n    case ST_ASSOC_REQUEST:\n        return handle_assoc_request(pmh, p, len);\n    case ST_ASSOC_RESPONSE:\n        return handle_assoc_response(pmh, p, len);\n    case ST_REASSOC_REQUEST:\n        return handle_reassoc_request(pmh, p, len);\n    case ST_REASSOC_RESPONSE:\n        return handle_reassoc_response(pmh, p, len);\n    case ST_PROBE_REQUEST:\n        return handle_probe_request(pmh, p, len);\n    case ST_PROBE_RESPONSE:\n        return handle_probe_response(pmh, p, len);\n    case ST_BEACON:\n        return handle_beacon(pmh, p, len);\n    case ST_ATIM:\n        return handle_atim(pmh, p, len);\n    case ST_DISASSOC:\n        return handle_disassoc(pmh, p, len);\n    case ST_AUTH:\n        if (len < 3) {\n            return 0;\n        }\n        if ((p[0] == 0 ) && (p[1] == 0) && (p[2] == 0)) {\n            //printf(\"Authentication (Shared-Key)-3 \");\n            cbs->Handle80211MgmtAuthSharedKey(*this, pmh, p, len);\n            return 0;\n        }\n        return handle_auth(pmh, p, len);\n    case ST_DEAUTH:\n        return handle_deauth(pmh, p, len);\n        break;\n    default:\n        return 0;\n    }\n}\n\nint WifiPacket::decode_mgmt_frame(const u_char * ptr, size_t len, u_int16_t fc, u_int8_t hdrlen)\n{\n    mgmt_header_t hdr;\n    u_int16_t seq_ctl;\n\n    hdr.da    = MAC::ether2MAC(ptr + 4);\n    hdr.sa    = MAC::ether2MAC(ptr + 10);\n    hdr.bssid = MAC::ether2MAC(ptr + 16);\n\n    hdr.duration = EXTRACT_LE_16BITS(ptr+2);\n\n    seq_ctl   = pletohs(ptr + 22);\n\n    hdr.seq   = COOK_SEQUENCE_NUMBER(seq_ctl);\n    hdr.frag  = COOK_FRAGMENT_NUMBER(seq_ctl);\n\n    cbs->Handle80211(*this, fc, hdr.sa, hdr.da, MAC::null, MAC::null, ptr, len);\n\n    int ret = decode_mgmt_body(fc, &hdr, ptr+MGMT_HDRLEN, len-MGMT_HDRLEN);\n\n    if (ret==0) {\n\tcbs->Handle80211Unknown(*this, fc, ptr, len);\n\treturn 0;\n    }\n\n    return 0;\n}\n\nint WifiPacket::decode_data_frame(const u_char * ptr, size_t len, u_int16_t fc)\n{\n    mac_hdr_t hdr;\n    hdr.fc       = fc;\n    hdr.duration = EXTRACT_LE_16BITS(ptr+2);\n    hdr.seq_ctl  = pletohs(ptr + 22);\n    hdr.seq      = COOK_SEQUENCE_NUMBER(hdr.seq_ctl);\n    hdr.frag     = COOK_FRAGMENT_NUMBER(hdr.seq_ctl);\n\n    if(FC_TYPE(fc)==2 && FC_SUBTYPE(fc)==8){ // quality of service?\n        hdr.qos = 1;\n    }\n        \n    size_t hdrlen=0;\n\n    const MAC address1 = MAC::ether2MAC(ptr+4);\n    const MAC address2 = MAC::ether2MAC(ptr+10);\n    const MAC address3 = MAC::ether2MAC(ptr+16);\n    \n    /* call the 80211 callback data callback */\n\n    if (FC_TO_DS(fc)==0 && FC_FROM_DS(fc)==0) {\t/* ad hoc IBSS */\n\thdr.da = address1;\n\thdr.sa = address2;\n\thdr.bssid = address3;\n\thdrlen = DATA_HDRLEN;\n        if(hdr.qos) hdrlen+=2;\n        cbs->Handle80211( *this, fc, hdr.sa, hdr.da, hdr.ra, hdr.ta, ptr, len);\n\tcbs->Handle80211DataIBSS( *this, hdr, ptr+hdrlen, len-hdrlen);\n    } else if (FC_TO_DS(fc)==0 && FC_FROM_DS(fc)) { /* from AP to STA */\n        hdr.da = address1;\n        hdr.bssid = address2;\n        hdr.sa = address3;\n\thdrlen = DATA_HDRLEN;\n        if(hdr.qos) hdrlen+=2;\n        cbs->Handle80211( *this, fc, hdr.sa, hdr.da, hdr.ra, hdr.ta, ptr, len);\n\tcbs->Handle80211DataFromAP( *this, hdr, ptr+hdrlen, len-hdrlen);\n    } else if (FC_TO_DS(fc) && FC_FROM_DS(fc)==0) {\t/* frame from STA to AP */\n        hdr.bssid = address1;\n        hdr.sa = address2;\n        hdr.da = address3;\n\thdrlen = DATA_HDRLEN;\n        if(hdr.qos) hdrlen+=2;\n        cbs->Handle80211( *this, fc, hdr.sa, hdr.da, hdr.ra, hdr.ta, ptr, len);\n\tcbs->Handle80211DataToAP( *this, hdr, ptr+hdrlen, len-hdrlen);\n    } else if (FC_TO_DS(fc) && FC_FROM_DS(fc)) {\t/* WDS */\n        const MAC address4 = MAC::ether2MAC(ptr+18);\n        hdr.ra = address1;\n        hdr.ta = address2;\n        hdr.da = address3;\n        hdr.sa = address4;\n        hdrlen = DATA_WDS_HDRLEN;\n        if(hdr.qos) hdrlen+=2;\n        cbs->Handle80211( *this, fc, hdr.sa, hdr.da, hdr.ra, hdr.ta, ptr, len);\n\tcbs->Handle80211DataWDS( *this, hdr, ptr+hdrlen, len-hdrlen);\n    }\n\n    /* Handle either the WEP or the link layer. This handles the data itself */\n    if (FC_WEP(fc)) {\n        handle_wep(ptr+hdrlen, len-hdrlen-4 ); \n    } else {\n        handle_llc(hdr, ptr+hdrlen, len-hdrlen-4, fc); \n    }\n    return 0;\n}\n\nint WifiPacket::decode_ctrl_frame(const u_char * ptr, size_t len, u_int16_t fc)\n{\n    u_int16_t du = EXTRACT_LE_16BITS(ptr+2);        //duration\n\n    switch (FC_SUBTYPE(fc)) {\n    case CTRL_PS_POLL: {\n\tctrl_ps_poll_t hdr;\n\thdr.fc = fc;\n\thdr.aid = du;\n\thdr.bssid =  MAC::ether2MAC(ptr+4);\n\thdr.ta =  MAC::ether2MAC(ptr+10);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, MAC::null, hdr.ta, ptr, len);\n\tcbs->Handle80211CtrlPSPoll( *this, &hdr);\n\tbreak;\n    }\n    case CTRL_RTS: {\n\tctrl_rts_t hdr;\n\thdr.fc = fc;\n\thdr.duration = du;\n\thdr.ra =  MAC::ether2MAC(ptr+4);\n\thdr.ta =  MAC::ether2MAC(ptr+10);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, hdr.ra, hdr.ta, ptr, len);\n\tcbs->Handle80211CtrlRTS( *this, &hdr);\n\tbreak;\n    }\n    case CTRL_CTS: {\n\tctrl_cts_t hdr;\n\thdr.fc = fc;\n\thdr.duration = du;\n\thdr.ra =  MAC::ether2MAC(ptr+4);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, hdr.ra, MAC::null, ptr, len);\n\tcbs->Handle80211CtrlCTS( *this, &hdr);\n\tbreak;\n    }\n    case CTRL_ACK: {\n\tctrl_ack_t hdr;\n\thdr.fc = fc;\n\thdr.duration = du;\n\thdr.ra =  MAC::ether2MAC(ptr+4);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, hdr.ra, MAC::null, ptr, len);\n\tcbs->Handle80211CtrlAck( *this, &hdr);\n\tbreak;\n    }\n    case CTRL_CF_END: {\n\tctrl_end_t hdr;\n\thdr.fc = fc;\n\thdr.duration = du;\n\thdr.ra =  MAC::ether2MAC(ptr+4);\n\thdr.bssid =  MAC::ether2MAC(ptr+10);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, hdr.ra, MAC::null, ptr, len);\n\tcbs->Handle80211CtrlCFEnd( *this, &hdr);\n\tbreak;\n    }\n    case CTRL_END_ACK: {\t\n\tctrl_end_ack_t hdr;\n\thdr.fc = fc;\n\thdr.duration = du;\n\thdr.ra =  MAC::ether2MAC(ptr+4);\n\thdr.bssid =  MAC::ether2MAC(ptr+10);\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, hdr.ra, MAC::null, ptr, len);\n\tcbs->Handle80211CtrlEndAck( *this, &hdr);\n\tbreak;\n    }\n    default: {\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, MAC::null, MAC::null, ptr, len);\n\tcbs->Handle80211Unknown( *this, fc, ptr, len);\n\treturn -1;\n\t//add the case statements for QoS control frames once ieee802_11.h is updated\n    }\n    }\n    return 0;\n}\n\n#ifndef roundup2\n#define\troundup2(x, y)\t(((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */\n#endif\n\nvoid WifiPacket::handle_80211(const u_char * pkt, size_t len /* , int pad */)  \n{\n    if (debug) std::cerr << \"handle_80211(len= \" << len << \" \";\n    if (len < 2) {\n\tcbs->Handle80211( *this, 0, MAC::null, MAC::null, MAC::null, MAC::null, pkt, len);\n\tcbs->Handle80211Unknown( *this, -1, pkt, len);\n\treturn;\n    }\n\n    u_int16_t fc  = EXTRACT_LE_16BITS(pkt);       //frame control\n    size_t hdrlen = extract_header_length(fc);\n    /*\n      if (pad) {\n      hdrlen = roundup2(hdrlen, 4);\n      }\n    */\n\n    if (debug) std::cerr << \"FC_TYPE(fc)= \" << FC_TYPE(fc) << \" \";\n\n    if (len < IEEE802_11_FC_LEN || len < hdrlen) {\n\tcbs->Handle80211Unknown( *this, fc, pkt, len);\n\treturn;\n    }\n\n    /* Always calculate the frame checksum, but only process the packets if the FCS or if we are ignoring it */\n    if (len >= hdrlen + 4) {\n        // assume fcs is last 4 bytes (?)\n        u_int32_t fcs_sent = EXTRACT_32BITS(pkt+len-4);\n        u_int32_t fcs = crc32_802(pkt, len-4);\n        \n        /*\n          if (fcs != fcs_sent) {\n          cerr << \"bad fcs: \";\n          fprintf (stderr, \"%08x != %08x\\n\", fcs_sent, fcs); \n          }\n        */\n\t\n        fcs_ok = (fcs == fcs_sent);\n    }\n    if (cbs->Check80211FCS(*this) && fcs_ok==false){\n        cbs->Handle80211Unknown(*this,fc,pkt,len);\n        return;\n    }\n\n\n    // fill in current_frame: type, sn\n    switch (FC_TYPE(fc)) {\n    case T_MGMT:\n\tif(decode_mgmt_frame(pkt, len, fc, hdrlen)<0)\n\t    return;\n\tbreak;\n    case T_DATA:\n\tif(decode_data_frame(pkt, len, fc)<0)\n\t    return;\n\tbreak;\n    case T_CTRL:\n\tif(decode_ctrl_frame(pkt, len, fc)<0)\n\t    return;\n\tbreak;\n    default:\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, MAC::null, MAC::null, pkt, len);\n\tcbs->Handle80211Unknown( *this, fc, pkt, len);\n\treturn;\n    }\n}\n\nint WifiPacket::print_radiotap_field(struct cpack_state *s, u_int32_t bit, int *pad, radiotap_hdr *hdr)\n{\n    union {\n        int8_t\t\ti8;\n        u_int8_t\tu8;\n        int16_t\t\ti16;\n        u_int16_t\tu16;\n        u_int32_t\tu32;\n        u_int64_t\tu64;\n    } u, u2, u3;\n    int rc;\n\n    switch (bit) {\n    case IEEE80211_RADIOTAP_FLAGS:\n        rc = cpack_uint8(s, &u.u8);\n        if (u.u8 & IEEE80211_RADIOTAP_F_DATAPAD)\n            *pad = 1;\n        break;\n    case IEEE80211_RADIOTAP_RATE:\n    case IEEE80211_RADIOTAP_DB_ANTSIGNAL:\n    case IEEE80211_RADIOTAP_DB_ANTNOISE:\n    case IEEE80211_RADIOTAP_ANTENNA:\n        rc = cpack_uint8(s, &u.u8);\n        break;\n    case IEEE80211_RADIOTAP_DBM_ANTSIGNAL:\n    case IEEE80211_RADIOTAP_DBM_ANTNOISE:\n        rc = cpack_int8(s, &u.i8);\n        break;\n    case IEEE80211_RADIOTAP_CHANNEL:\n        rc = cpack_uint16(s, &u.u16);\n        if (rc != 0)\n            break;\n        rc = cpack_uint16(s, &u2.u16);\n        break;\n    case IEEE80211_RADIOTAP_FHSS:\n    case IEEE80211_RADIOTAP_LOCK_QUALITY:\n    case IEEE80211_RADIOTAP_TX_ATTENUATION:\n        rc = cpack_uint16(s, &u.u16);\n        break;\n    case IEEE80211_RADIOTAP_DB_TX_ATTENUATION:\n        rc = cpack_uint8(s, &u.u8);\n        break;\n    case IEEE80211_RADIOTAP_DBM_TX_POWER:\n        rc = cpack_int8(s, &u.i8);\n        break;\n    case IEEE80211_RADIOTAP_TSFT:\n        rc = cpack_uint64(s, &u.u64);\n        break;\n    case IEEE80211_RADIOTAP_RX_FLAGS:\n        rc = cpack_uint16(s, &u.u16);\n        break;\n    case IEEE80211_RADIOTAP_TX_FLAGS:\n        rc = cpack_uint16(s, &u.u16);\n        break;\n    case IEEE80211_RADIOTAP_RTS_RETRIES:\n        rc = cpack_uint8(s, &u.u8);\n        break;\n    case IEEE80211_RADIOTAP_DATA_RETRIES:\n        rc = cpack_uint8(s, &u.u8);\n        break;\n        // simson add follows:\n    case IEEE80211_RADIOTAP_XCHANNEL:\n        rc = cpack_uint8(s, &u.u8);      // simson guess\n        break;\n    case IEEE80211_RADIOTAP_MCS:\n        rc = cpack_uint8(s, &u.u8) || cpack_uint8(s, &u2.u8) || cpack_uint8(s, &u3.u8);      // simson guess\n        break;\n        // simson end\n    default:\n        /* this bit indicates a field whose\n         * size we do not know, so we cannot\n         * proceed.\n         */\n        //printf(\"[0x%08x] \", bit);\n        fprintf(stderr, \"wifipcap: unknown radiotap bit: %d (%d)\\n\", bit,IEEE80211_RADIOTAP_XCHANNEL);\n        return  -1 ;\n    }\n\n    if (rc != 0) {\n        //printf(\"[|802.11]\");\n        fprintf(stderr, \"wifipcap: truncated radiotap header for bit: %d\\n\", bit);\n        return  rc ;\n    }\n\n    switch (bit) {\n    case IEEE80211_RADIOTAP_CHANNEL:\n        //printf(\"%u MHz \", u.u16);\n        if (u2.u16 != 0)\n            //printf(\"(0x%04x) \", u2.u16);\n            hdr->has_channel = true;\n        hdr->channel = u2.u16;\n        break;\n    case IEEE80211_RADIOTAP_FHSS:\n        //printf(\"fhset %d fhpat %d \", u.u16 & 0xff, (u.u16 >> 8) & 0xff);\n        hdr->has_fhss = true;\n        hdr->fhss_fhset = u.u16 & 0xff;\n        hdr->fhss_fhpat = (u.u16 >> 8) & 0xff;\n        break;\n    case IEEE80211_RADIOTAP_RATE:\n        //PRINT_RATE(\"\", u.u8, \" Mb/s \");\n        hdr->has_rate = true;\n        hdr->rate = u.u8;\n        break;\n    case IEEE80211_RADIOTAP_DBM_ANTSIGNAL:\n        //printf(\"%ddB signal \", u.i8);\n        hdr->has_signal_dbm = true;\n        hdr->signal_dbm = u.i8;\n        break;\n    case IEEE80211_RADIOTAP_DBM_ANTNOISE:\n        //printf(\"%ddB noise \", u.i8);\n        hdr->has_noise_dbm = true;\n        hdr->noise_dbm = u.i8;\n        break;\n    case IEEE80211_RADIOTAP_DB_ANTSIGNAL:\n        //printf(\"%ddB signal \", u.u8);\n        hdr->has_signal_db = true;\n        hdr->signal_db = u.u8;\n        break;\n    case IEEE80211_RADIOTAP_DB_ANTNOISE:\n        //printf(\"%ddB noise \", u.u8);\n        hdr->has_noise_db = true;\n        hdr->noise_db = u.u8;\n        break;\n    case IEEE80211_RADIOTAP_LOCK_QUALITY:\n        //printf(\"%u sq \", u.u16);\n        hdr->has_quality = true;\n        hdr->quality = u.u16;\n        break;\n    case IEEE80211_RADIOTAP_TX_ATTENUATION:\n        //printf(\"%d tx power \", -(int)u.u16);\n        hdr->has_txattenuation = true;\n        hdr->txattenuation = -(int)u.u16;\n        break;\n    case IEEE80211_RADIOTAP_DB_TX_ATTENUATION:\n        //printf(\"%ddB tx power \", -(int)u.u8);\n        hdr->has_txattenuation_db = true;\n        hdr->txattenuation_db = -(int)u.u8;\n        break;\n    case IEEE80211_RADIOTAP_DBM_TX_POWER:\n        //printf(\"%ddBm tx power \", u.i8);\n        hdr->has_txpower_dbm = true;\n        hdr->txpower_dbm = u.i8;\n        break;\n    case IEEE80211_RADIOTAP_FLAGS:\n        hdr->has_flags = true;\n        if (u.u8 & IEEE80211_RADIOTAP_F_CFP)\n            //printf(\"cfp \");\n            hdr->flags_cfp = true;\n        if (u.u8 & IEEE80211_RADIOTAP_F_SHORTPRE)\n            //printf(\"short preamble \");\n            hdr->flags_short_preamble = true;\n        if (u.u8 & IEEE80211_RADIOTAP_F_WEP)\n            //printf(\"wep \");\n            hdr->flags_wep = true;\n        if (u.u8 & IEEE80211_RADIOTAP_F_FRAG)\n            //printf(\"fragmented \");\n            hdr->flags_fragmented = true;\n        if (u.u8 & IEEE80211_RADIOTAP_F_BADFCS)\n            //printf(\"bad-fcs \");\n            hdr->flags_badfcs = true;\n        break;\n    case IEEE80211_RADIOTAP_ANTENNA:\n        //printf(\"antenna %d \", u.u8);\n        hdr->has_antenna = true;\n        hdr->antenna = u.u8;\n        break;\n    case IEEE80211_RADIOTAP_TSFT:\n        //printf(\"%\" PRIu64 \"us tsft \", u.u64);\n        hdr->has_tsft = true;\n        hdr->tsft = u.u64;\n        break;\n    case IEEE80211_RADIOTAP_RX_FLAGS:\n        hdr->has_rxflags = true;\n        hdr->rxflags = u.u16;\n        break;\n    case IEEE80211_RADIOTAP_TX_FLAGS:\n        hdr->has_txflags = true;\n        hdr->txflags = u.u16;\n        break;\n    case IEEE80211_RADIOTAP_RTS_RETRIES:\n        hdr->has_rts_retries = true;\n        hdr->rts_retries = u.u8;\n        break;\n    case IEEE80211_RADIOTAP_DATA_RETRIES:\n        hdr->has_data_retries = true;\n        hdr->data_retries = u.u8;\n        break;\n    }\n    return  0 ;\n}\n\n\n\nvoid WifiPacket::handle_radiotap(const u_char *p,size_t caplen)\n{\n#define\tBITNO_32(x) (((x) >> 16) ? 16 + BITNO_16((x) >> 16) : BITNO_16((x)))\n#define\tBITNO_16(x) (((x) >> 8) ? 8 + BITNO_8((x) >> 8) : BITNO_8((x)))\n#define\tBITNO_8(x) (((x) >> 4) ? 4 + BITNO_4((x) >> 4) : BITNO_4((x)))\n#define\tBITNO_4(x) (((x) >> 2) ? 2 + BITNO_2((x) >> 2) : BITNO_2((x)))\n#define\tBITNO_2(x) (((x) & 2) ? 1 : 0)\n#define\tBIT(n)\t(1 << n)\n#define\tIS_EXTENDED(__p) (EXTRACT_LE_32BITS(__p) & BIT(IEEE80211_RADIOTAP_EXT)) != 0\n\n    // If caplen is too small, just give it a try and carry on.\n    if (caplen < sizeof(struct ieee80211_radiotap_header)) {\n        cbs->HandleRadiotap( *this, NULL, p, caplen);\n        return;\n    }\n\n    struct ieee80211_radiotap_header *hdr = (struct ieee80211_radiotap_header *)p;\n\n    size_t len = EXTRACT_LE_16BITS(&hdr->it_len); // length of radiotap header\n\n    if (caplen < len) {\n        //printf(\"[|802.11]\");\n        cbs->HandleRadiotap( *this, NULL, p, caplen);\n        return;// caplen;\n    }\n    uint32_t *last_presentp=0;\n    for (last_presentp = &hdr->it_present;\n         IS_EXTENDED(last_presentp) && (u_char*)(last_presentp + 1) <= p + len;\n         last_presentp++){\n    }\n\n    /* are there more bitmap extensions than bytes in header? */\n    if (IS_EXTENDED(last_presentp)) {\n        //printf(\"[|802.11]\");\n        cbs->HandleRadiotap( *this, NULL, p, caplen);\n        return;// caplen;\n    }\n\n    const u_char *iter = (u_char*)(last_presentp + 1);\n    struct cpack_state cpacker;\n    if (cpack_init(&cpacker, (u_int8_t*)iter, len - (iter - p)) != 0) {\n        /* XXX */\n        //printf(\"[|802.11]\");\n        cbs->HandleRadiotap( *this, NULL, p, caplen);\n        return;// caplen;\n    }\n\n    radiotap_hdr ohdr;\n    memset(&ohdr, 0, sizeof(ohdr));\n\t\n    /* Assume no Atheros padding between 802.11 header and body */\n    int pad = 0;\n    uint32_t *presentp;\n    int bit0=0;\n    for (bit0 = 0, presentp = &hdr->it_present; presentp <= last_presentp;\n         presentp++, bit0 += 32) {\n\n        u_int32_t present, next_present;\n        for (present = EXTRACT_LE_32BITS(presentp); present;\n             present = next_present) {\n            /* clear the least significant bit that is set */\n            next_present = present & (present - 1);\n\n            /* extract the least significant bit that is set */\n            enum ieee80211_radiotap_type bit = (enum ieee80211_radiotap_type)\n                (bit0 + BITNO_32(present ^ next_present));\n\n            /* print the next radiotap field */\n            int r = print_radiotap_field(&cpacker, bit, &pad, &ohdr);\n\n            /* If we got an error, break both loops */\n            if(r!=0) goto done;\n        }\n    }\ndone:;\n    cbs->HandleRadiotap( *this, &ohdr, p, caplen);\n    //return len + ieee802_11_print(p + len, length - len, caplen - len, pad);\n#undef BITNO_32\n#undef BITNO_16\n#undef BITNO_8\n#undef BITNO_4\n#undef BITNO_2\n#undef BIT\n    handle_80211(p+len, caplen-len);\n}\n\nvoid WifiPacket::handle_prism(const u_char *pc, size_t len)\n{\n    prism2_pkthdr hdr;\n\n    /* get the fields */\n    if (len>=144){\n        hdr.host_time \t= EXTRACT_LE_32BITS(pc+32);\n        hdr.mac_time \t= EXTRACT_LE_32BITS(pc+44);\n        hdr.channel \t= EXTRACT_LE_32BITS(pc+56);\n        hdr.rssi \t\t= EXTRACT_LE_32BITS(pc+68);\n        hdr.sq \t\t= EXTRACT_LE_32BITS(pc+80);\n        hdr.signal  \t= EXTRACT_LE_32BITS(pc+92);\n        hdr.noise   \t= EXTRACT_LE_32BITS(pc+104);\n        hdr.rate\t\t= EXTRACT_LE_32BITS(pc+116)/2;\n        hdr.istx\t\t= EXTRACT_LE_32BITS(pc+128);\n        cbs->HandlePrism( *this, &hdr, pc + 144, len - 144);\n        handle_80211(pc+144,len-144);\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n///\n/// handle_*:\n/// handle each of the packet types\n///\n\n/// 2018-08-02: slg - I'm not sure why this is commented out.\nvoid WifiPacket::handle_ether(const u_char *ptr, size_t len)\n{\n#if 0\n    ether_hdr_t hdr;\n\n    hdr.da = MAC::ether2MAC(ptr);\n    hdr.sa = MAC::ether2MAC(ptr+6);\n    hdr.type = EXTRACT_16BITS(ptr + 12);\n\n    ptr += 14;\n    len -= 14;\n\n    cbs->HandleEthernet(*this, &hdr, ptr, len);\n\n    switch (hdr.type) {\n    case ETHERTYPE_IP:\n\thandle_ip(ptr, len);\n\treturn;\n    case ETHERTYPE_IPV6:\n\thandle_ip6(ptr, len);\n\treturn;\n    case ETHERTYPE_ARP:\n\thandle_arp( ptr, len);\n\treturn;\n    default:\n\tcbs->HandleL2Unknown(*this, hdr.type, ptr, len);\n\treturn;\n    }\n#endif\n}\n\n///////////////////////////////////////////////////////////////////////////////\n/* These are all static functions */\n#if 0\nvoid Wifipcap::dl_prism(const PcapUserData &data, const struct pcap_pkthdr *header, const u_char * packet)\n{\n    WifipcapCallbacks *cbs = data.cbs;\n\n    if(header->caplen < 144) return;    // prism header\n\n    cbs->PacketBegin( packet, header->caplen, header->len);\n    handle_prism(cbs,packet+144,header->caplen-144);\n    cbs->PacketEnd();\n}\n\nvoid Wifipcap::dl_prism(u_char *user, const struct pcap_pkthdr *header, const u_char * packet)\n{\n    PcapUserData *data = reinterpret_cast<PcapUserData *>(user);\n    Wifipcap::dl_prism(*data,header,packet);\n}\n#endif\n\n#if 0\nvoid Wifipcap::dl_ieee802_11_radio(const PcapUserData &data, const struct pcap_pkthdr *header,\n                                   const u_char * packet)\n{\n\n    data.cbs->PacketBegin( packet, header->caplen, header->len);\n    handle_radiotap(packet, header->caplen);\n    data.cbs->PacketEnd();\n}\n#endif\n\nvoid Wifipcap::dl_ieee802_11_radio(const u_char *user, const struct pcap_pkthdr *header, const u_char * packet)\n{\n    const PcapUserData *data = reinterpret_cast<const PcapUserData *>(user);\n    WifiPacket pkt(data->cbs,data->header_type,header,packet);\n\n    data->cbs->PacketBegin(pkt,packet,header->caplen,header->len);\n    pkt.handle_radiotap(packet,header->caplen);\n    data->cbs->PacketEnd(pkt);\n\n    //Wifipcap::dl_ieee802_11_radio(*data,header,packet);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n/* None of these are used in tcpflow */\n\nbool Wifipcap::InitNext()\n{\n    if (morefiles.size() < 1){\n\treturn false;\n    }\n    if (descr) {\n        pcap_close(descr);\n    }\n    Init(morefiles.front(), false);\n    morefiles.pop_front();\n    return true;\n}\n\nvoid Wifipcap::Init(const char *name, bool live) {\n    if (verbose){\n        std::cerr << \"wifipcap: initializing '\" << name << \"'\" << std::endl;\n    }\n\n    if (!live) {\n#ifdef _WIN32\n\tstd::cerr << \"Trace replay is unsupported in windows.\" << std::endl;\n\texit(1);\n#else\n\t// mini hack: handle gziped files since all our traces are in\n\t// this format\n\tint slen = strlen(name);\n\n\tbool gzip = !strcmp(name+slen-3, \".gz\");\n\tbool bzip = !strcmp(name+slen-4, \".bz2\");\n\t\n\tchar cmd[256];\n\tchar errbuf[256];\n\tif (gzip) \n\t    sprintf(cmd, \"zcat %s\", name);\n\telse if (bzip)\n\t    sprintf(cmd, \"bzcat %s\", name);\n\telse\n\t    // using cat here instead of pcap_open or fopen is intentional\n\t    // neither of these may be able to handle large files (>2GB files)\n\t    // but cat uses the linux routines to allow it to\n\t    sprintf(cmd, \"cat %s\", name);\n\n\tFILE *pipe = popen(cmd, \"r\");\n\tif (pipe == NULL) {\n\t    printf(\"popen(): %s\\n\", strerror(errno));\n\t    exit(1);\n\t}\n\tdescr = pcap_fopen_offline(pipe, errbuf);\n\n        if(descr == NULL) {\n            printf(\"pcap_open_offline(): %s\\n\", errbuf);\n            exit(1);\n        }\n#endif\n    } else {\n\tchar errbuf[256];\n\tdescr = pcap_open_live(name,BUFSIZ,1,-1,errbuf);\n        if(descr == NULL) {\n            printf(\"pcap_open_live(): %s\\n\", errbuf);\n            exit(1);\n        }\n    }\n\n    datalink = pcap_datalink(descr);\n    if (datalink != DLT_PRISM_HEADER && datalink != DLT_IEEE802_11_RADIO && datalink != DLT_IEEE802_11) {\n\tif (datalink == DLT_EN10MB) {\n\t    printf(\"warning: ethernet datalink type: %s\\n\",\n\t\t   pcap_datalink_val_to_name(datalink));\n\t} else {\n\t    printf(\"warning: unrecognized datalink type: %s\\n\",\n\t\t   pcap_datalink_val_to_name(datalink));\n\t}\n    }\n}\n\n\n\n\n/* object-oriented version of pcap callback. Called with the callbacks object,\n * the DLT type, the header and the packet.\n * This is the main packet processor.\n * It records some stats and then dispatches to the appropriate callback.\n */\nvoid Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,\n                             const struct pcap_pkthdr *header, const u_char * packet) \n{\n    /* Record start time if we don't have it */\n    if (startTime == TIME_NONE) {\n\tstartTime = header->ts;\n\tlastPrintTime = header->ts;\n    }\n    /* Print stats if necessary */\n    if (header->ts.tv_sec > lastPrintTime.tv_sec + Wifipcap::PRINT_TIME_INTERVAL) {\n\tif (verbose) {\n\t    int hours = (header->ts.tv_sec - startTime.tv_sec)/3600;\n\t    int days  = hours/24;\n\t    int left  = hours%24;\n\t    fprintf(stderr, \"wifipcap: %2d days %2d hours, %10\" PRId64 \" pkts\\n\", \n\t\t    days, left, packetsProcessed);\n\t}\n\tlastPrintTime = header->ts;\n    }\n    packetsProcessed++;\n\n    /* Create the packet object and call the appropriate callbacks */\n    WifiPacket pkt(cbs,header_type,header,packet);\n\n    /* Notify callback */\n    cbs->PacketBegin(pkt, packet, header->caplen, header->len);\n    //int frameLen = header->caplen;\n    switch(header_type) {\n    case DLT_PRISM_HEADER:\n        pkt.handle_prism(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11_RADIO:\n        pkt.handle_radiotap(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11:\n        pkt.handle_80211(packet,header->caplen);\n        break;\n    case DLT_EN10MB:\n        pkt.handle_ether(packet,header->caplen);\n        break;\n    default:\n#if 0\n        /// 2018-08-02: slg - I'm also not sure why this is commented out.\n\t// try handling it as default IP assuming framing is ethernet \n\t// (this is for testing)\n        pkt.handle_ip(packet,header->caplen);\n#endif\n        break;\n    }\n    cbs->PacketEnd(pkt);\n}\n\n\n/* The raw callback from pcap; jump back into the object-oriented domain */\n/* note: u_char *user may not be const according to spec */\nvoid Wifipcap::handle_packet_callback(u_char *user, const struct pcap_pkthdr *header, const u_char * packet)\n{\n    Wifipcap::PcapUserData *data = reinterpret_cast<Wifipcap::PcapUserData *>(user);\n    data->wcap->handle_packet(data->cbs,data->header_type,header,packet);\n}\n    \n\nconst char *Wifipcap::SetFilter(const char *filter)\n{\n    struct bpf_program fp;\n#ifdef PCAP_NETMASK_UNKNOWN\n    bpf_u_int32 netp=PCAP_NETMASK_UNKNOWN;\n#else\n    bpf_u_int32 netp=0;\n#endif\n\n\n    if(pcap_compile(descr,&fp,(char *)filter,0,netp) == -1) { \n\treturn \"Error calling pcap_compile\"; \n    }\n    \n    if(pcap_setfilter(descr,&fp) == -1) { \n\treturn \"Error setting filter\"; \n    }\n\n    return NULL;\n}\n\n\nvoid Wifipcap::Run(WifipcapCallbacks *cbs, int maxpkts)\n{\n    /* NOTE: This needs to be fixed so that the correct handle_packet is called  */\n\n    packetsProcessed = 0;\n    \n    do {\n\tPcapUserData data(this,cbs,DLT_IEEE802_11_RADIO);\n\tpcap_loop(descr, maxpkts > 0 ? maxpkts - packetsProcessed : 0,\n\t\t  Wifipcap::handle_packet_callback, reinterpret_cast<u_char *>(&data));\n    } while ( InitNext() );\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n\n"], "filenames": ["src/wifipcap/wifipcap.cpp"], "buggy_code_start_loc": [1495], "buggy_code_end_loc": [1717], "fixing_code_start_loc": [1495], "fixing_code_end_loc": [1722], "type": "CWE-125", "message": "An issue was discovered in wifipcap/wifipcap.cpp in TCPFLOW through 1.5.0-alpha. There is an integer overflow in the function handle_prism during caplen processing. If the caplen is less than 144, one can cause an integer overflow in the function handle_80211, which will result in an out-of-bounds read and may allow access to sensitive memory (or a denial of service).", "other": {"cve": {"id": "CVE-2018-14938", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-05T03:29:00.217", "lastModified": "2020-11-29T02:15:10.640", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in wifipcap/wifipcap.cpp in TCPFLOW through 1.5.0-alpha. There is an integer overflow in the function handle_prism during caplen processing. If the caplen is less than 144, one can cause an integer overflow in the function handle_80211, which will result in an out-of-bounds read and may allow access to sensitive memory (or a denial of service)."}, {"lang": "es", "value": "Se ha descubierto un problema en wifipcap/wifipcap.cpp en TCPFLOW hasta la versi\u00f3n 1.5.0-alpha. Hay un desbordamiento de enteros en la funci\u00f3n handle_prism durante el procesamiento de caplen. Si el caplen es menor que 144, se puede provocar un desbordamiento de enteros en la funci\u00f3n handle_80211, lo que resultar\u00e1 en una lectura fuera de l\u00edmites y podr\u00eda permitir el acceso a memoria sensible (o una denegaci\u00f3n de servicio)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:digitalcorpora:tcpflow:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4.5", "matchCriteriaId": "AEF9B14F-E5C7-452B-BC94-47B7F1B23FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:digitalcorpora:tcpflow:1.5.0:alpha:*:*:*:*:*:*", "matchCriteriaId": "5E324982-69EB-49BF-B37D-E1BBB998DEBD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "https://github.com/simsong/tcpflow/commit/a4e1cd14eb5ccc51ed271b65b3420f7d692c40eb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/simsong/tcpflow/issues/182", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/11/msg00046.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3955-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/simsong/tcpflow/commit/a4e1cd14eb5ccc51ed271b65b3420f7d692c40eb"}}