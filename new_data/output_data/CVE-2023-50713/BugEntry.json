{"buggy_code": ["<template>\n  <LayoutDialog\n    v-model:open=\"isOpen\"\n    max-width=\"sm\"\n    :buttons=\"dialogButtons\"\n    prevent-close-on-click-outside\n  >\n    <template #header>\n      {{ props.application ? 'Edit Application' : 'Create Application' }}\n    </template>\n    <form @submit=\"onSubmit\">\n      <div class=\"flex flex-col gap-6\">\n        <FormTextInput\n          v-model=\"name\"\n          label=\"Name\"\n          help=\"The name of your app\"\n          name=\"hookName\"\n          show-required\n          :rules=\"[isRequired]\"\n          show-label\n          type=\"text\"\n        />\n        <FormSelectBadges\n          v-model=\"scopes\"\n          multiple\n          name=\"scopes\"\n          label=\"Scopes\"\n          placeholder=\"Choose Scopes\"\n          help=\"It's good practice to limit the scopes of your token to the absolute minimum.\"\n          show-required\n          :rules=\"[isItemSelected]\"\n          show-label\n          :items=\"applicationScopes\"\n          by=\"id\"\n        />\n        <FormTextInput\n          v-model=\"redirectUrl\"\n          label=\"Redirect URL\"\n          help=\"After authentication, the users will be redirected (together with an access token) to this URL.\"\n          show-required\n          name=\"redirectUrl\"\n          show-label\n          :rules=\"[isRequired, isUrl]\"\n          type=\"text\"\n        />\n        <FormTextInput\n          v-model=\"description\"\n          label=\"Description\"\n          help=\"A short description of your application.\"\n          name=\"description\"\n          show-label\n          type=\"text\"\n        />\n      </div>\n    </form>\n  </LayoutDialog>\n</template>\n\n<script setup lang=\"ts\">\nimport { useMutation } from '@vue/apollo-composable'\nimport { AllScopes } from '@speckle/shared'\nimport { LayoutDialog, FormSelectBadges } from '@speckle/ui-components'\nimport type {\n  ApplicationFormValues,\n  ApplicationItem\n} from '~~/lib/developer-settings/helpers/types'\nimport {\n  createApplicationMutation,\n  editApplicationMutation\n} from '~~/lib/developer-settings/graphql/mutations'\nimport { isItemSelected } from '~~/lib/common/helpers/validation'\nimport { useForm } from 'vee-validate'\nimport {\n  convertThrowIntoFetchResult,\n  getCacheId,\n  getFirstErrorMessage\n} from '~~/lib/common/helpers/graphql'\nimport { useGlobalToast, ToastNotificationType } from '~~/lib/common/composables/toast'\nimport { isRequired, isUrl, fullyResetForm } from '~~/lib/common/helpers/validation'\nimport { useServerInfoScopes } from '~~/lib/common/composables/serverInfo'\n\nconst props = defineProps<{\n  application?: ApplicationItem\n}>()\n\nconst emit = defineEmits<{\n  (e: 'application-created', applicationId: string): void\n}>()\n\nconst isOpen = defineModel<boolean>('open', { required: true })\n\nconst { scopes: allScopes } = useServerInfoScopes()\nconst { mutate: createApplication } = useMutation(createApplicationMutation)\nconst { mutate: editApplication } = useMutation(editApplicationMutation)\nconst { triggerNotification } = useGlobalToast()\nconst { handleSubmit, resetForm } = useForm<ApplicationFormValues>()\n\nconst name = ref('')\nconst scopes = ref<typeof applicationScopes.value>([])\nconst redirectUrl = ref('')\nconst description = ref('')\n\nconst applicationScopes = computed(() => {\n  return Object.values(AllScopes).map((value) => ({\n    id: value,\n    text: value\n  }))\n})\n\nconst onSubmit = handleSubmit(async (applicationFormValues) => {\n  const applicationId = props.application?.id\n\n  if (props.application) {\n    const usedScopeIds = applicationFormValues.scopes.map((t) => t.id)\n    const result = await editApplication(\n      {\n        app: {\n          id: props.application.id,\n          name: name.value,\n          scopes: applicationFormValues.scopes.map((t) => t.id),\n          redirectUrl: redirectUrl.value,\n          description: description.value\n        }\n      },\n      {\n        update: (cache, { data }) => {\n          if (applicationId && data?.appUpdate) {\n            cache.modify({\n              id: getCacheId('ServerApp', applicationId),\n              fields: {\n                redirectUrl: () => applicationFormValues.redirectUrl,\n                description: () => description.value || '',\n                scopes: () =>\n                  allScopes.value.filter((t) => usedScopeIds.includes(t.name)),\n                name: () => name.value\n              }\n            })\n          }\n        }\n      }\n    ).catch(convertThrowIntoFetchResult)\n\n    if (result?.data?.appUpdate) {\n      isOpen.value = false\n      resetFormFields()\n      triggerNotification({\n        type: ToastNotificationType.Success,\n        title: 'Application updated',\n        description: 'The application has been successfully updated'\n      })\n    } else {\n      const errorMessage = getFirstErrorMessage(result?.errors)\n      triggerNotification({\n        type: ToastNotificationType.Danger,\n        title: 'Failed to update application',\n        description: errorMessage\n      })\n    }\n  } else {\n    const result = await createApplication({\n      app: {\n        name: name.value,\n        scopes: applicationFormValues.scopes.map((t) => t.id),\n        redirectUrl: redirectUrl.value,\n        description: description.value\n      }\n    }).catch(convertThrowIntoFetchResult)\n\n    if (result?.data?.appCreate) {\n      isOpen.value = false\n      resetFormFields()\n      emit('application-created', result.data.appCreate)\n      triggerNotification({\n        type: ToastNotificationType.Success,\n        title: 'Application created',\n        description: 'The application has been successfully created'\n      })\n    } else {\n      const errorMessage = getFirstErrorMessage(result?.errors)\n      triggerNotification({\n        type: ToastNotificationType.Danger,\n        title: 'Failed to create application',\n        description: errorMessage\n      })\n    }\n  }\n})\n\nconst dialogButtons = computed(() => [\n  {\n    text: 'Cancel',\n    props: { color: 'secondary', fullWidth: true, outline: true },\n    onClick: () => {\n      isOpen.value = false\n    }\n  },\n  {\n    text: props.application ? 'Save' : 'Create',\n    props: { color: 'primary', fullWidth: true },\n    onClick: onSubmit\n  }\n])\n\nconst resetApplicationModel = () => {\n  if (props.application) {\n    name.value = props.application.name\n    scopes.value = (props.application.scopes || []).map((scope) => ({\n      id: scope.name as (typeof AllScopes)[number],\n      text: scope.name as (typeof AllScopes)[number]\n    }))\n    redirectUrl.value = props.application.redirectUrl\n    description.value = props.application.description || ''\n  } else {\n    resetFormFields()\n  }\n}\n\nconst resetFormFields = () => {\n  name.value = ''\n  scopes.value = []\n  redirectUrl.value = ''\n  description.value = ''\n  fullyResetForm(resetForm)\n}\n\nwatch(\n  () => isOpen.value,\n  (newVal) => {\n    if (newVal) {\n      resetApplicationModel()\n    }\n  }\n)\n</script>\n", "<template>\n  <LayoutDialog\n    v-model:open=\"isOpen\"\n    max-width=\"sm\"\n    :buttons=\"dialogButtons\"\n    prevent-close-on-click-outside\n  >\n    <template #header>Create Token</template>\n    <form @submit=\"onSubmit\">\n      <div class=\"flex flex-col gap-6\">\n        <FormTextInput\n          v-model=\"name\"\n          label=\"Name\"\n          help=\"A name to remember this token by. For example, the name of the script or application you're planning to use it in!\"\n          name=\"hookName\"\n          :rules=\"[isRequired]\"\n          show-required\n          show-label\n          type=\"text\"\n        />\n        <FormSelectBadges\n          v-model=\"scopes\"\n          multiple\n          name=\"scopes\"\n          label=\"Scopes\"\n          placeholder=\"Choose Scopes\"\n          help=\"It's good practice to limit the scopes of your token to the absolute minimum. For example, if your application or script will only read and write streams, select just those scopes.\"\n          show-required\n          :rules=\"[isItemSelected]\"\n          show-label\n          :items=\"apiTokenScopes\"\n          mount-menu-on-body\n          by=\"id\"\n        />\n      </div>\n    </form>\n  </LayoutDialog>\n</template>\n\n<script setup lang=\"ts\">\nimport { useMutation } from '@vue/apollo-composable'\nimport { AllScopes } from '@speckle/shared'\nimport { LayoutDialog, FormSelectBadges } from '@speckle/ui-components'\nimport type { TokenFormValues } from '~~/lib/developer-settings/helpers/types'\nimport { createAccessTokenMutation } from '~~/lib/developer-settings/graphql/mutations'\nimport { isItemSelected, isRequired } from '~~/lib/common/helpers/validation'\nimport { useForm } from 'vee-validate'\nimport {\n  convertThrowIntoFetchResult,\n  getFirstErrorMessage\n} from '~~/lib/common/helpers/graphql'\nimport { useGlobalToast, ToastNotificationType } from '~~/lib/common/composables/toast'\n\nconst emit = defineEmits<{\n  (e: 'token-created', tokenId: string): void\n}>()\n\nconst { mutate: createToken } = useMutation(createAccessTokenMutation)\nconst { triggerNotification } = useGlobalToast()\nconst { handleSubmit } = useForm<TokenFormValues>()\n\nconst isOpen = defineModel<boolean>('open', { required: true })\n\nconst name = ref('')\nconst scopes = ref<typeof apiTokenScopes.value>([])\n\nconst apiTokenScopes = computed(() => {\n  return Object.values(AllScopes).map((value) => ({\n    id: value,\n    text: value\n  }))\n})\n\nconst onSubmit = handleSubmit(async (tokenFormValues) => {\n  const result = await createToken({\n    token: {\n      name: name.value,\n      scopes: tokenFormValues.scopes.map((t) => t.id)\n    }\n  }).catch(convertThrowIntoFetchResult)\n\n  if (result?.data?.apiTokenCreate) {\n    isOpen.value = false\n    resetFormFields()\n    emit('token-created', result.data.apiTokenCreate)\n    triggerNotification({\n      type: ToastNotificationType.Success,\n      title: 'Webhook created',\n      description: 'The webhook has been successfully created'\n    })\n  } else {\n    const errorMessage = getFirstErrorMessage(result?.errors)\n    triggerNotification({\n      type: ToastNotificationType.Danger,\n      title: 'Failed to create token',\n      description: errorMessage\n    })\n  }\n})\n\nconst dialogButtons = computed(() => [\n  {\n    text: 'Cancel',\n    props: { color: 'secondary', fullWidth: true, outline: true },\n    onClick: () => {\n      isOpen.value = false\n    }\n  },\n  {\n    text: 'Create',\n    props: { color: 'primary', fullWidth: true },\n    onClick: onSubmit\n  }\n])\n\nconst resetFormFields = () => {\n  name.value = ''\n  scopes.value = []\n}\n\nwatch(\n  () => isOpen.value,\n  (newVal) => {\n    if (newVal) {\n      resetFormFields()\n    }\n  }\n)\n</script>\n", "import { BaseError } from '@/modules/shared/errors/base'\n\nexport class UserUpdateError extends BaseError {\n  static defaultMessage = 'An issue occurred while attempting to update a user'\n  static code = 'USER_UPDATE_ERROR'\n}\n\nexport class UserValidationError extends BaseError {\n  static defaultMessage = 'The user input data is invalid'\n  static code = 'USER_VALIDATION_ERROR'\n}\n", "'use strict'\n\nconst { ForbiddenError } = require('apollo-server-express')\nconst {\n  createPersonalAccessToken,\n  revokeToken,\n  getUserTokens\n} = require('../../services/tokens')\nconst { canCreateToken } = require('@/modules/core/helpers/token')\n\n/** @type {import('@/modules/core/graph/generated/graphql').Resolvers} */\nconst resolvers = {\n  Query: {},\n  User: {\n    async apiTokens(parent, args, context) {\n      // TODO!\n      if (parent.id !== context.userId)\n        throw new ForbiddenError('You can only view your own tokens')\n\n      const tokens = await getUserTokens(context.userId)\n      return tokens\n    }\n  },\n  Mutation: {\n    async apiTokenCreate(parent, args, context) {\n      if (!canCreateToken(context.scopes || [], args.token.scopes)) {\n        throw new ForbiddenError(\n          \"You can't create a token with scopes that you don't have\"\n        )\n      }\n\n      return await createPersonalAccessToken(\n        context.userId,\n        args.token.name,\n        args.token.scopes,\n        args.token.lifespan\n      )\n    },\n    async apiTokenRevoke(parent, args, context) {\n      let id = null\n      if (args.token.toLowerCase().includes('bearer')) id = args.token.split(' ')[1]\n      else id = args.token\n      await revokeToken(id, context.userId) // let's not revoke other people's tokens\n      return true\n    }\n  }\n}\n\nmodule.exports = resolvers\n", "export const canCreateToken = (userScopes: string[], tokenScopes: string[]) => {\n  return tokenScopes.every((scope) => userScopes.includes(scope))\n}\n", "import { BasicTestUser, createTestUsers } from '@/test/authHelper'\nimport {\n  CreateTokenDocument,\n  RevokeTokenDocument\n} from '@/test/graphql/generated/graphql'\nimport {\n  TestApolloServer,\n  createTestContext,\n  testApolloServer\n} from '@/test/graphqlHelper'\nimport { beforeEachContext } from '@/test/hooks'\nimport { AllScopes, Roles, Scopes } from '@speckle/shared'\nimport { expect } from 'chai'\nimport { difference } from 'lodash'\n\n/**\n * Older API token test cases can be found in `graph.spec.js`\n */\ndescribe('API Tokens', () => {\n  const userOne: BasicTestUser = {\n    name: 'Dimitrie Stefanescu',\n    email: 'didimitrie@gmail.com',\n    password: 'sn3aky-1337-b1m',\n    id: ''\n  }\n\n  let apollo: TestApolloServer\n\n  before(async () => {\n    await beforeEachContext()\n    await createTestUsers([userOne])\n\n    apollo = await testApolloServer({\n      context: createTestContext({\n        auth: true,\n        userId: userOne.id,\n        role: Roles.Server.Admin,\n        token: 'asd',\n        scopes: AllScopes\n      })\n    })\n  })\n\n  it(\"can't create PATs with scopes that the authenticated req itself doesn't have\", async () => {\n    const { data, errors } = await apollo.execute(\n      CreateTokenDocument,\n      {\n        token: {\n          name: 'invalidone',\n          scopes: [Scopes.Profile.Read, Scopes.Streams.Read]\n        }\n      },\n      {\n        context: {\n          scopes: [Scopes.Profile.Read, Scopes.Tokens.Write]\n        }\n      }\n    )\n\n    expect(data?.apiTokenCreate).to.not.be.ok\n    expect(errors).to.be.ok\n    expect(\n      errors!.find((e) =>\n        e.message.includes(\"You can't create a token with scopes that you don't have\")\n      )\n    ).to.be.ok\n  })\n\n  describe('without the tokens:write scope', () => {\n    const limitedTokenScopes = difference(AllScopes, [Scopes.Tokens.Write])\n    let limitedToken: string\n\n    before(async () => {\n      const res = await apollo.execute(CreateTokenDocument, {\n        token: { name: 'limited', scopes: limitedTokenScopes }\n      })\n\n      limitedToken = res.data?.apiTokenCreate || ''\n      if (!limitedToken.length) {\n        throw new Error(\"Couldn't prepare token for test\")\n      }\n    })\n\n    it(\"can't create PAT tokens\", async () => {\n      const { data, errors } = await apollo.execute(\n        CreateTokenDocument,\n        {\n          token: { name: 'invalidone', scopes: [Scopes.Profile.Read] }\n        },\n        {\n          context: {\n            scopes: limitedTokenScopes,\n            token: limitedToken\n          }\n        }\n      )\n\n      expect(data?.apiTokenCreate).to.not.be.ok\n      expect(errors).to.be.ok\n      expect(\n        errors!.find((e) => e.message.includes('do not have the required privileges'))\n      ).to.be.ok\n    })\n\n    it(\"can't delete PAT tokens\", async () => {\n      const { data, errors } = await apollo.execute(\n        RevokeTokenDocument,\n        { token: limitedToken },\n        {\n          context: {\n            scopes: limitedTokenScopes,\n            token: limitedToken\n          }\n        }\n      )\n\n      expect(data?.apiTokenRevoke).to.not.be.ok\n      expect(errors).to.be.ok\n      expect(\n        errors!.find((e) => e.message.includes('do not have the required privileges'))\n      ).to.be.ok\n    })\n  })\n})\n"], "fixing_code": ["<template>\n  <LayoutDialog\n    v-model:open=\"isOpen\"\n    max-width=\"sm\"\n    :buttons=\"dialogButtons\"\n    prevent-close-on-click-outside\n  >\n    <template #header>\n      {{ props.application ? 'Edit Application' : 'Create Application' }}\n    </template>\n    <form @submit=\"onSubmit\">\n      <div class=\"flex flex-col gap-6\">\n        <FormTextInput\n          v-model=\"name\"\n          label=\"Name\"\n          help=\"The name of your app\"\n          name=\"hookName\"\n          show-required\n          :rules=\"[isRequired]\"\n          show-label\n          type=\"text\"\n        />\n        <FormSelectBadges\n          v-model=\"scopes\"\n          multiple\n          name=\"scopes\"\n          label=\"Scopes\"\n          placeholder=\"Choose Scopes\"\n          help=\"It's good practice to limit the scopes of your token to the absolute minimum.\"\n          show-required\n          :rules=\"[isItemSelected]\"\n          show-label\n          :items=\"applicationScopes\"\n          by=\"id\"\n        />\n        <FormTextInput\n          v-model=\"redirectUrl\"\n          label=\"Redirect URL\"\n          help=\"After authentication, the users will be redirected (together with an access token) to this URL.\"\n          show-required\n          name=\"redirectUrl\"\n          show-label\n          :rules=\"[isRequired, isUrl]\"\n          type=\"text\"\n        />\n        <FormTextInput\n          v-model=\"description\"\n          label=\"Description\"\n          help=\"A short description of your application.\"\n          name=\"description\"\n          show-label\n          type=\"text\"\n        />\n      </div>\n    </form>\n  </LayoutDialog>\n</template>\n\n<script setup lang=\"ts\">\nimport { useMutation } from '@vue/apollo-composable'\nimport { AllScopes } from '@speckle/shared'\nimport { LayoutDialog, FormSelectBadges } from '@speckle/ui-components'\nimport type {\n  ApplicationFormValues,\n  ApplicationItem\n} from '~~/lib/developer-settings/helpers/types'\nimport {\n  createApplicationMutation,\n  editApplicationMutation\n} from '~~/lib/developer-settings/graphql/mutations'\nimport { isItemSelected } from '~~/lib/common/helpers/validation'\nimport { useForm } from 'vee-validate'\nimport {\n  convertThrowIntoFetchResult,\n  getCacheId,\n  getFirstErrorMessage\n} from '~~/lib/common/helpers/graphql'\nimport { useGlobalToast, ToastNotificationType } from '~~/lib/common/composables/toast'\nimport { isRequired, isUrl, fullyResetForm } from '~~/lib/common/helpers/validation'\nimport { useServerInfoScopes } from '~~/lib/common/composables/serverInfo'\n\nconst props = defineProps<{\n  application?: ApplicationItem\n}>()\n\nconst emit = defineEmits<{\n  (e: 'application-created', applicationId: string): void\n}>()\n\nconst isOpen = defineModel<boolean>('open', { required: true })\n\nconst { scopes: allScopes } = useServerInfoScopes()\nconst { mutate: createApplication } = useMutation(createApplicationMutation)\nconst { mutate: editApplication } = useMutation(editApplicationMutation)\nconst { triggerNotification } = useGlobalToast()\nconst { handleSubmit, resetForm } = useForm<ApplicationFormValues>()\n\nconst name = ref('')\nconst scopes = ref<typeof applicationScopes.value>([])\nconst redirectUrl = ref('')\nconst description = ref('')\n\nconst applicationScopes = computed(() => {\n  return Object.values(allScopes.value).map((value) => ({\n    id: value.name,\n    text: value.name\n  }))\n})\n\nconst onSubmit = handleSubmit(async (applicationFormValues) => {\n  const applicationId = props.application?.id\n\n  if (props.application) {\n    const usedScopeIds = applicationFormValues.scopes.map((t) => t.id)\n    const result = await editApplication(\n      {\n        app: {\n          id: props.application.id,\n          name: name.value,\n          scopes: applicationFormValues.scopes.map((t) => t.id),\n          redirectUrl: redirectUrl.value,\n          description: description.value\n        }\n      },\n      {\n        update: (cache, { data }) => {\n          if (applicationId && data?.appUpdate) {\n            cache.modify({\n              id: getCacheId('ServerApp', applicationId),\n              fields: {\n                redirectUrl: () => applicationFormValues.redirectUrl,\n                description: () => description.value || '',\n                scopes: () =>\n                  allScopes.value.filter((t) => usedScopeIds.includes(t.name)),\n                name: () => name.value\n              }\n            })\n          }\n        }\n      }\n    ).catch(convertThrowIntoFetchResult)\n\n    if (result?.data?.appUpdate) {\n      isOpen.value = false\n      resetFormFields()\n      triggerNotification({\n        type: ToastNotificationType.Success,\n        title: 'Application updated',\n        description: 'The application has been successfully updated'\n      })\n    } else {\n      const errorMessage = getFirstErrorMessage(result?.errors)\n      triggerNotification({\n        type: ToastNotificationType.Danger,\n        title: 'Failed to update application',\n        description: errorMessage\n      })\n    }\n  } else {\n    const result = await createApplication({\n      app: {\n        name: name.value,\n        scopes: applicationFormValues.scopes.map((t) => t.id),\n        redirectUrl: redirectUrl.value,\n        description: description.value\n      }\n    }).catch(convertThrowIntoFetchResult)\n\n    if (result?.data?.appCreate) {\n      isOpen.value = false\n      resetFormFields()\n      emit('application-created', result.data.appCreate)\n      triggerNotification({\n        type: ToastNotificationType.Success,\n        title: 'Application created',\n        description: 'The application has been successfully created'\n      })\n    } else {\n      const errorMessage = getFirstErrorMessage(result?.errors)\n      triggerNotification({\n        type: ToastNotificationType.Danger,\n        title: 'Failed to create application',\n        description: errorMessage\n      })\n    }\n  }\n})\n\nconst dialogButtons = computed(() => [\n  {\n    text: 'Cancel',\n    props: { color: 'secondary', fullWidth: true, outline: true },\n    onClick: () => {\n      isOpen.value = false\n    }\n  },\n  {\n    text: props.application ? 'Save' : 'Create',\n    props: { color: 'primary', fullWidth: true },\n    onClick: onSubmit\n  }\n])\n\nconst resetApplicationModel = () => {\n  if (props.application) {\n    name.value = props.application.name\n    scopes.value = (props.application.scopes || []).map((scope) => ({\n      id: scope.name as (typeof AllScopes)[number],\n      text: scope.name as (typeof AllScopes)[number]\n    }))\n    redirectUrl.value = props.application.redirectUrl\n    description.value = props.application.description || ''\n  } else {\n    resetFormFields()\n  }\n}\n\nconst resetFormFields = () => {\n  name.value = ''\n  scopes.value = []\n  redirectUrl.value = ''\n  description.value = ''\n  fullyResetForm(resetForm)\n}\n\nwatch(\n  () => isOpen.value,\n  (newVal) => {\n    if (newVal) {\n      resetApplicationModel()\n    }\n  }\n)\n</script>\n", "<template>\n  <LayoutDialog\n    v-model:open=\"isOpen\"\n    max-width=\"sm\"\n    :buttons=\"dialogButtons\"\n    prevent-close-on-click-outside\n  >\n    <template #header>Create Token</template>\n    <form @submit=\"onSubmit\">\n      <div class=\"flex flex-col gap-6\">\n        <FormTextInput\n          v-model=\"name\"\n          label=\"Name\"\n          help=\"A name to remember this token by. For example, the name of the script or application you're planning to use it in!\"\n          name=\"hookName\"\n          :rules=\"[isRequired]\"\n          show-required\n          show-label\n          type=\"text\"\n        />\n        <FormSelectBadges\n          v-model=\"scopes\"\n          multiple\n          name=\"scopes\"\n          label=\"Scopes\"\n          placeholder=\"Choose Scopes\"\n          help=\"It's good practice to limit the scopes of your token to the absolute minimum. For example, if your application or script will only read and write streams, select just those scopes.\"\n          show-required\n          :rules=\"[isItemSelected]\"\n          show-label\n          :items=\"apiTokenScopes\"\n          mount-menu-on-body\n          by=\"id\"\n        />\n      </div>\n    </form>\n  </LayoutDialog>\n</template>\n\n<script setup lang=\"ts\">\nimport { useMutation } from '@vue/apollo-composable'\nimport { LayoutDialog, FormSelectBadges } from '@speckle/ui-components'\nimport type { TokenFormValues } from '~~/lib/developer-settings/helpers/types'\nimport { createAccessTokenMutation } from '~~/lib/developer-settings/graphql/mutations'\nimport { isItemSelected, isRequired } from '~~/lib/common/helpers/validation'\nimport { useForm } from 'vee-validate'\nimport {\n  convertThrowIntoFetchResult,\n  getFirstErrorMessage\n} from '~~/lib/common/helpers/graphql'\nimport { useGlobalToast, ToastNotificationType } from '~~/lib/common/composables/toast'\nimport { useServerInfoScopes } from '~/lib/common/composables/serverInfo'\n\nconst emit = defineEmits<{\n  (e: 'token-created', tokenId: string): void\n}>()\n\nconst { scopes: allScopes } = useServerInfoScopes()\nconst { mutate: createToken } = useMutation(createAccessTokenMutation)\nconst { triggerNotification } = useGlobalToast()\nconst { handleSubmit } = useForm<TokenFormValues>()\n\nconst isOpen = defineModel<boolean>('open', { required: true })\n\nconst name = ref('')\nconst scopes = ref<typeof apiTokenScopes.value>([])\n\nconst apiTokenScopes = computed(() => {\n  return Object.values(allScopes.value).map((value) => ({\n    id: value.name,\n    text: value.name\n  }))\n})\n\nconst onSubmit = handleSubmit(async (tokenFormValues) => {\n  const result = await createToken({\n    token: {\n      name: name.value,\n      scopes: tokenFormValues.scopes.map((t) => t.id)\n    }\n  }).catch(convertThrowIntoFetchResult)\n\n  if (result?.data?.apiTokenCreate) {\n    isOpen.value = false\n    resetFormFields()\n    emit('token-created', result.data.apiTokenCreate)\n    triggerNotification({\n      type: ToastNotificationType.Success,\n      title: 'Webhook created',\n      description: 'The webhook has been successfully created'\n    })\n  } else {\n    const errorMessage = getFirstErrorMessage(result?.errors)\n    triggerNotification({\n      type: ToastNotificationType.Danger,\n      title: 'Failed to create token',\n      description: errorMessage\n    })\n  }\n})\n\nconst dialogButtons = computed(() => [\n  {\n    text: 'Cancel',\n    props: { color: 'secondary', fullWidth: true, outline: true },\n    onClick: () => {\n      isOpen.value = false\n    }\n  },\n  {\n    text: 'Create',\n    props: { color: 'primary', fullWidth: true },\n    onClick: onSubmit\n  }\n])\n\nconst resetFormFields = () => {\n  name.value = ''\n  scopes.value = []\n}\n\nwatch(\n  () => isOpen.value,\n  (newVal) => {\n    if (newVal) {\n      resetFormFields()\n    }\n  }\n)\n</script>\n", "import { BaseError } from '@/modules/shared/errors/base'\n\nexport class UserUpdateError extends BaseError {\n  static defaultMessage = 'An issue occurred while attempting to update a user'\n  static code = 'USER_UPDATE_ERROR'\n}\n\nexport class UserValidationError extends BaseError {\n  static defaultMessage = 'The user input data is invalid'\n  static code = 'USER_VALIDATION_ERROR'\n}\n\nexport class TokenCreateError extends BaseError {\n  static code = 'TOKEN_CREATE_ERROR'\n  static defaultMessage = 'An error occurred while creating a token'\n}\n", "'use strict'\n\nconst { ForbiddenError } = require('apollo-server-express')\nconst {\n  createPersonalAccessToken,\n  revokeToken,\n  getUserTokens\n} = require('../../services/tokens')\nconst { canCreatePAT } = require('@/modules/core/helpers/token')\n\n/** @type {import('@/modules/core/graph/generated/graphql').Resolvers} */\nconst resolvers = {\n  Query: {},\n  User: {\n    async apiTokens(parent, args, context) {\n      // TODO!\n      if (parent.id !== context.userId)\n        throw new ForbiddenError('You can only view your own tokens')\n\n      const tokens = await getUserTokens(context.userId)\n      return tokens\n    }\n  },\n  Mutation: {\n    async apiTokenCreate(parent, args, context) {\n      canCreatePAT({\n        userScopes: context.scopes || [],\n        tokenScopes: args.token.scopes,\n        strict: true\n      })\n\n      return await createPersonalAccessToken(\n        context.userId,\n        args.token.name,\n        args.token.scopes,\n        args.token.lifespan\n      )\n    },\n    async apiTokenRevoke(parent, args, context) {\n      let id = null\n      if (args.token.toLowerCase().includes('bearer')) id = args.token.split(' ')[1]\n      else id = args.token\n      await revokeToken(id, context.userId) // let's not revoke other people's tokens\n      return true\n    }\n  }\n}\n\nmodule.exports = resolvers\n", "import { TokenCreateError } from '@/modules/core/errors/user'\nimport { Scopes } from '@speckle/shared'\n\nexport const canCreateToken = (params: {\n  userScopes: string[]\n  tokenScopes: string[]\n  strict?: boolean\n}) => {\n  const { userScopes, tokenScopes, strict } = params\n  const hasAllScopes = tokenScopes.every((scope) => userScopes.includes(scope))\n  if (!hasAllScopes) {\n    if (!strict) return false\n    throw new TokenCreateError(\n      \"You can't create a token with scopes that you don't have\"\n    )\n  }\n\n  return true\n}\n\nexport const canCreatePAT = (params: {\n  userScopes: string[]\n  tokenScopes: string[]\n  strict?: boolean\n}) => {\n  const { tokenScopes, strict } = params\n  if (tokenScopes.includes(Scopes.Tokens.Write)) {\n    if (!strict) return false\n    throw new TokenCreateError(\n      \"You can't create a personal access token with the tokens:write scope\"\n    )\n  }\n\n  return canCreateToken(params)\n}\n", "import { BasicTestUser, createTestUsers } from '@/test/authHelper'\nimport {\n  CreateTokenDocument,\n  RevokeTokenDocument\n} from '@/test/graphql/generated/graphql'\nimport {\n  TestApolloServer,\n  createTestContext,\n  testApolloServer\n} from '@/test/graphqlHelper'\nimport { beforeEachContext } from '@/test/hooks'\nimport { AllScopes, Roles, Scopes } from '@speckle/shared'\nimport { expect } from 'chai'\nimport { difference } from 'lodash'\n\n/**\n * Older API token test cases can be found in `graph.spec.js`\n */\ndescribe('API Tokens', () => {\n  const userOne: BasicTestUser = {\n    name: 'Dimitrie Stefanescu',\n    email: 'didimitrie@gmail.com',\n    password: 'sn3aky-1337-b1m',\n    id: ''\n  }\n\n  let apollo: TestApolloServer\n\n  before(async () => {\n    await beforeEachContext()\n    await createTestUsers([userOne])\n\n    apollo = await testApolloServer({\n      context: createTestContext({\n        auth: true,\n        userId: userOne.id,\n        role: Roles.Server.Admin,\n        token: 'asd',\n        scopes: AllScopes\n      })\n    })\n  })\n\n  it(\"can't create PATs with scopes that the authenticated req itself doesn't have\", async () => {\n    const { data, errors } = await apollo.execute(\n      CreateTokenDocument,\n      {\n        token: {\n          name: 'invalidone',\n          scopes: [Scopes.Profile.Read, Scopes.Streams.Read]\n        }\n      },\n      {\n        context: {\n          scopes: [Scopes.Profile.Read, Scopes.Tokens.Write]\n        }\n      }\n    )\n\n    expect(data?.apiTokenCreate).to.not.be.ok\n    expect(errors).to.be.ok\n    expect(\n      errors!.find((e) =>\n        e.message.includes(\"You can't create a token with scopes that you don't have\")\n      )\n    ).to.be.ok\n  })\n\n  it(\"can't create PAT with tokens:write scope\", async () => {\n    const scopes = [Scopes.Profile.Read, Scopes.Tokens.Write]\n    const { data, errors } = await apollo.execute(\n      CreateTokenDocument,\n      {\n        token: {\n          name: 'sometoken',\n          scopes\n        }\n      },\n      {\n        context: {\n          scopes\n        }\n      }\n    )\n\n    expect(data?.apiTokenCreate).to.not.be.ok\n    expect(errors).to.be.ok\n    expect(\n      errors!.find((e) =>\n        e.message.includes(\n          \"You can't create a personal access token with the tokens:write scope\"\n        )\n      )\n    ).to.be.ok\n  })\n\n  describe('without the tokens:write scope', () => {\n    const limitedTokenScopes = difference(AllScopes, [Scopes.Tokens.Write])\n    let limitedToken: string\n\n    before(async () => {\n      const res = await apollo.execute(CreateTokenDocument, {\n        token: { name: 'limited', scopes: limitedTokenScopes }\n      })\n\n      limitedToken = res.data?.apiTokenCreate || ''\n      if (!limitedToken.length) {\n        throw new Error(\"Couldn't prepare token for test\")\n      }\n    })\n\n    it(\"can't create PAT tokens\", async () => {\n      const { data, errors } = await apollo.execute(\n        CreateTokenDocument,\n        {\n          token: { name: 'invalidone', scopes: [Scopes.Profile.Read] }\n        },\n        {\n          context: {\n            scopes: limitedTokenScopes,\n            token: limitedToken\n          }\n        }\n      )\n\n      expect(data?.apiTokenCreate).to.not.be.ok\n      expect(errors).to.be.ok\n      expect(\n        errors!.find((e) => e.message.includes('do not have the required privileges'))\n      ).to.be.ok\n    })\n\n    it(\"can't delete PAT tokens\", async () => {\n      const { data, errors } = await apollo.execute(\n        RevokeTokenDocument,\n        { token: limitedToken },\n        {\n          context: {\n            scopes: limitedTokenScopes,\n            token: limitedToken\n          }\n        }\n      )\n\n      expect(data?.apiTokenRevoke).to.not.be.ok\n      expect(errors).to.be.ok\n      expect(\n        errors!.find((e) => e.message.includes('do not have the required privileges'))\n      ).to.be.ok\n    })\n  })\n})\n"], "filenames": ["packages/frontend-2/components/developer-settings/CreateEditApplicationDialog.vue", "packages/frontend-2/components/developer-settings/CreateTokenDialog.vue", "packages/server/modules/core/errors/user.ts", "packages/server/modules/core/graph/resolvers/apitoken.js", "packages/server/modules/core/helpers/token.ts", "packages/server/modules/core/tests/apitokens.spec.ts"], "buggy_code_start_loc": [104, 42, 11, 9, 1, 68], "buggy_code_end_loc": [107, 71, 11, 31, 3, 68], "fixing_code_start_loc": [104, 41, 12, 9, 1, 69], "fixing_code_end_loc": [107, 72, 17, 31, 36, 97], "type": "CWE-1220", "message": "Speckle Server provides server, frontend, 3D viewer, and other JavaScript utilities for the Speckle 3D data platform. A vulnerability in versions prior to 2.17.6 affects users who: authorized an application which requested a 'token write' scope or, using frontend-2, created a Personal Access Token (PAT) with `token write` scope. When creating a new token an agent needs to authorise the request with an existing token (the 'requesting token').  The requesting token is required to have token write scope in order to generate new tokens. However, Speckle server was not verifying that other privileges granted to the new token were not in excess of the privileges of the requesting token. A malicious actor could use a token with only token write scope to subsequently generate further tokens with additional privileges. These privileges would only grant privileges up to the existing privileges of the user. This vulnerability cannot be used to escalate a user's privileges or grant privileges on behalf of other users.\n\nThis has been patched as of version 2.17.6. All operators of Speckle servers should upgrade their server to version 2.17.6 or higher. Any users who authorized an application with 'token write' scope, or created a token in frontend-2 with `token write` scope should review existing tokens and permanently revoke any they do not recognize, revoke existing tokens and create new tokens, and review usage of their account for suspicious activity. No known workarounds for this issue exist.", "other": {"cve": {"id": "CVE-2023-50713", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-14T19:15:16.340", "lastModified": "2023-12-28T20:23:47.670", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Speckle Server provides server, frontend, 3D viewer, and other JavaScript utilities for the Speckle 3D data platform. A vulnerability in versions prior to 2.17.6 affects users who: authorized an application which requested a 'token write' scope or, using frontend-2, created a Personal Access Token (PAT) with `token write` scope. When creating a new token an agent needs to authorise the request with an existing token (the 'requesting token').  The requesting token is required to have token write scope in order to generate new tokens. However, Speckle server was not verifying that other privileges granted to the new token were not in excess of the privileges of the requesting token. A malicious actor could use a token with only token write scope to subsequently generate further tokens with additional privileges. These privileges would only grant privileges up to the existing privileges of the user. This vulnerability cannot be used to escalate a user's privileges or grant privileges on behalf of other users.\n\nThis has been patched as of version 2.17.6. All operators of Speckle servers should upgrade their server to version 2.17.6 or higher. Any users who authorized an application with 'token write' scope, or created a token in frontend-2 with `token write` scope should review existing tokens and permanently revoke any they do not recognize, revoke existing tokens and create new tokens, and review usage of their account for suspicious activity. No known workarounds for this issue exist."}, {"lang": "es", "value": "Speckle Server proporciona servidor, interfaz, visor 3D y otras utilidades de JavaScript para la plataforma de datos Speckle 3D. Una vulnerabilidad en versiones anteriores a la 2.17.6 afecta a los usuarios que: autorizaron una aplicaci\u00f3n que solicit\u00f3 un alcance de \"escritura de token\" o, utilizando frontend-2, crearon un token de acceso personal (PAT) con alcance de \"escritura de token\". Al crear un nuevo token, un agente debe autorizar la solicitud con un token existente (el \"token solicitante\"). Se requiere que el token solicitante tenga alcance de escritura de token para poder generar nuevos tokens. Sin embargo, el servidor Speckle no estaba verificando que otros privilegios otorgados al nuevo token no excedieran los privilegios del token solicitante. Un actor malintencionado podr\u00eda utilizar un token con alcance de escritura de token \u00fanicamente para generar posteriormente m\u00e1s tokens con privilegios adicionales. Estos privilegios solo otorgar\u00edan permisos hasta los privilegios existentes del usuario. Esta vulnerabilidad no se puede utilizar para escalar los privilegios de un usuario ni otorgar permisos en nombre de otros usuarios. Esto ha sido parcheado a partir de la versi\u00f3n 2.17.6. Todos los operadores de servidores Speckle deben actualizar su servidor a la versi\u00f3n 2.17.6 o superior. Cualquier usuario que haya autorizado una aplicaci\u00f3n con alcance de \"escritura de token\" o haya creado un token en frontend-2 con alcance de \"escritura de token\" debe revisar los tokens existentes y revocar permanentemente los que no reconozcan, revocar los tokens existentes y crear nuevos tokens, y revisar uso de su cuenta para actividades sospechosas. No existen workarounds conocidas para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1220"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:specklesystems:speckle_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.17.6", "matchCriteriaId": "B6E7134A-CA97-4DF0-BF26-FE9BFF2E71E0"}]}]}], "references": [{"url": "https://github.com/specklesystems/speckle-server/commit/3689e1cd58ec4f06abee836af34889d6ce474571", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/specklesystems/speckle-server/releases/tag/2.17.6", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/specklesystems/speckle-server/security/advisories/GHSA-xpf3-5q5x-3qwh", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/specklesystems/speckle-server/commit/3689e1cd58ec4f06abee836af34889d6ce474571"}}