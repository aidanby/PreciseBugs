{"buggy_code": ["/*\n * Parsing functions.\n *\n * This file is part of abcm2ps.\n *\n * Copyright (C) 1998-2020 Jean-Fran\u00e7ois Moine (http://moinejf.free.fr)\n * Adapted from abc2ps, Copyright (C) 1996-1998 Michael Methfessel\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#include <regex.h>\n\n#include \"abcm2ps.h\"\n\n/* options = external formatting */\nstruct symsel_s {\t\t\t/* symbol selection */\n\tshort bar;\n\tshort time;\n\tchar seq;\n};\nstruct brk_s {\t\t\t\t/* music line break */\n\tstruct brk_s *next;\n\tstruct symsel_s symsel;\n};\nstruct voice_opt_s {\t\t\t/* voice options */\n\tstruct voice_opt_s *next;\n\tstruct SYMBOL *s;\t\t/* list of options (%%xxx) */\n};\nstruct tune_opt_s {\t\t\t/* tune options */\n\tstruct tune_opt_s *next;\n\tstruct voice_opt_s *voice_opts;\n\tstruct SYMBOL *s;\t\t/* list of options (%%xxx) */\n};\n\nint nstaff;\t\t\t\t/* (0..MAXSTAFF-1) */\nstruct SYMBOL *tsfirst;\t\t\t/* first symbol in the time sorted list */\n\nstruct VOICE_S voice_tb[MAXVOICE];\t/* voice table */\nstruct VOICE_S *first_voice;\t\t/* first voice */\nstruct SYSTEM *cursys;\t\t\t/* current system */\nstatic struct SYSTEM *parsys;\t\t/* current system while parsing */\n\nstruct FORMAT dfmt;\t\t\t/* current global format */\nint nbar;\t\t\t\t/* current measure number */\n\nstruct map *maps;\t\t\t/* note mappings */\n\nstatic struct voice_opt_s *voice_opts, *tune_voice_opts;\nstatic struct tune_opt_s *tune_opts, *cur_tune_opts;\nstatic struct brk_s *brks;\nstatic struct symsel_s clip_start, clip_end;\n\nstatic INFO info_glob;\t\t\t/* global info definitions */\nstatic char *deco_glob[256];\t\t/* global decoration table */\nstatic struct map *maps_glob;\t\t/* save note maps */\n\nstatic int over_time;\t\t\t/* voice overlay start time */\nstatic int over_mxtime;\t\t\t/* voice overlay max time */\nstatic short over_bar;\t\t\t/* voice overlay in a measure */\nstatic short over_voice;\t\t/* main voice in voice overlay */\nstatic int staves_found;\t\t/* time of the last %%staves */\nstatic int abc2win;\nstatic int capo;\t\t\t// capo indication\n\nfloat multicol_start;\t\t\t/* (for multicol) */\nstatic float multicol_max;\nstatic float lmarg, rmarg;\n\nstatic void get_clef(struct SYMBOL *s);\nstatic struct SYMBOL *get_info(struct SYMBOL *s);\nstatic void get_key(struct SYMBOL *s);\nstatic void get_meter(struct SYMBOL *s);\nstatic void get_voice(struct SYMBOL *s);\nstatic void get_note(struct SYMBOL *s);\nstatic struct SYMBOL *process_pscomment(struct SYMBOL *s);\nstatic void ps_def(struct SYMBOL *s, char *p, char use);\nstatic void set_tblt(struct VOICE_S *p_voice);\nstatic void set_tuplet(struct SYMBOL *s);\n\n/* -- weight of the symbols -- */\nstatic char w_tb[NSYMTYPES] = {\t/* !! index = symbol type !! */\n\t0,\n\t9,\t/* 1- note / rest */\n\t3,\t/* 2- space */\n\t2,\t/* 3- bar */\n\t1,\t/* 4- clef */\n\t6,\t/* 5- timesig */\n\t5,\t/* 6- keysig */\n\t0,\t/* 7- tempo */\n\t0,\t/* 8- staves */\n\t9,\t/* 9- mrest */\n\t0,\t/* 10- part */\n\t3,\t/* 11- grace */\n\t0,\t/* 12- fmtchg */\n\t8,\t/* 13- tuplet */\n\t7,\t/* 14- stbrk */\n\t7\t/* 15- custos */\n};\n\n/* key signature transposition tables */\nstatic signed char cde2fcg[7] = {0, 2, 4, -1, 1, 3, 5};\nstatic char cgd2cde[7] = {0, 4, 1, 5, 2, 6, 3};\n\n/* -- link a ABC symbol into the current voice -- */\nstatic void sym_link(struct SYMBOL *s, int type)\n{\n\tstruct VOICE_S *p_voice = curvoice;\n\n\tif (!p_voice->ignore) {\n\t\ts->prev = p_voice->last_sym;\n\t\tif (s->prev)\n\t\t\tp_voice->last_sym->next = s;\n\t\telse\n\t\t\tp_voice->sym = s;\n\t\tp_voice->last_sym = s;\n//fixme:test bug\n//\t} else {\n//\t\tif (p_voice->sym)\n//\t\t\tp_voice->last_sym = p_voice->sym = s;\n\t}\n\n\ts->type = type;\n\ts->voice = p_voice - voice_tb;\n\ts->staff = p_voice->cstaff;\n\ts->time = p_voice->time;\n\ts->posit = p_voice->posit;\n}\n\n/* -- add a new symbol in a voice -- */\nstruct SYMBOL *sym_add(struct VOICE_S *p_voice, int type)\n{\n\tstruct SYMBOL *s;\n\tstruct VOICE_S *p_voice2;\n\n\ts = (struct SYMBOL *) getarena(sizeof *s);\n\tmemset(s, 0, sizeof *s);\n\tp_voice2 = curvoice;\n\tcurvoice = p_voice;\n\tsym_link(s, type);\n\tcurvoice = p_voice2;\n\tif (p_voice->second)\n\t\ts->sflags |= S_SECOND;\n\tif (p_voice->floating)\n\t\ts->sflags |= S_FLOATING;\n\tif (s->prev) {\n\t\ts->fn = s->prev->fn;\n\t\ts->linenum = s->prev->linenum;\n\t\ts->colnum = s->prev->colnum;\n\t}\n\treturn s;\n}\n\n/* -- expand a multi-rest into single rests and measure bars -- */\nstatic void mrest_expand(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice;\n\tstruct SYMBOL *s2, *next;\n\tstruct decos dc;\n\tint nb, dt;\n\n\tnb = s->u.bar.len;\n\tdt = s->dur / nb;\n\n\t/* change the multi-rest (type bar) to a single rest */\n\tmemcpy(&dc, &s->u.bar.dc, sizeof dc);\n\tmemset(&s->u.note, 0, sizeof s->u.note);\n\ts->type = NOTEREST;\n\ts->abc_type = ABC_T_REST;\n//\ts->nhd = 0;\n\ts->dur = s->u.note.notes[0].len = dt;\n\ts->head = H_FULL;\n\ts->nflags = -2;\n\n\t/* add the bar(s) and rest(s) */\n\tnext = s->next;\n\tp_voice = &voice_tb[s->voice];\n\tp_voice->last_sym = s;\n\tp_voice->time = s->time + dt;\n\tp_voice->cstaff = s->staff;\n\ts2 = s;\n\twhile (--nb > 0) {\n\t\ts2 = sym_add(p_voice, BAR);\n\t\ts2->abc_type = ABC_T_BAR;\n\t\ts2->u.bar.type = B_SINGLE;\n\t\ts2 = sym_add(p_voice, NOTEREST);\n\t\ts2->abc_type = ABC_T_REST;\n\t\ts2->flags = s->flags;\n\t\ts2->dur = s2->u.note.notes[0].len = dt;\n\t\ts2->head = H_FULL;\n\t\ts2->nflags = -2;\n\t\tp_voice->time += dt;\n\t}\n\ts2->next = next;\n\tif (next)\n\t\tnext->prev = s2;\n\n\t/* copy the mrest decorations to the last rest */\n\tmemcpy(&s2->u.note.dc, &dc, sizeof s2->u.note.dc);\n}\n\n/* -- sort all symbols by time and vertical sequence -- */\nstatic void sort_all(void)\n{\n\tstruct SYSTEM *sy;\n\tstruct SYMBOL *s, *prev, *s2;\n\tstruct VOICE_S *p_voice;\n\tint fl, voice, time, w, wmin, multi, mrest_time;\n\tint nb, r, set_sy, new_sy;\t// nv\n\tstruct SYMBOL *vtb[MAXVOICE];\n\tsigned char vn[MAXVOICE];\t/* voice indexed by range */\n\n/*\tmemset(vtb, 0, sizeof vtb); */\n\tmrest_time = -1;\n\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next)\n\t\tvtb[p_voice - voice_tb] = p_voice->sym;\n\n\t/* initialize the voice order */\n\tsy = cursys;\n\tset_sy = 1;\n\tnew_sy = 0;\n\tprev = NULL;\n\tfl = 1;\t\t\t\t/* (have gcc happy) */\n\tmulti = -1;\t\t\t/* (have gcc happy) */\n\tfor (;;) {\n\t\tif (set_sy) {\n\t\t    fl = 1;\t\t\t// start a new sequence\n//\t\t    if (!new_sy) {\n\t\t    if (1) {\n\t\t\tset_sy = 0;\n\t\t\tmulti = -1;\n\t\t\tmemset(vn, -1, sizeof vn);\n\t\t\tfor (p_voice = first_voice;\n\t\t\t     p_voice;\n\t\t\t     p_voice = p_voice->next) {\n\t\t\t\tvoice = p_voice - voice_tb;\n\t\t\t\tr = sy->voice[voice].range;\n\t\t\t\tif (r < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tvn[r] = voice;\n\t\t\t\tmulti++;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/* search the min time and symbol weight */\n\t\twmin = time = (unsigned) ~0 >> 1;\t/* max int */\n//\t\tnv = nb = 0;\n\t\tfor (r = 0; r < MAXVOICE; r++) {\n\t\t\tvoice = vn[r];\n\t\t\tif (voice < 0)\n\t\t\t\tbreak;\n\t\t\ts = vtb[voice];\n\t\t\tif (!s || s->time > time)\n\t\t\t\tcontinue;\n\t\t\tw = w_tb[s->type];\n\t\t\tif (s->time < time) {\n\t\t\t\ttime = s->time;\n\t\t\t\twmin = w;\n//\t\t\t\tnb = 0;\n\t\t\t} else if (w < wmin) {\n\t\t\t\twmin = w;\n//\t\t\t\tnb = 0;\n\t\t\t}\n#if 0\n\t\t\tif (!(s->sflags & S_SECOND)) {\n\t\t\t\tnv++;\n\t\t\t\tif (s->type == BAR)\n\t\t\t\t\tnb++;\n\t\t\t}\n#endif\n\t\t\tif (s->type == MREST) {\n\t\t\t\tif (s->u.bar.len == 1)\n\t\t\t\t\tmrest_expand(s);\n\t\t\t\telse if (multi > 0)\n\t\t\t\t\tmrest_time = time;\n\t\t\t}\n\t\t}\n\t\tif (wmin > 127)\n\t\t\tbreak;\t\t\t\t\t/* done */\n\n#if 0\n\t\t/* align the measure bars */\n\t\tif (nb != 0 && nb != nv) {\t/* if other symbol than bars */\n\t\t\twmin = (unsigned) ~0 >> 1;\n\t\t\tfor (r = 0; r < MAXVOICE; r++) {\n\t\t\t\tvoice = vn[r];\n\t\t\t\tif (voice < 0)\n\t\t\t\t\tbreak;\n\t\t\t\ts = vtb[voice];\n\t\t\t\tif (!s || s->time > time\n\t\t\t\t || s->type == BAR)\n\t\t\t\t\tcontinue;\n\t\t\t\tw = w_tb[s->type];\n\t\t\t\tif (w < wmin)\n\t\t\t\t\twmin = w;\n\t\t\t}\n\t\t\tif (wmin > 127)\n\t\t\t\twmin = w_tb[BAR];\n\t\t}\n#endif\n\n\t\t/* if some multi-rest and many voices, expand */\n\t\tif (time == mrest_time) {\n\t\t\tnb = 0;\n\t\t\tfor (r = 0; r < MAXVOICE; r++) {\n\t\t\t\tvoice = vn[r];\n\t\t\t\tif (voice < 0)\n\t\t\t\t\tbreak;\n\t\t\t\ts = vtb[voice];\n\t\t\t\tif (!s || s->time != time)\n\t\t\t\t\tcontinue;\n\t\t\t\tw = w_tb[s->type];\n\t\t\t\tif (w != wmin)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (s->type != MREST) {\n\t\t\t\t\tmrest_time = -1; /* some note or rest */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (nb == 0) {\n\t\t\t\t\tnb = s->u.bar.len;\n\t\t\t\t} else if (nb != s->u.bar.len) {\n\t\t\t\t\tmrest_time = -1; /* different duration */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mrest_time < 0) {\n\t\t\t\tfor (r = 0; r < MAXVOICE; r++) {\n\t\t\t\t\tvoice = vn[r];\n\t\t\t\t\tif (voice < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ts = vtb[voice];\n\t\t\t\t\tif (s && s->type == MREST)\n\t\t\t\t\t\tmrest_expand(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* link the vertical sequence */\n\t\tfor (r = 0; r < MAXVOICE; r++) {\n\t\t\tvoice = vn[r];\n\t\t\tif (voice < 0)\n\t\t\t\tbreak;\n\t\t\ts = vtb[voice];\n\t\t\tif (!s || s->time != time\n\t\t\t || w_tb[s->type] != wmin)\n\t\t\t\tcontinue;\n\t\t\tif (s->type == STAVES) {\t// change STAVES to a flag\n\t\t\t\tsy = sy->next;\n\t\t\t\tset_sy = new_sy = 1;\n\t\t\t\tif (s->prev)\n\t\t\t\t\ts->prev->next = s->next;\n\t\t\t\telse\n\t\t\t\t\tvoice_tb[voice].sym = s->next;\n\t\t\t\tif (s->next)\n\t\t\t\t\ts->next->prev = s->prev;\n\t\t\t} else {\n\t\t\t\tif (fl) {\n\t\t\t\t\tfl = 0;\n\t\t\t\t\ts->sflags |= S_SEQST;\n\t\t\t\t}\n\t\t\t\tif (new_sy) {\n\t\t\t\t\tnew_sy = 0;\n\t\t\t\t\ts->sflags |= S_NEW_SY;\n\t\t\t\t}\n\t\t\t\ts->ts_prev = prev;\n\t\t\t\tif (prev) {\n\t\t\t\t\tprev->ts_next = s;\n//fixme: bad error when the 1st voice is second\n//\t\t\t\t\tif (s->type == BAR\n//\t\t\t\t\t && (s->sflags & S_SECOND)\n//\t\t\t\t\t && prev->type != BAR\n//\t\t\t\t\t && !(s->flags & ABC_F_INVIS))\n//\t\t\t\t\t\terror(1, s, \"Bad measure bar\");\n\t\t\t\t} else {\n\t\t\t\t\ttsfirst = s;\n\t\t\t\t}\n\t\t\t\tprev = s;\n\t\t\t}\n\t\t\tvtb[voice] = s->next;\n\t\t}\n\t\tfl = wmin;\t\t/* start a new sequence if some space */\n\t}\n\n\tif (!prev)\n\t\treturn;\n\n\t/* if no bar or format_change at end of tune, add a dummy symbol */\n\tif ((prev->type != BAR && prev->type != FMTCHG)\n\t || new_sy) {\n\t\tp_voice = &voice_tb[prev->voice];\n\t\tp_voice->last_sym = prev;\n\t\ts = sym_add(p_voice, FMTCHG);\n\t\ts->aux = -1;\n\t\ts->time = prev->time + prev->dur;\n\t\ts->sflags = S_SEQST;\n\t\tif (new_sy)\n\t\t\ts->sflags |= S_NEW_SY;\n\t\tprev->ts_next = s;\n\t\ts->ts_prev = prev;\n\t\tfor (;;) {\n\t\t\tprev->sflags &= ~S_EOLN;\n\t\t\tif (prev->sflags & S_SEQST)\n\t\t\t\tbreak;\n\t\t\tprev = prev->ts_prev;\n\t\t}\n\t}\n\n\t/* if Q: from tune header, put it at start of the music */\n\ts2 = info['Q' - 'A'];\n\tif (!s2)\n\t\treturn;\n\tinfo['Q' - 'A'] = NULL;\n\ts = tsfirst->extra;\n\twhile (s) {\n\t\tif (s->type == TEMPO)\n\t\t\treturn;\t\t\t/* already a tempo */\n\t\ts = s->next;\n\t}\n\ts = tsfirst;\n\ts2->type = TEMPO;\n\ts2->voice = s->voice;\n\ts2->staff = s->staff;\n\ts2->time = s->time;\n\tif (s->extra) {\n\t\ts2->next = s->extra;\n\t\ts2->next->prev = s2;\n\t}\n\ts->extra = s2;\n}\n\n/* -- move the symbols with no width to the next symbol -- */\nstatic void voice_compress(void)\n{\n\tstruct VOICE_S *p_voice;\n\tstruct SYMBOL *s, *s2, *s3, *ns;\n\n\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next) {\n//8.7.0 - for fmt at end of music line\n//\t\tif (p_voice->ignore)\n//\t\t\tcontinue;\n\t\tp_voice->ignore = 0;\n\t\tfor (s = p_voice->sym; s; s = s->next) {\n\t\t\tif (s->time >= staves_found)\n\t\t\t\tbreak;\n\t\t}\n\t\tns = NULL;\n\t\tfor ( ; s; s = s->next) {\n\t\t\tswitch (s->type) {\n#if 0 // test\n\t\t\tcase KEYSIG:\t/* remove the empty key signatures */\n\t\t\t\tif (s->u.key.empty) {\n\t\t\t\t\tif (s->prev)\n\t\t\t\t\t\ts->prev->next = s->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tp_voice->sym = s->next;\n\t\t\t\t\tif (s->next)\n\t\t\t\t\t\ts->next->prev = s->prev;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tcase FMTCHG:\n\t\t\t\ts2 = s->extra;\n\t\t\t\tif (s2) {\t/* dummy format */\n\t\t\t\t\tif (!ns)\n\t\t\t\t\t\tns = s2;\n\t\t\t\t\tif (s->prev) {\n\t\t\t\t\t\ts->prev->next = s2;\n\t\t\t\t\t\ts2->prev = s->prev;\n\t\t\t\t\t}\n\t\t\t\t\tif (!s->next) {\n\t\t\t\t\t\tns = NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\twhile (s2->next)\n\t\t\t\t\t\ts2 = s2->next;\n\t\t\t\t\ts->next->prev = s2;\n\t\t\t\t\ts2->next = s->next;\n\t\t\t\t}\n\t\t\t\t/* fall thru */\n\t\t\tcase TEMPO:\n\t\t\tcase PART:\n\t\t\tcase TUPLET:\n\t\t\t\tif (!ns)\n\t\t\t\t\tns = s;\n\t\t\t\tcontinue;\n\t\t\tcase MREST:\t\t/* don't shift P: and Q: */\n\t\t\t\tif (!ns)\n\t\t\t\t\tcontinue;\n\t\t\t\ts2 = (struct SYMBOL *) getarena(sizeof *s);\n\t\t\t\tmemset(s2, 0, sizeof *s2);\n\t\t\t\ts2->type = SPACE;\n\t\t\t\ts2->u.note.notes[1].len = -1;\n\t\t\t\ts2->flags = ABC_F_INVIS;\n\t\t\t\ts2->voice = s->voice;\n\t\t\t\ts2->staff = s->staff;\n\t\t\t\ts2->time = s->time;\n\t\t\t\ts2->sflags = s->sflags;\n\t\t\t\ts2->next = s;\n\t\t\t\ts2->prev = s->prev;\n\t\t\t\ts2->prev->next = s2;\n\t\t\t\ts->prev = s2;\n\t\t\t\ts = s2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s->flags & ABC_F_GRACE) {\n\t\t\t\tif (!ns)\n\t\t\t\t\tns = s;\n\t\t\t\twhile (!(s->flags & ABC_F_GR_END))\n\t\t\t\t\ts = s->next;\n\t\t\t\ts2 = (struct SYMBOL *) getarena(sizeof *s);\n\t\t\t\tmemcpy(s2, s, sizeof *s2);\n\t\t\t\ts2->abc_type = 0;\n\t\t\t\ts2->type = GRACE;\n\t\t\t\ts2->dur = 0;\n\t\t\t\ts2->next = s->next;\n\t\t\t\tif (s2->next) {\n\t\t\t\t\ts2->next->prev = s2;\n\t\t\t\t\tif (cfmt.graceword) {\n\t\t\t\t\t\tfor (s3 = s2->next; s3; s3 = s3->next) {\n\t\t\t\t\t\t\tswitch (s3->type) {\n\t\t\t\t\t\t\tcase SPACE:\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tcase NOTEREST:\n\t\t\t\t\t\t\t\ts2->ly = s3->ly;\n\t\t\t\t\t\t\t\ts3->ly = NULL;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp_voice->last_sym = s2;\n\t\t\t\t}\n\t\t\t\ts2->prev = s;\n\t\t\t\ts->next = s2;\n\t\t\t\ts = s2;\n\n\t\t\t\t// with w_tb[BAR] = 2,\n\t\t\t\t// the grace notes go after the bar\n\t\t\t\t// if before a bar, change the grace time\n\t\t\t\tif (s->next && s->next->type == BAR)\n\t\t\t\t\ts->time--;\n\t\t\t}\n\t\t\tif (!ns)\n\t\t\t\tcontinue;\n\t\t\ts->extra = ns;\n\t\t\ts->prev->next = NULL;\n\t\t\ts->prev = ns->prev;\n\t\t\tif (s->prev)\n\t\t\t\ts->prev->next = s;\n\t\t\telse\n\t\t\t\tp_voice->sym = s;\n\t\t\tns->prev = NULL;\n\t\t\tns = NULL;\n\t\t}\n\n\t\t/* when symbols with no space at end of tune,\n\t\t * add a dummy format */\n\t\tif (ns) {\n\t\t\ts = sym_add(p_voice, FMTCHG);\n\t\t\ts->aux = -1;\t\t/* nothing */\n\t\t\ts->extra = ns;\n\t\t\ts->prev->next = NULL;\t/* unlink */\n\t\t\ts->prev = ns->prev;\n\t\t\tif (s->prev)\n\t\t\t\ts->prev->next = s;\n\t\t\telse\n\t\t\t\tp_voice->sym = s;\n\t\t\tns->prev = NULL;\n\t\t}\n\t}\n}\n\n/* -- duplicate the voices as required -- */\nstatic void voice_dup(void)\n{\n\tstruct VOICE_S *p_voice, *p_voice2;\n\tstruct SYMBOL *s, *s2, *g, *g2;\n\tint voice;\n\n\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next) {\n\t\tif ((voice = p_voice->clone) < 0)\n\t\t\tcontinue;\n\t\tp_voice->clone = -1;\n\t\tp_voice2 = &voice_tb[voice];\n\t\tfor (s = p_voice->sym; s; s = s->next) {\n//fixme: there may be other symbols before the %%staves at this same time\n\t\t\tif (s->time >= staves_found)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor ( ; s; s = s->next) {\n\t\t\tif (s->type == STAVES)\n\t\t\t\tcontinue;\n\t\t\ts2 = (struct SYMBOL *) getarena(sizeof *s2);\n\t\t\tmemcpy(s2, s, sizeof *s2);\n\t\t\ts2->prev = p_voice2->last_sym;\n\t\t\ts2->next = NULL;\n\t\t\tif (p_voice2->sym)\n\t\t\t\tp_voice2->last_sym->next = s2;\n\t\t\telse\n\t\t\t\tp_voice2->sym = s2;\n\t\t\tp_voice2->last_sym = s2;\n\t\t\ts2->voice = voice;\n\t\t\ts2->staff = p_voice2->staff;\n\t\t\tif (p_voice2->second)\n\t\t\t\ts2->sflags |= S_SECOND;\n\t\t\telse\n\t\t\t\ts2->sflags &= ~S_SECOND;\n\t\t\tif (p_voice2->floating)\n\t\t\t\ts2->sflags |= S_FLOATING;\n\t\t\telse\n\t\t\t\ts2->sflags &= ~S_FLOATING;\n\t\t\ts2->ly = NULL;\n\t\t\tg = s2->extra;\n\t\t\tif (!g)\n\t\t\t\tcontinue;\n\t\t\tg2 = (struct SYMBOL *) getarena(sizeof *g2);\n\t\t\tmemcpy(g2, g, sizeof *g2);\n\t\t\ts2->extra = g2;\n\t\t\ts2 = g2;\n\t\t\ts2->voice = voice;\n\t\t\ts2->staff = p_voice2->staff;\n\t\t\tfor (g = g->next; g; g = g->next) {\n\t\t\t\tg2 = (struct SYMBOL *) getarena(sizeof *g2);\n\t\t\t\tmemcpy(g2, g, sizeof *g2);\n\t\t\t\ts2->next = g2;\n\t\t\t\tg2->prev = s2;\n\t\t\t\ts2 = g2;\n\t\t\t\ts2->voice = voice;\n\t\t\t\ts2->staff = p_voice2->staff;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* -- create a new staff system -- */\nstatic void system_new(void)\n{\n\tstruct SYSTEM *new_sy;\n\tint staff, voice;\n\n\tnew_sy = (struct SYSTEM *) getarena(sizeof *new_sy);\n\tif (!parsys) {\n\t\tmemset(new_sy, 0, sizeof *new_sy);\n\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\tnew_sy->voice[voice].range = -1;\n\t\t}\n\t\tfor (staff = 0; staff < MAXSTAFF; staff++) {\n\t\t\tnew_sy->staff[staff].stafflines = \"|||||\";\n\t\t\tnew_sy->staff[staff].staffscale = 1;\n\t\t}\n\t\tcursys = new_sy;\n\t} else {\n\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\n\t\t\t// update the previous system\n//\t\t\tif (parsys->voice[voice].range < 0\n//\t\t\t || parsys->voice[voice].second)\n//\t\t\t\tcontinue;\n\t\t\tstaff = parsys->voice[voice].staff;\n\t\t\tif (voice_tb[voice].stafflines)\n\t\t\t\tparsys->staff[staff].stafflines =\n\t\t\t\t\t\tvoice_tb[voice].stafflines;\n\t\t\tif (voice_tb[voice].staffscale != 0)\n\t\t\t\tparsys->staff[staff].staffscale =\n\t\t\t\t\t\tvoice_tb[voice].staffscale;\n\t\t}\n\t\tmemcpy(new_sy, parsys, sizeof *new_sy);\n\t\t\n\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\tnew_sy->voice[voice].range = -1;\n\t\t\tnew_sy->voice[voice].second = 0;\n\t\t}\n\t\tfor (staff = 0; staff < MAXSTAFF; staff++)\n\t\t\tnew_sy->staff[staff].flags = 0;\n\t\tparsys->next = new_sy;\n\t}\n\tparsys = new_sy;\n}\n\n/* -- initialize the voices and staves -- */\n/* this routine is called when starting the generation */\nstatic void system_init(void)\n{\n\tvoice_compress();\n\tvoice_dup();\n\tsort_all();\t\t\t/* define the time / vertical sequences */\n//\tif (!tsfirst)\n//\t\treturn;\n//\tparsys->nstaff = nstaff;\t/* save the number of staves */\n}\n\n/* go to a global (measure + time) */\nstatic struct SYMBOL *go_global_time(struct SYMBOL *s,\n\t\t\t\tstruct symsel_s *symsel)\n{\n\tstruct SYMBOL *s2;\n\tint bar_time;\n\n\tif (symsel->bar <= 1) {\t\t/* special case: there is no measure 0/1 */\n//\t && nbar == -1) {\t\t/* see set_bar_num */\n\t\tif (symsel->bar == 0)\n\t\t\tgoto chk_time;\n\t\tfor (s2 = s; s2; s2 = s2->ts_next) {\n\t\t\tif (s2->type == BAR\n\t\t\t && s2->time != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (s2->time < voice_tb[cursys->top_voice].meter.wmeasure)\n\t\t\ts = s2;\n\t\tgoto chk_time;\n\t}\n\tfor ( ; s; s = s->ts_next) {\n\t\tif (s->type == BAR\n\t\t && s->aux >= symsel->bar)\n\t\t\tbreak;\n\t}\n\tif (!s)\n\t\treturn NULL;\n\tif (symsel->seq != 0) {\n\t\tint seq;\n\n\t\tseq = symsel->seq;\n\t\tfor (s = s->ts_next; s; s = s->ts_next) {\n\t\t\tif (s->type == BAR\n\t\t\t && s->aux == symsel->bar) {\n\t\t\t\tif (--seq == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!s)\n\t\t\treturn NULL;\n\t}\n\nchk_time:\n\tif (symsel->time == 0)\n\t\treturn s;\n\tbar_time = s->time + symsel->time;\n\twhile (s->time < bar_time) {\n\t\ts = s->ts_next;\n\t\tif (!s)\n\t\t\treturn s;\n\t}\n\tdo {\n\t\ts = s->ts_prev;\t\t/* go back to the previous sequence */\n\t} while (!(s->sflags & S_SEQST));\n\treturn s;\n}\n\n/* treat %%clip */\nstatic void do_clip(void)\n{\n\tstruct SYMBOL *s, *s2;\n\tstruct SYSTEM *sy;\n\tstruct VOICE_S *p_voice;\n\tint voice;\n\n\t/* remove the beginning of the tune */\n\ts = tsfirst;\n\tif (clip_start.bar > 0\n\t || clip_start.time > 0) {\n\t\ts = go_global_time(s, &clip_start);\n\t\tif (!s) {\n\t\t\ttsfirst = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\t/* update the start of voices */\n\t\tsy = cursys;\n\t\tfor (s2 = tsfirst; s2 != s; s2 = s2->ts_next) {\n\t\t\tif (s->sflags & S_NEW_SY)\n\t\t\t\tsy = sy->next;\n\t\t\tswitch (s2->type) {\n\t\t\tcase CLEF:\n\t\t\t\tvoice_tb[s2->voice].s_clef = s2;\n\t\t\t\tbreak;\n\t\t\tcase KEYSIG:\n\t\t\t\tmemcpy(&voice_tb[s2->voice].key, &s2->u.key,\n\t\t\t\t\tsizeof voice_tb[0].key);\n\t\t\t\tbreak;\n\t\t\tcase TIMESIG:\n\t\t\t\tmemcpy(&voice_tb[s2->voice].meter, &s2->u.meter,\n\t\t\t\t\tsizeof voice_tb[0].meter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcursys = sy;\n\t\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next) {\n\t\t\tvoice = p_voice - voice_tb;\n\t\t\tfor (s2 = s; s2; s2 = s2->ts_next) {\n\t\t\t\tif (s2->voice == voice) {\n\t\t\t\t\ts2->prev = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp_voice->sym = s2;\n\t\t}\n\t\ttsfirst = s;\n\t\ts->ts_prev = NULL;\n\t}\n\n\t/* remove the end of the tune */\n\ts = go_global_time(s, &clip_end);\n\tif (!s)\n\t\treturn;\n\n\t/* keep the current sequence */\n\tdo {\n\t\ts = s->ts_next;\n\t\tif (!s)\n\t\t\treturn;\n\t} while (!(s->sflags & S_SEQST));\n\n\t/* cut the voices */\n\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next) {\n\t\tvoice = p_voice - voice_tb;\n\t\tfor (s2 = s->ts_prev; s2; s2 = s2->ts_prev) {\n\t\t\tif (s2->voice == voice) {\n\t\t\t\ts2->next = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!s2)\n\t\t\tp_voice->sym = NULL;\n\t}\n\ts->ts_prev->ts_next = NULL;\n}\n\n/* -- set the bar numbers and treat %%clip / %%break -- */\nstatic void set_bar_num(void)\n{\n\tstruct SYMBOL *s, *s2, *s3;\n\tint bar_time, wmeasure, tim;\n\tint bar_num, bar_rep;\n\n\twmeasure = voice_tb[cursys->top_voice].meter.wmeasure;\n\tbar_rep = nbar;\n\n\t/* don't count a bar at start of line */\n\tfor (s = tsfirst; ; s = s->ts_next) {\n\t\tif (!s)\n\t\t\treturn;\n\t\tswitch (s->type) {\n\t\tcase TIMESIG:\n\t\tcase CLEF:\n\t\tcase KEYSIG:\n\t\tcase FMTCHG:\n\t\tcase STBRK:\n\t\t\tcontinue;\n\t\tcase BAR:\n\t\t\tif (s->aux) {\n\t\t\t\tnbar = s->aux;\t\t/* (%%setbarnb) */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s->u.bar.repeat_bar\n\t\t\t && s->text\n\t\t\t && !cfmt.contbarnb) {\n\t\t\t\tif (s->text[0] == '1') {\n\t\t\t\t\tbar_rep = nbar;\n\t\t\t\t} else {\n\t\t\t\t\tnbar = bar_rep; /* restart bar numbering */\n\t\t\t\t\ts->aux = nbar;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* set the measure number on the top bars\n\t * and move the clefs before the measure bars */\n\tbar_time = s->time + wmeasure;\t/* for incomplete measure at start of tune */\n\tbar_num = nbar;\n\tfor ( ; s; s = s->ts_next) {\n\t\tswitch (s->type) {\n\t\tcase CLEF:\n\t\t\tif (s->sflags & S_NEW_SY)\n\t\t\t\tbreak;\n\t\t\tfor (s2 = s->ts_prev; s2; s2 = s2->ts_prev) {\n\t\t\t\tif (s2->sflags & S_NEW_SY) {\n\t\t\t\t\ts2 = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (s2->type) {\n\t\t\t\tcase BAR:\n\t\t\t\t\tif (s2->sflags & S_SEQST)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase MREST:\n\t\t\t\tcase NOTEREST:\n\t\t\t\tcase SPACE:\n\t\t\t\tcase STBRK:\n\t\t\t\tcase TUPLET:\n\t\t\t\t\ts2 = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!s2)\n\t\t\t\tbreak;\n\n\t\t\t/* move the clef */\n\t\t\ts->next->prev = s->prev;\n\t\t\ts->prev->next = s->next;\n\t\t\ts->ts_next->ts_prev = s->ts_prev;\n\t\t\ts->ts_prev->ts_next = s->ts_next;\n\t\t\ts->next = s2;\n\t\t\ts->prev = s2->prev;\n\t\t\tif (s->prev)\n\t\t\t\ts->prev->next = s;\n\t\t\ts2->prev = s;\n\t\t\ts->ts_next = s2;\n\t\t\ts->ts_prev = s2->ts_prev;\n\t\t\tif (s->ts_prev)\n\t\t\t\ts->ts_prev->ts_next = s;\n\t\t\ts2->ts_prev = s;\n//\t\t\tif (s->sflags & S_NEW_SY) {\n//\t\t\t\ts->sflags &= ~S_NEW_SY;\n//\t\t\t\ts->ts_next->sflags |= S_NEW_SY;\n//\t\t\t}\n\t\t\ts3 = s->extra;\n\t\t\tif (s3) {\n\t\t\t\tif (s->ts_next->extra) {\n\t\t\t\t\twhile (s3->next)\n\t\t\t\t\t\ts3 = s3->next;\n\t\t\t\t\ts3->next = s->ts_next->extra;\n\t\t\t\t\ts->ts_next->extra = s->extra;\n\t\t\t\t} else {\n\t\t\t\t\ts->ts_next->extra = s3;\n\t\t\t\t}\n\t\t\t\ts->extra = NULL;\n\t\t\t}\n\t\t\ts = s2;\n\t\t\tbreak;\n\t\tcase TIMESIG:\n\t\t\twmeasure = s->u.meter.wmeasure;\n\t\t\tif (s->time < bar_time)\n\t\t\t\tbar_time = s->time + wmeasure;\n\t\t\tbreak;\n\t\tcase MREST:\n\t\t\tbar_num += s->u.bar.len - 1;\n\t\t\twhile (s->ts_next\n\t\t\t    && s->ts_next->type != BAR)\n\t\t\t\ts = s->ts_next;\n\t\t\tbreak;\n\t\tcase BAR:\n//\t\t\tif (s->flags & ABC_F_INVIS)\n//\t\t\t\tbreak;\n\t\t\tif (s->aux) {\n\t\t\t\tbar_num = s->aux;\t\t/* (%%setbarnb) */\n//\t\t\t\tif (s->time < bar_time) {\n//\t\t\t\t\ts->aux = 0;\n\t\t\t\t\tbreak;\n//\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (s->time < bar_time)\t/* incomplete measure */\n\t\t\t\t\tbreak;\n\t\t\t\tbar_num++;\n\t\t\t}\n\n\t\t\t/* check if any repeat bar at this time */\n\t\t\ttim = s->time;\n\t\t\ts2 = s;\n\t\t\tdo {\n\t\t\t\tif (s2->type == BAR\n\t\t\t\t && s2->u.bar.repeat_bar\n\t\t\t\t && s2->text\n\t\t\t\t && !cfmt.contbarnb) {\n\t\t\t\t\tif (s2->text[0] == '1')\n\t\t\t\t\t\tbar_rep = bar_num;\n\t\t\t\t\telse\t\t/* restart bar numbering */\n\t\t\t\t\t\tbar_num = bar_rep;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts2 = s2->next;\n\t\t\t} while (s2 && s2->time == tim);\n\t\t\ts->aux = bar_num;\n\t\t\tbar_time = s->time + wmeasure;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* do the %%clip stuff */\n\tif (clip_start.bar >= 0) {\n\t\tif (bar_num <= clip_start.bar\n\t\t || nbar > clip_end.bar) {\n\t\t\ttsfirst = NULL;\n\t\t\treturn;\n\t\t}\n\t\tdo_clip();\n\t}\n\n\t/* do the %%break stuff */\n\t{\n\t\tstruct brk_s *brk;\n\t\tint nbar_min;\n\n//\t\tif (nbar == 1)\n//\t\t\tnbar = -1;\t/* see go_global_time */\n\t\tnbar_min = nbar;\n\t\tif (nbar_min == 1)\n\t\t\tnbar_min = -1;\n\t\tfor (brk = brks; brk; brk = brk->next) {\n\t\t\tif (brk->symsel.bar <= nbar_min\n\t\t\t || brk->symsel.bar > bar_num)\n\t\t\t\tcontinue;\n\t\t\ts = go_global_time(tsfirst, &brk->symsel);\n\t\t\tif (s)\n\t\t\t\ts->sflags |= S_EOLN;\n\t\t}\n\t}\n\tif (cfmt.measurenb < 0)\t\t/* if no display of measure bar */\n\t\tnbar = bar_num;\t\t/* update in case of more music to come */\n}\n\n/* -- generate a piece of tune -- */\nstatic void generate(void)\n{\n\tint old_lvl, voice;\n\tstruct VOICE_S *p_voice;\n\n\tsystem_init();\n\tif (!tsfirst)\n\t\treturn;\t\t\t\t/* no symbol */\n\tset_bar_num();\n\tif (!tsfirst)\n\t\treturn;\t\t\t\t/* no more symbol */\n\told_lvl = lvlarena(2);\n\toutput_music();\n\tclrarena(2);\t\t\t\t/* clear generation */\n\tlvlarena(old_lvl);\n\n\t/* reset the parser */\n\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next) {\n\t\tvoice = p_voice - voice_tb;\n\t\tp_voice->sym = p_voice->last_sym = NULL;\n\t\tp_voice->time = 0;\n\t\tp_voice->have_ly = 0;\n\t\tp_voice->staff = cursys->voice[voice].staff;\n\t\tp_voice->second = cursys->voice[voice].second;\n\t\tp_voice->s_clef->time = 0;\n\t\tp_voice->lyric_start = NULL;\n\t}\n\tstaves_found = 0;\t\t// (for voice compress/dup)\n}\n\n/* -- output the music and lyrics after tune -- */\nstatic void gen_ly(int eob)\n{\n\tgenerate();\n\tif (info['W' - 'A']) {\n\t\tput_words(info['W' - 'A']);\n\t\tinfo['W' - 'A'] = NULL;\n\t}\n\tif (eob)\n\t\tbuffer_eob(0);\n}\n\n/*\n * for transpose purpose, check if a pitch is already in the measure or\n * if it is tied from a previous note, and return the associated accidental\n */\nstatic int acc_same_pitch(int pitch)\n{\n\tstruct SYMBOL *s = curvoice->last_sym->prev;\n\tint i, time;\n\n\t// the overlaid voices may have no measure bars\n//\tif (curvoice->id[0] == '&')\n//\t\ts = voice_tb[curvoice->mvoice].last_sym;\n\n\tif (!s)\n\t\treturn -1;\n\n\ttime = s->time;\n\n\tfor (; s; s = s->prev) {\n\t\tswitch (s->abc_type) {\n\t\tcase ABC_T_BAR:\n\t\t\tif (s->time < time)\n\t\t\t\treturn -1;\t/* no same pitch */\n\t\t\tfor (;;) {\n\t\t\t\ts = s->prev;\n\t\t\t\tif (!s)\n\t\t\t\t\treturn -1;\n\t\t\t\tif (s->abc_type == ABC_T_NOTE) {\n\t\t\t\t\tif (s->time + s->dur == time)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (s->time < time)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i <= s->nhd; i++) {\n\t\t\t\tif (s->u.note.notes[i].pit == pitch\n\t\t\t\t && s->u.note.notes[i].ti1)\n\t\t\t\t\treturn s->u.note.notes[i].acc;\n\t\t\t}\n\t\t\treturn -1;\n\t\tcase ABC_T_NOTE:\n\t\t\tfor (i = 0; i <= s->nhd; i++) {\n\t\t\t\tif (s->u.note.notes[i].pit == pitch)\n\t\t\t\t\treturn s->u.note.notes[i].acc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* transpose a note / chord */\nstatic void note_transpose(struct SYMBOL *s)\n{\n\tint i, j, m, n, d, a, dp, i1, i2, i3, i4, sf_old;\n\tstatic const signed char acc1[6] = {0, 1, 0, -1, 2, -2};\n\tstatic const char acc2[5] = {A_DF, A_FT, A_NT, A_SH, A_DS};\n\n\tm = s->nhd;\n\tsf_old = curvoice->okey.sf;\n\ti2 = curvoice->ckey.sf - sf_old;\n\tdp = cgd2cde[(i2 + 4 * 7) % 7];\n\tif (curvoice->transpose < 0\n\t && dp != 0)\n\t\tdp -= 7;\n\tdp += curvoice->transpose / 3 / 12 * 7;\n\tfor (i = 0; i <= m; i++) {\n\n\t\t/* pitch */\n\t\tn = s->u.note.notes[i].pit;\n\t\ts->u.note.notes[i].pit += dp;\n\t\ts->pits[i] += dp;\n\n\t\t/* accidental */\n\t\ti1 = cde2fcg[(n + 5 + 16 * 7) % 7];\t/* fcgdaeb */\n\t\ta = s->u.note.notes[i].acc & 0x07;\n\t\tif (a == 0) {\n\t\t\tif (curvoice->okey.nacc == 0) {\n\t\t\t\tif (sf_old > 0) {\n\t\t\t\t\tif (i1 < sf_old - 1)\n\t\t\t\t\t\ta = A_SH;\n\t\t\t\t} else if (sf_old < 0) {\n\t\t\t\t\tif (i1 >= sf_old + 6)\n\t\t\t\t\t\ta = A_FT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < curvoice->okey.nacc; j++) {\n\t\t\t\t\tif ((n + 16 * 7 - curvoice->okey.pits[j]) % 7\n\t\t\t\t\t\t\t\t== 0) {\n\t\t\t\t\t\ta = curvoice->okey.accs[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti3 = i1 + i2 + acc1[a] * 7;\n\n\t\ti1 = ((i3 + 1 + 21) / 7 + 2 - 3 + 32 * 5) % 5;\n\t\ta = acc2[(unsigned) i1];\n\t\tif (s->u.note.notes[i].acc != 0) {\n\t\t\t;\n\t\t} else if (curvoice->ckey.empty) {\t/* key none */\n\t\t\tif (a == A_NT\n\t\t\t || acc_same_pitch(s->u.note.notes[i].pit) >= 0)\n\t\t\t\tcontinue;\n\t\t} else if (curvoice->ckey.nacc > 0) {\t/* acc list */\n\t\t\ti4 = cgd2cde[(unsigned) ((i3 + 16 * 7) % 7)];\n\t\t\tfor (j = 0; j < curvoice->ckey.nacc; j++) {\n\t\t\t\tif ((i4 + 16 * 7 - curvoice->ckey.pits[j]) % 7\n\t\t\t\t\t\t\t== 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j < curvoice->ckey.nacc)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\ti1 = s->u.note.notes[i].acc & 0x07;\n\t\ti4 = s->u.note.notes[i].acc >> 3;\n\t\tif (i4 != 0\t\t\t\t/* microtone */\n\t\t && i1 != a) {\t\t\t\t/* different accidental type */\n\t\t\tif (s->u.note.microscale) {\n\t\t\t\tn = i4;\n\t\t\t\td = s->u.note.microscale;\n\t\t\t} else {\n\t\t\t\tn = parse.micro_tb[i4];\n\t\t\t\td = ((n & 0xff) + 1) * 2;\n\t\t\t\tn = (n >> 8) + 1;\n\t\t\t}\n//fixme: double sharps/flats ?*/\n//fixme: does not work in all cases (tied notes, previous accidental)\n\t\t\tswitch (a) {\n\t\t\tcase A_NT:\n\t\t\t\tif (n >= d / 2) {\n\t\t\t\t\tn -= d / 2;\n\t\t\t\t\ta = i1;\n\t\t\t\t} else {\n\t\t\t\t\ta = i1 == A_SH ? A_FT : A_SH;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase A_DS:\n\t\t\t\tif (n >= d / 2) {\n\t\t\t\t\ts->u.note.notes[i].pit += 1;\n\t\t\t\t\ts->pits[i] += 1;\n\t\t\t\t\tn -= d / 2;\n\t\t\t\t} else {\n\t\t\t\t\tn += d / 2;\n\t\t\t\t}\n\t\t\t\ta = i1;\n\t\t\t\tbreak;\n\t\t\tcase A_DF:\n\t\t\t\tif (n >= d / 2) {\n\t\t\t\t\ts->u.note.notes[i].pit -= 1;\n\t\t\t\t\ts->pits[i] -= 1;\n\t\t\t\t\tn -= d / 2;\n\t\t\t\t} else {\n\t\t\t\t\tn += d / 2;\n\t\t\t\t}\n\t\t\t\ta = i1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s->u.note.microscale) {\n\t\t\t\ti4 = n;\n\t\t\t} else {\n\t\t\t\td = d / 2 - 1 + ((n - 1) << 8);\n\t\t\t\tfor (i4 = 1; i4 < MAXMICRO; i4++) {\n\t\t\t\t\tif (parse.micro_tb[i4] == d)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (parse.micro_tb[i4] == 0) {\n\t\t\t\t\t\tparse.micro_tb[i4] = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i4 == MAXMICRO) {\n\t\t\t\t\terror(1, s, \"Too many microtone accidentals\");\n\t\t\t\t\ti4 = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts->u.note.notes[i].acc = (i4 << 3) | a;\n\t}\n}\n\n/* transpose a guitar chord */\nstatic void gch_tr1(struct SYMBOL *s, int i, int i2)\n{\n\tchar *p = &s->text[i],\n\t\t*q = p + 1,\n\t\t*new_txt;\n\tint l, latin;\n\tint n, a, i1, i3, i4;\n\tstatic const char note_names[] = \"CDEFGAB\";\n\tstatic const char *latin_names[7] =\n\t\t\t{ \"Do\", \"R\u00e9\", \"Mi\", \"Fa\", \"Sol\", \"La\", \"Si\" };\n\tstatic const char *acc_name[5] = {\"bb\", \"b\", \"\", \"#\", \"##\"};\n\n\t/* main chord */\n\tlatin = 0;\n\tswitch (*p) {\n\tcase 'A':\n\tcase 'B':\n\t\tn = *p - 'A' + 5;\n\t\tbreak;\n\tcase 'C':\n\tcase 'E':\n\tcase 'G':\n\t\tn = *p - 'C';\n\t\tbreak;\n\tcase 'D':\n\t\tif (p[1] == 'o') {\n\t\t\tlatin++;\n\t\t\tn = 0;\t\t/* Do */\n\t\t\tbreak;\n\t\t}\n\t\tn = 1;\n\t\tbreak;\n\tcase 'F':\n\t\tif (p[1] == 'a')\n\t\t\tlatin++;\t/* Fa */\n\t\tn = 3;\n\t\tbreak;\n\tcase 'L':\n\t\tlatin++;\t\t/* La */\n\t\tn = 5;\n\t\tbreak;\n\tcase 'M':\n\t\tlatin++;\t\t/* Mi */\n\t\tn = 2;\n\t\tbreak;\n\tcase 'R':\n\t\tlatin++;\n\t\tif (p[1] != 'e')\n\t\t\tlatin++;\t/* R\u00e9 */\n\t\tn = 1;\t\t\t/* Re */\n\t\tbreak;\n\tcase 'S':\n\t\tlatin++;\n\t\tif (p[1] == 'o') {\n\t\t\tlatin++;\n\t\t\tn = 4;\t\t/* Sol */\n\t\t} else {\n\t\t\tn = 6;\t\t/* Si */\n\t\t}\n\t\tbreak;\n\tcase '/':\t\t\t// bass only\n\t\tlatin--;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tq += latin;\n\n\t/* allocate a new string */\n\tnew_txt = getarena(strlen(s->text) + 6);\n\tl = p - s->text;\n\tmemcpy(new_txt, s->text, l);\n\ts->text = new_txt;\n\tnew_txt += l;\n\tp = q;\n\n\tif (latin >= 0) {\t\t\t// if some chord\n\t\ta = 0;\n\t\twhile (*p == '#') {\n\t\t\ta++;\n\t\t\tp++;\n\t\t}\n\t\twhile (*p == 'b') {\n\t\t\ta--;\n\t\t\tp++;\n\t\t}\n//\t\tif (*p == '=')\n//\t\t\tp++;\n\t\ti3 = cde2fcg[n] + i2 + a * 7;\n\t\ti4 = cgd2cde[(unsigned) ((i3 + 16 * 7) % 7)];\n\t\ti1 = ((i3 + 1 + 21) / 7 + 2 - 3 + 32 * 5) % 5;\n\t\t\t\t\t\t\t/* accidental */\n\t\tif (latin == 0)\n\t\t\t*new_txt++ = note_names[i4];\n\t\telse\n\t\t\tnew_txt += sprintf(new_txt, \"%s\", latin_names[i4]);\n\t\tnew_txt += sprintf(new_txt, \"%s\", acc_name[i1]);\n\t}\n\n\t/* bass */\n\twhile (*p != '\\0' && *p != '\\n' && *p != '/')\t// skip 'm'/'dim'..\n\t\t*new_txt++ = *p++;\n\tif (*p == '/') {\n\t\t*new_txt++ = *p++;\n//fixme: latin names not treated\n\t\tq = strchr(note_names, *p);\n\t\tif (q) {\n\t\t\tp++;\n\t\t\tn = q - note_names;\n\t\t\tif (*p == '#') {\n\t\t\t\ta = 1;\n\t\t\t\tp++;\n\t\t\t} else if (*p == 'b') {\n\t\t\t\ta = -1;\n\t\t\t\tp++;\n\t\t\t} else {\n\t\t\t\ta = 0;\n\t\t\t}\n\t\t\ti3 = cde2fcg[n] + i2 + a * 7;\n\t\t\ti4 = cgd2cde[(unsigned) ((i3 + 16 * 7) % 7)];\n\t\t\ti1 = ((i3 + 1 + 21) / 7 + 2 - 3 + 32 * 5) % 5;\n\t\t\t*new_txt++ = note_names[i4];\n\t\t\tnew_txt += sprintf(new_txt, \"%s\", acc_name[i1]);\n\t\t}\n\t}\n\tstrcpy(new_txt, p);\n}\n\nstatic void gch_capo(struct SYMBOL *s)\n{\n\tchar *p = s->text, *q, *r;\n\tint i, l, li = 0;\n\tstatic const char *capo_txt = \"  (capo: %d)\";\n\tstatic signed char cap_trans[] =\n\t\t{0, 5, -2, 3, -4, 1, -6, -1, 4, -3, 2, -5};\n\n\t// search the chord symbols\n\tfor (;;) {\n\t\tif (!strchr(\"^_<>@\", *p))\n\t\t\tbreak;\n\t\tp = strchr(p, '\\n');\n\t\tif (!p)\n\t\t\treturn;\n\t\tp++;\n\t}\n\n\t// add a capo chord symbol\n\ti = p - s->text;\n\tq = strchr(p + 1, '\\n');\n\tif (q)\n\t\tl = q - p;\n\telse\n\t\tl = strlen(p);\n\tif (!capo) {\n\t\tcapo = 1;\n\t\tli = strlen(capo_txt);\n\t}\n\tr = (char *) getarena(strlen(s->text) + l + li + 1);\n\ti += l;\n\tstrncpy(r, s->text, i);\t\t// annotations + chord symbol\n\tr[i++] = '\\n';\n\tstrncpy(r + i, p, l);\t\t// capo\n\tif (li) {\n\t\tsprintf(r + i + l, capo_txt, cfmt.capo);\n\t\tl += li;\n\t}\n\tif (q)\n\t\tstrcpy(r + i + l, q);\t// ending annotations\n\ts->text = r;\n\tgch_tr1(s, i, cap_trans[cfmt.capo % 12]);\n}\n\nstatic void gch_transpose(struct SYMBOL *s)\n{\n\tint in_ch = 0;\n\tint i2 = curvoice->ckey.sf - curvoice->okey.sf;\n\tchar *o = s->text, *p = o;\n\n\t// search the chord symbols\n\tfor (;;) {\n\t\tif (in_ch || !strchr(\"^_<>@\", *p)) {\n\t\t\tgch_tr1(s, p - s->text, i2);\n\t\t\tp = s->text + (p - o);\n\t\t\to = s->text;\n\t\t\tfor (p++; *p; p++) {\n\t\t\t\tif (strchr(\"\\t;\\n\", *p))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*p)\n\t\t\t\tbreak;\n\t\t\tswitch (*p) {\n\t\t\tcase '\\t':\n\t\t\t\tin_ch = 1;\n\t\t\t\tbreak;\n\t\t\tcase ';':\n\t\t\t\tin_ch = !strchr(\"^_<>@\", p[1]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tin_ch = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tp = strchr(p, '\\n');\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n}\n\n/* -- build the guitar chords / annotations -- */\nstatic void gch_build(struct SYMBOL *s)\n{\n\tstruct gch *gch;\n\tchar *p, *q, antype, sep;\n\tfloat w, h_ann, h_gch, y_above, y_below, y_left, y_right;\n\tfloat xspc;\n\tint l, ix, box, gch_place;\n\n\tif (s->posit.gch == SL_HIDDEN)\n\t\treturn;\n\ts->gch = getarena(sizeof *s->gch * MAXGCH);\n\tmemset(s->gch, 0, sizeof *s->gch * MAXGCH);\n\n\tif (curvoice->transpose != 0)\n\t\tgch_transpose(s);\n\tif (cfmt.capo)\n\t\tgch_capo(s);\n\n\t/* split the guitar chords / annotations\n\t * and initialize their vertical offsets */\n\tgch_place = s->posit.gch == SL_BELOW ? -1 : 1;\n\th_gch = cfmt.font_tb[cfmt.gcf].size;\n\th_ann = cfmt.font_tb[cfmt.anf].size;\n\ty_above = y_below = y_left = y_right = 0;\n\tbox = cfmt.gchordbox;\n\tp = s->text;\n\tgch = s->gch;\n\tsep = '\\n';\n\tantype = 'g';\t\t\t/* (compiler warning) */\n\tfor (;;) {\n\t\tif (sep != 'n' && strchr(\"^_<>@\", *p)) {\n\t\t\tgch->font = cfmt.anf;\n\t\t\tantype = *p++;\n\t\t\tif (antype == '@') {\n\t\t\t\tint n;\n\t\t\t\tfloat xo, yo;\n\n\t\t\t\tif (sscanf(p, \"%f,%f%n\", &xo, &yo, &n) != 2) {\n\t\t\t\t\terror(1, s, \"Error in annotation \\\"@\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tp += n;\n\t\t\t\t\tif (*p == ' ')\n\t\t\t\t\t\tp++;\n\t\t\t\t\tgch->x = xo;\n\t\t\t\t\tgch->y = yo;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (sep == '\\n') {\n\t\t\tgch->font = cfmt.gcf;\n\t\t\tgch->box = box;\n\t\t\tantype = 'g';\n\t\t} else {\n\t\t\tgch->font = (gch - 1)->font;\n\t\t\tgch->box = (gch - 1)->box;\n\t\t}\n\t\tgch->type = antype;\n\t\tswitch (antype) {\n\t\tdefault:\t\t\t\t/* guitar chord */\n\t\t\tif (gch_place < 0)\n\t\t\t\tbreak;\t\t\t/* below */\n\t\t\ty_above += h_gch;\n\t\t\tif (box)\n\t\t\t\ty_above += 2;\n\t\t\tbreak;\n\t\tcase '^':\t\t\t\t/* above */\n\t\t\ty_above += h_ann;\n\t\t\tbreak;\n\t\tcase '_':\t\t\t\t/* below */\n\t\t\tbreak;\n\t\tcase '<':\t\t\t\t/* left */\n\t\t\ty_left += h_ann * 0.5;\n\t\t\tbreak;\n\t\tcase '>':\t\t\t\t/* right */\n\t\t\ty_right += h_ann * 0.5;\n\t\t\tbreak;\n\t\tcase '@':\t\t\t\t/* absolute */\n\t\t\tif (gch->x == 0 && gch->y == 0\n\t\t\t && gch != s->gch\n\t\t\t && s->gch->type == '@') {\t/* if not 1st line */\n\t\t\t\tgch->x = (gch - 1)->x;\n\t\t\t\tgch->y = (gch - 1)->y - h_ann;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgch->idx = p - s->text;\n\t\tfor (;;) {\n\t\t\tswitch (*p) {\n\t\t\tdefault:\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\tcase '\\\\':\n\t\t\t\tp++;\n\t\t\t\tif (*p == 'n') {\n\t\t\t\t\tp[-1] = '\\0';\n\t\t\t\t\tbreak;\t\t/* sep = 'n' */\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\tcase '&':\t\t\t/* skip \"&xxx;\" */\n\t\t\t\tfor (;;) {\n\t\t\t\t\tswitch (*p) {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase ';':\n\t\t\t\t\t\tp++;\n\t\t\t\t\tcase '\\0':\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase '\\0':\n\t\t\tcase ';':\n\t\t\tcase '\\n':\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tsep = *p;\n\t\tif (sep == '\\0')\n\t\t\tbreak;\n\t\t*p++ = '\\0';\n\t\tgch++;\n\t\tif (gch - s->gch >= MAXGCH) {\n\t\t\terror(1, s, \"Too many guitar chords / annotations\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* change the accidentals in the guitar chords */\n\tfor (ix = 0, gch = s->gch; ix < MAXGCH; ix++, gch++) {\n\t\tif (gch->type == '\\0')\n\t\t\tbreak;\n\t\tif (gch->type != 'g')\n\t\t\tcontinue;\n\t\tp = s->text + gch->idx;\n\t\tq = p;\n\t\tfor (; *p != '\\0'; p++) {\n\t\t\tswitch (*p) {\n\t\t\tcase '#':\n\t\t\tcase 'b':\n\t\t\tcase '=':\n\t\t\t\tif (p == q\t/* 1st char or after a slash */\n\t\t\t\t || (p != q + 1\t/* or invert '\\' behaviour */\n\t\t\t\t  && p[-1] == '\\\\'))\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* set the accidentals as unused utf-8 values\n\t\t\t\t * (see subs.c) */\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase '#':\n\t\t\t\t\t*p = 0x01;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t*p = 0x02;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n/*\t\t\t\tcase '=': */\n\t\t\t\t\t*p = 0x03;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (p[-1] == '\\\\') {\n\t\t\t\t\tp--;\n\t\t\t\t\tl = strlen(p);\n\t\t\t\t\tmemmove(p, p + 1, l);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\tcase '/':\n\t\t\t\tq = p + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set the offsets and widths */\n/*fixme:utf8*/\n\tfor (ix = 0, gch = s->gch; ix < MAXGCH; ix++, gch++) {\n\t\tif (gch->type == '\\0')\n\t\t\tbreak;\n\t\tif (gch->type == '@')\n\t\t\tcontinue;\t\t/* no width */\n\t\tp = s->text + gch->idx;\n\t\tstr_font(gch->font);\n\t\tw = tex_str(p);\n\t\tgch->w = w; // + 4;\n\t\tswitch (gch->type) {\n\t\tcase '_':\t\t\t/* below */\n\t\t\txspc = w * GCHPRE;\n\t\t\tif (xspc > 8)\n\t\t\t\txspc = 8;\n\t\t\tgch->x = -xspc;\n\t\t\ty_below -= h_ann;\n\t\t\tgch->y = y_below;\n\t\t\tbreak;\n\t\tcase '^':\t\t\t/* above */\n\t\t\txspc = w * GCHPRE;\n\t\t\tif (xspc > 8)\n\t\t\t\txspc = 8;\n\t\t\tgch->x = -xspc;\n\t\t\ty_above -= h_ann;\n\t\t\tgch->y = y_above;\n\t\t\tbreak;\n\t\tdefault:\t\t\t/* guitar chord */\n\t\t\txspc = w * GCHPRE;\n\t\t\tif (xspc > 8)\n\t\t\t\txspc = 8;\n\t\t\tgch->x = -xspc;\n\t\t\tif (gch_place < 0) {\t/* below */\n\t\t\t\ty_below -= h_gch;\n\t\t\t\tgch->y = y_below;\n\t\t\t\tif (box) {\n\t\t\t\t\ty_below -= 2;\n\t\t\t\t\tgch->y -= 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ty_above -= h_gch;\n\t\t\t\tgch->y = y_above;\n\t\t\t\tif (box) {\n\t\t\t\t\ty_above -= 2;\n\t\t\t\t\tgch->y -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '<':\t\t/* left */\n\t\t\tgch->x = -(w + 6);\n\t\t\ty_left -= h_ann;\n\t\t\tgch->y = y_left;\n\t\t\tbreak;\n\t\tcase '>':\t\t/* right */\n\t\t\tgch->x = 6;\n\t\t\ty_right -= h_ann;\n\t\t\tgch->y = y_right;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* get the note which will receive a lyric word */\nstatic struct SYMBOL *next_lyric_note(struct SYMBOL *s)\n{\n\twhile (s\n\t    && (s->abc_type != ABC_T_NOTE\n\t     || (s->flags & ABC_F_GRACE)))\n\t\ts = s->next;\n\treturn s;\n}\n\n/* -- parse lyric (vocal) lines (w:) -- */\nstatic struct SYMBOL *get_lyric(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s1, *s2;\n\tchar word[128], *p, *q;\n\tint ln, cont;\n\tstruct FONTSPEC *f;\n\n\tcurvoice->have_ly = curvoice->posit.voc != SL_HIDDEN;\n\n\tif (curvoice->ignore) {\n\t\tfor (;;) {\n\t\t\tif (!s->abc_next)\n\t\t\t\treturn s;\n\t\t\tswitch (s->abc_next->abc_type) {\n\t\t\tcase ABC_T_PSCOM:\n\t\t\t\ts = process_pscomment(s->abc_next);\n\t\t\t\tcontinue;\n\t\t\tcase ABC_T_INFO:\n\t\t\t\tif (s->abc_next->text[0] == 'w'\n\t\t\t\t || s->abc_next->text[0] == '+') {\n\t\t\t\t\ts = s->abc_next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t}\n\n\tf = &cfmt.font_tb[cfmt.vof];\n\tstr_font(cfmt.vof);\t\t\t/* (for tex_str) */\n\n\t/* treat all w: lines */\n\tcont = 0;\n\tln = -1;\n\ts2 = s1 = NULL;\t\t\t\t// have gcc happy\n\tfor (;;) {\n\t\tif (!cont) {\n\t\t\tif (ln >= MAXLY- 1) {\n\t\t\t\terror(1, s, \"Too many lyric lines\");\n\t\t\t\tln--;\n\t\t\t}\n\t\t\tln++;\n\t\t\ts2 = s1;\n\t\t\ts1 = curvoice->lyric_start;\n\t\t\tif (!s1)\n\t\t\t\ts1 = curvoice->sym;\n\t\t\telse\n\t\t\t\ts1 = s1->next;\n\t\t\tif (!s1) {\n\t\t\t\terror(1, s, \"w: without music\");\n\t\t\t\treturn s;\n\t\t\t}\n\t\t} else {\n\t\t\tcont = 0;\n\t\t}\n\n\t\t/* scan the lyric line */\n\t\tp = &s->text[2];\n\t\twhile (*p != '\\0') {\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\tif (*p == '\\0')\n\t\t\t\tbreak;\n\t\t\tif (*p == '\\\\' && p[1] == '\\0') {\n\t\t\t\tcont = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (*p) {\n\t\t\tcase '|':\n\t\t\t\twhile (s1 && s1->type != BAR) {\n\t\t\t\t\ts2 = s1;\n\t\t\t\t\ts1 = s1->next;\n\t\t\t\t}\n\t\t\t\tif (!s1) {\n\t\t\t\t\terror(1, s2,\n\t\t\t\t\t\t\"Not enough bar lines for lyric line\");\n\t\t\t\t\tgoto ly_next;\n\t\t\t\t}\n\t\t\t\ts2 = s1;\n\t\t\t\ts1 = s1->next;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\tcase '-':\n\t\t\t\tword[0] = LY_HYPH;\n\t\t\t\tword[1] = '\\0';\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tcase '_':\n\t\t\t\tword[0] = LY_UNDER;\n\t\t\t\tword[1] = '\\0';\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tword[0] = '\\0';\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tq = word;\n\t\t\t\tfor (;;) {\n\t\t\t\t\tunsigned char c;\n\n\t\t\t\t\tc = *p;\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\0':\n\t\t\t\t\tcase ' ':\n\t\t\t\t\tcase '\\t':\n\t\t\t\t\tcase '_':\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase '|':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '~':\n\t\t\t\t\t\tc = ' ';\n\t\t\t\t\t\tgoto addch;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tc = LY_HYPH;\n\t\t\t\t\t\tgoto addch;\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tif (p[1] == '\\0')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tswitch (p[1]) {\n\t\t\t\t\t\tcase '~':\n\t\t\t\t\t\tcase '_':\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\tcase '|':\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\tcase ' ':\n\t\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\t\tc = *++p;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* fall thru */\n\t\t\t\t\tdefault:\n\t\t\t\t\taddch:\n\t\t\t\t\t\tif (q < &word[sizeof word - 1])\n\t\t\t\t\t\t\t*q++ = c;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (c == LY_HYPH)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*q = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* store the word in the next note */\n\t\t\tif (s1) {\t\t\t\t/* for error */\n\t\t\t\ts2 = s1;\n\t\t\t\ts1 = next_lyric_note(s1);\n\t\t\t}\n\t\t\tif (!s1) {\n\t\t\t\tif (!s2)\n\t\t\t\t\ts2 = s;\n\t\t\t\terror(1, s2, \"Too many words in lyric line\");\n\t\t\t\tgoto ly_next;\n\t\t\t}\n\t\t\tif (word[0] != '\\0'\n\t\t\t && s1->posit.voc != SL_HIDDEN) {\n\t\t\t\tstruct lyl *lyl;\n\t\t\t\tfloat w;\n\n\t\t\t\tif (!s1->ly) {\n\t\t\t\t\ts1->ly = (struct lyrics *) getarena(sizeof (struct lyrics));\n\t\t\t\t\tmemset(s1->ly, 0, sizeof (struct lyrics));\n\t\t\t\t}\n\n\t\t\t\t/* handle the font change at start of text */\n\t\t\t\tq = word;\n\t\t\t\tif (*q == '$' && isdigit((unsigned char) q[1])\n\t\t\t\t && (unsigned) (q[1] - '0') < FONT_UMAX) {\n\t\t\t\t\tint ft;\n\n\t\t\t\t\tft = q[1] - '0';\n\t\t\t\t\tif (ft == 0)\n\t\t\t\t\t\tft = cfmt.vof;\n\t\t\t\t\tf = &cfmt.font_tb[ft];\n\t\t\t\t\tstr_font(ft);\n\t\t\t\t\tq += 2;\n\t\t\t\t}\n\t\t\t\tw = tex_str(q);\n\t\t\t\tq = tex_buf;\n\t\t\t\tlyl = (struct lyl *) getarena(sizeof *s1->ly->lyl[0]\n\t\t\t\t\t\t\t- sizeof s1->ly->lyl[0]->t\n\t\t\t\t\t\t\t+ strlen(q) + 1);\n\t\t\t\ts1->ly->lyl[ln] = lyl;\n\t\t\t\tlyl->f = f;\n\t\t\t\tlyl->w = w;\n\t\t\t\tstrcpy(lyl->t, q);\n\n\t\t\t\t/* handle the font changes inside the text */\n\t\t\t\twhile (*q != '\\0') {\n\t\t\t\t\tif (*q == '$' && isdigit((unsigned char) q[1])\n\t\t\t\t\t && (unsigned) (q[1] - '0') < FONT_UMAX) {\n\t\t\t\t\t\tint ft;\n\n\t\t\t\t\t\tq++;\n\t\t\t\t\t\tft = *q - '0';\n\t\t\t\t\t\tif (ft == 0)\n\t\t\t\t\t\t\tft = cfmt.vof;\n\t\t\t\t\t\tf = &cfmt.font_tb[ft];\n\t\t\t\t\t\tstr_font(ft);\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts2 = s1;\n\t\t\ts1 = s1->next;\n\t\t}\n\n\t\t/* loop if more lyrics */\nly_next:\n\t\tfor (;;) {\n\t\t\tif (!s->abc_next)\n\t\t\t\tgoto ly_upd;\n\t\t\tswitch (s->abc_next->abc_type) {\n\t\t\tcase ABC_T_PSCOM:\n\t\t\t\ts = process_pscomment(s->abc_next);\n\t\t\t\tf = &cfmt.font_tb[cfmt.vof];\t/* may have changed */\n\t\t\t\tstr_font(cfmt.vof);\n\t\t\t\tcontinue;\n\t\t\tcase ABC_T_INFO:\n\t\t\t\tif (s->abc_next->text[0] != 'w'\n\t\t\t\t && s->abc_next->text[0] != '+')\n\t\t\t\t\tgoto ly_upd;\n\t\t\t\ts = s->abc_next;\n\t\t\t\tif (s->text[0] == '+')\n\t\t\t\t\tcont = 1;\n\t\t\t\tif (!cont) {\n\t\t\t\t\ts1 = next_lyric_note(s1);\n\t\t\t\t\tif (s1) {\n\t\t\t\t\t\terror(1, s1,\n\t\t\t\t\t\t\t\"Not enough words for lyric line\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\t\t\t/* more lyric */\n\t\t\tdefault:\n\t\t\t\tgoto ly_upd;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* the next lyrics will go into the next notes */\nly_upd:\n//fixme: no error with abc-2.1\n\tif (next_lyric_note(s1))\n\t\terror(0, s1, \"Not enough words for lyric line\");\n\t// fill the w: with 'blank syllabes'\n\tcurvoice->lyric_start = curvoice->last_sym;\n\treturn s;\n}\n\n/* -- add a voice in the linked list -- */\nstatic void voice_link(struct VOICE_S *p_voice)\n{\n\tstruct VOICE_S *p_voice2;\n\n\tp_voice2 = first_voice;\n\tfor (;;) {\n\t\tif (p_voice2 == p_voice)\n\t\t\treturn;\n\t\tif (!p_voice2->next)\n\t\t\tbreak;\n\t\tp_voice2 = p_voice2->next;\n\t}\n\tp_voice2->next = p_voice;\n}\n\n/* -- get a voice overlay -- */\nstatic void get_over(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice, *p_voice2, *p_voice3;\n\tint range, voice, voice2, voice3;\nstatic char tx_wrong_dur[] = \"Wrong duration in voice overlay\";\nstatic char txt_no_note[] = \"No note in voice overlay\";\n\n\t/* treat the end of overlay */\n\tp_voice = curvoice;\n\tif (p_voice->ignore)\n\t\treturn;\n\tif (s->abc_type == ABC_T_BAR\n\t || s->u.v_over.type == V_OVER_E)  {\n\t\tif (!p_voice->last_sym) {\n\t\t\terror(1, s, txt_no_note);\n\t\t\treturn;\n\t\t}\n\t\tp_voice->last_sym->sflags |= S_BEAM_END;\n\t\tover_bar = 0;\n\t\tif (over_time < 0) {\n\t\t\terror(1, s, \"Erroneous end of voice overlap\");\n\t\t\treturn;\n\t\t}\n\t\tif (p_voice->time != over_mxtime)\n\t\t\terror(1, s, tx_wrong_dur);\n\t\tcurvoice = &voice_tb[over_voice];\n\t\tover_mxtime = 0;\n\t\tover_voice = -1;\n\t\tover_time = -1;\n\t\treturn;\n\t}\n\n\t/* treat the full overlay start */\n\tif (s->u.v_over.type == V_OVER_S) {\n\t\tover_voice = p_voice - voice_tb;\n\t\tover_time = p_voice->time;\n\t\treturn;\n\t}\n\n\t/* (here is treated a new overlay - '&') */\n\t/* create the extra voice if not done yet */\n\tif (!p_voice->last_sym) {\n\t\terror(1, s, txt_no_note);\n\t\treturn;\n\t}\n\tp_voice->last_sym->sflags |= S_BEAM_END;\n\tvoice2 = s->u.v_over.voice;\n\tp_voice2 = &voice_tb[voice2];\n\tif (parsys->voice[voice2].range < 0) {\n\t\tint clone;\n\n\t\tif (cfmt.abc2pscompat) {\n\t\t\terror(1, s, \"Cannot have %%%%abc2pscompat\");\n\t\t\tcfmt.abc2pscompat = 0;\n\t\t}\n\t\tclone = p_voice->clone >= 0;\n\t\tp_voice2->id[0] = '&';\n\t\tp_voice2->id[1] = '\\0';\n\t\tp_voice2->second = 1;\n\t\tparsys->voice[voice2].second = 1;\n\t\tp_voice2->scale = p_voice->scale;\n\t\tp_voice2->octave = p_voice->octave;\n\t\tp_voice2->transpose = p_voice->transpose;\n\t\tmemcpy(&p_voice2->key, &p_voice->key,\n\t\t\t\t\tsizeof p_voice2->key);\n\t\tmemcpy(&p_voice2->ckey, &p_voice->ckey,\n\t\t\t\t\tsizeof p_voice2->ckey);\n\t\tmemcpy(&p_voice2->okey, &p_voice->okey,\n\t\t\t\t\tsizeof p_voice2->okey);\n\t\tp_voice2->posit = p_voice->posit;\n\t\tp_voice2->staff = p_voice->staff;\n\t\tp_voice2->cstaff = p_voice->cstaff;\n\t\tp_voice2->color = p_voice->color;\n\t\tp_voice2->map_name = p_voice->map_name;\n\t\trange = parsys->voice[p_voice - voice_tb].range;\n\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\tif (parsys->voice[voice].range > range)\n\t\t\t\tparsys->voice[voice].range += clone + 1;\n\t\t}\n\t\tparsys->voice[voice2].range = range + 1;\n\t\tvoice_link(p_voice2);\n\t\tif (clone) {\n\t\t\tfor (voice3 = MAXVOICE; --voice3 >= 0; ) {\n\t\t\t\tif (parsys->voice[voice3].range < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (voice3 > 0) {\n\t\t\t\tp_voice3 = &voice_tb[voice3];\n\t\t\t\tstrcpy(p_voice3->id, p_voice2->id);\n\t\t\t\tp_voice3->second = 1;\n\t\t\t\tparsys->voice[voice3].second = 1;\n\t\t\t\tp_voice3->scale = voice_tb[p_voice->clone].scale;\n\t\t\t\tparsys->voice[voice3].range = range + 2;\n\t\t\t\tvoice_link(p_voice3);\n\t\t\t\tp_voice2->clone = voice3;\n\t\t\t} else {\n\t\t\t\terror(1, s,\n\t\t\t\t      \"Too many voices for overlay cloning\");\n\t\t\t}\n\t\t}\n\t}\n\tvoice = p_voice - voice_tb;\n//\tp_voice2->cstaff = p_voice2->staff = parsys->voice[voice2].staff\n//\t\t\t= parsys->voice[voice].staff;\n//\tif ((voice3 = p_voice2->clone) >= 0) {\n//\t\tp_voice3 = &voice_tb[voice3];\n//\t\tp_voice3->cstaff = p_voice3->staff\n//\t\t\t\t= parsys->voice[voice3].staff\n//\t\t\t\t= parsys->voice[p_voice->clone].staff;\n//\t}\n\n\tif (over_time < 0) {\t\t\t/* first '&' in a measure */\n\t\tint time;\n\n\t\tover_bar = 1;\n\t\tover_mxtime = p_voice->time;\n\t\tover_voice = voice;\n\t\ttime = p_voice2->time;\n\t\tfor (s = p_voice->last_sym; /*s*/; s = s->prev) {\n\t\t\tif (s->type == BAR\n\t\t\t || s->time <= time)\t/* (if start of tune) */\n\t\t\t\tbreak;\n\t\t}\n\t\tover_time = s->time;\n\t} else {\n\t\tif (over_mxtime == 0)\n\t\t\tover_mxtime = p_voice->time;\n\t\telse if (p_voice->time != over_mxtime)\n\t\t\terror(1, s, tx_wrong_dur);\n\t}\n\tp_voice2->time = over_time;\n\tcurvoice = p_voice2;\n}\n\nstruct staff_s {\n\tshort voice;\n\tshort flags;\n};\n\n/* -- parse %%staves / %%score -- */\nstatic void parse_staves(struct SYMBOL *s,\n\t\t\tstruct staff_s *staves)\n{\n\tchar *p;\n\tint voice, flags_st, brace, bracket, parenth, err;\n\tshort flags;\n\tstruct staff_s *p_staff;\n\n\t/* define the voices */\n\terr = 0;\n\tflags = 0;\n\tbrace = bracket = parenth = 0;\n\tflags_st = 0;\n\tvoice = 0;\n\tp = s->text + 7;\n\twhile (*p != '\\0' && !isspace((unsigned char) *p))\n\t\tp++;\n\twhile (*p != '\\0') {\n\t\tswitch (*p) {\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tif (parenth || brace + bracket >= 2) {\n\t\t\t\terror(1, s, \"Misplaced '[' in %%%%staves\");\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (brace + bracket == 0)\n\t\t\t\tflags |= OPEN_BRACKET;\n\t\t\telse\n\t\t\t\tflags |= OPEN_BRACKET2;\n\t\t\tbracket++;\n\t\t\tflags_st <<= 8;\n\t\t\tflags_st |= OPEN_BRACKET;\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tif (parenth || brace || bracket >= 2) {\n\t\t\t\terror(1, s, \"Misplaced '{' in %%%%staves\");\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bracket == 0)\n\t\t\t\tflags |= OPEN_BRACE;\n\t\t\telse\n\t\t\t\tflags |= OPEN_BRACE2;\n\t\t\tbrace++;\n\t\t\tflags_st <<= 8;\n\t\t\tflags_st |= OPEN_BRACE;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tif (parenth) {\n\t\t\t\terror(1, s, \"Misplaced '(' in %%%%staves\");\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflags |= OPEN_PARENTH;\n\t\t\tparenth++;\n\t\t\tflags_st <<= 8;\n\t\t\tflags_st |= OPEN_PARENTH;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tif (brace && !parenth && !(flags & (OPEN_BRACE | OPEN_BRACE2)))\n\t\t\t\tflags |= FL_VOICE;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tflags |= MASTER_VOICE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!isalnum((unsigned char) *p) && *p != '_') {\n\t\t\t\terror(1, s, \"Bad voice ID in %%%%staves\");\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (voice >= MAXVOICE) {\n\t\t\t\terror(1, s, \"Too many voices in %%%%staves\");\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i, v;\n\t\t\t\tchar sep, *q;\n\n\t\t\t\tq = p;\n\t\t\t\twhile (isalnum((unsigned char) *p) || *p == '_')\n\t\t\t\t\tp++;\n\t\t\t\tsep = *p;\n\t\t\t\t*p = '\\0';\n\n\t\t\t\t/* search the voice in the voice table */\n\t\t\t\tv = -1;\n\t\t\t\tfor (i = 0; i < MAXVOICE; i++) {\n\t\t\t\t\tif (strcmp(q, voice_tb[i].id) == 0) {\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (v < 0) {\n\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t\"Voice '%s' of %%%%staves has no symbol\",\n\t\t\t\t\t\tq);\n\t\t\t\t\terr = 1;\n//\t\t\t\t\tbreak;\n\t\t\t\t\tp_staff = staves;\n\t\t\t\t} else {\n\t\t\t\t\tp_staff = staves + voice++;\n\t\t\t\t\tp_staff->voice = v;\n\t\t\t\t}\n\t\t\t\t*p = sep;\n\t\t\t}\n\t\t\tfor ( ; *p != '\\0'; p++) {\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tcontinue;\n\t\t\t\tcase ']':\n\t\t\t\t\tif (!(flags_st & OPEN_BRACKET)) {\n\t\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t\t\"Misplaced ']' in %%%%staves\");\n\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbracket--;\n\t\t\t\t\tif (brace + bracket == 0)\n\t\t\t\t\t\tflags |= CLOSE_BRACKET;\n\t\t\t\t\telse\n\t\t\t\t\t\tflags |= CLOSE_BRACKET2;\n\t\t\t\t\tflags_st >>= 8;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '}':\n\t\t\t\t\tif (!(flags_st & OPEN_BRACE)) {\n\t\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t\t\"Misplaced '}' in %%%%staves\");\n\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbrace--;\n\t\t\t\t\tif (bracket == 0)\n\t\t\t\t\t\tflags |= CLOSE_BRACE;\n\t\t\t\t\telse\n\t\t\t\t\t\tflags |= CLOSE_BRACE2;\n\t\t\t\t\tflags &= ~FL_VOICE;\n\t\t\t\t\tflags_st >>= 8;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase ')':\n\t\t\t\t\tif (!(flags_st & OPEN_PARENTH)) {\n\t\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t\t\"Misplaced ')' in %%%%staves\");\n\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tparenth--;\n\t\t\t\t\tflags |= CLOSE_PARENTH;\n\t\t\t\t\tflags_st >>= 8;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '|':\n\t\t\t\t\tflags |= STOP_BAR;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp_staff->flags = flags;\n\t\t\tflags = 0;\n\t\t\tif (*p == '\\0')\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tp++;\n\t}\n\tif (flags_st != 0) {\n\t\terror(1, s, \"'}', ')' or ']' missing in %%%%staves\");\n\t\terr = 1;\n\t}\n\tif (err) {\n\t\tint i;\n\n\t\tfor (i = 0; i < voice; i++)\n\t\t\tstaves[i].flags = 0;\n\t}\n\tif (voice < MAXVOICE)\n\t\tstaves[voice].voice = -1;\n}\n\n/* -- get staves definition (%%staves / %%score) -- */\nstatic void get_staves(struct SYMBOL *s)\n{\n//\tstruct SYMBOL *s2;\n\tstruct VOICE_S *p_voice, *p_voice2;\n\tstruct staff_s *p_staff, staves[MAXVOICE];\n\tint i, flags, voice, staff, range, dup_voice, maxtime;\n\n\tmemset(staves, 0, sizeof staves);\n\tparse_staves(s, staves);\n\tif (staves[0].voice < 0)\t\t\t// if error\n\t\treturn;\n\n\tvoice_compress();\n\tvoice_dup();\n\n\t/* create a new staff system */\n\tcurvoice = p_voice = first_voice;\n\tmaxtime = p_voice->time;\n\tflags = p_voice->sym != NULL;\n\tfor (p_voice = p_voice->next; p_voice; p_voice = p_voice->next) {\n\t\tif (p_voice->time > maxtime)\n\t\t\tmaxtime = p_voice->time;\n\t\tif (p_voice->sym)\n\t\t\tflags = 1;\n\t}\n\tif (flags == 0\t\t\t/* if first %%staves */\n\t || (maxtime == 0 && staves_found < 0)) {\n\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\tparsys->voice[voice].range = -1;\n\t} else {\n\n\t\t/*\n\t\t * create a new staff system and\n\t\t * link the staves in a voice which is seen from\n\t\t * the previous system - see sort_all\n\t\t */\n//\t\tp_voice = curvoice;\n\t\tif (parsys->voice[curvoice - voice_tb].range < 0) {\n\t\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\t\tif (parsys->voice[voice].range >= 0) {\n\t\t\t\t\tcurvoice = &voice_tb[voice];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n/*fixme: should check if voice < MAXVOICE*/\n\t\t}\n\t\tcurvoice->time = maxtime;\n\n\t\t// put the staves before a measure bar (see draw_bar())\n//\t\ts2 = curvoice->last_sym;\n//\t\tif (s2 && s2->type == BAR && s2->time == maxtime) {\n//\t\t\tcurvoice->last_sym = s2->prev;\n//\t\t\tif (!curvoice->last_sym)\n//\t\t\t\tcurvoice->sym = NULL;\n//\t\t\tsym_link(s, STAVES);\n//\t\t\ts->next = s2;\n//\t\t\ts2->prev = s;\n//\t\t\tcurvoice->last_sym = s2;\n//\t\t} else {\n\t\t\tsym_link(s, STAVES); // link the staves in the current voice\n//\t\t}\n\t\ts->state = ABC_S_HEAD; /* (output PS sequences immediately) */\n\t\tparsys->nstaff = nstaff;\n\t\tsystem_new();\n\t}\n\tstaves_found = maxtime;\n\n\t/* initialize the voices */\n\tfor (voice = 0, p_voice = voice_tb;\n\t     voice < MAXVOICE;\n\t     voice++, p_voice++) {\n\t\tp_voice->second = 0;\n\t\tp_voice->floating = 0;\n\t\tp_voice->ignore = 0;\n\t\tp_voice->time = maxtime;\n\t}\n\n\t/* create the 'clone' voices */\n\tdup_voice = MAXVOICE;\n\trange = 0;\n\tp_staff = staves;\n\tparsys->top_voice = p_staff->voice;\n\tfor (i = 0;\n\t     i < MAXVOICE && p_staff->voice >= 0;\n\t     i++, p_staff++) {\n\t\tvoice = p_staff->voice;\n\t\tp_voice = &voice_tb[voice];\n\t\tif (parsys->voice[voice].range >= 0) {\n\t\t\tif (parsys->voice[dup_voice - 1].range >= 0) {\n\t\t\t\terror(1, s, \"Too many voices for cloning\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvoice = --dup_voice;\t/* duplicate the voice */\n\t\t\tp_voice2 = &voice_tb[voice];\n\t\t\tmemcpy(p_voice2, p_voice, sizeof *p_voice2);\n\t\t\tp_voice2->next = NULL;\n\t\t\tp_voice2->sym = p_voice2->last_sym = NULL;\n\t\t\tp_voice2->tblts[0] = p_voice2->tblts[1] = NULL;\n\t\t\tp_voice2->clone = -1;\n\t\t\twhile (p_voice->clone > 0)\n\t\t\t\tp_voice = &voice_tb[p_voice->clone];\n\t\t\tp_voice->clone = voice;\n\t\t\tp_voice = p_voice2;\n\t\t\tp_staff->voice = voice;\n\t\t}\n\t\tparsys->voice[voice].range = range++;\n\t\tvoice_link(p_voice);\n\t}\n\n\t/* change the behavior from %%staves to %%score */\n\tif (s->text[3] == 't') {\t\t/* if %%staves */\n\t\tfor (i = 0, p_staff = staves;\n\t\t     i < MAXVOICE - 2 && p_staff->voice >= 0;\n\t\t     i++, p_staff++) {\n\t\t\tflags = p_staff->flags;\n\t\t\tif (!(flags & (OPEN_BRACE | OPEN_BRACE2)))\n\t\t\t\tcontinue;\n\t\t\tif ((flags & (OPEN_BRACE | CLOSE_BRACE))\n\t\t\t\t\t== (OPEN_BRACE | CLOSE_BRACE)\n\t\t\t || (flags & (OPEN_BRACE2 | CLOSE_BRACE2))\n\t\t\t\t\t== (OPEN_BRACE2 | CLOSE_BRACE2))\n\t\t\t\tcontinue;\n\t\t\tif (p_staff[1].flags != 0)\n\t\t\t\tcontinue;\n\t\t\tif ((flags & OPEN_PARENTH)\n\t\t\t || (p_staff[2].flags & OPEN_PARENTH))\n\t\t\t\tcontinue;\n\n\t\t\t/* {a b c} --> {a *b c} */\n\t\t\tif (p_staff[2].flags & (CLOSE_BRACE | CLOSE_BRACE2)) {\n\t\t\t\tp_staff[1].flags |= FL_VOICE;\n\n\t\t\t/* {a b c d} --> {(a b) (c d)} */\n\t\t\t} else if (p_staff[2].flags == 0\n\t\t\t\t && (p_staff[3].flags & (CLOSE_BRACE | CLOSE_BRACE2))) {\n\t\t\t\tp_staff->flags |= OPEN_PARENTH;\n\t\t\t\tp_staff[1].flags |= CLOSE_PARENTH;\n\t\t\t\tp_staff[2].flags |= OPEN_PARENTH;\n\t\t\t\tp_staff[3].flags |= CLOSE_PARENTH;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set the staff system */\n\tstaff = -1;\n\tfor (i = 0, p_staff = staves;\n\t     i < MAXVOICE && p_staff->voice >= 0;\n\t     i++, p_staff++) {\n\t\tflags = p_staff->flags;\n\t\tif ((flags & (OPEN_PARENTH | CLOSE_PARENTH))\n\t\t\t\t== (OPEN_PARENTH | CLOSE_PARENTH)) {\n\t\t\tflags &= ~(OPEN_PARENTH | CLOSE_PARENTH);\n\t\t\tp_staff->flags = flags;\n\t\t}\n\t\tvoice = p_staff->voice;\n\t\tp_voice = &voice_tb[voice];\n\t\tif (flags & FL_VOICE) {\n\t\t\tp_voice->floating = 1;\n\t\t\tp_voice->second = 1;\n\t\t} else {\n#if MAXSTAFF < MAXVOICE\n\t\t\tif (staff >= MAXSTAFF - 1) {\n\t\t\t\terror(1, s, \"Too many staves\");\n\t\t\t} else\n#endif\n\t\t\t\tstaff++;\n\t\t\tparsys->staff[staff].flags = 0;\n\t\t}\n\t\tp_voice->staff = p_voice->cstaff\n\t\t\t\t= parsys->voice[voice].staff = staff;\n\t\tparsys->staff[staff].flags |= flags;\n\t\tif (flags & OPEN_PARENTH) {\n\t\t\tp_voice2 = p_voice;\n\t\t\twhile (i < MAXVOICE) {\n\t\t\t\ti++;\n\t\t\t\tp_staff++;\n\t\t\t\tvoice = p_staff->voice;\n\t\t\t\tp_voice = &voice_tb[voice];\n\t\t\t\tif (p_staff->flags & MASTER_VOICE) {\n\t\t\t\t\tp_voice2->second = 1;\n\t\t\t\t\tp_voice2 = p_voice;\n\t\t\t\t} else {\n\t\t\t\t\tp_voice->second = 1;\n\t\t\t\t}\n\t\t\t\tp_voice->staff = p_voice->cstaff\n\t\t\t\t\t\t= parsys->voice[voice].staff\n\t\t\t\t\t\t= staff;\n\t\t\t\tif (p_staff->flags & CLOSE_PARENTH)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparsys->staff[staff].flags |= p_staff->flags;\n\t\t}\n\t}\n\tif (staff < 0)\n\t\tstaff = 0;\n\tparsys->nstaff = nstaff = staff;\n\n\t/* change the behaviour of '|' in %%score */\n\tif (s->text[3] == 'c') {\t\t/* if %%score */\n\t\tfor (staff = 0; staff < nstaff; staff++)\n\t\t\tparsys->staff[staff].flags ^= STOP_BAR;\n\t}\n\n\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\tp_voice = &voice_tb[voice];\n\t\tparsys->voice[voice].second = p_voice->second;\n\t\tstaff = p_voice->staff;\n\t\tif (staff > 0)\n\t\t\tp_voice->norepbra\n\t\t\t\t= !(parsys->staff[staff - 1].flags & STOP_BAR);\n\t\tif (p_voice->floating && staff == nstaff)\n\t\t\tp_voice->floating = 0;\n\t}\n\tcurvoice = &voice_tb[parsys->top_voice];\n}\n\n/* -- re-initialize all potential voices -- */\nstatic void voice_init(void)\n{\n\tstruct VOICE_S *p_voice;\n\tint i;\n\n\tfor (i = 0, p_voice = voice_tb;\n\t     i < MAXVOICE;\n\t     i++, p_voice++) {\n\t\tp_voice->sym = p_voice->last_sym = NULL;\n\t\tp_voice->lyric_start = NULL;\n\t\tp_voice->bar_start = 0;\n\t\tp_voice->time = 0;\n\t\tp_voice->slur_st = 0;\n\t\tp_voice->hy_st = 0;\n\t\tp_voice->tie = 0;\n\t\tp_voice->rtie = 0;\n\t}\n}\n\n/* output a pdf mark */\nstatic void put_pdfmark(char *p)\n{\n\tunsigned char c, *q;\n\tint u;\n\n\tp = trim_title(p, NULL);\n\n\t/* check if pure ASCII without '\\', '(' nor ')'*/\n\tfor (q = (unsigned char *) p; *q != '\\0'; q++) {\n\t\tswitch (*q) {\n\t\tcase '\\\\':\n\t\tcase '(':\n\t\tcase ')':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*q >= 0x80)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (*q == '\\0') {\n\t\ta2b(\"[/Title(%s)/OUT pdfmark\\n\", p);\n\t\treturn;\n\t}\n\n\t/* build utf-8 mark */\n\ta2b(\"[/Title<FEFF\");\n\tq = (unsigned char *) p;\n\tu = -1;\n\twhile (*q != '\\0') {\n\t\tc = *q++;\n\t\tif (c < 0x80) {\n\t\t\tif (u >= 0) {\n\t\t\t\ta2b(\"%04X\", u);\n\t\t\t\tu = -1;\n\t\t\t}\n\t\t\ta2b(\"%04X\", (int) c);\n\t\t\tcontinue;\n\t\t}\n\t\tif (c < 0xc0) {\n\t\t\tu = (u << 6) | (c & 0x3f);\n\t\t\tcontinue;\n\t\t}\n\t\tif (u >= 0) {\n\t\t\ta2b(\"%04X\", u);\n\t\t\tu = -1;\n\t\t}\n\t\tif (c < 0xe0)\n\t\t\tu = c & 0x1f;\n\t\telse if (c < 0xf0)\n\t\t\tu = c & 0x0f;\n\t\telse\n\t\t\tu = c & 0x07;\n\t}\n\tif (u >= 0) {\n\t\ta2b(\"%04X\", u);\n\t\tu = -1;\n\t}\n\ta2b(\">/OUT pdfmark\\n\");\n}\n\n/* rebuild a tune header for %%tune filter */\nstatic char *tune_header_rebuild(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s2;\n\tchar *header, *p;\n\tint len;\n\n\tlen = 0;\n\ts2 = s;\n\tfor (;;) {\n\t\tif (s2->abc_type == ABC_T_INFO) {\n\t\t\tlen += strlen(s2->text) + 1;\n\t\t\tif (s2->text[0] == 'K')\n\t\t\t\tbreak;\n\t\t}\n\t\ts2 = s2->abc_next;\n\t}\n\theader = malloc(len + 1);\n\tp = header;\n\tfor (;;) {\n\t\tif (s->abc_type == ABC_T_INFO) {\n\t\t\tstrcpy(p, s->text);\n\t\t\tp += strlen(p);\n\t\t\t*p++ = '\\n';\n\t\t\tif (s->text[0] == 'K')\n\t\t\t\tbreak;\n\t\t}\n\t\ts = s->abc_next;\n\t}\n\t*p++ = '\\0';\n\treturn header;\n}\n\n/* apply the options to the current tune */\nstatic void tune_filter(struct SYMBOL *s)\n{\n\tstruct tune_opt_s *opt;\n\tstruct SYMBOL *s1, *s2;\n\tregex_t r;\n\tchar *header, *p;\n\tint ret;\n\n\theader = tune_header_rebuild(s);\n\tfor (opt = tune_opts; opt; opt = opt->next) {\n\t\tstruct SYMBOL *last_staves;\n\n\t\tp = &opt->s->text[2 + 5];\t/* \"%%tune RE\" */\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\n\t\tret = regcomp(&r, p, REG_EXTENDED | REG_NEWLINE | REG_NOSUB);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tret = regexec(&r, header, 0, NULL, 0);\n\t\tregfree(&r);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/* apply the options */\n\t\tcur_tune_opts = opt;\n\t\tlast_staves = s->abc_next;\n\t\tfor (s1 = opt->s->next; s1; s1 = s1->next) {\n\n\t\t\t/* replace the next %%staves/%%score */\n\t\t\tif (s1->abc_type == ABC_T_PSCOM\n\t\t\t && (strncmp(&s1->text[2], \"staves\", 6) == 0\n\t\t\t  || strncmp(&s1->text[2], \"score\", 5) == 0)) {\n\t\t\t\twhile (last_staves) {\n\t\t\t\t\tif (last_staves->abc_type == ABC_T_PSCOM\n\t\t\t\t\t && (strncmp(&last_staves->text[2],\n\t\t\t\t\t\t\t\t\"staves\", 6) == 0\n\t\t\t\t\t  || strncmp(&last_staves->text[2],\n\t\t\t\t\t\t\t\t \"score\", 5) == 0)) {\n\t\t\t\t\t\tlast_staves->text = s1->text;\n\t\t\t\t\t\tlast_staves = last_staves->abc_next;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlast_staves = last_staves->abc_next;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts2 = (struct SYMBOL *) getarena(sizeof *s2);\n\t\t\tmemcpy(s2, s1, sizeof *s2);\n\t\t\tprocess_pscomment(s2);\n\t\t}\n\t\tcur_tune_opts = NULL;\n\t\ttune_voice_opts = opt->voice_opts;\t// for %%voice\n//fixme: what if many %%tune's with %%voice inside?\n\t}\n\tfree(header);\n}\n\n/* apply the options of the current voice */\nstatic void voice_filter(void)\n{\n\tstruct voice_opt_s *opt;\n\tstruct SYMBOL *s;\n\tregex_t r;\n\tint pass, ret;\n\tchar *p;\n\n\t/* scan the global, then the tune options */\n\tpass = 0;\n\topt = voice_opts;\n\tfor (;;) {\n\t\tif (!opt) {\n\t\t\tif (pass != 0)\n\t\t\t\tbreak;\n\t\t\topt = tune_voice_opts;\n\t\t\tif (!opt)\n\t\t\t\tbreak;\n\t\t\tpass++;\n\t\t}\n\t\tp = &opt->s->text[2 + 6];\t/* \"%%voice RE\" */\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\n\t\tret = regcomp(&r, p, REG_EXTENDED | REG_NOSUB);\n\t\tif (ret)\n\t\t\tgoto next_voice;\n\t\tret = regexec(&r, curvoice->id, 0, NULL, 0);\n\t\tif (ret && curvoice->nm)\n\t\t\tret = regexec(&r, curvoice->nm, 0, NULL, 0);\n\t\tregfree(&r);\n\t\tif (ret)\n\t\t\tgoto next_voice;\n\n\t\t/* apply the options */\n\t\tfor (s = opt->s->next; s; s = s->next) {\n\t\t\tstruct SYMBOL *s2;\n\n\t\t\ts2 = (struct SYMBOL *) getarena(sizeof *s2);\n\t\t\tmemcpy(s2, s, sizeof *s2);\n\t\t\tprocess_pscomment(s2);\n\t\t}\nnext_voice:\n\t\topt = opt->next;\n\t}\n}\n\n/* -- check if a pseudo-comment may be in the tune header -- */\nstatic int check_header(struct SYMBOL *s)\n{\n\tswitch (s->text[2]) {\n\tcase 'E':\n\t\tif (strncmp(s->text + 2, \"EPS\", 3) == 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase 'm':\n\t\tif (strncmp(s->text + 2, \"multicol\", 8) == 0)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\n/* -- set the global definitions after the first K: or middle-tune T:'s -- */\nstatic void set_global_def(void)\n{\n\tstruct VOICE_S *p_voice;\n\tint i;\n\n\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t     --i >= 0;\n\t     p_voice++) {\n\t\tswitch (p_voice->key.instr) {\n\t\tcase 0:\n\t\t\tif (!pipeformat) {\n//\t\t\t\tp_voice->transpose = cfmt.transpose;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//fall thru\n\t\tcase K_HP:\n\t\tcase K_Hp:\n\t\t\tif (p_voice->posit.std == 0)\n\t\t\t\tp_voice->posit.std = SL_BELOW;\n\t\t\tbreak;\n\t\t}\n//\t\tif (p_voice->key.empty)\n//\t\t\tp_voice->key.sf = 0;\n\t\tif (!cfmt.autoclef\n\t\t && p_voice->s_clef\n\t\t && (p_voice->s_clef->sflags & S_CLEF_AUTO)) {\n\t\t\tp_voice->s_clef->u.clef.type = TREBLE;\n\t\t\tp_voice->s_clef->sflags &= ~S_CLEF_AUTO;\n\t\t}\n\t}\n\n\t/* switch to the 1st voice */\n\tcurvoice = &voice_tb[parsys->top_voice];\n}\n\n/* -- get the global definitions after the first K: or middle-tune T:'s -- */\nstatic struct SYMBOL *get_global_def(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s2;\n\n\tfor (;;) {\n\t\ts2 = s->abc_next;\n\t\tif (!s2)\n\t\t\tbreak;\n\t\tswitch (s2->abc_type) {\n\t\tcase ABC_T_INFO:\n\t\t\tswitch (s2->text[0]) {\n\t\t\tcase 'K':\n\t\t\t\ts = s2;\n\t\t\t\ts->state = ABC_S_HEAD;\n\t\t\t\tget_key(s);\n\t\t\t\tcontinue;\n\t\t\tcase 'I':\n\t\t\tcase 'M':\n\t\t\tcase 'Q':\n\t\t\t\ts = s2;\n\t\t\t\ts->state = ABC_S_HEAD;\n\t\t\t\ts = get_info(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ABC_T_PSCOM:\n\t\t\tif (!check_header(s2))\n\t\t\t\tbreak;\n\t\t\ts = s2;\n\t\t\ts->state = ABC_S_HEAD;\n\t\t\ts = process_pscomment(s);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tset_global_def();\n\treturn s;\n}\n\n/* save the global note maps */\nstatic void save_maps(void)\n{\n\tstruct map *omap, *map;\n\tstruct note_map *onotes, *notes;\n\n\tomap = maps;\n\tif (!omap) {\n\t\tmaps_glob = NULL;\n\t\treturn;\n\t}\n\tmaps_glob = map = getarena(sizeof *maps_glob);\n\tfor (;;) {\n\t\tmemcpy(map, omap, sizeof *map);\n\t\tonotes = omap->notes;\n\t\tif (onotes) {\n\t\t\tmap->notes = notes = getarena(sizeof *notes);\n\t\t\tfor (;;) {\n\t\t\t\tmemcpy(notes, onotes, sizeof *notes);\n\t\t\t\tonotes = onotes->next;\n\t\t\t\tif (!onotes)\n\t\t\t\t\tbreak;\n\t\t\t\tnotes->next = getarena(sizeof *notes);\n\t\t\t\tnotes = notes->next;\n\t\t\t}\n\t\t}\n\t\tomap = omap->next;\n\t\tif (!omap)\n\t\t\tbreak;\n\t\tmap->next = getarena(sizeof *map);\n\t\tmap = map->next;\n\t}\n}\n\n/* -- identify info line, store in proper place\t-- */\nstatic struct SYMBOL *get_info(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s2;\n\tstruct VOICE_S *p_voice;\n\tchar *p;\n\tchar info_type;\n\tint old_lvl;\n\tstatic char *state_txt[] = {\"global\", \"header\", \"tune\"};\n\n\t/* change arena to global or tune */\n\told_lvl = lvlarena(s->state != ABC_S_GLOBAL);\n\n\tinfo_type = s->text[0];\n\tswitch (info_type) {\n\tcase 'd':\n\t\tbreak;\n\tcase 'I':\n\t\ts = process_pscomment(s);\t/* same as pseudo-comment */\n\t\tbreak;\n\tcase 'K':\n\t\tget_key(s);\n\t\tif (s->state != ABC_S_HEAD)\n\t\t\tbreak;\n\t\tinfo['K' - 'A'] = s;\t\t/* first K:, end of tune header */\n\t\ttunenum++;\n\n\t\tif (!epsf) {\n//\t\t\tif (!cfmt.oneperpage)\n//\t\t\t\tuse_buffer = cfmt.splittune != 1;\n\t\t\tbskip(cfmt.topspace);\n\t\t}\n\t\ta2b(\"%% --- xref %s\\n\", &info['X' - 'A']->text[2]); // (for index)\n\t\twrite_heading();\n\t\tblock_put();\n\n\t\t/* information for index\n\t\t * (pdfmark must be after title show for Adobe Distiller) */\n\t\ts2 = info['T' - 'A'];\n\t\tp = &s2->text[2];\n\t\tif (*p != '\\0') {\n\t\t\ta2b(\"%% --- font \");\n\t\t\toutft = -1;\n\t\t\tset_font(TITLEFONT);\t\t/* font in comment */\n\t\t\ta2b(\"\\n\");\n\t\t\toutft = -1;\n\t\t}\n\t\tif (cfmt.pdfmark) {\n\t\t\tif (*p != '\\0')\n\t\t\t\tput_pdfmark(p);\n\t\t\tif (cfmt.pdfmark > 1) {\n\t\t\t\tfor (s2 = s2->next; s2; s2 = s2->next) {\n\t\t\t\t\tp = &s2->text[2];\n\t\t\t\t\tif (*p != '\\0')\n\t\t\t\t\t\tput_pdfmark(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnbar = cfmt.measurefirst;\t/* measure numbering */\n\t\tover_voice = -1;\n\t\tover_time = -1;\n\t\tover_bar = 0;\n\t\tcapo = 0;\n\t\treset_gen();\n\n\t\ts = get_global_def(s);\n\n\t\tif (!(cfmt.fields[0] & (1 << ('Q' - 'A'))))\n\t\t\tinfo['Q' - 'A'] = NULL;\n\n\t\t/* apply the filter for the voice '1' */\n\t\tvoice_filter();\n\n\t\t/* activate the default tablature if not yet done */\n\t\tif (!first_voice->tblts[0])\n\t\t\tset_tblt(first_voice);\n\t\tbreak;\n\tcase 'L':\n\t\tswitch (s->state) {\n\t\tcase ABC_S_HEAD: {\n\t\t\tint i, auto_len;\n\n\t\t\tauto_len = s->u.length.base_length < 0;\n\n\t\t\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t\t\t     --i >= 0;\n\t\t\t     p_voice++)\n\t\t\t\tp_voice->auto_len = auto_len;\n\t\t\tbreak;\n\t\t    }\n\t\tcase ABC_S_TUNE:\n\t\t\tcurvoice->auto_len = s->u.length.base_length < 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'M':\n\t\tget_meter(s);\n\t\tbreak;\n\tcase 'P': {\n\t\tstruct VOICE_S *curvoice_sav;\n\n\t\tif (s->state != ABC_S_TUNE) {\n\t\t\tinfo['P' - 'A'] = s;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(cfmt.fields[0] & (1 << ('P' - 'A'))))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If not in the main voice, then,\n\t\t * if the voices are synchronized and no P: yet in the main voice,\n\t\t * the misplaced P: goes into the main voice.\n\t\t */ \n\t\tp_voice = &voice_tb[parsys->top_voice];\n\t\tif (curvoice != p_voice) {\n\t\t\tif (curvoice->time != p_voice->time)\n\t\t\t\tbreak;\n\t\t\tif (p_voice->last_sym && p_voice->last_sym->type == PART)\n\t\t\t\tbreak;\t\t// already a P:\n\t\t\tcurvoice_sav = curvoice;\n\t\t\tcurvoice = p_voice;\n\t\t\tsym_link(s, PART);\n\t\t\tcurvoice = curvoice_sav;\n\t\t\tbreak;\n\t\t}\n\t\tsym_link(s, PART);\n\t\tbreak;\n\t    }\n\tcase 'Q':\n\t\tif (!(cfmt.fields[0] & (1 << ('Q' - 'A'))))\n\t\t\tbreak;\n\t\tif (s->state != ABC_S_TUNE) {\n\t\t\tinfo['Q' - 'A'] = s;\n\t\t\tbreak;\n\t\t}\n\t\tif (curvoice != &voice_tb[parsys->top_voice])\n\t\t\tbreak;\t\t/* tempo only for first voice */\n\t\ts2 = curvoice->last_sym;\n\t\tif (s2) {\t\t\t/* keep last Q: */\n\t\t\tint tim;\n\n\t\t\ttim = s2->time;\n\t\t\tdo {\n\t\t\t\tif (s2->type == TEMPO) {\n\t\t\t\t\tif (!s2->next)\n\t\t\t\t\t\tcurvoice->last_sym = s2->prev;\n\t\t\t\t\telse\n\t\t\t\t\t\ts2->next->prev = s2->prev;\n\t\t\t\t\tif (!s2->prev)\n\t\t\t\t\t\tcurvoice->sym = s2->next;\n\t\t\t\t\telse\n\t\t\t\t\t\ts2->prev->next = s2->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts2 = s2->prev;\n\t\t\t} while (s2 && s2->time == tim);\n\t\t}\n\t\tsym_link(s, TEMPO);\n\t\tbreak;\n\tcase 'r':\n\tcase 's':\n\t\tbreak;\n\tcase 'T':\n\t\tif (s->state == ABC_S_GLOBAL)\n\t\t\tbreak;\n\t\tif (s->state == ABC_S_HEAD)\t\t/* in tune header */\n\t\t\tgoto addinfo;\n\t\tgen_ly(1);\t\t\t\t/* in tune */\n\t\tp = &s->text[2];\n\t\tif (*p != '\\0') {\n\t\t\twrite_title(s);\n\t\t\ta2b(\"%% --- + (%s) ---\\n\", p);\n\t\t\tif (cfmt.pdfmark)\n\t\t\t\tput_pdfmark(p);\n\t\t}\n\t\tvoice_init();\n\t\treset_gen();\t\t/* (display the time signature) */\n\t\ts = get_global_def(s);\n\t\tbreak;\n\tcase 'U':\n\t\tdeco[s->u.user.symbol] = parse.deco_tb[s->u.user.value - 128];\n\t\tbreak;\n\tcase 'u':\n\t\tbreak;\n\tcase 'V':\n\t\tget_voice(s);\n\n\t\t/* handle here the possible clef which could be replaced\n\t\t * in case of filter */\n\t\tif (s->abc_next && s->abc_next->abc_type == ABC_T_CLEF) {\n\t\t\ts = s->abc_next;\n\t\t\tget_clef(s);\n\t\t}\n\t\tif (s->state == ABC_S_TUNE\n\t\t && !curvoice->last_sym\n\t\t && curvoice->time == 0)\n\t\t\tvoice_filter();\n\t\tbreak;\n\tcase 'w':\n\t\tif (s->state != ABC_S_TUNE)\n\t\t\tbreak;\n\t\tif (!(cfmt.fields[1] & (1 << ('w' - 'a')))) {\n\t\t\twhile (s->abc_next) {\n\t\t\t\tif (s->abc_next->abc_type != ABC_T_INFO\n\t\t\t\t || s->abc_next->text[0] != '+')\n\t\t\t\t\tbreak;\n\t\t\t\ts = s->abc_next;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ts = get_lyric(s);\n\t\tbreak;\n\tcase 'W':\n\t\tif (s->state == ABC_S_GLOBAL\n\t\t || !(cfmt.fields[0] & (1 << ('W' - 'A'))))\n\t\t\tbreak;\n\t\tgoto addinfo;\n\tcase 'X':\n\t\tif (!epsf) {\n\t\t\tbuffer_eob(0);\t/* flush stuff left from %% lines */\n\t\t\twrite_buffer();\n//fixme: 8.6.2\n\t\t\tif (cfmt.oneperpage)\n\t\t\t\tclose_page();\n//\t\t\telse if (in_page)\n\t\t\telse\n\t\t\t\tuse_buffer = cfmt.splittune != 1;\n\t\t}\n\n\t\tmemcpy(&dfmt, &cfmt, sizeof dfmt); /* save global values */\n\t\tmemcpy(&info_glob, &info, sizeof info_glob);\n\t\tmemcpy(deco_glob, deco, sizeof deco_glob);\n\t\tsave_maps();\n\t\tinfo['X' - 'A'] = s;\n\t\tif (tune_opts)\n\t\t\ttune_filter(s);\n\t\tbreak;\n\tdefault:\n\t\tif (info_type >= 'A' && info_type <= 'Z') {\n\t\t\tstruct SYMBOL *prev;\n\n\t\t\tif (s->state == ABC_S_TUNE)\n\t\t\t\tbreak;\naddinfo:\n\t\t\tprev = info[info_type - 'A'];\n\t\t\tif (!prev\n\t\t\t || (prev->state == ABC_S_GLOBAL\n\t\t\t  && s->state != ABC_S_GLOBAL)) {\n\t\t\t\tinfo[info_type - 'A'] = s;\n\t\t\t} else {\n\t\t\t\twhile (prev->next)\n\t\t\t\t\tprev = prev->next;\n\t\t\t\tprev->next = s;\n\t\t\t}\n\t\t\twhile (s->abc_next\n\t\t\t    && s->abc_next->abc_type == ABC_T_INFO\n\t\t\t    && s->abc_next->text[0] == '+') {\n\t\t\t\tprev = s;\n\t\t\t\ts = s->abc_next;\n\t\t\t\tprev->next = s;\n\t\t\t}\n\t\t\ts->prev = prev;\n\t\t\tbreak;\n\t\t}\n\t\tif (s->state != ABC_S_GLOBAL)\n\t\t\terror(1, s, \"%s info '%c:' not treated\",\n\t\t\t\tstate_txt[(int) s->state], info_type);\n\t\tbreak;\n\t}\n\tlvlarena(old_lvl);\n\treturn s;\n}\n\n/* -- set head type, dots, flags for note -- */\nvoid identify_note(struct SYMBOL *s,\n\t\t   int dur,\n\t\t   int *p_head,\n\t\t   int *p_dots,\n\t\t   int *p_flags)\n{\n\tint head, dots, flags;\n\n\tif (dur % 12 != 0)\n\t\terror(1, s, \"Invalid note duration\");\n\tdur /= 12;\t\t\t/* see BASE_LEN for values */\n\tif (dur == 0)\n\t\terror(1, s, \"Note too short\");\n\tfor (flags = 5; dur != 0; dur >>= 1, flags--) {\n\t\tif (dur & 1)\n\t\t\tbreak;\n\t}\n\tdur >>= 1;\n\tswitch (dur) {\n\tcase 0: dots = 0; break;\n\tcase 1: dots = 1; break;\n\tcase 3: dots = 2; break;\n\tcase 7: dots = 3; break;\n\tdefault:\n\t\terror(1, s, \"Note too much dotted\");\n\t\tdots = 3;\n\t\tbreak;\n\t}\n\tflags -= dots;\n\tif (flags >= 0) {\n\t\thead = H_FULL;\n\t} else switch (flags) {\n\tdefault:\n\t\terror(1, s, \"Note too long\");\n\t\tflags = -4;\n\t\t/* fall thru */\n\tcase -4:\n\t\thead = H_SQUARE;\n\t\tbreak;\n\tcase -3:\n\t\thead = cfmt.squarebreve ? H_SQUARE : H_OVAL;\n\t\tbreak;\n\tcase -2:\n\t\thead = H_OVAL;\n\t\tbreak;\n\tcase -1:\n\t\thead = H_EMPTY;\n\t\tbreak;\n\t}\n\t*p_head = head;\n\t*p_flags = flags;\n\t*p_dots = dots;\n}\n\n/* -- adjust the duration and time of symbols in a measure when L:auto -- */\nstatic void adjust_dur(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s2;\n\tint time, auto_time;\n\n\t/* search the start of the measure */\n\ts2 = curvoice->last_sym;\n\tif (!s2)\n\t\treturn;\n\n\t/* the bar time is correct if there is multi-rests */\n\tif (s2->type == MREST\n\t || s2->type == BAR)\t\t/* in second voice */\n\t\treturn;\n\twhile (s2->type != BAR && s2->prev)\n\t\ts2 = s2->prev;\n\ttime = s2->time;\n\tauto_time = curvoice->time - time;\n\n\t/* remove the invisible rest at start of tune */\n\tif (time == 0) {\n\t\twhile (s2 && s2->dur == 0)\n\t\t\ts2 = s2->next;\n\t\tif (s2 && s2->abc_type == ABC_T_REST\n\t\t && (s2->flags & ABC_F_INVIS)) {\n\t\t\ttime += s2->dur * curvoice->wmeasure / auto_time;\n\t\t\tif (s2->prev)\n\t\t\t\ts2->prev->next = s2->next;\n\t\t\telse\n\t\t\t\tcurvoice->sym = s2->next;\n\t\t\tif (s2->next)\n\t\t\t\ts2->next->prev = s2->prev;\n\t\t\ts2 = s2->next;\n\t\t}\n\t}\n\tif (curvoice->wmeasure == auto_time)\n\t\treturn;\t\t\t\t/* already good duration */\n\n\tfor (; s2; s2 = s2->next) {\n\t\tint i, head, dots, nflags;\n\n\t\ts2->time = time;\n\t\tif (s2->dur == 0\n\t\t || (s2->flags & ABC_F_GRACE))\n\t\t\tcontinue;\n\t\ts2->dur = s2->dur * curvoice->wmeasure / auto_time;\n\t\ttime += s2->dur;\n\t\tif (s2->type != NOTEREST)\n\t\t\tcontinue;\n\t\tfor (i = 0; i <= s2->nhd; i++)\n\t\t\ts2->u.note.notes[i].len = s2->u.note.notes[i].len\n\t\t\t\t\t * curvoice->wmeasure / auto_time;\n\t\tidentify_note(s2, s2->u.note.notes[0].len,\n\t\t\t\t&head, &dots, &nflags);\n\t\ts2->head = head;\n\t\ts2->dots = dots;\n\t\ts2->nflags = nflags;\n\t\tif (s2->nflags <= -2)\n\t\t\ts2->flags |= ABC_F_STEMLESS;\n\t\telse\n\t\t\ts2->flags &= ~ABC_F_STEMLESS;\n\t}\n\tcurvoice->time = s->time = time;\n}\n\n/* -- measure bar -- */\nstatic void get_bar(struct SYMBOL *s)\n{\n\tint bar_type;\n\tstruct SYMBOL *s2;\n\n\tif (s->u.bar.repeat_bar\n\t && curvoice->norepbra\n\t && !curvoice->second)\n\t\ts->sflags |= S_NOREPBRA;\n\tif (curvoice->auto_len)\n\t\tadjust_dur(s);\n\n\tbar_type = s->u.bar.type;\n\ts2 = curvoice->last_sym;\n\tif (s2 && s2->type == SPACE) {\n\t\ts2->time--;\t\t// keep the space at the right place\n\t} else if (s2 && s2->type == BAR) {\n\n\t\t/* remove the invisible repeat bars when no shift is needed */\n\t\tif (bar_type == B_OBRA\n\t\t && !s2->text\n\t\t && (curvoice == &voice_tb[parsys->top_voice]\n\t\t  || (parsys->staff[curvoice->staff - 1].flags & STOP_BAR)\n\t\t  || (s->sflags & S_NOREPBRA))) {\n\t\t\ts2->text = s->text;\n\t\t\ts2->u.bar.repeat_bar = s->u.bar.repeat_bar;\n\t\t\ts2->flags |= s->flags & (ABC_F_RBSTART | ABC_F_RBSTOP);\n\t\t\ts2->sflags |= s->sflags\n\t\t\t\t\t& (S_NOREPBRA | S_RBSTART | S_RBSTOP);\n\t\t\ts = s2;\n\t\t\tgoto gch_build;\n\t\t}\n\n\t\t/* merge back-to-back repeat bars */\n\t\tif (bar_type == B_LREP && !s->text) {\n\t\t\tif (s2->u.bar.type == B_RREP) {\n\t\t\t\ts2->u.bar.type = B_DREP;\n\t\t\t\ts2->flags |= ABC_F_RBSTOP;\n\t\t\t\ts2->sflags |= S_RBSTOP;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (s2->u.bar.type == B_DOUBLE) {\n\t\t\t\ts2->u.bar.type = (B_SINGLE << 8) | B_LREP;\n\t\t\t\ts2->flags |= ABC_F_RBSTOP;\n\t\t\t\ts2->sflags |= S_RBSTOP;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* link the bar in the voice */\n\t/* the bar must appear before a key signature */\n\tif (s2 && s2->type == KEYSIG\n\t && (!s2->prev || s2->prev->type != BAR)) {\n\t\tcurvoice->last_sym = s2->prev;\n\t\tif (!curvoice->last_sym)\n\t\t\tcurvoice->sym = NULL;\n\t\tsym_link(s, BAR);\n\t\ts->next = s2;\n\t\ts2->prev = s;\n\t\tcurvoice->last_sym = s2;\n\t} else {\n\t\tsym_link(s, BAR);\n\t}\n\ts->staff = curvoice->staff;\t/* original staff */\n\n\t/* set some flags */\n\tswitch (bar_type) {\n\tcase B_OBRA:\n\tcase (B_OBRA << 4) + B_CBRA:\n\t\ts->flags |= ABC_F_INVIS;\n\t\tbreak;\n\tcase (B_COL << 8) + (B_BAR << 4) + B_COL:\n\tcase (B_COL << 12) + (B_BAR << 8) + (B_BAR << 4) + B_COL:\n\t\tbar_type = (B_COL << 4) + B_COL;\t/* :|: and :||: -> :: */\n\t\ts->u.bar.type = bar_type;\n\t\tbreak;\n\tcase (B_BAR << 4) + B_BAR:\n\t\tif (!cfmt.rbdbstop)\n\t\t\tbreak;\n\tcase (B_OBRA << 4) + B_BAR:\n\tcase (B_BAR << 4) + B_CBRA:\n\t\ts->flags |= ABC_F_RBSTOP;\n\t\ts->sflags |= S_RBSTOP;\n\t\tbreak;\n\t}\n\n\tif (s->u.bar.dc.n > 0)\n\t\tdeco_cnv(&s->u.bar.dc, s, NULL); /* convert the decorations */\n\n\t/* build the gch */\ngch_build:\n\tif (s->text) {\n\t\tif (!s->u.bar.repeat_bar) {\n\t\t\tgch_build(s);\t/* build the guitar chords */\n\t\t} else {\n\t\t\ts->gch = getarena(sizeof *s->gch * 2);\n\t\t\tmemset(s->gch, 0, sizeof *s->gch * 2);\n\t\t\ts->gch->type = 'r';\n\t\t\ts->gch->font = REPEATFONT;\n\t\t\tstr_font(REPEATFONT);\n\t\t\ts->gch->w = tex_str(s->text);\n\t\t\ts->gch->x = 4 + 4;\n\t\t}\n\t}\n}\n\n/* -- activate the tablature from the command line '-T' -- */\nstatic void set_tblt(struct VOICE_S *p_voice)\n{\n\tstruct tblt_s *tblt;\n\tint i;\n\n\tfor (i = 0; i < ncmdtblt; i++) {\n\t\tif (!cmdtblts[i].active)\n\t\t\tcontinue;\n\t\tif (cmdtblts[i].vn[0] != '\\0') {\n\t\t\tif (strcmp(cmdtblts[i].vn, p_voice->id) != 0\n\t\t\t && (p_voice->nm == 0\n\t\t\t  || strcmp(cmdtblts[i].vn, p_voice->nm) != 0)\n\t\t\t && (p_voice->snm == 0\n\t\t\t  || strcmp(cmdtblts[i].vn, p_voice->snm) != 0))\n\t\t\t\tcontinue;\n\t\t}\n\t\ttblt = tblts[cmdtblts[i].index];\n\t\tif (p_voice->tblts[0] == tblt\n\t\t || p_voice->tblts[1] == tblt)\n\t\t\tcontinue;\n\t\tif (p_voice->tblts[0] == 0)\n\t\t\tp_voice->tblts[0] = tblt;\n\t\telse\n\t\t\tp_voice->tblts[1] = tblt;\n\t}\n}\n\n/* -- do a tune -- */\nvoid do_tune(void)\n{\n\tstruct VOICE_S *p_voice;\n\tstruct SYMBOL *s, *s1, *s2;\n\tint i;\n\n\t/* initialize */\n\tlvlarena(0);\n\tnstaff = 0;\n\tstaves_found = -1;\n\tfor (i = 0; i < MAXVOICE; i++) {\n\t\tp_voice = &voice_tb[i];\n\t\ts1 = (struct SYMBOL *) getarena(sizeof *s1);\n\t\tmemset(s1, 0, sizeof *s1);\n\t\ts1->type = CLEF;\n\t\ts1->voice = i;\n\t\tif (cfmt.autoclef) {\n\t\t\ts1->u.clef.type = AUTOCLEF;\n\t\t\ts1->sflags = S_CLEF_AUTO;\n\t\t} else {\n\t\t\ts1->u.clef.type = TREBLE;\n\t\t}\n\t\ts1->u.clef.line = 2;\t\t/* treble clef on 2nd line */\n\t\tp_voice->s_clef = s1;\n\t\tp_voice->meter.wmeasure = 1;\t// M:none\n\t\tp_voice->wmeasure = 1;\n\t\tp_voice->scale = 1;\n\t\tp_voice->clone = -1;\n\t\tp_voice->over = -1;\n\t\tp_voice->posit = cfmt.posit;\n\t\tp_voice->stafflines = NULL;\n//\t\tp_voice->staffscale = 0;\n\t}\n\tcurvoice = first_voice = voice_tb;\n\treset_deco();\n\tabc2win = 0;\n\tclip_start.bar = -1;\n\tclip_end.bar = (short unsigned) ~0 >> 1;\n\n\tparsys = NULL;\n\tsystem_new();\t\t\t/* create the 1st staff system */\n\tparsys->top_voice = parsys->voice[0].range = 0;\t/* implicit voice */\n\n\tif (!epsf) {\n//fixme: 8.6.2\n#if 1\n// fixme: should already be 0\n\t\tuse_buffer = 0;\n#else\n\t\tif (cfmt.oneperpage) {\n\t\t\tuse_buffer = 0;\n\t\t\tclose_page();\n\t\t} else {\n\t\t\tif (in_page)\t\t// ??\n\t\t\t\tuse_buffer = cfmt.splittune != 1;\n\t\t}\n#endif\n\t} else {\n\t\tuse_buffer = 1;\n\t\tmarg_init();\n\t}\n\n\t/* set the duration of all notes/rests\n\t *\t(this is needed for tuplets and the feathered beams) */\n\tfor (s = parse.first_sym; s; s = s->abc_next) {\n\t\tswitch (s->abc_type) {\n\t\tcase ABC_T_EOLN:\n\t\t\tif (s->u.eoln.type == 2)\n\t\t\t\tabc2win = 1;\n\t\t\tbreak;\n\t\tcase ABC_T_NOTE:\n\t\tcase ABC_T_REST:\n\t\t\ts->dur = s->u.note.notes[0].len;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (voice_tb[0].id[0] == '\\0') {\t/* single voice */\n\t\tvoice_tb[0].id[0] = '1';\t/* implicit V:1 */\n\t\tvoice_tb[0].id[1] = '\\0';\n\t}\n\n\t/* scan the tune */\n\tfor (s = parse.first_sym; s; s = s->abc_next) {\n\t\tif (s->flags & ABC_F_LYRIC_START)\n\t\t\tcurvoice->lyric_start = curvoice->last_sym;\n\t\tswitch (s->abc_type) {\n\t\tcase ABC_T_INFO:\n\t\t\ts = get_info(s);\n\t\t\tbreak;\n\t\tcase ABC_T_PSCOM:\n\t\t\ts = process_pscomment(s);\n\t\t\tbreak;\n\t\tcase ABC_T_NOTE:\n\t\tcase ABC_T_REST:\n\t\t\tif (curvoice->space\n\t\t\t && !(s->flags & ABC_F_GRACE)) {\n\t\t\t\tcurvoice->space = 0;\n\t\t\t\ts->flags |= ABC_F_SPACE;\n\t\t\t}\n\t\t\tget_note(s);\n\t\t\tbreak;\n\t\tcase ABC_T_BAR:\n\t\t\tif (over_bar)\n\t\t\t\tget_over(s);\n\t\t\tget_bar(s);\n\t\t\tbreak;\n\t\tcase ABC_T_CLEF:\n\t\t\tget_clef(s);\n\t\t\tbreak;\n\t\tcase ABC_T_EOLN:\n\t\t\tif (cfmt.breakoneoln\n\t\t\t || (s->flags & ABC_F_SPACE))\n\t\t\t\tcurvoice->space = 1;\n\t\t\tif (cfmt.continueall || cfmt.barsperstaff\n\t\t\t || s->u.eoln.type == 1)\t/* if '\\' */\n\t\t\t\tcontinue;\n\t\t\tif (s->u.eoln.type == 0\t\t/* if normal eoln */\n\t\t\t && abc2win\n\t\t\t && parse.abc_vers != (2 << 16))\n\t\t\t\tcontinue;\n\t\t\tif (parsys->voice[curvoice - voice_tb].range == 0\n\t\t\t && curvoice->last_sym)\n\t\t\t\tcurvoice->last_sym->sflags |= S_EOLN;\n\t\t\tif (!cfmt.alignbars)\n\t\t\t\tcontinue;\t\t/* normal */\n\n\t\t\t/* align bars */\n\t\t\twhile (s->abc_next) {\t\t/* treat the lyrics */\n\t\t\t\tif (s->abc_next->abc_type != ABC_T_INFO)\n\t\t\t\t\tbreak;\n\t\t\t\tswitch (s->abc_next->text[0]) {\n\t\t\t\tcase 'w':\n\t\t\t\t\ts = get_info(s->abc_next);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'd':\n\t\t\t\tcase 's':\n\t\t\t\t\ts = s->abc_next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (curvoice - voice_tb) + 1;\n\t\t\tif (i < cfmt.alignbars) {\n\t\t\t\tcurvoice = &voice_tb[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgenerate();\n\t\t\tbuffer_eob(0);\n\t\t\tcurvoice = &voice_tb[0];\n\t\t\tcontinue;\n\t\tcase ABC_T_MREST: {\n\t\t\tint dur;\n\n\t\t\tdur = curvoice->wmeasure * s->u.bar.len;\n\t\t\tif (curvoice->second) {\n\t\t\t\tcurvoice->time += dur;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym_link(s, MREST);\n\t\t\ts->dur = dur;\n\t\t\tcurvoice->time += dur;\n\t\t\tif (s->text)\n\t\t\t\tgch_build(s);\t/* build the guitar chords */\n\t\t\tif (s->u.bar.dc.n > 0)\n\t\t\t\tdeco_cnv(&s->u.bar.dc, s, NULL);\n\t\t\tbreak;\n\t\t    }\n\t\tcase ABC_T_MREP: {\n\t\t\tint n;\n\n\t\t\ts2 = curvoice->last_sym;\n\t\t\tif (!s2 || s2->type != BAR) {\n\t\t\t\terror(1, s,\n\t\t\t\t      \"No bar before measure repeat\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (curvoice->ignore)\n\t\t\t\tbreak;\n\t\t\tn = s->u.bar.len;\n\t\t\tif (curvoice->second) {\n\t\t\t\tcurvoice->time += curvoice->wmeasure * n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts2 = sym_add(curvoice, NOTEREST);\n\t\t\ts2->abc_type = ABC_T_REST;\n\t\t\ts2->flags |= ABC_F_INVIS;\n\t\t\ts2->dur = curvoice->wmeasure;\n\t\t\tcurvoice->time += s2->dur;\n\t\t\tif (n == 1) {\n\t\t\t\ts->abc_next->u.bar.len = n; /* <n> in the next bar */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (--n > 0) {\n\t\t\t\ts2 = sym_add(curvoice, BAR);\n\t\t\t\ts2->u.bar.type = B_SINGLE;\n\t\t\t\tif (n == s->u.bar.len - 1)\n\t\t\t\t\ts2->u.bar.len = s->u.bar.len;\n\t\t\t\ts2 = sym_add(curvoice, NOTEREST);\n\t\t\t\ts2->abc_type = ABC_T_REST;\n\t\t\t\ts2->flags |= ABC_F_INVIS;\n\t\t\t\ts2->dur = curvoice->wmeasure;\n\t\t\t\tcurvoice->time += s2->dur;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\tcase ABC_T_V_OVER:\n\t\t\tget_over(s);\n\t\t\tcontinue;\n\t\tcase ABC_T_TUPLET:\n\t\t\tset_tuplet(s);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (s->type == 0)\n\t\t\tcontinue;\n\t\tif (curvoice->second)\n\t\t\ts->sflags |= S_SECOND;\n\t\tif (curvoice->floating)\n\t\t\ts->sflags |= S_FLOATING;\n\t}\n\n\tgen_ly(0);\n\tput_history();\n\tbuffer_eob(1);\n\tif (epsf) {\n\t\twrite_eps();\n\t} else {\n\t\twrite_buffer();\n//\t\tif (!cfmt.oneperpage && in_page)\n//\t\t\tuse_buffer = cfmt.splittune != 1;\n\t}\n\n\tif (info['X' - 'A']) {\n\t\tmemcpy(&cfmt, &dfmt, sizeof cfmt); /* restore global values */\n\t\tmemcpy(&info, &info_glob, sizeof info);\n\t\tmemcpy(deco, deco_glob, sizeof deco);\n\t\tmaps = maps_glob;\n\t\tinfo['X' - 'A'] = NULL;\n\t}\n\n\t/* free the parsing resources */\n\t{\n\t\tstruct brk_s *brk, *brk2;\n\n\t\tbrk = brks;\n\t\twhile (brk) {\n\t\t\tbrk2 = brk->next;\n\t\t\tfree(brk);\n\t\t\tbrk = brk2;\n\t\t}\n\t\tbrks = brk;\t\t/* (NULL) */\n\t}\n}\n\n/* check if a K: or M: may go to the tune key and time signatures */\nstatic int is_tune_sig(void)\n{\n\tstruct SYMBOL *s;\n\n\tif (!curvoice->sym)\n\t\treturn 1;\n\tif (curvoice->time != 0)\n\t\treturn 0;\t\t/* not at start of tune */\n\tfor (s = curvoice->sym; s; s = s->next) {\n\t\tswitch (s->type) {\n\t\tcase TEMPO:\n\t\tcase PART:\n\t\tcase FMTCHG:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/* -- get a clef definition (in K: or V:) -- */\nstatic void get_clef(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s2;\n\tstruct VOICE_S *p_voice;\n\tint voice;\n\n\tp_voice = curvoice;\n\ts->type = CLEF;\n\tif (s->abc_prev->abc_type == ABC_T_INFO) {\n\t\tswitch (s->abc_prev->text[0]) {\n\t\tcase 'K':\n\t\t\tif (s->abc_prev->state != ABC_S_HEAD)\n\t\t\t\tbreak;\n\t\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\t\tvoice_tb[voice].s_clef = s;\n\t\t\t\tif (s->u.clef.type == PERC)\n\t\t\t\t\tvoice_tb[voice].perc = 1;\n\t\t\t}\n\t\t\treturn;\n\t\tcase 'V':\t/* clef relative to a voice definition in the header */\n\t\t\tp_voice = &voice_tb[(int) s->abc_prev->u.voice.voice];\n\t\t\tcurvoice = p_voice;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (is_tune_sig()) {\n\t\tp_voice->s_clef = s;\n\t} else {\t\t\t\t/* clef change */\n\n#if 0\n\t\tsym_link(s, CLEF);\n#else\n\t\t/* the clef must appear before a key signature or a bar */\n\t\ts2 = p_voice->last_sym;\n\t\tif (s2 && s2->prev\n\t\t && s2->time == curvoice->time\t\t// if no time skip\n\t\t && (s2->type == KEYSIG || s2->type == BAR)) {\n\t\t\tstruct SYMBOL *s3;\n\n\t\t\tfor (s3 = s2; s3->prev; s3 = s3->prev) {\n\t\t\t\tswitch (s3->prev->type) {\n\t\t\t\tcase KEYSIG:\n\t\t\t\tcase BAR:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp_voice->last_sym = s3->prev;\n\t\t\tsym_link(s, CLEF);\n\t\t\ts->next = s3;\n\t\t\ts3->prev = s;\n\t\t\tp_voice->last_sym = s2;\n\t\t} else {\n\t\t\tsym_link(s, CLEF);\n\t\t}\n#endif\n\t\ts->aux = 1;\t\t\t/* small clef */\n\t}\n\tp_voice->perc = s->u.clef.type == PERC;\n\tif (s->u.clef.type == AUTOCLEF)\n\t\ts->sflags |= S_CLEF_AUTO;\n}\n\n/* -- treat %%clef -- */\nstatic void clef_def(struct SYMBOL *s)\n{\n\tchar *p;\n\tint clef, clef_line;\n\tchar str[80];\n\n\tclef = -1;\n\tclef_line = 2;\n\tp = &s->text[2 + 5];\t\t/* skip %%clef */\n\twhile (isspace((unsigned char) *p))\n\t\tp++;\n\n\t/* clef name */\n\tswitch (*p) {\n\tcase '\\\"':\t\t\t/* user clef name */\n\t\tp = get_str(str, p, sizeof str);\n\t\ts->u.clef.name = (char *) getarena(strlen(str) + 1);\n\t\tstrcpy(s->u.clef.name, str);\n\t\tclef = TREBLE;\n\t\tbreak;\n\tcase 'G':\n\t\tclef = TREBLE;\n\t\tp++;\n\t\tbreak;\n\tcase 'F':\n\t\tclef = BASS;\n\t\tclef_line = 4;\n\t\tp++;\n\t\tbreak;\n\tcase 'C':\n\t\tclef = ALTO;\n\t\tclef_line = 3;\n\t\tp++;\n\t\tbreak;\n\tcase 'P':\n\t\tclef = PERC;\n\t\tp++;\n\t\tbreak;\n\tcase 't':\n\t\tif (strncmp(p, \"treble\", 6) == 0) {\n\t\t\tclef = TREBLE;\n\t\t\tp += 6;\n\t\t}\n\t\tif (strncmp(p, \"tenor\", 5) == 0) {\n\t\t\tclef = ALTO;\n\t\t\tclef_line = 4;\n\t\t\tp += 5;\n\t\t}\n\t\tbreak;\n\tcase 'a':\n\t\tif (strncmp(p, \"alto\", 4) == 0) {\n\t\t\tclef = ALTO;\n\t\t\tclef_line = 3;\n\t\t\tp += 4;\n\t\t} else if (strncmp(p, \"auto\", 4) == 0) {\n\t\t\tclef = AUTOCLEF;\n\t\t\ts->sflags |= S_CLEF_AUTO;\n\t\t\tp += 4;\n\t\t}\n\t\tbreak;\n\tcase 'b':\n\t\tif (strncmp(p, \"bass\", 4) == 0) {\n\t\t\tclef = BASS;\n\t\t\tclef_line = 4;\n\t\t\tp += 4;\n\t\t}\n\t\tbreak;\n\tcase 'p':\n\t\tif (strncmp(p, \"perc\", 4) == 0) {\n\t\t\tclef = PERC;\n\t\t\tp += 4;\n\t\t}\n\t\tbreak;\n\tcase 'n':\n\t\tif (strncmp(p, \"none\", 4) == 0) {\n\t\t\tclef = TREBLE;\n\t\t\ts->u.clef.invis = 1;\n\t\t\ts->flags |= ABC_F_INVIS;\n\t\t\tp += 4;\n\t\t}\n\t\tbreak;\n\t}\n\tif (clef < 0) {\n\t\terror(1, s, \"Unknown clef '%s'\", p);\n\t\treturn;\n\t}\n\n\t/* clef line */\n\tswitch (*p) {\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\t\tclef_line = *p++ - '0';\n\t\tbreak;\n\t}\n\n\t/* +/-/^/_8 */\n\tif (p[1] == '8') {\n\t\tswitch (*p) {\n\t\tcase '^':\n\t\t\ts->u.clef.transpose = -7;\n\t\tcase '+':\n\t\t\ts->u.clef.octave = 1;\n\t\t\tbreak;\n\t\tcase '_':\n\t\t\ts->u.clef.transpose = 7;\n\t\tcase '-':\n\t\t\ts->u.clef.octave = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* handle the clef */\n\ts->abc_type = ABC_T_CLEF;\n\ts->u.clef.type = clef;\n\ts->u.clef.line = clef_line;\n\tget_clef(s);\n}\n\n/* transpose a key */\nstatic void key_transpose(struct key_s *key)\n{\n\tint t, sf;\n\n\tt = curvoice->transpose / 3;\n\tsf = (t & ~1) + (t & 1) * 7 + key->sf;\n\tswitch ((curvoice->transpose + 210) % 3) {\n\tcase 1:\n\t\tsf = (sf + 4 + 12 * 4) % 12 - 4;\t/* more sharps */\n\t\tbreak;\n\tcase 2:\n\t\tsf = (sf + 7 + 12 * 4) % 12 - 7;\t/* more flats */\n\t\tbreak;\n\tdefault:\n\t\tsf = (sf + 5 + 12 * 4) % 12 - 5;\t/* Db, F# or B */\n\t\tbreak;\n\t}\n\tkey->sf = sf;\n}\n\n/* -- set the accidentals when K: with modified accidentals -- */\nstatic void set_k_acc(struct SYMBOL *s)\n{\n\tint i, j, nacc;\n\tchar accs[8], pits[8];\n\tstatic char sharp_tb[8] = {26, 23, 27, 24, 21, 25, 22};\n\tstatic char flat_tb[8] = {22, 25, 21, 24, 20, 23, 26};\n\n\tif (s->u.key.sf > 0) {\n\t\tfor (nacc = 0; nacc < s->u.key.sf; nacc++) {\n\t\t\taccs[nacc] = A_SH;\n\t\t\tpits[nacc] = sharp_tb[nacc];\n\t\t}\n\t} else {\n\t\tfor (nacc = 0; nacc < -s->u.key.sf; nacc++) {\n\t\t\taccs[nacc] = A_FT;\n\t\t\tpits[nacc] = flat_tb[nacc];\n\t\t}\n\t}\n\tfor (i = 0; i < s->u.key.nacc; i++) {\n\t\tfor (j = 0; j < nacc; j++) {\n//\t\t\tif ((pits[j] - s->u.key.pits[i]) % 7 == 0) {\n\t\t\tif (pits[j] == s->u.key.pits[i]) {\n\t\t\t\taccs[j] = s->u.key.accs[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == nacc) {\n\t\t\tif (nacc >= sizeof accs) {\n\t\t\t\terror(1, s, \"Too many accidentals\");\n\t\t\t} else {\n\t\t\t\taccs[j] = s->u.key.accs[i];\n\t\t\t\tpits[j] = s->u.key.pits[i];\n\t\t\t\tnacc++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < nacc; i++) {\n\t\ts->u.key.accs[i] = accs[i];\n\t\ts->u.key.pits[i] = pits[i];\n\t}\n\ts->u.key.nacc = nacc;\n}\n\n/* -- get a key signature definition (K:) -- */\nstatic void get_key(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice;\n\tstruct SYMBOL *s2;\n\tstruct key_s okey;\t\t\t/* original key */\n\tint i;\n// int delta;\n\n\tif (s->u.key.octave != NO_OCTAVE)\n\t\tcurvoice->octave = s->u.key.octave;\n\tif (s->u.key.cue > 0)\n\t\tcurvoice->scale = 0.7;\n\telse if (s->u.key.cue < 0)\n\t\tcurvoice->scale = 1;\n\tif (s->u.key.stafflines)\n\t\tcurvoice->stafflines = s->u.key.stafflines;\n\tif (s->u.key.staffscale != 0)\n\t\tcurvoice->staffscale = s->u.key.staffscale;\n\n\tif (s->u.key.empty == 1)\t\t/* clef only */\n\t\treturn;\n\n\tif (s->u.key.sf != 0\n\t && !s->u.key.exp\n\t && s->u.key.nacc != 0)\n\t\tset_k_acc(s);\n\n\tmemcpy(&okey, &s->u.key, sizeof okey);\n\tif (s->state == ABC_S_HEAD) {\t\t/* if first K: (start of tune) */\n\t\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t\t     --i >= 0;\n\t\t     p_voice++)\n\t\t\tp_voice->transpose = cfmt.transpose;\n//\t\tcurvoice->transpose = cfmt.transpose;\n\t}\n\tif (curvoice->transpose != 0) {\n\t\tkey_transpose(&s->u.key);\n\n#if 0\n\t\t/* transpose explicit accidentals */\n//fixme: not correct - transpose adds or removes accidentals...\n\t\tif (s->u.key.nacc > 0) {\n\t\t\tstruct VOICE_S voice, *voice_sav;\n\t\t\tstruct SYMBOL note;\n\n\t\t\tmemset(&voice, 0, sizeof voice);\n\t\t\tvoice.transpose = curvoice->transpose;\n\t\t\tmemcpy(&voice.ckey, &s->u.key, sizeof voice.ckey);\n\t\t\tvoice.ckey.empty = 2;\n\t\t\tvoice.ckey.nacc = 0;\n\t\t\tmemset(&note, 0, sizeof note);\n--fixme\n\t\t\tmemcpy(note.u.note.pits, voice.ckey.pits,\n\t\t\t\t\tsizeof note.u.note.pits);\n\t\t\tmemcpy(note.u.note.accs, voice.ckey.accs,\n\t\t\t\t\tsizeof note.u.note.accs);\n\t\t\tnote.nhd = s->u.key.nacc;\n\t\t\tvoice_sav = curvoice;\n\t\t\tcurvoice = &voice;\n\t\t\tnote_transpose(&note);\n\t\t\tmemcpy(s->u.key.pits, note.u.note.pits,\n\t\t\t\t\tsizeof s->u.key.pits);\n\t\t\tmemcpy(s->u.key.accs, note.u.note.accs,\n\t\t\t\t\tsizeof s->u.key.accs);\n\t\t\tcurvoice = voice_sav;\n\t\t}\n#endif\n\t}\n\n\t// calculate the tonic delta\n//\ts->u.key.key_delta = (cgd2cde[(s->u.key.sf + 7) % 7] + 14 + s->u.key.mode) % 7;\n\ts->u.key.key_delta = (cgd2cde[(s->u.key.sf + 7) % 7] + 14) % 7;\n\n\tif (s->state == ABC_S_HEAD) {\t/* start of tune */\n\t\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t\t     --i >= 0;\n\t\t     p_voice++) {\n\t\t\tmemcpy(&p_voice->key, &s->u.key,\n\t\t\t\t\t\tsizeof p_voice->key);\n\t\t\tmemcpy(&p_voice->ckey, &s->u.key,\n\t\t\t\t\t\tsizeof p_voice->ckey);\n\t\t\tmemcpy(&p_voice->okey, &okey,\n\t\t\t\t\t\tsizeof p_voice->okey);\n\t\t\tif (p_voice->key.empty)\n\t\t\t\tp_voice->key.sf = 0;\n\t\t\tif (s->u.key.octave != NO_OCTAVE)\n\t\t\t\tp_voice->octave = s->u.key.octave;\n\t\t\tif (s->u.key.stafflines)\n\t\t\t\tp_voice->stafflines = s->u.key.stafflines;\n\t\t\tif (s->u.key.staffscale != 0)\n\t\t\t\tp_voice->staffscale = s->u.key.staffscale;\n//fixme: update parsys->voice[voice].stafflines = stafflines; ?\n\t\t}\n\t\treturn;\n\t}\n\n\t/* ABC_S_TUNE (K: cannot be ABC_S_GLOBAL) */\n\tif (is_tune_sig()) {\n\n\t\t/* define the starting key signature */\n\t\tmemcpy(&curvoice->key, &s->u.key,\n\t\t\t\t\tsizeof curvoice->key);\n\t\tmemcpy(&curvoice->ckey, &s->u.key,\n\t\t\t\t\tsizeof curvoice->ckey);\n\t\tmemcpy(&curvoice->okey, &okey,\n\t\t\t\t\tsizeof curvoice->okey);\n\t\tswitch (curvoice->key.instr) {\n\t\tcase 0:\n\t\t\tif (!pipeformat) {\n//\t\t\t\tcurvoice->transpose = cfmt.transpose;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//fall thru\n\t\tcase K_HP:\n\t\tcase K_Hp:\n\t\t\tif (curvoice->posit.std == 0)\n\t\t\t\tcurvoice->posit.std = SL_BELOW;\n\t\t\tbreak;\n\t\t}\n\t\tif (curvoice->key.empty)\n\t\t\tcurvoice->key.sf = 0;\n\t\treturn;\n\t}\n\n\t/* key signature change */\n\tif ((!s->abc_next\n\t  || s->abc_next->abc_type != ABC_T_CLEF)\t/* if not explicit clef */\n\t && curvoice->ckey.sf == s->u.key.sf\t/* and same key */\n\t && curvoice->ckey.nacc == 0\n\t && s->u.key.nacc == 0\n\t && curvoice->ckey.empty == s->u.key.empty\n\t && cfmt.keywarn)\t\t\t/* (if not key warning,\n\t\t\t\t\t\t *  keep all key signatures) */\n\t\treturn;\t\t\t\t/* ignore */\n\n\tif (!curvoice->ckey.empty)\n\t\ts->aux = curvoice->ckey.sf;\t/* previous key signature */\n\tmemcpy(&curvoice->ckey, &s->u.key,\n\t\t\t\tsizeof curvoice->ckey);\n\tmemcpy(&curvoice->okey, &okey,\n\t\t\t\tsizeof curvoice->okey);\n\tif (s->u.key.empty)\n\t\ts->u.key.sf = 0;\n\n\t/* the key signature must appear before a time signature */\n\ts2 = curvoice->last_sym;\n\tif (s2 && s2->type == TIMESIG) {\n\t\tcurvoice->last_sym = s2->prev;\n\t\tif (!curvoice->last_sym)\n\t\t\tcurvoice->sym = NULL;\n\t\tsym_link(s, KEYSIG);\n\t\ts->next = s2;\n\t\ts2->prev = s;\n\t\tcurvoice->last_sym = s2;\n\t} else {\n\t\tsym_link(s, KEYSIG);\n\t}\n}\n\n/* -- set meter from M: -- */\nstatic void get_meter(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice;\n\tint i;\n\n\tswitch (s->state) {\n\tcase ABC_S_GLOBAL:\n\t\t/*fixme: keep the values and apply to all tunes?? */\n\t\tbreak;\n\tcase ABC_S_HEAD:\n\t\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t\t     --i >= 0;\n\t\t     p_voice++) {\n\t\t\tmemcpy(&p_voice->meter, &s->u.meter,\n\t\t\t       sizeof p_voice->meter);\n\t\t\tp_voice->wmeasure = s->u.meter.wmeasure;\n\t\t}\n\t\tbreak;\n\tcase ABC_S_TUNE:\n\t\tcurvoice->wmeasure = s->u.meter.wmeasure;\n\t\tif (is_tune_sig()) {\n\t\t\tmemcpy(&curvoice->meter, &s->u.meter,\n\t\t\t\t       sizeof curvoice->meter);\n\t\t\treset_gen();\t/* (display the time signature) */\n\t\t\tbreak;\n\t\t}\n\t\tif (s->u.meter.nmeter == 0)\n\t\t\tbreak;\t\t/* M:none */\n\t\tsym_link(s, TIMESIG);\n\t\tbreak;\n\t}\n}\n\n/* -- treat a 'V:' -- */\nstatic void get_voice(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice;\n\tint voice;\n\n\tvoice = s->u.voice.voice;\n\tp_voice = &voice_tb[voice];\n\tif (parsys->voice[voice].range < 0) {\n\t\tif (cfmt.alignbars) {\n\t\t\terror(1, s, \"V: does not work with %%%%alignbars\");\n\t\t}\n\t\tif (staves_found < 0) {\n\t\t\tif (!s->u.voice.merge) {\n#if MAXSTAFF < MAXVOICE\n\t\t\t\tif (nstaff >= MAXSTAFF - 1) {\n\t\t\t\t\terror(1, s, \"Too many staves\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n#endif\n\t\t\t\tnstaff++;\n\t\t\t} else {\n\t\t\t\tp_voice->second = 1;\n\t\t\t\tparsys->voice[voice].second = 1;\n\t\t\t}\n\t\t\tp_voice->staff = p_voice->cstaff = nstaff;\n\t\t\tparsys->voice[voice].staff = nstaff;\n\t\t\tparsys->nstaff = nstaff;\n\t\t\t{\n\t\t\t\tint range, i;\n\n\t\t\t\trange = 0;\n\t\t\t\tfor (i = 0; i < MAXVOICE; i++) {\n\t\t\t\t\tif (parsys->voice[i].range > range)\n\t\t\t\t\t\trange = parsys->voice[i].range;\n\t\t\t\t}\n\t\t\t\tparsys->voice[voice].range = range + 1;\n\t\t\t\tvoice_link(p_voice);\n\t\t\t}\n\t\t} else {\n\t\t\tp_voice->ignore = 1;\n\t\t\tp_voice->staff = p_voice->cstaff = nstaff + 1;\n\t\t}\n\t}\n\n\t/* if something has changed, update */\n\tif (s->u.voice.fname != 0) {\n\t\tp_voice->nm = s->u.voice.fname;\n\t\tp_voice->new_name = 1;\n\t}\n\tif (s->u.voice.nname != 0)\n\t\tp_voice->snm = s->u.voice.nname;\n\tif (s->u.voice.octave != NO_OCTAVE)\n\t\tp_voice->octave = s->u.voice.octave;\n\tswitch (s->u.voice.dyn) {\n\tcase 1:\n\t\tp_voice->posit.dyn = SL_ABOVE;\n\t\tp_voice->posit.vol = SL_ABOVE;\n\t\tbreak;\n\tcase -1:\n\t\tp_voice->posit.dyn = SL_BELOW;\n\t\tp_voice->posit.vol = SL_BELOW;\n\t\tbreak;\n\t}\n\tswitch (s->u.voice.lyrics) {\n\tcase 1:\n\t\tp_voice->posit.voc = SL_ABOVE;\n\t\tbreak;\n\tcase -1:\n\t\tp_voice->posit.voc = SL_BELOW;\n\t\tbreak;\n\t}\n\tswitch (s->u.voice.gchord) {\n\tcase 1:\n\t\tp_voice->posit.gch = SL_ABOVE;\n\t\tbreak;\n\tcase -1:\n\t\tp_voice->posit.gch = SL_BELOW;\n\t\tbreak;\n\t}\n\tswitch (s->u.voice.stem) {\n\tcase 1:\n\t\tp_voice->posit.std = SL_ABOVE;\n\t\tbreak;\n\tcase -1:\n\t\tp_voice->posit.std = SL_BELOW;\n\t\tbreak;\n\tcase 2:\n\t\tp_voice->posit.std = 0;\t\t/* auto */\n\t\tbreak;\n\t}\n\tswitch (s->u.voice.gstem) {\n\tcase 1:\n\t\tp_voice->posit.gsd = SL_ABOVE;\n\t\tbreak;\n\tcase -1:\n\t\tp_voice->posit.gsd = SL_BELOW;\n\t\tbreak;\n\tcase 2:\n\t\tp_voice->posit.gsd = 0;\t\t/* auto */\n\t\tbreak;\n\t}\n\tif (s->u.voice.scale != 0)\n\t\tp_voice->scale = s->u.voice.scale;\n\telse if (s->u.voice.cue > 0)\n\t\tp_voice->scale = 0.7;\n\telse if (s->u.voice.cue < 0)\n\t\tp_voice->scale = 1;\n\tif (s->u.voice.stafflines)\n\t\tp_voice->stafflines = s->u.voice.stafflines;\n\tif (s->u.voice.staffscale != 0)\n\t\tp_voice->staffscale = s->u.voice.staffscale;\n\tif (!p_voice->combine)\n\t\tp_voice->combine = cfmt.combinevoices;\n\n\tset_tblt(p_voice);\n\n\t/* if in tune, switch to this voice */\n\tif (s->state == ABC_S_TUNE)\n\t\tcurvoice = p_voice;\n}\n\n/* sort the notes of the chord by pitch (lowest first) */\nvoid sort_pitch(struct SYMBOL *s)\n{\n\tint i, nx, k;\n\tstruct note v_note;\n\tunsigned char new_order[MAXHD], inv_order[MAXHD];\n\n\tfor (i = 0; i <= s->nhd; i++)\n\t\tnew_order[i] = i;\n\tfor (;;) {\n\t\tnx = 0;\n\t\tfor (i = 1; i <= s->nhd; i++) {\n\t\t\tif (s->u.note.notes[i].pit >= s->u.note.notes[i - 1].pit)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(&v_note, &s->u.note.notes[i],\n\t\t\t\t\tsizeof v_note);\n\t\t\tmemcpy(&s->u.note.notes[i], &s->u.note.notes[i - 1],\n\t\t\t\t\tsizeof v_note);\n\t\t\tmemcpy(&s->u.note.notes[i - 1], &v_note,\n\t\t\t\t\tsizeof v_note);\n\t\t\tk = s->pits[i];\n\t\t\ts->pits[i] = s->pits[i - 1];\n\t\t\ts->pits[i - 1] = k;\n\t\t\tk = new_order[i];\n\t\t\tnew_order[i] = new_order[i - 1];\n\t\t\tnew_order[i - 1] = k;\n\t\t\tnx++;\n\t\t}\n\t\tif (nx == 0)\n\t\t\tbreak;\n\t}\n\n\t/* change the indexes of the note head decorations */\n\tif (s->nhd > 0) {\n\t\tfor (i = 0; i <= s->nhd; i++)\n\t\t\tinv_order[new_order[i]] = i;\n\t\tfor (i = 0; i <= s->u.note.dc.n; i++) {\n\t\t\tk = s->u.note.dc.tm[i].m;\n\t\t\tif (k >= 0)\n\t\t\t\ts->u.note.dc.tm[i].m = inv_order[k];\n\t\t}\n\t}\n}\n\n// set the map of the notes\nstatic void set_map(struct SYMBOL *s)\n{\n\tstruct map *map;\n\tstruct note_map *note_map;\n\tstruct note *note;\n\tint m, delta;\n\n\tfor (map = maps; map; map = map->next) {\n\t\tif (strcmp(map->name, curvoice->map_name) == 0)\n\t\t\tbreak;\n\t}\n\tif (!map)\n\t\treturn;\t\t\t// !?\n\n\t// loop on the note maps, then on the notes of the chord\n\tdelta = curvoice->ckey.key_delta;\n\tfor (m = 0; m <= s->nhd; m++) {\n\t\tnote = &s->u.note.notes[m];\n\t\tfor (note_map = map->notes; note_map; note_map = note_map->next) {\n\t\t\tswitch (note_map->type) {\n\t\t\tcase MAP_ONE:\n\t\t\t\tif (note->pit == note_map->pit\n\t\t\t\t && note->acc == note_map->acc)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\tcase MAP_OCT:\n\t\t\t\tif ((note->pit - note_map->pit + 28 ) % 7 == 0\n\t\t\t\t && note->acc == note_map->acc)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\tcase MAP_KEY:\n\t\t\t\tif ((note->pit + 28 - delta - note_map->pit) % 7 == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\tdefault: // MAP_ALL\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnote->head = note_map->heads;\n\t\t\tnote->color = note_map->color;\n\t\t\tif (note_map->print_pit != -128) {\n\t\t\t\tnote->pit = note_map->print_pit;\n\t\t\t\ts->pits[m] = note->pit;\n\t\t\t\tnote->acc = note_map->print_acc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* -- note or rest -- */\nstatic void get_note(struct SYMBOL *s)\n{\n\tstruct SYMBOL *prev;\n\tint i, m, delta;\n\n\tprev = curvoice->last_sym;\n\tm = s->nhd;\n\n\t/* insert the note/rest in the voice */\n\tsym_link(s,  s->u.note.notes[0].len != 0 ? NOTEREST : SPACE);\n\tif (!(s->flags & ABC_F_GRACE))\n\t\tcurvoice->time += s->dur;\n\n\tif (curvoice->octave) {\n\t\tdelta = curvoice->octave * 7;\n\t\tfor (i = 0; i <= m; i++) {\n\t\t\ts->u.note.notes[i].pit += delta;\n\t\t\ts->pits[i] += delta;\n\t\t}\n\t}\n\n\t/* convert the decorations\n\t * (!beam-accel! and !beam-rall! may change the note duration)\n\t * (!8va(! may change ottava)\n\t */\n\tif (s->u.note.dc.n > 0)\n\t\tdeco_cnv(&s->u.note.dc, s, prev);\n\n\tif (curvoice->ottava) {\n\t\tdelta = curvoice->ottava;\n\t\tfor (i = 0; i <= m; i++)\n\t\t\ts->pits[i] += delta;\n\t}\n\ts->combine = curvoice->combine;\n\ts->color = curvoice->color;\n\n\tif (curvoice->perc)\n\t\ts->sflags |= S_PERC;\n\telse if (s->abc_type == ABC_T_NOTE\n\t      && curvoice->transpose != 0)\n\t\tnote_transpose(s);\n\n\tif (!(s->flags & ABC_F_GRACE)) {\n\t\tswitch (curvoice->posit.std) {\n\t\tcase SL_ABOVE: s->stem = 1; break;\n\t\tcase SL_BELOW: s->stem = -1; break;\n\t\tcase SL_HIDDEN: s->flags |= ABC_F_STEMLESS;; break;\n\t\t}\n\t} else {\t\t\t/* grace note - adjust its duration */\n\t\tint div;\n\n\t\tif (curvoice->key.instr != K_HP\n\t\t && curvoice->key.instr != K_Hp\n\t\t && !pipeformat) {\n\t\t\tdiv = 2;\n\t\t\tif (!prev\n\t\t\t || !(prev->flags & ABC_F_GRACE)) {\n\t\t\t\tif (s->flags & ABC_F_GR_END)\n\t\t\t\t\tdiv = 1;\t/* one grace note */\n\t\t\t}\n\t\t} else {\n\t\t\tdiv = 4;\t\t\t/* bagpipe */\n\t\t}\n\t\tfor (i = 0; i <= m; i++)\n\t\t\ts->u.note.notes[i].len /= div;\n\t\ts->dur /= div;\n\t\tswitch (curvoice->posit.gsd) {\n\t\tcase SL_ABOVE: s->stem = 1; break;\n\t\tcase SL_BELOW: s->stem = -1; break;\n\t\tcase SL_HIDDEN:\ts->stem = 2; break;\t/* opposite */\n\t\t}\n\t}\n\n\ts->nohdi1 = s->nohdi2 = -1;\n\n\t/* change the figure of whole measure rests */\n\tif (s->abc_type == ABC_T_REST) {\n\t\tif (s->dur == curvoice->wmeasure) {\n\t\t\tif (s->dur < BASE_LEN * 2)\n\t\t\t\ts->u.note.notes[0].len = BASE_LEN;\n\t\t\telse if (s->dur < BASE_LEN * 4)\n\t\t\t\ts->u.note.notes[0].len = BASE_LEN * 2;\n\t\t\telse\n\t\t\t\ts->u.note.notes[0].len = BASE_LEN * 4;\n\t\t}\n\t} else {\n\n\t\t/* sort the notes of the chord by pitch (lowest first) */\n\t\tif (!(s->flags & ABC_F_GRACE)\n\t\t && curvoice->map_name)\n\t\t\tset_map(s);\n\t\tsort_pitch(s);\n\t}\n\n\t/* get the max head type, number of dots and number of flags */\n\tif (!curvoice->auto_len || (s->flags & ABC_F_GRACE)) {\n\t\tint head, dots, nflags, l;\n\n\t\tif ((l = s->u.note.notes[0].len) != 0) {\n\t\t\tidentify_note(s, l, &head, &dots, &nflags);\n\t\t\ts->head = head;\n\t\t\ts->dots = dots;\n\t\t\ts->nflags = nflags;\n\t\t\tfor (i = 1; i <= m; i++) {\n\t\t\t\tif (s->u.note.notes[i].len == l)\n\t\t\t\t\tcontinue;\n\t\t\t\tidentify_note(s, s->u.note.notes[i].len,\n\t\t\t\t\t\t&head, &dots, &nflags);\n\t\t\t\tif (head > s->head)\n\t\t\t\t\ts->head = head;\n\t\t\t\tif (dots > s->dots)\n\t\t\t\t\ts->dots = dots;\n\t\t\t\tif (nflags > s->nflags)\n\t\t\t\t\ts->nflags = nflags;\n\t\t\t}\n\t\t\tif (s->sflags & S_XSTEM)\n\t\t\t\ts->nflags = 0;\t\t/* word start+end */\n\t\t}\n\t}\n\tif (s->nflags <= -2)\n\t\ts->flags |= ABC_F_STEMLESS;\n\n\tif (s->sflags & (S_TREM1 | S_TREM2)) {\n\t\tif (s->nflags > 0)\n\t\t\ts->nflags += s->aux;\n\t\telse\n\t\t\ts->nflags = s->aux;\n\t\tif ((s->sflags & S_TREM2)\n\t\t && (s->sflags & S_BEAM_END)) {\t\t/* if 2nd note - see deco.c */\n\t\t\tprev->head = s->head;\n\t\t\tprev->aux = s->aux;\n\t\t\tprev->nflags = s->nflags;\n\t\t\tprev->flags |= (s->flags & ABC_F_STEMLESS);\n\t\t}\n\t}\n\n\tfor (i = 0; i <= m; i++) {\n\t\tif (s->u.note.notes[i].sl1 != 0)\n\t\t\ts->sflags |= S_SL1;\n\t\tif (s->u.note.notes[i].sl2 != 0)\n\t\t\ts->sflags |= S_SL2;\n\t\tif (s->u.note.notes[i].ti1 != 0)\n\t\t\ts->sflags |= S_TI1;\n\t}\n\n\tswitch (cfmt.shiftunison) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\ts->sflags |= S_SHIFTUNISON_1;\n\t\tbreak;\n\tcase 2:\n\t\ts->sflags |= S_SHIFTUNISON_2;\n\t\tbreak;\n\tdefault:\n\t\ts->sflags |= S_SHIFTUNISON_1 | S_SHIFTUNISON_2;\n\t\tbreak;\n\t}\n\n\t/* build the guitar chords */\n\tif (s->text)\n\t\tgch_build(s);\n}\n\nstatic char *get_val(char *p, float *v)\n{\n\tchar tmp[32], *r = tmp;\n\n\twhile (isspace((unsigned char) *p))\n\t\tp++;\n\twhile ((isdigit((unsigned char) *p) && r < &tmp[32 - 1])\n\t    || *p == '-' || *p == '.')\n\t\t*r++ = *p++;\n\t*r = '\\0';\n\tsscanf(tmp, \"%f\", v);\n\treturn p;\n}\n\n// parse <path .../> from %%beginsvg and convert to Postscript\nstatic void parse_path(char *p, char *q, char *id, int idsz)\n{\n\tstruct SYMBOL *s;\n\tchar *buf, *r, *t, *op = NULL, *width, *scale, *trans;\n\tint i, fill, npar = 0;\n\tfloat x1, y1, x, y;\nchar *rmax;\n\n\tr = strstr(p, \"class=\\\"\");\n\tif (!r || r > q)\n\t\treturn;\n\tr += 7;\n\tfill = strncmp(r, \"fill\", 4) == 0;\n\twidth = strstr(p, \"stroke-width:\");\n\tscale = strstr(p, \"scale(\");\n\tif (scale && scale > q)\n\t\tscale = NULL;\n\ttrans = strstr(p, \"translate(\");\n\tif (trans && trans > q)\n\t\ttrans = NULL;\n\tfor (;;) {\n\t\tp = strstr(p, \"d=\\\"\");\n\t\tif (!p)\n\t\t\treturn;\n\t\tif (isspace((unsigned char) p[-1]))\t// (check not 'id=..\")\n\t\t\tbreak;\n\t\tp += 3;\n\t}\n\ti = (int) (q - p) * 4 + 200;\t\t// estimated PS buffer size\n\tif (i > TEX_BUF_SZ)\n\t\tbuf = malloc(i);\n\telse\n\t\tbuf = tex_buf;\nrmax=buf + i;\n\tr = buf;\n\t*r++ = '/';\n\tidsz -= 5;\n\tstrncpy(r, id + 4, idsz);\n\tr += idsz;\n\tstrcpy(r, \"{gsave T \");\n\tr += strlen(r);\n\tif (scale || trans) {\n\t\tif (scale) {\n\t\t\tscale += 6;\t\t// \"scale(\"\n\t\t\tt = get_val(scale, &x1);\n\t\t\tif (*t == ',')\n\t\t\t\tt = get_val(t + 1, &y1);\n\t\t\telse\n\t\t\t\ty1 = x1;\n\t\t}\n\t\tif (trans) {\n\t\t\ttrans += 10;\t\t// \"translate(\"\n\t\t\tt = get_val(trans, &x) + 1; //\",\"\n\t\t\tt = get_val(t, &y);\n\t\t}\n\t\tif (!scale)\n\t\t\tr += sprintf(r, \"%.2f %.2f T \", x, -y);\n\t\telse if (!trans)\n\t\t\tr += sprintf(r, \"%.2f %.2f scale \", x1, y1);\n\t\telse if (scale > trans)\n\t\t\tr += sprintf(r, \"%.2f %.2f T %.2f %.2f scale \",\n\t\t\t\t\tx, -y, x1, y1);\n\t\telse\n\t\t\tr += sprintf(r, \"%.2f %.2f scale %.2f %.2f T \",\n\t\t\t\t\tx1, y1, x, -y);\n\t}\n\tstrcpy(r, \"0 0 M\\n\");\n\tr += strlen(r);\n\tif (width && width < q) {\n\t\t*r++ = ' ';\n\t\twidth += 13;\n\t\twhile (isdigit(*width) || *width == '.')\n\t\t\t*r++ = *width++;\n\t\t*r++ = ' ';\n\t\t*r++ = 'S';\n\t\t*r++ = 'L';\n\t\t*r++ = 'W';\n\t}\n\tp += 3;\n\tfor (;;) {\n\t\tif (*p == '\\0' || *p == '\"')\n\t\t\tbreak;\n\t\ti = 0;\n\t\tswitch (*p++) {\n\t\tdefault:\n\t\t\tif ((isdigit((unsigned char) p[-1]))\n\t\t\t || p[-1] == '-' || p[-1] == '.') {\n\t\t\t\tif (!npar)\n\t\t\t\t\tcontinue;\n\t\t\t\tp--;\t\t\t// same op\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 'M':\n\t\t\top = \"M\";\n\t\t\tnpar = 2;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\top = \"RM\";\n\t\t\tnpar = 2;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\top = \"L\";\n\t\t\tnpar = 2;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\top = \"RL\";\n\t\t\tnpar = 2;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\top = \"H\";\n\t\t\tnpar = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\top = \"h\";\n\t\t\tnpar = 1;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\top = \"V\";\n\t\t\tnpar = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t*r++ = ' ';\n\t\t\t*r++ = '0';\n\t\t\top = \"RL\";\n\t\t\ti = 1;\n\t\t\tnpar = 2;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\top = \"closepath\";\n\t\t\tnpar = 0;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\top = \"C\";\n\t\t\tnpar = 6;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\top = \"RC\";\n\t\t\tnpar = 6;\n\t\t\tbreak;\n//\t\tcase 'A':\n//\t\t\top = \"arc\";\n//\t\t\tbreak;\n//\t\tcase 'a':\n//\t\t\top = \"arc\";\n//\t\t\tbreak;\n\t\tcase 'q':\n\t\t\top = \"RC\";\n\t\t\tnpar = 2;\n\t\t\tp = get_val(p, &x1);\n\t\t\tp = get_val(p, &y1);\n\t\t\tt = get_val(p, &x);\n\t\t\tt = get_val(t, &y);\n\t\t\tr += sprintf(r, \" %.2f %.2f %.2f %.2f\",\n\t\t\t\t\tx1*2/3, -y1*2/3,\n\t\t\t\t\tx1+(x-x1)*2/3, -y1-(y-y1)*2/3);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\top = \"RC\";\n\t\t\tnpar = 2;\n\t\t\tx1 = x - x1;\n\t\t\ty1 = y - y1;\n\t\t\tt = get_val(p, &x);\n\t\t\tt = get_val(t, &y);\n\t\t\tr += sprintf(r, \" %.2f %.2f %.2f %.2f\",\n\t\t\t\t\tx1*2/3, -y1*2/3,\n\t\t\t\t\tx1+(x-x1)*2/3, -y1-(y-y1)*2/3);\n\t\t\tbreak;\n\t\t}\n\t\t*r++ = ' ';\n\t\tfor ( ; i < npar; i++) {\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\tif (i & 1) {\t\t// y is inverted\n\t\t\t\tif (*p == '-')\n\t\t\t\t\tp++;\n\t\t\t\telse if (*p != '0' || p[1] != ' ')\n\t\t\t\t\t*r++ = '-';\n\t\t\t}\n\t\t\twhile ((isdigit((unsigned char) *p))\n\t\t\t    || *p == '-' || *p == '.')\n\t\t\t\t*r++ = *p++;\n\t\t\t*r++ = ' ';\n\t\t}\n\t\tif (*op == 'h') {\n\t\t\t*r++ = '0';\n\t\t\t*r++ = ' ';\n\t\t\top = \"RL\";\n\t\t}\n\t\tstrcpy(r, op);\n\t\tr += strlen(r);\nif (r + 30 > rmax) bug(\"Buffer overflow in SVG to PS\", 1);\n\t}\n\tstrcpy(r, fill ? \" fill\" : \" stroke\");\n\tr += strlen(r);\n\tstrcpy(r, \"\\ngrestore}!\");\n\tr += strlen(r);\n\n\ts = getarena(sizeof(struct SYMBOL));\n\tmemset(s, 0, sizeof(struct SYMBOL));\n\ts->text = getarena(strlen(buf) + 1);\n\tstrcpy(s->text, buf);\n\tps_def(s, s->text, 'p');\n\tif (buf != tex_buf)\n\t\tfree(buf);\n}\n\n// parse <defs> .. </defs> from %%beginsvg\nstatic void parse_defs(char *p, char *q)\n{\n\tchar *id, *r;\n\tint idsz;\n\n\tfor (;;) {\n\t\tid = strstr(p, \"id=\\\"\");\n\t\tif (!id || id > q)\n\t\t\treturn;\n\t\tr = strchr(id + 4, '\"');\n\t\tif (!r)\n\t\t\treturn;\n\t\tidsz = r + 1 - id;\n\n\t\t// if SVG output, mark the id as defined\n\t\tif (svg || epsf > 1) {\n\t\t\tsvg_def_id(id, idsz);\n\t\t\tp = r;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// convert SVG to PS\n\t\tp = id;\n\t\twhile (*p != '<')\n\t\t\tp--;\n\t\tif (strncmp(p, \"<path \", 6) == 0) {\n\t\t\tr = strstr(p, \"/>\");\n\t\t\tparse_path(p + 6, r, id, idsz);\n\t\t\tif (!r)\n\t\t\t\tbreak;\n\t\t\tp = r + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n// extract the SVG defs from %%beginsvg and\n//\tconvert to PostScript when PS output\n//\tmove to the SVG glyphs when SVG output\nstatic void svg_ps(char *p)\n{\n\tchar *q;\n\n\tfor (;;) {\n\t\tq = strstr(p, \"<defs>\");\n\t\tif (!q)\n\t\t\tbreak;\n\t\tp = strstr(q, \"</defs>\");\n\t\tif (!p) {\n\t\t\terror(1, NULL, \"No </defs> in %%beginsvg\");\n\t\t\tbreak;\n\t\t}\n\t\tparse_defs(q + 6, p);\n\t}\n}\n\n/* -- treat a postscript or SVG definition -- */\nstatic void ps_def(struct SYMBOL *s,\n\t\t\tchar *p,\n\t\t\tchar use)\t/* cf user_ps_add() */\n{\n\tif (!svg && epsf <= 1) {\t\t/* if PS output */\n\t\tif (secure\n//\t\t || use == 'g'\t\t// SVG\n\t\t || use == 's')\t\t// PS for SVG\n\t\t\treturn;\n\t} else {\t\t\t\t/* if SVG output */\n\t\tif (use == 'p'\t\t// PS for PS\n\t\t || (use == 'g'\t\t// SVG\n\t\t  && file_initialized > 0))\n\t\t\treturn;\n\t}\n\tif (s->abc_prev)\n\t\ts->state = s->abc_prev->state;\n\tif (s->state == ABC_S_TUNE) {\n\t\tif (use == 'g')\t\t// SVG\n\t\t\treturn;\n\t\tsym_link(s, FMTCHG);\n\t\ts->aux = PSSEQ;\n\t\ts->text = p;\n//\t\ts->flags |= ABC_F_INVIS;\n\t\treturn;\n\t}\n\tif (use == 'g') {\t\t\t// SVG\n\t\tsvg_ps(p);\n\t\tif (!svg && epsf <= 1)\n\t\t\treturn;\n\t}\n\tif (file_initialized > 0 || mbf != outbuf)\n\t\ta2b(\"%s\\n\", p);\n\telse\n\t\tuser_ps_add(p, use);\n}\n\n/* get a symbol selection */\n/* measure_number [ \":\" time_numerator \"/\" time_denominator ] */\nstatic char *get_symsel(struct symsel_s *symsel, char *p)\n{\n\tchar *q;\n\tint tn, td, n;\n\n\tsymsel->bar = strtod(p, &q);\n\tif (*q >= 'a' && *q <= 'z')\n\t\tsymsel->seq = *q++ - 'a';\n\telse\n\t\tsymsel->seq = 0;\n\tif (*q == ':') {\n\t\tif (sscanf(q + 1, \"%d/%d%n\", &tn, &td, &n) != 2\n\t\t || td <= 0)\n\t\t\treturn 0;\n\t\tsymsel->time = BASE_LEN * tn / td;\n\t\tq += 1 + n;\n\t} else {\n\t\tsymsel->time = 0;\n\t}\n\treturn q;\n}\n\n/* free the voice options */\nstatic void free_voice_opt(struct voice_opt_s *opt)\n{\n\tstruct voice_opt_s *opt2;\n\n\twhile (opt) {\n\t\topt2 = opt->next;\n\t\tfree(opt);\n\t\topt = opt2;\n\t}\n}\n\n// get a color\nstatic int get_color(char *p)\n{\n\tint i, color;\n\tstatic const struct {\n\t\tchar *name;\n\t\tint color;\n\t} col_tb[] = {\n\t\t{ \"aqua\",\t0x00ffff },\n\t\t{ \"black\",\t0x000000 },\n\t\t{ \"blue\",\t0x0000ff },\n\t\t{ \"fuchsia\",\t0xff00ff },\n\t\t{ \"gray\",\t0x808080 },\n\t\t{ \"green\",\t0x008000 },\n\t\t{ \"lime\",\t0x00ff00 },\n\t\t{ \"maroon\",\t0x800000 },\n\t\t{ \"navy\",\t0x000080 },\n\t\t{ \"olive\",\t0x808000 },\n\t\t{ \"purple\",\t0x800080 },\n\t\t{ \"red\",\t0xff0000 },\n\t\t{ \"silver\",\t0xc0c0c0 },\n\t\t{ \"teal\",\t0x008080 },\n\t\t{ \"white\",\t0xffffff },\n\t\t{ \"yellow\",\t0xffff00 },\n\t};\n\n\tif (*p == '#') {\n\t\tif (sscanf(p, \"#%06x\", &color) != 1\n\t\t || (unsigned) color > 0x00ffffff)\n\t\t\treturn -1;\n\t\treturn color;\n\t}\n\tfor (i = sizeof col_tb / sizeof col_tb[0]; --i >= 0; ) {\n\t\tif (strncasecmp(p, col_tb[i].name,\n\t\t\t\tstrlen(col_tb[i].name)) == 0)\n\t\t\tbreak;\n\t}\n\tif (i < 0)\n\t\treturn -1;\n\treturn col_tb[i].color;\n}\n/* get a transposition */\nstatic int get_transpose(char *p)\n{\n\tint val, pit1, pit2, acc;\n\tstatic int pit_st[7] = {0, 2, 4, 5, 7, 9, 11};\n\n\tif (isdigit(*p) || *p == '-' || *p == '+') {\n\t\tsscanf(p, \"%d\", &val);\n\t\tval *= 3;\n\t\tswitch (p[strlen(p) - 1]) {\n\t\tdefault:\n\t\t\treturn val;\n\t\tcase '#':\n\t\t\tval++;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tval += 2;\n\t\t\tbreak;\n\t\t}\n\t\tif (val > 0)\n\t\t\treturn val;\n\t\treturn val - 3;\n\t}\n\n\t// by music interval\n\tp = parse_acc_pit(p, &pit1, &acc);\n\tif (acc < 0) {\n\t\terror(1, NULL, \"  in %%%%transpose\");\n\t\treturn 0;\n\t}\n\tpit1 += 126 - 2;    // for value > 0 and 'C' % 7 == 0\n\tpit1 = (pit1 / 7) * 12 + pit_st[pit1 % 7];\n\tswitch (acc) {\n\tcase A_DS:\n\t\tpit1 += 2;\n\t\tbreak;\n\tcase A_SH:\n\t\tpit1++;\n\t\tbreak;\n\tcase A_FT:\n\t\tpit1--;\n\t\tbreak;\n\tcase A_DF:\n\t\tpit1 -= 2;\n\t\tbreak;\n\t}\n\tp = parse_acc_pit(p, &pit2, &acc);\n\tif (acc < 0) {\n\t\terror(1, NULL, \"  in %%%%transpose\");\n\t\treturn 0;\n\t}\n\tpit2 += 126 - 2;\n\tpit2 = (pit2 / 7) * 12 + pit_st[pit2 % 7];\n\tswitch (acc) {\n\tcase A_DS:\n\t\tpit2 += 2;\n\t\tbreak;\n\tcase A_SH:\n\t\tpit2++;\n\t\tbreak;\n\tcase A_FT:\n\t\tpit2--;\n\t\tbreak;\n\tcase A_DF:\n\t\tpit2 -= 2;\n\t\tbreak;\n\t}\n\n\tval = (pit2 - pit1) * 3;\n\tswitch (acc) {\n\tdefault:\n\t\treturn val;\n\tcase A_DS:\n\tcase A_SH:\n\t\tval++;\n\t\tbreak;\n\tcase A_FT:\n\tcase A_DF:\n\t\tval += 2;\n\t\tbreak;\n\t}\n\tif (val > 0)\n\t\treturn val;\n\treturn val - 3;\n}\n\n// create a note mapping\n// %%map map_name note [print [heads]] [param]*\nstatic void get_map(char *p)\n{\n\tstruct map *map;\n\tstruct note_map *note_map;\n\tchar *name, *q;\n\tint l, type, pit, acc;\n\n\tif (*p == '\\0')\n\t\treturn;\n\n\t/* map name */\n\tname = p;\n\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\tp++;\n\tl = p - name;\n\n\t/* base note */\n\twhile (isspace((unsigned char) *p))\n\t\tp++;\n\tif (*p == '*') {\n\t\ttype = MAP_ALL;\n\t\tp++;\n\t} else if (strncmp(p, \"octave,\", 7) == 0) {\n\t\ttype = MAP_OCT;\n\t\tp += 7;\n\t} else if (strncmp(p, \"key,\", 4) == 0) {\n\t\ttype = MAP_KEY;\n\t\tp += 4;\n\t} else if (strncmp(p, \"all\", 3) == 0) {\n\t\ttype = MAP_ALL;\n\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\tp++;\n\t} else {\n\t\ttype = MAP_ONE;\n\t}\n\tif (type != MAP_ALL) {\n\t\tp = parse_acc_pit(p, &pit, &acc);\n\t\tif (acc < 0)\t\t\t// if error\n\t\t\tpit = acc = 0;\n\t\tif (type == MAP_OCT || type == MAP_KEY) {\n\t\t\tpit %= 7;\n\t\t\tif (type == MAP_KEY)\n\t\t\t\tacc = A_NULL;\n\t\t}\n\t} else {\n\t\tpit = acc = 0;\n\t}\n\n\t// get/create the map\n\tfor (map = maps; map; map = map->next) {\n\t\tif (strncmp(name, map->name, l) == 0)\n\t\t\tbreak;\n\t}\n\tif (!map) {\n\t\tmap = getarena(sizeof *map);\n\t\tmap->next = maps;\n\t\tmaps = map;\n\t\tmap->name = getarena(l + 1);\n\t\tstrncpy(map->name, name, l);\n\t\tmap->name[l] = '\\0';\n\t\tmap->notes = NULL;\n\t}\n\tfor (note_map = map->notes; note_map; note_map = note_map->next) {\n\t\tif (note_map->type == type\n\t\t && note_map->pit == pit\n\t\t && note_map->acc == acc)\n\t\t\tbreak;\n\t}\n\tif (!note_map) {\n\t\tnote_map = getarena(sizeof *note_map);\n\t\tmemset(note_map, 0, sizeof *note_map);\n\t\tnote_map->next = map->notes;\n\t\tmap->notes = note_map;\n\t\tnote_map->type = type;\n\t\tnote_map->pit = pit;\n\t\tnote_map->acc = acc;\n\t\tnote_map->print_pit = -128;\n\t\tnote_map->color = -1;\n\t}\n\n\t/* try the optional 'print' and 'heads' parameters */\n\twhile (isspace((unsigned char) *p))\n\t\tp++;\n\tif (*p == '\\0')\n\t\treturn;\n\tq = p;\n\twhile (!isspace((unsigned char) *q) && *q != '\\0') {\n\t\tif (*q == '=')\n\t\t\tbreak;\n\t\tq++;\n\t}\n\tif (isspace((unsigned char) *q) || *q == '\\0') {\n\t\tif (*p != '*') {\n\t\t\tp = parse_acc_pit(p, &pit, &acc);\n\t\t\tif (acc >= 0) {\n\t\t\t\tnote_map->print_pit = pit;\n\t\t\t\tnote_map->print_acc = acc;\n\t\t\t}\n\t\t\tif (*p == '\\0')\n\t\t\t\treturn;\n\t\t}\n\t\tp = q;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\treturn;\n\t\tq = p;\n\t\twhile (!isspace((unsigned char) *q) && *q != '\\0') {\n\t\t\tif (*q == '=')\n\t\t\t\tbreak;\n\t\t\tq++;\n\t\t}\n\t\tif (isspace((unsigned char) *q) || *q == '\\0') {\n\t\t\tname = p;\n\t\t\tp = q;\n\t\t\tl = p - name;\n\t\t\tnote_map->heads = getarena(l + 1);\n\t\t\tstrncpy(note_map->heads, name, l);\n\t\t\tnote_map->heads[l] = '\\0';\n\t\t}\n\t}\n\n\t/* loop on the parameters */\n\tfor (;;) {\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tif (strncmp(p, \"heads=\", 6) == 0) {\n\t\t\tp += 6;\n\t\t\tname = p;\n\t\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\t\tp++;\n\t\t\tl = p - name;\n\t\t\tnote_map->heads = getarena(l + 1);\n\t\t\tstrncpy(note_map->heads, name, l);\n\t\t\tnote_map->heads[l] = '\\0';\n\t\t} else if (strncmp(p, \"print=\", 6) == 0) {\n\t\t\tp += 6;\n\t\t\tp = parse_acc_pit(p, &pit, &acc);\n\t\t\tif (acc >= 0) {\n\t\t\t\tnote_map->print_pit = pit;\n\t\t\t\tnote_map->print_acc = acc;\n\t\t\t}\n\t\t} else if (strncmp(p, \"color=\", 6) == 0) {\n\t\t\tint color;\n\n\t\t\tcolor = get_color(p + 6);\n\t\t\tif (color < 0) {\n\t\t\t\terror(1, NULL, \"Bad color in %%%%map\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnote_map->color = color;\n\t\t}\n\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\tp++;\n\t}\n}\n\n/* -- process a pseudo-comment (%% or I:) -- */\nstatic struct SYMBOL *process_pscomment(struct SYMBOL *s)\n{\n\tchar w[32], *p, *q;\n\tint voice;\n\tfloat h1;\n\tint lock = 0;\n\n\tp = s->text + 2;\t\t/* skip '%%' */\n\tq = p + strlen(p) - 5;\n\tif (q > p\n\t && strncmp(q, \" lock\", 5) == 0) {\n\t\tlock = 1;\n\t\t*q = '\\0';\n\t}\n\tp = get_str(w, p, sizeof w);\n\tif (s->state == ABC_S_HEAD\n\t && !check_header(s)) {\n\t\terror(1, s, \"Cannot have %%%%%s in tune header\", w);\n\t\treturn s;\n\t}\n\tswitch (w[0]) {\n\tcase 'b':\n\t\tif (strcmp(w, \"beginps\") == 0\n\t\t || strcmp(w, \"beginsvg\") == 0) {\n\t\t\tchar use;\n\n\t\t\tif (w[5] == 'p') {\n\t\t\t\tif (strncmp(p, \"svg\", 3) == 0)\n\t\t\t\t\tuse = 's';\n\t\t\t\telse if (strncmp(p, \"nosvg\", 5) == 0)\n\t\t\t\t\tuse = 'p';\n\t\t\t\telse\n\t\t\t\t\tuse = 'b';\n\t\t\t} else {\n\t\t\t\tuse = 'g';\n\t\t\t}\n\t\t\tp = s->text + 2 + 7;\n\t\t\twhile (*p != '\\0' && *p != '\\n')\n\t\t\t\tp++;\n\t\t\tif (*p == '\\0')\n\t\t\t\treturn s;\t\t/* empty */\n\t\t\tps_def(s, p + 1, use);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"begintext\") == 0) {\n\t\t\tint job;\n\n\t\t\tif (s->state == ABC_S_TUNE) {\n\t\t\t\tif (!multicol_start)\n\t\t\t\t\tgen_ly(1);\n\t\t\t} else if (s->state == ABC_S_GLOBAL) {\n\t\t\t\tif (epsf || !in_fname)\n\t\t\t\t\treturn s;\n\t\t\t}\n\t\t\tp = s->text + 2 + 9;\n\t\t\twhile (*p == ' ' || *p == '\\t')\n\t\t\t\tp++;\n\t\t\tif (*p != '\\n') {\n\t\t\t\tjob = get_textopt(p);\n\t\t\t\twhile (*p != '\\0' && *p != '\\n')\n\t\t\t\t\tp++;\n\t\t\t\tif (*p == '\\0')\n\t\t\t\t\treturn s;\t/* empty */\n\t\t\t} else {\n\t\t\t\tjob = cfmt.textoption;\n\t\t\t}\n\t\t\tif (job != T_SKIP) {\n\t\t\t\tp++;\n\t\t\t\twrite_text(w, p, job);\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"break\") == 0) {\n\t\t\tstruct brk_s *brk;\n\n\t\t\tif (s->state != ABC_S_HEAD) {\n\t\t\t\terror(1, s, \"%%%%%s ignored\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (*p == '\\0')\n\t\t\t\treturn s;\n\t\t\tfor (;;) {\n\t\t\t\tbrk = malloc(sizeof *brk);\n\t\t\t\tp = get_symsel(&brk->symsel, p);\n\t\t\t\tif (!p) {\n\t\t\t\t\terror(1, s, \"Bad selection in %%%%%s\", w);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\tbrk->next = brks;\n\t\t\t\tbrks = brk;\n\t\t\t\tif (*p != ',' && *p != ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'c':\n\t\tif (strcmp(w, \"center\") == 0)\n\t\t\tgoto center;\n\t\tif (strcmp(w, \"clef\") == 0) {\n\t\t\tif (s->state != ABC_S_GLOBAL)\n\t\t\t\tclef_def(s);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"clip\") == 0) {\n\t\t\tif (!cur_tune_opts) {\n\t\t\t\terror(1, s, \"%%%%%s not in %%%%tune sequence\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\t/* %%clip <symbol selection> \"-\" <symbol selection> */\n\t\t\tif (*p != '-') {\n\t\t\t\tp = get_symsel(&clip_start, p);\n\t\t\t\tif (!p) {\n\t\t\t\t\terror(1, s, \"Bad start in %%%%%s\", w);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\tif (*p != '-') {\n\t\t\t\t\terror(1, s, \"Lack of '-' in %%%%%s\", w);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t\tp = get_symsel(&clip_end, p);\n\t\t\tif (!p) {\n\t\t\t\terror(1, s, \"Bad end in %%%%%s\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (clip_start.bar < 0)\n\t\t\t\tclip_start.bar = 0;\n\t\t\tif (clip_end.bar < clip_start.bar\n\t\t\t || (clip_end.bar == clip_start.bar\n\t\t\t  && clip_end.time <= clip_start.time)) {\n\t\t\t\tclip_end.bar = (short unsigned) ~0 >> 1;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'd':\n\t\tif (strcmp(w, \"deco\") == 0) {\n\t\t\tdeco_add(p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"dynamic\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'E':\n\t\tif (strcmp(w, \"EPS\") == 0) {\n\t\t\tfloat x1, y1, x2, y2;\n\t\t\tFILE *fp;\n\t\t\tchar fn[STRL1], line[STRL1];\n\n\t\t\tgen_ly(1);\n\t\t\tif (secure\n\t\t\t || cfmt.textoption == T_SKIP)\n\t\t\t\treturn s;\n\t\t\tget_str(line, p, sizeof line);\n\t\t\tif ((fp = open_file(line, \"eps\", fn)) == NULL) {\n\t\t\t\terror(1, s, \"No such file: %s\", line);\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\t/* get the bounding box */\n\t\t\tx1 = x2 = 0;\n\t\t\twhile (fgets(line, sizeof line, fp)) {\n\t\t\t\tif (strncmp(line, \"%%BoundingBox:\", 14) == 0) {\n\t\t\t\t\tif (sscanf(&line[14], \"%f %f %f %f\",\n\t\t\t\t\t\t   &x1, &y1, &x2, &y2) == 4)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\tif (x1 == x2) {\n\t\t\t\terror(1, s, \"No bounding box in '%s'\", fn);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (cfmt.textoption == T_CENTER\n\t\t\t || cfmt.textoption == T_RIGHT) {\n\t\t\t\tfloat lw;\n\n\t\t\t\tlw = ((cfmt.landscape ? cfmt.pageheight : cfmt.pagewidth)\n\t\t\t\t\t- cfmt.leftmargin - cfmt.rightmargin) / cfmt.scale;\n\t\t\t\tif (cfmt.textoption == T_CENTER)\n\t\t\t\t\tx1 += (lw - (x2 - x1)) * 0.5;\n\t\t\t\telse\n\t\t\t\t\tx1 += lw - (x2 - x1);\n\t\t\t}\n\t\t\ta2b(\"\\001\");\t/* include file (must be the first after eob) */\n\t\t\tbskip(y2 - y1);\n\t\t\ta2b(\"%.2f %.2f%%%s\\n\", x1, -y1, fn);\n\t\t\tbuffer_eob(0);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'g':\n\t\tif (strcmp(w, \"gchord\") == 0\n\t\t || strcmp(w, \"gstemdir\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"glyph\") == 0) {\n\t\t\tif (!svg && epsf <= 1)\n\t\t\t\tglyph_add(p);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'm':\n\t\tif (strcmp(w, \"map\") == 0) {\n\t\t\tget_map(p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"maxsysstaffsep\") == 0) {\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\tbreak;\n\t\t\tparsys->voice[curvoice - voice_tb].maxsep = scan_u(p, 0);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"multicol\") == 0) {\n\t\t\tfloat bposy;\n\n\t\t\tgenerate();\n\t\t\tif (strncmp(p, \"start\", 5) == 0) {\n\t\t\t\tif (!in_page)\n\t\t\t\t\ta2b(\"%%\\n\");\t/* initialize the output */\n\t\t\t\tbuffer_eob(0);\n\t\t\t\tbposy = get_bposy();\n\t\t\t\tmulticol_max = multicol_start = bposy;\n\t\t\t\tlmarg = cfmt.leftmargin;\n\t\t\t\trmarg = cfmt.rightmargin;\n\t\t\t} else if (strncmp(p, \"new\", 3) == 0) {\n\t\t\t\tif (multicol_start == 0) {\n\t\t\t\t\terror(1, s,\n\t\t\t\t\t      \"%%%%%s new without start\", w);\n\t\t\t\t} else {\n\t\t\t\t\tbuffer_eob(0);\n\t\t\t\t\tbposy = get_bposy();\n\t\t\t\t\tif (bposy < multicol_start)\n\t\t\t\t\t\tbskip((bposy - multicol_start)\n\t\t\t\t\t\t\t\t/ cfmt.scale);\n\t\t\t\t\tif (bposy < multicol_max)\n\t\t\t\t\t\tmulticol_max = bposy;\n\t\t\t\t\tcfmt.leftmargin = lmarg;\n\t\t\t\t\tcfmt.rightmargin = rmarg;\n\t\t\t\t}\n\t\t\t} else if (strncmp(p, \"end\", 3) == 0) {\n\t\t\t\tif (multicol_start == 0) {\n\t\t\t\t\terror(1, s,\n\t\t\t\t\t      \"%%%%%s end without start\", w);\n\t\t\t\t} else {\n\t\t\t\t\tbuffer_eob(0);\n\t\t\t\t\tbposy = get_bposy();\n\t\t\t\t\tif (bposy > multicol_max)\n\t\t\t\t\t\tbskip((bposy - multicol_max)\n\t\t\t\t\t\t\t\t/ cfmt.scale);\n\t\t\t\t\telse\n\t\t\t\t\t\ta2b(\"%%\\n\");\t/* force write_buffer */\n\t\t\t\t\tcfmt.leftmargin = lmarg;\n\t\t\t\t\tcfmt.rightmargin = rmarg;\n\t\t\t\t\tmulticol_start = 0;\n\t\t\t\t\tbuffer_eob(0);\n\t\t\t\t\tif (!info['X' - 'A']\n\t\t\t\t\t && !epsf)\n\t\t\t\t\t\twrite_buffer();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror(1, s,\n\t\t\t\t      \"Unknown keyword '%s' in %%%%%s\", p, w);\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'M':\n\t\tif (strcmp(w, \"MIDI\") == 0\n\t\t && strncmp(p, \"temperamentequal\", 16) == 0) {\n\t\t\tint n;\n\n\t\t\tif (cfmt.nedo) {\n\t\t\t\terror(1, s, \"%%%%MIDI temperamentequal redefined\");\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tp += 16;\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\tn = atoi(p);\n\t\t\tif (n < 7 || n > 53) {\n\t\t\t\terror(1, s, \"Bad value in %%%%MIDI temperamentequal\");\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tcfmt.nedo = n;\n\t\t}\n\t\tbreak;\n\tcase 'n':\n\t\tif (strcmp(w, \"newpage\") == 0) {\n\t\t\tif (epsf || !in_fname)\n\t\t\t\treturn s;\n\t\t\tif (s->state == ABC_S_TUNE)\n\t\t\t\tgenerate();\n\t\t\tbuffer_eob(0);\n\t\t\twrite_buffer();\n//\t\t\tuse_buffer = 0;\n\t\t\tif (isdigit((unsigned char) *p))\n\t\t\t\tpagenum = atoi(p);\n\t\t\tclose_page();\n\t\t\tif (s->state == ABC_S_TUNE)\n\t\t\t\tbskip(cfmt.topspace);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'p':\n\t\tif (strcmp(w, \"pos\") == 0) {\t// %%pos <type> <position>\n\t\t\tp = get_str(w, p, sizeof w);\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"ps\") == 0\n\t\t || strcmp(w, \"postscript\") == 0) {\n\t\t\tps_def(s, p, 'b');\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'o':\n\t\tif (strcmp(w, \"ornament\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'r':\n\t\tif (strcmp(w, \"repbra\") == 0) {\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\treturn s;\n\t\t\tcurvoice->norepbra = strchr(\"0FfNn\", *p)\n\t\t\t\t\t\t|| *p == '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"repeat\") == 0) {\n\t\t\tint n, k;\n\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\treturn s;\n\t\t\tif (!curvoice->last_sym) {\n\t\t\t\terror(1, s,\n\t\t\t\t      \"%%%s cannot start a tune\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (*p == '\\0') {\n\t\t\t\tn = 1;\n\t\t\t\tk = 1;\n\t\t\t} else {\n\t\t\t\tn = atoi(p);\n\t\t\t\tif (n < 1\n\t\t\t\t || (curvoice->last_sym->type == BAR\n\t\t\t\t\t&& n > 2)) {\n\t\t\t\t\terror(1, s,\n\t\t\t\t\t      \"Incorrect 1st value in %%%%%s\", w);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\twhile (*p != '\\0' && !isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\tk = 1;\n\t\t\t\t} else {\n\t\t\t\t\tk = atoi(p);\n\t\t\t\t\tif (k < 1) {\n//\t\t\t\t\t || (curvoice->last_sym->type == BAR\n//\t\t\t\t\t  && n == 2\n//\t\t\t\t\t  && k > 1)) {\n\t\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t      \"Incorrect 2nd value in %%%%%s\", w);\n\t\t\t\t\t\treturn s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts->aux = REPEAT;\n\t\t\tif (curvoice->last_sym->type == BAR)\n\t\t\t\ts->doty = n;\n\t\t\telse\n\t\t\t\ts->doty = -n;\n\t\t\tsym_link(s, FMTCHG);\n\t\t\ts->nohdi1 = k;\n\t\t\ts->text = NULL;\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\tif (strcmp(w, \"setbarnb\") == 0) {\n\t\t\tif (s->state == ABC_S_TUNE) {\n\t\t\t\tstruct SYMBOL *s2;\n\t\t\t\tint n;\n\n\t\t\t\tn = atoi(p);\n\t\t\t\tfor (s2 = s->abc_next; s2; s2 = s2->abc_next) {\n\t\t\t\t\tif (s2->abc_type == ABC_T_BAR) {\n\t\t\t\t\t\ts2->aux = n;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tstrcpy(w, \"measurefirst\");\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(w, \"sep\") == 0) {\n\t\t\tfloat h2, len, lwidth;\n\n\t\t\tif (s->state == ABC_S_TUNE) {\n\t\t\t\tgen_ly(0);\n\t\t\t} else if (s->state == ABC_S_GLOBAL) {\n\t\t\t\tif (epsf || !in_fname)\n\t\t\t\t\treturn s;\n\t\t\t}\n\t\t\tlwidth = (cfmt.landscape ? cfmt.pageheight : cfmt.pagewidth)\n\t\t\t\t- cfmt.leftmargin - cfmt.rightmargin;\n\t\t\th1 = h2 = len = 0;\n\t\t\tif (*p != '\\0') {\n\t\t\t\th1 = scan_u(p, 0);\n\t\t\t\twhile (*p != '\\0' && !isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (*p != '\\0') {\n\t\t\t\th2 = scan_u(p, 0);\n\t\t\t\twhile (*p != '\\0' && !isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (*p != '\\0')\n\t\t\t\tlen = scan_u(p, 0);\n\t\t\tif (h1 < 1)\n\t\t\t\th1 = 0.5 CM;\n\t\t\tif (h2 < 1)\n\t\t\t\th2 = h1;\n\t\t\tif (len < 1)\n\t\t\t\tlen = 3.0 CM;\n\t\t\tbskip(h1);\n\t\t\ta2b(\"%.1f %.1f sep0\\n\",\n\t\t\t     len / cfmt.scale,\n\t\t\t     (lwidth - len) * 0.5 / cfmt.scale);\n\t\t\tbskip(h2);\n\t\t\tbuffer_eob(0);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"staff\") == 0) {\n\t\t\tint staff;\n\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\treturn s;\n\t\t\tif (*p == '+')\n\t\t\t\tstaff = curvoice->cstaff + atoi(p + 1);\n\t\t\telse if (*p == '-')\n\t\t\t\tstaff = curvoice->cstaff - atoi(p + 1);\n\t\t\telse\n\t\t\t\tstaff = atoi(p) - 1;\n\t\t\tif ((unsigned) staff > (unsigned) nstaff) {\n\t\t\t\terror(1, s, \"Bad staff in %%%%%s\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tcurvoice->floating = 0;\n\t\t\tcurvoice->cstaff = staff;\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"staffbreak\") == 0) {\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\treturn s;\n\t\t\tif (isdigit(*p)) {\n\t\t\t\ts->xmx = scan_u(p, 0);\n\t\t\t\tif (s->xmx < 0) {\n\t\t\t\t\terror(1, s, \"Bad value in %%%%%s\", w);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\tif (p[strlen(p) - 1] == 'f')\n\t\t\t\t\ts->doty = 1;\n\t\t\t} else {\n\t\t\t\ts->xmx = 0.5 CM;\n\t\t\t\tif (*p == 'f')\n\t\t\t\t\ts->doty = 1;\n\t\t\t}\n\t\t\tsym_link(s, STBRK);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"stafflines\") == 0) {\n\t\t\tif (isdigit((unsigned char) *p)) {\n\t\t\t\tswitch (atoi(p)) {\n\t\t\t\tcase 0: p = \"...\"; break;\n\t\t\t\tcase 1: p = \"..|\"; break;\n\t\t\t\tcase 2: p = \".||\"; break;\n\t\t\t\tcase 3: p = \".|||\"; break;\n\t\t\t\tcase 4: p = \"||||\"; break;\n\t\t\t\tcase 5: p = \"|||||\"; break;\n\t\t\t\tcase 6: p = \"||||||\"; break;\n\t\t\t\tcase 7: p = \"|||||||\"; break;\n\t\t\t\tcase 8: p = \"||||||||\"; break;\n\t\t\t\tdefault:\n\t\t\t\t\terror(1, s, \"Bad number of lines\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint l;\n\n\t\t\t\tl = strlen(p);\n\t\t\t\tq = p;\n\t\t\t\tp = getarena(l + 1);\n\t\t\t\tstrcpy(p, q);\n\t\t\t}\n\t\t\tif (s->state != ABC_S_TUNE) {\n\t\t\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\t\t\tvoice_tb[voice].stafflines = p;\n\t\t\t} else {\n\t\t\t\tcurvoice->stafflines = p;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"staffscale\") == 0) {\n\t\t\tchar *q;\n\t\t\tfloat scale;\n\n\t\t\tscale = strtod(p, &q);\n\t\t\tif (scale < 0.3 || scale > 2\n\t\t\t || (*q != '\\0' && *q != ' ')) {\n\t\t\t\terror(1, s, \"Bad value in %%%%%s\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (s->state != ABC_S_TUNE) {\n\t\t\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\t\t\tvoice_tb[voice].staffscale = scale;\n\t\t\t} else {\n\t\t\t\tcurvoice->staffscale = scale;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"staves\") == 0\n\t\t || strcmp(w, \"score\") == 0) {\n\t\t\tif (s->state == ABC_S_GLOBAL)\n\t\t\t\treturn s;\n\t\t\tget_staves(s);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"stemdir\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"sysstaffsep\") == 0) {\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\tbreak;\n\t\t\tparsys->voice[curvoice - voice_tb].sep = scan_u(p, 0);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 't':\n\t\tif (strcmp(w, \"text\") == 0) {\n\t\t\tint job;\n\ncenter:\n\t\t\tif (s->state == ABC_S_TUNE) {\n\t\t\t\tgen_ly(1);\n\t\t\t} else if (s->state == ABC_S_GLOBAL) {\n\t\t\t\tif (epsf || !in_fname)\n\t\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (w[0] == 'c') {\n\t\t\t\tjob = T_CENTER;\n\t\t\t} else {\n\t\t\t\tjob = cfmt.textoption;\n\t\t\t\tswitch(job) {\n\t\t\t\tcase T_SKIP:\n\t\t\t\t\treturn s;\n\t\t\t\tcase T_LEFT:\n\t\t\t\tcase T_RIGHT:\n\t\t\t\tcase T_CENTER:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tjob = T_LEFT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_text(w, p, job);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"tablature\") == 0) {\n\t\t\tstruct tblt_s *tblt;\n\t\t\tint i, j;\n\n\t\t\ttblt = tblt_parse(p);\n\t\t\tif (tblt == 0)\n\t\t\t\treturn s;\n\n\t\t\tswitch (s->state) {\n\t\t\tcase ABC_S_TUNE:\n\t\t\tcase ABC_S_HEAD:\n\t\t\t\tfor (i = 0; i < ncmdtblt; i++) {\n\t\t\t\t\tif (cmdtblts[i].active)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tj = cmdtblts[i].index;\n\t\t\t\t\tif (j < 0 || tblts[j] == tblt)\n\t\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\t/* !! 2 tblts per voice !! */\n\t\t\t\tif (curvoice->tblts[0] == tblt\n\t\t\t\t || curvoice->tblts[1] == tblt)\n\t\t\t\t\tbreak;\n\t\t\t\tif (curvoice->tblts[1]) {\n\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t\"Too many tablatures for voice %s\",\n\t\t\t\t\t\tcurvoice->id);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!curvoice->tblts[0])\n\t\t\t\t\tcurvoice->tblts[0] = tblt;\n\t\t\t\telse\n\t\t\t\t\tcurvoice->tblts[1] = tblt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"transpose\") == 0) {\n\t\t\tstruct VOICE_S *p_voice;\n\t\t\tstruct SYMBOL *s2;\n\t\t\tint i, val;\n\n\t\t\tval = get_transpose(p);\n\t\t\tswitch (s->state) {\n\t\t\tcase ABC_S_GLOBAL:\n\t\t\t\tcfmt.transpose = val;\n\t\t\t\treturn s;\n\t\t\tcase ABC_S_HEAD: {\n\t\t\t\tcfmt.transpose += val;\n\t\t\t\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t\t\t\t     --i >= 0;\n\t\t\t\t     p_voice++) {\n\t\t\t\t\tp_voice->transpose = cfmt.transpose;\n\t\t\t\t\tmemcpy(&p_voice->key, &p_voice->okey,\n\t\t\t\t\t\tsizeof p_voice->key);\n\t\t\t\t\tkey_transpose(&p_voice->key);\n\t\t\t\t\tmemcpy(&p_voice->ckey, &p_voice->key,\n\t\t\t\t\t\tsizeof p_voice->ckey);\n\t\t\t\t\tif (p_voice->key.empty)\n\t\t\t\t\t\tp_voice->key.sf = 0;\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t    }\n\t\t\t}\n\t\t\tcurvoice->transpose = cfmt.transpose + val;\n\t\t\ts2 = curvoice->sym;\n\t\t\tif (!s2) {\n\t\t\t\tmemcpy(&curvoice->key, &curvoice->okey,\n\t\t\t\t\tsizeof curvoice->key);\n\t\t\t\tkey_transpose(&curvoice->key);\n\t\t\t\tmemcpy(&curvoice->ckey, &curvoice->key,\n\t\t\t\t\tsizeof curvoice->ckey);\n\t\t\t\tif (curvoice->key.empty)\n\t\t\t\t\tcurvoice->key.sf = 0;\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tfor (;;) {\n\t\t\t\tif (s2->type == KEYSIG)\n\t\t\t\t\tbreak;\n\t\t\t\tif (s2->time == curvoice->time) {\n\t\t\t\t\ts2 = s2->prev;\n\t\t\t\t\tif (s2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts2 = s;\n\t\t\t\ts2->abc_type = ABC_T_INFO;\n\t\t\t\ts2->text = (char *) getarena(2);\n\t\t\t\ts2->text[0] = 'K';\n\t\t\t\ts2->text[1] = '\\0';\n\t\t\t\tsym_link(s2, KEYSIG);\n//\t\t\t\tif (!curvoice->ckey.empty)\n//\t\t\t\t\ts2->aux = curvoice->ckey.sf;\n\t\t\t\ts2->aux = curvoice->key.sf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(&s2->u.key, &curvoice->okey,\n\t\t\t\t\t\tsizeof s2->u.key);\n\t\t\tkey_transpose(&s2->u.key);\n\t\t\tmemcpy(&curvoice->ckey, &s2->u.key,\n\t\t\t\t\t\tsizeof curvoice->ckey);\n\t\t\tif (curvoice->key.empty)\n\t\t\t\ts2->u.key.sf = 0;\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"tune\") == 0) {\n\t\t\tstruct SYMBOL *s2, *s3;\n\t\t\tstruct tune_opt_s *opt, *opt2;\n\n\t\t\tif (s->state != ABC_S_GLOBAL) {\n\t\t\t\terror(1, s, \"%%%%%s ignored\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\t/* if void %%tune, remove all tune options */\n\t\t\tif (*p == '\\0') {\n\t\t\t\topt = tune_opts;\n\t\t\t\twhile (opt) {\n\t\t\t\t\tfree_voice_opt(opt->voice_opts);\n\t\t\t\t\topt2 = opt->next;\n\t\t\t\t\tfree(opt);\n\t\t\t\t\topt = opt2;\n\t\t\t\t}\n\t\t\t\ttune_opts = NULL;\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\tif (strcmp(p, \"end\") == 0)\n\t\t\t\treturn s;\t/* end of previous %%tune */\n\n\t\t\t/* search the end of the tune options */\n\t\t\ts2 = s;\n\t\t\tfor (;;) {\n\t\t\t\ts3 = s2->abc_next;\n\t\t\t\tif (!s3)\n\t\t\t\t\tbreak;\n\t\t\t\tif (s3->abc_type != ABC_T_NULL\n\t\t\t\t && (s3->abc_type != ABC_T_PSCOM\n\t\t\t\t  || strncmp(&s3->text[2], \"tune \", 5) == 0))\n\t\t\t\t\tbreak;\n\t\t\t\ts2 = s3;\n\t\t\t}\n\n\t\t\t/* search if already a same %%tune */\n\t\t\topt2 = NULL;\n\t\t\tfor (opt = tune_opts; opt; opt = opt->next) {\n\t\t\t\tif (strcmp(opt->s->text, s->text) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\topt2 = opt;\n\t\t\t}\n\n\t\t\tif (opt) {\n\t\t\t\tfree_voice_opt(opt->voice_opts);\n\t\t\t\tif (s2 == s) {\t\t\t/* no option */\n\t\t\t\t\tif (!opt2)\n\t\t\t\t\t\ttune_opts = opt->next;\n\t\t\t\t\telse\n\t\t\t\t\t\topt2->next = opt->next;\n\t\t\t\t\tfree(opt);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\topt->voice_opts = NULL;\n\t\t\t} else {\n\t\t\t\tif (s2 == s)\t\t\t/* no option */\n\t\t\t\t\treturn s;\n\t\t\t\topt = malloc(sizeof *opt);\n\t\t\t\tmemset(opt, 0, sizeof *opt);\n\t\t\t\topt->next = tune_opts;\n\t\t\t\ttune_opts = opt;\n\t\t\t}\n\n\t\t\t/* link the options */\n\t\t\topt->s = s3 = s;\n\t\t\tcur_tune_opts = opt;\n\t\t\ts = s->abc_next;\n\t\t\tfor (;;) {\n\t\t\t\tif (s->abc_type != ABC_T_PSCOM)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (strncmp(&s->text[2], \"voice \", 6) == 0) {\n\t\t\t\t\ts = process_pscomment(s);\n\t\t\t\t} else {\n\t\t\t\t\ts->state = ABC_S_HEAD;\n\n\t\t\t\t\t/* !! no reverse link !! */\n\t\t\t\t\ts3->next = s;\n\t\t\t\t\ts3 = s;\n\t\t\t\t}\n\t\t\t\tif (s == s2)\n\t\t\t\t\tbreak;\n\t\t\t\ts = s->abc_next;\n\t\t\t}\n\t\t\tcur_tune_opts = NULL;\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'u':\n\t\tif (strcmp(w, \"user\") == 0) {\n\t\t\tdeco[s->u.user.symbol] = parse.deco_tb[s->u.user.value - 128];\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'v':\n\t\tif (strcmp(w, \"vocal\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"voice\") == 0) {\n\t\t\tstruct SYMBOL *s2, *s3;\n\t\t\tstruct voice_opt_s *opt, *opt2;\n\n\t\t\tif (s->state != ABC_S_GLOBAL) {\n\t\t\t\terror(1, s, \"%%%%voice ignored\");\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\t/* if void %%voice, free all voice options */\n\t\t\tif (*p == '\\0') {\n\t\t\t\tif (cur_tune_opts) {\n\t\t\t\t\tfree_voice_opt(cur_tune_opts->voice_opts);\n\t\t\t\t\tcur_tune_opts->voice_opts = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tfree_voice_opt(voice_opts);\n\t\t\t\t\tvoice_opts = NULL;\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\tif (strcmp(p, \"end\") == 0)\n\t\t\t\treturn s;\t/* end of previous %%voice */\n\n\t\t\tif (cur_tune_opts)\n\t\t\t\topt = cur_tune_opts->voice_opts;\n\t\t\telse\n\t\t\t\topt = voice_opts;\n\n\t\t\t/* search the end of the voice options */\n\t\t\ts2 = s;\n\t\t\tfor (;;) {\n\t\t\t\ts3 = s2->abc_next;\n\t\t\t\tif (!s3)\n\t\t\t\t\tbreak;\n\t\t\t\tif (s3->abc_type != ABC_T_NULL\n\t\t\t\t && (s3->abc_type != ABC_T_PSCOM\n\t\t\t\t  || strncmp(&s3->text[2], \"score \", 6) == 0\n\t\t\t\t  || strncmp(&s3->text[2], \"staves \", 7) == 0\n\t\t\t\t  || strncmp(&s3->text[2], \"tune \", 5) == 0\n\t\t\t\t  || strncmp(&s3->text[2], \"voice \", 6) == 0))\n\t\t\t\t\tbreak;\n\t\t\t\ts2 = s3;\n\t\t\t}\n\n\t\t\t/* if already the same %%voice\n\t\t\t * remove the options */\n\t\t\topt2 = NULL;\n\t\t\tfor ( ; opt; opt = opt->next) {\n\t\t\t\tif (strcmp(opt->s->text, s->text) == 0) {\n\t\t\t\t\tif (!opt2) {\n\t\t\t\t\t\tif (cur_tune_opts)\n\t\t\t\t\t\t\tcur_tune_opts->voice_opts = NULL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tvoice_opts = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\topt2->next = opt->next;\n\t\t\t\t\t}\n\t\t\t\t\tfree(opt);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topt2 = opt;\n\t\t\t}\n\t\t\tif (s2 == s)\t\t/* no option */\n\t\t\t\treturn s;\n\t\t\topt = malloc(sizeof *opt + strlen(p));\n\t\t\tmemset(opt, 0, sizeof *opt);\n\t\t\tif (cur_tune_opts) {\n\t\t\t\topt->next = cur_tune_opts->voice_opts;\n\t\t\t\tcur_tune_opts->voice_opts = opt;\n\t\t\t} else {\n\t\t\t\topt->next = voice_opts;\n\t\t\t\tvoice_opts = opt;\n\t\t\t}\n\n\t\t\t/* link the options */\n\t\t\topt->s = s3 = s;\n\t\t\tfor ( ; s != s2; s = s->abc_next) {\n\t\t\t\tif (s->abc_next->abc_type != ABC_T_PSCOM)\n\t\t\t\t\tcontinue;\n\t\t\t\ts->abc_next->state = ABC_S_TUNE;\n\t\t\t\ts3->next = s->abc_next;\n\t\t\t\ts3 = s3->next;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"voicecolor\") == 0) {\n\t\t\tint color;\n\n\t\t\tif (!curvoice)\n\t\t\t\treturn s;\n\n\t\t\tcolor = get_color(p);\n\t\t\tif (color < 0)\n\t\t\t\terror(1, s, \"Bad color in %%%%voicecolor\");\n\t\t\telse\n\t\t\t\tcurvoice->color = color;\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"voicecombine\") == 0) {\n\t\t\tint combine;\n\n\t\t\tif (sscanf(p, \"%d\", &combine) != 1) {\n\t\t\t\terror(1, s, \"Bad value in %%%%voicecombine\");\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tswitch (s->state) {\n\t\t\tcase ABC_S_GLOBAL:\n\t\t\t\tcfmt.combinevoices = combine;\n\t\t\t\tbreak;\n\t\t\tcase ABC_S_HEAD:\n\t\t\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\t\t\tvoice_tb[voice].combine = combine;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcurvoice->combine = combine;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"voicemap\") == 0) {\n\t\t\tif (s->state != ABC_S_TUNE) {\n\t\t\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\t\t\tvoice_tb[voice].map_name = p;\n\t\t\t} else {\n\t\t\t\tcurvoice->map_name = p;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"voicescale\") == 0) {\n\t\t\tchar *q;\n\t\t\tfloat scale;\n\n\t\t\tscale = strtod(p, &q);\n\t\t\tif (scale < 0.6 || scale > 1.5\n\t\t\t || (*q != '\\0' && *q != ' ')) {\n\t\t\t\terror(1, s, \"Bad %%%%voicescale value\");\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (s->state != ABC_S_TUNE) {\n\t\t\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\t\t\tvoice_tb[voice].scale = scale;\n\t\t\t} else {\n\t\t\t\tcurvoice->scale = scale;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"volume\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"vskip\") == 0) {\n\t\t\tif (s->state == ABC_S_TUNE) {\n\t\t\t\tgen_ly(0);\n\t\t\t} else if (s->state == ABC_S_GLOBAL) {\n\t\t\t\tif (epsf || !in_fname)\n\t\t\t\t\treturn s;\n\t\t\t}\n\t\t\tbskip(scan_u(p, 0));\n\t\t\tbuffer_eob(0);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\t}\n\tif (s->state == ABC_S_TUNE) {\n\t\tif (strcmp(w, \"leftmargin\") == 0\n\t\t || strcmp(w, \"rightmargin\") == 0\n\t\t || strcmp(w, \"scale\") == 0) {\n\t\t\tgenerate();\n\t\t\tblock_put();\n\t\t}\n\t}\n\tinterpret_fmt_line(w, p, lock);\n\tif (cfmt.alignbars && strcmp(w, \"alignbars\") == 0) {\n\t\tint i;\n\n\t\tgenerate();\n\t\tif ((unsigned) cfmt.alignbars > MAXSTAFF) {\n\t\t\terror(1, s, \"Too big value in %%%%alignbars\");\n\t\t\tcfmt.alignbars = MAXSTAFF;\n\t\t}\n\t\tif (staves_found >= 0)\t\t/* (compatibility) */\n\t\t\tcfmt.alignbars = nstaff + 1;\n\t\tfirst_voice = curvoice = voice_tb;\n\t\tfor (i = 0; i < cfmt.alignbars; i++) {\n\t\t\tvoice_tb[i].staff = voice_tb[i].cstaff = i;\n\t\t\tvoice_tb[i].next = &voice_tb[i + 1];\n\t\t\tparsys->staff[i].flags |= STOP_BAR;\n\t\t\tparsys->voice[i].staff = i;\n\t\t\tparsys->voice[i].range = i;\n\t\t}\n\t\ti--;\n\t\tvoice_tb[i].next = NULL;\n\t\tparsys->nstaff = nstaff = i;\n\t}\n\treturn s;\n}\n\n/* -- set the duration of notes/rests in a tuplet -- */\n/*fixme: KO if voice change*/\n/*fixme: KO if in a grace sequence*/\nstatic void set_tuplet(struct SYMBOL *t)\n{\n\tstruct SYMBOL *s, *s1;\n\tint l, r, lplet, grace;\n\n\tr = t->u.tuplet.r_plet;\n\tgrace = t->flags & ABC_F_GRACE;\n\n\tl = 0;\n\tfor (s = t->abc_next; s; s = s->abc_next) {\n\t\tif (s->abc_type == ABC_T_TUPLET) {\n\t\t\tstruct SYMBOL *s2;\n\t\t\tint l2, r2;\n\n\t\t\tr2 = s->u.tuplet.r_plet;\n\t\t\tl2 = 0;\n\t\t\tfor (s2 = s->abc_next; s2; s2 = s2->abc_next) {\n\t\t\t\tswitch (s2->abc_type) {\n\t\t\t\tcase ABC_T_NOTE:\n\t\t\t\tcase ABC_T_REST:\n\t\t\t\t\tbreak;\n\t\t\t\tcase ABC_T_EOLN:\n\t\t\t\t\tif (s2->u.eoln.type != 1) {\n\t\t\t\t\t\terror(1, t,\n\t\t\t\t\t\t\t\"End of line found inside a nested tuplet\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s2->u.note.notes[0].len == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (grace ^ (s2->flags & ABC_F_GRACE))\n\t\t\t\t\tcontinue;\n\t\t\t\ts1 = s2;\n\t\t\t\tl2 += s1->dur;\n\t\t\t\tif (--r2 <= 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl2 = l2 * s->u.tuplet.q_plet / s->u.tuplet.p_plet;\n\t\t\ts->aux = l2;\n\t\t\tl += l2;\n\t\t\tr -= s->u.tuplet.r_plet;\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tif (r < 0) {\n\t\t\t\terror(1, t, \"Bad nested tuplet\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = s2;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (s->abc_type) {\n\t\tcase ABC_T_NOTE:\n\t\tcase ABC_T_REST:\n\t\t\tbreak;\n\t\tcase ABC_T_EOLN:\n\t\t\tif (s->u.eoln.type != 1) {\n\t\t\t\terror(1, t, \"End of line found inside a tuplet\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (s->u.note.notes[0].len == 0)\t/* space ('y') */\n\t\t\tcontinue;\n\t\tif (grace ^ (s->flags & ABC_F_GRACE))\n\t\t\tcontinue;\n\t\ts1 = s;\n\t\tl += s->dur;\n\t\tif (--r <= 0)\n\t\t\tbreak;\n\t}\n\tif (!s) {\n\t\terror(1, t, \"End of tune found inside a tuplet\");\n\t\treturn;\n\t}\n\tif (t->aux != 0)\t\t/* if nested tuplet */\n\t\tlplet = t->aux;\n\telse\n\t\tlplet = (l * t->u.tuplet.q_plet) / t->u.tuplet.p_plet;\n\tr = t->u.tuplet.r_plet;\n\tfor (s = t->abc_next; s; s = s->abc_next) {\n\t\tint olddur;\n\n\t\tif (s->abc_type == ABC_T_TUPLET) {\n\t\t\tint r2;\n\n\t\t\tr2 = s->u.tuplet.r_plet;\n\t\t\ts1 = s;\n\t\t\tolddur = s->aux;\n\t\t\ts1->aux = (olddur * lplet) / l;\n\t\t\tl -= olddur;\n\t\t\tlplet -= s1->aux;\n\t\t\tr -= r2;\n\t\t\tfor (;;) {\n\t\t\t\ts = s->abc_next;\n\t\t\t\tif (s->abc_type != ABC_T_NOTE\n\t\t\t\t && s->abc_type != ABC_T_REST)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (s->u.note.notes[0].len == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (grace ^ (s->flags & ABC_F_GRACE))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (--r2 <= 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (r <= 0)\n\t\t\t\tgoto done;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s->abc_type != ABC_T_NOTE && s->abc_type != ABC_T_REST)\n\t\t\tcontinue;\n\t\tif (s->u.note.notes[0].len == 0)\n\t\t\tcontinue;\n\t\ts->sflags |= S_IN_TUPLET;\n\t\tif (grace ^ (s->flags & ABC_F_GRACE))\n\t\t\tcontinue;\n\t\ts1 = s;\n\t\tolddur = s->dur;\n\t\ts1->dur = (olddur * lplet) / l;\n\t\tif (--r <= 0)\n\t\t\tbreak;\n\t\tl -= olddur;\n\t\tlplet -= s1->dur;\n\t}\ndone:\n\tif (grace) {\n\t\terror(1, t, \"Tuplets in grace note sequence not yet treated\");\n\t} else {\n\t\tsym_link(t, TUPLET);\n\t\tt->aux = cfmt.tuplets;\n\t}\n}\n"], "fixing_code": ["/*\n * Parsing functions.\n *\n * This file is part of abcm2ps.\n *\n * Copyright (C) 1998-2020 Jean-Fran\u00e7ois Moine (http://moinejf.free.fr)\n * Adapted from abc2ps, Copyright (C) 1996-1998 Michael Methfessel\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#include <regex.h>\n\n#include \"abcm2ps.h\"\n\n/* options = external formatting */\nstruct symsel_s {\t\t\t/* symbol selection */\n\tshort bar;\n\tshort time;\n\tchar seq;\n};\nstruct brk_s {\t\t\t\t/* music line break */\n\tstruct brk_s *next;\n\tstruct symsel_s symsel;\n};\nstruct voice_opt_s {\t\t\t/* voice options */\n\tstruct voice_opt_s *next;\n\tstruct SYMBOL *s;\t\t/* list of options (%%xxx) */\n};\nstruct tune_opt_s {\t\t\t/* tune options */\n\tstruct tune_opt_s *next;\n\tstruct voice_opt_s *voice_opts;\n\tstruct SYMBOL *s;\t\t/* list of options (%%xxx) */\n};\n\nint nstaff;\t\t\t\t/* (0..MAXSTAFF-1) */\nstruct SYMBOL *tsfirst;\t\t\t/* first symbol in the time sorted list */\n\nstruct VOICE_S voice_tb[MAXVOICE];\t/* voice table */\nstruct VOICE_S *first_voice;\t\t/* first voice */\nstruct SYSTEM *cursys;\t\t\t/* current system */\nstatic struct SYSTEM *parsys;\t\t/* current system while parsing */\n\nstruct FORMAT dfmt;\t\t\t/* current global format */\nint nbar;\t\t\t\t/* current measure number */\n\nstruct map *maps;\t\t\t/* note mappings */\n\nstatic struct voice_opt_s *voice_opts, *tune_voice_opts;\nstatic struct tune_opt_s *tune_opts, *cur_tune_opts;\nstatic struct brk_s *brks;\nstatic struct symsel_s clip_start, clip_end;\n\nstatic INFO info_glob;\t\t\t/* global info definitions */\nstatic char *deco_glob[256];\t\t/* global decoration table */\nstatic struct map *maps_glob;\t\t/* save note maps */\n\nstatic int over_time;\t\t\t/* voice overlay start time */\nstatic int over_mxtime;\t\t\t/* voice overlay max time */\nstatic short over_bar;\t\t\t/* voice overlay in a measure */\nstatic short over_voice;\t\t/* main voice in voice overlay */\nstatic int staves_found;\t\t/* time of the last %%staves */\nstatic int abc2win;\nstatic int capo;\t\t\t// capo indication\n\nfloat multicol_start;\t\t\t/* (for multicol) */\nstatic float multicol_max;\nstatic float lmarg, rmarg;\n\nstatic void get_clef(struct SYMBOL *s);\nstatic struct SYMBOL *get_info(struct SYMBOL *s);\nstatic void get_key(struct SYMBOL *s);\nstatic void get_meter(struct SYMBOL *s);\nstatic void get_voice(struct SYMBOL *s);\nstatic void get_note(struct SYMBOL *s);\nstatic struct SYMBOL *process_pscomment(struct SYMBOL *s);\nstatic void ps_def(struct SYMBOL *s, char *p, char use);\nstatic void set_tblt(struct VOICE_S *p_voice);\nstatic void set_tuplet(struct SYMBOL *s);\n\n/* -- weight of the symbols -- */\nstatic char w_tb[NSYMTYPES] = {\t/* !! index = symbol type !! */\n\t0,\n\t9,\t/* 1- note / rest */\n\t3,\t/* 2- space */\n\t2,\t/* 3- bar */\n\t1,\t/* 4- clef */\n\t6,\t/* 5- timesig */\n\t5,\t/* 6- keysig */\n\t0,\t/* 7- tempo */\n\t0,\t/* 8- staves */\n\t9,\t/* 9- mrest */\n\t0,\t/* 10- part */\n\t3,\t/* 11- grace */\n\t0,\t/* 12- fmtchg */\n\t8,\t/* 13- tuplet */\n\t7,\t/* 14- stbrk */\n\t7\t/* 15- custos */\n};\n\n/* key signature transposition tables */\nstatic signed char cde2fcg[7] = {0, 2, 4, -1, 1, 3, 5};\nstatic char cgd2cde[7] = {0, 4, 1, 5, 2, 6, 3};\n\n/* -- link a ABC symbol into the current voice -- */\nstatic void sym_link(struct SYMBOL *s, int type)\n{\n\tstruct VOICE_S *p_voice = curvoice;\n\n\tif (!p_voice->ignore) {\n\t\ts->prev = p_voice->last_sym;\n\t\tif (s->prev)\n\t\t\tp_voice->last_sym->next = s;\n\t\telse\n\t\t\tp_voice->sym = s;\n\t\tp_voice->last_sym = s;\n//fixme:test bug\n//\t} else {\n//\t\tif (p_voice->sym)\n//\t\t\tp_voice->last_sym = p_voice->sym = s;\n\t}\n\n\ts->type = type;\n\ts->voice = p_voice - voice_tb;\n\ts->staff = p_voice->cstaff;\n\ts->time = p_voice->time;\n\ts->posit = p_voice->posit;\n}\n\n/* -- add a new symbol in a voice -- */\nstruct SYMBOL *sym_add(struct VOICE_S *p_voice, int type)\n{\n\tstruct SYMBOL *s;\n\tstruct VOICE_S *p_voice2;\n\n\ts = (struct SYMBOL *) getarena(sizeof *s);\n\tmemset(s, 0, sizeof *s);\n\tp_voice2 = curvoice;\n\tcurvoice = p_voice;\n\tsym_link(s, type);\n\tcurvoice = p_voice2;\n\tif (p_voice->second)\n\t\ts->sflags |= S_SECOND;\n\tif (p_voice->floating)\n\t\ts->sflags |= S_FLOATING;\n\tif (s->prev) {\n\t\ts->fn = s->prev->fn;\n\t\ts->linenum = s->prev->linenum;\n\t\ts->colnum = s->prev->colnum;\n\t}\n\treturn s;\n}\n\n/* -- expand a multi-rest into single rests and measure bars -- */\nstatic void mrest_expand(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice;\n\tstruct SYMBOL *s2, *next;\n\tstruct decos dc;\n\tint nb, dt;\n\n\tnb = s->u.bar.len;\n\tdt = s->dur / nb;\n\n\t/* change the multi-rest (type bar) to a single rest */\n\tmemcpy(&dc, &s->u.bar.dc, sizeof dc);\n\tmemset(&s->u.note, 0, sizeof s->u.note);\n\ts->type = NOTEREST;\n\ts->abc_type = ABC_T_REST;\n//\ts->nhd = 0;\n\ts->dur = s->u.note.notes[0].len = dt;\n\ts->head = H_FULL;\n\ts->nflags = -2;\n\n\t/* add the bar(s) and rest(s) */\n\tnext = s->next;\n\tp_voice = &voice_tb[s->voice];\n\tp_voice->last_sym = s;\n\tp_voice->time = s->time + dt;\n\tp_voice->cstaff = s->staff;\n\ts2 = s;\n\twhile (--nb > 0) {\n\t\ts2 = sym_add(p_voice, BAR);\n\t\ts2->abc_type = ABC_T_BAR;\n\t\ts2->u.bar.type = B_SINGLE;\n\t\ts2 = sym_add(p_voice, NOTEREST);\n\t\ts2->abc_type = ABC_T_REST;\n\t\ts2->flags = s->flags;\n\t\ts2->dur = s2->u.note.notes[0].len = dt;\n\t\ts2->head = H_FULL;\n\t\ts2->nflags = -2;\n\t\tp_voice->time += dt;\n\t}\n\ts2->next = next;\n\tif (next)\n\t\tnext->prev = s2;\n\n\t/* copy the mrest decorations to the last rest */\n\tmemcpy(&s2->u.note.dc, &dc, sizeof s2->u.note.dc);\n}\n\n/* -- sort all symbols by time and vertical sequence -- */\nstatic void sort_all(void)\n{\n\tstruct SYSTEM *sy;\n\tstruct SYMBOL *s, *prev, *s2;\n\tstruct VOICE_S *p_voice;\n\tint fl, voice, time, w, wmin, multi, mrest_time;\n\tint nb, r, set_sy, new_sy;\t// nv\n\tstruct SYMBOL *vtb[MAXVOICE];\n\tsigned char vn[MAXVOICE];\t/* voice indexed by range */\n\n/*\tmemset(vtb, 0, sizeof vtb); */\n\tmrest_time = -1;\n\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next)\n\t\tvtb[p_voice - voice_tb] = p_voice->sym;\n\n\t/* initialize the voice order */\n\tsy = cursys;\n\tset_sy = 1;\n\tnew_sy = 0;\n\tprev = NULL;\n\tfl = 1;\t\t\t\t/* (have gcc happy) */\n\tmulti = -1;\t\t\t/* (have gcc happy) */\n\tfor (;;) {\n\t\tif (set_sy) {\n\t\t    fl = 1;\t\t\t// start a new sequence\n//\t\t    if (!new_sy) {\n\t\t    if (1) {\n\t\t\tset_sy = 0;\n\t\t\tmulti = -1;\n\t\t\tmemset(vn, -1, sizeof vn);\n\t\t\tfor (p_voice = first_voice;\n\t\t\t     p_voice;\n\t\t\t     p_voice = p_voice->next) {\n\t\t\t\tvoice = p_voice - voice_tb;\n\t\t\t\tr = sy->voice[voice].range;\n\t\t\t\tif (r < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tvn[r] = voice;\n\t\t\t\tmulti++;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/* search the min time and symbol weight */\n\t\twmin = time = (unsigned) ~0 >> 1;\t/* max int */\n//\t\tnv = nb = 0;\n\t\tfor (r = 0; r < MAXVOICE; r++) {\n\t\t\tvoice = vn[r];\n\t\t\tif (voice < 0)\n\t\t\t\tbreak;\n\t\t\ts = vtb[voice];\n\t\t\tif (!s || s->time > time)\n\t\t\t\tcontinue;\n\t\t\tw = w_tb[s->type];\n\t\t\tif (s->time < time) {\n\t\t\t\ttime = s->time;\n\t\t\t\twmin = w;\n//\t\t\t\tnb = 0;\n\t\t\t} else if (w < wmin) {\n\t\t\t\twmin = w;\n//\t\t\t\tnb = 0;\n\t\t\t}\n#if 0\n\t\t\tif (!(s->sflags & S_SECOND)) {\n\t\t\t\tnv++;\n\t\t\t\tif (s->type == BAR)\n\t\t\t\t\tnb++;\n\t\t\t}\n#endif\n\t\t\tif (s->type == MREST) {\n\t\t\t\tif (s->u.bar.len == 1)\n\t\t\t\t\tmrest_expand(s);\n\t\t\t\telse if (multi > 0)\n\t\t\t\t\tmrest_time = time;\n\t\t\t}\n\t\t}\n\t\tif (wmin > 127)\n\t\t\tbreak;\t\t\t\t\t/* done */\n\n#if 0\n\t\t/* align the measure bars */\n\t\tif (nb != 0 && nb != nv) {\t/* if other symbol than bars */\n\t\t\twmin = (unsigned) ~0 >> 1;\n\t\t\tfor (r = 0; r < MAXVOICE; r++) {\n\t\t\t\tvoice = vn[r];\n\t\t\t\tif (voice < 0)\n\t\t\t\t\tbreak;\n\t\t\t\ts = vtb[voice];\n\t\t\t\tif (!s || s->time > time\n\t\t\t\t || s->type == BAR)\n\t\t\t\t\tcontinue;\n\t\t\t\tw = w_tb[s->type];\n\t\t\t\tif (w < wmin)\n\t\t\t\t\twmin = w;\n\t\t\t}\n\t\t\tif (wmin > 127)\n\t\t\t\twmin = w_tb[BAR];\n\t\t}\n#endif\n\n\t\t/* if some multi-rest and many voices, expand */\n\t\tif (time == mrest_time) {\n\t\t\tnb = 0;\n\t\t\tfor (r = 0; r < MAXVOICE; r++) {\n\t\t\t\tvoice = vn[r];\n\t\t\t\tif (voice < 0)\n\t\t\t\t\tbreak;\n\t\t\t\ts = vtb[voice];\n\t\t\t\tif (!s || s->time != time)\n\t\t\t\t\tcontinue;\n\t\t\t\tw = w_tb[s->type];\n\t\t\t\tif (w != wmin)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (s->type != MREST) {\n\t\t\t\t\tmrest_time = -1; /* some note or rest */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (nb == 0) {\n\t\t\t\t\tnb = s->u.bar.len;\n\t\t\t\t} else if (nb != s->u.bar.len) {\n\t\t\t\t\tmrest_time = -1; /* different duration */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mrest_time < 0) {\n\t\t\t\tfor (r = 0; r < MAXVOICE; r++) {\n\t\t\t\t\tvoice = vn[r];\n\t\t\t\t\tif (voice < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ts = vtb[voice];\n\t\t\t\t\tif (s && s->type == MREST)\n\t\t\t\t\t\tmrest_expand(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* link the vertical sequence */\n\t\tfor (r = 0; r < MAXVOICE; r++) {\n\t\t\tvoice = vn[r];\n\t\t\tif (voice < 0)\n\t\t\t\tbreak;\n\t\t\ts = vtb[voice];\n\t\t\tif (!s || s->time != time\n\t\t\t || w_tb[s->type] != wmin)\n\t\t\t\tcontinue;\n\t\t\tif (s->type == STAVES) {\t// change STAVES to a flag\n\t\t\t\tsy = sy->next;\n\t\t\t\tset_sy = new_sy = 1;\n\t\t\t\tif (s->prev)\n\t\t\t\t\ts->prev->next = s->next;\n\t\t\t\telse\n\t\t\t\t\tvoice_tb[voice].sym = s->next;\n\t\t\t\tif (s->next)\n\t\t\t\t\ts->next->prev = s->prev;\n\t\t\t} else {\n\t\t\t\tif (fl) {\n\t\t\t\t\tfl = 0;\n\t\t\t\t\ts->sflags |= S_SEQST;\n\t\t\t\t}\n\t\t\t\tif (new_sy) {\n\t\t\t\t\tnew_sy = 0;\n\t\t\t\t\ts->sflags |= S_NEW_SY;\n\t\t\t\t}\n\t\t\t\ts->ts_prev = prev;\n\t\t\t\tif (prev) {\n\t\t\t\t\tprev->ts_next = s;\n//fixme: bad error when the 1st voice is second\n//\t\t\t\t\tif (s->type == BAR\n//\t\t\t\t\t && (s->sflags & S_SECOND)\n//\t\t\t\t\t && prev->type != BAR\n//\t\t\t\t\t && !(s->flags & ABC_F_INVIS))\n//\t\t\t\t\t\terror(1, s, \"Bad measure bar\");\n\t\t\t\t} else {\n\t\t\t\t\ttsfirst = s;\n\t\t\t\t}\n\t\t\t\tprev = s;\n\t\t\t}\n\t\t\tvtb[voice] = s->next;\n\t\t}\n\t\tfl = wmin;\t\t/* start a new sequence if some space */\n\t}\n\n\tif (!prev)\n\t\treturn;\n\n\t/* if no bar or format_change at end of tune, add a dummy symbol */\n\tif ((prev->type != BAR && prev->type != FMTCHG)\n\t || new_sy) {\n\t\tp_voice = &voice_tb[prev->voice];\n\t\tp_voice->last_sym = prev;\n\t\ts = sym_add(p_voice, FMTCHG);\n\t\ts->aux = -1;\n\t\ts->time = prev->time + prev->dur;\n\t\ts->sflags = S_SEQST;\n\t\tif (new_sy)\n\t\t\ts->sflags |= S_NEW_SY;\n\t\tprev->ts_next = s;\n\t\ts->ts_prev = prev;\n\t\tfor (;;) {\n\t\t\tprev->sflags &= ~S_EOLN;\n\t\t\tif (prev->sflags & S_SEQST)\n\t\t\t\tbreak;\n\t\t\tprev = prev->ts_prev;\n\t\t}\n\t}\n\n\t/* if Q: from tune header, put it at start of the music */\n\ts2 = info['Q' - 'A'];\n\tif (!s2)\n\t\treturn;\n\tinfo['Q' - 'A'] = NULL;\n\ts = tsfirst->extra;\n\twhile (s) {\n\t\tif (s->type == TEMPO)\n\t\t\treturn;\t\t\t/* already a tempo */\n\t\ts = s->next;\n\t}\n\ts = tsfirst;\n\ts2->type = TEMPO;\n\ts2->voice = s->voice;\n\ts2->staff = s->staff;\n\ts2->time = s->time;\n\tif (s->extra) {\n\t\ts2->next = s->extra;\n\t\ts2->next->prev = s2;\n\t}\n\ts->extra = s2;\n}\n\n/* -- move the symbols with no width to the next symbol -- */\nstatic void voice_compress(void)\n{\n\tstruct VOICE_S *p_voice;\n\tstruct SYMBOL *s, *s2, *s3, *ns;\n\n\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next) {\n//8.7.0 - for fmt at end of music line\n//\t\tif (p_voice->ignore)\n//\t\t\tcontinue;\n\t\tp_voice->ignore = 0;\n\t\tfor (s = p_voice->sym; s; s = s->next) {\n\t\t\tif (s->time >= staves_found)\n\t\t\t\tbreak;\n\t\t}\n\t\tns = NULL;\n\t\tfor ( ; s; s = s->next) {\n\t\t\tswitch (s->type) {\n#if 0 // test\n\t\t\tcase KEYSIG:\t/* remove the empty key signatures */\n\t\t\t\tif (s->u.key.empty) {\n\t\t\t\t\tif (s->prev)\n\t\t\t\t\t\ts->prev->next = s->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tp_voice->sym = s->next;\n\t\t\t\t\tif (s->next)\n\t\t\t\t\t\ts->next->prev = s->prev;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tcase FMTCHG:\n\t\t\t\ts2 = s->extra;\n\t\t\t\tif (s2) {\t/* dummy format */\n\t\t\t\t\tif (!ns)\n\t\t\t\t\t\tns = s2;\n\t\t\t\t\tif (s->prev) {\n\t\t\t\t\t\ts->prev->next = s2;\n\t\t\t\t\t\ts2->prev = s->prev;\n\t\t\t\t\t}\n\t\t\t\t\tif (!s->next) {\n\t\t\t\t\t\tns = NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\twhile (s2->next)\n\t\t\t\t\t\ts2 = s2->next;\n\t\t\t\t\ts->next->prev = s2;\n\t\t\t\t\ts2->next = s->next;\n\t\t\t\t}\n\t\t\t\t/* fall thru */\n\t\t\tcase TEMPO:\n\t\t\tcase PART:\n\t\t\tcase TUPLET:\n\t\t\t\tif (!ns)\n\t\t\t\t\tns = s;\n\t\t\t\tcontinue;\n\t\t\tcase MREST:\t\t/* don't shift P: and Q: */\n\t\t\t\tif (!ns)\n\t\t\t\t\tcontinue;\n\t\t\t\ts2 = (struct SYMBOL *) getarena(sizeof *s);\n\t\t\t\tmemset(s2, 0, sizeof *s2);\n\t\t\t\ts2->type = SPACE;\n\t\t\t\ts2->u.note.notes[1].len = -1;\n\t\t\t\ts2->flags = ABC_F_INVIS;\n\t\t\t\ts2->voice = s->voice;\n\t\t\t\ts2->staff = s->staff;\n\t\t\t\ts2->time = s->time;\n\t\t\t\ts2->sflags = s->sflags;\n\t\t\t\ts2->next = s;\n\t\t\t\ts2->prev = s->prev;\n\t\t\t\ts2->prev->next = s2;\n\t\t\t\ts->prev = s2;\n\t\t\t\ts = s2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s->flags & ABC_F_GRACE) {\n\t\t\t\tif (!ns)\n\t\t\t\t\tns = s;\n\t\t\t\twhile (!(s->flags & ABC_F_GR_END))\n\t\t\t\t\ts = s->next;\n\t\t\t\ts2 = (struct SYMBOL *) getarena(sizeof *s);\n\t\t\t\tmemcpy(s2, s, sizeof *s2);\n\t\t\t\ts2->abc_type = 0;\n\t\t\t\ts2->type = GRACE;\n\t\t\t\ts2->dur = 0;\n\t\t\t\ts2->next = s->next;\n\t\t\t\tif (s2->next) {\n\t\t\t\t\ts2->next->prev = s2;\n\t\t\t\t\tif (cfmt.graceword) {\n\t\t\t\t\t\tfor (s3 = s2->next; s3; s3 = s3->next) {\n\t\t\t\t\t\t\tswitch (s3->type) {\n\t\t\t\t\t\t\tcase SPACE:\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tcase NOTEREST:\n\t\t\t\t\t\t\t\ts2->ly = s3->ly;\n\t\t\t\t\t\t\t\ts3->ly = NULL;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp_voice->last_sym = s2;\n\t\t\t\t}\n\t\t\t\ts2->prev = s;\n\t\t\t\ts->next = s2;\n\t\t\t\ts = s2;\n\n\t\t\t\t// with w_tb[BAR] = 2,\n\t\t\t\t// the grace notes go after the bar\n\t\t\t\t// if before a bar, change the grace time\n\t\t\t\tif (s->next && s->next->type == BAR)\n\t\t\t\t\ts->time--;\n\t\t\t}\n\t\t\tif (!ns)\n\t\t\t\tcontinue;\n\t\t\ts->extra = ns;\n\t\t\ts->prev->next = NULL;\n\t\t\ts->prev = ns->prev;\n\t\t\tif (s->prev)\n\t\t\t\ts->prev->next = s;\n\t\t\telse\n\t\t\t\tp_voice->sym = s;\n\t\t\tns->prev = NULL;\n\t\t\tns = NULL;\n\t\t}\n\n\t\t/* when symbols with no space at end of tune,\n\t\t * add a dummy format */\n\t\tif (ns) {\n\t\t\ts = sym_add(p_voice, FMTCHG);\n\t\t\ts->aux = -1;\t\t/* nothing */\n\t\t\ts->extra = ns;\n\t\t\ts->prev->next = NULL;\t/* unlink */\n\t\t\ts->prev = ns->prev;\n\t\t\tif (s->prev)\n\t\t\t\ts->prev->next = s;\n\t\t\telse\n\t\t\t\tp_voice->sym = s;\n\t\t\tns->prev = NULL;\n\t\t}\n\t}\n}\n\n/* -- duplicate the voices as required -- */\nstatic void voice_dup(void)\n{\n\tstruct VOICE_S *p_voice, *p_voice2;\n\tstruct SYMBOL *s, *s2, *g, *g2;\n\tint voice;\n\n\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next) {\n\t\tif ((voice = p_voice->clone) < 0)\n\t\t\tcontinue;\n\t\tp_voice->clone = -1;\n\t\tp_voice2 = &voice_tb[voice];\n\t\tfor (s = p_voice->sym; s; s = s->next) {\n//fixme: there may be other symbols before the %%staves at this same time\n\t\t\tif (s->time >= staves_found)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor ( ; s; s = s->next) {\n\t\t\tif (s->type == STAVES)\n\t\t\t\tcontinue;\n\t\t\ts2 = (struct SYMBOL *) getarena(sizeof *s2);\n\t\t\tmemcpy(s2, s, sizeof *s2);\n\t\t\ts2->prev = p_voice2->last_sym;\n\t\t\ts2->next = NULL;\n\t\t\tif (p_voice2->sym)\n\t\t\t\tp_voice2->last_sym->next = s2;\n\t\t\telse\n\t\t\t\tp_voice2->sym = s2;\n\t\t\tp_voice2->last_sym = s2;\n\t\t\ts2->voice = voice;\n\t\t\ts2->staff = p_voice2->staff;\n\t\t\tif (p_voice2->second)\n\t\t\t\ts2->sflags |= S_SECOND;\n\t\t\telse\n\t\t\t\ts2->sflags &= ~S_SECOND;\n\t\t\tif (p_voice2->floating)\n\t\t\t\ts2->sflags |= S_FLOATING;\n\t\t\telse\n\t\t\t\ts2->sflags &= ~S_FLOATING;\n\t\t\ts2->ly = NULL;\n\t\t\tg = s2->extra;\n\t\t\tif (!g)\n\t\t\t\tcontinue;\n\t\t\tg2 = (struct SYMBOL *) getarena(sizeof *g2);\n\t\t\tmemcpy(g2, g, sizeof *g2);\n\t\t\ts2->extra = g2;\n\t\t\ts2 = g2;\n\t\t\ts2->voice = voice;\n\t\t\ts2->staff = p_voice2->staff;\n\t\t\tfor (g = g->next; g; g = g->next) {\n\t\t\t\tg2 = (struct SYMBOL *) getarena(sizeof *g2);\n\t\t\t\tmemcpy(g2, g, sizeof *g2);\n\t\t\t\ts2->next = g2;\n\t\t\t\tg2->prev = s2;\n\t\t\t\ts2 = g2;\n\t\t\t\ts2->voice = voice;\n\t\t\t\ts2->staff = p_voice2->staff;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* -- create a new staff system -- */\nstatic void system_new(void)\n{\n\tstruct SYSTEM *new_sy;\n\tint staff, voice;\n\n\tnew_sy = (struct SYSTEM *) getarena(sizeof *new_sy);\n\tif (!parsys) {\n\t\tmemset(new_sy, 0, sizeof *new_sy);\n\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\tnew_sy->voice[voice].range = -1;\n\t\t}\n\t\tfor (staff = 0; staff < MAXSTAFF; staff++) {\n\t\t\tnew_sy->staff[staff].stafflines = \"|||||\";\n\t\t\tnew_sy->staff[staff].staffscale = 1;\n\t\t}\n\t\tcursys = new_sy;\n\t} else {\n\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\n\t\t\t// update the previous system\n//\t\t\tif (parsys->voice[voice].range < 0\n//\t\t\t || parsys->voice[voice].second)\n//\t\t\t\tcontinue;\n\t\t\tstaff = parsys->voice[voice].staff;\n\t\t\tif (voice_tb[voice].stafflines)\n\t\t\t\tparsys->staff[staff].stafflines =\n\t\t\t\t\t\tvoice_tb[voice].stafflines;\n\t\t\tif (voice_tb[voice].staffscale != 0)\n\t\t\t\tparsys->staff[staff].staffscale =\n\t\t\t\t\t\tvoice_tb[voice].staffscale;\n\t\t}\n\t\tmemcpy(new_sy, parsys, sizeof *new_sy);\n\t\t\n\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\tnew_sy->voice[voice].range = -1;\n\t\t\tnew_sy->voice[voice].second = 0;\n\t\t}\n\t\tfor (staff = 0; staff < MAXSTAFF; staff++)\n\t\t\tnew_sy->staff[staff].flags = 0;\n\t\tparsys->next = new_sy;\n\t}\n\tparsys = new_sy;\n}\n\n/* -- initialize the voices and staves -- */\n/* this routine is called when starting the generation */\nstatic void system_init(void)\n{\n\tvoice_compress();\n\tvoice_dup();\n\tsort_all();\t\t\t/* define the time / vertical sequences */\n//\tif (!tsfirst)\n//\t\treturn;\n//\tparsys->nstaff = nstaff;\t/* save the number of staves */\n}\n\n/* go to a global (measure + time) */\nstatic struct SYMBOL *go_global_time(struct SYMBOL *s,\n\t\t\t\tstruct symsel_s *symsel)\n{\n\tstruct SYMBOL *s2;\n\tint bar_time;\n\n\tif (symsel->bar <= 1) {\t\t/* special case: there is no measure 0/1 */\n//\t && nbar == -1) {\t\t/* see set_bar_num */\n\t\tif (symsel->bar == 0)\n\t\t\tgoto chk_time;\n\t\tfor (s2 = s; s2; s2 = s2->ts_next) {\n\t\t\tif (s2->type == BAR\n\t\t\t && s2->time != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (s2->time < voice_tb[cursys->top_voice].meter.wmeasure)\n\t\t\ts = s2;\n\t\tgoto chk_time;\n\t}\n\tfor ( ; s; s = s->ts_next) {\n\t\tif (s->type == BAR\n\t\t && s->aux >= symsel->bar)\n\t\t\tbreak;\n\t}\n\tif (!s)\n\t\treturn NULL;\n\tif (symsel->seq != 0) {\n\t\tint seq;\n\n\t\tseq = symsel->seq;\n\t\tfor (s = s->ts_next; s; s = s->ts_next) {\n\t\t\tif (s->type == BAR\n\t\t\t && s->aux == symsel->bar) {\n\t\t\t\tif (--seq == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!s)\n\t\t\treturn NULL;\n\t}\n\nchk_time:\n\tif (symsel->time == 0)\n\t\treturn s;\n\tbar_time = s->time + symsel->time;\n\twhile (s->time < bar_time) {\n\t\ts = s->ts_next;\n\t\tif (!s)\n\t\t\treturn s;\n\t}\n\tdo {\n\t\ts = s->ts_prev;\t\t/* go back to the previous sequence */\n\t} while (!(s->sflags & S_SEQST));\n\treturn s;\n}\n\n/* treat %%clip */\nstatic void do_clip(void)\n{\n\tstruct SYMBOL *s, *s2;\n\tstruct SYSTEM *sy;\n\tstruct VOICE_S *p_voice;\n\tint voice;\n\n\t/* remove the beginning of the tune */\n\ts = tsfirst;\n\tif (clip_start.bar > 0\n\t || clip_start.time > 0) {\n\t\ts = go_global_time(s, &clip_start);\n\t\tif (!s) {\n\t\t\ttsfirst = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\t/* update the start of voices */\n\t\tsy = cursys;\n\t\tfor (s2 = tsfirst; s2 != s; s2 = s2->ts_next) {\n\t\t\tif (s->sflags & S_NEW_SY)\n\t\t\t\tsy = sy->next;\n\t\t\tswitch (s2->type) {\n\t\t\tcase CLEF:\n\t\t\t\tvoice_tb[s2->voice].s_clef = s2;\n\t\t\t\tbreak;\n\t\t\tcase KEYSIG:\n\t\t\t\tmemcpy(&voice_tb[s2->voice].key, &s2->u.key,\n\t\t\t\t\tsizeof voice_tb[0].key);\n\t\t\t\tbreak;\n\t\t\tcase TIMESIG:\n\t\t\t\tmemcpy(&voice_tb[s2->voice].meter, &s2->u.meter,\n\t\t\t\t\tsizeof voice_tb[0].meter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcursys = sy;\n\t\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next) {\n\t\t\tvoice = p_voice - voice_tb;\n\t\t\tfor (s2 = s; s2; s2 = s2->ts_next) {\n\t\t\t\tif (s2->voice == voice) {\n\t\t\t\t\ts2->prev = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp_voice->sym = s2;\n\t\t}\n\t\ttsfirst = s;\n\t\ts->ts_prev = NULL;\n\t}\n\n\t/* remove the end of the tune */\n\ts = go_global_time(s, &clip_end);\n\tif (!s)\n\t\treturn;\n\n\t/* keep the current sequence */\n\tdo {\n\t\ts = s->ts_next;\n\t\tif (!s)\n\t\t\treturn;\n\t} while (!(s->sflags & S_SEQST));\n\n\t/* cut the voices */\n\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next) {\n\t\tvoice = p_voice - voice_tb;\n\t\tfor (s2 = s->ts_prev; s2; s2 = s2->ts_prev) {\n\t\t\tif (s2->voice == voice) {\n\t\t\t\ts2->next = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!s2)\n\t\t\tp_voice->sym = NULL;\n\t}\n\ts->ts_prev->ts_next = NULL;\n}\n\n/* -- set the bar numbers and treat %%clip / %%break -- */\nstatic void set_bar_num(void)\n{\n\tstruct SYMBOL *s, *s2, *s3;\n\tint bar_time, wmeasure, tim;\n\tint bar_num, bar_rep;\n\n\twmeasure = voice_tb[cursys->top_voice].meter.wmeasure;\n\tbar_rep = nbar;\n\n\t/* don't count a bar at start of line */\n\tfor (s = tsfirst; ; s = s->ts_next) {\n\t\tif (!s)\n\t\t\treturn;\n\t\tswitch (s->type) {\n\t\tcase TIMESIG:\n\t\tcase CLEF:\n\t\tcase KEYSIG:\n\t\tcase FMTCHG:\n\t\tcase STBRK:\n\t\t\tcontinue;\n\t\tcase BAR:\n\t\t\tif (s->aux) {\n\t\t\t\tnbar = s->aux;\t\t/* (%%setbarnb) */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s->u.bar.repeat_bar\n\t\t\t && s->text\n\t\t\t && !cfmt.contbarnb) {\n\t\t\t\tif (s->text[0] == '1') {\n\t\t\t\t\tbar_rep = nbar;\n\t\t\t\t} else {\n\t\t\t\t\tnbar = bar_rep; /* restart bar numbering */\n\t\t\t\t\ts->aux = nbar;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* set the measure number on the top bars\n\t * and move the clefs before the measure bars */\n\tbar_time = s->time + wmeasure;\t/* for incomplete measure at start of tune */\n\tbar_num = nbar;\n\tfor ( ; s; s = s->ts_next) {\n\t\tswitch (s->type) {\n\t\tcase CLEF:\n\t\t\tif (s->sflags & S_NEW_SY)\n\t\t\t\tbreak;\n\t\t\tfor (s2 = s->ts_prev; s2; s2 = s2->ts_prev) {\n\t\t\t\tif (s2->sflags & S_NEW_SY) {\n\t\t\t\t\ts2 = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (s2->type) {\n\t\t\t\tcase BAR:\n\t\t\t\t\tif (s2->sflags & S_SEQST)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase MREST:\n\t\t\t\tcase NOTEREST:\n\t\t\t\tcase SPACE:\n\t\t\t\tcase STBRK:\n\t\t\t\tcase TUPLET:\n\t\t\t\t\ts2 = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!s2)\n\t\t\t\tbreak;\n\n\t\t\t/* move the clef */\n\t\t\ts->next->prev = s->prev;\n\t\t\ts->prev->next = s->next;\n\t\t\ts->ts_next->ts_prev = s->ts_prev;\n\t\t\ts->ts_prev->ts_next = s->ts_next;\n\t\t\ts->next = s2;\n\t\t\ts->prev = s2->prev;\n\t\t\tif (s->prev)\n\t\t\t\ts->prev->next = s;\n\t\t\ts2->prev = s;\n\t\t\ts->ts_next = s2;\n\t\t\ts->ts_prev = s2->ts_prev;\n\t\t\tif (s->ts_prev)\n\t\t\t\ts->ts_prev->ts_next = s;\n\t\t\ts2->ts_prev = s;\n//\t\t\tif (s->sflags & S_NEW_SY) {\n//\t\t\t\ts->sflags &= ~S_NEW_SY;\n//\t\t\t\ts->ts_next->sflags |= S_NEW_SY;\n//\t\t\t}\n\t\t\ts3 = s->extra;\n\t\t\tif (s3) {\n\t\t\t\tif (s->ts_next->extra) {\n\t\t\t\t\twhile (s3->next)\n\t\t\t\t\t\ts3 = s3->next;\n\t\t\t\t\ts3->next = s->ts_next->extra;\n\t\t\t\t\ts->ts_next->extra = s->extra;\n\t\t\t\t} else {\n\t\t\t\t\ts->ts_next->extra = s3;\n\t\t\t\t}\n\t\t\t\ts->extra = NULL;\n\t\t\t}\n\t\t\ts = s2;\n\t\t\tbreak;\n\t\tcase TIMESIG:\n\t\t\twmeasure = s->u.meter.wmeasure;\n\t\t\tif (s->time < bar_time)\n\t\t\t\tbar_time = s->time + wmeasure;\n\t\t\tbreak;\n\t\tcase MREST:\n\t\t\tbar_num += s->u.bar.len - 1;\n\t\t\twhile (s->ts_next\n\t\t\t    && s->ts_next->type != BAR)\n\t\t\t\ts = s->ts_next;\n\t\t\tbreak;\n\t\tcase BAR:\n//\t\t\tif (s->flags & ABC_F_INVIS)\n//\t\t\t\tbreak;\n\t\t\tif (s->aux) {\n\t\t\t\tbar_num = s->aux;\t\t/* (%%setbarnb) */\n//\t\t\t\tif (s->time < bar_time) {\n//\t\t\t\t\ts->aux = 0;\n\t\t\t\t\tbreak;\n//\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (s->time < bar_time)\t/* incomplete measure */\n\t\t\t\t\tbreak;\n\t\t\t\tbar_num++;\n\t\t\t}\n\n\t\t\t/* check if any repeat bar at this time */\n\t\t\ttim = s->time;\n\t\t\ts2 = s;\n\t\t\tdo {\n\t\t\t\tif (s2->type == BAR\n\t\t\t\t && s2->u.bar.repeat_bar\n\t\t\t\t && s2->text\n\t\t\t\t && !cfmt.contbarnb) {\n\t\t\t\t\tif (s2->text[0] == '1')\n\t\t\t\t\t\tbar_rep = bar_num;\n\t\t\t\t\telse\t\t/* restart bar numbering */\n\t\t\t\t\t\tbar_num = bar_rep;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts2 = s2->next;\n\t\t\t} while (s2 && s2->time == tim);\n\t\t\ts->aux = bar_num;\n\t\t\tbar_time = s->time + wmeasure;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* do the %%clip stuff */\n\tif (clip_start.bar >= 0) {\n\t\tif (bar_num <= clip_start.bar\n\t\t || nbar > clip_end.bar) {\n\t\t\ttsfirst = NULL;\n\t\t\treturn;\n\t\t}\n\t\tdo_clip();\n\t}\n\n\t/* do the %%break stuff */\n\t{\n\t\tstruct brk_s *brk;\n\t\tint nbar_min;\n\n//\t\tif (nbar == 1)\n//\t\t\tnbar = -1;\t/* see go_global_time */\n\t\tnbar_min = nbar;\n\t\tif (nbar_min == 1)\n\t\t\tnbar_min = -1;\n\t\tfor (brk = brks; brk; brk = brk->next) {\n\t\t\tif (brk->symsel.bar <= nbar_min\n\t\t\t || brk->symsel.bar > bar_num)\n\t\t\t\tcontinue;\n\t\t\ts = go_global_time(tsfirst, &brk->symsel);\n\t\t\tif (s)\n\t\t\t\ts->sflags |= S_EOLN;\n\t\t}\n\t}\n\tif (cfmt.measurenb < 0)\t\t/* if no display of measure bar */\n\t\tnbar = bar_num;\t\t/* update in case of more music to come */\n}\n\n/* -- generate a piece of tune -- */\nstatic void generate(void)\n{\n\tint old_lvl, voice;\n\tstruct VOICE_S *p_voice;\n\n\tsystem_init();\n\tif (!tsfirst)\n\t\treturn;\t\t\t\t/* no symbol */\n\tset_bar_num();\n\tif (!tsfirst)\n\t\treturn;\t\t\t\t/* no more symbol */\n\told_lvl = lvlarena(2);\n\toutput_music();\n\tclrarena(2);\t\t\t\t/* clear generation */\n\tlvlarena(old_lvl);\n\n\t/* reset the parser */\n\tfor (p_voice = first_voice; p_voice; p_voice = p_voice->next) {\n\t\tvoice = p_voice - voice_tb;\n\t\tp_voice->sym = p_voice->last_sym = NULL;\n\t\tp_voice->time = 0;\n\t\tp_voice->have_ly = 0;\n\t\tp_voice->staff = cursys->voice[voice].staff;\n\t\tp_voice->second = cursys->voice[voice].second;\n\t\tp_voice->s_clef->time = 0;\n\t\tp_voice->lyric_start = NULL;\n\t}\n\tstaves_found = 0;\t\t// (for voice compress/dup)\n}\n\n/* -- output the music and lyrics after tune -- */\nstatic void gen_ly(int eob)\n{\n\tgenerate();\n\tif (info['W' - 'A']) {\n\t\tput_words(info['W' - 'A']);\n\t\tinfo['W' - 'A'] = NULL;\n\t}\n\tif (eob)\n\t\tbuffer_eob(0);\n}\n\n/*\n * for transpose purpose, check if a pitch is already in the measure or\n * if it is tied from a previous note, and return the associated accidental\n */\nstatic int acc_same_pitch(int pitch)\n{\n\tstruct SYMBOL *s = curvoice->last_sym->prev;\n\tint i, time;\n\n\t// the overlaid voices may have no measure bars\n//\tif (curvoice->id[0] == '&')\n//\t\ts = voice_tb[curvoice->mvoice].last_sym;\n\n\tif (!s)\n\t\treturn -1;\n\n\ttime = s->time;\n\n\tfor (; s; s = s->prev) {\n\t\tswitch (s->abc_type) {\n\t\tcase ABC_T_BAR:\n\t\t\tif (s->time < time)\n\t\t\t\treturn -1;\t/* no same pitch */\n\t\t\tfor (;;) {\n\t\t\t\ts = s->prev;\n\t\t\t\tif (!s)\n\t\t\t\t\treturn -1;\n\t\t\t\tif (s->abc_type == ABC_T_NOTE) {\n\t\t\t\t\tif (s->time + s->dur == time)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (s->time < time)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i <= s->nhd; i++) {\n\t\t\t\tif (s->u.note.notes[i].pit == pitch\n\t\t\t\t && s->u.note.notes[i].ti1)\n\t\t\t\t\treturn s->u.note.notes[i].acc;\n\t\t\t}\n\t\t\treturn -1;\n\t\tcase ABC_T_NOTE:\n\t\t\tfor (i = 0; i <= s->nhd; i++) {\n\t\t\t\tif (s->u.note.notes[i].pit == pitch)\n\t\t\t\t\treturn s->u.note.notes[i].acc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* transpose a note / chord */\nstatic void note_transpose(struct SYMBOL *s)\n{\n\tint i, j, m, n, d, a, dp, i1, i2, i3, i4, sf_old;\n\tstatic const signed char acc1[6] = {0, 1, 0, -1, 2, -2};\n\tstatic const char acc2[5] = {A_DF, A_FT, A_NT, A_SH, A_DS};\n\n\tm = s->nhd;\n\tsf_old = curvoice->okey.sf;\n\ti2 = curvoice->ckey.sf - sf_old;\n\tdp = cgd2cde[(i2 + 4 * 7) % 7];\n\tif (curvoice->transpose < 0\n\t && dp != 0)\n\t\tdp -= 7;\n\tdp += curvoice->transpose / 3 / 12 * 7;\n\tfor (i = 0; i <= m; i++) {\n\n\t\t/* pitch */\n\t\tn = s->u.note.notes[i].pit;\n\t\ts->u.note.notes[i].pit += dp;\n\t\ts->pits[i] += dp;\n\n\t\t/* accidental */\n\t\ti1 = cde2fcg[(n + 5 + 16 * 7) % 7];\t/* fcgdaeb */\n\t\ta = s->u.note.notes[i].acc & 0x07;\n\t\tif (a == 0) {\n\t\t\tif (curvoice->okey.nacc == 0) {\n\t\t\t\tif (sf_old > 0) {\n\t\t\t\t\tif (i1 < sf_old - 1)\n\t\t\t\t\t\ta = A_SH;\n\t\t\t\t} else if (sf_old < 0) {\n\t\t\t\t\tif (i1 >= sf_old + 6)\n\t\t\t\t\t\ta = A_FT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < curvoice->okey.nacc; j++) {\n\t\t\t\t\tif ((n + 16 * 7 - curvoice->okey.pits[j]) % 7\n\t\t\t\t\t\t\t\t== 0) {\n\t\t\t\t\t\ta = curvoice->okey.accs[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti3 = i1 + i2 + acc1[a] * 7;\n\n\t\ti1 = ((i3 + 1 + 21) / 7 + 2 - 3 + 32 * 5) % 5;\n\t\ta = acc2[(unsigned) i1];\n\t\tif (s->u.note.notes[i].acc != 0) {\n\t\t\t;\n\t\t} else if (curvoice->ckey.empty) {\t/* key none */\n\t\t\tif (a == A_NT\n\t\t\t || acc_same_pitch(s->u.note.notes[i].pit) >= 0)\n\t\t\t\tcontinue;\n\t\t} else if (curvoice->ckey.nacc > 0) {\t/* acc list */\n\t\t\ti4 = cgd2cde[(unsigned) ((i3 + 16 * 7) % 7)];\n\t\t\tfor (j = 0; j < curvoice->ckey.nacc; j++) {\n\t\t\t\tif ((i4 + 16 * 7 - curvoice->ckey.pits[j]) % 7\n\t\t\t\t\t\t\t== 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j < curvoice->ckey.nacc)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\ti1 = s->u.note.notes[i].acc & 0x07;\n\t\ti4 = s->u.note.notes[i].acc >> 3;\n\t\tif (i4 != 0\t\t\t\t/* microtone */\n\t\t && i1 != a) {\t\t\t\t/* different accidental type */\n\t\t\tif (s->u.note.microscale) {\n\t\t\t\tn = i4;\n\t\t\t\td = s->u.note.microscale;\n\t\t\t} else {\n\t\t\t\tn = parse.micro_tb[i4];\n\t\t\t\td = ((n & 0xff) + 1) * 2;\n\t\t\t\tn = (n >> 8) + 1;\n\t\t\t}\n//fixme: double sharps/flats ?*/\n//fixme: does not work in all cases (tied notes, previous accidental)\n\t\t\tswitch (a) {\n\t\t\tcase A_NT:\n\t\t\t\tif (n >= d / 2) {\n\t\t\t\t\tn -= d / 2;\n\t\t\t\t\ta = i1;\n\t\t\t\t} else {\n\t\t\t\t\ta = i1 == A_SH ? A_FT : A_SH;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase A_DS:\n\t\t\t\tif (n >= d / 2) {\n\t\t\t\t\ts->u.note.notes[i].pit += 1;\n\t\t\t\t\ts->pits[i] += 1;\n\t\t\t\t\tn -= d / 2;\n\t\t\t\t} else {\n\t\t\t\t\tn += d / 2;\n\t\t\t\t}\n\t\t\t\ta = i1;\n\t\t\t\tbreak;\n\t\t\tcase A_DF:\n\t\t\t\tif (n >= d / 2) {\n\t\t\t\t\ts->u.note.notes[i].pit -= 1;\n\t\t\t\t\ts->pits[i] -= 1;\n\t\t\t\t\tn -= d / 2;\n\t\t\t\t} else {\n\t\t\t\t\tn += d / 2;\n\t\t\t\t}\n\t\t\t\ta = i1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s->u.note.microscale) {\n\t\t\t\ti4 = n;\n\t\t\t} else {\n\t\t\t\td = d / 2 - 1 + ((n - 1) << 8);\n\t\t\t\tfor (i4 = 1; i4 < MAXMICRO; i4++) {\n\t\t\t\t\tif (parse.micro_tb[i4] == d)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (parse.micro_tb[i4] == 0) {\n\t\t\t\t\t\tparse.micro_tb[i4] = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i4 == MAXMICRO) {\n\t\t\t\t\terror(1, s, \"Too many microtone accidentals\");\n\t\t\t\t\ti4 = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts->u.note.notes[i].acc = (i4 << 3) | a;\n\t}\n}\n\n/* transpose a guitar chord */\nstatic void gch_tr1(struct SYMBOL *s, int i, int i2)\n{\n\tchar *p = &s->text[i],\n\t\t*q = p + 1,\n\t\t*new_txt;\n\tint l, latin;\n\tint n, a, i1, i3, i4;\n\tstatic const char note_names[] = \"CDEFGAB\";\n\tstatic const char *latin_names[7] =\n\t\t\t{ \"Do\", \"R\u00e9\", \"Mi\", \"Fa\", \"Sol\", \"La\", \"Si\" };\n\tstatic const char *acc_name[5] = {\"bb\", \"b\", \"\", \"#\", \"##\"};\n\n\t/* main chord */\n\tlatin = 0;\n\tswitch (*p) {\n\tcase 'A':\n\tcase 'B':\n\t\tn = *p - 'A' + 5;\n\t\tbreak;\n\tcase 'C':\n\tcase 'E':\n\tcase 'G':\n\t\tn = *p - 'C';\n\t\tbreak;\n\tcase 'D':\n\t\tif (p[1] == 'o') {\n\t\t\tlatin++;\n\t\t\tn = 0;\t\t/* Do */\n\t\t\tbreak;\n\t\t}\n\t\tn = 1;\n\t\tbreak;\n\tcase 'F':\n\t\tif (p[1] == 'a')\n\t\t\tlatin++;\t/* Fa */\n\t\tn = 3;\n\t\tbreak;\n\tcase 'L':\n\t\tlatin++;\t\t/* La */\n\t\tn = 5;\n\t\tbreak;\n\tcase 'M':\n\t\tlatin++;\t\t/* Mi */\n\t\tn = 2;\n\t\tbreak;\n\tcase 'R':\n\t\tlatin++;\n\t\tif (p[1] != 'e')\n\t\t\tlatin++;\t/* R\u00e9 */\n\t\tn = 1;\t\t\t/* Re */\n\t\tbreak;\n\tcase 'S':\n\t\tlatin++;\n\t\tif (p[1] == 'o') {\n\t\t\tlatin++;\n\t\t\tn = 4;\t\t/* Sol */\n\t\t} else {\n\t\t\tn = 6;\t\t/* Si */\n\t\t}\n\t\tbreak;\n\tcase '/':\t\t\t// bass only\n\t\tlatin--;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tq += latin;\n\n\t/* allocate a new string */\n\tnew_txt = getarena(strlen(s->text) + 6);\n\tl = p - s->text;\n\tmemcpy(new_txt, s->text, l);\n\ts->text = new_txt;\n\tnew_txt += l;\n\tp = q;\n\n\tif (latin >= 0) {\t\t\t// if some chord\n\t\ta = 0;\n\t\twhile (*p == '#') {\n\t\t\ta++;\n\t\t\tp++;\n\t\t}\n\t\twhile (*p == 'b') {\n\t\t\ta--;\n\t\t\tp++;\n\t\t}\n//\t\tif (*p == '=')\n//\t\t\tp++;\n\t\ti3 = cde2fcg[n] + i2 + a * 7;\n\t\ti4 = cgd2cde[(unsigned) ((i3 + 16 * 7) % 7)];\n\t\ti1 = ((i3 + 1 + 21) / 7 + 2 - 3 + 32 * 5) % 5;\n\t\t\t\t\t\t\t/* accidental */\n\t\tif (latin == 0)\n\t\t\t*new_txt++ = note_names[i4];\n\t\telse\n\t\t\tnew_txt += sprintf(new_txt, \"%s\", latin_names[i4]);\n\t\tnew_txt += sprintf(new_txt, \"%s\", acc_name[i1]);\n\t}\n\n\t/* bass */\n\twhile (*p != '\\0' && *p != '\\n' && *p != '/')\t// skip 'm'/'dim'..\n\t\t*new_txt++ = *p++;\n\tif (*p == '/') {\n\t\t*new_txt++ = *p++;\n//fixme: latin names not treated\n\t\tq = strchr(note_names, *p);\n\t\tif (q) {\n\t\t\tp++;\n\t\t\tn = q - note_names;\n\t\t\tif (*p == '#') {\n\t\t\t\ta = 1;\n\t\t\t\tp++;\n\t\t\t} else if (*p == 'b') {\n\t\t\t\ta = -1;\n\t\t\t\tp++;\n\t\t\t} else {\n\t\t\t\ta = 0;\n\t\t\t}\n\t\t\ti3 = cde2fcg[n] + i2 + a * 7;\n\t\t\ti4 = cgd2cde[(unsigned) ((i3 + 16 * 7) % 7)];\n\t\t\ti1 = ((i3 + 1 + 21) / 7 + 2 - 3 + 32 * 5) % 5;\n\t\t\t*new_txt++ = note_names[i4];\n\t\t\tnew_txt += sprintf(new_txt, \"%s\", acc_name[i1]);\n\t\t}\n\t}\n\tstrcpy(new_txt, p);\n}\n\nstatic void gch_capo(struct SYMBOL *s)\n{\n\tchar *p = s->text, *q, *r;\n\tint i, l, li = 0;\n\tstatic const char *capo_txt = \"  (capo: %d)\";\n\tstatic signed char cap_trans[] =\n\t\t{0, 5, -2, 3, -4, 1, -6, -1, 4, -3, 2, -5};\n\n\t// search the chord symbols\n\tfor (;;) {\n\t\tif (!strchr(\"^_<>@\", *p))\n\t\t\tbreak;\n\t\tp = strchr(p, '\\n');\n\t\tif (!p)\n\t\t\treturn;\n\t\tp++;\n\t}\n\n\t// add a capo chord symbol\n\ti = p - s->text;\n\tq = strchr(p + 1, '\\n');\n\tif (q)\n\t\tl = q - p;\n\telse\n\t\tl = strlen(p);\n\tif (!capo) {\n\t\tcapo = 1;\n\t\tli = strlen(capo_txt);\n\t}\n\tr = (char *) getarena(strlen(s->text) + l + li + 1);\n\ti += l;\n\tstrncpy(r, s->text, i);\t\t// annotations + chord symbol\n\tr[i++] = '\\n';\n\tstrncpy(r + i, p, l);\t\t// capo\n\tif (li) {\n\t\tsprintf(r + i + l, capo_txt, cfmt.capo);\n\t\tl += li;\n\t}\n\tif (q)\n\t\tstrcpy(r + i + l, q);\t// ending annotations\n\ts->text = r;\n\tgch_tr1(s, i, cap_trans[cfmt.capo % 12]);\n}\n\nstatic void gch_transpose(struct SYMBOL *s)\n{\n\tint in_ch = 0;\n\tint i2 = curvoice->ckey.sf - curvoice->okey.sf;\n\tchar *o = s->text, *p = o;\n\n\t// search the chord symbols\n\tfor (;;) {\n\t\tif (in_ch || !strchr(\"^_<>@\", *p)) {\n\t\t\tgch_tr1(s, p - s->text, i2);\n\t\t\tp = s->text + (p - o);\n\t\t\to = s->text;\n\t\t\tfor (p++; *p; p++) {\n\t\t\t\tif (strchr(\"\\t;\\n\", *p))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*p)\n\t\t\t\tbreak;\n\t\t\tswitch (*p) {\n\t\t\tcase '\\t':\n\t\t\t\tin_ch = 1;\n\t\t\t\tbreak;\n\t\t\tcase ';':\n\t\t\t\tin_ch = !strchr(\"^_<>@\", p[1]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tin_ch = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tp = strchr(p, '\\n');\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n}\n\n/* -- build the guitar chords / annotations -- */\nstatic void gch_build(struct SYMBOL *s)\n{\n\tstruct gch *gch;\n\tchar *p, *q, antype, sep;\n\tfloat w, h_ann, h_gch, y_above, y_below, y_left, y_right;\n\tfloat xspc;\n\tint l, ix, box, gch_place;\n\n\tif (s->posit.gch == SL_HIDDEN)\n\t\treturn;\n\ts->gch = getarena(sizeof *s->gch * MAXGCH);\n\tmemset(s->gch, 0, sizeof *s->gch * MAXGCH);\n\n\tif (curvoice->transpose != 0)\n\t\tgch_transpose(s);\n\tif (cfmt.capo)\n\t\tgch_capo(s);\n\n\t/* split the guitar chords / annotations\n\t * and initialize their vertical offsets */\n\tgch_place = s->posit.gch == SL_BELOW ? -1 : 1;\n\th_gch = cfmt.font_tb[cfmt.gcf].size;\n\th_ann = cfmt.font_tb[cfmt.anf].size;\n\ty_above = y_below = y_left = y_right = 0;\n\tbox = cfmt.gchordbox;\n\tp = s->text;\n\tgch = s->gch;\n\tsep = '\\n';\n\tantype = 'g';\t\t\t/* (compiler warning) */\n\tfor (;;) {\n\t\tif (sep != 'n' && strchr(\"^_<>@\", *p)) {\n\t\t\tgch->font = cfmt.anf;\n\t\t\tantype = *p++;\n\t\t\tif (antype == '@') {\n\t\t\t\tint n;\n\t\t\t\tfloat xo, yo;\n\n\t\t\t\tif (sscanf(p, \"%f,%f%n\", &xo, &yo, &n) != 2) {\n\t\t\t\t\terror(1, s, \"Error in annotation \\\"@\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tp += n;\n\t\t\t\t\tif (*p == ' ')\n\t\t\t\t\t\tp++;\n\t\t\t\t\tgch->x = xo;\n\t\t\t\t\tgch->y = yo;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (sep == '\\n') {\n\t\t\tgch->font = cfmt.gcf;\n\t\t\tgch->box = box;\n\t\t\tantype = 'g';\n\t\t} else {\n\t\t\tgch->font = (gch - 1)->font;\n\t\t\tgch->box = (gch - 1)->box;\n\t\t}\n\t\tgch->type = antype;\n\t\tswitch (antype) {\n\t\tdefault:\t\t\t\t/* guitar chord */\n\t\t\tif (gch_place < 0)\n\t\t\t\tbreak;\t\t\t/* below */\n\t\t\ty_above += h_gch;\n\t\t\tif (box)\n\t\t\t\ty_above += 2;\n\t\t\tbreak;\n\t\tcase '^':\t\t\t\t/* above */\n\t\t\ty_above += h_ann;\n\t\t\tbreak;\n\t\tcase '_':\t\t\t\t/* below */\n\t\t\tbreak;\n\t\tcase '<':\t\t\t\t/* left */\n\t\t\ty_left += h_ann * 0.5;\n\t\t\tbreak;\n\t\tcase '>':\t\t\t\t/* right */\n\t\t\ty_right += h_ann * 0.5;\n\t\t\tbreak;\n\t\tcase '@':\t\t\t\t/* absolute */\n\t\t\tif (gch->x == 0 && gch->y == 0\n\t\t\t && gch != s->gch\n\t\t\t && s->gch->type == '@') {\t/* if not 1st line */\n\t\t\t\tgch->x = (gch - 1)->x;\n\t\t\t\tgch->y = (gch - 1)->y - h_ann;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgch->idx = p - s->text;\n\t\tfor (;;) {\n\t\t\tswitch (*p) {\n\t\t\tdefault:\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\tcase '\\\\':\n\t\t\t\tp++;\n\t\t\t\tif (*p == 'n') {\n\t\t\t\t\tp[-1] = '\\0';\n\t\t\t\t\tbreak;\t\t/* sep = 'n' */\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\tcase '&':\t\t\t/* skip \"&xxx;\" */\n\t\t\t\tfor (;;) {\n\t\t\t\t\tswitch (*p) {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase ';':\n\t\t\t\t\t\tp++;\n\t\t\t\t\tcase '\\0':\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase '\\0':\n\t\t\tcase ';':\n\t\t\tcase '\\n':\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tsep = *p;\n\t\tif (sep == '\\0')\n\t\t\tbreak;\n\t\t*p++ = '\\0';\n\t\tgch++;\n\t\tif (gch - s->gch >= MAXGCH) {\n\t\t\terror(1, s, \"Too many guitar chords / annotations\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* change the accidentals in the guitar chords */\n\tfor (ix = 0, gch = s->gch; ix < MAXGCH; ix++, gch++) {\n\t\tif (gch->type == '\\0')\n\t\t\tbreak;\n\t\tif (gch->type != 'g')\n\t\t\tcontinue;\n\t\tp = s->text + gch->idx;\n\t\tq = p;\n\t\tfor (; *p != '\\0'; p++) {\n\t\t\tswitch (*p) {\n\t\t\tcase '#':\n\t\t\tcase 'b':\n\t\t\tcase '=':\n\t\t\t\tif (p == q\t/* 1st char or after a slash */\n\t\t\t\t || (p != q + 1\t/* or invert '\\' behaviour */\n\t\t\t\t  && p[-1] == '\\\\'))\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* set the accidentals as unused utf-8 values\n\t\t\t\t * (see subs.c) */\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase '#':\n\t\t\t\t\t*p = 0x01;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t*p = 0x02;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n/*\t\t\t\tcase '=': */\n\t\t\t\t\t*p = 0x03;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (p[-1] == '\\\\') {\n\t\t\t\t\tp--;\n\t\t\t\t\tl = strlen(p);\n\t\t\t\t\tmemmove(p, p + 1, l);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\tcase '/':\n\t\t\t\tq = p + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set the offsets and widths */\n/*fixme:utf8*/\n\tfor (ix = 0, gch = s->gch; ix < MAXGCH; ix++, gch++) {\n\t\tif (gch->type == '\\0')\n\t\t\tbreak;\n\t\tif (gch->type == '@')\n\t\t\tcontinue;\t\t/* no width */\n\t\tp = s->text + gch->idx;\n\t\tstr_font(gch->font);\n\t\tw = tex_str(p);\n\t\tgch->w = w; // + 4;\n\t\tswitch (gch->type) {\n\t\tcase '_':\t\t\t/* below */\n\t\t\txspc = w * GCHPRE;\n\t\t\tif (xspc > 8)\n\t\t\t\txspc = 8;\n\t\t\tgch->x = -xspc;\n\t\t\ty_below -= h_ann;\n\t\t\tgch->y = y_below;\n\t\t\tbreak;\n\t\tcase '^':\t\t\t/* above */\n\t\t\txspc = w * GCHPRE;\n\t\t\tif (xspc > 8)\n\t\t\t\txspc = 8;\n\t\t\tgch->x = -xspc;\n\t\t\ty_above -= h_ann;\n\t\t\tgch->y = y_above;\n\t\t\tbreak;\n\t\tdefault:\t\t\t/* guitar chord */\n\t\t\txspc = w * GCHPRE;\n\t\t\tif (xspc > 8)\n\t\t\t\txspc = 8;\n\t\t\tgch->x = -xspc;\n\t\t\tif (gch_place < 0) {\t/* below */\n\t\t\t\ty_below -= h_gch;\n\t\t\t\tgch->y = y_below;\n\t\t\t\tif (box) {\n\t\t\t\t\ty_below -= 2;\n\t\t\t\t\tgch->y -= 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ty_above -= h_gch;\n\t\t\t\tgch->y = y_above;\n\t\t\t\tif (box) {\n\t\t\t\t\ty_above -= 2;\n\t\t\t\t\tgch->y -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '<':\t\t/* left */\n\t\t\tgch->x = -(w + 6);\n\t\t\ty_left -= h_ann;\n\t\t\tgch->y = y_left;\n\t\t\tbreak;\n\t\tcase '>':\t\t/* right */\n\t\t\tgch->x = 6;\n\t\t\ty_right -= h_ann;\n\t\t\tgch->y = y_right;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* get the note which will receive a lyric word */\nstatic struct SYMBOL *next_lyric_note(struct SYMBOL *s)\n{\n\twhile (s\n\t    && (s->abc_type != ABC_T_NOTE\n\t     || (s->flags & ABC_F_GRACE)))\n\t\ts = s->next;\n\treturn s;\n}\n\n/* -- parse lyric (vocal) lines (w:) -- */\nstatic struct SYMBOL *get_lyric(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s1, *s2;\n\tchar word[128], *p, *q;\n\tint ln, cont;\n\tstruct FONTSPEC *f;\n\n\tcurvoice->have_ly = curvoice->posit.voc != SL_HIDDEN;\n\n\tif (curvoice->ignore) {\n\t\tfor (;;) {\n\t\t\tif (!s->abc_next)\n\t\t\t\treturn s;\n\t\t\tswitch (s->abc_next->abc_type) {\n\t\t\tcase ABC_T_PSCOM:\n\t\t\t\ts = process_pscomment(s->abc_next);\n\t\t\t\tcontinue;\n\t\t\tcase ABC_T_INFO:\n\t\t\t\tif (s->abc_next->text[0] == 'w'\n\t\t\t\t || s->abc_next->text[0] == '+') {\n\t\t\t\t\ts = s->abc_next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t}\n\n\tf = &cfmt.font_tb[cfmt.vof];\n\tstr_font(cfmt.vof);\t\t\t/* (for tex_str) */\n\n\t/* treat all w: lines */\n\tcont = 0;\n\tln = -1;\n\ts2 = s1 = NULL;\t\t\t\t// have gcc happy\n\tfor (;;) {\n\t\tif (!cont) {\n\t\t\tif (ln >= MAXLY- 1) {\n\t\t\t\terror(1, s, \"Too many lyric lines\");\n\t\t\t\tln--;\n\t\t\t}\n\t\t\tln++;\n\t\t\ts2 = s1;\n\t\t\ts1 = curvoice->lyric_start;\n\t\t\tif (!s1)\n\t\t\t\ts1 = curvoice->sym;\n\t\t\telse\n\t\t\t\ts1 = s1->next;\n\t\t\tif (!s1) {\n\t\t\t\terror(1, s, \"w: without music\");\n\t\t\t\treturn s;\n\t\t\t}\n\t\t} else {\n\t\t\tcont = 0;\n\t\t}\n\n\t\t/* scan the lyric line */\n\t\tp = &s->text[2];\n\t\twhile (*p != '\\0') {\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\tif (*p == '\\0')\n\t\t\t\tbreak;\n\t\t\tif (*p == '\\\\' && p[1] == '\\0') {\n\t\t\t\tcont = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (*p) {\n\t\t\tcase '|':\n\t\t\t\twhile (s1 && s1->type != BAR) {\n\t\t\t\t\ts2 = s1;\n\t\t\t\t\ts1 = s1->next;\n\t\t\t\t}\n\t\t\t\tif (!s1) {\n\t\t\t\t\terror(1, s2,\n\t\t\t\t\t\t\"Not enough bar lines for lyric line\");\n\t\t\t\t\tgoto ly_next;\n\t\t\t\t}\n\t\t\t\ts2 = s1;\n\t\t\t\ts1 = s1->next;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\tcase '-':\n\t\t\t\tword[0] = LY_HYPH;\n\t\t\t\tword[1] = '\\0';\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tcase '_':\n\t\t\t\tword[0] = LY_UNDER;\n\t\t\t\tword[1] = '\\0';\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tword[0] = '\\0';\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tq = word;\n\t\t\t\tfor (;;) {\n\t\t\t\t\tunsigned char c;\n\n\t\t\t\t\tc = *p;\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\0':\n\t\t\t\t\tcase ' ':\n\t\t\t\t\tcase '\\t':\n\t\t\t\t\tcase '_':\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase '|':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '~':\n\t\t\t\t\t\tc = ' ';\n\t\t\t\t\t\tgoto addch;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tc = LY_HYPH;\n\t\t\t\t\t\tgoto addch;\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tif (p[1] == '\\0')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tswitch (p[1]) {\n\t\t\t\t\t\tcase '~':\n\t\t\t\t\t\tcase '_':\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\tcase '|':\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\tcase ' ':\n\t\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\t\tc = *++p;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* fall thru */\n\t\t\t\t\tdefault:\n\t\t\t\t\taddch:\n\t\t\t\t\t\tif (q < &word[sizeof word - 1])\n\t\t\t\t\t\t\t*q++ = c;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (c == LY_HYPH)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*q = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* store the word in the next note */\n\t\t\tif (s1) {\t\t\t\t/* for error */\n\t\t\t\ts2 = s1;\n\t\t\t\ts1 = next_lyric_note(s1);\n\t\t\t}\n\t\t\tif (!s1) {\n\t\t\t\tif (!s2)\n\t\t\t\t\ts2 = s;\n\t\t\t\terror(1, s2, \"Too many words in lyric line\");\n\t\t\t\tgoto ly_next;\n\t\t\t}\n\t\t\tif (word[0] != '\\0'\n\t\t\t && s1->posit.voc != SL_HIDDEN) {\n\t\t\t\tstruct lyl *lyl;\n\t\t\t\tfloat w;\n\n\t\t\t\tif (!s1->ly) {\n\t\t\t\t\ts1->ly = (struct lyrics *) getarena(sizeof (struct lyrics));\n\t\t\t\t\tmemset(s1->ly, 0, sizeof (struct lyrics));\n\t\t\t\t}\n\n\t\t\t\t/* handle the font change at start of text */\n\t\t\t\tq = word;\n\t\t\t\tif (*q == '$' && isdigit((unsigned char) q[1])\n\t\t\t\t && (unsigned) (q[1] - '0') < FONT_UMAX) {\n\t\t\t\t\tint ft;\n\n\t\t\t\t\tft = q[1] - '0';\n\t\t\t\t\tif (ft == 0)\n\t\t\t\t\t\tft = cfmt.vof;\n\t\t\t\t\tf = &cfmt.font_tb[ft];\n\t\t\t\t\tstr_font(ft);\n\t\t\t\t\tq += 2;\n\t\t\t\t}\n\t\t\t\tw = tex_str(q);\n\t\t\t\tq = tex_buf;\n\t\t\t\tlyl = (struct lyl *) getarena(sizeof *s1->ly->lyl[0]\n\t\t\t\t\t\t\t- sizeof s1->ly->lyl[0]->t\n\t\t\t\t\t\t\t+ strlen(q) + 1);\n\t\t\t\ts1->ly->lyl[ln] = lyl;\n\t\t\t\tlyl->f = f;\n\t\t\t\tlyl->w = w;\n\t\t\t\tstrcpy(lyl->t, q);\n\n\t\t\t\t/* handle the font changes inside the text */\n\t\t\t\twhile (*q != '\\0') {\n\t\t\t\t\tif (*q == '$' && isdigit((unsigned char) q[1])\n\t\t\t\t\t && (unsigned) (q[1] - '0') < FONT_UMAX) {\n\t\t\t\t\t\tint ft;\n\n\t\t\t\t\t\tq++;\n\t\t\t\t\t\tft = *q - '0';\n\t\t\t\t\t\tif (ft == 0)\n\t\t\t\t\t\t\tft = cfmt.vof;\n\t\t\t\t\t\tf = &cfmt.font_tb[ft];\n\t\t\t\t\t\tstr_font(ft);\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts2 = s1;\n\t\t\ts1 = s1->next;\n\t\t}\n\n\t\t/* loop if more lyrics */\nly_next:\n\t\tfor (;;) {\n\t\t\tif (!s->abc_next)\n\t\t\t\tgoto ly_upd;\n\t\t\tswitch (s->abc_next->abc_type) {\n\t\t\tcase ABC_T_PSCOM:\n\t\t\t\ts = process_pscomment(s->abc_next);\n\t\t\t\tf = &cfmt.font_tb[cfmt.vof];\t/* may have changed */\n\t\t\t\tstr_font(cfmt.vof);\n\t\t\t\tcontinue;\n\t\t\tcase ABC_T_INFO:\n\t\t\t\tif (s->abc_next->text[0] != 'w'\n\t\t\t\t && s->abc_next->text[0] != '+')\n\t\t\t\t\tgoto ly_upd;\n\t\t\t\ts = s->abc_next;\n\t\t\t\tif (s->text[0] == '+')\n\t\t\t\t\tcont = 1;\n\t\t\t\tif (!cont) {\n\t\t\t\t\ts1 = next_lyric_note(s1);\n\t\t\t\t\tif (s1) {\n\t\t\t\t\t\terror(1, s1,\n\t\t\t\t\t\t\t\"Not enough words for lyric line\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\t\t\t/* more lyric */\n\t\t\tdefault:\n\t\t\t\tgoto ly_upd;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* the next lyrics will go into the next notes */\nly_upd:\n//fixme: no error with abc-2.1\n\tif (next_lyric_note(s1))\n\t\terror(0, s1, \"Not enough words for lyric line\");\n\t// fill the w: with 'blank syllabes'\n\tcurvoice->lyric_start = curvoice->last_sym;\n\treturn s;\n}\n\n/* -- add a voice in the linked list -- */\nstatic void voice_link(struct VOICE_S *p_voice)\n{\n\tstruct VOICE_S *p_voice2;\n\n\tp_voice2 = first_voice;\n\tfor (;;) {\n\t\tif (p_voice2 == p_voice)\n\t\t\treturn;\n\t\tif (!p_voice2->next)\n\t\t\tbreak;\n\t\tp_voice2 = p_voice2->next;\n\t}\n\tp_voice2->next = p_voice;\n}\n\n/* -- get a voice overlay -- */\nstatic void get_over(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice, *p_voice2, *p_voice3;\n\tint range, voice, voice2, voice3;\nstatic char tx_wrong_dur[] = \"Wrong duration in voice overlay\";\nstatic char txt_no_note[] = \"No note in voice overlay\";\n\n\t/* treat the end of overlay */\n\tp_voice = curvoice;\n\tif (p_voice->ignore)\n\t\treturn;\n\tif (s->abc_type == ABC_T_BAR\n\t || s->u.v_over.type == V_OVER_E)  {\n\t\tif (!p_voice->last_sym) {\n\t\t\terror(1, s, txt_no_note);\n\t\t\treturn;\n\t\t}\n\t\tp_voice->last_sym->sflags |= S_BEAM_END;\n\t\tover_bar = 0;\n\t\tif (over_time < 0) {\n\t\t\terror(1, s, \"Erroneous end of voice overlap\");\n\t\t\treturn;\n\t\t}\n\t\tcurvoice = &voice_tb[over_voice];\n\t\tif (p_voice->time != over_mxtime) {\n\t\t\terror(1, s, tx_wrong_dur);\n\t\t\tif (p_voice->time > over_mxtime)\n\t\t\t\tcurvoice->time = p_voice->time;\n\t\t\telse\n\t\t\t\tp_voice->time = curvoice->time;\n\t\t}\n\t\tover_mxtime = 0;\n\t\tover_voice = -1;\n\t\tover_time = -1;\n\t\treturn;\n\t}\n\n\t/* treat the full overlay start */\n\tif (s->u.v_over.type == V_OVER_S) {\n\t\tover_voice = p_voice - voice_tb;\n\t\tover_time = p_voice->time;\n\t\treturn;\n\t}\n\n\t/* (here is treated a new overlay - '&') */\n\t/* create the extra voice if not done yet */\n\tif (!p_voice->last_sym) {\n\t\terror(1, s, txt_no_note);\n\t\treturn;\n\t}\n\tp_voice->last_sym->sflags |= S_BEAM_END;\n\tvoice2 = s->u.v_over.voice;\n\tp_voice2 = &voice_tb[voice2];\n\tif (parsys->voice[voice2].range < 0) {\n\t\tint clone;\n\n\t\tif (cfmt.abc2pscompat) {\n\t\t\terror(1, s, \"Cannot have %%%%abc2pscompat\");\n\t\t\tcfmt.abc2pscompat = 0;\n\t\t}\n\t\tclone = p_voice->clone >= 0;\n\t\tp_voice2->id[0] = '&';\n\t\tp_voice2->id[1] = '\\0';\n\t\tp_voice2->second = 1;\n\t\tparsys->voice[voice2].second = 1;\n\t\tp_voice2->scale = p_voice->scale;\n\t\tp_voice2->octave = p_voice->octave;\n\t\tp_voice2->transpose = p_voice->transpose;\n\t\tmemcpy(&p_voice2->key, &p_voice->key,\n\t\t\t\t\tsizeof p_voice2->key);\n\t\tmemcpy(&p_voice2->ckey, &p_voice->ckey,\n\t\t\t\t\tsizeof p_voice2->ckey);\n\t\tmemcpy(&p_voice2->okey, &p_voice->okey,\n\t\t\t\t\tsizeof p_voice2->okey);\n\t\tp_voice2->posit = p_voice->posit;\n\t\tp_voice2->staff = p_voice->staff;\n\t\tp_voice2->cstaff = p_voice->cstaff;\n\t\tp_voice2->color = p_voice->color;\n\t\tp_voice2->map_name = p_voice->map_name;\n\t\trange = parsys->voice[p_voice - voice_tb].range;\n\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\tif (parsys->voice[voice].range > range)\n\t\t\t\tparsys->voice[voice].range += clone + 1;\n\t\t}\n\t\tparsys->voice[voice2].range = range + 1;\n\t\tvoice_link(p_voice2);\n\t\tif (clone) {\n\t\t\tfor (voice3 = MAXVOICE; --voice3 >= 0; ) {\n\t\t\t\tif (parsys->voice[voice3].range < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (voice3 > 0) {\n\t\t\t\tp_voice3 = &voice_tb[voice3];\n\t\t\t\tstrcpy(p_voice3->id, p_voice2->id);\n\t\t\t\tp_voice3->second = 1;\n\t\t\t\tparsys->voice[voice3].second = 1;\n\t\t\t\tp_voice3->scale = voice_tb[p_voice->clone].scale;\n\t\t\t\tparsys->voice[voice3].range = range + 2;\n\t\t\t\tvoice_link(p_voice3);\n\t\t\t\tp_voice2->clone = voice3;\n\t\t\t} else {\n\t\t\t\terror(1, s,\n\t\t\t\t      \"Too many voices for overlay cloning\");\n\t\t\t}\n\t\t}\n\t}\n\tvoice = p_voice - voice_tb;\n//\tp_voice2->cstaff = p_voice2->staff = parsys->voice[voice2].staff\n//\t\t\t= parsys->voice[voice].staff;\n//\tif ((voice3 = p_voice2->clone) >= 0) {\n//\t\tp_voice3 = &voice_tb[voice3];\n//\t\tp_voice3->cstaff = p_voice3->staff\n//\t\t\t\t= parsys->voice[voice3].staff\n//\t\t\t\t= parsys->voice[p_voice->clone].staff;\n//\t}\n\n\tif (over_time < 0) {\t\t\t/* first '&' in a measure */\n\t\tint time;\n\n\t\tover_bar = 1;\n\t\tover_mxtime = p_voice->time;\n\t\tover_voice = voice;\n\t\ttime = p_voice2->time;\n\t\tfor (s = p_voice->last_sym; /*s*/; s = s->prev) {\n\t\t\tif (s->type == BAR\n\t\t\t || s->time <= time)\t/* (if start of tune) */\n\t\t\t\tbreak;\n\t\t}\n\t\tover_time = s->time;\n\t} else {\n\t\tif (over_mxtime == 0)\n\t\t\tover_mxtime = p_voice->time;\n\t\telse if (p_voice->time != over_mxtime)\n\t\t\terror(1, s, tx_wrong_dur);\n\t}\n\tp_voice2->time = over_time;\n\tcurvoice = p_voice2;\n}\n\nstruct staff_s {\n\tshort voice;\n\tshort flags;\n};\n\n/* -- parse %%staves / %%score -- */\nstatic void parse_staves(struct SYMBOL *s,\n\t\t\tstruct staff_s *staves)\n{\n\tchar *p;\n\tint voice, flags_st, brace, bracket, parenth, err;\n\tshort flags;\n\tstruct staff_s *p_staff;\n\n\t/* define the voices */\n\terr = 0;\n\tflags = 0;\n\tbrace = bracket = parenth = 0;\n\tflags_st = 0;\n\tvoice = 0;\n\tp = s->text + 7;\n\twhile (*p != '\\0' && !isspace((unsigned char) *p))\n\t\tp++;\n\twhile (*p != '\\0') {\n\t\tswitch (*p) {\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tif (parenth || brace + bracket >= 2) {\n\t\t\t\terror(1, s, \"Misplaced '[' in %%%%staves\");\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (brace + bracket == 0)\n\t\t\t\tflags |= OPEN_BRACKET;\n\t\t\telse\n\t\t\t\tflags |= OPEN_BRACKET2;\n\t\t\tbracket++;\n\t\t\tflags_st <<= 8;\n\t\t\tflags_st |= OPEN_BRACKET;\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tif (parenth || brace || bracket >= 2) {\n\t\t\t\terror(1, s, \"Misplaced '{' in %%%%staves\");\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bracket == 0)\n\t\t\t\tflags |= OPEN_BRACE;\n\t\t\telse\n\t\t\t\tflags |= OPEN_BRACE2;\n\t\t\tbrace++;\n\t\t\tflags_st <<= 8;\n\t\t\tflags_st |= OPEN_BRACE;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tif (parenth) {\n\t\t\t\terror(1, s, \"Misplaced '(' in %%%%staves\");\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflags |= OPEN_PARENTH;\n\t\t\tparenth++;\n\t\t\tflags_st <<= 8;\n\t\t\tflags_st |= OPEN_PARENTH;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tif (brace && !parenth && !(flags & (OPEN_BRACE | OPEN_BRACE2)))\n\t\t\t\tflags |= FL_VOICE;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tflags |= MASTER_VOICE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!isalnum((unsigned char) *p) && *p != '_') {\n\t\t\t\terror(1, s, \"Bad voice ID in %%%%staves\");\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (voice >= MAXVOICE) {\n\t\t\t\terror(1, s, \"Too many voices in %%%%staves\");\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i, v;\n\t\t\t\tchar sep, *q;\n\n\t\t\t\tq = p;\n\t\t\t\twhile (isalnum((unsigned char) *p) || *p == '_')\n\t\t\t\t\tp++;\n\t\t\t\tsep = *p;\n\t\t\t\t*p = '\\0';\n\n\t\t\t\t/* search the voice in the voice table */\n\t\t\t\tv = -1;\n\t\t\t\tfor (i = 0; i < MAXVOICE; i++) {\n\t\t\t\t\tif (strcmp(q, voice_tb[i].id) == 0) {\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (v < 0) {\n\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t\"Voice '%s' of %%%%staves has no symbol\",\n\t\t\t\t\t\tq);\n\t\t\t\t\terr = 1;\n//\t\t\t\t\tbreak;\n\t\t\t\t\tp_staff = staves;\n\t\t\t\t} else {\n\t\t\t\t\tp_staff = staves + voice++;\n\t\t\t\t\tp_staff->voice = v;\n\t\t\t\t}\n\t\t\t\t*p = sep;\n\t\t\t}\n\t\t\tfor ( ; *p != '\\0'; p++) {\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tcontinue;\n\t\t\t\tcase ']':\n\t\t\t\t\tif (!(flags_st & OPEN_BRACKET)) {\n\t\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t\t\"Misplaced ']' in %%%%staves\");\n\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbracket--;\n\t\t\t\t\tif (brace + bracket == 0)\n\t\t\t\t\t\tflags |= CLOSE_BRACKET;\n\t\t\t\t\telse\n\t\t\t\t\t\tflags |= CLOSE_BRACKET2;\n\t\t\t\t\tflags_st >>= 8;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '}':\n\t\t\t\t\tif (!(flags_st & OPEN_BRACE)) {\n\t\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t\t\"Misplaced '}' in %%%%staves\");\n\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbrace--;\n\t\t\t\t\tif (bracket == 0)\n\t\t\t\t\t\tflags |= CLOSE_BRACE;\n\t\t\t\t\telse\n\t\t\t\t\t\tflags |= CLOSE_BRACE2;\n\t\t\t\t\tflags &= ~FL_VOICE;\n\t\t\t\t\tflags_st >>= 8;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase ')':\n\t\t\t\t\tif (!(flags_st & OPEN_PARENTH)) {\n\t\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t\t\"Misplaced ')' in %%%%staves\");\n\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tparenth--;\n\t\t\t\t\tflags |= CLOSE_PARENTH;\n\t\t\t\t\tflags_st >>= 8;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '|':\n\t\t\t\t\tflags |= STOP_BAR;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp_staff->flags = flags;\n\t\t\tflags = 0;\n\t\t\tif (*p == '\\0')\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tp++;\n\t}\n\tif (flags_st != 0) {\n\t\terror(1, s, \"'}', ')' or ']' missing in %%%%staves\");\n\t\terr = 1;\n\t}\n\tif (err) {\n\t\tint i;\n\n\t\tfor (i = 0; i < voice; i++)\n\t\t\tstaves[i].flags = 0;\n\t}\n\tif (voice < MAXVOICE)\n\t\tstaves[voice].voice = -1;\n}\n\n/* -- get staves definition (%%staves / %%score) -- */\nstatic void get_staves(struct SYMBOL *s)\n{\n//\tstruct SYMBOL *s2;\n\tstruct VOICE_S *p_voice, *p_voice2;\n\tstruct staff_s *p_staff, staves[MAXVOICE];\n\tint i, flags, voice, staff, range, dup_voice, maxtime;\n\n\tmemset(staves, 0, sizeof staves);\n\tparse_staves(s, staves);\n\tif (staves[0].voice < 0)\t\t\t// if error\n\t\treturn;\n\n\tvoice_compress();\n\tvoice_dup();\n\n\t/* create a new staff system */\n\tcurvoice = p_voice = first_voice;\n\tmaxtime = p_voice->time;\n\tflags = p_voice->sym != NULL;\n\tfor (p_voice = p_voice->next; p_voice; p_voice = p_voice->next) {\n\t\tif (p_voice->time > maxtime)\n\t\t\tmaxtime = p_voice->time;\n\t\tif (p_voice->sym)\n\t\t\tflags = 1;\n\t}\n\tif (flags == 0\t\t\t/* if first %%staves */\n\t || (maxtime == 0 && staves_found < 0)) {\n\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\tparsys->voice[voice].range = -1;\n\t} else {\n\n\t\t/*\n\t\t * create a new staff system and\n\t\t * link the staves in a voice which is seen from\n\t\t * the previous system - see sort_all\n\t\t */\n//\t\tp_voice = curvoice;\n\t\tif (parsys->voice[curvoice - voice_tb].range < 0) {\n\t\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\t\tif (parsys->voice[voice].range >= 0) {\n\t\t\t\t\tcurvoice = &voice_tb[voice];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n/*fixme: should check if voice < MAXVOICE*/\n\t\t}\n\t\tcurvoice->time = maxtime;\n\n\t\t// put the staves before a measure bar (see draw_bar())\n//\t\ts2 = curvoice->last_sym;\n//\t\tif (s2 && s2->type == BAR && s2->time == maxtime) {\n//\t\t\tcurvoice->last_sym = s2->prev;\n//\t\t\tif (!curvoice->last_sym)\n//\t\t\t\tcurvoice->sym = NULL;\n//\t\t\tsym_link(s, STAVES);\n//\t\t\ts->next = s2;\n//\t\t\ts2->prev = s;\n//\t\t\tcurvoice->last_sym = s2;\n//\t\t} else {\n\t\t\tsym_link(s, STAVES); // link the staves in the current voice\n//\t\t}\n\t\ts->state = ABC_S_HEAD; /* (output PS sequences immediately) */\n\t\tparsys->nstaff = nstaff;\n\t\tsystem_new();\n\t}\n\tstaves_found = maxtime;\n\n\t/* initialize the voices */\n\tfor (voice = 0, p_voice = voice_tb;\n\t     voice < MAXVOICE;\n\t     voice++, p_voice++) {\n\t\tp_voice->second = 0;\n\t\tp_voice->floating = 0;\n\t\tp_voice->ignore = 0;\n\t\tp_voice->time = maxtime;\n\t}\n\n\t/* create the 'clone' voices */\n\tdup_voice = MAXVOICE;\n\trange = 0;\n\tp_staff = staves;\n\tparsys->top_voice = p_staff->voice;\n\tfor (i = 0;\n\t     i < MAXVOICE && p_staff->voice >= 0;\n\t     i++, p_staff++) {\n\t\tvoice = p_staff->voice;\n\t\tp_voice = &voice_tb[voice];\n\t\tif (parsys->voice[voice].range >= 0) {\n\t\t\tif (parsys->voice[dup_voice - 1].range >= 0) {\n\t\t\t\terror(1, s, \"Too many voices for cloning\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvoice = --dup_voice;\t/* duplicate the voice */\n\t\t\tp_voice2 = &voice_tb[voice];\n\t\t\tmemcpy(p_voice2, p_voice, sizeof *p_voice2);\n\t\t\tp_voice2->next = NULL;\n\t\t\tp_voice2->sym = p_voice2->last_sym = NULL;\n\t\t\tp_voice2->tblts[0] = p_voice2->tblts[1] = NULL;\n\t\t\tp_voice2->clone = -1;\n\t\t\twhile (p_voice->clone > 0)\n\t\t\t\tp_voice = &voice_tb[p_voice->clone];\n\t\t\tp_voice->clone = voice;\n\t\t\tp_voice = p_voice2;\n\t\t\tp_staff->voice = voice;\n\t\t}\n\t\tparsys->voice[voice].range = range++;\n\t\tvoice_link(p_voice);\n\t}\n\n\t/* change the behavior from %%staves to %%score */\n\tif (s->text[3] == 't') {\t\t/* if %%staves */\n\t\tfor (i = 0, p_staff = staves;\n\t\t     i < MAXVOICE - 2 && p_staff->voice >= 0;\n\t\t     i++, p_staff++) {\n\t\t\tflags = p_staff->flags;\n\t\t\tif (!(flags & (OPEN_BRACE | OPEN_BRACE2)))\n\t\t\t\tcontinue;\n\t\t\tif ((flags & (OPEN_BRACE | CLOSE_BRACE))\n\t\t\t\t\t== (OPEN_BRACE | CLOSE_BRACE)\n\t\t\t || (flags & (OPEN_BRACE2 | CLOSE_BRACE2))\n\t\t\t\t\t== (OPEN_BRACE2 | CLOSE_BRACE2))\n\t\t\t\tcontinue;\n\t\t\tif (p_staff[1].flags != 0)\n\t\t\t\tcontinue;\n\t\t\tif ((flags & OPEN_PARENTH)\n\t\t\t || (p_staff[2].flags & OPEN_PARENTH))\n\t\t\t\tcontinue;\n\n\t\t\t/* {a b c} --> {a *b c} */\n\t\t\tif (p_staff[2].flags & (CLOSE_BRACE | CLOSE_BRACE2)) {\n\t\t\t\tp_staff[1].flags |= FL_VOICE;\n\n\t\t\t/* {a b c d} --> {(a b) (c d)} */\n\t\t\t} else if (p_staff[2].flags == 0\n\t\t\t\t && (p_staff[3].flags & (CLOSE_BRACE | CLOSE_BRACE2))) {\n\t\t\t\tp_staff->flags |= OPEN_PARENTH;\n\t\t\t\tp_staff[1].flags |= CLOSE_PARENTH;\n\t\t\t\tp_staff[2].flags |= OPEN_PARENTH;\n\t\t\t\tp_staff[3].flags |= CLOSE_PARENTH;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set the staff system */\n\tstaff = -1;\n\tfor (i = 0, p_staff = staves;\n\t     i < MAXVOICE && p_staff->voice >= 0;\n\t     i++, p_staff++) {\n\t\tflags = p_staff->flags;\n\t\tif ((flags & (OPEN_PARENTH | CLOSE_PARENTH))\n\t\t\t\t== (OPEN_PARENTH | CLOSE_PARENTH)) {\n\t\t\tflags &= ~(OPEN_PARENTH | CLOSE_PARENTH);\n\t\t\tp_staff->flags = flags;\n\t\t}\n\t\tvoice = p_staff->voice;\n\t\tp_voice = &voice_tb[voice];\n\t\tif (flags & FL_VOICE) {\n\t\t\tp_voice->floating = 1;\n\t\t\tp_voice->second = 1;\n\t\t} else {\n#if MAXSTAFF < MAXVOICE\n\t\t\tif (staff >= MAXSTAFF - 1) {\n\t\t\t\terror(1, s, \"Too many staves\");\n\t\t\t} else\n#endif\n\t\t\t\tstaff++;\n\t\t\tparsys->staff[staff].flags = 0;\n\t\t}\n\t\tp_voice->staff = p_voice->cstaff\n\t\t\t\t= parsys->voice[voice].staff = staff;\n\t\tparsys->staff[staff].flags |= flags;\n\t\tif (flags & OPEN_PARENTH) {\n\t\t\tp_voice2 = p_voice;\n\t\t\twhile (i < MAXVOICE) {\n\t\t\t\ti++;\n\t\t\t\tp_staff++;\n\t\t\t\tvoice = p_staff->voice;\n\t\t\t\tp_voice = &voice_tb[voice];\n\t\t\t\tif (p_staff->flags & MASTER_VOICE) {\n\t\t\t\t\tp_voice2->second = 1;\n\t\t\t\t\tp_voice2 = p_voice;\n\t\t\t\t} else {\n\t\t\t\t\tp_voice->second = 1;\n\t\t\t\t}\n\t\t\t\tp_voice->staff = p_voice->cstaff\n\t\t\t\t\t\t= parsys->voice[voice].staff\n\t\t\t\t\t\t= staff;\n\t\t\t\tif (p_staff->flags & CLOSE_PARENTH)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparsys->staff[staff].flags |= p_staff->flags;\n\t\t}\n\t}\n\tif (staff < 0)\n\t\tstaff = 0;\n\tparsys->nstaff = nstaff = staff;\n\n\t/* change the behaviour of '|' in %%score */\n\tif (s->text[3] == 'c') {\t\t/* if %%score */\n\t\tfor (staff = 0; staff < nstaff; staff++)\n\t\t\tparsys->staff[staff].flags ^= STOP_BAR;\n\t}\n\n\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\tp_voice = &voice_tb[voice];\n\t\tparsys->voice[voice].second = p_voice->second;\n\t\tstaff = p_voice->staff;\n\t\tif (staff > 0)\n\t\t\tp_voice->norepbra\n\t\t\t\t= !(parsys->staff[staff - 1].flags & STOP_BAR);\n\t\tif (p_voice->floating && staff == nstaff)\n\t\t\tp_voice->floating = 0;\n\t}\n\tcurvoice = &voice_tb[parsys->top_voice];\n}\n\n/* -- re-initialize all potential voices -- */\nstatic void voice_init(void)\n{\n\tstruct VOICE_S *p_voice;\n\tint i;\n\n\tfor (i = 0, p_voice = voice_tb;\n\t     i < MAXVOICE;\n\t     i++, p_voice++) {\n\t\tp_voice->sym = p_voice->last_sym = NULL;\n\t\tp_voice->lyric_start = NULL;\n\t\tp_voice->bar_start = 0;\n\t\tp_voice->time = 0;\n\t\tp_voice->slur_st = 0;\n\t\tp_voice->hy_st = 0;\n\t\tp_voice->tie = 0;\n\t\tp_voice->rtie = 0;\n\t}\n}\n\n/* output a pdf mark */\nstatic void put_pdfmark(char *p)\n{\n\tunsigned char c, *q;\n\tint u;\n\n\tp = trim_title(p, NULL);\n\n\t/* check if pure ASCII without '\\', '(' nor ')'*/\n\tfor (q = (unsigned char *) p; *q != '\\0'; q++) {\n\t\tswitch (*q) {\n\t\tcase '\\\\':\n\t\tcase '(':\n\t\tcase ')':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*q >= 0x80)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (*q == '\\0') {\n\t\ta2b(\"[/Title(%s)/OUT pdfmark\\n\", p);\n\t\treturn;\n\t}\n\n\t/* build utf-8 mark */\n\ta2b(\"[/Title<FEFF\");\n\tq = (unsigned char *) p;\n\tu = -1;\n\twhile (*q != '\\0') {\n\t\tc = *q++;\n\t\tif (c < 0x80) {\n\t\t\tif (u >= 0) {\n\t\t\t\ta2b(\"%04X\", u);\n\t\t\t\tu = -1;\n\t\t\t}\n\t\t\ta2b(\"%04X\", (int) c);\n\t\t\tcontinue;\n\t\t}\n\t\tif (c < 0xc0) {\n\t\t\tu = (u << 6) | (c & 0x3f);\n\t\t\tcontinue;\n\t\t}\n\t\tif (u >= 0) {\n\t\t\ta2b(\"%04X\", u);\n\t\t\tu = -1;\n\t\t}\n\t\tif (c < 0xe0)\n\t\t\tu = c & 0x1f;\n\t\telse if (c < 0xf0)\n\t\t\tu = c & 0x0f;\n\t\telse\n\t\t\tu = c & 0x07;\n\t}\n\tif (u >= 0) {\n\t\ta2b(\"%04X\", u);\n\t\tu = -1;\n\t}\n\ta2b(\">/OUT pdfmark\\n\");\n}\n\n/* rebuild a tune header for %%tune filter */\nstatic char *tune_header_rebuild(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s2;\n\tchar *header, *p;\n\tint len;\n\n\tlen = 0;\n\ts2 = s;\n\tfor (;;) {\n\t\tif (s2->abc_type == ABC_T_INFO) {\n\t\t\tlen += strlen(s2->text) + 1;\n\t\t\tif (s2->text[0] == 'K')\n\t\t\t\tbreak;\n\t\t}\n\t\ts2 = s2->abc_next;\n\t}\n\theader = malloc(len + 1);\n\tp = header;\n\tfor (;;) {\n\t\tif (s->abc_type == ABC_T_INFO) {\n\t\t\tstrcpy(p, s->text);\n\t\t\tp += strlen(p);\n\t\t\t*p++ = '\\n';\n\t\t\tif (s->text[0] == 'K')\n\t\t\t\tbreak;\n\t\t}\n\t\ts = s->abc_next;\n\t}\n\t*p++ = '\\0';\n\treturn header;\n}\n\n/* apply the options to the current tune */\nstatic void tune_filter(struct SYMBOL *s)\n{\n\tstruct tune_opt_s *opt;\n\tstruct SYMBOL *s1, *s2;\n\tregex_t r;\n\tchar *header, *p;\n\tint ret;\n\n\theader = tune_header_rebuild(s);\n\tfor (opt = tune_opts; opt; opt = opt->next) {\n\t\tstruct SYMBOL *last_staves;\n\n\t\tp = &opt->s->text[2 + 5];\t/* \"%%tune RE\" */\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\n\t\tret = regcomp(&r, p, REG_EXTENDED | REG_NEWLINE | REG_NOSUB);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tret = regexec(&r, header, 0, NULL, 0);\n\t\tregfree(&r);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/* apply the options */\n\t\tcur_tune_opts = opt;\n\t\tlast_staves = s->abc_next;\n\t\tfor (s1 = opt->s->next; s1; s1 = s1->next) {\n\n\t\t\t/* replace the next %%staves/%%score */\n\t\t\tif (s1->abc_type == ABC_T_PSCOM\n\t\t\t && (strncmp(&s1->text[2], \"staves\", 6) == 0\n\t\t\t  || strncmp(&s1->text[2], \"score\", 5) == 0)) {\n\t\t\t\twhile (last_staves) {\n\t\t\t\t\tif (last_staves->abc_type == ABC_T_PSCOM\n\t\t\t\t\t && (strncmp(&last_staves->text[2],\n\t\t\t\t\t\t\t\t\"staves\", 6) == 0\n\t\t\t\t\t  || strncmp(&last_staves->text[2],\n\t\t\t\t\t\t\t\t \"score\", 5) == 0)) {\n\t\t\t\t\t\tlast_staves->text = s1->text;\n\t\t\t\t\t\tlast_staves = last_staves->abc_next;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlast_staves = last_staves->abc_next;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts2 = (struct SYMBOL *) getarena(sizeof *s2);\n\t\t\tmemcpy(s2, s1, sizeof *s2);\n\t\t\tprocess_pscomment(s2);\n\t\t}\n\t\tcur_tune_opts = NULL;\n\t\ttune_voice_opts = opt->voice_opts;\t// for %%voice\n//fixme: what if many %%tune's with %%voice inside?\n\t}\n\tfree(header);\n}\n\n/* apply the options of the current voice */\nstatic void voice_filter(void)\n{\n\tstruct voice_opt_s *opt;\n\tstruct SYMBOL *s;\n\tregex_t r;\n\tint pass, ret;\n\tchar *p;\n\n\t/* scan the global, then the tune options */\n\tpass = 0;\n\topt = voice_opts;\n\tfor (;;) {\n\t\tif (!opt) {\n\t\t\tif (pass != 0)\n\t\t\t\tbreak;\n\t\t\topt = tune_voice_opts;\n\t\t\tif (!opt)\n\t\t\t\tbreak;\n\t\t\tpass++;\n\t\t}\n\t\tp = &opt->s->text[2 + 6];\t/* \"%%voice RE\" */\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\n\t\tret = regcomp(&r, p, REG_EXTENDED | REG_NOSUB);\n\t\tif (ret)\n\t\t\tgoto next_voice;\n\t\tret = regexec(&r, curvoice->id, 0, NULL, 0);\n\t\tif (ret && curvoice->nm)\n\t\t\tret = regexec(&r, curvoice->nm, 0, NULL, 0);\n\t\tregfree(&r);\n\t\tif (ret)\n\t\t\tgoto next_voice;\n\n\t\t/* apply the options */\n\t\tfor (s = opt->s->next; s; s = s->next) {\n\t\t\tstruct SYMBOL *s2;\n\n\t\t\ts2 = (struct SYMBOL *) getarena(sizeof *s2);\n\t\t\tmemcpy(s2, s, sizeof *s2);\n\t\t\tprocess_pscomment(s2);\n\t\t}\nnext_voice:\n\t\topt = opt->next;\n\t}\n}\n\n/* -- check if a pseudo-comment may be in the tune header -- */\nstatic int check_header(struct SYMBOL *s)\n{\n\tswitch (s->text[2]) {\n\tcase 'E':\n\t\tif (strncmp(s->text + 2, \"EPS\", 3) == 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase 'm':\n\t\tif (strncmp(s->text + 2, \"multicol\", 8) == 0)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\n/* -- set the global definitions after the first K: or middle-tune T:'s -- */\nstatic void set_global_def(void)\n{\n\tstruct VOICE_S *p_voice;\n\tint i;\n\n\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t     --i >= 0;\n\t     p_voice++) {\n\t\tswitch (p_voice->key.instr) {\n\t\tcase 0:\n\t\t\tif (!pipeformat) {\n//\t\t\t\tp_voice->transpose = cfmt.transpose;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//fall thru\n\t\tcase K_HP:\n\t\tcase K_Hp:\n\t\t\tif (p_voice->posit.std == 0)\n\t\t\t\tp_voice->posit.std = SL_BELOW;\n\t\t\tbreak;\n\t\t}\n//\t\tif (p_voice->key.empty)\n//\t\t\tp_voice->key.sf = 0;\n\t\tif (!cfmt.autoclef\n\t\t && p_voice->s_clef\n\t\t && (p_voice->s_clef->sflags & S_CLEF_AUTO)) {\n\t\t\tp_voice->s_clef->u.clef.type = TREBLE;\n\t\t\tp_voice->s_clef->sflags &= ~S_CLEF_AUTO;\n\t\t}\n\t}\n\n\t/* switch to the 1st voice */\n\tcurvoice = &voice_tb[parsys->top_voice];\n}\n\n/* -- get the global definitions after the first K: or middle-tune T:'s -- */\nstatic struct SYMBOL *get_global_def(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s2;\n\n\tfor (;;) {\n\t\ts2 = s->abc_next;\n\t\tif (!s2)\n\t\t\tbreak;\n\t\tswitch (s2->abc_type) {\n\t\tcase ABC_T_INFO:\n\t\t\tswitch (s2->text[0]) {\n\t\t\tcase 'K':\n\t\t\t\ts = s2;\n\t\t\t\ts->state = ABC_S_HEAD;\n\t\t\t\tget_key(s);\n\t\t\t\tcontinue;\n\t\t\tcase 'I':\n\t\t\tcase 'M':\n\t\t\tcase 'Q':\n\t\t\t\ts = s2;\n\t\t\t\ts->state = ABC_S_HEAD;\n\t\t\t\ts = get_info(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ABC_T_PSCOM:\n\t\t\tif (!check_header(s2))\n\t\t\t\tbreak;\n\t\t\ts = s2;\n\t\t\ts->state = ABC_S_HEAD;\n\t\t\ts = process_pscomment(s);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tset_global_def();\n\treturn s;\n}\n\n/* save the global note maps */\nstatic void save_maps(void)\n{\n\tstruct map *omap, *map;\n\tstruct note_map *onotes, *notes;\n\n\tomap = maps;\n\tif (!omap) {\n\t\tmaps_glob = NULL;\n\t\treturn;\n\t}\n\tmaps_glob = map = getarena(sizeof *maps_glob);\n\tfor (;;) {\n\t\tmemcpy(map, omap, sizeof *map);\n\t\tonotes = omap->notes;\n\t\tif (onotes) {\n\t\t\tmap->notes = notes = getarena(sizeof *notes);\n\t\t\tfor (;;) {\n\t\t\t\tmemcpy(notes, onotes, sizeof *notes);\n\t\t\t\tonotes = onotes->next;\n\t\t\t\tif (!onotes)\n\t\t\t\t\tbreak;\n\t\t\t\tnotes->next = getarena(sizeof *notes);\n\t\t\t\tnotes = notes->next;\n\t\t\t}\n\t\t}\n\t\tomap = omap->next;\n\t\tif (!omap)\n\t\t\tbreak;\n\t\tmap->next = getarena(sizeof *map);\n\t\tmap = map->next;\n\t}\n}\n\n/* -- identify info line, store in proper place\t-- */\nstatic struct SYMBOL *get_info(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s2;\n\tstruct VOICE_S *p_voice;\n\tchar *p;\n\tchar info_type;\n\tint old_lvl;\n\tstatic char *state_txt[] = {\"global\", \"header\", \"tune\"};\n\n\t/* change arena to global or tune */\n\told_lvl = lvlarena(s->state != ABC_S_GLOBAL);\n\n\tinfo_type = s->text[0];\n\tswitch (info_type) {\n\tcase 'd':\n\t\tbreak;\n\tcase 'I':\n\t\ts = process_pscomment(s);\t/* same as pseudo-comment */\n\t\tbreak;\n\tcase 'K':\n\t\tget_key(s);\n\t\tif (s->state != ABC_S_HEAD)\n\t\t\tbreak;\n\t\tinfo['K' - 'A'] = s;\t\t/* first K:, end of tune header */\n\t\ttunenum++;\n\n\t\tif (!epsf) {\n//\t\t\tif (!cfmt.oneperpage)\n//\t\t\t\tuse_buffer = cfmt.splittune != 1;\n\t\t\tbskip(cfmt.topspace);\n\t\t}\n\t\ta2b(\"%% --- xref %s\\n\", &info['X' - 'A']->text[2]); // (for index)\n\t\twrite_heading();\n\t\tblock_put();\n\n\t\t/* information for index\n\t\t * (pdfmark must be after title show for Adobe Distiller) */\n\t\ts2 = info['T' - 'A'];\n\t\tp = &s2->text[2];\n\t\tif (*p != '\\0') {\n\t\t\ta2b(\"%% --- font \");\n\t\t\toutft = -1;\n\t\t\tset_font(TITLEFONT);\t\t/* font in comment */\n\t\t\ta2b(\"\\n\");\n\t\t\toutft = -1;\n\t\t}\n\t\tif (cfmt.pdfmark) {\n\t\t\tif (*p != '\\0')\n\t\t\t\tput_pdfmark(p);\n\t\t\tif (cfmt.pdfmark > 1) {\n\t\t\t\tfor (s2 = s2->next; s2; s2 = s2->next) {\n\t\t\t\t\tp = &s2->text[2];\n\t\t\t\t\tif (*p != '\\0')\n\t\t\t\t\t\tput_pdfmark(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnbar = cfmt.measurefirst;\t/* measure numbering */\n\t\tover_voice = -1;\n\t\tover_time = -1;\n\t\tover_bar = 0;\n\t\tcapo = 0;\n\t\treset_gen();\n\n\t\ts = get_global_def(s);\n\n\t\tif (!(cfmt.fields[0] & (1 << ('Q' - 'A'))))\n\t\t\tinfo['Q' - 'A'] = NULL;\n\n\t\t/* apply the filter for the voice '1' */\n\t\tvoice_filter();\n\n\t\t/* activate the default tablature if not yet done */\n\t\tif (!first_voice->tblts[0])\n\t\t\tset_tblt(first_voice);\n\t\tbreak;\n\tcase 'L':\n\t\tswitch (s->state) {\n\t\tcase ABC_S_HEAD: {\n\t\t\tint i, auto_len;\n\n\t\t\tauto_len = s->u.length.base_length < 0;\n\n\t\t\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t\t\t     --i >= 0;\n\t\t\t     p_voice++)\n\t\t\t\tp_voice->auto_len = auto_len;\n\t\t\tbreak;\n\t\t    }\n\t\tcase ABC_S_TUNE:\n\t\t\tcurvoice->auto_len = s->u.length.base_length < 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'M':\n\t\tget_meter(s);\n\t\tbreak;\n\tcase 'P': {\n\t\tstruct VOICE_S *curvoice_sav;\n\n\t\tif (s->state != ABC_S_TUNE) {\n\t\t\tinfo['P' - 'A'] = s;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(cfmt.fields[0] & (1 << ('P' - 'A'))))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If not in the main voice, then,\n\t\t * if the voices are synchronized and no P: yet in the main voice,\n\t\t * the misplaced P: goes into the main voice.\n\t\t */ \n\t\tp_voice = &voice_tb[parsys->top_voice];\n\t\tif (curvoice != p_voice) {\n\t\t\tif (curvoice->time != p_voice->time)\n\t\t\t\tbreak;\n\t\t\tif (p_voice->last_sym && p_voice->last_sym->type == PART)\n\t\t\t\tbreak;\t\t// already a P:\n\t\t\tcurvoice_sav = curvoice;\n\t\t\tcurvoice = p_voice;\n\t\t\tsym_link(s, PART);\n\t\t\tcurvoice = curvoice_sav;\n\t\t\tbreak;\n\t\t}\n\t\tsym_link(s, PART);\n\t\tbreak;\n\t    }\n\tcase 'Q':\n\t\tif (!(cfmt.fields[0] & (1 << ('Q' - 'A'))))\n\t\t\tbreak;\n\t\tif (s->state != ABC_S_TUNE) {\n\t\t\tinfo['Q' - 'A'] = s;\n\t\t\tbreak;\n\t\t}\n\t\tif (curvoice != &voice_tb[parsys->top_voice])\n\t\t\tbreak;\t\t/* tempo only for first voice */\n\t\ts2 = curvoice->last_sym;\n\t\tif (s2) {\t\t\t/* keep last Q: */\n\t\t\tint tim;\n\n\t\t\ttim = s2->time;\n\t\t\tdo {\n\t\t\t\tif (s2->type == TEMPO) {\n\t\t\t\t\tif (!s2->next)\n\t\t\t\t\t\tcurvoice->last_sym = s2->prev;\n\t\t\t\t\telse\n\t\t\t\t\t\ts2->next->prev = s2->prev;\n\t\t\t\t\tif (!s2->prev)\n\t\t\t\t\t\tcurvoice->sym = s2->next;\n\t\t\t\t\telse\n\t\t\t\t\t\ts2->prev->next = s2->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts2 = s2->prev;\n\t\t\t} while (s2 && s2->time == tim);\n\t\t}\n\t\tsym_link(s, TEMPO);\n\t\tbreak;\n\tcase 'r':\n\tcase 's':\n\t\tbreak;\n\tcase 'T':\n\t\tif (s->state == ABC_S_GLOBAL)\n\t\t\tbreak;\n\t\tif (s->state == ABC_S_HEAD)\t\t/* in tune header */\n\t\t\tgoto addinfo;\n\t\tgen_ly(1);\t\t\t\t/* in tune */\n\t\tp = &s->text[2];\n\t\tif (*p != '\\0') {\n\t\t\twrite_title(s);\n\t\t\ta2b(\"%% --- + (%s) ---\\n\", p);\n\t\t\tif (cfmt.pdfmark)\n\t\t\t\tput_pdfmark(p);\n\t\t}\n\t\tvoice_init();\n\t\treset_gen();\t\t/* (display the time signature) */\n\t\ts = get_global_def(s);\n\t\tbreak;\n\tcase 'U':\n\t\tdeco[s->u.user.symbol] = parse.deco_tb[s->u.user.value - 128];\n\t\tbreak;\n\tcase 'u':\n\t\tbreak;\n\tcase 'V':\n\t\tget_voice(s);\n\n\t\t/* handle here the possible clef which could be replaced\n\t\t * in case of filter */\n\t\tif (s->abc_next && s->abc_next->abc_type == ABC_T_CLEF) {\n\t\t\ts = s->abc_next;\n\t\t\tget_clef(s);\n\t\t}\n\t\tif (s->state == ABC_S_TUNE\n\t\t && !curvoice->last_sym\n\t\t && curvoice->time == 0)\n\t\t\tvoice_filter();\n\t\tbreak;\n\tcase 'w':\n\t\tif (s->state != ABC_S_TUNE)\n\t\t\tbreak;\n\t\tif (!(cfmt.fields[1] & (1 << ('w' - 'a')))) {\n\t\t\twhile (s->abc_next) {\n\t\t\t\tif (s->abc_next->abc_type != ABC_T_INFO\n\t\t\t\t || s->abc_next->text[0] != '+')\n\t\t\t\t\tbreak;\n\t\t\t\ts = s->abc_next;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ts = get_lyric(s);\n\t\tbreak;\n\tcase 'W':\n\t\tif (s->state == ABC_S_GLOBAL\n\t\t || !(cfmt.fields[0] & (1 << ('W' - 'A'))))\n\t\t\tbreak;\n\t\tgoto addinfo;\n\tcase 'X':\n\t\tif (!epsf) {\n\t\t\tbuffer_eob(0);\t/* flush stuff left from %% lines */\n\t\t\twrite_buffer();\n//fixme: 8.6.2\n\t\t\tif (cfmt.oneperpage)\n\t\t\t\tclose_page();\n//\t\t\telse if (in_page)\n\t\t\telse\n\t\t\t\tuse_buffer = cfmt.splittune != 1;\n\t\t}\n\n\t\tmemcpy(&dfmt, &cfmt, sizeof dfmt); /* save global values */\n\t\tmemcpy(&info_glob, &info, sizeof info_glob);\n\t\tmemcpy(deco_glob, deco, sizeof deco_glob);\n\t\tsave_maps();\n\t\tinfo['X' - 'A'] = s;\n\t\tif (tune_opts)\n\t\t\ttune_filter(s);\n\t\tbreak;\n\tdefault:\n\t\tif (info_type >= 'A' && info_type <= 'Z') {\n\t\t\tstruct SYMBOL *prev;\n\n\t\t\tif (s->state == ABC_S_TUNE)\n\t\t\t\tbreak;\naddinfo:\n\t\t\tprev = info[info_type - 'A'];\n\t\t\tif (!prev\n\t\t\t || (prev->state == ABC_S_GLOBAL\n\t\t\t  && s->state != ABC_S_GLOBAL)) {\n\t\t\t\tinfo[info_type - 'A'] = s;\n\t\t\t} else {\n\t\t\t\twhile (prev->next)\n\t\t\t\t\tprev = prev->next;\n\t\t\t\tprev->next = s;\n\t\t\t}\n\t\t\twhile (s->abc_next\n\t\t\t    && s->abc_next->abc_type == ABC_T_INFO\n\t\t\t    && s->abc_next->text[0] == '+') {\n\t\t\t\tprev = s;\n\t\t\t\ts = s->abc_next;\n\t\t\t\tprev->next = s;\n\t\t\t}\n\t\t\ts->prev = prev;\n\t\t\tbreak;\n\t\t}\n\t\tif (s->state != ABC_S_GLOBAL)\n\t\t\terror(1, s, \"%s info '%c:' not treated\",\n\t\t\t\tstate_txt[(int) s->state], info_type);\n\t\tbreak;\n\t}\n\tlvlarena(old_lvl);\n\treturn s;\n}\n\n/* -- set head type, dots, flags for note -- */\nvoid identify_note(struct SYMBOL *s,\n\t\t   int dur,\n\t\t   int *p_head,\n\t\t   int *p_dots,\n\t\t   int *p_flags)\n{\n\tint head, dots, flags;\n\n\tif (dur % 12 != 0)\n\t\terror(1, s, \"Invalid note duration\");\n\tdur /= 12;\t\t\t/* see BASE_LEN for values */\n\tif (dur == 0)\n\t\terror(1, s, \"Note too short\");\n\tfor (flags = 5; dur != 0; dur >>= 1, flags--) {\n\t\tif (dur & 1)\n\t\t\tbreak;\n\t}\n\tdur >>= 1;\n\tswitch (dur) {\n\tcase 0: dots = 0; break;\n\tcase 1: dots = 1; break;\n\tcase 3: dots = 2; break;\n\tcase 7: dots = 3; break;\n\tdefault:\n\t\terror(1, s, \"Note too much dotted\");\n\t\tdots = 3;\n\t\tbreak;\n\t}\n\tflags -= dots;\n\tif (flags >= 0) {\n\t\thead = H_FULL;\n\t} else switch (flags) {\n\tdefault:\n\t\terror(1, s, \"Note too long\");\n\t\tflags = -4;\n\t\t/* fall thru */\n\tcase -4:\n\t\thead = H_SQUARE;\n\t\tbreak;\n\tcase -3:\n\t\thead = cfmt.squarebreve ? H_SQUARE : H_OVAL;\n\t\tbreak;\n\tcase -2:\n\t\thead = H_OVAL;\n\t\tbreak;\n\tcase -1:\n\t\thead = H_EMPTY;\n\t\tbreak;\n\t}\n\t*p_head = head;\n\t*p_flags = flags;\n\t*p_dots = dots;\n}\n\n/* -- adjust the duration and time of symbols in a measure when L:auto -- */\nstatic void adjust_dur(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s2;\n\tint time, auto_time;\n\n\t/* search the start of the measure */\n\ts2 = curvoice->last_sym;\n\tif (!s2)\n\t\treturn;\n\n\t/* the bar time is correct if there is multi-rests */\n\tif (s2->type == MREST\n\t || s2->type == BAR)\t\t/* in second voice */\n\t\treturn;\n\twhile (s2->type != BAR && s2->prev)\n\t\ts2 = s2->prev;\n\ttime = s2->time;\n\tauto_time = curvoice->time - time;\n\n\t/* remove the invisible rest at start of tune */\n\tif (time == 0) {\n\t\twhile (s2 && s2->dur == 0)\n\t\t\ts2 = s2->next;\n\t\tif (s2 && s2->abc_type == ABC_T_REST\n\t\t && (s2->flags & ABC_F_INVIS)) {\n\t\t\ttime += s2->dur * curvoice->wmeasure / auto_time;\n\t\t\tif (s2->prev)\n\t\t\t\ts2->prev->next = s2->next;\n\t\t\telse\n\t\t\t\tcurvoice->sym = s2->next;\n\t\t\tif (s2->next)\n\t\t\t\ts2->next->prev = s2->prev;\n\t\t\ts2 = s2->next;\n\t\t}\n\t}\n\tif (curvoice->wmeasure == auto_time)\n\t\treturn;\t\t\t\t/* already good duration */\n\n\tfor (; s2; s2 = s2->next) {\n\t\tint i, head, dots, nflags;\n\n\t\ts2->time = time;\n\t\tif (s2->dur == 0\n\t\t || (s2->flags & ABC_F_GRACE))\n\t\t\tcontinue;\n\t\ts2->dur = s2->dur * curvoice->wmeasure / auto_time;\n\t\ttime += s2->dur;\n\t\tif (s2->type != NOTEREST)\n\t\t\tcontinue;\n\t\tfor (i = 0; i <= s2->nhd; i++)\n\t\t\ts2->u.note.notes[i].len = s2->u.note.notes[i].len\n\t\t\t\t\t * curvoice->wmeasure / auto_time;\n\t\tidentify_note(s2, s2->u.note.notes[0].len,\n\t\t\t\t&head, &dots, &nflags);\n\t\ts2->head = head;\n\t\ts2->dots = dots;\n\t\ts2->nflags = nflags;\n\t\tif (s2->nflags <= -2)\n\t\t\ts2->flags |= ABC_F_STEMLESS;\n\t\telse\n\t\t\ts2->flags &= ~ABC_F_STEMLESS;\n\t}\n\tcurvoice->time = s->time = time;\n}\n\n/* -- measure bar -- */\nstatic void get_bar(struct SYMBOL *s)\n{\n\tint bar_type;\n\tstruct SYMBOL *s2;\n\n\tif (s->u.bar.repeat_bar\n\t && curvoice->norepbra\n\t && !curvoice->second)\n\t\ts->sflags |= S_NOREPBRA;\n\tif (curvoice->auto_len)\n\t\tadjust_dur(s);\n\n\tbar_type = s->u.bar.type;\n\ts2 = curvoice->last_sym;\n\tif (s2 && s2->type == SPACE) {\n\t\ts2->time--;\t\t// keep the space at the right place\n\t} else if (s2 && s2->type == BAR) {\n\n\t\t/* remove the invisible repeat bars when no shift is needed */\n\t\tif (bar_type == B_OBRA\n\t\t && !s2->text\n\t\t && (curvoice == &voice_tb[parsys->top_voice]\n\t\t  || (parsys->staff[curvoice->staff - 1].flags & STOP_BAR)\n\t\t  || (s->sflags & S_NOREPBRA))) {\n\t\t\ts2->text = s->text;\n\t\t\ts2->u.bar.repeat_bar = s->u.bar.repeat_bar;\n\t\t\ts2->flags |= s->flags & (ABC_F_RBSTART | ABC_F_RBSTOP);\n\t\t\ts2->sflags |= s->sflags\n\t\t\t\t\t& (S_NOREPBRA | S_RBSTART | S_RBSTOP);\n\t\t\ts = s2;\n\t\t\tgoto gch_build;\n\t\t}\n\n\t\t/* merge back-to-back repeat bars */\n\t\tif (bar_type == B_LREP && !s->text) {\n\t\t\tif (s2->u.bar.type == B_RREP) {\n\t\t\t\ts2->u.bar.type = B_DREP;\n\t\t\t\ts2->flags |= ABC_F_RBSTOP;\n\t\t\t\ts2->sflags |= S_RBSTOP;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (s2->u.bar.type == B_DOUBLE) {\n\t\t\t\ts2->u.bar.type = (B_SINGLE << 8) | B_LREP;\n\t\t\t\ts2->flags |= ABC_F_RBSTOP;\n\t\t\t\ts2->sflags |= S_RBSTOP;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* link the bar in the voice */\n\t/* the bar must appear before a key signature */\n\tif (s2 && s2->type == KEYSIG\n\t && (!s2->prev || s2->prev->type != BAR)) {\n\t\tcurvoice->last_sym = s2->prev;\n\t\tif (!curvoice->last_sym)\n\t\t\tcurvoice->sym = NULL;\n\t\tsym_link(s, BAR);\n\t\ts->next = s2;\n\t\ts2->prev = s;\n\t\tcurvoice->last_sym = s2;\n\t} else {\n\t\tsym_link(s, BAR);\n\t}\n\ts->staff = curvoice->staff;\t/* original staff */\n\n\t/* set some flags */\n\tswitch (bar_type) {\n\tcase B_OBRA:\n\tcase (B_OBRA << 4) + B_CBRA:\n\t\ts->flags |= ABC_F_INVIS;\n\t\tbreak;\n\tcase (B_COL << 8) + (B_BAR << 4) + B_COL:\n\tcase (B_COL << 12) + (B_BAR << 8) + (B_BAR << 4) + B_COL:\n\t\tbar_type = (B_COL << 4) + B_COL;\t/* :|: and :||: -> :: */\n\t\ts->u.bar.type = bar_type;\n\t\tbreak;\n\tcase (B_BAR << 4) + B_BAR:\n\t\tif (!cfmt.rbdbstop)\n\t\t\tbreak;\n\tcase (B_OBRA << 4) + B_BAR:\n\tcase (B_BAR << 4) + B_CBRA:\n\t\ts->flags |= ABC_F_RBSTOP;\n\t\ts->sflags |= S_RBSTOP;\n\t\tbreak;\n\t}\n\n\tif (s->u.bar.dc.n > 0)\n\t\tdeco_cnv(&s->u.bar.dc, s, NULL); /* convert the decorations */\n\n\t/* build the gch */\ngch_build:\n\tif (s->text) {\n\t\tif (!s->u.bar.repeat_bar) {\n\t\t\tgch_build(s);\t/* build the guitar chords */\n\t\t} else {\n\t\t\ts->gch = getarena(sizeof *s->gch * 2);\n\t\t\tmemset(s->gch, 0, sizeof *s->gch * 2);\n\t\t\ts->gch->type = 'r';\n\t\t\ts->gch->font = REPEATFONT;\n\t\t\tstr_font(REPEATFONT);\n\t\t\ts->gch->w = tex_str(s->text);\n\t\t\ts->gch->x = 4 + 4;\n\t\t}\n\t}\n}\n\n/* -- activate the tablature from the command line '-T' -- */\nstatic void set_tblt(struct VOICE_S *p_voice)\n{\n\tstruct tblt_s *tblt;\n\tint i;\n\n\tfor (i = 0; i < ncmdtblt; i++) {\n\t\tif (!cmdtblts[i].active)\n\t\t\tcontinue;\n\t\tif (cmdtblts[i].vn[0] != '\\0') {\n\t\t\tif (strcmp(cmdtblts[i].vn, p_voice->id) != 0\n\t\t\t && (p_voice->nm == 0\n\t\t\t  || strcmp(cmdtblts[i].vn, p_voice->nm) != 0)\n\t\t\t && (p_voice->snm == 0\n\t\t\t  || strcmp(cmdtblts[i].vn, p_voice->snm) != 0))\n\t\t\t\tcontinue;\n\t\t}\n\t\ttblt = tblts[cmdtblts[i].index];\n\t\tif (p_voice->tblts[0] == tblt\n\t\t || p_voice->tblts[1] == tblt)\n\t\t\tcontinue;\n\t\tif (p_voice->tblts[0] == 0)\n\t\t\tp_voice->tblts[0] = tblt;\n\t\telse\n\t\t\tp_voice->tblts[1] = tblt;\n\t}\n}\n\n/* -- do a tune -- */\nvoid do_tune(void)\n{\n\tstruct VOICE_S *p_voice;\n\tstruct SYMBOL *s, *s1, *s2;\n\tint i;\n\n\t/* initialize */\n\tlvlarena(0);\n\tnstaff = 0;\n\tstaves_found = -1;\n\tfor (i = 0; i < MAXVOICE; i++) {\n\t\tp_voice = &voice_tb[i];\n\t\ts1 = (struct SYMBOL *) getarena(sizeof *s1);\n\t\tmemset(s1, 0, sizeof *s1);\n\t\ts1->type = CLEF;\n\t\ts1->voice = i;\n\t\tif (cfmt.autoclef) {\n\t\t\ts1->u.clef.type = AUTOCLEF;\n\t\t\ts1->sflags = S_CLEF_AUTO;\n\t\t} else {\n\t\t\ts1->u.clef.type = TREBLE;\n\t\t}\n\t\ts1->u.clef.line = 2;\t\t/* treble clef on 2nd line */\n\t\tp_voice->s_clef = s1;\n\t\tp_voice->meter.wmeasure = 1;\t// M:none\n\t\tp_voice->wmeasure = 1;\n\t\tp_voice->scale = 1;\n\t\tp_voice->clone = -1;\n\t\tp_voice->over = -1;\n\t\tp_voice->posit = cfmt.posit;\n\t\tp_voice->stafflines = NULL;\n//\t\tp_voice->staffscale = 0;\n\t}\n\tcurvoice = first_voice = voice_tb;\n\treset_deco();\n\tabc2win = 0;\n\tclip_start.bar = -1;\n\tclip_end.bar = (short unsigned) ~0 >> 1;\n\n\tparsys = NULL;\n\tsystem_new();\t\t\t/* create the 1st staff system */\n\tparsys->top_voice = parsys->voice[0].range = 0;\t/* implicit voice */\n\n\tif (!epsf) {\n//fixme: 8.6.2\n#if 1\n// fixme: should already be 0\n\t\tuse_buffer = 0;\n#else\n\t\tif (cfmt.oneperpage) {\n\t\t\tuse_buffer = 0;\n\t\t\tclose_page();\n\t\t} else {\n\t\t\tif (in_page)\t\t// ??\n\t\t\t\tuse_buffer = cfmt.splittune != 1;\n\t\t}\n#endif\n\t} else {\n\t\tuse_buffer = 1;\n\t\tmarg_init();\n\t}\n\n\t/* set the duration of all notes/rests\n\t *\t(this is needed for tuplets and the feathered beams) */\n\tfor (s = parse.first_sym; s; s = s->abc_next) {\n\t\tswitch (s->abc_type) {\n\t\tcase ABC_T_EOLN:\n\t\t\tif (s->u.eoln.type == 2)\n\t\t\t\tabc2win = 1;\n\t\t\tbreak;\n\t\tcase ABC_T_NOTE:\n\t\tcase ABC_T_REST:\n\t\t\ts->dur = s->u.note.notes[0].len;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (voice_tb[0].id[0] == '\\0') {\t/* single voice */\n\t\tvoice_tb[0].id[0] = '1';\t/* implicit V:1 */\n\t\tvoice_tb[0].id[1] = '\\0';\n\t}\n\n\t/* scan the tune */\n\tfor (s = parse.first_sym; s; s = s->abc_next) {\n\t\tif (s->flags & ABC_F_LYRIC_START)\n\t\t\tcurvoice->lyric_start = curvoice->last_sym;\n\t\tswitch (s->abc_type) {\n\t\tcase ABC_T_INFO:\n\t\t\ts = get_info(s);\n\t\t\tbreak;\n\t\tcase ABC_T_PSCOM:\n\t\t\ts = process_pscomment(s);\n\t\t\tbreak;\n\t\tcase ABC_T_NOTE:\n\t\tcase ABC_T_REST:\n\t\t\tif (curvoice->space\n\t\t\t && !(s->flags & ABC_F_GRACE)) {\n\t\t\t\tcurvoice->space = 0;\n\t\t\t\ts->flags |= ABC_F_SPACE;\n\t\t\t}\n\t\t\tget_note(s);\n\t\t\tbreak;\n\t\tcase ABC_T_BAR:\n\t\t\tif (over_bar)\n\t\t\t\tget_over(s);\n\t\t\tget_bar(s);\n\t\t\tbreak;\n\t\tcase ABC_T_CLEF:\n\t\t\tget_clef(s);\n\t\t\tbreak;\n\t\tcase ABC_T_EOLN:\n\t\t\tif (cfmt.breakoneoln\n\t\t\t || (s->flags & ABC_F_SPACE))\n\t\t\t\tcurvoice->space = 1;\n\t\t\tif (cfmt.continueall || cfmt.barsperstaff\n\t\t\t || s->u.eoln.type == 1)\t/* if '\\' */\n\t\t\t\tcontinue;\n\t\t\tif (s->u.eoln.type == 0\t\t/* if normal eoln */\n\t\t\t && abc2win\n\t\t\t && parse.abc_vers != (2 << 16))\n\t\t\t\tcontinue;\n\t\t\tif (parsys->voice[curvoice - voice_tb].range == 0\n\t\t\t && curvoice->last_sym)\n\t\t\t\tcurvoice->last_sym->sflags |= S_EOLN;\n\t\t\tif (!cfmt.alignbars)\n\t\t\t\tcontinue;\t\t/* normal */\n\n\t\t\t/* align bars */\n\t\t\twhile (s->abc_next) {\t\t/* treat the lyrics */\n\t\t\t\tif (s->abc_next->abc_type != ABC_T_INFO)\n\t\t\t\t\tbreak;\n\t\t\t\tswitch (s->abc_next->text[0]) {\n\t\t\t\tcase 'w':\n\t\t\t\t\ts = get_info(s->abc_next);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'd':\n\t\t\t\tcase 's':\n\t\t\t\t\ts = s->abc_next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (curvoice - voice_tb) + 1;\n\t\t\tif (i < cfmt.alignbars) {\n\t\t\t\tcurvoice = &voice_tb[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgenerate();\n\t\t\tbuffer_eob(0);\n\t\t\tcurvoice = &voice_tb[0];\n\t\t\tcontinue;\n\t\tcase ABC_T_MREST: {\n\t\t\tint dur;\n\n\t\t\tdur = curvoice->wmeasure * s->u.bar.len;\n\t\t\tif (curvoice->second) {\n\t\t\t\tcurvoice->time += dur;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym_link(s, MREST);\n\t\t\ts->dur = dur;\n\t\t\tcurvoice->time += dur;\n\t\t\tif (s->text)\n\t\t\t\tgch_build(s);\t/* build the guitar chords */\n\t\t\tif (s->u.bar.dc.n > 0)\n\t\t\t\tdeco_cnv(&s->u.bar.dc, s, NULL);\n\t\t\tbreak;\n\t\t    }\n\t\tcase ABC_T_MREP: {\n\t\t\tint n;\n\n\t\t\ts2 = curvoice->last_sym;\n\t\t\tif (!s2 || s2->type != BAR) {\n\t\t\t\terror(1, s,\n\t\t\t\t      \"No bar before measure repeat\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (curvoice->ignore)\n\t\t\t\tbreak;\n\t\t\tn = s->u.bar.len;\n\t\t\tif (curvoice->second) {\n\t\t\t\tcurvoice->time += curvoice->wmeasure * n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts2 = sym_add(curvoice, NOTEREST);\n\t\t\ts2->abc_type = ABC_T_REST;\n\t\t\ts2->flags |= ABC_F_INVIS;\n\t\t\ts2->dur = curvoice->wmeasure;\n\t\t\tcurvoice->time += s2->dur;\n\t\t\tif (n == 1) {\n\t\t\t\ts->abc_next->u.bar.len = n; /* <n> in the next bar */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (--n > 0) {\n\t\t\t\ts2 = sym_add(curvoice, BAR);\n\t\t\t\ts2->u.bar.type = B_SINGLE;\n\t\t\t\tif (n == s->u.bar.len - 1)\n\t\t\t\t\ts2->u.bar.len = s->u.bar.len;\n\t\t\t\ts2 = sym_add(curvoice, NOTEREST);\n\t\t\t\ts2->abc_type = ABC_T_REST;\n\t\t\t\ts2->flags |= ABC_F_INVIS;\n\t\t\t\ts2->dur = curvoice->wmeasure;\n\t\t\t\tcurvoice->time += s2->dur;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\tcase ABC_T_V_OVER:\n\t\t\tget_over(s);\n\t\t\tcontinue;\n\t\tcase ABC_T_TUPLET:\n\t\t\tset_tuplet(s);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (s->type == 0)\n\t\t\tcontinue;\n\t\tif (curvoice->second)\n\t\t\ts->sflags |= S_SECOND;\n\t\tif (curvoice->floating)\n\t\t\ts->sflags |= S_FLOATING;\n\t}\n\n\tgen_ly(0);\n\tput_history();\n\tbuffer_eob(1);\n\tif (epsf) {\n\t\twrite_eps();\n\t} else {\n\t\twrite_buffer();\n//\t\tif (!cfmt.oneperpage && in_page)\n//\t\t\tuse_buffer = cfmt.splittune != 1;\n\t}\n\n\tif (info['X' - 'A']) {\n\t\tmemcpy(&cfmt, &dfmt, sizeof cfmt); /* restore global values */\n\t\tmemcpy(&info, &info_glob, sizeof info);\n\t\tmemcpy(deco, deco_glob, sizeof deco);\n\t\tmaps = maps_glob;\n\t\tinfo['X' - 'A'] = NULL;\n\t}\n\n\t/* free the parsing resources */\n\t{\n\t\tstruct brk_s *brk, *brk2;\n\n\t\tbrk = brks;\n\t\twhile (brk) {\n\t\t\tbrk2 = brk->next;\n\t\t\tfree(brk);\n\t\t\tbrk = brk2;\n\t\t}\n\t\tbrks = brk;\t\t/* (NULL) */\n\t}\n}\n\n/* check if a K: or M: may go to the tune key and time signatures */\nstatic int is_tune_sig(void)\n{\n\tstruct SYMBOL *s;\n\n\tif (!curvoice->sym)\n\t\treturn 1;\n\tif (curvoice->time != 0)\n\t\treturn 0;\t\t/* not at start of tune */\n\tfor (s = curvoice->sym; s; s = s->next) {\n\t\tswitch (s->type) {\n\t\tcase TEMPO:\n\t\tcase PART:\n\t\tcase FMTCHG:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/* -- get a clef definition (in K: or V:) -- */\nstatic void get_clef(struct SYMBOL *s)\n{\n\tstruct SYMBOL *s2;\n\tstruct VOICE_S *p_voice;\n\tint voice;\n\n\tp_voice = curvoice;\n\ts->type = CLEF;\n\tif (s->abc_prev->abc_type == ABC_T_INFO) {\n\t\tswitch (s->abc_prev->text[0]) {\n\t\tcase 'K':\n\t\t\tif (s->abc_prev->state != ABC_S_HEAD)\n\t\t\t\tbreak;\n\t\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\t\tvoice_tb[voice].s_clef = s;\n\t\t\t\tif (s->u.clef.type == PERC)\n\t\t\t\t\tvoice_tb[voice].perc = 1;\n\t\t\t}\n\t\t\treturn;\n\t\tcase 'V':\t/* clef relative to a voice definition in the header */\n\t\t\tp_voice = &voice_tb[(int) s->abc_prev->u.voice.voice];\n\t\t\tcurvoice = p_voice;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (is_tune_sig()) {\n\t\tp_voice->s_clef = s;\n\t} else {\t\t\t\t/* clef change */\n\n#if 0\n\t\tsym_link(s, CLEF);\n#else\n\t\t/* the clef must appear before a key signature or a bar */\n\t\ts2 = p_voice->last_sym;\n\t\tif (s2 && s2->prev\n\t\t && s2->time == curvoice->time\t\t// if no time skip\n\t\t && (s2->type == KEYSIG || s2->type == BAR)) {\n\t\t\tstruct SYMBOL *s3;\n\n\t\t\tfor (s3 = s2; s3->prev; s3 = s3->prev) {\n\t\t\t\tswitch (s3->prev->type) {\n\t\t\t\tcase KEYSIG:\n\t\t\t\tcase BAR:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp_voice->last_sym = s3->prev;\n\t\t\tsym_link(s, CLEF);\n\t\t\ts->next = s3;\n\t\t\ts3->prev = s;\n\t\t\tp_voice->last_sym = s2;\n\t\t} else {\n\t\t\tsym_link(s, CLEF);\n\t\t}\n#endif\n\t\ts->aux = 1;\t\t\t/* small clef */\n\t}\n\tp_voice->perc = s->u.clef.type == PERC;\n\tif (s->u.clef.type == AUTOCLEF)\n\t\ts->sflags |= S_CLEF_AUTO;\n}\n\n/* -- treat %%clef -- */\nstatic void clef_def(struct SYMBOL *s)\n{\n\tchar *p;\n\tint clef, clef_line;\n\tchar str[80];\n\n\tclef = -1;\n\tclef_line = 2;\n\tp = &s->text[2 + 5];\t\t/* skip %%clef */\n\twhile (isspace((unsigned char) *p))\n\t\tp++;\n\n\t/* clef name */\n\tswitch (*p) {\n\tcase '\\\"':\t\t\t/* user clef name */\n\t\tp = get_str(str, p, sizeof str);\n\t\ts->u.clef.name = (char *) getarena(strlen(str) + 1);\n\t\tstrcpy(s->u.clef.name, str);\n\t\tclef = TREBLE;\n\t\tbreak;\n\tcase 'G':\n\t\tclef = TREBLE;\n\t\tp++;\n\t\tbreak;\n\tcase 'F':\n\t\tclef = BASS;\n\t\tclef_line = 4;\n\t\tp++;\n\t\tbreak;\n\tcase 'C':\n\t\tclef = ALTO;\n\t\tclef_line = 3;\n\t\tp++;\n\t\tbreak;\n\tcase 'P':\n\t\tclef = PERC;\n\t\tp++;\n\t\tbreak;\n\tcase 't':\n\t\tif (strncmp(p, \"treble\", 6) == 0) {\n\t\t\tclef = TREBLE;\n\t\t\tp += 6;\n\t\t}\n\t\tif (strncmp(p, \"tenor\", 5) == 0) {\n\t\t\tclef = ALTO;\n\t\t\tclef_line = 4;\n\t\t\tp += 5;\n\t\t}\n\t\tbreak;\n\tcase 'a':\n\t\tif (strncmp(p, \"alto\", 4) == 0) {\n\t\t\tclef = ALTO;\n\t\t\tclef_line = 3;\n\t\t\tp += 4;\n\t\t} else if (strncmp(p, \"auto\", 4) == 0) {\n\t\t\tclef = AUTOCLEF;\n\t\t\ts->sflags |= S_CLEF_AUTO;\n\t\t\tp += 4;\n\t\t}\n\t\tbreak;\n\tcase 'b':\n\t\tif (strncmp(p, \"bass\", 4) == 0) {\n\t\t\tclef = BASS;\n\t\t\tclef_line = 4;\n\t\t\tp += 4;\n\t\t}\n\t\tbreak;\n\tcase 'p':\n\t\tif (strncmp(p, \"perc\", 4) == 0) {\n\t\t\tclef = PERC;\n\t\t\tp += 4;\n\t\t}\n\t\tbreak;\n\tcase 'n':\n\t\tif (strncmp(p, \"none\", 4) == 0) {\n\t\t\tclef = TREBLE;\n\t\t\ts->u.clef.invis = 1;\n\t\t\ts->flags |= ABC_F_INVIS;\n\t\t\tp += 4;\n\t\t}\n\t\tbreak;\n\t}\n\tif (clef < 0) {\n\t\terror(1, s, \"Unknown clef '%s'\", p);\n\t\treturn;\n\t}\n\n\t/* clef line */\n\tswitch (*p) {\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\t\tclef_line = *p++ - '0';\n\t\tbreak;\n\t}\n\n\t/* +/-/^/_8 */\n\tif (p[1] == '8') {\n\t\tswitch (*p) {\n\t\tcase '^':\n\t\t\ts->u.clef.transpose = -7;\n\t\tcase '+':\n\t\t\ts->u.clef.octave = 1;\n\t\t\tbreak;\n\t\tcase '_':\n\t\t\ts->u.clef.transpose = 7;\n\t\tcase '-':\n\t\t\ts->u.clef.octave = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* handle the clef */\n\ts->abc_type = ABC_T_CLEF;\n\ts->u.clef.type = clef;\n\ts->u.clef.line = clef_line;\n\tget_clef(s);\n}\n\n/* transpose a key */\nstatic void key_transpose(struct key_s *key)\n{\n\tint t, sf;\n\n\tt = curvoice->transpose / 3;\n\tsf = (t & ~1) + (t & 1) * 7 + key->sf;\n\tswitch ((curvoice->transpose + 210) % 3) {\n\tcase 1:\n\t\tsf = (sf + 4 + 12 * 4) % 12 - 4;\t/* more sharps */\n\t\tbreak;\n\tcase 2:\n\t\tsf = (sf + 7 + 12 * 4) % 12 - 7;\t/* more flats */\n\t\tbreak;\n\tdefault:\n\t\tsf = (sf + 5 + 12 * 4) % 12 - 5;\t/* Db, F# or B */\n\t\tbreak;\n\t}\n\tkey->sf = sf;\n}\n\n/* -- set the accidentals when K: with modified accidentals -- */\nstatic void set_k_acc(struct SYMBOL *s)\n{\n\tint i, j, nacc;\n\tchar accs[8], pits[8];\n\tstatic char sharp_tb[8] = {26, 23, 27, 24, 21, 25, 22};\n\tstatic char flat_tb[8] = {22, 25, 21, 24, 20, 23, 26};\n\n\tif (s->u.key.sf > 0) {\n\t\tfor (nacc = 0; nacc < s->u.key.sf; nacc++) {\n\t\t\taccs[nacc] = A_SH;\n\t\t\tpits[nacc] = sharp_tb[nacc];\n\t\t}\n\t} else {\n\t\tfor (nacc = 0; nacc < -s->u.key.sf; nacc++) {\n\t\t\taccs[nacc] = A_FT;\n\t\t\tpits[nacc] = flat_tb[nacc];\n\t\t}\n\t}\n\tfor (i = 0; i < s->u.key.nacc; i++) {\n\t\tfor (j = 0; j < nacc; j++) {\n//\t\t\tif ((pits[j] - s->u.key.pits[i]) % 7 == 0) {\n\t\t\tif (pits[j] == s->u.key.pits[i]) {\n\t\t\t\taccs[j] = s->u.key.accs[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == nacc) {\n\t\t\tif (nacc >= sizeof accs) {\n\t\t\t\terror(1, s, \"Too many accidentals\");\n\t\t\t} else {\n\t\t\t\taccs[j] = s->u.key.accs[i];\n\t\t\t\tpits[j] = s->u.key.pits[i];\n\t\t\t\tnacc++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < nacc; i++) {\n\t\ts->u.key.accs[i] = accs[i];\n\t\ts->u.key.pits[i] = pits[i];\n\t}\n\ts->u.key.nacc = nacc;\n}\n\n/* -- get a key signature definition (K:) -- */\nstatic void get_key(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice;\n\tstruct SYMBOL *s2;\n\tstruct key_s okey;\t\t\t/* original key */\n\tint i;\n// int delta;\n\n\tif (s->u.key.octave != NO_OCTAVE)\n\t\tcurvoice->octave = s->u.key.octave;\n\tif (s->u.key.cue > 0)\n\t\tcurvoice->scale = 0.7;\n\telse if (s->u.key.cue < 0)\n\t\tcurvoice->scale = 1;\n\tif (s->u.key.stafflines)\n\t\tcurvoice->stafflines = s->u.key.stafflines;\n\tif (s->u.key.staffscale != 0)\n\t\tcurvoice->staffscale = s->u.key.staffscale;\n\n\tif (s->u.key.empty == 1)\t\t/* clef only */\n\t\treturn;\n\n\tif (s->u.key.sf != 0\n\t && !s->u.key.exp\n\t && s->u.key.nacc != 0)\n\t\tset_k_acc(s);\n\n\tmemcpy(&okey, &s->u.key, sizeof okey);\n\tif (s->state == ABC_S_HEAD) {\t\t/* if first K: (start of tune) */\n\t\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t\t     --i >= 0;\n\t\t     p_voice++)\n\t\t\tp_voice->transpose = cfmt.transpose;\n//\t\tcurvoice->transpose = cfmt.transpose;\n\t}\n\tif (curvoice->transpose != 0) {\n\t\tkey_transpose(&s->u.key);\n\n#if 0\n\t\t/* transpose explicit accidentals */\n//fixme: not correct - transpose adds or removes accidentals...\n\t\tif (s->u.key.nacc > 0) {\n\t\t\tstruct VOICE_S voice, *voice_sav;\n\t\t\tstruct SYMBOL note;\n\n\t\t\tmemset(&voice, 0, sizeof voice);\n\t\t\tvoice.transpose = curvoice->transpose;\n\t\t\tmemcpy(&voice.ckey, &s->u.key, sizeof voice.ckey);\n\t\t\tvoice.ckey.empty = 2;\n\t\t\tvoice.ckey.nacc = 0;\n\t\t\tmemset(&note, 0, sizeof note);\n--fixme\n\t\t\tmemcpy(note.u.note.pits, voice.ckey.pits,\n\t\t\t\t\tsizeof note.u.note.pits);\n\t\t\tmemcpy(note.u.note.accs, voice.ckey.accs,\n\t\t\t\t\tsizeof note.u.note.accs);\n\t\t\tnote.nhd = s->u.key.nacc;\n\t\t\tvoice_sav = curvoice;\n\t\t\tcurvoice = &voice;\n\t\t\tnote_transpose(&note);\n\t\t\tmemcpy(s->u.key.pits, note.u.note.pits,\n\t\t\t\t\tsizeof s->u.key.pits);\n\t\t\tmemcpy(s->u.key.accs, note.u.note.accs,\n\t\t\t\t\tsizeof s->u.key.accs);\n\t\t\tcurvoice = voice_sav;\n\t\t}\n#endif\n\t}\n\n\t// calculate the tonic delta\n//\ts->u.key.key_delta = (cgd2cde[(s->u.key.sf + 7) % 7] + 14 + s->u.key.mode) % 7;\n\ts->u.key.key_delta = (cgd2cde[(s->u.key.sf + 7) % 7] + 14) % 7;\n\n\tif (s->state == ABC_S_HEAD) {\t/* start of tune */\n\t\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t\t     --i >= 0;\n\t\t     p_voice++) {\n\t\t\tmemcpy(&p_voice->key, &s->u.key,\n\t\t\t\t\t\tsizeof p_voice->key);\n\t\t\tmemcpy(&p_voice->ckey, &s->u.key,\n\t\t\t\t\t\tsizeof p_voice->ckey);\n\t\t\tmemcpy(&p_voice->okey, &okey,\n\t\t\t\t\t\tsizeof p_voice->okey);\n\t\t\tif (p_voice->key.empty)\n\t\t\t\tp_voice->key.sf = 0;\n\t\t\tif (s->u.key.octave != NO_OCTAVE)\n\t\t\t\tp_voice->octave = s->u.key.octave;\n\t\t\tif (s->u.key.stafflines)\n\t\t\t\tp_voice->stafflines = s->u.key.stafflines;\n\t\t\tif (s->u.key.staffscale != 0)\n\t\t\t\tp_voice->staffscale = s->u.key.staffscale;\n//fixme: update parsys->voice[voice].stafflines = stafflines; ?\n\t\t}\n\t\treturn;\n\t}\n\n\t/* ABC_S_TUNE (K: cannot be ABC_S_GLOBAL) */\n\tif (is_tune_sig()) {\n\n\t\t/* define the starting key signature */\n\t\tmemcpy(&curvoice->key, &s->u.key,\n\t\t\t\t\tsizeof curvoice->key);\n\t\tmemcpy(&curvoice->ckey, &s->u.key,\n\t\t\t\t\tsizeof curvoice->ckey);\n\t\tmemcpy(&curvoice->okey, &okey,\n\t\t\t\t\tsizeof curvoice->okey);\n\t\tswitch (curvoice->key.instr) {\n\t\tcase 0:\n\t\t\tif (!pipeformat) {\n//\t\t\t\tcurvoice->transpose = cfmt.transpose;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//fall thru\n\t\tcase K_HP:\n\t\tcase K_Hp:\n\t\t\tif (curvoice->posit.std == 0)\n\t\t\t\tcurvoice->posit.std = SL_BELOW;\n\t\t\tbreak;\n\t\t}\n\t\tif (curvoice->key.empty)\n\t\t\tcurvoice->key.sf = 0;\n\t\treturn;\n\t}\n\n\t/* key signature change */\n\tif ((!s->abc_next\n\t  || s->abc_next->abc_type != ABC_T_CLEF)\t/* if not explicit clef */\n\t && curvoice->ckey.sf == s->u.key.sf\t/* and same key */\n\t && curvoice->ckey.nacc == 0\n\t && s->u.key.nacc == 0\n\t && curvoice->ckey.empty == s->u.key.empty\n\t && cfmt.keywarn)\t\t\t/* (if not key warning,\n\t\t\t\t\t\t *  keep all key signatures) */\n\t\treturn;\t\t\t\t/* ignore */\n\n\tif (!curvoice->ckey.empty)\n\t\ts->aux = curvoice->ckey.sf;\t/* previous key signature */\n\tmemcpy(&curvoice->ckey, &s->u.key,\n\t\t\t\tsizeof curvoice->ckey);\n\tmemcpy(&curvoice->okey, &okey,\n\t\t\t\tsizeof curvoice->okey);\n\tif (s->u.key.empty)\n\t\ts->u.key.sf = 0;\n\n\t/* the key signature must appear before a time signature */\n\ts2 = curvoice->last_sym;\n\tif (s2 && s2->type == TIMESIG) {\n\t\tcurvoice->last_sym = s2->prev;\n\t\tif (!curvoice->last_sym)\n\t\t\tcurvoice->sym = NULL;\n\t\tsym_link(s, KEYSIG);\n\t\ts->next = s2;\n\t\ts2->prev = s;\n\t\tcurvoice->last_sym = s2;\n\t} else {\n\t\tsym_link(s, KEYSIG);\n\t}\n}\n\n/* -- set meter from M: -- */\nstatic void get_meter(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice;\n\tint i;\n\n\tswitch (s->state) {\n\tcase ABC_S_GLOBAL:\n\t\t/*fixme: keep the values and apply to all tunes?? */\n\t\tbreak;\n\tcase ABC_S_HEAD:\n\t\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t\t     --i >= 0;\n\t\t     p_voice++) {\n\t\t\tmemcpy(&p_voice->meter, &s->u.meter,\n\t\t\t       sizeof p_voice->meter);\n\t\t\tp_voice->wmeasure = s->u.meter.wmeasure;\n\t\t}\n\t\tbreak;\n\tcase ABC_S_TUNE:\n\t\tcurvoice->wmeasure = s->u.meter.wmeasure;\n\t\tif (is_tune_sig()) {\n\t\t\tmemcpy(&curvoice->meter, &s->u.meter,\n\t\t\t\t       sizeof curvoice->meter);\n\t\t\treset_gen();\t/* (display the time signature) */\n\t\t\tbreak;\n\t\t}\n\t\tif (s->u.meter.nmeter == 0)\n\t\t\tbreak;\t\t/* M:none */\n\t\tsym_link(s, TIMESIG);\n\t\tbreak;\n\t}\n}\n\n/* -- treat a 'V:' -- */\nstatic void get_voice(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice;\n\tint voice;\n\n\tvoice = s->u.voice.voice;\n\tp_voice = &voice_tb[voice];\n\tif (parsys->voice[voice].range < 0) {\n\t\tif (cfmt.alignbars) {\n\t\t\terror(1, s, \"V: does not work with %%%%alignbars\");\n\t\t}\n\t\tif (staves_found < 0) {\n\t\t\tif (!s->u.voice.merge) {\n#if MAXSTAFF < MAXVOICE\n\t\t\t\tif (nstaff >= MAXSTAFF - 1) {\n\t\t\t\t\terror(1, s, \"Too many staves\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n#endif\n\t\t\t\tnstaff++;\n\t\t\t} else {\n\t\t\t\tp_voice->second = 1;\n\t\t\t\tparsys->voice[voice].second = 1;\n\t\t\t}\n\t\t\tp_voice->staff = p_voice->cstaff = nstaff;\n\t\t\tparsys->voice[voice].staff = nstaff;\n\t\t\tparsys->nstaff = nstaff;\n\t\t\t{\n\t\t\t\tint range, i;\n\n\t\t\t\trange = 0;\n\t\t\t\tfor (i = 0; i < MAXVOICE; i++) {\n\t\t\t\t\tif (parsys->voice[i].range > range)\n\t\t\t\t\t\trange = parsys->voice[i].range;\n\t\t\t\t}\n\t\t\t\tparsys->voice[voice].range = range + 1;\n\t\t\t\tvoice_link(p_voice);\n\t\t\t}\n\t\t} else {\n\t\t\tp_voice->ignore = 1;\n\t\t\tp_voice->staff = p_voice->cstaff = nstaff + 1;\n\t\t}\n\t}\n\n\t/* if something has changed, update */\n\tif (s->u.voice.fname != 0) {\n\t\tp_voice->nm = s->u.voice.fname;\n\t\tp_voice->new_name = 1;\n\t}\n\tif (s->u.voice.nname != 0)\n\t\tp_voice->snm = s->u.voice.nname;\n\tif (s->u.voice.octave != NO_OCTAVE)\n\t\tp_voice->octave = s->u.voice.octave;\n\tswitch (s->u.voice.dyn) {\n\tcase 1:\n\t\tp_voice->posit.dyn = SL_ABOVE;\n\t\tp_voice->posit.vol = SL_ABOVE;\n\t\tbreak;\n\tcase -1:\n\t\tp_voice->posit.dyn = SL_BELOW;\n\t\tp_voice->posit.vol = SL_BELOW;\n\t\tbreak;\n\t}\n\tswitch (s->u.voice.lyrics) {\n\tcase 1:\n\t\tp_voice->posit.voc = SL_ABOVE;\n\t\tbreak;\n\tcase -1:\n\t\tp_voice->posit.voc = SL_BELOW;\n\t\tbreak;\n\t}\n\tswitch (s->u.voice.gchord) {\n\tcase 1:\n\t\tp_voice->posit.gch = SL_ABOVE;\n\t\tbreak;\n\tcase -1:\n\t\tp_voice->posit.gch = SL_BELOW;\n\t\tbreak;\n\t}\n\tswitch (s->u.voice.stem) {\n\tcase 1:\n\t\tp_voice->posit.std = SL_ABOVE;\n\t\tbreak;\n\tcase -1:\n\t\tp_voice->posit.std = SL_BELOW;\n\t\tbreak;\n\tcase 2:\n\t\tp_voice->posit.std = 0;\t\t/* auto */\n\t\tbreak;\n\t}\n\tswitch (s->u.voice.gstem) {\n\tcase 1:\n\t\tp_voice->posit.gsd = SL_ABOVE;\n\t\tbreak;\n\tcase -1:\n\t\tp_voice->posit.gsd = SL_BELOW;\n\t\tbreak;\n\tcase 2:\n\t\tp_voice->posit.gsd = 0;\t\t/* auto */\n\t\tbreak;\n\t}\n\tif (s->u.voice.scale != 0)\n\t\tp_voice->scale = s->u.voice.scale;\n\telse if (s->u.voice.cue > 0)\n\t\tp_voice->scale = 0.7;\n\telse if (s->u.voice.cue < 0)\n\t\tp_voice->scale = 1;\n\tif (s->u.voice.stafflines)\n\t\tp_voice->stafflines = s->u.voice.stafflines;\n\tif (s->u.voice.staffscale != 0)\n\t\tp_voice->staffscale = s->u.voice.staffscale;\n\tif (!p_voice->combine)\n\t\tp_voice->combine = cfmt.combinevoices;\n\n\tset_tblt(p_voice);\n\n\t/* if in tune, switch to this voice */\n\tif (s->state == ABC_S_TUNE)\n\t\tcurvoice = p_voice;\n}\n\n/* sort the notes of the chord by pitch (lowest first) */\nvoid sort_pitch(struct SYMBOL *s)\n{\n\tint i, nx, k;\n\tstruct note v_note;\n\tunsigned char new_order[MAXHD], inv_order[MAXHD];\n\n\tfor (i = 0; i <= s->nhd; i++)\n\t\tnew_order[i] = i;\n\tfor (;;) {\n\t\tnx = 0;\n\t\tfor (i = 1; i <= s->nhd; i++) {\n\t\t\tif (s->u.note.notes[i].pit >= s->u.note.notes[i - 1].pit)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(&v_note, &s->u.note.notes[i],\n\t\t\t\t\tsizeof v_note);\n\t\t\tmemcpy(&s->u.note.notes[i], &s->u.note.notes[i - 1],\n\t\t\t\t\tsizeof v_note);\n\t\t\tmemcpy(&s->u.note.notes[i - 1], &v_note,\n\t\t\t\t\tsizeof v_note);\n\t\t\tk = s->pits[i];\n\t\t\ts->pits[i] = s->pits[i - 1];\n\t\t\ts->pits[i - 1] = k;\n\t\t\tk = new_order[i];\n\t\t\tnew_order[i] = new_order[i - 1];\n\t\t\tnew_order[i - 1] = k;\n\t\t\tnx++;\n\t\t}\n\t\tif (nx == 0)\n\t\t\tbreak;\n\t}\n\n\t/* change the indexes of the note head decorations */\n\tif (s->nhd > 0) {\n\t\tfor (i = 0; i <= s->nhd; i++)\n\t\t\tinv_order[new_order[i]] = i;\n\t\tfor (i = 0; i <= s->u.note.dc.n; i++) {\n\t\t\tk = s->u.note.dc.tm[i].m;\n\t\t\tif (k >= 0)\n\t\t\t\ts->u.note.dc.tm[i].m = inv_order[k];\n\t\t}\n\t}\n}\n\n// set the map of the notes\nstatic void set_map(struct SYMBOL *s)\n{\n\tstruct map *map;\n\tstruct note_map *note_map;\n\tstruct note *note;\n\tint m, delta;\n\n\tfor (map = maps; map; map = map->next) {\n\t\tif (strcmp(map->name, curvoice->map_name) == 0)\n\t\t\tbreak;\n\t}\n\tif (!map)\n\t\treturn;\t\t\t// !?\n\n\t// loop on the note maps, then on the notes of the chord\n\tdelta = curvoice->ckey.key_delta;\n\tfor (m = 0; m <= s->nhd; m++) {\n\t\tnote = &s->u.note.notes[m];\n\t\tfor (note_map = map->notes; note_map; note_map = note_map->next) {\n\t\t\tswitch (note_map->type) {\n\t\t\tcase MAP_ONE:\n\t\t\t\tif (note->pit == note_map->pit\n\t\t\t\t && note->acc == note_map->acc)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\tcase MAP_OCT:\n\t\t\t\tif ((note->pit - note_map->pit + 28 ) % 7 == 0\n\t\t\t\t && note->acc == note_map->acc)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\tcase MAP_KEY:\n\t\t\t\tif ((note->pit + 28 - delta - note_map->pit) % 7 == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\tdefault: // MAP_ALL\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnote->head = note_map->heads;\n\t\t\tnote->color = note_map->color;\n\t\t\tif (note_map->print_pit != -128) {\n\t\t\t\tnote->pit = note_map->print_pit;\n\t\t\t\ts->pits[m] = note->pit;\n\t\t\t\tnote->acc = note_map->print_acc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* -- note or rest -- */\nstatic void get_note(struct SYMBOL *s)\n{\n\tstruct SYMBOL *prev;\n\tint i, m, delta;\n\n\tprev = curvoice->last_sym;\n\tm = s->nhd;\n\n\t/* insert the note/rest in the voice */\n\tsym_link(s,  s->u.note.notes[0].len != 0 ? NOTEREST : SPACE);\n\tif (!(s->flags & ABC_F_GRACE))\n\t\tcurvoice->time += s->dur;\n\n\tif (curvoice->octave) {\n\t\tdelta = curvoice->octave * 7;\n\t\tfor (i = 0; i <= m; i++) {\n\t\t\ts->u.note.notes[i].pit += delta;\n\t\t\ts->pits[i] += delta;\n\t\t}\n\t}\n\n\t/* convert the decorations\n\t * (!beam-accel! and !beam-rall! may change the note duration)\n\t * (!8va(! may change ottava)\n\t */\n\tif (s->u.note.dc.n > 0)\n\t\tdeco_cnv(&s->u.note.dc, s, prev);\n\n\tif (curvoice->ottava) {\n\t\tdelta = curvoice->ottava;\n\t\tfor (i = 0; i <= m; i++)\n\t\t\ts->pits[i] += delta;\n\t}\n\ts->combine = curvoice->combine;\n\ts->color = curvoice->color;\n\n\tif (curvoice->perc)\n\t\ts->sflags |= S_PERC;\n\telse if (s->abc_type == ABC_T_NOTE\n\t      && curvoice->transpose != 0)\n\t\tnote_transpose(s);\n\n\tif (!(s->flags & ABC_F_GRACE)) {\n\t\tswitch (curvoice->posit.std) {\n\t\tcase SL_ABOVE: s->stem = 1; break;\n\t\tcase SL_BELOW: s->stem = -1; break;\n\t\tcase SL_HIDDEN: s->flags |= ABC_F_STEMLESS;; break;\n\t\t}\n\t} else {\t\t\t/* grace note - adjust its duration */\n\t\tint div;\n\n\t\tif (curvoice->key.instr != K_HP\n\t\t && curvoice->key.instr != K_Hp\n\t\t && !pipeformat) {\n\t\t\tdiv = 2;\n\t\t\tif (!prev\n\t\t\t || !(prev->flags & ABC_F_GRACE)) {\n\t\t\t\tif (s->flags & ABC_F_GR_END)\n\t\t\t\t\tdiv = 1;\t/* one grace note */\n\t\t\t}\n\t\t} else {\n\t\t\tdiv = 4;\t\t\t/* bagpipe */\n\t\t}\n\t\tfor (i = 0; i <= m; i++)\n\t\t\ts->u.note.notes[i].len /= div;\n\t\ts->dur /= div;\n\t\tswitch (curvoice->posit.gsd) {\n\t\tcase SL_ABOVE: s->stem = 1; break;\n\t\tcase SL_BELOW: s->stem = -1; break;\n\t\tcase SL_HIDDEN:\ts->stem = 2; break;\t/* opposite */\n\t\t}\n\t}\n\n\ts->nohdi1 = s->nohdi2 = -1;\n\n\t/* change the figure of whole measure rests */\n\tif (s->abc_type == ABC_T_REST) {\n\t\tif (s->dur == curvoice->wmeasure) {\n\t\t\tif (s->dur < BASE_LEN * 2)\n\t\t\t\ts->u.note.notes[0].len = BASE_LEN;\n\t\t\telse if (s->dur < BASE_LEN * 4)\n\t\t\t\ts->u.note.notes[0].len = BASE_LEN * 2;\n\t\t\telse\n\t\t\t\ts->u.note.notes[0].len = BASE_LEN * 4;\n\t\t}\n\t} else {\n\n\t\t/* sort the notes of the chord by pitch (lowest first) */\n\t\tif (!(s->flags & ABC_F_GRACE)\n\t\t && curvoice->map_name)\n\t\t\tset_map(s);\n\t\tsort_pitch(s);\n\t}\n\n\t/* get the max head type, number of dots and number of flags */\n\tif (!curvoice->auto_len || (s->flags & ABC_F_GRACE)) {\n\t\tint head, dots, nflags, l;\n\n\t\tif ((l = s->u.note.notes[0].len) != 0) {\n\t\t\tidentify_note(s, l, &head, &dots, &nflags);\n\t\t\ts->head = head;\n\t\t\ts->dots = dots;\n\t\t\ts->nflags = nflags;\n\t\t\tfor (i = 1; i <= m; i++) {\n\t\t\t\tif (s->u.note.notes[i].len == l)\n\t\t\t\t\tcontinue;\n\t\t\t\tidentify_note(s, s->u.note.notes[i].len,\n\t\t\t\t\t\t&head, &dots, &nflags);\n\t\t\t\tif (head > s->head)\n\t\t\t\t\ts->head = head;\n\t\t\t\tif (dots > s->dots)\n\t\t\t\t\ts->dots = dots;\n\t\t\t\tif (nflags > s->nflags)\n\t\t\t\t\ts->nflags = nflags;\n\t\t\t}\n\t\t\tif (s->sflags & S_XSTEM)\n\t\t\t\ts->nflags = 0;\t\t/* word start+end */\n\t\t}\n\t}\n\tif (s->nflags <= -2)\n\t\ts->flags |= ABC_F_STEMLESS;\n\n\tif (s->sflags & (S_TREM1 | S_TREM2)) {\n\t\tif (s->nflags > 0)\n\t\t\ts->nflags += s->aux;\n\t\telse\n\t\t\ts->nflags = s->aux;\n\t\tif ((s->sflags & S_TREM2)\n\t\t && (s->sflags & S_BEAM_END)) {\t\t/* if 2nd note - see deco.c */\n\t\t\tprev->head = s->head;\n\t\t\tprev->aux = s->aux;\n\t\t\tprev->nflags = s->nflags;\n\t\t\tprev->flags |= (s->flags & ABC_F_STEMLESS);\n\t\t}\n\t}\n\n\tfor (i = 0; i <= m; i++) {\n\t\tif (s->u.note.notes[i].sl1 != 0)\n\t\t\ts->sflags |= S_SL1;\n\t\tif (s->u.note.notes[i].sl2 != 0)\n\t\t\ts->sflags |= S_SL2;\n\t\tif (s->u.note.notes[i].ti1 != 0)\n\t\t\ts->sflags |= S_TI1;\n\t}\n\n\tswitch (cfmt.shiftunison) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\ts->sflags |= S_SHIFTUNISON_1;\n\t\tbreak;\n\tcase 2:\n\t\ts->sflags |= S_SHIFTUNISON_2;\n\t\tbreak;\n\tdefault:\n\t\ts->sflags |= S_SHIFTUNISON_1 | S_SHIFTUNISON_2;\n\t\tbreak;\n\t}\n\n\t/* build the guitar chords */\n\tif (s->text)\n\t\tgch_build(s);\n}\n\nstatic char *get_val(char *p, float *v)\n{\n\tchar tmp[32], *r = tmp;\n\n\twhile (isspace((unsigned char) *p))\n\t\tp++;\n\twhile ((isdigit((unsigned char) *p) && r < &tmp[32 - 1])\n\t    || *p == '-' || *p == '.')\n\t\t*r++ = *p++;\n\t*r = '\\0';\n\tsscanf(tmp, \"%f\", v);\n\treturn p;\n}\n\n// parse <path .../> from %%beginsvg and convert to Postscript\nstatic void parse_path(char *p, char *q, char *id, int idsz)\n{\n\tstruct SYMBOL *s;\n\tchar *buf, *r, *t, *op = NULL, *width, *scale, *trans;\n\tint i, fill, npar = 0;\n\tfloat x1, y1, x, y;\nchar *rmax;\n\n\tr = strstr(p, \"class=\\\"\");\n\tif (!r || r > q)\n\t\treturn;\n\tr += 7;\n\tfill = strncmp(r, \"fill\", 4) == 0;\n\twidth = strstr(p, \"stroke-width:\");\n\tscale = strstr(p, \"scale(\");\n\tif (scale && scale > q)\n\t\tscale = NULL;\n\ttrans = strstr(p, \"translate(\");\n\tif (trans && trans > q)\n\t\ttrans = NULL;\n\tfor (;;) {\n\t\tp = strstr(p, \"d=\\\"\");\n\t\tif (!p)\n\t\t\treturn;\n\t\tif (isspace((unsigned char) p[-1]))\t// (check not 'id=..\")\n\t\t\tbreak;\n\t\tp += 3;\n\t}\n\ti = (int) (q - p) * 4 + 200;\t\t// estimated PS buffer size\n\tif (i > TEX_BUF_SZ)\n\t\tbuf = malloc(i);\n\telse\n\t\tbuf = tex_buf;\nrmax=buf + i;\n\tr = buf;\n\t*r++ = '/';\n\tidsz -= 5;\n\tstrncpy(r, id + 4, idsz);\n\tr += idsz;\n\tstrcpy(r, \"{gsave T \");\n\tr += strlen(r);\n\tif (scale || trans) {\n\t\tif (scale) {\n\t\t\tscale += 6;\t\t// \"scale(\"\n\t\t\tt = get_val(scale, &x1);\n\t\t\tif (*t == ',')\n\t\t\t\tt = get_val(t + 1, &y1);\n\t\t\telse\n\t\t\t\ty1 = x1;\n\t\t}\n\t\tif (trans) {\n\t\t\ttrans += 10;\t\t// \"translate(\"\n\t\t\tt = get_val(trans, &x) + 1; //\",\"\n\t\t\tt = get_val(t, &y);\n\t\t}\n\t\tif (!scale)\n\t\t\tr += sprintf(r, \"%.2f %.2f T \", x, -y);\n\t\telse if (!trans)\n\t\t\tr += sprintf(r, \"%.2f %.2f scale \", x1, y1);\n\t\telse if (scale > trans)\n\t\t\tr += sprintf(r, \"%.2f %.2f T %.2f %.2f scale \",\n\t\t\t\t\tx, -y, x1, y1);\n\t\telse\n\t\t\tr += sprintf(r, \"%.2f %.2f scale %.2f %.2f T \",\n\t\t\t\t\tx1, y1, x, -y);\n\t}\n\tstrcpy(r, \"0 0 M\\n\");\n\tr += strlen(r);\n\tif (width && width < q) {\n\t\t*r++ = ' ';\n\t\twidth += 13;\n\t\twhile (isdigit(*width) || *width == '.')\n\t\t\t*r++ = *width++;\n\t\t*r++ = ' ';\n\t\t*r++ = 'S';\n\t\t*r++ = 'L';\n\t\t*r++ = 'W';\n\t}\n\tp += 3;\n\tfor (;;) {\n\t\tif (*p == '\\0' || *p == '\"')\n\t\t\tbreak;\n\t\ti = 0;\n\t\tswitch (*p++) {\n\t\tdefault:\n\t\t\tif ((isdigit((unsigned char) p[-1]))\n\t\t\t || p[-1] == '-' || p[-1] == '.') {\n\t\t\t\tif (!npar)\n\t\t\t\t\tcontinue;\n\t\t\t\tp--;\t\t\t// same op\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 'M':\n\t\t\top = \"M\";\n\t\t\tnpar = 2;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\top = \"RM\";\n\t\t\tnpar = 2;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\top = \"L\";\n\t\t\tnpar = 2;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\top = \"RL\";\n\t\t\tnpar = 2;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\top = \"H\";\n\t\t\tnpar = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\top = \"h\";\n\t\t\tnpar = 1;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\top = \"V\";\n\t\t\tnpar = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t*r++ = ' ';\n\t\t\t*r++ = '0';\n\t\t\top = \"RL\";\n\t\t\ti = 1;\n\t\t\tnpar = 2;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\top = \"closepath\";\n\t\t\tnpar = 0;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\top = \"C\";\n\t\t\tnpar = 6;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\top = \"RC\";\n\t\t\tnpar = 6;\n\t\t\tbreak;\n//\t\tcase 'A':\n//\t\t\top = \"arc\";\n//\t\t\tbreak;\n//\t\tcase 'a':\n//\t\t\top = \"arc\";\n//\t\t\tbreak;\n\t\tcase 'q':\n\t\t\top = \"RC\";\n\t\t\tnpar = 2;\n\t\t\tp = get_val(p, &x1);\n\t\t\tp = get_val(p, &y1);\n\t\t\tt = get_val(p, &x);\n\t\t\tt = get_val(t, &y);\n\t\t\tr += sprintf(r, \" %.2f %.2f %.2f %.2f\",\n\t\t\t\t\tx1*2/3, -y1*2/3,\n\t\t\t\t\tx1+(x-x1)*2/3, -y1-(y-y1)*2/3);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\top = \"RC\";\n\t\t\tnpar = 2;\n\t\t\tx1 = x - x1;\n\t\t\ty1 = y - y1;\n\t\t\tt = get_val(p, &x);\n\t\t\tt = get_val(t, &y);\n\t\t\tr += sprintf(r, \" %.2f %.2f %.2f %.2f\",\n\t\t\t\t\tx1*2/3, -y1*2/3,\n\t\t\t\t\tx1+(x-x1)*2/3, -y1-(y-y1)*2/3);\n\t\t\tbreak;\n\t\t}\n\t\t*r++ = ' ';\n\t\tfor ( ; i < npar; i++) {\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\tif (i & 1) {\t\t// y is inverted\n\t\t\t\tif (*p == '-')\n\t\t\t\t\tp++;\n\t\t\t\telse if (*p != '0' || p[1] != ' ')\n\t\t\t\t\t*r++ = '-';\n\t\t\t}\n\t\t\twhile ((isdigit((unsigned char) *p))\n\t\t\t    || *p == '-' || *p == '.')\n\t\t\t\t*r++ = *p++;\n\t\t\t*r++ = ' ';\n\t\t}\n\t\tif (*op == 'h') {\n\t\t\t*r++ = '0';\n\t\t\t*r++ = ' ';\n\t\t\top = \"RL\";\n\t\t}\n\t\tstrcpy(r, op);\n\t\tr += strlen(r);\nif (r + 30 > rmax) bug(\"Buffer overflow in SVG to PS\", 1);\n\t}\n\tstrcpy(r, fill ? \" fill\" : \" stroke\");\n\tr += strlen(r);\n\tstrcpy(r, \"\\ngrestore}!\");\n\tr += strlen(r);\n\n\ts = getarena(sizeof(struct SYMBOL));\n\tmemset(s, 0, sizeof(struct SYMBOL));\n\ts->text = getarena(strlen(buf) + 1);\n\tstrcpy(s->text, buf);\n\tps_def(s, s->text, 'p');\n\tif (buf != tex_buf)\n\t\tfree(buf);\n}\n\n// parse <defs> .. </defs> from %%beginsvg\nstatic void parse_defs(char *p, char *q)\n{\n\tchar *id, *r;\n\tint idsz;\n\n\tfor (;;) {\n\t\tid = strstr(p, \"id=\\\"\");\n\t\tif (!id || id > q)\n\t\t\treturn;\n\t\tr = strchr(id + 4, '\"');\n\t\tif (!r)\n\t\t\treturn;\n\t\tidsz = r + 1 - id;\n\n\t\t// if SVG output, mark the id as defined\n\t\tif (svg || epsf > 1) {\n\t\t\tsvg_def_id(id, idsz);\n\t\t\tp = r;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// convert SVG to PS\n\t\tp = id;\n\t\twhile (*p != '<')\n\t\t\tp--;\n\t\tif (strncmp(p, \"<path \", 6) == 0) {\n\t\t\tr = strstr(p, \"/>\");\n\t\t\tparse_path(p + 6, r, id, idsz);\n\t\t\tif (!r)\n\t\t\t\tbreak;\n\t\t\tp = r + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n// extract the SVG defs from %%beginsvg and\n//\tconvert to PostScript when PS output\n//\tmove to the SVG glyphs when SVG output\nstatic void svg_ps(char *p)\n{\n\tchar *q;\n\n\tfor (;;) {\n\t\tq = strstr(p, \"<defs>\");\n\t\tif (!q)\n\t\t\tbreak;\n\t\tp = strstr(q, \"</defs>\");\n\t\tif (!p) {\n\t\t\terror(1, NULL, \"No </defs> in %%beginsvg\");\n\t\t\tbreak;\n\t\t}\n\t\tparse_defs(q + 6, p);\n\t}\n}\n\n/* -- treat a postscript or SVG definition -- */\nstatic void ps_def(struct SYMBOL *s,\n\t\t\tchar *p,\n\t\t\tchar use)\t/* cf user_ps_add() */\n{\n\tif (!svg && epsf <= 1) {\t\t/* if PS output */\n\t\tif (secure\n//\t\t || use == 'g'\t\t// SVG\n\t\t || use == 's')\t\t// PS for SVG\n\t\t\treturn;\n\t} else {\t\t\t\t/* if SVG output */\n\t\tif (use == 'p'\t\t// PS for PS\n\t\t || (use == 'g'\t\t// SVG\n\t\t  && file_initialized > 0))\n\t\t\treturn;\n\t}\n\tif (s->abc_prev)\n\t\ts->state = s->abc_prev->state;\n\tif (s->state == ABC_S_TUNE) {\n\t\tif (use == 'g')\t\t// SVG\n\t\t\treturn;\n\t\tsym_link(s, FMTCHG);\n\t\ts->aux = PSSEQ;\n\t\ts->text = p;\n//\t\ts->flags |= ABC_F_INVIS;\n\t\treturn;\n\t}\n\tif (use == 'g') {\t\t\t// SVG\n\t\tsvg_ps(p);\n\t\tif (!svg && epsf <= 1)\n\t\t\treturn;\n\t}\n\tif (file_initialized > 0 || mbf != outbuf)\n\t\ta2b(\"%s\\n\", p);\n\telse\n\t\tuser_ps_add(p, use);\n}\n\n/* get a symbol selection */\n/* measure_number [ \":\" time_numerator \"/\" time_denominator ] */\nstatic char *get_symsel(struct symsel_s *symsel, char *p)\n{\n\tchar *q;\n\tint tn, td, n;\n\n\tsymsel->bar = strtod(p, &q);\n\tif (*q >= 'a' && *q <= 'z')\n\t\tsymsel->seq = *q++ - 'a';\n\telse\n\t\tsymsel->seq = 0;\n\tif (*q == ':') {\n\t\tif (sscanf(q + 1, \"%d/%d%n\", &tn, &td, &n) != 2\n\t\t || td <= 0)\n\t\t\treturn 0;\n\t\tsymsel->time = BASE_LEN * tn / td;\n\t\tq += 1 + n;\n\t} else {\n\t\tsymsel->time = 0;\n\t}\n\treturn q;\n}\n\n/* free the voice options */\nstatic void free_voice_opt(struct voice_opt_s *opt)\n{\n\tstruct voice_opt_s *opt2;\n\n\twhile (opt) {\n\t\topt2 = opt->next;\n\t\tfree(opt);\n\t\topt = opt2;\n\t}\n}\n\n// get a color\nstatic int get_color(char *p)\n{\n\tint i, color;\n\tstatic const struct {\n\t\tchar *name;\n\t\tint color;\n\t} col_tb[] = {\n\t\t{ \"aqua\",\t0x00ffff },\n\t\t{ \"black\",\t0x000000 },\n\t\t{ \"blue\",\t0x0000ff },\n\t\t{ \"fuchsia\",\t0xff00ff },\n\t\t{ \"gray\",\t0x808080 },\n\t\t{ \"green\",\t0x008000 },\n\t\t{ \"lime\",\t0x00ff00 },\n\t\t{ \"maroon\",\t0x800000 },\n\t\t{ \"navy\",\t0x000080 },\n\t\t{ \"olive\",\t0x808000 },\n\t\t{ \"purple\",\t0x800080 },\n\t\t{ \"red\",\t0xff0000 },\n\t\t{ \"silver\",\t0xc0c0c0 },\n\t\t{ \"teal\",\t0x008080 },\n\t\t{ \"white\",\t0xffffff },\n\t\t{ \"yellow\",\t0xffff00 },\n\t};\n\n\tif (*p == '#') {\n\t\tif (sscanf(p, \"#%06x\", &color) != 1\n\t\t || (unsigned) color > 0x00ffffff)\n\t\t\treturn -1;\n\t\treturn color;\n\t}\n\tfor (i = sizeof col_tb / sizeof col_tb[0]; --i >= 0; ) {\n\t\tif (strncasecmp(p, col_tb[i].name,\n\t\t\t\tstrlen(col_tb[i].name)) == 0)\n\t\t\tbreak;\n\t}\n\tif (i < 0)\n\t\treturn -1;\n\treturn col_tb[i].color;\n}\n/* get a transposition */\nstatic int get_transpose(char *p)\n{\n\tint val, pit1, pit2, acc;\n\tstatic int pit_st[7] = {0, 2, 4, 5, 7, 9, 11};\n\n\tif (isdigit(*p) || *p == '-' || *p == '+') {\n\t\tsscanf(p, \"%d\", &val);\n\t\tval *= 3;\n\t\tswitch (p[strlen(p) - 1]) {\n\t\tdefault:\n\t\t\treturn val;\n\t\tcase '#':\n\t\t\tval++;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tval += 2;\n\t\t\tbreak;\n\t\t}\n\t\tif (val > 0)\n\t\t\treturn val;\n\t\treturn val - 3;\n\t}\n\n\t// by music interval\n\tp = parse_acc_pit(p, &pit1, &acc);\n\tif (acc < 0) {\n\t\terror(1, NULL, \"  in %%%%transpose\");\n\t\treturn 0;\n\t}\n\tpit1 += 126 - 2;    // for value > 0 and 'C' % 7 == 0\n\tpit1 = (pit1 / 7) * 12 + pit_st[pit1 % 7];\n\tswitch (acc) {\n\tcase A_DS:\n\t\tpit1 += 2;\n\t\tbreak;\n\tcase A_SH:\n\t\tpit1++;\n\t\tbreak;\n\tcase A_FT:\n\t\tpit1--;\n\t\tbreak;\n\tcase A_DF:\n\t\tpit1 -= 2;\n\t\tbreak;\n\t}\n\tp = parse_acc_pit(p, &pit2, &acc);\n\tif (acc < 0) {\n\t\terror(1, NULL, \"  in %%%%transpose\");\n\t\treturn 0;\n\t}\n\tpit2 += 126 - 2;\n\tpit2 = (pit2 / 7) * 12 + pit_st[pit2 % 7];\n\tswitch (acc) {\n\tcase A_DS:\n\t\tpit2 += 2;\n\t\tbreak;\n\tcase A_SH:\n\t\tpit2++;\n\t\tbreak;\n\tcase A_FT:\n\t\tpit2--;\n\t\tbreak;\n\tcase A_DF:\n\t\tpit2 -= 2;\n\t\tbreak;\n\t}\n\n\tval = (pit2 - pit1) * 3;\n\tswitch (acc) {\n\tdefault:\n\t\treturn val;\n\tcase A_DS:\n\tcase A_SH:\n\t\tval++;\n\t\tbreak;\n\tcase A_FT:\n\tcase A_DF:\n\t\tval += 2;\n\t\tbreak;\n\t}\n\tif (val > 0)\n\t\treturn val;\n\treturn val - 3;\n}\n\n// create a note mapping\n// %%map map_name note [print [heads]] [param]*\nstatic void get_map(char *p)\n{\n\tstruct map *map;\n\tstruct note_map *note_map;\n\tchar *name, *q;\n\tint l, type, pit, acc;\n\n\tif (*p == '\\0')\n\t\treturn;\n\n\t/* map name */\n\tname = p;\n\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\tp++;\n\tl = p - name;\n\n\t/* base note */\n\twhile (isspace((unsigned char) *p))\n\t\tp++;\n\tif (*p == '*') {\n\t\ttype = MAP_ALL;\n\t\tp++;\n\t} else if (strncmp(p, \"octave,\", 7) == 0) {\n\t\ttype = MAP_OCT;\n\t\tp += 7;\n\t} else if (strncmp(p, \"key,\", 4) == 0) {\n\t\ttype = MAP_KEY;\n\t\tp += 4;\n\t} else if (strncmp(p, \"all\", 3) == 0) {\n\t\ttype = MAP_ALL;\n\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\tp++;\n\t} else {\n\t\ttype = MAP_ONE;\n\t}\n\tif (type != MAP_ALL) {\n\t\tp = parse_acc_pit(p, &pit, &acc);\n\t\tif (acc < 0)\t\t\t// if error\n\t\t\tpit = acc = 0;\n\t\tif (type == MAP_OCT || type == MAP_KEY) {\n\t\t\tpit %= 7;\n\t\t\tif (type == MAP_KEY)\n\t\t\t\tacc = A_NULL;\n\t\t}\n\t} else {\n\t\tpit = acc = 0;\n\t}\n\n\t// get/create the map\n\tfor (map = maps; map; map = map->next) {\n\t\tif (strncmp(name, map->name, l) == 0)\n\t\t\tbreak;\n\t}\n\tif (!map) {\n\t\tmap = getarena(sizeof *map);\n\t\tmap->next = maps;\n\t\tmaps = map;\n\t\tmap->name = getarena(l + 1);\n\t\tstrncpy(map->name, name, l);\n\t\tmap->name[l] = '\\0';\n\t\tmap->notes = NULL;\n\t}\n\tfor (note_map = map->notes; note_map; note_map = note_map->next) {\n\t\tif (note_map->type == type\n\t\t && note_map->pit == pit\n\t\t && note_map->acc == acc)\n\t\t\tbreak;\n\t}\n\tif (!note_map) {\n\t\tnote_map = getarena(sizeof *note_map);\n\t\tmemset(note_map, 0, sizeof *note_map);\n\t\tnote_map->next = map->notes;\n\t\tmap->notes = note_map;\n\t\tnote_map->type = type;\n\t\tnote_map->pit = pit;\n\t\tnote_map->acc = acc;\n\t\tnote_map->print_pit = -128;\n\t\tnote_map->color = -1;\n\t}\n\n\t/* try the optional 'print' and 'heads' parameters */\n\twhile (isspace((unsigned char) *p))\n\t\tp++;\n\tif (*p == '\\0')\n\t\treturn;\n\tq = p;\n\twhile (!isspace((unsigned char) *q) && *q != '\\0') {\n\t\tif (*q == '=')\n\t\t\tbreak;\n\t\tq++;\n\t}\n\tif (isspace((unsigned char) *q) || *q == '\\0') {\n\t\tif (*p != '*') {\n\t\t\tp = parse_acc_pit(p, &pit, &acc);\n\t\t\tif (acc >= 0) {\n\t\t\t\tnote_map->print_pit = pit;\n\t\t\t\tnote_map->print_acc = acc;\n\t\t\t}\n\t\t\tif (*p == '\\0')\n\t\t\t\treturn;\n\t\t}\n\t\tp = q;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\treturn;\n\t\tq = p;\n\t\twhile (!isspace((unsigned char) *q) && *q != '\\0') {\n\t\t\tif (*q == '=')\n\t\t\t\tbreak;\n\t\t\tq++;\n\t\t}\n\t\tif (isspace((unsigned char) *q) || *q == '\\0') {\n\t\t\tname = p;\n\t\t\tp = q;\n\t\t\tl = p - name;\n\t\t\tnote_map->heads = getarena(l + 1);\n\t\t\tstrncpy(note_map->heads, name, l);\n\t\t\tnote_map->heads[l] = '\\0';\n\t\t}\n\t}\n\n\t/* loop on the parameters */\n\tfor (;;) {\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tif (strncmp(p, \"heads=\", 6) == 0) {\n\t\t\tp += 6;\n\t\t\tname = p;\n\t\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\t\tp++;\n\t\t\tl = p - name;\n\t\t\tnote_map->heads = getarena(l + 1);\n\t\t\tstrncpy(note_map->heads, name, l);\n\t\t\tnote_map->heads[l] = '\\0';\n\t\t} else if (strncmp(p, \"print=\", 6) == 0) {\n\t\t\tp += 6;\n\t\t\tp = parse_acc_pit(p, &pit, &acc);\n\t\t\tif (acc >= 0) {\n\t\t\t\tnote_map->print_pit = pit;\n\t\t\t\tnote_map->print_acc = acc;\n\t\t\t}\n\t\t} else if (strncmp(p, \"color=\", 6) == 0) {\n\t\t\tint color;\n\n\t\t\tcolor = get_color(p + 6);\n\t\t\tif (color < 0) {\n\t\t\t\terror(1, NULL, \"Bad color in %%%%map\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnote_map->color = color;\n\t\t}\n\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\tp++;\n\t}\n}\n\n/* -- process a pseudo-comment (%% or I:) -- */\nstatic struct SYMBOL *process_pscomment(struct SYMBOL *s)\n{\n\tchar w[32], *p, *q;\n\tint voice;\n\tfloat h1;\n\tint lock = 0;\n\n\tp = s->text + 2;\t\t/* skip '%%' */\n\tq = p + strlen(p) - 5;\n\tif (q > p\n\t && strncmp(q, \" lock\", 5) == 0) {\n\t\tlock = 1;\n\t\t*q = '\\0';\n\t}\n\tp = get_str(w, p, sizeof w);\n\tif (s->state == ABC_S_HEAD\n\t && !check_header(s)) {\n\t\terror(1, s, \"Cannot have %%%%%s in tune header\", w);\n\t\treturn s;\n\t}\n\tswitch (w[0]) {\n\tcase 'b':\n\t\tif (strcmp(w, \"beginps\") == 0\n\t\t || strcmp(w, \"beginsvg\") == 0) {\n\t\t\tchar use;\n\n\t\t\tif (w[5] == 'p') {\n\t\t\t\tif (strncmp(p, \"svg\", 3) == 0)\n\t\t\t\t\tuse = 's';\n\t\t\t\telse if (strncmp(p, \"nosvg\", 5) == 0)\n\t\t\t\t\tuse = 'p';\n\t\t\t\telse\n\t\t\t\t\tuse = 'b';\n\t\t\t} else {\n\t\t\t\tuse = 'g';\n\t\t\t}\n\t\t\tp = s->text + 2 + 7;\n\t\t\twhile (*p != '\\0' && *p != '\\n')\n\t\t\t\tp++;\n\t\t\tif (*p == '\\0')\n\t\t\t\treturn s;\t\t/* empty */\n\t\t\tps_def(s, p + 1, use);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"begintext\") == 0) {\n\t\t\tint job;\n\n\t\t\tif (s->state == ABC_S_TUNE) {\n\t\t\t\tif (!multicol_start)\n\t\t\t\t\tgen_ly(1);\n\t\t\t} else if (s->state == ABC_S_GLOBAL) {\n\t\t\t\tif (epsf || !in_fname)\n\t\t\t\t\treturn s;\n\t\t\t}\n\t\t\tp = s->text + 2 + 9;\n\t\t\twhile (*p == ' ' || *p == '\\t')\n\t\t\t\tp++;\n\t\t\tif (*p != '\\n') {\n\t\t\t\tjob = get_textopt(p);\n\t\t\t\twhile (*p != '\\0' && *p != '\\n')\n\t\t\t\t\tp++;\n\t\t\t\tif (*p == '\\0')\n\t\t\t\t\treturn s;\t/* empty */\n\t\t\t} else {\n\t\t\t\tjob = cfmt.textoption;\n\t\t\t}\n\t\t\tif (job != T_SKIP) {\n\t\t\t\tp++;\n\t\t\t\twrite_text(w, p, job);\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"break\") == 0) {\n\t\t\tstruct brk_s *brk;\n\n\t\t\tif (s->state != ABC_S_HEAD) {\n\t\t\t\terror(1, s, \"%%%%%s ignored\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (*p == '\\0')\n\t\t\t\treturn s;\n\t\t\tfor (;;) {\n\t\t\t\tbrk = malloc(sizeof *brk);\n\t\t\t\tp = get_symsel(&brk->symsel, p);\n\t\t\t\tif (!p) {\n\t\t\t\t\terror(1, s, \"Bad selection in %%%%%s\", w);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\tbrk->next = brks;\n\t\t\t\tbrks = brk;\n\t\t\t\tif (*p != ',' && *p != ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'c':\n\t\tif (strcmp(w, \"center\") == 0)\n\t\t\tgoto center;\n\t\tif (strcmp(w, \"clef\") == 0) {\n\t\t\tif (s->state != ABC_S_GLOBAL)\n\t\t\t\tclef_def(s);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"clip\") == 0) {\n\t\t\tif (!cur_tune_opts) {\n\t\t\t\terror(1, s, \"%%%%%s not in %%%%tune sequence\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\t/* %%clip <symbol selection> \"-\" <symbol selection> */\n\t\t\tif (*p != '-') {\n\t\t\t\tp = get_symsel(&clip_start, p);\n\t\t\t\tif (!p) {\n\t\t\t\t\terror(1, s, \"Bad start in %%%%%s\", w);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\tif (*p != '-') {\n\t\t\t\t\terror(1, s, \"Lack of '-' in %%%%%s\", w);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t\tp = get_symsel(&clip_end, p);\n\t\t\tif (!p) {\n\t\t\t\terror(1, s, \"Bad end in %%%%%s\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (clip_start.bar < 0)\n\t\t\t\tclip_start.bar = 0;\n\t\t\tif (clip_end.bar < clip_start.bar\n\t\t\t || (clip_end.bar == clip_start.bar\n\t\t\t  && clip_end.time <= clip_start.time)) {\n\t\t\t\tclip_end.bar = (short unsigned) ~0 >> 1;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'd':\n\t\tif (strcmp(w, \"deco\") == 0) {\n\t\t\tdeco_add(p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"dynamic\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'E':\n\t\tif (strcmp(w, \"EPS\") == 0) {\n\t\t\tfloat x1, y1, x2, y2;\n\t\t\tFILE *fp;\n\t\t\tchar fn[STRL1], line[STRL1];\n\n\t\t\tgen_ly(1);\n\t\t\tif (secure\n\t\t\t || cfmt.textoption == T_SKIP)\n\t\t\t\treturn s;\n\t\t\tget_str(line, p, sizeof line);\n\t\t\tif ((fp = open_file(line, \"eps\", fn)) == NULL) {\n\t\t\t\terror(1, s, \"No such file: %s\", line);\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\t/* get the bounding box */\n\t\t\tx1 = x2 = 0;\n\t\t\twhile (fgets(line, sizeof line, fp)) {\n\t\t\t\tif (strncmp(line, \"%%BoundingBox:\", 14) == 0) {\n\t\t\t\t\tif (sscanf(&line[14], \"%f %f %f %f\",\n\t\t\t\t\t\t   &x1, &y1, &x2, &y2) == 4)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\tif (x1 == x2) {\n\t\t\t\terror(1, s, \"No bounding box in '%s'\", fn);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (cfmt.textoption == T_CENTER\n\t\t\t || cfmt.textoption == T_RIGHT) {\n\t\t\t\tfloat lw;\n\n\t\t\t\tlw = ((cfmt.landscape ? cfmt.pageheight : cfmt.pagewidth)\n\t\t\t\t\t- cfmt.leftmargin - cfmt.rightmargin) / cfmt.scale;\n\t\t\t\tif (cfmt.textoption == T_CENTER)\n\t\t\t\t\tx1 += (lw - (x2 - x1)) * 0.5;\n\t\t\t\telse\n\t\t\t\t\tx1 += lw - (x2 - x1);\n\t\t\t}\n\t\t\ta2b(\"\\001\");\t/* include file (must be the first after eob) */\n\t\t\tbskip(y2 - y1);\n\t\t\ta2b(\"%.2f %.2f%%%s\\n\", x1, -y1, fn);\n\t\t\tbuffer_eob(0);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'g':\n\t\tif (strcmp(w, \"gchord\") == 0\n\t\t || strcmp(w, \"gstemdir\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"glyph\") == 0) {\n\t\t\tif (!svg && epsf <= 1)\n\t\t\t\tglyph_add(p);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'm':\n\t\tif (strcmp(w, \"map\") == 0) {\n\t\t\tget_map(p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"maxsysstaffsep\") == 0) {\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\tbreak;\n\t\t\tparsys->voice[curvoice - voice_tb].maxsep = scan_u(p, 0);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"multicol\") == 0) {\n\t\t\tfloat bposy;\n\n\t\t\tgenerate();\n\t\t\tif (strncmp(p, \"start\", 5) == 0) {\n\t\t\t\tif (!in_page)\n\t\t\t\t\ta2b(\"%%\\n\");\t/* initialize the output */\n\t\t\t\tbuffer_eob(0);\n\t\t\t\tbposy = get_bposy();\n\t\t\t\tmulticol_max = multicol_start = bposy;\n\t\t\t\tlmarg = cfmt.leftmargin;\n\t\t\t\trmarg = cfmt.rightmargin;\n\t\t\t} else if (strncmp(p, \"new\", 3) == 0) {\n\t\t\t\tif (multicol_start == 0) {\n\t\t\t\t\terror(1, s,\n\t\t\t\t\t      \"%%%%%s new without start\", w);\n\t\t\t\t} else {\n\t\t\t\t\tbuffer_eob(0);\n\t\t\t\t\tbposy = get_bposy();\n\t\t\t\t\tif (bposy < multicol_start)\n\t\t\t\t\t\tbskip((bposy - multicol_start)\n\t\t\t\t\t\t\t\t/ cfmt.scale);\n\t\t\t\t\tif (bposy < multicol_max)\n\t\t\t\t\t\tmulticol_max = bposy;\n\t\t\t\t\tcfmt.leftmargin = lmarg;\n\t\t\t\t\tcfmt.rightmargin = rmarg;\n\t\t\t\t}\n\t\t\t} else if (strncmp(p, \"end\", 3) == 0) {\n\t\t\t\tif (multicol_start == 0) {\n\t\t\t\t\terror(1, s,\n\t\t\t\t\t      \"%%%%%s end without start\", w);\n\t\t\t\t} else {\n\t\t\t\t\tbuffer_eob(0);\n\t\t\t\t\tbposy = get_bposy();\n\t\t\t\t\tif (bposy > multicol_max)\n\t\t\t\t\t\tbskip((bposy - multicol_max)\n\t\t\t\t\t\t\t\t/ cfmt.scale);\n\t\t\t\t\telse\n\t\t\t\t\t\ta2b(\"%%\\n\");\t/* force write_buffer */\n\t\t\t\t\tcfmt.leftmargin = lmarg;\n\t\t\t\t\tcfmt.rightmargin = rmarg;\n\t\t\t\t\tmulticol_start = 0;\n\t\t\t\t\tbuffer_eob(0);\n\t\t\t\t\tif (!info['X' - 'A']\n\t\t\t\t\t && !epsf)\n\t\t\t\t\t\twrite_buffer();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror(1, s,\n\t\t\t\t      \"Unknown keyword '%s' in %%%%%s\", p, w);\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'M':\n\t\tif (strcmp(w, \"MIDI\") == 0\n\t\t && strncmp(p, \"temperamentequal\", 16) == 0) {\n\t\t\tint n;\n\n\t\t\tif (cfmt.nedo) {\n\t\t\t\terror(1, s, \"%%%%MIDI temperamentequal redefined\");\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tp += 16;\n\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\tp++;\n\t\t\tn = atoi(p);\n\t\t\tif (n < 7 || n > 53) {\n\t\t\t\terror(1, s, \"Bad value in %%%%MIDI temperamentequal\");\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tcfmt.nedo = n;\n\t\t}\n\t\tbreak;\n\tcase 'n':\n\t\tif (strcmp(w, \"newpage\") == 0) {\n\t\t\tif (epsf || !in_fname)\n\t\t\t\treturn s;\n\t\t\tif (s->state == ABC_S_TUNE)\n\t\t\t\tgenerate();\n\t\t\tbuffer_eob(0);\n\t\t\twrite_buffer();\n//\t\t\tuse_buffer = 0;\n\t\t\tif (isdigit((unsigned char) *p))\n\t\t\t\tpagenum = atoi(p);\n\t\t\tclose_page();\n\t\t\tif (s->state == ABC_S_TUNE)\n\t\t\t\tbskip(cfmt.topspace);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'p':\n\t\tif (strcmp(w, \"pos\") == 0) {\t// %%pos <type> <position>\n\t\t\tp = get_str(w, p, sizeof w);\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"ps\") == 0\n\t\t || strcmp(w, \"postscript\") == 0) {\n\t\t\tps_def(s, p, 'b');\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'o':\n\t\tif (strcmp(w, \"ornament\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'r':\n\t\tif (strcmp(w, \"repbra\") == 0) {\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\treturn s;\n\t\t\tcurvoice->norepbra = strchr(\"0FfNn\", *p)\n\t\t\t\t\t\t|| *p == '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"repeat\") == 0) {\n\t\t\tint n, k;\n\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\treturn s;\n\t\t\tif (!curvoice->last_sym) {\n\t\t\t\terror(1, s,\n\t\t\t\t      \"%%%s cannot start a tune\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (*p == '\\0') {\n\t\t\t\tn = 1;\n\t\t\t\tk = 1;\n\t\t\t} else {\n\t\t\t\tn = atoi(p);\n\t\t\t\tif (n < 1\n\t\t\t\t || (curvoice->last_sym->type == BAR\n\t\t\t\t\t&& n > 2)) {\n\t\t\t\t\terror(1, s,\n\t\t\t\t\t      \"Incorrect 1st value in %%%%%s\", w);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\twhile (*p != '\\0' && !isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\tk = 1;\n\t\t\t\t} else {\n\t\t\t\t\tk = atoi(p);\n\t\t\t\t\tif (k < 1) {\n//\t\t\t\t\t || (curvoice->last_sym->type == BAR\n//\t\t\t\t\t  && n == 2\n//\t\t\t\t\t  && k > 1)) {\n\t\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t      \"Incorrect 2nd value in %%%%%s\", w);\n\t\t\t\t\t\treturn s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts->aux = REPEAT;\n\t\t\tif (curvoice->last_sym->type == BAR)\n\t\t\t\ts->doty = n;\n\t\t\telse\n\t\t\t\ts->doty = -n;\n\t\t\tsym_link(s, FMTCHG);\n\t\t\ts->nohdi1 = k;\n\t\t\ts->text = NULL;\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\tif (strcmp(w, \"setbarnb\") == 0) {\n\t\t\tif (s->state == ABC_S_TUNE) {\n\t\t\t\tstruct SYMBOL *s2;\n\t\t\t\tint n;\n\n\t\t\t\tn = atoi(p);\n\t\t\t\tfor (s2 = s->abc_next; s2; s2 = s2->abc_next) {\n\t\t\t\t\tif (s2->abc_type == ABC_T_BAR) {\n\t\t\t\t\t\ts2->aux = n;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tstrcpy(w, \"measurefirst\");\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(w, \"sep\") == 0) {\n\t\t\tfloat h2, len, lwidth;\n\n\t\t\tif (s->state == ABC_S_TUNE) {\n\t\t\t\tgen_ly(0);\n\t\t\t} else if (s->state == ABC_S_GLOBAL) {\n\t\t\t\tif (epsf || !in_fname)\n\t\t\t\t\treturn s;\n\t\t\t}\n\t\t\tlwidth = (cfmt.landscape ? cfmt.pageheight : cfmt.pagewidth)\n\t\t\t\t- cfmt.leftmargin - cfmt.rightmargin;\n\t\t\th1 = h2 = len = 0;\n\t\t\tif (*p != '\\0') {\n\t\t\t\th1 = scan_u(p, 0);\n\t\t\t\twhile (*p != '\\0' && !isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (*p != '\\0') {\n\t\t\t\th2 = scan_u(p, 0);\n\t\t\t\twhile (*p != '\\0' && !isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (*p != '\\0')\n\t\t\t\tlen = scan_u(p, 0);\n\t\t\tif (h1 < 1)\n\t\t\t\th1 = 0.5 CM;\n\t\t\tif (h2 < 1)\n\t\t\t\th2 = h1;\n\t\t\tif (len < 1)\n\t\t\t\tlen = 3.0 CM;\n\t\t\tbskip(h1);\n\t\t\ta2b(\"%.1f %.1f sep0\\n\",\n\t\t\t     len / cfmt.scale,\n\t\t\t     (lwidth - len) * 0.5 / cfmt.scale);\n\t\t\tbskip(h2);\n\t\t\tbuffer_eob(0);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"staff\") == 0) {\n\t\t\tint staff;\n\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\treturn s;\n\t\t\tif (*p == '+')\n\t\t\t\tstaff = curvoice->cstaff + atoi(p + 1);\n\t\t\telse if (*p == '-')\n\t\t\t\tstaff = curvoice->cstaff - atoi(p + 1);\n\t\t\telse\n\t\t\t\tstaff = atoi(p) - 1;\n\t\t\tif ((unsigned) staff > (unsigned) nstaff) {\n\t\t\t\terror(1, s, \"Bad staff in %%%%%s\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tcurvoice->floating = 0;\n\t\t\tcurvoice->cstaff = staff;\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"staffbreak\") == 0) {\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\treturn s;\n\t\t\tif (isdigit(*p)) {\n\t\t\t\ts->xmx = scan_u(p, 0);\n\t\t\t\tif (s->xmx < 0) {\n\t\t\t\t\terror(1, s, \"Bad value in %%%%%s\", w);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\tif (p[strlen(p) - 1] == 'f')\n\t\t\t\t\ts->doty = 1;\n\t\t\t} else {\n\t\t\t\ts->xmx = 0.5 CM;\n\t\t\t\tif (*p == 'f')\n\t\t\t\t\ts->doty = 1;\n\t\t\t}\n\t\t\tsym_link(s, STBRK);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"stafflines\") == 0) {\n\t\t\tif (isdigit((unsigned char) *p)) {\n\t\t\t\tswitch (atoi(p)) {\n\t\t\t\tcase 0: p = \"...\"; break;\n\t\t\t\tcase 1: p = \"..|\"; break;\n\t\t\t\tcase 2: p = \".||\"; break;\n\t\t\t\tcase 3: p = \".|||\"; break;\n\t\t\t\tcase 4: p = \"||||\"; break;\n\t\t\t\tcase 5: p = \"|||||\"; break;\n\t\t\t\tcase 6: p = \"||||||\"; break;\n\t\t\t\tcase 7: p = \"|||||||\"; break;\n\t\t\t\tcase 8: p = \"||||||||\"; break;\n\t\t\t\tdefault:\n\t\t\t\t\terror(1, s, \"Bad number of lines\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint l;\n\n\t\t\t\tl = strlen(p);\n\t\t\t\tq = p;\n\t\t\t\tp = getarena(l + 1);\n\t\t\t\tstrcpy(p, q);\n\t\t\t}\n\t\t\tif (s->state != ABC_S_TUNE) {\n\t\t\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\t\t\tvoice_tb[voice].stafflines = p;\n\t\t\t} else {\n\t\t\t\tcurvoice->stafflines = p;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"staffscale\") == 0) {\n\t\t\tchar *q;\n\t\t\tfloat scale;\n\n\t\t\tscale = strtod(p, &q);\n\t\t\tif (scale < 0.3 || scale > 2\n\t\t\t || (*q != '\\0' && *q != ' ')) {\n\t\t\t\terror(1, s, \"Bad value in %%%%%s\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (s->state != ABC_S_TUNE) {\n\t\t\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\t\t\tvoice_tb[voice].staffscale = scale;\n\t\t\t} else {\n\t\t\t\tcurvoice->staffscale = scale;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"staves\") == 0\n\t\t || strcmp(w, \"score\") == 0) {\n\t\t\tif (s->state == ABC_S_GLOBAL)\n\t\t\t\treturn s;\n\t\t\tget_staves(s);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"stemdir\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"sysstaffsep\") == 0) {\n\t\t\tif (s->state != ABC_S_TUNE)\n\t\t\t\tbreak;\n\t\t\tparsys->voice[curvoice - voice_tb].sep = scan_u(p, 0);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 't':\n\t\tif (strcmp(w, \"text\") == 0) {\n\t\t\tint job;\n\ncenter:\n\t\t\tif (s->state == ABC_S_TUNE) {\n\t\t\t\tgen_ly(1);\n\t\t\t} else if (s->state == ABC_S_GLOBAL) {\n\t\t\t\tif (epsf || !in_fname)\n\t\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (w[0] == 'c') {\n\t\t\t\tjob = T_CENTER;\n\t\t\t} else {\n\t\t\t\tjob = cfmt.textoption;\n\t\t\t\tswitch(job) {\n\t\t\t\tcase T_SKIP:\n\t\t\t\t\treturn s;\n\t\t\t\tcase T_LEFT:\n\t\t\t\tcase T_RIGHT:\n\t\t\t\tcase T_CENTER:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tjob = T_LEFT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_text(w, p, job);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"tablature\") == 0) {\n\t\t\tstruct tblt_s *tblt;\n\t\t\tint i, j;\n\n\t\t\ttblt = tblt_parse(p);\n\t\t\tif (tblt == 0)\n\t\t\t\treturn s;\n\n\t\t\tswitch (s->state) {\n\t\t\tcase ABC_S_TUNE:\n\t\t\tcase ABC_S_HEAD:\n\t\t\t\tfor (i = 0; i < ncmdtblt; i++) {\n\t\t\t\t\tif (cmdtblts[i].active)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tj = cmdtblts[i].index;\n\t\t\t\t\tif (j < 0 || tblts[j] == tblt)\n\t\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\t/* !! 2 tblts per voice !! */\n\t\t\t\tif (curvoice->tblts[0] == tblt\n\t\t\t\t || curvoice->tblts[1] == tblt)\n\t\t\t\t\tbreak;\n\t\t\t\tif (curvoice->tblts[1]) {\n\t\t\t\t\terror(1, s,\n\t\t\t\t\t\t\"Too many tablatures for voice %s\",\n\t\t\t\t\t\tcurvoice->id);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!curvoice->tblts[0])\n\t\t\t\t\tcurvoice->tblts[0] = tblt;\n\t\t\t\telse\n\t\t\t\t\tcurvoice->tblts[1] = tblt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"transpose\") == 0) {\n\t\t\tstruct VOICE_S *p_voice;\n\t\t\tstruct SYMBOL *s2;\n\t\t\tint i, val;\n\n\t\t\tval = get_transpose(p);\n\t\t\tswitch (s->state) {\n\t\t\tcase ABC_S_GLOBAL:\n\t\t\t\tcfmt.transpose = val;\n\t\t\t\treturn s;\n\t\t\tcase ABC_S_HEAD: {\n\t\t\t\tcfmt.transpose += val;\n\t\t\t\tfor (i = MAXVOICE, p_voice = voice_tb;\n\t\t\t\t     --i >= 0;\n\t\t\t\t     p_voice++) {\n\t\t\t\t\tp_voice->transpose = cfmt.transpose;\n\t\t\t\t\tmemcpy(&p_voice->key, &p_voice->okey,\n\t\t\t\t\t\tsizeof p_voice->key);\n\t\t\t\t\tkey_transpose(&p_voice->key);\n\t\t\t\t\tmemcpy(&p_voice->ckey, &p_voice->key,\n\t\t\t\t\t\tsizeof p_voice->ckey);\n\t\t\t\t\tif (p_voice->key.empty)\n\t\t\t\t\t\tp_voice->key.sf = 0;\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t    }\n\t\t\t}\n\t\t\tcurvoice->transpose = cfmt.transpose + val;\n\t\t\ts2 = curvoice->sym;\n\t\t\tif (!s2) {\n\t\t\t\tmemcpy(&curvoice->key, &curvoice->okey,\n\t\t\t\t\tsizeof curvoice->key);\n\t\t\t\tkey_transpose(&curvoice->key);\n\t\t\t\tmemcpy(&curvoice->ckey, &curvoice->key,\n\t\t\t\t\tsizeof curvoice->ckey);\n\t\t\t\tif (curvoice->key.empty)\n\t\t\t\t\tcurvoice->key.sf = 0;\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tfor (;;) {\n\t\t\t\tif (s2->type == KEYSIG)\n\t\t\t\t\tbreak;\n\t\t\t\tif (s2->time == curvoice->time) {\n\t\t\t\t\ts2 = s2->prev;\n\t\t\t\t\tif (s2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts2 = s;\n\t\t\t\ts2->abc_type = ABC_T_INFO;\n\t\t\t\ts2->text = (char *) getarena(2);\n\t\t\t\ts2->text[0] = 'K';\n\t\t\t\ts2->text[1] = '\\0';\n\t\t\t\tsym_link(s2, KEYSIG);\n//\t\t\t\tif (!curvoice->ckey.empty)\n//\t\t\t\t\ts2->aux = curvoice->ckey.sf;\n\t\t\t\ts2->aux = curvoice->key.sf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(&s2->u.key, &curvoice->okey,\n\t\t\t\t\t\tsizeof s2->u.key);\n\t\t\tkey_transpose(&s2->u.key);\n\t\t\tmemcpy(&curvoice->ckey, &s2->u.key,\n\t\t\t\t\t\tsizeof curvoice->ckey);\n\t\t\tif (curvoice->key.empty)\n\t\t\t\ts2->u.key.sf = 0;\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"tune\") == 0) {\n\t\t\tstruct SYMBOL *s2, *s3;\n\t\t\tstruct tune_opt_s *opt, *opt2;\n\n\t\t\tif (s->state != ABC_S_GLOBAL) {\n\t\t\t\terror(1, s, \"%%%%%s ignored\", w);\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\t/* if void %%tune, remove all tune options */\n\t\t\tif (*p == '\\0') {\n\t\t\t\topt = tune_opts;\n\t\t\t\twhile (opt) {\n\t\t\t\t\tfree_voice_opt(opt->voice_opts);\n\t\t\t\t\topt2 = opt->next;\n\t\t\t\t\tfree(opt);\n\t\t\t\t\topt = opt2;\n\t\t\t\t}\n\t\t\t\ttune_opts = NULL;\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\tif (strcmp(p, \"end\") == 0)\n\t\t\t\treturn s;\t/* end of previous %%tune */\n\n\t\t\t/* search the end of the tune options */\n\t\t\ts2 = s;\n\t\t\tfor (;;) {\n\t\t\t\ts3 = s2->abc_next;\n\t\t\t\tif (!s3)\n\t\t\t\t\tbreak;\n\t\t\t\tif (s3->abc_type != ABC_T_NULL\n\t\t\t\t && (s3->abc_type != ABC_T_PSCOM\n\t\t\t\t  || strncmp(&s3->text[2], \"tune \", 5) == 0))\n\t\t\t\t\tbreak;\n\t\t\t\ts2 = s3;\n\t\t\t}\n\n\t\t\t/* search if already a same %%tune */\n\t\t\topt2 = NULL;\n\t\t\tfor (opt = tune_opts; opt; opt = opt->next) {\n\t\t\t\tif (strcmp(opt->s->text, s->text) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\topt2 = opt;\n\t\t\t}\n\n\t\t\tif (opt) {\n\t\t\t\tfree_voice_opt(opt->voice_opts);\n\t\t\t\tif (s2 == s) {\t\t\t/* no option */\n\t\t\t\t\tif (!opt2)\n\t\t\t\t\t\ttune_opts = opt->next;\n\t\t\t\t\telse\n\t\t\t\t\t\topt2->next = opt->next;\n\t\t\t\t\tfree(opt);\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\topt->voice_opts = NULL;\n\t\t\t} else {\n\t\t\t\tif (s2 == s)\t\t\t/* no option */\n\t\t\t\t\treturn s;\n\t\t\t\topt = malloc(sizeof *opt);\n\t\t\t\tmemset(opt, 0, sizeof *opt);\n\t\t\t\topt->next = tune_opts;\n\t\t\t\ttune_opts = opt;\n\t\t\t}\n\n\t\t\t/* link the options */\n\t\t\topt->s = s3 = s;\n\t\t\tcur_tune_opts = opt;\n\t\t\ts = s->abc_next;\n\t\t\tfor (;;) {\n\t\t\t\tif (s->abc_type != ABC_T_PSCOM)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (strncmp(&s->text[2], \"voice \", 6) == 0) {\n\t\t\t\t\ts = process_pscomment(s);\n\t\t\t\t} else {\n\t\t\t\t\ts->state = ABC_S_HEAD;\n\n\t\t\t\t\t/* !! no reverse link !! */\n\t\t\t\t\ts3->next = s;\n\t\t\t\t\ts3 = s;\n\t\t\t\t}\n\t\t\t\tif (s == s2)\n\t\t\t\t\tbreak;\n\t\t\t\ts = s->abc_next;\n\t\t\t}\n\t\t\tcur_tune_opts = NULL;\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'u':\n\t\tif (strcmp(w, \"user\") == 0) {\n\t\t\tdeco[s->u.user.symbol] = parse.deco_tb[s->u.user.value - 128];\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\tcase 'v':\n\t\tif (strcmp(w, \"vocal\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"voice\") == 0) {\n\t\t\tstruct SYMBOL *s2, *s3;\n\t\t\tstruct voice_opt_s *opt, *opt2;\n\n\t\t\tif (s->state != ABC_S_GLOBAL) {\n\t\t\t\terror(1, s, \"%%%%voice ignored\");\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\t/* if void %%voice, free all voice options */\n\t\t\tif (*p == '\\0') {\n\t\t\t\tif (cur_tune_opts) {\n\t\t\t\t\tfree_voice_opt(cur_tune_opts->voice_opts);\n\t\t\t\t\tcur_tune_opts->voice_opts = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tfree_voice_opt(voice_opts);\n\t\t\t\t\tvoice_opts = NULL;\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\tif (strcmp(p, \"end\") == 0)\n\t\t\t\treturn s;\t/* end of previous %%voice */\n\n\t\t\tif (cur_tune_opts)\n\t\t\t\topt = cur_tune_opts->voice_opts;\n\t\t\telse\n\t\t\t\topt = voice_opts;\n\n\t\t\t/* search the end of the voice options */\n\t\t\ts2 = s;\n\t\t\tfor (;;) {\n\t\t\t\ts3 = s2->abc_next;\n\t\t\t\tif (!s3)\n\t\t\t\t\tbreak;\n\t\t\t\tif (s3->abc_type != ABC_T_NULL\n\t\t\t\t && (s3->abc_type != ABC_T_PSCOM\n\t\t\t\t  || strncmp(&s3->text[2], \"score \", 6) == 0\n\t\t\t\t  || strncmp(&s3->text[2], \"staves \", 7) == 0\n\t\t\t\t  || strncmp(&s3->text[2], \"tune \", 5) == 0\n\t\t\t\t  || strncmp(&s3->text[2], \"voice \", 6) == 0))\n\t\t\t\t\tbreak;\n\t\t\t\ts2 = s3;\n\t\t\t}\n\n\t\t\t/* if already the same %%voice\n\t\t\t * remove the options */\n\t\t\topt2 = NULL;\n\t\t\tfor ( ; opt; opt = opt->next) {\n\t\t\t\tif (strcmp(opt->s->text, s->text) == 0) {\n\t\t\t\t\tif (!opt2) {\n\t\t\t\t\t\tif (cur_tune_opts)\n\t\t\t\t\t\t\tcur_tune_opts->voice_opts = NULL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tvoice_opts = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\topt2->next = opt->next;\n\t\t\t\t\t}\n\t\t\t\t\tfree(opt);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topt2 = opt;\n\t\t\t}\n\t\t\tif (s2 == s)\t\t/* no option */\n\t\t\t\treturn s;\n\t\t\topt = malloc(sizeof *opt + strlen(p));\n\t\t\tmemset(opt, 0, sizeof *opt);\n\t\t\tif (cur_tune_opts) {\n\t\t\t\topt->next = cur_tune_opts->voice_opts;\n\t\t\t\tcur_tune_opts->voice_opts = opt;\n\t\t\t} else {\n\t\t\t\topt->next = voice_opts;\n\t\t\t\tvoice_opts = opt;\n\t\t\t}\n\n\t\t\t/* link the options */\n\t\t\topt->s = s3 = s;\n\t\t\tfor ( ; s != s2; s = s->abc_next) {\n\t\t\t\tif (s->abc_next->abc_type != ABC_T_PSCOM)\n\t\t\t\t\tcontinue;\n\t\t\t\ts->abc_next->state = ABC_S_TUNE;\n\t\t\t\ts3->next = s->abc_next;\n\t\t\t\ts3 = s3->next;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"voicecolor\") == 0) {\n\t\t\tint color;\n\n\t\t\tif (!curvoice)\n\t\t\t\treturn s;\n\n\t\t\tcolor = get_color(p);\n\t\t\tif (color < 0)\n\t\t\t\terror(1, s, \"Bad color in %%%%voicecolor\");\n\t\t\telse\n\t\t\t\tcurvoice->color = color;\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"voicecombine\") == 0) {\n\t\t\tint combine;\n\n\t\t\tif (sscanf(p, \"%d\", &combine) != 1) {\n\t\t\t\terror(1, s, \"Bad value in %%%%voicecombine\");\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tswitch (s->state) {\n\t\t\tcase ABC_S_GLOBAL:\n\t\t\t\tcfmt.combinevoices = combine;\n\t\t\t\tbreak;\n\t\t\tcase ABC_S_HEAD:\n\t\t\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\t\t\tvoice_tb[voice].combine = combine;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcurvoice->combine = combine;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"voicemap\") == 0) {\n\t\t\tif (s->state != ABC_S_TUNE) {\n\t\t\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\t\t\tvoice_tb[voice].map_name = p;\n\t\t\t} else {\n\t\t\t\tcurvoice->map_name = p;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"voicescale\") == 0) {\n\t\t\tchar *q;\n\t\t\tfloat scale;\n\n\t\t\tscale = strtod(p, &q);\n\t\t\tif (scale < 0.6 || scale > 1.5\n\t\t\t || (*q != '\\0' && *q != ' ')) {\n\t\t\t\terror(1, s, \"Bad %%%%voicescale value\");\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (s->state != ABC_S_TUNE) {\n\t\t\t\tfor (voice = 0; voice < MAXVOICE; voice++)\n\t\t\t\t\tvoice_tb[voice].scale = scale;\n\t\t\t} else {\n\t\t\t\tcurvoice->scale = scale;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"volume\") == 0) {\n\t\t\tset_voice_param(curvoice, s->state, w, p);\n\t\t\treturn s;\n\t\t}\n\t\tif (strcmp(w, \"vskip\") == 0) {\n\t\t\tif (s->state == ABC_S_TUNE) {\n\t\t\t\tgen_ly(0);\n\t\t\t} else if (s->state == ABC_S_GLOBAL) {\n\t\t\t\tif (epsf || !in_fname)\n\t\t\t\t\treturn s;\n\t\t\t}\n\t\t\tbskip(scan_u(p, 0));\n\t\t\tbuffer_eob(0);\n\t\t\treturn s;\n\t\t}\n\t\tbreak;\n\t}\n\tif (s->state == ABC_S_TUNE) {\n\t\tif (strcmp(w, \"leftmargin\") == 0\n\t\t || strcmp(w, \"rightmargin\") == 0\n\t\t || strcmp(w, \"scale\") == 0) {\n\t\t\tgenerate();\n\t\t\tblock_put();\n\t\t}\n\t}\n\tinterpret_fmt_line(w, p, lock);\n\tif (cfmt.alignbars && strcmp(w, \"alignbars\") == 0) {\n\t\tint i;\n\n\t\tgenerate();\n\t\tif ((unsigned) cfmt.alignbars > MAXSTAFF) {\n\t\t\terror(1, s, \"Too big value in %%%%alignbars\");\n\t\t\tcfmt.alignbars = MAXSTAFF;\n\t\t}\n\t\tif (staves_found >= 0)\t\t/* (compatibility) */\n\t\t\tcfmt.alignbars = nstaff + 1;\n\t\tfirst_voice = curvoice = voice_tb;\n\t\tfor (i = 0; i < cfmt.alignbars; i++) {\n\t\t\tvoice_tb[i].staff = voice_tb[i].cstaff = i;\n\t\t\tvoice_tb[i].next = &voice_tb[i + 1];\n\t\t\tparsys->staff[i].flags |= STOP_BAR;\n\t\t\tparsys->voice[i].staff = i;\n\t\t\tparsys->voice[i].range = i;\n\t\t}\n\t\ti--;\n\t\tvoice_tb[i].next = NULL;\n\t\tparsys->nstaff = nstaff = i;\n\t}\n\treturn s;\n}\n\n/* -- set the duration of notes/rests in a tuplet -- */\n/*fixme: KO if voice change*/\n/*fixme: KO if in a grace sequence*/\nstatic void set_tuplet(struct SYMBOL *t)\n{\n\tstruct SYMBOL *s, *s1;\n\tint l, r, lplet, grace;\n\n\tr = t->u.tuplet.r_plet;\n\tgrace = t->flags & ABC_F_GRACE;\n\n\tl = 0;\n\tfor (s = t->abc_next; s; s = s->abc_next) {\n\t\tif (s->abc_type == ABC_T_TUPLET) {\n\t\t\tstruct SYMBOL *s2;\n\t\t\tint l2, r2;\n\n\t\t\tr2 = s->u.tuplet.r_plet;\n\t\t\tl2 = 0;\n\t\t\tfor (s2 = s->abc_next; s2; s2 = s2->abc_next) {\n\t\t\t\tswitch (s2->abc_type) {\n\t\t\t\tcase ABC_T_NOTE:\n\t\t\t\tcase ABC_T_REST:\n\t\t\t\t\tbreak;\n\t\t\t\tcase ABC_T_EOLN:\n\t\t\t\t\tif (s2->u.eoln.type != 1) {\n\t\t\t\t\t\terror(1, t,\n\t\t\t\t\t\t\t\"End of line found inside a nested tuplet\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s2->u.note.notes[0].len == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (grace ^ (s2->flags & ABC_F_GRACE))\n\t\t\t\t\tcontinue;\n\t\t\t\ts1 = s2;\n\t\t\t\tl2 += s1->dur;\n\t\t\t\tif (--r2 <= 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl2 = l2 * s->u.tuplet.q_plet / s->u.tuplet.p_plet;\n\t\t\ts->aux = l2;\n\t\t\tl += l2;\n\t\t\tr -= s->u.tuplet.r_plet;\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tif (r < 0) {\n\t\t\t\terror(1, t, \"Bad nested tuplet\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = s2;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (s->abc_type) {\n\t\tcase ABC_T_NOTE:\n\t\tcase ABC_T_REST:\n\t\t\tbreak;\n\t\tcase ABC_T_EOLN:\n\t\t\tif (s->u.eoln.type != 1) {\n\t\t\t\terror(1, t, \"End of line found inside a tuplet\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (s->u.note.notes[0].len == 0)\t/* space ('y') */\n\t\t\tcontinue;\n\t\tif (grace ^ (s->flags & ABC_F_GRACE))\n\t\t\tcontinue;\n\t\ts1 = s;\n\t\tl += s->dur;\n\t\tif (--r <= 0)\n\t\t\tbreak;\n\t}\n\tif (!s) {\n\t\terror(1, t, \"End of tune found inside a tuplet\");\n\t\treturn;\n\t}\n\tif (t->aux != 0)\t\t/* if nested tuplet */\n\t\tlplet = t->aux;\n\telse\n\t\tlplet = (l * t->u.tuplet.q_plet) / t->u.tuplet.p_plet;\n\tr = t->u.tuplet.r_plet;\n\tfor (s = t->abc_next; s; s = s->abc_next) {\n\t\tint olddur;\n\n\t\tif (s->abc_type == ABC_T_TUPLET) {\n\t\t\tint r2;\n\n\t\t\tr2 = s->u.tuplet.r_plet;\n\t\t\ts1 = s;\n\t\t\tolddur = s->aux;\n\t\t\ts1->aux = (olddur * lplet) / l;\n\t\t\tl -= olddur;\n\t\t\tlplet -= s1->aux;\n\t\t\tr -= r2;\n\t\t\tfor (;;) {\n\t\t\t\ts = s->abc_next;\n\t\t\t\tif (s->abc_type != ABC_T_NOTE\n\t\t\t\t && s->abc_type != ABC_T_REST)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (s->u.note.notes[0].len == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (grace ^ (s->flags & ABC_F_GRACE))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (--r2 <= 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (r <= 0)\n\t\t\t\tgoto done;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s->abc_type != ABC_T_NOTE && s->abc_type != ABC_T_REST)\n\t\t\tcontinue;\n\t\tif (s->u.note.notes[0].len == 0)\n\t\t\tcontinue;\n\t\ts->sflags |= S_IN_TUPLET;\n\t\tif (grace ^ (s->flags & ABC_F_GRACE))\n\t\t\tcontinue;\n\t\ts1 = s;\n\t\tolddur = s->dur;\n\t\ts1->dur = (olddur * lplet) / l;\n\t\tif (--r <= 0)\n\t\t\tbreak;\n\t\tl -= olddur;\n\t\tlplet -= s1->dur;\n\t}\ndone:\n\tif (grace) {\n\t\terror(1, t, \"Tuplets in grace note sequence not yet treated\");\n\t} else {\n\t\tsym_link(t, TUPLET);\n\t\tt->aux = cfmt.tuplets;\n\t}\n}\n"], "filenames": ["parse.c"], "buggy_code_start_loc": [2014], "buggy_code_end_loc": [2017], "fixing_code_start_loc": [2014], "fixing_code_end_loc": [2022], "type": "CWE-125", "message": "abcm2ps v8.14.11 was discovered to contain an out-of-bounds read in the function calculate_beam at draw.c.", "other": {"cve": {"id": "CVE-2021-32434", "sourceIdentifier": "cve@mitre.org", "published": "2022-03-10T17:42:14.277", "lastModified": "2022-04-25T20:48:18.513", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "abcm2ps v8.14.11 was discovered to contain an out-of-bounds read in the function calculate_beam at draw.c."}, {"lang": "es", "value": "Se ha detectado que abcm2ps versi\u00f3n v8.14.11, contiene una lectura fuera de l\u00edmites en la funci\u00f3n calculate_beam en el archivo draw.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:abcm2ps_project:abcm2ps:8.14.11:*:*:*:*:*:*:*", "matchCriteriaId": "F1915B5A-15EE-4267-9DBE-0827CA3F709E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/leesavide/abcm2ps/commit/2f56e1179cab6affeb8afa9d6c324008fe40d8e3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/leesavide/abcm2ps/issues/83", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/04/msg00015.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6333SXWMES3K22DBAOAW34G6EU6WIJEY/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EVGJH4HMXI3TWMHQJQCG3M7KSXJWJM7R/", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YTF4FXCW22FFB5HNQO3GK3F4FFBLTZKE/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/leesavide/abcm2ps/commit/2f56e1179cab6affeb8afa9d6c324008fe40d8e3"}}