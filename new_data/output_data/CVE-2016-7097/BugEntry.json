{"buggy_code": ["/*\n * Copyright IBM Corporation, 2010\n * Author Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of version 2.1 of the GNU Lesser General Public License\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it would be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *\n */\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"v9fs.h\"\n#include \"v9fs_vfs.h\"\n#include \"fid.h\"\n\nstatic struct posix_acl *__v9fs_get_acl(struct p9_fid *fid, char *name)\n{\n\tssize_t size;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl = NULL;\n\n\tsize = v9fs_fid_xattr_get(fid, name, NULL, 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = v9fs_fid_xattr_get(fid, name, value, size);\n\t\tif (size > 0) {\n\t\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\t\tif (IS_ERR(acl))\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else if (size == -ENODATA || size == 0 ||\n\t\t   size == -ENOSYS || size == -EOPNOTSUPP) {\n\t\tacl = NULL;\n\t} else\n\t\tacl = ERR_PTR(-EIO);\n\nerr_out:\n\tkfree(value);\n\treturn acl;\n}\n\nint v9fs_get_acl(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *pacl, *dacl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, NULL);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, NULL);\n\t\treturn 0;\n\t}\n\t/* get the default/access acl values and cache them */\n\tdacl = __v9fs_get_acl(fid, XATTR_NAME_POSIX_ACL_DEFAULT);\n\tpacl = __v9fs_get_acl(fid, XATTR_NAME_POSIX_ACL_ACCESS);\n\n\tif (!IS_ERR(dacl) && !IS_ERR(pacl)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, pacl);\n\t} else\n\t\tretval = -EIO;\n\n\tif (!IS_ERR(dacl))\n\t\tposix_acl_release(dacl);\n\n\tif (!IS_ERR(pacl))\n\t\tposix_acl_release(pacl);\n\n\treturn retval;\n}\n\nstatic struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(is_uncached_acl(acl));\n\treturn acl;\n}\n\nstruct posix_acl *v9fs_iop_get_acl(struct inode *inode, int type)\n{\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\t/*\n\t\t * On access = client  and acl = on mode get the acl\n\t\t * values from the server\n\t\t */\n\t\treturn NULL;\n\t}\n\treturn v9fs_get_cached_acl(inode, type);\n\n}\n\nstatic int v9fs_set_acl(struct p9_fid *fid, int type, struct posix_acl *acl)\n{\n\tint retval;\n\tchar *name;\n\tsize_t size;\n\tvoid *buffer;\n\tif (!acl)\n\t\treturn 0;\n\n\t/* Set a setxattr request to server */\n\tsize = posix_acl_xattr_size(acl->a_count);\n\tbuffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tretval = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tif (retval < 0)\n\t\tgoto err_free_out;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_fid_xattr_set(fid, name, buffer, size, 0);\nerr_free_out:\n\tkfree(buffer);\n\treturn retval;\n}\n\nint v9fs_acl_chmod(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *acl;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tacl = v9fs_get_cached_acl(inode, ACL_TYPE_ACCESS);\n\tif (acl) {\n\t\tretval = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\tretval = v9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn retval;\n}\n\nint v9fs_set_create_acl(struct inode *inode, struct p9_fid *fid,\n\t\t\tstruct posix_acl *dacl, struct posix_acl *acl)\n{\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\tv9fs_set_acl(fid, ACL_TYPE_DEFAULT, dacl);\n\tv9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\treturn 0;\n}\n\nvoid v9fs_put_acl(struct posix_acl *dacl,\n\t\t  struct posix_acl *acl)\n{\n\tposix_acl_release(dacl);\n\tposix_acl_release(acl);\n}\n\nint v9fs_acl_mode(struct inode *dir, umode_t *modep,\n\t\t  struct posix_acl **dpacl, struct posix_acl **pacl)\n{\n\tint retval = 0;\n\tumode_t mode = *modep;\n\tstruct posix_acl *acl = NULL;\n\n\tif (!S_ISLNK(mode)) {\n\t\tacl = v9fs_get_cached_acl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\tif (!acl)\n\t\t\tmode &= ~current_umask();\n\t}\n\tif (acl) {\n\t\tif (S_ISDIR(mode))\n\t\t\t*dpacl = posix_acl_dup(acl);\n\t\tretval = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval > 0)\n\t\t\t*pacl = acl;\n\t\telse\n\t\t\tposix_acl_release(acl);\n\t}\n\t*modep  = mode;\n\treturn 0;\n}\n\nstatic int v9fs_xattr_get_acl(const struct xattr_handler *handler,\n\t\t\t      struct dentry *dentry, struct inode *inode,\n\t\t\t      const char *name, void *buffer, size_t size)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct posix_acl *acl;\n\tint error;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\t/*\n\t * We allow set/get/list of acl when access=client is not specified\n\t */\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)\n\t\treturn v9fs_xattr_get(dentry, handler->name, buffer, size);\n\n\tacl = v9fs_get_cached_acl(inode, handler->flags);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\terror = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}\n\nstatic int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n\t\t\t      struct dentry *dentry, struct inode *inode,\n\t\t\t      const char *name, const void *value,\n\t\t\t      size_t size, int flags)\n{\n\tint retval;\n\tstruct posix_acl *acl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\t/*\n\t * set the attribute on the remote. Without even looking at the\n\t * xattr value. We leave it to the server to validate\n\t */\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)\n\t\treturn v9fs_xattr_set(dentry, handler->name, value, size,\n\t\t\t\t      flags);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\tif (value) {\n\t\t/* update the cached acl value */\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\telse if (acl) {\n\t\t\tretval = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else\n\t\tacl = NULL;\n\n\tswitch (handler->flags) {\n\tcase ACL_TYPE_ACCESS:\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err_out;\n\t\t\telse {\n\t\t\t\tstruct iattr iattr;\n\t\t\t\tif (retval == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * ACL can be represented\n\t\t\t\t\t * by the mode bits. So don't\n\t\t\t\t\t * update ACL.\n\t\t\t\t\t */\n\t\t\t\t\tacl = NULL;\n\t\t\t\t\tvalue = NULL;\n\t\t\t\t\tsize = 0;\n\t\t\t\t}\n\t\t\t\t/* Updte the mode bits */\n\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n\t\t\t\tiattr.ia_valid = ATTR_MODE;\n\t\t\t\t/* FIXME should we update ctime ?\n\t\t\t\t * What is the following setxattr update the\n\t\t\t\t * mode ?\n\t\t\t\t */\n\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tretval = acl ? -EINVAL : 0;\n\t\t\tgoto err_out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_xattr_set(dentry, handler->name, value, size, flags);\n\tif (!retval)\n\t\tset_cached_acl(inode, handler->flags, acl);\nerr_out:\n\tposix_acl_release(acl);\n\treturn retval;\n}\n\nconst struct xattr_handler v9fs_xattr_acl_access_handler = {\n\t.name\t= XATTR_NAME_POSIX_ACL_ACCESS,\n\t.flags\t= ACL_TYPE_ACCESS,\n\t.get\t= v9fs_xattr_get_acl,\n\t.set\t= v9fs_xattr_set_acl,\n};\n\nconst struct xattr_handler v9fs_xattr_acl_default_handler = {\n\t.name\t= XATTR_NAME_POSIX_ACL_DEFAULT,\n\t.flags\t= ACL_TYPE_DEFAULT,\n\t.get\t= v9fs_xattr_get_acl,\n\t.set\t= v9fs_xattr_set_acl,\n};\n", "/*\n * Copyright (C) 2007 Red Hat.  All rights reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License v2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 021110-1307, USA.\n */\n\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include \"ctree.h\"\n#include \"btrfs_inode.h\"\n#include \"xattr.h\"\n\nstruct posix_acl *btrfs_get_acl(struct inode *inode, int type)\n{\n\tint size;\n\tconst char *name;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = __btrfs_getxattr(inode, name, \"\", 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __btrfs_getxattr(inode, name, value, size);\n\t}\n\tif (size > 0) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t} else if (size == -ERANGE || size == -ENODATA || size == 0) {\n\t\tacl = NULL;\n\t} else {\n\t\tacl = ERR_PTR(-EIO);\n\t}\n\tkfree(value);\n\n\treturn acl;\n}\n\n/*\n * Needs to be called with fs_mutex held\n */\nstatic int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn ret;\n}\n\nint btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn __btrfs_set_acl(NULL, inode, acl, type);\n}\n\n/*\n * btrfs_init_acl is already generally called under fs_mutex, so the locking\n * stuff has been fixed to work with that.  If the locking stuff changes, we\n * need to re-evaluate the acl locking stuff.\n */\nint btrfs_init_acl(struct btrfs_trans_handle *trans,\n\t\t   struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint ret = 0;\n\n\t/* this happens with subvols */\n\tif (!dir)\n\t\treturn 0;\n\n\tret = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (default_acl) {\n\t\tret = __btrfs_set_acl(trans, inode, default_acl,\n\t\t\t\t      ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!ret)\n\t\t\tret = __btrfs_set_acl(trans, inode, acl,\n\t\t\t\t\t      ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (!default_acl && !acl)\n\t\tcache_no_acl(inode);\n\treturn ret;\n}\n", "/*\n * linux/fs/ceph/acl.c\n *\n * Copyright (C) 2013 Guangliang Zhao, <lucienchao@gmail.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License v2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 021110-1307, USA.\n */\n\n#include <linux/ceph/ceph_debug.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include \"super.h\"\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\telse\n\t\tforget_cached_acl(inode, type);\n\tspin_unlock(&ci->i_ceph_lock);\n}\n\nstruct posix_acl *ceph_get_acl(struct inode *inode, int type)\n{\n\tint size;\n\tconst char *name;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = __ceph_getxattr(inode, name, \"\", 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __ceph_getxattr(inode, name, value, size);\n\t}\n\n\tif (size > 0)\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\telse if (size == -ERANGE || size == -ENODATA || size == 0)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(-EIO);\n\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tceph_set_cached_acl(inode, type, acl);\n\n\treturn acl;\n}\n\nint ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = __ceph_setattr(inode, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tret = __ceph_setxattr(inode, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\t__ceph_setattr(inode, &newattrs);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tceph_set_cached_acl(inode, type, acl);\n\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}\n\nint ceph_pre_init_acls(struct inode *dir, umode_t *mode,\n\t\t       struct ceph_acls_info *info)\n{\n\tstruct posix_acl *acl, *default_acl;\n\tsize_t val_size1 = 0, val_size2 = 0;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tvoid *tmp_buf = NULL;\n\tint err;\n\n\terr = posix_acl_create(dir, mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (acl) {\n\t\tint ret = posix_acl_equiv_mode(acl, mode);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t\tif (ret == 0) {\n\t\t\tposix_acl_release(acl);\n\t\t\tacl = NULL;\n\t\t}\n\t}\n\n\tif (!default_acl && !acl)\n\t\treturn 0;\n\n\tif (acl)\n\t\tval_size1 = posix_acl_xattr_size(acl->a_count);\n\tif (default_acl)\n\t\tval_size2 = posix_acl_xattr_size(default_acl->a_count);\n\n\terr = -ENOMEM;\n\ttmp_buf = kmalloc(max(val_size1, val_size2), GFP_KERNEL);\n\tif (!tmp_buf)\n\t\tgoto out_err;\n\tpagelist = kmalloc(sizeof(struct ceph_pagelist), GFP_KERNEL);\n\tif (!pagelist)\n\t\tgoto out_err;\n\tceph_pagelist_init(pagelist);\n\n\terr = ceph_pagelist_reserve(pagelist, PAGE_SIZE);\n\tif (err)\n\t\tgoto out_err;\n\n\tceph_pagelist_encode_32(pagelist, acl && default_acl ? 2 : 1);\n\n\tif (acl) {\n\t\tsize_t len = strlen(XATTR_NAME_POSIX_ACL_ACCESS);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size1 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_string(pagelist, XATTR_NAME_POSIX_ACL_ACCESS,\n\t\t\t\t\t    len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl,\n\t\t\t\t\t tmp_buf, val_size1);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size1);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size1);\n\t}\n\tif (default_acl) {\n\t\tsize_t len = strlen(XATTR_NAME_POSIX_ACL_DEFAULT);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size2 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\terr = ceph_pagelist_encode_string(pagelist,\n\t\t\t\t\t\t  XATTR_NAME_POSIX_ACL_DEFAULT, len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, default_acl,\n\t\t\t\t\t tmp_buf, val_size2);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size2);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size2);\n\t}\n\n\tkfree(tmp_buf);\n\n\tinfo->acl = acl;\n\tinfo->default_acl = default_acl;\n\tinfo->pagelist = pagelist;\n\treturn 0;\n\nout_err:\n\tposix_acl_release(acl);\n\tposix_acl_release(default_acl);\n\tkfree(tmp_buf);\n\tif (pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}\n\nvoid ceph_init_inode_acls(struct inode* inode, struct ceph_acls_info *info)\n{\n\tif (!inode)\n\t\treturn;\n\tceph_set_cached_acl(inode, ACL_TYPE_ACCESS, info->acl);\n\tceph_set_cached_acl(inode, ACL_TYPE_DEFAULT, info->default_acl);\n}\n\nvoid ceph_release_acls_info(struct ceph_acls_info *info)\n{\n\tposix_acl_release(info->acl);\n\tposix_acl_release(info->default_acl);\n\tif (info->pagelist)\n\t\tceph_pagelist_release(info->pagelist);\n}\n", "/*\n * linux/fs/ext2/acl.c\n *\n * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>\n */\n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n/*\n * Convert from filesystem to in-memory representation.\n */\nstatic struct posix_acl *\next2_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(ext2_acl_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (((ext2_acl_header *)value)->a_version !=\n\t    cpu_to_le32(EXT2_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(ext2_acl_header);\n\tcount = ext2_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n=0; n < count; n++) {\n\t\text2_acl_entry *entry =\n\t\t\t(ext2_acl_entry *)value;\n\t\tif ((char *)value + sizeof(ext2_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tvalue = (char *)value +\n\t\t\t\t\tsizeof(ext2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tvalue = (char *)value + sizeof(ext2_acl_entry);\n\t\t\t\tif ((char *)value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tvalue = (char *)value + sizeof(ext2_acl_entry);\n\t\t\t\tif ((char *)value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * Convert from in-memory to filesystem representation.\n */\nstatic void *\next2_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\text2_acl_header *ext_acl;\n\tchar *e;\n\tsize_t n;\n\n\t*size = ext2_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(ext2_acl_header) + acl->a_count *\n\t\t\tsizeof(ext2_acl_entry), GFP_KERNEL);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(EXT2_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(ext2_acl_header);\n\tfor (n=0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text2_acl_entry *entry = (ext2_acl_entry *)e;\n\t\tentry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER:\n\t\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\t\te += sizeof(ext2_acl_entry);\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\t\te += sizeof(ext2_acl_entry);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\te += sizeof(ext2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * inode->i_mutex: don't care\n */\nstruct posix_acl *\next2_get_acl(struct inode *inode, int type)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = ext2_xattr_get(inode, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ext2_xattr_get(inode, name_index, \"\", value, retval);\n\t}\n\tif (retval > 0)\n\t\tacl = ext2_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA || retval == -ENOSYS)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\treturn acl;\n}\n\n/*\n * inode->i_mutex: down\n */\nint\next2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\t\tif (acl) {\n\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\t\tif (error < 0)\n\t\t\t\t\treturn error;\n\t\t\t\telse {\n\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\t\tif (error == 0)\n\t\t\t\t\t\tacl = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\treturn acl ? -EACCES : 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n \tif (acl) {\n\t\tvalue = ext2_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n\n/*\n * Initialize the ACLs of a new inode. Called from ext2_new_inode.\n *\n * dir->i_mutex: down\n * inode->i_mutex: up (access to inode is still exclusive)\n */\nint\next2_init_acl(struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = ext2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = ext2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\treturn error;\n}\n", "/*\n * linux/fs/ext4/acl.c\n *\n * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>\n */\n\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n/*\n * Convert from filesystem to in-memory representation.\n */\nstatic struct posix_acl *\next4_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(ext4_acl_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (((ext4_acl_header *)value)->a_version !=\n\t    cpu_to_le32(EXT4_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(ext4_acl_header);\n\tcount = ext4_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\text4_acl_entry *entry =\n\t\t\t(ext4_acl_entry *)value;\n\t\tif ((char *)value + sizeof(ext4_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t\tsizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * Convert from in-memory to filesystem representation.\n */\nstatic void *\next4_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\text4_acl_header *ext_acl;\n\tchar *e;\n\tsize_t n;\n\n\t*size = ext4_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(ext4_acl_header) + acl->a_count *\n\t\t\tsizeof(ext4_acl_entry), GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(EXT4_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(ext4_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text4_acl_entry *entry = (ext4_acl_entry *)e;\n\t\tentry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * Inode operation get_posix_acl().\n *\n * inode->i_mutex: don't care\n */\nstruct posix_acl *\next4_get_acl(struct inode *inode, int type)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = ext4_xattr_get(inode, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ext4_xattr_get(inode, name_index, \"\", value, retval);\n\t}\n\tif (retval > 0)\n\t\tacl = ext4_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA || retval == -ENOSYS)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\treturn acl;\n}\n\n/*\n * Set the access or default ACL of an inode.\n *\n * inode->i_mutex: down unless called from ext4_new_inode\n */\nstatic int\n__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}\n\nint\next4_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\thandle_t *handle;\n\tint error, retries = 0;\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_XATTR,\n\t\t\t\t    ext4_jbd2_credits_xattr(inode));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terror = __ext4_set_acl(handle, inode, type, acl);\n\text4_journal_stop(handle);\n\tif (error == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\treturn error;\n}\n\n/*\n * Initialize the ACLs of a new inode. Called from ext4_new_inode.\n *\n * dir->i_mutex: down\n * inode->i_mutex: up (access to inode is still exclusive)\n */\nint\next4_init_acl(handle_t *handle, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __ext4_set_acl(handle, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t       default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __ext4_set_acl(handle, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t       acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn error;\n}\n", "/*\n * fs/f2fs/acl.c\n *\n * Copyright (c) 2012 Samsung Electronics Co., Ltd.\n *             http://www.samsung.com/\n *\n * Portions of this code from linux/fs/ext2/acl.c\n *\n * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n#include <linux/f2fs_fs.h>\n#include \"f2fs.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstatic inline size_t f2fs_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\tcount * sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\t4 * sizeof(struct f2fs_acl_entry_short) +\n\t\t\t(count - 4) * sizeof(struct f2fs_acl_entry);\n\t}\n}\n\nstatic inline int f2fs_acl_count(size_t size)\n{\n\tssize_t s;\n\tsize -= sizeof(struct f2fs_acl_header);\n\ts = size - 4 * sizeof(struct f2fs_acl_entry_short);\n\tif (s < 0) {\n\t\tif (size % sizeof(struct f2fs_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\tif (s % sizeof(struct f2fs_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(struct f2fs_acl_entry) + 4;\n\t}\n}\n\nstatic struct posix_acl *f2fs_acl_from_disk(const char *value, size_t size)\n{\n\tint i, count;\n\tstruct posix_acl *acl;\n\tstruct f2fs_acl_header *hdr = (struct f2fs_acl_header *)value;\n\tstruct f2fs_acl_entry *entry = (struct f2fs_acl_entry *)(hdr + 1);\n\tconst char *end = value + size;\n\n\tif (hdr->a_version != cpu_to_le32(F2FS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = f2fs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\n\t\tif ((char *)entry > end)\n\t\t\tgoto fail;\n\n\t\tacl->a_entries[i].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[i].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[i].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[i].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif ((char *)entry != end)\n\t\tgoto fail;\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void *f2fs_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\tstruct f2fs_acl_header *f2fs_acl;\n\tstruct f2fs_acl_entry *entry;\n\tint i;\n\n\tf2fs_acl = f2fs_kmalloc(sizeof(struct f2fs_acl_header) + acl->a_count *\n\t\t\tsizeof(struct f2fs_acl_entry), GFP_NOFS);\n\tif (!f2fs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_acl->a_version = cpu_to_le32(F2FS_ACL_VERSION);\n\tentry = (struct f2fs_acl_entry *)(f2fs_acl + 1);\n\n\tfor (i = 0; i < acl->a_count; i++) {\n\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[i].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[i].e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_uid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_gid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*size = f2fs_acl_size(acl->a_count);\n\treturn (void *)f2fs_acl;\n\nfail:\n\tkfree(f2fs_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct posix_acl *__f2fs_get_acl(struct inode *inode, int type,\n\t\t\t\t\t\tstruct page *dpage)\n{\n\tint name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tif (type == ACL_TYPE_ACCESS)\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\n\tretval = f2fs_getxattr(inode, name_index, \"\", NULL, 0, dpage);\n\tif (retval > 0) {\n\t\tvalue = f2fs_kmalloc(retval, GFP_F2FS_ZERO);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = f2fs_getxattr(inode, name_index, \"\", value,\n\t\t\t\t\t\t\tretval, dpage);\n\t}\n\n\tif (retval > 0)\n\t\tacl = f2fs_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\treturn acl;\n}\n\nstruct posix_acl *f2fs_get_acl(struct inode *inode, int type)\n{\n\treturn __f2fs_get_acl(inode, type, NULL);\n}\n\nstatic int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\tclear_inode_flag(inode, FI_ACL_MODE);\n\treturn error;\n}\n\nint f2fs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn __f2fs_set_acl(inode, type, acl, NULL);\n}\n\n/*\n * Most part of f2fs_acl_clone, f2fs_acl_create_masq, f2fs_acl_create\n * are copied from posix_acl.c\n */\nstatic struct posix_acl *f2fs_acl_clone(const struct posix_acl *acl,\n\t\t\t\t\t\t\tgfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t\t\tsizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\tatomic_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}\n\nstatic int f2fs_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tgroup_obj = pa;\n\t\t\tbreak;\n\n\t\tcase ACL_OTHER:\n\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n\t\t\tbreak;\n\n\t\tcase ACL_MASK:\n\t\t\tmask_obj = pa;\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\n\nstatic int f2fs_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl,\n\t\tstruct page *dpage)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = __f2fs_get_acl(dir, ACL_TYPE_DEFAULT, dpage);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tclone = f2fs_acl_clone(p, GFP_NOFS);\n\tif (!clone)\n\t\tgoto no_mem;\n\n\tret = f2fs_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(clone);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}\n\nint f2fs_init_acl(struct inode *inode, struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tstruct page *dpage)\n{\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tint error = 0;\n\n\terror = f2fs_acl_create(dir, &inode->i_mode, &default_acl, &acl, dpage);\n\tif (error)\n\t\treturn error;\n\n\tf2fs_mark_inode_dirty_sync(inode);\n\n\tif (default_acl) {\n\t\terror = __f2fs_set_acl(inode, ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       ipage);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __f2fs_set_acl(inode, ACL_TYPE_ACCESS, acl,\n\t\t\t\t\t       ipage);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn error;\n}\n", "/*\n * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.\n * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.\n *\n * This copyrighted material is made available to anyone wishing to use,\n * modify, copy, or redistribute it subject to the terms and conditions\n * of the GNU General Public License version 2.\n */\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"glock.h\"\n#include \"inode.h\"\n#include \"meta_io.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"util.h\"\n\nstatic const char *gfs2_acl_name(int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn XATTR_POSIX_ACL_ACCESS;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn XATTR_POSIX_ACL_DEFAULT;\n\t}\n\treturn NULL;\n}\n\nstatic struct posix_acl *__gfs2_get_acl(struct inode *inode, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct posix_acl *acl;\n\tconst char *name;\n\tchar *data;\n\tint len;\n\n\tif (!ip->i_eattr)\n\t\treturn NULL;\n\n\tname = gfs2_acl_name(type);\n\tlen = gfs2_xattr_acl_get(ip, name, &data);\n\tif (len <= 0)\n\t\treturn ERR_PTR(len);\n\tacl = posix_acl_from_xattr(&init_user_ns, data, len);\n\tkfree(data);\n\treturn acl;\n}\n\nstruct posix_acl *gfs2_get_acl(struct inode *inode, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tbool need_unlock = false;\n\tstruct posix_acl *acl;\n\n\tif (!gfs2_glock_is_locked_by_me(ip->i_gl)) {\n\t\tint ret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t     LM_FLAG_ANY, &gh);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tneed_unlock = true;\n\t}\n\tacl = __gfs2_get_acl(inode, type);\n\tif (need_unlock)\n\t\tgfs2_glock_dq_uninit(&gh);\n\treturn acl;\n}\n\nint __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tint len;\n\tchar *data;\n\tconst char *name = gfs2_acl_name(type);\n\n\tif (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))\n\t\treturn -E2BIG;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\n\t\tif (mode != inode->i_mode) {\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tif (acl) {\n\t\tlen = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tdata = kmalloc(len, GFP_NOFS);\n\t\tif (data == NULL)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, data, len);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\n\terror = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);\n\tif (error)\n\t\tgoto out;\n\tset_cached_acl(inode, type, acl);\nout:\n\tkfree(data);\n\treturn error;\n}\n\nint gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tbool need_unlock = false;\n\tint ret;\n\n\tret = gfs2_rsqa_alloc(ip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!gfs2_glock_is_locked_by_me(ip->i_gl)) {\n\t\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tneed_unlock = true;\n\t}\n\tret = __gfs2_set_acl(inode, acl, type);\n\tif (need_unlock)\n\t\tgfs2_glock_dq_uninit(&gh);\n\treturn ret;\n}\n", "/*\n * linux/fs/hfsplus/posix_acl.c\n *\n * Vyacheslav Dubeyko <slava@dubeyko.com>\n *\n * Handler for Posix Access Control Lists (ACLs) support.\n */\n\n#include \"hfsplus_fs.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstruct posix_acl *hfsplus_get_posix_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tchar *xattr_name;\n\tchar *value = NULL;\n\tssize_t size;\n\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsize = __hfsplus_getxattr(inode, xattr_name, NULL, 0);\n\n\tif (size > 0) {\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __hfsplus_getxattr(inode, xattr_name, value, size);\n\t}\n\n\tif (size > 0)\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\telse if (size == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(size);\n\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\treturn acl;\n}\n\nint hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\n\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn err;\n}\n\nint hfsplus_init_posix_acl(struct inode *inode, struct inode *dir)\n{\n\tint err = 0;\n\tstruct posix_acl *default_acl, *acl;\n\n\thfs_dbg(ACL_MOD,\n\t\t\"[%s]: ino %lu, dir->ino %lu\\n\",\n\t\t__func__, inode->i_ino, dir->i_ino);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = hfsplus_set_posix_acl(inode, default_acl,\n\t\t\t\t\t    ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = hfsplus_set_posix_acl(inode, acl,\n\t\t\t\t\t\t    ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\treturn err;\n}\n", "/*\n * JFFS2 -- Journalling Flash File System, Version 2.\n *\n * Copyright \u00a9 2006  NEC Corporation\n *\n * Created by KaiGai Kohei <kaigai@ak.jp.nec.com>\n *\n * For licensing information, see the file 'LICENCE' in this directory.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/jffs2.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/mtd/mtd.h>\n#include \"nodelist.h\"\n\nstatic size_t jffs2_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(struct jffs2_acl_header)\n\t\t       + count * sizeof(struct jffs2_acl_entry_short);\n\t} else {\n\t\treturn sizeof(struct jffs2_acl_header)\n\t\t       + 4 * sizeof(struct jffs2_acl_entry_short)\n\t\t       + (count - 4) * sizeof(struct jffs2_acl_entry);\n\t}\n}\n\nstatic int jffs2_acl_count(size_t size)\n{\n\tsize_t s;\n\n\tsize -= sizeof(struct jffs2_acl_header);\n\tif (size < 4 * sizeof(struct jffs2_acl_entry_short)) {\n\t\tif (size % sizeof(struct jffs2_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(struct jffs2_acl_entry_short);\n\t} else {\n\t\ts = size - 4 * sizeof(struct jffs2_acl_entry_short);\n\t\tif (s % sizeof(struct jffs2_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(struct jffs2_acl_entry) + 4;\n\t}\n}\n\nstatic struct posix_acl *jffs2_acl_from_medium(void *value, size_t size)\n{\n\tvoid *end = value + size;\n\tstruct jffs2_acl_header *header = value;\n\tstruct jffs2_acl_entry *entry;\n\tstruct posix_acl *acl;\n\tuint32_t ver;\n\tint i, count;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct jffs2_acl_header))\n\t\treturn ERR_PTR(-EINVAL);\n\tver = je32_to_cpu(header->a_version);\n\tif (ver != JFFS2_ACL_VERSION) {\n\t\tJFFS2_WARNING(\"Invalid ACL version. (=%u)\\n\", ver);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tvalue += sizeof(struct jffs2_acl_header);\n\tcount = jffs2_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i=0; i < count; i++) {\n\t\tentry = value;\n\t\tif (value + sizeof(struct jffs2_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[i].e_tag = je16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[i].e_perm = je16_to_cpu(entry->e_perm);\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tvalue += sizeof(struct jffs2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tvalue += sizeof(struct jffs2_acl_entry);\n\t\t\t\tif (value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[i].e_uid =\n\t\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\t  je32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tvalue += sizeof(struct jffs2_acl_entry);\n\t\t\t\tif (value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[i].e_gid =\n\t\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\t  je32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n fail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void *jffs2_acl_to_medium(const struct posix_acl *acl, size_t *size)\n{\n\tstruct jffs2_acl_header *header;\n\tstruct jffs2_acl_entry *entry;\n\tvoid *e;\n\tsize_t i;\n\n\t*size = jffs2_acl_size(acl->a_count);\n\theader = kmalloc(sizeof(*header) + acl->a_count * sizeof(*entry), GFP_KERNEL);\n\tif (!header)\n\t\treturn ERR_PTR(-ENOMEM);\n\theader->a_version = cpu_to_je32(JFFS2_ACL_VERSION);\n\te = header + 1;\n\tfor (i=0; i < acl->a_count; i++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[i];\n\t\tentry = e;\n\t\tentry->e_tag = cpu_to_je16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_je16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER:\n\t\t\t\tentry->e_id = cpu_to_je32(\n\t\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\t\te += sizeof(struct jffs2_acl_entry);\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tentry->e_id = cpu_to_je32(\n\t\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\t\te += sizeof(struct jffs2_acl_entry);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\te += sizeof(struct jffs2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn header;\n fail:\n\tkfree(header);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstruct posix_acl *jffs2_get_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tchar *value = NULL;\n\tint rc, xprefix;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\trc = do_jffs2_getxattr(inode, xprefix, \"\", NULL, 0);\n\tif (rc > 0) {\n\t\tvalue = kmalloc(rc, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\trc = do_jffs2_getxattr(inode, xprefix, \"\", value, rc);\n\t}\n\tif (rc > 0) {\n\t\tacl = jffs2_acl_from_medium(value, rc);\n\t} else if (rc == -ENODATA || rc == -ENOSYS) {\n\t\tacl = NULL;\n\t} else {\n\t\tacl = ERR_PTR(rc);\n\t}\n\tkfree(value);\n\treturn acl;\n}\n\nstatic int __jffs2_set_acl(struct inode *inode, int xprefix, struct posix_acl *acl)\n{\n\tchar *value = NULL;\n\tsize_t size = 0;\n\tint rc;\n\n\tif (acl) {\n\t\tvalue = jffs2_acl_to_medium(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn PTR_ERR(value);\n\t}\n\trc = do_jffs2_setxattr(inode, xprefix, \"\", value, size, 0);\n\tif (!value && rc == -ENODATA)\n\t\trc = 0;\n\tkfree(value);\n\n\treturn rc;\n}\n\nint jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}\n\nint jffs2_init_acl_pre(struct inode *dir_i, struct inode *inode, umode_t *i_mode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint rc;\n\n\tcache_no_acl(inode);\n\n\trc = posix_acl_create(dir_i, i_mode, &default_acl, &acl);\n\tif (rc)\n\t\treturn rc;\n\n\tif (default_acl) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn 0;\n}\n\nint jffs2_init_acl_post(struct inode *inode)\n{\n\tint rc;\n\n\tif (inode->i_default_acl) {\n\t\trc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_DEFAULT, inode->i_default_acl);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (inode->i_acl) {\n\t\trc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_ACCESS, inode->i_acl);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n", "/*\n *   Copyright (C) International Business Machines  Corp., 2002-2004\n *   Copyright (C) Andreas Gruenbacher, 2001\n *   Copyright (C) Linus Torvalds, 1991, 1992\n *\n *   This program is free software;  you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY;  without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program;  if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/posix_acl_xattr.h>\n#include \"jfs_incore.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_acl.h\"\n\nstruct posix_acl *jfs_get_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tchar *ea_name;\n\tint size;\n\tchar *value = NULL;\n\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\t\tbreak;\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsize = __jfs_getxattr(inode, ea_name, NULL, 0);\n\n\tif (size > 0) {\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __jfs_getxattr(inode, ea_name, value, size);\n\t}\n\n\tif (size < 0) {\n\t\tif (size == -ENODATA)\n\t\t\tacl = NULL;\n\t\telse\n\t\t\tacl = ERR_PTR(size);\n\t} else {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t}\n\tkfree(value);\n\treturn acl;\n}\n\nstatic int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn rc;\n}\n\nint jfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc;\n\ttid_t tid;\n\n\ttid = txBegin(inode->i_sb, 0);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\trc = __jfs_set_acl(tid, inode, type, acl);\n\tif (!rc)\n\t\trc = txCommit(tid, 1, &inode, 0);\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}\n\nint jfs_init_acl(tid_t tid, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint rc = 0;\n\n\trc = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (rc)\n\t\treturn rc;\n\n\tif (default_acl) {\n\t\trc = __jfs_set_acl(tid, inode, ACL_TYPE_DEFAULT, default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!rc)\n\t\t\trc = __jfs_set_acl(tid, inode, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\n\tJFS_IP(inode)->mode2 = (JFS_IP(inode)->mode2 & 0xffff0000) |\n\t\t\t       inode->i_mode;\n\n\treturn rc;\n}\n", "/* -*- mode: c; c-basic-offset: 8; -*-\n * vim: noexpandtab sw=8 ts=8 sts=0:\n *\n * acl.c\n *\n * Copyright (C) 2004, 2008 Oracle.  All rights reserved.\n *\n * CREDITS:\n * Lots of code in this file is copy from linux/fs/ext3/acl.c.\n * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License version 2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n */\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n#include \"alloc.h\"\n#include \"dlmglue.h\"\n#include \"file.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"ocfs2_fs.h\"\n\n#include \"xattr.h\"\n#include \"acl.h\"\n\n/*\n * Convert from xattr value to acl struct.\n */\nstatic struct posix_acl *ocfs2_acl_from_xattr(const void *value, size_t size)\n{\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_entry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = size / sizeof(struct posix_acl_entry);\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\tstruct ocfs2_acl_entry *entry =\n\t\t\t(struct ocfs2_acl_entry *)value;\n\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tvalue += sizeof(struct posix_acl_entry);\n\n\t}\n\treturn acl;\n}\n\n/*\n * Convert acl struct to xattr value.\n */\nstatic void *ocfs2_acl_to_xattr(const struct posix_acl *acl, size_t *size)\n{\n\tstruct ocfs2_acl_entry *entry = NULL;\n\tchar *ocfs2_acl;\n\tsize_t n;\n\n\t*size = acl->a_count * sizeof(struct posix_acl_entry);\n\n\tocfs2_acl = kmalloc(*size, GFP_NOFS);\n\tif (!ocfs2_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tentry = (struct ocfs2_acl_entry *)ocfs2_acl;\n\tfor (n = 0; n < acl->a_count; n++, entry++) {\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ocfs2_acl;\n}\n\nstatic struct posix_acl *ocfs2_get_acl_nolock(struct inode *inode,\n\t\t\t\t\t      int type,\n\t\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t\t\t\"\", value, retval);\n\t}\n\n\tif (retval > 0)\n\t\tacl = ocfs2_acl_from_xattr(value, retval);\n\telse if (retval == -ENODATA || retval == 0)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\n\tkfree(value);\n\n\treturn acl;\n}\n\n/*\n * Helper function to set i_mode in memory and disk. Some call paths\n * will not have di_bh or a journal handle to pass, in which case it\n * will create it's own.\n */\nstatic int ocfs2_acl_set_mode(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t      handle_t *handle, umode_t new_mode)\n{\n\tint ret, commit_handle = 0;\n\tstruct ocfs2_dinode *di;\n\n\tif (di_bh == NULL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tget_bh(di_bh);\n\n\tif (handle == NULL) {\n\t\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_brelse;\n\t\t}\n\n\t\tcommit_handle = 1;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode->i_mode = new_mode;\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tif (commit_handle)\n\t\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout_brelse:\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}\n\n/*\n * Set the access or default ACL of an inode.\n */\nint ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\n\treturn ret;\n}\n\nint ocfs2_iop_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct buffer_head *bh = NULL;\n\tint status = 0;\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_set_acl(NULL, inode, bh, type, acl, NULL, NULL);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(bh);\n\treturn status;\n}\n\nstruct posix_acl *ocfs2_iop_get_acl(struct inode *inode, int type)\n{\n\tstruct ocfs2_super *osb;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct posix_acl *acl;\n\tint ret;\n\n\tosb = OCFS2_SB(inode->i_sb);\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL))\n\t\treturn NULL;\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tif (ret != -ENOENT)\n\t\t\tmlog_errno(ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tacl = ocfs2_get_acl_nolock(inode, type, di_bh);\n\n\tocfs2_inode_unlock(inode, 0);\n\tbrelse(di_bh);\n\treturn acl;\n}\n\nint ocfs2_acl_chmod(struct inode *inode, struct buffer_head *bh)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct posix_acl *acl;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL))\n\t\treturn 0;\n\n\tacl = ocfs2_get_acl_nolock(inode, ACL_TYPE_ACCESS, bh);\n\tif (IS_ERR(acl) || !acl)\n\t\treturn PTR_ERR(acl);\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\tif (ret)\n\t\treturn ret;\n\tret = ocfs2_set_acl(NULL, inode, NULL, ACL_TYPE_ACCESS,\n\t\t\t    acl, NULL, NULL);\n\tposix_acl_release(acl);\n\treturn ret;\n}\n\n/*\n * Initialize the ACLs of a new inode. If parent directory has default ACL,\n * then clone to new inode. Called from ocfs2_mknod.\n */\nint ocfs2_init_acl(handle_t *handle,\n\t\t   struct inode *inode,\n\t\t   struct inode *dir,\n\t\t   struct buffer_head *di_bh,\n\t\t   struct buffer_head *dir_bh,\n\t\t   struct ocfs2_alloc_context *meta_ac,\n\t\t   struct ocfs2_alloc_context *data_ac)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct posix_acl *acl = NULL;\n\tint ret = 0, ret2;\n\tumode_t mode;\n\n\tif (!S_ISLNK(inode->i_mode)) {\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) {\n\t\t\tacl = ocfs2_get_acl_nolock(dir, ACL_TYPE_DEFAULT,\n\t\t\t\t\t\t   dir_bh);\n\t\t\tif (IS_ERR(acl))\n\t\t\t\treturn PTR_ERR(acl);\n\t\t}\n\t\tif (!acl) {\n\t\t\tmode = inode->i_mode & ~current_umask();\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh, handle, mode);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) && acl) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tret = ocfs2_set_acl(handle, inode, di_bh,\n\t\t\t\t\t    ACL_TYPE_DEFAULT, acl,\n\t\t\t\t\t    meta_ac, data_ac);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tmode = inode->i_mode;\n\t\tret = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret2 = ocfs2_acl_set_mode(inode, di_bh, handle, mode);\n\t\tif (ret2) {\n\t\t\tmlog_errno(ret2);\n\t\t\tret = ret2;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tret = ocfs2_set_acl(handle, inode,\n\t\t\t\t\t    di_bh, ACL_TYPE_ACCESS,\n\t\t\t\t\t    acl, meta_ac, data_ac);\n\t\t}\n\t}\ncleanup:\n\tposix_acl_release(acl);\n\treturn ret;\n}\n", "/*\n * (C) 2001 Clemson University and The University of Chicago\n *\n * See COPYING in top-level directory.\n */\n\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-bufmap.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/fs_struct.h>\n\nstruct posix_acl *orangefs_get_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tint ret;\n\tchar *key = NULL, *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tkey = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tkey = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"orangefs_get_acl: bogus value of type %d\\n\", type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t/*\n\t * Rather than incurring a network call just to determine the exact\n\t * length of the attribute, I just allocate a max length to save on\n\t * the network call. Conceivably, we could pass NULL to\n\t * orangefs_inode_getxattr() to probe the length of the value, but\n\t * I don't do that for now.\n\t */\n\tvalue = kmalloc(ORANGEFS_MAX_XATTR_VALUELEN, GFP_KERNEL);\n\tif (value == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"inode %pU, key %s, type %d\\n\",\n\t\t     get_khandle_from_ino(inode),\n\t\t     key,\n\t\t     type);\n\tret = orangefs_inode_getxattr(inode, key, value,\n\t\t\t\t      ORANGEFS_MAX_XATTR_VALUELEN);\n\t/* if the key exists, convert it to an in-memory rep */\n\tif (ret > 0) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, ret);\n\t} else if (ret == -ENODATA || ret == -ENOSYS) {\n\t\tacl = NULL;\n\t} else {\n\t\tgossip_err(\"inode %pU retrieving acl's failed with error %d\\n\",\n\t\t\t   get_khandle_from_ino(inode),\n\t\t\t   ret);\n\t\tacl = ERR_PTR(ret);\n\t}\n\t/* kfree(NULL) is safe, so don't worry if value ever got used */\n\tkfree(value);\n\treturn acl;\n}\n\nint orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tint error = 0;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tconst char *name = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\t/*\n\t\t\t * can we represent this with the traditional file\n\t\t\t * mode permission bits?\n\t\t\t */\n\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (error < 0) {\n\t\t\t\tgossip_err(\"%s: posix_acl_equiv_mode err: %d\\n\",\n\t\t\t\t\t   __func__,\n\t\t\t\t\t   error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tif (inode->i_mode != mode)\n\t\t\t\tSetModeFlag(orangefs_inode);\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"%s: invalid type %d!\\n\", __func__, type);\n\t\treturn -EINVAL;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: inode %pU, key %s type %d\\n\",\n\t\t     __func__, get_khandle_from_ino(inode),\n\t\t     name,\n\t\t     type);\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: name %s, value %p, size %zd, acl %p\\n\",\n\t\t     __func__, name, value, size, acl);\n\t/*\n\t * Go ahead and set the extended attribute now. NOTE: Suppose acl\n\t * was NULL, then value will be NULL and size will be 0 and that\n\t * will xlate to a removexattr. However, we don't want removexattr\n\t * complain if attributes does not exist.\n\t */\n\terror = orangefs_inode_setxattr(inode, name, value, size, 0);\n\nout:\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n\nint orangefs_init_acl(struct inode *inode, struct inode *dir)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct posix_acl *default_acl, *acl;\n\tumode_t mode = inode->i_mode;\n\tint error = 0;\n\n\tClearModeFlag(orangefs_inode);\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = orangefs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = orangefs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\t/* If mode of the inode was changed, then do a forcible ->setattr */\n\tif (mode != inode->i_mode) {\n\t\tSetModeFlag(orangefs_inode);\n\t\tinode->i_mode = mode;\n\t\torangefs_flush_inode(inode);\n\t}\n\n\treturn error;\n}\n", "/*\n * Copyright (C) 2002,2003 by Andreas Gruenbacher <a.gruenbacher@computer.org>\n *\n * Fixes from William Schumacher incorporated on 15 March 2001.\n *    (Reported by Charles Bertsch, <CBertsch@microtest.com>).\n */\n\n/*\n *  This file contains generic functions for manipulating\n *  POSIX 1003.1e draft standard 17 ACLs.\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/export.h>\n#include <linux/user_namespace.h>\n\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstruct posix_acl *get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *acl;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tacl = rcu_dereference(*p);\n\t\tif (!acl || is_uncached_acl(acl) ||\n\t\t    atomic_inc_not_zero(&acl->a_refcount))\n\t\t\tbreak;\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t}\n\trcu_read_unlock();\n\treturn acl;\n}\nEXPORT_SYMBOL(get_cached_acl);\n\nstruct posix_acl *get_cached_acl_rcu(struct inode *inode, int type)\n{\n\treturn rcu_dereference(*acl_by_type(inode, type));\n}\nEXPORT_SYMBOL(get_cached_acl_rcu);\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}\nEXPORT_SYMBOL(set_cached_acl);\n\nstatic void __forget_cached_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *old;\n\n\told = xchg(p, ACL_NOT_CACHED);\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}\n\nvoid forget_cached_acl(struct inode *inode, int type)\n{\n\t__forget_cached_acl(acl_by_type(inode, type));\n}\nEXPORT_SYMBOL(forget_cached_acl);\n\nvoid forget_all_cached_acls(struct inode *inode)\n{\n\t__forget_cached_acl(&inode->i_acl);\n\t__forget_cached_acl(&inode->i_default_acl);\n}\nEXPORT_SYMBOL(forget_all_cached_acls);\n\nstruct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}\nEXPORT_SYMBOL(get_acl);\n\n/*\n * Init a fresh posix_acl\n */\nvoid\nposix_acl_init(struct posix_acl *acl, int count)\n{\n\tatomic_set(&acl->a_refcount, 1);\n\tacl->a_count = count;\n}\nEXPORT_SYMBOL(posix_acl_init);\n\n/*\n * Allocate a new ACL with the specified number of entries.\n */\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}\nEXPORT_SYMBOL(posix_acl_alloc);\n\n/*\n * Clone an ACL.\n */\nstatic struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\tatomic_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}\n\n/*\n * Check if an acl is valid. Returns 0 if it is, or -E... otherwise.\n */\nint\nposix_acl_valid(struct user_namespace *user_ns, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tint state = ACL_USER_OBJ;\n\tint needs_mask = 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\n\t\t\treturn -EINVAL;\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tif (state == ACL_USER_OBJ) {\n\t\t\t\t\tstate = ACL_USER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tif (state != ACL_USER)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kuid_has_mapping(user_ns, pa->e_uid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tif (state == ACL_USER) {\n\t\t\t\t\tstate = ACL_GROUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kgid_has_mapping(user_ns, pa->e_gid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tstate = ACL_OTHER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tif (state == ACL_OTHER ||\n\t\t\t\t    (state == ACL_GROUP && !needs_mask)) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (state == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(posix_acl_valid);\n\n/*\n * Returns 0 if the acl can be exactly represented in the traditional\n * file mode permission bits, or else 1. Returns -E... on error.\n */\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\nEXPORT_SYMBOL(posix_acl_equiv_mode);\n\n/*\n * Create an ACL representing the file mode permission bits of an inode.\n */\nstruct posix_acl *\nposix_acl_from_mode(umode_t mode, gfp_t flags)\n{\n\tstruct posix_acl *acl = posix_acl_alloc(3, flags);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tacl->a_entries[0].e_tag  = ACL_USER_OBJ;\n\tacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\n\n\tacl->a_entries[1].e_tag  = ACL_GROUP_OBJ;\n\tacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\n\n\tacl->a_entries[2].e_tag  = ACL_OTHER;\n\tacl->a_entries[2].e_perm = (mode & S_IRWXO);\n\treturn acl;\n}\nEXPORT_SYMBOL(posix_acl_from_mode);\n\n/*\n * Return 0 if current is granted want access to the inode\n * by the acl. Returns -E... otherwise.\n */\nint\nposix_acl_permission(struct inode *inode, const struct posix_acl *acl, int want)\n{\n\tconst struct posix_acl_entry *pa, *pe, *mask_obj;\n\tint found = 0;\n\n\twant &= MAY_READ | MAY_WRITE | MAY_EXEC | MAY_NOT_BLOCK;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\t/* (May have been checked already) */\n\t\t\t\tif (uid_eq(inode->i_uid, current_fsuid()))\n                                        goto check_perm;\n                                break;\n                        case ACL_USER:\n\t\t\t\tif (uid_eq(pa->e_uid, current_fsuid()))\n                                        goto mask;\n\t\t\t\tbreak;\n                        case ACL_GROUP_OBJ:\n                                if (in_group_p(inode->i_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n\t\t\t\tbreak;\n                        case ACL_GROUP:\n\t\t\t\tif (in_group_p(pa->e_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n                                break;\n                        case ACL_MASK:\n                                break;\n                        case ACL_OTHER:\n\t\t\t\tif (found)\n\t\t\t\t\treturn -EACCES;\n\t\t\t\telse\n\t\t\t\t\tgoto check_perm;\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\treturn -EIO;\n\nmask:\n\tfor (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\n\t\tif (mask_obj->e_tag == ACL_MASK) {\n\t\t\tif ((pa->e_perm & mask_obj->e_perm & want) == want)\n\t\t\t\treturn 0;\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\ncheck_perm:\n\tif ((pa->e_perm & want) == want)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\n/*\n * Modify acl when creating a new inode. The caller must ensure the acl is\n * only referenced once.\n *\n * mode_p initially must contain the mode parameter to the open() / creat()\n * system calls. All permissions that are not granted by the acl are removed.\n * The permissions in the acl are changed to reflect the mode_p parameter.\n */\nstatic int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\n                        case ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n                                break;\n\n                        case ACL_OTHER:\n\t\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n                                break;\n\n                        case ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tnot_equiv = 1;\n                                break;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\n\n/*\n * Modify the ACL for the chmod syscall.\n */\nstatic int __posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\n{\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpa->e_perm = (mode & S_IRWXU) >> 6;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpa->e_perm = (mode & S_IRWXO);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t}\n\n\treturn 0;\n}\n\nint\n__posix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = posix_acl_create_masq(clone, mode_p);\n\t\tif (err < 0) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}\nEXPORT_SYMBOL(__posix_acl_create);\n\nint\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = __posix_acl_chmod_masq(clone, mode);\n\t\tif (err) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}\nEXPORT_SYMBOL(__posix_acl_chmod);\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}\nEXPORT_SYMBOL(posix_acl_chmod);\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tclone = posix_acl_clone(p, GFP_NOFS);\n\tif (!clone)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(clone);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(posix_acl_create);\n\n/*\n * Fix up the uids and gids in posix acl extended attributes in place.\n */\nstatic void posix_acl_fix_xattr_userns(\n\tstruct user_namespace *to, struct user_namespace *from,\n\tvoid *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!value)\n\t\treturn;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\treturn;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn;\n\tif (count == 0)\n\t\treturn;\n\n\tfor (end = entry + count; entry != end; entry++) {\n\t\tswitch(le16_to_cpu(entry->e_tag)) {\n\t\tcase ACL_USER:\n\t\t\tuid = make_kuid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kuid(to, uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tgid = make_kgid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kgid(to, gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid posix_acl_fix_xattr_from_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);\n}\n\nvoid posix_acl_fix_xattr_to_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);\n}\n\n/*\n * Convert from extended attribute to in-memory representation.\n */\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL (posix_acl_from_xattr);\n\n/*\n * Convert from in-memory to extended attribute representation.\n */\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}\nEXPORT_SYMBOL (posix_acl_to_xattr);\n\nstatic int\nposix_acl_xattr_get(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, void *value, size_t size)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, handler->flags);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\n\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}\n\nint\nset_posix_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn acl ? -EACCES : 0;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (acl) {\n\t\tint ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn inode->i_op->set_acl(inode, acl, type);\n}\nEXPORT_SYMBOL(set_posix_acl);\n\nstatic int\nposix_acl_xattr_set(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, const void *value,\n\t\t    size_t size, int flags)\n{\n\tstruct posix_acl *acl = NULL;\n\tint ret;\n\n\tif (value) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t}\n\tret = set_posix_acl(inode, handler->flags, acl);\n\tposix_acl_release(acl);\n\treturn ret;\n}\n\nstatic bool\nposix_acl_xattr_list(struct dentry *dentry)\n{\n\treturn IS_POSIXACL(d_backing_inode(dentry));\n}\n\nconst struct xattr_handler posix_acl_access_xattr_handler = {\n\t.name = XATTR_NAME_POSIX_ACL_ACCESS,\n\t.flags = ACL_TYPE_ACCESS,\n\t.list = posix_acl_xattr_list,\n\t.get = posix_acl_xattr_get,\n\t.set = posix_acl_xattr_set,\n};\nEXPORT_SYMBOL_GPL(posix_acl_access_xattr_handler);\n\nconst struct xattr_handler posix_acl_default_xattr_handler = {\n\t.name = XATTR_NAME_POSIX_ACL_DEFAULT,\n\t.flags = ACL_TYPE_DEFAULT,\n\t.list = posix_acl_xattr_list,\n\t.get = posix_acl_xattr_get,\n\t.set = posix_acl_xattr_set,\n};\nEXPORT_SYMBOL_GPL(posix_acl_default_xattr_handler);\n\nint simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\n\tinode->i_ctime = CURRENT_TIME;\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}\n\nint simple_acl_create(struct inode *dir, struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn 0;\n}\n", "#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/posix_acl.h>\n#include \"reiserfs.h\"\n#include <linux/errno.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include <linux/uaccess.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\n\nint\nreiserfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error, error2;\n\tstruct reiserfs_transaction_handle th;\n\tsize_t jcreate_blocks;\n\tint size = acl ? posix_acl_xattr_size(acl->a_count) : 0;\n\n\n\t/*\n\t * Pessimism: We can't assume that anything from the xattr root up\n\t * has been created.\n\t */\n\n\tjcreate_blocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, size) * 2;\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jcreate_blocks);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0) {\n\t\terror = __reiserfs_set_acl(&th, inode, type, acl);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror2 = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error2)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}\n\n/*\n * Convert from filesystem to in-memory representation.\n */\nstatic struct posix_acl *reiserfs_posix_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(reiserfs_acl_header))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (((reiserfs_acl_header *) value)->a_version !=\n\t    cpu_to_le32(REISERFS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(reiserfs_acl_header);\n\tcount = reiserfs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) value;\n\t\tif ((char *)value + sizeof(reiserfs_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t    sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid = \n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * Convert from in-memory to filesystem representation.\n */\nstatic void *reiserfs_posix_acl_to_disk(const struct posix_acl *acl, size_t * size)\n{\n\treiserfs_acl_header *ext_acl;\n\tchar *e;\n\tint n;\n\n\t*size = reiserfs_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(reiserfs_acl_header) +\n\t\t\t\t\t\t  acl->a_count *\n\t\t\t\t\t\t  sizeof(reiserfs_acl_entry),\n\t\t\t\t\t\t  GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(REISERFS_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(reiserfs_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) e;\n\t\tentry->e_tag = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * Inode operation get_posix_acl().\n *\n * inode->i_mutex: down\n * BKL held [before 2.5.x]\n */\nstruct posix_acl *reiserfs_get_acl(struct inode *inode, int type)\n{\n\tchar *name, *value;\n\tstruct posix_acl *acl;\n\tint size;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = reiserfs_xattr_get(inode, name, NULL, 0);\n\tif (size < 0) {\n\t\tif (size == -ENODATA || size == -ENOSYS)\n\t\t\treturn NULL;\n\t\treturn ERR_PTR(size);\n\t}\n\n\tvalue = kmalloc(size, GFP_NOFS);\n\tif (!value)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tretval = reiserfs_xattr_get(inode, name, value, size);\n\tif (retval == -ENODATA || retval == -ENOSYS) {\n\t\t/*\n\t\t * This shouldn't actually happen as it should have\n\t\t * been caught above.. but just in case\n\t\t */\n\t\tacl = NULL;\n\t} else if (retval < 0) {\n\t\tacl = ERR_PTR(retval);\n\t} else {\n\t\tacl = reiserfs_posix_acl_from_disk(value, retval);\n\t}\n\n\tkfree(value);\n\treturn acl;\n}\n\n/*\n * Inode operation set_posix_acl().\n *\n * inode->i_mutex: down\n * BKL held [before 2.5.x]\n */\nstatic int\n__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\n\t/*\n\t * Ensure that the inode gets dirtied if we're only using\n\t * the mode bits and an old ACL didn't exist. We don't need\n\t * to check if the inode is hashed here since we won't get\n\t * called by reiserfs_inherit_default_acl().\n\t */\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tkfree(value);\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}\n\n/*\n * dir->i_mutex: locked,\n * inode is new and not released into the wild yet\n */\nint\nreiserfs_inherit_default_acl(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *dir, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint err = 0;\n\n\t/* ACLs only get applied to files and directories */\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\t/*\n\t * ACLs can only be used on \"new\" objects, so if it's an old object\n\t * there is nothing to inherit from\n\t */\n\tif (get_inode_sd_version(dir) == STAT_DATA_V1)\n\t\tgoto apply_umask;\n\n\t/*\n\t * Don't apply ACLs to objects in the .reiserfs_priv tree.. This\n\t * would be useless since permissions are ignored, and a pain because\n\t * it introduces locking cycles\n\t */\n\tif (IS_PRIVATE(dir)) {\n\t\tinode->i_flags |= S_PRIVATE;\n\t\tgoto apply_umask;\n\t}\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t\t default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t\t acl);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn err;\n\napply_umask:\n\t/* no ACL, apply umask */\n\tinode->i_mode &= ~current_umask();\n\treturn err;\n}\n\n/* This is used to cache the default acl before a new object is created.\n * The biggest reason for this is to get an idea of how many blocks will\n * actually be required for the create operation if we must inherit an ACL.\n * An ACL write can add up to 3 object creations and an additional file write\n * so we'd prefer not to reserve that many blocks in the journal if we can.\n * It also has the advantage of not loading the ACL with a transaction open,\n * this may seem silly, but if the owner of the directory is doing the\n * creation, the ACL may not be loaded since the permissions wouldn't require\n * it.\n * We return the number of blocks required for the transaction.\n */\nint reiserfs_cache_default_acl(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint nblocks = 0;\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\tacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\n\tif (acl && !IS_ERR(acl)) {\n\t\tint size = reiserfs_acl_size(acl->a_count);\n\n\t\t/* Other xattrs can be created during inode creation. We don't\n\t\t * want to claim too many blocks, so we check to see if we\n\t\t * we need to create the tree to the xattrs, and then we\n\t\t * just want two files. */\n\t\tnblocks = reiserfs_xattr_jcreate_nblocks(inode);\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\n\t\t/* We need to account for writes + bitmaps for two files */\n\t\tnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn nblocks;\n}\n\n/*\n * Called under i_mutex\n */\nint reiserfs_acl_chmod(struct inode *inode)\n{\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1 ||\n\t    !reiserfs_posixacl(inode->i_sb))\n\t\treturn 0;\n\n\treturn posix_acl_chmod(inode, inode->i_mode);\n}\n", "/*\n * Copyright (c) 2008, Christoph Hellwig\n * All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it would be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write the Free Software Foundation,\n * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n#include \"xfs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_trace.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n\n\n/*\n * Locking scheme:\n *  - all ACL updates are protected by inode->i_mutex, which is taken before\n *    calling into this file.\n */\n\nSTATIC struct posix_acl *\nxfs_acl_from_disk(\n\tconst struct xfs_acl\t*aclp,\n\tint\t\t\tlen,\n\tint\t\t\tmax_entries)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tconst struct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tif (len < sizeof(*aclp))\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > max_entries || XFS_ACL_SIZE(count) != len)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl_e->e_uid = xfs_uid_to_kuid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_gid = xfs_gid_to_kgid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nSTATIC void\nxfs_acl_to_disk(struct xfs_acl *aclp, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *acl_e;\n\tstruct xfs_acl_entry *ace;\n\tint i;\n\n\taclp->acl_cnt = cpu_to_be32(acl->a_count);\n\tfor (i = 0; i < acl->a_count; i++) {\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e = &acl->a_entries[i];\n\n\t\tace->ae_tag = cpu_to_be32(acl_e->e_tag);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kuid_to_uid(acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kgid_to_gid(acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tace->ae_id = cpu_to_be32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\n\t\tace->ae_perm = cpu_to_be16(acl_e->e_perm);\n\t}\n}\n\nstruct posix_acl *\nxfs_get_acl(struct inode *inode, int type)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tstruct posix_acl *acl = NULL;\n\tstruct xfs_acl *xfs_acl;\n\tunsigned char *ea_name;\n\tint error;\n\tint len;\n\n\ttrace_xfs_get_acl(ip);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * If we have a cached ACLs value just return it, not need to\n\t * go out to the disk.\n\t */\n\tlen = XFS_ACL_MAX_SIZE(ip->i_mount);\n\txfs_acl = kmem_zalloc_large(len, KM_SLEEP);\n\tif (!xfs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = xfs_attr_get(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\t\t\t\t&len, ATTR_ROOT);\n\tif (error) {\n\t\t/*\n\t\t * If the attribute doesn't exist make sure we have a negative\n\t\t * cache entry, for any other error assume it is transient.\n\t\t */\n\t\tif (error != -ENOATTR)\n\t\t\tacl = ERR_PTR(error);\n\t} else  {\n\t\tacl = xfs_acl_from_disk(xfs_acl, len,\n\t\t\t\t\tXFS_ACL_MAX_ENTRIES(ip->i_mount));\n\t}\n\tkmem_free(xfs_acl);\n\treturn acl;\n}\n\nSTATIC int\n__xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tunsigned char *ea_name;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tstruct xfs_acl *xfs_acl;\n\t\tint len = XFS_ACL_MAX_SIZE(ip->i_mount);\n\n\t\txfs_acl = kmem_zalloc_large(len, KM_SLEEP);\n\t\tif (!xfs_acl)\n\t\t\treturn -ENOMEM;\n\n\t\txfs_acl_to_disk(xfs_acl, acl);\n\n\t\t/* subtract away the unused acl entries */\n\t\tlen -= sizeof(struct xfs_acl_entry) *\n\t\t\t (XFS_ACL_MAX_ENTRIES(ip->i_mount) - acl->a_count);\n\n\t\terror = xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\tlen, ATTR_ROOT);\n\n\t\tkmem_free(xfs_acl);\n\t} else {\n\t\t/*\n\t\t * A NULL ACL argument means we want to remove the ACL.\n\t\t */\n\t\terror = xfs_attr_remove(ip, ea_name, ATTR_ROOT);\n\n\t\t/*\n\t\t * If the attribute didn't exist to start with that's fine.\n\t\t */\n\t\tif (error == -ENOATTR)\n\t\t\terror = 0;\n\t}\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n\nstatic int\nxfs_set_mode(struct inode *inode, umode_t mode)\n{\n\tint error = 0;\n\n\tif (mode != inode->i_mode) {\n\t\tstruct iattr iattr;\n\n\t\tiattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\tiattr.ia_mode = mode;\n\t\tiattr.ia_ctime = current_fs_time(inode->i_sb);\n\n\t\terror = xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);\n\t}\n\n\treturn error;\n}\n\nint\nxfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}\n", "/*\n  File: linux/posix_acl.h\n\n  (C) 2002 Andreas Gruenbacher, <a.gruenbacher@computer.org>\n*/\n\n\n#ifndef __LINUX_POSIX_ACL_H\n#define __LINUX_POSIX_ACL_H\n\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rcupdate.h>\n\n#define ACL_UNDEFINED_ID\t(-1)\n\n/* a_type field in acl_user_posix_entry_t */\n#define ACL_TYPE_ACCESS\t\t(0x8000)\n#define ACL_TYPE_DEFAULT\t(0x4000)\n\n/* e_tag entry in struct posix_acl_entry */\n#define ACL_USER_OBJ\t\t(0x01)\n#define ACL_USER\t\t(0x02)\n#define ACL_GROUP_OBJ\t\t(0x04)\n#define ACL_GROUP\t\t(0x08)\n#define ACL_MASK\t\t(0x10)\n#define ACL_OTHER\t\t(0x20)\n\n/* permissions in the e_perm field */\n#define ACL_READ\t\t(0x04)\n#define ACL_WRITE\t\t(0x02)\n#define ACL_EXECUTE\t\t(0x01)\n//#define ACL_ADD\t\t(0x08)\n//#define ACL_DELETE\t\t(0x10)\n\nstruct posix_acl_entry {\n\tshort\t\t\te_tag;\n\tunsigned short\t\te_perm;\n\tunion {\n\t\tkuid_t\t\te_uid;\n\t\tkgid_t\t\te_gid;\n\t};\n};\n\nstruct posix_acl {\n\tatomic_t\t\ta_refcount;\n\tstruct rcu_head\t\ta_rcu;\n\tunsigned int\t\ta_count;\n\tstruct posix_acl_entry\ta_entries[0];\n};\n\n#define FOREACH_ACL_ENTRY(pa, acl, pe) \\\n\tfor(pa=(acl)->a_entries, pe=pa+(acl)->a_count; pa<pe; pa++)\n\n\n/*\n * Duplicate an ACL handle.\n */\nstatic inline struct posix_acl *\nposix_acl_dup(struct posix_acl *acl)\n{\n\tif (acl)\n\t\tatomic_inc(&acl->a_refcount);\n\treturn acl;\n}\n\n/*\n * Free an ACL handle.\n */\nstatic inline void\nposix_acl_release(struct posix_acl *acl)\n{\n\tif (acl && atomic_dec_and_test(&acl->a_refcount))\n\t\tkfree_rcu(acl, a_rcu);\n}\n\n\n/* posix_acl.c */\n\nextern void posix_acl_init(struct posix_acl *, int);\nextern struct posix_acl *posix_acl_alloc(int, gfp_t);\nextern int posix_acl_valid(struct user_namespace *, const struct posix_acl *);\nextern int posix_acl_permission(struct inode *, const struct posix_acl *, int);\nextern struct posix_acl *posix_acl_from_mode(umode_t, gfp_t);\nextern int posix_acl_equiv_mode(const struct posix_acl *, umode_t *);\nextern int __posix_acl_create(struct posix_acl **, gfp_t, umode_t *);\nextern int __posix_acl_chmod(struct posix_acl **, gfp_t, umode_t);\n\nextern struct posix_acl *get_posix_acl(struct inode *, int);\nextern int set_posix_acl(struct inode *, int, struct posix_acl *);\n\n#ifdef CONFIG_FS_POSIX_ACL\nextern int posix_acl_chmod(struct inode *, umode_t);\nextern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n\t\tstruct posix_acl **);\n\nextern int simple_set_acl(struct inode *, struct posix_acl *, int);\nextern int simple_acl_create(struct inode *, struct inode *);\n\nstruct posix_acl *get_cached_acl(struct inode *inode, int type);\nstruct posix_acl *get_cached_acl_rcu(struct inode *inode, int type);\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl);\nvoid forget_cached_acl(struct inode *inode, int type);\nvoid forget_all_cached_acls(struct inode *inode);\n\nstatic inline void cache_no_acl(struct inode *inode)\n{\n\tinode->i_acl = NULL;\n\tinode->i_default_acl = NULL;\n}\n#else\nstatic inline int posix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\treturn 0;\n}\n\n#define simple_set_acl\t\tNULL\n\nstatic inline int simple_acl_create(struct inode *dir, struct inode *inode)\n{\n\treturn 0;\n}\nstatic inline void cache_no_acl(struct inode *inode)\n{\n}\n\nstatic inline int posix_acl_create(struct inode *inode, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\t*default_acl = *acl = NULL;\n\treturn 0;\n}\n\nstatic inline void forget_all_cached_acls(struct inode *inode)\n{\n}\n#endif /* CONFIG_FS_POSIX_ACL */\n\nstruct posix_acl *get_acl(struct inode *inode, int type);\n\n#endif  /* __LINUX_POSIX_ACL_H */\n"], "fixing_code": ["/*\n * Copyright IBM Corporation, 2010\n * Author Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of version 2.1 of the GNU Lesser General Public License\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it would be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *\n */\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"v9fs.h\"\n#include \"v9fs_vfs.h\"\n#include \"fid.h\"\n\nstatic struct posix_acl *__v9fs_get_acl(struct p9_fid *fid, char *name)\n{\n\tssize_t size;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl = NULL;\n\n\tsize = v9fs_fid_xattr_get(fid, name, NULL, 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = v9fs_fid_xattr_get(fid, name, value, size);\n\t\tif (size > 0) {\n\t\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\t\tif (IS_ERR(acl))\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else if (size == -ENODATA || size == 0 ||\n\t\t   size == -ENOSYS || size == -EOPNOTSUPP) {\n\t\tacl = NULL;\n\t} else\n\t\tacl = ERR_PTR(-EIO);\n\nerr_out:\n\tkfree(value);\n\treturn acl;\n}\n\nint v9fs_get_acl(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *pacl, *dacl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, NULL);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, NULL);\n\t\treturn 0;\n\t}\n\t/* get the default/access acl values and cache them */\n\tdacl = __v9fs_get_acl(fid, XATTR_NAME_POSIX_ACL_DEFAULT);\n\tpacl = __v9fs_get_acl(fid, XATTR_NAME_POSIX_ACL_ACCESS);\n\n\tif (!IS_ERR(dacl) && !IS_ERR(pacl)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, pacl);\n\t} else\n\t\tretval = -EIO;\n\n\tif (!IS_ERR(dacl))\n\t\tposix_acl_release(dacl);\n\n\tif (!IS_ERR(pacl))\n\t\tposix_acl_release(pacl);\n\n\treturn retval;\n}\n\nstatic struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t/*\n\t * 9p Always cache the acl value when\n\t * instantiating the inode (v9fs_inode_from_fid)\n\t */\n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(is_uncached_acl(acl));\n\treturn acl;\n}\n\nstruct posix_acl *v9fs_iop_get_acl(struct inode *inode, int type)\n{\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\t/*\n\t\t * On access = client  and acl = on mode get the acl\n\t\t * values from the server\n\t\t */\n\t\treturn NULL;\n\t}\n\treturn v9fs_get_cached_acl(inode, type);\n\n}\n\nstatic int v9fs_set_acl(struct p9_fid *fid, int type, struct posix_acl *acl)\n{\n\tint retval;\n\tchar *name;\n\tsize_t size;\n\tvoid *buffer;\n\tif (!acl)\n\t\treturn 0;\n\n\t/* Set a setxattr request to server */\n\tsize = posix_acl_xattr_size(acl->a_count);\n\tbuffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tretval = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tif (retval < 0)\n\t\tgoto err_free_out;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_fid_xattr_set(fid, name, buffer, size, 0);\nerr_free_out:\n\tkfree(buffer);\n\treturn retval;\n}\n\nint v9fs_acl_chmod(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *acl;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tacl = v9fs_get_cached_acl(inode, ACL_TYPE_ACCESS);\n\tif (acl) {\n\t\tretval = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\tretval = v9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn retval;\n}\n\nint v9fs_set_create_acl(struct inode *inode, struct p9_fid *fid,\n\t\t\tstruct posix_acl *dacl, struct posix_acl *acl)\n{\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\tv9fs_set_acl(fid, ACL_TYPE_DEFAULT, dacl);\n\tv9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\treturn 0;\n}\n\nvoid v9fs_put_acl(struct posix_acl *dacl,\n\t\t  struct posix_acl *acl)\n{\n\tposix_acl_release(dacl);\n\tposix_acl_release(acl);\n}\n\nint v9fs_acl_mode(struct inode *dir, umode_t *modep,\n\t\t  struct posix_acl **dpacl, struct posix_acl **pacl)\n{\n\tint retval = 0;\n\tumode_t mode = *modep;\n\tstruct posix_acl *acl = NULL;\n\n\tif (!S_ISLNK(mode)) {\n\t\tacl = v9fs_get_cached_acl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\tif (!acl)\n\t\t\tmode &= ~current_umask();\n\t}\n\tif (acl) {\n\t\tif (S_ISDIR(mode))\n\t\t\t*dpacl = posix_acl_dup(acl);\n\t\tretval = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval > 0)\n\t\t\t*pacl = acl;\n\t\telse\n\t\t\tposix_acl_release(acl);\n\t}\n\t*modep  = mode;\n\treturn 0;\n}\n\nstatic int v9fs_xattr_get_acl(const struct xattr_handler *handler,\n\t\t\t      struct dentry *dentry, struct inode *inode,\n\t\t\t      const char *name, void *buffer, size_t size)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct posix_acl *acl;\n\tint error;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\t/*\n\t * We allow set/get/list of acl when access=client is not specified\n\t */\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)\n\t\treturn v9fs_xattr_get(dentry, handler->name, buffer, size);\n\n\tacl = v9fs_get_cached_acl(inode, handler->flags);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\terror = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}\n\nstatic int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n\t\t\t      struct dentry *dentry, struct inode *inode,\n\t\t\t      const char *name, const void *value,\n\t\t\t      size_t size, int flags)\n{\n\tint retval;\n\tstruct posix_acl *acl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\t/*\n\t * set the attribute on the remote. Without even looking at the\n\t * xattr value. We leave it to the server to validate\n\t */\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)\n\t\treturn v9fs_xattr_set(dentry, handler->name, value, size,\n\t\t\t\t      flags);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\tif (value) {\n\t\t/* update the cached acl value */\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\telse if (acl) {\n\t\t\tretval = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else\n\t\tacl = NULL;\n\n\tswitch (handler->flags) {\n\tcase ACL_TYPE_ACCESS:\n\t\tif (acl) {\n\t\t\tstruct iattr iattr;\n\n\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t\tif (!acl) {\n\t\t\t\t/*\n\t\t\t\t * ACL can be represented\n\t\t\t\t * by the mode bits. So don't\n\t\t\t\t * update ACL.\n\t\t\t\t */\n\t\t\t\tvalue = NULL;\n\t\t\t\tsize = 0;\n\t\t\t}\n\t\t\tiattr.ia_valid = ATTR_MODE;\n\t\t\t/* FIXME should we update ctime ?\n\t\t\t * What is the following setxattr update the\n\t\t\t * mode ?\n\t\t\t */\n\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tretval = acl ? -EINVAL : 0;\n\t\t\tgoto err_out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_xattr_set(dentry, handler->name, value, size, flags);\n\tif (!retval)\n\t\tset_cached_acl(inode, handler->flags, acl);\nerr_out:\n\tposix_acl_release(acl);\n\treturn retval;\n}\n\nconst struct xattr_handler v9fs_xattr_acl_access_handler = {\n\t.name\t= XATTR_NAME_POSIX_ACL_ACCESS,\n\t.flags\t= ACL_TYPE_ACCESS,\n\t.get\t= v9fs_xattr_get_acl,\n\t.set\t= v9fs_xattr_set_acl,\n};\n\nconst struct xattr_handler v9fs_xattr_acl_default_handler = {\n\t.name\t= XATTR_NAME_POSIX_ACL_DEFAULT,\n\t.flags\t= ACL_TYPE_DEFAULT,\n\t.get\t= v9fs_xattr_get_acl,\n\t.set\t= v9fs_xattr_set_acl,\n};\n", "/*\n * Copyright (C) 2007 Red Hat.  All rights reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License v2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 021110-1307, USA.\n */\n\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include \"ctree.h\"\n#include \"btrfs_inode.h\"\n#include \"xattr.h\"\n\nstruct posix_acl *btrfs_get_acl(struct inode *inode, int type)\n{\n\tint size;\n\tconst char *name;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = __btrfs_getxattr(inode, name, \"\", 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __btrfs_getxattr(inode, name, value, size);\n\t}\n\tif (size > 0) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t} else if (size == -ERANGE || size == -ENODATA || size == 0) {\n\t\tacl = NULL;\n\t} else {\n\t\tacl = ERR_PTR(-EIO);\n\t}\n\tkfree(value);\n\n\treturn acl;\n}\n\n/*\n * Needs to be called with fs_mutex held\n */\nstatic int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn ret;\n}\n\nint btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn __btrfs_set_acl(NULL, inode, acl, type);\n}\n\n/*\n * btrfs_init_acl is already generally called under fs_mutex, so the locking\n * stuff has been fixed to work with that.  If the locking stuff changes, we\n * need to re-evaluate the acl locking stuff.\n */\nint btrfs_init_acl(struct btrfs_trans_handle *trans,\n\t\t   struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint ret = 0;\n\n\t/* this happens with subvols */\n\tif (!dir)\n\t\treturn 0;\n\n\tret = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (default_acl) {\n\t\tret = __btrfs_set_acl(trans, inode, default_acl,\n\t\t\t\t      ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!ret)\n\t\t\tret = __btrfs_set_acl(trans, inode, acl,\n\t\t\t\t\t      ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (!default_acl && !acl)\n\t\tcache_no_acl(inode);\n\treturn ret;\n}\n", "/*\n * linux/fs/ceph/acl.c\n *\n * Copyright (C) 2013 Guangliang Zhao, <lucienchao@gmail.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License v2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 021110-1307, USA.\n */\n\n#include <linux/ceph/ceph_debug.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include \"super.h\"\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\telse\n\t\tforget_cached_acl(inode, type);\n\tspin_unlock(&ci->i_ceph_lock);\n}\n\nstruct posix_acl *ceph_get_acl(struct inode *inode, int type)\n{\n\tint size;\n\tconst char *name;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = __ceph_getxattr(inode, name, \"\", 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __ceph_getxattr(inode, name, value, size);\n\t}\n\n\tif (size > 0)\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\telse if (size == -ERANGE || size == -ENODATA || size == 0)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(-EIO);\n\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tceph_set_cached_acl(inode, type, acl);\n\n\treturn acl;\n}\n\nint ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_update_mode(inode, &new_mode, &acl);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = __ceph_setattr(inode, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tret = __ceph_setxattr(inode, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\t__ceph_setattr(inode, &newattrs);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tceph_set_cached_acl(inode, type, acl);\n\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}\n\nint ceph_pre_init_acls(struct inode *dir, umode_t *mode,\n\t\t       struct ceph_acls_info *info)\n{\n\tstruct posix_acl *acl, *default_acl;\n\tsize_t val_size1 = 0, val_size2 = 0;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tvoid *tmp_buf = NULL;\n\tint err;\n\n\terr = posix_acl_create(dir, mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (acl) {\n\t\tint ret = posix_acl_equiv_mode(acl, mode);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t\tif (ret == 0) {\n\t\t\tposix_acl_release(acl);\n\t\t\tacl = NULL;\n\t\t}\n\t}\n\n\tif (!default_acl && !acl)\n\t\treturn 0;\n\n\tif (acl)\n\t\tval_size1 = posix_acl_xattr_size(acl->a_count);\n\tif (default_acl)\n\t\tval_size2 = posix_acl_xattr_size(default_acl->a_count);\n\n\terr = -ENOMEM;\n\ttmp_buf = kmalloc(max(val_size1, val_size2), GFP_KERNEL);\n\tif (!tmp_buf)\n\t\tgoto out_err;\n\tpagelist = kmalloc(sizeof(struct ceph_pagelist), GFP_KERNEL);\n\tif (!pagelist)\n\t\tgoto out_err;\n\tceph_pagelist_init(pagelist);\n\n\terr = ceph_pagelist_reserve(pagelist, PAGE_SIZE);\n\tif (err)\n\t\tgoto out_err;\n\n\tceph_pagelist_encode_32(pagelist, acl && default_acl ? 2 : 1);\n\n\tif (acl) {\n\t\tsize_t len = strlen(XATTR_NAME_POSIX_ACL_ACCESS);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size1 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_string(pagelist, XATTR_NAME_POSIX_ACL_ACCESS,\n\t\t\t\t\t    len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl,\n\t\t\t\t\t tmp_buf, val_size1);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size1);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size1);\n\t}\n\tif (default_acl) {\n\t\tsize_t len = strlen(XATTR_NAME_POSIX_ACL_DEFAULT);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size2 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\terr = ceph_pagelist_encode_string(pagelist,\n\t\t\t\t\t\t  XATTR_NAME_POSIX_ACL_DEFAULT, len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, default_acl,\n\t\t\t\t\t tmp_buf, val_size2);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size2);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size2);\n\t}\n\n\tkfree(tmp_buf);\n\n\tinfo->acl = acl;\n\tinfo->default_acl = default_acl;\n\tinfo->pagelist = pagelist;\n\treturn 0;\n\nout_err:\n\tposix_acl_release(acl);\n\tposix_acl_release(default_acl);\n\tkfree(tmp_buf);\n\tif (pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}\n\nvoid ceph_init_inode_acls(struct inode* inode, struct ceph_acls_info *info)\n{\n\tif (!inode)\n\t\treturn;\n\tceph_set_cached_acl(inode, ACL_TYPE_ACCESS, info->acl);\n\tceph_set_cached_acl(inode, ACL_TYPE_DEFAULT, info->default_acl);\n}\n\nvoid ceph_release_acls_info(struct ceph_acls_info *info)\n{\n\tposix_acl_release(info->acl);\n\tposix_acl_release(info->default_acl);\n\tif (info->pagelist)\n\t\tceph_pagelist_release(info->pagelist);\n}\n", "/*\n * linux/fs/ext2/acl.c\n *\n * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>\n */\n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n/*\n * Convert from filesystem to in-memory representation.\n */\nstatic struct posix_acl *\next2_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(ext2_acl_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (((ext2_acl_header *)value)->a_version !=\n\t    cpu_to_le32(EXT2_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(ext2_acl_header);\n\tcount = ext2_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n=0; n < count; n++) {\n\t\text2_acl_entry *entry =\n\t\t\t(ext2_acl_entry *)value;\n\t\tif ((char *)value + sizeof(ext2_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tvalue = (char *)value +\n\t\t\t\t\tsizeof(ext2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tvalue = (char *)value + sizeof(ext2_acl_entry);\n\t\t\t\tif ((char *)value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tvalue = (char *)value + sizeof(ext2_acl_entry);\n\t\t\t\tif ((char *)value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * Convert from in-memory to filesystem representation.\n */\nstatic void *\next2_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\text2_acl_header *ext_acl;\n\tchar *e;\n\tsize_t n;\n\n\t*size = ext2_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(ext2_acl_header) + acl->a_count *\n\t\t\tsizeof(ext2_acl_entry), GFP_KERNEL);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(EXT2_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(ext2_acl_header);\n\tfor (n=0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text2_acl_entry *entry = (ext2_acl_entry *)e;\n\t\tentry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER:\n\t\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\t\te += sizeof(ext2_acl_entry);\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\t\te += sizeof(ext2_acl_entry);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\te += sizeof(ext2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * inode->i_mutex: don't care\n */\nstruct posix_acl *\next2_get_acl(struct inode *inode, int type)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = ext2_xattr_get(inode, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ext2_xattr_get(inode, name_index, \"\", value, retval);\n\t}\n\tif (retval > 0)\n\t\tacl = ext2_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA || retval == -ENOSYS)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\treturn acl;\n}\n\n/*\n * inode->i_mutex: down\n */\nint\next2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\t\tif (acl) {\n\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\treturn acl ? -EACCES : 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n \tif (acl) {\n\t\tvalue = ext2_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n\n/*\n * Initialize the ACLs of a new inode. Called from ext2_new_inode.\n *\n * dir->i_mutex: down\n * inode->i_mutex: up (access to inode is still exclusive)\n */\nint\next2_init_acl(struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = ext2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = ext2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\treturn error;\n}\n", "/*\n * linux/fs/ext4/acl.c\n *\n * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>\n */\n\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n/*\n * Convert from filesystem to in-memory representation.\n */\nstatic struct posix_acl *\next4_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(ext4_acl_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (((ext4_acl_header *)value)->a_version !=\n\t    cpu_to_le32(EXT4_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(ext4_acl_header);\n\tcount = ext4_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\text4_acl_entry *entry =\n\t\t\t(ext4_acl_entry *)value;\n\t\tif ((char *)value + sizeof(ext4_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t\tsizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * Convert from in-memory to filesystem representation.\n */\nstatic void *\next4_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\text4_acl_header *ext_acl;\n\tchar *e;\n\tsize_t n;\n\n\t*size = ext4_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(ext4_acl_header) + acl->a_count *\n\t\t\tsizeof(ext4_acl_entry), GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(EXT4_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(ext4_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text4_acl_entry *entry = (ext4_acl_entry *)e;\n\t\tentry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * Inode operation get_posix_acl().\n *\n * inode->i_mutex: don't care\n */\nstruct posix_acl *\next4_get_acl(struct inode *inode, int type)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = ext4_xattr_get(inode, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ext4_xattr_get(inode, name_index, \"\", value, retval);\n\t}\n\tif (retval > 0)\n\t\tacl = ext4_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA || retval == -ENOSYS)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\treturn acl;\n}\n\n/*\n * Set the access or default ACL of an inode.\n *\n * inode->i_mutex: down unless called from ext4_new_inode\n */\nstatic int\n__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}\n\nint\next4_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\thandle_t *handle;\n\tint error, retries = 0;\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_XATTR,\n\t\t\t\t    ext4_jbd2_credits_xattr(inode));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terror = __ext4_set_acl(handle, inode, type, acl);\n\text4_journal_stop(handle);\n\tif (error == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\treturn error;\n}\n\n/*\n * Initialize the ACLs of a new inode. Called from ext4_new_inode.\n *\n * dir->i_mutex: down\n * inode->i_mutex: up (access to inode is still exclusive)\n */\nint\next4_init_acl(handle_t *handle, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __ext4_set_acl(handle, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t       default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __ext4_set_acl(handle, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t       acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn error;\n}\n", "/*\n * fs/f2fs/acl.c\n *\n * Copyright (c) 2012 Samsung Electronics Co., Ltd.\n *             http://www.samsung.com/\n *\n * Portions of this code from linux/fs/ext2/acl.c\n *\n * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n#include <linux/f2fs_fs.h>\n#include \"f2fs.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstatic inline size_t f2fs_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\tcount * sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\t4 * sizeof(struct f2fs_acl_entry_short) +\n\t\t\t(count - 4) * sizeof(struct f2fs_acl_entry);\n\t}\n}\n\nstatic inline int f2fs_acl_count(size_t size)\n{\n\tssize_t s;\n\tsize -= sizeof(struct f2fs_acl_header);\n\ts = size - 4 * sizeof(struct f2fs_acl_entry_short);\n\tif (s < 0) {\n\t\tif (size % sizeof(struct f2fs_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\tif (s % sizeof(struct f2fs_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(struct f2fs_acl_entry) + 4;\n\t}\n}\n\nstatic struct posix_acl *f2fs_acl_from_disk(const char *value, size_t size)\n{\n\tint i, count;\n\tstruct posix_acl *acl;\n\tstruct f2fs_acl_header *hdr = (struct f2fs_acl_header *)value;\n\tstruct f2fs_acl_entry *entry = (struct f2fs_acl_entry *)(hdr + 1);\n\tconst char *end = value + size;\n\n\tif (hdr->a_version != cpu_to_le32(F2FS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = f2fs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\n\t\tif ((char *)entry > end)\n\t\t\tgoto fail;\n\n\t\tacl->a_entries[i].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[i].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[i].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[i].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif ((char *)entry != end)\n\t\tgoto fail;\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void *f2fs_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\tstruct f2fs_acl_header *f2fs_acl;\n\tstruct f2fs_acl_entry *entry;\n\tint i;\n\n\tf2fs_acl = f2fs_kmalloc(sizeof(struct f2fs_acl_header) + acl->a_count *\n\t\t\tsizeof(struct f2fs_acl_entry), GFP_NOFS);\n\tif (!f2fs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_acl->a_version = cpu_to_le32(F2FS_ACL_VERSION);\n\tentry = (struct f2fs_acl_entry *)(f2fs_acl + 1);\n\n\tfor (i = 0; i < acl->a_count; i++) {\n\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[i].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[i].e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_uid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_gid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*size = f2fs_acl_size(acl->a_count);\n\treturn (void *)f2fs_acl;\n\nfail:\n\tkfree(f2fs_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct posix_acl *__f2fs_get_acl(struct inode *inode, int type,\n\t\t\t\t\t\tstruct page *dpage)\n{\n\tint name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tif (type == ACL_TYPE_ACCESS)\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\n\tretval = f2fs_getxattr(inode, name_index, \"\", NULL, 0, dpage);\n\tif (retval > 0) {\n\t\tvalue = f2fs_kmalloc(retval, GFP_F2FS_ZERO);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = f2fs_getxattr(inode, name_index, \"\", value,\n\t\t\t\t\t\t\tretval, dpage);\n\t}\n\n\tif (retval > 0)\n\t\tacl = f2fs_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\treturn acl;\n}\n\nstruct posix_acl *f2fs_get_acl(struct inode *inode, int type)\n{\n\treturn __f2fs_get_acl(inode, type, NULL);\n}\n\nstatic int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\tclear_inode_flag(inode, FI_ACL_MODE);\n\treturn error;\n}\n\nint f2fs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn __f2fs_set_acl(inode, type, acl, NULL);\n}\n\n/*\n * Most part of f2fs_acl_clone, f2fs_acl_create_masq, f2fs_acl_create\n * are copied from posix_acl.c\n */\nstatic struct posix_acl *f2fs_acl_clone(const struct posix_acl *acl,\n\t\t\t\t\t\t\tgfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t\t\tsizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\tatomic_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}\n\nstatic int f2fs_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tgroup_obj = pa;\n\t\t\tbreak;\n\n\t\tcase ACL_OTHER:\n\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n\t\t\tbreak;\n\n\t\tcase ACL_MASK:\n\t\t\tmask_obj = pa;\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\n\nstatic int f2fs_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl,\n\t\tstruct page *dpage)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = __f2fs_get_acl(dir, ACL_TYPE_DEFAULT, dpage);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tclone = f2fs_acl_clone(p, GFP_NOFS);\n\tif (!clone)\n\t\tgoto no_mem;\n\n\tret = f2fs_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(clone);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}\n\nint f2fs_init_acl(struct inode *inode, struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tstruct page *dpage)\n{\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tint error = 0;\n\n\terror = f2fs_acl_create(dir, &inode->i_mode, &default_acl, &acl, dpage);\n\tif (error)\n\t\treturn error;\n\n\tf2fs_mark_inode_dirty_sync(inode);\n\n\tif (default_acl) {\n\t\terror = __f2fs_set_acl(inode, ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       ipage);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __f2fs_set_acl(inode, ACL_TYPE_ACCESS, acl,\n\t\t\t\t\t       ipage);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn error;\n}\n", "/*\n * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.\n * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.\n *\n * This copyrighted material is made available to anyone wishing to use,\n * modify, copy, or redistribute it subject to the terms and conditions\n * of the GNU General Public License version 2.\n */\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"glock.h\"\n#include \"inode.h\"\n#include \"meta_io.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"util.h\"\n\nstatic const char *gfs2_acl_name(int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn XATTR_POSIX_ACL_ACCESS;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn XATTR_POSIX_ACL_DEFAULT;\n\t}\n\treturn NULL;\n}\n\nstatic struct posix_acl *__gfs2_get_acl(struct inode *inode, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct posix_acl *acl;\n\tconst char *name;\n\tchar *data;\n\tint len;\n\n\tif (!ip->i_eattr)\n\t\treturn NULL;\n\n\tname = gfs2_acl_name(type);\n\tlen = gfs2_xattr_acl_get(ip, name, &data);\n\tif (len <= 0)\n\t\treturn ERR_PTR(len);\n\tacl = posix_acl_from_xattr(&init_user_ns, data, len);\n\tkfree(data);\n\treturn acl;\n}\n\nstruct posix_acl *gfs2_get_acl(struct inode *inode, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tbool need_unlock = false;\n\tstruct posix_acl *acl;\n\n\tif (!gfs2_glock_is_locked_by_me(ip->i_gl)) {\n\t\tint ret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t     LM_FLAG_ANY, &gh);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tneed_unlock = true;\n\t}\n\tacl = __gfs2_get_acl(inode, type);\n\tif (need_unlock)\n\t\tgfs2_glock_dq_uninit(&gh);\n\treturn acl;\n}\n\nint __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tint len;\n\tchar *data;\n\tconst char *name = gfs2_acl_name(type);\n\n\tif (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))\n\t\treturn -E2BIG;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (mode != inode->i_mode)\n\t\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (acl) {\n\t\tlen = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tdata = kmalloc(len, GFP_NOFS);\n\t\tif (data == NULL)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, data, len);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\n\terror = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);\n\tif (error)\n\t\tgoto out;\n\tset_cached_acl(inode, type, acl);\nout:\n\tkfree(data);\n\treturn error;\n}\n\nint gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tbool need_unlock = false;\n\tint ret;\n\n\tret = gfs2_rsqa_alloc(ip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!gfs2_glock_is_locked_by_me(ip->i_gl)) {\n\t\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tneed_unlock = true;\n\t}\n\tret = __gfs2_set_acl(inode, acl, type);\n\tif (need_unlock)\n\t\tgfs2_glock_dq_uninit(&gh);\n\treturn ret;\n}\n", "/*\n * linux/fs/hfsplus/posix_acl.c\n *\n * Vyacheslav Dubeyko <slava@dubeyko.com>\n *\n * Handler for Posix Access Control Lists (ACLs) support.\n */\n\n#include \"hfsplus_fs.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstruct posix_acl *hfsplus_get_posix_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tchar *xattr_name;\n\tchar *value = NULL;\n\tssize_t size;\n\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsize = __hfsplus_getxattr(inode, xattr_name, NULL, 0);\n\n\tif (size > 0) {\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __hfsplus_getxattr(inode, xattr_name, value, size);\n\t}\n\n\tif (size > 0)\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\telse if (size == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(size);\n\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\treturn acl;\n}\n\nint hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\n\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn err;\n}\n\nint hfsplus_init_posix_acl(struct inode *inode, struct inode *dir)\n{\n\tint err = 0;\n\tstruct posix_acl *default_acl, *acl;\n\n\thfs_dbg(ACL_MOD,\n\t\t\"[%s]: ino %lu, dir->ino %lu\\n\",\n\t\t__func__, inode->i_ino, dir->i_ino);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = hfsplus_set_posix_acl(inode, default_acl,\n\t\t\t\t\t    ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = hfsplus_set_posix_acl(inode, acl,\n\t\t\t\t\t\t    ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\treturn err;\n}\n", "/*\n * JFFS2 -- Journalling Flash File System, Version 2.\n *\n * Copyright \u00a9 2006  NEC Corporation\n *\n * Created by KaiGai Kohei <kaigai@ak.jp.nec.com>\n *\n * For licensing information, see the file 'LICENCE' in this directory.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/jffs2.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/mtd/mtd.h>\n#include \"nodelist.h\"\n\nstatic size_t jffs2_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(struct jffs2_acl_header)\n\t\t       + count * sizeof(struct jffs2_acl_entry_short);\n\t} else {\n\t\treturn sizeof(struct jffs2_acl_header)\n\t\t       + 4 * sizeof(struct jffs2_acl_entry_short)\n\t\t       + (count - 4) * sizeof(struct jffs2_acl_entry);\n\t}\n}\n\nstatic int jffs2_acl_count(size_t size)\n{\n\tsize_t s;\n\n\tsize -= sizeof(struct jffs2_acl_header);\n\tif (size < 4 * sizeof(struct jffs2_acl_entry_short)) {\n\t\tif (size % sizeof(struct jffs2_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(struct jffs2_acl_entry_short);\n\t} else {\n\t\ts = size - 4 * sizeof(struct jffs2_acl_entry_short);\n\t\tif (s % sizeof(struct jffs2_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(struct jffs2_acl_entry) + 4;\n\t}\n}\n\nstatic struct posix_acl *jffs2_acl_from_medium(void *value, size_t size)\n{\n\tvoid *end = value + size;\n\tstruct jffs2_acl_header *header = value;\n\tstruct jffs2_acl_entry *entry;\n\tstruct posix_acl *acl;\n\tuint32_t ver;\n\tint i, count;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct jffs2_acl_header))\n\t\treturn ERR_PTR(-EINVAL);\n\tver = je32_to_cpu(header->a_version);\n\tif (ver != JFFS2_ACL_VERSION) {\n\t\tJFFS2_WARNING(\"Invalid ACL version. (=%u)\\n\", ver);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tvalue += sizeof(struct jffs2_acl_header);\n\tcount = jffs2_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i=0; i < count; i++) {\n\t\tentry = value;\n\t\tif (value + sizeof(struct jffs2_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[i].e_tag = je16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[i].e_perm = je16_to_cpu(entry->e_perm);\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tvalue += sizeof(struct jffs2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tvalue += sizeof(struct jffs2_acl_entry);\n\t\t\t\tif (value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[i].e_uid =\n\t\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\t  je32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tvalue += sizeof(struct jffs2_acl_entry);\n\t\t\t\tif (value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[i].e_gid =\n\t\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\t  je32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n fail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void *jffs2_acl_to_medium(const struct posix_acl *acl, size_t *size)\n{\n\tstruct jffs2_acl_header *header;\n\tstruct jffs2_acl_entry *entry;\n\tvoid *e;\n\tsize_t i;\n\n\t*size = jffs2_acl_size(acl->a_count);\n\theader = kmalloc(sizeof(*header) + acl->a_count * sizeof(*entry), GFP_KERNEL);\n\tif (!header)\n\t\treturn ERR_PTR(-ENOMEM);\n\theader->a_version = cpu_to_je32(JFFS2_ACL_VERSION);\n\te = header + 1;\n\tfor (i=0; i < acl->a_count; i++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[i];\n\t\tentry = e;\n\t\tentry->e_tag = cpu_to_je16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_je16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER:\n\t\t\t\tentry->e_id = cpu_to_je32(\n\t\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\t\te += sizeof(struct jffs2_acl_entry);\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tentry->e_id = cpu_to_je32(\n\t\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\t\te += sizeof(struct jffs2_acl_entry);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\te += sizeof(struct jffs2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn header;\n fail:\n\tkfree(header);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstruct posix_acl *jffs2_get_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tchar *value = NULL;\n\tint rc, xprefix;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\trc = do_jffs2_getxattr(inode, xprefix, \"\", NULL, 0);\n\tif (rc > 0) {\n\t\tvalue = kmalloc(rc, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\trc = do_jffs2_getxattr(inode, xprefix, \"\", value, rc);\n\t}\n\tif (rc > 0) {\n\t\tacl = jffs2_acl_from_medium(value, rc);\n\t} else if (rc == -ENODATA || rc == -ENOSYS) {\n\t\tacl = NULL;\n\t} else {\n\t\tacl = ERR_PTR(rc);\n\t}\n\tkfree(value);\n\treturn acl;\n}\n\nstatic int __jffs2_set_acl(struct inode *inode, int xprefix, struct posix_acl *acl)\n{\n\tchar *value = NULL;\n\tsize_t size = 0;\n\tint rc;\n\n\tif (acl) {\n\t\tvalue = jffs2_acl_to_medium(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn PTR_ERR(value);\n\t}\n\trc = do_jffs2_setxattr(inode, xprefix, \"\", value, size, 0);\n\tif (!value && rc == -ENODATA)\n\t\trc = 0;\n\tkfree(value);\n\n\treturn rc;\n}\n\nint jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode;\n\n\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}\n\nint jffs2_init_acl_pre(struct inode *dir_i, struct inode *inode, umode_t *i_mode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint rc;\n\n\tcache_no_acl(inode);\n\n\trc = posix_acl_create(dir_i, i_mode, &default_acl, &acl);\n\tif (rc)\n\t\treturn rc;\n\n\tif (default_acl) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn 0;\n}\n\nint jffs2_init_acl_post(struct inode *inode)\n{\n\tint rc;\n\n\tif (inode->i_default_acl) {\n\t\trc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_DEFAULT, inode->i_default_acl);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (inode->i_acl) {\n\t\trc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_ACCESS, inode->i_acl);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n", "/*\n *   Copyright (C) International Business Machines  Corp., 2002-2004\n *   Copyright (C) Andreas Gruenbacher, 2001\n *   Copyright (C) Linus Torvalds, 1991, 1992\n *\n *   This program is free software;  you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY;  without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program;  if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/posix_acl_xattr.h>\n#include \"jfs_incore.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_acl.h\"\n\nstruct posix_acl *jfs_get_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tchar *ea_name;\n\tint size;\n\tchar *value = NULL;\n\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\t\tbreak;\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsize = __jfs_getxattr(inode, ea_name, NULL, 0);\n\n\tif (size > 0) {\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __jfs_getxattr(inode, ea_name, value, size);\n\t}\n\n\tif (size < 0) {\n\t\tif (size == -ENODATA)\n\t\t\tacl = NULL;\n\t\telse\n\t\t\tacl = ERR_PTR(size);\n\t} else {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t}\n\tkfree(value);\n\treturn acl;\n}\n\nstatic int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn rc;\n}\n\nint jfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc;\n\ttid_t tid;\n\n\ttid = txBegin(inode->i_sb, 0);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\trc = __jfs_set_acl(tid, inode, type, acl);\n\tif (!rc)\n\t\trc = txCommit(tid, 1, &inode, 0);\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}\n\nint jfs_init_acl(tid_t tid, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint rc = 0;\n\n\trc = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (rc)\n\t\treturn rc;\n\n\tif (default_acl) {\n\t\trc = __jfs_set_acl(tid, inode, ACL_TYPE_DEFAULT, default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!rc)\n\t\t\trc = __jfs_set_acl(tid, inode, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\n\tJFS_IP(inode)->mode2 = (JFS_IP(inode)->mode2 & 0xffff0000) |\n\t\t\t       inode->i_mode;\n\n\treturn rc;\n}\n", "/* -*- mode: c; c-basic-offset: 8; -*-\n * vim: noexpandtab sw=8 ts=8 sts=0:\n *\n * acl.c\n *\n * Copyright (C) 2004, 2008 Oracle.  All rights reserved.\n *\n * CREDITS:\n * Lots of code in this file is copy from linux/fs/ext3/acl.c.\n * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License version 2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n */\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n#include \"alloc.h\"\n#include \"dlmglue.h\"\n#include \"file.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"ocfs2_fs.h\"\n\n#include \"xattr.h\"\n#include \"acl.h\"\n\n/*\n * Convert from xattr value to acl struct.\n */\nstatic struct posix_acl *ocfs2_acl_from_xattr(const void *value, size_t size)\n{\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_entry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = size / sizeof(struct posix_acl_entry);\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\tstruct ocfs2_acl_entry *entry =\n\t\t\t(struct ocfs2_acl_entry *)value;\n\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tvalue += sizeof(struct posix_acl_entry);\n\n\t}\n\treturn acl;\n}\n\n/*\n * Convert acl struct to xattr value.\n */\nstatic void *ocfs2_acl_to_xattr(const struct posix_acl *acl, size_t *size)\n{\n\tstruct ocfs2_acl_entry *entry = NULL;\n\tchar *ocfs2_acl;\n\tsize_t n;\n\n\t*size = acl->a_count * sizeof(struct posix_acl_entry);\n\n\tocfs2_acl = kmalloc(*size, GFP_NOFS);\n\tif (!ocfs2_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tentry = (struct ocfs2_acl_entry *)ocfs2_acl;\n\tfor (n = 0; n < acl->a_count; n++, entry++) {\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ocfs2_acl;\n}\n\nstatic struct posix_acl *ocfs2_get_acl_nolock(struct inode *inode,\n\t\t\t\t\t      int type,\n\t\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t\t\t\"\", value, retval);\n\t}\n\n\tif (retval > 0)\n\t\tacl = ocfs2_acl_from_xattr(value, retval);\n\telse if (retval == -ENODATA || retval == 0)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\n\tkfree(value);\n\n\treturn acl;\n}\n\n/*\n * Helper function to set i_mode in memory and disk. Some call paths\n * will not have di_bh or a journal handle to pass, in which case it\n * will create it's own.\n */\nstatic int ocfs2_acl_set_mode(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t      handle_t *handle, umode_t new_mode)\n{\n\tint ret, commit_handle = 0;\n\tstruct ocfs2_dinode *di;\n\n\tif (di_bh == NULL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tget_bh(di_bh);\n\n\tif (handle == NULL) {\n\t\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_brelse;\n\t\t}\n\n\t\tcommit_handle = 1;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode->i_mode = new_mode;\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tif (commit_handle)\n\t\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout_brelse:\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}\n\n/*\n * Set the access or default ACL of an inode.\n */\nint ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode;\n\n\t\t\tret = posix_acl_update_mode(inode, &mode, &acl);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\n\treturn ret;\n}\n\nint ocfs2_iop_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct buffer_head *bh = NULL;\n\tint status = 0;\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_set_acl(NULL, inode, bh, type, acl, NULL, NULL);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(bh);\n\treturn status;\n}\n\nstruct posix_acl *ocfs2_iop_get_acl(struct inode *inode, int type)\n{\n\tstruct ocfs2_super *osb;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct posix_acl *acl;\n\tint ret;\n\n\tosb = OCFS2_SB(inode->i_sb);\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL))\n\t\treturn NULL;\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tif (ret != -ENOENT)\n\t\t\tmlog_errno(ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tacl = ocfs2_get_acl_nolock(inode, type, di_bh);\n\n\tocfs2_inode_unlock(inode, 0);\n\tbrelse(di_bh);\n\treturn acl;\n}\n\nint ocfs2_acl_chmod(struct inode *inode, struct buffer_head *bh)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct posix_acl *acl;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL))\n\t\treturn 0;\n\n\tacl = ocfs2_get_acl_nolock(inode, ACL_TYPE_ACCESS, bh);\n\tif (IS_ERR(acl) || !acl)\n\t\treturn PTR_ERR(acl);\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\tif (ret)\n\t\treturn ret;\n\tret = ocfs2_set_acl(NULL, inode, NULL, ACL_TYPE_ACCESS,\n\t\t\t    acl, NULL, NULL);\n\tposix_acl_release(acl);\n\treturn ret;\n}\n\n/*\n * Initialize the ACLs of a new inode. If parent directory has default ACL,\n * then clone to new inode. Called from ocfs2_mknod.\n */\nint ocfs2_init_acl(handle_t *handle,\n\t\t   struct inode *inode,\n\t\t   struct inode *dir,\n\t\t   struct buffer_head *di_bh,\n\t\t   struct buffer_head *dir_bh,\n\t\t   struct ocfs2_alloc_context *meta_ac,\n\t\t   struct ocfs2_alloc_context *data_ac)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct posix_acl *acl = NULL;\n\tint ret = 0, ret2;\n\tumode_t mode;\n\n\tif (!S_ISLNK(inode->i_mode)) {\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) {\n\t\t\tacl = ocfs2_get_acl_nolock(dir, ACL_TYPE_DEFAULT,\n\t\t\t\t\t\t   dir_bh);\n\t\t\tif (IS_ERR(acl))\n\t\t\t\treturn PTR_ERR(acl);\n\t\t}\n\t\tif (!acl) {\n\t\t\tmode = inode->i_mode & ~current_umask();\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh, handle, mode);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) && acl) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tret = ocfs2_set_acl(handle, inode, di_bh,\n\t\t\t\t\t    ACL_TYPE_DEFAULT, acl,\n\t\t\t\t\t    meta_ac, data_ac);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tmode = inode->i_mode;\n\t\tret = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret2 = ocfs2_acl_set_mode(inode, di_bh, handle, mode);\n\t\tif (ret2) {\n\t\t\tmlog_errno(ret2);\n\t\t\tret = ret2;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tret = ocfs2_set_acl(handle, inode,\n\t\t\t\t\t    di_bh, ACL_TYPE_ACCESS,\n\t\t\t\t\t    acl, meta_ac, data_ac);\n\t\t}\n\t}\ncleanup:\n\tposix_acl_release(acl);\n\treturn ret;\n}\n", "/*\n * (C) 2001 Clemson University and The University of Chicago\n *\n * See COPYING in top-level directory.\n */\n\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-bufmap.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/fs_struct.h>\n\nstruct posix_acl *orangefs_get_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tint ret;\n\tchar *key = NULL, *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tkey = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tkey = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"orangefs_get_acl: bogus value of type %d\\n\", type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t/*\n\t * Rather than incurring a network call just to determine the exact\n\t * length of the attribute, I just allocate a max length to save on\n\t * the network call. Conceivably, we could pass NULL to\n\t * orangefs_inode_getxattr() to probe the length of the value, but\n\t * I don't do that for now.\n\t */\n\tvalue = kmalloc(ORANGEFS_MAX_XATTR_VALUELEN, GFP_KERNEL);\n\tif (value == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"inode %pU, key %s, type %d\\n\",\n\t\t     get_khandle_from_ino(inode),\n\t\t     key,\n\t\t     type);\n\tret = orangefs_inode_getxattr(inode, key, value,\n\t\t\t\t      ORANGEFS_MAX_XATTR_VALUELEN);\n\t/* if the key exists, convert it to an in-memory rep */\n\tif (ret > 0) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, ret);\n\t} else if (ret == -ENODATA || ret == -ENOSYS) {\n\t\tacl = NULL;\n\t} else {\n\t\tgossip_err(\"inode %pU retrieving acl's failed with error %d\\n\",\n\t\t\t   get_khandle_from_ino(inode),\n\t\t\t   ret);\n\t\tacl = ERR_PTR(ret);\n\t}\n\t/* kfree(NULL) is safe, so don't worry if value ever got used */\n\tkfree(value);\n\treturn acl;\n}\n\nint orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tint error = 0;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tconst char *name = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode;\n\n\t\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n\t\t\tif (error) {\n\t\t\t\tgossip_err(\"%s: posix_acl_update_mode err: %d\\n\",\n\t\t\t\t\t   __func__,\n\t\t\t\t\t   error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tif (inode->i_mode != mode)\n\t\t\t\tSetModeFlag(orangefs_inode);\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"%s: invalid type %d!\\n\", __func__, type);\n\t\treturn -EINVAL;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: inode %pU, key %s type %d\\n\",\n\t\t     __func__, get_khandle_from_ino(inode),\n\t\t     name,\n\t\t     type);\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: name %s, value %p, size %zd, acl %p\\n\",\n\t\t     __func__, name, value, size, acl);\n\t/*\n\t * Go ahead and set the extended attribute now. NOTE: Suppose acl\n\t * was NULL, then value will be NULL and size will be 0 and that\n\t * will xlate to a removexattr. However, we don't want removexattr\n\t * complain if attributes does not exist.\n\t */\n\terror = orangefs_inode_setxattr(inode, name, value, size, 0);\n\nout:\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n\nint orangefs_init_acl(struct inode *inode, struct inode *dir)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct posix_acl *default_acl, *acl;\n\tumode_t mode = inode->i_mode;\n\tint error = 0;\n\n\tClearModeFlag(orangefs_inode);\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = orangefs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = orangefs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\t/* If mode of the inode was changed, then do a forcible ->setattr */\n\tif (mode != inode->i_mode) {\n\t\tSetModeFlag(orangefs_inode);\n\t\tinode->i_mode = mode;\n\t\torangefs_flush_inode(inode);\n\t}\n\n\treturn error;\n}\n", "/*\n * Copyright (C) 2002,2003 by Andreas Gruenbacher <a.gruenbacher@computer.org>\n *\n * Fixes from William Schumacher incorporated on 15 March 2001.\n *    (Reported by Charles Bertsch, <CBertsch@microtest.com>).\n */\n\n/*\n *  This file contains generic functions for manipulating\n *  POSIX 1003.1e draft standard 17 ACLs.\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/export.h>\n#include <linux/user_namespace.h>\n\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstruct posix_acl *get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *acl;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tacl = rcu_dereference(*p);\n\t\tif (!acl || is_uncached_acl(acl) ||\n\t\t    atomic_inc_not_zero(&acl->a_refcount))\n\t\t\tbreak;\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t}\n\trcu_read_unlock();\n\treturn acl;\n}\nEXPORT_SYMBOL(get_cached_acl);\n\nstruct posix_acl *get_cached_acl_rcu(struct inode *inode, int type)\n{\n\treturn rcu_dereference(*acl_by_type(inode, type));\n}\nEXPORT_SYMBOL(get_cached_acl_rcu);\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}\nEXPORT_SYMBOL(set_cached_acl);\n\nstatic void __forget_cached_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *old;\n\n\told = xchg(p, ACL_NOT_CACHED);\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}\n\nvoid forget_cached_acl(struct inode *inode, int type)\n{\n\t__forget_cached_acl(acl_by_type(inode, type));\n}\nEXPORT_SYMBOL(forget_cached_acl);\n\nvoid forget_all_cached_acls(struct inode *inode)\n{\n\t__forget_cached_acl(&inode->i_acl);\n\t__forget_cached_acl(&inode->i_default_acl);\n}\nEXPORT_SYMBOL(forget_all_cached_acls);\n\nstruct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}\nEXPORT_SYMBOL(get_acl);\n\n/*\n * Init a fresh posix_acl\n */\nvoid\nposix_acl_init(struct posix_acl *acl, int count)\n{\n\tatomic_set(&acl->a_refcount, 1);\n\tacl->a_count = count;\n}\nEXPORT_SYMBOL(posix_acl_init);\n\n/*\n * Allocate a new ACL with the specified number of entries.\n */\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}\nEXPORT_SYMBOL(posix_acl_alloc);\n\n/*\n * Clone an ACL.\n */\nstatic struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\tatomic_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}\n\n/*\n * Check if an acl is valid. Returns 0 if it is, or -E... otherwise.\n */\nint\nposix_acl_valid(struct user_namespace *user_ns, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tint state = ACL_USER_OBJ;\n\tint needs_mask = 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\n\t\t\treturn -EINVAL;\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tif (state == ACL_USER_OBJ) {\n\t\t\t\t\tstate = ACL_USER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tif (state != ACL_USER)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kuid_has_mapping(user_ns, pa->e_uid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tif (state == ACL_USER) {\n\t\t\t\t\tstate = ACL_GROUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kgid_has_mapping(user_ns, pa->e_gid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tstate = ACL_OTHER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tif (state == ACL_OTHER ||\n\t\t\t\t    (state == ACL_GROUP && !needs_mask)) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (state == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(posix_acl_valid);\n\n/*\n * Returns 0 if the acl can be exactly represented in the traditional\n * file mode permission bits, or else 1. Returns -E... on error.\n */\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\nEXPORT_SYMBOL(posix_acl_equiv_mode);\n\n/*\n * Create an ACL representing the file mode permission bits of an inode.\n */\nstruct posix_acl *\nposix_acl_from_mode(umode_t mode, gfp_t flags)\n{\n\tstruct posix_acl *acl = posix_acl_alloc(3, flags);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tacl->a_entries[0].e_tag  = ACL_USER_OBJ;\n\tacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\n\n\tacl->a_entries[1].e_tag  = ACL_GROUP_OBJ;\n\tacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\n\n\tacl->a_entries[2].e_tag  = ACL_OTHER;\n\tacl->a_entries[2].e_perm = (mode & S_IRWXO);\n\treturn acl;\n}\nEXPORT_SYMBOL(posix_acl_from_mode);\n\n/*\n * Return 0 if current is granted want access to the inode\n * by the acl. Returns -E... otherwise.\n */\nint\nposix_acl_permission(struct inode *inode, const struct posix_acl *acl, int want)\n{\n\tconst struct posix_acl_entry *pa, *pe, *mask_obj;\n\tint found = 0;\n\n\twant &= MAY_READ | MAY_WRITE | MAY_EXEC | MAY_NOT_BLOCK;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\t/* (May have been checked already) */\n\t\t\t\tif (uid_eq(inode->i_uid, current_fsuid()))\n                                        goto check_perm;\n                                break;\n                        case ACL_USER:\n\t\t\t\tif (uid_eq(pa->e_uid, current_fsuid()))\n                                        goto mask;\n\t\t\t\tbreak;\n                        case ACL_GROUP_OBJ:\n                                if (in_group_p(inode->i_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n\t\t\t\tbreak;\n                        case ACL_GROUP:\n\t\t\t\tif (in_group_p(pa->e_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n                                break;\n                        case ACL_MASK:\n                                break;\n                        case ACL_OTHER:\n\t\t\t\tif (found)\n\t\t\t\t\treturn -EACCES;\n\t\t\t\telse\n\t\t\t\t\tgoto check_perm;\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\treturn -EIO;\n\nmask:\n\tfor (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\n\t\tif (mask_obj->e_tag == ACL_MASK) {\n\t\t\tif ((pa->e_perm & mask_obj->e_perm & want) == want)\n\t\t\t\treturn 0;\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\ncheck_perm:\n\tif ((pa->e_perm & want) == want)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\n/*\n * Modify acl when creating a new inode. The caller must ensure the acl is\n * only referenced once.\n *\n * mode_p initially must contain the mode parameter to the open() / creat()\n * system calls. All permissions that are not granted by the acl are removed.\n * The permissions in the acl are changed to reflect the mode_p parameter.\n */\nstatic int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\n                        case ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n                                break;\n\n                        case ACL_OTHER:\n\t\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n                                break;\n\n                        case ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tnot_equiv = 1;\n                                break;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\n\n/*\n * Modify the ACL for the chmod syscall.\n */\nstatic int __posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\n{\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpa->e_perm = (mode & S_IRWXU) >> 6;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpa->e_perm = (mode & S_IRWXO);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t}\n\n\treturn 0;\n}\n\nint\n__posix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = posix_acl_create_masq(clone, mode_p);\n\t\tif (err < 0) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}\nEXPORT_SYMBOL(__posix_acl_create);\n\nint\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = __posix_acl_chmod_masq(clone, mode);\n\t\tif (err) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}\nEXPORT_SYMBOL(__posix_acl_chmod);\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}\nEXPORT_SYMBOL(posix_acl_chmod);\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tclone = posix_acl_clone(p, GFP_NOFS);\n\tif (!clone)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(clone);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(posix_acl_create);\n\n/**\n * posix_acl_update_mode  -  update mode in set_acl\n *\n * Update the file mode when setting an ACL: compute the new file permission\n * bits based on the ACL.  In addition, if the ACL is equivalent to the new\n * file mode, set *acl to NULL to indicate that no ACL should be set.\n *\n * As with chmod, clear the setgit bit if the caller is not in the owning group\n * or capable of CAP_FSETID (see inode_change_ok).\n *\n * Called from set_acl inode operations.\n */\nint posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}\nEXPORT_SYMBOL(posix_acl_update_mode);\n\n/*\n * Fix up the uids and gids in posix acl extended attributes in place.\n */\nstatic void posix_acl_fix_xattr_userns(\n\tstruct user_namespace *to, struct user_namespace *from,\n\tvoid *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!value)\n\t\treturn;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\treturn;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn;\n\tif (count == 0)\n\t\treturn;\n\n\tfor (end = entry + count; entry != end; entry++) {\n\t\tswitch(le16_to_cpu(entry->e_tag)) {\n\t\tcase ACL_USER:\n\t\t\tuid = make_kuid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kuid(to, uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tgid = make_kgid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kgid(to, gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid posix_acl_fix_xattr_from_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);\n}\n\nvoid posix_acl_fix_xattr_to_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);\n}\n\n/*\n * Convert from extended attribute to in-memory representation.\n */\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL (posix_acl_from_xattr);\n\n/*\n * Convert from in-memory to extended attribute representation.\n */\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}\nEXPORT_SYMBOL (posix_acl_to_xattr);\n\nstatic int\nposix_acl_xattr_get(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, void *value, size_t size)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, handler->flags);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\n\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}\n\nint\nset_posix_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn acl ? -EACCES : 0;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (acl) {\n\t\tint ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn inode->i_op->set_acl(inode, acl, type);\n}\nEXPORT_SYMBOL(set_posix_acl);\n\nstatic int\nposix_acl_xattr_set(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, const void *value,\n\t\t    size_t size, int flags)\n{\n\tstruct posix_acl *acl = NULL;\n\tint ret;\n\n\tif (value) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t}\n\tret = set_posix_acl(inode, handler->flags, acl);\n\tposix_acl_release(acl);\n\treturn ret;\n}\n\nstatic bool\nposix_acl_xattr_list(struct dentry *dentry)\n{\n\treturn IS_POSIXACL(d_backing_inode(dentry));\n}\n\nconst struct xattr_handler posix_acl_access_xattr_handler = {\n\t.name = XATTR_NAME_POSIX_ACL_ACCESS,\n\t.flags = ACL_TYPE_ACCESS,\n\t.list = posix_acl_xattr_list,\n\t.get = posix_acl_xattr_get,\n\t.set = posix_acl_xattr_set,\n};\nEXPORT_SYMBOL_GPL(posix_acl_access_xattr_handler);\n\nconst struct xattr_handler posix_acl_default_xattr_handler = {\n\t.name = XATTR_NAME_POSIX_ACL_DEFAULT,\n\t.flags = ACL_TYPE_DEFAULT,\n\t.list = posix_acl_xattr_list,\n\t.get = posix_acl_xattr_get,\n\t.set = posix_acl_xattr_set,\n};\nEXPORT_SYMBOL_GPL(posix_acl_default_xattr_handler);\n\nint simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\n\tinode->i_ctime = CURRENT_TIME;\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}\n\nint simple_acl_create(struct inode *dir, struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn 0;\n}\n", "#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/posix_acl.h>\n#include \"reiserfs.h\"\n#include <linux/errno.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include <linux/uaccess.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\n\nint\nreiserfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error, error2;\n\tstruct reiserfs_transaction_handle th;\n\tsize_t jcreate_blocks;\n\tint size = acl ? posix_acl_xattr_size(acl->a_count) : 0;\n\n\n\t/*\n\t * Pessimism: We can't assume that anything from the xattr root up\n\t * has been created.\n\t */\n\n\tjcreate_blocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, size) * 2;\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jcreate_blocks);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0) {\n\t\terror = __reiserfs_set_acl(&th, inode, type, acl);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror2 = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error2)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}\n\n/*\n * Convert from filesystem to in-memory representation.\n */\nstatic struct posix_acl *reiserfs_posix_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(reiserfs_acl_header))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (((reiserfs_acl_header *) value)->a_version !=\n\t    cpu_to_le32(REISERFS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(reiserfs_acl_header);\n\tcount = reiserfs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) value;\n\t\tif ((char *)value + sizeof(reiserfs_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t    sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid = \n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * Convert from in-memory to filesystem representation.\n */\nstatic void *reiserfs_posix_acl_to_disk(const struct posix_acl *acl, size_t * size)\n{\n\treiserfs_acl_header *ext_acl;\n\tchar *e;\n\tint n;\n\n\t*size = reiserfs_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(reiserfs_acl_header) +\n\t\t\t\t\t\t  acl->a_count *\n\t\t\t\t\t\t  sizeof(reiserfs_acl_entry),\n\t\t\t\t\t\t  GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(REISERFS_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(reiserfs_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) e;\n\t\tentry->e_tag = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n/*\n * Inode operation get_posix_acl().\n *\n * inode->i_mutex: down\n * BKL held [before 2.5.x]\n */\nstruct posix_acl *reiserfs_get_acl(struct inode *inode, int type)\n{\n\tchar *name, *value;\n\tstruct posix_acl *acl;\n\tint size;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = reiserfs_xattr_get(inode, name, NULL, 0);\n\tif (size < 0) {\n\t\tif (size == -ENODATA || size == -ENOSYS)\n\t\t\treturn NULL;\n\t\treturn ERR_PTR(size);\n\t}\n\n\tvalue = kmalloc(size, GFP_NOFS);\n\tif (!value)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tretval = reiserfs_xattr_get(inode, name, value, size);\n\tif (retval == -ENODATA || retval == -ENOSYS) {\n\t\t/*\n\t\t * This shouldn't actually happen as it should have\n\t\t * been caught above.. but just in case\n\t\t */\n\t\tacl = NULL;\n\t} else if (retval < 0) {\n\t\tacl = ERR_PTR(retval);\n\t} else {\n\t\tacl = reiserfs_posix_acl_from_disk(value, retval);\n\t}\n\n\tkfree(value);\n\treturn acl;\n}\n\n/*\n * Inode operation set_posix_acl().\n *\n * inode->i_mutex: down\n * BKL held [before 2.5.x]\n */\nstatic int\n__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\n\t/*\n\t * Ensure that the inode gets dirtied if we're only using\n\t * the mode bits and an old ACL didn't exist. We don't need\n\t * to check if the inode is hashed here since we won't get\n\t * called by reiserfs_inherit_default_acl().\n\t */\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tkfree(value);\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}\n\n/*\n * dir->i_mutex: locked,\n * inode is new and not released into the wild yet\n */\nint\nreiserfs_inherit_default_acl(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *dir, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint err = 0;\n\n\t/* ACLs only get applied to files and directories */\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\t/*\n\t * ACLs can only be used on \"new\" objects, so if it's an old object\n\t * there is nothing to inherit from\n\t */\n\tif (get_inode_sd_version(dir) == STAT_DATA_V1)\n\t\tgoto apply_umask;\n\n\t/*\n\t * Don't apply ACLs to objects in the .reiserfs_priv tree.. This\n\t * would be useless since permissions are ignored, and a pain because\n\t * it introduces locking cycles\n\t */\n\tif (IS_PRIVATE(dir)) {\n\t\tinode->i_flags |= S_PRIVATE;\n\t\tgoto apply_umask;\n\t}\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t\t default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t\t acl);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn err;\n\napply_umask:\n\t/* no ACL, apply umask */\n\tinode->i_mode &= ~current_umask();\n\treturn err;\n}\n\n/* This is used to cache the default acl before a new object is created.\n * The biggest reason for this is to get an idea of how many blocks will\n * actually be required for the create operation if we must inherit an ACL.\n * An ACL write can add up to 3 object creations and an additional file write\n * so we'd prefer not to reserve that many blocks in the journal if we can.\n * It also has the advantage of not loading the ACL with a transaction open,\n * this may seem silly, but if the owner of the directory is doing the\n * creation, the ACL may not be loaded since the permissions wouldn't require\n * it.\n * We return the number of blocks required for the transaction.\n */\nint reiserfs_cache_default_acl(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint nblocks = 0;\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\tacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\n\tif (acl && !IS_ERR(acl)) {\n\t\tint size = reiserfs_acl_size(acl->a_count);\n\n\t\t/* Other xattrs can be created during inode creation. We don't\n\t\t * want to claim too many blocks, so we check to see if we\n\t\t * we need to create the tree to the xattrs, and then we\n\t\t * just want two files. */\n\t\tnblocks = reiserfs_xattr_jcreate_nblocks(inode);\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\n\t\t/* We need to account for writes + bitmaps for two files */\n\t\tnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn nblocks;\n}\n\n/*\n * Called under i_mutex\n */\nint reiserfs_acl_chmod(struct inode *inode)\n{\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1 ||\n\t    !reiserfs_posixacl(inode->i_sb))\n\t\treturn 0;\n\n\treturn posix_acl_chmod(inode, inode->i_mode);\n}\n", "/*\n * Copyright (c) 2008, Christoph Hellwig\n * All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it would be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write the Free Software Foundation,\n * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n#include \"xfs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_trace.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n\n\n/*\n * Locking scheme:\n *  - all ACL updates are protected by inode->i_mutex, which is taken before\n *    calling into this file.\n */\n\nSTATIC struct posix_acl *\nxfs_acl_from_disk(\n\tconst struct xfs_acl\t*aclp,\n\tint\t\t\tlen,\n\tint\t\t\tmax_entries)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tconst struct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tif (len < sizeof(*aclp))\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > max_entries || XFS_ACL_SIZE(count) != len)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl_e->e_uid = xfs_uid_to_kuid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_gid = xfs_gid_to_kgid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nSTATIC void\nxfs_acl_to_disk(struct xfs_acl *aclp, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *acl_e;\n\tstruct xfs_acl_entry *ace;\n\tint i;\n\n\taclp->acl_cnt = cpu_to_be32(acl->a_count);\n\tfor (i = 0; i < acl->a_count; i++) {\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e = &acl->a_entries[i];\n\n\t\tace->ae_tag = cpu_to_be32(acl_e->e_tag);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kuid_to_uid(acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kgid_to_gid(acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tace->ae_id = cpu_to_be32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\n\t\tace->ae_perm = cpu_to_be16(acl_e->e_perm);\n\t}\n}\n\nstruct posix_acl *\nxfs_get_acl(struct inode *inode, int type)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tstruct posix_acl *acl = NULL;\n\tstruct xfs_acl *xfs_acl;\n\tunsigned char *ea_name;\n\tint error;\n\tint len;\n\n\ttrace_xfs_get_acl(ip);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * If we have a cached ACLs value just return it, not need to\n\t * go out to the disk.\n\t */\n\tlen = XFS_ACL_MAX_SIZE(ip->i_mount);\n\txfs_acl = kmem_zalloc_large(len, KM_SLEEP);\n\tif (!xfs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = xfs_attr_get(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\t\t\t\t&len, ATTR_ROOT);\n\tif (error) {\n\t\t/*\n\t\t * If the attribute doesn't exist make sure we have a negative\n\t\t * cache entry, for any other error assume it is transient.\n\t\t */\n\t\tif (error != -ENOATTR)\n\t\t\tacl = ERR_PTR(error);\n\t} else  {\n\t\tacl = xfs_acl_from_disk(xfs_acl, len,\n\t\t\t\t\tXFS_ACL_MAX_ENTRIES(ip->i_mount));\n\t}\n\tkmem_free(xfs_acl);\n\treturn acl;\n}\n\nSTATIC int\n__xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tunsigned char *ea_name;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tstruct xfs_acl *xfs_acl;\n\t\tint len = XFS_ACL_MAX_SIZE(ip->i_mount);\n\n\t\txfs_acl = kmem_zalloc_large(len, KM_SLEEP);\n\t\tif (!xfs_acl)\n\t\t\treturn -ENOMEM;\n\n\t\txfs_acl_to_disk(xfs_acl, acl);\n\n\t\t/* subtract away the unused acl entries */\n\t\tlen -= sizeof(struct xfs_acl_entry) *\n\t\t\t (XFS_ACL_MAX_ENTRIES(ip->i_mount) - acl->a_count);\n\n\t\terror = xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\tlen, ATTR_ROOT);\n\n\t\tkmem_free(xfs_acl);\n\t} else {\n\t\t/*\n\t\t * A NULL ACL argument means we want to remove the ACL.\n\t\t */\n\t\terror = xfs_attr_remove(ip, ea_name, ATTR_ROOT);\n\n\t\t/*\n\t\t * If the attribute didn't exist to start with that's fine.\n\t\t */\n\t\tif (error == -ENOATTR)\n\t\t\terror = 0;\n\t}\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n\nstatic int\nxfs_set_mode(struct inode *inode, umode_t mode)\n{\n\tint error = 0;\n\n\tif (mode != inode->i_mode) {\n\t\tstruct iattr iattr;\n\n\t\tiattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\tiattr.ia_mode = mode;\n\t\tiattr.ia_ctime = current_fs_time(inode->i_sb);\n\n\t\terror = xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);\n\t}\n\n\treturn error;\n}\n\nint\nxfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode;\n\n\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}\n", "/*\n  File: linux/posix_acl.h\n\n  (C) 2002 Andreas Gruenbacher, <a.gruenbacher@computer.org>\n*/\n\n\n#ifndef __LINUX_POSIX_ACL_H\n#define __LINUX_POSIX_ACL_H\n\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rcupdate.h>\n\n#define ACL_UNDEFINED_ID\t(-1)\n\n/* a_type field in acl_user_posix_entry_t */\n#define ACL_TYPE_ACCESS\t\t(0x8000)\n#define ACL_TYPE_DEFAULT\t(0x4000)\n\n/* e_tag entry in struct posix_acl_entry */\n#define ACL_USER_OBJ\t\t(0x01)\n#define ACL_USER\t\t(0x02)\n#define ACL_GROUP_OBJ\t\t(0x04)\n#define ACL_GROUP\t\t(0x08)\n#define ACL_MASK\t\t(0x10)\n#define ACL_OTHER\t\t(0x20)\n\n/* permissions in the e_perm field */\n#define ACL_READ\t\t(0x04)\n#define ACL_WRITE\t\t(0x02)\n#define ACL_EXECUTE\t\t(0x01)\n//#define ACL_ADD\t\t(0x08)\n//#define ACL_DELETE\t\t(0x10)\n\nstruct posix_acl_entry {\n\tshort\t\t\te_tag;\n\tunsigned short\t\te_perm;\n\tunion {\n\t\tkuid_t\t\te_uid;\n\t\tkgid_t\t\te_gid;\n\t};\n};\n\nstruct posix_acl {\n\tatomic_t\t\ta_refcount;\n\tstruct rcu_head\t\ta_rcu;\n\tunsigned int\t\ta_count;\n\tstruct posix_acl_entry\ta_entries[0];\n};\n\n#define FOREACH_ACL_ENTRY(pa, acl, pe) \\\n\tfor(pa=(acl)->a_entries, pe=pa+(acl)->a_count; pa<pe; pa++)\n\n\n/*\n * Duplicate an ACL handle.\n */\nstatic inline struct posix_acl *\nposix_acl_dup(struct posix_acl *acl)\n{\n\tif (acl)\n\t\tatomic_inc(&acl->a_refcount);\n\treturn acl;\n}\n\n/*\n * Free an ACL handle.\n */\nstatic inline void\nposix_acl_release(struct posix_acl *acl)\n{\n\tif (acl && atomic_dec_and_test(&acl->a_refcount))\n\t\tkfree_rcu(acl, a_rcu);\n}\n\n\n/* posix_acl.c */\n\nextern void posix_acl_init(struct posix_acl *, int);\nextern struct posix_acl *posix_acl_alloc(int, gfp_t);\nextern int posix_acl_valid(struct user_namespace *, const struct posix_acl *);\nextern int posix_acl_permission(struct inode *, const struct posix_acl *, int);\nextern struct posix_acl *posix_acl_from_mode(umode_t, gfp_t);\nextern int posix_acl_equiv_mode(const struct posix_acl *, umode_t *);\nextern int __posix_acl_create(struct posix_acl **, gfp_t, umode_t *);\nextern int __posix_acl_chmod(struct posix_acl **, gfp_t, umode_t);\n\nextern struct posix_acl *get_posix_acl(struct inode *, int);\nextern int set_posix_acl(struct inode *, int, struct posix_acl *);\n\n#ifdef CONFIG_FS_POSIX_ACL\nextern int posix_acl_chmod(struct inode *, umode_t);\nextern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,\n\t\tstruct posix_acl **);\nextern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);\n\nextern int simple_set_acl(struct inode *, struct posix_acl *, int);\nextern int simple_acl_create(struct inode *, struct inode *);\n\nstruct posix_acl *get_cached_acl(struct inode *inode, int type);\nstruct posix_acl *get_cached_acl_rcu(struct inode *inode, int type);\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl);\nvoid forget_cached_acl(struct inode *inode, int type);\nvoid forget_all_cached_acls(struct inode *inode);\n\nstatic inline void cache_no_acl(struct inode *inode)\n{\n\tinode->i_acl = NULL;\n\tinode->i_default_acl = NULL;\n}\n#else\nstatic inline int posix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\treturn 0;\n}\n\n#define simple_set_acl\t\tNULL\n\nstatic inline int simple_acl_create(struct inode *dir, struct inode *inode)\n{\n\treturn 0;\n}\nstatic inline void cache_no_acl(struct inode *inode)\n{\n}\n\nstatic inline int posix_acl_create(struct inode *inode, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\t*default_acl = *acl = NULL;\n\treturn 0;\n}\n\nstatic inline void forget_all_cached_acls(struct inode *inode)\n{\n}\n#endif /* CONFIG_FS_POSIX_ACL */\n\nstruct posix_acl *get_acl(struct inode *inode, int type);\n\n#endif  /* __LINUX_POSIX_ACL_H */\n"], "filenames": ["fs/9p/acl.c", "fs/btrfs/acl.c", "fs/ceph/acl.c", "fs/ext2/acl.c", "fs/ext4/acl.c", "fs/f2fs/acl.c", "fs/gfs2/acl.c", "fs/hfsplus/posix_acl.c", "fs/jffs2/acl.c", "fs/jfs/acl.c", "fs/ocfs2/acl.c", "fs/orangefs/acl.c", "fs/posix_acl.c", "fs/reiserfs/xattr_acl.c", "fs/xfs/xfs_acl.c", "include/linux/posix_acl.h"], "buggy_code_start_loc": [279, 82, 98, 193, 196, 213, 95, 68, 236, 81, 244, 76, 628, 245, 260, 95], "buggy_code_end_loc": [304, 87, 103, 202, 205, 219, 106, 70, 252, 88, 251, 95, 628, 252, 270, 95], "fixing_code_start_loc": [279, 82, 98, 193, 196, 213, 95, 68, 236, 81, 244, 76, 629, 245, 260, 96], "fixing_code_end_loc": [299, 84, 100, 198, 201, 216, 99, 70, 250, 85, 248, 89, 660, 247, 265, 97], "type": "CWE-285", "message": "The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.", "other": {"cve": {"id": "CVE-2016-7097", "sourceIdentifier": "secalert@redhat.com", "published": "2016-10-16T21:59:11.147", "lastModified": "2023-02-12T23:25:19.473", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions."}, {"lang": "es", "value": "La implementaci\u00f3n del sistema de archivos en el kernel de Linux hasta la versi\u00f3n 4.8.2 preserva el bit setgid durante una llamada setxattr, lo que permite a usuarios locales obtener privilegios de grupo aprovechando la existencia de un programa setgid con restricciones en permisos de ejecuci\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.8.2", "matchCriteriaId": "F2B9219B-3507-4C0A-90B0-3A53254FDCD0"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=073931017b49d9458aa351605b43a7e34598caef", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://marc.info/?l=linux-fsdevel&m=147162313630259&w=2", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0817.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2016/08/26/3", "source": "secalert@redhat.com", "tags": ["Mailing List"]}, {"url": "http://www.securityfocus.com/bid/92659", "source": "secalert@redhat.com"}, {"url": "http://www.securitytracker.com/id/1038201", "source": "secalert@redhat.com"}, {"url": "http://www.spinics.net/lists/linux-fsdevel/msg98328.html", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3146-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-3146-2", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-3147-1", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2669", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1368938", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-04-01", "source": "secalert@redhat.com"}, {"url": "https://support.f5.com/csp/article/K31603170?utm_source=f5support&amp%3Butm_medium=RSS", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef"}}