{"buggy_code": ["<?xml version=\"1.0\" ?>\n\n<container xmlns=\"http://symfony.com/schema/dic/services\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n    <services>\n        <defaults public=\"false\" />\n\n        <service id=\"security.authentication.guard_handler\"\n                 class=\"Symfony\\Component\\Security\\Guard\\GuardAuthenticatorHandler\"\n            >\n            <argument type=\"service\" id=\"security.token_storage\" />\n            <argument type=\"service\" id=\"event_dispatcher\" on-invalid=\"null\" />\n            <argument /> <!-- stateless firewall keys -->\n            <call method=\"setSessionAuthenticationStrategy\">\n                <argument type=\"service\" id=\"security.authentication.session_strategy\" />\n            </call>\n        </service>\n        \n        <service id=\"Symfony\\Component\\Security\\Guard\\GuardAuthenticatorHandler\" alias=\"security.authentication.guard_handler\" />\n\n        <!-- See GuardAuthenticationFactory -->\n        <service id=\"security.authentication.provider.guard\"\n                 class=\"Symfony\\Component\\Security\\Guard\\Provider\\GuardAuthenticationProvider\"\n                 abstract=\"true\"\n            >\n            <argument /> <!-- Simple Authenticator -->\n            <argument /> <!-- User Provider -->\n            <argument /> <!-- Provider-shared Key -->\n            <argument /> <!-- User Checker -->\n        </service>\n\n        <service id=\"security.authentication.listener.guard\"\n                 class=\"Symfony\\Component\\Security\\Guard\\Firewall\\GuardAuthenticationListener\"\n                 abstract=\"true\"\n            >\n            <tag name=\"monolog.logger\" channel=\"security\" />\n            <argument type=\"service\" id=\"security.authentication.guard_handler\" />\n            <argument type=\"service\" id=\"security.authentication.manager\" />\n            <argument /> <!-- Provider-shared Key -->\n            <argument /> <!-- Authenticator -->\n            <argument type=\"service\" id=\"logger\" on-invalid=\"null\" />\n        </service>\n    </services>\n</container>\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Core\\Authentication\\Provider;\n\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationServiceException;\nuse Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException;\nuse Symfony\\Component\\Security\\Core\\Exception\\UsernameNotFoundException;\nuse Symfony\\Component\\Security\\Core\\Role\\SwitchUserRole;\nuse Symfony\\Component\\Security\\Core\\User\\UserCheckerInterface;\nuse Symfony\\Component\\Security\\Core\\User\\UserInterface;\n\n/**\n * UserProviderInterface retrieves users for UsernamePasswordToken tokens.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nabstract class UserAuthenticationProvider implements AuthenticationProviderInterface\n{\n    private $hideUserNotFoundExceptions;\n    private $userChecker;\n    private $providerKey;\n\n    /**\n     * @param UserCheckerInterface $userChecker                An UserCheckerInterface interface\n     * @param string               $providerKey                A provider key\n     * @param bool                 $hideUserNotFoundExceptions Whether to hide user not found exception or not\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function __construct(UserCheckerInterface $userChecker, $providerKey, $hideUserNotFoundExceptions = true)\n    {\n        if (empty($providerKey)) {\n            throw new \\InvalidArgumentException('$providerKey must not be empty.');\n        }\n\n        $this->userChecker = $userChecker;\n        $this->providerKey = $providerKey;\n        $this->hideUserNotFoundExceptions = $hideUserNotFoundExceptions;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function authenticate(TokenInterface $token)\n    {\n        if (!$this->supports($token)) {\n            throw new AuthenticationException('The token is not supported by this authentication provider.');\n        }\n\n        $username = $token->getUsername();\n        if ('' === $username || null === $username) {\n            $username = AuthenticationProviderInterface::USERNAME_NONE_PROVIDED;\n        }\n\n        try {\n            $user = $this->retrieveUser($username, $token);\n        } catch (UsernameNotFoundException $e) {\n            if ($this->hideUserNotFoundExceptions) {\n                throw new BadCredentialsException('Bad credentials.', 0, $e);\n            }\n            $e->setUsername($username);\n\n            throw $e;\n        }\n\n        if (!$user instanceof UserInterface) {\n            throw new AuthenticationServiceException('retrieveUser() must return a UserInterface.');\n        }\n\n        try {\n            $this->userChecker->checkPreAuth($user);\n            $this->checkAuthentication($user, $token);\n            $this->userChecker->checkPostAuth($user);\n        } catch (BadCredentialsException $e) {\n            if ($this->hideUserNotFoundExceptions) {\n                throw new BadCredentialsException('Bad credentials.', 0, $e);\n            }\n\n            throw $e;\n        }\n\n        $authenticatedToken = new UsernamePasswordToken($user, $token->getCredentials(), $this->providerKey, $this->getRoles($user, $token));\n        $authenticatedToken->setAttributes($token->getAttributes());\n\n        return $authenticatedToken;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supports(TokenInterface $token)\n    {\n        return $token instanceof UsernamePasswordToken && $this->providerKey === $token->getProviderKey();\n    }\n\n    /**\n     * Retrieves roles from user and appends SwitchUserRole if original token contained one.\n     *\n     * @return array The user roles\n     */\n    private function getRoles(UserInterface $user, TokenInterface $token)\n    {\n        $roles = $user->getRoles();\n\n        foreach ($token->getRoles() as $role) {\n            if ($role instanceof SwitchUserRole) {\n                $roles[] = $role;\n\n                break;\n            }\n        }\n\n        return $roles;\n    }\n\n    /**\n     * Retrieves the user from an implementation-specific location.\n     *\n     * @param string                $username The username to retrieve\n     * @param UsernamePasswordToken $token    The Token\n     *\n     * @return UserInterface The user\n     *\n     * @throws AuthenticationException if the credentials could not be validated\n     */\n    abstract protected function retrieveUser($username, UsernamePasswordToken $token);\n\n    /**\n     * Does additional checks on the user and token (like validating the\n     * credentials).\n     *\n     * @throws AuthenticationException if the credentials could not be validated\n     */\n    abstract protected function checkAuthentication(UserInterface $user, UsernamePasswordToken $token);\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Core\\Tests\\Authentication\\Provider;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\Security\\Core\\Exception\\AccountExpiredException;\nuse Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException;\nuse Symfony\\Component\\Security\\Core\\Exception\\CredentialsExpiredException;\nuse Symfony\\Component\\Security\\Core\\Exception\\UsernameNotFoundException;\nuse Symfony\\Component\\Security\\Core\\Role\\Role;\nuse Symfony\\Component\\Security\\Core\\Role\\SwitchUserRole;\n\nclass UserAuthenticationProviderTest extends TestCase\n{\n    public function testSupports()\n    {\n        $provider = $this->getProvider();\n\n        $this->assertTrue($provider->supports($this->getSupportedToken()));\n        $this->assertFalse($provider->supports($this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock()));\n    }\n\n    public function testAuthenticateWhenTokenIsNotSupported()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException');\n        $this->expectExceptionMessage('The token is not supported by this authentication provider.');\n        $provider = $this->getProvider();\n\n        $provider->authenticate($this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock());\n    }\n\n    public function testAuthenticateWhenUsernameIsNotFound()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\UsernameNotFoundException');\n        $provider = $this->getProvider(false, false);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willThrowException(new UsernameNotFoundException())\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticateWhenUsernameIsNotFoundAndHideIsTrue()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException');\n        $provider = $this->getProvider(false, true);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willThrowException(new UsernameNotFoundException())\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testAuthenticateWhenProviderDoesNotReturnAnUserInterface()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\AuthenticationServiceException');\n        $provider = $this->getProvider(false, true);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn(null)\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticateWhenPreChecksFails()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\CredentialsExpiredException');\n        $userChecker = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserCheckerInterface')->getMock();\n        $userChecker->expects($this->once())\n                    ->method('checkPreAuth')\n                    ->willThrowException(new CredentialsExpiredException())\n        ;\n\n        $provider = $this->getProvider($userChecker);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock())\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticateWhenPostChecksFails()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\AccountExpiredException');\n        $userChecker = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserCheckerInterface')->getMock();\n        $userChecker->expects($this->once())\n                    ->method('checkPostAuth')\n                    ->willThrowException(new AccountExpiredException())\n        ;\n\n        $provider = $this->getProvider($userChecker);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock())\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticateWhenPostCheckAuthenticationFails()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException');\n        $this->expectExceptionMessage('Bad credentials');\n        $provider = $this->getProvider();\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock())\n        ;\n        $provider->expects($this->once())\n                 ->method('checkAuthentication')\n                 ->willThrowException(new BadCredentialsException())\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticateWhenPostCheckAuthenticationFailsWithHideFalse()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException');\n        $this->expectExceptionMessage('Foo');\n        $provider = $this->getProvider(false, false);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock())\n        ;\n        $provider->expects($this->once())\n                 ->method('checkAuthentication')\n                 ->willThrowException(new BadCredentialsException('Foo'))\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticate()\n    {\n        $user = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock();\n        $user->expects($this->once())\n             ->method('getRoles')\n             ->willReturn(['ROLE_FOO'])\n        ;\n\n        $provider = $this->getProvider();\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($user)\n        ;\n\n        $token = $this->getSupportedToken();\n        $token->expects($this->once())\n              ->method('getCredentials')\n              ->willReturn('foo')\n        ;\n\n        $token->expects($this->once())\n              ->method('getRoles')\n              ->willReturn([])\n        ;\n\n        $authToken = $provider->authenticate($token);\n\n        $this->assertInstanceOf('Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken', $authToken);\n        $this->assertSame($user, $authToken->getUser());\n        $this->assertEquals([new Role('ROLE_FOO')], $authToken->getRoles());\n        $this->assertEquals('foo', $authToken->getCredentials());\n        $this->assertEquals(['foo' => 'bar'], $authToken->getAttributes(), '->authenticate() copies token attributes');\n    }\n\n    public function testAuthenticateWithPreservingRoleSwitchUserRole()\n    {\n        $user = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock();\n        $user->expects($this->once())\n             ->method('getRoles')\n             ->willReturn(['ROLE_FOO'])\n        ;\n\n        $provider = $this->getProvider();\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($user)\n        ;\n\n        $token = $this->getSupportedToken();\n        $token->expects($this->once())\n              ->method('getCredentials')\n              ->willReturn('foo')\n        ;\n\n        $switchUserRole = new SwitchUserRole('foo', $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock());\n        $token->expects($this->once())\n              ->method('getRoles')\n              ->willReturn([$switchUserRole])\n        ;\n\n        $authToken = $provider->authenticate($token);\n\n        $this->assertInstanceOf('Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken', $authToken);\n        $this->assertSame($user, $authToken->getUser());\n        $this->assertContainsEquals(new Role('ROLE_FOO'), $authToken->getRoles());\n        $this->assertContainsEquals($switchUserRole, $authToken->getRoles());\n        $this->assertEquals('foo', $authToken->getCredentials());\n        $this->assertEquals(['foo' => 'bar'], $authToken->getAttributes(), '->authenticate() copies token attributes');\n    }\n\n    protected function getSupportedToken()\n    {\n        $mock = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken')->setMethods(['getCredentials', 'getProviderKey', 'getRoles'])->disableOriginalConstructor()->getMock();\n        $mock\n            ->expects($this->any())\n            ->method('getProviderKey')\n            ->willReturn('key')\n        ;\n\n        $mock->setAttributes(['foo' => 'bar']);\n\n        return $mock;\n    }\n\n    protected function getProvider($userChecker = false, $hide = true)\n    {\n        if (false === $userChecker) {\n            $userChecker = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserCheckerInterface')->getMock();\n        }\n\n        return $this->getMockForAbstractClass('Symfony\\Component\\Security\\Core\\Authentication\\Provider\\UserAuthenticationProvider', [$userChecker, 'key', $hide]);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Guard\\Firewall;\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\GetResponseEvent;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException;\nuse Symfony\\Component\\Security\\Guard\\AbstractGuardAuthenticator;\nuse Symfony\\Component\\Security\\Guard\\AuthenticatorInterface;\nuse Symfony\\Component\\Security\\Guard\\GuardAuthenticatorHandler;\nuse Symfony\\Component\\Security\\Guard\\GuardAuthenticatorInterface;\nuse Symfony\\Component\\Security\\Guard\\Token\\PreAuthenticationGuardToken;\nuse Symfony\\Component\\Security\\Http\\Firewall\\ListenerInterface;\nuse Symfony\\Component\\Security\\Http\\RememberMe\\RememberMeServicesInterface;\n\n/**\n * Authentication listener for the \"guard\" system.\n *\n * @author Ryan Weaver <ryan@knpuniversity.com>\n * @author Amaury Leroux de Lens <amaury@lerouxdelens.com>\n */\nclass GuardAuthenticationListener implements ListenerInterface\n{\n    private $guardHandler;\n    private $authenticationManager;\n    private $providerKey;\n    private $guardAuthenticators;\n    private $logger;\n    private $rememberMeServices;\n\n    /**\n     * @param GuardAuthenticatorHandler         $guardHandler          The Guard handler\n     * @param AuthenticationManagerInterface    $authenticationManager An AuthenticationManagerInterface instance\n     * @param string                            $providerKey           The provider (i.e. firewall) key\n     * @param iterable|AuthenticatorInterface[] $guardAuthenticators   The authenticators, with keys that match what's passed to GuardAuthenticationProvider\n     * @param LoggerInterface                   $logger                A LoggerInterface instance\n     */\n    public function __construct(GuardAuthenticatorHandler $guardHandler, AuthenticationManagerInterface $authenticationManager, $providerKey, $guardAuthenticators, LoggerInterface $logger = null)\n    {\n        if (empty($providerKey)) {\n            throw new \\InvalidArgumentException('$providerKey must not be empty.');\n        }\n\n        $this->guardHandler = $guardHandler;\n        $this->authenticationManager = $authenticationManager;\n        $this->providerKey = $providerKey;\n        $this->guardAuthenticators = $guardAuthenticators;\n        $this->logger = $logger;\n    }\n\n    /**\n     * Iterates over each authenticator to see if each wants to authenticate the request.\n     */\n    public function handle(GetResponseEvent $event)\n    {\n        if (null !== $this->logger) {\n            $context = ['firewall_key' => $this->providerKey];\n\n            if ($this->guardAuthenticators instanceof \\Countable || \\is_array($this->guardAuthenticators)) {\n                $context['authenticators'] = \\count($this->guardAuthenticators);\n            }\n\n            $this->logger->debug('Checking for guard authentication credentials.', $context);\n        }\n\n        foreach ($this->guardAuthenticators as $key => $guardAuthenticator) {\n            // get a key that's unique to *this* guard authenticator\n            // this MUST be the same as GuardAuthenticationProvider\n            $uniqueGuardKey = $this->providerKey.'_'.$key;\n\n            $this->executeGuardAuthenticator($uniqueGuardKey, $guardAuthenticator, $event);\n\n            if ($event->hasResponse()) {\n                if (null !== $this->logger) {\n                    $this->logger->debug('The \"{authenticator}\" authenticator set the response. Any later authenticator will not be called', ['authenticator' => \\get_class($guardAuthenticator)]);\n                }\n\n                break;\n            }\n        }\n    }\n\n    private function executeGuardAuthenticator($uniqueGuardKey, GuardAuthenticatorInterface $guardAuthenticator, GetResponseEvent $event)\n    {\n        $request = $event->getRequest();\n        try {\n            // abort the execution of the authenticator if it doesn't support the request\n            if ($guardAuthenticator instanceof AuthenticatorInterface) {\n                if (null !== $this->logger) {\n                    $this->logger->debug('Checking support on guard authenticator.', ['firewall_key' => $this->providerKey, 'authenticator' => \\get_class($guardAuthenticator)]);\n                }\n\n                if (!$guardAuthenticator->supports($request)) {\n                    if (null !== $this->logger) {\n                        $this->logger->debug('Guard authenticator does not support the request.', ['firewall_key' => $this->providerKey, 'authenticator' => \\get_class($guardAuthenticator)]);\n                    }\n\n                    return;\n                }\n                // as there was a support for given request,\n                // authenticator is expected to give not-null credentials.\n                $credentialsCanBeNull = false;\n            } else {\n                // deprecated since version 3.4, to be removed in 4.0\n                $credentialsCanBeNull = true;\n            }\n\n            if (null !== $this->logger) {\n                $this->logger->debug('Calling getCredentials() on guard authenticator.', ['firewall_key' => $this->providerKey, 'authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            // allow the authenticator to fetch authentication info from the request\n            $credentials = $guardAuthenticator->getCredentials($request);\n\n            if (null === $credentials) {\n                // deprecated since version 3.4, to be removed in 4.0\n                if ($credentialsCanBeNull) {\n                    return;\n                }\n\n                if ($guardAuthenticator instanceof AbstractGuardAuthenticator) {\n                    @trigger_error(sprintf('Returning null from \"%1$s::getCredentials()\" is deprecated since Symfony 3.4 and will throw an \\UnexpectedValueException in 4.0. Return false from \"%1$s::supports()\" instead.', \\get_class($guardAuthenticator)), \\E_USER_DEPRECATED);\n\n                    return;\n                }\n\n                throw new \\UnexpectedValueException(sprintf('The return value of \"%1$s::getCredentials()\" must not be null. Return false from \"%1$s::supports()\" instead.', \\get_class($guardAuthenticator)));\n            }\n\n            // create a token with the unique key, so that the provider knows which authenticator to use\n            $token = new PreAuthenticationGuardToken($credentials, $uniqueGuardKey);\n\n            if (null !== $this->logger) {\n                $this->logger->debug('Passing guard token information to the GuardAuthenticationProvider', ['firewall_key' => $this->providerKey, 'authenticator' => \\get_class($guardAuthenticator)]);\n            }\n            // pass the token into the AuthenticationManager system\n            // this indirectly calls GuardAuthenticationProvider::authenticate()\n            $token = $this->authenticationManager->authenticate($token);\n\n            if (null !== $this->logger) {\n                $this->logger->info('Guard authentication successful!', ['token' => $token, 'authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            // sets the token on the token storage, etc\n            $this->guardHandler->authenticateWithToken($token, $request, $this->providerKey);\n        } catch (AuthenticationException $e) {\n            // oh no! Authentication failed!\n\n            if (null !== $this->logger) {\n                $this->logger->info('Guard authentication failed.', ['exception' => $e, 'authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            $response = $this->guardHandler->handleAuthenticationFailure($e, $request, $guardAuthenticator, $this->providerKey);\n\n            if ($response instanceof Response) {\n                $event->setResponse($response);\n            }\n\n            return;\n        }\n\n        // success!\n        $response = $this->guardHandler->handleAuthenticationSuccess($token, $request, $guardAuthenticator, $this->providerKey);\n        if ($response instanceof Response) {\n            if (null !== $this->logger) {\n                $this->logger->debug('Guard authenticator set success response.', ['response' => $response, 'authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            $event->setResponse($response);\n        } else {\n            if (null !== $this->logger) {\n                $this->logger->debug('Guard authenticator set no success response: request continues.', ['authenticator' => \\get_class($guardAuthenticator)]);\n            }\n        }\n\n        // attempt to trigger the remember me functionality\n        $this->triggerRememberMe($guardAuthenticator, $request, $token, $response);\n    }\n\n    /**\n     * Should be called if this listener will support remember me.\n     */\n    public function setRememberMeServices(RememberMeServicesInterface $rememberMeServices)\n    {\n        $this->rememberMeServices = $rememberMeServices;\n    }\n\n    /**\n     * Checks to see if remember me is supported in the authenticator and\n     * on the firewall. If it is, the RememberMeServicesInterface is notified.\n     */\n    private function triggerRememberMe(GuardAuthenticatorInterface $guardAuthenticator, Request $request, TokenInterface $token, Response $response = null)\n    {\n        if (null === $this->rememberMeServices) {\n            if (null !== $this->logger) {\n                $this->logger->debug('Remember me skipped: it is not configured for the firewall.', ['authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            return;\n        }\n\n        if (!$guardAuthenticator->supportsRememberMe()) {\n            if (null !== $this->logger) {\n                $this->logger->debug('Remember me skipped: your authenticator does not support it.', ['authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            return;\n        }\n\n        if (!$response instanceof Response) {\n            throw new \\LogicException(sprintf('\"%s::onAuthenticationSuccess()\" *must* return a Response if you want to use the remember me functionality. Return a Response, or set remember_me to false under the guard configuration.', \\get_class($guardAuthenticator)));\n        }\n\n        $this->rememberMeServices->loginSuccess($request, $response, $token);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Guard\\Tests\\Firewall;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException;\nuse Symfony\\Component\\Security\\Guard\\AbstractGuardAuthenticator;\nuse Symfony\\Component\\Security\\Guard\\AuthenticatorInterface;\nuse Symfony\\Component\\Security\\Guard\\Firewall\\GuardAuthenticationListener;\nuse Symfony\\Component\\Security\\Guard\\GuardAuthenticatorInterface;\nuse Symfony\\Component\\Security\\Guard\\Token\\PreAuthenticationGuardToken;\n\n/**\n * @author Ryan Weaver <weaverryan@gmail.com>\n * @author Amaury Leroux de Lens <amaury@lerouxdelens.com>\n */\nclass GuardAuthenticationListenerTest extends TestCase\n{\n    private $authenticationManager;\n    private $guardAuthenticatorHandler;\n    private $event;\n    private $logger;\n    private $request;\n    private $rememberMeServices;\n\n    public function testHandleSuccess()\n    {\n        $authenticator = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $authenticateToken = $this->getMockBuilder(TokenInterface::class)->getMock();\n        $providerKey = 'my_firewall';\n\n        $credentials = ['username' => 'weaverryan', 'password' => 'all_your_base'];\n\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(true);\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->with($this->equalTo($this->request))\n            ->willReturn($credentials);\n\n        // a clone of the token that should be created internally\n        $uniqueGuardKey = 'my_firewall_0';\n        $nonAuthedToken = new PreAuthenticationGuardToken($credentials, $uniqueGuardKey);\n\n        $this->authenticationManager\n            ->expects($this->once())\n            ->method('authenticate')\n            ->with($this->equalTo($nonAuthedToken))\n            ->willReturn($authenticateToken);\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('authenticateWithToken')\n            ->with($authenticateToken, $this->request);\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('handleAuthenticationSuccess')\n            ->with($authenticateToken, $this->request, $authenticator, $providerKey);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->setRememberMeServices($this->rememberMeServices);\n        // should never be called - our handleAuthenticationSuccess() does not return a Response\n        $this->rememberMeServices\n            ->expects($this->never())\n            ->method('loginSuccess');\n\n        $listener->handle($this->event);\n    }\n\n    public function testHandleSuccessStopsAfterResponseIsSet()\n    {\n        $authenticator1 = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $authenticator2 = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n\n        // mock the first authenticator to fail, and set a Response\n        $authenticator1\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(true);\n        $authenticator1\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willThrowException(new AuthenticationException());\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('handleAuthenticationFailure')\n            ->willReturn(new Response());\n        // the second authenticator should *never* be called\n        $authenticator2\n            ->expects($this->never())\n            ->method('getCredentials');\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            'my_firewall',\n            [$authenticator1, $authenticator2],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    public function testHandleSuccessWithRememberMe()\n    {\n        $authenticator = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $authenticateToken = $this->getMockBuilder(TokenInterface::class)->getMock();\n        $providerKey = 'my_firewall_with_rememberme';\n\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->with($this->equalTo($this->request))\n            ->willReturn(true);\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->with($this->equalTo($this->request))\n            ->willReturn(['username' => 'anything_not_empty']);\n\n        $this->authenticationManager\n            ->expects($this->once())\n            ->method('authenticate')\n            ->willReturn($authenticateToken);\n\n        $successResponse = new Response('Success!');\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('handleAuthenticationSuccess')\n            ->willReturn($successResponse);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->setRememberMeServices($this->rememberMeServices);\n        $authenticator->expects($this->once())\n            ->method('supportsRememberMe')\n            ->willReturn(true);\n        // should be called - we do have a success Response\n        $this->rememberMeServices\n            ->expects($this->once())\n            ->method('loginSuccess');\n\n        $listener->handle($this->event);\n    }\n\n    public function testHandleCatchesAuthenticationException()\n    {\n        $authenticator = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $providerKey = 'my_firewall2';\n\n        $authException = new AuthenticationException('Get outta here crazy user with a bad password!');\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(true);\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willThrowException($authException);\n\n        // this is not called\n        $this->authenticationManager\n            ->expects($this->never())\n            ->method('authenticate');\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('handleAuthenticationFailure')\n            ->with($authException, $this->request, $authenticator, $providerKey);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyInterfaceNullCredentials()\n    {\n        $authenticatorA = $this->getMockBuilder(GuardAuthenticatorInterface::class)->getMock();\n        $providerKey = 'my_firewall3';\n\n        $authenticatorA\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willReturn(null);\n\n        // this is not called\n        $this->authenticationManager\n            ->expects($this->never())\n            ->method('authenticate');\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->never())\n            ->method('handleAuthenticationSuccess');\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticatorA],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyInterfaceKeepsWorking()\n    {\n        $authenticator = $this->getMockBuilder(GuardAuthenticatorInterface::class)->getMock();\n        $authenticateToken = $this->getMockBuilder(TokenInterface::class)->getMock();\n        $providerKey = 'my_firewall';\n\n        $credentials = ['username' => 'weaverryan', 'password' => 'all_your_base'];\n\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->with($this->equalTo($this->request))\n            ->willReturn($credentials);\n\n        // a clone of the token that should be created internally\n        $uniqueGuardKey = 'my_firewall_0';\n        $nonAuthedToken = new PreAuthenticationGuardToken($credentials, $uniqueGuardKey);\n\n        $this->authenticationManager\n            ->expects($this->once())\n            ->method('authenticate')\n            ->with($this->equalTo($nonAuthedToken))\n            ->willReturn($authenticateToken);\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('authenticateWithToken')\n            ->with($authenticateToken, $this->request);\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('handleAuthenticationSuccess')\n            ->with($authenticateToken, $this->request, $authenticator, $providerKey);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->setRememberMeServices($this->rememberMeServices);\n        // should never be called - our handleAuthenticationSuccess() does not return a Response\n        $this->rememberMeServices\n            ->expects($this->never())\n            ->method('loginSuccess');\n\n        $listener->handle($this->event);\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testReturnNullToSkipAuth()\n    {\n        $authenticatorA = $this->getMockBuilder('Symfony\\Component\\Security\\Guard\\GuardAuthenticatorInterface')->getMock();\n        $authenticatorB = $this->getMockBuilder('Symfony\\Component\\Security\\Guard\\GuardAuthenticatorInterface')->getMock();\n        $providerKey = 'my_firewall3';\n\n        $authenticatorA\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willReturn(null);\n        $authenticatorB\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willReturn(null);\n\n        // this is not called\n        $this->authenticationManager\n            ->expects($this->never())\n            ->method('authenticate');\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->never())\n            ->method('handleAuthenticationSuccess');\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticatorA, $authenticatorB],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    public function testSupportsReturnFalseSkipAuth()\n    {\n        $authenticator = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $providerKey = 'my_firewall4';\n\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(false);\n\n        // this is not called\n        $authenticator\n            ->expects($this->never())\n            ->method('getCredentials');\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    public function testReturnNullFromGetCredentials()\n    {\n        $this->expectException('UnexpectedValueException');\n        $authenticator = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $providerKey = 'my_firewall4';\n\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(true);\n\n        // this will raise exception\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willReturn(null);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    /**\n     * @group legacy\n     * @expectedDeprecation Returning null from \"%s::getCredentials()\" is deprecated since Symfony 3.4 and will throw an \\UnexpectedValueException in 4.0. Return false from \"%s::supports()\" instead.\n     */\n    public function testReturnNullFromGetCredentialsTriggersForAbstractGuardAuthenticatorInstances()\n    {\n        $authenticator = $this->getMockBuilder(AbstractGuardAuthenticator::class)->getMock();\n        $providerKey = 'my_firewall4';\n\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(true);\n\n        // this will raise exception\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willReturn(null);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    protected function setUp()\n    {\n        $this->authenticationManager = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationProviderManager')\n            ->disableOriginalConstructor()\n            ->getMock();\n\n        $this->guardAuthenticatorHandler = $this->getMockBuilder('Symfony\\Component\\Security\\Guard\\GuardAuthenticatorHandler')\n            ->disableOriginalConstructor()\n            ->getMock();\n\n        $this->request = new Request([], [], [], [], [], []);\n\n        $this->event = $this->getMockBuilder('Symfony\\Component\\HttpKernel\\Event\\GetResponseEvent')\n            ->disableOriginalConstructor()\n            ->setMethods(['getRequest'])\n            ->getMock();\n        $this->event\n            ->expects($this->any())\n            ->method('getRequest')\n            ->willReturn($this->request);\n\n        $this->logger = $this->getMockBuilder('Psr\\Log\\LoggerInterface')->getMock();\n        $this->rememberMeServices = $this->getMockBuilder('Symfony\\Component\\Security\\Http\\RememberMe\\RememberMeServicesInterface')->getMock();\n    }\n\n    protected function tearDown()\n    {\n        $this->authenticationManager = null;\n        $this->guardAuthenticatorHandler = null;\n        $this->event = null;\n        $this->logger = null;\n        $this->request = null;\n        $this->rememberMeServices = null;\n    }\n}\n"], "fixing_code": ["<?xml version=\"1.0\" ?>\n\n<container xmlns=\"http://symfony.com/schema/dic/services\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n    <services>\n        <defaults public=\"false\" />\n\n        <service id=\"security.authentication.guard_handler\"\n                 class=\"Symfony\\Component\\Security\\Guard\\GuardAuthenticatorHandler\"\n            >\n            <argument type=\"service\" id=\"security.token_storage\" />\n            <argument type=\"service\" id=\"event_dispatcher\" on-invalid=\"null\" />\n            <argument /> <!-- stateless firewall keys -->\n            <call method=\"setSessionAuthenticationStrategy\">\n                <argument type=\"service\" id=\"security.authentication.session_strategy\" />\n            </call>\n        </service>\n\n        <service id=\"Symfony\\Component\\Security\\Guard\\GuardAuthenticatorHandler\" alias=\"security.authentication.guard_handler\" />\n\n        <!-- See GuardAuthenticationFactory -->\n        <service id=\"security.authentication.provider.guard\"\n                 class=\"Symfony\\Component\\Security\\Guard\\Provider\\GuardAuthenticationProvider\"\n                 abstract=\"true\"\n            >\n            <argument /> <!-- Simple Authenticator -->\n            <argument /> <!-- User Provider -->\n            <argument /> <!-- Provider-shared Key -->\n            <argument /> <!-- User Checker -->\n        </service>\n\n        <service id=\"security.authentication.listener.guard\"\n                 class=\"Symfony\\Component\\Security\\Guard\\Firewall\\GuardAuthenticationListener\"\n                 abstract=\"true\"\n            >\n            <tag name=\"monolog.logger\" channel=\"security\" />\n            <argument type=\"service\" id=\"security.authentication.guard_handler\" />\n            <argument type=\"service\" id=\"security.authentication.manager\" />\n            <argument /> <!-- Provider-shared Key -->\n            <argument /> <!-- Authenticator -->\n            <argument type=\"service\" id=\"logger\" on-invalid=\"null\" />\n            <argument>%security.authentication.hide_user_not_found%</argument>\n        </service>\n    </services>\n</container>\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Core\\Authentication\\Provider;\n\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken;\nuse Symfony\\Component\\Security\\Core\\Exception\\AccountStatusException;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationServiceException;\nuse Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException;\nuse Symfony\\Component\\Security\\Core\\Exception\\UsernameNotFoundException;\nuse Symfony\\Component\\Security\\Core\\Role\\SwitchUserRole;\nuse Symfony\\Component\\Security\\Core\\User\\UserCheckerInterface;\nuse Symfony\\Component\\Security\\Core\\User\\UserInterface;\n\n/**\n * UserProviderInterface retrieves users for UsernamePasswordToken tokens.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nabstract class UserAuthenticationProvider implements AuthenticationProviderInterface\n{\n    private $hideUserNotFoundExceptions;\n    private $userChecker;\n    private $providerKey;\n\n    /**\n     * @param UserCheckerInterface $userChecker                An UserCheckerInterface interface\n     * @param string               $providerKey                A provider key\n     * @param bool                 $hideUserNotFoundExceptions Whether to hide user not found exception or not\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function __construct(UserCheckerInterface $userChecker, $providerKey, $hideUserNotFoundExceptions = true)\n    {\n        if (empty($providerKey)) {\n            throw new \\InvalidArgumentException('$providerKey must not be empty.');\n        }\n\n        $this->userChecker = $userChecker;\n        $this->providerKey = $providerKey;\n        $this->hideUserNotFoundExceptions = $hideUserNotFoundExceptions;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function authenticate(TokenInterface $token)\n    {\n        if (!$this->supports($token)) {\n            throw new AuthenticationException('The token is not supported by this authentication provider.');\n        }\n\n        $username = $token->getUsername();\n        if ('' === $username || null === $username) {\n            $username = AuthenticationProviderInterface::USERNAME_NONE_PROVIDED;\n        }\n\n        try {\n            $user = $this->retrieveUser($username, $token);\n        } catch (UsernameNotFoundException $e) {\n            if ($this->hideUserNotFoundExceptions) {\n                throw new BadCredentialsException('Bad credentials.', 0, $e);\n            }\n            $e->setUsername($username);\n\n            throw $e;\n        }\n\n        if (!$user instanceof UserInterface) {\n            throw new AuthenticationServiceException('retrieveUser() must return a UserInterface.');\n        }\n\n        try {\n            $this->userChecker->checkPreAuth($user);\n            $this->checkAuthentication($user, $token);\n            $this->userChecker->checkPostAuth($user);\n        } catch (AccountStatusException $e) {\n            if ($this->hideUserNotFoundExceptions) {\n                throw new BadCredentialsException('Bad credentials.', 0, $e);\n            }\n\n            throw $e;\n        }\n\n        $authenticatedToken = new UsernamePasswordToken($user, $token->getCredentials(), $this->providerKey, $this->getRoles($user, $token));\n        $authenticatedToken->setAttributes($token->getAttributes());\n\n        return $authenticatedToken;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supports(TokenInterface $token)\n    {\n        return $token instanceof UsernamePasswordToken && $this->providerKey === $token->getProviderKey();\n    }\n\n    /**\n     * Retrieves roles from user and appends SwitchUserRole if original token contained one.\n     *\n     * @return array The user roles\n     */\n    private function getRoles(UserInterface $user, TokenInterface $token)\n    {\n        $roles = $user->getRoles();\n\n        foreach ($token->getRoles() as $role) {\n            if ($role instanceof SwitchUserRole) {\n                $roles[] = $role;\n\n                break;\n            }\n        }\n\n        return $roles;\n    }\n\n    /**\n     * Retrieves the user from an implementation-specific location.\n     *\n     * @param string                $username The username to retrieve\n     * @param UsernamePasswordToken $token    The Token\n     *\n     * @return UserInterface The user\n     *\n     * @throws AuthenticationException if the credentials could not be validated\n     */\n    abstract protected function retrieveUser($username, UsernamePasswordToken $token);\n\n    /**\n     * Does additional checks on the user and token (like validating the\n     * credentials).\n     *\n     * @throws AuthenticationException if the credentials could not be validated\n     */\n    abstract protected function checkAuthentication(UserInterface $user, UsernamePasswordToken $token);\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Core\\Tests\\Authentication\\Provider;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\Security\\Core\\Exception\\AccountExpiredException;\nuse Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException;\nuse Symfony\\Component\\Security\\Core\\Exception\\CredentialsExpiredException;\nuse Symfony\\Component\\Security\\Core\\Exception\\UsernameNotFoundException;\nuse Symfony\\Component\\Security\\Core\\Role\\Role;\nuse Symfony\\Component\\Security\\Core\\Role\\SwitchUserRole;\n\nclass UserAuthenticationProviderTest extends TestCase\n{\n    public function testSupports()\n    {\n        $provider = $this->getProvider();\n\n        $this->assertTrue($provider->supports($this->getSupportedToken()));\n        $this->assertFalse($provider->supports($this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock()));\n    }\n\n    public function testAuthenticateWhenTokenIsNotSupported()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException');\n        $this->expectExceptionMessage('The token is not supported by this authentication provider.');\n        $provider = $this->getProvider();\n\n        $provider->authenticate($this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock());\n    }\n\n    public function testAuthenticateWhenUsernameIsNotFound()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\UsernameNotFoundException');\n        $provider = $this->getProvider(false, false);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willThrowException(new UsernameNotFoundException())\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticateWhenUsernameIsNotFoundAndHideIsTrue()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException');\n        $provider = $this->getProvider(false, true);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willThrowException(new UsernameNotFoundException())\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testAuthenticateWhenProviderDoesNotReturnAnUserInterface()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\AuthenticationServiceException');\n        $provider = $this->getProvider(false, true);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn(null)\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticateWhenPreChecksFails()\n    {\n        $this->expectException(BadCredentialsException::class);\n        $userChecker = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserCheckerInterface')->getMock();\n        $userChecker->expects($this->once())\n                    ->method('checkPreAuth')\n                    ->willThrowException(new CredentialsExpiredException())\n        ;\n\n        $provider = $this->getProvider($userChecker);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock())\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticateWhenPostChecksFails()\n    {\n        $this->expectException(BadCredentialsException::class);\n        $userChecker = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserCheckerInterface')->getMock();\n        $userChecker->expects($this->once())\n                    ->method('checkPostAuth')\n                    ->willThrowException(new AccountExpiredException())\n        ;\n\n        $provider = $this->getProvider($userChecker);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock())\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticateWhenPostCheckAuthenticationFails()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException');\n        $this->expectExceptionMessage('Bad credentials.');\n        $provider = $this->getProvider();\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock())\n        ;\n        $provider->expects($this->once())\n                 ->method('checkAuthentication')\n                 ->willThrowException(new CredentialsExpiredException())\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticateWhenPostCheckAuthenticationFailsWithHideFalse()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException');\n        $this->expectExceptionMessage('Foo');\n        $provider = $this->getProvider(false, false);\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock())\n        ;\n        $provider->expects($this->once())\n                 ->method('checkAuthentication')\n                 ->willThrowException(new BadCredentialsException('Foo'))\n        ;\n\n        $provider->authenticate($this->getSupportedToken());\n    }\n\n    public function testAuthenticate()\n    {\n        $user = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock();\n        $user->expects($this->once())\n             ->method('getRoles')\n             ->willReturn(['ROLE_FOO'])\n        ;\n\n        $provider = $this->getProvider();\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($user)\n        ;\n\n        $token = $this->getSupportedToken();\n        $token->expects($this->once())\n              ->method('getCredentials')\n              ->willReturn('foo')\n        ;\n\n        $token->expects($this->once())\n              ->method('getRoles')\n              ->willReturn([])\n        ;\n\n        $authToken = $provider->authenticate($token);\n\n        $this->assertInstanceOf('Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken', $authToken);\n        $this->assertSame($user, $authToken->getUser());\n        $this->assertEquals([new Role('ROLE_FOO')], $authToken->getRoles());\n        $this->assertEquals('foo', $authToken->getCredentials());\n        $this->assertEquals(['foo' => 'bar'], $authToken->getAttributes(), '->authenticate() copies token attributes');\n    }\n\n    public function testAuthenticateWithPreservingRoleSwitchUserRole()\n    {\n        $user = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserInterface')->getMock();\n        $user->expects($this->once())\n             ->method('getRoles')\n             ->willReturn(['ROLE_FOO'])\n        ;\n\n        $provider = $this->getProvider();\n        $provider->expects($this->once())\n                 ->method('retrieveUser')\n                 ->willReturn($user)\n        ;\n\n        $token = $this->getSupportedToken();\n        $token->expects($this->once())\n              ->method('getCredentials')\n              ->willReturn('foo')\n        ;\n\n        $switchUserRole = new SwitchUserRole('foo', $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock());\n        $token->expects($this->once())\n              ->method('getRoles')\n              ->willReturn([$switchUserRole])\n        ;\n\n        $authToken = $provider->authenticate($token);\n\n        $this->assertInstanceOf('Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken', $authToken);\n        $this->assertSame($user, $authToken->getUser());\n        $this->assertContainsEquals(new Role('ROLE_FOO'), $authToken->getRoles());\n        $this->assertContainsEquals($switchUserRole, $authToken->getRoles());\n        $this->assertEquals('foo', $authToken->getCredentials());\n        $this->assertEquals(['foo' => 'bar'], $authToken->getAttributes(), '->authenticate() copies token attributes');\n    }\n\n    protected function getSupportedToken()\n    {\n        $mock = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken')->setMethods(['getCredentials', 'getProviderKey', 'getRoles'])->disableOriginalConstructor()->getMock();\n        $mock\n            ->expects($this->any())\n            ->method('getProviderKey')\n            ->willReturn('key')\n        ;\n\n        $mock->setAttributes(['foo' => 'bar']);\n\n        return $mock;\n    }\n\n    protected function getProvider($userChecker = false, $hide = true)\n    {\n        if (false === $userChecker) {\n            $userChecker = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\User\\UserCheckerInterface')->getMock();\n        }\n\n        return $this->getMockForAbstractClass('Symfony\\Component\\Security\\Core\\Authentication\\Provider\\UserAuthenticationProvider', [$userChecker, 'key', $hide]);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Guard\\Firewall;\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\GetResponseEvent;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Exception\\AccountStatusException;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException;\nuse Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException;\nuse Symfony\\Component\\Security\\Core\\Exception\\UsernameNotFoundException;\nuse Symfony\\Component\\Security\\Guard\\AbstractGuardAuthenticator;\nuse Symfony\\Component\\Security\\Guard\\AuthenticatorInterface;\nuse Symfony\\Component\\Security\\Guard\\GuardAuthenticatorHandler;\nuse Symfony\\Component\\Security\\Guard\\GuardAuthenticatorInterface;\nuse Symfony\\Component\\Security\\Guard\\Token\\PreAuthenticationGuardToken;\nuse Symfony\\Component\\Security\\Http\\Firewall\\ListenerInterface;\nuse Symfony\\Component\\Security\\Http\\RememberMe\\RememberMeServicesInterface;\n\n/**\n * Authentication listener for the \"guard\" system.\n *\n * @author Ryan Weaver <ryan@knpuniversity.com>\n * @author Amaury Leroux de Lens <amaury@lerouxdelens.com>\n */\nclass GuardAuthenticationListener implements ListenerInterface\n{\n    private $guardHandler;\n    private $authenticationManager;\n    private $providerKey;\n    private $guardAuthenticators;\n    private $logger;\n    private $rememberMeServices;\n    private $hideUserNotFoundExceptions;\n\n    /**\n     * @param GuardAuthenticatorHandler         $guardHandler          The Guard handler\n     * @param AuthenticationManagerInterface    $authenticationManager An AuthenticationManagerInterface instance\n     * @param string                            $providerKey           The provider (i.e. firewall) key\n     * @param iterable|AuthenticatorInterface[] $guardAuthenticators   The authenticators, with keys that match what's passed to GuardAuthenticationProvider\n     * @param LoggerInterface                   $logger                A LoggerInterface instance\n     */\n    public function __construct(GuardAuthenticatorHandler $guardHandler, AuthenticationManagerInterface $authenticationManager, $providerKey, $guardAuthenticators, LoggerInterface $logger = null, $hideUserNotFoundExceptions = true)\n    {\n        if (empty($providerKey)) {\n            throw new \\InvalidArgumentException('$providerKey must not be empty.');\n        }\n\n        $this->guardHandler = $guardHandler;\n        $this->authenticationManager = $authenticationManager;\n        $this->providerKey = $providerKey;\n        $this->guardAuthenticators = $guardAuthenticators;\n        $this->logger = $logger;\n        $this->hideUserNotFoundExceptions = $hideUserNotFoundExceptions;\n    }\n\n    /**\n     * Iterates over each authenticator to see if each wants to authenticate the request.\n     */\n    public function handle(GetResponseEvent $event)\n    {\n        if (null !== $this->logger) {\n            $context = ['firewall_key' => $this->providerKey];\n\n            if ($this->guardAuthenticators instanceof \\Countable || \\is_array($this->guardAuthenticators)) {\n                $context['authenticators'] = \\count($this->guardAuthenticators);\n            }\n\n            $this->logger->debug('Checking for guard authentication credentials.', $context);\n        }\n\n        foreach ($this->guardAuthenticators as $key => $guardAuthenticator) {\n            // get a key that's unique to *this* guard authenticator\n            // this MUST be the same as GuardAuthenticationProvider\n            $uniqueGuardKey = $this->providerKey.'_'.$key;\n\n            $this->executeGuardAuthenticator($uniqueGuardKey, $guardAuthenticator, $event);\n\n            if ($event->hasResponse()) {\n                if (null !== $this->logger) {\n                    $this->logger->debug('The \"{authenticator}\" authenticator set the response. Any later authenticator will not be called', ['authenticator' => \\get_class($guardAuthenticator)]);\n                }\n\n                break;\n            }\n        }\n    }\n\n    private function executeGuardAuthenticator($uniqueGuardKey, GuardAuthenticatorInterface $guardAuthenticator, GetResponseEvent $event)\n    {\n        $request = $event->getRequest();\n        try {\n            // abort the execution of the authenticator if it doesn't support the request\n            if ($guardAuthenticator instanceof AuthenticatorInterface) {\n                if (null !== $this->logger) {\n                    $this->logger->debug('Checking support on guard authenticator.', ['firewall_key' => $this->providerKey, 'authenticator' => \\get_class($guardAuthenticator)]);\n                }\n\n                if (!$guardAuthenticator->supports($request)) {\n                    if (null !== $this->logger) {\n                        $this->logger->debug('Guard authenticator does not support the request.', ['firewall_key' => $this->providerKey, 'authenticator' => \\get_class($guardAuthenticator)]);\n                    }\n\n                    return;\n                }\n                // as there was a support for given request,\n                // authenticator is expected to give not-null credentials.\n                $credentialsCanBeNull = false;\n            } else {\n                // deprecated since version 3.4, to be removed in 4.0\n                $credentialsCanBeNull = true;\n            }\n\n            if (null !== $this->logger) {\n                $this->logger->debug('Calling getCredentials() on guard authenticator.', ['firewall_key' => $this->providerKey, 'authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            // allow the authenticator to fetch authentication info from the request\n            $credentials = $guardAuthenticator->getCredentials($request);\n\n            if (null === $credentials) {\n                // deprecated since version 3.4, to be removed in 4.0\n                if ($credentialsCanBeNull) {\n                    return;\n                }\n\n                if ($guardAuthenticator instanceof AbstractGuardAuthenticator) {\n                    @trigger_error(sprintf('Returning null from \"%1$s::getCredentials()\" is deprecated since Symfony 3.4 and will throw an \\UnexpectedValueException in 4.0. Return false from \"%1$s::supports()\" instead.', \\get_class($guardAuthenticator)), \\E_USER_DEPRECATED);\n\n                    return;\n                }\n\n                throw new \\UnexpectedValueException(sprintf('The return value of \"%1$s::getCredentials()\" must not be null. Return false from \"%1$s::supports()\" instead.', \\get_class($guardAuthenticator)));\n            }\n\n            // create a token with the unique key, so that the provider knows which authenticator to use\n            $token = new PreAuthenticationGuardToken($credentials, $uniqueGuardKey);\n\n            if (null !== $this->logger) {\n                $this->logger->debug('Passing guard token information to the GuardAuthenticationProvider', ['firewall_key' => $this->providerKey, 'authenticator' => \\get_class($guardAuthenticator)]);\n            }\n            // pass the token into the AuthenticationManager system\n            // this indirectly calls GuardAuthenticationProvider::authenticate()\n            $token = $this->authenticationManager->authenticate($token);\n\n            if (null !== $this->logger) {\n                $this->logger->info('Guard authentication successful!', ['token' => $token, 'authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            // sets the token on the token storage, etc\n            $this->guardHandler->authenticateWithToken($token, $request, $this->providerKey);\n        } catch (AuthenticationException $e) {\n            // oh no! Authentication failed!\n\n            if (null !== $this->logger) {\n                $this->logger->info('Guard authentication failed.', ['exception' => $e, 'authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            // Avoid leaking error details in case of invalid user (e.g. user not found or invalid account status)\n            // to prevent user enumeration via response content\n            if ($this->hideUserNotFoundExceptions && ($e instanceof UsernameNotFoundException || $e instanceof AccountStatusException)) {\n                $e = new BadCredentialsException('Bad credentials.', 0, $e);\n            }\n\n            $response = $this->guardHandler->handleAuthenticationFailure($e, $request, $guardAuthenticator, $this->providerKey);\n\n            if ($response instanceof Response) {\n                $event->setResponse($response);\n            }\n\n            return;\n        }\n\n        // success!\n        $response = $this->guardHandler->handleAuthenticationSuccess($token, $request, $guardAuthenticator, $this->providerKey);\n        if ($response instanceof Response) {\n            if (null !== $this->logger) {\n                $this->logger->debug('Guard authenticator set success response.', ['response' => $response, 'authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            $event->setResponse($response);\n        } else {\n            if (null !== $this->logger) {\n                $this->logger->debug('Guard authenticator set no success response: request continues.', ['authenticator' => \\get_class($guardAuthenticator)]);\n            }\n        }\n\n        // attempt to trigger the remember me functionality\n        $this->triggerRememberMe($guardAuthenticator, $request, $token, $response);\n    }\n\n    /**\n     * Should be called if this listener will support remember me.\n     */\n    public function setRememberMeServices(RememberMeServicesInterface $rememberMeServices)\n    {\n        $this->rememberMeServices = $rememberMeServices;\n    }\n\n    /**\n     * Checks to see if remember me is supported in the authenticator and\n     * on the firewall. If it is, the RememberMeServicesInterface is notified.\n     */\n    private function triggerRememberMe(GuardAuthenticatorInterface $guardAuthenticator, Request $request, TokenInterface $token, Response $response = null)\n    {\n        if (null === $this->rememberMeServices) {\n            if (null !== $this->logger) {\n                $this->logger->debug('Remember me skipped: it is not configured for the firewall.', ['authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            return;\n        }\n\n        if (!$guardAuthenticator->supportsRememberMe()) {\n            if (null !== $this->logger) {\n                $this->logger->debug('Remember me skipped: your authenticator does not support it.', ['authenticator' => \\get_class($guardAuthenticator)]);\n            }\n\n            return;\n        }\n\n        if (!$response instanceof Response) {\n            throw new \\LogicException(sprintf('\"%s::onAuthenticationSuccess()\" *must* return a Response if you want to use the remember me functionality. Return a Response, or set remember_me to false under the guard configuration.', \\get_class($guardAuthenticator)));\n        }\n\n        $this->rememberMeServices->loginSuccess($request, $response, $token);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Guard\\Tests\\Firewall;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException;\nuse Symfony\\Component\\Security\\Core\\Exception\\BadCredentialsException;\nuse Symfony\\Component\\Security\\Core\\Exception\\LockedException;\nuse Symfony\\Component\\Security\\Core\\Exception\\UsernameNotFoundException;\nuse Symfony\\Component\\Security\\Guard\\AbstractGuardAuthenticator;\nuse Symfony\\Component\\Security\\Guard\\AuthenticatorInterface;\nuse Symfony\\Component\\Security\\Guard\\Firewall\\GuardAuthenticationListener;\nuse Symfony\\Component\\Security\\Guard\\GuardAuthenticatorInterface;\nuse Symfony\\Component\\Security\\Guard\\Token\\PreAuthenticationGuardToken;\n\n/**\n * @author Ryan Weaver <weaverryan@gmail.com>\n * @author Amaury Leroux de Lens <amaury@lerouxdelens.com>\n */\nclass GuardAuthenticationListenerTest extends TestCase\n{\n    private $authenticationManager;\n    private $guardAuthenticatorHandler;\n    private $event;\n    private $logger;\n    private $request;\n    private $rememberMeServices;\n\n    public function testHandleSuccess()\n    {\n        $authenticator = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $authenticateToken = $this->getMockBuilder(TokenInterface::class)->getMock();\n        $providerKey = 'my_firewall';\n\n        $credentials = ['username' => 'weaverryan', 'password' => 'all_your_base'];\n\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(true);\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->with($this->equalTo($this->request))\n            ->willReturn($credentials);\n\n        // a clone of the token that should be created internally\n        $uniqueGuardKey = 'my_firewall_0';\n        $nonAuthedToken = new PreAuthenticationGuardToken($credentials, $uniqueGuardKey);\n\n        $this->authenticationManager\n            ->expects($this->once())\n            ->method('authenticate')\n            ->with($this->equalTo($nonAuthedToken))\n            ->willReturn($authenticateToken);\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('authenticateWithToken')\n            ->with($authenticateToken, $this->request);\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('handleAuthenticationSuccess')\n            ->with($authenticateToken, $this->request, $authenticator, $providerKey);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->setRememberMeServices($this->rememberMeServices);\n        // should never be called - our handleAuthenticationSuccess() does not return a Response\n        $this->rememberMeServices\n            ->expects($this->never())\n            ->method('loginSuccess');\n\n        $listener->handle($this->event);\n    }\n\n    public function testHandleSuccessStopsAfterResponseIsSet()\n    {\n        $authenticator1 = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $authenticator2 = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n\n        // mock the first authenticator to fail, and set a Response\n        $authenticator1\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(true);\n        $authenticator1\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willThrowException(new AuthenticationException());\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('handleAuthenticationFailure')\n            ->willReturn(new Response());\n        // the second authenticator should *never* be called\n        $authenticator2\n            ->expects($this->never())\n            ->method('getCredentials');\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            'my_firewall',\n            [$authenticator1, $authenticator2],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    public function testHandleSuccessWithRememberMe()\n    {\n        $authenticator = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $authenticateToken = $this->getMockBuilder(TokenInterface::class)->getMock();\n        $providerKey = 'my_firewall_with_rememberme';\n\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->with($this->equalTo($this->request))\n            ->willReturn(true);\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->with($this->equalTo($this->request))\n            ->willReturn(['username' => 'anything_not_empty']);\n\n        $this->authenticationManager\n            ->expects($this->once())\n            ->method('authenticate')\n            ->willReturn($authenticateToken);\n\n        $successResponse = new Response('Success!');\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('handleAuthenticationSuccess')\n            ->willReturn($successResponse);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->setRememberMeServices($this->rememberMeServices);\n        $authenticator->expects($this->once())\n            ->method('supportsRememberMe')\n            ->willReturn(true);\n        // should be called - we do have a success Response\n        $this->rememberMeServices\n            ->expects($this->once())\n            ->method('loginSuccess');\n\n        $listener->handle($this->event);\n    }\n\n    public function testHandleCatchesAuthenticationException()\n    {\n        $authenticator = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $providerKey = 'my_firewall2';\n\n        $authException = new AuthenticationException('Get outta here crazy user with a bad password!');\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(true);\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willThrowException($authException);\n\n        // this is not called\n        $this->authenticationManager\n            ->expects($this->never())\n            ->method('authenticate');\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('handleAuthenticationFailure')\n            ->with($authException, $this->request, $authenticator, $providerKey);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    /**\n     * @dataProvider exceptionsToHide\n     */\n    public function testHandleHidesInvalidUserExceptions(AuthenticationException $exceptionToHide)\n    {\n        $authenticator = $this->createMock(AuthenticatorInterface::class);\n        $providerKey = 'my_firewall2';\n\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(true);\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willReturn(['username' => 'robin', 'password' => 'hood']);\n\n        $this->authenticationManager\n            ->expects($this->once())\n            ->method('authenticate')\n            ->willThrowException($exceptionToHide);\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('handleAuthenticationFailure')\n            ->with($this->callback(function ($e) use ($exceptionToHide) {\n                return $e instanceof BadCredentialsException && $exceptionToHide === $e->getPrevious();\n            }), $this->request, $authenticator, $providerKey);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    public function exceptionsToHide()\n    {\n        return [\n            [new UsernameNotFoundException()],\n            [new LockedException()],\n        ];\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyInterfaceNullCredentials()\n    {\n        $authenticatorA = $this->getMockBuilder(GuardAuthenticatorInterface::class)->getMock();\n        $providerKey = 'my_firewall3';\n\n        $authenticatorA\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willReturn(null);\n\n        // this is not called\n        $this->authenticationManager\n            ->expects($this->never())\n            ->method('authenticate');\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->never())\n            ->method('handleAuthenticationSuccess');\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticatorA],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyInterfaceKeepsWorking()\n    {\n        $authenticator = $this->getMockBuilder(GuardAuthenticatorInterface::class)->getMock();\n        $authenticateToken = $this->getMockBuilder(TokenInterface::class)->getMock();\n        $providerKey = 'my_firewall';\n\n        $credentials = ['username' => 'weaverryan', 'password' => 'all_your_base'];\n\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->with($this->equalTo($this->request))\n            ->willReturn($credentials);\n\n        // a clone of the token that should be created internally\n        $uniqueGuardKey = 'my_firewall_0';\n        $nonAuthedToken = new PreAuthenticationGuardToken($credentials, $uniqueGuardKey);\n\n        $this->authenticationManager\n            ->expects($this->once())\n            ->method('authenticate')\n            ->with($this->equalTo($nonAuthedToken))\n            ->willReturn($authenticateToken);\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('authenticateWithToken')\n            ->with($authenticateToken, $this->request);\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->once())\n            ->method('handleAuthenticationSuccess')\n            ->with($authenticateToken, $this->request, $authenticator, $providerKey);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->setRememberMeServices($this->rememberMeServices);\n        // should never be called - our handleAuthenticationSuccess() does not return a Response\n        $this->rememberMeServices\n            ->expects($this->never())\n            ->method('loginSuccess');\n\n        $listener->handle($this->event);\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testReturnNullToSkipAuth()\n    {\n        $authenticatorA = $this->getMockBuilder('Symfony\\Component\\Security\\Guard\\GuardAuthenticatorInterface')->getMock();\n        $authenticatorB = $this->getMockBuilder('Symfony\\Component\\Security\\Guard\\GuardAuthenticatorInterface')->getMock();\n        $providerKey = 'my_firewall3';\n\n        $authenticatorA\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willReturn(null);\n        $authenticatorB\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willReturn(null);\n\n        // this is not called\n        $this->authenticationManager\n            ->expects($this->never())\n            ->method('authenticate');\n\n        $this->guardAuthenticatorHandler\n            ->expects($this->never())\n            ->method('handleAuthenticationSuccess');\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticatorA, $authenticatorB],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    public function testSupportsReturnFalseSkipAuth()\n    {\n        $authenticator = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $providerKey = 'my_firewall4';\n\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(false);\n\n        // this is not called\n        $authenticator\n            ->expects($this->never())\n            ->method('getCredentials');\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    public function testReturnNullFromGetCredentials()\n    {\n        $this->expectException('UnexpectedValueException');\n        $authenticator = $this->getMockBuilder(AuthenticatorInterface::class)->getMock();\n        $providerKey = 'my_firewall4';\n\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(true);\n\n        // this will raise exception\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willReturn(null);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    /**\n     * @group legacy\n     * @expectedDeprecation Returning null from \"%s::getCredentials()\" is deprecated since Symfony 3.4 and will throw an \\UnexpectedValueException in 4.0. Return false from \"%s::supports()\" instead.\n     */\n    public function testReturnNullFromGetCredentialsTriggersForAbstractGuardAuthenticatorInstances()\n    {\n        $authenticator = $this->getMockBuilder(AbstractGuardAuthenticator::class)->getMock();\n        $providerKey = 'my_firewall4';\n\n        $authenticator\n            ->expects($this->once())\n            ->method('supports')\n            ->willReturn(true);\n\n        // this will raise exception\n        $authenticator\n            ->expects($this->once())\n            ->method('getCredentials')\n            ->willReturn(null);\n\n        $listener = new GuardAuthenticationListener(\n            $this->guardAuthenticatorHandler,\n            $this->authenticationManager,\n            $providerKey,\n            [$authenticator],\n            $this->logger\n        );\n\n        $listener->handle($this->event);\n    }\n\n    protected function setUp()\n    {\n        $this->authenticationManager = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationProviderManager')\n            ->disableOriginalConstructor()\n            ->getMock();\n\n        $this->guardAuthenticatorHandler = $this->getMockBuilder('Symfony\\Component\\Security\\Guard\\GuardAuthenticatorHandler')\n            ->disableOriginalConstructor()\n            ->getMock();\n\n        $this->request = new Request([], [], [], [], [], []);\n\n        $this->event = $this->getMockBuilder('Symfony\\Component\\HttpKernel\\Event\\GetResponseEvent')\n            ->disableOriginalConstructor()\n            ->setMethods(['getRequest'])\n            ->getMock();\n        $this->event\n            ->expects($this->any())\n            ->method('getRequest')\n            ->willReturn($this->request);\n\n        $this->logger = $this->getMockBuilder('Psr\\Log\\LoggerInterface')->getMock();\n        $this->rememberMeServices = $this->getMockBuilder('Symfony\\Component\\Security\\Http\\RememberMe\\RememberMeServicesInterface')->getMock();\n    }\n\n    protected function tearDown()\n    {\n        $this->authenticationManager = null;\n        $this->guardAuthenticatorHandler = null;\n        $this->event = null;\n        $this->logger = null;\n        $this->request = null;\n        $this->rememberMeServices = null;\n    }\n}\n"], "filenames": ["src/Symfony/Bundle/SecurityBundle/Resources/config/guard.xml", "src/Symfony/Component/Security/Core/Authentication/Provider/UserAuthenticationProvider.php", "src/Symfony/Component/Security/Core/Tests/Authentication/Provider/UserAuthenticationProviderTest.php", "src/Symfony/Component/Security/Guard/Firewall/GuardAuthenticationListener.php", "src/Symfony/Component/Security/Guard/Tests/Firewall/GuardAuthenticationListenerTest.php"], "buggy_code_start_loc": [20, 15, 82, 19, 18], "buggy_code_end_loc": [43, 87, 128, 165, 211], "fixing_code_start_loc": [20, 16, 82, 20, 19], "fixing_code_end_loc": [45, 88, 128, 177, 263], "type": "CWE-203", "message": "Symfony is a PHP framework for web and console applications and a set of reusable PHP components. The ability to enumerate users was possible without relevant permissions due to different handling depending on whether the user existed or not when attempting to use the switch users functionality. We now ensure that 403s are returned whether the user exists or not if a user cannot switch to a user or if the user does not exist. The patch for this issue is available for branch 3.4.", "other": {"cve": {"id": "CVE-2021-21424", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-13T16:15:07.777", "lastModified": "2022-10-21T22:43:59.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Symfony is a PHP framework for web and console applications and a set of reusable PHP components. The ability to enumerate users was possible without relevant permissions due to different handling depending on whether the user existed or not when attempting to use the switch users functionality. We now ensure that 403s are returned whether the user exists or not if a user cannot switch to a user or if the user does not exist. The patch for this issue is available for branch 3.4."}, {"lang": "es", "value": "Symfony es un framework PHP para aplicaciones web y de consola y un conjunto de componentes PHP reutilizables.&#xa0;La capacidad de enumerar a los usuarios fue posible sin los permisos pertinentes debido al manejo diferente dependiendo de si el usuario exist\u00eda o no al intentar usar la funcionalidad switch users.&#xa0;Ahora nos aseguramos de que los 403 sean retornados independientemente de que el usuario exista o no si un usuario no puede cambiar a un usuario o si el usuario no existe.&#xa0;El parche para este problema est\u00e1 disponible para la rama 3.4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "3.4.48", "matchCriteriaId": "2EB740DF-3B50-4D03-8C88-136F0ED45E9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.4.23", "matchCriteriaId": "DE9FB0C5-08F0-4D7D-B9B1-0D6347A04E63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2.8", "matchCriteriaId": "80C5BB06-3309-4F71-8AC9-5567AB0E3149"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://github.com/symfony/symfony/commit/2a581d22cc621b33d5464ed65c4bc2057f72f011", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/symfony/symfony/security/advisories/GHSA-5pv8-ppvj-4h68", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KENRNLB3FYXYGDWRBH2PDBOZZKOD7VY4/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RH7TMM5CHQYBFFGXWRPJDPB3SKCZXI2M/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UC7BND775DVZDQT3RMGD2HVB2PKLJDJW/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VRUS2H2SSOQWNLBD35SKIWIDQEMV2PD3/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/symfony/symfony/commit/2a581d22cc621b33d5464ed65c4bc2057f72f011"}}